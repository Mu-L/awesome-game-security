Project Path: arc_freemint_fdlibm_7oqtb43s

Source Tree:

```txt
arc_freemint_fdlibm_7oqtb43s
├── MD5
├── Makefile.in
├── Product-Info
├── README.md
├── config-aux
│   ├── config.guess
│   ├── config.sub
│   ├── install-sh
│   └── mkinstalldirs
├── configure
├── configure.in
├── e_acos.c
├── e_acosf.c
├── e_acosh.c
├── e_acoshf.c
├── e_acoshl.c
├── e_acosl.c
├── e_asin.c
├── e_asinf.c
├── e_asinl.c
├── e_atan2.c
├── e_atan2f.c
├── e_atan2l.c
├── e_atanh.c
├── e_atanhf.c
├── e_atanhl.c
├── e_cosh.c
├── e_coshf.c
├── e_coshl.c
├── e_exp.c
├── e_exp10.c
├── e_exp10f.c
├── e_exp10l.c
├── e_exp2.c
├── e_exp2f.c
├── e_exp2l.c
├── e_expf.c
├── e_expl.c
├── e_fmod.c
├── e_fmodf.c
├── e_fmodl.c
├── e_hypot.c
├── e_hypotf.c
├── e_hypotl.c
├── e_ilogb.c
├── e_ilogbf.c
├── e_ilogbl.c
├── e_j0.c
├── e_j0f.c
├── e_j0l.c
├── e_j1.c
├── e_j1f.c
├── e_j1l.c
├── e_jn.c
├── e_jnf.c
├── e_jnl.c
├── e_lgamma.c
├── e_lgamma_r.c
├── e_lgammaf.c
├── e_lgammaf_r.c
├── e_lgammal.c
├── e_lgammal_r.c
├── e_log.c
├── e_log10.c
├── e_log10f.c
├── e_log10l.c
├── e_log2.c
├── e_log2f.c
├── e_log2l.c
├── e_logf.c
├── e_logl.c
├── e_pow.c
├── e_powf.c
├── e_powi.c
├── e_powif.c
├── e_powil.c
├── e_powl.c
├── e_rem_pio2.c
├── e_rem_pio2f.c
├── e_rem_pio2l.c
├── e_remainder.c
├── e_remainderf.c
├── e_remainderl.c
├── e_scalb.c
├── e_scalbf.c
├── e_scalbl.c
├── e_sinh.c
├── e_sinhf.c
├── e_sinhl.c
├── e_sqrt.c
├── e_sqrtf.c
├── e_sqrtl.c
├── e_tgamma_r.c
├── e_tgammaf_r.c
├── e_tgammal_r.c
├── e_y0.c
├── e_y0f.c
├── e_y0l.c
├── e_y1.c
├── e_y1f.c
├── e_y1l.c
├── e_yn.c
├── e_ynf.c
├── e_ynl.c
├── feclearexcept.c
├── fedisableexcept.c
├── feenableexcept.c
├── fegetenv.c
├── fegetexcept.c
├── fegetexceptflag.c
├── fegetround.c
├── feholdexcept.c
├── feraiseexcept.c
├── fesetenv.c
├── fesetexceptflag.c
├── fesetround.c
├── fetestexcept.c
├── feupdateenv.c
├── fpu_ctrl.c
├── fpu_ctrl.h
├── include
│   ├── asm
│   │   └── ieee754
│   │       ├── i386.h
│   │       ├── m68k.h
│   │       ├── m68k_ahcc.h
│   │       ├── m68k_cf.h
│   │       ├── m68k_pc.h
│   │       ├── x86_64.h
│   │       └── x86l.h
│   ├── bits
│   │   ├── fenv.h
│   │   ├── fenvinline.h
│   │   ├── fpu_control.h
│   │   ├── huge_val.h
│   │   ├── inf.h
│   │   ├── m68k
│   │   │   ├── fenv.h
│   │   │   └── fpu_control.h
│   │   ├── math-68881.h
│   │   ├── math-cffpu.h
│   │   ├── mathcall.h
│   │   ├── mathdef.h
│   │   ├── nan.h
│   │   └── x86
│   │       └── fenv.h
│   ├── fdlibm.h
│   ├── fenv.h
│   ├── fpu_control.h
│   ├── k_stand.h
│   └── math.h
├── index
├── index.html
├── k_cos.c
├── k_cosf.c
├── k_cosl.c
├── k_rem_pio2.c
├── k_rem_pio2f.c
├── k_rem_pio2l.c
├── k_sin.c
├── k_sinf.c
├── k_sinl.c
├── k_standard.c
├── k_tan.c
├── k_tanf.c
├── k_tanl.c
├── makefile.sunsoft
├── manifests
│   ├── bin
│   └── src
├── readme
├── s_asinh.c
├── s_asinhf.c
├── s_asinhl.c
├── s_atan.c
├── s_atanf.c
├── s_atanl.c
├── s_cbrt.c
├── s_cbrtf.c
├── s_cbrtl.c
├── s_ceil.c
├── s_ceilf.c
├── s_ceill.c
├── s_copysign.c
├── s_copysignf.c
├── s_copysignl.c
├── s_cos.c
├── s_cosf.c
├── s_cosl.c
├── s_erf.c
├── s_erfc.c
├── s_erfcf.c
├── s_erfcl.c
├── s_erff.c
├── s_erfl.c
├── s_expm1.c
├── s_expm1f.c
├── s_expm1l.c
├── s_fabs.c
├── s_fabsf.c
├── s_fabsl.c
├── s_fdim.c
├── s_fdimf.c
├── s_fdiml.c
├── s_finite.c
├── s_finitef.c
├── s_finitel.c
├── s_floor.c
├── s_floorf.c
├── s_floorl.c
├── s_fmax.c
├── s_fmaxf.c
├── s_fmaxl.c
├── s_fmin.c
├── s_fminf.c
├── s_fminl.c
├── s_fpclassify.c
├── s_fpclassifyf.c
├── s_fpclassifyl.c
├── s_frexp.c
├── s_frexpf.c
├── s_frexpl.c
├── s_isinf.c
├── s_isinff.c
├── s_isinfl.c
├── s_isnan.c
├── s_isnanf.c
├── s_isnanl.c
├── s_issig.c
├── s_issigf.c
├── s_issigl.c
├── s_ldexp.c
├── s_ldexpf.c
├── s_ldexpl.c
├── s_lib_version.c
├── s_llrint.c
├── s_llrintf.c
├── s_llrintl.c
├── s_llround.c
├── s_llroundf.c
├── s_llroundl.c
├── s_log1p.c
├── s_log1pf.c
├── s_log1pl.c
├── s_logb.c
├── s_logbf.c
├── s_logbl.c
├── s_lrint.c
├── s_lrintf.c
├── s_lrintl.c
├── s_lround.c
├── s_lroundf.c
├── s_lroundl.c
├── s_matherr.c
├── s_modf.c
├── s_modff.c
├── s_modfl.c
├── s_nearbyint.c
├── s_nearbyintf.c
├── s_nearbyintl.c
├── s_nextafter.c
├── s_nextafterf.c
├── s_nextafterl.c
├── s_nexttoward.c
├── s_nexttowardf.c
├── s_pone.c
├── s_ponef.c
├── s_ponel.c
├── s_pzero.c
├── s_pzerof.c
├── s_pzerol.c
├── s_remquo.c
├── s_remquof.c
├── s_remquol.c
├── s_rint.c
├── s_rintf.c
├── s_rintl.c
├── s_round.c
├── s_roundf.c
├── s_roundl.c
├── s_scalbln.c
├── s_scalblnf.c
├── s_scalblnl.c
├── s_scalbn.c
├── s_scalbnf.c
├── s_scalbnl.c
├── s_signgam.c
├── s_significand.c
├── s_significandf.c
├── s_significandl.c
├── s_sin.c
├── s_sincos.c
├── s_sincosf.c
├── s_sincosl.c
├── s_sinf.c
├── s_sinl.c
├── s_tan.c
├── s_tanf.c
├── s_tanh.c
├── s_tanhf.c
├── s_tanhl.c
├── s_tanl.c
├── s_trunc.c
├── s_truncf.c
├── s_truncl.c
├── t_erf.h
├── t_erff.h
├── t_erfl.h
├── t_exp2.h
├── t_exp2f.h
├── t_expf.h
├── t_sincosl.c
├── tests
│   ├── README.txt
│   ├── acos.c
│   ├── acosh.c
│   ├── asin.c
│   ├── asinh.c
│   ├── atan.c
│   ├── atan2.c
│   ├── atanh.c
│   ├── cbrt.c
│   ├── ceil.c
│   ├── cos.c
│   ├── cosh.c
│   ├── csign.c
│   ├── drem.c
│   ├── erf.c
│   ├── erfc.c
│   ├── exp.c
│   ├── exp10.c
│   ├── exp2.c
│   ├── expm1.c
│   ├── fabs.c
│   ├── fadd.c
│   ├── fcmp.c
│   ├── fdim.c
│   ├── fdiv.c
│   ├── finite.c
│   ├── floor.c
│   ├── fma.c
│   ├── fmax.c
│   ├── fmin.c
│   ├── fmod.c
│   ├── fmul.c
│   ├── fneg.c
│   ├── fpclass.c
│   ├── frexp.c
│   ├── fsub.c
│   ├── hypot.c
│   ├── ilogb.c
│   ├── isfini.c
│   ├── isgr.c
│   ├── isgreq.c
│   ├── isinf.c
│   ├── isls.c
│   ├── islseq.c
│   ├── islsgr.c
│   ├── isnan.c
│   ├── isnorm.c
│   ├── issign.c
│   ├── isunor.c
│   ├── j0.c
│   ├── j1.c
│   ├── jn.c
│   ├── ldexp.c
│   ├── lgamma.c
│   ├── llrint.c
│   ├── llround.c
│   ├── log.c
│   ├── log10.c
│   ├── log1p.c
│   ├── log2.c
│   ├── logb.c
│   ├── lrint.c
│   ├── lround.c
│   ├── modf.c
│   ├── nearby.c
│   ├── nextaf.c
│   ├── nextto.c
│   ├── pow.c
│   ├── remain.c
│   ├── remquo.c
│   ├── rint.c
│   ├── round.c
│   ├── scalb.c
│   ├── scbln.c
│   ├── scbn.c
│   ├── signb.c
│   ├── signi.c
│   ├── sin.c
│   ├── sincos.c
│   ├── sinh.c
│   ├── sqrt.c
│   ├── tan.c
│   ├── tanh.c
│   ├── testcomplex.h
│   ├── testconfig.h
│   ├── testdriver.h
│   ├── tgamma.c
│   ├── trunc.c
│   ├── y0.c
│   ├── y1.c
│   └── yn.c
├── truncxfdf2.c
├── w_gamma.c
├── w_gamma_r.c
├── w_gammaf.c
├── w_gammaf_r.c
├── w_gammal.c
├── w_gammal_r.c
├── w_lgamma.c
├── w_lgamma_r.c
├── w_lgammaf.c
├── w_lgammaf_r.c
├── w_lgammal.c
├── w_lgammal_r.c
├── w_tgamma.c
├── w_tgammaf.c
└── w_tgammal.c

```

`MD5`:

```
-----BEGIN PGP SIGNED MESSAGE-----

# netlib-bl master Thu Apr 11 12:56:10 EDT 1996
BA60PiTRdtDExrFWVYR+9Q	.depend
8S+7LjhQzPQB7ezglQm2yg	.master
N+ATV/pciCNVs3dSJLzz/Q	dependencies
P2sEgHh/v3RHTsLuS1UeTw	e_acos.c
SReAT7diAMhuAtChHm1nLQ	e_acosh.c
xsqL2/A2cuTbG4ZabFtgQg	e_asin.c
uXwtBvNUrnsWp2lWS/ZPzg	e_atan2.c
7+Zmokqk6yU+4B/dPWLVnQ	e_atanh.c
FFRFIVaqeYuPIbZDy+GPLQ	e_cosh.c
QoYw5v0PHYAt5cU28TGHdQ	e_exp.c
ladlzVeoGGhd+r/RvPJUsw	e_fmod.c
WwWDDWUnqoeniw5c6ShWUQ	e_gamma.c
+rYzLHXdv60VBR9GpEVA7Q	e_gamma_r.c
BUemgwLOjQ2tpsWv8fQOWA	e_hypot.c
um0j/BMMHd0mEzOIg/iTIw	e_j0.c
023e/9GjB47rNsYlxW9/Ug	e_j1.c
X2UtLCi/Hg5Xx0ZAiaUHXQ	e_jn.c
bBStzzLdDSzNsVlhy/Isdw	e_lgamma.c
pYie2c6jvQAObJMq2IhNGQ	e_lgamma_r.c
mj6pKYX+E8euiAP6577R4A	e_log.c
fEuDo4brNfU8HRqvM0syqQ	e_log10.c
AbafUflu9RYPDEPxXHaKOg	e_pow.c
L/2ye70MqZA7YqsCtgMQlQ	e_rem_pio2.c
kdemnBPRKpa3661lnjEcyw	e_remainder.c
DW4MDjGPgkJLg4PBGX5yGg	e_scalb.c
LiW0gFPaN5JVIuQZW4XbVQ	e_sinh.c
JPBrE86qzL59qF5PFCDA/Q	e_sqrt.c
I3+l1PmPMBhQNfWuDhA0mA	fdlibm.h
G21yQjn+xOAex15TPeLfBQ	index
sDIZFCqsPOqSl9ykcjky8w	k_cos.c
1t3fuGir+TOYRAO0N8Chng	k_rem_pio2.c
1Fi/fEeHcsIq50vVplKVzQ	k_sin.c
1ufaWqW1PRP1cOuPtb7O7A	k_standard.c
aiVKPl8c6cs/Aoh7XUS0zA	k_tan.c
wDXTC07GG4Bd+EnUjk/MVw	makefile
KDrKTBZOuKKe0jq9qqG6Tg	readme
WDSYQ245qaKiYXtEn9qSdg	s_asinh.c
ucf0ncFkne9OW4Uv+CxRrQ	s_atan.c
w2/WG3x7j7+b9uydji3FZg	s_cbrt.c
YqCYHnPBw1dDvbYwjWJNbw	s_ceil.c
JX6gTEPMyjuTQclyjiLC2w	s_copysign.c
91ARVh9L6LTc2i9VGu9DSg	s_cos.c
0Jwhkbo/6ewEss7CW1PI9w	s_erf.c
Zufy+no5pUoNOHgplAipyA	s_expm1.c
K6LRiJVYLNzThuQaOyibVA	s_fabs.c
uvNnsV4Fmj90jAbySXd54w	s_finite.c
etEc6khe9K27aeE+6ZpW0A	s_floor.c
5KDyugUMkjOsPsq6fygPjg	s_frexp.c
UWvuamu8A+XGSwi9twc/vQ	s_ilogb.c
/KmGbiWbhyiZCru0HbLUpw	s_isnan.c
+OZ/WHEZ12FiA8mZ7hk4rA	s_ldexp.c
g33PLRuQjT5HRX4ZozySGA	s_lib_version.c
MHsSOIzpsdw4sVVtAu4GTQ	s_log1p.c
qWJm/3AkemsNi7aF295SGA	s_logb.c
QGkKHdTmho+2Xbd0rObCmA	s_matherr.c
Tfmhq38TAJspcNpJT9Tcww	s_modf.c
k+onjlepmLUH/9xA+Wdqaw	s_nextafter.c
omWcOHAaAKLjMuuSirX8Lw	s_rint.c
6w2X17eamkvE+pCZlPm8Xg	s_scalbn.c
z93vZw0EQ1IQUSqJMRu/IA	s_signgam.c
S3OtNFaARNk7TltgUoVs+Q	s_significand.c
yYuvBWZCWR0Y/YT6pmIr0w	s_sin.c
LhJVti8VVlaWbptWR88XGg	s_tan.c
QfLTJ1iGqgC7RhZWHi0PTQ	s_tanh.c
vR2IBXoLtHZh+GHCV+Iydg	w_acos.c
ZbhbPlbMYiu8Z1NXaDiPDQ	w_acosh.c
KsvLAMHSqu1b72p5kYkJyQ	w_asin.c
ENaJir3y0hZ4yWWKzBs89w	w_atan2.c
+jLlTCXpNVY6yuncPyfWyw	w_atanh.c
84kcBUnnIU16mG+cChPbRA	w_cosh.c
Y48Ptgaq0V9/MStWX8iZMA	w_exp.c
WQG0A3Gk/MlFkjx4h3yw6Q	w_fmod.c
MNIqntvhf0fvFvKfzcPR1g	w_gamma.c
TnrF3OPpiAEUymzT0PZiDw	w_gamma_r.c
OLFqJDwkIZmIF7vm6BQuGQ	w_hypot.c
cvayKIzuZlCxTj6dLXe+qQ	w_j0.c
PB3rNmFTtPoMICeJFkAMeg	w_j1.c
7qCc7gGMiRIp1GY0UQ3gLg	w_jn.c
8URUp8BmBP32s79GRllwdw	w_lgamma.c
AJyN8jlYXVe1Dwx+w6qlEQ	w_lgamma_r.c
8fmXSpy3xt0Mgd+9BkKHRg	w_log.c
/+qteyYx+IKTmLuv1fxqPQ	w_log10.c
+o/ImP/JfknQmSxM4TA1ag	w_pow.c
BkF5AkqkRA4Py2Y1p0bQIA	w_remainder.c
77arOaApwrSQngHv26UWrg	w_scalb.c
SgGvz6WUAuHs90sDA/GDbA	w_sinh.c
2aR8vbagrVvvMtXPktM6CQ	w_sqrt.c

-----BEGIN PGP SIGNATURE-----
Version: 2.6.2

iQCVAwUBMW05rr5pvxO9gjtZAQHg/QP5Afrnwww9+I+hRs/GMoU2/veoF6XHhYFr
PLLIHdcE50wSZ4oeZxHfqerXkzvL6F5iPKEiPymWFgQiZ9ITS67ojwVukfHALR7C
g2ndcYIoyYtzKeh3Hv7GkgcfNtefkRRKZ9b2MtNCHSMsAAS/JW3huStg7TvBzrE6
zSFZXIlqNL0=
=hrlW
-----END PGP SIGNATURE-----

```

`Makefile.in`:

```in
srcdir_ = @srcdir@
ifeq ($(src_dir),)
srcdir:=$(shell (cd $(srcdir_); pwd))
else
srcdir:=$(src_dir)
endif
VPATH = $(srcdir)	#: This colon should fool config.status into not
			#: deleting VPATH when srcdir = .
cpu=$(word 1, $(subst ., ,$(CPU-FPU)))
ifeq ($(cpu),5475)
	CPU=-mcpu=$(cpu)
else
	CPU=-m$(cpu)
endif
FLAVOUR=$(addprefix -m,$(wordlist 2,100, $(subst ., ,$(CPU-FPU))))
CC = @CC@
CFLAGS = -pipe -O2 -fomit-frame-pointer $(CPU) $(FLAVOUR) -Werror
prefix = @prefix@
exec_prefix = @exec_prefix@
libdir = $(prefix)/lib
incdir = $(prefix)/include
RANLIB = @RANLIB@
AR = @AR@
ac_aux_dir=@ac_aux_dir@
MKINSTALLDIRS = $(ac_aux_dir)/mkinstalldirs

#
# There are two options in making libm at fdlibm compile time:
# 	_IEEE_LIBM 	--- IEEE libm; smaller, and somewhat faster
#	_MULTI_LIBM	--- Support multi-standard at runtime by 
#			    imposing wrapper functions defined in 
#			    fdlibm.h:
#				_IEEE_MODE 	-- IEEE
#				_XOPEN_MODE 	-- X/OPEN
#				_POSIX_MODE 	-- POSIX/ANSI
#				_SVID3_MODE 	-- SVID
#
# Here is how to set up CFLAGS to create the desired libm at 
# compile time:
#
# 	DEFS = -D_IEEE_LIBM	... IEEE libm (recommended)
#	DEFS = -D_SVID3_MODE	... Multi-standard supported
#					    libm with SVID as the 
#					    default standard
#	DEFS = -D_XOPEN_MODE	... Multi-standard supported
#					    libm with XOPEN as the 
#					    default standard
#	DEFS = -D_POSIX_MODE	... Multi-standard supported
#					    libm with POSIX as the 
#					    default standard
#	DEFS = 			... Multi-standard supported
#					    libm with IEEE as the 
#					    default standard
# 
# NOTE: if scalb's second arguement is an int, then one must
# define _SCALB_INT in DEFS. The default prototype of scalb
# is double scalb(double, double)
#

# Multi-standard supported libm with POSIX as the default standard
DEFS=-D_IEEE_LIBM -D_REENTRANT

# Pick the CPU/FPU combinations you want
# The compiler will prefix -mCPU and -mFPU 
# so 68000.soft-float becomes -m68000 -msoft-float
CPU-FPU-TYPES = \
		68000.soft-float \
		68020-60.68881 \
		5475.hard-float \
		68000.soft-float.short \
		68020-60.68881.short \
		5475.hard-float.short

BUILD_FAST=$(shell if $(CC) -mfastcall -E - < /dev/null >/dev/null 2>&1; then echo Y; else echo N; fi)
ifeq ($(BUILD_FAST), Y)
CPU-FPU-TYPES += \
		68000.soft-float.fastcall \
		68020-60.68881.fastcall \
		5475.hard-float.fastcall \
		68000.soft-float.short.fastcall \
		68020-60.68881.short.fastcall \
		5475.hard-float.short.fastcall
endif

INCFILES = fdlibm.h k_stand.h
SRC = 	$(srcdir)/k_standard.c \
	$(srcdir)/k_rem_pio2.c $(srcdir)/k_rem_pio2f.c $(srcdir)/k_rem_pio2l.c \
	$(srcdir)/k_cos.c $(srcdir)/k_cosf.c $(srcdir)/k_cosl.c \
	$(srcdir)/k_sin.c $(srcdir)/k_sinf.c $(srcdir)/k_sinl.c \
	$(srcdir)/k_tan.c $(srcdir)/k_tanf.c $(srcdir)/k_tanl.c \
	$(srcdir)/e_acos.c $(srcdir)/e_acosf.c $(srcdir)/e_acosl.c \
	$(srcdir)/e_acosh.c $(srcdir)/e_acoshf.c $(srcdir)/e_acoshl.c \
	$(srcdir)/e_asin.c $(srcdir)/e_asinf.c $(srcdir)/e_asinl.c \
	$(srcdir)/e_atan2.c $(srcdir)/e_atan2f.c $(srcdir)/e_atan2l.c \
	$(srcdir)/e_atanh.c $(srcdir)/e_atanhf.c $(srcdir)/e_atanhl.c \
	$(srcdir)/e_cosh.c $(srcdir)/e_coshf.c $(srcdir)/e_coshl.c \
	$(srcdir)/e_exp.c $(srcdir)/e_expf.c $(srcdir)/e_expl.c \
	$(srcdir)/e_exp2.c $(srcdir)/e_exp2f.c $(srcdir)/e_exp2l.c \
	$(srcdir)/e_exp10.c $(srcdir)/e_exp10f.c $(srcdir)/e_exp10l.c \
	$(srcdir)/e_fmod.c $(srcdir)/e_fmodf.c $(srcdir)/e_fmodl.c \
	$(srcdir)/e_hypot.c $(srcdir)/e_hypotf.c $(srcdir)/e_hypotl.c \
	$(srcdir)/e_j0.c $(srcdir)/e_j0f.c $(srcdir)/e_j0l.c \
	$(srcdir)/e_j1.c $(srcdir)/e_j1f.c $(srcdir)/e_j1l.c \
	$(srcdir)/e_jn.c $(srcdir)/e_jnf.c $(srcdir)/e_jnl.c \
	$(srcdir)/e_y0.c $(srcdir)/e_y0f.c $(srcdir)/e_y0l.c \
	$(srcdir)/e_y1.c $(srcdir)/e_y1f.c $(srcdir)/e_y1l.c \
	$(srcdir)/e_yn.c $(srcdir)/e_ynf.c $(srcdir)/e_ynl.c \
	$(srcdir)/s_pzero.c $(srcdir)/s_pzerof.c $(srcdir)/s_pzerol.c \
	$(srcdir)/s_pone.c $(srcdir)/s_pone.c $(srcdir)/s_ponel.c \
	$(srcdir)/e_log.c $(srcdir)/e_logf.c $(srcdir)/e_logl.c \
	$(srcdir)/e_log2.c $(srcdir)/e_log2f.c $(srcdir)/e_log2l.c \
	$(srcdir)/e_log10.c $(srcdir)/e_log10f.c $(srcdir)/e_log10l.c \
	$(srcdir)/e_pow.c $(srcdir)/e_powf.c $(srcdir)/e_powl.c \
	$(srcdir)/e_powi.c $(srcdir)/e_powif.c $(srcdir)/e_powil.c \
	$(srcdir)/e_rem_pio2.c $(srcdir)/e_rem_pio2f.c $(srcdir)/e_rem_pio2l.c \
	$(srcdir)/e_remainder.c $(srcdir)/e_remainderf.c $(srcdir)/e_remainderl.c \
	$(srcdir)/e_scalb.c $(srcdir)/e_scalbf.c $(srcdir)/e_scalbl.c \
	$(srcdir)/e_sinh.c $(srcdir)/e_sinhf.c $(srcdir)/e_sinhl.c \
	$(srcdir)/e_sqrt.c $(srcdir)/e_sqrtf.c $(srcdir)/e_sqrtl.c \
	$(srcdir)/s_asinh.c $(srcdir)/s_asinhf.c $(srcdir)/s_asinhl.c \
	$(srcdir)/s_atan.c $(srcdir)/s_atanf.c $(srcdir)/s_atanl.c \
	$(srcdir)/s_cbrt.c $(srcdir)/s_cbrtf.c $(srcdir)/s_cbrtl.c \
	$(srcdir)/s_ceil.c $(srcdir)/s_ceilf.c $(srcdir)/s_ceill.c \
	$(srcdir)/s_copysign.c $(srcdir)/s_copysignf.c $(srcdir)/s_copysignl.c \
	$(srcdir)/s_cos.c $(srcdir)/s_cosf.c $(srcdir)/s_cosl.c \
	$(srcdir)/s_erf.c $(srcdir)/s_erff.c $(srcdir)/s_erfl.c \
	$(srcdir)/s_erfc.c $(srcdir)/s_erfcf.c $(srcdir)/s_erfcl.c \
	$(srcdir)/s_expm1.c $(srcdir)/s_expm1f.c $(srcdir)/s_expm1l.c \
	$(srcdir)/s_fabs.c $(srcdir)/s_fabsf.c $(srcdir)/s_fabsl.c \
	$(srcdir)/s_finite.c $(srcdir)/s_finitef.c $(srcdir)/s_finitel.c \
	$(srcdir)/s_floor.c $(srcdir)/s_floorf.c $(srcdir)/s_floorl.c \
	$(srcdir)/s_frexp.c $(srcdir)/s_frexpf.c $(srcdir)/s_frexpl.c \
	$(srcdir)/e_ilogb.c $(srcdir)/e_ilogbf.c $(srcdir)/e_ilogbl.c \
	$(srcdir)/s_isnan.c $(srcdir)/s_isnanf.c $(srcdir)/s_isnanl.c \
	$(srcdir)/s_isinf.c $(srcdir)/s_isinff.c $(srcdir)/s_isinfl.c \
	$(srcdir)/s_ldexp.c $(srcdir)/s_ldexpf.c $(srcdir)/s_ldexpl.c \
	$(srcdir)/s_lib_version.c \
	$(srcdir)/s_log1p.c $(srcdir)/s_log1pf.c $(srcdir)/s_log1pl.c \
	$(srcdir)/s_logb.c $(srcdir)/s_logbf.c $(srcdir)/s_logbl.c \
	$(srcdir)/s_matherr.c \
	$(srcdir)/s_modf.c $(srcdir)/s_modff.c $(srcdir)/s_modfl.c \
	$(srcdir)/s_remquo.c $(srcdir)/s_remquof.c $(srcdir)/s_remquol.c \
	$(srcdir)/s_nextafter.c $(srcdir)/s_nextafterf.c $(srcdir)/s_nextafterl.c \
	$(srcdir)/s_nexttoward.c $(srcdir)/s_nexttowardf.c \
	$(srcdir)/s_rint.c $(srcdir)/s_rintf.c $(srcdir)/s_rintl.c \
	$(srcdir)/s_lrint.c $(srcdir)/s_lrintf.c $(srcdir)/s_lrintl.c \
	$(srcdir)/s_llrint.c $(srcdir)/s_llrintf.c $(srcdir)/s_llrintl.c \
	$(srcdir)/s_scalbn.c $(srcdir)/s_scalbnf.c $(srcdir)/s_scalbnl.c \
	$(srcdir)/s_scalbln.c $(srcdir)/s_scalblnf.c $(srcdir)/s_scalblnl.c \
	$(srcdir)/s_signgam.c \
	$(srcdir)/s_significand.c $(srcdir)/s_significandf.c $(srcdir)/s_significandl.c \
	$(srcdir)/s_sin.c $(srcdir)/s_sinf.c $(srcdir)/s_sinl.c \
	$(srcdir)/s_sincos.c $(srcdir)/s_sincosf.c $(srcdir)/s_sincosl.c \
	$(srcdir)/s_tan.c $(srcdir)/s_tanf.c $(srcdir)/s_tanl.c \
	$(srcdir)/s_tanh.c $(srcdir)/s_tanhf.c $(srcdir)/s_tanhl.c \
	$(srcdir)/s_fmin.c $(srcdir)/s_fminf.c $(srcdir)/s_fminl.c \
	$(srcdir)/s_fmax.c $(srcdir)/s_fmaxf.c $(srcdir)/s_fmaxl.c \
	$(srcdir)/s_fdim.c $(srcdir)/s_fdimf.c $(srcdir)/s_fdiml.c \
	$(srcdir)/s_fpclassify.c $(srcdir)/s_fpclassifyf.c $(srcdir)/s_fpclassifyl.c \
	$(srcdir)/s_round.c $(srcdir)/s_roundf.c $(srcdir)/s_roundl.c \
	$(srcdir)/s_lround.c $(srcdir)/s_lroundf.c $(srcdir)/s_lroundl.c \
	$(srcdir)/s_llround.c $(srcdir)/s_llroundf.c $(srcdir)/s_llroundl.c \
	$(srcdir)/s_trunc.c $(srcdir)/s_truncf.c $(srcdir)/s_truncl.c \
	$(srcdir)/s_issig.c $(srcdir)/s_issigf.c $(srcdir)/s_issigl.c \
	$(srcdir)/s_nearbyint.c $(srcdir)/s_nearbyintf.c $(srcdir)/s_nearbyintl.c \
	$(srcdir)/t_sincosl.c \
	\
	$(srcdir)/e_lgamma.c $(srcdir)/e_lgammaf.c $(srcdir)/e_lgammal.c \
	$(srcdir)/e_lgamma_r.c $(srcdir)/e_lgammaf_r.c $(srcdir)/e_lgammal_r.c \
	$(srcdir)/e_tgamma_r.c $(srcdir)/e_tgammaf_r.c $(srcdir)/e_tgammal_r.c \
	$(srcdir)/w_gamma.c $(srcdir)/w_gammaf.c $(srcdir)/w_gammal.c \
	$(srcdir)/w_gamma_r.c $(srcdir)/w_gammaf_r.c $(srcdir)/w_gammal_r.c \
	$(srcdir)/w_lgamma.c $(srcdir)/w_lgammaf.c $(srcdir)/w_lgammal.c \
	$(srcdir)/w_lgamma_r.c $(srcdir)/w_lgammaf_r.c $(srcdir)/w_lgammal_r.c \
	$(srcdir)/w_tgamma.c $(srcdir)/w_tgammaf.c $(srcdir)/w_tgammal.c \
	\
	$(srcdir)/fpu_ctrl.c \
	$(srcdir)/fesetround.c \
	$(srcdir)/fegetround.c \
	$(srcdir)/fesetenv.c \
	$(srcdir)/fegetenv.c \
	$(srcdir)/feholdexcept.c \
	$(srcdir)/feupdateenv.c \
	$(srcdir)/feclearexcept.c \
	$(srcdir)/fedisableexcept.c \
	$(srcdir)/feenableexcept.c \
	$(srcdir)/fegetexcept.c \
	$(srcdir)/fegetexceptflag.c \
	$(srcdir)/feraiseexcept.c \
	$(srcdir)/fesetexceptflag.c \
	$(srcdir)/fetestexcept.c \
	\
	$(srcdir)/truncxfdf2.c \
	\
	$(empty)

OBJ = 	$(addsuffix .o, $(basename $(notdir $(SRC))))

.c.o:
	$(CC) -c $(DEFS) -I$(srcdir)/include $(CFLAGS) $< $(OUTPUT_OPTION)

all:
	for i in $(CPU-FPU-TYPES); do \
	  if [ ! -d $$i ] ; then \
	    mkdir $$i; \
	  else true; fi; \
	  (cd $$i; $(MAKE) -f ../Makefile CPU-FPU=$$i src_dir=$(srcdir) $(LIB)); \
	done

LIB = libm.a

$(LIB): $(OBJ) 
	$(AR) cru $(LIB) $(OBJ)
	$(RANLIB) $(LIB)

install: all install-headers
	@for i in $(CPU-FPU-TYPES); do \
	  if [ -d $$i ] ; then \
            cpu=`echo $$i | cut -d . -f 1`; \
            if test $$cpu = 5475; then cpu=-mcpu=$$cpu; else cpu=-m$$cpu; fi; \
            flavour=`echo "$$i" | sed -e 's/\./ -m/g' -e 's/[^ ]* //'`; \
            multilibdir=`$(CC) $$cpu $$flavour -print-multi-directory`; \
	    $(MKINSTALLDIRS) $(DESTDIR)$(libdir)/$$multilibdir; \
	    echo cp $$i/libm.a $(DESTDIR)$(libdir)/$$multilibdir/libm.a; \
	    cp $$i/libm.a $(DESTDIR)$(libdir)/$$multilibdir/libm.a; \
	  fi; \
        done

install-headers:
	mkdir -p $(DESTDIR)$(incdir)/bits/m68k
	for i in math.h fenv.h fpu_control.h; do \
		cp -a $(srcdir)/include/$$i $(DESTDIR)$(incdir) || exit 1; \
	done
	for i in fenv.h fenvinline.h huge_val.h inf.h math-68881.h math-cffpu.h mathcall.h mathdef.h nan.h fpu_control.h; do \
		cp -a $(srcdir)/include/bits/$$i $(DESTDIR)$(incdir)/bits || exit 1; \
	done
	for i in fenv.h fpu_control.h; do \
		cp -a $(srcdir)/include/bits/m68k/$$i $(DESTDIR)$(incdir)/bits/m68k || exit 1; \
	done

Makefile: $(srcdir)/Makefile.in config.status
	./config.status

check: all
	$(MAKE) -C tests $@

clean:
	$(MAKE) -C tests $@
	rm -rf a.out $(CPU-FPU-TYPES)

distclean: clean
	$(MAKE) -C tests $@
	rm -f config.cache config.status config.log Makefile
	rm -rf autom4te.cache

$(OBJ): $(srcdir)/include/fdlibm.h

```

`Product-Info`:

```
.name
fdlibm
.type
library
.short
Redistributable IEEE 754 C math library
.description
FDLIBM (Freely Distributable LIBM) is a C math library 
for machines that support IEEE 754 floating-point arithmetic. 
In this release, only double precision is supported.
.version
5.2
.author
SunSoft
.distribution
Freely Distributable
.described-by
Fred Fish (fnf@ninemoons.com)
.submittal
ftp://netlib.bell-labs.com/netlib/fdlibm

```

`README.md`:

```md
[![Build Status](https://github.com/freemint/fdlibm/actions/workflows/build.yml/badge.svg?branch=master)](https://github.com/freemint/fdlibm/actions) 

* Latest snapshot: [Download (mint)](https://tho-otto.de/snapshots/fdlibm/fdlibm-mint-latest.tar.bz2)
* Latest snapshot: [Download (mintelf)](https://tho-otto.de/snapshots/fdlibm/fdlibm-mintelf-latest.tar.bz2)
* [Archive](https://tho-otto.de/snapshots/fdlibm/)

```

`config-aux/config.guess`:

```guess
#! /bin/sh
# Attempt to guess a canonical system name.
#   Copyright 1992-2017 Free Software Foundation, Inc.

timestamp='2017-05-27'

# This file is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, see <http://www.gnu.org/licenses/>.
#
# As a special exception to the GNU General Public License, if you
# distribute this file as part of a program that contains a
# configuration script generated by Autoconf, you may include it under
# the same distribution terms that you use for the rest of that
# program.  This Exception is an additional permission under section 7
# of the GNU General Public License, version 3 ("GPLv3").
#
# Originally written by Per Bothner; maintained since 2000 by Ben Elliston.
#
# You can get the latest version of this script from:
# http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess
#
# Please send patches to <config-patches@gnu.org>.


me=`echo "$0" | sed -e 's,.*/,,'`

usage="\
Usage: $0 [OPTION]

Output the configuration name of the system \`$me' is run on.

Operation modes:
  -h, --help         print this help, then exit
  -t, --time-stamp   print date of last modification, then exit
  -v, --version      print version number, then exit

Report bugs and patches to <config-patches@gnu.org>."

version="\
GNU config.guess ($timestamp)

Originally written by Per Bothner.
Copyright 1992-2017 Free Software Foundation, Inc.

This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."

help="
Try \`$me --help' for more information."

# Parse command line
while test $# -gt 0 ; do
  case $1 in
    --time-stamp | --time* | -t )
       echo "$timestamp" ; exit ;;
    --version | -v )
       echo "$version" ; exit ;;
    --help | --h* | -h )
       echo "$usage"; exit ;;
    -- )     # Stop option processing
       shift; break ;;
    - )	# Use stdin as input.
       break ;;
    -* )
       echo "$me: invalid option $1$help" >&2
       exit 1 ;;
    * )
       break ;;
  esac
done

if test $# != 0; then
  echo "$me: too many arguments$help" >&2
  exit 1
fi

trap 'exit 1' 1 2 15

# CC_FOR_BUILD -- compiler used by this script. Note that the use of a
# compiler to aid in system detection is discouraged as it requires
# temporary files to be created and, as you can see below, it is a
# headache to deal with in a portable fashion.

# Historically, `CC_FOR_BUILD' used to be named `HOST_CC'. We still
# use `HOST_CC' if defined, but it is deprecated.

# Portable tmp directory creation inspired by the Autoconf team.

set_cc_for_build='
trap "exitcode=\$?; (rm -f \$tmpfiles 2>/dev/null; rmdir \$tmp 2>/dev/null) && exit \$exitcode" 0 ;
trap "rm -f \$tmpfiles 2>/dev/null; rmdir \$tmp 2>/dev/null; exit 1" 1 2 13 15 ;
: ${TMPDIR=/tmp} ;
 { tmp=`(umask 077 && mktemp -d "$TMPDIR/cgXXXXXX") 2>/dev/null` && test -n "$tmp" && test -d "$tmp" ; } ||
 { test -n "$RANDOM" && tmp=$TMPDIR/cg$$-$RANDOM && (umask 077 && mkdir $tmp) ; } ||
 { tmp=$TMPDIR/cg-$$ && (umask 077 && mkdir $tmp) && echo "Warning: creating insecure temp directory" >&2 ; } ||
 { echo "$me: cannot create a temporary directory in $TMPDIR" >&2 ; exit 1 ; } ;
dummy=$tmp/dummy ;
tmpfiles="$dummy.c $dummy.o $dummy.rel $dummy" ;
case $CC_FOR_BUILD,$HOST_CC,$CC in
 ,,)    echo "int x;" > $dummy.c ;
	for c in cc gcc c89 c99 ; do
	  if ($c -c -o $dummy.o $dummy.c) >/dev/null 2>&1 ; then
	     CC_FOR_BUILD="$c"; break ;
	  fi ;
	done ;
	if test x"$CC_FOR_BUILD" = x ; then
	  CC_FOR_BUILD=no_compiler_found ;
	fi
	;;
 ,,*)   CC_FOR_BUILD=$CC ;;
 ,*,*)  CC_FOR_BUILD=$HOST_CC ;;
esac ; set_cc_for_build= ;'

# This is needed to find uname on a Pyramid OSx when run in the BSD universe.
# (ghazi@noc.rutgers.edu 1994-08-24)
if (test -f /.attbin/uname) >/dev/null 2>&1 ; then
	PATH=$PATH:/.attbin ; export PATH
fi

UNAME_MACHINE=`(uname -m) 2>/dev/null` || UNAME_MACHINE=unknown
UNAME_RELEASE=`(uname -r) 2>/dev/null` || UNAME_RELEASE=unknown
UNAME_SYSTEM=`(uname -s) 2>/dev/null`  || UNAME_SYSTEM=unknown
UNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown

case "${UNAME_SYSTEM}" in
Linux|GNU|GNU/*)
	# If the system lacks a compiler, then just pick glibc.
	# We could probably try harder.
	LIBC=gnu

	eval $set_cc_for_build
	cat <<-EOF > $dummy.c
	#include <features.h>
	#if defined(__UCLIBC__)
	LIBC=uclibc
	#elif defined(__dietlibc__)
	LIBC=dietlibc
	#else
	LIBC=gnu
	#endif
	EOF
	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^LIBC' | sed 's, ,,g'`
	;;
esac

case "${UNAME_MACHINE}" in
  i?86)
     test -z "$VENDOR" && VENDOR=pc
     ;;
  *)
     test -z "$VENDOR" && VENDOR=unknown
     ;;
esac
test -f /etc/SuSE-release -o -f /.buildenv && VENDOR=suse

# Note: order is significant - the case branches are not exclusive.

case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
    *:NetBSD:*:*)
	# NetBSD (nbsd) targets should (where applicable) match one or
	# more of the tuples: *-*-netbsdelf*, *-*-netbsdaout*,
	# *-*-netbsdecoff* and *-*-netbsd*.  For targets that recently
	# switched to ELF, *-*-netbsd* would select the old
	# object file format.  This provides both forward
	# compatibility and a consistent mechanism for selecting the
	# object file format.
	#
	# Note: NetBSD doesn't particularly care about the vendor
	# portion of the name.  We always set it to "unknown".
	sysctl="sysctl -n hw.machine_arch"
	UNAME_MACHINE_ARCH=`(uname -p 2>/dev/null || \
	    /sbin/$sysctl 2>/dev/null || \
	    /usr/sbin/$sysctl 2>/dev/null || \
	    echo unknown)`
	case "${UNAME_MACHINE_ARCH}" in
	    armeb) machine=armeb-unknown ;;
	    arm*) machine=arm-unknown ;;
	    sh3el) machine=shl-unknown ;;
	    sh3eb) machine=sh-unknown ;;
	    sh5el) machine=sh5le-unknown ;;
	    earmv*)
		arch=`echo ${UNAME_MACHINE_ARCH} | sed -e 's,^e\(armv[0-9]\).*$,\1,'`
		endian=`echo ${UNAME_MACHINE_ARCH} | sed -ne 's,^.*\(eb\)$,\1,p'`
		machine=${arch}${endian}-unknown
		;;
	    *) machine=${UNAME_MACHINE_ARCH}-unknown ;;
	esac
	# The Operating System including object format, if it has switched
	# to ELF recently (or will in the future) and ABI.
	case "${UNAME_MACHINE_ARCH}" in
	    earm*)
		os=netbsdelf
		;;
	    arm*|i386|m68k|ns32k|sh3*|sparc|vax)
		eval $set_cc_for_build
		if echo __ELF__ | $CC_FOR_BUILD -E - 2>/dev/null \
			| grep -q __ELF__
		then
		    # Once all utilities can be ECOFF (netbsdecoff) or a.out (netbsdaout).
		    # Return netbsd for either.  FIX?
		    os=netbsd
		else
		    os=netbsdelf
		fi
		;;
	    *)
		os=netbsd
		;;
	esac
	# Determine ABI tags.
	case "${UNAME_MACHINE_ARCH}" in
	    earm*)
		expr='s/^earmv[0-9]/-eabi/;s/eb$//'
		abi=`echo ${UNAME_MACHINE_ARCH} | sed -e "$expr"`
		;;
	esac
	# The OS release
	# Debian GNU/NetBSD machines have a different userland, and
	# thus, need a distinct triplet. However, they do not need
	# kernel version information, so it can be replaced with a
	# suitable tag, in the style of linux-gnu.
	case "${UNAME_VERSION}" in
	    Debian*)
		release='-gnu'
		;;
	    *)
		release=`echo ${UNAME_RELEASE} | sed -e 's/[-_].*//' | cut -d. -f1,2`
		;;
	esac
	# Since CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM:
	# contains redundant information, the shorter form:
	# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.
	echo "${machine}-${os}${release}${abi}"
	exit ;;
    *:Bitrig:*:*)
	UNAME_MACHINE_ARCH=`arch | sed 's/Bitrig.//'`
	echo ${UNAME_MACHINE_ARCH}-${VENDOR}-bitrig${UNAME_RELEASE}
	exit ;;
    *:OpenBSD:*:*)
	UNAME_MACHINE_ARCH=`arch | sed 's/OpenBSD.//'`
	echo ${UNAME_MACHINE_ARCH}-${VENDOR}-openbsd${UNAME_RELEASE}
	exit ;;
    *:LibertyBSD:*:*)
	UNAME_MACHINE_ARCH=`arch | sed 's/^.*BSD\.//'`
	echo ${UNAME_MACHINE_ARCH}-${VENDOR}-libertybsd${UNAME_RELEASE}
	exit ;;
    *:ekkoBSD:*:*)
	echo ${UNAME_MACHINE}-${VENDOR}-ekkobsd${UNAME_RELEASE}
	exit ;;
    *:SolidBSD:*:*)
	echo ${UNAME_MACHINE}-${VENDOR}-solidbsd${UNAME_RELEASE}
	exit ;;
    macppc:MirBSD:*:*)
	echo powerpc-${VENDOR}-mirbsd${UNAME_RELEASE}
	exit ;;
    *:MirBSD:*:*)
	echo ${UNAME_MACHINE}-${VENDOR}-mirbsd${UNAME_RELEASE}
	exit ;;
    *:Sortix:*:*)
	echo ${UNAME_MACHINE}-${VENDOR}-sortix
	exit ;;
    alpha:OSF1:*:*)
	case $UNAME_RELEASE in
	*4.0)
		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $3}'`
		;;
	*5.*)
		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $4}'`
		;;
	esac
	# According to Compaq, /usr/sbin/psrinfo has been available on
	# OSF/1 and Tru64 systems produced since 1995.  I hope that
	# covers most systems running today.  This code pipes the CPU
	# types through head -n 1, so we only detect the type of CPU 0.
	ALPHA_CPU_TYPE=`/usr/sbin/psrinfo -v | sed -n -e 's/^  The alpha \(.*\) processor.*$/\1/p' | head -n 1`
	case "$ALPHA_CPU_TYPE" in
	    "EV4 (21064)")
		UNAME_MACHINE=alpha ;;
	    "EV4.5 (21064)")
		UNAME_MACHINE=alpha ;;
	    "LCA4 (21066/21068)")
		UNAME_MACHINE=alpha ;;
	    "EV5 (21164)")
		UNAME_MACHINE=alphaev5 ;;
	    "EV5.6 (21164A)")
		UNAME_MACHINE=alphaev56 ;;
	    "EV5.6 (21164PC)")
		UNAME_MACHINE=alphapca56 ;;
	    "EV5.7 (21164PC)")
		UNAME_MACHINE=alphapca57 ;;
	    "EV6 (21264)")
		UNAME_MACHINE=alphaev6 ;;
	    "EV6.7 (21264A)")
		UNAME_MACHINE=alphaev67 ;;
	    "EV6.8CB (21264C)")
		UNAME_MACHINE=alphaev68 ;;
	    "EV6.8AL (21264B)")
		UNAME_MACHINE=alphaev68 ;;
	    "EV6.8CX (21264D)")
		UNAME_MACHINE=alphaev68 ;;
	    "EV6.9A (21264/EV69A)")
		UNAME_MACHINE=alphaev69 ;;
	    "EV7 (21364)")
		UNAME_MACHINE=alphaev7 ;;
	    "EV7.9 (21364A)")
		UNAME_MACHINE=alphaev79 ;;
	esac
	# A Pn.n version is a patched version.
	# A Vn.n version is a released version.
	# A Tn.n version is a released field test version.
	# A Xn.n version is an unreleased experimental baselevel.
	# 1.2 uses "1.2" for uname -r.
	echo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[PVTX]//' | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz`
	# Reset EXIT trap before exiting to avoid spurious non-zero exit code.
	exitcode=$?
	trap '' 0
	exit $exitcode ;;
    Alpha\ *:Windows_NT*:*)
	# How do we know it's Interix rather than the generic POSIX subsystem?
	# Should we change UNAME_MACHINE based on the output of uname instead
	# of the specific Alpha model?
	echo alpha-pc-interix
	exit ;;
    21064:Windows_NT:50:3)
	echo alpha-dec-winnt3.5
	exit ;;
    Amiga*:UNIX_System_V:4.0:*)
	echo m68k-${VENDOR}-sysv4
	exit ;;
    *:[Aa]miga[Oo][Ss]:*:*)
	echo ${UNAME_MACHINE}-${VENDOR}-amigaos
	exit ;;
    *:[Mm]orph[Oo][Ss]:*:*)
	echo ${UNAME_MACHINE}-${VENDOR}-morphos
	exit ;;
    *:OS/390:*:*)
	echo i370-ibm-openedition
	exit ;;
    *:z/VM:*:*)
	echo s390-ibm-zvmoe
	exit ;;
    *:OS400:*:*)
	echo powerpc-ibm-os400
	exit ;;
    arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)
	echo arm-acorn-riscix${UNAME_RELEASE}
	exit ;;
    arm*:riscos:*:*|arm*:RISCOS:*:*)
	echo arm-${VENDOR}-riscos
	exit ;;
    SR2?01:HI-UX/MPP:*:* | SR8000:HI-UX/MPP:*:*)
	echo hppa1.1-hitachi-hiuxmpp
	exit ;;
    Pyramid*:OSx*:*:* | MIS*:OSx*:*:* | MIS*:SMP_DC-OSx*:*:*)
	# akee@wpdis03.wpafb.af.mil (Earle F. Ake) contributed MIS and NILE.
	if test "`(/bin/universe) 2>/dev/null`" = att ; then
		echo pyramid-pyramid-sysv3
	else
		echo pyramid-pyramid-bsd
	fi
	exit ;;
    NILE*:*:*:dcosx)
	echo pyramid-pyramid-svr4
	exit ;;
    DRS?6000:unix:4.0:6*)
	echo sparc-icl-nx6
	exit ;;
    DRS?6000:UNIX_SV:4.2*:7* | DRS?6000:isis:4.2*:7*)
	case `/usr/bin/uname -p` in
	    sparc) echo sparc-icl-nx7; exit ;;
	esac ;;
    s390x:SunOS:*:*)
	echo ${UNAME_MACHINE}-ibm-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
	exit ;;
    sun4H:SunOS:5.*:*)
	echo sparc-hal-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
	exit ;;
    sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)
	echo sparc-sun-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
	exit ;;
    i86pc:AuroraUX:5.*:* | i86xen:AuroraUX:5.*:*)
	echo i386-pc-auroraux${UNAME_RELEASE}
	exit ;;
    i86pc:SunOS:5.*:* | i86xen:SunOS:5.*:*)
	eval $set_cc_for_build
	SUN_ARCH=i386
	# If there is a compiler, see if it is configured for 64-bit objects.
	# Note that the Sun cc does not turn __LP64__ into 1 like gcc does.
	# This test works for both compilers.
	if [ "$CC_FOR_BUILD" != no_compiler_found ]; then
	    if (echo '#ifdef __amd64'; echo IS_64BIT_ARCH; echo '#endif') | \
		(CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
		grep IS_64BIT_ARCH >/dev/null
	    then
		SUN_ARCH=x86_64
	    fi
	fi
	echo ${SUN_ARCH}-pc-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
	exit ;;
    sun4*:SunOS:6*:*)
	# According to config.sub, this is the proper way to canonicalize
	# SunOS6.  Hard to guess exactly what SunOS6 will be like, but
	# it's likely to be more like Solaris than SunOS4.
	echo sparc-sun-solaris3`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
	exit ;;
    sun4*:SunOS:*:*)
	case "`/usr/bin/arch -k`" in
	    Series*|S4*)
		UNAME_RELEASE=`uname -v`
		;;
	esac
	# Japanese Language versions have a version number like `4.1.3-JL'.
	echo sparc-sun-sunos`echo ${UNAME_RELEASE}|sed -e 's/-/_/'`
	exit ;;
    sun3*:SunOS:*:*)
	echo m68k-sun-sunos${UNAME_RELEASE}
	exit ;;
    sun*:*:4.2BSD:*)
	UNAME_RELEASE=`(sed 1q /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null`
	test "x${UNAME_RELEASE}" = x && UNAME_RELEASE=3
	case "`/bin/arch`" in
	    sun3)
		echo m68k-sun-sunos${UNAME_RELEASE}
		;;
	    sun4)
		echo sparc-sun-sunos${UNAME_RELEASE}
		;;
	esac
	exit ;;
    aushp:SunOS:*:*)
	echo sparc-auspex-sunos${UNAME_RELEASE}
	exit ;;
    # The situation for MiNT is a little confusing.  The machine name
    # can be virtually everything (everything which is not
    # "atarist" or "atariste" at least should have a processor
    # > m68000).  The system name ranges from "MiNT" over "FreeMiNT"
    # to the lowercase version "mint" (or "freemint").  Finally
    # the system name "TOS" denotes a system which is actually not
    # MiNT.  But MiNT is downward compatible to TOS, so this should
    # be no problem.
    atarist[e]:*MiNT:*:* | atarist[e]:*mint:*:* | atarist[e]:*TOS:*:*)
	echo m68k-atari-mint${UNAME_RELEASE}
	exit ;;
    atari*:*MiNT:*:* | atari*:*mint:*:* | atarist[e]:*TOS:*:*)
	echo m68k-atari-mint${UNAME_RELEASE}
	exit ;;
    *falcon*:*MiNT:*:* | *falcon*:*mint:*:* | *falcon*:*TOS:*:*)
	echo m68k-atari-mint${UNAME_RELEASE}
	exit ;;
    milan*:*MiNT:*:* | milan*:*mint:*:* | *milan*:*TOS:*:*)
	echo m68k-milan-mint${UNAME_RELEASE}
	exit ;;
    hades*:*MiNT:*:* | hades*:*mint:*:* | *hades*:*TOS:*:*)
	echo m68k-hades-mint${UNAME_RELEASE}
	exit ;;
    *:*MiNT:*:* | *:*mint:*:* | *:*TOS:*:*)
	echo m68k-${VENDOR}-mint${UNAME_RELEASE}
	exit ;;
    m68k:machten:*:*)
	echo m68k-apple-machten${UNAME_RELEASE}
	exit ;;
    powerpc:machten:*:*)
	echo powerpc-apple-machten${UNAME_RELEASE}
	exit ;;
    RISC*:Mach:*:*)
	echo mips-dec-mach_bsd4.3
	exit ;;
    RISC*:ULTRIX:*:*)
	echo mips-dec-ultrix${UNAME_RELEASE}
	exit ;;
    VAX*:ULTRIX*:*:*)
	echo vax-dec-ultrix${UNAME_RELEASE}
	exit ;;
    2020:CLIX:*:* | 2430:CLIX:*:*)
	echo clipper-intergraph-clix${UNAME_RELEASE}
	exit ;;
    mips:*:*:UMIPS | mips:*:*:RISCos)
	eval $set_cc_for_build
	sed 's/^	//' << EOF >$dummy.c
#ifdef __cplusplus
#include <stdio.h>  /* for printf() prototype */
	int main (int argc, char *argv[]) {
#else
	int main (argc, argv) int argc; char *argv[]; {
#endif
	#if defined (host_mips) && defined (MIPSEB)
	#if defined (SYSTYPE_SYSV)
	  printf ("mips-mips-riscos%ssysv\n", argv[1]); exit (0);
	#endif
	#if defined (SYSTYPE_SVR4)
	  printf ("mips-mips-riscos%ssvr4\n", argv[1]); exit (0);
	#endif
	#if defined (SYSTYPE_BSD43) || defined(SYSTYPE_BSD)
	  printf ("mips-mips-riscos%sbsd\n", argv[1]); exit (0);
	#endif
	#endif
	  exit (-1);
	}
EOF
	$CC_FOR_BUILD -o $dummy $dummy.c &&
	  dummyarg=`echo "${UNAME_RELEASE}" | sed -n 's/\([0-9]*\).*/\1/p'` &&
	  SYSTEM_NAME=`$dummy $dummyarg` &&
	    { echo "$SYSTEM_NAME"; exit; }
	echo mips-mips-riscos${UNAME_RELEASE}
	exit ;;
    Motorola:PowerMAX_OS:*:*)
	echo powerpc-motorola-powermax
	exit ;;
    Motorola:*:4.3:PL8-*)
	echo powerpc-harris-powermax
	exit ;;
    Night_Hawk:*:*:PowerMAX_OS | Synergy:PowerMAX_OS:*:*)
	echo powerpc-harris-powermax
	exit ;;
    Night_Hawk:Power_UNIX:*:*)
	echo powerpc-harris-powerunix
	exit ;;
    m88k:CX/UX:7*:*)
	echo m88k-harris-cxux7
	exit ;;
    m88k:*:4*:R4*)
	echo m88k-motorola-sysv4
	exit ;;
    m88k:*:3*:R3*)
	echo m88k-motorola-sysv3
	exit ;;
    AViiON:dgux:*:*)
	# DG/UX returns AViiON for all architectures
	UNAME_PROCESSOR=`/usr/bin/uname -p`
	if [ $UNAME_PROCESSOR = mc88100 ] || [ $UNAME_PROCESSOR = mc88110 ]
	then
	    if [ ${TARGET_BINARY_INTERFACE}x = m88kdguxelfx ] || \
	       [ ${TARGET_BINARY_INTERFACE}x = x ]
	    then
		echo m88k-dg-dgux${UNAME_RELEASE}
	    else
		echo m88k-dg-dguxbcs${UNAME_RELEASE}
	    fi
	else
	    echo i586-dg-dgux${UNAME_RELEASE}
	fi
	exit ;;
    M88*:DolphinOS:*:*)	# DolphinOS (SVR3)
	echo m88k-dolphin-sysv3
	exit ;;
    M88*:*:R3*:*)
	# Delta 88k system running SVR3
	echo m88k-motorola-sysv3
	exit ;;
    XD88*:*:*:*) # Tektronix XD88 system running UTekV (SVR3)
	echo m88k-tektronix-sysv3
	exit ;;
    Tek43[0-9][0-9]:UTek:*:*) # Tektronix 4300 system running UTek (BSD)
	echo m68k-tektronix-bsd
	exit ;;
    *:IRIX*:*:*)
	echo mips-sgi-irix`echo ${UNAME_RELEASE}|sed -e 's/-/_/g'`
	exit ;;
    ????????:AIX?:[12].1:2)   # AIX 2.2.1 or AIX 2.1.1 is RT/PC AIX.
	echo romp-ibm-aix     # uname -m gives an 8 hex-code CPU id
	exit ;;               # Note that: echo "'`uname -s`'" gives 'AIX '
    i*86:AIX:*:*)
	echo i386-ibm-aix
	exit ;;
    ia64:AIX:*:*)
	if [ -x /usr/bin/oslevel ] ; then
		IBM_REV=`/usr/bin/oslevel`
	else
		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
	fi
	echo ${UNAME_MACHINE}-ibm-aix${IBM_REV}
	exit ;;
    *:AIX:2:3)
	if grep bos325 /usr/include/stdio.h >/dev/null 2>&1; then
		eval $set_cc_for_build
		sed 's/^		//' << EOF >$dummy.c
		#include <sys/systemcfg.h>

		main()
			{
			if (!__power_pc())
				exit(1);
			puts("powerpc-ibm-aix3.2.5");
			exit(0);
			}
EOF
		if $CC_FOR_BUILD -o $dummy $dummy.c && SYSTEM_NAME=`$dummy`
		then
			echo "$SYSTEM_NAME"
		else
			echo rs6000-ibm-aix3.2.5
		fi
	elif grep bos324 /usr/include/stdio.h >/dev/null 2>&1; then
		echo rs6000-ibm-aix3.2.4
	else
		echo rs6000-ibm-aix3.2
	fi
	exit ;;
    *:AIX:*:[4567])
	IBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | sed 1q | awk '{ print $1 }'`
	if /usr/sbin/lsattr -El ${IBM_CPU_ID} | grep ' POWER' >/dev/null 2>&1; then
		IBM_ARCH=rs6000
	else
		IBM_ARCH=powerpc
	fi
	if [ -x /usr/bin/lslpp ] ; then
		IBM_REV=`/usr/bin/lslpp -Lqc bos.rte.libc |
			   awk -F: '{ print $3 }' | sed s/[0-9]*$/0/`
	else
		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
	fi
	echo ${IBM_ARCH}-ibm-aix${IBM_REV}
	exit ;;
    *:AIX:*:*)
	echo rs6000-ibm-aix
	exit ;;
    ibmrt:4.4BSD:*|romp-ibm:BSD:*)
	echo romp-ibm-bsd4.4
	exit ;;
    ibmrt:*BSD:*|romp-ibm:BSD:*)            # covers RT/PC BSD and
	echo romp-ibm-bsd${UNAME_RELEASE}   # 4.3 with uname added to
	exit ;;                             # report: romp-ibm BSD 4.3
    *:BOSX:*:*)
	echo rs6000-bull-bosx
	exit ;;
    DPX/2?00:B.O.S.:*:*)
	echo m68k-bull-sysv3
	exit ;;
    9000/[34]??:4.3bsd:1.*:*)
	echo m68k-hp-bsd
	exit ;;
    hp300:4.4BSD:*:* | 9000/[34]??:4.3bsd:2.*:*)
	echo m68k-hp-bsd4.4
	exit ;;
    9000/[34678]??:HP-UX:*:*)
	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
	case "${UNAME_MACHINE}" in
	    9000/31? )            HP_ARCH=m68000 ;;
	    9000/[34]?? )         HP_ARCH=m68k ;;
	    9000/[678][0-9][0-9])
		if [ -x /usr/bin/getconf ]; then
		    sc_cpu_version=`/usr/bin/getconf SC_CPU_VERSION 2>/dev/null`
		    sc_kernel_bits=`/usr/bin/getconf SC_KERNEL_BITS 2>/dev/null`
		    case "${sc_cpu_version}" in
		      523) HP_ARCH=hppa1.0 ;; # CPU_PA_RISC1_0
		      528) HP_ARCH=hppa1.1 ;; # CPU_PA_RISC1_1
		      532)                      # CPU_PA_RISC2_0
			case "${sc_kernel_bits}" in
			  32) HP_ARCH=hppa2.0n ;;
			  64) HP_ARCH=hppa2.0w ;;
			  '') HP_ARCH=hppa2.0 ;;   # HP-UX 10.20
			esac ;;
		    esac
		fi
		if [ "${HP_ARCH}" = "" ]; then
		    eval $set_cc_for_build
		    sed 's/^		//' << EOF >$dummy.c

		#define _HPUX_SOURCE
		#include <stdlib.h>
		#include <unistd.h>

		int main ()
		{
		#if defined(_SC_KERNEL_BITS)
		    long bits = sysconf(_SC_KERNEL_BITS);
		#endif
		    long cpu  = sysconf (_SC_CPU_VERSION);

		    switch (cpu)
			{
			case CPU_PA_RISC1_0: puts ("hppa1.0"); break;
			case CPU_PA_RISC1_1: puts ("hppa1.1"); break;
			case CPU_PA_RISC2_0:
		#if defined(_SC_KERNEL_BITS)
			    switch (bits)
				{
				case 64: puts ("hppa2.0w"); break;
				case 32: puts ("hppa2.0n"); break;
				default: puts ("hppa2.0"); break;
				} break;
		#else  /* !defined(_SC_KERNEL_BITS) */
			    puts ("hppa2.0"); break;
		#endif
			default: puts ("hppa1.0"); break;
			}
		    exit (0);
		}
EOF
		    (CCOPTS="" $CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null) && HP_ARCH=`$dummy`
		    test -z "$HP_ARCH" && HP_ARCH=hppa
		fi ;;
	esac
	if [ ${HP_ARCH} = hppa2.0w ]
	then
	    eval $set_cc_for_build

	    # hppa2.0w-hp-hpux* has a 64-bit kernel and a compiler generating
	    # 32-bit code.  hppa64-hp-hpux* has the same kernel and a compiler
	    # generating 64-bit code.  GNU and HP use different nomenclature:
	    #
	    # $ CC_FOR_BUILD=cc ./config.guess
	    # => hppa2.0w-hp-hpux11.23
	    # $ CC_FOR_BUILD="cc +DA2.0w" ./config.guess
	    # => hppa64-hp-hpux11.23

	    if echo __LP64__ | (CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) |
		grep -q __LP64__
	    then
		HP_ARCH=hppa2.0w
	    else
		HP_ARCH=hppa64
	    fi
	fi
	echo ${HP_ARCH}-hp-hpux${HPUX_REV}
	exit ;;
    ia64:HP-UX:*:*)
	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
	echo ia64-hp-hpux${HPUX_REV}
	exit ;;
    3050*:HI-UX:*:*)
	eval $set_cc_for_build
	sed 's/^	//' << EOF >$dummy.c
	#include <unistd.h>
	int
	main ()
	{
	  long cpu = sysconf (_SC_CPU_VERSION);
	  /* The order matters, because CPU_IS_HP_MC68K erroneously returns
	     true for CPU_PA_RISC1_0.  CPU_IS_PA_RISC returns correct
	     results, however.  */
	  if (CPU_IS_PA_RISC (cpu))
	    {
	      switch (cpu)
		{
		  case CPU_PA_RISC1_0: puts ("hppa1.0-hitachi-hiuxwe2"); break;
		  case CPU_PA_RISC1_1: puts ("hppa1.1-hitachi-hiuxwe2"); break;
		  case CPU_PA_RISC2_0: puts ("hppa2.0-hitachi-hiuxwe2"); break;
		  default: puts ("hppa-hitachi-hiuxwe2"); break;
		}
	    }
	  else if (CPU_IS_HP_MC68K (cpu))
	    puts ("m68k-hitachi-hiuxwe2");
	  else puts ("unknown-hitachi-hiuxwe2");
	  exit (0);
	}
EOF
	$CC_FOR_BUILD -o $dummy $dummy.c && SYSTEM_NAME=`$dummy` &&
		{ echo "$SYSTEM_NAME"; exit; }
	echo unknown-hitachi-hiuxwe2
	exit ;;
    9000/7??:4.3bsd:*:* | 9000/8?[79]:4.3bsd:*:* )
	echo hppa1.1-hp-bsd
	exit ;;
    9000/8??:4.3bsd:*:*)
	echo hppa1.0-hp-bsd
	exit ;;
    *9??*:MPE/iX:*:* | *3000*:MPE/iX:*:*)
	echo hppa1.0-hp-mpeix
	exit ;;
    hp7??:OSF1:*:* | hp8?[79]:OSF1:*:* )
	echo hppa1.1-hp-osf
	exit ;;
    hp8??:OSF1:*:*)
	echo hppa1.0-hp-osf
	exit ;;
    i*86:OSF1:*:*)
	if [ -x /usr/sbin/sysversion ] ; then
	    echo ${UNAME_MACHINE}-${VENDOR}-osf1mk
	else
	    echo ${UNAME_MACHINE}-${VENDOR}-osf1
	fi
	exit ;;
    parisc*:Lites*:*:*)
	echo hppa1.1-hp-lites
	exit ;;
    C1*:ConvexOS:*:* | convex:ConvexOS:C1*:*)
	echo c1-convex-bsd
	exit ;;
    C2*:ConvexOS:*:* | convex:ConvexOS:C2*:*)
	if getsysinfo -f scalar_acc
	then echo c32-convex-bsd
	else echo c2-convex-bsd
	fi
	exit ;;
    C34*:ConvexOS:*:* | convex:ConvexOS:C34*:*)
	echo c34-convex-bsd
	exit ;;
    C38*:ConvexOS:*:* | convex:ConvexOS:C38*:*)
	echo c38-convex-bsd
	exit ;;
    C4*:ConvexOS:*:* | convex:ConvexOS:C4*:*)
	echo c4-convex-bsd
	exit ;;
    CRAY*Y-MP:*:*:*)
	echo ymp-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
	exit ;;
    CRAY*[A-Z]90:*:*:*)
	echo ${UNAME_MACHINE}-cray-unicos${UNAME_RELEASE} \
	| sed -e 's/CRAY.*\([A-Z]90\)/\1/' \
	      -e y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/ \
	      -e 's/\.[^.]*$/.X/'
	exit ;;
    CRAY*TS:*:*:*)
	echo t90-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
	exit ;;
    CRAY*T3E:*:*:*)
	echo alphaev5-cray-unicosmk${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
	exit ;;
    CRAY*SV1:*:*:*)
	echo sv1-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
	exit ;;
    *:UNICOS/mp:*:*)
	echo craynv-cray-unicosmp${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
	exit ;;
    F30[01]:UNIX_System_V:*:* | F700:UNIX_System_V:*:*)
	FUJITSU_PROC=`uname -m | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz`
	FUJITSU_SYS=`uname -p | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/\///'`
	FUJITSU_REL=`echo ${UNAME_RELEASE} | sed -e 's/ /_/'`
	echo "${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
	exit ;;
    5000:UNIX_System_V:4.*:*)
	FUJITSU_SYS=`uname -p | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/\///'`
	FUJITSU_REL=`echo ${UNAME_RELEASE} | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/ /_/'`
	echo "sparc-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
	exit ;;
    i*86:BSD/386:*:* | i*86:BSD/OS:*:* | *:Ascend\ Embedded/OS:*:*)
	echo ${UNAME_MACHINE}-pc-bsdi${UNAME_RELEASE}
	exit ;;
    sparc*:BSD/OS:*:*)
	echo sparc-${VENDOR}-bsdi${UNAME_RELEASE}
	exit ;;
    *:BSD/OS:*:*)
	echo ${UNAME_MACHINE}-${VENDOR}-bsdi${UNAME_RELEASE}
	exit ;;
    *:FreeBSD:*:*)
	UNAME_PROCESSOR=`/usr/bin/uname -p`
	case ${UNAME_PROCESSOR} in
	    amd64)
		UNAME_PROCESSOR=x86_64 ;;
	    i386)
		UNAME_PROCESSOR=i586 ;;
	esac
	echo ${UNAME_PROCESSOR}-${VENDOR}-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`
	exit ;;
    i*:CYGWIN*:*)
	echo ${UNAME_MACHINE}-pc-cygwin
	exit ;;
    *:MINGW64*:*)
	echo ${UNAME_MACHINE}-pc-mingw64
	exit ;;
    *:MINGW*:*)
	echo ${UNAME_MACHINE}-pc-mingw32
	exit ;;
    *:MSYS*:*)
	echo ${UNAME_MACHINE}-pc-msys
	exit ;;
    i*:windows32*:*)
	# uname -m includes "-pc" on this system.
	echo ${UNAME_MACHINE}-mingw32
	exit ;;
    i*:PW*:*)
	echo ${UNAME_MACHINE}-pc-pw32
	exit ;;
    *:Interix*:*)
	case ${UNAME_MACHINE} in
	    x86)
		echo i586-pc-interix${UNAME_RELEASE}
		exit ;;
	    authenticamd | genuineintel | EM64T)
		echo x86_64-${VENDOR}-interix${UNAME_RELEASE}
		exit ;;
	    IA64)
		echo ia64-${VENDOR}-interix${UNAME_RELEASE}
		exit ;;
	esac ;;
    [345]86:Windows_95:* | [345]86:Windows_98:* | [345]86:Windows_NT:*)
	echo i${UNAME_MACHINE}-pc-mks
	exit ;;
    8664:Windows_NT:*)
	echo x86_64-pc-mks
	exit ;;
    i*:Windows_NT*:* | Pentium*:Windows_NT*:*)
	# How do we know it's Interix rather than the generic POSIX subsystem?
	# It also conflicts with pre-2.0 versions of AT&T UWIN. Should we
	# UNAME_MACHINE based on the output of uname instead of i386?
	echo i586-pc-interix
	exit ;;
    i*:UWIN*:*)
	echo ${UNAME_MACHINE}-pc-uwin
	exit ;;
    amd64:CYGWIN*:*:* | x86_64:CYGWIN*:*:*)
	echo x86_64-${VENDOR}-cygwin
	exit ;;
    p*:CYGWIN*:*)
	echo powerpcle-${VENDOR}-cygwin
	exit ;;
    prep*:SunOS:5.*:*)
	echo powerpcle-${VENDOR}-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
	exit ;;
    *:GNU:*:*)
	# the GNU system
	echo `echo ${UNAME_MACHINE}|sed -e 's,[-/].*$,,'`-${VENDOR}-${LIBC}`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`
	exit ;;
    *:GNU/*:*:*)
	# other systems with GNU libc and userland
	echo ${UNAME_MACHINE}-${VENDOR}-`echo ${UNAME_SYSTEM} | sed 's,^[^/]*/,,' | tr "[:upper:]" "[:lower:]"``echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`-${LIBC}
	exit ;;
    i*86:Minix:*:*)
	echo ${UNAME_MACHINE}-pc-minix
	exit ;;
    aarch64:Linux:*:*)
	echo ${UNAME_MACHINE}-${VENDOR}-linux-${LIBC}
	exit ;;
    aarch64_be:Linux:*:*)
	UNAME_MACHINE=aarch64_be
	echo ${UNAME_MACHINE}-${VENDOR}-linux-${LIBC}
	exit ;;
    alpha:Linux:*:*)
	case `sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' < /proc/cpuinfo` in
	  EV5)   UNAME_MACHINE=alphaev5 ;;
	  EV56)  UNAME_MACHINE=alphaev56 ;;
	  PCA56) UNAME_MACHINE=alphapca56 ;;
	  PCA57) UNAME_MACHINE=alphapca56 ;;
	  EV6)   UNAME_MACHINE=alphaev6 ;;
	  EV67)  UNAME_MACHINE=alphaev67 ;;
	  EV68*) UNAME_MACHINE=alphaev68 ;;
	esac
	objdump --private-headers /bin/sh | grep -q ld.so.1
	if test "$?" = 0 ; then LIBC=gnulibc1 ; fi
	echo ${UNAME_MACHINE}-${VENDOR}-linux-${LIBC}
	exit ;;
    arc:Linux:*:* | arceb:Linux:*:*)
	echo ${UNAME_MACHINE}-${VENDOR}-linux-${LIBC}
	exit ;;
    arm*:Linux:*:*)
	eval $set_cc_for_build
	if echo __ARM_EABI__ | $CC_FOR_BUILD -E - 2>/dev/null \
	    | grep -q __ARM_EABI__
	then
	    echo ${UNAME_MACHINE}-${VENDOR}-linux-${LIBC}
	else
	    if echo __ARM_PCS_VFP | $CC_FOR_BUILD -E - 2>/dev/null \
		| grep -q __ARM_PCS_VFP
	    then
		echo ${UNAME_MACHINE}-${VENDOR}-linux-${LIBC}eabi
	    else
		echo ${UNAME_MACHINE}-${VENDOR}-linux-${LIBC}eabihf
	    fi
	fi
	exit ;;
    avr32*:Linux:*:*)
	echo ${UNAME_MACHINE}-${VENDOR}-linux-${LIBC}
	exit ;;
    cris:Linux:*:*)
	echo ${UNAME_MACHINE}-axis-linux-${LIBC}
	exit ;;
    crisv32:Linux:*:*)
	echo ${UNAME_MACHINE}-axis-linux-${LIBC}
	exit ;;
    e2k:Linux:*:*)
	echo ${UNAME_MACHINE}-${VENDOR}-linux-${LIBC}
	exit ;;
    frv:Linux:*:*)
	echo ${UNAME_MACHINE}-${VENDOR}-linux-${LIBC}
	exit ;;
    hexagon:Linux:*:*)
	echo ${UNAME_MACHINE}-${VENDOR}-linux-${LIBC}
	exit ;;
    i*86:Linux:*:*)
	echo ${UNAME_MACHINE}-${VENDOR}-linux-${LIBC}
	exit ;;
    ia64:Linux:*:*)
	echo ${UNAME_MACHINE}-${VENDOR}-linux-${LIBC}
	exit ;;
    k1om:Linux:*:*)
	echo ${UNAME_MACHINE}-${VENDOR}-linux-${LIBC}
	exit ;;
    m32r*:Linux:*:*)
	echo ${UNAME_MACHINE}-${VENDOR}-linux-${LIBC}
	exit ;;
    m68*:Linux:*:*)
	echo ${UNAME_MACHINE}-${VENDOR}-linux-${LIBC}
	exit ;;
    mips:Linux:*:* | mips64:Linux:*:*)
	eval $set_cc_for_build
	sed 's/^	//' << EOF >$dummy.c
	#undef CPU
	#undef ${UNAME_MACHINE}
	#undef ${UNAME_MACHINE}el
	#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)
	CPU=${UNAME_MACHINE}el
	#else
	#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)
	CPU=${UNAME_MACHINE}
	#else
	CPU=
	#endif
	#endif
EOF
	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^CPU'`
	test x"${CPU}" != x && { echo "${CPU}-${VENDOR}-linux-${LIBC}"; exit; }
	;;
    mips64el:Linux:*:*)
	echo ${UNAME_MACHINE}-${VENDOR}-linux-${LIBC}
	exit ;;
    openrisc*:Linux:*:*)
	echo or1k-${VENDOR}-linux-${LIBC}
	exit ;;
    or32:Linux:*:* | or1k*:Linux:*:*)
	echo ${UNAME_MACHINE}-${VENDOR}-linux-${LIBC}
	exit ;;
    padre:Linux:*:*)
	echo sparc-${VENDOR}-linux-${LIBC}
	exit ;;
    parisc64:Linux:*:* | hppa64:Linux:*:*)
	echo hppa64-${VENDOR}-linux-${LIBC}
	exit ;;
    parisc:Linux:*:* | hppa:Linux:*:*)
	# Look for CPU level
	case `grep '^cpu[^a-z]*:' /proc/cpuinfo 2>/dev/null | cut -d' ' -f2` in
	  PA7*) echo hppa1.1-${VENDOR}-linux-${LIBC} ;;
	  PA8*) echo hppa2.0-${VENDOR}-linux-${LIBC} ;;
	  *)    echo hppa-${VENDOR}-linux-${LIBC} ;;
	esac
	exit ;;
    ppc64:Linux:*:*)
	echo powerpc64-${VENDOR}-linux-${LIBC}
	exit ;;
    ppc:Linux:*:*)
	echo powerpc-${VENDOR}-linux-${LIBC}
	exit ;;
    ppc64le:Linux:*:*)
	echo powerpc64le-${VENDOR}-linux-${LIBC}
	exit ;;
    ppcle:Linux:*:*)
	echo powerpcle-${VENDOR}-linux-${LIBC}
	exit ;;
    riscv32:Linux:*:* | riscv64:Linux:*:*)
	echo ${UNAME_MACHINE}-${VENDOR}-linux-${LIBC}
	exit ;;
    s390:Linux:*:* | s390x:Linux:*:*)
	echo ${UNAME_MACHINE}-ibm-linux-${LIBC}
	exit ;;
    sh64*:Linux:*:*)
	echo ${UNAME_MACHINE}-${VENDOR}-linux-${LIBC}
	exit ;;
    sh*:Linux:*:*)
	echo ${UNAME_MACHINE}-${VENDOR}-linux-${LIBC}
	exit ;;
    sparc:Linux:*:* | sparc64:Linux:*:*)
	echo ${UNAME_MACHINE}-${VENDOR}-linux-${LIBC}
	exit ;;
    tile*:Linux:*:*)
	echo ${UNAME_MACHINE}-${VENDOR}-linux-${LIBC}
	exit ;;
    vax:Linux:*:*)
	echo ${UNAME_MACHINE}-dec-linux-${LIBC}
	exit ;;
    x86_64:Linux:*:*)
	echo ${UNAME_MACHINE}-${VENDOR}-linux-${LIBC}
	exit ;;
    xtensa*:Linux:*:*)
	echo ${UNAME_MACHINE}-${VENDOR}-linux-${LIBC}
	exit ;;
    i*86:DYNIX/ptx:4*:*)
	# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.
	# earlier versions are messed up and put the nodename in both
	# sysname and nodename.
	echo i386-sequent-sysv4
	exit ;;
    i*86:UNIX_SV:4.2MP:2.*)
	# Unixware is an offshoot of SVR4, but it has its own version
	# number series starting with 2...
	# I am not positive that other SVR4 systems won't match this,
	# I just have to hope.  -- rms.
	# Use sysv4.2uw... so that sysv4* matches it.
	echo ${UNAME_MACHINE}-pc-sysv4.2uw${UNAME_VERSION}
	exit ;;
    i*86:OS/2:*:*)
	# If we were able to find `uname', then EMX Unix compatibility
	# is probably installed.
	echo ${UNAME_MACHINE}-pc-os2-emx
	exit ;;
    i*86:XTS-300:*:STOP)
	echo ${UNAME_MACHINE}-${VENDOR}-stop
	exit ;;
    i*86:atheos:*:*)
	echo ${UNAME_MACHINE}-${VENDOR}-atheos
	exit ;;
    i*86:syllable:*:*)
	echo ${UNAME_MACHINE}-pc-syllable
	exit ;;
    i*86:LynxOS:2.*:* | i*86:LynxOS:3.[01]*:* | i*86:LynxOS:4.[02]*:*)
	echo i386-${VENDOR}-lynxos${UNAME_RELEASE}
	exit ;;
    i*86:*DOS:*:*)
	echo ${UNAME_MACHINE}-pc-msdosdjgpp
	exit ;;
    i*86:*:4.*:* | i*86:SYSTEM_V:4.*:*)
	UNAME_REL=`echo ${UNAME_RELEASE} | sed 's/\/MP$//'`
	if grep Novell /usr/include/link.h >/dev/null 2>/dev/null; then
		echo ${UNAME_MACHINE}-univel-sysv${UNAME_REL}
	else
		echo ${UNAME_MACHINE}-pc-sysv${UNAME_REL}
	fi
	exit ;;
    i*86:*:5:[678]*)
	# UnixWare 7.x, OpenUNIX and OpenServer 6.
	case `/bin/uname -X | grep "^Machine"` in
	    *486*)	     UNAME_MACHINE=i486 ;;
	    *Pentium)	     UNAME_MACHINE=i586 ;;
	    *Pent*|*Celeron) UNAME_MACHINE=i686 ;;
	esac
	echo ${UNAME_MACHINE}-${VENDOR}-sysv${UNAME_RELEASE}${UNAME_SYSTEM}${UNAME_VERSION}
	exit ;;
    i*86:*:3.2:*)
	if test -f /usr/options/cb.name; then
		UNAME_REL=`sed -n 's/.*Version //p' </usr/options/cb.name`
		echo ${UNAME_MACHINE}-pc-isc$UNAME_REL
	elif /bin/uname -X 2>/dev/null >/dev/null ; then
		UNAME_REL=`(/bin/uname -X|grep Release|sed -e 's/.*= //')`
		(/bin/uname -X|grep i80486 >/dev/null) && UNAME_MACHINE=i486
		(/bin/uname -X|grep '^Machine.*Pentium' >/dev/null) \
			&& UNAME_MACHINE=i586
		(/bin/uname -X|grep '^Machine.*Pent *II' >/dev/null) \
			&& UNAME_MACHINE=i686
		(/bin/uname -X|grep '^Machine.*Pentium Pro' >/dev/null) \
			&& UNAME_MACHINE=i686
		echo ${UNAME_MACHINE}-pc-sco$UNAME_REL
	else
		echo ${UNAME_MACHINE}-pc-sysv32
	fi
	exit ;;
    pc:*:*:*)
	# Left here for compatibility:
	# uname -m prints for DJGPP always 'pc', but it prints nothing about
	# the processor, so we play safe by assuming i586.
	# Note: whatever this is, it MUST be the same as what config.sub
	# prints for the "djgpp" host, or else GDB configure will decide that
	# this is a cross-build.
	echo i586-pc-msdosdjgpp
	exit ;;
    Intel:Mach:3*:*)
	echo i386-pc-mach3
	exit ;;
    paragon:*:*:*)
	echo i860-intel-osf1
	exit ;;
    i860:*:4.*:*) # i860-SVR4
	if grep Stardent /usr/include/sys/uadmin.h >/dev/null 2>&1 ; then
	  echo i860-stardent-sysv${UNAME_RELEASE} # Stardent Vistra i860-SVR4
	else # Add other i860-SVR4 vendors below as they are discovered.
	  echo i860-${VENDOR}-sysv${UNAME_RELEASE}  # Unknown i860-SVR4
	fi
	exit ;;
    mini*:CTIX:SYS*5:*)
	# "miniframe"
	echo m68010-convergent-sysv
	exit ;;
    mc68k:UNIX:SYSTEM5:3.51m)
	echo m68k-convergent-sysv
	exit ;;
    M680?0:D-NIX:5.3:*)
	echo m68k-diab-dnix
	exit ;;
    M68*:*:R3V[5678]*:*)
	test -r /sysV68 && { echo 'm68k-motorola-sysv'; exit; } ;;
    3[345]??:*:4.0:3.0 | 3[34]??A:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 3[34]??/*:*:4.0:3.0 | 4400:*:4.0:3.0 | 4850:*:4.0:3.0 | SKA40:*:4.0:3.0 | SDS2:*:4.0:3.0 | SHG2:*:4.0:3.0 | S7501*:*:4.0:3.0)
	OS_REL=''
	test -r /etc/.relid \
	&& OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
	  && { echo i486-ncr-sysv4.3${OS_REL}; exit; }
	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
	  && { echo i586-ncr-sysv4.3${OS_REL}; exit; } ;;
    3[34]??:*:4.0:* | 3[34]??,*:*:4.0:*)
	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
	  && { echo i486-ncr-sysv4; exit; } ;;
    NCR*:*:4.2:* | MPRAS*:*:4.2:*)
	OS_REL='.3'
	test -r /etc/.relid \
	    && OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
	    && { echo i486-ncr-sysv4.3${OS_REL}; exit; }
	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
	    && { echo i586-ncr-sysv4.3${OS_REL}; exit; }
	/bin/uname -p 2>/dev/null | /bin/grep pteron >/dev/null \
	    && { echo i586-ncr-sysv4.3${OS_REL}; exit; } ;;
    m68*:LynxOS:2.*:* | m68*:LynxOS:3.0*:*)
	echo m68k-${VENDOR}-lynxos${UNAME_RELEASE}
	exit ;;
    mc68030:UNIX_System_V:4.*:*)
	echo m68k-atari-sysv4
	exit ;;
    TSUNAMI:LynxOS:2.*:*)
	echo sparc-${VENDOR}-lynxos${UNAME_RELEASE}
	exit ;;
    rs6000:LynxOS:2.*:*)
	echo rs6000-${VENDOR}-lynxos${UNAME_RELEASE}
	exit ;;
    PowerPC:LynxOS:2.*:* | PowerPC:LynxOS:3.[01]*:* | PowerPC:LynxOS:4.[02]*:*)
	echo powerpc-${VENDOR}-lynxos${UNAME_RELEASE}
	exit ;;
    SM[BE]S:UNIX_SV:*:*)
	echo mips-dde-sysv${UNAME_RELEASE}
	exit ;;
    RM*:ReliantUNIX-*:*:*)
	echo mips-sni-sysv4
	exit ;;
    RM*:SINIX-*:*:*)
	echo mips-sni-sysv4
	exit ;;
    *:SINIX-*:*:*)
	if uname -p 2>/dev/null >/dev/null ; then
		UNAME_MACHINE=`(uname -p) 2>/dev/null`
		echo ${UNAME_MACHINE}-sni-sysv4
	else
		echo ns32k-sni-sysv
	fi
	exit ;;
    PENTIUM:*:4.0*:*)	# Unisys `ClearPath HMP IX 4000' SVR4/MP effort
			# says <Richard.M.Bartel@ccMail.Census.GOV>
	echo i586-unisys-sysv4
	exit ;;
    *:UNIX_System_V:4*:FTX*)
	# From Gerald Hewes <hewes@openmarket.com>.
	# How about differentiating between stratus architectures? -djm
	echo hppa1.1-stratus-sysv4
	exit ;;
    *:*:*:FTX*)
	# From seanf@swdc.stratus.com.
	echo i860-stratus-sysv4
	exit ;;
    i*86:VOS:*:*)
	# From Paul.Green@stratus.com.
	echo ${UNAME_MACHINE}-stratus-vos
	exit ;;
    *:VOS:*:*)
	# From Paul.Green@stratus.com.
	echo hppa1.1-stratus-vos
	exit ;;
    mc68*:A/UX:*:*)
	echo m68k-apple-aux${UNAME_RELEASE}
	exit ;;
    news*:NEWS-OS:6*:*)
	echo mips-sony-newsos6
	exit ;;
    R[34]000:*System_V*:*:* | R4000:UNIX_SYSV:*:* | R*000:UNIX_SV:*:*)
	if [ -d /usr/nec ]; then
		echo mips-nec-sysv${UNAME_RELEASE}
	else
		echo mips-${VENDOR}-sysv${UNAME_RELEASE}
	fi
	exit ;;
    BeBox:BeOS:*:*)	# BeOS running on hardware made by Be, PPC only.
	echo powerpc-be-beos
	exit ;;
    BeMac:BeOS:*:*)	# BeOS running on Mac or Mac clone, PPC only.
	echo powerpc-apple-beos
	exit ;;
    BePC:BeOS:*:*)	# BeOS running on Intel PC compatible.
	echo i586-pc-beos
	exit ;;
    BePC:Haiku:*:*)	# Haiku running on Intel PC compatible.
	echo i586-pc-haiku
	exit ;;
    x86_64:Haiku:*:*)
	echo x86_64-${VENDOR}-haiku
	exit ;;
    SX-4:SUPER-UX:*:*)
	echo sx4-nec-superux${UNAME_RELEASE}
	exit ;;
    SX-5:SUPER-UX:*:*)
	echo sx5-nec-superux${UNAME_RELEASE}
	exit ;;
    SX-6:SUPER-UX:*:*)
	echo sx6-nec-superux${UNAME_RELEASE}
	exit ;;
    SX-7:SUPER-UX:*:*)
	echo sx7-nec-superux${UNAME_RELEASE}
	exit ;;
    SX-8:SUPER-UX:*:*)
	echo sx8-nec-superux${UNAME_RELEASE}
	exit ;;
    SX-8R:SUPER-UX:*:*)
	echo sx8r-nec-superux${UNAME_RELEASE}
	exit ;;
    SX-ACE:SUPER-UX:*:*)
	echo sxace-nec-superux${UNAME_RELEASE}
	exit ;;
    Power*:Rhapsody:*:*)
	echo powerpc-apple-rhapsody${UNAME_RELEASE}
	exit ;;
    *:Rhapsody:*:*)
	echo ${UNAME_MACHINE}-apple-rhapsody${UNAME_RELEASE}
	exit ;;
    *:Darwin:*:*)
	UNAME_PROCESSOR=`uname -p` || UNAME_PROCESSOR=unknown
	eval $set_cc_for_build
	if test "$UNAME_PROCESSOR" = unknown ; then
	    UNAME_PROCESSOR=powerpc
	fi
	if test `echo "$UNAME_RELEASE" | sed -e 's/\..*//'` -le 10 ; then
	    if [ "$CC_FOR_BUILD" != no_compiler_found ]; then
		if (echo '#ifdef __LP64__'; echo IS_64BIT_ARCH; echo '#endif') | \
		       (CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
		       grep IS_64BIT_ARCH >/dev/null
		then
		    case $UNAME_PROCESSOR in
			i386) UNAME_PROCESSOR=x86_64 ;;
			powerpc) UNAME_PROCESSOR=powerpc64 ;;
		    esac
		fi
		# On 10.4-10.6 one might compile for PowerPC via gcc -arch ppc
		if (echo '#ifdef __POWERPC__'; echo IS_PPC; echo '#endif') | \
		       (CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
		       grep IS_PPC >/dev/null
		then
		    UNAME_PROCESSOR=powerpc
		fi
	    fi
	elif test "$UNAME_PROCESSOR" = i386 ; then
	    # Avoid executing cc on OS X 10.9, as it ships with a stub
	    # that puts up a graphical alert prompting to install
	    # developer tools.  Any system running Mac OS X 10.7 or
	    # later (Darwin 11 and later) is required to have a 64-bit
	    # processor. This is not true of the ARM version of Darwin
	    # that Apple uses in portable devices.
	    UNAME_PROCESSOR=x86_64
	fi
	echo ${UNAME_PROCESSOR}-apple-darwin${UNAME_RELEASE}
	exit ;;
    *:procnto*:*:* | *:QNX:[0123456789]*:*)
	UNAME_PROCESSOR=`uname -p`
	if test "$UNAME_PROCESSOR" = x86; then
		UNAME_PROCESSOR=i386
		UNAME_MACHINE=pc
	fi
	echo ${UNAME_PROCESSOR}-${UNAME_MACHINE}-nto-qnx${UNAME_RELEASE}
	exit ;;
    *:QNX:*:4*)
	echo i386-pc-qnx
	exit ;;
    NEO-*:NONSTOP_KERNEL:*:*)
	echo neo-tandem-nsk${UNAME_RELEASE}
	exit ;;
    NSE-*:NONSTOP_KERNEL:*:*)
	echo nse-tandem-nsk${UNAME_RELEASE}
	exit ;;
    NSR-*:NONSTOP_KERNEL:*:*)
	echo nsr-tandem-nsk${UNAME_RELEASE}
	exit ;;
    NSX-*:NONSTOP_KERNEL:*:*)
	echo nsx-tandem-nsk${UNAME_RELEASE}
	exit ;;
    *:NonStop-UX:*:*)
	echo mips-compaq-nonstopux
	exit ;;
    BS2000:POSIX*:*:*)
	echo bs2000-siemens-sysv
	exit ;;
    DS/*:UNIX_System_V:*:*)
	echo ${UNAME_MACHINE}-${UNAME_SYSTEM}-${UNAME_RELEASE}
	exit ;;
    *:Plan9:*:*)
	# "uname -m" is not consistent, so use $cputype instead. 386
	# is converted to i386 for consistency with other x86
	# operating systems.
	if test "$cputype" = 386; then
	    UNAME_MACHINE=i386
	else
	    UNAME_MACHINE="$cputype"
	fi
	echo ${UNAME_MACHINE}-${VENDOR}-plan9
	exit ;;
    *:TOPS-10:*:*)
	echo pdp10-${VENDOR}-tops10
	exit ;;
    *:TENEX:*:*)
	echo pdp10-${VENDOR}-tenex
	exit ;;
    KS10:TOPS-20:*:* | KL10:TOPS-20:*:* | TYPE4:TOPS-20:*:*)
	echo pdp10-dec-tops20
	exit ;;
    XKL-1:TOPS-20:*:* | TYPE5:TOPS-20:*:*)
	echo pdp10-xkl-tops20
	exit ;;
    *:TOPS-20:*:*)
	echo pdp10-${VENDOR}-tops20
	exit ;;
    *:ITS:*:*)
	echo pdp10-${VENDOR}-its
	exit ;;
    SEI:*:*:SEIUX)
	echo mips-sei-seiux${UNAME_RELEASE}
	exit ;;
    *:DragonFly:*:*)
	echo ${UNAME_MACHINE}-${VENDOR}-dragonfly`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`
	exit ;;
    *:*VMS:*:*)
	UNAME_MACHINE=`(uname -p) 2>/dev/null`
	case "${UNAME_MACHINE}" in
	    A*) echo alpha-dec-vms ; exit ;;
	    I*) echo ia64-dec-vms ; exit ;;
	    V*) echo vax-dec-vms ; exit ;;
	esac ;;
    *:XENIX:*:SysV)
	echo i386-pc-xenix
	exit ;;
    i*86:skyos:*:*)
	echo ${UNAME_MACHINE}-pc-skyos`echo ${UNAME_RELEASE} | sed -e 's/ .*$//'`
	exit ;;
    i*86:rdos:*:*)
	echo ${UNAME_MACHINE}-pc-rdos
	exit ;;
    i*86:AROS:*:*)
	echo ${UNAME_MACHINE}-pc-aros
	exit ;;
    x86_64:VMkernel:*:*)
	echo ${UNAME_MACHINE}-${VENDOR}-esx
	exit ;;
    amd64:Isilon\ OneFS:*:*)
	echo x86_64-${VENDOR}-onefs
	exit ;;
esac

cat >&2 <<EOF
$0: unable to guess system type

This script (version $timestamp), has failed to recognize the
operating system you are using. If your script is old, overwrite
config.guess and config.sub with the latest versions from:

  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess
and
  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub

If $0 has already been updated, send the following data and any
information you think might be pertinent to config-patches@gnu.org to
provide the necessary information to handle your system.

config.guess timestamp = $timestamp

uname -m = `(uname -m) 2>/dev/null || echo unknown`
uname -r = `(uname -r) 2>/dev/null || echo unknown`
uname -s = `(uname -s) 2>/dev/null || echo unknown`
uname -v = `(uname -v) 2>/dev/null || echo unknown`

/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null`
/bin/uname -X     = `(/bin/uname -X) 2>/dev/null`

hostinfo               = `(hostinfo) 2>/dev/null`
/bin/universe          = `(/bin/universe) 2>/dev/null`
/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null`
/bin/arch              = `(/bin/arch) 2>/dev/null`
/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null`
/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null`

UNAME_MACHINE = ${UNAME_MACHINE}
UNAME_RELEASE = ${UNAME_RELEASE}
UNAME_SYSTEM  = ${UNAME_SYSTEM}
UNAME_VERSION = ${UNAME_VERSION}
EOF

exit 1

# Local variables:
# eval: (add-hook 'write-file-hooks 'time-stamp)
# time-stamp-start: "timestamp='"
# time-stamp-format: "%:y-%02m-%02d"
# time-stamp-end: "'"
# End:

```

`config-aux/config.sub`:

```sub
#! /bin/sh
# Configuration validation subroutine script.
#   Copyright 1992-2017 Free Software Foundation, Inc.

timestamp='2017-04-02'

# This file is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, see <http://www.gnu.org/licenses/>.
#
# As a special exception to the GNU General Public License, if you
# distribute this file as part of a program that contains a
# configuration script generated by Autoconf, you may include it under
# the same distribution terms that you use for the rest of that
# program.  This Exception is an additional permission under section 7
# of the GNU General Public License, version 3 ("GPLv3").


# Please send patches to <config-patches@gnu.org>.
#
# Configuration subroutine to validate and canonicalize a configuration type.
# Supply the specified configuration type as an argument.
# If it is invalid, we print an error message on stderr and exit with code 1.
# Otherwise, we print the canonical config type on stdout and succeed.

# You can get the latest version of this script from:
# http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub

# This file is supposed to be the same for all GNU packages
# and recognize all the CPU types, system types and aliases
# that are meaningful with *any* GNU software.
# Each package is responsible for reporting which valid configurations
# it does not support.  The user should be able to distinguish
# a failure to support a valid configuration from a meaningless
# configuration.

# The goal of this file is to map all the various variations of a given
# machine specification into a single specification in the form:
#	CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM
# or in some cases, the newer four-part form:
#	CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM
# It is wrong to echo any other type of specification.

me=`echo "$0" | sed -e 's,.*/,,'`

usage="\
Usage: $0 [OPTION] CPU-MFR-OPSYS or ALIAS

Canonicalize a configuration name.

Operation modes:
  -h, --help         print this help, then exit
  -t, --time-stamp   print date of last modification, then exit
  -v, --version      print version number, then exit

Report bugs and patches to <config-patches@gnu.org>."

version="\
GNU config.sub ($timestamp)

Copyright 1992-2017 Free Software Foundation, Inc.

This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."

help="
Try \`$me --help' for more information."

# Parse command line
while test $# -gt 0 ; do
  case $1 in
    --time-stamp | --time* | -t )
       echo "$timestamp" ; exit ;;
    --version | -v )
       echo "$version" ; exit ;;
    --help | --h* | -h )
       echo "$usage"; exit ;;
    -- )     # Stop option processing
       shift; break ;;
    - )	# Use stdin as input.
       break ;;
    -* )
       echo "$me: invalid option $1$help"
       exit 1 ;;

    *local*)
       # First pass through any local machine types.
       echo $1
       exit ;;

    * )
       break ;;
  esac
done

case $# in
 0) echo "$me: missing argument$help" >&2
    exit 1;;
 1) ;;
 *) echo "$me: too many arguments$help" >&2
    exit 1;;
esac

# Separate what the user gave into CPU-COMPANY and OS or KERNEL-OS (if any).
# Here we must recognize all the valid KERNEL-OS combinations.
maybe_os=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\2/'`
case $maybe_os in
  nto-qnx* | linux-gnu* | linux-android* | linux-dietlibc | linux-newlib* | \
  linux-musl* | linux-uclibc* | uclinux-uclibc* | uclinux-gnu* | kfreebsd*-gnu* | \
  knetbsd*-gnu* | netbsd*-gnu* | netbsd*-eabi* | \
  kopensolaris*-gnu* | cloudabi*-eabi* | \
  storm-chaos* | os2-emx* | rtmk-nova*)
    os=-$maybe_os
    basic_machine=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\1/'`
    ;;
  android-linux)
    os=-linux-android
    basic_machine=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\1/'`-unknown
    ;;
  *)
    basic_machine=`echo $1 | sed 's/-[^-]*$//'`
    if [ $basic_machine != $1 ]
    then os=`echo $1 | sed 's/.*-/-/'`
    else os=; fi
    ;;
esac

### Let's recognize common machines as not being operating systems so
### that things like config.sub decstation-3100 work.  We also
### recognize some manufacturers as not being operating systems, so we
### can provide default operating systems below.
case $os in
	-sun*os*)
		# Prevent following clause from handling this invalid input.
		;;
	-dec* | -mips* | -sequent* | -encore* | -pc532* | -sgi* | -sony* | \
	-att* | -7300* | -3300* | -delta* | -motorola* | -sun[234]* | \
	-unicom* | -ibm* | -next | -hp | -isi* | -apollo | -altos* | \
	-convergent* | -ncr* | -news | -32* | -3600* | -3100* | -hitachi* |\
	-c[123]* | -convex* | -sun | -crds | -omron* | -dg | -ultra | -tti* | \
	-harris | -dolphin | -highlevel | -gould | -cbm | -ns | -masscomp | \
	-apple | -axis | -knuth | -cray | -microblaze*)
		os=
		basic_machine=$1
		;;
	-bluegene*)
		os=-cnk
		;;
	-sim | -cisco | -oki | -wec | -winbond)
		os=
		basic_machine=$1
		;;
	-scout)
		;;
	-wrs)
		os=-vxworks
		basic_machine=$1
		;;
	-chorusos*)
		os=-chorusos
		basic_machine=$1
		;;
	-chorusrdb)
		os=-chorusrdb
		basic_machine=$1
		;;
	-hiux*)
		os=-hiuxwe2
		;;
	-sco6)
		os=-sco5v6
		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
		;;
	-sco5)
		os=-sco3.2v5
		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
		;;
	-sco4)
		os=-sco3.2v4
		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
		;;
	-sco3.2.[4-9]*)
		os=`echo $os | sed -e 's/sco3.2./sco3.2v/'`
		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
		;;
	-sco3.2v[4-9]*)
		# Don't forget version if it is 3.2v4 or newer.
		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
		;;
	-sco5v6*)
		# Don't forget version if it is 3.2v4 or newer.
		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
		;;
	-sco*)
		os=-sco3.2v2
		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
		;;
	-udk*)
		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
		;;
	-isc)
		os=-isc2.2
		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
		;;
	-clix*)
		basic_machine=clipper-intergraph
		;;
	-isc*)
		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
		;;
	-lynx*178)
		os=-lynxos178
		;;
	-lynx*5)
		os=-lynxos5
		;;
	-lynx*)
		os=-lynxos
		;;
	-ptx*)
		basic_machine=`echo $1 | sed -e 's/86-.*/86-sequent/'`
		;;
	-windowsnt*)
		os=`echo $os | sed -e 's/windowsnt/winnt/'`
		;;
	-psos*)
		os=-psos
		;;
	-mintelf | -mintelf[0-9]*)
		basic_machine=m68k-atari
		os=-mintelf
		;;
	-mint | -mint[0-9]*)
		basic_machine=m68k-atari
		os=-mint
		;;
esac

# Decode aliases for certain CPU-COMPANY combinations.
case $basic_machine in
	# Recognize the basic CPU types without company name.
	# Some are omitted here because they have special meanings below.
	1750a | 580 \
	| a29k \
	| aarch64 | aarch64_be \
	| alpha | alphaev[4-8] | alphaev56 | alphaev6[78] | alphapca5[67] \
	| alpha64 | alpha64ev[4-8] | alpha64ev56 | alpha64ev6[78] | alpha64pca5[67] \
	| am33_2.0 \
	| arc | arceb \
	| arm | arm[bl]e | arme[lb] | armv[2-8] | armv[3-8][lb] | armv7[arm] \
	| avr | avr32 \
	| ba \
	| be32 | be64 \
	| bfin \
	| c4x | c8051 | clipper \
	| d10v | d30v | dlx | dsp16xx \
	| e2k | epiphany \
	| fido | fr30 | frv | ft32 \
	| h8300 | h8500 | hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \
	| hexagon \
	| i370 | i860 | i960 | ia16 | ia64 \
	| ip2k | iq2000 \
	| k1om \
	| le32 | le64 \
	| lm32 \
	| m32c | m32r | m32rle | m68000 | m68k | m88k \
	| maxq | mb | microblaze | microblazeel | mcore | mep | metag \
	| mips | mipsbe | mipseb | mipsel | mipsle \
	| mips16 \
	| mips64 | mips64el \
	| mips64octeon | mips64octeonel \
	| mips64orion | mips64orionel \
	| mips64r5900 | mips64r5900el \
	| mips64vr | mips64vrel \
	| mips64vr4100 | mips64vr4100el \
	| mips64vr4300 | mips64vr4300el \
	| mips64vr5000 | mips64vr5000el \
	| mips64vr5900 | mips64vr5900el \
	| mipsisa32 | mipsisa32el \
	| mipsisa32r2 | mipsisa32r2el \
	| mipsisa32r6 | mipsisa32r6el \
	| mipsisa64 | mipsisa64el \
	| mipsisa64r2 | mipsisa64r2el \
	| mipsisa64r6 | mipsisa64r6el \
	| mipsisa64sb1 | mipsisa64sb1el \
	| mipsisa64sr71k | mipsisa64sr71kel \
	| mipsr5900 | mipsr5900el \
	| mipstx39 | mipstx39el \
	| mn10200 | mn10300 \
	| moxie \
	| mt \
	| msp430 \
	| nds32 | nds32le | nds32be \
	| nios | nios2 | nios2eb | nios2el \
	| ns16k | ns32k \
	| open8 | or1k | or1knd | or32 \
	| pdp10 | pdp11 | pj | pjl \
	| powerpc | powerpc64 | powerpc64le | powerpcle \
	| pru \
	| pyramid \
	| riscv32 | riscv64 \
	| rl78 | rx \
	| score \
	| sh | sh[1234] | sh[24]a | sh[24]aeb | sh[23]e | sh[234]eb | sheb | shbe | shle | sh[1234]le | sh3ele \
	| sh64 | sh64le \
	| sparc | sparc64 | sparc64b | sparc64v | sparc86x | sparclet | sparclite \
	| sparcv8 | sparcv9 | sparcv9b | sparcv9v \
	| spu \
	| tahoe | tic4x | tic54x | tic55x | tic6x | tic80 | tron \
	| ubicom32 \
	| v850 | v850e | v850e1 | v850e2 | v850es | v850e2v3 \
	| visium \
	| wasm32 \
	| we32k \
	| x86 | xc16x | xstormy16 | xtensa \
	| z8k | z80)
		basic_machine=$basic_machine-unknown
		;;
	c54x)
		basic_machine=tic54x-unknown
		;;
	c55x)
		basic_machine=tic55x-unknown
		;;
	c6x)
		basic_machine=tic6x-unknown
		;;
	leon|leon[3-9])
		basic_machine=sparc-$basic_machine
		;;
	m6811 | m68hc11 | m6812 | m68hc12 | m68hcs12x | nvptx | picochip)
		basic_machine=$basic_machine-unknown
		os=-none
		;;
	m88110 | m680[12346]0 | m683?2 | m68360 | m5200 | v70 | w65 | z8k)
		;;
	ms1)
		basic_machine=mt-unknown
		;;

	strongarm | thumb | xscale)
		basic_machine=arm-unknown
		;;
	xgate)
		basic_machine=$basic_machine-unknown
		os=-none
		;;
	xscaleeb)
		basic_machine=armeb-unknown
		;;

	xscaleel)
		basic_machine=armel-unknown
		;;

	# We use `pc' rather than `unknown'
	# because (1) that's what they normally are, and
	# (2) the word "unknown" tends to confuse beginning users.
	i*86 | x86_64)
	  basic_machine=$basic_machine-pc
	  ;;
	# Object if more than one company name word.
	*-*-*)
		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1>&2
		exit 1
		;;
	# Recognize the basic CPU types with company name.
	580-* \
	| a29k-* \
	| aarch64-* | aarch64_be-* \
	| alpha-* | alphaev[4-8]-* | alphaev56-* | alphaev6[78]-* \
	| alpha64-* | alpha64ev[4-8]-* | alpha64ev56-* | alpha64ev6[78]-* \
	| alphapca5[67]-* | alpha64pca5[67]-* | arc-* | arceb-* \
	| arm-*  | armbe-* | armle-* | armeb-* | armv*-* \
	| avr-* | avr32-* \
	| ba-* \
	| be32-* | be64-* \
	| bfin-* | bs2000-* \
	| c[123]* | c30-* | [cjt]90-* | c4x-* \
	| c8051-* | clipper-* | craynv-* | cydra-* \
	| d10v-* | d30v-* | dlx-* \
	| e2k-* | elxsi-* \
	| f30[01]-* | f700-* | fido-* | fr30-* | frv-* | fx80-* \
	| h8300-* | h8500-* \
	| hppa-* | hppa1.[01]-* | hppa2.0-* | hppa2.0[nw]-* | hppa64-* \
	| hexagon-* \
	| i*86-* | i860-* | i960-* | ia16-* | ia64-* \
	| ip2k-* | iq2000-* \
	| k1om-* \
	| le32-* | le64-* \
	| lm32-* \
	| m32c-* | m32r-* | m32rle-* \
	| m68000-* | m680[012346]0-* | m68360-* | m683?2-* | m68k-* \
	| m88110-* | m88k-* | maxq-* | mcore-* | metag-* \
	| microblaze-* | microblazeel-* \
	| mips-* | mipsbe-* | mipseb-* | mipsel-* | mipsle-* \
	| mips16-* \
	| mips64-* | mips64el-* \
	| mips64octeon-* | mips64octeonel-* \
	| mips64orion-* | mips64orionel-* \
	| mips64r5900-* | mips64r5900el-* \
	| mips64vr-* | mips64vrel-* \
	| mips64vr4100-* | mips64vr4100el-* \
	| mips64vr4300-* | mips64vr4300el-* \
	| mips64vr5000-* | mips64vr5000el-* \
	| mips64vr5900-* | mips64vr5900el-* \
	| mipsisa32-* | mipsisa32el-* \
	| mipsisa32r2-* | mipsisa32r2el-* \
	| mipsisa32r6-* | mipsisa32r6el-* \
	| mipsisa64-* | mipsisa64el-* \
	| mipsisa64r2-* | mipsisa64r2el-* \
	| mipsisa64r6-* | mipsisa64r6el-* \
	| mipsisa64sb1-* | mipsisa64sb1el-* \
	| mipsisa64sr71k-* | mipsisa64sr71kel-* \
	| mipsr5900-* | mipsr5900el-* \
	| mipstx39-* | mipstx39el-* \
	| mmix-* \
	| mt-* \
	| msp430-* \
	| nds32-* | nds32le-* | nds32be-* \
	| nios-* | nios2-* | nios2eb-* | nios2el-* \
	| none-* | np1-* | ns16k-* | ns32k-* \
	| open8-* \
	| or1k*-* \
	| orion-* \
	| pdp10-* | pdp11-* | pj-* | pjl-* | pn-* | power-* \
	| powerpc-* | powerpc64-* | powerpc64le-* | powerpcle-* \
	| pru-* \
	| pyramid-* \
	| riscv32-* | riscv64-* \
	| rl78-* | romp-* | rs6000-* | rx-* \
	| sh-* | sh[1234]-* | sh[24]a-* | sh[24]aeb-* | sh[23]e-* | sh[34]eb-* | sheb-* | shbe-* \
	| shle-* | sh[1234]le-* | sh3ele-* | sh64-* | sh64le-* \
	| sparc-* | sparc64-* | sparc64b-* | sparc64v-* | sparc86x-* | sparclet-* \
	| sparclite-* \
	| sparcv8-* | sparcv9-* | sparcv9b-* | sparcv9v-* | sv1-* | sx*-* \
	| tahoe-* \
	| tic30-* | tic4x-* | tic54x-* | tic55x-* | tic6x-* | tic80-* \
	| tile*-* \
	| tron-* \
	| ubicom32-* \
	| v850-* | v850e-* | v850e1-* | v850es-* | v850e2-* | v850e2v3-* \
	| vax-* \
	| visium-* \
	| wasm32-* \
	| we32k-* \
	| x86-* | x86_64-* | xc16x-* | xps100-* \
	| xstormy16-* | xtensa*-* \
	| ymp-* \
	| z8k-* | z80-*)
		;;
	# Recognize the basic CPU types without company name, with glob match.
	xtensa*)
		basic_machine=$basic_machine-unknown
		;;
	# Recognize the various machine names and aliases which stand
	# for a CPU type and a company and sometimes even an OS.
	386bsd)
		basic_machine=i386-unknown
		os=-bsd
		;;
	3b1 | 7300 | 7300-att | att-7300 | pc7300 | safari | unixpc)
		basic_machine=m68000-att
		;;
	3b*)
		basic_machine=we32k-att
		;;
	a29khif)
		basic_machine=a29k-amd
		os=-udi
		;;
	abacus)
		basic_machine=abacus-unknown
		;;
	adobe68k)
		basic_machine=m68010-adobe
		os=-scout
		;;
	alliant | fx80)
		basic_machine=fx80-alliant
		;;
	altos | altos3068)
		basic_machine=m68k-altos
		;;
	am29k)
		basic_machine=a29k-none
		os=-bsd
		;;
	amd64)
		basic_machine=x86_64-pc
		;;
	amd64-*)
		basic_machine=x86_64-`echo $basic_machine | sed 's/^[^-]*-//'`
		;;
	amdahl)
		basic_machine=580-amdahl
		os=-sysv
		;;
	amiga | amiga-*)
		basic_machine=m68k-unknown
		;;
	amigaos | amigados)
		basic_machine=m68k-unknown
		os=-amigaos
		;;
	amigaunix | amix)
		basic_machine=m68k-unknown
		os=-sysv4
		;;
	apollo68)
		basic_machine=m68k-apollo
		os=-sysv
		;;
	apollo68bsd)
		basic_machine=m68k-apollo
		os=-bsd
		;;
	aros)
		basic_machine=i386-pc
		os=-aros
		;;
	asmjs)
		basic_machine=asmjs-unknown
		;;
	aux)
		basic_machine=m68k-apple
		os=-aux
		;;
	balance)
		basic_machine=ns32k-sequent
		os=-dynix
		;;
	blackfin)
		basic_machine=bfin-unknown
		os=-linux
		;;
	blackfin-*)
		basic_machine=bfin-`echo $basic_machine | sed 's/^[^-]*-//'`
		os=-linux
		;;
	bluegene*)
		basic_machine=powerpc-ibm
		os=-cnk
		;;
	c54x-*)
		basic_machine=tic54x-`echo $basic_machine | sed 's/^[^-]*-//'`
		;;
	c55x-*)
		basic_machine=tic55x-`echo $basic_machine | sed 's/^[^-]*-//'`
		;;
	c6x-*)
		basic_machine=tic6x-`echo $basic_machine | sed 's/^[^-]*-//'`
		;;
	c90)
		basic_machine=c90-cray
		os=-unicos
		;;
	cegcc)
		basic_machine=arm-unknown
		os=-cegcc
		;;
	convex-c1)
		basic_machine=c1-convex
		os=-bsd
		;;
	convex-c2)
		basic_machine=c2-convex
		os=-bsd
		;;
	convex-c32)
		basic_machine=c32-convex
		os=-bsd
		;;
	convex-c34)
		basic_machine=c34-convex
		os=-bsd
		;;
	convex-c38)
		basic_machine=c38-convex
		os=-bsd
		;;
	cray | j90)
		basic_machine=j90-cray
		os=-unicos
		;;
	craynv)
		basic_machine=craynv-cray
		os=-unicosmp
		;;
	cr16 | cr16-*)
		basic_machine=cr16-unknown
		os=-elf
		;;
	crds | unos)
		basic_machine=m68k-crds
		;;
	crisv32 | crisv32-* | etraxfs*)
		basic_machine=crisv32-axis
		;;
	cris | cris-* | etrax*)
		basic_machine=cris-axis
		;;
	crx)
		basic_machine=crx-unknown
		os=-elf
		;;
	da30 | da30-*)
		basic_machine=m68k-da30
		;;
	decstation | decstation-3100 | pmax | pmax-* | pmin | dec3100 | decstatn)
		basic_machine=mips-dec
		;;
	decsystem10* | dec10*)
		basic_machine=pdp10-dec
		os=-tops10
		;;
	decsystem20* | dec20*)
		basic_machine=pdp10-dec
		os=-tops20
		;;
	delta | 3300 | motorola-3300 | motorola-delta \
	      | 3300-motorola | delta-motorola)
		basic_machine=m68k-motorola
		;;
	delta88)
		basic_machine=m88k-motorola
		os=-sysv3
		;;
	dicos)
		basic_machine=i686-pc
		os=-dicos
		;;
	djgpp)
		basic_machine=i586-pc
		os=-msdosdjgpp
		;;
	dpx20 | dpx20-*)
		basic_machine=rs6000-bull
		os=-bosx
		;;
	dpx2* | dpx2*-bull)
		basic_machine=m68k-bull
		os=-sysv3
		;;
	e500v[12])
		basic_machine=powerpc-unknown
		os=$os"spe"
		;;
	e500v[12]-*)
		basic_machine=powerpc-`echo $basic_machine | sed 's/^[^-]*-//'`
		os=$os"spe"
		;;
	ebmon29k)
		basic_machine=a29k-amd
		os=-ebmon
		;;
	elxsi)
		basic_machine=elxsi-elxsi
		os=-bsd
		;;
	encore | umax | mmax)
		basic_machine=ns32k-encore
		;;
	es1800 | OSE68k | ose68k | ose | OSE)
		basic_machine=m68k-ericsson
		os=-ose
		;;
	fx2800)
		basic_machine=i860-alliant
		;;
	genix)
		basic_machine=ns32k-ns
		;;
	gmicro)
		basic_machine=tron-gmicro
		os=-sysv
		;;
	go32)
		basic_machine=i386-pc
		os=-go32
		;;
	h3050r* | hiux*)
		basic_machine=hppa1.1-hitachi
		os=-hiuxwe2
		;;
	h8300hms)
		basic_machine=h8300-hitachi
		os=-hms
		;;
	h8300xray)
		basic_machine=h8300-hitachi
		os=-xray
		;;
	h8500hms)
		basic_machine=h8500-hitachi
		os=-hms
		;;
	harris)
		basic_machine=m88k-harris
		os=-sysv3
		;;
	hp300-*)
		basic_machine=m68k-hp
		;;
	hp300bsd)
		basic_machine=m68k-hp
		os=-bsd
		;;
	hp300hpux)
		basic_machine=m68k-hp
		os=-hpux
		;;
	hp3k9[0-9][0-9] | hp9[0-9][0-9])
		basic_machine=hppa1.0-hp
		;;
	hp9k2[0-9][0-9] | hp9k31[0-9])
		basic_machine=m68000-hp
		;;
	hp9k3[2-9][0-9])
		basic_machine=m68k-hp
		;;
	hp9k6[0-9][0-9] | hp6[0-9][0-9])
		basic_machine=hppa1.0-hp
		;;
	hp9k7[0-79][0-9] | hp7[0-79][0-9])
		basic_machine=hppa1.1-hp
		;;
	hp9k78[0-9] | hp78[0-9])
		# FIXME: really hppa2.0-hp
		basic_machine=hppa1.1-hp
		;;
	hp9k8[67]1 | hp8[67]1 | hp9k80[24] | hp80[24] | hp9k8[78]9 | hp8[78]9 | hp9k893 | hp893)
		# FIXME: really hppa2.0-hp
		basic_machine=hppa1.1-hp
		;;
	hp9k8[0-9][13679] | hp8[0-9][13679])
		basic_machine=hppa1.1-hp
		;;
	hp9k8[0-9][0-9] | hp8[0-9][0-9])
		basic_machine=hppa1.0-hp
		;;
	hppa-next)
		os=-nextstep3
		;;
	hppaosf)
		basic_machine=hppa1.1-hp
		os=-osf
		;;
	hppro)
		basic_machine=hppa1.1-hp
		os=-proelf
		;;
	i370-ibm* | ibm*)
		basic_machine=i370-ibm
		;;
	i*86v32)
		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
		os=-sysv32
		;;
	i*86v4*)
		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
		os=-sysv4
		;;
	i*86v)
		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
		os=-sysv
		;;
	i*86sol2)
		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
		os=-solaris2
		;;
	i386mach)
		basic_machine=i386-mach
		os=-mach
		;;
	i386-vsta | vsta)
		basic_machine=i386-unknown
		os=-vsta
		;;
	iris | iris4d)
		basic_machine=mips-sgi
		case $os in
		    -irix*)
			;;
		    *)
			os=-irix4
			;;
		esac
		;;
	isi68 | isi)
		basic_machine=m68k-isi
		os=-sysv
		;;
	leon-*|leon[3-9]-*)
		basic_machine=sparc-`echo $basic_machine | sed 's/-.*//'`
		;;
	m68knommu)
		basic_machine=m68k-unknown
		os=-linux
		;;
	m68knommu-*)
		basic_machine=m68k-`echo $basic_machine | sed 's/^[^-]*-//'`
		os=-linux
		;;
	m88k-omron*)
		basic_machine=m88k-omron
		;;
	magnum | m3230)
		basic_machine=mips-mips
		os=-sysv
		;;
	merlin)
		basic_machine=ns32k-utek
		os=-sysv
		;;
	microblaze*)
		basic_machine=microblaze-xilinx
		;;
	mingw64)
		basic_machine=x86_64-pc
		os=-mingw64
		;;
	mingw32)
		basic_machine=i686-pc
		os=-mingw32
		;;
	mingw32ce)
		basic_machine=arm-unknown
		os=-mingw32ce
		;;
	miniframe)
		basic_machine=m68000-convergent
		;;
	*mintelf | -mintelf[0-9]*)
		basic_machine=m68k-atari
		os=-mintelf
		;;
	*mint | -mint[0-9]* | *MiNT | *MiNT[0-9]*)
		basic_machine=m68k-atari
		os=-mint
		;;
	mips3*-*)
		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`
		;;
	mips3*)
		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`-unknown
		;;
	monitor)
		basic_machine=m68k-rom68k
		os=-coff
		;;
	morphos)
		basic_machine=powerpc-unknown
		os=-morphos
		;;
	moxiebox)
		basic_machine=moxie-unknown
		os=-moxiebox
		;;
	msdos)
		basic_machine=i386-pc
		os=-msdos
		;;
	ms1-*)
		basic_machine=`echo $basic_machine | sed -e 's/ms1-/mt-/'`
		;;
	msys)
		basic_machine=i686-pc
		os=-msys
		;;
	mvs)
		basic_machine=i370-ibm
		os=-mvs
		;;
	nacl)
		basic_machine=le32-unknown
		os=-nacl
		;;
	ncr3000)
		basic_machine=i486-ncr
		os=-sysv4
		;;
	netbsd386)
		basic_machine=i386-unknown
		os=-netbsd
		;;
	netwinder)
		basic_machine=armv4l-rebel
		os=-linux
		;;
	news | news700 | news800 | news900)
		basic_machine=m68k-sony
		os=-newsos
		;;
	news1000)
		basic_machine=m68030-sony
		os=-newsos
		;;
	news-3600 | risc-news)
		basic_machine=mips-sony
		os=-newsos
		;;
	necv70)
		basic_machine=v70-nec
		os=-sysv
		;;
	next | m*-next )
		basic_machine=m68k-next
		case $os in
		    -nextstep* )
			;;
		    -ns2*)
		      os=-nextstep2
			;;
		    *)
		      os=-nextstep3
			;;
		esac
		;;
	nh3000)
		basic_machine=m68k-harris
		os=-cxux
		;;
	nh[45]000)
		basic_machine=m88k-harris
		os=-cxux
		;;
	nindy960)
		basic_machine=i960-intel
		os=-nindy
		;;
	mon960)
		basic_machine=i960-intel
		os=-mon960
		;;
	nonstopux)
		basic_machine=mips-compaq
		os=-nonstopux
		;;
	np1)
		basic_machine=np1-gould
		;;
	neo-tandem)
		basic_machine=neo-tandem
		;;
	nse-tandem)
		basic_machine=nse-tandem
		;;
	nsr-tandem)
		basic_machine=nsr-tandem
		;;
	nsx-tandem)
		basic_machine=nsx-tandem
		;;
	op50n-* | op60c-*)
		basic_machine=hppa1.1-oki
		os=-proelf
		;;
	openrisc | openrisc-*)
		basic_machine=or32-unknown
		;;
	os400)
		basic_machine=powerpc-ibm
		os=-os400
		;;
	OSE68000 | ose68000)
		basic_machine=m68000-ericsson
		os=-ose
		;;
	os68k)
		basic_machine=m68k-none
		os=-os68k
		;;
	pa-hitachi)
		basic_machine=hppa1.1-hitachi
		os=-hiuxwe2
		;;
	paragon)
		basic_machine=i860-intel
		os=-osf
		;;
	parisc)
		basic_machine=hppa-unknown
		os=-linux
		;;
	parisc-*)
		basic_machine=hppa-`echo $basic_machine | sed 's/^[^-]*-//'`
		os=-linux
		;;
	pbd)
		basic_machine=sparc-tti
		;;
	pbb)
		basic_machine=m68k-tti
		;;
	pc532 | pc532-*)
		basic_machine=ns32k-pc532
		;;
	pc98)
		basic_machine=i386-pc
		;;
	pc98-*)
		basic_machine=i386-`echo $basic_machine | sed 's/^[^-]*-//'`
		;;
	pentium | p5 | k5 | k6 | nexgen | viac3)
		basic_machine=i586-pc
		;;
	pentiumpro | p6 | 6x86 | athlon | athlon_*)
		basic_machine=i686-pc
		;;
	pentiumii | pentium2 | pentiumiii | pentium3)
		basic_machine=i686-pc
		;;
	pentium4)
		basic_machine=i786-pc
		;;
	pentium-* | p5-* | k5-* | k6-* | nexgen-* | viac3-*)
		basic_machine=i586-`echo $basic_machine | sed 's/^[^-]*-//'`
		;;
	pentiumpro-* | p6-* | 6x86-* | athlon-*)
		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
		;;
	pentiumii-* | pentium2-* | pentiumiii-* | pentium3-*)
		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
		;;
	pentium4-*)
		basic_machine=i786-`echo $basic_machine | sed 's/^[^-]*-//'`
		;;
	pn)
		basic_machine=pn-gould
		;;
	power)	basic_machine=power-ibm
		;;
	ppc | ppcbe)	basic_machine=powerpc-unknown
		;;
	ppc-* | ppcbe-*)
		basic_machine=powerpc-`echo $basic_machine | sed 's/^[^-]*-//'`
		;;
	ppcle | powerpclittle)
		basic_machine=powerpcle-unknown
		;;
	ppcle-* | powerpclittle-*)
		basic_machine=powerpcle-`echo $basic_machine | sed 's/^[^-]*-//'`
		;;
	ppc64)	basic_machine=powerpc64-unknown
		;;
	ppc64-*) basic_machine=powerpc64-`echo $basic_machine | sed 's/^[^-]*-//'`
		;;
	ppc64le | powerpc64little)
		basic_machine=powerpc64le-unknown
		;;
	ppc64le-* | powerpc64little-*)
		basic_machine=powerpc64le-`echo $basic_machine | sed 's/^[^-]*-//'`
		;;
	ps2)
		basic_machine=i386-ibm
		;;
	pw32)
		basic_machine=i586-unknown
		os=-pw32
		;;
	rdos | rdos64)
		basic_machine=x86_64-pc
		os=-rdos
		;;
	rdos32)
		basic_machine=i386-pc
		os=-rdos
		;;
	rom68k)
		basic_machine=m68k-rom68k
		os=-coff
		;;
	rm[46]00)
		basic_machine=mips-siemens
		;;
	rtpc | rtpc-*)
		basic_machine=romp-ibm
		;;
	s390 | s390-*)
		basic_machine=s390-ibm
		;;
	s390x | s390x-*)
		basic_machine=s390x-ibm
		;;
	sa29200)
		basic_machine=a29k-amd
		os=-udi
		;;
	sb1)
		basic_machine=mipsisa64sb1-unknown
		;;
	sb1el)
		basic_machine=mipsisa64sb1el-unknown
		;;
	sde)
		basic_machine=mipsisa32-sde
		os=-elf
		;;
	sei)
		basic_machine=mips-sei
		os=-seiux
		;;
	sequent)
		basic_machine=i386-sequent
		;;
	sh)
		basic_machine=sh-hitachi
		os=-hms
		;;
	sh5el)
		basic_machine=sh5le-unknown
		;;
	sh64)
		basic_machine=sh64-unknown
		;;
	sparclite-wrs | simso-wrs)
		basic_machine=sparclite-wrs
		os=-vxworks
		;;
	sps7)
		basic_machine=m68k-bull
		os=-sysv2
		;;
	spur)
		basic_machine=spur-unknown
		;;
	st2000)
		basic_machine=m68k-tandem
		;;
	stratus)
		basic_machine=i860-stratus
		os=-sysv4
		;;
	strongarm-* | thumb-*)
		basic_machine=arm-`echo $basic_machine | sed 's/^[^-]*-//'`
		;;
	sun2)
		basic_machine=m68000-sun
		;;
	sun2os3)
		basic_machine=m68000-sun
		os=-sunos3
		;;
	sun2os4)
		basic_machine=m68000-sun
		os=-sunos4
		;;
	sun3os3)
		basic_machine=m68k-sun
		os=-sunos3
		;;
	sun3os4)
		basic_machine=m68k-sun
		os=-sunos4
		;;
	sun4os3)
		basic_machine=sparc-sun
		os=-sunos3
		;;
	sun4os4)
		basic_machine=sparc-sun
		os=-sunos4
		;;
	sun4sol2)
		basic_machine=sparc-sun
		os=-solaris2
		;;
	sun3 | sun3-*)
		basic_machine=m68k-sun
		;;
	sun4)
		basic_machine=sparc-sun
		;;
	sun386 | sun386i | roadrunner)
		basic_machine=i386-sun
		;;
	sv1)
		basic_machine=sv1-cray
		os=-unicos
		;;
	symmetry)
		basic_machine=i386-sequent
		os=-dynix
		;;
	t3e)
		basic_machine=alphaev5-cray
		os=-unicos
		;;
	t90)
		basic_machine=t90-cray
		os=-unicos
		;;
	tile*)
		basic_machine=$basic_machine-unknown
		os=-linux-gnu
		;;
	tx39)
		basic_machine=mipstx39-unknown
		;;
	tx39el)
		basic_machine=mipstx39el-unknown
		;;
	toad1)
		basic_machine=pdp10-xkl
		os=-tops20
		;;
	tower | tower-32)
		basic_machine=m68k-ncr
		;;
	tpf)
		basic_machine=s390x-ibm
		os=-tpf
		;;
	udi29k)
		basic_machine=a29k-amd
		os=-udi
		;;
	ultra3)
		basic_machine=a29k-nyu
		os=-sym1
		;;
	v810 | necv810)
		basic_machine=v810-nec
		os=-none
		;;
	vaxv)
		basic_machine=vax-dec
		os=-sysv
		;;
	vms)
		basic_machine=vax-dec
		os=-vms
		;;
	vpp*|vx|vx-*)
		basic_machine=f301-fujitsu
		;;
	vxworks960)
		basic_machine=i960-wrs
		os=-vxworks
		;;
	vxworks68)
		basic_machine=m68k-wrs
		os=-vxworks
		;;
	vxworks29k)
		basic_machine=a29k-wrs
		os=-vxworks
		;;
	wasm32)
		basic_machine=wasm32-unknown
		;;
	w65*)
		basic_machine=w65-wdc
		os=-none
		;;
	w89k-*)
		basic_machine=hppa1.1-winbond
		os=-proelf
		;;
	xbox)
		basic_machine=i686-pc
		os=-mingw32
		;;
	xps | xps100)
		basic_machine=xps100-honeywell
		;;
	xscale-* | xscalee[bl]-*)
		basic_machine=`echo $basic_machine | sed 's/^xscale/arm/'`
		;;
	ymp)
		basic_machine=ymp-cray
		os=-unicos
		;;
	z8k-*-coff)
		basic_machine=z8k-unknown
		os=-sim
		;;
	z80-*-coff)
		basic_machine=z80-unknown
		os=-sim
		;;
	none)
		basic_machine=none-none
		os=-none
		;;

# Here we handle the default manufacturer of certain CPU types.  It is in
# some cases the only manufacturer, in others, it is the most popular.
	w89k)
		basic_machine=hppa1.1-winbond
		;;
	op50n)
		basic_machine=hppa1.1-oki
		;;
	op60c)
		basic_machine=hppa1.1-oki
		;;
	romp)
		basic_machine=romp-ibm
		;;
	mmix)
		basic_machine=mmix-knuth
		;;
	rs6000)
		basic_machine=rs6000-ibm
		;;
	vax)
		basic_machine=vax-dec
		;;
	pdp10)
		# there are many clones, so DEC is not a safe bet
		basic_machine=pdp10-unknown
		;;
	pdp11)
		basic_machine=pdp11-dec
		;;
	we32k)
		basic_machine=we32k-att
		;;
	sh[1234] | sh[24]a | sh[24]aeb | sh[34]eb | sh[1234]le | sh[23]ele)
		basic_machine=sh-unknown
		;;
	sparc | sparcv8 | sparcv9 | sparcv9b | sparcv9v)
		basic_machine=sparc-sun
		;;
	cydra)
		basic_machine=cydra-cydrome
		;;
	orion)
		basic_machine=orion-highlevel
		;;
	orion105)
		basic_machine=clipper-highlevel
		;;
	mac | mpw | mac-mpw)
		basic_machine=m68k-apple
		;;
	pmac | pmac-mpw)
		basic_machine=powerpc-apple
		;;
	*-unknown)
		# Make sure to match an already-canonicalized machine name.
		;;
	*)
		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1>&2
		exit 1
		;;
esac

# Here we canonicalize certain aliases for manufacturers.
case $basic_machine in
	*-digital*)
		basic_machine=`echo $basic_machine | sed 's/digital.*/dec/'`
		;;
	*-commodore*)
		basic_machine=`echo $basic_machine | sed 's/commodore.*/cbm/'`
		;;
	*)
		;;
esac

# Decode manufacturer-specific aliases for certain operating systems.

if [ x"$os" != x"" ]
then
case $os in
	# First match some system type aliases
	# that might get confused with valid system types.
	# -solaris* is a basic system type, with this one exception.
	-auroraux)
		os=-auroraux
		;;
	-solaris1 | -solaris1.*)
		os=`echo $os | sed -e 's|solaris1|sunos4|'`
		;;
	-solaris)
		os=-solaris2
		;;
	-svr4*)
		os=-sysv4
		;;
	-unixware*)
		os=-sysv4.2uw
		;;
	-gnu/linux*)
		os=`echo $os | sed -e 's|gnu/linux|linux-gnu|'`
		;;
	# First accept the basic system types.
	# The portable systems comes first.
	# Each alternative MUST END IN A *, to match a version number.
	# -sysv* is not here because it comes later, after sysvr4.
	-gnu* | -bsd* | -mach* | -minix* | -genix* | -ultrix* | -irix* \
	      | -*vms* | -sco* | -esix* | -isc* | -aix* | -cnk* | -sunos | -sunos[34]*\
	      | -hpux* | -unos* | -osf* | -luna* | -dgux* | -auroraux* | -solaris* \
	      | -sym* | -kopensolaris* | -plan9* \
	      | -amigaos* | -amigados* | -msdos* | -newsos* | -unicos* | -aof* \
	      | -aos* | -aros* | -cloudabi* | -sortix* \
	      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \
	      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \
	      | -hiux* | -386bsd* | -knetbsd* | -mirbsd* | -netbsd* \
	      | -bitrig* | -openbsd* | -solidbsd* | -libertybsd* \
	      | -ekkobsd* | -kfreebsd* | -freebsd* | -riscix* | -lynxos* \
	      | -bosx* | -nextstep* | -cxux* | -aout* | -elf* | -oabi* \
	      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \
	      | -udi* | -eabi* | -lites* | -ieee* | -go32* | -aux* \
	      | -chorusos* | -chorusrdb* | -cegcc* | -glidix* \
	      | -cygwin* | -msys* | -pe* | -psos* | -moss* | -proelf* | -rtems* \
	      | -midipix* | -mingw32* | -mingw64* | -linux-gnu* | -linux-android* \
	      | -linux-newlib* | -linux-musl* | -linux-uclibc* \
	      | -uxpv* | -beos* | -mpeix* | -udk* | -moxiebox* \
	      | -interix* | -uwin* | -mks* | -rhapsody* | -darwin* | -opened* \
	      | -openstep* | -oskit* | -conix* | -pw32* | -nonstopux* \
	      | -storm-chaos* | -tops10* | -tenex* | -tops20* | -its* \
	      | -os2* | -vos* | -palmos* | -uclinux* | -nucleus* \
	      | -morphos* | -superux* | -rtmk* | -rtmk-nova* | -windiss* \
	      | -powermax* | -dnix* | -nx6 | -nx7 | -sei* | -dragonfly* \
	      | -skyos* | -haiku* | -rdos* | -toppers* | -drops* | -es* \
	      | -onefs* | -tirtos* | -phoenix* | -fuchsia* | -redox*)
	# Remember, each alternative MUST END IN *, to match a version number.
		;;
	-qnx*)
		case $basic_machine in
		    x86-* | i*86-*)
			;;
		    *)
			os=-nto$os
			;;
		esac
		;;
	-nto-qnx*)
		;;
	-nto*)
		os=`echo $os | sed -e 's|nto|nto-qnx|'`
		;;
	-sim | -es1800* | -hms* | -xray | -os68k* | -none* | -v88r* \
	      | -windows* | -osx | -abug | -netware* | -os9* | -beos* | -haiku* \
	      | -macos* | -mpw* | -magic* | -mmixware* | -mon960* | -lnews*)
		;;
	-mac*)
		os=`echo $os | sed -e 's|mac|macos|'`
		;;
	-linux-dietlibc)
		os=-linux-dietlibc
		;;
	-linux*)
		os=`echo $os | sed -e 's|linux|linux-gnu|'`
		;;
	-sunos5*)
		os=`echo $os | sed -e 's|sunos5|solaris2|'`
		;;
	-sunos6*)
		os=`echo $os | sed -e 's|sunos6|solaris3|'`
		;;
	-opened*)
		os=-openedition
		;;
	-os400*)
		os=-os400
		;;
	-wince*)
		os=-wince
		;;
	-osfrose*)
		os=-osfrose
		;;
	-osf*)
		os=-osf
		;;
	-utek*)
		os=-bsd
		;;
	-dynix*)
		os=-bsd
		;;
	-acis*)
		os=-aos
		;;
	-atheos*)
		os=-atheos
		;;
	-syllable*)
		os=-syllable
		;;
	-386bsd)
		os=-bsd
		;;
	-ctix* | -uts*)
		os=-sysv
		;;
	-nova*)
		os=-rtmk-nova
		;;
	-ns2 )
		os=-nextstep2
		;;
	-nsk*)
		os=-nsk
		;;
	# Preserve the version number of sinix5.
	-sinix5.*)
		os=`echo $os | sed -e 's|sinix|sysv|'`
		;;
	-sinix*)
		os=-sysv4
		;;
	-tpf*)
		os=-tpf
		;;
	-triton*)
		os=-sysv3
		;;
	-oss*)
		os=-sysv3
		;;
	-svr4)
		os=-sysv4
		;;
	-svr3)
		os=-sysv3
		;;
	-sysvr4)
		os=-sysv4
		;;
	# This must come after -sysvr4.
	-sysv*)
		;;
	-ose*)
		os=-ose
		;;
	-es1800*)
		os=-ose
		;;
	-xenix)
		os=-xenix
		;;
	-*mintelf | -mintelf[0-9]*)
		os=-mintelf
		;;
	-*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)
		os=-mint
		;;
	-aros*)
		os=-aros
		;;
	-zvmoe)
		os=-zvmoe
		;;
	-dicos*)
		os=-dicos
		;;
	-nacl*)
		;;
	-ios)
		;;
	-none)
		;;
	*)
		# Get rid of the `-' at the beginning of $os.
		os=`echo $os | sed 's/[^-]*-//'`
		echo Invalid configuration \`$1\': system \`$os\' not recognized 1>&2
		exit 1
		;;
esac
else

# Here we handle the default operating systems that come with various machines.
# The value should be what the vendor currently ships out the door with their
# machine or put another way, the most popular os provided with the machine.

# Note that if you're going to try to match "-MANUFACTURER" here (say,
# "-sun"), then you have to tell the case statement up towards the top
# that MANUFACTURER isn't an operating system.  Otherwise, code above
# will signal an error saying that MANUFACTURER isn't an operating
# system, and we'll never get to this point.

case $basic_machine in
	score-*)
		os=-elf
		;;
	spu-*)
		os=-elf
		;;
	*-acorn)
		os=-riscix1.2
		;;
	arm*-rebel)
		os=-linux
		;;
	arm*-semi)
		os=-aout
		;;
	c4x-* | tic4x-*)
		os=-coff
		;;
	c8051-*)
		os=-elf
		;;
	hexagon-*)
		os=-elf
		;;
	tic54x-*)
		os=-coff
		;;
	tic55x-*)
		os=-coff
		;;
	tic6x-*)
		os=-coff
		;;
	# This must come before the *-dec entry.
	pdp10-*)
		os=-tops20
		;;
	pdp11-*)
		os=-none
		;;
	*-dec | vax-*)
		os=-ultrix4.2
		;;
	m68*-apollo)
		os=-domain
		;;
	i386-sun)
		os=-sunos4.0.2
		;;
	m68000-sun)
		os=-sunos3
		;;
	m68*-cisco)
		os=-aout
		;;
	mep-*)
		os=-elf
		;;
	mips*-cisco)
		os=-elf
		;;
	mips*-*)
		os=-elf
		;;
	or32-*)
		os=-coff
		;;
	*-tti)	# must be before sparc entry or we get the wrong os.
		os=-sysv3
		;;
	sparc-* | *-sun)
		os=-sunos4.1.1
		;;
	pru-*)
		os=-elf
		;;
	*-be)
		os=-beos
		;;
	*-haiku)
		os=-haiku
		;;
	*-ibm)
		os=-aix
		;;
	*-knuth)
		os=-mmixware
		;;
	*-wec)
		os=-proelf
		;;
	*-winbond)
		os=-proelf
		;;
	*-oki)
		os=-proelf
		;;
	*-hp)
		os=-hpux
		;;
	*-hitachi)
		os=-hiux
		;;
	i860-* | *-att | *-ncr | *-altos | *-motorola | *-convergent)
		os=-sysv
		;;
	*-cbm)
		os=-amigaos
		;;
	*-dg)
		os=-dgux
		;;
	*-dolphin)
		os=-sysv3
		;;
	m68k-ccur)
		os=-rtu
		;;
	m88k-omron*)
		os=-luna
		;;
	*-next )
		os=-nextstep
		;;
	*-sequent)
		os=-ptx
		;;
	*-crds)
		os=-unos
		;;
	*-ns)
		os=-genix
		;;
	i370-*)
		os=-mvs
		;;
	*-next)
		os=-nextstep3
		;;
	*-gould)
		os=-sysv
		;;
	*-highlevel)
		os=-bsd
		;;
	*-encore)
		os=-bsd
		;;
	*-sgi)
		os=-irix
		;;
	*-siemens)
		os=-sysv4
		;;
	*-masscomp)
		os=-rtu
		;;
	f30[01]-fujitsu | f700-fujitsu)
		os=-uxpv
		;;
	*-rom68k)
		os=-coff
		;;
	*-*bug)
		os=-coff
		;;
	*-apple)
		os=-macos
		;;
	*-atari*)
		os=-mint
		;;
	*)
		os=-none
		;;
esac
fi

# Here we handle the case where we know the os, and the CPU type, but not the
# manufacturer.  We pick the logical manufacturer.
vendor=unknown
case $basic_machine in
	*-unknown)
		case $os in
			-riscix*)
				vendor=acorn
				;;
			-sunos*)
				vendor=sun
				;;
			-cnk*|-aix*)
				vendor=ibm
				;;
			-beos*)
				vendor=be
				;;
			-hpux*)
				vendor=hp
				;;
			-mpeix*)
				vendor=hp
				;;
			-hiux*)
				vendor=hitachi
				;;
			-unos*)
				vendor=crds
				;;
			-dgux*)
				vendor=dg
				;;
			-luna*)
				vendor=omron
				;;
			-genix*)
				vendor=ns
				;;
			-mvs* | -opened*)
				vendor=ibm
				;;
			-os400*)
				vendor=ibm
				;;
			-ptx*)
				vendor=sequent
				;;
			-tpf*)
				vendor=ibm
				;;
			-vxsim* | -vxworks* | -windiss*)
				vendor=wrs
				;;
			-aux*)
				vendor=apple
				;;
			-hms*)
				vendor=hitachi
				;;
			-mpw* | -macos*)
				vendor=apple
				;;
			-*mintelf | -mintelf[0-9]*)
				vendor=atari
				;;
			-*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)
				vendor=atari
				;;
			-vos*)
				vendor=stratus
				;;
		esac
		basic_machine=`echo $basic_machine | sed "s/unknown/$vendor/"`
		;;
esac

echo $basic_machine$os
exit

# Local variables:
# eval: (add-hook 'write-file-hooks 'time-stamp)
# time-stamp-start: "timestamp='"
# time-stamp-format: "%:y-%02m-%02d"
# time-stamp-end: "'"
# End:

```

`config-aux/install-sh`:

```
#!/bin/sh
# install - install a program, script, or datafile

scriptversion=2016-01-11.22; # UTC

# This originates from X11R5 (mit/util/scripts/install.sh), which was
# later released in X11R6 (xc/config/util/install.sh) with the
# following copyright and license.
#
# Copyright (C) 1994 X Consortium
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
# X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
# AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNEC-
# TION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
# Except as contained in this notice, the name of the X Consortium shall not
# be used in advertising or otherwise to promote the sale, use or other deal-
# ings in this Software without prior written authorization from the X Consor-
# tium.
#
#
# FSF changes to this file are in the public domain.
#
# Calling this script install-sh is preferred over install.sh, to prevent
# 'make' implicit rules from creating a file called install from it
# when there is no Makefile.
#
# This script is compatible with the BSD install script, but was written
# from scratch.

tab='	'
nl='
'
IFS=" $tab$nl"

# Set DOITPROG to "echo" to test this script.

doit=${DOITPROG-}
doit_exec=${doit:-exec}

# Put in absolute file names if you don't have them in your path;
# or use environment vars.

chgrpprog=${CHGRPPROG-chgrp}
chmodprog=${CHMODPROG-chmod}
chownprog=${CHOWNPROG-chown}
cmpprog=${CMPPROG-cmp}
cpprog=${CPPROG-cp}
mkdirprog=${MKDIRPROG-mkdir}
mvprog=${MVPROG-mv}
rmprog=${RMPROG-rm}
stripprog=${STRIPPROG-strip}

posix_mkdir=

# Desired mode of installed file.
mode=0755

chgrpcmd=
chmodcmd=$chmodprog
chowncmd=
mvcmd=$mvprog
rmcmd="$rmprog -f"
stripcmd=

src=
dst=
dir_arg=
dst_arg=

copy_on_change=false
is_target_a_directory=possibly

usage="\
Usage: $0 [OPTION]... [-T] SRCFILE DSTFILE
   or: $0 [OPTION]... SRCFILES... DIRECTORY
   or: $0 [OPTION]... -t DIRECTORY SRCFILES...
   or: $0 [OPTION]... -d DIRECTORIES...

In the 1st form, copy SRCFILE to DSTFILE.
In the 2nd and 3rd, copy all SRCFILES to DIRECTORY.
In the 4th, create DIRECTORIES.

Options:
     --help     display this help and exit.
     --version  display version info and exit.

  -c            (ignored)
  -C            install only if different (preserve the last data modification time)
  -d            create directories instead of installing files.
  -g GROUP      $chgrpprog installed files to GROUP.
  -m MODE       $chmodprog installed files to MODE.
  -o USER       $chownprog installed files to USER.
  -s            $stripprog installed files.
  -t DIRECTORY  install into DIRECTORY.
  -T            report an error if DSTFILE is a directory.

Environment variables override the default commands:
  CHGRPPROG CHMODPROG CHOWNPROG CMPPROG CPPROG MKDIRPROG MVPROG
  RMPROG STRIPPROG
"

while test $# -ne 0; do
  case $1 in
    -c) ;;

    -C) copy_on_change=true;;

    -d) dir_arg=true;;

    -g) chgrpcmd="$chgrpprog $2"
        shift;;

    --help) echo "$usage"; exit $?;;

    -m) mode=$2
        case $mode in
          *' '* | *"$tab"* | *"$nl"* | *'*'* | *'?'* | *'['*)
            echo "$0: invalid mode: $mode" >&2
            exit 1;;
        esac
        shift;;

    -o) chowncmd="$chownprog $2"
        shift;;

    -s) stripcmd=$stripprog;;

    -t)
        is_target_a_directory=always
        dst_arg=$2
        # Protect names problematic for 'test' and other utilities.
        case $dst_arg in
          -* | [=\(\)!]) dst_arg=./$dst_arg;;
        esac
        shift;;

    -T) is_target_a_directory=never;;

    --version) echo "$0 $scriptversion"; exit $?;;

    --) shift
        break;;

    -*) echo "$0: invalid option: $1" >&2
        exit 1;;

    *)  break;;
  esac
  shift
done

# We allow the use of options -d and -T together, by making -d
# take the precedence; this is for compatibility with GNU install.

if test -n "$dir_arg"; then
  if test -n "$dst_arg"; then
    echo "$0: target directory not allowed when installing a directory." >&2
    exit 1
  fi
fi

if test $# -ne 0 && test -z "$dir_arg$dst_arg"; then
  # When -d is used, all remaining arguments are directories to create.
  # When -t is used, the destination is already specified.
  # Otherwise, the last argument is the destination.  Remove it from $@.
  for arg
  do
    if test -n "$dst_arg"; then
      # $@ is not empty: it contains at least $arg.
      set fnord "$@" "$dst_arg"
      shift # fnord
    fi
    shift # arg
    dst_arg=$arg
    # Protect names problematic for 'test' and other utilities.
    case $dst_arg in
      -* | [=\(\)!]) dst_arg=./$dst_arg;;
    esac
  done
fi

if test $# -eq 0; then
  if test -z "$dir_arg"; then
    echo "$0: no input file specified." >&2
    exit 1
  fi
  # It's OK to call 'install-sh -d' without argument.
  # This can happen when creating conditional directories.
  exit 0
fi

if test -z "$dir_arg"; then
  if test $# -gt 1 || test "$is_target_a_directory" = always; then
    if test ! -d "$dst_arg"; then
      echo "$0: $dst_arg: Is not a directory." >&2
      exit 1
    fi
  fi
fi

if test -z "$dir_arg"; then
  do_exit='(exit $ret); exit $ret'
  trap "ret=129; $do_exit" 1
  trap "ret=130; $do_exit" 2
  trap "ret=141; $do_exit" 13
  trap "ret=143; $do_exit" 15

  # Set umask so as not to create temps with too-generous modes.
  # However, 'strip' requires both read and write access to temps.
  case $mode in
    # Optimize common cases.
    *644) cp_umask=133;;
    *755) cp_umask=22;;

    *[0-7])
      if test -z "$stripcmd"; then
        u_plus_rw=
      else
        u_plus_rw='% 200'
      fi
      cp_umask=`expr '(' 777 - $mode % 1000 ')' $u_plus_rw`;;
    *)
      if test -z "$stripcmd"; then
        u_plus_rw=
      else
        u_plus_rw=,u+rw
      fi
      cp_umask=$mode$u_plus_rw;;
  esac
fi

for src
do
  # Protect names problematic for 'test' and other utilities.
  case $src in
    -* | [=\(\)!]) src=./$src;;
  esac

  if test -n "$dir_arg"; then
    dst=$src
    dstdir=$dst
    test -d "$dstdir"
    dstdir_status=$?
  else

    # Waiting for this to be detected by the "$cpprog $src $dsttmp" command
    # might cause directories to be created, which would be especially bad
    # if $src (and thus $dsttmp) contains '*'.
    if test ! -f "$src" && test ! -d "$src"; then
      echo "$0: $src does not exist." >&2
      exit 1
    fi

    if test -z "$dst_arg"; then
      echo "$0: no destination specified." >&2
      exit 1
    fi
    dst=$dst_arg

    # If destination is a directory, append the input filename; won't work
    # if double slashes aren't ignored.
    if test -d "$dst"; then
      if test "$is_target_a_directory" = never; then
        echo "$0: $dst_arg: Is a directory" >&2
        exit 1
      fi
      dstdir=$dst
      dst=$dstdir/`basename "$src"`
      dstdir_status=0
    else
      dstdir=`dirname "$dst"`
      test -d "$dstdir"
      dstdir_status=$?
    fi
  fi

  obsolete_mkdir_used=false

  if test $dstdir_status != 0; then
    case $posix_mkdir in
      '')
        # Create intermediate dirs using mode 755 as modified by the umask.
        # This is like FreeBSD 'install' as of 1997-10-28.
        umask=`umask`
        case $stripcmd.$umask in
          # Optimize common cases.
          *[2367][2367]) mkdir_umask=$umask;;
          .*0[02][02] | .[02][02] | .[02]) mkdir_umask=22;;

          *[0-7])
            mkdir_umask=`expr $umask + 22 \
              - $umask % 100 % 40 + $umask % 20 \
              - $umask % 10 % 4 + $umask % 2
            `;;
          *) mkdir_umask=$umask,go-w;;
        esac

        # With -d, create the new directory with the user-specified mode.
        # Otherwise, rely on $mkdir_umask.
        if test -n "$dir_arg"; then
          mkdir_mode=-m$mode
        else
          mkdir_mode=
        fi

        posix_mkdir=false
        case $umask in
          *[123567][0-7][0-7])
            # POSIX mkdir -p sets u+wx bits regardless of umask, which
            # is incompatible with FreeBSD 'install' when (umask & 300) != 0.
            ;;
          *)
            tmpdir=${TMPDIR-/tmp}/ins$RANDOM-$$
            trap 'ret=$?; rmdir "$tmpdir/d" "$tmpdir" 2>/dev/null; exit $ret' 0

            if (umask $mkdir_umask &&
                exec $mkdirprog $mkdir_mode -p -- "$tmpdir/d") >/dev/null 2>&1
            then
              if test -z "$dir_arg" || {
                   # Check for POSIX incompatibilities with -m.
                   # HP-UX 11.23 and IRIX 6.5 mkdir -m -p sets group- or
                   # other-writable bit of parent directory when it shouldn't.
                   # FreeBSD 6.1 mkdir -m -p sets mode of existing directory.
                   ls_ld_tmpdir=`ls -ld "$tmpdir"`
                   case $ls_ld_tmpdir in
                     d????-?r-*) different_mode=700;;
                     d????-?--*) different_mode=755;;
                     *) false;;
                   esac &&
                   $mkdirprog -m$different_mode -p -- "$tmpdir" && {
                     ls_ld_tmpdir_1=`ls -ld "$tmpdir"`
                     test "$ls_ld_tmpdir" = "$ls_ld_tmpdir_1"
                   }
                 }
              then posix_mkdir=:
              fi
              rmdir "$tmpdir/d" "$tmpdir"
            else
              # Remove any dirs left behind by ancient mkdir implementations.
              rmdir ./$mkdir_mode ./-p ./-- 2>/dev/null
            fi
            trap '' 0;;
        esac;;
    esac

    if
      $posix_mkdir && (
        umask $mkdir_umask &&
        $doit_exec $mkdirprog $mkdir_mode -p -- "$dstdir"
      )
    then :
    else

      # The umask is ridiculous, or mkdir does not conform to POSIX,
      # or it failed possibly due to a race condition.  Create the
      # directory the slow way, step by step, checking for races as we go.

      case $dstdir in
        /*) prefix='/';;
        [-=\(\)!]*) prefix='./';;
        *)  prefix='';;
      esac

      oIFS=$IFS
      IFS=/
      set -f
      set fnord $dstdir
      shift
      set +f
      IFS=$oIFS

      prefixes=

      for d
      do
        test X"$d" = X && continue

        prefix=$prefix$d
        if test -d "$prefix"; then
          prefixes=
        else
          if $posix_mkdir; then
            (umask=$mkdir_umask &&
             $doit_exec $mkdirprog $mkdir_mode -p -- "$dstdir") && break
            # Don't fail if two instances are running concurrently.
            test -d "$prefix" || exit 1
          else
            case $prefix in
              *\'*) qprefix=`echo "$prefix" | sed "s/'/'\\\\\\\\''/g"`;;
              *) qprefix=$prefix;;
            esac
            prefixes="$prefixes '$qprefix'"
          fi
        fi
        prefix=$prefix/
      done

      if test -n "$prefixes"; then
        # Don't fail if two instances are running concurrently.
        (umask $mkdir_umask &&
         eval "\$doit_exec \$mkdirprog $prefixes") ||
          test -d "$dstdir" || exit 1
        obsolete_mkdir_used=true
      fi
    fi
  fi

  if test -n "$dir_arg"; then
    { test -z "$chowncmd" || $doit $chowncmd "$dst"; } &&
    { test -z "$chgrpcmd" || $doit $chgrpcmd "$dst"; } &&
    { test "$obsolete_mkdir_used$chowncmd$chgrpcmd" = false ||
      test -z "$chmodcmd" || $doit $chmodcmd $mode "$dst"; } || exit 1
  else

    # Make a couple of temp file names in the proper directory.
    dsttmp=$dstdir/_inst.$$_
    rmtmp=$dstdir/_rm.$$_

    # Trap to clean up those temp files at exit.
    trap 'ret=$?; rm -f "$dsttmp" "$rmtmp" && exit $ret' 0

    # Copy the file name to the temp name.
    (umask $cp_umask && $doit_exec $cpprog "$src" "$dsttmp") &&

    # and set any options; do chmod last to preserve setuid bits.
    #
    # If any of these fail, we abort the whole thing.  If we want to
    # ignore errors from any of these, just make sure not to ignore
    # errors from the above "$doit $cpprog $src $dsttmp" command.
    #
    { test -z "$chowncmd" || $doit $chowncmd "$dsttmp"; } &&
    { test -z "$chgrpcmd" || $doit $chgrpcmd "$dsttmp"; } &&
    { test -z "$stripcmd" || $doit $stripcmd "$dsttmp"; } &&
    { test -z "$chmodcmd" || $doit $chmodcmd $mode "$dsttmp"; } &&

    # If -C, don't bother to copy if it wouldn't change the file.
    if $copy_on_change &&
       old=`LC_ALL=C ls -dlL "$dst"     2>/dev/null` &&
       new=`LC_ALL=C ls -dlL "$dsttmp"  2>/dev/null` &&
       set -f &&
       set X $old && old=:$2:$4:$5:$6 &&
       set X $new && new=:$2:$4:$5:$6 &&
       set +f &&
       test "$old" = "$new" &&
       $cmpprog "$dst" "$dsttmp" >/dev/null 2>&1
    then
      rm -f "$dsttmp"
    else
      # Rename the file to the real destination.
      $doit $mvcmd -f "$dsttmp" "$dst" 2>/dev/null ||

      # The rename failed, perhaps because mv can't rename something else
      # to itself, or perhaps because mv is so ancient that it does not
      # support -f.
      {
        # Now remove or move aside any old file at destination location.
        # We try this two ways since rm can't unlink itself on some
        # systems and the destination file might be busy for other
        # reasons.  In this case, the final cleanup might fail but the new
        # file should still install successfully.
        {
          test ! -f "$dst" ||
          $doit $rmcmd -f "$dst" 2>/dev/null ||
          { $doit $mvcmd -f "$dst" "$rmtmp" 2>/dev/null &&
            { $doit $rmcmd -f "$rmtmp" 2>/dev/null; :; }
          } ||
          { echo "$0: cannot unlink or rename $dst" >&2
            (exit 1); exit 1
          }
        } &&

        # Now rename the file to the real destination.
        $doit $mvcmd "$dsttmp" "$dst"
      }
    fi || exit 1

    trap '' 0
  fi
done

# Local variables:
# eval: (add-hook 'write-file-hooks 'time-stamp)
# time-stamp-start: "scriptversion="
# time-stamp-format: "%:y-%02m-%02d.%02H"
# time-stamp-time-zone: "UTC0"
# time-stamp-end: "; # UTC"
# End:

```

`config-aux/mkinstalldirs`:

```
#! /bin/sh
# mkinstalldirs --- make directory hierarchy

scriptversion=2016-01-11.22; # UTC

# Original author: Noah Friedman <friedman@prep.ai.mit.edu>
# Created: 1993-05-16
# Public domain.
#
# This file is maintained in Automake, please report
# bugs to <bug-automake@gnu.org> or send patches to
# <automake-patches@gnu.org>.

nl='
'
IFS=" ""	$nl"
errstatus=0
dirmode=

usage="\
Usage: mkinstalldirs [-h] [--help] [--version] [-m MODE] DIR ...

Create each directory DIR (with mode MODE, if specified), including all
leading file name components.

Report bugs to <bug-automake@gnu.org>."

# process command line arguments
while test $# -gt 0 ; do
  case $1 in
    -h | --help | --h*)         # -h for help
      echo "$usage"
      exit $?
      ;;
    -m)                         # -m PERM arg
      shift
      test $# -eq 0 && { echo "$usage" 1>&2; exit 1; }
      dirmode=$1
      shift
      ;;
    --version)
      echo "$0 $scriptversion"
      exit $?
      ;;
    --)                         # stop option processing
      shift
      break
      ;;
    -*)                         # unknown option
      echo "$usage" 1>&2
      exit 1
      ;;
    *)                          # first non-opt arg
      break
      ;;
  esac
done

for file
do
  if test -d "$file"; then
    shift
  else
    break
  fi
done

case $# in
  0) exit 0 ;;
esac

# Solaris 8's mkdir -p isn't thread-safe.  If you mkdir -p a/b and
# mkdir -p a/c at the same time, both will detect that a is missing,
# one will create a, then the other will try to create a and die with
# a "File exists" error.  This is a problem when calling mkinstalldirs
# from a parallel make.  We use --version in the probe to restrict
# ourselves to GNU mkdir, which is thread-safe.
case $dirmode in
  '')
    if mkdir -p --version . >/dev/null 2>&1 && test ! -d ./--version; then
      echo "mkdir -p -- $*"
      exec mkdir -p -- "$@"
    else
      # On NextStep and OpenStep, the 'mkdir' command does not
      # recognize any option.  It will interpret all options as
      # directories to create, and then abort because '.' already
      # exists.
      test -d ./-p && rmdir ./-p
      test -d ./--version && rmdir ./--version
    fi
    ;;
  *)
    if mkdir -m "$dirmode" -p --version . >/dev/null 2>&1 &&
       test ! -d ./--version; then
      echo "mkdir -m $dirmode -p -- $*"
      exec mkdir -m "$dirmode" -p -- "$@"
    else
      # Clean up after NextStep and OpenStep mkdir.
      for d in ./-m ./-p ./--version "./$dirmode";
      do
        test -d $d && rmdir $d
      done
    fi
    ;;
esac

for file
do
  case $file in
    /*) pathcomp=/ ;;
    *)  pathcomp= ;;
  esac
  oIFS=$IFS
  IFS=/
  set fnord $file
  shift
  IFS=$oIFS

  for d
  do
    test "x$d" = x && continue

    pathcomp=$pathcomp$d
    case $pathcomp in
      -*) pathcomp=./$pathcomp ;;
    esac

    if test ! -d "$pathcomp"; then
      echo "mkdir $pathcomp"

      mkdir "$pathcomp" || lasterr=$?

      if test ! -d "$pathcomp"; then
	errstatus=$lasterr
      else
	if test ! -z "$dirmode"; then
	  echo "chmod $dirmode $pathcomp"
	  lasterr=
	  chmod "$dirmode" "$pathcomp" || lasterr=$?

	  if test ! -z "$lasterr"; then
	    errstatus=$lasterr
	  fi
	fi
      fi
    fi

    pathcomp=$pathcomp/
  done
done

exit $errstatus

# Local Variables:
# mode: shell-script
# sh-indentation: 2
# eval: (add-hook 'write-file-hooks 'time-stamp)
# time-stamp-start: "scriptversion="
# time-stamp-format: "%:y-%02m-%02d.%02H"
# time-stamp-time-zone: "UTC0"
# time-stamp-end: "; # UTC"
# End:

```

`configure`:

```
#! /bin/sh
# Guess values for system-dependent variables and create Makefiles.
# Generated by GNU Autoconf 2.69.
#
#
# Copyright (C) 1992-1996, 1998-2012 Free Software Foundation, Inc.
#
#
# This configure script is free software; the Free Software Foundation
# gives unlimited permission to copy, distribute and modify it.
## -------------------- ##
## M4sh Initialization. ##
## -------------------- ##

# Be more Bourne compatible
DUALCASE=1; export DUALCASE # for MKS sh
if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then :
  emulate sh
  NULLCMD=:
  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
  # is contrary to our usage.  Disable this feature.
  alias -g '${1+"$@"}'='"$@"'
  setopt NO_GLOB_SUBST
else
  case `(set -o) 2>/dev/null` in #(
  *posix*) :
    set -o posix ;; #(
  *) :
     ;;
esac
fi


as_nl='
'
export as_nl
# Printing a long string crashes Solaris 7 /usr/bin/printf.
as_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo
as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo
# Prefer a ksh shell builtin over an external printf program on Solaris,
# but without wasting forks for bash or zsh.
if test -z "$BASH_VERSION$ZSH_VERSION" \
    && (test "X`print -r -- $as_echo`" = "X$as_echo") 2>/dev/null; then
  as_echo='print -r --'
  as_echo_n='print -rn --'
elif (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
  as_echo='printf %s\n'
  as_echo_n='printf %s'
else
  if test "X`(/usr/ucb/echo -n -n $as_echo) 2>/dev/null`" = "X-n $as_echo"; then
    as_echo_body='eval /usr/ucb/echo -n "$1$as_nl"'
    as_echo_n='/usr/ucb/echo -n'
  else
    as_echo_body='eval expr "X$1" : "X\\(.*\\)"'
    as_echo_n_body='eval
      arg=$1;
      case $arg in #(
      *"$as_nl"*)
	expr "X$arg" : "X\\(.*\\)$as_nl";
	arg=`expr "X$arg" : ".*$as_nl\\(.*\\)"`;;
      esac;
      expr "X$arg" : "X\\(.*\\)" | tr -d "$as_nl"
    '
    export as_echo_n_body
    as_echo_n='sh -c $as_echo_n_body as_echo'
  fi
  export as_echo_body
  as_echo='sh -c $as_echo_body as_echo'
fi

# The user is always right.
if test "${PATH_SEPARATOR+set}" != set; then
  PATH_SEPARATOR=:
  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {
    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||
      PATH_SEPARATOR=';'
  }
fi


# IFS
# We need space, tab and new line, in precisely that order.  Quoting is
# there to prevent editors from complaining about space-tab.
# (If _AS_PATH_WALK were called with IFS unset, it would disable word
# splitting by setting IFS to empty value.)
IFS=" ""	$as_nl"

# Find who we are.  Look in the path if we contain no directory separator.
as_myself=
case $0 in #((
  *[\\/]* ) as_myself=$0 ;;
  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
    test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
  done
IFS=$as_save_IFS

     ;;
esac
# We did not find ourselves, most probably we were run as `sh COMMAND'
# in which case we are not to be found in the path.
if test "x$as_myself" = x; then
  as_myself=$0
fi
if test ! -f "$as_myself"; then
  $as_echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
  exit 1
fi

# Unset variables that we do not need and which cause bugs (e.g. in
# pre-3.0 UWIN ksh).  But do not cause bugs in bash 2.01; the "|| exit 1"
# suppresses any "Segmentation fault" message there.  '((' could
# trigger a bug in pdksh 5.2.14.
for as_var in BASH_ENV ENV MAIL MAILPATH
do eval test x\${$as_var+set} = xset \
  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :
done
PS1='$ '
PS2='> '
PS4='+ '

# NLS nuisances.
LC_ALL=C
export LC_ALL
LANGUAGE=C
export LANGUAGE

# CDPATH.
(unset CDPATH) >/dev/null 2>&1 && unset CDPATH

# Use a proper internal environment variable to ensure we don't fall
  # into an infinite loop, continuously re-executing ourselves.
  if test x"${_as_can_reexec}" != xno && test "x$CONFIG_SHELL" != x; then
    _as_can_reexec=no; export _as_can_reexec;
    # We cannot yet assume a decent shell, so we have to provide a
# neutralization value for shells without unset; and this also
# works around shells that cannot unset nonexistent variables.
# Preserve -v and -x to the replacement shell.
BASH_ENV=/dev/null
ENV=/dev/null
(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV
case $- in # ((((
  *v*x* | *x*v* ) as_opts=-vx ;;
  *v* ) as_opts=-v ;;
  *x* ) as_opts=-x ;;
  * ) as_opts= ;;
esac
exec $CONFIG_SHELL $as_opts "$as_myself" ${1+"$@"}
# Admittedly, this is quite paranoid, since all the known shells bail
# out after a failed `exec'.
$as_echo "$0: could not re-execute with $CONFIG_SHELL" >&2
as_fn_exit 255
  fi
  # We don't want this to propagate to other subprocesses.
          { _as_can_reexec=; unset _as_can_reexec;}
if test "x$CONFIG_SHELL" = x; then
  as_bourne_compatible="if test -n \"\${ZSH_VERSION+set}\" && (emulate sh) >/dev/null 2>&1; then :
  emulate sh
  NULLCMD=:
  # Pre-4.2 versions of Zsh do word splitting on \${1+\"\$@\"}, which
  # is contrary to our usage.  Disable this feature.
  alias -g '\${1+\"\$@\"}'='\"\$@\"'
  setopt NO_GLOB_SUBST
else
  case \`(set -o) 2>/dev/null\` in #(
  *posix*) :
    set -o posix ;; #(
  *) :
     ;;
esac
fi
"
  as_required="as_fn_return () { (exit \$1); }
as_fn_success () { as_fn_return 0; }
as_fn_failure () { as_fn_return 1; }
as_fn_ret_success () { return 0; }
as_fn_ret_failure () { return 1; }

exitcode=0
as_fn_success || { exitcode=1; echo as_fn_success failed.; }
as_fn_failure && { exitcode=1; echo as_fn_failure succeeded.; }
as_fn_ret_success || { exitcode=1; echo as_fn_ret_success failed.; }
as_fn_ret_failure && { exitcode=1; echo as_fn_ret_failure succeeded.; }
if ( set x; as_fn_ret_success y && test x = \"\$1\" ); then :

else
  exitcode=1; echo positional parameters were not saved.
fi
test x\$exitcode = x0 || exit 1
test -x / || exit 1"
  as_suggested="  as_lineno_1=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_1a=\$LINENO
  as_lineno_2=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_2a=\$LINENO
  eval 'test \"x\$as_lineno_1'\$as_run'\" != \"x\$as_lineno_2'\$as_run'\" &&
  test \"x\`expr \$as_lineno_1'\$as_run' + 1\`\" = \"x\$as_lineno_2'\$as_run'\"' || exit 1
test \$(( 1 + 1 )) = 2 || exit 1"
  if (eval "$as_required") 2>/dev/null; then :
  as_have_required=yes
else
  as_have_required=no
fi
  if test x$as_have_required = xyes && (eval "$as_suggested") 2>/dev/null; then :

else
  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
as_found=false
for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
  as_found=:
  case $as_dir in #(
	 /*)
	   for as_base in sh bash ksh sh5; do
	     # Try only shells that exist, to save several forks.
	     as_shell=$as_dir/$as_base
	     if { test -f "$as_shell" || test -f "$as_shell.exe"; } &&
		    { $as_echo "$as_bourne_compatible""$as_required" | as_run=a "$as_shell"; } 2>/dev/null; then :
  CONFIG_SHELL=$as_shell as_have_required=yes
		   if { $as_echo "$as_bourne_compatible""$as_suggested" | as_run=a "$as_shell"; } 2>/dev/null; then :
  break 2
fi
fi
	   done;;
       esac
  as_found=false
done
$as_found || { if { test -f "$SHELL" || test -f "$SHELL.exe"; } &&
	      { $as_echo "$as_bourne_compatible""$as_required" | as_run=a "$SHELL"; } 2>/dev/null; then :
  CONFIG_SHELL=$SHELL as_have_required=yes
fi; }
IFS=$as_save_IFS


      if test "x$CONFIG_SHELL" != x; then :
  export CONFIG_SHELL
             # We cannot yet assume a decent shell, so we have to provide a
# neutralization value for shells without unset; and this also
# works around shells that cannot unset nonexistent variables.
# Preserve -v and -x to the replacement shell.
BASH_ENV=/dev/null
ENV=/dev/null
(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV
case $- in # ((((
  *v*x* | *x*v* ) as_opts=-vx ;;
  *v* ) as_opts=-v ;;
  *x* ) as_opts=-x ;;
  * ) as_opts= ;;
esac
exec $CONFIG_SHELL $as_opts "$as_myself" ${1+"$@"}
# Admittedly, this is quite paranoid, since all the known shells bail
# out after a failed `exec'.
$as_echo "$0: could not re-execute with $CONFIG_SHELL" >&2
exit 255
fi

    if test x$as_have_required = xno; then :
  $as_echo "$0: This script requires a shell more modern than all"
  $as_echo "$0: the shells that I found on your system."
  if test x${ZSH_VERSION+set} = xset ; then
    $as_echo "$0: In particular, zsh $ZSH_VERSION has bugs and should"
    $as_echo "$0: be upgraded to zsh 4.3.4 or later."
  else
    $as_echo "$0: Please tell bug-autoconf@gnu.org about your system,
$0: including any error possibly output before this
$0: message. Then install a modern shell, or manually run
$0: the script under such a shell if you do have one."
  fi
  exit 1
fi
fi
fi
SHELL=${CONFIG_SHELL-/bin/sh}
export SHELL
# Unset more variables known to interfere with behavior of common tools.
CLICOLOR_FORCE= GREP_OPTIONS=
unset CLICOLOR_FORCE GREP_OPTIONS

## --------------------- ##
## M4sh Shell Functions. ##
## --------------------- ##
# as_fn_unset VAR
# ---------------
# Portably unset VAR.
as_fn_unset ()
{
  { eval $1=; unset $1;}
}
as_unset=as_fn_unset

# as_fn_set_status STATUS
# -----------------------
# Set $? to STATUS, without forking.
as_fn_set_status ()
{
  return $1
} # as_fn_set_status

# as_fn_exit STATUS
# -----------------
# Exit the shell with STATUS, even in a "trap 0" or "set -e" context.
as_fn_exit ()
{
  set +e
  as_fn_set_status $1
  exit $1
} # as_fn_exit

# as_fn_mkdir_p
# -------------
# Create "$as_dir" as a directory, including parents if necessary.
as_fn_mkdir_p ()
{

  case $as_dir in #(
  -*) as_dir=./$as_dir;;
  esac
  test -d "$as_dir" || eval $as_mkdir_p || {
    as_dirs=
    while :; do
      case $as_dir in #(
      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
      *) as_qdir=$as_dir;;
      esac
      as_dirs="'$as_qdir' $as_dirs"
      as_dir=`$as_dirname -- "$as_dir" ||
$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
	 X"$as_dir" : 'X\(//\)[^/]' \| \
	 X"$as_dir" : 'X\(//\)$' \| \
	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
$as_echo X"$as_dir" |
    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
	    s//\1/
	    q
	  }
	  /^X\(\/\/\)[^/].*/{
	    s//\1/
	    q
	  }
	  /^X\(\/\/\)$/{
	    s//\1/
	    q
	  }
	  /^X\(\/\).*/{
	    s//\1/
	    q
	  }
	  s/.*/./; q'`
      test -d "$as_dir" && break
    done
    test -z "$as_dirs" || eval "mkdir $as_dirs"
  } || test -d "$as_dir" || as_fn_error $? "cannot create directory $as_dir"


} # as_fn_mkdir_p

# as_fn_executable_p FILE
# -----------------------
# Test if FILE is an executable regular file.
as_fn_executable_p ()
{
  test -f "$1" && test -x "$1"
} # as_fn_executable_p
# as_fn_append VAR VALUE
# ----------------------
# Append the text in VALUE to the end of the definition contained in VAR. Take
# advantage of any shell optimizations that allow amortized linear growth over
# repeated appends, instead of the typical quadratic growth present in naive
# implementations.
if (eval "as_var=1; as_var+=2; test x\$as_var = x12") 2>/dev/null; then :
  eval 'as_fn_append ()
  {
    eval $1+=\$2
  }'
else
  as_fn_append ()
  {
    eval $1=\$$1\$2
  }
fi # as_fn_append

# as_fn_arith ARG...
# ------------------
# Perform arithmetic evaluation on the ARGs, and store the result in the
# global $as_val. Take advantage of shells that can avoid forks. The arguments
# must be portable across $(()) and expr.
if (eval "test \$(( 1 + 1 )) = 2") 2>/dev/null; then :
  eval 'as_fn_arith ()
  {
    as_val=$(( $* ))
  }'
else
  as_fn_arith ()
  {
    as_val=`expr "$@" || test $? -eq 1`
  }
fi # as_fn_arith


# as_fn_error STATUS ERROR [LINENO LOG_FD]
# ----------------------------------------
# Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
# provided, also output the error to LOG_FD, referencing LINENO. Then exit the
# script with STATUS, using 1 if that was 0.
as_fn_error ()
{
  as_status=$1; test $as_status -eq 0 && as_status=1
  if test "$4"; then
    as_lineno=${as_lineno-"$3"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
    $as_echo "$as_me:${as_lineno-$LINENO}: error: $2" >&$4
  fi
  $as_echo "$as_me: error: $2" >&2
  as_fn_exit $as_status
} # as_fn_error

if expr a : '\(a\)' >/dev/null 2>&1 &&
   test "X`expr 00001 : '.*\(...\)'`" = X001; then
  as_expr=expr
else
  as_expr=false
fi

if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
  as_basename=basename
else
  as_basename=false
fi

if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
  as_dirname=dirname
else
  as_dirname=false
fi

as_me=`$as_basename -- "$0" ||
$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
	 X"$0" : 'X\(//\)$' \| \
	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
$as_echo X/"$0" |
    sed '/^.*\/\([^/][^/]*\)\/*$/{
	    s//\1/
	    q
	  }
	  /^X\/\(\/\/\)$/{
	    s//\1/
	    q
	  }
	  /^X\/\(\/\).*/{
	    s//\1/
	    q
	  }
	  s/.*/./; q'`

# Avoid depending upon Character Ranges.
as_cr_letters='abcdefghijklmnopqrstuvwxyz'
as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
as_cr_Letters=$as_cr_letters$as_cr_LETTERS
as_cr_digits='0123456789'
as_cr_alnum=$as_cr_Letters$as_cr_digits


  as_lineno_1=$LINENO as_lineno_1a=$LINENO
  as_lineno_2=$LINENO as_lineno_2a=$LINENO
  eval 'test "x$as_lineno_1'$as_run'" != "x$as_lineno_2'$as_run'" &&
  test "x`expr $as_lineno_1'$as_run' + 1`" = "x$as_lineno_2'$as_run'"' || {
  # Blame Lee E. McMahon (1931-1989) for sed's syntax.  :-)
  sed -n '
    p
    /[$]LINENO/=
  ' <$as_myself |
    sed '
      s/[$]LINENO.*/&-/
      t lineno
      b
      :lineno
      N
      :loop
      s/[$]LINENO\([^'$as_cr_alnum'_].*\n\)\(.*\)/\2\1\2/
      t loop
      s/-\n.*//
    ' >$as_me.lineno &&
  chmod +x "$as_me.lineno" ||
    { $as_echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2; as_fn_exit 1; }

  # If we had to re-execute with $CONFIG_SHELL, we're ensured to have
  # already done that, so ensure we don't try to do so again and fall
  # in an infinite loop.  This has already happened in practice.
  _as_can_reexec=no; export _as_can_reexec
  # Don't try to exec as it changes $[0], causing all sort of problems
  # (the dirname of $[0] is not the place where we might find the
  # original and so on.  Autoconf is especially sensitive to this).
  . "./$as_me.lineno"
  # Exit status is that of the last command.
  exit
}

ECHO_C= ECHO_N= ECHO_T=
case `echo -n x` in #(((((
-n*)
  case `echo 'xy\c'` in
  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
  xy)  ECHO_C='\c';;
  *)   echo `echo ksh88 bug on AIX 6.1` > /dev/null
       ECHO_T='	';;
  esac;;
*)
  ECHO_N='-n';;
esac

rm -f conf$$ conf$$.exe conf$$.file
if test -d conf$$.dir; then
  rm -f conf$$.dir/conf$$.file
else
  rm -f conf$$.dir
  mkdir conf$$.dir 2>/dev/null
fi
if (echo >conf$$.file) 2>/dev/null; then
  if ln -s conf$$.file conf$$ 2>/dev/null; then
    as_ln_s='ln -s'
    # ... but there are two gotchas:
    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
    # In both cases, we have to default to `cp -pR'.
    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
      as_ln_s='cp -pR'
  elif ln conf$$.file conf$$ 2>/dev/null; then
    as_ln_s=ln
  else
    as_ln_s='cp -pR'
  fi
else
  as_ln_s='cp -pR'
fi
rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
rmdir conf$$.dir 2>/dev/null

if mkdir -p . 2>/dev/null; then
  as_mkdir_p='mkdir -p "$as_dir"'
else
  test -d ./-p && rmdir ./-p
  as_mkdir_p=false
fi

as_test_x='test -x'
as_executable_p=as_fn_executable_p

# Sed expression to map a string onto a valid CPP name.
as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"

# Sed expression to map a string onto a valid variable name.
as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"


test -n "$DJDIR" || exec 7<&0 </dev/null
exec 6>&1

# Name of the host.
# hostname on some systems (SVR3.2, old GNU/Linux) returns a bogus exit status,
# so uname gets run too.
ac_hostname=`(hostname || uname -n) 2>/dev/null | sed 1q`

#
# Initializations.
#
ac_default_prefix=/usr/local
ac_clean_files=
ac_config_libobj_dir=.
LIBOBJS=
cross_compiling=no
subdirs=
MFLAGS=
MAKEFLAGS=

# Identity of this package.
PACKAGE_NAME=
PACKAGE_TARNAME=
PACKAGE_VERSION=
PACKAGE_STRING=
PACKAGE_BUGREPORT=
PACKAGE_URL=

ac_unique_file="fdlibm"
ac_unique_file="include/fdlibm.h"
# Factoring default headers for most tests.
ac_includes_default="\
#include <stdio.h>
#ifdef HAVE_SYS_TYPES_H
# include <sys/types.h>
#endif
#ifdef HAVE_SYS_STAT_H
# include <sys/stat.h>
#endif
#ifdef STDC_HEADERS
# include <stdlib.h>
# include <stddef.h>
#else
# ifdef HAVE_STDLIB_H
#  include <stdlib.h>
# endif
#endif
#ifdef HAVE_STRING_H
# if !defined STDC_HEADERS && defined HAVE_MEMORY_H
#  include <memory.h>
# endif
# include <string.h>
#endif
#ifdef HAVE_STRINGS_H
# include <strings.h>
#endif
#ifdef HAVE_INTTYPES_H
# include <inttypes.h>
#endif
#ifdef HAVE_STDINT_H
# include <stdint.h>
#endif
#ifdef HAVE_UNISTD_H
# include <unistd.h>
#endif"

ac_subst_vars='LTLIBOBJS
LIBOBJS
ac_aux_dir
EGREP
GREP
CPP
AR
RANLIB
OBJEXT
EXEEXT
ac_ct_CC
CPPFLAGS
LDFLAGS
CFLAGS
CC
host_os
host_vendor
host_cpu
host
build_os
build_vendor
build_cpu
build
target_alias
host_alias
build_alias
LIBS
ECHO_T
ECHO_N
ECHO_C
DEFS
mandir
localedir
libdir
psdir
pdfdir
dvidir
htmldir
infodir
docdir
oldincludedir
includedir
localstatedir
sharedstatedir
sysconfdir
datadir
datarootdir
libexecdir
sbindir
bindir
program_transform_name
prefix
exec_prefix
PACKAGE_URL
PACKAGE_BUGREPORT
PACKAGE_STRING
PACKAGE_VERSION
PACKAGE_TARNAME
PACKAGE_NAME
PATH_SEPARATOR
SHELL'
ac_subst_files=''
ac_user_opts='
enable_option_checking
'
      ac_precious_vars='build_alias
host_alias
target_alias
CC
CFLAGS
LDFLAGS
LIBS
CPPFLAGS
CPP'


# Initialize some variables set by options.
ac_init_help=
ac_init_version=false
ac_unrecognized_opts=
ac_unrecognized_sep=
# The variables have the same names as the options, with
# dashes changed to underlines.
cache_file=/dev/null
exec_prefix=NONE
no_create=
no_recursion=
prefix=NONE
program_prefix=NONE
program_suffix=NONE
program_transform_name=s,x,x,
silent=
site=
srcdir=
verbose=
x_includes=NONE
x_libraries=NONE

# Installation directory options.
# These are left unexpanded so users can "make install exec_prefix=/foo"
# and all the variables that are supposed to be based on exec_prefix
# by default will actually change.
# Use braces instead of parens because sh, perl, etc. also accept them.
# (The list follows the same order as the GNU Coding Standards.)
bindir='${exec_prefix}/bin'
sbindir='${exec_prefix}/sbin'
libexecdir='${exec_prefix}/libexec'
datarootdir='${prefix}/share'
datadir='${datarootdir}'
sysconfdir='${prefix}/etc'
sharedstatedir='${prefix}/com'
localstatedir='${prefix}/var'
includedir='${prefix}/include'
oldincludedir='/usr/include'
docdir='${datarootdir}/doc/${PACKAGE}'
infodir='${datarootdir}/info'
htmldir='${docdir}'
dvidir='${docdir}'
pdfdir='${docdir}'
psdir='${docdir}'
libdir='${exec_prefix}/lib'
localedir='${datarootdir}/locale'
mandir='${datarootdir}/man'

ac_prev=
ac_dashdash=
for ac_option
do
  # If the previous option needs an argument, assign it.
  if test -n "$ac_prev"; then
    eval $ac_prev=\$ac_option
    ac_prev=
    continue
  fi

  case $ac_option in
  *=?*) ac_optarg=`expr "X$ac_option" : '[^=]*=\(.*\)'` ;;
  *=)   ac_optarg= ;;
  *)    ac_optarg=yes ;;
  esac

  # Accept the important Cygnus configure options, so we can diagnose typos.

  case $ac_dashdash$ac_option in
  --)
    ac_dashdash=yes ;;

  -bindir | --bindir | --bindi | --bind | --bin | --bi)
    ac_prev=bindir ;;
  -bindir=* | --bindir=* | --bindi=* | --bind=* | --bin=* | --bi=*)
    bindir=$ac_optarg ;;

  -build | --build | --buil | --bui | --bu)
    ac_prev=build_alias ;;
  -build=* | --build=* | --buil=* | --bui=* | --bu=*)
    build_alias=$ac_optarg ;;

  -cache-file | --cache-file | --cache-fil | --cache-fi \
  | --cache-f | --cache- | --cache | --cach | --cac | --ca | --c)
    ac_prev=cache_file ;;
  -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \
  | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* | --c=*)
    cache_file=$ac_optarg ;;

  --config-cache | -C)
    cache_file=config.cache ;;

  -datadir | --datadir | --datadi | --datad)
    ac_prev=datadir ;;
  -datadir=* | --datadir=* | --datadi=* | --datad=*)
    datadir=$ac_optarg ;;

  -datarootdir | --datarootdir | --datarootdi | --datarootd | --dataroot \
  | --dataroo | --dataro | --datar)
    ac_prev=datarootdir ;;
  -datarootdir=* | --datarootdir=* | --datarootdi=* | --datarootd=* \
  | --dataroot=* | --dataroo=* | --dataro=* | --datar=*)
    datarootdir=$ac_optarg ;;

  -disable-* | --disable-*)
    ac_useropt=`expr "x$ac_option" : 'x-*disable-\(.*\)'`
    # Reject names that are not valid shell variable names.
    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
      as_fn_error $? "invalid feature name: $ac_useropt"
    ac_useropt_orig=$ac_useropt
    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
    case $ac_user_opts in
      *"
"enable_$ac_useropt"
"*) ;;
      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--disable-$ac_useropt_orig"
	 ac_unrecognized_sep=', ';;
    esac
    eval enable_$ac_useropt=no ;;

  -docdir | --docdir | --docdi | --doc | --do)
    ac_prev=docdir ;;
  -docdir=* | --docdir=* | --docdi=* | --doc=* | --do=*)
    docdir=$ac_optarg ;;

  -dvidir | --dvidir | --dvidi | --dvid | --dvi | --dv)
    ac_prev=dvidir ;;
  -dvidir=* | --dvidir=* | --dvidi=* | --dvid=* | --dvi=* | --dv=*)
    dvidir=$ac_optarg ;;

  -enable-* | --enable-*)
    ac_useropt=`expr "x$ac_option" : 'x-*enable-\([^=]*\)'`
    # Reject names that are not valid shell variable names.
    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
      as_fn_error $? "invalid feature name: $ac_useropt"
    ac_useropt_orig=$ac_useropt
    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
    case $ac_user_opts in
      *"
"enable_$ac_useropt"
"*) ;;
      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--enable-$ac_useropt_orig"
	 ac_unrecognized_sep=', ';;
    esac
    eval enable_$ac_useropt=\$ac_optarg ;;

  -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \
  | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \
  | --exec | --exe | --ex)
    ac_prev=exec_prefix ;;
  -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* \
  | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \
  | --exec=* | --exe=* | --ex=*)
    exec_prefix=$ac_optarg ;;

  -gas | --gas | --ga | --g)
    # Obsolete; use --with-gas.
    with_gas=yes ;;

  -help | --help | --hel | --he | -h)
    ac_init_help=long ;;
  -help=r* | --help=r* | --hel=r* | --he=r* | -hr*)
    ac_init_help=recursive ;;
  -help=s* | --help=s* | --hel=s* | --he=s* | -hs*)
    ac_init_help=short ;;

  -host | --host | --hos | --ho)
    ac_prev=host_alias ;;
  -host=* | --host=* | --hos=* | --ho=*)
    host_alias=$ac_optarg ;;

  -htmldir | --htmldir | --htmldi | --htmld | --html | --htm | --ht)
    ac_prev=htmldir ;;
  -htmldir=* | --htmldir=* | --htmldi=* | --htmld=* | --html=* | --htm=* \
  | --ht=*)
    htmldir=$ac_optarg ;;

  -includedir | --includedir | --includedi | --included | --include \
  | --includ | --inclu | --incl | --inc)
    ac_prev=includedir ;;
  -includedir=* | --includedir=* | --includedi=* | --included=* | --include=* \
  | --includ=* | --inclu=* | --incl=* | --inc=*)
    includedir=$ac_optarg ;;

  -infodir | --infodir | --infodi | --infod | --info | --inf)
    ac_prev=infodir ;;
  -infodir=* | --infodir=* | --infodi=* | --infod=* | --info=* | --inf=*)
    infodir=$ac_optarg ;;

  -libdir | --libdir | --libdi | --libd)
    ac_prev=libdir ;;
  -libdir=* | --libdir=* | --libdi=* | --libd=*)
    libdir=$ac_optarg ;;

  -libexecdir | --libexecdir | --libexecdi | --libexecd | --libexec \
  | --libexe | --libex | --libe)
    ac_prev=libexecdir ;;
  -libexecdir=* | --libexecdir=* | --libexecdi=* | --libexecd=* | --libexec=* \
  | --libexe=* | --libex=* | --libe=*)
    libexecdir=$ac_optarg ;;

  -localedir | --localedir | --localedi | --localed | --locale)
    ac_prev=localedir ;;
  -localedir=* | --localedir=* | --localedi=* | --localed=* | --locale=*)
    localedir=$ac_optarg ;;

  -localstatedir | --localstatedir | --localstatedi | --localstated \
  | --localstate | --localstat | --localsta | --localst | --locals)
    ac_prev=localstatedir ;;
  -localstatedir=* | --localstatedir=* | --localstatedi=* | --localstated=* \
  | --localstate=* | --localstat=* | --localsta=* | --localst=* | --locals=*)
    localstatedir=$ac_optarg ;;

  -mandir | --mandir | --mandi | --mand | --man | --ma | --m)
    ac_prev=mandir ;;
  -mandir=* | --mandir=* | --mandi=* | --mand=* | --man=* | --ma=* | --m=*)
    mandir=$ac_optarg ;;

  -nfp | --nfp | --nf)
    # Obsolete; use --without-fp.
    with_fp=no ;;

  -no-create | --no-create | --no-creat | --no-crea | --no-cre \
  | --no-cr | --no-c | -n)
    no_create=yes ;;

  -no-recursion | --no-recursion | --no-recursio | --no-recursi \
  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r)
    no_recursion=yes ;;

  -oldincludedir | --oldincludedir | --oldincludedi | --oldincluded \
  | --oldinclude | --oldinclud | --oldinclu | --oldincl | --oldinc \
  | --oldin | --oldi | --old | --ol | --o)
    ac_prev=oldincludedir ;;
  -oldincludedir=* | --oldincludedir=* | --oldincludedi=* | --oldincluded=* \
  | --oldinclude=* | --oldinclud=* | --oldinclu=* | --oldincl=* | --oldinc=* \
  | --oldin=* | --oldi=* | --old=* | --ol=* | --o=*)
    oldincludedir=$ac_optarg ;;

  -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
    ac_prev=prefix ;;
  -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
    prefix=$ac_optarg ;;

  -program-prefix | --program-prefix | --program-prefi | --program-pref \
  | --program-pre | --program-pr | --program-p)
    ac_prev=program_prefix ;;
  -program-prefix=* | --program-prefix=* | --program-prefi=* \
  | --program-pref=* | --program-pre=* | --program-pr=* | --program-p=*)
    program_prefix=$ac_optarg ;;

  -program-suffix | --program-suffix | --program-suffi | --program-suff \
  | --program-suf | --program-su | --program-s)
    ac_prev=program_suffix ;;
  -program-suffix=* | --program-suffix=* | --program-suffi=* \
  | --program-suff=* | --program-suf=* | --program-su=* | --program-s=*)
    program_suffix=$ac_optarg ;;

  -program-transform-name | --program-transform-name \
  | --program-transform-nam | --program-transform-na \
  | --program-transform-n | --program-transform- \
  | --program-transform | --program-transfor \
  | --program-transfo | --program-transf \
  | --program-trans | --program-tran \
  | --progr-tra | --program-tr | --program-t)
    ac_prev=program_transform_name ;;
  -program-transform-name=* | --program-transform-name=* \
  | --program-transform-nam=* | --program-transform-na=* \
  | --program-transform-n=* | --program-transform-=* \
  | --program-transform=* | --program-transfor=* \
  | --program-transfo=* | --program-transf=* \
  | --program-trans=* | --program-tran=* \
  | --progr-tra=* | --program-tr=* | --program-t=*)
    program_transform_name=$ac_optarg ;;

  -pdfdir | --pdfdir | --pdfdi | --pdfd | --pdf | --pd)
    ac_prev=pdfdir ;;
  -pdfdir=* | --pdfdir=* | --pdfdi=* | --pdfd=* | --pdf=* | --pd=*)
    pdfdir=$ac_optarg ;;

  -psdir | --psdir | --psdi | --psd | --ps)
    ac_prev=psdir ;;
  -psdir=* | --psdir=* | --psdi=* | --psd=* | --ps=*)
    psdir=$ac_optarg ;;

  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
  | -silent | --silent | --silen | --sile | --sil)
    silent=yes ;;

  -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)
    ac_prev=sbindir ;;
  -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \
  | --sbi=* | --sb=*)
    sbindir=$ac_optarg ;;

  -sharedstatedir | --sharedstatedir | --sharedstatedi \
  | --sharedstated | --sharedstate | --sharedstat | --sharedsta \
  | --sharedst | --shareds | --shared | --share | --shar \
  | --sha | --sh)
    ac_prev=sharedstatedir ;;
  -sharedstatedir=* | --sharedstatedir=* | --sharedstatedi=* \
  | --sharedstated=* | --sharedstate=* | --sharedstat=* | --sharedsta=* \
  | --sharedst=* | --shareds=* | --shared=* | --share=* | --shar=* \
  | --sha=* | --sh=*)
    sharedstatedir=$ac_optarg ;;

  -site | --site | --sit)
    ac_prev=site ;;
  -site=* | --site=* | --sit=*)
    site=$ac_optarg ;;

  -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)
    ac_prev=srcdir ;;
  -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)
    srcdir=$ac_optarg ;;

  -sysconfdir | --sysconfdir | --sysconfdi | --sysconfd | --sysconf \
  | --syscon | --sysco | --sysc | --sys | --sy)
    ac_prev=sysconfdir ;;
  -sysconfdir=* | --sysconfdir=* | --sysconfdi=* | --sysconfd=* | --sysconf=* \
  | --syscon=* | --sysco=* | --sysc=* | --sys=* | --sy=*)
    sysconfdir=$ac_optarg ;;

  -target | --target | --targe | --targ | --tar | --ta | --t)
    ac_prev=target_alias ;;
  -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)
    target_alias=$ac_optarg ;;

  -v | -verbose | --verbose | --verbos | --verbo | --verb)
    verbose=yes ;;

  -version | --version | --versio | --versi | --vers | -V)
    ac_init_version=: ;;

  -with-* | --with-*)
    ac_useropt=`expr "x$ac_option" : 'x-*with-\([^=]*\)'`
    # Reject names that are not valid shell variable names.
    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
      as_fn_error $? "invalid package name: $ac_useropt"
    ac_useropt_orig=$ac_useropt
    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
    case $ac_user_opts in
      *"
"with_$ac_useropt"
"*) ;;
      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--with-$ac_useropt_orig"
	 ac_unrecognized_sep=', ';;
    esac
    eval with_$ac_useropt=\$ac_optarg ;;

  -without-* | --without-*)
    ac_useropt=`expr "x$ac_option" : 'x-*without-\(.*\)'`
    # Reject names that are not valid shell variable names.
    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
      as_fn_error $? "invalid package name: $ac_useropt"
    ac_useropt_orig=$ac_useropt
    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
    case $ac_user_opts in
      *"
"with_$ac_useropt"
"*) ;;
      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--without-$ac_useropt_orig"
	 ac_unrecognized_sep=', ';;
    esac
    eval with_$ac_useropt=no ;;

  --x)
    # Obsolete; use --with-x.
    with_x=yes ;;

  -x-includes | --x-includes | --x-include | --x-includ | --x-inclu \
  | --x-incl | --x-inc | --x-in | --x-i)
    ac_prev=x_includes ;;
  -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \
  | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)
    x_includes=$ac_optarg ;;

  -x-libraries | --x-libraries | --x-librarie | --x-librari \
  | --x-librar | --x-libra | --x-libr | --x-lib | --x-li | --x-l)
    ac_prev=x_libraries ;;
  -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \
  | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
    x_libraries=$ac_optarg ;;

  -*) as_fn_error $? "unrecognized option: \`$ac_option'
Try \`$0 --help' for more information"
    ;;

  *=*)
    ac_envvar=`expr "x$ac_option" : 'x\([^=]*\)='`
    # Reject names that are not valid shell variable names.
    case $ac_envvar in #(
      '' | [0-9]* | *[!_$as_cr_alnum]* )
      as_fn_error $? "invalid variable name: \`$ac_envvar'" ;;
    esac
    eval $ac_envvar=\$ac_optarg
    export $ac_envvar ;;

  *)
    # FIXME: should be removed in autoconf 3.0.
    $as_echo "$as_me: WARNING: you should use --build, --host, --target" >&2
    expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
      $as_echo "$as_me: WARNING: invalid host type: $ac_option" >&2
    : "${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}"
    ;;

  esac
done

if test -n "$ac_prev"; then
  ac_option=--`echo $ac_prev | sed 's/_/-/g'`
  as_fn_error $? "missing argument to $ac_option"
fi

if test -n "$ac_unrecognized_opts"; then
  case $enable_option_checking in
    no) ;;
    fatal) as_fn_error $? "unrecognized options: $ac_unrecognized_opts" ;;
    *)     $as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2 ;;
  esac
fi

# Check all directory arguments for consistency.
for ac_var in	exec_prefix prefix bindir sbindir libexecdir datarootdir \
		datadir sysconfdir sharedstatedir localstatedir includedir \
		oldincludedir docdir infodir htmldir dvidir pdfdir psdir \
		libdir localedir mandir
do
  eval ac_val=\$$ac_var
  # Remove trailing slashes.
  case $ac_val in
    */ )
      ac_val=`expr "X$ac_val" : 'X\(.*[^/]\)' \| "X$ac_val" : 'X\(.*\)'`
      eval $ac_var=\$ac_val;;
  esac
  # Be sure to have absolute directory names.
  case $ac_val in
    [\\/$]* | ?:[\\/]* )  continue;;
    NONE | '' ) case $ac_var in *prefix ) continue;; esac;;
  esac
  as_fn_error $? "expected an absolute directory name for --$ac_var: $ac_val"
done

# There might be people who depend on the old broken behavior: `$host'
# used to hold the argument of --host etc.
# FIXME: To remove some day.
build=$build_alias
host=$host_alias
target=$target_alias

# FIXME: To remove some day.
if test "x$host_alias" != x; then
  if test "x$build_alias" = x; then
    cross_compiling=maybe
  elif test "x$build_alias" != "x$host_alias"; then
    cross_compiling=yes
  fi
fi

ac_tool_prefix=
test -n "$host_alias" && ac_tool_prefix=$host_alias-

test "$silent" = yes && exec 6>/dev/null


ac_pwd=`pwd` && test -n "$ac_pwd" &&
ac_ls_di=`ls -di .` &&
ac_pwd_ls_di=`cd "$ac_pwd" && ls -di .` ||
  as_fn_error $? "working directory cannot be determined"
test "X$ac_ls_di" = "X$ac_pwd_ls_di" ||
  as_fn_error $? "pwd does not report name of working directory"


# Find the source files, if location was not specified.
if test -z "$srcdir"; then
  ac_srcdir_defaulted=yes
  # Try the directory containing this script, then the parent directory.
  ac_confdir=`$as_dirname -- "$as_myself" ||
$as_expr X"$as_myself" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
	 X"$as_myself" : 'X\(//\)[^/]' \| \
	 X"$as_myself" : 'X\(//\)$' \| \
	 X"$as_myself" : 'X\(/\)' \| . 2>/dev/null ||
$as_echo X"$as_myself" |
    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
	    s//\1/
	    q
	  }
	  /^X\(\/\/\)[^/].*/{
	    s//\1/
	    q
	  }
	  /^X\(\/\/\)$/{
	    s//\1/
	    q
	  }
	  /^X\(\/\).*/{
	    s//\1/
	    q
	  }
	  s/.*/./; q'`
  srcdir=$ac_confdir
  if test ! -r "$srcdir/$ac_unique_file"; then
    srcdir=..
  fi
else
  ac_srcdir_defaulted=no
fi
if test ! -r "$srcdir/$ac_unique_file"; then
  test "$ac_srcdir_defaulted" = yes && srcdir="$ac_confdir or .."
  as_fn_error $? "cannot find sources ($ac_unique_file) in $srcdir"
fi
ac_msg="sources are in $srcdir, but \`cd $srcdir' does not work"
ac_abs_confdir=`(
	cd "$srcdir" && test -r "./$ac_unique_file" || as_fn_error $? "$ac_msg"
	pwd)`
# When building in place, set srcdir=.
if test "$ac_abs_confdir" = "$ac_pwd"; then
  srcdir=.
fi
# Remove unnecessary trailing slashes from srcdir.
# Double slashes in file names in object file debugging info
# mess up M-x gdb in Emacs.
case $srcdir in
*/) srcdir=`expr "X$srcdir" : 'X\(.*[^/]\)' \| "X$srcdir" : 'X\(.*\)'`;;
esac
for ac_var in $ac_precious_vars; do
  eval ac_env_${ac_var}_set=\${${ac_var}+set}
  eval ac_env_${ac_var}_value=\$${ac_var}
  eval ac_cv_env_${ac_var}_set=\${${ac_var}+set}
  eval ac_cv_env_${ac_var}_value=\$${ac_var}
done

#
# Report the --help message.
#
if test "$ac_init_help" = "long"; then
  # Omit some internal or obsolete options to make the list less imposing.
  # This message is too long to be a string in the A/UX 3.1 sh.
  cat <<_ACEOF
\`configure' configures this package to adapt to many kinds of systems.

Usage: $0 [OPTION]... [VAR=VALUE]...

To assign environment variables (e.g., CC, CFLAGS...), specify them as
VAR=VALUE.  See below for descriptions of some of the useful variables.

Defaults for the options are specified in brackets.

Configuration:
  -h, --help              display this help and exit
      --help=short        display options specific to this package
      --help=recursive    display the short help of all the included packages
  -V, --version           display version information and exit
  -q, --quiet, --silent   do not print \`checking ...' messages
      --cache-file=FILE   cache test results in FILE [disabled]
  -C, --config-cache      alias for \`--cache-file=config.cache'
  -n, --no-create         do not create output files
      --srcdir=DIR        find the sources in DIR [configure dir or \`..']

Installation directories:
  --prefix=PREFIX         install architecture-independent files in PREFIX
                          [$ac_default_prefix]
  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX
                          [PREFIX]

By default, \`make install' will install all the files in
\`$ac_default_prefix/bin', \`$ac_default_prefix/lib' etc.  You can specify
an installation prefix other than \`$ac_default_prefix' using \`--prefix',
for instance \`--prefix=\$HOME'.

For better control, use the options below.

Fine tuning of the installation directories:
  --bindir=DIR            user executables [EPREFIX/bin]
  --sbindir=DIR           system admin executables [EPREFIX/sbin]
  --libexecdir=DIR        program executables [EPREFIX/libexec]
  --sysconfdir=DIR        read-only single-machine data [PREFIX/etc]
  --sharedstatedir=DIR    modifiable architecture-independent data [PREFIX/com]
  --localstatedir=DIR     modifiable single-machine data [PREFIX/var]
  --libdir=DIR            object code libraries [EPREFIX/lib]
  --includedir=DIR        C header files [PREFIX/include]
  --oldincludedir=DIR     C header files for non-gcc [/usr/include]
  --datarootdir=DIR       read-only arch.-independent data root [PREFIX/share]
  --datadir=DIR           read-only architecture-independent data [DATAROOTDIR]
  --infodir=DIR           info documentation [DATAROOTDIR/info]
  --localedir=DIR         locale-dependent data [DATAROOTDIR/locale]
  --mandir=DIR            man documentation [DATAROOTDIR/man]
  --docdir=DIR            documentation root [DATAROOTDIR/doc/PACKAGE]
  --htmldir=DIR           html documentation [DOCDIR]
  --dvidir=DIR            dvi documentation [DOCDIR]
  --pdfdir=DIR            pdf documentation [DOCDIR]
  --psdir=DIR             ps documentation [DOCDIR]
_ACEOF

  cat <<\_ACEOF

System types:
  --build=BUILD     configure for building on BUILD [guessed]
  --host=HOST       cross-compile to build programs to run on HOST [BUILD]
_ACEOF
fi

if test -n "$ac_init_help"; then

  cat <<\_ACEOF

Some influential environment variables:
  CC          C compiler command
  CFLAGS      C compiler flags
  LDFLAGS     linker flags, e.g. -L<lib dir> if you have libraries in a
              nonstandard directory <lib dir>
  LIBS        libraries to pass to the linker, e.g. -l<library>
  CPPFLAGS    (Objective) C/C++ preprocessor flags, e.g. -I<include dir> if
              you have headers in a nonstandard directory <include dir>
  CPP         C preprocessor

Use these variables to override the choices made by `configure' or to help
it to find libraries and programs with nonstandard names/locations.

Report bugs to the package provider.
_ACEOF
ac_status=$?
fi

if test "$ac_init_help" = "recursive"; then
  # If there are subdirs, report their specific --help.
  for ac_dir in : $ac_subdirs_all; do test "x$ac_dir" = x: && continue
    test -d "$ac_dir" ||
      { cd "$srcdir" && ac_pwd=`pwd` && srcdir=. && test -d "$ac_dir"; } ||
      continue
    ac_builddir=.

case "$ac_dir" in
.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
*)
  ac_dir_suffix=/`$as_echo "$ac_dir" | sed 's|^\.[\\/]||'`
  # A ".." for each directory in $ac_dir_suffix.
  ac_top_builddir_sub=`$as_echo "$ac_dir_suffix" | sed 's|/[^\\/]*|/..|g;s|/||'`
  case $ac_top_builddir_sub in
  "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
  esac ;;
esac
ac_abs_top_builddir=$ac_pwd
ac_abs_builddir=$ac_pwd$ac_dir_suffix
# for backward compatibility:
ac_top_builddir=$ac_top_build_prefix

case $srcdir in
  .)  # We are building in place.
    ac_srcdir=.
    ac_top_srcdir=$ac_top_builddir_sub
    ac_abs_top_srcdir=$ac_pwd ;;
  [\\/]* | ?:[\\/]* )  # Absolute name.
    ac_srcdir=$srcdir$ac_dir_suffix;
    ac_top_srcdir=$srcdir
    ac_abs_top_srcdir=$srcdir ;;
  *) # Relative name.
    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix
    ac_top_srcdir=$ac_top_build_prefix$srcdir
    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;
esac
ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix

    cd "$ac_dir" || { ac_status=$?; continue; }
    # Check for guested configure.
    if test -f "$ac_srcdir/configure.gnu"; then
      echo &&
      $SHELL "$ac_srcdir/configure.gnu" --help=recursive
    elif test -f "$ac_srcdir/configure"; then
      echo &&
      $SHELL "$ac_srcdir/configure" --help=recursive
    else
      $as_echo "$as_me: WARNING: no configuration information is in $ac_dir" >&2
    fi || ac_status=$?
    cd "$ac_pwd" || { ac_status=$?; break; }
  done
fi

test -n "$ac_init_help" && exit $ac_status
if $ac_init_version; then
  cat <<\_ACEOF
configure
generated by GNU Autoconf 2.69

Copyright (C) 2012 Free Software Foundation, Inc.
This configure script is free software; the Free Software Foundation
gives unlimited permission to copy, distribute and modify it.
_ACEOF
  exit
fi

## ------------------------ ##
## Autoconf initialization. ##
## ------------------------ ##

# ac_fn_c_try_compile LINENO
# --------------------------
# Try to compile conftest.$ac_ext, and return whether this succeeded.
ac_fn_c_try_compile ()
{
  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
  rm -f conftest.$ac_objext
  if { { ac_try="$ac_compile"
case "(($ac_try" in
  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
  *) ac_try_echo=$ac_try;;
esac
eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
$as_echo "$ac_try_echo"; } >&5
  (eval "$ac_compile") 2>conftest.err
  ac_status=$?
  if test -s conftest.err; then
    grep -v '^ *+' conftest.err >conftest.er1
    cat conftest.er1 >&5
    mv -f conftest.er1 conftest.err
  fi
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; } && {
	 test -z "$ac_c_werror_flag" ||
	 test ! -s conftest.err
       } && test -s conftest.$ac_objext; then :
  ac_retval=0
else
  $as_echo "$as_me: failed program was:" >&5
sed 's/^/| /' conftest.$ac_ext >&5

	ac_retval=1
fi
  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
  as_fn_set_status $ac_retval

} # ac_fn_c_try_compile

# ac_fn_c_try_cpp LINENO
# ----------------------
# Try to preprocess conftest.$ac_ext, and return whether this succeeded.
ac_fn_c_try_cpp ()
{
  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
  if { { ac_try="$ac_cpp conftest.$ac_ext"
case "(($ac_try" in
  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
  *) ac_try_echo=$ac_try;;
esac
eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
$as_echo "$ac_try_echo"; } >&5
  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.err
  ac_status=$?
  if test -s conftest.err; then
    grep -v '^ *+' conftest.err >conftest.er1
    cat conftest.er1 >&5
    mv -f conftest.er1 conftest.err
  fi
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; } > conftest.i && {
	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
	 test ! -s conftest.err
       }; then :
  ac_retval=0
else
  $as_echo "$as_me: failed program was:" >&5
sed 's/^/| /' conftest.$ac_ext >&5

    ac_retval=1
fi
  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
  as_fn_set_status $ac_retval

} # ac_fn_c_try_cpp

# ac_fn_c_check_header_mongrel LINENO HEADER VAR INCLUDES
# -------------------------------------------------------
# Tests whether HEADER exists, giving a warning if it cannot be compiled using
# the include files in INCLUDES and setting the cache variable VAR
# accordingly.
ac_fn_c_check_header_mongrel ()
{
  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
  if eval \${$3+:} false; then :
  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
$as_echo_n "checking for $2... " >&6; }
if eval \${$3+:} false; then :
  $as_echo_n "(cached) " >&6
fi
eval ac_res=\$$3
	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
$as_echo "$ac_res" >&6; }
else
  # Is the header compilable?
{ $as_echo "$as_me:${as_lineno-$LINENO}: checking $2 usability" >&5
$as_echo_n "checking $2 usability... " >&6; }
cat confdefs.h - <<_ACEOF >conftest.$ac_ext
/* end confdefs.h.  */
$4
#include <$2>
_ACEOF
if ac_fn_c_try_compile "$LINENO"; then :
  ac_header_compiler=yes
else
  ac_header_compiler=no
fi
rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_header_compiler" >&5
$as_echo "$ac_header_compiler" >&6; }

# Is the header present?
{ $as_echo "$as_me:${as_lineno-$LINENO}: checking $2 presence" >&5
$as_echo_n "checking $2 presence... " >&6; }
cat confdefs.h - <<_ACEOF >conftest.$ac_ext
/* end confdefs.h.  */
#include <$2>
_ACEOF
if ac_fn_c_try_cpp "$LINENO"; then :
  ac_header_preproc=yes
else
  ac_header_preproc=no
fi
rm -f conftest.err conftest.i conftest.$ac_ext
{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_header_preproc" >&5
$as_echo "$ac_header_preproc" >&6; }

# So?  What about this header?
case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in #((
  yes:no: )
    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: accepted by the compiler, rejected by the preprocessor!" >&5
$as_echo "$as_me: WARNING: $2: accepted by the compiler, rejected by the preprocessor!" >&2;}
    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: proceeding with the compiler's result" >&5
$as_echo "$as_me: WARNING: $2: proceeding with the compiler's result" >&2;}
    ;;
  no:yes:* )
    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: present but cannot be compiled" >&5
$as_echo "$as_me: WARNING: $2: present but cannot be compiled" >&2;}
    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2:     check for missing prerequisite headers?" >&5
$as_echo "$as_me: WARNING: $2:     check for missing prerequisite headers?" >&2;}
    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: see the Autoconf documentation" >&5
$as_echo "$as_me: WARNING: $2: see the Autoconf documentation" >&2;}
    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2:     section \"Present But Cannot Be Compiled\"" >&5
$as_echo "$as_me: WARNING: $2:     section \"Present But Cannot Be Compiled\"" >&2;}
    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: proceeding with the compiler's result" >&5
$as_echo "$as_me: WARNING: $2: proceeding with the compiler's result" >&2;}
    ;;
esac
  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
$as_echo_n "checking for $2... " >&6; }
if eval \${$3+:} false; then :
  $as_echo_n "(cached) " >&6
else
  eval "$3=\$ac_header_compiler"
fi
eval ac_res=\$$3
	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
$as_echo "$ac_res" >&6; }
fi
  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno

} # ac_fn_c_check_header_mongrel

# ac_fn_c_try_run LINENO
# ----------------------
# Try to link conftest.$ac_ext, and return whether this succeeded. Assumes
# that executables *can* be run.
ac_fn_c_try_run ()
{
  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
  if { { ac_try="$ac_link"
case "(($ac_try" in
  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
  *) ac_try_echo=$ac_try;;
esac
eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
$as_echo "$ac_try_echo"; } >&5
  (eval "$ac_link") 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; } && { ac_try='./conftest$ac_exeext'
  { { case "(($ac_try" in
  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
  *) ac_try_echo=$ac_try;;
esac
eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
$as_echo "$ac_try_echo"; } >&5
  (eval "$ac_try") 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }; }; then :
  ac_retval=0
else
  $as_echo "$as_me: program exited with status $ac_status" >&5
       $as_echo "$as_me: failed program was:" >&5
sed 's/^/| /' conftest.$ac_ext >&5

       ac_retval=$ac_status
fi
  rm -rf conftest.dSYM conftest_ipa8_conftest.oo
  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
  as_fn_set_status $ac_retval

} # ac_fn_c_try_run

# ac_fn_c_check_header_compile LINENO HEADER VAR INCLUDES
# -------------------------------------------------------
# Tests whether HEADER exists and can be compiled using the include files in
# INCLUDES, setting the cache variable VAR accordingly.
ac_fn_c_check_header_compile ()
{
  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
$as_echo_n "checking for $2... " >&6; }
if eval \${$3+:} false; then :
  $as_echo_n "(cached) " >&6
else
  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
/* end confdefs.h.  */
$4
#include <$2>
_ACEOF
if ac_fn_c_try_compile "$LINENO"; then :
  eval "$3=yes"
else
  eval "$3=no"
fi
rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
fi
eval ac_res=\$$3
	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
$as_echo "$ac_res" >&6; }
  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno

} # ac_fn_c_check_header_compile

# ac_fn_c_try_link LINENO
# -----------------------
# Try to link conftest.$ac_ext, and return whether this succeeded.
ac_fn_c_try_link ()
{
  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
  rm -f conftest.$ac_objext conftest$ac_exeext
  if { { ac_try="$ac_link"
case "(($ac_try" in
  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
  *) ac_try_echo=$ac_try;;
esac
eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
$as_echo "$ac_try_echo"; } >&5
  (eval "$ac_link") 2>conftest.err
  ac_status=$?
  if test -s conftest.err; then
    grep -v '^ *+' conftest.err >conftest.er1
    cat conftest.er1 >&5
    mv -f conftest.er1 conftest.err
  fi
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; } && {
	 test -z "$ac_c_werror_flag" ||
	 test ! -s conftest.err
       } && test -s conftest$ac_exeext && {
	 test "$cross_compiling" = yes ||
	 test -x conftest$ac_exeext
       }; then :
  ac_retval=0
else
  $as_echo "$as_me: failed program was:" >&5
sed 's/^/| /' conftest.$ac_ext >&5

	ac_retval=1
fi
  # Delete the IPA/IPO (Inter Procedural Analysis/Optimization) information
  # created by the PGI compiler (conftest_ipa8_conftest.oo), as it would
  # interfere with the next link command; also delete a directory that is
  # left behind by Apple's compiler.  We do this before executing the actions.
  rm -rf conftest.dSYM conftest_ipa8_conftest.oo
  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
  as_fn_set_status $ac_retval

} # ac_fn_c_try_link
cat >config.log <<_ACEOF
This file contains any messages produced by compilers while
running configure, to aid debugging if configure makes a mistake.

It was created by $as_me, which was
generated by GNU Autoconf 2.69.  Invocation command line was

  $ $0 $@

_ACEOF
exec 5>>config.log
{
cat <<_ASUNAME
## --------- ##
## Platform. ##
## --------- ##

hostname = `(hostname || uname -n) 2>/dev/null | sed 1q`
uname -m = `(uname -m) 2>/dev/null || echo unknown`
uname -r = `(uname -r) 2>/dev/null || echo unknown`
uname -s = `(uname -s) 2>/dev/null || echo unknown`
uname -v = `(uname -v) 2>/dev/null || echo unknown`

/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null || echo unknown`
/bin/uname -X     = `(/bin/uname -X) 2>/dev/null     || echo unknown`

/bin/arch              = `(/bin/arch) 2>/dev/null              || echo unknown`
/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null       || echo unknown`
/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null || echo unknown`
/usr/bin/hostinfo      = `(/usr/bin/hostinfo) 2>/dev/null      || echo unknown`
/bin/machine           = `(/bin/machine) 2>/dev/null           || echo unknown`
/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null       || echo unknown`
/bin/universe          = `(/bin/universe) 2>/dev/null          || echo unknown`

_ASUNAME

as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
    $as_echo "PATH: $as_dir"
  done
IFS=$as_save_IFS

} >&5

cat >&5 <<_ACEOF


## ----------- ##
## Core tests. ##
## ----------- ##

_ACEOF


# Keep a trace of the command line.
# Strip out --no-create and --no-recursion so they do not pile up.
# Strip out --silent because we don't want to record it for future runs.
# Also quote any args containing shell meta-characters.
# Make two passes to allow for proper duplicate-argument suppression.
ac_configure_args=
ac_configure_args0=
ac_configure_args1=
ac_must_keep_next=false
for ac_pass in 1 2
do
  for ac_arg
  do
    case $ac_arg in
    -no-create | --no-c* | -n | -no-recursion | --no-r*) continue ;;
    -q | -quiet | --quiet | --quie | --qui | --qu | --q \
    | -silent | --silent | --silen | --sile | --sil)
      continue ;;
    *\'*)
      ac_arg=`$as_echo "$ac_arg" | sed "s/'/'\\\\\\\\''/g"` ;;
    esac
    case $ac_pass in
    1) as_fn_append ac_configure_args0 " '$ac_arg'" ;;
    2)
      as_fn_append ac_configure_args1 " '$ac_arg'"
      if test $ac_must_keep_next = true; then
	ac_must_keep_next=false # Got value, back to normal.
      else
	case $ac_arg in
	  *=* | --config-cache | -C | -disable-* | --disable-* \
	  | -enable-* | --enable-* | -gas | --g* | -nfp | --nf* \
	  | -q | -quiet | --q* | -silent | --sil* | -v | -verb* \
	  | -with-* | --with-* | -without-* | --without-* | --x)
	    case "$ac_configure_args0 " in
	      "$ac_configure_args1"*" '$ac_arg' "* ) continue ;;
	    esac
	    ;;
	  -* ) ac_must_keep_next=true ;;
	esac
      fi
      as_fn_append ac_configure_args " '$ac_arg'"
      ;;
    esac
  done
done
{ ac_configure_args0=; unset ac_configure_args0;}
{ ac_configure_args1=; unset ac_configure_args1;}

# When interrupted or exit'd, cleanup temporary files, and complete
# config.log.  We remove comments because anyway the quotes in there
# would cause problems or look ugly.
# WARNING: Use '\'' to represent an apostrophe within the trap.
# WARNING: Do not start the trap code with a newline, due to a FreeBSD 4.0 bug.
trap 'exit_status=$?
  # Save into config.log some information that might help in debugging.
  {
    echo

    $as_echo "## ---------------- ##
## Cache variables. ##
## ---------------- ##"
    echo
    # The following way of writing the cache mishandles newlines in values,
(
  for ac_var in `(set) 2>&1 | sed -n '\''s/^\([a-zA-Z_][a-zA-Z0-9_]*\)=.*/\1/p'\''`; do
    eval ac_val=\$$ac_var
    case $ac_val in #(
    *${as_nl}*)
      case $ac_var in #(
      *_cv_*) { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline" >&5
$as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
      esac
      case $ac_var in #(
      _ | IFS | as_nl) ;; #(
      BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(
      *) { eval $ac_var=; unset $ac_var;} ;;
      esac ;;
    esac
  done
  (set) 2>&1 |
    case $as_nl`(ac_space='\'' '\''; set) 2>&1` in #(
    *${as_nl}ac_space=\ *)
      sed -n \
	"s/'\''/'\''\\\\'\'''\''/g;
	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\''\\2'\''/p"
      ;; #(
    *)
      sed -n "/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p"
      ;;
    esac |
    sort
)
    echo

    $as_echo "## ----------------- ##
## Output variables. ##
## ----------------- ##"
    echo
    for ac_var in $ac_subst_vars
    do
      eval ac_val=\$$ac_var
      case $ac_val in
      *\'\''*) ac_val=`$as_echo "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
      esac
      $as_echo "$ac_var='\''$ac_val'\''"
    done | sort
    echo

    if test -n "$ac_subst_files"; then
      $as_echo "## ------------------- ##
## File substitutions. ##
## ------------------- ##"
      echo
      for ac_var in $ac_subst_files
      do
	eval ac_val=\$$ac_var
	case $ac_val in
	*\'\''*) ac_val=`$as_echo "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
	esac
	$as_echo "$ac_var='\''$ac_val'\''"
      done | sort
      echo
    fi

    if test -s confdefs.h; then
      $as_echo "## ----------- ##
## confdefs.h. ##
## ----------- ##"
      echo
      cat confdefs.h
      echo
    fi
    test "$ac_signal" != 0 &&
      $as_echo "$as_me: caught signal $ac_signal"
    $as_echo "$as_me: exit $exit_status"
  } >&5
  rm -f core *.core core.conftest.* &&
    rm -f -r conftest* confdefs* conf$$* $ac_clean_files &&
    exit $exit_status
' 0
for ac_signal in 1 2 13 15; do
  trap 'ac_signal='$ac_signal'; as_fn_exit 1' $ac_signal
done
ac_signal=0

# confdefs.h avoids OS command line length limits that DEFS can exceed.
rm -f -r conftest* confdefs.h

$as_echo "/* confdefs.h */" > confdefs.h

# Predefined preprocessor variables.

cat >>confdefs.h <<_ACEOF
#define PACKAGE_NAME "$PACKAGE_NAME"
_ACEOF

cat >>confdefs.h <<_ACEOF
#define PACKAGE_TARNAME "$PACKAGE_TARNAME"
_ACEOF

cat >>confdefs.h <<_ACEOF
#define PACKAGE_VERSION "$PACKAGE_VERSION"
_ACEOF

cat >>confdefs.h <<_ACEOF
#define PACKAGE_STRING "$PACKAGE_STRING"
_ACEOF

cat >>confdefs.h <<_ACEOF
#define PACKAGE_BUGREPORT "$PACKAGE_BUGREPORT"
_ACEOF

cat >>confdefs.h <<_ACEOF
#define PACKAGE_URL "$PACKAGE_URL"
_ACEOF


# Let the site file select an alternate cache file if it wants to.
# Prefer an explicitly selected file to automatically selected ones.
ac_site_file1=NONE
ac_site_file2=NONE
if test -n "$CONFIG_SITE"; then
  # We do not want a PATH search for config.site.
  case $CONFIG_SITE in #((
    -*)  ac_site_file1=./$CONFIG_SITE;;
    */*) ac_site_file1=$CONFIG_SITE;;
    *)   ac_site_file1=./$CONFIG_SITE;;
  esac
elif test "x$prefix" != xNONE; then
  ac_site_file1=$prefix/share/config.site
  ac_site_file2=$prefix/etc/config.site
else
  ac_site_file1=$ac_default_prefix/share/config.site
  ac_site_file2=$ac_default_prefix/etc/config.site
fi
for ac_site_file in "$ac_site_file1" "$ac_site_file2"
do
  test "x$ac_site_file" = xNONE && continue
  if test /dev/null != "$ac_site_file" && test -r "$ac_site_file"; then
    { $as_echo "$as_me:${as_lineno-$LINENO}: loading site script $ac_site_file" >&5
$as_echo "$as_me: loading site script $ac_site_file" >&6;}
    sed 's/^/| /' "$ac_site_file" >&5
    . "$ac_site_file" \
      || { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
as_fn_error $? "failed to load site script $ac_site_file
See \`config.log' for more details" "$LINENO" 5; }
  fi
done

if test -r "$cache_file"; then
  # Some versions of bash will fail to source /dev/null (special files
  # actually), so we avoid doing that.  DJGPP emulates it as a regular file.
  if test /dev/null != "$cache_file" && test -f "$cache_file"; then
    { $as_echo "$as_me:${as_lineno-$LINENO}: loading cache $cache_file" >&5
$as_echo "$as_me: loading cache $cache_file" >&6;}
    case $cache_file in
      [\\/]* | ?:[\\/]* ) . "$cache_file";;
      *)                      . "./$cache_file";;
    esac
  fi
else
  { $as_echo "$as_me:${as_lineno-$LINENO}: creating cache $cache_file" >&5
$as_echo "$as_me: creating cache $cache_file" >&6;}
  >$cache_file
fi

# Check that the precious variables saved in the cache have kept the same
# value.
ac_cache_corrupted=false
for ac_var in $ac_precious_vars; do
  eval ac_old_set=\$ac_cv_env_${ac_var}_set
  eval ac_new_set=\$ac_env_${ac_var}_set
  eval ac_old_val=\$ac_cv_env_${ac_var}_value
  eval ac_new_val=\$ac_env_${ac_var}_value
  case $ac_old_set,$ac_new_set in
    set,)
      { $as_echo "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&5
$as_echo "$as_me: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&2;}
      ac_cache_corrupted=: ;;
    ,set)
      { $as_echo "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' was not set in the previous run" >&5
$as_echo "$as_me: error: \`$ac_var' was not set in the previous run" >&2;}
      ac_cache_corrupted=: ;;
    ,);;
    *)
      if test "x$ac_old_val" != "x$ac_new_val"; then
	# differences in whitespace do not lead to failure.
	ac_old_val_w=`echo x $ac_old_val`
	ac_new_val_w=`echo x $ac_new_val`
	if test "$ac_old_val_w" != "$ac_new_val_w"; then
	  { $as_echo "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' has changed since the previous run:" >&5
$as_echo "$as_me: error: \`$ac_var' has changed since the previous run:" >&2;}
	  ac_cache_corrupted=:
	else
	  { $as_echo "$as_me:${as_lineno-$LINENO}: warning: ignoring whitespace changes in \`$ac_var' since the previous run:" >&5
$as_echo "$as_me: warning: ignoring whitespace changes in \`$ac_var' since the previous run:" >&2;}
	  eval $ac_var=\$ac_old_val
	fi
	{ $as_echo "$as_me:${as_lineno-$LINENO}:   former value:  \`$ac_old_val'" >&5
$as_echo "$as_me:   former value:  \`$ac_old_val'" >&2;}
	{ $as_echo "$as_me:${as_lineno-$LINENO}:   current value: \`$ac_new_val'" >&5
$as_echo "$as_me:   current value: \`$ac_new_val'" >&2;}
      fi;;
  esac
  # Pass precious variables to config.status.
  if test "$ac_new_set" = set; then
    case $ac_new_val in
    *\'*) ac_arg=$ac_var=`$as_echo "$ac_new_val" | sed "s/'/'\\\\\\\\''/g"` ;;
    *) ac_arg=$ac_var=$ac_new_val ;;
    esac
    case " $ac_configure_args " in
      *" '$ac_arg' "*) ;; # Avoid dups.  Use of quotes ensures accuracy.
      *) as_fn_append ac_configure_args " '$ac_arg'" ;;
    esac
  fi
done
if $ac_cache_corrupted; then
  { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
  { $as_echo "$as_me:${as_lineno-$LINENO}: error: changes in the environment can compromise the build" >&5
$as_echo "$as_me: error: changes in the environment can compromise the build" >&2;}
  as_fn_error $? "run \`make distclean' and/or \`rm $cache_file' and start over" "$LINENO" 5
fi
## -------------------- ##
## Main body of script. ##
## -------------------- ##

ac_ext=c
ac_cpp='$CPP $CPPFLAGS'
ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
ac_compiler_gnu=$ac_cv_c_compiler_gnu




ac_aux_dir=
for ac_dir in config-aux "$srcdir"/config-aux; do
  if test -f "$ac_dir/install-sh"; then
    ac_aux_dir=$ac_dir
    ac_install_sh="$ac_aux_dir/install-sh -c"
    break
  elif test -f "$ac_dir/install.sh"; then
    ac_aux_dir=$ac_dir
    ac_install_sh="$ac_aux_dir/install.sh -c"
    break
  elif test -f "$ac_dir/shtool"; then
    ac_aux_dir=$ac_dir
    ac_install_sh="$ac_aux_dir/shtool install -c"
    break
  fi
done
if test -z "$ac_aux_dir"; then
  as_fn_error $? "cannot find install-sh, install.sh, or shtool in config-aux \"$srcdir\"/config-aux" "$LINENO" 5
fi

# These three variables are undocumented and unsupported,
# and are intended to be withdrawn in a future Autoconf release.
# They can cause serious problems if a builder's source tree is in a directory
# whose full name contains unusual characters.
ac_config_guess="$SHELL $ac_aux_dir/config.guess"  # Please don't use this var.
ac_config_sub="$SHELL $ac_aux_dir/config.sub"  # Please don't use this var.
ac_configure="$SHELL $ac_aux_dir/configure"  # Please don't use this var.



# Make sure we can run config.sub.
$SHELL "$ac_aux_dir/config.sub" sun4 >/dev/null 2>&1 ||
  as_fn_error $? "cannot run $SHELL $ac_aux_dir/config.sub" "$LINENO" 5

{ $as_echo "$as_me:${as_lineno-$LINENO}: checking build system type" >&5
$as_echo_n "checking build system type... " >&6; }
if ${ac_cv_build+:} false; then :
  $as_echo_n "(cached) " >&6
else
  ac_build_alias=$build_alias
test "x$ac_build_alias" = x &&
  ac_build_alias=`$SHELL "$ac_aux_dir/config.guess"`
test "x$ac_build_alias" = x &&
  as_fn_error $? "cannot guess build type; you must specify one" "$LINENO" 5
ac_cv_build=`$SHELL "$ac_aux_dir/config.sub" $ac_build_alias` ||
  as_fn_error $? "$SHELL $ac_aux_dir/config.sub $ac_build_alias failed" "$LINENO" 5

fi
{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_build" >&5
$as_echo "$ac_cv_build" >&6; }
case $ac_cv_build in
*-*-*) ;;
*) as_fn_error $? "invalid value of canonical build" "$LINENO" 5;;
esac
build=$ac_cv_build
ac_save_IFS=$IFS; IFS='-'
set x $ac_cv_build
shift
build_cpu=$1
build_vendor=$2
shift; shift
# Remember, the first character of IFS is used to create $*,
# except with old shells:
build_os=$*
IFS=$ac_save_IFS
case $build_os in *\ *) build_os=`echo "$build_os" | sed 's/ /-/g'`;; esac


{ $as_echo "$as_me:${as_lineno-$LINENO}: checking host system type" >&5
$as_echo_n "checking host system type... " >&6; }
if ${ac_cv_host+:} false; then :
  $as_echo_n "(cached) " >&6
else
  if test "x$host_alias" = x; then
  ac_cv_host=$ac_cv_build
else
  ac_cv_host=`$SHELL "$ac_aux_dir/config.sub" $host_alias` ||
    as_fn_error $? "$SHELL $ac_aux_dir/config.sub $host_alias failed" "$LINENO" 5
fi

fi
{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_host" >&5
$as_echo "$ac_cv_host" >&6; }
case $ac_cv_host in
*-*-*) ;;
*) as_fn_error $? "invalid value of canonical host" "$LINENO" 5;;
esac
host=$ac_cv_host
ac_save_IFS=$IFS; IFS='-'
set x $ac_cv_host
shift
host_cpu=$1
host_vendor=$2
shift; shift
# Remember, the first character of IFS is used to create $*,
# except with old shells:
host_os=$*
IFS=$ac_save_IFS
case $host_os in *\ *) host_os=`echo "$host_os" | sed 's/ /-/g'`;; esac



ac_ext=c
ac_cpp='$CPP $CPPFLAGS'
ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
ac_compiler_gnu=$ac_cv_c_compiler_gnu
if test -n "$ac_tool_prefix"; then
  # Extract the first word of "${ac_tool_prefix}gcc", so it can be a program name with args.
set dummy ${ac_tool_prefix}gcc; ac_word=$2
{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
$as_echo_n "checking for $ac_word... " >&6; }
if ${ac_cv_prog_CC+:} false; then :
  $as_echo_n "(cached) " >&6
else
  if test -n "$CC"; then
  ac_cv_prog_CC="$CC" # Let the user override the test.
else
as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
    for ac_exec_ext in '' $ac_executable_extensions; do
  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
    ac_cv_prog_CC="${ac_tool_prefix}gcc"
    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
    break 2
  fi
done
  done
IFS=$as_save_IFS

fi
fi
CC=$ac_cv_prog_CC
if test -n "$CC"; then
  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
$as_echo "$CC" >&6; }
else
  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
$as_echo "no" >&6; }
fi


fi
if test -z "$ac_cv_prog_CC"; then
  ac_ct_CC=$CC
  # Extract the first word of "gcc", so it can be a program name with args.
set dummy gcc; ac_word=$2
{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
$as_echo_n "checking for $ac_word... " >&6; }
if ${ac_cv_prog_ac_ct_CC+:} false; then :
  $as_echo_n "(cached) " >&6
else
  if test -n "$ac_ct_CC"; then
  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
else
as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
    for ac_exec_ext in '' $ac_executable_extensions; do
  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
    ac_cv_prog_ac_ct_CC="gcc"
    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
    break 2
  fi
done
  done
IFS=$as_save_IFS

fi
fi
ac_ct_CC=$ac_cv_prog_ac_ct_CC
if test -n "$ac_ct_CC"; then
  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC" >&5
$as_echo "$ac_ct_CC" >&6; }
else
  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
$as_echo "no" >&6; }
fi

  if test "x$ac_ct_CC" = x; then
    CC=""
  else
    case $cross_compiling:$ac_tool_warned in
yes:)
{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
ac_tool_warned=yes ;;
esac
    CC=$ac_ct_CC
  fi
else
  CC="$ac_cv_prog_CC"
fi

if test -z "$CC"; then
          if test -n "$ac_tool_prefix"; then
    # Extract the first word of "${ac_tool_prefix}cc", so it can be a program name with args.
set dummy ${ac_tool_prefix}cc; ac_word=$2
{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
$as_echo_n "checking for $ac_word... " >&6; }
if ${ac_cv_prog_CC+:} false; then :
  $as_echo_n "(cached) " >&6
else
  if test -n "$CC"; then
  ac_cv_prog_CC="$CC" # Let the user override the test.
else
as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
    for ac_exec_ext in '' $ac_executable_extensions; do
  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
    ac_cv_prog_CC="${ac_tool_prefix}cc"
    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
    break 2
  fi
done
  done
IFS=$as_save_IFS

fi
fi
CC=$ac_cv_prog_CC
if test -n "$CC"; then
  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
$as_echo "$CC" >&6; }
else
  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
$as_echo "no" >&6; }
fi


  fi
fi
if test -z "$CC"; then
  # Extract the first word of "cc", so it can be a program name with args.
set dummy cc; ac_word=$2
{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
$as_echo_n "checking for $ac_word... " >&6; }
if ${ac_cv_prog_CC+:} false; then :
  $as_echo_n "(cached) " >&6
else
  if test -n "$CC"; then
  ac_cv_prog_CC="$CC" # Let the user override the test.
else
  ac_prog_rejected=no
as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
    for ac_exec_ext in '' $ac_executable_extensions; do
  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
    if test "$as_dir/$ac_word$ac_exec_ext" = "/usr/ucb/cc"; then
       ac_prog_rejected=yes
       continue
     fi
    ac_cv_prog_CC="cc"
    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
    break 2
  fi
done
  done
IFS=$as_save_IFS

if test $ac_prog_rejected = yes; then
  # We found a bogon in the path, so make sure we never use it.
  set dummy $ac_cv_prog_CC
  shift
  if test $# != 0; then
    # We chose a different compiler from the bogus one.
    # However, it has the same basename, so the bogon will be chosen
    # first if we set CC to just the basename; use the full file name.
    shift
    ac_cv_prog_CC="$as_dir/$ac_word${1+' '}$@"
  fi
fi
fi
fi
CC=$ac_cv_prog_CC
if test -n "$CC"; then
  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
$as_echo "$CC" >&6; }
else
  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
$as_echo "no" >&6; }
fi


fi
if test -z "$CC"; then
  if test -n "$ac_tool_prefix"; then
  for ac_prog in cl.exe
  do
    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
set dummy $ac_tool_prefix$ac_prog; ac_word=$2
{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
$as_echo_n "checking for $ac_word... " >&6; }
if ${ac_cv_prog_CC+:} false; then :
  $as_echo_n "(cached) " >&6
else
  if test -n "$CC"; then
  ac_cv_prog_CC="$CC" # Let the user override the test.
else
as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
    for ac_exec_ext in '' $ac_executable_extensions; do
  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
    ac_cv_prog_CC="$ac_tool_prefix$ac_prog"
    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
    break 2
  fi
done
  done
IFS=$as_save_IFS

fi
fi
CC=$ac_cv_prog_CC
if test -n "$CC"; then
  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
$as_echo "$CC" >&6; }
else
  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
$as_echo "no" >&6; }
fi


    test -n "$CC" && break
  done
fi
if test -z "$CC"; then
  ac_ct_CC=$CC
  for ac_prog in cl.exe
do
  # Extract the first word of "$ac_prog", so it can be a program name with args.
set dummy $ac_prog; ac_word=$2
{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
$as_echo_n "checking for $ac_word... " >&6; }
if ${ac_cv_prog_ac_ct_CC+:} false; then :
  $as_echo_n "(cached) " >&6
else
  if test -n "$ac_ct_CC"; then
  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
else
as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
    for ac_exec_ext in '' $ac_executable_extensions; do
  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
    ac_cv_prog_ac_ct_CC="$ac_prog"
    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
    break 2
  fi
done
  done
IFS=$as_save_IFS

fi
fi
ac_ct_CC=$ac_cv_prog_ac_ct_CC
if test -n "$ac_ct_CC"; then
  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC" >&5
$as_echo "$ac_ct_CC" >&6; }
else
  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
$as_echo "no" >&6; }
fi


  test -n "$ac_ct_CC" && break
done

  if test "x$ac_ct_CC" = x; then
    CC=""
  else
    case $cross_compiling:$ac_tool_warned in
yes:)
{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
ac_tool_warned=yes ;;
esac
    CC=$ac_ct_CC
  fi
fi

fi


test -z "$CC" && { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
as_fn_error $? "no acceptable C compiler found in \$PATH
See \`config.log' for more details" "$LINENO" 5; }

# Provide some information about the compiler.
$as_echo "$as_me:${as_lineno-$LINENO}: checking for C compiler version" >&5
set X $ac_compile
ac_compiler=$2
for ac_option in --version -v -V -qversion; do
  { { ac_try="$ac_compiler $ac_option >&5"
case "(($ac_try" in
  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
  *) ac_try_echo=$ac_try;;
esac
eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
$as_echo "$ac_try_echo"; } >&5
  (eval "$ac_compiler $ac_option >&5") 2>conftest.err
  ac_status=$?
  if test -s conftest.err; then
    sed '10a\
... rest of stderr output deleted ...
         10q' conftest.err >conftest.er1
    cat conftest.er1 >&5
  fi
  rm -f conftest.er1 conftest.err
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }
done

cat confdefs.h - <<_ACEOF >conftest.$ac_ext
/* end confdefs.h.  */

int
main ()
{

  ;
  return 0;
}
_ACEOF
ac_clean_files_save=$ac_clean_files
ac_clean_files="$ac_clean_files a.out a.out.dSYM a.exe b.out"
# Try to create an executable without -o first, disregard a.out.
# It will help us diagnose broken compilers, and finding out an intuition
# of exeext.
{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the C compiler works" >&5
$as_echo_n "checking whether the C compiler works... " >&6; }
ac_link_default=`$as_echo "$ac_link" | sed 's/ -o *conftest[^ ]*//'`

# The possible output files:
ac_files="a.out conftest.exe conftest a.exe a_out.exe b.out conftest.*"

ac_rmfiles=
for ac_file in $ac_files
do
  case $ac_file in
    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj ) ;;
    * ) ac_rmfiles="$ac_rmfiles $ac_file";;
  esac
done
rm -f $ac_rmfiles

if { { ac_try="$ac_link_default"
case "(($ac_try" in
  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
  *) ac_try_echo=$ac_try;;
esac
eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
$as_echo "$ac_try_echo"; } >&5
  (eval "$ac_link_default") 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }; then :
  # Autoconf-2.13 could set the ac_cv_exeext variable to `no'.
# So ignore a value of `no', otherwise this would lead to `EXEEXT = no'
# in a Makefile.  We should not override ac_cv_exeext if it was cached,
# so that the user can short-circuit this test for compilers unknown to
# Autoconf.
for ac_file in $ac_files ''
do
  test -f "$ac_file" || continue
  case $ac_file in
    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj )
	;;
    [ab].out )
	# We found the default executable, but exeext='' is most
	# certainly right.
	break;;
    *.* )
	if test "${ac_cv_exeext+set}" = set && test "$ac_cv_exeext" != no;
	then :; else
	   ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
	fi
	# We set ac_cv_exeext here because the later test for it is not
	# safe: cross compilers may not add the suffix if given an `-o'
	# argument, so we may need to know it at that point already.
	# Even if this section looks crufty: it has the advantage of
	# actually working.
	break;;
    * )
	break;;
  esac
done
test "$ac_cv_exeext" = no && ac_cv_exeext=

else
  ac_file=''
fi
if test -z "$ac_file"; then :
  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
$as_echo "no" >&6; }
$as_echo "$as_me: failed program was:" >&5
sed 's/^/| /' conftest.$ac_ext >&5

{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
as_fn_error 77 "C compiler cannot create executables
See \`config.log' for more details" "$LINENO" 5; }
else
  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
$as_echo "yes" >&6; }
fi
{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for C compiler default output file name" >&5
$as_echo_n "checking for C compiler default output file name... " >&6; }
{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_file" >&5
$as_echo "$ac_file" >&6; }
ac_exeext=$ac_cv_exeext

rm -f -r a.out a.out.dSYM a.exe conftest$ac_cv_exeext b.out
ac_clean_files=$ac_clean_files_save
{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for suffix of executables" >&5
$as_echo_n "checking for suffix of executables... " >&6; }
if { { ac_try="$ac_link"
case "(($ac_try" in
  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
  *) ac_try_echo=$ac_try;;
esac
eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
$as_echo "$ac_try_echo"; } >&5
  (eval "$ac_link") 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }; then :
  # If both `conftest.exe' and `conftest' are `present' (well, observable)
# catch `conftest.exe'.  For instance with Cygwin, `ls conftest' will
# work properly (i.e., refer to `conftest.exe'), while it won't with
# `rm'.
for ac_file in conftest.exe conftest conftest.*; do
  test -f "$ac_file" || continue
  case $ac_file in
    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj ) ;;
    *.* ) ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
	  break;;
    * ) break;;
  esac
done
else
  { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
as_fn_error $? "cannot compute suffix of executables: cannot compile and link
See \`config.log' for more details" "$LINENO" 5; }
fi
rm -f conftest conftest$ac_cv_exeext
{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_exeext" >&5
$as_echo "$ac_cv_exeext" >&6; }

rm -f conftest.$ac_ext
EXEEXT=$ac_cv_exeext
ac_exeext=$EXEEXT
cat confdefs.h - <<_ACEOF >conftest.$ac_ext
/* end confdefs.h.  */
#include <stdio.h>
int
main ()
{
FILE *f = fopen ("conftest.out", "w");
 return ferror (f) || fclose (f) != 0;

  ;
  return 0;
}
_ACEOF
ac_clean_files="$ac_clean_files conftest.out"
# Check that the compiler produces executables we can run.  If not, either
# the compiler is broken, or we cross compile.
{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are cross compiling" >&5
$as_echo_n "checking whether we are cross compiling... " >&6; }
if test "$cross_compiling" != yes; then
  { { ac_try="$ac_link"
case "(($ac_try" in
  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
  *) ac_try_echo=$ac_try;;
esac
eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
$as_echo "$ac_try_echo"; } >&5
  (eval "$ac_link") 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }
  if { ac_try='./conftest$ac_cv_exeext'
  { { case "(($ac_try" in
  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
  *) ac_try_echo=$ac_try;;
esac
eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
$as_echo "$ac_try_echo"; } >&5
  (eval "$ac_try") 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }; }; then
    cross_compiling=no
  else
    if test "$cross_compiling" = maybe; then
	cross_compiling=yes
    else
	{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
as_fn_error $? "cannot run C compiled programs.
If you meant to cross compile, use \`--host'.
See \`config.log' for more details" "$LINENO" 5; }
    fi
  fi
fi
{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $cross_compiling" >&5
$as_echo "$cross_compiling" >&6; }

rm -f conftest.$ac_ext conftest$ac_cv_exeext conftest.out
ac_clean_files=$ac_clean_files_save
{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for suffix of object files" >&5
$as_echo_n "checking for suffix of object files... " >&6; }
if ${ac_cv_objext+:} false; then :
  $as_echo_n "(cached) " >&6
else
  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
/* end confdefs.h.  */

int
main ()
{

  ;
  return 0;
}
_ACEOF
rm -f conftest.o conftest.obj
if { { ac_try="$ac_compile"
case "(($ac_try" in
  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
  *) ac_try_echo=$ac_try;;
esac
eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
$as_echo "$ac_try_echo"; } >&5
  (eval "$ac_compile") 2>&5
  ac_status=$?
  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
  test $ac_status = 0; }; then :
  for ac_file in conftest.o conftest.obj conftest.*; do
  test -f "$ac_file" || continue;
  case $ac_file in
    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM ) ;;
    *) ac_cv_objext=`expr "$ac_file" : '.*\.\(.*\)'`
       break;;
  esac
done
else
  $as_echo "$as_me: failed program was:" >&5
sed 's/^/| /' conftest.$ac_ext >&5

{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
as_fn_error $? "cannot compute suffix of object files: cannot compile
See \`config.log' for more details" "$LINENO" 5; }
fi
rm -f conftest.$ac_cv_objext conftest.$ac_ext
fi
{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_objext" >&5
$as_echo "$ac_cv_objext" >&6; }
OBJEXT=$ac_cv_objext
ac_objext=$OBJEXT
{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are using the GNU C compiler" >&5
$as_echo_n "checking whether we are using the GNU C compiler... " >&6; }
if ${ac_cv_c_compiler_gnu+:} false; then :
  $as_echo_n "(cached) " >&6
else
  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
/* end confdefs.h.  */

int
main ()
{
#ifndef __GNUC__
       choke me
#endif

  ;
  return 0;
}
_ACEOF
if ac_fn_c_try_compile "$LINENO"; then :
  ac_compiler_gnu=yes
else
  ac_compiler_gnu=no
fi
rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
ac_cv_c_compiler_gnu=$ac_compiler_gnu

fi
{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_compiler_gnu" >&5
$as_echo "$ac_cv_c_compiler_gnu" >&6; }
if test $ac_compiler_gnu = yes; then
  GCC=yes
else
  GCC=
fi
ac_test_CFLAGS=${CFLAGS+set}
ac_save_CFLAGS=$CFLAGS
{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CC accepts -g" >&5
$as_echo_n "checking whether $CC accepts -g... " >&6; }
if ${ac_cv_prog_cc_g+:} false; then :
  $as_echo_n "(cached) " >&6
else
  ac_save_c_werror_flag=$ac_c_werror_flag
   ac_c_werror_flag=yes
   ac_cv_prog_cc_g=no
   CFLAGS="-g"
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
/* end confdefs.h.  */

int
main ()
{

  ;
  return 0;
}
_ACEOF
if ac_fn_c_try_compile "$LINENO"; then :
  ac_cv_prog_cc_g=yes
else
  CFLAGS=""
      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
/* end confdefs.h.  */

int
main ()
{

  ;
  return 0;
}
_ACEOF
if ac_fn_c_try_compile "$LINENO"; then :

else
  ac_c_werror_flag=$ac_save_c_werror_flag
	 CFLAGS="-g"
	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
/* end confdefs.h.  */

int
main ()
{

  ;
  return 0;
}
_ACEOF
if ac_fn_c_try_compile "$LINENO"; then :
  ac_cv_prog_cc_g=yes
fi
rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
fi
rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
fi
rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
   ac_c_werror_flag=$ac_save_c_werror_flag
fi
{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_g" >&5
$as_echo "$ac_cv_prog_cc_g" >&6; }
if test "$ac_test_CFLAGS" = set; then
  CFLAGS=$ac_save_CFLAGS
elif test $ac_cv_prog_cc_g = yes; then
  if test "$GCC" = yes; then
    CFLAGS="-g -O2"
  else
    CFLAGS="-g"
  fi
else
  if test "$GCC" = yes; then
    CFLAGS="-O2"
  else
    CFLAGS=
  fi
fi
{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $CC option to accept ISO C89" >&5
$as_echo_n "checking for $CC option to accept ISO C89... " >&6; }
if ${ac_cv_prog_cc_c89+:} false; then :
  $as_echo_n "(cached) " >&6
else
  ac_cv_prog_cc_c89=no
ac_save_CC=$CC
cat confdefs.h - <<_ACEOF >conftest.$ac_ext
/* end confdefs.h.  */
#include <stdarg.h>
#include <stdio.h>
struct stat;
/* Most of the following tests are stolen from RCS 5.7's src/conf.sh.  */
struct buf { int x; };
FILE * (*rcsopen) (struct buf *, struct stat *, int);
static char *e (p, i)
     char **p;
     int i;
{
  return p[i];
}
static char *f (char * (*g) (char **, int), char **p, ...)
{
  char *s;
  va_list v;
  va_start (v,p);
  s = g (p, va_arg (v,int));
  va_end (v);
  return s;
}

/* OSF 4.0 Compaq cc is some sort of almost-ANSI by default.  It has
   function prototypes and stuff, but not '\xHH' hex character constants.
   These don't provoke an error unfortunately, instead are silently treated
   as 'x'.  The following induces an error, until -std is added to get
   proper ANSI mode.  Curiously '\x00'!='x' always comes out true, for an
   array size at least.  It's necessary to write '\x00'==0 to get something
   that's true only with -std.  */
int osf4_cc_array ['\x00' == 0 ? 1 : -1];

/* IBM C 6 for AIX is almost-ANSI by default, but it replaces macro parameters
   inside strings and character constants.  */
#define FOO(x) 'x'
int xlc6_cc_array[FOO(a) == 'x' ? 1 : -1];

int test (int i, double x);
struct s1 {int (*f) (int a);};
struct s2 {int (*f) (double a);};
int pairnames (int, char **, FILE *(*)(struct buf *, struct stat *, int), int, int);
int argc;
char **argv;
int
main ()
{
return f (e, argv, 0) != argv[0]  ||  f (e, argv, 1) != argv[1];
  ;
  return 0;
}
_ACEOF
for ac_arg in '' -qlanglvl=extc89 -qlanglvl=ansi -std \
	-Ae "-Aa -D_HPUX_SOURCE" "-Xc -D__EXTENSIONS__"
do
  CC="$ac_save_CC $ac_arg"
  if ac_fn_c_try_compile "$LINENO"; then :
  ac_cv_prog_cc_c89=$ac_arg
fi
rm -f core conftest.err conftest.$ac_objext
  test "x$ac_cv_prog_cc_c89" != "xno" && break
done
rm -f conftest.$ac_ext
CC=$ac_save_CC

fi
# AC_CACHE_VAL
case "x$ac_cv_prog_cc_c89" in
  x)
    { $as_echo "$as_me:${as_lineno-$LINENO}: result: none needed" >&5
$as_echo "none needed" >&6; } ;;
  xno)
    { $as_echo "$as_me:${as_lineno-$LINENO}: result: unsupported" >&5
$as_echo "unsupported" >&6; } ;;
  *)
    CC="$CC $ac_cv_prog_cc_c89"
    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_c89" >&5
$as_echo "$ac_cv_prog_cc_c89" >&6; } ;;
esac
if test "x$ac_cv_prog_cc_c89" != xno; then :

fi

ac_ext=c
ac_cpp='$CPP $CPPFLAGS'
ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
ac_compiler_gnu=$ac_cv_c_compiler_gnu

if test -n "$ac_tool_prefix"; then
  # Extract the first word of "${ac_tool_prefix}ranlib", so it can be a program name with args.
set dummy ${ac_tool_prefix}ranlib; ac_word=$2
{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
$as_echo_n "checking for $ac_word... " >&6; }
if ${ac_cv_prog_RANLIB+:} false; then :
  $as_echo_n "(cached) " >&6
else
  if test -n "$RANLIB"; then
  ac_cv_prog_RANLIB="$RANLIB" # Let the user override the test.
else
as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
    for ac_exec_ext in '' $ac_executable_extensions; do
  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
    ac_cv_prog_RANLIB="${ac_tool_prefix}ranlib"
    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
    break 2
  fi
done
  done
IFS=$as_save_IFS

fi
fi
RANLIB=$ac_cv_prog_RANLIB
if test -n "$RANLIB"; then
  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $RANLIB" >&5
$as_echo "$RANLIB" >&6; }
else
  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
$as_echo "no" >&6; }
fi


fi
if test -z "$ac_cv_prog_RANLIB"; then
  ac_ct_RANLIB=$RANLIB
  # Extract the first word of "ranlib", so it can be a program name with args.
set dummy ranlib; ac_word=$2
{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
$as_echo_n "checking for $ac_word... " >&6; }
if ${ac_cv_prog_ac_ct_RANLIB+:} false; then :
  $as_echo_n "(cached) " >&6
else
  if test -n "$ac_ct_RANLIB"; then
  ac_cv_prog_ac_ct_RANLIB="$ac_ct_RANLIB" # Let the user override the test.
else
as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
    for ac_exec_ext in '' $ac_executable_extensions; do
  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
    ac_cv_prog_ac_ct_RANLIB="ranlib"
    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
    break 2
  fi
done
  done
IFS=$as_save_IFS

fi
fi
ac_ct_RANLIB=$ac_cv_prog_ac_ct_RANLIB
if test -n "$ac_ct_RANLIB"; then
  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_RANLIB" >&5
$as_echo "$ac_ct_RANLIB" >&6; }
else
  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
$as_echo "no" >&6; }
fi

  if test "x$ac_ct_RANLIB" = x; then
    RANLIB=":"
  else
    case $cross_compiling:$ac_tool_warned in
yes:)
{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
ac_tool_warned=yes ;;
esac
    RANLIB=$ac_ct_RANLIB
  fi
else
  RANLIB="$ac_cv_prog_RANLIB"
fi

if test -n "$ac_tool_prefix"; then
  # Extract the first word of "${ac_tool_prefix}ar", so it can be a program name with args.
set dummy ${ac_tool_prefix}ar; ac_word=$2
{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
$as_echo_n "checking for $ac_word... " >&6; }
if ${ac_cv_prog_AR+:} false; then :
  $as_echo_n "(cached) " >&6
else
  if test -n "$AR"; then
  ac_cv_prog_AR="$AR" # Let the user override the test.
else
as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
    for ac_exec_ext in '' $ac_executable_extensions; do
  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
    ac_cv_prog_AR="${ac_tool_prefix}ar"
    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
    break 2
  fi
done
  done
IFS=$as_save_IFS

fi
fi
AR=$ac_cv_prog_AR
if test -n "$AR"; then
  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $AR" >&5
$as_echo "$AR" >&6; }
else
  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
$as_echo "no" >&6; }
fi


fi
if test -z "$ac_cv_prog_AR"; then
  ac_ct_AR=$AR
  # Extract the first word of "ar", so it can be a program name with args.
set dummy ar; ac_word=$2
{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
$as_echo_n "checking for $ac_word... " >&6; }
if ${ac_cv_prog_ac_ct_AR+:} false; then :
  $as_echo_n "(cached) " >&6
else
  if test -n "$ac_ct_AR"; then
  ac_cv_prog_ac_ct_AR="$ac_ct_AR" # Let the user override the test.
else
as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
    for ac_exec_ext in '' $ac_executable_extensions; do
  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
    ac_cv_prog_ac_ct_AR="ar"
    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
    break 2
  fi
done
  done
IFS=$as_save_IFS

fi
fi
ac_ct_AR=$ac_cv_prog_ac_ct_AR
if test -n "$ac_ct_AR"; then
  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_AR" >&5
$as_echo "$ac_ct_AR" >&6; }
else
  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
$as_echo "no" >&6; }
fi

  if test "x$ac_ct_AR" = x; then
    AR=""
  else
    case $cross_compiling:$ac_tool_warned in
yes:)
{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
ac_tool_warned=yes ;;
esac
    AR=$ac_ct_AR
  fi
else
  AR="$ac_cv_prog_AR"
fi

if test "$AR" = ""; then as_fn_error $? "ar missing" "$LINENO" 5; fi



ac_ext=c
ac_cpp='$CPP $CPPFLAGS'
ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
ac_compiler_gnu=$ac_cv_c_compiler_gnu
{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to run the C preprocessor" >&5
$as_echo_n "checking how to run the C preprocessor... " >&6; }
# On Suns, sometimes $CPP names a directory.
if test -n "$CPP" && test -d "$CPP"; then
  CPP=
fi
if test -z "$CPP"; then
  if ${ac_cv_prog_CPP+:} false; then :
  $as_echo_n "(cached) " >&6
else
      # Double quotes because CPP needs to be expanded
    for CPP in "$CC -E" "$CC -E -traditional-cpp" "/lib/cpp"
    do
      ac_preproc_ok=false
for ac_c_preproc_warn_flag in '' yes
do
  # Use a header file that comes with gcc, so configuring glibc
  # with a fresh cross-compiler works.
  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
  # <limits.h> exists even on freestanding compilers.
  # On the NeXT, cc -E runs the code through the compiler's parser,
  # not just through cpp. "Syntax error" is here to catch this case.
  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
/* end confdefs.h.  */
#ifdef __STDC__
# include <limits.h>
#else
# include <assert.h>
#endif
		     Syntax error
_ACEOF
if ac_fn_c_try_cpp "$LINENO"; then :

else
  # Broken: fails on valid input.
continue
fi
rm -f conftest.err conftest.i conftest.$ac_ext

  # OK, works on sane cases.  Now check whether nonexistent headers
  # can be detected and how.
  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
/* end confdefs.h.  */
#include <ac_nonexistent.h>
_ACEOF
if ac_fn_c_try_cpp "$LINENO"; then :
  # Broken: success on invalid input.
continue
else
  # Passes both tests.
ac_preproc_ok=:
break
fi
rm -f conftest.err conftest.i conftest.$ac_ext

done
# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
rm -f conftest.i conftest.err conftest.$ac_ext
if $ac_preproc_ok; then :
  break
fi

    done
    ac_cv_prog_CPP=$CPP

fi
  CPP=$ac_cv_prog_CPP
else
  ac_cv_prog_CPP=$CPP
fi
{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $CPP" >&5
$as_echo "$CPP" >&6; }
ac_preproc_ok=false
for ac_c_preproc_warn_flag in '' yes
do
  # Use a header file that comes with gcc, so configuring glibc
  # with a fresh cross-compiler works.
  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
  # <limits.h> exists even on freestanding compilers.
  # On the NeXT, cc -E runs the code through the compiler's parser,
  # not just through cpp. "Syntax error" is here to catch this case.
  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
/* end confdefs.h.  */
#ifdef __STDC__
# include <limits.h>
#else
# include <assert.h>
#endif
		     Syntax error
_ACEOF
if ac_fn_c_try_cpp "$LINENO"; then :

else
  # Broken: fails on valid input.
continue
fi
rm -f conftest.err conftest.i conftest.$ac_ext

  # OK, works on sane cases.  Now check whether nonexistent headers
  # can be detected and how.
  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
/* end confdefs.h.  */
#include <ac_nonexistent.h>
_ACEOF
if ac_fn_c_try_cpp "$LINENO"; then :
  # Broken: success on invalid input.
continue
else
  # Passes both tests.
ac_preproc_ok=:
break
fi
rm -f conftest.err conftest.i conftest.$ac_ext

done
# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
rm -f conftest.i conftest.err conftest.$ac_ext
if $ac_preproc_ok; then :

else
  { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
as_fn_error $? "C preprocessor \"$CPP\" fails sanity check
See \`config.log' for more details" "$LINENO" 5; }
fi

ac_ext=c
ac_cpp='$CPP $CPPFLAGS'
ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
ac_compiler_gnu=$ac_cv_c_compiler_gnu


{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for grep that handles long lines and -e" >&5
$as_echo_n "checking for grep that handles long lines and -e... " >&6; }
if ${ac_cv_path_GREP+:} false; then :
  $as_echo_n "(cached) " >&6
else
  if test -z "$GREP"; then
  ac_path_GREP_found=false
  # Loop through the user's path and test for each of PROGNAME-LIST
  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
    for ac_prog in grep ggrep; do
    for ac_exec_ext in '' $ac_executable_extensions; do
      ac_path_GREP="$as_dir/$ac_prog$ac_exec_ext"
      as_fn_executable_p "$ac_path_GREP" || continue
# Check for GNU ac_path_GREP and select it if it is found.
  # Check for GNU $ac_path_GREP
case `"$ac_path_GREP" --version 2>&1` in
*GNU*)
  ac_cv_path_GREP="$ac_path_GREP" ac_path_GREP_found=:;;
*)
  ac_count=0
  $as_echo_n 0123456789 >"conftest.in"
  while :
  do
    cat "conftest.in" "conftest.in" >"conftest.tmp"
    mv "conftest.tmp" "conftest.in"
    cp "conftest.in" "conftest.nl"
    $as_echo 'GREP' >> "conftest.nl"
    "$ac_path_GREP" -e 'GREP$' -e '-(cannot match)-' < "conftest.nl" >"conftest.out" 2>/dev/null || break
    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
    as_fn_arith $ac_count + 1 && ac_count=$as_val
    if test $ac_count -gt ${ac_path_GREP_max-0}; then
      # Best one so far, save it but keep looking for a better one
      ac_cv_path_GREP="$ac_path_GREP"
      ac_path_GREP_max=$ac_count
    fi
    # 10*(2^10) chars as input seems more than enough
    test $ac_count -gt 10 && break
  done
  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
esac

      $ac_path_GREP_found && break 3
    done
  done
  done
IFS=$as_save_IFS
  if test -z "$ac_cv_path_GREP"; then
    as_fn_error $? "no acceptable grep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
  fi
else
  ac_cv_path_GREP=$GREP
fi

fi
{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_GREP" >&5
$as_echo "$ac_cv_path_GREP" >&6; }
 GREP="$ac_cv_path_GREP"


{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for egrep" >&5
$as_echo_n "checking for egrep... " >&6; }
if ${ac_cv_path_EGREP+:} false; then :
  $as_echo_n "(cached) " >&6
else
  if echo a | $GREP -E '(a|b)' >/dev/null 2>&1
   then ac_cv_path_EGREP="$GREP -E"
   else
     if test -z "$EGREP"; then
  ac_path_EGREP_found=false
  # Loop through the user's path and test for each of PROGNAME-LIST
  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
    for ac_prog in egrep; do
    for ac_exec_ext in '' $ac_executable_extensions; do
      ac_path_EGREP="$as_dir/$ac_prog$ac_exec_ext"
      as_fn_executable_p "$ac_path_EGREP" || continue
# Check for GNU ac_path_EGREP and select it if it is found.
  # Check for GNU $ac_path_EGREP
case `"$ac_path_EGREP" --version 2>&1` in
*GNU*)
  ac_cv_path_EGREP="$ac_path_EGREP" ac_path_EGREP_found=:;;
*)
  ac_count=0
  $as_echo_n 0123456789 >"conftest.in"
  while :
  do
    cat "conftest.in" "conftest.in" >"conftest.tmp"
    mv "conftest.tmp" "conftest.in"
    cp "conftest.in" "conftest.nl"
    $as_echo 'EGREP' >> "conftest.nl"
    "$ac_path_EGREP" 'EGREP$' < "conftest.nl" >"conftest.out" 2>/dev/null || break
    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
    as_fn_arith $ac_count + 1 && ac_count=$as_val
    if test $ac_count -gt ${ac_path_EGREP_max-0}; then
      # Best one so far, save it but keep looking for a better one
      ac_cv_path_EGREP="$ac_path_EGREP"
      ac_path_EGREP_max=$ac_count
    fi
    # 10*(2^10) chars as input seems more than enough
    test $ac_count -gt 10 && break
  done
  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
esac

      $ac_path_EGREP_found && break 3
    done
  done
  done
IFS=$as_save_IFS
  if test -z "$ac_cv_path_EGREP"; then
    as_fn_error $? "no acceptable egrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
  fi
else
  ac_cv_path_EGREP=$EGREP
fi

   fi
fi
{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_EGREP" >&5
$as_echo "$ac_cv_path_EGREP" >&6; }
 EGREP="$ac_cv_path_EGREP"


{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ANSI C header files" >&5
$as_echo_n "checking for ANSI C header files... " >&6; }
if ${ac_cv_header_stdc+:} false; then :
  $as_echo_n "(cached) " >&6
else
  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
/* end confdefs.h.  */
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <float.h>

int
main ()
{

  ;
  return 0;
}
_ACEOF
if ac_fn_c_try_compile "$LINENO"; then :
  ac_cv_header_stdc=yes
else
  ac_cv_header_stdc=no
fi
rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext

if test $ac_cv_header_stdc = yes; then
  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
/* end confdefs.h.  */
#include <string.h>

_ACEOF
if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
  $EGREP "memchr" >/dev/null 2>&1; then :

else
  ac_cv_header_stdc=no
fi
rm -f conftest*

fi

if test $ac_cv_header_stdc = yes; then
  # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
/* end confdefs.h.  */
#include <stdlib.h>

_ACEOF
if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
  $EGREP "free" >/dev/null 2>&1; then :

else
  ac_cv_header_stdc=no
fi
rm -f conftest*

fi

if test $ac_cv_header_stdc = yes; then
  # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
  if test "$cross_compiling" = yes; then :
  :
else
  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
/* end confdefs.h.  */
#include <ctype.h>
#include <stdlib.h>
#if ((' ' & 0x0FF) == 0x020)
# define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
# define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
#else
# define ISLOWER(c) \
		   (('a' <= (c) && (c) <= 'i') \
		     || ('j' <= (c) && (c) <= 'r') \
		     || ('s' <= (c) && (c) <= 'z'))
# define TOUPPER(c) (ISLOWER(c) ? ((c) | 0x40) : (c))
#endif

#define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
int
main ()
{
  int i;
  for (i = 0; i < 256; i++)
    if (XOR (islower (i), ISLOWER (i))
	|| toupper (i) != TOUPPER (i))
      return 2;
  return 0;
}
_ACEOF
if ac_fn_c_try_run "$LINENO"; then :

else
  ac_cv_header_stdc=no
fi
rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
  conftest.$ac_objext conftest.beam conftest.$ac_ext
fi

fi
fi
{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_header_stdc" >&5
$as_echo "$ac_cv_header_stdc" >&6; }
if test $ac_cv_header_stdc = yes; then

$as_echo "#define STDC_HEADERS 1" >>confdefs.h

fi

# On IRIX 5.3, sys/types and inttypes.h are conflicting.
for ac_header in sys/types.h sys/stat.h stdlib.h string.h memory.h strings.h \
		  inttypes.h stdint.h unistd.h
do :
  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
ac_fn_c_check_header_compile "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default
"
if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
  cat >>confdefs.h <<_ACEOF
#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
_ACEOF

fi

done


for ac_header in unistd.h
do :
  ac_fn_c_check_header_mongrel "$LINENO" "unistd.h" "ac_cv_header_unistd_h" "$ac_includes_default"
if test "x$ac_cv_header_unistd_h" = xyes; then :
  cat >>confdefs.h <<_ACEOF
#define HAVE_UNISTD_H 1
_ACEOF

fi

done

{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for cos in -lm" >&5
$as_echo_n "checking for cos in -lm... " >&6; }
if ${ac_cv_lib_m_cos+:} false; then :
  $as_echo_n "(cached) " >&6
else
  ac_check_lib_save_LIBS=$LIBS
LIBS="-lm  $LIBS"
cat confdefs.h - <<_ACEOF >conftest.$ac_ext
/* end confdefs.h.  */

/* Override any GCC internal prototype to avoid an error.
   Use char because int might match the return type of a GCC
   builtin and then its argument prototype would still apply.  */
#ifdef __cplusplus
extern "C"
#endif
char cos ();
int
main ()
{
return cos ();
  ;
  return 0;
}
_ACEOF
if ac_fn_c_try_link "$LINENO"; then :
  ac_cv_lib_m_cos=yes
else
  ac_cv_lib_m_cos=no
fi
rm -f core conftest.err conftest.$ac_objext \
    conftest$ac_exeext conftest.$ac_ext
LIBS=$ac_check_lib_save_LIBS
fi
{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_m_cos" >&5
$as_echo "$ac_cv_lib_m_cos" >&6; }
if test "x$ac_cv_lib_m_cos" = xyes; then :
  cat >>confdefs.h <<_ACEOF
#define HAVE_LIBM 1
_ACEOF

  LIBS="-lm $LIBS"

fi


{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for an ANSI C-conforming const" >&5
$as_echo_n "checking for an ANSI C-conforming const... " >&6; }
if ${ac_cv_c_const+:} false; then :
  $as_echo_n "(cached) " >&6
else
  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
/* end confdefs.h.  */

int
main ()
{

#ifndef __cplusplus
  /* Ultrix mips cc rejects this sort of thing.  */
  typedef int charset[2];
  const charset cs = { 0, 0 };
  /* SunOS 4.1.1 cc rejects this.  */
  char const *const *pcpcc;
  char **ppc;
  /* NEC SVR4.0.2 mips cc rejects this.  */
  struct point {int x, y;};
  static struct point const zero = {0,0};
  /* AIX XL C 1.02.0.0 rejects this.
     It does not let you subtract one const X* pointer from another in
     an arm of an if-expression whose if-part is not a constant
     expression */
  const char *g = "string";
  pcpcc = &g + (g ? g-g : 0);
  /* HPUX 7.0 cc rejects these. */
  ++pcpcc;
  ppc = (char**) pcpcc;
  pcpcc = (char const *const *) ppc;
  { /* SCO 3.2v4 cc rejects this sort of thing.  */
    char tx;
    char *t = &tx;
    char const *s = 0 ? (char *) 0 : (char const *) 0;

    *t++ = 0;
    if (s) return 0;
  }
  { /* Someone thinks the Sun supposedly-ANSI compiler will reject this.  */
    int x[] = {25, 17};
    const int *foo = &x[0];
    ++foo;
  }
  { /* Sun SC1.0 ANSI compiler rejects this -- but not the above. */
    typedef const int *iptr;
    iptr p = 0;
    ++p;
  }
  { /* AIX XL C 1.02.0.0 rejects this sort of thing, saying
       "k.c", line 2.27: 1506-025 (S) Operand must be a modifiable lvalue. */
    struct s { int j; const int *ap[3]; } bx;
    struct s *b = &bx; b->j = 5;
  }
  { /* ULTRIX-32 V3.1 (Rev 9) vcc rejects this */
    const int foo = 10;
    if (!foo) return 0;
  }
  return !cs[0] && !zero.x;
#endif

  ;
  return 0;
}
_ACEOF
if ac_fn_c_try_compile "$LINENO"; then :
  ac_cv_c_const=yes
else
  ac_cv_c_const=no
fi
rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
fi
{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_const" >&5
$as_echo "$ac_cv_c_const" >&6; }
if test $ac_cv_c_const = no; then

$as_echo "#define const /**/" >>confdefs.h

fi




ac_config_files="$ac_config_files Makefile"

cat >confcache <<\_ACEOF
# This file is a shell script that caches the results of configure
# tests run on this system so they can be shared between configure
# scripts and configure runs, see configure's option --config-cache.
# It is not useful on other systems.  If it contains results you don't
# want to keep, you may remove or edit it.
#
# config.status only pays attention to the cache file if you give it
# the --recheck option to rerun configure.
#
# `ac_cv_env_foo' variables (set or unset) will be overridden when
# loading this file, other *unset* `ac_cv_foo' will be assigned the
# following values.

_ACEOF

# The following way of writing the cache mishandles newlines in values,
# but we know of no workaround that is simple, portable, and efficient.
# So, we kill variables containing newlines.
# Ultrix sh set writes to stderr and can't be redirected directly,
# and sets the high bit in the cache file unless we assign to the vars.
(
  for ac_var in `(set) 2>&1 | sed -n 's/^\([a-zA-Z_][a-zA-Z0-9_]*\)=.*/\1/p'`; do
    eval ac_val=\$$ac_var
    case $ac_val in #(
    *${as_nl}*)
      case $ac_var in #(
      *_cv_*) { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline" >&5
$as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
      esac
      case $ac_var in #(
      _ | IFS | as_nl) ;; #(
      BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(
      *) { eval $ac_var=; unset $ac_var;} ;;
      esac ;;
    esac
  done

  (set) 2>&1 |
    case $as_nl`(ac_space=' '; set) 2>&1` in #(
    *${as_nl}ac_space=\ *)
      # `set' does not quote correctly, so add quotes: double-quote
      # substitution turns \\\\ into \\, and sed turns \\ into \.
      sed -n \
	"s/'/'\\\\''/g;
	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\\2'/p"
      ;; #(
    *)
      # `set' quotes correctly as required by POSIX, so do not add quotes.
      sed -n "/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p"
      ;;
    esac |
    sort
) |
  sed '
     /^ac_cv_env_/b end
     t clear
     :clear
     s/^\([^=]*\)=\(.*[{}].*\)$/test "${\1+set}" = set || &/
     t end
     s/^\([^=]*\)=\(.*\)$/\1=${\1=\2}/
     :end' >>confcache
if diff "$cache_file" confcache >/dev/null 2>&1; then :; else
  if test -w "$cache_file"; then
    if test "x$cache_file" != "x/dev/null"; then
      { $as_echo "$as_me:${as_lineno-$LINENO}: updating cache $cache_file" >&5
$as_echo "$as_me: updating cache $cache_file" >&6;}
      if test ! -f "$cache_file" || test -h "$cache_file"; then
	cat confcache >"$cache_file"
      else
        case $cache_file in #(
        */* | ?:*)
	  mv -f confcache "$cache_file"$$ &&
	  mv -f "$cache_file"$$ "$cache_file" ;; #(
        *)
	  mv -f confcache "$cache_file" ;;
	esac
      fi
    fi
  else
    { $as_echo "$as_me:${as_lineno-$LINENO}: not updating unwritable cache $cache_file" >&5
$as_echo "$as_me: not updating unwritable cache $cache_file" >&6;}
  fi
fi
rm -f confcache

test "x$prefix" = xNONE && prefix=$ac_default_prefix
# Let make expand exec_prefix.
test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'

# Transform confdefs.h into DEFS.
# Protect against shell expansion while executing Makefile rules.
# Protect against Makefile macro expansion.
#
# If the first sed substitution is executed (which looks for macros that
# take arguments), then branch to the quote section.  Otherwise,
# look for a macro that doesn't take arguments.
ac_script='
:mline
/\\$/{
 N
 s,\\\n,,
 b mline
}
t clear
:clear
s/^[	 ]*#[	 ]*define[	 ][	 ]*\([^	 (][^	 (]*([^)]*)\)[	 ]*\(.*\)/-D\1=\2/g
t quote
s/^[	 ]*#[	 ]*define[	 ][	 ]*\([^	 ][^	 ]*\)[	 ]*\(.*\)/-D\1=\2/g
t quote
b any
:quote
s/[	 `~#$^&*(){}\\|;'\''"<>?]/\\&/g
s/\[/\\&/g
s/\]/\\&/g
s/\$/$$/g
H
:any
${
	g
	s/^\n//
	s/\n/ /g
	p
}
'
DEFS=`sed -n "$ac_script" confdefs.h`


ac_libobjs=
ac_ltlibobjs=
U=
for ac_i in : $LIBOBJS; do test "x$ac_i" = x: && continue
  # 1. Remove the extension, and $U if already installed.
  ac_script='s/\$U\././;s/\.o$//;s/\.obj$//'
  ac_i=`$as_echo "$ac_i" | sed "$ac_script"`
  # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR
  #    will be set to the directory where LIBOBJS objects are built.
  as_fn_append ac_libobjs " \${LIBOBJDIR}$ac_i\$U.$ac_objext"
  as_fn_append ac_ltlibobjs " \${LIBOBJDIR}$ac_i"'$U.lo'
done
LIBOBJS=$ac_libobjs

LTLIBOBJS=$ac_ltlibobjs



: "${CONFIG_STATUS=./config.status}"
ac_write_fail=0
ac_clean_files_save=$ac_clean_files
ac_clean_files="$ac_clean_files $CONFIG_STATUS"
{ $as_echo "$as_me:${as_lineno-$LINENO}: creating $CONFIG_STATUS" >&5
$as_echo "$as_me: creating $CONFIG_STATUS" >&6;}
as_write_fail=0
cat >$CONFIG_STATUS <<_ASEOF || as_write_fail=1
#! $SHELL
# Generated by $as_me.
# Run this file to recreate the current configuration.
# Compiler output produced by configure, useful for debugging
# configure, is in config.log if it exists.

debug=false
ac_cs_recheck=false
ac_cs_silent=false

SHELL=\${CONFIG_SHELL-$SHELL}
export SHELL
_ASEOF
cat >>$CONFIG_STATUS <<\_ASEOF || as_write_fail=1
## -------------------- ##
## M4sh Initialization. ##
## -------------------- ##

# Be more Bourne compatible
DUALCASE=1; export DUALCASE # for MKS sh
if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then :
  emulate sh
  NULLCMD=:
  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
  # is contrary to our usage.  Disable this feature.
  alias -g '${1+"$@"}'='"$@"'
  setopt NO_GLOB_SUBST
else
  case `(set -o) 2>/dev/null` in #(
  *posix*) :
    set -o posix ;; #(
  *) :
     ;;
esac
fi


as_nl='
'
export as_nl
# Printing a long string crashes Solaris 7 /usr/bin/printf.
as_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo
as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo
# Prefer a ksh shell builtin over an external printf program on Solaris,
# but without wasting forks for bash or zsh.
if test -z "$BASH_VERSION$ZSH_VERSION" \
    && (test "X`print -r -- $as_echo`" = "X$as_echo") 2>/dev/null; then
  as_echo='print -r --'
  as_echo_n='print -rn --'
elif (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
  as_echo='printf %s\n'
  as_echo_n='printf %s'
else
  if test "X`(/usr/ucb/echo -n -n $as_echo) 2>/dev/null`" = "X-n $as_echo"; then
    as_echo_body='eval /usr/ucb/echo -n "$1$as_nl"'
    as_echo_n='/usr/ucb/echo -n'
  else
    as_echo_body='eval expr "X$1" : "X\\(.*\\)"'
    as_echo_n_body='eval
      arg=$1;
      case $arg in #(
      *"$as_nl"*)
	expr "X$arg" : "X\\(.*\\)$as_nl";
	arg=`expr "X$arg" : ".*$as_nl\\(.*\\)"`;;
      esac;
      expr "X$arg" : "X\\(.*\\)" | tr -d "$as_nl"
    '
    export as_echo_n_body
    as_echo_n='sh -c $as_echo_n_body as_echo'
  fi
  export as_echo_body
  as_echo='sh -c $as_echo_body as_echo'
fi

# The user is always right.
if test "${PATH_SEPARATOR+set}" != set; then
  PATH_SEPARATOR=:
  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {
    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||
      PATH_SEPARATOR=';'
  }
fi


# IFS
# We need space, tab and new line, in precisely that order.  Quoting is
# there to prevent editors from complaining about space-tab.
# (If _AS_PATH_WALK were called with IFS unset, it would disable word
# splitting by setting IFS to empty value.)
IFS=" ""	$as_nl"

# Find who we are.  Look in the path if we contain no directory separator.
as_myself=
case $0 in #((
  *[\\/]* ) as_myself=$0 ;;
  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
    test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
  done
IFS=$as_save_IFS

     ;;
esac
# We did not find ourselves, most probably we were run as `sh COMMAND'
# in which case we are not to be found in the path.
if test "x$as_myself" = x; then
  as_myself=$0
fi
if test ! -f "$as_myself"; then
  $as_echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
  exit 1
fi

# Unset variables that we do not need and which cause bugs (e.g. in
# pre-3.0 UWIN ksh).  But do not cause bugs in bash 2.01; the "|| exit 1"
# suppresses any "Segmentation fault" message there.  '((' could
# trigger a bug in pdksh 5.2.14.
for as_var in BASH_ENV ENV MAIL MAILPATH
do eval test x\${$as_var+set} = xset \
  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :
done
PS1='$ '
PS2='> '
PS4='+ '

# NLS nuisances.
LC_ALL=C
export LC_ALL
LANGUAGE=C
export LANGUAGE

# CDPATH.
(unset CDPATH) >/dev/null 2>&1 && unset CDPATH


# as_fn_error STATUS ERROR [LINENO LOG_FD]
# ----------------------------------------
# Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
# provided, also output the error to LOG_FD, referencing LINENO. Then exit the
# script with STATUS, using 1 if that was 0.
as_fn_error ()
{
  as_status=$1; test $as_status -eq 0 && as_status=1
  if test "$4"; then
    as_lineno=${as_lineno-"$3"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
    $as_echo "$as_me:${as_lineno-$LINENO}: error: $2" >&$4
  fi
  $as_echo "$as_me: error: $2" >&2
  as_fn_exit $as_status
} # as_fn_error


# as_fn_set_status STATUS
# -----------------------
# Set $? to STATUS, without forking.
as_fn_set_status ()
{
  return $1
} # as_fn_set_status

# as_fn_exit STATUS
# -----------------
# Exit the shell with STATUS, even in a "trap 0" or "set -e" context.
as_fn_exit ()
{
  set +e
  as_fn_set_status $1
  exit $1
} # as_fn_exit

# as_fn_unset VAR
# ---------------
# Portably unset VAR.
as_fn_unset ()
{
  { eval $1=; unset $1;}
}
as_unset=as_fn_unset
# as_fn_append VAR VALUE
# ----------------------
# Append the text in VALUE to the end of the definition contained in VAR. Take
# advantage of any shell optimizations that allow amortized linear growth over
# repeated appends, instead of the typical quadratic growth present in naive
# implementations.
if (eval "as_var=1; as_var+=2; test x\$as_var = x12") 2>/dev/null; then :
  eval 'as_fn_append ()
  {
    eval $1+=\$2
  }'
else
  as_fn_append ()
  {
    eval $1=\$$1\$2
  }
fi # as_fn_append

# as_fn_arith ARG...
# ------------------
# Perform arithmetic evaluation on the ARGs, and store the result in the
# global $as_val. Take advantage of shells that can avoid forks. The arguments
# must be portable across $(()) and expr.
if (eval "test \$(( 1 + 1 )) = 2") 2>/dev/null; then :
  eval 'as_fn_arith ()
  {
    as_val=$(( $* ))
  }'
else
  as_fn_arith ()
  {
    as_val=`expr "$@" || test $? -eq 1`
  }
fi # as_fn_arith


if expr a : '\(a\)' >/dev/null 2>&1 &&
   test "X`expr 00001 : '.*\(...\)'`" = X001; then
  as_expr=expr
else
  as_expr=false
fi

if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
  as_basename=basename
else
  as_basename=false
fi

if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
  as_dirname=dirname
else
  as_dirname=false
fi

as_me=`$as_basename -- "$0" ||
$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
	 X"$0" : 'X\(//\)$' \| \
	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
$as_echo X/"$0" |
    sed '/^.*\/\([^/][^/]*\)\/*$/{
	    s//\1/
	    q
	  }
	  /^X\/\(\/\/\)$/{
	    s//\1/
	    q
	  }
	  /^X\/\(\/\).*/{
	    s//\1/
	    q
	  }
	  s/.*/./; q'`

# Avoid depending upon Character Ranges.
as_cr_letters='abcdefghijklmnopqrstuvwxyz'
as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
as_cr_Letters=$as_cr_letters$as_cr_LETTERS
as_cr_digits='0123456789'
as_cr_alnum=$as_cr_Letters$as_cr_digits

ECHO_C= ECHO_N= ECHO_T=
case `echo -n x` in #(((((
-n*)
  case `echo 'xy\c'` in
  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
  xy)  ECHO_C='\c';;
  *)   echo `echo ksh88 bug on AIX 6.1` > /dev/null
       ECHO_T='	';;
  esac;;
*)
  ECHO_N='-n';;
esac

rm -f conf$$ conf$$.exe conf$$.file
if test -d conf$$.dir; then
  rm -f conf$$.dir/conf$$.file
else
  rm -f conf$$.dir
  mkdir conf$$.dir 2>/dev/null
fi
if (echo >conf$$.file) 2>/dev/null; then
  if ln -s conf$$.file conf$$ 2>/dev/null; then
    as_ln_s='ln -s'
    # ... but there are two gotchas:
    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
    # In both cases, we have to default to `cp -pR'.
    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
      as_ln_s='cp -pR'
  elif ln conf$$.file conf$$ 2>/dev/null; then
    as_ln_s=ln
  else
    as_ln_s='cp -pR'
  fi
else
  as_ln_s='cp -pR'
fi
rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
rmdir conf$$.dir 2>/dev/null


# as_fn_mkdir_p
# -------------
# Create "$as_dir" as a directory, including parents if necessary.
as_fn_mkdir_p ()
{

  case $as_dir in #(
  -*) as_dir=./$as_dir;;
  esac
  test -d "$as_dir" || eval $as_mkdir_p || {
    as_dirs=
    while :; do
      case $as_dir in #(
      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
      *) as_qdir=$as_dir;;
      esac
      as_dirs="'$as_qdir' $as_dirs"
      as_dir=`$as_dirname -- "$as_dir" ||
$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
	 X"$as_dir" : 'X\(//\)[^/]' \| \
	 X"$as_dir" : 'X\(//\)$' \| \
	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
$as_echo X"$as_dir" |
    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
	    s//\1/
	    q
	  }
	  /^X\(\/\/\)[^/].*/{
	    s//\1/
	    q
	  }
	  /^X\(\/\/\)$/{
	    s//\1/
	    q
	  }
	  /^X\(\/\).*/{
	    s//\1/
	    q
	  }
	  s/.*/./; q'`
      test -d "$as_dir" && break
    done
    test -z "$as_dirs" || eval "mkdir $as_dirs"
  } || test -d "$as_dir" || as_fn_error $? "cannot create directory $as_dir"


} # as_fn_mkdir_p
if mkdir -p . 2>/dev/null; then
  as_mkdir_p='mkdir -p "$as_dir"'
else
  test -d ./-p && rmdir ./-p
  as_mkdir_p=false
fi


# as_fn_executable_p FILE
# -----------------------
# Test if FILE is an executable regular file.
as_fn_executable_p ()
{
  test -f "$1" && test -x "$1"
} # as_fn_executable_p
as_test_x='test -x'
as_executable_p=as_fn_executable_p

# Sed expression to map a string onto a valid CPP name.
as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"

# Sed expression to map a string onto a valid variable name.
as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"


exec 6>&1
## ----------------------------------- ##
## Main body of $CONFIG_STATUS script. ##
## ----------------------------------- ##
_ASEOF
test $as_write_fail = 0 && chmod +x $CONFIG_STATUS || ac_write_fail=1

cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
# Save the log message, to keep $0 and so on meaningful, and to
# report actual input values of CONFIG_FILES etc. instead of their
# values after options handling.
ac_log="
This file was extended by $as_me, which was
generated by GNU Autoconf 2.69.  Invocation command line was

  CONFIG_FILES    = $CONFIG_FILES
  CONFIG_HEADERS  = $CONFIG_HEADERS
  CONFIG_LINKS    = $CONFIG_LINKS
  CONFIG_COMMANDS = $CONFIG_COMMANDS
  $ $0 $@

on `(hostname || uname -n) 2>/dev/null | sed 1q`
"

_ACEOF

case $ac_config_files in *"
"*) set x $ac_config_files; shift; ac_config_files=$*;;
esac



cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
# Files that config.status was made for.
config_files="$ac_config_files"

_ACEOF

cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
ac_cs_usage="\
\`$as_me' instantiates files and other configuration actions
from templates according to the current configuration.  Unless the files
and actions are specified as TAGs, all are instantiated by default.

Usage: $0 [OPTION]... [TAG]...

  -h, --help       print this help, then exit
  -V, --version    print version number and configuration settings, then exit
      --config     print configuration, then exit
  -q, --quiet, --silent
                   do not print progress messages
  -d, --debug      don't remove temporary files
      --recheck    update $as_me by reconfiguring in the same conditions
      --file=FILE[:TEMPLATE]
                   instantiate the configuration file FILE

Configuration files:
$config_files

Report bugs to the package provider."

_ACEOF
cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
ac_cs_config="`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`"
ac_cs_version="\\
config.status
configured by $0, generated by GNU Autoconf 2.69,
  with options \\"\$ac_cs_config\\"

Copyright (C) 2012 Free Software Foundation, Inc.
This config.status script is free software; the Free Software Foundation
gives unlimited permission to copy, distribute and modify it."

ac_pwd='$ac_pwd'
srcdir='$srcdir'
test -n "\$AWK" || AWK=awk
_ACEOF

cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
# The default lists apply if the user does not specify any file.
ac_need_defaults=:
while test $# != 0
do
  case $1 in
  --*=?*)
    ac_option=`expr "X$1" : 'X\([^=]*\)='`
    ac_optarg=`expr "X$1" : 'X[^=]*=\(.*\)'`
    ac_shift=:
    ;;
  --*=)
    ac_option=`expr "X$1" : 'X\([^=]*\)='`
    ac_optarg=
    ac_shift=:
    ;;
  *)
    ac_option=$1
    ac_optarg=$2
    ac_shift=shift
    ;;
  esac

  case $ac_option in
  # Handling of the options.
  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
    ac_cs_recheck=: ;;
  --version | --versio | --versi | --vers | --ver | --ve | --v | -V )
    $as_echo "$ac_cs_version"; exit ;;
  --config | --confi | --conf | --con | --co | --c )
    $as_echo "$ac_cs_config"; exit ;;
  --debug | --debu | --deb | --de | --d | -d )
    debug=: ;;
  --file | --fil | --fi | --f )
    $ac_shift
    case $ac_optarg in
    *\'*) ac_optarg=`$as_echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"` ;;
    '') as_fn_error $? "missing file argument" ;;
    esac
    as_fn_append CONFIG_FILES " '$ac_optarg'"
    ac_need_defaults=false;;
  --he | --h |  --help | --hel | -h )
    $as_echo "$ac_cs_usage"; exit ;;
  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
  | -silent | --silent | --silen | --sile | --sil | --si | --s)
    ac_cs_silent=: ;;

  # This is an error.
  -*) as_fn_error $? "unrecognized option: \`$1'
Try \`$0 --help' for more information." ;;

  *) as_fn_append ac_config_targets " $1"
     ac_need_defaults=false ;;

  esac
  shift
done

ac_configure_extra_args=

if $ac_cs_silent; then
  exec 6>/dev/null
  ac_configure_extra_args="$ac_configure_extra_args --silent"
fi

_ACEOF
cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
if \$ac_cs_recheck; then
  set X $SHELL '$0' $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
  shift
  \$as_echo "running CONFIG_SHELL=$SHELL \$*" >&6
  CONFIG_SHELL='$SHELL'
  export CONFIG_SHELL
  exec "\$@"
fi

_ACEOF
cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
exec 5>>config.log
{
  echo
  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
## Running $as_me. ##
_ASBOX
  $as_echo "$ac_log"
} >&5

_ACEOF
cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
_ACEOF

cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1

# Handling of arguments.
for ac_config_target in $ac_config_targets
do
  case $ac_config_target in
    "Makefile") CONFIG_FILES="$CONFIG_FILES Makefile" ;;

  *) as_fn_error $? "invalid argument: \`$ac_config_target'" "$LINENO" 5;;
  esac
done


# If the user did not use the arguments to specify the items to instantiate,
# then the envvar interface is used.  Set only those that are not.
# We use the long form for the default assignment because of an extremely
# bizarre bug on SunOS 4.1.3.
if $ac_need_defaults; then
  test "${CONFIG_FILES+set}" = set || CONFIG_FILES=$config_files
fi

# Have a temporary directory for convenience.  Make it in the build tree
# simply because there is no reason against having it here, and in addition,
# creating and moving files from /tmp can sometimes cause problems.
# Hook for its removal unless debugging.
# Note that there is a small window in which the directory will not be cleaned:
# after its creation but before its name has been assigned to `$tmp'.
$debug ||
{
  tmp= ac_tmp=
  trap 'exit_status=$?
  : "${ac_tmp:=$tmp}"
  { test ! -d "$ac_tmp" || rm -fr "$ac_tmp"; } && exit $exit_status
' 0
  trap 'as_fn_exit 1' 1 2 13 15
}
# Create a (secure) tmp directory for tmp files.

{
  tmp=`(umask 077 && mktemp -d "./confXXXXXX") 2>/dev/null` &&
  test -d "$tmp"
}  ||
{
  tmp=./conf$$-$RANDOM
  (umask 077 && mkdir "$tmp")
} || as_fn_error $? "cannot create a temporary directory in ." "$LINENO" 5
ac_tmp=$tmp

# Set up the scripts for CONFIG_FILES section.
# No need to generate them if there are no CONFIG_FILES.
# This happens for instance with `./config.status config.h'.
if test -n "$CONFIG_FILES"; then


ac_cr=`echo X | tr X '\015'`
# On cygwin, bash can eat \r inside `` if the user requested igncr.
# But we know of no other shell where ac_cr would be empty at this
# point, so we can use a bashism as a fallback.
if test "x$ac_cr" = x; then
  eval ac_cr=\$\'\\r\'
fi
ac_cs_awk_cr=`$AWK 'BEGIN { print "a\rb" }' </dev/null 2>/dev/null`
if test "$ac_cs_awk_cr" = "a${ac_cr}b"; then
  ac_cs_awk_cr='\\r'
else
  ac_cs_awk_cr=$ac_cr
fi

echo 'BEGIN {' >"$ac_tmp/subs1.awk" &&
_ACEOF


{
  echo "cat >conf$$subs.awk <<_ACEOF" &&
  echo "$ac_subst_vars" | sed 's/.*/&!$&$ac_delim/' &&
  echo "_ACEOF"
} >conf$$subs.sh ||
  as_fn_error $? "could not make $CONFIG_STATUS" "$LINENO" 5
ac_delim_num=`echo "$ac_subst_vars" | grep -c '^'`
ac_delim='%!_!# '
for ac_last_try in false false false false false :; do
  . ./conf$$subs.sh ||
    as_fn_error $? "could not make $CONFIG_STATUS" "$LINENO" 5

  ac_delim_n=`sed -n "s/.*$ac_delim\$/X/p" conf$$subs.awk | grep -c X`
  if test $ac_delim_n = $ac_delim_num; then
    break
  elif $ac_last_try; then
    as_fn_error $? "could not make $CONFIG_STATUS" "$LINENO" 5
  else
    ac_delim="$ac_delim!$ac_delim _$ac_delim!! "
  fi
done
rm -f conf$$subs.sh

cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
cat >>"\$ac_tmp/subs1.awk" <<\\_ACAWK &&
_ACEOF
sed -n '
h
s/^/S["/; s/!.*/"]=/
p
g
s/^[^!]*!//
:repl
t repl
s/'"$ac_delim"'$//
t delim
:nl
h
s/\(.\{148\}\)..*/\1/
t more1
s/["\\]/\\&/g; s/^/"/; s/$/\\n"\\/
p
n
b repl
:more1
s/["\\]/\\&/g; s/^/"/; s/$/"\\/
p
g
s/.\{148\}//
t nl
:delim
h
s/\(.\{148\}\)..*/\1/
t more2
s/["\\]/\\&/g; s/^/"/; s/$/"/
p
b
:more2
s/["\\]/\\&/g; s/^/"/; s/$/"\\/
p
g
s/.\{148\}//
t delim
' <conf$$subs.awk | sed '
/^[^""]/{
  N
  s/\n//
}
' >>$CONFIG_STATUS || ac_write_fail=1
rm -f conf$$subs.awk
cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
_ACAWK
cat >>"\$ac_tmp/subs1.awk" <<_ACAWK &&
  for (key in S) S_is_set[key] = 1
  FS = ""

}
{
  line = $ 0
  nfields = split(line, field, "@")
  substed = 0
  len = length(field[1])
  for (i = 2; i < nfields; i++) {
    key = field[i]
    keylen = length(key)
    if (S_is_set[key]) {
      value = S[key]
      line = substr(line, 1, len) "" value "" substr(line, len + keylen + 3)
      len += length(value) + length(field[++i])
      substed = 1
    } else
      len += 1 + keylen
  }

  print line
}

_ACAWK
_ACEOF
cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
if sed "s/$ac_cr//" < /dev/null > /dev/null 2>&1; then
  sed "s/$ac_cr\$//; s/$ac_cr/$ac_cs_awk_cr/g"
else
  cat
fi < "$ac_tmp/subs1.awk" > "$ac_tmp/subs.awk" \
  || as_fn_error $? "could not setup config files machinery" "$LINENO" 5
_ACEOF

# VPATH may cause trouble with some makes, so we remove sole $(srcdir),
# ${srcdir} and @srcdir@ entries from VPATH if srcdir is ".", strip leading and
# trailing colons and then remove the whole line if VPATH becomes empty
# (actually we leave an empty line to preserve line numbers).
if test "x$srcdir" = x.; then
  ac_vpsub='/^[	 ]*VPATH[	 ]*=[	 ]*/{
h
s///
s/^/:/
s/[	 ]*$/:/
s/:\$(srcdir):/:/g
s/:\${srcdir}:/:/g
s/:@srcdir@:/:/g
s/^:*//
s/:*$//
x
s/\(=[	 ]*\).*/\1/
G
s/\n//
s/^[^=]*=[	 ]*$//
}'
fi

cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
fi # test -n "$CONFIG_FILES"


eval set X "  :F $CONFIG_FILES      "
shift
for ac_tag
do
  case $ac_tag in
  :[FHLC]) ac_mode=$ac_tag; continue;;
  esac
  case $ac_mode$ac_tag in
  :[FHL]*:*);;
  :L* | :C*:*) as_fn_error $? "invalid tag \`$ac_tag'" "$LINENO" 5;;
  :[FH]-) ac_tag=-:-;;
  :[FH]*) ac_tag=$ac_tag:$ac_tag.in;;
  esac
  ac_save_IFS=$IFS
  IFS=:
  set x $ac_tag
  IFS=$ac_save_IFS
  shift
  ac_file=$1
  shift

  case $ac_mode in
  :L) ac_source=$1;;
  :[FH])
    ac_file_inputs=
    for ac_f
    do
      case $ac_f in
      -) ac_f="$ac_tmp/stdin";;
      *) # Look for the file first in the build tree, then in the source tree
	 # (if the path is not absolute).  The absolute path cannot be DOS-style,
	 # because $ac_f cannot contain `:'.
	 test -f "$ac_f" ||
	   case $ac_f in
	   [\\/$]*) false;;
	   *) test -f "$srcdir/$ac_f" && ac_f="$srcdir/$ac_f";;
	   esac ||
	   as_fn_error 1 "cannot find input file: \`$ac_f'" "$LINENO" 5;;
      esac
      case $ac_f in *\'*) ac_f=`$as_echo "$ac_f" | sed "s/'/'\\\\\\\\''/g"`;; esac
      as_fn_append ac_file_inputs " '$ac_f'"
    done

    # Let's still pretend it is `configure' which instantiates (i.e., don't
    # use $as_me), people would be surprised to read:
    #    /* config.h.  Generated by config.status.  */
    configure_input='Generated from '`
	  $as_echo "$*" | sed 's|^[^:]*/||;s|:[^:]*/|, |g'
	`' by configure.'
    if test x"$ac_file" != x-; then
      configure_input="$ac_file.  $configure_input"
      { $as_echo "$as_me:${as_lineno-$LINENO}: creating $ac_file" >&5
$as_echo "$as_me: creating $ac_file" >&6;}
    fi
    # Neutralize special characters interpreted by sed in replacement strings.
    case $configure_input in #(
    *\&* | *\|* | *\\* )
       ac_sed_conf_input=`$as_echo "$configure_input" |
       sed 's/[\\\\&|]/\\\\&/g'`;; #(
    *) ac_sed_conf_input=$configure_input;;
    esac

    case $ac_tag in
    *:-:* | *:-) cat >"$ac_tmp/stdin" \
      || as_fn_error $? "could not create $ac_file" "$LINENO" 5 ;;
    esac
    ;;
  esac

  ac_dir=`$as_dirname -- "$ac_file" ||
$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
	 X"$ac_file" : 'X\(//\)[^/]' \| \
	 X"$ac_file" : 'X\(//\)$' \| \
	 X"$ac_file" : 'X\(/\)' \| . 2>/dev/null ||
$as_echo X"$ac_file" |
    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
	    s//\1/
	    q
	  }
	  /^X\(\/\/\)[^/].*/{
	    s//\1/
	    q
	  }
	  /^X\(\/\/\)$/{
	    s//\1/
	    q
	  }
	  /^X\(\/\).*/{
	    s//\1/
	    q
	  }
	  s/.*/./; q'`
  as_dir="$ac_dir"; as_fn_mkdir_p
  ac_builddir=.

case "$ac_dir" in
.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
*)
  ac_dir_suffix=/`$as_echo "$ac_dir" | sed 's|^\.[\\/]||'`
  # A ".." for each directory in $ac_dir_suffix.
  ac_top_builddir_sub=`$as_echo "$ac_dir_suffix" | sed 's|/[^\\/]*|/..|g;s|/||'`
  case $ac_top_builddir_sub in
  "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
  esac ;;
esac
ac_abs_top_builddir=$ac_pwd
ac_abs_builddir=$ac_pwd$ac_dir_suffix
# for backward compatibility:
ac_top_builddir=$ac_top_build_prefix

case $srcdir in
  .)  # We are building in place.
    ac_srcdir=.
    ac_top_srcdir=$ac_top_builddir_sub
    ac_abs_top_srcdir=$ac_pwd ;;
  [\\/]* | ?:[\\/]* )  # Absolute name.
    ac_srcdir=$srcdir$ac_dir_suffix;
    ac_top_srcdir=$srcdir
    ac_abs_top_srcdir=$srcdir ;;
  *) # Relative name.
    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix
    ac_top_srcdir=$ac_top_build_prefix$srcdir
    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;
esac
ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix


  case $ac_mode in
  :F)
  #
  # CONFIG_FILE
  #

_ACEOF

cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
# If the template does not know about datarootdir, expand it.
# FIXME: This hack should be removed a few years after 2.60.
ac_datarootdir_hack=; ac_datarootdir_seen=
ac_sed_dataroot='
/datarootdir/ {
  p
  q
}
/@datadir@/p
/@docdir@/p
/@infodir@/p
/@localedir@/p
/@mandir@/p'
case `eval "sed -n \"\$ac_sed_dataroot\" $ac_file_inputs"` in
*datarootdir*) ac_datarootdir_seen=yes;;
*@datadir@*|*@docdir@*|*@infodir@*|*@localedir@*|*@mandir@*)
  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&5
$as_echo "$as_me: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&2;}
_ACEOF
cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
  ac_datarootdir_hack='
  s&@datadir@&$datadir&g
  s&@docdir@&$docdir&g
  s&@infodir@&$infodir&g
  s&@localedir@&$localedir&g
  s&@mandir@&$mandir&g
  s&\\\${datarootdir}&$datarootdir&g' ;;
esac
_ACEOF

# Neutralize VPATH when `$srcdir' = `.'.
# Shell code in configure.ac might set extrasub.
# FIXME: do we really want to maintain this feature?
cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
ac_sed_extra="$ac_vpsub
$extrasub
_ACEOF
cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
:t
/@[a-zA-Z_][a-zA-Z_0-9]*@/!b
s|@configure_input@|$ac_sed_conf_input|;t t
s&@top_builddir@&$ac_top_builddir_sub&;t t
s&@top_build_prefix@&$ac_top_build_prefix&;t t
s&@srcdir@&$ac_srcdir&;t t
s&@abs_srcdir@&$ac_abs_srcdir&;t t
s&@top_srcdir@&$ac_top_srcdir&;t t
s&@abs_top_srcdir@&$ac_abs_top_srcdir&;t t
s&@builddir@&$ac_builddir&;t t
s&@abs_builddir@&$ac_abs_builddir&;t t
s&@abs_top_builddir@&$ac_abs_top_builddir&;t t
$ac_datarootdir_hack
"
eval sed \"\$ac_sed_extra\" "$ac_file_inputs" | $AWK -f "$ac_tmp/subs.awk" \
  >$ac_tmp/out || as_fn_error $? "could not create $ac_file" "$LINENO" 5

test -z "$ac_datarootdir_hack$ac_datarootdir_seen" &&
  { ac_out=`sed -n '/\${datarootdir}/p' "$ac_tmp/out"`; test -n "$ac_out"; } &&
  { ac_out=`sed -n '/^[	 ]*datarootdir[	 ]*:*=/p' \
      "$ac_tmp/out"`; test -z "$ac_out"; } &&
  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file contains a reference to the variable \`datarootdir'
which seems to be undefined.  Please make sure it is defined" >&5
$as_echo "$as_me: WARNING: $ac_file contains a reference to the variable \`datarootdir'
which seems to be undefined.  Please make sure it is defined" >&2;}

  rm -f "$ac_tmp/stdin"
  case $ac_file in
  -) cat "$ac_tmp/out" && rm -f "$ac_tmp/out";;
  *) rm -f "$ac_file" && mv "$ac_tmp/out" "$ac_file";;
  esac \
  || as_fn_error $? "could not create $ac_file" "$LINENO" 5
 ;;



  esac

done # for ac_tag


as_fn_exit 0
_ACEOF
ac_clean_files=$ac_clean_files_save

test $ac_write_fail = 0 ||
  as_fn_error $? "write failure creating $CONFIG_STATUS" "$LINENO" 5


# configure is writing to config.log, and then calls config.status.
# config.status does its own redirection, appending to config.log.
# Unfortunately, on DOS this fails, as config.log is still kept open
# by configure, so config.status won't be able to write to it; its
# output is simply discarded.  So we exec the FD to /dev/null,
# effectively closing config.log, so it can be properly (re)opened and
# appended to by config.status.  When coming back to configure, we
# need to make the FD available again.
if test "$no_create" != yes; then
  ac_cs_success=:
  ac_config_status_args=
  test "$silent" = yes &&
    ac_config_status_args="$ac_config_status_args --quiet"
  exec 5>/dev/null
  $SHELL $CONFIG_STATUS $ac_config_status_args || ac_cs_success=false
  exec 5>>config.log
  # Use ||, not &&, to avoid exiting from the if with $? = 1, which
  # would make configure fail if this is the last instruction.
  $ac_cs_success || as_fn_exit 1
fi
if test -n "$ac_unrecognized_opts" && test "$enable_option_checking" != no; then
  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: unrecognized options: $ac_unrecognized_opts" >&5
$as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2;}
fi


```

`configure.in`:

```in
dnl Process this file with autoconf to produce a configure script.
AC_INIT(fdlibm, , [freemint-discuss@lists.sourceforge.net], , [https://github.com/freemint/fdlibm])
AC_PREREQ(2.52)
AC_CONFIG_SRCDIR([include/fdlibm.h])
AC_CONFIG_AUX_DIR([config-aux])

dnl Canonical system information.
AC_CANONICAL_HOST

dnl Checks for programs.
AC_PROG_CC
AC_PROG_RANLIB
AC_CHECK_TOOL(AR, ar)
if test "$AR" = ""; then AC_MSG_ERROR([ar missing]); fi

dnl Checks for libraries.

dnl Checks for header files.
AC_CHECK_HEADERS(unistd.h)
AC_CHECK_LIB(m, cos)

dnl Checks for typedefs, structures, and compiler characteristics.
AC_C_CONST

dnl Checks for library functions.

AC_SUBST(ac_aux_dir)
AC_OUTPUT(Makefile)

```

`e_acos.c`:

```c
/* @(#)e_acos.c 1.3 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/* __ieee754_acos(x)
 * Method :                  
 *	acos(x)  = pi/2 - asin(x)
 *	acos(-x) = pi/2 + asin(x)
 * For |x|<=0.5
 *	acos(x) = pi/2 - (x + x*x^2*R(x^2))	(see asin.c)
 * For x>0.5
 * 	acos(x) = pi/2 - (pi/2 - 2asin(sqrt((1-x)/2)))
 *		= 2asin(sqrt((1-x)/2))  
 *		= 2s + 2s*z*R(z) 	...z=(1-x)/2, s=sqrt(z)
 *		= 2f + (2c + 2s*z*R(z))
 *     where f=hi part of s, and c = (z-f*f)/(s+f) is the correction term
 *     for f so that f+c ~ sqrt(z).
 * For x<-0.5
 *	acos(x) = pi - 2asin(sqrt((1-|x|)/2))
 *		= pi - 0.5*(s+s*z*R(z)), where z=(1-|x|)/2,s=sqrt(z)
 *
 * Special cases:
 *	if x is NaN, return x itself;
 *	if |x|>1, return NaN with invalid signal.
 *
 * Function needed: sqrt
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_acos

double __ieee754_acos(double x)
{
	double z, p, q, r, w, s, c, df;
	int32_t hx, ix;

	static const double one = 1.00000000000000000000e+00;	/* 0x3FF00000, 0x00000000 */
	static const double pi = 3.14159265358979311600e+00;	/* 0x400921FB, 0x54442D18 */
	static const double pio2_hi = 1.57079632679489655800e+00;	/* 0x3FF921FB, 0x54442D18 */
	static const double pio2_lo = 6.12323399573676603587e-17;	/* 0x3C91A626, 0x33145C07 */
	static const double pS0 = 1.66666666666666657415e-01;	/* 0x3FC55555, 0x55555555 */
	static const double pS1 = -3.25565818622400915405e-01;	/* 0xBFD4D612, 0x03EB6F7D */
	static const double pS2 = 2.01212532134862925881e-01;	/* 0x3FC9C155, 0x0E884455 */
	static const double pS3 = -4.00555345006794114027e-02;	/* 0xBFA48228, 0xB5688F3B */
	static const double pS4 = 7.91534994289814532176e-04;	/* 0x3F49EFE0, 0x7501B288 */
	static const double pS5 = 3.47933107596021167570e-05;	/* 0x3F023DE1, 0x0DFDF709 */
	static const double qS1 = -2.40339491173441421878e+00;	/* 0xC0033A27, 0x1C8A2D4B */
	static const double qS2 = 2.02094576023350569471e+00;	/* 0x40002AE5, 0x9C598AC8 */
	static const double qS3 = -6.88283971605453293030e-01;	/* 0xBFE6066C, 0x1B8D0159 */
	static const double qS4 = 7.70381505559019352791e-02;	/* 0x3FB3B8C5, 0xB12E9282 */
	
	GET_HIGH_WORD(hx, x);
	ix = hx & IC(0x7fffffff);
	if (ix >= IC(0x3ff00000))
	{									/* |x| >= 1 */
		uint32_t lx;

		GET_LOW_WORD(lx, x);
		if (((ix - IC(0x3ff00000)) | lx) == 0)
		{								/* |x|==1 */
			if (hx > 0)
				return 0.0;				/* acos(1) = 0  */
			else
				return pi + 2.0 * pio2_lo;	/* acos(-1)= pi */
		}
		return (x - x) / (x - x);		/* acos(|x|>1) is NaN */
	}

	if (ix < IC(0x3fe00000))
	{									/* |x| < 0.5 */
		if (ix <= IC(0x3c600000))
			return pio2_hi + pio2_lo;	/*if|x|<2**-57 */
		z = x * x;
		p = z * (pS0 + z * (pS1 + z * (pS2 + z * (pS3 + z * (pS4 + z * pS5)))));
		q = one + z * (qS1 + z * (qS2 + z * (qS3 + z * qS4)));
		r = p / q;
		return pio2_hi - (x - (pio2_lo - x * r));
	} else if (hx < 0)
	{									/* x < -0.5 */
		z = (one + x) * 0.5;
		p = z * (pS0 + z * (pS1 + z * (pS2 + z * (pS3 + z * (pS4 + z * pS5)))));
		q = one + z * (qS1 + z * (qS2 + z * (qS3 + z * qS4)));
		s = __ieee754_sqrt(z);
		r = p / q;
		w = r * s - pio2_lo;
		return pi - 2.0 * (s + w);
	} else
	{									/* x > 0.5 */
		z = (one - x) * 0.5;
		s = __ieee754_sqrt(z);
		df = s;
		SET_LOW_WORD(df, 0);
		c = (z - df * df) / (s + df);
		p = z * (pS0 + z * (pS1 + z * (pS2 + z * (pS3 + z * (pS4 + z * pS5)))));
		q = one + z * (qS1 + z * (qS2 + z * (qS3 + z * qS4)));
		r = p / q;
		w = r * s + c;
		return 2.0 * (df + w);
	}
}

#endif

/* wrapper acos */
double __acos(double x)
{
	if (_LIB_VERSION != _IEEE_ && isgreater(__ieee754_fabs(x), 1.0))
	{
		/* acos(|x|>1) */
		feraiseexcept(FE_INVALID);
		return __kernel_standard(x, x, __builtin_nan(""), KMATHERR_ACOS);
	}

	return __ieee754_acos(x);
}

__typeof(__acos) acos __attribute__((weak, alias("__acos")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(__acosl) __acosl __attribute__((alias("__acos")));
__typeof(__acosl) acosl __attribute__((weak, alias("__acos")));
#endif

```

`e_acosf.c`:

```c
/* e_acosf.c -- float version of e_acos.c.
 * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_acos

float __ieee754_acosf(float x)
{
	float z, p, q, r, w, s, c, df;
	int32_t hx, ix;

	static const float one = 1.0000000000e+00;			/* 0x3F800000 */
	static const float pi = 3.1415925026e+00;			/* 0x40490fda */
	static const float pio2_hi = 1.5707962513e+00;		/* 0x3fc90fda */
	static const float pio2_lo = 7.5497894159e-08;		/* 0x33a22168 */
	static const float pS0 = 1.6666667163e-01;			/* 0x3e2aaaab */
	static const float pS1 = -3.2556581497e-01;			/* 0xbea6b090 */
	static const float pS2 = 2.0121252537e-01;			/* 0x3e4e0aa8 */
	static const float pS3 = -4.0055535734e-02;			/* 0xbd241146 */
	static const float pS4 = 7.9153501429e-04;			/* 0x3a4f7f04 */
	static const float pS5 = 3.4793309169e-05;			/* 0x3811ef08 */
	static const float qS1 = -2.4033949375e+00;			/* 0xc019d139 */
	static const float qS2 = 2.0209457874e+00;			/* 0x4001572d */
	static const float qS3 = -6.8828397989e-01;			/* 0xbf303361 */
	static const float qS4 = 7.7038154006e-02;			/* 0x3d9dc62e */
	
	GET_FLOAT_WORD(hx, x);
	ix = hx & IC(0x7fffffff);
	if (ix == IC(0x3f800000))
	{									/* |x|==1 */
		if (hx > 0)
			return 0.0;					/* acos(1) = 0  */
		else
			return pi + 2.0f * pio2_lo;	/* acos(-1)= pi */
	} else if (ix > IC(0x3f800000))
	{									/* |x| >= 1 */
		return (x - x) / (x - x);		/* acos(|x|>1) is NaN */
	}
	if (ix < IC(0x3f000000))
	{									/* |x| < 0.5 */
		if (ix <= IC(0x32800000))
			return pio2_hi + pio2_lo;	/*if|x|<=2**-26 */
		z = x * x;
		p = z * (pS0 + z * (pS1 + z * (pS2 + z * (pS3 + z * (pS4 + z * pS5)))));
		q = one + z * (qS1 + z * (qS2 + z * (qS3 + z * qS4)));
		r = p / q;
		return pio2_hi - (x - (pio2_lo - x * r));
	} else if (hx < 0)
	{									/* x < -0.5 */
		z = (one + x) * 0.5f;
		p = z * (pS0 + z * (pS1 + z * (pS2 + z * (pS3 + z * (pS4 + z * pS5)))));
		q = one + z * (qS1 + z * (qS2 + z * (qS3 + z * qS4)));
		s = __ieee754_sqrtf(z);
		r = p / q;
		w = r * s - pio2_lo;
		return pi - 2.0f * (s + w);
	} else
	{									/* x > 0.5 */
		int32_t idf;

		z = (one - x) * 0.5f;
		s = __ieee754_sqrtf(z);
		df = s;
		GET_FLOAT_WORD(idf, df);
		SET_FLOAT_WORD(df, idf & IC(0xfffff000));
		c = (z - df * df) / (s + df);
		p = z * (pS0 + z * (pS1 + z * (pS2 + z * (pS3 + z * (pS4 + z * pS5)))));
		q = one + z * (qS1 + z * (qS2 + z * (qS3 + z * qS4)));
		r = p / q;
		w = r * s + c;
		return 2.0f * (df + w);
	}
}

#endif

/* wrapper acosf */
float __acosf(float x)
{
	if (isgreater(__ieee754_fabsf(x), 1.0f) && _LIB_VERSION != _IEEE_)
	{
		/* acos(|x|>1) */
		feraiseexcept(FE_INVALID);
		return __kernel_standard_f(x, x, __builtin_nanf(""), KMATHERRF_ACOS);
	}

	return __ieee754_acosf(x);
}

__typeof(__acosf) acosf __attribute__((weak, alias("__acosf")));

```

`e_acosh.c`:

```c
/* @(#)e_acosh.c 1.3 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/* __ieee754_acosh(x)
 * Method :
 *	Based on
 *		acosh(x) = log [ x + sqrt(x*x-1) ]
 *	we have
 *		acosh(x) := log(x)+ln2,	if x is large; else
 *		acosh(x) := log(2x-1/(sqrt(x*x-1)+x)) if x>2; else
 *		acosh(x) := log1p(t+sqrt(2.0*t+t*t)); where t=x-1.
 *
 * Special cases:
 *	acosh(x) is NaN with signal if x<1.
 *	acosh(NaN) is NaN without signal.
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_acosh

double __ieee754_acosh(double x)
{
	double t;
	int32_t hx;
	uint32_t lx;

	static const double one = 1.0;
	static const double ln2 = 6.93147180559945286227e-01;	/* 0x3FE62E42, 0xFEFA39EF */

	GET_DOUBLE_WORDS(hx, lx, x);
	if (hx < IC(0x3ff00000))
	{									/* x < 1 */
		return (x - x) / (x - x);
	} else if (hx >= IC(0x41b00000))
	{									/* x > 2**28 */
		if (hx >= IC(0x7ff00000))
		{								/* x is inf of NaN */
			return x + x;
		}
		return __ieee754_log(x) + ln2;	/* acosh(huge)=log(2x) */
	} else if (((hx - IC(0x3ff00000)) | lx) == 0)
	{
		return 0.0;						/* acosh(1) = 0 */
	} else if (hx > IC(0x40000000))
	{									/* 2**28 > x > 2 */
		t = x * x;
		return __ieee754_log(2.0 * x - one / (x + __ieee754_sqrt(t - one)));
	} else
	{									/* 1<x<2 */
		t = x - one;
		return __ieee754_log1p(t + __ieee754_sqrt(2.0 * t + t * t));
	}
}

#endif

/* wrapper acosh */
double __acosh(double x)
{
	if (_LIB_VERSION != _IEEE_ && isless(x, 1.0))
		/* acosh(x<1) */
		return __kernel_standard(x, x, __builtin_nan(""), KMATHERR_ACOSH);

	return __ieee754_acosh(x);
}

__typeof(__acosh) acosh __attribute__((weak, alias("__acosh")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(__acoshl) __acoshl __attribute__((alias("__acosh")));
__typeof(__acoshl) acoshl __attribute__((weak, alias("__acosh")));
#endif

```

`e_acoshf.c`:

```c
/* e_acoshf.c -- float version of e_acosh.c.
 * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_acosh

float __ieee754_acoshf(float x)
{
	float t;
	int32_t hx;

	static const float one = 1.0;
	static const float ln2 = 6.9314718246e-01;				/* 0x3f317218 */

	GET_FLOAT_WORD(hx, x);
	if (hx < IC(0x3f800000))
	{									/* x < 1 */
		return (x - x) / (x - x);
	} else if (hx >= IC(0x4d800000))
	{									/* x > 2**28 */
		if (!FLT_UWORD_IS_FINITE(hx))
		{								/* x is inf of NaN */
			return x + x;
		}
		return __ieee754_logf(x) + ln2;	/* acosh(huge)=log(2x) */
	} else if (hx == IC(0x3f800000))
	{
		return 0.0f;					/* acosh(1) = 0 */
	} else if (hx > IC(0x40000000))
	{									/* 2**28 > x > 2 */
		t = x * x;
		return __ieee754_logf(2.0F * x - one / (x + __ieee754_sqrtf(t - one)));
	} else
	{									/* 1<x<2 */
		t = x - one;
		return __ieee754_log1pf(t + __ieee754_sqrtf(2.0F * t + t * t));
	}
}

#endif

/* wrapper acoshf */
float __acoshf(float x)
{
	if (isless(x, 1.0f) && _LIB_VERSION != _IEEE_)
		/* acosh(x<1) */
		return __kernel_standard_f(x, x, __builtin_nanf(""), KMATHERRF_ACOSH);

	return __ieee754_acoshf(x);
}

__typeof(__acoshf) acoshf __attribute__((weak, alias("__acoshf")));

```

`e_acoshl.c`:

```c
/* e_acoshl.c -- long double version of e_acosh.c.
 * Conversion to long double by Ulrich Drepper,
 * Cygnus Support, drepper@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/* __ieee754_acoshl(x)
 * Method :
 *	Based on
 *		acoshl(x) = logl [ x + sqrtl(x*x-1) ]
 *	we have
 *		acoshl(x) := logl(x)+ln2,	if x is large; else
 *		acoshl(x) := logl(2x-1/(sqrtl(x*x-1)+x)) if x>2; else
 *		acoshl(x) := log1pl(t+sqrtl(2.0*t+t*t)); where t=x-1.
 *
 * Special cases:
 *	acoshl(x) is NaN with signal if x<1.
 *	acoshl(NaN) is NaN without signal.
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

#ifndef __have_fpu_acosh

long double __ieee754_acoshl(long double x)
{
	long double t;
	uint32_t se, i0, i1;

	static const long double one = 1.0;
	static const long double ln2 = 6.931471805599453094287e-01L;	/* 0x3FFE, 0xB17217F7, 0xD1CF79AC */
	
	GET_LDOUBLE_WORDS(se, i0, i1, x);
	if (se < 0x3fff || (se & 0x8000))
	{									/* x < 1 */
		return (x - x) / (x - x);
	} else if (se >= 0x401d)
	{									/* x > 2**30 */
		if (se >= 0x7fff)
		{								/* x is inf of NaN */
			return x + x;
		} else
			return __ieee754_logl(x) + ln2;	/* acoshl(huge)=logl(2x) */
	} else if (((se - 0x3fff) | i0 | i1) == 0)
	{
		return 0.0;						/* acosh(1) = 0 */
	} else if (se > 0x4000)
	{									/* 2**28 > x > 2 */
		t = x * x;
		return __ieee754_logl(2.0 * x - one / (x + __ieee754_sqrtl(t - one)));
	} else
	{									/* 1<x<2 */
		t = x - one;
		return __ieee754_log1pl(t + __ieee754_sqrtl(2.0 * t + t * t));
	}
}

#endif

/* wrapper acosl */
long double __acoshl(long double x)
{
	if (isless(x, 1.0L) && _LIB_VERSION != _IEEE_)
		/* acosh(x<1) */
		return __kernel_standard_l(x, x, __builtin_nanl(""), KMATHERRL_ACOSH);

	return __ieee754_acoshl(x);
}

__typeof(__acoshl) acoshl __attribute__((weak, alias("__acoshl")));

#endif

```

`e_acosl.c`:

```c
#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

#ifndef __have_fpu_acos

long double __ieee754_acosl(long double x)
{
	long double y;
	
	if (x == 0.0)
		return M_PI_2l;
	if (x == 1.0)
		return 0.0;
	if (x == -1.0)
		return M_PIl;
	y = __ieee754_atanl(__ieee754_sqrtl(1.0L - (x * x)) / x);
	if (x > 0.0)
		return y;
	return y + M_PIl;
}

#endif

/* wrapper acosl */
long double __acosl(long double x)
{
	if (isgreater(__ieee754_fabsl(x), 1.0L) && _LIB_VERSION != _IEEE_)
	{
		/* acos(|x|>1) */
		feraiseexcept(FE_INVALID);
		return __kernel_standard_l(x, x, __builtin_nanl(""), KMATHERRL_ACOS);
	}

	return __ieee754_acosl(x);
}

__typeof(__acosl) acosl __attribute__((weak, alias("__acosl")));

#endif

```

`e_asin.c`:

```c
/* @(#)e_asin.c 1.3 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/* __ieee754_asin(x)
 * Method :                  
 *	Since  asin(x) = x + x^3/6 + x^5*3/40 + x^7*15/336 + ...
 *	we approximate asin(x) on [0,0.5] by
 *		asin(x) = x + x*x^2*R(x^2)
 *	where
 *		R(x^2) is a rational approximation of (asin(x)-x)/x^3 
 *	and its remez error is bounded by
 *		|(asin(x)-x)/x^3 - R(x^2)| < 2^(-58.75)
 *
 *	For x in [0.5,1]
 *		asin(x) = pi/2-2*asin(sqrt((1-x)/2))
 *	Let y = (1-x), z = y/2, s := sqrt(z), and pio2_hi+pio2_lo=pi/2;
 *	then for x>0.98
 *		asin(x) = pi/2 - 2*(s+s*z*R(z))
 *			= pio2_hi - (2*(s+s*z*R(z)) - pio2_lo)
 *	For x<=0.98, let pio4_hi = pio2_hi/2, then
 *		f = hi part of s;
 *		c = sqrt(z) - f = (z-f*f)/(s+f) 	...f+c=sqrt(z)
 *	and
 *		asin(x) = pi/2 - 2*(s+s*z*R(z))
 *			= pio4_hi+(pio4-2s)-(2s*z*R(z)-pio2_lo)
 *			= pio4_hi+(pio4-2f)-(2s*z*R(z)-(pio2_lo+2c))
 *
 * Special cases:
 *	if x is NaN, return x itself;
 *	if |x|>1, return NaN with invalid signal.
 *
 */


#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_asin

double __ieee754_asin(double x)
{
	double t, w, p, q, c, r, s;
	int32_t hx, ix;

	static const double one = 1.00000000000000000000e+00;		/* 0x3FF00000, 0x00000000 */
	static const double hugeval = 1.000e+300;
	static const double pio2_hi = 1.57079632679489655800e+00;	/* 0x3FF921FB, 0x54442D18 */
	static const double pio2_lo = 6.12323399573676603587e-17;	/* 0x3C91A626, 0x33145C07 */
	static const double pio4_hi = 7.85398163397448278999e-01;	/* 0x3FE921FB, 0x54442D18 */
	/* coefficient for R(x^2) */
	static const double pS0 = 1.66666666666666657415e-01;	/* 0x3FC55555, 0x55555555 */
	static const double pS1 = -3.25565818622400915405e-01;	/* 0xBFD4D612, 0x03EB6F7D */
	static const double pS2 = 2.01212532134862925881e-01;	/* 0x3FC9C155, 0x0E884455 */
	static const double pS3 = -4.00555345006794114027e-02;	/* 0xBFA48228, 0xB5688F3B */
	static const double pS4 = 7.91534994289814532176e-04;	/* 0x3F49EFE0, 0x7501B288 */
	static const double pS5 = 3.47933107596021167570e-05;	/* 0x3F023DE1, 0x0DFDF709 */
	static const double qS1 = -2.40339491173441421878e+00;	/* 0xC0033A27, 0x1C8A2D4B */
	static const double qS2 = 2.02094576023350569471e+00;	/* 0x40002AE5, 0x9C598AC8 */
	static const double qS3 = -6.88283971605453293030e-01;	/* 0xBFE6066C, 0x1B8D0159 */
	static const double qS4 = 7.70381505559019352791e-02;	/* 0x3FB3B8C5, 0xB12E9282 */

	GET_HIGH_WORD(hx, x);
	ix = hx & IC(0x7fffffff);
	if (ix >= IC(0x3ff00000))
	{									/* |x|>= 1 */
		uint32_t lx;

		GET_LOW_WORD(lx, x);
		if (((ix - IC(0x3ff00000)) | lx) == 0)
			/* asin(1)=+-pi/2 with inexact */
			return x * pio2_hi + x * pio2_lo;
		return (x - x) / (x - x);		/* asin(|x|>1) is NaN */
	} else if (ix < IC(0x3fe00000))
	{									/* |x|<0.5 */
		if (ix < IC(0x3e400000))
		{								/* if |x| < 2**-27 */
			if (hugeval + x > one)
				return x;				/* return x with inexact if x!=0 */
		} else
		{
			t = x * x;
			p = t * (pS0 + t * (pS1 + t * (pS2 + t * (pS3 + t * (pS4 + t * pS5)))));
			q = one + t * (qS1 + t * (qS2 + t * (qS3 + t * qS4)));
			w = p / q;
			return x + x * w;
		}
	}
	/* 1> |x|>= 0.5 */
	w = one - __ieee754_fabs(x);
	t = w * 0.5;
	p = t * (pS0 + t * (pS1 + t * (pS2 + t * (pS3 + t * (pS4 + t * pS5)))));
	q = one + t * (qS1 + t * (qS2 + t * (qS3 + t * qS4)));
	s = __ieee754_sqrt(t);
	if (ix >= IC(0x3FEF3333))
	{									/* if |x| > 0.975 */
		w = p / q;
		t = pio2_hi - (2.0 * (s + s * w) - pio2_lo);
	} else
	{
		w = s;
		SET_LOW_WORD(w, 0);
		c = (t - w * w) / (s + w);
		r = p / q;
		p = 2.0 * s * r - (pio2_lo - 2.0 * c);
		q = pio4_hi - 2.0 * w;
		t = pio4_hi - (p - q);
	}
	if (hx > 0)
		return t;
	return -t;
}

#endif

/* wrapper asin */
double __asin(double x)
{
	if (_LIB_VERSION != _IEEE_ && isgreater(__ieee754_fabs(x), 1.0))
	{
		/* asin(|x|>1) */
		feraiseexcept(FE_INVALID);
		return __kernel_standard(x, x, __builtin_nan(""), KMATHERR_ASIN);
	}

	return __ieee754_asin(x);
}

__typeof(__asin) asin __attribute__((weak, alias("__asin")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(__asinl) __asinl __attribute__((alias("__asin")));
__typeof(__asinl) asinl __attribute__((weak, alias("__asin")));
#endif

```

`e_asinf.c`:

```c
/* e_asinf.c -- float version of e_asin.c.
 * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/*
  Modifications for single precision expansion are
  Copyright (C) 2001 Stephen L. Moshier <moshier@na-net.ornl.gov>
  and are incorporated herein by permission of the author.  The author
  reserves the right to distribute this material elsewhere under different
  copying permissions.  These modifications are distributed here under
  the following terms:

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, see
    <http://www.gnu.org/licenses/>.  */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_asin

float __ieee754_asinf(float x)
{
	float t, w, p, q, c, r, s;
	int32_t hx, ix;

	static const float one = 1.0000000000e+00;	/* 0x3F800000 */
	static const float hugeval = 1.000e+30;
	static const float pio2_hi = 1.57079637050628662109375f;
	static const float pio2_lo = -4.37113900018624283e-8f;
	static const float pio4_hi = 0.785398185253143310546875f;
	/* asin x = x + x^3 p(x^2)
	   -0.5 <= x <= 0.5;
	   Peak relative error 4.8e-9 */
	static const float p0 = 1.666675248e-1f;
	static const float p1 = 7.495297643e-2f;
	static const float p2 = 4.547037598e-2f;
	static const float p3 = 2.417951451e-2f;
	static const float p4 = 4.216630880e-2f;
	
	GET_FLOAT_WORD(hx, x);
	ix = hx & IC(0x7fffffff);
	if (ix == IC(0x3f800000))
	{
		/* asin(1)=+-pi/2 with inexact */
		return x * pio2_hi + x * pio2_lo;
	} else if (ix > IC(0x3f800000))
	{									/* |x|>= 1 */
		return (x - x) / (x - x);		/* asin(|x|>1) is NaN */
	} else if (ix < IC(0x3f000000))
	{									/* |x|<0.5 */
		if (ix < IC(0x32000000))
		{								/* if |x| < 2**-27 */
			if (hugeval + x > one)
				return x;				/* return x with inexact if x!=0 */
		} else
		{
			t = x * x;
			w = t * (p0 + t * (p1 + t * (p2 + t * (p3 + t * p4))));
			return x + x * w;
		}
	}
	/* 1> |x|>= 0.5 */
	w = one - __ieee754_fabsf(x);
	t = w * 0.5f;
	p = t * (p0 + t * (p1 + t * (p2 + t * (p3 + t * p4))));
	s = __ieee754_sqrtf(t);
	if (ix >= IC(0x3F79999A))
	{									/* if |x| > 0.975 */
		t = pio2_hi - (2.0f * (s + s * p) - pio2_lo);
	} else
	{
		int32_t iw;

		w = s;
		GET_FLOAT_WORD(iw, w);
		SET_FLOAT_WORD(w, iw & IC(0xfffff000));
		c = (t - w * w) / (s + w);
		r = p;
		p = 2.0f * s * r - (pio2_lo - 2.0f * c);
		q = pio4_hi - 2.0f * w;
		t = pio4_hi - (p - q);
	}
	if (hx > 0)
		return t;
	return -t;
}

#endif

/* wrapper asin */
float __asinf(float x)
{
	if (isgreater(__ieee754_fabsf(x), 1.0) && _LIB_VERSION != _IEEE_)
	{
		/* asin(|x|>1) */
		feraiseexcept(FE_INVALID);
		return __kernel_standard_f(x, x, __builtin_nanf(""), KMATHERRF_ASIN);
	}

	return __ieee754_asinf(x);
}

__typeof(__asinf) asinf __attribute__((weak, alias("__asinf")));

```

`e_asinl.c`:

```c
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/*
  Long double expansions are
  Copyright (C) 2001 Stephen L. Moshier <moshier@na-net.ornl.gov>
  and are incorporated herein by permission of the author.  The author
  reserves the right to distribute this material elsewhere under different
  copying permissions.  These modifications are distributed here under
  the following terms:

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, see
    <http://www.gnu.org/licenses/>.  */

/* __ieee754_asin(x)
 * Method :
 *	Since  asin(x) = x + x^3/6 + x^5*3/40 + x^7*15/336 + ...
 *	we approximate asin(x) on [0,0.5] by
 *		asin(x) = x + x*x^2*R(x^2)
 *
 *	For x in [0.5,1]
 *		asin(x) = pi/2-2*asin(sqrt((1-x)/2))
 *	Let y = (1-x), z = y/2, s := sqrt(z), and pio2_hi+pio2_lo=pi/2;
 *	then for x>0.98
 *		asin(x) = pi/2 - 2*(s+s*z*R(z))
 *			= pio2_hi - (2*(s+s*z*R(z)) - pio2_lo)
 *	For x<=0.98, let pio4_hi = pio2_hi/2, then
 *		f = hi part of s;
 *		c = sqrt(z) - f = (z-f*f)/(s+f)		...f+c=sqrt(z)
 *	and
 *		asin(x) = pi/2 - 2*(s+s*z*R(z))
 *			= pio4_hi+(pio4-2s)-(2s*z*R(z)-pio2_lo)
 *			= pio4_hi+(pio4-2f)-(2s*z*R(z)-(pio2_lo+2c))
 *
 * Special cases:
 *	if x is NaN, return x itself;
 *	if |x|>1, return NaN with invalid signal.
 *
 */


#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

#ifndef __have_fpu_asin

long double __ieee754_asinl(long double x)
{
	long double t, w, p, q, c, r, s;
	int32_t ix;
	uint32_t se, i0, i1, k;

	static const long double one = 1.0L;
	static const long double hugeval = 1.0e+4932L;
	static const long double pio2_hi = 0x1.921fb54442d1846ap+0L;	/* pi/2 rounded to nearest to 64 bits.  */
	static const long double pio2_lo = -0x7.6733ae8fe47c65d8p-68L;	/* pi/2 - pio2_hi rounded to nearest to 64 bits.  */
	static const long double pio4_hi = 0xc.90fdaa22168c235p-4L;		/* pi/4 rounded to nearest to 64 bits.  */
	/* coefficient for R(x^2) */
	/* asin(x) = x + x^3 pS(x^2) / qS(x^2)
	   0 <= x <= 0.5
	   peak relative error 1.9e-21  */
	static const long double pS0 = -1.008714657938491626019651170502036851607E1L;
	static const long double pS1 = 2.331460313214179572063441834101394865259E1L;
	static const long double pS2 = -1.863169762159016144159202387315381830227E1L;
	static const long double pS3 = 5.930399351579141771077475766877674661747E0L;
	static const long double pS4 = -6.121291917696920296944056882932695185001E-1L;
	static const long double pS5 = 3.776934006243367487161248678019350338383E-3L;
	static const long double qS0 = -6.052287947630949712886794360635592886517E1L;
	static const long double qS1 = 1.671229145571899593737596543114258558503E2L;
	static const long double qS2 = -1.707840117062586426144397688315411324388E2L;
	static const long double qS3 = 7.870295154902110425886636075950077640623E1L;
	static const long double qS4 = -1.568433562487314651121702982333303458814E1L;
	/* 1.000000000000000000000000000000000000000E0 */
	
	GET_LDOUBLE_WORDS(se, i0, i1, x);
	ix = se & 0x7fff;
	ix = (ix << 16) | (i0 >> 16);
	if (ix >= IC(0x3fff8000))
	{									/* |x|>= 1 */
		if (ix == IC(0x3fff8000) && ((i0 - UC(0x80000000)) | i1) == 0)
			/* asin(1)=+-pi/2 with inexact */
			return x * pio2_hi + x * pio2_lo;
		return (x - x) / (x - x);		/* asin(|x|>1) is NaN */
	} else if (ix < IC(0x3ffe8000))
	{									/* |x|<0.5 */
		if (ix < IC(0x3fde8000))
		{								/* if |x| < 2**-33 */
			if (hugeval + x > one)
				return x;				/* return x with inexact if x!=0 */
		} else
		{
			t = x * x;
			p = t * (pS0 + t * (pS1 + t * (pS2 + t * (pS3 + t * (pS4 + t * pS5)))));
			q = qS0 + t * (qS1 + t * (qS2 + t * (qS3 + t * (qS4 + t))));
			w = p / q;
			return x + x * w;
		}
	}
	/* 1> |x|>= 0.5 */
	w = one - __ieee754_fabsl(x);
	t = w * 0.5;
	p = t * (pS0 + t * (pS1 + t * (pS2 + t * (pS3 + t * (pS4 + t * pS5)))));
	q = qS0 + t * (qS1 + t * (qS2 + t * (qS3 + t * (qS4 + t))));
	s = __ieee754_sqrtl(t);
	if (ix >= IC(0x3ffef999))
	{									/* if |x| > 0.975 */
		w = p / q;
		t = pio2_hi - (2.0 * (s + s * w) - pio2_lo);
	} else
	{
		GET_LDOUBLE_WORDS(k, i0, i1, s);
		i1 = 0;
		SET_LDOUBLE_WORDS(w, k, i0, i1);
		c = (t - w * w) / (s + w);
		r = p / q;
		p = 2.0 * s * r - (pio2_lo - 2.0 * c);
		q = pio4_hi - 2.0 * w;
		t = pio4_hi - (p - q);
	}
	if ((se & 0x8000) == 0)
		return t;
	return -t;
}

#endif

/* wrapper asin */
long double __asinl(long double  x)
{
	if (isgreater(__ieee754_fabsl(x), 1.0) && _LIB_VERSION != _IEEE_)
	{
		/* asin(|x|>1) */
		feraiseexcept(FE_INVALID);
		return __kernel_standard_l(x, x, __builtin_nanl(""), KMATHERRL_ASIN);
	}

	return __ieee754_asinl(x);
}

__typeof(__asinl) asinl __attribute__((weak, alias("__asinl")));

#endif

```

`e_atan2.c`:

```c
/* @(#)e_atan2.c 1.3 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 *
 */

/* __ieee754_atan2(y,x)
 * Method :
 *	1. Reduce y to positive by atan2(y,x)=-atan2(-y,x).
 *	2. Reduce x to positive by (if x and y are unexceptional): 
 *		ARG (x+iy) = arctan(y/x)   	   ... if x > 0,
 *		ARG (x+iy) = pi - arctan[y/(-x)]   ... if x < 0,
 *
 * Special cases:
 *
 *	ATAN2((anything), NaN ) is NaN;
 *	ATAN2(NAN , (anything) ) is NaN;
 *	ATAN2(+-0, +(anything but NaN)) is +-0  ;
 *	ATAN2(+-0, -(anything but NaN)) is +-pi ;
 *	ATAN2(+-(anything but 0 and NaN), 0) is +-pi/2;
 *	ATAN2(+-(anything but INF and NaN), +INF) is +-0 ;
 *	ATAN2(+-(anything but INF and NaN), -INF) is +-pi;
 *	ATAN2(+-INF,+INF ) is +-pi/4 ;
 *	ATAN2(+-INF,-INF ) is +-3pi/4;
 *	ATAN2(+-INF, (anything but,0,NaN, and INF)) is +-pi/2;
 *
 * Constants:
 * The hexadecimal values are the intended ones for the following 
 * constants. The decimal values may be used, provided that the 
 * compiler will convert from decimal to binary accurately enough 
 * to produce the hexadecimal values shown.
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_atan2

double __ieee754_atan2(double y, double x)
{
	double z;
	int32_t k, m, hx, hy, ix, iy;
	uint32_t lx, ly;

	static const double tiny = 1.0e-300;
	static const double zero = 0.0;
	static const double pi_o_4 = 7.8539816339744827900E-01;	/* 0x3FE921FB, 0x54442D18 */
	static const double pi_o_2 = 1.5707963267948965580E+00;	/* 0x3FF921FB, 0x54442D18 */
	static const double pi = 3.1415926535897931160E+00;		/* 0x400921FB, 0x54442D18 */
	static const double pi_lo = 1.2246467991473531772E-16;	/* 0x3CA1A626, 0x33145C07 */

	GET_DOUBLE_WORDS(hx, lx, x);
	ix = hx & IC(0x7fffffff);
	GET_DOUBLE_WORDS(hy, ly, y);
	iy = hy & IC(0x7fffffff);
	if (((ix | ((lx | -lx) >> 31)) > IC(0x7ff00000)) || ((iy | ((ly | -ly) >> 31)) > IC(0x7ff00000)))	/* x or y is NaN */
		return x + y;
	if (((hx - IC(0x3ff00000)) | lx) == 0)
		return __ieee754_atan(y);					/* x=1.0 */
	m = ((hy >> 31) & 1) | ((hx >> 30) & 2);	/* 2*sign(x)+sign(y) */

	/* when y = 0 */
	if ((iy | ly) == 0)
	{
		switch ((int)m)
		{
		case 0:
		case 1:
			return y;					/* atan(+-0,+anything)=+-0 */
		case 2:
			return pi + tiny;			/* atan(+0,-anything) = pi */
		case 3:
			return -pi - tiny;			/* atan(-0,-anything) =-pi */
		}
	}
	/* when x = 0 */
	if ((ix | lx) == 0)
		return (hy < 0) ? -pi_o_2 - tiny : pi_o_2 + tiny;

	/* when x is INF */
	if (ix == IC(0x7ff00000))
	{
		if (iy == IC(0x7ff00000))
		{
			switch ((int)m)
			{
			case 0:
				return pi_o_4 + tiny;	/* atan(+INF,+INF) */
			case 1:
				return -pi_o_4 - tiny;	/* atan(-INF,+INF) */
			case 2:
				return 3.0 * pi_o_4 + tiny;	/*atan(+INF,-INF) */
			case 3:
				return -3.0 * pi_o_4 - tiny;	/*atan(-INF,-INF) */
			}
		} else
		{
			switch ((int)m)
			{
			case 0:
				return zero;			/* atan(+...,+INF) */
			case 1:
				return -zero;			/* atan(-...,+INF) */
			case 2:
				return pi + tiny;		/* atan(+...,-INF) */
			case 3:
				return -pi - tiny;		/* atan(-...,-INF) */
			}
		}
	}
	/* when y is INF */
	if (iy == IC(0x7ff00000))
		return (hy < 0) ? -pi_o_2 - tiny : pi_o_2 + tiny;

	/* compute y/x */
	k = (iy - ix) >> 20;
	if (k > 60)
		z = pi_o_2 + 0.5 * pi_lo;		/* |y/x| >  2**60 */
	else if (hx < 0 && k < -60)
		z = 0.0;						/* |y|/x < -2**60 */
	else
		z = __ieee754_atan(__ieee754_fabs(y / x));			/* safe to do y/x */
	switch ((int)m)
	{
	case 0:
		return z;						/* atan(+,+) */
	case 1:
		{
			uint32_t zh;

			GET_HIGH_WORD(zh, z);
			SET_HIGH_WORD(z, zh ^ UC(0x80000000));
		}
		return z;						/* atan(-,+) */
	case 2:
		return pi - (z - pi_lo);		/* atan(+,-) */
	default:							/* case 3 */
		return (z - pi_lo) - pi;		/* atan(-,-) */
	}
}

#endif

double __atan2(double y, double x)	/* wrapper atan2 */
{
	if (_LIB_VERSION == _SVID_ && x == 0.0 && y == 0.0)
		return __kernel_standard(y, x, HUGE_VAL, KMATHERR_ATAN2);	/* atan2(+-0,+-0) */

	return __ieee754_atan2(y, x);
}

__typeof(__atan2) atan2 __attribute__((weak, alias("__atan2")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(__atan2l) __atan2l __attribute__((alias("__atan2")));
__typeof(__atan2l) atan2l __attribute__((weak, alias("__atan2")));
#endif

```

`e_atan2f.c`:

```c
/* e_atan2f.c -- float version of e_atan2.c.
 * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_atan2

float __ieee754_atan2f(float y, float x)
{
	float z;
	int32_t k, m, hx, hy, ix, iy;

	static const float tiny = 1.0e-30;
	static const float zero = 0.0;
	static const float pi_o_4 = 7.8539818525e-01;			/* 0x3f490fdb */
	static const float pi_o_2 = 1.5707963705e+00;			/* 0x3fc90fdb */
	static const float pi = 3.1415927410e+00;				/* 0x40490fdb */
	static const float pi_lo = -8.7422776573e-08;			/* 0xb3bbbd2e */
	
	GET_FLOAT_WORD(hx, x);
	ix = hx & IC(0x7fffffff);
	GET_FLOAT_WORD(hy, y);
	iy = hy & IC(0x7fffffff);
	if (FLT_UWORD_IS_NAN(ix) || FLT_UWORD_IS_NAN(iy))	/* x or y is NaN */
		return x + y;
	if (hx == IC(0x3f800000))
		return __ieee754_atanf(y);				/* x=1.0 */
	m = ((hy >> 31) & 1) | ((hx >> 30) & 2);	/* 2*sign(x)+sign(y) */

	/* when y = 0 */
	if (FLT_UWORD_IS_ZERO(iy))
	{
		switch ((int)m)
		{
		case 0:
		case 1:
			return y;					/* atan(+-0,+anything)=+-0 */
		case 2:
			return pi + tiny;			/* atan(+0,-anything) = pi */
		case 3:
			return -pi - tiny;			/* atan(-0,-anything) =-pi */
		}
	}
	/* when x = 0 */
	if (FLT_UWORD_IS_ZERO(ix))
		return (hy < 0) ? -pi_o_2 - tiny : pi_o_2 + tiny;

	/* when x is INF */
	if (FLT_UWORD_IS_INFINITE(ix))
	{
		if (FLT_UWORD_IS_INFINITE(iy))
		{
			switch ((int)m)
			{
			case 0:
				return pi_o_4 + tiny;	/* atan(+INF,+INF) */
			case 1:
				return -pi_o_4 - tiny;	/* atan(-INF,+INF) */
			case 2:
				return (float) 3.0 *pi_o_4 + tiny;	/*atan(+INF,-INF) */

			case 3:
				return (float) -3.0 * pi_o_4 - tiny;	/*atan(-INF,-INF) */
			}
		} else
		{
			switch ((int)m)
			{
			case 0:
				return zero;			/* atan(+...,+INF) */
			case 1:
				return -zero;			/* atan(-...,+INF) */
			case 2:
				return pi + tiny;		/* atan(+...,-INF) */
			case 3:
				return -pi - tiny;		/* atan(-...,-INF) */
			}
		}
	}
	/* when y is INF */
	if (FLT_UWORD_IS_INFINITE(iy))
		return (hy < 0) ? -pi_o_2 - tiny : pi_o_2 + tiny;

	/* compute y/x */
	k = (iy - ix) >> 23;
	if (k > 60)
		z = pi_o_2 + (float) 0.5 *pi_lo;	/* |y/x| >  2**60 */

	else if (hx < 0 && k < -60)
		z = 0.0;						/* |y|/x < -2**60 */
	else
		z = __ieee754_atanf(__ieee754_fabsf(y / x));		/* safe to do y/x */
	switch ((int)m)
	{
	case 0:
		return z;						/* atan(+,+) */
	case 1:
		{
			uint32_t zh;

			GET_FLOAT_WORD(zh, z);
			SET_FLOAT_WORD(z, zh ^ UC(0x80000000));
		}
		return z;						/* atan(-,+) */
	case 2:
		return pi - (z - pi_lo);		/* atan(+,-) */
	default:							/* case 3 */
		return (z - pi_lo) - pi;		/* atan(-,-) */
	}
}

#endif

float __atan2f(float y, float x)
{
	if (x == 0.0f && y == 0.0f && _LIB_VERSION == _SVID_)
		return __kernel_standard_f(y, x, HUGE_VALF, KMATHERRF_ATAN2);	/* atan2(+-0,+-0) */

	return __ieee754_atan2f(y, x);
}

__typeof(__atan2f) atan2f __attribute__((weak, alias("__atan2f")));

```

`e_atan2l.c`:

```c
/* e_atan2l.c -- long double version of e_atan2.c.
 * Conversion to long double by Ulrich Drepper,
 * Cygnus Support, drepper@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/* __ieee754_atan2l(y,x)
 * Method :
 *	1. Reduce y to positive by atan2(y,x)=-atan2(-y,x).
 *	2. Reduce x to positive by (if x and y are unexceptional):
 *		ARG (x+iy) = arctan(y/x)	   ... if x > 0,
 *		ARG (x+iy) = pi - arctan[y/(-x)]   ... if x < 0,
 *
 * Special cases:
 *
 *	ATAN2((anything), NaN ) is NaN;
 *	ATAN2(NAN , (anything) ) is NaN;
 *	ATAN2(+-0, +(anything but NaN)) is +-0  ;
 *	ATAN2(+-0, -(anything but NaN)) is +-pi ;
 *	ATAN2(+-(anything but 0 and NaN), 0) is +-pi/2;
 *	ATAN2(+-(anything but INF and NaN), +INF) is +-0 ;
 *	ATAN2(+-(anything but INF and NaN), -INF) is +-pi;
 *	ATAN2(+-INF,+INF ) is +-pi/4 ;
 *	ATAN2(+-INF,-INF ) is +-3pi/4;
 *	ATAN2(+-INF, (anything but,0,NaN, and INF)) is +-pi/2;
 *
 * Constants:
 * The hexadecimal values are the intended ones for the following
 * constants. The decimal values may be used, provided that the
 * compiler will convert from decimal to binary accurately enough
 * to produce the hexadecimal values shown.
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

#ifndef __have_fpu_atan2

long double __ieee754_atan2l(long double y, long double x)
{
	long double z;
	int32_t k, m, hx, hy, ix, iy;
	uint32_t sx, sy, lx, ly;

	static const long double tiny = 1.0e-4900L;
	static const long double zero = 0.0;
	static const long double pi_o_4 = 7.85398163397448309628202E-01L;	/* 0x3FFE, 0xC90FDAA2, 0x2168C235 */
	static const long double pi_o_2 = 1.5707963267948966192564E+00L;	/* 0x3FFF, 0xC90FDAA2, 0x2168C235 */
	static const long double pi = 3.14159265358979323851281E+00L;		/* 0x4000, 0xC90FDAA2, 0x2168C235 */
	static const long double pi_lo = -5.01655761266833202345176e-20L;	/* 0xBFBE, 0xECE675D1, 0xFC8F8CBB */
	
	GET_LDOUBLE_WORDS(sx, hx, lx, x);
	ix = sx & 0x7fff;
	lx |= hx & IC(0x7fffffff);
	GET_LDOUBLE_WORDS(sy, hy, ly, y);
	iy = sy & 0x7fff;
	ly |= hy & IC(0x7fffffff);
	if (((2 * ix | ((lx | -lx) >> 31)) > UC(0xfffe)) || ((2 * iy | ((ly | -ly) >> 31)) > UC(0xfffe)))	/* x or y is NaN */
		return x + y;
	if (((sx - 0x3fff) | lx) == 0)
		return __ieee754_atanl(y);				/* x=1.0 */
	m = ((sy >> 15) & 1) | ((sx >> 14) & 2);	/* 2*sign(x)+sign(y) */

	/* when y = 0 */
	if ((iy | ly) == 0)
	{
		switch ((int)m)
		{
		case 0:
		case 1:
			return y;					/* atan(+-0,+anything)=+-0 */
		case 2:
			return pi + tiny;			/* atan(+0,-anything) = pi */
		case 3:
			return -pi - tiny;			/* atan(-0,-anything) =-pi */
		}
	}
	/* when x = 0 */
	if ((ix | lx) == 0)
		return (sy & 0x8000) ? -pi_o_2 - tiny : pi_o_2 + tiny;

	/* when x is INF */
	if (ix == 0x7fff)
	{
		if (iy == 0x7fff)
		{
			switch ((int)m)
			{
			case 0:
				return pi_o_4 + tiny;	/* atan(+INF,+INF) */
			case 1:
				return -pi_o_4 - tiny;	/* atan(-INF,+INF) */
			case 2:
				return 3.0 * pi_o_4 + tiny;	/*atan(+INF,-INF) */
			case 3:
				return -3.0 * pi_o_4 - tiny;	/*atan(-INF,-INF) */
			}
		} else
		{
			switch ((int)m)
			{
			case 0:
				return zero;			/* atan(+...,+INF) */
			case 1:
				return -zero;			/* atan(-...,+INF) */
			case 2:
				return pi + tiny;		/* atan(+...,-INF) */
			case 3:
				return -pi - tiny;		/* atan(-...,-INF) */
			}
		}
	}
	/* when y is INF */
	if (iy == 0x7fff)
		return (sy & 0x8000) ? -pi_o_2 - tiny : pi_o_2 + tiny;

	/* compute y/x */
	k = iy - ix;
	if (k > 70)
		z = pi_o_2 + 0.5L * pi_lo;		/* |y/x| >  2**70 */
	else if ((sx & 0x8000) && k < -70)
		z = 0.0;						/* |y|/x < -2**70 */
	else
		z = __ieee754_atanl(__ieee754_fabsl(y / x));		/* safe to do y/x */
	switch ((int)m)
	{
	case 0:
		return z;						/* atan(+,+) */
	case 1:
		{
			uint32_t sz;

			GET_LDOUBLE_EXP(sz, z);
			SET_LDOUBLE_EXP(z, sz ^ UC(0x8000));
		}
		return z;						/* atan(-,+) */
	case 2:
		return pi - (z - pi_lo);		/* atan(+,-) */
	default:							/* case 3 */
		return (z - pi_lo) - pi;		/* atan(-,-) */
	}
}

#endif

long double __atan2l(long double y, long double x)
{
	if (x == 0.0 && y == 0.0 && _LIB_VERSION == _SVID_)
		return __kernel_standard_l(y, x, HUGE_VALL, KMATHERRL_ATAN2);	/* atan2(+-0,+-0) */

	return __ieee754_atan2l(y, x);
}

__typeof(__atan2l) atan2l __attribute__((weak, alias("__atan2l")));

#endif

```

`e_atanh.c`:

```c
/* @(#)e_atanh.c 1.3 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 *
 */

/* __ieee754_atanh(x)
 * Method :
 *    1.Reduced x to positive by atanh(-x) = -atanh(x)
 *    2.For x>=0.5
 *                  1              2x                          x
 *	atanh(x) = --- * log(1 + -------) = 0.5 * log1p(2 * --------)
 *                  2             1 - x                      1 - x
 *	
 * 	For x<0.5
 *	atanh(x) = 0.5*log1p(2x+2x*x/(1-x))
 *
 * Special cases:
 *	atanh(x) is NaN if |x| > 1 with signal;
 *	atanh(NaN) is that NaN with no signal;
 *	atanh(+-1) is +-INF with signal.
 *
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_atanh

double __ieee754_atanh(double x)
{
#if defined __have_fpu_log1p
	double xa = __ieee754_fabs(x);
	double t;

	static const double hugeval = 1e300;
	
	if (isless(xa, 0.5))
	{
		if (xa < 0x1.0p-28)
		{
			math_force_eval(hugeval + x);
			return x;
		}

		t = xa + xa;
		t = 0.5 * __ieee754_log1p(t + t * xa / (1.0 - xa));
	} else if (isless(xa, 1.0))
	{
		t = 0.5 * __ieee754_log1p((xa + xa) / (1.0 - xa));
	} else
	{
		if (isgreater(xa, 1.0))
			return (x - x) / (x - x);

		return x / 0.0;
	}

	return __copysign(t, x);

#elif defined __have_fpu_log

	return 0.5 * log((1 + x) / (1 - x));

#else
	double t;
	int32_t hx, ix;
	uint32_t lx;

	static const double one = 1.0;
	static const double hugeval = 1e300;
	static const double zero = 0.0;

	GET_DOUBLE_WORDS(hx, lx, x);
	ix = hx & IC(0x7fffffff);
	if ((ix | ((lx | (-lx)) >> 31)) > IC(0x3ff00000))	/* |x|>1 */
		return (x - x) / (x - x);
	if (ix == IC(0x3ff00000))
		return x / zero;
	if (ix < IC(0x3e300000) && (hugeval + x) > zero)
		return x;						/* x<2**-28 */
	SET_HIGH_WORD(x, ix);
	if (ix < IC(0x3fe00000))
	{									/* x < 0.5 */
		t = x + x;
		t = 0.5 * __ieee754_log1p(t + t * x / (one - x));
	} else
	{
		t = 0.5 * __ieee754_log1p((x + x) / (one - x));
	}
	if (hx >= 0)
		return t;
	return -t;
#endif
}

#endif

/* wrapper atanh */
double __atanh(double x)
{
	if (_LIB_VERSION != _IEEE_ && isgreaterequal(__ieee754_fabs(x), 1.0))
		return __kernel_standard(x, x, HUGE_VAL, __ieee754_fabs(x) > 1.0 ? KMATHERR_ATANH_PLUSONE	/* atanh(|x|>1) */
								 : KMATHERR_ATANH_ONE);	/* atanh(|x|==1) */

	return __ieee754_atanh(x);
}

__typeof(__atanh) atanh __attribute__((weak, alias("__atanh")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(__atanhl) __atanhl __attribute__((alias("__atanh")));
__typeof(__atanhl) atanhl __attribute__((weak, alias("__atanh")));
#endif

```

`e_atanhf.c`:

```c
/* e_atanhf.c -- float version of e_atanh.c.
 * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 *
 */

/* __ieee754_atanh(x)
   Method :
      1.Reduced x to positive by atanh(-x) = -atanh(x)
      2.For x>=0.5
		    1              2x                          x
	atanh(x) = --- * log(1 + -------) = 0.5 * log1p(2 * --------)
		    2             1 - x                      1 - x

	For x<0.5
	atanh(x) = 0.5*log1p(2x+2x*x/(1-x))

   Special cases:
	atanh(x) is NaN if |x| > 1 with signal;
	atanh(NaN) is that NaN with no signal;
	atanh(+-1) is +-INF with signal.

 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_atanh

float __ieee754_atanhf(float x)
{
#if defined __have_fpu_log1p
	float xa = __ieee754_fabsf(x);
	float t;

	static const float hugeval = 1e30;

	if (isless(xa, 0.5f))
	{
		if (xa < hexconstf(0x1.0p-28f, 3.7252902984619140625000e-09F, UC(0x31800000)))
		{
			math_force_eval(hugeval + x);
			return x;
		}

		t = xa + xa;
		t = 0.5f * __ieee754_log1pf(t + t * xa / (1.0f - xa));
	} else if (isless(xa, 1.0f))
	{
		t = 0.5f * __ieee754_log1pf((xa + xa) / (1.0f - xa));
	} else
	{
		if (isgreater(xa, 1.0f))
			return (x - x) / (x - x);

		return x / 0.0f;
	}

	return __copysignf(t, x);

#elif defined __have_fpu_log

	return 0.5f * logf((1.0f + x) / (1.0f - x));

#else

	float t;
	int32_t hx, ix;

	static const float one = 1.0;
	static const float hugeval = 1e30;
	static const float zero = 0.0;
	
	GET_FLOAT_WORD(hx, x);
	ix = hx & IC(0x7fffffff);
	if (ix > IC(0x3f800000))				/* |x|>1 */
		return (x - x) / (x - x);
	if (ix == IC(0x3f800000))
		return x / zero;
	if (ix < IC(0x31800000) && (hugeval + x) > zero)
		return x;						/* x<2**-28 */
	SET_FLOAT_WORD(x, ix);
	if (ix < IC(0x3f000000))
	{									/* x < 0.5 */
		t = x + x;
		t = 0.5f * __ieee754_log1pf(t + t * x / (one - x));
	} else
	{
		t = 0.5f * __ieee754_log1pf((x + x) / (one - x));
	}
	
	if (hx >= 0)
		return t;
	return -t;

#endif
}

#endif

/* wrapper atanhf */
float __atanhf(float x)
{
	if (isgreaterequal(__ieee754_fabsf(x), 1.0F) && _LIB_VERSION != _IEEE_)
		return __kernel_standard_f(x, x, HUGE_VALF, __ieee754_fabsf(x) > 1.0F ? KMATHERRF_ATANH_PLUSONE	/* atanh(|x|>1) */
								 : KMATHERRF_ATANH_ONE);	/* atanh(|x|==1) */

	return __ieee754_atanhf(x);
}

__typeof(__atanhf) atanhf __attribute__((weak, alias("__atanhf")));

```

`e_atanhl.c`:

```c
/* s_atanhl.c -- long double version of s_atan.c.
 * Conversion to long double by Ulrich Drepper,
 * Cygnus Support, drepper@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/* __ieee754_atanhl(x)
 * Method :
 *    1.Reduced x to positive by atanh(-x) = -atanh(x)
 *    2.For x>=0.5
 *                   1              2x                          x
 *	atanhl(x) = --- * log(1 + -------) = 0.5 * log1p(2 * --------)
 *                   2             1 - x                      1 - x
 *
 *	For x<0.5
 *	atanhl(x) = 0.5*log1pl(2x+2x*x/(1-x))
 *
 * Special cases:
 *	atanhl(x) is NaN if |x| > 1 with signal;
 *	atanhl(NaN) is that NaN with no signal;
 *	atanhl(+-1) is +-INF with signal.
 *
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

#ifndef __have_fpu_atanh

long double __ieee754_atanhl(long double x)
{
	long double t;
	int32_t ix;
	uint32_t i0, i1;
	int32_t se;
	
	static const long double one = 1.0;
	static const long double hugeval = 1e4900L;
	static const long double zero = 0.0;

	GET_LDOUBLE_WORDS(se, i0, i1, x);
	ix = se & 0x7fff;
	if ((ix + ((((i0 & IC(0x7fffffff)) | i1) | (-((i0 & IC(0x7fffffff)) | i1))) >> 31)) > 0x3fff)
		/* |x|>1 */
		return (x - x) / (x - x);
	if (ix == 0x3fff)
		return x / zero;
	if (ix < 0x3fe3)
	{
		math_force_eval(hugeval + x);
		return x;						/* x<2**-28 */
	}
	SET_LDOUBLE_EXP(x, ix);
	if (ix < 0x3ffe)
	{									/* x < 0.5 */
		t = x + x;
		t = 0.5 * __ieee754_log1pl(t + t * x / (one - x));
	} else
	{
		t = 0.5 * __ieee754_log1pl((x + x) / (one - x));
	}
	if (se < 0)
		t = -t;
	return t;
}

#endif

/* wrapper atanh */
long double __atanhl(long double x)
{
	if (isgreaterequal(__ieee754_fabsl(x), 1.0) && _LIB_VERSION != _IEEE_)
		return __kernel_standard_l(x, x, HUGE_VALL, __ieee754_fabsl(x) > 1.0 ? KMATHERRL_ATANH_PLUSONE	/* atanh(|x|>1) */
								 : KMATHERRL_ATANH_ONE);	/* atanh(|x|==1) */

	return __ieee754_atanhl(x);
}

__typeof(__atanhl) atanhl __attribute__((weak, alias("__atanhl")));

#endif

```

`e_cosh.c`:

```c
/* @(#)e_cosh.c 1.3 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */
/* Optimized by Ulrich Drepper <drepper@gmail.com>, 2011 */

/* __ieee754_cosh(x)
 * Method :
 * mathematically cosh(x) if defined to be (exp(x)+exp(-x))/2
 *	1. Replace x by |x| (cosh(x) = cosh(-x)).
 *	2.
 *							[ exp(x) - 1 ]^2
 *	    0        <= x <= ln2/2  :  cosh(x) := 1 + -------------------
 *							   2*exp(x)
 *
 *						  exp(x) +  1/exp(x)
 *	    ln2/2    <= x <= 22     :  cosh(x) := -------------------
 *							  2
 *	    22       <= x <= lnovft :  cosh(x) := exp(x)/2
 *	    lnovft   <= x <= ln2ovft:  cosh(x) := exp(x/2)/2 * exp(x/2)
 *	    ln2ovft  <  x	    :  cosh(x) := hugeval*hugeval (overflow)
 *
 * Special cases:
 *	cosh(x) is |x| if x is +INF, -INF, or NaN.
 *	only cosh(0)=1 is exact for finite x.
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_cosh

double __ieee754_cosh(double x)
{
	double t, w;
	int32_t ix;
	uint32_t lx;

	static const double one = 1.0;
	static const double half = 0.5;
	static const double hugeval = 1.0e300;
	
	/* High word of |x|. */
	GET_HIGH_WORD(ix, x);
	ix &= IC(0x7fffffff);

	/* x is INF or NaN */
	if (ix >= IC(0x7ff00000))
		return x * x;

	/* |x| in [0,22] */
	if (ix < IC(0x40360000))
	{
		/* |x| in [0,0.5*ln2], return 1+expm1(|x|)^2/(2*exp(|x|)) */
		if (ix < IC(0x3fd62e43))
		{
			t = __ieee754_expm1(__ieee754_fabs(x));
			w = one + t;
			if (ix < IC(0x3c800000))
				return w;				/* cosh(tiny) = 1 */
			return one + (t * t) / (w + w);
		}

		/* |x| in [0.5*ln2,22], return (exp(|x|)+1/exp(|x|)/2; */
		t = __ieee754_exp(__ieee754_fabs(x));
		return half * t + half / t;
	}

	/* |x| in [22, log(maxdouble)] return half*exp(|x|) */
	if (ix < IC(0x40862E42))
		return half * __ieee754_exp(__ieee754_fabs(x));

	/* |x| in [log(maxdouble), overflowthresold] */
	GET_LOW_WORD(lx, x);
	if (ix < IC(0x408633ce) || (ix == IC(0x408633ce) && lx <= UC(0x8fb9f87d)))
	{
		w = __ieee754_exp(half * __ieee754_fabs(x));
		t = half * w;
		return t * w;
	}

	/* |x| > overflowthresold, cosh(x) overflow */
	return hugeval * hugeval;
}

#endif

/* wrapper cosh */
double __cosh(double x)
{
	double z = __ieee754_cosh(x);

	if (_LIB_VERSION != _IEEE_ && !isfinite(z) && isfinite(x))
		return __kernel_standard(x, x, z, KMATHERR_COSH);	/* cosh overflow */

	return z;
}

__typeof(__cosh) cosh __attribute__((weak, alias("__cosh")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(__coshl) __coshl __attribute__((alias("__cosh")));
__typeof(__coshl) coshl __attribute__((weak, alias("__cosh")));
#endif

```

`e_coshf.c`:

```c
/* e_coshf.c -- float version of e_cosh.c.
 * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
 * Optimizations by Ulrich Drepper <drepper@gmail.com>, 2011
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_cosh

float __ieee754_coshf(float x)
{
	float t, w;
	int32_t ix;

	static const float hugeval = 1.0e30;
	static const float one = 1.0;
	static const float half = 0.5;
	
	GET_FLOAT_WORD(ix, x);
	ix &= IC(0x7fffffff);

	/* x is INF or NaN */
	if (!FLT_UWORD_IS_FINITE(ix))
		return x * x;

	/* |x| in [0.5*ln2,22], return (exp(|x|)+1/exp(|x|)/2; */
	if (ix < IC(0x41b00000))
	{
		/* |x| in [0,0.5*ln2], return 1+expm1(|x|)^2/(2*exp(|x|)) */
		if (ix < IC(0x3eb17218))
		{
			t = __ieee754_expm1f(__ieee754_fabsf(x));
			w = one + t;
			if (ix < IC(0x24000000))
				return w;					/* cosh(tiny) = 1 */
			return one + (t * t) / (w + w);
		}

		/* |x| in [0,22] */
		t = __ieee754_expf(__ieee754_fabsf(x));
		return half * t + half / t;
	}

	/* |x| in [22, log(maxdouble)] return half*exp(|x|) */
	if (ix <= FLT_UWORD_LOG_MAX)
		return half * __ieee754_expf(__ieee754_fabsf(x));

	/* |x| in [log(maxdouble), overflowthresold] */
	if (ix <= FLT_UWORD_LOG_2MAX)
	{
		w = __ieee754_expf(half * __ieee754_fabsf(x));
		t = half * w;
		return t * w;
	}

	/* |x| > overflowthresold, cosh(x) overflow */
	return hugeval * hugeval;
}

#endif

float __coshf(float x)
{
	float z = __ieee754_coshf(x);

	if (!isfinite(z) && isfinite(x) && _LIB_VERSION != _IEEE_)
		return __kernel_standard_f(x, x, z, KMATHERRF_COSH);	/* cosh overflow */

	return z;
}

__typeof(__coshf) coshf __attribute__((weak, alias("__coshf")));

```

`e_coshl.c`:

```c
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/* __ieee754_coshl(x)
 * Method :
 * mathematically coshl(x) if defined to be (exp(x)+exp(-x))/2
 *	1. Replace x by |x| (coshl(x) = coshl(-x)).
 *	2.
 *							[ exp(x) - 1 ]^2
 *	    0        <= x <= ln2/2  :  coshl(x) := 1 + -------------------
 *							   2*exp(x)
 *
 *						   exp(x) +  1/exp(x)
 *	    ln2/2    <= x <= 22     :  coshl(x) := -------------------
 *							   2
 *	    22       <= x <= lnovft :  coshl(x) := expl(x)/2
 *	    lnovft   <= x <= ln2ovft:  coshl(x) := expl(x/2)/2 * expl(x/2)
 *	    ln2ovft  <  x	    :  coshl(x) := huge*huge (overflow)
 *
 * Special cases:
 *	coshl(x) is |x| if x is +INF, -INF, or NaN.
 *	only coshl(0)=1 is exact for finite x.
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

#ifndef __have_fpu_cosh

long double __ieee754_coshl(long double x)
{
	long double t, w;
	int32_t ex;
	uint32_t mx, lx;

	static const long double one = 1.0;
	static const long double half = 0.5;
	static const long double hugeval = 1.0e4900L;
	
	/* High word of |x|. */
	GET_LDOUBLE_WORDS(ex, mx, lx, x);
	ex &= 0x7fff;

	/* x is INF or NaN */
	if (ex == 0x7fff)
		return x * x;

	/* |x| in [0,22] */
	if (ex < 0x4003 || (ex == 0x4003 && mx < UC(0xb0000000)))
	{
		/* |x| in [0,0.5*ln2], return 1+expm1l(|x|)^2/(2*expl(|x|)) */
		if (ex < 0x3ffd || (ex == 0x3ffd && mx < UC(0xb17217f7)))
		{
			t = __ieee754_expm1l(__ieee754_fabsl(x));
			w = one + t;
			if (ex < 0x3fbc)
				return w;				/* cosh(tiny) = 1 */
			return one + (t * t) / (w + w);
		}

		/* |x| in [0.5*ln2,22], return (exp(|x|)+1/exp(|x|)/2; */
		t = __ieee754_expl(__ieee754_fabsl(x));
		return half * t + half / t;
	}

	/* |x| in [22, ln(maxdouble)] return half*exp(|x|) */
	if (ex < 0x400c || (ex == 0x400c && mx < UC(0xb1700000)))
		return half * __ieee754_expl(__ieee754_fabsl(x));

	/* |x| in [log(maxdouble), log(2*maxdouble)) */
	if (ex == 0x400c && (mx < UC(0xb174ddc0) || (mx == UC(0xb174ddc0) && lx < UC(0x31aec0eb))))
	{
		w = __ieee754_expl(half * __ieee754_fabsl(x));
		t = half * w;
		return t * w;
	}

	/* |x| >= log(2*maxdouble), cosh(x) overflow */
	return hugeval * hugeval;
}

#endif

long double __coshl(long double x)
{
	long double z = __ieee754_coshl(x);

	if (!isfinite(z) && isfinite(x) && _LIB_VERSION != _IEEE_)
		return __kernel_standard_l(x, x, z, KMATHERRL_COSH);	/* cosh overflow */

	return z;
}

__typeof(__coshl) coshl __attribute__((weak, alias("__coshl")));

#endif

```

`e_exp.c`:

```c
/* @(#)e_exp.c 1.3 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice 
 * is preserved.
 * ====================================================
 */

/* __ieee754_exp(x)
 * Returns the exponential of x.
 *
 * Method
 *   1. Argument reduction:
 *      Reduce x to an r so that |r| <= 0.5*ln2 ~ 0.34658.
 *	Given x, find r and integer k such that
 *
 *               x = k*ln2 + r,  |r| <= 0.5*ln2.  
 *
 *      Here r will be represented as r = hi-lo for better 
 *	accuracy.
 *
 *   2. Approximation of exp(r) by a special rational function on
 *	the interval [0,0.34658]:
 *	Write
 *	    R(r**2) = r*(exp(r)+1)/(exp(r)-1) = 2 + r*r/6 - r**4/360 + ...
 *      We use a special Reme algorithm on [0,0.34658] to generate 
 * 	a polynomial of degree 5 to approximate R. The maximum error 
 *	of this polynomial approximation is bounded by 2**-59. In
 *	other words,
 *	    R(z) ~ 2.0 + P1*z + P2*z**2 + P3*z**3 + P4*z**4 + P5*z**5
 *  	(where z=r*r, and the values of P1 to P5 are listed below)
 *	and
 *	    |                  5          |     -59
 *	    | 2.0+P1*z+...+P5*z   -  R(z) | <= 2 
 *	    |                             |
 *	The computation of exp(r) thus becomes
 *                             2*r
 *		exp(r) = 1 + -------
 *		              R - r
 *                                 r*R1(r)	
 *		       = 1 + r + ----------- (for better accuracy)
 *		                  2 - R1(r)
 *	where
 *			         2       4             10
 *		R1(r) = r - (P1*r  + P2*r  + ... + P5*r   ).
 *	
 *   3. Scale back to obtain exp(x):
 *	From step 1, we have
 *	   exp(x) = 2^k * exp(r)
 *
 * Special cases:
 *	exp(INF) is INF, exp(NaN) is NaN;
 *	exp(-INF) is 0, and
 *	for finite argument, only exp(0)=1 is exact.
 *
 * Accuracy:
 *	according to an error analysis, the error is always less than
 *	1 ulp (unit in the last place).
 *
 * Misc. info.
 *	For IEEE double 
 *	    if x >  7.09782712893383973096e+02 then exp(x) overflow
 *	    if x < -7.45133219101941108420e+02 then exp(x) underflow
 *
 * Constants:
 * The hexadecimal values are the intended ones for the following 
 * constants. The decimal values may be used, provided that the 
 * compiler will convert from decimal to binary accurately enough
 * to produce the hexadecimal values shown.
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_exp

double __ieee754_exp(double x)			/* default IEEE double exp */
{
	double y, hi, lo, c, t;
	int32_t k, xsb;
	uint32_t hx;

	static const double one = 1.0;
	static const double halF[2] = { 0.5, -0.5 };

	static const double hugeval = 1.0e+300;
	static const double twom1000 = 9.33263618503218878990e-302;		/* 2**-1000=0x01700000,0 */
	static const double o_threshold = 7.09782712893383973096e+02;	/* 0x40862E42, 0xFEFA39EF */
	static const double u_threshold = -7.45133219101941108420e+02;	/* 0xc0874910, 0xD52D3051 */
	static const double ln2HI[2] = {
		6.93147180369123816490e-01,	/* 0x3fe62e42, 0xfee00000 */
		-6.93147180369123816490e-01	/* 0xbfe62e42, 0xfee00000 */
	};

	static const double ln2LO[2] = {
		1.90821492927058770002e-10,	/* 0x3dea39ef, 0x35793c76 */
		-1.90821492927058770002e-10	/* 0xbdea39ef, 0x35793c76 */
	};

	static const double invln2 = 1.44269504088896338700e+00;	/* 0x3ff71547, 0x652b82fe */
	static const double P1 = 1.66666666666666019037e-01;		/* 0x3FC55555, 0x5555553E */
	static const double P2 = -2.77777777770155933842e-03;		/* 0xBF66C16C, 0x16BEBD93 */
	static const double P3 = 6.61375632143793436117e-05;		/* 0x3F11566A, 0xAF25DE2C */
	static const double P4 = -1.65339022054652515390e-06;		/* 0xBEBBBD41, 0xC5D26BF1 */
	static const double P5 = 4.13813679705723846039e-08;		/* 0x3E663769, 0x72BEA4D0 */

	GET_HIGH_WORD(hx, x);				/* high word of x */
	xsb = (hx >> 31) & 1;				/* sign bit of x */
	hx &= IC(0x7fffffff);				/* high word of |x| */

	/* filter out non-finite argument */
	if (hx >= IC(0x40862E42))
	{									/* if |x|>=709.78... */
		if (hx >= IC(0x7ff00000))
		{
			GET_LOW_WORD(k, x);
			if (((hx & IC(0xfffff)) | k) != 0)
				return x;				/* NaN */
			return (xsb == 0) ? x : 0.0;	/* exp(+-inf)={inf,0} */
		}
		if (x > o_threshold)			/* overflow */
		{
			feraiseexcept(FE_OVERFLOW);
			return HUGE_VAL;
		}
		if (x < u_threshold)			/* underflow */
		{
			feraiseexcept(FE_UNDERFLOW);
			return 0;
		}
	}

	/* argument reduction */
	if (hx > IC(0x3fd62e42))
	{									/* if  |x| > 0.5 ln2 */
		if (hx < IC(0x3FF0A2B2))
		{								/* and |x| < 1.5 ln2 */
			hi = x - ln2HI[xsb];
			lo = ln2LO[xsb];
			k = 1 - xsb - xsb;
		} else
		{
			k = invln2 * x + halF[xsb];
			t = k;
			hi = x - t * ln2HI[0];		/* t*ln2HI is exact here */
			lo = t * ln2LO[0];
		}
		x = hi - lo;
	} else if (hx < IC(0x3e300000))
	{									/* when |x|<2**-28 */
		if (hugeval + x > one)
			return one + x;				/* trigger inexact */
		return one;
	} else
	{
		k = 0;
		lo = 0;
		hi = 0;
	}

	/* x is now in primary range */
	t = x * x;
	c = x - t * (P1 + t * (P2 + t * (P3 + t * (P4 + t * P5))));
	if (k == 0)
		return one - ((x * c) / (c - 2.0) - x);
	y = one - ((lo - (x * c) / (2.0 - c)) - hi);
	GET_HIGH_WORD(hx, y);
	if (k >= -1021)
	{
		hx += (k << IEEE754_DOUBLE_SHIFT);			/* add k to y's exponent */
		SET_HIGH_WORD(y, hx);
		return y;
	} else
	{
		hx += ((k + 1000) << IEEE754_DOUBLE_SHIFT);	/* add k to y's exponent */
		SET_HIGH_WORD(y, hx);
		return y * twom1000;
	}
}

#endif

/* wrapper exp */
double __exp(double x)
{
	double z = __ieee754_exp(x);

	if (_LIB_VERSION != _IEEE_ && (!isfinite(z) || z == 0.0) && isfinite(x))
		return __kernel_standard(x, x, z, signbit(x) ? KMATHERR_EXP_UNDERFLOW : KMATHERR_EXP_OVERFLOW);

	return z;
}

__typeof(__exp) exp __attribute__((weak, alias("__exp")));
#ifdef __NO_LONG_DOUBLE_MATH
long double __expl(long double x) __attribute__((alias("__exp")));
__typeof(__expl) expl __attribute__((weak, alias("__exp")));
#endif

```

`e_exp10.c`:

```c
#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_exp10

double __ieee754_exp10(double arg)
{
	if (isfinite(arg) && arg < DBL_MIN_10_EXP - DBL_DIG - 10)
	{
		feraiseexcept(FE_UNDERFLOW);
		return 0;
	}
	/* This is a very stupid and inprecise implementation.  It'll get
	   replaced sometime (soon?).  */
	return __ieee754_exp(M_LN10 * arg);
}

#endif


double __exp10(double x)
{
	double z = __ieee754_exp10(x);

	if (!isfinite(z) && isfinite(x) && _LIB_VERSION != _IEEE_)
		/* exp10 overflow (46) if x > 0, underflow (47) if x < 0.  */
		return __kernel_standard(x, x, z, signbit(x) ? KMATHERR_EXP10_UNDERFLOW : KMATHERR_EXP10_OVERFLOW);

	return z;
}



__typeof(__exp10) exp10 __attribute__((weak, alias("__exp10")));
__typeof(__exp10) __pow10 __attribute__((alias("__exp10")));
__typeof(__pow10) pow10 __attribute__((weak, alias("__pow10")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(__exp10l) __exp10l __attribute__((alias("__exp10")));
__typeof(__exp10l) exp10l __attribute__((weak, alias("__exp10l")));
__typeof(__pow10l) __pow10l __attribute__((alias("__pow10")));
__typeof(__pow10l) pow10l __attribute__((weak, alias("__pow10l")));
#endif

```

`e_exp10f.c`:

```c
#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_exp10

float __ieee754_exp10f(float arg)
{
	/* The argument to exp needs to be calculated in enough precision
	   that the fractional part has as much precision as float, in
	   addition to the bits in the integer part; using double ensures
	   this.  */
	return (float)__ieee754_exp(M_LN10 * (double)arg);
}

#endif


float __exp10f(float x)
{
	float z = __ieee754_exp10f(x);

	if (!isfinite(z) && isfinite(x) && _LIB_VERSION != _IEEE_)
		/* exp10 overflow (46) if x > 0, underflow (47) if x < 0.  */
		return __kernel_standard_f(x, x, z, signbit(x) ? KMATHERRF_EXP10_UNDERFLOW : KMATHERRF_EXP10_OVERFLOW);

	return z;
}

__typeof(__exp10f) exp10f __attribute__((weak, alias("__exp10f")));
__typeof(__exp10f) __pow10f __attribute__((alias("__exp10f")));
__typeof(__pow10f) pow10f __attribute__((weak, alias("__pow10f")));

```

`e_exp10l.c`:

```c
#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

#ifndef __have_fpu_exp10

long double __ieee754_exp10l(long double arg)
{
	if (isfinite(arg) && arg < LDBL_MIN_10_EXP - LDBL_DIG - 10)
	{
		feraiseexcept(FE_UNDERFLOW);
		return 0;
	}
	/* This is a very stupid and inprecise implementation.  It'll get
	   replaced sometime (soon?).  */
	return __ieee754_expl(M_LN10l * arg);
}

#endif

long double __exp10l(long double x)
{
	long double z = __ieee754_exp10l(x);

	if (!isfinite(z) && isfinite(x) && _LIB_VERSION != _IEEE_)
		/* exp10 overflow (46) if x > 0, underflow (47) if x < 0.  */
		return __kernel_standard_l(x, x, z, signbit(x) ? KMATHERRL_EXP10_UNDERFLOW : KMATHERRL_EXP10_OVERFLOW);

	return z;
}

__typeof(__exp10l) exp10l __attribute__((weak, alias("__exp10l")));
__typeof(__exp10l) __pow10l __attribute__((alias("__exp10l")));
__typeof(__pow10l) pow10l __attribute__((weak, alias("__pow10l")));

#endif

```

`e_exp2.c`:

```c
/* Double-precision floating point 2^x.
   Copyright (C) 1997-2013 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Geoffrey Keating <geoffk@ozemail.com.au>

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/* The basic design here is from
   Shmuel Gal and Boris Bachelis, "An Accurate Elementary Mathematical
   Library for the IEEE Floating Point Standard", ACM Trans. Math. Soft.,
   17 (1), March 1991, pp. 26-45.
   It has been slightly modified to compute 2^x instead of e^x.
   */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_exp2

#undef abs
#define abs(x) ((x) < 0 ? -(x) : (x))

double __ieee754_exp2(double x)
{
	static const double himark = (double) DBL_MAX_EXP;
	static const double lomark = (double) (DBL_MIN_EXP - DBL_MANT_DIG - 1);

#include "t_exp2.h"

	/* Check for usual case.  */
	if (isless(x, himark))
	{
		static const double THREEp42 = 13194139533312.0;

		int32_t tval, unsafe;
		double rx, x22, result;
		double ex2_u, scale_u;
		uint32_t exp;

		/* Exceptional cases:  */
		if (!isgreaterequal(x, lomark))
		{
			if (isinf(x))
				/* e^-inf == 0, with no error.  */
				return 0;
			/* Underflow */
			feraiseexcept(FE_UNDERFLOW);
			return 0;
		}

		if (__ieee754_fabs(x) < DBL_EPSILON / 4.0)
			return 1.0 + x;

		{
			SAVE_AND_SET_ROUND(FE_TONEAREST);

			/* 1. Argument reduction.
			   Choose integers ex, -256 <= t < 256, and some real
			   -1/1024 <= x1 <= 1024 so that
			   x = ex + t/512 + x1.

			   First, calculate rx = ex + t/512.  */
			rx = x + THREEp42;
			rx -= THREEp42;
			x -= rx;					/* Compute x=x1. */
			/* Compute tval = (ex*512 + t)+256.
			   Now, t = (tval mod 512)-256 and ex=tval/512  [that's mod, NOT %;
			   and /-round-to-nearest not the usual c integer /].  */
			tval = (int32_t) (rx * 512.0 + 256.0);

			/* 2. Adjust for accurate table entry.
			   Find e so that
			   x = ex + t/512 + e + x2
			   where -1e6 < e < 1e6, and
			   (double)(2^(t/512+e))
			   is accurate to one part in 2^-64.  */

			/* 'tval & 511' is the same as 'tval%512' except that it's always
			   positive.
			   Compute x = x2.  */
			x -= exp2_deltatable[tval & 511];

			/* 3. Compute ex2 = 2^(t/512+e+ex).  */
			ex2_u = exp2_accuratetable[tval & 511];
			tval >>= 9;
			/* x2 is an integer multiple of 2^-54; avoid intermediate
			   underflow from the calculation of x22 * x.  */
			unsafe = abs(tval) >= -DBL_MIN_EXP - 56;
			GET_HIGH_WORD(exp, ex2_u);
			exp = ((exp & UC(0x7ff00000)) + ((tval >> unsafe) << IEEE754_DOUBLE_SHIFT)) | (exp & ~UC(0x7ff00000));
			SET_HIGH_WORD(ex2_u, exp);
			exp = UC(0x3ff00000) + ((tval - (tval >> unsafe)) << IEEE754_DOUBLE_SHIFT);
			INSERT_WORDS(scale_u, exp, 0);

			/* 4. Approximate 2^x2 - 1, using a fourth-degree polynomial,
			   with maximum error in [-2^-10-2^-30,2^-10+2^-30]
			   less than 10^-19.  */

			x22 = (((.0096181293647031180 * x + .055504110254308625) * x + .240226506959100583) * x + .69314718055994495) * ex2_u;
			(void)math_opt_barrier(x22);
			RESTORE_ROUND();
		}

		/* 5. Return (2^x2-1) * 2^(t/512+e+ex) + 2^(t/512+e+ex).  */
		result = x22 * x + ex2_u;

		if (!unsafe)
			return result;
		return result * scale_u;
	}
	/* Return x, if x is a NaN or Inf; or overflow, otherwise.  */
	if (isinf(x))
		return HUGE_VAL;
	if (isnan(x))
		return x;
	feraiseexcept(FE_OVERFLOW);
	return HUGE_VAL;
}

#undef abs

#endif

double __exp2(double x)
{
	double z = __ieee754_exp2(x);

	if (!isfinite(z) && isfinite(x) && _LIB_VERSION != _IEEE_)
		/* exp2 overflow: 44, exp2 underflow: 45 */
		return __kernel_standard(x, x, z, signbit(x) ? KMATHERR_EXP2_UNDERFLOW : KMATHERR_EXP2_OVERFLOW);

	return z;
}


__typeof(__exp2) exp2 __attribute__((weak, alias("__exp2")));
__typeof(__exp2) __pow2 __attribute__((alias("__exp2")));
__typeof(__pow2) pow2 __attribute__((weak, alias("__pow2")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(__exp2l) __exp2l __attribute__((alias("__exp2")));
__typeof(__exp2l) exp2l __attribute__((weak, alias("__exp2l")));
__typeof(__pow2l) __pow2l __attribute__((alias("__pow2")));
__typeof(__pow2l) pow2l __attribute__((weak, alias("__pow2l")));
#endif

```

`e_exp2f.c`:

```c
/* Single-precision floating point 2^x.
   Copyright (C) 1997-2013 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Geoffrey Keating <geoffk@ozemail.com.au>

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/* The basic design here is from
   Shmuel Gal and Boris Bachelis, "An Accurate Elementary Mathematical
   Library for the IEEE Floating Point Standard", ACM Trans. Math. Soft.,
   17 (1), March 1991, pp. 26-45.
   It has been slightly modified to compute 2^x instead of e^x, and for
   single-precision.
   */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_exp2

#undef abs
#define abs(x) ((x) < 0 ? -(x) : (x))

float __ieee754_exp2f(float x)
{
	static const float himark = (float) FLT_MAX_EXP;
	static const float lomark = (float) (FLT_MIN_EXP - FLT_MANT_DIG - 1);

	static const volatile float TWOM100 = 7.88860905e-31;
	static const volatile float TWO127 = 1.7014118346e+38;

#include "t_exp2f.h"

	/* Check for usual case.  */
	if (isless(x, himark) && isgreaterequal(x, lomark))
	{
		static const float THREEp14 = 49152.0;
		int32_t tval, unsafe;
		float rx, x22, result;
		float ex2_u, scale_u;
		uint32_t exp;
		
		if (__ieee754_fabsf(x) < FLT_EPSILON / 4.0f)
			return 1.0f + x;

		{
			SAVE_AND_SET_ROUND(FE_TONEAREST);

			/* 1. Argument reduction.
			   Choose integers ex, -128 <= t < 128, and some real
			   -1/512 <= x1 <= 1/512 so that
			   x = ex + t/512 + x1.

			   First, calculate rx = ex + t/256.  */
			rx = x + THREEp14;
			rx -= THREEp14;
			x -= rx;					/* Compute x=x1. */
			/* Compute tval = (ex*256 + t)+128.
			   Now, t = (tval mod 256)-128 and ex=tval/256  [that's mod, NOT %;
			   and /-round-to-nearest not the usual c integer /].  */
			tval = (int32_t) (rx * 256.0f + 128.0f);
			
			/* 2. Adjust for accurate table entry.
			   Find e so that
			   x = ex + t/256 + e + x2
			   where -7e-4 < e < 7e-4, and
			   (float)(2^(t/256+e))
			   is accurate to one part in 2^-64.  */

			/* 'tval & 255' is the same as 'tval%256' except that it's always
			   positive.
			   Compute x = x2.  */
			x -= __exp2f_deltatable[tval & 255];

			/* 3. Compute ex2 = 2^(t/255+e+ex).  */
			ex2_u = __exp2f_atable[tval & 255];
			tval >>= 8;
			/* x2 is an integer multiple of 2^-30; avoid intermediate
			   underflow from the calculation of x22 * x.  */
			unsafe = abs(tval) >= -FLT_MIN_EXP - 32;
			GET_FLOAT_WORD(exp, ex2_u);
			exp = ((exp & UC(0x7F800000)) + ((tval >> unsafe) << IEEE754_FLOAT_SHIFT)) | (exp & ~UC(0x7F800000));
			SET_FLOAT_WORD(ex2_u, exp);
			exp = UC(0x3f800000) + ((tval - (tval >> unsafe)) << IEEE754_FLOAT_SHIFT);
			SET_FLOAT_WORD(scale_u, exp);

			/* 4. Approximate 2^x2 - 1, using a second-degree polynomial,
			   with maximum error in [-2^-9 - 2^-14, 2^-9 + 2^-14]
			   less than 1.3e-10.  */

			x22 = (.24022656679f * x + .69314736128f) * ex2_u;
			RESTORE_ROUND();
		}

		/* 5. Return (2^x2-1) * 2^(t/512+e+ex) + 2^(t/512+e+ex).  */
		result = x22 * x + ex2_u;

		if (!unsafe)
			return result;
		return result * scale_u;
	}
	/* Exceptional cases:  */
	if (isless(x, himark))
	{
		if (isinf(x))
			/* e^-inf == 0, with no error.  */
			return 0;
		/* Underflow */
		return TWOM100 * TWOM100;
	}
	/* Return x, if x is a NaN or Inf; or overflow, otherwise.  */
	return TWO127 * x;
}

#undef abs

#endif

float __exp2f(float x)
{
	float z = __ieee754_exp2f(x);

	if (!isfinite(z) && isfinite(x) && _LIB_VERSION != _IEEE_)
		/* exp2 overflow: 144, exp2 underflow: 145 */
		return __kernel_standard_f(x, x, z, signbit(x) ? KMATHERRF_EXP2_UNDERFLOW : KMATHERRF_EXP2_OVERFLOW);

	return z;
}

__typeof(__exp2f) exp2f __attribute__((weak, alias("__exp2f")));
__typeof(__exp2f) __pow2f __attribute__((alias("__exp2f")));
__typeof(__pow2f) pow2f __attribute__((weak, alias("__pow2f")));

```

`e_exp2l.c`:

```c
/* Compute 2^x.
   Copyright (C) 2012-2013 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

#ifndef __have_fpu_exp2

long double __ieee754_exp2l(long double x)
{
	if (isless(x, (long double) LDBL_MAX_EXP))
	{
		if (isgreaterequal(x, (long double) (LDBL_MIN_EXP - LDBL_MANT_DIG - 1)))
		{
			int intx = (int) x;
			long double fractx = x - intx;

			return __ieee754_scalbnl(__ieee754_expm1l(M_LN2l * fractx) + 1.0L, intx);
		}
		/* Underflow or exact zero.  */
		if (isinf(x))
			return 0;
		feraiseexcept(FE_UNDERFLOW);
		return 0;
	}
	/* Infinity, NaN or overflow.  */
	return LDBL_MAX * x;
}

#endif

long double __exp2l(long double x)
{
	long double z = __ieee754_exp2l(x);

	if (!isfinite(z) && isfinite(x) && _LIB_VERSION != _IEEE_)
		/* exp2 overflow: 244, exp2 underflow: 245 */
		return __kernel_standard_l(x, x, z, signbit(x) ? KMATHERRL_EXP2_UNDERFLOW : KMATHERRL_EXP2_OVERFLOW);

	return z;
}


__typeof(__exp2l) exp2l __attribute__((weak, alias("__exp2l")));
__typeof(__exp2l) __pow2l __attribute__((alias("__exp2l")));
__typeof(__pow2l) pow2l __attribute__((weak, alias("__pow2l")));

#endif

```

`e_expf.c`:

```c
/* Single-precision floating point e^x.
   Copyright (C) 1997-2013 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Geoffrey Keating <geoffk@ozemail.com.au>

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/* How this works:

   The input value, x, is written as

   x = n * ln(2) + t/512 + delta[t] + x;

   where:
   - n is an integer, 127 >= n >= -150;
   - t is an integer, 177 >= t >= -177
   - delta is based on a table entry, delta[t] < 2^-28
   - x is whatever is left, |x| < 2^-10

   Then e^x is approximated as

   e^x = 2^n ( e^(t/512 + delta[t])
	       + ( e^(t/512 + delta[t])
		   * ( p(x + delta[t] + n * ln(2)) - delta ) ) )

   where
   - p(x) is a polynomial approximating e(x)-1;
   - e^(t/512 + delta[t]) is obtained from a table.

   The table used is the same one as for the double precision version;
   since we have the table, we might as well use it.

   It turns out to be faster to do calculations in double precision than
   to perform an 'accurate table method' expf, because of the range reduction
   overhead (compare exp2f).
   */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_exp

float __ieee754_expf(float x)
{
	static const float himark = 88.72283935546875f;
	static const float lomark = -103.972084045410f;

#include "t_expf.h"

	/* Check for usual case.  */
	if (isless(x, himark) && isgreater(x, lomark))
	{
		static const float THREEp42 = 13194139533312.0f;
		static const float THREEp22 = 12582912.0f;

		/* 1/ln(2).  */
		static const float m_1_ln2 = 1.44269502163f;

		/* ln(2) */
		static const double m_ln2 = .6931471805599452862;

		int tval;
		volatile double x22, t, result, dx;
		volatile float n, delta;
		double ex2_u;
		
		{
			int32_t exponent;
			SAVE_AND_SET_ROUND(FE_TONEAREST);
			
			/* Calculate n.  */
			n = x * m_1_ln2 + THREEp22;
			n -= THREEp22;
			dx = x - n * m_ln2;

			/* Calculate t/512.  */
			t = dx + THREEp42;
			t -= THREEp42;
			dx -= t;

			/* Compute tval = t. */
			tval = (int) (t * 512.0);

			if (t >= 0)
				delta = -__exp_deltatable[tval];
			else
				delta = __exp_deltatable[-tval];

			/* Compute ex2 = 2^n e^(t/512+delta[t]).  */
			ex2_u = __exp_atable[tval + 177];
			GET_HIGH_WORD(exponent, ex2_u);
			exponent += ((int32_t) n) << IEEE754_DOUBLE_SHIFT;
			SET_HIGH_WORD(ex2_u, exponent);
			
			/* Approximate e^(dx+delta) - 1, using a second-degree polynomial,
			   with maximum error in [-2^-10-2^-28,2^-10+2^-28]
			   less than 5e-11.  */
			x22 = (0.5000000496709180453 * dx + 1.0000001192102037084) * dx + delta;
			RESTORE_ROUND();
		}

		/* Return result.  */
		result = x22 * ex2_u + ex2_u;
		return (float) result;
	}
	/* Exceptional cases:  */
	if (isless(x, himark))
	{
		if (isinf(x))
			/* e^-inf == 0, with no error.  */
			return 0;
		/* Underflow */
		feraiseexcept(FE_UNDERFLOW);
		return 0;
	}
	/* Return x, if x is a NaN or Inf; or overflow, otherwise.  */
	if (isinf(x))
		return HUGE_VALF;
	if (isnan(x))
		return x;
	feraiseexcept(FE_OVERFLOW);
	return HUGE_VALF;
}

#endif

/* wrapper exp */
float __expf(float x)
{
	float z = __ieee754_expf(x);

	if ((!isfinite(z) || z == 0.0f) && isfinite(x) && _LIB_VERSION != _IEEE_)
		return __kernel_standard_f(x, x, z, signbit(x) ? KMATHERRF_EXP_UNDERFLOW : KMATHERRF_EXP_OVERFLOW);

	return z;
}

__typeof(__expf) expf __attribute__((weak, alias("__expf")));

```

`e_expl.c`:

```c
#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

#ifndef __have_fpu_exp

long double __ieee754_expl(long double x)			/* default IEEE double exp */
{
	int sign;
	int32_t ex;
	uint32_t hx, lx;
	int intx;
	long double fractx;

	/* Smallest integer x for which e^x overflows.  */
	static const double o_threshold = 1.1356523406294143949491931077970764891253E4L;
	/* Largest integer x for which e^x underflows.  */
	static const long double u_threshold = -11355.137111933024058885L;
	static const long double log2e = 1.44269504088896340735992468100189213743L;

	GET_LDOUBLE_WORDS(ex, hx, lx, x);
	sign = (int)ex & 0x8000;				/* sign bit of x */
	ex &= 0x7fff;
	hx &= IC(0x7fffffff);
	/* filter out non-finite argument */
	if (ex >= 0x7fff)
	{
		if ((hx | lx) != 0)
			return x;				/* NaN */
		return sign ? 0.0 : x;		/* exp(+-inf)={inf,0} */
	}
	if (x > o_threshold)			/* overflow */
	{
		feraiseexcept(FE_OVERFLOW);
		return HUGE_VALL;
	}
	if (x < u_threshold)			/* underflow */
	{
		feraiseexcept(FE_UNDERFLOW);
		return 0;
	}
	x *= log2e;
	intx = (int) x;
	fractx = x - intx;
	return __ieee754_scalbnl(__ieee754_expm1l(M_LN2l * fractx) + 1.0L, intx);
}

#endif

/* wrapper exp */
long double __expl(long double x)
{
	long double z = __ieee754_expl(x);

	if ((!isfinite(z) || z == 0.0L) && isfinite(x) && _LIB_VERSION != _IEEE_)
		return __kernel_standard_l(x, x, z, signbit(x) ? KMATHERRL_EXP_UNDERFLOW : KMATHERRL_EXP_OVERFLOW);

	return z;
}

__typeof(__expl) expl __attribute__((weak, alias("__expl")));

#endif

```

`e_fmod.c`:

```c
/* @(#)e_fmod.c 1.3 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/*
 * __ieee754_fmod(x,y)
 * Return x mod y in exact arithmetic
 * Method: shift and subtract
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_fmod

double __ieee754_fmod(double x, double y)
{
	int32_t n, hx, hy, hz, ix, iy, sx, i;
	uint32_t lx, ly, lz;

	static const double one = 1.0;
	static const double Zero[] = { 0.0, -0.0 };

	GET_DOUBLE_WORDS(hx, lx, x);
	GET_DOUBLE_WORDS(hy, ly, y);
	sx = hx & IC(0x80000000);			/* sign of x */
	hx ^= sx;							/* |x| */
	hy &= IC(0x7fffffff);				/* |y| */

	/* purge off exception values */
	if ((hy | ly) == 0 || (hx >= IC(0x7ff00000)) ||	/* y=0,or x not finite */
		((hy | ((ly | -ly) >> 31)) > IC(0x7ff00000)))	/* or y is NaN */
		return (x * y) / (x * y);
	if (hx <= hy)
	{
		if ((hx < hy) || (lx < ly))
			return x;					/* |x|<|y| return x */
		if (lx == ly)
			return Zero[(uint32_t) sx >> 31];	/* |x|=|y| return x*0 */
	}

	/* determine ix = ilogb(x) */
	if (hx < IC(0x00100000))
	{									/* subnormal x */
		if (hx == 0)
		{
			for (ix = -1043, i = lx; i > 0; i <<= 1)
				ix -= 1;
		} else
		{
			for (ix = -1022, i = (hx << 11); i > 0; i <<= 1)
				ix -= 1;
		}
	} else
	{
		ix = (hx >> 20) - 1023;
	}

	/* determine iy = ilogb(y) */
	if (hy < IC(0x00100000))
	{									/* subnormal y */
		if (hy == 0)
		{
			for (iy = -1043, i = ly; i > 0; i <<= 1)
				iy -= 1;
		} else
		{
			for (iy = -1022, i = (hy << 11); i > 0; i <<= 1)
				iy -= 1;
		}
	} else
	{
		iy = (hy >> 20) - 1023;
	}

	/* set up {hx,lx}, {hy,ly} and align y to x */
	if (ix >= -1022)
		hx = IC(0x00100000) | (IC(0x000fffff) & hx);
	else
	{									/* subnormal x, shift x to normal */
		n = -1022 - ix;
		if (n <= 31)
		{
			hx = (hx << n) | (lx >> (32 - n));
			lx <<= n;
		} else
		{
			hx = lx << (n - 32);
			lx = 0;
		}
	}
	if (iy >= -1022)
		hy = IC(0x00100000) | (IC(0x000fffff) & hy);
	else
	{									/* subnormal y, shift y to normal */
		n = -1022 - iy;
		if (n <= 31)
		{
			hy = (hy << n) | (ly >> (32 - n));
			ly <<= n;
		} else
		{
			hy = ly << (n - 32);
			ly = 0;
		}
	}

	/* fix point fmod */
	n = ix - iy;
	while (n--)
	{
		hz = hx - hy;
		lz = lx - ly;
		if (lx < ly)
			hz -= 1;
		if (hz < 0)
		{
			hx = hx + hx + (lx >> 31);
			lx = lx + lx;
		} else
		{
			if ((hz | lz) == 0)			/* return sign(x)*0 */
				return Zero[(uint32_t) sx >> 31];
			hx = hz + hz + (lz >> 31);
			lx = lz + lz;
		}
	}
	hz = hx - hy;
	lz = lx - ly;
	if (lx < ly)
		hz -= 1;
	if (hz >= 0)
	{
		hx = hz;
		lx = lz;
	}

	/* convert back to floating value and restore the sign */
	if ((hx | lx) == 0)					/* return sign(x)*0 */
		return Zero[(uint32_t) sx >> 31];
	while (hx < IC(0x00100000))
	{									/* normalize x */
		hx = hx + hx + (lx >> 31);
		lx = lx + lx;
		iy -= 1;
	}
	if (iy >= -1022)
	{									/* normalize output */
		hx = ((hx - IC(0x00100000)) | ((iy + 1023) << 20));
		INSERT_WORDS(x, hx | sx, lx);
	} else
	{									/* subnormal output */
		n = -1022 - iy;
		if (n <= 20)
		{
			lx = (lx >> n) | ((uint32_t) hx << (32 - n));
			hx >>= n;
		} else if (n <= 31)
		{
			lx = (hx << (32 - n)) | (lx >> n);
			hx = sx;
		} else
		{
			lx = hx >> (n - 32);
			hx = sx;
		}
		INSERT_WORDS(x, hx | sx, lx);
		x *= one;						/* create necessary signal */
	}
	return x;							/* exact output */
}

#endif

double __fmod(double x, double y)
{
	if (_LIB_VERSION != _IEEE_ && (isinf(x) || y == 0.0) && !isunordered(x, y))
		/* fmod(+-Inf,y) or fmod(x,0) */
		return __kernel_standard(x, y, y, KMATHERR_FMOD);
	return __ieee754_fmod(x, y);
}

__typeof(__fmod) fmod __attribute__((weak, alias("__fmod")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(__fmodl) __fmodl __attribute__((alias("__fmod")));
__typeof(__fmodl) fmodl __attribute__((weak, alias("__fmod")));
#endif

```

`e_fmodf.c`:

```c
/* e_fmodf.c -- float version of e_fmod.c.
 * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/*
 * __ieee754_fmodf(x,y)
 * Return x mod y in exact arithmetic
 * Method: shift and subtract
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_fmod

float __ieee754_fmodf(float x, float y)
{
	int32_t n, hx, hy, hz, ix, iy, sx, i;

	static const float one = 1.0;
	static const float Zero[] = { 0.0, -0.0 };

	GET_FLOAT_WORD(hx, x);
	GET_FLOAT_WORD(hy, y);
	sx = hx & IC(0x80000000);			/* sign of x */
	hx ^= sx;							/* |x| */
	hy &= IC(0x7fffffff);				/* |y| */

	/* purge off exception values */
	if (hy == 0 || (hx >= IC(0x7f800000)) ||	/* y=0,or x not finite */
		(hy > IC(0x7f800000)))				/* or y is NaN */
		return (x * y) / (x * y);
	if (hx < hy)
		return x;						/* |x|<|y| return x */
	if (hx == hy)
		return Zero[(uint32_t) sx >> 31];	/* |x|=|y| return x*0 */

	/* determine ix = ilogb(x) */
	if (hx < IC(0x00800000))
	{									/* subnormal x */
		for (ix = -126, i = (hx << 8); i > 0; i <<= 1)
			ix -= 1;
	} else
		ix = (hx >> 23) - 127;

	/* determine iy = ilogb(y) */
	if (hy < IC(0x00800000))
	{									/* subnormal y */
		for (iy = -126, i = (hy << 8); i >= 0; i <<= 1)
			iy -= 1;
	} else
		iy = (hy >> 23) - 127;

	/* set up {hx,lx}, {hy,ly} and align y to x */
	if (ix >= -126)
		hx = IC(0x00800000) | (IC(0x007fffff) & hx);
	else
	{									/* subnormal x, shift x to normal */
		n = -126 - ix;
		hx = hx << n;
	}
	if (iy >= -126)
		hy = IC(0x00800000) | (IC(0x007fffff) & hy);
	else
	{									/* subnormal y, shift y to normal */
		n = -126 - iy;
		hy = hy << n;
	}

	/* fix point fmod */
	n = ix - iy;
	while (n--)
	{
		hz = hx - hy;
		if (hz < 0)
		{
			hx = hx + hx;
		} else
		{
			if (hz == 0)				/* return sign(x)*0 */
				return Zero[(uint32_t) sx >> 31];
			hx = hz + hz;
		}
	}
	hz = hx - hy;
	if (hz >= 0)
	{
		hx = hz;
	}

	/* convert back to floating value and restore the sign */
	if (hx == 0)						/* return sign(x)*0 */
		return Zero[(uint32_t) sx >> 31];
	while (hx < IC(0x00800000))
	{									/* normalize x */
		hx = hx + hx;
		iy -= 1;
	}
	if (iy >= -126)
	{									/* normalize output */
		hx = ((hx - IC(0x00800000)) | ((iy + 127) << 23));
		SET_FLOAT_WORD(x, hx | sx);
	} else
	{									/* subnormal output */
		n = -126 - iy;
		hx >>= n;
		SET_FLOAT_WORD(x, hx | sx);
		x *= one;						/* create necessary signal */
	}
	return x;							/* exact output */
}

#endif

float __fmodf(float x, float y)
{
	if ((isinf(x) || y == 0.0F) && _LIB_VERSION != _IEEE_ && !isunordered(x, y))
		/* fmod(+-Inf,y) or fmod(x,0) */
		return __kernel_standard_f(x, y, y, KMATHERRF_FMOD);
	return __ieee754_fmodf(x, y);
}

__typeof(__fmodf) fmodf __attribute__((weak, alias("__fmodf")));

```

`e_fmodl.c`:

```c
/* e_fmodl.c -- long double version of e_fmod.c.
 * Conversion to IEEE quad long double by Jakub Jelinek, jj@ultra.linux.cz.
 */
/*
 * ====================================================
 * Copyright (C) 1993, 2011 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/*
 * __ieee754_fmodl(x,y)
 * Return x mod y in exact arithmetic
 * Method: shift and subtract
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

#ifndef __have_fpu_fmod

long double __ieee754_fmodl(long double x, long double y)
{
	long double intpart;

	if (isinf(y))
	{
		if (isinf(x))
			return x < 0 ? -0.0L : 0.0L;
		return x;
	}
	if (__ieee754_fabsl(x) <= __ieee754_fabsl(y))
		return x;
	(void) __ieee754_modfl(x / y, &intpart);
	return x - y * intpart;
}

#endif

long double __fmodl(long double x, long double y)
{
	if ((isinf(x) || y == 0.0) && _LIB_VERSION != _IEEE_ && !isunordered(x, y))
		/* fmod(+-Inf,y) or fmod(x,0) */
		return __kernel_standard_l(x, y, y, KMATHERRL_FMOD);
	return __ieee754_fmodl(x, y);
}

__typeof(__fmodl) fmodl __attribute__((weak, alias("__fmodl")));

#endif

```

`e_hypot.c`:

```c
/* @(#)e_hypot.c 1.3 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice 
 * is preserved.
 * ====================================================
 */

/* __ieee754_hypot(x,y)
 *
 * Method :                  
 *	If (assume round-to-nearest) z=x*x+y*y 
 *	has error less than sqrt(2)/2 ulp, than 
 *	sqrt(z) has error less than 1 ulp (exercise).
 *
 *	So, compute sqrt(x*x+y*y) with some care as 
 *	follows to get the error below 1 ulp:
 *
 *	Assume x>y>0;
 *	(if possible, set rounding to round-to-nearest)
 *	1. if x > 2y  use
 *		x1*x1+(y*y+(x2*(x+x1))) for x*x+y*y
 *	where x1 = x with lower 32 bits cleared, x2 = x-x1; else
 *	2. if x <= 2y use
 *		t1*y1+((x-y)*(x-y)+(t1*y2+t2*y))
 *	where t1 = 2x with lower 32 bits cleared, t2 = 2x-t1, 
 *	y1= y with lower 32 bits chopped, y2 = y-y1.
 *		
 *	NOTE: scaling may be necessary if some argument is too 
 *	      large or too tiny
 *
 * Special cases:
 *	hypot(x,y) is INF if x or y is +INF or -INF; else
 *	hypot(x,y) is NAN if x or y is NAN.
 *
 * Accuracy:
 * 	hypot(x,y) returns sqrt(x^2+y^2) with error less 
 * 	than 1 ulps (units in the last place) 
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_hypot

double __ieee754_hypot(double x, double y)
{
	double a, b, t1, t2, y1, y2, w;
	int32_t j, k, ha, hb;

	GET_HIGH_WORD(ha, x);
	ha &= IC(0x7fffffff);
	GET_HIGH_WORD(hb, y);
	hb &= IC(0x7fffffff);
	if (hb > ha)
	{
		a = y;
		b = x;
		j = ha;
		ha = hb;
		hb = j;
	} else
	{
		a = x;
		b = y;
	}
	SET_HIGH_WORD(a, ha);				/* a <- |a| */
	SET_HIGH_WORD(b, hb);				/* b <- |b| */
	if ((ha - hb) > IC(0x3c00000))
	{
		return a + b;
	}									/* x/y > 2**60 */
	k = 0;
	if (ha > IC(0x5f300000))
	{									/* a>2**500 */
		if (ha >= IC(0x7ff00000))
		{								/* Inf or NaN */
			uint32_t low;

			w = a + b;					/* for sNaN */
			GET_LOW_WORD(low, a);
			if (((ha & IC(0xfffff)) | low) == 0)
				w = a;
			GET_LOW_WORD(low, b);
			if (((hb ^ IC(0x7ff00000)) | low) == 0)
				w = b;
			return w;
		}
		/* scale a and b by 2**-600 */
		ha -= IC(0x25800000);
		hb -= IC(0x25800000);
		k += 600;
		SET_HIGH_WORD(a, ha);
		SET_HIGH_WORD(b, hb);
	}
	if (hb < IC(0x20b00000))
	{									/* b < 2**-500 */
		if (hb <= IC(0x000fffff))
		{								/* subnormal b or 0 */
			uint32_t low;

			GET_LOW_WORD(low, b);
			if ((hb | low) == 0)
				return a;
			t1 = 0;
			SET_HIGH_WORD(t1, IC(0x7fd00000));	/* t1=2^1022 */
			b *= t1;
			a *= t1;
			k -= 1022;
		} else
		{								/* scale a and b by 2^600 */
			ha += IC(0x25800000);		/* a *= 2^600 */
			hb += IC(0x25800000);		/* b *= 2^600 */
			k -= 600;
			SET_HIGH_WORD(a, ha);
			SET_HIGH_WORD(b, hb);
		}
	}
	/* medium size a and b */
	w = a - b;
	if (w > b)
	{
		t1 = 0;
		SET_HIGH_WORD(t1, ha);
		t2 = a - t1;
		w = __ieee754_sqrt(t1 * t1 - (b * (-b) - t2 * (a + t1)));
	} else
	{
		a = a + a;
		y1 = 0;
		SET_HIGH_WORD(y1, hb);
		y2 = b - y1;
		t1 = 0;
		SET_HIGH_WORD(t1, ha + IC(0x00100000));
		t2 = a - t1;
		w = __ieee754_sqrt(t1 * y1 - (w * (-w) - (t1 * y2 + t2 * b)));
	}
	if (k != 0)
	{
		return __ieee754_scalbn(w, (int)k);
	}
	return w;
}
#endif

/* wrapper hypot(x,y) */
double __hypot(double x, double y)
{
	double z = __ieee754_hypot(x, y);

	if (!isfinite(z) && isfinite(x) && isfinite(y) && _LIB_VERSION != _IEEE_)
		return __kernel_standard(x, y, z, KMATHERR_HYPOT);	/* hypot overflow */

	return z;
}

__typeof(__hypot) hypot __attribute__((weak, alias("__hypot")));
#ifdef __NO_LONG_DOUBLE_MATH
long double __hypotl(long double x, long double y) __attribute__((alias("__hypot")));
__typeof(__hypotl) hypotl __attribute__((weak, alias("__hypot")));
#endif

```

`e_hypotf.c`:

```c
/* e_hypotf.c -- float version of e_hypot.c.
 * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice 
 * is preserved.
 * ====================================================
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_hypot
float __ieee754_hypotf(float x, float y)
{
	float a, b,	t1,	t2,	y1,	y2,	w;
	int32_t j, k, ha, hb;

	GET_FLOAT_WORD(ha, x);
	ha &= IC(0x7fffffff);
	GET_FLOAT_WORD(hb, y);
	hb &= IC(0x7fffffff);
	if (hb > ha)
	{
		a = y;
		b = x;
		j = ha;
		ha = hb;
		hb = j;
	} else
	{
		a = x;
		b = y;
	}
	SET_FLOAT_WORD(a, ha);				/* a <- |a| */
	SET_FLOAT_WORD(b, hb);				/* b <- |b| */
	if ((ha - hb) > IC(0x0f000000))
	{
		return a + b;
	}									/* x/y > 2**30 */
	k = 0;
	if (ha > IC(0x58800000))
	{									/* a>2**50 */
		if (!FLT_UWORD_IS_FINITE(ha))
		{								/* Inf or NaN */
			w = a + b;					/* for sNaN */
			if (FLT_UWORD_IS_INFINITE(ha))
				w = a;
			if (FLT_UWORD_IS_INFINITE(hb))
				w = b;
			return w;
		}
		/* scale a and b by 2**-68 */
		ha -= IC(0x22000000);
		hb -= IC(0x22000000);
		k += 68;
		SET_FLOAT_WORD(a, ha);
		SET_FLOAT_WORD(b, hb);
	}
	if (hb < IC(0x26800000))
	{									/* b < 2**-50 */
		if (FLT_UWORD_IS_ZERO(hb))
		{
			return a;
		} else if (FLT_UWORD_IS_SUBNORMAL(hb))
		{
			SET_FLOAT_WORD(t1, IC(0x7e800000));	/* t1=2^126 */
			b *= t1;
			a *= t1;
			k -= 126;
		} else
		{								/* scale a and b by 2^68 */
			ha += IC(0x22000000);		/* a *= 2^68 */
			hb += IC(0x22000000);		/* b *= 2^68 */
			k -= 68;
			SET_FLOAT_WORD(a, ha);
			SET_FLOAT_WORD(b, hb);
		}
	}
	/* medium size a and b */
	w = a - b;
	if (w > b)
	{
		SET_FLOAT_WORD(t1, ha & IC(0xfffff000));
		t2 = a - t1;
		w = __ieee754_sqrtf(t1 * t1 - (b * (-b) - t2 * (a + t1)));
	} else
	{
		a = a + a;
		SET_FLOAT_WORD(y1, hb & IC(0xfffff000));
		y2 = b - y1;
		SET_FLOAT_WORD(t1, ha + IC(0x00800000));
		t2 = a - t1;
		w = __ieee754_sqrtf(t1 * y1 - (w * (-w) - (t1 * y2 + t2 * b)));
	}
	if (k != 0)
	{
		SET_FLOAT_WORD(t1, IC(0x3f800000) + (k << 23));
		return t1 * w;
	}
	return w;
}
#endif


float __hypotf(float x, float y)
{
	float z = __ieee754_hypotf(x, y);

	if (!isfinite(z) && isfinite(x) && isfinite(y) && _LIB_VERSION != _IEEE_)
		return __kernel_standard_f(x, y, z, KMATHERRF_HYPOT);	/* hypot overflow */

	return z;
}

__typeof(__hypotf) hypotf __attribute__((weak, alias("__hypotf")));

```

`e_hypotl.c`:

```c
/* e_hypotl.c -- long double version of e_hypot.c.
 * Conversion to long double by Ulrich Drepper,
 * Cygnus Support, drepper@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/* __ieee754_hypotl(x,y)
 *
 * Method :
 *	If (assume round-to-nearest) z=x*x+y*y
 *	has error less than sqrt(2)/2 ulp, than
 *	sqrt(z) has error less than 1 ulp (exercise).
 *
 *	So, compute sqrt(x*x+y*y) with some care as
 *	follows to get the error below 1 ulp:
 *
 *	Assume x>y>0;
 *	(if possible, set rounding to round-to-nearest)
 *	1. if x > 2y  use
 *		x1*x1+(y*y+(x2*(x+x1))) for x*x+y*y
 *	where x1 = x with lower 32 bits cleared, x2 = x-x1; else
 *	2. if x <= 2y use
 *		t1*y1+((x-y)*(x-y)+(t1*y2+t2*y))
 *	where t1 = 2x with lower 32 bits cleared, t2 = 2x-t1,
 *	y1= y with lower 32 bits chopped, y2 = y-y1.
 *
 *	NOTE: scaling may be necessary if some argument is too
 *	      large or too tiny
 *
 * Special cases:
 *	hypot(x,y) is INF if x or y is +INF or -INF; else
 *	hypot(x,y) is NAN if x or y is NAN.
 *
 * Accuracy:
 *	hypot(x,y) returns sqrt(x^2+y^2) with error less
 *	than 1 ulps (units in the last place)
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

#ifndef __have_fpu_hypot

long double __ieee754_hypotl(long double x, long double y)
{
	long double a, b, t1, t2, y1, y2, w;
	uint32_t j, k, ea, eb;

	GET_LDOUBLE_EXP(ea, x);
	ea &= 0x7fff;
	GET_LDOUBLE_EXP(eb, y);
	eb &= 0x7fff;
	if (eb > ea)
	{
		a = y;
		b = x;
		j = ea;
		ea = eb;
		eb = j;
	} else
	{
		a = x;
		b = y;
	}
	SET_LDOUBLE_EXP(a, ea);				/* a <- |a| */
	SET_LDOUBLE_EXP(b, eb);				/* b <- |b| */
	if ((ea - eb) > 0x46)
	{
		return a + b;
	}									/* x/y > 2**70 */
	k = 0;
	if (ea > 0x5f3f)
	{									/* a>2**8000 */
		if (ea == 0x7fff)
		{								/* Inf or NaN */
			uint32_t high, low;

			w = a + b;					/* for sNaN */
			GET_LDOUBLE_WORDS(ea, high, low, a);
			if (((high & IC(0x7fffffff)) | low) == 0)
				w = a;
			GET_LDOUBLE_WORDS(eb, high, low, b);
			if (((eb ^ 0x7fff) | (high & IC(0x7fffffff)) | low) == 0)
				w = b;
			return w;
		}
		/* scale a and b by 2**-9600 */
		ea -= 0x2580;
		eb -= 0x2580;
		k += 9600;
		SET_LDOUBLE_EXP(a, ea);
		SET_LDOUBLE_EXP(b, eb);
	}
	if (eb < 0x20bf)
	{									/* b < 2**-8000 */
		if (eb == 0)
		{								/* subnormal b or 0 */
			uint32_t high, low;

			GET_LDOUBLE_WORDS(eb, high, low, b);
			if ((high | low) == 0)
				return a;
			SET_LDOUBLE_WORDS(t1, 0x7ffd, UC(0x80000000), 0);	/* t1=2^16382 */
			b *= t1;
			a *= t1;
			k -= 16382;
			GET_LDOUBLE_EXP(ea, a);
			GET_LDOUBLE_EXP(eb, b);
			if (eb > ea)
			{
				t1 = a;
				a = b;
				b = t1;
				j = ea;
				ea = eb;
				eb = j;
			}
		} else
		{								/* scale a and b by 2^9600 */
			ea += 0x2580;				/* a *= 2^9600 */
			eb += 0x2580;				/* b *= 2^9600 */
			k -= 9600;
			SET_LDOUBLE_EXP(a, ea);
			SET_LDOUBLE_EXP(b, eb);
		}
	}
	/* medium size a and b */
	w = a - b;
	if (w > b)
	{
		uint32_t high;

		GET_LDOUBLE_MSW(high, a);
		SET_LDOUBLE_WORDS(t1, ea, high, 0);
		t2 = a - t1;
		w = __ieee754_sqrtl(t1 * t1 - (b * (-b) - t2 * (a + t1)));
	} else
	{
		uint32_t high;

		GET_LDOUBLE_MSW(high, b);
		a = a + a;
		SET_LDOUBLE_WORDS(y1, eb, high, 0);
		y2 = b - y1;
		GET_LDOUBLE_MSW(high, a);
		SET_LDOUBLE_WORDS(t1, ea + 1, high, 0);
		t2 = a - t1;
		w = __ieee754_sqrtl(t1 * y1 - (w * (-w) - (t1 * y2 + t2 * b)));
	}
	if (k != 0)
	{
		return __ieee754_scalbnl(w, (int)k);
	}
	return w;
}
#endif

long double __hypotl(long double x, long double y)
{
	long double z = __ieee754_hypotl(x, y);

	if (!isfinite(z) && isfinite(x) && isfinite(y) && _LIB_VERSION != _IEEE_)
		return __kernel_standard_l(x, y, z, KMATHERRL_HYPOT);	/* hypot overflow */

	return z;
}

__typeof(__hypotl) hypotl __attribute__((weak, alias("__hypotl")));

#endif

```

`e_ilogb.c`:

```c
/* @(#)s_ilogb.c 1.3 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/* ilogb(double x)
 * return the binary exponent of non-zero x
 * ilogb(0) = FP_ILOGB0
 * ilogb(NaN) = FP_ILOGBNAN (no signal is raised)
 * ilogb(+-Inf) = INT_MAX (no signal is raised)
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_ilogb

int __ieee754_ilogb(double x)
{
	int32_t hx, lx, ix;

	GET_HIGH_WORD(hx, x);
	hx &= IC(0x7fffffff);
	if (hx < IC(0x00100000))
	{
		GET_LOW_WORD(lx, x);
		if ((hx | lx) == 0)
			return FP_ILOGB0;			/* ilogb(0) = FP_ILOGB0 */
		/* subnormal x */
		if (hx == 0)
		{
			for (ix = -1043; lx > 0; lx <<= 1)
				ix -= 1;
		} else
		{
			for (ix = -1022, hx <<= 11; hx > 0; hx <<= 1)
				ix -= 1;
		}
		return (int)ix;
	}
	if (hx < IC(0x7ff00000))
		return (int)((hx >> IEEE754_DOUBLE_SHIFT) - IEEE754_DOUBLE_BIAS);
#if FP_ILOGBNAN != INT_MAX
	/* ISO C99 requires ilogb(+-Inf) == INT_MAX.  */
	GET_LOW_WORD(lx, x);
	if (((hx ^ IC(0x7ff00000)) | lx) == 0)
		return INT_MAX;
#endif
	return FP_ILOGBNAN;
}

#endif

/* wrapper ilogb */
int __ilogb(double x)
{
	int r = __ieee754_ilogb(x);

	if (r == FP_ILOGB0 ||
		r == FP_ILOGBNAN ||
		r == INT_MAX)
	{
		__kernel_standard(x, x, x, KMATHERR_ILOGB);
	}
	return r;
}

__typeof(__ilogb) ilogb __attribute__((weak, alias("__ilogb")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(__ilogbl) __ilogbl __attribute__((alias("__ilogb")));
__typeof(__ilogbl) ilogbl __attribute__((weak, alias("__ilogb")));
#endif

```

`e_ilogbf.c`:

```c
/* s_ilogbf.c -- float version of s_ilogb.c.
 * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_ilogb

int __ieee754_ilogbf(float x)
{
	int32_t hx, ix;

	GET_FLOAT_WORD(hx, x);
	hx &= IC(0x7fffffff);
	if (hx < IC(0x00800000))
	{
		if (hx == 0)
			return FP_ILOGB0;			/* ilogb(0) = FP_ILOGB0 */
		/* subnormal x */
		for (ix = -126, hx <<= 8; hx > 0; hx <<= 1)
			ix -= 1;
		return (int)ix;
	}
	if (hx < IC(0x7f800000))
		return (int)((hx >> IEEE754_FLOAT_SHIFT) - IEEE754_FLOAT_BIAS);
#if FP_ILOGBNAN != INT_MAX
	/* ISO C99 requires ilogbf(+-Inf) == INT_MAX.  */
	if (hx == IC(0x7f800000))
		return INT_MAX;
#endif
	return FP_ILOGBNAN;
}

#endif

/* wrapper ilogbf */
int __ilogbf(float x)
{
	int r = __ieee754_ilogbf(x);

	if (r == FP_ILOGB0 || r == FP_ILOGBNAN || r == INT_MAX)
	{
		__kernel_standard_f(x, x, x, KMATHERRF_ILOGB);
	}
	return r;
}

__typeof(__ilogbf) ilogbf __attribute__((weak, alias("__ilogbf")));

```

`e_ilogbl.c`:

```c
/* s_ilogbl.c -- long double version of s_ilogb.c.
 * Conversion to long double by Ulrich Drepper,
 * Cygnus Support, drepper@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/* ilogbl(long double x)
 * return the binary exponent of non-zero x
 * ilogbl(0) = FP_ILOGB0
 * ilogbl(NaN) = FP_ILOGBNAN (no signal is raised)
 * ilogbl(+-Inf) = INT_MAX (no signal is raised)
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

#ifndef __have_fpu_ilogb

int __ieee754_ilogbl(long double x)
{
	int32_t es, hx, lx, ix;

	GET_LDOUBLE_EXP(es, x);
	es &= 0x7fff;
	if (es == 0)
	{
		GET_LDOUBLE_WORDS(es, hx, lx, x);
		hx &= IC(0x7fffffff);
		if ((hx | lx) == 0)
			return FP_ILOGB0;			/* ilogbl(0) = FP_ILOGB0 */
		/* subnormal x */
		if (hx == 0)
		{
			for (ix = -16414; lx > 0; lx <<= 1)
				ix -= 1;
		} else
		{
			for (ix = -16383, hx <<= 1; hx > 0; hx <<= 1)
				ix -= 1;
		}
		return (int)ix;
	}
	if (es < 0x7fff)
		return (int)es - 0x3fff;
#if FP_ILOGBNAN != INT_MAX
	GET_LDOUBLE_WORDS(es, hx, lx, x);
	if (((hx & IC(0x7fffffff)) | lx) == 0)
		/* ISO C99 requires ilogbl(+-Inf) == INT_MAX.  */
		return INT_MAX;
#endif
	return FP_ILOGBNAN;
}

#endif

/* wrapper ilogbl */
int __ilogbl(long double x)
{
	int r = __ieee754_ilogbl(x);

	if (r == FP_ILOGB0 ||
		r == FP_ILOGBNAN ||
		r == INT_MAX)
	{
		__kernel_standard_l(x, x, x, KMATHERRL_ILOGB);
	}
	return r;
}

__typeof(__ilogbl) ilogbl __attribute__((weak, alias("__ilogbl")));

#endif

```

`e_j0.c`:

```c
/* @(#)e_j0.c 1.3 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */
/* Modified by Naohiko Shimizu/Tokai University, Japan 1997/08/26,
   for performance improvement on pipelined processors.
*/

/* __ieee754_j0(x)
 * Bessel function of the first kind of order zero.
 * Method -- j0(x):
 *	1. For tiny x, we use j0(x) = 1 - x^2/4 + x^4/64 - ...
 *	2. Reduce x to |x| since j0(x)=j0(-x),  and
 *	   for x in (0,2)
 *		j0(x) = 1-z/4+ z^2*R0/S0,  where z = x*x;
 *	   (precision:  |j0-1+z/4-z^2R0/S0 |<2**-63.67 )
 *	   for x in (2,inf)
 *      j0(x) = sqrt(2/(pi*x))*(p0(x)*cos(x0)-q0(x)*sin(x0))
 *     where x0 = x-pi/4. It is better to compute sin(x0),cos(x0)
 *	   as follow:
 *		cos(x0) = cos(x)cos(pi/4)+sin(x)sin(pi/4)
 *			= 1/sqrt(2) * (cos(x) + sin(x))
 *		sin(x0) = sin(x)cos(pi/4)-cos(x)sin(pi/4)
 *			= 1/sqrt(2) * (sin(x) - cos(x))
 *     (To avoid cancellation, use
 *		sin(x) +- cos(x) = -cos(2x)/(sin(x) -+ cos(x))
 *      to compute the worse one.)
 *
 *	3 Special cases
 *		j0(nan)= nan
 *		j0(0) = 1
 *		j0(inf) = 0
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

double __ieee754_j0(double x)
{
	double z, s, c, ss, cc, r, u, v, r1, r2, s1, s2, z2, z4;
	int32_t hx, ix;

	static const double hugeval = 1e300;
	static const double one = 1.0;
	static const double zero = 0.0;
	static const double invsqrtpi = 5.64189583547756279280e-01;	/* 0x3FE20DD7, 0x50429B6D */

	/* R0/S0 on [0, 2.00] */
	static const double R02 = 1.56249999999999947958e-02;	/* 0x3F8FFFFF, 0xFFFFFFFD */
	static const double R03 = -1.89979294238854721751e-04;	/* 0xBF28E6A5, 0xB61AC6E9 */
	static const double R04 = 1.82954049532700665670e-06;	/* 0x3EBEB1D1, 0x0C503919 */
	static const double R05 = -4.61832688532103189199e-09;	/* 0xBE33D5E7, 0x73D63FCE */
	static const double S01 = 1.56191029464890010492e-02;	/* 0x3F8FFCE8, 0x82C8C2A4 */
	static const double S02 = 1.16926784663337450260e-04;	/* 0x3F1EA6D2, 0xDD57DBF4 */
	static const double S03 = 5.13546550207318111446e-07;	/* 0x3EA13B54, 0xCE84D5A9 */
	static const double S04 = 1.16614003333790000205e-09;	/* 0x3E1408BC, 0xF4745D8F */

	GET_HIGH_WORD(hx, x);
	ix = hx & IC(0x7fffffff);
	if (ix >= IC(0x7ff00000))
		return one / (x * x);
	x = __ieee754_fabs(x);
	if (ix >= IC(0x40000000))
	{									/* |x| >= 2.0 */
		__ieee754_sincos(x, &s, &c);
		ss = s - c;
		cc = s + c;
		if (ix < IC(0x7fe00000))
		{								/* make sure x+x not overflow */
			z = -__ieee754_cos(x + x);
			if ((s * c) < zero)
				cc = z / ss;
			else
				ss = z / cc;
		}
		/*
		 * j0(x) = 1/sqrt(pi) * (P(0,x)*cc - Q(0,x)*ss) / sqrt(x)
		 * y0(x) = 1/sqrt(pi) * (P(0,x)*ss + Q(0,x)*cc) / sqrt(x)
		 */
		if (ix > IC(0x48000000))
			z = (invsqrtpi * cc) / __ieee754_sqrt(x);
		else
		{
			u = __j0_y0_pzero(x);
			v = __j0_y0_qzero(x);
			z = invsqrtpi * (u * cc - v * ss) / __ieee754_sqrt(x);
		}
		return z;
	}
	if (ix < IC(0x3f200000))
	{									/* |x| < 2**-13 */
		math_force_eval(hugeval + x);	/* raise inexact if x != 0 */
		if (ix < IC(0x3e400000))
			return one;					/* |x|<2**-27 */
		else
			return one - 0.25 * x * x;
	}
	z = x * x;
#ifdef DO_NOT_USE_THIS
	r = z * (R02 + z * (R03 + z * (R04 + z * R05)));
	s = one + z * (S01 + z * (S02 + z * (S03 + z * S04)));
#else
	r1 = z * R02;
	z2 = z * z;
	r2 = R03 + z * R04;
	z4 = z2 * z2;
	r = r1 + z2 * r2 + z4 * R05;
	s1 = one + z * S01;
	s2 = S02 + z * S03;
	s = s1 + z2 * s2 + z4 * S04;
#endif
	if (ix < IC(0x3FF00000))
	{									/* |x| < 1.00 */
		return one + z * (-0.25 + (r / s));
	} else
	{
		u = 0.5 * x;
		return ((one + u) * (one - u) + z * (r / s));
	}
}


/* wrapper j0 */
double __j0(double x)
{
	if (isgreater(__ieee754_fabs(x), X_TLOSS) && _LIB_VERSION != _IEEE_ && _LIB_VERSION != _POSIX_)
		/* j0(|x|>X_TLOSS) */
		return __kernel_standard(x, x, 0.0, KMATHERR_J0_TLOSS);

	return __ieee754_j0(x);
}

__typeof(__j0) j0 __attribute__((weak, alias("__j0")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(__j0l) __j0l __attribute__((alias("__j0")));
__typeof(__j0l) j0l __attribute__((weak, alias("__j0l")));
#endif

```

`e_j0f.c`:

```c
/* e_j0f.c -- float version of e_j0.c.
 * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

float __ieee754_j0f(float x)
{
	float z, s, c, ss, cc, r, u, v;
	int32_t hx, ix;

	static const float hugeval = 1e30;
	static const float one = 1.0;
	static const float invsqrtpi = 5.6418961287e-01;		/* 0x3f106ebb */
	static const float zero = 0.0;
	
	/* R0/S0 on [0, 2.00] */
	static const float R02 = 1.5625000000e-02;				/* 0x3c800000 */
	static const float R03 = -1.8997929874e-04;				/* 0xb947352e */
	static const float R04 = 1.8295404516e-06;				/* 0x35f58e88 */
	static const float R05 = -4.6183270541e-09;				/* 0xb19eaf3c */
	static const float S01 = 1.5619102865e-02;				/* 0x3c7fe744 */
	static const float S02 = 1.1692678527e-04;				/* 0x38f53697 */
	static const float S03 = 5.1354652442e-07;				/* 0x3509daa6 */
	static const float S04 = 1.1661400734e-09;				/* 0x30a045e8 */

	GET_FLOAT_WORD(hx, x);
	ix = hx & IC(0x7fffffff);
	if (!FLT_UWORD_IS_FINITE(ix))
		return one / (x * x);
	x = __ieee754_fabsf(x);
	if (ix >= IC(0x40000000))
	{									/* |x| >= 2.0 */
		__ieee754_sincosf(x, &s, &c);
		ss = s - c;
		cc = s + c;
		if (ix <= FLT_UWORD_HALF_MAX)
		{								/* make sure x+x not overflow */
			z = -__ieee754_cosf(x + x);
			if ((s * c) < zero)
				cc = z / ss;
			else
				ss = z / cc;
		}
		/*
		 * j0(x) = 1/sqrt(pi) * (P(0,x)*cc - Q(0,x)*ss) / sqrt(x)
		 * y0(x) = 1/sqrt(pi) * (P(0,x)*ss + Q(0,x)*cc) / sqrt(x)
		 */
		if (ix > IC(0x48000000))
			z = (invsqrtpi * cc) / __ieee754_sqrtf(x);
		else
		{
			u = __j0_y0_pzerof(x);
			v = __j0_y0_qzerof(x);
			z = invsqrtpi * (u * cc - v * ss) / __ieee754_sqrtf(x);
		}
		return z;
	}
	if (ix < IC(0x39000000))
	{									/* |x| < 2**-13 */
		math_force_eval(hugeval + x);	/* raise inexact if x != 0 */
		if (ix < IC(0x32000000))
			return one;					/* |x|<2**-27 */
		else
			return one - 0.25f * x * x;
	}
	z = x * x;
	r = z * (R02 + z * (R03 + z * (R04 + z * R05)));
	s = one + z * (S01 + z * (S02 + z * (S03 + z * S04)));
	if (ix < IC(0x3F800000))
	{									/* |x| < 1.00 */
		return one + z * (-0.25f + (r / s));
	} else
	{
		u = 0.5f * x;

		return ((one + u) * (one - u) + z * (r / s));
	}
}


/* wrapper j0 */
float __j0f(float x)
{
	if (isgreater(__ieee754_fabsf(x), X_TLOSS) && _LIB_VERSION != _IEEE_ && _LIB_VERSION != _POSIX_)
		/* j0(|x|>X_TLOSS) */
		return __kernel_standard_f(x, x, 0.0f, KMATHERRF_J0_TLOSS);

	return __ieee754_j0f(x);
}

__typeof(__j0f) j0f __attribute__((weak, alias("__j0f")));

```

`e_j0l.c`:

```c
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/* Long double expansions are
  Copyright (C) 2001 Stephen L. Moshier <moshier@na-net.ornl.gov>
  and are incorporated herein by permission of the author.  The author
  reserves the right to distribute this material elsewhere under different
  copying permissions.  These modifications are distributed here under
  the following terms:

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, see
    <http://www.gnu.org/licenses/>.  */

/* __ieee754_j0(x)
 * Bessel function of the first kind of order zero.
 * Method -- j0(x):
 *	1. For tiny x, we use j0(x) = 1 - x^2/4 + x^4/64 - ...
 *	2. Reduce x to |x| since j0(x)=j0(-x),  and
 *	   for x in (0,2)
 *		j0(x) = 1 - z/4 + z^2*R0/S0,  where z = x*x;
 *	   for x in (2,inf)
 *		j0(x) = sqrt(2/(pi*x))*(p0(x)*cos(x0)-q0(x)*sin(x0))
 *	   where x0 = x-pi/4. It is better to compute sin(x0),cos(x0)
 *	   as follow:
 *		cos(x0) = cos(x)cos(pi/4)+sin(x)sin(pi/4)
 *			= 1/sqrt(2) * (cos(x) + sin(x))
 *		sin(x0) = sin(x)cos(pi/4)-cos(x)sin(pi/4)
 *			= 1/sqrt(2) * (sin(x) - cos(x))
 *	   (To avoid cancellation, use
 *		sin(x) +- cos(x) = -cos(2x)/(sin(x) -+ cos(x))
 *	    to compute the worse one.)
 *
 *	3 Special cases
 *		j0(nan)= nan
 *		j0(0) = 1
 *		j0(inf) = 0
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

long double __ieee754_j0l(long double x)
{
	long double z, s, c, ss, cc, r, u, v;
	int32_t ix;
	uint32_t se;

	static const long double hugeval = 1e4930L;
	static const long double one = 1.0L;
	static const long double invsqrtpi = 5.6418958354775628694807945156077258584405e-1L;
	static const long double zero = 0.0;
	
	/* J0(x) = 1 - x^2 / 4 + x^4 R0(x^2) / S0(x^2)
	   0 <= x <= 2
	   peak relative error 1.41e-22 */
	static const long double R[5] = {
		4.287176872744686992880841716723478740566E7L,
		-6.652058897474241627570911531740907185772E5L,
		7.011848381719789863458364584613651091175E3L,
		-3.168040850193372408702135490809516253693E1L,
		6.030778552661102450545394348845599300939E-2L
	};
	static const long double S[4] =
	{
		2.743793198556599677955266341699130654342E9L,
		3.364330079384816249840086842058954076201E7L,
		1.924119649412510777584684927494642526573E5L,
		6.239282256012734914211715620088714856494E2L
		/*   1.000000000000000000000000000000000000000E0L, */
	};
	
	GET_LDOUBLE_EXP(se, x);
	ix = se & 0x7fff;
	if (ix >= 0x7fff)
		return one / (x * x);
	x = __ieee754_fabsl(x);
	if (ix >= 0x4000)					/* |x| >= 2.0 */
	{
		__ieee754_sincosl(x, &s, &c);
		ss = s - c;
		cc = s + c;
		if (ix < 0x7ffe)
		{								/* make sure x+x not overflow */
			z = -__ieee754_cosl(x + x);
			if ((s * c) < zero)
				cc = z / ss;
			else
				ss = z / cc;
		}
		/*
		 * j0(x) = 1/sqrt(pi) * (P(0,x)*cc - Q(0,x)*ss) / sqrt(x)
		 * y0(x) = 1/sqrt(pi) * (P(0,x)*ss + Q(0,x)*cc) / sqrt(x)
		 */
		if (ix > 0x4080)						/* 2^129 */
			z = (invsqrtpi * cc) / __ieee754_sqrtl(x);
		else
		{
			u = __j0_y0_pzerol(x);
			v = __j0_y0_qzerol(x);
			z = invsqrtpi * (u * cc - v * ss) / __ieee754_sqrtl(x);
		}
		return z;
	}
	if (ix < 0x3fef)					/* |x| < 2**-16 */
	{
		/* raise inexact if x != 0 */
		math_force_eval(hugeval + x);
		if (ix < 0x3fde)				/* |x| < 2^-33 */
			return one;
		else
			return one - 0.25 * x * x;
	}
	z = x * x;
	r = z * (R[0] + z * (R[1] + z * (R[2] + z * (R[3] + z * R[4]))));
	s = S[0] + z * (S[1] + z * (S[2] + z * (S[3] + z)));
	if (ix < 0x3fff)
	{									/* |x| < 1.00 */
		return (one - 0.25 * z + z * (r / s));
	} else
	{
		u = 0.5 * x;
		return ((one + u) * (one - u) + z * (r / s));
	}
}

/* wrapper j0 */
long double __j0l(long double x)
{
	if (isgreater(__ieee754_fabsl(x), X_TLOSS) && _LIB_VERSION != _IEEE_ && _LIB_VERSION != _POSIX_)
		/* j0(|x|>X_TLOSS) */
		return __kernel_standard_l(x, x, 0.0L, KMATHERRL_J0_TLOSS);

	return __ieee754_j0l(x);
}

__typeof(__j0l) j0l __attribute__((weak, alias("__j0l")));

#endif

```

`e_j1.c`:

```c
/* @(#)e_j1.c 1.3 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */
/* Modified by Naohiko Shimizu/Tokai University, Japan 1997/08/26,
   for performance improvement on pipelined processors.
*/

/* __ieee754_j1(x)
 * Bessel function of the first kind of order one.
 * Method -- j1(x):
 *	1. For tiny x, we use j1(x) = x/2 - x^3/16 + x^5/384 - ...
 *	2. Reduce x to |x| since j1(x)=-j1(-x),  and
 *	   for x in (0,2)
 *		j1(x) = x/2 + x*z*R0/S0,  where z = x*x;
 *	   (precision:  |j1/x - 1/2 - R0/S0 |<2**-61.51 )
 *	   for x in (2,inf)
 *		j1(x) = sqrt(2/(pi*x))*(p1(x)*cos(x1)-q1(x)*sin(x1))
 *		y1(x) = sqrt(2/(pi*x))*(p1(x)*sin(x1)+q1(x)*cos(x1))
 *	   where x1 = x-3*pi/4. It is better to compute sin(x1),cos(x1)
 *	   as follow:
 *		cos(x1) =  cos(x)cos(3pi/4)+sin(x)sin(3pi/4)
 *			=  1/sqrt(2) * (sin(x) - cos(x))
 *		sin(x1) =  sin(x)cos(3pi/4)-cos(x)sin(3pi/4)
 *			= -1/sqrt(2) * (sin(x) + cos(x))
 *	   (To avoid cancellation, use
 *		sin(x) +- cos(x) = -cos(2x)/(sin(x) -+ cos(x))
 *	    to compute the worse one.)
 *
 *	3 Special cases
 *		j1(nan)= nan
 *		j1(0) = 0
 *		j1(inf) = 0
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

double __ieee754_j1(double x)
{
	double z, s, c, ss, cc, r, u, v, y, r1, r2, s1, s2, s3, z2,	z4;
	int32_t hx, ix;

	static const double hugeval = 1e300;
	static const double one = 1.0;
	static const double invsqrtpi = 5.64189583547756279280e-01;	/* 0x3FE20DD7, 0x50429B6D */
	static const double zero = 0.0;

	/* R0/S0 on [0,2] */
	static const double r00 = -6.25000000000000000000e-02;	/* 0xBFB00000, 0x00000000 */
	static const double r01 = 1.40705666955189706048e-03;	/* 0x3F570D9F, 0x98472C61 */
	static const double r02 = -1.59955631084035597520e-05;	/* 0xBEF0C5C6, 0xBA169668 */
	static const double r03 = 4.96727999609584448412e-08;	/* 0x3E6AAAFA, 0x46CA0BD9 */
	static const double s01 = 1.91537599538363460805e-02;	/* 0x3F939D0B, 0x12637E53 */
	static const double s02 = 1.85946785588630915560e-04;	/* 0x3F285F56, 0xB9CDF664 */
	static const double s03 = 1.17718464042623683263e-06;	/* 0x3EB3BFF8, 0x333F8498 */
	static const double s04 = 5.04636257076217042715e-09;	/* 0x3E35AC88, 0xC97DFF2C */
	static const double s05 = 1.23542274426137913908e-11;	/* 0x3DAB2ACF, 0xCFB97ED8 */

	GET_HIGH_WORD(hx, x);
	ix = hx & IC(0x7fffffff);
	if (ix >= IC(0x7ff00000))
		return one / x;
	y = __ieee754_fabs(x);
	if (ix >= IC(0x40000000))
	{									/* |x| >= 2.0 */
		__ieee754_sincos(y, &s, &c);
		ss = -s - c;
		cc = s - c;
		if (ix < IC(0x7fe00000))
		{								/* make sure y+y not overflow */
			z = __ieee754_cos(y + y);
			if ((s * c) > zero)
				cc = z / ss;
			else
				ss = z / cc;
		}
		/*
		 * j1(x) = 1/sqrt(pi) * (P(1,x)*cc - Q(1,x)*ss) / sqrt(x)
		 * y1(x) = 1/sqrt(pi) * (P(1,x)*ss + Q(1,x)*cc) / sqrt(x)
		 */
		if (ix > IC(0x48000000))
			z = (invsqrtpi * cc) / __ieee754_sqrt(y);
		else
		{
			u = __j1_y1_pone(y);
			v = __j1_y1_qone(y);
			z = invsqrtpi * (u * cc - v * ss) / __ieee754_sqrt(y);
		}
		if (hx < 0)
			return -z;
		else
			return z;
	}
	if (ix < IC(0x3e400000))
	{									/* |x|<2**-27 */
		if (hugeval + x > one)
			return 0.5 * x;				/* inexact if x!=0 necessary */
	}
	z = x * x;
#ifdef DO_NOT_USE_THIS
	r = z * (r00 + z * (r01 + z * (r02 + z * r03)));
	s = one + z * (s01 + z * (s02 + z * (s03 + z * (s04 + z * s05))));
	r *= x;
#else
	r1 = z * r00;
	z2 = z * z;
	r2 = r01 + z * r02;
	z4 = z2 * z2;
	r = r1 + z2 * r2 + z4 * r03;
	r *= x;
	s1 = one + z * s01;
	s2 = s02 + z * s03;
	s3 = s04 + z * s05;
	s = s1 + z2 * s2 + z4 * s3;
#endif
	return (x * 0.5 + r / s);
}

/* wrapper j1 */
double __j1(double x)
{
	if (isgreater(__ieee754_fabs(x), X_TLOSS) && _LIB_VERSION != _IEEE_ && _LIB_VERSION != _POSIX_)
		/* j1(|x|>X_TLOSS) */
		return __kernel_standard(x, x, 0.0, KMATHERR_J1_TLOSS);

	return __ieee754_j1(x);
}

__typeof(__j1) j1 __attribute__((weak, alias("__j1")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(__j1l) __j1l __attribute__((alias("__j1")));
__typeof(__j1l) j1l __attribute__((weak, alias("__j1l")));
#endif

```

`e_j1f.c`:

```c
/* e_j1f.c -- float version of e_j1.c.
 * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

float __ieee754_j1f(float x)
{
	float z, s, c, ss, cc, r, u, v, y;
	int32_t hx, ix;

	static const float hugeval = 1e30;
	static const float one = 1.0;
	static const float invsqrtpi = 5.6418961287e-01;		/* 0x3f106ebb */
	static const float zero = 0.0;

	/* R0/S0 on [0,2] */
	static const float r00 = -6.2500000000e-02;				/* 0xbd800000 */
	static const float r01 = 1.4070566976e-03;				/* 0x3ab86cfd */
	static const float r02 = -1.5995563444e-05;				/* 0xb7862e36 */
	static const float r03 = 4.9672799207e-08;				/* 0x335557d2 */
	static const float s01 = 1.9153760746e-02;				/* 0x3c9ce859 */
	static const float s02 = 1.8594678841e-04;				/* 0x3942fab6 */
	static const float s03 = 1.1771846857e-06;				/* 0x359dffc2 */
	static const float s04 = 5.0463624390e-09;				/* 0x31ad6446 */
	static const float s05 = 1.2354227016e-11;				/* 0x2d59567e */
	
	
	GET_FLOAT_WORD(hx, x);
	ix = hx & IC(0x7fffffff);
	if (!FLT_UWORD_IS_FINITE(ix))
		return one / x;
	y = __ieee754_fabsf(x);
	if (ix >= IC(0x40000000))
	{									/* |x| >= 2.0 */
		__ieee754_sincosf(y, &s, &c);
		ss = -s - c;
		cc = s - c;
		if (ix <= FLT_UWORD_HALF_MAX)
		{								/* make sure y+y not overflow */
			z = __ieee754_cosf(y + y);
			if ((s * c) > zero)
				cc = z / ss;
			else
				ss = z / cc;
		}
		/*
		 * j1(x) = 1/sqrt(pi) * (P(1,x)*cc - Q(1,x)*ss) / sqrt(x)
		 * y1(x) = 1/sqrt(pi) * (P(1,x)*ss + Q(1,x)*cc) / sqrt(x)
		 */
		if (ix > IC(0x48000000))
			z = (invsqrtpi * cc) / __ieee754_sqrtf(y);
		else
		{
			u = __j1_y1_ponef(y);
			v = __j1_y1_qonef(y);
			z = invsqrtpi * (u * cc - v * ss) / __ieee754_sqrtf(y);
		}
		if (hx < 0)
			return -z;
		else
			return z;
	}
	if (ix < IC(0x32000000))
	{									/* |x|<2**-27 */
		if (hugeval + x > one)
			return 0.5f * x;		/* inexact if x!=0 necessary */
	}
	z = x * x;
	r = z * (r00 + z * (r01 + z * (r02 + z * r03)));
	s = one + z * (s01 + z * (s02 + z * (s03 + z * (s04 + z * s05))));
	r *= x;
	return (x * 0.5f + r / s);
}


/* wrapper j1 */
float __j1f(float x)
{
	if (isgreater(__ieee754_fabsf(x), X_TLOSS) && _LIB_VERSION != _IEEE_ && _LIB_VERSION != _POSIX_)
		/* j1(|x|>X_TLOSS) */
		return __kernel_standard_f(x, x, 0.0f, KMATHERRF_J1_TLOSS);

	return __ieee754_j1f(x);
}

__typeof(__j1f) j1f __attribute__((weak, alias("__j1f")));

```

`e_j1l.c`:

```c
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/* Long double expansions are
  Copyright (C) 2001 Stephen L. Moshier <moshier@na-net.ornl.gov>
  and are incorporated herein by permission of the author.  The author
  reserves the right to distribute this material elsewhere under different
  copying permissions.  These modifications are distributed here under
  the following terms:

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, see
    <http://www.gnu.org/licenses/>.  */

/* __ieee754_j1(x), __ieee754_y1(x)
 * Bessel function of the first kind of order one.
 * Method -- j1(x):
 *	1. For tiny x, we use j1(x) = x/2 - x^3/16 + x^5/384 - ...
 *	2. Reduce x to |x| since j1(x)=-j1(-x),  and
 *	   for x in (0,2)
 *		j1(x) = x/2 + x*z*R0/S0,  where z = x*x;
 *	   for x in (2,inf)
 *		j1(x) = sqrt(2/(pi*x))*(p1(x)*cos(x1)-q1(x)*sin(x1))
 *		y1(x) = sqrt(2/(pi*x))*(p1(x)*sin(x1)+q1(x)*cos(x1))
 *	   where x1 = x-3*pi/4. It is better to compute sin(x1),cos(x1)
 *	   as follow:
 *		cos(x1) =  cos(x)cos(3pi/4)+sin(x)sin(3pi/4)
 *			=  1/sqrt(2) * (sin(x) - cos(x))
 *		sin(x1) =  sin(x)cos(3pi/4)-cos(x)sin(3pi/4)
 *			= -1/sqrt(2) * (sin(x) + cos(x))
 *	   (To avoid cancellation, use
 *		sin(x) +- cos(x) = -cos(2x)/(sin(x) -+ cos(x))
 *	    to compute the worse one.)
 *
 *	3 Special cases
 *		j1(nan)= nan
 *		j1(0) = 0
 *		j1(inf) = 0
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

long double __ieee754_j1l(long double x)
{
	long double z, c, r, s, ss, cc, u, v, y;
	int32_t ix;
	uint32_t se;

	static const long double hugeval = 1e4930L;
	static const long double one = 1.0L;
	static const long double invsqrtpi = 5.6418958354775628694807945156077258584405e-1L;
	static const long double zero = 0.0;
	
	/* J1(x) = .5 x + x x^2 R(x^2) / S(x^2)
	   0 <= x <= 2
	   Peak relative error 4.5e-21 */
	static const long double R[5] = {
		-9.647406112428107954753770469290757756814E7L,
		2.686288565865230690166454005558203955564E6L,
		-3.689682683905671185891885948692283776081E4L,
		2.195031194229176602851429567792676658146E2L,
		-5.124499848728030297902028238597308971319E-1L
	};
	static const long double S[4] =
	{
		1.543584977988497274437410333029029035089E9L,
		2.133542369567701244002565983150952549520E7L,
		1.394077011298227346483732156167414670520E5L,
		5.252401789085732428842871556112108446506E2L
		/*  1.000000000000000000000000000000000000000E0L, */
	};
	
	GET_LDOUBLE_EXP(se, x);
	ix = se & 0x7fff;
	if (ix >= 0x7fff)
		return one / x;
	y = __ieee754_fabsl(x);
	if (ix >= 0x4000)
	{									/* |x| >= 2.0 */
		__ieee754_sincosl(y, &s, &c);
		ss = -s - c;
		cc = s - c;
		if (ix < 0x7ffe)
		{								/* make sure y+y not overflow */
			z = __ieee754_cosl(y + y);
			if ((s * c) > zero)
				cc = z / ss;
			else
				ss = z / cc;
		}
		/*
		 * j1(x) = 1/sqrt(pi) * (P(1,x)*cc - Q(1,x)*ss) / sqrt(x)
		 * y1(x) = 1/sqrt(pi) * (P(1,x)*ss + Q(1,x)*cc) / sqrt(x)
		 */
		if (ix > 0x4080)
			z = (invsqrtpi * cc) / __ieee754_sqrtl(y);
		else
		{
			u = __j1_y1_ponel(y);
			v = __j1_y1_qonel(y);
			z = invsqrtpi * (u * cc - v * ss) / __ieee754_sqrtl(y);
		}
		if (se & 0x8000)
			return -z;
		else
			return z;
	}
	if (ix < 0x3fde)						/* |x| < 2^-33 */
	{
		if (hugeval + x > one)
			return 0.5 * x;				/* inexact if x!=0 necessary */
	}
	z = x * x;
	r = z * (R[0] + z * (R[1] + z * (R[2] + z * (R[3] + z * R[4]))));
	s = S[0] + z * (S[1] + z * (S[2] + z * (S[3] + z)));
	r *= x;
	return (x * 0.5 + r / s);
}


/* wrapper j1 */
long double __j1l(long double x)
{
	if (isgreater(__ieee754_fabsl(x), X_TLOSS) && _LIB_VERSION != _IEEE_ && _LIB_VERSION != _POSIX_)
		/* j1(|x|>X_TLOSS) */
		return __kernel_standard_l(x, x, 0.0L, KMATHERRL_J1_TLOSS);

	return __ieee754_j1l(x);
}

__typeof(__j1l) j1l __attribute__((weak, alias("__j1l")));

#endif

```

`e_jn.c`:

```c
/* @(#)e_jn.c 1.4 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/*
 * __ieee754_jn(n, x)
 * floating point Bessel's function of the 1st and 2nd kind
 * of order n
 *
 * Special cases:
 *	y0(0)=y1(0)=yn(n,0) = -inf with overflow signal;
 *	y0(-ve)=y1(-ve)=yn(n,-ve) are NaN with invalid signal.
 * Note 2. About jn(n,x), yn(n,x)
 *	For n=0, j0(x) is called,
 *	for n=1, j1(x) is called,
 *	for n<x, forward recursion us used starting
 *	from values of j0(x) and j1(x).
 *	for n>x, a continued fraction approximation to
 *	j(n,x)/j(n-1,x) is evaluated and then backward
 *	recursion is used starting from a supposed value
 *	for j(n,x). The resulting value of j(0,x) is
 *	compared with the actual value to correct the
 *	supposed value of j(n,x).
 *
 *	yn(n,x) is similar in all respects, except
 *	that forward recursion is used for all
 *	values of n>1.
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

double __ieee754_jn(int n, double x)
{
	int32_t i, hx, ix, lx;
	int sgn;
	double a, b, temp, di;
	double z, w;

	static const double invsqrtpi = 5.64189583547756279280e-01;	/* 0x3FE20DD7, 0x50429B6D */
	static const double two = 2.00000000000000000000e+00;	/* 0x40000000, 0x00000000 */
	static const double one = 1.00000000000000000000e+00;	/* 0x3FF00000, 0x00000000 */
	static const double zero = 0.00000000000000000000e+00;

	/* J(-n,x) = (-1)^n * J(n, x), J(n, -x) = (-1)^n * J(n, x)
	 * Thus, J(-n,x) = J(n,-x)
	 */
	GET_DOUBLE_WORDS(hx, lx, x);
	ix = IC(0x7fffffff) & hx;
	/* if J(n,NaN) is NaN */
	if ((ix | (((uint32_t) (lx | -lx)) >> 31)) > IC(0x7ff00000))
		return x + x;
	if (n < 0)
	{
		n = -n;
		x = -x;
		hx ^= IC(0x80000000);
	}
	if (n == 0)
		return (__ieee754_j0(x));
	if (n == 1)
		return (__ieee754_j1(x));
	sgn = (int)((n & 1) & (hx >> 31));			/* even n -- 0, odd n -- sign(x) */
	x = __ieee754_fabs(x);
	if ((ix | lx) == 0 || ix >= IC(0x7ff00000))	/* if x is 0 or inf */
		b = zero;
	else if ((double) n <= x)
	{
		/* Safe to use J(n+1,x)=2n/x *J(n,x)-J(n-1,x) */
		if (ix >= IC(0x52D00000))
		{								/* x > 2**302 */
			/* (x >> n**2)
			 *      Jn(x) = cos(x-(2n+1)*pi/4)*sqrt(2/x*pi)
			 *      Yn(x) = sin(x-(2n+1)*pi/4)*sqrt(2/x*pi)
			 *      Let s=sin(x), c=cos(x),
			 *      xn=x-(2n+1)*pi/4, sqt2 = sqrt(2),then
			 *
			 *         n    sin(xn)*sqt2    cos(xn)*sqt2
			 *      ----------------------------------
			 *         0     s-c         c+s
			 *         1    -s-c        -c+s
			 *         2    -s+c        -c-s
			 *         3     s+c         c-s
			 */
			double s;
			double c;

			__ieee754_sincos(x, &s, &c);
			switch (n & 3)
			{
			case 0:
				temp = c + s;
				break;
			case 1:
				temp = -c + s;
				break;
			case 2:
				temp = -c - s;
				break;
			case 3:
				temp = c - s;
				break;
			}
			b = invsqrtpi * temp / __ieee754_sqrt(x);
		} else
		{
			a = __ieee754_j0(x);
			b = __ieee754_j1(x);
			for (i = 1; i < n; i++)
			{
				temp = b;
				b = b * ((double) (i + i) / x) - a;	/* avoid underflow */
				a = temp;
			}
		}
	} else
	{
		if (ix < IC(0x3e100000))
		{								/* x < 2**-29 */
			/* x is tiny, return the first Taylor expansion of J(n,x)
			 * J(n,x) = 1/n!*(x/2)^n  - ...
			 */
			if (n > 33)					/* underflow */
				b = zero;
			else
			{
				temp = x * 0.5;
				b = temp;
				for (a = one, i = 2; i <= n; i++)
				{
					a *= (double) i;	/* a = n! */
					b *= temp;			/* b = (x/2)^n */
				}
				b = b / a;
			}
		} else
		{
			/* use backward recurrence */
			/*          x      x^2      x^2
			 *  J(n,x)/J(n-1,x) =  ----   ------   ------   .....
			 *          2n  - 2(n+1) - 2(n+2)
			 *
			 *          1      1        1
			 *  (for large x)   =  ----  ------   ------   .....
			 *          2n   2(n+1)   2(n+2)
			 *          -- - ------ - ------ -
			 *           x     x         x
			 *
			 * Let w = 2n/x and h=2/x, then the above quotient
			 * is equal to the continued fraction:
			 *          1
			 *  = -----------------------
			 *             1
			 *     w - -----------------
			 *            1
			 *          w+h - ---------
			 *             w+2h - ...
			 *
			 * To determine how many terms needed, let
			 * Q(0) = w, Q(1) = w(w+h) - 1,
			 * Q(k) = (w+k*h)*Q(k-1) - Q(k-2),
			 * When Q(k) > 1e4  good for single
			 * When Q(k) > 1e9  good for double
			 * When Q(k) > 1e17 good for quadruple
			 */
			/* determine k */
			double t, v;
			double q0, q1, h, tmp;
			int32_t k, m;

			w = (n + n) / (double) x;
			h = 2.0 / (double) x;
			q0 = w;
			z = w + h;
			q1 = w * z - 1.0;
			k = 1;
			while (q1 < 1.0e9)
			{
				k += 1;
				z += h;
				tmp = z * q1 - q0;
				q0 = q1;
				q1 = tmp;
			}
			m = n + n;
			for (t = zero, i = 2 * (n + k); i >= m; i -= 2)
				t = one / (i / x - t);
			a = t;
			b = one;
			/*  estimate log((2/x)^n*n!) = n*log(2/x)+n*ln(n)
			 *  Hence, if n*(log(2n/x)) > ...
			 *  single 8.8722839355e+01
			 *  double 7.09782712893383973096e+02
			 *  long double 1.1356523406294143949491931077970765006170e+04
			 *  then recurrent value may overflow and the result is
			 *  likely underflow to zero
			 */
			tmp = n;
			v = two / x;
			tmp = tmp * __ieee754_log(__ieee754_fabs(v * tmp));
			if (tmp < 7.09782712893383973096e+02)
			{
				for (i = n - 1, di = (double) (i + i); i > 0; i--)
				{
					temp = b;
					b *= di;
					b = b / x - a;
					a = temp;
					di -= two;
				}
			} else
			{
				for (i = n - 1, di = (double) (i + i); i > 0; i--)
				{
					temp = b;
					b *= di;
					b = b / x - a;
					a = temp;
					di -= two;
					/* scale b to avoid spurious overflow */
					if (b > 1e100)
					{
						a /= b;
						t /= b;
						b = one;
					}
				}
			}
			/* j0() and j1() suffer enormous loss of precision at and
			 * near zero; however, we know that their zero points never
			 * coincide, so just choose the one further away from zero.
			 */
			z = __ieee754_j0(x);
			w = __ieee754_j1(x);
			if (__ieee754_fabs(z) >= __ieee754_fabs(w))
				b = (t * z / b);
			else
				b = (t * w / a);
		}
	}
	if (sgn)
		return -b;
	return b;
}

/* wrapper jn */
double __jn(int n, double x)
{
	if (isgreater(__ieee754_fabs(x), X_TLOSS) && _LIB_VERSION != _IEEE_ && _LIB_VERSION != _POSIX_)
		/* jn(n,|x|>X_TLOSS) */
		return __kernel_standard(n, x, 0.0, KMATHERR_JN_TLOSS);

	return __ieee754_jn(n, x);
}

__typeof(__jn) jn __attribute__((weak, alias("__jn")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(__jnl) __jnl __attribute__((alias("__jn")));
__typeof(__jnl) jnl __attribute__((weak, alias("__jnl")));
#endif

```

`e_jnf.c`:

```c
/* e_jnf.c -- float version of e_jn.c.
 * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

float __ieee754_jnf(int n, float x)
{
	int32_t i, hx, ix;
	int sgn;
	float a, b, temp, di;
	float z, w;

	static const float two = 2.0000000000e+00;		/* 0x40000000 */
	static const float one = 1.0000000000e+00;		/* 0x3F800000 */
	static const float zero = 0.0000000000e+00;
	
	/* J(-n,x) = (-1)^n * J(n, x), J(n, -x) = (-1)^n * J(n, x)
	 * Thus, J(-n,x) = J(n,-x)
	 */
	GET_FLOAT_WORD(hx, x);
	ix = IC(0x7fffffff) & hx;
	/* if J(n,NaN) is NaN */
	if (FLT_UWORD_IS_NAN(ix))
		return x + x;
	if (n < 0)
	{
		n = -n;
		x = -x;
		hx ^= IC(0x80000000);
	}
	if (n == 0)
		return (__ieee754_j0f(x));
	if (n == 1)
		return (__ieee754_j1f(x));
	sgn = (int)((n & 1) & (hx >> 31));			/* even n -- 0, odd n -- sign(x) */
	x = __ieee754_fabsf(x);
	if (FLT_UWORD_IS_ZERO(ix) || FLT_UWORD_IS_INFINITE(ix))
		b = zero;
	else if ((float) n <= x)
	{
		/* Safe to use J(n+1,x)=2n/x *J(n,x)-J(n-1,x) */
		a = __ieee754_j0f(x);
		b = __ieee754_j1f(x);
		for (i = 1; i < n; i++)
		{
			temp = b;
			b = b * ((float) (i + i) / x) - a;	/* avoid underflow */
			a = temp;
		}
	} else
	{
		if (ix < IC(0x30800000))
		{								/* x < 2**-29 */
			/* x is tiny, return the first Taylor expansion of J(n,x)
			 * J(n,x) = 1/n!*(x/2)^n  - ...
			 */
			if (n > 33)					/* underflow */
				b = zero;
			else
			{
				temp = x * 0.5f;
				b = temp;
				for (a = one, i = 2; i <= n; i++)
				{
					a *= (float) i;		/* a = n! */
					b *= temp;			/* b = (x/2)^n */
				}
				b = b / a;
			}
		} else
		{
			/* use backward recurrence */
			/*          x      x^2      x^2
			 *  J(n,x)/J(n-1,x) =  ----   ------   ------   .....
			 *          2n  - 2(n+1) - 2(n+2)
			 *
			 *          1      1        1
			 *  (for large x)   =  ----  ------   ------   .....
			 *          2n   2(n+1)   2(n+2)
			 *          -- - ------ - ------ -
			 *           x     x         x
			 *
			 * Let w = 2n/x and h=2/x, then the above quotient
			 * is equal to the continued fraction:
			 *          1
			 *  = -----------------------
			 *             1
			 *     w - -----------------
			 *            1
			 *          w+h - ---------
			 *             w+2h - ...
			 *
			 * To determine how many terms needed, let
			 * Q(0) = w, Q(1) = w(w+h) - 1,
			 * Q(k) = (w+k*h)*Q(k-1) - Q(k-2),
			 * When Q(k) > 1e4  good for single
			 * When Q(k) > 1e9  good for double
			 * When Q(k) > 1e17 good for quadruple
			 */
			/* determine k */
			float t, v;
			float q0, q1, h, tmp;
			int32_t k, m;

			w = (n + n) / (float) x;
			h = 2.0f / x;
			q0 = w;
			z = w + h;
			q1 = w * z - 1.0f;
			k = 1;
			while (q1 < 1.0e9f)
			{
				k += 1;
				z += h;
				tmp = z * q1 - q0;
				q0 = q1;
				q1 = tmp;
			}
			m = n + n;
			for (t = zero, i = 2 * (n + k); i >= m; i -= 2)
				t = one / (i / x - t);
			a = t;
			b = one;
			/*  estimate log((2/x)^n*n!) = n*log(2/x)+n*ln(n)
			 *  Hence, if n*(log(2n/x)) > ...
			 *  single 8.8722839355e+01
			 *  double 7.09782712893383973096e+02
			 *  long double 1.1356523406294143949491931077970765006170e+04
			 *  then recurrent value may overflow and the result is
			 *  likely underflow to zero
			 */
			tmp = n;
			v = two / x;
			tmp = tmp * __ieee754_logf(__ieee754_fabsf(v * tmp));
			if (tmp < 8.8721679688e+01f)
			{
				for (i = n - 1, di = (float) (i + i); i > 0; i--)
				{
					temp = b;
					b *= di;
					b = b / x - a;
					a = temp;
					di -= two;
				}
			} else
			{
				for (i = n - 1, di = (float) (i + i); i > 0; i--)
				{
					temp = b;
					b *= di;
					b = b / x - a;
					a = temp;
					di -= two;
					/* scale b to avoid spurious overflow */
					if (b > 1e10f)
					{
						a /= b;
						t /= b;
						b = one;
					}
				}
			}
			/* j0() and j1() suffer enormous loss of precision at and
			 * near zero; however, we know that their zero points never
			 * coincide, so just choose the one further away from zero.
			 */
			z = __ieee754_j0f(x);
			w = __ieee754_j1f(x);
			if (__ieee754_fabsf(z) >= __ieee754_fabsf(w))
				b = (t * z / b);
			else
				b = (t * w / a);
		}
	}
	if (sgn)
		return -b;
	return b;
}


/* wrapper jn */
float __jnf(int n, float x)
{
	if (isgreater(__ieee754_fabsf(x), X_TLOSS) && _LIB_VERSION != _IEEE_ && _LIB_VERSION != _POSIX_)
		/* jn(n,|x|>X_TLOSS) */
		return __kernel_standard_f(n, x, 0.0f, KMATHERRF_JN_TLOSS);

	return __ieee754_jnf(n, x);
}

__typeof(__jnf) jnf __attribute__((weak, alias("__jnf")));

```

`e_jnl.c`:

```c
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/* Modifications for long double are
  Copyright (C) 2001 Stephen L. Moshier <moshier@na-net.ornl.gov>
  and are incorporated herein by permission of the author.  The author
  reserves the right to distribute this material elsewhere under different
  copying permissions.  These modifications are distributed here under
  the following terms:

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, see
    <http://www.gnu.org/licenses/>.  */

/*
 * __ieee754_jn(n, x)
 * floating point Bessel's function of the 1st kind
 * of order n
 *
 * Special cases:
 *	y0(0)=y1(0)=yn(n,0) = -inf with overflow signal;
 *	y0(-ve)=y1(-ve)=yn(n,-ve) are NaN with invalid signal.
 * Note 2. About jn(n,x), yn(n,x)
 *	For n=0, j0(x) is called,
 *	for n=1, j1(x) is called,
 *	for n<x, forward recursion us used starting
 *	from values of j0(x) and j1(x).
 *	for n>x, a continued fraction approximation to
 *	j(n,x)/j(n-1,x) is evaluated and then backward
 *	recursion is used starting from a supposed value
 *	for j(n,x). The resulting value of j(0,x) is
 *	compared with the actual value to correct the
 *	supposed value of j(n,x).
 *
 *	yn(n,x) is similar in all respects, except
 *	that forward recursion is used for all
 *	values of n>1.
 *
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

long double __ieee754_jnl(int n, long double x)
{
	uint32_t se, i0, i1;
	int32_t i, ix;
	int sgn;
	long double a, b, temp, di;
	long double z, w;

	static const long double invsqrtpi = 5.64189583547756286948079e-1L;
	static const long double two = 2.0e0L;
	static const long double one = 1.0e0L;
	static const long double zero = 0.0L;
	
	/* J(-n,x) = (-1)^n * J(n, x), J(n, -x) = (-1)^n * J(n, x)
	 * Thus, J(-n,x) = J(n,-x)
	 */

	GET_LDOUBLE_WORDS(se, i0, i1, x);
	ix = se & 0x7fff;

	/* if J(n,NaN) is NaN */
	if ((ix == 0x7fff) && ((i0 & IC(0x7fffffff)) != 0))
		return x + x;
	if (n < 0)
	{
		n = -n;
		x = -x;
		se ^= 0x8000;
	}
	if (n == 0)
		return (__ieee754_j0l(x));
	if (n == 1)
		return (__ieee754_j1l(x));
	sgn = (int)((n & 1) & (se >> 15));			/* even n -- 0, odd n -- sign(x) */
	x = __ieee754_fabsl(x);
	if ((ix | i0 | i1) == 0 || ix >= 0x7fff)
		/* if x is 0 or inf */
		b = zero;
	else if ((long double) n <= x)
	{
		/* Safe to use J(n+1,x)=2n/x *J(n,x)-J(n-1,x) */
		if (ix >= 0x412D)
		{								/* x > 2**302 */

			/* ??? This might be a futile gesture.
			   If x exceeds X_TLOSS anyway, the wrapper function
			   will set the result to zero. */

			/* (x >> n**2)
			 *      Jn(x) = cos(x-(2n+1)*pi/4)*sqrt(2/x*pi)
			 *      Yn(x) = sin(x-(2n+1)*pi/4)*sqrt(2/x*pi)
			 *      Let s=sin(x), c=cos(x),
			 *          xn=x-(2n+1)*pi/4, sqt2 = sqrt(2),then
			 *
			 *             n    sin(xn)*sqt2    cos(xn)*sqt2
			 *          ----------------------------------
			 *             0     s-c             c+s
			 *             1    -s-c            -c+s
			 *             2    -s+c            -c-s
			 *             3     s+c             c-s
			 */
			long double s;
			long double c;

			__ieee754_sincosl(x, &s, &c);
			switch (n & 3)
			{
			case 0:
				temp = c + s;
				break;
			case 1:
				temp = -c + s;
				break;
			case 2:
				temp = -c - s;
				break;
			case 3:
				temp = c - s;
				break;
			}
			b = invsqrtpi * temp / __ieee754_sqrtl(x);
		} else
		{
			a = __ieee754_j0l(x);
			b = __ieee754_j1l(x);
			for (i = 1; i < n; i++)
			{
				temp = b;
				b = b * ((long double) (i + i) / x) - a;	/* avoid underflow */
				a = temp;
			}
		}
	} else
	{
		if (ix < 0x3fde)
		{								/* x < 2**-33 */
			/* x is tiny, return the first Taylor expansion of J(n,x)
			 * J(n,x) = 1/n!*(x/2)^n  - ...
			 */
			if (n >= 400)				/* underflow, result < 10^-4952 */
				b = zero;
			else
			{
				temp = x * 0.5;
				b = temp;
				for (a = one, i = 2; i <= n; i++)
				{
					a *= (long double) i;	/* a = n! */
					b *= temp;			/* b = (x/2)^n */
				}
				b = b / a;
			}
		} else
		{
			/* use backward recurrence */
			/*                      x      x^2      x^2
			 *  J(n,x)/J(n-1,x) =  ----   ------   ------   .....
			 *                      2n  - 2(n+1) - 2(n+2)
			 *
			 *                      1      1        1
			 *  (for large x)   =  ----  ------   ------   .....
			 *                      2n   2(n+1)   2(n+2)
			 *                      -- - ------ - ------ -
			 *                       x     x         x
			 *
			 * Let w = 2n/x and h=2/x, then the above quotient
			 * is equal to the continued fraction:
			 *                  1
			 *      = -----------------------
			 *                     1
			 *         w - -----------------
			 *                        1
			 *              w+h - ---------
			 *                     w+2h - ...
			 *
			 * To determine how many terms needed, let
			 * Q(0) = w, Q(1) = w(w+h) - 1,
			 * Q(k) = (w+k*h)*Q(k-1) - Q(k-2),
			 * When Q(k) > 1e4      good for single
			 * When Q(k) > 1e9      good for double
			 * When Q(k) > 1e17     good for quadruple
			 */
			/* determine k */
			long double t,
			 v;

			long double q0,
			 q1,
			 h,
			 tmp;

			int32_t k,
			 m;

			w = (n + n) / (long double) x;
			h = 2.0L / (long double) x;
			q0 = w;
			z = w + h;
			q1 = w * z - 1.0L;
			k = 1;
			while (q1 < 1.0e11L)
			{
				k += 1;
				z += h;
				tmp = z * q1 - q0;
				q0 = q1;
				q1 = tmp;
			}
			m = n + n;
			for (t = zero, i = 2 * (n + k); i >= m; i -= 2)
				t = one / (i / x - t);
			a = t;
			b = one;
			/*  estimate log((2/x)^n*n!) = n*log(2/x)+n*ln(n)
			 *  Hence, if n*(log(2n/x)) > ...
			 *  single 8.8722839355e+01
			 *  double 7.09782712893383973096e+02
			 *  long double 1.1356523406294143949491931077970765006170e+04
			 *  then recurrent value may overflow and the result is
			 *  likely underflow to zero
			 */
			tmp = n;
			v = two / x;
			tmp = tmp * __ieee754_logl(__ieee754_fabsl(v * tmp));

			if (tmp < 1.1356523406294143949491931077970765006170e+04L)
			{
				for (i = n - 1, di = (long double) (i + i); i > 0; i--)
				{
					temp = b;
					b *= di;
					b = b / x - a;
					a = temp;
					di -= two;
				}
			} else
			{
				for (i = n - 1, di = (long double) (i + i); i > 0; i--)
				{
					temp = b;
					b *= di;
					b = b / x - a;
					a = temp;
					di -= two;
					/* scale b to avoid spurious overflow */
					if (b > 1e100L)
					{
						a /= b;
						t /= b;
						b = one;
					}
				}
			}
			/* j0() and j1() suffer enormous loss of precision at and
			 * near zero; however, we know that their zero points never
			 * coincide, so just choose the one further away from zero.
			 */
			z = __ieee754_j0l(x);
			w = __ieee754_j1l(x);
			if (__ieee754_fabsl(z) >= __ieee754_fabsl(w))
				b = (t * z / b);
			else
				b = (t * w / a);
		}
	}
	if (sgn)
		return -b;
	return b;
}

/* wrapper jn */
long double __jnl(int n, long double x)
{
	if (isgreater(__ieee754_fabsl(x), X_TLOSS) && _LIB_VERSION != _IEEE_ && _LIB_VERSION != _POSIX_)
		/* jn(n,|x|>X_TLOSS) */
		return __kernel_standard_l(n, x, 0.0l, KMATHERRL_JN_TLOSS);

	return __ieee754_jnl(n, x);
}

__typeof(__jnl) jnl __attribute__((weak, alias("__jnl")));

#endif

```

`e_lgamma.c`:

```c
/* @(#)e_lgamma.c 1.3 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice 
 * is preserved.
 * ====================================================
 *
 */

/* __ieee754_lgamma(x)
 * Return the logarithm of the Gamma function of x.
 *
 * Method: call __ieee754_lgamma_r
 */

#include "fdlibm.h"

double __ieee754_lgamma(double x)
{
	return __ieee754_lgamma_r(x, &signgam);
}

```

`e_lgamma_r.c`:

```c
/* @(#)e_lgamma_r.c 1.3 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/* __ieee754_lgamma_r(x, signgamp)
 * Reentrant version of the logarithm of the Gamma function
 * with user provide pointer for the sign of Gamma(x).
 *
 * Method:
 *   1. Argument Reduction for 0 < x <= 8
 *	Since gamma(1+s)=s*gamma(s), for x in [0,8], we may
 *	reduce x to a number in [1.5,2.5] by
 *		lgamma(1+s) = log(s) + lgamma(s)
 *	for example,
 *		lgamma(7.3) = log(6.3) + lgamma(6.3)
 *			    = log(6.3*5.3) + lgamma(5.3)
 *			    = log(6.3*5.3*4.3*3.3*2.3) + lgamma(2.3)
 *   2. Polynomial approximation of lgamma around its
 *	minimun ymin=1.461632144968362245 to maintain monotonicity.
 *	On [ymin-0.23, ymin+0.27] (i.e., [1.23164,1.73163]), use
 *		Let z = x-ymin;
 *		lgamma(x) = -1.214862905358496078218 + z^2*poly(z)
 *	where
 *		poly(z) is a 14 degree polynomial.
 *   2. Rational approximation in the primary interval [2,3]
 *	We use the following approximation:
 *		s = x-2.0;
 *		lgamma(x) = 0.5*s + s*P(s)/Q(s)
 *	with accuracy
 *		|P/Q - (lgamma(x)-0.5s)| < 2**-61.71
 *	Our algorithms are based on the following observation
 *
 *                             zeta(2)-1    2    zeta(3)-1    3
 * lgamma(2+s) = s*(1-Euler) + --------- * s  -  --------- * s  + ...
 *                                 2                 3
 *
 *	where Euler = 0.5771... is the Euler constant, which is very
 *	close to 0.5.
 *
 *   3. For x>=8, we have
 *	lgamma(x)~(x-0.5)log(x)-x+0.5*log(2pi)+1/(12x)-1/(360x**3)+....
 *	(better formula:
 *	   lgamma(x)~(x-0.5)*(log(x)-1)-.5*(log(2pi)-1) + ...)
 *	Let z = 1/x, then we approximation
 *		f(z) = lgamma(x) - (x-0.5)(log(x)-1)
 *	by
 *				    3       5             11
 *		w = w0 + w1*z + w2*z  + w3*z  + ... + w6*z
 *	where
 *		|w - f(z)| < 2**-58.74
 *
 *   4. For negative x, since (G is gamma function)
 *		-x*G(-x)*G(x) = pi/sin(pi*x),
 *	we have
 *		G(x) = pi/(sin(pi*x)*(-x)*G(-x))
 *	since G(-x) is positive, sign(G(x)) = sign(sin(pi*x)) for x<0
 *	Hence, for x<0, signgam = sign(sin(pi*x)) and
 *		lgamma(x) = log(|Gamma(x)|)
 *			  = log(pi/(|x*sin(pi*x)|)) - lgamma(-x);
 *	Note: one should avoid compute pi*(-x) directly in the
 *	      computation of sin(pi*(-x)).
 *
 *   5. Special Cases
 *		lgamma(2+s) ~ s*(1-Euler) for tiny s
 *		lgamma(1)=lgamma(2)=0
 *		lgamma(x) ~ -log(x) for tiny x
 *		lgamma(0) = lgamma(inf) = inf
 *		lgamma(-integer) = +-inf
 *
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

static double sin_pi(double x)
{
	double y, z;
	int32_t n, ix;

	static const double zero = 0.00000000000000000000e+00;
	static const double one = 1.00000000000000000000e+00;	/* 0x3FF00000, 0x00000000 */
	static const double pi = 3.14159265358979311600e+00;	/* 0x400921FB, 0x54442D18 */
	static const double two52 = 4.50359962737049600000e+15;	/* 0x43300000, 0x00000000 */

	GET_HIGH_WORD(ix, x);
	ix &= IC(0x7fffffff);

	if (ix < IC(0x3fd00000))
		return __ieee754_sin(pi * x);
	y = -x;								/* x is assume negative */

	/*
	 * argument reduction, make sure inexact flag not raised if input
	 * is an integer
	 */
	z = __ieee754_floor(y);
	if (z != y)
	{									/* inexact anyway */
		y *= 0.5;
		y = 2.0 * (y - __ieee754_floor(y));		/* y = |x| mod 2.0 */
		n = (int32_t) (y * 4.0);
	} else
	{
		if (ix >= IC(0x43400000))
		{
			y = zero;
			n = 0;						/* y must be even */
		} else
		{
			if (ix < IC(0x43300000))
				z = y + two52;			/* exact */
			GET_LOW_WORD(n, z);
			n &= 1;
			y = n;
			n <<= 2;
		}
	}
#ifdef __have_fpu_sin
	switch ((int)n)
	{
	case 0:
		y = __ieee754_sin(pi * y);
		break;
	case 1:
	case 2:
		y = __ieee754_cos(pi * (0.5 - y));
		break;
	case 3:
	case 4:
		y = __ieee754_sin(pi * (one - y));
		break;
	case 5:
	case 6:
		y = -__ieee754_cos(pi * (y - 1.5));
		break;
	default:
		y = __ieee754_sin(pi * (y - 2.0));
		break;
	}
#else
	switch ((int)n)
	{
	case 0:
		y = __kernel_sin(pi * y, zero, 0);
		break;
	case 1:
	case 2:
		y = __kernel_cos(pi * (0.5 - y), zero);
		break;
	case 3:
	case 4:
		y = __kernel_sin(pi * (one - y), zero, 0);
		break;
	case 5:
	case 6:
		y = -__kernel_cos(pi * (y - 1.5), zero);
		break;
	default:
		y = __kernel_sin(pi * (y - 2.0), zero, 0);
		break;
	}
#endif
	return -y;
}


double __ieee754_lgamma_r(double x, int *signgamp)
{
	double t, y, z, nadj = 0, p, p1, p2, p3, q, r, w;
	int32_t i, hx, lx, ix;

	static const double zero = 0.00000000000000000000e+00;

	static const double half = 5.00000000000000000000e-01;	/* 0x3FE00000, 0x00000000 */
	static const double one = 1.00000000000000000000e+00;	/* 0x3FF00000, 0x00000000 */
	static const double pi = 3.14159265358979311600e+00;	/* 0x400921FB, 0x54442D18 */
	static const double a0 = 7.72156649015328655494e-02;	/* 0x3FB3C467, 0xE37DB0C8 */
	static const double a1 = 3.22467033424113591611e-01;	/* 0x3FD4A34C, 0xC4A60FAD */
	static const double a2 = 6.73523010531292681824e-02;	/* 0x3FB13E00, 0x1A5562A7 */
	static const double a3 = 2.05808084325167332806e-02;	/* 0x3F951322, 0xAC92547B */
	static const double a4 = 7.38555086081402883957e-03;	/* 0x3F7E404F, 0xB68FEFE8 */
	static const double a5 = 2.89051383673415629091e-03;	/* 0x3F67ADD8, 0xCCB7926B */
	static const double a6 = 1.19270763183362067845e-03;	/* 0x3F538A94, 0x116F3F5D */
	static const double a7 = 5.10069792153511336608e-04;	/* 0x3F40B6C6, 0x89B99C00 */
	static const double a8 = 2.20862790713908385557e-04;	/* 0x3F2CF2EC, 0xED10E54D */
	static const double a9 = 1.08011567247583939954e-04;	/* 0x3F1C5088, 0x987DFB07 */
	static const double a10 = 2.52144565451257326939e-05;	/* 0x3EFA7074, 0x428CFA52 */
	static const double a11 = 4.48640949618915160150e-05;	/* 0x3F07858E, 0x90A45837 */
	static const double tc = 1.46163214496836224576e+00;	/* 0x3FF762D8, 0x6356BE3F */
	static const double tf = -1.21486290535849611461e-01;	/* 0xBFBF19B9, 0xBCC38A42 */
	/* tt = -(tail of tf) */
	static const double tt = -3.63867699703950536541e-18;	/* 0xBC50C7CA, 0xA48A971F */
	static const double t0 = 4.83836122723810047042e-01;	/* 0x3FDEF72B, 0xC8EE38A2 */
	static const double t1 = -1.47587722994593911752e-01;	/* 0xBFC2E427, 0x8DC6C509 */
	static const double t2 = 6.46249402391333854778e-02;	/* 0x3FB08B42, 0x94D5419B */
	static const double t3 = -3.27885410759859649565e-02;	/* 0xBFA0C9A8, 0xDF35B713 */
	static const double t4 = 1.79706750811820387126e-02;	/* 0x3F9266E7, 0x970AF9EC */
	static const double t5 = -1.03142241298341437450e-02;	/* 0xBF851F9F, 0xBA91EC6A */
	static const double t6 = 6.10053870246291332635e-03;	/* 0x3F78FCE0, 0xE370E344 */
	static const double t7 = -3.68452016781138256760e-03;	/* 0xBF6E2EFF, 0xB3E914D7 */
	static const double t8 = 2.25964780900612472250e-03;	/* 0x3F6282D3, 0x2E15C915 */
	static const double t9 = -1.40346469989232843813e-03;	/* 0xBF56FE8E, 0xBF2D1AF1 */
	static const double t10 = 8.81081882437654011382e-04;	/* 0x3F4CDF0C, 0xEF61A8E9 */
	static const double t11 = -5.38595305356740546715e-04;	/* 0xBF41A610, 0x9C73E0EC */
	static const double t12 = 3.15632070903625950361e-04;	/* 0x3F34AF6D, 0x6C0EBBF7 */
	static const double t13 = -3.12754168375120860518e-04;	/* 0xBF347F24, 0xECC38C38 */
	static const double t14 = 3.35529192635519073543e-04;	/* 0x3F35FD3E, 0xE8C2D3F4 */
	static const double u0 = -7.72156649015328655494e-02;	/* 0xBFB3C467, 0xE37DB0C8 */
	static const double u1 = 6.32827064025093366517e-01;	/* 0x3FE4401E, 0x8B005DFF */
	static const double u2 = 1.45492250137234768737e+00;	/* 0x3FF7475C, 0xD119BD6F */
	static const double u3 = 9.77717527963372745603e-01;	/* 0x3FEF4976, 0x44EA8450 */
	static const double u4 = 2.28963728064692451092e-01;	/* 0x3FCD4EAE, 0xF6010924 */
	static const double u5 = 1.33810918536787660377e-02;	/* 0x3F8B678B, 0xBF2BAB09 */
	static const double v1 = 2.45597793713041134822e+00;	/* 0x4003A5D7, 0xC2BD619C */
	static const double v2 = 2.12848976379893395361e+00;	/* 0x40010725, 0xA42B18F5 */
	static const double v3 = 7.69285150456672783825e-01;	/* 0x3FE89DFB, 0xE45050AF */
	static const double v4 = 1.04222645593369134254e-01;	/* 0x3FBAAE55, 0xD6537C88 */
	static const double v5 = 3.21709242282423911810e-03;	/* 0x3F6A5ABB, 0x57D0CF61 */
	static const double s0 = -7.72156649015328655494e-02;	/* 0xBFB3C467, 0xE37DB0C8 */
	static const double s1 = 2.14982415960608852501e-01;	/* 0x3FCB848B, 0x36E20878 */
	static const double s2 = 3.25778796408930981787e-01;	/* 0x3FD4D98F, 0x4F139F59 */
	static const double s3 = 1.46350472652464452805e-01;	/* 0x3FC2BB9C, 0xBEE5F2F7 */
	static const double s4 = 2.66422703033638609560e-02;	/* 0x3F9B481C, 0x7E939961 */
	static const double s5 = 1.84028451407337715652e-03;	/* 0x3F5E26B6, 0x7368F239 */
	static const double s6 = 3.19475326584100867617e-05;	/* 0x3F00BFEC, 0xDD17E945 */
	static const double r1 = 1.39200533467621045958e+00;	/* 0x3FF645A7, 0x62C4AB74 */
	static const double r2 = 7.21935547567138069525e-01;	/* 0x3FE71A18, 0x93D3DCDC */
	static const double r3 = 1.71933865632803078993e-01;	/* 0x3FC601ED, 0xCCFBDF27 */
	static const double r4 = 1.86459191715652901344e-02;	/* 0x3F9317EA, 0x742ED475 */
	static const double r5 = 7.77942496381893596434e-04;	/* 0x3F497DDA, 0xCA41A95B */
	static const double r6 = 7.32668430744625636189e-06;	/* 0x3EDEBAF7, 0xA5B38140 */
	static const double w0 = 4.18938533204672725052e-01;	/* 0x3FDACFE3, 0x90C97D69 */
	static const double w1 = 8.33333333333329678849e-02;	/* 0x3FB55555, 0x5555553B */
	static const double w2 = -2.77777777728775536470e-03;	/* 0xBF66C16C, 0x16B02E5C */
	static const double w3 = 7.93650558643019558500e-04;	/* 0x3F4A019F, 0x98CF38B6 */
	static const double w4 = -5.95187557450339963135e-04;	/* 0xBF4380CB, 0x8C0FE741 */
	static const double w5 = 8.36339918996282139126e-04;	/* 0x3F4B67BA, 0x4CDAD5D1 */
	static const double w6 = -1.63092934096575273989e-03;	/* 0xBF5AB89D, 0x0B9E43E4 */

	GET_DOUBLE_WORDS(hx, lx, x);

	/* purge off +-inf, NaN, +-0, and negative arguments */
	*signgamp = 1;
	ix = hx & IC(0x7fffffff);
	if (ix >= IC(0x7ff00000))
		return x * x;
	if ((ix | lx) == 0)
	{
		if (hx < 0)
			*signgamp = -1;
		return one / __ieee754_fabs(x);
	}
	if (ix < IC(0x3b900000))
	{
		/* |x|<2**-70, return -log(|x|) */
		if (hx < 0)
		{
			*signgamp = -1;
			return -__ieee754_log(-x);
		} else
			return -__ieee754_log(x);
	}
	if (hx < 0)
	{
		if (ix >= IC(0x43300000))	/* |x|>=2**52, must be -integer */
			return x / zero;
		t = sin_pi(x);
		if (t == zero)
			return one / __ieee754_fabs(t);	/* -integer */
		nadj = __ieee754_log(pi / __ieee754_fabs(t * x));
		if (t < zero)
			*signgamp = -1;
		x = -x;
	}

	/* purge off 1 and 2 */
	if ((((ix - IC(0x3ff00000)) | lx) == 0) || (((ix - IC(0x40000000)) | lx) == 0))
		r = 0;
	/* for x < 2.0 */
	else if (ix < IC(0x40000000))
	{
		if (ix <= IC(0x3feccccc))
		{								/* lgamma(x) = lgamma(x+1)-log(x) */
			r = -__ieee754_log(x);
			if (ix >= IC(0x3FE76944))
			{
				y = one - x;
				i = 0;
			} else if (ix >= IC(0x3FCDA661))
			{
				y = x - (tc - one);
				i = 1;
			} else
			{
				y = x;
				i = 2;
			}
		} else
		{
			r = zero;
			if (ix >= IC(0x3FFBB4C3))
			{
				y = 2.0 - x;
				i = 0;
			} /* [1.7316,2] */
			else if (ix >= IC(0x3FF3B4C4))
			{
				y = x - tc;
				i = 1;
			} /* [1.23,1.73] */
			else
			{
				y = x - one;
				i = 2;
			}
		}
		switch ((int) i)
		{
		case 0:
			z = y * y;
			p1 = a0 + z * (a2 + z * (a4 + z * (a6 + z * (a8 + z * a10))));
			p2 = z * (a1 + z * (a3 + z * (a5 + z * (a7 + z * (a9 + z * a11)))));
			p = y * p1 + p2;
			r += (p - 0.5 * y);
			break;
		case 1:
			z = y * y;
			w = z * y;
			p1 = t0 + w * (t3 + w * (t6 + w * (t9 + w * t12)));	/* parallel comp */
			p2 = t1 + w * (t4 + w * (t7 + w * (t10 + w * t13)));
			p3 = t2 + w * (t5 + w * (t8 + w * (t11 + w * t14)));
			p = z * p1 - (tt - w * (p2 + y * p3));
			r += (tf + p);
			break;
		case 2:
			p1 = y * (u0 + y * (u1 + y * (u2 + y * (u3 + y * (u4 + y * u5)))));
			p2 = one + y * (v1 + y * (v2 + y * (v3 + y * (v4 + y * v5))));
			r += (-0.5 * y + p1 / p2);
			break;
		}
	} else if (ix < IC(0x40200000))
	{									/* x < 8.0 */
		i = (int32_t) x;
		t = zero;
		y = x - (double) i;
		p = y * (s0 + y * (s1 + y * (s2 + y * (s3 + y * (s4 + y * (s5 + y * s6))))));
		q = one + y * (r1 + y * (r2 + y * (r3 + y * (r4 + y * (r5 + y * r6)))));
		r = half * y + p / q;
		z = one;						/* lgamma(1+s) = log(s) + lgamma(s) */
		switch ((int) i)
		{
		case 7:
			z *= (y + 6.0);				/* FALLTHRU */
		case 6:
			z *= (y + 5.0);				/* FALLTHRU */
		case 5:
			z *= (y + 4.0);				/* FALLTHRU */
		case 4:
			z *= (y + 3.0);				/* FALLTHRU */
		case 3:
			z *= (y + 2.0);				/* FALLTHRU */
			r += __ieee754_log(z);
			break;
		}
		/* 8.0 <= x < 2**58 */
	} else if (ix < IC(0x43900000))
	{
		t = __ieee754_log(x);
		z = one / x;
		y = z * z;
		w = w0 + z * (w1 + y * (w2 + y * (w3 + y * (w4 + y * (w5 + y * w6)))));
		r = (x - half) * (t - one) + w;
	} else
		/* 2**58 <= x <= inf */
		r = x * (__ieee754_log(x) - one);
	if (hx < 0)
		r = nadj - r;
	return r;
}

```

`e_lgammaf.c`:

```c
/* @(#)e_lgamma.c 1.3 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice 
 * is preserved.
 * ====================================================
 *
 */

/* __ieee754_lgammaf(x)
 * Return the logarithm of the Gamma function of x.
 *
 * Method: call __ieee754_lgammaf_r
 */

#include "fdlibm.h"

float __ieee754_lgammaf(float x)
{
	return __ieee754_lgammaf_r(x, &signgam);
}

```

`e_lgammaf_r.c`:

```c
/* e_lgammaf_r.c -- float version of e_lgamma_r.c.
 * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

static float sin_pif(float x)
{
	float y, z;
	int32_t n, ix;

	static const float zero = 0.0000000000e+00;
	static const float one = 1.0000000000e+00;	/* 0x3f800000 */
	static const float pi = 3.1415927410e+00;	/* 0x40490fdb */
	static const float two23 = 8.3886080000e+06;	/* 0x4b000000 */

	GET_FLOAT_WORD(ix, x);
	ix &= IC(0x7fffffff);

	if (ix < IC(0x3e800000))
#ifdef __have_fpu_sin
		return __ieee754_sinf(pi * x);
#else
		return __kernel_sinf(pi * x, zero, 0);
#endif
	y = -x;								/* x is assume negative */

	/*
	 * argument reduction, make sure inexact flag not raised if input
	 * is an integer
	 */
	z = __ieee754_floorf(y);
	if (z != y)
	{									/* inexact anyway */
		y *= 0.5F;
		y = 2.0F * (y - __ieee754_floorf(y));	/* y = |x| mod 2.0 */
		n = (int32_t) (y * 4.0F);
	} else
	{
		if (ix >= IC(0x4b800000))
		{
			y = zero;
			n = 0;						/* y must be even */
		} else
		{
			if (ix < IC(0x4b000000))
				z = y + two23;			/* exact */
			GET_FLOAT_WORD(n, z);
			n &= 1;
			y = n;
			n <<= 2;
		}
	}
#ifdef __have_fpu_sin
	switch ((int) n)
	{
	case 0:
		y = __ieee754_sinf(pi * y);
		break;
	case 1:
	case 2:
		y = __ieee754_cosf(pi * (0.5F - y));
		break;
	case 3:
	case 4:
		y = __ieee754_sinf(pi * (one - y));
		break;
	case 5:
	case 6:
		y = -__ieee754_cosf(pi * (y - 1.5F));
		break;
	default:
		y = __ieee754_sinf(pi * (y - 2.0F));
		break;
	}
#else
	switch ((int) n)
	{
	case 0:
		y = __kernel_sinf(pi * y, zero, 0);
		break;
	case 1:
	case 2:
		y = __kernel_cosf(pi * (0.5F - y), zero);
		break;
	case 3:
	case 4:
		y = __kernel_sinf(pi * (one - y), zero, 0);
		break;
	case 5:
	case 6:
		y = -__kernel_cosf(pi * (y - 1.5F), zero);
		break;
	default:
		y = __kernel_sinf(pi * (y - 2.0F), zero, 0);
		break;
	}
#endif
	return -y;
}


float __ieee754_lgammaf_r(float x, int *signgamp)
{
	float t, y, z, nadj = 0, p, p1, p2, p3, q, r, w;
	int32_t i, hx, ix;

	static const float zero = 0.0000000000e+00;

	static const float half = 5.0000000000e-01;	/* 0x3f000000 */
	static const float one = 1.0000000000e+00;	/* 0x3f800000 */
	static const float pi = 3.1415927410e+00;	/* 0x40490fdb */
	static const float a0 = 7.7215664089e-02;	/* 0x3d9e233f */
	static const float a1 = 3.2246702909e-01;	/* 0x3ea51a66 */
	static const float a2 = 6.7352302372e-02;	/* 0x3d89f001 */
	static const float a3 = 2.0580807701e-02;	/* 0x3ca89915 */
	static const float a4 = 7.3855509982e-03;	/* 0x3bf2027e */
	static const float a5 = 2.8905137442e-03;	/* 0x3b3d6ec6 */
	static const float a6 = 1.1927076848e-03;	/* 0x3a9c54a1 */
	static const float a7 = 5.1006977446e-04;	/* 0x3a05b634 */
	static const float a8 = 2.2086278477e-04;	/* 0x39679767 */
	static const float a9 = 1.0801156895e-04;	/* 0x38e28445 */
	static const float a10 = 2.5214456400e-05;	/* 0x37d383a2 */
	static const float a11 = 4.4864096708e-05;	/* 0x383c2c75 */
	static const float tc = 1.4616321325e+00;	/* 0x3fbb16c3 */
	static const float tf = -1.2148628384e-01;	/* 0xbdf8cdcd */
	
	/* tt = -(tail of tf) */
	static const float tt = 6.6971006518e-09;	/* 0x31e61c52 */
	static const float t0 = 4.8383611441e-01;	/* 0x3ef7b95e */
	static const float t1 = -1.4758771658e-01;	/* 0xbe17213c */
	static const float t2 = 6.4624942839e-02;	/* 0x3d845a15 */
	static const float t3 = -3.2788541168e-02;	/* 0xbd064d47 */
	static const float t4 = 1.7970675603e-02;	/* 0x3c93373d */
	static const float t5 = -1.0314224288e-02;	/* 0xbc28fcfe */
	static const float t6 = 6.1005386524e-03;	/* 0x3bc7e707 */
	static const float t7 = -3.6845202558e-03;	/* 0xbb7177fe */
	static const float t8 = 2.2596477065e-03;	/* 0x3b141699 */
	static const float t9 = -1.4034647029e-03;	/* 0xbab7f476 */
	static const float t10 = 8.8108185446e-04;	/* 0x3a66f867 */
	static const float t11 = -5.3859531181e-04;	/* 0xba0d3085 */
	static const float t12 = 3.1563205994e-04;	/* 0x39a57b6b */
	static const float t13 = -3.1275415677e-04;	/* 0xb9a3f927 */
	static const float t14 = 3.3552918467e-04;	/* 0x39afe9f7 */
	static const float u0 = -7.7215664089e-02;	/* 0xbd9e233f */
	static const float u1 = 6.3282704353e-01;	/* 0x3f2200f4 */
	static const float u2 = 1.4549225569e+00;	/* 0x3fba3ae7 */
	static const float u3 = 9.7771751881e-01;	/* 0x3f7a4bb2 */
	static const float u4 = 2.2896373272e-01;	/* 0x3e6a7578 */
	static const float u5 = 1.3381091878e-02;	/* 0x3c5b3c5e */
	static const float v1 = 2.4559779167e+00;	/* 0x401d2ebe */
	static const float v2 = 2.1284897327e+00;	/* 0x4008392d */
	static const float v3 = 7.6928514242e-01;	/* 0x3f44efdf */
	static const float v4 = 1.0422264785e-01;	/* 0x3dd572af */
	static const float v5 = 3.2170924824e-03;	/* 0x3b52d5db */
	static const float s0 = -7.7215664089e-02;	/* 0xbd9e233f */
	static const float s1 = 2.1498242021e-01;	/* 0x3e5c245a */
	static const float s2 = 3.2577878237e-01;	/* 0x3ea6cc7a */
	static const float s3 = 1.4635047317e-01;	/* 0x3e15dce6 */
	static const float s4 = 2.6642270386e-02;	/* 0x3cda40e4 */
	static const float s5 = 1.8402845599e-03;	/* 0x3af135b4 */
	static const float s6 = 3.1947532989e-05;	/* 0x3805ff67 */
	static const float r1 = 1.3920053244e+00;	/* 0x3fb22d3b */
	static const float r2 = 7.2193557024e-01;	/* 0x3f38d0c5 */
	static const float r3 = 1.7193385959e-01;	/* 0x3e300f6e */
	static const float r4 = 1.8645919859e-02;	/* 0x3c98bf54 */
	static const float r5 = 7.7794247773e-04;	/* 0x3a4beed6 */
	static const float r6 = 7.3266842264e-06;	/* 0x36f5d7bd */
	static const float w0 = 4.1893854737e-01;	/* 0x3ed67f1d */
	static const float w1 = 8.3333335817e-02;	/* 0x3daaaaab */
	static const float w2 = -2.7777778450e-03;	/* 0xbb360b61 */
	static const float w3 = 7.9365057172e-04;	/* 0x3a500cfd */
	static const float w4 = -5.9518753551e-04;	/* 0xba1c065c */
	static const float w5 = 8.3633989561e-04;	/* 0x3a5b3dd2 */
	static const float w6 = -1.6309292987e-03;	/* 0xbad5c4e8 */
	
	GET_FLOAT_WORD(hx, x);

	/* purge off +-inf, NaN, +-0, and negative arguments */
	*signgamp = 1;
	ix = hx & IC(0x7fffffff);
	if (ix >= IC(0x7f800000))
		return x * x;
	if (ix == 0)
	{
		if (hx < 0)
			*signgamp = -1;
		return one / __ieee754_fabsf(x);
	}
	if (ix < IC(0x1c800000))
	{
		/* |x|<2**-70, return -log(|x|) */
		if (hx < 0)
		{
			*signgamp = -1;
			return -__ieee754_logf(-x);
		} else
			return -__ieee754_logf(x);
	}
	if (hx < 0)
	{
		if (ix >= IC(0x4b000000))			/* |x|>=2**23, must be -integer */
			return x / zero;
		t = sin_pif(x);
		if (t == zero)
			return one / __ieee754_fabsf(t);	/* -integer */
		nadj = __ieee754_logf(pi / __ieee754_fabsf(t * x));
		if (t < zero)
			*signgamp = -1;
		x = -x;
	}

	/* purge off 1 and 2 */
	if (ix == IC(0x3f800000) || ix == IC(0x40000000))
		r = 0;
	/* for x < 2.0 */
	else if (ix < IC(0x40000000))
	{
		if (ix <= IC(0x3f666666))
		{								/* lgamma(x) = lgamma(x+1)-log(x) */
			r = -__ieee754_logf(x);
			if (ix >= IC(0x3f3b4a20))
			{
				y = one - x;
				i = 0;
			} else if (ix >= IC(0x3e6d3308))
			{
				y = x - (tc - one);
				i = 1;
			} else
			{
				y = x;
				i = 2;
			}
		} else
		{
			r = zero;
			if (ix >= IC(0x3fdda618))
			{
				y = 2.0F - x;
				i = 0;
			} /* [1.7316,2] */
			else if (ix >= IC(0x3F9da620))
			{
				y = x - tc;
				i = 1;
			} /* [1.23,1.73] */
			else
			{
				y = x - one;
				i = 2;
			}
		}
		switch ((int) i)
		{
		case 0:
			z = y * y;
			p1 = a0 + z * (a2 + z * (a4 + z * (a6 + z * (a8 + z * a10))));
			p2 = z * (a1 + z * (a3 + z * (a5 + z * (a7 + z * (a9 + z * a11)))));
			p = y * p1 + p2;
			r += (p - 0.5F * y);
			break;
		case 1:
			z = y * y;
			w = z * y;
			p1 = t0 + w * (t3 + w * (t6 + w * (t9 + w * t12)));	/* parallel comp */
			p2 = t1 + w * (t4 + w * (t7 + w * (t10 + w * t13)));
			p3 = t2 + w * (t5 + w * (t8 + w * (t11 + w * t14)));
			p = z * p1 - (tt - w * (p2 + y * p3));
			r += (tf + p);
			break;
		case 2:
			p1 = y * (u0 + y * (u1 + y * (u2 + y * (u3 + y * (u4 + y * u5)))));
			p2 = one + y * (v1 + y * (v2 + y * (v3 + y * (v4 + y * v5))));
			r += (-0.5F * y + p1 / p2);
			break;
		}
	} else if (ix < IC(0x41000000))
	{									/* x < 8.0 */
		i = (int32_t) x;
		t = zero;
		y = x - (float) i;
		p = y * (s0 + y * (s1 + y * (s2 + y * (s3 + y * (s4 + y * (s5 + y * s6))))));
		q = one + y * (r1 + y * (r2 + y * (r3 + y * (r4 + y * (r5 + y * r6)))));
		r = half * y + p / q;
		z = one;						/* lgamma(1+s) = log(s) + lgamma(s) */
		switch ((int) i)
		{
		case 7:
			z *= (y + 6.0F);			/* FALLTHRU */
		case 6:
			z *= (y + 5.0F);			/* FALLTHRU */
		case 5:
			z *= (y + 4.0F);			/* FALLTHRU */
		case 4:
			z *= (y + 3.0F);			/* FALLTHRU */
		case 3:
			z *= (y + 2.0F);			/* FALLTHRU */
			r += __ieee754_logf(z);
			break;
		}
		/* 8.0 <= x < 2**58 */
	} else if (ix < IC(0x5c800000))
	{
		t = __ieee754_logf(x);
		z = one / x;
		y = z * z;
		w = w0 + z * (w1 + y * (w2 + y * (w3 + y * (w4 + y * (w5 + y * w6)))));
		r = (x - half) * (t - one) + w;
	} else
		/* 2**58 <= x <= inf */
		r = x * (__ieee754_logf(x) - one);
	if (hx < 0)
		r = nadj - r;
	return r;
}

```

`e_lgammal.c`:

```c
/* @(#)e_lgamma.c 1.3 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice 
 * is preserved.
 * ====================================================
 *
 */

/* __ieee754_lgammal(x)
 * Return the logarithm of the Gamma function of x.
 *
 * Method: call __ieee754_lgamma_r
 */

#include "fdlibm.h"

long double __ieee754_lgamma(long double x)
{
	return __ieee754_lgammal_r(x, &signgam);
}

```

`e_lgammal_r.c`:

```c
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/* Long double expansions are
  Copyright (C) 2001 Stephen L. Moshier <moshier@na-net.ornl.gov>
  and are incorporated herein by permission of the author.  The author
  reserves the right to distribute this material elsewhere under different
  copying permissions.  These modifications are distributed here under
  the following terms:

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, see
    <http://www.gnu.org/licenses/>.  */

/* __ieee754_lgammal_r(x, signgamp)
 * Reentrant version of the logarithm of the Gamma function
 * with user provide pointer for the sign of Gamma(x).
 *
 * Method:
 *   1. Argument Reduction for 0 < x <= 8
 *	Since gamma(1+s)=s*gamma(s), for x in [0,8], we may
 *	reduce x to a number in [1.5,2.5] by
 *		lgamma(1+s) = log(s) + lgamma(s)
 *	for example,
 *		lgamma(7.3) = log(6.3) + lgamma(6.3)
 *			    = log(6.3*5.3) + lgamma(5.3)
 *			    = log(6.3*5.3*4.3*3.3*2.3) + lgamma(2.3)
 *   2. Polynomial approximation of lgamma around its
 *	minimun ymin=1.461632144968362245 to maintain monotonicity.
 *	On [ymin-0.23, ymin+0.27] (i.e., [1.23164,1.73163]), use
 *		Let z = x-ymin;
 *		lgamma(x) = -1.214862905358496078218 + z^2*poly(z)
 *   2. Rational approximation in the primary interval [2,3]
 *	We use the following approximation:
 *		s = x-2.0;
 *		lgamma(x) = 0.5*s + s*P(s)/Q(s)
 *	Our algorithms are based on the following observation
 *
 *                             zeta(2)-1    2    zeta(3)-1    3
 * lgamma(2+s) = s*(1-Euler) + --------- * s  -  --------- * s  + ...
 *                                 2                 3
 *
 *	where Euler = 0.5771... is the Euler constant, which is very
 *	close to 0.5.
 *
 *   3. For x>=8, we have
 *	lgamma(x)~(x-0.5)log(x)-x+0.5*log(2pi)+1/(12x)-1/(360x**3)+....
 *	(better formula:
 *	   lgamma(x)~(x-0.5)*(log(x)-1)-.5*(log(2pi)-1) + ...)
 *	Let z = 1/x, then we approximation
 *		f(z) = lgamma(x) - (x-0.5)(log(x)-1)
 *	by
 *				    3       5             11
 *		w = w0 + w1*z + w2*z  + w3*z  + ... + w6*z
 *
 *   4. For negative x, since (G is gamma function)
 *		-x*G(-x)*G(x) = pi/sin(pi*x),
 *	we have
 *		G(x) = pi/(sin(pi*x)*(-x)*G(-x))
 *	since G(-x) is positive, sign(G(x)) = sign(sin(pi*x)) for x<0
 *	Hence, for x<0, signgam = sign(sin(pi*x)) and
 *		lgamma(x) = log(|Gamma(x)|)
 *			  = log(pi/(|x*sin(pi*x)|)) - lgamma(-x);
 *	Note: one should avoid compute pi*(-x) directly in the
 *	      computation of sin(pi*(-x)).
 *
 *   5. Special Cases
 *		lgamma(2+s) ~ s*(1-Euler) for tiny s
 *		lgamma(1)=lgamma(2)=0
 *		lgamma(x) ~ -log(x) for tiny x
 *		lgamma(0) = lgamma(inf) = inf
 *		lgamma(-integer) = +-inf
 *
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

static long double sin_pi_l(long double x)
{
	long double y, z;
	int32_t n, ix;
	uint32_t se, i0, i1;

	static const long double zero = 0.0L;
	static const long double half = 0.5L;
	static const long double one = 1.0L;
	static const long double pi = 3.14159265358979323846264L;
	static const long double two63 = 9.223372036854775808e18L;

	GET_LDOUBLE_WORDS(se, i0, i1, x);
	ix = se & 0x7fff;
	ix = (ix << 16) | (i0 >> 16);
	if (ix < IC(0x3ffd8000))			/* 0.25 */
		return __ieee754_sinl(pi * x);
	y = -x;								/* x is assume negative */

	/*
	 * argument reduction, make sure inexact flag not raised if input
	 * is an integer
	 */
	z = __ieee754_floorl(y);
	if (z != y)
	{									/* inexact anyway */
		y *= 0.5;
		y = 2.0 * (y - __ieee754_floorl(y));	/* y = |x| mod 2.0 */
		n = (int32_t) (y * 4.0);
	} else
	{
		if (ix >= IC(0x403f8000))		/* 2^64 */
		{
			y = zero;
			n = 0;						/* y must be even */
		} else
		{
			if (ix < IC(0x403e8000))	/* 2^63 */
				z = y + two63;			/* exact */
			GET_LDOUBLE_WORDS(se, i0, i1, z);
			n = i1 & 1;
			y = n;
			n <<= 2;
		}
	}

	switch ((int) n)
	{
	case 0:
		y = __ieee754_sinl(pi * y);
		break;
	case 1:
	case 2:
		y = __ieee754_cosl(pi * (half - y));
		break;
	case 3:
	case 4:
		y = __ieee754_sinl(pi * (one - y));
		break;
	case 5:
	case 6:
		y = -__ieee754_cosl(pi * (y - 1.5));
		break;
	default:
		y = __ieee754_sinl(pi * (y - 2.0));
		break;
	}
	return -y;
}


long double __ieee754_lgammal_r(long double x, int *signgamp)
{
	long double t, y, z, nadj = 0, p, p1, p2, q, r, w;
	int32_t i, ix;
	uint32_t se, i0, i1;

	static const long double half = 0.5L;
	static const long double one = 1.0L;
	static const long double pi = 3.14159265358979323846264L;
	  /* lgam(1+x) = 0.5 x + x a(x)/b(x)
	     -0.268402099609375 <= x <= 0
	     peak relative error 6.6e-22 */
	static const long double a0 = -6.343246574721079391729402781192128239938E2L;
	static const long double a1 = 1.856560238672465796768677717168371401378E3L;
	static const long double a2 = 2.404733102163746263689288466865843408429E3L;
	static const long double a3 = 8.804188795790383497379532868917517596322E2L;
	static const long double a4 = 1.135361354097447729740103745999661157426E2L;
	static const long double a5 = 3.766956539107615557608581581190400021285E0L;
	static const long double b0 = 8.214973713960928795704317259806842490498E3L;
	static const long double b1 = 1.026343508841367384879065363925870888012E4L;
	static const long double b2 = 4.553337477045763320522762343132210919277E3L;
	static const long double b3 = 8.506975785032585797446253359230031874803E2L;
	static const long double b4 = 6.042447899703295436820744186992189445813E1L;
	/* static const long double b5 =  1.000000000000000000000000000000000000000E0 */
	static const long double tc = 1.4616321449683623412626595423257213284682E0L;
	static const long double tf = -1.2148629053584961146050602565082954242826E-1;	/* double precision */
	/* tt = (tail of tf), i.e. tf + tt has extended precision. */
	static const long double tt = 3.3649914684731379602768989080467587736363E-18L;
	  /* lgam ( 1.4616321449683623412626595423257213284682E0 ) =
	     -1.2148629053584960809551455717769158215135617312999903886372437313313530E-1 */
	  /* lgam (x + tc) = tf + tt + x g(x)/h(x)
	     - 0.230003726999612341262659542325721328468 <= x
	     <= 0.2699962730003876587373404576742786715318
	     peak relative error 2.1e-21 */
	static const long double g0 = 3.645529916721223331888305293534095553827E-18L;
	static const long double g1 = 5.126654642791082497002594216163574795690E3L;
	static const long double g2 = 8.828603575854624811911631336122070070327E3L;
	static const long double g3 = 5.464186426932117031234820886525701595203E3L;
	static const long double g4 = 1.455427403530884193180776558102868592293E3L;
	static const long double g5 = 1.541735456969245924860307497029155838446E2L;
	static const long double g6 = 4.335498275274822298341872707453445815118E0L;
	static const long double h0 = 1.059584930106085509696730443974495979641E4L;
	static const long double h1 = 2.147921653490043010629481226937850618860E4L;
	static const long double h2 = 1.643014770044524804175197151958100656728E4L;
	static const long double h3 = 5.869021995186925517228323497501767586078E3L;
	static const long double h4 = 9.764244777714344488787381271643502742293E2L;
	static const long double h5 = 6.442485441570592541741092969581997002349E1L;
	/* static const long double h6 = 1.000000000000000000000000000000000000000E0 */
	
	  /* lgam (x+1) = -0.5 x + x u(x)/v(x)
	     -0.100006103515625 <= x <= 0.231639862060546875
	     peak relative error 1.3e-21 */
	static const long double u0 = -8.886217500092090678492242071879342025627E1L;
	static const long double u1 = 6.840109978129177639438792958320783599310E2L;
	static const long double u2 = 2.042626104514127267855588786511809932433E3L;
	static const long double u3 = 1.911723903442667422201651063009856064275E3L;
	static const long double u4 = 7.447065275665887457628865263491667767695E2L;
	static const long double u5 = 1.132256494121790736268471016493103952637E2L;
	static const long double u6 = 4.484398885516614191003094714505960972894E0L;
	static const long double v0 = 1.150830924194461522996462401210374632929E3L;
	static const long double v1 = 3.399692260848747447377972081399737098610E3L;
	static const long double v2 = 3.786631705644460255229513563657226008015E3L;
	static const long double v3 = 1.966450123004478374557778781564114347876E3L;
	static const long double v4 = 4.741359068914069299837355438370682773122E2L;
	static const long double v5 = 4.508989649747184050907206782117647852364E1L;
	/* static const long double v6 =  1.000000000000000000000000000000000000000E0 */
	
	  /* lgam (x+2) = .5 x + x s(x)/r(x)
	     0 <= x <= 1
	     peak relative error 7.2e-22 */
	static const long double s0 = 1.454726263410661942989109455292824853344E6L;
	static const long double s1 = -3.901428390086348447890408306153378922752E6L;
	static const long double s2 = -6.573568698209374121847873064292963089438E6L;
	static const long double s3 = -3.319055881485044417245964508099095984643E6L;
	static const long double s4 = -7.094891568758439227560184618114707107977E5L;
	static const long double s5 = -6.263426646464505837422314539808112478303E4L;
	static const long double s6 = -1.684926520999477529949915657519454051529E3L;
	static const long double r0 = -1.883978160734303518163008696712983134698E7L;
	static const long double r1 = -2.815206082812062064902202753264922306830E7L;
	static const long double r2 = -1.600245495251915899081846093343626358398E7L;
	static const long double r3 = -4.310526301881305003489257052083370058799E6L;
	static const long double r4 = -5.563807682263923279438235987186184968542E5L;
	static const long double r5 = -3.027734654434169996032905158145259713083E4L;
	static const long double r6 = -4.501995652861105629217250715790764371267E2L;
	/* static const long double r6 =  1.000000000000000000000000000000000000000E0 */
	
	
	/* lgam(x) = ( x - 0.5 ) * log(x) - x + LS2PI + 1/x w(1/x^2)
	   x >= 8
	   Peak relative error 1.51e-21
	   w0 = LS2PI - 0.5 */
	static const long double w0 = 4.189385332046727417803e-1L;
	static const long double w1 = 8.333333333333331447505E-2L;
	static const long double w2 = -2.777777777750349603440E-3L;
	static const long double w3 = 7.936507795855070755671E-4L;
	static const long double w4 = -5.952345851765688514613E-4L;
	static const long double w5 = 8.412723297322498080632E-4L;
	static const long double w6 = -1.880801938119376907179E-3L;
	static const long double w7 = 4.885026142432270781165E-3L;
	static const long double zero = 0.0L;
	
	*signgamp = 1;
	GET_LDOUBLE_WORDS(se, i0, i1, x);
	ix = se & 0x7fff;

	if ((ix | i0 | i1) == 0)
	{
		if (se & 0x8000)
			*signgamp = -1;
		return one / __ieee754_fabsl(x);
	}

	ix = (ix << 16) | (i0 >> 16);

	/* purge off +-inf, NaN, +-0, and negative arguments */
	if (ix >= IC(0x7fff0000))
		return x * x;

	if (ix < IC(0x3fc08000))	/* 2^-63 */
	{									/* |x|<2**-63, return -log(|x|) */
		if (se & 0x8000)
		{
			*signgamp = -1;
			return -__ieee754_logl(-x);
		} else
			return -__ieee754_logl(x);
	}
	if (se & 0x8000)
	{
		t = sin_pi_l(x);
		if (t == zero)
			return one / __ieee754_fabsl(t);	/* -integer */
		nadj = __ieee754_logl(pi / __ieee754_fabsl(t * x));
		if (t < zero)
			*signgamp = -1;
		x = -x;
	}

	/* purge off 1 and 2 */
	if ((((ix - IC(0x3fff8000)) | i0 | i1) == 0) || (((ix - IC(0x40008000)) | i0 | i1) == 0))
		r = 0;
	else if (ix < IC(0x40008000))			/* 2.0 */
	{
		/* x < 2.0 */
		if (ix <= IC(0x3ffee666))			/* 8.99993896484375e-1 */
		{
			/* lgamma(x) = lgamma(x+1) - log(x) */
			r = -__ieee754_logl(x);
			if (ix >= IC(0x3ffebb4a))		/* 7.31597900390625e-1 */
			{
				y = x - one;
				i = 0;
			} else if (ix >= IC(0x3ffced33))	/* 2.31639862060546875e-1 */
			{
				y = x - (tc - one);
				i = 1;
			} else
			{
				/* x < 0.23 */
				y = x;
				i = 2;
			}
		} else
		{
			r = zero;
			if (ix >= IC(0x3fffdda6))		/* 1.73162841796875 */
			{
				/* [1.7316,2] */
				y = x - 2.0;
				i = 0;
			} else if (ix >= IC(0x3fff9da6))	/* 1.23162841796875 */
			{
				/* [1.23,1.73] */
				y = x - tc;
				i = 1;
			} else
			{
				/* [0.9, 1.23] */
				y = x - one;
				i = 2;
			}
		}
		switch ((int) i)
		{
		case 0:
			p1 = a0 + y * (a1 + y * (a2 + y * (a3 + y * (a4 + y * a5))));
			p2 = b0 + y * (b1 + y * (b2 + y * (b3 + y * (b4 + y))));
			r += half * y + y * p1 / p2;
			break;
		case 1:
			p1 = g0 + y * (g1 + y * (g2 + y * (g3 + y * (g4 + y * (g5 + y * g6)))));
			p2 = h0 + y * (h1 + y * (h2 + y * (h3 + y * (h4 + y * (h5 + y)))));
			p = tt + y * p1 / p2;
			r += (tf + p);
			break;
		case 2:
			p1 = y * (u0 + y * (u1 + y * (u2 + y * (u3 + y * (u4 + y * (u5 + y * u6))))));
			p2 = v0 + y * (v1 + y * (v2 + y * (v3 + y * (v4 + y * (v5 + y)))));
			r += (-half * y + p1 / p2);
			break;
		}
	} else if (ix < IC(0x40028000))		/* 8.0 */
	{
		/* x < 8.0 */
		i = (int32_t) x;
		t = zero;
		y = x - (double) i;
		p = y * (s0 + y * (s1 + y * (s2 + y * (s3 + y * (s4 + y * (s5 + y * s6))))));
		q = r0 + y * (r1 + y * (r2 + y * (r3 + y * (r4 + y * (r5 + y * (r6 + y))))));
		r = half * y + p / q;
		z = one;						/* lgamma(1+s) = log(s) + lgamma(s) */
		switch ((int) i)
		{
		case 7:
			z *= (y + 6.0);				/* FALLTHRU */
		case 6:
			z *= (y + 5.0);				/* FALLTHRU */
		case 5:
			z *= (y + 4.0);				/* FALLTHRU */
		case 4:
			z *= (y + 3.0);				/* FALLTHRU */
		case 3:
			z *= (y + 2.0);				/* FALLTHRU */
			r += __ieee754_logl(z);
			break;
		}
	} else if (ix < IC(0x40418000))		/* 2^66 */
	{
		/* 8.0 <= x < 2**66 */
		t = __ieee754_logl(x);
		z = one / x;
		y = z * z;
		w = w0 + z * (w1 + y * (w2 + y * (w3 + y * (w4 + y * (w5 + y * (w6 + y * w7))))));
		r = (x - half) * (t - one) + w;
	} else
		/* 2**66 <= x <= inf */
		r = x * (__ieee754_logl(x) - one);
	if (se & 0x8000)
		r = nadj - r;
	return r;
}

#endif

```

`e_log.c`:

```c
/* @(#)e_log.c 1.3 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice 
 * is preserved.
 * ====================================================
 */

/* __ieee754_log(x)
 * Return the logrithm of x
 *
 * Method :                  
 *   1. Argument Reduction: find k and f such that 
 *			x = 2^k * (1+f), 
 *	   where  sqrt(2)/2 < 1+f < sqrt(2) .
 *
 *   2. Approximation of log(1+f).
 *	Let s = f/(2+f) ; based on log(1+f) = log(1+s) - log(1-s)
 *		 = 2s + 2/3 s**3 + 2/5 s**5 + .....,
 *	     	 = 2s + s*R
 *      We use a special Reme algorithm on [0,0.1716] to generate 
 * 	a polynomial of degree 14 to approximate R The maximum error 
 *	of this polynomial approximation is bounded by 2**-58.45. In
 *	other words,
 *		        2      4      6      8      10      12      14
 *	    R(z) ~ Lg1*s +Lg2*s +Lg3*s +Lg4*s +Lg5*s  +Lg6*s  +Lg7*s
 *  	(the values of Lg1 to Lg7 are listed in the program)
 *	and
 *	    |      2          14          |     -58.45
 *	    | Lg1*s +...+Lg7*s    -  R(z) | <= 2 
 *	    |                             |
 *	Note that 2s = f - s*f = f - hfsq + s*hfsq, where hfsq = f*f/2.
 *	In order to guarantee error in log below 1ulp, we compute log
 *	by
 *		log(1+f) = f - s*(f - R)	(if f is not too large)
 *		log(1+f) = f - (hfsq - s*(hfsq+R)).	(better accuracy)
 *	
 *	3. Finally,  log(x) = k*ln2 + log(1+f).  
 *			    = k*ln2_hi+(f-(hfsq-(s*(hfsq+R)+k*ln2_lo)))
 *	   Here ln2 is split into two floating point number: 
 *			ln2_hi + ln2_lo,
 *	   where n*ln2_hi is always exact for |n| < 2000.
 *
 * Special cases:
 *	log(x) is NaN with signal if x < 0 (including -INF) ; 
 *	log(+INF) is +INF; log(0) is -INF with signal;
 *	log(NaN) is that NaN with no signal.
 *
 * Accuracy:
 *	according to an error analysis, the error is always less than
 *	1 ulp (unit in the last place).
 *
 * Constants:
 * The hexadecimal values are the intended ones for the following 
 * constants. The decimal values may be used, provided that the 
 * compiler will convert from decimal to binary accurately enough 
 * to produce the hexadecimal values shown.
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_log

double __ieee754_log(double x)
{
	double hfsq, f, s, z, R, w, t1, t2, dk;
	int32_t k, hx, i, j;
	uint32_t lx;

	static const double ln2_hi = 6.93147180369123816490e-01;	/* 3fe62e42 fee00000 */
	static const double ln2_lo = 1.90821492927058770002e-10;	/* 3dea39ef 35793c76 */
	static const double two54 = 1.80143985094819840000e+16;	/* 43500000 00000000 */
	static const double Lg1 = 6.666666666666735130e-01;		/* 3FE55555 55555593 */
	static const double Lg2 = 3.999999999940941908e-01;		/* 3FD99999 9997FA04 */
	static const double Lg3 = 2.857142874366239149e-01;		/* 3FD24924 94229359 */
	static const double Lg4 = 2.222219843214978396e-01;		/* 3FCC71C5 1D8E78AF */
	static const double Lg5 = 1.818357216161805012e-01;		/* 3FC74664 96CB03DE */
	static const double Lg6 = 1.531383769920937332e-01;		/* 3FC39A09 D078C69F */
	static const double Lg7 = 1.479819860511658591e-01;		/* 3FC2F112 DF3E5244 */

	static const double zero = 0.0;

	GET_DOUBLE_WORDS(hx, lx, x);

	k = 0;
	if (hx < IC(0x00100000))
	{									/* x < 2**-1022  */
		if (((hx & IC(0x7fffffff)) | lx) == 0)
			return -two54 / zero;		/* log(+-0)=-inf */
		if (hx < 0)
			return (x - x) / zero;		/* log(-#) = NaN */
		k -= 54;
		x *= two54;						/* subnormal number, scale up x */
		GET_HIGH_WORD(hx, x);
	}

	if (hx >= IC(0x7ff00000))
		return x + x;
	k += (hx >> 20) - 1023;
	hx &= IC(0x000fffff);
	i = (hx + IC(0x95f64)) & IC(0x100000);
	SET_HIGH_WORD(x, hx | (i ^ IC(0x3ff00000)));	/* normalize x or x/2 */
	k += (i >> 20);
	f = x - 1.0;
	if ((IC(0x000fffff) & (2 + hx)) < 3)
	{									/* |f| < 2**-20 */
		if (f == zero)
		{
			if (k == 0)
				return zero;
			dk = (double) k;
			return dk * ln2_hi + dk * ln2_lo;
		}
		R = f * f * (0.5 - 0.33333333333333333 * f);
		if (k == 0)
			return f - R;
		dk = (double) k;
		return dk * ln2_hi - ((R - dk * ln2_lo) - f);
	}
	s = f / (2.0 + f);
	dk = (double) k;
	z = s * s;
	i = hx - IC(0x6147a);
	w = z * z;
	j = IC(0x6b851) - hx;
	t1 = w * (Lg2 + w * (Lg4 + w * Lg6));
	t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));
	i |= j;
	R = t2 + t1;
	if (i > 0)
	{
		hfsq = 0.5 * f * f;
		if (k == 0)
			return f - (hfsq - s * (hfsq + R));
		return dk * ln2_hi - ((hfsq - (s * (hfsq + R) + dk * ln2_lo)) - f);
	}
	if (k == 0)
		return f - s * (f - R);
	return dk * ln2_hi - ((s * (f - R) - dk * ln2_lo) - f);
}

#endif


/* wrapper log(x) */
double __log(double x)
{
	if (_LIB_VERSION != _IEEE_ && islessequal(x, 0.0))
	{
		if (x == 0.0)
		{
			feraiseexcept(FE_DIVBYZERO);
			return __kernel_standard(x, x, -HUGE_VAL, KMATHERR_LOG_ZERO);	/* log(0) */
		} else
		{
			feraiseexcept(FE_INVALID);
			return __kernel_standard(x, x, __builtin_nan(""), KMATHERR_LOG_MINUS);	/* log(x<0) */
		}
	}

	return __ieee754_log(x);
}

__typeof(__log) log __attribute__((weak, alias("__log")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(__logl) __logl __attribute__((alias("__log")));
__typeof(__logl) logl __attribute__((weak, alias("__log")));
#endif

```

`e_log10.c`:

```c
/* @(#)e_log10.c 1.3 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/* __ieee754_log10(x)
 * Return the base 10 logarithm of x
 *
 * Method :
 *	Let log10_2hi = leading 40 bits of log10(2) and
 *	    log10_2lo = log10(2) - log10_2hi,
 *	    ivln10   = 1/log(10) rounded.
 *	Then
 *		n = ilogb(x),
 *		if(n<0)  n = n+1;
 *		x = scalbn(x,-n);
 *		log10(x) := n*log10_2hi + (n*log10_2lo + ivln10*log(x))
 *
 * Note 1:
 *	To guarantee log10(10**n)=n, where 10**n is normal, the rounding
 *	mode must set to Round-to-Nearest.
 * Note 2:
 *	[1/log(10)] rounded to 53 bits has error  .198   ulps;
 *	log10 is monotonic at all binary break points.
 *
 * Special cases:
 *	log10(x) is NaN with signal if x < 0;
 *	log10(+INF) is +INF with no signal; log10(0) is -INF with signal;
 *	log10(NaN) is that NaN with no signal;
 *	log10(10**N) = N  for N=0,1,...,22.
 *
 * Constants:
 * The hexadecimal values are the intended ones for the following constants.
 * The decimal values may be used, provided that the compiler will convert
 * from decimal to binary accurately enough to produce the hexadecimal values
 * shown.
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_log10

double __ieee754_log10(double x)
{
	double y, z;
	int32_t i, k, hx;
	uint32_t lx;

	static const double two54 = 1.80143985094819840000e+16;		/* 0x43500000, 0x00000000 */
	static const double ivln10 = 4.34294481903251816668e-01;	/* 0x3FDBCB7B, 0x1526E50E */
	static const double log10_2hi = 3.01029995663611771306e-01;	/* 0x3FD34413, 0x509F6000 */
	static const double log10_2lo = 3.69423907715893078616e-13;	/* 0x3D59FEF3, 0x11F12B36 */

	static const double zero = 0.0;

	GET_DOUBLE_WORDS(hx, lx, x);

	k = 0;
	if (hx < IC(0x00100000))
	{									/* x < 2**-1022  */
		if (((hx & IC(0x7fffffff)) | lx) == 0)
			return -two54 / zero;		/* log(+-0)=-inf */
		if (hx < 0)
			return (x - x) / zero;		/* log(-#) = NaN */
		k -= 54;
		x *= two54;						/* subnormal number, scale up x */
		GET_HIGH_WORD(hx, x);
	}
	if (hx >= IC(0x7ff00000))
		return x + x;
	k += (hx >> 20) - 1023;
	i = ((uint32_t) k & UC(0x80000000)) >> 31;
	hx = (hx & IC(0x000fffff)) | ((0x3ff - i) << 20);
	y = (double) (k + i);
	SET_HIGH_WORD(x, hx);
	z = y * log10_2lo + ivln10 * __ieee754_log(x);
	return z + y * log10_2hi;
}
#endif


/* wrapper log10(x) */
double __log10(double x)
{
	if (_LIB_VERSION != _IEEE_ && islessequal(x, 0.0))
	{
		if (x == 0.0)
		{
			feraiseexcept(FE_DIVBYZERO);
			return __kernel_standard(x, x, -HUGE_VAL, KMATHERR_LOG10_ZERO);	/* log10(0) */
		} else
		{
			feraiseexcept(FE_INVALID);
			return __kernel_standard(x, x, __builtin_nan(""), KMATHERR_LOG10_MINUS);	/* log10(x<0) */
		}
	}

	return __ieee754_log10(x);
}

__typeof(__log10) log10 __attribute__((weak, alias("__log10")));
#ifdef __NO_LONG_DOUBLE_MATH
long double __log10l(long double x) __attribute__((alias("__log10")));
__typeof(__log10l) log10l __attribute__((weak, alias("__log10")));
#endif

```

`e_log10f.c`:

```c
/* e_log10f.c -- float version of e_log10.c.
 * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_log10

float __ieee754_log10f(float x)
{
	float y, z;
	int32_t i, k, hx;

	static const float two25 = 3.3554432000e+07;			/* 0x4c000000 */
	static const float ivln10 = 4.3429449201e-01;			/* 0x3ede5bd9 */
	static const float log10_2hi = 3.0102920532e-01;		/* 0x3e9a2080 */
	static const float log10_2lo = 7.9034151668e-07;		/* 0x355427db */
	
	GET_FLOAT_WORD(hx, x);

	k = 0;
	if (hx < IC(0x00800000))
	{									/* x < 2**-126  */
		if ((hx & IC(0x7fffffff)) == 0)
			return -two25 / (x - x);	/* log(+-0)=-inf */
		if (hx < 0)
			return (x - x) / (x - x);	/* log(-#) = NaN */
		k -= 25;
		x *= two25;						/* subnormal number, scale up x */
		GET_FLOAT_WORD(hx, x);
	}
	if (hx >= IC(0x7f800000))
		return x + x;
	k += (hx >> 23) - 127;
	i = ((uint32_t) k & UC(0x80000000)) >> 31;
	hx = (hx & IC(0x007fffff)) | ((0x7f - i) << 23);
	y = (float) (k + i);
	SET_FLOAT_WORD(x, hx);
	z = y * log10_2lo + ivln10 * __ieee754_logf(x);
	return z + y * log10_2hi;
}

#endif


/* wrapper log10f(x) */
float __log10f(float x)
{
	if (islessequal(x, 0.0f) && _LIB_VERSION != _IEEE_)
	{
		if (x == 0.0f)
		{
			feraiseexcept(FE_DIVBYZERO);
			return __kernel_standard_f(x, x, -HUGE_VALF, KMATHERRF_LOG10_ZERO);	/* log10(0) */
		} else
		{
			feraiseexcept(FE_INVALID);
			return __kernel_standard_f(x, x, __builtin_nanf(""), KMATHERRF_LOG10_MINUS);	/* log10(x<0) */
		}
	}

	return __ieee754_log10f(x);
}

__typeof(__log10f) log10f __attribute__((weak, alias("__log10f")));


```

`e_log10l.c`:

```c
/*							log10l.c
 *
 *	Common logarithm, 128-bit long double precision
 *
 *
 *
 * SYNOPSIS:
 *
 * long double x, y, log10l();
 *
 * y = log10l( x );
 *
 *
 *
 * DESCRIPTION:
 *
 * Returns the base 10 logarithm of x.
 *
 * The argument is separated into its exponent and fractional
 * parts.  If the exponent is between -1 and +1, the logarithm
 * of the fraction is approximated by
 *
 *     log(1+x) = x - 0.5 x^2 + x^3 P(x)/Q(x).
 *
 * Otherwise, setting  z = 2(x-1)/x+1),
 *
 *     log(x) = z + z^3 P(z)/Q(z).
 *
 *
 *
 * ACCURACY:
 *
 *                      Relative error:
 * arithmetic   domain     # trials      peak         rms
 *    IEEE      0.5, 2.0     30000      2.3e-34     4.9e-35
 *    IEEE     exp(+-10000)  30000      1.0e-34     4.1e-35
 *
 * In the tests over the interval exp(+-10000), the logarithms
 * of the random arguments were uniformly distributed over
 * [-10000, +10000].
 *
 */

/*
   Cephes Math Library Release 2.2:  January, 1991
   Copyright 1984, 1991 by Stephen L. Moshier
   Adapted for glibc November, 2001

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, see <http://www.gnu.org/licenses/>.
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

#ifndef __have_fpu_log10

/* Evaluate P[n] x^n  +  P[n-1] x^(n-1)  +  ...  +  P[0] */

static long double log10l_neval(long double x, const long double *p, int n)
{
	long double y;

	p += n;
	y = *p--;
	do
	{
		y = y * x + *p--;
	} while (--n > 0);
	return y;
}


/* Evaluate x^n+1  +  P[n] x^(n)  +  P[n-1] x^(n-1)  +  ...  +  P[0] */

static long double log10l_deval(long double x, const long double *p, int n)
{
	long double y;

	p += n;
	y = x + *p--;
	do
	{
		y = y * x + *p--;
	} while (--n > 0);
	return y;
}



long double __ieee754_log10l(long double x)
{
	long double z;
	long double y;
	int e;
	uint32_t exp;

	/* Coefficients for ln(1+x) = x - x**2/2 + x**3 P(x)/Q(x)
	 * 1/sqrt(2) <= x < sqrt(2)
	 * Theoretical peak relative error = 5.3e-37,
	 * relative peak error spread = 2.3e-14
	 */
	static const long double P[13] = {
		1.313572404063446165910279910527789794488E4L,
		7.771154681358524243729929227226708890930E4L,
		2.014652742082537582487669938141683759923E5L,
		3.007007295140399532324943111654767187848E5L,
		2.854829159639697837788887080758954924001E5L,
		1.797628303815655343403735250238293741397E5L,
		7.594356839258970405033155585486712125861E4L,
		2.128857716871515081352991964243375186031E4L,
		3.824952356185897735160588078446136783779E3L,
		4.114517881637811823002128927449878962058E2L,
		2.321125933898420063925789532045674660756E1L,
		4.998469661968096229986658302195402690910E-1L,
		1.538612243596254322971797716843006400388E-6L
	};

	static const long double Q[12] = {
		3.940717212190338497730839731583397586124E4L,
		2.626900195321832660448791748036714883242E5L,
		7.777690340007566932935753241556479363645E5L,
		1.347518538384329112529391120390701166528E6L,
		1.514882452993549494932585972882995548426E6L,
		1.158019977462989115839826904108208787040E6L,
		6.132189329546557743179177159925690841200E5L,
		2.248234257620569139969141618556349415120E5L,
		5.605842085972455027590989944010492125825E4L,
		9.147150349299596453976674231612674085381E3L,
		9.104928120962988414618126155557301584078E2L,
		4.839208193348159620282142911143429644326E1L
	/* 1.000000000000000000000000000000000000000E0L, */
	};
	
	/* Coefficients for log(x) = z + z^3 P(z^2)/Q(z^2),
	 * where z = 2(x-1)/(x+1)
	 * 1/sqrt(2) <= x < sqrt(2)
	 * Theoretical peak relative error = 1.1e-35,
	 * relative peak error spread 1.1e-9
	 */
	static const long double R[6] = {
		1.418134209872192732479751274970992665513E5L,
		-8.977257995689735303686582344659576526998E4L,
		2.048819892795278657810231591630928516206E4L,
		-2.024301798136027039250415126250455056397E3L,
		8.057002716646055371965756206836056074715E1L,
		-8.828896441624934385266096344596648080902E-1L
	};
	
	static const long double S[6] = {
		1.701761051846631278975701529965589676574E6L,
		-1.332535117259762928288745111081235577029E6L,
		4.001557694070773974936904547424676279307E5L,
		-5.748542087379434595104154610899551484314E4L,
		3.998526750980007367835804959888064681098E3L,
		-1.186359407982897997337150403816839480438E2L
	/* 1.000000000000000000000000000000000000000E0L, */
	};

	/* log10(2) */
	static const long double L102A = 0.3125L;
	static const long double L102B = -1.14700043360188047862611052755069732318101185E-2L;
	/* log10(e) */
	static const long double L10EA = 0.5L;
	static const long double L10EB = -6.570551809674817234887108108339491770560299E-2L;
	/* sqrt(2)/2 */
	static const long double SQRTH = 7.071067811865475244008443621048490392848359E-1L;


/* Test for domain */
	GET_LDOUBLE_EXP(exp, x);
	if ((exp & 0x7fff) == 0)
		return (-1.0L / (x - x));
	if (exp & 0x8000)
		return (x - x) / (x - x);
	if (exp >= 0x7fff)
		return x + x;

/* separate mantissa from exponent */

/* Note, frexp is used so that denormal numbers
 * will be handled properly.
 */
	x = __ieee754_frexpl(x, &e);


/* logarithm using log(x) = z + z**3 P(z)/Q(z),
 * where z = 2(x-1)/x+1)
 */
	if ((e > 2) || (e < -2))
	{
		if (x < SQRTH)
		{								/* 2( 2x-1 )/( 2x+1 ) */
			e -= 1;
			z = x - 0.5L;
			y = 0.5L * z + 0.5L;
		} else
		{								/*  2 (x-1)/(x+1)   */
			z = x - 0.5L;
			z -= 0.5L;
			y = 0.5L * x + 0.5L;
		}
		x = z / y;
		z = x * x;
		y = x * (z * log10l_neval(z, R, 5) / log10l_deval(z, S, 5));
		goto done;
	}


/* logarithm using log(1+x) = x - .5x**2 + x**3 P(x)/Q(x) */

	if (x < SQRTH)
	{
		e -= 1;
		x = 2.0 * x - 1.0L;				/*  2x - 1  */
	} else
	{
		x = x - 1.0L;
	}
	z = x * x;
	y = x * (z * log10l_neval(x, P, 12) / log10l_deval(x, Q, 11));
	y = y - 0.5 * z;

  done:

	/* Multiply log of fraction by log10(e)
	 * and base 2 exponent by log10(2).
	 */
	z = y * L10EB;
	z += x * L10EB;
	z += e * L102B;
	z += y * L10EA;
	z += x * L10EA;
	z += e * L102A;
	return z;
}

#endif

/* wrapper log10l(x) */
long double __log10l(long double x)
{
	if (islessequal(x, 0.0L) && _LIB_VERSION != _IEEE_)
	{
		if (x == 0.0L)
		{
			feraiseexcept(FE_DIVBYZERO);
			return __kernel_standard_l(x, x, -HUGE_VALL, KMATHERRL_LOG10_ZERO);	/* log10(0) */
		} else
		{
			feraiseexcept(FE_INVALID);
			return __kernel_standard_l(x, x, __builtin_nanl(""), KMATHERRL_LOG10_MINUS);	/* log10(x<0) */
		}
	}

	return __ieee754_log10l(x);
}

__typeof(__log10l) log10l __attribute__((weak, alias("__log10l")));

#endif

```

`e_log2.c`:

```c
/* Adapted for log2 by Ulrich Drepper <drepper@cygnus.com>.  */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/* __ieee754_log2(x)
 * Return the logarithm to base 2 of x
 *
 * Method :
 *   1. Argument Reduction: find k and f such that
 *			x = 2^k * (1+f),
 *	   where  sqrt(2)/2 < 1+f < sqrt(2) .
 *
 *   2. Approximation of log(1+f).
 *	Let s = f/(2+f) ; based on log(1+f) = log(1+s) - log(1-s)
 *		 = 2s + 2/3 s**3 + 2/5 s**5 + .....,
 *		 = 2s + s*R
 *      We use a special Reme algorithm on [0,0.1716] to generate
 *	a polynomial of degree 14 to approximate R The maximum error
 *	of this polynomial approximation is bounded by 2**-58.45. In
 *	other words,
 *			2      4      6      8      10      12      14
 *	    R(z) ~ Lg1*s +Lg2*s +Lg3*s +Lg4*s +Lg5*s  +Lg6*s  +Lg7*s
 *	(the values of Lg1 to Lg7 are listed in the program)
 *	and
 *	    |      2          14          |     -58.45
 *	    | Lg1*s +...+Lg7*s    -  R(z) | <= 2
 *	    |                             |
 *	Note that 2s = f - s*f = f - hfsq + s*hfsq, where hfsq = f*f/2.
 *	In order to guarantee error in log below 1ulp, we compute log
 *	by
 *		log(1+f) = f - s*(f - R)	(if f is not too large)
 *		log(1+f) = f - (hfsq - s*(hfsq+R)).	(better accuracy)
 *
 *	3. Finally,  log(x) = k + log(1+f).
 *			    = k+(f-(hfsq-(s*(hfsq+R))))
 *
 * Special cases:
 *	log2(x) is NaN with signal if x < 0 (including -INF) ;
 *	log2(+INF) is +INF; log(0) is -INF with signal;
 *	log2(NaN) is that NaN with no signal.
 *
 * Constants:
 * The hexadecimal values are the intended ones for the following
 * constants. The decimal values may be used, provided that the
 * compiler will convert from decimal to binary accurately enough
 * to produce the hexadecimal values shown.
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_log2

double __ieee754_log2(double x)
{
	double hfsq, f, s, z, R, w, t1, t2, dk;
	int32_t k, hx, i, j;
	uint32_t lx;

	static const double ln2 = 0.69314718055994530942;
	static const double two54 = 1.80143985094819840000e+16;	/* 43500000 00000000 */
	static const double Lg1 = 6.666666666666735130e-01;	/* 3FE55555 55555593 */
	static const double Lg2 = 3.999999999940941908e-01;	/* 3FD99999 9997FA04 */
	static const double Lg3 = 2.857142874366239149e-01;	/* 3FD24924 94229359 */
	static const double Lg4 = 2.222219843214978396e-01;	/* 3FCC71C5 1D8E78AF */
	static const double Lg5 = 1.818357216161805012e-01;	/* 3FC74664 96CB03DE */
	static const double Lg6 = 1.531383769920937332e-01;	/* 3FC39A09 D078C69F */
	static const double Lg7 = 1.479819860511658591e-01;	/* 3FC2F112 DF3E5244 */
	static const double zero = 0.0;

	GET_DOUBLE_WORDS(hx, lx, x);

	k = 0;
	if (hx < IC(0x00100000))
	{									/* x < 2**-1022  */
		if (((hx & IC(0x7fffffff)) | lx) == 0)
			return -two54 / (x - x);	/* log(+-0)=-inf */
		if (hx < 0)
			return (x - x) / (x - x);	/* log(-#) = NaN */
		k -= 54;
		x *= two54;						/* subnormal number, scale up x */
		GET_HIGH_WORD(hx, x);
	}
	if (hx >= IC(0x7ff00000))
		return x + x;
	k += (hx >> 20) - 1023;
	hx &= IC(0x000fffff);
	i = (hx + IC(0x95f64)) & IC(0x100000);
	SET_HIGH_WORD(x, hx | (i ^ IC(0x3ff00000)));	/* normalize x or x/2 */
	k += (i >> 20);
	dk = (double) k;
	f = x - 1.0;
	if ((IC(0x000fffff) & (2 + hx)) < 3)
	{									/* |f| < 2**-20 */
		if (f == zero)
			return dk;
		R = f * f * (0.5 - 0.33333333333333333 * f);
		return dk - (R - f) / ln2;
	}
	s = f / (2.0 + f);
	z = s * s;
	i = hx - IC(0x6147a);
	w = z * z;
	j = IC(0x6b851) - hx;
	t1 = w * (Lg2 + w * (Lg4 + w * Lg6));
	t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));
	i |= j;
	R = t2 + t1;
	if (i > 0)
	{
		hfsq = 0.5 * f * f;
		return dk - ((hfsq - (s * (hfsq + R))) - f) / ln2;
	} else
	{
		return dk - ((s * (f - R)) - f) / ln2;
	}
}

#endif

/* wrapper log2(x) */
double __log2(double x)
{
	if (islessequal(x, 0.0) && _LIB_VERSION != _IEEE_)
	{
		if (x == 0.0)
		{
			feraiseexcept(FE_DIVBYZERO);
			return __kernel_standard(x, x, -HUGE_VAL, KMATHERR_LOG2_ZERO);	/* log2(0) */
		} else
		{
			feraiseexcept(FE_INVALID);
			return __kernel_standard(x, x, __builtin_nan(""), KMATHERR_LOG2_MINUS);	/* log2(x<0) */
		}
	}

	return __ieee754_log2(x);
}


__typeof(__log2) log2 __attribute__((weak, alias("__log2")));
#ifdef __NO_LONG_DOUBLE_MATH
long double __log2l(long double x) __attribute__((alias("__log2")));
__typeof(__log2l) log2l __attribute__((weak, alias("__log2")));
#endif

```

`e_log2f.c`:

```c
/* e_logf.c -- float version of e_log.c.
 * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
 * adapted for log2 by Ulrich Drepper <drepper@cygnus.com>
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */


#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_log2

float __ieee754_log2f(float x)
{
	float hfsq, f, s, z, R, w, t1, t2, dk;
	int32_t k, ix, i, j;

	static const float ln2 = 0.69314718055994530942;
	static const float two25 = 3.355443200e+07;				/* 0x4c000000 */
	static const float Lg1 = 6.6666668653e-01;				/* 3F2AAAAB */
	static const float Lg2 = 4.0000000596e-01;				/* 3ECCCCCD */
	static const float Lg3 = 2.8571429849e-01;				/* 3E924925 */
	static const float Lg4 = 2.2222198546e-01;				/* 3E638E29 */
	static const float Lg5 = 1.8183572590e-01;				/* 3E3A3325 */
	static const float Lg6 = 1.5313838422e-01;				/* 3E1CD04F */
	static const float Lg7 = 1.4798198640e-01;				/* 3E178897 */
	
	static const float zero = 0.0;

	GET_FLOAT_WORD(ix, x);

	k = 0;
	if (ix < IC(0x00800000))
	{									/* x < 2**-126  */
		if ((ix & IC(0x7fffffff)) == 0)
			return -two25 / (x - x);	/* log(+-0)=-inf */
		if (ix < 0)
			return (x - x) / (x - x);	/* log(-#) = NaN */
		k -= 25;
		x *= two25;						/* subnormal number, scale up x */
		GET_FLOAT_WORD(ix, x);
	}
	if (ix >= IC(0x7f800000))
		return x + x;
	k += (ix >> 23) - 127;
	ix &= IC(0x007fffff);
	i = (ix + (IC(0x95f64) << 3)) & IC(0x800000);
	SET_FLOAT_WORD(x, ix | (i ^ IC(0x3f800000)));	/* normalize x or x/2 */
	k += (i >> 23);
	dk = (float) k;
	f = x - (float) 1.0;
	if ((IC(0x007fffff) & (15 + ix)) < 16)
	{									/* |f| < 2**-20 */
		if (f == zero)
			return dk;
		R = f * f * ((float) 0.5 - (float) 0.33333333333333333 * f);
		return dk - (R - f) / ln2;
	}
	s = f / ((float) 2.0 + f);
	z = s * s;
	i = ix - (IC(0x6147a) << 3);
	w = z * z;
	j = (IC(0x6b851) << 3) - ix;
	t1 = w * (Lg2 + w * (Lg4 + w * Lg6));
	t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));
	i |= j;
	R = t2 + t1;
	if (i > 0)
	{
		hfsq = (float) 0.5 *f * f;

		return dk - ((hfsq - (s * (hfsq + R))) - f) / ln2;
	} else
	{
		return dk - ((s * (f - R)) - f) / ln2;
	}
}

#endif

/* wrapper log2(x) */
float __log2f(float x)
{
	if (islessequal(x, 0.0) && _LIB_VERSION != _IEEE_)
	{
		if (x == 0.0F)
		{
			feraiseexcept(FE_DIVBYZERO);
			return __kernel_standard_f(x, x, -HUGE_VALF, KMATHERRF_LOG2_ZERO);	/* log2(0) */
		} else
		{
			feraiseexcept(FE_INVALID);
			return __kernel_standard_f(x, x, __builtin_nanf(""), KMATHERRF_LOG2_MINUS);	/* log2(x<0) */
		}
	}

	return __ieee754_log2f(x);
}

__typeof(__log2f) log2f __attribute__((weak, alias("__log2f")));

```

`e_log2l.c`:

```c
/* Base 2 logarithm.
   Copyright (C) 2011-2013 Free Software Foundation, Inc.

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2.1 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

#ifndef __have_fpu_log2

long double __ieee754_log2l(long double x)
{
	/* Decompose x into
	   x = 2^e * y
	   where
	   e is an integer,
	   1/2 < y < 2.
	   Then log2(x) = e + log2(y) = e + log(y)/log(2).  */
	int e;
	long double y;

	y = __ieee754_frexpl(x, &e);
	if (y < M_SQRT1_2l)
	{
		y = 2.0L * y;
		e = e - 1;
	}

	return (long double) e + __ieee754_logl(y) * M_LOG2El;
}

#endif

/* wrapper log2(x) */
long double __log2l(long double x)
{
	if (islessequal(x, 0.0) && _LIB_VERSION != _IEEE_)
	{
		if (x == 0.0)
		{
			feraiseexcept(FE_DIVBYZERO);
			return __kernel_standard_l(x, x, -HUGE_VALL, KMATHERRL_LOG2_ZERO);	/* log2(0) */
		} else
		{
			feraiseexcept(FE_INVALID);
			return __kernel_standard_l(x, x, __builtin_nanl(""), KMATHERRL_LOG2_MINUS);	/* log2(x<0) */
		}
	}

	return __ieee754_log2l(x);
}

__typeof(__log2l) log2l __attribute__((weak, alias("__log2l")));

#endif

```

`e_logf.c`:

```c
/* e_logf.c -- float version of e_log.c.
 * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_log

float __ieee754_logf(float x)
{
	float hfsq, f, s, z, R, w, t1, t2, dk;
	int32_t k, ix, i, j;

	static const float ln2_hi = 6.9313812256e-01;			/* 0x3f317180 */
	static const float ln2_lo = 9.0580006145e-06;			/* 0x3717f7d1 */
	static const float two25 = 3.355443200e+07;				/* 0x4c000000 */
	static const float Lg1 = 6.6666668653e-01;				/* 3F2AAAAB */
	static const float Lg2 = 4.0000000596e-01;				/* 3ECCCCCD */
	static const float Lg3 = 2.8571429849e-01;				/* 3E924925 */
	static const float Lg4 = 2.2222198546e-01;				/* 3E638E29 */
	static const float Lg5 = 1.8183572590e-01;				/* 3E3A3325 */
	static const float Lg6 = 1.5313838422e-01;				/* 3E1CD04F */
	static const float Lg7 = 1.4798198640e-01;				/* 3E178897 */
	
	static const float zero = 0.0;

	GET_FLOAT_WORD(ix, x);

	k = 0;
	if (ix < IC(0x00800000))
	{									/* x < 2**-126  */
		if ((ix & IC(0x7fffffff)) == 0)
			return -two25 / (x - x);	/* log(+-0)=-inf */
		if (ix < 0)
			return (x - x) / (x - x);	/* log(-#) = NaN */
		k -= 25;
		x *= two25;						/* subnormal number, scale up x */
		GET_FLOAT_WORD(ix, x);
	}
	if (ix >= IC(0x7f800000))
		return x + x;
	k += (ix >> 23) - 127;
	ix &= IC(0x007fffff);
	i = (ix + (IC(0x95f64) << 3)) & IC(0x800000);
	SET_FLOAT_WORD(x, ix | (i ^ IC(0x3f800000)));	/* normalize x or x/2 */
	k += (i >> 23);
	f = x - (float) 1.0;
	if ((IC(0x007fffff) & (15 + ix)) < 16)
	{									/* |f| < 2**-20 */
		if (f == zero)
		{
			if (k == 0)
				return zero;
			else
			{
				dk = (float) k;
				return dk * ln2_hi + dk * ln2_lo;
			}
		}
		R = f * f * ((float) 0.5 - (float) 0.33333333333333333 * f);
		if (k == 0)
			return f - R;
		else
		{
			dk = (float) k;
			return dk * ln2_hi - ((R - dk * ln2_lo) - f);
		}
	}
	s = f / ((float) 2.0 + f);
	dk = (float) k;
	z = s * s;
	i = ix - (IC(0x6147a) << 3);
	w = z * z;
	j = (IC(0x6b851) << 3) - ix;
	t1 = w * (Lg2 + w * (Lg4 + w * Lg6));
	t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));
	i |= j;
	R = t2 + t1;
	if (i > 0)
	{
		hfsq = 0.5F * f * f;

		if (k == 0)
			return f - (hfsq - s * (hfsq + R));
		else
			return dk * ln2_hi - ((hfsq - (s * (hfsq + R) + dk * ln2_lo)) - f);
	} else
	{
		if (k == 0)
			return f - s * (f - R);
		else
			return dk * ln2_hi - ((s * (f - R) - dk * ln2_lo) - f);
	}
}

#endif


/* wrapper logf(x) */
float __logf(float x)
{
	if (islessequal(x, 0.0f) && _LIB_VERSION != _IEEE_)
	{
		if (x == 0.0f)
		{
			feraiseexcept(FE_DIVBYZERO);
			return __kernel_standard_f(x, x, -HUGE_VALF, KMATHERRF_LOG_ZERO);	/* log(0) */
		} else
		{
			feraiseexcept(FE_INVALID);
			return __kernel_standard_f(x, x, __builtin_nanf(""), KMATHERRF_LOG_MINUS);	/* log(x<0) */
		}
	}

	return __ieee754_logf(x);
}

__typeof(__logf) logf __attribute__((weak, alias("__logf")));

```

`e_logl.c`:

```c
/*							logll.c
 *
 * Natural logarithm for 128-bit long double precision.
 *
 *
 *
 * SYNOPSIS:
 *
 * long double x, y, logl();
 *
 * y = logl( x );
 *
 *
 *
 * DESCRIPTION:
 *
 * Returns the base e (2.718...) logarithm of x.
 *
 * The argument is separated into its exponent and fractional
 * parts.  Use of a lookup table increases the speed of the routine.
 * The program uses logarithms tabulated at intervals of 1/128 to
 * cover the domain from approximately 0.7 to 1.4.
 *
 * On the interval [-1/128, +1/128] the logarithm of 1+x is approximated by
 *     log(1+x) = x - 0.5 x^2 + x^3 P(x) .
 *
 *
 *
 * ACCURACY:
 *
 *                      Relative error:
 * arithmetic   domain     # trials      peak         rms
 *    IEEE   0.875, 1.125   100000      1.2e-34    4.1e-35
 *    IEEE   0.125, 8       100000      1.2e-34    4.1e-35
 *
 *
 * WARNING:
 *
 * This program uses integer operations on bit fields of floating-point
 * numbers.  It does not work with data structures other than the
 * structure assumed.
 *
 */

/* Copyright 2001 by Stephen L. Moshier <moshier@na-net.ornl.gov>

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, see
    <http://www.gnu.org/licenses/>.  */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

#ifndef __have_fpu_log

long double __ieee754_logl(long double x)
{
#if 0
	long double z, y, w;
	long double u, t;
	uint32_t m, k;
	int32_t e;
	uint32_t msw, lsw;
	
	/* log(1+x) = x - .5 x^2 + x^3 l(x)
	   -.0078125 <= x <= +.0078125
	   peak relative error 1.2e-37 */
	static const long double l3 = 3.333333333333333333333333333333336096926E-1L;
	static const long double l4 = -2.499999999999999999999999999486853077002E-1L;
	static const long double l5 = 1.999999999999999999999999998515277861905E-1L;
	static const long double l6 = -1.666666666666666666666798448356171665678E-1L;
	static const long double l7 = 1.428571428571428571428808945895490721564E-1L;
	static const long double l8 = -1.249999999999999987884655626377588149000E-1L;
	static const long double l9 = 1.111111111111111093947834982832456459186E-1L;
	static const long double l10 = -1.000000000000532974938900317952530453248E-1L;
	static const long double l11 = 9.090909090915566247008015301349979892689E-2L;
	static const long double l12 = -8.333333211818065121250921925397567745734E-2L;
	static const long double l13 = 7.692307559897661630807048686258659316091E-2L;
	static const long double l14 = -7.144242754190814657241902218399056829264E-2L;
	static const long double l15 = 6.668057591071739754844678883223432347481E-2L;
	
	/* Lookup table of ln(t) - (t-1)
	    t = 0.5 + (k+26)/128)
	    k = 0, ..., 91   */
	static const long double logtbl[92] = {
		-5.5345593589352099112142921677820359632418E-2L,
		-5.2108257402767124761784665198737642086148E-2L,
		-4.8991686870576856279407775480686721935120E-2L,
		-4.5993270766361228596215288742353061431071E-2L,
		-4.3110481649613269682442058976885699556950E-2L,
		-4.0340872319076331310838085093194799765520E-2L,
		-3.7682072451780927439219005993827431503510E-2L,
		-3.5131785416234343803903228503274262719586E-2L,
		-3.2687785249045246292687241862699949178831E-2L,
		-3.0347913785027239068190798397055267411813E-2L,
		-2.8110077931525797884641940838507561326298E-2L,
		-2.5972247078357715036426583294246819637618E-2L,
		-2.3932450635346084858612873953407168217307E-2L,
		-2.1988775689981395152022535153795155900240E-2L,
		-2.0139364778244501615441044267387667496733E-2L,
		-1.8382413762093794819267536615342902718324E-2L,
		-1.6716169807550022358923589720001638093023E-2L,
		-1.5138929457710992616226033183958974965355E-2L,
		-1.3649036795397472900424896523305726435029E-2L,
		-1.2244881690473465543308397998034325468152E-2L,
		-1.0924898127200937840689817557742469105693E-2L,
		-9.6875626072830301572839422532631079809328E-3L,
		-8.5313926245226231463436209313499745894157E-3L,
		-7.4549452072765973384933565912143044991706E-3L,
		-6.4568155251217050991200599386801665681310E-3L,
		-5.5356355563671005131126851708522185605193E-3L,
		-4.6900728132525199028885749289712348829878E-3L,
		-3.9188291218610470766469347968659624282519E-3L,
		-3.2206394539524058873423550293617843896540E-3L,
		-2.5942708080877805657374888909297113032132E-3L,
		-2.0385211375711716729239156839929281289086E-3L,
		-1.5522183228760777967376942769773768850872E-3L,
		-1.1342191863606077520036253234446621373191E-3L,
		-7.8340854719967065861624024730268350459991E-4L,
		-4.9869831458030115699628274852562992756174E-4L,
		-2.7902661731604211834685052867305795169688E-4L,
		-1.2335696813916860754951146082826952093496E-4L,
		-3.0677461025892873184042490943581654591817E-5L,
#define ZERO logtbl[38]
		0.0000000000000000000000000000000000000000E0L,
		-3.0359557945051052537099938863236321874198E-5L,
		-1.2081346403474584914595395755316412213151E-4L,
		-2.7044071846562177120083903771008342059094E-4L,
		-4.7834133324631162897179240322783590830326E-4L,
		-7.4363569786340080624467487620270965403695E-4L,
		-1.0654639687057968333207323853366578860679E-3L,
		-1.4429854811877171341298062134712230604279E-3L,
		-1.8753781835651574193938679595797367137975E-3L,
		-2.3618380914922506054347222273705859653658E-3L,
		-2.9015787624124743013946600163375853631299E-3L,
		-3.4938307889254087318399313316921940859043E-3L,
		-4.1378413103128673800485306215154712148146E-3L,
		-4.8328735414488877044289435125365629849599E-3L,
		-5.5782063183564351739381962360253116934243E-3L,
		-6.3731336597098858051938306767880719015261E-3L,
		-7.2169643436165454612058905294782949315193E-3L,
		-8.1090214990427641365934846191367315083867E-3L,
		-9.0486422112807274112838713105168375482480E-3L,
		-1.0035177140880864314674126398350812606841E-2L,
		-1.1067990155502102718064936259435676477423E-2L,
		-1.2146457974158024928196575103115488672416E-2L,
		-1.3269969823361415906628825374158424754308E-2L,
		-1.4437927104692837124388550722759686270765E-2L,
		-1.5649743073340777659901053944852735064621E-2L,
		-1.6904842527181702880599758489058031645317E-2L,
		-1.8202661505988007336096407340750378994209E-2L,
		-1.9542647000370545390701192438691126552961E-2L,
		-2.0924256670080119637427928803038530924742E-2L,
		-2.2346958571309108496179613803760727786257E-2L,
		-2.3810230892650362330447187267648486279460E-2L,
		-2.5313561699385640380910474255652501521033E-2L,
		-2.6856448685790244233704909690165496625399E-2L,
		-2.8438398935154170008519274953860128449036E-2L,
		-3.0058928687233090922411781058956589863039E-2L,
		-3.1717563112854831855692484086486099896614E-2L,
		-3.3413836095418743219397234253475252001090E-2L,
		-3.5147290019036555862676702093393332533702E-2L,
		-3.6917475563073933027920505457688955423688E-2L,
		-3.8723951502862058660874073462456610731178E-2L,
		-4.0566284516358241168330505467000838017425E-2L,
		-4.2444048996543693813649967076598766917965E-2L,
		-4.4356826869355401653098777649745233339196E-2L,
		-4.6304207416957323121106944474331029996141E-2L,
		-4.8285787106164123613318093945035804818364E-2L,
		-5.0301169421838218987124461766244507342648E-2L,
		-5.2349964705088137924875459464622098310997E-2L,
		-5.4431789996103111613753440311680967840214E-2L,
		-5.6546268881465384189752786409400404404794E-2L,
		-5.8693031345788023909329239565012647817664E-2L,
		-6.0871713627532018185577188079210189048340E-2L,
		-6.3081958078862169742820420185833800925568E-2L,
		-6.5323413029406789694910800219643791556918E-2L,
		-6.7595732653791419081537811574227049288168E-2L
	};
	
	/* ln(2) = ln2a + ln2b with extended precision. */
	static const long double ln2a = 6.93145751953125e-1L;
	static const long double ln2b = 1.4286068203094172321214581765680755001344E-6L;
	
	static const long double ldbl_epsilon = hexconstl(0x1p-106L, 1.2325951644078309459558e-32L, 0x3f95, UC(0x80000000), UC(0x00000000));

	u = x;
	GET_LDOUBLE_WORDS(m, msw, lsw, u);
	msw &= IC(0x7fffffff);
	
	/* Check for IEEE special cases.  */
	k = ((m & 0x7fff) << 16) | (msw >> 16);
	/* log(0) = -infinity. */
	if ((k | (msw & UC(0x7fffffff)) | lsw) == 0)
	{
		return -0.5L / ZERO;
	}
	/* log ( x < 0 ) = NaN */
	if (m & 0x8000)
	{
		return (x - x) / ZERO;
	}
	/* log (infinity or NaN) */
	if (k >= UC(0x7fff0000))
	{
		return x + x;
	}

	/* On this interval the table is not used due to cancellation error.  */
	if (x <= 1.0078125L && x >= 0.9921875L)
	{
		if (x == 1.0L)
			return 0.0L;
		z = x - 1.0L;
		k = 64;
		t = 1.0L;
		e = 0;
	} else
	{
		/* Extract exponent and reduce domain to 0.703125 <= u < 1.40625  */
		e = m - 0x3ffe;
		SET_LDOUBLE_EXP(u, 0x3ffe);
		m = (msw >> 16) | IC(0x10000);
		/* Find lookup table index k from high order bits of the significand. */
		if (m < UC(0x16800))
		{
			k = (m - UC(0xff00)) >> 9;
			/* t is the argument 0.5 + (k+26)/128
			   of the nearest item to u in the lookup table.  */
			SET_LDOUBLE_WORDS(t, 0x3fff, (k << 25) | UC(0x80000000), 0);
			SET_LDOUBLE_EXP(u, 0x3fff);
			e -= 1;
			k += 64;
		} else
		{
			k = (m - UC(0xfe00)) >> 10;
			SET_LDOUBLE_WORDS(t, 0x3ffe, (k << 26) | UC(0x80000000), 0);
		}
		/* log(u) = log( t u/t ) = log(t) + log(u/t)
		   log(t) is tabulated in the lookup table.
		   Express log(u/t) = log(1+z),  where z = u/t - 1 = (u-t)/t.
		   cf. Cody & Waite. */
		z = (u - t) / t;
	}
	/* Series expansion of log(1+z).  */
	w = z * z;
	/* Avoid spurious underflows.  */
	if (w <= ldbl_epsilon)
		y = 0.0L;
	else
	{
		y = ((((((((((((l15 * z
						+ l14) * z
					   + l13) * z
					  + l12) * z
					 + l11) * z
					+ l10) * z
				   + l9) * z
				  + l8) * z
				 + l7) * z
				+ l6) * z
			   + l5) * z
			  + l4) * z
			 + l3) * z * w;
		y -= 0.5 * w;
	}
	y += e * ln2b;						/* Base 2 exponent offset times ln(2).  */
	y += z;
	y += logtbl[k - 26];				/* log(t) - (t-1) */
	y += (t - 1.0L);
	y += e * ln2a;
	return y;
#undef ZERO
#else
	long double hfsq, f, s, z, R, w, t1, t2, dk;
	int32_t k, hx, i, j;
	uint32_t lx;
	uint32_t m;
	
	static const long double ln2_hi = 6.93145751953125e-1L;
	static const long double ln2_lo = 1.4286068203094172321214581765680755001344E-6L;
	static const long double Lg1 = 6.666666666666735130e-01L;		/* 3FE55555 55555593 */
	static const long double Lg2 = 3.999999999940941908e-01L;		/* 3FD99999 9997FA04 */
	static const long double Lg3 = 2.857142874366239149e-01L;		/* 3FD24924 94229359 */
	static const long double Lg4 = 2.222219843214978396e-01L;		/* 3FCC71C5 1D8E78AF */
	static const long double Lg5 = 1.818357216161805012e-01L;		/* 3FC74664 96CB03DE */
	static const long double Lg6 = 1.531383769920937332e-01L;		/* 3FC39A09 D078C69F */
	static const long double Lg7 = 1.479819860511658591e-01L;		/* 3FC2F112 DF3E5244 */
	
	static const long double zero = 0.0;

	GET_LDOUBLE_WORDS(m, hx, lx, x);
	k = m & 0x7fff;

	/* log(0) = -infinity. */
	if ((k | (hx & UC(0x7fffffff)) | lx) == 0)
	{
		return -0.5L / zero;
	}
	if (m & 0x8000)
		return (x - x) / zero;		/* log(-#) = NaN */
	/* log (infinity or NaN) */
	if (k >= 0x7fff)
		return x + x;
 	k -= 0x3fff;
	hx &= IC(0x7fffffff);
	i = (((hx >> 11) + IC(0x95f64)) & IC(0x100000)) >> 20;
	SET_LDOUBLE_EXP(x, i ^ 0x3fff);	/* normalize x or x/2 */
	k += i;
	f = x - 1.0;
#if 0
	if ((IC(0x7fffffff) & (2 + hx)) < 3)
	{									/* |f| < 2**-20 */
		if (f == zero)
		{
			if (k == 0)
				return zero;
			dk = (long double) k;
			return dk * ln2_hi + dk * ln2_lo;
		}
		R = f * f * (0.5L - 0.33333333333333333333333333L * f);
		if (k == 0)
			return f - R;
		dk = (long double) k;
		return dk * ln2_hi - ((R - dk * ln2_lo) - f);
	}
#endif
	s = f / (2.0 + f);
	dk = (long double) k;
	z = s * s;
	i = hx - IC(0x6147a000);
	w = z * z;
	j = IC(0x6b851000) - hx;
	t1 = w * (Lg2 + w * (Lg4 + w * Lg6));
	t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));
	i |= j;
	R = t2 + t1;
	if (i > 0)
	{
		hfsq = 0.5 * f * f;
		if (k == 0)
			return f - (hfsq - s * (hfsq + R));
		return dk * ln2_hi - ((hfsq - (s * (hfsq + R) + dk * ln2_lo)) - f);
	}
	if (k == 0)
		return f - s * (f - R);
	return dk * ln2_hi - ((s * (f - R) - dk * ln2_lo) - f);
#endif
}

#endif

/* wrapper logl(x) */
long double __logl(long double x)
{
	if (islessequal(x, 0.0L) && _LIB_VERSION != _IEEE_)
	{
		if (x == 0.0L)
		{
			feraiseexcept(FE_DIVBYZERO);
			return __kernel_standard_l(x, x, -HUGE_VALL, KMATHERRL_LOG_ZERO);	/* log(0) */
		} else
		{
			feraiseexcept(FE_INVALID);
			return __kernel_standard_l(x, x, __builtin_nanl(""), KMATHERRL_LOG_MINUS);	/* log(x<0) */
		}
	}

	return __ieee754_logl(x);
}

__typeof(__logl) logl __attribute__((weak, alias("__logl")));

#endif

```

`e_pow.c`:

```c
/*
 * ====================================================
 * Copyright (C) 2004 by Sun Microsystems, Inc. All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice 
 * is preserved.
 * ====================================================
 */

/* __ieee754_pow(x,y) return x**y
 *
 *		      n
 * Method:  Let x =  2   * (1+f)
 *	1. Compute and return log2(x) in two pieces:
 *		log2(x) = w1 + w2,
 *	   where w1 has 53-24 = 29 bit trailing zeros.
 *	2. Perform y*log2(x) = n+y' by simulating multi-precision 
 *	   arithmetic, where |y'|<=0.5.
 *	3. Return x**y = 2**n*exp(y'*log2)
 *
 * Special cases:
 *	1.  (anything) ** 0  is 1
 *	2.  (anything) ** 1  is itself
 *	3a. (anything) ** NAN is NAN except
 *	3b. +1         ** NAN is 1
 *	4.  NAN ** (anything except 0) is NAN
 *	5.  +-(|x| > 1) **  +INF is +INF
 *	6.  +-(|x| > 1) **  -INF is +0
 *	7.  +-(|x| < 1) **  +INF is +0
 *	8.  +-(|x| < 1) **  -INF is +INF
 *	9.  +-1         ** +-INF is 1
 *	10. +0 ** (+anything except 0, NAN)               is +0
 *	11. -0 ** (+anything except 0, NAN, odd integer)  is +0
 *	12. +0 ** (-anything except 0, NAN)               is +INF
 *	13. -0 ** (-anything except 0, NAN, odd integer)  is +INF
 *	14. -0 ** (odd integer) = -( +0 ** (odd integer) )
 *	15. +INF ** (+anything except 0,NAN) is +INF
 *	16. +INF ** (-anything except 0,NAN) is +0
 *	17. -INF ** (anything)  = -0 ** (-anything)
 *	18. (-anything) ** (integer) is (-1)**(integer)*(+anything**integer)
 *	19. (-anything except 0 and inf) ** (non-integer) is NAN
 *
 * Accuracy:
 *	pow(x,y) returns x**y nearly rounded. In particular
 *			pow(integer,integer)
 *	always returns the correct integer provided it is 
 *	representable.
 *
 * Constants :
 * The hexadecimal values are the intended ones for the following 
 * constants. The decimal values may be used, provided that the 
 * compiler will convert from decimal to binary accurately enough 
 * to produce the hexadecimal values shown.
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_pow


double __ieee754_pow(double x, double y)
{
	double z, ax, z_h, z_l, p_h, p_l;
	double y1, t1, t2, r, s, t, u, v, w;
	int32_t i, j, k, yisint, n;
	int32_t hx, hy, ix, iy;
	uint32_t lx, ly;

	static const double bp[] = { 1.0, 1.5 };
	static const double dp_h[] = { 0.0, 5.84962487220764160156e-01 };		/* 0x3FE2B803, 0x40000000 */
	static const double dp_l[] = { 0.0, 1.35003920212974897128e-08 };		/* 0x3E4CFDEB, 0x43CFD006 */
	static const double zero = 0.0;
	static const double one = 1.0;
	static const double two = 2.0;
	static const double two53 = 9007199254740992.0;	/* 0x43400000, 0x00000000 */
	/* poly coefs for (3/2)*(log(x)-2s-2/3*s**3 */
	static const double L1 = 5.99999999999994648725e-01;	/* 0x3FE33333, 0x33333303 */
	static const double L2 = 4.28571428578550184252e-01;	/* 0x3FDB6DB6, 0xDB6FABFF */
	static const double L3 = 3.33333329818377432918e-01;	/* 0x3FD55555, 0x518F264D */
	static const double L4 = 2.72728123808534006489e-01;	/* 0x3FD17460, 0xA91D4101 */
	static const double L5 = 2.30660745775561754067e-01;	/* 0x3FCD864A, 0x93C9DB65 */
	static const double L6 = 2.06975017800338417784e-01;	/* 0x3FCA7E28, 0x4A454EEF */
	static const double P1 = 1.66666666666666019037e-01;	/* 0x3FC55555, 0x5555553E */
	static const double P2 = -2.77777777770155933842e-03;	/* 0xBF66C16C, 0x16BEBD93 */
	static const double P3 = 6.61375632143793436117e-05;	/* 0x3F11566A, 0xAF25DE2C */
	static const double P4 = -1.65339022054652515390e-06;	/* 0xBEBBBD41, 0xC5D26BF1 */
	static const double P5 = 4.13813679705723846039e-08;	/* 0x3E663769, 0x72BEA4D0 */
	static const double lg2 = 6.93147180559945286227e-01;	/* 0x3FE62E42, 0xFEFA39EF */
	static const double lg2_h = 6.93147182464599609375e-01;	/* 0x3FE62E43, 0x00000000 */
	static const double lg2_l = -1.90465429995776804525e-09;	/* 0xBE205C61, 0x0CA86C39 */
	static const double ovt = 8.0085662595372944372e-0017;	/* -(1024-log2(ovfl+.5ulp)) */
	static const double cp = 9.61796693925975554329e-01;	/* 0x3FEEC709, 0xDC3A03FD =2/(3ln2) */
	static const double cp_h = 9.61796700954437255859e-01;	/* 0x3FEEC709, 0xE0000000 =(float)cp */
	static const double cp_l = -7.02846165095275826516e-09;	/* 0xBE3E2FE0, 0x145B01F5 =tail of cp_h */
	static const double ivln2 = 1.44269504088896338700e+00;	/* 0x3FF71547, 0x652B82FE =1/ln2 */
	static const double ivln2_h = 1.44269502162933349609e+00;	/* 0x3FF71547, 0x60000000 =24b 1/ln2 */
	static const double ivln2_l = 1.92596299112661746887e-08;	/* 0x3E54AE0B, 0xF85DDF44 =1/ln2 tail */

	GET_DOUBLE_WORDS(hx, lx, x);
	GET_DOUBLE_WORDS(hy, ly, y);
	ix = hx & IC(0x7fffffff);
	iy = hy & IC(0x7fffffff);

	/* y==zero: x**0 = 1 */
	if ((iy | ly) == 0)
	{
		/* unless x is signaling NaN */
		if (issignaling(x))
			return __builtin_nan("");
		return one;
	}

	/* x|y==NaN return NaN unless x==1 then return 1 */
	if (ix > IC(0x7ff00000) || ((ix == IC(0x7ff00000)) && (lx != 0)) || iy > IC(0x7ff00000) || ((iy == IC(0x7ff00000)) && (ly != 0)))
	{
		if (((ix - IC(0x3ff00000)) | lx) == 0 && !(hx & UC(0x80000000)))
			return one;
		else
			return __builtin_nan("");
	}

	/* determine if y is an odd int when x < 0
	 * yisint = 0   ... y is not an integer
	 * yisint = 1   ... y is an odd int
	 * yisint = 2   ... y is an even int
	 */
	yisint = 0;
	if (hx < 0)
	{
		if (iy >= IC(0x43400000))
			yisint = 2;					/* even integer y */
		else if (iy >= IC(0x3ff00000))
		{
			k = (iy >> IEEE754_DOUBLE_SHIFT) - IEEE754_DOUBLE_BIAS;		/* exponent */
			if (k > IEEE754_DOUBLE_SHIFT)
			{
				j = ly >> (52 - k);
				if ((j << (52 - k)) == (int32_t)ly)
					yisint = 2 - (j & 1);
			} else if (ly == 0)
			{
				j = iy >> (IEEE754_DOUBLE_SHIFT - k);
				if ((j << (IEEE754_DOUBLE_SHIFT - k)) == iy)
					yisint = 2 - (j & 1);
			}
		}
	}

	/* special value of y */
	if (ly == 0)
	{
		if (iy == IC(0x7ff00000))
		{								/* y is +-inf */
			if (((ix - IC(0x3ff00000)) | lx) == 0)
				return one;				/* +-1**+-inf = 1 */
			else if (ix >= IC(0x3ff00000))	/* (|x|>1)**+-inf = inf,0 */
				return (hy >= 0) ? y : zero;
			else						/* (|x|<1)**-,+inf = inf,0 */
				return (hy < 0) ? -y : zero;
		}
		if (iy == IC(0x3ff00000))
		{								/* y is  +-1 */
			if (hy < 0)
				return one / x;
			else
				return x;
		}
		if (hy == IC(0x40000000))
			return x * x;				/* y is  2 */
		if (hy == IC(0x3fe00000))
		{								/* y is  0.5 */
			if (hx >= 0)				/* x >= +0 */
				return __ieee754_sqrt(x);
		}
	}

	ax = __ieee754_fabs(x);
	/* special value of x */
	if (lx == 0)
	{
		if (ix == IC(0x7ff00000) || ix == 0 || ix == IC(0x3ff00000))
		{
			z = ax;						/*x is +-0,+-inf,+-1 */
			if (hy < 0)
				z = one / z;			/* z = (1/|x|) */
			if (hx < 0)
			{
				if (((ix - IC(0x3ff00000)) | yisint) == 0)
				{
					z = (z - z) / (z - z);	/* (-1)**non-int is NaN */
				} else if (yisint == 1)
					z = -z;				/* (x<0)**odd = -(|x|**odd) */
			}
			return z;
		}
	}

	/* (x<0)**(non-int) is NaN */
	if (((((uint32_t) hx >> 31) - 1) | yisint) == 0)
		return (x - x) / (x - x);

	/* |y| is huge */
	if (iy > IC(0x41e00000))
	{									/* if |y| > 2**31 */
		if (iy > IC(0x43f00000))
		{								/* if |y| > 2**64, must o/uflow */
			if (ix <= IC(0x3fefffff))
			{
				if (hy < 0)
				{
					feraiseexcept(FE_OVERFLOW);
					return HUGE_VAL;
				}
				feraiseexcept(FE_UNDERFLOW);
				return 0;
			}
			if (ix >= IC(0x3ff00000))
			{
				if (hy > 0)
				{
					feraiseexcept(FE_OVERFLOW);
					return HUGE_VAL;
				}
				feraiseexcept(FE_UNDERFLOW);
				return 0;
			}
		}
		/* over/underflow if x is not close to one */
		if (ix < IC(0x3fefffff))
		{
			if (hy < 0)
			{
				feraiseexcept(FE_OVERFLOW);
				return HUGE_VAL;
			}
			feraiseexcept(FE_UNDERFLOW);
			return 0;
		}
		if (ix > IC(0x3ff00000))
		{
			if (hy > 0)
			{
				feraiseexcept(FE_OVERFLOW);
				return HUGE_VAL;
			}
			feraiseexcept(FE_UNDERFLOW);
			return 0;
		}
		/* now |1-x| is tiny <= 2**-20, suffice to compute 
		   log(x) by x-x^2/2+x^3/3-x^4/4 */
		t = ax - 1;						/* t has 20 trailing zeros */
		w = (t * t) * (0.5 - t * (0.3333333333333333333333 - t * 0.25));
		u = ivln2_h * t;				/* ivln2_h has 21 sig. bits */
		v = t * ivln2_l - w * ivln2;
		t1 = u + v;
		SET_LOW_WORD(t1, 0);
		t2 = v - (t1 - u);
	} else
	{
		double s2, s_h, s_l, t_h, t_l;

		n = 0;
		/* take care subnormal number */
		if (ix < IC(0x00100000))
		{
			ax *= two53;
			n -= 53;
			GET_HIGH_WORD(ix, ax);
		}
		n += ((ix) >> IEEE754_DOUBLE_SHIFT) - IEEE754_DOUBLE_BIAS;
		j = ix & IC(0x000fffff);
		/* determine interval */
		ix = j | IC(0x3ff00000);			/* normalize ix */
		if (j <= IC(0x3988E))
			k = 0;						/* |x|<sqrt(3/2) */
		else if (j < IC(0xBB67A))
			k = 1;						/* |x|<sqrt(3)   */
		else
		{
			k = 0;
			n += 1;
			ix -= IC(0x00100000);
		}
		SET_HIGH_WORD(ax, ix);

		/* compute s = s_h+s_l = (x-1)/(x+1) or (x-1.5)/(x+1.5) */
		u = ax - bp[k];					/* bp[0]=1.0, bp[1]=1.5 */
		v = one / (ax + bp[k]);
		s = u * v;
		s_h = s;
		SET_LOW_WORD(s_h, 0);
		/* t_h=ax+bp[k] High */
		t_h = zero;
		SET_HIGH_WORD(t_h, ((ix >> 1) | IC(0x20000000)) + IC(0x00080000) + (k << 18));
		t_l = ax - (t_h - bp[k]);
		s_l = v * ((u - s_h * t_h) - s_h * t_l);
		/* compute log(ax) */
		s2 = s * s;
		r = s2 * s2 * (L1 + s2 * (L2 + s2 * (L3 + s2 * (L4 + s2 * (L5 + s2 * L6)))));
		r += s_l * (s_h + s);
		s2 = s_h * s_h;
		t_h = 3.0 + s2 + r;
		SET_LOW_WORD(t_h, 0);
		t_l = r - ((t_h - 3.0) - s2);
		/* u+v = s*(1+...) */
		u = s_h * t_h;
		v = s_l * t_h + t_l * s;
		/* 2/(3log2)*(s+...) */
		p_h = u + v;
		SET_LOW_WORD(p_h, 0);
		p_l = v - (p_h - u);
		z_h = cp_h * p_h;				/* cp_h+cp_l = 2/(3*log2) */
		z_l = cp_l * p_h + p_l * cp + dp_l[k];
		/* log2(ax) = (s+..)*2/(3*log2) = n + dp_h + z_h + z_l */
		t = (double) n;
		t1 = (((z_h + z_l) + dp_h[k]) + t);
		SET_LOW_WORD(t1, 0);
		t2 = z_l - (((t1 - t) - dp_h[k]) - z_h);
	}

	s = one;							/* s (sign of result -ve**odd) = -1 else = 1 */
	if (((((uint32_t) hx >> 31) - 1) | (yisint - 1)) == 0)
		s = -one;						/* (-ve)**(odd int) */

	/* split up y into y1+y2 and compute (y1+y2)*(t1+t2) */
	y1 = y;
	SET_LOW_WORD(y1, 0);
	p_l = (y - y1) * t1 + y * t2;
	p_h = y1 * t1;
	z = p_l + p_h;
	GET_DOUBLE_WORDS(j, i, z);
	if (j >= IC(0x40900000))
	{									/* z >= 1024 */
		if (((j - IC(0x40900000)) | i) != 0)	/* if z > 1024 */
		{
			feraiseexcept(FE_OVERFLOW);
			return copysign(HUGE_VAL, s);
		}
		if (p_l + ovt > z - p_h)
		{
			feraiseexcept(FE_OVERFLOW);
			return copysign(HUGE_VAL, s);
		}
	} else if ((j & IC(0x7fffffff)) >= IC(0x4090cc00))
	{									/* z <= -1075 */
		if (((j - IC(0xc090cc00)) | i) != 0)	/* z < -1075 */
		{
			feraiseexcept(FE_UNDERFLOW);
			return copysign(0.0, s);
		}
		if (p_l <= z - p_h)
		{
			feraiseexcept(FE_UNDERFLOW);
			return copysign(0.0, s);
		}
	}
	/*
	 * compute 2**(p_h+p_l)
	 */
	i = j & IC(0x7fffffff);
	k = (i >> IEEE754_DOUBLE_SHIFT) - IEEE754_DOUBLE_BIAS;
	n = 0;
	if (i > IC(0x3fe00000))
	{									/* if |z| > 0.5, set n = [z+0.5] */
		n = j + (IC(0x00100000) >> (k + 1));
		k = ((n & IC(0x7fffffff)) >> IEEE754_DOUBLE_SHIFT) - IEEE754_DOUBLE_BIAS;	/* new k for n */
		t = zero;
		SET_HIGH_WORD(t, n & ~(UC(0x000fffff) >> k));
		n = ((n & IC(0x000fffff)) | IC(0x00100000)) >> (IEEE754_DOUBLE_SHIFT - k);
		if (j < 0)
			n = -n;
		p_h -= t;
	}
	t = p_l + p_h;
	SET_LOW_WORD(t, 0);
	u = t * lg2_h;
	v = (p_l - (t - p_h)) * lg2 + t * lg2_l;
	z = u + v;
	w = v - (z - u);
	t = z * z;
	t1 = z - t * (P1 + t * (P2 + t * (P3 + t * (P4 + t * P5))));
	r = (z * t1) / (t1 - two) - (w + z * w);
	z = one - (r - z);
	GET_HIGH_WORD(j, z);
	j += (n << IEEE754_DOUBLE_SHIFT);
	if ((j >> IEEE754_DOUBLE_SHIFT) <= 0)
	{
		z = __ieee754_scalbn(z, (int) n);			/* subnormal output */
	} else
	{
		SET_HIGH_WORD(z, j);
	}
	return s * z;
}

#endif


/* wrapper pow */
double __pow(double x, double y)
{
	double z = __ieee754_pow(x, y);

	if (!isfinite(z))
	{
#ifdef __have_fpu_pow
		if (isnan(y) && x == 1.0)
		{
			z = 1.0;
		} else
#endif
		if (_LIB_VERSION != _IEEE_)
		{
			if (isnan(x))
			{
				if (y == 0.0)
					/* pow(NaN,0.0) */
					return __kernel_standard(x, y, z, KMATHERR_POW_NAN);
			} else if (isfinite(x) && isfinite(y))
			{
				if (isnan(z))
				{
					/* pow neg**non-int */
					return __kernel_standard(x, y, z, KMATHERR_POW_NONINT);
				} else if (x == 0.0 && y < 0.0)
				{
					if (signbit(x) && signbit(z))
						/* pow(-0.0,negative) */
						return __kernel_standard(x, y, z, KMATHERR_POW_MINUS);
					else
						/* pow(+0.0,negative) */
						return __kernel_standard(x, y, z, KMATHERR_POW_ZEROMINUS);
				} else
				{
					/* pow overflow */
					return __kernel_standard(x, y, z, KMATHERR_POW_OVERFLOW);
				}
			}
		}
	} else if (z == 0.0 && isfinite(x) && isfinite(y) && _LIB_VERSION != _IEEE_)
	{
		if (x == 0.0)
		{
			if (y == 0.0)
				/* pow(0.0,0.0) */
				return __kernel_standard(x, y, z, KMATHERR_POW_ZERO);
		} else
		{
			/* pow underflow */
			return __kernel_standard(x, y, z, KMATHERR_POW_UNDERFLOW);
		}
	}

	return z;
}


__typeof(__pow) pow __attribute__((weak, alias("__pow")));
#ifdef __NO_LONG_DOUBLE_MATH
long double __powl(long double x, long double y) __attribute__((alias("__pow")));
__typeof(__powl) powl __attribute__((weak, alias("__pow")));
#endif

```

`e_powf.c`:

```c
/* e_powf.c -- float version of e_pow.c.
 * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_pow

float __ieee754_powf(float x, float y)
{
	float z, ax, z_h, z_l, p_h, p_l;
	float y1, t1, t2, r, s, t, u, v, w;
	int32_t i, j, k, yisint, n;
	int32_t hx, hy, ix, iy, is;

	static const float bp[] = { 1.0, 1.5 };
	static const float dp_h[] = { 0.0, 5.84960938e-01 };					/* 0x3f15c000 */
	static const float dp_l[] = { 0.0, 1.56322085e-06 };					/* 0x35d1cfdc */
	static const float zero = 0.0;
	static const float one = 1.0;
	static const float two = 2.0;
	static const float two24 = 16777216.0;					/* 0x4b800000 */
	/* poly coefs for (3/2)*(log(x)-2s-2/3*s**3 */
	static const float L1 = 6.0000002384e-01;				/* 0x3f19999a */
	static const float L2 = 4.2857143283e-01;				/* 0x3edb6db7 */
	static const float L3 = 3.3333334327e-01;				/* 0x3eaaaaab */
	static const float L4 = 2.7272811532e-01;				/* 0x3e8ba305 */
	static const float L5 = 2.3066075146e-01;				/* 0x3e6c3255 */
	static const float L6 = 2.0697501302e-01;				/* 0x3e53f142 */
	static const float P1 = 1.6666667163e-01;				/* 0x3e2aaaab */
	static const float P2 = -2.7777778450e-03;				/* 0xbb360b61 */
	static const float P3 = 6.6137559770e-05;				/* 0x388ab355 */
	static const float P4 = -1.6533901999e-06;				/* 0xb5ddea0e */
	static const float P5 = 4.1381369442e-08;				/* 0x3331bb4c */
	static const float lg2 = 6.9314718246e-01;				/* 0x3f317218 */
	static const float lg2_h = 6.93145752e-01;				/* 0x3f317200 */
	static const float lg2_l = 1.42860654e-06;				/* 0x35bfbe8c */
	static const float ovt = 4.2995665694e-08;				/* -(128-log2(ovfl+.5ulp)) */
	static const float cp = 9.6179670095e-01;				/* 0x3f76384f =2/(3ln2) */
	static const float cp_h = 9.6179199219e-01;				/* 0x3f763800 =head of cp */
	static const float cp_l = 4.7017383622e-06;				/* 0x369dc3a0 =tail of cp_h */
	static const float ivln2 = 1.4426950216e+00;			/* 0x3fb8aa3b =1/ln2 */
	static const float ivln2_h = 1.4426879883e+00;			/* 0x3fb8aa00 =16b 1/ln2 */
	static const float ivln2_l = 7.0526075433e-06;			/* 0x36eca570 =1/ln2 tail */
	
	
	GET_FLOAT_WORD(hx, x);
	GET_FLOAT_WORD(hy, y);
	ix = hx & IC(0x7fffffff);
	iy = hy & IC(0x7fffffff);

	/* y==zero: x**0 = 1 */
	if (FLT_UWORD_IS_ZERO(iy))
	{
		/* unless x is signaling NaN */
		if (issignalingf(x))
			return __builtin_nanf("");
		return one;
	}

	/* x==+-1 */
	if (x == 1.0F)
		return one;
	if (x == -1.0F && isinf(y))
		return one;

	/* +-NaN return x+y */
	if (FLT_UWORD_IS_NAN(ix) || FLT_UWORD_IS_NAN(iy))
		return x + y;

	/* determine if y is an odd int when x < 0
	 * yisint = 0   ... y is not an integer
	 * yisint = 1   ... y is an odd int
	 * yisint = 2   ... y is an even int
	 */
	yisint = 0;
	if (hx < 0)
	{
		if (iy >= IC(0x4b800000))		/* |y| >= 2**24 */
			yisint = 2;					/* even integer y */
		else if (iy >= IC(0x3f800000))	/* |y| >= 2**0 */
		{
			k = (iy >> IEEE754_FLOAT_SHIFT) - IEEE754_FLOAT_BIAS;		/* exponent */
			j = iy >> (IEEE754_FLOAT_SHIFT - k);
			if ((j << (IEEE754_FLOAT_SHIFT - k)) == iy)
				yisint = 2 - (j & 1);
		}
	}

	/* special value of y */
	if (FLT_UWORD_IS_INFINITE(iy))
	{									/* y is +-inf */
		if (ix == IC(0x3f800000))
			return one;					/* +-1**+-inf = 1 */
		else if (ix > IC(0x3f800000))		/* (|x|>1)**+-inf = inf,0 */
			return (hy >= 0) ? y : zero;
		else							/* (|x|<1)**-,+inf = inf,0 */
			return (hy < 0) ? -y : zero;
	}
	if (iy == IC(0x3f800000))
	{									/* y is  +-1 */
		if (hy < 0)
			return one / x;
		else
			return x;
	}
	if (hy == IC(0x40000000))
		return x * x;					/* y is  2 */
	if (hy == IC(0x3f000000))
	{									/* y is  0.5 */
		if (hx >= 0)					/* x >= +0 */
			return __ieee754_sqrtf(x);
	}

	ax = __ieee754_fabsf(x);
	/* special value of x */
	if (FLT_UWORD_IS_INFINITE(ix) || FLT_UWORD_IS_ZERO(ix) || ix == IC(0x3f800000))
	{
		z = ax;							/*x is +-0,+-inf,+-1 */
		if (hy < 0)
			z = one / z;				/* z = (1/|x|) */
		if (hx < 0)
		{
			if (((ix - IC(0x3f800000)) | yisint) == 0)
			{
				z = (z - z) / (z - z);	/* (-1)**non-int is NaN */
			} else if (yisint == 1)
				z = -z;					/* (x<0)**odd = -(|x|**odd) */
		}
		return z;
	}

	/* (x<0)**(non-int) is NaN */
	if (((((uint32_t) hx >> 31) - 1) | yisint) == 0)
		return (x - x) / (x - x);

	/* |y| is huge */
	if (iy > IC(0x4d000000))
	{									/* if |y| > 2**27 */
		/* over/underflow if x is not close to one */
		if (ix < IC(0x3f7ffff8))
		{
			if (hy < 0)
			{
				feraiseexcept(FE_OVERFLOW);
				return HUGE_VALF;
			}
			feraiseexcept(FE_UNDERFLOW);
			return 0;
		}
		if (ix > IC(0x3f800007))
		{
			if (hy > 0)
			{
				feraiseexcept(FE_OVERFLOW);
				return HUGE_VALF;
			}
			feraiseexcept(FE_UNDERFLOW);
			return 0;
		}
		/* now |1-x| is tiny <= 2**-20, suffice to compute
		   log(x) by x-x^2/2+x^3/3-x^4/4 */
		t = ax - 1;						/* t has 20 trailing zeros */
		w = (t * t) * ((float) 0.5 - t * ((float) 0.333333333333 - t * (float) 0.25));
		u = ivln2_h * t;				/* ivln2_h has 16 sig. bits */
		v = t * ivln2_l - w * ivln2;
		t1 = u + v;
		GET_FLOAT_WORD(is, t1);
		SET_FLOAT_WORD(t1, is & UC(0xfffff000));
		t2 = v - (t1 - u);
	} else
	{
		float s2, s_h, s_l, t_h, t_l;

		/* Avoid internal underflow for tiny y.  The exact value
		   of y does not matter if |y| <= 2**-32.  */
		if (iy < IC(0x2f800000))
		{
			SET_FLOAT_WORD(y, (hy & UC(0x80000000)) | UC(0x2f800000));
		}
		n = 0;
		/* take care subnormal number */
		if (FLT_UWORD_IS_SUBNORMAL(ix))
		{
			ax *= two24;
			n -= 24;
			GET_FLOAT_WORD(ix, ax);
		}
		n += ((ix) >> 23) - 0x7f;
		j = ix & IC(0x007fffff);
		/* determine interval */
		ix = j | IC(0x3f800000);		/* normalize ix */
		if (j <= IC(0x1cc471))
			k = 0;						/* |x|<sqrt(3/2) */
		else if (j < IC(0x5db3d7))
			k = 1;						/* |x|<sqrt(3)   */
		else
		{
			k = 0;
			n += 1;
			ix -= IC(0x00800000);
		}
		SET_FLOAT_WORD(ax, ix);

		/* compute s = s_h+s_l = (x-1)/(x+1) or (x-1.5)/(x+1.5) */
		u = ax - bp[k];					/* bp[0]=1.0, bp[1]=1.5 */
		v = one / (ax + bp[k]);
		s = u * v;
		s_h = s;
		GET_FLOAT_WORD(is, s_h);
		SET_FLOAT_WORD(s_h, is & UC(0xfffff000));
		/* t_h=ax+bp[k] High */
		SET_FLOAT_WORD(t_h, ((ix >> 1) | IC(0x20000000)) + IC(0x0040000) + (k << 21));
		t_l = ax - (t_h - bp[k]);
		s_l = v * ((u - s_h * t_h) - s_h * t_l);
		/* compute log(ax) */
		s2 = s * s;
		r = s2 * s2 * (L1 + s2 * (L2 + s2 * (L3 + s2 * (L4 + s2 * (L5 + s2 * L6)))));
		r += s_l * (s_h + s);
		s2 = s_h * s_h;
		t_h = 3.0f + s2 + r;
		GET_FLOAT_WORD(is, t_h);
		SET_FLOAT_WORD(t_h, is & UC(0xfffff000));
		t_l = r - ((t_h - 3.0f) - s2);
		/* u+v = s*(1+...) */
		u = s_h * t_h;
		v = s_l * t_h + t_l * s;
		/* 2/(3log2)*(s+...) */
		p_h = u + v;
		GET_FLOAT_WORD(is, p_h);
		SET_FLOAT_WORD(p_h, is & UC(0xfffff000));
		p_l = v - (p_h - u);
		z_h = cp_h * p_h;				/* cp_h+cp_l = 2/(3*log2) */
		z_l = cp_l * p_h + p_l * cp + dp_l[k];
		/* log2(ax) = (s+..)*2/(3*log2) = n + dp_h + z_h + z_l */
		t = (float) n;
		t1 = (((z_h + z_l) + dp_h[k]) + t);
		GET_FLOAT_WORD(is, t1);
		SET_FLOAT_WORD(t1, is & UC(0xfffff000));
		t2 = z_l - (((t1 - t) - dp_h[k]) - z_h);
	}

	s = one;							/* s (sign of result -ve**odd) = -1 else = 1 */
	if (((((uint32_t) hx >> 31) - 1) | (yisint - 1)) == 0)
		s = -one;						/* (-ve)**(odd int) */

	/* split up y into y1+y2 and compute (y1+y2)*(t1+t2) */
	GET_FLOAT_WORD(is, y);
	SET_FLOAT_WORD(y1, is & UC(0xfffff000));
	p_l = (y - y1) * t1 + y * t2;
	p_h = y1 * t1;
	z = p_l + p_h;
	GET_FLOAT_WORD(j, z);
	i = j & IC(0x7fffffff);
	if (j > 0)
	{
		if (i > FLT_UWORD_EXP_MAX)
		{
			feraiseexcept(FE_OVERFLOW);
			return copysignf(HUGE_VALF, s);
		}
		if (i == FLT_UWORD_EXP_MAX)
			if (p_l + ovt > z - p_h)
			{
				feraiseexcept(FE_OVERFLOW);
				return copysignf(HUGE_VALF, s);
			}
	} else
	{
		if (i > FLT_UWORD_EXP_MIN)
		{
			feraiseexcept(FE_UNDERFLOW);
			return copysignf(0.0f, s);
		}
		if (i == FLT_UWORD_EXP_MIN)
			if (p_l <= z - p_h)
			{
				feraiseexcept(FE_UNDERFLOW);
				return copysignf(0.0f, s);
			}
	}
	/*
	 * compute 2**(p_h+p_l)
	 */
	k = (i >> 23) - 0x7f;

	n = 0;
	if (i > IC(0x3f000000))
	{									/* if |z| > 0.5, set n = [z+0.5] */
		n = j + (IC(0x00800000) >> (k + 1));
		k = ((n & IC(0x7fffffff)) >> 23) - 0x7f;	/* new k for n */
		SET_FLOAT_WORD(t, n & ~(UC(0x007fffff) >> k));
		n = ((n & IC(0x007fffff)) | IC(0x00800000)) >> (23 - k);
		if (j < 0)
			n = -n;
		p_h -= t;
	}
	t = p_l + p_h;
	GET_FLOAT_WORD(is, t);
	SET_FLOAT_WORD(t, is & UC(0xfffff000));
	u = t * lg2_h;
	v = (p_l - (t - p_h)) * lg2 + t * lg2_l;
	z = u + v;
	w = v - (z - u);
	t = z * z;
	t1 = z - t * (P1 + t * (P2 + t * (P3 + t * (P4 + t * P5))));
	r = (z * t1) / (t1 - two) - (w + z * w);
	z = one - (r - z);
	GET_FLOAT_WORD(j, z);
	j += (n << 23);
	if ((j >> 23) <= 0)
	{
		z = __ieee754_scalbnf(z, (int)n);			/* subnormal output */
	} else
	{
		SET_FLOAT_WORD(z, j);
	}
	return s * z;
}

#endif



/* wrapper powf */
float __powf(float x, float y)
{
	float z = __ieee754_powf(x, y);

	if (!isfinite(z))
	{
		if (_LIB_VERSION != _IEEE_)
		{
			if (isnan(x))
			{
				if (y == 0.0f)
					/* pow(NaN,0.0) */
					return __kernel_standard_f(x, y, z, KMATHERRF_POW_NAN);
			} else if (isfinite(x) && isfinite(y))
			{
				if (isnan(z))
				{
					/* pow neg**non-int */
					return __kernel_standard_f(x, y, z, KMATHERRF_POW_NONINT);
				} else if (x == 0.0f && y < 0.0f)
				{
					if (signbit(x) && signbit(z))
						/* pow(-0.0,negative) */
						return __kernel_standard_f(x, y, z, KMATHERRF_POW_MINUS);
					else
						/* pow(+0.0,negative) */
						return __kernel_standard_f(x, y, z, KMATHERRF_POW_ZEROMINUS);
				} else
				{
					/* pow overflow */
					return __kernel_standard_f(x, y, z, KMATHERRF_POW_OVERFLOW);
				}
			}
		}
	} else if (z == 0.0f && isfinite(x) && isfinite(y) && _LIB_VERSION != _IEEE_)
	{
		if (x == 0.0f)
		{
			if (y == 0.0f)
				/* pow(0.0,0.0) */
				return __kernel_standard_f(x, y, z, KMATHERRF_POW_ZERO);
		} else
		{
			/* pow underflow */
			return __kernel_standard_f(x, y, z, KMATHERRF_POW_UNDERFLOW);
		}
	}

	return z;
}

__typeof(__powf) powf __attribute__((weak, alias("__powf")));

```

`e_powi.c`:

```c
/*
 This Software is provided under the Zope Public License (ZPL) Version 2.1.

 Copyright (c) 2009, 2010 by the mingw-w64 project

 See the AUTHORS file for the list of contributors to the mingw-w64 project.

 This license has been certified as open source. It has also been designated
 as GPL compatible by the Free Software Foundation (FSF).

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

   1. Redistributions in source code must retain the accompanying copyright
      notice, this list of conditions, and the following disclaimer.
   2. Redistributions in binary form must reproduce the accompanying
      copyright notice, this list of conditions, and the following disclaimer
      in the documentation and/or other materials provided with the
      distribution.
   3. Names of the copyright holders must not be used to endorse or promote
      products derived from this software without prior written permission
      from the copyright holders.
   4. The right to distribute this software or to use it for any purpose does
      not give you the right to use Servicemarks (sm) or Trademarks (tm) of
      the copyright holders.  Use of them is covered by separate agreement
      with the copyright holders.
   5. If any files are modified, you must cause the modified files to carry
      prominent notices stating that you changed the files and the date of
      any change.

 Disclaimer

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY EXPRESSED
 OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
 EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, 
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/* IEEE 754 - Elementary Functions - Special Cases
 * powi (x, +/-0) is 1 for any x (even a zero, quiet NaN, or infinity)
 * powi (+1, y) is 1 for any y (even a quiet NaN)
 * powi (+/-0, y) is +/-oo and signals the divideByZero exception for y an odd integer < 0
 * powi (+/-0, y) is +oo and signals the divideByZero exception for finite y < 0 and not an odd integer
 * powi (+/-0, y) is +/-0 for finite y > 0 an odd integer
 * powi (+/-0, y) is +0 for finite y > 0 and not an odd integer
 powi (-inf, y) = +0 for y<0 and not an odd integer
 powi (-inf, y) = -inf for y an odd integer > 0
 powi (-inf, y) = +inf for y>0 and not an odd integer
 powi (+/-inf, y) is +/-0 with no exception for y an odd integer < 0
 powi (+/-inf, y) is +0 with no exception for finite y < 0 and not an odd integer
 powi (+/-inf, y) is +/-inf with no exception for finite y > 0 an odd integer
 powi (+/-inf, y) is +inf with no exception for finite y > 0 and not an odd integer
 powi (x, y) signals the invalid operation exception for finite x < 0 and finite non-integer y.
 
 For x /= 0: lim y->oo (1/x)^y results as: for |x| < 1 that sgn(x)*0 and for |x| > 0 that sgn(x)*Infinity

*/

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

double __ieee754_powi (double x, int y)
{
	int x_class = fpclassify(x);
	int odd_y = y & 1;
	double d, rslt;

	if (y == 0 || x == 1.0)
	{
		/* unless x is signaling NaN */
		if (issignaling(x))
			return __builtin_nan("");
		return 1.0;
	}

	if (x_class == FP_NAN)
	{
		rslt = signbit(x) ? -__builtin_nan("") : __builtin_nan("");
		return rslt;
	}
	if (x_class == FP_ZERO)
	{
		if (y >= 0)
		{
			if (!odd_y || !signbit(x))
				return 0.0;
			return -0.0;
		}

		if (!odd_y || !signbit(x))
			return HUGE_VAL;
		return signbit(x) ? -HUGE_VAL : HUGE_VAL;
	}
	if (x_class == FP_INFINITE)
	{
		/* pow( -inf, y) = +0 for y<0 and not an odd integer,  */
		if (signbit(x) && y < 0 && !odd_y)
			return 0.0;
		/* pow( -inf, y) = -inf for y an odd integer > 0.  */
		if (signbit(x) && y >= 0 && odd_y)
			return -HUGE_VAL;
		/* pow( -inf, y) = +inf for y>0 and not an odd integer.  */
		if (signbit(x) && y >= 0 && !odd_y)
			return HUGE_VAL;
		/* pow (+/-inf, y) is +/-0 with no exception for y an odd integer < 0. */
		if (y < 0)
		{
			/* pow (+/-inf, y) is +0 with no exception for finite y < 0 and not an odd integer.  */
			return (odd_y && signbit(x)) ? -0.0 : 0.0;
		}
		/* pow (+/-inf, y) is +/-inf with no exception for finite y > 0 an odd integer.  */
		/* pow (+/-inf, y) is +inf with no exception for finite y > 0 and not an odd integer.  */
		return (odd_y && signbit(x)) ? -HUGE_VAL : HUGE_VAL;
	}

	d = __ieee754_fabs(x);

	if (y < 0)
	{
		d = 1.0 / d;
		y = -y;
	}

	if (!y)
		rslt = 1.0;
	else if (y == 1)
		rslt = d;
	else
	{
		unsigned int u = (unsigned int) y;

		rslt = ((u & 1) != 0) ? d : 1.0;
		u >>= 1;
		do
		{
			d *= d;
			if ((u & 1) != 0)
				rslt *= d;
			u >>= 1;
		} while (u > 0);
	}
	if (signbit(x) && odd_y)
		rslt = -rslt;
	return rslt;
}

```

`e_powif.c`:

```c
/*
 This Software is provided under the Zope Public License (ZPL) Version 2.1.

 Copyright (c) 2009, 2010 by the mingw-w64 project

 See the AUTHORS file for the list of contributors to the mingw-w64 project.

 This license has been certified as open source. It has also been designated
 as GPL compatible by the Free Software Foundation (FSF).

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

   1. Redistributions in source code must retain the accompanying copyright
      notice, this list of conditions, and the following disclaimer.
   2. Redistributions in binary form must reproduce the accompanying
      copyright notice, this list of conditions, and the following disclaimer
      in the documentation and/or other materials provided with the
      distribution.
   3. Names of the copyright holders must not be used to endorse or promote
      products derived from this software without prior written permission
      from the copyright holders.
   4. The right to distribute this software or to use it for any purpose does
      not give you the right to use Servicemarks (sm) or Trademarks (tm) of
      the copyright holders.  Use of them is covered by separate agreement
      with the copyright holders.
   5. If any files are modified, you must cause the modified files to carry
      prominent notices stating that you changed the files and the date of
      any change.

 Disclaimer

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY EXPRESSED
 OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
 EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, 
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/* IEEE 754 - Elementary Functions - Special Cases
 * powi (x, +/-0) is 1 for any x (even a zero, quiet NaN, or infinity)
 * powi (+1, y) is 1 for any y (even a quiet NaN)
 * powi (+/-0, y) is +/-oo and signals the divideByZero exception for y an odd integer < 0
 * powi (+/-0, y) is +oo and signals the divideByZero exception for finite y < 0 and not an odd integer
 * powi (+/-0, y) is +/-0 for finite y > 0 an odd integer
 * powi (+/-0, y) is +0 for finite y > 0 and not an odd integer
 powi (-inf, y) = +0 for y<0 and not an odd integer
 powi (-inf, y) = -inf for y an odd integer > 0
 powi (-inf, y) = +inf for y>0 and not an odd integer
 powi (+/-inf, y) is +/-0 with no exception for y an odd integer < 0
 powi (+/-inf, y) is +0 with no exception for finite y < 0 and not an odd integer
 powi (+/-inf, y) is +/-inf with no exception for finite y > 0 an odd integer
 powi (+/-inf, y) is +inf with no exception for finite y > 0 and not an odd integer
 powi (x, y) signals the invalid operation exception for finite x < 0 and finite non-integer y.
 
 For x /= 0: lim y->oo (1/x)^y results as: for |x| < 1 that sgn(x)*0 and for |x| > 0 that sgn(x)*Infinity

*/

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

float __ieee754_powif (float x, int y)
{
	int x_class = fpclassify(x);
	int odd_y = y & 1;
	float d, rslt;

	if (y == 0 || x == 1.0F)
	{
		/* unless x is signaling NaN */
		if (issignalingf(x))
			return __builtin_nanf("");
		return 1.0F;
	}

	if (x_class == FP_NAN)
	{
		rslt = signbit(x) ? -__builtin_nanf("") : __builtin_nanf("");
		return rslt;
	}
	if (x_class == FP_ZERO)
	{
		if (y >= 0)
		{
			if (!odd_y || !signbit(x))
				return 0.0F;
			return -0.0F;
		}

		if (!odd_y || !signbit(x))
			return HUGE_VALF;
		return signbit(x) ? -HUGE_VALF : HUGE_VALF;
	}
	if (x_class == FP_INFINITE)
	{
		/* pow( -inf, y) = +0 for y<0 and not an odd integer,  */
		if (signbit(x) && y < 0 && !odd_y)
			return 0.0F;
		/* pow( -inf, y) = -inf for y an odd integer > 0.  */
		if (signbit(x) && y >= 0 && odd_y)
			return -HUGE_VALF;
		/* pow( -inf, y) = +inf for y>0 and not an odd integer.  */
		if (signbit(x) && y >= 0 && !odd_y)
			return HUGE_VALF;
		/* pow (+/-inf, y) is +/-0 with no exception for y an odd integer < 0. */
		if (y < 0)
		{
			/* pow (+/-inf, y) is +0 with no exception for finite y < 0 and not an odd integer.  */
			return (odd_y && signbit(x)) ? -0.0F : 0.0F;
		}
		/* pow (+/-inf, y) is +/-inf with no exception for finite y > 0 an odd integer.  */
		/* pow (+/-inf, y) is +inf with no exception for finite y > 0 and not an odd integer.  */
		return (odd_y && signbit(x)) ? -HUGE_VALF : HUGE_VALF;
	}

	d = __ieee754_fabsf(x);

	if (y < 0)
	{
		d = 1.0F / d;
		y = -y;
	}

	if (!y)
		rslt = 1.0F;
	else if (y == 1)
		rslt = d;
	else
	{
		unsigned int u = (unsigned int) y;

		rslt = ((u & 1) != 0) ? d : 1.0F;
		u >>= 1;
		do
		{
			d *= d;
			if ((u & 1) != 0)
				rslt *= d;
			u >>= 1;
		} while (u > 0);
	}
	if (signbit(x) && odd_y)
		rslt = -rslt;
	return rslt;
}

```

`e_powil.c`:

```c
/*
 This Software is provided under the Zope Public License (ZPL) Version 2.1.

 Copyright (c) 2009, 2010 by the mingw-w64 project

 See the AUTHORS file for the list of contributors to the mingw-w64 project.

 This license has been certified as open source. It has also been designated
 as GPL compatible by the Free Software Foundation (FSF).

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

   1. Redistributions in source code must retain the accompanying copyright
      notice, this list of conditions, and the following disclaimer.
   2. Redistributions in binary form must reproduce the accompanying
      copyright notice, this list of conditions, and the following disclaimer
      in the documentation and/or other materials provided with the
      distribution.
   3. Names of the copyright holders must not be used to endorse or promote
      products derived from this software without prior written permission
      from the copyright holders.
   4. The right to distribute this software or to use it for any purpose does
      not give you the right to use Servicemarks (sm) or Trademarks (tm) of
      the copyright holders.  Use of them is covered by separate agreement
      with the copyright holders.
   5. If any files are modified, you must cause the modified files to carry
      prominent notices stating that you changed the files and the date of
      any change.

 Disclaimer

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY EXPRESSED
 OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
 EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, 
 OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/* IEEE 754 - Elementary Functions - Special Cases
 * powi (x, +/-0) is 1 for any x (even a zero, quiet NaN, or infinity)
 * powi (+1, y) is 1 for any y (even a quiet NaN)
 * powi (+/-0, y) is +/-oo and signals the divideByZero exception for y an odd integer < 0
 * powi (+/-0, y) is +oo and signals the divideByZero exception for finite y < 0 and not an odd integer
 * powi (+/-0, y) is +/-0 for finite y > 0 an odd integer
 * powi (+/-0, y) is +0 for finite y > 0 and not an odd integer
 powi (-inf, y) = +0 for y<0 and not an odd integer
 powi (-inf, y) = -inf for y an odd integer > 0
 powi (-inf, y) = +inf for y>0 and not an odd integer
 powi (+/-inf, y) is +/-0 with no exception for y an odd integer < 0
 powi (+/-inf, y) is +0 with no exception for finite y < 0 and not an odd integer
 powi (+/-inf, y) is +/-inf with no exception for finite y > 0 an odd integer
 powi (+/-inf, y) is +inf with no exception for finite y > 0 and not an odd integer
 powi (x, y) signals the invalid operation exception for finite x < 0 and finite non-integer y.
 
 For x /= 0: lim y->oo (1/x)^y results as: for |x| < 1 that sgn(x)*0 and for |x| > 0 that sgn(x)*Infinity

*/

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

long double __ieee754_powil (long double x, int y)
{
	int x_class = fpclassify(x);
	int odd_y = y & 1;
	long double d, rslt;

	if (y == 0 || x == 1.0L)
	{
		/* unless x is signaling NaN */
		if (issignalingl(x))
			return __builtin_nanl("");
		return 1.0L;
	}

	if (x_class == FP_NAN)
	{
		rslt = signbit(x) ? -__builtin_nanl("") : __builtin_nanl("");
		return rslt;
	}
	if (x_class == FP_ZERO)
	{
		if (y >= 0)
		{
			if (!odd_y || !signbit(x))
				return 0.0L;
			return -0.0L;
		}

		if (!odd_y || !signbit(x))
			return HUGE_VALL;
		return signbit(x) ? -HUGE_VALL : HUGE_VALL;
	}
	if (x_class == FP_INFINITE)
	{
		/* pow( -inf, y) = +0 for y<0 and not an odd integer,  */
		if (signbit(x) && y < 0 && !odd_y)
			return 0.0L;
		/* pow( -inf, y) = -inf for y an odd integer > 0.  */
		if (signbit(x) && y >= 0 && odd_y)
			return -HUGE_VALL;
		/* pow( -inf, y) = +inf for y>0 and not an odd integer.  */
		if (signbit(x) && y >= 0 && !odd_y)
			return HUGE_VALL;
		/* pow (+/-inf, y) is +/-0 with no exception for y an odd integer < 0. */
		if (y < 0)
		{
			/* pow (+/-inf, y) is +0 with no exception for finite y < 0 and not an odd integer.  */
			return (odd_y && signbit(x)) ? -0.0L : 0.0L;
		}
		/* pow (+/-inf, y) is +/-inf with no exception for finite y > 0 an odd integer.  */
		/* pow (+/-inf, y) is +inf with no exception for finite y > 0 and not an odd integer.  */
		return (odd_y && signbit(x)) ? -HUGE_VALL : HUGE_VALL;
	}

	d = __ieee754_fabsl(x);

	if (y < 0)
	{
		d = 1.0L / d;
		y = -y;
	}

	if (!y)
		rslt = 1.0L;
	else if (y == 1)
		rslt = d;
	else
	{
		unsigned int u = (unsigned int) y;

		rslt = ((u & 1) != 0) ? d : 1.0L;
		u >>= 1;
		do
		{
			d *= d;
			if ((u & 1) != 0)
				rslt *= d;
			u >>= 1;
		} while (u > 0);
	}
	if (signbit(x) && odd_y)
		rslt = -rslt;
	return rslt;
}

```

`e_powl.c`:

```c
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/* Expansions and modifications for 128-bit long double are
   Copyright (C) 2001 Stephen L. Moshier <moshier@na-net.ornl.gov>
   and are incorporated herein by permission of the author.  The author
   reserves the right to distribute this material elsewhere under different
   copying permissions.  These modifications are distributed here under
   the following terms:

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, see
    <http://www.gnu.org/licenses/>.  */

/* __ieee754_powl(x,y) return x**y
 *
 *		      n
 * Method:  Let x =  2   * (1+f)
 *	1. Compute and return log2(x) in two pieces:
 *		log2(x) = w1 + w2,
 *	   where w1 has 113-53 = 60 bit trailing zeros.
 *	2. Perform y*log2(x) = n+y' by simulating multi-precision
 *	   arithmetic, where |y'|<=0.5.
 *	3. Return x**y = 2**n*exp(y'*log2)
 *
 * Special cases:
 *	1.  (anything) ** 0  is 1
 *	2.  (anything) ** 1  is itself
 *	3a. (anything) ** NAN is NAN except
 *	3b. +1         ** NAN is 1
 *	4.  NAN ** (anything except 0) is NAN
 *	5.  +-(|x| > 1) **  +INF is +INF
 *	6.  +-(|x| > 1) **  -INF is +0
 *	7.  +-(|x| < 1) **  +INF is +0
 *	8.  +-(|x| < 1) **  -INF is +INF
 *	9.  +-1         ** +-INF is 1
 *	10. +0 ** (+anything except 0, NAN)               is +0
 *	11. -0 ** (+anything except 0, NAN, odd integer)  is +0
 *	12. +0 ** (-anything except 0, NAN)               is +INF
 *	13. -0 ** (-anything except 0, NAN, odd integer)  is +INF
 *	14. -0 ** (odd integer) = -( +0 ** (odd integer) )
 *	15. +INF ** (+anything except 0,NAN) is +INF
 *	16. +INF ** (-anything except 0,NAN) is +0
 *	17. -INF ** (anything)  = -0 ** (-anything)
 *	18. (-anything) ** (integer) is (-1)**(integer)*(+anything**integer)
 *	19. (-anything except 0 and inf) ** (non-integer) is NAN
 *
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

#ifndef __have_fpu_pow

long double __ieee754_powl(long double x, long double y)
{
	int x_class = fpclassify(x);
	int y_class = fpclassify(y);
	int odd_y;
	long double d, rslt;
	int32_t dexp, yexp;
	
	if (y_class == FP_ZERO || x == 1.0L)
	{
		/* unless x is signaling NaN */
		if (issignalingl(x))
			return __builtin_nanl("");
		return 1.0L;
	}

	if (x_class == FP_NAN || y_class == FP_NAN)
	{
		rslt = signbit(x) ? -__builtin_nanl("") : __builtin_nanl("");
		return rslt;
	}
	if (x_class == FP_ZERO)
	{
		if (y_class == FP_INFINITE)
			return signbit(y) ? HUGE_VALL : 0.0L;

		if (signbit(x) && __ieee754_truncl(y) != y)
		{
			return signbit(y) ? (1.0 / -x) : 0.0L;
		}
		d = __ieee754_scalbnl(y, -1);
		odd_y = __ieee754_truncl(d) != d;
		if (!signbit(y))
		{
			if (!odd_y || !signbit(x))
				return 0.0L;
			return -0.0L;
		}

		feraiseexcept(FE_DIVBYZERO);
		if (!odd_y || !signbit(x))
			return HUGE_VALL;
		return signbit(x) ? -HUGE_VALL : HUGE_VALL;
	}
	if (y_class == FP_INFINITE)
	{
		long double a_x;

		if (x_class == FP_INFINITE)
			return (signbit(y) ? 0.0L : HUGE_VALL);
		a_x = (signbit(x) ? -x : x);
		if (a_x == 1.0L)
			return 1.0L;
		if (a_x > 1.0)
			return (signbit(y) == 0 ? HUGE_VALL : 0.0L);
		return (!signbit(y) ? 0.0L : HUGE_VALL);
	}
	if (x_class == FP_INFINITE)
	{
		/* pow (x, y) signals the invalid operation exception for finite x < 0 and finite non-integer y.  */
		if (signbit(x) && __ieee754_truncl(y) != y)
		{
			return signbit(y) ? 1.0 / -x : -x;
		}
		d = __ieee754_scalbnl(y, -1);
		odd_y = __ieee754_truncl(d) != d;
		/* pow( -inf, y) = +0 for y<0 and not an odd integer,  */
		if (signbit(x) && signbit(y) && !odd_y)
			return 0.0L;
		/* pow( -inf, y) = -inf for y an odd integer > 0.  */
		if (signbit(x) && !signbit(y) && odd_y)
			return -HUGE_VALL;
		/* pow( -inf, y) = +inf for y>0 and not an odd integer.  */
		if (signbit(x) && !signbit(y) && !odd_y)
			return HUGE_VALL;
		/* pow (+/-inf, y) is +/-0 with no exception for y an odd integer < 0. */
		if (signbit(y))
		{
			/* pow (+/-inf, y) is +0 with no exception for finite y < 0 and not an odd integer.  */
			return (odd_y && signbit(x)) ? -0.0L : 0.0L;
		}
		/* pow (+/-inf, y) is +/-inf with no exception for finite y > 0 an odd integer.  */
		/* pow (+/-inf, y) is +inf with no exception for finite y > 0 and not an odd integer.  */
		return (odd_y && signbit(x) ? -HUGE_VALL : HUGE_VALL);
	}

	d = __ieee754_truncl(y);
	if (d != y)
	{
		if (signbit(x))
		{
			return -__builtin_nanl("");
		}
		if (y == 0.5L)
		{
			return __ieee754_sqrtl(x);
		}
	} else if ((d <= (long double) INT_MAX && d >= (long double) INT_MIN))
	{
		return __ieee754_powil(x, (int) y);
	}
	/* As exp already checks for minlog and maxlog no further checks are necessary.  */
	d = __ieee754_log2l(__ieee754_fabsl(x));
	dexp = __ieee754_ilogbl(d);
	yexp = __ieee754_ilogbl(y);
	if (dexp > 0 && (yexp + dexp) >= LDBL_MAX_EXP)
	{
		dexp = __ieee754_ilogbl(x);
		if ((dexp < 0 && y < 0.0L) || (dexp > 0 && y > 0.0L))
		{
			feraiseexcept(FE_OVERFLOW);
			rslt = HUGE_VALL;
		} else
		{
			feraiseexcept(FE_UNDERFLOW);
			rslt = 0;
		}
	} else if (dexp < 0 && y > 0.0L && (-yexp + dexp) < LDBL_MIN_EXP)
	{
		feraiseexcept(FE_UNDERFLOW);
		if ((-yexp + dexp) >= (LDBL_MIN_EXP - LDBL_MANT_DIG))
			rslt = 1.0L;
		else
			rslt = 0;
	} else
	{
		rslt = __ieee754_exp2l(y * d);
	}
	
	if (signbit(x))
	{
		y = __ieee754_scalbnl(y, -1);
		if (y != __ieee754_truncl(y))
			rslt = -rslt;
	}
	return rslt;
}

#endif

/* wrapper powl */
long double __powl(long double x, long double y)
{
	long double z = __ieee754_powl(x, y);

	if (!isfinite(z))
	{
		if (_LIB_VERSION != _IEEE_)
		{
			if (isnan(x))
			{
				if (y == 0.0L)
					/* pow(NaN,0.0) */
					return __kernel_standard_l(x, y, z, KMATHERRL_POW_NAN);
			} else if (isfinite(x) && isfinite(y))
			{
				if (isnan(z))
				{
					/* pow neg**non-int */
					return __kernel_standard_l(x, y, z, KMATHERRL_POW_NONINT);
				} else if (x == 0.0L && y < 0.0L)
				{
					if (signbit(x) && signbit(z))
						/* pow(-0.0,negative) */
						return __kernel_standard_l(x, y, z, KMATHERRL_POW_MINUS);
					else
						/* pow(+0.0,negative) */
						return __kernel_standard_l(x, y, z, KMATHERRL_POW_ZEROMINUS);
				} else
				{
					/* pow overflow */
					return __kernel_standard_l(x, y, z, KMATHERRL_POW_OVERFLOW);
				}
			}
		}
	} else if (z == 0.0L && isfinite(x) && isfinite(y) && _LIB_VERSION != _IEEE_)
	{
		if (x == 0.0L)
		{
			if (y == 0.0L)
				/* pow(0.0,0.0) */
				return __kernel_standard_l(x, y, z, KMATHERRL_POW_ZERO);
		} else
		{
			/* pow underflow */
			return __kernel_standard_l(x, y, z, KMATHERRL_POW_UNDERFLOW);
		}
	}

	return z;
}

__typeof(__powl) powl __attribute__((weak, alias("__powl")));

#endif

```

`e_rem_pio2.c`:

```c
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/* __ieee754_rem_pio2(x,y)
 *
 * return the remainder of x rem pi/2 in y[0]+y[1]
 * use __kernel_rem_pio2()
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif


int32_t __ieee754_rem_pio2(double x, double *y)
{
	double z, w, t, r, fn;
	double tx[3];
	int32_t e0, i, j, nx, n, ix, hx;
	uint32_t low;

	static const int32_t npio2_hw[] = {
		IC(0x3FF921FB), IC(0x400921FB), IC(0x4012D97C), IC(0x401921FB), IC(0x401F6A7A), IC(0x4022D97C),
		IC(0x4025FDBB), IC(0x402921FB), IC(0x402C463A), IC(0x402F6A7A), IC(0x4031475C), IC(0x4032D97C),
		IC(0x40346B9C), IC(0x4035FDBB), IC(0x40378FDB), IC(0x403921FB), IC(0x403AB41B), IC(0x403C463A),
		IC(0x403DD85A), IC(0x403F6A7A), IC(0x40407E4C), IC(0x4041475C), IC(0x4042106C), IC(0x4042D97C),
		IC(0x4043A28C), IC(0x40446B9C), IC(0x404534AC), IC(0x4045FDBB), IC(0x4046C6CB), IC(0x40478FDB),
		IC(0x404858EB), IC(0x404921FB)
	};

	/*
	 * invpio2:  53 bits of 2/pi
	 * pio2_1:   first  33 bit of pi/2
	 * pio2_1t:  pi/2 - pio2_1
	 * pio2_2:   second 33 bit of pi/2
	 * pio2_2t:  pi/2 - (pio2_1+pio2_2)
	 * pio2_3:   third  33 bit of pi/2
	 * pio2_3t:  pi/2 - (pio2_1+pio2_2+pio2_3)
	 */

	static const double zero = 0.00000000000000000000e+00;	/* 0x00000000, 0x00000000 */
	static const double half = 5.00000000000000000000e-01;	/* 0x3FE00000, 0x00000000 */
	static const double two24 = 1.67772160000000000000e+07;	/* 0x41700000, 0x00000000 */
	static const double invpio2 = 6.36619772367581382433e-01;	/* 0x3FE45F30, 0x6DC9C883 */
	static const double pio2_1 = 1.57079632673412561417e+00;	/* 0x3FF921FB, 0x54400000 */
	static const double pio2_1t = 6.07710050650619224932e-11;	/* 0x3DD0B461, 0x1A626331 */
	static const double pio2_2 = 6.07710050630396597660e-11;	/* 0x3DD0B461, 0x1A600000 */
	static const double pio2_2t = 2.02226624879595063154e-21;	/* 0x3BA3198A, 0x2E037073 */
	static const double pio2_3 = 2.02226624871116645580e-21;	/* 0x3BA3198A, 0x2E000000 */
	static const double pio2_3t = 8.47842766036889956997e-32;	/* 0x397B839A, 0x252049C1 */

	GET_HIGH_WORD(hx, x);				/* high word of x */
	ix = hx & IC(0x7fffffff);
	if (ix <= IC(0x3fe921fb))			/* |x| ~<= pi/4 , no need for reduction */
	{
		y[0] = x;
		y[1] = 0;
		return 0;
	}

	if (ix < IC(0x4002d97c))
	{									/* |x| < 3pi/4, special case with n=+-1 */
		if (hx > 0)
		{
			z = x - pio2_1;
			if (ix != IC(0x3ff921fb))
			{							/* 33+53 bit pi is good enough */
				y[0] = z - pio2_1t;
				y[1] = (z - y[0]) - pio2_1t;
			} else
			{							/* near pi/2, use 33+33+53 bit pi */
				z -= pio2_2;
				y[0] = z - pio2_2t;
				y[1] = (z - y[0]) - pio2_2t;
			}
			return 1;
		} else
		{								/* negative x */
			z = x + pio2_1;
			if (ix != IC(0x3ff921fb))
			{							/* 33+53 bit pi is good enough */
				y[0] = z + pio2_1t;
				y[1] = (z - y[0]) + pio2_1t;
			} else
			{							/* near pi/2, use 33+33+53 bit pi */
				z += pio2_2;
				y[0] = z + pio2_2t;
				y[1] = (z - y[0]) + pio2_2t;
			}
			return -1;
		}
	}

	if (ix <= IC(0x413921fb))
	{									/* |x| ~<= 2^19*(pi/2), medium size */
		t = __ieee754_fabs(x);
		n = (int32_t) (t * invpio2 + half);
		fn = (double) n;
		r = t - fn * pio2_1;
		w = fn * pio2_1t;				/* 1st round good to 85 bit */
		if (n < 32 && ix != npio2_hw[n - 1])
		{
			y[0] = r - w;				/* quick check no cancellation */
		} else
		{
			uint32_t high;

			j = ix >> IEEE754_DOUBLE_SHIFT;
			y[0] = r - w;
			GET_HIGH_WORD(high, y[0]);
			i = j - ((high >> IEEE754_DOUBLE_SHIFT) & IEEE754_DOUBLE_MAXEXP);
			if (i > 16)
			{							/* 2nd iteration needed, good to 118 */
				t = r;
				w = fn * pio2_2;
				r = t - w;
				w = fn * pio2_2t - ((t - r) - w);
				y[0] = r - w;
				GET_HIGH_WORD(high, y[0]);
				i = j - ((high >> IEEE754_DOUBLE_SHIFT) & IEEE754_DOUBLE_MAXEXP);
				if (i > 49)
				{						/* 3rd iteration need, 151 bits acc */
					t = r;				/* will cover all possible cases */
					w = fn * pio2_3;
					r = t - w;
					w = fn * pio2_3t - ((t - r) - w);
					y[0] = r - w;
				}
			}
		}
		y[1] = (r - y[0]) - w;
		if (hx < 0)
		{
			y[0] = -y[0];
			y[1] = -y[1];
			return -n;
		} else
			return n;
	}

	/*
	 * all other (large) arguments
	 */
	if (ix >= IC(0x7ff00000))
	{									/* x is inf or NaN */
		y[0] = y[1] = x - x;
		return 0;
	}
	/* set z = scalbn(|x|,ilogb(x)-23) */
	GET_LOW_WORD(low, x);
	e0 = (ix >> IEEE754_DOUBLE_SHIFT) - (IEEE754_DOUBLE_BIAS + 23);			/* e0 = ilogb(z)-23; */
	INSERT_WORDS(z, ix - (e0 << IEEE754_DOUBLE_SHIFT), low);
	for (i = 0; i < 2; i++)
	{
		tx[i] = (double) ((int32_t) (z));
		z = (z - tx[i]) * two24;
	}
	tx[2] = z;
	nx = 3;
	while (tx[nx - 1] == zero)
		nx--;							/* skip zero term */
	n = __kernel_rem_pio2(tx, y, e0, nx, 2);
	if (hx < 0)
	{
		y[0] = -y[0];
		y[1] = -y[1];
		return -n;
	}
	return n;
}

```

`e_rem_pio2f.c`:

```c
/* e_rem_pio2f.c -- float version of e_rem_pio2.c
 * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/* __ieee754_rem_pio2f(x,y)
 *
 * return the remainder of x rem pi/2 in y[0]+y[1]
 * use __kernel_rem_pio2f()
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif


int32_t __ieee754_rem_pio2f(float x, float *y)
{
	float z, w, t, r, fn;
	float tx[3];
	int32_t e0, i, j, nx, n, ix, hx;

	/* This array is like the one in e_rem_pio2.c, but the numbers are
	   single precision and the last 8 bits are forced to 0.  */
	static const int32_t npio2_hw[] = {
		IC(0x3fc90f00), IC(0x40490f00), IC(0x4096cb00), IC(0x40c90f00), IC(0x40fb5300), IC(0x4116cb00),
		IC(0x412fed00), IC(0x41490f00), IC(0x41623100), IC(0x417b5300), IC(0x418a3a00), IC(0x4196cb00),
		IC(0x41a35c00), IC(0x41afed00), IC(0x41bc7e00), IC(0x41c90f00), IC(0x41d5a000), IC(0x41e23100),
		IC(0x41eec200), IC(0x41fb5300), IC(0x4203f200), IC(0x420a3a00), IC(0x42108300), IC(0x4216cb00),
		IC(0x421d1400), IC(0x42235c00), IC(0x4229a500), IC(0x422fed00), IC(0x42363600), IC(0x423c7e00),
		IC(0x4242c700), IC(0x42490f00)
	};
	
	/*
	 * invpio2:  24 bits of 2/pi
	 * pio2_1:   first  17 bit of pi/2
	 * pio2_1t:  pi/2 - pio2_1
	 * pio2_2:   second 17 bit of pi/2
	 * pio2_2t:  pi/2 - (pio2_1+pio2_2)
	 * pio2_3:   third  17 bit of pi/2
	 * pio2_3t:  pi/2 - (pio2_1+pio2_2+pio2_3)
	 */
	
	static const float zero = 0.0000000000e+00;	/* 0x00000000 */
	static const float half = 5.0000000000e-01;			/* 0x3f000000 */
	static const float two8 = 2.5600000000e+02;			/* 0x43800000 */
	static const float invpio2 = 6.3661980629e-01;			/* 0x3f22f984 */
	static const float pio2_1 = 1.5707855225e+00;			/* 0x3fc90f80 */
	static const float pio2_1t = 1.0804334124e-05;			/* 0x37354443 */
	static const float pio2_2 = 1.0804273188e-05;			/* 0x37354400 */
	static const float pio2_2t = 6.0770999344e-11;			/* 0x2e85a308 */
	static const float pio2_3 = 6.0770943833e-11;			/* 0x2e85a300 */
	static const float pio2_3t = 6.1232342629e-17;			/* 0x248d3132 */

	GET_FLOAT_WORD(hx, x);
	ix = hx & IC(0x7fffffff);
	if (ix <= IC(0x3f490fd8))				/* |x| ~<= pi/4 , no need for reduction */
	{
		y[0] = x;
		y[1] = 0;
		return 0;
	}
	if (ix < IC(0x4016cbe4))
	{									/* |x| < 3pi/4, special case with n=+-1 */
		if (hx > 0)
		{
			z = x - pio2_1;
			if ((ix & IC(0xfffffff0)) != IC(0x3fc90fd0))
			{							/* 24+24 bit pi OK */
				y[0] = z - pio2_1t;
				y[1] = (z - y[0]) - pio2_1t;
			} else
			{							/* near pi/2, use 24+24+24 bit pi */
				z -= pio2_2;
				y[0] = z - pio2_2t;
				y[1] = (z - y[0]) - pio2_2t;
			}
			return 1;
		} else
		{								/* negative x */
			z = x + pio2_1;
			if ((ix & IC(0xfffffff0)) != IC(0x3fc90fd0))
			{							/* 24+24 bit pi OK */
				y[0] = z + pio2_1t;
				y[1] = (z - y[0]) + pio2_1t;
			} else
			{							/* near pi/2, use 24+24+24 bit pi */
				z += pio2_2;
				y[0] = z + pio2_2t;
				y[1] = (z - y[0]) + pio2_2t;
			}
			return -1;
		}
	}
	if (ix <= IC(0x43490f80))
	{									/* |x| ~<= 2^7*(pi/2), medium size */
		t = __ieee754_fabsf(x);
		n = (int32_t) (t * invpio2 + half);
		fn = (float) n;
		r = t - fn * pio2_1;
		w = fn * pio2_1t;				/* 1st round good to 40 bit */
		if (n < 32 && (int32_t)(ix & IC(0xffffff00)) != npio2_hw[n - 1])
		{
			y[0] = r - w;				/* quick check no cancellation */
		} else
		{
			uint32_t high;

			j = ix >> IEEE754_FLOAT_SHIFT;
			y[0] = r - w;
			GET_FLOAT_WORD(high, y[0]);
			i = j - ((high >> IEEE754_FLOAT_SHIFT) & IEEE754_FLOAT_MAXEXP);
			if (i > 8)
			{							/* 2nd iteration needed, good to 57 */
				t = r;
				w = fn * pio2_2;
				r = t - w;
				w = fn * pio2_2t - ((t - r) - w);
				y[0] = r - w;
				GET_FLOAT_WORD(high, y[0]);
				i = j - ((high >> IEEE754_FLOAT_SHIFT) & IEEE754_FLOAT_MAXEXP);
				if (i > 25)
				{						/* 3rd iteration need, 74 bits acc */
					t = r;				/* will cover all possible cases */
					w = fn * pio2_3;
					r = t - w;
					w = fn * pio2_3t - ((t - r) - w);
					y[0] = r - w;
				}
			}
		}
		y[1] = (r - y[0]) - w;
		if (hx < 0)
		{
			y[0] = -y[0];
			y[1] = -y[1];
			return -n;
		} else
			return n;
	}
	/*
	 * all other (large) arguments
	 */
	if (!FLT_UWORD_IS_FINITE(ix))
	{									/* x is inf or NaN */
		y[0] = y[1] = x - x;
		return 0;
	}
	/* set z = scalbn(|x|,ilogb(x)-7) */
	e0 = (ix >> IEEE754_FLOAT_SHIFT) - (IEEE754_FLOAT_BIAS + 7);				/* e0 = ilogb(z)-7; */
	SET_FLOAT_WORD(z, ix - (e0 << IEEE754_FLOAT_SHIFT));
	for (i = 0; i < 2; i++)
	{
		tx[i] = (float) ((int32_t) (z));
		z = (z - tx[i]) * two8;
	}
	tx[2] = z;
	nx = 3;
	while (tx[nx - 1] == zero)
		nx--;							/* skip zero term */
	n = __kernel_rem_pio2f(tx, y, e0, nx, 2);
	if (hx < 0)
	{
		y[0] = -y[0];
		y[1] = -y[1];
		return -n;
	}
	return n;
}

```

`e_rem_pio2l.c`:

```c
/* Extended-precision floating point argument reduction.
   Copyright (C) 1999-2013 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Based on quad-precision code by Jakub Jelinek <jj@ultra.linux.cz>

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

int32_t __ieee754_rem_pio2l(long double x, long double *y)
{
	double tx[3], ty[3];
	int32_t se, j0;
	uint32_t i0, i1;
	int32_t sx;
	int32_t n, exp;

	GET_LDOUBLE_WORDS(se, i0, i1, x);
	sx = (se >> 15) & 1;
	j0 = (se & IEEE854_LONG_DOUBLE_MAXEXP) - IEEE854_LONG_DOUBLE_BIAS;

	if (j0 < -1)
	{
		/* |x| < pi/4.  */
		y[0] = x;
		y[1] = 0;
		return 0;
	}

	if (j0 >= IC(0x8000))
	{
		/* x is infinite or NaN.  */
		y[0] = x - x;
		y[1] = y[0];
		return 0;
	}

	/* Split the 64 bits of the mantissa into three 24-bit integers
	   stored in a double array.  */
	exp = j0 - 23;
	tx[0] = (double) (i0 >> 8);
	tx[1] = (double) (((i0 << 16) | (i1 >> 16)) & IC(0xffffff));
	tx[2] = (double) ((i1 << 8) & IC(0xffffff));

	n = __kernel_rem_pio2l(tx, ty, exp, 3, 2);

	/* The result is now stored in two double values, we need to convert
	   it into two long double values.  */
	if (sx == 0)
	{
		y[0] = (long double) ty[0] + (long double) ty[1];
		y[1] = ty[1] - (y[0] - ty[0]);
		return n;
	} else
	{
		y[0] = -((long double) ty[0] + (long double) ty[1]);
		y[1] = -ty[1] - (y[0] + ty[0]);
		return -n;
	}
}

#endif

```

`e_remainder.c`:

```c
/* @(#)e_remainder.c 1.3 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/* __ieee754_remainder(x,p)
 * Return :                  
 * 	returns  x REM p  =  x - [x/p]*p as if in infinite 
 * 	precise arithmetic, where [x/p] is the (infinite bit) 
 *	integer nearest x/p (in half way case choose the even one).
 * Method : 
 *	Based on fmod() return x-[x/p]chopped*p exactlp.
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_remainder

double __ieee754_remainder(double x, double p)
{
	int32_t hx, hp;
	uint32_t sx, lx, lp;
	double p_half;

	static const double zero = 0.0;

	GET_DOUBLE_WORDS(hx, lx, x);
	GET_DOUBLE_WORDS(hp, lp, p);
	sx = hx & IC(0x80000000);
	hp &= IC(0x7fffffff);
	hx &= IC(0x7fffffff);

	/* purge off exception values */
	if ((hp | lp) == 0)
		return (x * p) / (x * p);		/* p = 0 */
	if ((hx >= IC(0x7ff00000)) ||			/* x not finite */
		((hp >= IC(0x7ff00000)) &&			/* p is NaN */
		 (((hp - IC(0x7ff00000)) | lp) != 0)))
		return (x * p) / (x * p);


	if (hp <= IC(0x7fdfffff))
		x = __ieee754_fmod(x, p + p);	/* now x < 2p */
	if (((hx - hp) | (lx - lp)) == 0)
		return zero * x;
	x = __ieee754_fabs(x);
	p = __ieee754_fabs(p);
	if (hp < IC(0x00200000))
	{
		if (x + x > p)
		{
			x -= p;
			if (x + x >= p)
				x -= p;
		}
	} else
	{
		p_half = 0.5 * p;
		if (x > p_half)
		{
			x -= p;
			if (x >= p_half)
				x -= p;
		}
	}
	GET_HIGH_WORD(hx, x);
	SET_HIGH_WORD(x, hx ^ sx);
	return x;
}

#endif

/* wrapper remainder */
double __remainder(double x, double y)
{
	if (((y == 0.0 && !isnan(x))
		 || (isinf(x) && !isnan(y))) && _LIB_VERSION != _IEEE_)
		return __kernel_standard(x, y, y, KMATHERR_REMAINDER);	/* remainder domain */

	return __ieee754_remainder(x, y);
}


#undef drem
#undef dreml

__typeof(__remainder) remainder __attribute__((weak, alias("__remainder")));
__typeof(__remainder) __drem __attribute__((alias("__remainder")));
__typeof(remainder) drem __attribute__((weak, alias("__drem")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(__remainderl) __remainderl __attribute__((alias("__remainder")));
__typeof(__remainderl) remainderl __attribute__((weak, alias("__remainder")));
__typeof(__remainderl) __dreml __attribute__((alias("__remainderl")));
__typeof(__remainderl) dreml __attribute__((weak, alias("__dreml")));
#endif

```

`e_remainderf.c`:

```c
/* e_remainderf.c -- float version of e_remainder.c.
 * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_remainder

float __ieee754_remainderf(float x, float p)
{
	int32_t hx, hp;
	uint32_t sx;
	float p_half;

	static const float zero = 0.0;

	GET_FLOAT_WORD(hx, x);
	GET_FLOAT_WORD(hp, p);
	sx = hx & IC(0x80000000);
	hp &= IC(0x7fffffff);
	hx &= IC(0x7fffffff);

	/* purge off exception values */
	if (FLT_UWORD_IS_ZERO(hp) || !FLT_UWORD_IS_FINITE(hx) || FLT_UWORD_IS_NAN(hp))
		return (x * p) / (x * p);

	if (hp <= FLT_UWORD_HALF_MAX)
		x = __ieee754_fmodf(x, p + p);	/* now x < 2p */
	if ((hx - hp) == 0)
		return zero * x;
	x = __ieee754_fabsf(x);
	p = __ieee754_fabsf(p);
	if (hp < IC(0x01000000))
	{
		if (x + x > p)
		{
			x -= p;
			if (x + x >= p)
				x -= p;
		}
	} else
	{
		p_half = (float) 0.5 *p;

		if (x > p_half)
		{
			x -= p;
			if (x >= p_half)
				x -= p;
		}
	}
	GET_FLOAT_WORD(hx, x);
	SET_FLOAT_WORD(x, hx ^ sx);
	return x;
}

#endif

/* wrapper remainder */
float __remainderf(float x, float y)
{
	if (((y == 0.0F && !isnan(x))
		 || (isinf(x) && !isnan(y))) && _LIB_VERSION != _IEEE_)
		return __kernel_standard_f(x, y, y, KMATHERRF_REMAINDER);	/* remainder domain */

	return __ieee754_remainderf(x, y);
}

__typeof(__remainderf) remainderf __attribute__((weak, alias("__remainderf")));
__typeof(__remainderf) __dremf __attribute__((alias("__remainderf")));
__typeof(remainderf) dremf __attribute__((weak, alias("__dremf")));

```

`e_remainderl.c`:

```c
/* e_remainderl.c -- long double version of e_remainder.c.
 * Conversion to long double by Ulrich Drepper,
 * Cygnus Support, drepper@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/* __ieee754_remainderl(x,p)
 * Return :
 *	returns  x REM p  =  x - [x/p]*p as if in infinite
 *	precise arithmetic, where [x/p] is the (infinite bit)
 *	integer nearest x/p (in half way case choose the even one).
 * Method :
 *	Based on fmod() return x-[x/p]chopped*p exactlp.
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

#ifndef __have_fpu_remainder

long double __ieee754_remainderl(long double x, long double p)
{
	uint32_t sx, sex, sep, x0, x1, p0, p1;
	long double p_half;

	static const long double zero = 0.0;

	GET_LDOUBLE_WORDS(sex, x0, x1, x);
	GET_LDOUBLE_WORDS(sep, p0, p1, p);
	sx = sex & IC(0x8000);
	sep &= IEEE854_LONG_DOUBLE_MAXEXP;
	sex &= IEEE854_LONG_DOUBLE_MAXEXP;

	/* purge off exception values */
	if ((sep | p0 | p1) == 0)
		return (x * p) / (x * p);		/* p = 0 */
	if ((sex == IEEE854_LONG_DOUBLE_MAXEXP) ||				/* x not finite */
		((sep == IEEE854_LONG_DOUBLE_MAXEXP) &&				/* p is NaN */
		 (((p0 & IC(0x7fffffff)) | p1) != 0)))
		return (x * p) / (x * p);

	if (sep < (IEEE854_LONG_DOUBLE_MAXEXP - 1))
		x = __ieee754_fmodl(x, p + p);	/* now x < 2p */
	if (((sex - sep) | ((x0 - p0) & IC(0x7fffffff)) | (x1 - p1)) == 0)
		return zero * x;
	x = __ieee754_fabsl(x);
	p = __ieee754_fabsl(p);
	if (sep < 0x0002)
	{
		if (x + x > p)
		{
			x -= p;
			if (x + x >= p)
				x -= p;
		}
	} else
	{
		p_half = 0.5L * p;
		if (x > p_half)
		{
			x -= p;
			if (x >= p_half)
				x -= p;
		}
	}
	GET_LDOUBLE_EXP(sex, x);
	SET_LDOUBLE_EXP(x, sex ^ sx);
	return x;
}

#endif

/* wrapper remainder */
long double __remainderl(long double x, long double y)
{
	if (((y == 0.0 && !isnan(x))
		 || (isinf(x) && !isnan(y))) && _LIB_VERSION != _IEEE_)
		return __kernel_standard_l(x, y, y, KMATHERRL_REMAINDER);	/* remainder domain */

	return __ieee754_remainderl(x, y);
}

__typeof(__remainderl) remainderl __attribute__((weak, alias("__remainderl")));
__typeof(__remainderl) __dreml __attribute__((alias("__remainderl")));
__typeof(remainderl) dreml __attribute__((weak, alias("__dreml")));

#endif

```

`e_scalb.c`:

```c
/* @(#)e_scalb.c 1.3 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

#include "fdlibm.h"

double __ieee754_scalb(double x, double fn)
{
	long ifn;
	
	if (isnan(x))
		return x * fn;
	if (!isfinite(fn))
	{
		if (isnan(fn) || fn > 0.0)
			return x * fn;
		if (x == 0.0)
			return x;
		return x / -fn;
	}
	ifn = (long) fn;
	if ((double) ifn != fn)
	{
		if (__ieee754_rint(fn) != fn)
		{
			feraiseexcept(FE_INVALID);
			return __builtin_nan("");
		}
		if (ifn > 65000l)
			return __ieee754_scalbln(x, 65000l);
		return __ieee754_scalbln(x, -65000l);
	}
	
	return __ieee754_scalbln(x, ifn);
}


static double __attribute__ ((noinline)) sysv_scalb(double x, double fn)
{
	double z = __ieee754_scalb(x, fn);

	if (isinf(z))
	{
		if (isfinite(x))
			return __kernel_standard(x, fn, z, KMATHERR_SCALB_OVERFLOW);	/* scalb overflow */
		else
			__set_errno(ERANGE);
	} else if (z == 0.0 && z != x)
		return __kernel_standard(x, fn, z, KMATHERR_SCALB_UNDERFLOW);	/* scalb underflow */

	return z;
}


/*
 * wrapper scalb(double x, double fn) is provide for
 * passing various standard test suite. One 
 * should use scalbn() instead.
 */

double __scalb(double x, double fn)
{
	if (_LIB_VERSION == _SVID_)
	{
		return sysv_scalb(x, fn);
	} else
	{
		double z = __ieee754_scalb(x, fn);

		if (!isfinite(z) || z == 0.0)
		{
			if (isnan(z))
			{
				if (!isnan(x) && !isnan(fn))
					z = __kernel_standard(x, fn, z, KMATHERR_SCALB_INVALID);
			} else if (isinf(z))
			{
				if (!isinf(x) && !isinf(fn))
					z = __kernel_standard(x, fn, z, KMATHERR_SCALB_OVERFLOW);
			} else
			{
				/* z == 0.  */
				if (x != 0.0 && !isinf(fn))
					z = __kernel_standard(x, fn, z, KMATHERR_SCALB_UNDERFLOW);
			}
		}
		return z;
	}
}

__typeof(__scalb) scalb __attribute__((weak, alias("__scalb")));
#ifdef __NO_LONG_DOUBLE_MATH
long double __scalbl(long double x, long double fn) __attribute__((alias("__scalb")));
__typeof(__scalbl) scalbl __attribute__((weak, alias("__scalb")));
#endif

```

`e_scalbf.c`:

```c
/* Copyright (C) 2011-2013 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Ulrich Drepper <drepper@gmail.com>, 2011.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

float __ieee754_scalbf(float x, float fn)
{
	long ifn;
	
	if (isnan(x))
		return x * fn;
	if (!isfinite(fn))
	{
		if (isnan(fn) || fn > 0.0f)
			return x * fn;
		if (x == 0.0f)
			return x;
		return x / -fn;
	}
	ifn = (long) fn;
	if ((float) ifn != fn)
	{
		if (__ieee754_rintf(fn) != fn)
		{
			feraiseexcept(FE_INVALID);
			return __builtin_nanf("");
		}
		if (ifn > 65000l)
			return __ieee754_scalblnf(x, 65000l);
		return __ieee754_scalblnf(x, -65000l);
	}
	
	return __ieee754_scalblnf(x, ifn);
}

static float __attribute__ ((noinline)) sysv_scalbf(float x, float fn)
{
	float z = __ieee754_scalbf(x, fn);

	if (isinf(z))
	{
		if (isfinite(x))
			return __kernel_standard_f(x, fn, z, KMATHERR_SCALB_OVERFLOW);	/* scalb overflow */
		else
			__set_errno(ERANGE);
	} else if (z == 0.0F && z != x)
		return __kernel_standard_f(x, fn, z, KMATHERRF_SCALB_UNDERFLOW);	/* scalb underflow */

	return z;
}

/* Wrapper scalb */
float __scalbf(float x, float fn)
{
	if (_LIB_VERSION == _SVID_)
	{
		return sysv_scalbf(x, fn);
	} else
	{
		float z = __ieee754_scalbf(x, fn);

		if (!isfinite(z) || z == 0.0F)
		{
			if (isnan(z))
			{
				if (!isnan(x) && !isnan(fn))
					z = __kernel_standard_f(x, fn, z, KMATHERRF_SCALB_INVALID);
			} else if (isinf(z))
			{
				if (!isinf(x) && !isinf(fn))
					z = __kernel_standard_f(x, fn, z, KMATHERRF_SCALB_OVERFLOW);
			} else
			{
				/* z == 0.  */
				if (x != 0.0F && !isinf(fn))
					z = __kernel_standard_f(x, fn, z, KMATHERRF_SCALB_UNDERFLOW);
			}
		}
		return z;
	}
}


__typeof(__scalbf) scalbf __attribute__((weak, alias("__scalbf")));

```

`e_scalbl.c`:

```c
/* Copyright (C) 2011-2013 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Ulrich Drepper <drepper@gmail.com>, 2011.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

long double __ieee754_scalbl(long double x, long double fn)
{
	long ifn;
	
	if (isnan(x))
		return x * fn;
	if (!isfinite(fn))
	{
		if (isnan(fn) || fn > 0.0L)
			return x * fn;
		if (x == 0.0L)
			return x;
		return x / -fn;
	}
	ifn = (long) fn;
	if ((long double) ifn != fn)
	{
		if (__ieee754_rintl(fn) != fn)
		{
			feraiseexcept(FE_INVALID);
			return __builtin_nanl("");
		}
		if (ifn > 65000l)
			return __ieee754_scalblnl(x, 65000l);
		return __ieee754_scalblnl(x, -65000l);
	}

	return __ieee754_scalblnl(x, ifn);
}

static long double __attribute__ ((noinline)) sysv_scalbl(long double x, long double fn)
{
	long double z = __ieee754_scalbl(x, fn);

	if (isinf(z))
	{
		if (isfinite(x))
			return __kernel_standard_l(x, fn, z, KMATHERRL_SCALB_OVERFLOW);	/* scalb overflow */
		else
			__set_errno(ERANGE);
	} else if (z == 0.0 && z != x)
		return __kernel_standard_l(x, fn, z, KMATHERRL_SCALB_UNDERFLOW);	/* scalb underflow */

	return z;
}

/* Wrapper scalb */
long double __scalbl(long double x, long double fn)
{
	if (_LIB_VERSION == _SVID_)
	{
		return sysv_scalbl(x, fn);
	} else
	{
		long double z = __ieee754_scalbl(x, fn);

		if (!isfinite(z) || z == 0.0)
		{
			if (isnan(z))
			{
				if (!isnan(x) && !isnan(fn))
					z = __kernel_standard_l(x, fn, z, KMATHERRL_SCALB_INVALID);
			} else if (isinf(z))
			{
				if (!isinf(x) && !isinf(fn))
					z = __kernel_standard_l(x, fn, z, KMATHERRL_SCALB_OVERFLOW);
			} else
			{
				/* z == 0.  */
				if (x != 0.0 && !isinf(fn))
					z = __kernel_standard_l(x, fn, z, KMATHERRL_SCALB_UNDERFLOW);
			}
		}
		return z;
	}
}


__typeof(__scalbl) scalbl __attribute__((weak, alias("__scalbl")));

#endif

```

`e_sinh.c`:

```c
/* @(#)e_sinh.c 1.3 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/* __ieee754_sinh(x)
 * Method :
 * mathematically sinh(x) if defined to be (exp(x)-exp(-x))/2
 *	1. Replace x by |x| (sinh(-x) = -sinh(x)).
 *	2.
 *						    E + E/(E+1)
 *	    0        <= x <= 22     :  sinh(x) := --------------, E=expm1(x)
 *							2
 *
 *	    22       <= x <= lnovft :  sinh(x) := exp(x)/2
 *	    lnovft   <= x <= ln2ovft:  sinh(x) := exp(x/2)/2 * exp(x/2)
 *	    ln2ovft  <  x	    :  sinh(x) := x*shuge (overflow)
 *
 * Special cases:
 *	sinh(x) is |x| if x is +INF, -INF, or NaN.
 *	only sinh(0)=0 is exact for finite x.
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_sinh

double __ieee754_sinh(double x)
{
	double t, w, h;
	int32_t ix, jx;
	uint32_t lx;

	static const double one = 1.0;
	static const double shuge = 1.0e307;

	/* High word of |x|. */
	GET_HIGH_WORD(jx, x);
	ix = jx & IC(0x7fffffff);

	/* x is INF or NaN */
	if (ix >= IC(0x7ff00000))
		return x + x;

	h = 0.5;
	if (jx < 0)
		h = -h;
	/* |x| in [0,22], return sign(x)*0.5*(E+E/(E+1))) */
	if (ix < IC(0x40360000))
	{									/* |x|<22 */
		if (ix < IC(0x3e300000))		/* |x|<2**-28 */
			if (shuge + x > one)
				return x;				/* sinh(tiny) = tiny with inexact */
		t = __ieee754_expm1(__ieee754_fabs(x));
		if (ix < IC(0x3ff00000))
			return h * (2.0 * t - t * t / (t + one));
		return h * (t + t / (t + one));
	}

	/* |x| in [22, log(maxdouble)] return 0.5*exp(|x|) */
	if (ix < IC(0x40862e42))
		return h * __ieee754_exp(__ieee754_fabs(x));

	/* |x| in [log(maxdouble), overflowthresold] */
	GET_LOW_WORD(lx, x);
	if (ix < IC(0x408633ce) || (ix == IC(0x408633ce) && lx <= UC(0x8fb9f87d)))
	{
		w = __ieee754_exp(0.5 * __ieee754_fabs(x));
		t = h * w;
		return t * w;
	}

	/* |x| > overflowthresold, sinh(x) overflow */
	return x * shuge;
}

#endif

/* wrapper sinh */
double __sinh(double x)
{
	double z = __ieee754_sinh(x);

	if (_LIB_VERSION != _IEEE_ && !isfinite(z) && isfinite(x))
		return __kernel_standard(x, x, z, KMATHERR_SINH);	/* sinh overflow */

	return z;
}

__typeof(__sinh) sinh __attribute__((weak, alias("__sinh")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(__sinhl) __sinhl __attribute__((alias("__sinh")));
__typeof(__sinhl) sinhl __attribute__((weak, alias("__sinh")));
#endif

```

`e_sinhf.c`:

```c
/* e_sinhf.c -- float version of e_sinh.c.
 * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_sinh

float __ieee754_sinhf(float x)
{
	float t, w, h;
	int32_t ix, jx;

	static const float one = 1.0;
	static const float shuge = 1.0e37;
	
	GET_FLOAT_WORD(jx, x);
	ix = jx & IC(0x7fffffff);

	/* x is INF or NaN */
	if (!FLT_UWORD_IS_FINITE(ix))
		return x + x;

	h = 0.5;
	if (jx < 0)
		h = -h;
	/* |x| in [0,22], return sign(x)*0.5*(E+E/(E+1))) */
	if (ix < IC(0x41b00000))
	{									/* |x|<22 */
		if (ix < IC(0x31800000))			/* |x|<2**-28 */
			if (shuge + x > one)
				return x;				/* sinh(tiny) = tiny with inexact */
		t = __ieee754_expm1f(__ieee754_fabsf(x));
		if (ix < IC(0x3f800000))
			return h * (2.0f * t - t * t / (t + one));
		return h * (t + t / (t + one));
	}

	/* |x| in [22, log(maxdouble)] return 0.5*exp(|x|) */
	if (ix <= FLT_UWORD_LOG_MAX)
		return h * __ieee754_expf(__ieee754_fabsf(x));

	/* |x| in [log(maxdouble), overflowthresold] */
	if (ix <= FLT_UWORD_LOG_2MAX)
	{
		w = __ieee754_expf(0.5f * __ieee754_fabsf(x));
		t = h * w;
		return t * w;
	}

	/* |x| > overflowthresold, sinh(x) overflow */
	return x * shuge;
}

#endif

float __sinhf(float x)
{
	float z = __ieee754_sinhf(x);

	if (!isfinite(z) && isfinite(x) && _LIB_VERSION != _IEEE_)
		return __kernel_standard_f(x, x, z, KMATHERRF_SINH);	/* sinh overflow */

	return z;
}

__typeof(__sinhf) sinhf __attribute__((weak, alias("__sinhf")));

```

`e_sinhl.c`:

```c
/* e_asinhl.c -- long double version of e_asinh.c.
 * Conversion to long double by Ulrich Drepper,
 * Cygnus Support, drepper@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/* __ieee754_sinhl(x)
 * Method :
 * mathematically sinh(x) if defined to be (exp(x)-exp(-x))/2
 *	1. Replace x by |x| (sinhl(-x) = -sinhl(x)).
 *	2.
 *						     E + E/(E+1)
 *	    0        <= x <= 25     :  sinhl(x) := --------------, E=expm1l(x)
 *							 2
 *
 *	    25       <= x <= lnovft :  sinhl(x) := expl(x)/2
 *	    lnovft   <= x <= ln2ovft:  sinhl(x) := expl(x/2)/2 * expl(x/2)
 *	    ln2ovft  <  x	    :  sinhl(x) := x*shuge (overflow)
 *
 * Special cases:
 *	sinhl(x) is |x| if x is +INF, -INF, or NaN.
 *	only sinhl(0)=0 is exact for finite x.
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

#ifndef __have_fpu_sinh

long double __ieee754_sinhl(long double x)
{
	long double t, w, h;
	uint32_t jx, ix, i0, i1;

	static const long double one = 1.0;
	static const long double shuge = 1.0e4931L;
	
	/* Words of |x|. */
	GET_LDOUBLE_WORDS(jx, i0, i1, x);
	ix = jx & IEEE854_LONG_DOUBLE_MAXEXP;

	/* x is INF or NaN */
	if (ix == IEEE854_LONG_DOUBLE_MAXEXP)
		return x + x;

	h = 0.5;
	if (jx & 0x8000)
		h = -h;
	/* |x| in [0,25], return sign(x)*0.5*(E+E/(E+1))) */
	if (ix < 0x4003 || (ix == 0x4003 && i0 <= UC(0xc8000000)))
	{									/* |x|<25 */
		if (ix < 0x3fdf)				/* |x|<2**-32 */
			if (shuge + x > one)
				return x;				/* sinh(tiny) = tiny with inexact */
		t = __ieee754_expm1l(__ieee754_fabsl(x));
		if (ix < 0x3fff)
			return h * (2.0 * t - t * t / (t + one));
		return h * (t + t / (t + one));
	}

	/* |x| in [25, log(maxdouble)] return 0.5*exp(|x|) */
	if (ix < 0x400c || (ix == 0x400c && i0 < UC(0xb17217f7)))
		return h * __ieee754_expl(__ieee754_fabsl(x));

	/* |x| in [log(maxdouble), overflowthreshold] */
	if (ix < 0x400c || (ix == 0x400c && (i0 < UC(0xb174ddc0) || (i0 == UC(0xb174ddc0) && i1 <= UC(0x31aec0ea)))))
	{
		w = __ieee754_expl(0.5 * __ieee754_fabsl(x));
		t = h * w;
		return t * w;
	}

	/* |x| > overflowthreshold, sinhl(x) overflow */
	return x * shuge;
}

#endif

long double __sinhl(long double  x)
{
	long double z = __ieee754_sinhl(x);

	if (!isfinite(z) && isfinite(x) && _LIB_VERSION != _IEEE_)
		return __kernel_standard_l(x, x, z, KMATHERRL_SINH);	/* sinh overflow */

	return z;
}

__typeof(__sinhl) sinhl __attribute__((weak, alias("__sinhl")));

#endif

```

`e_sqrt.c`:

```c
/* @(#)e_sqrt.c 1.3 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice 
 * is preserved.
 * ====================================================
 */

/* __ieee754_sqrt(x)
 * Return correctly rounded sqrt.
 *           ------------------------------------------
 *	     |  Use the hardware sqrt if you have one |
 *           ------------------------------------------
 * Method: 
 *   Bit by bit method using integer arithmetic. (Slow, but portable) 
 *   1. Normalization
 *	Scale x to y in [1,4) with even powers of 2: 
 *	find an integer k such that  1 <= (y=x*2^(2k)) < 4, then
 *		sqrt(x) = 2^k * sqrt(y)
 *   2. Bit by bit computation
 *	Let q  = sqrt(y) truncated to i bit after binary point (q = 1),
 *	     i							 0
 *                                     i+1         2
 *	    s  = 2*q , and	y  =  2   * ( y - q  ).		(1)
 *	     i      i            i                 i
 *                                                        
 *	To compute q    from q , one checks whether 
 *		    i+1       i                       
 *
 *			      -(i+1) 2
 *			(q + 2      ) <= y.			(2)
 *     			  i
 *							      -(i+1)
 *	If (2) is false, then q   = q ; otherwise q   = q  + 2      .
 *		 	       i+1   i             i+1   i
 *
 *	With some algebric manipulation, it is not difficult to see
 *	that (2) is equivalent to 
 *                             -(i+1)
 *			s  +  2       <= y			(3)
 *			 i                i
 *
 *	The advantage of (3) is that s  and y  can be computed by 
 *				      i      i
 *	the following recurrence formula:
 *	    if (3) is false
 *
 *	    s     =  s  ,	y    = y   ;			(4)
 *	     i+1      i		 i+1    i
 *
 *	    otherwise,
 *                         -i                     -(i+1)
 *	    s	  =  s  + 2  ,  y    = y  -  s  - 2  		(5)
 *           i+1      i          i+1    i     i
 *				
 *	One may easily use induction to prove (4) and (5). 
 *	Note. Since the left hand side of (3) contain only i+2 bits,
 *	      it does not necessary to do a full (53-bit) comparison 
 *	      in (3).
 *   3. Final rounding
 *	After generating the 53 bits result, we compute one more bit.
 *	Together with the remainder, we can decide whether the
 *	result is exact, bigger than 1/2ulp, or less than 1/2ulp
 *	(it will never equal to 1/2ulp).
 *	The rounding mode can be detected by checking whether
 *	huge + tiny is equal to huge, and whether huge - tiny is
 *	equal to huge for some floating point number "huge" and "tiny".
 *		
 * Special cases:
 *	sqrt(+-0) = +-0 	... exact
 *	sqrt(inf) = inf
 *	sqrt(-ve) = NaN		... with invalid signal
 *	sqrt(NaN) = NaN		... with invalid signal for signaling NaN
 *
 * Other methods : see the appended file at the end of the program below.
 *---------------
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_sqrt

double __ieee754_sqrt(double x)
{
	double z;
	int32_t sign = IC(0x80000000);
	uint32_t r, t1, s1, ix1, q1;
	int32_t ix0, s0, q, m, t, i;

	static const double one = 1.0;
	static const double tiny = 1.0e-300;

	GET_DOUBLE_WORDS(ix0, ix1, x);

	/* take care of Inf and NaN */
	if ((ix0 & IC(0x7ff00000)) == IC(0x7ff00000))
	{
		return x * x + x;				/* sqrt(NaN)=NaN, sqrt(+inf)=+inf
										   sqrt(-inf)=sNaN */
	}
	/* take care of zero */
	if (ix0 <= 0)
	{
		if (((ix0 & (~sign)) | ix1) == 0)
			return x;					/* sqrt(+-0) = +-0 */
		else if (ix0 < 0)
			return (x - x) / (x - x);	/* sqrt(-ve) = sNaN */
	}
	/* normalize x */
	m = (ix0 >> 20);
	if (m == 0)
	{									/* subnormal x */
		while (ix0 == 0)
		{
			m -= 21;
			ix0 |= (ix1 >> 11);
			ix1 <<= 21;
		}
		for (i = 0; (ix0 & IC(0x00100000)) == 0; i++)
			ix0 <<= 1;
		m -= i - 1;
		ix0 |= (ix1 >> (32 - i));
		ix1 <<= i;
	}
	m -= 1023;							/* unbias exponent */
	ix0 = (ix0 & IC(0x000fffff)) | IC(0x00100000);
	if (m & 1)
	{									/* odd m, double x to make it even */
		ix0 += ix0 + ((ix1 & sign) >> 31);
		ix1 += ix1;
	}
	m >>= 1;							/* m = [m/2] */

	/* generate sqrt(x) bit by bit */
	ix0 += ix0 + ((ix1 & sign) >> 31);
	ix1 += ix1;
	q = q1 = s0 = s1 = 0;				/* [q,q1] = sqrt(x) */
	r = IC(0x00200000);					/* r = moving bit from right to left */

	while (r != 0)
	{
		t = s0 + r;
		if (t <= ix0)
		{
			s0 = t + r;
			ix0 -= t;
			q += r;
		}
		ix0 += ix0 + ((ix1 & sign) >> 31);
		ix1 += ix1;
		r >>= 1;
	}

	r = sign;
	while (r != 0)
	{
		t1 = s1 + r;
		t = s0;
		if ((t < ix0) || ((t == ix0) && (t1 <= ix1)))
		{
			s1 = t1 + r;
			if (((int32_t)(t1 & sign) == sign) && (s1 & sign) == 0)
				s0 += 1;
			ix0 -= t;
			if (ix1 < t1)
				ix0 -= 1;
			ix1 -= t1;
			q1 += r;
		}
		ix0 += ix0 + ((ix1 & sign) >> 31);
		ix1 += ix1;
		r >>= 1;
	}

	/* use floating add to find out rounding direction */
	if ((ix0 | ix1) != 0)
	{
		z = one - tiny;					/* trigger inexact flag */
		if (z >= one)
		{
			z = one + tiny;
			if (q1 == UC(0xffffffff))
			{
				q1 = 0;
				q += 1;
			} else if (z > one)
			{
				if (q1 == UC(0xfffffffe))
					q += 1;
				q1 += 2;
			} else
				q1 += (q1 & 1);
		}
	}
	ix0 = (q >> 1) + UC(0x3fe00000);
	ix1 = q1 >> 1;
	if ((q & 1) == 1)
		ix1 |= sign;
	ix0 += (m << 20);
	INSERT_WORDS(z, ix0, ix1);
	return z;
}

#endif

/*
Other methods  (use floating-point arithmetic)
-------------
(This is a copy of a drafted paper by Prof W. Kahan 
and K.C. Ng, written in May, 1986)

	Two algorithms are given here to implement sqrt(x) 
	(IEEE double precision arithmetic) in software.
	Both supply sqrt(x) correctly rounded. The first algorithm (in
	Section A) uses newton iterations and involves four divisions.
	The second one uses reciproot iterations to avoid division, but
	requires more multiplications. Both algorithms need the ability
	to chop results of arithmetic operations instead of round them, 
	and the INEXACT flag to indicate when an arithmetic operation
	is executed exactly with no roundoff error, all part of the 
	standard (IEEE 754-1985). The ability to perform shift, add,
	subtract and logical AND operations upon 32-bit words is needed
	too, though not part of the standard.

A.  sqrt(x) by Newton Iteration

   (1)	Initial approximation

	Let x0 and x1 be the leading and the trailing 32-bit words of
	a floating point number x (in IEEE double format) respectively 

	    1    11		     52				  ...widths
	   ------------------------------------------------------
	x: |s|	  e     |	      f				|
	   ------------------------------------------------------
	      msb    lsb  msb				      lsb ...order

 
	     ------------------------  	     ------------------------
	x0:  |s|   e    |    f1     |	 x1: |          f2           |
	     ------------------------  	     ------------------------

	By performing shifts and subtracts on x0 and x1 (both regarded
	as integers), we obtain an 8-bit approximation of sqrt(x) as
	follows.

		k  := (x0>>1) + 0x1ff80000;
		y0 := k - T1[31&(k>>15)].	... y ~ sqrt(x) to 8 bits
	Here k is a 32-bit integer and T1[] is an integer array containing
	correction terms. Now magically the floating value of y (y's
	leading 32-bit word is y0, the value of its trailing word is 0)
	approximates sqrt(x) to almost 8-bit.

	Value of T1:
	static int T1[32]= {
	0,	1024,	3062,	5746,	9193,	13348,	18162,	23592,
	29598,	36145,	43202,	50740,	58733,	67158,	75992,	85215,
	83599,	71378,	60428,	50647,	41945,	34246,	27478,	21581,
	16499,	12183,	8588,	5674,	3403,	1742,	661,	130 };

    (2)	Iterative refinement

	Apply Heron's rule three times to y, we have y approximates 
	sqrt(x) to within 1 ulp (Unit in the Last Place):

		y := (y+x/y)/2		... almost 17 sig. bits
		y := (y+x/y)/2		... almost 35 sig. bits
		y := y-(y-x/y)/2	... within 1 ulp


	Remark 1.
	    Another way to improve y to within 1 ulp is:

		y := (y+x/y)		... almost 17 sig. bits to 2*sqrt(x)
		y := y - 0x00100006	... almost 18 sig. bits to sqrt(x)

				2
			    (x-y )*y
		y := y + 2* ----------	...within 1 ulp
			       2
			     3y  + x


	This formula has one division fewer than the one above; however,
	it requires more multiplications and additions. Also x must be
	scaled in advance to avoid spurious overflow in evaluating the
	expression 3y*y+x. Hence it is not recommended uless division
	is slow. If division is very slow, then one should use the 
	reciproot algorithm given in section B.

    (3) Final adjustment

	By twiddling y's last bit it is possible to force y to be 
	correctly rounded according to the prevailing rounding mode
	as follows. Let r and i be copies of the rounding mode and
	inexact flag before entering the square root program. Also we
	use the expression y+-ulp for the next representable floating
	numbers (up and down) of y. Note that y+-ulp = either fixed
	point y+-1, or multiply y by nextafter(1,+-inf) in chopped
	mode.

		I := FALSE;	... reset INEXACT flag I
		R := RZ;	... set rounding mode to round-toward-zero
		z := x/y;	... chopped quotient, possibly inexact
		If(not I) then {	... if the quotient is exact
		    if(z=y) {
		        I := i;	 ... restore inexact flag
		        R := r;  ... restore rounded mode
		        return sqrt(x):=y.
		    } else {
			z := z - ulp;	... special rounding
		    }
		}
		i := TRUE;		... sqrt(x) is inexact
		If (r=RN) then z=z+ulp	... rounded-to-nearest
		If (r=RP) then {	... round-toward-+inf
		    y = y+ulp; z=z+ulp;
		}
		y := y+z;		... chopped sum
		y0:=y0-0x00100000;	... y := y/2 is correctly rounded.
	        I := i;	 		... restore inexact flag
	        R := r;  		... restore rounded mode
	        return sqrt(x):=y.
		    
    (4)	Special cases

	Square root of +inf, +-0, or NaN is itself;
	Square root of a negative number is NaN with invalid signal.


B.  sqrt(x) by Reciproot Iteration

   (1)	Initial approximation

	Let x0 and x1 be the leading and the trailing 32-bit words of
	a floating point number x (in IEEE double format) respectively
	(see section A). By performing shifs and subtracts on x0 and y0,
	we obtain a 7.8-bit approximation of 1/sqrt(x) as follows.

	    k := 0x5fe80000 - (x0>>1);
	    y0:= k - T2[63&(k>>14)].	... y ~ 1/sqrt(x) to 7.8 bits

	Here k is a 32-bit integer and T2[] is an integer array 
	containing correction terms. Now magically the floating
	value of y (y's leading 32-bit word is y0, the value of
	its trailing word y1 is set to zero) approximates 1/sqrt(x)
	to almost 7.8-bit.

	Value of T2:
	static int T2[64]= {
	0x1500,	0x2ef8,	0x4d67,	0x6b02,	0x87be,	0xa395,	0xbe7a,	0xd866,
	0xf14a,	0x1091b,0x11fcd,0x13552,0x14999,0x15c98,0x16e34,0x17e5f,
	0x18d03,0x19a01,0x1a545,0x1ae8a,0x1b5c4,0x1bb01,0x1bfde,0x1c28d,
	0x1c2de,0x1c0db,0x1ba73,0x1b11c,0x1a4b5,0x1953d,0x18266,0x16be0,
	0x1683e,0x179d8,0x18a4d,0x19992,0x1a789,0x1b445,0x1bf61,0x1c989,
	0x1d16d,0x1d77b,0x1dddf,0x1e2ad,0x1e5bf,0x1e6e8,0x1e654,0x1e3cd,
	0x1df2a,0x1d635,0x1cb16,0x1be2c,0x1ae4e,0x19bde,0x1868e,0x16e2e,
	0x1527f,0x1334a,0x11051,0xe951,	0xbe01,	0x8e0d,	0x5924,	0x1edd};

    (2)	Iterative refinement

	Apply Reciproot iteration three times to y and multiply the
	result by x to get an approximation z that matches sqrt(x)
	to about 1 ulp. To be exact, we will have 
		-1ulp < sqrt(x)-z<1.0625ulp.
	
	... set rounding mode to Round-to-nearest
	   y := y*(1.5-0.5*x*y*y)	... almost 15 sig. bits to 1/sqrt(x)
	   y := y*((1.5-2^-30)+0.5*x*y*y)... about 29 sig. bits to 1/sqrt(x)
	... special arrangement for better accuracy
	   z := x*y			... 29 bits to sqrt(x), with z*y<1
	   z := z + 0.5*z*(1-z*y)	... about 1 ulp to sqrt(x)

	Remark 2. The constant 1.5-2^-30 is chosen to bias the error so that
	(a) the term z*y in the final iteration is always less than 1; 
	(b) the error in the final result is biased upward so that
		-1 ulp < sqrt(x) - z < 1.0625 ulp
	    instead of |sqrt(x)-z|<1.03125ulp.

    (3)	Final adjustment

	By twiddling y's last bit it is possible to force y to be 
	correctly rounded according to the prevailing rounding mode
	as follows. Let r and i be copies of the rounding mode and
	inexact flag before entering the square root program. Also we
	use the expression y+-ulp for the next representable floating
	numbers (up and down) of y. Note that y+-ulp = either fixed
	point y+-1, or multiply y by nextafter(1,+-inf) in chopped
	mode.

	R := RZ;		... set rounding mode to round-toward-zero
	switch(r) {
	    case RN:		... round-to-nearest
	       if(x<= z*(z-ulp)...chopped) z = z - ulp; else
	       if(x<= z*(z+ulp)...chopped) z = z; else z = z+ulp;
	       break;
	    case RZ:case RM:	... round-to-zero or round-to--inf
	       R:=RP;		... reset rounding mod to round-to-+inf
	       if(x<z*z ... rounded up) z = z - ulp; else
	       if(x>=(z+ulp)*(z+ulp) ...rounded up) z = z+ulp;
	       break;
	    case RP:		... round-to-+inf
	       if(x>(z+ulp)*(z+ulp)...chopped) z = z+2*ulp; else
	       if(x>z*z ...chopped) z = z+ulp;
	       break;
	}

	Remark 3. The above comparisons can be done in fixed point. For
	example, to compare x and w=z*z chopped, it suffices to compare
	x1 and w1 (the trailing parts of x and w), regarding them as
	two's complement integers.

	...Is z an exact square root?
	To determine whether z is an exact square root of x, let z1 be the
	trailing part of z, and also let x0 and x1 be the leading and
	trailing parts of x.

	If ((z1&0x03ffffff)!=0)	... not exact if trailing 26 bits of z!=0
	    I := 1;		... Raise Inexact flag: z is not exact
	else {
	    j := 1 - [(x0>>20)&1]	... j = logb(x) mod 2
	    k := z1 >> 26;		... get z's 25-th and 26-th 
					    fraction bits
	    I := i or (k&j) or ((k&(j+j+1))!=(x1&3));
	}
	R:= r		... restore rounded mode
	return sqrt(x):=z.

	If multiplication is cheaper then the foregoing red tape, the 
	Inexact flag can be evaluated by

	    I := i;
	    I := (z*z!=x) or I.

	Note that z*z can overwrite I; this value must be sensed if it is 
	True.

	Remark 4. If z*z = x exactly, then bit 25 to bit 0 of z1 must be
	zero.

		    --------------------
		z1: |        f2        | 
		    --------------------
		bit 31		   bit 0

	Further more, bit 27 and 26 of z1, bit 0 and 1 of x1, and the odd
	or even of logb(x) have the following relations:

	-------------------------------------------------
	bit 27,26 of z1		bit 1,0 of x1	logb(x)
	-------------------------------------------------
	00			00		odd and even
	01			01		even
	10			10		odd
	10			00		even
	11			01		even
	-------------------------------------------------

    (4)	Special cases (see (4) of Section A).	
 
 */

/* wrapper sqrt */
double __sqrt(double x)
{
	if (_LIB_VERSION != _IEEE_ && isless(x, 0.0))
		return __kernel_standard(x, x, __builtin_nan(""), KMATHERR_SQRT); /* sqrt(negative) */
	return __ieee754_sqrt(x);
}

__typeof(__sqrt) sqrt __attribute__((weak, alias("__sqrt")));
#ifdef __NO_LONG_DOUBLE_MATH
long double __sqrtl(long double x) __attribute__((alias("__sqrt")));
__typeof(__sqrtl) sqrtl __attribute__((weak, alias("__sqrt")));
#endif

```

`e_sqrtf.c`:

```c
#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_sqrt

float __ieee754_sqrtf(float x)
{
	float z;
	int32_t sign = IC(0x80000000);
	int32_t ix, s, q, m, t, i;
	uint32_t r;

	static const float one = 1.0;
	static const float tiny = 1.0e-30;

	GET_FLOAT_WORD(ix, x);

	/* take care of Inf and NaN */
	if ((ix & IC(0x7f800000)) == IC(0x7f800000))
	{
		return x * x + x;				/* sqrt(NaN)=NaN, sqrt(+inf)=+inf
										   sqrt(-inf)=sNaN */
	}
	/* take care of zero */
	if (ix <= 0)
	{
		if ((ix & (~sign)) == 0)
			return x;					/* sqrt(+-0) = +-0 */
		else if (ix < 0)
			return (x - x) / (x - x);	/* sqrt(-ve) = sNaN */
	}
	/* normalize x */
	m = (ix >> 23);
	if (m == 0)
	{									/* subnormal x */
		for (i = 0; (ix & IC(0x00800000)) == 0; i++)
			ix <<= 1;
		m -= i - 1;
	}
	m -= 127;							/* unbias exponent */
	ix = (ix & IC(0x007fffff)) | IC(0x00800000);
	if (m & 1)							/* odd m, double x to make it even */
		ix += ix;
	m >>= 1;							/* m = [m/2] */

	/* generate sqrt(x) bit by bit */
	ix += ix;
	q = s = 0;							/* q = sqrt(x) */
	r = IC(0x01000000);						/* r = moving bit from right to left */

	while (r != 0)
	{
		t = s + r;
		if (t <= ix)
		{
			s = t + r;
			ix -= t;
			q += r;
		}
		ix += ix;
		r >>= 1;
	}

	/* use floating add to find out rounding direction */
	if (ix != 0)
	{
		z = one - tiny;					/* trigger inexact flag */
		if (z >= one)
		{
			z = one + tiny;
			if (z > one)
				q += 2;
			else
				q += (q & 1);
		}
	}
	ix = (q >> 1) + IC(0x3f000000);
	ix += (m << 23);
	SET_FLOAT_WORD(z, ix);
	return z;
}
#endif

float __sqrtf(float x)
{
	if (isless(x, 0.0) && _LIB_VERSION != _IEEE_)
		return __kernel_standard_f(x, x, __builtin_nanf(""), KMATHERRF_SQRT); /* sqrt(negative) */
	return __ieee754_sqrtf(x);
}

__typeof(__sqrtf) sqrtf __attribute__((weak, alias("__sqrtf")));

```

`e_sqrtl.c`:

```c
/* Emulation for sqrtl.
   Contributed by Paolo Bonzini

   Copyright 2002-2003, 2007, 2009-2013 Free Software Foundation, Inc.

   This file was taken from gnulib.

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2.1 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */


#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

#ifndef __have_fpu_sqrt

/* A simple Newton-Raphson method. */
long double __ieee754_sqrtl(long double x)
{
	long double delta, y;
	int exponent;

	/* Check for NaN */
	if (isnanl(x))
		return x;

	/* Check for negative numbers */
	if (x < 0.0L)
		return (long double) sqrt(-1);

	/* Check for zero and infinites */
	if (x + x == x)
		return x;

	__ieee754_frexpl(x, &exponent);
	y = __ieee754_ldexpl(x, -exponent / 2);

	do
	{
		delta = y;
		y = (y + x / y) * 0.5L;
		delta -= y;
	} while (delta != 0.0L);

	return y;
}

#endif

long double __sqrtl(long double x)
{
	if (isless(x, 0.0) && _LIB_VERSION != _IEEE_)
		return __kernel_standard_l(x, x, __builtin_nanl(""), KMATHERRL_SQRT); /* sqrt(negative) */
	return __ieee754_sqrtl(x);
}

__typeof(__sqrtl) sqrtl __attribute__((weak, alias("__sqrtl")));

#endif

```

`e_tgamma_r.c`:

```c
/* Implementation of gamma function according to ISO C.
   Copyright (C) 1997-2013 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif
#include "fpu_ctrl.h"

/* Calculate X * Y exactly and store the result in *HI + *LO.  It is
   given that the values are small enough that no overflow occurs and
   large enough (or zero) that no underflow occurs.  */

static void gamma_mul_split(double *hi, double *lo, double x, double y)
{
#ifdef __FP_FAST_FMA
	/* Fast built-in fused multiply-add.  */
	*hi = x * y;
	*lo = __builtin_fma(x, y, -*hi);
#elif defined FP_FAST_FMA
	/* Fast library fused multiply-add, compiler before GCC 4.6.  */
	*hi = x * y;
	*lo = fma(x, y, -*hi);
#else
	double x1, y1;
	double x2, y2;
	volatile double tmp, tmp2;
	
	/* Apply Dekker's algorithm.  */
	tmp = x * y;
	*hi = tmp;
# define C 134217729.0 /* (((int32_t)1 << ((DBL_MANT_DIG + 1) / 2)) + 1) */
	tmp = x * C;
	x1 = tmp;
	tmp = y * C;
	y1 = tmp;
	
# undef C
	tmp = x - x1;
	tmp = tmp + x1;
	x1 = tmp;
	tmp = y - y1;
	tmp = tmp + y1;
	y1 = tmp;
	tmp = x - x1;
	x2 = tmp;
	tmp = y - y1;
	y2 = tmp;
	
	tmp = x1 * y1;
	tmp = tmp - *hi;
	tmp2 = x1 * y2;
	tmp += tmp2;
	tmp2 = x2 * y1;
	tmp += tmp2;
	tmp2 = x2 * y2;
	tmp += tmp2;
	*lo = tmp;
#endif
}


/* Compute the product of X + X_EPS, X + X_EPS + 1, ..., X + X_EPS + N
   - 1, in the form R * (1 + *EPS) where the return value R is an
   approximation to the product and *EPS is set to indicate the
   approximate error in the return value.  X is such that all the
   values X + 1, ..., X + N - 1 are exactly representable, and X_EPS /
   X is small enough that factors quadratic in it can be
   neglected.  */

static double __gamma_product(double x, double x_eps, int n, double *eps)
{
	double ret = x;
	int i;
	
	SAVE_AND_SET_ROUND(FE_TONEAREST);
	*eps = x_eps / x;
	for (i = 1; i < n; i++)
	{
		double lo;
		double tmp = x + i;
		*eps += x_eps / tmp;

		gamma_mul_split(&ret, &lo, ret, tmp);
		tmp = lo / ret;
		*eps += tmp;
	}
	RESTORE_ROUND();
	return ret;
}


#ifdef __i386__
static __always_inline void libc_feholdexcept_setround_387_prec (fpu_control_t cw, int r)
{
	cw &= ~(FE_ROUNDING_MASK | FE_PRECISION_MASK);
	cw |= r | 0x3f;
	_FPU_SETCW (cw);
}

#define SET_ROUND_53BIT(r) \
	fpu_control_t cw; \
	_FPU_GETCW(cw); \
	libc_feholdexcept_setround_387_prec(cw, r | _FPU_DOUBLE)

#define RESTORE_ROUND_PREC() \
	_FPU_SETCW (cw)
#endif


#ifdef __mc68000__
static __inline void libc_feholdexcept_setround_68k_prec (fpu_control_t cw, int r)
{
	cw &= ~(FE_ROUNDING_MASK | FE_PRECISION_MASK);
	cw &= ~(FE_ALL_EXCEPT << 6);
	cw |= r;
	_FPU_SETCW (cw);
}

#define SET_ROUND_53BIT(r) \
	fpu_control_t cw; \
	_FPU_GETCW(cw); \
	libc_feholdexcept_setround_68k_prec(cw, r | _FPU_DOUBLE)

#define RESTORE_ROUND_PREC() \
	_FPU_SETCW (cw)
#endif

#ifndef SET_ROUND_53BIT
#  define SET_ROUND_53BIT(r) SAVE_AND_SET_ROUND(r)
#  define RESTORE_ROUND_PREC() RESTORE_ROUND()
#endif


/* Return gamma (X), for positive X less than 184, in the form R *
   2^(*EXP2_ADJ), where R is the return value and *EXP2_ADJ is set to
   avoid overflow or underflow in intermediate calculations.  */

static double gamma_positive(double x, int *exp2_adj)
{
	int local_signgam;

	/* Coefficients B_2k / 2k(2k-1) of x^-(2k-1) inside exp in Stirling's
	   approximation to gamma function.  */
	
	static const double gamma_coeff[] = {
		 0x1.5555555555555p-4,
		-0xb.60b60b60b60b8p-12,
		 0x3.4034034034034p-12,
		-0x2.7027027027028p-12,
		 0x3.72a3c5631fe46p-12,
		-0x7.daac36664f1f4p-12
	};
	
#define NCOEFF (sizeof (gamma_coeff) / sizeof (gamma_coeff[0]))
	
	if (x < 0.5)
	{
		*exp2_adj = 0;
		return __ieee754_exp(__ieee754_lgamma_r(x + 1, &local_signgam)) / x;
	} else if (x <= 1.5)
	{
		*exp2_adj = 0;
		return __ieee754_exp(__ieee754_lgamma_r(x, &local_signgam));
	} else if (x < 6.5)
	{
		/* Adjust into the range for using exp (lgamma).  */
		double n = __ieee754_ceil(x - 1.5);
		double x_adj = x - n;
		double eps;
		double prod = __gamma_product(x_adj, 0, n, &eps);

		*exp2_adj = 0;
		return __ieee754_exp(__ieee754_lgamma_r(x_adj, &local_signgam)) * prod * (1.0 + eps);
	} else
	{
		double eps = 0;
		double x_eps = 0;
		double x_adj = x;
		double prod = 1;
		double exp_adj;
		double x_adj_int;
		double x_adj_frac;
		int x_adj_log2;
		double x_adj_mant;
		double ret;
		double bsum;
		double x_adj2;
		size_t i;
		
		SET_ROUND_53BIT(FE_TONEAREST);
		
		if (x < 12.0)
		{
			/* Adjust into the range for applying Stirling's
			   approximation.  */
			double n = __ieee754_ceil(12.0 - x);
			volatile double x_tmp = x + n;

			x_adj = x_tmp;
			x_eps = (x - (x_adj - n));
			prod = __gamma_product(x_adj - n, x_eps, n, &eps);
		}
		/* The result is now gamma (X_ADJ + X_EPS) / (PROD * (1 + EPS)).
		   Compute gamma (X_ADJ + X_EPS) using Stirling's approximation,
		   starting by computing pow (X_ADJ, X_ADJ) with a power of 2
		   factored out.  */
		exp_adj = -eps;
		x_adj_int = __ieee754_round(x_adj);
		x_adj_frac = x_adj - x_adj_int;
		x_adj_mant = __ieee754_frexp(x_adj, &x_adj_log2);

		if (x_adj_mant < M_SQRT1_2)
		{
			x_adj_log2--;
			x_adj_mant *= 2.0;
		}
		*exp2_adj = x_adj_log2 * (int) x_adj_int;
		ret = __ieee754_pow(x_adj_mant, x_adj)
					  * __ieee754_exp2(x_adj_log2 * x_adj_frac)
					  * __ieee754_exp(-x_adj) * __ieee754_sqrt(2 * M_PI / x_adj) / prod;
		exp_adj += x_eps * __ieee754_log(x_adj);
		bsum = gamma_coeff[NCOEFF - 1];

		x_adj2 = x_adj * x_adj;

		for (i = 1; i <= NCOEFF - 1; i++)
			bsum = bsum / x_adj2 + gamma_coeff[NCOEFF - 1 - i];
		exp_adj += bsum / x_adj;
		ret += ret * __ieee754_expm1(exp_adj);
		RESTORE_ROUND_PREC();
		return ret;
	}
#undef NCOEFF
}


double __ieee754_tgamma_r(double x, int *signgamp)
{
	int32_t hx;
	uint32_t lx;
	volatile double ret;

	GET_DOUBLE_WORDS(hx, lx, x);

	if (((hx & IC(0x7fffffff)) | lx) == 0)
	{
		/* Return value for x == 0 is Inf with divide by zero exception.  */
		*signgamp = 0;
		return 1.0 / x;
	}
	if (hx < 0 && (uint32_t) hx < UC(0xfff00000) && __ieee754_rint(x) == x)
	{
		/* Return value for integer x < 0 is NaN with invalid exception.  */
		*signgamp = 0;
		return (x - x) / (x - x);
	}
	if ((uint32_t) hx == UC(0xfff00000) && lx == 0)
	{
		/* x == -Inf.  According to ISO this is NaN.  */
		*signgamp = 0;
		return x - x;
	}
	if ((hx & IC(0x7ff00000)) == IC(0x7ff00000))
	{
		/* Positive infinity (return positive infinity) or NaN (return
		   NaN).  */
		*signgamp = 0;
		return x + x;
	}

	if (x >= 172.0)
	{
		/* Overflow.  */
		*signgamp = 0;
		ret = DBL_MAX * DBL_MAX;
		return ret;
	} else
	{
		SAVE_AND_SET_ROUND(FE_TONEAREST);
		if (x > 0.0)
		{
			int exp2_adj;
			double tret;
			
			*signgamp = 0;
			tret = gamma_positive(x, &exp2_adj);
			ret = __ieee754_scalbn(tret, exp2_adj);
		} else if (x >= -DBL_EPSILON / 4.0)
		{
			*signgamp = 0;
			ret = 1.0 / x;
		} else
		{
			double tx = __ieee754_trunc(x);

			*signgamp = (tx == 2.0 * __ieee754_trunc(tx / 2.0)) ? -1 : 1;
			if (x <= -184.0)
				/* Underflow.  */
				ret = DBL_MIN * DBL_MIN;
			else
			{
				double frac = tx - x;
				double sinpix;
				int exp2_adj;
				double tret;
				
				if (frac > 0.5)
					frac = 1.0 - frac;
				sinpix = (frac <= 0.25 ? __ieee754_sin(M_PI * frac) : __ieee754_cos(M_PI * (0.5 - frac)));
				tret = M_PI / (-x * sinpix * gamma_positive(-x, &exp2_adj));
				ret = __ieee754_scalbn(tret, -exp2_adj);
			}
		}
		RESTORE_ROUND();
	}
	if (isinf(ret) && x != 0.0)
	{
		if (*signgamp < 0)
		{
			ret = -copysign(DBL_MAX, ret) * DBL_MAX;
			ret = -ret;
		} else
		{
			ret = copysign(DBL_MAX, ret) * DBL_MAX;
		}
	} else if (ret == 0.0)
	{
		if (*signgamp < 0)
		{
			ret = -copysign(DBL_MIN, ret) * DBL_MIN;
			ret = -ret;
		} else
		{
			ret = copysign(DBL_MIN, ret) * DBL_MIN;
		}
	}
	return ret;
}

```

`e_tgammaf_r.c`:

```c
/* Implementation of gamma function according to ISO C.
   Copyright (C) 1997-2013 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif
#include "fpu_ctrl.h"

/* Compute the product of X + X_EPS, X + X_EPS + 1, ..., X + X_EPS + N
   - 1, in the form R * (1 + *EPS) where the return value R is an
   approximation to the product and *EPS is set to indicate the
   approximate error in the return value.  X is such that all the
   values X + 1, ..., X + N - 1 are exactly representable, and X_EPS /
   X is small enough that factors quadratic in it can be
   neglected.  */

static float __gamma_productf(float x, float x_eps, int n, float *eps)
{
	double x_full = (double) x + (double) x_eps;
	double ret = x_full;
	int i;
	volatile float fret;
	
	for (i = 1; i < n; i++)
		ret *= x_full + i;

	fret = (float)ret;

	*eps = (ret - (double)fret) / (double)fret;

	return fret;
}


/* Return gamma (X), for positive X less than 42, in the form R *
   2^(*EXP2_ADJ), where R is the return value and *EXP2_ADJ is set to
   avoid overflow or underflow in intermediate calculations.  */

static float gammaf_positive(float x, int *exp2_adj)
{
	int local_signgam;

	/* Coefficients B_2k / 2k(2k-1) of x^-(2k-1) inside exp in Stirling's
	   approximation to gamma function.  */
	
	static const float gamma_coeff[] = {
		 0x1.555556p-4f,
		-0xb.60b61p-12f,
		 0x3.403404p-12f
	};
	
#define NCOEFF (sizeof (gamma_coeff) / sizeof (gamma_coeff[0]))
	
	if (x < 0.5f)
	{
		*exp2_adj = 0;
		return __ieee754_expf(__ieee754_lgammaf_r(x + 1.0f, &local_signgam)) / x;
	} else if (x <= 1.5f)
	{
		*exp2_adj = 0;
		return __ieee754_expf(__ieee754_lgammaf_r(x, &local_signgam));
	} else if (x < 2.5f)
	{
		float x_adj = x - 1.0f;
		*exp2_adj = 0;

		return __ieee754_expf(__ieee754_lgammaf_r(x_adj, &local_signgam)) * x_adj;
	} else
	{
		float eps = 0;
		float x_eps = 0;
		float x_adj = x;
		float prod = 1;
		float exp_adj;
		float x_adj_int;
		float x_adj_frac;
		int x_adj_log2;
		float x_adj_mant;
		float ret;
		float bsum;
		float x_adj2;
		size_t i;
		
		if (x < 4.0f)
		{
			/* Adjust into the range for applying Stirling's
			   approximation.  */
			float n = __ieee754_ceilf(4.0f - x);

			volatile float x_tmp = x + n;

			x_adj = x_tmp;
			x_eps = (x - (x_adj - n));
			prod = __gamma_productf(x_adj - n, x_eps, n, &eps);
		}
		/* The result is now gamma (X_ADJ + X_EPS) / (PROD * (1 + EPS)).
		   Compute gamma (X_ADJ + X_EPS) using Stirling's approximation,
		   starting by computing pow (X_ADJ, X_ADJ) with a power of 2
		   factored out.  */
		exp_adj = -eps;
		x_adj_int = __ieee754_roundf(x_adj);
		x_adj_frac = x_adj - x_adj_int;
		x_adj_mant = __ieee754_frexpf(x_adj, &x_adj_log2);

		if (x_adj_mant < (float) M_SQRT1_2)
		{
			x_adj_log2--;
			x_adj_mant *= 2.0f;
		}
		*exp2_adj = x_adj_log2 * (int) x_adj_int;
		ret = __ieee754_powf(x_adj_mant, x_adj)
					 * __ieee754_exp2f(x_adj_log2 * x_adj_frac)
					 * __ieee754_expf(-x_adj) * __ieee754_sqrtf(2.0f * (float) M_PI / x_adj) / prod;
		exp_adj += x_eps * __ieee754_logf(x_adj);
		bsum = gamma_coeff[NCOEFF - 1];

		x_adj2 = x_adj * x_adj;

		for (i = 1; i <= NCOEFF - 1; i++)
			bsum = bsum / x_adj2 + gamma_coeff[NCOEFF - 1 - i];
		exp_adj += bsum / x_adj;
		ret += ret * __ieee754_expm1f(exp_adj);
		return ret;
	}
#undef NCOEFF
}


float __ieee754_tgammaf_r(float x, int *signgamp)
{
	int32_t hx;
	volatile float ret;

	GET_FLOAT_WORD(hx, x);

	if ((hx & IC(0x7fffffff)) == 0)
	{
		/* Return value for x == 0 is Inf with divide by zero exception.  */
		*signgamp = 0;
		return 1.0F / x;
	}
	if (hx < 0 && (uint32_t) hx < UC(0xff800000) && __ieee754_rintf(x) == x)
	{
		/* Return value for integer x < 0 is NaN with invalid exception.  */
		*signgamp = 0;
		return (x - x) / (x - x);
	}
	if (hx == IC(0xff800000))
	{
		/* x == -Inf.  According to ISO this is NaN.  */
		*signgamp = 0;
		return x - x;
	}
	if ((hx & IC(0x7f800000)) == IC(0x7f800000))
	{
		/* Positive infinity (return positive infinity) or NaN (return
		   NaN).  */
		*signgamp = 0;
		return x + x;
	}

	if (x >= 36.0f)
	{
		/* Overflow.  */
		*signgamp = 0;
		ret = FLT_MAX * FLT_MAX;
		return ret;
	} else
	{
		SAVE_AND_SET_ROUND(FE_TONEAREST);
		if (x > 0.0f)
		{
			int exp2_adj;
			float tret;
			
			*signgamp = 0;
			tret = gammaf_positive(x, &exp2_adj);
			ret = __ieee754_scalbnf(tret, exp2_adj);
		} else if (x >= -FLT_EPSILON / 4.0f)
		{
			*signgamp = 0;
			ret = 1.0f / x;
		} else
		{
			float tx = __ieee754_truncf(x);
			
			*signgamp = (tx == 2.0f * __ieee754_truncf(tx / 2.0f)) ? -1 : 1;
			if (x <= -42.0f)
				/* Underflow.  */
				ret = FLT_MIN * FLT_MIN;
			else
			{
				float frac = tx - x;
				float sinpix;
				int exp2_adj;
				float tret;
				
				if (frac > 0.5f)
					frac = 1.0f - frac;
				sinpix = (frac <= 0.25f ? __ieee754_sinf((float) M_PI * frac) : __ieee754_cosf((float) M_PI * (0.5f - frac)));
				
				tret = (float) M_PI / (-x * sinpix * gammaf_positive(-x, &exp2_adj));
				ret = __ieee754_scalbnf(tret, -exp2_adj);
			}
		}
		RESTORE_ROUND();
	}
	if (isinf(ret) && x != 0.0f)
	{
		if (*signgamp < 0)
		{
			ret = -copysignf(FLT_MAX, ret) * FLT_MAX;
			ret = -ret;
		} else
		{
			ret = copysignf(FLT_MAX, ret) * FLT_MAX;
		}
	} else if (ret == 0.0f)
	{
		if (*signgamp < 0)
		{
			ret = -copysignf(FLT_MIN, ret) * FLT_MIN;
			ret = -ret;
		} else
		{
			ret = copysignf(FLT_MIN, ret) * FLT_MIN;
		}
	}
	return ret;
}

```

`e_tgammal_r.c`:

```c
/* Implementation of gamma function according to ISO C.
   Copyright (C) 1997-2015 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

/* Calculate X * Y exactly and store the result in *HI + *LO.  It is
   given that the values are small enough that no overflow occurs and
   large enough (or zero) that no underflow occurs.  */

static void gamma_mul_splitl(long double *hi, long double *lo, long double x, long double y)
{
#ifdef __FP_FAST_FMAL
	/* Fast built-in fused multiply-add.  */
	*hi = x * y;
	*lo = __builtin_fmal(x, y, -*hi);
#elif defined FP_FAST_FMAL
	/* Fast library fused multiply-add, compiler before GCC 4.6.  */
	*hi = x * y;
	*lo = fmal(x, y, -*hi);
#else
	/* Apply Dekker's algorithm.  */
	long double x1, y1;
	long double x2, y2;
	
	*hi = x * y;
#define C 4294967297.0L /* ((1LL << ((LDBL_MANT_DIG + 1) / 2)) + 1) */
	x1 = x * C;
	y1 = y * C;

#undef C
	x1 = (x - x1) + x1;
	y1 = (y - y1) + y1;
	x2 = x - x1;
	y2 = y - y1;

	*lo = (((x1 * y1 - *hi) + x1 * y2) + x2 * y1) + x2 * y2;
#endif
}

/* Compute the product of X + X_EPS, X + X_EPS + 1, ..., X + X_EPS + N
   - 1, in the form R * (1 + *EPS) where the return value R is an
   approximation to the product and *EPS is set to indicate the
   approximate error in the return value.  X is such that all the
   values X + 1, ..., X + N - 1 are exactly representable, and X_EPS /
   X is small enough that factors quadratic in it can be
   neglected.  */

static long double __gamma_productl(long double x, long double x_eps, int n, long double *eps)
{
	long double ret = x;
	int i;
	
	SAVE_AND_SET_ROUND(FE_TONEAREST);
	*eps = x_eps / x;
	for (i = 1; i < n; i++)
	{
		long double lo;
		*eps += x_eps / (x + i);

		gamma_mul_splitl(&ret, &lo, ret, x + i);
		*eps += lo / ret;
	}
	RESTORE_ROUND();
	return ret;
}

/* Return gamma (X), for positive X less than 1766, in the form R *
   2^(*EXP2_ADJ), where R is the return value and *EXP2_ADJ is set to
   avoid overflow or underflow in intermediate calculations.  */

static long double gammal_positive(long double x, int *exp2_adj)
{
	int local_signgam;

	/* Coefficients B_2k / 2k(2k-1) of x^-(2k-1) inside exp in Stirling's
	   approximation to gamma function.  */
	
	static const long double gamma_coeff[] = {
		 0x1.5555555555555556p-4L,
		-0xb.60b60b60b60b60bp-12L,
		 0x3.4034034034034034p-12L,
		-0x2.7027027027027028p-12L,
		 0x3.72a3c5631fe46aep-12L,
		-0x7.daac36664f1f208p-12L,
		 0x1.a41a41a41a41a41ap-8L,
		-0x7.90a1b2c3d4e5f708p-8L
	};
	
#define NCOEFF (sizeof (gamma_coeff) / sizeof (gamma_coeff[0]))

	if (x < 0.5L)
	{
		*exp2_adj = 0;
		return __ieee754_expl(__ieee754_lgammal_r(x + 1.0L, &local_signgam)) / x;
	} else if (x <= 1.5L)
	{
		*exp2_adj = 0;
		return __ieee754_expl(__ieee754_lgammal_r(x, &local_signgam));
	} else if (x < 7.5L)
	{
		/* Adjust into the range for using exp (lgamma).  */
		long double n = __ieee754_ceill(x - 1.5L);
		long double x_adj = x - n;
		long double eps;
		long double prod = __gamma_productl(x_adj, 0, n, &eps);

		*exp2_adj = 0;
		return __ieee754_expl(__ieee754_lgammal_r(x_adj, &local_signgam)) * prod * (1.0L + eps);
	} else
	{
		long double eps = 0;
		long double x_eps = 0;
		long double x_adj = x;
		long double prod = 1;
		long double exp_adj;
		long double x_adj_int;
		long double x_adj_frac;
		int x_adj_log2;
		long double x_adj_mant;
		long double ret;
		long double bsum;
		long double x_adj2;
		size_t i;
		
		if (x < 13.0L)
		{
			/* Adjust into the range for applying Stirling's
			   approximation.  */
			long double n = __ieee754_ceill(13.0L - x);

			x_adj = x + n;
			x_eps = (x - (x_adj - n));
			prod = __gamma_productl(x_adj - n, x_eps, n, &eps);
		}
		/* The result is now gamma (X_ADJ + X_EPS) / (PROD * (1 + EPS)).
		   Compute gamma (X_ADJ + X_EPS) using Stirling's approximation,
		   starting by computing pow (X_ADJ, X_ADJ) with a power of 2
		   factored out.  */
		exp_adj = -eps;
		x_adj_int = __ieee754_roundl(x_adj);
		x_adj_frac = x_adj - x_adj_int;
		x_adj_mant = __ieee754_frexpl(x_adj, &x_adj_log2);

		if (x_adj_mant < M_SQRT1_2l)
		{
			x_adj_log2--;
			x_adj_mant *= 2.0L;
		}
		*exp2_adj = x_adj_log2 * (int) x_adj_int;
		ret = __ieee754_powl(x_adj_mant, x_adj)
					  * __ieee754_exp2l(x_adj_log2 * x_adj_frac)
					  * __ieee754_expl(-x_adj) * __ieee754_sqrtl(2 * M_PIl / x_adj) / prod;
		exp_adj += x_eps * __ieee754_logl(x_adj);
		bsum = gamma_coeff[NCOEFF - 1];

		x_adj2 = x_adj * x_adj;

		for (i = 1; i <= NCOEFF - 1; i++)
			bsum = bsum / x_adj2 + gamma_coeff[NCOEFF - 1 - i];
		exp_adj += bsum / x_adj;
		return ret + ret * __ieee754_expm1l(exp_adj);
	}
#undef NCOEFF
}


long double __ieee754_tgammal_r(long double x, int *signgamp)
{
	uint32_t es, hx, lx;
	long double ret;
	
	GET_LDOUBLE_WORDS(es, hx, lx, x);

	if (((es & IEEE854_LONG_DOUBLE_MAXEXP) | hx | lx) == 0)
	{
		/* Return value for x == 0 is Inf with divide by zero exception.  */
		*signgamp = 0;
		return 1.0L / x;
	}
	if (es == UC(0xffffffff) && ((hx & UC(0x7fffffff)) | lx) == 0)
	{
		/* x == -Inf.  According to ISO this is NaN.  */
		*signgamp = 0;
		return x - x;
	}
	if ((es & IEEE854_LONG_DOUBLE_MAXEXP) == IEEE854_LONG_DOUBLE_MAXEXP)
	{
		/* Positive infinity (return positive infinity) or NaN (return
		   NaN).  */
		*signgamp = 0;
		return x + x;
	}
	if ((es & 0x8000) != 0 && __ieee754_rintl(x) == x)
	{
		/* Return value for integer x < 0 is NaN with invalid exception.  */
		*signgamp = 0;
		return (x - x) / (x - x);
	}

	if (x >= 1756.0L)
	{
		/* Overflow.  */
		*signgamp = 0;
		return LDBL_MAX * LDBL_MAX;
	} else
	{
		SAVE_AND_SET_ROUND(FE_TONEAREST);
		if (x > 0.0L)
		{
			int exp2_adj;
			
			*signgamp = 0;
			ret = gammal_positive(x, &exp2_adj);
			ret = __ieee754_scalbnl(ret, exp2_adj);
		} else if (x >= -LDBL_EPSILON / 4.0L)
		{
			*signgamp = 0;
			ret = 1.0L / x;
		} else
		{
			long double tx = __ieee754_truncl(x);
			
			*signgamp = (tx == 2.0L * __ieee754_truncl(tx / 2.0L)) ? -1 : 1;
			if (x <= -1766.0L)
				/* Underflow.  */
				ret = LDBL_MIN * LDBL_MIN;
			else
			{
				long double frac = tx - x;
				long double sinpix;
				int exp2_adj;
				
				if (frac > 0.5L)
					frac = 1.0L - frac;
				sinpix = (frac <= 0.25L ? __ieee754_sinl(M_PIl * frac) : __ieee754_cosl(M_PIl * (0.5L - frac)));
				
				ret = M_PIl / (-x * sinpix * gammal_positive(-x, &exp2_adj));
				ret = __ieee754_scalbnl(ret, -exp2_adj);
			}
		}
		RESTORE_ROUND();
	}
	if (isinf(ret) && x != 0.0L)
	{
		if (*signgamp < 0)
		{
			ret = -copysignl(LDBL_MAX, ret) * LDBL_MAX;
			ret = -ret;
		} else
		{
			ret = copysignl(LDBL_MAX, ret) * LDBL_MAX;
		}
	} else if (ret == 0.0L)
	{
		if (*signgamp < 0)
		{
			ret = -copysignl(LDBL_MIN, ret) * LDBL_MIN;
			ret = -ret;
		} else
		{
			ret = copysignl(LDBL_MIN, ret) * LDBL_MIN;
		}
	}
	return ret;
}

#endif

```

`e_y0.c`:

```c
/* @(#)e_y0.c 5.1 93/09/24 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */
/* Modified by Naohiko Shimizu/Tokai University, Japan 1997/08/26,
   for performance improvement on pipelined processors.
*/
/* __ieee754_y0(x)
 * Bessel function of the second kind of order zero.
 *
 * Method -- y0(x):
 *	1. For x<2.
 *	   Since
 *		y0(x) = 2/pi*(j0(x)*(ln(x/2)+Euler) + x^2/4 - ...)
 *	   therefore y0(x)-2/pi*j0(x)*ln(x) is an even function.
 *	   We use the following function to approximate y0,
 *		y0(x) = U(z)/V(z) + (2/pi)*(j0(x)*ln(x)), z= x^2
 *	   where
 *		U(z) = u00 + u01*z + ... + u06*z^6
 *		V(z) = 1  + v01*z + ... + v04*z^4
 *	   with absolute approximation error bounded by 2**-72.
 *	   Note: For tiny x, U/V = u0 and j0(x)~1, hence
 *		y0(tiny) = u0 + (2/pi)*ln(tiny), (choose tiny<2**-27)
 *	2. For x>=2.
 *		y0(x) = sqrt(2/(pi*x))*(p0(x)*cos(x0)+q0(x)*sin(x0))
 *	   where x0 = x-pi/4. It is better to compute sin(x0),cos(x0)
 *	   by the method mentioned above.
 *	3. Special cases: y0(0)=-inf, y0(x<0)=NaN, y0(inf)=0.
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

double __ieee754_y0(double x)
{
	double z, s, c, ss, cc, u, v, z2, z4, z6, u1, u2, u3, v1, v2;
	int32_t hx, ix, lx;

	static const double one = 1.0;
	static const double zero = 0.0;
	static const double invsqrtpi = 5.64189583547756279280e-01;	/* 0x3FE20DD7, 0x50429B6D */
	static const double tpi = 6.36619772367581382433e-01;	/* 0x3FE45F30, 0x6DC9C883 */

	static const double u00 = -7.38042951086872317523e-02;	/* 0xBFB2E4D6, 0x99CBD01F */
	static const double u01 = 1.76666452509181115538e-01;	/* 0x3FC69D01, 0x9DE9E3FC */
	static const double u02 = -1.38185671945596898896e-02;	/* 0xBF8C4CE8, 0xB16CFA97 */
	static const double u03 = 3.47453432093683650238e-04;	/* 0x3F36C54D, 0x20B29B6B */
	static const double u04 = -3.81407053724364161125e-06;	/* 0xBECFFEA7, 0x73D25CAD */
	static const double u05 = 1.95590137035022920206e-08;	/* 0x3E550057, 0x3B4EABD4 */
	static const double u06 = -3.98205194132103398453e-11;	/* 0xBDC5E43D, 0x693FB3C8 */

	static const double v01 = 1.27304834834123699328e-02;	/* 0x3F8A1270, 0x91C9C71A */
	static const double v02 = 7.60068627350353253702e-05;	/* 0x3F13ECBB, 0xF578C6C1 */
	static const double v03 = 2.59150851840457805467e-07;	/* 0x3E91642D, 0x7FF202FD */
	static const double v04 = 4.41110311332675467403e-10;	/* 0x3DFE5018, 0x3BD6D9EF */

	GET_DOUBLE_WORDS(hx, lx, x);
	ix = IC(0x7fffffff) & hx;
	/* Y0(NaN) is NaN, y0(-inf) is Nan, y0(inf) is 0  */
	if (ix >= IC(0x7ff00000))
		return one / (x + x * x);
	if ((ix | lx) == 0)
		return -HUGE_VAL + x;			/* -inf and overflow exception.  */
	if (hx < 0)
		return zero / zero;
	if (ix >= IC(0x40000000))
	{									/* |x| >= 2.0 */
		/* y0(x) = sqrt(2/(pi*x))*(p0(x)*sin(x0)+q0(x)*cos(x0))
		 * where x0 = x-pi/4
		 *      Better formula:
		 *              cos(x0) = cos(x)cos(pi/4)+sin(x)sin(pi/4)
		 *                      =  1/sqrt(2) * (sin(x) + cos(x))
		 *              sin(x0) = sin(x)cos(3pi/4)-cos(x)sin(3pi/4)
		 *                      =  1/sqrt(2) * (sin(x) - cos(x))
		 * To avoid cancellation, use
		 *              sin(x) +- cos(x) = -cos(2x)/(sin(x) -+ cos(x))
		 * to compute the worse one.
		 */
		__ieee754_sincos(x, &s, &c);
		ss = s - c;
		cc = s + c;
		/*
		 * j0(x) = 1/sqrt(pi) * (P(0,x)*cc - Q(0,x)*ss) / sqrt(x)
		 * y0(x) = 1/sqrt(pi) * (P(0,x)*ss + Q(0,x)*cc) / sqrt(x)
		 */
		if (ix < IC(0x7fe00000))
		{								/* make sure x+x not overflow */
			z = -__ieee754_cos(x + x);
			if ((s * c) < zero)
				cc = z / ss;
			else
				ss = z / cc;
		}
		if (ix > IC(0x48000000))
			z = (invsqrtpi * ss) / __ieee754_sqrt(x);
		else
		{
			u = __j0_y0_pzero(x);
			v = __j0_y0_qzero(x);
			z = invsqrtpi * (u * ss + v * cc) / __ieee754_sqrt(x);
		}
		return z;
	}
	if (ix <= IC(0x3e400000))
	{									/* x < 2**-27 */
		return (u00 + tpi * __ieee754_log(x));
	}
	z = x * x;
#ifdef DO_NOT_USE_THIS
	u = u00 + z * (u01 + z * (u02 + z * (u03 + z * (u04 + z * (u05 + z * u06)))));
	v = one + z * (v01 + z * (v02 + z * (v03 + z * v04)));
#else
	u1 = u00 + z * u01;
	z2 = z * z;
	u2 = u02 + z * u03;
	z4 = z2 * z2;
	u3 = u04 + z * u05;
	z6 = z4 * z2;
	u = u1 + z2 * u2 + z4 * u3 + z6 * u06;
	v1 = one + z * v01;
	v2 = v02 + z * v03;
	v = v1 + z2 * v2 + z4 * v04;
#endif
	return (u / v + tpi * (__ieee754_j0(x) * __ieee754_log(x)));
}

/* wrapper y0 */
double __y0(double x)
{
	if ((islessequal(x, 0.0) || isgreater(x, X_TLOSS)) && _LIB_VERSION != _IEEE_)
	{
		if (x < 0.0)
		{
			/* d = zero/(x-x) */
			feraiseexcept(FE_INVALID);
			return __kernel_standard(x, x, -HUGE_VAL, KMATHERR_Y0_MINUS);
		} else if (x == 0.0)
			/* d = -one/(x-x) */
			return __kernel_standard(x, x, -HUGE_VAL, KMATHERR_Y0_ZERO);
		else if (_LIB_VERSION != _POSIX_)
			/* y0(x>X_TLOSS) */
			return __kernel_standard(x, x, 0.0, KMATHERR_Y0_TLOSS);
	}

	return __ieee754_y0(x);
}

__typeof(__y0) y0 __attribute__((weak, alias("__y0")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(__y0l) __y0l __attribute__((alias("__y0")));
__typeof(__y0l) y0l __attribute__((weak, alias("__y0l")));
#endif

```

`e_y0f.c`:

```c
/* e_y0f.c -- float version of e_y0.c.
 * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif


float __ieee754_y0f(float x)
{
	float z, s, c, ss, cc, u, v;
	int32_t hx, ix;

	static const float one = 1.0;
	static const float invsqrtpi = 5.6418961287e-01;		/* 0x3f106ebb */
	static const float tpi = 6.3661974669e-01;				/* 0x3f22f983 */
	static const float zero = 0.0;
	
	static const float u00 = -7.3804296553e-02;				/* 0xbd9726b5 */
	static const float u01 = 1.7666645348e-01;				/* 0x3e34e80d */
	static const float u02 = -1.3818567619e-02;				/* 0xbc626746 */
	static const float u03 = 3.4745343146e-04;				/* 0x39b62a69 */
	static const float u04 = -3.8140706238e-06;				/* 0xb67ff53c */
	static const float u05 = 1.9559013964e-08;				/* 0x32a802ba */
	static const float u06 = -3.9820518410e-11;				/* 0xae2f21eb */
	static const float v01 = 1.2730483897e-02;				/* 0x3c509385 */
	static const float v02 = 7.6006865129e-05;				/* 0x389f65e0 */
	static const float v03 = 2.5915085189e-07;				/* 0x348b216c */
	static const float v04 = 4.4111031494e-10;				/* 0x2ff280c2 */
	
	GET_FLOAT_WORD(hx, x);
	ix = IC(0x7fffffff) & hx;
	/* Y0(NaN) is NaN, y0(-inf) is Nan, y0(inf) is 0, y0(0) is -inf.  */
	if (!FLT_UWORD_IS_FINITE(ix))
		return one / (x + x * x);
	if (FLT_UWORD_IS_ZERO(ix))
		return -HUGE_VALF + x;			/* -inf and overflow exception.  */
	if (hx < 0)
		return zero / (zero * x);
	if (ix >= IC(0x40000000))
	{									/* |x| >= 2.0 */
		/* y0(x) = sqrt(2/(pi*x))*(p0(x)*sin(x0)+q0(x)*cos(x0))
		 * where x0 = x-pi/4
		 *      Better formula:
		 *              cos(x0) = cos(x)cos(pi/4)+sin(x)sin(pi/4)
		 *                      =  1/sqrt(2) * (sin(x) + cos(x))
		 *              sin(x0) = sin(x)cos(3pi/4)-cos(x)sin(3pi/4)
		 *                      =  1/sqrt(2) * (sin(x) - cos(x))
		 * To avoid cancellation, use
		 *              sin(x) +- cos(x) = -cos(2x)/(sin(x) -+ cos(x))
		 * to compute the worse one.
		 */
		__ieee754_sincosf(x, &s, &c);
		ss = s - c;
		cc = s + c;
		/*
		 * j0(x) = 1/sqrt(pi) * (P(0,x)*cc - Q(0,x)*ss) / sqrt(x)
		 * y0(x) = 1/sqrt(pi) * (P(0,x)*ss + Q(0,x)*cc) / sqrt(x)
		 */
		if (ix <= FLT_UWORD_HALF_MAX)
		{								/* make sure x+x not overflow */
			z = -__ieee754_cosf(x + x);
			if ((s * c) < zero)
				cc = z / ss;
			else
				ss = z / cc;
		}
		if (ix > IC(0x48000000))
			z = (invsqrtpi * ss) / __ieee754_sqrtf(x);
		else
		{
			u = __j0_y0_pzerof(x);
			v = __j0_y0_qzerof(x);
			z = invsqrtpi * (u * ss + v * cc) / __ieee754_sqrtf(x);
		}
		return z;
	}
	if (ix <= IC(0x39800000))
	{									/* x < 2**-13 */
		return (u00 + tpi * __ieee754_logf(x));
	}
	z = x * x;
	u = u00 + z * (u01 + z * (u02 + z * (u03 + z * (u04 + z * (u05 + z * u06)))));
	v = one + z * (v01 + z * (v02 + z * (v03 + z * v04)));
	return (u / v + tpi * (__ieee754_j0f(x) * __ieee754_logf(x)));
}

/* wrapper y0 */
float __y0f(float x)
{
	if ((islessequal(x, 0.0F) || isgreater(x, X_TLOSS)) && _LIB_VERSION != _IEEE_)
	{
		if (x < 0.0F)
		{
			/* d = zero/(x-x) */
			feraiseexcept(FE_INVALID);
			return __kernel_standard_f(x, x, -HUGE_VALF, KMATHERRF_Y0_MINUS);
		} else if (x == 0.0F)
			/* d = -one/(x-x) */
			return __kernel_standard_f(x, x, -HUGE_VALF, KMATHERRF_Y0_ZERO);
		else if (_LIB_VERSION != _POSIX_)
			/* y0(x>X_TLOSS) */
			return __kernel_standard_f(x, x, 0.0f, KMATHERRF_Y0_TLOSS);
	}

	return __ieee754_y0f(x);
}

__typeof(__y0f) y0f __attribute__((weak, alias("__y0f")));

```

`e_y0l.c`:

```c
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/* Long double expansions are
  Copyright (C) 2001 Stephen L. Moshier <moshier@na-net.ornl.gov>
  and are incorporated herein by permission of the author.  The author
  reserves the right to distribute this material elsewhere under different
  copying permissions.  These modifications are distributed here under
  the following terms:

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, see
    <http://www.gnu.org/licenses/>.  */

/* __ieee754_y0(x)
 * Bessel function of the second kind of order zero.
 * Method -- y0(x):
 *	1. For x<2.
 *	   Since
 *		y0(x) = 2/pi*(j0(x)*(ln(x/2)+Euler) + x^2/4 - ...)
 *	   therefore y0(x)-2/pi*j0(x)*ln(x) is an even function.
 *	   We use the following function to approximate y0,
 *		y0(x) = U(z)/V(z) + (2/pi)*(j0(x)*ln(x)), z= x^2
 *
 *	   Note: For tiny x, U/V = u0 and j0(x)~1, hence
 *		y0(tiny) = u0 + (2/pi)*ln(tiny), (choose tiny<2**-27)
 *	2. For x>=2.
 *		y0(x) = sqrt(2/(pi*x))*(p0(x)*cos(x0)+q0(x)*sin(x0))
 *	   where x0 = x-pi/4. It is better to compute sin(x0),cos(x0)
 *	   by the method mentioned above.
 *	3. Special cases: y0(0)=-inf, y0(x<0)=NaN, y0(inf)=0.
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

long double __ieee754_y0l(long double x)
{
	long double z, s, c, ss, cc, u, v;
	int32_t ix;
	uint32_t se, i0, i1;

	static const long double one = 1.0L;
	static const long double invsqrtpi = 5.6418958354775628694807945156077258584405e-1L;
	static const long double tpi = 6.3661977236758134307553505349005744813784e-1L;
	static const long double zero = 0.0;
	
	/* y0(x) = 2/pi ln(x) J0(x) + U(x^2)/V(x^2)
	   0 < x <= 2
	   peak relative error 1.7e-21 */
	static const long double U[6] = {
		-1.054912306975785573710813351985351350861E10L,
		2.520192609749295139432773849576523636127E10L,
		-1.856426071075602001239955451329519093395E9L,
		4.079209129698891442683267466276785956784E7L,
		-3.440684087134286610316661166492641011539E5L,
		1.005524356159130626192144663414848383774E3L,
	};
	
	static const long double V[5] = {
		1.429337283720789610137291929228082613676E11L,
		2.492593075325119157558811370165695013002E9L,
		2.186077620785925464237324417623665138376E7L,
		1.238407896366385175196515057064384929222E5L,
		4.693924035211032457494368947123233101664E2L,
		/*  1.000000000000000000000000000000000000000E0L */
	};
	
	GET_LDOUBLE_WORDS(se, i0, i1, x);
	ix = se & IEEE854_LONG_DOUBLE_MAXEXP;
	/* Y0(NaN) is NaN, y0(-inf) is Nan, y0(inf) is 0  */
	if (se & 0x8000)
		return zero / (zero * x);
	if (ix >= IEEE854_LONG_DOUBLE_MAXEXP)
		return one / (x + x * x);
	if ((i0 | i1) == 0)
		return -HUGE_VALL + x;			/* -inf and overflow exception.  */
	if (ix >= 0x4000)
	{									/* |x| >= 2.0 */

		/* y0(x) = sqrt(2/(pi*x))*(p0(x)*sin(x0)+q0(x)*cos(x0))
		 * where x0 = x-pi/4
		 *      Better formula:
		 *              cos(x0) = cos(x)cos(pi/4)+sin(x)sin(pi/4)
		 *                      =  1/sqrt(2) * (sin(x) + cos(x))
		 *              sin(x0) = sin(x)cos(3pi/4)-cos(x)sin(3pi/4)
		 *                      =  1/sqrt(2) * (sin(x) - cos(x))
		 * To avoid cancellation, use
		 *              sin(x) +- cos(x) = -cos(2x)/(sin(x) -+ cos(x))
		 * to compute the worse one.
		 */
		__ieee754_sincosl(x, &s, &c);
		ss = s - c;
		cc = s + c;
		/*
		 * j0(x) = 1/sqrt(pi) * (P(0,x)*cc - Q(0,x)*ss) / sqrt(x)
		 * y0(x) = 1/sqrt(pi) * (P(0,x)*ss + Q(0,x)*cc) / sqrt(x)
		 */
		if (ix < 0x7ffe)
		{								/* make sure x+x not overflow */
			z = -__ieee754_cosl(x + x);
			if ((s * c) < zero)
				cc = z / ss;
			else
				ss = z / cc;
		}
		if (ix > 0x4080)	/* 1e39 */
			z = (invsqrtpi * ss) / __ieee754_sqrtl(x);
		else
		{
			u = __j0_y0_pzerol(x);
			v = __j0_y0_qzerol(x);
			z = invsqrtpi * (u * ss + v * cc) / __ieee754_sqrtl(x);
		}
		return z;
	}
	if (ix <= 0x3fde)	/* x < 2^-33 */
	{
		z = -7.380429510868722527629822444004602747322E-2L + tpi * __ieee754_logl(x);
		return z;
	}
	z = x * x;
	u = U[0] + z * (U[1] + z * (U[2] + z * (U[3] + z * (U[4] + z * U[5]))));
	v = V[0] + z * (V[1] + z * (V[2] + z * (V[3] + z * (V[4] + z))));
	return (u / v + tpi * (__ieee754_j0l(x) * __ieee754_logl(x)));
}

/* wrapper y0 */
long double __y0l(long double x)
{
	if ((islessequal(x, 0.0) || isgreater(x, X_TLOSS)) && _LIB_VERSION != _IEEE_)
	{
		if (x < 0.0)
		{
			/* d = zero/(x-x) */
			feraiseexcept(FE_INVALID);
			return __kernel_standard_l(x, x, -HUGE_VALL, KMATHERRL_Y0_MINUS);
		} else if (x == 0.0)
			/* d = -one/(x-x) */
			return __kernel_standard_l(x, x, -HUGE_VALL, KMATHERRL_Y0_ZERO);
		else if (_LIB_VERSION != _POSIX_)
			/* y0(x>X_TLOSS) */
			return __kernel_standard_l(x, x, 0.0L, KMATHERRL_Y0_TLOSS);
	}

	return __ieee754_y0l(x);
}

__typeof(__y0l) y0l __attribute__((weak, alias("__y0l")));

#endif

```

`e_y1.c`:

```c
/* @(#)e_y1.c 5.1 93/09/24 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */
/* Modified by Naohiko Shimizu/Tokai University, Japan 1997/08/26,
   for performance improvement on pipelined processors.
*/

/* __ieee754_y1(x)
 * Bessel function of the second kind of order one.
 * Method -- y1(x):
 *	1. screen out x<=0 cases: y1(0)=-inf, y1(x<0)=NaN
 *	2. For x<2.
 *	   Since
 *		y1(x) = 2/pi*(j1(x)*(ln(x/2)+Euler)-1/x-x/2+5/64*x^3-...)
 *	   therefore y1(x)-2/pi*j1(x)*ln(x)-1/x is an odd function.
 *	   We use the following function to approximate y1,
 *		y1(x) = x*U(z)/V(z) + (2/pi)*(j1(x)*ln(x)-1/x), z= x^2
 *	   where for x in [0,2] (abs err less than 2**-65.89)
 *		U(z) = U0[0] + U0[1]*z + ... + U0[4]*z^4
 *		V(z) = 1  + v0[0]*z + ... + v0[4]*z^5
 *	   Note: For tiny x, 1/x dominate y1 and hence
 *		y1(tiny) = -2/pi/tiny, (choose tiny<2**-54)
 *	3. For x>=2.
 *		y1(x) = sqrt(2/(pi*x))*(p1(x)*sin(x1)+q1(x)*cos(x1))
 *	   where x1 = x-3*pi/4. It is better to compute sin(x1),cos(x1)
 *	   by method mentioned above.
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

double __ieee754_y1(double x)
{
	double z, s, c, ss, cc, u, v, u1, u2, v1, v2, v3, z2, z4;
	int32_t hx, ix, lx;

	static const double one = 1.0;
	static const double invsqrtpi = 5.64189583547756279280e-01;	/* 0x3FE20DD7, 0x50429B6D */
	static const double tpi = 6.36619772367581382433e-01;	/* 0x3FE45F30, 0x6DC9C883 */
	static const double zero = 0.0;

	static const double U0[5] = {
		-1.96057090646238940668e-01,		/* 0xBFC91866, 0x143CBC8A */
		5.04438716639811282616e-02,			/* 0x3FA9D3C7, 0x76292CD1 */
		-1.91256895875763547298e-03,		/* 0xBF5F55E5, 0x4844F50F */
		2.35252600561610495928e-05,			/* 0x3EF8AB03, 0x8FA6B88E */
		-9.19099158039878874504e-08			/* 0xBE78AC00, 0x569105B8 */
	};

	static const double V0[5] = {
		1.99167318236649903973e-02,			/* 0x3F94650D, 0x3F4DA9F0 */
		2.02552581025135171496e-04,			/* 0x3F2A8C89, 0x6C257764 */
		1.35608801097516229404e-06,			/* 0x3EB6C05A, 0x894E8CA6 */
		6.22741452364621501295e-09,			/* 0x3E3ABF1D, 0x5BA69A86 */
		1.66559246207992079114e-11			/* 0x3DB25039, 0xDACA772A */
	};

	GET_DOUBLE_WORDS(hx, lx, x);
	ix = IC(0x7fffffff) & hx;
	/* if Y1(NaN) is NaN, Y1(-inf) is NaN, Y1(inf) is 0 */
	if (ix >= IC(0x7ff00000))
		return one / (x + x * x);
	if ((ix | lx) == 0)
		return -HUGE_VAL + x; /* -inf and overflow exception.  */ ;
	if (hx < 0)
		return zero / zero;
	if (ix >= IC(0x40000000))
	{									/* |x| >= 2.0 */
		__ieee754_sincos(x, &s, &c);
		ss = -s - c;
		cc = s - c;
		if (ix < IC(0x7fe00000))
		{								/* make sure x+x not overflow */
			z = __ieee754_cos(x + x);
			if ((s * c) > zero)
				cc = z / ss;
			else
				ss = z / cc;
		}
		/* y1(x) = sqrt(2/(pi*x))*(p1(x)*sin(x0)+q1(x)*cos(x0))
		 * where x0 = x-3pi/4
		 *      Better formula:
		 *              cos(x0) = cos(x)cos(3pi/4)+sin(x)sin(3pi/4)
		 *                      =  1/sqrt(2) * (sin(x) - cos(x))
		 *              sin(x0) = sin(x)cos(3pi/4)-cos(x)sin(3pi/4)
		 *                      = -1/sqrt(2) * (cos(x) + sin(x))
		 * To avoid cancellation, use
		 *              sin(x) +- cos(x) = -cos(2x)/(sin(x) -+ cos(x))
		 * to compute the worse one.
		 */
		if (ix > IC(0x48000000))
			z = (invsqrtpi * ss) / __ieee754_sqrt(x);
		else
		{
			u = __j1_y1_pone(x);
			v = __j1_y1_qone(x);
			z = invsqrtpi * (u * ss + v * cc) / __ieee754_sqrt(x);
		}
		return z;
	}
	if (ix <= IC(0x3c900000))
	{									/* x < 2**-54 */
		return (-tpi / x);
	}
	z = x * x;
#ifdef DO_NOT_USE_THIS
	u = U0[0] + z * (U0[1] + z * (U0[2] + z * (U0[3] + z * U0[4])));
	v = one + z * (V0[0] + z * (V0[1] + z * (V0[2] + z * (V0[3] + z * V0[4]))));
#else
	u1 = U0[0] + z * U0[1];
	z2 = z * z;
	u2 = U0[2] + z * U0[3];
	z4 = z2 * z2;
	u = u1 + z2 * u2 + z4 * U0[4];
	v1 = one + z * V0[0];
	v2 = V0[1] + z * V0[2];
	v3 = V0[3] + z * V0[4];
	v = v1 + z2 * v2 + z4 * v3;
#endif
	return (x * (u / v) + tpi * (__ieee754_j1(x) * __ieee754_log(x) - one / x));
}

/* wrapper y1 */
double __y1(double x)
{
	if ((islessequal(x, 0.0) || isgreater(x, X_TLOSS)) && _LIB_VERSION != _IEEE_)
	{
		if (x < 0.0)
		{
			/* d = zero/(x-x) */
			feraiseexcept(FE_INVALID);
			return __kernel_standard(x, x, -HUGE_VAL, KMATHERR_Y1_MINUS);
		} else if (x == 0.0)
			/* d = -one/(x-x) */
			return __kernel_standard(x, x, -HUGE_VAL, KMATHERR_Y1_ZERO);
		else if (_LIB_VERSION != _POSIX_)
			/* y1(x>X_TLOSS) */
			return __kernel_standard(x, x, 0.0, KMATHERR_Y1_TLOSS);
	}

	return __ieee754_y1(x);
}

__typeof(__y1) y1 __attribute__((weak, alias("__y1")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(__y1l) __y1l __attribute__((alias("__y1")));
__typeof(__y1l) y1l __attribute__((weak, alias("__y1l")));
#endif

```

`e_y1f.c`:

```c
/* e_y1f.c -- float version of e_y1.c.
 * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

float __ieee754_y1f(float x)
{
	float z, s, c, ss, cc, u, v;
	int32_t hx, ix;

	static const float one = 1.0;
	static const float invsqrtpi = 5.6418961287e-01;		/* 0x3f106ebb */
	static const float tpi = 6.3661974669e-01;				/* 0x3f22f983 */
	static const float zero = 0.0;

	static const float U0[5] = {
		-1.9605709612e-01,					/* 0xbe48c331 */
		5.0443872809e-02,					/* 0x3d4e9e3c */
		-1.9125689287e-03,					/* 0xbafaaf2a */
		2.3525259166e-05,					/* 0x37c5581c */
		-9.1909917899e-08					/* 0xb3c56003 */
	};
	
	static const float V0[5] = {
		1.9916731864e-02,					/* 0x3ca3286a */
		2.0255257550e-04,					/* 0x3954644b */
		1.3560879779e-06,					/* 0x35b602d4 */
		6.2274145840e-09,					/* 0x31d5f8eb */
		1.6655924903e-11					/* 0x2d9281cf */
	};
	
	GET_FLOAT_WORD(hx, x);
	ix = IC(0x7fffffff) & hx;
	/* if Y1(NaN) is NaN, Y1(-inf) is NaN, Y1(inf) is 0 */
	if (!FLT_UWORD_IS_FINITE(ix))
		return one / (x + x * x);
	if (FLT_UWORD_IS_ZERO(ix))
		return -HUGE_VALF + x;			/* -inf and overflow exception.  */
	if (hx < 0)
		return zero / (zero * x);
	if (ix >= IC(0x40000000))
	{									/* |x| >= 2.0 */
		__ieee754_sincosf(x, &s, &c);
		ss = -s - c;
		cc = s - c;
		if (ix <= FLT_UWORD_HALF_MAX)
		{								/* make sure x+x not overflow */
			z = __ieee754_cosf(x + x);
			if ((s * c) > zero)
				cc = z / ss;
			else
				ss = z / cc;
		}
		/* y1(x) = sqrt(2/(pi*x))*(p1(x)*sin(x0)+q1(x)*cos(x0))
		 * where x0 = x-3pi/4
		 *      Better formula:
		 *              cos(x0) = cos(x)cos(3pi/4)+sin(x)sin(3pi/4)
		 *                      =  1/sqrt(2) * (sin(x) - cos(x))
		 *              sin(x0) = sin(x)cos(3pi/4)-cos(x)sin(3pi/4)
		 *                      = -1/sqrt(2) * (cos(x) + sin(x))
		 * To avoid cancellation, use
		 *              sin(x) +- cos(x) = -cos(2x)/(sin(x) -+ cos(x))
		 * to compute the worse one.
		 */
		if (ix > IC(0x48000000))
			z = (invsqrtpi * ss) / __ieee754_sqrtf(x);
		else
		{
			u = __j1_y1_ponef(x);
			v = __j1_y1_qonef(x);
			z = invsqrtpi * (u * ss + v * cc) / __ieee754_sqrtf(x);
		}
		return z;
	}
	if (ix <= IC(0x33000000))
	{									/* x < 2**-25 */
		return (-tpi / x);
	}
	z = x * x;
	u = U0[0] + z * (U0[1] + z * (U0[2] + z * (U0[3] + z * U0[4])));
	v = one + z * (V0[0] + z * (V0[1] + z * (V0[2] + z * (V0[3] + z * V0[4]))));
	return (x * (u / v) + tpi * (__ieee754_j1f(x) * __ieee754_logf(x) - one / x));
}

/* wrapper y1 */
float __y1f(float x)
{
	if ((islessequal(x, 0.0F) || isgreater(x, X_TLOSS)) && _LIB_VERSION != _IEEE_)
	{
		if (x < 0.0F)
		{
			/* d = zero/(x-x) */
			feraiseexcept(FE_INVALID);
			return __kernel_standard_f(x, x, -HUGE_VALF, KMATHERRF_Y1_MINUS);
		} else if (x == 0.0F)
			/* d = -one/(x-x) */
			return __kernel_standard_f(x, x, -HUGE_VALF, KMATHERRF_Y1_ZERO);
		else if (_LIB_VERSION != _POSIX_)
			/* y1(x>X_TLOSS) */
			return __kernel_standard_f(x, x, 0.0f, KMATHERRF_Y1_TLOSS);
	}

	return __ieee754_y1f(x);
}

__typeof(__y1f) y1f __attribute__((weak, alias("__y1f")));

```

`e_y1l.c`:

```c
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/* Long double expansions are
  Copyright (C) 2001 Stephen L. Moshier <moshier@na-net.ornl.gov>
  and are incorporated herein by permission of the author.  The author
  reserves the right to distribute this material elsewhere under different
  copying permissions.  These modifications are distributed here under
  the following terms:

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, see
    <http://www.gnu.org/licenses/>.  */

/* __ieee754_y1(x)
 * Bessel function of the second kind of order one.
 * Method -- y1(x):
 *	1. screen out x<=0 cases: y1(0)=-inf, y1(x<0)=NaN
 *	2. For x<2.
 *	   Since
 *		y1(x) = 2/pi*(j1(x)*(ln(x/2)+Euler)-1/x-x/2+5/64*x^3-...)
 *	   therefore y1(x)-2/pi*j1(x)*ln(x)-1/x is an odd function.
 *	   We use the following function to approximate y1,
 *		y1(x) = x*U(z)/V(z) + (2/pi)*(j1(x)*ln(x)-1/x), z= x^2
 *	   Note: For tiny x, 1/x dominate y1 and hence
 *		y1(tiny) = -2/pi/tiny
 *	3. For x>=2.
 *		y1(x) = sqrt(2/(pi*x))*(p1(x)*sin(x1)+q1(x)*cos(x1))
 *	   where x1 = x-3*pi/4. It is better to compute sin(x1),cos(x1)
 *	   by method mentioned above.
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

long double __ieee754_y1l(long double x)
{
	long double z, s, c, ss, cc, u, v;
	int32_t ix;
	uint32_t se, i0, i1;

	static const long double one = 1.0L;
	static const long double invsqrtpi = 5.6418958354775628694807945156077258584405e-1L;
	static const long double tpi = 6.3661977236758134307553505349005744813784e-1L;
	static const long double zero = 0.0;
	
	/* Y1(x) = 2/pi * (log(x) * j1(x) - 1/x) + x R(x^2)
	   0 <= x <= 2
	   Peak relative error 2.3e-23 */
	static const long double U0[6] = {
		-5.908077186259914699178903164682444848615E10L,
		1.546219327181478013495975514375773435962E10L,
		-6.438303331169223128870035584107053228235E8L,
		9.708540045657182600665968063824819371216E6L,
		-6.138043997084355564619377183564196265471E4L,
		1.418503228220927321096904291501161800215E2L
	};
	
	static const long double V0[5] = {
		3.013447341682896694781964795373783679861E11L,
		4.669546565705981649470005402243136124523E9L,
		3.595056091631351184676890179233695857260E7L,
		1.761554028569108722903944659933744317994E5L,
		5.668480419646516568875555062047234534863E2L
		/*  1.000000000000000000000000000000000000000E0L, */
	};
	
	GET_LDOUBLE_WORDS(se, i0, i1, x);
	ix = se & IEEE854_LONG_DOUBLE_MAXEXP;
	/* if Y1(NaN) is NaN, Y1(-inf) is NaN, Y1(inf) is 0 */
	if (se & 0x8000)
		return zero / (zero * x);
	if (ix >= IEEE854_LONG_DOUBLE_MAXEXP)
		return one / (x + x * x);
	if ((i0 | i1) == 0)
		return -HUGE_VALL + x;			/* -inf and overflow exception.  */
	if (ix >= 0x4000)
	{									/* |x| >= 2.0 */
		__ieee754_sincosl(x, &s, &c);
		ss = -s - c;
		cc = s - c;
		if (ix < 0x7ffe)
		{								/* make sure x+x not overflow */
			z = __ieee754_cosl(x + x);
			if ((s * c) > zero)
				cc = z / ss;
			else
				ss = z / cc;
		}
		/* y1(x) = sqrt(2/(pi*x))*(p1(x)*sin(x0)+q1(x)*cos(x0))
		 * where x0 = x-3pi/4
		 *      Better formula:
		 *              cos(x0) = cos(x)cos(3pi/4)+sin(x)sin(3pi/4)
		 *                      =  1/sqrt(2) * (sin(x) - cos(x))
		 *              sin(x0) = sin(x)cos(3pi/4)-cos(x)sin(3pi/4)
		 *                      = -1/sqrt(2) * (cos(x) + sin(x))
		 * To avoid cancellation, use
		 *              sin(x) +- cos(x) = -cos(2x)/(sin(x) -+ cos(x))
		 * to compute the worse one.
		 */
		if (ix > 0x4080)
			z = (invsqrtpi * ss) / __ieee754_sqrtl(x);
		else
		{
			u = __j1_y1_ponel(x);
			v = __j1_y1_qonel(x);
			z = invsqrtpi * (u * ss + v * cc) / __ieee754_sqrtl(x);
		}
		return z;
	}
	if (ix <= 0x3fbe)
	{									/* x < 2**-65 */
		return (-tpi / x);
	}
	z = x * x;
	u = U0[0] + z * (U0[1] + z * (U0[2] + z * (U0[3] + z * (U0[4] + z * U0[5]))));
	v = V0[0] + z * (V0[1] + z * (V0[2] + z * (V0[3] + z * (V0[4] + z))));
	return (x * (u / v) + tpi * (__ieee754_j1l(x) * __ieee754_logl(x) - one / x));
}

/* wrapper y1 */
long double __y1l(long double x)
{
	if ((islessequal(x, 0.0) || isgreater(x, X_TLOSS)) && _LIB_VERSION != _IEEE_)
	{
		if (x < 0.0)
		{
			/* d = zero/(x-x) */
			feraiseexcept(FE_INVALID);
			return __kernel_standard_l(x, x, -HUGE_VALL, KMATHERRL_Y1_MINUS);
		} else if (x == 0.0)
			/* d = -one/(x-x) */
			return __kernel_standard_l(x, x, -HUGE_VALL, KMATHERRL_Y1_ZERO);
		else if (_LIB_VERSION != _POSIX_)
			/* y1(x>X_TLOSS) */
			return __kernel_standard_l(x, x, 0.0l, KMATHERRL_Y1_TLOSS);
	}

	return __ieee754_y1l(x);
}

__typeof(__y1l) y1l __attribute__((weak, alias("__y1l")));

#endif

```

`e_yn.c`:

```c
/* @(#)e_yn.c 5.1 93/09/24 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/*
 * __ieee754_yn(n, x)
 * floating point Bessel's function of the 1st and 2nd kind
 * of order n
 *
 * Special cases:
 *	y0(0)=y1(0)=yn(n,0) = -inf with overflow signal;
 *	y0(-ve)=y1(-ve)=yn(n,-ve) are NaN with invalid signal.
 * Note 2. About jn(n,x), yn(n,x)
 *	For n=0, j0(x) is called,
 *	for n=1, j1(x) is called,
 *	for n<x, forward recursion us used starting
 *	from values of j0(x) and j1(x).
 *	for n>x, a continued fraction approximation to
 *	j(n,x)/j(n-1,x) is evaluated and then backward
 *	recursion is used starting from a supposed value
 *	for j(n,x). The resulting value of j(0,x) is
 *	compared with the actual value to correct the
 *	supposed value of j(n,x).
 *
 *	yn(n,x) is similar in all respects, except
 *	that forward recursion is used for all
 *	values of n>1.
 *
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

double __ieee754_yn(int n, double x)
{
	int32_t i, hx, ix, lx;
	int32_t sign;
	double a, b, temp;

	static const double invsqrtpi = 5.64189583547756279280e-01;	/* 0x3FE20DD7, 0x50429B6D */
	static const double zero = 0.00000000000000000000e+00;
	
	GET_DOUBLE_WORDS(hx, lx, x);
	ix = IC(0x7fffffff) & hx;
	/* if Y(n,NaN) is NaN */
	if ((ix | (((uint32_t) (lx | -lx)) >> 31)) > IC(0x7ff00000))
		return x + x;
	if ((ix | lx) == 0)
		return -HUGE_VAL + x; /* -inf and overflow exception.  */ ;
	if (hx < 0)
		return zero / zero;
	sign = 1;
	if (n < 0)
	{
		n = -n;
		sign = 1 - ((n & 1) << 1);
	}
	if (n == 0)
		return (__ieee754_y0(x));
	if (n == 1)
		return (sign * __ieee754_y1(x));
	if (ix == IC(0x7ff00000))
		return zero;
	if (ix >= IC(0x52D00000))
	{									/* x > 2**302 */
		/* (x >> n**2)
		 *      Jn(x) = cos(x-(2n+1)*pi/4)*sqrt(2/x*pi)
		 *      Yn(x) = sin(x-(2n+1)*pi/4)*sqrt(2/x*pi)
		 *      Let s=sin(x), c=cos(x),
		 *      xn=x-(2n+1)*pi/4, sqt2 = sqrt(2),then
		 *
		 *         n    sin(xn)*sqt2    cos(xn)*sqt2
		 *      ----------------------------------
		 *         0     s-c         c+s
		 *         1    -s-c        -c+s
		 *         2    -s+c        -c-s
		 *         3     s+c         c-s
		 */
		double c;
		double s;

		__ieee754_sincos(x, &s, &c);
		switch (n & 3)
		{
		case 0:
			temp = s - c;
			break;
		case 1:
			temp = -s - c;
			break;
		case 2:
			temp = -s + c;
			break;
		case 3:
			temp = s + c;
			break;
		}
		b = invsqrtpi * temp / __ieee754_sqrt(x);
	} else
	{
		uint32_t high;

		a = __ieee754_y0(x);
		b = __ieee754_y1(x);
		/* quit if b is -inf */
		GET_HIGH_WORD(high, b);
		for (i = 1; i < n && high != UC(0xfff00000); i++)
		{
			temp = b;
			b = ((double) (i + i) / x) * b - a;
			GET_HIGH_WORD(high, b);
			a = temp;
		}
	}
	if (sign > 0)
		return b;
	return -b;
}

/* wrapper yn */
double __yn(int n, double x)
{
	if ((islessequal(x, 0.0) || isgreater(x, X_TLOSS)) && _LIB_VERSION != _IEEE_)
	{
		if (x < 0.0)
		{
			/* d = zero/(x-x) */
			feraiseexcept(FE_INVALID);
			return __kernel_standard(n, x, -HUGE_VAL, KMATHERR_YN_MINUS);
		} else if (x == 0.0)
			/* d = -one/(x-x) */
			return __kernel_standard(n, x, -HUGE_VAL, KMATHERR_YN_ZERO);
		else if (_LIB_VERSION != _POSIX_)
			/* yn(n,x>X_TLOSS) */
			return __kernel_standard(n, x, 0.0, KMATHERR_YN_TLOSS);
	}

	return __ieee754_yn(n, x);
}

__typeof(__yn) yn __attribute__((weak, alias("__yn")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(__ynl) __ynl __attribute__((alias("__yn")));
__typeof(__ynl) ynl __attribute__((weak, alias("__ynl")));
#endif

```

`e_ynf.c`:

```c
/* e_ynf.c -- float version of e_jn.c.
 * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

float __ieee754_ynf(int n, float x)
{
	int32_t i, hx, ix;
	uint32_t ib;
	int sign;
	float a, b, temp;

	static const float zero = 0.0000000000e+00;

	GET_FLOAT_WORD(hx, x);
	ix = IC(0x7fffffff) & hx;
	/* if Y(n,NaN) is NaN */
	if (FLT_UWORD_IS_NAN(ix))
		return x + x;
	if (FLT_UWORD_IS_ZERO(ix))
		return -HUGE_VALF + x;			/* -inf and overflow exception.  */
	if (hx < 0)
		return zero / (zero * x);
	sign = 1;
	if (n < 0)
	{
		n = -n;
		sign = 1 - ((n & 1) << 1);
	}
	if (n == 0)
		return (__ieee754_y0f(x));
	if (n == 1)
		return (sign * __ieee754_y1f(x));
	if (FLT_UWORD_IS_INFINITE(ix))
		return zero;

	a = __ieee754_y0f(x);
	b = __ieee754_y1f(x);
	/* quit if b is -inf */
	GET_FLOAT_WORD(ib, b);
	for (i = 1; i < n && ib != UC(0xff800000); i++)
	{
		temp = b;
		b = ((float) (i + i) / x) * b - a;
		GET_FLOAT_WORD(ib, b);
		a = temp;
	}
	if (sign > 0)
		return b;
	return -b;
}

/* wrapper yn */
float __ynf(int n, float x)
{
	if ((islessequal(x, 0.0F) || isgreater(x, X_TLOSS)) && _LIB_VERSION != _IEEE_)
	{
		if (x < 0.0F)
		{
			/* d = zero/(x-x) */
			feraiseexcept(FE_INVALID);
			return __kernel_standard_f(n, x, -HUGE_VALF, KMATHERRF_YN_MINUS);
		} else if (x == 0.0F)
			/* d = -one/(x-x) */
			return __kernel_standard_f(n, x, -HUGE_VALF, KMATHERRF_YN_ZERO);
		else if (_LIB_VERSION != _POSIX_)
			/* yn(n,x>X_TLOSS) */
			return __kernel_standard_f(n, x, 0.0f, KMATHERRF_YN_TLOSS);
	}

	return __ieee754_ynf(n, x);
}

__typeof(__ynf) ynf __attribute__((weak, alias("__ynf")));

```

`e_ynl.c`:

```c
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/* Modifications for long double are
  Copyright (C) 2001 Stephen L. Moshier <moshier@na-net.ornl.gov>
  and are incorporated herein by permission of the author.  The author
  reserves the right to distribute this material elsewhere under different
  copying permissions.  These modifications are distributed here under
  the following terms:

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, see
    <http://www.gnu.org/licenses/>.  */

/*
 * __ieee754_yn(n, x)
 * floating point Bessel's function of the 2nd kind
 * of order n
 *
 * Special cases:
 *	y0(0)=y1(0)=yn(n,0) = -inf with overflow signal;
 *	y0(-ve)=y1(-ve)=yn(n,-ve) are NaN with invalid signal.
 * Note 2. About jn(n,x), yn(n,x)
 *	For n=0, j0(x) is called,
 *	for n=1, j1(x) is called,
 *	for n<x, forward recursion us used starting
 *	from values of j0(x) and j1(x).
 *	for n>x, a continued fraction approximation to
 *	j(n,x)/j(n-1,x) is evaluated and then backward
 *	recursion is used starting from a supposed value
 *	for j(n,x). The resulting value of j(0,x) is
 *	compared with the actual value to correct the
 *	supposed value of j(n,x).
 *
 *	yn(n,x) is similar in all respects, except
 *	that forward recursion is used for all
 *	values of n>1.
 *
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

long double __ieee754_ynl(int n, long double x)
{
	uint32_t se, i0, i1;
	int32_t i, ix;
	int sign;
	long double a, b, temp;

	static const long double invsqrtpi = 5.64189583547756286948079e-1L;
	static const long double zero = 0.0L;
	
	GET_LDOUBLE_WORDS(se, i0, i1, x);
	ix = se & IEEE854_LONG_DOUBLE_MAXEXP;
	/* if Y(n,NaN) is NaN */
	if ((ix == IEEE854_LONG_DOUBLE_MAXEXP) && ((i0 & IC(0x7fffffff)) != 0))
		return x + x;
	if ((ix | i0 | i1) == 0)
		return -HUGE_VALL + x;			/* -inf and overflow exception.  */
	if (se & 0x8000)
		return zero / (zero * x);
	sign = 1;
	if (n < 0)
	{
		n = -n;
		sign = 1 - ((n & 1) << 1);
	}
	if (n == 0)
		return (__ieee754_y0l(x));
	if (n == 1)
		return (sign * __ieee754_y1l(x));
	if (ix == IEEE854_LONG_DOUBLE_MAXEXP)
		return zero;
	if (ix >= 0x412D)
	{									/* x > 2**302 */

		/* ??? See comment above on the possible futility of this.  */

		/* (x >> n**2)
		 *      Jn(x) = cos(x-(2n+1)*pi/4)*sqrt(2/x*pi)
		 *      Yn(x) = sin(x-(2n+1)*pi/4)*sqrt(2/x*pi)
		 *      Let s=sin(x), c=cos(x),
		 *          xn=x-(2n+1)*pi/4, sqt2 = sqrt(2),then
		 *
		 *             n    sin(xn)*sqt2    cos(xn)*sqt2
		 *          ----------------------------------
		 *             0     s-c             c+s
		 *             1    -s-c            -c+s
		 *             2    -s+c            -c-s
		 *             3     s+c             c-s
		 */
		long double s;
		long double c;

		__ieee754_sincosl(x, &s, &c);
		switch (n & 3)
		{
		case 0:
			temp = s - c;
			break;
		case 1:
			temp = -s - c;
			break;
		case 2:
			temp = -s + c;
			break;
		case 3:
			temp = s + c;
			break;
		}
		b = invsqrtpi * temp / __ieee754_sqrtl(x);
	} else
	{
		a = __ieee754_y0l(x);
		b = __ieee754_y1l(x);
		/* quit if b is -inf */
		GET_LDOUBLE_WORDS(se, i0, i1, b);
		/* Use 0xffffffff since GET_LDOUBLE_WORDS sign-extends SE.  */
		for (i = 1; i < n && se != UC(0xffffffff); i++)
		{
			temp = b;
			b = ((long double) (i + i) / x) * b - a;
			GET_LDOUBLE_WORDS(se, i0, i1, b);
			a = temp;
		}
	}
	if (sign > 0)
		return b;
	return -b;
}

/* wrapper yn */
long double __ynl(int n, long double x)
{
	if ((islessequal(x, 0.0) || isgreater(x, X_TLOSS)) && _LIB_VERSION != _IEEE_)
	{
		if (x < 0.0)
		{
			/* d = zero/(x-x) */
			feraiseexcept(FE_INVALID);
			return __kernel_standard_l(n, x, -HUGE_VALL, KMATHERRL_YN_MINUS);
		} else if (x == 0.0)
			/* d = -one/(x-x) */
			return __kernel_standard_l(n, x, -HUGE_VALL, KMATHERRL_YN_ZERO);
		else if (_LIB_VERSION != _POSIX_)
			/* yn(n,x>X_TLOSS) */
			return __kernel_standard_l(n, x, 0.0L, KMATHERRL_YN_TLOSS);
	}

	return __ieee754_yn(n, x);
}

__typeof(__ynl) ynl __attribute__((weak, alias("__ynl")));

#endif

```

`feclearexcept.c`:

```c
/* Clear given exceptions in current floating-point environment.
   Copyright (C) 1997-2013 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif
#include "fpu_ctrl.h"

int __feclearexcept(int excepts)
{
	fexcept_t fpsr;

	/* Mask out unsupported bits/exceptions. */
	excepts &= FE_ALL_EXCEPT;

	/* Fetch the fpu status register. */
	_FPU_GETSR(fpsr);

	/* Clear the relevant bits. */
	fpsr &= ~excepts;

	/* Put the new data in effect. */
	_FPU_SETSR(fpsr);

	/* Success. */
	return 0;
}

__typeof(__feclearexcept) feclearexcept __attribute__((weak, alias("__feclearexcept")));

```

`fedisableexcept.c`:

```c
/* Disable floating-point exceptions.
   Copyright (C) 2000-2013 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Andreas Schwab <schwab@suse.de>, 2000.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library.  If not, see
   <http://www.gnu.org/licenses/>.  */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif
#include "fpu_ctrl.h"

int __fedisableexcept(int excepts)
{
	fpu_control_t old_exc, new_exc;

	/* Get the current control register contents.  */
	_FPU_GETCW(new_exc);

	old_exc = (new_exc >> 6) & FE_ALL_EXCEPT;

	excepts &= FE_ALL_EXCEPT;

	new_exc &= ~(excepts << 6);
	_FPU_SETCW(new_exc);

	return (int)old_exc;
}

__typeof(__fedisableexcept) fedisableexcept __attribute__((weak, alias("__fedisableexcept")));

```

`feenableexcept.c`:

```c
/* Enable floating-point exceptions.
   Copyright (C) 2000-2013 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Andreas Schwab <schwab@suse.de>, 2000.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library.  If not, see
   <http://www.gnu.org/licenses/>.  */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif
#include "fpu_ctrl.h"

int __feenableexcept(int excepts)
{
	fpu_control_t new_exc, old_exc;

	/* Get the current control register contents.  */
	_FPU_GETCW(new_exc);

	old_exc = (new_exc >> 6) & FE_ALL_EXCEPT;

	excepts &= FE_ALL_EXCEPT;

	new_exc |= excepts << 6;
	_FPU_SETCW(new_exc);

	return (int)old_exc;
}

__typeof(__feenableexcept) feenableexcept __attribute__((weak, alias("__feenableexcept")));

```

`fegetenv.c`:

```c
/* Store current floating-point environment.
    Copyright (C) 1997-2013 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Andreas Schwab <schwab@issan.informatik.uni-dortmund.de>

    The GNU C Library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    The GNU C Library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with the GNU C Library.  If not, see
    <http://www.gnu.org/licenses/>.  */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif
#include "fpu_ctrl.h"

int __fegetenv(fenv_t *envp)
{
#if defined(__GNUC__) && defined(__HAVE_68881__) && !defined(__mcoldfire__)
	 __asm__("fmovem%.l %/fpcr/%/fpsr/%/fpiar,%0":"=m"(*envp));
#else
	_FPU_GETCW(envp->__control_register);
	_FPU_GETSR(envp->__status_register);
	_FPU_GETIAR(envp->__instruction_address);
#endif

	/* Success.  */
	return 0;
}

__typeof(__fegetenv) fegetenv __attribute__((weak, alias("__fegetenv")));

```

`fegetexcept.c`:

```c
/* Get enabled floating-point exceptions.
   Copyright (C) 2000-2013 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Andreas Schwab <schwab@suse.de>, 2000.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library.  If not, see
   <http://www.gnu.org/licenses/>.  */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif
#include "fpu_ctrl.h"

int __fegetexcept(void)
{
	fpu_control_t exc;

	/* Get the current control register contents.  */
	_FPU_GETCW(exc);

	return (int)((exc >> 6) & FE_ALL_EXCEPT);
}

__typeof(__fegetexcept) fegetexcept __attribute__((weak, alias("__fegetexcept")));

```

`fegetexceptflag.c`:

```c
/* Store current representation for exceptions.
   Copyright (C) 1997-2013 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Andreas Schwab <schwab@issan.informatik.uni-dortmund.de>

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library.  If not, see
   <http://www.gnu.org/licenses/>.  */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif
#include "fpu_ctrl.h"

int __fegetexceptflag(fexcept_t *flagp, int excepts)
{
	fexcept_t fpsr;

	/* Get the current exceptions.  */
	_FPU_GETSR(fpsr);

	*flagp = fpsr & excepts & FE_ALL_EXCEPT;

	/* Success.  */
	return 0;
}

__typeof(__fegetexceptflag) fegetexceptflag __attribute__((weak, alias("__fegetexceptflag")));

```

`fegetround.c`:

```c
/* Return current rounding direction.
   Copyright (C) 1997-2013 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Andreas Schwab <schwab@issan.informatik.uni-dortmund.de>

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library.  If not, see
   <http://www.gnu.org/licenses/>.  */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif
#include "fpu_ctrl.h"

int __fegetround(void)
{
	fpu_control_t cw;

	_FPU_GETCW(cw);

	return (int) (cw & FE_ROUNDING_MASK);
}

__typeof(__fegetround) fegetround __attribute__((weak, alias("__fegetround")));

```

`feholdexcept.c`:

```c
/* Store current floating-point environment and clear exceptions.
   Copyright (C) 1997-2013 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Andreas Schwab <schwab@issan.informatik.uni-dortmund.de>

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library.  If not, see
   <http://www.gnu.org/licenses/>.  */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif
#include "fpu_ctrl.h"

int __feholdexcept(fenv_t *envp)
{
	fpu_control_t fpcr;
	fexcept_t fpsr;

	/* Store the environment.  */
	fegetenv(envp);

	/* Now clear all exceptions.  */
	fpsr = envp->__status_register & ~FE_ALL_EXCEPT;
	_FPU_SETSR(fpsr);
	/* And set all exceptions to non-stop.  */
	fpcr = envp->__control_register & ~(FE_ALL_EXCEPT << 6);
	_FPU_SETCW(fpcr);

	return 0;
}

__typeof(__feholdexcept) feholdexcept __attribute__((weak, alias("__feholdexcept")));

```

`feraiseexcept.c`:

```c
/* Raise given exceptions.
   Copyright (C) 1997-2013 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Andreas Schwab <schwab@issan.informatik.uni-dortmund.de>

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library.  If not, see
   <http://www.gnu.org/licenses/>.  */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif
#include "fpu_ctrl.h"

#ifdef __mcoldfire__

static void raise_one_exception(fexcept_t excepts, fexcept_t mask)
{
	if (excepts & mask)
	{
		fexcept_t fpsr;
		double unused;

		_FPU_GETSR(fpsr);
		fpsr |= (mask << 6) | mask;
		_FPU_SETSR(fpsr);
		__asm__ __volatile__ ("fmove%.l (%%sp),%0":"=f" (unused));
	}
}

int __feraiseexcept(int excepts)
{
	/* Raise exceptions represented by EXCEPTS.  But we must raise only one
	   signal at a time.  It is important that if the overflow/underflow
	   exception and the divide by zero exception are given at the same
	   time, the overflow/underflow exception follows the divide by zero
	   exception.

	   The Coldfire FPU allows an exception to be raised by asserting
	   the associated EXC bit and then executing an arbitrary arithmetic
	   instruction.  fmove.l is classified as an arithmetic instruction
	   and suffices for this purpose.

	   We therefore raise an exception by setting both the EXC and AEXC
	   bit associated with the exception (the former being 6 bits to the
	   left of the latter) and then loading the longword at (%sp) into an
	   FP register.  */

#ifdef __HAVE_FPU__
	raise_one_exception(excepts, FE_INVALID);
	raise_one_exception(excepts, FE_DIVBYZERO);
	raise_one_exception(excepts, FE_OVERFLOW);
	raise_one_exception(excepts, FE_UNDERFLOW);
	raise_one_exception(excepts, FE_INEXACT);
#else
	__fpu_status |= excepts & FE_ALL_EXCEPT;
#endif

	/* Success.  */
	return 0;
}

#else

int __feraiseexcept(int excepts)
{
#ifdef __HAVE_FPU__
	/* Raise exceptions represented by EXCEPTS.  But we must raise only one
	   signal at a time.  It is important that if the overflow/underflow
	   exception and the divide by zero exception are given at the same
	   time, the overflow/underflow exception follows the divide by zero
	   exception.  */

	/* First: invalid exception.  */
	if (excepts & FE_INVALID)
	{
		/* One example of a invalid operation is 0 * Infinity.  */
		double d = HUGE_VAL;

		__asm__ __volatile__("fmul%.s %#0r0,%0; fnop":"=f"(d):"0"(d));
	}

	/* Next: division by zero.  */
	if (excepts & FE_DIVBYZERO)
	{
		double d = 1.0;

		__asm__ __volatile__("fdiv%.s %#0r0,%0; fnop":"=f"(d):"0"(d));
	}

	/* Next: overflow.  */
	if (excepts & FE_OVERFLOW)
	{
		long double d = LDBL_MAX;

		__asm__ __volatile__("fmul%.x %0,%0; fnop":"=f"(d):"0"(d));
	}

	/* Next: underflow.  */
	if (excepts & FE_UNDERFLOW)
	{
		long double d = -LDBL_MAX;

		__asm__ __volatile__("fetox%.x %0; fnop":"=f"(d):"0"(d));
	}

	/* Last: inexact.  */
	if (excepts & FE_INEXACT)
	{
		long double d = 1.0;

		__asm__ __volatile__("fdiv%.s %#0r3,%0; fnop":"=f"(d):"0"(d));
	}
#else
	__fpu_status |= excepts & FE_ALL_EXCEPT;
#endif

	/* Success.  */
	return 0;
}

#endif

__typeof(__feraiseexcept) feraiseexcept __attribute__((weak, alias("__feraiseexcept")));

```

`fesetenv.c`:

```c
/* Install given floating-point environment.
   Copyright (C) 1997-2013 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Andreas Schwab <schwab@issan.informatik.uni-dortmund.de>

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library.  If not, see
   <http://www.gnu.org/licenses/>.  */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif
#include "fpu_ctrl.h"

int __fesetenv(const fenv_t *envp)
{
	fenv_t temp;

	/* Install the environment specified by ENVP.  But there are a few
	   values which we do not want to come from the saved environment.
	   Therefore, we get the current environment and replace the values
	   we want to use from the environment specified by the parameter.  */
	fegetenv(&temp);

	temp.__status_register &= ~FE_ALL_EXCEPT;
	temp.__control_register &= ~((FE_ALL_EXCEPT << 6) | FE_ROUNDING_MASK | FE_PRECISION_MASK);
	if (envp == FE_DFL_ENV)
	{
		temp.__control_register |= FE_TONEAREST | _FPU_EXTENDED;
	} else if (envp == FE_NOMASK_ENV)
	{
		temp.__control_register |= FE_ALL_EXCEPT << 6;
		temp.__control_register |= FE_TONEAREST | _FPU_EXTENDED;
	} else
	{
		temp.__control_register |= (envp->__control_register & ((FE_ALL_EXCEPT << 6) | FE_ROUNDING_MASK | FE_PRECISION_MASK));
		temp.__status_register |= envp->__status_register & FE_ALL_EXCEPT;
	}

	_FPU_SETCW(temp.__control_register);
	_FPU_SETSR(temp.__status_register);

	/* Success.  */
	return 0;
}

__typeof(__fesetenv) fesetenv __attribute__((weak, alias("__fesetenv")));

```

`fesetexceptflag.c`:

```c
/* Set floating-point environment exception handling.
   Copyright (C) 1997-2013 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Andreas Schwab <schwab@issan.informatik.uni-dortmund.de>

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library.  If not, see
   <http://www.gnu.org/licenses/>.  */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif
#include "fpu_ctrl.h"

int __fesetexceptflag(const fexcept_t *flagp, int excepts)
{
	fexcept_t fpsr;

	/* Get the current status register.  */
	_FPU_GETSR(fpsr);

	/* Install the new exception bits in the Accrued Exception Byte.  */
	fpsr &= ~(excepts & FE_ALL_EXCEPT);
	fpsr |= *flagp & excepts & FE_ALL_EXCEPT;

	/* Store the new status register.  */
	_FPU_SETSR(fpsr);

	/* Success.  */
	return 0;
}

__typeof(__fesetexceptflag) fesetexceptflag __attribute__((weak, alias("__fesetexceptflag")));

```

`fesetround.c`:

```c
/* Set current rounding direction.
   Copyright (C) 1997-2013 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Andreas Schwab <schwab@issan.informatik.uni-dortmund.de>

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library.  If not, see
   <http://www.gnu.org/licenses/>.  */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif
#include "fpu_ctrl.h"

#ifdef __mc68000__

int __fesetround(int round)
{
	fpu_control_t fpcr;

	if ((round & ~FE_ROUNDING_MASK) != 0)
		/* ROUND is no valid rounding mode.  */
		return 1;

	_FPU_GETCW(fpcr);
	fpcr &= ~FE_ROUNDING_MASK;
	fpcr |= round;
	_FPU_SETCW(fpcr);

	return 0;
}

#endif

#if defined __i386__ || defined __x86_64__

int __fesetround(int round)
{
	fpu_control_t cw;

	if ((round & ~FE_ROUNDING_MASK) != 0)
		/* ROUND is no valid rounding mode.  */
		return 1;

	/* First set the x87 FPU.  */
	_FPU_GETCW(cw);
	cw &= ~FE_ROUNDING_MASK;
	cw |= round;
	_FPU_SETCW(cw);

	/* And now the MSCSR register for SSE, the precision is at different bit
	   positions in the different units, we need to shift it 3 bits.  */
	if (HAVE_SSE)
	{
		uint32_t xcw;

		__asm__("stmxcsr %0":"=m"(*&xcw));
		xcw &= ~(FE_ROUNDING_MASK << __MXCSR_ROUND_FLAG_SHIFT);
		xcw |= round << __MXCSR_ROUND_FLAG_SHIFT;
		__asm__("ldmxcsr %0": :"m"(*&xcw));
	}

	return 0;
}

#endif

__typeof(__fesetround) fesetround __attribute__((weak, alias("__fesetround")));

```

`fetestexcept.c`:

```c
/* Test exception in current environment.
   Copyright (C) 1997-2013 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Andreas Schwab <schwab@issan.informatik.uni-dortmund.de>

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library.  If not, see
   <http://www.gnu.org/licenses/>.  */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif
#include "fpu_ctrl.h"

int __fetestexcept(int excepts)
{
	fexcept_t fpsr;

	/* Get current exceptions.  */
	_FPU_GETSR(fpsr);

	return (int)(fpsr & excepts & FE_ALL_EXCEPT);
}

__typeof(__fetestexcept) fetestexcept __attribute__((weak, alias("__fetestexcept")));

```

`feupdateenv.c`:

```c
/* Install given floating-point environment and raise exceptions.
   Copyright (C) 1997-2013 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Andreas Schwab <schwab@issan.informatik.uni-dortmund.de>

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library.  If not, see
   <http://www.gnu.org/licenses/>.  */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif
#include "fpu_ctrl.h"

int __feupdateenv(const fenv_t *envp)
{
	fexcept_t fpsr;

	/* Save current exceptions.  */
	_FPU_GETSR(fpsr);
	fpsr &= FE_ALL_EXCEPT;

	/* Install new environment.  */
	fesetenv(envp);

	/* Raise the saved exception.  Incidently for us the implementation
	   defined format of the values in objects of type fexcept_t is the
	   same as the ones specified using the FE_* constants.  */
	feraiseexcept((int) fpsr);

	/* Success.  */
	return 0;
}

__typeof(__feupdateenv) feupdateenv __attribute__((weak, alias("__feupdateenv")));

```

`fpu_ctrl.c`:

```c
/* Install given floating-point environment.
   Copyright (C) 1997-2013 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Andreas Schwab <schwab@issan.informatik.uni-dortmund.de>

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library.  If not, see
   <http://www.gnu.org/licenses/>.  */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif
#include "fpu_ctrl.h"


/* This module defines `__fpu_control' with the default value.  */

fpu_control_t __fpu_control = _FPU_DEFAULT;
fexcept_t __fpu_status = 0;

```

`fpu_ctrl.h`:

```h
/* FPU control word bits.  x86-64 version.
   Copyright (C) 1993,1995,1996,1997,1998,2000,2001,2002 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Olaf Flebbe.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

#ifndef ___FPU_CONTROL_H__
#define ___FPU_CONTROL_H__	1

#if defined(__i386__) || defined(__x86_64__)

/* _WIN32 does not have <fpu_control.h>, include our definitions */
#define _FPU_CONTROL_H
#include "../../include/bits/x86/fpu_control.h"

#else

#include <fpu_control.h>

#endif

/* Default control word set at startup.  */
extern fpu_control_t __fpu_control;

/* Called at startup.  It can be used to manipulate fpu control register.  */
void __setfpucw(fpu_control_t set);

#ifndef FE_ROUNDING_MASK
#define FE_ROUNDING_MASK (FE_TONEAREST|FE_DOWNWARD|FE_UPWARD|FE_TOWARDZERO)
#endif
#ifndef FE_PRECISION_MASK
#define FE_PRECISION_MASK (_FPU_EXTENDED|_FPU_DOUBLE|_FPU_SINGLE)
#endif

#endif	/* fpu_control.h */

```

`include/asm/ieee754/i386.h`:

```h
#include "asm/ieee754/x86l.h"

#ifndef __NO_MATH_INLINES

__MATH_INLINE double
__ieee754_fabs(double x)
{
	return (double)__ieee754_fabsl(x);
}

__MATH_INLINE float
__ieee754_fabsf(float x)
{
	return (float)__ieee754_fabsl(x);
}

__MATH_INLINE double
__ieee754_sin(double x)
{
	return (double)__ieee754_sinl(x);
}

__MATH_INLINE float
__ieee754_sinf(float x)
{
	return (float)__ieee754_sinl(x);
}

__MATH_INLINE double
__ieee754_cos(double x)
{
	return (double)__ieee754_cosl(x);
}

__MATH_INLINE float
__ieee754_cosf(float x)
{
	return (float)__ieee754_cosl(x);
}

__MATH_INLINE void
__ieee754_sincos(double x, double *sinx, double *cosx)
{
	long double lsinx, lcosx;
	__ieee754_sincosl(x, &lsinx, &lcosx);
	*sinx = lsinx;
	*cosx = lcosx;
}

__MATH_INLINE void
__ieee754_sincosf(float x, float *sinx, float *cosx)
{
	long double lsinx, lcosx;
	__ieee754_sincosl(x, &lsinx, &lcosx);
	*sinx = lsinx;
	*cosx = lcosx;
}

__MATH_INLINE double
__ieee754_tan(double x)
{
	return (double)__ieee754_tanl(x);
}

__MATH_INLINE float
__ieee754_tanf(float x)
{
	return (float)__ieee754_tanl(x);
}

__MATH_INLINE double
__ieee754_sqrt (double x)
{
  double res;

  asm ("fsqrt" : "=t" (res) : "0" (x));

  return res;
}

__MATH_INLINE float
__ieee754_sqrtf (float x)
{
  float res;

  asm ("fsqrt" : "=t" (res) : "0" (x));

  return res;
}

__MATH_INLINE double
__ieee754_acos (double x)
{
	double res;

	/* acosl = atanl (sqrtl((1-x) (1+x)) / x) */
	asm("fld	%%st\n"
		"fmul %%st(0)\n"		/* x^2 */
		"fld1\n"
		"fsubp\n"		/* 1 - x^2 */
		"fsqrt\n"		/* sqrtl (1 - x^2) */
	   "fabs\n"
	   "fxch	%%st(1)\n"
	   "fpatan"
	: "=t"(res)
	: "0"(x)
	: "st(1)", "st(2)");
	return res;
}

__MATH_INLINE float
__ieee754_acosf (float x)
{
	float res;

	/* acosl = atanl (sqrtl((1-x) (1+x)) / x) */
	asm("fld	%%st\n"
		"fmul %%st(0)\n"		/* x^2 */
		"fld1\n"
		"fsubp\n"		/* 1 - x^2 */
		"fsqrt\n"		/* sqrtl (1 - x^2) */
	   "fabs\n"
	   "fxch	%%st(1)\n"
	   "fpatan"
	: "=t"(res)
	: "0"(x)
	: "st(1)", "st(2)");
	return res;
}

__MATH_INLINE double
__ieee754_asin (double x)
{
	double res;

	/* asinl = atanl (x / sqrtl(1 - x^2)) */
	asm("fld	%%st\n"
		"fmul %%st(0)\n"		/* x^2 */
		"fld1\n"
		"fsubp\n"		/* 1 - x^2 */
		"fsqrt\n"		/* sqrtl (1 - x^2) */
	   "fpatan"
	: "=t"(res)
	: "0"(x)
	: "st(1)", "st(2)");
	return res;
}

__MATH_INLINE float
__ieee754_asinf (float x)
{
	float res;

	/* asinl = atanl (x / sqrtl(1 - x^2)) */
	asm("fld	%%st\n"
		"fmul %%st(0)\n"		/* x^2 */
		"fld1\n"
		"fsubp\n"		/* 1 - x^2 */
		"fsqrt\n"		/* sqrtl (1 - x^2) */
	   "fpatan"
	: "=t"(res)
	: "0"(x)
	: "st(1)", "st(2)");
	return res;
}


__MATH_INLINE double
__ieee754_atan (double x)
{
  double res;

  asm ("fld1\n"
       "fpatan"
       : "=t" (res)
       : "0" (x)
	   : "st(1)");
  return res;
}

__MATH_INLINE float
__ieee754_atanf (float x)
{
  float res;

  asm ("fld1\n"
       "fpatan"
       : "=t" (res)
       : "0" (x)
	   : "st(1)");
  return res;
}


__MATH_INLINE double
__ieee754_atan2 (double y, double x)
{
  double res;

  asm ("fpatan" : "=t" (res) : "u" (y), "0" (x) : "st(1)");

  return res;
}

__MATH_INLINE float
__ieee754_atan2f (float y, float x)
{
  float res;

  asm ("fpatan" : "=t" (res) : "u" (y), "0" (x) : "st(1)");

  return res;
}


__MATH_INLINE double
__ieee754_fmod (double x, double y)
{
	return (double) __ieee754_fmodl(x, y);
}

__MATH_INLINE float
__ieee754_fmodf (float x, float y)
{
	return (float) __ieee754_fmodl(x, y);
}

__MATH_INLINE double
__ieee754_remainder (double x, double y)
{
	return (double) __ieee754_remainderl(x, y);
}

__MATH_INLINE float
__ieee754_remainderf (float x, float y)
{
	return (float) __ieee754_remainderl(x, y);
}

#if 0

__MATH_INLINE double
__ieee754_remquo (double x, double y, int *quo)
{
	return (double) __ieee754_remquol(x, y, quo);
}

__MATH_INLINE float
__ieee754_remquof (float x, float y, int *quo)
{
	return (float) __ieee754_remquol(x, y, quo);
}

#endif

__MATH_INLINE double
__ieee754_ceil (double x)
{
	return (double) __ieee754_ceill(x);
}

__MATH_INLINE float
__ieee754_ceilf (float x)
{
	return (float) __ieee754_ceill(x);
}

__MATH_INLINE double
__ieee754_floor (double x)
{
	return (double) __ieee754_floorl(x);
}

__MATH_INLINE float
__ieee754_floorf (float x)
{
	return (float) __ieee754_floorl(x);
}

__MATH_INLINE double
__ieee754_trunc (double x)
{
	return (double) __ieee754_truncl(x);
}

__MATH_INLINE float
__ieee754_truncf (float x)
{
	return (float) __ieee754_truncl(x);
}

__MATH_INLINE double
__ieee754_rint (double x)
{
	return (double) __ieee754_rintl(x);
}

__MATH_INLINE float
__ieee754_rintf (float x)
{
	return (float) __ieee754_rintl(x);
}

__MATH_INLINE long
__ieee754_lrint (double x)
{
	return __ieee754_lrintl(x);
}

__MATH_INLINE long
__ieee754_lrintf (float x)
{
	return __ieee754_lrintl(x);
}

__extension__ __MATH_INLINE long long
__ieee754_llrint (double x)
{
	return __ieee754_llrintl(x);
}

__extension__ __MATH_INLINE long long
__ieee754_llrintf (float x)
{
	return __ieee754_llrintl(x);
}

#if 0 /* frndint rounds in wrong direction */

__MATH_INLINE double
__ieee754_round (double x)
{
	return (double) __ieee754_roundl(x);
}

__MATH_INLINE float
__ieee754_roundf (float x)
{
	return (float) __ieee754_roundl(x);
}

#endif

__MATH_INLINE double
__ieee754_scalbn (double x, int n)
{
	return (double) __ieee754_scalbnl(x, n);
}

__MATH_INLINE float
__ieee754_scalbnf (float x, int n)
{
	return (float) __ieee754_scalbnl(x, n);
}

__MATH_INLINE double
__ieee754_scalbln (double x, long n)
{
	return (double) __ieee754_scalblnl(x, n);
}

__MATH_INLINE float
__ieee754_scalblnf (float x, long n)
{
	return (float) __ieee754_scalblnl(x, n);
}

__MATH_INLINE double
__ieee754_logb (double x)
{
	return (double) __ieee754_logbl(x);
}

__MATH_INLINE float
__ieee754_logbf (float x)
{
	return (float) __ieee754_logbl(x);
}

__MATH_INLINE double
__ieee754_expm1 (double x)
{
	return (double) __ieee754_expm1l(x);
}

__MATH_INLINE float
__ieee754_expm1f (float x)
{
	return (float) __ieee754_expm1l(x);
}

__MATH_INLINE double
__ieee754_exp2 (double x)
{
	return (double) __ieee754_exp2l(x);
}

__MATH_INLINE float
__ieee754_exp2f (float x)
{
	return (float) __ieee754_exp2l(x);
}

__MATH_INLINE double
__ieee754_log (double x)
{
	return (double) __ieee754_logl(x);
}

__MATH_INLINE float
__ieee754_logf (float x)
{
	return (float) __ieee754_logl(x);
}

__MATH_INLINE double
__ieee754_log1p (double x)
{
	return (double) __ieee754_log1pl(x);
}

__MATH_INLINE float
__ieee754_log1pf (float x)
{
	return (float) __ieee754_log1pl(x);
}

__MATH_INLINE double
__ieee754_log2 (double x)
{
	return (double) __ieee754_log2l(x);
}

__MATH_INLINE float
__ieee754_log2f (float x)
{
	return (float) __ieee754_log2l(x);
}

__MATH_INLINE double
__ieee754_log10 (double x)
{
	return (double) __ieee754_log10l(x);
}

__MATH_INLINE float
__ieee754_log10f (float x)
{
	return (float) __ieee754_log10l(x);
}

__MATH_INLINE double
__ieee754_exp (double x)
{
	return (double) __ieee754_expl(x);
}

__MATH_INLINE float
__ieee754_expf (float x)
{
	return (float) __ieee754_expl(x);
}

__MATH_INLINE double
__ieee754_modf (double x, double *ip)
{
	long double temp, result;
	result = __ieee754_modfl(x, &temp);
	if (ip)
		*ip = (double) temp;
	return (double) result;
}

__MATH_INLINE float
__ieee754_modff (float x, float *ip)
{
	long double temp, result;
	result = __ieee754_modfl(x, &temp);
	if (ip)
		*ip = (float) temp;
	return (float) result;
}



#if 0

"0", "1", and "i" stand for the associated
floating point stack registers, not constant numbers!  Constant
numbers in the descriptions are given with decimal points: 0.0,
1.0, 2.0, 10.0.


    Opcode    Instruction     Description

 w  D9 F0     F2XM1           0 := (2.0 ** 0) - 1.0
 w  D9 E1     FABS            0 := |0|
 w  DE C1     FADD            1 := 1 + 0, pop
 w  D8 C0+i   FADD i          0 := i + 0
 w  DC C0+i   FADD i,0        i := i + 0
 w  D8 C0+i   FADD 0,i        0 := i + 0
 w  D8 /0     FADD mem4r      0 := 0 + mem4r
 w  DC /0     FADD mem8r      0 := 0 + mem8r
 w  DE C0+i   FADDP i,0       i := i + 0, pop
 w  DF /4     FBLD mem10d     push, 0 := mem10d
 w  DF /6     FBSTP mem10d    mem10d := 0, pop
 w  D9 E0     FCHS            0 := -0
9B  DB E2     FCLEX           clear exceptions
 w  D8 D1     FCOM            compare 0 - 1
 w  D8 D0+i   FCOM 0,i        compare 0 - i
 w  D8 D0+i   FCOM i          compare 0 - i
 w  D8 /2     FCOM mem4r      compare 0 - mem4r
 w  DC /2     FCOM mem8r      compare 0 - mem8r
 w  D8 D9     FCOMP           compare 0 - 1, pop
 w  D8 D8+i   FCOMP 0,i       compare 0 - i, pop
 w  D8 D8+i   FCOMP i         compare 0 - i, pop
 w  D8 /3     FCOMP mem4r     compare 0 - mem4r, pop
 w  DC /3     FCOMP mem8r     compare 0 - mem8r, pop
 w  DE D9     FCOMPP          compare 0 - 1, pop both
 w  D9 FF     FCOS            387 only: push, 1/0 := cosine(old 0)
 w  D9 F6     FDECSTP         decrement stack pointer
 w  DB E1     FDISI           disable interrupts (.287 ignore)
 w  DE F9     FDIV            1 := 1 / 0, pop
 w  D8 F0+i   FDIV i          0 := 0 / i
 w  DC F8+i   FDIV i,0        i := i / 0
 w  D8 F0+i   FDIV 0,i        0 := 0 / i
 w  D8 /6     FDIV mem4r      0 := 0 / mem4r
 w  DC /6     FDIV mem8r      0 := 0 / mem8r
 w  DE F8+i   FDIVP i,0       i := i / 0, pop
 w  DE F1     FDIVR           1 := 0 / 1, pop
 w  D8 F8+i   FDIVR i         0 := i / 0
 w  DC F0+i   FDIVR i,0       i := 0 / i
 w  D8 F8+i   FDIVR 0,i       0 := i / 0
 w  D8 /7     FDIVR mem4r     0 := mem4r / 0
 w  DC /7     FDIVR mem8r     0 := mem8r / 0
 w  DE F0+i   FDIVRP i,0      i := 0 / i, pop
 w  DB E0     FENI            enable interrupts (.287 ignore)
 w  DD C0+i   FFREE i         empty i
 w  DE /0     FIADD mem2i     0 := 0 + mem4i
 w  DA /0     FIADD mem4i     0 := 0 + mem2i
 w  DE /2     FICOM mem2i     compare 0 - mem2i
 w  DA /2     FICOM mem4i     compare 0 - mem4i
 w  DE /3     FICOMP mem2i    compare 0 - mem2i, pop
 w  DA /3     FICOMP mem4i    compare 0 - mem4i, pop
 w  DE /6     FIDIV mem2i     0 := 0 / mem2i
 w  DA /6     FIDIV mem4i     0 := 0 / mem4i
 w  DE /7     FIDIVR mem2i    0 := mem2i / 0
 w  DA /7     FIDIVR mem4i    0 := mem4i / 0
 w  DF /0     FILD mem2i      push, 0 := mem2i
 w  DB /0     FILD mem4i      push, 0 := mem4i
 w  DF /5     FILD mem8i      push, 0 := mem8i
 w  DE /1     FIMUL mem2i     0 := 0 * mem2i
 w  DA /1     FIMUL mem4i     0 := 0 * mem4i
 w  D9 F7     FINCSTP         increment stack pointer
9B  DB E3     FINIT           initialize 87
 w  DF /2     FIST mem2i      mem2i := 0
 w  DB /2     FIST mem4i      mem4i := 0
 w  DF /3     FISTP mem2i     mem2i := 0, pop
 w  DB /3     FISTP mem4i     mem4i := 0, pop
 w  DF /7     FISTP mem8i     mem8i := 0, pop
 w  DE /4     FISUB mem2i     0 := 0 - mem2i
 w  DA /4     FISUB mem4i     0 := 0 - mem4i
 w  DE /5     FISUBR mem2i    0 := mem2i - 0
 w  DA /5     FISUBR mem4i    0 := mem4i - 0
 w  D9 C0+i   FLD i           push, 0 := old i
 w  DB /5     FLD mem10r      push, 0 := mem10r
 w  D9 /0     FLD mem4r       push, 0 := mem4r
 w  DD /0     FLD mem8r       push, 0 := mem8r
 w  D9 E8     FLD1            push, 0 := 1.0
 w  D9 /5     FLDCW mem2i     control word := mem2i
 w  D9 /4     FLDENV mem14    environment := mem14
 w  D9 EA     FLDL2E          push, 0 := log base 2.0 of e
 w  D9 E9     FLDL2T          push, 0 := log base 2.0 of 10.0
 w  D9 EC     FLDLG2          push, 0 := log base 10.0 of 2.0
 w  D9 ED     FLDLN2          push, 0 := log base e of 2.0
 w  D9 EB     FLDPI           push, 0 := Pi
 w  D9 EE     FLDZ            push, 0 := +0.0
 w  DE C9     FMUL            1 := 1 * 0, pop
 w  D8 C8+i   FMUL i          0 := 0 * i
 w  DC C8+i   FMUL i,0        i := i * 0
 w  D8 C8+i   FMUL 0,i        0 := 0 * i
 w  D8 /1     FMUL mem4r      0 := 0 * mem4r
 w  DC /1     FMUL mem8r      0 := 0 * mem8r
 w  DE C8+i   FMULP i,0       i := i * 0, pop
    DB E2     FNCLEX          nowait clear exceptions
    DB E1     FNDISI          disable interrupts (.287 ignore)
    DB E0     FNENI           enable interrupts (.287 ignore)
    DB E3     FNINIT          nowait initialize 87
 w  D9 D0     FNOP            no operation
    DD /6     FNSAVE mem94    mem94 := 87 state
    D9 /7     FNSTCW mem2i    mem2i := control word
    D9 /6     FNSTENV mem14   mem14 := environment
    DF E0     FNSTSW AX       AX := status word
    DD /7     FNSTSW mem2i    mem2i := status word
 w  D9 F3     FPATAN          0 := arctan(1/0), pop
 w  D9 F8     FPREM           0 := REPEAT(0 - 1)
 w  D9 F5     FPREM1          387 only: 0 := REPEAT(0 - 1) IEEE compat.
 w  D9 F2     FPTAN           push, 1/0 := tan(old 0)
 w  D9 FC     FRNDINT         0 := round(0)
 w  DD /4     FRSTOR mem94    87 state := mem94
 w  DD /6     FSAVE mem94     mem94 := 87 state
 w  D9 FD     FSCALE          0 := 0 * 2.0 ** 1
9B  DB E4     FSETPM          set protection mode
 w  D9 FE     FSIN            387 only: push, 1/0 := sine(old 0)
 w  D9 FB     FSINCOS         387 only: push, 1 := sine, 0 := cos(old 0)
 w  D9 FA     FSQRT           0 := square root of 0
 w  DD D0+i   FST i           i := 0
 w  D9 /2     FST mem4r       mem4r := 0
 w  DD /2     FST mem8r       mem8r := 0
 w  D9 /7     FSTCW mem2i     mem2i := control word
 w  D9 /6     FSTENV mem14    mem14 := environment
 w  DD D8+i   FSTP i          i := 0, pop
 w  DB /7     FSTP mem10r     mem10r := 0, pop
 w  D9 /3     FSTP mem4r      mem4r := 0, pop
 w  DD /3     FSTP mem8r      mem8r := 0, pop
 w  DF E0     FSTSW AX        AX := status word
 w  DD /7     FSTSW mem2i     mem2i := status word
 w  DE E9     FSUB            1 := 1 - 0, pop
 w  D8 E0+i   FSUB i          0 := 0 - i
 w  DC E8+i   FSUB i,0        i := i - 0
 w  D8 E0+i   FSUB 0,i        0 := 0 - i
 w  D8 /4     FSUB mem4r      0 := 0 - mem4r
 w  DC /4     FSUB mem8r      0 := 0 - mem8r
 w  DE E8+i   FSUBP i,0       i := i - 0, pop
 w  DE E1     FSUBR           1 := 0 - 1, pop
 w  D8 E8+i   FSUBR i         0 := i - 0
 w  DC E8+i   FSUBR i,0       0 := i - 0
 w  D8 E0+i   FSUBR 0,i       i := i - 0
 w  D8 /5     FSUBR mem4r     0 := mem4r - 0
 w  DC /5     FSUBR mem8r     0 := mem8r - 0
 w  DE E0+i   FSUBRP i,0      i := 0 - i, pop
 w  D9 E4     FTST            compare 0 - 0.0
 w  DD E0+i   FUCOM i         387 only: unordered compare 0 - i
 w  DD E1     FUCOM           387 only: unordered compare 0 - 1
 w  DD E8+i   FUCOMP i        387 only: unordered compare 0 - i, pop
 w  DD E9     FUCOMP          387 only: unordered compare 0 - 1, pop
 w  DA E9     FUCOMPP         387 only: unordered compare 0 - 1, pop both
9B            FWAIT           wait for 87 ready
 w  D9 E5     FXAM            C3 -- C0 := type of 0
 w  D9 C9     FXCH            exchange 0 and 1
 w  D9 C8+i   FXCH 0,i        exchange 0 and i
 w  D9 C8+i   FXCH i          exchange 0 and i
 w  D9 C8+i   FXCH i,0        exchange 0 and i
 w  D9 F4     FXTRACT         push, 1 := expo, 0 := sig
 w  D9 F1     FYL2X           0 := 1 * log base 2.0 of 0, pop
 w  D9 F9     FYL2XP1         0 := 1 * log base 2.0 of (0+1.0), pop

#endif

#endif /* __NO_MATH_INLINES */

```

`include/asm/ieee754/m68k.h`:

```h
#if defined(__GNUC__) && defined(__HAVE_68881__)

#ifndef FE_ROUNDING_MASK
#define FE_ROUNDING_MASK (FE_TONEAREST|FE_DOWNWARD|FE_UPWARD|FE_TOWARDZERO)
#endif

# define math_opt_barrier(x) \
  ({ __typeof (x) __x;					\
    __asm ("" : "=f" (__x) : "0" (x));			\
    __x; })
# define math_force_eval(x) \
  do {							\
    __typeof (x) __x = (x);				\
    __asm __volatile ("" : : "f" (__x));		\
  } while (0)

#ifndef __NO_MATH_INLINES

/* Get the m68881 condition codes, to quickly check multiple conditions.  */
#define __m81_test(__val, __fpsr) \
  __asm ("ftst%.x %1; fmove%.l %/fpsr,%0" : "=dm" (__fpsr) : "f" (__val))

/* Bit values returned by __m81_test.  */
#define __M81_COND_NAN  (1UL << 24)
#define __M81_COND_INF  (2UL << 24)
#define __M81_COND_ZERO (4UL << 24)
#define __M81_COND_NEG  (8UL << 24)

__MATH_INLINE double
__ieee754_sin (double x)
{
  double value;

  __asm ("fsin%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_INLINE float
__ieee754_sinf (float x)
{
  float value;

  __asm ("fsin%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_INLINE long double
__ieee754_sinl (long double x)
{
  long double value;

  __asm ("fsin%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define __have_fpu_sin

__MATH_INLINE double
__ieee754_cos (double x)
{
  double value;

  __asm ("fcos%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_INLINE float
__ieee754_cosf (float x)
{
  float value;

  __asm ("fcos%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_INLINE long double
__ieee754_cosl (long double x)
{
  long double value;

  __asm ("fcos%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define __have_fpu_cos

__MATH_INLINE void
__ieee754_sincos (double __x, double *__sin, double *__cos)
{
  __asm ("fsincos%.x %2,%0,%1"
	 : "=f" (*__cos), "=f" (*__sin)
	 : "f" (__x));
}

__MATH_INLINE void
__ieee754_sincosf (float __x, float *__sin, float *__cos)
{
  __asm ("fsincos%.x %2,%0,%1"
	 : "=f" (*__cos), "=f" (*__sin)
	 : "f" (__x));
}

__MATH_INLINE void
__ieee754_sincosl (long double __x, long double *__sin, long double *__cos)
{
  __asm ("fsincos%.x %2,%0,%1"
	 : "=f" (*__cos), "=f" (*__sin)
	 : "f" (__x));
}
#define __have_fpu_sincos

__MATH_INLINE double
__ieee754_tan (double x)
{
  double value;

  __asm ("ftan%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_INLINE float
__ieee754_tanf (float x)
{
  float value;

  __asm ("ftan%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_INLINE long double
__ieee754_tanl (long double x)
{
  long double value;

  __asm ("ftan%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define __have_fpu_tan

__MATH_INLINE double
__ieee754_asin (double x)
{
  double value;

  __asm ("fasin%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_INLINE float
__ieee754_asinf (float x)
{
  float value;

  __asm ("fasin%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_INLINE long double
__ieee754_asinl (long double x)
{
  long double value;

  __asm ("fasin%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define __have_fpu_asin

__MATH_INLINE double
__ieee754_acos (double x)
{
  double value;

  __asm ("facos%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_INLINE float
__ieee754_acosf (float x)
{
  float value;

  __asm ("facos%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_INLINE long double
__ieee754_acosl (long double x)
{
  long double value;

  __asm ("facos%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define __have_fpu_acos

__MATH_INLINE double
__ieee754_atan (double x)
{
  double value;

  __asm ("fatan%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_INLINE float
__ieee754_atanf (float x)
{
  float value;

  __asm ("fatan%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_INLINE long double
__ieee754_atanl (long double x)
{
  long double value;

  __asm ("fatan%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define __have_fpu_atan

__MATH_INLINE double
__ieee754_atan2 (double y, double x)
{
  double pi, pi_over_2;

  __asm ("fmovecr%.x #0,%0"		/* extended precision pi */
	 : "=f" (pi)
	 : /* no inputs */ );
  __asm ("fscale%.b #-1,%0"		/* no loss of accuracy */
	 : "=f" (pi_over_2)
	 : "0" (pi));
  if (x > 0)
    {
      if (y > 0)
	{
	  if (x > y)
	    return __ieee754_atan (y / x);
	  else
	    return pi_over_2 - __ieee754_atan (x / y);
	}
      else
	{
	  if (x > -y)
	    return __ieee754_atan (y / x);
	  else
	    return - pi_over_2 - __ieee754_atan (x / y);
	}
    }
  else
    {
      if (y < 0)
	{
	  if (-x > -y)
	    return - pi + __ieee754_atan (y / x);
	  else
	    return - pi_over_2 - __ieee754_atan (x / y);
	}
      else
	{
	  if (-x > y)
	    return pi + __ieee754_atan (y / x);
	  else if (y > 0)
	    return pi_over_2 - __ieee754_atan (x / y);
	  else
	    {
	      double value;

	      __set_errno(EDOM);
	      value = __builtin_nan("");	/* quiet NaN */
	      return value;
	    }
	}
    }
}

__MATH_INLINE float
__ieee754_atan2f (float y, float x)
{
  float pi, pi_over_2;

  __asm ("fmovecr%.x #0,%0"		/* extended precision pi */
	 : "=f" (pi)
	 : /* no inputs */ );
  __asm ("fscale%.b #-1,%0"		/* no loss of accuracy */
	 : "=f" (pi_over_2)
	 : "0" (pi));
  if (x > 0)
    {
      if (y > 0)
	{
	  if (x > y)
	    return __ieee754_atanf (y / x);
	  else
	    return pi_over_2 - __ieee754_atanf (x / y);
	}
      else
	{
	  if (x > -y)
	    return __ieee754_atanf (y / x);
	  else
	    return - pi_over_2 - __ieee754_atanf (x / y);
	}
    }
  else
    {
      if (y < 0)
	{
	  if (-x > -y)
	    return - pi + __ieee754_atanf (y / x);
	  else
	    return - pi_over_2 - __ieee754_atanf (x / y);
	}
      else
	{
	  if (-x > y)
	    return pi + __ieee754_atanf (y / x);
	  else if (y > 0)
	    return pi_over_2 - __ieee754_atanf (x / y);
	  else
	    {
	      float value;

	      __set_errno(EDOM);
	      value = __builtin_nanf("");
	      return value;
	    }
	}
    }
}

__MATH_INLINE long double
__ieee754_atan2l (long double y, long double x)
{
  long double pi, pi_over_2;

  __asm ("fmovecr%.x #0,%0"		/* extended precision pi */
	 : "=f" (pi)
	 : /* no inputs */ );
  __asm ("fscale%.b #-1,%0"		/* no loss of accuracy */
	 : "=f" (pi_over_2)
	 : "0" (pi));
  if (x > 0)
    {
      if (y > 0)
	{
	  if (x > y)
	    return __ieee754_atanl (y / x);
	  else
	    return pi_over_2 - __ieee754_atanl (x / y);
	}
      else
	{
	  if (x > -y)
	    return __ieee754_atanl (y / x);
	  else
	    return - pi_over_2 - __ieee754_atanl (x / y);
	}
    }
  else
    {
      if (y < 0)
	{
	  if (-x > -y)
	    return - pi + __ieee754_atanl (y / x);
	  else
	    return - pi_over_2 - __ieee754_atanl (x / y);
	}
      else
	{
	  if (-x > y)
	    return pi + __ieee754_atanl (y / x);
	  else if (y > 0)
	    return pi_over_2 - __ieee754_atanl (x / y);
	  else
	    {
	      long double value;

	      __set_errno(EDOM);
	      value = __builtin_nanl("");
	      return value;
	    }
	}
    }
}
#define __have_fpu_atan2

__MATH_INLINE double
__ieee754_sinh (double x)
{
  double value;

  __asm ("fsinh%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_INLINE float
__ieee754_sinhf (float x)
{
  float value;

  __asm ("fsinh%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_INLINE long double
__ieee754_sinhl (long double x)
{
  long double value;

  __asm ("fsinh%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define __have_fpu_sinh

__MATH_INLINE double
__ieee754_cosh (double x)
{
  double value;

  __asm ("fcosh%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_INLINE float
__ieee754_coshf (float x)
{
  float value;

  __asm ("fcosh%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_INLINE long double
__ieee754_coshl (long double x)
{
  long double value;

  __asm ("fcosh%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define __have_fpu_cosh

__MATH_INLINE double
__ieee754_tanh (double x)
{
  double value;

  __asm ("ftanh%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_INLINE float
__ieee754_tanhf (float x)
{
  float value;

  __asm ("ftanh%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_INLINE long double
__ieee754_tanhl (long double x)
{
  long double value;

  __asm ("ftanh%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define __have_fpu_tanh

__MATH_INLINE double
__ieee754_atanh (double x)
{
  double value;

  __asm ("fatanh%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_INLINE float
__ieee754_atanhf (float x)
{
  float value;

  __asm ("fatanh%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_INLINE long double
__ieee754_atanhl (long double x)
{
  long double value;

  __asm ("fatanh%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define __have_fpu_atanh

__MATH_INLINE double
__ieee754_exp (double x)
{
  double value;

  __asm ("fetox%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_INLINE float
__ieee754_expf (float x)
{
  float value;

  __asm ("fetox%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_INLINE long double
__ieee754_expl (long double x)
{
  long double value;

  __asm ("fetox%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define __have_fpu_exp

__MATH_INLINE double
__ieee754_expm1 (double x)
{
  double value;

  __asm ("fetoxm1%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_INLINE float
__ieee754_expm1f (float x)
{
  float value;

  __asm ("fetoxm1%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_INLINE long double
__ieee754_expm1l (long double x)
{
  long double value;

  __asm ("fetoxm1%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define __have_fpu_expm1

__MATH_INLINE double
__ieee754_exp2 (double x)
{
  double value;

  __asm ("ftwotox%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_INLINE float
__ieee754_exp2f (float x)
{
  float value;

  __asm ("ftwotox%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_INLINE long double
__ieee754_exp2l (long double x)
{
  long double value;

  __asm ("ftwotox%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define __have_fpu_exp2

__MATH_INLINE double
__ieee754_pow2 (double x)
{
  double value;

  __asm ("ftwotox%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_INLINE float
__ieee754_pow2f (float x)
{
  float value;

  __asm ("ftwotox%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_INLINE long double
__ieee754_pow2l (long double x)
{
  long double value;

  __asm ("ftwotox%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define __have_fpu_pow2

__MATH_INLINE double
__ieee754_exp10 (double x)
{
  double value;

  __asm ("ftentox%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_INLINE float
__ieee754_exp10f (float x)
{
  float value;

  __asm ("ftentox%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_INLINE long double
__ieee754_exp10l (long double x)
{
  long double value;

  __asm ("ftentox%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define __have_fpu_exp10

__MATH_INLINE double
__ieee754_pow10 (double x)
{
  double value;

  __asm ("ftentox%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_INLINE float
__ieee754_pow10f (float x)
{
  float value;

  __asm ("ftentox%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_INLINE long double
__ieee754_pow10l (long double x)
{
  long double value;

  __asm ("ftentox%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define __have_fpu_pow10

__MATH_INLINE double
__ieee754_log (double x)
{
  double value;

  __asm ("flogn%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_INLINE float
__ieee754_logf (float x)
{
  float value;

  __asm ("flogn%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_INLINE long double
__ieee754_logl (long double x)
{
  long double value;

  __asm ("flogn%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define __have_fpu_log

__MATH_INLINE double
__ieee754_log1p (double x)
{
  double value;

  __asm ("flognp1%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_INLINE float
__ieee754_log1pf (float x)
{
  float value;

  __asm ("flognp1%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_INLINE long double
__ieee754_log1pl (long double x)
{
  long double value;

  __asm ("flognp1%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define __have_fpu_log1p

__MATH_INLINE double
__ieee754_log10 (double x)
{
  double value;

  __asm ("flog10%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_INLINE float
__ieee754_log10f (float x)
{
  float value;

  __asm ("flog10%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_INLINE long double
__ieee754_log10l (long double x)
{
  long double value;

  __asm ("flog10%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define __have_fpu_log10

__MATH_INLINE double
__ieee754_log2 (double x)
{
  double value;

  __asm ("flog2%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_INLINE float
__ieee754_log2f (float x)
{
  float value;

  __asm ("flog2%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_INLINE long double
__ieee754_log2l (long double x)
{
  long double value;

  __asm ("flog2%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define __have_fpu_log2

__MATH_INLINE double
__ieee754_sqrt (double x)
{
  double value;

  __asm ("fsqrt%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_INLINE float
__ieee754_sqrtf (float x)
{
  float value;

  __asm ("fsqrt%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_INLINE long double
__ieee754_sqrtl (long double x)
{
  long double value;

  __asm ("fsqrt%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define __have_fpu_sqrt

__MATH_INLINE double
__ieee754_fabs (double x)
{
  double value;

  __asm ("fabs%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_INLINE float
__ieee754_fabsf (float x)
{
  float value;

  __asm ("fabs%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_INLINE long double
__ieee754_fabsl (long double x)
{
  long double value;

  __asm ("fabs%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define __have_fpu_fabs

__MATH_INLINE double
__ieee754_ceil (double x)
{
  long rounding_mode, round_up;
  double value;

  __asm __volatile ("fmove%.l %!,%0"
		  : "=dm" (rounding_mode)
		  : /* no inputs */ );
  round_up = (rounding_mode & ~FE_ROUNDING_MASK) | FE_UPWARD;
  __asm __volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (round_up));
  __asm __volatile ("fint%.x %1,%0"
		  : "=f" (value)
		  : "f" (x));
  __asm __volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (rounding_mode));
  return value;
}

__MATH_INLINE float
__ieee754_ceilf (float x)
{
  long rounding_mode, round_up;
  float value;

  __asm __volatile ("fmove%.l %!,%0"
		  : "=dm" (rounding_mode)
		  : /* no inputs */ );
  round_up = (rounding_mode & ~FE_ROUNDING_MASK) | FE_UPWARD;
  __asm __volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (round_up));
  __asm __volatile ("fint%.x %1,%0"
		  : "=f" (value)
		  : "f" (x));
  __asm __volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (rounding_mode));
  return value;
}

__MATH_INLINE long double
__ieee754_ceill (long double x)
{
  long rounding_mode, round_up;
  long double value;

  __asm __volatile ("fmove%.l %!,%0"
		  : "=dm" (rounding_mode)
		  : /* no inputs */ );
  round_up = (rounding_mode & ~FE_ROUNDING_MASK) | FE_UPWARD;
  __asm __volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (round_up));
  __asm __volatile ("fint%.x %1,%0"
		  : "=f" (value)
		  : "f" (x));
  __asm __volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (rounding_mode));
  return value;
}
#define __have_fpu_ceil

__MATH_INLINE double
__ieee754_floor (double x)
{
  long rounding_mode, round_down;
  double value;

  __asm __volatile ("fmove%.l %!,%0"
		  : "=dm" (rounding_mode)
		  : /* no inputs */ );
  round_down = (rounding_mode & ~FE_ROUNDING_MASK) | FE_DOWNWARD;;
  __asm __volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (round_down));
  __asm __volatile ("fint%.x %1,%0"
		  : "=f" (value)
		  : "f" (x));
  __asm __volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (rounding_mode));
  return value;
}

__MATH_INLINE float
__ieee754_floorf (float x)
{
  long rounding_mode, round_down;
  float value;

  __asm __volatile ("fmove%.l %!,%0"
		  : "=dm" (rounding_mode)
		  : /* no inputs */ );
  round_down = (rounding_mode & ~FE_ROUNDING_MASK) | FE_DOWNWARD;
  __asm __volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (round_down));
  __asm __volatile ("fint%.x %1,%0"
		  : "=f" (value)
		  : "f" (x));
  __asm __volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (rounding_mode));
  return value;
}

__MATH_INLINE long double
__ieee754_floorl (long double x)
{
  long rounding_mode, round_down;
  long double value;

  __asm __volatile ("fmove%.l %!,%0"
		  : "=dm" (rounding_mode)
		  : /* no inputs */ );
  round_down = (rounding_mode & ~FE_ROUNDING_MASK) | FE_DOWNWARD;
  __asm __volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (round_down));
  __asm __volatile ("fint%.x %1,%0"
		  : "=f" (value)
		  : "f" (x));
  __asm __volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (rounding_mode));
  return value;
}
#define __have_fpu_floor

__MATH_INLINE double
__ieee754_trunc (double x)
{
  double value;

  __asm __volatile ("fintrz%.x %1,%0"
		  : "=f" (value)
		  : "f" (x));
  return value;
}

__MATH_INLINE float
__ieee754_truncf (float x)
{
  float value;

  __asm __volatile ("fintrz%.x %1,%0"
		  : "=f" (value)
		  : "f" (x));
  return value;
}

__MATH_INLINE long double
__ieee754_truncl (long double x)
{
  long double value;

  __asm __volatile ("fintrz%.x %1,%0"
		  : "=f" (value)
		  : "f" (x));
  return value;
}
#define __have_fpu_trunc

__MATH_INLINE double
__ieee754_rint (double x)
{
  double value;
  __asm __volatile ("fint%.x %1,%0"
		  : "=f" (value)
		  : "f" (x));
  return value;
}

__MATH_INLINE float
__ieee754_rintf (float x)
{
  float value;
  __asm __volatile ("fint%.x %1,%0"
		  : "=f" (value)
		  : "f" (x));
  return value;
}

__MATH_INLINE long double
__ieee754_rintl (long double x)
{
  long double value;
  __asm __volatile ("fint%.x %1,%0"
		  : "=f" (value)
		  : "f" (x));
  return value;
}
#define __have_fpu_rint

__MATH_INLINE long int
__ieee754_lrint (double x)
{
  long int value;
  __asm __volatile ("fmove.l %1,%0"
		  : "=dm" (value)
		  : "f" (x));
  return value;
}

__MATH_INLINE long int
__ieee754_lrintf (float x)
{
  long int value;
  __asm __volatile ("fmove.l %1,%0"
		  : "=dm" (value)
		  : "f" (x));
  return value;
}

__MATH_INLINE long int
__ieee754_lrintl (long double x)
{
  long int value;
  __asm __volatile ("fmove.l %1,%0"
		  : "=dm" (value)
		  : "f" (x));
  return value;
}
#define __have_fpu_lrint

__MATH_INLINE double
__ieee754_round (double x)
{
  long rounding_mode, round_nearest;
  double value;

  __asm __volatile ("fmove%.l %!,%0"
		  : "=dm" (rounding_mode)
		  : /* no inputs */ );
  round_nearest = (rounding_mode & ~FE_ROUNDING_MASK) | FE_TONEAREST;
  __asm __volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (round_nearest));
  __asm __volatile ("fint%.x %1,%0"
		  : "=f" (value)
		  : "f" (x));
  __asm __volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (rounding_mode));
  return value;
}

__MATH_INLINE float
__ieee754_roundf (float x)
{
  long rounding_mode, round_nearest;
  float value;

  __asm __volatile ("fmove%.l %!,%0"
		  : "=dm" (rounding_mode)
		  : /* no inputs */ );
  round_nearest = (rounding_mode & ~FE_ROUNDING_MASK) | FE_TONEAREST;
  __asm __volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (round_nearest));
  __asm __volatile ("fint%.x %1,%0"
		  : "=f" (value)
		  : "f" (x));
  __asm __volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (rounding_mode));
  return value;
}

__MATH_INLINE long double
__ieee754_roundl (long double x)
{
  long rounding_mode, round_nearest;
  long double value;

  __asm __volatile ("fmove%.l %!,%0"
		  : "=dm" (rounding_mode)
		  : /* no inputs */ );
  round_nearest = (rounding_mode & ~FE_ROUNDING_MASK) | FE_TONEAREST;
  __asm __volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (round_nearest));
  __asm __volatile ("fint%.x %1,%0"
		  : "=f" (value)
		  : "f" (x));
  __asm __volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (rounding_mode));
  return value;
}
#define __have_fpu_round

__MATH_INLINE long int
__ieee754_lround(double x)
{
  long rounding_mode, round_nearest;
  long value;

  __asm __volatile ("fmove%.l %!,%0"
		  : "=dm" (rounding_mode)
		  : /* no inputs */ );
  round_nearest = rounding_mode & ~0x30;
  __asm __volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (round_nearest));
  __asm __volatile ("fint%.x %2,%1\n"
  			"\tfmove%.l %1,%0"
		  : "=dm" (value), "=f"(x)
		  : "1" (x));
  __asm __volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (rounding_mode));
  return value;
}

__MATH_INLINE long int __ieee754_lroundf(float x)
{
  long rounding_mode, round_nearest;
  long value;

  __asm __volatile ("fmove%.l %!,%0"
		  : "=dm" (rounding_mode)
		  : /* no inputs */ );
  round_nearest = rounding_mode & ~0x30;
  __asm __volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (round_nearest));
  __asm __volatile ("fint%.x %2,%1\n"
  			"\tfmove%.l %1,%0"
		  : "=dm" (value), "=f"(x)
		  : "1" (x));
  __asm __volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (rounding_mode));
  return value;
}

__MATH_INLINE long int __ieee754_lroundl(long double x)
{
  long rounding_mode, round_nearest;
  long value;

  __asm __volatile ("fmove%.l %!,%0"
		  : "=dm" (rounding_mode)
		  : /* no inputs */ );
  round_nearest = rounding_mode & ~0x30;
  __asm __volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (round_nearest));
  __asm __volatile ("fint%.x %2,%1\n"
  			"\tfmove%.l %1,%0"
		  : "=dm" (value), "=f"(x)
		  : "1" (x));
  __asm __volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (rounding_mode));
  return value;
}
#define __have_fpu_lround

__MATH_INLINE double
__ieee754_fmod (double x, double y)
{
  double value;

  __asm ("fmod%.x %2,%0"
	 : "=f" (value)
	 : "0" (x),
	   "f" (y));
  return value;
}

__MATH_INLINE float
__ieee754_fmodf (float x, float y)
{
  float value;

  __asm ("fmod%.x %2,%0"
	 : "=f" (value)
	 : "0" (x),
	   "f" (y));
  return value;
}

__MATH_INLINE long double
__ieee754_fmodl (long double x, long double y)
{
  long double value;

  __asm ("fmod%.x %2,%0"
	 : "=f" (value)
	 : "0" (x),
	   "f" (y));
  return value;
}
#define __have_fpu_fmod

__MATH_INLINE double
__ieee754_drem (double x, double y)
{
  double value;

  __asm ("frem%.x %2,%0"
	 : "=f" (value)
	 : "0" (x),
	   "f" (y));
  return value;
}

__MATH_INLINE float
__ieee754_dremf (float x, float y)
{
  float value;

  __asm ("frem%.x %2,%0"
	 : "=f" (value)
	 : "0" (x),
	   "f" (y));
  return value;
}

__MATH_INLINE long double
__ieee754_dreml (long double x, long double y)
{
  long double value;

  __asm ("frem%.x %2,%0"
	 : "=f" (value)
	 : "0" (x),
	   "f" (y));
  return value;
}
#define __have_fpu_drem

__MATH_INLINE double
__ieee754_remainder (double x, double y)
{
  double value;

  __asm ("frem%.x %2,%0"
	 : "=f" (value)
	 : "0" (x),
	   "f" (y));
  return value;
}

__MATH_INLINE float
__ieee754_remainderf (float x, float y)
{
  float value;

  __asm ("frem%.x %2,%0"
	 : "=f" (value)
	 : "0" (x),
	   "f" (y));
  return value;
}

__MATH_INLINE long double
__ieee754_remainderl (long double x, long double y)
{
  long double value;

  __asm ("frem%.x %2,%0"
	 : "=f" (value)
	 : "0" (x),
	   "f" (y));
  return value;
}
#define __have_fpu_remainder


__MATH_INLINE double
__ieee754_remquo(double x, double y, int *quo)
{
  double result;
  int cquo;
  unsigned long fpsr;

  __asm ("frem%.x %2,%0\n\tfmove%.l %/fpsr,%1"
	 : "=f" (result), "=dm" (fpsr) : "f" (y), "0" (x));
  cquo = (fpsr >> 16) & 0x7f;
  if (fpsr & (1L << 23))
    cquo = -cquo;
  *quo = cquo;
  return result;
}

__MATH_INLINE float
__ieee754_remquof(float x, float y, int *quo)
{
  float result;
  int cquo;
  unsigned long fpsr;

  __asm ("frem%.x %2,%0\n\tfmove%.l %/fpsr,%1"
	 : "=f" (result), "=dm" (fpsr) : "f" (y), "0" (x));
  cquo = (fpsr >> 16) & 0x7f;
  if (fpsr & (1L << 23))
    cquo = -cquo;
  *quo = cquo;
  return result;
}

__MATH_INLINE long double
__ieee754_remquol(long double x, long double y, int *quo)
{
  long double result;
  int cquo;
  unsigned long fpsr;

  __asm ("frem%.x %2,%0\n\tfmove%.l %/fpsr,%1"
	 : "=f" (result), "=dm" (fpsr) : "f" (y), "0" (x));
  cquo = (fpsr >> 16) & 0x7f;
  if (fpsr & (1L << 23))
    cquo = -cquo;
  *quo = cquo;
  return result;
}
#define __have_fpu_remquo


__MATH_INLINE double
__ieee754_scalbn (double x, int n)
{
  double value;
  long exp = (long)(n);

  __asm ("fscale%.l %2,%0"
	 : "=f" (value)
	 : "0" (x),
	   "dmi" (exp));
  return value;
}

__MATH_INLINE float
__ieee754_scalbnf (float x, int n)
{
  float value;
  long exp = (long)(n);

  __asm ("fscale%.l %2,%0"
	 : "=f" (value)
	 : "0" (x),
	   "dmi" (exp));
  return value;
}

__MATH_INLINE long double
__ieee754_scalbnl (long double x, int n)
{
  long double value;
  long exp = (long)(n);

  __asm ("fscale%.l %2,%0"
	 : "=f" (value)
	 : "0" (x),
	   "dmi" (exp));
  return value;
}
#define __have_fpu_scalbn

__MATH_INLINE double
__ieee754_scalbln (double x, long n)
{
  double value;
  long exp = (long)(n);

  __asm ("fscale%.l %2,%0"
	 : "=f" (value)
	 : "0" (x),
	   "dmi" (exp));
  return value;
}

__MATH_INLINE float
__ieee754_scalblnf (float x, long n)
{
  float value;
  long exp = (long)(n);

  __asm ("fscale%.l %2,%0"
	 : "=f" (value)
	 : "0" (x),
	   "dmi" (exp));
  return value;
}

__MATH_INLINE long double
__ieee754_scalblnl (long double x, long n)
{
  long double value;
  long exp = (long)(n);

  __asm ("fscale%.l %2,%0"
	 : "=f" (value)
	 : "0" (x),
	   "dmi" (exp));
  return value;
}
#define __have_fpu_scalbln

__MATH_INLINE double
__ieee754_logb (double x)
{
  double exponent;

  __asm ("fgetexp%.x %1,%0"
	 : "=f" (exponent)
	 : "f" (x));
  return exponent;
}

__MATH_INLINE float
__ieee754_logbf (float x)
{
  float exponent;

  __asm ("fgetexp%.x %1,%0"
	 : "=f" (exponent)
	 : "f" (x));
  return exponent;
}

__MATH_INLINE long double
__ieee754_logbl (long double x)
{
  long double exponent;

  __asm ("fgetexp%.x %1,%0"
	 : "=f" (exponent)
	 : "f" (x));
  return exponent;
}
#define __have_fpu_logb

__MATH_INLINE int
__ieee754_ilogb (double x)
{
  double exponent;
  unsigned long x_cond;

  __m81_test (x, x_cond);
  /* We must return consistent values for zero and NaN.  */
  if (x_cond & __M81_COND_ZERO)
    return FP_ILOGB0;
  if (x_cond & (__M81_COND_NAN | __M81_COND_INF))
    return FP_ILOGBNAN;

  __asm ("fgetexp%.x %1,%0"
	 : "=f" (exponent)
	 : "f" (x));
  return (int)exponent;
}

__MATH_INLINE int
__ieee754_ilogbf (float x)
{
  float exponent;
  unsigned long x_cond;

  __m81_test (x, x_cond);
  /* We must return consistent values for zero and NaN.  */
  if (x_cond & __M81_COND_ZERO)
    return FP_ILOGB0;
  if (x_cond & (__M81_COND_NAN | __M81_COND_INF))
    return FP_ILOGBNAN;

  __asm ("fgetexp%.x %1,%0"
	 : "=f" (exponent)
	 : "f" (x));
  return (int)exponent;
}

__MATH_INLINE int
__ieee754_ilogbl (long double x)
{
  long double exponent;
  unsigned long x_cond;

  __m81_test (x, x_cond);
  /* We must return consistent values for zero and NaN.  */
  if (x_cond & __M81_COND_ZERO)
    return FP_ILOGB0;
  if (x_cond & (__M81_COND_NAN | __M81_COND_INF))
    return FP_ILOGBNAN;

  __asm ("fgetexp%.x %1,%0"
	 : "=f" (exponent)
	 : "f" (x));
  return (int)exponent;
}
#define __have_fpu_ilogb


__MATH_INLINE double
__ieee754_ldexp (double x, int n)
{
  double value;

  __asm ("fscale%.l %2,%0"
	 : "=f" (value)
	 : "0" (x),
	   "dmi" (n));
  return value;
}

__MATH_INLINE float
__ieee754_ldexpf (float x, int n)
{
  float value;

  __asm ("fscale%.l %2,%0"
	 : "=f" (value)
	 : "0" (x),
	   "dmi" (n));
  return value;
}

__MATH_INLINE long double
__ieee754_ldexpl (long double x, int n)
{
  long double value;

  __asm ("fscale%.l %2,%0"
	 : "=f" (value)
	 : "0" (x),
	   "dmi" (n));
  return value;
}
#define __have_fpu_ldexp

__MATH_INLINE double
__ieee754_frexp (double value, int *expptr)
{
  double float_exponent, mantissa;
  int int_exponent;
  unsigned long fpsr;

  __m81_test(value, fpsr);
  if (fpsr & (__M81_COND_NAN|__M81_COND_INF|__M81_COND_ZERO))
    {
      /* Not finite or zero.  */
      *expptr = 0;
      return value;
    }
  __asm ("fgetexp%.x %1,%0"
	 : "=f" (float_exponent)	/* integer-valued float */
	 : "f" (value));
  int_exponent = (int) float_exponent + 1;
  *expptr = int_exponent;
  __asm ("fscale%.l %2, %0"
	 : "=f" (mantissa)
	 : "0" (value), "dmi" (-int_exponent));
  return mantissa;
}

__MATH_INLINE float
__ieee754_frexpf (float value, int *expptr)
{
  float float_exponent, mantissa;
  int int_exponent;
  unsigned long fpsr;

  __m81_test(value, fpsr);
  if (fpsr & (__M81_COND_NAN|__M81_COND_INF|__M81_COND_ZERO))
    {
      /* Not finite or zero.  */
      *expptr = 0;
      return value;
    }
  __asm ("fgetexp%.x %1,%0"
	 : "=f" (float_exponent)	/* integer-valued float */
	 : "f" (value));
  int_exponent = (int) float_exponent + 1;
  *expptr = int_exponent;
  __asm ("fscale%.l %2, %0"
	 : "=f" (mantissa)
	 : "0" (value), "dmi" (-int_exponent));
  return mantissa;
}

__MATH_INLINE long double
__ieee754_frexpl (long double value, int *expptr)
{
  long double float_exponent, mantissa;
  int int_exponent;
  unsigned long fpsr;

  __m81_test(value, fpsr);
  if (fpsr & (__M81_COND_NAN|__M81_COND_INF|__M81_COND_ZERO))
    {
      /* Not finite or zero.  */
      *expptr = 0;
      return value;
    }
  __asm ("fgetexp%.x %1,%0"
	 : "=f" (float_exponent)	/* integer-valued float */
	 : "f" (value));
  int_exponent = (int) float_exponent + 1;
  *expptr = int_exponent;
  /* Unnormalized numbers must be handled specially, otherwise fscale
     results in overflow.  */
  if (int_exponent <= -16384)
    {
      value *= 0x1p16383L;
      int_exponent += 16383;
    }
  else if (int_exponent >= 16384)
    {
      value *= 0x1p-16383L;
      int_exponent -= 16383;
    }

  __asm ("fscale%.l %2, %0"
	 : "=f" (mantissa)
	 : "0" (value), "dmi" (-int_exponent));
  return mantissa;
}
#define __have_fpu_frexp

__MATH_INLINE double
__ieee754_significand(double x)
{
  double mantissa;

  __asm ("fgetman%.x %1,%0"
	 : "=f" (mantissa)		/* 1.0 <= mantissa < 2.0 */
	 : "f" (x));
  return mantissa;
}

__MATH_INLINE float
__ieee754_significandf(float x)
{
  float mantissa;

  __asm ("fgetman%.x %1,%0"
	 : "=f" (mantissa)		/* 1.0 <= mantissa < 2.0 */
	 : "f" (x));
  return mantissa;
}

__MATH_INLINE long double
__ieee754_significandl(long double x)
{
  long double mantissa;

  __asm ("fgetman%.x %1,%0"
	 : "=f" (mantissa)		/* 1.0 <= mantissa < 2.0 */
	 : "f" (x));
  return mantissa;
}
#define __have_fpu_significand

__MATH_INLINE double
__ieee754_modf (double x, double *ip)
{
  double temp, result;
  unsigned long x_cond;

  temp = __ieee754_trunc(x);
  if (ip)
    *ip = temp;
  __m81_test (x, x_cond);
  if (x_cond & __M81_COND_INF)
    {
      result = 0;
      if (x_cond & __M81_COND_NEG)
	result = -result;
    }
  else if (x_cond & __M81_COND_ZERO)
    result = x;
  else
    result = x - temp;
  return result;
}

__MATH_INLINE float
__ieee754_modff (float x, float *ip)
{
  float temp, result;
  unsigned long x_cond;

  temp = __ieee754_truncf(x);
  if (ip)
    *ip = temp;
  __m81_test (x, x_cond);
  if (x_cond & __M81_COND_INF)
    {
      result = 0;
      if (x_cond & __M81_COND_NEG)
	result = -result;
    }
  else if (x_cond & __M81_COND_ZERO)
    result = x;
  else
    result = x - temp;
  return result;
}

__MATH_INLINE long double
__ieee754_modfl (long double x, long double *ip)
{
  long double temp, result;
  unsigned long x_cond;

  temp = __ieee754_truncl(x);
  if (ip)
    *ip = temp;
  __m81_test (x, x_cond);
  if (x_cond & __M81_COND_INF)
    {
      result = 0;
      if (x_cond & __M81_COND_NEG)
	result = -result;
    }
  else if (x_cond & __M81_COND_ZERO)
    result = x;
  else
    result = x - temp;
  return result;
}
#define __have_fpu_modf

/* ISO C99 defines some macros to perform unordered comparisons.  The
   m68k FPU supports this with special opcodes and we should use them.
   These must not be inline functions since we have to be able to handle
   all floating-point types.  */
#  undef isgreater
#  undef isgreaterequal
#  undef isless
#  undef islessequal
#  undef islessgreater
#  undef isunordered
#  define isgreater(x, y)					\
   __extension__					\
   ({ signed char __result;					\
      __asm__ ("fcmp%.x %2,%1; fsogt %0"		\
	       : "=dm" (__result) : "f" (x), "f" (y));	\
      -__result; })

#  define isgreaterequal(x, y)				\
   __extension__					\
   ({ signed char __result;					\
      __asm__ ("fcmp%.x %2,%1; fsoge %0"		\
	       : "=dm" (__result) : "f" (x), "f" (y));	\
      -__result; })

#  define isless(x, y)					\
   __extension__					\
   ({ signed char __result;					\
      __asm__ ("fcmp%.x %2,%1; fsolt %0"		\
	       : "=dm" (__result) : "f" (x), "f" (y));	\
      -__result; })

#  define islessequal(x, y)				\
   __extension__					\
   ({ signed char __result;					\
      __asm__ ("fcmp%.x %2,%1; fsole %0"		\
	       : "=dm" (__result) : "f" (x), "f" (y));	\
      -__result; })

#  define islessgreater(x, y)				\
   __extension__					\
   ({ signed char __result;					\
      __asm__ ("fcmp%.x %2,%1; fsogl %0"		\
	       : "=dm" (__result) : "f" (x), "f" (y));	\
      -__result; })

#  define isunordered(x, y)				\
   __extension__					\
   ({ signed char __result;					\
      __asm__ ("fcmp%.x %2,%1; fsun %0"			\
	       : "=dm" (__result) : "f" (x), "f" (y));	\
      -__result; })

#endif /* __NO_MATH_INLINES */

#endif

```

`include/asm/ieee754/m68k_ahcc.h`:

```h
#if defined(__AHCC__) && defined(__HAVE_68881__)

#ifndef __NO_MATH_INLINES

#endif /* __NO_MATH_INLINES */

#endif

```

`include/asm/ieee754/m68k_cf.h`:

```h
#if defined(__GNUC__) && defined(__mcffpu__)

# define math_opt_barrier(x) \
  ({ __typeof (x) __x;					\
    __asm ("" : "=f" (__x) : "0" (x));			\
    __x; })
# define math_force_eval(x) \
  do {							\
    __typeof (x) __x = (x);				\
    __asm __volatile ("" : : "f" (__x));		\
  } while (0)

#ifndef __NO_MATH_INLINES

__MATH_INLINE double
__ieee754_atan2 (double y, double x)
{
  double pi, pi_over_2;

#ifdef M_PI
  pi = M_PI;
  pi_over_2 = M_PI_2;
#else
  pi = 3.14159265358979323846;
  pi_over_2 = 1.57079632679489661923;
#endif
  if (x > 0)
    {
      if (y > 0)
	{
	  if (x > y)
	    return atan (y / x);
	  else
	    return pi_over_2 - atan (x / y);
	}
      else
	{
	  if (x > -y)
	    return atan (y / x);
	  else
	    return - pi_over_2 - atan (x / y);
	}
    }
  else
    {
      if (y < 0)
	{
	  if (-x > -y)
	    return - pi + atan (y / x);
	  else
	    return - pi_over_2 - atan (x / y);
	}
      else
	{
	  if (-x > y)
	    return pi + atan (y / x);
	  else if (y > 0)
	    return pi_over_2 - atan (x / y);
	  else
	    {
	      double value;

	      __set_errno(EDOM);
	      value = __builtin_nan("");
	      return value;
	    }
	}
    }
}

__MATH_INLINE float
__ieee754_atan2f (float y, float x)
{
  float pi, pi_over_2;

#ifdef M_PI
  pi = M_PI;
  pi_over_2 = M_PI_2;
#else
  pi = 3.14159265358979323846;
  pi_over_2 = 1.57079632679489661923;
#endif
  if (x > 0)
    {
      if (y > 0)
	{
	  if (x > y)
	    return atanf (y / x);
	  else
	    return pi_over_2 - atanf (x / y);
	}
      else
	{
	  if (x > -y)
	    return atanf (y / x);
	  else
	    return - pi_over_2 - atanf (x / y);
	}
    }
  else
    {
      if (y < 0)
	{
	  if (-x > -y)
	    return - pi + atanf (y / x);
	  else
	    return - pi_over_2 - atanf (x / y);
	}
      else
	{
	  if (-x > y)
	    return pi + atanf (y / x);
	  else if (y > 0)
	    return pi_over_2 - atanf (x / y);
	  else
	    {
	      float value;

	      __set_errno(EDOM);
	      value = __builtin_nanf("");
	      return value;
	    }
	}
    }
}

__MATH_INLINE long double
__ieee754_atan2l (long double y, long double x)
{
	return __ieee754_atan2(y, x);
}
#define __have_fpu_atan2

__MATH_INLINE double
__ieee754_sqrt (double x)
{
  double value;

  __asm ("fsqrt%.d %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_INLINE float
__ieee754_sqrtf (float x)
{
  float value;

  __asm ("fsqrt%.d %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_INLINE long double
__ieee754_sqrtl (long double x)
{
	return __ieee754_sqrt(x);
}
#define __have_fpu_sqrt

__MATH_INLINE double
__ieee754_fabs (double x)
{
  double value;

  __asm ("fabs%.d %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_INLINE float
__ieee754_fabsf (float x)
{
  float value;

  __asm ("fabs%.d %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_INLINE long double
__ieee754_fabsl (long double x)
{
	return __ieee754_fabs(x);
}
#define __have_fpu_fabs

__MATH_INLINE double
__ieee754_ceil (double x)
{
  long rounding_mode, round_up;
  double value;

  __asm volatile ("fmove%.l %!,%0"
		  : "=dm" (rounding_mode)
		  : /* no inputs */ );
  round_up = rounding_mode | 0x30;
  __asm volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (round_up));
  __asm volatile ("fint%.d %1,%0"
		  : "=f" (value)
		  : "f" (x));
  __asm volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (rounding_mode));
  return value;
}

__MATH_INLINE float
__ieee754_ceilf (float x)
{
  long rounding_mode, round_up;
  float value;

  __asm volatile ("fmove%.l %!,%0"
		  : "=dm" (rounding_mode)
		  : /* no inputs */ );
  round_up = rounding_mode | 0x30;
  __asm volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (round_up));
  __asm volatile ("fint%.d %1,%0"
		  : "=f" (value)
		  : "f" (x));
  __asm volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (rounding_mode));
  return value;
}

__MATH_INLINE long double
__ieee754_ceill (long double x)
{
	return __ieee754_ceil(x);
}
#define __have_fpu_ceil

__MATH_INLINE double
__ieee754_floor (double x)
{
  long rounding_mode, round_down;
  double value;

  __asm volatile ("fmove%.l %!,%0"
		  : "=dm" (rounding_mode)
		  : /* no inputs */ );
  round_down = (rounding_mode & ~0x10)
		| 0x20;
  __asm volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (round_down));
  __asm volatile ("fint%.d %1,%0"
		  : "=f" (value)
		  : "f" (x));
  __asm volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (rounding_mode));
  return value;
}

__MATH_INLINE float
__ieee754_floorf (float x)
{
  long rounding_mode, round_down;
  float value;

  __asm volatile ("fmove%.l %!,%0"
		  : "=dm" (rounding_mode)
		  : /* no inputs */ );
  round_down = (rounding_mode & ~0x10)
		| 0x20;
  __asm volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (round_down));
  __asm volatile ("fint%.d %1,%0"
		  : "=f" (value)
		  : "f" (x));
  __asm volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (rounding_mode));
  return value;
}

__MATH_INLINE long double
__ieee754_floorl (long double x)
{
	return __ieee754_floor(x);
}
#define __have_fpu_floor

__MATH_INLINE double
__ieee754_trunc (double x)
{
  double value;

  __asm volatile ("fintrz%.d %1,%0"
		  : "=f" (value)
		  : "f" (x));
  return value;
}

__MATH_INLINE float
__ieee754_truncf (float x)
{
  float value;

  __asm volatile ("fintrz%.d %1,%0"
		  : "=f" (value)
		  : "f" (x));
  return value;
}

__MATH_INLINE long double
__ieee754_truncl (long double x)
{
	return __ieee754_trunc(x);
}
#define __have_fpu_trunc

__MATH_INLINE double
__ieee754_rint (double x)
{
  double value;
  __asm volatile ("fint%.d %1,%0"
		  : "=f" (value)
		  : "f" (x));
  return value;
}

__MATH_INLINE float
__ieee754_rintf (float x)
{
  float value;
  __asm volatile ("fint%.d %1,%0"
		  : "=f" (value)
		  : "f" (x));
  return value;
}

__MATH_INLINE long double
__ieee754_rintl (long double x)
{
	return __ieee754_rint(x);
}
#define __have_fpu_rint

__MATH_INLINE double
__ieee754_round (double x)
{
  long rounding_mode, round_nearest;
  double value;

  __asm volatile ("fmove%.l %!,%0"
		  : "=dm" (rounding_mode)
		  : /* no inputs */ );
  round_nearest = rounding_mode & ~0x30;
  __asm volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (round_nearest));
  __asm volatile ("fint%.d %1,%0"
		  : "=f" (value)
		  : "f" (x));
  __asm volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (rounding_mode));
  return value;
}

__MATH_INLINE float
__ieee754_roundf (float x)
{
  long rounding_mode, round_nearest;
  float value;

  __asm volatile ("fmove%.l %!,%0"
		  : "=dm" (rounding_mode)
		  : /* no inputs */ );
  round_nearest = rounding_mode & ~0x30;
  __asm volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (round_nearest));
  __asm volatile ("fint%.d %1,%0"
		  : "=f" (value)
		  : "f" (x));
  __asm volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (rounding_mode));
  return value;
}

__MATH_INLINE long double
__ieee754_roundl (long double x)
{
	return __ieee754_round(x);
}
#define __have_fpu_round

__MATH_INLINE double
__ieee754_modf (double x, double *ip)
{
  double temp;

  __asm ("fintrz%.d %1,%0"
	 : "=f" (temp)			/* integer-valued float */
	 : "f" (x));
  *ip = temp;
  return x - temp;
}

__MATH_INLINE float
__ieee754_modff (float x, float *ip)
{
  float temp;

  __asm ("fintrz%.d %1,%0"
	 : "=f" (temp)			/* integer-valued float */
	 : "f" (x));
  *ip = temp;
  return x - temp;
}

__MATH_INLINE long double
__ieee754_modfl (long double x, long double *ip)
{
  long double temp;

  __asm ("fintrz%.d %1,%0"
	 : "=f" (temp)			/* integer-valued float */
	 : "f" (x));
  *ip = temp;
  return x - temp;
}
#define __have_fpu_modf

#endif /* __NO_MATH_INLINES */

#endif

```

`include/asm/ieee754/m68k_pc.h`:

```h
# define math_opt_barrier(x) (x)
# define math_force_eval(x) (void)(x)

#if defined(__PUREC__)

#if defined(__HAVE_68881__)

#ifndef __NO_MATH_INLINES


#endif /* __NO_MATH_INLINES */

#endif

#endif

```

`include/asm/ieee754/x86_64.h`:

```h
#include "asm/ieee754/x86l.h"

#ifndef __NO_MATH_INLINES

__MATH_INLINE double
__ieee754_fabs(double x)
{
	return __builtin_fabs(x);
}

__MATH_INLINE float
__ieee754_fabsf(float x)
{
	return __builtin_fabsf(x);
}

__MATH_INLINE double
__ieee754_sin(double x)
{
	return (double)__ieee754_sinl(x);
}

__MATH_INLINE float
__ieee754_sinf(float x)
{
	return (float)__ieee754_sinl(x);
}

__MATH_INLINE double
__ieee754_cos(double x)
{
	return (double)__ieee754_cosl(x);
}

__MATH_INLINE float
__ieee754_cosf(float x)
{
	return (float)__ieee754_cosl(x);
}

__MATH_INLINE void
__ieee754_sincos(double x, double *sinx, double *cosx)
{
	long double lsinx, lcosx;
	__ieee754_sincosl(x, &lsinx, &lcosx);
	*sinx = (double)lsinx;
	*cosx = (double)lcosx;
}

__MATH_INLINE void
__ieee754_sincosf(float x, float *sinx, float *cosx)
{
	long double lsinx, lcosx;
	__ieee754_sincosl(x, &lsinx, &lcosx);
	*sinx = (float)lsinx;
	*cosx = (float)lcosx;
}

__MATH_INLINE double
__ieee754_tan(double x)
{
	return (double)__ieee754_tanl(x);
}

__MATH_INLINE float
__ieee754_tanf(float x)
{
	return (float)__ieee754_tanl(x);
}

__MATH_INLINE double
__ieee754_acos (double x)
{
	return (double) __ieee754_acosl(x);
}

__MATH_INLINE float
__ieee754_acosf (float x)
{
	return (float) __ieee754_acosl(x);
}

__MATH_INLINE double
__ieee754_asin (double x)
{
	return (double) __ieee754_asinl(x);
}

__MATH_INLINE float
__ieee754_asinf (float x)
{
	return (float) __ieee754_asinl(x);
}

__MATH_INLINE double
__ieee754_atan (double x)
{
	return (double) __ieee754_atanl(x);
}

__MATH_INLINE float
__ieee754_atanf (float x)
{
	return (float) __ieee754_atanl(x);
}

__MATH_INLINE double
__ieee754_atan2 (double y, double x)
{
	return (double) __ieee754_atan2l(y, x);
}

__MATH_INLINE float
__ieee754_atan2f (float y, float x)
{
	return (float) __ieee754_atan2l(y, x);
}

__MATH_INLINE double
__ieee754_sqrt (double x)
{
  double res;

  asm ("sqrtsd %1, %0" : "=x" (res) : "xm" (x));

  return res;
}

__MATH_INLINE float
__ieee754_sqrtf (float x)
{
  float res;

  asm ("sqrtss %1, %0" : "=x" (res) : "xm" (x));

  return res;
}

__MATH_INLINE double
__ieee754_fmod (double x, double y)
{
	return (double) __ieee754_fmodl(x, y);
}

__MATH_INLINE float
__ieee754_fmodf (float x, float y)
{
	return (float) __ieee754_fmodl(x, y);
}

__MATH_INLINE double
__ieee754_remainder (double x, double y)
{
	return (double) __ieee754_remainderl(x, y);
}


__MATH_INLINE float
__ieee754_remainderf (float x, float y)
{
	return (float) __ieee754_remainderl(x, y);
}

#if 0

__MATH_INLINE double
__ieee754_remquo (double x, double y, int *quo)
{
	return (double) __ieee754_remquol(x, y, quo);
}

__MATH_INLINE float
__ieee754_remquof (float x, float y, int *quo)
{
	return (float) __ieee754_remquol(x, y, quo);
}

#endif

__MATH_INLINE double
__ieee754_ceil (double x)
{
	return (double) __ieee754_ceill(x);
}

__MATH_INLINE float
__ieee754_ceilf (float x)
{
	return (float) __ieee754_ceill(x);
}

__MATH_INLINE double
__ieee754_floor (double x)
{
	return (double) __ieee754_floorl(x);
}

__MATH_INLINE float
__ieee754_floorf (float x)
{
	return (float) __ieee754_floorl(x);
}

__MATH_INLINE double
__ieee754_trunc (double x)
{
	return (double) __ieee754_truncl(x);
}

__MATH_INLINE float
__ieee754_truncf (float x)
{
	return (float) __ieee754_truncl(x);
}

__MATH_INLINE double
__ieee754_rint (double x)
{
	return (double) __ieee754_rintl(x);
}

__MATH_INLINE float
__ieee754_rintf (float x)
{
	return (float) __ieee754_rintl(x);
}

__MATH_INLINE long
__ieee754_lrint (double x)
{
	return __ieee754_lrintl(x);
}

__MATH_INLINE long
__ieee754_lrintf (float x)
{
	return __ieee754_lrintl(x);
}

__extension__ __MATH_INLINE long long
__ieee754_llrint (double x)
{
	return __ieee754_llrintl(x);
}

__extension__ __MATH_INLINE long long
__ieee754_llrintf (float x)
{
	return __ieee754_llrintl(x);
}

#if 0 /* frndint rounds in wrong direction */

__MATH_INLINE double
__ieee754_round (double x)
{
	return (double) __ieee754_roundl(x);
}

__MATH_INLINE float
__ieee754_roundf (float x)
{
	return (float) __ieee754_roundl(x);
}

#endif

__MATH_INLINE double
__ieee754_scalbn (double x, int n)
{
	return (double) __ieee754_scalbnl(x, n);
}

__MATH_INLINE float
__ieee754_scalbnf (float x, int n)
{
	return (float) __ieee754_scalbnl(x, n);
}

__MATH_INLINE double
__ieee754_scalbln (double x, long n)
{
	return (double) __ieee754_scalblnl(x, n);
}

__MATH_INLINE float
__ieee754_scalblnf (float x, long n)
{
	return (float) __ieee754_scalblnl(x, n);
}

__MATH_INLINE double
__ieee754_logb (double x)
{
	return (double) __ieee754_logbl(x);
}

__MATH_INLINE float
__ieee754_logbf (float x)
{
	return (float) __ieee754_logbl(x);
}

__MATH_INLINE double
__ieee754_expm1 (double x)
{
	return (double) __ieee754_expm1l(x);
}

__MATH_INLINE float
__ieee754_expm1f (float x)
{
	return (float) __ieee754_expm1l(x);
}

__MATH_INLINE double
__ieee754_exp2 (double x)
{
	return (double) __ieee754_exp2l(x);
}

__MATH_INLINE float
__ieee754_exp2f (float x)
{
	return (float) __ieee754_exp2l(x);
}

__MATH_INLINE double
__ieee754_log (double x)
{
	return (double) __ieee754_logl(x);
}

__MATH_INLINE float
__ieee754_logf (float x)
{
	return (float) __ieee754_logl(x);
}

__MATH_INLINE double
__ieee754_log1p (double x)
{
	return (double) __ieee754_log1pl(x);
}

__MATH_INLINE float
__ieee754_log1pf (float x)
{
	return (float) __ieee754_log1pl(x);
}

__MATH_INLINE double
__ieee754_log2 (double x)
{
	return (double) __ieee754_log2l(x);
}

__MATH_INLINE float
__ieee754_log2f (float x)
{
	return (float) __ieee754_log2l(x);
}

__MATH_INLINE double
__ieee754_log10 (double x)
{
	return (double) __ieee754_log10l(x);
}

__MATH_INLINE float
__ieee754_log10f (float x)
{
	return (float) __ieee754_log10l(x);
}

__MATH_INLINE double
__ieee754_exp (double x)
{
	return (double) __ieee754_expl(x);
}

__MATH_INLINE float
__ieee754_expf (float x)
{
	return (float) __ieee754_expl(x);
}

__MATH_INLINE double
__ieee754_modf (double x, double *ip)
{
	long double temp, result;
	result = __ieee754_modfl(x, &temp);
	if (ip)
		*ip = (double) temp;
	return (double) result;
}

__MATH_INLINE float
__ieee754_modff (float x, float *ip)
{
	long double temp, result;
	result = __ieee754_modfl(x, &temp);
	if (ip)
		*ip = (float) temp;
	return (float) result;
}

#endif /* __NO_MATH_INLINES */

```

`include/asm/ieee754/x86l.h`:

```h
int __x86_have_sse(void);

#if defined(__x86_64__) || defined(__SSE__)
#  define HAVE_SSE 1
#else
#  define HAVE_SSE __x86_have_sse()
#endif

/* Bit values returned by __x87_test.  */

#define __X87_COND_NAN		 0x0100
#define __X87_COND_NEG		 0x0200
#define __X87_COND_NORMAL	 0x0400
#define __X87_COND_ZERO		 0x4000
#define __X87_COND_INF		 (__X87_COND_NAN|__X87_COND_NORMAL)
#define __X87_COND_SUBNORMAL (__X87_COND_ZERO|__X87_COND_NORMAL)

#define __X87_COND_INVALID	 0x0400

#ifndef FE_ROUNDING_MASK
#define FE_ROUNDING_MASK (FE_TONEAREST|FE_DOWNWARD|FE_UPWARD|FE_TOWARDZERO)
#endif


#if defined __SSE2__
# define math_opt_barrier(x) \
  ({ __typeof(x) __x;					\
     if (sizeof (x) <= sizeof (double))			\
       __asm ("" : "=x" (__x) : "0" (x));		\
     else						\
       __asm ("" : "=t" (__x) : "0" (x));		\
     __x; })
# define math_force_eval(x) \
  do {							\
    if (sizeof (x) <= sizeof (double))			\
      __asm __volatile ("" : : "x" (x));		\
    else						\
      __asm __volatile ("" : : "f" (x));		\
  } while (0)
#elif defined(__i386__) || defined(__x86_64__)
# define math_opt_barrier(x) \
  ({ __typeof (x) __x;					\
     __asm ("" : "=t" (__x) : "0" (x));			\
     __x; })
# define math_force_eval(x) \
  do {							\
    __typeof (x) __x = (x);				\
    if (sizeof (x) <= sizeof (double))			\
      __asm __volatile ("" : : "m" (__x));		\
    else						\
      __asm __volatile ("" : : "f" (__x));		\
  } while (0)
#endif


#ifndef __NO_MATH_INLINES


#define __x87_test(__val, __fpsr) \
  __asm__ __volatile__("fxam; fstsw	%0" : "=am" (__fpsr) : "t" (__val))

#define __x87_getsw(__fpsr) \
  __asm__ __volatile__("fnstsw	%0" : "=am" (__fpsr))

#define __x87_getcw(cw) \
  __asm__ __volatile__("fnstcw	%0" : "=m" (cw))

#define __x87_setcw(cw) \
  __asm__ __volatile__("fldcw %0" : : "m" (cw))



__MATH_INLINE long double
__ieee754_fabsl (long double x)
{
	long double res;
	__asm__ ("fabs;" : "=t" (res) : "0" (x));
	return res;
}
#define __have_fpu_fabs

__MATH_INLINE long double
__ieee754_sinl(long double x)
{
	long double value;
	unsigned short x_class;
	
	/* sin(Inf or NaN) is NaN */
	__x87_test(x, x_class);
	if (x_class & __X87_COND_NAN)
		return x - x;
	__asm__ __volatile__(
		"fsin\n"
		"fnstsw	%%ax\n"
		"testl	$0x400,%%eax\n"
		"jz	2f\n"
		"fldpi\n"
		"fadd	%%st(0)\n"
		"fxch	%%st(1)\n"
	"1:	fprem1\n"
		"fnstsw	%%ax\n"
		"testl	$0x400,%%eax\n"
		"jnz	1b\n"
		"fstp	%%st(1)\n"
		"fsin\n"
	"2:\n"
		: "=t"(value)
		: "0"(x)
		: "st(1)", "eax");
	return value;
}
#define __have_fpu_sin

__MATH_INLINE long double
__ieee754_cosl(long double x)
{
	long double value;
	unsigned short x_class;
	
	/* cos(Inf or NaN) is NaN */
	__x87_test(x, x_class);
	if (x_class & __X87_COND_NAN)
		return x - x;
	__asm__ __volatile__(
		"fcos\n"
		"fnstsw	%%ax\n"
		"testl	$0x400,%%eax\n"
		"jz	2f\n"
		"fldpi\n"
		"fadd	%%st(0)\n"
		"fxch	%%st(1)\n"
	"1:	fprem1\n"
		"fnstsw	%%ax\n"
		"testl	$0x400,%%eax\n"
		"jnz	1b\n"
		"fstp	%%st(1)\n"
		"fcos\n"
	"2:\n"
		: "=t"(value)
		: "0"(x)
		: "st(1)", "eax");
	return value;
}
#define __have_fpu_cos

__MATH_INLINE void
__ieee754_sincosl(long double x, long double *sinx, long double *cosx)
{
	unsigned short x_class;
	
	__x87_test(x, x_class);
	if (x_class & __X87_COND_NAN)
	{
		*sinx = *cosx = x - x;
		return;
	}	
	__asm__ __volatile__(
		"fsincos\n"
		"fnstsw	%%ax\n"
		"testl	$0x400,%%eax\n"
		"jz	2f\n"
		"fldpi\n"
		"fadd	%%st(0)\n"
		"fxch	%%st(1)\n"
	"1:	fprem1\n"
		"fnstsw	%%ax\n"
		"testl	$0x400,%%eax\n"
		"jnz	1b\n"
		"fstp	%%st(1)\n"
		"fsincos\n"
	"2:\n"
		: "=t"(*cosx), "=u"(*sinx)
		: "0"(x)
		: "st(2)", "eax");
}
#define __have_fpu_sincos

__MATH_INLINE long double
__ieee754_tanl(long double x)
{
	long double value;
	unsigned short x_class;
	
	/* tan(Inf or NaN) is NaN */
	__x87_test(x, x_class);
	if (x_class & __X87_COND_NAN)
		return x - x;
	__asm__ __volatile__(
		"fptan\n"
		"fstp	%%st(0)\n"
		: "=t"(value)
		: "0"(x));
	__x87_getsw(x_class);
	if (x_class & __X87_COND_INVALID)
	{
		__asm__("fldpi\n"
			"fadd	%%st(0)\n"
			"fxch	%%st(1)\n"
		"1:	fprem1\n"
			"fnstsw	%%ax\n"
			"testl	$0x400,%%eax\n"
			"jnz	1b\n"
			"fstp	%%st(1)\n"
			"fptan\n"
			"fstp	%%st(0)\n"
			: "=t"(value)
			: "0"(x)
			: "st(1)", "eax");
	}
	return value;
}
#define __have_fpu_tan

__MATH_INLINE long double
__ieee754_acosl (long double x)
{
	long double res;

	/* acosl = atanl (sqrtl((1-x) (1+x)) / x) */
	__asm__("fld	%%st\n"
		"fmul %%st(0)\n"		/* x^2 */
		"fld1\n"
		"fsubp\n"		/* 1 - x^2 */
		"fsqrt\n"		/* sqrtl (1 - x^2) */
	   "fabs\n"
	   "fxch	%%st(1)\n"
	   "fpatan"
	: "=t"(res)
	: "0"(x)
	: "st(1)", "st(2)");
	return res;
}
#define __have_fpu_acos

__MATH_INLINE long double
__ieee754_asinl (long double x)
{
	long double res;

	/* asinl = atanl (x / sqrtl(1 - x^2)) */
	__asm__("fld	%%st\n"
		"fmul %%st(0)\n"		/* x^2 */
		"fld1\n"
		"fsubp\n"		/* 1 - x^2 */
		"fsqrt\n"		/* sqrtl (1 - x^2) */
	   "fpatan"
	: "=t"(res)
	: "0"(x)
	: "st(1)", "st(2)");
	return res;
}
#define __have_fpu_asin

__MATH_INLINE long double
__ieee754_sqrtl (long double x)
{
  long double res;

  __asm__("fsqrt" : "=t" (res) : "0" (x));

  return res;
}
#define __have_fpu_sqrt

__MATH_INLINE long double
__ieee754_atanl (long double x)
{
  long double res;

  __asm__("fld1\n"
       "fpatan"
       : "=t" (res)
       : "0" (x)
	   : "st(1)");
  return res;
}
#define __have_fpu_atan


__MATH_INLINE long double
__ieee754_atan2l (long double y, long double x)
{
  long double res;

  __asm__("fpatan" : "=t" (res) : "u" (y), "0" (x) : "st(1)");

  return res;
}
#define __have_fpu_atan2


__MATH_INLINE long double
__ieee754_fmodl (long double x, long double y)
{
  long double res;

  __asm__("1:\tfprem\n"
       "fstsw   %%ax\n"
       "sahf\n"
       "jp      1b\n"
       "fstp    %%st(1)"
       : "=t" (res) : "0" (x), "u" (y) : "ax", "st(1)");
  return res;
}
#define __have_fpu_fmod

__MATH_INLINE long double
__ieee754_remainderl (long double x, long double y)
{
  long double res;

  __asm__("1:\tfprem1\n"
       "fstsw   %%ax\n"
       "sahf\n"
       "jp      1b\n"
       "fstp    %%st(1)"
       : "=t" (res) : "0" (x), "u" (y) : "ax", "st(1)");
  return res;
}
#define __have_fpu_remainder

#if 0

__MATH_INLINE long double
__ieee754_remquol(long double x, long double y, int *quo)
{
	int cquo;
	long double value;
	
	__asm__ __volatile__(
	"1:	fprem1\n"
		"fstsw	%%ax\n"
		"sahf\n"
		"jp	1b\n"
		"fstp	%%st(1)\n"
		/* Compute the congruent of the quotient.  */
		"movl	%%eax, %%ecx\n"
		"shrl	$8, %%eax\n"
		"shrl	$12, %%ecx\n"
		"andl	$4, %%ecx\n"
		"andl	$3, %%eax\n"
		"orl	%%eax, %%ecx\n"
		"movl	$0xef2a60, %%eax\n"
		"leal	(%%ecx,%%ecx,2),%%ecx\n"
		"shrl	%%cl, %%eax\n"
		"andl	$7, %%eax\n"
        "movl   8(%4), %%ecx\n"
        "xorl   8(%5), %%ecx\n"
        "testl  $0x8000, %%ecx\n"
        "jz 1f\n"
        "negl %%eax\n"
	"1:\n"
	: "=t"(value), "=&a"(cquo)
	: "0"(x), "u"(y), "r"(&x), "r"(&y)
	: "st(1)", "ecx");
	*quo = cquo;
	return value;
}
#define __have_fpu_remquo

#endif

__MATH_INLINE long double
__ieee754_ceill (long double x)
{
  unsigned short rounding_mode, round_up;
  long double value;

  __x87_getcw(rounding_mode);
  round_up = (unsigned short)((rounding_mode & ~FE_ROUNDING_MASK) | FE_UPWARD);
  __x87_setcw(round_up);
  __asm __volatile ("frndint"
		  : "=t" (value)
		  : "0" (x));
  __x87_setcw(rounding_mode);
  return value;
}
#define __have_fpu_ceil

__MATH_INLINE long double
__ieee754_floorl (long double x)
{
  unsigned short rounding_mode, round_down;
  long double value;

  __x87_getcw(rounding_mode);
  round_down = (unsigned short)((rounding_mode & ~FE_ROUNDING_MASK) | FE_DOWNWARD);
  __x87_setcw(round_down);
  __asm __volatile ("frndint"
		  : "=t" (value)
		  : "0" (x));
  __x87_setcw(rounding_mode);
  return value;
}
#define __have_fpu_floor

__MATH_INLINE long double
__ieee754_truncl (long double x)
{
  unsigned short rounding_mode, round_down;
  long double value;

  __x87_getcw(rounding_mode);
  round_down = (rounding_mode & ~FE_ROUNDING_MASK) | FE_TOWARDZERO;
  __x87_setcw(round_down);
  __asm __volatile ("frndint"
		  : "=t" (value)
		  : "0" (x));
  __x87_setcw(rounding_mode);
  return value;
}
#define __have_fpu_trunc

__MATH_INLINE long double
__ieee754_rintl (long double x)
{
  long double value;

  __asm __volatile ("frndint"
		  : "=t" (value)
		  : "0" (x));
  return value;
}
#define __have_fpu_rint

__MATH_INLINE long
__ieee754_lrintl (long double x)
{
#if LONG_MAX > 2147483647L
  int64_t value;

  __asm __volatile ("fistpll %0"
		  : "=m" (value)
		  : "t" (x)
		  : "st");
  return value;
#else
  int32_t value;

  __asm __volatile ("fistpl %0"
		  : "=m" (value)
		  : "t" (x)
		  : "st");
  return value;
#endif
}
#define __have_fpu_lrint

__extension__ __MATH_INLINE long long
__ieee754_llrintl (long double x)
{
  long long value;

  __asm __volatile ("fistpll %0"
		  : "=m" (value)
		  : "t" (x)
		  : "st");
  return value;
}
#define __have_fpu_llrint

#if 0 /* frndint rounds in wrong direction */

__MATH_INLINE long double
__ieee754_roundl (long double x)
{
  unsigned short rounding_mode, round_nearest;
  long double value;

  __x87_getcw(rounding_mode);
  round_nearest = (unsigned short)((rounding_mode & ~FE_ROUNDING_MASK) | FE_TONEAREST);
  __x87_setcw(round_nearest);
  __asm __volatile ("frndint"
		  : "=t" (value)
		  : "0" (x));
  __x87_setcw(rounding_mode);
  return value;
}
#define __have_fpu_round

#endif

__MATH_INLINE long double
__ieee754_scalbnl (long double x, int n)
{
  long double value;
  long double exp = (long double)(n);

  __asm __volatile (
  		  "fscale\n"
  		  "fstp	%%st(1)\n"
		  : "=t" (value)
		  : "0" (x), "u"(exp)
		  : "st(1)");
  return value;
}
#define __have_fpu_scalbn

__MATH_INLINE long double
__ieee754_scalblnl (long double x, long n)
{
  long double value;
  long double exp = (long double)(n);

  __asm __volatile (
  		  "fscale\n"
  		  "fstp	%%st(1)\n"
		  : "=t" (value)
		  : "0" (x), "u"(exp)
		  : "st(1)");
  return value;
}
#define __have_fpu_scalbln


__MATH_INLINE long double
__ieee754_logbl (long double x)
{
  long double exponent;

  __asm __volatile (
       "fxtract\n"
       "fstp	%%st"
	 : "=t" (exponent)
	 : "0" (x));
  return exponent;
}
#define __have_fpu_logb


__MATH_INLINE long double
__ieee754_expm1l(long double x)
{
	int x_class = fpclassify(x);
	long double value;
	
	if (x_class == FP_NAN)
		return x;
	if (x_class == FP_INFINITE)
		return signbit(x) ? -1.0L : x;
	if (x_class == FP_ZERO)
		return x;
	if (x > 11356.523406294143949491931077970765L)
		return LDBL_MAX * LDBL_MAX;
	if (x < -7.9018778583833765273564461846232128760607E1L)
		return (4.0 / 1e4932L - 1.0L);
  __asm __volatile (
	"fldl2e\n"					/* log2(e) : x */
	"fmulp\n"					/* log2(e)*x */
	"fld	%%st\n"				/* log2(e)*x : log2(e)*x */
	"frndint\n"					/* int(log2(e)*x) : log2(e)*x */
	"fsubr	%%st, %%st(1)\n"	/* int(log2(e)*x) : fract(log2(e)*x) */
	"fxch\n"					/* fract(log2(e)*x) : int(log2(e)*x) */
	"f2xm1\n"					/* 2^fract(log2(e)*x)-1 : int(log2(e)*x) */
	"fscale\n"					/* 2^(log2(e)*x)-2^int(log2(e)*x) : int(log2(e)*x) */
	"fxch\n"					/* int(log2(e)*x) : 2^(log2(e)*x)-2^int(log2(e)*x) */
	"fld1\n"					/* 1 : int(log2(e)*x) : 2^(log2(e)*x)-2^int(log2(e)*x) */
	"fscale\n"					/* 2^int(log2(e)*x) : int(log2(e)*x) : 2^(log2(e)*x)-2^int(log2(e)*x) */
	"fstp	%%st(1)\n"			/* 2^int(log2(e)*x) : 2^(log2(e)*x)-2^int(log2(e)*x) */
	"fld1\n"					/* 1 : 2^int(log2(e)*x) : 2^(log2(e)*x)-2^int(log2(e)*x) */
	"fsubp	%%st, %%st(1)\n"	/* 1-2^int(log2(e)*x) : 2^(log2(e)*x)-2^int(log2(e)*x) */
	"fsubrp	%%st, %%st(1)\n"	/* 2^(log2(e)*x)-1 */
	 : "=t" (value)
	 : "0" (x)
	 : "st(1)", "st(2)");
	return value;
}
#define __have_fpu_expm1


__MATH_INLINE long double
__ieee754_exp2l (long double x)
{
	unsigned short fpsr;
	
	__x87_test(x, fpsr);
	if ((fpsr & (__X87_COND_ZERO|__X87_COND_INF)) == __X87_COND_INF)
	{
		if (fpsr & __X87_COND_NEG)
			x = 0;
	} else
	{
		double y;
		__asm (
			"\tfld	%%st\n"				/* x : x */
			"\tfrndint\n"				/* int(x) : x */
			"\tfsubr %%st,%%st(1)\n"	/* int(x) : fract(x) */
			"\tfxch\n"					/* fract(x) : int(x) */
			"\tf2xm1\n"					/* 2^(fract(x)) - 1 : int(x) */
			"\tfld1\n"					/* 1 : 2^(fract(x)) - 1 : int(x) */
			"\tfaddp\n" 				/* 2^(fract(x)) : int(x) */
			"\tfscale\n"				/* 2^x : int(x)  */
			"\tfstp	%%st(1)\n"
		: "=t"(y)
		: "0"(x)
		: "st(1)", "st(2)");
		x = y;
	}
	return x;
}
#define __have_fpu_exp2


__MATH_INLINE long double
__ieee754_logl (long double x)
{
	int x_class = fpclassify(x);
	long double value;
	
	if (x_class == FP_ZERO)
		return -HUGE_VALL;
	if (signbit(x))
		return __builtin_nanl("");
	if (x_class == FP_INFINITE || x_class == FP_NAN)
		return x + x;
	__asm (
		"fldln2\n"			/* log(2) */
		"fxch\n"			/* x : log(2) */
		"fyl2x\n"			/* log(x) */
	: "=t"(value)
	: "0"(x)
	: "st(1)", "st(2)");
	return value;
}
#define __have_fpu_log

__MATH_INLINE long double
__ieee754_log1pl (long double x)
{
	int x_class = fpclassify(x);
	long double value;

	/* It is not important that this constant is precise.  It is only
	   a value which is known to be on the safe side for using the
	   fyl2xp1 instruction.  */
	const double limit = 0.29;
	
	if (x_class == FP_INFINITE || x_class == FP_NAN)
		return x + x;
	if (x_class == FP_ZERO)
		return x;

	if (__ieee754_fabsl(x) < limit)
	{
		__asm (
			"fldln2\n"					/* log(2) */
			"fxch\n"					/* x : log(2) */
			"fyl2xp1\n"					/* log(x) */
		: "=t"(value)
		: "0"(x)
		: "st(1)");
	} else
	{
		__asm (
			"fldln2\n"					/* log(2) */
			"fxch\n"					/* x : log(2) */
			"fld1\n"					/* 1 : x : log(2) */
			"faddp\n"					/* x + 1 : log(2) */
			"fyl2x\n"					/* log(x) */
		: "=t"(value)
		: "0"(x)
		: "st(1)", "st(2)");
	}
	return value;
}
#define __have_fpu_log1p

__MATH_INLINE long double
__ieee754_log2l (long double x)
{
	int x_class = fpclassify(x);
	long double value;

	if (x_class == FP_INFINITE || x_class == FP_NAN)
		return x + x;

	__asm (
		"fld1\n"					/* 1 */
		"fxch\n"					/* x : 1 */
		"fyl2x\n"					/* log2(x) */
	: "=t"(value)
	: "0"(x)
	: "st(1)");
	return value;
}
#define __have_fpu_log2
	
__MATH_INLINE long double
__ieee754_log10l (long double x)
{
	int x_class = fpclassify(x);
	long double value;

	if (x_class == FP_INFINITE || x_class == FP_NAN)
		return x + x;

	__asm (
		"fldlg2\n"					/* log10(2) */
		"fxch\n"					/* x : log10(2) */
		"fyl2x\n"					/* log10(x) */
	: "=t"(value)
	: "0"(x)
	: "st(1)");
	return value;
}
#define __have_fpu_log10
	
__MATH_INLINE long double
__ieee754_expl(long double x)
{
	int x_class = fpclassify(x);

	if (x_class == FP_NAN)
		return x;
	if (x_class == FP_INFINITE)
		return signbit(x) ? 0.0 : x;
	if (x_class == FP_ZERO)
		return 1.0L;
	if (x > 11356.523406294143949491931077970765L)
	{
		feraiseexcept(FE_OVERFLOW);
		return HUGE_VALL;
	}
	if (x < -11355.137111933024058885L)
	{
		feraiseexcept(FE_UNDERFLOW);
		return 0;
	}
	return __ieee754_exp2l(1.44269504088896340735992468100189213743L * x);
}
#define __have_fpu_exp

__MATH_INLINE long double
__ieee754_modfl (long double x, long double *ip)
{
  long double temp, result;
  unsigned short x_cond;

  temp = __ieee754_truncl(x);
  if (ip)
    *ip = temp;
  __x87_test (x, x_cond);
  if ((x_cond & (__X87_COND_ZERO|__X87_COND_INF)) == __X87_COND_INF)
    {
      result = 0;
      if (x_cond & __X87_COND_NEG)
	result = -result;
    }
  else if ((x_cond & __X87_COND_ZERO) == __X87_COND_ZERO)
    result = x;
  else
    result = x - temp;
  return result;
}
#define __have_fpu_modf

#endif /* __NO_MATH_INLINES */

```

`include/bits/fenv.h`:

```h
/* Copyright (C) 1997-2013 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library.  If not, see
   <http://www.gnu.org/licenses/>.  */

#ifndef _FENV_H
# error "Never use <bits/fenv.h> directly; include <fenv.h> instead."
#endif

#ifndef	_BITS_TYPES_H
#include <bits/types.h>
#endif

#ifdef __mc68000__
#include <bits/m68k/fenv.h>
#endif

#if defined(__i386__) || defined(__x86_64__)
#include <bits/x86/fenv.h>
#endif

#ifndef FE_DFL_ENV
#error "<fenv.h> not supported"
#endif

```

`include/bits/fenvinline.h`:

```h
/* This file provides inline versions of floating-point environment
   handling functions.  If there were any.  */

#ifndef __NO_MATH_INLINES

/* Here is where the code would go.  */

#endif

```

`include/bits/fpu_control.h`:

```h
#ifndef _FPU_CONTROL_H
# error "Never use <bits/fpu_control.h> directly; include <fpu_control.h> instead."
#endif

#ifdef __mc68000__
#include <bits/m68k/fpu_control.h>
#endif

#if defined(__i386__) || defined(__x86_64__)
#include <bits/x86/fpu_control.h>
#endif

#ifndef _FPU_GETCW
#error "<fpu_control.h> not supported"
#endif

```

`include/bits/huge_val.h`:

```h
/* `HUGE_VAL' constants for m68k (where it is infinity).
   Used by <stdlib.h> and <math.h> functions for overflow.
   Copyright (C) 1992, 1995, 1996, 1997 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Library General Public License as
   published by the Free Software Foundation; either version 2 of the
   License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Library General Public License for more details.

   You should have received a copy of the GNU Library General Public
   License along with the GNU C Library; see the file COPYING.LIB.  If not,
   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#ifndef _MATH_H
# error "Never use <bits/huge_val.h> directly; include <math.h> instead."
#endif

/* IEEE positive infinity (-HUGE_VAL is negative infinity).  */

#if __GNUC_PREREQ(3,3)
# define HUGE_VAL	(__builtin_huge_val())

#ifdef	 __USE_ISOC99
# define HUGE_VALF	(__builtin_huge_valf())
# define HUGE_VALL	(__builtin_huge_vall())
#endif

#elif __GNUC_PREREQ(2,96)
# define HUGE_VAL	(__extension__ 0x1.0p2047)

#ifdef	 __USE_ISOC99
# define HUGE_VALF	(__extension__ 0x1.0p255f)
# define HUGE_VALL (__extension__ 0x1.0p32767L)
#endif

#elif defined __GNUC__

# define HUGE_VAL					\
  (__extension__					\
   ((union { unsigned long long __l; double __d; })	\
    { __l: 0x7ff0000000000000ULL }).__d)

#ifdef	 __USE_ISOC99
#  define HUGE_VALF					\
  (__extension__					\
   ((union { unsigned long __l; float __f; })		\
    { __l: 0x7f800000UL }).__f)

# define HUGE_VALL	((long double) HUGE_VAL)

#endif

#else /* not GCC */

#if defined(__DOUBLE_64__)
static union { unsigned char __c[8]; double __d; } __huge_val =
  { { 0x7f, 0xf0, 0, 0, 0, 0, 0, 0 } };
#elif defined(__HAVE_68881__)
static union { unsigned char __c[12]; double __d; } __huge_val =
  { { 0x7f, 0xff, 0, 0, 0x80, 0, 0, 0, 0, 0, 0, 0 } };
#else
static union { unsigned char __c[10]; double __d; } __huge_val =
  { { 0x7f, 0xff, 0x80, 0, 0, 0, 0, 0, 0, 0 } };
#endif
#define HUGE_VAL	(__huge_val.__d)
/*
 * definition above is more accurrate, but cannot be
 * used in static initializations.
 */
#undef HUGE_VAL
#define HUGE_VAL 1.189731495357231765E+4932

#ifdef	 __USE_ISOC99
static union { unsigned char __c[4]; float __f; } __huge_valf =
  { { 0x7f, 0x80, 0, 0 } };
#  define HUGE_VALF	(__huge_valf.__f)

/*
 * definition above is more accurrate, but cannot be
 * used in static initializations.
 */
#undef HUGE_VALF
#define HUGE_VALF ((float)HUGE_VAL)

#if defined(__HAVE_68881__)
static union { unsigned char __c[12]; long double __ld; } __huge_vall =
  { { 0x7f, 0xff, 0, 0, 0x80, 0, 0, 0, 0, 0, 0, 0 } };
#else
static union { unsigned char __c[10]; long double __ld; } __huge_vall =
  { { 0x7f, 0xff, 0x80, 0, 0, 0, 0, 0, 0, 0 } };
#endif
#  define HUGE_VALL	(__huge_vall.__ld)

/*
 * definition above is more accurrate, but cannot be
 * used in static initializations.
 */
#undef HUGE_VALL
#define HUGE_VALL	((long double) HUGE_VAL)

#endif

#endif	/* GCC.  */

```

`include/bits/inf.h`:

```h
/* `INFINITY' constant for IEEE 754 machines.
   Copyright (C) 2004-2013 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#ifndef _MATH_H
# error "Never use <bits/inf.h> directly; include <math.h> instead."
#endif

/* IEEE positive infinity.  */

#if __GNUC_PREREQ(3,3)
# define INFINITY	(__builtin_inff())
#else
# define INFINITY	HUGE_VALF
#endif

```

`include/bits/m68k/fenv.h`:

```h
#ifndef _FENV_H
# error "Never use <bits/fenv.h> directly; include <fenv.h> instead."
#endif

/* Define bits representing the exception.  We use the bit positions of
   the appropriate bits in the FPSR Accrued Exception Byte.  */
enum
  {
    FE_INEXACT =	(1 << 3),
    FE_DIVBYZERO =  (1 << 4),
    FE_UNDERFLOW =  (1 << 5),
    FE_OVERFLOW =   (1 << 6),
    FE_INVALID =    (1 << 7)
  };

#define FE_INEXACT FE_INEXACT
#define FE_DIVBYZERO FE_DIVBYZERO
#define FE_UNDERFLOW FE_UNDERFLOW
#define FE_OVERFLOW FE_OVERFLOW
#define FE_INVALID FE_INVALID

#define FE_ALL_EXCEPT (FE_INEXACT | FE_DIVBYZERO | FE_UNDERFLOW | FE_OVERFLOW | FE_INVALID)

/* rounding precision used by fegetprec() and fesetprec() */
#ifdef __mcoldfire__
#define FE_LDBLPREC 0x00 /* long double precision */
#define FE_DBLPREC  0x00 /* double precision */
#else
#define FE_LDBLPREC 0x00 /* long double precision */
#define FE_DBLPREC  0x80 /* double precision */
#endif
#define FE_FLTPREC  0x40 /* float precision */
#define FE_PRECISION_MASK (FE_LDBLPREC|FE_FLTPREC|FE_DBLPREC)

/* The m68k FPU supports all of the four defined rounding modes.  We use
   the bit positions in the FPCR Mode Control Byte as the values for the
   appropriate macros.  */
enum
  {
    FE_TONEAREST = 0,
    FE_TOWARDZERO = (1 << 4),
    FE_DOWNWARD =   (2 << 4),
    FE_UPWARD =     (3 << 4)
  };

#define FE_TONEAREST FE_TONEAREST
#define FE_TOWARDZERO FE_TOWARDZERO
#define FE_DOWNWARD FE_DOWNWARD
#define FE_UPWARD FE_UPWARD

/* Type representing exception flags.  */
typedef __uint32_t fexcept_t;


/* Type representing floating-point environment.  This structure
   corresponds to the layout of the block written by `fmovem'.  */
typedef struct
  {
    __uint32_t __control_register;
    __uint32_t __status_register;
    __uint32_t __instruction_address;
  }
fenv_t;

/* If the default argument is used we use this value.  */
#define FE_DFL_ENV	((const fenv_t *) -1)

#ifdef __USE_GNU
/* Floating-point environment where none of the exceptions are masked.  */
# define FE_NOMASK_ENV	((const fenv_t *) -2)
#endif

extern fexcept_t __fpu_status;

```

`include/bits/m68k/fpu_control.h`:

```h
#ifndef _FPU_CONTROL_H
# error "Never use <bits/fpu_control.h> directly; include <fpu_control.h> instead."
#endif

/*
 * Motorola floating point control register bits.
 *
 * 31-16  -> reserved (read as 0, ignored on write)
 * 15     -> enable trap for BSUN exception
 * 14     -> enable trap for SNAN exception
 * 13     -> enable trap for OPERR exception
 * 12     -> enable trap for OVFL exception
 * 11     -> enable trap for UNFL exception
 * 10     -> enable trap for DZ exception
 *  9     -> enable trap for INEX2 exception (INEX on Coldfire)
 *  8     -> enable trap for INEX1 exception (IDE on Coldfire)
 *  7-6   -> Precision Control (only bit 6 is used on Coldfire)
 *  5-4   -> Rounding Control
 *  3-0   -> zero (read as 0, write as 0)
 *
 *
 * Precision Control:
 * 00 - round to extended precision
 * 01 - round to single precision
 * 10 - round to double precision
 * 11 - undefined
 *
 * Rounding Control:
 * 00 - rounding to nearest (RN)
 * 01 - rounding toward zero (RZ)
 * 10 - rounding (down)toward minus infinity (RM)
 * 11 - rounding (up) toward plus infinity (RP)
 *
 * The hardware default is 0x0000. I choose 0x5400.
 */

/* masking of interrupts */
#define _FPU_MASK_BSUN  0x8000
#define _FPU_MASK_SNAN  0x4000
#define _FPU_MASK_OPERR 0x2000
#define _FPU_MASK_OVFL  0x1000
#define _FPU_MASK_UNFL  0x0800
#define _FPU_MASK_DZ    0x0400
#define _FPU_MASK_INEX1 0x0200
#define _FPU_MASK_INEX2 0x0100

/* precision control */
#ifdef __mcoldfire__
# define _FPU_EXTENDED 0x00
# define _FPU_DOUBLE   0x00
#else
# define _FPU_EXTENDED 0x00   /* RECOMMENDED */
# define _FPU_DOUBLE   0x80
#endif
#define _FPU_SINGLE   0x40     /* DO NOT USE */

/* rounding control */
#define _FPU_RC_NEAREST 0x00    /* RECOMMENDED */
#define _FPU_RC_ZERO    0x10
#define _FPU_RC_DOWN    0x20
#define _FPU_RC_UP      0x30

#ifdef __mcoldfire__
# define _FPU_RESERVED 0xFFFF800FL
#else
# define _FPU_RESERVED 0xFFFF000FL  /* Reserved bits in fpucr */
#endif


/* Now two recommended fpucr */

/* The fdlibm code requires no interrupts for exceptions.  Don't
   change the rounding mode, it would break long double I/O!  */
#define _FPU_DEFAULT  0x00000000

/* IEEE:  same as above, but exceptions.  We must make it non-zero so
   that __setfpucw works.  This bit will be ignored.  */
#define _FPU_IEEE     0x00000001

/* Type of the control word.  */
typedef __uint32_t fpu_control_t;

/* Macros for accessing the hardware control word.  */
#if defined(__GNUC__) && ((defined(__mcoldfire__) && defined (__mcffpu__)) || defined(__HAVE_68881__))
# define _FPU_GETCW(cw) __asm__ ("fmove%.l %!, %0" : "=dm" (cw))
# define _FPU_SETCW(cw) __asm__ volatile ("fmove%.l %0, %!" : : "dm" (cw))
# define _FPU_GETSR(sr) __asm__ ("fmove%.l %/fpsr,%0" : "=dm" (sr))
# define _FPU_SETSR(sr) __asm__ __volatile__ ("fmove%.l %0,%/fpsr" : : "dm" (sr))
# define _FPU_GETIAR(addr) __asm__ ("fmove%.l %/fpiar,%0" : "=dm" (addr));
#elif (defined(__AHCC__) || defined(__PUREC__) || defined(__TURBOC__)) && ((defined(__mcoldfire__) && defined (__mcffpu__)) || defined(__HAVE_68881__))
# define _FPU_GETCW(cw) cw = __FGETCONTROL__(4)
# define _FPU_SETCW(cw) __FSETCONTROL__(4, cw)
# define _FPU_GETSR(sr) sr = __FGETCONTROL__(2)
# define _FPU_SETSR(sr) __FSETCONTROL__(2, sr)
# define _FPU_GETIAR(addr) addr = __FGETCONTROL__(1)
#elif defined(__VBCC__) && (defined (__mcffpu__) || defined(__M68881) || defined(__M68882))
static fpu_control_t __asm_fpu_getcw(void)="\tfmove.l\tfpcr,d0\n";
# define _FPU_GETCW(cw) cw = __asm_fpu_getcw()
static void __asm_fpu_setcw(__reg("d0")fpu_control_t)="\tfmove.l\td0,fpcr\n";
# define _FPU_SETCW(cw) __asm_fpu_setcw(cw)
static fpu_control_t __asm_fpu_getsr(void)="\tfmove.l\tfpsr,d0\n";
# define _FPU_GETSR(sr) sr = __asm_fpu_getsr()
static void __asm_fpu_setsr(__reg("d0")fpu_control_t)="\tfmove.l\td0,fpsr\n";
# define _FPU_SETSR(sr) __asm_fpu_setsr(sr)
static fpu_control_t __asm_fpu_getiar(void)="\tfmove.l\tfpiar,d0\n";
# define _FPU_GETIAR(addr) addr = __asm_fpu_getiar()
#endif

/* Default control word set at startup.  */
extern fpu_control_t __fpu_control;

#ifndef _FPU_GETCW
# define _FPU_GETCW(cw) cw = __fpu_control
# define _FPU_SETCW(cw) __fpu_control = cw
# define _FPU_GETSR(sr) sr = __fpu_status
# define _FPU_SETSR(sr) __fpu_status = sr
# define _FPU_GETIAR(addr) addr = 0
#endif

```

`include/bits/math-68881.h`:

```h
/******************************************************************\
*								   *
*  <math-68881.h>		last modified: 23 May 1992.	   *
*								   *
*  Copyright (C) 1989 by Matthew Self.				   *
*  You may freely distribute verbatim copies of this software	   *
*  provided that this copyright notice is retained in all copies.  *
*  You may distribute modifications to this software under the     *
*  conditions above if you also clearly note such modifications    *
*  with their author and date.			   	     	   *
*								   *
*  Note:  errno is not set to EDOM when domain errors occur for    *
*  most of these functions.  Rather, it is assumed that the	   *
*  68881's OPERR exception will be enabled and handled		   *
*  appropriately by the	operating system.  Similarly, overflow	   *
*  and underflow do not set errno to ERANGE.			   *
*								   *
*  Send bugs to Matthew Self (self@bayes.arc.nasa.gov).		   *
*								   *
\******************************************************************/

/* This file is NOT a part of GCC, just distributed with it.  */

/* If you find this in GCC,
   please send bug reports to bug-gcc@prep.ai.mit.edu.  */

/* Changed by Richard Stallman:
   May 1993, add conditional to prevent multiple inclusion.
   % inserted before a #.
   New function `hypot' added.
   Nans written in hex to avoid 0rnan.
   May 1992, use %! for fpcr register.  Break lines before function names.
   December 1989, add parens around `&' in pow.
   November 1990, added alternate definition of HUGE_VAL for Sun.  */

/* Changed by Jim Wilson:
   September 1993, Use #undef before HUGE_VAL instead of #ifdef/#endif.  */

/* Changed by Ian Lance Taylor:
   September 1994, use extern inline instead of static inline.  */

#ifndef __math_68881
#define __math_68881

#include <errno.h>

/* GCC 4.3 and above with -std=c99 or -std=gnu99 implements ISO C99
   inline semantics, unless -fgnu89-inline is used.  */
#if defined __cplusplus
# define __MATH_68881_INLINE inline
#elif defined __GNUC_STDC_INLINE__
# define __MATH_68881_INLINE extern __inline __attribute__ ((__gnu_inline__))
#else
# define __MATH_68881_INLINE extern __inline
#endif

#undef HUGE_VAL
#ifdef __sun__
/* The Sun assembler fails to handle the hex constant in the usual defn.  */
#define HUGE_VAL							\
({									\
  static union { long i[2]; double d; } u = { {0x7ff00000, 0} };		\
  u.d;									\
})
#else
#define HUGE_VAL							\
({									\
  double huge_val;							\
									\
  __asm ("fmove%.d #0x7ff0000000000000,%0"	/* Infinity */		\
	 : "=f" (huge_val)						\
	 : /* no inputs */);						\
  huge_val;								\
})
#endif

__MATH_68881_INLINE double
sin (double x)
{
  double value;

  __asm ("fsin%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_68881_INLINE float
sinf (float x)
{
  float value;

  __asm ("fsin%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define _GLIBCXX_HAVE_SINF 1

__MATH_68881_INLINE long double
sinl (long double x)
{
  long double value;

  __asm ("fsin%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define _GLIBCXX_HAVE_SINL 1

__MATH_68881_INLINE double
cos (double x)
{
  double value;

  __asm ("fcos%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_68881_INLINE float
cosf (float x)
{
  float value;

  __asm ("fcos%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define _GLIBCXX_HAVE_COSF 1

__MATH_68881_INLINE long double
cosl (long double x)
{
  long double value;

  __asm ("fcos%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define _GLIBCXX_HAVE_COSL 1

__MATH_68881_INLINE void
sincos (double __x, double *__sin, double *__cos)
{
  __asm ("fsincos%.x %2,%0,%1"
	 : "=f" (*__cos), "=f" (*__sin)
	 : "f" (__x));
}

__MATH_68881_INLINE void
sincosf (float __x, float *__sin, float *__cos)
{
  __asm ("fsincos%.x %2,%0,%1"
	 : "=f" (*__cos), "=f" (*__sin)
	 : "f" (__x));
}
#define _GLIBCXX_HAVE_SINCOSF 1

__MATH_68881_INLINE void
sincosl (long double __x, long double *__sin, long double *__cos)
{
  __asm ("fsincos%.x %2,%0,%1"
	 : "=f" (*__cos), "=f" (*__sin)
	 : "f" (__x));
}
#define _GLIBCXX_HAVE_SINCOSL 1

__MATH_68881_INLINE double
tan (double x)
{
  double value;

  __asm ("ftan%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_68881_INLINE float
tanf (float x)
{
  float value;

  __asm ("ftan%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define _GLIBCXX_HAVE_TANF 1

__MATH_68881_INLINE long double
tanl (long double x)
{
  long double value;

  __asm ("ftan%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define _GLIBCXX_HAVE_TANL 1

__MATH_68881_INLINE double
asin (double x)
{
  double value;

  __asm ("fasin%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_68881_INLINE float
asinf (float x)
{
  float value;

  __asm ("fasin%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define _GLIBCXX_HAVE_ASINF 1

__MATH_68881_INLINE long double
asinl (long double x)
{
  long double value;

  __asm ("fasin%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define _GLIBCXX_HAVE_ASINL 1

__MATH_68881_INLINE double
acos (double x)
{
  double value;

  __asm ("facos%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_68881_INLINE float
acosf (float x)
{
  float value;

  __asm ("facos%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define _GLIBCXX_HAVE_ACOSF 1

__MATH_68881_INLINE long double
acosl (long double x)
{
  long double value;

  __asm ("facos%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define _GLIBCXX_HAVE_ACOSL 1

__MATH_68881_INLINE double
atan (double x)
{
  double value;

  __asm ("fatan%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_68881_INLINE float
atanf (float x)
{
  float value;

  __asm ("fatan%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define _GLIBCXX_HAVE_ATANF 1

__MATH_68881_INLINE long double
atanl (long double x)
{
  long double value;

  __asm ("fatan%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define _GLIBCXX_HAVE_ATANL 1

__MATH_68881_INLINE double
atan2 (double y, double x)
{
  double pi, pi_over_2;

  __asm ("fmovecr%.x #0,%0"		/* extended precision pi */
	 : "=f" (pi)
	 : /* no inputs */ );
  __asm ("fscale%.b #-1,%0"		/* no loss of accuracy */
	 : "=f" (pi_over_2)
	 : "0" (pi));
  if (x > 0)
    {
      if (y > 0)
	{
	  if (x > y)
	    return atan (y / x);
	  else
	    return pi_over_2 - atan (x / y);
	}
      else
	{
	  if (x > -y)
	    return atan (y / x);
	  else
	    return - pi_over_2 - atan (x / y);
	}
    }
  else
    {
      if (y < 0)
	{
	  if (-x > -y)
	    return - pi + atan (y / x);
	  else
	    return - pi_over_2 - atan (x / y);
	}
      else
	{
	  if (-x > y)
	    return pi + atan (y / x);
	  else if (y > 0)
	    return pi_over_2 - atan (x / y);
	  else
	    {
	      double value;

	      errno = EDOM;
	      __asm ("fmove%.d #0x7fffffffffffffff,%0"	/* quiet NaN */
		     : "=f" (value)
		     : /* no inputs */);
	      return value;
	    }
	}
    }
}

__MATH_68881_INLINE float
atan2f (float y, float x)
{
  float pi, pi_over_2;

  __asm ("fmovecr%.x #0,%0"		/* extended precision pi */
	 : "=f" (pi)
	 : /* no inputs */ );
  __asm ("fscale%.b #-1,%0"		/* no loss of accuracy */
	 : "=f" (pi_over_2)
	 : "0" (pi));
  if (x > 0)
    {
      if (y > 0)
	{
	  if (x > y)
	    return atanf (y / x);
	  else
	    return pi_over_2 - atanf (x / y);
	}
      else
	{
	  if (x > -y)
	    return atanf (y / x);
	  else
	    return - pi_over_2 - atanf (x / y);
	}
    }
  else
    {
      if (y < 0)
	{
	  if (-x > -y)
	    return - pi + atanf (y / x);
	  else
	    return - pi_over_2 - atanf (x / y);
	}
      else
	{
	  if (-x > y)
	    return pi + atanf (y / x);
	  else if (y > 0)
	    return pi_over_2 - atanf (x / y);
	  else
	    {
	      float value;

	      errno = EDOM;
	      value = __builtin_nanf("");
	      return value;
	    }
	}
    }
}
#define _GLIBCXX_HAVE_ATAN2F 1

__MATH_68881_INLINE long double
atan2l (long double y, long double x)
{
  long double pi, pi_over_2;

  __asm ("fmovecr%.x #0,%0"		/* extended precision pi */
	 : "=f" (pi)
	 : /* no inputs */ );
  __asm ("fscale%.b #-1,%0"		/* no loss of accuracy */
	 : "=f" (pi_over_2)
	 : "0" (pi));
  if (x > 0)
    {
      if (y > 0)
	{
	  if (x > y)
	    return atanl (y / x);
	  else
	    return pi_over_2 - atanl (x / y);
	}
      else
	{
	  if (x > -y)
	    return atanl (y / x);
	  else
	    return - pi_over_2 - atanl (x / y);
	}
    }
  else
    {
      if (y < 0)
	{
	  if (-x > -y)
	    return - pi + atanl (y / x);
	  else
	    return - pi_over_2 - atanl (x / y);
	}
      else
	{
	  if (-x > y)
	    return pi + atanl (y / x);
	  else if (y > 0)
	    return pi_over_2 - atanl (x / y);
	  else
	    {
	      long double value;

	      errno = EDOM;
	      value = __builtin_nanl("");
	      return value;
	    }
	}
    }
}
#define _GLIBCXX_HAVE_ATAN2L 1

__MATH_68881_INLINE double
sinh (double x)
{
  double value;

  __asm ("fsinh%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_68881_INLINE float
sinhf (float x)
{
  float value;

  __asm ("fsinh%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define _GLIBCXX_HAVE_SINHF 1

__MATH_68881_INLINE long double
sinhl (long double x)
{
  long double value;

  __asm ("fsinh%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define _GLIBCXX_HAVE_SINHL 1

__MATH_68881_INLINE double
cosh (double x)
{
  double value;

  __asm ("fcosh%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_68881_INLINE float
coshf (float x)
{
  float value;

  __asm ("fcosh%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define _GLIBCXX_HAVE_COSHF 1

__MATH_68881_INLINE long double
coshl (long double x)
{
  long double value;

  __asm ("fcosh%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define _GLIBCXX_HAVE_COSHL 1

__MATH_68881_INLINE double
tanh (double x)
{
  double value;

  __asm ("ftanh%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_68881_INLINE float
tanhf (float x)
{
  float value;

  __asm ("ftanh%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define _GLIBCXX_HAVE_TANHF 1

__MATH_68881_INLINE long double
tanhl (long double x)
{
  long double value;

  __asm ("ftanh%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define _GLIBCXX_HAVE_TANHL 1

__MATH_68881_INLINE double
atanh (double x)
{
  double value;

  __asm ("fatanh%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_68881_INLINE float
atanhf (float x)
{
  float value;

  __asm ("fatanh%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define _GLIBCXX_HAVE_ATANHF 1

__MATH_68881_INLINE long double
atanhl (long double x)
{
  long double value;

  __asm ("fatanh%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define _GLIBCXX_HAVE_ATANHL 1

__MATH_68881_INLINE double
exp (double x)
{
  double value;

  __asm ("fetox%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_68881_INLINE float
expf (float x)
{
  float value;

  __asm ("fetox%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define _GLIBCXX_HAVE_EXPF 1

__MATH_68881_INLINE long double
expl (long double x)
{
  long double value;

  __asm ("fetox%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define _GLIBCXX_HAVE_EXPL 1

__MATH_68881_INLINE double
expm1 (double x)
{
  double value;

  __asm ("fetoxm1%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_68881_INLINE float
expm1f (float x)
{
  float value;

  __asm ("fetoxm1%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define _GLIBCXX_HAVE_EXPM1F 1

__MATH_68881_INLINE long double
expm1l (long double x)
{
  long double value;

  __asm ("fetoxm1%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define _GLIBCXX_HAVE_EXPM1L 1

__MATH_68881_INLINE double
exp2 (double x)
{
  double value;

  __asm ("ftwotox%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_68881_INLINE float
exp2f (float x)
{
  float value;

  __asm ("ftwotox%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define _GLIBCXX_HAVE_EXP2F 1

__MATH_68881_INLINE long double
exp2l (long double x)
{
  long double value;

  __asm ("ftwotox%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define _GLIBCXX_HAVE_EXP2L 1

__MATH_68881_INLINE double
pow2 (double x)
{
  double value;

  __asm ("ftwotox%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_68881_INLINE float
pow2f (float x)
{
  float value;

  __asm ("ftwotox%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define _GLIBCXX_HAVE_POW2F 1

__MATH_68881_INLINE long double
pow2l (long double x)
{
  long double value;

  __asm ("ftwotox%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define _GLIBCXX_HAVE_POW2L 1

__MATH_68881_INLINE double
exp10 (double x)
{
  double value;

  __asm ("ftentox%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_68881_INLINE float
exp10f (float x)
{
  float value;

  __asm ("ftentox%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define _GLIBCXX_HAVE_EXP10F 1

__MATH_68881_INLINE long double
exp10l (long double x)
{
  long double value;

  __asm ("ftentox%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define _GLIBCXX_HAVE_EXP10L 1

__MATH_68881_INLINE double
pow10 (double x)
{
  double value;

  __asm ("ftentox%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_68881_INLINE float
pow10f (float x)
{
  float value;

  __asm ("ftentox%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define _GLIBCXX_HAVE_POW10F 1

__MATH_68881_INLINE long double
pow10l (long double x)
{
  long double value;

  __asm ("ftentox%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define _GLIBCXX_HAVE_POW10L 1

__MATH_68881_INLINE double
log (double x)
{
  double value;

  __asm ("flogn%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_68881_INLINE float
logf (float x)
{
  float value;

  __asm ("flogn%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define _GLIBCXX_HAVE_LOGF 1

__MATH_68881_INLINE long double
logl (long double x)
{
  long double value;

  __asm ("flogn%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define _GLIBCXX_HAVE_LOGL 1

__MATH_68881_INLINE double
log1p (double x)
{
  double value;

  __asm ("flognp1%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_68881_INLINE float
log1pf (float x)
{
  float value;

  __asm ("flognp1%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define _GLIBCXX_HAVE_LOG1PF 1

__MATH_68881_INLINE long double
log1pl (long double x)
{
  long double value;

  __asm ("flognp1%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define _GLIBCXX_HAVE_LOG1PL 1

__MATH_68881_INLINE double
log10 (double x)
{
  double value;

  __asm ("flog10%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_68881_INLINE float
log10f (float x)
{
  float value;

  __asm ("flog10%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define _GLIBCXX_HAVE_LOG10F 1

__MATH_68881_INLINE long double
log10l (long double x)
{
  long double value;

  __asm ("flog10%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define _GLIBCXX_HAVE_LOG10L 1

__MATH_68881_INLINE double
log2 (double x)
{
  double value;

  __asm ("flog2%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_68881_INLINE float
log2f (float x)
{
  float value;

  __asm ("flog2%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define _GLIBCXX_HAVE_LOG2F 1

__MATH_68881_INLINE long double
log2l (long double x)
{
  long double value;

  __asm ("flog2%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define _GLIBCXX_HAVE_LOG2L 1

__MATH_68881_INLINE double
sqrt (double x)
{
  double value;

  __asm ("fsqrt%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_68881_INLINE float
sqrtf (float x)
{
  float value;

  __asm ("fsqrt%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define _GLIBCXX_HAVE_SQRTF 1

__MATH_68881_INLINE long double
sqrtl (long double x)
{
  long double value;

  __asm ("fsqrt%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define _GLIBCXX_HAVE_SQRTL 1

__MATH_68881_INLINE double
hypot (double x, double y)
{
  return __builtin_isinf(x) || __builtin_isinf(y) ? __builtin_inf() : sqrt (x*x + y*y);
}

__MATH_68881_INLINE float
hypotf (float x, float y)
{
  return __builtin_isinff(x) || __builtin_isinff(y) ? __builtin_inff() : sqrtf (x*x + y*y);
}
#define _GLIBCXX_HAVE_HYPOTF 1

__MATH_68881_INLINE long double
hypotl (long double x, long double y)
{
  return __builtin_isinfl(x) || __builtin_isinfl(y) ? __builtin_infl() : sqrtl (x*x + y*y);
}
#define _GLIBCXX_HAVE_HYPOTL 1

__MATH_68881_INLINE double
pow (double x, double y)
{
  if (x > 0)
    return exp (y * log (x));
  else if (x == 0)
    {
      if (y > 0)
	return 0.0;
      else
	{
	  double value;

	  errno = EDOM;
	  __asm ("fmove%.d #0x7fffffffffffffff,%0"		/* quiet NaN */
		 : "=f" (value)
		 : /* no inputs */);
	  return value;
	}
    }
  else
    {
      double temp;

      __asm ("fintrz%.x %1,%0"
	     : "=f" (temp)			/* integer-valued float */
	     : "f" (y));
      if (y == temp)
        {
	  int i = (int) y;

	  if ((i & 1) == 0)			/* even */
	    return exp (y * log (-x));
	  else
	    return - exp (y * log (-x));
        }
      else
        {
	  double value;

	  errno = EDOM;
	  __asm ("fmove%.d #0x7fffffffffffffff,%0"		/* quiet NaN */
		 : "=f" (value)
		 : /* no inputs */);
	  return value;
        }
    }
}

__MATH_68881_INLINE float
powf (float x, float y)
{
  if (x > 0)
    return expf (y * logf (x));
  else if (x == 0)
    {
      if (y > 0)
	return 0.0;
      else
	{
	  float value;

	  errno = EDOM;
	  value = __builtin_nanf("");
	  return value;
	}
    }
  else
    {
      float temp;

      __asm ("fintrz%.x %1,%0"
	     : "=f" (temp)			/* integer-valued float */
	     : "f" (y));
      if (y == temp)
        {
	  int i = (int) y;

	  if ((i & 1) == 0)			/* even */
	    return expf (y * logf (-x));
	  else
	    return - expf (y * logf (-x));
        }
      else
        {
	  float value;

	  errno = EDOM;
	  value = __builtin_nanf("");
	  return value;
        }
    }
}
#define _GLIBCXX_HAVE_POWF 1

__MATH_68881_INLINE long double
powl (long double x, long double y)
{
  if (x > 0)
    return expl (y * logl (x));
  else if (x == 0)
    {
      if (y > 0)
	return 0.0;
      else
	{
	  long double value;

	  errno = EDOM;
	  value = __builtin_nanl("");
	  return value;
	}
    }
  else
    {
      long double temp;

      __asm ("fintrz%.x %1,%0"
	     : "=f" (temp)			/* integer-valued long double */
	     : "f" (y));
      if (y == temp)
        {
	  int i = (int) y;

	  if ((i & 1) == 0)			/* even */
	    return expl (y * logf (-x));
	  else
	    return - expl (y * logl (-x));
        }
      else
        {
	  long double value;

	  errno = EDOM;
	  value = __builtin_nanl("");
	  return value;
        }
    }
}
#define _GLIBCXX_HAVE_POWL 1

__MATH_68881_INLINE double
fabs (double x)
{
  double value;

  __asm ("fabs%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_68881_INLINE float
fabsf (float x)
{
  float value;

  __asm ("fabs%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define _GLIBCXX_HAVE_FABSF 1

__MATH_68881_INLINE long double
fabsl (long double x)
{
  long double value;

  __asm ("fabs%.x %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define _GLIBCXX_HAVE_FABSL 1

__MATH_68881_INLINE double
ceil (double x)
{
  long rounding_mode, round_up;
  double value;

  __asm volatile ("fmove%.l %!,%0"
		  : "=dm" (rounding_mode)
		  : /* no inputs */ );
  round_up = rounding_mode | 0x30;
  __asm volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (round_up));
  __asm volatile ("fint%.x %1,%0"
		  : "=f" (value)
		  : "f" (x));
  __asm volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (rounding_mode));
  return value;
}

__MATH_68881_INLINE float
ceilf (float x)
{
  long rounding_mode, round_up;
  float value;

  __asm volatile ("fmove%.l %!,%0"
		  : "=dm" (rounding_mode)
		  : /* no inputs */ );
  round_up = rounding_mode | 0x30;
  __asm volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (round_up));
  __asm volatile ("fint%.x %1,%0"
		  : "=f" (value)
		  : "f" (x));
  __asm volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (rounding_mode));
  return value;
}
#define _GLIBCXX_HAVE_CEILF 1

__MATH_68881_INLINE long double
ceill (long double x)
{
  long rounding_mode, round_up;
  long double value;

  __asm volatile ("fmove%.l %!,%0"
		  : "=dm" (rounding_mode)
		  : /* no inputs */ );
  round_up = rounding_mode | 0x30;
  __asm volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (round_up));
  __asm volatile ("fint%.x %1,%0"
		  : "=f" (value)
		  : "f" (x));
  __asm volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (rounding_mode));
  return value;
}
#define _GLIBCXX_HAVE_CEILL 1

__MATH_68881_INLINE double
floor (double x)
{
  long rounding_mode, round_down;
  double value;

  __asm volatile ("fmove%.l %!,%0"
		  : "=dm" (rounding_mode)
		  : /* no inputs */ );
  round_down = (rounding_mode & ~0x10)
		| 0x20;
  __asm volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (round_down));
  __asm volatile ("fint%.x %1,%0"
		  : "=f" (value)
		  : "f" (x));
  __asm volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (rounding_mode));
  return value;
}

__MATH_68881_INLINE float
floorf (float x)
{
  long rounding_mode, round_down;
  float value;

  __asm volatile ("fmove%.l %!,%0"
		  : "=dm" (rounding_mode)
		  : /* no inputs */ );
  round_down = (rounding_mode & ~0x10)
		| 0x20;
  __asm volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (round_down));
  __asm volatile ("fint%.x %1,%0"
		  : "=f" (value)
		  : "f" (x));
  __asm volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (rounding_mode));
  return value;
}
#define _GLIBCXX_HAVE_FLOORF 1

__MATH_68881_INLINE long double
floorl (long double x)
{
  long rounding_mode, round_down;
  long double value;

  __asm volatile ("fmove%.l %!,%0"
		  : "=dm" (rounding_mode)
		  : /* no inputs */ );
  round_down = (rounding_mode & ~0x10)
		| 0x20;
  __asm volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (round_down));
  __asm volatile ("fint%.x %1,%0"
		  : "=f" (value)
		  : "f" (x));
  __asm volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (rounding_mode));
  return value;
}
#define _GLIBCXX_HAVE_FLOORL 1

__MATH_68881_INLINE double
trunc (double x)
{
  double value;

  __asm volatile ("fintrz%.x %1,%0"
		  : "=f" (value)
		  : "f" (x));
  return value;
}

__MATH_68881_INLINE float
truncf (float x)
{
  float value;

  __asm volatile ("fintrz%.x %1,%0"
		  : "=f" (value)
		  : "f" (x));
  return value;
}
#define _GLIBCXX_HAVE_TRUNCF 1

__MATH_68881_INLINE long double
truncl (long double x)
{
  long double value;

  __asm volatile ("fintrz%.x %1,%0"
		  : "=f" (value)
		  : "f" (x));
  return value;
}
#define _GLIBCXX_HAVE_TRUNCL 1

__MATH_68881_INLINE double
rint (double x)
{
  double value;
#if 0
  long rounding_mode, round_nearest;

  __asm volatile ("fmove%.l %!,%0"
		  : "=dm" (rounding_mode)
		  : /* no inputs */ );
  round_nearest = rounding_mode & ~0x30;
  __asm volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (round_nearest));
#endif
  __asm volatile ("fint%.x %1,%0"
		  : "=f" (value)
		  : "f" (x));
#if 0
  __asm volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (rounding_mode));
#endif
  return value;
}

__MATH_68881_INLINE float
rintf (float x)
{
  float value;
#if 0
  long rounding_mode, round_nearest;

  __asm volatile ("fmove%.l %!,%0"
		  : "=dm" (rounding_mode)
		  : /* no inputs */ );
  round_nearest = rounding_mode & ~0x30;
  __asm volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (round_nearest));
#endif
  __asm volatile ("fint%.x %1,%0"
		  : "=f" (value)
		  : "f" (x));
#if 0
  __asm volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (rounding_mode));
#endif
  return value;
}
#define _GLIBCXX_HAVE_RINTF 1

__MATH_68881_INLINE long double
rintl (long double x)
{
  long double value;
#if 0
  long rounding_mode, round_nearest;

  __asm volatile ("fmove%.l %!,%0"
		  : "=dm" (rounding_mode)
		  : /* no inputs */ );
  round_nearest = rounding_mode & ~0x30;
  __asm volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (round_nearest));
#endif
  __asm volatile ("fint%.x %1,%0"
		  : "=f" (value)
		  : "f" (x));
#if 0
  __asm volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (rounding_mode));
#endif
  return value;
}
#define _GLIBCXX_HAVE_RINTL 1

__MATH_68881_INLINE double
round (double x)
{
  long rounding_mode, round_nearest;
  double value;

  __asm volatile ("fmove%.l %!,%0"
		  : "=dm" (rounding_mode)
		  : /* no inputs */ );
  round_nearest = rounding_mode & ~0x30;
  __asm volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (round_nearest));
  __asm volatile ("fint%.x %1,%0"
		  : "=f" (value)
		  : "f" (x));
  __asm volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (rounding_mode));
  return value;
}

__MATH_68881_INLINE float
roundf (float x)
{
  long rounding_mode, round_nearest;
  float value;

  __asm volatile ("fmove%.l %!,%0"
		  : "=dm" (rounding_mode)
		  : /* no inputs */ );
  round_nearest = rounding_mode & ~0x30;
  __asm volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (round_nearest));
  __asm volatile ("fint%.x %1,%0"
		  : "=f" (value)
		  : "f" (x));
  __asm volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (rounding_mode));
  return value;
}
#define _GLIBCXX_HAVE_ROUNDF 1

__MATH_68881_INLINE long double
roundl (long double x)
{
  long rounding_mode, round_nearest;
  long double value;

  __asm volatile ("fmove%.l %!,%0"
		  : "=dm" (rounding_mode)
		  : /* no inputs */ );
  round_nearest = rounding_mode & ~0x30;
  __asm volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (round_nearest));
  __asm volatile ("fint%.x %1,%0"
		  : "=f" (value)
		  : "f" (x));
  __asm volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (rounding_mode));
  return value;
}
#define _GLIBCXX_HAVE_ROUNDL 1

__MATH_68881_INLINE double
fmod (double x, double y)
{
  double value;

  __asm ("fmod%.x %2,%0"
	 : "=f" (value)
	 : "0" (x),
	   "f" (y));
  return value;
}

__MATH_68881_INLINE float
fmodf (float x, float y)
{
  float value;

  __asm ("fmod%.x %2,%0"
	 : "=f" (value)
	 : "0" (x),
	   "f" (y));
  return value;
}
#define _GLIBCXX_HAVE_FMODF 1

__MATH_68881_INLINE long double
fmodl (long double x, long double y)
{
  long double value;

  __asm ("fmod%.x %2,%0"
	 : "=f" (value)
	 : "0" (x),
	   "f" (y));
  return value;
}
#define _GLIBCXX_HAVE_FMODL 1

__MATH_68881_INLINE double
drem (double x, double y)
{
  double value;

  __asm ("frem%.x %2,%0"
	 : "=f" (value)
	 : "0" (x),
	   "f" (y));
  return value;
}

__MATH_68881_INLINE float
dremf (float x, float y)
{
  float value;

  __asm ("frem%.x %2,%0"
	 : "=f" (value)
	 : "0" (x),
	   "f" (y));
  return value;
}
#define _GLIBCXX_HAVE_DREMF 1

__MATH_68881_INLINE long double
dreml (long double x, long double y)
{
  long double value;

  __asm ("frem%.x %2,%0"
	 : "=f" (value)
	 : "0" (x),
	   "f" (y));
  return value;
}
#define _GLIBCXX_HAVE_DREML 1

__MATH_68881_INLINE double
remainder (double x, double y)
{
  double value;

  __asm ("frem%.x %2,%0"
	 : "=f" (value)
	 : "0" (x),
	   "f" (y));
  return value;
}

__MATH_68881_INLINE float
remainderf (float x, float y)
{
  float value;

  __asm ("frem%.x %2,%0"
	 : "=f" (value)
	 : "0" (x),
	   "f" (y));
  return value;
}
#define _GLIBCXX_HAVE_REMAINDERF 1

__MATH_68881_INLINE long double
remainderl (long double x, long double y)
{
  long double value;

  __asm ("frem%.x %2,%0"
	 : "=f" (value)
	 : "0" (x),
	   "f" (y));
  return value;
}
#define _GLIBCXX_HAVE_REMAINDERL 1

__MATH_68881_INLINE double
scalb (double x, double n)
{
  double value;
  long exp = (long)(n);

  __asm ("fscale%.l %2,%0"
	 : "=f" (value)
	 : "0" (x),
	   "dmi" (exp));
  return value;
}

__MATH_68881_INLINE float
scalbf (float x, float n)
{
  float value;
  long exp = (long)(n);

  __asm ("fscale%.l %2,%0"
	 : "=f" (value)
	 : "0" (x),
	   "dmi" (exp));
  return value;
}
#define _GLIBCXX_HAVE_SCALBF 1

__MATH_68881_INLINE long double
scalbl (long double x, long double n)
{
  long double value;
  long exp = (long)(n);

  __asm ("fscale%.l %2,%0"
	 : "=f" (value)
	 : "0" (x),
	   "dmi" (exp));
  return value;
}
#define _GLIBCXX_HAVE_SCALBL 1

__MATH_68881_INLINE double
scalbn (double x, int n)
{
  double value;
  long exp = (long)(n);

  __asm ("fscale%.l %2,%0"
	 : "=f" (value)
	 : "0" (x),
	   "dmi" (exp));
  return value;
}

__MATH_68881_INLINE float
scalbnf (float x, int n)
{
  float value;
  long exp = (long)(n);

  __asm ("fscale%.l %2,%0"
	 : "=f" (value)
	 : "0" (x),
	   "dmi" (exp));
  return value;
}
#define _GLIBCXX_HAVE_SCALBNF 1

__MATH_68881_INLINE long double
scalbnl (long double x, int n)
{
  long double value;
  long exp = (long)(n);

  __asm ("fscale%.l %2,%0"
	 : "=f" (value)
	 : "0" (x),
	   "dmi" (exp));
  return value;
}
#define _GLIBCXX_HAVE_SCALBNL 1

__MATH_68881_INLINE double
scalbln (double x, long n)
{
  double value;
  long exp = (long)(n);

  __asm ("fscale%.l %2,%0"
	 : "=f" (value)
	 : "0" (x),
	   "dmi" (exp));
  return value;
}

__MATH_68881_INLINE float
scalblnf (float x, long n)
{
  float value;
  long exp = (long)(n);

  __asm ("fscale%.l %2,%0"
	 : "=f" (value)
	 : "0" (x),
	   "dmi" (exp));
  return value;
}
#define _GLIBCXX_HAVE_SCALBLNF 1

__MATH_68881_INLINE long double
scalblnl (long double x, long n)
{
  long double value;
  long exp = (long)(n);

  __asm ("fscale%.l %2,%0"
	 : "=f" (value)
	 : "0" (x),
	   "dmi" (exp));
  return value;
}
#define _GLIBCXX_HAVE_SCALBLNL 1

__MATH_68881_INLINE double
logb (double x)
{
  double exponent;

  __asm ("fgetexp%.x %1,%0"
	 : "=f" (exponent)
	 : "f" (x));
  return exponent;
}

__MATH_68881_INLINE float
logbf (float x)
{
  float exponent;

  __asm ("fgetexp%.x %1,%0"
	 : "=f" (exponent)
	 : "f" (x));
  return exponent;
}
#define _GLIBCXX_HAVE_LOGBF 1

__MATH_68881_INLINE long double
logbl (long double x)
{
  long double exponent;

  __asm ("fgetexp%.x %1,%0"
	 : "=f" (exponent)
	 : "f" (x));
  return exponent;
}
#define _GLIBCXX_HAVE_LOGBL 1

__MATH_68881_INLINE int
ilogb (double x)
{
  double exponent;

  __asm ("fgetexp%.x %1,%0"
	 : "=f" (exponent)
	 : "f" (x));
  return (int)exponent;
}

__MATH_68881_INLINE int
ilogbf (float x)
{
  float exponent;

  __asm ("fgetexp%.x %1,%0"
	 : "=f" (exponent)
	 : "f" (x));
  return (int)exponent;
}
#define _GLIBCXX_HAVE_ILOGBF 1

__MATH_68881_INLINE int
ilogbl (long double x)
{
  long double exponent;

  __asm ("fgetexp%.x %1,%0"
	 : "=f" (exponent)
	 : "f" (x));
  return (int)exponent;
}
#define _GLIBCXX_HAVE_ILOGBL 1


__MATH_68881_INLINE double
ldexp (double x, int n)
{
  double value;

  __asm ("fscale%.l %2,%0"
	 : "=f" (value)
	 : "0" (x),
	   "dmi" (n));
  return value;
}

__MATH_68881_INLINE float
ldexpf (float x, int n)
{
  float value;

  __asm ("fscale%.l %2,%0"
	 : "=f" (value)
	 : "0" (x),
	   "dmi" (n));
  return value;
}
#define _GLIBCXX_HAVE_LDEXPF 1

__MATH_68881_INLINE long double
ldexpl (long double x, int n)
{
  long double value;

  __asm ("fscale%.l %2,%0"
	 : "=f" (value)
	 : "0" (x),
	   "dmi" (n));
  return value;
}
#define _GLIBCXX_HAVE_LDEXPL 1

__MATH_68881_INLINE double
frexp (double x, int *exp)
{
  double float_exponent;
  long int_exponent;
  double mantissa;

  __asm ("fgetexp%.x %1,%0"
	 : "=f" (float_exponent)	/* integer-valued float */
	 : "f" (x));
  int_exponent = (long) float_exponent;
  __asm ("fgetman%.x %1,%0"
	 : "=f" (mantissa)		/* 1.0 <= mantissa < 2.0 */
	 : "f" (x));
  if (mantissa != 0)
    {
      __asm ("fscale%.b #-1,%0"
	     : "=f" (mantissa)		/* mantissa /= 2.0 */
	     : "0" (mantissa));
      int_exponent += 1;
    }
  *exp = int_exponent;
  return mantissa;
}

__MATH_68881_INLINE float
frexpf (float x, int *exp)
{
  float float_exponent;
  long int_exponent;
  float mantissa;

  __asm ("fgetexp%.x %1,%0"
	 : "=f" (float_exponent)	/* integer-valued float */
	 : "f" (x));
  int_exponent = (long) float_exponent;
  __asm ("fgetman%.x %1,%0"
	 : "=f" (mantissa)		/* 1.0 <= mantissa < 2.0 */
	 : "f" (x));
  if (mantissa != 0)
    {
      __asm ("fscale%.b #-1,%0"
	     : "=f" (mantissa)		/* mantissa /= 2.0 */
	     : "0" (mantissa));
      int_exponent += 1;
    }
  *exp = int_exponent;
  return mantissa;
}
#define _GLIBCXX_HAVE_FREXPF 1

__MATH_68881_INLINE long double
frexpl (long double x, int *exp)
{
  long double float_exponent;
  long int_exponent;
  long double mantissa;

  __asm ("fgetexp%.x %1,%0"
	 : "=f" (float_exponent)	/* integer-valued float */
	 : "f" (x));
  int_exponent = (long) float_exponent;
  __asm ("fgetman%.x %1,%0"
	 : "=f" (mantissa)		/* 1.0 <= mantissa < 2.0 */
	 : "f" (x));
  if (mantissa != 0)
    {
      __asm ("fscale%.b #-1,%0"
	     : "=f" (mantissa)		/* mantissa /= 2.0 */
	     : "0" (mantissa));
      int_exponent += 1;
    }
  *exp = int_exponent;
  return mantissa;
}
#define _GLIBCXX_HAVE_FREXPL 1

__MATH_68881_INLINE double
significand(double x)
{
  double mantissa;

  __asm ("fgetman%.x %1,%0"
	 : "=f" (mantissa)		/* 1.0 <= mantissa < 2.0 */
	 : "f" (x));
  return mantissa;
}

__MATH_68881_INLINE float
significandf(float x)
{
  float mantissa;

  __asm ("fgetman%.x %1,%0"
	 : "=f" (mantissa)		/* 1.0 <= mantissa < 2.0 */
	 : "f" (x));
  return mantissa;
}
#define _GLIBCXX_HAVE_SIGNIFICANDF 1

__MATH_68881_INLINE long double
significandl(long double x)
{
  long double mantissa;

  __asm ("fgetman%.x %1,%0"
	 : "=f" (mantissa)		/* 1.0 <= mantissa < 2.0 */
	 : "f" (x));
  return mantissa;
}
#define _GLIBCXX_HAVE_SIGNIFICANDL 1

__MATH_68881_INLINE double
modf (double x, double *ip)
{
  double temp;

  __asm ("fintrz%.x %1,%0"
	 : "=f" (temp)			/* integer-valued float */
	 : "f" (x));
  *ip = temp;
  return x - temp;
}

__MATH_68881_INLINE float
modff (float x, float *ip)
{
  float temp;

  __asm ("fintrz%.x %1,%0"
	 : "=f" (temp)			/* integer-valued float */
	 : "f" (x));
  *ip = temp;
  return x - temp;
}
#define _GLIBCXX_HAVE_MODFF 1

__MATH_68881_INLINE long double
modfl (long double x, long double *ip)
{
  long double temp;

  __asm ("fintrz%.x %1,%0"
	 : "=f" (temp)			/* integer-valued float */
	 : "f" (x));
  *ip = temp;
  return x - temp;
}
#define _GLIBCXX_HAVE_MODFL 1

#ifdef __USE_ISOC99

#ifndef isunordered
__MATH_68881_INLINE int
__isunordered (double x, double y)
{
  signed char res;

  __asm ("fcmp%.x %1,%2\n"
  	 "\tfsun %0"
	 : "=d" (res)
	 : "f" (x), "f" (y));
  return -res;
}

__MATH_68881_INLINE int
__isunorderedf (float x, float y)
{
  signed char res;

  __asm ("fcmp%.x %1,%2\n"
  	 "\tfsun %0"
	 : "=d" (res)
	 : "f" (x), "f" (y));
  return -res;
}

__MATH_68881_INLINE int
__isunorderedl (long double x, long double y)
{
  signed char res;

  __asm ("fcmp%.x %1,%2\n"
  	 "\tfsun %0"
	 : "=d" (res)
	 : "f" (x), "f" (y));
  return -res;
}

# ifdef __NO_LONG_DOUBLE_MATH
#  define isunordered(x, y) \
     (sizeof (x) == sizeof (float) && sizeof (y) == sizeof (float) ? __isunorderedf (x, y) : __isunordered (x, y))
# else
#  define isunordered(x, y) \
     (sizeof (x) == sizeof (float) && sizeof (y) == sizeof (float)					      \
      ? __isunorderedf (x, y)						      \
      : sizeof (x) == sizeof (double) && sizeof (y) == sizeof (double)					      \
      ? __isunordered (x, y) : __isunorderedl (x, y))
# endif
#endif

__MATH_68881_INLINE double
fma(double x, double y, double z)
{
	return (x * y) + z;
}

__MATH_68881_INLINE float
fmaf(float x, float y, float z)
{
	return (x * y) + z;
}
#define _GLIBCXX_HAVE_FMAF 1

__MATH_68881_INLINE long double
fmal(long double x, long double y, long double z)
{
	return (x * y) + z;
}
#define _GLIBCXX_HAVE_FMAL 1

#endif /* __USE_ISOC99 */

#endif /* not __math_68881 */

```

`include/bits/math-cffpu.h`:

```h
/******************************************************************\
*                                                                  *
*  <math-cffpu.h>               last modified: 6 Apr 2014.         *
*                                                                  *
*  Copyright (C) 2014 by Thorsten Otto.                            *
*  Modified version of <math-68881.h>, adjusted for ColdFire FPUs  *
*                                                                  *
*  You may freely distribute verbatim copies of this software      *
*  provided that this copyright notice is retained in all copies.  *
*  You may distribute modifications to this software under the     *
*  conditions above if you also clearly note such modifications    *
*  with their author and date.                                     *
*                                                                  *
*  Note:  errno is not set to EDOM when domain errors occur for    *
*  most of these functions.  Rather, it is assumed that the        *
*  68881's OPERR exception will be enabled and handled             *
*  appropriately by the operating system.  Similarly, overflow     *
*  and underflow do not set errno to ERANGE.                       *
*                                                                  *
\******************************************************************/

#ifndef __math_cffpu
#define __math_cffpu

#include <errno.h>

/* GCC 4.3 and above with -std=c99 or -std=gnu99 implements ISO C99
   inline semantics, unless -fgnu89-inline is used.  */
#ifdef __cplusplus
# define __MATH_68881_INLINE inline
#elif defined __GNUC_STDC_INLINE__
# define __MATH_68881_INLINE extern __inline __attribute__ ((__gnu_inline__))
#else
# define __MATH_68881_INLINE extern __inline
#endif

__MATH_68881_INLINE double
atan2 (double y, double x)
{
  double pi, pi_over_2;

#ifdef M_PI
  pi = M_PI;
  pi_over_2 = M_PI_2;
#else
  pi = 3.14159265358979323846;
  pi_over_2 = 1.57079632679489661923;
#endif
  if (x > 0)
    {
      if (y > 0)
	{
	  if (x > y)
	    return atan (y / x);
	  else
	    return pi_over_2 - atan (x / y);
	}
      else
	{
	  if (x > -y)
	    return atan (y / x);
	  else
	    return - pi_over_2 - atan (x / y);
	}
    }
  else
    {
      if (y < 0)
	{
	  if (-x > -y)
	    return - pi + atan (y / x);
	  else
	    return - pi_over_2 - atan (x / y);
	}
      else
	{
	  if (-x > y)
	    return pi + atan (y / x);
	  else if (y > 0)
	    return pi_over_2 - atan (x / y);
	  else
	    {
	      double value;

	      errno = EDOM;
	      value = __builtin_nan("");
	      return value;
	    }
	}
    }
}

#if defined __USE_MISC || defined __USE_ISOC99
__MATH_68881_INLINE float
atan2f (float y, float x)
{
  float pi, pi_over_2;

#ifdef M_PI
  pi = M_PI;
  pi_over_2 = M_PI_2;
#else
  pi = 3.14159265358979323846;
  pi_over_2 = 1.57079632679489661923;
#endif
  if (x > 0)
    {
      if (y > 0)
	{
	  if (x > y)
	    return atanf (y / x);
	  else
	    return pi_over_2 - atanf (x / y);
	}
      else
	{
	  if (x > -y)
	    return atanf (y / x);
	  else
	    return - pi_over_2 - atanf (x / y);
	}
    }
  else
    {
      if (y < 0)
	{
	  if (-x > -y)
	    return - pi + atanf (y / x);
	  else
	    return - pi_over_2 - atanf (x / y);
	}
      else
	{
	  if (-x > y)
	    return pi + atanf (y / x);
	  else if (y > 0)
	    return pi_over_2 - atanf (x / y);
	  else
	    {
	      float value;

	      errno = EDOM;
	      value = __builtin_nanf("");
	      return value;
	    }
	}
    }
}
#define _GLIBCXX_HAVE_ATAN2F 1
#endif

__MATH_68881_INLINE long double
atan2l (long double y, long double x)
{
	return atan2(y, x);
}
#define _GLIBCXX_HAVE_ATAN2L 1

__MATH_68881_INLINE double
sqrt (double x)
{
  double value;

  __asm ("fsqrt%.d %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_68881_INLINE float
sqrtf (float x)
{
  float value;

  __asm ("fsqrt%.d %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define _GLIBCXX_HAVE_SQRTF 1

__MATH_68881_INLINE long double
sqrtl (long double x)
{
	return sqrt(x);
}
#define _GLIBCXX_HAVE_SQRTL 1

__MATH_68881_INLINE double
hypot (double x, double y)
{
  return __builtin_isinf(x) || __builtin_isinf(y) ? __builtin_inf() : sqrt (x*x + y*y);
}

__MATH_68881_INLINE float
hypotf (float x, float y)
{
  return __builtin_isinff(x) || __builtin_isinff(y) ? __builtin_inff() : sqrtf (x*x + y*y);
}
#define _GLIBCXX_HAVE_HYPOTF 1

__MATH_68881_INLINE long double
hypotl (long double x, long double y)
{
  return __builtin_isinfl(x) || __builtin_isinfl(y) ? __builtin_infl() : sqrtl (x*x + y*y);
}
#define _GLIBCXX_HAVE_HYPOTL 1

__MATH_68881_INLINE double
pow (double x, double y)
{
  if (x > 0)
    return exp (y * log (x));
  else if (x == 0)
    {
      if (y > 0)
	return 0.0;
      else
	{
	  double value;

	  errno = EDOM;
	  value = __builtin_nan("");		/* quiet NaN */
	  return value;
	}
    }
  else
    {
      double temp;

      __asm ("fintrz%.d %1,%0"
	     : "=f" (temp)			/* integer-valued float */
	     : "f" (y));
      if (y == temp)
        {
	  int i = (int) y;

	  if ((i & 1) == 0)			/* even */
	    return exp (y * log (-x));
	  else
	    return - exp (y * log (-x));
        }
      else
        {
	  double value;

	  errno = EDOM;
	  value = __builtin_nan("");		/* quiet NaN */
	  return value;
        }
    }
}

#if defined __USE_MISC || defined __USE_ISOC99
__MATH_68881_INLINE float
powf (float x, float y)
{
  if (x > 0)
    return expf (y * logf (x));
  else if (x == 0)
    {
      if (y > 0)
	return 0.0;
      else
	{
	  float value;

	  errno = EDOM;
	  value = __builtin_nanf("");
	  return value;
	}
    }
  else
    {
      float temp;

      __asm ("fintrz%.d %1,%0"
	     : "=f" (temp)			/* integer-valued float */
	     : "f" (y));
      if (y == temp)
        {
	  int i = (int) y;

	  if ((i & 1) == 0)			/* even */
	    return expf (y * logf (-x));
	  else
	    return - expf (y * logf (-x));
        }
      else
        {
	  float value;

	  errno = EDOM;
	  value = __builtin_nanf("");
	  return value;
        }
    }
}
#define _GLIBCXX_HAVE_POWF 1
#endif

__MATH_68881_INLINE long double
powl (long double x, long double y)
{
	return pow(x, y);
}
#define _GLIBCXX_HAVE_POWL 1

__MATH_68881_INLINE double
fabs (double x)
{
  double value;

  __asm ("fabs%.d %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}

__MATH_68881_INLINE float
fabsf (float x)
{
  float value;

  __asm ("fabs%.d %1,%0"
	 : "=f" (value)
	 : "f" (x));
  return value;
}
#define _GLIBCXX_HAVE_FABSF 1

__MATH_68881_INLINE long double
fabsl (long double x)
{
	return fabs(x);
}
#define _GLIBCXX_HAVE_FABSL 1

__MATH_68881_INLINE double
ceil (double x)
{
  long rounding_mode, round_up;
  double value;

  __asm volatile ("fmove%.l %!,%0"
		  : "=dm" (rounding_mode)
		  : /* no inputs */ );
  round_up = rounding_mode | 0x30;
  __asm volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (round_up));
  __asm volatile ("fint%.d %1,%0"
		  : "=f" (value)
		  : "f" (x));
  __asm volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (rounding_mode));
  return value;
}

__MATH_68881_INLINE float
ceilf (float x)
{
  long rounding_mode, round_up;
  float value;

  __asm volatile ("fmove%.l %!,%0"
		  : "=dm" (rounding_mode)
		  : /* no inputs */ );
  round_up = rounding_mode | 0x30;
  __asm volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (round_up));
  __asm volatile ("fint%.d %1,%0"
		  : "=f" (value)
		  : "f" (x));
  __asm volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (rounding_mode));
  return value;
}
#define _GLIBCXX_HAVE_CEILF 1

__MATH_68881_INLINE long double
ceill (long double x)
{
	return ceil(x);
}
#define _GLIBCXX_HAVE_CEILL 1

__MATH_68881_INLINE double
floor (double x)
{
  long rounding_mode, round_down;
  double value;

  __asm volatile ("fmove%.l %!,%0"
		  : "=dm" (rounding_mode)
		  : /* no inputs */ );
  round_down = (rounding_mode & ~0x10)
		| 0x20;
  __asm volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (round_down));
  __asm volatile ("fint%.d %1,%0"
		  : "=f" (value)
		  : "f" (x));
  __asm volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (rounding_mode));
  return value;
}

__MATH_68881_INLINE float
floorf (float x)
{
  long rounding_mode, round_down;
  float value;

  __asm volatile ("fmove%.l %!,%0"
		  : "=dm" (rounding_mode)
		  : /* no inputs */ );
  round_down = (rounding_mode & ~0x10)
		| 0x20;
  __asm volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (round_down));
  __asm volatile ("fint%.d %1,%0"
		  : "=f" (value)
		  : "f" (x));
  __asm volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (rounding_mode));
  return value;
}
#define _GLIBCXX_HAVE_FLOORF 1

__MATH_68881_INLINE long double
floorl (long double x)
{
	return floor(x);
}
#define _GLIBCXX_HAVE_FLOORL 1

__MATH_68881_INLINE double
trunc (double x)
{
  double value;

  __asm volatile ("fintrz%.d %1,%0"
		  : "=f" (value)
		  : "f" (x));
  return value;
}

__MATH_68881_INLINE float
truncf (float x)
{
  float value;

  __asm volatile ("fintrz%.d %1,%0"
		  : "=f" (value)
		  : "f" (x));
  return value;
}
#define _GLIBCXX_HAVE_TRUNCF 1

__MATH_68881_INLINE long double
truncl (long double x)
{
	return trunc(x);
}
#define _GLIBCXX_HAVE_TRUNCL 1

__MATH_68881_INLINE double
rint (double x)
{
  double value;
  __asm volatile ("fint%.d %1,%0"
		  : "=f" (value)
		  : "f" (x));
  return value;
}

__MATH_68881_INLINE float
rintf (float x)
{
  float value;
  __asm volatile ("fint%.d %1,%0"
		  : "=f" (value)
		  : "f" (x));
  return value;
}
#define _GLIBCXX_HAVE_RINTF 1

__MATH_68881_INLINE long double
rintl (long double x)
{
	return rint(x);
}
#define _GLIBCXX_HAVE_RINTL 1

__MATH_68881_INLINE double
round (double x)
{
  long rounding_mode, round_nearest;
  double value;

  __asm volatile ("fmove%.l %!,%0"
		  : "=dm" (rounding_mode)
		  : /* no inputs */ );
  round_nearest = rounding_mode & ~0x30;
  __asm volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (round_nearest));
  __asm volatile ("fint%.d %1,%0"
		  : "=f" (value)
		  : "f" (x));
  __asm volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (rounding_mode));
  return value;
}

__MATH_68881_INLINE float
roundf (float x)
{
  long rounding_mode, round_nearest;
  float value;

  __asm volatile ("fmove%.l %!,%0"
		  : "=dm" (rounding_mode)
		  : /* no inputs */ );
  round_nearest = rounding_mode & ~0x30;
  __asm volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (round_nearest));
  __asm volatile ("fint%.d %1,%0"
		  : "=f" (value)
		  : "f" (x));
  __asm volatile ("fmove%.l %0,%!"
		  : /* no outputs */
		  : "dmi" (rounding_mode));
  return value;
}
#define _GLIBCXX_HAVE_ROUNDF 1

__MATH_68881_INLINE long double
roundl (long double x)
{
	return round(x);
}
#define _GLIBCXX_HAVE_ROUNDL 1

__MATH_68881_INLINE double
modf (double x, double *ip)
{
  double temp;

  __asm ("fintrz%.d %1,%0"
	 : "=f" (temp)			/* integer-valued float */
	 : "f" (x));
  *ip = temp;
  return x - temp;
}

__MATH_68881_INLINE float
modff (float x, float *ip)
{
  float temp;

  __asm ("fintrz%.d %1,%0"
	 : "=f" (temp)			/* integer-valued float */
	 : "f" (x));
  *ip = temp;
  return x - temp;
}
#define _GLIBCXX_HAVE_MODFF 1

__MATH_68881_INLINE long double
modfl (long double x, long double *ip)
{
  long double temp;

  __asm ("fintrz%.d %1,%0"
	 : "=f" (temp)			/* integer-valued float */
	 : "f" (x));
  *ip = temp;
  return x - temp;
}
#define _GLIBCXX_HAVE_MODFL 1

#ifdef __USE_ISOC99

#ifndef isunordered
__MATH_68881_INLINE int
__isunordered (double x, double y)
{
  signed char res;

  __asm ("fcmp%.d %1,%2\n"
  	 "\tfsun %0"
	 : "=d" (res)
	 : "f" (x), "f" (y));
  return -res;
}

__MATH_68881_INLINE int
__isunorderedf (float x, float y)
{
  signed char res;

  __asm ("fcmp%.d %1,%2\n"
  	 "\tfsun %0"
	 : "=d" (res)
	 : "f" (x), "f" (y));
  return -res;
}

__MATH_68881_INLINE int
__isunorderedl (long double x, long double y)
{
  signed char res;

  __asm ("fcmp%.d %1,%2\n"
  	 "\tfsun %0"
	 : "=d" (res)
	 : "f" (x), "f" (y));
  return -res;
}

# ifdef __NO_LONG_DOUBLE_MATH
#  define isunordered(x, y) \
     (sizeof (x) == sizeof (float) && sizeof (y) == sizeof (float) ? __isunorderedf (x, y) : __isunordered (x, y))
# else
#  define isunordered(x, y) \
     (sizeof (x) == sizeof (float) && sizeof (y) == sizeof (float)					      \
      ? __isunorderedf (x, y)						      \
      : sizeof (x) == sizeof (double) && sizeof (y) == sizeof (double)					      \
      ? __isunordered (x, y) : __isunorderedl (x, y))
# endif
#endif

#endif /* __USE_ISOC99 */

#endif /* math-cffpu.h */

```

`include/bits/mathcall.h`:

```h
/* Prototype declarations for math functions; helper file for <math.h>.
   Copyright (C) 1996-2019 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/* NOTE: Because of the special way this file is used by <math.h>, this
   file must NOT be protected from multiple inclusion as header files
   usually are.

   This file provides prototype declarations for the math functions.
   Most functions are declared using the macro:

   __MATHCALL (NAME,[_r], (ARGS...));

   This means there is a function `NAME' returning `double' and a function
   `NAMEf' returning `float'.  Each place `_Mdouble_' appears in the
   prototype, that is actually `double' in the prototype for `NAME' and
   `float' in the prototype for `NAMEf'.  Reentrant variant functions are
   called `NAME_r' and `NAMEf_r'.

   Functions returning other types like `int' are declared using the macro:

   __MATHDECL (TYPE, NAME,[_r], (ARGS...));

   This is just like __MATHCALL but for a function returning `TYPE'
   instead of `_Mdouble_'.  In all of these cases, there is still
   both a `NAME' and a `NAMEf' that takes `float' arguments.

   Note that there must be no whitespace before the argument passed for
   NAME, to make token pasting work with -traditional.  */

#ifndef _MATH_H
# error "Never include <bits/mathcalls.h> directly; include <math.h> instead."
#endif

#ifndef __GLIBC_USE_IEC_60559_BFP_EXT
#if defined __USE_GNU || defined __STDC_WANT_IEC_60559_BFP_EXT__
# define __GLIBC_USE_IEC_60559_BFP_EXT 1
#else
# define __GLIBC_USE_IEC_60559_BFP_EXT 0
#endif
#endif

/* Trigonometric functions.  */

_Mdouble_BEGIN_NAMESPACE
/* Arc cosine of X.  */
__MATHCALL (acos,, (_Mdouble_ __x));
/* Arc sine of X.  */
__MATHCALL (asin,, (_Mdouble_ __x));
/* Arc tangent of X.  */
__MATHCALL (atan,, (_Mdouble_ __x));
/* Arc tangent of Y/X.  */
__MATHCALL (atan2,, (_Mdouble_ __y, _Mdouble_ __x));

/* Cosine of X.  */
__MATHCALL (cos,, (_Mdouble_ __x));
/* Sine of X.  */
__MATHCALL (sin,, (_Mdouble_ __x));
/* Tangent of X.  */
__MATHCALL (tan,, (_Mdouble_ __x));

/* Hyperbolic functions.  */

/* Hyperbolic cosine of X.  */
__MATHCALL (cosh,, (_Mdouble_ __x));
/* Hyperbolic sine of X.  */
__MATHCALL (sinh,, (_Mdouble_ __x));
/* Hyperbolic tangent of X.  */
__MATHCALL (tanh,, (_Mdouble_ __x));
_Mdouble_END_NAMESPACE

#if defined __USE_GNU || defined __USE_PUREC
/* Cosine and sine of X.  */
__MATHDECL (void,sincos,,
		(_Mdouble_ __x, _Mdouble_ *__sinx, _Mdouble_ *__cosx));
#endif

#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED || defined __USE_ISOC99 || defined __USE_PUREC
__BEGIN_NAMESPACE_C99
/* Hyperbolic arc cosine of X.  */
__MATHCALL (acosh,, (_Mdouble_ __x));
/* Hyperbolic arc sine of X.  */
__MATHCALL (asinh,, (_Mdouble_ __x));
/* Hyperbolic arc tangent of X.  */
__MATHCALL (atanh,, (_Mdouble_ __x));
__END_NAMESPACE_C99
#endif

/* Exponential and logarithmic functions.  */

_Mdouble_BEGIN_NAMESPACE
/* Exponential function of X.  */
__MATHCALL (exp,, (_Mdouble_ __x));

/* Break VALUE into a normalized fraction and an integral power of 2.  */
__MATHCALL (frexp,, (_Mdouble_ __x, int *__exponent));

/* X times (two to the EXP power).  */
__MATHCALL (ldexp,, (_Mdouble_ __x, int __exponent));

/* Natural logarithm of X.  */
__MATHCALL (log,, (_Mdouble_ __x));

/* Base-ten logarithm of X.  */
__MATHCALL (log10,, (_Mdouble_ __x));

/* Break VALUE into integral and fractional parts.  */
__MATHCALL (modf,, (_Mdouble_ __x, _Mdouble_ *__iptr)) __nonnull ((2));
_Mdouble_END_NAMESPACE

#if defined __USE_GNU || defined __USE_PUREC
/* A function missing in all standards: compute exponent to base ten.  */
__MATHCALL (exp10,, (_Mdouble_ __x));
/* Another name occasionally used.  */
__MATHCALL (pow10,, (_Mdouble_ __x));
#endif

#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED || defined __USE_ISOC99 || defined __USE_PUREC
__BEGIN_NAMESPACE_C99
/* Return exp(X) - 1.  */
__MATHCALL (expm1,, (_Mdouble_ __x));

/* Return log(1 + X).  */
__MATHCALL (log1p,, (_Mdouble_ __x));

/* Return the base 2 signed integral exponent of X.  */
__MATHCALL (logb,, (_Mdouble_ __x));
__END_NAMESPACE_C99
#endif

#if defined __USE_ISOC99 || defined __USE_PUREC
__BEGIN_NAMESPACE_C99
/* Compute base-2 exponential of X.  */
__MATHCALL (exp2,, (_Mdouble_ __x));
/* Another name occasionally used.  */
__MATHCALL (pow2,, (_Mdouble_ __x));

/* Compute base-2 logarithm of X.  */
__MATHCALL (log2,, (_Mdouble_ __x));
__END_NAMESPACE_C99
#endif


/* Power functions.  */

_Mdouble_BEGIN_NAMESPACE
/* Return X to the Y power.  */
__MATHCALL (pow,, (_Mdouble_ __x, _Mdouble_ __y));

/* Return the square root of X.  */
__MATHCALL (sqrt,, (_Mdouble_ __x));
_Mdouble_END_NAMESPACE

#if defined __USE_MISC || defined __USE_XOPEN || defined __USE_ISOC99 || defined __USE_PUREC
__BEGIN_NAMESPACE_C99
/* Return `sqrt(X*X + Y*Y)'.  */
__MATHCALL (hypot,, (_Mdouble_ __x, _Mdouble_ __y));
__END_NAMESPACE_C99
#endif

#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED || defined __USE_ISOC99 || defined __USE_PUREC
__BEGIN_NAMESPACE_C99
/* Return the cube root of X.  */
__MATHCALL (cbrt,, (_Mdouble_ __x));
__END_NAMESPACE_C99
#endif


/* Nearest integer, absolute value, and remainder functions.  */

_Mdouble_BEGIN_NAMESPACE
/* Smallest integral value not less than X.  */
__MATHCALLX (ceil,, (_Mdouble_ __x), (__const__));

/* Absolute value of X.  */
__MATHCALLX (fabs,, (_Mdouble_ __x), (__const__));

/* Largest integer not greater than X.  */
__MATHCALLX (floor,, (_Mdouble_ __x), (__const__));

/* Floating-point modulo remainder of X/Y.  */
__MATHCALL (fmod,, (_Mdouble_ __x, _Mdouble_ __y));


/* Return 0 if VALUE is finite or NaN, +1 if it
   is +Infinity, -1 if it is -Infinity.  */
__MATHDECL_1 (int,__isinf,, (_Mdouble_ __value)) __attribute__ ((__const__));

/* Return nonzero if VALUE is finite and not NaN.  */
__MATHDECL_1 (int,__finite,, (_Mdouble_ __value)) __attribute__ ((__const__));
_Mdouble_END_NAMESPACE

#if defined __USE_MISC || defined __USE_PUREC
# if ((!defined __cplusplus \
       || __cplusplus < 201103L /* isinf conflicts with C++11.  */ \
       || __MATH_DECLARING_DOUBLE == 0)) /* isinff or isinfl don't.  */ \
      && !__MATH_DECLARING_FLOATN
/* Return 0 if VALUE is finite or NaN, +1 if it
   is +Infinity, -1 if it is -Infinity.  */
__MATHDECL_1 (int,isinf,, (_Mdouble_ __value)) __attribute__ ((__const__));
# endif

# if !__MATH_DECLARING_FLOATN
/* Return nonzero if VALUE is finite and not NaN.  */
__MATHDECL_1 (int,finite,, (_Mdouble_ __value)) __attribute__ ((__const__));

/* Return the remainder of X/Y.  */
__MATHCALL (drem,, (_Mdouble_ __x, _Mdouble_ __y));


/* Return the fractional part of X after dividing out `ilogb (X)'.  */
__MATHCALL (significand,, (_Mdouble_ __x));
# endif

#endif /* Use misc.  */

#if defined __USE_MISC || defined __USE_ISOC99 || defined __USE_PUREC
__BEGIN_NAMESPACE_C99
/* Return X with its signed changed to Y's.  */
__MATHCALLX (copysign,, (_Mdouble_ __x, _Mdouble_ __y), (__const__));
__END_NAMESPACE_C99
#endif

#if defined __USE_ISOC99
__BEGIN_NAMESPACE_C99
/* Return representation of qNaN for double type.  */
__MATHCALLX (nan,, (const char *__tagb), (__const__));
__END_NAMESPACE_C99
#endif


/* Return nonzero if VALUE is not a number.  */
__MATHDECL_1 (int,__isnan,, (_Mdouble_ __value)) __attribute__ ((__const__));

#if defined __USE_MISC || defined __USE_XOPEN || defined __USE_PUREC
# if ((!defined __cplusplus \
       || __cplusplus < 201103L /* isnan conflicts with C++11.  */ \
       || __MATH_DECLARING_DOUBLE == 0)) /* isnanf or isnanl don't.  */ \
      && !__MATH_DECLARING_FLOATN
/* Return nonzero if VALUE is not a number.  */
__MATHDECL_1 (int,isnan,, (_Mdouble_ __value)) __attribute__ ((__const__));
# endif
#endif

#if defined __USE_MISC || defined __USE_PUREC || (defined __USE_XOPEN && __MATH_DECLARING_DOUBLE)
/* Bessel functions.  */
__MATHCALL (j0,, (_Mdouble_));
__MATHCALL (j1,, (_Mdouble_));
__MATHCALL (jn,, (int, _Mdouble_));
__MATHCALL (y0,, (_Mdouble_));
__MATHCALL (y1,, (_Mdouble_));
__MATHCALL (yn,, (int, _Mdouble_));
#endif


#if defined __USE_MISC || defined __USE_XOPEN || defined __USE_ISOC99 || defined __USE_PUREC
__BEGIN_NAMESPACE_C99
/* Error and gamma functions.  */
__MATHCALL (erf,, (_Mdouble_));
__MATHCALL (erfc,, (_Mdouble_));
__MATHCALL (lgamma,, (_Mdouble_));
__END_NAMESPACE_C99
#endif

#if defined __USE_ISOC99 || defined __USE_PUREC
__BEGIN_NAMESPACE_C99
/* True gamma function.  */
__MATHCALL (tgamma,, (_Mdouble_));
__END_NAMESPACE_C99
#endif

#if defined __USE_MISC || defined __USE_XOPEN || defined __USE_PUREC
# if !__MATH_DECLARING_FLOATN
/* Obsolete alias for `lgamma'.  */
__MATHCALL (gamma,, (_Mdouble_));
__MATHCALL (gamma,_r, (_Mdouble_, int *__signgamp));
# endif
#endif

#if defined __USE_MISC || defined __USE_PUREC
/* Reentrant version of lgamma.  This function uses the global variable
   `signgam'.  The reentrant version instead takes a pointer and stores
   the value through it.  */
__MATHCALL (lgamma,_r, (_Mdouble_, int *__signgamp));
#endif


#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED || defined __USE_ISOC99 || defined __USE_PUREC
__BEGIN_NAMESPACE_C99
/* Return the integer nearest X in the direction of the
   prevailing rounding mode.  */
__MATHCALL (rint,, (_Mdouble_ __x));

/* Return X + epsilon if X < Y, X - epsilon if X > Y.  */
__MATHCALLX (nextafter,, (_Mdouble_ __x, _Mdouble_ __y), (__const__));
# if defined __USE_ISOC99 && !defined __LDBL_COMPAT && !__MATH_DECLARING_FLOATN
__MATHCALLX (nexttoward,, (_Mdouble_ __x, long double __y), (__const__));
# endif

# if __GLIBC_USE_IEC_60559_BFP_EXT || __MATH_DECLARING_FLOATN
/* Return X - epsilon.  */
__MATHCALL (nextdown,, (_Mdouble_ __x));
/* Return X + epsilon.  */
__MATHCALL (nextup,, (_Mdouble_ __x));
# endif

/* Return the remainder of integer divison X / Y with infinite precision.  */
__MATHCALL (remainder,, (_Mdouble_ __x, _Mdouble_ __y));

# if defined __USE_MISC || defined __USE_ISOC99
/* Return X times (2 to the Nth power).  */
__MATHCALL (scalbn,, (_Mdouble_ __x, int __n));
# endif

/* Return the binary exponent of X, which must be nonzero.  */
__MATHDECL (int,ilogb,, (_Mdouble_ __x));
#endif

#if __GLIBC_USE_IEC_60559_BFP_EXT || __MATH_DECLARING_FLOATN
/* Like ilogb, but returning long int.  */
__MATHDECL (long int, llogb,, (_Mdouble_ __x));
#endif

#if defined __USE_ISOC99 || defined __USE_PUREC
/* Return X times (2 to the Nth power).  */
__MATHCALL (scalbln,, (_Mdouble_ __x, long int __n));

/* Round X to integral value in floating-point format using current
   rounding direction, but do not raise inexact exception.  */
__MATHCALL (nearbyint,, (_Mdouble_ __x));

/* Round X to nearest integral value, rounding halfway cases away from
   zero.  */
__MATHCALLX (round,, (_Mdouble_ __x), (__const__));

/* Round X to the integral value in floating-point format nearest but
   not larger in magnitude.  */
__MATHCALLX (trunc,, (_Mdouble_ __x), (__const__));

/* Compute remainder of X and Y and put in *QUO a value with sign of x/y
   and magnitude congruent `mod 2^n' to the magnitude of the integral
   quotient x/y, with n >= 3.  */
__MATHCALL (remquo,, (_Mdouble_ __x, _Mdouble_ __y, int *__quo));


/* Conversion functions.  */

/* Round X to nearest integral value according to current rounding
   direction.  */
__MATHDECL (long int,lrint,, (_Mdouble_ __x));
#ifndef __NO_LONGLONG
__extension__
__MATHDECL (long long int,llrint,, (_Mdouble_ __x));
#endif

/* Round X to nearest integral value, rounding halfway cases away from
   zero.  */
__MATHDECL (long int,lround,, (_Mdouble_ __x));
#ifndef __NO_LONGLONG
__extension__
__MATHDECL (long long int,llround,, (_Mdouble_ __x));
#endif


/* Return positive difference between X and Y.  */
__MATHCALL (fdim,, (_Mdouble_ __x, _Mdouble_ __y));

/* Return maximum numeric value from X and Y.  */
__MATHCALLX (fmax,, (_Mdouble_ __x, _Mdouble_ __y), (__const__));

/* Return minimum numeric value from X and Y.  */
__MATHCALLX (fmin,, (_Mdouble_ __x, _Mdouble_ __y), (__const__));


/* Classify given number.  */
__MATHDECL_1 (int, __fpclassify,, (_Mdouble_ __value))
     __attribute__ ((__const__));

/* Test for negative number.  */
__MATHDECL_1 (int, __signbit,, (_Mdouble_ __value))
     __attribute__ ((__const__));
#ifndef __cplusplus
__MATHDECL_1 (int, signbit,, (_Mdouble_ __value))
     __attribute__ ((__const__));
#endif


/* Multiply-add function computed as a ternary operation.  */
__MATHCALL (fma,, (_Mdouble_ __x, _Mdouble_ __y, _Mdouble_ __z));
#endif /* Use ISO C99.  */

#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED || defined __USE_ISOC99 || defined __USE_PUREC
__END_NAMESPACE_C99
#endif

#if __GLIBC_USE_IEC_60559_BFP_EXT || __MATH_DECLARING_FLOATN
/* Round X to nearest integer value, rounding halfway cases to even.  */
__MATHCALLX (roundeven,, (_Mdouble_ __x), (__const__));

#ifdef ____intmax_t_defined
/* Round X to nearest signed integer value, not raising inexact, with
   control of rounding direction and width of result.  */
__MATHDECL (__intmax_t, fromfp,, (_Mdouble_ __x, int __round,
				  unsigned int __width));

/* Round X to nearest unsigned integer value, not raising inexact,
   with control of rounding direction and width of result.  */
__MATHDECL (__uintmax_t, ufromfp,, (_Mdouble_ __x, int __round,
				    unsigned int __width));

/* Round X to nearest signed integer value, raising inexact for
   non-integers, with control of rounding direction and width of
   result.  */
__MATHDECL (__intmax_t, fromfpx,, (_Mdouble_ __x, int __round,
				   unsigned int __width));

/* Round X to nearest unsigned integer value, raising inexact for
   non-integers, with control of rounding direction and width of
   result.  */
__MATHDECL (__uintmax_t, ufromfpx,, (_Mdouble_ __x, int __round,
				     unsigned int __width));
#endif

/* Return value with maximum magnitude.  */
__MATHCALLX (fmaxmag,, (_Mdouble_ __x, _Mdouble_ __y), (__const__));

/* Return value with minimum magnitude.  */
__MATHCALLX (fminmag,, (_Mdouble_ __x, _Mdouble_ __y), (__const__));

/* Total order operation.  */
__MATHDECL_1 (int, totalorder,, (_Mdouble_ __x, _Mdouble_ __y))
     __attribute__ ((__const__));

/* Total order operation on absolute values.  */
__MATHDECL_1 (int, totalordermag,, (_Mdouble_ __x, _Mdouble_ __y))
     __attribute__ ((__const__));

/* Canonicalize floating-point representation.  */
__MATHDECL_1 (int, canonicalize,, (_Mdouble_ *__cx, const _Mdouble_ *__x));

/* Get NaN payload.  */
__MATHCALL (getpayload,, (const _Mdouble_ *__x));

/* Set quiet NaN payload.  */
__MATHDECL_1 (int, setpayload,, (_Mdouble_ *__x, _Mdouble_ __payload));

/* Set signaling NaN payload.  */
__MATHDECL_1 (int, setpayloadsig,, (_Mdouble_ *__x, _Mdouble_ __payload));
#endif

#if defined __USE_GNU
/* Test for signaling NaN.  */
__MATHDECL_1 (int, __issignaling,, (_Mdouble_ __value))
     __attribute__ ((__const__));
__MATHDECL_1 (int, issignaling,, (_Mdouble_ __value))
     __attribute__ ((__const__));
#endif

#if (defined __USE_MISC || (defined __USE_XOPEN_EXTENDED && __MATH_DECLARING_DOUBLE	&& !defined __USE_XOPEN2K8)) && !__MATH_DECLARING_FLOATN
/* Return X times (2 to the Nth power).  */
__MATHCALL (scalb,, (_Mdouble_ __x, _Mdouble_ __n));
#endif


#ifndef __STRICT_ANSI__
__MATHCALL (poly,, (int order, const _Mdouble_ *coeffs, _Mdouble_ x));
#endif


```

`include/bits/mathdef.h`:

```h
/* Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

#if !defined _MATH_H && !defined _COMPLEX_H
# error "Never use <bits/mathdef.h> directly; include <math.h> instead"
#endif

/* The m68k FPUs evaluate all values in the 96 bit floating-point format
   which is also available for the user as `long double'.  Therefore we
   define: */
#ifndef __FLT_EVAL_METHOD__
#  if defined(__HAVE_68881__)
#    define __FLT_EVAL_METHOD__ 2
#  elif defined(__HAVE_FPU__) /* coldfire, double == long double */
#    define __FLT_EVAL_METHOD__ 1
#  else
#    define __FLT_EVAL_METHOD__ 0
#  endif
#endif

#if defined __USE_ISOC99 && defined _MATH_H && !defined _MATH_H_MATHDEF
# define _MATH_H_MATHDEF	1

#if __FLT_EVAL_METHOD__ == 0

typedef float float_t;
typedef double double_t;

#elif __FLT_EVAL_METHOD__ == 1

typedef double float_t;
typedef double double_t;

#elif __FLT_EVAL_METHOD__ == 2

typedef long double float_t;	/* `float' expressions are evaluated as
				   `long double'.  */
typedef long double double_t;	/* `double' expressions are evaluated as
				   `long double'.  */
#endif

#endif	/* ISO C99 */

/* The values returned by `ilogb' for 0 and NaN respectively.  */
#define FP_ILOGB0	(-__INT_MAX__ - 1)
#define FP_ILOGBNAN	(__INT_MAX__)

```

`include/bits/nan.h`:

```h
/* `NAN' constant for IEEE 754 machines.
   Copyright (C) 1992, 1996, 1997, 1999 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

#ifndef _MATH_H
# error "Never use <bits/nan.h> directly; include <math.h> instead."
#endif


/* IEEE Not A Number.  */

#ifdef	__GNUC__

#if __GNUC_PREREQ(3,3)

# define NAN	(__builtin_nanf (""))

#else

# define NAN \
  (__extension__                                                            \
   ((union { unsigned __l __attribute__((__mode__(__SI__))); float __d; })  \
    { __l: 0x7fc00000UL }).__d)

#endif

#else

# include <endian.h>

# if __BYTE_ORDER == __BIG_ENDIAN
#  define __nan_bytes		{ 0x7f, 0xc0, 0, 0 }
# endif
# if __BYTE_ORDER == __LITTLE_ENDIAN
#  define __nan_bytes		{ 0, 0, 0xc0, 0x7f }
# endif

static union { unsigned char __c[4]; float __d; } const __nan_union = { __nan_bytes };
# define NAN	(__nan_union.__d)

#endif	/* GCC.  */

```

`include/bits/x86/fenv.h`:

```h
#ifndef _FENV_H
# error "Never use <bits/fenv.h> directly; include <fenv.h> instead."
#endif

/* Define bits representing the exception.  We use the bit positions
   of the appropriate bits in the FPU control word.  */
enum
  {
    FE_INVALID = 0x01,
    FE_DENORMAL = 0x02,
    FE_DIVBYZERO = 0x04,
    FE_OVERFLOW = 0x08,
    FE_UNDERFLOW = 0x10,
    FE_INEXACT = 0x20
  };

#define FE_INVALID	FE_INVALID
#define FE_DIVBYZERO	FE_DIVBYZERO
#define FE_OVERFLOW	FE_OVERFLOW
#define FE_UNDERFLOW	FE_UNDERFLOW
#define FE_INEXACT	FE_INEXACT
#define __FE_DENORM FE_DENORMAL

#define FE_ALL_EXCEPT (FE_INEXACT | FE_DIVBYZERO | FE_UNDERFLOW | FE_OVERFLOW | FE_INVALID)

/* rounding precision used by fegetprec() and fesetprec() */
#define FE_LDBLPREC 0x300 /* long double precision */
#define FE_FLTPREC  0x000 /* float precision */
#define FE_DBLPREC  0x200 /* double precision */
#define FE_PRECISION_MASK (FE_LDBLPREC|FE_FLTPREC|FE_DBLPREC)

/* The ix87 FPU supports all of the four defined rounding modes.  We
   use again the bit positions in the FPU control word as the values
   for the appropriate macros.  */
enum
  {
    FE_TONEAREST = 0,
    FE_DOWNWARD = 0x400,
    FE_UPWARD = 0x800,
    FE_TOWARDZERO = 0xc00
  };

#define FE_TONEAREST	FE_TONEAREST
#define FE_DOWNWARD	FE_DOWNWARD
#define FE_UPWARD	FE_UPWARD
#define FE_TOWARDZERO	FE_TOWARDZERO

/* Type representing exception flags.  */
typedef unsigned short int fexcept_t;


/* Type representing floating-point environment.  This structure
   corresponds to the layout of the block written by the `fstenv'
   instruction and has additional fields for the contents of the MXCSR
   register as written by the `stmxcsr' instruction.  */
typedef struct
  {
    unsigned short int __control_word;
    unsigned short int __unused1;
    unsigned short int __status_word;
    unsigned short int __unused2;
    unsigned short int __tags;
    unsigned short int __unused3;
    unsigned int __eip;
    unsigned short int __cs_selector;
    unsigned int __opcode:11;
    unsigned int __unused4:5;
    unsigned int __data_offset;
    unsigned short int __data_selector;
    unsigned short int __unused5;
#if defined(__x86_64__) || defined(_WIN32)
    unsigned int __mxcsr;
#endif
  }
fenv_t;

/* If the default argument is used we use this value.  */
#ifdef _WIN32
#define FE_DFL_ENV ((const fenv_t *) 0)
#else
#define FE_DFL_ENV	((__const fenv_t *) -1)
#endif

#ifdef __USE_GNU
/* Floating-point environment where none of the exception is masked.  */
# define FE_NOMASK_ENV	((__const fenv_t *) -2)
#endif

/* The default Intel x87 floating point environment (64-bit mantissa) */
#define FE_PC64_ENV ((const fenv_t *)-1)

/* The floating point environment set by MSVCRT _fpreset (53-bit mantissa) */
#define FE_PC53_ENV ((const fenv_t *)-2)

/* The MXCSR exception flags are the same as the
   FE flags. */
#define __MXCSR_EXCEPT_FLAG_SHIFT 0

/* How much to shift FE status word exception flags
   to get the MXCSR exeptions masks,  */
#define __MXCSR_EXCEPT_MASK_SHIFT 7

/* How much to shift FE control word rounding flags
   to get MXCSR rounding flags,  */
#define __MXCSR_ROUND_FLAG_SHIFT 3

```

`include/fdlibm.h`:

```h
/* @(#)fdlibm.h 1.5 04/04/22 */
/*
 * ====================================================
 * Copyright (C) 2004 by Sun Microsystems, Inc. All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice 
 * is preserved.
 * ====================================================
 */

#ifndef __FDLIBM_H__
#define __FDLIBM_H__

#ifndef _GNU_SOURCE
# define _GNU_SOURCE 1
#endif

#ifdef _LIBC
#include "lib.h"
#endif
#include <stdio.h>
#include <math.h>
#include <float.h>
#include <errno.h>
#include <stdint.h>
#include <limits.h>

#include <fenv.h>

#ifndef __BYTE_ORDER__
#  error "endianness not defined"
#endif

#ifndef __FLOAT_WORD_ORDER__
#define __FLOAT_WORD_ORDER__ __BYTE_ORDER__
#endif

#define IEEE754_FLOAT_MAXEXP	0xff
#define IEEE754_FLOAT_BIAS	0x7f /* Added to exponent.  */
#define IEEE754_FLOAT_SHIFT 23

#define IEEE754_DOUBLE_MAXEXP	0x7ff
#define IEEE754_DOUBLE_BIAS	0x3ff /* Added to exponent.  */
#define IEEE754_DOUBLE_SHIFT 20

#define IEEE854_LONG_DOUBLE_MAXEXP	0x7fff
#define IEEE854_LONG_DOUBLE_BIAS 0x3fff
#define IEEE854_LONG_DOUBLE_SHIFT 0

/* A union which permits us to convert between a double and two 32 bit
   ints.  */

#if __FLOAT_WORD_ORDER__ == __ORDER_BIG_ENDIAN__

typedef union
{
  double value;
  struct
  {
    uint32_t msw;
    uint32_t lsw;
  } parts;
} ieee_double_shape_type;

typedef union
{
  long double value;
  struct
  {
    int16_t sign_exponent;
#if !defined(__PUREC__) || defined(__MATH_68881__)
    uint16_t empty;
#define SET_LDOUBLE_EMPTY(u) (u).parts.empty = 0
#endif
    uint32_t msw;
    uint32_t lsw;
  } parts;
} ieee_long_double_shape_type;

#endif

#if __FLOAT_WORD_ORDER__ == __ORDER_LITTLE_ENDIAN__

typedef union
{
  double value;
  struct
  {
    uint32_t lsw;
    uint32_t msw;
  } parts;
} ieee_double_shape_type;

typedef union
{
  long double value;
  struct
  {
    uint32_t lsw;
    uint32_t msw;
    int sign_exponent:16;
    unsigned int empty:16;
#define SET_LDOUBLE_EMPTY(u) (u).parts.empty = 0
  } parts;
} ieee_long_double_shape_type;

#endif

#ifndef SET_LDOUBLE_EMPTY
#define SET_LDOUBLE_EMPTY(u)
#endif

/* A union which permits us to convert between a float and a 32 bit
   int.  */

typedef union
{
  float value;
  uint32_t word;
} ieee_float_shape_type;


/* Get two 32 bit ints from a double.  */

#define GET_DOUBLE_WORDS(ix0,ix1,d)				\
{								\
  const ieee_double_shape_type *ew_u = (const ieee_double_shape_type *)&(d);					\
  (ix0) = ew_u->parts.msw;					\
  (ix1) = ew_u->parts.lsw;					\
}

/* Get the more significant 32 bit int from a double.  */

#define GET_HIGH_WORD(i,d)					\
{								\
  const ieee_double_shape_type *gh_u = (const ieee_double_shape_type *)&(d);					\
  (i) = gh_u->parts.msw;						\
}

/* Get the less significant 32 bit int from a double.  */

#define GET_LOW_WORD(i,d)					\
{								\
  const ieee_double_shape_type *gl_u = (const ieee_double_shape_type *)&(d);					\
  (i) = gl_u->parts.lsw;						\
}

/* Set a double from two 32 bit ints.  */

#define INSERT_WORDS(d,ix0,ix1)                                 \
do {                                                            \
  ieee_double_shape_type *iw_u = (ieee_double_shape_type *)&(d);\
  iw_u->parts.msw = (ix0);                                      \
  iw_u->parts.lsw = (ix1);                                      \
} while (0)

/* Set the more significant 32 bits of a double from an int.  */

#define SET_HIGH_WORD(d,v)                                      \
{                                                               \
  ieee_double_shape_type *sh_u = (ieee_double_shape_type *)&(d);\
  sh_u->parts.msw = (v);                                        \
}

/* Set the less significant 32 bits of a double from an int.  */

#define SET_LOW_WORD(d,v)                                       \
{                                                               \
  ieee_double_shape_type *sl_u = (ieee_double_shape_type *)&(d);\
  sl_u->parts.lsw = (v);                                        \
}

/* Get a 32 bit int from a float.  */

#define GET_FLOAT_WORD(i,d)					\
{								\
  const ieee_float_shape_type *gf_u = (const ieee_float_shape_type *)&(d);					\
  (i) = gf_u->word;						\
}

/* Set a float from a 32 bit int.  */

#define SET_FLOAT_WORD(d,i)					\
{								\
  ieee_float_shape_type *sf_u = (ieee_float_shape_type *)&(d);					\
  sf_u->word = (i);						\
}

#if __GNUC__ <= 4 /* work around an internal compiler error */

/* Get three 32 bit ints from a long double.  */

#define GET_LDOUBLE_WORDS(exp,ix0,ix1,d)			\
do {								\
  ieee_long_double_shape_type ew_u;				\
  ew_u.value = (d);						\
  (exp) = ew_u.parts.sign_exponent;				\
  (ix0) = ew_u.parts.msw;					\
  (ix1) = ew_u.parts.lsw;					\
} while (0)

/* Set a long double from two 32 bit ints.  */

#define SET_LDOUBLE_WORDS(d,exp,ix0,ix1)			\
do {								\
  ieee_long_double_shape_type iw_u;				\
  iw_u.parts.sign_exponent = (exp);				\
  SET_LDOUBLE_EMPTY(iw_u); \
  iw_u.parts.msw = (ix0);					\
  iw_u.parts.lsw = (ix1);					\
  (d) = iw_u.value;						\
} while (0)

/* Get the more significant 32 bits of a long double mantissa.  */

#define GET_LDOUBLE_MSW(v,d)					\
do {								\
  ieee_long_double_shape_type sh_u;				\
  sh_u.value = (d);						\
  (v) = sh_u.parts.msw;						\
} while (0)

/* Get the less significant 32 bits of a long double mantissa.  */

#define GET_LDOUBLE_LSW(v,d)					\
do {								\
  ieee_long_double_shape_type sh_u;				\
  sh_u.value = (d);						\
  (v) = sh_u.parts.lsw;						\
} while (0)

/* Set the more significant 32 bits of a long double mantissa from an int.  */

#define SET_LDOUBLE_MSW(d,v)					\
do {								\
  ieee_long_double_shape_type sh_u;				\
  sh_u.value = (d);						\
  sh_u.parts.msw = (v);						\
  (d) = sh_u.value;						\
} while (0)

/* Set the less significant 32 bits of a long double mantissa from an int.  */

#define SET_LDOUBLE_LSW(d,v)					\
do {								\
  ieee_long_double_shape_type sh_u;				\
  sh_u.value = (d);						\
  sh_u.parts.lsw = (v);						\
  (d) = sh_u.value;						\
} while (0)

/* Get int from the exponent of a long double.  */

#define GET_LDOUBLE_EXP(exp,d)					\
do {								\
  ieee_long_double_shape_type ge_u;				\
  ge_u.value = (d);						\
  (exp) = ge_u.parts.sign_exponent;				\
} while (0)

/* Set exponent of a long double from an int.  */

#define SET_LDOUBLE_EXP(d,exp)					\
do {								\
  ieee_long_double_shape_type se_u;				\
  se_u.value = (d);						\
  se_u.parts.sign_exponent = (exp);				\
  (d) = se_u.value;						\
} while (0)

#else

/* Get three 32 bit ints from a long double.  */

#define GET_LDOUBLE_WORDS(exp,ix0,ix1,d)			\
do {								\
  const ieee_long_double_shape_type *ew_u = (const ieee_long_double_shape_type *)&(d);				\
  (exp) = ew_u->parts.sign_exponent;				\
  (ix0) = ew_u->parts.msw;					\
  (ix1) = ew_u->parts.lsw;					\
} while (0)

/* Set a long double from two 32 bit ints.  */

#define SET_LDOUBLE_WORDS(d,exp,ix0,ix1)			\
do {								\
  ieee_long_double_shape_type *iw_u = (ieee_long_double_shape_type *)&(d);				\
  iw_u->parts.sign_exponent = (exp);				\
  SET_LDOUBLE_EMPTY(*iw_u); \
  iw_u->parts.msw = (ix0);					\
  iw_u->parts.lsw = (ix1);					\
} while (0)

/* Get the more significant 32 bits of a long double mantissa.  */

#define GET_LDOUBLE_MSW(v,d)					\
do {								\
  const ieee_long_double_shape_type *sh_u = (const ieee_long_double_shape_type *)&(d);				\
  (v) = sh_u->parts.msw;						\
} while (0)

/* Get the less significant 32 bits of a long double mantissa.  */

#define GET_LDOUBLE_LSW(v,d)					\
do {								\
  const ieee_long_double_shape_type *sh_u = (const ieee_long_double_shape_type *)&(d);				\
  (v) = sh_u->parts.lsw;						\
} while (0)

/* Set the more significant 32 bits of a long double mantissa from an int.  */

#define SET_LDOUBLE_MSW(d,v)					\
do {								\
  ieee_long_double_shape_type *sh_u = (ieee_long_double_shape_type *)&(d);				\
  sh_u->parts.msw = (v);						\
} while (0)

/* Set the less significant 32 bits of a long double mantissa from an int.  */

#define SET_LDOUBLE_LSW(d,v)					\
do {								\
  ieee_long_double_shape_type *sh_u = (ieee_long_double_shape_type *)&(d);				\
  sh_u->parts.lsw = (v);						\
} while (0)

/* Get int from the exponent of a long double.  */

#define GET_LDOUBLE_EXP(exp,d)					\
do {								\
  const ieee_long_double_shape_type *ge_u = (const ieee_long_double_shape_type *)&(d);				\
  (exp) = ge_u->parts.sign_exponent;				\
} while (0)

/* Set exponent of a long double from an int.  */

#define SET_LDOUBLE_EXP(d,exp)					\
do {								\
  ieee_long_double_shape_type *se_u = (ieee_long_double_shape_type *)&(d);				\
  se_u->parts.sign_exponent = (exp);				\
} while (0)

#endif

#if INT_MAX > 32767
#  define IC(x) ((int32_t) x)
#  define UC(x) ((uint32_t) x)
#else
#  define IC(x) ((int32_t) x##L)
#  define UC(x) ((uint32_t) x##UL)
#endif

/*
 * ANSI/POSIX
 */

extern int *__signgam (void);
#undef signgam
extern int signgam;

#undef MAXFLOAT
#define	MAXFLOAT	((float)3.40282346638528860e+38)

#ifndef _LIB_VERSION
/*
 * define and initialize _LIB_VERSION
 */
#if defined(_POSIX_MODE)
#define _LIB_VERSION _POSIX_
#elif defined(_XOPEN_MODE)
#define _LIB_VERSION _XOPEN_
#elif defined(_SVID3_MODE)
#define _LIB_VERSION _SVID_
#else
#define _LIB_VERSION _IEEE_
#endif

#endif

#if !defined(_MATH_H) && !defined(_MATH_H_)
#ifdef __cplusplus
struct __exception
#else
struct exception
#endif
{
	int			type;	/* exception type */
	const char	*name;	/* function in which it occured */
	double		arg1;	/* an arg */
	double		arg2;	/* another arg */
	double		retval; /* val to return */
};
#endif

#undef HUGE
#define	HUGE		MAXFLOAT

#include "k_stand.h"

/* All floating-point numbers can be put in one of these categories.  */
#ifndef FP_NAN
enum
{
  FP_NAN,
# define FP_NAN FP_NAN
  FP_INFINITE,
# define FP_INFINITE FP_INFINITE
  FP_ZERO,
# define FP_ZERO FP_ZERO
  FP_SUBNORMAL,
# define FP_SUBNORMAL FP_SUBNORMAL
  FP_NORMAL
# define FP_NORMAL FP_NORMAL
};
#endif

/*
 * set X_TLOSS = pi*2**52, which is possibly defined in <values.h>
 * (one may replace the following line by "#include <values.h>")
 */
#undef X_TLOSS
#define X_TLOSS	1.41484755040568800000e+16


/* Most routines need to check whether a float is finite, infinite, or not a
   number, and many need to know whether the result of an operation will
   overflow.  These conditions depend on whether the largest exponent is
   used for NaNs & infinities, or whether it's used for finite numbers.  The
   macros below wrap up that kind of information:

   FLT_UWORD_IS_FINITE(X)
	True if a positive float with bitmask X is finite.

   FLT_UWORD_IS_NAN(X)
	True if a positive float with bitmask X is not a number.

   FLT_UWORD_IS_INFINITE(X)
	True if a positive float with bitmask X is +infinity.

   FLT_UWORD_MAX
	The bitmask of FLT_MAX.

   FLT_UWORD_HALF_MAX
	The bitmask of FLT_MAX/2.

   FLT_UWORD_EXP_MAX
	The bitmask of the largest finite exponent (129 if the largest
	exponent is used for finite numbers, 128 otherwise).

   FLT_UWORD_LOG_MAX
	The bitmask of log(FLT_MAX), rounded down.  This value is the largest
	input that can be passed to exp() without producing overflow.

   FLT_UWORD_LOG_2MAX
	The bitmask of log(2*FLT_MAX), rounded down.  This value is the
	largest input than can be passed to cosh() without producing
	overflow.

   FLT_LARGEST_EXP
	The largest biased exponent that can be used for finite numbers
	(255 if the largest exponent is used for finite numbers, 254
	otherwise) */

#ifdef _FLT_LARGEST_EXPONENT_IS_NORMAL
#define FLT_UWORD_IS_FINITE(x) 1
#define FLT_UWORD_IS_NAN(x) 0
#define FLT_UWORD_IS_INFINITE(x) 0
#define FLT_UWORD_MAX IC(0x7fffffff)
#define FLT_UWORD_HALF_MAX IC(0x7f7fffff)
#define FLT_UWORD_EXP_MAX IC(0x43010000)
#define FLT_UWORD_LOG_MAX IC(0x42b2d4fc)
#define FLT_UWORD_LOG_2MAX IC(0x42b437e0)
/* #define HUGE ((float)0X1.FFFFFEP128) */
#else
#define FLT_UWORD_IS_FINITE(x) ((x) < IC(0x7f800000))
#define FLT_UWORD_IS_NAN(x) ((x) > IC(0x7f800000))
#define FLT_UWORD_IS_INFINITE(x) ((x) == IC(0x7f800000))
#define FLT_UWORD_MAX IC(0x7f7fffff)
#define FLT_UWORD_HALF_MAX IC(0x7effffff)
#define FLT_UWORD_EXP_MAX IC(0x43000000)
#define FLT_UWORD_LOG_MAX IC(0x42b17217)
#define FLT_UWORD_LOG_2MAX IC(0x42b2d4fc)
/* #define HUGE ((float)3.40282346638528860e+38) */
#endif
#define FLT_LARGEST_EXP (FLT_UWORD_MAX>>23)

/* Many routines check for zero and subnormal numbers.  Such things depend
   on whether the target supports denormals or not:

   FLT_UWORD_IS_ZERO(X)
	True if a positive float with bitmask X is +0.	Without denormals,
	any float with a zero exponent is a +0 representation.	With
	denormals, the only +0 representation is a 0 bitmask.

   FLT_UWORD_IS_SUBNORMAL(X)
	True if a non-zero positive float with bitmask X is subnormal.
	(Routines should check for zeros first.)

   FLT_UWORD_MIN
	The bitmask of the smallest float above +0.  Call this number
	REAL_FLT_MIN...

   FLT_UWORD_EXP_MIN
	The bitmask of the float representation of REAL_FLT_MIN's exponent.

   FLT_UWORD_LOG_MIN
	The bitmask of |log(REAL_FLT_MIN)|, rounding down.

   FLT_SMALLEST_EXP
	REAL_FLT_MIN's exponent - EXP_BIAS (1 if denormals are not supported,
	-22 if they are).
*/

#ifdef _FLT_NO_DENORMALS
#define FLT_UWORD_IS_ZERO(x) ((x) < IC(0x00800000))
#define FLT_UWORD_IS_SUBNORMAL(x) 0
#define FLT_UWORD_MIN IC(0x00800000)
#define FLT_UWORD_EXP_MIN IC(0x42fc0000)
#define FLT_UWORD_LOG_MIN IC(0x42aeac50)
#define FLT_SMALLEST_EXP 1
#else
#define FLT_UWORD_IS_ZERO(x) ((x) == 0)
#define FLT_UWORD_IS_SUBNORMAL(x) ((x) < IC(0x00800000))
#define FLT_UWORD_MIN IC(0x00000001)
#define FLT_UWORD_EXP_MIN IC(0x43160000)
#define FLT_UWORD_LOG_MIN IC(0x42cff1b5)
#define FLT_SMALLEST_EXP -22
#endif


#ifndef DOMAIN
# define	DOMAIN		1
# define	SING		2
# define	OVERFLOW	3
# define	UNDERFLOW	4
# define	TLOSS		5
# define	PLOSS		6
#endif

#if defined(__GNUC__) && defined (__mc68020__) && !defined (__mcpu32__)
static __inline__ int32_t count_leading_zeros(uint32_t x)
{
	int32_t count;
	__asm__ ("bfffo %1{%b2:%b2},%0"
		: "=d" (count)
		: "od" (x), "n" (0));
	if (count == 32) count = 0;
	return count;
}
#elif defined(__GNUC__)
static __inline__ int32_t count_leading_zeros(uint32_t x)
{
	return __builtin_clz(x);
}
#else
static int32_t count_leading_zeros(uint32_t x)
{
	uint32_t __xr = (x);
    uint32_t __a, count;

static unsigned char const __clz_tab[256] =
{
  0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
  8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
  8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
  8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
  8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8
};

	__a = __xr < ((uint32_t)1<<16)
	  ? (__xr < ((uint32_t)8) ? 0 : 8)
	  : (__xr < ((uint32_t)1<<24) ? 16 : 24);
	count = 32 - (__clz_tab[__xr >> __a] + __a);
	if (count == 32) count = 0;
	return count;
}
#endif

#undef isinf
#undef isnan
#undef signbit
#undef isfinite
#undef issignaling
#undef isnormal

/*
 * ANSI/POSIX
 */
extern double acos (double);
extern double asin (double);
extern double atan (double);
extern double atan2 (double, double);
extern double cos (double);
extern double sin (double);
extern double tan (double);

extern double cosh (double);
extern double sinh (double);
extern double tanh (double);

extern double exp (double);
extern double frexp (double, int *);
extern double ldexp (double, int);
extern double log (double);
extern double log10 (double);
extern double modf (double, double *);

extern double pow (double, double);
extern double sqrt (double);

extern double ceil (double);
extern double fabs (double);
extern double floor (double);
extern double fmod (double, double);

extern double erf (double);
extern double erfc (double);
extern double gamma (double);
extern double hypot (double, double);
extern int isnan (double);
extern int finite (double);
extern double j0 (double);
extern double j1 (double);
extern double jn (int, double);
extern double lgamma (double);
extern double y0 (double);
extern double y1 (double);
extern double yn (int, double);

extern double acosh (double);
extern double asinh (double);
extern double atanh (double);
extern double cbrt (double);
extern double logb (double);
extern double nextafter (double, double);
extern double remainder (double, double);
#ifdef __mc68000__
#undef _SCALB_INT
#else
#undef _SCALB_INT
#endif
#ifdef _SCALB_INT
extern double scalb (double, int);
#else
extern double scalb (double, double);
#endif

extern int matherr (struct exception *);

# ifdef __NO_LONG_DOUBLE_MATH
#  define isnan(x) \
     (sizeof (x) == sizeof (float) ? __isnanf (x) : __isnan (x))
# else
#  define isnan(x) \
     (sizeof (x) == sizeof (float)					      \
      ? __isnanf (x)							      \
      : sizeof (x) == sizeof (double)					      \
      ? __isnan (x) : __isnanl (x))
# endif

/* Return nonzero value if X is positive or negative infinity.  */
# ifdef __NO_LONG_DOUBLE_MATH
#  define isinf(x) \
     (sizeof (x) == sizeof (float) ? __isinff (x) : __isinf (x))
# else
#  define isinf(x) \
     (sizeof (x) == sizeof (float)					      \
      ? __isinff (x)							      \
      : sizeof (x) == sizeof (double)					      \
      ? __isinf (x) : __isinfl (x))
# endif

/* Return nonzero value if sign of X is negative.  */
# ifdef __NO_LONG_DOUBLE_MATH
#  define signbit(x) \
     (sizeof (x) == sizeof (float) ? __signbitf (x) : __signbit (x))
# else
#  define signbit(x) \
     (sizeof (x) == sizeof (float)					      \
      ? __signbitf (x)							      \
      : sizeof (x) == sizeof (double)					      \
      ? __signbit (x) : __signbitl (x))
# endif

/* Return nonzero value if X is not +-Inf or NaN.  */
# ifdef __NO_LONG_DOUBLE_MATH
#  define isfinite(x) \
     (sizeof (x) == sizeof (float) ? __finitef (x) : __finite (x))
# else
#  define isfinite(x) \
     (sizeof (x) == sizeof (float)					      \
      ? __finitef (x)							      \
      : sizeof (x) == sizeof (double)					      \
      ? __finite (x) : __finitel (x))
# endif

/* Return nonzero value if X is neither zero, subnormal, Inf, nor NaN.  */
# define isnormal(x) (fpclassify (x) == FP_NORMAL)

# ifdef __NO_LONG_DOUBLE_MATH
#  define issignaling(x) \
     (sizeof (x) == sizeof (float) ? __issignalingf (x) : __issignaling (x))
# else
#  define issignaling(x) \
     (sizeof (x) == sizeof (float)					      \
      ? __issignalingf (x)						      \
      : sizeof (x) == sizeof (double)					      \
      ? __issignaling (x) : __issignalingl (x))
# endif

/*
 * IEEE Test Vector
 */
extern double significand (double);

/*
 * Functions callable from C, intended to support IEEE arithmetic.
 */
extern double copysign (double, double);
extern int ilogb (double);
extern double rint (double);
extern double scalbn (double, int);

/*
 * BSD math library entry points
 */
extern double expm1 (double);
extern double log1p (double);

/*
 * Reentrant version of gamma & lgamma; passes signgam back by reference
 * as the second argument; user must allocate space for signgam.
 */
#ifdef _REENTRANT
extern double gamma_r (double, int *);
extern double lgamma_r (double, int *);
#endif	/* _REENTRANT */

#undef __MATH_INLINE
#define __MATH_INLINE static __inline

#if defined(__GNUC__) && defined(__mcoldfire__)
# include "asm/ieee754/m68k_cf.h"
#elif defined(__GNUC__) && defined(__mc68000__)
# include "asm/ieee754/m68k.h"
#elif defined(__AHCC__)
# include "asm/ieee754/m68k_ahcc.h"
#elif defined(__PUREC__)
# include "asm/ieee754/m68k_pc.h"
#elif defined(__GNUC__) && defined(__i386__)
# include "asm/ieee754/i386.h"
#elif defined(__GNUC__) && defined(__x86_64__)
# include "asm/ieee754/x86_64.h"
#endif

/* ieee style elementary functions */
#ifndef __have_fpu_sin
double      __ieee754_sin (double x);
float       __ieee754_sinf (float x);
long double __ieee754_sinl (long double x);
#endif
#ifndef __have_fpu_cos
double      __ieee754_cos (double x);
float       __ieee754_cosf (float x);
long double __ieee754_cosl (long double x);
#endif
#ifndef __have_fpu_sincos
void        __ieee754_sincos (double __x, double *__sin, double *__cos);
void        __ieee754_sincosf (float __x, float *__sin, float *__cos);
void        __ieee754_sincosl (long double __x, long double *__sin, long double *__cos);
#endif
#ifndef __have_fpu_tan
double      __ieee754_tan (double x);
float       __ieee754_tanf (float x);
long double __ieee754_tanl (long double x);
#endif
#ifndef __have_fpu_asin
double      __ieee754_asin (double x);
float       __ieee754_asinf (float x);
long double __ieee754_asinl (long double x);
#endif
#ifndef __have_fpu_acos
double      __ieee754_acos (double x);
float       __ieee754_acosf (float x);
long double __ieee754_acosl (long double x);
#endif
#ifndef __have_fpu_atan
double      __ieee754_atan (double x);
float       __ieee754_atanf (float x);
long double __ieee754_atanl (long double x);
#endif
#ifndef __have_fpu_atan2
double      __ieee754_atan2 (double y, double x);
float       __ieee754_atan2f (float y, float x);
long double __ieee754_atan2l (long double y, long double x);
#endif
#ifndef __have_fpu_sinh
double      __ieee754_sinh (double x);
float       __ieee754_sinhf (float x);
long double __ieee754_sinhl (long double x);
#endif
#ifndef __have_fpu_cosh
double      __ieee754_cosh (double x);
float       __ieee754_coshf (float x);
long double __ieee754_coshl (long double x);
#endif
#ifndef __have_fpu_tanh
double      __ieee754_tanh (double x);
float       __ieee754_tanhf (float x);
long double __ieee754_tanhl (long double x);
#endif
#ifndef __have_fpu_acosh
double      __ieee754_acosh(double x);
float       __ieee754_acoshf(float x);
long double __ieee754_acoshl(long double x);
#endif
#ifndef __have_fpu_asinh
double      __ieee754_asinh(double x);
float       __ieee754_asinhf(float x);
long double __ieee754_asinhl(long double x);
#endif
#ifndef __have_fpu_atanh
double      __ieee754_atanh (double x);
float       __ieee754_atanhf (float x);
long double __ieee754_atanhl (long double x);
#endif
#ifndef __have_fpu_exp
double      __ieee754_exp (double x);
float       __ieee754_expf (float x);
long double __ieee754_expl (long double x);
#endif
#ifndef __have_fpu_expm1
double      __ieee754_expm1 (double x);
float       __ieee754_expm1f (float x);
long double __ieee754_expm1l (long double x);
#endif
#ifndef __have_fpu_exp2
double      __ieee754_exp2 (double x);
float       __ieee754_exp2f (float x);
long double __ieee754_exp2l (long double x);
#endif
#ifndef __have_fpu_pow2
double      __ieee754_pow2 (double x);
float       __ieee754_pow2f (float x);
long double __ieee754_pow2l (long double x);
#endif
#ifndef __have_fpu_exp10
double      __ieee754_exp10 (double x);
float       __ieee754_exp10f (float x);
long double __ieee754_exp10l (long double x);
#endif
#ifndef __have_fpu_pow10
double      __ieee754_pow10 (double x);
float       __ieee754_pow10f (float x);
long double __ieee754_pow10l (long double x);
#endif
#ifndef __have_fpu_log
double      __ieee754_log (double x);
float       __ieee754_logf (float x);
long double __ieee754_logl (long double x);
#endif
#ifndef __have_fpu_log1p
double      __ieee754_log1p (double x);
float       __ieee754_log1pf (float x);
long double __ieee754_log1pl (long double x);
#endif
#ifndef __have_fpu_log10
double      __ieee754_log10 (double x);
float       __ieee754_log10f (float x);
long double __ieee754_log10l (long double x);
#endif
#ifndef __have_fpu_log2
double      __ieee754_log2 (double x);
float       __ieee754_log2f (float x);
long double __ieee754_log2l (long double x);
#endif
#ifndef __have_fpu_sqrt
double      __ieee754_sqrt (double x);
float       __ieee754_sqrtf (float x);
long double __ieee754_sqrtl (long double x);
#endif
#ifndef __have_fpu_hypot
double      __ieee754_hypot (double x, double y);
float       __ieee754_hypotf (float x, float y);
long double __ieee754_hypotl (long double x, long double y);
#endif
#ifndef __have_fpu_pow
double      __ieee754_pow (double x, double y);
float       __ieee754_powf (float x, float y);
long double __ieee754_powl (long double x, long double y);
#endif
double      __ieee754_powi (double x, int y);
float       __ieee754_powif (float x, int y);
long double __ieee754_powil (long double x, int y);
#ifndef __have_fpu_fabs
double      __ieee754_fabs (double x);
float       __ieee754_fabsf (float x);
long double __ieee754_fabsl (long double x);
#endif
#ifndef __have_fpu_ceil
double      __ieee754_ceil (double x);
float       __ieee754_ceilf (float x);
long double __ieee754_ceill (long double x);
#endif
#ifndef __have_fpu_floor
double      __ieee754_floor (double x);
float       __ieee754_floorf (float x);
long double __ieee754_floorl (long double x);
#endif
#ifndef __have_fpu_trunc
double      __ieee754_trunc (double x);
float       __ieee754_truncf (float x);
long double __ieee754_truncl (long double x);
#endif
#ifndef __have_fpu_rint
double      __ieee754_rint (double x);
float       __ieee754_rintf (float x);
long double __ieee754_rintl (long double x);
#endif
#ifndef __have_fpu_lrint
long int    __ieee754_lrint(double x);
long int    __ieee754_lrintf(float x);
long int    __ieee754_lrintl(long double x);
#endif
#ifndef __have_fpu_llrint
#ifndef __NO_LONGLONG
long long int    __ieee754_llrint(double x);
long long int    __ieee754_llrintf(float x);
long long int    __ieee754_llrintl(long double x);
#endif
#endif
#ifndef __have_fpu_round
double      __ieee754_round (double x);
float       __ieee754_roundf (float x);
long double __ieee754_roundl (long double x);
#endif
#ifndef __have_fpu_lround
long int    __ieee754_lround (double x);
long int    __ieee754_lroundf (float x);
long int    __ieee754_lroundl (long double x);
#endif
#ifndef __have_fpu_llround
#ifndef __NO_LONGLONG
long long int    __ieee754_llround (double x);
long long int    __ieee754_llroundf (float x);
long long int    __ieee754_llroundl (long double x);
#endif
#endif
#ifndef __have_fpu_fmod
double      __ieee754_fmod (double x, double y);
float       __ieee754_fmodf (float x, float y);
long double __ieee754_fmodl (long double x, long double y);
#endif
#ifndef __have_fpu_drem
double      __ieee754_drem (double x, double y);
float       __ieee754_dremf (float x, float y);
long double __ieee754_dreml (long double x, long double y);
#endif
#ifndef __have_fpu_remainder
double      __ieee754_remainder (double x, double y);
float       __ieee754_remainderf (float x, float y);
long double __ieee754_remainderl (long double x, long double y);
#endif
#ifndef __have_fpu_remquo
double      __ieee754_remquo (double x, double y, int *quo);
float       __ieee754_remquof (float x, float y, int *quo);
long double __ieee754_remquol (long double x, long double y, int *quo);
#endif
#ifndef __have_fpu_scalb
#ifdef _SCALB_INT
double      __ieee754_scalb (double x, int n);
float       __ieee754_scalbf (float x, int n);
long double __ieee754_scalbl (long double x, int n);
#else
double      __ieee754_scalb (double x, double n);
float       __ieee754_scalbf (float x, float n);
long double __ieee754_scalbl (long double x, long double n);
#endif
#endif
#ifndef __have_fpu_scalbn
double      __ieee754_scalbn (double x, int n);
float       __ieee754_scalbnf (float x, int n);
long double __ieee754_scalbnl (long double x, int n);
#endif
#ifndef __have_fpu_scalbln
double      __ieee754_scalbln (double x, long n);
float       __ieee754_scalblnf (float x, long n);
long double __ieee754_scalblnl (long double x, long n);
#endif
#ifndef __have_fpu_logb
double      __ieee754_logb (double x);
float       __ieee754_logbf (float x);
long double __ieee754_logbl (long double x);
#endif
#ifndef __have_fpu_ilogb
int __ieee754_ilogb (double x);
int __ieee754_ilogbf (float x);
int __ieee754_ilogbl (long double x);
#endif
#ifndef __have_fpu_ldexp
double      __ieee754_ldexp (double x, int n);
float       __ieee754_ldexpf (float x, int n);
long double __ieee754_ldexpl (long double x, int n);
#endif
#ifndef __have_fpu_frexp
double      __ieee754_frexp (double x, int *exp);
float       __ieee754_frexpf (float x, int *exp);
long double __ieee754_frexpl (long double x, int *exp);
#endif
#ifndef __have_fpu_significand
double      __ieee754_significand(double x);
float       __ieee754_significandf(float x);
long double __ieee754_significandl(long double x);
#endif
#ifndef __have_fpu_modf
double      __ieee754_modf (double x, double *ip);
float       __ieee754_modff (float x, float *ip);
long double __ieee754_modfl (long double x, long double *ip);
#endif

double      __ieee754_lgamma_r(double x, int *sign);
float       __ieee754_lgammaf_r(float x, int *sign);
long double __ieee754_lgammal_r(long double x, int *sign);
double      __ieee754_tgamma_r(double x, int *sign);
float       __ieee754_tgammaf_r(float x, int *sign);
long double __ieee754_tgammal_r(long double x, int *sign);

double __ieee754_j0(double x);
float __ieee754_j0f(float x);
long double __ieee754_j0l(long double x);
double __ieee754_y0(double x);
float __ieee754_y0f(float x);
long double __ieee754_y0l(long double x);

double __ieee754_j1(double x);
float __ieee754_j1f(float x);
long double __ieee754_j1l(long double x);
double __ieee754_y1(double x);
float __ieee754_y1f(float x);
long double __ieee754_y1l(long double x);

double __ieee754_jn(int n, double x);
float __ieee754_jnf(int n, float x);
long double __ieee754_jnl(int n, long double x);
double __ieee754_yn(int n, double x);
float __ieee754_ynf(int n, float x);
long double __ieee754_ynl(int n, long double x);

#ifndef math_opt_barrier
# define math_opt_barrier(x) \
  ({ __typeof (x) __x = (x); __asm ("" : "+m" (__x)); __x; })
# define math_force_eval(x) \
  ({ __typeof (x) __x = (x); __asm __volatile__ ("" : : "m" (__x)); })
#endif

#ifndef __have_fpu_fabs
#define __ieee754_fabs(x) fabs(x)
#define __ieee754_fabsf(x) fabsf(x)
#define __ieee754_fabsl(x) fabsl(x)
#endif

#ifndef FP_ILOGB0
/* The values returned by `ilogb' for 0 and NaN respectively.  */
# define FP_ILOGB0	(-INT_MAX - 1)
# define FP_ILOGBNAN	(INT_MAX)
#endif

#define SAVE_AND_SET_ROUND(RM) \
  int __round, __oldround; \
  __round = (RM); \
  __oldround = fegetround(); \
  if (__round != __oldround) \
  { \
  	 fesetround(__round); \
  }
#define RESTORE_ROUND() \
  if (__round != __oldround) fesetround(__oldround)

/* fdlibm kernel function */
double __kernel_sin(double x, double y, int iy);
float __kernel_sinf(float x, float y, int iy);
long double __kernel_sinl(long double x, long double y, int iy);

double __kernel_cos(double x, double y);
float __kernel_cosf(float x, float y);
long double __kernel_cosl(long double x, long double y);

double __kernel_tan(double x, double y, int iy);
float __kernel_tanf(float x, float y, int iy);
long double __kernel_tanl(long double x, long double y, int iy);

int32_t __ieee754_rem_pio2(double x, double *y);
int32_t __ieee754_rem_pio2f(float x, float *y);
int32_t __ieee754_rem_pio2l(long double x, long double *y);

int32_t __kernel_rem_pio2(double *x, double *y, int32_t e0, int32_t nx, int prec);
int32_t __kernel_rem_pio2f(float *x, float *y, int32_t e0, int32_t nx, int prec);
int32_t __kernel_rem_pio2l(double *x, double *y, int32_t e0, int32_t nx, int prec);

double __j0_y0_pzero(double);
double __j0_y0_qzero(double);
float __j0_y0_pzerof(float);
float __j0_y0_qzerof(float);
long double __j0_y0_pzerol(long double);
long double __j0_y0_qzerol(long double);

double __j1_y1_pone(double);
double __j1_y1_qone(double);
float __j1_y1_ponef(float);
float __j1_y1_qonef(float);
long double __j1_y1_ponel(long double);
long double __j1_y1_qonel(long double);

double __x2y2m1(double x, double y);
float __x2y2m1f(float x, float y);
long double __x2y2m1l(long double x, long double y);

extern const long double __sincosl_table[];

/* NYI */
#define feraiseexcept(x)

#endif /* __FDLIBM_H__ */

```

`include/fenv.h`:

```h
/* Copyright (C) 1997-2013 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * ISO C99 7.6: Floating-point environment	<fenv.h>
 */

#ifndef _FENV_H
#define _FENV_H	1

#ifndef _FEATURES_H
#include <features.h>
#endif

/* Get the architecture dependend definitions.  The following definitions
   are expected to be done:

   fenv_t	type for object representing an entire floating-point
		environment

   FE_DFL_ENV	macro of type pointer to fenv_t to be used as the argument
		to functions taking an argument of type fenv_t; in this
		case the default environment will be used

   fexcept_t	type for object representing the floating-point exception
		flags including status associated with the flags

   The following macros are defined iff the implementation supports this
   kind of exception.
   FE_INEXACT		inexact result
   FE_DIVBYZERO		division by zero
   FE_UNDERFLOW		result not representable due to underflow
   FE_OVERFLOW		result not representable due to overflow
   FE_INVALID		invalid operation

   FE_ALL_EXCEPT	bitwise OR of all supported exceptions

   The next macros are defined iff the appropriate rounding mode is
   supported by the implementation.
   FE_TONEAREST		round to nearest
   FE_UPWARD		round toward +Inf
   FE_DOWNWARD		round toward -Inf
   FE_TOWARDZERO	round toward 0
*/
#include <bits/fenv.h>

__BEGIN_DECLS

/* Floating-point exception handling.  */

/* Clear the supported exceptions represented by EXCEPTS.  */
extern int feclearexcept (int __excepts) __THROW;

/* Store implementation-defined representation of the exception flags
   indicated by EXCEPTS in the object pointed to by FLAGP.  */
extern int fegetexceptflag (fexcept_t *__flagp, int __excepts) __THROW;

/* Raise the supported exceptions represented by EXCEPTS.  */
extern int feraiseexcept (int __excepts) __THROW;

/* Set complete status for exceptions indicated by EXCEPTS according to
   the representation in the object pointed to by FLAGP.  */
extern int fesetexceptflag (const fexcept_t *__flagp, int __excepts) __THROW;

/* Determine which of subset of the exceptions specified by EXCEPTS are
   currently set.  */
extern int fetestexcept (int __excepts) __THROW;


/* Rounding control.  */

/* Get current rounding direction.  */
extern int fegetround (void) __THROW;

/* Establish the rounding direction represented by ROUND.  */
extern int fesetround (int __rounding_direction) __THROW;

/* Get current precision.  */
extern int fegetprec (void) __THROW;

/* Establish the precision represented by PREC.  */
extern int fesetprec (int __prec) __THROW;


/* Floating-point environment.  */

/* Store the current floating-point environment in the object pointed
   to by ENVP.  */
extern int fegetenv (fenv_t *__envp) __THROW;

/* Save the current environment in the object pointed to by ENVP, clear
   exception flags and install a non-stop mode (if available) for all
   exceptions.  */
extern int feholdexcept (fenv_t *__envp) __THROW;

/* Establish the floating-point environment represented by the object
   pointed to by ENVP.  */
extern int fesetenv (const fenv_t *__envp) __THROW;

/* Save current exceptions in temporary storage, install environment
   represented by object pointed to by ENVP and raise exceptions
   according to saved exceptions.  */
extern int feupdateenv (const fenv_t *__envp) __THROW;


/* Include optimization.  */
#ifdef __OPTIMIZE__
# include <bits/fenvinline.h>
#endif

#ifdef __USE_GNU

/* Enable individual exceptions.  Will not enable more exceptions than
   EXCEPTS specifies.  Returns the previous enabled exceptions if all
   exceptions are successfully set, otherwise returns -1.  */
extern int feenableexcept (int __excepts) __THROW;

/* Disable individual exceptions.  Will not disable more exceptions than
   EXCEPTS specifies.  Returns the previous enabled exceptions if all
   exceptions are successfully disabled, otherwise returns -1.  */
extern int fedisableexcept (int __excepts) __THROW;

/* Return enabled exceptions.  */
extern int fegetexcept (void) __THROW;
#endif


__END_DECLS

#endif /* fenv.h */

```

`include/fpu_control.h`:

```h
/* 68k FPU control word definitions.
   Copyright (C) 1996-2013 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library.  If not, see
   <http://www.gnu.org/licenses/>.  */

#ifndef _FPU_CONTROL_H
#define _FPU_CONTROL_H

#ifndef _FEATURES_H
#include <features.h>
#endif

#ifndef	_BITS_TYPES_H
#include <bits/types.h>
#endif

#include <bits/fpu_control.h>

#endif /* _FPU_CONTROL_H */

```

`include/k_stand.h`:

```h
enum matherr {
	KMATHERR_ACOS = 1,			/* acos(|x|>1) */
	KMATHERR_ASIN,				/* asin(|x|>1) */
	KMATHERR_ATAN2,				/* atan2(+-0,+-0) */
	KMATHERR_HYPOT,				/* hypot overflow */
	KMATHERR_COSH,				/* cosh overflow */
	KMATHERR_EXP_OVERFLOW,		/* exp overflow */
	KMATHERR_EXP_UNDERFLOW,		/* exp underflow */
	KMATHERR_Y0_ZERO,			/* y0(0) */
	KMATHERR_Y0_MINUS,			/* y0(x<0) */
	KMATHERR_Y1_ZERO,			/* y1(0) */
	KMATHERR_Y1_MINUS,			/* y1(x<0) */
	KMATHERR_YN_ZERO,			/* yn(0) */
	KMATHERR_YN_MINUS,			/* yn(x<0) */
	KMATHERR_LGAMMA_OVERFLOW,	/* lgamma(finite) overflow */
	KMATHERR_LGAMMA_MINUS,		/* lgamma(-integer) */
	KMATHERR_LOG_ZERO,			/* log(0) */
	KMATHERR_LOG_MINUS,			/* log(x<0) */
	KMATHERR_LOG10_ZERO,		/* log10(0) */
	KMATHERR_LOG10_MINUS,		/* log10(x<0) */
	KMATHERR_POW_ZERO,			/* pow(0.0,0.0) */
	KMATHERR_POW_OVERFLOW,		/* pow(x,y) overflow */
	KMATHERR_POW_UNDERFLOW,		/* pow(x,y) underflow */
	KMATHERR_POW_MINUS,			/* pow(0,negative) */
	KMATHERR_POW_NONINT,		/* pow(neg,non-integral) */
	KMATHERR_SINH,				/* sinh(finite) overflow */
	KMATHERR_SQRT,				/* sqrt(negative) */
	KMATHERR_FMOD,				/* fmod(x,0) */
	KMATHERR_REMAINDER,			/* remainder(x,0) */
	KMATHERR_ACOSH,				/* acosh(x<1) */
	KMATHERR_ATANH_PLUSONE,		/* atanh(|x|>1) */
	KMATHERR_ATANH_ONE,			/* atanh(|x|=1) */
	KMATHERR_SCALB_OVERFLOW,	/* scalb overflow */
	KMATHERR_SCALB_UNDERFLOW,	/* scalb underflow */
	KMATHERR_J0_TLOSS,			/* j0(|x|>X_TLOSS) */
	KMATHERR_Y0_TLOSS,			/* y0(x>X_TLOSS) */
	KMATHERR_J1_TLOSS,			/* j1(|x|>X_TLOSS) */
	KMATHERR_Y1_TLOSS,			/* y1(x>X_TLOSS) */
	KMATHERR_JN_TLOSS,			/* jn(|x|>X_TLOSS) */
	KMATHERR_YN_TLOSS,			/* yn(x>X_TLOSS) */
	KMATHERR_TGAMMA_OVERFLOW,	/* tgamma(finite) overflow */
	KMATHERR_TGAMMA_MINUS,		/* tgamma(-integer) */
	KMATHERR_POW_NAN,			/* pow(NaN,0.0) */
	KMATHERR_POW_ZEROMINUS,		/* +0**neg */
	KMATHERR_EXP2_OVERFLOW,		/* exp2 overflow */
	KMATHERR_EXP2_UNDERFLOW,	/* exp2 underflow */
	KMATHERR_EXP10_OVERFLOW,	/* exp10 overflow */
	KMATHERR_EXP10_UNDERFLOW,	/* exp10 underflow */
	KMATHERR_LOG2_ZERO,			/* log2(0) */
	KMATHERR_LOG2_MINUS,		/* log2(x<0) */
	KMATHERR_TGAMMA_ZERO,		/* tgamma(+-0) */
	KMATHERR_COS_INF,			/* cos(inf) */
	KMATHERR_SIN_INF,			/* sin(inf) */
	KMATHERR_TAN_INF,			/* tan(inf) */
	KMATHERR_SCALB_INVALID,		/* scalb invalid */
	KMATHERR_TGAMMA_UNDERFLOW,	/* tgamma(finite) underflow */
	KMATHERR_ILOGB,				/* ilogb(0 or NaN) */
	KMATHERR_EXPM1_OVERFLOW,	/* expm1 overflow */
	KMATHERR_EXPM1_UNDERFLOW,	/* expm1 underflow */
 
	KMATHERRF_FIRST = 100,
	KMATHERRF_ACOS = KMATHERR_ACOS + KMATHERRF_FIRST,
	KMATHERRF_ASIN = KMATHERR_ASIN + KMATHERRF_FIRST,
	KMATHERRF_ATAN2 = KMATHERR_ATAN2 + KMATHERRF_FIRST,
	KMATHERRF_HYPOT = KMATHERR_HYPOT + KMATHERRF_FIRST,
	KMATHERRF_COSH = KMATHERR_COSH + KMATHERRF_FIRST,
	KMATHERRF_EXP_OVERFLOW = KMATHERR_EXP_OVERFLOW + KMATHERRF_FIRST,
	KMATHERRF_EXP_UNDERFLOW = KMATHERR_EXP_UNDERFLOW + KMATHERRF_FIRST,
	KMATHERRF_Y0_ZERO = KMATHERR_Y0_ZERO + KMATHERRF_FIRST,
	KMATHERRF_Y0_MINUS = KMATHERR_Y0_MINUS + KMATHERRF_FIRST,
	KMATHERRF_Y1_ZERO = KMATHERR_Y1_ZERO + KMATHERRF_FIRST,
	KMATHERRF_Y1_MINUS = KMATHERR_Y1_MINUS + KMATHERRF_FIRST,
	KMATHERRF_YN_ZERO = KMATHERR_YN_ZERO + KMATHERRF_FIRST,
	KMATHERRF_YN_MINUS = KMATHERR_YN_MINUS + KMATHERRF_FIRST,
	KMATHERRF_LGAMMA_OVERFLOW = KMATHERR_LGAMMA_OVERFLOW + KMATHERRF_FIRST,
	KMATHERRF_LGAMMA_MINUS = KMATHERR_LGAMMA_MINUS + KMATHERRF_FIRST,
	KMATHERRF_LOG_ZERO = KMATHERR_LOG_ZERO + KMATHERRF_FIRST,
	KMATHERRF_LOG_MINUS = KMATHERR_LOG_MINUS + KMATHERRF_FIRST,
	KMATHERRF_LOG10_ZERO = KMATHERR_LOG10_ZERO + KMATHERRF_FIRST,
	KMATHERRF_LOG10_MINUS = KMATHERR_LOG10_MINUS + KMATHERRF_FIRST,
	KMATHERRF_POW_ZERO = KMATHERR_POW_ZERO + KMATHERRF_FIRST,
	KMATHERRF_POW_OVERFLOW = KMATHERR_POW_OVERFLOW + KMATHERRF_FIRST,
	KMATHERRF_POW_UNDERFLOW = KMATHERR_POW_UNDERFLOW + KMATHERRF_FIRST,
	KMATHERRF_POW_MINUS = KMATHERR_POW_MINUS + KMATHERRF_FIRST,
	KMATHERRF_POW_NONINT = KMATHERR_POW_NONINT + KMATHERRF_FIRST,
	KMATHERRF_SINH = KMATHERR_SINH + KMATHERRF_FIRST,
	KMATHERRF_SQRT = KMATHERR_SQRT + KMATHERRF_FIRST,
	KMATHERRF_FMOD = KMATHERR_FMOD + KMATHERRF_FIRST,
	KMATHERRF_REMAINDER = KMATHERR_REMAINDER + KMATHERRF_FIRST,
	KMATHERRF_ACOSH = KMATHERR_ACOSH + KMATHERRF_FIRST,
	KMATHERRF_ATANH_PLUSONE = KMATHERR_ATANH_PLUSONE + KMATHERRF_FIRST,
	KMATHERRF_ATANH_ONE = KMATHERR_ATANH_ONE + KMATHERRF_FIRST,
	KMATHERRF_SCALB_OVERFLOW = KMATHERR_SCALB_OVERFLOW + KMATHERRF_FIRST,
	KMATHERRF_SCALB_UNDERFLOW = KMATHERR_SCALB_UNDERFLOW + KMATHERRF_FIRST,
	KMATHERRF_J0_TLOSS = KMATHERR_J0_TLOSS + KMATHERRF_FIRST,
	KMATHERRF_Y0_TLOSS = KMATHERR_Y0_TLOSS + KMATHERRF_FIRST,
	KMATHERRF_J1_TLOSS = KMATHERR_J1_TLOSS + KMATHERRF_FIRST,
	KMATHERRF_Y1_TLOSS = KMATHERR_Y1_TLOSS + KMATHERRF_FIRST,
	KMATHERRF_JN_TLOSS = KMATHERR_JN_TLOSS + KMATHERRF_FIRST,
	KMATHERRF_YN_TLOSS = KMATHERR_YN_TLOSS + KMATHERRF_FIRST,
	KMATHERRF_TGAMMA_OVERFLOW = KMATHERR_TGAMMA_OVERFLOW + KMATHERRF_FIRST,
	KMATHERRF_TGAMMA_MINUS = KMATHERR_TGAMMA_MINUS + KMATHERRF_FIRST,
	KMATHERRF_POW_NAN = KMATHERR_POW_NAN + KMATHERRF_FIRST,
	KMATHERRF_POW_ZEROMINUS = KMATHERR_POW_ZEROMINUS + KMATHERRF_FIRST,
	KMATHERRF_EXP2_OVERFLOW = KMATHERR_EXP2_OVERFLOW + KMATHERRF_FIRST,
	KMATHERRF_EXP2_UNDERFLOW = KMATHERR_EXP2_UNDERFLOW + KMATHERRF_FIRST,
	KMATHERRF_EXP10_OVERFLOW = KMATHERR_EXP10_OVERFLOW + KMATHERRF_FIRST,
	KMATHERRF_EXP10_UNDERFLOW = KMATHERR_EXP10_UNDERFLOW + KMATHERRF_FIRST,
	KMATHERRF_LOG2_ZERO = KMATHERR_LOG2_ZERO + KMATHERRF_FIRST,
	KMATHERRF_LOG2_MINUS = KMATHERR_LOG2_MINUS + KMATHERRF_FIRST,
	KMATHERRF_TGAMMA_ZERO = KMATHERR_TGAMMA_ZERO + KMATHERRF_FIRST,
	KMATHERRF_COS_INF = KMATHERR_COS_INF + KMATHERRF_FIRST,
	KMATHERRF_SIN_INF = KMATHERR_SIN_INF + KMATHERRF_FIRST,
	KMATHERRF_TAN_INF = KMATHERR_TAN_INF + KMATHERRF_FIRST,
	KMATHERRF_SCALB_INVALID = KMATHERR_SCALB_INVALID + KMATHERRF_FIRST,
	KMATHERRF_TGAMMA_UNDERFLOW = KMATHERR_TGAMMA_UNDERFLOW + KMATHERRF_FIRST,
	KMATHERRF_ILOGB = KMATHERR_ILOGB + KMATHERRF_FIRST,
	KMATHERRF_EXPM1_OVERFLOW = KMATHERR_EXPM1_OVERFLOW + KMATHERRF_FIRST,
	KMATHERRF_EXPM1_UNDERFLOW = KMATHERR_EXPM1_UNDERFLOW + KMATHERRF_FIRST,
	
	KMATHERRL_FIRST = 200,
	KMATHERRL_ACOS = KMATHERR_ACOS + KMATHERRL_FIRST,
	KMATHERRL_ASIN = KMATHERR_ASIN + KMATHERRL_FIRST,
	KMATHERRL_ATAN2 = KMATHERR_ATAN2 + KMATHERRL_FIRST,
	KMATHERRL_HYPOT = KMATHERR_HYPOT + KMATHERRL_FIRST,
	KMATHERRL_COSH = KMATHERR_COSH + KMATHERRL_FIRST,
	KMATHERRL_EXP_OVERFLOW = KMATHERR_EXP_OVERFLOW + KMATHERRL_FIRST,
	KMATHERRL_EXP_UNDERFLOW = KMATHERR_EXP_UNDERFLOW + KMATHERRL_FIRST,
	KMATHERRL_Y0_ZERO = KMATHERR_Y0_ZERO + KMATHERRL_FIRST,
	KMATHERRL_Y0_MINUS = KMATHERR_Y0_MINUS + KMATHERRL_FIRST,
	KMATHERRL_Y1_ZERO = KMATHERR_Y1_ZERO + KMATHERRL_FIRST,
	KMATHERRL_Y1_MINUS = KMATHERR_Y1_MINUS + KMATHERRL_FIRST,
	KMATHERRL_YN_ZERO = KMATHERR_YN_ZERO + KMATHERRL_FIRST,
	KMATHERRL_YN_MINUS = KMATHERR_YN_MINUS + KMATHERRL_FIRST,
	KMATHERRL_LGAMMA_OVERFLOW = KMATHERR_LGAMMA_OVERFLOW + KMATHERRL_FIRST,
	KMATHERRL_LGAMMA_MINUS = KMATHERR_LGAMMA_MINUS + KMATHERRL_FIRST,
	KMATHERRL_LOG_ZERO = KMATHERR_LOG_ZERO + KMATHERRL_FIRST,
	KMATHERRL_LOG_MINUS = KMATHERR_LOG_MINUS + KMATHERRL_FIRST,
	KMATHERRL_LOG10_ZERO = KMATHERR_LOG10_ZERO + KMATHERRL_FIRST,
	KMATHERRL_LOG10_MINUS = KMATHERR_LOG10_MINUS + KMATHERRL_FIRST,
	KMATHERRL_POW_ZERO = KMATHERR_POW_ZERO + KMATHERRL_FIRST,
	KMATHERRL_POW_OVERFLOW = KMATHERR_POW_OVERFLOW + KMATHERRL_FIRST,
	KMATHERRL_POW_UNDERFLOW = KMATHERR_POW_UNDERFLOW + KMATHERRL_FIRST,
	KMATHERRL_POW_MINUS = KMATHERR_POW_MINUS + KMATHERRL_FIRST,
	KMATHERRL_POW_NONINT = KMATHERR_POW_NONINT + KMATHERRL_FIRST,
	KMATHERRL_SINH = KMATHERR_SINH + KMATHERRL_FIRST,
	KMATHERRL_SQRT = KMATHERR_SQRT + KMATHERRL_FIRST,
	KMATHERRL_FMOD = KMATHERR_FMOD + KMATHERRL_FIRST,
	KMATHERRL_REMAINDER = KMATHERR_REMAINDER + KMATHERRL_FIRST,
	KMATHERRL_ACOSH = KMATHERR_ACOSH + KMATHERRL_FIRST,
	KMATHERRL_ATANH_PLUSONE = KMATHERR_ATANH_PLUSONE + KMATHERRL_FIRST,
	KMATHERRL_ATANH_ONE = KMATHERR_ATANH_ONE + KMATHERRL_FIRST,
	KMATHERRL_SCALB_OVERFLOW = KMATHERR_SCALB_OVERFLOW + KMATHERRL_FIRST,
	KMATHERRL_SCALB_UNDERFLOW = KMATHERR_SCALB_UNDERFLOW + KMATHERRL_FIRST,
	KMATHERRL_J0_TLOSS = KMATHERR_J0_TLOSS + KMATHERRL_FIRST,
	KMATHERRL_Y0_TLOSS = KMATHERR_Y0_TLOSS + KMATHERRL_FIRST,
	KMATHERRL_J1_TLOSS = KMATHERR_J1_TLOSS + KMATHERRL_FIRST,
	KMATHERRL_Y1_TLOSS = KMATHERR_Y1_TLOSS + KMATHERRL_FIRST,
	KMATHERRL_JN_TLOSS = KMATHERR_JN_TLOSS + KMATHERRL_FIRST,
	KMATHERRL_YN_TLOSS = KMATHERR_YN_TLOSS + KMATHERRL_FIRST,
	KMATHERRL_TGAMMA_OVERFLOW = KMATHERR_TGAMMA_OVERFLOW + KMATHERRL_FIRST,
	KMATHERRL_TGAMMA_MINUS = KMATHERR_TGAMMA_MINUS + KMATHERRL_FIRST,
	KMATHERRL_POW_NAN = KMATHERR_POW_NAN + KMATHERRL_FIRST,
	KMATHERRL_POW_ZEROMINUS = KMATHERR_POW_ZEROMINUS + KMATHERRL_FIRST,
	KMATHERRL_EXP2_OVERFLOW = KMATHERR_EXP2_OVERFLOW + KMATHERRL_FIRST,
	KMATHERRL_EXP2_UNDERFLOW = KMATHERR_EXP2_UNDERFLOW + KMATHERRL_FIRST,
	KMATHERRL_EXP10_OVERFLOW = KMATHERR_EXP10_OVERFLOW + KMATHERRL_FIRST,
	KMATHERRL_EXP10_UNDERFLOW = KMATHERR_EXP10_UNDERFLOW + KMATHERRL_FIRST,
	KMATHERRL_LOG2_ZERO = KMATHERR_LOG2_ZERO + KMATHERRL_FIRST,
	KMATHERRL_LOG2_MINUS = KMATHERR_LOG2_MINUS + KMATHERRL_FIRST,
	KMATHERRL_TGAMMA_ZERO = KMATHERR_TGAMMA_ZERO + KMATHERRL_FIRST,
	KMATHERRL_COS_INF = KMATHERR_COS_INF + KMATHERRL_FIRST,
	KMATHERRL_SIN_INF = KMATHERR_SIN_INF + KMATHERRL_FIRST,
	KMATHERRL_TAN_INF = KMATHERR_TAN_INF + KMATHERRL_FIRST,
	KMATHERRL_SCALB_INVALID = KMATHERR_SCALB_INVALID + KMATHERRL_FIRST,
	KMATHERRL_TGAMMA_UNDERFLOW = KMATHERR_TGAMMA_UNDERFLOW + KMATHERRL_FIRST,
	KMATHERRL_ILOGB = KMATHERR_ILOGB + KMATHERRL_FIRST,
	KMATHERRL_EXPM1_OVERFLOW = KMATHERR_EXPM1_OVERFLOW + KMATHERRL_FIRST,
	KMATHERRL_EXPM1_UNDERFLOW = KMATHERR_EXPM1_UNDERFLOW + KMATHERRL_FIRST
};

double __kernel_standard(double arg1, double arg2, double retval, enum matherr type);
float __kernel_standard_f(float arg1, float arg2, float retval, enum matherr type);
long double __kernel_standard_l(long double arg1, long double arg2, long double retval, enum matherr type);

```

`include/math.h`:

```h
/*  math.h -- MiNTLib.
    Copyright (C) 2019 Thorsten Otto <admin@tho-otto.de>

    This file is part of the MiNTLib project, and may only be used
    modified and distributed under the terms of the MiNTLib project
    license, COPYMINT.  By continuing to use, modify, or distribute
    this file you indicate that you have read the license and
    understand and accept it fully.
*/

/*
 *	ISO C99 Standard: 7.12 Mathematics	<math.h>
 */

#ifndef _MATH_H
#define _MATH_H 1

#ifndef	_FEATURES_H
# include <features.h>
#endif

#if (defined(__HAVE_68881__) || defined(__FPU__) || (defined(__mcoldfire__) && defined(__mcffpu__))) && !defined(__HAVE_FPU__)
#  define __HAVE_FPU__ 1
#endif

/*
 * PureC uses __NFPUIN__ to inhibit math inline intrinsics
 */
#if defined(__NFPUIN__) && !defined(__NO_MATH_INLINES)
#  define __NO_MATH_INLINES
#endif

/*
 * ColdFire has no long double format
 */
#if defined(__mcoldfire__) && !defined(__NO_LONG_DOUBLE_MATH)
#  define __NO_LONG_DOUBLE_MATH 1
#endif

/*
 * GNU-C uses 64-bit double format, and 96-bit for long double.
 * PureC uses 64-bit double format for ColdFire (AHCC only),
         80-bit for soft-float and 96-bit for hard-float,
         and the same format also for long double.
 * so:
 *    - ColdFire has no long double, and the long double versions
 *      are redirected to the double versions
 *    - PureC has no real double, all arithmetic is done using long double,
 *      but the format differs between soft-float and fpu versions.
 */
#if (defined(__mcoldfire__) || defined(__GNUC__)) && !defined(__DOUBLE_64__)
#  define __DOUBLE_64__ 1 /* double == long double == ieee754-64bit */
#endif
#if defined(__PUREC__) || defined(__TURBOC__)
#  define __DOUBLE_80__ 1 /* double == long double == ieee854-96bit */
#endif

__BEGIN_DECLS

/* Get definitions of __intmax_t and __uintmax_t.  */
#include <sys/types.h>

/* Get machine-dependent HUGE_VAL value (returned on overflow).
   On all IEEE754 machines, this is +Infinity.  */
#include <bits/huge_val.h>

#ifdef	 __USE_ISOC99
/* Get machine-dependent INFINITY value.  */
# include <bits/inf.h>

/* Get machine-dependent NAN value (returned for some domain errors).  */
# include <bits/nan.h>
#endif

/* Get general and ISO C9X specific information.  */
#include <bits/mathdef.h>


/* The file <bits/mathcalls.h> contains the prototypes for all the
   actual math functions.  These macros are used for those prototypes,
   so we can easily declare each function as both `name' and `__name',
   and can declare the float versions `namef' and `__namef'.  */

#define __MATHCALL(function,suffix, args)	\
  __MATHDECL (_Mdouble_,function,suffix, args)
#define __MATHDECL(type, function,suffix, args) \
  __MATHDECL_1(type, function,suffix, args); \
  __MATHDECL_1(type, __CONCAT(__,function),suffix, args)
#define __MATHCALLX(function,suffix, args, attrib)	\
  __MATHDECLX (_Mdouble_,function,suffix, args, attrib)
#define __MATHDECLX(type, function,suffix, args, attrib) \
  __MATHDECL_1(type, function,suffix, args) __attribute__ (attrib); \
  __MATHDECL_1(type, __CONCAT(__,function),suffix, args) __attribute__ (attrib)
#define __MATHDECL_1(type, function,suffix, args) \
  extern type __MATH_PRECNAME(function,suffix) args __THROW

#define _Mdouble_		double
#define __MATH_PRECNAME(name,r)	__CONCAT(name,r)
#define _Mdouble_BEGIN_NAMESPACE __BEGIN_NAMESPACE_STD
#define _Mdouble_END_NAMESPACE   __END_NAMESPACE_STD
#define __MATH_DECLARING_DOUBLE  1
#define __MATH_DECLARING_FLOATN  0
#include <bits/mathcall.h>
#undef	_Mdouble_
#undef	__MATH_PRECNAME
#undef __MATH_DECLARING_DOUBLE
#undef __MATH_DECLARING_FLOATN
#undef _Mdouble_BEGIN_NAMESPACE
#undef _Mdouble_END_NAMESPACE

#if defined __USE_MISC || defined __USE_ISOC99


/* Include the file of declarations again, this time using `float'
   instead of `double' and appending f to each function name.  */

# ifndef _Mfloat_
#  define _Mfloat_		float
# endif
# define _Mdouble_		_Mfloat_
# define __MATH_PRECNAME(name,r) name##f##r
# define _Mdouble_BEGIN_NAMESPACE __BEGIN_NAMESPACE_C99
# define _Mdouble_END_NAMESPACE   __END_NAMESPACE_C99
# define __MATH_DECLARING_DOUBLE  0
# define __MATH_DECLARING_FLOATN  0
# include <bits/mathcall.h>
# undef	_Mdouble_
# undef	__MATH_PRECNAME
# undef __MATH_DECLARING_DOUBLE
# undef __MATH_DECLARING_FLOATN
# undef _Mdouble_BEGIN_NAMESPACE
# undef _Mdouble_END_NAMESPACE

#  ifdef __LDBL_COMPAT

#   ifdef __USE_ISOC99
extern float __nldbl_nexttowardf (float __x, long double __y)
				  __THROW __attribute__ ((__const__));
#    ifdef __REDIRECT_NTH
extern float __REDIRECT_NTH (nexttowardf, (float __x, long double __y),
			     __nldbl_nexttowardf)
     __attribute__ ((__const__));
extern double __REDIRECT_NTH (nexttoward, (double __x, long double __y),
			      nextafter) __attribute__ ((__const__));
extern long double __REDIRECT_NTH (nexttowardl,
				   (long double __x, long double __y),
				   nextafter) __attribute__ ((__const__));
#    endif
#   endif

#   undef __MATHDECL_1
#   define __MATHDECL_2(type, function,suffix, args, alias) \
  extern type __REDIRECT_NTH(__MATH_PRECNAME(function,suffix), \
			     args, alias)
#   define __MATHDECL_1(type, function,suffix, args) \
  __MATHDECL_2(type, function,suffix, args, __CONCAT(function,suffix))
#  endif

/* Include the file of declarations again, this time using `long double'
   instead of `double' and appending l to each function name.  */

#  ifndef _Mlong_double_
#   define _Mlong_double_	long double
#  endif
#  define _Mdouble_		_Mlong_double_
#  define __MATH_PRECNAME(name,r) name##l##r
#  define _Mdouble_BEGIN_NAMESPACE __BEGIN_NAMESPACE_C99
#  define _Mdouble_END_NAMESPACE   __END_NAMESPACE_C99
#  define __MATH_DECLARING_DOUBLE  0
#  define __MATH_DECLARING_FLOATN  0
#  define __MATH_DECLARE_LDOUBLE   1
#  include <bits/mathcall.h>
#  undef _Mdouble_
#  undef __MATH_PRECNAME
#  undef __MATH_DECLARING_DOUBLE
#  undef __MATH_DECLARING_FLOATN
#  undef _Mdouble_BEGIN_NAMESPACE
#  undef _Mdouble_END_NAMESPACE

#endif	/* Use misc or ISO C99.  */
#undef	__MATHDECL_1
#undef	__MATHDECL
#undef	__MATHCALL


# define X_TLOSS	1.41484755040568800000e+16

#if !defined(__STRICT_ANSI__) || defined(__USE_PUREC)
typedef enum  {
    DOMAIN      = 1,
#define DOMAIN DOMAIN
    SING        = 2,
#define SING SING
    OVERFLOW    = 3,
#define OVERFLOW OVERFLOW
    UNDERFLOW   = 4,
#define UNDERFLOW UNDERFLOW
    TLOSS       = 5,
#define TLOSS TLOSS
    PLOSS       = 6
#define PLOSS PLOSS
} exception_type;
#ifdef __USE_PUREC
typedef exception_type mexcep;
#endif

#ifdef	__USE_MISC
/* Support for various different standard error handling behaviors.  */
typedef enum
{
  _IEEE_ = -1,	/* According to IEEE 754/IEEE 854.  */
  _SVID_,	/* According to System V, release 4.  */
  _XOPEN_,	/* Nowadays also Unix98.  */
  _POSIX_,
  _ISOC_	/* Actually this is ISO C99.  */
} _LIB_VERSION_TYPE;

/* This variable can be changed at run-time to any of the values above to
   affect floating point error handling behavior (it may also be necessary
   to change the hardware FPU exception settings).  */
extern _LIB_VERSION_TYPE _LIB_VERSION;
#endif


/* In SVID error handling, `matherr' is called with this description
   of the exceptional condition.

   We have a problem when using C++ since `exception' is a reserved
   name in C++.  */
/* do not change the comment above; it is looked up by GCCs fixincludes script */
#ifdef __cplusplus
struct __exception
#else
struct exception
#endif
{
	exception_type	type;	/* exception type */
	const char	*name;	/* function in which it occured */
	double		arg1;	/* an arg */
	double		arg2;	/* another arg */
	double		retval; /* val to return */
};
#endif /* __STRICT_ANSI__ */


/* Some useful constants.  */
#if defined __USE_BSD || defined __USE_XOPEN || defined __USE_PUREC
# define M_E		2.71828182845904523536	/* e */
# define M_LOG2E	1.44269504088896340736	/* log_2 e */
# define M_LOG10E	0.434294481903251827651	/* log_10 e */
# define M_LN2		0.693147180559945309417	/* log_e 2 */
# define M_LN10		2.30258509299404568402	/* log_e 10 */
# define M_PI		3.14159265358979323846	/* pi */
# define M_PI_2		1.57079632679489661923	/* pi/2 */
# define M_PI_4		0.785398163397448309116	/* pi/4 */
# define M_1_PI		0.318309886183790671538	/* 1/pi */
# define M_2_PI		0.636619772367581343076	/* 2/pi */
# define M_1_SQRTPI	0.564189583547756286948	/* 1/sqrt(pi) */
# define M_2_SQRTPI	1.12837916709551257390	/* 2/sqrt(pi) */
# define M_SQRT2	1.41421356237309504880	/* sqrt(2) */
# define M_SQRT1_2	0.707106781186547524401	/* 1/sqrt(2) */
#endif

/* The above constants are not adequate for computation using `long double's.
   Therefore we provide as an extension constants with similar names as a
   GNU extension.  Provide enough digits for the 128-bit IEEE quad.  */
#ifdef __USE_GNU
# define M_El		2.718281828459045235360287471352662498L /* e */
# define M_LOG2El	1.442695040888963407359924681001892137L /* log_2 e */
# define M_LOG10El	0.434294481903251827651128918916605082L /* log_10 e */
# define M_LN2l		0.693147180559945309417232121458176568L /* log_e 2 */
# define M_LN10l	2.302585092994045684017991454684364208L /* log_e 10 */
# define M_PIl		3.141592653589793238462643383279502884L /* pi */
# define M_PI_2l	1.570796326794896619231321691639751442L /* pi/2 */
# define M_PI_4l	0.785398163397448309615660845819875721L /* pi/4 */
# define M_1_PIl	0.318309886183790671537767526745028724L /* 1/pi */
# define M_2_PIl	0.636619772367581343075535053490057448L /* 2/pi */
# define M_2_SQRTPIl	1.128379167095512573896158903121545172L /* 2/sqrt(pi) */
# define M_SQRT2l	1.414213562373095048801688724209698079L /* sqrt(2) */
# define M_SQRT1_2l	0.707106781186547524400844362104849039L /* 1/sqrt(2) */
#endif


#define HUGE HUGE_VAL

#ifdef __GNUC__
# ifndef __cplusplus
#  ifndef max
#   define max(x,y) ({typeof(x) _x=(x); typeof(y) _y=(y); _x > _y ? _x : _y;})
#   define min(x,y) ({typeof(x) _x=(x); typeof(y) _y=(y); _x < _y ? _x : _y;})
#  endif
# endif
#endif

#if defined __USE_MISC || defined __USE_XOPEN
/* This variable is used by `gamma' and `lgamma'.  */
#define signgam (*__signgam())
extern int *__signgam (void);
#endif


/* ISO C99 defines some generic macros which work on any data type.  */
#ifdef __USE_ISOC99

/* Get the architecture specific values describing the floating-point
   evaluation.  The following symbols will get defined:

    float_t	floating-point type at least as wide as `float' used
		to evaluate `float' expressions
    double_t	floating-point type at least as wide as `double' used
		to evaluate `double' expressions

    FLT_EVAL_METHOD
		Defined to
		  0	if `float_t' is `float' and `double_t' is `double'
		  1	if `float_t' and `double_t' are `double'
		  2	if `float_t' and `double_t' are `long double'
		  else	`float_t' and `double_t' are unspecified

    INFINITY	representation of the infinity value of type `float'

    FP_FAST_FMA
    FP_FAST_FMAF
    FP_FAST_FMAL
		If defined it indicates that the `fma' function
		generally executes about as fast as a multiply and an add.
		This macro is defined only iff the `fma' function is
		implemented directly with a hardware multiply-add instructions.

    FP_ILOGB0	Expands to a value returned by `ilogb (0.0)'.
    FP_ILOGBNAN	Expands to a value returned by `ilogb (NAN)'.

    DECIMAL_DIG	Number of decimal digits supported by conversion between
		decimal and all internal floating-point formats.

*/

/* All floating-point numbers can be put in one of these categories.  */
enum
  {
    FP_NAN,
# define FP_NAN FP_NAN
    FP_INFINITE,
# define FP_INFINITE FP_INFINITE
    FP_ZERO,
# define FP_ZERO FP_ZERO
    FP_SUBNORMAL,
# define FP_SUBNORMAL FP_SUBNORMAL
    FP_NORMAL
# define FP_NORMAL FP_NORMAL
  };

/* Return number of classification appropriate for X.  */
# ifdef __NO_LONG_DOUBLE_MATH
#  define fpclassify(x) \
     (sizeof (x) == sizeof (float) ? __fpclassifyf (x) : __fpclassify (x))
# else
#  define fpclassify(x) \
     (sizeof (x) == sizeof (float)					      \
      ? __fpclassifyf (x)						      \
      : sizeof (x) == sizeof (double)					      \
      ? __fpclassify (x) : __fpclassifyl (x))
# endif

/* Return nonzero value if sign of X is negative.  */
# if __GNUC_PREREQ (6,0)
#  define signbit(x) __builtin_signbit (x)
# elif defined __cplusplus
  /* In C++ mode, __MATH_TG cannot be used, because it relies on
     __builtin_types_compatible_p, which is a C-only builtin.
     The check for __cplusplus allows the use of the builtin instead of
     __MATH_TG. This is provided for libstdc++, only to let its configure
     test work. No further use of this definition of signbit is expected
     in C++ mode, since libstdc++ provides its own version of signbit
     in cmath (which undefines signbit). */
#  define signbit(x) __builtin_signbitl (x)
# elif defined(__NO_LONG_DOUBLE_MATH)
#  define signbit(x) \
     (sizeof (x) == sizeof (float) ? __signbitf (x) : __signbit (x))
# else
#  define signbit(x) \
     (sizeof (x) == sizeof (float)					      \
      ? __signbitf (x)							      \
      : sizeof (x) == sizeof (double)					      \
      ? __signbit (x) : __signbitl (x))
# endif

/* Return nonzero value if X is not +-Inf or NaN.  */
# ifdef __NO_LONG_DOUBLE_MATH
#  define isfinite(x) \
     (sizeof (x) == sizeof (float) ? __finitef (x) : __finite (x))
# else
#  define isfinite(x) \
     (sizeof (x) == sizeof (float)					      \
      ? __finitef (x)							      \
      : sizeof (x) == sizeof (double)					      \
      ? __finite (x) : __finitel (x))
# endif

/* Return nonzero value if X is neither zero, subnormal, Inf, nor NaN.  */
# if (__GNUC_PREREQ (4,4) && !defined __SUPPORT_SNAN__)
#  define isnormal(x) __builtin_isnormal (x)
# else
#  define isnormal(x) (fpclassify (x) == FP_NORMAL)
# endif

/* Return nonzero value if X is subnormal.  */
# define issubnormal(x) (fpclassify (x) == FP_SUBNORMAL)

/* Return nonzero value if X is a NaN.  We could use `fpclassify' but
   we already have this functions `__isnan' and it is faster.  */
# ifdef __NO_LONG_DOUBLE_MATH
#  define isnan(x) \
     (sizeof (x) == sizeof (float) ? __isnanf (x) : __isnan (x))
# else
#  define isnan(x) \
     (sizeof (x) == sizeof (float)					      \
      ? __isnanf (x)							      \
      : sizeof (x) == sizeof (double)					      \
      ? __isnan (x) : __isnanl (x))
# endif

/* Return nonzero value if X is positive or negative infinity.  */
# ifdef __NO_LONG_DOUBLE_MATH
#  define isinf(x) \
     (sizeof (x) == sizeof (float) ? __isinff (x) : __isinf (x))
# else
#  define isinf(x) \
     (sizeof (x) == sizeof (float)					      \
      ? __isinff (x)							      \
      : sizeof (x) == sizeof (double)					      \
      ? __isinf (x) : __isinfl (x))
# endif

/* Bitmasks for the math_errhandling macro.  */
# define MATH_ERRNO	1	/* errno set by math functions.  */
# define MATH_ERREXCEPT	2	/* Exceptions raised by math functions.  */

/* By default all functions support both errno and exception handling.
   In gcc's fast math mode and if inline functions are defined this
   might not be true.  */
# ifndef __FAST_MATH__
#  define math_errhandling	(MATH_ERRNO | MATH_ERREXCEPT)
# endif

#endif /* Use ISO C99.  */


#ifdef __USE_GNU
/* Return nonzero value if X is a signaling NaN.  */
# ifdef __NO_LONG_DOUBLE_MATH
#  define issignaling(x) \
     (sizeof (x) == sizeof (float) ? __issignalingf (x) : __issignaling (x))
# else
#  define issignaling(x) \
     (sizeof (x) == sizeof (float)					      \
      ? __issignalingf (x)						      \
      : sizeof (x) == sizeof (double)					      \
      ? __issignaling (x) : __issignalingl (x))
# endif
#endif /* Use GNU.  */

extern double atof (__const char *__nptr) __THROW;

#ifdef __USE_PUREC
int ftoa(double *__x, char *__resStr, int __ndig, int __format, int *__decPnt, int *__sign) __THROW;

void    setmatherr( int (*errorfunc)( struct exception *e ) );
int     fpumode( int disable );
void xdcnv(const double *val, void *rep8bytes);
void dxcnv(const void *rep8bytes, double *val);
double x80x96cnv( void *rep10bytes );
void   x96x80cnv( double rep12bytes, void *rep10bytes );

#if defined( __HAVE_68881__ )
double  fint( double __x );
double  fintrz( double __x );
double  fgetexp( double __x );
double  fgetman( double __x );
double  frem( double __x, double __y );
double  fsgldiv( double __x, double __y );
double  fsglmul( double __x, double __y );
double  fetoxm1( double __x );
double  flognp1( double __x );
#endif

#endif

#ifndef __STRICT_ANSI__

#ifndef dabs
extern double dabs (double) __THROW;
#if defined(__HAVE_FPU__) && !defined(__NO_MATH_INLINES)
# define dabs(x) fabs(x)
#endif
#endif

extern double copysign (double, double) __THROW;
extern float copysignf (float, float) __THROW;
extern long double copysignl (long double, long double) __THROW;

#ifdef __cplusplus
extern int matherr (struct __exception *) throw();
#else
extern int matherr (struct exception *) __THROW;
#endif

#endif /* __STRICT_ANSI__ */

#if defined __USE_ISOC99 && __GNUC_PREREQ(2,97)
/* ISO C99 defines some macros to compare number while taking care for
   unordered numbers.  Many FPUs provide special instructions to support
   these operations.  Generic support in GCC for these as builtins went
   in before 3.0.0, but not all cpus added their patterns.  We define
   versions that use the builtins here, and <bits/mathinline.h> will
   undef/redefine as appropriate for the specific GCC version in use.  */
# define isgreater(x, y)	__builtin_isgreater(x, y)
# define isgreaterequal(x, y)	__builtin_isgreaterequal(x, y)
# define isless(x, y)		__builtin_isless(x, y)
# define islessequal(x, y)	__builtin_islessequal(x, y)
# define islessgreater(x, y)	__builtin_islessgreater(x, y)
# define isunordered(u, v)	__builtin_isunordered(u, v)
#endif

#if defined(__HAVE_FPU__) && !defined(__NO_MATH_INLINES)
#if defined(__GNUC__) && !defined(__mcoldfire__)
/* this uses an updated version of GCC */
# include <bits/math-68881.h>
#elif defined(__GNUC__) && defined(__mcffpu__)
# include <bits/math-cffpu.h>
#elif defined(__AHCC__)
# include <ahcc/mathinl.h>
#elif defined(__PUREC__) || defined(__TURBOC__)
# include <purec/mathinl.h>
#endif
#endif

#ifdef __USE_ISOC99
/* If we've still got undefined comparison macros, provide defaults.  */

/* Return nonzero value if arguments are unordered.  */
# ifndef isunordered
#  define isunordered(u, v) (fpclassify (u) == FP_NAN || fpclassify (v) == FP_NAN)
# endif

/* Return nonzero value if X is greater than Y.  */
# ifndef isgreater
#ifdef __GNUC__
#  define isgreater(x, y) \
  (__extension__							      \
   ({ __typeof__(x) __x = (x); __typeof__(y) __y = (y);			      \
      !isunordered (__x, __y) && __x > __y; }))
#else
static int __isgreater(long double x, long double y)
{
	return !isunordered (x, y) && x > y;
}
#define isgreater(x, y) __isgreater(x, y)
#endif
# endif

/* Return nonzero value if X is greater than or equal to Y.  */
# ifndef isgreaterequal
#ifdef __GNUC__
#  define isgreaterequal(x, y) \
  (__extension__							      \
   ({ __typeof__(x) __x = (x); __typeof__(y) __y = (y);			      \
      !isunordered (__x, __y) && __x >= __y; }))
#else
static int __isgreaterequal(long double x, long double y)
{
	return !isunordered (x, y) && x >= y;
}
#define isgreaterequal(x, y) __isgreaterequal(x, y)
#endif
# endif

/* Return nonzero value if X is less than Y.  */
# ifndef isless
#ifdef __GNUC__
#  define isless(x, y) \
  (__extension__							      \
   ({ __typeof__(x) __x = (x); __typeof__(y) __y = (y);			      \
      !isunordered (__x, __y) && __x < __y; }))
#else
static int __isless(long double x, long double y)
{
	return !isunordered (x, y) && x < y;
}
#define isless(x, y) __isless(x, y)
#endif
# endif

/* Return nonzero value if X is less than or equal to Y.  */
# ifndef islessequal
#ifdef __GNUC__
#  define islessequal(x, y) \
  (__extension__							      \
   ({ __typeof__(x) __x = (x); __typeof__(y) __y = (y);			      \
      !isunordered (__x, __y) && __x <= __y; }))
#else
static int __islessequal(long double x, long double y)
{
	return !isunordered (x, y) && x <= y;
}
#define islessequal(x, y) __islessequal(x, y)
#endif
# endif

/* Return nonzero value if either X is less than Y or Y is less than X.  */
# ifndef islessgreater
#ifdef __GNUC__
#  define islessgreater(x, y) \
  (__extension__							      \
   ({ __typeof__(x) __x = (x); __typeof__(y) __y = (y);			      \
      !isunordered (__x, __y) && (__x < __y || __y < __x); }))
#else
static int __islessgreater(long double x, long double y)
{
	return !isunordered (x, y) && (x < y || x > y);
}
#define islessgreater(x, y) __islessgreater(x, y)
#endif
# endif

#endif

/* This function had a different name in the old libm.a */
#define drem remainder

__END_DECLS

#endif /* math.h  */

```

`index`:

```
file	fdlibm/fdlibm.h

file	fdlibm/index

file	fdlibm/e_acos.c

file	fdlibm/e_acosh.c

file	fdlibm/e_asin.c

file	fdlibm/e_atan2.c

file	fdlibm/e_atanh.c

file	fdlibm/e_cosh.c

file	fdlibm/e_exp.c

file	fdlibm/e_fmod.c

file	fdlibm/e_gamma.c

file	fdlibm/e_gamma_r.c

file	fdlibm/e_hypot.c

file	fdlibm/e_j0.c

file	fdlibm/e_j1.c

file	fdlibm/e_jn.c

file	fdlibm/e_lgamma.c

file	fdlibm/e_lgamma_r.c

file	fdlibm/e_log.c

file	fdlibm/e_log10.c

file	fdlibm/e_pow.c

file	fdlibm/e_rem_pio2.c

file	fdlibm/e_remainder.c

file	fdlibm/e_scalb.c

file	fdlibm/e_sinh.c

file	fdlibm/e_sqrt.c

file	fdlibm/k_cos.c

file	fdlibm/k_rem_pio2.c

file	fdlibm/k_sin.c

file	fdlibm/k_standard.c

file	fdlibm/k_tan.c

file	fdlibm/makefile

file	fdlibm/s_asinh.c

file	fdlibm/s_atan.c

file	fdlibm/s_cbrt.c

file	fdlibm/s_ceil.c

file	fdlibm/s_copysign.c

file	fdlibm/s_cos.c

file	fdlibm/s_erf.c

file	fdlibm/s_expm1.c

file	fdlibm/s_fabs.c

file	fdlibm/s_finite.c

file	fdlibm/s_floor.c

file	fdlibm/s_frexp.c

file	fdlibm/s_ilogb.c

file	fdlibm/s_isnan.c

file	fdlibm/s_ldexp.c

file	fdlibm/s_lib_version.c

file	fdlibm/s_log1p.c

file	fdlibm/s_logb.c

file	fdlibm/s_matherr.c

file	fdlibm/s_modf.c

file	fdlibm/s_nextafter.c

file	fdlibm/s_rint.c

file	fdlibm/s_scalbn.c

file	fdlibm/s_signgam.c

file	fdlibm/s_significand.c

file	fdlibm/s_sin.c

file	fdlibm/s_tan.c

file	fdlibm/s_tanh.c

file	fdlibm/w_acos.c

file	fdlibm/w_acosh.c

file	fdlibm/w_asin.c

file	fdlibm/w_atan2.c

file	fdlibm/w_atanh.c

file	fdlibm/w_cosh.c

file	fdlibm/w_exp.c

file	fdlibm/w_fmod.c

file	fdlibm/w_gamma.c

file	fdlibm/w_gamma_r.c

file	fdlibm/w_hypot.c

file	fdlibm/w_j0.c

file	fdlibm/w_j1.c

file	fdlibm/w_jn.c

file	fdlibm/w_lgamma.c

file	fdlibm/w_lgamma_r.c

file	fdlibm/w_log.c

file	fdlibm/w_log10.c

file	fdlibm/w_pow.c

file	fdlibm/w_remainder.c

file	fdlibm/w_scalb.c

file	fdlibm/w_sinh.c

file	fdlibm/w_sqrt.c

file	fdlibm/readme


```

`index.html`:

```html
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<TITLE>/netlib/fdlibm</TITLE>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#330088" ALINK="#FF0044">
<H2>/netlib/fdlibm</H2>
<UL>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/fdlibm.h.Z">fdlibm.h</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/fdlibm.h.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/index.Z">index</A><MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/e_acos.c.Z">e_acos.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/e_acos.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/e_acosh.c.Z">e_acosh.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/e_acosh.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/e_asin.c.Z">e_asin.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/e_asin.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/e_atan2.c.Z">e_atan2.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/e_atan2.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/e_atanh.c.Z">e_atanh.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/e_atanh.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/e_cosh.c.Z">e_cosh.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/e_cosh.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/e_exp.c.Z">e_exp.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/e_exp.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/e_fmod.c.Z">e_fmod.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/e_fmod.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/e_gamma.c.Z">e_gamma.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/e_gamma.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/e_gamma_r.c.Z">e_gamma_r.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/e_gamma_r.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/e_hypot.c.Z">e_hypot.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/e_hypot.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/e_j0.c.Z">e_j0.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/e_j0.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/e_j1.c.Z">e_j1.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/e_j1.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/e_jn.c.Z">e_jn.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/e_jn.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/e_lgamma.c.Z">e_lgamma.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/e_lgamma.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/e_lgamma_r.c.Z">e_lgamma_r.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/e_lgamma_r.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/e_log.c.Z">e_log.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/e_log.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/e_log10.c.Z">e_log10.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/e_log10.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/e_pow.c.Z">e_pow.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/e_pow.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/e_rem_pio2.c.Z">e_rem_pio2.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/e_rem_pio2.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/e_remainder.c.Z">e_remainder.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/e_remainder.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/e_scalb.c.Z">e_scalb.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/e_scalb.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/e_sinh.c.Z">e_sinh.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/e_sinh.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/e_sqrt.c.Z">e_sqrt.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/e_sqrt.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/k_cos.c.Z">k_cos.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/k_cos.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/k_rem_pio2.c.Z">k_rem_pio2.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/k_rem_pio2.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/k_sin.c.Z">k_sin.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/k_sin.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/k_standard.c.Z">k_standard.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/k_standard.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/k_tan.c.Z">k_tan.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/k_tan.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/makefile.Z">makefile</A><MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/s_asinh.c.Z">s_asinh.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/s_asinh.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/s_atan.c.Z">s_atan.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/s_atan.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/s_cbrt.c.Z">s_cbrt.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/s_cbrt.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/s_ceil.c.Z">s_ceil.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/s_ceil.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/s_copysign.c.Z">s_copysign.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/s_copysign.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/s_cos.c.Z">s_cos.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/s_cos.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/s_erf.c.Z">s_erf.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/s_erf.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/s_expm1.c.Z">s_expm1.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/s_expm1.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/s_fabs.c.Z">s_fabs.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/s_fabs.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/s_finite.c.Z">s_finite.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/s_finite.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/s_floor.c.Z">s_floor.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/s_floor.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/s_frexp.c.Z">s_frexp.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/s_frexp.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/s_ilogb.c.Z">s_ilogb.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/s_ilogb.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/s_isnan.c.Z">s_isnan.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/s_isnan.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/s_ldexp.c.Z">s_ldexp.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/s_ldexp.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/s_lib_version.c.Z">s_lib_version.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/s_lib_version.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/s_log1p.c.Z">s_log1p.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/s_log1p.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/s_logb.c.Z">s_logb.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/s_logb.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/s_matherr.c.Z">s_matherr.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/s_matherr.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/s_modf.c.Z">s_modf.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/s_modf.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/s_nextafter.c.Z">s_nextafter.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/s_nextafter.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/s_rint.c.Z">s_rint.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/s_rint.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/s_scalbn.c.Z">s_scalbn.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/s_scalbn.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/s_signgam.c.Z">s_signgam.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/s_signgam.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/s_significand.c.Z">s_significand.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/s_significand.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/s_sin.c.Z">s_sin.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/s_sin.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/s_tan.c.Z">s_tan.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/s_tan.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/s_tanh.c.Z">s_tanh.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/s_tanh.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/w_acos.c.Z">w_acos.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/w_acos.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/w_acosh.c.Z">w_acosh.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/w_acosh.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/w_asin.c.Z">w_asin.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/w_asin.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/w_atan2.c.Z">w_atan2.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/w_atan2.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/w_atanh.c.Z">w_atanh.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/w_atanh.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/w_cosh.c.Z">w_cosh.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/w_cosh.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/w_exp.c.Z">w_exp.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/w_exp.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/w_fmod.c.Z">w_fmod.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/w_fmod.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/w_gamma.c.Z">w_gamma.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/w_gamma.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/w_gamma_r.c.Z">w_gamma_r.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/w_gamma_r.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/w_hypot.c.Z">w_hypot.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/w_hypot.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/w_j0.c.Z">w_j0.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/w_j0.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/w_j1.c.Z">w_j1.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/w_j1.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/w_jn.c.Z">w_jn.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/w_jn.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/w_lgamma.c.Z">w_lgamma.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/w_lgamma.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/w_lgamma_r.c.Z">w_lgamma_r.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/w_lgamma_r.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/w_log.c.Z">w_log.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/w_log.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/w_log10.c.Z">w_log10.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/w_log10.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/w_pow.c.Z">w_pow.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/w_pow.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/w_remainder.c.Z">w_remainder.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/w_remainder.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/w_scalb.c.Z">w_scalb.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/w_scalb.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/w_sinh.c.Z">w_sinh.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/w_sinh.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/w_sqrt.c.Z">w_sqrt.c</A> (<A HREF="ftp://netlib.bell-labs.com/netlib.depend/fdlibm/w_sqrt.c.tar">with dependencies</A>)<MENU>
</MENU>
<LI><EM>file: </EM><A HREF="/netlib/fdlibm/readme.Z">readme</A><MENU>
</MENU>
<P><LI><A HREF="/netlib/bib/thesaurus.html">index help</A>
</UL>
<P><A HREF="/netlib/bib/ericjack.html">Eric and Jack</EM>
</BODY></HTML>

```

`k_cos.c`:

```c
/* @(#)k_cos.c 1.3 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice 
 * is preserved.
 * ====================================================
 */

/*
 * __kernel_cos( x,  y )
 * kernel cos function on [-pi/4, pi/4], pi/4 ~ 0.785398164
 * Input x is assumed to be bounded by ~pi/4 in magnitude.
 * Input y is the tail of x. 
 *
 * Algorithm
 *	1. Since cos(-x) = cos(x), we need only to consider positive x.
 *	2. if x < 2^-27 (hx<0x3e400000 0), return 1 with inexact if x!=0.
 *	3. cos(x) is approximated by a polynomial of degree 14 on
 *	   [0,pi/4]
 *		  	                 4            14
 *	   	cos(x) ~ 1 - x*x/2 + C1*x + ... + C6*x
 *	   where the remez error is
 *	
 * 	|              2     4     6     8     10    12     14 |     -58
 * 	|cos(x)-(1-.5*x +C1*x +C2*x +C3*x +C4*x +C5*x  +C6*x  )| <= 2
 * 	|    					               | 
 * 
 * 	               4     6     8     10    12     14 
 *	4. let r = C1*x +C2*x +C3*x +C4*x +C5*x  +C6*x  , then
 *	       cos(x) = 1 - x*x/2 + r
 *	   since cos(x+y) ~ cos(x) - sin(x)*y 
 *			  ~ cos(x) - x*y,
 *	   a correction term is necessary in cos(x) and hence
 *		cos(x+y) = 1 - (x*x/2 - (r - x*y))
 *	   For better accuracy when x > 0.3, let qx = |x|/4 with
 *	   the last 32 bits mask off, and if x > 0.78125, let qx = 0.28125.
 *	   Then
 *		cos(x+y) = (1-qx) - ((x*x/2-qx) - (r-x*y)).
 *	   Note that 1-qx and (x*x/2-qx) is EXACT here, and the
 *	   magnitude of the latter is at least a quarter of x*x/2,
 *	   thus, reducing the rounding error in the subtraction.
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

double __kernel_cos(double x, double y)
{
	double a, hz, z, r, qx;
	int32_t ix;

	static const double one = 1.00000000000000000000e+00;	/* 0x3FF00000, 0x00000000 */
	static const double C1 = 4.16666666666666019037e-02;	/* 0x3FA55555, 0x5555554C */
	static const double C2 = -1.38888888888741095749e-03;	/* 0xBF56C16C, 0x16C15177 */
	static const double C3 = 2.48015872894767294178e-05;	/* 0x3EFA01A0, 0x19CB1590 */
	static const double C4 = -2.75573143513906633035e-07;	/* 0xBE927E4F, 0x809C52AD */
	static const double C5 = 2.08757232129817482790e-09;	/* 0x3E21EE9E, 0xBDB4B1C4 */
	static const double C6 = -1.13596475577881948265e-11;	/* 0xBDA8FAE9, 0xBE8838D4 */

	GET_HIGH_WORD(ix, x);
	ix &= IC(0x7fffffff);				/* ix = |x|'s high word */
	if (ix < IC(0x3e400000))
	{									/* if x < 2**27 */
		if (((int) x) == 0)
			return one;					/* generate inexact */
	}
	z = x * x;
	r = z * (C1 + z * (C2 + z * (C3 + z * (C4 + z * (C5 + z * C6)))));
	if (ix < IC(0x3FD33333))			/* if |x| < 0.3 */
		return one - (0.5 * z - (z * r - x * y));
	else
	{
		if (ix > IC(0x3fe90000))
		{								/* x > 0.78125 */
			qx = 0.28125;
		} else
		{
			INSERT_WORDS(qx, ix - IC(0x00200000), 0);	/* x/4 */
		}
		hz = 0.5 * z - qx;
		a = one - qx;
		return a - (hz - (z * r - x * y));
	}
}

```

`k_cosf.c`:

```c
/* k_cosf.c -- float version of k_cos.c
 * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

float __kernel_cosf(float x, float y)
{
	float a, hz, z, r, qx;
	int32_t ix;

	static const float one = 1.0000000000e+00;		/* 0x3f800000 */
	static const float C1 = 4.1666667908e-02;		/* 0x3d2aaaab */
	static const float C2 = -1.3888889225e-03;		/* 0xbab60b61 */
	static const float C3 = 2.4801587642e-05;		/* 0x37d00d01 */
	static const float C4 = -2.7557314297e-07;		/* 0xb493f27c */
	static const float C5 = 2.0875723372e-09;		/* 0x310f74f6 */
	static const float C6 = -1.1359647598e-11;		/* 0xad47d74e */

	GET_FLOAT_WORD(ix, x);
	ix &= IC(0x7fffffff);				/* ix = |x|'s high word */
	if (ix < IC(0x32000000))
	{									/* if x < 2**27 */
		if (((int32_t) x) == 0)
			return one;					/* generate inexact */
	}
	z = x * x;
	r = z * (C1 + z * (C2 + z * (C3 + z * (C4 + z * (C5 + z * C6)))));
	if (ix < IC(0x3e99999a))			/* if |x| < 0.3 */
		return one - (0.5f * z - (z * r - x * y));
	else
	{
		if (ix > IC(0x3f480000))
		{								/* x > 0.78125 */
			qx = 0.28125f;
		} else
		{
			SET_FLOAT_WORD(qx, ix - IC(0x01000000));	/* x/4 */
		}
		hz = 0.5f * z - qx;

		a = one - qx;
		return a - (hz - (z * r - x * y));
	}
}

```

`k_cosl.c`:

```c
/* Extended-precision floating point cosine on <-pi/4,pi/4>.
   Copyright (C) 1999-2013 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Based on quad-precision cosine by Jakub Jelinek <jj@ultra.linux.cz>

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

long double __kernel_cosl(long double x, long double y)
{
	long double h, l, z, sin_l, cos_l_m1;
	int index;

	/* The polynomials have not been optimized for extended-precision and
	   may contain more terms than needed.  */
	
	static const long double ONE = 1.00000000000000000000000000000000000E+00L;
	
	/* cos x ~ ONE + x^2 ( SCOS1 + SCOS2 * x^2 + ... + SCOS4 * x^6 + SCOS5 * x^8 )
	   x in <0,1/256>  */
	static const long double SCOS1 = -5.00000000000000000000000000000000000E-01L;
	static const long double SCOS2 = 4.16666666666666666666666666556146073E-02L;
	static const long double SCOS3 = -1.38888888888888888888309442601939728E-03L;
	static const long double SCOS4 = 2.48015873015862382987049502531095061E-05L;
	static const long double SCOS5 = -2.75573112601362126593516899592158083E-07L;
	
	/* cos x ~ ONE + x^2 ( COS1 + COS2 * x^2 + ... + COS7 * x^12 + COS8 * x^14 )
	   x in <0,0.1484375>  */
	static const long double COS1 = -4.99999999999999999999999999999999759E-01L;
	static const long double COS2 = 4.16666666666666666666666666651287795E-02L;
	static const long double COS3 = -1.38888888888888888888888742314300284E-03L;
	static const long double COS4 = 2.48015873015873015867694002851118210E-05L;
	static const long double COS5 = -2.75573192239858811636614709689300351E-07L;
	static const long double COS6 = 2.08767569877762248667431926878073669E-09L;
	static const long double COS7 = -1.14707451049343817400420280514614892E-11L;
	static const long double COS8 = 4.77810092804389587579843296923533297E-14L;
	
	/* sin x ~ ONE * x + x^3 ( SSIN1 + SSIN2 * x^2 + ... + SSIN4 * x^6 + SSIN5 * x^8 )
	   x in <0,1/256>  */
	static const long double SSIN1 = -1.66666666666666666666666666666666659E-01L;
	static const long double SSIN2 = 8.33333333333333333333333333146298442E-03L;
	static const long double SSIN3 = -1.98412698412698412697726277416810661E-04L;
	static const long double SSIN4 = 2.75573192239848624174178393552189149E-06L;
	static const long double SSIN5 = -2.50521016467996193495359189395805639E-08L;
	
#define SINCOSL_COS_HI 0
#define SINCOSL_COS_LO 1
#define SINCOSL_SIN_HI 2
#define SINCOSL_SIN_LO 3
	
	if (signbit(x))
	{
		x = -x;
		y = -y;
	}
	if (x < 0.1484375L)
	{
		/* Argument is small enough to approximate it by a Chebyshev
		   polynomial of degree 16.  */
		if (x < 0x1p-33L)
			if (!((int32_t) x))
				return ONE;				/* generate inexact */
		z = x * x;
		return ONE + (z * (COS1 + z * (COS2 + z * (COS3 + z * (COS4 + z * (COS5 + z * (COS6 + z * (COS7 + z * COS8))))))));
	} else
	{
		/* So that we don't have to use too large polynomial,  we find
		   l and h such that x = l + h,  where fabsl(l) <= 1.0/256 with 83
		   possible values for h.  We look up cosl(h) and sinl(h) in
		   pre-computed tables,  compute cosl(l) and sinl(l) using a
		   Chebyshev polynomial of degree 10(11) and compute
		   cosl(h+l) = cosl(h)cosl(l) - sinl(h)sinl(l).  */
		index = (int) (128 * (x - (0.1484375L - 1.0L / 256.0L)));
		h = 0.1484375L + index / 128.0;
		index *= 4;
		l = y - (h - x);
		z = l * l;
		sin_l = l * (ONE + z * (SSIN1 + z * (SSIN2 + z * (SSIN3 + z * (SSIN4 + z * SSIN5)))));
		cos_l_m1 = z * (SCOS1 + z * (SCOS2 + z * (SCOS3 + z * (SCOS4 + z * SCOS5))));
		return __sincosl_table[index + SINCOSL_COS_HI]
			+ (__sincosl_table[index + SINCOSL_COS_LO]
			   - (__sincosl_table[index + SINCOSL_SIN_HI] * sin_l
				  - __sincosl_table[index + SINCOSL_COS_HI] * cos_l_m1));
	}

#undef SINCOSL_COS_HI
#undef SINCOSL_COS_LO
#undef SINCOSL_SIN_HI
#undef SINCOSL_SIN_LO
}

```

`k_rem_pio2.c`:

```c
/* @(#)k_rem_pio2.c 1.3 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/*
 * __kernel_rem_pio2(x,y,e0,nx,prec,ipio2)
 * double x[],y[]; int e0,nx,prec; int ipio2[];
 *
 * __kernel_rem_pio2 return the last three digits of N with
 *		y = x - N*pi/2
 * so that |y| < pi/2.
 *
 * The method is to compute the integer (mod 8) and fraction parts of
 * (2/pi)*x without doing the full multiplication. In general we
 * skip the part of the product that are known to be a huge integer (
 * more accurately, = 0 mod 8 ). Thus the number of operations are
 * independent of the exponent of the input.
 *
 * (2/pi) is represented by an array of 24-bit integers in ipio2[].
 *
 * Input parameters:
 * 	x[]	The input value (must be positive) is broken into nx
 *		pieces of 24-bit integers in double precision format.
 *		x[i] will be the i-th 24 bit of x. The scaled exponent
 *		of x[0] is given in input parameter e0 (i.e., x[0]*2^e0
 *		match x's up to 24 bits.
 *
 *		Example of breaking a double positive z into x[0]+x[1]+x[2]:
 *			e0 = ilogb(z)-23
 *			z  = scalbn(z,-e0)
 *		for i = 0,1,2
 *			x[i] = floor(z)
 *			z    = (z-x[i])*2**24
 *
 *
 *	y[]	ouput result in an array of double precision numbers.
 *		The dimension of y[] is:
 *			24-bit  precision	1
 *			53-bit  precision	2
 *			64-bit  precision	2
 *			113-bit precision	3
 *		The actual value is the sum of them. Thus for 113-bit
 *		precision, one may have to do something like:
 *
 *		long double t,w,r_head, r_tail;
 *		t = (long double)y[2] + (long double)y[1];
 *		w = (long double)y[0];
 *		r_head = t+w;
 *		r_tail = w - (r_head - t);
 *
 *	e0	The exponent of x[0]
 *
 *	nx	dimension of x[]
 *
 *  	prec	an integer indicating the precision:
 *			0	24  bits (single)
 *			1	53  bits (double)
 *			2	64  bits (extended)
 *			3	113 bits (quad)
 *
 *	ipio2[]
 *		integer array, contains the (24*i)-th to (24*i+23)-th
 *		bit of 2/pi after binary point. The corresponding
 *		floating value is
 *
 *			ipio2[i] * 2^(-24(i+1)).
 *
 * External function:
 *	double scalbn(), floor();
 *
 *
 * Here is the description of some local variables:
 *
 * 	jk	jk+1 is the initial number of terms of ipio2[] needed
 *		in the computation. The recommended value is 2,3,4,
 *		6 for single, double, extended,and quad.
 *
 * 	jz	local integer variable indicating the number of
 *		terms of ipio2[] used.
 *
 *	jx	nx - 1
 *
 *	jv	index for pointing to the suitable ipio2[] for the
 *		computation. In general, we want
 *			( 2^e0*x[0] * ipio2[jv-1]*2^(-24jv) )/8
 *		is an integer. Thus
 *			e0-3-24*jv >= 0 or (e0-3)/24 >= jv
 *		Hence jv = max(0,(e0-3)/24).
 *
 *	jp	jp+1 is the number of terms in PIo2[] needed, jp = jk.
 *
 * 	q[]	double array with integral value, representing the
 *		24-bits chunk of the product of x and 2/pi.
 *
 *	q0	the corresponding exponent of q[0]. Note that the
 *		exponent for q[i] would be q0-24*i.
 *
 *	PIo2[]	double precision array, obtained by cutting pi/2
 *		into 24 bits chunks.
 *
 *	f[]	ipio2[] in floating point
 *
 *	iq[]	integer array by breaking up q[] in 24-bits chunk.
 *
 *	fq[]	final product of x*(2/pi) in fq[0],..,fq[jk]
 *
 *	ih	integer. If >0 it indicates q[] is >= 0.5, hence
 *		it also indicates the *sign* of the result.
 *
 */


#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif


int32_t __kernel_rem_pio2(double *x, double *y, int32_t e0, int32_t nx, int prec)
{
	int32_t jz, jx, jv, jp, jk, carry, n, iq[20], i, j, k, m, q0, ih;
	double z, fw, f[20], fq[20], q[20];

	static const int init_jk[] = { 2, 3, 4, 6 };	/* initial value for jk */

	/*
	 * Constants:
	 * The hexadecimal values are the intended ones for the following
	 * constants. The decimal values may be used, provided that the
	 * compiler will convert from decimal to binary accurately enough
	 * to produce the hexadecimal values shown.
	 */
	
	static const double PIo2[] = {
		1.57079625129699707031e+00,			/* 0x3FF921FB, 0x40000000 */
		7.54978941586159635335e-08,			/* 0x3E74442D, 0x00000000 */
		5.39030252995776476554e-15,			/* 0x3CF84698, 0x80000000 */
		3.28200341580791294123e-22,			/* 0x3B78CC51, 0x60000000 */
		1.27065575308067607349e-29,			/* 0x39F01B83, 0x80000000 */
		1.22933308981111328932e-36,			/* 0x387A2520, 0x40000000 */
		2.73370053816464559624e-44,			/* 0x36E38222, 0x80000000 */
		2.16741683877804819444e-51			/* 0x3569F31D, 0x00000000 */
	};

	/*
	 * Table of constants for 2/pi, 396 Hex digits (476 decimal) of 2/pi
	 */
	static const int32_t two_over_pi[] = {
		IC(0xA2F983), IC(0x6E4E44), IC(0x1529FC), IC(0x2757D1), IC(0xF534DD), IC(0xC0DB62),
		IC(0x95993C), IC(0x439041), IC(0xFE5163), IC(0xABDEBB), IC(0xC561B7), IC(0x246E3A),
		IC(0x424DD2), IC(0xE00649), IC(0x2EEA09), IC(0xD1921C), IC(0xFE1DEB), IC(0x1CB129),
		IC(0xA73EE8), IC(0x8235F5), IC(0x2EBB44), IC(0x84E99C), IC(0x7026B4), IC(0x5F7E41),
		IC(0x3991D6), IC(0x398353), IC(0x39F49C), IC(0x845F8B), IC(0xBDF928), IC(0x3B1FF8),
		IC(0x97FFDE), IC(0x05980F), IC(0xEF2F11), IC(0x8B5A0A), IC(0x6D1F6D), IC(0x367ECF),
		IC(0x27CB09), IC(0xB74F46), IC(0x3F669E), IC(0x5FEA2D), IC(0x7527BA), IC(0xC7EBE5),
		IC(0xF17B3D), IC(0x0739F7), IC(0x8A5292), IC(0xEA6BFB), IC(0x5FB11F), IC(0x8D5D08),
		IC(0x560330), IC(0x46FC7B), IC(0x6BABF0), IC(0xCFBC20), IC(0x9AF436), IC(0x1DA9E3),
		IC(0x91615E), IC(0xE61B08), IC(0x659985), IC(0x5F14A0), IC(0x68408D), IC(0xFFD880),
		IC(0x4D7327), IC(0x310606), IC(0x1556CA), IC(0x73A8C9), IC(0x60E27B), IC(0xC08C6B)
	};

	static const double zero = 0.0;
	static const double one = 1.0;
	static const double two24 = 1.67772160000000000000e+07;		/* 0x41700000, 0x00000000 */
	static const double twon24 = 5.96046447753906250000e-08;	/* 0x3E700000, 0x00000000 */

	/* initialize jk */
	jk = init_jk[prec];
	jp = jk;

	/* determine jx,jv,q0, note that 3>q0 */
	jx = nx - 1;
	jv = (e0 - 3) / 24;
	if (jv < 0)
		jv = 0;
	q0 = e0 - 24 * (jv + 1);

	/* set up f[0] to f[jx+jk] where f[jx+jk] = two_over_pi[jv+jk] */
	j = jv - jx;
	m = jx + jk;
	for (i = 0; i <= m; i++, j++)
		f[i] = (j < 0) ? zero : (double) two_over_pi[j];

	/* compute q[0],q[1],...q[jk] */
	for (i = 0; i <= jk; i++)
	{
		for (j = 0, fw = 0.0; j <= jx; j++)
			fw += x[j] * f[jx + i - j];
		q[i] = fw;
	}

	jz = jk;
  recompute:
	/* distill q[] into iq[] reversingly */
	for (i = 0, j = jz, z = q[jz]; j > 0; i++, j--)
	{
		fw = (double) ((int32_t) (twon24 * z));
		iq[i] = (int32_t) (z - two24 * fw);
		z = q[j - 1] + fw;
	}

	/* compute n */
	z = __ieee754_scalbn(z, (int)q0);				/* actual value of z */
	z -= 8.0 * __ieee754_floor(z * 0.125);		/* trim off integer >= 8 */
	n = (int32_t) z;
	z -= (double) n;
	ih = 0;
	if (q0 > 0)
	{									/* need iq[jz-1] to determine n */
		i = (iq[jz - 1] >> (24 - q0));
		n += i;
		iq[jz - 1] -= i << (24 - q0);
		ih = iq[jz - 1] >> (23 - q0);
	} else if (q0 == 0)
	{
		ih = iq[jz - 1] >> 23;
	} else if (z >= 0.5)
	{
		ih = 2;
	}

	if (ih > 0)
	{									/* q > 0.5 */
		n += 1;
		carry = 0;
		for (i = 0; i < jz; i++)
		{								/* compute 1-q */
			j = iq[i];
			if (carry == 0)
			{
				if (j != 0)
				{
					carry = 1;
					iq[i] = IC(0x1000000) - j;
				}
			} else
				iq[i] = IC(0xffffff) - j;
		}
		if (q0 > 0)
		{								/* rare case: chance is 1 in 12 */
			switch ((int)q0)
			{
			case 1:
				iq[jz - 1] &= IC(0x7fffff);
				break;
			case 2:
				iq[jz - 1] &= IC(0x3fffff);
				break;
			}
		}
		if (ih == 2)
		{
			z = one - z;
			if (carry != 0)
				z -= __ieee754_scalbn(one, (int)q0);
		}
	}

	/* check if recomputation is needed */
	if (z == zero)
	{
		j = 0;
		for (i = jz - 1; i >= jk; i--)
			j |= iq[i];
		if (j == 0)
		{								/* need recomputation */
			for (k = 1; iq[jk - k] == 0; k++)	/* k = no. of terms needed */
				;
			for (i = jz + 1; i <= jz + k; i++)
			{							/* add q[jz+1] to q[jz+k] */
				f[jx + i] = (double) two_over_pi[jv + i];
				for (j = 0, fw = 0.0; j <= jx; j++)
					fw += x[j] * f[jx + i - j];
				q[i] = fw;
			}
			jz += k;
			goto recompute;
		}
	}

	/* chop off zero terms */
	if (z == 0.0)
	{
		jz -= 1;
		q0 -= 24;
		while (iq[jz] == 0)
		{
			jz--;
			q0 -= 24;
		}
	} else
	{									/* break z into 24-bit if necessary */
		z = __ieee754_scalbn(z, (int)-q0);
		if (z >= two24)
		{
			fw = (double) ((int32_t) (twon24 * z));
			iq[jz] = (int32_t) (z - two24 * fw);
			jz += 1;
			q0 += 24;
			iq[jz] = (int32_t) fw;
		} else
		{
			iq[jz] = (int32_t) z;
		}
	}

	/* convert integer "bit" chunk to floating-point value */
	fw = __ieee754_scalbn(one, (int)q0);
	for (i = jz; i >= 0; i--)
	{
		q[i] = fw * (double) iq[i];
		fw *= twon24;
	}

	/* compute PIo2[0,...,jp]*q[jz,...,0] */
	for (i = jz; i >= 0; i--)
	{
		for (fw = 0.0, k = 0; k <= jp && k <= jz - i; k++)
			fw += PIo2[k] * q[i + k];
		fq[jz - i] = fw;
	}

	/* compress fq[] into y[] */
	switch (prec)
	{
	case 0:
		fw = 0.0;
		for (i = jz; i >= 0; i--)
			fw += fq[i];
		y[0] = (ih == 0) ? fw : -fw;
		break;
	case 1:
	case 2:
		{
			volatile double fv = 0.0;

			for (i = jz; i >= 0; i--)
				fv += fq[i];
			y[0] = (ih == 0) ? fv : -fv;
			fv = fq[0] - fv;
			for (i = 1; i <= jz; i++)
				fv += fq[i];
			y[1] = (ih == 0) ? fv : -fv;
		}
		break;
	case 3:							/* painful */
		for (i = jz; i > 0; i--)
		{
			volatile double fv = (double) (fq[i - 1] + fq[i]);

			fq[i] += fq[i - 1] - fv;
			fq[i - 1] = fv;
		}
		for (i = jz; i > 1; i--)
		{
			volatile double fv = (double) (fq[i - 1] + fq[i]);

			fq[i] += fq[i - 1] - fv;
			fq[i - 1] = fv;
		}
		for (fw = 0.0, i = jz; i >= 2; i--)
			fw += fq[i];
		if (ih == 0)
		{
			y[0] = fq[0];
			y[1] = fq[1];
			y[2] = fw;
		} else
		{
			y[0] = -fq[0];
			y[1] = -fq[1];
			y[2] = -fw;
		}
	}
	return n & 7;
}

```

`k_rem_pio2f.c`:

```c
/* k_rem_pio2f.c -- float version of k_rem_pio2.c
 * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif


int32_t __kernel_rem_pio2f(float *x, float *y, int32_t e0, int32_t nx, int prec)
{
	int32_t jz, jx, jv, jp, jk, carry, n, iq[20], i, j, k, m, q0, ih;
	float z, fw, f[20], fq[20], q[20];

	/* In the float version, the input parameter x contains 8 bit
	   integers, not 24 bit integers.  113 bit precision is not supported.  */
	
	static int const init_jk[] = { 4, 7, 9 };	/* initial value for jk */
	
	static float const PIo2[] = {
		1.5703125000e+00,					/* 0x3fc90000 */
		4.5776367188e-04,					/* 0x39f00000 */
		2.5987625122e-05,					/* 0x37da0000 */
		7.5437128544e-08,					/* 0x33a20000 */
		6.0026650317e-11,					/* 0x2e840000 */
		7.3896444519e-13,					/* 0x2b500000 */
		5.3845816694e-15,					/* 0x27c20000 */
		5.6378512969e-18,					/* 0x22d00000 */
		8.3009228831e-20,					/* 0x1fc40000 */
		3.2756352257e-22,					/* 0x1bc60000 */
		6.3331015649e-25					/* 0x17440000 */
	};
	
	static float const zero = 0.0;
	static float const one = 1.0;
	static float const two8 = 2.5600000000e+02;			/* 0x43800000 */
	static float const twon8 = 3.9062500000e-03;		/* 0x3b800000 */

	/*
	 * Table of constants for 2/pi, 396 Hex digits (476 decimal) of 2/pi
	 */
	static int32_t const two_over_pi[] = {
		0xA2, 0xF9, 0x83, 0x6E, 0x4E, 0x44, 0x15, 0x29, 0xFC,
		0x27, 0x57, 0xD1, 0xF5, 0x34, 0xDD, 0xC0, 0xDB, 0x62,
		0x95, 0x99, 0x3C, 0x43, 0x90, 0x41, 0xFE, 0x51, 0x63,
		0xAB, 0xDE, 0xBB, 0xC5, 0x61, 0xB7, 0x24, 0x6E, 0x3A,
		0x42, 0x4D, 0xD2, 0xE0, 0x06, 0x49, 0x2E, 0xEA, 0x09,
		0xD1, 0x92, 0x1C, 0xFE, 0x1D, 0xEB, 0x1C, 0xB1, 0x29,
		0xA7, 0x3E, 0xE8, 0x82, 0x35, 0xF5, 0x2E, 0xBB, 0x44,
		0x84, 0xE9, 0x9C, 0x70, 0x26, 0xB4, 0x5F, 0x7E, 0x41,
		0x39, 0x91, 0xD6, 0x39, 0x83, 0x53, 0x39, 0xF4, 0x9C,
		0x84, 0x5F, 0x8B, 0xBD, 0xF9, 0x28, 0x3B, 0x1F, 0xF8,
		0x97, 0xFF, 0xDE, 0x05, 0x98, 0x0F, 0xEF, 0x2F, 0x11,
		0x8B, 0x5A, 0x0A, 0x6D, 0x1F, 0x6D, 0x36, 0x7E, 0xCF,
		0x27, 0xCB, 0x09, 0xB7, 0x4F, 0x46, 0x3F, 0x66, 0x9E,
		0x5F, 0xEA, 0x2D, 0x75, 0x27, 0xBA, 0xC7, 0xEB, 0xE5,
		0xF1, 0x7B, 0x3D, 0x07, 0x39, 0xF7, 0x8A, 0x52, 0x92,
		0xEA, 0x6B, 0xFB, 0x5F, 0xB1, 0x1F, 0x8D, 0x5D, 0x08,
		0x56, 0x03, 0x30, 0x46, 0xFC, 0x7B, 0x6B, 0xAB, 0xF0,
		0xCF, 0xBC, 0x20, 0x9A, 0xF4, 0x36, 0x1D, 0xA9, 0xE3,
		0x91, 0x61, 0x5E, 0xE6, 0x1B, 0x08, 0x65, 0x99, 0x85,
		0x5F, 0x14, 0xA0, 0x68, 0x40, 0x8D, 0xFF, 0xD8, 0x80,
		0x4D, 0x73, 0x27, 0x31, 0x06, 0x06, 0x15, 0x56, 0xCA,
		0x73, 0xA8, 0xC9, 0x60, 0xE2, 0x7B, 0xC0, 0x8C, 0x6B
	};

	/* initialize jk */
	jk = init_jk[prec];
	jp = jk;

	/* determine jx,jv,q0, note that 3>q0 */
	jx = nx - 1;
	jv = (e0 - 3) / 8;
	if (jv < 0)
		jv = 0;
	q0 = e0 - 8 * (jv + 1);

	/* set up f[0] to f[jx+jk] where f[jx+jk] = two_over_pi[jv+jk] */
	j = jv - jx;
	m = jx + jk;
	for (i = 0; i <= m; i++, j++)
		f[i] = (j < 0) ? zero : (float) two_over_pi[j];

	/* compute q[0],q[1],...q[jk] */
	for (i = 0; i <= jk; i++)
	{
		for (j = 0, fw = 0.0; j <= jx; j++)
			fw += x[j] * f[jx + i - j];
		q[i] = fw;
	}

	jz = jk;
  recompute:
	/* distill q[] into iq[] reversingly */
	for (i = 0, j = jz, z = q[jz]; j > 0; i++, j--)
	{
		fw = (float) ((int32_t) (twon8 * z));
		iq[i] = (int32_t) (z - two8 * fw);
		z = q[j - 1] + fw;
	}

	/* compute n */
	z = __ieee754_scalbnf(z, (int)q0);				/* actual value of z */
	z -= (float) 8.0 * __ieee754_floorf(z * (float) 0.125);	/* trim off integer >= 8 */

	n = (int32_t) z;
	z -= (float) n;
	ih = 0;
	if (q0 > 0)
	{									/* need iq[jz-1] to determine n */
		i = (iq[jz - 1] >> (8 - q0));
		n += i;
		iq[jz - 1] -= i << (8 - q0);
		ih = iq[jz - 1] >> (7 - q0);
	} else if (q0 == 0)
	{
		ih = iq[jz - 1] >> 7;
	} else if (z >= (float) 0.5)
	{
		ih = 2;
	}
	
	if (ih > 0)
	{									/* q > 0.5 */
		n += 1;
		carry = 0;
		for (i = 0; i < jz; i++)
		{								/* compute 1-q */
			j = iq[i];
			if (carry == 0)
			{
				if (j != 0)
				{
					carry = 1;
					iq[i] = 0x100 - j;
				}
			} else
				iq[i] = 0xff - j;
		}
		if (q0 > 0)
		{								/* rare case: chance is 1 in 12 */
			switch ((int)q0)
			{
			case 1:
				iq[jz - 1] &= 0x7f;
				break;
			case 2:
				iq[jz - 1] &= 0x3f;
				break;
			}
		}
		if (ih == 2)
		{
			z = one - z;
			if (carry != 0)
				z -= __ieee754_scalbnf(one, (int)q0);
		}
	}

	/* check if recomputation is needed */
	if (z == zero)
	{
		j = 0;
		for (i = jz - 1; i >= jk; i--)
			j |= iq[i];
		if (j == 0)
		{								/* need recomputation */
			for (k = 1; iq[jk - k] == 0; k++) ;	/* k = no. of terms needed */

			for (i = jz + 1; i <= jz + k; i++)
			{							/* add q[jz+1] to q[jz+k] */
				f[jx + i] = (float) two_over_pi[jv + i];
				for (j = 0, fw = 0.0; j <= jx; j++)
					fw += x[j] * f[jx + i - j];
				q[i] = fw;
			}
			jz += k;
			goto recompute;
		}
	}

	/* chop off zero terms */
	if (z == (float) 0.0)
	{
		jz -= 1;
		q0 -= 8;
		while (iq[jz] == 0)
		{
			jz--;
			q0 -= 8;
		}
	} else
	{									/* break z into 8-bit if necessary */
		z = __ieee754_scalbnf(z, (int)-q0);
		if (z >= two8)
		{
			fw = (float) ((int32_t) (twon8 * z));
			iq[jz] = (int32_t) (z - two8 * fw);
			jz += 1;
			q0 += 8;
			iq[jz] = (int32_t) fw;
		} else
		{
			iq[jz] = (int32_t) z;
		}
	}

	/* convert integer "bit" chunk to floating-point value */
	fw = __ieee754_scalbnf(one, (int)q0);
	for (i = jz; i >= 0; i--)
	{
		q[i] = fw * (float) iq[i];
		fw *= twon8;
	}

	/* compute PIo2[0,...,jp]*q[jz,...,0] */
	for (i = jz; i >= 0; i--)
	{
		for (fw = 0.0, k = 0; k <= jp && k <= jz - i; k++)
			fw += PIo2[k] * q[i + k];
		fq[jz - i] = fw;
	}

	/* compress fq[] into y[] */
	switch (prec)
	{
	case 0:
		fw = 0.0;
		for (i = jz; i >= 0; i--)
			fw += fq[i];
		y[0] = (ih == 0) ? fw : -fw;
		break;
	case 1:
	case 2:
		{
			volatile float fv = 0.0;
	
			for (i = jz; i >= 0; i--)
				fv += fq[i];
			y[0] = (ih == 0) ? fv : -fv;
			fv = fq[0] - fv;
			for (i = 1; i <= jz; i++)
				fv += fq[i];
			y[1] = (ih == 0) ? fv : -fv;
		}
		break;
	case 3:							/* painful */
		for (i = jz; i > 0; i--)
		{
			volatile float fv = fq[i - 1] + fq[i];

			fq[i] += fq[i - 1] - fv;
			fq[i - 1] = fv;
		}
		for (i = jz; i > 1; i--)
		{
			volatile float fv = fq[i - 1] + fq[i];

			fq[i] += fq[i - 1] - fv;
			fq[i - 1] = fv;
		}
		for (fw = 0.0, i = jz; i >= 2; i--)
			fw += fq[i];
		if (ih == 0)
		{
			y[0] = fq[0];
			y[1] = fq[1];
			y[2] = fw;
		} else
		{
			y[0] = -fq[0];
			y[1] = -fq[1];
			y[2] = -fw;
		}
	}
	return n & 7;
}

```

`k_rem_pio2l.c`:

```c
/* @(#)k_rem_pio2.c 5.1 93/09/24 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/*
 * __kernel_rem_pio2(x,y,e0,nx,prec,ipio2)
 * double x[],y[]; int e0,nx,prec; int ipio2[];
 *
 * __kernel_rem_pio2 return the last three digits of N with
 *		y = x - N*pi/2
 * so that |y| < pi/2.
 *
 * The method is to compute the integer (mod 8) and fraction parts of
 * (2/pi)*x without doing the full multiplication. In general we
 * skip the part of the product that are known to be a huge integer (
 * more accurately, = 0 mod 8 ). Thus the number of operations are
 * independent of the exponent of the input.
 *
 * (2/pi) is represented by an array of 24-bit integers in ipio2[].
 *
 * Input parameters:
 * 	x[]	The input value (must be positive) is broken into nx
 *		pieces of 24-bit integers in double precision format.
 *		x[i] will be the i-th 24 bit of x. The scaled exponent
 *		of x[0] is given in input parameter e0 (i.e., x[0]*2^e0
 *		match x's up to 24 bits.
 *
 *		Example of breaking a double positive z into x[0]+x[1]+x[2]:
 *			e0 = ilogb(z)-23
 *			z  = scalbn(z,-e0)
 *		for i = 0,1,2
 *			x[i] = floor(z)
 *			z    = (z-x[i])*2**24
 *
 *
 *	y[]	ouput result in an array of double precision numbers.
 *		The dimension of y[] is:
 *			24-bit  precision	1
 *			53-bit  precision	2
 *			64-bit  precision	2
 *			113-bit precision	3
 *		The actual value is the sum of them. Thus for 113-bit
 *		precision, one may have to do something like:
 *
 *		long double t,w,r_head, r_tail;
 *		t = (long double)y[2] + (long double)y[1];
 *		w = (long double)y[0];
 *		r_head = t+w;
 *		r_tail = w - (r_head - t);
 *
 *	e0	The exponent of x[0]
 *
 *	nx	dimension of x[]
 *
 *  	prec	an integer indicating the precision:
 *			0	24  bits (single)
 *			1	53  bits (double)
 *			2	64  bits (extended)
 *			3	113 bits (quad)
 *
 *	ipio2[]
 *		integer array, contains the (24*i)-th to (24*i+23)-th
 *		bit of 2/pi after binary point. The corresponding
 *		floating value is
 *
 *			ipio2[i] * 2^(-24(i+1)).
 *
 * External function:
 *	double scalbn(), floor();
 *
 *
 * Here is the description of some local variables:
 *
 * 	jk	jk+1 is the initial number of terms of ipio2[] needed
 *		in the computation. The recommended value is 2,3,4,
 *		6 for single, double, extended,and quad.
 *
 * 	jz	local integer variable indicating the number of
 *		terms of ipio2[] used.
 *
 *	jx	nx - 1
 *
 *	jv	index for pointing to the suitable ipio2[] for the
 *		computation. In general, we want
 *			( 2^e0*x[0] * ipio2[jv-1]*2^(-24jv) )/8
 *		is an integer. Thus
 *			e0-3-24*jv >= 0 or (e0-3)/24 >= jv
 *		Hence jv = max(0,(e0-3)/24).
 *
 *	jp	jp+1 is the number of terms in PIo2[] needed, jp = jk.
 *
 * 	q[]	double array with integral value, representing the
 *		24-bits chunk of the product of x and 2/pi.
 *
 *	q0	the corresponding exponent of q[0]. Note that the
 *		exponent for q[i] would be q0-24*i.
 *
 *	PIo2[]	double precision array, obtained by cutting pi/2
 *		into 24 bits chunks.
 *
 *	f[]	ipio2[] in floating point
 *
 *	iq[]	integer array by breaking up q[] in 24-bits chunk.
 *
 *	fq[]	final product of x*(2/pi) in fq[0],..,fq[jk]
 *
 *	ih	integer. If >0 it indicates q[] is >= 0.5, hence
 *		it also indicates the *sign* of the result.
 *
 */


#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif


int32_t __kernel_rem_pio2l(double *x, double *y, int32_t e0, int32_t nx, int prec)
{
	int32_t jz, jx, jv, jp, jk, carry, n, iq[20], i, j, k, m, q0, ih;
	double z, fw, f[20], fq[20], q[20];

	static const int init_jk[] = { 2, 3, 4, 6 };	/* initial value for jk */
	
	/*
	 * Constants:
	 * The hexadecimal values are the intended ones for the following
	 * constants. The decimal values may be used, provided that the
	 * compiler will convert from decimal to binary accurately enough
	 * to produce the hexadecimal values shown.
	 */
	
	static const double PIo2[] = {
		1.57079625129699707031e+00,			/* 0x3FF921FB, 0x40000000 */
		7.54978941586159635335e-08,			/* 0x3E74442D, 0x00000000 */
		5.39030252995776476554e-15,			/* 0x3CF84698, 0x80000000 */
		3.28200341580791294123e-22,			/* 0x3B78CC51, 0x60000000 */
		1.27065575308067607349e-29,			/* 0x39F01B83, 0x80000000 */
		1.22933308981111328932e-36,			/* 0x387A2520, 0x40000000 */
		2.73370053816464559624e-44,			/* 0x36E38222, 0x80000000 */
		2.16741683877804819444e-51			/* 0x3569F31D, 0x00000000 */
	};
	
	/*  Table of constants for 2/pi, 5628 hexadecimal digits of 2/pi.  */
	static const int32_t two_over_pi[] = {
		IC(0xa2f983), IC(0x6e4e44), IC(0x1529fc), IC(0x2757d1), IC(0xf534dd), IC(0xc0db62),
		IC(0x95993c), IC(0x439041), IC(0xfe5163), IC(0xabdebb), IC(0xc561b7), IC(0x246e3a),
		IC(0x424dd2), IC(0xe00649), IC(0x2eea09), IC(0xd1921c), IC(0xfe1deb), IC(0x1cb129),
		IC(0xa73ee8), IC(0x8235f5), IC(0x2ebb44), IC(0x84e99c), IC(0x7026b4), IC(0x5f7e41),
		IC(0x3991d6), IC(0x398353), IC(0x39f49c), IC(0x845f8b), IC(0xbdf928), IC(0x3b1ff8),
		IC(0x97ffde), IC(0x05980f), IC(0xef2f11), IC(0x8b5a0a), IC(0x6d1f6d), IC(0x367ecf),
		IC(0x27cb09), IC(0xb74f46), IC(0x3f669e), IC(0x5fea2d), IC(0x7527ba), IC(0xc7ebe5),
		IC(0xf17b3d), IC(0x0739f7), IC(0x8a5292), IC(0xea6bfb), IC(0x5fb11f), IC(0x8d5d08),
		IC(0x560330), IC(0x46fc7b), IC(0x6babf0), IC(0xcfbc20), IC(0x9af436), IC(0x1da9e3),
		IC(0x91615e), IC(0xe61b08), IC(0x659985), IC(0x5f14a0), IC(0x68408d), IC(0xffd880),
		IC(0x4d7327), IC(0x310606), IC(0x1556ca), IC(0x73a8c9), IC(0x60e27b), IC(0xc08c6b),
		IC(0x47c419), IC(0xc367cd), IC(0xdce809), IC(0x2a8359), IC(0xc4768b), IC(0x961ca6),
		IC(0xddaf44), IC(0xd15719), IC(0x053ea5), IC(0xff0705), IC(0x3f7e33), IC(0xe832c2),
		IC(0xde4f98), IC(0x327dbb), IC(0xc33d26), IC(0xef6b1e), IC(0x5ef89f), IC(0x3a1f35),
		IC(0xcaf27f), IC(0x1d87f1), IC(0x21907c), IC(0x7c246a), IC(0xfa6ed5), IC(0x772d30),
		IC(0x433b15), IC(0xc614b5), IC(0x9d19c3), IC(0xc2c4ad), IC(0x414d2c), IC(0x5d000c),
		IC(0x467d86), IC(0x2d71e3), IC(0x9ac69b), IC(0x006233), IC(0x7cd2b4), IC(0x97a7b4),
		IC(0xd55537), IC(0xf63ed7), IC(0x1810a3), IC(0xfc764d), IC(0x2a9d64), IC(0xabd770),
		IC(0xf87c63), IC(0x57b07a), IC(0xe71517), IC(0x5649c0), IC(0xd9d63b), IC(0x3884a7),
		IC(0xcb2324), IC(0x778ad6), IC(0x23545a), IC(0xb91f00), IC(0x1b0af1), IC(0xdfce19),
		IC(0xff319f), IC(0x6a1e66), IC(0x615799), IC(0x47fbac), IC(0xd87f7e), IC(0xb76522),
		IC(0x89e832), IC(0x60bfe6), IC(0xcdc4ef), IC(0x09366c), IC(0xd43f5d), IC(0xd7de16),
		IC(0xde3b58), IC(0x929bde), IC(0x2822d2), IC(0xe88628), IC(0x4d58e2), IC(0x32cac6),
		IC(0x16e308), IC(0xcb7de0), IC(0x50c017), IC(0xa71df3), IC(0x5be018), IC(0x34132e),
		IC(0x621283), IC(0x014883), IC(0x5b8ef5), IC(0x7fb0ad), IC(0xf2e91e), IC(0x434a48),
		IC(0xd36710), IC(0xd8ddaa), IC(0x425fae), IC(0xce616a), IC(0xa4280a), IC(0xb499d3),
		IC(0xf2a606), IC(0x7f775c), IC(0x83c2a3), IC(0x883c61), IC(0x78738a), IC(0x5a8caf),
		IC(0xbdd76f), IC(0x63a62d), IC(0xcbbff4), IC(0xef818d), IC(0x67c126), IC(0x45ca55),
		IC(0x36d9ca), IC(0xd2a828), IC(0x8d61c2), IC(0x77c912), IC(0x142604), IC(0x9b4612),
		IC(0xc459c4), IC(0x44c5c8), IC(0x91b24d), IC(0xf31700), IC(0xad43d4), IC(0xe54929),
		IC(0x10d5fd), IC(0xfcbe00), IC(0xcc941e), IC(0xeece70), IC(0xf53e13), IC(0x80f1ec),
		IC(0xc3e7b3), IC(0x28f8c7), IC(0x940593), IC(0x3e71c1), IC(0xb3092e), IC(0xf3450b),
		IC(0x9c1288), IC(0x7b20ab), IC(0x9fb52e), IC(0xc29247), IC(0x2f327b), IC(0x6d550c),
		IC(0x90a772), IC(0x1fe76b), IC(0x96cb31), IC(0x4a1679), IC(0xe27941), IC(0x89dff4),
		IC(0x9794e8), IC(0x84e6e2), IC(0x973199), IC(0x6bed88), IC(0x365f5f), IC(0x0efdbb),
		IC(0xb49a48), IC(0x6ca467), IC(0x427271), IC(0x325d8d), IC(0xb8159f), IC(0x09e5bc),
		IC(0x25318d), IC(0x3974f7), IC(0x1c0530), IC(0x010c0d), IC(0x68084b), IC(0x58ee2c),
		IC(0x90aa47), IC(0x02e774), IC(0x24d6bd), IC(0xa67df7), IC(0x72486e), IC(0xef169f),
		IC(0xa6948e), IC(0xf691b4), IC(0x5153d1), IC(0xf20acf), IC(0x339820), IC(0x7e4bf5),
		IC(0x6863b2), IC(0x5f3edd), IC(0x035d40), IC(0x7f8985), IC(0x295255), IC(0xc06437),
		IC(0x10d86d), IC(0x324832), IC(0x754c5b), IC(0xd4714e), IC(0x6e5445), IC(0xc1090b),
		IC(0x69f52a), IC(0xd56614), IC(0x9d0727), IC(0x50045d), IC(0xdb3bb4), IC(0xc576ea),
		IC(0x17f987), IC(0x7d6b49), IC(0xba271d), IC(0x296996), IC(0xacccc6), IC(0x5414ad),
		IC(0x6ae290), IC(0x89d988), IC(0x50722c), IC(0xbea404), IC(0x940777), IC(0x7030f3),
		IC(0x27fc00), IC(0xa871ea), IC(0x49c266), IC(0x3de064), IC(0x83dd97), IC(0x973fa3),
		IC(0xfd9443), IC(0x8c860d), IC(0xde4131), IC(0x9d3992), IC(0x8c70dd), IC(0xe7b717),
		IC(0x3bdf08), IC(0x2b3715), IC(0xa0805c), IC(0x93805a), IC(0x921110), IC(0xd8e80f),
		IC(0xaf806c), IC(0x4bffdb), IC(0x0f9038), IC(0x761859), IC(0x15a562), IC(0xbbcb61),
		IC(0xb989c7), IC(0xbd4010), IC(0x04f2d2), IC(0x277549), IC(0xf6b6eb), IC(0xbb22db),
		IC(0xaa140a), IC(0x2f2689), IC(0x768364), IC(0x333b09), IC(0x1a940e), IC(0xaa3a51),
		IC(0xc2a31d), IC(0xaeedaf), IC(0x12265c), IC(0x4dc26d), IC(0x9c7a2d), IC(0x9756c0),
		IC(0x833f03), IC(0xf6f009), IC(0x8c402b), IC(0x99316d), IC(0x07b439), IC(0x15200c),
		IC(0x5bc3d8), IC(0xc492f5), IC(0x4badc6), IC(0xa5ca4e), IC(0xcd37a7), IC(0x36a9e6),
		IC(0x9492ab), IC(0x6842dd), IC(0xde6319), IC(0xef8c76), IC(0x528b68), IC(0x37dbfc),
		IC(0xaba1ae), IC(0x3115df), IC(0xa1ae00), IC(0xdafb0c), IC(0x664d64), IC(0xb705ed),
		IC(0x306529), IC(0xbf5657), IC(0x3aff47), IC(0xb9f96a), IC(0xf3be75), IC(0xdf9328),
		IC(0x3080ab), IC(0xf68c66), IC(0x15cb04), IC(0x0622fa), IC(0x1de4d9), IC(0xa4b33d),
		IC(0x8f1b57), IC(0x09cd36), IC(0xe9424e), IC(0xa4be13), IC(0xb52333), IC(0x1aaaf0),
		IC(0xa8654f), IC(0xa5c1d2), IC(0x0f3f0b), IC(0xcd785b), IC(0x76f923), IC(0x048b7b),
		IC(0x721789), IC(0x53a6c6), IC(0xe26e6f), IC(0x00ebef), IC(0x584a9b), IC(0xb7dac4),
		IC(0xba66aa), IC(0xcfcf76), IC(0x1d02d1), IC(0x2df1b1), IC(0xc1998c), IC(0x77adc3),
		IC(0xda4886), IC(0xa05df7), IC(0xf480c6), IC(0x2ff0ac), IC(0x9aecdd), IC(0xbc5c3f),
		IC(0x6dded0), IC(0x1fc790), IC(0xb6db2a), IC(0x3a25a3), IC(0x9aaf00), IC(0x9353ad),
		IC(0x0457b6), IC(0xb42d29), IC(0x7e804b), IC(0xa707da), IC(0x0eaa76), IC(0xa1597b),
		IC(0x2a1216), IC(0x2db7dc), IC(0xfde5fa), IC(0xfedb89), IC(0xfdbe89), IC(0x6c76e4),
		IC(0xfca906), IC(0x70803e), IC(0x156e85), IC(0xff87fd), IC(0x073e28), IC(0x336761),
		IC(0x86182a), IC(0xeabd4d), IC(0xafe7b3), IC(0x6e6d8f), IC(0x396795), IC(0x5bbf31),
		IC(0x48d784), IC(0x16df30), IC(0x432dc7), IC(0x356125), IC(0xce70c9), IC(0xb8cb30),
		IC(0xfd6cbf), IC(0xa200a4), IC(0xe46c05), IC(0xa0dd5a), IC(0x476f21), IC(0xd21262),
		IC(0x845cb9), IC(0x496170), IC(0xe0566b), IC(0x015299), IC(0x375550), IC(0xb7d51e),
		IC(0xc4f133), IC(0x5f6e13), IC(0xe4305d), IC(0xa92e85), IC(0xc3b21d), IC(0x3632a1),
		IC(0xa4b708), IC(0xd4b1ea), IC(0x21f716), IC(0xe4698f), IC(0x77ff27), IC(0x80030c),
		IC(0x2d408d), IC(0xa0cd4f), IC(0x99a520), IC(0xd3a2b3), IC(0x0a5d2f), IC(0x42f9b4),
		IC(0xcbda11), IC(0xd0be7d), IC(0xc1db9b), IC(0xbd17ab), IC(0x81a2ca), IC(0x5c6a08),
		IC(0x17552e), IC(0x550027), IC(0xf0147f), IC(0x8607e1), IC(0x640b14), IC(0x8d4196),
		IC(0xdebe87), IC(0x2afdda), IC(0xb6256b), IC(0x34897b), IC(0xfef305), IC(0x9ebfb9),
		IC(0x4f6a68), IC(0xa82a4a), IC(0x5ac44f), IC(0xbcf82d), IC(0x985ad7), IC(0x95c7f4),
		IC(0x8d4d0d), IC(0xa63a20), IC(0x5f57a4), IC(0xb13f14), IC(0x953880), IC(0x0120cc),
		IC(0x86dd71), IC(0xb6dec9), IC(0xf560bf), IC(0x11654d), IC(0x6b0701), IC(0xacb08c),
		IC(0xd0c0b2), IC(0x485551), IC(0x0efb1e), IC(0xc37295), IC(0x3b06a3), IC(0x3540c0),
		IC(0x7bdc06), IC(0xcc45e0), IC(0xfa294e), IC(0xc8cad6), IC(0x41f3e8), IC(0xde647c),
		IC(0xd8649b), IC(0x31bed9), IC(0xc397a4), IC(0xd45877), IC(0xc5e369), IC(0x13daf0),
		IC(0x3c3aba), IC(0x461846), IC(0x5f7555), IC(0xf5bdd2), IC(0xc6926e), IC(0x5d2eac),
		IC(0xed440e), IC(0x423e1c), IC(0x87c461), IC(0xe9fd29), IC(0xf3d6e7), IC(0xca7c22),
		IC(0x35916f), IC(0xc5e008), IC(0x8dd7ff), IC(0xe26a6e), IC(0xc6fdb0), IC(0xc10893),
		IC(0x745d7c), IC(0xb2ad6b), IC(0x9d6ecd), IC(0x7b723e), IC(0x6a11c6), IC(0xa9cff7),
		IC(0xdf7329), IC(0xbac9b5), IC(0x5100b7), IC(0x0db2e2), IC(0x24ba74), IC(0x607de5),
		IC(0x8ad874), IC(0x2c150d), IC(0x0c1881), IC(0x94667e), IC(0x162901), IC(0x767a9f),
		IC(0xbefdfd), IC(0xef4556), IC(0x367ed9), IC(0x13d9ec), IC(0xb9ba8b), IC(0xfc97c4),
		IC(0x27a831), IC(0xc36ef1), IC(0x36c594), IC(0x56a8d8), IC(0xb5a8b4), IC(0x0ecccf),
		IC(0x2d8912), IC(0x34576f), IC(0x89562c), IC(0xe3ce99), IC(0xb920d6), IC(0xaa5e6b),
		IC(0x9c2a3e), IC(0xcc5f11), IC(0x4a0bfd), IC(0xfbf4e1), IC(0x6d3b8e), IC(0x2c86e2),
		IC(0x84d4e9), IC(0xa9b4fc), IC(0xd1eeef), IC(0xc9352e), IC(0x61392f), IC(0x442138),
		IC(0xc8d91b), IC(0x0afc81), IC(0x6a4afb), IC(0xd81c2f), IC(0x84b453), IC(0x8c994e),
		IC(0xcc2254), IC(0xdc552a), IC(0xd6c6c0), IC(0x96190b), IC(0xb8701a), IC(0x649569),
		IC(0x605a26), IC(0xee523f), IC(0x0f117f), IC(0x11b5f4), IC(0xf5cbfc), IC(0x2dbc34),
		IC(0xeebc34), IC(0xcc5de8), IC(0x605edd), IC(0x9b8e67), IC(0xef3392), IC(0xb817c9),
		IC(0x9b5861), IC(0xbc57e1), IC(0xc68351), IC(0x103ed8), IC(0x4871dd), IC(0xdd1c2d),
		IC(0xa118af), IC(0x462c21), IC(0xd7f359), IC(0x987ad9), IC(0xc0549e), IC(0xfa864f),
		IC(0xfc0656), IC(0xae79e5), IC(0x362289), IC(0x22ad38), IC(0xdc9367), IC(0xaae855),
		IC(0x382682), IC(0x9be7ca), IC(0xa40d51), IC(0xb13399), IC(0x0ed7a9), IC(0x480569),
		IC(0xf0b265), IC(0xa7887f), IC(0x974c88), IC(0x36d1f9), IC(0xb39221), IC(0x4a827b),
		IC(0x21cf98), IC(0xdc9f40), IC(0x5547dc), IC(0x3a74e1), IC(0x42eb67), IC(0xdf9dfe),
		IC(0x5fd45e), IC(0xa4677b), IC(0x7aacba), IC(0xa2f655), IC(0x23882b), IC(0x55ba41),
		IC(0x086e59), IC(0x862a21), IC(0x834739), IC(0xe6e389), IC(0xd49ee5), IC(0x40fb49),
		IC(0xe956ff), IC(0xca0f1c), IC(0x8a59c5), IC(0x2bfa94), IC(0xc5c1d3), IC(0xcfc50f),
		IC(0xae5adb), IC(0x86c547), IC(0x624385), IC(0x3b8621), IC(0x94792c), IC(0x876110),
		IC(0x7b4c2a), IC(0x1a2c80), IC(0x12bf43), IC(0x902688), IC(0x893c78), IC(0xe4c4a8),
		IC(0x7bdbe5), IC(0xc23ac4), IC(0xeaf426), IC(0x8a67f7), IC(0xbf920d), IC(0x2ba365),
		IC(0xb1933d), IC(0x0b7cbd), IC(0xdc51a4), IC(0x63dd27), IC(0xdde169), IC(0x19949a),
		IC(0x9529a8), IC(0x28ce68), IC(0xb4ed09), IC(0x209f44), IC(0xca984e), IC(0x638270),
		IC(0x237c7e), IC(0x32b90f), IC(0x8ef5a7), IC(0xe75614), IC(0x08f121), IC(0x2a9db5),
		IC(0x4d7e6f), IC(0x5119a5), IC(0xabf9b5), IC(0xd6df82), IC(0x61dd96), IC(0x023616),
		IC(0x9f3ac4), IC(0xa1a283), IC(0x6ded72), IC(0x7a8d39), IC(0xa9b882), IC(0x5c326b),
		IC(0x5b2746), IC(0xed3400), IC(0x7700d2), IC(0x55f4fc), IC(0x4d5901), IC(0x8071e0),
		IC(0xe13f89), IC(0xb295f3), IC(0x64a8f1), IC(0xaea74b), IC(0x38fc4c), IC(0xeab2bb),
		IC(0x47270b), IC(0xabc3a7), IC(0x34ba60), IC(0x52dd34), IC(0xf8563a), IC(0xeb7e8a),
		IC(0x31bb36), IC(0x5895b7), IC(0x47f7a9), IC(0x94c3aa), IC(0xd39225), IC(0x1e7f3e),
		IC(0xd8974e), IC(0xbba94f), IC(0xd8ae01), IC(0xe661b4), IC(0x393d8e), IC(0xa523aa),
		IC(0x33068e), IC(0x1633b5), IC(0x3bb188), IC(0x1d3a9d), IC(0x4013d0), IC(0xcc1be5),
		IC(0xf862e7), IC(0x3bf28f), IC(0x39b5bf), IC(0x0bc235), IC(0x22747e), IC(0xa247c0),
		IC(0xd52d1f), IC(0x19add3), IC(0x9094df), IC(0x9311d0), IC(0xb42b25), IC(0x496db2),
		IC(0xe264b2), IC(0x5ef135), IC(0x3bc6a4), IC(0x1a4ad0), IC(0xaac92e), IC(0x64e886),
		IC(0x573091), IC(0x982cfb), IC(0x311b1a), IC(0x08728b), IC(0xbdcee1), IC(0x60e142),
		IC(0xeb641d), IC(0xd0bba3), IC(0xe559d4), IC(0x597b8c), IC(0x2a4483), IC(0xf332ba),
		IC(0xf84867), IC(0x2c8d1b), IC(0x2fa9b0), IC(0x50f3dd), IC(0xf9f573), IC(0xdb61b4),
		IC(0xfe233e), IC(0x6c41a6), IC(0xeea318), IC(0x775a26), IC(0xbc5e5c), IC(0xcea708),
		IC(0x94dc57), IC(0xe20196), IC(0xf1e839), IC(0xbe4851), IC(0x5d2d2f), IC(0x4e9555),
		IC(0xd96ec2), IC(0xe7d755), IC(0x6304e0), IC(0xc02e0e), IC(0xfc40a0), IC(0xbbf9b3),
		IC(0x7125a7), IC(0x222dfb), IC(0xf619d8), IC(0x838c1c), IC(0x6619e6), IC(0xb20d55),
		IC(0xbb5137), IC(0x79e809), IC(0xaf9149), IC(0x0d73de), IC(0x0b0da5), IC(0xce7f58),
		IC(0xac1934), IC(0x724667), IC(0x7a1a13), IC(0x9e26bc), IC(0x4555e7), IC(0x585cb5),
		IC(0x711d14), IC(0x486991), IC(0x480d60), IC(0x56adab), IC(0xd62f64), IC(0x96ee0c),
		IC(0x212ff3), IC(0x5d6d88), IC(0xa67684), IC(0x95651e), IC(0xab9e0a), IC(0x4ddefe),
		IC(0x571010), IC(0x836a39), IC(0xf8ea31), IC(0x9e381d), IC(0xeac8b1), IC(0xcac96b),
		IC(0x37f21e), IC(0xd505e9), IC(0x984743), IC(0x9fc56c), IC(0x0331b7), IC(0x3b8bf8),
		IC(0x86e56a), IC(0x8dc343), IC(0x6230e7), IC(0x93cfd5), IC(0x6a8f2d), IC(0x733005),
		IC(0x1af021), IC(0xa09fcb), IC(0x7415a1), IC(0xd56b23), IC(0x6ff725), IC(0x2f4bc7),
		IC(0xb8a591), IC(0x7fac59), IC(0x5c55de), IC(0x212c38), IC(0xb13296), IC(0x5cff50),
		IC(0x366262), IC(0xfa7b16), IC(0xf4d9a6), IC(0x2acfe7), IC(0xf07403), IC(0xd4d604),
		IC(0x6fd916), IC(0x31b1bf), IC(0xcbb450), IC(0x5bd7c8), IC(0x0ce194), IC(0x6bd643),
		IC(0x4fd91c), IC(0xdf4543), IC(0x5f3453), IC(0xe2b5aa), IC(0xc9aec8), IC(0x131485),
		IC(0xf9d2bf), IC(0xbadb9e), IC(0x76f5b9), IC(0xaf15cf), IC(0xca3182), IC(0x14b56d),
		IC(0xe9fe4d), IC(0x50fc35), IC(0xf5aed5), IC(0xa2d0c1), IC(0xc96057), IC(0x192eb6),
		IC(0xe91d92), IC(0x07d144), IC(0xaea3c6), IC(0x343566), IC(0x26d5b4), IC(0x3161e2),
		IC(0x37f1a2), IC(0x209eff), IC(0x958e23), IC(0x493798), IC(0x35f4a6), IC(0x4bdc02),
		IC(0xc2be13), IC(0xbe80a0), IC(0x0b72a3), IC(0x115c5f), IC(0x1e1bd1), IC(0x0db4d3),
		IC(0x869e85), IC(0x96976b), IC(0x2ac91f), IC(0x8a26c2), IC(0x3070f0), IC(0x041412),
		IC(0xfc9fa5), IC(0xf72a38), IC(0x9c6878), IC(0xe2aa76), IC(0x50cfe1), IC(0x559274),
		IC(0x934e38), IC(0x0a92f7), IC(0x5533f0), IC(0xa63db4), IC(0x399971), IC(0xe2b755),
		IC(0xa98a7c), IC(0x008f19), IC(0xac54d2), IC(0x2ea0b4), IC(0xf5f3e0), IC(0x60c849),
		IC(0xffd269), IC(0xae52ce), IC(0x7a5fdd), IC(0xe9ce06), IC(0xfb0ae8), IC(0xa50cce),
		IC(0xea9d3e), IC(0x3766dd), IC(0xb834f5), IC(0x0da090), IC(0x846f88), IC(0x4ae3d5),
		IC(0x099a03), IC(0x2eae2d), IC(0xfcb40a), IC(0xfb9b33), IC(0xe281dd), IC(0x1b16ba),
		IC(0xd8c0af), IC(0xd96b97), IC(0xb52dc9), IC(0x9c277f), IC(0x5951d5), IC(0x21ccd6),
		IC(0xb6496b), IC(0x584562), IC(0xb3baf2), IC(0xa1a5c4), IC(0x7ca2cf), IC(0xa9b93d),
		IC(0x7b7b89), IC(0x483d38)
	};

	static const double zero = 0.0;
	static const double one = 1.0;
	static const double two24 = 1.67772160000000000000e+07;		/* 0x41700000, 0x00000000 */
	static const double twon24 = 5.96046447753906250000e-08;	/* 0x3E700000, 0x00000000 */

	/* initialize jk */
	jk = init_jk[prec];
	jp = jk;

	/* determine jx,jv,q0, note that 3>q0 */
	jx = nx - 1;
	jv = (e0 - 3) / 24;
	if (jv < 0)
		jv = 0;
	q0 = e0 - 24 * (jv + 1);

	/* set up f[0] to f[jx+jk] where f[jx+jk] = two_over_pi[jv+jk] */
	j = jv - jx;
	m = jx + jk;
	for (i = 0; i <= m; i++, j++)
		f[i] = (j < 0) ? zero : (double) two_over_pi[j];

	/* compute q[0],q[1],...q[jk] */
	for (i = 0; i <= jk; i++)
	{
		for (j = 0, fw = 0.0; j <= jx; j++)
			fw += x[j] * f[jx + i - j];
		q[i] = fw;
	}

	jz = jk;
  recompute:
	/* distill q[] into iq[] reversingly */
	for (i = 0, j = jz, z = q[jz]; j > 0; i++, j--)
	{
		fw = (double) ((int32_t) (twon24 * z));
		iq[i] = (int32_t) (z - two24 * fw);
		z = q[j - 1] + fw;
	}

	/* compute n */
	z = __ieee754_scalbn(z, (int)q0);			/* actual value of z */
	z -= 8.0 * __ieee754_floor(z * 0.125);		/* trim off integer >= 8 */
	n = (int32_t) z;
	z -= (double) n;
	ih = 0;
	if (q0 > 0)
	{									/* need iq[jz-1] to determine n */
		i = (iq[jz - 1] >> (24 - q0));
		n += i;
		iq[jz - 1] -= i << (24 - q0);
		ih = iq[jz - 1] >> (23 - q0);
	} else if (q0 == 0)
	{
		ih = iq[jz - 1] >> 23;
	} else if (z >= 0.5)
	{
		ih = 2;
	}
	
	if (ih > 0)
	{									/* q > 0.5 */
		n += 1;
		carry = 0;
		for (i = 0; i < jz; i++)
		{								/* compute 1-q */
			j = iq[i];
			if (carry == 0)
			{
				if (j != 0)
				{
					carry = 1;
					iq[i] = IC(0x1000000) - j;
				}
			} else
				iq[i] = IC(0xffffff) - j;
		}
		if (q0 > 0)
		{								/* rare case: chance is 1 in 12 */
			switch ((int)q0)
			{
			case 1:
				iq[jz - 1] &= IC(0x7fffff);
				break;
			case 2:
				iq[jz - 1] &= IC(0x3fffff);
				break;
			}
		}
		if (ih == 2)
		{
			z = one - z;
			if (carry != 0)
				z -= __ieee754_scalbn(one, (int)q0);
		}
	}

	/* check if recomputation is needed */
	if (z == zero)
	{
		j = 0;
		for (i = jz - 1; i >= jk; i--)
			j |= iq[i];
		if (j == 0)
		{								/* need recomputation */
			for (k = 1; iq[jk - k] == 0; k++) ;	/* k = no. of terms needed */

			for (i = jz + 1; i <= jz + k; i++)
			{							/* add q[jz+1] to q[jz+k] */
				f[jx + i] = (double) two_over_pi[jv + i];
				for (j = 0, fw = 0.0; j <= jx; j++)
					fw += x[j] * f[jx + i - j];
				q[i] = fw;
			}
			jz += k;
			goto recompute;
		}
	}

	/* chop off zero terms */
	if (z == 0.0)
	{
		jz -= 1;
		q0 -= 24;
		while (iq[jz] == 0)
		{
			jz--;
			q0 -= 24;
		}
	} else
	{									/* break z into 24-bit if necessary */
		z = __ieee754_scalbn(z, (int)-q0);
		if (z >= two24)
		{
			fw = (double) ((int32_t) (twon24 * z));
			iq[jz] = (int32_t) (z - two24 * fw);
			jz += 1;
			q0 += 24;
			iq[jz] = (int32_t) fw;
		} else
		{
			iq[jz] = (int32_t) z;
		}
	}

	/* convert integer "bit" chunk to floating-point value */
	fw = __ieee754_scalbn(one, (int)q0);
	for (i = jz; i >= 0; i--)
	{
		q[i] = fw * (double) iq[i];
		fw *= twon24;
	}

	/* compute PIo2[0,...,jp]*q[jz,...,0] */
	for (i = jz; i >= 0; i--)
	{
		for (fw = 0.0, k = 0; k <= jp && k <= jz - i; k++)
			fw += PIo2[k] * q[i + k];
		fq[jz - i] = fw;
	}

	/* compress fq[] into y[] */
	switch (prec)
	{
	case 0:
		fw = 0.0;
		for (i = jz; i >= 0; i--)
			fw += fq[i];
		y[0] = (ih == 0) ? fw : -fw;
		break;
	case 1:
	case 2:
		{
			volatile double fv = 0.0;
	
			for (i = jz; i >= 0; i--)
				fv += fq[i];
			y[0] = (ih == 0) ? fv : -fv;
			fv = fq[0] - fv;
			for (i = 1; i <= jz; i++)
				fv += fq[i];
			y[1] = (ih == 0) ? fv : -fv;
		}
		break;
	case 3:							/* painful */
		for (i = jz; i > 0; i--)
		{
			volatile double fv = (double) (fq[i - 1] + fq[i]);

			fq[i] += fq[i - 1] - fv;
			fq[i - 1] = fv;
		}
		for (i = jz; i > 1; i--)
		{
			volatile double fv = (double) (fq[i - 1] + fq[i]);

			fq[i] += fq[i - 1] - fv;
			fq[i - 1] = fv;
		}
		for (fw = 0.0, i = jz; i >= 2; i--)
			fw += fq[i];
		if (ih == 0)
		{
			y[0] = fq[0];
			y[1] = fq[1];
			y[2] = fw;
		} else
		{
			y[0] = -fq[0];
			y[1] = -fq[1];
			y[2] = -fw;
		}
	}
	return n & 7;
}

```

`k_sin.c`:

```c
/* @(#)k_sin.c 1.3 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/* __kernel_sin( x, y, iy)
 * kernel sin function on [-pi/4, pi/4], pi/4 ~ 0.7854
 * Input x is assumed to be bounded by ~pi/4 in magnitude.
 * Input y is the tail of x.
 * Input iy indicates whether y is 0. (if iy=0, y assume to be 0). 
 *
 * Algorithm
 *	1. Since sin(-x) = -sin(x), we need only to consider positive x. 
 *	2. if x < 2^-27 (hx<0x3e400000 0), return x with inexact if x!=0.
 *	3. sin(x) is approximated by a polynomial of degree 13 on
 *	   [0,pi/4]
 *		  	         3            13
 *	   	sin(x) ~ x + S1*x + ... + S6*x
 *	   where
 *	
 * 	|sin(x)         2     4     6     8     10     12  |     -58
 * 	|----- - (1+S1*x +S2*x +S3*x +S4*x +S5*x  +S6*x   )| <= 2
 * 	|  x 					           | 
 * 
 *	4. sin(x+y) = sin(x) + sin'(x')*y
 *		    ~ sin(x) + (1-x*x/2)*y
 *	   For better accuracy, let 
 *		     3      2      2      2      2
 *		r = x *(S2+x *(S3+x *(S4+x *(S5+x *S6))))
 *	   then                   3    2
 *		sin(x) = x + (S1*x + (x *(r-y/2)+y))
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

double __kernel_sin(double x, double y, int iy)
{
	double z, r, v;
	int32_t ix;

	static const double half = 5.00000000000000000000e-01;	/* 0x3FE00000, 0x00000000 */
	static const double S1 = -1.66666666666666324348e-01;	/* 0xBFC55555, 0x55555549 */
	static const double S2 = 8.33333333332248946124e-03;	/* 0x3F811111, 0x1110F8A6 */
	static const double S3 = -1.98412698298579493134e-04;	/* 0xBF2A01A0, 0x19C161D5 */
	static const double S4 = 2.75573137070700676789e-06;	/* 0x3EC71DE3, 0x57B1FE7D */
	static const double S5 = -2.50507602534068634195e-08;	/* 0xBE5AE5E6, 0x8A2B9CEB */
	static const double S6 = 1.58969099521155010221e-10;	/* 0x3DE5D93A, 0x5ACFD57C */

	GET_HIGH_WORD(ix, x);
	ix &= IC(0x7fffffff);					/* high word of x */
	if (ix < IC(0x3e400000))				/* |x| < 2**-27 */
	{
		if ((int32_t) x == 0)
			return x;						/* generate inexact */
	}
	z = x * x;
	v = z * x;
	r = S2 + z * (S3 + z * (S4 + z * (S5 + z * S6)));
	if (iy == 0)
		return x + v * (S1 + z * r);
	else
		return x - ((z * (half * y - v * r) - y) - v * S1);
}

```

`k_sinf.c`:

```c
/* k_sinf.c -- float version of k_sin.c
 * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif


float __kernel_sinf(float x, float y, int iy)
{
	float z, r, v;
	int32_t ix;

	static const float half = 5.0000000000e-01;				/* 0x3f000000 */
	static const float S1 = -1.6666667163e-01;				/* 0xbe2aaaab */
	static const float S2 = 8.3333337680e-03;				/* 0x3c088889 */
	static const float S3 = -1.9841270114e-04;				/* 0xb9500d01 */
	static const float S4 = 2.7557314297e-06;				/* 0x3638ef1b */
	static const float S5 = -2.5050759689e-08;				/* 0xb2d72f34 */
	static const float S6 = 1.5896910177e-10;				/* 0x2f2ec9d3 */

	GET_FLOAT_WORD(ix, x);
	ix &= IC(0x7fffffff);				/* high word of x */
	if (ix < IC(0x32000000))			/* |x| < 2**-27 */
	{
		if ((int32_t) x == 0)
			return x;
	}									/* generate inexact */
	z = x * x;
	v = z * x;
	r = S2 + z * (S3 + z * (S4 + z * (S5 + z * S6)));
	if (iy == 0)
		return x + v * (S1 + z * r);
	else
		return x - ((z * (half * y - v * r) - y) - v * S1);
}

```

`k_sinl.c`:

```c
/* Quad-precision floating point sine on <-pi/4,pi/4>.
   Copyright (C) 1999-2013 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Based on quad-precision sine by Jakub Jelinek <jj@ultra.linux.cz>

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/* The polynomials have not been optimized for extended-precision and
   may contain more terms than needed.  */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

long double __kernel_sinl(long double x, long double y, int iy)
{
	long double absx, h, l, z, sin_l, cos_l_m1;
	int index;

	/* The polynomials have not been optimized for extended-precision and
	   may contain more terms than needed.  */
	
	static const long double ONE = 1.00000000000000000000000000000000000E+00L;
	
	/* cos x ~ ONE + x^2 ( SCOS1 + SCOS2 * x^2 + ... + SCOS4 * x^6 + SCOS5 * x^8 )
	   x in <0,1/256>  */
	static const long double SCOS1 = -5.00000000000000000000000000000000000E-01L;
	static const long double SCOS2 = 4.16666666666666666666666666556146073E-02L;
	static const long double SCOS3 = -1.38888888888888888888309442601939728E-03L;
	static const long double SCOS4 = 2.48015873015862382987049502531095061E-05L;
	static const long double SCOS5 = -2.75573112601362126593516899592158083E-07L;
	
	/* sin x ~ ONE * x + x^3 ( SIN1 + SIN2 * x^2 + ... + SIN7 * x^12 + SIN8 * x^14 )
	   x in <0,0.1484375>  */
	static const long double SIN1 = -1.66666666666666666666666666666666538e-01L;
	static const long double SIN2 = 8.33333333333333333333333333307532934e-03L;
	static const long double SIN3 = -1.98412698412698412698412534478712057e-04L;
	static const long double SIN4 = 2.75573192239858906520896496653095890e-06L;
	static const long double SIN5 = -2.50521083854417116999224301266655662e-08L;
	static const long double SIN6 = 1.60590438367608957516841576404938118e-10L;
	static const long double SIN7 = -7.64716343504264506714019494041582610e-13L;
	static const long double SIN8 = 2.81068754939739570236322404393398135e-15L;
	
	/* sin x ~ ONE * x + x^3 ( SSIN1 + SSIN2 * x^2 + ... + SSIN4 * x^6 + SSIN5 * x^8 )
	   x in <0,1/256>  */
	static const long double SSIN1 = -1.66666666666666666666666666666666659E-01L;
	static const long double SSIN2 = 8.33333333333333333333333333146298442E-03L;
	static const long double SSIN3 = -1.98412698412698412697726277416810661E-04L;
	static const long double SSIN4 = 2.75573192239848624174178393552189149E-06L;
	static const long double SSIN5 = -2.50521016467996193495359189395805639E-08L;
	
#define SINCOSL_COS_HI 0
#define SINCOSL_COS_LO 1
#define SINCOSL_SIN_HI 2
#define SINCOSL_SIN_LO 3

	absx = __ieee754_fabsl(x);
	if (absx < 0.1484375L)
	{
		/* Argument is small enough to approximate it by a Chebyshev
		   polynomial of degree 17.  */
		if (absx < 0x1p-33L)
			if (!((int32_t) x))
				return x;				/* generate inexact */
		z = x * x;
		return x + (x * (z * (SIN1 + z * (SIN2 + z * (SIN3 + z * (SIN4 +
																  z * (SIN5 + z * (SIN6 + z * (SIN7 + z * SIN8)))))))));
	} else
	{
		/* So that we don't have to use too large polynomial,  we find
		   l and h such that x = l + h,  where fabsl(l) <= 1.0/256 with 83
		   possible values for h.  We look up cosl(h) and sinl(h) in
		   pre-computed tables,  compute cosl(l) and sinl(l) using a
		   Chebyshev polynomial of degree 10(11) and compute
		   sinl(h+l) = sinl(h)cosl(l) + cosl(h)sinl(l).  */
		index = (int) (128 * (absx - (0.1484375L - 1.0L / 256.0L)));
		h = 0.1484375L + index / 128.0;
		index *= 4;
		if (iy)
			l = (x < 0 ? -y : y) - (h - absx);
		else
			l = absx - h;
		z = l * l;
		sin_l = l * (ONE + z * (SSIN1 + z * (SSIN2 + z * (SSIN3 + z * (SSIN4 + z * SSIN5)))));
		cos_l_m1 = z * (SCOS1 + z * (SCOS2 + z * (SCOS3 + z * (SCOS4 + z * SCOS5))));
		z = __sincosl_table[index + SINCOSL_SIN_HI]
			+ (__sincosl_table[index + SINCOSL_SIN_LO]
			   + (__sincosl_table[index + SINCOSL_SIN_HI] * cos_l_m1)
			   + (__sincosl_table[index + SINCOSL_COS_HI] * sin_l));
		return (x < 0) ? -z : z;
	}

#undef SINCOSL_COS_HI
#undef SINCOSL_COS_LO
#undef SINCOSL_SIN_HI
#undef SINCOSL_SIN_LO
}

```

`k_standard.c`:

```c
/* @(#)k_standard.c 1.3 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef _USE_WRITE
#include <stdio.h>						/* fputs(), stderr */
#define	WRITE2(u,v)	fputs(u, stderr)
#else /* !defined(_USE_WRITE) */
#include <unistd.h>						/* write */
#define	WRITE2(u,v)	write(2, u, v)
#undef fflush
#endif /* !defined(_USE_WRITE) */

/* if struct exception has err field...*/
#if defined(__CYGWIN__) || defined(__MSYS__)
#define reset_matherr_errno(exc) exc.err = 0
#define set_matherr_errno(exc) if (exc.err != 0) __set_errno(exc.err)
#else
#define reset_matherr_errno(exc) 
#define set_matherr_errno(exc) 
#endif

#ifndef HUGE
#  define HUGE HUGE_VAL
#endif

/*
 * Standard conformance (non-IEEE) on exception cases.
 * Mapping:
 *	1 -- acos(|x|>1)
 *	2 -- asin(|x|>1)
 *	3 -- atan2(+-0,+-0)
 *	4 -- hypot overflow
 *	5 -- cosh overflow
 *	6 -- exp overflow
 *	7 -- exp underflow
 *	8 -- y0(0)
 *	9 -- y0(x<0)
 *	10-- y1(0)
 *	11-- y1(x<0)
 *	12-- yn(0)
 *	13-- yn(x<0)
 *	14-- lgamma(finite) overflow
 *	15-- lgamma(-integer)
 *	16-- log(0)
 *	17-- log(x<0)
 *	18-- log10(0)
 *	19-- log10(x<0)
 *	20-- pow(0.0,0.0)
 *	21-- pow(x,y) overflow
 *	22-- pow(x,y) underflow
 *	23-- pow(0,negative)
 *	24-- pow(neg,non-integral)
 *	25-- sinh(finite) overflow
 *	26-- sqrt(negative)
 *  27-- fmod(x,0)
 *  28-- remainder(x,0)
 *	29-- acosh(x<1)
 *	30-- atanh(|x|>1)
 *	31-- atanh(|x|=1)
 *	32-- scalb overflow
 *	33-- scalb underflow
 *	34-- j0(|x|>X_TLOSS)
 *	35-- y0(x>X_TLOSS)
 *	36-- j1(|x|>X_TLOSS)
 *	37-- y1(x>X_TLOSS)
 *	38-- jn(|x|>X_TLOSS, n)
 *	39-- yn(x>X_TLOSS, n)
 *	40-- tgamma(finite) overflow
 *	41-- tgamma(-integer)
 *	42-- pow(NaN,0.0)
 *	43-- +0**neg
 *	44-- exp2 overflow
 *	45-- exp2 underflow
 *	46-- exp10 overflow
 *	47-- exp10 underflow
 *	48-- log2(0)
 *	49-- log2(x<0)
 *	50-- tgamma(+-0)
 */



double __kernel_standard(double x, double y, double retval, enum matherr type)
{
	struct exception exc;

/* XXX gcc versions until now don't delay the 0.0/0.0 division until
   runtime but produce NaN at compile time.  This is wrong since the
   exceptions are not set correctly.  */
#if 0
	static const double zero = 0.0;			/* used as const */
#else
	static double zero = 0.0;				/* used as const */
#endif

#ifdef _USE_WRITE
	(void) fflush(stdout);
#endif

#define funcname(name) (type >= KMATHERRL_FIRST ? name "l" : (type >= KMATHERRF_FIRST ? name "f" : name))

	exc.arg1 = x;
	exc.arg2 = y;
	exc.retval = retval;
	reset_matherr_errno(exc);
	switch (type)
	{
	case KMATHERR_ACOS:
	case KMATHERRF_ACOS:
	case KMATHERRL_ACOS:
		/* acos(|x|>1) */
		exc.type = DOMAIN;
		exc.name = funcname("acos");
		if (_LIB_VERSION == _SVID_)
			exc.retval = HUGE;
		else
			exc.retval = __builtin_nan("");
		if (_LIB_VERSION == _POSIX_)
			__set_errno(EDOM);
		else if (!matherr(&exc))
		{
			if (_LIB_VERSION == _SVID_)
			{
				(void) WRITE2("acos: DOMAIN error\n", 19);
			}
			__set_errno(EDOM);
		}
		break;
	case KMATHERR_ASIN:
	case KMATHERRF_ASIN:
	case KMATHERRL_ASIN:
		/* asin(|x|>1) */
		exc.type = DOMAIN;
		exc.name = funcname("asin");
		if (_LIB_VERSION == _SVID_)
			exc.retval = HUGE;
		else
			exc.retval = __builtin_nan("");
		if (_LIB_VERSION == _POSIX_)
			__set_errno(EDOM);
		else if (!matherr(&exc))
		{
			if (_LIB_VERSION == _SVID_)
			{
				(void) WRITE2("asin: DOMAIN error\n", 19);
			}
			__set_errno(EDOM);
		}
		break;
	case KMATHERR_ATAN2:
	case KMATHERRF_ATAN2:
	case KMATHERRL_ATAN2:
		/* atan2(+-0,+-0) */
		exc.arg1 = y;
		exc.arg2 = x;
		exc.type = DOMAIN;
		exc.name = funcname("atan2");
		exc.retval = HUGE;
		if (_LIB_VERSION == _POSIX_)
			__set_errno(EDOM);
		else if (!matherr(&exc))
		{
			if (_LIB_VERSION == _SVID_)
			{
				(void) WRITE2("atan2: DOMAIN error\n", 20);
			}
			__set_errno(EDOM);
		}
		break;
	case KMATHERR_HYPOT:
	case KMATHERRF_HYPOT:
	case KMATHERRL_HYPOT:
		/* hypot(finite,finite) overflow */
		exc.type = OVERFLOW;
		exc.name = funcname("hypot");
		if (_LIB_VERSION == _SVID_)
			exc.retval = HUGE;
		else
			exc.retval = HUGE_VAL;
		if (_LIB_VERSION == _POSIX_)
			__set_errno(ERANGE);
		else if (!matherr(&exc))
		{
			__set_errno(ERANGE);
		}
		break;
	case KMATHERR_COSH:
	case KMATHERRF_COSH:
	case KMATHERRL_COSH:
		/* cosh(finite) overflow */
		exc.type = OVERFLOW;
		exc.name = funcname("cosh");
		if (_LIB_VERSION == _SVID_)
			exc.retval = HUGE;
		else
			exc.retval = HUGE_VAL;
		if (_LIB_VERSION == _POSIX_)
			__set_errno(ERANGE);
		else if (!matherr(&exc))
		{
			__set_errno(ERANGE);
		}
		break;
	case KMATHERR_EXP_OVERFLOW:
	case KMATHERRF_EXP_OVERFLOW:
	case KMATHERRL_EXP_OVERFLOW:
		/* exp(finite) overflow */
		exc.type = OVERFLOW;
		exc.name = funcname("exp");
		if (_LIB_VERSION == _SVID_)
			exc.retval = HUGE;
		else
			exc.retval = HUGE_VAL;
		if (_LIB_VERSION == _POSIX_)
			__set_errno(ERANGE);
		else if (!matherr(&exc))
		{
			__set_errno(ERANGE);
		}
		break;
	case KMATHERR_EXP_UNDERFLOW:
	case KMATHERRF_EXP_UNDERFLOW:
	case KMATHERRL_EXP_UNDERFLOW:
		/* exp(finite) underflow */
		exc.type = UNDERFLOW;
		exc.name = funcname("exp");
		if (_LIB_VERSION == _POSIX_)
			__set_errno(ERANGE);
		else if (!matherr(&exc))
		{
			__set_errno(ERANGE);
		}
		break;
	case KMATHERR_EXPM1_OVERFLOW:
	case KMATHERRF_EXPM1_OVERFLOW:
	case KMATHERRL_EXPM1_OVERFLOW:
		/* exp(finite) overflow */
		exc.type = OVERFLOW;
		exc.name = funcname("expm1");
		if (_LIB_VERSION == _POSIX_)
			__set_errno(ERANGE);
		else if (!matherr(&exc))
		{
			__set_errno(ERANGE);
		}
		break;
	case KMATHERR_EXPM1_UNDERFLOW:
	case KMATHERRF_EXPM1_UNDERFLOW:
	case KMATHERRL_EXPM1_UNDERFLOW:
		/* exp(finite) underflow */
		exc.type = UNDERFLOW;
		exc.name = funcname("exp");
		if (_LIB_VERSION == _POSIX_)
			__set_errno(ERANGE);
		else if (!matherr(&exc))
		{
			__set_errno(ERANGE);
		}
		break;
	case KMATHERR_Y0_ZERO:
	case KMATHERRF_Y0_ZERO:
	case KMATHERRL_Y0_ZERO:
		/* y0(0) = -inf */
		exc.type = DOMAIN;				/* should be SING for IEEE */
		exc.name = funcname("y0");
		if (_LIB_VERSION == _SVID_)
			exc.retval = -HUGE;
		else
			exc.retval = -HUGE_VAL;
		if (_LIB_VERSION == _POSIX_)
			__set_errno(EDOM);
		else if (!matherr(&exc))
		{
			if (_LIB_VERSION == _SVID_)
			{
				(void) WRITE2("y0: DOMAIN error\n", 17);
			}
			__set_errno(EDOM);
		}
		break;
	case KMATHERR_Y0_MINUS:
	case KMATHERRF_Y0_MINUS:
	case KMATHERRL_Y0_MINUS:
		/* y0(x<0) = NaN */
		exc.type = DOMAIN;
		exc.name = funcname("y0");
		if (_LIB_VERSION == _SVID_)
			exc.retval = -HUGE;
		else
			exc.retval = -HUGE_VAL;
		if (_LIB_VERSION == _POSIX_)
			__set_errno(EDOM);
		else if (!matherr(&exc))
		{
			if (_LIB_VERSION == _SVID_)
			{
				(void) WRITE2("y0: DOMAIN error\n", 17);
			}
			__set_errno(EDOM);
		}
		break;
	case KMATHERR_Y1_ZERO:
	case KMATHERRF_Y1_ZERO:
	case KMATHERRL_Y1_ZERO:
		/* y1(0) = -inf */
		exc.type = DOMAIN;				/* should be SING for IEEE */
		exc.name = funcname("y1");
		if (_LIB_VERSION == _SVID_)
			exc.retval = -HUGE;
		else
			exc.retval = -HUGE_VAL;
		if (_LIB_VERSION == _POSIX_)
			__set_errno(EDOM);
		else if (!matherr(&exc))
		{
			if (_LIB_VERSION == _SVID_)
			{
				(void) WRITE2("y1: DOMAIN error\n", 17);
			}
			__set_errno(EDOM);
		}
		break;
	case KMATHERR_Y1_MINUS:
	case KMATHERRF_Y1_MINUS:
	case KMATHERRL_Y1_MINUS:
		/* y1(x<0) = NaN */
		exc.type = DOMAIN;
		exc.name = funcname("y1");
		if (_LIB_VERSION == _SVID_)
			exc.retval = -HUGE;
		else
			exc.retval = -HUGE_VAL;
		if (_LIB_VERSION == _POSIX_)
			__set_errno(EDOM);
		else if (!matherr(&exc))
		{
			if (_LIB_VERSION == _SVID_)
			{
				(void) WRITE2("y1: DOMAIN error\n", 17);
			}
			__set_errno(EDOM);
		}
		break;
	case KMATHERR_YN_ZERO:
	case KMATHERRF_YN_ZERO:
	case KMATHERRL_YN_ZERO:
		/* yn(n,0) = -inf */
		exc.type = DOMAIN;				/* should be SING for IEEE */
		exc.name = funcname("yn");
		if (_LIB_VERSION == _SVID_)
			exc.retval = -HUGE;
		else
			exc.retval = -HUGE_VAL;
		if (_LIB_VERSION == _POSIX_)
			__set_errno(EDOM);
		else if (!matherr(&exc))
		{
			if (_LIB_VERSION == _SVID_)
			{
				(void) WRITE2("yn: DOMAIN error\n", 17);
			}
			__set_errno(EDOM);
		}
		break;
	case KMATHERR_YN_MINUS:
	case KMATHERRF_YN_MINUS:
	case KMATHERRL_YN_MINUS:
		/* yn(x<0) = NaN */
		exc.type = DOMAIN;
		exc.name = funcname("yn");
		if (_LIB_VERSION == _SVID_)
			exc.retval = -HUGE;
		else
			exc.retval = -HUGE_VAL;
		if (_LIB_VERSION == _POSIX_)
			__set_errno(EDOM);
		else if (!matherr(&exc))
		{
			if (_LIB_VERSION == _SVID_)
			{
				(void) WRITE2("yn: DOMAIN error\n", 17);
			}
			__set_errno(EDOM);
		}
		break;
	case KMATHERR_LGAMMA_OVERFLOW:
	case KMATHERRF_LGAMMA_OVERFLOW:
	case KMATHERRL_LGAMMA_OVERFLOW:
		/* lgamma(finite) overflow */
		exc.type = OVERFLOW;
		exc.name = funcname("lgamma");
		if (_LIB_VERSION == _SVID_)
			exc.retval = HUGE;
		else
			exc.retval = HUGE_VAL;
		if (_LIB_VERSION == _POSIX_)
			__set_errno(ERANGE);
		else if (!matherr(&exc))
		{
			__set_errno(ERANGE);
		}
		break;
	case KMATHERR_LGAMMA_MINUS:
	case KMATHERRF_LGAMMA_MINUS:
	case KMATHERRL_LGAMMA_MINUS:
		/* lgamma(-integer) or lgamma(0) */
		exc.type = SING;
		exc.name = funcname("lgamma");
		if (_LIB_VERSION == _SVID_)
			exc.retval = HUGE;
		else
			exc.retval = HUGE_VAL;
		if (_LIB_VERSION == _POSIX_)
			__set_errno(ERANGE);
		else if (!matherr(&exc))
		{
			if (_LIB_VERSION == _SVID_)
			{
				(void) WRITE2("lgamma: SING error\n", 19);
			}
			__set_errno(EDOM);
		}
		break;
	case KMATHERR_LOG_ZERO:
	case KMATHERRF_LOG_ZERO:
	case KMATHERRL_LOG_ZERO:
		/* log(0) */
		exc.type = SING;
		exc.name = funcname("log");
		if (_LIB_VERSION == _SVID_)
			exc.retval = -HUGE;
		else
			exc.retval = -HUGE_VAL;
		if (_LIB_VERSION == _POSIX_)
			__set_errno(ERANGE);
		else if (!matherr(&exc))
		{
			if (_LIB_VERSION == _SVID_)
			{
				(void) WRITE2("log: SING error\n", 16);
			}
			__set_errno(EDOM);
		}
		break;
	case KMATHERR_LOG_MINUS:
	case KMATHERRF_LOG_MINUS:
	case KMATHERRL_LOG_MINUS:
		/* log(x<0) */
		exc.type = DOMAIN;
		exc.name = funcname("log");
		if (_LIB_VERSION == _SVID_)
			exc.retval = -HUGE;
		else
			exc.retval = __builtin_nan("");
		if (_LIB_VERSION == _POSIX_)
			__set_errno(EDOM);
		else if (!matherr(&exc))
		{
			if (_LIB_VERSION == _SVID_)
			{
				(void) WRITE2("log: DOMAIN error\n", 18);
			}
			__set_errno(EDOM);
		}
		break;
	case KMATHERR_LOG10_ZERO:
	case KMATHERRF_LOG10_ZERO:
	case KMATHERRL_LOG10_ZERO:
		/* log10(0) */
		exc.type = SING;
		exc.name = funcname("log10");
		if (_LIB_VERSION == _SVID_)
			exc.retval = -HUGE;
		else
			exc.retval = -HUGE_VAL;
		if (_LIB_VERSION == _POSIX_)
			__set_errno(ERANGE);
		else if (!matherr(&exc))
		{
			if (_LIB_VERSION == _SVID_)
			{
				(void) WRITE2("log10: SING error\n", 18);
			}
			__set_errno(EDOM);
		}
		break;
	case KMATHERR_LOG10_MINUS:
	case KMATHERRF_LOG10_MINUS:
	case KMATHERRL_LOG10_MINUS:
		/* log10(x<0) */
		exc.type = DOMAIN;
		exc.name = funcname("log10");
		if (_LIB_VERSION == _SVID_)
			exc.retval = -HUGE;
		else
			exc.retval = __builtin_nan("");
		if (_LIB_VERSION == _POSIX_)
			__set_errno(EDOM);
		else if (!matherr(&exc))
		{
			if (_LIB_VERSION == _SVID_)
			{
				(void) WRITE2("log10: DOMAIN error\n", 20);
			}
			__set_errno(EDOM);
		}
		break;
	case KMATHERR_POW_ZERO:
	case KMATHERRF_POW_ZERO:
	case KMATHERRL_POW_ZERO:
		/* pow(0.0,0.0) */
		/* error only if _LIB_VERSION == _SVID_ */
		exc.type = DOMAIN;
		exc.name = funcname("pow");
		exc.retval = zero;
		if (_LIB_VERSION != _SVID_)
			exc.retval = 1.0;
		else if (!matherr(&exc))
		{
			(void) WRITE2("pow(0,0): DOMAIN error\n", 23);
			__set_errno(EDOM);
		}
		break;
	case KMATHERR_POW_OVERFLOW:
	case KMATHERRF_POW_OVERFLOW:
	case KMATHERRL_POW_OVERFLOW:
		/* pow(x,y) overflow */
		exc.type = OVERFLOW;
		exc.name = funcname("pow");
		if (_LIB_VERSION == _SVID_)
		{
			exc.retval = HUGE;
			y *= 0.5;
			if (x < zero && __ieee754_rint(y) != y)
				exc.retval = -HUGE;
		} else
		{
			exc.retval = HUGE_VAL;
			y *= 0.5;
			if (x < zero && __ieee754_rint(y) != y)
				exc.retval = -HUGE_VAL;
		}
		if (_LIB_VERSION == _POSIX_)
			__set_errno(ERANGE);
		else if (!matherr(&exc))
		{
			__set_errno(ERANGE);
		}
		break;
	case KMATHERR_POW_UNDERFLOW:
	case KMATHERRF_POW_UNDERFLOW:
	case KMATHERRL_POW_UNDERFLOW:
		/* pow(x,y) underflow */
		exc.type = UNDERFLOW;
		exc.name = funcname("pow");
		exc.retval = zero;
		y *= 0.5;
		if (x < zero && __ieee754_rint(y) != y)
			exc.retval = -zero;
		if (_LIB_VERSION == _POSIX_)
			__set_errno(ERANGE);
		else if (!matherr(&exc))
		{
			__set_errno(ERANGE);
		}
		break;
	case KMATHERR_POW_MINUS:
	case KMATHERRF_POW_MINUS:
	case KMATHERRL_POW_MINUS:
		/* -0**neg */
		exc.type = DOMAIN;
		exc.name = funcname("pow");
		if (_LIB_VERSION == _SVID_)
			exc.retval = zero;
		else
			exc.retval = -HUGE_VAL;
		if (_LIB_VERSION == _POSIX_)
			__set_errno(ERANGE);
		else if (!matherr(&exc))
		{
			if (_LIB_VERSION == _SVID_)
			{
				(void) WRITE2("pow(0,neg): DOMAIN error\n", 25);
			}
			__set_errno(EDOM);
		}
		break;
	case KMATHERR_POW_NONINT:
	case KMATHERRF_POW_NONINT:
	case KMATHERRL_POW_NONINT:
		/* neg**non-integral */
		exc.type = DOMAIN;
		exc.name = funcname("pow");
		if (_LIB_VERSION == _SVID_)
			exc.retval = zero;
		else
			exc.retval = zero / zero;	/* X/Open allow NaN */
		if (_LIB_VERSION == _POSIX_)
			__set_errno(EDOM);
		else if (!matherr(&exc))
		{
			if (_LIB_VERSION == _SVID_)
			{
				(void) WRITE2("neg**non-integral: DOMAIN error\n", 32);
			}
			__set_errno(EDOM);
		}
		break;
	case KMATHERR_SINH:
	case KMATHERRF_SINH:
	case KMATHERRL_SINH:
		/* sinh(finite) overflow */
		exc.type = OVERFLOW;
		exc.name = funcname("sinh");
		if (_LIB_VERSION == _SVID_)
			exc.retval = ((x > zero) ? HUGE : -HUGE);
		else
			exc.retval = ((x > zero) ? HUGE_VAL : -HUGE_VAL);
		if (_LIB_VERSION == _POSIX_)
			__set_errno(ERANGE);
		else if (!matherr(&exc))
		{
			__set_errno(ERANGE);
		}
		break;
	case KMATHERR_SQRT:
	case KMATHERRF_SQRT:
	case KMATHERRL_SQRT:
		/* sqrt(x<0) */
		exc.type = DOMAIN;
		exc.name = funcname("sqrt");
		if (_LIB_VERSION == _SVID_)
			exc.retval = zero;
		else
			exc.retval = zero / zero;
		if (_LIB_VERSION == _POSIX_)
			__set_errno(EDOM);
		else if (!matherr(&exc))
		{
			if (_LIB_VERSION == _SVID_)
			{
				(void) WRITE2("sqrt: DOMAIN error\n", 19);
			}
			__set_errno(EDOM);
		}
		break;
	case KMATHERR_FMOD:
	case KMATHERRF_FMOD:
	case KMATHERRL_FMOD:
		/* fmod(x,0) */
		exc.type = DOMAIN;
		exc.name = funcname("fmod");
		if (_LIB_VERSION == _SVID_)
			exc.retval = x;
		else
			exc.retval = zero / zero;
		if (_LIB_VERSION == _POSIX_)
			__set_errno(EDOM);
		else if (!matherr(&exc))
		{
			if (_LIB_VERSION == _SVID_)
			{
				(void) WRITE2("fmod:  DOMAIN error\n", 20);
			}
			__set_errno(EDOM);
		}
		break;
	case KMATHERR_REMAINDER:
	case KMATHERRF_REMAINDER:
	case KMATHERRL_REMAINDER:
		/* remainder(x,0) */
		exc.type = DOMAIN;
		exc.name = funcname("remainder");
		exc.retval = zero / zero;
		if (_LIB_VERSION == _POSIX_)
			__set_errno(EDOM);
		else if (!matherr(&exc))
		{
			if (_LIB_VERSION == _SVID_)
			{
				(void) WRITE2("remainder: DOMAIN error\n", 24);
			}
			__set_errno(EDOM);
		}
		break;
	case KMATHERR_ACOSH:
	case KMATHERRF_ACOSH:
	case KMATHERRL_ACOSH:
		/* acosh(x<1) */
		exc.type = DOMAIN;
		exc.name = funcname("acosh");
		exc.retval = zero / zero;
		if (_LIB_VERSION == _POSIX_)
			__set_errno(EDOM);
		else if (!matherr(&exc))
		{
			if (_LIB_VERSION == _SVID_)
			{
				(void) WRITE2("acosh: DOMAIN error\n", 20);
			}
			__set_errno(EDOM);
		}
		break;
	case KMATHERR_ATANH_PLUSONE:
	case KMATHERRF_ATANH_PLUSONE:
	case KMATHERRL_ATANH_PLUSONE:
		/* atanh(|x|>1) */
		exc.type = DOMAIN;
		exc.name = funcname("atanh");
		exc.retval = zero / zero;
		if (_LIB_VERSION == _POSIX_)
			__set_errno(EDOM);
		else if (!matherr(&exc))
		{
			if (_LIB_VERSION == _SVID_)
			{
				(void) WRITE2("atanh: DOMAIN error\n", 20);
			}
			__set_errno(EDOM);
		}
		break;
	case KMATHERR_ATANH_ONE:
	case KMATHERRF_ATANH_ONE:
	case KMATHERRL_ATANH_ONE:
		/* atanh(|x|=1) */
		exc.type = SING;
		exc.name = funcname("atanh");
		exc.retval = x / zero;			/* sign(x)*inf */
		if (_LIB_VERSION == _POSIX_)
			__set_errno(ERANGE);
		else if (!matherr(&exc))
		{
			if (_LIB_VERSION == _SVID_)
			{
				(void) WRITE2("atanh: SING error\n", 18);
			}
			__set_errno(EDOM);
		}
		break;
	case KMATHERR_SCALB_OVERFLOW:
	case KMATHERRF_SCALB_OVERFLOW:
	case KMATHERRL_SCALB_OVERFLOW:
		/* scalb overflow; SVID also returns +-HUGE_VAL */
		exc.type = OVERFLOW;
		exc.name = funcname("scalb");
		exc.retval = x > zero ? HUGE_VAL : -HUGE_VAL;
		if (_LIB_VERSION == _POSIX_)
			__set_errno(ERANGE);
		else if (!matherr(&exc))
		{
			__set_errno(ERANGE);
		}
		break;
	case KMATHERR_SCALB_UNDERFLOW:
	case KMATHERRF_SCALB_UNDERFLOW:
	case KMATHERRL_SCALB_UNDERFLOW:
		/* scalb underflow */
		exc.type = UNDERFLOW;
		exc.name = funcname("scalb");
		exc.retval = copysign(zero, x);
		if (_LIB_VERSION == _POSIX_)
			__set_errno(ERANGE);
		else if (!matherr(&exc))
		{
			__set_errno(ERANGE);
		}
		break;
	case KMATHERR_J0_TLOSS:
	case KMATHERRF_J0_TLOSS:
	case KMATHERRL_J0_TLOSS:
		/* j0(|x|>X_TLOSS) */
		exc.type = TLOSS;
		exc.name = funcname("j0");
		exc.retval = zero;
		if (_LIB_VERSION == _POSIX_)
			__set_errno(ERANGE);
		else if (!matherr(&exc))
		{
			if (_LIB_VERSION == _SVID_)
			{
				(void) WRITE2(exc.name, 2);
				(void) WRITE2(": TLOSS error\n", 14);
			}
			__set_errno(ERANGE);
		}
		break;
	case KMATHERR_Y0_TLOSS:
	case KMATHERRF_Y0_TLOSS:
	case KMATHERRL_Y0_TLOSS:
		/* y0(x>X_TLOSS) */
		exc.type = TLOSS;
		exc.name = funcname("y0");
		exc.retval = zero;
		if (_LIB_VERSION == _POSIX_)
			__set_errno(ERANGE);
		else if (!matherr(&exc))
		{
			if (_LIB_VERSION == _SVID_)
			{
				(void) WRITE2(exc.name, 2);
				(void) WRITE2(": TLOSS error\n", 14);
			}
			__set_errno(ERANGE);
		}
		break;
	case KMATHERR_J1_TLOSS:
	case KMATHERRF_J1_TLOSS:
	case KMATHERRL_J1_TLOSS:
		/* j1(|x|>X_TLOSS) */
		exc.type = TLOSS;
		exc.name = funcname("j1");
		exc.retval = zero;
		if (_LIB_VERSION == _POSIX_)
			__set_errno(ERANGE);
		else if (!matherr(&exc))
		{
			if (_LIB_VERSION == _SVID_)
			{
				(void) WRITE2(exc.name, 2);
				(void) WRITE2(": TLOSS error\n", 14);
			}
			__set_errno(ERANGE);
		}
		break;
	case KMATHERR_Y1_TLOSS:
	case KMATHERRF_Y1_TLOSS:
	case KMATHERRL_Y1_TLOSS:
		/* y1(x>X_TLOSS) */
		exc.type = TLOSS;
		exc.name = funcname("y1");
		exc.retval = zero;
		if (_LIB_VERSION == _POSIX_)
			__set_errno(ERANGE);
		else if (!matherr(&exc))
		{
			if (_LIB_VERSION == _SVID_)
			{
				(void) WRITE2(exc.name, 2);
				(void) WRITE2(": TLOSS error\n", 14);
			}
			__set_errno(ERANGE);
		}
		break;
	case KMATHERR_JN_TLOSS:
	case KMATHERRF_JN_TLOSS:
	case KMATHERRL_JN_TLOSS:
		/* jn(|x|>X_TLOSS) */
		exc.type = TLOSS;
		exc.name = funcname("jn");
		exc.retval = zero;
		if (_LIB_VERSION == _POSIX_)
			__set_errno(ERANGE);
		else if (!matherr(&exc))
		{
			if (_LIB_VERSION == _SVID_)
			{
				(void) WRITE2(exc.name, 2);
				(void) WRITE2(": TLOSS error\n", 14);
			}
			__set_errno(ERANGE);
		}
		break;
	case KMATHERR_YN_TLOSS:
	case KMATHERRF_YN_TLOSS:
	case KMATHERRL_YN_TLOSS:
		/* yn(x>X_TLOSS) */
		exc.type = TLOSS;
		exc.name = funcname("yn");
		exc.retval = zero;
		if (_LIB_VERSION == _POSIX_)
			__set_errno(ERANGE);
		else if (!matherr(&exc))
		{
			if (_LIB_VERSION == _SVID_)
			{
				(void) WRITE2(exc.name, 2);
				(void) WRITE2(": TLOSS error\n", 14);
			}
			__set_errno(ERANGE);
		}
		break;
	case KMATHERR_TGAMMA_OVERFLOW:
	case KMATHERRF_TGAMMA_OVERFLOW:
	case KMATHERRL_TGAMMA_OVERFLOW:
		/* tgamma(finite) overflow */
		exc.type = OVERFLOW;
		exc.name = funcname("tgamma");
		exc.retval = copysign(HUGE_VAL, x);
		if (_LIB_VERSION == _POSIX_)
			__set_errno(ERANGE);
		else if (!matherr(&exc))
		{
			__set_errno(ERANGE);
		}
		break;
	case KMATHERR_TGAMMA_MINUS:
	case KMATHERRF_TGAMMA_MINUS:
	case KMATHERRL_TGAMMA_MINUS:
		/* tgamma(-integer) */
		exc.type = SING;
		exc.name = funcname("tgamma");
		if (_LIB_VERSION == _SVID_)
			exc.retval = HUGE_VAL;
		else
			exc.retval = __builtin_nan("");
		if (_LIB_VERSION == _POSIX_)
			__set_errno(EDOM);
		else if (!matherr(&exc))
		{
			if (_LIB_VERSION == _SVID_)
			{
				(void) WRITE2("gamma: SING error\n", 18);
			}
			__set_errno(EDOM);
		}
		break;
	case KMATHERR_TGAMMA_UNDERFLOW:
	case KMATHERRF_TGAMMA_UNDERFLOW:
	case KMATHERRL_TGAMMA_UNDERFLOW:
		/* tgamma(finite) underflow */
		exc.type = UNDERFLOW;
		exc.name = funcname("tgamma");
		exc.retval = 0;
		if (_LIB_VERSION == _POSIX_)
			__set_errno(ERANGE);
		else if (!matherr(&exc))
		{
			__set_errno(ERANGE);
		}
		break;
	case KMATHERR_POW_NAN:
	case KMATHERRF_POW_NAN:
	case KMATHERRL_POW_NAN:
		/* pow(NaN,0.0) */
		/* error only if _LIB_VERSION == _SVID_ & _XOPEN_ */
		exc.type = DOMAIN;
		exc.name = funcname("pow");
		exc.retval = x;
		if (_LIB_VERSION != _SVID_ && _LIB_VERSION != _XOPEN_)
			exc.retval = 1.0;
		else if (!matherr(&exc))
			__set_errno(EDOM);
		break;

	case KMATHERR_POW_ZEROMINUS:
	case KMATHERRF_POW_ZEROMINUS:
	case KMATHERRL_POW_ZEROMINUS:
		/* +0**neg */
		exc.type = DOMAIN;
		exc.name = funcname("pow");
		if (_LIB_VERSION == _SVID_)
			exc.retval = zero;
		else
			exc.retval = HUGE_VAL;
		if (_LIB_VERSION == _POSIX_)
			__set_errno(ERANGE);
		else if (!matherr(&exc))
			__set_errno(EDOM);
		break;
	case KMATHERR_EXP2_OVERFLOW:
	case KMATHERRF_EXP2_OVERFLOW:
	case KMATHERRL_EXP2_OVERFLOW:
		/* exp(finite) overflow */
		exc.type = OVERFLOW;
		exc.name = funcname("exp2");
		if (_LIB_VERSION == _SVID_)
			exc.retval = HUGE;
		else
			exc.retval = HUGE_VAL;
		if (_LIB_VERSION == _POSIX_)
			__set_errno(ERANGE);
		else if (!matherr(&exc))
			__set_errno(ERANGE);
		break;
	case KMATHERR_EXP2_UNDERFLOW:
	case KMATHERRF_EXP2_UNDERFLOW:
	case KMATHERRL_EXP2_UNDERFLOW:
		/* exp(finite) underflow */
		exc.type = UNDERFLOW;
		exc.name = funcname("exp2");
		exc.retval = zero;
		if (_LIB_VERSION == _POSIX_)
			__set_errno(ERANGE);
		else if (!matherr(&exc))
			__set_errno(ERANGE);
		break;

	case KMATHERR_EXP10_OVERFLOW:
	case KMATHERRF_EXP10_OVERFLOW:
	case KMATHERRL_EXP10_OVERFLOW:
		/* exp(finite) overflow */
		exc.type = OVERFLOW;
		exc.name = funcname("exp10");
		if (_LIB_VERSION == _SVID_)
			exc.retval = HUGE;
		else
			exc.retval = HUGE_VAL;
		if (_LIB_VERSION == _POSIX_)
			__set_errno(ERANGE);
		else if (!matherr(&exc))
			__set_errno(ERANGE);
		break;
	case KMATHERR_EXP10_UNDERFLOW:
	case KMATHERRF_EXP10_UNDERFLOW:
	case KMATHERRL_EXP10_UNDERFLOW:
		/* exp(finite) underflow */
		exc.type = UNDERFLOW;
		exc.name = funcname("exp10");
		exc.retval = zero;
		if (_LIB_VERSION == _POSIX_)
			__set_errno(ERANGE);
		else if (!matherr(&exc))
			__set_errno(ERANGE);
		break;
	case KMATHERR_LOG2_ZERO:
	case KMATHERRF_LOG2_ZERO:
	case KMATHERRL_LOG2_ZERO:
		/* log2(0) */
		exc.type = SING;
		exc.name = funcname("log2");
		if (_LIB_VERSION == _SVID_)
			exc.retval = -HUGE;
		else
			exc.retval = -HUGE_VAL;
		if (_LIB_VERSION == _POSIX_)
			__set_errno(ERANGE);
		else if (!matherr(&exc))
			__set_errno(EDOM);
		break;
	case KMATHERR_LOG2_MINUS:
	case KMATHERRF_LOG2_MINUS:
	case KMATHERRL_LOG2_MINUS:
		/* log2(x<0) */
		exc.type = DOMAIN;
		exc.name = funcname("log2");
		if (_LIB_VERSION == _SVID_)
			exc.retval = -HUGE;
		else
			exc.retval = __builtin_nan("");
		if (_LIB_VERSION == _POSIX_)
			__set_errno(EDOM);
		else if (!matherr(&exc))
			__set_errno(EDOM);
		break;
	case KMATHERR_TGAMMA_ZERO:
	case KMATHERRF_TGAMMA_ZERO:
	case KMATHERRL_TGAMMA_ZERO:
		/* tgamma(+-0) */
		exc.type = SING;
		exc.name = funcname("tgamma");
		exc.retval = copysign(HUGE_VAL, x);
		if (_LIB_VERSION == _POSIX_)
			__set_errno(ERANGE);
		else if (!matherr(&exc))
			__set_errno(EDOM);
		break;
	case KMATHERR_COS_INF:
	case KMATHERRF_COS_INF:
	case KMATHERRL_COS_INF:
		/* cos(inf) */
		exc.type = DOMAIN;
		exc.name = funcname("cos");
		exc.retval = __builtin_nan("");
		if (_LIB_VERSION == _POSIX_)
			__set_errno(EDOM);
		else if (!matherr(&exc))
			__set_errno(EDOM);
		break;
	case KMATHERR_SIN_INF:
	case KMATHERRF_SIN_INF:
	case KMATHERRL_SIN_INF:
		/* sin(inf) */
		exc.type = DOMAIN;
		exc.name = funcname("sin");
		exc.retval = __builtin_nan("");
		if (_LIB_VERSION == _POSIX_)
			__set_errno(EDOM);
		else if (!matherr(&exc))
			__set_errno(EDOM);
		break;
	case KMATHERR_TAN_INF:
	case KMATHERRF_TAN_INF:
	case KMATHERRL_TAN_INF:
		/* tan(inf) */
		exc.type = DOMAIN;
		exc.name = funcname("tan");
		exc.retval = __builtin_nan("");
		if (_LIB_VERSION == _POSIX_)
			__set_errno(EDOM);
		else if (!matherr(&exc))
			__set_errno(EDOM);
		break;
	
	case KMATHERR_SCALB_INVALID:
	case KMATHERRF_SCALB_INVALID:
	case KMATHERRL_SCALB_INVALID:
		/* scalb(x, non-integer) */
		exc.type = DOMAIN;
		exc.name = funcname("scalb");
		exc.retval = __builtin_nan("");
		if (_LIB_VERSION == _POSIX_)
			__set_errno(EDOM);
		else if (!matherr(&exc))
			__set_errno(EDOM);
		break;
	
	case KMATHERR_ILOGB:
	case KMATHERRF_ILOGB:
	case KMATHERRL_ILOGB:
		/* ilogb(0 or NaN) */
		exc.type = DOMAIN;
		exc.name = funcname("ilogb");
		exc.retval = x == 0 ? FP_ILOGB0 : FP_ILOGBNAN;
		feraiseexcept(FE_INVALID);
		if (_LIB_VERSION == _POSIX_)
			__set_errno(EDOM);
		else if (!matherr(&exc))
			__set_errno(EDOM);
		break;
	
	case KMATHERRF_FIRST:
	case KMATHERRL_FIRST:
		break;
	}
	set_matherr_errno(exc);
	return exc.retval;
}


float __kernel_standard_f(float x, float y, float retval, enum matherr type)
{
	return __kernel_standard(x, y, retval, type);
}


#ifndef __NO_LONG_DOUBLE_MATH
long double __kernel_standard_l(long double x, long double y, long double retval, enum matherr type)
{
	double dx, dy, dretval;
	struct exception exc;

	if (isfinite(x))
	{
		long double ax = __ieee754_fabsl(x);

		if (ax > DBL_MAX)
			dx = copysignl(DBL_MAX, x);
		else if (ax > 0 && ax < DBL_MIN)
			dx = copysignl(DBL_MIN, x);
		else
			dx = x;
	} else
	{
		dx = x;
	}
	if (isfinite(y))
	{
		long double ay = __ieee754_fabsl(y);

		if (ay > DBL_MAX)
			dy = copysignl(DBL_MAX, y);
		else if (ay > 0 && ay < DBL_MIN)
			dy = copysignl(DBL_MIN, y);
		else
			dy = y;
	} else
	{
		dy = y;
	}
	if (isfinite(retval))
	{
		long double az = __ieee754_fabsl(retval);

		if (az > DBL_MAX)
			dretval = copysignl(DBL_MAX, retval);
		else if (az > 0 && az < DBL_MIN)
			dretval = copysignl(DBL_MIN, retval);
		else
			dretval = retval;
	} else
	{
		dretval = retval;
	}
	
	switch (type)
	{
	case KMATHERRL_POW_OVERFLOW:
		/* powl (x, y) overflow.  */
		exc.arg1 = dx;
		exc.arg2 = dy;
		exc.type = OVERFLOW;
		exc.name = funcname("pow");
		reset_matherr_errno(exc);
		if (_LIB_VERSION == _SVID_)
		{
			exc.retval = signbit(retval) ? -HUGE : HUGE;
		} else
		{
			exc.retval = dretval;
		}
		if (_LIB_VERSION == _POSIX_)
			__set_errno(ERANGE);
		else if (!matherr(&exc))
			__set_errno(ERANGE);
		set_matherr_errno(exc);
		return exc.retval;

	case KMATHERRL_POW_UNDERFLOW:
		/* powl (x, y) underflow.  */
		exc.arg1 = dx;
		exc.arg2 = dy;
		exc.type = UNDERFLOW;
		exc.name = funcname("pow");
		exc.retval = dretval;
		reset_matherr_errno(exc);
		if (_LIB_VERSION == _POSIX_)
			__set_errno(ERANGE);
		else if (!matherr(&exc))
			__set_errno(ERANGE);
		set_matherr_errno(exc);
		return exc.retval;

	default:
		break;
	}
	return __kernel_standard(dx, dy, dretval, type);
}
#endif

#undef funcname

```

`k_tan.c`:

```c
/*
 * ====================================================
 * Copyright 2004 Sun Microsystems, Inc.  All Rights Reserved.
 *
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/* __kernel_tan( x, y, k )
 * kernel tan function on [-pi/4, pi/4], pi/4 ~ 0.7854
 * Input x is assumed to be bounded by ~pi/4 in magnitude.
 * Input y is the tail of x.
 * Input k indicates whether tan (if k = 1) or -1/tan (if k = -1) is returned.
 *
 * Algorithm
 *	1. Since tan(-x) = -tan(x), we need only to consider positive x.
 *	2. if x < 2^-28 (hx<0x3e300000 0), return x with inexact if x!=0.
 *	3. tan(x) is approximated by a odd polynomial of degree 27 on
 *	   [0,0.67434]
 *		  	         3             27
 *	   	tan(x) ~ x + T1*x + ... + T13*x
 *	   where
 *
 * 	        |tan(x)         2     4            26   |     -59.2
 * 	        |----- - (1+T1*x +T2*x +.... +T13*x    )| <= 2
 * 	        |  x 					|
 *
 *	   Note: tan(x+y) = tan(x) + tan'(x)*y
 *		          ~ tan(x) + (1+x*x)*y
 *	   Therefore, for better accuracy in computing tan(x+y), let
 *		     3      2      2       2       2
 *		r = x *(T2+x *(T3+x *(...+x *(T12+x *T13))))
 *	   then
 *		 		    3    2
 *		tan(x+y) = x + (T1*x + (x *(r+y)+y))
 *
 *      4. For x in [0.67434,pi/4],  let y = pi/4 - x, then
 *		tan(x) = tan(pi/4-y) = (1-tan(y))/(1+tan(y))
 *		       = 1 - 2*(tan(y) - (tan(y)^2)/(1+tan(y)))
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

double __kernel_tan(double x, double y, int iy)
{
	double z, r, v, w, s;
	int32_t ix, hx;

	static const double one = 1.00000000000000000000e+00;		/* 0x3FF00000, 0x00000000 */
	static const double pio4 = 7.85398163397448278999e-01;		/* 0x3FE921FB, 0x54442D18 */
	static const double pio4lo = 3.06161699786838301793e-17;	/* 0x3C81A626, 0x33145C07 */

	static const double T[] = {
		3.33333333333334091986e-01,			/* 0x3FD55555, 0x55555563 */
		1.33333333333201242699e-01,			/* 0x3FC11111, 0x1110FE7A */
		5.39682539762260521377e-02,			/* 0x3FABA1BA, 0x1BB341FE */
		2.18694882948595424599e-02,			/* 0x3F9664F4, 0x8406D637 */
		8.86323982359930005737e-03,			/* 0x3F8226E3, 0xE96E8493 */
		3.59207910759131235356e-03,			/* 0x3F6D6D22, 0xC9560328 */
		1.45620945432529025516e-03,			/* 0x3F57DBC8, 0xFEE08315 */
		5.88041240820264096874e-04,			/* 0x3F4344D8, 0xF2F26501 */
		2.46463134818469906812e-04,			/* 0x3F3026F7, 0x1A8D1068 */
		7.81794442939557092300e-05,			/* 0x3F147E88, 0xA03792A6 */
		7.14072491382608190305e-05,			/* 0x3F12B80F, 0x32F0A7E9 */
		-1.85586374855275456654e-05,		/* 0xBEF375CB, 0xDB605373 */
		2.59073051863633712884e-05			/* 0x3EFB2A70, 0x74BF7AD4 */
	};

	GET_HIGH_WORD(hx, x);
	ix = hx & IC(0x7fffffff);			/* high word of |x| */
	if (ix < IC(0x3e300000))			/* x < 2**-28 */
	{
		if ((int32_t) x == 0)
		{								/* generate inexact */
			uint32_t low;

			GET_LOW_WORD(low, x);
			if (((ix | low) | (iy + 1)) == 0)
				return one / __ieee754_fabs(x);
			else
				return (iy == 1) ? x : -one / x;
		}
	}
	if (ix >= IC(0x3FE59428))
	{									/* |x| >= 0.6744 */
		if (hx < 0)
		{
			x = -x;
			y = -y;
		}
		z = pio4 - x;
		w = pio4lo - y;
		x = z + w;
		y = 0.0;
	}
	z = x * x;
	w = z * z;
	/*
	 * Break x^5*(T[1]+x^2*T[2]+...) into
	 * x^5(T[1]+x^4*T[3]+...+x^20*T[11]) +
	 * x^5(x^2*(T[2]+x^4*T[4]+...+x^22*[T12]))
	 */
	r = T[1] + w * (T[3] + w * (T[5] + w * (T[7] + w * (T[9] + w * T[11]))));
	v = z * (T[2] + w * (T[4] + w * (T[6] + w * (T[8] + w * (T[10] + w * T[12])))));
	s = z * x;
	r = y + z * (s * (r + v) + y);
	r += T[0] * s;
	w = x + r;
	if (ix >= IC(0x3FE59428))
	{
		v = (double) iy;
		return (double) (1 - ((hx >> 30) & 2)) * (v - 2.0 * (x - (w * w / (w + v) - r)));
	}
	if (iy == 1)
		return w;
	else
	{
		/*
		 * if allow error up to 2 ulp, simply return
		 * -1.0 / (x+r) here
		 */
		/* compute -1.0 / (x+r) accurately */
		double a, t;

		z = w;
		SET_LOW_WORD(z, 0);
		v = r - (z - x);				/* z+v = r+x */
		t = a = -1.0 / w;				/* a = -1.0/w */
		SET_LOW_WORD(t, 0);
		s = 1.0 + t * z;
		return t + a * (s + t * v);
	}
}

```

`k_tanf.c`:

```c
/* k_tanf.c -- float version of k_tan.c
 * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

float __kernel_tanf(float x, float y, int iy)
{
	float z, r, v, w, s;
	int32_t ix, hx;

	static const float one = 1.0000000000e+00;			/* 0x3f800000 */
	static const float pio4 = 7.8539812565e-01;			/* 0x3f490fda */
	static const float pio4lo = 3.7748947079e-08;		/* 0x33222168 */
	static const float T[] = {
		3.3333334327e-01,					/* 0x3eaaaaab */
		1.3333334029e-01,					/* 0x3e088889 */
		5.3968254477e-02,					/* 0x3d5d0dd1 */
		2.1869488060e-02,					/* 0x3cb327a4 */
		8.8632395491e-03,					/* 0x3c11371f */
		3.5920790397e-03,					/* 0x3b6b6916 */
		1.4562094584e-03,					/* 0x3abede48 */
		5.8804126456e-04,					/* 0x3a1a26c8 */
		2.4646313977e-04,					/* 0x398137b9 */
		7.8179444245e-05,					/* 0x38a3f445 */
		7.1407252108e-05,					/* 0x3895c07a */
		-1.8558637748e-05,					/* 0xb79bae5f */
		2.5907305826e-05					/* 0x37d95384 */
	};
	
	GET_FLOAT_WORD(hx, x);
	ix = hx & IC(0x7fffffff);			/* high word of |x| */
	if (ix < IC(0x31800000))			/* x < 2**-28 */
	{
		if ((int32_t) x == 0)
		{								/* generate inexact */
			if ((ix | (iy + 1)) == 0)
				return one / __ieee754_fabsf(x);
			else
				return (iy == 1) ? x : -one / x;
		}
	}
	if (ix >= IC(0x3f2ca140))
	{									/* |x|>=0.6744 */
		if (hx < 0)
		{
			x = -x;
			y = -y;
		}
		z = pio4 - x;
		w = pio4lo - y;
		x = z + w;
		y = 0.0;
		if (__ieee754_fabsf(x) < 0x1p-13f)
			return (1 - ((hx >> 30) & 2)) * iy * (1.0f - 2 * iy * x);
	}
	z = x * x;
	w = z * z;
	/* Break x^5*(T[1]+x^2*T[2]+...) into
	 *    x^5(T[1]+x^4*T[3]+...+x^20*T[11]) +
	 *    x^5(x^2*(T[2]+x^4*T[4]+...+x^22*[T12]))
	 */
	r = T[1] + w * (T[3] + w * (T[5] + w * (T[7] + w * (T[9] + w * T[11]))));
	v = z * (T[2] + w * (T[4] + w * (T[6] + w * (T[8] + w * (T[10] + w * T[12])))));
	s = z * x;
	r = y + z * (s * (r + v) + y);
	r += T[0] * s;
	w = x + r;
	if (ix >= IC(0x3f2ca140))
	{
		v = (float) iy;
		return (float) (1 - ((hx >> 30) & 2)) * (v - 2.0f * (x - (w * w / (w + v) - r)));
	}
	if (iy == 1)
		return w;
	else
	{									/* if allow error up to 2 ulp,
										   simply return -1.0/(x+r) here */
		/*  compute -1.0/(x+r) accurately */
		float a, t;
		int32_t i;

		z = w;
		GET_FLOAT_WORD(i, z);
		SET_FLOAT_WORD(z, i & UC(0xfffff000));
		v = r - (z - x);				/* z+v = r+x */
		t = a = -1.0f / w;				/* a = -1.0/w */
		GET_FLOAT_WORD(i, t);
		SET_FLOAT_WORD(t, i & UC(0xfffff000));
		s = 1.0f + t * z;
		return t + a * (s + t * v);
	}
}

```

`k_tanl.c`:

```c
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/*
  Long double expansions are
  Copyright (C) 2001 Stephen L. Moshier <moshier@na-net.ornl.gov>
  and are incorporated herein by permission of the author.  The author
  reserves the right to distribute this material elsewhere under different
  copying permissions.  These modifications are distributed here under
  the following terms:

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, see
    <http://www.gnu.org/licenses/>.  */

/* __kernel_tanl( x, y, k )
 * kernel tan function on [-pi/4, pi/4], pi/4 ~ 0.7854
 * Input x is assumed to be bounded by ~pi/4 in magnitude.
 * Input y is the tail of x.
 * Input k indicates whether tan (if k=1) or
 * -1/tan (if k= -1) is returned.
 *
 * Algorithm
 *	1. Since tan(-x) = -tan(x), we need only to consider positive x.
 *	2. if x < 2^-33, return x with inexact if x!=0.
 *	3. tan(x) is approximated by a rational form x + x^3 / 3 + x^5 R(x^2)
 *          on [0,0.67433].
 *
 *	   Note: tan(x+y) = tan(x) + tan'(x)*y
 *		          ~ tan(x) + (1+x*x)*y
 *	   Therefore, for better accuracy in computing tan(x+y), let
 *		r = x^3 * R(x^2)
 *	   then
 *		tan(x+y) = x + (x^3 / 3 + (x^2 *(r+y)+y))
 *
 *      4. For x in [0.67433,pi/4],  let y = pi/4 - x, then
 *		tan(x) = tan(pi/4-y) = (1-tan(y))/(1+tan(y))
 *		       = 1 - 2*(tan(y) - (tan(y)^2)/(1+tan(y)))
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif


long double __kernel_tanl(long double x, long double y, int iy)
{
	long double z, r, v, w, s;
	long double absx = __ieee754_fabsl(x);
	int sign = 0;

	static const long double one = 1.0L;
	static const long double pio4hi = 0xc.90fdaa22168c235p-4L;
	static const long double pio4lo = -0x3.b399d747f23e32ecp-68L;
	/* tan x = x + x^3 / 3 + x^5 T(x^2)/U(x^2)
	   0 <= x <= 0.6743316650390625
	   Peak relative error 8.0e-36  */
	static const long double TH = 3.333333333333333333333333333333333333333E-1L;
	static const long double T0 = -1.813014711743583437742363284336855889393E7L;
	static const long double T1 = 1.320767960008972224312740075083259247618E6L;
	static const long double T2 = -2.626775478255838182468651821863299023956E4L;
	static const long double T3 = 1.764573356488504935415411383687150199315E2L;
	static const long double T4 = -3.333267763822178690794678978979803526092E-1L;
	static const long double U0 = -1.359761033807687578306772463253710042010E8L;
	static const long double U1 = 6.494370630656893175666729313065113194784E7L;
	static const long double U2 = -4.180787672237927475505536849168729386782E6L;
	static const long double U3 = 8.031643765106170040139966622980914621521E4L;
	static const long double U4 = -5.323131271912475695157127875560667378597E2L;
	/* 1.000000000000000000000000000000000000000E0 */

	if (absx < 0x1p-33L)
	{
		if ((int32_t) x == 0)
		{								/* generate inexact */
			if (x == 0 && iy == -1)
				return one / __ieee754_fabsl(x);
			else
				return (iy == 1) ? x : -one / x;
		}
	}
	if (absx >= 0.6743316650390625L)
	{
		if (signbit(x))
		{
			x = -x;
			y = -y;
			sign = -1;
		} else
			sign = 1;
		z = pio4hi - x;
		w = pio4lo - y;
		x = z + w;
		y = 0.0;
	}
	z = x * x;
	r = T0 + z * (T1 + z * (T2 + z * (T3 + z * T4)));
	v = U0 + z * (U1 + z * (U2 + z * (U3 + z * (U4 + z))));
	r = r / v;

	s = z * x;
	r = y + z * (s * r + y);
	r += TH * s;
	w = x + r;
	if (sign != 0)
	{
		v = (long double) iy;
		w = (v - 2.0 * (x - (w * w / (w + v) - r)));
		if (sign < 0)
			w = -w;
		return w;
	}
	if (iy == 1)
		return w;
	else
		return -1.0 / (x + r);
}

```

`makefile.sunsoft`:

```sunsoft
#
#  @(#)Makefile 1.4 95/01/18 
# 
#  ====================================================
#  Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
# 
#  Developed at SunSoft, a Sun Microsystems, Inc. business.
#  Permission to use, copy, modify, and distribute this
#  software is freely granted, provided that this notice 
#  is preserved.
#  ====================================================
# 
# 

#
# There are two options in making libm at fdlibm compile time:
# 	_IEEE_LIBM 	--- IEEE libm; smaller, and somewhat faster
#	_MULTI_LIBM	--- Support multi-standard at runtime by 
#			    imposing wrapper functions defined in 
#			    fdlibm.h:
#				_IEEE_MODE 	-- IEEE
#				_XOPEN_MODE 	-- X/OPEN
#				_POSIX_MODE 	-- POSIX/ANSI
#				_SVID3_MODE 	-- SVID
#
# Here is how to set up CFLAGS to create the desired libm at 
# compile time:
#
# 	CFLAGS = -D_IEEE_LIBM		... IEEE libm (recommended)
#	CFLAGS = -D_SVID3_MODE	... Multi-standard supported
#					    libm with SVID as the 
#					    default standard
#	CFLAGS = -D_XOPEN_MODE	... Multi-standard supported
#					    libm with XOPEN as the 
#					    default standard
#	CFLAGS = -D_POSIX_MODE	... Multi-standard supported
#					    libm with POSIX as the 
#					    default standard
#	CFLAGS = 			... Multi-standard supported
#					    libm with IEEE as the 
#					    default standard
# 
# NOTE: if scalb's second arguement is an int, then one must
# define _SCALB_INT in CFLAGS. The default prototype of scalb
# is double scalb(double, double)
#


#
# Default IEEE libm
#
CFLAGS = -D_IEEE_LIBM 

CC = cc

INCFILES = fdlibm.h
.INIT: $(INCFILES)
.KEEP_STATE:
src = 	k_standard.c k_rem_pio2.c \
	k_cos.c k_sin.c k_tan.c \
	e_acos.c e_acosh.c e_asin.c e_atan2.c \
	e_atanh.c e_cosh.c e_exp.c e_fmod.c \
	e_gamma.c e_gamma_r.c e_hypot.c e_j0.c \
	e_j1.c e_jn.c e_lgamma.c e_lgamma_r.c \
	e_log.c e_log10.c e_pow.c e_rem_pio2.c e_remainder.c \
	e_scalb.c e_sinh.c e_sqrt.c \
	w_acos.c w_acosh.c w_asin.c w_atan2.c \
	w_atanh.c w_cosh.c w_exp.c w_fmod.c \
	w_gamma.c w_gamma_r.c w_hypot.c w_j0.c \
	w_j1.c w_jn.c w_lgamma.c w_lgamma_r.c \
	w_log.c w_log10.c w_pow.c w_remainder.c \
	w_scalb.c w_sinh.c w_sqrt.c \
	s_asinh.c s_atan.c s_cbrt.c s_ceil.c s_copysign.c \
	s_cos.c s_erf.c s_expm1.c s_fabs.c s_finite.c s_floor.c \
	s_frexp.c s_ilogb.c s_isnan.c s_ldexp.c s_lib_version.c \
	s_log1p.c s_logb.c s_matherr.c s_modf.c s_nextafter.c \
	s_rint.c s_scalbn.c s_signgam.c s_significand.c s_sin.c \
	s_tan.c s_tanh.c

obj = 	k_standard.o k_rem_pio2.o \
	k_cos.o k_sin.o k_tan.o \
	e_acos.o e_acosh.o e_asin.o e_atan2.o \
	e_atanh.o e_cosh.o e_exp.o e_fmod.o \
	e_gamma.o e_gamma_r.o e_hypot.o e_j0.o \
	e_j1.o e_jn.o e_lgamma.o e_lgamma_r.o \
	e_log.o e_log10.o e_pow.o e_rem_pio2.o e_remainder.o  \
	e_scalb.o e_sinh.o e_sqrt.o \
	w_acos.o w_acosh.o w_asin.o w_atan2.o \
	w_atanh.o w_cosh.o w_exp.o w_fmod.o \
	w_gamma.o w_gamma_r.o w_hypot.o w_j0.o \
	w_j1.o w_jn.o w_lgamma.o w_lgamma_r.o \
	w_log.o w_log10.o w_pow.o w_remainder.o \
	w_scalb.o w_sinh.o w_sqrt.o \
	s_asinh.o s_atan.o s_cbrt.o s_ceil.o s_copysign.o \
	s_cos.o s_erf.o s_expm1.o s_fabs.o s_finite.o s_floor.o \
	s_frexp.o s_ilogb.o s_isnan.o s_ldexp.o s_lib_version.o \
	s_log1p.o s_logb.o s_matherr.o s_modf.o s_nextafter.o \
	s_rint.o s_scalbn.o s_signgam.o s_significand.o s_sin.o \
	s_tan.o s_tanh.o

all: libm.a 

libm.a : $(obj) 
	ar cru libm.a $(obj)
	ranlib libm.a

source: $(src) README

clean: 
	/bin/rm -f $(obj) a.out libm.a

```

`manifests/src`:

```
contrib/fdlibm/.depend
contrib/fdlibm/.master
contrib/fdlibm/MD5
contrib/fdlibm/Makefile.in
contrib/fdlibm/Makefile.in.ok
contrib/fdlibm/Product-Info
contrib/fdlibm/configure
contrib/fdlibm/configure.in
contrib/fdlibm/e_acos.c
contrib/fdlibm/e_acosh.c
contrib/fdlibm/e_asin.c
contrib/fdlibm/e_atan2.c
contrib/fdlibm/e_atanh.c
contrib/fdlibm/e_cosh.c
contrib/fdlibm/e_exp.c
contrib/fdlibm/e_fmod.c
contrib/fdlibm/e_gamma.c
contrib/fdlibm/e_gamma_r.c
contrib/fdlibm/e_hypot.c
contrib/fdlibm/e_j0.c
contrib/fdlibm/e_j1.c
contrib/fdlibm/e_jn.c
contrib/fdlibm/e_lgamma.c
contrib/fdlibm/e_lgamma_r.c
contrib/fdlibm/e_log.c
contrib/fdlibm/e_log10.c
contrib/fdlibm/e_pow.c
contrib/fdlibm/e_rem_pio2.c
contrib/fdlibm/e_remainder.c
contrib/fdlibm/e_scalb.c
contrib/fdlibm/e_sinh.c
contrib/fdlibm/e_sqrt.c
contrib/fdlibm/fdlibm.h
contrib/fdlibm/index
contrib/fdlibm/index.html
contrib/fdlibm/k_cos.c
contrib/fdlibm/k_rem_pio2.c
contrib/fdlibm/k_sin.c
contrib/fdlibm/k_standard.c
contrib/fdlibm/k_tan.c
contrib/fdlibm/makefile.sunsoft
contrib/fdlibm/manifests/bin
contrib/fdlibm/manifests/src
contrib/fdlibm/math.h
contrib/fdlibm/math.h.68040
contrib/fdlibm/mkinstalldirs
contrib/fdlibm/readme
contrib/fdlibm/s_asinh.c
contrib/fdlibm/s_atan.c
contrib/fdlibm/s_cbrt.c
contrib/fdlibm/s_ceil.c
contrib/fdlibm/s_copysign.c
contrib/fdlibm/s_cos.c
contrib/fdlibm/s_erf.c
contrib/fdlibm/s_expm1.c
contrib/fdlibm/s_fabs.c
contrib/fdlibm/s_finite.c
contrib/fdlibm/s_floor.c
contrib/fdlibm/s_frexp.c
contrib/fdlibm/s_ilogb.c
contrib/fdlibm/s_isnan.c
contrib/fdlibm/s_ldexp.c
contrib/fdlibm/s_lib_version.c
contrib/fdlibm/s_log1p.c
contrib/fdlibm/s_logb.c
contrib/fdlibm/s_matherr.c
contrib/fdlibm/s_modf.c
contrib/fdlibm/s_nextafter.c
contrib/fdlibm/s_rint.c
contrib/fdlibm/s_scalbn.c
contrib/fdlibm/s_signgam.c
contrib/fdlibm/s_significand.c
contrib/fdlibm/s_sin.c
contrib/fdlibm/s_tan.c
contrib/fdlibm/s_tanh.c
contrib/fdlibm/w_acos.c
contrib/fdlibm/w_acosh.c
contrib/fdlibm/w_asin.c
contrib/fdlibm/w_atan2.c
contrib/fdlibm/w_atanh.c
contrib/fdlibm/w_cosh.c
contrib/fdlibm/w_exp.c
contrib/fdlibm/w_fmod.c
contrib/fdlibm/w_gamma.c
contrib/fdlibm/w_gamma_r.c
contrib/fdlibm/w_hypot.c
contrib/fdlibm/w_j0.c
contrib/fdlibm/w_j1.c
contrib/fdlibm/w_jn.c
contrib/fdlibm/w_lgamma.c
contrib/fdlibm/w_lgamma_r.c
contrib/fdlibm/w_log.c
contrib/fdlibm/w_log10.c
contrib/fdlibm/w_pow.c
contrib/fdlibm/w_remainder.c
contrib/fdlibm/w_scalb.c
contrib/fdlibm/w_sinh.c
contrib/fdlibm/w_sqrt.c

```

`readme`:

```

	  *********************************
 	  * Announcing FDLIBM Version 5.3 *
	  *********************************
============================================================
			FDLIBM
============================================================
	developed at Sun Microsystems, Inc. 

What's new in FDLIBM 5.3?

CONFIGURE
	To build FDLIBM, edit the supplied Makefile or create
	a local Makefile by running "sh configure" 
	using the supplied configure script contributed by Nelson Beebe

BUGS FIXED

    1. e_pow.c incorrect results when 
	x is very close to -1.0 and y is very large, e.g.
  	pow(-1.0000000000000002e+00,4.5035996273704970e+15) = 0
  	pow(-9.9999999999999978e-01,4.5035996273704970e+15) = 0
	Correct results are close to -e and -1/e.

    2. k_tan.c error was > 1 ulp target for FDLIBM
	5.2: Worst error at least 1.45 ulp at
	tan(1.7765241907548024E+269) = 1.7733884462610958E+16
	5.3: Worst error 0.96 ulp

NOT FIXED YET

    3. Compiler failure on non-standard code
	Statements like
	            *(1+(int*)&t1) = 0;
	are not standard C and cause some optimizing compilers (e.g. GCC)
	to generate bad code under optimization.    These cases
	are to be addressed in the next release.
	
FDLIBM (Freely Distributable LIBM) is a C math library 
for machines that support IEEE 754 floating-point arithmetic. 
In this release, only double precision is supported.

FDLIBM is intended to provide a reasonably portable (see 
assumptions below), reference quality (below one ulp for
major functions like sin,cos,exp,log) math library 
(libm.a).  For a copy of FDLIBM, please see
	http://www.netlib.org/fdlibm/
or
	http://www.validlab.com/software/

--------------
1. ASSUMPTIONS
--------------
FDLIBM (double precision version) assumes:
 a.  IEEE 754 style (if not precise compliance) arithmetic;
 b.  32 bit 2's complement integer arithmetic;
 c.  Each double precision floating-point number must be in IEEE 754 
     double format, and that each number can be retrieved as two 32-bit 
     integers through the using of pointer bashing as in the example 
     below:

     Example: let y = 2.0
	double fp number y: 	2.0
	IEEE double format:	0x4000000000000000

	Referencing y as two integers:
	*(int*)&y,*(1+(int*)&y) =	{0x40000000,0x0} (on sparc)
					{0x0,0x40000000} (on 386)

	Note: Four macros are defined in fdlibm.h to handle this kind of
	retrieving:

	__HI(x)		the high part of a double x 
			(sign,exponent,the first 21 significant bits)
	__LO(x)		the least 32 significant bits of x
	__HIp(x)	same as __HI except that the argument is a pointer
			to a double
	__LOp(x)	same as __LO except that the argument is a pointer
			to a double
	
	To ensure obtaining correct ordering, one must define  __LITTLE_ENDIAN
	during compilation for little endian machine (like 386,486). The 
	default is big endian.

	If the behavior of pointer bashing is undefined, one may hack on the 
	macro in fdlibm.h.
	
  d. IEEE exceptions may trigger "signals" as is common in Unix
     implementations. 

-------------------
2. EXCEPTION CASES
-------------------
All exception cases in the FDLIBM functions will be mapped
to one of the following four exceptions:

   +-huge*huge, +-tiny*tiny,    +-1.0/0.0,	+-0.0/0.0
    (overflow)	(underflow)  (divided-by-zero) 	(invalid)

For example, log(0) is a singularity and is thus mapped to 
	-1.0/0.0 = -infinity.
That is, FDLIBM's log will compute -one/zero and return the
computed value.  On an IEEE machine, this will trigger the 
divided-by-zero exception and a negative infinity is returned by 
default.

Similarly, exp(-huge) will be mapped to tiny*tiny to generate
an underflow signal. 


--------------------------------
3. STANDARD CONFORMANCE WRAPPER 
--------------------------------
The default FDLIBM functions (compiled with -D_IEEE_LIBM flag)  
are in "IEEE spirit" (i.e., return the most reasonable result in 
floating-point arithmetic). If one wants FDLIBM to comply with
standards like SVID, X/OPEN, or POSIX/ANSI, then one can 
create a multi-standard compliant FDLIBM. In this case, each
function in FDLIBM is actually a standard compliant wrapper
function.  

File organization:
    1. For FDLIBM's kernel (internal) function,
		File name	Entry point
		---------------------------
		k_sin.c		__kernel_sin
		k_tan.c		__kernel_tan
		---------------------------
    2. For functions that have no standards conflict 
		File name	Entry point
		---------------------------
		s_sin.c		sin
		s_erf.c		erf
		---------------------------
    3. Ieee754 core functions
		File name	Entry point
		---------------------------
		e_exp.c		__ieee754_exp
		e_sinh.c	__ieee754_sinh
		---------------------------
    4. Wrapper functions
		File name	Entry point
		---------------------------
		w_exp.c		exp
		w_sinh.c	sinh
		---------------------------

Wrapper functions will twist the result of the ieee754 
function to comply to the standard specified by the value 
of _LIB_VERSION 
    if _LIB_VERSION = _IEEE_, return the ieee754 result;
    if _LIB_VERSION = _SVID_, return SVID result;
    if _LIB_VERSION = _XOPEN_, return XOPEN result;
    if _LIB_VERSION = _POSIX_, return POSIX/ANSI result.
(These are macros, see fdlibm.h for their definition.)


--------------------------------
4. HOW TO CREATE FDLIBM's libm.a
--------------------------------
There are two types of libm.a. One is IEEE only, and the other is
multi-standard compliant (supports IEEE,XOPEN,POSIX/ANSI,SVID).

To create the IEEE only libm.a, use 
	    make "CFLAGS = -D_IEEE_LIBM"	 
This will create an IEEE libm.a, which is smaller in size, and 
somewhat faster.

To create a multi-standard compliant libm, use
    make "CFLAGS = -D_IEEE_MODE"   --- multi-standard fdlibm: default
					 to IEEE
    make "CFLAGS = -D_XOPEN_MODE"  --- multi-standard fdlibm: default
					 to X/OPEN
    make "CFLAGS = -D_POSIX_MODE"  --- multi-standard fdlibm: default
					 to POSIX/ANSI
    make "CFLAGS = -D_SVID3_MODE"  --- multi-standard fdlibm: default
					 to SVID


Here is how one makes a SVID compliant libm.
    Make the library by
		make "CFLAGS = -D_SVID3_MODE".
    The libm.a of FDLIBM will be multi-standard compliant and 
    _LIB_VERSION is initialized to the value _SVID_ . 

    example1:
    ---------
	    main()
	    {
		double y0();
		printf("y0(1e300) = %1.20e\n",y0(1e300));
		exit(0);
	    }

    % cc example1.c libm.a
    % a.out
    y0: TLOSS error
    y0(1e300) = 0.00000000000000000000e+00


It is possible to change the default standard in multi-standard 
fdlibm. Here is an example of how to do it:
    example2:
    ---------
	#include "fdlibm.h"	/* must include FDLIBM's fdlibm.h */
	main()
	{
		double y0();
		_LIB_VERSION =  _IEEE_;
		printf("IEEE: y0(1e300) = %1.20e\n",y0(1e300));
		_LIB_VERSION = _XOPEN_;
		printf("XOPEN y0(1e300) = %1.20e\n",y0(1e300));
		_LIB_VERSION = _POSIX_;
		printf("POSIX y0(1e300) = %1.20e\n",y0(1e300));
		_LIB_VERSION = _SVID_;
		printf("SVID  y0(1e300) = %1.20e\n",y0(1e300));
		exit(0);
	}

    % cc example2.c libm.a
    % a.out
      IEEE: y0(1e300) = -1.36813604503424810557e-151
      XOPEN y0(1e300) = 0.00000000000000000000e+00
      POSIX y0(1e300) = 0.00000000000000000000e+00
      y0: TLOSS error
      SVID  y0(1e300) = 0.00000000000000000000e+00

Note:	Here _LIB_VERSION is a global variable. If global variables 
	are forbidden, then one should modify fdlibm.h to change
	_LIB_VERSION to be a global constant. In this case, one
	may not change the value of _LIB_VERSION as in example2.

---------------------------
5. NOTES ON PORTING FDLIBM
---------------------------
	Care must be taken when installing FDLIBM over existing
	libm.a.
	All co-existing function prototypes must agree, otherwise
	users will encounter mysterious failures.

	So far, the only known likely conflict is the declaration 
	of the IEEE recommended function scalb:

		double scalb(double,double)	(1)	SVID3 defined
		double scalb(double,int)	(2)	IBM,DEC,...

	FDLIBM follows Sun definition and use (1) as default. 
	If one's existing libm.a uses (2), then one may raise
	the flags _SCALB_INT during the compilation of FDLIBM
	to get the correct function prototype.
	(E.g., make "CFLAGS = -D_IEEE_LIBM -D_SCALB_INT".)
	NOTE that if -D_SCALB_INT is raised, it won't be SVID3
	conformant.

--------------
6. PROBLEMS ?
--------------
Please send comments and bug reports to the electronic mail address
suggested by: 
		fdlibm-comments AT sun.com


```

`s_asinh.c`:

```c
/* @(#)s_asinh.c 1.3 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/* asinh(x)
 * Method :
 *	Based on
 *		asinh(x) = sign(x) * log [ |x| + sqrt(x*x+1) ]
 *	we have
 *	asinh(x) := x  if  1+x*x=1,
 *		 := sign(x)*(log(x)+ln2)) for large |x|, else
 *		 := sign(x)*log(2|x|+1/(|x|+sqrt(x*x+1))) if|x|>2, else
 *		 := sign(x)*log1p(|x| + x^2/(1 + sqrt(1+x^2)))
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_asinh

double __ieee754_asinh(double x)
{
	double w;
	int32_t hx, ix;

	static const double one = 1.00000000000000000000e+00;	/* 0x3FF00000, 0x00000000 */
	static const double ln2 = 6.93147180559945286227e-01;	/* 0x3FE62E42, 0xFEFA39EF */
	static const double hugeval = 1.00000000000000000000e+300;
	
	GET_HIGH_WORD(hx, x);
	ix = hx & IC(0x7fffffff);
	if (ix < IC(0x3e300000))
	{									/* |x|<2**-28 */
		if (hugeval + x > one)
			return x;					/* return x inexact except 0 */
	}
	if (ix > IC(0x41b00000))
	{									/* |x| > 2**28 */
		if (ix >= IC(0x7ff00000))
			return x + x;				/* x is inf or NaN */
		w = __ieee754_log(__ieee754_fabs(x)) + ln2;
	} else
	{
		double xa = __ieee754_fabs(x);

		if (ix > IC(0x40000000))
		{								/* 2**28 > |x| > 2.0 */
			w = __ieee754_log(2.0 * xa + one / (__ieee754_sqrt(xa * xa + one) + xa));
		} else
		{								/* 2.0 > |x| > 2**-28 */
			double t = xa * xa;

			w = __ieee754_log1p(xa + t / (one + __ieee754_sqrt(one + t)));
		}
	}
	if (hx > 0)
		return w;
	return -w;
}

#endif

double __asinh(double x)
{
	return __ieee754_asinh(x);
}

__typeof(__asinh) asinh __attribute__((weak, alias("__asinh")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(__asinhl) __asinhl __attribute__((alias("__asinh")));
__typeof(__asinhl) asinhl __attribute__((weak, alias("__asinh")));
#endif

```

`s_asinhf.c`:

```c
/* s_asinhf.c -- float version of s_asinh.c.
 * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_asinh

float __ieee754_asinhf(float x)
{
	float w;
	int32_t hx, ix;

	static const float one = 1.0000000000e+00;		/* 0x3F800000 */
	static const float ln2 = 6.9314718246e-01;		/* 0x3f317218 */
	static const float hugeval = 1.0000000000e+30;
	
	GET_FLOAT_WORD(hx, x);
	ix = hx & IC(0x7fffffff);
	if (ix < IC(0x38000000))
	{									/* |x|<2**-14 */
		if (hugeval + x > one)
			return x;					/* return x inexact except 0 */
	}
	if (ix > IC(0x47000000))
	{									/* |x| > 2**14 */
		if (!FLT_UWORD_IS_FINITE(ix))
			return x + x;				/* x is inf or NaN */
		w = __ieee754_logf(__ieee754_fabsf(x)) + ln2;
	} else
	{
		float xa = __ieee754_fabsf(x);

		if (ix > IC(0x40000000))
		{								/* 2**14 > |x| > 2.0 */
			w = __ieee754_logf(2.0f * xa + one / (__ieee754_sqrtf(xa * xa + one) + xa));
		} else
		{								/* 2.0 > |x| > 2**-14 */
			float t = xa * xa;

			w = __ieee754_log1pf(xa + t / (one + __ieee754_sqrtf(one + t)));
		}
	}
	if (hx > 0)
		return w;
	return -w;
}

#endif

float __asinhf(float x)
{
	return __ieee754_asinhf(x);
}

__typeof(__asinhf) asinhf __attribute__((weak, alias("__asinhf")));

```

`s_asinhl.c`:

```c
/* s_asinhl.c -- long double version of s_asinh.c.
 * Conversion to long double by Ulrich Drepper,
 * Cygnus Support, drepper@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/* asinhl(x)
 * Method :
 *	Based on
 *		asinhl(x) = signl(x) * logl [ |x| + sqrtl(x*x+1) ]
 *	we have
 *	asinhl(x) := x  if  1+x*x=1,
 *		  := signl(x)*(logl(x)+ln2)) for large |x|, else
 *		  := signl(x)*logl(2|x|+1/(|x|+sqrtl(x*x+1))) if|x|>2, else
 *		  := signl(x)*log1pl(|x| + x^2/(1 + sqrtl(1+x^2)))
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

#ifndef __have_fpu_asinh

long double __ieee754_asinhl(long double x)
{
	long double t, w;
	int32_t hx, ix;

	static const long double one = 1.000000000000000000000e+00L;	/* 0x3FFF, 0x00000000, 0x00000000 */
	static const long double ln2 = 6.931471805599453094287e-01L;	/* 0x3FFE, 0xB17217F7, 0xD1CF79AC */
	static const long double hugeval = 1.000000000000000000e+4900L;

	GET_LDOUBLE_EXP(hx, x);
	ix = hx & IEEE854_LONG_DOUBLE_MAXEXP;
	if (ix < 0x3fde)
	{									/* |x|<2**-34 */
		if (hugeval + x > one)
			return x;					/* return x inexact except 0 */
	}
	if (ix > 0x4020)
	{									/* |x| > 2**34 */
		if (ix == IEEE854_LONG_DOUBLE_MAXEXP)
			return x + x;				/* x is inf or NaN */
		w = __ieee754_logl(__ieee754_fabsl(x)) + ln2;
	} else
	{
		long double xa = __ieee754_fabsl(x);

		if (ix > 0x4000)
		{								/* 2**34 > |x| > 2.0 */
			w = __ieee754_logl(2.0L * xa + one / (__ieee754_sqrtl(xa * xa + one) + xa));
		} else
		{								/* 2.0 > |x| > 2**-28 */
			t = xa * xa;
			w = __ieee754_log1pl(xa + t / (one + __ieee754_sqrtl(one + t)));
		}
	}
	if (hx > 0)
		return w;
	return -w;
}

#endif

long double __asinhl(long double x)
{
	return __ieee754_asinhl(x);
}

__typeof(__asinhl) asinhl __attribute__((weak, alias("__asinhl")));

#endif

```

`s_atan.c`:

```c
/* @(#)s_atan.c 1.3 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 *
 */

/* atan(x)
 * Method
 *   1. Reduce x to positive by atan(x) = -atan(-x).
 *   2. According to the integer k=4t+0.25 chopped, t=x, the argument
 *      is further reduced to one of the following intervals and the
 *      arctangent of t is evaluated by the corresponding formula:
 *
 *      [0,7/16]      atan(x) = t-t^3*(a1+t^2*(a2+...(a10+t^2*a11)...)
 *      [7/16,11/16]  atan(x) = atan(1/2) + atan( (t-0.5)/(1+t/2) )
 *      [11/16.19/16] atan(x) = atan( 1 ) + atan( (t-1)/(1+t) )
 *      [19/16,39/16] atan(x) = atan(3/2) + atan( (t-1.5)/(1+1.5t) )
 *      [39/16,INF]   atan(x) = atan(INF) + atan( -1/t )
 *
 * Constants:
 * The hexadecimal values are the intended ones for the following 
 * constants. The decimal values may be used, provided that the 
 * compiler will convert from decimal to binary accurately enough 
 * to produce the hexadecimal values shown.
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_atan

double __ieee754_atan(double x)
{
	double w, s1, s2, z;
	int32_t ix, hx, id;

	static const double atanhi[] = {
		4.63647609000806093515e-01,			/* atan(0.5)hi 0x3FDDAC67, 0x0561BB4F */
		7.85398163397448278999e-01,			/* atan(1.0)hi 0x3FE921FB, 0x54442D18 */
		9.82793723247329054082e-01,			/* atan(1.5)hi 0x3FEF730B, 0xD281F69B */
		1.57079632679489655800e+00			/* atan(inf)hi 0x3FF921FB, 0x54442D18 */
	};
	
	static const double atanlo[] = {
		2.26987774529616870924e-17,			/* atan(0.5)lo 0x3C7A2B7F, 0x222F65E2 */
		3.06161699786838301793e-17,			/* atan(1.0)lo 0x3C81A626, 0x33145C07 */
		1.39033110312309984516e-17,			/* atan(1.5)lo 0x3C700788, 0x7AF0CBBD */
		6.12323399573676603587e-17			/* atan(inf)lo 0x3C91A626, 0x33145C07 */
	};
	
	static const double aT[] = {
		3.33333333333329318027e-01,			/* 0x3FD55555, 0x5555550D */
		-1.99999999998764832476e-01,		/* 0xBFC99999, 0x9998EBC4 */
		1.42857142725034663711e-01,			/* 0x3FC24924, 0x920083FF */
		-1.11111104054623557880e-01,		/* 0xBFBC71C6, 0xFE231671 */
		9.09088713343650656196e-02,			/* 0x3FB745CD, 0xC54C206E */
		-7.69187620504482999495e-02,		/* 0xBFB3B0F2, 0xAF749A6D */
		6.66107313738753120669e-02,			/* 0x3FB10D66, 0xA0D03D51 */
		-5.83357013379057348645e-02,		/* 0xBFADDE2D, 0x52DEFD9A */
		4.97687799461593236017e-02,			/* 0x3FA97B4B, 0x24760DEB */
		-3.65315727442169155270e-02,		/* 0xBFA2B444, 0x2C6A6C2F */
		1.62858201153657823623e-02			/* 0x3F90AD3A, 0xE322DA11 */
	};
	
	static const double one = 1.0;
	static const double hugeval = 1.0e300;

	GET_HIGH_WORD(hx, x);
	ix = hx & IC(0x7fffffff);
	if (ix >= IC(0x44100000))
	{									/* if |x| >= 2^66 */
		uint32_t low;

		GET_LOW_WORD(low, x);
		if (ix > IC(0x7ff00000) || (ix == IC(0x7ff00000) && (low != 0)))
			return x + x;				/* NaN */
		if (hx > 0)
			return atanhi[3] + atanlo[3];
		else
			return -atanhi[3] - atanlo[3];
	}
	if (ix < IC(0x3fdc0000))
	{									/* |x| < 0.4375 */
		if (ix < IC(0x3e200000))
		{								/* |x| < 2^-29 */
			if (hugeval + x > one)
				return x;				/* raise inexact */
		}
		id = -1;
	} else
	{
		x = __ieee754_fabs(x);
		if (ix < IC(0x3ff30000))
		{								/* |x| < 1.1875 */
			if (ix < IC(0x3fe60000))
			{							/* 7/16 <=|x|<11/16 */
				id = 0;
				x = (2.0 * x - one) / (2.0 + x);
			} else
			{							/* 11/16<=|x|< 19/16 */
				id = 1;
				x = (x - one) / (x + one);
			}
		} else
		{
			if (ix < IC(0x40038000))
			{							/* |x| < 2.4375 */
				id = 2;
				x = (x - 1.5) / (one + 1.5 * x);
			} else
			{							/* 2.4375 <= |x| < 2^66 */
				id = 3;
				x = -1.0 / x;
			}
		}
	}
	/* end of argument reduction */
	z = x * x;
	w = z * z;
	/* break sum from i=0 to 10 aT[i]z**(i+1) into odd and even poly */
	s1 = z * (aT[0] + w * (aT[2] + w * (aT[4] + w * (aT[6] + w * (aT[8] + w * aT[10])))));
	s2 = w * (aT[1] + w * (aT[3] + w * (aT[5] + w * (aT[7] + w * aT[9]))));
	if (id < 0)
		return x - x * (s1 + s2);
	else
	{
		z = atanhi[id] - ((x * (s1 + s2) - atanlo[id]) - x);
		return (hx < 0) ? -z : z;
	}
}

#endif

double __atan(double x)
{
	return __ieee754_atan(x);
}

__typeof(__atan) atan __attribute__((weak, alias("__atan")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(__atanl) __atanl __attribute__((alias("__atan")));
__typeof(__atanl) atanl __attribute__((weak, alias("__atan")));
#endif

```

`s_atanf.c`:

```c
/* s_atanf.c -- float version of s_atan.c.
 * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_atan

float __ieee754_atanf(float x)
{
	float w, s1, s2, z;
	int32_t ix, hx, id;

	static const float atanhi[] = {
		4.6364760399e-01,					/* atan(0.5)hi 0x3eed6338 */
		7.8539812565e-01,					/* atan(1.0)hi 0x3f490fda */
		9.8279368877e-01,					/* atan(1.5)hi 0x3f7b985e */
		1.5707962513e+00					/* atan(inf)hi 0x3fc90fda */
	};
	
	static const float atanlo[] = {
		5.0121582440e-09,					/* atan(0.5)lo 0x31ac3769 */
		3.7748947079e-08,					/* atan(1.0)lo 0x33222168 */
		3.4473217170e-08,					/* atan(1.5)lo 0x33140fb4 */
		7.5497894159e-08					/* atan(inf)lo 0x33a22168 */
	};
	
	static const float aT[] = {
		3.3333334327e-01,					/* 0x3eaaaaaa */
		-2.0000000298e-01,					/* 0xbe4ccccd */
		1.4285714924e-01,					/* 0x3e124925 */
		-1.1111110449e-01,					/* 0xbde38e38 */
		9.0908870101e-02,					/* 0x3dba2e6e */
		-7.6918758452e-02,					/* 0xbd9d8795 */
		6.6610731184e-02,					/* 0x3d886b35 */
		-5.8335702866e-02,					/* 0xbd6ef16b */
		4.9768779427e-02,					/* 0x3d4bda59 */
		-3.6531571299e-02,					/* 0xbd15a221 */
		1.6285819933e-02					/* 0x3c8569d7 */
	};
	
	static const float one = 1.0;
	static const float hugeval = 1.0e30;

	GET_FLOAT_WORD(hx, x);
	ix = hx & IC(0x7fffffff);
	if (ix >= IC(0x50800000))
	{									/* if |x| >= 2^34 */
		if (FLT_UWORD_IS_NAN(ix))
			return x + x;				/* NaN */
		if (hx > 0)
			return atanhi[3] + atanlo[3];
		else
			return -atanhi[3] - atanlo[3];
	}
	if (ix < IC(0x3ee00000))
	{									/* |x| < 0.4375 */
		if (ix < IC(0x31000000))
		{								/* |x| < 2^-29 */
			if (hugeval + x > one)
				return x;				/* raise inexact */
		}
		id = -1;
	} else
	{
		x = __ieee754_fabsf(x);
		if (ix < IC(0x3f980000))
		{								/* |x| < 1.1875 */
			if (ix < IC(0x3f300000))
			{							/* 7/16 <=|x|<11/16 */
				id = 0;
				x = ((float) 2.0 * x - one) / ((float) 2.0 + x);
			} else
			{							/* 11/16<=|x|< 19/16 */
				id = 1;
				x = (x - one) / (x + one);
			}
		} else
		{
			if (ix < IC(0x401c0000))
			{							/* |x| < 2.4375 */
				id = 2;
				x = (x - (float) 1.5) / (one + (float) 1.5 * x);
			} else
			{							/* 2.4375 <= |x| < 2^66 */
				id = 3;
				x = -(float) 1.0 / x;
			}
		}
	}
	/* end of argument reduction */
	z = x * x;
	w = z * z;
	/* break sum from i=0 to 10 aT[i]z**(i+1) into odd and even poly */
	s1 = z * (aT[0] + w * (aT[2] + w * (aT[4] + w * (aT[6] + w * (aT[8] + w * aT[10])))));
	s2 = w * (aT[1] + w * (aT[3] + w * (aT[5] + w * (aT[7] + w * aT[9]))));
	if (id < 0)
		return x - x * (s1 + s2);
	else
	{
		z = atanhi[id] - ((x * (s1 + s2) - atanlo[id]) - x);
		return (hx < 0) ? -z : z;
	}
}

#endif

float __atanf(float x)
{
	return __ieee754_atanf(x);
}

__typeof(__atanf) atanf __attribute__((weak, alias("__atanf")));

```

`s_atanl.c`:

```c
/*							s_atanl.c
 *
 *	Inverse circular tangent for 128-bit long double precision
 *      (arctangent)
 *
 *
 *
 * SYNOPSIS:
 *
 * long double x, y, atanl();
 *
 * y = atanl( x );
 *
 *
 *
 * DESCRIPTION:
 *
 * Returns radian angle between -pi/2 and +pi/2 whose tangent is x.
 *
 * The function uses a rational approximation of the form
 * t + t^3 P(t^2)/Q(t^2), optimized for |t| < 0.09375.
 *
 * The argument is reduced using the identity
 *    arctan x - arctan u  =  arctan ((x-u)/(1 + ux))
 * and an 83-entry lookup table for arctan u, with u = 0, 1/8, ..., 10.25.
 * Use of the table improves the execution speed of the routine.
 *
 *
 *
 * ACCURACY:
 *
 *                      Relative error:
 * arithmetic   domain     # trials      peak         rms
 *    IEEE      -19, 19       4e5       1.7e-34     5.4e-35
 *
 *
 * WARNING:
 *
 * This program uses integer operations on bit fields of floating-point
 * numbers.  It does not work with data structures other than the
 * structure assumed.
 *
 */

/* Copyright 2001 by Stephen L. Moshier <moshier@na-net.ornl.gov>

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, see
    <http://www.gnu.org/licenses/>.  */


#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

#ifndef __have_fpu_atan

long double __ieee754_atanl(long double x)
{
	int32_t k;
	int sign;
	long double t, u, p, q;
	uint32_t msw;
	
	/* arctan(k/8), k = 0, ..., 82 */
	static const long double atantbl[84] = {
		0.0000000000000000000000000000000000000000E0L,
		1.2435499454676143503135484916387102557317E-1L,	/* arctan(0.125)  */
		2.4497866312686415417208248121127581091414E-1L,
		3.5877067027057222039592006392646049977698E-1L,
		4.6364760900080611621425623146121440202854E-1L,
		5.5859931534356243597150821640166127034645E-1L,
		6.4350110879328438680280922871732263804151E-1L,
		7.1882999962162450541701415152590465395142E-1L,
		7.8539816339744830961566084581987572104929E-1L,
		8.4415398611317100251784414827164750652594E-1L,
		8.9605538457134395617480071802993782702458E-1L,
		9.4200004037946366473793717053459358607166E-1L,
		9.8279372324732906798571061101466601449688E-1L,
		1.0191413442663497346383429170230636487744E0L,
		1.0516502125483736674598673120862998296302E0L,
		1.0808390005411683108871567292171998202703E0L,
		1.1071487177940905030170654601785370400700E0L,
		1.1309537439791604464709335155363278047493E0L,
		1.1525719972156675180401498626127513797495E0L,
		1.1722738811284763866005949441337046149712E0L,
		1.1902899496825317329277337748293183376012E0L,
		1.2068173702852525303955115800565576303133E0L,
		1.2220253232109896370417417439225704908830E0L,
		1.2360594894780819419094519711090786987027E0L,
		1.2490457723982544258299170772810901230778E0L,
		1.2610933822524404193139408812473357720101E0L,
		1.2722973952087173412961937498224804940684E0L,
		1.2827408797442707473628852511364955306249E0L,
		1.2924966677897852679030914214070816845853E0L,
		1.3016288340091961438047858503666855921414E0L,
		1.3101939350475556342564376891719053122733E0L,
		1.3182420510168370498593302023271362531155E0L,
		1.3258176636680324650592392104284756311844E0L,
		1.3329603993374458675538498697331558093700E0L,
		1.3397056595989995393283037525895557411039E0L,
		1.3460851583802539310489409282517796256512E0L,
		1.3521273809209546571891479413898128509842E0L,
		1.3578579772154994751124898859640585287459E0L,
		1.3633001003596939542892985278250991189943E0L,
		1.3684746984165928776366381936948529556191E0L,
		1.3734007669450158608612719264449611486510E0L,
		1.3780955681325110444536609641291551522494E0L,
		1.3825748214901258580599674177685685125566E0L,
		1.3868528702577214543289381097042486034883E0L,
		1.3909428270024183486427686943836432060856E0L,
		1.3948567013423687823948122092044222644895E0L,
		1.3986055122719575950126700816114282335732E0L,
		1.4021993871854670105330304794336492676944E0L,
		1.4056476493802697809521934019958079881002E0L,
		1.4089588955564736949699075250792569287156E0L,
		1.4121410646084952153676136718584891599630E0L,
		1.4152014988178669079462550975833894394929E0L,
		1.4181469983996314594038603039700989523716E0L,
		1.4209838702219992566633046424614466661176E0L,
		1.4237179714064941189018190466107297503086E0L,
		1.4263547484202526397918060597281265695725E0L,
		1.4288992721907326964184700745371983590908E0L,
		1.4313562697035588982240194668401779312122E0L,
		1.4337301524847089866404719096698873648610E0L,
		1.4360250423171655234964275337155008780675E0L,
		1.4382447944982225979614042479354815855386E0L,
		1.4403930189057632173997301031392126865694E0L,
		1.4424730991091018200252920599377292525125E0L,
		1.4444882097316563655148453598508037025938E0L,
		1.4464413322481351841999668424758804165254E0L,
		1.4483352693775551917970437843145232637695E0L,
		1.4501726582147939000905940595923466567576E0L,
		1.4519559822271314199339700039142990228105E0L,
		1.4536875822280323362423034480994649820285E0L,
		1.4553696664279718992423082296859928222270E0L,
		1.4570043196511885530074841089245667532358E0L,
		1.4585935117976422128825857356750737658039E0L,
		1.4601391056210009726721818194296893361233E0L,
		1.4616428638860188872060496086383008594310E0L,
		1.4631064559620759326975975316301202111560E0L,
		1.4645314639038178118428450961503371619177E0L,
		1.4659193880646627234129855241049975398470E0L,
		1.4672716522843522691530527207287398276197E0L,
		1.4685896086876430842559640450619880951144E0L,
		1.4698745421276027686510391411132998919794E0L,
		1.4711276743037345918528755717617308518553E0L,
		1.4723501675822635384916444186631899205983E0L,
		1.4735431285433308455179928682541563973416E0L,	/* arctan(10.25) */
		1.5707963267948966192313216916397514420986E0L	/* pi/2 */
	};
	
	
	/* arctan t = t + t^3 p(t^2) / q(t^2)
	   |t| <= 0.09375
	   peak relative error 5.3e-37 */
	
	static const long double p0 = -4.283708356338736809269381409828726405572E1L;
	static const long double p1 = -8.636132499244548540964557273544599863825E1L;
	static const long double p2 = -5.713554848244551350855604111031839613216E1L;
	static const long double p3 = -1.371405711877433266573835355036413750118E1L;
	static const long double p4 = -8.638214309119210906997318946650189640184E-1L;
	static const long double q0 = 1.285112506901621042780814422948906537959E2L;
	static const long double q1 = 3.361907253914337187957855834229672347089E2L;
	static const long double q2 = 3.180448303864130128268191635189365331680E2L;
	static const long double q3 = 1.307244136980865800160844625025280344686E2L;
	static const long double q4 = 2.173623741810414221251136181221172551416E1L;
	/* static const long double q5 = 1.000000000000000000000000000000000000000E0 */
	
	static const long double hugeval = 1.0e4930L;
	
	GET_LDOUBLE_EXP(k, x);
	if (k & 0x8000)
		sign = 1;
	else
		sign = 0;

	/* Check for IEEE special cases.  */
	k &= IEEE854_LONG_DOUBLE_MAXEXP;
	if (k >= IEEE854_LONG_DOUBLE_MAXEXP)
	{
		/* NaN. */
		if (isnan(x))
			return (x + x);

		/* Infinity. */
		if (sign)
			return -atantbl[83];
		else
			return atantbl[83];
	}

	if (k <= 0x3fc5)				/* |x| < 2**-58 */
	{
		/* Raise inexact. */
		if (hugeval + x > 0.0)
			return x;
	}

	if (k >= 0x4072)				/* |x| > 2**115 */
	{
		/* Saturate result to {-,+}pi/2 */
		if (sign)
			return -atantbl[83];
		else
			return atantbl[83];
	}

	if (sign)
		x = -x;

	GET_LDOUBLE_MSW(msw, x);
	if (k > 0x4002 || (k == 0x4002 && msw >= UC(0x48000000)))				/* 10.25 */
	{
		k = 83;
		t = -1.0 / x;
	} else
	{
		/* Index of nearest table element.
		   Roundoff to integer is asymmetrical to avoid cancellation when t < 0
		   (cf. fdlibm). */
		k = 8.0 * x + 0.25;
		u = 0.125 * k;
		/* Small arctan argument.  */
		t = (x - u) / (1.0 + x * u);
	}

	/* Arctan of small argument t.  */
	u = t * t;
	p = ((((p4 * u) + p3) * u + p2) * u + p1) * u + p0;
	q = ((((u + q4) * u + q3) * u + q2) * u + q1) * u + q0;
	u = t * u * p / q + t;

	/* arctan x = arctan u  +  arctan t */
	u = atantbl[k] + u;
	if (sign)
		return -u;
	return u;
}

#endif

long double __atanl(long double x)
{
	return __ieee754_atanl(x);
}

__typeof(__atanl) atanl __attribute__((weak, alias("__atanl")));

#endif

```

`s_cbrt.c`:

```c
/* Compute cubic root of double value.
   Copyright (C) 1997-2013 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Dirk Alboth <dirka@uni-paderborn.de> and
   Ulrich Drepper <drepper@cygnus.com>, 1997.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif


double __cbrt(double x)
{
	double xm, ym, u, t2;
	int xe;
	int x_class;
	
	static const double factor[5] = {
		0.62996052494743658238361,			/* 1 / 2^(2/3) */
		0.79370052598409973737585,			/* 1 / 2^(1/3) */
		1.0,
		1.2599210498948731647672,			/* 2^(1/3) */
		1.5874010519681994747517			/* 2^(2/3) */
	};
	
	
	/* Reduce X.  XM now is an range 1.0 to 0.5.  */
	xm = __ieee754_frexp(__ieee754_fabs(x), &xe);

	/* If X is not finite or is null return it (with raising exceptions
	   if necessary.
	   Note: *Our* version of `frexp' sets XE to zero if the argument is
	   Inf or NaN.  This is not portable but faster.  */
	if (xe == 0 && ((x_class = fpclassify(x)) == FP_ZERO || x_class == FP_NAN || x_class == FP_INFINITE))
		return x + x;

	u = (0.354895765043919860
		 + ((1.50819193781584896
			 + ((-2.11499494167371287
				 + ((2.44693122563534430
					 + ((-1.83469277483613086
						 + (0.784932344976639262 - 0.145263899385486377 * xm) * xm) * xm)) * xm)) * xm)) * xm));

	t2 = u * u * u;

	ym = u * (t2 + 2.0 * xm) / (2.0 * t2 + xm) * factor[2 + xe % 3];

	return __ieee754_ldexp(x > 0.0 ? ym : -ym, xe / 3);
}

__typeof(__cbrt) cbrt __attribute__((weak, alias("__cbrt")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(cbrtl) __cbrtl __attribute__((alias("__cbrt")));
__typeof(__cbrtl) cbrtl __attribute__((weak, alias("__cbrt")));
#endif

```

`s_cbrtf.c`:

```c
/* Compute cubic root of float value.
   Copyright (C) 1997-2013 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Dirk Alboth <dirka@uni-paderborn.de> and
   Ulrich Drepper <drepper@cygnus.com>, 1997.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

float __cbrtf(float x)
{
	float xm, ym, u, t2;
	int xe;
	int x_class;
	
	static const float factor[5] = {
		0.62996052494743658238361,			/* 1 / 2^(2/3) */
		0.79370052598409973737585,			/* 1 / 2^(1/3) */
		1.0,
		1.2599210498948731647672,			/* 2^(1/3) */
		1.5874010519681994747517			/* 2^(2/3) */
	};
	
	/* Reduce X.  XM now is an range 1.0 to 0.5.  */
	xm = __ieee754_frexpf(__ieee754_fabsf(x), &xe);

	/* If X is not finite or is null return it (with raising exceptions
	   if necessary.
	   Note: *Our* version of `frexp' sets XE to zero if the argument is
	   Inf or NaN.  This is not portable but faster.  */
	if (xe == 0 && ((x_class = fpclassify(x)) == FP_ZERO || x_class == FP_NAN || x_class == FP_INFINITE))
		return x + x;

	u = (0.492659620528969547F + (0.697570460207922770F - 0.191502161678719066F * xm) * xm);

	t2 = u * u * u;

	ym = u * (t2 + 2.0F * xm) / (2.0F * t2 + xm) * factor[2 + xe % 3];

	return __ieee754_ldexpf(x > 0.0F ? ym : -ym, xe / 3);
}

__typeof(__cbrtf) cbrtf __attribute__((weak, alias("__cbrtf")));

```

`s_cbrtl.c`:

```c
/* Compute cubic root of double value.
   Copyright (C) 1997-2013 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Dirk Alboth <dirka@uni-paderborn.de> and
   Ulrich Drepper <drepper@cygnus.com>, 1997.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

long double __cbrtl(long double x)
{
	long double xm, u;
	int xe;
	int x_class;
	
	static const long double factor[5] = {
		0.62996052494743658238361L,			/* 1 / 2^(2/3) */
		0.79370052598409973737585L,			/* 1 / 2^(1/3) */
		1.0L,
		1.2599210498948731647672L,			/* 2^(1/3) */
		1.5874010519681994747517L			/* 2^(2/3) */
	};
	
	static const long double third = 0.3333333333333333333333333L;

	/* Reduce X.  XM now is an range 1.0 to 0.5.  */
	xm = __ieee754_frexpl(__ieee754_fabsl(x), &xe);

	/* If X is not finite or is null return it (with raising exceptions
	   if necessary.
	   Note: *Our* version of `frexp' sets XE to zero if the argument is
	   Inf or NaN.  This is not portable but faster.  */
	if (xe == 0 && ((x_class = fpclassify(x)) == FP_ZERO || x_class == FP_NAN || x_class == FP_INFINITE))
		return x + x;

	u = (((-1.34661104733595206551E-1 * xm
		   + 5.46646013663955245034E-1) * xm
		  - 9.54382247715094465250E-1) * xm + 1.13999833547172932737E0) * xm + 4.02389795645447521269E-1;

	u *= factor[2 + xe % 3];
	u = __ieee754_ldexpl(x > 0.0 ? u : -u, xe / 3);

	u -= (u - (x / (u * u))) * third;
	u -= (u - (x / (u * u))) * third;
	return u;
}

__typeof(__cbrtl) cbrtl __attribute__((weak, alias("__cbrtl")));

#endif

```

`s_ceil.c`:

```c
/* @(#)s_ceil.c 1.3 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice 
 * is preserved.
 * ====================================================
 */

/*
 * ceil(x)
 * Return x rounded toward -inf to integral value
 * Method:
 *	Bit twiddling.
 * Exception:
 *	Inexact flag raised if x not equal to ceil(x).
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_ceil

double __ieee754_ceil(double x)
{
	int32_t i0, j0;
	uint32_t i, j, i1;

	static const double hugeval = 1.0e300;

	GET_DOUBLE_WORDS(i0, i1, x);
	j0 = ((i0 >> IEEE754_DOUBLE_SHIFT) & IEEE754_DOUBLE_MAXEXP) - IEEE754_DOUBLE_BIAS;
	if (j0 < IEEE754_DOUBLE_SHIFT)
	{
		if (j0 < 0)
		{								/* raise inexact if x != 0 */
			math_force_eval(hugeval + x);
			/* return 0*sign(x) if |x|<1 */
			if (i0 < 0)
			{
				i0 = IC(0x80000000);
				i1 = 0;
			} else if ((i0 | i1) != 0)
			{
				i0 = UC(0x3ff00000);
				i1 = 0;
			}
		} else
		{
			i = UC(0x000fffff) >> j0;
			if (((i0 & i) | i1) == 0)
				return x;				/* x is integral */
			math_force_eval(hugeval + x);	/* raise inexact flag */
			if (i0 > 0)
				i0 += IC(0x00100000) >> j0;
			i0 &= (~i);
			i1 = 0;
		}
	} else if (j0 > 51)
	{
		if (j0 == (IEEE754_DOUBLE_MAXEXP - IEEE754_DOUBLE_BIAS))
			return x + x;				/* inf or NaN */
		else
			return x;					/* x is integral */
	} else
	{
		i = UC(0xffffffff) >> (j0 - IEEE754_DOUBLE_SHIFT);
		if ((i1 & i) == 0)
			return x;					/* x is integral */
		math_force_eval(hugeval + x);		/* raise inexact flag */
		if (i0 > 0)
		{
			if (j0 == IEEE754_DOUBLE_SHIFT)
				i0 += 1;
			else
			{
				j = i1 + (UC(1) << (52 - j0));
				if (j < i1)
					i0 += 1;			/* got a carry */
				i1 = j;
			}
		}
		i1 &= (~i);
	}
	INSERT_WORDS(x, i0, i1);
	return x;
}

#endif

double __ceil(double x)
{
	return __ieee754_ceil(x);
}

__typeof(__ceil) ceil __attribute__((weak, alias("__ceil")));
#ifdef __NO_LONG_DOUBLE_MATH
long double __ceill(long double x) __attribute__((alias("__ceil")));
__typeof(__ceill) ceill __attribute__((weak, alias("__ceil")));
#endif

```

`s_ceilf.c`:

```c
#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_ceil

float __ieee754_ceilf(float x)
{
	int32_t i0, j0;
	uint32_t i;

	static const float hugeval = 1.0e30;
	
	GET_FLOAT_WORD(i0, x);
	j0 = ((i0 >> IEEE754_FLOAT_SHIFT) & IEEE754_FLOAT_MAXEXP) - IEEE754_FLOAT_BIAS;
	if (j0 < IEEE754_FLOAT_SHIFT)
	{
		if (j0 < 0)
		{								/* raise inexact if x != 0 */
			math_force_eval(hugeval + x);	/* return 0*sign(x) if |x|<1 */
			if (i0 < 0)
			{
				i0 = IC(0x80000000);
			} else if (i0 != 0)
			{
				i0 = IC(0x3f800000);
			}
		} else
		{
			i = UC(0x007fffff) >> j0;
			if ((i0 & i) == 0)
				return x;				/* x is integral */
			math_force_eval(hugeval + x);	/* raise inexact flag */
			if (i0 > 0)
				i0 += UC(0x00800000) >> j0;
			i0 &= (~i);
		}
	} else
	{
		if (j0 == (IEEE754_FLOAT_MAXEXP - IEEE754_FLOAT_BIAS))
			return x + x;				/* inf or NaN */
		else
			return x;					/* x is integral */
	}
	SET_FLOAT_WORD(x, i0);
	return x;
}

#endif

float __ceilf(float x)
{
	return __ieee754_ceilf(x);
}

__typeof(__ceilf) ceilf __attribute__((weak, alias("__ceilf")));

```

`s_ceill.c`:

```c
#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

#ifndef __have_fpu_ceil

long double __ieee754_ceill(long double  x)
{
	int32_t j0;
	uint32_t i, j, se, i0, i1, sx;

	static const long double hugeval = 1.0e4930L;
	
	GET_LDOUBLE_WORDS(se, i0, i1, x);
	sx = (se >> 15) & 1;
	j0 = (se & IEEE854_LONG_DOUBLE_MAXEXP) - IEEE854_LONG_DOUBLE_BIAS;
	if (j0 < 31)
	{
		if (j0 < 0)
		{								/* raise inexact if x != 0 */
			math_force_eval(hugeval + x);
			/* return 0*sign(x) if |x|<1 */
			if (sx)
			{
				se = 0x8000;
				i0 = UC(0x80000000);
				i1 = 0;
			} else if ((i0 | i1) != 0)
			{
				se = 0x3fff;
				i0 = UC(0x80000000);
				i1 = 0;
			}
		} else
		{
			i = UC(0x7fffffff) >> j0;
			if (((i0 & i) | i1) == 0)
				return x;				/* x is integral */
			math_force_eval(hugeval + x);	/* raise inexact flag */
			if (sx == 0)
			{
				if (j0 > 0 && (i0 + (UC(0x80000000) >> j0)) > i0)
					i0 += UC(0x80000000) >> j0;
				else
				{
					i = UC(0x7fffffff);
					++se;
				}
			}
			i0 &= (~i);
			i1 = 0;
		}
	} else if (j0 > 62)
	{
		if (j0 == (IEEE854_LONG_DOUBLE_MAXEXP - IEEE854_LONG_DOUBLE_BIAS))
			return x + x;				/* inf or NaN */
		else
			return x;					/* x is integral */
	} else
	{
		i = UC(0xffffffff) >> (j0 - 31);
		if ((i1 & i) == 0)
			return x;					/* x is integral */
		math_force_eval(hugeval + x);		/* raise inexact flag */
		if (sx == 0)
		{
			if (j0 == 31)
				i0 += 1;
			else
			{
				j = i1 + (UC(1) << (63 - j0));
				if (j < i1)
					i0 += 1;		/* got a carry */
				i1 = j;
			}
		}
		i1 &= (~i);
	}
	SET_LDOUBLE_WORDS(x, se, i0, i1);
	return x;
}

#endif

long double __ceill(long double  x)
{
	return __ieee754_ceill(x);
}

__typeof(__ceill) ceill __attribute__((weak, alias("__ceill")));

#endif

```

`s_copysign.c`:

```c
/* @(#)s_copysign.c 1.3 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice 
 * is preserved.
 * ====================================================
 */

/*
 * copysign(double x, double y)
 * copysign(x,y) returns a value with the magnitude of x and
 * with the sign bit of y.
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

double __copysign(double x, double y)
{
	uint32_t hx, hy;

	GET_HIGH_WORD(hx, x);
	GET_HIGH_WORD(hy, y);
	SET_HIGH_WORD(x, (hx & UC(0x7fffffff)) | (hy & UC(0x80000000)));
	return x;
}

__typeof(__copysign) copysign __attribute__((weak, alias("__copysign")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(__copysignl) __copysignl __attribute__((alias("__copysign")));
__typeof(__copysignl) copysignl __attribute__((weak, alias("__copysign")));
#endif

```

`s_copysignf.c`:

```c
#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

float __copysignf(float x, float y)
{
	uint32_t ix, iy;

	GET_FLOAT_WORD(ix, x);
	GET_FLOAT_WORD(iy, y);
	SET_FLOAT_WORD(x, (ix & UC(0x7fffffff)) | (iy & UC(0x80000000)));
	return x;
}

__typeof(__copysignf) copysignf __attribute__((weak, alias("__copysignf")));

```

`s_copysignl.c`:

```c
#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

long double __copysignl(long double x, long double y)
{
	uint32_t es1, es2;
	GET_LDOUBLE_EXP(es1, x);
	GET_LDOUBLE_EXP(es2, y);
	SET_LDOUBLE_EXP(x, (es1 & 0x7fff) | (es2 & 0x8000));
    return x;
}

__typeof(__copysignl) copysignl __attribute__((weak, alias("__copysignl")));

#endif

```

`s_cos.c`:

```c
/* @(#)s_cos.c 1.3 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice 
 * is preserved.
 * ====================================================
 */

/* cos(x)
 * Return cosine function of x.
 *
 * kernel function:
 *	__kernel_sin		... sine function on [-pi/4,pi/4]
 *	__kernel_cos		... cosine function on [-pi/4,pi/4]
 *	__ieee754_rem_pio2	... argument reduction routine
 *
 * Method.
 *      Let S,C and T denote the sin, cos and tan respectively on 
 *	[-PI/4, +PI/4]. Reduce the argument x to y1+y2 = x-k*pi/2 
 *	in [-pi/4 , +pi/4], and let n = k mod 4.
 *	We have
 *
 *          n        sin(x)      cos(x)        tan(x)
 *     ----------------------------------------------------------
 *	    0	       S	   C		 T
 *	    1	       C	  -S		-1/T
 *	    2	      -S	  -C		 T
 *	    3	      -C	   S		-1/T
 *     ----------------------------------------------------------
 *
 * Special cases:
 *      Let trig be any of sin, cos, or tan.
 *      trig(+-INF)  is NaN, with signals;
 *      trig(NaN)    is that NaN;
 *
 * Accuracy:
 *	TRIG(x) returns trig(x) nearly rounded 
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_cos

double __ieee754_cos(double x)
{
	double y[2];
	double z = 0.0;
	int32_t n, ix;

	/* High word of x. */
	GET_HIGH_WORD(ix, x);

	/* |x| ~< pi/4 */
	ix &= IC(0x7fffffff);
	if (ix <= IC(0x3fe921fb))
		return __kernel_cos(x, z);

	/* cos(Inf or NaN) is NaN */
	else if (ix >= IC(0x7ff00000))
		return x - x;

	/* argument reduction needed */
	else
	{
		n = __ieee754_rem_pio2(x, y);
		switch ((int)(n & 3))
		{
		case 0:
			return __kernel_cos(y[0], y[1]);
		case 1:
			return -__kernel_sin(y[0], y[1], 1);
		case 2:
			return -__kernel_cos(y[0], y[1]);
		default:
			return __kernel_sin(y[0], y[1], 1);
		}
	}
}

#endif

double __cos(double x)
{
	double ret;
	
	ret = __ieee754_cos(x);
	if (isnan(ret) && !isnan(x))
		ret = __kernel_standard(x, x, ret, KMATHERR_COS_INF);
	return ret;
}

__typeof(__cos) cos __attribute__((weak, alias("__cos")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(__cosl) __cosl __attribute__((alias("__cos")));
__typeof(__cosl) cosl __attribute__((weak, alias("__cos")));
#endif

```

`s_cosf.c`:

```c
/* sf_cos.c -- float version of s_cos.c.
 * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice 
 * is preserved.
 * ====================================================
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_cos

float __ieee754_cosf(float x)
{
	float y[2], z = 0.0;
	int32_t n, ix;

	GET_FLOAT_WORD(ix, x);

	/* |x| ~< pi/4 */
	ix &= IC(0x7fffffff);
	if (ix <= IC(0x3f490fd8))
		return __kernel_cosf(x, z);

	/* cos(Inf or NaN) is NaN */
	else if (!FLT_UWORD_IS_FINITE(ix))
		return x - x;

	/* argument reduction needed */
	else
	{
		n = __ieee754_rem_pio2f(x, y);
		switch ((int)(n & 3))
		{
		case 0:
			return __kernel_cosf(y[0], y[1]);
		case 1:
			return -__kernel_sinf(y[0], y[1], 1);
		case 2:
			return -__kernel_cosf(y[0], y[1]);
		default:
			return __kernel_sinf(y[0], y[1], 1);
		}
	}
}

#endif

float __cosf(float x)
{
	float ret;
	
	ret = __ieee754_cosf(x);
	if (isnan(ret) && !isnan(x))
		ret = __kernel_standard_f(x, x, ret, KMATHERRF_COS_INF);
	return ret;
}

__typeof(__cosf) cosf __attribute__((weak, alias("__cosf")));

```

`s_cosl.c`:

```c
/* s_cosl.c -- long double version of s_cos.c.
 * Conversion to long double by Ulrich Drepper,
 * Cygnus Support, drepper@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/* cosl(x)
 * Return cosine function of x.
 *
 * kernel function:
 *	__kernel_sinl		... sine function on [-pi/4,pi/4]
 *	__kernel_cosl		... cosine function on [-pi/4,pi/4]
 *	__ieee754_rem_pio2l	... argument reduction routine
 *
 * Method.
 *      Let S,C and T denote the sin, cos and tan respectively on
 *	[-PI/4, +PI/4]. Reduce the argument x to y1+y2 = x-k*pi/2
 *	in [-pi/4 , +pi/4], and let n = k mod 4.
 *	We have
 *
 *          n        sin(x)      cos(x)        tan(x)
 *     ----------------------------------------------------------
 *	    0	       S	   C		 T
 *	    1	       C	  -S		-1/T
 *	    2	      -S	  -C		 T
 *	    3	      -C	   S		-1/T
 *     ----------------------------------------------------------
 *
 * Special cases:
 *      Let trig be any of sin, cos, or tan.
 *      trig(+-INF)  is NaN, with signals;
 *      trig(NaN)    is that NaN;
 *
 * Accuracy:
 *	TRIG(x) returns trig(x) nearly rounded
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

#ifndef __have_fpu_cos

long double __ieee754_cosl(long double x)
{
	long double y[2], z = 0.0;
	int32_t n, se;
	uint32_t i0, i1;

	/* High word of x. */
	GET_LDOUBLE_WORDS(se, i0, i1, x);
	(void) i1;
	
	/* |x| ~< pi/4 */
	se &= IEEE854_LONG_DOUBLE_MAXEXP;
	if (se < 0x3ffe || (se == 0x3ffe && i0 <= UC(0xc90fdaa2)))
		return __kernel_cosl(x, z);

	/* cos(Inf or NaN) is NaN */
	else if (se == IEEE854_LONG_DOUBLE_MAXEXP)
		return x - x;

	/* argument reduction needed */
	else
	{
		n = __ieee754_rem_pio2l(x, y);
		switch ((int)(n & 3))
		{
		case 0:
			return __kernel_cosl(y[0], y[1]);
		case 1:
			return -__kernel_sinl(y[0], y[1], 1);
		case 2:
			return -__kernel_cosl(y[0], y[1]);
		default:
			return __kernel_sinl(y[0], y[1], 1);
		}
	}
}

#endif

long double __cosl(long double x)
{
	long double ret;
	
	ret = __ieee754_cosl(x);
	if (isnan(ret) && !isnan(x))
		ret = __kernel_standard_l(x, x, ret, KMATHERRL_COS_INF);
	return ret;
}

__typeof(__cosl) cosl __attribute__((weak, alias("__cosl")));

#endif

```

`s_erf.c`:

```c
/* @(#)s_erf.c 1.3 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */
/* Modified by Naohiko Shimizu/Tokai University, Japan 1997/08/25,
   for performance improvement on pipelined processors.
*/

/* double erf(double x)
 * double erfc(double x)
 *                           x
 *                    2      |\
 *     erf(x)  =  ---------  | exp(-t*t)dt
 *                 sqrt(pi) \|
 *                           0
 *
 *     erfc(x) =  1-erf(x)
 *  Note that
 *              erf(-x) = -erf(x)
 *              erfc(-x) = 2 - erfc(x)
 *
 * Method:
 *      1. For |x| in [0, 0.84375]
 *          erf(x)  = x + x*R(x^2)
 *          erfc(x) = 1 - erf(x)           if x in [-.84375,0.25]
 *                  = 0.5 + ((0.5-x)-x*R)  if x in [0.25,0.84375]
 *         where R = P/Q where P is an odd poly of degree 8 and
 *         Q is an odd poly of degree 10.
 *                                               -57.90
 *                      | R - (erf(x)-x)/x | <= 2
 *
 *
 *         Remark. The formula is derived by noting
 *          erf(x) = (2/sqrt(pi))*(x - x^3/3 + x^5/10 - x^7/42 + ....)
 *         and that
 *          2/sqrt(pi) = 1.128379167095512573896158903121545171688
 *         is close to one. The interval is chosen because the fix
 *         point of erf(x) is near 0.6174 (i.e., erf(x)=x when x is
 *         near 0.6174), and by some experiment, 0.84375 is chosen to
 *         guarantee the error is less than one ulp for erf.
 *
 *      2. For |x| in [0.84375,1.25], let s = |x| - 1, and
 *         c = 0.84506291151 rounded to single (24 bits)
 *              erf(x)  = sign(x) * (c  + P1(s)/Q1(s))
 *              erfc(x) = (1-c)  - P1(s)/Q1(s) if x > 0
 *                        1+(c+P1(s)/Q1(s))    if x < 0
 *              |P1/Q1 - (erf(|x|)-c)| <= 2**-59.06
 *         Remark: here we use the taylor series expansion at x=1.
 *              erf(1+s) = erf(1) + s*Poly(s)
 *                       = 0.845.. + P1(s)/Q1(s)
 *         That is, we use rational approximation to approximate
 *                      erf(1+s) - (c = (single)0.84506291151)
 *         Note that |P1/Q1|< 0.078 for x in [0.84375,1.25]
 *         where
 *              P1(s) = degree 6 poly in s
 *              Q1(s) = degree 6 poly in s
 *
 *      3. For x in [1.25,1/0.35(~2.857143)],
 *              erfc(x) = (1/x)*exp(-x*x-0.5625+R1/S1)
 *              erf(x)  = 1 - erfc(x)
 *         where
 *              R1(z) = degree 7 poly in z, (z=1/x^2)
 *              S1(z) = degree 8 poly in z
 *
 *      4. For x in [1/0.35,28]
 *              erfc(x) = (1/x)*exp(-x*x-0.5625+R2/S2) if x > 0
 *                      = 2.0 - (1/x)*exp(-x*x-0.5625+R2/S2) if -6<x<0
 *                      = 2.0 - tiny            (if x <= -6)
 *              erf(x)  = sign(x)*(1.0 - erfc(x)) if x < 6, else
 *              erf(x)  = sign(x)*(1.0 - tiny)
 *         where
 *              R2(z) = degree 6 poly in z, (z=1/x^2)
 *              S2(z) = degree 7 poly in z
 *
 *      Note1:
 *         To compute exp(-x*x-0.5625+R/S), let s be a single
 *         precision number and s := x; then
 *              -x*x = -s*s + (s-x)*(s+x)
 *              exp(-x*x-0.5626+R/S) =
 *                      exp(-s*s-0.5625)*exp((s-x)*(s+x)+R/S);
 *      Note2:
 *         Here 4 and 5 make use of the asymptotic series
 *                        exp(-x*x)
 *              erfc(x) ~ ---------- * ( 1 + Poly(1/x^2) )
 *                        x*sqrt(pi)
 *         We use rational approximation to approximate
 *              g(s)=f(1/x^2) = log(erfc(x)*x) - x*x + 0.5625
 *         Here is the error bound for R1/S1 and R2/S2
 *              |R1/S1 - f(x)|  < 2**(-62.57)
 *              |R2/S2 - f(x)|  < 2**(-61.52)
 *
 *      5. For inf > x >= 28
 *              erf(x)  = sign(x) *(1 - tiny)  (raise inexact)
 *              erfc(x) = tiny*tiny (raise underflow) if x > 0
 *                      = 2 - tiny if x<0
 *
 *      7. Special case:
 *              erf(0)  = 0, erf(inf)  = 1, erf(-inf) = -1,
 *              erfc(0) = 1, erfc(inf) = 0, erfc(-inf) = 2,
 *              erfc/erf(NaN) is NaN
 */


#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

double __erf(double x)
{
	int32_t hx, ix, i;
	double R, S, P, Q, s, y, z, r;

	static const double tiny = 1e-300;
	static const double one  = 1.00000000000000000000e+00;	/* 0x3FF00000, 0x00000000 */
	/* c = (float)0.84506291151 */
	static const double erx  = 8.45062911510467529297e-01;	/* 0x3FEB0AC1, 0x60000000 */
	static const double efx  = 1.28379167095512586316e-01;	/* 0x3FC06EBA, 0x8214DB69 */
	static const double efx8 = 1.02703333676410069053e+00;	/* 0x3FF06EBA, 0x8214DB69 */

#include "t_erf.h"

	GET_HIGH_WORD(hx, x);
	ix = hx & IC(0x7fffffff);
	if (ix >= IC(0x7ff00000))
	{									/* erf(nan)=nan */
		i = ((uint32_t) hx >> 31) << 1;
		return (double) (1 - i) + one / x;	/* erf(+-inf)=+-1 */
	}

	if (ix < IC(0x3feb0000))
	{									/* |x|<0.84375 */
		double r1, r2, s1, s2, s3, z2, z4;

		if (ix < IC(0x3e300000))
		{								/* |x|<2**-28 */
			if (ix < IC(0x00800000))
				return 0.125 * (8.0 * x + efx8 * x);	/*avoid underflow */
			return x + efx * x;
		}
		z = x * x;
#ifdef DO_NOT_USE_THIS
		r = pp0 + z * (pp1 + z * (pp2 + z * (pp3 + z * pp4)));
		s = one + z * (qq1 + z * (qq2 + z * (qq3 + z * (qq4 + z * qq5))));
#else
		r1 = pp0 + z * pp1;
		z2 = z * z;
		r2 = pp2 + z * pp3;
		z4 = z2 * z2;
		s1 = one + z * qq1;
		s2 = qq2 + z * qq3;
		s3 = qq4 + z * qq5;
		r = r1 + z2 * r2 + z4 * pp4;
		s = s1 + z2 * s2 + z4 * s3;
#endif
		y = r / s;
		return x + x * y;
	}
	if (ix < IC(0x3ff40000))
	{									/* 0.84375 <= |x| < 1.25 */
		double s2, s4, s6, P1, P2, P3, P4, Q1, Q2, Q3, Q4;

		s = __ieee754_fabs(x) - one;
#ifdef DO_NOT_USE_THIS
		P = pa0 + s * (pa1 + s * (pa2 + s * (pa3 + s * (pa4 + s * (pa5 + s * pa6)))));
		Q = one + s * (qa1 + s * (qa2 + s * (qa3 + s * (qa4 + s * (qa5 + s * qa6)))));
#else
		P1 = pa0 + s * pa1;
		s2 = s * s;
		Q1 = one + s * qa1;
		s4 = s2 * s2;
		P2 = pa2 + s * pa3;
		s6 = s4 * s2;
		Q2 = qa2 + s * qa3;
		P3 = pa4 + s * pa5;
		Q3 = qa4 + s * qa5;
		P4 = pa6;
		Q4 = qa6;
		P = P1 + s2 * P2 + s4 * P3 + s6 * P4;
		Q = Q1 + s2 * Q2 + s4 * Q3 + s6 * Q4;
#endif
		if (hx >= 0)
			return erx + P / Q;
		else
			return -erx - P / Q;
	}
	if (ix >= IC(0x40180000))
	{									/* inf>|x|>=6 */
		if (hx >= 0)
			return one - tiny;
		else
			return tiny - one;
	}
	x = __ieee754_fabs(x);
	s = one / (x * x);
	if (ix < IC(0x4006DB6E))
	{									/* |x| < 1/0.35 */
#ifdef DO_NOT_USE_THIS
		R = ra0 + s * (ra1 + s * (ra2 + s * (ra3 + s * (ra4 + s * (ra5 + s * (ra6 + s * ra7))))));
		S = one + s * (sa1 + s * (sa2 + s * (sa3 + s * (sa4 + s * (sa5 + s * (sa6 + s * (sa7 + s * sa8)))))));
#else
		double R1, R2, R3, R4, S1, S2, S3, S4, s2, s4, s6, s8;

		R1 = ra0 + s * ra1;
		s2 = s * s;
		S1 = one + s * sa1;
		s4 = s2 * s2;
		R2 = ra2 + s * ra3;
		s6 = s4 * s2;
		S2 = sa2 + s * sa3;
		s8 = s4 * s4;
		R3 = ra4 + s * ra5;
		S3 = sa4 + s * sa5;
		R4 = ra6 + s * ra7;
		S4 = sa6 + s * sa7;
		R = R1 + s2 * R2 + s4 * R3 + s6 * R4;
		S = S1 + s2 * S2 + s4 * S3 + s6 * S4 + s8 * sa8;
#endif
	} else
	{									/* |x| >= 1/0.35 */
#ifdef DO_NOT_USE_THIS
		R = rb0 + s * (rb1 + s * (rb2 + s * (rb3 + s * (rb4 + s * (rb5 + s * rb6)))));
		S = one + s * (sb1 + s * (sb2 + s * (sb3 + s * (sb4 + s * (sb5 + s * (sb6 + s * sb7))))));
#else
		double R1, R2, R3, S1, S2, S3, S4, s2, s4, s6;

		R1 = rb0 + s * rb1;
		s2 = s * s;
		S1 = one + s * sb1;
		s4 = s2 * s2;
		R2 = rb2 + s * rb3;
		s6 = s4 * s2;
		S2 = sb2 + s * sb3;
		R3 = rb4 + s * rb5;
		S3 = sb4 + s * sb5;
		S4 = sb6 + s * sb7;
		R = R1 + s2 * R2 + s4 * R3 + s6 * rb6;
		S = S1 + s2 * S2 + s4 * S3 + s6 * S4;
#endif
	}
	z = x;
	SET_LOW_WORD(z, 0);
	r = __ieee754_exp(-z * z - 0.5625) * __ieee754_exp((z - x) * (z + x) + R / S);
	if (hx >= 0)
		return one - r / x;
	else
		return r / x - one;
}

__typeof(__erf) erf __attribute__((weak, alias("__erf")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(__erfl) __erfl __attribute__((alias("__erf")));
__typeof(__erfl) erfl __attribute__((weak, alias("__erf")));
#endif

```

`s_erfc.c`:

```c
/* @(#)s_erf.c 5.1 93/09/24 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */
/* Modified by Naohiko Shimizu/Tokai University, Japan 1997/08/25,
   for performance improvement on pipelined processors.
*/

/* double erf(double x)
 * double erfc(double x)
 *			     x
 *		      2      |\
 *     erf(x)  =  ---------  | exp(-t*t)dt
 *	 	   sqrt(pi) \|
 *			     0
 *
 *     erfc(x) =  1-erf(x)
 *  Note that
 *		erf(-x) = -erf(x)
 *		erfc(-x) = 2 - erfc(x)
 *
 * Method:
 *	1. For |x| in [0, 0.84375]
 *	    erf(x)  = x + x*R(x^2)
 *          erfc(x) = 1 - erf(x)           if x in [-.84375,0.25]
 *                  = 0.5 + ((0.5-x)-x*R)  if x in [0.25,0.84375]
 *	   where R = P/Q where P is an odd poly of degree 8 and
 *	   Q is an odd poly of degree 10.
 *						 -57.90
 *			| R - (erf(x)-x)/x | <= 2
 *
 *
 *	   Remark. The formula is derived by noting
 *          erf(x) = (2/sqrt(pi))*(x - x^3/3 + x^5/10 - x^7/42 + ....)
 *	   and that
 *          2/sqrt(pi) = 1.128379167095512573896158903121545171688
 *	   is close to one. The interval is chosen because the fix
 *	   point of erf(x) is near 0.6174 (i.e., erf(x)=x when x is
 *	   near 0.6174), and by some experiment, 0.84375 is chosen to
 * 	   guarantee the error is less than one ulp for erf.
 *
 *      2. For |x| in [0.84375,1.25], let s = |x| - 1, and
 *         c = 0.84506291151 rounded to single (24 bits)
 *         	erf(x)  = sign(x) * (c  + P1(s)/Q1(s))
 *         	erfc(x) = (1-c)  - P1(s)/Q1(s) if x > 0
 *			  1+(c+P1(s)/Q1(s))    if x < 0
 *         	|P1/Q1 - (erf(|x|)-c)| <= 2**-59.06
 *	   Remark: here we use the taylor series expansion at x=1.
 *		erf(1+s) = erf(1) + s*Poly(s)
 *			 = 0.845.. + P1(s)/Q1(s)
 *	   That is, we use rational approximation to approximate
 *			erf(1+s) - (c = (single)0.84506291151)
 *	   Note that |P1/Q1|< 0.078 for x in [0.84375,1.25]
 *	   where
 *		P1(s) = degree 6 poly in s
 *		Q1(s) = degree 6 poly in s
 *
 *      3. For x in [1.25,1/0.35(~2.857143)],
 *         	erfc(x) = (1/x)*exp(-x*x-0.5625+R1/S1)
 *         	erf(x)  = 1 - erfc(x)
 *	   where
 *		R1(z) = degree 7 poly in z, (z=1/x^2)
 *		S1(z) = degree 8 poly in z
 *
 *      4. For x in [1/0.35,28]
 *         	erfc(x) = (1/x)*exp(-x*x-0.5625+R2/S2) if x > 0
 *			= 2.0 - (1/x)*exp(-x*x-0.5625+R2/S2) if -6<x<0
 *			= 2.0 - tiny		(if x <= -6)
 *         	erf(x)  = sign(x)*(1.0 - erfc(x)) if x < 6, else
 *         	erf(x)  = sign(x)*(1.0 - tiny)
 *	   where
 *		R2(z) = degree 6 poly in z, (z=1/x^2)
 *		S2(z) = degree 7 poly in z
 *
 *      Note1:
 *	   To compute exp(-x*x-0.5625+R/S), let s be a single
 *	   precision number and s := x; then
 *		-x*x = -s*s + (s-x)*(s+x)
 *	        exp(-x*x-0.5626+R/S) =
 *			exp(-s*s-0.5625)*exp((s-x)*(s+x)+R/S);
 *      Note2:
 *	   Here 4 and 5 make use of the asymptotic series
 *			  exp(-x*x)
 *		erfc(x) ~ ---------- * ( 1 + Poly(1/x^2) )
 *			  x*sqrt(pi)
 *	   We use rational approximation to approximate
 *      	g(s)=f(1/x^2) = log(erfc(x)*x) - x*x + 0.5625
 *	   Here is the error bound for R1/S1 and R2/S2
 *      	|R1/S1 - f(x)|  < 2**(-62.57)
 *      	|R2/S2 - f(x)|  < 2**(-61.52)
 *
 *      5. For inf > x >= 28
 *         	erf(x)  = sign(x) *(1 - tiny)  (raise inexact)
 *         	erfc(x) = tiny*tiny (raise underflow) if x > 0
 *			= 2 - tiny if x<0
 *
 *      7. Special case:
 *         	erf(0)  = 0, erf(inf)  = 1, erf(-inf) = -1,
 *         	erfc(0) = 1, erfc(inf) = 0, erfc(-inf) = 2,
 *	   	erfc/erf(NaN) is NaN
 */


#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif


double __erfc(double x)
{
	int32_t hx, ix;
	double R, S, P, Q, s, y, z, r;

	static const double tiny = 1e-300;
	static const double half = 5.00000000000000000000e-01;	/* 0x3FE00000, 0x00000000 */
	static const double one = 1.00000000000000000000e+00;	/* 0x3FF00000, 0x00000000 */
	static const double two = 2.00000000000000000000e+00;	/* 0x40000000, 0x00000000 */
	/* c = (float)0.84506291151 */
	static const double erx = 8.45062911510467529297e-01;	/* 0x3FEB0AC1, 0x60000000 */

#include "t_erf.h"

	GET_HIGH_WORD(hx, x);
	ix = hx & IC(0x7fffffff);
	if (ix >= IC(0x7ff00000))
	{									/* erfc(nan)=nan */
		/* erfc(+-inf)=0,2 */
		return (double) (((uint32_t) hx >> 31) << 1) + one / x;
	}

	if (ix < IC(0x3feb0000))
	{									/* |x|<0.84375 */
		double r1, r2, s1, s2, s3, z2, z4;

		if (ix < IC(0x3c700000))			/* |x|<2**-56 */
			return one - x;
		z = x * x;
#ifdef DO_NOT_USE_THIS
		r = pp0 + z * (pp1 + z * (pp2 + z * (pp3 + z * pp4)));
		s = one + z * (qq1 + z * (qq2 + z * (qq3 + z * (qq4 + z * qq5))));
#else
		r1 = pp0 + z * pp1;
		z2 = z * z;
		r2 = pp2 + z * pp3;
		z4 = z2 * z2;
		s1 = one + z * qq1;
		s2 = qq2 + z * qq3;
		s3 = qq4 + z * qq5;
		r = r1 + z2 * r2 + z4 * pp4;
		s = s1 + z2 * s2 + z4 * s3;
#endif
		y = r / s;
		if (hx < IC(0x3fd00000))
		{								/* x<1/4 */
			return one - (x + x * y);
		} else
		{
			r = x * y;
			r += (x - half);
			return half - r;
		}
	}
	if (ix < IC(0x3ff40000))
	{									/* 0.84375 <= |x| < 1.25 */
		double s2, s4, s6, P1, P2, P3, P4, Q1, Q2, Q3, Q4;

		s = __ieee754_fabs(x) - one;
#ifdef DO_NOT_USE_THIS
		P = pa0 + s * (pa1 + s * (pa2 + s * (pa3 + s * (pa4 + s * (pa5 + s * pa6)))));
		Q = one + s * (qa1 + s * (qa2 + s * (qa3 + s * (qa4 + s * (qa5 + s * qa6)))));
#else
		P1 = pa0 + s * pa1;
		s2 = s * s;
		Q1 = one + s * qa1;
		s4 = s2 * s2;
		P2 = pa2 + s * pa3;
		s6 = s4 * s2;
		Q2 = qa2 + s * qa3;
		P3 = pa4 + s * pa5;
		Q3 = qa4 + s * qa5;
		P4 = pa6;
		Q4 = qa6;
		P = P1 + s2 * P2 + s4 * P3 + s6 * P4;
		Q = Q1 + s2 * Q2 + s4 * Q3 + s6 * Q4;
#endif
		if (hx >= 0)
		{
			z = one - erx;
			return z - P / Q;
		} else
		{
			z = erx + P / Q;
			return one + z;
		}
	}
	if (ix < IC(0x403c0000))
	{									/* |x|<28 */
		x = __ieee754_fabs(x);
		s = one / (x * x);
		if (ix < IC(0x4006DB6D))
		{								/* |x| < 1/.35 ~ 2.857143 */
#ifdef DO_NOT_USE_THIS
			R = ra0 + s * (ra1 + s * (ra2 + s * (ra3 + s * (ra4 + s * (ra5 + s * (ra6 + s * ra7))))));
			S = one + s * (sa1 + s * (sa2 + s * (sa3 + s * (sa4 + s * (sa5 + s * (sa6 + s * (sa7 + s * sa8)))))));
#else
			double R1, R2, R3, R4, S1, S2, S3, S4, s2, s4, s6, s8;

			R1 = ra0 + s * ra1;
			s2 = s * s;
			S1 = one + s * sa1;
			s4 = s2 * s2;
			R2 = ra2 + s * ra3;
			s6 = s4 * s2;
			S2 = sa2 + s * sa3;
			s8 = s4 * s4;
			R3 = ra4 + s * ra5;
			S3 = sa4 + s * sa5;
			R4 = ra6 + s * ra7;
			S4 = sa6 + s * sa7;
			R = R1 + s2 * R2 + s4 * R3 + s6 * R4;
			S = S1 + s2 * S2 + s4 * S3 + s6 * S4 + s8 * sa8;
#endif
		} else
		{								/* |x| >= 1/.35 ~ 2.857143 */
			double R1, R2, R3, S1, S2, S3, S4, s2, s4, s6;

			if (hx < 0 && ix >= IC(0x40180000))
				return two - tiny;		/* x < -6 */
#ifdef DO_NOT_USE_THIS
			R = rb0 + s * (rb1 + s * (rb2 + s * (rb3 + s * (rb4 + s * (rb5 + s * rb6)))));
			S = one + s * (sb1 + s * (sb2 + s * (sb3 + s * (sb4 + s * (sb5 + s * (sb6 + s * sb7))))));
#else
			R1 = rb0 + s * rb1;
			s2 = s * s;
			S1 = one + s * sb1;
			s4 = s2 * s2;
			R2 = rb2 + s * rb3;
			s6 = s4 * s2;
			S2 = sb2 + s * sb3;
			R3 = rb4 + s * rb5;
			S3 = sb4 + s * sb5;
			S4 = sb6 + s * sb7;
			R = R1 + s2 * R2 + s4 * R3 + s6 * rb6;
			S = S1 + s2 * S2 + s4 * S3 + s6 * S4;
#endif
		}
		z = x;
		SET_LOW_WORD(z, 0);
		r = __ieee754_exp(-z * z - 0.5625) * __ieee754_exp((z - x) * (z + x) + R / S);
		if (hx > 0)
			return r / x;
		else
			return two - r / x;
	}
	if (hx > 0)
		return tiny * tiny;
	return two - tiny;
}

__typeof(__erfc) erfc __attribute__((weak, alias("__erfc")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(__erfcl) __erfcl __attribute__((alias("__erfc")));
__typeof(__erfcl) erfcl __attribute__((weak, alias("__erfc")));
#endif

```

`s_erfcf.c`:

```c
/* s_erff.c -- float version of s_erf.c.
 * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

float __erfcf(float x)
{
	int32_t hx, ix;
	float R, S, P, Q, s, y, z, r;

#include "t_erff.h"

	static const float tiny = 1e-30;
	static const float half = 5.0000000000e-01;			/* 0x3F000000 */
	static const float one = 1.0000000000e+00;			/* 0x3F800000 */
	static const float two = 2.0000000000e+00;			/* 0x40000000 */
	/* c = (subfloat)0.84506291151 */
	static const float erx = 8.4506291151e-01;			/* 0x3f58560b */

	GET_FLOAT_WORD(hx, x);
	ix = hx & IC(0x7fffffff);
	if (!FLT_UWORD_IS_FINITE(ix))
	{									/* erfc(nan)=nan */
		/* erfc(+-inf)=0,2 */
		return (float) (((uint32_t) hx >> 31) << 1) + one / x;
	}

	if (ix < IC(0x3f580000))
	{									/* |x|<0.84375 */
		if (ix < IC(0x23800000))		/* |x|<2**-56 */
			return one - x;
		z = x * x;
		r = pp0 + z * (pp1 + z * (pp2 + z * (pp3 + z * pp4)));
		s = one + z * (qq1 + z * (qq2 + z * (qq3 + z * (qq4 + z * qq5))));
		y = r / s;
		if (hx < IC(0x3e800000))
		{								/* x<1/4 */
			return one - (x + x * y);
		} else
		{
			r = x * y;
			r += (x - half);
			return half - r;
		}
	}
	if (ix < IC(0x3fa00000))
	{									/* 0.84375 <= |x| < 1.25 */
		s = __ieee754_fabsf(x) - one;
		P = pa0 + s * (pa1 + s * (pa2 + s * (pa3 + s * (pa4 + s * (pa5 + s * pa6)))));
		Q = one + s * (qa1 + s * (qa2 + s * (qa3 + s * (qa4 + s * (qa5 + s * qa6)))));
		if (hx >= 0)
		{
			z = one - erx;
			return z - P / Q;
		} else
		{
			z = erx + P / Q;
			return one + z;
		}
	}
	
	if (ix < IC(0x41e00000))
	{									/* |x|<28 */
		x = __ieee754_fabsf(x);
		s = one / (x * x);
		if (ix < IC(0x4036DB6D))
		{								/* |x| < 1/.35 ~ 2.857143 */
			R = ra0 + s * (ra1 + s * (ra2 + s * (ra3 + s * (ra4 + s * (ra5 + s * (ra6 + s * ra7))))));
			S = one + s * (sa1 + s * (sa2 + s * (sa3 + s * (sa4 + s * (sa5 + s * (sa6 + s * (sa7 + s * sa8)))))));
		} else
		{								/* |x| >= 1/.35 ~ 2.857143 */
			if (hx < 0 && ix >= IC(0x40c00000))
				return two - tiny;		/* x < -6 */
			R = rb0 + s * (rb1 + s * (rb2 + s * (rb3 + s * (rb4 + s * (rb5 + s * rb6)))));
			S = one + s * (sb1 + s * (sb2 + s * (sb3 + s * (sb4 + s * (sb5 + s * (sb6 + s * sb7))))));
		}
		GET_FLOAT_WORD(ix, x);
		SET_FLOAT_WORD(z, ix & IC(0xffffe000));
		r = __ieee754_expf(-z * z - 0.5625f) * __ieee754_expf((z - x) * (z + x) + R / S);
		if (hx > 0)
			return r / x;
		else
			return two - r / x;
	}
#ifdef _WIN32
	__set_errno(ERANGE);
#endif
	if (hx > 0)
		return tiny * tiny;
	return two - tiny;
}

__typeof(__erfcf) erfcf __attribute__((weak, alias("__erfcf")));

```

`s_erfcl.c`:

```c
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/* Long double expansions are
  Copyright (C) 2001 Stephen L. Moshier <moshier@na-net.ornl.gov>
  and are incorporated herein by permission of the author.  The author
  reserves the right to distribute this material elsewhere under different
  copying permissions.  These modifications are distributed here under
  the following terms:

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, see
    <http://www.gnu.org/licenses/>.  */

/* double erf(double x)
 * double erfc(double x)
 *			     x
 *		      2      |\
 *     erf(x)  =  ---------  | exp(-t*t)dt
 *		   sqrt(pi) \|
 *			     0
 *
 *     erfc(x) =  1-erf(x)
 *  Note that
 *		erf(-x) = -erf(x)
 *		erfc(-x) = 2 - erfc(x)
 *
 * Method:
 *	1. For |x| in [0, 0.84375]
 *	    erf(x)  = x + x*R(x^2)
 *          erfc(x) = 1 - erf(x)           if x in [-.84375,0.25]
 *                  = 0.5 + ((0.5-x)-x*R)  if x in [0.25,0.84375]
 *	   Remark. The formula is derived by noting
 *          erf(x) = (2/sqrt(pi))*(x - x^3/3 + x^5/10 - x^7/42 + ....)
 *	   and that
 *          2/sqrt(pi) = 1.128379167095512573896158903121545171688
 *	   is close to one. The interval is chosen because the fix
 *	   point of erf(x) is near 0.6174 (i.e., erf(x)=x when x is
 *	   near 0.6174), and by some experiment, 0.84375 is chosen to
 *	   guarantee the error is less than one ulp for erf.
 *
 *      2. For |x| in [0.84375,1.25], let s = |x| - 1, and
 *         c = 0.84506291151 rounded to single (24 bits)
 *	erf(x)  = sign(x) * (c  + P1(s)/Q1(s))
 *	erfc(x) = (1-c)  - P1(s)/Q1(s) if x > 0
 *			  1+(c+P1(s)/Q1(s))    if x < 0
 *	   Remark: here we use the taylor series expansion at x=1.
 *		erf(1+s) = erf(1) + s*Poly(s)
 *			 = 0.845.. + P1(s)/Q1(s)
 *	   Note that |P1/Q1|< 0.078 for x in [0.84375,1.25]
 *
 *      3. For x in [1.25,1/0.35(~2.857143)],
 *	erfc(x) = (1/x)*exp(-x*x-0.5625+R1(z)/S1(z))
 *              z=1/x^2
 *	erf(x)  = 1 - erfc(x)
 *
 *      4. For x in [1/0.35,107]
 *	erfc(x) = (1/x)*exp(-x*x-0.5625+R2/S2) if x > 0
 *			= 2.0 - (1/x)*exp(-x*x-0.5625+R2(z)/S2(z))
 *                             if -6.666<x<0
 *			= 2.0 - tiny		(if x <= -6.666)
 *              z=1/x^2
 *	erf(x)  = sign(x)*(1.0 - erfc(x)) if x < 6.666, else
 *	erf(x)  = sign(x)*(1.0 - tiny)
 *      Note1:
 *	   To compute exp(-x*x-0.5625+R/S), let s be a single
 *	   precision number and s := x; then
 *		-x*x = -s*s + (s-x)*(s+x)
 *	        exp(-x*x-0.5626+R/S) =
 *			exp(-s*s-0.5625)*exp((s-x)*(s+x)+R/S);
 *      Note2:
 *	   Here 4 and 5 make use of the asymptotic series
 *			  exp(-x*x)
 *		erfc(x) ~ ---------- * ( 1 + Poly(1/x^2) )
 *			  x*sqrt(pi)
 *
 *      5. For inf > x >= 107
 *	erf(x)  = sign(x) *(1 - tiny)  (raise inexact)
 *	erfc(x) = tiny*tiny (raise underflow) if x > 0
 *			= 2 - tiny if x<0
 *
 *      7. Special case:
 *	erf(0)  = 0, erf(inf)  = 1, erf(-inf) = -1,
 *	erfc(0) = 1, erfc(inf) = 0, erfc(-inf) = 2,
 *		erfc/erf(NaN) is NaN
 */


#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

long double __erfcl(long double x)
{
	int32_t hx, ix;
	long double R, S, P, Q, s, y, z, r;
	uint32_t se, i0, i1;

	static const long double tiny = 1e-4931L;
	static const long double half = 0.5L;
	static const long double one = 1.0L;
	static const long double two = 2.0L;
	/* c = (float)0.84506291151 */
	static const long double erx = 0.845062911510467529296875L;

#include "t_erfl.h"

	/* erfc(1/x) = x exp (-1/x^2 - 0.5625 + rc(x^2)/sc(x^2))
	   1/107 <= 1/x <= 1/6.6666259765625
	   Peak relative error 1.1e-21  */
	static const long double rc[] =
	{
		-8.299617545269701963973537248996670806850E-5L,
		-6.243845685115818513578933902532056244108E-3L,
		-1.141667210620380223113693474478394397230E-1L,
		-7.521343797212024245375240432734425789409E-1L,
		-1.765321928311155824664963633786967602934E0L,
		-1.029403473103215800456761180695263439188E0L
	};
	static const long double sc[] =
	{
		8.413244363014929493035952542677768808601E-3L,
		2.065114333816877479753334599639158060979E-1L,
		1.639064941530797583766364412782135680148E0L,
		4.936788463787115555582319302981666347450E0L,
		5.005177727208955487404729933261347679090E0L
		/* 1.000000000000000000000000000000000000000E0 */
	};

	GET_LDOUBLE_WORDS(se, i0, i1, x);
	ix = se & 0x7fff;
	if (ix >= 0x7fff)
	{									/* erfc(nan)=nan */
		/* erfc(+-inf)=0,2 */
		return (long double) (((se & 0xffff) >> 15) << 1) + one / x;
	}

	ix = (ix << 16) | (i0 >> 16);
	if (ix < IC(0x3ffed800))			/* |x|<0.84375 */
	{
		if (ix < IC(0x3fbe0000))		/* |x|<2**-65 */
			return one - x;
		z = x * x;
		r = pp[0] + z * (pp[1] + z * (pp[2] + z * (pp[3] + z * (pp[4] + z * pp[5]))));
		s = qq[0] + z * (qq[1] + z * (qq[2] + z * (qq[3] + z * (qq[4] + z * (qq[5] + z)))));
		y = r / s;
		if (ix < IC(0x3ffd8000))		/* x<1/4 */
		{
			return one - (x + x * y);
		} else
		{
			r = x * y;
			r += (x - half);
			return half - r;
		}
	}
	if (ix < IC(0x3fffa000))			/* 1.25 */
	{									/* 0.84375 <= |x| < 1.25 */
		s = __ieee754_fabsl(x) - one;
		P = pa[0] + s * (pa[1] + s * (pa[2] + s * (pa[3] + s * (pa[4] + s * (pa[5] + s * (pa[6] + s * pa[7]))))));
		Q = qa[0] + s * (qa[1] + s * (qa[2] + s * (qa[3] + s * (qa[4] + s * (qa[5] + s * (qa[6] + s))))));
		if ((se & 0x8000) == 0)
		{
			z = one - erx;
			return z - P / Q;
		} else
		{
			z = erx + P / Q;
			return one + z;
		}
	}
	if (ix < IC(0x4005d600))			/* 107 */
	{									/* |x|<107 */
		x = __ieee754_fabsl(x);
		s = one / (x * x);
		if (ix < IC(0x4000b6db))		/* 2.85711669921875 */
		{								/* |x| < 1/.35 ~ 2.857143 */
			R = ra[0] + s * (ra[1] + s * (ra[2] + s * (ra[3] + s * (ra[4] + s * (ra[5] + s * (ra[6] + s * (ra[7] + s * ra[8])))))));
			S = sa[0] + s * (sa[1] + s * (sa[2] + s * (sa[3] + s * (sa[4] + s * (sa[5] + s * (sa[6] + s * (sa[7] + s * (sa[8] + s))))))));
		} else if (ix < IC(0x4001d555))		/* 6.6666259765625 */
		{								/* 6.666 > |x| >= 1/.35 ~ 2.857143 */
			R = rb[0] + s * (rb[1] + s * (rb[2] + s * (rb[3] + s * (rb[4] + s * (rb[5] + s * (rb[6] + s * rb[7]))))));
			S = sb[0] + s * (sb[1] + s * (sb[2] + s * (sb[3] + s * (sb[4] + s * (sb[5] + s * (sb[6] + s))))));
		} else
		{								/* |x| >= 6.666 */
			if (se & 0x8000)
				return two - tiny;		/* x < -6.666 */

			R = rc[0] + s * (rc[1] + s * (rc[2] + s * (rc[3] + s * (rc[4] + s * rc[5]))));
			S = sc[0] + s * (sc[1] + s * (sc[2] + s * (sc[3] + s * (sc[4] + s))));
		}
		z = x;
		GET_LDOUBLE_WORDS(hx, i0, i1, z);
		i1 = 0;
		i0 &= UC(0xffffff00);
		SET_LDOUBLE_WORDS(z, hx, i0, i1);
		r = __ieee754_expl(-z * z - 0.5625) * __ieee754_expl((z - x) * (z + x) + R / S);
		if ((se & 0x8000) == 0)
			return r / x;
		else
			return two - r / x;
	}
#ifdef _WIN32
	__set_errno(ERANGE);
#endif
	if ((se & 0x8000) == 0)
		return tiny * tiny;
	return two - tiny;
}

__typeof(__erfcl) erfcl __attribute__((weak, alias("__erfcl")));

#endif

```

`s_erff.c`:

```c
/* s_erff.c -- float version of s_erf.c.
 * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

float __erff(float x)
{
	int32_t hx, ix, i;
	float R, S, P, Q, s, y, z, r;

	static const float tiny = 1e-30;
	static const float one = 1.0000000000e+00;				/* 0x3F800000 */
	/* c = (subfloat)0.84506291151 */
	static const float erx = 8.4506291151e-01;				/* 0x3f58560b */
	static const float efx = 1.2837916613e-01;				/* 0x3e0375d4 */
	static const float efx8 = 1.0270333290e+00;				/* 0x3f8375d4 */

#include "t_erff.h"

	GET_FLOAT_WORD(hx, x);
	ix = hx & IC(0x7fffffff);
	if (!FLT_UWORD_IS_FINITE(ix))
	{									/* erf(nan)=nan */
		i = ((uint32_t) hx >> 31) << 1;
		return (float) (1 - i) + one / x;	/* erf(+-inf)=+-1 */
	}

	if (ix < IC(0x3f580000))
	{									/* |x|<0.84375 */
		if (ix < IC(0x31800000))
		{								/* |x|<2**-28 */
			if (ix < IC(0x04000000))
				/*avoid underflow */
				return 0.125f * (8.0f * x + efx8 * x);

			return x + efx * x;
		}
		z = x * x;
		r = pp0 + z * (pp1 + z * (pp2 + z * (pp3 + z * pp4)));
		s = one + z * (qq1 + z * (qq2 + z * (qq3 + z * (qq4 + z * qq5))));
		y = r / s;
		return x + x * y;
	}
	if (ix < IC(0x3fa00000))
	{									/* 0.84375 <= |x| < 1.25 */
		s = __ieee754_fabsf(x) - one;
		P = pa0 + s * (pa1 + s * (pa2 + s * (pa3 + s * (pa4 + s * (pa5 + s * pa6)))));
		Q = one + s * (qa1 + s * (qa2 + s * (qa3 + s * (qa4 + s * (qa5 + s * qa6)))));
		if (hx >= 0)
			return erx + P / Q;
		else
			return -erx - P / Q;
	}
	if (ix >= IC(0x40c00000))
	{									/* inf>|x|>=6 */
		if (hx >= 0)
			return one - tiny;
		else
			return tiny - one;
	}
	x = __ieee754_fabsf(x);
	s = one / (x * x);
	if (ix < IC(0x4036DB6E))
	{									/* |x| < 1/0.35 */
		R = ra0 + s * (ra1 + s * (ra2 + s * (ra3 + s * (ra4 + s * (ra5 + s * (ra6 + s * ra7))))));
		S = one + s * (sa1 + s * (sa2 + s * (sa3 + s * (sa4 + s * (sa5 + s * (sa6 + s * (sa7 + s * sa8)))))));
	} else
	{									/* |x| >= 1/0.35 */
		R = rb0 + s * (rb1 + s * (rb2 + s * (rb3 + s * (rb4 + s * (rb5 + s * rb6)))));
		S = one + s * (sb1 + s * (sb2 + s * (sb3 + s * (sb4 + s * (sb5 + s * (sb6 + s * sb7))))));
	}
	GET_FLOAT_WORD(ix, x);
	SET_FLOAT_WORD(z, ix & UC(0xfffff000));
	r = __ieee754_expf(-z * z - 0.5625f) * __ieee754_expf((z - x) * (z + x) + R / S);
	if (hx >= 0)
		return one - r / x;
	return r / x - one;
}

__typeof(__erff) erff __attribute__((weak, alias("__erff")));

```

`s_erfl.c`:

```c
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/* Long double expansions are
  Copyright (C) 2001 Stephen L. Moshier <moshier@na-net.ornl.gov>
  and are incorporated herein by permission of the author.  The author
  reserves the right to distribute this material elsewhere under different
  copying permissions.  These modifications are distributed here under
  the following terms:

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, see
    <http://www.gnu.org/licenses/>.  */

/* double erf(double x)
 * double erfc(double x)
 *			     x
 *		      2      |\
 *     erf(x)  =  ---------  | exp(-t*t)dt
 *		   sqrt(pi) \|
 *			     0
 *
 *     erfc(x) =  1-erf(x)
 *  Note that
 *		erf(-x) = -erf(x)
 *		erfc(-x) = 2 - erfc(x)
 *
 * Method:
 *	1. For |x| in [0, 0.84375]
 *	    erf(x)  = x + x*R(x^2)
 *          erfc(x) = 1 - erf(x)           if x in [-.84375,0.25]
 *                  = 0.5 + ((0.5-x)-x*R)  if x in [0.25,0.84375]
 *	   Remark. The formula is derived by noting
 *          erf(x) = (2/sqrt(pi))*(x - x^3/3 + x^5/10 - x^7/42 + ....)
 *	   and that
 *          2/sqrt(pi) = 1.128379167095512573896158903121545171688
 *	   is close to one. The interval is chosen because the fix
 *	   point of erf(x) is near 0.6174 (i.e., erf(x)=x when x is
 *	   near 0.6174), and by some experiment, 0.84375 is chosen to
 *	   guarantee the error is less than one ulp for erf.
 *
 *      2. For |x| in [0.84375,1.25], let s = |x| - 1, and
 *         c = 0.84506291151 rounded to single (24 bits)
 *	erf(x)  = sign(x) * (c  + P1(s)/Q1(s))
 *	erfc(x) = (1-c)  - P1(s)/Q1(s) if x > 0
 *			  1+(c+P1(s)/Q1(s))    if x < 0
 *	   Remark: here we use the taylor series expansion at x=1.
 *		erf(1+s) = erf(1) + s*Poly(s)
 *			 = 0.845.. + P1(s)/Q1(s)
 *	   Note that |P1/Q1|< 0.078 for x in [0.84375,1.25]
 *
 *      3. For x in [1.25,1/0.35(~2.857143)],
 *	erfc(x) = (1/x)*exp(-x*x-0.5625+R1(z)/S1(z))
 *              z=1/x^2
 *	erf(x)  = 1 - erfc(x)
 *
 *      4. For x in [1/0.35,107]
 *	erfc(x) = (1/x)*exp(-x*x-0.5625+R2/S2) if x > 0
 *			= 2.0 - (1/x)*exp(-x*x-0.5625+R2(z)/S2(z))
 *                             if -6.666<x<0
 *			= 2.0 - tiny		(if x <= -6.666)
 *              z=1/x^2
 *	erf(x)  = sign(x)*(1.0 - erfc(x)) if x < 6.666, else
 *	erf(x)  = sign(x)*(1.0 - tiny)
 *      Note1:
 *	   To compute exp(-x*x-0.5625+R/S), let s be a single
 *	   precision number and s := x; then
 *		-x*x = -s*s + (s-x)*(s+x)
 *	        exp(-x*x-0.5626+R/S) =
 *			exp(-s*s-0.5625)*exp((s-x)*(s+x)+R/S);
 *      Note2:
 *	   Here 4 and 5 make use of the asymptotic series
 *			  exp(-x*x)
 *		erfc(x) ~ ---------- * ( 1 + Poly(1/x^2) )
 *			  x*sqrt(pi)
 *
 *      5. For inf > x >= 107
 *	erf(x)  = sign(x) *(1 - tiny)  (raise inexact)
 *	erfc(x) = tiny*tiny (raise underflow) if x > 0
 *			= 2 - tiny if x<0
 *
 *      7. Special case:
 *	erf(0)  = 0, erf(inf)  = 1, erf(-inf) = -1,
 *	erfc(0) = 1, erfc(inf) = 0, erfc(-inf) = 2,
 *		erfc/erf(NaN) is NaN
 */


#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

long double __erfl(long double x)
{
	long double R, S, P, Q, s, y, z, r;
	int32_t ix, i;
	uint32_t se, i0, i1;

	static const long double tiny = 1e-4931L;
	static const long double one = 1.0L;
	static const long double erx = 0.845062911510467529296875L;
	/* c = (float)0.84506291151 */
	/*
	 * Coefficients for approximation to  erf on [0,0.84375]
	 */
		/* 2/sqrt(pi) - 1 */
	static const long double efx = 1.2837916709551257389615890312154517168810E-1L;
		/* 8 * (2/sqrt(pi) - 1) */
	static const long double efx8 = 1.0270333367641005911692712249723613735048E0L;

#include "t_erfl.h"

	GET_LDOUBLE_WORDS(se, i0, i1, x);
	ix = se & 0x7fff;

	if (ix >= 0x7fff)
	{									/* erf(nan)=nan */
		i = ((se & 0xffff) >> 15) << 1;
		return (long double) (1 - i) + one / x;	/* erf(+-inf)=+-1 */
	}

	ix = (ix << 16) | (i0 >> 16);
	if (ix < IC(0x3ffed800))			/* |x|<0.84375 */
	{
		if (ix < IC(0x3fde8000))		/* |x|<2**-33 */
		{
			if (ix < IC(0x00080000))
				return 0.125 * (8.0 * x + efx8 * x);	/*avoid underflow */
			return x + efx * x;
		}
		z = x * x;
		r = pp[0] + z * (pp[1] + z * (pp[2] + z * (pp[3] + z * (pp[4] + z * pp[5]))));
		s = qq[0] + z * (qq[1] + z * (qq[2] + z * (qq[3] + z * (qq[4] + z * (qq[5] + z)))));
		y = r / s;
		return x + x * y;
	}
	if (ix < IC(0x3fffa000))			/* 1.25 */
	{									/* 0.84375 <= |x| < 1.25 */
		s = __ieee754_fabsl(x) - one;
		P = pa[0] + s * (pa[1] + s * (pa[2] + s * (pa[3] + s * (pa[4] + s * (pa[5] + s * (pa[6] + s * pa[7]))))));
		Q = qa[0] + s * (qa[1] + s * (qa[2] + s * (qa[3] + s * (qa[4] + s * (qa[5] + s * (qa[6] + s))))));
		if ((se & 0x8000) == 0)
			return erx + P / Q;
		else
			return -erx - P / Q;
	}
	if (ix >= IC(0x4001d555))			/* 6.6666259765625 */
	{									/* inf>|x|>=6.666 */
		if ((se & 0x8000) == 0)
			return one - tiny;
		else
			return tiny - one;
	}
	x = __ieee754_fabsl(x);
	s = one / (x * x);
	if (ix < IC(0x4000b6db))			/* 2.85711669921875 */
	{
		R = ra[0] + s * (ra[1] + s * (ra[2] + s * (ra[3] + s * (ra[4] +
																s * (ra[5] + s * (ra[6] + s * (ra[7] + s * ra[8])))))));
		S = sa[0] + s * (sa[1] + s * (sa[2] + s * (sa[3] + s * (sa[4] +
																s * (sa[5] +
																	 s * (sa[6] + s * (sa[7] + s * (sa[8] + s))))))));
	} else
	{									/* |x| >= 1/0.35 */
		R = rb[0] + s * (rb[1] + s * (rb[2] + s * (rb[3] + s * (rb[4] + s * (rb[5] + s * (rb[6] + s * rb[7]))))));
		S = sb[0] + s * (sb[1] + s * (sb[2] + s * (sb[3] + s * (sb[4] + s * (sb[5] + s * (sb[6] + s))))));
	}
	z = x;
	GET_LDOUBLE_WORDS(i, i0, i1, z);
	i1 = 0;
	SET_LDOUBLE_WORDS(z, i, i0, i1);
	r = __ieee754_expl(-z * z - 0.5625) * __ieee754_expl((z - x) * (z + x) + R / S);
	if ((se & 0x8000) == 0)
		return one - r / x;
	else
		return r / x - one;
}

__typeof(__erfl) erfl __attribute__((weak, alias("__erfl")));

#endif

```

`s_expm1.c`:

```c
/* @(#)s_expm1.c 1.5 04/04/22 */
/*
 * ====================================================
 * Copyright (C) 2004 by Sun Microsystems, Inc. All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice 
 * is preserved.
 * ====================================================
 */
/* Modified by Naohiko Shimizu/Tokai University, Japan 1997/08/25,
   for performance improvement on pipelined processors.
*/

/* expm1(x)
 * Returns exp(x)-1, the exponential of x minus 1.
 *
 * Method
 *       1. Argument reduction:
 *      Given x, find r and integer k such that
 *
 *                               x = k*ln2 + r,  |r| <= 0.5*ln2 ~ 0.34658
 *
 *        Here a correction term c will be computed to compensate
 *      the error in r when rounded to a floating-point number.
 *
 *       2. Approximating expm1(r) by a special rational function on
 *      the interval [0,0.34658]:
 *      Since
 *              r*(exp(r)+1)/(exp(r)-1) = 2+ r^2/6 - r^4/360 + ...
 *      we define R1(r*r) by
 *              r*(exp(r)+1)/(exp(r)-1) = 2+ r^2/6 * R1(r*r)
 *      That is,
 *              R1(r**2) = 6/r *((exp(r)+1)/(exp(r)-1) - 2/r)
 *                       = 6/r * ( 1 + 2.0*(1/(exp(r)-1) - 1/r))
 *                       = 1 - r^2/60 + r^4/2520 - r^6/100800 + ...
 *              We use a special Remes algorithm on [0,0.347] to generate
 *      a polynomial of degree 5 in r*r to approximate R1. The
 *      maximum error of this polynomial approximation is bounded
 *      by 2**-61. In other words,
 *              R1(z) ~ 1.0 + Q1*z + Q2*z**2 + Q3*z**3 + Q4*z**4 + Q5*z**5
 *      where   Q1      =  -1.6666666666666567384E-2,
 *              Q2      =       3.9682539681370365873E-4,
 *              Q3      =  -9.9206344733435987357E-6,
 *              Q4      =       2.5051361420808517002E-7,
 *              Q5      =  -6.2843505682382617102E-9;
 *      (where z=r*r, and the values of Q1 to Q5 are listed below)
 *      with error bounded by
 *              |                                  5               |     -61
 *              | 1.0+Q1*z+...+Q5*z   -  R1(z) | <= 2
 *              |                                                          |
 *
 *      expm1(r) = exp(r)-1 is then computed by the following
 *      specific way which minimize the accumulation rounding error:
 *                                 2     3
 *                                r     r        [ 3 - (R1 + R1*r/2)  ]
 *                expm1(r) = r + --- + --- * [--------------------]
 *                                2     2        [ 6 - r*(3 - R1*r/2) ]
 *
 *      To compensate the error in the argument reduction, we use
 *              expm1(r+c) = expm1(r) + c + expm1(r)*c
 *                         ~ expm1(r) + c + r*c
 *      Thus c+r*c will be added in as the correction terms for
 *      expm1(r+c). Now rearrange the term to avoid optimization
 *      screw up:
 *                      (          2                                    2 )
 *                      ({      ( r    [ R1 -  (3 - R1*r/2) ]  )  }    r  )
 *       expm1(r+c)~r - ({r*(--- * [--------------------]-c)-c} - --- )
 *                      ({      ( 2    [ 6 - r*(3 - R1*r/2) ]  )  }    2  )
 *                      (                                                 )
 *
 *                 = r - E
 *       3. Scale back to obtain expm1(x):
 *      From step 1, we have
 *         expm1(x) = either 2^k*[expm1(r)+1] - 1
 *                      = or     2^k*[expm1(r) + (1-2^-k)]
 *       4. Implementation notes:
 *      (A). To save one multiplication, we scale the coefficient Qi
 *               to Qi*2^i, and replace z by (x^2)/2.
 *      (B). To achieve maximum accuracy, we compute expm1(x) by
 *        (i)   if x < -56*ln2, return -1.0, (raise inexact if x!=inf)
 *        (ii)  if k=0, return r-E
 *        (iii) if k=-1, return 0.5*(r-E)-0.5
 *                (iv)  if k=1 if r < -0.25, return 2*((r+0.5)- E)
 *                         else          return  1.0+2.0*(r-E);
 *        (v)   if (k<-2||k>56) return 2^k(1-(E-r)) - 1 (or exp(x)-1)
 *        (vi)  if k <= 20, return 2^k((1-2^-k)-(E-r)), else
 *        (vii) return 2^k(1-((E+2^-k)-r))
 *
 * Special cases:
 *      expm1(INF) is INF, expm1(NaN) is NaN;
 *      expm1(-INF) is -1, and
 *      for finite argument, only expm1(0)=0 is exact.
 *
 * Accuracy:
 *      according to an error analysis, the error is always less than
 *      1 ulp (unit in the last place).
 *
 * Misc. info.
 *      For IEEE double
 *              if x >  7.09782712893383973096e+02 then expm1(x) overflow
 *
 * Constants:
 * The hexadecimal values are the intended ones for the following
 * constants. The decimal values may be used, provided that the
 * compiler will convert from decimal to binary accurately enough
 * to produce the hexadecimal values shown.
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_expm1

double __ieee754_expm1(double x)
{
	double y, hi, lo, c, t, e, hxs, hfx, r1, h2, h4, R1, R2, R3;
	int32_t k, xsb;
	uint32_t hx;

	static const double hugeval = 1.0e+300;
	static const double o_threshold = 7.09782712893383973096e+02;	/* 0x40862E42, 0xFEFA39EF */
	static const double ln2_hi = 6.93147180369123816490e-01;	/* 0x3fe62e42, 0xfee00000 */
	static const double ln2_lo = 1.90821492927058770002e-10;	/* 0x3dea39ef, 0x35793c76 */
	static const double invln2 = 1.44269504088896338700e+00;	/* 0x3ff71547, 0x652b82fe */
	/* scaled coefficients related to expm1 */
	static const double Q[] = {
		1.0,
#define one Q[0]
		-3.33333333333331316428e-02,		/* BFA11111 111110F4 */
		1.58730158725481460165e-03,			/* 3F5A01A0 19FE5585 */
		-7.93650757867487942473e-05,		/* BF14CE19 9EAADBB7 */
		4.00821782732936239552e-06,			/* 3ED0CFCA 86E65239 */
		-2.01099218183624371326e-07			/* BE8AFDB7 6E09C32D */
	};

	GET_HIGH_WORD(hx, x);
	xsb = hx & IC(0x80000000);				/* sign bit of x */
	if (xsb == 0)
		y = x;
	else
		y = -x;							/* y = |x| */
	hx &= UC(0x7fffffff);					/* high word of |x| */

	/* filter out hugeval and non-finite argument */
	if (hx >= UC(0x4043687A))
	{									/* if |x|>=56*ln2 */
		if (hx >= UC(0x40862E42))
		{								/* if |x|>=709.78... */
			if (hx >= UC(0x7ff00000))
			{
				uint32_t low;

				GET_LOW_WORD(low, x);
				if (((hx & UC(0xfffff)) | low) != 0)
					return x + x;		/* NaN */
				return (xsb == 0) ? x : -one;	/* exp(+-inf)={inf,-1} */
			}
			if (x > o_threshold)
			{
				feraiseexcept(FE_OVERFLOW);
				return HUGE_VAL;		/* overflow */
			}
		}
		if (xsb != 0)
		{								/* x < -56*ln2, return -1.0 with inexact */
			feraiseexcept(FE_INEXACT);	/* raise inexact */
			return -one;				/* return -1 */
		}
	}

	/* argument reduction */
	if (hx > UC(0x3fd62e42))
	{									/* if  |x| > 0.5 ln2 */
		if (hx < UC(0x3FF0A2B2))
		{								/* and |x| < 1.5 ln2 */
			if (xsb == 0)
			{
				hi = x - ln2_hi;
				lo = ln2_lo;
				k = 1;
			} else
			{
				hi = x + ln2_hi;
				lo = -ln2_lo;
				k = -1;
			}
		} else
		{
			k = invln2 * x + ((xsb == 0) ? 0.5 : -0.5);
			t = k;
			hi = x - t * ln2_hi;		/* t*ln2_hi is exact here */
			lo = t * ln2_lo;
		}
		x = hi - lo;
		c = (hi - x) - lo;
	} else if (hx < UC(0x3c900000))
	{									/* when |x|<2**-54, return x */
		t = hugeval + x;				/* return x with inexact flags when x!=0 */
		return x - (t - (hugeval + x));
	} else
	{
		k = 0;
		c = 0;
	}

	/* x is now in primary range */
	hfx = 0.5 * x;
	hxs = x * hfx;
#ifdef DO_NOT_USE_THIS
	r1 = one + hxs * (Q1 + hxs * (Q2 + hxs * (Q3 + hxs * (Q4 + hxs * Q5))));
#else
	R1 = one + hxs * Q[1];
	h2 = hxs * hxs;
	R2 = Q[2] + hxs * Q[3];
	h4 = h2 * h2;
	R3 = Q[4] + hxs * Q[5];
	r1 = R1 + h2 * R2 + h4 * R3;
#endif
	t = 3.0 - r1 * hfx;
	e = hxs * ((r1 - t) / (6.0 - x * t));
	if (k == 0)
		return x - (x * e - hxs);		/* c is 0 */
	else
	{
		e = (x * (e - c) - c);
		e -= hxs;
		if (k == -1)
			return 0.5 * (x - e) - 0.5;
		if (k == 1)
		{
			if (x < -0.25)
				return -2.0 * (e - (x + 0.5));
			else
				return one + 2.0 * (x - e);
		}
		if (k <= -2 || k > 56)
		{								/* suffice to return exp(x)-1 */
			uint32_t high;

			y = one - (e - x);
			GET_HIGH_WORD(high, y);
			SET_HIGH_WORD(y, high + (k << 20));	/* add k to y's exponent */
			return y - one;
		}
		t = one;
		if (k < 20)
		{
			uint32_t high;

			SET_HIGH_WORD(t, UC(0x3ff00000) - (UC(0x200000) >> k));	/* t=1-2^-k */
			y = t - (e - x);
			GET_HIGH_WORD(high, y);
			SET_HIGH_WORD(y, high + (k << 20));	/* add k to y's exponent */
		} else
		{
			uint32_t high;

			SET_HIGH_WORD(t, ((UC(0x3ff) - k) << 20));	/* 2^-k */
			y = x - (e + t);
			y += one;
			GET_HIGH_WORD(high, y);
			SET_HIGH_WORD(y, high + (k << 20));	/* add k to y's exponent */
		}
	}
	return y;
#undef one
}

#endif

double __expm1(double x)
{
	double z = __ieee754_expm1(x);

	if ((!isfinite(z) || z == -1.0) && isfinite(x) && _LIB_VERSION != _IEEE_)
		return __kernel_standard(x, x, z, signbit(x) ? KMATHERR_EXPM1_UNDERFLOW : KMATHERR_EXPM1_OVERFLOW);

	return z;
}

__typeof(__expm1) expm1 __attribute__((weak, alias("__expm1")));
#ifdef __NO_LONG_DOUBLE_MATH
long double __expm1l(long double x) __attribute__((alias("__expm1")));
__typeof(__expm1l) expm1l __attribute__((weak, alias("__expm1")));
#endif

```

`s_expm1f.c`:

```c
/* s_expm1f.c -- float version of s_expm1.c.
 * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_expm1

float __ieee754_expm1f(float x)
{
	float y, hi, lo, c, t, e, hxs, hfx, r1;
	int32_t k, xsb;
	uint32_t hx;

	static const float hugeval = 1.0e+30;
	static const float one = 1.0;
	static const float o_threshold = 8.8721679688e+01;	/* 0x42b17180 */
	static const float ln2_hi = 6.9313812256e-01;	/* 0x3f317180 */
	static const float ln2_lo = 9.0580006145e-06;	/* 0x3717f7d1 */
	static const float invln2 = 1.4426950216e+00;	/* 0x3fb8aa3b */
	/* scaled coefficients related to expm1 */
	static const float Q1 = -3.3333335072e-02;	/* 0xbd088889 */
	static const float Q2 = 1.5873016091e-03;	/* 0x3ad00d01 */
	static const float Q3 = -7.9365076090e-05;	/* 0xb8a670cd */
	static const float Q4 = 4.0082177293e-06;	/* 0x36867e54 */
	static const float Q5 = -2.0109921195e-07;	/* 0xb457edbb */
	
	GET_FLOAT_WORD(hx, x);
	xsb = hx & UC(0x80000000);			/* sign bit of x */
	if (xsb == 0)
		y = x;
	else
		y = -x;							/* y = |x| */
	hx &= UC(0x7fffffff);				/* high word of |x| */

	/* filter out huge and non-finite argument */
	if (hx >= UC(0x4195b844))
	{									/* if |x|>=27*ln2 */
		if (hx >= UC(0x42b17218))
		{								/* if |x|>=88.721... */
			if (hx > UC(0x7f800000))
				return x + x;			/* NaN */
			if (hx == UC(0x7f800000))
				return (xsb == 0) ? x : -one;	/* exp(+-inf)={inf,-1} */
			if (x > o_threshold)
			{
				feraiseexcept(FE_OVERFLOW);
				return HUGE_VALF;		/* overflow */
			}
		}
		if (xsb != 0)
		{								/* x < -27*ln2, return -1.0 with inexact */
			feraiseexcept(FE_INEXACT);	/* raise inexact */
			return -one;				/* return -1 */
		}
	}

	/* argument reduction */
	if (hx > UC(0x3eb17218))
	{									/* if  |x| > 0.5 ln2 */
		if (hx < UC(0x3F851592))
		{								/* and |x| < 1.5 ln2 */
			if (xsb == 0)
			{
				hi = x - ln2_hi;
				lo = ln2_lo;
				k = 1;
			} else
			{
				hi = x + ln2_hi;
				lo = -ln2_lo;
				k = -1;
			}
		} else
		{
			k = invln2 * x + ((xsb == 0) ? 0.5F : -0.5F);
			t = k;
			hi = x - t * ln2_hi;		/* t*ln2_hi is exact here */
			lo = t * ln2_lo;
		}
		x = hi - lo;
		c = (hi - x) - lo;
	} else if (hx < UC(0x33000000))
	{									/* when |x|<2**-25, return x */
		t = hugeval + x;				/* return x with inexact flags when x!=0 */
		return x - (t - (hugeval + x));
	} else
	{
		k = 0;
		c = 0;
	}
	
	/* x is now in primary range */
	hfx = 0.5F *x;

	hxs = x * hfx;
	r1 = one + hxs * (Q1 + hxs * (Q2 + hxs * (Q3 + hxs * (Q4 + hxs * Q5))));
	t = 3.0F - r1 * hfx;
	e = hxs * ((r1 - t) / (6.0F - x * t));
	if (k == 0)
		return x - (x * e - hxs);		/* c is 0 */
	else
	{
		e = (x * (e - c) - c);
		e -= hxs;
		if (k == -1)
			return 0.5F *(x - e) - 0.5F;

		if (k == 1)
		{
			if (x < -0.25F)
				return -2.0F * (e - (x + 0.5F));
			else
				return one + 2.0F * (x - e);
		}
		if (k <= -2 || k > 56)
		{								/* suffice to return exp(x)-1 */
			int32_t i;

			y = one - (e - x);
			GET_FLOAT_WORD(i, y);
			SET_FLOAT_WORD(y, i + (k << 23));	/* add k to y's exponent */
			return y - one;
		}
		t = one;
		if (k < 23)
		{
			int32_t i;

			SET_FLOAT_WORD(t, UC(0x3f800000) - (UC(0x1000000) >> k));	/* t=1-2^-k */
			y = t - (e - x);
			GET_FLOAT_WORD(i, y);
			SET_FLOAT_WORD(y, i + (k << 23));	/* add k to y's exponent */
		} else
		{
			int32_t i;

			SET_FLOAT_WORD(t, ((UC(0x7f) - k) << 23));	/* 2^-k */
			y = x - (e + t);
			y += one;
			GET_FLOAT_WORD(i, y);
			SET_FLOAT_WORD(y, i + (k << 23));	/* add k to y's exponent */
		}
	}
	return y;
}

#endif

float __expm1f(float x)
{
	float z = __ieee754_expm1f(x);

	if ((!isfinite(z) || z == -1.0f) && isfinite(x) && _LIB_VERSION != _IEEE_)
		return __kernel_standard_f(x, x, z, signbit(x) ? KMATHERRF_EXPM1_UNDERFLOW : KMATHERRF_EXPM1_OVERFLOW);

	return z;
}

__typeof(__expm1f) expm1f __attribute__((weak, alias("__expm1f")));

```

`s_expm1l.c`:

```c
/*							expm1l.c
 *
 *	Exponential function, minus 1
 *      128-bit long double precision
 *
 *
 *
 * SYNOPSIS:
 *
 * long double x, y, expm1l();
 *
 * y = expm1l( x );
 *
 *
 *
 * DESCRIPTION:
 *
 * Returns e (2.71828...) raised to the x power, minus one.
 *
 * Range reduction is accomplished by separating the argument
 * into an integer k and fraction f such that
 *
 *     x    k  f
 *    e  = 2  e.
 *
 * An expansion x + .5 x^2 + x^3 R(x) approximates exp(f) - 1
 * in the basic range [-0.5 ln 2, 0.5 ln 2].
 *
 *
 * ACCURACY:
 *
 *                      Relative error:
 * arithmetic   domain     # trials      peak         rms
 *    IEEE    -79,+MAXLOG    100,000     1.7e-34     4.5e-35
 *
 */

/* Copyright 2001 by Stephen L. Moshier

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, see
    <http://www.gnu.org/licenses/>.  */


#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

#ifndef __have_fpu_expm1

/* exp(x) - 1 = x + 0.5 x^2 + x^3 P(x)/Q(x)
   -.5 ln 2  <  x  <  .5 ln 2
   Theoretical peak relative error = 8.1e-36  */

long double __ieee754_expm1l(long double x)
{
	long double px, qx, xx;
	int32_t ix, sign;
	uint32_t msw, lsw;
	int32_t k;

	static const long double P0 = 2.943520915569954073888921213330863757240E8L;
	static const long double P1 = -5.722847283900608941516165725053359168840E7L;
	static const long double P2 = 8.944630806357575461578107295909719817253E6L;
	static const long double P3 = -7.212432713558031519943281748462837065308E5L;
	static const long double P4 = 4.578962475841642634225390068461943438441E4L;
	static const long double P5 = -1.716772506388927649032068540558788106762E3L;
	static const long double P6 = 4.401308817383362136048032038528753151144E1L;
	static const long double P7 = -4.888737542888633647784737721812546636240E-1L;
	static const long double Q0 = 1.766112549341972444333352727998584753865E9L;
	static const long double Q1 = -7.848989743695296475743081255027098295771E8L;
	static const long double Q2 = 1.615869009634292424463780387327037251069E8L;
	static const long double Q3 = -2.019684072836541751428967854947019415698E7L;
	static const long double Q4 = 1.682912729190313538934190635536631941751E6L;
	static const long double Q5 = -9.615511549171441430850103489315371768998E4L;
	static const long double Q6 = 3.697714952261803935521187272204485251835E3L;
	static const long double Q7 = -8.802340681794263968892934703309274564037E1L;
	/* Q8 = 1.000000000000000000000000000000000000000E0 */
	/* C1 + C2 = ln 2 */
	static const long double C1 = 6.93145751953125E-1L;
	static const long double C2 = 1.428606820309417232121458176568075500134E-6L;
	/* ln (2^16384 * (1 - 2^-113)) */
	static const long double maxlog = 1.1356523406294143949491931077970764891253E4L;
	/* ln 2^-114 */
	static const long double minarg = -7.9018778583833765273564461846232128760607E1L;
	static const long double big = 1e4932L;

	/* Detect infinity and NaN.  */
	GET_LDOUBLE_WORDS(ix, msw, lsw, x);
	sign = ix & 0x8000;
	ix &= 0x7fff;
	lsw |= msw & IC(0x7fffffff);
	if (ix >= 0x7fff)
	{
		/* Infinity. */
		if (lsw == 0)
		{
			if (sign)
				return -1.0L;
			else
				return x;
		}
		/* NaN. No invalid exception. */
		return x;
	}

	/* expm1(+- 0) = +- 0.  */
	if (ix == 0 && lsw == 0)
		return x;

	/* Overflow.  */
	if (x > maxlog)
	{
		feraiseexcept(FE_OVERFLOW);
		return HUGE_VALL;
	}

	/* Minimum value.  */
	if (x < minarg)
		return (4.0 / big - 1.0L);

	/* Express x = ln 2 (k + remainder), remainder not exceeding 1/2. */
	xx = C1 + C2;						/* ln 2. */
	px = __ieee754_floorl(0.5L + x / xx);
	k = px;
	/* remainder times ln 2 */
	x -= px * C1;
	x -= px * C2;

	/* Approximate exp(remainder ln 2).  */
	px = (((((((P7 * x + P6) * x + P5) * x + P4) * x + P3) * x + P2) * x + P1) * x + P0) * x;

	qx = (((((((x + Q7) * x + Q6) * x + Q5) * x + Q4) * x + Q3) * x + Q2) * x + Q1) * x + Q0;

	xx = x * x;
	qx = x + (0.5 * xx + xx * px / qx);

	/* exp(x) = exp(k ln 2) exp(remainder ln 2) = 2^k exp(remainder ln 2).

	   We have qx = exp(remainder ln 2) - 1, so
	   exp(x) - 1 = 2^k (qx + 1) - 1
	   = 2^k qx + 2^k - 1.  */
	if (k == 16384)
	{
		px = __ieee754_ldexpl(1.0L, (int)k - 2);
		x = (px * qx + (px - 0.25L)) * 4.0L;
	} else
	{
		px = __ieee754_ldexpl(1.0L, (int)k);
		x = px * qx + (px - 1.0L);
	}
	return x;
}

#endif

long double __expm1l(long double x)
{
	long double z = __ieee754_expm1l(x);

	if ((!isfinite(z) || z == -1.0L) && isfinite(x) && _LIB_VERSION != _IEEE_)
		return __kernel_standard_l(x, x, z, signbit(x) ? KMATHERRL_EXPM1_UNDERFLOW : KMATHERRL_EXPM1_OVERFLOW);

	return z;
}

__typeof(__expm1l) expm1l __attribute__((weak, alias("__expm1l")));

#endif

```

`s_fabs.c`:

```c
/* @(#)s_fabs.c 1.3 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/*
 * fabs(x) returns the absolute value of x.
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

double __fabs(double x)
{
#ifdef __mc68000__
	ieee_double_shape_type *sh_u = (ieee_double_shape_type *)&x;
	sh_u->parts.msw &= UC(0x7fffffff);
	return x;
#else
	uint32_t high;

	GET_HIGH_WORD(high, x);
	SET_HIGH_WORD(x, high & UC(0x7fffffff));
	return x;
#endif
}

__typeof(__fabs) fabs __attribute__((weak, alias("__fabs")));
#ifdef __NO_LONG_DOUBLE_MATH
long double __fabsl(long double x) __attribute__((alias("__fabs")));
__typeof(__fabsl) fabsl __attribute__((weak, alias("__fabs")));
#endif

```

`s_fabsf.c`:

```c
/* s_fabsf.c -- float version of s_fabs.c.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/*
 * fabsf(x) returns the absolute value of x.
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

float __fabsf(float x)
{
	uint32_t ix;

	GET_FLOAT_WORD(ix, x);
	SET_FLOAT_WORD(x, ix & UC(0x7fffffff));
	return x;
}

__typeof(__fabsf) fabsf __attribute__((weak, alias("__fabsf")));

```

`s_fabsl.c`:

```c
/* s_fabsl.c -- long double version of s_fabs.c.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/*
 * fabsl(x) returns the absolute value of x.
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH
long double __fabsl(long double x)
{
#ifdef __mc68000__
	ieee_long_double_shape_type *sh_u = (ieee_long_double_shape_type *)&x;
	sh_u->parts.sign_exponent &= 0x7fff;
#else
	uint32_t exp;

	GET_LDOUBLE_EXP(exp, x);
	SET_LDOUBLE_EXP(x, exp & 0x7fff);
#endif
	return x;
}

__typeof(__fabsl) fabsl __attribute__((weak, alias("__fabsl")));

#endif

```

`s_fdim.c`:

```c
/* Return positive difference between arguments.
   Copyright (C) 1997-2013 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

double __fdim(double x, double y)
{
	double r;

	if (islessequal(x, y))
		return 0.0;

	r = x - y;

	if (isinf(r) && !isinf(x) && !isinf(y))
		__set_errno(ERANGE);

	return r;
}

__typeof(__fdim) fdim __attribute__((weak, alias("__fdim")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(fdiml) __fdiml __attribute__((alias("__fdim")));
__typeof(__fdiml) fdiml __attribute__((weak, alias("__fdim")));
#endif

```

`s_fdimf.c`:

```c
/* Return positive difference between arguments.
   Copyright (C) 1997-2013 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

float __fdimf(float x, float y)
{
	float r;

	if (islessequal(x, y))
		return 0.0f;

	r = x - y;

	if (isinf(r) && !isinf(x) && !isinf(y))
		__set_errno(ERANGE);

	return r;
}

__typeof(__fdimf) fdimf __attribute__((weak, alias("__fdimf")));

```

`s_fdiml.c`:

```c
/* Return positive difference between arguments.
   Copyright (C) 1997-2013 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH
long double __fdiml(long double x, long double y)
{
	long double r;

	if (islessequal(x, y))
		return 0.0L;

	r = x - y;

	if (isinf(r) && !isinf(x) && !isinf(y))
		__set_errno(ERANGE);

	return r;
}

__typeof(__fdiml) fdiml __attribute__((weak, alias("__fdiml")));

#endif

```

`s_finite.c`:

```c
/* @(#)s_finite.c 1.3 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice 
 * is preserved.
 * ====================================================
 */

/*
 * finite(x) returns 1 is x is finite, else 0;
 * no branching!
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

int __finite(double x)
{
	uint32_t hx;

	GET_HIGH_WORD(hx, x);
	return (int) (((hx & UC(0x7fffffff)) - UC(0x7ff00000)) >> 31);
}

__typeof(__finite) finite __attribute__((weak, alias("__finite")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(finitel) __finitel __attribute__((alias("__finite")));
__typeof(__finitel) finitel __attribute__((weak, alias("__finite")));
#endif

```

`s_finitef.c`:

```c
/*
 * finitef(x) returns 1 is x is finite, else 0;
 * no branching!
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

int __finitef(float x)
{
	uint32_t ix;

	GET_FLOAT_WORD(ix, x);
	return (ix & UC(0x7fffffff)) < UC(0x7f800000);
}

__typeof(__finitef) finitef __attribute__((weak, alias("__finitef")));

```

`s_finitel.c`:

```c
/* s_finitel.c -- long double version of s_finite.c.
 * Conversion to IEEE quad long double by Jakub Jelinek, jj@ultra.linux.cz.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/*
 * finitel(x) returns 1 is x is finite, else 0;
 * no branching!
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

int __finitel(long double x)
{
	uint32_t exp;

	GET_LDOUBLE_EXP(exp, x);
	return (int) (((exp & 0x7fff) - 0x7fff) >> 31);
}

__typeof(__finitel) finitel __attribute__((weak, alias("__finitel")));

#endif

```

`s_floor.c`:

```c
/* @(#)s_floor.c 1.3 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/*
 * floor(x)
 * Return x rounded toward -inf to integral value
 * Method:
 *	Bit twiddling.
 * Exception:
 *	Inexact flag raised if x not equal to floor(x).
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_floor

double __ieee754_floor(double x)
{
	int32_t i0, j0;
	uint32_t i, j, i1;

	static const double hugeval = 1.0e300;
	
	GET_DOUBLE_WORDS(i0, i1, x);
	j0 = ((i0 >> IEEE754_DOUBLE_SHIFT) & IEEE754_DOUBLE_MAXEXP) - IEEE754_DOUBLE_BIAS;
	if (j0 < IEEE754_DOUBLE_SHIFT)
	{
		if (j0 < 0)
		{								/* raise inexact if x != 0 */
			math_force_eval(hugeval + x);	/* return 0*sign(x) if |x|<1 */
			if (i0 >= 0)
			{
				i0 = i1 = 0;
			} else if (((i0 & IC(0x7fffffff)) | i1) != 0)
			{
				i0 = IC(0xbff00000);
				i1 = 0;
			}
		} else
		{
			i = UC(0x000fffff) >> j0;
			if (((i0 & i) | i1) == 0)
				return x;				/* x is integral */
			math_force_eval(hugeval + x);	/* raise inexact flag */
			if (i0 < 0)
				i0 += UC(0x00100000) >> j0;
			i0 &= (~i);
			i1 = 0;
		}
	} else if (j0 > 51)
	{
		if (j0 == (IEEE754_DOUBLE_MAXEXP - IEEE754_DOUBLE_BIAS))
			return x + x;				/* inf or NaN */
		else
			return x;					/* x is integral */
	} else
	{
		i = UC(0xffffffff) >> (j0 - IEEE754_DOUBLE_SHIFT);
		if ((i1 & i) == 0)
			return x;					/* x is integral */
		math_force_eval(hugeval + x);		/* raise inexact flag */
		if (i0 < 0)
		{
			if (j0 == IEEE754_DOUBLE_SHIFT)
				i0 += 1;
			else
			{
				j = i1 + (UC(1) << (52 - j0));
				if (j < i1)
					i0 += 1;			/* got a carry */
				i1 = j;
			}
		}
		i1 &= (~i);
	}
	INSERT_WORDS(x, i0, i1);
	return x;
}

#endif

double __floor(double x)
{
	return __ieee754_floor(x);
}

__typeof(__floor) floor __attribute__((weak, alias("__floor")));
#ifdef __NO_LONG_DOUBLE_MATH
long double __floorl(long double x) __attribute__((alias("__floor")));
__typeof(__floorl) floorl __attribute__((weak, alias("__floor")));
#endif

```

`s_floorf.c`:

```c
#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_floor

float __ieee754_floorf(float x)
{
	int32_t i0, j0;
	uint32_t i;

	static const float hugeval = 1.0e30;
	
	GET_FLOAT_WORD(i0, x);
	j0 = ((i0 >> IEEE754_FLOAT_SHIFT) & IEEE754_FLOAT_MAXEXP) - IEEE754_FLOAT_BIAS;
	if (j0 < IEEE754_FLOAT_SHIFT)
	{
		if (j0 < 0)
		{								/* raise inexact if x != 0 */
			math_force_eval(hugeval + x);	/* return 0*sign(x) if |x|<1 */
			if (i0 >= 0)
			{
				i0 = 0;
			} else if ((i0 & UC(0x7fffffff)) != 0)
			{
				i0 = UC(0xbf800000);
			}
		} else
		{
			i = UC(0x007fffff) >> j0;
			if ((i0 & i) == 0)
				return x;				/* x is integral */
			math_force_eval(hugeval + x);	/* raise inexact flag */
			if (i0 < 0)
				i0 += UC(0x00800000) >> j0;
			i0 &= (~i);
		}
	} else
	{
		if (j0 == (IEEE754_FLOAT_MAXEXP - IEEE754_FLOAT_BIAS))
			return x + x;				/* inf or NaN */
		else
			return x;					/* x is integral */
	}
	SET_FLOAT_WORD(x, i0);
	return x;
}

#endif

float __floorf(float x)
{
	return __ieee754_floorf(x);
}

__typeof(__floorf) floorf __attribute__((weak, alias("__floorf")));

```

`s_floorl.c`:

```c
#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

#ifndef __have_fpu_floor

long double __ieee754_floorl(long double x)
{
	int32_t j0;
	uint32_t i, j, se, i0, i1, sx;

	static const long double hugeval = 1.0e4930L;
	
	GET_LDOUBLE_WORDS(se, i0, i1, x);
	sx = (se >> 15) & 1;
	j0 = (se & IEEE854_LONG_DOUBLE_MAXEXP) - IEEE854_LONG_DOUBLE_BIAS;
	if (j0 < 31)
	{
		if (j0 < 0)
		{								/* raise inexact if x != 0 */
			if (hugeval + x > 0.0)
			{							/* return 0*sign(x) if |x|<1 */
				if (sx == 0)
				{
					se = 0;
					i0 = i1 = 0;
				} else if (((se & IEEE854_LONG_DOUBLE_MAXEXP) | i0 | i1) != 0)
				{
					se = 0xbfff;
					i0 = IC(0x80000000); /* explicit */
					i1 = 0;
				}
			}
		} else
		{
			i = UC(0x7fffffff) >> j0;
			if (((i0 & i) | i1) == 0)
				return x;				/* x is integral */
			if (hugeval + x > 0.0)
			{							/* raise inexact flag */
				if (sx)
				{
					if (j0 > 0 && (i0 + (UC(0x80000000) >> j0)) > i0)
						i0 += UC(0x80000000) >> j0;
					else
					{
						i = UC(0x7fffffff);
						++se;
					}
				}
				i0 &= (~i);
				i1 = 0;
			}
		}
	} else if (j0 > 62)
	{
		if (j0 == (IEEE854_LONG_DOUBLE_MAXEXP - IEEE854_LONG_DOUBLE_BIAS))
			return x + x;				/* inf or NaN */
		else
			return x;					/* x is integral */
	} else
	{
		i = UC(0xffffffff) >> (j0 - 31);
		if ((i1 & i) == 0)
			return x;					/* x is integral */
		if (hugeval + x > 0.0)
		{								/* raise inexact flag */
			if (sx)
			{
				if (j0 == 31)
					i0 += 1;
				else
				{
					j = i1 + (UC(1) << (63 - j0));
					if (j < i1)
						i0 += 1;		/* got a carry */
					i1 = j;
				}
			}
			i1 &= (~i);
		}
	}
	SET_LDOUBLE_WORDS(x, se, i0, i1);
	return x;
}

#endif

long double __floorl(long double x)
{
	return __ieee754_floorl(x);
}

__typeof(__floorl) floorl __attribute__((weak, alias("__floorl")));

#endif

```

`s_fmax.c`:

```c
/* Return maximum numeric value of X and Y.
   Copyright (C) 1997 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

double __fmax(double x, double y)
{
	return (isgreaterequal (x, y) || isnan (y)) ? x : y;
}

__typeof(__fmax) fmax __attribute__((weak, alias("__fmax")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(fmaxl) __fmaxl __attribute__((alias("__fmax")));
__typeof(__fmaxl) fmaxl __attribute__((weak, alias("__fmax")));
#endif

```

`s_fmaxf.c`:

```c
#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

float __fmaxf(float x, float y)
{
	return (isgreaterequal (x, y) || isnan (y)) ? x : y;
}

__typeof(__fmaxf) fmaxf __attribute__((weak, alias("__fmaxf")));

```

`s_fmaxl.c`:

```c
#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

long double __fmaxl(long double x, long double y)
{
	return (isgreaterequal (x, y) || isnan (y)) ? x : y;
}

__typeof(__fmaxl) fmaxl __attribute__((weak, alias("__fmaxl")));

#endif

```

`s_fmin.c`:

```c
/* Return minimum numeric value of X and Y.
   Copyright (C) 1997 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

double __fmin(double x, double y)
{
	return (islessequal (x, y) || isnan (y)) ? x : y;
}

__typeof(__fmin) fmin __attribute__((weak, alias("__fmin")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(fminl) __fminl __attribute__((alias("__fmin")));
__typeof(__fminl) fminl __attribute__((weak, alias("__fmin")));
#endif

```

`s_fminf.c`:

```c
#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

float __fminf(float x, float y)
{
	return (islessequal (x, y) || isnan (y)) ? x : y;
}

__typeof(__fminf) fminf __attribute__((weak, alias("__fminf")));

```

`s_fminl.c`:

```c
#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

long double __fminl(long double x, long double y)
{
	return (islessequal (x, y) || isnan (y)) ? x : y;
}

__typeof(__fminl) fminl __attribute__((weak, alias("__fminl")));

#endif

```

`s_fpclassify.c`:

```c
/* Copyright (C) 2002, 2007 by  Red Hat, Incorporated. All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software
 * is freely granted, provided that this notice is preserved.
 */

#include "fdlibm.h"

#undef fpclassify

int __fpclassify (double x)
{
	int retval = FP_NORMAL;
	uint32_t msw, lsw;

	GET_DOUBLE_WORDS(msw, lsw, x);

	lsw |= msw & UC(0xfffff);
	msw &= UC(0x7ff00000);
	if ((msw | lsw) == 0)
		retval = FP_ZERO;
	else if (msw == 0)
		retval = FP_SUBNORMAL;
	else if (msw == UC(0x7ff00000))
		retval = lsw != 0 ? FP_NAN : FP_INFINITE;

	return retval;
}

__typeof(__fpclassify) fpclassify __attribute__((weak, alias("__fpclassify")));
#ifdef __NO_LONG_DOUBLE_MATH
int __fpclassifyl(long double x) __attribute__((alias("__fpclassify")));
__typeof(__fpclassifyl) fpclassifyl __attribute__((weak, alias("__fpclassifyl")));
#endif

```

`s_fpclassifyf.c`:

```c
/* Copyright (C) 2002, 2007 by  Red Hat, Incorporated. All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software
 * is freely granted, provided that this notice is preserved.
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

int __fpclassifyf(float x)
{
	int retval = FP_NORMAL;
	uint32_t wx;

	GET_FLOAT_WORD(wx, x);
	wx &= UC(0x7fffffff);
	if (wx == 0)
		retval = FP_ZERO;
	else if (wx < UC(0x800000))
		retval = FP_SUBNORMAL;
	else if (wx >= UC(0x7f800000))
		retval = wx > UC(0x7f800000) ? FP_NAN : FP_INFINITE;

	return retval;
}

__typeof(__fpclassifyf) fpclassifyf __attribute__((weak, alias("__fpclassifyf")));

```

`s_fpclassifyl.c`:

```c
/* Copyright (C) 2002, 2007 by  Red Hat, Incorporated. All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software
 * is freely granted, provided that this notice is preserved.
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

int __fpclassifyl(long double x)
{
	int retval = FP_NORMAL;
	uint32_t ex, hx, lx, m;

	GET_LDOUBLE_WORDS(ex, hx, lx, x);
	m = (hx & UC(0x7fffffff)) | lx;
	ex &= IEEE854_LONG_DOUBLE_MAXEXP;
	if ((ex | m) == 0)
		retval = FP_ZERO;
	else if (ex == 0 && (hx & UC(0x80000000)) == 0)
		retval = FP_SUBNORMAL;
	else if (ex == IEEE854_LONG_DOUBLE_MAXEXP)
		retval = m != 0 ? FP_NAN : FP_INFINITE;

	return retval;
}

__typeof(__fpclassifyl) fpclassifyl __attribute__((weak, alias("__fpclassifyl")));

#endif

```

`s_frexp.c`:

```c
/* @(#)s_frexp.c 1.4 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice 
 * is preserved.
 * ====================================================
 */

/*
 * for non-zero x 
 *	x = frexp(arg,&exp);
 * return a double fp quantity x such that 0.5 <= |x| <1.0
 * and the corresponding binary exponent "exp". That is
 *	arg = x*2^exp.
 * If arg is inf, 0.0, or NaN, then frexp(arg,&exp) returns arg 
 * with *exp=0. 
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_frexp

double __ieee754_frexp(double x, int *eptr)
{
	int32_t hx, ix, lx;
	static const double two54 = 1.80143985094819840000e+16;	/* 0x43500000, 0x00000000 */

	GET_DOUBLE_WORDS(hx, lx, x);
	ix = UC(0x7fffffff) & hx;
	*eptr = 0;
	if (ix >= IC(0x7ff00000) || ((ix | lx) == 0))
		return x;						/* 0,inf,nan */
	if (ix < IC(0x00100000))
	{									/* subnormal */
		x *= two54;
		GET_HIGH_WORD(hx, x);
		ix = hx & UC(0x7fffffff);
		*eptr = -54;
	}
	*eptr += (int)(ix >> 20) - 1022;
	hx = (hx & UC(0x800fffff)) | UC(0x3fe00000);
	SET_HIGH_WORD(x, hx);
	return x;
}

#endif

double __frexp(double x, int *exp)
{
	return __ieee754_frexp(x, exp);
}

__typeof(__frexp) frexp __attribute__((weak, alias("__frexp")));
#ifdef __NO_LONG_DOUBLE_MATH
long double __frexpl(long double x, int *expt) __attribute__((alias("__frexp")));
__typeof(__frexpl) frexpl __attribute__((weak, alias("__frexp")));
#endif

```

`s_frexpf.c`:

```c
#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_frexp

float __ieee754_frexpf(float x, int *eptr)
{
	int32_t hx, ix;
	static const float two25 = 3.3554432000e+07;				/* 0x4c000000 */

	GET_FLOAT_WORD(hx, x);
	ix = UC(0x7fffffff) & hx;
	*eptr = 0;
	if (!FLT_UWORD_IS_FINITE(ix) || FLT_UWORD_IS_ZERO(ix))
		return x;						/* 0,inf,nan */
	if (FLT_UWORD_IS_SUBNORMAL(ix))
	{									/* subnormal */
		x *= two25;
		GET_FLOAT_WORD(hx, x);
		ix = hx & UC(0x7fffffff);
		*eptr = -25;
	}
	*eptr += (int)(ix >> 23) - 126;
	hx = (hx & UC(0x807fffff)) | UC(0x3f000000);
	SET_FLOAT_WORD(x, hx);
	return x;
}

#endif

float __frexpf(float x, int *exp)
{
	return __ieee754_frexpf(x, exp);
}

__typeof(__frexpf) frexpf __attribute__((weak, alias("__frexpf")));

```

`s_frexpl.c`:

```c
#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

#ifndef __have_fpu_frexp

long double __ieee754_frexpl(long double x, int *eptr)
{
	static const long double two65 = 3.68934881474191032320e+19L;	/* 0x4040, 0x80000000, 0x00000000 */

	uint32_t se, hx, ix, lx;

	GET_LDOUBLE_WORDS(se, hx, lx, x);
	ix = 0x7fff & se;
	*eptr = 0;
	if (ix == 0x7fff || ((ix | hx | lx) == 0))
		return x;						/* 0,inf,nan */
	if (ix == 0x0000)
	{									/* subnormal */
		x *= two65;
		GET_LDOUBLE_EXP(se, x);
		ix = se & 0x7fff;
		*eptr = -65;
	}
	*eptr += (int)(ix - 16382);
	se = (se & 0x8000) | 0x3ffe;
	SET_LDOUBLE_EXP(x, se);
	return x;
}

#endif

long double __frexpl(long double x, int *exp)
{
	return __ieee754_frexpl(x, exp);
}

__typeof(__frexpl) frexpl __attribute__((weak, alias("__frexpl")));

#endif

```

`s_isinf.c`:

```c
/*
 * Written by J.T. Conklin <jtc@netbsd.org>.
 * Changed to return -1 for -Inf by Ulrich Drepper <drepper@cygnus.com>.
 * Public domain.
 */

/*
 * isinf(x) returns 1 is x is inf, -1 if x is -inf, else 0;
 * no branching!
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

int __isinf(double x)
{
	int32_t hx, lx;

	GET_DOUBLE_WORDS(hx, lx, x);
	lx |= (hx & IC(0x7fffffff)) ^ IC(0x7ff00000);
	lx |= -lx;
	return (int)(~(lx >> 31) & (hx >> 30));
}

__typeof(__isinf) isinf __attribute__((weak, alias("__isinf")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(__isinfl) __isinfl __attribute__((alias("__isinf")));
__typeof(__isinfl) isinfl __attribute__((weak, alias("__isinf")));
#endif

```

`s_isinff.c`:

```c
/*
 * Written by J.T. Conklin <jtc@netbsd.org>.
 * Public domain.
 */

/*
 * isinff(x) returns 1 if x is inf, -1 if x is -inf, else 0;
 * no branching!
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

int __isinff(float x)
{
	int32_t ix, t;

	GET_FLOAT_WORD(ix, x);
	t = ix & IC(0x7fffffff);
	t ^= IC(0x7f800000);
	t |= -t;
	return (int)(~(t >> 31) & (ix >> 30));
}

__typeof(__isinff) isinff __attribute__((weak, alias("__isinff")));

```

`s_isinfl.c`:

```c
/*
 * Written by J.T. Conklin <jtc@netbsd.org>.
 * Change for long double by Jakub Jelinek <jj@ultra.linux.cz>
 * Public domain.
 */

/*
 * isinfl(x) returns 1 if x is inf, -1 if x is -inf, else 0;
 * no branching!
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

int __isinfl(long double x)
{
	int32_t se, hx, lx;

	GET_LDOUBLE_WORDS(se, hx, lx, x);
	lx |= (hx & IC(0x7fffffff)) | ((se & 0x7fff) ^ 0x7fff);
	lx |= -lx;
	se &= 0x8000;
	return (int)(~(lx >> 31) & (1 - (se >> 14)));
}

__typeof(__isinfl) isinfl __attribute__((weak, alias("__isinfl")));

#endif

```

`s_isnan.c`:

```c
/* @(#)s_isnan.c 1.3 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/*
 * isnan(x) returns 1 is x is nan, else 0;
 * no branching!
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

int __isnan(double x)
{
	int32_t hx, lx;

	GET_DOUBLE_WORDS(hx, lx, x);
	hx &= IC(0x7fffffff);
	hx |= (uint32_t) (lx | (-lx)) >> 31;
	hx = IC(0x7ff00000) - hx;
	return (int) (((uint32_t) hx) >> 31);
}

__typeof(__isnan) isnan __attribute__((weak, alias("__isnan")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(__isnanl) __isnanl __attribute__((alias("__isnan")));
__typeof(__isnanl) isnanl __attribute__((weak, alias("__isnan")));
#endif

```

`s_isnanf.c`:

```c
#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

int __isnanf(float x)
{
	int32_t ix;

	GET_FLOAT_WORD(ix, x);
	ix &= IC(0x7fffffff);
	return ix > IC(0x7f800000);
}

__typeof(__isnanf) isnanf __attribute__((weak, alias("__isnanf")));

```

`s_isnanl.c`:

```c
#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

int __isnanl(long double x)
{
	int32_t se, hx, lx;

	GET_LDOUBLE_WORDS(se, hx, lx, x);
	se = (se & 0x7fff) << 1;
	lx |= hx & IC(0x7fffffff);
	se |= (uint32_t) (lx | (-lx)) >> 31;
	se = 0xfffe - se;
	return (int) (((uint32_t) (se)) >> 31);
}

__typeof(__isnanl) isnanl __attribute__((weak, alias("__isnanl")));

#endif

```

`s_issig.c`:

```c
#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#undef issignaling

int __issignaling(double x)
{
#ifdef HIGH_ORDER_BIT_IS_SET_FOR_SNAN
	uint32_t hxi;

	GET_HIGH_WORD(hxi, x);
	/* We only have to care about the high-order bit of x's significand, because
	   having it set (sNaN) already makes the significand different from that
	   used to designate infinity.  */
	return (hxi & UC(0x7ff80000)) == UC(0x7ff80000);
#else
	uint32_t hxi, lxi;

	GET_DOUBLE_WORDS(hxi, lxi, x);
	/* To keep the following comparison simple, toggle the quiet/signaling bit,
	   so that it is set for sNaNs.  This is inverse to IEEE 754-2008 (as well as
	   common practice for IEEE 754-1985).  */
	hxi ^= UC(0x00080000);
	/* If lxi != 0, then set any suitable bit of the significand in hxi.  */
	hxi |= (lxi | -lxi) >> 31;
	/* We have to compare for greater (instead of greater or equal), because x's
	   significand being all-zero designates infinity not NaN.  */
	return (hxi & UC(0x7fffffff)) > UC(0x7ff80000);
#endif
}

__typeof(__issignaling) issignaling __attribute__((weak, alias("__issignaling")));
#ifdef __NO_LONG_DOUBLE_MATH
int __issignalingl(long double x) __attribute__((alias("__issignaling")));
__typeof(__issignalingl) issignalingl __attribute__((weak, alias("__issignaling")));
#endif

```

`s_issigf.c`:

```c
#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

int __issignalingf(float x)
{
	uint32_t xi;

	GET_FLOAT_WORD(xi, x);
#ifdef HIGH_ORDER_BIT_IS_SET_FOR_SNAN
	/* We only have to care about the high-order bit of x's significand, because
	   having it set (sNaN) already makes the significand different from that
	   used to designate infinity.  */
	return (xi & UC(0x7fc00000)) == UC(0x7fc00000);
#else
	/* To keep the following comparison simple, toggle the quiet/signaling bit,
	   so that it is set for sNaNs.  This is inverse to IEEE 754-2008 (as well as
	   common practice for IEEE 754-1985).  */
	xi ^= UC(0x00400000);
	/* We have to compare for greater (instead of greater or equal), because x's
	   significand being all-zero designates infinity not NaN.  */
	return (xi & UC(0x7fffffff)) > UC(0x7fc00000);
#endif
}

__typeof(__issignalingf) issignalingf __attribute__((weak, alias("__issignalingf")));

```

`s_issigl.c`:

```c
#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

int __issignalingl(long double x)
{
	uint32_t exi, hxi, lxi;

	GET_LDOUBLE_WORDS(exi, hxi, lxi, x);
#ifdef HIGH_ORDER_BIT_IS_SET_FOR_SNAN
# error not implemented
#else
	/* To keep the following comparison simple, toggle the quiet/signaling bit,
	   so that it is set for sNaNs.  This is inverse to IEEE 754-2008 (as well as
	   common practice for IEEE 754-1985).  */
	hxi ^= UC(0x40000000);
	/* If lxi != 0, then set any suitable bit of the significand in hxi.  */
	hxi |= (lxi | -lxi) >> 31;
	/* We do not recognize a pseudo NaN as sNaN; they're invalid on 80387 and
	   later.  */
	/* We have to compare for greater (instead of greater or equal), because x's
	   significand being all-zero designates infinity not NaN.  */
	return ((exi & 0x7fff) == 0x7fff) && (hxi > UC(0xc0000000));
#endif
}

__typeof(__issignalingl) issignalingl __attribute__((weak, alias("__issignalingl")));

#endif

```

`s_ldexp.c`:

```c
/* @(#)s_ldexp.c 1.3 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice 
 * is preserved.
 * ====================================================
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_ldexp

double __ieee754_ldexp(double value, int exp)
{
	if (!isfinite(value) || value == 0.0)
		return value;
	return __ieee754_scalbn(value, exp);
}

#endif

double __ldexp(double x, int n)
{
	x = __ieee754_ldexp(x, n);
	if (!isfinite(x) || x == 0.0)
		__set_errno(ERANGE);
	return x;
}

__typeof(__ldexp) ldexp __attribute__((weak, alias("__ldexp")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(__ldexpl) __ldexpl __attribute__((alias("__ldexp")));
__typeof(__ldexpl) ldexpl __attribute__((weak, alias("__ldexp")));
#endif

```

`s_ldexpf.c`:

```c
#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_ldexp

float __ieee754_ldexpf(float value, int exp)
{
	if (!isfinite(value) || value == 0.0F)
		return value;
	return __ieee754_scalbnf(value, exp);
}

#endif

float __ldexpf(float x, int n)
{
	x = __ieee754_ldexpf(x, n);
	if (!isfinite(x) || x == 0.0F)
		__set_errno(ERANGE);
	return x;
}

__typeof(__ldexpf) ldexpf __attribute__((weak, alias("__ldexpf")));

```

`s_ldexpl.c`:

```c
#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

#ifndef __have_fpu_ldexp

long double __ieee754_ldexpl(long double value, int exp)
{
	if (!isfinite(value) || value == 0.0)
		return value;
	return __ieee754_scalbnl(value, exp);
}

#endif

long double __ldexpl(long double x, int n)
{
	x = __ieee754_ldexpl(x, n);
	if (!isfinite(x) || x == 0.0)
		__set_errno(ERANGE);
	return x;
}

__typeof(__ldexpl) ldexpl __attribute__((weak, alias("__ldexpl")));

#endif

```

`s_lib_version.c`:

```c
/* @(#)s_lib_version.c 1.3 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice 
 * is preserved.
 * ====================================================
 */

/*
 * MACRO for standards
 */

#include "fdlibm.h"

#undef _LIB_VERSION

/*
 * define and initialize _LIB_VERSION
 */
#if defined(_POSIX_MODE)
_LIB_VERSION_TYPE _LIB_VERSION = _POSIX_;
#elif defined(_XOPEN_MODE)
_LIB_VERSION_TYPE _LIB_VERSION = _XOPEN_;
#elif defined(_SVID3_MODE)
_LIB_VERSION_TYPE _LIB_VERSION = _SVID_;
#else					/* default _IEEE_MODE */
_LIB_VERSION_TYPE _LIB_VERSION = _IEEE_;
#endif

```

`s_llrint.c`:

```c
/* Round argument to nearest integral value according to current rounding
   direction.
   Copyright (C) 1997-2013 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONGLONG

long long int __llrint(double x)
{
	int32_t j0;
	uint32_t i0, i1;
	long long int result;
	int32_t sx;
	int rm;

	rm = fegetround();

	GET_DOUBLE_WORDS(i0, i1, x);
	j0 = ((i0 >> IEEE754_DOUBLE_SHIFT) & IEEE754_DOUBLE_MAXEXP) - IEEE754_DOUBLE_BIAS;
	sx = i0 & IC(0x80000000);
	i0 &= UC(0xfffff);
	
	if (j0 < IEEE754_DOUBLE_SHIFT)
	{
		uint32_t i;
		
		if (j0 == -IEEE754_DOUBLE_BIAS)
			return 0;
		/* Raise inexact if x != 0.  */
		if (j0 < 0 || (i0 | i1) != 0)
			feraiseexcept(FE_INEXACT);
		if (j0 < 0)
		{
			switch (rm)
			{
				case FE_TOWARDZERO: return 0;
				case FE_DOWNWARD: return sx ? -1 : 0;
				case FE_UPWARD: return sx ? 0 : 1;
			}
			/* case FE_TONEAREST: */
			if (j0 == -1 && (i0 | i1) != 0)
				return sx ? -1 : 1;
			return 0;
		}

		switch (rm)
		{
		case FE_TOWARDZERO:
			i0 |= UC(0x100000);
			break;
		case FE_DOWNWARD:
			i = UC(0x000fffff) >> j0;
			i0 |= UC(0x100000);
			if (sx && ((i0 & i) | i1) != 0)
				i0 += UC(0x00100000) >> j0;
			break;
		case FE_UPWARD:
			i = UC(0x000fffff) >> j0;
			i0 |= UC(0x100000);
			if (!sx && ((i0 & i) | i1) != 0)
				i0 += IC(0x00100000) >> j0;
			break;
		case FE_TONEAREST:
		default:
			i = UC(0x000fffff) >> j0;
			i0 |= UC(0x100000);
			if ((i0 & (i >> 1)) != 0 || i1 != 0 || (i0 & (UC(0x00100000) >> j0)))
			{
				i0 += UC(0x00080000) >> j0;
			}
			break;
		}
		result = i0 >> (IEEE754_DOUBLE_SHIFT - j0);
	} else if (j0 < (int32_t) (8 * sizeof(long long int)) - 1)
	{
		if (j0 >= 52)
		{
			i0 |= UC(0x100000);
			if ((j0 - IEEE754_DOUBLE_SHIFT) >= (int32_t) (8 * sizeof(long long int)))
				result = 0;
			else
				result = (long long int) i0 << (j0 - IEEE754_DOUBLE_SHIFT);
			if ((j0 - 52) < 32)
				result |= (unsigned long long int)i1 << (j0 - 52);
		} else
		{
			uint32_t i = UC(0xffffffff) >> (j0 - IEEE754_DOUBLE_SHIFT);
			uint32_t j;
		
			switch (rm)
			{
			case FE_TOWARDZERO:
				i0 |= UC(0x100000);
				break;
			case FE_DOWNWARD:
				i0 |= UC(0x100000);
				if (sx && (i1 & i) != 0)
				{
					if (j0 == IEEE754_DOUBLE_SHIFT)
						i0 += 1;
					else
					{
						j = i1 + (UC(1) << (52 - j0));
						if (j < i1)
							i0 += 1;			/* got a carry */
						i1 = j;
					}
				}
				break;
			case FE_UPWARD:
				i0 |= UC(0x100000);
				if (!sx && (i1 & i) != 0)
				{
					if (j0 == IEEE754_DOUBLE_SHIFT)
						i0 += 1;
					else
					{
						j = i1 + (UC(1) << (52 - j0));
						if (j < i1)
							i0 += 1;			/* got a carry */
						i1 = j;
					}
				}
				break;
			case FE_TONEAREST:
			default:
				i0 |= UC(0x100000);
				if ((i1 & (i >> 1)) != 0 || (j0 == IEEE754_DOUBLE_SHIFT && (i0 & 1)) || (i1 & (UC(1) << (52 - j0))))
				{
					j = i1 + (UC(1) << (51 - j0));
					if (j < i1)
						i0 += 1;
					i1 = j;
				}
				break;
			}
			i1 &= ~i;
			if (j0 == IEEE754_DOUBLE_SHIFT)
				result = (long long int) i0;
			else
				result = ((long long int) i0 << (j0 - IEEE754_DOUBLE_SHIFT)) | (i1 >> (52 - j0));
		}
	} else
	{
		/* The number is too large.  It is left implementation defined
		   what happens.  */
		feraiseexcept(FE_INVALID|FE_INEXACT);
		if (j0 == (IEEE754_DOUBLE_MAXEXP - IEEE754_DOUBLE_BIAS))
		{
			/* inf or nan */
			return LONG_LONG_MIN;
		}
		return (long long int) x;
	}

	return sx ? -result : result;
}

__typeof(__llrint) llrint __attribute__((weak, alias("__llrint")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(llrintl) __llrintl __attribute__((alias("__llrint")));
__typeof(__llrintl) llrintl __attribute__((weak, alias("__llrint")));
#endif

#endif

```

`s_llrintf.c`:

```c
#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONGLONG

long long int __llrintf(float x)
{
	int32_t j0;
	uint32_t i0;
	long long int result;
	int32_t sx;
	int rm;

	rm = fegetround();

	GET_FLOAT_WORD(i0, x);

	sx = i0 & IC(0x80000000);
	j0 = ((i0 >> IEEE754_FLOAT_SHIFT) & IEEE754_FLOAT_MAXEXP) - IEEE754_FLOAT_BIAS;
	i0 &= UC(0x7fffff);

	if (j0 < (int32_t) (sizeof(long long int) * 8) - 1)
	{
		if (j0 == -IEEE754_FLOAT_BIAS)
			return 0;
		/* Raise inexact if x != 0.  */
		if (j0 < 0 || i0 != 0)
			feraiseexcept(FE_INEXACT);

		if (j0 < 0)
		{
			switch (rm)
			{
				case FE_TOWARDZERO: return 0;
				case FE_DOWNWARD: return sx ? -1 : 0;
				case FE_UPWARD: return sx ? 0 : 1;
			}
			/* case FE_TONEAREST: */
			if (j0 == -1 && i0 != 0)
				return sx ? -1 : 1;
			return 0;
		}

		if (j0 >= IEEE754_FLOAT_SHIFT)
		{
			i0 |= UC(0x800000);
			result = (long long int) i0 << (j0 - IEEE754_FLOAT_SHIFT);
		} else
		{
			uint32_t i = UC(0x007fffff) >> j0;
			
			switch (rm)
			{
			case FE_TOWARDZERO:
				i0 |= UC(0x800000);
				break;
			case FE_DOWNWARD:
				i0 |= UC(0x800000);
				if (sx && (i0 & i) != 0)
					i0 += UC(0x00800000) >> j0;
				break;
			case FE_UPWARD:
				i0 |= UC(0x800000);
				if (!sx && (i0 & i) != 0)
					i0 += UC(0x00800000) >> j0;
				break;
			case FE_TONEAREST:
			default:
				i0 |= UC(0x800000);
				if ((i0 & (i >> 1)) != 0 || (i0 & (UC(0x00800000) >> j0)))
				{
					i0 += UC(0x00400000) >> j0;
				}
				break;
			}
			i0 &= (~i);
			result = i0 >> (IEEE754_FLOAT_SHIFT - j0);
		}
	} else
	{
		/* The number is too large.  It is left implementation defined
		   what happens.  */
		feraiseexcept(FE_INVALID|FE_INEXACT);
		if (j0 == (IEEE754_FLOAT_MAXEXP - IEEE754_FLOAT_BIAS))
		{
			/* inf or nan */
			return LONG_LONG_MIN;
		}
		return (long long int) x;
	}

	return sx ? -result : result;
}

__typeof(__llrintf) llrintf __attribute__((weak, alias("__llrintf")));

#endif

```

`s_llrintl.c`:

```c
#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

#ifndef __NO_LONGLONG

long long int __llrintl(long double x)
{
	int32_t se, j0;
	uint32_t i0, i1;
	long long int result;
	int32_t sx;
	int rm;

	rm = fegetround();

	GET_LDOUBLE_WORDS(se, i0, i1, x);

	sx = se & 0x8000;
	j0 = (se & IEEE854_LONG_DOUBLE_MAXEXP) - IEEE854_LONG_DOUBLE_BIAS;
	/* printf("%08x %08x %d\n", i0, i1, j0); */
	
	if (j0 < 31)
	{
		uint32_t i;
		uint32_t j;

		if (j0 == -IEEE854_LONG_DOUBLE_BIAS)
			return 0;
		/* Raise inexact if x != 0.  */
		if (j0 < 0 || ((i0 & IC(0x7fffffff)) | i1) != 0)
			feraiseexcept(FE_INEXACT);
		if (j0 < 0)
		{
			switch (rm)
			{
				case FE_TOWARDZERO: return 0;
				case FE_DOWNWARD: return sx ? -1 : 0;
				case FE_UPWARD: return sx ? 0 : 1;
			}
			/* case FE_TONEAREST: */
			if (j0 == -1 && ((i0 & IC(0x7fffffff)) | i1) != 0)
				return sx ? -1 : 1;
			return 0;
		}

		i = UC(0x7fffffff) >> j0;
		j = i0;
		switch (rm)
		{
		case FE_TOWARDZERO:
			break;
		case FE_DOWNWARD:
			if (sx && ((i0 & i) | i1) != 0)
			{
				j += UC(0x80000000) >> j0;
				if (j < i0)
				{
					j += j;
					j0++;
				}
			}
			break;
		case FE_UPWARD:
			if (!sx && ((i0 & i) | i1) != 0)
			{
				j += UC(0x80000000) >> j0;
				if (j < i0)
				{
					i = UC(0x7fffffff);
					j += j;
					j0++;
				}
			}
			break;
		case FE_TONEAREST:
		default:
			if ((i0 & (i >> 1)) != 0 || i1 != 0 || (i0 & (UC(0x80000000) >> j0)))
			{
				j += (UC(0x40000000) >> j0);
	
				if (j < i0)
				{
					j += j;
					j0++;
				}
			}
			break;
		}
		i0 = (j & ~i) | IC(0x80000000);
		result = i0 >> (31 - j0);
	} else if (j0 < (int32_t) (8 * sizeof(long long int)) - 1)
	{
		if (j0 >= 63)
		{
			result = (long long int) i0 << (j0 - 31);
			if ((j0 - 63) < 32)
				result |= (unsigned long long int)i1 << (j0 - 63);
		} else
		{
			uint32_t i = UC(0xffffffff) >> (j0 - 31);
			uint32_t j;
			
			switch (rm)
			{
			case FE_TOWARDZERO:
				break;
			case FE_DOWNWARD:
				if (sx && (i1 & i) != 0)
				{
					if (j0 == 31)
						i0 += 1;
					else
					{
						j = i1 + (UC(1) << (63 - j0));
						if (j < i1)
						{
							i0 += 1;		/* got a carry */
							if (i0 == 0)
							{
								i0 = UC(0x80000000);
								j0++;
							}
						}
						i1 = j;
					}
				}
				break;
			case FE_UPWARD:
				if (!sx && (i1 & i) != 0)
				{
					if (j0 == 31)
						i0 += 1;
					else
					{
						j = i1 + (UC(1) << (63 - j0));
						if (j < i1)
						{
							i0 += 1;		/* got a carry */
							if (i0 == 0)
							{
								i0 = UC(0x80000000);
								j0++;
							}
						}
						i1 = j;
					}
				}
				break;
			case FE_TONEAREST:
			default:
				if ((i1 & (i >> 1)) != 0 || (j0 == 32 && (i0 & 1)) || (i1 & (UC(1) << (63 - j0))))
				{
					j = i1 + (UC(1) << (62 - j0));
	
					if (j < i1)
					{
						uint32_t k = i0 + 1;
		
						if (k < i0)
						{
							j += j;
							j0++;
							k |= UC(0x80000000);
						}
						i0 = k;
					}
					i1 = j;
				}
				break;
			}
			i1 &= ~i;
			if (j0 == 31)
				result = (long long int) i0;
			else
				result = ((long long int) i0 << (j0 - 31)) | (i1 >> (63 - j0));
		}
	} else
	{
		/* The number is too large.  It is left implementation defined
		   what happens.  */
		feraiseexcept(FE_INVALID|FE_INEXACT);
		if (j0 == (IEEE854_LONG_DOUBLE_MAXEXP - IEEE854_LONG_DOUBLE_BIAS))
		{
			/* inf or nan */
			return LONG_LONG_MIN;
		}
		return (long long int) x;
	}

	return sx ? -result : result;
}

__typeof(__llrintl) llrintl __attribute__((weak, alias("__llrintl")));

#endif

#endif

```

`s_llround.c`:

```c
/* Round double value to long int.
   Copyright (C) 1997-2013 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONGLONG

long long int __llround(double x)
{
	int32_t j0;
	uint32_t i1, i0;
	long long int result;
	int32_t sign;

	GET_DOUBLE_WORDS(i0, i1, x);
	j0 = ((i0 >> IEEE754_DOUBLE_SHIFT) & IEEE754_DOUBLE_MAXEXP) - IEEE754_DOUBLE_BIAS;
	sign = (i0 & IC(0x80000000)) != 0 ? -1 : 1;
	i0 &= IC(0xfffff);
	i0 |= IC(0x100000);

	if (j0 < IEEE754_DOUBLE_SHIFT)
	{
		if (j0 < 0)
			return j0 < -1 ? 0 : sign;
		else
		{
			i0 += IC(0x80000) >> j0;

			result = i0 >> (IEEE754_DOUBLE_SHIFT - j0);
		}
	} else if (j0 < (int32_t) (8 * sizeof(long long int)) - 1)
	{
		if (j0 >= 52)
		{
			if ((j0 - IEEE754_DOUBLE_SHIFT) >= (int32_t) (8 * sizeof(long long int)))
				result = 0;
			else
				result = (long long int) i0 << (j0 - IEEE754_DOUBLE_SHIFT);
			if ((j0 - 52) < 32)
				result |= (unsigned long long int)i1 << (j0 - 52);
		} else
		{
			uint32_t j = i1 + (UC(0x80000000) >> (j0 - IEEE754_DOUBLE_SHIFT));

			if (j < i1)
				++i0;

			if (j0 == IEEE754_DOUBLE_SHIFT)
				result = (long long int) i0;
			else
				result = ((long long int) i0 << (j0 - IEEE754_DOUBLE_SHIFT)) | (j >> (52 - j0));
		}
	} else
	{
		/* The number is too large.  It is left implementation defined
		   what happens.  */
		return (long long int) x;
	}

	if (sign < 0)
		result = -result;
	return result;
}

__typeof(__llround) llround __attribute__((weak, alias("__llround")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(__llroundl) __llroundl __attribute__((alias("__llround")));
__typeof(__llroundl) llroundl __attribute__((weak, alias("__llround")));
#endif

#endif

```

`s_llroundf.c`:

```c
/* Round double value to long int.
   Copyright (C) 1997-2013 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONGLONG

long long int __llroundf(float x)
{
	int32_t j0;
	uint32_t i;
	long long int result;
	int32_t sign;

	GET_FLOAT_WORD(i, x);
	j0 = ((i >> IEEE754_FLOAT_SHIFT) & IEEE754_FLOAT_MAXEXP) - IEEE754_FLOAT_BIAS;
	sign = (i & IC(0x80000000)) != 0 ? -1 : 1;
	i &= UC(0x7fffff);
	i |= UC(0x800000);

	if (j0 < (int32_t) (8 * sizeof(long long int)) - 1)
	{
		if (j0 < 0)
			return j0 < -1 ? 0 : sign;
		else if (j0 >= IEEE754_FLOAT_SHIFT)
			result = (long long int) i << (j0 - IEEE754_FLOAT_SHIFT);
		else
		{
			i += IC(0x400000) >> j0;

			result = i >> (IEEE754_FLOAT_SHIFT - j0);
		}
	} else
	{
		/* The number is too large.  It is left implementation defined
		   what happens.  */
		return (long long int) x;
	}

	if (sign < 0)
		result = -result;
	return result;
}

__typeof(__llroundf) llroundf __attribute__((weak, alias("__llroundf")));

#endif

```

`s_llroundl.c`:

```c
/* Round double value to long int.
   Copyright (C) 1997-2013 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

#ifndef __NO_LONGLONG

long long int __llroundl(long double x)
{
	int32_t j0;
	uint32_t se, i1, i0;
	long long int result;
	int32_t sign;

	GET_LDOUBLE_WORDS(se, i0, i1, x);
	j0 = (se & IEEE854_LONG_DOUBLE_MAXEXP) - IEEE854_LONG_DOUBLE_BIAS;
	sign = (se & 0x8000) != 0 ? -1 : 1;

	if (j0 < 31)
	{
		if (j0 < 0)
			return j0 < -1 ? 0 : sign;
		else
		{
			uint32_t j = i0 + (UC(0x40000000) >> j0);

			if (j < i0)
			{
				j >>= 1;
				j |= UC(0x80000000);
				++j0;
			}

			result = j >> (31 - j0);
		}
	} else if (j0 < (int32_t) (8 * sizeof(long long int)) - 1)
	{
		if (j0 >= 63)
		{
			result = (long long int) i0 << (j0 - 31);
			if ((j0 - 63) < 32)
				result |= (unsigned long long int)i1 << (j0 - 63);
		} else
		{
			uint32_t j = i1 + (UC(0x80000000) >> (j0 - 31));

			result = (long long int) i0;
			if (j < i1)
				++result;

			if (j0 > 31)
				result = (result << (j0 - 31)) | (j >> (63 - j0));
		}
	} else
	{
		/* The number is too large.  It is left implementation defined
		   what happens.  */
		return (long long int) x;
	}

	if (sign < 0)
		result = -result;
	return result;
}

__typeof(__llroundl) llroundl __attribute__((weak, alias("__llroundl")));

#endif

#endif

```

`s_log1p.c`:

```c
/* @(#)s_log1p.c 1.3 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */
/* Modified by Naohiko Shimizu/Tokai University, Japan 1997/08/25,
   for performance improvement on pipelined processors.
*/

/* double log1p(double x)
 *
 * Method :
 *   1. Argument Reduction: find k and f such that
 *			1+x = 2^k * (1+f),
 *	   where  sqrt(2)/2 < 1+f < sqrt(2) .
 *
 *      Note. If k=0, then f=x is exact. However, if k!=0, then f
 *	may not be representable exactly. In that case, a correction
 *	term is need. Let u=1+x rounded. Let c = (1+x)-u, then
 *	log(1+x) - log(u) ~ c/u. Thus, we proceed to compute log(u),
 *	and add back the correction term c/u.
 *	(Note: when x > 2**53, one can simply return log(x))
 *
 *   2. Approximation of log1p(f).
 *	Let s = f/(2+f) ; based on log(1+f) = log(1+s) - log(1-s)
 *		 = 2s + 2/3 s**3 + 2/5 s**5 + .....,
 *	     = 2s + s*R
 *      We use a special Reme algorithm on [0,0.1716] to generate
 *	a polynomial of degree 14 to approximate R The maximum error
 *	of this polynomial approximation is bounded by 2**-58.45. In
 *	other words,
 *		        2      4      6      8      10      12      14
 *	    R(z) ~ Lp1*s +Lp2*s +Lp3*s +Lp4*s +Lp5*s  +Lp6*s  +Lp7*s
 *  	(the values of Lp1 to Lp7 are listed in the program)
 *	and
 *	    |      2          14          |     -58.45
 *	    | Lp1*s +...+Lp7*s    -  R(z) | <= 2
 *	    |                             |
 *	Note that 2s = f - s*f = f - hfsq + s*hfsq, where hfsq = f*f/2.
 *	In order to guarantee error in log below 1ulp, we compute log
 *	by
 *		log1p(f) = f - (hfsq - s*(hfsq+R)).
 *
 *	3. Finally, log1p(x) = k*ln2 + log1p(f).
 *			     = k*ln2_hi+(f-(hfsq-(s*(hfsq+R)+k*ln2_lo)))
 *	   Here ln2 is split into two floating point number:
 *			ln2_hi + ln2_lo,
 *	   where n*ln2_hi is always exact for |n| < 2000.
 *
 * Special cases:
 *	log1p(x) is NaN with signal if x < -1 (including -INF) ;
 *	log1p(+INF) is +INF; log1p(-1) is -INF with signal;
 *	log1p(NaN) is that NaN with no signal.
 *
 * Accuracy:
 *	according to an error analysis, the error is always less than
 *	1 ulp (unit in the last place).
 *
 * Constants:
 * The hexadecimal values are the intended ones for the following
 * constants. The decimal values may be used, provided that the
 * compiler will convert from decimal to binary accurately enough
 * to produce the hexadecimal values shown.
 *
 * Note: Assuming log() return accurate answer, the following
 *	 algorithm can be used to compute log1p(x) to within a few ULP:
 *
 *		u = 1+x;
 *		if(u==1.0) return x ; else
 *			   return log(u)*(x/(u-1.0));
 *
 *	 See HP-15C Advanced Functions Handbook, p.193.
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_log1p

double __ieee754_log1p(double x)
{
	double hfsq, f, c, s, z, R, u, z2, z4, z6, R1, R2, R3, R4;
	int32_t k, hx, hu, ax;

	static const double ln2_hi = 6.93147180369123816490e-01;	/* 3fe62e42 fee00000 */
	static const double ln2_lo = 1.90821492927058770002e-10;	/* 3dea39ef 35793c76 */
	static const double two54 = 1.80143985094819840000e+16;	/* 43500000 00000000 */
	static const double Lp[] = {
		0.0,
		6.666666666666735130e-01,			/* 3FE55555 55555593 */
		3.999999999940941908e-01,			/* 3FD99999 9997FA04 */
		2.857142874366239149e-01,			/* 3FD24924 94229359 */
		2.222219843214978396e-01,			/* 3FCC71C5 1D8E78AF */
		1.818357216161805012e-01,			/* 3FC74664 96CB03DE */
		1.531383769920937332e-01,			/* 3FC39A09 D078C69F */
		1.479819860511658591e-01			/* 3FC2F112 DF3E5244 */
	};
	static const double zero = 0.0;

	GET_HIGH_WORD(hx, x);
	ax = hx & IC(0x7fffffff);

	k = 1;
	if (hx < IC(0x3FDA827A))
	{									/* x < 0.41422  */
		if (ax >= IC(0x3ff00000))
		{								/* x <= -1.0 */
			if (x == -1.0)
				return -two54 / zero;	/* log1p(-1)=+inf */
			else
				return (x - x) / (x - x);	/* log1p(x<-1)=NaN */
		}
		if (ax < IC(0x3e200000))
		{								/* |x| < 2**-29 */
			math_force_eval(two54 + x);	/* raise inexact */
			if (ax < IC(0x3c900000))	/* |x| < 2**-54 */
				return x;
			else
				return x - x * x * 0.5;
		}
		if (hx > 0 || hx <= IC(0xbfd2bec3))
		{
			k = 0;
			f = x;
			hu = 1;
			c = 0;
		}								/* -0.2929<x<0.41422 */
	} else if (hx >= IC(0x7ff00000))
		return x + x;
	if (k != 0)
	{
		if (hx < IC(0x43400000))
		{
			u = 1.0 + x;
			GET_HIGH_WORD(hu, u);
			k = (hu >> 20) - 1023;
			c = (k > 0) ? 1.0 - (u - x) : x - (u - 1.0);	/* correction term */
			c /= u;
		} else
		{
			u = x;
			GET_HIGH_WORD(hu, u);
			k = (hu >> 20) - 1023;
			c = 0;
		}
		hu &= IC(0x000fffff);
		if (hu < IC(0x6a09e))
		{
			SET_HIGH_WORD(u, hu | IC(0x3ff00000));	/* normalize u */
		} else
		{
			k += 1;
			SET_HIGH_WORD(u, hu | IC(0x3fe00000));	/* normalize u/2 */
			hu = (IC(0x00100000) - hu) >> 2;
		}
		f = u - 1.0;
	}
	hfsq = 0.5 * f * f;
	if (hu == 0)
	{									/* |f| < 2**-20 */
		if (f == zero)
		{
			if (k == 0)
				return zero;
			else
			{
				c += k * ln2_lo;
				return k * ln2_hi + c;
			}
		}
		R = hfsq * (1.0 - 0.66666666666666666 * f);
		if (k == 0)
			return f - R;
		else
			return k * ln2_hi - ((R - (k * ln2_lo + c)) - f);
	}
	s = f / (2.0 + f);
	z = s * s;
#ifdef DO_NOT_USE_THIS
	R = z * (Lp1 + z * (Lp2 + z * (Lp3 + z * (Lp4 + z * (Lp5 + z * (Lp6 + z * Lp7))))));
#else
	R1 = z * Lp[1];
	z2 = z * z;
	R2 = Lp[2] + z * Lp[3];
	z4 = z2 * z2;
	R3 = Lp[4] + z * Lp[5];
	z6 = z4 * z2;
	R4 = Lp[6] + z * Lp[7];
	R = R1 + z2 * R2 + z4 * R3 + z6 * R4;
#endif
	if (k == 0)
		return f - (hfsq - s * (hfsq + R));
	else
		return k * ln2_hi - ((hfsq - (s * (hfsq + R) + (k * ln2_lo + c))) - f);
}

#endif


/* wrapper log1p(x) */
double __log1p(double x)
{
	if (islessequal(x, -1.0) && _LIB_VERSION != _IEEE_)
	{
		if (x == -1.0)
		{
			feraiseexcept(FE_DIVBYZERO);
			return __kernel_standard(x, x, -HUGE_VAL, KMATHERR_LOG_ZERO);	/* log(0) */
		} else
		{
			feraiseexcept(FE_INVALID);
			return __kernel_standard(x, x, __builtin_nan(""), KMATHERR_LOG_MINUS);	/* log(x<0) */
		}
	}

	return __ieee754_log1p(x);
}

__typeof(__log1p) log1p __attribute__((weak, alias("__log1p")));
#ifdef __NO_LONG_DOUBLE_MATH
long double __log1pl(long double x) __attribute__((alias("__log1p")));
__typeof(__log1pl) log1pl __attribute__((weak, alias("__log1p")));
#endif

```

`s_log1pf.c`:

```c
/* s_log1pf.c -- float version of s_log1p.c.
 * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_log1p

float __ieee754_log1pf(float x)
{
	float hfsq, f, c, s, z, R, u;
	int32_t k, hx, hu, ax;

	static const float ln2_hi = 6.9313812256e-01;	/* 0x3f317180 */
	static const float ln2_lo = 9.0580006145e-06;	/* 0x3717f7d1 */
	static const float two25 = 3.355443200e+07;	/* 0x4c000000 */
	static const float Lp1 = 6.6666668653e-01;	/* 3F2AAAAB */
	static const float Lp2 = 4.0000000596e-01;	/* 3ECCCCCD */
	static const float Lp3 = 2.8571429849e-01;	/* 3E924925 */
	static const float Lp4 = 2.2222198546e-01;	/* 3E638E29 */
	static const float Lp5 = 1.8183572590e-01;	/* 3E3A3325 */
	static const float Lp6 = 1.5313838422e-01;	/* 3E1CD04F */
	static const float Lp7 = 1.4798198640e-01;	/* 3E178897 */
	
	static const float zero = 0.0;
	
	GET_FLOAT_WORD(hx, x);
	ax = hx & IC(0x7fffffff);

	k = 1;
	if (hx < IC(0x3ed413d7))
	{									/* x < 0.41422  */
		if (ax >= IC(0x3f800000))
		{								/* x <= -1.0 */
			if (x == 1.0F)
				return -two25 / (x - x);	/* log1p(-1)=+inf */
			else
				return (x - x) / (x - x);	/* log1p(x<-1)=NaN */
		}
		if (ax < IC(0x31000000))
		{								/* |x| < 2**-29 */
			math_force_eval(two25 + x);	/* raise inexact */
			if (ax < IC(0x24800000))	/* |x| < 2**-54 */
				return x;
			else
				return x - x * x * 0.5f;
		}
		if (hx > 0 || hx <= IC(0xbe95f61f))
		{
			k = 0;
			f = x;
			hu = 1;
			c = 0;
		}								/* -0.2929<x<0.41422 */
	}
	if (hx >= IC(0x7f800000))
		return x + x;
	if (k != 0)
	{
		if (hx < IC(0x5a000000))
		{
			u = 1.0f + x;
			GET_FLOAT_WORD(hu, u);
			k = (hu >> 23) - 127;
			/* correction term */
			c = (k > 0) ? 1.0f - (u - x) : x - (u - 1.0f);
			c /= u;
		} else
		{
			u = x;
			GET_FLOAT_WORD(hu, u);
			k = (hu >> 23) - 127;
			c = 0;
		}
		hu &= IC(0x007fffff);
		if (hu < IC(0x3504f7))
		{
			SET_FLOAT_WORD(u, hu | IC(0x3f800000));	/* normalize u */
		} else
		{
			k += 1;
			SET_FLOAT_WORD(u, hu | IC(0x3f000000));	/* normalize u/2 */
			hu = (IC(0x00800000) - hu) >> 2;
		}
		f = u - 1.0f;
	}
	hfsq = 0.5f * f * f;

	if (hu == 0)
	{									/* |f| < 2**-20 */
		if (f == zero)
		{
			if (k == 0)
				return zero;
			else
			{
				c += k * ln2_lo;
				return k * ln2_hi + c;
			}
		}
		R = hfsq * (1.0f - 0.66666666666666666f * f);
		if (k == 0)
			return f - R;
		else
			return k * ln2_hi - ((R - (k * ln2_lo + c)) - f);
	}
	s = f / (2.0f + f);
	z = s * s;
	R = z * (Lp1 + z * (Lp2 + z * (Lp3 + z * (Lp4 + z * (Lp5 + z * (Lp6 + z * Lp7))))));
	if (k == 0)
		return f - (hfsq - s * (hfsq + R));
	else
		return k * ln2_hi - ((hfsq - (s * (hfsq + R) + (k * ln2_lo + c))) - f);
}

#endif

/* wrapper log1p(x) */
float __log1pf(float x)
{
	if (islessequal(x, -1.0) && _LIB_VERSION != _IEEE_)
	{
		if (x == -1.0F)
		{
			feraiseexcept(FE_DIVBYZERO);
			return __kernel_standard_f(x, x, -HUGE_VALF, KMATHERRF_LOG_ZERO);	/* log(0) */
		} else
		{
			feraiseexcept(FE_INVALID);
			return __kernel_standard_f(x, x, __builtin_nanf(""), KMATHERRF_LOG_MINUS);	/* log(x<0) */
		}
	}

	return __ieee754_log1pf(x);
}

__typeof(__log1pf) log1pf __attribute__((weak, alias("__log1pf")));

```

`s_log1pl.c`:

```c
/* Natural logarithm of 1 plus argument.
   Copyright (C) 2011-2013 Free Software Foundation, Inc.

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2.1 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

#ifndef __have_fpu_log1p

long double __ieee754_log1pl(long double x)
{
	if (isnan(x))
		return x;

	if (x < -0.5L || x > 1.0L)
		return __ieee754_logl(1.0L + x);
	/* Here -0.5 <= x <= 1.0.  */

	if (x == 0.0L)
		/* Return a zero with the same sign as x.  */
		return x;

	/* Decompose x into
	   1 + x = (1 + m/256) * (1 + y)
	   where
	   m is an integer, -128 <= m <= 256,
	   y is a number, |y| <= 1/256.
	   y is computed as
	   y = (256 * x - m) / (256 + m).
	   Then
	   log(1+x) = log(m/256) + log(1+y)
	   The first summand is a table lookup.
	   The second summand is computed
	   - either through the power series
	   log(1+y) = y
	   - 1/2 * y^2
	   + 1/3 * y^3
	   - 1/4 * y^4
	   + 1/5 * y^5
	   - 1/6 * y^6
	   + 1/7 * y^7
	   - 1/8 * y^8
	   + 1/9 * y^9
	   - 1/10 * y^10
	   + 1/11 * y^11
	   - 1/12 * y^12
	   + 1/13 * y^13
	   - 1/14 * y^14
	   + 1/15 * y^15
	   - ...
	   - or as log(1+y) = log((1+z)/(1-z)) = 2 * atanh(z)
	   where z = y/(2+y)
	   and atanh(z) is computed through its power series:
	   atanh(z) = z
	   + 1/3 * z^3
	   + 1/5 * z^5
	   + 1/7 * z^7
	   + 1/9 * z^9
	   + 1/11 * z^11
	   + 1/13 * z^13
	   + 1/15 * z^15
	   + ...
	   Since |z| <= 1/511 < 0.002, the relative contribution of the z^15
	   term is < 1/15*0.002^14 < 2^-120 <= 2^-LDBL_MANT_DIG, therefore we
	   can truncate the series after the z^13 term.  */

	{
		long double m = roundl(x * 256.0L);
		long double y = ((x * 256.0L) - m) / (m + 256.0L);
		long double z = y / (2.0L + y);

/* Coefficients of the power series for atanh(z).  */
#define ATANH_COEFF_1  1.0L
#define ATANH_COEFF_3  0.333333333333333333333333333333333333334L
#define ATANH_COEFF_5  0.2L
#define ATANH_COEFF_7  0.142857142857142857142857142857142857143L
#define ATANH_COEFF_9  0.1111111111111111111111111111111111111113L
#define ATANH_COEFF_11 0.090909090909090909090909090909090909091L
#define ATANH_COEFF_13 0.076923076923076923076923076923076923077L
#define ATANH_COEFF_15 0.066666666666666666666666666666666666667L

		long double z2 = z * z;

		long double atanh_z =
			((((((ATANH_COEFF_13
				  * z2 + ATANH_COEFF_11)
				 * z2 + ATANH_COEFF_9)
				* z2 + ATANH_COEFF_7)
			   * z2 + ATANH_COEFF_5)
			  * z2 + ATANH_COEFF_3)
			 * z2 + ATANH_COEFF_1)
			* z;

#undef ATANH_COEFF_1
#undef ATANH_COEFF_3
#undef ATANH_COEFF_5
#undef ATANH_COEFF_7
#undef ATANH_COEFF_9
#undef ATANH_COEFF_11
#undef ATANH_COEFF_13
#undef ATANH_COEFF_15

		/* logl_table[i] = log((i + 128) / 256).
		   Computed in GNU clisp through
		   (setf (long-float-digits) 128)
		   (setq a 0L0)
		   (setf (long-float-digits) 256)
		   (dotimes (i 385)
		   (format t "        ~D,~%"
		   (float (log (* (/ (+ i 128) 256) 1L0)) a)))  */
		static const long double logl_table[385] = {
			-0.693147180559945309417232121458176568075L,
			-0.6853650401178903604697692213970398044L,
			-0.677642994023980055266378075415729732197L,
			-0.669980121278410931188432960495886651496L,
			-0.662375521893191621046203913861404403985L,
			-0.65482831625780871022347679633437927773L,
			-0.647337644528651106250552853843513225963L,
			-0.639902666041133026551361927671647791137L,
			-0.632522558743510466836625989417756304788L,
			-0.625196518651437560022666843685547154042L,
			-0.617923759322357783718626781474514153438L,
			-0.61070351134887071814907205278986876216L,
			-0.60353502187025817679728065207969203929L,
			-0.59641755410139419712166106497071313106L,
			-0.58935038687830174459117031769420187977L,
			-0.582332814219655195222425952134964639978L,
			-0.575364144903561854878438011987654863008L,
			-0.568443702058988073553825606077313299585L,
			-0.561570822771226036828515992768693405624L,
			-0.554744857700826173731906247856527380683L,
			-0.547965170715447412135297057717612244552L,
			-0.541231138534103334345428696561292056747L,
			-0.534542150383306725323860946832334992828L,
			-0.527897607664638146541620672180936254347L,
			-0.52129692363328608707713317540302930314L,
			-0.514739523087127012297831879947234599722L,
			-0.50822484206593331675332852879892694707L,
			-0.50175232756031585480793331389686769463L,
			-0.495321437230025429054660050261215099L,
			-0.488931639131254417913411735261937295862L,
			-0.482582411452595671747679308725825054355L,
			-0.476273242259330949798142595713829069596L,
			-0.470003629245735553650937031148342064701L,
			-0.463773079495099479425751396412036696525L,
			-0.457581109247178400339643902517133157939L,
			-0.451427243672800141272924605544662667972L,
			-0.445311016655364052636629355711651820077L,
			-0.43923197057898186527990882355156990061L,
			-0.4331896561230192424451526269158655235L,
			-0.427183632062807368078106194920633178807L,
			-0.421213465076303550585562626925177406092L,
			-0.415278729556489003230882088534775334993L,
			-0.409379007429300711070330899107921801414L,
			-0.403513887976902632538339065932507598071L,
			-0.397682967666109433030550215403212372894L,
			-0.391885849981783528404356583224421075418L,
			-0.386122145265033447342107580922798666387L,
			-0.380391470556048421030985561769857535915L,
			-0.374693449441410693606984907867576972481L,
			-0.369027711905733333326561361023189215893L,
			-0.363393894187477327602809309537386757124L,
			-0.357791638638807479160052541644010369001L,
			-0.352220593589352099112142921677820359633L,
			-0.346680413213736728498769933032403617363L,
			-0.341170757402767124761784665198737642087L,
			-0.33569129163814153519122263131727209364L,
			-0.330241686870576856279407775480686721935L,
			-0.324821619401237656369001967407777741178L,
			-0.31943077076636122859621528874235306143L,
			-0.314068827624975851026378775827156709194L,
			-0.308735481649613269682442058976885699557L,
			-0.303430429419920096046768517454655701024L,
			-0.298153372319076331310838085093194799765L,
			-0.292904016432932602487907019463045397996L,
			-0.287682072451780927439219005993827431504L,
			-0.282487255574676923482925918282353780414L,
			-0.277319285416234343803903228503274262719L,
			-0.272177885915815673288364959951380595626L,
			-0.267062785249045246292687241862699949179L,
			-0.261973715741573968558059642502581569596L,
			-0.256910413785027239068190798397055267412L,
			-0.251872619755070079927735679796875342712L,
			-0.2468600779315257978846419408385075613265L,
			-0.24187253642048672427253973837916408939L,
			-0.2369097470783577150364265832942468196375L,
			-0.2319714654377751430492321958603212094726L,
			-0.2270574506353460848586128739534071682175L,
			-0.222167465341154296870334265401817316702L,
			-0.2173012756899813951520225351537951559L,
			-0.212458651214193401740613666010165016867L,
			-0.2076393647782445016154410442673876674964L,
			-0.202843192514751471266885961812429707545L,
			-0.1980699137620937948192675366153429027185L,
			-0.193319311003495979595900706211132426563L,
			-0.188591169807550022358923589720001638093L,
			-0.183885278770137362613157202229852743197L,
			-0.179201429457710992616226033183958974965L,
			-0.174539416351899677264255125093377869519L,
			-0.169899036795397472900424896523305726435L,
			-0.165280090939102924303339903679875604517L,
			-0.160682381690473465543308397998034325468L,
			-0.156105714663061654850502877304344269052L,
			-0.1515498981272009378406898175577424691056L,
			-0.1470147429618096590348349122269674042104L,
			-0.142500062607283030157283942253263107981L,
			-0.1380056730194437167017517619422725179055L,
			-0.1335313926245226231463436209313499745895L,
			-0.129077042275142343345847831367985856258L,
			-0.124642445207276597338493356591214304499L,
			-0.1202274269981598003244753948319154994493L,
			-0.115831815525121705099120059938680166568L,
			-0.1114554409253228268966213677328042273655L,
			-0.1070981355563671005131126851708522185606L,
			-0.1027597339577689347753154133345778104976L,
			-0.098440072813252519902888574928971234883L,
			-0.094138990913861910035632096996525066015L,
			-0.0898563291218610470766469347968659624282L,
			-0.0855919303354035139161469686670511961825L,
			-0.0813456394539524058873423550293617843895L,
			-0.077117303344431289769666193261475917783L,
			-0.072906770808087780565737488890929711303L,
			-0.0687138925480518083746933774035034481663L,
			-0.064538521137571171672923915683992928129L,
			-0.0603805109889074798714456529545968095868L,
			-0.0562397183228760777967376942769773768851L,
			-0.0521160011390140183616307870527840213665L,
			-0.0480092191863606077520036253234446621373L,
			-0.0439192339348354905263921515528654458042L,
			-0.0398459085471996706586162402473026835046L,
			-0.0357891078515852792753420982122404025613L,
			-0.0317486983145803011569962827485256299276L,
			-0.0277245480148548604671395114515163869272L,
			-0.0237165266173160421183468505286730579517L,
			-0.0197245053477785891192717326571593033246L,
			-0.015748356968139168607549511460828269521L,
			-0.0117879557520422404691605618900871263399L,
			-0.0078431774610258928731840424909435816546L,
			-0.00391389932113632909231778364357266484272L,
			0.0L,
			0.00389864041565732301393734309584290701073L,
			0.00778214044205494894746290006113676367813L,
			0.01165061721997527413559144280921434893315L,
			0.0155041865359652541508540460424468358779L,
			0.01934296284313093463590553454155047018545L,
			0.0231670592815343782287991609622899165794L,
			0.0269765876982020757480692925396595457815L,
			0.0307716586667536883710282075967721640917L,
			0.0345523815066597334073715005898328652816L,
			0.038318864302136599193755325123797290346L,
			0.042071213920687054375203805926962379448L,
			0.045809536031294203166679267614663342114L,
			0.049533935122276630882096208829824573267L,
			0.0532445145188122828658701937865287769396L,
			0.0569413764001384247590131015404494943015L,
			0.0606246218164348425806061320404202632862L,
			0.0642943507053972572162284502656114944857L,
			0.0679506619085077493945652777726294140346L,
			0.071593653187008817925605272752092034269L,
			0.075223421237587525698605339983662414637L,
			0.078840061707776024531540577859198294559L,
			0.082443669211074591268160068668307805914L,
			0.086034337341803153381797826721996075141L,
			0.0896121586896871326199514693784845287854L,
			0.093177224854183289768781353027759396216L,
			0.096729626458551112295571056487463437015L,
			0.1002694531636751493081301751297276601964L,
			0.1037967936816435648260618037639746883066L,
			0.1073117357890880506671750303711543368066L,
			0.1108143663402901141948061693232119280986L,
			0.1143047712800586336342591448151747734094L,
			0.1177830356563834545387941094705217050686L,
			0.1212492436328696851612122640808405265723L,
			0.1247034785009572358634065153808632684918L,
			0.128145822691930038174109886961074873852L,
			0.1315763577887192725887161286894831624516L,
			0.134995164537504830601983291147085645626L,
			0.138402322859119135685325873601649187393L,
			0.1417979118602573498789527352804727189846L,
			0.1451820098444978972819350637405643235226L,
			0.1485546943231371429098223170672938691604L,
			0.151916042025841975071803424896884511328L,
			0.1552661289111239515223833017101021786436L,
			0.1586050301766385840933711746258415752456L,
			0.161932820269313253240338285123614220592L,
			0.165249572895307162875611449277240313729L,
			0.1685553610298066669415865321701023169345L,
			0.171850256926659222340098946055147264935L,
			0.1751343321278491480142914649863898412374L,
			0.1784076574728182971194002415109419683545L,
			0.181670303107634678260605595617079739242L,
			0.184922338494011992663903592659249621006L,
			0.1881638324181829868259905803105539806714L,
			0.191394852999629454609298807561308873447L,
			0.194615467699671658858138593767269731516L,
			0.1978257433299198803625720711969614690756L,
			0.201025746060590741340908337591797808969L,
			0.204215541428690891503820386196239272214L,
			0.2073951943460705871587455788490062338536L,
			0.210564769107349637669552812732351513721L,
			0.2137243293977181388619051976331987647734L,
			0.216873938300614359619089525744347498479L,
			0.220013658305282095907358638661628360712L,
			0.2231435513142097557662950903098345033745L,
			0.226263678650453389361787082280390161607L,
			0.229374101064845829991480725046139871551L,
			0.232474878743094064920705078095567528222L,
			0.235566071312766909077588218941043410137L,
			0.2386477378501750099171491363522813392526L,
			0.241719936887145168144307515913513900104L,
			0.244782726417690916434704717466314811104L,
			0.247836163904581256780602765746524747999L,
			0.25088030628580941658844644154994089393L,
			0.253915209980963444137323297906606667466L,
			0.256940930897500425446759867911224262093L,
			0.259957524436926066972079494542311044577L,
			0.26296504550088135182072917321108602859L,
			0.265963548497137941339125926537543389269L,
			0.268953087345503958932974357924497845489L,
			0.271933715483641758831669494532999161983L,
			0.274905485872799249167009582983018668293L,
			0.277868451003456306186350032923401233082L,
			0.280822662900887784639519758873134832073L,
			0.28376817313064459834690122235025476666L,
			0.286705032803954314653250930842073965668L,
			0.289633292583042676878893055525668970004L,
			0.292553002686377439978201258664126644308L,
			0.295464212893835876386681906054964195182L,
			0.298366972551797281464900430293496918012L,
			0.301261330578161781012875538233755492657L,
			0.304147335467296717015819874720446989991L,
			0.30702503529491186207512454053537790169L,
			0.309894477722864687861624550833227164546L,
			0.31275571000389688838624655968831903216L,
			0.315608778986303334901366180667483174144L,
			0.318453731118534615810247213590599595595L,
			0.321290612453734292057863145522557457887L,
			0.324119468654211976090670760434987352183L,
			0.326940344995853320592356894073809191681L,
			0.329753286372467981814422811920789810952L,
			0.332558337300076601412275626573419425269L,
			0.335355541921137830257179579814166199074L,
			0.338144944008716397710235913939267433111L,
			0.340926586970593210305089199780356208443L,
			0.34370051385331844468019789211029452987L,
			0.346466767346208580918462188425772950712L,
			0.349225389785288304181275421187371759687L,
			0.35197642315717818465544745625943892599L,
			0.354719909102929028355011218999317665826L,
			0.357455888921803774226009490140904474434L,
			0.360184403575007796281574967493016620926L,
			0.362905493689368453137824345977489846141L,
			0.365619199560964711319396875217046453067L,
			0.368325561158707653048230154050398826898L,
			0.371024618127872663911964910806824955394L,
			0.373716409793584080821016832715823506644L,
			0.376400975164253065997877633436251593315L,
			0.379078352934969458390853345631019858882L,
			0.38174858149084833985966626493567607862L,
			0.384411698910332039734790062481290868519L,
			0.387067742968448287898902502261817665695L,
			0.38971675114002521337046360400352086705L,
			0.392358760602863872479379611988215363485L,
			0.39499380824086897810639403636498176831L,
			0.397621930647138489104829072973405554918L,
			0.40024316412701270692932510199513117008L,
			0.402857544701083514655197565487057707577L,
			0.405465108108164381978013115464349136572L,
			0.408065889808221748430198682969084124381L,
			0.410659924985268385934306203175822787661L,
			0.41324724855021933092547601552548590025L,
			0.415827895143710965613328892954902305356L,
			0.418401899138883817510763261966760106515L,
			0.42096929464412963612886716150679597245L,
			0.423530115505803295718430478017910109426L,
			0.426084395310900063124544879595476618897L,
			0.428632167389698760206812276426639053152L,
			0.43117346481837134085917247895559499848L,
			0.433708320421559393435847903042186017095L,
			0.436236766774918070349041323061121300663L,
			0.438758836207627937745575058511446738878L,
			0.441274560804875229489496441661301225362L,
			0.443783972410300981171768440588146426918L,
			0.446287102628419511532590180619669006749L,
			0.448783982827006710512822115683937186274L,
			0.451274644139458585144692383079012478686L,
			0.453759117467120506644794794442263270651L,
			0.456237433481587594380805538163929748437L,
			0.458709622626976664843883309250877913511L,
			0.461175715122170166367999925597855358603L,
			0.463635740963032513092182277331163919118L,
			0.466089729924599224558619247504769399859L,
			0.468537711563239270375665237462973542708L,
			0.470979715218791012546897856056359251373L,
			0.473415770016672131372578393236978550606L,
			0.475845904869963914265209586304381412175L,
			0.478270148481470280383546145497464809096L,
			0.480688529345751907676618455448011551209L,
			0.48310107575113582273837458485214554795L,
			0.485507815781700807801791077190788900579L,
			0.487908777319238973246173184132656942487L,
			0.490303988045193838150346159645746860531L,
			0.492693475442575255695076950020077845328L,
			0.495077266797851514597964584842833665358L,
			0.497455389202818942250859256731684928918L,
			0.499827869556449329821331415247044141512L,
			0.502194734566715494273584171951812573586L,
			0.504556010752395287058308531738174929982L,
			0.506911724444854354113196312660089270034L,
			0.509261901789807946804074919228323824878L,
			0.51160656874906207851888487520338193135L,
			0.51394575110223431680100608827421759311L,
			0.51627947444845449617281928478756106467L,
			0.518607764208045632152976996364798698556L,
			0.520930645624185312409809834659637709188L,
			0.52324814376454783651680722493487084164L,
			0.525560283522927371382427602307131424923L,
			0.527867089620842385113892217778300963557L,
			0.530168586609121617841419630845212405063L,
			0.532464798869471843873923723460142242606L,
			0.534755750616027675477923292032637111077L,
			0.537041465896883654566729244153832299024L,
			0.539321968595608874655355158077341155752L,
			0.54159728243274437157654230390043409897L,
			0.543867430967283517663338989065998323965L,
			0.546132437598135650382397209231209163864L,
			0.548392325565573162748150286179863158565L,
			0.550647117952662279259948179204913460093L,
			0.552896837686677737580717902230624314327L,
			0.55514150754050159271548035951590405017L,
			0.557381150134006357049816540361233647898L,
			0.559615787935422686270888500526826593487L,
			0.561845443262691817915664819160697456814L,
			0.564070138284802966071384290090190711817L,
			0.566289895023115872590849979337124343595L,
			0.568504735352668712078738764866962263577L,
			0.5707146810034715448536245647415894503L,
			0.572919753561785509092756726626261068625L,
			0.575119974471387940421742546569273429365L,
			0.577315365034823604318112061519496401506L,
			0.579505946414642223855274409488070989814L,
			0.58169173963462248252061075372537234071L,
			0.583872765580982679097413356975291104927L,
			0.586049045003578208904119436287324349516L,
			0.588220598517086043034868221609113995052L,
			0.590387446602176374641916708123598757576L,
			0.59254960960667159874199020959329739696L,
			0.594707107746692789514343546529205333192L,
			0.59685996110779383658731192302565801002L,
			0.59900818964608339938160002446165150206L,
			0.601151813189334836191674317068856441547L,
			0.603290851438084262340585186661310605647L,
			0.6054253239667168894375677681414899356L,
			0.607555250224541795501085152791125371894L,
			0.609680649536855273481833501660588408785L,
			0.611801541105992903529889766428814783686L,
			0.613917944012370492196929119645563790777L,
			0.616029877215514019647565928196700650293L,
			0.618137359555078733872689126674816271683L,
			0.620240409751857528851494632567246856773L,
			0.62233904640877874159710264120869663505L,
			0.62443328801189350104253874405467311991L,
			0.626523152931352759778820859734204069282L,
			0.628608659422374137744308205774183639946L,
			0.6306898256261987050837261409313532241L,
			0.63276666957103782954578646850357975849L,
			0.634839209173010211969493840510489008123L,
			0.63690746223706923162049442718119919119L,
			0.63897144645792072137962398326473680873L,
			0.64103117942093129105560133440539254671L,
			0.643086678603027315392053859585132960477L,
			0.645137961373584701665228496134731905937L,
			0.647185044995309550122320631377863036675L,
			0.64922794662510981889083996990531112227L,
			0.651266683314958103396333353349672108398L,
			0.653301272012745638758615881210873884572L,
			0.65533172956312763209494967856962559648L,
			0.657358072708360030141890023245936165513L,
			0.659380318089127826115336413370955804038L,
			0.661398482245365008260235838709650938148L,
			0.66341258161706625109695030429080128179L,
			0.665422632545090448950092610006660181147L,
			0.667428651271956189947234166318980478403L,
			0.669430653942629267298885270929503510123L,
			0.67142865660530232331713904200189252584L,
			0.67342267521216672029796038880101726475L,
			0.67541272562017673108090414397019748722L,
			0.677398823591806140809682609997348298556L,
			0.67938098479579735014710062847376425181L,
			0.681359224807903068948071559568089441735L,
			0.683333559111620688164363148387750369654L,
			0.68530400309891941654404807896723298642L,
			0.687270572070960267497006884394346103924L,
			0.689233281238808980324914337814603903233L,
			0.691192145724141958859604629216309755938L,
			0.693147180559945309417232121458176568075L
		};
		int mi = (int) m;
		return logl_table[128 + mi] + 2.0L * atanh_z;
	}
}

#endif

/* wrapper log1pl(x) */
long double __log1pl(long double  x)
{
	if (islessequal(x, -1.0) && _LIB_VERSION != _IEEE_)
	{
		if (x == -1.0)
		{
			feraiseexcept(FE_DIVBYZERO);
			return __kernel_standard_l(x, x, -HUGE_VALL, KMATHERRL_LOG_ZERO);	/* log(0) */
		} else
		{
			feraiseexcept(FE_INVALID);
			return __kernel_standard_l(x, x, __builtin_nanl(""), KMATHERRL_LOG_MINUS);	/* log(x<0) */
		}
	}

	return __ieee754_log1pl(x);
}

__typeof(__log1pl) log1pl __attribute__((weak, alias("__log1pl")));

#endif

```

`s_logb.c`:

```c
/* @(#)s_logb.c 1.3 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/*
 * double logb(x)
 * IEEE 754 logb. Included to pass IEEE test suite. Not recommend.
 * Use ilogb instead.
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif


double __logb(double x)
{
	int32_t lx, ix, rix;

	GET_DOUBLE_WORDS(ix, lx, x);
	ix &= IC(0x7fffffff);					/* high |x| */
	if ((ix | lx) == 0)
		return -1.0 / __ieee754_fabs(x);
	if (ix >= IC(0x7ff00000))
		return x * x;
	if ((rix = ix >> IEEE754_DOUBLE_SHIFT) == 0)
	{
		/* POSIX specifies that denormal number is treated as
		   though it were normalized.  */
		int32_t ma;

		if (ix == 0)
			ma = count_leading_zeros(lx) + 32;
		else
			ma = count_leading_zeros(ix);
		rix -= ma - 12;
	}
	return (double) (rix - IEEE754_DOUBLE_BIAS);
}

__typeof(__logb) logb __attribute__((weak, alias("__logb")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(__logbl) __logbl __attribute__((alias("__logb")));
__typeof(__logbl) logbl __attribute__((weak, alias("__logb")));
#endif

```

`s_logbf.c`:

```c
/* s_logbf.c -- float version of s_logb.c.
 * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

float __logbf(float x)
{
	int32_t ix, rix;

	GET_FLOAT_WORD(ix, x);
	ix &= IC(0x7fffffff);					/* high |x| */
	if (ix == 0)
		return (float) -1.0 / __ieee754_fabsf(x);
	if (ix >= IC(0x7f800000))
		return x * x;
	if ((rix = ix >> IEEE754_FLOAT_SHIFT) == 0)
	{
		/* POSIX specifies that denormal number is treated as
		   though it were normalized.  */
		rix -= count_leading_zeros(ix) - 9;
	}
	return (float) (rix - IEEE754_FLOAT_BIAS);
}

__typeof(__logbf) logbf __attribute__((weak, alias("__logbf")));

```

`s_logbl.c`:

```c
/* s_logbl.c -- long double version of s_logb.c.
 * Conversion to long double by Ulrich Drepper,
 * Cygnus Support, drepper@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/*
 * long double logbl(x)
 * IEEE 754 logb. Included to pass IEEE test suite. Not recommend.
 * Use ilogb instead.
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

long double __logbl(long double x)
{
	int32_t es, lx, ix;

	GET_LDOUBLE_WORDS(es, ix, lx, x);
	es &= IEEE854_LONG_DOUBLE_MAXEXP;						/* exponent */
	if ((es | ix | lx) == 0)
		return -1.0 / __ieee754_fabsl(x);
	if (es == IEEE854_LONG_DOUBLE_MAXEXP)
		return x * x;
	if (es == 0)						/* IEEE 754 logb */
	{
		/* POSIX specifies that denormal number is treated as
		   though it were normalized.  */
		int32_t ma;

		if (ix == 0)
			ma = count_leading_zeros(lx) + 32;
		else
			ma = count_leading_zeros(ix);
		es -= ma - 1;
	}
	return (long double) (es - IEEE854_LONG_DOUBLE_BIAS);
}

__typeof(__logbl) logbl __attribute__((weak, alias("__logbl")));

#endif

```

`s_lrint.c`:

```c
#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_lrint

long int __ieee754_lrint(double x)
{
	int32_t j0;
	uint32_t i0, i1;
	long int result;
	int32_t sx;
	int rm;
	
	rm = fegetround();

	GET_DOUBLE_WORDS(i0, i1, x);
	j0 = ((i0 >> IEEE754_DOUBLE_SHIFT) & IEEE754_DOUBLE_MAXEXP) - IEEE754_DOUBLE_BIAS;
	sx = i0 & IC(0x80000000);
	i0 &= UC(0xfffff);
	
	if (j0 < IEEE754_DOUBLE_SHIFT)
	{
		uint32_t i;
		
		if (j0 == -IEEE754_DOUBLE_BIAS)
			return 0;
		/* Raise inexact if x != 0.  */
		if (j0 < 0 || (i0 | i1) != 0)
			feraiseexcept(FE_INEXACT);
		if (j0 < 0)
		{
			switch (rm)
			{
				case FE_TOWARDZERO: return 0;
				case FE_DOWNWARD: return sx ? -1 : 0;
				case FE_UPWARD: return sx ? 0 : 1;
			}
			/* case FE_TONEAREST: */
			if (j0 == -1 && (i0 | i1) != 0)
				return sx ? -1 : 1;
			return 0;
		}

		switch (rm)
		{
		case FE_TOWARDZERO:
			i0 |= UC(0x100000);
			break;
		case FE_DOWNWARD:
			i = UC(0x000fffff) >> j0;
			i0 |= UC(0x100000);
			if (sx && ((i0 & i) | i1) != 0)
				i0 += UC(0x00100000) >> j0;
			break;
		case FE_UPWARD:
			i = UC(0x000fffff) >> j0;
			i0 |= UC(0x100000);
			if (!sx && ((i0 & i) | i1) != 0)
				i0 += IC(0x00100000) >> j0;
			break;
		case FE_TONEAREST:
		default:
			i = UC(0x000fffff) >> j0;
			i0 |= UC(0x100000);
			if ((i0 & (i >> 1)) != 0 || i1 != 0 || (i0 & (UC(0x00100000) >> j0)))
			{
				i0 += UC(0x00080000) >> j0;
			}
			break;
		}
		result = i0 >> (IEEE754_DOUBLE_SHIFT - j0);
	} else if (j0 < (int32_t) (8 * sizeof(long int)) - 1)
	{
		if (j0 >= 52)
		{
			i0 |= UC(0x100000);
			if ((j0 - IEEE754_DOUBLE_SHIFT) >= (int32_t) (8 * sizeof(long int)))
				result = 0;
			else
				result = (long int) i0 << (j0 - IEEE754_DOUBLE_SHIFT);
			if ((j0 - 52) < 32)
				result |= (unsigned long int)i1 << (j0 - 52);
		} else
		{
			uint32_t i = UC(0xffffffff) >> (j0 - IEEE754_DOUBLE_SHIFT);
			uint32_t j;
		
			switch (rm)
			{
			case FE_TOWARDZERO:
				i0 |= UC(0x100000);
				break;
			case FE_DOWNWARD:
				i0 |= UC(0x100000);
				if (sx && (i1 & i) != 0)
				{
					if (j0 == IEEE754_DOUBLE_SHIFT)
						i0 += 1;
					else
					{
						j = i1 + (UC(1) << (52 - j0));
						if (j < i1)
							i0 += 1;			/* got a carry */
						i1 = j;
					}
				}
				break;
			case FE_UPWARD:
				i0 |= UC(0x100000);
				if (!sx && (i1 & i) != 0)
				{
					if (j0 == IEEE754_DOUBLE_SHIFT)
						i0 += 1;
					else
					{
						j = i1 + (UC(1) << (52 - j0));
						if (j < i1)
							i0 += 1;			/* got a carry */
						i1 = j;
					}
				}
				break;
			case FE_TONEAREST:
			default:
				i0 |= UC(0x100000);
				if ((i1 & (i >> 1)) != 0 || (j0 == IEEE754_DOUBLE_SHIFT && (i0 & 1)) || (i1 & (UC(1) << (52 - j0))))
				{
					j = i1 + (UC(1) << (51 - j0));
					if (j < i1)
						i0 += 1;
					i1 = j;
				}
				break;
			}
			i1 &= ~i;
			if (j0 == IEEE754_DOUBLE_SHIFT)
				result = (long int) i0;
			else
				result = ((long int) i0 << (j0 - IEEE754_DOUBLE_SHIFT)) | (i1 >> (52 - j0));
		}
	} else
	{
		/* The number is too large.  It is left implementation defined
		   what happens.  */
		feraiseexcept(FE_INVALID|FE_INEXACT);
		if (j0 == (IEEE754_DOUBLE_MAXEXP - IEEE754_DOUBLE_BIAS))
		{
			/* inf or nan */
			return LONG_MIN;
		}
		return (long int) x;
	}

	return sx ? -result : result;
}

#endif

long int __lrint(double x)
{
	return __ieee754_lrint(x);
}


__typeof(__lrint) lrint __attribute__((weak, alias("__lrint")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(lrintl) __lrintl __attribute__((alias("__lrint")));
__typeof(__lrintl) lrintl __attribute__((weak, alias("__lrint")));
#endif

```

`s_lrintf.c`:

```c
#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_lrint

long int __ieee754_lrintf(float x)
{
	int32_t j0;
	uint32_t i0;
	long int result;
	int32_t sx;
	int rm;

	rm = fegetround();

	GET_FLOAT_WORD(i0, x);

	sx = i0 & IC(0x80000000);
	j0 = ((i0 >> IEEE754_FLOAT_SHIFT) & IEEE754_FLOAT_MAXEXP) - IEEE754_FLOAT_BIAS;
	i0 &= UC(0x7fffff);

	if (j0 < (int32_t) (sizeof(long int) * 8) - 1)
	{
		if (j0 == -IEEE754_FLOAT_BIAS)
			return 0;
		/* Raise inexact if x != 0.  */
		if (j0 < 0 || i0 != 0)
			feraiseexcept(FE_INEXACT);

		if (j0 < 0)
		{
			switch (rm)
			{
				case FE_TOWARDZERO: return 0;
				case FE_DOWNWARD: return sx ? -1 : 0;
				case FE_UPWARD: return sx ? 0 : 1;
			}
			/* case FE_TONEAREST: */
			if (j0 == -1 && i0 != 0)
				return sx ? -1 : 1;
			return 0;
		}

		if (j0 >= IEEE754_FLOAT_SHIFT)
		{
			i0 |= UC(0x800000);
			result = (long int) i0 << (j0 - IEEE754_FLOAT_SHIFT);
		} else
		{
			uint32_t i = UC(0x007fffff) >> j0;
			
			switch (rm)
			{
			case FE_TOWARDZERO:
				i0 |= UC(0x800000);
				break;
			case FE_DOWNWARD:
				i0 |= UC(0x800000);
				if (sx && (i0 & i) != 0)
					i0 += UC(0x00800000) >> j0;
				break;
			case FE_UPWARD:
				i0 |= UC(0x800000);
				if (!sx && (i0 & i) != 0)
					i0 += UC(0x00800000) >> j0;
				break;
			case FE_TONEAREST:
			default:
				i0 |= UC(0x800000);
				if ((i0 & (i >> 1)) != 0 || (i0 & (UC(0x00800000) >> j0)))
				{
					i0 += UC(0x00400000) >> j0;
				}
				break;
			}
			i0 &= (~i);
			result = i0 >> (IEEE754_FLOAT_SHIFT - j0);
		}
	} else
	{
		/* The number is too large.  It is left implementation defined
		   what happens.  */
		feraiseexcept(FE_INVALID|FE_INEXACT);
		if (j0 == (IEEE754_FLOAT_MAXEXP - IEEE754_FLOAT_BIAS))
		{
			/* inf or nan */
			return LONG_MIN;
		}
		return (long int) x;
	}

	return sx ? -result : result;
}

#endif

long int __lrintf(float x)
{
	return __ieee754_lrintf(x);
}

__typeof(__lrintf) lrintf __attribute__((weak, alias("__lrintf")));

```

`s_lrintl.c`:

```c
#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

#ifndef __have_fpu_lrint

long int __ieee754_lrintl(long double x)
{
	int32_t se, j0;
	uint32_t i0, i1;
	long int result;
	int32_t sx;
	int rm;

	rm = fegetround();

	GET_LDOUBLE_WORDS(se, i0, i1, x);

	sx = se & 0x8000;
	j0 = (se & IEEE854_LONG_DOUBLE_MAXEXP) - IEEE854_LONG_DOUBLE_BIAS;

	if (j0 < 31)
	{
		uint32_t i;
		uint32_t j;

		if (j0 == -IEEE854_LONG_DOUBLE_BIAS)
			return 0;
		/* Raise inexact if x != 0.  */
		if (j0 < 0 || ((i0 & IC(0x7fffffff)) | i1) != 0)
			feraiseexcept(FE_INEXACT);
		if (j0 < 0)
		{
			switch (rm)
			{
				case FE_TOWARDZERO: return 0;
				case FE_DOWNWARD: return sx ? -1 : 0;
				case FE_UPWARD: return sx ? 0 : 1;
			}
			/* case FE_TONEAREST: */
			if (j0 == -1 && ((i0 & IC(0x7fffffff)) | i1) != 0)
				return sx ? -1 : 1;
			return 0;
		}

		i = UC(0x7fffffff) >> j0;
		j = i0;
		switch (rm)
		{
		case FE_TOWARDZERO:
			break;
		case FE_DOWNWARD:
			if (sx && ((i0 & i) | i1) != 0)
			{
				j += UC(0x80000000) >> j0;
				if (j < i0)
				{
					i = UC(0x7fffffff);
					j += j;
					j0++;
				}
			}
			break;
		case FE_UPWARD:
			if (!sx && ((i0 & i) | i1) != 0)
			{
				j += UC(0x80000000) >> j0;
				if (j < i0)
				{
					i = UC(0x7fffffff);
					j += j;
					j0++;
				}
			}
			break;
		case FE_TONEAREST:
		default:
			if ((i0 & (i >> 1)) != 0 || i1 != 0 || (i0 & (UC(0x80000000) >> j0)))
			{
				j += (UC(0x40000000) >> j0);
	
				if (j < i0)
				{
					j += j;
					j0++;
				}
			}
			break;
		}
		i0 = (j & ~i) | IC(0x80000000);
		result = i0 >> (31 - j0);
	} else if (j0 < (int32_t) (8 * sizeof(long int)) - 1)
	{
		if (j0 >= 63)
		{
			result = (long int) i0 << (j0 - 31);
			if ((j0 - 63) < 32)
				result |= (unsigned long int)i1 << (j0 - 63);
		} else
		{
			uint32_t i = UC(0xffffffff) >> (j0 - 31);
			uint32_t j;
			
			switch (rm)
			{
			case FE_TOWARDZERO:
				break;
			case FE_DOWNWARD:
				if (sx && (i1 & i) != 0)
				{
					if (j0 == 31)
						i0 += 1;
					else
					{
						j = i1 + (UC(1) << (63 - j0));
						if (j < i1)
						{
							i0 += 1;		/* got a carry */
							if (i0 == 0)
							{
								i0 = UC(0x80000000);
								j0++;
							}
						}
						i1 = j;
					}
				}
				break;
			case FE_UPWARD:
				if (!sx && (i1 & i) != 0)
				{
					if (j0 == 31)
						i0 += 1;
					else
					{
						j = i1 + (UC(1) << (63 - j0));
						if (j < i1)
						{
							i0 += 1;		/* got a carry */
							if (i0 == 0)
							{
								i0 = UC(0x80000000);
								j0++;
							}
						}
						i1 = j;
					}
				}
				break;
			case FE_TONEAREST:
			default:
				if ((i1 & (i >> 1)) != 0 || (j0 == 32 && (i0 & 1)) || (i1 & (UC(1) << (63 - j0))))
				{
					j = i1 + (UC(1) << (62 - j0));
	
					if (j < i1)
					{
						uint32_t k = i0 + 1;
		
						if (k < i0)
						{
							j += j;
							j0++;
							k |= UC(0x80000000);
						}
						i0 = k;
					}
					i1 = j;
				}
				break;
			}
			i1 &= ~i;
			if (j0 == 31)
				result = (long int) i0;
			else
				result = ((long int) i0 << (j0 - 31)) | (i1 >> (63 - j0));
		}
	} else
	{
		/* The number is too large.  It is left implementation defined
		   what happens.  */
		feraiseexcept(FE_INVALID|FE_INEXACT);
		if (j0 == (IEEE854_LONG_DOUBLE_MAXEXP - IEEE854_LONG_DOUBLE_BIAS))
		{
			/* inf or nan */
			return LONG_MIN;
		}
		return (long int) x;
	}

	return sx ? -result : result;
}

#endif

long int __lrintl(long double x)
{
	return __ieee754_lrintl(x);
}

__typeof(__lrintl) lrintl __attribute__((weak, alias("__lrintl")));

#endif

```

`s_lround.c`:

```c
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice 
 * is preserved.
 * ====================================================
 */
/*
FUNCTION
<<lround>>, <<lroundf>>, <<llround>>, <<llroundf>>--round to integer, to nearest
INDEX
	lround
INDEX
	lroundf
INDEX
	llround
INDEX
	llroundf

ANSI_SYNOPSIS
	#include <math.h>
	long int lround(double <[x]>);
	long int lroundf(float <[x]>);
	long long int llround(double <[x]>);
	long long int llroundf(float <[x]>);

DESCRIPTION
	The <<lround>> and <<llround>> functions round their argument to the
	nearest integer value, rounding halfway cases away from zero, regardless
	of the current rounding direction.  If the rounded value is outside the
	range of the return type, the numeric result is unspecified (depending
	upon the floating-point implementation, not the library).  A range
	error may occur if the magnitude of x is too large.

RETURNS
<[x]> rounded to an integral value as an integer.

SEEALSO
See the <<round>> functions for the return being the same floating-point type
as the argument.  <<lrint>>, <<llrint>>.

PORTABILITY
ANSI C, POSIX

*/

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_lround

long int __ieee754_lround(double x)
{
	int32_t j0;
	uint32_t i1, i0;
	long int result;
	int32_t sign;

	GET_DOUBLE_WORDS(i0, i1, x);
	/* Extract exponent field. */
	j0 = ((i0 >> IEEE754_DOUBLE_SHIFT) & IEEE754_DOUBLE_MAXEXP) - IEEE754_DOUBLE_BIAS;
	/* Extract sign. */
	sign = (i0 & IC(0x80000000)) != 0 ? -1 : 1;
	i0 &= UC(0x000fffff);
	i0 |= UC(0x00100000);

	/* j0 in [-1023,1024] */
	if (j0 < IEEE754_DOUBLE_SHIFT)
	{
		/* j0 in [-1023,19] */
		if (j0 < 0)
		{
			return j0 < -1 ? 0 : sign;
		} else
		{
			/* j0 in [0,19] */

			/* shift amt in [0,19] */
			i0 += UC(0x80000) >> j0;
			/* shift amt in [20,1] */
			result = i0 >> (IEEE754_DOUBLE_SHIFT - j0);
		}
	} else if (j0 < (int32_t) (8 * sizeof(long int)) - 1)
	{
		/* 32bit long: j0 in [20,30] */
		/* 64bit long: j0 in [20,62] */
		if (j0 >= 52)
		{
			/* 64bit long: j0 in [52,62] */
			/* 64bit long: shift amt in [32,42] */
			if ((j0 - IEEE754_DOUBLE_SHIFT) >= (int32_t) (8 * sizeof(long int)))
				result = 0;
			else
				result = (long int) i0 << (j0 - IEEE754_DOUBLE_SHIFT);
			if ((j0 - 52) < 32)
				result |= (unsigned long int)i1 << (j0 - 52);
		} else
		{
			/* 32bit long: j0 in [20,30] */
			/* 64bit long: j0 in [20,51] */
			uint32_t j = i1 + (UC(0x80000000) >> (j0 - IEEE754_DOUBLE_SHIFT));

			if (j < i1)
				++i0;

			if (j0 == IEEE754_DOUBLE_SHIFT)
				result = (long int) i0;
			else
				result = ((long int) i0 << (j0 - IEEE754_DOUBLE_SHIFT)) | (j >> (52 - j0));
		}
	} else
	{
		/* The number is too large.  It is left implementation defined
		   what happens.  */
		return (long int) x;
	}

	if (sign < 0)
		result = -result;
	return result;
}

#endif

long int __lround(double x)
{
	return __ieee754_lround(x);
}

__typeof(__lround) lround __attribute__((weak, alias("__lround")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(__lroundl) __lroundl __attribute__((alias("__lround")));
__typeof(__lroundl) lroundl __attribute__((weak, alias("__lround")));
#endif

```

`s_lroundf.c`:

```c
/* Round double value to long int.
   Copyright (C) 1997-2013 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_lround

long int __ieee754_lroundf(float x)
{
	int32_t j0;
	uint32_t i;
	long int result;
	int32_t sign;

	GET_FLOAT_WORD(i, x);
	j0 = ((i >> IEEE754_FLOAT_SHIFT) & IEEE754_FLOAT_MAXEXP) - IEEE754_FLOAT_BIAS;
	sign = (i & IC(0x80000000)) != 0 ? -1 : 1;
	i &= UC(0x7fffff);
	i |= UC(0x800000);

	if (j0 < (int32_t) (8 * sizeof(long int)) - 1)
	{
		if (j0 < 0)
			return j0 < -1 ? 0 : sign;
		else if (j0 >= IEEE754_FLOAT_SHIFT)
			result = (long int) i << (j0 - IEEE754_FLOAT_SHIFT);
		else
		{
			i += UC(0x400000) >> j0;

			result = i >> (IEEE754_FLOAT_SHIFT - j0);
		}
	} else
	{
		/* The number is too large.  It is left implementation defined
		   what happens.  */
		return (long int) x;
	}

	if (sign < 0)
		result = -result;
	return result;
}

#endif

long int __lroundf(float x)
{
	return __ieee754_lroundf(x);
}

__typeof(__lroundf) lroundf __attribute__((weak, alias("__lroundf")));

```

`s_lroundl.c`:

```c
/* Round double value to long int.
   Copyright (C) 1997-2013 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

#ifndef __have_fpu_lround

long int __ieee754_lroundl(long double x)
{
	int32_t j0;
	uint32_t se, i1, i0;
	long int result;
	int32_t sign;

	GET_LDOUBLE_WORDS(se, i0, i1, x);
	j0 = (se & IEEE854_LONG_DOUBLE_MAXEXP) - IEEE854_LONG_DOUBLE_BIAS;
	sign = (se & 0x8000) != 0 ? -1 : 1;

	if (j0 < 31)
	{
		if (j0 < 0)
			return j0 < -1 ? 0 : sign;
		else
		{
			uint32_t j = i0 + (UC(0x40000000) >> j0);

			if (j < i0)
			{
				j >>= 1;
				j |= UC(0x80000000);
				++j0;
			}

			result = j >> (31 - j0);
		}
	} else if (j0 < (int32_t) (8 * sizeof(long int)) - 1)
	{
		if (j0 >= 63)
		{
			result = (long int) i0 << (j0 - 31);
			if ((j0 - 63) < 32)
				result |= (unsigned long int)i1 << (j0 - 63);
		} else
		{
			uint32_t j = i1 + (UC(0x80000000) >> (j0 - 31));

			if (j < i1)
				++i0;

			if (j0 == 31)
				result = (long int) i0;
			else
				result = ((long int) i0 << (j0 - 31)) | (j >> (63 - j0));
		}
	} else
	{
		/* The number is too large.  It is left implementation defined
		   what happens.  */
		return (long int) x;
	}

	if (sign < 0)
		result = -result;
	return result;
}

#endif

long int __lroundl(long double x)
{
	return __ieee754_lroundl(x);
}

__typeof(__lroundl) lroundl __attribute__((weak, alias("__lroundl")));

#endif

```

`s_matherr.c`:

```c

/* @(#)s_matherr.c 1.3 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice 
 * is preserved.
 * ====================================================
 */

#include "fdlibm.h"

int matherr(struct exception *x)
{
	int n=0;
	if(x->arg1!=x->arg1) return 0;
	return n;
}

```

`s_modf.c`:

```c
/* @(#)s_modf.c 1.3 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/*
 * modf(double x, double *iptr) 
 * return fraction part of x, and return x's integral part in *iptr.
 * Method:
 *	Bit twiddling.
 *
 * Exception:
 *	No exception.
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_modf

double __ieee754_modf(double x, double *iptr)
{
	int32_t i0, i1, j0;
	uint32_t i;

	static const double one = 1.0;

	GET_DOUBLE_WORDS(i0, i1, x);
	j0 = ((i0 >> IEEE754_DOUBLE_SHIFT) & IEEE754_DOUBLE_MAXEXP) - IEEE754_DOUBLE_BIAS;	/* exponent of x */
	if (j0 < IEEE754_DOUBLE_SHIFT)
	{									/* integer part in high x */
		if (j0 < 0)
		{								/* |x|<1 */
			INSERT_WORDS(*iptr, i0 & UC(0x80000000), 0);	/* *iptr = +-0 */
			return x;
		} else
		{
			i = UC(0x000fffff) >> j0;
			if (((i0 & i) | i1) == 0)
			{							/* x is integral */
				*iptr = x;
				INSERT_WORDS(x, i0 & UC(0x80000000), 0);	/* return +-0 */
				return x;
			} else
			{
				INSERT_WORDS(*iptr, i0 & (~i), 0);
				return x - *iptr;
			}
		}
	} else if (j0 > 51)
	{									/* no fraction part */
		*iptr = x * one;
		/* We must handle NaNs separately.  */
		if (j0 == (IEEE754_DOUBLE_MAXEXP - IEEE754_DOUBLE_BIAS) && ((i0 & UC(0xfffff)) | i1) != 0)
			return x * one;
		INSERT_WORDS(x, i0 & UC(0x80000000), 0);	/* return +-0 */
		return x;
	} else
	{									/* fraction part in low x */
		i = UC(0xffffffff) >> (j0 - IEEE754_DOUBLE_SHIFT);
		if ((i1 & i) == 0)
		{								/* x is integral */
			*iptr = x;
			INSERT_WORDS(x, i0 & UC(0x80000000), 0);	/* return +-0 */
			return x;
		} else
		{
			INSERT_WORDS(*iptr, i0, i1 & (~i));
			return x - *iptr;
		}
	}
}

#endif

double __modf(double x, double *iptr)
{
	return __ieee754_modf(x, iptr);
}


__typeof(__modf) modf __attribute__((weak, alias("__modf")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(__modfl) __modfl __attribute__((alias("__modf")));
__typeof(__modfl) modfl __attribute__((weak, alias("__modf")));
#endif

```

`s_modff.c`:

```c
/* s_modff.c -- float version of s_modf.c.
 * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_modf

float __ieee754_modff(float x, float *iptr)
{
	int32_t i0, j0;
	uint32_t i;

	static const float one = 1.0;

	GET_FLOAT_WORD(i0, x);
	j0 = ((i0 >> IEEE754_FLOAT_SHIFT) & IEEE754_FLOAT_MAXEXP) - IEEE754_FLOAT_BIAS;	/* exponent of x */
	if (j0 < IEEE754_FLOAT_SHIFT)
	{									/* integer part in x */
		if (j0 < 0)
		{								/* |x|<1 */
			SET_FLOAT_WORD(*iptr, i0 & IC(0x80000000));	/* *iptr = +-0 */
			return x;
		} else
		{
			i = IC(0x007fffff) >> j0;
			if ((i0 & i) == 0)
			{							/* x is integral */
				uint32_t ix;

				*iptr = x;
				GET_FLOAT_WORD(ix, x);
				SET_FLOAT_WORD(x, ix & IC(0x80000000));	/* return +-0 */
				return x;
			} else
			{
				SET_FLOAT_WORD(*iptr, i0 & (~i));
				return x - *iptr;
			}
		}
	} else
	{									/* no fraction part */
		*iptr = x * one;
		/* We must handle NaNs separately.  */
		if (j0 == (IEEE754_FLOAT_MAXEXP - IEEE754_FLOAT_BIAS) && (i0 & IC(0x7fffff)) != 0)
			return x * one;
		SET_FLOAT_WORD(x, i0 & IC(0x80000000));	/* return +-0 */
		return x;
	}
}

#endif

float __modff(float x, float *iptr)
{
	return __ieee754_modff(x, iptr);
}

__typeof(__modff) modff __attribute__((weak, alias("__modff")));

```

`s_modfl.c`:

```c
/* s_modfl.c -- long double version of s_modf.c.
 * Conversion to long double by Ulrich Drepper,
 * Cygnus Support, drepper@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/*
 * modfl(long double x, long double *iptr)
 * return fraction part of x, and return x's integral part in *iptr.
 * Method:
 *	Bit twiddling.
 *
 * Exception:
 *	No exception.
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

#ifndef __have_fpu_modf

long double __ieee754_modfl(long double x, long double *iptr)
{
	int32_t i0, i1, j0;
	uint32_t i, se;

	static const long double one = 1.0;

	GET_LDOUBLE_WORDS(se, i0, i1, x);
	j0 = (se & IEEE854_LONG_DOUBLE_MAXEXP) - IEEE854_LONG_DOUBLE_BIAS;		/* exponent of x */
	if (j0 < 32)
	{									/* integer part in high x */
		if (j0 < 0)
		{								/* |x|<1 */
			SET_LDOUBLE_WORDS(*iptr, se & 0x8000, 0, 0);	/* *iptr = +-0 */
			return x;
		} else
		{
			i = IC(0x7fffffff) >> j0;
			if (((i0 & i) | i1) == 0)
			{							/* x is integral */
				*iptr = x;
				SET_LDOUBLE_WORDS(x, se & 0x8000, 0, 0);	/* return +-0 */
				return x;
			} else
			{
				SET_LDOUBLE_WORDS(*iptr, se, i0 & (~i), 0);
				return x - *iptr;
			}
		}
	} else if (j0 > 63)
	{									/* no fraction part */
		*iptr = x * one;
		/* We must handle NaNs separately.  */
		if (j0 == (IEEE854_LONG_DOUBLE_MAXEXP - IEEE854_LONG_DOUBLE_BIAS) && ((i0 & IC(0x7fffffff)) | i1) != 0)
			return x * one;
		SET_LDOUBLE_WORDS(x, se & 0x8000, 0, 0);	/* return +-0 */
		return x;
	} else
	{									/* fraction part in low x */
		i = UC(0x7fffffff) >> (j0 - 32);
		if ((i1 & i) == 0)
		{								/* x is integral */
			*iptr = x;
			SET_LDOUBLE_WORDS(x, se & 0x8000, 0, 0);	/* return +-0 */
			return x;
		} else
		{
			SET_LDOUBLE_WORDS(*iptr, se, i0, i1 & (~i));
			return x - *iptr;
		}
	}
}

#endif

long double __modfl(long double x, long double *iptr)
{
	return __ieee754_modfl(x, iptr);
}

__typeof(__modfl) modfl __attribute__((weak, alias("__modfl")));

#endif

```

`s_nearbyint.c`:

```c
/* Adapted for use as nearbyint by Ulrich Drepper <drepper@cygnus.com>.  */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

/*
 * nearbyint(x)
 * Return x rounded to integral value according to the prevailing
 * rounding mode.
 * Method:
 *	Using floating addition.
 * Exception:
 *	none
 */

double __nearbyint(double x)
{
	fenv_t env;
	double value;

	feholdexcept(&env);
	value = __ieee754_rint(x);
	fesetenv(&env);
	return value;
}

__typeof(__nearbyint) nearbyint __attribute__((weak, alias("__nearbyint")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(nearbyintl) __nearbyintl __attribute__((alias("__nearbyint")));
__typeof(__nearbyintl) nearbyintl __attribute__((weak, alias("__nearbyint")));
#endif

```

`s_nearbyintf.c`:

```c
/* s_nearbyintf.c -- float version of s_nearbyint.c.
 * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
 */
/* Adapted for use as nearbyint by Ulrich Drepper <drepper@cygnus.com>.  */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */


#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

float __nearbyintf(float x)
{
	fenv_t env;
	float value;

	feholdexcept(&env);
	value = __ieee754_rintf(x);
	fesetenv(&env);
	return value;
}

__typeof(__nearbyintf) nearbyintf __attribute__((weak, alias("__nearbyintf")));

```

`s_nearbyintl.c`:

```c
/* s_nearbyintl.c -- long double version of s_nearbyint.c.
 * Conversion to long double by Ulrich Drepper,
 * Cygnus Support, drepper@cygnus.com.
 */
/* Adapted for use as nearbyint by Ulrich Drepper <drepper@cygnus.com>.  */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/*
 * nearbyintl(x)
 * Return x rounded to integral value according to the prevailing
 * rounding mode.
 * Method:
 *	Using floating addition.
 * Exception:
 *	none
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

long double __nearbyintl(long double x)
{
	fenv_t env;
	long double value;

	feholdexcept(&env);
	value = __ieee754_rintl(x);
	fesetenv(&env);
	return value;
}

__typeof(__nearbyintl) nearbyintl __attribute__((weak, alias("__nearbyintl")));

#endif

```

`s_nextafter.c`:

```c
/* @(#)s_nextafter.c 1.3 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/* IEEE functions
 *	nextafter(x,y)
 *	return the next machine floating-point number of x in the
 *	direction toward y.
 *   Special cases:
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

double __nextafter(double x, double y)
{
	int32_t hx, hy, ix, iy;
	uint32_t lx, ly;

	GET_DOUBLE_WORDS(hx, lx, x);
	GET_DOUBLE_WORDS(hy, ly, y);
	ix = hx & IC(0x7fffffff);				/* |x| */
	iy = hy & IC(0x7fffffff);				/* |y| */

	if (((ix >= IC(0x7ff00000)) && ((ix - IC(0x7ff00000)) | lx) != 0) ||	/* x is nan */
		((iy >= IC(0x7ff00000)) && ((iy - IC(0x7ff00000)) | ly) != 0))	/* y is nan */
		return x + y;
	if (x == y)
		return x;						/* x=y, return x */
	if ((ix | lx) == 0)
	{									/* x == 0 */
		double u;

		INSERT_WORDS(x, hy & UC(0x80000000), 1);	/* return +-minsubnormal */
		u = math_opt_barrier(x);
		u = u * u;
		math_force_eval(u);				/* raise underflow flag */
		return x;
	}
	if (hx >= 0)
	{									/* x > 0 */
		if (hx > hy || ((hx == hy) && (lx > ly)))
		{								/* x > y, x -= ulp */
			if (lx == 0)
				hx -= 1;
			lx -= 1;
		} else
		{								/* x < y, x += ulp */
			lx += 1;
			if (lx == 0)
				hx += 1;
		}
	} else
	{									/* x < 0 */
		if (hy >= 0 || hx > hy || ((hx == hy) && (lx > ly)))
		{								/* x < y, x -= ulp */
			if (lx == 0)
				hx -= 1;
			lx -= 1;
		} else
		{								/* x > y, x += ulp */
			lx += 1;
			if (lx == 0)
				hx += 1;
		}
	}
	hy = hx & IC(0x7ff00000);
	if (hy >= IC(0x7ff00000))
	{
		x = x + x;						/* overflow  */
		math_force_eval(x);
		return x;						/* overflow  */
	}
	if (hy < IC(0x00100000))
	{
		double u = x * x;				/* underflow */
		math_force_eval(u);				/* raise underflow flag */
	}
	INSERT_WORDS(x, hx, lx);
	return x;
}


__typeof(__nextafter) nextafter __attribute__((weak, alias("__nextafter")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(nextafterl) __nextafterl __attribute__((alias("__nextafter")));
__typeof(__nextafterl) nextafterl __attribute__((weak, alias("__nextafter")));
__typeof(__nexttoward) __nexttoward __attribute__((alias("__nextafter")));
__typeof(nexttoward) nexttoward __attribute__((weak, alias("__nextafter")));
__typeof(__nexttowardl) __nexttowardl __attribute__((alias("__nextafterl")));
__typeof(nexttowardl) nexttowardl __attribute__((weak, alias("__nextafterl")));
#endif

```

`s_nextafterf.c`:

```c
/* s_nextafterf.c -- float version of s_nextafter.c.
 * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

float __nextafterf(float x, float y)
{
	int32_t hx, hy, ix, iy;

	GET_FLOAT_WORD(hx, x);
	GET_FLOAT_WORD(hy, y);
	ix = hx & IC(0x7fffffff);			/* |x| */
	iy = hy & IC(0x7fffffff);			/* |y| */

	if ((ix > IC(0x7f800000)) ||		/* x is nan */
		(iy > IC(0x7f800000)))			/* y is nan */
		return x + y;
	if (x == y)
		return y;						/* x=y, return y */
	if (ix == 0)
	{									/* x == 0 */
		float u;

		SET_FLOAT_WORD(x, (hy & IC(0x80000000)) | 1);	/* return +-minsubnormal */
		u = math_opt_barrier(x);
		u = u * u;
		math_force_eval(u);				/* raise underflow flag */
		return x;
	}
	if (hx >= 0)
	{									/* x > 0 */
		if (hx > hy)
		{								/* x > y, x -= ulp */
			hx -= 1;
		} else
		{								/* x < y, x += ulp */
			hx += 1;
		}
	} else
	{									/* x < 0 */
		if (hy >= 0 || hx > hy)
		{								/* x < y, x -= ulp */
			hx -= 1;
		} else
		{								/* x > y, x += ulp */
			hx += 1;
		}
	}
	hy = hx & IC(0x7f800000);
	if (hy >= IC(0x7f800000))
	{
		x = x + x;						/* overflow  */
		math_force_eval(x);
		return x;						/* overflow  */
	}
	if (hy < IC(0x00800000))
	{
		float u = x * x;				/* underflow */
		math_force_eval(u);				/* raise underflow flag */
	}
	SET_FLOAT_WORD(x, hx);
	return x;
}

__typeof(__nextafterf) nextafterf __attribute__((weak, alias("__nextafterf")));

```

`s_nextafterl.c`:

```c
/* s_nextafterl.c -- long double version of s_nextafter.c.
 * Conversion to long double by Ulrich Drepper,
 * Cygnus Support, drepper@cygnus.com.
 * Fixed for m68k by Andreas Schwab <schwab@suse.de>.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/* IEEE functions
 *	nextafterl(x,y)
 *	return the next machine floating-point number of x in the
 *	direction toward y.
 *   Special cases:
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

long double __nextafterl(long double x, long double y)
{
	int32_t ix, iy;
	int32_t esx, esy;
	uint32_t hx, hy, lx, ly;

	GET_LDOUBLE_WORDS(esx, hx, lx, x);
	GET_LDOUBLE_WORDS(esy, hy, ly, y);
	ix = esx & IEEE854_LONG_DOUBLE_MAXEXP;					/* |x| */
	iy = esy & IEEE854_LONG_DOUBLE_MAXEXP;					/* |y| */

	/* Intel's extended format has the normally implicit 1 explicit
	   present.  Sigh!  */
	if (((ix == IEEE854_LONG_DOUBLE_MAXEXP) && (((hx & IC(0x7fffffff)) | lx) != 0)) ||	/* x is nan */
		((iy == IEEE854_LONG_DOUBLE_MAXEXP) && (((hy & IC(0x7fffffff)) | ly) != 0)))	/* y is nan */
		return x + y;
	if (x == y)
		return y;						/* x=y, return y */
	if ((ix | hx | lx) == 0)
	{									/* x == 0 */
		long double u;

		SET_LDOUBLE_WORDS(x, esy & 0x8000, 0, 1);	/* return +-minsubnormal */
		u = math_opt_barrier(x);
		u = u * u;
		math_force_eval(u);				/* raise underflow flag */
		return x;
	}
	if (esx >= 0)
	{									/* x > 0 */
		if (esx > esy || ((esx == esy) && (hx > hy || ((hx == hy) && (lx > ly)))))
		{
			/* x > y, x -= ulp */
			if (lx == 0)
			{
				if (hx <= UC(0x80000000))
				{
					if (esx == 0)
					{
						--hx;
					} else
					{
						esx -= 1;
						hx = hx - 1;
						if (esx > 0)
							hx |= UC(0x80000000);
					}
				} else
					hx -= 1;
			}
			lx -= 1;
		} else
		{								/* x < y, x += ulp */
			lx += 1;
			if (lx == 0)
			{
				hx += 1;
				if (hx == 0 || (esx == 0 && hx == UC(0x80000000)))
				{
					esx += 1;
					hx |= UC(0x80000000);
				}
			}
		}
	} else
	{									/* x < 0 */
		if (esy >= 0 || (esx > esy || ((esx == esy) && (hx > hy || ((hx == hy) && (lx > ly))))))
		{
			/* x < y, x -= ulp */
			if (lx == 0)
			{
				if (hx <= UC(0x80000000))
				{
					esx -= 1;
					hx = hx - 1;
					if ((esx & IEEE854_LONG_DOUBLE_MAXEXP) > 0)
						hx |= UC(0x80000000);
				} else
					hx -= 1;
			}
			lx -= 1;
		} else
		{								/* x > y, x += ulp */
			lx += 1;
			if (lx == 0)
			{
				hx += 1;
				if (hx == 0 || (esx == IC(0xffff8000) && hx == UC(0x80000000)))
				{
					esx += 1;
					hx |= UC(0x80000000);
				}
			}
		}
	}
	esy = esx & IEEE854_LONG_DOUBLE_MAXEXP;
	if (esy == IEEE854_LONG_DOUBLE_MAXEXP)
		return x + x;					/* overflow  */
	if (esy == 0)
	{
		long double u = x * x;			/* underflow */
		math_force_eval(u);				/* raise underflow flag */
	}
	SET_LDOUBLE_WORDS(x, esx, hx, lx);
	return x;
}

__typeof(__nextafterl) nextafterl __attribute__((weak, alias("__nextafterl")));

__typeof(__nexttowardl) __nexttowardl __attribute__((alias("__nextafterl")));
__typeof(nexttowardl) nexttowardl __attribute__((weak, alias("__nextafterl")));

#endif

```

`s_nexttoward.c`:

```c
/* s_nexttoward.c
 * Special i387 version
 * Conversion from s_nextafter.c by Ulrich Drepper, Cygnus Support,
 * drepper@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/* IEEE functions
 *	nexttoward(x,y)
 *	return the next machine floating-point number of x in the
 *	direction toward y.
 *   Special cases:
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

double __nexttoward(double x, long double y)
{
	int32_t hx, ix, iy;
	uint32_t lx, hy, ly, esy;

	GET_DOUBLE_WORDS(hx, lx, x);
	GET_LDOUBLE_WORDS(esy, hy, ly, y);
	ix = hx & IC(0x7fffffff);				/* |x| */
	iy = esy & IEEE854_LONG_DOUBLE_MAXEXP;					/* |y| */

	/* Intel's extended format has the normally implicit 1 explicit
	   present.  Sigh!  */
	if (((ix >= IC(0x7ff00000)) && ((ix - IC(0x7ff00000)) | lx) != 0) ||	/* x is nan */
		((iy >= IEEE854_LONG_DOUBLE_MAXEXP) && ((hy & UC(0x7fffffff)) | ly) != 0))	/* y is nan */
		return __builtin_nan("");
	if ((long double) x == y)
		return y;						/* x=y, return y */
	if ((ix | lx) == 0)
	{									/* x == 0 */
		double u;

		INSERT_WORDS(x, (esy & 0x8000) << 16, 1);	/* return +-minsub */
		u = math_opt_barrier(x);
		u = u * u;
		math_force_eval(u);				/* raise underflow flag */
		return x;
	}
	if (hx >= 0)
	{									/* x > 0 */
		if (x > y)
		{								/* x -= ulp */
			if (lx == 0)
				hx -= 1;
			lx -= 1;
		} else
		{								/* x < y, x += ulp */
			lx += 1;
			if (lx == 0)
				hx += 1;
		}
	} else
	{									/* x < 0 */
		if (x < y)
		{								/* x -= ulp */
			if (lx == 0)
				hx -= 1;
			lx -= 1;
		} else
		{								/* x > y, x += ulp */
			lx += 1;
			if (lx == 0)
				hx += 1;
		}
	}
	hy = hx & UC(0x7ff00000);
	if (hy >= UC(0x7ff00000))
	{
		x = x + x;						/* overflow  */
		/* Force conversion to double.  */
		math_force_eval(x);
		return x;
	}
	if (hy < UC(0x00100000))
	{
		double u = x * x;				/* underflow */
		math_force_eval(u);				/* raise underflow flag */
	}
	INSERT_WORDS(x, hx, lx);
	return x;
}

__typeof(__nexttoward) nexttoward __attribute__((weak, alias("__nexttoward")));
/* aliases for long double versions already done in nextafter */

#endif

```

`s_nexttowardf.c`:

```c
/* s_nexttowardf.c -- float version of s_nextafter.c.
 * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

float __nexttowardf(float x, long double y)
{
	int32_t hx, ix, iy;
	uint32_t hy, ly, esy;

	GET_FLOAT_WORD(hx, x);
	GET_LDOUBLE_WORDS(esy, hy, ly, y);
	ix = hx & IC(0x7fffffff);				/* |x| */
	iy = esy & IEEE854_LONG_DOUBLE_MAXEXP;					/* |y| */

	/* Intel's extended format has the normally implicit 1 explicit
	   present.  Sigh!  */
	if ((ix > IC(0x7f800000)) ||			/* x is nan */
		(iy >= IEEE854_LONG_DOUBLE_MAXEXP && (((hy & UC(0x7fffffff)) | ly) != 0)))	/* y is nan */
		return x + y;
	if ((long double) x == y)
		return y;						/* x=y, return y */
	if (ix == 0)
	{									/* x == 0 */
		float u;

		SET_FLOAT_WORD(x, ((esy & 0x8000) << 16) | 1);	/* return +-minsub */
		u = math_opt_barrier(x);
		u = u * u;
		math_force_eval(u);				/* raise underflow flag */
		return x;
	}
	if (hx >= 0)
	{									/* x > 0 */
		if (x > y)
		{								/* x -= ulp */
			hx -= 1;
		} else
		{								/* x < y, x += ulp */
			hx += 1;
		}
	} else
	{									/* x < 0 */
		if (x < y)
		{								/* x -= ulp */
			hx -= 1;
		} else
		{								/* x > y, x += ulp */
			hx += 1;
		}
	}
	hy = hx & UC(0x7f800000);
	if (hy >= UC(0x7f800000))
	{
		x = x + x;						/* overflow  */
		/* Force conversion to float.  */
		math_force_eval(x);
		return x;
	}
	if (hy < UC(0x00800000))
	{
		float u = x * x;				/* underflow */

		math_force_eval(u);				/* raise underflow flag */
	}
	SET_FLOAT_WORD(x, hx);
	return x;
}

__typeof(__nexttowardf) nexttowardf __attribute__((weak, alias("__nexttowardf")));

#endif

```

`s_pone.c`:

```c
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

double __j1_y1_pone(double x)
{
	const double *p, *q;
	double z, r, s, r1, r2, r3, s1, s2, s3, z2, z4;
	int32_t ix;

	static const double one = 1.0;

	/* For x >= 8, the asymptotic expansions of pone is
	 *	1 + 15/128 s^2 - 4725/2^15 s^4 - ...,	where s = 1/x.
	 * We approximate pone by
	 *	pone(x) = 1 + (R/S)
	 * where  R = pr0 + pr1*s^2 + pr2*s^4 + ... + pr5*s^10
	 *  S = 1 + ps0*s^2 + ... + ps4*s^10
	 * and
	 *	| pone(x)-1-R/S | <= 2  ** ( -60.06)
	 */
	
	static const double pr8[6] = {			/* for x in [inf, 8]=1/[0,0.125] */
		0.00000000000000000000e+00,			/* 0x00000000, 0x00000000 */
		1.17187499999988647970e-01,			/* 0x3FBDFFFF, 0xFFFFFCCE */
		1.32394806593073575129e+01,			/* 0x402A7A9D, 0x357F7FCE */
		4.12051854307378562225e+02,			/* 0x4079C0D4, 0x652EA590 */
		3.87474538913960532227e+03,			/* 0x40AE457D, 0xA3A532CC */
		7.91447954031891731574e+03			/* 0x40BEEA7A, 0xC32782DD */
	};
	
	static const double ps8[5] = {
		1.14207370375678408436e+02,			/* 0x405C8D45, 0x8E656CAC */
		3.65093083420853463394e+03,			/* 0x40AC85DC, 0x964D274F */
		3.69562060269033463555e+04,			/* 0x40E20B86, 0x97C5BB7F */
		9.76027935934950801311e+04,			/* 0x40F7D42C, 0xB28F17BB */
		3.08042720627888811578e+04			/* 0x40DE1511, 0x697A0B2D */
	};
	
	static const double pr5[6] = {			/* for x in [8,4.5454]=1/[0.125,0.22001] */
		1.31990519556243522749e-11,			/* 0x3DAD0667, 0xDAE1CA7D */
		1.17187493190614097638e-01,			/* 0x3FBDFFFF, 0xE2C10043 */
		6.80275127868432871736e+00,			/* 0x401B3604, 0x6E6315E3 */
		1.08308182990189109773e+02,			/* 0x405B13B9, 0x452602ED */
		5.17636139533199752805e+02,			/* 0x40802D16, 0xD052D649 */
		5.28715201363337541807e+02			/* 0x408085B8, 0xBB7E0CB7 */
	};
	
	static const double ps5[5] = {
		5.92805987221131331921e+01,			/* 0x404DA3EA, 0xA8AF633D */
		9.91401418733614377743e+02,			/* 0x408EFB36, 0x1B066701 */
		5.35326695291487976647e+03,			/* 0x40B4E944, 0x5706B6FB */
		7.84469031749551231769e+03,			/* 0x40BEA4B0, 0xB8A5BB15 */
		1.50404688810361062679e+03			/* 0x40978030, 0x036F5E51 */
	};
	
	static const double pr3[6] = {
		3.02503916137373618024e-09,			/* 0x3E29FC21, 0xA7AD9EDD */
		1.17186865567253592491e-01,			/* 0x3FBDFFF5, 0x5B21D17B */
		3.93297750033315640650e+00,			/* 0x400F76BC, 0xE85EAD8A */
		3.51194035591636932736e+01,			/* 0x40418F48, 0x9DA6D129 */
		9.10550110750781271918e+01,			/* 0x4056C385, 0x4D2C1837 */
		4.85590685197364919645e+01			/* 0x4048478F, 0x8EA83EE5 */
	};
	
	static const double ps3[5] = {
		3.47913095001251519989e+01,			/* 0x40416549, 0xA134069C */
		3.36762458747825746741e+02,			/* 0x40750C33, 0x07F1A75F */
		1.04687139975775130551e+03,			/* 0x40905B7C, 0x5037D523 */
		8.90811346398256432622e+02,			/* 0x408BD67D, 0xA32E31E9 */
		1.03787932439639277504e+02			/* 0x4059F26D, 0x7C2EED53 */
	};
	
	static const double pr2[6] = {			/* for x in [2.8570,2]=1/[0.3499,0.5] */
		1.07710830106873743082e-07,			/* 0x3E7CE9D4, 0xF65544F4 */
		1.17176219462683348094e-01,			/* 0x3FBDFF42, 0xBE760D83 */
		2.36851496667608785174e+00,			/* 0x4002F2B7, 0xF98FAEC0 */
		1.22426109148261232917e+01,			/* 0x40287C37, 0x7F71A964 */
		1.76939711271687727390e+01,			/* 0x4031B1A8, 0x177F8EE2 */
		5.07352312588818499250e+00			/* 0x40144B49, 0xA574C1FE */
	};
	
	static const double ps2[5] = {
		2.14364859363821409488e+01,			/* 0x40356FBD, 0x8AD5ECDC */
		1.25290227168402751090e+02,			/* 0x405F5293, 0x14F92CD5 */
		2.32276469057162813669e+02,			/* 0x406D08D8, 0xD5A2DBD9 */
		1.17679373287147100768e+02,			/* 0x405D6B7A, 0xDA1884A9 */
		8.36463893371618283368e+00			/* 0x4020BAB1, 0xF44E5192 */
	};
	
	GET_HIGH_WORD(ix, x);
	ix &= IC(0x7fffffff);
	if (ix >= IC(0x41b00000))
	{
		return one;
	} else if (ix >= IC(0x40200000))
	{
		p = pr8;
		q = ps8;
	} else if (ix >= IC(0x40122E8B))
	{
		p = pr5;
		q = ps5;
	} else if (ix >= IC(0x4006DB6D))
	{
		p = pr3;
		q = ps3;
	} else /* if (ix >= IC(0x40000000)) */
	{
		p = pr2;
		q = ps2;
	}
	z = one / (x * x);
#ifdef DO_NOT_USE_THIS
	r = p[0] + z * (p[1] + z * (p[2] + z * (p[3] + z * (p[4] + z * p[5]))));
	s = one + z * (q[0] + z * (q[1] + z * (q[2] + z * (q[3] + z * q[4]))));
#else
	r1 = p[0] + z * p[1];
	z2 = z * z;
	r2 = p[2] + z * p[3];
	z4 = z2 * z2;
	r3 = p[4] + z * p[5];
	r = r1 + z2 * r2 + z4 * r3;
	s1 = one + z * q[0];
	s2 = q[1] + z * q[2];
	s3 = q[3] + z * q[4];
	s = s1 + z2 * s2 + z4 * s3;
#endif
	return one + r / s;
}

double __j1_y1_qone(double x)
{
	const double *p, *q;
	double s, r, z, r1, r2, r3, s1, s2, s3, z2, z4, z6;
	int32_t ix;

	static const double one = 1.0;

	/* For x >= 8, the asymptotic expansions of qone is
	 *	3/8 s - 105/1024 s^3 - ..., where s = 1/x.
	 * We approximate qone by
	 *	qone(x) = s*(0.375 + (R/S))
	 * where  R = qr1*s^2 + qr2*s^4 + ... + qr5*s^10
	 *  S = 1 + qs1*s^2 + ... + qs6*s^12
	 * and
	 *	| qone(x)/s -0.375-R/S | <= 2  ** ( -61.13)
	 */
	
	static const double qr8[6] = {			/* for x in [inf, 8]=1/[0,0.125] */
		0.00000000000000000000e+00,			/* 0x00000000, 0x00000000 */
		-1.02539062499992714161e-01,		/* 0xBFBA3FFF, 0xFFFFFDF3 */
		-1.62717534544589987888e+01,		/* 0xC0304591, 0xA26779F7 */
		-7.59601722513950107896e+02,		/* 0xC087BCD0, 0x53E4B576 */
		-1.18498066702429587167e+04,		/* 0xC0C724E7, 0x40F87415 */
		-4.84385124285750353010e+04			/* 0xC0E7A6D0, 0x65D09C6A */
	};
	
	static const double qs8[6] = {
		1.61395369700722909556e+02,			/* 0x40642CA6, 0xDE5BCDE5 */
		7.82538599923348465381e+03,			/* 0x40BE9162, 0xD0D88419 */
		1.33875336287249578163e+05,			/* 0x4100579A, 0xB0B75E98 */
		7.19657723683240939863e+05,			/* 0x4125F653, 0x72869C19 */
		6.66601232617776375264e+05,			/* 0x412457D2, 0x7719AD5C */
		-2.94490264303834643215e+05			/* 0xC111F969, 0x0EA5AA18 */
	};
	
	static const double qr5[6] = {			/* for x in [8,4.5454]=1/[0.125,0.22001] */
		-2.08979931141764104297e-11,		/* 0xBDB6FA43, 0x1AA1A098 */
		-1.02539050241375426231e-01,		/* 0xBFBA3FFF, 0xCB597FEF */
		-8.05644828123936029840e+00,		/* 0xC0201CE6, 0xCA03AD4B */
		-1.83669607474888380239e+02,		/* 0xC066F56D, 0x6CA7B9B0 */
		-1.37319376065508163265e+03,		/* 0xC09574C6, 0x6931734F */
		-2.61244440453215656817e+03			/* 0xC0A468E3, 0x88FDA79D */
	};
	
	static const double qs5[6] = {
		8.12765501384335777857e+01,			/* 0x405451B2, 0xFF5A11B2 */
		1.99179873460485964642e+03,			/* 0x409F1F31, 0xE77BF839 */
		1.74684851924908907677e+04,			/* 0x40D10F1F, 0x0D64CE29 */
		4.98514270910352279316e+04,			/* 0x40E8576D, 0xAABAD197 */
		2.79480751638918118260e+04,			/* 0x40DB4B04, 0xCF7C364B */
		-4.71918354795128470869e+03			/* 0xC0B26F2E, 0xFCFFA004 */
	};
	
	static const double qr3[6] = {
		-5.07831226461766561369e-09,		/* 0xBE35CFA9, 0xD38FC84F */
		-1.02537829820837089745e-01,		/* 0xBFBA3FEB, 0x51AEED54 */
		-4.61011581139473403113e+00,		/* 0xC01270C2, 0x3302D9FF */
		-5.78472216562783643212e+01,		/* 0xC04CEC71, 0xC25D16DA */
		-2.28244540737631695038e+02,		/* 0xC06C87D3, 0x4718D55F */
		-2.19210128478909325622e+02			/* 0xC06B66B9, 0x5F5C1BF6 */
	};
	
	static const double qs3[6] = {
		4.76651550323729509273e+01,			/* 0x4047D523, 0xCCD367E4 */
		6.73865112676699709482e+02,			/* 0x40850EEB, 0xC031EE3E */
		3.38015286679526343505e+03,			/* 0x40AA684E, 0x448E7C9A */
		5.54772909720722782367e+03,			/* 0x40B5ABBA, 0xA61D54A6 */
		1.90311919338810798763e+03,			/* 0x409DBC7A, 0x0DD4DF4B */
		-1.35201191444307340817e+02			/* 0xC060E670, 0x290A311F */
	};
	
	static const double qr2[6] = {			/* for x in [2.8570,2]=1/[0.3499,0.5] */
		-1.78381727510958865572e-07,		/* 0xBE87F126, 0x44C626D2 */
		-1.02517042607985553460e-01,		/* 0xBFBA3E8E, 0x9148B010 */
		-2.75220568278187460720e+00,		/* 0xC0060484, 0x69BB4EDA */
		-1.96636162643703720221e+01,		/* 0xC033A9E2, 0xC168907F */
		-4.23253133372830490089e+01,		/* 0xC04529A3, 0xDE104AAA */
		-2.13719211703704061733e+01			/* 0xC0355F36, 0x39CF6E52 */
	};
	
	static const double qs2[6] = {
		2.95333629060523854548e+01,			/* 0x403D888A, 0x78AE64FF */
		2.52981549982190529136e+02,			/* 0x406F9F68, 0xDB821CBA */
		7.57502834868645436472e+02,			/* 0x4087AC05, 0xCE49A0F7 */
		7.39393205320467245656e+02,			/* 0x40871B25, 0x48D4C029 */
		1.55949003336666123687e+02,			/* 0x40637E5E, 0x3C3ED8D4 */
		-4.95949898822628210127e+00			/* 0xC013D686, 0xE71BE86B */
	};

	GET_HIGH_WORD(ix, x);
	ix &= IC(0x7fffffff);
	if (ix >= IC(0x41b00000))
	{
		return .375 / x;
	} else if (ix >= IC(0x40200000))
	{
		p = qr8;
		q = qs8;
	} else if (ix >= IC(0x40122E8B))
	{
		p = qr5;
		q = qs5;
	} else if (ix >= IC(0x4006DB6D))
	{
		p = qr3;
		q = qs3;
	} else /* if (ix >= IC(0x40000000)) */
	{
		p = qr2;
		q = qs2;
	}
	z = one / (x * x);
#ifdef DO_NOT_USE_THIS
	r = p[0] + z * (p[1] + z * (p[2] + z * (p[3] + z * (p[4] + z * p[5]))));
	s = one + z * (q[0] + z * (q[1] + z * (q[2] + z * (q[3] + z * (q[4] + z * q[5])))));
#else
	r1 = p[0] + z * p[1];
	z2 = z * z;
	r2 = p[2] + z * p[3];
	z4 = z2 * z2;
	r3 = p[4] + z * p[5];
	z6 = z4 * z2;
	r = r1 + z2 * r2 + z4 * r3;
	s1 = one + z * q[0];
	s2 = q[1] + z * q[2];
	s3 = q[3] + z * q[4];
	s = s1 + z2 * s2 + z4 * s3 + z6 * q[5];
#endif
	return (.375 + r / s) / x;
}

```

`s_ponef.c`:

```c
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

float __j1_y1_ponef(float x)
{
	const float *p, *q;
	float z, r, s;
	int32_t ix;

	static const float one = 1.0;

	/* For x >= 8, the asymptotic expansions of pone is
	 *	1 + 15/128 s^2 - 4725/2^15 s^4 - ...,	where s = 1/x.
	 * We approximate pone by
	 *	pone(x) = 1 + (R/S)
	 * where  R = pr0 + pr1*s^2 + pr2*s^4 + ... + pr5*s^10
	 *	  S = 1 + ps0*s^2 + ... + ps4*s^10
	 * and
	 *	| pone(x)-1-R/S | <= 2  ** ( -60.06)
	 */
	static const float pr8[6] = {			/* for x in [inf, 8]=1/[0,0.125] */
		0.0000000000e+00,					/* 0x00000000 */
		1.1718750000e-01,					/* 0x3df00000 */
		1.3239480972e+01,					/* 0x4153d4ea */
		4.1205184937e+02,					/* 0x43ce06a3 */
		3.8747453613e+03,					/* 0x45722bed */
		7.9144794922e+03					/* 0x45f753d6 */
	};
	
	static const float ps8[5] = {
		1.1420736694e+02,					/* 0x42e46a2c */
		3.6509309082e+03,					/* 0x45642ee5 */
		3.6956207031e+04,					/* 0x47105c35 */
		9.7602796875e+04,					/* 0x47bea166 */
		3.0804271484e+04					/* 0x46f0a88b */
	};
	
	static const float pr5[6] = {			/* for x in [8,4.5454]=1/[0.125,0.22001] */
		1.3199052094e-11,					/* 0x2d68333f */
		1.1718749255e-01,					/* 0x3defffff */
		6.8027510643e+00,					/* 0x40d9b023 */
		1.0830818176e+02,					/* 0x42d89dca */
		5.1763616943e+02,					/* 0x440168b7 */
		5.2871520996e+02					/* 0x44042dc6 */
	};
	
	static const float ps5[5] = {
		5.9280597687e+01,					/* 0x426d1f55 */
		9.9140142822e+02,					/* 0x4477d9b1 */
		5.3532670898e+03,					/* 0x45a74a23 */
		7.8446904297e+03,					/* 0x45f52586 */
		1.5040468750e+03					/* 0x44bc0180 */
	};
	
	static const float pr3[6] = {
		3.0250391081e-09,					/* 0x314fe10d */
		1.1718686670e-01,					/* 0x3defffab */
		3.9329774380e+00,					/* 0x407bb5e7 */
		3.5119403839e+01,					/* 0x420c7a45 */
		9.1055007935e+01,					/* 0x42b61c2a */
		4.8559066772e+01					/* 0x42423c7c */
	};
	
	static const float ps3[5] = {
		3.4791309357e+01,					/* 0x420b2a4d */
		3.3676245117e+02,					/* 0x43a86198 */
		1.0468714600e+03,					/* 0x4482dbe3 */
		8.9081134033e+02,					/* 0x445eb3ed */
		1.0378793335e+02					/* 0x42cf936c */
	};
	
	static const float pr2[6] = {			/* for x in [2.8570,2]=1/[0.3499,0.5] */
		1.0771083225e-07,					/* 0x33e74ea8 */
		1.1717621982e-01,					/* 0x3deffa16 */
		2.3685150146e+00,					/* 0x401795c0 */
		1.2242610931e+01,					/* 0x4143e1bc */
		1.7693971634e+01,					/* 0x418d8d41 */
		5.0735230446e+00					/* 0x40a25a4d */
	};
	
	static const float ps2[5] = {
		2.1436485291e+01,					/* 0x41ab7dec */
		1.2529022980e+02,					/* 0x42fa9499 */
		2.3227647400e+02,					/* 0x436846c7 */
		1.1767937469e+02,					/* 0x42eb5bd7 */
		8.3646392822e+00					/* 0x4105d590 */
	};
	
	GET_FLOAT_WORD(ix, x);
	ix &= IC(0x7fffffff);
	if (ix >= IC(0x41000000))
	{
		p = pr8;
		q = ps8;
	} else if (ix >= IC(0x40f71c58))
	{
		p = pr5;
		q = ps5;
	} else if (ix >= IC(0x4036db68))
	{
		p = pr3;
		q = ps3;
	} else /* if (ix >= IC(0x40000000)) */
	{
		p = pr2;
		q = ps2;
	}
	z = one / (x * x);
	r = p[0] + z * (p[1] + z * (p[2] + z * (p[3] + z * (p[4] + z * p[5]))));
	s = one + z * (q[0] + z * (q[1] + z * (q[2] + z * (q[3] + z * q[4]))));
	return one + r / s;
}


float __j1_y1_qonef(float x)
{
	const float *p, *q;
	float s, r, z;
	int32_t ix;

	static const float one = 1.0;

	/* For x >= 8, the asymptotic expansions of qone is
	 *	3/8 s - 105/1024 s^3 - ..., where s = 1/x.
	 * We approximate qone by
	 *	qone(x) = s*(0.375 + (R/S))
	 * where  R = qr1*s^2 + qr2*s^4 + ... + qr5*s^10
	 *	  S = 1 + qs1*s^2 + ... + qs6*s^12
	 * and
	 *	| qone(x)/s -0.375-R/S | <= 2  ** ( -61.13)
	 */
	
	static const float qr8[6] = {			/* for x in [inf, 8]=1/[0,0.125] */
		0.0000000000e+00,					/* 0x00000000 */
		-1.0253906250e-01,					/* 0xbdd20000 */
		-1.6271753311e+01,					/* 0xc1822c8d */
		-7.5960174561e+02,					/* 0xc43de683 */
		-1.1849806641e+04,					/* 0xc639273a */
		-4.8438511719e+04					/* 0xc73d3683 */
	};
	
	static const float qs8[6] = {
		1.6139537048e+02,					/* 0x43216537 */
		7.8253862305e+03,					/* 0x45f48b17 */
		1.3387534375e+05,					/* 0x4802bcd6 */
		7.1965775000e+05,					/* 0x492fb29c */
		6.6660125000e+05,					/* 0x4922be94 */
		-2.9449025000e+05					/* 0xc88fcb48 */
	};
	
	static const float qr5[6] = {			/* for x in [8,4.5454]=1/[0.125,0.22001] */
		-2.0897993405e-11,					/* 0xadb7d219 */
		-1.0253904760e-01,					/* 0xbdd1fffe */
		-8.0564479828e+00,					/* 0xc100e736 */
		-1.8366960144e+02,					/* 0xc337ab6b */
		-1.3731937256e+03,					/* 0xc4aba633 */
		-2.6124443359e+03					/* 0xc523471c */
	};
	
	static const float qs5[6] = {
		8.1276550293e+01,					/* 0x42a28d98 */
		1.9917987061e+03,					/* 0x44f8f98f */
		1.7468484375e+04,					/* 0x468878f8 */
		4.9851425781e+04,					/* 0x4742bb6d */
		2.7948074219e+04,					/* 0x46da5826 */
		-4.7191835938e+03					/* 0xc5937978 */
	};
	
	static const float qr3[6] = {
		-5.0783124372e-09,					/* 0xb1ae7d4f */
		-1.0253783315e-01,					/* 0xbdd1ff5b */
		-4.6101160049e+00,					/* 0xc0938612 */
		-5.7847221375e+01,					/* 0xc267638e */
		-2.2824453735e+02,					/* 0xc3643e9a */
		-2.1921012878e+02					/* 0xc35b35cb */
	};
	
	static const float qs3[6] = {
		4.7665153503e+01,					/* 0x423ea91e */
		6.7386511230e+02,					/* 0x4428775e */
		3.3801528320e+03,					/* 0x45534272 */
		5.5477290039e+03,					/* 0x45ad5dd5 */
		1.9031191406e+03,					/* 0x44ede3d0 */
		-1.3520118713e+02					/* 0xc3073381 */
	};
	
	static const float qr2[6] = {			/* for x in [2.8570,2]=1/[0.3499,0.5] */
		-1.7838172539e-07,					/* 0xb43f8932 */
		-1.0251704603e-01,					/* 0xbdd1f475 */
		-2.7522056103e+00,					/* 0xc0302423 */
		-1.9663616180e+01,					/* 0xc19d4f16 */
		-4.2325313568e+01,					/* 0xc2294d1f */
		-2.1371921539e+01					/* 0xc1aaf9b2 */
	};
	
	static const float qs2[6] = {
		2.9533363342e+01,					/* 0x41ec4454 */
		2.5298155212e+02,					/* 0x437cfb47 */
		7.5750280762e+02,					/* 0x443d602e */
		7.3939318848e+02,					/* 0x4438d92a */
		1.5594900513e+02,					/* 0x431bf2f2 */
		-4.9594988823e+00					/* 0xc09eb437 */
	};
	
	GET_FLOAT_WORD(ix, x);
	ix &= IC(0x7fffffff);
	if (ix >= IC(0x40200000))
	{
		p = qr8;
		q = qs8;
	} else if (ix >= IC(0x40f71c58))
	{
		p = qr5;
		q = qs5;
	} else if (ix >= IC(0x4036db68))
	{
		p = qr3;
		q = qs3;
	} else /* if (ix >= IC(0x40000000)) */
	{
		p = qr2;
		q = qs2;
	}
	z = one / (x * x);
	r = p[0] + z * (p[1] + z * (p[2] + z * (p[3] + z * (p[4] + z * p[5]))));
	s = one + z * (q[0] + z * (q[1] + z * (q[2] + z * (q[3] + z * (q[4] + z * q[5])))));
	return (.375f + r / s) / x;
}

```

`s_ponel.c`:

```c
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

long double __j1_y1_ponel(long double x)
{
	const long double *p, *q;
	long double z, r, s;
	int32_t ix;
	uint32_t se, i0, i1;

	static const long double one = 1.0L;

	/* For x >= 8, the asymptotic expansions of pone is
	 *	1 + 15/128 s^2 - 4725/2^15 s^4 - ...,	where s = 1/x.
	 * We approximate pone by
	 *	pone(x) = 1 + (R/S)
	 */
	/* J1(x) cosX + Y1(x) sinX  =  sqrt( 2/(pi x)) P1(x)
	   P1(x) = 1 + z^2 R(z^2), z=1/x
	   8 <= x <= inf  (0 <= z <= 0.125)
	   Peak relative error 5.2e-22  */
	static const long double pr8[7] = {
		8.402048819032978959298664869941375143163E-9L,
		1.813743245316438056192649247507255996036E-6L,
		1.260704554112906152344932388588243836276E-4L,
		3.439294839869103014614229832700986965110E-3L,
		3.576910849712074184504430254290179501209E-2L,
		1.131111483254318243139953003461511308672E-1L,
		4.480715825681029711521286449131671880953E-2L
	};
	
	static const long double ps8[6] = {
		7.169748325574809484893888315707824924354E-8L,
		1.556549720596672576431813934184403614817E-5L,
		1.094540125521337139209062035774174565882E-3L,
		3.060978962596642798560894375281428805840E-2L,
		3.374146536087205506032643098619414507024E-1L,
		1.253830208588979001991901126393231302559E0L
		/* 1.000000000000000000000000000000000000000E0L, */
	};
	
	/* J1(x) cosX + Y1(x) sinX  =  sqrt( 2/(pi x)) P1(x)
	   P1(x) = 1 + z^2 R(z^2), z=1/x
	   4.54541015625 <= x <= 8
	   Peak relative error 7.7e-22  */
	static const long double pr5[7] = {
		4.318486887948814529950980396300969247900E-7L,
		4.715341880798817230333360497524173929315E-5L,
		1.642719430496086618401091544113220340094E-3L,
		2.228688005300803935928733750456396149104E-2L,
		1.142773760804150921573259605730018327162E-1L,
		1.755576530055079253910829652698703791957E-1L,
		3.218803858282095929559165965353784980613E-2L
	};
	
	static const long double ps5[6] = {
		3.685108812227721334719884358034713967557E-6L,
		4.069102509511177498808856515005792027639E-4L,
		1.449728676496155025507893322405597039816E-2L,
		2.058869213229520086582695850441194363103E-1L,
		1.164890985918737148968424972072751066553E0L,
		2.274776933457009446573027260373361586841E0L
		/*  1.000000000000000000000000000000000000000E0L, */
	};
	

	/* J1(x) cosX + Y1(x) sinX  =  sqrt( 2/(pi x)) P1(x)
	   P1(x) = 1 + z^2 R(z^2), z=1/x
	   2.85711669921875 <= x <= 4.54541015625
	   Peak relative error 6.5e-21  */
	static const long double pr3[7] = {
		1.265251153957366716825382654273326407972E-5L,
		8.031057269201324914127680782288352574567E-4L,
		1.581648121115028333661412169396282881035E-2L,
		1.179534658087796321928362981518645033967E-1L,
		3.227936912780465219246440724502790727866E-1L,
		2.559223765418386621748404398017602935764E-1L,
		2.277136933287817911091370397134882441046E-2L
	};
	
	static const long double ps3[6] = {
		1.079681071833391818661952793568345057548E-4L,
		6.986017817100477138417481463810841529026E-3L,
		1.429403701146942509913198539100230540503E-1L,
		1.148392024337075609460312658938700765074E0L,
		3.643663015091248720208251490291968840882E0L,
		3.990702269032018282145100741746633960737E0L
		/* 1.000000000000000000000000000000000000000E0L, */
	};
	
	/* J1(x) cosX + Y1(x) sinX  =  sqrt( 2/(pi x)) P1(x)
	   P1(x) = 1 + z^2 R(z^2), z=1/x
	   2 <= x <= 2.85711669921875
	   Peak relative error 3.5e-21  */
	static const long double pr2[7] = {
		2.795623248568412225239401141338714516445E-4L,
		1.092578168441856711925254839815430061135E-2L,
		1.278024620468953761154963591853679640560E-1L,
		5.469680473691500673112904286228351988583E-1L,
		8.313769490922351300461498619045639016059E-1L,
		3.544176317308370086415403567097130611468E-1L,
		1.604142674802373041247957048801599740644E-2L
	};
	
	static const long double ps2[6] = {
		2.385605161555183386205027000675875235980E-3L,
		9.616778294482695283928617708206967248579E-2L,
		1.195215570959693572089824415393951258510E0L,
		5.718412857897054829999458736064922974662E0L,
		1.065626298505499086386584642761602177568E1L,
		6.809140730053382188468983548092322151791E0L
		/* 1.000000000000000000000000000000000000000E0L, */
	};
	
	GET_LDOUBLE_WORDS(se, i0, i1, x);
	ix = se & 0x7fff;
	if (ix >= 0x4002)					/* x >= 8 */
	{
		p = pr8;
		q = ps8;
	} else
	{
		i1 = (ix << 16) | (i0 >> 16);
		if (i1 >= UC(0x40019174))			/* x >= 4.54541015625 */
		{
			p = pr5;
			q = ps5;
		} else if (i1 >= UC(0x4000b6db))	/* x >= 2.85711669921875 */
		{
			p = pr3;
			q = ps3;
		} else /* if (ix >= 0x4000) */		/* x better be >= 2 */
		{
			p = pr2;
			q = ps2;
		}
	}
	z = one / (x * x);
	r = p[0] + z * (p[1] + z * (p[2] + z * (p[3] + z * (p[4] + z * (p[5] + z * p[6])))));
	s = q[0] + z * (q[1] + z * (q[2] + z * (q[3] + z * (q[4] + z * (q[5] + z)))));
	return one + z * r / s;
}


long double __j1_y1_qonel(long double x)
{
	const long double *p, *q;
	long double s, r, z;
	int32_t ix;
	uint32_t se, i0, i1;

	static const long double one = 1.0L;

	/* For x >= 8, the asymptotic expansions of qone is
	 *	3/8 s - 105/1024 s^3 - ..., where s = 1/x.
	 * We approximate qone by
	 *	qone(x) = s*(0.375 + (R/S))
	 */
	
	/* Y1(x)cosX - J1(x)sinX = sqrt( 2/(pi x)) Q1(x),
	   Q1(x) = z(.375 + z^2 R(z^2)), z=1/x
	   8 <= x <= inf
	   Peak relative error 8.3e-22 */
	
	static const long double qr8[7] = {
		-5.691925079044209246015366919809404457380E-10L,
		-1.632587664706999307871963065396218379137E-7L,
		-1.577424682764651970003637263552027114600E-5L,
		-6.377627959241053914770158336842725291713E-4L,
		-1.087408516779972735197277149494929568768E-2L,
		-6.854943629378084419631926076882330494217E-2L,
		-1.055448290469180032312893377152490183203E-1L
	};
	
	static const long double qs8[7] = {
		5.550982172325019811119223916998393907513E-9L,
		1.607188366646736068460131091130644192244E-6L,
		1.580792530091386496626494138334505893599E-4L,
		6.617859900815747303032860443855006056595E-3L,
		1.212840547336984859952597488863037659161E-1L,
		9.017885953937234900458186716154005541075E-1L,
		2.201114489712243262000939120146436167178E0L
		/* 1.000000000000000000000000000000000000000E0L, */
	};
	
	/* Y1(x)cosX - J1(x)sinX = sqrt( 2/(pi x)) Q1(x),
	   Q1(x) = z(.375 + z^2 R(z^2)), z=1/x
	   4.54541015625 <= x <= 8
	   Peak relative error 4.1e-22 */
	static const long double qr5[7] = {
		-6.719134139179190546324213696633564965983E-8L,
		-9.467871458774950479909851595678622044140E-6L,
		-4.429341875348286176950914275723051452838E-4L,
		-8.539898021757342531563866270278505014487E-3L,
		-6.818691805848737010422337101409276287170E-2L,
		-1.964432669771684034858848142418228214855E-1L,
		-1.333896496989238600119596538299938520726E-1L
	};
	
	static const long double qs5[7] = {
		6.552755584474634766937589285426911075101E-7L,
		9.410814032118155978663509073200494000589E-5L,
		4.561677087286518359461609153655021253238E-3L,
		9.397742096177905170800336715661091535805E-2L,
		8.518538116671013902180962914473967738771E-1L,
		3.177729183645800174212539541058292579009E0L,
		4.006745668510308096259753538973038902990E0L
		/* 1.000000000000000000000000000000000000000E0L, */
	};
	
	/* Y1(x)cosX - J1(x)sinX = sqrt( 2/(pi x)) Q1(x),
	   Q1(x) = z(.375 + z^2 R(z^2)), z=1/x
	   2.85711669921875 <= x <= 4.54541015625
	   Peak relative error 2.2e-21 */
	static const long double qr3[7] = {
		-3.618746299358445926506719188614570588404E-6L,
		-2.951146018465419674063882650970344502798E-4L,
		-7.728518171262562194043409753656506795258E-3L,
		-8.058010968753999435006488158237984014883E-2L,
		-3.356232856677966691703904770937143483472E-1L,
		-4.858192581793118040782557808823460276452E-1L,
		-1.592399251246473643510898335746432479373E-1L
	};
	
	static const long double qs3[7] = {
		3.529139957987837084554591421329876744262E-5L,
		2.973602667215766676998703687065066180115E-3L,
		8.273534546240864308494062287908662592100E-2L,
		9.613359842126507198241321110649974032726E-1L,
		4.853923697093974370118387947065402707519E0L,
		1.002671608961669247462020977417828796933E1L,
		7.028927383922483728931327850683151410267E0L
		/* 1.000000000000000000000000000000000000000E0L, */
	};
	
	/* Y1(x)cosX - J1(x)sinX = sqrt( 2/(pi x)) Q1(x),
	   Q1(x) = z(.375 + z^2 R(z^2)), z=1/x
	   2 <= x <= 2.85711669921875
	   Peak relative error 6.9e-22 */
	static const long double qr2[7] = {
		-1.372751603025230017220666013816502528318E-4L,
		-6.879190253347766576229143006767218972834E-3L,
		-1.061253572090925414598304855316280077828E-1L,
		-6.262164224345471241219408329354943337214E-1L,
		-1.423149636514768476376254324731437473915E0L,
		-1.087955310491078933531734062917489870754E0L,
		-1.826821119773182847861406108689273719137E-1L
	};
	
	static const long double qs2[7] = {
		1.338768933634451601814048220627185324007E-3L,
		7.071099998918497559736318523932241901810E-2L,
		1.200511429784048632105295629933382142221E0L,
		8.327301713640367079030141077172031825276E0L,
		2.468479301872299311658145549931764426840E1L,
		2.961179686096262083509383820557051621644E1L,
		1.201402313144305153005639494661767354977E1L
		/* 1.000000000000000000000000000000000000000E0L, */
	};
	

	GET_LDOUBLE_WORDS(se, i0, i1, x);
	ix = se & 0x7fff;
	if (ix >= 0x4002)					/* x >= 8 */
	{
		p = qr8;
		q = qs8;
	} else
	{
		i1 = (ix << 16) | (i0 >> 16);
		if (i1 >= UC(0x40019174))			/* x >= 4.54541015625 */
		{
			p = qr5;
			q = qs5;
		} else if (i1 >= UC(0x4000b6db))	/* x >= 2.85711669921875 */
		{
			p = qr3;
			q = qs3;
		} else /* if (ix >= 0x4000) */		/* x better be >= 2 */
		{
			p = qr2;
			q = qs2;
		}
	}
	z = one / (x * x);
	r = p[0] + z * (p[1] + z * (p[2] + z * (p[3] + z * (p[4] + z * (p[5] + z * p[6])))));
	s = q[0] + z * (q[1] + z * (q[2] + z * (q[3] + z * (q[4] + z * (q[5] + z * (q[6] + z))))));
	return (.375 + z * r / s) / x;
}

#endif

```

`s_pzero.c`:

```c
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

double __j0_y0_pzero(double x)
{
	const double *p, *q;
	double z, r, s, z2, z4, r1, r2, r3, s1, s2, s3;
	int32_t ix;

	static const double one = 1.0;

	/* The asymptotic expansions of pzero is
	 *	1 - 9/128 s^2 + 11025/98304 s^4 - ...,	where s = 1/x.
	 * For x >= 2, We approximate pzero by
	 *  pzero(x) = 1 + (R/S)
	 * where  R = pR0 + pR1*s^2 + pR2*s^4 + ... + pR5*s^10
	 *	  S = 1 + pS0*s^2 + ... + pS4*s^10
	 * and
	 *	| pzero(x)-1-R/S | <= 2  ** ( -60.26)
	 */
	static const double pR8[6] = {			/* for x in [inf, 8]=1/[0,0.125] */
		0.00000000000000000000e+00,			/* 0x00000000, 0x00000000 */
		-7.03124999999900357484e-02,		/* 0xBFB1FFFF, 0xFFFFFD32 */
		-8.08167041275349795626e+00,		/* 0xC02029D0, 0xB44FA779 */
		-2.57063105679704847262e+02,		/* 0xC0701102, 0x7B19E863 */
		-2.48521641009428822144e+03,		/* 0xC0A36A6E, 0xCD4DCAFC */
		-5.25304380490729545272e+03			/* 0xC0B4850B, 0x36CC643D */
	};

	static const double pS8[5] = {
		1.16534364619668181717e+02,			/* 0x405D2233, 0x07A96751 */
		3.83374475364121826715e+03,			/* 0x40ADF37D, 0x50596938 */
		4.05978572648472545552e+04,			/* 0x40E3D2BB, 0x6EB6B05F */
		1.16752972564375915681e+05,			/* 0x40FC810F, 0x8F9FA9BD */
		4.76277284146730962675e+04			/* 0x40E74177, 0x4F2C49DC */
	};

	static const double pR5[6] = {			/* for x in [8,4.5454]=1/[0.125,0.22001] */
		-1.14125464691894502584e-11,		/* 0xBDA918B1, 0x47E495CC */
		-7.03124940873599280078e-02,		/* 0xBFB1FFFF, 0xE69AFBC6 */
		-4.15961064470587782438e+00,		/* 0xC010A370, 0xF90C6BBF */
		-6.76747652265167261021e+01,		/* 0xC050EB2F, 0x5A7D1783 */
		-3.31231299649172967747e+02,		/* 0xC074B3B3, 0x6742CC63 */
		-3.46433388365604912451e+02			/* 0xC075A6EF, 0x28A38BD7 */
	};

	static const double pS5[5] = {
		6.07539382692300335975e+01,			/* 0x404E6081, 0x0C98C5DE */
		1.05125230595704579173e+03,			/* 0x40906D02, 0x5C7E2864 */
		5.97897094333855784498e+03,			/* 0x40B75AF8, 0x8FBE1D60 */
		9.62544514357774460223e+03,			/* 0x40C2CCB8, 0xFA76FA38 */
		2.40605815922939109441e+03			/* 0x40A2CC1D, 0xC70BE864 */
	};

	static const double pR3[6] = {			/* for x in [4.547,2.8571]=1/[0.2199,0.35001] */
		-2.54704601771951915620e-09,		/* 0xBE25E103, 0x6FE1AA86 */
		-7.03119616381481654654e-02,		/* 0xBFB1FFF6, 0xF7C0E24B */
		-2.40903221549529611423e+00,		/* 0xC00345B2, 0xAEA48074 */
		-2.19659774734883086467e+01,		/* 0xC035F74A, 0x4CB94E14 */
		-5.80791704701737572236e+01,		/* 0xC04D0A22, 0x420A1A45 */
		-3.14479470594888503854e+01			/* 0xC03F72AC, 0xA892D80F */
	};

	static const double pS3[5] = {
		3.58560338055209726349e+01,			/* 0x4041ED92, 0x84077DD3 */
		3.61513983050303863820e+02,			/* 0x40769839, 0x464A7C0E */
		1.19360783792111533330e+03,			/* 0x4092A66E, 0x6D1061D6 */
		1.12799679856907414432e+03,			/* 0x40919FFC, 0xB8C39B7E */
		1.73580930813335754692e+02			/* 0x4065B296, 0xFC379081 */
	};

	static const double pR2[6] = {			/* for x in [2.8570,2]=1/[0.3499,0.5] */
		-8.87534333032526411254e-08,		/* 0xBE77D316, 0xE927026D */
		-7.03030995483624743247e-02,		/* 0xBFB1FF62, 0x495E1E42 */
		-1.45073846780952986357e+00,		/* 0xBFF73639, 0x8A24A843 */
		-7.63569613823527770791e+00,		/* 0xC01E8AF3, 0xEDAFA7F3 */
		-1.11931668860356747786e+01,		/* 0xC02662E6, 0xC5246303 */
		-3.23364579351335335033e+00			/* 0xC009DE81, 0xAF8FE70F */
	};

	static const double pS2[5] = {
		2.22202997532088808441e+01,			/* 0x40363865, 0x908B5959 */
		1.36206794218215208048e+02,			/* 0x4061069E, 0x0EE8878F */
		2.70470278658083486789e+02,			/* 0x4070E786, 0x42EA079B */
		1.53875394208320329881e+02,			/* 0x40633C03, 0x3AB6FAFF */
		1.46576176948256193810e+01			/* 0x402D50B3, 0x44391809 */
	};

	GET_HIGH_WORD(ix, x);
	ix &= IC(0x7fffffff);
	if (ix >= IC(0x41b00000))
	{
		/* x >= 2**28 */
		return one;
	} else if (ix >= IC(0x40200000))
	{
		/* x >= 8 */
		p = pR8;
		q = pS8;
	} else if (ix >= IC(0x40122E8B))
	{
		/* x >= 4.545452117919921875 */
		p = pR5;
		q = pS5;
	} else if (ix >= IC(0x4006DB6D))
	{
		/* x >= 2.8571414947509765625 */
		p = pR3;
		q = pS3;
	} else /* if (ix >= IC(0x40000000)) */
	{
		/* x >= 2 */
		p = pR2;
		q = pS2;
	}
	z = one / (x * x);
#ifdef DO_NOT_USE_THIS
	r = p[0] + z * (p[1] + z * (p[2] + z * (p[3] + z * (p[4] + z * p[5]))));
	s = one + z * (q[0] + z * (q[1] + z * (q[2] + z * (q[3] + z * q[4]))));
#else
	r1 = p[0] + z * p[1];
	z2 = z * z;
	r2 = p[2] + z * p[3];
	z4 = z2 * z2;
	r3 = p[4] + z * p[5];
	r = r1 + z2 * r2 + z4 * r3;
	s1 = one + z * q[0];
	s2 = q[1] + z * q[2];
	s3 = q[3] + z * q[4];
	s = s1 + z2 * s2 + z4 * s3;
#endif
	return one + r / s;
}


double __j0_y0_qzero(double x)
{
	const double *p, *q;
	double s, r, z, z2, z4, z6, r1, r2, r3, s1, s2, s3;
	int32_t ix;

	static const double one = 1.0;

	/* For x >= 8, the asymptotic expansions of qzero is
	 *	-1/8 s + 75/1024 s^3 - ..., where s = 1/x.
	 * We approximate pzero by
	 *	qzero(x) = s*(-1.25 + (R/S))
	 * where  R = qR0 + qR1*s^2 + qR2*s^4 + ... + qR5*s^10
	 *  S = 1 + qS0*s^2 + ... + qS5*s^12
	 * and
	 *	| qzero(x)/s +1.25-R/S | <= 2  ** ( -61.22)
	 */
	static const double qR8[6] = {			/* for x in [inf, 8]=1/[0,0.125] */
		0.00000000000000000000e+00,			/* 0x00000000, 0x00000000 */
		7.32421874999935051953e-02,			/* 0x3FB2BFFF, 0xFFFFFE2C */
		1.17682064682252693899e+01,			/* 0x40278952, 0x5BB334D6 */
		5.57673380256401856059e+02,			/* 0x40816D63, 0x15301825 */
		8.85919720756468632317e+03,			/* 0x40C14D99, 0x3E18F46D */
		3.70146267776887834771e+04			/* 0x40E212D4, 0x0E901566 */
	};

	static const double qS8[6] = {
		1.63776026895689824414e+02,			/* 0x406478D5, 0x365B39BC */
		8.09834494656449805916e+03,			/* 0x40BFA258, 0x4E6B0563 */
		1.42538291419120476348e+05,			/* 0x41016652, 0x54D38C3F */
		8.03309257119514397345e+05,			/* 0x412883DA, 0x83A52B43 */
		8.40501579819060512818e+05,			/* 0x4129A66B, 0x28DE0B3D */
		-3.43899293537866615225e+05			/* 0xC114FD6D, 0x2C9530C5 */
	};

	static const double qR5[6] = {			/* for x in [8,4.5454]=1/[0.125,0.22001] */
		1.84085963594515531381e-11,			/* 0x3DB43D8F, 0x29CC8CD9 */
		7.32421766612684765896e-02,			/* 0x3FB2BFFF, 0xD172B04C */
		5.83563508962056953777e+00,			/* 0x401757B0, 0xB9953DD3 */
		1.35111577286449829671e+02,			/* 0x4060E392, 0x0A8788E9 */
		1.02724376596164097464e+03,			/* 0x40900CF9, 0x9DC8C481 */
		1.98997785864605384631e+03			/* 0x409F17E9, 0x53C6E3A6 */
	};

	static const double qS5[6] = {
		8.27766102236537761883e+01,			/* 0x4054B1B3, 0xFB5E1543 */
		2.07781416421392987104e+03,			/* 0x40A03BA0, 0xDA21C0CE */
		1.88472887785718085070e+04,			/* 0x40D267D2, 0x7B591E6D */
		5.67511122894947329769e+04,			/* 0x40EBB5E3, 0x97E02372 */
		3.59767538425114471465e+04,			/* 0x40E19118, 0x1F7A54A0 */
		-5.35434275601944773371e+03			/* 0xC0B4EA57, 0xBEDBC609 */
	};

	static const double qR3[6] = {			/* for x in [4.547,2.8571]=1/[0.2199,0.35001] */
		4.37741014089738620906e-09,			/* 0x3E32CD03, 0x6ADECB82 */
		7.32411180042911447163e-02,			/* 0x3FB2BFEE, 0x0E8D0842 */
		3.34423137516170720929e+00,			/* 0x400AC0FC, 0x61149CF5 */
		4.26218440745412650017e+01,			/* 0x40454F98, 0x962DAEDD */
		1.70808091340565596283e+02,			/* 0x406559DB, 0xE25EFD1F */
		1.66733948696651168575e+02			/* 0x4064D77C, 0x81FA21E0 */
	};

	static const double qS3[6] = {
		4.87588729724587182091e+01,			/* 0x40486122, 0xBFE343A6 */
		7.09689221056606015736e+02,			/* 0x40862D83, 0x86544EB3 */
		3.70414822620111362994e+03,			/* 0x40ACF04B, 0xE44DFC63 */
		6.46042516752568917582e+03,			/* 0x40B93C6C, 0xD7C76A28 */
		2.51633368920368957333e+03,			/* 0x40A3A8AA, 0xD94FB1C0 */
		-1.49247451836156386662e+02			/* 0xC062A7EB, 0x201CF40F */
	};

	static const double qR2[6] = {			/* for x in [2.8570,2]=1/[0.3499,0.5] */
		1.50444444886983272379e-07,			/* 0x3E84313B, 0x54F76BDB */
		7.32234265963079278272e-02,			/* 0x3FB2BEC5, 0x3E883E34 */
		1.99819174093815998816e+00,			/* 0x3FFFF897, 0xE727779C */
		1.44956029347885735348e+01,			/* 0x402CFDBF, 0xAAF96FE5 */
		3.16662317504781540833e+01,			/* 0x403FAA8E, 0x29FBDC4A */
		1.62527075710929267416e+01			/* 0x403040B1, 0x71814BB4 */
	};

	static const double qS2[6] = {
		3.03655848355219184498e+01,			/* 0x403E5D96, 0xF7C07AED */
		2.69348118608049844624e+02,			/* 0x4070D591, 0xE4D14B40 */
		8.44783757595320139444e+02,			/* 0x408A6645, 0x22B3BF22 */
		8.82935845112488550512e+02,			/* 0x408B977C, 0x9C5CC214 */
		2.12666388511798828631e+02,			/* 0x406A9553, 0x0E001365 */
		-5.31095493882666946917e+00			/* 0xC0153E6A, 0xF8B32931 */
	};

	GET_HIGH_WORD(ix, x);
	ix &= IC(0x7fffffff);
	if (ix >= IC(0x41b00000))
	{
		/* x >= 2**28 */
		return -.125 / x;
	} else if (ix >= IC(0x40200000))
	{
		/* x >= 8 */
		p = qR8;
		q = qS8;
	} else if (ix >= IC(0x40122E8B))
	{
		/* x >= 4.545452117919921875 */
		p = qR5;
		q = qS5;
	} else if (ix >= IC(0x4006DB6D))
	{
		/* x >= 2.8571414947509765625 */
		p = qR3;
		q = qS3;
	} else /* if (ix >= IC(0x40000000)) */
	{
		/* x >= 2 */
		p = qR2;
		q = qS2;
	}
	z = one / (x * x);
#ifdef DO_NOT_USE_THIS
	r = p[0] + z * (p[1] + z * (p[2] + z * (p[3] + z * (p[4] + z * p[5]))));
	s = one + z * (q[0] + z * (q[1] + z * (q[2] + z * (q[3] + z * (q[4] + z * q[5])))));
#else
	r1 = p[0] + z * p[1];
	z2 = z * z;
	r2 = p[2] + z * p[3];
	z4 = z2 * z2;
	r3 = p[4] + z * p[5];
	z6 = z4 * z2;
	r = r1 + z2 * r2 + z4 * r3;
	s1 = one + z * q[0];
	s2 = q[1] + z * q[2];
	s3 = q[3] + z * q[4];
	s = s1 + z2 * s2 + z4 * s3 + z6 * q[5];
#endif
	return (-.125 + r / s) / x;
}

```

`s_pzerof.c`:

```c
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif


float __j0_y0_pzerof(float x)
{
	const float *p, *q;
	float z, r, s;
	int32_t ix;

	static const float one = 1.0;

	/* The asymptotic expansions of pzero is
	 *	1 - 9/128 s^2 + 11025/98304 s^4 - ...,	where s = 1/x.
	 * For x >= 2, We approximate pzero by
	 *	pzero(x) = 1 + (R/S)
	 * where  R = pR0 + pR1*s^2 + pR2*s^4 + ... + pR5*s^10
	 *	  S = 1 + pS0*s^2 + ... + pS4*s^10
	 * and
	 *	| pzero(x)-1-R/S | <= 2  ** ( -60.26)
	 */
	static const float pR8[6] = {			/* for x in [inf, 8]=1/[0,0.125] */
		0.0000000000e+00,					/* 0x00000000 */
		-7.0312500000e-02,					/* 0xbd900000 */
		-8.0816707611e+00,					/* 0xc1014e86 */
		-2.5706311035e+02,					/* 0xc3808814 */
		-2.4852163086e+03,					/* 0xc51b5376 */
		-5.2530439453e+03					/* 0xc5a4285a */
	};

	static const float pS8[5] = {
		1.1653436279e+02,					/* 0x42e91198 */
		3.8337448730e+03,					/* 0x456f9beb */
		4.0597855469e+04,					/* 0x471e95db */
		1.1675296875e+05,					/* 0x47e4087c */
		4.7627726562e+04					/* 0x473a0bba */
	};

	static const float pR5[6] = {			/* for x in [8,4.5454]=1/[0.125,0.22001] */
		-1.1412546255e-11,					/* 0xad48c58a */
		-7.0312492549e-02,					/* 0xbd8fffff */
		-4.1596107483e+00,					/* 0xc0851b88 */
		-6.7674766541e+01,					/* 0xc287597b */
		-3.3123129272e+02,					/* 0xc3a59d9b */
		-3.4643338013e+02					/* 0xc3ad3779 */
	};

	static const float pS5[5] = {
		6.0753936768e+01,					/* 0x42730408 */
		1.0512523193e+03,					/* 0x44836813 */
		5.9789707031e+03,					/* 0x45bad7c4 */
		9.6254453125e+03,					/* 0x461665c8 */
		2.4060581055e+03					/* 0x451660ee */
	};

	static const float pR3[6] = {			/* for x in [4.547,2.8571]=1/[0.2199,0.35001] */
		-2.5470459075e-09,					/* 0xb12f081b */
		-7.0311963558e-02,					/* 0xbd8fffb8 */
		-2.4090321064e+00,					/* 0xc01a2d95 */
		-2.1965976715e+01,					/* 0xc1afba52 */
		-5.8079170227e+01,					/* 0xc2685112 */
		-3.1447946548e+01					/* 0xc1fb9565 */
	};

	static const float pS3[5] = {
		3.5856033325e+01,					/* 0x420f6c94 */
		3.6151397705e+02,					/* 0x43b4c1ca */
		1.1936077881e+03,					/* 0x44953373 */
		1.1279968262e+03,					/* 0x448cffe6 */
		1.7358093262e+02					/* 0x432d94b8 */
	};

	static const float pR2[6] = {			/* for x in [2.8570,2]=1/[0.3499,0.5] */
		-8.8753431271e-08,					/* 0xb3be98b7 */
		-7.0303097367e-02,					/* 0xbd8ffb12 */
		-1.4507384300e+00,					/* 0xbfb9b1cc */
		-7.6356959343e+00,					/* 0xc0f4579f */
		-1.1193166733e+01,					/* 0xc1331736 */
		-3.2336456776e+00					/* 0xc04ef40d */
	};

	static const float pS2[5] = {
		2.2220300674e+01,					/* 0x41b1c32d */
		1.3620678711e+02,					/* 0x430834f0 */
		2.7047027588e+02,					/* 0x43873c32 */
		1.5387539673e+02,					/* 0x4319e01a */
		1.4657617569e+01					/* 0x416a859a */
	};

	GET_FLOAT_WORD(ix, x);
	ix &= IC(0x7fffffff);
	if (ix >= IC(0x41000000))
	{
		/* x >= 2**16 */
		p = pR8;
		q = pS8;
	} else if (ix >= IC(0x40917458))
	{
		/* x >= 4.545452117919921875 */
		p = pR5;
		q = pS5;
	} else if (ix >= IC(0x4036db68))
	{
		/* x >= 2.8571414947509765625 */
		p = pR3;
		q = pS3;
	} else /* if (ix >= IC(0x40000000)) */
	{
		/* x >= 2 */
		p = pR2;
		q = pS2;
	}
	z = one / (x * x);
	r = p[0] + z * (p[1] + z * (p[2] + z * (p[3] + z * (p[4] + z * p[5]))));
	s = one + z * (q[0] + z * (q[1] + z * (q[2] + z * (q[3] + z * q[4]))));
	return one + r / s;
}


float __j0_y0_qzerof(float x)
{
	const float *p, *q;
	float s, r, z;
	int32_t ix;

	static const float one = 1.0;

	/* For x >= 8, the asymptotic expansions of qzero is
	 *	-1/8 s + 75/1024 s^3 - ..., where s = 1/x.
	 * We approximate qzero by
	 *	qzero(x) = s*(-1.25 + (R/S))
	 * where  R = qR0 + qR1*s^2 + qR2*s^4 + ... + qR5*s^10
	 *	  S = 1 + qS0*s^2 + ... + qS5*s^12
	 * and
	 *	| qzero(x)/s +1.25-R/S | <= 2  ** ( -61.22)
	 */
	static const float qR8[6] = {			/* for x in [inf, 8]=1/[0,0.125] */
		0.0000000000e+00,					/* 0x00000000 */
		7.3242187500e-02,					/* 0x3d960000 */
		1.1768206596e+01,					/* 0x413c4a93 */
		5.5767340088e+02,					/* 0x440b6b19 */
		8.8591972656e+03,					/* 0x460a6cca */
		3.7014625000e+04					/* 0x471096a0 */
	};

	static const float qS8[6] = {
		1.6377603149e+02,					/* 0x4323c6aa */
		8.0983447266e+03,					/* 0x45fd12c2 */
		1.4253829688e+05,					/* 0x480b3293 */
		8.0330925000e+05,					/* 0x49441ed4 */
		8.4050156250e+05,					/* 0x494d3359 */
		-3.4389928125e+05					/* 0xc8a7eb69 */
	};

	static const float qR5[6] = {			/* for x in [8,4.5454]=1/[0.125,0.22001] */
		1.8408595828e-11,					/* 0x2da1ec79 */
		7.3242180049e-02,					/* 0x3d95ffff */
		5.8356351852e+00,					/* 0x40babd86 */
		1.3511157227e+02,					/* 0x43071c90 */
		1.0272437744e+03,					/* 0x448067cd */
		1.9899779053e+03					/* 0x44f8bf4b */
	};

	static const float qS5[6] = {
		8.2776611328e+01,					/* 0x42a58da0 */
		2.0778142090e+03,					/* 0x4501dd07 */
		1.8847289062e+04,					/* 0x46933e94 */
		5.6751113281e+04,					/* 0x475daf1d */
		3.5976753906e+04,					/* 0x470c88c1 */
		-5.3543427734e+03					/* 0xc5a752be */
	};

	static const float qR3[6] = {			/* for x in [4.547,2.8571]=1/[0.2199,0.35001] */
		4.3774099900e-09,					/* 0x3196681b */
		7.3241114616e-02,					/* 0x3d95ff70 */
		3.3442313671e+00,					/* 0x405607e3 */
		4.2621845245e+01,					/* 0x422a7cc5 */
		1.7080809021e+02,					/* 0x432acedf */
		1.6673394775e+02					/* 0x4326bbe4 */
	};

	static const float qS3[6] = {
		4.8758872986e+01,					/* 0x42430916 */
		7.0968920898e+02,					/* 0x44316c1c */
		3.7041481934e+03,					/* 0x4567825f */
		6.4604252930e+03,					/* 0x45c9e367 */
		2.5163337402e+03,					/* 0x451d4557 */
		-1.4924745178e+02					/* 0xc3153f59 */
	};

	static const float qR2[6] = {			/* for x in [2.8570,2]=1/[0.3499,0.5] */
		1.5044444979e-07,					/* 0x342189db */
		7.3223426938e-02,					/* 0x3d95f62a */
		1.9981917143e+00,					/* 0x3fffc4bf */
		1.4495602608e+01,					/* 0x4167edfd */
		3.1666231155e+01,					/* 0x41fd5471 */
		1.6252708435e+01					/* 0x4182058c */
	};

	static const float qS2[6] = {
		3.0365585327e+01,					/* 0x41f2ecb8 */
		2.6934811401e+02,					/* 0x4386ac8f */
		8.4478375244e+02,					/* 0x44533229 */
		8.8293585205e+02,					/* 0x445cbbe5 */
		2.1266638184e+02,					/* 0x4354aa98 */
		-5.3109550476e+00					/* 0xc0a9f358 */
	};

	GET_FLOAT_WORD(ix, x);
	ix &= IC(0x7fffffff);
	if (ix >= IC(0x41000000))
	{
		/* x >= 2**16 */
		p = qR8;
		q = qS8;
	} else if (ix >= IC(0x40917458))
	{
		/* x >= 4.545452117919921875 */
		/* x >= 4.54541015625 */
		p = qR5;
		q = qS5;
	} else if (ix >= IC(0x4036db68))
	{
		/* x >= 2.8571414947509765625 */
		p = qR3;
		q = qS3;
	} else /* if (ix >= IC(0x40000000)) */
	{
		/* x >= 2 */
		p = qR2;
		q = qS2;
	}
	z = one / (x * x);
	r = p[0] + z * (p[1] + z * (p[2] + z * (p[3] + z * (p[4] + z * p[5]))));
	s = one + z * (q[0] + z * (q[1] + z * (q[2] + z * (q[3] + z * (q[4] + z * q[5])))));
	return (-.125f + r / s) / x;
}

```

`s_pzerol.c`:

```c
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

long double __j0_y0_pzerol(long double x)
{
	const long double *p, *q;
	long double z, r, s;
	int32_t ix;
	uint32_t se, i0, i1;

	static const long double one = 1.0L;

	/* The asymptotic expansions of pzero is
	 *	1 - 9/128 s^2 + 11025/98304 s^4 - ...,	where s = 1/x.
	 * For x >= 2, We approximate pzero by
	 *	pzero(x) = 1 + s^2 R(s^2) / S(s^2)
	 */
	static const long double pR8[7] = {
		/* 8 <= x <= inf
		   Peak relative error 4.62 */
		-4.094398895124198016684337960227780260127E-9L,
		-8.929643669432412640061946338524096893089E-7L,
		-6.281267456906136703868258380673108109256E-5L,
		-1.736902783620362966354814353559382399665E-3L,
		-1.831506216290984960532230842266070146847E-2L,
		-5.827178869301452892963280214772398135283E-2L,
		-2.087563267939546435460286895807046616992E-2L
	};
	
	static const long double pS8[6] = {
		5.823145095287749230197031108839653988393E-8L,
		1.279281986035060320477759999428992730280E-5L,
		9.132668954726626677174825517150228961304E-4L,
		2.606019379433060585351880541545146252534E-2L,
		2.956262215119520464228467583516287175244E-1L,
		1.149498145388256448535563278632697465675E0L
		/* 1.000000000000000000000000000000000000000E0L, */
	};
	
	static const long double pR5[7] = {
		/* 4.54541015625 <= x <= 8
		   Peak relative error 6.51E-22 */
		-2.041226787870240954326915847282179737987E-7L,
		-2.255373879859413325570636768224534428156E-5L,
		-7.957485746440825353553537274569102059990E-4L,
		-1.093205102486816696940149222095559439425E-2L,
		-5.657957849316537477657603125260701114646E-2L,
		-8.641175552716402616180994954177818461588E-2L,
		-1.354654710097134007437166939230619726157E-2L
	};
	
	static const long double pS5[6] = {
		2.903078099681108697057258628212823545290E-6L,
		3.253948449946735405975737677123673867321E-4L,
		1.181269751723085006534147920481582279979E-2L,
		1.719212057790143888884745200257619469363E-1L,
		1.006306498779212467670654535430694221924E0L,
		2.069568808688074324555596301126375951502E0L
		/* 1.000000000000000000000000000000000000000E0L, */
	};
	
	static const long double pR3[7] = {
		/* 2.85711669921875 <= x <= 4.54541015625
		   peak relative error 5.25e-21 */
		-5.755732156848468345557663552240816066802E-6L,
		-3.703675625855715998827966962258113034767E-4L,
		-7.390893350679637611641350096842846433236E-3L,
		-5.571922144490038765024591058478043873253E-2L,
		-1.531290690378157869291151002472627396088E-1L,
		-1.193350853469302941921647487062620011042E-1L,
		-8.567802507331578894302991505331963782905E-3L
	};
	
	static const long double pS3[6] = {
		8.185931139070086158103309281525036712419E-5L,
		5.398016943778891093520574483111255476787E-3L,
		1.130589193590489566669164765853409621081E-1L,
		9.358652328786413274673192987670237145071E-1L,
		3.091711512598349056276917907005098085273E0L,
		3.594602474737921977972586821673124231111E0L
		/* 1.000000000000000000000000000000000000000E0L, */
	};
	
	static const long double pR2[7] = {
		/* 2 <= x <= 2.85711669921875
		   peak relative error 2.64e-21 */
		-1.219525235804532014243621104365384992623E-4L,
		-4.838597135805578919601088680065298763049E-3L,
		-5.732223181683569266223306197751407418301E-2L,
		-2.472947430526425064982909699406646503758E-1L,
		-3.753373645974077960207588073975976327695E-1L,
		-1.556241316844728872406672349347137975495E-1L,
		-5.355423239526452209595316733635519506958E-3L
	};
	
	static const long double pS2[6] = {
		1.734442793664291412489066256138894953823E-3L,
		7.158111826468626405416300895617986926008E-2L,
		9.153839713992138340197264669867993552641E-1L,
		4.539209519433011393525841956702487797582E0L,
		8.868932430625331650266067101752626253644E0L,
		6.067161890196324146320763844772857713502E0L
		/* 1.000000000000000000000000000000000000000E0L, */
	};
	
	GET_LDOUBLE_WORDS(se, i0, i1, x);
	ix = se & 0x7fff;
	if (ix >= 0x4002)
	{
		/* x >= 8 */
		p = pR8;
		q = pS8;
	} else
	{
		i1 = (ix << 16) | (i0 >> 16);
		if (i1 >= UC(0x40019174))
		{
			/* x >= 4.54541015625 */
			p = pR5;
			q = pS5;
		} else if (i1 >= UC(0x4000b6db))
		{
			/* x >= 2.85711669921875 */
			p = pR3;
			q = pS3;
		} else /* if (ix >= 0x4000) */
		{
			/* x >= 2 */
			p = pR2;
			q = pS2;
		}
	}
	z = one / (x * x);
	r = p[0] + z * (p[1] + z * (p[2] + z * (p[3] + z * (p[4] + z * (p[5] + z * p[6])))));
	s = q[0] + z * (q[1] + z * (q[2] + z * (q[3] + z * (q[4] + z * (q[5] + z)))));
	return (one + z * r / s);
}


long double __j0_y0_qzerol(long double x)
{
	const long double *p, *q;
	long double s, r, z;
	int32_t ix;
	uint32_t se, i0, i1;

	static const long double one = 1.0L;

	/* For x >= 8, the asymptotic expansions of qzero is
	 *	-1/8 s + 75/1024 s^3 - ..., where s = 1/x.
	 * We approximate qzero by
	 *	qzero(x) = s*(-.125 + R(s^2) / S(s^2))
	 */
	static const long double qR8[7] = {
		/* 8 <= x <= inf
		   peak relative error 2.23e-21 */
		3.001267180483191397885272640777189348008E-10L,
		8.693186311430836495238494289942413810121E-8L,
		8.496875536711266039522937037850596580686E-6L,
		3.482702869915288984296602449543513958409E-4L,
		6.036378380706107692863811938221290851352E-3L,
		3.881970028476167836382607922840452192636E-2L,
		6.132191514516237371140841765561219149638E-2L
	};
	
	static const long double qS8[7] = {
		4.097730123753051126914971174076227600212E-9L,
		1.199615869122646109596153392152131139306E-6L,
		1.196337580514532207793107149088168946451E-4L,
		5.099074440112045094341500497767181211104E-3L,
		9.577420799632372483249761659674764460583E-2L,
		7.385243015344292267061953461563695918646E-1L,
		1.917266424391428937962682301561699055943E0L
		/* 1.000000000000000000000000000000000000000E0L, */
	};
	
	static const long double qR5[7] = {
		/* 4.54541015625 <= x <= 8
		   peak relative error 1.03e-21 */
		3.406256556438974327309660241748106352137E-8L,
		4.855492710552705436943630087976121021980E-6L,
		2.301011739663737780613356017352912281980E-4L,
		4.500470249273129953870234803596619899226E-3L,
		3.651376459725695502726921248173637054828E-2L,
		1.071578819056574524416060138514508609805E-1L,
		7.458950172851611673015774675225656063757E-2L
	};
	
	static const long double qS5[7] = {
		4.650675622764245276538207123618745150785E-7L,
		6.773573292521412265840260065635377164455E-5L,
		3.340711249876192721980146877577806687714E-3L,
		7.036218046856839214741678375536970613501E-2L,
		6.569599559163872573895171876511377891143E-1L,
		2.557525022583599204591036677199171155186E0L,
		3.457237396120935674982927714210361269133E0L
		/* 1.000000000000000000000000000000000000000E0L, */
	};
	
	static const long double qR3[7] = {
		/* 2.85711669921875 <= x <= 4.54541015625
		   peak relative error 5.24e-21 */
		1.749459596550816915639829017724249805242E-6L,
		1.446252487543383683621692672078376929437E-4L,
		3.842084087362410664036704812125005761859E-3L,
		4.066369994699462547896426554180954233581E-2L,
		1.721093619117980251295234795188992722447E-1L,
		2.538595333972857367655146949093055405072E-1L,
		8.560591367256769038905328596020118877936E-2L
	};
	
	static const long double qS3[7] = {
		2.388596091707517488372313710647510488042E-5L,
		2.048679968058758616370095132104333998147E-3L,
		5.824663198201417760864458765259945181513E-2L,
		6.953906394693328750931617748038994763958E-1L,
		3.638186936390881159685868764832961092476E0L,
		7.900169524705757837298990558459547842607E0L,
		5.992718532451026507552820701127504582907E0L
		/* 1.000000000000000000000000000000000000000E0L, */
	};
	
	static const long double qR2[7] = {
		/* 2 <= x <= 2.85711669921875
		   peak relative error 1.58e-21  */
		6.306524405520048545426928892276696949540E-5L,
		3.209606155709930950935893996591576624054E-3L,
		5.027828775702022732912321378866797059604E-2L,
		3.012705561838718956481911477587757845163E-1L,
		6.960544893905752937420734884995688523815E-1L,
		5.431871999743531634887107835372232030655E-1L,
		9.447736151202905471899259026430157211949E-2L
	};
	
	static const long double qS2[7] = {
		8.610579901936193494609755345106129102676E-4L,
		4.649054352710496997203474853066665869047E-2L,
		8.104282924459837407218042945106320388339E-1L,
		5.807730930825886427048038146088828206852E0L,
		1.795310145936848873627710102199881642939E1L,
		2.281313316875375733663657188888110605044E1L,
		1.011242067883822301487154844458322200143E1L
		/* 1.000000000000000000000000000000000000000E0L, */
	};
	
	GET_LDOUBLE_WORDS(se, i0, i1, x);
	ix = se & 0x7fff;
	if (ix >= 0x4002)
	{
		/* x >= 8 */
		p = qR8;
		q = qS8;
	} else
	{
		i1 = (ix << 16) | (i0 >> 16);
		if (i1 >= UC(0x40019174))
		{
			/* x >= 4.54541015625 */
			p = qR5;
			q = qS5;
		} else if (i1 >= UC(0x4000b6db))
		{
			/* x >= 2.85711669921875 */
			p = qR3;
			q = qS3;
		} else /* if (ix >= 0x4000) */
		{
			/* x >= 2 */
			p = qR2;
			q = qS2;
		}
	}
	z = one / (x * x);
	r = p[0] + z * (p[1] + z * (p[2] + z * (p[3] + z * (p[4] + z * (p[5] + z * p[6])))));
	s = q[0] + z * (q[1] + z * (q[2] + z * (q[3] + z * (q[4] + z * (q[5] + z * (q[6] + z))))));
	return (-.125 + z * r / s) / x;
}

#endif

```

`s_remquo.c`:

```c
/* Compute remainder and a congruent to the quotient.
   Copyright (C) 1997-2013 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_remquo

double __ieee754_remquo(double x, double y, int *quo)
{
	int32_t hx, hy;
	uint32_t sx, lx, ly;
	int32_t qs;
	int cquo;
	
	static const double zero = 0.0;
	
	GET_DOUBLE_WORDS(hx, lx, x);
	GET_DOUBLE_WORDS(hy, ly, y);
	sx = hx & IC(0x80000000);
	qs = sx ^ (hy & IC(0x80000000));
	hy &= IC(0x7fffffff);
	hx &= IC(0x7fffffff);

	/* Purge off exception values.  */
	if ((hy | ly) == 0)
		return (x * y) / (x * y);		/* y = 0 */
	if ((hx >= IC(0x7ff00000))			/* x not finite */
		|| ((hy >= IC(0x7ff00000))		/* p is NaN */
			&& (((hy - IC(0x7ff00000)) | ly) != 0)))
		return (x * y) / (x * y);

	if (hy <= IC(0x7fbfffff))
		x = __ieee754_fmod(x, 8 * y);	/* now x < 8y */

	if (((hx - hy) | (lx - ly)) == 0)
	{
		*quo = qs ? -1 : 1;
		return zero * x;
	}

	x = __ieee754_fabs(x);
	y = __ieee754_fabs(y);
	cquo = 0;

	if (x >= 4 * y)
	{
		x -= 4 * y;
		cquo += 4;
	}
	if (x >= 2 * y)
	{
		x -= 2 * y;
		cquo += 2;
	}

	if (hy < IC(0x00200000))
	{
		if (x + x > y)
		{
			x -= y;
			++cquo;
			if (x + x >= y)
			{
				x -= y;
				++cquo;
			}
		}
	} else
	{
		double y_half = 0.5 * y;

		if (x > y_half)
		{
			x -= y;
			++cquo;
			if (x >= y_half)
			{
				x -= y;
				++cquo;
			}
		}
	}

	*quo = qs ? -cquo : cquo;

	if (sx)
		x = -x;
	return x;
}

#endif

double __remquo(double x, double y, int *quo)
{
	return __ieee754_remquo(x, y, quo);
}

__typeof(__remquo) remquo __attribute__((weak, alias("__remquo")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(remquol) __remquol __attribute__((alias("__remquo")));
__typeof(__remquol) remquol __attribute__((weak, alias("__remquo")));
#endif

```

`s_remquof.c`:

```c
/* Compute remainder and a congruent to the quotient.
   Copyright (C) 1997-2013 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_remquo

float __ieee754_remquof(float x, float y, int *quo)
{
	int32_t hx, hy;
	uint32_t sx;
	int cquo;
	int32_t qs;

	static const float zero = 0.0;

	GET_FLOAT_WORD(hx, x);
	GET_FLOAT_WORD(hy, y);
	sx = hx & IC(0x80000000);
	qs = sx ^ (hy & IC(0x80000000));
	hy &= IC(0x7fffffff);
	hx &= IC(0x7fffffff);

	/* Purge off exception values.  */
	if (hy == 0)
		return (x * y) / (x * y);		/* y = 0 */
	if ((hx >= IC(0x7f800000))			/* x not finite */
		|| (hy > IC(0x7f800000)))		/* y is NaN */
		return (x * y) / (x * y);

	if (hy <= IC(0x7dffffff))
		x = __ieee754_fmodf(x, 8 * y);	/* now x < 8y */

	if ((hx - hy) == 0)
	{
		*quo = qs ? -1 : 1;
		return zero * x;
	}

	x = __ieee754_fabsf(x);
	y = __ieee754_fabsf(y);
	cquo = 0;

	if (x >= 4 * y)
	{
		x -= 4 * y;
		cquo += 4;
	}
	if (x >= 2 * y)
	{
		x -= 2 * y;
		cquo += 2;
	}

	if (hy < IC(0x01000000))
	{
		if (x + x > y)
		{
			x -= y;
			++cquo;
			if (x + x >= y)
			{
				x -= y;
				++cquo;
			}
		}
	} else
	{
		float y_half = 0.5 * y;

		if (x > y_half)
		{
			x -= y;
			++cquo;
			if (x >= y_half)
			{
				x -= y;
				++cquo;
			}
		}
	}

	*quo = qs ? -cquo : cquo;

	if (sx)
		x = -x;
	return x;
}

#endif

float __remquof(float x, float y, int *quo)
{
	return __ieee754_remquof(x, y, quo);
}

__typeof(__remquof) remquof __attribute__((weak, alias("__remquof")));

```

`s_remquol.c`:

```c
/* Compute remainder and a congruent to the quotient.
   Copyright (C) 1997-2013 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

#ifndef __have_fpu_remquo

long double __ieee754_remquol(long double x, long double p, int *quo)
{
	int32_t ex, ep, hx, hp;
	uint32_t sx, lx, lp;
	int cquo;
	int32_t qs;

	static const long double zero = 0.0;
	
	GET_LDOUBLE_WORDS(ex, hx, lx, x);
	GET_LDOUBLE_WORDS(ep, hp, lp, p);
	sx = ex & 0x8000;
	qs = (sx ^ (ep & 0x8000)) >> 15;
	ep &= IEEE854_LONG_DOUBLE_MAXEXP;
	ex &= IEEE854_LONG_DOUBLE_MAXEXP;

	/* Purge off exception values.  */
	if ((ep | hp | lp) == 0)
		return (x * p) / (x * p);		/* p = 0 */
	if ((ex == IEEE854_LONG_DOUBLE_MAXEXP)					/* x not finite */
		|| ((ep == IEEE854_LONG_DOUBLE_MAXEXP)				/* p is NaN */
			&& ((hp | lp) != 0)))
		return (x * p) / (x * p);

	if (ep <= 0x7ffb)
		x = __ieee754_fmodl(x, 8 * p);	/* now x < 8p */

	if (((ex - ep) | (hx - hp) | (lx - lp)) == 0)
	{
		*quo = qs ? -1 : 1;
		return zero * x;
	}

	x = __ieee754_fabsl(x);
	p = __ieee754_fabsl(p);
	cquo = 0;

	if (x >= 4 * p)
	{
		x -= 4 * p;
		cquo += 4;
	}
	if (x >= 2 * p)
	{
		x -= 2 * p;
		cquo += 2;
	}

	if (ep < 0x0002)
	{
		if (x + x > p)
		{
			x -= p;
			++cquo;
			if (x + x >= p)
			{
				x -= p;
				++cquo;
			}
		}
	} else
	{
		long double p_half = 0.5 * p;

		if (x > p_half)
		{
			x -= p;
			++cquo;
			if (x >= p_half)
			{
				x -= p;
				++cquo;
			}
		}
	}

	*quo = qs ? -cquo : cquo;

	if (sx)
		x = -x;
	return x;
}

#endif

long double __remquol(long double x, long double y, int *quo)
{
	return __ieee754_remquol(x, y, quo);
}

__typeof(__remquol) remquol __attribute__((weak, alias("__remquol")));

#endif

```

`s_rint.c`:

```c
/* @(#)s_rint.c 1.3 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/*
 * rint(x)
 * Return x rounded to integral value according to the prevailing
 * rounding mode.
 * Method:
 *	Using floating addition.
 * Exception:
 *	Inexact flag raised if x not equal to rint(x).
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_rint

static double __ieee754_roundeven(double x)
{
	int32_t i0, j0;
	uint32_t i1;

	static const double hugeval = 1.0e300;
	
	GET_DOUBLE_WORDS(i0, i1, x);
	j0 = ((i0 >> IEEE754_DOUBLE_SHIFT) & IEEE754_DOUBLE_MAXEXP) - IEEE754_DOUBLE_BIAS;
	if (j0 < IEEE754_DOUBLE_SHIFT)
	{
		if (j0 < 0)
		{
			math_force_eval(hugeval + x);
			if (j0 == -1 && (i0 & IC(0x000fffff)) != 0)
			{
				i0 &= UC(0x80000000);
				i0 |= UC(0x3ff00000);
			} else
			{
				i0 &= UC(0x80000000);
			}
			i1 = 0;
		} else
		{
			uint32_t i = UC(0x000fffff) >> j0;

			if (((i0 & i) | i1) == 0)
				/* X is integral.  */
				return x;

			/* Raise inexact if x != 0.  */
			math_force_eval(hugeval + x);

			if ((i0 & (i >> 1)) != 0 || i1 != 0 || (i0 & (UC(0x00100000) >> j0)))
			{
				i0 += UC(0x00080000) >> j0;
			}
			i0 &= ~i;
			i1 = 0;
		}
	} else if (j0 > 51)
	{
		if (j0 == (IEEE754_DOUBLE_MAXEXP - IEEE754_DOUBLE_BIAS))
			return x + x;				/* Inf or NaN */
		else
			return x;					/* x is integral */
	} else
	{
		uint32_t i = UC(0xffffffff) >> (j0 - IEEE754_DOUBLE_SHIFT);
		uint32_t j;

		if ((i1 & i) == 0)
			return x;					/* x is integral */

		/* Raise inexact if x != 0. */
		math_force_eval(hugeval + x);

		if ((i1 & (i >> 1)) != 0 || (j0 == IEEE754_DOUBLE_SHIFT && (i0 & 1)) || (i1 & (UC(1) << (52 - j0))))
		{
			j = i1 + (UC(1) << (51 - j0));
			if (j < i1)
				i0 += 1;
			i1 = j;
		}
		i1 &= ~i;
	}

	INSERT_WORDS(x, i0, i1);
	return x;
}

double __ieee754_rint(double x)
{
	/*
	 * above code relies on a FPU doing the rounding,
	 * and using round-to-even for FE_TONEAREST
	 */
	switch (fegetround())
	{
		case FE_UPWARD: return __ieee754_ceil(x);
		case FE_DOWNWARD: return __ieee754_floor(x);
		case FE_TOWARDZERO: return __ieee754_trunc(x);
	}
	/* case FE_TONEAREST: */
	return __ieee754_roundeven(x);
}

#endif

double __rint(double x)
{
	return __ieee754_rint(x);
}


__typeof(__rint) rint __attribute__((weak, alias("__rint")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(rintl) __rintl __attribute__((alias("__rint")));
__typeof(__rintl) rintl __attribute__((weak, alias("__rint")));
#endif

```

`s_rintf.c`:

```c
#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_rint

static float __ieee754_roundevenf(float x)
{
	int32_t i0, j0;

	static const float hugeval = 1.0e30;
	
	GET_FLOAT_WORD(i0, x);
	j0 = ((i0 >> IEEE754_FLOAT_SHIFT) & IEEE754_FLOAT_MAXEXP) - IEEE754_FLOAT_BIAS;
	if (j0 < IEEE754_FLOAT_SHIFT)
	{
		if (j0 < 0)
		{
			math_force_eval(hugeval + x);

			if (j0 == -1 && (i0 & IC(0x007fffff)) != 0)
			{
				i0 &= IC(0x80000000);
				i0 |= IC(0x3f800000);
			} else
			{
				i0 &= IC(0x80000000);
			}
		} else
		{
			uint32_t i = UC(0x007fffff) >> j0;

			if ((i0 & i) == 0)
				/* X is integral.  */
				return x;

			/* Raise inexact if x != 0.  */
			math_force_eval(hugeval + x);

			if ((i0 & (i >> 1)) != 0 || (i0 & (UC(0x00800000) >> j0)))
			{
				i0 += UC(0x00400000) >> j0;
			}
			i0 &= ~i;
		}
	} else
	{
		if (j0 == (IEEE754_FLOAT_MAXEXP - IEEE754_FLOAT_BIAS))
			/* Inf or NaN.  */
			return x + x;
		else
			return x;
	}

	SET_FLOAT_WORD(x, i0);
	return x;
}


float __ieee754_rintf(float x)
{
	/*
	 * above code relies on a FPU doing the rounding,
	 * and using round-to-even for FE_TONEAREST
	 */
	switch (fegetround())
	{
		case FE_UPWARD: return __ieee754_ceilf(x);
		case FE_DOWNWARD: return __ieee754_floorf(x);
		case FE_TOWARDZERO: return __ieee754_truncf(x);
	}
	/* case FE_TONEAREST: */
	return __ieee754_roundevenf(x);
}

#endif

float __rintf(float x)
{
	return __ieee754_rintf(x);
}

__typeof(__rintf) rintf __attribute__((weak, alias("__rintf")));

```

`s_rintl.c`:

```c
#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

/*
 * rintl(x)
 * Return x rounded to integral value according to the prevailing
 * rounding mode.
 * Method:
 *	Using floating addition.
 * Exception:
 *	Inexact flag raised if x not equal to rintl(x).
 */

#ifndef __NO_LONG_DOUBLE_MATH

#ifndef __have_fpu_rint

static long double __ieee754_roundevenl(long double x)
{
	int32_t j0;
	uint32_t se, i1, i0;

	static const long double hugeval = 1.0e4930L;
	
	GET_LDOUBLE_WORDS(se, i0, i1, x);
	j0 = (se & IEEE854_LONG_DOUBLE_MAXEXP) - IEEE854_LONG_DOUBLE_BIAS;
	if (j0 < 31)
	{
		if (j0 < 0)
		{
			math_force_eval(hugeval + x);
			se &= 0x8000;
			if (j0 == -1 && (i0 & UC(0x7fffffff)) != 0)
			{
				se |= 0x3fff;
				i0 = UC(0x80000000);
			} else
			{
				i0 = 0;
			}
			i1 = 0;
		} else
		{
			uint32_t i = UC(0x7fffffff) >> j0;
			uint32_t j;
			
			if (((i0 & i) | i1) == 0)
				/* X is integral.  */
				return x;

			/* Raise inexact if x != 0.  */
			math_force_eval(hugeval + x);
			j = i0;
			if ((i0 & (i >> 1)) != 0 || i1 != 0 || (i0 & (UC(0x80000000) >> j0)))
			{
				j += (UC(0x40000000) >> j0);

				if (j < i0)
					se += 1;
			}
			i0 = (j & ~i) | IC(0x80000000);
			i1 = 0;
		}
	} else if (j0 > 62)
	{
		if (j0 == (IEEE854_LONG_DOUBLE_MAXEXP - IEEE854_LONG_DOUBLE_BIAS))
			/* Inf or NaN.  */
			return x + x;
		else
			return x;
	} else
	{
		uint32_t i = UC(0xffffffff) >> (j0 - 31);
		uint32_t j;
		
		if ((i1 & i) == 0)
			/* X is integral.  */
			return x;

		/* Raise inexact if x != 0.  */
		math_force_eval(hugeval + x);

		if ((i1 & (i >> 1)) != 0 || (j0 == 32 && (i0 & 1)) || (i1 & (UC(1) << (63 - j0))))
		{
			j = i1 + (UC(1) << (62 - j0));

			if (j < i1)
			{
				uint32_t k = i0 + 1;

				if (k < i0)
				{
					se += 1;
					k |= UC(0x80000000);
				}
				i0 = k;
			}
			i1 = j;
		}
		i1 &= ~i;
	}

	SET_LDOUBLE_WORDS(x, se, i0, i1);
	return x;
}

long double __ieee754_rintl(long double x)
{
	/*
	 * above code relies on a FPU doing the rounding,
	 * and using round-to-even for FE_TONEAREST
	 */
	switch (fegetround())
	{
		case FE_UPWARD: return __ieee754_ceill(x);
		case FE_DOWNWARD: return __ieee754_floorl(x);
		case FE_TOWARDZERO: return __ieee754_truncl(x);
	}
	/* case FE_TONEAREST: */
	return __ieee754_roundevenl(x);
}

#endif

long double __rintl(long double x)
{
	return __ieee754_rintl(x);
}

__typeof(__rintl) rintl __attribute__((weak, alias("__rintl")));

#endif

```

`s_round.c`:

```c
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice 
 * is preserved.
 * ====================================================
 */
/*
FUNCTION
<<round>>, <<roundf>>--round to integer, to nearest
INDEX
	round
INDEX
	roundf

ANSI_SYNOPSIS
	#include <math.h>
	double round(double <[x]>);
	float roundf(float <[x]>);

DESCRIPTION
	The <<round>> functions round their argument to the nearest integer
	value in floating-point format, rounding halfway cases away from zero,
	regardless of the current rounding direction.  (While the "inexact"
	floating-point exception behavior is unspecified by the C standard, the
	<<round>> functions are written so that "inexact" is not raised if the
	result does not equal the argument, which behavior is as recommended by
	IEEE 754 for its related functions.)

RETURNS
<[x]> rounded to an integral value.

PORTABILITY
ANSI C, POSIX

SEEALSO
<<nearbyint>>, <<rint>>

*/

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_round

double __ieee754_round(double x)
{
	int32_t i0, j0;
	uint32_t i1;

	static const double hugeval = 1.0e300;
	
	GET_DOUBLE_WORDS(i0, i1, x);
	j0 = ((i0 >> IEEE754_DOUBLE_SHIFT) & IEEE754_DOUBLE_MAXEXP) - IEEE754_DOUBLE_BIAS;
	if (j0 < IEEE754_DOUBLE_SHIFT)
	{
		if (j0 < 0)
		{
			math_force_eval(hugeval + x);
			i0 &= UC(0x80000000);
			if (j0 == -1)				/* Result is +1.0 or -1.0. */
				i0 |= UC(0x3ff00000);
			i1 = 0;
		} else
		{
			uint32_t i = UC(0x000fffff) >> j0;

			if (((i0 & i) | i1) == 0)
				/* X is integral.  */
				return x;

			/* Raise inexact if x != 0.  */
			math_force_eval(hugeval + x);

			i0 += UC(0x00080000) >> j0;
			i0 &= ~i;
			i1 = 0;
		}
	} else if (j0 > 51)
	{
		if (j0 == (IEEE754_DOUBLE_MAXEXP - IEEE754_DOUBLE_BIAS))
			/* Inf or NaN.  */
			return x + x;
		else
			return x;
	} else
	{
		uint32_t i = UC(0xffffffff) >> (j0 - IEEE754_DOUBLE_SHIFT);
		uint32_t j;

		if ((i1 & i) == 0)
			/* X is integral.  */
			return x;

		/* Raise inexact if x != 0.  */
		math_force_eval(hugeval + x);

		j = i1 + (UC(1) << (51 - j0));

		if (j < i1)
			i0 += 1;
		i1 = j;
		i1 &= ~i;
	}

	INSERT_WORDS(x, i0, i1);

	return x;
}

#endif

double __round(double x)
{
	return __ieee754_round(x);
}

__typeof(__round) round __attribute__((weak, alias("__round")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(__roundl) __roundl __attribute__((alias("__round")));
__typeof(__roundl) roundl __attribute__((weak, alias("__round")));
#endif

```

`s_roundf.c`:

```c
#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_round

float __ieee754_roundf(float x)
{
	int32_t i0, j0;

	static const float hugeval = 1.0e30;
	
	GET_FLOAT_WORD(i0, x);
	j0 = ((i0 >> IEEE754_FLOAT_SHIFT) & IEEE754_FLOAT_MAXEXP) - IEEE754_FLOAT_BIAS;
	if (j0 < IEEE754_FLOAT_SHIFT)
	{
		if (j0 < 0)
		{
			math_force_eval(hugeval + x);

			i0 &= IC(0x80000000);
			if (j0 == -1)
				i0 |= IC(0x3f800000);
		} else
		{
			uint32_t i = UC(0x007fffff) >> j0;

			if ((i0 & i) == 0)
				/* X is integral.  */
				return x;
			math_force_eval(hugeval + x);

			/* Raise inexact if x != 0.  */
			i0 += UC(0x00400000) >> j0;
			i0 &= ~i;
		}
	} else
	{
		if (j0 == (IEEE754_FLOAT_MAXEXP - IEEE754_FLOAT_BIAS))
			/* Inf or NaN.  */
			return x + x;
		else
			return x;
	}

	SET_FLOAT_WORD(x, i0);
	return x;
}

#endif

float __roundf(float x)
{
	return __ieee754_roundf(x);
}

__typeof(__roundf) roundf __attribute__((weak, alias("__roundf")));

```

`s_roundl.c`:

```c
#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

#ifndef __have_fpu_round

long double __ieee754_roundl(long double x)
{
	int32_t j0;
	uint32_t se, i1, i0;

	static const long double hugeval = 1.0e4930L;
	
	GET_LDOUBLE_WORDS(se, i0, i1, x);
	j0 = (se & IEEE854_LONG_DOUBLE_MAXEXP) - IEEE854_LONG_DOUBLE_BIAS;
	if (j0 < 31)
	{
		if (j0 < 0)
		{
			math_force_eval(hugeval + x);
			se &= 0x8000;
			i0 = i1 = 0;
			if (j0 == -1)
			{
				se |= 0x3fff;
				i0 = UC(0x80000000);
			}
		} else
		{
			uint32_t i = UC(0x7fffffff) >> j0;
			uint32_t j;
			
			if (((i0 & i) | i1) == 0)
				/* X is integral.  */
				return x;

			/* Raise inexact if x != 0.  */
			math_force_eval(hugeval + x);
			j = i0 + (UC(0x40000000) >> j0);

			if (j < i0)
				se += 1;
			i0 = (j & ~i) | IC(0x80000000);
			i1 = 0;
		}
	} else if (j0 > 62)
	{
		if (j0 == (IEEE854_LONG_DOUBLE_MAXEXP - IEEE854_LONG_DOUBLE_BIAS))
			/* Inf or NaN.  */
			return x + x;
		else
			return x;
	} else
	{
		uint32_t i = UC(0xffffffff) >> (j0 - 31);
		uint32_t j;
		
		if ((i1 & i) == 0)
			/* X is integral.  */
			return x;

		/* Raise inexact if x != 0.  */
		math_force_eval(hugeval + x);
		j = i1 + (UC(1) << (62 - j0));

		if (j < i1)
		{
			uint32_t k = i0 + 1;

			if (k < i0)
			{
				se += 1;
				k |= UC(0x80000000);
			}
			i0 = k;
		}
		i1 = j;
		i1 &= ~i;
	}

	SET_LDOUBLE_WORDS(x, se, i0, i1);
	return x;
}

#endif

long double __roundl(long double x)
{
	return __ieee754_roundl(x);
}

__typeof(__roundl) roundl __attribute__((weak, alias("__roundl")));

#endif

```

`s_scalbln.c`:

```c
#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#if INT_MAX != LONG_MAX

#ifndef __have_fpu_scalbn

double __ieee754_scalbln(double x, long n)
{
	int32_t k, hx, lx;

	static const double two54 = 1.80143985094819840000e+16;		/* 0x43500000, 0x00000000 */
	static const double twom54 = 5.55111512312578270212e-17;	/* 0x3C900000, 0x00000000 */
	static const double hugeval = 1.0e+300;
	static const double tiny = 1.0e-300;

	GET_DOUBLE_WORDS(hx, lx, x);
	k = (hx >> IEEE754_DOUBLE_SHIFT) & IEEE754_DOUBLE_MAXEXP;		/* extract exponent */
	if (k == 0)
	{									/* 0 or subnormal x */
		if ((lx | (hx & IC(0x7fffffff))) == 0)
			return x;					/* +-0 */
		x *= two54;
		GET_HIGH_WORD(hx, x);
		k = ((hx & IC(0x7ff00000)) >> IEEE754_DOUBLE_SHIFT) - 54;
	}
	if (k == IEEE754_DOUBLE_MAXEXP)
		return x + x;					/* NaN or Inf */
	if (n < IC(-50000))
		return tiny * copysign(tiny, x);	/* underflow */
	if (n > IC(50000) || k + n > 0x7fe)
		return hugeval * copysign(hugeval, x);	/* overflow  */
	/* Now k and n are bounded we know that k = k+n does not
	   overflow.  */
	k = k + n;
	if (k > 0)							/* normal result */
	{
		SET_HIGH_WORD(x, (hx & UC(0x800fffff)) | (k << IEEE754_DOUBLE_SHIFT));
		return x;
	}
	if (k <= -54)
		return tiny * copysign(tiny, x);	/*underflow */
	k += 54;							/* subnormal result */
	SET_HIGH_WORD(x, (hx & UC(0x800fffff)) | (k << IEEE754_DOUBLE_SHIFT));
	return x * twom54;
}

#endif

double __scalbln(double x, long n)
{
	return __ieee754_scalbln(x, n);
}

__typeof(__scalbln) scalbln __attribute__((weak, alias("__scalbln")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(scalblnl) __scalblnl __attribute__((alias("__scalbln")));
__typeof(__scalblnl) scalblnl __attribute__((weak, alias("__scalbln")));
#endif

#endif

```

`s_scalblnf.c`:

```c
#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#if INT_MAX != LONG_MAX

#ifndef __have_fpu_scalbln

float __ieee754_scalblnf(float x, long n)
{
	int32_t k, ix;

	static const float two25 = 3.355443200e+07;			/* 0x4c000000 */
	static const float twom25 = 2.9802322388e-08;		/* 0x33000000 */
	static const float hugeval = 1.0e+30;
	static const float tiny = 1.0e-30;

	GET_FLOAT_WORD(ix, x);
	k = (ix & UC(0x7f800000)) >> IEEE754_FLOAT_SHIFT;		/* extract exponent */
	if (k == 0)
	{									/* 0 or subnormal x */
		if ((ix & UC(0x7fffffff)) == 0)
			return x;					/* +-0 */
		x *= two25;
		GET_FLOAT_WORD(ix, x);
		k = ((ix & UC(0x7f800000)) >> IEEE754_FLOAT_SHIFT) - 25;
	}
	if (k == IEEE754_FLOAT_MAXEXP)
		return x + x;					/* NaN or Inf */
	if (n < IC(-50000))
		return tiny * copysignf(tiny, x);	/*underflow */
	if (n > IC(50000) || k + n > 0xfe)
		return hugeval * copysignf(hugeval, x);	/* overflow  */
	/* Now k and n are bounded we know that k = k+n does not
	   overflow.  */
	k = k + n;
	if (k > 0)		/* normal result */
	{
		SET_FLOAT_WORD(x, (ix & UC(0x807fffff)) | (k << IEEE754_FLOAT_SHIFT));
		return x;
	}
	if (k <= -25)
		return tiny * copysignf(tiny, x);	/*underflow */
	k += 25;							/* subnormal result */
	SET_FLOAT_WORD(x, (ix & UC(0x807fffff)) | (k << IEEE754_FLOAT_SHIFT));
	return x * twom25;
}

#endif

float __scalblnf(float x, long n)
{
	return __ieee754_scalblnf(x, n);
}

__typeof(__scalblnf) scalblnf __attribute__((weak, alias("__scalblnf")));

#endif

```

`s_scalblnl.c`:

```c
#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#if INT_MAX != LONG_MAX

#ifndef __NO_LONG_DOUBLE_MATH

#ifndef __have_fpu_scalbln

long double __ieee754_scalblnl(long double x, long n)
{
	int32_t k, es, hx, lx;

	static const long double two64 = 1.8446744073709551616e19L;
	static const long double twom64 = 5.421010862427522170037e-20L;
	static const long double hugeval = 1.0e+4900L;
	static const long double tiny = 1.0e-4900L;

	GET_LDOUBLE_WORDS(es, hx, lx, x);
	k = es & IEEE854_LONG_DOUBLE_MAXEXP;					/* extract exponent */
	if (k == 0)
	{									/* 0 or subnormal x */
		if ((lx | (hx & UC(0x7fffffff))) == 0)
			return x;					/* +-0 */
		x *= two64;
		GET_LDOUBLE_EXP(hx, x);
		k = (hx & IEEE854_LONG_DOUBLE_MAXEXP) - 64;
	}
	if (k == IEEE854_LONG_DOUBLE_MAXEXP)
		return x + x;					/* NaN or Inf */
	if (n < IC(-50000))
		return tiny * __copysignl(tiny, x);
	if (n > IC(50000) || k + n > 0x7ffe)
		return hugeval * __copysignl(hugeval, x);	/* overflow  */
	/* Now k and n are bounded we know that k = k+n does not
	   overflow.  */
	k = k + n;
	if (k > 0)		/* normal result */
	{
		SET_LDOUBLE_EXP(x, (es & 0x8000) | k);
		return x;
	}
	if (k <= -64)
		return tiny * __copysignl(tiny, x);	/* underflow */
	k += 64;							/* subnormal result */
	SET_LDOUBLE_EXP(x, (es & 0x8000) | k);
	return x * twom64;
}

#endif

long double __scalblnl(long double x, long n)
{
	return __ieee754_scalblnl(x, n);
}

__typeof(__scalblnl) scalblnl __attribute__((weak, alias("__scalblnl")));

#endif

#endif

```

`s_scalbn.c`:

```c
/* @(#)s_scalbn.c 1.3 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice 
 * is preserved.
 * ====================================================
 */

/* 
 * scalbn (double x, int n)
 * scalbn(x,n) returns x* 2**n  computed by  exponent  
 * manipulation rather than by actually performing an 
 * exponentiation or a multiplication.
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_scalbn

double __ieee754_scalbn(double x, int n)
{
	int32_t k, hx, lx;

	static const double two54 = 1.80143985094819840000e+16;		/* 0x43500000, 0x00000000 */
	static const double twom54 = 5.55111512312578270212e-17;	/* 0x3C900000, 0x00000000 */
	static const double hugeval = 1.0e+300;
	static const double tiny = 1.0e-300;

	GET_DOUBLE_WORDS(hx, lx, x);
	k = (hx >> IEEE754_DOUBLE_SHIFT) & IEEE754_DOUBLE_MAXEXP;		/* extract exponent */
	if (k == 0)
	{									/* 0 or subnormal x */
		if ((lx | (hx & IC(0x7fffffff))) == 0)
			return x;					/* +-0 */
		x *= two54;
		GET_HIGH_WORD(hx, x);
		k = ((hx & IC(0x7ff00000)) >> IEEE754_DOUBLE_SHIFT) - 54;
	}
	if (k == IEEE754_DOUBLE_MAXEXP)
		return x + x;					/* NaN or Inf */
	if ((int32_t)n < IC(-30000))
		return tiny * copysign(tiny, x);	/* underflow */
	if ((int32_t)n > IC(30000) || k + n > 0x7fe)
		return hugeval * copysign(hugeval, x);	/* overflow  */
	/* Now k and n are bounded we know that k = k+n does not
	   overflow.  */
	k = k + n;
	if (k > 0)							/* normal result */
	{
		SET_HIGH_WORD(x, (hx & UC(0x800fffff)) | (k << IEEE754_DOUBLE_SHIFT));
		return x;
	}
	if (k <= -54)
		return tiny * copysign(tiny, x);	/*underflow */
	k += 54;							/* subnormal result */
	SET_HIGH_WORD(x, (hx & UC(0x800fffff)) | (k << IEEE754_DOUBLE_SHIFT));
	return x * twom54;
}

#endif

double __scalbn(double x, int n)
{
	return __ieee754_scalbn(x, n);
}

__typeof(__scalbn) scalbn __attribute__((weak, alias("__scalbn")));
#ifdef __NO_LONG_DOUBLE_MATH
long double __scalbnl(long double x, int n) __attribute__((alias("__scalbn")));
__typeof(__scalbnl) scalbnl __attribute__((weak, alias("__scalbn")));
#endif


#if INT_MAX == LONG_MAX
double __scalbln(double x, long n) __attribute__((alias("__scalbn")));
double scalbln(double x, long n) __attribute__((weak, alias("__scalbln")));
#ifndef __have_fpu_scalbn
double __ieee754_scalbln(double x, long n) __attribute__((alias("__ieee754_scalbn")));
#endif
#ifdef __NO_LONG_DOUBLE_MATH
long double __scalblnl(long double x, long n) __attribute__((alias("__scalbln")));
long double scalblnl(long double x, long n) __attribute__((weak, alias("__scalblnl")));
#ifndef __have_fpu_scalbn
long double __ieee754_scalblnl(long double x, long n) __attribute__((alias("__ieee754_scalbln")));
#endif
#endif
#endif

```

`s_scalbnf.c`:

```c
#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_scalbn

float __ieee754_scalbnf(float x, int n)
{
	int32_t k, ix;

	static const float two25 = 3.355443200e+07;			/* 0x4c000000 */
	static const float twom25 = 2.9802322388e-08;		/* 0x33000000 */
	static const float hugeval = 1.0e+30;
	static const float tiny = 1.0e-30;

	GET_FLOAT_WORD(ix, x);
	k = (ix & UC(0x7f800000)) >> IEEE754_FLOAT_SHIFT;		/* extract exponent */
	if (k == 0)
	{									/* 0 or subnormal x */
		if ((ix & UC(0x7fffffff)) == 0)
			return x;					/* +-0 */
		x *= two25;
		GET_FLOAT_WORD(ix, x);
		k = ((ix & UC(0x7f800000)) >> IEEE754_FLOAT_SHIFT) - 25;
	}
	if (k == IEEE754_FLOAT_MAXEXP)
		return x + x;					/* NaN or Inf */
	if ((int32_t)n < IC(-30000))
		return tiny * copysignf(tiny, x);	/*underflow */
	if ((int32_t)n > IC(30000) || k + n > 0xfe)
		return hugeval * copysignf(hugeval, x);	/* overflow  */
	/* Now k and n are bounded we know that k = k+n does not
	   overflow.  */
	k = k + n;
	if (k > 0)		/* normal result */
	{
		SET_FLOAT_WORD(x, (ix & UC(0x807fffff)) | (k << IEEE754_FLOAT_SHIFT));
		return x;
	}
	if (k <= -25)
		return tiny * copysignf(tiny, x);	/*underflow */
	k += 25;							/* subnormal result */
	SET_FLOAT_WORD(x, (ix & UC(0x807fffff)) | (k << IEEE754_FLOAT_SHIFT));
	return x * twom25;
}

#endif

float __scalbnf(float x, int n)
{
	return __ieee754_scalbnf(x, n);
}

__typeof(__scalbnf) scalbnf __attribute__((weak, alias("__scalbnf")));

#if INT_MAX == LONG_MAX
float __scalblnf(float x, long n) __attribute__((alias("__scalbnf")));
float scalblnf(float x, long n) __attribute__((weak, alias("__scalblnf")));
#ifndef __have_fpu_scalbn
float __ieee754_scalblnf(float x, long n) __attribute__((alias("__ieee754_scalbnf")));
#endif
#endif

```

`s_scalbnl.c`:

```c
#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

#ifndef __have_fpu_scalbn

long double __ieee754_scalbnl(long double x, int n)
{
	int32_t k, es, hx, lx;

	static const long double two64 = 1.8446744073709551616e19L;
	static const long double twom64 = 5.421010862427522170037e-20L;
	static const long double hugeval = 1.0e+4900L;
	static const long double tiny = 1.0e-4900L;

	GET_LDOUBLE_WORDS(es, hx, lx, x);
	k = es & IEEE854_LONG_DOUBLE_MAXEXP;					/* extract exponent */
	if (k == 0)
	{									/* 0 or subnormal x */
		if ((lx | (hx & UC(0x7fffffff))) == 0)
			return x;					/* +-0 */
		x *= two64;
		GET_LDOUBLE_EXP(hx, x);
		k = (hx & IEEE854_LONG_DOUBLE_MAXEXP) - 64;
	}
	if (k == IEEE854_LONG_DOUBLE_MAXEXP)
		return x + x;					/* NaN or Inf */
	if ((int32_t)n < IC(-30000))
		return tiny * copysignl(tiny, x);
	if ((int32_t)n > IC(30000) || (k + n) > 0x7ffe)
		return hugeval * copysignl(hugeval, x);	/* overflow  */
	/* Now k and n are bounded we know that k = k+n does not
	   overflow.  */
	k = k + n;
	if (k > 0)		/* normal result */
	{
		SET_LDOUBLE_EXP(x, (es & 0x8000) | k);
		return x;
	}
	if (k <= -64)
		return tiny * copysignl(tiny, x);	/*underflow */
	k += 64;							/* subnormal result */
	SET_LDOUBLE_EXP(x, (es & 0x8000) | k);
	return x * twom64;
}

#endif

long double __scalbnl(long double x, int n)
{
	return __ieee754_scalbnl(x, n);
}

__typeof(__scalbnl) scalbnl __attribute__((weak, alias("__scalbnl")));

#if INT_MAX == LONG_MAX
long double __scalblnl(long double x, long n) __attribute__((alias("__scalbnl")));
long double scalblnl(long double x, long n) __attribute__((weak, alias("__scalblnl")));
#ifndef __have_fpu_scalbn
long double __ieee754_scalblnl(long double x, long n) __attribute__((alias("__ieee754_scalbnl")));
#endif
#endif

#endif

```

`s_signgam.c`:

```c
#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

int signgam = 0;

int *__signgam (void)
{
	return &signgam;
}

```

`s_significand.c`:

```c
/* @(#)s_significand.c 1.3 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice 
 * is preserved.
 * ====================================================
 */

/*
 * significand(x) computes just
 * 	scalb(x, (double) -ilogb(x)),
 * for exercising the fraction-part(F) IEEE 754-1985 test vector.
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

double __significand(double x)
{
	uint32_t hx, ix;

	GET_HIGH_WORD(hx, x);
	ix = hx & UC(0x7ff00000);
	if (ix != 0 && ix != UC(0x7ff00000))
	{
		SET_HIGH_WORD(x, (hx & UC(0x800fffff)) | UC(0x3ff00000));
	}
	return x;
}

__typeof(__significand) significand __attribute__((weak, alias("__significand")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(__significandl) __significandl __attribute__((alias("__significand")));
__typeof(__significandl) significandl __attribute__((weak, alias("__significand")));
#endif

```

`s_significandf.c`:

```c
#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

float __significandf(float x)
{
	uint32_t hx, ix;

	GET_FLOAT_WORD(hx, x);
	ix = hx & UC(0x7f800000);
	if (ix != 0 && ix != UC(0x7f800000))
	{
		SET_FLOAT_WORD(x, (hx & UC(0x807fffff)) | UC(0x3f800000));
	}
	return x;
}

__typeof(__significandf) significandf __attribute__((weak, alias("__significandf")));

```

`s_significandl.c`:

```c
#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

long double __significandl(long double x)
{
	uint32_t exp, ix;

	GET_LDOUBLE_EXP(exp, x);
	ix = exp & 0x7fff;
	if (ix != 0 && ix != 0x7fff)
		SET_LDOUBLE_EXP(x, (exp & 0x8000) | 0x3fff);
	return x;
}

__typeof(__significandl) significandl __attribute__((weak, alias("__significandl")));

#endif

```

`s_sin.c`:

```c
/* @(#)s_sin.c 1.3 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice 
 * is preserved.
 * ====================================================
 */

/* sin(x)
 * Return sine function of x.
 *
 * kernel function:
 *	__kernel_sin		... sine function on [-pi/4,pi/4]
 *	__kernel_cos		... cose function on [-pi/4,pi/4]
 *	__ieee754_rem_pio2	... argument reduction routine
 *
 * Method.
 *      Let S,C and T denote the sin, cos and tan respectively on 
 *	[-PI/4, +PI/4]. Reduce the argument x to y1+y2 = x-k*pi/2 
 *	in [-pi/4 , +pi/4], and let n = k mod 4.
 *	We have
 *
 *          n        sin(x)      cos(x)        tan(x)
 *     ----------------------------------------------------------
 *	    0	       S	   C		 T
 *	    1	       C	  -S		-1/T
 *	    2	      -S	  -C		 T
 *	    3	      -C	   S		-1/T
 *     ----------------------------------------------------------
 *
 * Special cases:
 *      Let trig be any of sin, cos, or tan.
 *      trig(+-INF)  is NaN, with signals;
 *      trig(NaN)    is that NaN;
 *
 * Accuracy:
 *	TRIG(x) returns trig(x) nearly rounded 
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_sin

double __ieee754_sin(double x)
{
	double y[2], z = 0.0;
	int32_t n, ix;

	/* High word of x. */
	GET_HIGH_WORD(ix, x);

	/* |x| ~< pi/4 */
	ix &= IC(0x7fffffff);
	if (ix <= IC(0x3fe921fb))
		return __kernel_sin(x, z, 0);

	/* sin(Inf or NaN) is NaN */
	else if (ix >= IC(0x7ff00000))
		return x - x;

	/* argument reduction needed */
	else
	{
		n = __ieee754_rem_pio2(x, y);
		switch ((int)(n & 3))
		{
		case 0:
			return __kernel_sin(y[0], y[1], 1);
		case 1:
			return __kernel_cos(y[0], y[1]);
		case 2:
			return -__kernel_sin(y[0], y[1], 1);
		default:
			return -__kernel_cos(y[0], y[1]);
		}
	}
}

#endif

double __sin(double x)
{
	double ret;
	
	ret = __ieee754_sin(x);
	if (isnan(ret) && !isnan(x))
		ret = __kernel_standard(x, x, ret, KMATHERR_SIN_INF);
	return ret;
}

__typeof(__sin) sin __attribute__((weak, alias("__sin")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(__sinl) __sinl __attribute__((alias("__sin")));
__typeof(__sinl) sinl __attribute__((weak, alias("__sin")));
#endif

```

`s_sincos.c`:

```c
#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_sincos

void __ieee754_sincos(double x, double *sinx, double *cosx)
{
	*sinx = __ieee754_sin(x);
	*cosx = __ieee754_cos(x);
}

#endif

void __sincos(double x, double *sinx, double *cosx)
{
	int32_t ix;

	/* High word of x. */
	GET_HIGH_WORD(ix, x);

	/* |x| ~< pi/4 */
	ix &= IC(0x7fffffff);
	if (ix >= IC(0x7ff00000))
	{
		/* sin(Inf or NaN) is NaN */
		*sinx = *cosx = x - x;
	} else
	{
		__ieee754_sincos(x, sinx, cosx);
	}
}

__typeof(__sincos) sincos __attribute__((weak, alias("__sincos")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(__sincosl) __sincosl __attribute__((alias("__sincos")));
__typeof(__sincosl) sincosl __attribute__((weak, alias("__sincos")));
#endif

```

`s_sincosf.c`:

```c
#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_sincos

void __ieee754_sincosf(float x, float *sinx, float *cosx)
{
	*sinx = sinf(x);
	*cosx = cosf(x);
}

#endif

void __sincosf(float x, float *sinx, float *cosx)
{
	int32_t ix;

	/* High word of x. */
	GET_FLOAT_WORD(ix, x);

	/* |x| ~< pi/4 */
	ix &= IC(0x7fffffff);
	if (ix <= IC(0x3f490fd8))
	{
#ifdef __have_fpu_sincos
		__ieee754_sincosf(x, sinx, cosx);
#else
		*sinx = __kernel_sinf(x, 0.0, 0);
		*cosx = __kernel_cosf(x, 0.0);
#endif
	} else if (ix >= IC(0x7f800000))
	{
		/* sin(Inf or NaN) is NaN */
		*sinx = *cosx = x - x;
	} else
	{
#ifdef __have_fpu_sincos
		__ieee754_sincosf(x, sinx, cosx);
#else
		/* Argument reduction needed.  */
		float y[2];
		int32_t n;

		n = __ieee754_rem_pio2f(x, y);
		switch ((int)(n & 3))
		{
		case 0:
			*sinx = __kernel_sinf(y[0], y[1], 1);
			*cosx = __kernel_cosf(y[0], y[1]);
			break;
		case 1:
			*sinx = __kernel_cosf(y[0], y[1]);
			*cosx = -__kernel_sinf(y[0], y[1], 1);
			break;
		case 2:
			*sinx = -__kernel_sinf(y[0], y[1], 1);
			*cosx = -__kernel_cosf(y[0], y[1]);
			break;
		default:
			*sinx = -__kernel_cosf(y[0], y[1]);
			*cosx = __kernel_sinf(y[0], y[1], 1);
			break;
		}
#endif
	}
}

__typeof(__sincosf) sincosf __attribute__((weak, alias("__sincosf")));

```

`s_sincosl.c`:

```c
#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

#ifndef __have_fpu_sincos

void __ieee754_sincosl(long double x, long double *sinx, long double *cosx)
{
	*sinx = __ieee754_sinl(x);
	*cosx = __ieee754_cosl(x);
}

#endif

void __sincosl(long double x, long double *sinx, long double *cosx)
{
	int32_t se;
	uint32_t i0, i1;

	/* High word of x. */
	GET_LDOUBLE_WORDS(se, i0, i1, x);
	(void) i1;
	
	/* |x| ~< pi/4 */
	se &= 0x7fff;
	if (se < 0x3ffe || (se == 0x3ffe && i0 <= UC(0xc90fdaa2)))
	{
#ifdef __have_fpu_sincos
		__ieee754_sincosl(x, sinx, cosx);
#else
		*sinx = __kernel_sinl(x, 0.0, 0);
		*cosx = __kernel_cosl(x, 0.0);
#endif
	} else if (se == 0x7fff)
	{
		/* sin(Inf or NaN) is NaN */
		*sinx = *cosx = x - x;
	} else
	{
#ifdef __have_fpu_sincos
		__ieee754_sincosl(x, sinx, cosx);
#else
		/* Argument reduction needed.  */
		long double y[2];
		int32_t n;

		n = __ieee754_rem_pio2l(x, y);
		switch ((int)(n & 3))
		{
		case 0:
			*sinx = __kernel_sinl(y[0], y[1], 1);
			*cosx = __kernel_cosl(y[0], y[1]);
			break;
		case 1:
			*sinx = __kernel_cosl(y[0], y[1]);
			*cosx = -__kernel_sinl(y[0], y[1], 1);
			break;
		case 2:
			*sinx = -__kernel_sinl(y[0], y[1], 1);
			*cosx = -__kernel_cosl(y[0], y[1]);
			break;
		default:
			*sinx = -__kernel_cosl(y[0], y[1]);
			*cosx = __kernel_sinl(y[0], y[1], 1);
			break;
		}
#endif
	}
}

__typeof(__sincosl) sincosl __attribute__((weak, alias("__sincosl")));

#endif

```

`s_sinf.c`:

```c
/* sf_sin.c -- float version of s_sin.c.
 * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice 
 * is preserved.
 * ====================================================
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_sin

float __ieee754_sinf(float x)
{
	float y[2], z = 0.0;
	int32_t n, ix;

	GET_FLOAT_WORD(ix, x);

	/* |x| ~< pi/4 */
	ix &= IC(0x7fffffff);
	if (ix <= IC(0x3f490fd8))
		return __kernel_sinf(x, z, 0);

	/* sin(Inf or NaN) is NaN */
	else if (!FLT_UWORD_IS_FINITE(ix))
		return x - x;

	/* argument reduction needed */
	else
	{
		n = __ieee754_rem_pio2f(x, y);
		switch ((int)(n & 3))
		{
		case 0:
			return __kernel_sinf(y[0], y[1], 1);
		case 1:
			return __kernel_cosf(y[0], y[1]);
		case 2:
			return -__kernel_sinf(y[0], y[1], 1);
		default:
			return -__kernel_cosf(y[0], y[1]);
		}
	}
}

#endif

float __sinf(float x)
{
	float ret;
	
	ret = __ieee754_sinf(x);
	if (isnan(ret) && !isnan(x))
		ret = __kernel_standard_f(x, x, ret, KMATHERRF_SIN_INF);
	return ret;
}

__typeof(__sinf) sinf __attribute__((weak, alias("__sinf")));

```

`s_sinl.c`:

```c
/* s_sinl.c -- long double version of s_sin.c.
 * Conversion to long double by Ulrich Drepper,
 * Cygnus Support, drepper@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/* sinl(x)
 * Return sine function of x.
 *
 * kernel function:
 *	__kernel_sinl		... sine function on [-pi/4,pi/4]
 *	__kernel_cosl		... cose function on [-pi/4,pi/4]
 *	__ieee754_rem_pio2l	... argument reduction routine
 *
 * Method.
 *      Let S,C and T denote the sin, cos and tan respectively on
 *	[-PI/4, +PI/4]. Reduce the argument x to y1+y2 = x-k*pi/2
 *	in [-pi/4 , +pi/4], and let n = k mod 4.
 *	We have
 *
 *          n        sin(x)      cos(x)        tan(x)
 *     ----------------------------------------------------------
 *	    0	       S	   C		 T
 *	    1	       C	  -S		-1/T
 *	    2	      -S	  -C		 T
 *	    3	      -C	   S		-1/T
 *     ----------------------------------------------------------
 *
 * Special cases:
 *      Let trig be any of sin, cos, or tan.
 *      trig(+-INF)  is NaN, with signals;
 *      trig(NaN)    is that NaN;
 *
 * Accuracy:
 *	TRIG(x) returns trig(x) nearly rounded
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

#ifndef __have_fpu_sin

long double __ieee754_sinl(long double x)
{
	long double y[2], z = 0.0;
	int32_t n, se;
	uint32_t i0, i1;

	/* High word of x. */
	GET_LDOUBLE_WORDS(se, i0, i1, x);
	(void) i1;
	
	/* |x| ~< pi/4 */
	se &= 0x7fff;
	if (se < 0x3ffe || (se == 0x3ffe && i0 <= UC(0xc90fdaa2)))
		return __kernel_sinl(x, z, 0);

	/* sin(Inf or NaN) is NaN */
	else if (se == 0x7fff)
		return x - x;

	/* argument reduction needed */
	else
	{
		n = __ieee754_rem_pio2l(x, y);
		switch ((int)(n & 3))
		{
		case 0:
			return __kernel_sinl(y[0], y[1], 1);
		case 1:
			return __kernel_cosl(y[0], y[1]);
		case 2:
			return -__kernel_sinl(y[0], y[1], 1);
		default:
			return -__kernel_cosl(y[0], y[1]);
		}
	}
}

#endif

long double __sinl(long double x)
{
	long double ret;
	
	ret = __ieee754_sinl(x);
	if (isnan(ret) && !isnan(x))
		ret = __kernel_standard_l(x, x, ret, KMATHERRL_SIN_INF);
	return ret;
}

__typeof(__sinl) sinl __attribute__((weak, alias("__sinl")));

#endif

```

`s_tan.c`:

```c
/* @(#)s_tan.c 1.3 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/* tan(x)
 * Return tangent function of x.
 *
 * kernel function:
 *	__kernel_tan		... tangent function on [-pi/4,pi/4]
 *	__ieee754_rem_pio2	... argument reduction routine
 *
 * Method.
 *      Let S,C and T denote the sin, cos and tan respectively on 
 *	[-PI/4, +PI/4]. Reduce the argument x to y1+y2 = x-k*pi/2 
 *	in [-pi/4 , +pi/4], and let n = k mod 4.
 *	We have
 *
 *          n        sin(x)      cos(x)        tan(x)
 *     ----------------------------------------------------------
 *	    0	       S	   C		 T
 *	    1	       C	  -S		-1/T
 *	    2	      -S	  -C		 T
 *	    3	      -C	   S		-1/T
 *     ----------------------------------------------------------
 *
 * Special cases:
 *      Let trig be any of sin, cos, or tan.
 *      trig(+-INF)  is NaN, with signals;
 *      trig(NaN)    is that NaN;
 *
 * Accuracy:
 *	TRIG(x) returns trig(x) nearly rounded 
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_tan

double __ieee754_tan(double x)
{
	double y[2], z = 0.0;
	int32_t n, ix;

	/* High word of x. */
	GET_HIGH_WORD(ix, x);

	/* |x| ~< pi/4 */
	ix &= IC(0x7fffffff);
	if (ix <= IC(0x3fe921fb))
		return __kernel_tan(x, z, 1);

	/* tan(Inf or NaN) is NaN */
	else if (ix >= IC(0x7ff00000))
		return x - x;					/* NaN */

	/* argument reduction needed */
	else
	{
		n = __ieee754_rem_pio2(x, y);
		return __kernel_tan(y[0], y[1], (int)(1 - ((n & 1) << 1)));	/*   1 -- n even
																   -1 -- n odd */
	}
}

#endif


double __tan(double x)
{
	double ret;
	
	ret = __ieee754_tan(x);
	if (isnan(ret) && isinf(x))
		ret = __kernel_standard(x, x, ret, KMATHERR_TAN_INF);
	return ret;
}

__typeof(__tan) tan __attribute__((weak, alias("__tan")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(__tanl) __tanl __attribute__((alias("__tan")));
__typeof(__tanl) tanl __attribute__((weak, alias("__tan")));
#endif

```

`s_tanf.c`:

```c
/* s_tanf.c -- float version of s_tan.c.
 * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_tan

float __ieee754_tanf(float x)
{
	float y[2], z = 0.0;
	int32_t n, ix;

	GET_FLOAT_WORD(ix, x);

	/* |x| ~< pi/4 */
	ix &= IC(0x7fffffff);
	if (ix <= IC(0x3f490fda))
		return __kernel_tanf(x, z, 1);

	/* tan(Inf or NaN) is NaN */
	else if (!FLT_UWORD_IS_FINITE(ix))
		return x - x;					/* NaN */

	/* argument reduction needed */
	else
	{
		n = __ieee754_rem_pio2f(x, y);
		return __kernel_tanf(y[0], y[1], (int)(1 - ((n & 1) << 1)));	/*   1 -- n even -1 -- n odd */
	}
}

#endif

float __tanf(float x)
{
	float ret;
	
	ret = __ieee754_tan(x);
	if (isnan(ret) && isinf(x))
		ret = __kernel_standard_f(x, x, ret, KMATHERRF_TAN_INF);
	return ret;
}

__typeof(__tanf) tanf __attribute__((weak, alias("__tanf")));

```

`s_tanh.c`:

```c
/* @(#)s_tanh.c 1.3 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/* Tanh(x)
 * Return the Hyperbolic Tangent of x
 *
 * Method :
 *				       x    -x
 *				      e  - e
 *	0. tanh(x) is defined to be -----------
 *				       x    -x
 *				      e  + e
 *	1. reduce x to non-negative by tanh(-x) = -tanh(x).
 *	2.  0      <= x <= 2**-55 : tanh(x) := x*(one+x)
 *					        -t
 *	    2**-55 <  x <=  1     : tanh(x) := -----; t = expm1(-2x)
 *					       t + 2
 *						     2
 *	    1      <= x <=  22.0  : tanh(x) := 1-  ----- ; t=expm1(2x)
 *						   t + 2
 *	    22.0   <  x <= INF    : tanh(x) := 1.
 *
 * Special cases:
 *	tanh(NaN) is NaN;
 *	only tanh(0)=0 is exact for finite argument.
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_tanh

double __ieee754_tanh(double x)
{
	double t, z;
	int32_t jx, ix, lx;

	static const double one = 1.0;
	static const double two = 2.0;
	static const double tiny = 1.0e-300;

	/* High word of |x|. */
	GET_DOUBLE_WORDS(jx, lx, x);
	ix = jx & IC(0x7fffffff);

	/* x is INF or NaN */
	if (ix >= IC(0x7ff00000))
	{
		if (jx >= 0)
			return one / x + one;		/* tanh(+-inf)=+-1 */
		else
			return one / x - one;		/* tanh(NaN) = NaN */
	}

	/* |x| < 22 */
	if (ix < IC(0x40360000))
	{									/* |x|<22 */
		if ((ix | lx) == 0)
			return x;					/* x == +-0 */
		if (ix < IC(0x3c800000))		/* |x|<2**-55 */
			return x * (one + x);		/* tanh(small) = small */
		if (ix >= IC(0x3ff00000))
		{								/* |x|>=1  */
			t = __ieee754_expm1(two * __ieee754_fabs(x));
			z = one - two / (t + two);
		} else
		{
			t = __ieee754_expm1(-two * __ieee754_fabs(x));
			z = -t / (t + two);
		}
		/* |x| > 22, return +-1 */
	} else
	{
		z = one - tiny;					/* raised inexact flag */
	}
	return (jx >= 0) ? z : -z;
}

#endif

double __tanh(double x)
{
	return __ieee754_tanh(x);
}

__typeof(__tanh) tanh __attribute__((weak, alias("__tanh")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(__tanhl) __tanhl __attribute__((alias("__tanh")));
__typeof(__tanhl) tanhl __attribute__((weak, alias("__tanh")));
#endif

```

`s_tanhf.c`:

```c
/* s_tanhf.c -- float version of s_tanh.c.
 * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_tanh

float __ieee754_tanhf(float x)
{
	float t, z;
	int32_t jx, ix;

	static const float one = 1.0;
	static const float two = 2.0;
	static const float tiny = 1.0e-30;
	
	GET_FLOAT_WORD(jx, x);
	ix = jx & IC(0x7fffffff);

	/* x is INF or NaN */
	if (!FLT_UWORD_IS_FINITE(ix))
	{
		if (jx >= 0)
			return one / x + one;		/* tanh(+-inf)=+-1 */
		else
			return one / x - one;		/* tanh(NaN) = NaN */
	}

	/* |x| < 22 */
	if (ix < IC(0x41b00000))
	{									/* |x|<22 */
		if (ix == 0)
			return x;					/* x == +-0 */
		if (ix < IC(0x24000000))		/* |x|<2**-55 */
			return x * (one + x);		/* tanh(small) = small */
		if (ix >= IC(0x3f800000))
		{								/* |x|>=1  */
			t = expm1f(two * __ieee754_fabsf(x));
			z = one - two / (t + two);
		} else
		{
			t = expm1f(-two * __ieee754_fabsf(x));
			z = -t / (t + two);
		}
		/* |x| > 22, return +-1 */
	} else
	{
		z = one - tiny;					/* raised inexact flag */
	}
	return (jx >= 0) ? z : -z;
}

#endif

float __tanhf(float x)
{
	return __ieee754_tanhf(x);
}

__typeof(__tanhf) tanhf __attribute__((weak, alias("__tanhf")));

```

`s_tanhl.c`:

```c
/* s_tanhl.c -- long double version of s_tanh.c.
 * Conversion to long double by Ulrich Drepper,
 * Cygnus Support, drepper@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/* tanhl(x)
 * Return the Hyperbolic Tangent of x
 *
 * Method :
 *				        x    -x
 *				       e  - e
 *	0. tanhl(x) is defined to be -----------
 *				        x    -x
 *				       e  + e
 *	1. reduce x to non-negative by tanhl(-x) = -tanhl(x).
 *	2.  0      <= x <= 2**-55 : tanhl(x) := x*(one+x)
 *					         -t
 *	    2**-55 <  x <=  1     : tanhl(x) := -----; t = expm1l(-2x)
 *					        t + 2
 *						      2
 *	    1      <= x <=  23.0  : tanhl(x) := 1-  ----- ; t=expm1l(2x)
 *						    t + 2
 *	    23.0   <  x <= INF    : tanhl(x) := 1.
 *
 * Special cases:
 *	tanhl(NaN) is NaN;
 *	only tanhl(0)=0 is exact for finite argument.
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

#ifndef __have_fpu_tanh

long double __ieee754_tanhl(long double x)
{
	long double t, z;
	int32_t se;
	uint32_t j0, j1, ix;

	static const long double one = 1.0;
	static const long double two = 2.0;
	static const long double tiny = 1.0e-4900L;
	
	/* High word of |x|. */
	GET_LDOUBLE_WORDS(se, j0, j1, x);
	ix = se & 0x7fff;

	/* x is INF or NaN */
	if (ix == 0x7fff)
	{
		/* for NaN it's not important which branch: tanhl(NaN) = NaN */
		if (se & 0x8000)
			return one / x - one;		/* tanhl(-inf)= -1; */
		else
			return one / x + one;		/* tanhl(+inf)=+1 */
	}

	/* |x| < 23 */
	if (ix < 0x4003 || (ix == 0x4003 && j0 < UC(0xb8000000)))
	{									/* |x|<23 */
		if ((ix | j0 | j1) == 0)
			return x;					/* x == +- 0 */
		if (ix < 0x3fc8)				/* |x|<2**-55 */
			return x * (one + tiny);	/* tanh(small) = small */
		if (ix >= 0x3fff)
		{								/* |x|>=1  */
			t = __ieee754_expm1l(two * __ieee754_fabsl(x));
			z = one - two / (t + two);
		} else
		{
			t = __ieee754_expm1l(-two * __ieee754_fabsl(x));
			z = -t / (t + two);
		}
		/* |x| > 23, return +-1 */
	} else
	{
		z = one - tiny;					/* raised inexact flag */
	}
	return (se & 0x8000) ? -z : z;
}

#endif

long double __tanhl(long double x)
{
	return __ieee754_tanhl(x);
}

__typeof(__tanhl) tanhl __attribute__((weak, alias("__tanhl")));

#endif

```

`s_tanl.c`:

```c
/* s_tanl.c -- long double version of s_tan.c.
 * Conversion to long double by Ulrich Drepper,
 * Cygnus Support, drepper@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/* tanl(x)
 * Return tangent function of x.
 *
 * kernel function:
 *	__kernel_tanl		... tangent function on [-pi/4,pi/4]
 *	__ieee754_rem_pio2l	... argument reduction routine
 *
 * Method.
 *      Let S,C and T denote the sin, cos and tan respectively on
 *	[-PI/4, +PI/4]. Reduce the argument x to y1+y2 = x-k*pi/2
 *	in [-pi/4 , +pi/4], and let n = k mod 4.
 *	We have
 *
 *          n        sin(x)      cos(x)        tan(x)
 *     ----------------------------------------------------------
 *	    0	       S	   C		 T
 *	    1	       C	  -S		-1/T
 *	    2	      -S	  -C		 T
 *	    3	      -C	   S		-1/T
 *     ----------------------------------------------------------
 *
 * Special cases:
 *      Let trig be any of sin, cos, or tan.
 *      trig(+-INF)  is NaN, with signals;
 *      trig(NaN)    is that NaN;
 *
 * Accuracy:
 *	TRIG(x) returns trig(x) nearly rounded
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

#ifndef __have_fpu_tan

long double __ieee754_tanl(long double x)
{
	long double y[2], z = 0.0;
	int32_t n, se;

	/* High word of x. */
	GET_LDOUBLE_EXP(se, x);

	/* |x| ~< pi/4 */
	se &= 0x7fff;
	if (se <= 0x3ffe)
		return __kernel_tanl(x, z, 1);

	/* tan(Inf or NaN) is NaN */
	else if (se == 0x7fff)
		return x - x;

	/* argument reduction needed */
	else
	{
		n = __ieee754_rem_pio2l(x, y);
		return __kernel_tanl(y[0], y[1], (int)(1 - ((n & 1) << 1)));	/*   1 -- n even -1 -- n odd */
	}
}

#endif


long double __tanl(long double x)
{
	long double ret;
	
	ret = __ieee754_tanl(x);
	if (isnan(ret) && isinf(x))
		ret = __kernel_standard_l(x, x, ret, KMATHERRL_TAN_INF);
	return ret;
}

__typeof(__tanl) tanl __attribute__((weak, alias("__tanl")));

#endif

```

`s_trunc.c`:

```c
#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_trunc

double __ieee754_trunc(double x)
{
	int32_t i0, j0;
	uint32_t i1;
	int32_t sx;

	GET_DOUBLE_WORDS(i0, i1, x);
	sx = i0 & IC(0x80000000);
	j0 = ((i0 >> IEEE754_DOUBLE_SHIFT) & IEEE754_DOUBLE_MAXEXP) - IEEE754_DOUBLE_BIAS;
	if (j0 < IEEE754_DOUBLE_SHIFT)
	{
		if (j0 < 0)
			/* The magnitude of the number is < 1 so the result is +-0.  */
			INSERT_WORDS(x, sx, 0);
		else
			INSERT_WORDS(x, sx | (i0 & ~(UC(0x000fffff) >> j0)), 0);
	} else if (j0 > 51)
	{
		if (j0 == (IEEE754_DOUBLE_MAXEXP - IEEE754_DOUBLE_BIAS))
			/* x is inf or NaN.  */
			return x + x;
	} else
	{
		INSERT_WORDS(x, i0, i1 & ~(UC(0xffffffff) >> (j0 - IEEE754_DOUBLE_SHIFT)));
	}

	return x;
}

#endif

double __trunc(double x)
{
	return __ieee754_trunc(x);
}

__typeof(__trunc) trunc __attribute__((weak, alias("__trunc")));
#ifdef __NO_LONG_DOUBLE_MATH
long double __truncl(long double x) __attribute__((alias("__trunc")));
__typeof(__truncl) truncl __attribute__((weak, alias("__trunc")));
#endif

```

`s_truncf.c`:

```c
#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __have_fpu_trunc

float __ieee754_truncf(float x)
{
	int32_t i0, j0;
	int32_t sx;

	GET_FLOAT_WORD(i0, x);
	sx = i0 & UC(0x80000000);
	j0 = ((i0 >> IEEE754_FLOAT_SHIFT) & IEEE754_FLOAT_MAXEXP) - IEEE754_FLOAT_BIAS;
	if (j0 < IEEE754_FLOAT_SHIFT)
	{
		if (j0 < 0)
		{
			/* The magnitude of the number is < 1 so the result is +-0.  */
			SET_FLOAT_WORD(x, sx);
		} else
		{
			SET_FLOAT_WORD(x, sx | (i0 & ~(UC(0x007fffff) >> j0)));
		}
	} else
	{
		if (j0 == (IEEE754_FLOAT_MAXEXP - IEEE754_FLOAT_BIAS))
			/* x is inf or NaN.  */
			return x + x;
	}

	return x;
}

#endif

float __truncf(float x)
{
	return __ieee754_truncf(x);
}

__typeof(__truncf) truncf __attribute__((weak, alias("__truncf")));

```

`s_truncl.c`:

```c
#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

#ifndef __have_fpu_trunc

long double __ieee754_truncl(long double x)
{
	int32_t i0, j0;
	uint32_t se, i1;
	int32_t sx;

	GET_LDOUBLE_WORDS(se, i0, i1, x);
	sx = se & 0x8000;
	j0 = (se & IEEE854_LONG_DOUBLE_MAXEXP) - IEEE854_LONG_DOUBLE_BIAS;
	if (j0 < 31)
	{
		if (j0 < 0)
			/* The magnitude of the number is < 1 so the result is +-0.  */
			SET_LDOUBLE_WORDS(x, sx, 0, 0);
		else
			SET_LDOUBLE_WORDS(x, se, i0 & ~(UC(0x7fffffff) >> j0), 0);
	} else if (j0 > 63)
	{
		if (j0 == (IEEE854_LONG_DOUBLE_MAXEXP - IEEE854_LONG_DOUBLE_BIAS))
			/* x is inf or NaN.  */
			return x + x;
	} else
	{
		/* avoid undefined behaviour for shift-count == 32 */
		if (j0 != 63)
			SET_LDOUBLE_WORDS(x, se, i0, i1 & ~(UC(0xffffffff) >> (j0 - 31)));
	}

	return x;
}

#endif

long double __truncl(long double x)
{
	return __ieee754_truncl(x);
}

__typeof(__truncl) truncl __attribute__((weak, alias("__truncl")));

#endif

```

`t_erf.h`:

```h
	/*
	 * Coefficients for approximation to  erf on [0,0.84375]
	 */
	static const double pp0 =  1.28379167095512558561e-01;	/* 0x3FC06EBA, 0x8214DB68 */
	static const double pp1 = -3.25042107247001499370e-01;	/* 0xBFD4CD7D, 0x691CB913 */
	static const double pp2 = -2.84817495755985104766e-02;	/* 0xBF9D2A51, 0xDBD7194F */
	static const double pp3 = -5.77027029648944159157e-03;	/* 0xBF77A291, 0x236668E4 */
	static const double pp4 = -2.37630166566501626084e-05;	/* 0xBEF8EAD6, 0x120016AC */
	static const double qq1 =  3.97917223959155352819e-01;	/* 0x3FD97779, 0xCDDADC09 */
	static const double qq2 =  6.50222499887672944485e-02;	/* 0x3FB0A54C, 0x5536CEBA */
	static const double qq3 =  5.08130628187576562776e-03;	/* 0x3F74D022, 0xC4D36B0F */
	static const double qq4 =  1.32494738004321644526e-04;	/* 0x3F215DC9, 0x221C1A10 */
	static const double qq5 = -3.96022827877536812320e-06;	/* 0xBED09C43, 0x42A26120 */
	/*
	 * Coefficients for approximation to  erf  in [0.84375,1.25]
	 */
	static const double pa0 = -2.36211856075265944077e-03;	/* 0xBF6359B8, 0xBEF77538 */
	static const double pa1 =  4.14856118683748331666e-01;	/* 0x3FDA8D00, 0xAD92B34D */
	static const double pa2 = -3.72207876035701323847e-01;	/* 0xBFD7D240, 0xFBB8C3F1 */
	static const double pa3 =  3.18346619901161753674e-01;	/* 0x3FD45FCA, 0x805120E4 */
	static const double pa4 = -1.10894694282396677476e-01;	/* 0xBFBC6398, 0x3D3E28EC */
	static const double pa5 =  3.54783043256182359371e-02;	/* 0x3FA22A36, 0x599795EB */
	static const double pa6 = -2.16637559486879084300e-03;	/* 0xBF61BF38, 0x0A96073F */
	static const double qa1 =  1.06420880400844228286e-01;	/* 0x3FBB3E66, 0x18EEE323 */
	static const double qa2 =  5.40397917702171048937e-01;	/* 0x3FE14AF0, 0x92EB6F33 */
	static const double qa3 =  7.18286544141962662868e-02;	/* 0x3FB2635C, 0xD99FE9A7 */
	static const double qa4 =  1.26171219808761642112e-01;	/* 0x3FC02660, 0xE763351F */
	static const double qa5 =  1.36370839120290507362e-02;	/* 0x3F8BEDC2, 0x6B51DD1C */
	static const double qa6 =  1.19844998467991074170e-02;	/* 0x3F888B54, 0x5735151D */
	/*
	 * Coefficients for approximation to  erfc in [1.25,1/0.35]
	 */
	static const double ra0 = -9.86494403484714822705e-03;	/* 0xBF843412, 0x600D6435 */
	static const double ra1 = -6.93858572707181764372e-01;	/* 0xBFE63416, 0xE4BA7360 */
	static const double ra2 = -1.05586262253232909814e+01;	/* 0xC0251E04, 0x41B0E726 */
	static const double ra3 = -6.23753324503260060396e+01;	/* 0xC04F300A, 0xE4CBA38D */
	static const double ra4 = -1.62396669462573470355e+02;	/* 0xC0644CB1, 0x84282266 */
	static const double ra5 = -1.84605092906711035994e+02;	/* 0xC067135C, 0xEBCCABB2 */
	static const double ra6 = -8.12874355063065934246e+01;	/* 0xC0545265, 0x57E4D2F2 */
	static const double ra7 = -9.81432934416914548592e+00;	/* 0xC023A0EF, 0xC69AC25C */
	static const double sa1 =  1.96512716674392571292e+01;	/* 0x4033A6B9, 0xBD707687 */
	static const double sa2 =  1.37657754143519042600e+02;	/* 0x4061350C, 0x526AE721 */
	static const double sa3 =  4.34565877475229228821e+02;	/* 0x407B290D, 0xD58A1A71 */
	static const double sa4 =  6.45387271733267880336e+02;	/* 0x40842B19, 0x21EC2868 */
	static const double sa5 =  4.29008140027567833386e+02;	/* 0x407AD021, 0x57700314 */
	static const double sa6 =  1.08635005541779435134e+02;	/* 0x405B28A3, 0xEE48AE2C */
	static const double sa7 =  6.57024977031928170135e+00;	/* 0x401A47EF, 0x8E484A93 */
	static const double sa8 = -6.04244152148580987438e-02;	/* 0xBFAEEFF2, 0xEE749A62 */
	/*
	 * Coefficients for approximation to  erfc in [1/.35,28]
	 */
	static const double rb0 = -9.86494292470009928597e-03;	/* 0xBF843412, 0x39E86F4A */
	static const double rb1 = -7.99283237680523006574e-01;	/* 0xBFE993BA, 0x70C285DE */
	static const double rb2 = -1.77579549177547519889e+01;	/* 0xC031C209, 0x555F995A */
	static const double rb3 = -1.60636384855821916062e+02;	/* 0xC064145D, 0x43C5ED98 */
	static const double rb4 = -6.37566443368389627722e+02;	/* 0xC083EC88, 0x1375F228 */
	static const double rb5 = -1.02509513161107724954e+03;	/* 0xC0900461, 0x6A2E5992 */
	static const double rb6 = -4.83519191608651397019e+02;	/* 0xC07E384E, 0x9BDC383F */
	static const double sb1 =  3.03380607434824582924e+01;	/* 0x403E568B, 0x261D5190 */
	static const double sb2 =  3.25792512996573918826e+02;	/* 0x40745CAE, 0x221B9F0A */
	static const double sb3 =  1.53672958608443695994e+03;	/* 0x409802EB, 0x189D5118 */
	static const double sb4 =  3.19985821950859553908e+03;	/* 0x40A8FFB7, 0x688C246A */
	static const double sb5 =  2.55305040643316442583e+03;	/* 0x40A3F219, 0xCEDF3BE6 */
	static const double sb6 =  4.74528541206955367215e+02;	/* 0x407DA874, 0xE79FE763 */
	static const double sb7 = -2.24409524465858183362e+01;	/* 0xC03670E2, 0x42712D62 */

```

`t_erff.h`:

```h
/*
 * Coefficients for approximation to  erf on [0,0.84375]
 */
static const float pp0 = 1.2837916613e-01;			/* 0x3e0375d4 */
static const float pp1 = -3.2504209876e-01;			/* 0xbea66beb */
static const float pp2 = -2.8481749818e-02;			/* 0xbce9528f */
static const float pp3 = -5.7702702470e-03;			/* 0xbbbd1489 */
static const float pp4 = -2.3763017452e-05;			/* 0xb7c756b1 */
static const float qq1 = 3.9791721106e-01;			/* 0x3ecbbbce */
static const float qq2 = 6.5022252500e-02;			/* 0x3d852a63 */
static const float qq3 = 5.0813062117e-03;			/* 0x3ba68116 */
static const float qq4 = 1.3249473704e-04;			/* 0x390aee49 */
static const float qq5 = -3.9602282413e-06;			/* 0xb684e21a */
/*
 * Coefficients for approximation to  erf  in [0.84375,1.25]
 */
static const float pa0 = -2.3621185683e-03;			/* 0xbb1acdc6 */
static const float pa1 = 4.1485610604e-01;			/* 0x3ed46805 */
static const float pa2 = -3.7220788002e-01;			/* 0xbebe9208 */
static const float pa3 = 3.1834661961e-01;			/* 0x3ea2fe54 */
static const float pa4 = -1.1089469492e-01;			/* 0xbde31cc2 */
static const float pa5 = 3.5478305072e-02;			/* 0x3d1151b3 */
static const float pa6 = -2.1663755178e-03;			/* 0xbb0df9c0 */
static const float qa1 = 1.0642088205e-01;			/* 0x3dd9f331 */
static const float qa2 = 5.4039794207e-01;			/* 0x3f0a5785 */
static const float qa3 = 7.1828655899e-02;			/* 0x3d931ae7 */
static const float qa4 = 1.2617121637e-01;			/* 0x3e013307 */
static const float qa5 = 1.3637083583e-02;			/* 0x3c5f6e13 */
static const float qa6 = 1.1984500103e-02;			/* 0x3c445aa3 */
/*
 * Coefficients for approximation to  erfc in [1.25,1/0.35]
 */
static const float ra0 = -9.8649440333e-03;			/* 0xbc21a093 */
static const float ra1 = -6.9385856390e-01;			/* 0xbf31a0b7 */
static const float ra2 = -1.0558626175e+01;			/* 0xc128f022 */
static const float ra3 = -6.2375331879e+01;			/* 0xc2798057 */
static const float ra4 = -1.6239666748e+02;			/* 0xc322658c */
static const float ra5 = -1.8460508728e+02;			/* 0xc3389ae7 */
static const float ra6 = -8.1287437439e+01;			/* 0xc2a2932b */
static const float ra7 = -9.8143291473e+00;			/* 0xc11d077e */
static const float sa1 = 1.9651271820e+01;			/* 0x419d35ce */
static const float sa2 = 1.3765776062e+02;			/* 0x4309a863 */
static const float sa3 = 4.3456588745e+02;			/* 0x43d9486f */
static const float sa4 = 6.4538726807e+02;			/* 0x442158c9 */
static const float sa5 = 4.2900814819e+02;			/* 0x43d6810b */
static const float sa6 = 1.0863500214e+02;			/* 0x42d9451f */
static const float sa7 = 6.5702495575e+00;			/* 0x40d23f7c */
static const float sa8 = -6.0424413532e-02;			/* 0xbd777f97 */
/*
 * Coefficients for approximation to  erfc in [1/.35,28]
 */
static const float rb0 = -9.8649431020e-03;			/* 0xbc21a092 */
static const float rb1 = -7.9928326607e-01;			/* 0xbf4c9dd4 */
static const float rb2 = -1.7757955551e+01;			/* 0xc18e104b */
static const float rb3 = -1.6063638306e+02;			/* 0xc320a2ea */
static const float rb4 = -6.3756646729e+02;			/* 0xc41f6441 */
static const float rb5 = -1.0250950928e+03;			/* 0xc480230b */
static const float rb6 = -4.8351919556e+02;			/* 0xc3f1c275 */
static const float sb1 = 3.0338060379e+01;			/* 0x41f2b459 */
static const float sb2 = 3.2579251099e+02;			/* 0x43a2e571 */
static const float sb3 = 1.5367296143e+03;			/* 0x44c01759 */
static const float sb4 = 3.1998581543e+03;			/* 0x4547fdbb */
static const float sb5 = 2.5530502930e+03;			/* 0x451f90ce */
static const float sb6 = 4.7452853394e+02;			/* 0x43ed43a7 */
static const float sb7 = -2.2440952301e+01;			/* 0xc1b38712 */


```

`t_erfl.h`:

```h
/*
 * Coefficients for approximation to  erf on [0,0.84375]
 */
static const long double pp[6] = {
	1.122751350964552113068262337278335028553E6L,
	-2.808533301997696164408397079650699163276E6L,
	-3.314325479115357458197119660818768924100E5L,
	-6.848684465326256109712135497895525446398E4L,
	-2.657817695110739185591505062971929859314E3L,
	-1.655310302737837556654146291646499062882E2L
};
static const long double qq[6] =
{
	8.745588372054466262548908189000448124232E6L,
	3.746038264792471129367533128637019611485E6L,
	7.066358783162407559861156173539693900031E5L,
	7.448928604824620999413120955705448117056E4L,
	4.511583986730994111992253980546131408924E3L,
	1.368902937933296323345610240009071254014E2L
	/* 1.000000000000000000000000000000000000000E0 */
};

/*
 * Coefficients for approximation to  erf  in [0.84375,1.25]
 */
/* erf(x+1) = 0.845062911510467529296875 + pa(x)/qa(x)
   -0.15625 <= x <= +.25
   Peak relative error 8.5e-22  */
static const long double pa[8] =
{
	-1.076952146179812072156734957705102256059E0L,
	1.884814957770385593365179835059971587220E2L,
	-5.339153975012804282890066622962070115606E1L,
	4.435910679869176625928504532109635632618E1L,
	1.683219516032328828278557309642929135179E1L,
	-2.360236618396952560064259585299045804293E0L,
	1.852230047861891953244413872297940938041E0L,
	9.394994446747752308256773044667843200719E-2L
};
static const long double qa[7] =
{
	4.559263722294508998149925774781887811255E2L,
	3.289248982200800575749795055149780689738E2L,
	2.846070965875643009598627918383314457912E2L,
	1.398715859064535039433275722017479994465E2L,
	6.060190733759793706299079050985358190726E1L,
	2.078695677795422351040502569964299664233E1L,
	4.641271134150895940966798357442234498546E0L
	/* 1.000000000000000000000000000000000000000E0 */
};

/*
 * Coefficients for approximation to  erfc in [1.25,1/0.35]
 */
/* erfc(1/x) = x exp (-1/x^2 - 0.5625 + ra(x^2)/sa(x^2))
   1/2.85711669921875 < 1/x < 1/1.25
   Peak relative error 3.1e-21  */
static const long double ra[] =
{
	1.363566591833846324191000679620738857234E-1L,
	1.018203167219873573808450274314658434507E1L,
	1.862359362334248675526472871224778045594E2L,
	1.411622588180721285284945138667933330348E3L,
	5.088538459741511988784440103218342840478E3L,
	8.928251553922176506858267311750789273656E3L,
	7.264436000148052545243018622742770549982E3L,
	2.387492459664548651671894725748959751119E3L,
	2.220916652813908085449221282808458466556E2L
};
static const long double sa[] =
{
	-1.382234625202480685182526402169222331847E1L,
	-3.315638835627950255832519203687435946482E2L,
	-2.949124863912936259747237164260785326692E3L,
	-1.246622099070875940506391433635999693661E4L,
	-2.673079795851665428695842853070996219632E4L,
	-2.880269786660559337358397106518918220991E4L,
	-1.450600228493968044773354186390390823713E4L,
	-2.874539731125893533960680525192064277816E3L,
	-1.402241261419067750237395034116942296027E2L,
	/* 1.000000000000000000000000000000000000000E0 */
};

/*
 * Coefficients for approximation to  erfc in [1/.35,107]
 */
/* erfc(1/x) = x exp (-1/x^2 - 0.5625 + rb(x^2)/sb(x^2))
   1/6.6666259765625 < 1/x < 1/2.85711669921875
   Peak relative error 4.2e-22  */
static const long double rb[] =
{
	-4.869587348270494309550558460786501252369E-5L,
	-4.030199390527997378549161722412466959403E-3L,
	-9.434425866377037610206443566288917589122E-2L,
	-9.319032754357658601200655161585539404155E-1L,
	-4.273788174307459947350256581445442062291E0L,
	-8.842289940696150508373541814064198259278E0L,
	-7.069215249419887403187988144752613025255E0L,
	-1.401228723639514787920274427443330704764E0L
};
static const long double sb[] =
{
	4.936254964107175160157544545879293019085E-3L,
	1.583457624037795744377163924895349412015E-1L,
	1.850647991850328356622940552450636420484E0L,
	9.927611557279019463768050710008450625415E0L,
	2.531667257649436709617165336779212114570E1L,
	2.869752886406743386458304052862814690045E1L,
	1.182059497870819562441683560749192539345E1L
	/* 1.000000000000000000000000000000000000000E0 */
};

```

`t_exp2.h`:

```h
/* These values are accurate to 52+12 bits when represented as
   a double.  */
static const double exp2_accuratetable[512] = {
0.707106781187802013759 /* 0x0.b504f333fb3f80007 */,
0.708064712808760599040 /* 0x0.b543baa0f71b38000 */,
0.709023942160304065938 /* 0x0.b58297d3a8d518002 */,
0.709984470998547667624 /* 0x0.b5c18ad39b4ba0001 */,
0.710946301084324217006 /* 0x0.b60093a85e8d30001 */,
0.711909434180505784637 /* 0x0.b63fb25984e628005 */,
0.712873872052760648733 /* 0x0.b67ee6eea3b5f8003 */,
0.713839616467838999908 /* 0x0.b6be316f518c98001 */,
0.714806669195984345523 /* 0x0.b6fd91e328d148007 */,
0.715775032009894562898 /* 0x0.b73d0851c69e20002 */,
0.716744706683768884058 /* 0x0.b77c94c2c9b3d0003 */,
0.717715694995770148178 /* 0x0.b7bc373dd52eb0003 */,
0.718687998724665488852 /* 0x0.b7fbefca8cd530004 */,
0.719661619652575468291 /* 0x0.b83bbe70981da8001 */,
0.720636559564428180758 /* 0x0.b87ba337a194b0006 */,
0.721612820246623098989 /* 0x0.b8bb9e27556508004 */,
0.722590403488338473025 /* 0x0.b8fbaf4762c798006 */,
0.723569311081411870036 /* 0x0.b93bd69f7be1d0000 */,
0.724549544820974333906 /* 0x0.b97c1437567828007 */,
0.725531106502312561633 /* 0x0.b9bc6816a87ae8002 */,
0.726513997924421062181 /* 0x0.b9fcd2452bee00000 */,
0.727498220889519875430 /* 0x0.ba3d52ca9e6148002 */,
0.728483777200401694265 /* 0x0.ba7de9aebe05c8003 */,
0.729470668664712662563 /* 0x0.babe96f94e62a8002 */,
0.730458897090379144517 /* 0x0.baff5ab2134df0004 */,
0.731448464287988597833 /* 0x0.bb4034e0d38ab0000 */,
0.732439372072965166897 /* 0x0.bb81258d5b2d60001 */,
0.733431622260458326859 /* 0x0.bbc22cbf75fd28001 */,
0.734425216668725511232 /* 0x0.bc034a7ef32c00001 */,
0.735420157118880535324 /* 0x0.bc447ed3a50fe0005 */,
0.736416445434497690674 /* 0x0.bc85c9c560b350001 */,
0.737414083433310718618 /* 0x0.bcc72b5bf4b4e0000 */,
0.738413072966152328496 /* 0x0.bd08a39f5417a8007 */,
0.739413415848264365956 /* 0x0.bd4a32974abcd0002 */,
0.740415113911250699637 /* 0x0.bd8bd84bb68300002 */,
0.741418168994518067562 /* 0x0.bdcd94c47ddd30003 */,
0.742422582936659858376 /* 0x0.be0f6809865968006 */,
0.743428357577745613238 /* 0x0.be515222b72530003 */,
0.744435494762383687126 /* 0x0.be935317fc6ba0002 */,
0.745443996335090397492 /* 0x0.bed56af1423de8001 */,
0.746453864145572798553 /* 0x0.bf1799b67a6248007 */,
0.747465100043933849969 /* 0x0.bf59df6f970e70002 */,
0.748477705883256683178 /* 0x0.bf9c3c248dbee8001 */,
0.749491683518965001732 /* 0x0.bfdeafdd568308000 */,
0.750507034813367890373 /* 0x0.c0213aa1f0fc38004 */,
0.751523761622240105153 /* 0x0.c063dc7a559ca0003 */,
0.752541865811731880422 /* 0x0.c0a6956e883ed8000 */,
0.753561349247157341600 /* 0x0.c0e965868bd220006 */,
0.754582213796583967110 /* 0x0.c12c4cca664cb8002 */,
0.755604461332336940791 /* 0x0.c16f4b42225350006 */,
0.756628093726406381068 /* 0x0.c1b260f5ca2c48002 */,
0.757653112855631305506 /* 0x0.c1f58ded6d72d8001 */,
0.758679520599333412360 /* 0x0.c238d2311e7d08001 */,
0.759707318837184453227 /* 0x0.c27c2dc8f00368005 */,
0.760736509456435783249 /* 0x0.c2bfa0bcfd1400000 */,
0.761767094336480043995 /* 0x0.c3032b155818d0000 */,
0.762799075372231349951 /* 0x0.c346ccda248cc0001 */,
0.763832454453522768941 /* 0x0.c38a8613805488005 */,
0.764867233473625618441 /* 0x0.c3ce56c98d1ca8005 */,
0.765903414329434539816 /* 0x0.c4123f04708d80002 */,
0.766940998920452976510 /* 0x0.c4563ecc532dc0001 */,
0.767979989148100838946 /* 0x0.c49a56295f9f88006 */,
0.769020386915772125040 /* 0x0.c4de8523c2b0a0001 */,
0.770062194131770905170 /* 0x0.c522cbc3ae94e0003 */,
0.771105412703856241146 /* 0x0.c5672a1154e6b8004 */,
0.772150044545352520777 /* 0x0.c5aba014ed5f18003 */,
0.773196091570364285606 /* 0x0.c5f02dd6b09288003 */,
0.774243555696622731700 /* 0x0.c634d35edb1260003 */,
0.775292438842697939641 /* 0x0.c67990b5aa5c18004 */,
0.776342742931542928455 /* 0x0.c6be65e360bed8000 */,
0.777394469888802008854 /* 0x0.c70352f0437f50004 */,
0.778447621641124243320 /* 0x0.c74857e498fd00006 */,
0.779502200118583399303 /* 0x0.c78d74c8ab5b60000 */,
0.780558207255445668515 /* 0x0.c7d2a9a4c959f8000 */,
0.781615644985491186966 /* 0x0.c817f681412f80002 */,
0.782674515247667956808 /* 0x0.c85d5b6666c150006 */,
0.783734819983036512536 /* 0x0.c8a2d85c904760003 */,
0.784796561133562109454 /* 0x0.c8e86d6c14f850002 */,
0.785859740645942328471 /* 0x0.c92e1a9d513ec8002 */,
0.786924360469767103536 /* 0x0.c973dff8a4b390007 */,
0.787990422552312885808 /* 0x0.c9b9bd866c6440007 */,
0.789057928854407064640 /* 0x0.c9ffb34f1444b0001 */,
0.790126881326406182996 /* 0x0.ca45c15afcc570001 */,
0.791197281930050233534 /* 0x0.ca8be7b292db38000 */,
0.792269132620954885659 /* 0x0.cad2265e3cbee8000 */,
0.793342435380726906957 /* 0x0.cb187d667d3d38006 */,
0.794417192158282659010 /* 0x0.cb5eecd3b33158006 */,
0.795493404931386649540 /* 0x0.cba574ae5d2e80001 */,
0.796571075671306805268 /* 0x0.cbec14fef2a348004 */,
0.797650206352955137846 /* 0x0.cc32cdcdef0000000 */,
0.798730798954342069432 /* 0x0.cc799f23d11d18000 */,
0.799812855456121796232 /* 0x0.ccc089091abb28004 */,
0.800896377841454287795 /* 0x0.cd078b86505c18003 */,
0.801981368096190028208 /* 0x0.cd4ea6a3f97720007 */,
0.803067828208752554378 /* 0x0.cd95da6aa057b8007 */,
0.804155760170129796375 /* 0x0.cddd26e2d21b28001 */,
0.805245165974338261710 /* 0x0.ce248c151f3330001 */,
0.806336047619038653883 /* 0x0.ce6c0a0a1c1350001 */,
0.807428407102107836855 /* 0x0.ceb3a0ca5d6be0006 */,
0.808522246427078927792 /* 0x0.cefb505e7e2550007 */,
0.809617567597010201484 /* 0x0.cf4318cf18a268002 */,
0.810714372621179513182 /* 0x0.cf8afa24ce1c98004 */,
0.811812663508675536069 /* 0x0.cfd2f4683f9810005 */,
0.812912442272482604912 /* 0x0.d01b07a2126188003 */,
0.814013710929394895825 /* 0x0.d06333daeff618001 */,
0.815116471495287542325 /* 0x0.d0ab791b80d028006 */,
0.816220725993571205593 /* 0x0.d0f3d76c75b330000 */,
0.817326476447408967199 /* 0x0.d13c4ed67f1cf8000 */,
0.818433724883006474832 /* 0x0.d184df6250e3b0001 */,
0.819542473330909460055 /* 0x0.d1cd8918a3a328004 */,
0.820652723822034690935 /* 0x0.d2164c02305fa0002 */,
0.821764478391968422618 /* 0x0.d25f2827b53fb0005 */,
0.822877739077315761840 /* 0x0.d2a81d91f188b8000 */,
0.823992507918612782109 /* 0x0.d2f12c49a8d290005 */,
0.825108786960634610365 /* 0x0.d33a5457a35e40003 */,
0.826226578247117093869 /* 0x0.d38395c4a84848007 */,
0.827345883828319528258 /* 0x0.d3ccf09985d958004 */,
0.828466705754248966560 /* 0x0.d41664df0a1320005 */,
0.829589046080638992111 /* 0x0.d45ff29e094330000 */,
0.830712906863802391671 /* 0x0.d4a999df585a20005 */,
0.831838290163696481037 /* 0x0.d4f35aabd04a60006 */,
0.832965198041969556729 /* 0x0.d53d350c4be258002 */,
0.834093632565442222342 /* 0x0.d5872909aba050007 */,
0.835223595802037643865 /* 0x0.d5d136acd138e8006 */,
0.836355089820669306292 /* 0x0.d61b5dfe9f7780004 */,
0.837488116698010487424 /* 0x0.d6659f0801afa8005 */,
0.838622678508982644113 /* 0x0.d6aff9d1e147d8004 */,
0.839758777333464490056 /* 0x0.d6fa6e652d19e0000 */,
0.840896415254110962690 /* 0x0.d744fccad70d00003 */,
0.842035594355151628676 /* 0x0.d78fa50bd2c3b0000 */,
0.843176316724478125433 /* 0x0.d7da673117e730007 */,
0.844318584453106590905 /* 0x0.d8254343a19038003 */,
0.845462399634695271912 /* 0x0.d870394c6dbf30003 */,
0.846607764365415071965 /* 0x0.d8bb49547d37c0004 */,
0.847754680744707056494 /* 0x0.d9067364d45608003 */,
0.848903150873708822763 /* 0x0.d951b7867953b0006 */,
0.850053176859071113491 /* 0x0.d99d15c2787a30006 */,
0.851204760807439786431 /* 0x0.d9e88e21de11a0003 */,
0.852357904828824897169 /* 0x0.da3420adba1508003 */,
0.853512611037803181642 /* 0x0.da7fcd6f2184d8005 */,
0.854668881550406100980 /* 0x0.dacb946f2afaf8000 */,
0.855826718478671755185 /* 0x0.db1775b6e8ad48000 */,
0.856986123964844970247 /* 0x0.db63714f8e0818006 */,
0.858147100114499461478 /* 0x0.dbaf87422625b8000 */,
0.859309649060962410524 /* 0x0.dbfbb797daa460002 */,
0.860473772936213743282 /* 0x0.dc480259d3a710001 */,
0.861639473872910177676 /* 0x0.dc9467913a0f48006 */,
0.862806754008130227807 /* 0x0.dce0e7473b9b28003 */,
0.863975615481124226159 /* 0x0.dd2d8185086c20006 */,
0.865146060433749419813 /* 0x0.dd7a3653d38168005 */,
0.866318091005120138881 /* 0x0.ddc705bcccd628000 */,
0.867491709362415264210 /* 0x0.de13efc9434100004 */,
0.868666917636779056818 /* 0x0.de60f4825df9b8005 */,
0.869843717989716047624 /* 0x0.deae13f16599c0003 */,
0.871022112578215268471 /* 0x0.defb4e1f9dc388002 */,
0.872202103559697183859 /* 0x0.df48a3164a92f0001 */,
0.873383693097737778847 /* 0x0.df9612deb6e878007 */,
0.874566883362160263365 /* 0x0.dfe39d82348310001 */,
0.875751676517234511901 /* 0x0.e031430a0f0688000 */,
0.876938074732511840819 /* 0x0.e07f037f97e548001 */,
0.878126080186539592654 /* 0x0.e0ccdeec2a75e0006 */,
0.879315695055312818168 /* 0x0.e11ad5591f4078001 */,
0.880506921518618312932 /* 0x0.e168e6cfd2f880004 */,
0.881699761760385225541 /* 0x0.e1b71359a6df60003 */,
0.882894217964411143207 /* 0x0.e2055afffc1178000 */,
0.884090292325693805080 /* 0x0.e253bdcc3ffbb8001 */,
0.885287987031581180559 /* 0x0.e2a23bc7d7a1d8002 */,
0.886487304278189114386 /* 0x0.e2f0d4fc31ab80004 */,
0.887688246263368285778 /* 0x0.e33f8972bea8a8005 */,
0.888890815189881999840 /* 0x0.e38e5934f49010007 */,
0.890095013257492739835 /* 0x0.e3dd444c460bd0007 */,
0.891300842677948068626 /* 0x0.e42c4ac232f380000 */,
0.892508305659222567226 /* 0x0.e47b6ca036f8b8005 */,
0.893717404414979710310 /* 0x0.e4caa9efd40e58002 */,
0.894928141160697743242 /* 0x0.e51a02ba8e2610007 */,
0.896140518115016826430 /* 0x0.e5697709ecab90000 */,
0.897354537501434679237 /* 0x0.e5b906e77c61d0006 */,
0.898570201543732793877 /* 0x0.e608b25cca5ba8005 */,
0.899787512470129891014 /* 0x0.e6587973688ce8002 */,
0.901006472512270728537 /* 0x0.e6a85c34ecadb8000 */,
0.902227083902570559127 /* 0x0.e6f85aaaed4f20006 */,
0.903449348881299796343 /* 0x0.e74874df09a530003 */,
0.904673269686823378091 /* 0x0.e798aadadecba0007 */,
0.905898848559668845585 /* 0x0.e7e8fca80c3ee0001 */,
0.907126087750156795426 /* 0x0.e8396a503c3fe0005 */,
0.908354989505901100354 /* 0x0.e889f3dd1615b0002 */,
0.909585556079328783087 /* 0x0.e8da9958465228007 */,
0.910817789726044213523 /* 0x0.e92b5acb7d0578001 */,
0.912051692703457872481 /* 0x0.e97c38406c3c30003 */,
0.913287267274154990210 /* 0x0.e9cd31c0cbb370001 */,
0.914524515702244578108 /* 0x0.ea1e475654d540000 */,
0.915763440256158633982 /* 0x0.ea6f790ac5cc78001 */,
0.917004043205012497909 /* 0x0.eac0c6e7dd8448007 */,
0.918246326823137892807 /* 0x0.eb1230f760a428007 */,
0.919490293387826285200 /* 0x0.eb63b7431714a8007 */,
0.920735945178816406225 /* 0x0.ebb559d4cb6f30007 */,
0.921983284479243714322 /* 0x0.ec0718b64c0940002 */,
0.923232313574974705626 /* 0x0.ec58f3f16a3910002 */,
0.924483034755387955725 /* 0x0.ecaaeb8ffb3168005 */,
0.925735450311948926408 /* 0x0.ecfcff9bd67078000 */,
0.926989562542820610982 /* 0x0.ed4f301edad1a0007 */,
0.928245373740515189457 /* 0x0.eda17d22e0f9b0001 */,
0.929502886213858126045 /* 0x0.edf3e6b1d37d40001 */,
0.930762102264245716494 /* 0x0.ee466cd594c5c8005 */,
0.932023024199046146183 /* 0x0.ee990f980dcdb0005 */,
0.933285654329454095216 /* 0x0.eeebcf032bc470007 */,
0.934549994971191289044 /* 0x0.ef3eab20e0d3c0001 */,
0.935816048439005676599 /* 0x0.ef91a3fb1e1340004 */,
0.937083817055075818404 /* 0x0.efe4b99bdcc618006 */,
0.938353303143720007819 /* 0x0.f037ec0d1889b8000 */,
0.939624509028518128972 /* 0x0.f08b3b58cc2bb8006 */,
0.940897437041863904384 /* 0x0.f0dea788fc2a90000 */,
0.942172089516254085427 /* 0x0.f13230a7ad21b8003 */,
0.943448468787511540534 /* 0x0.f185d6bee754e0006 */,
0.944726577195256100890 /* 0x0.f1d999d8b73478005 */,
0.946006417082291717338 /* 0x0.f22d79ff2cb130000 */,
0.947287990793413858827 /* 0x0.f281773c59ec48007 */,
0.948571300678290207925 /* 0x0.f2d5919a566268001 */,
0.949856349088629370320 /* 0x0.f329c9233bceb0001 */,
0.951143138379053731954 /* 0x0.f37e1de1272068002 */,
0.952431670908847949364 /* 0x0.f3d28fde3a6728006 */,
0.953721949039916472305 /* 0x0.f4271f249a93f0001 */,
0.955013975135367898520 /* 0x0.f47bcbbe6deab0001 */,
0.956307751564417496418 /* 0x0.f4d095b5e16638004 */,
0.957603280698967163097 /* 0x0.f5257d1524f590006 */,
0.958900564911197350604 /* 0x0.f57a81e668d628000 */,
0.960199606581278120057 /* 0x0.f5cfa433e60e50007 */,
0.961500408088936442422 /* 0x0.f624e407d527a0007 */,
0.962802971817578789903 /* 0x0.f67a416c72b760006 */,
0.964107300155846558292 /* 0x0.f6cfbc6c011458004 */,
0.965413395493874504368 /* 0x0.f7255510c439a8002 */,
0.966721260225105960572 /* 0x0.f77b0b6503c5b8006 */,
0.968030896745834645873 /* 0x0.f7d0df730a7940005 */,
0.969342307458006424716 /* 0x0.f826d145294be8003 */,
0.970655494764855020231 /* 0x0.f87ce0e5b29fd8000 */,
0.971970461071268720958 /* 0x0.f8d30e5efaa8f0004 */,
0.973287208789983648852 /* 0x0.f92959bb5e3c08001 */,
0.974605740331924708124 /* 0x0.f97fc305383028004 */,
0.975926058115625383329 /* 0x0.f9d64a46ebb9f8004 */,
0.977248164559556209435 /* 0x0.fa2cef8adbfc68004 */,
0.978572062087848637573 /* 0x0.fa83b2db7253d0007 */,
0.979897753126343307191 /* 0x0.fada944319fda0005 */,
0.981225240104636631254 /* 0x0.fb3193cc425870002 */,
0.982554525455618277276 /* 0x0.fb88b1815e61d0003 */,
0.983885611617111077747 /* 0x0.fbdfed6ce683e0007 */,
0.985218501026348891812 /* 0x0.fc3747995282f8006 */,
0.986553196127724962867 /* 0x0.fc8ec0112202a0005 */,
0.987889699367056062238 /* 0x0.fce656ded63710002 */,
0.989228013193998778636 /* 0x0.fd3e0c0cf48d50005 */,
0.990568140061241164686 /* 0x0.fd95dfa605c7b0003 */,
0.991910082424819927754 /* 0x0.fdedd1b4965710004 */,
0.993253842749249660216 /* 0x0.fe45e2433bfea0000 */,
0.994599423484053835071 /* 0x0.fe9e115c7c05f0005 */,
0.995946827107488830167 /* 0x0.fef65f0afb4c28006 */,
0.997296056085008264529 /* 0x0.ff4ecb59509cc8001 */,
0.998647112892057764479 /* 0x0.ffa756521dbfd0007 */,
1.000000000000000000000 /* 0x1.00000000000000000 */,
1.001354719891689004659 /* 0x1.0058c86da14aa0005 */,
1.002711275050312211844 /* 0x1.00b1afa5abead0003 */,
1.004069667960743483835 /* 0x1.010ab5b2cc0660009 */,
1.005429901112333324093 /* 0x1.0163da9fb2af30008 */,
1.006791976999887428009 /* 0x1.01bd1e7716f6a0008 */,
1.008155898118476168101 /* 0x1.02168143b03890006 */,
1.009521666967782227439 /* 0x1.027003103ae320002 */,
1.010889286051850133326 /* 0x1.02c9a3e7783030002 */,
1.012258757875921233497 /* 0x1.032363d42aaa8000e */,
1.013630084952214405194 /* 0x1.037d42e11c88d0000 */,
1.015003269791313389451 /* 0x1.03d741191635a0001 */,
1.016378314911229763267 /* 0x1.04315e86e84630008 */,
1.017755222831652872635 /* 0x1.048b9b35652800002 */,
1.019133996077934645224 /* 0x1.04e5f72f65827000b */,
1.020514637175266248212 /* 0x1.0540727fc1cfa0006 */,
1.021897148653734488385 /* 0x1.059b0d3157ebb0002 */,
1.023281533050062419584 /* 0x1.05f5c74f0cfeb0002 */,
1.024667792897328677539 /* 0x1.0650a0e3c22ee0003 */,
1.026055930738840826806 /* 0x1.06ab99fa63e1b0008 */,
1.027445949118511947550 /* 0x1.0706b29ddf2700009 */,
1.028837850584049418178 /* 0x1.0761ead9253ab0009 */,
1.030231637685799839262 /* 0x1.07bd42b72a3f80008 */,
1.031627312979383592802 /* 0x1.0818ba42e824a000c */,
1.033024879021186448496 /* 0x1.0874518759b0b0008 */,
1.034424338374263729911 /* 0x1.08d0088f80ffa0006 */,
1.035825693601787333992 /* 0x1.092bdf66604e30005 */,
1.037228947273990842283 /* 0x1.0987d617019cd000a */,
1.038634101961269928846 /* 0x1.09e3ecac6f199000f */,
1.040041160239590700707 /* 0x1.0a402331b91270002 */,
1.041450124688240164200 /* 0x1.0a9c79b1f37c3000b */,
1.042860997889083929381 /* 0x1.0af8f038352160000 */,
1.044273782427270314011 /* 0x1.0b5586cf986890006 */,
1.045688480893644856116 /* 0x1.0bb23d833dfbf0006 */,
1.047105095879385272564 /* 0x1.0c0f145e46e330007 */,
1.048523629981608529302 /* 0x1.0c6c0b6bdaadc000f */,
1.049944085800634585634 /* 0x1.0cc922b72470a000f */,
1.051366465939483019223 /* 0x1.0d265a4b5238b0007 */,
1.052790773004648849929 /* 0x1.0d83b23395e510002 */,
1.054217009607077093512 /* 0x1.0de12a7b263970006 */,
1.055645178360430591625 /* 0x1.0e3ec32d3cf680000 */,
1.057075281882416506511 /* 0x1.0e9c7c55184f5000e */,
1.058507322794714378170 /* 0x1.0efa55fdfad51000a */,
1.059941303721639416236 /* 0x1.0f58503329fed0003 */,
1.061377227289284297385 /* 0x1.0fb66affed37f0000 */,
1.062815096132297298980 /* 0x1.1014a66f95540000c */,
1.064254912884593951029 /* 0x1.1073028d725850007 */,
1.065696680185205469411 /* 0x1.10d17f64d9ea2000b */,
1.067140400676658718053 /* 0x1.11301d012586a0007 */,
1.068586077004890055886 /* 0x1.118edb6db26ab0003 */,
1.070033711820396415998 /* 0x1.11edbab5e2d6e000b */,
1.071483307775789262099 /* 0x1.124cbae51b5ef0001 */,
1.072934867526001312439 /* 0x1.12abdc06c3240000c */,
1.074388393734249103080 /* 0x1.130b1e264a62e0005 */,
1.075843889063253344684 /* 0x1.136a814f20ccd0003 */,
1.077301356179926061823 /* 0x1.13ca058cbaaed000b */,
1.078760797756675327056 /* 0x1.1429aaea9260e000e */,
1.080222216468626150775 /* 0x1.148971742537c0009 */,
1.081685614993597610617 /* 0x1.14e95934f37e8000b */,
1.083150996013011013776 /* 0x1.1549623881762000d */,
1.084618362213087383633 /* 0x1.15a98c8a58a6a000b */,
1.086087716284427351384 /* 0x1.1609d8360768c0008 */,
1.087559060917626885283 /* 0x1.166a45471c13f0008 */,
1.089032398810997337465 /* 0x1.16cad3c92d7b50009 */,
1.090507732647478578212 /* 0x1.172b83c7c18b5000f */,
1.091985065182095926460 /* 0x1.178c554ead72a000c */,
1.093464399073070136880 /* 0x1.17ed48695befe000c */,
1.094945737045367906172 /* 0x1.184e5d23812500007 */,
1.096429081816546080591 /* 0x1.18af9388c90e40005 */,
1.097914436104650892651 /* 0x1.1910eba4e031a0001 */,
1.099401802629782043408 /* 0x1.19726583755720003 */,
1.100891184121537858001 /* 0x1.19d4013041b860007 */,
1.102382583308144647940 /* 0x1.1a35beb6fd0cd0007 */,
1.103876002922312915544 /* 0x1.1a979e2363fa10000 */,
1.105371445702084232160 /* 0x1.1af99f8139025000e */,
1.106868914387219016199 /* 0x1.1b5bc2dc408b9000e */,
1.108368411723785085252 /* 0x1.1bbe084045eb30002 */,
1.109869940458469095340 /* 0x1.1c206fb91524c000e */,
1.111373503344554869449 /* 0x1.1c82f952817cc0001 */,
1.112879103137133007859 /* 0x1.1ce5a51860344000f */,
1.114386742595953938610 /* 0x1.1d4873168babf000e */,
1.115896424484008608911 /* 0x1.1dab6358e1d4a000f */,
1.117408151567338414664 /* 0x1.1e0e75eb43f9c000c */,
1.118921926613465345265 /* 0x1.1e71aad995078000f */,
1.120437752409564780022 /* 0x1.1ed5022fcd8600003 */,
1.121955631720569668277 /* 0x1.1f387bf9cd88b0000 */,
1.123475567332998359439 /* 0x1.1f9c18438cdec000a */,
1.124997562033035469759 /* 0x1.1fffd71902f970002 */,
1.126521618608448571713 /* 0x1.2063b88629079000e */,
1.128047739853580200284 /* 0x1.20c7bc96ff72a0002 */,
1.129575928566289189112 /* 0x1.212be3578a81e0006 */,
1.131106187546149888259 /* 0x1.21902cd3d05f70007 */,
1.132638519598779369743 /* 0x1.21f49917ddda5000c */,
1.134172927531616359481 /* 0x1.2259282fc1c24000e */,
1.135709414157753949251 /* 0x1.22bdda27911e90007 */,
1.137247982292643566662 /* 0x1.2322af0b638e60007 */,
1.138788634756517259562 /* 0x1.2387a6e755f270000 */,
1.140331374372893558110 /* 0x1.23ecc1c788c890006 */,
1.141876203969685699176 /* 0x1.2451ffb821639000c */,
1.143423126377846266197 /* 0x1.24b760c5486dc0009 */,
1.144972144431494420774 /* 0x1.251ce4fb2a0cc0005 */,
1.146523260971646252006 /* 0x1.25828c65f9fb8000d */,
1.148076478839068270690 /* 0x1.25e85711ebaeb0000 */,
1.149631800883562204903 /* 0x1.264e450b3c8a30008 */,
1.151189229953253789786 /* 0x1.26b4565e281a20003 */,
1.152748768902654319399 /* 0x1.271a8b16f0f000002 */,
1.154310420590433317050 /* 0x1.2780e341de2fc0001 */,
1.155874187878668246681 /* 0x1.27e75eeb3abc90007 */,
1.157440073633736243899 /* 0x1.284dfe1f5633e000a */,
1.159008080725518974322 /* 0x1.28b4c0ea840d90001 */,
1.160578212048386514965 /* 0x1.291ba75932ae60000 */,
1.162150470417516290340 /* 0x1.2982b177796850008 */,
1.163724858777502646494 /* 0x1.29e9df51fdd900001 */,
1.165301379991388053320 /* 0x1.2a5130f50bf34000e */,
1.166880036952526289469 /* 0x1.2ab8a66d10fdc0008 */,
1.168460832550151540268 /* 0x1.2b203fc675b7a000a */,
1.170043769683112966389 /* 0x1.2b87fd0dad7260008 */,
1.171628851252754177681 /* 0x1.2befde4f2e3da000d */,
1.173216080163546060084 /* 0x1.2c57e397719940002 */,
1.174805459325657830448 /* 0x1.2cc00cf2f7491000c */,
1.176396991650083379037 /* 0x1.2d285a6e3ff90000b */,
1.177990680055698513602 /* 0x1.2d90cc15d4ff90005 */,
1.179586527463262646306 /* 0x1.2df961f641c57000c */,
1.181184536796979545103 /* 0x1.2e621c1c157cd000d */,
1.182784710984701836994 /* 0x1.2ecafa93e35af0004 */,
1.184387052960675701386 /* 0x1.2f33fd6a459cb0000 */,
1.185991565661414393112 /* 0x1.2f9d24abd8fd1000e */,
1.187598252026902612178 /* 0x1.300670653e083000a */,
1.189207115003001469262 /* 0x1.306fe0a31bc040008 */,
1.190818157535919796833 /* 0x1.30d9757219895000e */,
1.192431382587621380206 /* 0x1.31432edef01a1000f */,
1.194046793097208292195 /* 0x1.31ad0cf63f0630008 */,
1.195664392040319823392 /* 0x1.32170fc4ce0db000c */,
1.197284182375793593084 /* 0x1.32813757527750005 */,
1.198906167074650808198 /* 0x1.32eb83ba8eef3000f */,
1.200530349107333139048 /* 0x1.3355f4fb457e5000d */,
1.202156731453099647353 /* 0x1.33c08b2641df9000c */,
1.203785317090505513368 /* 0x1.342b46484f07b0005 */,
1.205416109005122526928 /* 0x1.3496266e3fa270005 */,
1.207049110184904572310 /* 0x1.35012ba4e8fa10000 */,
1.208684323627194912036 /* 0x1.356c55f92aabb0004 */,
1.210321752322854882437 /* 0x1.35d7a577dd33f0004 */,
1.211961399276747286580 /* 0x1.36431a2de8748000d */,
1.213603267492579629347 /* 0x1.36aeb4283309e000c */,
1.215247359985374142610 /* 0x1.371a7373b00160000 */,
1.216893679753690671322 /* 0x1.3786581d404e90000 */,
1.218542229828181611183 /* 0x1.37f26231e82e4000c */,
1.220193013225231215567 /* 0x1.385e91be9c2d20002 */,
1.221846032973555429280 /* 0x1.38cae6d05e66f0000 */,
1.223501292099485437962 /* 0x1.393761742e5830001 */,
1.225158793636904830441 /* 0x1.39a401b713cb3000e */,
1.226818540625497444577 /* 0x1.3a10c7a61ceae0007 */,
1.228480536107136034131 /* 0x1.3a7db34e5a4a50003 */,
1.230144783126481566885 /* 0x1.3aeac4bcdf8d60001 */,
1.231811284734168454619 /* 0x1.3b57fbfec6e950008 */,
1.233480043984379381835 /* 0x1.3bc559212e7a2000f */,
1.235151063936380300149 /* 0x1.3c32dc3139f2a0004 */,
1.236824347652524913647 /* 0x1.3ca0853c106ac000e */,
1.238499898199571624970 /* 0x1.3d0e544eddd240003 */,
1.240177718649636107175 /* 0x1.3d7c4976d3fcd0000 */,
1.241857812073360767273 /* 0x1.3dea64c1231f70004 */,
1.243540181554270152039 /* 0x1.3e58a63b099920005 */,
1.245224830175077013244 /* 0x1.3ec70df1c4e46000e */,
1.246911761022835740725 /* 0x1.3f359bf29741c000e */,
1.248600977188942806639 /* 0x1.3fa4504ac7b800009 */,
1.250292481770148400634 /* 0x1.40132b07a330d000a */,
1.251986277866492969263 /* 0x1.40822c367a340000b */,
1.253682368581898742876 /* 0x1.40f153e4a18e0000d */,
1.255380757024939564249 /* 0x1.4160a21f73289000d */,
1.257081446308726757662 /* 0x1.41d016f44deaa000c */,
1.258784439550028944083 /* 0x1.423fb27094c090008 */,
1.260489739869405489991 /* 0x1.42af74a1aec1c0006 */,
1.262197350394008266193 /* 0x1.431f5d950a453000c */,
1.263907274252603851764 /* 0x1.438f6d58176860004 */,
1.265619514578811388761 /* 0x1.43ffa3f84b9eb000d */,
1.267334074511444086425 /* 0x1.44700183221180008 */,
1.269050957191869555296 /* 0x1.44e0860618b930006 */,
1.270770165768063009230 /* 0x1.4551318eb4d20000e */,
1.272491703389059036805 /* 0x1.45c2042a7cc26000b */,
1.274215573211836316547 /* 0x1.4632fde6ffacd000d */,
1.275941778396075143580 /* 0x1.46a41ed1cfac40001 */,
1.277670322103555911043 /* 0x1.471566f8812ac0000 */,
1.279401207505722393185 /* 0x1.4786d668b33260005 */,
1.281134437771823675369 /* 0x1.47f86d3002637000a */,
1.282870016078732078362 /* 0x1.486a2b5c13c00000e */,
1.284607945607987078432 /* 0x1.48dc10fa916bd0004 */,
1.286348229545787758022 /* 0x1.494e1e192aaa30007 */,
1.288090871080605159846 /* 0x1.49c052c5913df000c */,
1.289835873406902644341 /* 0x1.4a32af0d7d8090002 */,
1.291583239722392528754 /* 0x1.4aa532feab5e10002 */,
1.293332973229098792374 /* 0x1.4b17dea6db8010008 */,
1.295085077135345708087 /* 0x1.4b8ab213d57d9000d */,
1.296839554650994097442 /* 0x1.4bfdad53629e10003 */,
1.298596408992440220988 /* 0x1.4c70d0735358a000d */,
1.300355643380135983739 /* 0x1.4ce41b817c99e0001 */,
1.302117261036232376282 /* 0x1.4d578e8bb52cb0003 */,
1.303881265192249561154 /* 0x1.4dcb299fde2920008 */,
1.305647659079073541490 /* 0x1.4e3eeccbd7f4c0003 */,
1.307416445934474813521 /* 0x1.4eb2d81d8a86f000b */,
1.309187629001237640529 /* 0x1.4f26eba2e35a5000e */,
1.310961211525240921493 /* 0x1.4f9b2769d35090009 */,
1.312737196755087820678 /* 0x1.500f8b804e4a30000 */,
1.314515587949291131086 /* 0x1.508417f4530d00009 */,
1.316296388365203462468 /* 0x1.50f8ccd3df1840003 */,
1.318079601265708777911 /* 0x1.516daa2cf60020002 */,
1.319865229921343141607 /* 0x1.51e2b00da3c2b0007 */,
1.321653277603506371251 /* 0x1.5257de83f5512000d */,
1.323443747588034513690 /* 0x1.52cd359dfc7d5000e */,
1.325236643161341820781 /* 0x1.5342b569d6baa000f */,
1.327031967602244177939 /* 0x1.53b85df59921b0000 */,
1.328829724206201046165 /* 0x1.542e2f4f6b17e0006 */,
1.330629916266568235675 /* 0x1.54a4298571b27000e */,
1.332432547083447937938 /* 0x1.551a4ca5d97190009 */,
1.334237619959296017340 /* 0x1.559098bed16bf0008 */,
1.336045138203900251029 /* 0x1.56070dde90c800000 */,
1.337855105129210686631 /* 0x1.567dac13510cd0009 */,
1.339667524053662184301 /* 0x1.56f4736b52e2c000c */,
1.341482398296830025383 /* 0x1.576b63f4d8333000f */,
1.343299731186792467254 /* 0x1.57e27dbe2c40e0003 */,
1.345119526053918823702 /* 0x1.5859c0d59cd37000f */,
1.346941786233264881662 /* 0x1.58d12d497cd9a0005 */,
1.348766515064854010261 /* 0x1.5948c32824b87000c */,
1.350593715891792223641 /* 0x1.59c0827ff03890007 */,
1.352423392064920459908 /* 0x1.5a386b5f43a3e0006 */,
1.354255546937278120764 /* 0x1.5ab07dd485af1000c */,
1.356090183865519494030 /* 0x1.5b28b9ee21085000f */,
1.357927306213322804534 /* 0x1.5ba11fba8816e000b */,
1.359766917346459269620 /* 0x1.5c19af482f8f2000f */,
1.361609020638567812980 /* 0x1.5c9268a594cc00004 */,
1.363453619463660171403 /* 0x1.5d0b4be135916000c */,
1.365300717204201985683 /* 0x1.5d84590998eeb0005 */,
1.367150317245710233754 /* 0x1.5dfd902d494e40001 */,
1.369002422974674892971 /* 0x1.5e76f15ad22c40008 */,
1.370857037789471544224 /* 0x1.5ef07ca0cc166000b */,
1.372714165088220639199 /* 0x1.5f6a320dcf5280006 */,
1.374573808273481745378 /* 0x1.5fe411b0790800009 */,
1.376435970755022220096 /* 0x1.605e1b976e4b1000e */,
1.378300655944092456600 /* 0x1.60d84fd155d15000e */,
1.380167867259843417228 /* 0x1.6152ae6cdf0030003 */,
1.382037608124419003675 /* 0x1.61cd3778bc879000d */,
1.383909881963391264069 /* 0x1.6247eb03a4dc40009 */,
1.385784692209972801544 /* 0x1.62c2c91c56d9b0002 */,
1.387662042298923203992 /* 0x1.633dd1d1930ec0001 */,
1.389541935670444372533 /* 0x1.63b90532200630004 */,
1.391424375772021271329 /* 0x1.6434634ccc4cc0007 */,
1.393309366052102982208 /* 0x1.64afec30677e90008 */,
1.395196909966106124701 /* 0x1.652b9febc8e0f000d */,
1.397087010973788290271 /* 0x1.65a77e8dcc7f10004 */,
1.398979672539331309267 /* 0x1.66238825534170000 */,
1.400874898129892187656 /* 0x1.669fbcc1415600008 */,
1.402772691220124823310 /* 0x1.671c1c708328e000a */,
1.404673055288671035301 /* 0x1.6798a7420988b000d */,
1.406575993818903302975 /* 0x1.68155d44ca77a000f */,
1.408481510297352468121 /* 0x1.68923e87bf70e000a */,
1.410389608216942924956 /* 0x1.690f4b19e8f74000c */,
1.412300291075172076232 /* 0x1.698c830a4c94c0008 */
};
#define S (1.0/4503599627370496.0)  /* 2^-52 */
static const float exp2_deltatable[512] = {
  IC(11527)*S,  IC(-963)*S,   IC(884)*S,  IC(-781)*S, IC(-2363)*S, IC(-3441)*S,   IC(123)*S,   IC(526)*S,
     IC(-6)*S,  IC(1254)*S, IC(-1138)*S,  IC(1519)*S,  IC(1576)*S,   IC(-65)*S,  IC(1040)*S,   IC(793)*S,
  IC(-1662)*S, IC(-5063)*S,  IC(-387)*S,   IC(968)*S,  IC(-941)*S,   IC(984)*S, IC(-2856)*S,  IC(-545)*S,
    IC(495)*S, IC(-5246)*S, IC(-2109)*S,  IC(1281)*S,  IC(2075)*S,   IC(909)*S, IC(-1642)*S,IC(-78233)*S,
 IC(-31653)*S,  IC(-265)*S,   IC(130)*S,   IC(430)*S,  IC(2482)*S,  IC(-742)*S,  IC(1616)*S, IC(-2213)*S,
   IC(-519)*S,    IC(20)*S, IC(-3134)*S,IC(-13981)*S,  IC(1343)*S, IC(-1740)*S,   IC(247)*S,  IC(1679)*S,
  IC(-1097)*S,  IC(3131)*S,   IC(871)*S, IC(-1480)*S,  IC(1936)*S, IC(-1827)*S, IC(17325)*S,   IC(528)*S,
   IC(-322)*S,  IC(1404)*S,  IC(-152)*S, IC(-1845)*S,  IC(-212)*S,  IC(2639)*S,  IC(-476)*S,  IC(2960)*S,
   IC(-962)*S, IC(-1012)*S, IC(-1231)*S,  IC(3030)*S,  IC(1659)*S,  IC(-486)*S,  IC(2154)*S,  IC(1728)*S,
  IC(-2793)*S,   IC(699)*S, IC(-1560)*S, IC(-2125)*S,  IC(2156)*S,   IC(142)*S, IC(-1888)*S,  IC(4426)*S,
 IC(-13443)*S,  IC(1970)*S,   IC(-50)*S,  IC(1771)*S,IC(-43399)*S,  IC(4979)*S, IC(-2448)*S,  IC(-370)*S,
   IC(1414)*S,  IC(1075)*S,   IC(232)*S,   IC(206)*S,   IC(873)*S,  IC(2141)*S,  IC(2970)*S,  IC(1279)*S,
  IC(-2331)*S,   IC(336)*S, IC(-2595)*S,   IC(753)*S, IC(-3384)*S,  IC(-616)*S,    IC(89)*S,  IC(-818)*S,
   IC(5755)*S,  IC(-241)*S,  IC(-528)*S,  IC(-661)*S, IC(-3777)*S,  IC(-354)*S,   IC(250)*S,  IC(3881)*S,
   IC(2632)*S, IC(-2131)*S,  IC(2565)*S,  IC(-316)*S,  IC(1746)*S, IC(-2541)*S, IC(-1324)*S,   IC(-50)*S,
   IC(2564)*S,  IC(-782)*S,  IC(1176)*S,  IC(6452)*S, IC(-1002)*S,  IC(1288)*S,   IC(336)*S,  IC(-185)*S,
   IC(3063)*S,  IC(3784)*S,  IC(2169)*S,   IC(686)*S,   IC(328)*S,  IC(-400)*S,   IC(312)*S, IC(-4517)*S,
  IC(-1457)*S,  IC(1046)*S, IC(-1530)*S,  IC(-685)*S,  IC(1328)*S,IC(-49815)*S,  IC(-895)*S,  IC(1063)*S,
  IC(-2091)*S,  IC(-672)*S, IC(-1710)*S,  IC(-665)*S,  IC(1545)*S,  IC(1819)*S,IC(-45265)*S,  IC(3548)*S,
   IC(-554)*S,  IC(-568)*S,  IC(4752)*S, IC(-1907)*S,IC(-13738)*S,   IC(675)*S,  IC(9611)*S, IC(-1115)*S,
   IC(-815)*S,   IC(408)*S, IC(-1281)*S,  IC(-937)*S,IC(-16376)*S, IC(-4772)*S, IC(-1440)*S,   IC(992)*S,
    IC(788)*S, IC(10364)*S, IC(-1602)*S,  IC(-661)*S, IC(-1783)*S,  IC(-265)*S,   IC(-20)*S, IC(-3781)*S,
   IC(-861)*S,  IC(-345)*S,  IC(-994)*S,  IC(1364)*S, IC(-5339)*S,  IC(1620)*S,  IC(9390)*S, IC(-1066)*S,
   IC(-305)*S,  IC(-170)*S,   IC(175)*S,  IC(2461)*S,  IC(-490)*S,  IC(-769)*S, IC(-1450)*S,  IC(3315)*S,
   IC(2418)*S,   IC(-45)*S,  IC(-852)*S, IC(-1295)*S,  IC(-488)*S,   IC(-96)*S,  IC(1142)*S, IC(-2639)*S,
   IC(7905)*S, IC(-9306)*S, IC(-3859)*S,   IC(760)*S,  IC(1057)*S, IC(-1570)*S,  IC(3977)*S,   IC(209)*S,
   IC(-514)*S,  IC(7151)*S,  IC(1646)*S,   IC(627)*S,   IC(599)*S,  IC(-774)*S, IC(-1468)*S,   IC(633)*S,
   IC(-473)*S,   IC(851)*S,  IC(2406)*S,   IC(143)*S,    IC(74)*S,  IC(4260)*S,  IC(1177)*S,  IC(-913)*S,
   IC(2670)*S, IC(-3298)*S, IC(-1662)*S,  IC(-120)*S, IC(-3264)*S, IC(-2148)*S,   IC(410)*S,  IC(2078)*S,
  IC(-2098)*S,  IC(-926)*S,  IC(3580)*S, IC(-1289)*S,  IC(2450)*S, IC(-1158)*S,   IC(907)*S,  IC(-590)*S,
    IC(986)*S,  IC(1801)*S,  IC(1145)*S, IC(-1677)*S,  IC(3455)*S,   IC(956)*S,   IC(710)*S,   IC(144)*S,
    IC(153)*S,  IC(-255)*S, IC(-1898)*S, IC(28102)*S,  IC(2748)*S,  IC(1194)*S, IC(-3009)*S,  IC(7076)*S,
      IC(0)*S, IC(-2720)*S,   IC(711)*S,  IC(1225)*S, IC(-3034)*S,  IC(-473)*S,   IC(378)*S, IC(-1046)*S,
    IC(962)*S, IC(-2006)*S,  IC(4647)*S,  IC(3206)*S,  IC(1769)*S, IC(-2665)*S,  IC(1254)*S,  IC(2025)*S,
  IC(-2430)*S,  IC(6193)*S,  IC(1224)*S,  IC(-856)*S, IC(-1592)*S,  IC(-325)*S, IC(-1521)*S,  IC(1827)*S,
   IC(-264)*S,  IC(2403)*S, IC(-1065)*S,   IC(967)*S,  IC(-681)*S, IC(-2106)*S,  IC(-474)*S,  IC(1333)*S,
   IC(-893)*S,  IC(2296)*S,   IC(592)*S, IC(-1220)*S,  IC(-326)*S,   IC(990)*S,   IC(139)*S,   IC(206)*S,
   IC(-779)*S, IC(-1683)*S,  IC(1238)*S,  IC(6098)*S,   IC(136)*S,  IC(1197)*S,   IC(790)*S,  IC(-107)*S,
  IC(-1004)*S, IC(-2449)*S,   IC(939)*S,  IC(5568)*S,   IC(156)*S,  IC(1812)*S,  IC(2792)*S, IC(-1094)*S,
  IC(-2677)*S,  IC(-251)*S,  IC(2297)*S,   IC(943)*S, IC(-1329)*S,  IC(2883)*S,  IC(-853)*S, IC(-2626)*S,
 IC(-105929)*S, IC(-6552)*S,  IC(1095)*S, IC(-1508)*S,  IC(1003)*S,  IC(5039)*S, IC(-2600)*S,  IC(-749)*S,
   IC(1790)*S,   IC(890)*S,  IC(2016)*S, IC(-1073)*S,   IC(624)*S, IC(-2084)*S, IC(-1536)*S, IC(-1330)*S,
    IC(358)*S,  IC(2444)*S,  IC(-179)*S,IC(-25759)*S,  IC(-243)*S,  IC(-552)*S,  IC(-124)*S,  IC(3766)*S,
   IC(1192)*S, IC(-1614)*S,     IC(6)*S, IC(-1227)*S,   IC(345)*S,  IC(-981)*S,  IC(-295)*S, IC(-1006)*S,
   IC(-995)*S, IC(-1195)*S,   IC(706)*S,  IC(2512)*S, IC(-1758)*S,  IC(-734)*S, IC(-6286)*S,  IC(-922)*S,
   IC(1530)*S,  IC(1542)*S,  IC(1223)*S,    IC(61)*S,   IC(-83)*S,   IC(522)*S,IC(116937)*S,  IC(-914)*S,
   IC(-418)*S, IC(-7339)*S,   IC(249)*S,  IC(-520)*S,  IC(-762)*S,   IC(426)*S,  IC(-505)*S,  IC(2664)*S,
  IC(-1093)*S, IC(-1035)*S,  IC(2130)*S,  IC(4878)*S,  IC(1982)*S,  IC(1551)*S,  IC(2304)*S,   IC(193)*S,
   IC(1532)*S, IC(-7268)*S, IC(24357)*S,   IC(531)*S,  IC(2676)*S, IC(-1170)*S,  IC(1465)*S, IC(-1917)*S,
   IC(2143)*S,  IC(1466)*S,    IC(-7)*S, IC(-7300)*S,  IC(3297)*S, IC(-1197)*S,  IC(-289)*S, IC(-1548)*S,
  IC(26226)*S,  IC(4401)*S,  IC(4123)*S, IC(-1588)*S,  IC(4243)*S,  IC(4069)*S, IC(-1276)*S, IC(-2010)*S,
   IC(1407)*S,  IC(1478)*S,   IC(488)*S, IC(-2366)*S, IC(-2909)*S, IC(-2534)*S, IC(-1285)*S,  IC(7095)*S,
   IC(-645)*S, IC(-2089)*S,  IC(-944)*S,   IC(-40)*S, IC(-1363)*S,  IC(-833)*S,   IC(917)*S,  IC(1609)*S,
   IC(1286)*S,  IC(1677)*S,  IC(1613)*S, IC(-2295)*S, IC(-1248)*S,    IC(40)*S,    IC(26)*S,  IC(2038)*S,
    IC(698)*S,  IC(2675)*S, IC(-1755)*S, IC(-3522)*S, IC(-1614)*S, IC(-6111)*S,   IC(270)*S,  IC(1822)*S,
   IC(-234)*S, IC(-2844)*S, IC(-1201)*S,  IC(-830)*S,  IC(1193)*S,  IC(2354)*S,    IC(47)*S,  IC(1522)*S,
    IC(-78)*S,  IC(-640)*S,  IC(2425)*S, IC(-1596)*S,  IC(1563)*S,  IC(1169)*S, IC(-1006)*S,   IC(-83)*S,
   IC(2362)*S, IC(-3521)*S,  IC(-314)*S,  IC(1814)*S, IC(-1751)*S,   IC(305)*S,  IC(1715)*S, IC(-3741)*S,
   IC(7847)*S,  IC(1291)*S,  IC(1206)*S,    IC(36)*S,  IC(1397)*S, IC(-1419)*S, IC(-1194)*S, IC(-2014)*S,
   IC(1742)*S,  IC(-578)*S,  IC(-207)*S,   IC(875)*S,  IC(1539)*S,  IC(2826)*S, IC(-1165)*S,  IC(-909)*S,
   IC(1849)*S,   IC(927)*S,  IC(2018)*S,  IC(-981)*S,  IC(1637)*S,  IC(-463)*S,   IC(905)*S,  IC(6618)*S,
    IC(400)*S,   IC(630)*S,  IC(2614)*S,   IC(900)*S,  IC(2323)*S, IC(-1094)*S, IC(-1858)*S,  IC(-212)*S,
  IC(-2069)*S,   IC(747)*S,  IC(1845)*S, IC(-1450)*S,   IC(444)*S,  IC(-213)*S,  IC(-438)*S,  IC(1158)*S,
   IC(4738)*S,  IC(2497)*S,  IC(-370)*S, IC(-2016)*S,  IC(-518)*S, IC(-1160)*S, IC(-1510)*S,   IC(123)*S
};
/* Maximum magnitude in above table: 116937 */
#undef S

```

`t_exp2f.h`:

```h
/* Accurate tables for exp2f().
   Copyright (C) 1998-2015 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Geoffrey Keating <geoffk@ozemail.com.au>

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/* This table has the property that, for all integers -128 <= i <= 127,
   exp(i/256.0 + __exp2f_deltatable[i-128]) == __exp2f_atable[i+128] + r
   for some -2^-35 < r < 2^-35 (abs(r) < 2^-36 if i <= 0); and that
   __exp2f_deltatable[i+128] == t * 2^-30
   for integer t so that abs(t) <= 43447 * 2^0.  */

#define W30 (9.31322575e-10)
static const float __exp2f_deltatable[256] = {
      IC(-810)*W30,       IC(283)*W30,     IC(-1514)*W30,      IC(1304)*W30,
     IC(-1148)*W30,       IC(-98)*W30,      IC(-744)*W30,      IC(-156)*W30,
      IC(-419)*W30,      IC(-155)*W30,       IC(474)*W30,       IC(167)*W30,
     IC(-1984)*W30,      IC(-826)*W30,       IC(692)*W30,       IC(781)*W30,
      IC(-578)*W30,      IC(-411)*W30,      IC(-129)*W30,     IC(-1500)*W30,
       IC(654)*W30,      IC(-141)*W30,      IC(-816)*W30,       IC(-53)*W30,
       IC(148)*W30,       IC(493)*W30,     IC(-2214)*W30,       IC(760)*W30,
       IC(260)*W30,       IC(750)*W30,     IC(-1300)*W30,      IC(1424)*W30,
     IC(-1445)*W30,      IC(-339)*W30,      IC(-680)*W30,      IC(-349)*W30,
      IC(-922)*W30,       IC(531)*W30,       IC(193)*W30,     IC(-2892)*W30,
       IC(290)*W30,     IC(-2145)*W30,      IC(-276)*W30,       IC(485)*W30,
      IC(-695)*W30,       IC(215)*W30,     IC(-7093)*W30,       IC(412)*W30,
     IC(-4596)*W30,       IC(367)*W30,       IC(592)*W30,      IC(-615)*W30,
       IC(-97)*W30,     IC(-1066)*W30,       IC(972)*W30,      IC(-226)*W30,
      IC(-625)*W30,      IC(-374)*W30,     IC(-5647)*W30,      IC(-180)*W30,
     IC(20349)*W30,      IC(-447)*W30,       IC(111)*W30,     IC(-4164)*W30,
       IC(-87)*W30,       IC(-21)*W30,      IC(-251)*W30,        IC(66)*W30,
      IC(-517)*W30,      IC(2093)*W30,      IC(-263)*W30,       IC(182)*W30,
      IC(-601)*W30,       IC(475)*W30,      IC(-483)*W30,     IC(-1251)*W30,
      IC(-373)*W30,      IC(1471)*W30,       IC(-92)*W30,      IC(-215)*W30,
       IC(-97)*W30,      IC(-190)*W30,         IC(0)*W30,      IC(-290)*W30,
     IC(-2647)*W30,      IC(1940)*W30,      IC(-582)*W30,        IC(28)*W30,
       IC(833)*W30,      IC(1493)*W30,        IC(34)*W30,       IC(321)*W30,
      IC(3327)*W30,       IC(-35)*W30,       IC(177)*W30,      IC(-135)*W30,
      IC(-796)*W30,      IC(-428)*W30,       IC(129)*W30,      IC(9332)*W30,
       IC(-12)*W30,       IC(-69)*W30,     IC(-1743)*W30,      IC(6508)*W30,
       IC(-60)*W30,       IC(359)*W30,     IC(43447)*W30,        IC(15)*W30,
       IC(-23)*W30,      IC(-305)*W30,      IC(-375)*W30,      IC(-652)*W30,
       IC(667)*W30,       IC(269)*W30,     IC(-1575)*W30,       IC(185)*W30,
      IC(-329)*W30,       IC(200)*W30,      IC(6002)*W30,       IC(163)*W30,
      IC(-647)*W30,        IC(19)*W30,      IC(-603)*W30,      IC(-755)*W30,
       IC(742)*W30,      IC(-438)*W30,      IC(3587)*W30,      IC(2560)*W30,
         IC(0)*W30,      IC(-520)*W30,      IC(-241)*W30,      IC(-299)*W30,
     IC(-1270)*W30,      IC(-991)*W30,     IC(-1138)*W30,       IC(255)*W30,
     IC(-1192)*W30,      IC(1722)*W30,      IC(1023)*W30,      IC(3700)*W30,
     IC(-1388)*W30,     IC(-1551)*W30,     IC(-2549)*W30,        IC(27)*W30,
       IC(282)*W30,       IC(673)*W30,       IC(113)*W30,      IC(1561)*W30,
        IC(72)*W30,       IC(873)*W30,        IC(87)*W30,      IC(-395)*W30,
      IC(-433)*W30,       IC(629)*W30,      IC(3440)*W30,      IC(-284)*W30,
      IC(-592)*W30,      IC(-103)*W30,       IC(-46)*W30,     IC(-3844)*W30,
      IC(1712)*W30,       IC(303)*W30,      IC(1555)*W30,      IC(-631)*W30,
     IC(-1400)*W30,      IC(-961)*W30,      IC(-854)*W30,      IC(-276)*W30,
       IC(407)*W30,       IC(833)*W30,      IC(-345)*W30,     IC(-1501)*W30,
       IC(121)*W30,     IC(-1581)*W30,       IC(400)*W30,       IC(150)*W30,
      IC(1224)*W30,      IC(-139)*W30,      IC(-563)*W30,       IC(879)*W30,
       IC(933)*W30,      IC(2939)*W30,       IC(788)*W30,       IC(211)*W30,
       IC(530)*W30,      IC(-192)*W30,       IC(706)*W30,    IC(-13347)*W30,
      IC(1065)*W30,         IC(3)*W30,       IC(111)*W30,      IC(-208)*W30,
      IC(-360)*W30,      IC(-532)*W30,      IC(-291)*W30,       IC(483)*W30,
       IC(987)*W30,       IC(-33)*W30,     IC(-1373)*W30,      IC(-166)*W30,
     IC(-1174)*W30,     IC(-3955)*W30,      IC(1601)*W30,      IC(-280)*W30,
      IC(1405)*W30,       IC(600)*W30,     IC(-1659)*W30,       IC(-23)*W30,
       IC(390)*W30,       IC(449)*W30,       IC(570)*W30,    IC(-13143)*W30,
        IC(-9)*W30,     IC(-1646)*W30,      IC(1201)*W30,       IC(294)*W30,
      IC(2181)*W30,     IC(-1173)*W30,      IC(1388)*W30,     IC(-4504)*W30,
       IC(190)*W30,     IC(-2304)*W30,       IC(211)*W30,       IC(239)*W30,
        IC(48)*W30,      IC(-817)*W30,      IC(1018)*W30,      IC(1828)*W30,
      IC(-663)*W30,      IC(1408)*W30,       IC(408)*W30,       IC(-36)*W30,
      IC(1295)*W30,      IC(-230)*W30,      IC(1341)*W30,         IC(9)*W30,
        IC(40)*W30,       IC(705)*W30,       IC(186)*W30,       IC(376)*W30,
       IC(557)*W30,      IC(5866)*W30,       IC(363)*W30,     IC(-1558)*W30,
       IC(718)*W30,       IC(669)*W30,      IC(1369)*W30,     IC(-2972)*W30,
      IC(-468)*W30,      IC(-121)*W30,      IC(-219)*W30,       IC(667)*W30,
     IC(29954)*W30,       IC(366)*W30,        IC(48)*W30,      IC(-203)*W30
};

static const float __exp2f_atable[256] /* __attribute__((mode(SF))) */ = {
 0.707106411447, /* 0x0.b504ecfff */
 0.709024071690, /* 0x0.b58299fff */
 0.710945606239, /* 0x0.b60088000 */
 0.712874472142, /* 0x0.b67ef1000 */
 0.714806139464, /* 0x0.b6fd88fff */
 0.716744661340, /* 0x0.b77c94000 */
 0.718687653549, /* 0x0.b7fbea000 */
 0.720636486992, /* 0x0.b87ba1fff */
 0.722590208040, /* 0x0.b8fbabfff */
 0.724549472323, /* 0x0.b97c12fff */
 0.726514220228, /* 0x0.b9fcd5fff */
 0.728483855735, /* 0x0.ba7deb000 */
 0.730457961549, /* 0x0.baff4afff */
 0.732438981522, /* 0x0.bb811efff */
 0.734425544748, /* 0x0.bc0350000 */
 0.736416816713, /* 0x0.bc85d0000 */
 0.738412797450, /* 0x0.bd089efff */
 0.740414917465, /* 0x0.bd8bd4fff */
 0.742422521111, /* 0x0.be0f66fff */
 0.744434773914, /* 0x0.be9346fff */
 0.746454179287, /* 0x0.bf179f000 */
 0.748477637755, /* 0x0.bf9c3afff */
 0.750506639473, /* 0x0.c02133fff */
 0.752541840064, /* 0x0.c0a694fff */
 0.754582285889, /* 0x0.c12c4e000 */
 0.756628334525, /* 0x0.c1b265000 */
 0.758678436269, /* 0x0.c238bffff */
 0.760736882681, /* 0x0.c2bfa6fff */
 0.762799203401, /* 0x0.c346cf000 */
 0.764867603790, /* 0x0.c3ce5d000 */
 0.766940355298, /* 0x0.c45633fff */
 0.769021093841, /* 0x0.c4de90fff */
 0.771104693409, /* 0x0.c5671dfff */
 0.773195922364, /* 0x0.c5f02afff */
 0.775292098512, /* 0x0.c6798afff */
 0.777394294745, /* 0x0.c70350000 */
 0.779501736166, /* 0x0.c78d6d000 */
 0.781615912910, /* 0x0.c817fafff */
 0.783734917628, /* 0x0.c8a2d9fff */
 0.785858273516, /* 0x0.c92e02000 */
 0.787990570071, /* 0x0.c9b9c0000 */
 0.790125787245, /* 0x0.ca45aefff */
 0.792268991467, /* 0x0.cad223fff */
 0.794417440881, /* 0x0.cb5ef0fff */
 0.796570718287, /* 0x0.cbec0efff */
 0.798730909811, /* 0x0.cc79a0fff */
 0.800892710672, /* 0x0.cd074dfff */
 0.803068041795, /* 0x0.cd95ddfff */
 0.805242776881, /* 0x0.ce2464000 */
 0.807428598393, /* 0x0.ceb3a3fff */
 0.809617877002, /* 0x0.cf431dfff */
 0.811812341211, /* 0x0.cfd2eefff */
 0.814013659956, /* 0x0.d06333000 */
 0.816220164311, /* 0x0.d0f3ce000 */
 0.818434238424, /* 0x0.d184e7fff */
 0.820652604094, /* 0x0.d21649fff */
 0.822877407074, /* 0x0.d2a818000 */
 0.825108587751, /* 0x0.d33a51000 */
 0.827342867839, /* 0x0.d3ccbdfff */
 0.829588949684, /* 0x0.d45ff1000 */
 0.831849217401, /* 0x0.d4f411fff */
 0.834093391880, /* 0x0.d58724fff */
 0.836355149750, /* 0x0.d61b5f000 */
 0.838620424257, /* 0x0.d6afd3fff */
 0.840896368027, /* 0x0.d744fc000 */
 0.843176305293, /* 0x0.d7da66fff */
 0.845462262643, /* 0x0.d87037000 */
 0.847754716864, /* 0x0.d90673fff */
 0.850052893157, /* 0x0.d99d10fff */
 0.852359056469, /* 0x0.da3433fff */
 0.854668736446, /* 0x0.dacb91fff */
 0.856986224651, /* 0x0.db6373000 */
 0.859309315673, /* 0x0.dbfbb1fff */
 0.861639738080, /* 0x0.dc946bfff */
 0.863975346095, /* 0x0.dd2d7d000 */
 0.866317391394, /* 0x0.ddc6f9fff */
 0.868666708472, /* 0x0.de60f1000 */
 0.871022939695, /* 0x0.defb5c000 */
 0.873383641229, /* 0x0.df9611fff */
 0.875751554968, /* 0x0.e03141000 */
 0.878126025200, /* 0x0.e0ccde000 */
 0.880506813521, /* 0x0.e168e4fff */
 0.882894217966, /* 0x0.e2055afff */
 0.885287821299, /* 0x0.e2a239000 */
 0.887686729423, /* 0x0.e33f6ffff */
 0.890096127973, /* 0x0.e3dd56fff */
 0.892507970338, /* 0x0.e47b67000 */
 0.894928157336, /* 0x0.e51a03000 */
 0.897355020043, /* 0x0.e5b90efff */
 0.899788379682, /* 0x0.e65888000 */
 0.902227103705, /* 0x0.e6f85afff */
 0.904673457151, /* 0x0.e798ae000 */
 0.907128036008, /* 0x0.e8398afff */
 0.909585535528, /* 0x0.e8da99000 */
 0.912051796915, /* 0x0.e97c3a000 */
 0.914524436003, /* 0x0.ea1e46000 */
 0.917003571999, /* 0x0.eac0bf000 */
 0.919490039339, /* 0x0.eb63b2fff */
 0.921983361257, /* 0x0.ec071a000 */
 0.924488604054, /* 0x0.ecab48fff */
 0.926989555360, /* 0x0.ed4f30000 */
 0.929502844812, /* 0x0.edf3e6000 */
 0.932021975503, /* 0x0.ee98fdfff */
 0.934553921208, /* 0x0.ef3eecfff */
 0.937083780759, /* 0x0.efe4b8fff */
 0.939624726786, /* 0x0.f08b3f000 */
 0.942198514924, /* 0x0.f133ebfff */
 0.944726586343, /* 0x0.f1d99a000 */
 0.947287976728, /* 0x0.f28176fff */
 0.949856162070, /* 0x0.f329c5fff */
 0.952431440345, /* 0x0.f3d28bfff */
 0.955013573175, /* 0x0.f47bc5000 */
 0.957603693021, /* 0x0.f52584000 */
 0.960199773321, /* 0x0.f5cfa7000 */
 0.962801992906, /* 0x0.f67a31000 */
 0.965413510788, /* 0x0.f72556fff */
 0.968030691152, /* 0x0.f7d0dc000 */
 0.970655620084, /* 0x0.f87ce2fff */
 0.973290979849, /* 0x0.f92998fff */
 0.975926160805, /* 0x0.f9d64bfff */
 0.978571653370, /* 0x0.fa83ac000 */
 0.981225252139, /* 0x0.fb3193fff */
 0.983885228626, /* 0x0.fbdfe6fff */
 0.986552715296, /* 0x0.fc8eb7fff */
 0.989228487027, /* 0x0.fd3e14000 */
 0.991909801964, /* 0x0.fdedcd000 */
 0.994601726545, /* 0x0.fe9e38000 */
 0.997297704209, /* 0x0.ff4ee6fff */
 1.000000000000, /* 0x1.000000000 */
 1.002710938457, /* 0x1.00b1aa000 */
 1.005429744692, /* 0x1.0163d7ffe */
 1.008155703526, /* 0x1.02167dffe */
 1.010888457284, /* 0x1.02c995fff */
 1.013629436498, /* 0x1.037d38000 */
 1.016377568250, /* 0x1.043152000 */
 1.019134163841, /* 0x1.04e5f9ffe */
 1.021896362316, /* 0x1.059b00000 */
 1.024668931945, /* 0x1.0650b3ffe */
 1.027446627635, /* 0x1.0706be001 */
 1.030234098408, /* 0x1.07bd6bffe */
 1.033023953416, /* 0x1.087441ffe */
 1.035824656494, /* 0x1.092bce000 */
 1.038632392900, /* 0x1.09e3d0001 */
 1.041450142840, /* 0x1.0a9c79ffe */
 1.044273972530, /* 0x1.0b558a001 */
 1.047105550795, /* 0x1.0c0f1c001 */
 1.049944162390, /* 0x1.0cc924001 */
 1.052791833895, /* 0x1.0d83c4001 */
 1.055645227426, /* 0x1.0e3ec3fff */
 1.058507919326, /* 0x1.0efa60001 */
 1.061377286898, /* 0x1.0fb66bfff */
 1.064254641510, /* 0x1.1072fdffe */
 1.067140102389, /* 0x1.113018000 */
 1.070034146304, /* 0x1.11edc1fff */
 1.072937250162, /* 0x1.12ac04001 */
 1.075843691823, /* 0x1.136a7dfff */
 1.078760385496, /* 0x1.1429a3ffe */
 1.081685543070, /* 0x1.14e958000 */
 1.084618330005, /* 0x1.15a98c000 */
 1.087556362176, /* 0x1.166a18001 */
 1.090508937863, /* 0x1.172b98001 */
 1.093464612954, /* 0x1.17ed4bfff */
 1.096430182434, /* 0x1.18afa5ffe */
 1.099401354802, /* 0x1.19725e000 */
 1.102381587017, /* 0x1.1a35adfff */
 1.105370759965, /* 0x1.1af994000 */
 1.108367800686, /* 0x1.1bbdfdffe */
 1.111373305331, /* 0x1.1c82f6000 */
 1.114387035385, /* 0x1.1d4878001 */
 1.117408752440, /* 0x1.1e0e7ffff */
 1.120437502874, /* 0x1.1ed4fe000 */
 1.123474478729, /* 0x1.1f9c06000 */
 1.126521706601, /* 0x1.2063ba001 */
 1.129574775716, /* 0x1.212bd0001 */
 1.132638812065, /* 0x1.21f49e000 */
 1.135709524130, /* 0x1.22bddbffe */
 1.138789534565, /* 0x1.2387b5fff */
 1.141876101508, /* 0x1.2451fe000 */
 1.144971728301, /* 0x1.251cddffe */
 1.148077130296, /* 0x1.25e861ffe */
 1.151189923305, /* 0x1.26b462001 */
 1.154312610610, /* 0x1.278107ffe */
 1.157440662410, /* 0x1.284e08001 */
 1.160578370109, /* 0x1.291baa001 */
 1.163725256932, /* 0x1.29e9e6000 */
 1.166879892324, /* 0x1.2ab8a3ffe */
 1.170044302935, /* 0x1.2b8805fff */
 1.173205971694, /* 0x1.2c5739ffe */
 1.176397800428, /* 0x1.2d2867ffe */
 1.179586529747, /* 0x1.2df962001 */
 1.182784795737, /* 0x1.2ecafbffe */
 1.185991406414, /* 0x1.2f9d21ffe */
 1.189206838636, /* 0x1.306fdc001 */
 1.192430973067, /* 0x1.314328000 */
 1.195664167430, /* 0x1.32170c001 */
 1.198906540890, /* 0x1.32eb8a001 */
 1.202157497408, /* 0x1.33c098000 */
 1.205416083326, /* 0x1.349625fff */
 1.208683252332, /* 0x1.356c43fff */
 1.211961269402, /* 0x1.364318001 */
 1.215246438983, /* 0x1.371a64000 */
 1.218539118740, /* 0x1.37f22dffe */
 1.221847295770, /* 0x1.38cafc000 */
 1.225158572187, /* 0x1.39a3fdfff */
 1.228481650325, /* 0x1.3a7dc5ffe */
 1.231811761846, /* 0x1.3b5803fff */
 1.235149741144, /* 0x1.3c32c5ffe */
 1.238499879811, /* 0x1.3d0e53ffe */
 1.241858124726, /* 0x1.3dea69fff */
 1.245225191102, /* 0x1.3ec713fff */
 1.248601436624, /* 0x1.3fa458000 */
 1.251975655584, /* 0x1.40817a001 */
 1.255380749731, /* 0x1.4160a2001 */
 1.258783102010, /* 0x1.423f9bffe */
 1.262198328973, /* 0x1.431f6e000 */
 1.265619754780, /* 0x1.43ffa7fff */
 1.269052743928, /* 0x1.44e0a4001 */
 1.272490739830, /* 0x1.45c1f4000 */
 1.275942921659, /* 0x1.46a432001 */
 1.279397487615, /* 0x1.478697ffe */
 1.282870173427, /* 0x1.486a2dffe */
 1.286346316319, /* 0x1.494dfdffe */
 1.289836049094, /* 0x1.4a32b2001 */
 1.293333172770, /* 0x1.4b17e1ffe */
 1.296839594835, /* 0x1.4bfdadfff */
 1.300354957560, /* 0x1.4ce40fffe */
 1.303882122055, /* 0x1.4dcb38001 */
 1.307417988757, /* 0x1.4eb2f1ffe */
 1.310960650439, /* 0x1.4f9b1dfff */
 1.314516782746, /* 0x1.50842bfff */
 1.318079948424, /* 0x1.516daffff */
 1.321653246888, /* 0x1.5257de000 */
 1.325237751030, /* 0x1.5342c8001 */
 1.328829526907, /* 0x1.542e2c000 */
 1.332433700535, /* 0x1.551a5fffe */
 1.336045145966, /* 0x1.56070dffe */
 1.339667558645, /* 0x1.56f473ffe */
 1.343300342533, /* 0x1.57e287ffe */
 1.346941947961, /* 0x1.58d130001 */
 1.350594043714, /* 0x1.59c087ffe */
 1.354256033883, /* 0x1.5ab085fff */
 1.357932448365, /* 0x1.5ba175ffe */
 1.361609339707, /* 0x1.5c926dfff */
 1.365299344044, /* 0x1.5d8441ffe */
 1.369003057507, /* 0x1.5e76fc001 */
 1.372714757920, /* 0x1.5f6a3c000 */
 1.376437187179, /* 0x1.605e2fffe */
 1.380165219333, /* 0x1.615282001 */
 1.383909463864, /* 0x1.6247e3ffe */
 1.387661933907, /* 0x1.633dd0000 */
 1.391424179060, /* 0x1.64345fffe */
 1.395197510706, /* 0x1.652ba9fff */
 1.399006724329, /* 0x1.66254dffe */
 1.402773022651, /* 0x1.671c22000 */
 1.406576037403, /* 0x1.68155dfff */
 1.410389423392  /* 0x1.690f48001 */
};

```

`t_expf.h`:

```h
/* Accurate tables for exp().
   Copyright (C) 1998-2015 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Geoffrey Keating <geoffk@ozemail.com.au>

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/* This table has the property that, for all integers -177 <= i <= 177,
   exp(i/512.0 + __exp_deltatable[abs(i)]) == __exp_atable[i+177] + r
   for some -2^-64 < r < 2^-64 (abs(r) < 2^-65 if i <= 0); and that
   __exp_deltatable[abs(i)] == t * 2^-60
   for integer t so that abs(t) <= 8847927 * 2^8.  */

#define W52 (2.22044605e-16)
#define W55 (2.77555756e-17)
#define W58 (3.46944695e-18)
#define W59 (1.73472348e-18)
#define W60 (8.67361738e-19)
static const float __exp_deltatable[178] = {
	0 * W60, IC(16558714) * W60, IC(-10672149) * W59, IC(1441652) * W60,
	IC(-15787963) * W55, IC(462888) * W60, IC(7291806) * W60, IC(1698880) * W60,
	IC(-14375103) * W58, IC(-2021016) * W60, IC(728829) * W60, IC(-3759654) * W60,
	IC(3202123) * W60, IC(-10916019) * W58, IC(-251570) * W60, IC(-1043086) * W60,
	IC(8207536) * W60, IC(-409964) * W60, IC(-5993931) * W60, IC(-475500) * W60,
	IC(2237522) * W60, IC(324170) * W60, IC(-244117) * W60, IC(32077) * W60,
	IC(123907) * W60, IC(-1019734) * W60, IC(-143) * W60, IC(813077) * W60,
	IC(743345) * W60, IC(462461) * W60, IC(629794) * W60, IC(2125066) * W60,
	IC(-2339121) * W60, IC(-337951) * W60, IC(9922067) * W60, IC(-648704) * W60,
	IC(149407) * W60, IC(-2687209) * W60, IC(-631608) * W60, IC(2128280) * W60,
	IC(-4882082) * W60, IC(2001360) * W60, IC(175074) * W60, IC(2923216) * W60,
	IC(-538947) * W60, IC(-1212193) * W60, IC(-1920926) * W60, IC(-1080577) * W60,
	IC(3690196) * W60, IC(2643367) * W60, IC(2911937) * W60, IC(671455) * W60,
	IC(-1128674) * W60, IC(593282) * W60, IC(-5219347) * W60, IC(-1941490) * W60,
	IC(11007953) * W60, IC(239609) * W60, IC(-2969658) * W60, IC(-1183650) * W60,
	IC(942998) * W60, IC(699063) * W60, IC(450569) * W60, IC(-329250) * W60,
	IC(-7257875) * W60, IC(-312436) * W60, IC(51626) * W60, IC(555877) * W60,
	IC(-641761) * W60, IC(1565666) * W60, IC(884327) * W60, IC(-10960035) * W60,
	IC(-2004679) * W60, IC(-995793) * W60, IC(-2229051) * W60, IC(-146179) * W60,
	IC(-510327) * W60, IC(1453482) * W60, IC(-3778852) * W60, IC(-2238056) * W60,
	IC(-4895983) * W60, IC(3398883) * W60, IC(-252738) * W60, IC(1230155) * W60,
	IC(346918) * W60, IC(1109352) * W60, IC(268941) * W60, IC(-2930483) * W60,
	IC(-1036263) * W60, IC(-1159280) * W60, IC(1328176) * W60, IC(2937642) * W60,
	IC(-9371420) * W60, IC(-6902650) * W60, IC(-1419134) * W60, IC(1442904) * W60,
	IC(-1319056) * W60, IC(-16369) * W60, IC(696555) * W60, IC(-279987) * W60,
	IC(-7919763) * W60, IC(252741) * W60, IC(459711) * W60, IC(-1709645) * W60,
	IC(354913) * W60, IC(6025867) * W60, IC(-421460) * W60, IC(-853103) * W60,
	IC(-338649) * W60, IC(962151) * W60, IC(955965) * W60, IC(784419) * W60,
	IC(-3633653) * W60, IC(2277133) * W60, IC(-8847927) * W52, IC(1223028) * W60,
	IC(5907079) * W60, IC(623167) * W60, IC(5142888) * W60, IC(2599099) * W60,
	IC(1214280) * W60, IC(4870359) * W60, IC(593349) * W60, IC(-57705) * W60,
	IC(7761209) * W60, IC(-5564097) * W60, IC(2051261) * W60, IC(6216869) * W60,
	IC(4692163) * W60, IC(601691) * W60, IC(-5264906) * W60, IC(1077872) * W60,
	IC(-3205949) * W60, IC(1833082) * W60, IC(2081746) * W60, IC(-987363) * W60,
	IC(-1049535) * W60, IC(2015244) * W60, IC(874230) * W60, IC(2168259) * W60,
	IC(-1740124) * W60, IC(-10068269) * W60, IC(-18242) * W60, IC(-3013583) * W60,
	IC(580601) * W60, IC(-2547161) * W60, IC(-535689) * W60, IC(2220815) * W60,
	IC(1285067) * W60, IC(2806933) * W60, IC(-983086) * W60, IC(-1729097) * W60,
	IC(-1162985) * W60, IC(-2561904) * W60, IC(801988) * W60, IC(244351) * W60,
	IC(1441893) * W60, IC(-7517981) * W60, IC(271781) * W60, IC(-15021588) * W60,
	IC(-2341588) * W60, IC(-919198) * W60, IC(1642232) * W60, IC(4771771) * W60,
	IC(-1220099) * W60, IC(-3062372) * W60, IC(628624) * W60, IC(1278114) * W60,
	IC(13083513) * W60, IC(-10521925) * W60, IC(3180310) * W60, IC(-1659307) * W60,
	IC(3543773) * W60, IC(2501203) * W60, IC(4151) * W60, IC(-340748) * W60,
	IC(-2285625) * W60, IC(2495202) * W60
};

static const double __exp_atable[355] = {
	0.707722561055888932371,			/* 0x0.b52d4e46605c27ffd */
	0.709106182438804188967,			/* 0x0.b587fb96f75097ffb */
	0.710492508843861281234,			/* 0x0.b5e2d649899167ffd */
	0.711881545564593931623,			/* 0x0.b63dde74d36bdfffe */
	0.713273297897442870573,			/* 0x0.b699142f945f87ffc */
	0.714667771153751463236,			/* 0x0.b6f477909c4ea0001 */
	0.716064970655995725059,			/* 0x0.b75008aec758f8004 */
	0.717464901723956938193,			/* 0x0.b7abc7a0eea7e0002 */
	0.718867569715736398602,			/* 0x0.b807b47e1586c7ff8 */
	0.720272979947266023271,			/* 0x0.b863cf5d10e380003 */
	0.721681137825144314297,			/* 0x0.b8c01855195c37ffb */
	0.723092048691992950199,			/* 0x0.b91c8f7d213740004 */
	0.724505717938892290800,			/* 0x0.b97934ec5002d0007 */
	0.725922150953176470431,			/* 0x0.b9d608b9c92ea7ffc */
	0.727341353138962865022,			/* 0x0.ba330afcc29e98003 */
	0.728763329918453162104,			/* 0x0.ba903bcc8618b7ffc */
	0.730188086709957051568,			/* 0x0.baed9b40591ba0000 */
	0.731615628948127705309,			/* 0x0.bb4b296f931e30002 */
	0.733045962086486091436,			/* 0x0.bba8e671a05617ff9 */
	0.734479091556371366251,			/* 0x0.bc06d25dd49568001 */
	0.735915022857225542529,			/* 0x0.bc64ed4bce8f6fff9 */
	0.737353761441304711410,			/* 0x0.bcc33752f915d7ff9 */
	0.738795312814142124419,			/* 0x0.bd21b08af98e78005 */
	0.740239682467211168593,			/* 0x0.bd80590b65e9a8000 */
	0.741686875913991849885,			/* 0x0.bddf30ebec4a10000 */
	0.743136898669507939299,			/* 0x0.be3e38443c84e0007 */
	0.744589756269486091620,			/* 0x0.be9d6f2c1d32a0002 */
	0.746045454254026796384,			/* 0x0.befcd5bb59baf8004 */
	0.747503998175051087583,			/* 0x0.bf5c6c09ca84c0003 */
	0.748965393601880857739,			/* 0x0.bfbc322f5b18b7ff8 */
	0.750429646104262104698,			/* 0x0.c01c2843f776fffff */
	0.751896761271877989160,			/* 0x0.c07c4e5fa18b88002 */
	0.753366744698445112140,			/* 0x0.c0dca49a5fb18fffd */
	0.754839601988627206827,			/* 0x0.c13d2b0c444db0005 */
	0.756315338768691947122,			/* 0x0.c19de1cd798578006 */
	0.757793960659406629066,			/* 0x0.c1fec8f623723fffd */
	0.759275473314173443536,			/* 0x0.c25fe09e8a0f47ff8 */
	0.760759882363831851927,			/* 0x0.c2c128dedc88f8000 */
	0.762247193485956486805,			/* 0x0.c322a1cf7d6e7fffa */
	0.763737412354726363781,			/* 0x0.c3844b88cb9347ffc */
	0.765230544649828092739,			/* 0x0.c3e626232bd8f7ffc */
	0.766726596071518051729,			/* 0x0.c44831b719bf18002 */
	0.768225572321911687194,			/* 0x0.c4aa6e5d12d078001 */
	0.769727479119219348810,			/* 0x0.c50cdc2da64a37ffb */
	0.771232322196981678892,			/* 0x0.c56f7b41744490001 */
	0.772740107296721268087,			/* 0x0.c5d24bb1259e70004 */
	0.774250840160724651565,			/* 0x0.c6354d95640dd0007 */
	0.775764526565368872643,			/* 0x0.c6988106fec447fff */
	0.777281172269557396602,			/* 0x0.c6fbe61eb1bd0ffff */
	0.778800783068235302750,			/* 0x0.c75f7cf560942fffc */
	0.780323364758801041312,			/* 0x0.c7c345a3f1983fffe */
	0.781848923151573727006,			/* 0x0.c8274043594cb0002 */
	0.783377464064598849602,			/* 0x0.c88b6cec94b3b7ff9 */
	0.784908993312207869935,			/* 0x0.c8efcbb89cba27ffe */
	0.786443516765346961618,			/* 0x0.c9545cc0a88c70003 */
	0.787981040257604625744,			/* 0x0.c9b9201dc643bfffa */
	0.789521569657452682047,			/* 0x0.ca1e15e92a5410007 */
	0.791065110849462849192,			/* 0x0.ca833e3c1ae510005 */
	0.792611669712891875319,			/* 0x0.cae8992fd84667ffd */
	0.794161252150049179450,			/* 0x0.cb4e26ddbc207fff8 */
	0.795713864077794763584,			/* 0x0.cbb3e75f301b60003 */
	0.797269511407239561694,			/* 0x0.cc19dacd978cd8002 */
	0.798828200086368567220,			/* 0x0.cc8001427e55d7ffb */
	0.800389937624300440456,			/* 0x0.cce65ade24d360006 */
	0.801954725261124767840,			/* 0x0.cd4ce7a5de839fffb */
	0.803522573691593189330,			/* 0x0.cdb3a7c79a678fffd */
	0.805093487311204114563,			/* 0x0.ce1a9b563965ffffc */
	0.806667472122675088819,			/* 0x0.ce81c26b838db8000 */
	0.808244534127439906441,			/* 0x0.cee91d213f8428002 */
	0.809824679342317166307,			/* 0x0.cf50ab9144d92fff9 */
	0.811407913793616542005,			/* 0x0.cfb86dd5758c2ffff */
	0.812994243520784198882,			/* 0x0.d0206407c20e20005 */
	0.814583674571603966162,			/* 0x0.d0888e4223facfff9 */
	0.816176213022088536960,			/* 0x0.d0f0ec9eb3f7c8002 */
	0.817771864936188586101,			/* 0x0.d1597f377d6768002 */
	0.819370636400374108252,			/* 0x0.d1c24626a46eafff8 */
	0.820972533518165570298,			/* 0x0.d22b41865ff1e7ff9 */
	0.822577562404315121269,			/* 0x0.d2947170f32ec7ff9 */
	0.824185729164559344159,			/* 0x0.d2fdd60097795fff8 */
	0.825797039949601741075,			/* 0x0.d3676f4fb796d0001 */
	0.827411500902565544264,			/* 0x0.d3d13d78b5f68fffb */
	0.829029118181348834154,			/* 0x0.d43b40960546d8001 */
	0.830649897953322891022,			/* 0x0.d4a578c222a058000 */
	0.832273846408250750368,			/* 0x0.d50fe617a3ba78005 */
	0.833900969738858188772,			/* 0x0.d57a88b1218e90002 */
	0.835531274148056613016,			/* 0x0.d5e560a94048f8006 */
	0.837164765846411529371,			/* 0x0.d6506e1aac8078003 */
	0.838801451086016225394,			/* 0x0.d6bbb1204074e0001 */
	0.840441336100884561780,			/* 0x0.d72729d4c28518004 */
	0.842084427144139224814,			/* 0x0.d792d8530e12b0001 */
	0.843730730487052604790,			/* 0x0.d7febcb61273e7fff */
	0.845380252404570153833,			/* 0x0.d86ad718c308dfff9 */
	0.847032999194574087728,			/* 0x0.d8d727962c69d7fff */
	0.848688977161248581090,			/* 0x0.d943ae49621ce7ffb */
	0.850348192619261200615,			/* 0x0.d9b06b4d832ef8005 */
	0.852010651900976245816,			/* 0x0.da1d5ebdc22220005 */
	0.853676361342631029337,			/* 0x0.da8a88b555baa0006 */
	0.855345327311054837175,			/* 0x0.daf7e94f965f98004 */
	0.857017556155879489641,			/* 0x0.db6580a7c98f7fff8 */
	0.858693054267390953857,			/* 0x0.dbd34ed9617befff8 */
	0.860371828028939855647,			/* 0x0.dc4153ffc8b65fff9 */
	0.862053883854957292436,			/* 0x0.dcaf90368bfca8004 */
	0.863739228154875360306,			/* 0x0.dd1e0399328d87ffe */
	0.865427867361348468455,			/* 0x0.dd8cae435d303fff9 */
	0.867119807911702289458,			/* 0x0.ddfb9050b1cee8006 */
	0.868815056264353846599,			/* 0x0.de6aa9dced8448001 */
	0.870513618890481399881,			/* 0x0.ded9fb03db7320006 */
	0.872215502247877139094,			/* 0x0.df4983e1380657ff8 */
	0.873920712852848668986,			/* 0x0.dfb94490ffff77ffd */
	0.875629257204025623884,			/* 0x0.e0293d2f1cb01fff9 */
	0.877341141814212965880,			/* 0x0.e0996dd786fff0007 */
	0.879056373217612985183,			/* 0x0.e109d6a64f5d57ffc */
	0.880774957955916648615,			/* 0x0.e17a77b78e72a7ffe */
	0.882496902590150900078,			/* 0x0.e1eb5127722cc7ff8 */
	0.884222213673356738383,			/* 0x0.e25c63121fb0c8006 */
	0.885950897802399772740,			/* 0x0.e2cdad93ec5340003 */
	0.887682961567391237685,			/* 0x0.e33f30c925fb97ffb */
	0.889418411575228162725,			/* 0x0.e3b0ecce2d05ffff9 */
	0.891157254447957902797,			/* 0x0.e422e1bf727718006 */
	0.892899496816652704641,			/* 0x0.e4950fb9713fc7ffe */
	0.894645145323828439008,			/* 0x0.e50776d8b0e60fff8 */
	0.896394206626591749641,			/* 0x0.e57a1739c8fadfffc */
	0.898146687421414902124,			/* 0x0.e5ecf0f97c5798007 */
	0.899902594367530173098,			/* 0x0.e660043464e378005 */
	0.901661934163603406867,			/* 0x0.e6d3510747e150006 */
	0.903424713533971135418,			/* 0x0.e746d78f06cd97ffd */
	0.905190939194458810123,			/* 0x0.e7ba97e879c91fffc */
	0.906960617885092856864,			/* 0x0.e82e92309390b0007 */
	0.908733756358986566306,			/* 0x0.e8a2c6845544afffa */
	0.910510361377119825629,			/* 0x0.e9173500c8abc7ff8 */
	0.912290439722343249336,			/* 0x0.e98bddc30f98b0002 */
	0.914073998177417412765,			/* 0x0.ea00c0e84bc4c7fff */
	0.915861043547953501680,			/* 0x0.ea75de8db8094fffe */
	0.917651582652244779397,			/* 0x0.eaeb36d09d3137ffe */
	0.919445622318405764159,			/* 0x0.eb60c9ce4ed3dffff */
	0.921243169397334638073,			/* 0x0.ebd697a43995b0007 */
	0.923044230737526172328,			/* 0x0.ec4ca06fc7768fffa */
	0.924848813220121135342,			/* 0x0.ecc2e44e865b6fffb */
	0.926656923710931002014,			/* 0x0.ed39635df34e70006 */
	0.928468569126343790092,			/* 0x0.edb01dbbc2f5b7ffa */
	0.930283756368834757725,			/* 0x0.ee2713859aab57ffa */
	0.932102492359406786818,			/* 0x0.ee9e44d9342870004 */
	0.933924784042873379360,			/* 0x0.ef15b1d4635438005 */
	0.935750638358567643520,			/* 0x0.ef8d5a94f60f50007 */
	0.937580062297704630580,			/* 0x0.f0053f38f345cffff */
	0.939413062815381727516,			/* 0x0.f07d5fde3a2d98001 */
	0.941249646905368053689,			/* 0x0.f0f5bca2d481a8004 */
	0.943089821583810716806,			/* 0x0.f16e55a4e497d7ffe */
	0.944933593864477061592,			/* 0x0.f1e72b028a2827ffb */
	0.946780970781518460559,			/* 0x0.f2603cd9fb5430001 */
	0.948631959382661205081,			/* 0x0.f2d98b497d2a87ff9 */
	0.950486566729423554277,			/* 0x0.f353166f63e3dffff */
	0.952344799896018723290,			/* 0x0.f3ccde6a11ae37ffe */
	0.954206665969085765512,			/* 0x0.f446e357f66120000 */
	0.956072172053890279009,			/* 0x0.f4c12557964f0fff9 */
	0.957941325265908139014,			/* 0x0.f53ba48781046fffb */
	0.959814132734539637840,			/* 0x0.f5b66106555d07ffa */
	0.961690601603558903308,			/* 0x0.f6315af2c2027fffc */
	0.963570739036113010927,			/* 0x0.f6ac926b8aeb80004 */
	0.965454552202857141381,			/* 0x0.f728078f7c5008002 */
	0.967342048278315158608,			/* 0x0.f7a3ba7d66a908001 */
	0.969233234469444204768,			/* 0x0.f81fab543e1897ffb */
	0.971128118008140250896,			/* 0x0.f89bda33122c78007 */
	0.973026706099345495256,			/* 0x0.f9184738d4cf97ff8 */
	0.974929006031422851235,			/* 0x0.f994f284d3a5c0008 */
	0.976835024947348973265,			/* 0x0.fa11dc35bc7820002 */
	0.978744770239899142285,			/* 0x0.fa8f046b4fb7f8007 */
	0.980658249138918636210,			/* 0x0.fb0c6b449ab1cfff9 */
	0.982575468959622777535,			/* 0x0.fb8a10e1088fb7ffa */
	0.984496437054508843888,			/* 0x0.fc07f5602d79afffc */
	0.986421160608523028820,			/* 0x0.fc8618e0e55e47ffb */
	0.988349647107594098099,			/* 0x0.fd047b83571b1fffa */
	0.990281903873210800357,			/* 0x0.fd831d66f4c018002 */
	0.992217938695037382475,			/* 0x0.fe01fead3320bfff8 */
	0.994157757657894713987,			/* 0x0.fe811f703491e8006 */
	0.996101369488558541238,			/* 0x0.ff007fd5744490005 */
	0.998048781093141101932,			/* 0x0.ff801ffa9b9280007 */
	1.000000000000000000000,			/* 0x1.00000000000000000 */
	1.001955033605393285965,			/* 0x1.0080200565d29ffff */
	1.003913889319761887310,			/* 0x1.0100802aa0e80fff0 */
	1.005876574715736104818,			/* 0x1.01812090377240007 */
	1.007843096764807100351,			/* 0x1.020201541aad7fff6 */
	1.009813464316352327214,			/* 0x1.0283229c4c9820007 */
	1.011787683565730677817,			/* 0x1.030484836910a000e */
	1.013765762469146736174,			/* 0x1.0386272b9c077fffe */
	1.015747708536026694351,			/* 0x1.04080ab526304fff0 */
	1.017733529475172815584,			/* 0x1.048a2f412375ffff0 */
	1.019723232714418781378,			/* 0x1.050c94ef7ad5e000a */
	1.021716825883923762690,			/* 0x1.058f3be0f1c2d0004 */
	1.023714316605201180057,			/* 0x1.06122436442e2000e */
	1.025715712440059545995,			/* 0x1.06954e0fec63afff2 */
	1.027721021151397406936,			/* 0x1.0718b98f41c92fff6 */
	1.029730250269221158939,			/* 0x1.079c66d49bb2ffff1 */
	1.031743407506447551857,			/* 0x1.082056011a9230009 */
	1.033760500517691527387,			/* 0x1.08a487359ebd50002 */
	1.035781537016238873464,			/* 0x1.0928fa93490d4fff3 */
	1.037806524719013578963,			/* 0x1.09adb03b3e5b3000d */
	1.039835471338248051878,			/* 0x1.0a32a84e9e5760004 */
	1.041868384612101516848,			/* 0x1.0ab7e2eea5340ffff */
	1.043905272300907460835,			/* 0x1.0b3d603ca784f0009 */
	1.045946142174331239262,			/* 0x1.0bc3205a042060000 */
	1.047991002016745332165,			/* 0x1.0c4923682a086fffe */
	1.050039859627715177527,			/* 0x1.0ccf698898f3a000d */
	1.052092722826109660856,			/* 0x1.0d55f2dce5d1dfffb */
	1.054149599440827866881,			/* 0x1.0ddcbf86b09a5fff6 */
	1.056210497317612961855,			/* 0x1.0e63cfa7abc97fffd */
	1.058275424318780855142,			/* 0x1.0eeb23619c146fffb */
	1.060344388322010722446,			/* 0x1.0f72bad65714bffff */
	1.062417397220589476718,			/* 0x1.0ffa9627c38d30004 */
	1.064494458915699715017,			/* 0x1.1082b577d0eef0003 */
	1.066575581342167566880,			/* 0x1.110b18e893a90000a */
	1.068660772440545025953,			/* 0x1.1193c09c267610006 */
	1.070750040138235936705,			/* 0x1.121cacb4959befff6 */
	1.072843392435016474095,			/* 0x1.12a5dd543cf36ffff */
	1.074940837302467588937,			/* 0x1.132f529d59552000b */
	1.077042382749654914030,			/* 0x1.13b90cb250d08fff5 */
	1.079148036789447484528,			/* 0x1.14430bb58da3dfff9 */
	1.081257807444460983297,			/* 0x1.14cd4fc984c4a000e */
	1.083371702785017154417,			/* 0x1.1557d910df9c7000e */
	1.085489730853784307038,			/* 0x1.15e2a7ae292d30002 */
	1.087611899742884524772,			/* 0x1.166dbbc422d8c0004 */
	1.089738217537583819804,			/* 0x1.16f9157586772ffff */
	1.091868692357631731528,			/* 0x1.1784b4e533cacfff0 */
	1.094003332327482702577,			/* 0x1.18109a360fc23fff2 */
	1.096142145591650907149,			/* 0x1.189cc58b155a70008 */
	1.098285140311341168136,			/* 0x1.1929370751ea50002 */
	1.100432324652149906842,			/* 0x1.19b5eecdd79cefff0 */
	1.102583706811727015711,			/* 0x1.1a42ed01dbdba000e */
	1.104739294993289488947,			/* 0x1.1ad031c69a2eafff0 */
	1.106899097422573863281,			/* 0x1.1b5dbd3f66e120003 */
	1.109063122341542140286,			/* 0x1.1beb8f8fa8150000b */
	1.111231377994659874592,			/* 0x1.1c79a8dac6ad0fff4 */
	1.113403872669181282605,			/* 0x1.1d0809445a97ffffc */
	1.115580614653132185460,			/* 0x1.1d96b0effc9db000e */
	1.117761612217810673898,			/* 0x1.1e25a001332190000 */
	1.119946873713312474002,			/* 0x1.1eb4d69bdb2a9fff1 */
	1.122136407473298902480,			/* 0x1.1f4454e3bfae00006 */
	1.124330221845670330058,			/* 0x1.1fd41afcbb48bfff8 */
	1.126528325196519908506,			/* 0x1.2064290abc98c0001 */
	1.128730725913251964394,			/* 0x1.20f47f31c9aa7000f */
	1.130937432396844410880,			/* 0x1.21851d95f776dfff0 */
	1.133148453059692917203,			/* 0x1.2216045b6784efffa */
	1.135363796355857157764,			/* 0x1.22a733a6692ae0004 */
	1.137583470716100553249,			/* 0x1.2338ab9b3221a0004 */
	1.139807484614418608939,			/* 0x1.23ca6c5e27aadfff7 */
	1.142035846532929888057,			/* 0x1.245c7613b7f6c0004 */
	1.144268564977221958089,			/* 0x1.24eec8e06b035000c */
	1.146505648458203463465,			/* 0x1.258164e8cea85fff8 */
	1.148747105501412235671,			/* 0x1.26144a5180d380009 */
	1.150992944689175123667,			/* 0x1.26a7793f5de2efffa */
	1.153243174560058870217,			/* 0x1.273af1d712179000d */
	1.155497803703682491111,			/* 0x1.27ceb43d81d42fff1 */
	1.157756840726344771440,			/* 0x1.2862c097a3d29000c */
	1.160020294239811677834,			/* 0x1.28f7170a74cf4fff1 */
	1.162288172883275239058,			/* 0x1.298bb7bb0faed0004 */
	1.164560485298402170388,			/* 0x1.2a20a2ce920dffff4 */
	1.166837240167474476460,			/* 0x1.2ab5d86a4631ffff6 */
	1.169118446164539637555,			/* 0x1.2b4b58b36d5220009 */
	1.171404112007080167155,			/* 0x1.2be123cf786790002 */
	1.173694246390975415341,			/* 0x1.2c7739e3c0aac000d */
	1.175988858069749065617,			/* 0x1.2d0d9b15deb58fff6 */
	1.178287955789017793514,			/* 0x1.2da4478b627040002 */
	1.180591548323240091978,			/* 0x1.2e3b3f69fb794fffc */
	1.182899644456603782686,			/* 0x1.2ed282d76421d0004 */
	1.185212252993012693694,			/* 0x1.2f6a11f96c685fff3 */
	1.187529382762033236513,			/* 0x1.3001ecf60082ffffa */
	1.189851042595508889847,			/* 0x1.309a13f30f28a0004 */
	1.192177241354644978669,			/* 0x1.31328716a758cfff7 */
	1.194507987909589896687,			/* 0x1.31cb4686e1e85fffb */
	1.196843291137896336843,			/* 0x1.32645269dfd04000a */
	1.199183159977805113226,			/* 0x1.32fdaae604c39000f */
	1.201527603343041317132,			/* 0x1.339750219980dfff3 */
	1.203876630171082595692,			/* 0x1.3431424300e480007 */
	1.206230249419600664189,			/* 0x1.34cb8170b3fee000e */
	1.208588470077065268869,			/* 0x1.35660dd14dbd4fffc */
	1.210951301134513435915,			/* 0x1.3600e78b6bdfc0005 */
	1.213318751604272271958,			/* 0x1.369c0ec5c38ebfff2 */
	1.215690830512196507537,			/* 0x1.373783a718d29000f */
	1.218067546930756250870,			/* 0x1.37d3465662f480007 */
	1.220448909901335365929,			/* 0x1.386f56fa770fe0008 */
	1.222834928513994334780,			/* 0x1.390bb5ba5fc540004 */
	1.225225611877684750397,			/* 0x1.39a862bd3c7a8fff3 */
	1.227620969111500981433,			/* 0x1.3a455e2a37bcafffd */
	1.230021009336254911271,			/* 0x1.3ae2a8287dfbefff6 */
	1.232425741726685064472,			/* 0x1.3b8040df76f39fffa */
	1.234835175450728295084,			/* 0x1.3c1e287682e48fff1 */
	1.237249319699482263931,			/* 0x1.3cbc5f151b86bfff8 */
	1.239668183679933477545,			/* 0x1.3d5ae4e2cc0a8000f */
	1.242091776620540377629,			/* 0x1.3df9ba07373bf0006 */
	1.244520107762172811399,			/* 0x1.3e98deaa0d8cafffe */
	1.246953186383919165383,			/* 0x1.3f3852f32973efff0 */
	1.249391019292643401078,			/* 0x1.3fd816ffc72b90001 */
	1.251833623164381181797,			/* 0x1.40782b17863250005 */
	1.254280999953110153911,			/* 0x1.41188f42caf400000 */
	1.256733161434815393410,			/* 0x1.41b943b42945bfffd */
	1.259190116985283935980,			/* 0x1.425a4893e5f10000a */
	1.261651875958665236542,			/* 0x1.42fb9e0a2df4c0009 */
	1.264118447754797758244,			/* 0x1.439d443f608c4fff9 */
	1.266589841787181258708,			/* 0x1.443f3b5bebf850008 */
	1.269066067469190262045,			/* 0x1.44e183883e561fff7 */
	1.271547134259576328224,			/* 0x1.45841cecf7a7a0001 */
	1.274033051628237434048,			/* 0x1.462707b2c43020009 */
	1.276523829025464573684,			/* 0x1.46ca44023aa410007 */
	1.279019475999373156531,			/* 0x1.476dd2045d46ffff0 */
	1.281520002043128991825,			/* 0x1.4811b1e1f1f19000b */
	1.284025416692967214122,			/* 0x1.48b5e3c3edd74fff4 */
	1.286535729509738823464,			/* 0x1.495a67d3613c8fff7 */
	1.289050950070396384145,			/* 0x1.49ff3e396e19d000b */
	1.291571087985403654081,			/* 0x1.4aa4671f5b401fff1 */
	1.294096152842774794011,			/* 0x1.4b49e2ae56d19000d */
	1.296626154297237043484,			/* 0x1.4befb10fd84a3fff4 */
	1.299161101984141142272,			/* 0x1.4c95d26d41d84fff8 */
	1.301701005575179204100,			/* 0x1.4d3c46f01d9f0fff3 */
	1.304245874766450485904,			/* 0x1.4de30ec21097d0003 */
	1.306795719266019562007,			/* 0x1.4e8a2a0ccce3d0002 */
	1.309350548792467483458,			/* 0x1.4f3198fa10346fff5 */
	1.311910373099227200545,			/* 0x1.4fd95bb3be8cffffd */
	1.314475201942565174546,			/* 0x1.50817263bf0e5fffb */
	1.317045045107389400535,			/* 0x1.5129dd3418575000e */
	1.319619912422941299109,			/* 0x1.51d29c4f01c54ffff */
	1.322199813675649204855,			/* 0x1.527bafde83a310009 */
	1.324784758729532718739,			/* 0x1.5325180cfb8b3fffd */
	1.327374757430096474625,			/* 0x1.53ced504b2bd0fff4 */
	1.329969819671041886272,			/* 0x1.5478e6f02775e0001 */
	1.332569955346704748651,			/* 0x1.55234df9d8a59fff8 */
	1.335175174370685002822,			/* 0x1.55ce0a4c5a6a9fff6 */
	1.337785486688218616860,			/* 0x1.56791c1263abefff7 */
	1.340400902247843806217,			/* 0x1.57248376aef21fffa */
	1.343021431036279800211,			/* 0x1.57d040a420c0bfff3 */
	1.345647083048053138662,			/* 0x1.587c53c5a630f0002 */
	1.348277868295411074918,			/* 0x1.5928bd063fd7bfff9 */
	1.350913796821875845231,			/* 0x1.59d57c9110ad60006 */
	1.353554878672557082439,			/* 0x1.5a8292913d68cfffc */
	1.356201123929036356254,			/* 0x1.5b2fff3212db00007 */
	1.358852542671913132777,			/* 0x1.5bddc29edcc06fff3 */
	1.361509145047255398051,			/* 0x1.5c8bdd032ed16000f */
	1.364170941142184734180,			/* 0x1.5d3a4e8a5bf61fff4 */
	1.366837941171020309735,			/* 0x1.5de9176042f1effff */
	1.369510155261156381121,			/* 0x1.5e9837b062f4e0005 */
	1.372187593620959988833,			/* 0x1.5f47afa69436cfff1 */
	1.374870266463378287715,			/* 0x1.5ff77f6eb3f8cfffd */
	1.377558184010425845733,			/* 0x1.60a7a734a9742fff9 */
	1.380251356531521533853,			/* 0x1.6158272490016000c */
	1.382949794301995272203,			/* 0x1.6208ff6a8978a000f */
	1.385653507605306700170,			/* 0x1.62ba3032c0a280004 */
	1.388362506772382154503,			/* 0x1.636bb9a994784000f */
	1.391076802081129493127,			/* 0x1.641d9bfb29a7bfff6 */
	1.393796403973427855412,			/* 0x1.64cfd7545928b0002 */
	1.396521322756352656542,			/* 0x1.65826be167badfff8 */
	1.399251568859207761660,			/* 0x1.663559cf20826000c */
	1.401987152677323100733,			/* 0x1.66e8a14a29486fffc */
	1.404728084651919228815,			/* 0x1.679c427f5a4b6000b */
	1.407474375243217723560,			/* 0x1.68503d9ba0add000f */
	1.410226034922914983815,			/* 0x1.690492cbf6303fff9 */
	1.412983074197955213304,			/* 0x1.69b9423d7b548fff6 */
};
#undef W52
#undef W55
#undef W58
#undef W59
#undef W60

```

`t_sincosl.c`:

```c
/* Extended-precision floating point sine and cosine tables.
   Copyright (C) 1999-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */

/* For 0.1484375 + n/128.0, n=0..82 this table contains
   first 64 bits of cosine, then at least 64 additional
   bits and the same for sine.
   0.1484375+82.0/128.0 is the smallest number among above defined numbers
   larger than pi/4.
   Computed using MPFR:

   #include <stdio.h>
   #include <mpfr.h>

   int
   main (void)
   {
     int j;
     mpfr_t t, b, i, rs, rc, ts, tc, tsl, tcl;
     mpfr_init2 (b, 64);
     mpfr_init2 (i, 64);
     mpfr_init2 (t, 64);
     mpfr_set_str (b, "0.1484375", 0, MPFR_RNDN);
     mpfr_set_str (i, "0x1p-7", 0, MPFR_RNDN);
     mpfr_init2 (rs, 300);
     mpfr_init2 (rc, 300);
     mpfr_init2 (ts, 64);
     mpfr_init2 (tc, 64);
     mpfr_init2 (tsl, 64);
     mpfr_init2 (tcl, 64);
     for (j = 0; j <= 82; j++)
       {
         mpfr_mul_ui (t, i, j, MPFR_RNDN);
         mpfr_add (t, t, b, MPFR_RNDN);
         printf ("  /" "* x = 0.1484375 + %d/128.  *" "/\n", j);
         mpfr_cos (rc, t, MPFR_RNDN);
         mpfr_sin (rs, t, MPFR_RNDN);
         mpfr_set (tc, rc, MPFR_RNDN);
         mpfr_set (ts, rs, MPFR_RNDN);
         mpfr_sub (tcl, rc, tc, MPFR_RNDN);
         mpfr_sub (tsl, rs, ts, MPFR_RNDN);
         mpfr_printf ("  %.17RaL,\n", tc);
         mpfr_printf ("  %.17RaL,\n", tcl);
         mpfr_printf ("  %.17RaL,\n", ts);
         mpfr_printf ("  %.17RaL,\n", tsl);
       }
     return 0;
   }

*/

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#define HEXCONSTE(d, h) d

const long double __sincosl_table[] = {
  /* x = 0.1484375 + 0/128.  */
  HEXCONSTE(9.89003367927322909038e-01L, 0xf.d2f5320e1b7902100p-4L),
  HEXCONSTE(-2.13231840142488555850e-20L, -0x6.4b225d06708635580p-68L),
  HEXCONSTE(1.47892995873409608575e-01L, 0x2.5dc50bc95711d0d80p-4L),
  HEXCONSTE(4.98278425828992151485e-21L, 0x1.787d108fd438cf5a0p-68L),
  /* x = 0.1484375 + 1/128.  */
  HEXCONSTE(9.87817783816471944077e-01L, 0xf.ce1a053e621438b00p-4L),
  HEXCONSTE(2.31617015504752229136e-20L, 0x6.d60c76e8c45bf0a80p-68L),
  HEXCONSTE(1.55614992773556041214e-01L, 0x2.7d66258bacd96a400p-4L),
  HEXCONSTE(-4.40444203884857086035e-21L, -0x1.4cca4c9a3782a6bc0p-68L),
  /* x = 0.1484375 + 2/128.  */
  HEXCONSTE(9.86571908399497588731e-01L, 0xf.c8ffa01ba68074100p-4L),
  HEXCONSTE(2.66861589611214360329e-20L, 0x7.e05962b0d9fdf2000p-68L),
  HEXCONSTE(1.63327491736612850852e-01L, 0x2.9cfd49b8be4f66540p-4L),
  HEXCONSTE(-5.20406786070713935071e-21L, -0x1.89354fe340fbd96c0p-68L),
  /* x = 0.1484375 + 3/128.  */
  HEXCONSTE(9.85265817718213816185e-01L, 0xf.c3a6170f767ac7300p-4L),
  HEXCONSTE(1.97761100206283328059e-20L, 0x5.d63d99a9d439e1d80p-68L),
  HEXCONSTE(1.71030022031395019275e-01L, 0x2.bc89f9f424de54840p-4L),
  HEXCONSTE(6.33273325764964683162e-21L, 0x1.de7ce03b2514952c0p-68L),
  /* x = 0.1484375 + 4/128.  */
  HEXCONSTE(9.83899591489663972196e-01L, 0xf.be0d7f7fef11e7100p-4L),
  HEXCONSTE(-1.81551905584600649427e-20L, -0x5.5bc47540b095ba800p-68L),
  HEXCONSTE(1.78722113535153659378e-01L, 0x2.dc0bb80b49a97ffc0p-4L),
  HEXCONSTE(-2.68787874500507442373e-21L, -0xc.b1722e07246208500p-72L),
  /* x = 0.1484375 + 5/128.  */
  HEXCONSTE(9.82473313101255257493e-01L, 0xf.b835efcf670dd2d00p-4L),
  HEXCONSTE(-5.29521884989285724198e-21L, -0x1.90186db968115ec20p-68L),
  HEXCONSTE(1.86403296762269884548e-01L, 0x2.fb8205f75e56a2b40p-4L),
  HEXCONSTE(4.79249212825385550465e-21L, 0x1.6a1c4792f85625880p-68L),
  /* x = 0.1484375 + 6/128.  */
  HEXCONSTE(9.80987069605669190469e-01L, 0xf.b21f7f5c156696b00p-4L),
  HEXCONSTE(1.42378091124512193886e-22L, 0xa.c1fe28ac5fd766700p-76L),
  HEXCONSTE(1.94073102892909791155e-01L, 0x3.1aec65df552876f80p-4L),
  HEXCONSTE(6.19486009154478228324e-22L, 0x2.ece9a235671324700p-72L),
  /* x = 0.1484375 + 7/128.  */
  HEXCONSTE(9.79440951715548360009e-01L, 0xf.abca467fb3cb8f200p-4L),
  HEXCONSTE(-1.00767655478452301975e-20L, -0x2.f960fe2715cc521c0p-68L),
  HEXCONSTE(2.01731063801638804721e-01L, 0x3.3a4a5a19d86246700p-4L),
  HEXCONSTE(3.59162715976515462280e-21L, 0x1.0f602c44df4fa5140p-68L),
  /* x = 0.1484375 + 8/128.  */
  HEXCONSTE(9.77835053797959793346e-01L, 0xf.a5365e8f1d3ca2800p-4L),
  HEXCONSTE(-1.39514678304373764381e-20L, -0x4.1e24a289519b26800p-68L),
  HEXCONSTE(2.09376712085993643705e-01L, 0x3.599b652f40ec999c0p-4L),
  HEXCONSTE(6.57991365997798986044e-21L, 0x1.f12a0a4c8561de160p-68L),
  /* x = 0.1484375 + 9/128.  */
  HEXCONSTE(9.76169473868635276714e-01L, 0xf.9e63e1d9e8b6f6f00p-4L),
  HEXCONSTE(9.77514123487945515229e-21L, 0x2.e296bae5b5ed9c100p-68L),
  HEXCONSTE(2.17009581095010156758e-01L, 0x3.78df09db8c332ce00p-4L),
  HEXCONSTE(2.78869676368043837016e-21L, 0xd.2b53d865582e45200p-72L),
  /* x = 0.1484375 + 10/128.  */
  HEXCONSTE(9.74444313585988980376e-01L, 0xf.9752eba9fff6b9900p-4L),
  HEXCONSTE(-2.62216937435242560980e-20L, -0x7.bd415254fab56cd00p-68L),
  HEXCONSTE(2.24629204957705292352e-01L, 0x3.9814cb10513453cc0p-4L),
  HEXCONSTE(-1.38045543929396355840e-21L, -0x6.84de43e3595cc8500p-72L),
  /* x = 0.1484375 + 11/128.  */
  HEXCONSTE(9.72659678244912752657e-01L, 0xf.90039843324f9b900p-4L),
  HEXCONSTE(1.36066431847933429307e-20L, 0x4.0416c1984b6cbed00p-68L),
  HEXCONSTE(2.32235118611511462411e-01L, 0x3.b73c2bf6b4b9f6680p-4L),
  HEXCONSTE(3.17082113904069975039e-21L, 0xe.f9499c81f0d965100p-72L),
  /* x = 0.1484375 + 12/128.  */
  HEXCONSTE(9.70815676770349462944e-01L, 0xf.887604e2c39dbb200p-4L),
  HEXCONSTE(3.02977358929219524715e-21L, 0xe.4ec5825059a78a000p-72L),
  HEXCONSTE(2.39826857830661564438e-01L, 0x3.d654aff15cb457a00p-4L),
  HEXCONSTE(3.34389467316840192054e-21L, 0xf.ca854698aba330400p-72L),
  /* x = 0.1484375 + 13/128.  */
  HEXCONSTE(9.68912421710644784171e-01L, 0xf.80aa4fbef750ba800p-4L),
  HEXCONSTE(-2.62950482822512977421e-20L, -0x7.c2cc346a06b075c00p-68L),
  HEXCONSTE(2.47403959254522929593e-01L, 0x3.f55dda9e62aed7500p-4L),
  HEXCONSTE(4.18014286719533146981e-21L, 0x1.3bd7b8e6a3d1635e0p-68L),
  /* x = 0.1484375 + 14/128.  */
  HEXCONSTE(9.66950029230677822023e-01L, 0xf.78a098069792dab00p-4L),
  HEXCONSTE(-1.42681283846165712932e-20L, -0x4.3611bda6e483a5980p-68L),
  HEXCONSTE(2.54965960415878467490e-01L, 0x4.14572fd94556e6480p-4L),
  HEXCONSTE(-2.57573653670122274821e-21L, -0xc.29dfd8ec7722b8400p-72L),
  /* x = 0.1484375 + 15/128.  */
  HEXCONSTE(9.64928619104771009580e-01L, 0xf.7058fde0788dfc800p-4L),
  HEXCONSTE(1.21181485754992584423e-21L, 0x5.b8fe88789e4f42500p-72L),
  HEXCONSTE(2.62512399769153281461e-01L, 0x4.334033bcd90d66080p-4L),
  HEXCONSTE(-1.02973945157718102948e-20L, -0x3.0a0c93e2b47bbae40p-68L),
  /* x = 0.1484375 + 16/128.  */
  HEXCONSTE(9.62848314709379699884e-01L, 0xf.67d3a26af7d07aa00p-4L),
  HEXCONSTE(1.60595699634281048404e-20L, 0x4.bd6d42af8c0068000p-68L),
  HEXCONSTE(2.70042816718585031540e-01L, 0x4.52186aa5377ab2080p-4L),
  HEXCONSTE(1.26941796377356567222e-20L, 0x3.bf2524f52e3a06a80p-68L),
  /* x = 0.1484375 + 17/128.  */
  HEXCONSTE(9.60709243015561903064e-01L, 0xf.5f10a7bb77d3dfa00p-4L),
  HEXCONSTE(2.56563220727436661740e-21L, 0xc.1da8b578427832800p-72L),
  HEXCONSTE(2.77556751646336325920e-01L, 0x4.70df5931ae1d94600p-4L),
  HEXCONSTE(1.57485127810111795649e-21L, 0x7.6fe0dcff47fe31b80p-72L),
  /* x = 0.1484375 + 18/128.  */
  HEXCONSTE(9.58511534581228627299e-01L, 0xf.561030ddd7a789600p-4L),
  HEXCONSTE(3.10519930497093774364e-21L, 0xe.a9f4a32c652155500p-72L),
  HEXCONSTE(2.85053745940547424589e-01L, 0x4.8f948446abcd6b100p-4L),
  HEXCONSTE(-1.69671848592029057923e-21L, -0x8.0334eff185e4d9100p-72L),
  /* x = 0.1484375 + 19/128.  */
  HEXCONSTE(9.56255323543175296964e-01L, 0xf.4cd261d3e6c15bb00p-4L),
  HEXCONSTE(1.15644222876172451781e-20L, 0x3.69c8758630d2ac000p-68L),
  HEXCONSTE(2.92533342023327543616e-01L, 0x4.ae37710fad27c8a80p-4L),
  HEXCONSTE(8.84488586523313362501e-21L, 0x2.9c4cf96c03519b9c0p-68L),
  /* x = 0.1484375 + 20/128.  */
  HEXCONSTE(9.53940747608894733971e-01L, 0xf.43575f94d4f6b2700p-4L),
  HEXCONSTE(1.00318119448780868195e-20L, 0x2.f5fb76b14d2a64ac0p-68L),
  HEXCONSTE(2.99995083378683051174e-01L, 0x4.ccc7a50127e1de100p-4L),
  HEXCONSTE(-1.11344689690403402932e-20L, -0x3.494bf3cfd39ae0840p-68L),
  /* x = 0.1484375 + 21/128.  */
  HEXCONSTE(9.51567948048172202163e-01L, 0xf.399f500c9e9fd3800p-4L),
  HEXCONSTE(-1.72373351901632477563e-20L, -0x5.166a8d9c254778900p-68L),
  HEXCONSTE(3.07438514580380850669e-01L, 0x4.eb44a5da74f600200p-4L),
  HEXCONSTE(1.62344717910253214207e-21L, 0x7.aaa090f0734e28880p-72L),
  /* x = 0.1484375 + 22/128.  */
  HEXCONSTE(9.49137069684463027645e-01L, 0xf.2faa5a1b74e82fd00p-4L),
  HEXCONSTE(2.07473634239044581948e-20L, 0x6.1fa05f9177380e900p-68L),
  HEXCONSTE(3.14863181319745250871e-01L, 0x5.09adf9a7b9a5a0f80p-4L),
  HEXCONSTE(-6.02637381960544846509e-21L, -0x1.c75705c59f5e66be0p-68L),
  /* x = 0.1484375 + 23/128.  */
  HEXCONSTE(9.46648260886053321823e-01L, 0xf.2578a595224dd2e00p-4L),
  HEXCONSTE(2.28650773851898088275e-20L, 0x6.bfa2eb2f99cc67500p-68L),
  HEXCONSTE(3.22268630433386625675e-01L, 0x5.280326c3cf4818200p-4L),
  HEXCONSTE(1.26316522958226468432e-20L, 0x3.ba6bb08eac82c2080p-68L),
  /* x = 0.1484375 + 24/128.  */
  HEXCONSTE(9.44101673557004345656e-01L, 0xf.1b0a5b406b526d900p-4L),
  HEXCONSTE(-2.56712403846585417020e-20L, -0x7.93aa0152372f23380p-68L),
  HEXCONSTE(3.29654409930860171923e-01L, 0x5.4643b3da29de9b380p-4L),
  HEXCONSTE(-8.66441016875827628508e-21L, -0x2.8eaa110f0ccd04c00p-68L),
  /* x = 0.1484375 + 25/128.  */
  HEXCONSTE(9.41497463127881068618e-01L, 0xf.105fa4d66b607a600p-4L),
  HEXCONSTE(2.65267525050600210733e-20L, 0x7.d44e0427252044380p-68L),
  HEXCONSTE(3.37020069022253076249e-01L, 0x5.646f27e8bd65cbe00p-4L),
  HEXCONSTE(1.23592221749238593975e-20L, 0x3.a5d61ff0657229100p-68L),
  /* x = 0.1484375 + 26/128.  */
  HEXCONSTE(9.38835788546265488652e-01L, 0xf.0578ad01ede708000p-4L),
  HEXCONSTE(-1.95644439854405762611e-20L, -0x5.c63f6239467b50100p-68L),
  HEXCONSTE(3.44365158145698408207e-01L, 0x5.82850a41e1dd46c80p-4L),
  HEXCONSTE(-1.32198215872418315080e-22L, -0x9.fd15dbb3244403200p-76L),
  /* x = 0.1484375 + 27/128.  */
  HEXCONSTE(9.36116812267055290278e-01L, 0xe.fa559f5ec3aec3a00p-4L),
  HEXCONSTE(1.66628913666496689574e-20L, 0x4.eb03319278a2d4200p-68L),
  HEXCONSTE(3.51689228994814059225e-01L, 0x5.a084e28e35fda2780p-4L),
  HEXCONSTE(-1.93241109989952969218e-21L, -0x9.202444aace28b3100p-72L),
  /* x = 0.1484375 + 28/128.  */
  HEXCONSTE(9.33340700242548435657e-01L, 0xe.eef6a879146af0c00p-4L),
  HEXCONSTE(-1.32897345772491558961e-21L, -0x6.46a15d15f53f2c200p-72L),
  HEXCONSTE(3.58991834546065053665e-01L, 0x5.be6e38ce809554280p-4L),
  HEXCONSTE(1.27228088300892142412e-20L, 0x3.c14ee9da0d3648400p-68L),
  /* x = 0.1484375 + 29/128.  */
  HEXCONSTE(9.30507621912314291160e-01L, 0xe.e35bf5ccac8905300p-4L),
  HEXCONSTE(-1.06790124867696704650e-20L, -0x3.26e2248cb2c5b81c0p-68L),
  HEXCONSTE(3.66272529086047561364e-01L, 0x5.dc40955d9084f4880p-4L),
  HEXCONSTE(8.74037044797859402972e-21L, 0x2.94675a2498de5d840p-68L),
  /* x = 0.1484375 + 30/128.  */
  HEXCONSTE(9.27617750192851909651e-01L, 0xe.d785b5c44741b4500p-4L),
  HEXCONSTE(-2.29183449263892408500e-20L, -0x6.c3a943462cc75eb00p-68L),
  HEXCONSTE(3.73530868238692946430e-01L, 0x5.f9fb80f21b5364a00p-4L),
  HEXCONSTE(-1.26638636293427510160e-20L, -0x3.bcdabf5af1dd3ad00p-68L),
  /* x = 0.1484375 + 31/128.  */
  HEXCONSTE(9.24671261467036098515e-01L, 0xe.cb7417b8d4ee3ff00p-4L),
  HEXCONSTE(-1.28157345989865023457e-20L, -0x3.c8545bf8c55b70e00p-68L),
  HEXCONSTE(3.80766408992390192071e-01L, 0x6.179e84a09a5258a80p-4L),
  HEXCONSTE(-1.33592060652005256341e-20L, -0x3.f164a0531fc1ada00p-68L),
  /* x = 0.1484375 + 32/128.  */
  HEXCONSTE(9.21668335573351918161e-01L, 0xe.bf274bf0bda4f6200p-4L),
  HEXCONSTE(1.45040647682423457681e-20L, 0x4.47e56a09362679900p-68L),
  HEXCONSTE(3.87978709727025046044e-01L, 0x6.352929dd264bd4480p-4L),
  HEXCONSTE(6.81485478221876523830e-21L, 0x2.02ea766325d8aa8c0p-68L),
  /* x = 0.1484375 + 33/128.  */
  HEXCONSTE(9.18609155794918267853e-01L, 0xe.b29f839f201fd1400p-4L),
  HEXCONSTE(-1.49888535571324401483e-20L, -0x4.6c8697d86e9587100p-68L),
  HEXCONSTE(3.95167330240934236234e-01L, 0x6.529afa7d51b129600p-4L),
  HEXCONSTE(1.05714505734028921913e-20L, 0x3.1ec197c0a840a11c0p-68L),
  /* x = 0.1484375 + 34/128.  */
  HEXCONSTE(9.15493908848301228586e-01L, 0xe.a5dcf0e30cf03e700p-4L),
  HEXCONSTE(-2.21428472705231207029e-20L, -0x6.8910f4e13d9aea080p-68L),
  HEXCONSTE(4.02331831777773111223e-01L, 0x6.6ff380ba014410a00p-4L),
  HEXCONSTE(-6.01344135520230631298e-21L, -0x1.c65cdf4f5c05a02a0p-68L),
  /* x = 0.1484375 + 35/128.  */
  HEXCONSTE(9.12322784872117846489e-01L, 0xe.98dfc6c6be031e600p-4L),
  HEXCONSTE(2.92742001557490219940e-21L, 0xd.d3089cbdd18a75b00p-72L),
  HEXCONSTE(4.09471777053295066110e-01L, 0x6.8d324731433279700p-4L),
  HEXCONSTE(1.26584054576324074473e-20L, 0x3.bc712bcc4ccddc480p-68L),
  /* x = 0.1484375 + 36/128.  */
  HEXCONSTE(9.09095977415431051670e-01L, 0xe.8ba8393eca7821b00p-4L),
  HEXCONSTE(-1.91874100722343522460e-20L, -0x5.a9c27cb6e49efee80p-68L),
  HEXCONSTE(4.16586730282041119248e-01L, 0x6.aa56d8e8249db4e80p-4L),
  HEXCONSTE(1.14435982751372847976e-20L, 0x3.60a761fe3f9e559c0p-68L),
  /* x = 0.1484375 + 37/128.  */
  HEXCONSTE(9.05813683425936420760e-01L, 0xe.7e367d2956cfb1700p-4L),
  HEXCONSTE(-1.55294309964866840562e-20L, -0x4.955ee1abe632ffa80p-68L),
  HEXCONSTE(4.23676257203938010369e-01L, 0x6.c760c14c8585a5200p-4L),
  HEXCONSTE(-7.66029225036476932445e-21L, -0x2.42cb99f5193ad5380p-68L),
  /* x = 0.1484375 + 38/128.  */
  HEXCONSTE(9.02476103237941504917e-01L, 0xe.708ac84d4172a3e00p-4L),
  HEXCONSTE(8.30439617928509375258e-21L, 0x2.737662213429e1400p-68L),
  HEXCONSTE(4.30739925110803197219e-01L, 0x6.e44f8c36eb10a1c80p-4L),
  HEXCONSTE(-2.29208763946240806250e-21L, -0xa.d2f6c3ff0b2b84600p-72L),
  /* x = 0.1484375 + 39/128.  */
  HEXCONSTE(8.99083440560138456193e-01L, 0xe.62a551594b970a700p-4L),
  HEXCONSTE(2.38636348216540976170e-20L, 0x7.0b15d41d4c0e48400p-68L),
  HEXCONSTE(4.37777302872755132862e-01L, 0x7.0122c5ec5028c8d00p-4L),
  HEXCONSTE(-1.69016402576717882854e-22L, -0xc.c540b02cbf333c800p-76L),
  /* x = 0.1484375 + 40/128.  */
  HEXCONSTE(8.95635902463170698918e-01L, 0xe.54864fe33e8575d00p-4L),
  HEXCONSTE(-1.77961800058544374685e-20L, -0x5.40a42f1a30e4e5780p-68L),
  HEXCONSTE(4.44787960964527211421e-01L, 0x7.1dd9fb1ff46778500p-4L),
  HEXCONSTE(1.24503834409269736986e-20L, 0x3.acb970a9f6729c700p-68L),
  /* x = 0.1484375 + 41/128.  */
  HEXCONSTE(8.92133699366994404711e-01L, 0xe.462dfc670d421ab00p-4L),
  HEXCONSTE(1.29388288146449617644e-20L, 0x3.d1a15901228f146c0p-68L),
  HEXCONSTE(4.51771471491683776576e-01L, 0x7.3a74b8f52947b6800p-4L),
  HEXCONSTE(5.86256879093106433623e-21L, 0x1.baf6928eb3fb02180p-68L),
  /* x = 0.1484375 + 42/128.  */
  HEXCONSTE(8.88577045028035543330e-01L, 0xe.379c9045f29d51800p-4L),
  HEXCONSTE(-1.25991671109055059195e-20L, -0x3.b7f755b683dfa84c0p-68L),
  HEXCONSTE(4.58727408216736592370e-01L, 0x7.56f28d011d9852880p-4L),
  HEXCONSTE(7.68488912075400148930e-21L, 0x2.44a75fc29c779bd80p-68L),
  /* x = 0.1484375 + 43/128.  */
  HEXCONSTE(8.84966156526143291690e-01L, 0xe.28d245c58baef7200p-4L),
  HEXCONSTE(7.27764865972459924999e-21L, 0x2.25e232abc003c4380p-68L),
  HEXCONSTE(4.65655346585160182692e-01L, 0x7.7353054ca72690d80p-4L),
  HEXCONSTE(-1.09203637279124669245e-20L, -0x3.391e8e0266194c600p-68L),
  /* x = 0.1484375 + 44/128.  */
  HEXCONSTE(8.81301254251340599160e-01L, 0xe.19cf580eeec046b00p-4L),
  HEXCONSTE(-2.00622846002828080934e-20L, -0x5.ebdd058b7f8131080p-68L),
  HEXCONSTE(4.72554863751304451150e-01L, 0x7.8f95b0560a9a3bd80p-4L),
  HEXCONSTE(-3.81848027624352422807e-21L, -0x1.2084267e23c739ee0p-68L),
  /* x = 0.1484375 + 45/128.  */
  HEXCONSTE(8.77582561890372716130e-01L, 0xe.0a94032dbea7cee00p-4L),
  HEXCONSTE(-1.40044855996735394062e-20L, -0x4.222625d0505267a80p-68L),
  HEXCONSTE(4.79425538604203000282e-01L, 0x7.abba1d12c17bfa200p-4L),
  HEXCONSTE(-8.21964987414168684016e-21L, -0x2.6d0f26c09f2126680p-68L),
  /* x = 0.1484375 + 46/128.  */
  HEXCONSTE(8.73810306413054508257e-01L, 0xd.fb20840f3a9b36f00p-4L),
  HEXCONSTE(2.60220845186527729776e-20L, 0x7.ae2c515342890b600p-68L),
  HEXCONSTE(4.86266951793275574304e-01L, 0x7.c7bfdaf13e5ed1700p-4L),
  HEXCONSTE(7.02734668429569836155e-21L, 0x2.12f8a7525bfb113c0p-68L),
  /* x = 0.1484375 + 47/128.  */
  HEXCONSTE(8.69984718058417388843e-01L, 0xd.eb7518814a7a93200p-4L),
  HEXCONSTE(-1.44421316189897037823e-20L, -0x4.433773ef632be3b00p-68L),
  HEXCONSTE(4.93078685753923057271e-01L, 0x7.e3a679daaf25c6780p-4L),
  HEXCONSTE(-5.66226874073050650550e-21L, -0x1.abd434bfd72f69be0p-68L),
  /* x = 0.1484375 + 48/128.  */
  HEXCONSTE(8.66106030320656714711e-01L, 0xd.db91ff31879917300p-4L),
  HEXCONSTE(-1.41577557747757377389e-20L, -0x4.2dbad2f5c7760ae80p-68L),
  HEXCONSTE(4.99860324733013463829e-01L, 0x7.ff6d8a34bd5e8fa80p-4L),
  HEXCONSTE(-9.15072264881519793247e-21L, -0x2.b368b7d24aea62100p-68L),
  /* x = 0.1484375 + 49/128.  */
  HEXCONSTE(8.62174479934880504345e-01L, 0xd.cb7777ac420705100p-4L),
  HEXCONSTE(2.22239592442876500218e-20L, 0x6.8f31e3eb780ce9c80p-68L),
  HEXCONSTE(5.06611454814257367648e-01L, 0x8.1b149ce34caa5a500p-4L),
  HEXCONSTE(-5.43873574372091021165e-21L, -0x1.9af072f602b295580p-68L),
  /* x = 0.1484375 + 50/128.  */
  HEXCONSTE(8.58190306862660347049e-01L, 0xd.bb25c25b8260c1500p-4L),
  HEXCONSTE(-1.92589425569875060353e-21L, -0x9.1843671366e48f400p-72L),
  HEXCONSTE(5.13331663943471218305e-01L, 0x8.369b434a372da7f00p-4L),
  HEXCONSTE(-1.57158916299168626266e-20L, -0x4.a3758e01c931e1f80p-68L),
  /* x = 0.1484375 + 51/128.  */
  HEXCONSTE(8.54153754277385385144e-01L, 0xd.aa9d2086082706400p-4L),
  HEXCONSTE(-4.45759752235584325033e-22L, -0x2.1ae3f617aa166cd00p-72L),
  HEXCONSTE(5.20020541953727004748e-01L, 0x8.52010f4f080052100p-4L),
  HEXCONSTE(1.17623818577417093831e-20L, 0x3.78bd8dd614753d080p-68L),
  /* x = 0.1484375 + 52/128.  */
  HEXCONSTE(8.50065068549420263966e-01L, 0xd.99ddd44e44a43d500p-4L),
  HEXCONSTE(-9.18200229983247954575e-21L, -0x2.b5c5c126adfbef900p-68L),
  HEXCONSTE(5.26677680590386730717e-01L, 0x8.6d45935ab396cb500p-4L),
  HEXCONSTE(-5.90118359800578539313e-21L, -0x1.bde17dd211ab0caa0p-68L),
  /* x = 0.1484375 + 53/128.  */
  HEXCONSTE(8.45924499231067954469e-01L, 0xd.88e820b1526311e00p-4L),
  HEXCONSTE(-9.02459303942571217866e-21L, -0x2.a9e1043f3e565ac80p-68L),
  HEXCONSTE(5.33302673536020173319e-01L, 0x8.8868625b4e1dbb200p-4L),
  HEXCONSTE(1.04183917560805762189e-20L, 0x3.13310133022527200p-68L),
  /* x = 0.1484375 + 54/128.  */
  HEXCONSTE(8.41732299041338366975e-01L, 0xd.77bc4985e93a60800p-4L),
  HEXCONSTE(-1.14676936349510593222e-20L, -0x3.6279746f944394400p-68L),
  HEXCONSTE(5.39895116435204405064e-01L, 0x8.a3690fc5bfc11c000p-4L),
  HEXCONSTE(-2.26135590620802231857e-20L, -0x6.aca1d8c657aed0b80p-68L),
  /* x = 0.1484375 + 55/128.  */
  HEXCONSTE(8.37488723850523685292e-01L, 0xd.665a937b4ef2b1f00p-4L),
  HEXCONSTE(2.31492531524952692639e-20L, 0x6.d51bad6d988a44180p-68L),
  HEXCONSTE(5.46454606919203564406e-01L, 0x8.be472f9776d809b00p-4L),
  HEXCONSTE(-2.81199583315247283697e-21L, -0xd.477e8edbc29c29900p-72L),
  /* x = 0.1484375 + 56/128.  */
  HEXCONSTE(8.33194032664581363094e-01L, 0xd.54c3441844897fd00p-4L),
  HEXCONSTE(-2.38184620945175358135e-20L, -0x7.07ac0f9aa0e459680p-68L),
  HEXCONSTE(5.52980744630527369871e-01L, 0x8.d902565817ee78400p-4L),
  HEXCONSTE(-2.12169862016049170373e-20L, -0x6.431c32ed7f9fee680p-68L),
  /* x = 0.1484375 + 57/128.  */
  HEXCONSTE(8.28848487609325734814e-01L, 0xd.42f6a1b9f0168ce00p-4L),
  HEXCONSTE(-3.34696998325213509739e-21L, -0xf.ce3d09c3726cfb200p-72L),
  HEXCONSTE(5.59473131247366877404e-01L, 0x8.f39a191b2ba612300p-4L),
  HEXCONSTE(-1.94864647768084335763e-20L, -0x5.c05b0be2a5c002c00p-68L),
  /* x = 0.1484375 + 58/128.  */
  HEXCONSTE(8.24452353914429207464e-01L, 0xd.30f4f392c357ab000p-4L),
  HEXCONSTE(2.16228103024253588454e-20L, 0x6.61c5fa8a7d9b26600p-68L),
  HEXCONSTE(5.65931370507905990750e-01L, 0x9.0e0e0d81ca6787900p-4L),
  HEXCONSTE(2.30362968512695267962e-20L, 0x6.cc92c8ea8c2815c00p-68L),
  /* x = 0.1484375 + 59/128.  */
  HEXCONSTE(8.20005899897234008240e-01L, 0xd.1ebe81a95ee752e00p-4L),
  HEXCONSTE(1.53809446354279993570e-20L, 0x4.8a26bcd32d6e92300p-68L),
  HEXCONSTE(5.72355068234507240372e-01L, 0x9.285dc9bc45dd9ea00p-4L),
  HEXCONSTE(1.29191313204581227755e-20L, 0x3.d02457bcce59c4180p-68L),
  /* x = 0.1484375 + 60/128.  */
  HEXCONSTE(8.15509396946375476856e-01L, 0xd.0c5394d7722281900p-4L),
  HEXCONSTE(1.99362528914976799676e-20L, 0x5.e25736c0357470800p-68L),
  HEXCONSTE(5.78743832357770354507e-01L, 0x9.4288e48bd0335fc00p-4L),
  HEXCONSTE(1.39270713790910161139e-20L, 0x4.1c4cbd2920497a900p-68L),
  /* x = 0.1484375 + 61/128.  */
  HEXCONSTE(8.10963119505217902203e-01L, 0xc.f9b476c897c25c600p-4L),
  HEXCONSTE(-1.35729453849135558116e-20L, -0x4.018af22c0cf715080p-68L),
  HEXCONSTE(5.85097272940462154829e-01L, 0x9.5c8ef544210ec0c00p-4L),
  HEXCONSTE(-2.33425333952787374945e-20L, -0x6.e3b642d55f617ae80p-68L),
  /* x = 0.1484375 + 62/128.  */
  HEXCONSTE(8.06367345055103913688e-01L, 0xc.e6e171f92f2e27f00p-4L),
  HEXCONSTE(1.06163046728677933135e-20L, 0x3.2225327ec440ddb00p-68L),
  HEXCONSTE(5.91415002201316315105e-01L, 0x9.766f93cd18413a700p-4L),
  HEXCONSTE(-1.80026651925272365358e-20L, -0x5.503e303903d754480p-68L),
  /* x = 0.1484375 + 63/128.  */
  HEXCONSTE(8.01722354098418450588e-01L, 0xc.d3dad1b5328a2e400p-4L),
  HEXCONSTE(1.90529291233468413425e-20L, 0x5.9f993f4f510881a00p-68L),
  HEXCONSTE(5.97696634538701531217e-01L, 0x9.902a58a45e27bed00p-4L),
  HEXCONSTE(2.20767631472538020202e-20L, 0x6.8412b426b675ed500p-68L),
  /* x = 0.1484375 + 64/128.  */
  HEXCONSTE(7.97028430141468342005e-01L, 0xc.c0a0e21709883a400p-4L),
  HEXCONSTE(-2.11289337022436663315e-22L, -0xf.f6ee1ee5f811c4300p-76L),
  HEXCONSTE(6.03941786554156657290e-01L, 0x9.a9bedcdf01b38da00p-4L),
  HEXCONSTE(-2.28799465801609035460e-20L, -0x6.c0c287df87e21d700p-68L),
  /* x = 0.1484375 + 65/128.  */
  HEXCONSTE(7.92285859677178543135e-01L, 0xc.ad33f00658fe5e800p-4L),
  HEXCONSTE(6.83890977694422698650e-21L, 0x2.04bbc0f3a66a0e6c0p-68L),
  HEXCONSTE(6.10150077075791371273e-01L, 0x9.c32cba2b14156ef00p-4L),
  HEXCONSTE(1.08974683725426216339e-21L, 0x5.256c4f857991ca680p-72L),
  /* x = 0.1484375 + 66/128.  */
  HEXCONSTE(7.87494932167606083928e-01L, 0xc.99944936cf48c8900p-4L),
  HEXCONSTE(3.81129927554490335537e-21L, 0x1.1ff93fe64b3ddb7a0p-68L),
  HEXCONSTE(6.16321127181550943027e-01L, 0x9.dc738ad14204e6900p-4L),
  HEXCONSTE(-2.14359628840834864704e-20L, -0x6.53a7d2f07a7d9a700p-68L),
  /* x = 0.1484375 + 67/128.  */
  HEXCONSTE(7.82655940026272796926e-01L, 0xc.85c23c26ed7b6f000p-4L),
  HEXCONSTE(4.43313368799061556772e-21L, 0x1.4ef546c4792968220p-68L),
  HEXCONSTE(6.22454560222343683019e-01L, 0x9.f592e9b66a9cf9000p-4L),
  HEXCONSTE(2.24964002091179940205e-20L, 0x6.a3c7aa3c101998480p-68L),
  /* x = 0.1484375 + 68/128.  */
  HEXCONSTE(7.77769178600317903128e-01L, 0xc.71be181ecd6875d00p-4L),
  HEXCONSTE(-6.17214357692608212760e-21L, -0x1.d25a9ea5fc335df80p-68L),
  HEXCONSTE(6.28550001845029662024e-01L, 0xa.0e8a725d33c828c00p-4L),
  HEXCONSTE(3.80694687403907782636e-21L, 0x1.1fa50fd9e9a15ffe0p-68L),
  /* x = 0.1484375 + 69/128.  */
  HEXCONSTE(7.72834946152471544785e-01L, 0xc.5d882d2ee48030c00p-4L),
  HEXCONSTE(2.62644919755593891600e-20L, 0x7.c07d28e981e348080p-68L),
  HEXCONSTE(6.34607080015269296833e-01L, 0xa.2759c0e79c3558200p-4L),
  HEXCONSTE(1.74669096626243469324e-20L, 0x5.27c32b55f5405c180p-68L),
  /* x = 0.1484375 + 70/128.  */
  HEXCONSTE(7.67853543842850365874e-01L, 0xc.4920cc2ec38fb8900p-4L),
  HEXCONSTE(5.76421614734988201699e-21L, 0x1.b38827db08884fc60p-68L),
  HEXCONSTE(6.40625425040230409197e-01L, 0xa.400072188acf49d00p-4L),
  HEXCONSTE(-8.74706174724155513741e-21L, -0x2.94e8c7da1fc7cb900p-68L),
  /* x = 0.1484375 + 71/128.  */
  HEXCONSTE(7.62825275710576250531e-01L, 0xc.348846bbd36313400p-4L),
  HEXCONSTE(-2.37184347301402901903e-20L, -0x7.001d401622ec7e600p-68L),
  HEXCONSTE(6.46604669591152370501e-01L, 0xa.587e23555bb080800p-4L),
  HEXCONSTE(2.30839024451270913358e-20L, 0x6.d02b9c662cdd29300p-68L),
  /* x = 0.1484375 + 72/128.  */
  HEXCONSTE(7.57750448655219342221e-01L, 0xc.1fbeef380e4ffdd00p-4L),
  HEXCONSTE(1.91386806954286619473e-20L, 0x5.a613ec8722f644000p-68L),
  HEXCONSTE(6.52544448725765956416e-01L, 0xa.70d272a76a8d4b700p-4L),
  HEXCONSTE(-8.03458291503629352382e-21L, -0x2.5f136f8ed448b7480p-68L),
  /* x = 0.1484375 + 73/128.  */
  HEXCONSTE(7.52629372418066476069e-01L, 0xc.0ac518c8b6ae71100p-4L),
  HEXCONSTE(-1.47770519487482145719e-20L, -0x4.5c85c1146f34ea500p-68L),
  HEXCONSTE(6.58444399910567541596e-01L, 0xa.88fcfebd9a8dd4800p-4L),
  HEXCONSTE(-6.15109781116215965199e-21L, -0x1.d0c3891061dbc66e0p-68L),
  /* x = 0.1484375 + 74/128.  */
  HEXCONSTE(7.47462359563216166645e-01L, 0xb.f59b17550a4406800p-4L),
  HEXCONSTE(2.49002644480447006263e-20L, 0x7.5969296567cf3e380p-68L),
  HEXCONSTE(6.64304163042946276506e-01L, 0xa.a0fd66eddb9212300p-4L),
  HEXCONSTE(9.35071476748618146730e-21L, 0x2.c28520d3911b8a040p-68L),
  /* x = 0.1484375 + 75/128.  */
  HEXCONSTE(7.42249725458501306971e-01L, 0xb.e0413f84f2a771c00p-4L),
  HEXCONSTE(2.06011614652293890323e-20L, 0x6.14946a88cbf4da200p-68L),
  HEXCONSTE(6.70123380473162894651e-01L, 0xa.b8d34b36acd987200p-4L),
  HEXCONSTE(3.58434240758437154368e-21L, 0x1.0ed343ec65d7e3ae0p-68L),
  /* x = 0.1484375 + 76/128.  */
  HEXCONSTE(7.36991788256240741074e-01L, 0xb.cab7e6bfb2a14aa00p-4L),
  HEXCONSTE(-1.67001385539296449908e-20L, -0x4.edd3a8b5c89413680p-68L),
  HEXCONSTE(6.75901697026178809209e-01L, 0xa.d07e4c409d08c5000p-4L),
  HEXCONSTE(-1.95537047830807972270e-20L, -0x5.c56fa844f53db4780p-68L),
  /* x = 0.1484375 + 77/128.  */
  HEXCONSTE(7.31688868873820886325e-01L, 0xb.b4ff632a908f73f00p-4L),
  HEXCONSTE(-1.32733420276494277786e-20L, -0x3.eae7c6346266c4b00p-68L),
  HEXCONSTE(6.81638760023334166756e-01L, 0xa.e7fe0b5fc786b2e00p-4L),
  HEXCONSTE(-2.23552881810015977960e-20L, -0x6.991e2950ebf5b7780p-68L),
  /* x = 0.1484375 + 78/128.  */
  HEXCONSTE(7.26341290974108590389e-01L, 0xb.9f180ba77dd075100p-4L),
  HEXCONSTE(2.08698293903315188673e-20L, 0x6.28e135a9508299000p-68L),
  HEXCONSTE(6.87334219303873534960e-01L, 0xa.ff522a954f2ba1700p-4L),
  HEXCONSTE(-8.07411717765665768906e-21L, -0x2.621023be91cc0a180p-68L),
  /* x = 0.1484375 + 79/128.  */
  HEXCONSTE(7.20949380945696418059e-01L, 0xb.890237d3bb3c28500p-4L),
  HEXCONSTE(-1.56530478693592385850e-20L, -0x4.9eb5fac6fe9405f00p-68L),
  HEXCONSTE(6.92987727246317910266e-01L, 0xb.167a4c90d63c42400p-4L),
  HEXCONSTE(1.62965218744645211416e-20L, 0x4.cf5493b7cc23bd400p-68L),
  /* x = 0.1484375 + 80/128.  */
  HEXCONSTE(7.15513467882981573503e-01L, 0xb.72be40067aaf2c000p-4L),
  HEXCONSTE(1.71225206672800459459e-20L, 0x5.0dbdb7a14c3d7d500p-68L),
  HEXCONSTE(6.98598938789681741309e-01L, 0xb.2d7614b1f3aaa2500p-4L),
  HEXCONSTE(-6.95044284595882773735e-21L, -0x2.0d291df5881e35c00p-68L),
  /* x = 0.1484375 + 81/128.  */
  HEXCONSTE(7.10033883566079674992e-01L, 0xb.5c4c7d4f7dae91600p-4L),
  HEXCONSTE(-1.76880786356028566544e-20L, -0x5.3879330b4e5b67300p-68L),
  HEXCONSTE(7.04167511454533672779e-01L, 0xb.44452709a59752900p-4L),
  HEXCONSTE(1.17891136558968995613e-21L, 0x5.913765434a59d1100p-72L),
  /* x = 0.1484375 + 82/128.  */
  HEXCONSTE(7.04510962440574606172e-01L, 0xb.45ad4975b1294cb00p-4L),
  HEXCONSTE(-7.48696923229974279863e-21L, -0x2.35b30bf1370dd5980p-68L),
  HEXCONSTE(7.09693105363899724941e-01L, 0xb.5ae7285bc10cf5100p-4L),
  HEXCONSTE(1.84920507060471729454e-20L, 0x5.753847e8f8b7a3100p-68L),
};

```

`tests/README.txt`:

```txt
This is a first version of a testsuite for fdlibm for 680x0.

Part of the data for the tests were orginally taken from an
older release of GLIBC, but many additional test cases for
corner-cases have been added.

The tests where originally designed to test emulator behaviour
of FPU instructions, and had already been verified by running them
on real hardware. However, since the FPU internally only uses long
doubles, and fdlibm currently only handles (64-bit) doubles, the
tests were adjusted.

Some failures have already been identified, and are currently skipped
to concentrate on any remaining issues and to prevent regressions.

Note that the constants involved in the tests are still defined as
long doubles, and are converted during the tests. This is not perfect,
and might change in a later release. For the same reason, the Coldfire
versions might not work yet at all, because the Coldfire has no long double
format.

```

`tests/acos.c`:

```c
#include "testconfig.h"
#define TEST_FUNC_F_F __MATH_PRECNAME(acos)
#include "testdriver.h"



static test_f_f_data const facos_data[] = {
	{ __LINE__, ZERO_P, HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, ZERO_M, HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, INF_P, QNAN_P, 0 },
	{ __LINE__, INF_M, QNAN_P, 0 },
	{ __LINE__, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_P, 0 },
	{ __LINE__, SNAN_P, QNAN_P, 0 },
	{ __LINE__, SNAN_M, QNAN_P, 0 },

	/* |x| > 1: */
	{ __LINE__, HEXCONSTE(1.125L, 0x3fff, 0x90000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__, HEXCONSTE(-1.125L, 0xbfff, 0x90000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__, MAX_P, QNAN_P, 0 },
	{ __LINE__, MAX_M, QNAN_P, 0 },
	
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(5.00000000000000000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.04719755119659774613e+00, 0x3fff, 0x860a91c1L, 0x6b9b2c23L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(2.09439510239319549227e+00, 0x4000, 0x860a91c1L, 0x6b9b2c23L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(7.50000000000000000000e-01, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(7.22734247813415611186e-01, 0x3ffe, 0xb9051c96L, 0x0ecaa422L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.00000013298644055914e-17, 0x3fc7, 0xb877ab00L, 0x00000000L), HEXCONSTE(1.57079632679489659920e+00, 0x3fff, 0xc90fdaa2L, 0x2168c167L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.99999996755031804853e-17, 0x3fc7, 0xb877aa00L, 0x00000000L), HEXCONSTE(1.57079632679489659920e+00, 0x3fff, 0xc90fdaa2L, 0x2168c167L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.00000000000000014308e-17, 0x3fc7, 0xb877aa32L, 0x36a4b800L), HEXCONSTE(1.57079632679489659920e+00, 0x3fff, 0xc90fdaa2L, 0x2168c167L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.99999999999999983494e-17, 0x3fc7, 0xb877aa32L, 0x36a4b000L), HEXCONSTE(1.57079632679489659920e+00, 0x3fff, 0xc90fdaa2L, 0x2168c167L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.00000000000000000014e-17, 0x3fc7, 0xb877aa32L, 0x36a4b44aL), HEXCONSTE(1.57079632679489659920e+00, 0x3fff, 0xc90fdaa2L, 0x2168c167L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.99999999999999999999e-17, 0x3fc7, 0xb877aa32L, 0x36a4b449L), HEXCONSTE(1.57079632679489659920e+00, 0x3fff, 0xc90fdaa2L, 0x2168c167L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(6.25000000000000000000e-02, 0x3ffb, 0x80000000L, 0x00000000L), HEXCONSTE(1.50825556499840522846e+00, 0x3fff, 0xc10e84b2L, 0xd6cdb595L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(3.45266984716203587610e-04, 0x3ff3, 0xb504f343L, 0x0f9d56c9L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(3.14124738660507703486e+00, 0x4000, 0xc90a327aL, 0x8750454aL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(3.45266984716203587610e-04, 0x3ff3, 0xb504f343L, 0x0f9d56c9L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(9.99999999883584678173e-01, 0x3ffe, 0xffffffffL, 0x80000000L), HEXCONSTE(1.52587890626480297361e-05, 0x3fef, 0x80000000L, 0x05555536L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(3.14124738660507703486e+00, 0x4000, 0xc90a327aL, 0x8750454aL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-9.99999999883584678173e-01, 0xbffe, 0xffffffffL, 0x80000000L), HEXCONSTE(3.14157739480073059041e+00, 0x4000, 0xc90f9aa2L, 0x2168bf8aL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(3.45266984716203587610e-04, 0x3ff3, 0xb504f343L, 0x0f9d56c9L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(9.99999999999996447286e-01, 0x3ffe, 0xffffffffL, 0xffff0000L), HEXCONSTE(8.42936970217880885293e-08, 0x3fe7, 0xb504f333L, 0xf9de7381L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(3.14124738660507703486e+00, 0x4000, 0xc90a327aL, 0x8750454aL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-9.99999999999996447286e-01, 0xbffe, 0xffffffffL, 0xffff0000L), HEXCONSTE(3.14159256929609621671e+00, 0x4000, 0xc90fda47L, 0x9eef2838L), 0 },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(3.45266984716203587610e-04, 0x3ff3, 0xb504f343L, 0x0f9d56c9L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.49011611938476563873e-08, 0x3fe5, 0x80000000L, 0x00000070L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(3.14124738660507703486e+00, 0x4000, 0xc90a327aL, 0x8750454aL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-9.99999999999999888978e-01, 0xbffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(3.14159263868863204467e+00, 0x4000, 0xc90fda92L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(3.45266984716203587610e-04, 0x3ff3, 0xb504f343L, 0x0f9d56c9L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.49011611938476563873e-08, 0x3fe5, 0x80000000L, 0x00000070L), FLAG_INEXACT2 },
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(3.29272253991359623327e-10, 0x3fdf, 0xb504f333L, 0xf9de6484L), FLAG_INEXACT },
#endif
	{ __LINE__, HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(3.14124738660507703486e+00, 0x4000, 0xc90a327aL, 0x8750454aL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-9.99999999999999888978e-01, 0xbffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(3.14159263868863204467e+00, 0x4000, 0xc90fda92L, 0x2168c235L), 0 },
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(-9.99999999999999999946e-01, 0xbffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(3.14159265326052098452e+00, 0x4000, 0xc90fdaa1L, 0xc6e6489bL), FLAG_INEXACT },
#endif
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(3.45266984716203587610e-04, 0x3ff3, 0xb504f343L, 0x0f9d56c9L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.49011611938476563873e-08, 0x3fe5, 0x80000000L, 0x00000070L), FLAG_INEXACT2 },
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(3.29272253991359623327e-10, 0x3fdf, 0xb504f333L, 0xf9de6484L), FLAG_INEXACT },
#endif
	{ __LINE__, HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(3.14124738660507703486e+00, 0x4000, 0xc90a327aL, 0x8750454aL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-9.99999999999999888978e-01, 0xbffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(3.14159263868863204467e+00, 0x4000, 0xc90fda92L, 0x2168c235L), 0 },
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(-9.99999999999999999946e-01, 0xbffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(3.14159265326052098452e+00, 0x4000, 0xc90fdaa1L, 0xc6e6489bL), FLAG_INEXACT },
#endif
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(3.45266984716203587610e-04, 0x3ff3, 0xb504f343L, 0x0f9d56c9L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.49011611938476563873e-08, 0x3fe5, 0x80000000L, 0x00000070L), FLAG_INEXACT2 },
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(3.29272253991359623327e-10, 0x3fdf, 0xb504f333L, 0xf9de6484L), FLAG_INEXACT },
#endif
	{ __LINE__, HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(3.14124738660507703486e+00, 0x4000, 0xc90a327aL, 0x8750454aL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-9.99999999999999888978e-01, 0xbffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(3.14159263868863204467e+00, 0x4000, 0xc90fda92L, 0x2168c235L), 0 },
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(-9.99999999999999999946e-01, 0xbffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(3.14159265326052098452e+00, 0x4000, 0xc90fdaa1L, 0xc6e6489bL), FLAG_INEXACT },
#endif
	{ __LINE__, HEXCONSTE(3.12500000000000000000e-02, 0x3ffa, 0x80000000L, 0x00000000L), HEXCONSTE(1.53954123829540146450e+00, 0x3fff, 0xc50faff2L, 0xa93a5012L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(9.76562500000000000000e-04, 0x3ff5, 0x80000000L, 0x00000000L), HEXCONSTE(1.56981976413967612351e+00, 0x3fff, 0xc8efdaa1L, 0xcc136a8bL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(3.05175781250000000000e-05, 0x3ff0, 0x80000000L, 0x00000000L), HEXCONSTE(1.57076580921676688227e+00, 0x3fff, 0xc90edaa2L, 0x2168177dL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(9.53674316406250000000e-07, 0x3feb, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079537312058021279e+00, 0x3fff, 0xc90fd2a2L, 0x2168c229L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.98023223876953125000e-08, 0x3fe6, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079629699257423156e+00, 0x3fff, 0xc90fda62L, 0x2168c229L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(9.31322574615478515625e-10, 0x3fe1, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632586357404464e+00, 0x3fff, 0xc90fdaa0L, 0x2168c229L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.91038304567337036133e-11, 0x3fdc, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632676579278880e+00, 0x3fff, 0xc90fdaa2L, 0x1168c227L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(9.09494701772928237915e-13, 0x3fd7, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679398712455e+00, 0x3fff, 0xc90fdaa2L, 0x20e8c228L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.84217094304040074348e-14, 0x3fd2, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679486819755e+00, 0x3fff, 0xc90fdaa2L, 0x2164c228L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(8.88178419700125232339e-16, 0x3fcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489573108e+00, 0x3fff, 0xc90fdaa2L, 0x2168a228L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.77555756156289135106e-17, 0x3fc8, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489659150e+00, 0x3fff, 0xc90fdaa2L, 0x2168c128L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(8.67361737988403547206e-19, 0x3fc3, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661839e+00, 0x3fff, 0xc90fdaa2L, 0x2168c228L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.71050543121376108502e-20, 0x3fbe, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c228L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(8.47032947254300339068e-22, 0x3fb9, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c228L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.64697796016968855959e-23, 0x3fb4, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c228L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(8.27180612553027674871e-25, 0x3faf, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c228L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.58493941422821148397e-26, 0x3faa, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c228L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(8.07793566946316088742e-28, 0x3fa5, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c228L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.52435489670723777732e-29, 0x3fa0, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c228L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(7.88860905221011805412e-31, 0x3f9b, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c228L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.46519032881566189191e-32, 0x3f96, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c228L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(7.70371977754894341222e-34, 0x3f91, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c228L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.40741243048404481632e-35, 0x3f8c, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c228L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(7.52316384526264005100e-37, 0x3f87, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c228L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-3.12500000000000000000e-02, 0xbffa, 0x80000000L, 0x00000000L), HEXCONSTE(1.60205141529439177390e+00, 0x3fff, 0xcd100551L, 0x9997344cL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-2.98023223876953125000e-08, 0xbfe6, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079635659721900695e+00, 0x3fff, 0xc90fdae2L, 0x2168c242L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-2.84217094304040074348e-14, 0xbfd2, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679492504097e+00, 0x3fff, 0xc90fdaa2L, 0x216cc241L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-2.71050543121376108502e-20, 0xbfbe, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c241L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-2.58493941422821148397e-26, 0xbfaa, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c241L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-2.46519032881566189191e-32, 0xbf96, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c241L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-2.35098870164457501594e-38, 0xbf82, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c241L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-1.25131264328956604004e-01, 0xbffc, 0x80226900L, 0x00000000L), HEXCONSTE(1.69625646107378745249e+00, 0x3fff, 0xd91eee84L, 0xf8660b85L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(9.38643336296081542969e-01, 0x3ffe, 0xf04aee00L, 0x00000000L), HEXCONSTE(3.52120935914171536487e-01, 0x3ffd, 0xb44931ffL, 0xf9ffa77dL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(3.66490870714187622070e-01, 0x3ffd, 0xbba4b100L, 0x00000000L), HEXCONSTE(1.19556166808888820129e+00, 0x3fff, 0x99082a2cL, 0x65806c2dL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(3.66490840911865234375e-01, 0x3ffd, 0xbba4b000L, 0x00000000L), HEXCONSTE(1.19556170011987360192e+00, 0x3fff, 0x99082a71L, 0x2eb8db7eL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(3.66490841000206013511e-01, 0x3ffd, 0xbba4b000L, 0xc2437000L), HEXCONSTE(1.19556170002492656546e+00, 0x3fff, 0x99082a70L, 0xfa863ffdL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-1.38168632984161376953e-01, 0xbffc, 0x8d7c1400L, 0x00000000L), HEXCONSTE(1.70940839961261982136e+00, 0x3fff, 0xdacde4f9L, 0xec04f45eL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-1.38168647885322570801e-01, 0xbffc, 0x8d7c1500L, 0x00000000L), HEXCONSTE(1.70940841465808634179e+00, 0x3fff, 0xdacde51aL, 0x3b5a1fb1L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-1.38168640071724857510e-01, 0xbffc, 0x8d7c1479L, 0xc36f1000L), HEXCONSTE(1.70940840676882044303e+00, 0x3fff, 0xdacde509L, 0x4a2ea7ffL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(9.12685453891754150391e-01, 0x3ffe, 0xe9a5c100L, 0x00000000L), HEXCONSTE(4.20988424568760853596e-01, 0x3ffd, 0xd78bcb77L, 0x08e77164L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(9.12685394287109375000e-01, 0x3ffe, 0xe9a5c000L, 0x00000000L), HEXCONSTE(4.20988570421622838196e-01, 0x3ffd, 0xd78bd05bL, 0xe6bd4db4L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(9.12685444573738013929e-01, 0x3ffe, 0xe9a5c0d7L, 0xfabba000L), HEXCONSTE(4.20988447369995780656e-01, 0x3ffd, 0xd78bcc3aL, 0xe5599544L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(9.12685444573737902907e-01, 0x3ffe, 0xe9a5c0d7L, 0xfabb9800L), HEXCONSTE(4.20988447369996052330e-01, 0x3ffd, 0xd78bcc3aL, 0xe559bc6bL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(9.12685444573737939390e-01, 0x3ffe, 0xe9a5c0d7L, 0xfabb9aa1L), HEXCONSTE(4.20988447369995963046e-01, 0x3ffd, 0xd78bcc3aL, 0xe559af8dL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(8.80692720413208007812e-01, 0x3ffe, 0xe1751400L, 0x00000000L), HEXCONSTE(4.93473710486068662485e-01, 0x3ffd, 0xfca8960fL, 0xf2665b4bL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(8.80692660808563232422e-01, 0x3ffe, 0xe1751300L, 0x00000000L), HEXCONSTE(4.93473836317072107378e-01, 0x3ffd, 0xfca89a48L, 0xd3b3e2a6L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(8.80692681441273439447e-01, 0x3ffe, 0xe1751358L, 0x9de7a000L), HEXCONSTE(4.93473792759486279066e-01, 0x3ffd, 0xfca898d2L, 0xab8ef8c0L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(8.80692681441273328424e-01, 0x3ffe, 0xe1751358L, 0x9de79800L), HEXCONSTE(4.93473792759486513444e-01, 0x3ffd, 0xfca898d2L, 0xab8f1aa6L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(8.80692681441273376400e-01, 0x3ffe, 0xe1751358L, 0x9de79b75L), HEXCONSTE(4.93473792759486412152e-01, 0x3ffd, 0xfca898d2L, 0xab8f0beeL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(2.43522778153419494629e-01, 0x3ffc, 0xf95e0900L, 0x00000000L), HEXCONSTE(1.32479999989484240129e+00, 0x3fff, 0xa9930be0L, 0xa502eb07L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.43522763252258300781e-01, 0x3ffc, 0xf95e0800L, 0x00000000L), HEXCONSTE(1.32480001525852447892e+00, 0x3fff, 0xa9930c01L, 0xa348f211L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.43522770053966747250e-01, 0x3ffc, 0xf95e0874L, 0xda3ae800L), HEXCONSTE(1.32480000824569610351e+00, 0x3fff, 0xa9930bf2L, 0x93f11800L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.27912998199462890625e-01, 0x3ffc, 0x82fba000L, 0x00000000L), HEXCONSTE(1.44253192196786039769e+00, 0x3fff, 0xb8a4e2d2L, 0x24dcac10L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-1.15723460912704467773e-01, 0xbffb, 0xed006c00L, 0x00000000L), HEXCONSTE(1.68677965000896504624e+00, 0x3fff, 0xd7e86544L, 0x2c64f523L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), FLAG_INEXACT2 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), FLAG_INEXACT2 },
#endif
	{ __LINE__, HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), FLAG_INEXACT2 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), FLAG_INEXACT2 },
#endif
	{ __LINE__, HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), FLAG_INEXACT2 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), FLAG_INEXACT2 },
#endif
	{ __LINE__, SUBNORM_P, HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM|FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), FLAG_INEXACT2 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), FLAG_INEXACT2 },
#endif
	{ __LINE__, SUBNORM_M, HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM|FLAG_INEXACT2 },
};

int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);

	status |= test_table_f_f(facos_data, ARRAY_SIZE(facos_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

```

`tests/acosh.c`:

```c
#include "testconfig.h"
#define TEST_FUNC_F_F __MATH_PRECNAME(acosh)
#include "testdriver.h"



static test_f_f_data const facosh_data[] = {
	{ __LINE__, ZERO_P, QNAN_P, 0 },
	{ __LINE__, ZERO_M, QNAN_P, 0 },
	{ __LINE__, INF_P, INF_P, FLAG_FAIL_ARANYM }, /* glibc returns NaN */
	{ __LINE__, INF_M, QNAN_P, 0 },
	{ __LINE__, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_P, 0 },
	{ __LINE__, SNAN_P, QNAN_P, 0 },
	{ __LINE__, SNAN_M, QNAN_P, 0 },

	/* x < 1:  */
	{ __LINE__, HEXCONSTE(0.75L, 0x3ffe, 0xc0000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__, MIN_P, QNAN_P, 0 },
	{ __LINE__, SUBNORM_P, QNAN_P, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, QNAN_P, FLAG_SUBNORM },
	{ __LINE__, MIN_M, QNAN_P, 0 },
	{ __LINE__, HEXCONSTE(-1.125L, 0xbfff, 0x90000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__, MAX_M, QNAN_P, 0 },

	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(4.88281245149361720661e-04, 0x3ff3, 0xffffffd5L, 0x55556889L), 0 },
	{ __LINE__, HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(4.88281245149361720661e-04, 0x3ff3, 0xffffffd5L, 0x55556889L), 0 },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(2.10734242554470155036e-08, 0x3fe5, 0xb504f333L, 0xf9de6393L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(4.88281245149361720661e-04, 0x3ff3, 0xffffffd5L, 0x55556889L), 0 },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(2.10734242554470155036e-08, 0x3fe5, 0xb504f333L, 0xf9de6393L), FLAG_INEXACT },
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(1.00000000000000000011e+00, 0x3fff, 0x80000000L, 0x00000001L), HEXCONSTE(4.65661287307739257812e-10, 0x3fe0, 0x80000000L, 0x00000000L), FLAG_INEXACT },
#endif
	{ __LINE__, HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(4.88281245149361720661e-04, 0x3ff3, 0xffffffd5L, 0x55556889L), 0 },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(2.10734242554470155036e-08, 0x3fe5, 0xb504f333L, 0xf9de6393L), FLAG_INEXACT },
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(1.00000000000000000011e+00, 0x3fff, 0x80000000L, 0x00000001L), HEXCONSTE(4.65661287307739257812e-10, 0x3fe0, 0x80000000L, 0x00000000L), FLAG_INEXACT },
#endif
	{ __LINE__, HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(4.88281245149361720661e-04, 0x3ff3, 0xffffffd5L, 0x55556889L), 0 },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(2.10734242554470155036e-08, 0x3fe5, 0xb504f333L, 0xf9de6393L), FLAG_INEXACT },
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(1.00000000000000000011e+00, 0x3fff, 0x80000000L, 0x00000001L), HEXCONSTE(4.65661287307739257812e-10, 0x3fe0, 0x80000000L, 0x00000000L), FLAG_INEXACT },
#endif
	{ __LINE__, HEXCONSTE(1.62500000000000000000e+00, 0x3fff, 0xd0000000L, 0x00000000L), HEXCONSTE(1.06673243190143557358e+00, 0x3fff, 0x888ab036L, 0x4cb301feL), 0 },
	{ __LINE__, HEXCONSTE(7.00000000000000000000e+00, 0x4001, 0xe0000000L, 0x00000000L), HEXCONSTE(2.63391579384963341721e+00, 0x4000, 0xa892138cL, 0xc021a4dfL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+02, 0x4005, 0xc8000000L, 0x00000000L), HEXCONSTE(5.29829236561048459069e+00, 0x4001, 0xa98b9c6eL, 0x5e313451L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+05, 0x400f, 0xc3500000L, 0x00000000L), HEXCONSTE(1.22060726455051737297e+01, 0x4002, 0xc34c12d4L, 0x90b800baL), 0 },
	{ __LINE__, HEXCONSTE(2.56000000000000000000e+02, 0x4007, 0x80000000L, 0x00000000L), HEXCONSTE(6.23832081032041410205e+00, 0x4001, 0xc7a052f6L, 0xc9096737L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(5.12000000000000000000e+02, 0x4008, 0x80000000L, 0x00000000L), HEXCONSTE(6.93147085192377244295e+00, 0x4001, 0xddce9bf5L, 0xc6135810L), 0 },
	{ __LINE__, HEXCONSTE(1.02400000000000000000e+03, 0x4009, 0x80000000L, 0x00000000L), HEXCONSTE(7.62461874774073403681e+00, 0x4001, 0xf3fce074L, 0xc07a474cL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.04800000000000000000e+03, 0x400a, 0x80000000L, 0x00000000L), HEXCONSTE(8.31776610711469360868e+00, 0x4002, 0x851591e9L, 0xdd5b8341L), 0 },
	{ __LINE__, HEXCONSTE(4.09600000000000000000e+03, 0x400b, 0x80000000L, 0x00000000L), HEXCONSTE(9.01091333237812749588e+00, 0x4002, 0x902cb375L, 0x5a78915cL), 0 },
	{ __LINE__, HEXCONSTE(8.19200000000000000000e+03, 0x400c, 0x80000000L, 0x00000000L), HEXCONSTE(9.70406052411394401229e+00, 0x4002, 0x9b43d4f7L, 0xd7958a5eL), 0 },
	{ __LINE__, HEXCONSTE(1.67772160000000000000e+07, 0x4017, 0x80000000L, 0x00000000L), HEXCONSTE(1.73286795139986318469e+01, 0x4003, 0x8aa122b9L, 0x9bea150eL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.35544320000000000000e+07, 0x4018, 0x80000000L, 0x00000000L), HEXCONSTE(1.80218266945585778235e+01, 0x4003, 0x902cb379L, 0x5a78925cL), 0 },
	{ __LINE__, HEXCONSTE(6.71088640000000000000e+07, 0x4019, 0x80000000L, 0x00000000L), HEXCONSTE(1.87149738751185232988e+01, 0x4003, 0x95b84439L, 0x19070e89L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.34217728000000000000e+08, 0x401a, 0x80000000L, 0x00000000L), HEXCONSTE(1.94081210556784686493e+01, 0x4003, 0x9b43d4f8L, 0xd7958a6eL), 0 },
	{ __LINE__, HEXCONSTE(2.68435456000000000000e+08, 0x401b, 0x80000000L, 0x00000000L), HEXCONSTE(2.01012682362384139702e+01, 0x4003, 0xa0cf65b8L, 0x96240642L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(5.36870912000000000000e+08, 0x401c, 0x80000000L, 0x00000000L), HEXCONSTE(2.07944154167983592824e+01, 0x4003, 0xa65af678L, 0x54b28211L), 0 },
	{ __LINE__, HEXCONSTE(1.07374182400000000000e+09, 0x401d, 0x80000000L, 0x00000000L), HEXCONSTE(2.14875625973583045912e+01, 0x4003, 0xabe68738L, 0x1340fddeL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.14748364800000000000e+09, 0x401e, 0x80000000L, 0x00000000L), HEXCONSTE(2.21807097779182499017e+01, 0x4003, 0xb17217f7L, 0xd1cf79acL), 0 },
	{ __LINE__, HEXCONSTE(4.29496729600000000000e+09, 0x401f, 0x80000000L, 0x00000000L), HEXCONSTE(2.28738569584781952105e+01, 0x4003, 0xb6fda8b7L, 0x905df579L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(8.58993459200000000000e+09, 0x4020, 0x80000000L, 0x00000000L), HEXCONSTE(2.35670041390381405210e+01, 0x4003, 0xbc893977L, 0x4eec7147L), 0 },
	{ __LINE__, HEXCONSTE(2.81474976710656000000e+14, 0x402f, 0x80000000L, 0x00000000L), HEXCONSTE(3.39642118474373201631e+01, 0x4004, 0x87db5a59L, 0xbca2d928L), 0 },
	{ __LINE__, HEXCONSTE(5.62949953421312000000e+14, 0x4030, 0x80000000L, 0x00000000L), HEXCONSTE(3.46573590279972654701e+01, 0x4004, 0x8aa122b9L, 0x9bea170eL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.12589990684262400000e+15, 0x4031, 0x80000000L, 0x00000000L), HEXCONSTE(3.53505062085572107806e+01, 0x4004, 0x8d66eb19L, 0x7b3154f5L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.25179981368524800000e+15, 0x4032, 0x80000000L, 0x00000000L), HEXCONSTE(3.60436533891171560912e+01, 0x4004, 0x902cb379L, 0x5a7892dcL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(4.50359962737049600000e+15, 0x4033, 0x80000000L, 0x00000000L), HEXCONSTE(3.67368005696771013982e+01, 0x4004, 0x92f27bd9L, 0x39bfd0c2L), 0 },
	{ __LINE__, HEXCONSTE(9.00719925474099200000e+15, 0x4034, 0x80000000L, 0x00000000L), HEXCONSTE(3.74299477502370467087e+01, 0x4004, 0x95b84439L, 0x19070ea9L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.80143985094819840000e+16, 0x4035, 0x80000000L, 0x00000000L), HEXCONSTE(3.81230949307969920192e+01, 0x4004, 0x987e0c98L, 0xf84e4c90L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.60287970189639680000e+16, 0x4036, 0x80000000L, 0x00000000L), HEXCONSTE(3.88162421113569373263e+01, 0x4004, 0x9b43d4f8L, 0xd7958a76L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(7.20575940379279360000e+16, 0x4037, 0x80000000L, 0x00000000L), HEXCONSTE(3.95093892919168826368e+01, 0x4004, 0x9e099d58L, 0xb6dcc85dL), 0 },
	{ __LINE__, HEXCONSTE(1.44115188075855872000e+17, 0x4038, 0x80000000L, 0x00000000L), HEXCONSTE(4.02025364724768279473e+01, 0x4004, 0xa0cf65b8L, 0x96240644L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.88230376151711744000e+17, 0x4039, 0x80000000L, 0x00000000L), HEXCONSTE(4.08956836530367732543e+01, 0x4004, 0xa3952e18L, 0x756b442aL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(5.76460752303423488000e+17, 0x403a, 0x80000000L, 0x00000000L), HEXCONSTE(4.15888308335967185649e+01, 0x4004, 0xa65af678L, 0x54b28211L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.26765060022822940150e+30, 0x4063, 0x80000000L, 0x00000000L), HEXCONSTE(7.00078652365544762542e+01, 0x4005, 0x8c0406e9L, 0x8b8db602L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(8.94159862326282983622e+01, 0x4005, 0xb2d4fc25L, 0xc173179fL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.27339060789614187001e+150, 0x41f3, 0x80000000L, 0x00000000L), HEXCONSTE(3.47266737460532600029e+02, 0x4007, 0xada22473L, 0xfecd848fL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(8.94159862326282983622e+01, 0x4005, 0xb2d4fc25L, 0xc173179fL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(7.10475860073943942030e+02, 0x4008, 0xb19e747dL, 0xcfc3ed88L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.41246703213942603684e+1505, 0x5387, 0x80000000L, 0x00000000L), HEXCONSTE(3.46642904998028649244e+03, 0x400a, 0xd8a6dd63L, 0x831ae0feL), 0 },
	{ __LINE__, HEXCONSTE(1.50249338150024414062e+00, 0x3fff, 0xc051b400L, 0x00000000L), HEXCONSTE(9.64650470073551659183e-01, 0x3ffe, 0xf6f3554dL, 0x097450e3L), 0 },
	{ __LINE__, HEXCONSTE(1.04536819458007812500e+00, 0x3fff, 0x85cea000L, 0x00000000L), HEXCONSTE(3.00097449950904218030e-01, 0x3ffd, 0x99a65f7aL, 0x4de409e7L), 0 },
	{ __LINE__, HEXCONSTE(1.04536807537078857422e+00, 0x3fff, 0x85ce9f00L, 0x00000000L), HEXCONSTE(3.00097058615722329271e-01, 0x3ffd, 0x99a65258L, 0xc2b99f4eL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.04536811256696071659e+00, 0x3fff, 0x85ce9f4fL, 0xe0cfd800L), HEXCONSTE(3.00097180721789482755e-01, 0x3ffd, 0x99a65671L, 0xa4ce7055L), 0 },
	{ __LINE__, HEXCONSTE(1.06998765468597412109e+00, 0x3fff, 0x88f55b00L, 0x00000000L), HEXCONSTE(3.71984349086711841079e-01, 0x3ffd, 0xbe74bb8bL, 0xe70d7e73L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.06249487400054931641e+00, 0x3fff, 0x87ffd500L, 0x00000000L), HEXCONSTE(3.51723112590137885661e-01, 0x3ffd, 0xb4150d43L, 0xa4d8ffbfL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.02560520172119140625e+00, 0x3fff, 0x83470800L, 0x00000000L), HEXCONSTE(2.25817052878548658456e-01, 0x3ffc, 0xe73c95e3L, 0xf849d514L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.02560508251190185547e+00, 0x3fff, 0x83470700L, 0x00000000L), HEXCONSTE(2.25816529435895013995e-01, 0x3ffc, 0xe73c72c3L, 0x4b26db49L), 0 },
	{ __LINE__, HEXCONSTE(1.02560512955856486528e+00, 0x3fff, 0x83470765L, 0x082d3000L), HEXCONSTE(2.25816736015833490663e-01, 0x3ffc, 0xe73c80a0L, 0x4f5457d0L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.55179643630981445312e+00, 0x4000, 0xa350a200L, 0x00000000L), HEXCONSTE(1.58913111734422241028e+00, 0x3fff, 0xcb68a601L, 0x0651e000L), 0 },
	{ __LINE__, HEXCONSTE(9.38031431680000000000e+10, 0x4023, 0xaeb8d300L, 0x00000000L), HEXCONSTE(2.59576113822108442974e+01, 0x4003, 0xcfa93028L, 0x06fbc400L), 0 },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(8.94159862326282983622e+01, 0x4005, 0xb2d4fc25L, 0xc173179fL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(6.36058900518228837402e+86, 0x411f, 0xa3b51e21L, 0xebf6f000L), HEXCONSTE(2.00565586161989500624e+02, 0x4006, 0xc890ca41L, 0x34d0a800L), 0 },
	{ __LINE__, HEXCONSTE(1.25187244415283203125e+01, 0x4002, 0xc84cb200L, 0x00000000L), HEXCONSTE(3.21877361141696921717e+00, 0x4000, 0xce006308L, 0x90e06106L), 0 },
	{ __LINE__, HEXCONSTE(1.25187234878540039062e+01, 0x4002, 0xc84cb100L, 0x00000000L), HEXCONSTE(3.21877353499291883349e+00, 0x4000, 0xce0062b6L, 0x8197edb4L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.25187243064444295726e+01, 0x4002, 0xc84cb1dbL, 0xbd1b1000L), HEXCONSTE(3.21877360059182948682e+00, 0x4000, 0xce0062fcL, 0xf148e400L), 0 },
	{ __LINE__, HEXCONSTE(1.02786588668823242188e+00, 0x3fff, 0x83911c00L, 0x00000000L), HEXCONSTE(2.35530982721737767877e-01, 0x3ffc, 0xf12f08afL, 0xf03c3c5dL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.02786576747894287109e+00, 0x3fff, 0x83911b00L, 0x00000000L), HEXCONSTE(2.35530481240692454633e-01, 0x3ffc, 0xf12ee708L, 0x8f4608c6L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.02786577775871390550e+00, 0x3fff, 0x83911b16L, 0x135d2800L), HEXCONSTE(2.35530524484935000647e-01, 0x3ffc, 0xf12ee9efL, 0x7d76b035L), 0 },
	{ __LINE__, HEXCONSTE(1.45045948028564453125e+00, 0x3fff, 0xb9a8a800L, 0x00000000L), HEXCONSTE(9.16728199990045994404e-01, 0x3ffe, 0xeaaeb306L, 0x4737caceL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.10747337341308593750e+00, 0x3fff, 0x8dc1b000L, 0x00000000L), HEXCONSTE(4.59568541107771539093e-01, 0x3ffd, 0xeb4c915cL, 0xa8184c0cL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.03041589260101318359e+00, 0x3fff, 0x83e4ab00L, 0x00000000L), HEXCONSTE(2.46020094112509415805e-01, 0x3ffc, 0xfbecb109L, 0x7cfff0c2L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.09388625621795654297e+00, 0x3fff, 0x8c047700L, 0x00000000L), HEXCONSTE(4.30006646886303414582e-01, 0x3ffd, 0xdc29d4caL, 0xe0eb1062L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.06376290321350097656e+00, 0x3fff, 0x88296200L, 0x00000000L), HEXCONSTE(3.55236755318221097608e-01, 0x3ffd, 0xb5e1978cL, 0xdb9a9326L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(8.94159862326282983622e+01, 0x4005, 0xb2d4fc25L, 0xc173179fL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(7.10475860073943942030e+02, 0x4008, 0xb19e747dL, 0xcfc3ed88L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.13572165534747038951e+04, 0x400c, 0xb174ddc0L, 0x31aec0eaL), 0 },
};

int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_f_f(facosh_data, ARRAY_SIZE(facosh_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

```

`tests/asin.c`:

```c
#include "testconfig.h"
#define TEST_FUNC_F_F __MATH_PRECNAME(asin)
#include "testdriver.h"



static test_f_f_data const fasin_data[] = {
	{ __LINE__, ZERO_P, ZERO_P, 0 },
	{ __LINE__, ZERO_M, ZERO_M, FLAG_FAIL_ARANYM2 }, /* sometimes fails on ARAnyM, returning +0 ??? */
	{ __LINE__, INF_P, QNAN_P, 0 },
	{ __LINE__, INF_M, QNAN_P, 0 },
	{ __LINE__, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_P, 0 },
	{ __LINE__, SNAN_P, QNAN_P, 0 },
	{ __LINE__, SNAN_M, QNAN_P, 0 },

	/* asin x == qNaN plus invalid exception for |x| > 1.  */
	{ __LINE__, HEXCONSTE(1.125L, 0x3fff, 0x90000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__, HEXCONSTE(-1.125L, 0xbfff, 0x90000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__, MAX_P, QNAN_P, 0 },
	{ __LINE__, MAX_M, QNAN_P, 0 },

	{ __LINE__, HEXCONSTE(5.00000000000000000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(5.23598775598298873067e-01, 0x3ffe, 0x860a91c1L, 0x6b9b2c43L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(-5.23598775598298873067e-01, 0xbffe, 0x860a91c1L, 0x6b9b2c43L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(7.50000000000000000000e-01, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(8.48062078981481008071e-01, 0x3ffe, 0xd91a98aeL, 0x3406e041L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(1.57045105981018041561e+00, 0x3fff, 0xc9048a52L, 0xed37c85fL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.57045105981018041561e+00, 0xbfff, 0xc9048a52L, 0xed37c85fL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(1.57045105981018041561e+00, 0x3fff, 0xc9048a52L, 0xed37c85fL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.99999999883584678173e-01, 0x3ffe, 0xffffffffL, 0x80000000L), HEXCONSTE(1.57078106800583397115e+00, 0x3fff, 0xc90f5aa2L, 0x2168bcdfL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.57045105981018041561e+00, 0xbfff, 0xc9048a52L, 0xed37c85fL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-9.99999999883584678173e-01, 0xbffe, 0xffffffffL, 0x80000000L), HEXCONSTE(-1.57078106800583397115e+00, 0xbfff, 0xc90f5aa2L, 0x2168bcdfL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(1.57045105981018041561e+00, 0x3fff, 0xc9048a52L, 0xed37c85fL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.99999999999996447286e-01, 0x3ffe, 0xffffffffL, 0xffff0000L), HEXCONSTE(1.57079624250119959745e+00, 0x3fff, 0xc90fd9edL, 0x1c758e3bL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.57045105981018041561e+00, 0xbfff, 0xc9048a52L, 0xed37c85fL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-9.99999999999996447286e-01, 0xbffe, 0xffffffffL, 0xffff0000L), HEXCONSTE(-1.57079624250119959745e+00, 0xbfff, 0xc90fd9edL, 0x1c758e3bL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(1.57045105981018041561e+00, 0x3fff, 0xc9048a52L, 0xed37c85fL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.57079631189373542541e+00, 0x3fff, 0xc90fda82L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.57045105981018041561e+00, 0xbfff, 0xc9048a52L, 0xed37c85fL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-9.99999999999999888978e-01, 0xbffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.57079631189373542541e+00, 0xbfff, 0xc90fda82L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(1.57045105981018041561e+00, 0x3fff, 0xc9048a52L, 0xed37c85fL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.57079631189373542541e+00, 0x3fff, 0xc90fda82L, 0x2168c235L), 0 },
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.57079632646562436526e+00, 0x3fff, 0xc90fdaa1L, 0x6c63cf01L), FLAG_INEXACT },
#endif
	{ __LINE__, HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.57045105981018041561e+00, 0xbfff, 0xc9048a52L, 0xed37c85fL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-9.99999999999999888978e-01, 0xbffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.57079631189373542541e+00, 0xbfff, 0xc90fda82L, 0x2168c235L), 0 },
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(-9.99999999999999999946e-01, 0xbffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-1.57079632646562436526e+00, 0xbfff, 0xc90fdaa1L, 0x6c63cf01L), FLAG_INEXACT },
#endif
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(1.57045105981018041561e+00, 0x3fff, 0xc9048a52L, 0xed37c85fL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.57079631189373542541e+00, 0x3fff, 0xc90fda82L, 0x2168c235L), 0 },
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.57079632646562436526e+00, 0x3fff, 0xc90fdaa1L, 0x6c63cf01L), FLAG_INEXACT },
#endif
	{ __LINE__, HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.57045105981018041561e+00, 0xbfff, 0xc9048a52L, 0xed37c85fL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-9.99999999999999888978e-01, 0xbffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.57079631189373542541e+00, 0xbfff, 0xc90fda82L, 0x2168c235L), 0 },
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(-9.99999999999999999946e-01, 0xbffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-1.57079632646562436526e+00, 0xbfff, 0xc90fdaa1L, 0x6c63cf01L), FLAG_INEXACT },
#endif
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(1.57045105981018041561e+00, 0x3fff, 0xc9048a52L, 0xed37c85fL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.57079631189373542541e+00, 0x3fff, 0xc90fda82L, 0x2168c235L), 0 },
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.57079632646562436526e+00, 0x3fff, 0xc90fdaa1L, 0x6c63cf01L), FLAG_INEXACT },
#endif
	{ __LINE__, HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.57045105981018041561e+00, 0xbfff, 0xc9048a52L, 0xed37c85fL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-9.99999999999999888978e-01, 0xbffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.57079631189373542541e+00, 0xbfff, 0xc90fda82L, 0x2168c235L), 0 },
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(-9.99999999999999999946e-01, 0xbffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-1.57079632646562436526e+00, 0xbfff, 0xc90fdaa1L, 0x6c63cf01L), FLAG_INEXACT },
#endif
	{ __LINE__, HEXCONSTE(3.12500000000000000000e-02, 0x3ffa, 0x80000000L, 0x00000000L), HEXCONSTE(3.12550884994951546827e-02, 0x3ffa, 0x800555efL, 0x05ce40ebL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(9.76562500000000000000e-04, 0x3ff5, 0x80000000L, 0x00000000L), HEXCONSTE(9.76562655220495715968e-04, 0x3ff5, 0x80000155L, 0x555eeed7L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(3.05175781250000000000e-05, 0x3ff0, 0x80000000L, 0x00000000L), HEXCONSTE(3.05175781297369515739e-05, 0x3ff0, 0x80000000L, 0x55555556L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(9.53674316406250000000e-07, 0x3feb, 0x80000000L, 0x00000000L), HEXCONSTE(9.53674316406394560255e-07, 0x3feb, 0x80000000L, 0x00155555L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.98023223876953125000e-08, 0x3fe6, 0x80000000L, 0x00000000L), HEXCONSTE(2.98023223876953169106e-08, 0x3fe6, 0x80000000L, 0x00000574L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(9.31322574615478515625e-10, 0x3fe1, 0x80000000L, 0x00000000L), HEXCONSTE(9.31322574615478515726e-10, 0x3fe1, 0x80000000L, 0x00000001L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(2.91038304567337036133e-11, 0x3fdc, 0x80000000L, 0x00000000L), HEXCONSTE(2.91038304567337036133e-11, 0x3fdc, 0x80000000L, 0x00000000L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.09494701772928237915e-13, 0x3fd7, 0x80000000L, 0x00000000L), HEXCONSTE(9.09494701772928237915e-13, 0x3fd7, 0x80000000L, 0x00000000L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.84217094304040074348e-14, 0x3fd2, 0x80000000L, 0x00000000L), HEXCONSTE(2.84217094304040074348e-14, 0x3fd2, 0x80000000L, 0x00000000L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(8.88178419700125232339e-16, 0x3fcd, 0x80000000L, 0x00000000L), HEXCONSTE(8.88178419700125232339e-16, 0x3fcd, 0x80000000L, 0x00000000L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.77555756156289135106e-17, 0x3fc8, 0x80000000L, 0x00000000L), HEXCONSTE(2.77555756156289135106e-17, 0x3fc8, 0x80000000L, 0x00000000L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(8.67361737988403547206e-19, 0x3fc3, 0x80000000L, 0x00000000L), HEXCONSTE(8.67361737988403547206e-19, 0x3fc3, 0x80000000L, 0x00000000L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(7.88860905221011805412e-31, 0x3f9b, 0x80000000L, 0x00000000L), HEXCONSTE(7.88860905221011805412e-31, 0x3f9b, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.40991986510288411774e-181, 0x3da7, 0x80000000L, 0x00000000L), HEXCONSTE(2.40991986510288411774e-181, 0x3da7, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(5.01237274920645200930e-3011, 0x18ef, 0x80000000L, 0x00000000L), HEXCONSTE(5.01237274920645200930e-3011, 0x18ef, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.30998000502586364746e-01, 0xbffc, 0x86245700L, 0x00000000L), HEXCONSTE(-1.31375588323176431131e-01, 0xbffc, 0x8687527dL, 0x5cfb43e2L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-2.15918973088264465332e-01, 0xbffc, 0xdd19dd00L, 0x00000000L), HEXCONSTE(-2.17632906237299750060e-01, 0xbffc, 0xdedb291bL, 0x4a614ff1L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-1.94416821002960205078e-01, 0xbffc, 0xc7153400L, 0x00000000L), HEXCONSTE(-1.95662892009592907471e-01, 0xbffc, 0xc85bda68L, 0xe34f0dd9L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-1.94416835904121398926e-01, 0xbffc, 0xc7153500L, 0x00000000L), HEXCONSTE(-1.95662907200613877569e-01, 0xbffc, 0xc85bdb6dL, 0xde202640L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-1.94416824937236276671e-01, 0xbffc, 0xc7153443L, 0x97211000L), HEXCONSTE(-1.95662896020399143431e-01, 0xbffc, 0xc85bdaadL, 0xcb056bf9L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(9.86670851707458496094e-01, 0x3ffe, 0xfc967600L, 0x00000000L), HEXCONSTE(1.40734073632082449352e+00, 0x3fff, 0xb423bdc2L, 0x69cac53dL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(9.86670792102813720703e-01, 0x3ffe, 0xfc967500L, 0x00000000L), HEXCONSTE(1.40734037003892137828e+00, 0x3fff, 0xb423baafL, 0xd42fb22eL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(9.86670850412247890660e-01, 0x3ffe, 0xfc9675faL, 0x6fe6a000L), HEXCONSTE(1.40734072836149980265e+00, 0x3fff, 0xb423bdb1L, 0x521b678bL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(9.86670850412247779637e-01, 0x3ffe, 0xfc9675faL, 0x6fe69800L), HEXCONSTE(1.40734072836149912047e+00, 0x3fff, 0xb423bdb1L, 0x521b4ef7L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(9.86670850412247877757e-01, 0x3ffe, 0xfc9675faL, 0x6fe69f12L), HEXCONSTE(1.40734072836149972340e+00, 0x3fff, 0xb423bdb1L, 0x521b64b0L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-6.86610162258148193359e-01, 0xbffe, 0xafc5af00L, 0x00000000L), HEXCONSTE(-7.56816114434122518386e-01, 0xbffe, 0xc1beb36cL, 0x9491cd54L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(8.43839943408966064453e-01, 0x3ffe, 0xd805e500L, 0x00000000L), HEXCONSTE(1.00439959289967151168e+00, 0x3fff, 0x80902a75L, 0xcf55b400L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-1.31350383162498474121e-01, 0xbffc, 0x8680b700L, 0x00000000L), HEXCONSTE(-1.31731042344104071207e-01, 0xbffc, 0x86e4809aL, 0xf1948800L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-5.06853103637695312500e-01, 0xbffe, 0x81c12000L, 0x00000000L), HEXCONSTE(-5.31530301417143665149e-01, 0xbffe, 0x88125eadL, 0x6b6e7a1eL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-5.06853163242340087891e-01, 0xbffe, 0x81c12100L, 0x00000000L), HEXCONSTE(-5.31530370561462454113e-01, 0xbffe, 0x88125fd6L, 0x6469ff71L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-5.06853143741215150797e-01, 0xbffe, 0x81c120acL, 0x3e495000L), HEXCONSTE(-5.31530347939198318202e-01, 0xbffe, 0x88125f75L, 0x3af8ba1eL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.00892210006713867188e-01, 0xbffe, 0xb36dac00L, 0x00000000L), HEXCONSTE(-7.76647606752559711060e-01, 0xbffe, 0xc6d260a7L, 0x84d776d8L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), FLAG_INEXACT },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), 0 },
#endif
	{ __LINE__, HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), FLAG_INEXACT },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), 0 },
#endif
};

int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_f_f(fasin_data, ARRAY_SIZE(fasin_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

```

`tests/asinh.c`:

```c
#include "testconfig.h"
#define TEST_FUNC_F_F __MATH_PRECNAME(asinh)
#include "testdriver.h"



static test_f_f_data const fasinh_data[] = {
	{ __LINE__, ZERO_P, ZERO_P, 0 },
	{ __LINE__, ZERO_M, ZERO_M, FLAG_FAIL_ARANYM2 }, /* sometimes fails on ARAnyM, returning +0 ??? */
	{ __LINE__, INF_P, INF_P, FLAG_FAIL_ARANYM2 }, /* sometimes fails on ARAnyM, returning -NaN ??? */
	{ __LINE__, INF_M, INF_M, FLAG_FAIL_ARANYM2 }, /* sometimes fails on ARAnyM, returning -NaN ??? */
	{ __LINE__, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_P, 0 },
	{ __LINE__, SNAN_P, QNAN_P, 0 },
	{ __LINE__, SNAN_M, QNAN_P, 0 },

	{ __LINE__, HEXCONSTE(7.50000000000000000000e-01, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(6.93147180559945309429e-01, 0x3ffe, 0xb17217f7L, 0xd1cf79acL), 0 },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(8.81373587019543025241e-01, 0x3ffe, 0xe1a1b30bL, 0xcea13661L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+01, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(2.99822295029796973887e+00, 0x4000, 0xbfe2e283L, 0x695ed6a9L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+02, 0x4005, 0xc8000000L, 0x00000000L), HEXCONSTE(5.29834236561058875749e+00, 0x4001, 0xa98c0549L, 0xe9e14f9eL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+06, 0x4012, 0xf4240000L, 0x00000000L), HEXCONSTE(1.45086577385244694131e+01, 0x4002, 0xe823764bL, 0xfd1e5fa3L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.56000000000000000000e+02, 0x4007, 0x80000000L, 0x00000000L), HEXCONSTE(6.23832843971494572198e+00, 0x4001, 0xc7a062f6L, 0xc9096a8cL), 0 },
	{ __LINE__, HEXCONSTE(5.12000000000000000000e+02, 0x4008, 0x80000000L, 0x00000000L), HEXCONSTE(6.93147275927240526109e+00, 0x4001, 0xddce9ff5L, 0xc613581dL), 0 },
	{ __LINE__, HEXCONSTE(1.02400000000000000000e+03, 0x4009, 0x80000000L, 0x00000000L), HEXCONSTE(7.62461922457789223993e+00, 0x4001, 0xf3fce174L, 0xc07a474cL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.04800000000000000000e+03, 0x400a, 0x80000000L, 0x00000000L), HEXCONSTE(8.31776622632398315946e+00, 0x4002, 0x85159209L, 0xdd5b8341L), 0 },
	{ __LINE__, HEXCONSTE(4.09600000000000000000e+03, 0x400b, 0x80000000L, 0x00000000L), HEXCONSTE(9.01091336218044988357e+00, 0x4002, 0x902cb37dL, 0x5a78915cL), 0 },
	{ __LINE__, HEXCONSTE(8.19200000000000000000e+03, 0x400c, 0x80000000L, 0x00000000L), HEXCONSTE(9.70406053156452460921e+00, 0x4002, 0x9b43d4f9L, 0xd7958a5eL), 0 },
	{ __LINE__, HEXCONSTE(1.67772160000000000000e+07, 0x4017, 0x80000000L, 0x00000000L), HEXCONSTE(1.73286795139986336232e+01, 0x4003, 0x8aa122b9L, 0x9bea190eL), 0 },
	{ __LINE__, HEXCONSTE(3.35544320000000000000e+07, 0x4018, 0x80000000L, 0x00000000L), HEXCONSTE(1.80218266945585782676e+01, 0x4003, 0x902cb379L, 0x5a78935cL), 0 },
	{ __LINE__, HEXCONSTE(6.71088640000000000000e+07, 0x4019, 0x80000000L, 0x00000000L), HEXCONSTE(1.87149738751185234099e+01, 0x4003, 0x95b84439L, 0x19070ec9L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.34217728000000000000e+08, 0x401a, 0x80000000L, 0x00000000L), HEXCONSTE(1.94081210556784686770e+01, 0x4003, 0x9b43d4f8L, 0xd7958a7eL), 0 },
	{ __LINE__, HEXCONSTE(2.68435456000000000000e+08, 0x401b, 0x80000000L, 0x00000000L), HEXCONSTE(2.01012682362384139771e+01, 0x4003, 0xa0cf65b8L, 0x96240646L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(5.36870912000000000000e+08, 0x401c, 0x80000000L, 0x00000000L), HEXCONSTE(2.07944154167983592842e+01, 0x4003, 0xa65af678L, 0x54b28212L), 0 },
	{ __LINE__, HEXCONSTE(1.07374182400000000000e+09, 0x401d, 0x80000000L, 0x00000000L), HEXCONSTE(2.14875625973583045929e+01, 0x4003, 0xabe68738L, 0x1340fddfL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.14748364800000000000e+09, 0x401e, 0x80000000L, 0x00000000L), HEXCONSTE(2.21807097779182499017e+01, 0x4003, 0xb17217f7L, 0xd1cf79acL), 0 },
	{ __LINE__, HEXCONSTE(4.29496729600000000000e+09, 0x401f, 0x80000000L, 0x00000000L), HEXCONSTE(2.28738569584781952105e+01, 0x4003, 0xb6fda8b7L, 0x905df579L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(8.58993459200000000000e+09, 0x4020, 0x80000000L, 0x00000000L), HEXCONSTE(2.35670041390381405210e+01, 0x4003, 0xbc893977L, 0x4eec7147L), 0 },
	{ __LINE__, HEXCONSTE(2.81474976710656000000e+14, 0x402f, 0x80000000L, 0x00000000L), HEXCONSTE(3.39642118474373201631e+01, 0x4004, 0x87db5a59L, 0xbca2d928L), 0 },
	{ __LINE__, HEXCONSTE(5.62949953421312000000e+14, 0x4030, 0x80000000L, 0x00000000L), HEXCONSTE(3.46573590279972654701e+01, 0x4004, 0x8aa122b9L, 0x9bea170eL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.12589990684262400000e+15, 0x4031, 0x80000000L, 0x00000000L), HEXCONSTE(3.53505062085572107806e+01, 0x4004, 0x8d66eb19L, 0x7b3154f5L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.25179981368524800000e+15, 0x4032, 0x80000000L, 0x00000000L), HEXCONSTE(3.60436533891171560912e+01, 0x4004, 0x902cb379L, 0x5a7892dcL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(4.50359962737049600000e+15, 0x4033, 0x80000000L, 0x00000000L), HEXCONSTE(3.67368005696771013982e+01, 0x4004, 0x92f27bd9L, 0x39bfd0c2L), 0 },
	{ __LINE__, HEXCONSTE(9.00719925474099200000e+15, 0x4034, 0x80000000L, 0x00000000L), HEXCONSTE(3.74299477502370467087e+01, 0x4004, 0x95b84439L, 0x19070ea9L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.80143985094819840000e+16, 0x4035, 0x80000000L, 0x00000000L), HEXCONSTE(3.81230949307969920192e+01, 0x4004, 0x987e0c98L, 0xf84e4c90L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.60287970189639680000e+16, 0x4036, 0x80000000L, 0x00000000L), HEXCONSTE(3.88162421113569373263e+01, 0x4004, 0x9b43d4f8L, 0xd7958a76L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(7.20575940379279360000e+16, 0x4037, 0x80000000L, 0x00000000L), HEXCONSTE(3.95093892919168826368e+01, 0x4004, 0x9e099d58L, 0xb6dcc85dL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.44115188075855872000e+17, 0x4038, 0x80000000L, 0x00000000L), HEXCONSTE(4.02025364724768279473e+01, 0x4004, 0xa0cf65b8L, 0x96240644L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.88230376151711744000e+17, 0x4039, 0x80000000L, 0x00000000L), HEXCONSTE(4.08956836530367732543e+01, 0x4004, 0xa3952e18L, 0x756b442aL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(5.76460752303423488000e+17, 0x403a, 0x80000000L, 0x00000000L), HEXCONSTE(4.15888308335967185649e+01, 0x4004, 0xa65af678L, 0x54b28211L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.26765060022822940150e+30, 0x4063, 0x80000000L, 0x00000000L), HEXCONSTE(7.00078652365544762542e+01, 0x4005, 0x8c0406e9L, 0x8b8db602L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(8.94159862326282983622e+01, 0x4005, 0xb2d4fc25L, 0xc173179fL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.27339060789614187001e+150, 0x41f3, 0x80000000L, 0x00000000L), HEXCONSTE(3.47266737460532600029e+02, 0x4007, 0xada22473L, 0xfecd848fL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(8.94159862326282983622e+01, 0x4005, 0xb2d4fc25L, 0xc173179fL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(7.10475860073943942030e+02, 0x4008, 0xb19e747dL, 0xcfc3ed88L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.41246703213942603684e+1505, 0x5387, 0x80000000L, 0x00000000L), HEXCONSTE(3.46642904998028649244e+03, 0x400a, 0xd8a6dd63L, 0x831ae0feL), 0 },
	{ __LINE__, HEXCONSTE(3.90625000000000000000e-03, 0x3ff7, 0x80000000L, 0x00000000L), HEXCONSTE(3.90624006596074891802e-03, 0x3ff6, 0xffffd555L, 0x68887d1bL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.95312500000000000000e-03, 0x3ff6, 0x80000000L, 0x00000000L), HEXCONSTE(1.95312375823869880275e-03, 0x3ff5, 0xfffff555L, 0x5688885bL), 0 },
	{ __LINE__, HEXCONSTE(9.76562500000000000000e-04, 0x3ff5, 0x80000000L, 0x00000000L), HEXCONSTE(9.76562344779637510773e-04, 0x3ff4, 0xfffffd55L, 0x55688888L), 0 },
	{ __LINE__, HEXCONSTE(4.88281250000000000000e-04, 0x3ff4, 0x80000000L, 0x00000000L), HEXCONSTE(4.88281230597448443858e-04, 0x3ff3, 0xffffff55L, 0x55568889L), 0 },
	{ __LINE__, HEXCONSTE(2.44140625000000000000e-04, 0x3ff3, 0x80000000L, 0x00000000L), HEXCONSTE(2.44140622574680860330e-04, 0x3ff2, 0xffffffd5L, 0x55556889L), 0 },
	{ __LINE__, HEXCONSTE(1.22070312500000000000e-04, 0x3ff2, 0x80000000L, 0x00000000L), HEXCONSTE(1.22070312196835101445e-04, 0x3ff1, 0xfffffff5L, 0x55555689L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(5.96046447753906250000e-08, 0x3fe7, 0x80000000L, 0x00000000L), HEXCONSTE(5.96046447753905897059e-08, 0x3fe6, 0xffffffffL, 0xffffd555L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.98023223876953125000e-08, 0x3fe6, 0x80000000L, 0x00000000L), HEXCONSTE(2.98023223876953080878e-08, 0x3fe5, 0xffffffffL, 0xfffff555L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.49011611938476562500e-08, 0x3fe5, 0x80000000L, 0x00000000L), HEXCONSTE(1.49011611938476556983e-08, 0x3fe4, 0xffffffffL, 0xfffffd55L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(7.45058059692382812500e-09, 0x3fe4, 0x80000000L, 0x00000000L), HEXCONSTE(7.45058059692382805593e-09, 0x3fe3, 0xffffffffL, 0xffffff55L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.72529029846191406250e-09, 0x3fe3, 0x80000000L, 0x00000000L), HEXCONSTE(3.72529029846191405382e-09, 0x3fe2, 0xffffffffL, 0xffffffd5L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.86264514923095703125e-09, 0x3fe2, 0x80000000L, 0x00000000L), HEXCONSTE(1.86264514923095703014e-09, 0x3fe1, 0xffffffffL, 0xfffffff5L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.31322574615478515625e-10, 0x3fe1, 0x80000000L, 0x00000000L), HEXCONSTE(9.31322574615478515474e-10, 0x3fe0, 0xffffffffL, 0xfffffffdL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(4.65661287307739257812e-10, 0x3fe0, 0x80000000L, 0x00000000L), HEXCONSTE(4.65661287307739257787e-10, 0x3fdf, 0xffffffffL, 0xffffffffL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.32830643653869628906e-10, 0x3fdf, 0x80000000L, 0x00000000L), HEXCONSTE(2.32830643653869628906e-10, 0x3fdf, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.16415321826934814453e-10, 0x3fde, 0x80000000L, 0x00000000L), HEXCONSTE(1.16415321826934814453e-10, 0x3fde, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.55271367880050092936e-15, 0x3fcf, 0x80000000L, 0x00000000L), HEXCONSTE(3.55271367880050092936e-15, 0x3fcf, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.77635683940025046468e-15, 0x3fce, 0x80000000L, 0x00000000L), HEXCONSTE(1.77635683940025046468e-15, 0x3fce, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(8.88178419700125232339e-16, 0x3fcd, 0x80000000L, 0x00000000L), HEXCONSTE(8.88178419700125232339e-16, 0x3fcd, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.44089209850062616169e-16, 0x3fcc, 0x80000000L, 0x00000000L), HEXCONSTE(4.44089209850062616169e-16, 0x3fcc, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.22044604925031308085e-16, 0x3fcb, 0x80000000L, 0x00000000L), HEXCONSTE(2.22044604925031308085e-16, 0x3fcb, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.11022302462515654042e-16, 0x3fca, 0x80000000L, 0x00000000L), HEXCONSTE(1.11022302462515654042e-16, 0x3fca, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(5.55111512312578270212e-17, 0x3fc9, 0x80000000L, 0x00000000L), HEXCONSTE(5.55111512312578270212e-17, 0x3fc9, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.77555756156289135106e-17, 0x3fc8, 0x80000000L, 0x00000000L), HEXCONSTE(2.77555756156289135106e-17, 0x3fc8, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.38777878078144567553e-17, 0x3fc7, 0x80000000L, 0x00000000L), HEXCONSTE(1.38777878078144567553e-17, 0x3fc7, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(6.93889390390722837765e-18, 0x3fc6, 0x80000000L, 0x00000000L), HEXCONSTE(6.93889390390722837765e-18, 0x3fc6, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.46944695195361418882e-18, 0x3fc5, 0x80000000L, 0x00000000L), HEXCONSTE(3.46944695195361418882e-18, 0x3fc5, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.73472347597680709441e-18, 0x3fc4, 0x80000000L, 0x00000000L), HEXCONSTE(1.73472347597680709441e-18, 0x3fc4, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(7.88860905221011805412e-31, 0x3f9b, 0x80000000L, 0x00000000L), HEXCONSTE(7.88860905221011805412e-31, 0x3f9b, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-2.38872244954109191895e-01, 0xbffc, 0xf49aed00L, 0x00000000L), HEXCONSTE(-2.36656994327097555556e-01, 0xbffc, 0xf256360cL, 0x04a688c4L), 0 },
	{ __LINE__, HEXCONSTE(-2.33870461583137512207e-01, 0xbffc, 0xef7bbd00L, 0x00000000L), HEXCONSTE(-2.31789348165671296495e-01, 0xbffc, 0xed5a2fd7L, 0xbb19da55L), 0 },
	{ __LINE__, HEXCONSTE(-3.11965811997652053833e-02, 0xbff9, 0xff8ff900L, 0x00000000L), HEXCONSTE(-3.11915231904336943000e-02, 0xbff9, 0xff855d80L, 0x7da6bd8aL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-2.32736885547637939453e-01, 0xbffc, 0xee529400L, 0x00000000L), HEXCONSTE(-2.30685417910334923943e-01, 0xbffc, 0xec38cc56L, 0x5b1de07bL), 0 },
	{ __LINE__, HEXCONSTE(-2.32736900448799133301e-01, 0xbffc, 0xee529500L, 0x00000000L), HEXCONSTE(-2.30685432423612960638e-01, 0xbffc, 0xec38cd4fL, 0xb1304431L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-2.32736896353414685068e-01, 0xbffc, 0xee5294b9L, 0xa44f0800L), HEXCONSTE(-2.30685428434833004484e-01, 0xbffc, 0xec38cd0bL, 0x2a59490bL), 0 },
	{ __LINE__, HEXCONSTE(4.90453392267227172852e-01, 0x3ffd, 0xfb1cb500L, 0x00000000L), HEXCONSTE(4.72656818410998511617e-01, 0x3ffd, 0xf2001312L, 0x9d0122e3L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-4.61822867393493652344e-01, 0xbffd, 0xec740c00L, 0x00000000L), HEXCONSTE(-4.46807243352965719054e-01, 0xbffd, 0xe4c3eb43L, 0xa240de05L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-4.61822897195816040039e-01, 0xbffd, 0xec740d00L, 0x00000000L), HEXCONSTE(-4.46807270409335263983e-01, 0xbffd, 0xe4c3ec2cL, 0x0bd6d7a3L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-4.61822879046177414697e-01, 0xbffd, 0xec740c64L, 0x1885c800L), HEXCONSTE(-4.46807253931984194604e-01, 0xbffd, 0xe4c3eb9eL, 0x81c2d348L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(4.34731662273406982422e-01, 0x3ffd, 0xde952600L, 0x00000000L), HEXCONSTE(4.22086592521660201882e-01, 0x3ffd, 0xd81bbbddL, 0xebd4e89aL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-4.70883160829544067383e-01, 0xbffd, 0xf1179900L, 0x00000000L), HEXCONSTE(-4.55018504486113701467e-01, 0xbffd, 0xe8f82f77L, 0xaf74c0e9L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.91836655139923095703e-01, 0xbffc, 0xc470d400L, 0x00000000L), HEXCONSTE(-1.90679084757090569480e-01, 0xbffc, 0xc34160c4L, 0x406d1400L), 0 },
	{ __LINE__, HEXCONSTE(-2.63995409011840820312e-01, 0xbffd, 0x872a6800L, 0x00000000L), HEXCONSTE(-2.61021306213352980629e-01, 0xbffd, 0x85a495abL, 0x7db913b5L), 0 },
	{ __LINE__, HEXCONSTE(-6.85157574898635196050e+28, 0xc05e, 0xdd62e800L, 0x00000000L), HEXCONSTE(-6.70900084465614270357e+01, 0xc005, 0x862e1596L, 0x4cb0b000L), 0 },
	{ __LINE__, HEXCONSTE(-3.00714015960693359375e-01, 0xbffd, 0x99f73000L, 0x00000000L), HEXCONSTE(-2.96356883578852584477e-01, 0xbffd, 0x97bc16e5L, 0xd4d03eddL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-3.00714045763015747070e-01, 0xbffd, 0x99f73100L, 0x00000000L), HEXCONSTE(-2.96356912118685493382e-01, 0xbffd, 0x97bc17daL, 0xfc91da2fL), 0 },
	{ __LINE__, HEXCONSTE(-3.00714017275119704919e-01, 0xbffd, 0x99f7300bL, 0x4a744000L), HEXCONSTE(-2.96356884837597051859e-01, 0xbffd, 0x97bc16f0L, 0xa4d26285L), 0 },
	{ __LINE__, HEXCONSTE(-3.00714017275119760431e-01, 0xbffd, 0x99f7300bL, 0x4a744800L), HEXCONSTE(-2.96356884837597105012e-01, 0xbffd, 0x97bc16f0L, 0xa4d26a2eL), 0 },
	{ __LINE__, HEXCONSTE(-3.00714017275119710395e-01, 0xbffd, 0x99f7300bL, 0x4a7440caL), HEXCONSTE(-2.96356884837597057091e-01, 0xbffd, 0x97bc16f0L, 0xa4d26346L), 0 },
	{ __LINE__, HEXCONSTE(-3.61994624137878417969e-01, 0xbffd, 0xb9575c00L, 0x00000000L), HEXCONSTE(-3.54521449778125209880e-01, 0xbffd, 0xb583d5e1L, 0x0e1b96a0L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-3.61994653940200805664e-01, 0xbffd, 0xb9575d00L, 0x00000000L), HEXCONSTE(-3.54521477800897865746e-01, 0xbffd, 0xb583d6d1L, 0xc4d62655L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-3.61994652544233685987e-01, 0xbffd, 0xb9575cf4L, 0x023c6000L), HEXCONSTE(-3.54521476488286434224e-01, 0xbffd, 0xb583d6c6L, 0x7e5f9b02L), 0 },
	{ __LINE__, HEXCONSTE(-3.61994652544233741498e-01, 0xbffd, 0xb9575cf4L, 0x023c6800L), HEXCONSTE(-3.54521476488286486401e-01, 0xbffd, 0xb583d6c6L, 0x7e5fa287L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-3.61994652544233739384e-01, 0xbffd, 0xb9575cf4L, 0x023c67b2L), HEXCONSTE(-3.54521476488286484423e-01, 0xbffd, 0xb583d6c6L, 0x7e5fa23eL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-4.30270522832870483398e-01, 0xbffd, 0xdc4c6b00L, 0x00000000L), HEXCONSTE(-4.17992008232310901053e-01, 0xbffd, 0xd6030c6aL, 0xb1bc1574L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(4.24114257097244262695e-01, 0x3ffd, 0xd9258100L, 0x00000000L), HEXCONSTE(4.12330688342907894218e-01, 0x3ffd, 0xd31d020bL, 0x23d1838fL), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.05493636349960468205e-151, 0x3e0b, 0x80000000L, 0x00000000L), HEXCONSTE(3.05493636349960468205e-151, 0x3e0b, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(7.07981126104817289239e-1506, 0x2c77, 0x80000000L, 0x00000000L), HEXCONSTE(7.07981126104817289239e-1506, 0x2c77, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), FLAG_SUBNORM },
#endif
	{ __LINE__, HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(8.94159862326282983622e+01, 0x4005, 0xb2d4fc25L, 0xc173179fL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(7.10475860073943942030e+02, 0x4008, 0xb19e747dL, 0xcfc3ed88L), FLAG_INEXACT },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.13572165534747038951e+04, 0x400c, 0xb174ddc0L, 0x31aec0eaL), 0 },
#endif
	{ __LINE__, HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-8.94159862326282983622e+01, 0xc005, 0xb2d4fc25L, 0xc173179fL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-7.10475860073943942030e+02, 0xc008, 0xb19e747dL, 0xcfc3ed88L), FLAG_INEXACT },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-1.13572165534747038951e+04, 0xc00c, 0xb174ddc0L, 0x31aec0eaL), 0 },
#endif
};

int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_f_f(fasinh_data, ARRAY_SIZE(fasinh_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

```

`tests/atan.c`:

```c
#include "testconfig.h"
#define TEST_FUNC_F_F __MATH_PRECNAME(atan)
#include "testdriver.h"



static test_f_f_data const fatan_data[] = {
	{ __LINE__, ZERO_P, ZERO_P, 0 },
	{ __LINE__, ZERO_M, ZERO_M, FLAG_FAIL_ARANYM2 }, /* sometimes fails on ARAnyM, returning +0 ??? */
	{ __LINE__, INF_P, HEXCONST_PI_2, 0 },
	{ __LINE__, INF_M, HEXCONST_PI_2_M, 0 },
	{ __LINE__, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_P, 0 },
	{ __LINE__, SNAN_P, QNAN_P, 0 },
	{ __LINE__, SNAN_M, QNAN_P, 0 },

	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(7.85398163397448309628e-01, 0x3ffe, 0xc90fdaa2L, 0x2168c235L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-7.85398163397448309628e-01, 0xbffe, 0xc90fdaa2L, 0x2168c235L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(7.50000000000000000000e-01, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(6.43501108793284386797e-01, 0x3ffe, 0xa4bc7d19L, 0x34f70924L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(3.12500000000000000000e-02, 0x3ffa, 0x80000000L, 0x00000000L), HEXCONSTE(3.12398334302682762529e-02, 0x3ff9, 0xffeaadddL, 0x4bb12542L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(9.76562500000000000000e-04, 0x3ff5, 0x80000000L, 0x00000000L), HEXCONSTE(9.76562189559319430426e-04, 0x3ff4, 0xfffffaaaL, 0xaadddddcL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(3.05175781250000000000e-05, 0x3ff0, 0x80000000L, 0x00000000L), HEXCONSTE(3.05175781155260968620e-05, 0x3fef, 0xfffffffeL, 0xaaaaaaaeL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(9.53674316406250000000e-07, 0x3feb, 0x80000000L, 0x00000000L), HEXCONSTE(9.53674316405960879438e-07, 0x3fea, 0xffffffffL, 0xffaaaaabL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(2.98023223876953125000e-08, 0x3fe6, 0x80000000L, 0x00000000L), HEXCONSTE(2.98023223876953036773e-08, 0x3fe5, 0xffffffffL, 0xffffeaabL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(9.31322574615478515625e-10, 0x3fe1, 0x80000000L, 0x00000000L), HEXCONSTE(9.31322574615478515373e-10, 0x3fe0, 0xffffffffL, 0xfffffffbL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.91038304567337036133e-11, 0x3fdc, 0x80000000L, 0x00000000L), HEXCONSTE(2.91038304567337036133e-11, 0x3fdc, 0x80000000L, 0x00000000L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(9.09494701772928237915e-13, 0x3fd7, 0x80000000L, 0x00000000L), HEXCONSTE(9.09494701772928237915e-13, 0x3fd7, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.84217094304040074348e-14, 0x3fd2, 0x80000000L, 0x00000000L), HEXCONSTE(2.84217094304040074348e-14, 0x3fd2, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(8.88178419700125232339e-16, 0x3fcd, 0x80000000L, 0x00000000L), HEXCONSTE(8.88178419700125232339e-16, 0x3fcd, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.77555756156289135106e-17, 0x3fc8, 0x80000000L, 0x00000000L), HEXCONSTE(2.77555756156289135106e-17, 0x3fc8, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(8.67361737988403547206e-19, 0x3fc3, 0x80000000L, 0x00000000L), HEXCONSTE(8.67361737988403547206e-19, 0x3fc3, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.50000000000000000000e+00, 0x4000, 0xa0000000L, 0x00000000L), HEXCONSTE(1.19028994968253173296e+00, 0x3fff, 0x985b6bcbL, 0x526d42c5L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+01, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(1.47112767430373459182e+00, 0x3fff, 0xbc4de960L, 0xb0029c17L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+06, 0x4012, 0xf4240000L, 0x00000000L), HEXCONSTE(1.57079532679489661956e+00, 0x3fff, 0xc90fd23eL, 0xa5986741L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.14748364800000000000e+09, 0x401e, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632632923533195e+00, 0x3fff, 0xc90fdaa1L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(7.88860905221011805412e-31, 0x3f9b, 0x80000000L, 0x00000000L), HEXCONSTE(7.88860905221011805412e-31, 0x3f9b, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.40991986510288411774e-181, 0x3da7, 0x80000000L, 0x00000000L), HEXCONSTE(2.40991986510288411774e-181, 0x3da7, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(5.01237274920645200930e-3011, 0x18ef, 0x80000000L, 0x00000000L), HEXCONSTE(5.01237274920645200930e-3011, 0x18ef, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-2.30512157082557678223e-01, 0xbffc, 0xec0b6100L, 0x00000000L), HEXCONSTE(-2.26554758731449528894e-01, 0xbffc, 0xe7fdf87eL, 0x04dc2e4cL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-2.03055411577224731445e-01, 0xbffc, 0xcfedc200L, 0x00000000L), HEXCONSTE(-2.00331721927011568860e-01, 0xbffc, 0xcd23c248L, 0x1c8cc7f6L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-2.19643592834472656250e+00, 0xc000, 0x8c926800L, 0x00000000L), HEXCONSTE(-1.14355772701168300406e+00, 0xbfff, 0x9260197fL, 0x4d3817b9L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-1.21190297603607177734e+00, 0xbfff, 0x9b1fa300L, 0x00000000L), HEXCONSTE(-8.80907890629840996312e-01, 0xbffe, 0xe1832df5L, 0x0b2398e5L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-1.67694151401519775391e+00, 0xbfff, 0xd6a60500L, 0x00000000L), HEXCONSTE(-1.03308435910990273571e+00, 0xbfff, 0x843c1bb8L, 0x316d6d15L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-3.92013692855834960938e+00, 0xc000, 0xfae38600L, 0x00000000L), HEXCONSTE(-1.32102990354261166711e+00, 0xbfff, 0xa9178204L, 0x6074616cL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(3.32717180252075195312e+00, 0x4000, 0xd4f06200L, 0x00000000L), HEXCONSTE(1.27882991788893141116e+00, 0x3fff, 0xa3b0b2e1L, 0x3d5a8c00L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-1.34680461883544921875e+00, 0xbfff, 0xac641800L, 0x00000000L), HEXCONSTE(-9.32113685989933426980e-01, 0xbffe, 0xee9f00a5L, 0x7b143b32L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MIN_EXP <= -16381
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), FLAG_SUBNORM },
#endif
	{ __LINE__, HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), 0 },
};

int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_f_f(fatan_data, ARRAY_SIZE(fatan_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

```

`tests/atan2.c`:

```c
#include "testconfig.h"
#define TEST_FUNC_FF_F __MATH_PRECNAME(atan2)
#include "testdriver.h"



static test_ff_f_data const fatan2_data[] = {
	/* atan2 (0,x) == 0 for x > 0.	*/
	{ __LINE__, ZERO_P, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), ZERO_P, 0 },
	{ __LINE__, ZERO_P, ZERO_P, ZERO_P, FLAG_FAIL_HARDFLOAT }, /* not handled by inline version in math-68881.h */
	/* atan2 (-0,x) == -0 for x > 0.  */
	{ __LINE__, ZERO_M, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), ZERO_M, FLAG_FAIL_ARANYM2 },
	{ __LINE__, ZERO_M, ZERO_P, ZERO_M, FLAG_FAIL_HARDFLOAT }, /* not handled by inline version in math-68881.h */
	/* atan2 (+0,x) == +pi for x < 0.  */
	{ __LINE__, ZERO_P, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, ZERO_P, ZERO_M, HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), FLAG_FAIL_HARDFLOAT }, /* not handled by inline version in math-68881.h */
	/* atan2 (-0,x) == -pi for x < 0.  */
	{ __LINE__, ZERO_M, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), FLAG_FAIL_HARDFLOAT }, /* not handled by inline version in math-68881.h */
	{ __LINE__, ZERO_M, ZERO_M, HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), FLAG_FAIL_HARDFLOAT }, /* not handled by inline version in math-68881.h */

	/* atan2 (y,inf) == +0 for finite y > 0 or +0. */
	{ __LINE__, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), INF_P, ZERO_P, FLAG_XFAIL_LINUX },
	{ __LINE__, ZERO_P, INF_P, ZERO_P, FLAG_XFAIL_LINUX },
	{ __LINE__, MIN_P, INF_P, ZERO_P, FLAG_MINVAL|FLAG_XFAIL_LINUX },
	{ __LINE__, SUBNORM_P, INF_P, ZERO_P, FLAG_SUBNORM|FLAG_XFAIL_LINUX },
	{ __LINE__, MAX_P, INF_P, ZERO_P, FLAG_XFAIL_LINUX },
	
	/* atan2 (y,inf) == -0 for finite y < 0 or -0.  */
	{ __LINE__, HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), INF_P, ZERO_M, FLAG_XFAIL_LINUX|FLAG_FAIL_ARANYM2 },
	{ __LINE__, ZERO_M, INF_P, ZERO_M, FLAG_XFAIL_LINUX|FLAG_FAIL_ARANYM2 },
	{ __LINE__, MIN_M, INF_P, ZERO_M, FLAG_MINVAL|FLAG_XFAIL_LINUX },
	{ __LINE__, SUBNORM_M, INF_P, ZERO_M, FLAG_SUBNORM|FLAG_XFAIL_LINUX },
	{ __LINE__, MAX_M, INF_P, ZERO_M, FLAG_XFAIL_LINUX },

 	/* atan2(+inf, x) == pi/2 for finite x.  */
	{ __LINE__, INF_P, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), HEXCONST_PI_2, FLAG_XFAIL_LINUX },
	{ __LINE__, INF_P, ZERO_P, HEXCONST_PI_2, FLAG_XFAIL_LINUX },
	{ __LINE__, INF_P, MIN_P, HEXCONST_PI_2, FLAG_MINVAL|FLAG_XFAIL_LINUX },
	{ __LINE__, INF_P, SUBNORM_P, HEXCONST_PI_2, FLAG_SUBNORM|FLAG_XFAIL_LINUX },
	{ __LINE__, INF_P, MAX_P, HEXCONST_PI_2, FLAG_XFAIL_LINUX },
	{ __LINE__, INF_P, HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), HEXCONST_PI_2, FLAG_XFAIL_LINUX },
	{ __LINE__, INF_P, ZERO_M, HEXCONST_PI_2, FLAG_XFAIL_LINUX },
	{ __LINE__, INF_P, SUBNORM_M, HEXCONST_PI_2, FLAG_SUBNORM|FLAG_XFAIL_LINUX },
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, INF_P, MIN_M, HEXCONST_PI_2, FLAG_MINVAL|FLAG_XFAIL_LINUX },
	{ __LINE__, INF_P, MAX_M, HEXCONST_PI_2, FLAG_XFAIL_LINUX },
#endif

	/* atan2(-inf, x) == -pi/2 for finite x.  */
	{ __LINE__, INF_M, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), HEXCONST_PI_2_M, FLAG_XFAIL_LINUX },
	{ __LINE__, INF_M, ZERO_P, HEXCONST_PI_2_M, FLAG_XFAIL_LINUX },
	{ __LINE__, INF_M, MIN_P, HEXCONST_PI_2_M, FLAG_MINVAL|FLAG_XFAIL_LINUX },
	{ __LINE__, INF_M, SUBNORM_P, HEXCONST_PI_2_M, FLAG_SUBNORM|FLAG_XFAIL_LINUX },
	{ __LINE__, INF_M, MAX_P, HEXCONST_PI_2_M, FLAG_XFAIL_LINUX },
	{ __LINE__, INF_M, HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), HEXCONST_PI_2_M, FLAG_XFAIL_LINUX },
	{ __LINE__, INF_M, ZERO_M, HEXCONST_PI_2_M, FLAG_XFAIL_LINUX },
	{ __LINE__, INF_M, MIN_M, HEXCONST_PI_2_M, FLAG_MINVAL|FLAG_XFAIL_LINUX },
	{ __LINE__, INF_M, SUBNORM_M, HEXCONST_PI_2_M, FLAG_SUBNORM|FLAG_XFAIL_LINUX },
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, INF_M, MAX_M, HEXCONST_PI_2_M, FLAG_XFAIL_LINUX },
#endif

	/* atan2 (y,-inf) == +pi for finite y > 0 or +0.  */
	{ __LINE__, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), INF_M, HEXCONST_PI, FLAG_XFAIL_LINUX },
	{ __LINE__, ZERO_P, INF_M, HEXCONST_PI, FLAG_XFAIL_LINUX },
	{ __LINE__, MIN_P, INF_M, HEXCONST_PI, FLAG_MINVAL|FLAG_XFAIL_LINUX },
	{ __LINE__, SUBNORM_P, INF_M, HEXCONST_PI, FLAG_SUBNORM|FLAG_XFAIL_LINUX },
	{ __LINE__, MAX_P, INF_M, HEXCONST_PI, FLAG_XFAIL_LINUX },

	/* atan2 (y,-inf) == -pi for finite y < 0 or -0.  */
	{ __LINE__, HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), INF_M, HEXCONST_PI_M, FLAG_XFAIL_LINUX },
	{ __LINE__, ZERO_M, INF_M, HEXCONST_PI_M, FLAG_FAIL_HARDFLOAT|FLAG_FAIL_ARANYM }, /* not handled by inline version in math-68881.h */
	{ __LINE__, MIN_M, INF_M, HEXCONST_PI_M, FLAG_MINVAL|FLAG_XFAIL_LINUX },
	{ __LINE__, SUBNORM_M, INF_M, HEXCONST_PI_M, FLAG_SUBNORM|FLAG_XFAIL_LINUX },
	{ __LINE__, MAX_M, INF_M, HEXCONST_PI_M, FLAG_XFAIL_LINUX },

	/* If y is positive infinity (negative infinity) and x is positive infinity, +pi/4 (-pi/4) is returned. */
	{ __LINE__, INF_P, INF_P, HEXCONST_PI_4, FLAG_FAIL_HARDFLOAT|FLAG_FAIL_ARANYM }, /* not handled by inline version in math-68881.h */
	{ __LINE__, INF_M, INF_P, HEXCONST_PI_4_M, FLAG_FAIL_HARDFLOAT|FLAG_FAIL_ARANYM }, /* not handled by inline version in math-68881.h */
	/* If y is positive infinity (negative infinity) and x is negative infinity, +3*pi/4 (-3*pi/4) is returned. */
	{ __LINE__, INF_P, INF_M, HEXCONSTE(2.356194490192344928846982537459627163, 0x4000, 0x96cbe3f9L, 0x990e91a8L), FLAG_FAIL_HARDFLOAT|FLAG_FAIL_ARANYM }, /* not handled by inline version in math-68881.h */
	{ __LINE__, INF_M, INF_M, HEXCONSTE(-2.356194490192344928846982537459627163, 0xc000, 0x96cbe3f9L, 0x990e91a8L), FLAG_FAIL_HARDFLOAT|FLAG_FAIL_ARANYM }, /* not handled by inline version in math-68881.h */

	{ __LINE__, QNAN_P, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_P, QNAN_M, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_M, QNAN_P, 0 },
	{ __LINE__, SNAN_P, QNAN_P, QNAN_P, 0 },
	{ __LINE__, SNAN_P, QNAN_M, QNAN_P, 0 },
	{ __LINE__, SNAN_M, QNAN_P, QNAN_P, 0 },
	{ __LINE__, SNAN_M, QNAN_M, QNAN_P, 0 },
	{ __LINE__, QNAN_P, SNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_P, SNAN_M, QNAN_P, 0 },
	{ __LINE__, QNAN_M, SNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, SNAN_M, QNAN_P, 0 },
	{ __LINE__, SNAN_P, SNAN_P, QNAN_P, 0 },
	{ __LINE__, SNAN_P, SNAN_M, QNAN_P, 0 },
	{ __LINE__, SNAN_M, SNAN_P, QNAN_P, 0 },
	{ __LINE__, SNAN_M, SNAN_M, QNAN_P, 0 },
	{ __LINE__, QNAN_P, INF_P, QNAN_P, 0 },
	{ __LINE__, QNAN_P, INF_M, QNAN_P, 0 },
	{ __LINE__, QNAN_P, ZERO_P, QNAN_P, 0 },
	{ __LINE__, QNAN_P, ZERO_M, QNAN_P, 0 },
	{ __LINE__, QNAN_P, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__, QNAN_P, HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__, QNAN_P, MIN_P, QNAN_P, FLAG_MINVAL },
	{ __LINE__, QNAN_P, MIN_M, QNAN_P, FLAG_MINVAL },
	{ __LINE__, QNAN_P, SUBNORM_P, QNAN_P, FLAG_SUBNORM },
	{ __LINE__, QNAN_P, SUBNORM_M, QNAN_P, FLAG_SUBNORM },
	{ __LINE__, QNAN_P, MAX_P, QNAN_P, 0 },
	{ __LINE__, QNAN_P, MAX_M, QNAN_P, 0 },
	{ __LINE__, QNAN_M, INF_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, INF_M, QNAN_P, 0 },
	{ __LINE__, QNAN_M, ZERO_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, ZERO_M, QNAN_P, 0 },
	{ __LINE__, QNAN_M, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__, QNAN_M, HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__, QNAN_M, MIN_P, QNAN_P, FLAG_MINVAL },
	{ __LINE__, QNAN_M, MIN_M, QNAN_P, FLAG_MINVAL },
	{ __LINE__, QNAN_M, SUBNORM_P, QNAN_P, FLAG_SUBNORM },
	{ __LINE__, QNAN_M, SUBNORM_M, QNAN_P, FLAG_SUBNORM },
	{ __LINE__, QNAN_M, MAX_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, MAX_M, QNAN_P, 0 },
	{ __LINE__, SNAN_P, INF_P, QNAN_P, 0 },
	{ __LINE__, SNAN_P, INF_M, QNAN_P, 0 },
	{ __LINE__, SNAN_P, ZERO_P, QNAN_P, 0 },
	{ __LINE__, SNAN_P, ZERO_M, QNAN_P, 0 },
	{ __LINE__, SNAN_P, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__, SNAN_P, HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__, SNAN_P, MIN_P, QNAN_P, FLAG_MINVAL },
	{ __LINE__, SNAN_P, MIN_M, QNAN_P, FLAG_MINVAL },
	{ __LINE__, SNAN_P, SUBNORM_P, QNAN_P, FLAG_SUBNORM },
	{ __LINE__, SNAN_P, SUBNORM_M, QNAN_P, FLAG_SUBNORM },
	{ __LINE__, SNAN_P, MAX_P, QNAN_P, 0 },
	{ __LINE__, SNAN_P, MAX_M, QNAN_P, 0 },
	{ __LINE__, SNAN_M, INF_P, QNAN_P, 0 },
	{ __LINE__, SNAN_M, INF_M, QNAN_P, 0 },
	{ __LINE__, SNAN_M, ZERO_P, QNAN_P, 0 },
	{ __LINE__, SNAN_M, ZERO_M, QNAN_P, 0 },
	{ __LINE__, SNAN_M, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__, SNAN_M, HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__, SNAN_M, MIN_P, QNAN_P, FLAG_MINVAL },
	{ __LINE__, SNAN_M, MIN_M, QNAN_P, FLAG_MINVAL },
	{ __LINE__, SNAN_M, SUBNORM_P, QNAN_P, FLAG_SUBNORM },
	{ __LINE__, SNAN_M, SUBNORM_M, QNAN_P, FLAG_SUBNORM },
	{ __LINE__, SNAN_M, MAX_P, QNAN_P, 0 },
	{ __LINE__, SNAN_M, MAX_M, QNAN_P, 0 },
	{ __LINE__, INF_P, QNAN_P, QNAN_P, 0 },
	{ __LINE__, INF_M, QNAN_P, QNAN_P, 0 },
	{ __LINE__, ZERO_P, QNAN_P, QNAN_P, 0 },
	{ __LINE__, ZERO_M, QNAN_P, QNAN_P, 0 },
	{ __LINE__, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), QNAN_P, QNAN_P, 0 },
	{ __LINE__, HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), QNAN_P, QNAN_P, 0 },
	{ __LINE__, MIN_P, QNAN_P, QNAN_P, FLAG_MINVAL },
	{ __LINE__, MIN_M, QNAN_P, QNAN_P, FLAG_MINVAL },
	{ __LINE__, SUBNORM_P, QNAN_P, QNAN_P, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, QNAN_P, QNAN_P, FLAG_SUBNORM },
	{ __LINE__, MAX_P, QNAN_P, QNAN_P, 0 },
	{ __LINE__, MAX_M, QNAN_P, QNAN_P, 0 },
	{ __LINE__, INF_P, QNAN_M, QNAN_P, 0 },
	{ __LINE__, INF_M, QNAN_M, QNAN_P, 0 },
	{ __LINE__, ZERO_P, QNAN_M, QNAN_P, 0 },
	{ __LINE__, ZERO_M, QNAN_M, QNAN_P, 0 },
	{ __LINE__, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), QNAN_M, QNAN_P, 0 },
	{ __LINE__, HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), QNAN_M, QNAN_P, 0 },
	{ __LINE__, MIN_P, QNAN_M, QNAN_P, FLAG_MINVAL },
	{ __LINE__, MIN_M, QNAN_M, QNAN_P, FLAG_MINVAL},
	{ __LINE__, SUBNORM_P, QNAN_M, QNAN_P, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, QNAN_M, QNAN_P, FLAG_SUBNORM },
	{ __LINE__, MAX_P, QNAN_M, QNAN_P, 0 },
	{ __LINE__, MAX_M, QNAN_M, QNAN_P, 0 },
	{ __LINE__, INF_P, SNAN_P, QNAN_P, 0 },
	{ __LINE__, INF_M, SNAN_P, QNAN_P, 0 },
	{ __LINE__, ZERO_P, SNAN_P, QNAN_P, 0 },
	{ __LINE__, ZERO_M, SNAN_P, QNAN_P, 0 },
	{ __LINE__, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), SNAN_P, QNAN_P, 0 },
	{ __LINE__, HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), SNAN_P, QNAN_P, 0 },
	{ __LINE__, MIN_P, SNAN_P, QNAN_P, FLAG_MINVAL },
	{ __LINE__, MIN_M, SNAN_P, QNAN_P, FLAG_MINVAL },
	{ __LINE__, SUBNORM_P, SNAN_P, QNAN_P, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, SNAN_P, QNAN_P, FLAG_SUBNORM },
	{ __LINE__, MAX_P, SNAN_P, QNAN_P, 0 },
	{ __LINE__, MAX_M, SNAN_P, QNAN_P, 0 },
	{ __LINE__, INF_P, SNAN_M, QNAN_P, 0 },
	{ __LINE__, INF_M, SNAN_M, QNAN_P, 0 },
	{ __LINE__, ZERO_P, SNAN_M, QNAN_P, 0 },
	{ __LINE__, ZERO_M, SNAN_M, QNAN_P, 0 },
	{ __LINE__, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), SNAN_M, QNAN_P, 0 },
	{ __LINE__, HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), SNAN_M, QNAN_P, 0 },
	{ __LINE__, MIN_P, SNAN_M, QNAN_P, FLAG_MINVAL },
	{ __LINE__, MIN_M, SNAN_M, QNAN_P, FLAG_MINVAL },
	{ __LINE__, SUBNORM_P, SNAN_M, QNAN_P, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, SNAN_M, QNAN_P, FLAG_SUBNORM },
	{ __LINE__, MAX_P, SNAN_M, QNAN_P, 0 },
	{ __LINE__, MAX_M, SNAN_M, QNAN_P, 0 },

	/* atan2 (y,+0) == pi/2 for y > 0.	*/
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), ZERO_P, HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	/* atan2 (y,-0) == pi/2 for y > 0.	*/
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), ZERO_M, HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	/* atan2 (y,+0) == -pi/2 for y < 0.  */
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), ZERO_P, HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	/* atan2 (y,-0) == -pi/2 for y < 0.  */
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), ZERO_M, HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },

	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(7.85398163397448309628e-01, 0x3ffe, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.89288338504219125616e-270, 0x3c7e, 0xffffff00L, 0x00000800L), 0 },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(2.86016086794739201471e-4894, 0x007e, 0xffffff00L, 0x00000001L), 0 },
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(7.85398163397448309628e-01, 0x3ffe, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.51100743476790606040e-4624, 0x03fe, 0xffffffffL, 0xfffff801L), 0 },
	{ __LINE__, HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(7.85398163397448309628e-01, 0x3ffe, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(2.35619449019234492894e+00, 0x4000, 0x96cbe3f9L, 0x990e91a8L), 0 },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(2.35619449019234492894e+00, 0x4000, 0x96cbe3f9L, 0x990e91a8L), 0 },
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(2.35619449019234492894e+00, 0x4000, 0x96cbe3f9L, 0x990e91a8L), 0 },
	{ __LINE__, HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-7.85398163397448309628e-01, 0xbffe, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.89288338504219125616e-270, 0xbc7e, 0xffffff00L, 0x00000800L), 0 },
	{ __LINE__, HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-2.86016086794739201471e-4894, 0x807e, 0xffffff00L, 0x00000001L), 0 },
	{ __LINE__, HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-7.85398163397448309628e-01, 0xbffe, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-1.51100743476790606040e-4624, 0x83fe, 0xffffffffL, 0xfffff801L), 0 },
	{ __LINE__, HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-7.85398163397448309628e-01, 0xbffe, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-2.35619449019234492894e+00, 0xc000, 0x96cbe3f9L, 0x990e91a8L), 0 },
	{ __LINE__, HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-2.35619449019234492894e+00, 0xc000, 0x96cbe3f9L, 0x990e91a8L), 0 },
	{ __LINE__, HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-2.35619449019234492894e+00, 0xc000, 0x96cbe3f9L, 0x990e91a8L), 0 },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
#endif
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
#endif
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
#endif
	{ __LINE__, HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
#endif
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
#endif
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
#endif
	{ __LINE__, HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), SUBNORM_P, HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), SUBNORM_P, HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), SUBNORM_P, HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), SUBNORM_M, HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), SUBNORM_M, HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), SUBNORM_M, HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), SUBNORM_P, HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), SUBNORM_P, HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), SUBNORM_P, HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), SUBNORM_M, HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), SUBNORM_M, HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), SUBNORM_M, HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(7.50000000000000000000e-01, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(6.43501108793284386797e-01, 0x3ffe, 0xa4bc7d19L, 0x34f70924L), 0 },
	{ __LINE__, HEXCONSTE(-7.50000000000000000000e-01, 0xbffe, 0xc0000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-6.43501108793284386797e-01, 0xbffe, 0xa4bc7d19L, 0x34f70924L), 0 },
	{ __LINE__, HEXCONSTE(7.50000000000000000000e-01, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(2.49809154479650885172e+00, 0x4000, 0x9fe0bb5bL, 0xd42affecL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-7.50000000000000000000e-01, 0xbffe, 0xc0000000L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-2.49809154479650885172e+00, 0xc000, 0x9fe0bb5bL, 0xd42affecL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.90625000000000000000e-01, 0x3ffd, 0xc8000000L, 0x00000000L), HEXCONSTE(2.90000025415793061256e-04, 0x3ff3, 0x980b2500L, 0x00000000L), HEXCONSTE(1.57005392686622535347e+00, 0x3fff, 0xc8f786eeL, 0x6c6463d8L), 0 },
	{ __LINE__, HEXCONSTE(3.90625000000000000000e-01, 0x3ffd, 0xc8000000L, 0x00000000L), HEXCONSTE(2.89999996311962604523e-04, 0x3ff3, 0x980b2400L, 0x00000000L), HEXCONSTE(1.57005392694073111831e+00, 0x3fff, 0xc8f786eeL, 0x955a24ecL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.90625000000000000000e-01, 0x3ffd, 0xc8000000L, 0x00000000L), HEXCONSTE(2.90000000000000001700e-04, 0x3ff3, 0x980b2420L, 0x70b8d000L), HEXCONSTE(1.57005392693128974777e+00, 0x3fff, 0xc8f786eeL, 0x902963b3L), 0 },
	{ __LINE__, HEXCONSTE(3.90625000000000000000e-01, 0x3ffd, 0xc8000000L, 0x00000000L), HEXCONSTE(2.89999999999999947490e-04, 0x3ff3, 0x980b2420L, 0x70b8c800L), HEXCONSTE(1.57005392693128974799e+00, 0x3fff, 0xc8f786eeL, 0x902963b5L), 0 },
	{ __LINE__, HEXCONSTE(3.90625000000000000000e-01, 0x3ffd, 0xc8000000L, 0x00000000L), HEXCONSTE(2.90000000000000000006e-04, 0x3ff3, 0x980b2420L, 0x70b8cfc0L), HEXCONSTE(1.57005392693128974777e+00, 0x3fff, 0xc8f786eeL, 0x902963b3L), 0 },
	{ __LINE__, HEXCONSTE(3.90625000000000000000e-01, 0x3ffd, 0xc8000000L, 0x00000000L), HEXCONSTE(2.89999999999999999979e-04, 0x3ff3, 0x980b2420L, 0x70b8cfbfL), HEXCONSTE(1.57005392693128974777e+00, 0x3fff, 0xc8f786eeL, 0x902963b3L), 0 },
	{ __LINE__, HEXCONSTE(1.39062500000000000000e+00, 0x3fff, 0xb2000000L, 0x00000000L), HEXCONSTE(9.29687500000000000000e-01, 0x3ffe, 0xee000000L, 0x00000000L), HEXCONSTE(9.81498387184244311507e-01, 0x3ffe, 0xfb437a72L, 0x087797cfL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-7.56826996803283691406e-03, 0xbff7, 0xf7ff4000L, 0x00000000L), HEXCONSTE(-1.79273576941341161728e-03, 0xbff5, 0xeafa3b00L, 0x00000000L), HEXCONSTE(-1.80338464370443418792e+00, 0xbfff, 0xe6d54ed9L, 0x68da2408L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-7.56826996803283691406e-03, 0xbff7, 0xf7ff4000L, 0x00000000L), HEXCONSTE(-1.79273588582873344421e-03, 0xbff5, 0xeafa3c00L, 0x00000000L), HEXCONSTE(-1.80338465826923068200e+00, 0xbfff, 0xe6d54ef8L, 0xafef048aL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-7.56826996803283691406e-03, 0xbff7, 0xf7ff4000L, 0x00000000L), HEXCONSTE(-1.79273585753872790639e-03, 0xbff5, 0xeafa3bc1L, 0xca248800L), HEXCONSTE(-1.80338465472984973168e+00, 0xbfff, 0xe6d54ef1L, 0x16236eb5L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-7.56826996803283691406e-03, 0xbff7, 0xf7ff4000L, 0x00000000L), HEXCONSTE(-1.79273585753872812323e-03, 0xbff5, 0xeafa3bc1L, 0xca249000L), HEXCONSTE(-1.80338465472984975878e+00, 0xbfff, 0xe6d54ef1L, 0x16236fafL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-7.56826996803283691406e-03, 0xbff7, 0xf7ff4000L, 0x00000000L), HEXCONSTE(-1.79273585753872803599e-03, 0xbff5, 0xeafa3bc1L, 0xca248cc8L), HEXCONSTE(-1.80338465472984974794e+00, 0xbfff, 0xe6d54ef1L, 0x16236f4bL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-7.56826996803283691406e-03, 0xbff7, 0xf7ff4000L, 0x00000000L), HEXCONSTE(-1.79273585753872803610e-03, 0xbff5, 0xeafa3bc1L, 0xca248cc9L), HEXCONSTE(-1.80338465472984974794e+00, 0xbfff, 0xe6d54ef1L, 0x16236f4bL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-7.56827043369412422180e-03, 0xbff7, 0xf7ff4100L, 0x00000000L), HEXCONSTE(-1.79273576941341161728e-03, 0xbff5, 0xeafa3b00L, 0x00000000L), HEXCONSTE(-1.80338462990427625041e+00, 0xbfff, 0xe6d54ebbL, 0xc62292dfL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-7.56827043369412422180e-03, 0xbff7, 0xf7ff4100L, 0x00000000L), HEXCONSTE(-1.79273588582873344421e-03, 0xbff5, 0xeafa3c00L, 0x00000000L), HEXCONSTE(-1.80338464446907194359e+00, 0xbfff, 0xe6d54edbL, 0x0d375686L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-7.56827043369412422180e-03, 0xbff7, 0xf7ff4100L, 0x00000000L), HEXCONSTE(-1.79273585753872790639e-03, 0xbff5, 0xeafa3bc1L, 0xca248800L), HEXCONSTE(-1.80338464092969118788e+00, 0xbfff, 0xe6d54ed3L, 0x736bc7b4L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-7.56827043369412422180e-03, 0xbff7, 0xf7ff4100L, 0x00000000L), HEXCONSTE(-1.79273585753872812323e-03, 0xbff5, 0xeafa3bc1L, 0xca249000L), HEXCONSTE(-1.80338464092969121499e+00, 0xbfff, 0xe6d54ed3L, 0x736bc8aeL), 0 },
	{ __LINE__, HEXCONSTE(-7.56827043369412422180e-03, 0xbff7, 0xf7ff4100L, 0x00000000L), HEXCONSTE(-1.79273585753872803599e-03, 0xbff5, 0xeafa3bc1L, 0xca248cc8L), HEXCONSTE(-1.80338464092969120414e+00, 0xbfff, 0xe6d54ed3L, 0x736bc84aL), 0 },
	{ __LINE__, HEXCONSTE(-7.56827043369412422180e-03, 0xbff7, 0xf7ff4100L, 0x00000000L), HEXCONSTE(-1.79273585753872803610e-03, 0xbff5, 0xeafa3bc1L, 0xca248cc9L), HEXCONSTE(-1.80338464092969120414e+00, 0xbfff, 0xe6d54ed3L, 0x736bc84aL), 0 },
	{ __LINE__, HEXCONSTE(-7.56827042671106252347e-03, 0xbff7, 0xf7ff40fcL, 0x2938b000L), HEXCONSTE(-1.79273576941341161728e-03, 0xbff5, 0xeafa3b00L, 0x00000000L), HEXCONSTE(-1.80338463011122355616e+00, 0xbfff, 0xe6d54ebcL, 0x37e7d158L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-7.56827042671106252347e-03, 0xbff7, 0xf7ff40fcL, 0x2938b000L), HEXCONSTE(-1.79273588582873344421e-03, 0xbff5, 0xeafa3c00L, 0x00000000L), HEXCONSTE(-1.80338464467601926138e+00, 0xbfff, 0xe6d54edbL, 0x7efc956eL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-7.56827042671106252347e-03, 0xbff7, 0xf7ff40fcL, 0x2938b000L), HEXCONSTE(-1.79273585753872790639e-03, 0xbff5, 0xeafa3bc1L, 0xca248800L), HEXCONSTE(-1.80338464113663850274e+00, 0xbfff, 0xe6d54ed3L, 0xe5310681L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-7.56827042671106252347e-03, 0xbff7, 0xf7ff40fcL, 0x2938b000L), HEXCONSTE(-1.79273585753872812323e-03, 0xbff5, 0xeafa3bc1L, 0xca249000L), HEXCONSTE(-1.80338464113663852985e+00, 0xbfff, 0xe6d54ed3L, 0xe531077bL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-7.56827042671106252347e-03, 0xbff7, 0xf7ff40fcL, 0x2938b000L), HEXCONSTE(-1.79273585753872803599e-03, 0xbff5, 0xeafa3bc1L, 0xca248cc8L), HEXCONSTE(-1.80338464113663851890e+00, 0xbfff, 0xe6d54ed3L, 0xe5310716L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-7.56827042671106252347e-03, 0xbff7, 0xf7ff40fcL, 0x2938b000L), HEXCONSTE(-1.79273585753872803610e-03, 0xbff5, 0xeafa3bc1L, 0xca248cc9L), HEXCONSTE(-1.80338464113663851901e+00, 0xbfff, 0xe6d54ed3L, 0xe5310717L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-7.56827042671106339083e-03, 0xbff7, 0xf7ff40fcL, 0x2938b800L), HEXCONSTE(-1.79273576941341161728e-03, 0xbff5, 0xeafa3b00L, 0x00000000L), HEXCONSTE(-1.80338463011122353047e+00, 0xbfff, 0xe6d54ebcL, 0x37e7d06bL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-7.56827042671106339083e-03, 0xbff7, 0xf7ff40fcL, 0x2938b800L), HEXCONSTE(-1.79273588582873344421e-03, 0xbff5, 0xeafa3c00L, 0x00000000L), HEXCONSTE(-1.80338464467601923568e+00, 0xbfff, 0xe6d54edbL, 0x7efc9481L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-7.56827042671106339083e-03, 0xbff7, 0xf7ff40fcL, 0x2938b800L), HEXCONSTE(-1.79273585753872790639e-03, 0xbff5, 0xeafa3bc1L, 0xca248800L), HEXCONSTE(-1.80338464113663847705e+00, 0xbfff, 0xe6d54ed3L, 0xe5310594L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-7.56827042671106339083e-03, 0xbff7, 0xf7ff40fcL, 0x2938b800L), HEXCONSTE(-1.79273585753872812323e-03, 0xbff5, 0xeafa3bc1L, 0xca249000L), HEXCONSTE(-1.80338464113663850415e+00, 0xbfff, 0xe6d54ed3L, 0xe531068eL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-7.56827042671106339083e-03, 0xbff7, 0xf7ff40fcL, 0x2938b800L), HEXCONSTE(-1.79273585753872803599e-03, 0xbff5, 0xeafa3bc1L, 0xca248cc8L), HEXCONSTE(-1.80338464113663849320e+00, 0xbfff, 0xe6d54ed3L, 0xe5310629L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-7.56827042671106339083e-03, 0xbff7, 0xf7ff40fcL, 0x2938b800L), HEXCONSTE(-1.79273585753872803610e-03, 0xbff5, 0xeafa3bc1L, 0xca248cc9L), HEXCONSTE(-1.80338464113663849331e+00, 0xbfff, 0xe6d54ed3L, 0xe531062aL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-7.56827042671106338999e-03, 0xbff7, 0xf7ff40fcL, 0x2938b7feL), HEXCONSTE(-1.79273576941341161728e-03, 0xbff5, 0xeafa3b00L, 0x00000000L), HEXCONSTE(-1.80338463011122353047e+00, 0xbfff, 0xe6d54ebcL, 0x37e7d06bL), FLAG_INEXACT},
	{ __LINE__, HEXCONSTE(-7.56827042671106338999e-03, 0xbff7, 0xf7ff40fcL, 0x2938b7feL), HEXCONSTE(-1.79273588582873344421e-03, 0xbff5, 0xeafa3c00L, 0x00000000L), HEXCONSTE(-1.80338464467601923568e+00, 0xbfff, 0xe6d54edbL, 0x7efc9481L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-7.56827042671106338999e-03, 0xbff7, 0xf7ff40fcL, 0x2938b7feL), HEXCONSTE(-1.79273585753872790639e-03, 0xbff5, 0xeafa3bc1L, 0xca248800L), HEXCONSTE(-1.80338464113663847705e+00, 0xbfff, 0xe6d54ed3L, 0xe5310594L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-7.56827042671106338999e-03, 0xbff7, 0xf7ff40fcL, 0x2938b7feL), HEXCONSTE(-1.79273585753872812323e-03, 0xbff5, 0xeafa3bc1L, 0xca249000L), HEXCONSTE(-1.80338464113663850415e+00, 0xbfff, 0xe6d54ed3L, 0xe531068eL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-7.56827042671106338999e-03, 0xbff7, 0xf7ff40fcL, 0x2938b7feL), HEXCONSTE(-1.79273585753872803599e-03, 0xbff5, 0xeafa3bc1L, 0xca248cc8L), HEXCONSTE(-1.80338464113663849331e+00, 0xbfff, 0xe6d54ed3L, 0xe531062aL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-7.56827042671106338999e-03, 0xbff7, 0xf7ff40fcL, 0x2938b7feL), HEXCONSTE(-1.79273585753872803610e-03, 0xbff5, 0xeafa3bc1L, 0xca248cc9L), HEXCONSTE(-1.80338464113663849331e+00, 0xbfff, 0xe6d54ed3L, 0xe531062aL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-7.56827042671106339041e-03, 0xbff7, 0xf7ff40fcL, 0x2938b7ffL), HEXCONSTE(-1.79273576941341161728e-03, 0xbff5, 0xeafa3b00L, 0x00000000L), HEXCONSTE(-1.80338463011122353047e+00, 0xbfff, 0xe6d54ebcL, 0x37e7d06bL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-7.56827042671106339041e-03, 0xbff7, 0xf7ff40fcL, 0x2938b7ffL), HEXCONSTE(-1.79273588582873344421e-03, 0xbff5, 0xeafa3c00L, 0x00000000L), HEXCONSTE(-1.80338464467601923568e+00, 0xbfff, 0xe6d54edbL, 0x7efc9481L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-7.56827042671106339041e-03, 0xbff7, 0xf7ff40fcL, 0x2938b7ffL), HEXCONSTE(-1.79273585753872790639e-03, 0xbff5, 0xeafa3bc1L, 0xca248800L), HEXCONSTE(-1.80338464113663847705e+00, 0xbfff, 0xe6d54ed3L, 0xe5310594L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-7.56827042671106339041e-03, 0xbff7, 0xf7ff40fcL, 0x2938b7ffL), HEXCONSTE(-1.79273585753872812323e-03, 0xbff5, 0xeafa3bc1L, 0xca249000L), HEXCONSTE(-1.80338464113663850415e+00, 0xbfff, 0xe6d54ed3L, 0xe531068eL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-7.56827042671106339041e-03, 0xbff7, 0xf7ff40fcL, 0x2938b7ffL), HEXCONSTE(-1.79273585753872803599e-03, 0xbff5, 0xeafa3bc1L, 0xca248cc8L), HEXCONSTE(-1.80338464113663849331e+00, 0xbfff, 0xe6d54ed3L, 0xe531062aL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-7.56827042671106339041e-03, 0xbff7, 0xf7ff40fcL, 0x2938b7ffL), HEXCONSTE(-1.79273585753872803610e-03, 0xbff5, 0xeafa3bc1L, 0xca248cc9L), HEXCONSTE(-1.80338464113663849331e+00, 0xbfff, 0xe6d54ed3L, 0xe531062aL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(7.85398163397448309628e-01, 0x3ffe, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(7.85398223002089532305e-01, 0x3ffe, 0xc90fdba2L, 0x2167c235L), 0 },
	{ __LINE__, HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(7.85398223002089421283e-01, 0x3ffe, 0xc90fdba2L, 0x2167ba35L), 0 },
	{ __LINE__, HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(1.00000000000000001388e+00, 0x3fff, 0x80000000L, 0x00000080L), HEXCONSTE(7.85398223002089525366e-01, 0x3ffe, 0xc90fdba2L, 0x2167c1b5L), 0 },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(7.85398103792807086951e-01, 0x3ffe, 0xc90fd9a2L, 0x2169c235L), 0 },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(7.85398163397448309628e-01, 0x3ffe, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(7.85398163397448198606e-01, 0x3ffe, 0xc90fdaa2L, 0x2168ba35L), 0 },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000001388e+00, 0x3fff, 0x80000000L, 0x00000080L), HEXCONSTE(7.85398163397448302689e-01, 0x3ffe, 0xc90fdaa2L, 0x2168c1b5L), 0 },
	{ __LINE__, HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(7.85398103792807197974e-01, 0x3ffe, 0xc90fd9a2L, 0x2169ca35L), 0 },
	{ __LINE__, HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(7.85398163397448420651e-01, 0x3ffe, 0xc90fdaa2L, 0x2168ca35L), 0 },
	{ __LINE__, HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(7.85398163397448309628e-01, 0x3ffe, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(1.00000000000000001388e+00, 0x3fff, 0x80000000L, 0x00000080L), HEXCONSTE(7.85398163397448413712e-01, 0x3ffe, 0xc90fdaa2L, 0x2168c9b5L), 0 },
	{ __LINE__, HEXCONSTE(1.00000000000000001388e+00, 0x3fff, 0x80000000L, 0x00000080L), HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(7.85398103792807093890e-01, 0x3ffe, 0xc90fd9a2L, 0x2169c2b5L), 0 },
	{ __LINE__, HEXCONSTE(1.00000000000000001388e+00, 0x3fff, 0x80000000L, 0x00000080L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(7.85398163397448316567e-01, 0x3ffe, 0xc90fdaa2L, 0x2168c2b5L), 0 },
	{ __LINE__, HEXCONSTE(1.00000000000000001388e+00, 0x3fff, 0x80000000L, 0x00000080L), HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(7.85398163397448205545e-01, 0x3ffe, 0xc90fdaa2L, 0x2168bab5L), 0 },
	{ __LINE__, HEXCONSTE(1.00000000000000001388e+00, 0x3fff, 0x80000000L, 0x00000080L), HEXCONSTE(1.00000000000000001388e+00, 0x3fff, 0x80000000L, 0x00000080L), HEXCONSTE(7.85398163397448309628e-01, 0x3ffe, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(2.97733366489410400391e-01, 0x3ffd, 0x98708200L, 0x00000000L), HEXCONSTE(2.94902086257934570312e+00, 0x4000, 0xbcbcc200L, 0x00000000L), HEXCONSTE(1.00619130835590067886e-01, 0x3ffb, 0xce116722L, 0x53914e89L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.34686177141740692775e-11, 0xbfda, 0xecf14300L, 0x00000000L), HEXCONSTE(1.92693777600894122770e-10, 0x3fde, 0xd3de7a00L, 0x00000000L), HEXCONSTE(-6.97829905314132166973e-02, 0xbffb, 0x8eea6271L, 0x322bb4e9L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.33844155073165893555e-01, 0x3ffd, 0xaaed9f00L, 0x00000000L), HEXCONSTE(2.13242053985595703125e+00, 0x4000, 0x88799400L, 0x00000000L), HEXCONSTE(1.55295858732534312248e-01, 0x3ffc, 0x9f05e0a9L, 0xd785add1L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-2.60071814060211181641e-01, 0xbffd, 0x85282200L, 0x00000000L), HEXCONSTE(1.95491576194763183594e+00, 0x3fff, 0xfa3aae00L, 0x00000000L), HEXCONSTE(-1.32258195347048682869e-01, 0xbffc, 0x876eb13eL, 0x92ffadd4L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.12232970000000000000e+07, 0xc016, 0xab410100L, 0x00000000L), HEXCONSTE(-9.75658893585205078125e-01, 0xbffe, 0xf9c4c800L, 0x00000000L), HEXCONSTE(-1.57079641372647239286e+00, 0xbfff, 0xc90fdb5cL, 0xd08c644bL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.59059637784957885742e-01, 0x3ffd, 0x84a37700L, 0x00000000L), HEXCONSTE(7.25263071060180664062e+00, 0x4001, 0xe8158d00L, 0x00000000L), HEXCONSTE(3.57042232556216916333e-02, 0x3ffa, 0x923e9773L, 0x6442d916L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.77165737558791946240e+20, 0x4043, 0xa391cf00L, 0x00000000L), HEXCONSTE(3.01923007868778315776e+21, 0x4046, 0xa3ac3c00L, 0x00000000L), HEXCONSTE(1.24277371224459421689e-01, 0x3ffb, 0xfe852268L, 0x55d2207aL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-4.18084383010864257812e-01, 0xbffd, 0xd60f2800L, 0x00000000L), HEXCONSTE(3.56227183341979980469e+00, 0x4000, 0xe3fc4300L, 0x00000000L), HEXCONSTE(-1.16830070183738940311e-01, 0xbffb, 0xef449a95L, 0x0741cb1aL), FLAG_INEXACT },
	{ __LINE__, ZERO_M, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), ZERO_M, FLAG_FAIL_ARANYM2 },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-4.11804631702911102964e-84, 0xbeea, 0x80000080L, 0x00008000L), 0 },
	{ __LINE__, HEXCONSTE(-8.02893081072683142234e-218, 0xbd2d, 0xe2bcf5e1L, 0x42f01800L), HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-2.35949084342471338272e-256, 0xbcad, 0xe2bcf6c3L, 0xffe6dc00L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.94310092926025390625e+00, 0x4000, 0xfc5bc400L, 0x00000000L), HEXCONSTE(-1.32959496974945068359e+00, 0xbfff, 0xaa302b00L, 0x00000000L), HEXCONSTE(1.89601858507516756217e+00, 0x3fff, 0xf2b0bcabL, 0xc0c5dd9dL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-9.64841859740772633813e-08, 0xbfe7, 0xcf32be00L, 0x00000000L), HEXCONSTE(1.61045781338397045457e-15, 0x3fcd, 0xe8176800L, 0x00000000L), HEXCONSTE(-1.57079631010347929392e+00, 0xbfff, 0xc90fda7eL, 0x49349b6fL), 0 },
	{ __LINE__, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(7.85398163397448309628e-01, 0x3ffe, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), FLAG_INEXACT },
#endif
	{ __LINE__, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(1.89288349786683953756e-270, 0x3c7f, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(7.85398163397448309628e-01, 0x3ffe, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), FLAG_INEXACT },
#endif
	{ __LINE__, HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(1.11022302462515654042e-16, 0x3fca, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(2.86016103842627471037e-4894, 0x007f, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(1.51100743476790622808e-4624, 0x03ff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(7.85398163397448309628e-01, 0x3ffe, 0xc90fdaa2L, 0x2168c235L), 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(1.10714871779409050297e+00, 0x3fff, 0x8db70c97L, 0x5df22363L), 0 },
#endif
	{ __LINE__, HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(1.67755524445912377116e-4640, 0x03ca, 0x80000000L, 0x00000000L), 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(1.43008051921313735518e-4894, 0x007e, 0x80000000L, 0x00000000L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(7.55503717383953114038e-4625, 0x03fe, 0x80000000L, 0x00000000L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(4.63647609000806116202e-01, 0x3ffd, 0xed63382bL, 0x0dda7b45L), 0 },
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(7.85398163397448309628e-01, 0x3ffe, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(8.38777622229561885579e-4641, 0x03c9, 0x80000000L, 0x00000000L), FLAG_INEXACT },
#endif
	{ __LINE__, HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(1.70495788312977192029e-254, 0x3cb4, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489650823e+00, 0x3fff, 0xc90fdaa2L, 0x2168be35L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
#endif
	{ __LINE__, HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(7.85398163397448309628e-01, 0x3ffe, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(2.35619449019234492894e+00, 0x4000, 0x96cbe3f9L, 0x990e91a8L), 0 },
	{ __LINE__, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
#endif
	{ __LINE__, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(2.35619449019234492894e+00, 0x4000, 0x96cbe3f9L, 0x990e91a8L), 0 },
	{ __LINE__, HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
#endif
	{ __LINE__, HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(3.14159265358979312749e+00, 0x4000, 0xc90fdaa2L, 0x2168c035L), 0 },
	{ __LINE__, HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(2.35619449019234492894e+00, 0x4000, 0x96cbe3f9L, 0x990e91a8L), 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(2.03444393579570273543e+00, 0x4000, 0x82345456L, 0x726fb083L), 0 },
#endif
	{ __LINE__, HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(2.67794504458898712223e+00, 0x4000, 0xab63739cL, 0xbfad72ccL), 0 },
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(2.35619449019234492894e+00, 0x4000, 0x96cbe3f9L, 0x990e91a8L), 0 },
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
#endif
	{ __LINE__, HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489673028e+00, 0x3fff, 0xc90fdaa2L, 0x2168c635L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
#endif
	{ __LINE__, HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(2.35619449019234492894e+00, 0x4000, 0x96cbe3f9L, 0x990e91a8L), 0 },
	{ __LINE__, HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(-7.85398163397448309628e-01, 0xbffe, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.89288349786683953756e-270, 0xbc7f, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(-7.85398163397448309628e-01, 0xbffe, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(-1.11022302462515654042e-16, 0xbfca, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(-2.86016103842627471037e-4894, 0x807f, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(-1.51100743476790622808e-4624, 0x83ff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(-7.85398163397448309628e-01, 0xbffe, 0xc90fdaa2L, 0x2168c235L), 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.10714871779409050297e+00, 0xbfff, 0x8db70c97L, 0x5df22363L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(-1.67755524445912377116e-4640, 0x83ca, 0x80000000L, 0x00000000L), 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.43008051921313735518e-4894, 0x807e, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(-7.55503717383953114038e-4625, 0x83fe, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(-4.63647609000806116202e-01, 0xbffd, 0xed63382bL, 0x0dda7b45L), 0 },
	{ __LINE__, HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(-7.85398163397448309628e-01, 0xbffe, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(-8.38777622229561885579e-4641, 0x83c9, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.70495788312977192029e-254, 0xbcb4, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489650823e+00, 0xbfff, 0xc90fdaa2L, 0x2168be35L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(-7.85398163397448309628e-01, 0xbffe, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-2.35619449019234492894e+00, 0xc000, 0x96cbe3f9L, 0x990e91a8L), 0 },
	{ __LINE__, HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-2.35619449019234492894e+00, 0xc000, 0x96cbe3f9L, 0x990e91a8L), 0 },
	{ __LINE__, HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-3.14159265358979312749e+00, 0xc000, 0xc90fdaa2L, 0x2168c035L), 0 },
	{ __LINE__, HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-2.35619449019234492894e+00, 0xc000, 0x96cbe3f9L, 0x990e91a8L), 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-2.03444393579570273543e+00, 0xc000, 0x82345456L, 0x726fb083L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-2.67794504458898712223e+00, 0xc000, 0xab63739cL, 0xbfad72ccL), 0 },
	{ __LINE__, HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-2.35619449019234492894e+00, 0xc000, 0x96cbe3f9L, 0x990e91a8L), 0 },
	{ __LINE__, HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489673028e+00, 0xbfff, 0xc90fdaa2L, 0x2168c635L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-2.35619449019234492894e+00, 0xc000, 0x96cbe3f9L, 0x990e91a8L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(7.85398163397448309628e-01, 0x3ffe, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), SUBNORM_P, HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(3.52577026536099526576e-279, 0x3c62, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(7.85398163397448309628e-01, 0x3ffe, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), SUBNORM_P, HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
	{ __LINE__, SUBNORM_P, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.30065065533302672992e-4906, 0x0056, 0x80000000L, 0x00000000L), FLAG_SUBNORM },
	{ __LINE__, SUBNORM_P, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(3.68898299503883356464e-4628, 0x03f3, 0x80000000L, 0x00000000L), FLAG_SUBNORM },
	{ __LINE__, SUBNORM_P, SUBNORM_P, HEXCONSTE(7.85398163397448309628e-01, 0x3ffe, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(2.35619449019234492894e+00, 0x4000, 0x96cbe3f9L, 0x990e91a8L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), SUBNORM_M, HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(2.35619449019234492894e+00, 0x4000, 0x96cbe3f9L, 0x990e91a8L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), SUBNORM_M, HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
	{ __LINE__, SUBNORM_P, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
	{ __LINE__, SUBNORM_P, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
	{ __LINE__, SUBNORM_P, SUBNORM_M, HEXCONSTE(2.35619449019234492894e+00, 0x4000, 0x96cbe3f9L, 0x990e91a8L), FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(-7.85398163397448309628e-01, 0xbffe, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), SUBNORM_P, HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(-3.52577026536099526576e-279, 0xbc62, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(-7.85398163397448309628e-01, 0xbffe, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), SUBNORM_P, HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.30065065533302672992e-4906, 0x8056, 0x80000000L, 0x00000000L), FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(-3.68898299503883356464e-4628, 0x83f3, 0x80000000L, 0x00000000L), FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, SUBNORM_P, HEXCONSTE(-7.85398163397448309628e-01, 0xbffe, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-2.35619449019234492894e+00, 0xc000, 0x96cbe3f9L, 0x990e91a8L), 0 },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), SUBNORM_M, HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-2.35619449019234492894e+00, 0xc000, 0x96cbe3f9L, 0x990e91a8L), 0 },
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), SUBNORM_M, HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, SUBNORM_M, HEXCONSTE(-2.35619449019234492894e+00, 0xc000, 0x96cbe3f9L, 0x990e91a8L), FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079620758560706848e+00, 0x3fff, 0xc90fd9a2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), SUBNORM_P, HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.58786576532737530795e-263, 0x3c96, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489639721e+00, 0x3fff, 0xc90fdaa2L, 0x2168ba35L), 0 },
	{ __LINE__, HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), SUBNORM_P, HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(2.39927697682309554456e-4887, 0x0096, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(6.80497252017479153089e-4609, 0x0433, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), SUBNORM_P, HEXCONSTE(1.57079632679489661915e+00, 0x3fff, 0xc90fdaa2L, 0x2168c234L), FLAG_SUBNORM },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.19963848841154777228e-4887, 0x0095, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(3.40248626008739576544e-4609, 0x0432, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), SUBNORM_P, HEXCONSTE(1.57079632679489661915e+00, 0x3fff, 0xc90fdaa2L, 0x2168c234L), FLAG_SUBNORM },
#endif
	{ __LINE__, HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.43022233380854697687e-247, 0x3ccb, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), SUBNORM_P, HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079644600418617004e+00, 0x3fff, 0xc90fdba2L, 0x2168c235L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), SUBNORM_M, HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489684130e+00, 0x3fff, 0xc90fdaa2L, 0x2168ca35L), 0 },
	{ __LINE__, HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), SUBNORM_M, HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), SUBNORM_M, HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), SUBNORM_M, HEXCONSTE(1.57079632679489661936e+00, 0x3fff, 0xc90fdaa2L, 0x2168c236L), FLAG_SUBNORM },
#endif
	{ __LINE__, HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), SUBNORM_M, HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079620758560706848e+00, 0xbfff, 0xc90fd9a2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), SUBNORM_P, HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.58786576532737530795e-263, 0xbc96, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489639721e+00, 0xbfff, 0xc90fdaa2L, 0x2168ba35L), 0 },
	{ __LINE__, HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), SUBNORM_P, HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(-2.39927697682309554456e-4887, 0x8096, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(-6.80497252017479153089e-4609, 0x8433, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), SUBNORM_P, HEXCONSTE(-1.57079632679489661915e+00, 0xbfff, 0xc90fdaa2L, 0x2168c234L), FLAG_SUBNORM },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.19963848841154777228e-4887, 0x8095, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(-3.40248626008739576544e-4609, 0x8432, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), SUBNORM_P, HEXCONSTE(-1.57079632679489661915e+00, 0xbfff, 0xc90fdaa2L, 0x2168c234L), FLAG_SUBNORM },
#endif
	{ __LINE__, HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.43022233380854697687e-247, 0xbccb, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), SUBNORM_P, HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079644600418617004e+00, 0xbfff, 0xc90fdba2L, 0x2168c235L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), SUBNORM_M, HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489684130e+00, 0xbfff, 0xc90fdaa2L, 0x2168ca35L), 0 },
	{ __LINE__, HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), SUBNORM_M, HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), SUBNORM_M, HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), SUBNORM_M, HEXCONSTE(-1.57079632679489661936e+00, 0xbfff, 0xc90fdaa2L, 0x2168c236L), FLAG_SUBNORM },
#endif
	{ __LINE__, HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), SUBNORM_M, HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(1.19209289550780685314e-07, 0x3fe7, 0xffffffffL, 0xfffeaaabL), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
#endif
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(4.20304568452953727932e-286, 0x3c4b, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(2.22044604925031308085e-16, 0x3fcb, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
#endif
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(2.46519032881566189191e-32, 0x3f96, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, SUBNORM_P, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(1.55049640576008168449e-4913, 0x003f, 0x80000000L, 0x00000000L), FLAG_SUBNORM },
	{ __LINE__, SUBNORM_P, HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(8.19118771708556528886e-4644, 0x03bf, 0x80000000L, 0x00000000L), FLAG_SUBNORM },
	{ __LINE__, SUBNORM_P, HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(5.42101086242752217004e-20, 0x3fbf, 0x80000000L, 0x00000000L), FLAG_SUBNORM },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, SUBNORM_P, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(1.08420217248550443401e-19, 0x3fc0, 0x80000000L, 0x00000000L), FLAG_SUBNORM },
#endif
	{ __LINE__, SUBNORM_P, HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(9.09404520253516733692e-4660, 0x038a, 0x80000000L, 0x00000000L), FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(3.14159253438050368773e+00, 0x4000, 0xc90fda22L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
#endif
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(3.14159265358979301647e+00, 0x4000, 0xc90fdaa2L, 0x2168be35L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
#endif
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, SUBNORM_P, HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
	{ __LINE__, SUBNORM_P, HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
	{ __LINE__, SUBNORM_P, HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, SUBNORM_P, HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(3.14159265358979323830e+00, 0x4000, 0xc90fdaa2L, 0x2168c234L), FLAG_SUBNORM },
#endif
	{ __LINE__, SUBNORM_P, HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.19209289550780685314e-07, 0xbfe7, 0xffffffffL, 0xfffeaaabL), 0 },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(-4.20304568452953727932e-286, 0xbc4b, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(-2.22044604925031308085e-16, 0xbfcb, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(-2.46519032881566189191e-32, 0xbf96, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, SUBNORM_M, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.55049640576008168449e-4913, 0x803f, 0x80000000L, 0x00000000L), FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(-8.19118771708556528886e-4644, 0x83bf, 0x80000000L, 0x00000000L), FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(-5.42101086242752217004e-20, 0xbfbf, 0x80000000L, 0x00000000L), FLAG_SUBNORM },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, SUBNORM_M, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.08420217248550443401e-19, 0xbfc0, 0x80000000L, 0x00000000L), FLAG_SUBNORM },
#endif
	{ __LINE__, SUBNORM_M, HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(-9.09404520253516733692e-4660, 0x838a, 0x80000000L, 0x00000000L), FLAG_SUBNORM},
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-3.14159253438050368773e+00, 0xc000, 0xc90fda22L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-3.14159265358979301647e+00, 0xc000, 0xc90fdaa2L, 0x2168be35L), 0 },
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, SUBNORM_M, HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, SUBNORM_M, HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-3.14159265358979323830e+00, 0xc000, 0xc90fdaa2L, 0x2168c234L), FLAG_SUBNORM },
#endif
	{ __LINE__, SUBNORM_M, HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
#endif
	{ __LINE__, HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, SUBNORM_P, HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
	{ __LINE__, SUBNORM_P, HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, SUBNORM_M, HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(2.93873605221803725101e-39, 0x3f7f, 0x80000080L, 0x00008000L), 0 },
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(5.56268464626800407531e-309, 0x3bff, 0x80000000L, 0x00000400L), FLAG_INEXACT },
#endif
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(8.40525785778023376566e-4933, 0x0000, 0x20000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-2.93873605221803725101e-39, 0xbf7f, 0x80000080L, 0x00008000L), 0 },
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-5.56268464626800407531e-309, 0xbbff, 0x80000000L, 0x00000400L), FLAG_INEXACT },
#endif
	{ __LINE__, HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-8.40525785778023376566e-4933, 0x8000, 0x20000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(3.45446762794009370161e-77, 0x3f01, 0x80000080L, 0x00008000L), 0 },
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(6.53890437709391347170e-347, 0x3b81, 0x80000000L, 0x00000400L), FLAG_INEXACT },
#endif
	{ __LINE__, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), ZERO_P, 0 },
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(6.53890476684300859352e-347, 0x3b81, 0x80000080L, 0x00008000L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.23773841895303144761e-616, 0x3801, 0x80000000L, 0x00000400L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), ZERO_P, 0 },
#endif
	{ __LINE__, HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), ZERO_P, 0 },
	{ __LINE__, HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), ZERO_P, 0 },
	{ __LINE__, HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), ZERO_P, 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), ZERO_P, 0 },
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), ZERO_P, 0 },
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), ZERO_P, 0 },
#endif
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(5.88972181427306670596e-331, 0x3bb6, 0x80000080L, 0x00008000L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.11485565647580385825e-600, 0x3836, 0x80000000L, 0x00000400L), FLAG_INEXACT },
#endif
	{ __LINE__, HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), ZERO_P, 0 },
	{ __LINE__, HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-3.45446762794009370161e-77, 0xbf01, 0x80000080L, 0x00008000L), 0 },
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-6.53890437709391347170e-347, 0xbb81, 0x80000000L, 0x00000400L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), ZERO_M, 0 },
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-6.53890476684300859352e-347, 0xbb81, 0x80000080L, 0x00008000L), 0 },
	{ __LINE__, HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.23773841895303144761e-616, 0xb801, 0x80000000L, 0x00000400L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), ZERO_M, 0 },
	{ __LINE__, HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), ZERO_M, 0 },
	{ __LINE__, HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), ZERO_M, 0 },
	{ __LINE__, HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), ZERO_M, 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), ZERO_M, 0 },
	{ __LINE__, HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), ZERO_M, 0 },
	{ __LINE__, HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), ZERO_M, 0 },
#endif
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-5.88972181427306670596e-331, 0xbbb6, 0x80000080L, 0x00008000L), 0 },
	{ __LINE__, HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.11485565647580385825e-600, 0xb836, 0x80000000L, 0x00000400L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), ZERO_M, 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(4.11804631702911102964e-84, 0x3eea, 0x80000080L, 0x00008000L), 0 },
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(7.79498145233859237635e-354, 0x3b6a, 0x80000000L, 0x00000400L), 0 },
#endif
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), ZERO_P, 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.45192852559605980323e-362, 0x3b4d, 0x80000080L, 0x00008000L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(2.74833138236958751135e-632, 0x37cd, 0x80000000L, 0x00000400L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), ZERO_P, 0 },
	{ __LINE__, SUBNORM_P, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), ZERO_P, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_P, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), ZERO_P, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_P, HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), ZERO_P, FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-4.11804631702911102964e-84, 0xbeea, 0x80000080L, 0x00008000L), 0 },
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-7.79498145233859237635e-354, 0xbb6a, 0x80000000L, 0x00000400L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), ZERO_M, 0 },
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.45192852559605980323e-362, 0xbb4d, 0x80000080L, 0x00008000L), 0 },
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-2.74833138236958751135e-632, 0xb7cd, 0x80000000L, 0x00000400L), 0 },
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), ZERO_M, 0 },
	{ __LINE__, SUBNORM_M, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), ZERO_M, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), ZERO_M, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), ZERO_M, FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, SUBNORM_P, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), ZERO_P, FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, SUBNORM_M, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), ZERO_M, FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
#endif
	{ __LINE__, HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, SUBNORM_P, HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, SUBNORM_M, HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },

#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(2.60130131066605345983e-4906, 0x0057, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(7.37796599007766712928e-4628, 0x03f4, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(7.85398163397448309628e-01, 0x3ffe, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), SUBNORM_P, HEXCONSTE(1.10714871779409050297e+00, 0x3fff, 0x8db70c97L, 0x5df22363L), FLAG_SUBNORM },
	{ __LINE__, SUBNORM_P, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(4.63647609000806116202e-01, 0x3ffd, 0xed63382bL, 0x0dda7b45L), FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(2.35619449019234492894e+00, 0x4000, 0x96cbe3f9L, 0x990e91a8L), 0 },
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), SUBNORM_M, HEXCONSTE(2.03444393579570273543e+00, 0x4000, 0x82345456L, 0x726fb083L), FLAG_SUBNORM },
	{ __LINE__, SUBNORM_P, HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(2.67794504458898712223e+00, 0x4000, 0xab63739cL, 0xbfad72ccL), FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(-2.60130131066605345983e-4906, 0x8057, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(-7.37796599007766712928e-4628, 0x83f4, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(-7.85398163397448309628e-01, 0xbffe, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), SUBNORM_P, HEXCONSTE(-1.10714871779409050297e+00, 0xbfff, 0x8db70c97L, 0x5df22363L), FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(-4.63647609000806116202e-01, 0xbffd, 0xed63382bL, 0x0dda7b45L), FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(-2.35619449019234492894e+00, 0xc000, 0x96cbe3f9L, 0x990e91a8L), 0 },
	{ __LINE__, HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), SUBNORM_M, HEXCONSTE(-2.03444393579570273543e+00, 0xc000, 0x82345456L, 0x726fb083L), FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(-2.67794504458898712223e+00, 0xc000, 0xab63739cL, 0xbfad72ccL), FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(1.57079632679489661915e+00, 0x3fff, 0xc90fdaa2L, 0x2168c234L), 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(1.57079632679489661904e+00, 0x3fff, 0xc90fdaa2L, 0x2168c233L), 0 },
#endif
	{ __LINE__, HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(1.57079632679489661936e+00, 0x3fff, 0xc90fdaa2L, 0x2168c236L), 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(1.57079632679489661947e+00, 0x3fff, 0xc90fdaa2L, 0x2168c237L), 0 },
#endif
	{ __LINE__, HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(-1.57079632679489661915e+00, 0xbfff, 0xc90fdaa2L, 0x2168c234L), 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(-1.57079632679489661904e+00, 0xbfff, 0xc90fdaa2L, 0x2168c233L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(-1.57079632679489661936e+00, 0xbfff, 0xc90fdaa2L, 0x2168c236L), 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(-1.57079632679489661947e+00, 0xbfff, 0xc90fdaa2L, 0x2168c237L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(3.10099281152016336898e-4913, 0x0040, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(1.63823754341711305777e-4643, 0x03c0, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(1.08420217248550443401e-19, 0x3fc0, 0x80000000L, 0x00000000L), 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(2.16840434497100886801e-19, 0x3fc1, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(1.81880904050703346738e-4659, 0x038b, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(3.14159265358979323830e+00, 0x4000, 0xc90fdaa2L, 0x2168c234L), 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(3.14159265358979323830e+00, 0x4000, 0xc90fdaa2L, 0x2168c234L), 0 },
#endif
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L) },
	{ __LINE__, HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(-3.10099281152016336898e-4913, 0x8040, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(-1.63823754341711305777e-4643, 0x83c0, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(-1.08420217248550443401e-19, 0xbfc0, 0x80000000L, 0x00000000L), 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(-2.16840434497100886801e-19, 0xbfc1, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(-1.81880904050703346738e-4659, 0x838b, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-3.14159265358979323830e+00, 0xc000, 0xc90fdaa2L, 0x2168c234L), 0 },
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-3.14159265358979323830e+00, 0xc000, 0xc90fdaa2L, 0x2168c234L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, SUBNORM_P, HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), ZERO_P, 0 },
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), ZERO_P, 0 },
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), ZERO_P, 0 },
	{ __LINE__, HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), ZERO_M, 0 },
	{ __LINE__, HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), ZERO_M, 0 },
	{ __LINE__, HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), ZERO_M, 0 },
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), 0 },
	{ __LINE__, HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), 0 },
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), 0 },
	{ __LINE__, HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), 0 },
#endif
};

int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_ff_f(fatan2_data, ARRAY_SIZE(fatan2_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

```

`tests/atanh.c`:

```c
#include "testconfig.h"
#define TEST_FUNC_F_F __MATH_PRECNAME(atanh)
#include "testdriver.h"



static test_f_f_data const fatanh_data[] = {
	{ __LINE__, ZERO_P, ZERO_P, 0 },
	{ __LINE__, ZERO_M, ZERO_M, FLAG_FAIL_ARANYM2 },
	{ __LINE__, INF_P, QNAN_P, 0 },
	{ __LINE__, INF_M, QNAN_P, 0 },
	{ __LINE__, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_P, 0 },
	{ __LINE__, SNAN_P, QNAN_P, 0 },
	{ __LINE__, SNAN_M, QNAN_P, 0 },

	{ __LINE__, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), INF_M, 0 },
	
	/* atanh (x) == qNaN plus invalid exception if |x| > 1.  */
	{ __LINE__, HEXCONSTE(1.125L, 0x3fff, 0x90000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__, HEXCONSTE(-1.125L, 0xbfff, 0x90000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__, MAX_P, QNAN_P, 0 },
	{ __LINE__, MAX_M, QNAN_P, 0 },
	{ __LINE__, INF_P, QNAN_P, 0 },
	{ __LINE__, INF_M, QNAN_P, 0 },

	{ __LINE__, HEXCONSTE(7.50000000000000000000e-01, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(9.72955074527656652527e-01, 0x3ffe, 0xf9139571L, 0x92d2baa3L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-7.50000000000000000000e-01, 0xbffe, 0xc0000000L, 0x00000000L), HEXCONSTE(-9.72955074527656652527e-01, 0xbffe, 0xf9139571L, 0x92d2baa3L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.50000000000000000000e-01, 0x3ffd, 0x80000000L, 0x00000000L), HEXCONSTE(2.55412811882995341596e-01, 0x3ffd, 0x82c577d4L, 0x08a28d39L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(3.12500000000000000000e-02, 0x3ffa, 0x80000000L, 0x00000000L), HEXCONSTE(3.12601784906669947630e-02, 0x3ffa, 0x800aac44L, 0x8d77125aL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(9.76562500000000000000e-04, 0x3ff5, 0x80000000L, 0x00000000L), HEXCONSTE(9.76562810441035840921e-04, 0x3ff5, 0x800002aaL, 0xaac44445L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(1.08506355900317430496e-06, 0x3feb, 0x91a28000L, 0x00000000L), HEXCONSTE(1.08506355900360014281e-06, 0x3feb, 0x91a28000L, 0x003ed7b3L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(3.90625000000000000000e-03, 0x3ff7, 0x80000000L, 0x00000000L), HEXCONSTE(3.90626986839682605293e-03, 0x3ff7, 0x80002aaaL, 0xc444568dL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(1.95312500000000000000e-03, 0x3ff6, 0x80000000L, 0x00000000L), HEXCONSTE(1.95312748353254999856e-03, 0x3ff6, 0x80000aaaL, 0xac44448dL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(9.76562500000000000000e-04, 0x3ff5, 0x80000000L, 0x00000000L), HEXCONSTE(9.76562810441035840921e-04, 0x3ff5, 0x800002aaL, 0xaac44445L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(4.88281250000000000000e-04, 0x3ff4, 0x80000000L, 0x00000000L), HEXCONSTE(4.88281288805112826746e-04, 0x3ff4, 0x800000aaL, 0xaaac4444L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(2.44140625000000000000e-04, 0x3ff3, 0x80000000L, 0x00000000L), HEXCONSTE(2.44140629850638582921e-04, 0x3ff3, 0x8000002aL, 0xaaaac444L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(1.22070312500000000000e-04, 0x3ff2, 0x80000000L, 0x00000000L), HEXCONSTE(1.22070313106329806599e-04, 0x3ff2, 0x8000000aL, 0xaaaaac44L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(5.96046447753906250000e-08, 0x3fe7, 0x80000000L, 0x00000000L), HEXCONSTE(5.96046447753906955882e-08, 0x3fe7, 0x80000000L, 0x00002aabL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(2.98023223876953125000e-08, 0x3fe6, 0x80000000L, 0x00000000L), HEXCONSTE(2.98023223876953213243e-08, 0x3fe6, 0x80000000L, 0x00000aabL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(1.49011611938476562500e-08, 0x3fe5, 0x80000000L, 0x00000000L), HEXCONSTE(1.49011611938476573534e-08, 0x3fe5, 0x80000000L, 0x000002abL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.45058059692382812500e-09, 0x3fe4, 0x80000000L, 0x00000000L), HEXCONSTE(7.45058059692382826313e-09, 0x3fe4, 0x80000000L, 0x000000abL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(3.72529029846191406250e-09, 0x3fe3, 0x80000000L, 0x00000000L), HEXCONSTE(3.72529029846191407987e-09, 0x3fe3, 0x80000000L, 0x0000002bL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(1.86264514923095703125e-09, 0x3fe2, 0x80000000L, 0x00000000L), HEXCONSTE(1.86264514923095703347e-09, 0x3fe2, 0x80000000L, 0x0000000bL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(9.31322574615478515625e-10, 0x3fe1, 0x80000000L, 0x00000000L), HEXCONSTE(9.31322574615478515928e-10, 0x3fe1, 0x80000000L, 0x00000003L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(4.65661287307739257812e-10, 0x3fe0, 0x80000000L, 0x00000000L), HEXCONSTE(4.65661287307739257863e-10, 0x3fe0, 0x80000000L, 0x00000001L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(2.32830643653869628906e-10, 0x3fdf, 0x80000000L, 0x00000000L), HEXCONSTE(2.32830643653869628906e-10, 0x3fdf, 0x80000000L, 0x00000000L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(1.16415321826934814453e-10, 0x3fde, 0x80000000L, 0x00000000L), HEXCONSTE(1.16415321826934814453e-10, 0x3fde, 0x80000000L, 0x00000000L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(3.55271367880050092936e-15, 0x3fcf, 0x80000000L, 0x00000000L), HEXCONSTE(3.55271367880050092936e-15, 0x3fcf, 0x80000000L, 0x00000000L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(1.77635683940025046468e-15, 0x3fce, 0x80000000L, 0x00000000L), HEXCONSTE(1.77635683940025046468e-15, 0x3fce, 0x80000000L, 0x00000000L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(8.88178419700125232339e-16, 0x3fcd, 0x80000000L, 0x00000000L), HEXCONSTE(8.88178419700125232339e-16, 0x3fcd, 0x80000000L, 0x00000000L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(4.44089209850062616169e-16, 0x3fcc, 0x80000000L, 0x00000000L), HEXCONSTE(4.44089209850062616169e-16, 0x3fcc, 0x80000000L, 0x00000000L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(2.22044604925031308085e-16, 0x3fcb, 0x80000000L, 0x00000000L), HEXCONSTE(2.22044604925031308085e-16, 0x3fcb, 0x80000000L, 0x00000000L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(1.11022302462515654042e-16, 0x3fca, 0x80000000L, 0x00000000L), HEXCONSTE(1.11022302462515654042e-16, 0x3fca, 0x80000000L, 0x00000000L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(5.55111512312578270212e-17, 0x3fc9, 0x80000000L, 0x00000000L), HEXCONSTE(5.55111512312578270212e-17, 0x3fc9, 0x80000000L, 0x00000000L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(2.77555756156289135106e-17, 0x3fc8, 0x80000000L, 0x00000000L), HEXCONSTE(2.77555756156289135106e-17, 0x3fc8, 0x80000000L, 0x00000000L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(1.38777878078144567553e-17, 0x3fc7, 0x80000000L, 0x00000000L), HEXCONSTE(1.38777878078144567553e-17, 0x3fc7, 0x80000000L, 0x00000000L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(6.93889390390722837765e-18, 0x3fc6, 0x80000000L, 0x00000000L), HEXCONSTE(6.93889390390722837765e-18, 0x3fc6, 0x80000000L, 0x00000000L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(3.46944695195361418882e-18, 0x3fc5, 0x80000000L, 0x00000000L), HEXCONSTE(3.46944695195361418882e-18, 0x3fc5, 0x80000000L, 0x00000000L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(1.73472347597680709441e-18, 0x3fc4, 0x80000000L, 0x00000000L), HEXCONSTE(1.73472347597680709441e-18, 0x3fc4, 0x80000000L, 0x00000000L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.88860905221011805412e-31, 0x3f9b, 0x80000000L, 0x00000000L), HEXCONSTE(7.88860905221011805412e-31, 0x3f9b, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-7.88860905221011805412e-31, 0xbf9b, 0x80000000L, 0x00000000L), HEXCONSTE(-7.88860905221011805412e-31, 0xbf9b, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.40991986510288411774e-181, 0x3da7, 0x80000000L, 0x00000000L), HEXCONSTE(2.40991986510288411774e-181, 0x3da7, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-2.40991986510288411774e-181, 0xbda7, 0x80000000L, 0x00000000L), HEXCONSTE(-2.40991986510288411774e-181, 0xbda7, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(5.01237274920645200930e-3011, 0x18ef, 0x80000000L, 0x00000000L), HEXCONSTE(5.01237274920645200930e-3011, 0x18ef, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-5.01237274920645200930e-3011, 0x98ef, 0x80000000L, 0x00000000L), HEXCONSTE(-5.01237274920645200930e-3011, 0x98ef, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(8.66433974209815495164e+00, 0x4002, 0x8aa122b5L, 0x9bea160eL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-8.66433974209815495164e+00, 0xc002, 0x8aa122b5L, 0x9bea160eL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(8.66433974209815495164e+00, 0x4002, 0x8aa122b5L, 0x9bea160eL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.99999999883584678173e-01, 0x3ffe, 0xffffffffL, 0x80000000L), HEXCONSTE(1.17835020694899664300e+01, 0x4002, 0xbc893977L, 0x4cec7147L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-8.66433974209815495164e+00, 0xc002, 0x8aa122b5L, 0x9bea160eL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-9.99999999883584678173e-01, 0xbffe, 0xffffffffL, 0x80000000L), HEXCONSTE(-1.17835020694899664300e+01, 0xc002, 0xbc893977L, 0x4cec7147L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(8.66433974209815495164e+00, 0x4002, 0x8aa122b5L, 0x9bea160eL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.99999999999996447286e-01, 0x3ffe, 0xffffffffL, 0xffff0000L), HEXCONSTE(1.69821059237186591934e+01, 0x4003, 0x87db5a59L, 0xbca2d728L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-8.66433974209815495164e+00, 0xc002, 0x8aa122b5L, 0x9bea160eL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-9.99999999999996447286e-01, 0xbffe, 0xffffffffL, 0xffff0000L), HEXCONSTE(-1.69821059237186591934e+01, 0xc003, 0x87db5a59L, 0xbca2d728L), FLAG_INEXACT },
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(8.66433974209815495164e+00, 0x4002, 0x8aa122b5L, 0x9bea160eL), 0 },
	{ __LINE__, HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.87149738751185233266e+01, 0x4003, 0x95b84439L, 0x19070e99L), 0 },
	{ __LINE__, HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-8.66433974209815495164e+00, 0xc002, 0x8aa122b5L, 0x9bea160eL), 0 },
	{ __LINE__, HEXCONSTE(-9.99999999999999888978e-01, 0xbffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.87149738751185233266e+01, 0xc003, 0x95b84439L, 0x19070e99L), 0 },
	{ __LINE__, HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(8.66433974209815495164e+00, 0x4002, 0x8aa122b5L, 0x9bea160eL), 0 },
	{ __LINE__, HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.87149738751185233266e+01, 0x4003, 0x95b84439L, 0x19070e99L), 0 },
	{ __LINE__, HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(2.25272833681982225552e+01, 0x4003, 0xb437e057L, 0xb116b792L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-8.66433974209815495164e+00, 0xc002, 0x8aa122b5L, 0x9bea160eL), 0 },
	{ __LINE__, HEXCONSTE(-9.99999999999999888978e-01, 0xbffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.87149738751185233266e+01, 0xc003, 0x95b84439L, 0x19070e99L), 0 },
	{ __LINE__, HEXCONSTE(-9.99999999999999999946e-01, 0xbffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-2.25272833681982225552e+01, 0xc003, 0xb437e057L, 0xb116b792L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(8.66433974209815495164e+00, 0x4002, 0x8aa122b5L, 0x9bea160eL), 0 },
	{ __LINE__, HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.87149738751185233266e+01, 0x4003, 0x95b84439L, 0x19070e99L), 0 },
	{ __LINE__, HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(2.25272833681982225552e+01, 0x4003, 0xb437e057L, 0xb116b792L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-8.66433974209815495164e+00, 0xc002, 0x8aa122b5L, 0x9bea160eL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-9.99999999999999888978e-01, 0xbffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.87149738751185233266e+01, 0xc003, 0x95b84439L, 0x19070e99L), 0 },
	{ __LINE__, HEXCONSTE(-9.99999999999999999946e-01, 0xbffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-2.25272833681982225552e+01, 0xc003, 0xb437e057L, 0xb116b792L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(8.66433974209815495164e+00, 0x4002, 0x8aa122b5L, 0x9bea160eL), 0 },
	{ __LINE__, HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.87149738751185233266e+01, 0x4003, 0x95b84439L, 0x19070e99L), 0 },
	{ __LINE__, HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(2.25272833681982225552e+01, 0x4003, 0xb437e057L, 0xb116b792L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-8.66433974209815495164e+00, 0xc002, 0x8aa122b5L, 0x9bea160eL), 0 },
	{ __LINE__, HEXCONSTE(-9.99999999999999888978e-01, 0xbffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.87149738751185233266e+01, 0xc003, 0x95b84439L, 0x19070e99L), 0 },
	{ __LINE__, HEXCONSTE(-9.99999999999999999946e-01, 0xbffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-2.25272833681982225552e+01, 0xc003, 0xb437e057L, 0xb116b792L), FLAG_INEXACT },
#endif
	{ __LINE__, HEXCONSTE(-6.58176486467709764838e-06, 0xbfed, 0xdcd8ee00L, 0x00000000L), HEXCONSTE(-6.58176486477213751860e-06, 0xbfed, 0xdcd8ee00L, 0x0db25a32L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(1.98402538895606994629e-01, 0x3ffc, 0xcb2a0900L, 0x00000000L), HEXCONSTE(2.01069084145582931982e-01, 0x3ffc, 0xcde50dd2L, 0x915b8ca5L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-1.12332724034786224365e-01, 0xbffb, 0xe60eb300L, 0x00000000L), HEXCONSTE(-1.12808829383352887043e-01, 0xbffb, 0xe70850c7L, 0x365cf609L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-9.87602233886718750000e-01, 0xbffe, 0xfcd38000L, 0x00000000L), HEXCONSTE(-2.53858398970612031864e+00, 0xc000, 0xa27828fbL, 0x7bf79a15L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-9.87602293491363525391e-01, 0xbffe, 0xfcd38100L, 0x00000000L), HEXCONSTE(-2.53858640855216035020e+00, 0xc000, 0xa2783320L, 0xb34dcc4bL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-9.87602270361993661574e-01, 0xbffe, 0xfcd3809cL, 0xa8fd2800L), HEXCONSTE(-2.53858546992620761240e+00, 0xc000, 0xa2782f30L, 0xdbc44055L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-6.37088045477867126465e-02, 0xbffb, 0x8279c300L, 0x00000000L), HEXCONSTE(-6.37952090808348398925e-02, 0xbffb, 0x82a71005L, 0x263b5573L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-1.27019315958023071289e-01, 0xbffc, 0x82115a00L, 0x00000000L), HEXCONSTE(-1.27709111761469442929e-01, 0xbffc, 0x82c62d69L, 0xaab8b3ebL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-2.42345660924911499023e-01, 0xbffc, 0xf8297600L, 0x00000000L), HEXCONSTE(-2.47264634556099816430e-01, 0xbffc, 0xfd32f0bbL, 0x80dc3fd6L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(2.42113083600997924805e-01, 0x3ffc, 0xf7ec7e00L, 0x00000000L), HEXCONSTE(2.47017560121339791642e-01, 0x3ffc, 0xfcf22bd9L, 0x0914be7dL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(2.42113068699836730957e-01, 0x3ffc, 0xf7ec7d00L, 0x00000000L), HEXCONSTE(2.47017544292300216473e-01, 0x3ffc, 0xfcf22ac9L, 0x183a8fbeL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(2.42113075612731154518e-01, 0x3ffc, 0xf7ec7d76L, 0xc33b3000L), HEXCONSTE(2.47017551635652708354e-01, 0x3ffc, 0xfcf22b47L, 0x40a272d1L), FLAG_INEXACT5 },
	{ __LINE__, HEXCONSTE(1.34059116244316101074e-01, 0x3ffc, 0x8946cb00L, 0x00000000L), HEXCONSTE(1.34870985492521069360e-01, 0x3ffc, 0x8a1b9e9fL, 0x7a8a5d6fL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(1.34059101343154907227e-01, 0x3ffc, 0x8946ca00L, 0x00000000L), HEXCONSTE(1.34870970318657557727e-01, 0x3ffc, 0x8a1b9d9aL, 0xcb2ed9cdL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(1.34059110260316555197e-01, 0x3ffc, 0x8946ca99L, 0x32177800L), HEXCONSTE(1.34870979399009879724e-01, 0x3ffc, 0x8a1b9e36L, 0xcafeaf29L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-1.80486246943473815918e-01, 0xbffc, 0xb8d16300L, 0x00000000L), HEXCONSTE(-1.82485262982639478654e-01, 0xbffc, 0xbadd6ab2L, 0x0cb187e8L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.23108246922492980957e-01, 0x3ffc, 0xe4767d00L, 0x00000000L), HEXCONSTE(2.26924807188093071594e-01, 0x3ffc, 0xe85efa06L, 0x188a6701L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(2.23108232021331787109e-01, 0x3ffc, 0xe4767c00L, 0x00000000L), HEXCONSTE(2.26924791506336592342e-01, 0x3ffc, 0xe85ef8f8L, 0xaf723e45L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(2.23108246108293356569e-01, 0x3ffc, 0xe4767cf2L, 0x031cb800L), HEXCONSTE(2.26924806331241708714e-01, 0x3ffc, 0xe85ef9f7L, 0x60118860L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(2.23108246108293328813e-01, 0x3ffc, 0xe4767cf2L, 0x031cb000L), HEXCONSTE(2.26924806331241679509e-01, 0x3ffc, 0xe85ef9f7L, 0x60117fc5L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(2.23108246108293349345e-01, 0x3ffc, 0xe4767cf2L, 0x031cb5ebL), HEXCONSTE(2.26924806331241701111e-01, 0x3ffc, 0xe85ef9f7L, 0x6011862fL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-1.51446104049682617188e-01, 0xbffc, 0x9b14b000L, 0x00000000L), HEXCONSTE(-1.52620155710835250586e-01, 0xbffc, 0x9c487545L, 0xf4302d8bL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-1.51446118950843811035e-01, 0xbffc, 0x9b14b100L, 0x00000000L), HEXCONSTE(-1.52620170961791222023e-01, 0xbffc, 0x9c48764bL, 0xf69a15ddL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-1.51446112975867186456e-01, 0xbffc, 0x9b14b099L, 0x59c66000L), HEXCONSTE(-1.52620164846556015013e-01, 0xbffc, 0x9c4875e2L, 0xe78355e4L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(2.27162286639213562012e-01, 0x3ffc, 0xe89d3b00L, 0x00000000L), HEXCONSTE(2.31195308137153428919e-01, 0x3ffc, 0xecbe767dL, 0xc038cbcaL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-1.53954681009054183960e-02, 0xbff8, 0xfc3d4600L, 0x00000000L), HEXCONSTE(-1.53966846207785491606e-02, 0xbff8, 0xfc42603aL, 0x6fbd4805L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-1.53954690322279930115e-02, 0xbff8, 0xfc3d4700L, 0x00000000L), HEXCONSTE(-1.53966855523219186068e-02, 0xbff8, 0xfc42613aL, 0x7f46c484L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-1.53954684851943281176e-02, 0xbff8, 0xfc3d4669L, 0xa1ed9000L), HEXCONSTE(-1.53966850051585648042e-02, 0xbff8, 0xfc4260a4L, 0x1814101dL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(4.36842709779739379883e-01, 0x3ffd, 0xdfa9d900L, 0x00000000L), HEXCONSTE(4.68322227445012922997e-01, 0x3ffd, 0xefc7ee55L, 0xbb7f1c00L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-1.51537567377090454102e-01, 0xbffc, 0x9b2caa00L, 0x00000000L), HEXCONSTE(-1.52713767405771180807e-01, 0xbffc, 0x9c60ff72L, 0xa07fec00L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.58269727230072021484e-01, 0xbffe, 0xc21df700L, 0x00000000L), HEXCONSTE(-9.92131482854947083325e-01, 0xbffe, 0xfdfc5430L, 0x31a8d535L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-7.58269786834716796875e-01, 0xbffe, 0xc21df800L, 0x00000000L), HEXCONSTE(-9.92131623092268950814e-01, 0xbffe, 0xfdfc568aL, 0x8239bd4dL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-7.58269773786271028548e-01, 0xbffe, 0xc21df7c7L, 0xf5150800L), HEXCONSTE(-9.92131592391989669490e-01, 0xbffe, 0xfdfc5606L, 0xa6e957ffL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(5.04454204103277348281e-12, 0x3fd9, 0xb17d3200L, 0x00000000L), HEXCONSTE(5.04454204103277348281e-12, 0x3fd9, 0xb17d3200L, 0x00000000L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(2.37286776304244995117e-01, 0x3ffc, 0xf2fb4e00L, 0x00000000L), HEXCONSTE(2.41897035298379386312e-01, 0x3ffc, 0xf7b3db3eL, 0x6c7047cdL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(2.37286761403083801270e-01, 0x3ffc, 0xf2fb4d00L, 0x00000000L), HEXCONSTE(2.41897019508149108119e-01, 0x3ffc, 0xf7b3da2fL, 0x26457b12L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(2.37286768831111216649e-01, 0x3ffc, 0xf2fb4d7fL, 0x9ccf6000L), HEXCONSTE(2.41897027379365428467e-01, 0x3ffc, 0xf7b3dab6L, 0x603f33fbL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-3.59752058982849121094e-01, 0xbffd, 0xb8316c00L, 0x00000000L), HEXCONSTE(-3.76601071684139351235e-01, 0xbffd, 0xc0d1db0dL, 0x0b3a6de9L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-3.04037518799304962158e-02, 0xbff9, 0xf9114a00L, 0x00000000L), HEXCONSTE(-3.04131253684235113750e-02, 0xbff9, 0xf924f25aL, 0x72e89c02L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-1.73625454306602478027e-01, 0xbffc, 0xb1cadf00L, 0x00000000L), HEXCONSTE(-1.75402399890176962461e-01, 0xbffc, 0xb39cafccL, 0xac42ec96L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-2.24833443760871887207e-01, 0xbffc, 0xe63abd00L, 0x00000000L), HEXCONSTE(-2.28741115959243365672e-01, 0xbffc, 0xea3b1c71L, 0x2e95f597L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(1.72127068042755126953e-01, 0x3ffc, 0xb0421400L, 0x00000000L), HEXCONSTE(1.73857852651462417427e-01, 0x3ffc, 0xb207cafdL, 0x29cc2f8fL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.05493636349960468205e-151, 0x3e0b, 0x80000000L, 0x00000000L), HEXCONSTE(3.05493636349960468205e-151, 0x3e0b, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(7.07981126104817289239e-1506, 0x2c77, 0x80000000L, 0x00000000L), HEXCONSTE(7.07981126104817289239e-1506, 0x2c77, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), 0 },
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), 0 },
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), 0 },
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), 0 },
	{ __LINE__, HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), 0 },
#endif
	{ __LINE__, HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), 0 },

#ifdef TEST_FLOAT
	{ __LINE__, HEXCONSTE(-9.999899999999999999e-01, 0xbffe, 0xffff583aL, 0x53b8e4b7L), HEXCONSTE(-6.10235548019409179688e+00, 0xc001, 0xc3467f00L, 0x00000000L), 0 },
#endif
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(-9.999899999999999999e-01, 0xbffe, 0xffff583aL, 0x53b8e4b7L), HEXCONSTE(-6.103033822758835533e00, 0xc001, 0xc34c0d96L, 0x6431a2e0L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-5.000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(-5.493061443340548457e-01, 0xbffe, 0x8c9f53d5L, 0x681854bbL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-2.500000000000000000e-01, 0xbffd, 0x80000000L, 0x00000000L), HEXCONSTE(-2.554128118829953416e-01, 0xbffd, 0x82c577d4L, 0x08a28d39L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(0.000000000000000000e00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(0.000000000000000000e00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.500000000000000000e-01, 0x3ffd, 0x80000000L, 0x00000000L), HEXCONSTE(2.554128118829953415e-01, 0x3ffd, 0x82c577d4L, 0x08a28d35L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(5.000000000000000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(5.493061443340548457e-01, 0x3ffe, 0x8c9f53d5L, 0x681854bbL), FLAG_INEXACT },
#ifdef TEST_FLOAT
	{ __LINE__, HEXCONSTE(9.999899999999999999e-01, 0x3ffe, 0xffff583aL, 0x53b8e4b7L), HEXCONSTE(6.10235548019409179688e+00, 0x4001, 0xc3467f00L, 0x00000000L), 0 },
#endif
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(9.999899999999999999e-01, 0x3ffe, 0xffff583aL, 0x53b8e4b7L), HEXCONSTE(6.103033822758835533e00, 0x4001, 0xc34c0d96L, 0x6431a2e0L), 0 },
#endif

	{ __LINE__, HEXCONSTE(0.75L, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(0.972955074527656652552676371721589865L, 0x3ffe, 0xf9139571L, 0x92d2baa3L), 0 },
};

int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_f_f(fatanh_data, ARRAY_SIZE(fatanh_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

```

`tests/cbrt.c`:

```c
#include "testconfig.h"
#define TEST_FUNC_F_F __MATH_PRECNAME(cbrt)
#include "testdriver.h"



static test_f_f_data const cbrt_data[] = {
	/* If x is +0, -0, positive infinity, negative infinity, or NaN, x is returned. */
	{ __LINE__, ZERO_P, ZERO_P, 0 },
	{ __LINE__, ZERO_M, ZERO_M, FLAG_FAIL_ARANYM2 },
	{ __LINE__, INF_P, INF_P, FLAG_FAIL_ARANYM2 },
	{ __LINE__, INF_M, INF_M, FLAG_FAIL_ARANYM2 }, /* sometimes returns NaN */
	{ __LINE__, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_P, 0 },
	{ __LINE__, SNAN_P, QNAN_P, 0 },
	{ __LINE__, SNAN_M, QNAN_P, 0 },

	{ __LINE__, HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), FLAG_FAIL_SOFTFLOAT|FLAG_FAIL_ARANYM|FLAG_XFAIL }, /* very inexact */ /* fails with FPU + with gcc 8.3 */
	{ __LINE__, HEXCONSTE(-1.1, 0xbfff, 0x8cccccccL, 0xcccccccdL), HEXCONSTE(-1.0322801154563671591907e+00, 0xbfff, 0x8421c13cL, 0x191d1dd0L), FLAG_INEXACT|FLAG_FAIL_SOFTFLOAT|FLAG_FAIL_ARANYM|FLAG_XFAIL }, /* very inexact */ /* fails with FPU + with gcc 8.3 */
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-1.4980869156445771586875e-1644, 0xaaaa, 0xa14517ccL, 0x6b945711L), 0 },
	{ __LINE__, MAX_M, HEXCONSTE(-1.0596187947380832725013e+1644, 0xd554, 0xa14517ccL, 0x6b945711L), 0 },
#endif
#if defined(TEST_DOUBLE)
	{ __LINE__, HEXCONSTE(-2.2250738585072014e-308L, 0xbc01, 0x80000000L, 0x00000046L), HEXCONSTE(-2.8126442852362619617738e-103, 0xbeaa, 0xa14517ccL, 0x6b945800L), FLAG_FAIL_SOFTFLOAT|FLAG_FAIL_ARANYM|FLAG_XFAIL }, /* very inexact */ /* fails with FPU + with gcc 8.3 */
	{ __LINE__, HEXCONSTE(1.7976931348623157e+308L, 0x43fe, 0xffffffffL, 0xfffff7acL), HEXCONSTE(5.6438030941223632930333e+102, 0x4154, 0xa14517ccL, 0x6b945800L), FLAG_INEXACT|FLAG_FAIL_SOFTFLOAT|FLAG_FAIL_ARANYM|FLAG_XFAIL }, /* very inexact */ /* fails with FPU + with gcc 8.3 */
#endif
	{ __LINE__, SUBNORM_M, QNAN_P, FLAG_SUBNORM },

	{ __LINE__, HEXCONSTE(-0.001L, 0xbff5, 0x83126e97L, 0x8d4fdf3bL), HEXCONSTE(-0.1L, 0xbffb, 0xccccccccL, 0xcccccccdL), FLAG_INEXACT|FLAG_FAIL_SOFTFLOAT|FLAG_FAIL_ARANYM|FLAG_XFAIL }, /* fails with FPU + with gcc 8.3 */
	{ __LINE__, HEXCONSTE(8, 0x4002, 0x80000000L, 0x00000000L), HEXCONSTE(2, 0x4000, 0x80000000L, 0x00000000L), FLAG_FAIL_SOFTFLOAT|FLAG_FAIL_ARANYM|FLAG_XFAIL }, /* fails with FPU + with gcc 8.3 */
	{ __LINE__, HEXCONSTE(-27.0, 0xc003, 0xd8000000L, 0x00000000L), HEXCONSTE(-3.0, 0xc000, 0xc0000000L, 0x00000000L), FLAG_INEXACT|FLAG_FAIL_SOFTFLOAT|FLAG_FAIL_ARANYM|FLAG_XFAIL }, /* fails with FPU + with gcc 8.3 */
	{ __LINE__, HEXCONSTE(0.9921875L, 0x3ffe, 0xfe000000L, 0x00000000L), HEXCONSTE(0.997389022060725270579075195353955217L, 0x3ffe, 0xff54e30fL, 0x23e69be4L), FLAG_INEXACT|FLAG_FAIL_SOFTFLOAT|FLAG_FAIL_ARANYM|FLAG_XFAIL }, /* fails with FPU + with gcc 8.3 */
	{ __LINE__, HEXCONSTE(0.75L, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(0.908560296416069829445605878163630251L, 0x3ffe, 0xe8976857L, 0x8d13f79fL), FLAG_INEXACT|FLAG_FAIL_SOFTFLOAT|FLAG_FAIL_ARANYM|FLAG_XFAIL }, /* fails with FPU + with gcc 8.3 */
};

int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_f_f(cbrt_data, ARRAY_SIZE(cbrt_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

```

`tests/ceil.c`:

```c
#include "testconfig.h"
#define TEST_FUNC_F_F __MATH_PRECNAME(ceil)
#include "testdriver.h"



static test_f_f_data const ceil_data[] = {
	{ __LINE__, ZERO_P, ZERO_P, 0 },
	{ __LINE__, ZERO_M, ZERO_M, FLAG_FAIL_ARANYM2 },
	{ __LINE__, INF_P, INF_P, 0 },
	{ __LINE__, INF_M, INF_M, 0 },
	{ __LINE__, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_P, 0 },
	{ __LINE__, SNAN_P, QNAN_P, 0 },
	{ __LINE__, SNAN_M, QNAN_P, 0 },

	/* Bug 15479: spurious "inexact" exception may occur.  */
	{ __LINE__, HEXCONST_PI, HEXCONSTE(4.0, 0x4001, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONST_PI_M, HEXCONSTE(-3.0, 0xc000, 0xc0000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.1, 0x3ffb, 0xccccccccL, 0xcccccccdL), HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.25, 0x3ffd, 0x80000000L, 0x00000000L), HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.5, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.625, 0x3ffe, 0xa0000000L, 0x00000000L), HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-0.1, 0xbffb, 0xccccccccL, 0xcccccccdL), ZERO_M, FLAG_IGNORE_ZEROSIGN },
	{ __LINE__, HEXCONSTE(-0.25, 0xbffd, 0x80000000L, 0x00000000L), ZERO_M, FLAG_IGNORE_ZEROSIGN },
	{ __LINE__, HEXCONSTE(-0.625, 0xbffe, 0xa0000000L, 0x00000000L), ZERO_M, FLAG_IGNORE_ZEROSIGN },

#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	/* The result can only be represented in long double.  */
	{ __LINE__, HEXCONSTE(4503599627370495.5L, 0x4032, 0xffffffffL, 0xfffff800L), HEXCONSTE(4503599627370496.0L, 0x4033, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4503599627370496.25L, 0x4033, 0x80000000L, 0x00000200L), HEXCONSTE(4503599627370497.0L, 0x4033, 0x80000000L, 0x00000800L), 0 },
	{ __LINE__, HEXCONSTE(4503599627370496.5L, 0x4033, 0x80000000L, 0x00000400L), HEXCONSTE(4503599627370497.0L, 0x4033, 0x80000000L, 0x00000800L), 0 },
	{ __LINE__, HEXCONSTE(4503599627370496.75L, 0x4033, 0x80000000L, 0x00000600L), HEXCONSTE(4503599627370497.0L, 0x4033, 0x80000000L, 0x00000800L), 0 },
	{ __LINE__, HEXCONSTE(4503599627370497.5L, 0x4033, 0x80000000L, 0x00000c00L), HEXCONSTE(4503599627370498.0L, 0x4033, 0x80000000L, 0x00001000L), 0 },

	{ __LINE__, HEXCONSTE(-4503599627370495.5L, 0xc032, 0xffffffffL, 0xfffff800L), HEXCONSTE(-4503599627370495.0L, 0xc032, 0xffffffffL, 0xfffff000L), 0 },
	{ __LINE__, HEXCONSTE(-4503599627370496.25L, 0xc033, 0x80000000L, 0x00000200L), HEXCONSTE(-4503599627370496.0L, 0xc033, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-4503599627370496.5L, 0xc033, 0x80000000L, 0x00000400L), HEXCONSTE(-4503599627370496.0L, 0xc033, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-4503599627370496.75L, 0xc033, 0x80000000L, 0x00000600L), HEXCONSTE(-4503599627370496.0L, 0xc033, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-4503599627370497.5L, 0xc033, 0x80000000L, 0x00000c00L), HEXCONSTE(-4503599627370497.0L, 0xc033, 0x80000000L, 0x00000800L), 0 },

# if LDBL_MANT_DIG > 100
	{ __LINE__, HEXCONSTE(4503599627370494.5000000000001L, 0x4032, 0xffffffffL, 0xffffe800L), HEXCONSTE(4503599627370495.0L, 0x4032, 0xffffffffL, 0xfffff000L), 0 },
	{ __LINE__, HEXCONSTE(4503599627370495.5000000000001L, 0x4032, 0xffffffffL, 0xfffff800L), HEXCONSTE(4503599627370496.0L, 0x4033, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4503599627370496.5000000000001L, 0x4033, 0x80000000L, 0x00000400L), HEXCONSTE(4503599627370497.0L, 0x4033, 0x80000000L, 0x00000800L), 0 },
	{ __LINE__, HEXCONSTE(-4503599627370494.5000000000001L, 0xc032, 0xffffffffL, 0xffffe800L), HEXCONSTE(-4503599627370494.0L, 0xc032, 0xffffffffL, 0xffffe000L), 0 },
	{ __LINE__, HEXCONSTE(-4503599627370495.5000000000001L, 0xc032, 0xffffffffL, 0xfffff800L), HEXCONSTE(-4503599627370495.0L, 0xc032, 0xffffffffL, 0xfffff000L), 0 },
	{ __LINE__, HEXCONSTE(-4503599627370496.5000000000001L, 0xc033, 0x80000000L, 0x00000400L), HEXCONSTE(-4503599627370496.0L, 0xc033, 0x80000000L, 0x00000000L), 0 },
# endif

	{ __LINE__, HEXCONSTE(9007199254740991.5L, 0x4033, 0xffffffffL, 0xfffffc00L), HEXCONSTE(9007199254740992.0L, 0x4034, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9007199254740992.25L, 0x4034, 0x80000000L, 0x00000100L), HEXCONSTE(9007199254740993.0L, 0x4034, 0x80000000L, 0x00000400L), 0 },
	{ __LINE__, HEXCONSTE(9007199254740992.5L, 0x4034, 0x80000000L, 0x00000200L), HEXCONSTE(9007199254740993.0L, 0x4034, 0x80000000L, 0x00000400L), 0 },
	{ __LINE__, HEXCONSTE(9007199254740992.75L, 0x4034, 0x80000000L, 0x00000300L), HEXCONSTE(9007199254740993.0L, 0x4034, 0x80000000L, 0x00000400L), 0 },
	{ __LINE__, HEXCONSTE(9007199254740993.5L, 0x4034, 0x80000000L, 0x00000600L), HEXCONSTE(9007199254740994.0L, 0x4034, 0x80000000L, 0x00000800L), 0 },

	{ __LINE__, HEXCONSTE(-9007199254740991.5L, 0xc033, 0xffffffffL, 0xfffffc00L), HEXCONSTE(-9007199254740991.0L, 0xc033, 0xffffffffL, 0xfffff800L), 0 },
	{ __LINE__, HEXCONSTE(-9007199254740992.25L, 0xc034, 0x80000000L, 0x00000100L), HEXCONSTE(-9007199254740992.0L, 0xc034, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-9007199254740992.5L, 0xc034, 0x80000000L, 0x00000200L), HEXCONSTE(-9007199254740992.0L, 0xc034, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-9007199254740992.75L, 0xc034, 0x80000000L, 0x00000300L), HEXCONSTE(-9007199254740992.0L, 0xc034, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-9007199254740993.5L, 0xc034, 0x80000000L, 0x00000600L), HEXCONSTE(-9007199254740993.0L, 0xc034, 0x80000000L, 0x00000400L), 0 },

# if LDBL_MANT_DIG > 100
	{ __LINE__, HEXCONSTE(9007199254740991.0000000000001L, 0x4033, 0xffffffffL, 0xfffff800L), HEXCONSTE(9007199254740992.0L, 0x4034, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9007199254740992.0000000000001L, 0x4034, 0x80000000L, 0x00000000L), HEXCONSTE(9007199254740993.0L, 0x4034, 0x80000000L, 0x00000400L), 0 },
	{ __LINE__, HEXCONSTE(9007199254740993.0000000000001L, 0x4034, 0x80000000L, 0x00000400L), HEXCONSTE(9007199254740994.0L, 0x4034, 0x80000000L, 0x00000800L), 0 },
	{ __LINE__, HEXCONSTE(9007199254740991.5000000000001L, 0x4033, 0xffffffffL, 0xfffffc00L), HEXCONSTE(9007199254740992.0L, 0x4034, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9007199254740992.5000000000001L, 0x4034, 0x80000000L, 0x00000200L), HEXCONSTE(9007199254740993.0L, 0x4034, 0x80000000L, 0x00000400L), 0 },
	{ __LINE__, HEXCONSTE(9007199254740993.5000000000001L, 0x4034, 0x80000000L, 0x00000600L), HEXCONSTE(9007199254740994.0L, 0x4034, 0x80000000L, 0x00000800L), 0 },

	{ __LINE__, HEXCONSTE(-9007199254740991.0000000000001L, 0xc033, 0xffffffffL, 0xfffff800L), HEXCONSTE(-9007199254740991.0L, 0xc033, 0xffffffffL, 0xfffff800L), 0 },
	{ __LINE__, HEXCONSTE(-9007199254740992.0000000000001L, 0xc034, 0x80000000L, 0x00000000L), HEXCONSTE(-9007199254740992.0L, 0xc034, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-9007199254740993.0000000000001L, 0xc034, 0x80000000L, 0x00000400L), HEXCONSTE(-9007199254740993.0L, 0xc034, 0x80000000L, 0x00000400L), 0 },
	{ __LINE__, HEXCONSTE(-9007199254740991.5000000000001L, 0xc033, 0xffffffffL, 0xfffffc00L), HEXCONSTE(-9007199254740991.0L, 0xc033, 0xffffffffL, 0xfffff800L), 0 },
	{ __LINE__, HEXCONSTE(-9007199254740992.5000000000001L, 0xc034, 0x80000000L, 0x00000200L), HEXCONSTE(-9007199254740992.0L, 0xc034, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-9007199254740993.5000000000001L, 0xc034, 0x80000000L, 0x00000600L), HEXCONSTE(-9007199254740993.0L, 0xc034, 0x80000000L, 0x00000400L), 0 },
# endif

	{ __LINE__, HEXCONSTE(72057594037927935.5L, 0x4036, 0xffffffffL, 0xffffff80L), HEXCONSTE(72057594037927936.0L, 0x4037, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(72057594037927936.25L, 0x4037, 0x80000000L, 0x00000020L), HEXCONSTE(72057594037927937.0L, 0x4037, 0x80000000L, 0x00000080L), 0 },
	{ __LINE__, HEXCONSTE(72057594037927936.5L, 0x4037, 0x80000000L, 0x00000040L), HEXCONSTE(72057594037927937.0L, 0x4037, 0x80000000L, 0x00000080L), 0 },
	{ __LINE__, HEXCONSTE(72057594037927936.75L, 0x4037, 0x80000000L, 0x00000060L), HEXCONSTE(72057594037927937.0L, 0x4037, 0x80000000L, 0x00000080L), 0 },
	{ __LINE__, HEXCONSTE(72057594037927937.5L, 0x4037, 0x80000000L, 0x000000c0L), HEXCONSTE(72057594037927938.0L, 0x4037, 0x80000000L, 0x00000100L), 0 },

	{ __LINE__, HEXCONSTE(-72057594037927935.5L, 0xc036, 0xffffffffL, 0xffffff80L), HEXCONSTE(-72057594037927935.0L, 0xc036, 0xffffffffL, 0xffffff00L), 0 },
	{ __LINE__, HEXCONSTE(-72057594037927936.25L, 0xc037, 0x80000000L, 0x00000020L), HEXCONSTE(-72057594037927936.0L, 0xc037, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-72057594037927936.5L, 0xc037, 0x80000000L, 0x00000040L), HEXCONSTE(-72057594037927936.0L, 0xc037, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-72057594037927936.75L, 0xc037, 0x80000000L, 0x00000060L), HEXCONSTE(-72057594037927936.0L, 0xc037, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-72057594037927937.5L, 0xc037, 0x80000000L, 0x000000c0L), HEXCONSTE(-72057594037927937.0L, 0xc037, 0x80000000L, 0x00000080L), 0 },

	{ __LINE__, HEXCONSTE(10141204801825835211973625643007.5L, 0x4066, 0x80000000L, 0x00000000L), HEXCONSTE(10141204801825835211973625643008.0L, 0x4066, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(10141204801825835211973625643008.25L, 0x4066, 0x80000000L, 0x00000000L), HEXCONSTE(10141204801825835211973625643009.0L, 0x4066, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(10141204801825835211973625643008.5L, 0x4066, 0x80000000L, 0x00000000L), HEXCONSTE(10141204801825835211973625643009.0L, 0x4066, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(10141204801825835211973625643008.75L, 0x4066, 0x80000000L, 0x00000000L), HEXCONSTE(10141204801825835211973625643009.0L, 0x4066, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(10141204801825835211973625643009.5L, 0x4066, 0x80000000L, 0x00000000L), HEXCONSTE(10141204801825835211973625643010.0L, 0x4066, 0x80000000L, 0x00000000L), 0 },
#endif
};

int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_f_f(ceil_data, ARRAY_SIZE(ceil_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

```

`tests/cos.c`:

```c
#include "testconfig.h"
#define TEST_FUNC_F_F __MATH_PRECNAME(cos)
#include "testdriver.h"



static test_f_f_data const fcos_data[] = {
	{ __LINE__, ZERO_P, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, ZERO_M, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, INF_P, QNAN_P, 0 },
	{ __LINE__, INF_M, QNAN_P, 0 },
	{ __LINE__, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_P, 0 },
	{ __LINE__, SNAN_P, QNAN_P, 0 },
	{ __LINE__, SNAN_M, QNAN_P, 0 },

	{ __LINE__, HEXCONSTE(1.04719758033752441406e+00, 0x3fff, 0x860a9200L, 0x00000000L), HEXCONSTE(4.99999974763217003483e-01, 0x3ffd, 0xffffff27L, 0x37ba3007L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(1.04719746112823486328e+00, 0x3fff, 0x860a9100L, 0x00000000L), HEXCONSTE(5.00000078001488305771e-01, 0x3ffe, 0x8000014fL, 0x038b1ab1L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.04719755119659785336e+00, 0x3fff, 0x860a91c1L, 0x6b9b3000L), HEXCONSTE(4.99999999999999907165e-01, 0x3ffd, 0xffffffffL, 0xfffff29fL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.04719755119659763132e+00, 0x3fff, 0x860a91c1L, 0x6b9b2800L), HEXCONSTE(5.00000000000000099476e-01, 0x3ffe, 0x80000000L, 0x0000072bL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.04719755119659774624e+00, 0x3fff, 0x860a91c1L, 0x6b9b2c24L), HEXCONSTE(4.99999999999999999919e-01, 0x3ffd, 0xffffffffL, 0xfffffffdL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(1.04719755119659774613e+00, 0x3fff, 0x860a91c1L, 0x6b9b2c23L), HEXCONSTE(5.00000000000000000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(2.09439516067504882812e+00, 0x4000, 0x860a9200L, 0x00000000L), HEXCONSTE(-5.00000050473564719260e-01, 0xbffe, 0x800000d8L, 0xc8457430L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(2.09439492225646972656e+00, 0x4000, 0x860a9100L, 0x00000000L), HEXCONSTE(-4.99999843997011219997e-01, 0xbffd, 0xfffffac3L, 0xf1ccbb73L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(2.09439510239319570672e+00, 0x4000, 0x860a91c1L, 0x6b9b3000L), HEXCONSTE(-5.00000000000000185670e-01, 0xbffe, 0x80000000L, 0x00000d61L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(2.09439510239319526264e+00, 0x4000, 0x860a91c1L, 0x6b9b2800L), HEXCONSTE(-4.99999999999999801103e-01, 0xbffd, 0xffffffffL, 0xffffe336L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(2.09439510239319549249e+00, 0x4000, 0x860a91c1L, 0x6b9b2c24L), HEXCONSTE(-5.00000000000000000163e-01, 0xbffe, 0x80000000L, 0x00000003L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(2.09439510239319549227e+00, 0x4000, 0x860a91c1L, 0x6b9b2c23L), HEXCONSTE(-4.99999999999999999973e-01, 0xbffd, 0xffffffffL, 0xffffffffL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(1.57079637050628662109e+00, 0x3fff, 0xc90fdb00L, 0x00000000L), HEXCONSTE(-4.37113900018624143888e-08, 0xbfe6, 0xbbbd2e7bL, 0x96766267L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(1.57079625129699707031e+00, 0x3fff, 0xc90fda00L, 0x00000000L), HEXCONSTE(7.54978995489187499690e-08, 0x3fe7, 0xa22168c2L, 0x34c49b08L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(1.57079632679489678004e+00, 0x3fff, 0xc90fdaa2L, 0x2168c800L), HEXCONSTE(-1.60812264967663649219e-16, 0xbfca, 0xb9676733L, 0xae8fe47cL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(1.57079632679489655800e+00, 0x3fff, 0xc90fdaa2L, 0x2168c000L), HEXCONSTE(6.12323399573676588601e-17, 0x3fc9, 0x8d313198L, 0xa2e03707L), FLAG_INEXACT4 },
#if defined TEST_LDOUBLE && LDBL_MAX_EXP >= 16384 && !defined __mc68000__
	{ __LINE__, HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), HEXCONSTE(-2.50827880633416601173e-20, 0xbfbe, 0x80000000, 0x00000000L), FLAG_INEXACT4|FLAG_FAIL_X87 },
#endif
#if defined TEST_LDOUBLE && LDBL_MAX_EXP >= 16384 && defined __mc68000__
	{ __LINE__, HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), HEXCONSTE(-2.50827880633416601173e-20, 0xbfbd, 0xece675d1L, 0xfc8f8cbbL), FLAG_INEXACT4 },
#endif
#if defined TEST_LDOUBLE && LDBL_MAX_EXP >= 16384
	{ __LINE__, HEXCONSTE(1.57079632679489661915e+00, 0x3fff, 0xc90fdaa2L, 0x2168c234L), HEXCONSTE(8.33374291852087832820e-20, 0x3fbf, 0xc4c6628bL, 0x80dc1cd1L), FLAG_INEXACT4 },
#endif
	{ __LINE__, HEXCONSTE(7.50000000000000000000e-01, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(7.31688868873820886325e-01, 0x3ffe, 0xbb4ff632L, 0xa908f73fL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.68934881474191032320e+19, 0x4040, 0x80000000L, 0x00000000L), HEXCONSTE(9.98886220660580136132e-01, 0x3ffe, 0xffb701e2L, 0x2987fbe7L), FLAG_INEXACT4|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(-3.68934881474191032320e+19, 0xc040, 0x80000000L, 0x00000000L), HEXCONSTE(9.98886220660580136132e-01, 0x3ffe, 0xffb701e2L, 0x2987fbe7L), FLAG_INEXACT4|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(8.01901280879974365234e-01, 0x3ffe, 0xcd496700L, 0x00000000L), HEXCONSTE(6.95341555497763925725e-01, 0x3ffe, 0xb201e778L, 0x69a46ae2L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(8.01901221275329589844e-01, 0x3ffe, 0xcd496600L, 0x00000000L), HEXCONSTE(6.95341598334394744017e-01, 0x3ffe, 0xb201e830L, 0x65041457L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(8.01901271840588458772e-01, 0x3ffe, 0xcd4966d9L, 0x2d171000L), HEXCONSTE(6.95341561994184596124e-01, 0x3ffe, 0xb201e794L, 0x50884640L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(8.01901271840588347750e-01, 0x3ffe, 0xcd4966d9L, 0x2d170800L), HEXCONSTE(6.95341561994184675921e-01, 0x3ffe, 0xb201e794L, 0x50884c00L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(8.01901271840588350027e-01, 0x3ffe, 0xcd4966d9L, 0x2d17082aL), HEXCONSTE(6.95341561994184674295e-01, 0x3ffe, 0xb201e794L, 0x50884be2L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(8.01901271840588349973e-01, 0x3ffe, 0xcd4966d9L, 0x2d170829L), HEXCONSTE(6.95341561994184674349e-01, 0x3ffe, 0xb201e794L, 0x50884be3L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(4.14957265625000000000e+04, 0x400e, 0xa217ba00L, 0x00000000L), HEXCONSTE(2.44078399023140166278e-06, 0x3fec, 0xa3cc5983L, 0x39790b01L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(1.00000009040962152038e+22, 0x4048, 0x87867900L, 0x00000000L), HEXCONSTE(9.53885881745745288040e-01, 0x3ffe, 0xf431dd7aL, 0x36cf37deL), FLAG_INEXACT4|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(9.99999977819630836122e+21, 0x4048, 0x87867800L, 0x00000000L), HEXCONSTE(6.79061337095050972191e-01, 0x3ffe, 0xadd6f6baL, 0xcd20654cL), FLAG_INEXACT4|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+22, 0x4048, 0x87867832L, 0x6eac9000L), HEXCONSTE(5.23214785395138945478e-01, 0x3ffe, 0xc1bd48bdL, 0x5cb29cf1L), FLAG_INEXACT4|FLAG_FAIL_ARANYM }, /* ARAnyM seems to return input value???? */
#if defined TEST_LDOUBLE && LDBL_MAX_EXP >= 16384 && !defined __mc68000__
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-3.03724788012322208133e-01, 0xbffd, 0x9b81d0beL, 0xfeb2a5fcL), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* sometimes returns 3ffe:da5f963c:defe6d53 */
	{ __LINE__, HEXCONSTE(8.98846567431157953865e+307, 0x43fe, 0x80000000L, 0x00000000L), HEXCONSTE(3.83763456205621497565e-01, 0x3ffd, 0xc47ca4cbL, 0x9b2c5464L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* bffe:d38cf936:1195f50b */
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-3.03724788012322208133e-01, 0xbffd, 0x9b81d0beL, 0xfeb2a5fcL), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* 3ffe:da5f963c:defe6d53 */
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-6.05752278262073315482e-01, 0xbffe, 0x9b1294d0L, 0x9cf3e635L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* bffe:ffff3176:7d5ba9e0 */
#endif
#if defined TEST_LDOUBLE && LDBL_MAX_EXP >= 16384 && defined __mc68000__
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-3.03724788012322208133e-01, 0x3ffe, 0xda5f963c, 0xdefe6d53L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(8.98846567431157953865e+307, 0x43fe, 0x80000000L, 0x00000000L), HEXCONSTE(3.83763456205621497565e-01, 0xbffe, 0xd38cf936, 0x1195f50bL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-3.03724788012322208133e-01, 0x3ffe, 0xda5f963c, 0xdefe6d53L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-6.05752278262073315482e-01, 0xbffe, 0xffff3176, 0x7d5ba9e0L), FLAG_INEXACT3 },
#endif
#if defined TEST_LDOUBLE && LDBL_MAX_EXP >= 16384
	{ __LINE__, HEXCONSTE(5.94865747678615882543e+4931, 0x7ffe, 0x80000000L, 0x00000000L), HEXCONSTE(-2.02005417966319858098e-01, 0xbffc, 0xceda821fL, 0x1ee0da4bL), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* 3ffe:ebcc2fc8:2ae39ec0 */
#endif
	{ __LINE__, HEXCONSTE(1.32922799578491587290e+36, 0x4077, 0x80000000L, 0x00000000L), HEXCONSTE(-3.89299940193917960762e-01, 0xbffd, 0xc752525eL, 0xef6da9ceL), FLAG_INEXACT3|FLAG_FAIL_X87|FLAG_FAIL_SOFTFLOAT }, /* bffe:ed06685b:36c66c4d */
	{ __LINE__, HEXCONSTE(1.70141183460469231732e+38, 0x407e, 0x80000000L, 0x00000000L), HEXCONSTE(6.07359600606700279822e-01, 0x3ffe, 0x9b7beb35L, 0x84744a81L), FLAG_INEXACT3|FLAG_FAIL_X87|FLAG_FAIL_SOFTFLOAT }, /* 3ffe:c82b8ec9:8b5e62fd */
	{ __LINE__, HEXCONSTE(3.40282285791300048857e+38, 0x407e, 0xfffffc00L, 0x00000000L), HEXCONSTE(8.96232101881571183914e-01, 0x3ffe, 0xe56f778fL, 0x34e98641L), FLAG_INEXACT3|FLAG_FAIL_X87|FLAG_FAIL_SOFTFLOAT }, /* 3ffe:ffb2a030:c5ae20be */
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-3.03724788012322208133e-01, 0xbffd, 0x9b81d0beL, 0xfeb2a5fcL), FLAG_INEXACT3|FLAG_FAIL_X87|FLAG_FAIL_SOFTFLOAT }, /* 3ffe:da5f963c:defe6d53 got bffd:9b81d0be:feb2a5fc */
	{ __LINE__, HEXCONSTE(1.12589990684262400000e+15, 0x4031, 0x80000000L, 0x00000000L), HEXCONSTE(8.68095185132856530987e-01, 0x3ffe, 0xde3b7c6dL, 0xf5ef6698L), FLAG_INEXACT3|FLAG_FAIL_X87|FLAG_FAIL_SOFTFLOAT }, /* 3ffe:de3b8880:4f00552d */
	{ __LINE__, HEXCONSTE(2.68435456000000000000e+08, 0x401b, 0x80000000L, 0x00000000L), HEXCONSTE(-1.65568979490578758871e-01, 0xbffc, 0xa98aea20L, 0x9396f2c2L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(5.40302205556977601752e-01, 0x3ffe, 0x8a513eceL, 0xd2ea575eL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(5.40302305868139717414e-01, 0x3ffe, 0x8a51407dL, 0xa8345c92L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.00000004826339550235e+00, 0x3fff, 0x80000067L, 0xa5151000L), HEXCONSTE(5.40302265255892144591e-01, 0x3ffe, 0x8a513fcfL, 0x3a90ec00L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(5.40302205556977601752e-01, 0x3ffe, 0x8a513eceL, 0xd2ea575eL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(5.40302305868139717414e-01, 0x3ffe, 0x8a51407dL, 0xa8345c92L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.00000006219816328645e+00, 0x3fff, 0x80000085L, 0x91cd4800L), HEXCONSTE(5.40302253530188958397e-01, 0x3ffe, 0x8a513f9cL, 0xde04e400L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(5.40302205556977601752e-01, 0x3ffe, 0x8a513eceL, 0xd2ea575eL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(5.40302305868139717414e-01, 0x3ffe, 0x8a51407dL, 0xa8345c92L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.00000008257593253624e+00, 0x3fff, 0x800000b1L, 0x54995800L), HEXCONSTE(5.40302236382886602595e-01, 0x3ffe, 0x8a513f53L, 0x385c5c00L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.00000023841857910156e+00, 0x3fff, 0x80000200L, 0x00000000L), HEXCONSTE(5.40302105245807807988e-01, 0x3ffe, 0x8a513d1fL, 0xfd9e28e6L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(5.40302205556977601752e-01, 0x3ffe, 0x8a513eceL, 0xd2ea575eL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.00000016864453655785e+00, 0x3fff, 0x8000016aL, 0x29508000L), HEXCONSTE(5.40302163958647774233e-01, 0x3ffe, 0x8a513e1cL, 0x29116c00L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.00000035762786865234e+00, 0x3fff, 0x80000300L, 0x00000000L), HEXCONSTE(5.40302004934630336066e-01, 0x3ffe, 0x8a513b71L, 0x284fd129L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.00000023841857910156e+00, 0x3fff, 0x80000200L, 0x00000000L), HEXCONSTE(5.40302105245807807988e-01, 0x3ffe, 0x8a513d1fL, 0xfd9e28e6L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.00000034190955067182e+00, 0x3fff, 0x800002deL, 0x3ec36800L), HEXCONSTE(5.40302018161141817121e-01, 0x3ffe, 0x8a513ba9L, 0xf703d400L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(4.83192166400000000000e+09, 0x401f, 0x9000a300L, 0x00000000L), HEXCONSTE(-9.66060479310720755059e-01, 0xbffe, 0xf74fbd54L, 0x98fe4c0cL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(4.83192115200000000000e+09, 0x401f, 0x9000a200L, 0x00000000L), HEXCONSTE(9.83542241802157490307e-01, 0x3ffe, 0xfbc96ca2L, 0xc658abf6L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(4.83192157746018028259e+09, 0x401f, 0x9000a2d4L, 0xbae73000L), HEXCONSTE(-3.96131987972693638714e-01, 0xbffd, 0xcad1cfdaL, 0x7bff9bfcL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(5.40302305868139717414e-01, 0x3ffe, 0x8a51407dL, 0xa8345c92L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-4.16146836547142387008e-01, 0xbffd, 0xd51132baL, 0x9b902522L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(3.00000000000000000000e+00, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(-9.89992496600445457278e-01, 0xbffe, 0xfd7025f4L, 0x2f2e9308L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(4.00000000000000000000e+00, 0x4001, 0x80000000L, 0x00000000L), HEXCONSTE(-6.53643620863611914628e-01, 0xbffe, 0xa7553036L, 0xd9260623L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(5.00000000000000000000e+00, 0x4001, 0xa0000000L, 0x00000000L), HEXCONSTE(2.83662185463226264461e-01, 0x3ffd, 0x913c2b83L, 0x5a56ca9fL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(6.00000000000000000000e+00, 0x4001, 0xc0000000L, 0x00000000L), HEXCONSTE(9.60170286650366020529e-01, 0x3ffe, 0xf5cdb84bL, 0xc117abd7L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(7.00000000000000000000e+00, 0x4001, 0xe0000000L, 0x00000000L), HEXCONSTE(7.53902254343304638155e-01, 0x3ffe, 0xc0ffbcf6L, 0xc900bab0L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(8.00000000000000000000e+00, 0x4002, 0x80000000L, 0x00000000L), HEXCONSTE(-1.45500033808613525867e-01, 0xbffc, 0x94fdf5fbL, 0x197c9c7bL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(9.00000000000000000000e+00, 0x4002, 0x90000000L, 0x00000000L), HEXCONSTE(-9.11130261884676988346e-01, 0xbffe, 0xe93fd535L, 0x30cb5b82L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+01, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(-8.39071529076452452261e-01, 0xbffe, 0xd6cd6448L, 0x6358f905L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(3.12500000000000000000e-02, 0x3ffa, 0x80000000L, 0x00000000L), HEXCONSTE(9.99511758485136369223e-01, 0x3ffe, 0xffe000aaL, 0xa93e9589L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.76562500000000000000e-04, 0x3ff5, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999523162879692506e-01, 0x3ffe, 0xfffff800L, 0x000aaaabL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(3.05175781250000000000e-05, 0x3ff0, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999999534338712746e-01, 0x3ffe, 0xfffffffeL, 0x00000001L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(9.53674316406250000000e-07, 0x3feb, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999999999545252649e-01, 0x3ffe, 0xffffffffL, 0xff800000L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.98023223876953125000e-08, 0x3fe6, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999999999999555911e-01, 0x3ffe, 0xffffffffL, 0xffffe000L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(9.31322574615478515625e-10, 0x3fe1, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999999999999999566e-01, 0x3ffe, 0xffffffffL, 0xfffffff8L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.91038304567337036133e-11, 0x3fdc, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9.09494701772928237915e-13, 0x3fd7, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.84217094304040074348e-14, 0x3fd2, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(8.88178419700125232339e-16, 0x3fcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.77555756156289135106e-17, 0x3fc8, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(8.67361737988403547206e-19, 0x3fc3, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(7.88860905221011805412e-31, 0x3f9b, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.40991986510288411774e-181, 0x3da7, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(5.01237274920645200930e-3011, 0x18ef, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MAX_EXP >= 16384 && !defined __mc68000__
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-3.03724788012322208133e-01, 0xbffd, 0x9b81d0beL, 0xfeb2a5fcL), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* 3ffe:da5f963c:defe6d53 */
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-6.05752278262073315482e-01, 0xbffe, 0x9b1294d0L, 0x9cf3e635L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* bffe:ffff3176:7d5ba9e0 */
#endif
#if defined TEST_LDOUBLE && LDBL_MAX_EXP >= 16384 && defined __mc68000__
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-3.03724788012322208133e-01, 0xbffd, 0x3ffe:da5f963c, 0xdefe6d53L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-6.05752278262073315482e-01, 0xbffe, 0xffff3176, 0x7d5ba9e0L), FLAG_INEXACT3 },
#endif
#if defined(TEST_LDOUBLE)
	{ __LINE__, HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(9.94560279894571366193e-01, 0x3ffe, 0xfe9b80a4L, 0x0c3bfcf4L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* bffc:800bbd00:61d4f543 */
#endif
#if defined TEST_LDOUBLE && LDBL_MAX_EXP >= 16384 && !defined __mc68000__
	{ __LINE__, HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-3.03724788012322208133e-01, 0xbffd, 0x9b81d0beL, 0xfeb2a5fcL), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* 3ffe:da5f963c:defe6d53 */
	{ __LINE__, HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-6.05752278262073315482e-01, 0xbffe, 0x9b1294d0L, 0x9cf3e635L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* bffe:ffff3176:7d5ba9e0 */
#endif
#if defined TEST_LDOUBLE && LDBL_MAX_EXP >= 16384 && defined __mc68000__
	{ __LINE__, HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-3.03724788012322208133e-01, 0x3ffe, 0xda5f963cL, 0xdefe6d53L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-6.05752278262073315482e-01, 0xbffe, 0xffff3176L, 0x7d5ba9e0L), FLAG_INEXACT3 },
#endif
#if defined(TEST_LDOUBLE)
	{ __LINE__, HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(9.94560279894571366193e-01, 0x3ffe, 0xfe9b80a4L, 0x0c3bfcf4L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* bffc:800bbd00:61d4f543 */
#endif
	{ __LINE__, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if defined(TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16381)
	{ __LINE__, HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
#if defined(TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if defined(TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16381)
	{ __LINE__, HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
#if defined(TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if defined(TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16381)
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, SUBNORM_P, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if defined(TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16381)
	{ __LINE__, HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, SUBNORM_M, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), FLAG_SUBNORM },
#if defined TEST_LDOUBLE && LDBL_MAX_EXP >= 16384 && !defined __mc68000__
	{ __LINE__, HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-3.03724788012322208133e-01, 0xbffd, 0x9b81d0beL, 0xfeb2a5fcL), FLAG_INEXACT3|FLAG_FAIL_X87 },
	{ __LINE__, HEXCONSTE(-3.64229140925048708372e+307, 0xc3fc, 0xcf78c83dL, 0xafa1f800L), HEXCONSTE(9.32031230844456268128e-01, 0x3ffe, 0xee999947L, 0x53db5fcbL), FLAG_INEXACT3|FLAG_FAIL_X87 },
	{ __LINE__, HEXCONSTE(7.59194657019045731761e+34, 0x4072, 0xe9f1e600L, 0x00000000L), HEXCONSTE(-7.25683352321772097188e-01, 0xbffe, 0xb9c66259L, 0x794192e2L), FLAG_INEXACT3|FLAG_FAIL_X87 },
	{ __LINE__, HEXCONSTE(7.59194607501444160346e+34, 0x4072, 0xe9f1e500L, 0x00000000L), HEXCONSTE(-4.02365414694072335997e-01, 0xbffd, 0xce02d6f2L, 0x4e16e895L), FLAG_INEXACT3|FLAG_FAIL_X87 },
	{ __LINE__, HEXCONSTE(7.59194643911056501837e+34, 0x4072, 0xe9f1e5bcL, 0x3bb88000L), HEXCONSTE(-6.54756326377446390375e-01, 0xbffe, 0xa79e1c50L, 0xa3e666ccL), FLAG_INEXACT3|FLAG_FAIL_X87 },
	{ __LINE__, HEXCONSTE(1.31933767361251141222e+21, 0x4045, 0x8f0afa00L, 0x00000000L), HEXCONSTE(2.50305240966173909295e-01, 0x3ffd, 0x8028022fL, 0xef29e0e6L), FLAG_INEXACT3|FLAG_FAIL_X87 },
#endif
#if defined TEST_LDOUBLE && LDBL_MAX_EXP >= 16384 && defined __mc68000__
	{ __LINE__, HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-3.03724788012322208133e-01, 0x3ffe, 0xda5f963cL, 0xdefe6d53L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-3.64229140925048708372e+307, 0xc3fc, 0xcf78c83dL, 0xafa1f800L), HEXCONSTE(9.32031230844456268128e-01, 0xbffb, 0xff5dfccaL, 0x4f66099bL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.59194657019045731761e+34, 0x4072, 0xe9f1e600L, 0x00000000L), HEXCONSTE(-7.25683352321772097188e-01, 0xbffe, 0xa07bd3abL, 0x53ab9711L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.59194607501444160346e+34, 0x4072, 0xe9f1e500L, 0x00000000L), HEXCONSTE(-4.02365414694072335997e-01, 0x3ffe, 0xe26f8af8L, 0x333f9271L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.59194643911056501837e+34, 0x4072, 0xe9f1e5bcL, 0x3bb88000L), HEXCONSTE(-6.54756326377446390375e-01, 0x3ffb,0xff808006L, 0x4d739b18L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(1.31933767361251141222e+21, 0x4045, 0x8f0afa00L, 0x00000000L), HEXCONSTE(2.50305240966173909295e-01, 0xbffe, 0xfdfe9021L, 0x35fc1c18L), FLAG_INEXACT3 },
#endif
	{ __LINE__, HEXCONSTE(-1.01128077507019042969e+00, 0xbfff, 0x8171a600L, 0x00000000L), HEXCONSTE(5.30775684327595814770e-01, 0x3ffe, 0x87e0ea4dL, 0xb2f48867L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(2.55009582519531250000e+02, 0x4006, 0xff027400L, 0x00000000L), HEXCONSTE(-8.57411584288221151643e-01, 0xbffe, 0xdb7f5359L, 0xbabdb66cL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(3.01631975173950195312e+00, 0x4000, 0xc10b6200L, 0x00000000L), HEXCONSTE(-9.92163606317157264374e-01, 0xbffe, 0xfdfe6f21L, 0x69e24f27L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.51742398738861083984e+00, 0x3fff, 0xc23af300L, 0x00000000L), HEXCONSTE(5.33470035486460361106e-02, 0x3ffa, 0xda826339L, 0x4be6d0e6L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.51742386817932128906e+00, 0x3fff, 0xc23af200L, 0x00000000L), HEXCONSTE(5.33471225881853241497e-02, 0x3ffa, 0xda82832dL, 0xa19f9892L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.51742396872239759809e+00, 0x3fff, 0xc23af2d7L, 0xea240800L), HEXCONSTE(5.33470221882792298984e-02, 0x3ffa, 0xda82683aL, 0x33cbec00L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.57079708576202392578e+00, 0x3fff, 0xc90fe100L, 0x00000000L), HEXCONSTE(-7.58967127306477063536e-07, 0xbfea, 0xcbbbd2e7L, 0xb951e5b2L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(1.57079696655273437500e+00, 0x3fff, 0xc90fe000L, 0x00000000L), HEXCONSTE(-6.39757837755725037206e-07, 0xbfea, 0xabbbd2e7L, 0xb95a85c6L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(1.57079697000000018114e+00, 0x3fff, 0xc90fe007L, 0x67278800L), HEXCONSTE(-6.43205103561868956137e-07, 0xbfea, 0xaca8b7d8L, 0xb95a502fL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(1.57079696999999995910e+00, 0x3fff, 0xc90fe007L, 0x67278000L), HEXCONSTE(-6.43205103339824351212e-07, 0xbfea, 0xaca8b7d7L, 0xb95a502fL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(1.57079697000000000008e+00, 0x3fff, 0xc90fe007L, 0x6727817aL), HEXCONSTE(-6.43205103380807193332e-07, 0xbfea, 0xaca8b7d7L, 0xe89a502fL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(1.57079696999999999997e+00, 0x3fff, 0xc90fe007L, 0x67278179L), HEXCONSTE(-6.43205103380698773115e-07, 0xbfea, 0xaca8b7d7L, 0xe87a502fL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(-1.57079696655273437500e+00, 0xbfff, 0xc90fe000L, 0x00000000L), HEXCONSTE(-6.39757837755725037206e-07, 0xbfea, 0xabbbd2e7L, 0xb95a85c6L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(-1.57079708576202392578e+00, 0xbfff, 0xc90fe100L, 0x00000000L), HEXCONSTE(-7.58967127306477063536e-07, 0xbfea, 0xcbbbd2e7L, 0xb951e5b2L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(-1.57079696999999995910e+00, 0xbfff, 0xc90fe007L, 0x67278000L), HEXCONSTE(-6.43205103339824351212e-07, 0xbfea, 0xaca8b7d7L, 0xb95a502fL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(-1.57079697000000018114e+00, 0xbfff, 0xc90fe007L, 0x67278800L), HEXCONSTE(-6.43205103561868956137e-07, 0xbfea, 0xaca8b7d8L, 0xb95a502fL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(-1.57079696999999999997e+00, 0xbfff, 0xc90fe007L, 0x67278179L), HEXCONSTE(-6.43205103380698773115e-07, 0xbfea, 0xaca8b7d7L, 0xe87a502fL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(-1.57079697000000000008e+00, 0xbfff, 0xc90fe007L, 0x6727817aL), HEXCONSTE(-6.43205103380807193332e-07, 0xbfea, 0xaca8b7d7L, 0xe89a502fL), FLAG_INEXACT4 },
};

int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_f_f(fcos_data, ARRAY_SIZE(fcos_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

```

`tests/cosh.c`:

```c
#include "testconfig.h"
#define TEST_FUNC_F_F __MATH_PRECNAME(cosh)
#include "testdriver.h"



static test_f_f_data const fcosh_data[] = {
	{ __LINE__, ZERO_P, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, ZERO_M, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, INF_P, INF_P, FLAG_XFAIL_LINUX|FLAG_FAIL_ARANYM }, /* glibc returns NaN */
	{ __LINE__, INF_M, INF_P, FLAG_XFAIL_LINUX|FLAG_FAIL_ARANYM }, /* glibc returns NaN */
	{ __LINE__, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_P, 0 },
	{ __LINE__, SNAN_P, QNAN_P, 0 },
	{ __LINE__, SNAN_M, QNAN_P, 0 },

	{ __LINE__, HEXCONSTE(7.50000000000000000000e-01, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(1.29468328467684468781e+00, 0x3fff, 0xa5b82e8fL, 0x2eb53c3dL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(7.09889404296875000000e+02, 0x4008, 0xb178ec00L, 0x00000000L), HEXCONSTE(1.00004847532387455672e+308, 0x43fe, 0x8e696096L, 0x6c8d230bL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(7.09889343261718750000e+02, 0x4008, 0xb178eb00L, 0x00000000L), HEXCONSTE(9.99987439071623134546e+307, 0x43fe, 0x8e6726f5L, 0x5d788682L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(7.09889355812725966643e+02, 0x4008, 0xb178eb34L, 0xa48a9800L), HEXCONSTE(9.99999989999950706557e+307, 0x43fe, 0x8e679c17L, 0x7a00bfb6L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-7.09889343261718750000e+02, 0xc008, 0xb178eb00L, 0x00000000L), HEXCONSTE(9.99987439071623134546e+307, 0x43fe, 0x8e6726f5L, 0x5d788682L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-7.09889404296875000000e+02, 0xc008, 0xb178ec00L, 0x00000000L), HEXCONSTE(1.00004847532387455672e+308, 0x43fe, 0x8e696096L, 0x6c8d230bL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-7.09889355812725966643e+02, 0xc008, 0xb178eb34L, 0xa48a9800L), HEXCONSTE(9.99999989999950706557e+307, 0x43fe, 0x8e679c17L, 0x7a00bfb6L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.20000000000000000000e+01, 0x4003, 0xb0000000L, 0x00000000L), HEXCONSTE(1.79245642306579578097e+09, 0x401d, 0xd5ad6dceL, 0x21affc0fL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.30000000000000000000e+01, 0x4003, 0xb8000000L, 0x00000000L), HEXCONSTE(4.87240172312445130013e+09, 0x401f, 0x9135799dL, 0x8fee052cL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.40000000000000000000e+01, 0x4003, 0xc0000000L, 0x00000000L), HEXCONSTE(1.32445610649217361473e+10, 0x4020, 0xc55bfdaaL, 0x3afdb99cL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(3.12500000000000000000e-02, 0x3ffa, 0x80000000L, 0x00000000L), HEXCONSTE(1.00048832098772337638e+00, 0x3fff, 0x80100055L, 0x560b6186L), 0 },
	{ __LINE__, HEXCONSTE(9.76562500000000000000e-04, 0x3ff5, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000047683719609870e+00, 0x3fff, 0x80000400L, 0x00055555L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.05175781250000000000e-05, 0x3ff0, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000046566128731e+00, 0x3fff, 0x80000001L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9.53674316406250000000e-07, 0x3feb, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000045474735e+00, 0x3fff, 0x80000000L, 0x00400000L), 0 },
	{ __LINE__, HEXCONSTE(2.98023223876953125000e-08, 0x3fe6, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000044409e+00, 0x3fff, 0x80000000L, 0x00001000L), 0 },
	{ __LINE__, HEXCONSTE(9.31322574615478515625e-10, 0x3fe1, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000043e+00, 0x3fff, 0x80000000L, 0x00000004L), 0 },
	{ __LINE__, HEXCONSTE(2.91038304567337036133e-11, 0x3fdc, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9.09494701772928237915e-13, 0x3fd7, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.84217094304040074348e-14, 0x3fd2, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(8.88178419700125232339e-16, 0x3fcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(7.88860905221011805412e-31, 0x3f9b, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.40991986510288411774e-181, 0x3da7, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(5.01237274920645200930e-3011, 0x18ef, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(1.54308063481524377844e+00, 0x3fff, 0xc583aa8eL, 0xcfaa8261L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(5.00000000000000000000e+01, 0x4004, 0xc8000000L, 0x00000000L), HEXCONSTE(2.59235276429353623194e+21, 0x4046, 0x8c881f20L, 0x405a2b32L), 0 },
	{ __LINE__, HEXCONSTE(-1.13767271041870117188e+01, 0xc002, 0xb6071300L, 0x00000000L), HEXCONSTE(4.36334756012919583483e+04, 0x400e, 0xaa7179c1L, 0x019ae57eL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-3.80817413330078125000e+00, 0xc000, 0xf3b92000L, 0x00000000L), HEXCONSTE(2.25451320271481881665e+01, 0x4003, 0xb45c6e2eL, 0x24d447abL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.96022272109985351562e+00, 0x4000, 0xbd744a00L, 0x00000000L), HEXCONSTE(9.67703883847959733799e+00, 0x4002, 0x9ad526adL, 0x56446400L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-1.30469207763671875000e+01, 0xc002, 0xd0c03000L, 0x00000000L), HEXCONSTE(2.31833239240170234183e+05, 0x4010, 0xe2664f4fL, 0xb600c2e6L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-2.38345295190811157227e-01, 0xbffc, 0xf410ca00L, 0x00000000L), HEXCONSTE(1.02853896156385822265e+00, 0x3fff, 0x83a72a29L, 0x4a0ea665L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-2.38345310091972351074e-01, 0xbffc, 0xf410cb00L, 0x00000000L), HEXCONSTE(1.02853896514920268256e+00, 0x3fff, 0x83a72a30L, 0xfd1f062fL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-2.38345296857656208100e-01, 0xbffc, 0xf410ca1cL, 0xa2dcb000L), HEXCONSTE(1.02853896196491512161e+00, 0x3fff, 0x83a72a2aL, 0x268a6400L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.21605300903320312500e+01, 0x4003, 0xb148c400L, 0x00000000L), HEXCONSTE(2.10458242140422782348e+09, 0x401d, 0xfae2c22aL, 0xcef6f304L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), INF_P, 0 },
#if defined(TEST_LDOUBLE)
	{ __LINE__, MAX_P, INF_P, 0 },
	{ __LINE__, MAX_M, INF_P, 0 },
#endif
	{ __LINE__, HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if defined(TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16381)
	{ __LINE__, HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
#if defined(TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if defined(TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16381)
	{ __LINE__, HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
#if defined(TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if defined(TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16381)
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, SUBNORM_P, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if defined(TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16381)
	{ __LINE__, HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, SUBNORM_M, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(1.38777878078144567553e-17, 0x3fc7, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.38777878078144567553e-17, 0xbfc7, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.11758236813575084767e-22, 0x3fb7, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-2.11758236813575084767e-22, 0xbfb7, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(8.94159851074218750000e+01, 0x4005, 0xb2d4fc00L, 0x00000000L), HEXCONSTE(3.40281963750862078946e+38, 0x407e, 0xffffec1fL, 0x473940d2L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(8.94159927368164062500e+01, 0x4005, 0xb2d4fd00L, 0x00000000L), HEXCONSTE(3.40284559906118936553e+38, 0x407f, 0x8000360fL, 0xaea473a4L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-8.94159851074218750000e+01, 0xc005, 0xb2d4fc00L, 0x00000000L), HEXCONSTE(3.40281963750862078946e+38, 0x407e, 0xffffec1fL, 0x473940d2L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-8.94159927368164062500e+01, 0xc005, 0xb2d4fd00L, 0x00000000L), HEXCONSTE(3.40284559906118936553e+38, 0x407f, 0x8000360fL, 0xaea473a4L), FLAG_INEXACT2 },
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64 /* too inexact for double */
	{ __LINE__, HEXCONSTE(7.10475891113281250000e+02, 0x4008, 0xb19e7500L, 0x00000000L), HEXCONSTE(1.79774893493189901141e+308, 0x43ff, 0x80010461L, 0x80f9b78eL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(7.10475830078125000000e+02, 0x4008, 0xb19e7400L, 0x00000000L), HEXCONSTE(1.79763921239325737934e+308, 0x43fe, 0xfffe08c2L, 0xdeed02b1L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.10475860073943863426e+02, 0x4008, 0xb19e747dL, 0xcfc3e800L), HEXCONSTE(1.79769313486217438209e+308, 0x43fe, 0xffffffffL, 0xffe9d72dL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.10475891113281250000e+02, 0x4008, 0xb19e7500L, 0x00000000L), HEXCONSTE(1.79774893493189901141e+308, 0x43ff, 0x80010461L, 0x80f9b78eL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(7.10475830078125000000e+02, 0x4008, 0xb19e7400L, 0x00000000L), HEXCONSTE(1.79763921239325737934e+308, 0x43fe, 0xfffe08c2L, 0xdeed02b1L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.10475860073943977113e+02, 0x4008, 0xb19e747dL, 0xcfc3f000L), HEXCONSTE(1.79769313486237875604e+308, 0x43ff, 0x80000000L, 0x0004eb96L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-7.10475830078125000000e+02, 0xc008, 0xb19e7400L, 0x00000000L), HEXCONSTE(1.79763921239325737934e+308, 0x43fe, 0xfffe08c2L, 0xdeed02b1L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.10475891113281250000e+02, 0xc008, 0xb19e7500L, 0x00000000L), HEXCONSTE(1.79774893493189901141e+308, 0x43ff, 0x80010461L, 0x80f9b78eL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.10475860073943863426e+02, 0xc008, 0xb19e747dL, 0xcfc3e800L), HEXCONSTE(1.79769313486217438209e+308, 0x43fe, 0xffffffffL, 0xffe9d72dL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.10475830078125000000e+02, 0xc008, 0xb19e7400L, 0x00000000L), HEXCONSTE(1.79763921239325737934e+308, 0x43fe, 0xfffe08c2L, 0xdeed02b1L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.10475891113281250000e+02, 0xc008, 0xb19e7500L, 0x00000000L), HEXCONSTE(1.79774893493189901141e+308, 0x43ff, 0x80010461L, 0x80f9b78eL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.10475860073943977113e+02, 0xc008, 0xb19e747dL, 0xcfc3f000L), HEXCONSTE(1.79769313486237875604e+308, 0x43ff, 0x80000000L, 0x0004eb96L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.10475891113281250000e+02, 0x4008, 0xb19e7500L, 0x00000000L), HEXCONSTE(1.79774893493189901141e+308, 0x43ff, 0x80010461L, 0x80f9b78eL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.10475830078125000000e+02, 0x4008, 0xb19e7400L, 0x00000000L), HEXCONSTE(1.79763921239325737934e+308, 0x43fe, 0xfffe08c2L, 0xdeed02b1L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.10475860073943977113e+02, 0x4008, 0xb19e747dL, 0xcfc3f000L), HEXCONSTE(1.79769313486237875604e+308, 0x43ff, 0x80000000L, 0x0004eb96L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.10475860073943863426e+02, 0x4008, 0xb19e747dL, 0xcfc3e800L), HEXCONSTE(1.79769313486217438209e+308, 0x43fe, 0xffffffffL, 0xffe9d72dL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.10475860073943942141e+02, 0x4008, 0xb19e747dL, 0xcfc3ed8aL), HEXCONSTE(1.79769313486231588717e+308, 0x43fe, 0xffffffffL, 0xffffff2dL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.10475860073943942086e+02, 0x4008, 0xb19e747dL, 0xcfc3ed89L), HEXCONSTE(1.79769313486231578737e+308, 0x43fe, 0xffffffffL, 0xfffffb2dL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.10475891113281250000e+02, 0x4008, 0xb19e7500L, 0x00000000L), HEXCONSTE(1.79774893493189901141e+308, 0x43ff, 0x80010461L, 0x80f9b78eL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.10475830078125000000e+02, 0x4008, 0xb19e7400L, 0x00000000L), HEXCONSTE(1.79763921239325737934e+308, 0x43fe, 0xfffe08c2L, 0xdeed02b1L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.10475860073943977113e+02, 0x4008, 0xb19e747dL, 0xcfc3f000L), HEXCONSTE(1.79769313486237875604e+308, 0x43ff, 0x80000000L, 0x0004eb96L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.10475860073943863426e+02, 0x4008, 0xb19e747dL, 0xcfc3e800L), HEXCONSTE(1.79769313486217438209e+308, 0x43fe, 0xffffffffL, 0xffe9d72dL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.10475860073943942141e+02, 0x4008, 0xb19e747dL, 0xcfc3ed8aL), HEXCONSTE(1.79769313486231588717e+308, 0x43fe, 0xffffffffL, 0xffffff2dL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.10475860073943942086e+02, 0x4008, 0xb19e747dL, 0xcfc3ed89L), HEXCONSTE(1.79769313486231578737e+308, 0x43fe, 0xffffffffL, 0xfffffb2dL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.10475830078125000000e+02, 0xc008, 0xb19e7400L, 0x00000000L), HEXCONSTE(1.79763921239325737934e+308, 0x43fe, 0xfffe08c2L, 0xdeed02b1L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.10475891113281250000e+02, 0xc008, 0xb19e7500L, 0x00000000L), HEXCONSTE(1.79774893493189901141e+308, 0x43ff, 0x80010461L, 0x80f9b78eL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.10475860073943863426e+02, 0xc008, 0xb19e747dL, 0xcfc3e800L), HEXCONSTE(1.79769313486217438209e+308, 0x43fe, 0xffffffffL, 0xffe9d72dL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.10475860073943977113e+02, 0xc008, 0xb19e747dL, 0xcfc3f000L), HEXCONSTE(1.79769313486237875604e+308, 0x43ff, 0x80000000L, 0x0004eb96L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.10475860073943942086e+02, 0xc008, 0xb19e747dL, 0xcfc3ed89L), HEXCONSTE(1.79769313486231578737e+308, 0x43fe, 0xffffffffL, 0xfffffb2dL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.10475860073943942141e+02, 0xc008, 0xb19e747dL, 0xcfc3ed8aL), HEXCONSTE(1.79769313486231588717e+308, 0x43fe, 0xffffffffL, 0xffffff2dL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.10475830078125000000e+02, 0xc008, 0xb19e7400L, 0x00000000L), HEXCONSTE(1.79763921239325737934e+308, 0x43fe, 0xfffe08c2L, 0xdeed02b1L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.10475891113281250000e+02, 0xc008, 0xb19e7500L, 0x00000000L), HEXCONSTE(1.79774893493189901141e+308, 0x43ff, 0x80010461L, 0x80f9b78eL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.10475860073943863426e+02, 0xc008, 0xb19e747dL, 0xcfc3e800L), HEXCONSTE(1.79769313486217438209e+308, 0x43fe, 0xffffffffL, 0xffe9d72dL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.10475860073943977113e+02, 0xc008, 0xb19e747dL, 0xcfc3f000L), HEXCONSTE(1.79769313486237875604e+308, 0x43ff, 0x80000000L, 0x0004eb96L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.10475860073943942086e+02, 0xc008, 0xb19e747dL, 0xcfc3ed89L), HEXCONSTE(1.79769313486231578737e+308, 0x43fe, 0xffffffffL, 0xfffffb2dL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.10475860073943942141e+02, 0xc008, 0xb19e747dL, 0xcfc3ed8aL), HEXCONSTE(1.79769313486231588717e+308, 0x43fe, 0xffffffffL, 0xffffff2dL), FLAG_INEXACT3 },
#endif
	{ __LINE__, HEXCONSTE(1.13572167968750000000e+04, 0x400c, 0xb174de00L, 0x00000000L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(1.13572165534747055062e+04, 0x400c, 0xb174ddc0L, 0x31aec800L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(1.13572167968750000000e+04, 0x400c, 0xb174de00L, 0x00000000L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(1.13572165534747055062e+04, 0x400c, 0xb174ddc0L, 0x31aec800L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(1.13572165534747038951e+04, 0x400c, 0xb174ddc0L, 0x31aec0eaL), INF_P, 0 },
	{ __LINE__, HEXCONSTE(-1.13572167968750000000e+04, 0xc00c, 0xb174de00L, 0x00000000L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(-1.13572165534747055062e+04, 0xc00c, 0xb174ddc0L, 0x31aec800L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(-1.13572167968750000000e+04, 0xc00c, 0xb174de00L, 0x00000000L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(-1.13572165534747055062e+04, 0xc00c, 0xb174ddc0L, 0x31aec800L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(-1.13572165534747038951e+04, 0xc00c, 0xb174ddc0L, 0x31aec0eaL), INF_P, 0 },
	{ __LINE__, HEXCONSTE(1.13572167968750000000e+04, 0x400c, 0xb174de00L, 0x00000000L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(1.13572165534747055062e+04, 0x400c, 0xb174ddc0L, 0x31aec800L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(1.13572165534747038951e+04, 0x400c, 0xb174ddc0L, 0x31aec0eaL), INF_P, 0 },
	{ __LINE__, HEXCONSTE(1.13572167968750000000e+04, 0x400c, 0xb174de00L, 0x00000000L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(1.13572165534747055062e+04, 0x400c, 0xb174ddc0L, 0x31aec800L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(1.13572165534747038951e+04, 0x400c, 0xb174ddc0L, 0x31aec0eaL), INF_P, 0 },
	{ __LINE__, HEXCONSTE(-1.13572167968750000000e+04, 0xc00c, 0xb174de00L, 0x00000000L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(-1.13572165534747055062e+04, 0xc00c, 0xb174ddc0L, 0x31aec800L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(-1.13572165534747038951e+04, 0xc00c, 0xb174ddc0L, 0x31aec0eaL), INF_P, 0 },
	{ __LINE__, HEXCONSTE(-1.13572167968750000000e+04, 0xc00c, 0xb174de00L, 0x00000000L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(-1.13572165534747055062e+04, 0xc00c, 0xb174ddc0L, 0x31aec800L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(-1.13572165534747038951e+04, 0xc00c, 0xb174ddc0L, 0x31aec0eaL), INF_P, 0 },
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(1.13572158203125000000e+04, 0x400c, 0xb174dd00L, 0x00000000L), HEXCONSTE(1.18885954887021453402e+4932, 0x7ffe, 0xffcff816L, 0x5c0f3207L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(1.13572165534747036872e+04, 0x400c, 0xb174ddc0L, 0x31aec000L), HEXCONSTE(1.18973149535698482656e+4932, 0x7ffe, 0xffffffffL, 0xffc593dbL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(1.13572165534747038942e+04, 0x400c, 0xb174ddc0L, 0x31aec0e9L), HEXCONSTE(1.18973149535723103622e+4932, 0x7ffe, 0xffffffffL, 0xffffd3dbL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(1.13572158203125000000e+04, 0x400c, 0xb174dd00L, 0x00000000L), HEXCONSTE(1.18885954887021453402e+4932, 0x7ffe, 0xffcff816L, 0x5c0f3207L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(1.13572165534747036872e+04, 0x400c, 0xb174ddc0L, 0x31aec000L), HEXCONSTE(1.18973149535698482656e+4932, 0x7ffe, 0xffffffffL, 0xffc593dbL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(-1.13572158203125000000e+04, 0xc00c, 0xb174dd00L, 0x00000000L), HEXCONSTE(1.18885954887021453402e+4932, 0x7ffe, 0xffcff816L, 0x5c0f3207L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(-1.13572165534747036872e+04, 0xc00c, 0xb174ddc0L, 0x31aec000L), HEXCONSTE(1.18973149535698482656e+4932, 0x7ffe, 0xffffffffL, 0xffc593dbL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(-1.13572165534747038942e+04, 0xc00c, 0xb174ddc0L, 0x31aec0e9L), HEXCONSTE(1.18973149535723103622e+4932, 0x7ffe, 0xffffffffL, 0xffffd3dbL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(-1.13572158203125000000e+04, 0xc00c, 0xb174dd00L, 0x00000000L), HEXCONSTE(1.18885954887021453402e+4932, 0x7ffe, 0xffcff816L, 0x5c0f3207L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(-1.13572165534747036872e+04, 0xc00c, 0xb174ddc0L, 0x31aec000L), HEXCONSTE(1.18973149535698482656e+4932, 0x7ffe, 0xffffffffL, 0xffc593dbL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(1.13572158203125000000e+04, 0x400c, 0xb174dd00L, 0x00000000L), HEXCONSTE(1.18885954887021453402e+4932, 0x7ffe, 0xffcff816L, 0x5c0f3207L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(1.13572165534747036872e+04, 0x400c, 0xb174ddc0L, 0x31aec000L), HEXCONSTE(1.18973149535698482656e+4932, 0x7ffe, 0xffffffffL, 0xffc593dbL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(1.13572165534747038942e+04, 0x400c, 0xb174ddc0L, 0x31aec0e9L), HEXCONSTE(1.18973149535723103622e+4932, 0x7ffe, 0xffffffffL, 0xffffd3dbL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(1.13572158203125000000e+04, 0x400c, 0xb174dd00L, 0x00000000L), HEXCONSTE(1.18885954887021453402e+4932, 0x7ffe, 0xffcff816L, 0x5c0f3207L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(1.13572165534747036872e+04, 0x400c, 0xb174ddc0L, 0x31aec000L), HEXCONSTE(1.18973149535698482656e+4932, 0x7ffe, 0xffffffffL, 0xffc593dbL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(1.13572165534747038942e+04, 0x400c, 0xb174ddc0L, 0x31aec0e9L), HEXCONSTE(1.18973149535723103622e+4932, 0x7ffe, 0xffffffffL, 0xffffd3dbL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(-1.13572158203125000000e+04, 0xc00c, 0xb174dd00L, 0x00000000L), HEXCONSTE(1.18885954887021453402e+4932, 0x7ffe, 0xffcff816L, 0x5c0f3207L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(-1.13572165534747036872e+04, 0xc00c, 0xb174ddc0L, 0x31aec000L), HEXCONSTE(1.18973149535698482656e+4932, 0x7ffe, 0xffffffffL, 0xffc593dbL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(-1.13572165534747038942e+04, 0xc00c, 0xb174ddc0L, 0x31aec0e9L), HEXCONSTE(1.18973149535723103622e+4932, 0x7ffe, 0xffffffffL, 0xffffd3dbL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(-1.13572158203125000000e+04, 0xc00c, 0xb174dd00L, 0x00000000L), HEXCONSTE(1.18885954887021453402e+4932, 0x7ffe, 0xffcff816L, 0x5c0f3207L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(-1.13572165534747036872e+04, 0xc00c, 0xb174ddc0L, 0x31aec000L), HEXCONSTE(1.18973149535698482656e+4932, 0x7ffe, 0xffffffffL, 0xffc593dbL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(-1.13572165534747038942e+04, 0xc00c, 0xb174ddc0L, 0x31aec0e9L), HEXCONSTE(1.18973149535723103622e+4932, 0x7ffe, 0xffffffffL, 0xffffd3dbL), FLAG_INEXACT4 },
#endif

	{ __LINE__, HEXCONSTE(-8.000000000000000000e01, 0xc005, 0xa0000000L, 0x00000000L), HEXCONSTE(2.770311192196755026e34, 0x4071, 0xaabbcdccL, 0x279f59e3L), 0 },
	{ __LINE__, HEXCONSTE(-1.000000000000000000e01, 0xc002, 0xa0000000L, 0x00000000L), HEXCONSTE(1.101323292010332313e04, 0x400c, 0xac14ee82L, 0x9b896a46L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-5.000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.127625965206380785e00, 0x3fff, 0x90560c31L, 0x57468321L), 0 },
	{ __LINE__, HEXCONSTE(1.500000000000000000e00, 0x3fff, 0xc0000000L, 0x00000000L), HEXCONSTE(2.352409615243247325e00, 0x4000, 0x968de10fL, 0x11011214L), 0 },
	{ __LINE__, HEXCONSTE(1.000000000000000000e01, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(1.101323292010332313e04, 0x400c, 0xac14ee82L, 0x9b896a46L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(8.000000000000000000e01, 0x4005, 0xa0000000L, 0x00000000L), HEXCONSTE(2.770311192196755026e34, 0x4071, 0xaabbcdccL, 0x279f59e3L), 0 },

	{ __LINE__, HEXCONSTE(22, 0x4003, 0xb0000000L, 0x00000000L), HEXCONSTE(1792456423.065795780980053377632656584997L, 0x401d, 0xd5ad6dceL, 0x21affc0fL), FLAG_INEXACT|ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(23, 0x4003, 0xb8000000L, 0x00000000L), HEXCONSTE(4872401723.124451300068625740569997090344L, 0x401f, 0x9135799dL, 0x8fee052cL), FLAG_INEXACT|ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(24, 0x4003, 0xc0000000L, 0x00000000L), HEXCONSTE(13244561064.92173614708845674912733665919L, 0x4020, 0xc55bfdaaL, 0x3afdb99cL), ROUND_TONEAREST },

#if 0
	{ __LINE__, HEXCONSTE(22, 0x4003, 0xb0000000L, 0x00000000L), HEXCONSTE(1792456423.065795780980053377632656584997L, 0x401d, 0xd5ad6dceL, 0x21affc0fL), ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(23, 0x4003, 0xb8000000L, 0x00000000L), HEXCONSTE(4872401723.124451300068625740569997090344L, 0x401f, 0x9135799dL, 0x8fee052cL), ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(24, 0x4003, 0xc0000000L, 0x00000000L), HEXCONSTE(13244561064.92173614708845674912733665919L, 0x4020, 0xc55bfdaaL, 0x3afdb99cL), ROUND_TOWARDZERO },

	{ __LINE__, HEXCONSTE(22, 0x4003, 0xb0000000L, 0x00000000L), HEXCONSTE(1792456423.065795780980053377632656584997L, 0x401d, 0xd5ad6dceL, 0x21affc0fL), ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(23, 0x4003, 0xb8000000L, 0x00000000L), HEXCONSTE(4872401723.124451300068625740569997090344L, 0x401f, 0x9135799dL, 0x8fee052cL), ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(24, 0x4003, 0xc0000000L, 0x00000000L), HEXCONSTE(13244561064.92173614708845674912733665919L, 0x4020, 0xc55bfdaaL, 0x3afdb99cL), ROUND_DOWNWARD },

	{ __LINE__, HEXCONSTE(22, 0x4003, 0xb0000000L, 0x00000000L), HEXCONSTE(1792456423.065795780980053377632656584997L, 0x401d, 0xd5ad6dceL, 0x21affc0fL), ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(23, 0x4003, 0xb8000000L, 0x00000000L), HEXCONSTE(4872401723.124451300068625740569997090344L, 0x401f, 0x9135799dL, 0x8fee052cL), ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(24, 0x4003, 0xc0000000L, 0x00000000L), HEXCONSTE(13244561064.92173614708845674912733665919L, 0x4020, 0xc55bfdaaL, 0x3afdb99cL), ROUND_UPWARD },
#endif
};

int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_f_f(fcosh_data, ARRAY_SIZE(fcosh_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

```

`tests/csign.c`:

```c
#include "testconfig.h"
#ifdef HAVE_COPYSIGN
#define TEST_FUNC_FF_F __MATH_PRECNAME(copysign)
#include "testdriver.h"


static test_ff_f_data const copysign_data[] = {
	{ __LINE__, ZERO_P, HEXCONSTE(4, 0x4001, 0x80000000L, 0x00000000L), ZERO_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_P, HEXCONSTE(-4, 0xc001, 0x80000000L, 0x00000000L), ZERO_M, NO_INEXACT_EXCEPTION|FLAG_FAIL_ARANYM2 },
	{ __LINE__, ZERO_M, HEXCONSTE(4, 0x4001, 0x80000000L, 0x00000000L), ZERO_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_M, HEXCONSTE(-4, 0xc001, 0x80000000L, 0x00000000L), ZERO_M, NO_INEXACT_EXCEPTION|FLAG_FAIL_ARANYM2 },

	{ __LINE__, INF_P, ZERO_P, INF_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, INF_P, ZERO_M, INF_M, NO_INEXACT_EXCEPTION },
	{ __LINE__, INF_M, ZERO_P, INF_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, INF_M, ZERO_M, INF_M, NO_INEXACT_EXCEPTION },

	{ __LINE__, ZERO_P, INF_P, ZERO_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_P, ZERO_M, ZERO_M, NO_INEXACT_EXCEPTION|FLAG_FAIL_ARANYM2 },
	{ __LINE__, ZERO_M, INF_P, ZERO_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_M, ZERO_M, ZERO_M, NO_INEXACT_EXCEPTION|FLAG_FAIL_ARANYM2 },

	/* XXX More correctly we would have to check the sign of the NaN.  */
	{ __LINE__, QNAN_P, ZERO_P, QNAN_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_P, ZERO_M, QNAN_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_M, ZERO_P, QNAN_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_M, ZERO_M, QNAN_P, NO_INEXACT_EXCEPTION },
};

int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_ff_f(copysign_data, ARRAY_SIZE(copysign_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

#else

int main(void)
{
	return 77;
}

#endif

```

`tests/drem.c`:

```c
#include "testconfig.h"
#define TEST_FUNC_FF_F __MATH_PRECNAME(drem)
#include "testdriver.h"


static test_ff_f_data const drem_data[] = {
	{ __LINE__, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), ZERO_P, QNAN_P, NO_INEXACT_EXCEPTION|INVALID_EXCEPTION|ERRNO_EDOM },
	{ __LINE__, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), ZERO_M, QNAN_P, NO_INEXACT_EXCEPTION|INVALID_EXCEPTION|ERRNO_EDOM },
	{ __LINE__, INF_P, ZERO_M, QNAN_P, NO_INEXACT_EXCEPTION|INVALID_EXCEPTION|ERRNO_EDOM },
	{ __LINE__, INF_P, ZERO_P, QNAN_P, NO_INEXACT_EXCEPTION|INVALID_EXCEPTION|ERRNO_EDOM },
	{ __LINE__, INF_P, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), QNAN_P, NO_INEXACT_EXCEPTION|INVALID_EXCEPTION|ERRNO_EDOM },
	{ __LINE__, INF_P, HEXCONSTE(2, 0x4000, 0x80000000L, 0x00000000L), QNAN_P, NO_INEXACT_EXCEPTION|INVALID_EXCEPTION|ERRNO_EDOM },
	{ __LINE__, INF_M, ZERO_M, QNAN_P, NO_INEXACT_EXCEPTION|INVALID_EXCEPTION|ERRNO_EDOM },
	{ __LINE__, INF_M, ZERO_P, QNAN_P, NO_INEXACT_EXCEPTION|INVALID_EXCEPTION|ERRNO_EDOM },
	{ __LINE__, INF_M, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), QNAN_P, NO_INEXACT_EXCEPTION|INVALID_EXCEPTION|ERRNO_EDOM },
	{ __LINE__, INF_M, HEXCONSTE(2, 0x4000, 0x80000000L, 0x00000000L), QNAN_P, NO_INEXACT_EXCEPTION|INVALID_EXCEPTION|ERRNO_EDOM },
	{ __LINE__, QNAN_P, QNAN_P, QNAN_P, NO_INEXACT_EXCEPTION|ERRNO_UNCHANGED },
	{ __LINE__, ZERO_P, QNAN_P, QNAN_P, NO_INEXACT_EXCEPTION|ERRNO_UNCHANGED },
	{ __LINE__, QNAN_P, ZERO_P, QNAN_P, NO_INEXACT_EXCEPTION|ERRNO_UNCHANGED },

	{ __LINE__, HEXCONSTE(7.0, 0x4001, 0xe0000000L, 0x00000000L), INF_P, HEXCONSTE(7.0, 0x4001, 0xe0000000L, 0x00000000L), NO_INEXACT_EXCEPTION|ERRNO_UNCHANGED|FLAG_FAIL_ARANYM }, /* returns NaN */
	{ __LINE__, HEXCONSTE(7.0, 0x4001, 0xe0000000L, 0x00000000L), INF_M, HEXCONSTE(7.0, 0x4001, 0xe0000000L, 0x00000000L), NO_INEXACT_EXCEPTION|ERRNO_UNCHANGED|FLAG_FAIL_ARANYM }, /* returns NaN */

	{ __LINE__, HEXCONSTE(1.625, 0x3fff, 0xd0000000L, 0x00000000L), HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-0.375, 0xbffd, 0xc0000000L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-1.625, 0xbfff, 0xd0000000L, 0x00000000L), HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.375, 0x3ffd, 0xc0000000L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.625, 0x3fff, 0xd0000000L, 0x00000000L), HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-0.375, 0xbffd, 0xc0000000L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-1.625, 0xbfff, 0xd0000000L, 0x00000000L), HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(0.375, 0x3ffd, 0xc0000000L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(5.0, 0x4001, 0xa0000000L, 0x00000000L), HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), NO_INEXACT_EXCEPTION|FLAG_FAIL_ARANYM }, /* returns -1, which is OK */
	{ __LINE__, HEXCONSTE(3.0, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), NO_INEXACT_EXCEPTION },
};


int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_ff_f(drem_data, ARRAY_SIZE(drem_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

```

`tests/erf.c`:

```c
#include "testconfig.h"
#define TEST_FUNC_F_F __MATH_PRECNAME(erf)
#include "testdriver.h"



static test_f_f_data const erf_data[] = {
	{ __LINE__, ZERO_P, ZERO_P, 0 },
	{ __LINE__, ZERO_M, ZERO_M, FLAG_FAIL_ARANYM2 },
	{ __LINE__, INF_P, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, INF_M, HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_P, 0 },
	{ __LINE__, SNAN_P, QNAN_P, 0 },
	{ __LINE__, SNAN_M, QNAN_P, 0 },

	{ __LINE__, HEXCONSTE(0.125L, 0x3ffc, 0x80000000L, 0x00000000L), HEXCONSTE(0.140316204801333817393029446521623398L, 0x3ffc, 0x8faf0d1aL, 0xe1dc4ba1L), 0 },
	{ __LINE__, HEXCONSTE(0.75L, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(0.711155633653515131598937834591410777L, 0x3ffe, 0xb60e4bacL, 0xe872fb63L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.25L, 0x3fff, 0xa0000000L, 0x00000000L), HEXCONSTE(0.922900128256458230136523481197281140L, 0x3ffe, 0xec432eccL, 0x55f00406L), FLAG_FAIL_ARANYM }, /* too inexact when using double */
	{ __LINE__, HEXCONSTE(2.0L, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(0.995322265018952734162069256367252929L, 0x3ffe, 0xfecd70a1L, 0x3caf1997L), 0 },
	{ __LINE__, HEXCONSTE(4.125L, 0x4001, 0x84000000L, 0x00000000L), HEXCONSTE(0.999999994576599200434933994687765914L, 0x3ffe, 0xffffffe8L, 0xb4e862e1L), 0 },
	{ __LINE__, HEXCONSTE(27.0L, 0x4003, 0xd8000000L, 0x00000000L), HEXCONSTE(1.0L, 0x3fff, 0x80000000L, 0x00000000L), 0 },
};

int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_f_f(erf_data, ARRAY_SIZE(erf_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

```

`tests/erfc.c`:

```c
#include "testconfig.h"
#define TEST_FUNC_F_F __MATH_PRECNAME(erfc)
#include "testdriver.h"



static test_f_f_data const erfc_data[] = {
	{ __LINE__, ZERO_P, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, ZERO_M, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, INF_P, ZERO_P, 0 },
	{ __LINE__, INF_M, HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_P, 0 },
	{ __LINE__, SNAN_P, QNAN_P, 0 },
	{ __LINE__, SNAN_M, QNAN_P, 0 },

	{ __LINE__, HEXCONSTE(0.125L, 0x3ffc, 0x80000000L, 0x00000000L), HEXCONSTE(0.859683795198666182606970553478376602L, 0x3ffe, 0xdc143cb9L, 0x4788ed18L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(0.75L, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(0.288844366346484868401062165408589223L, 0x3ffd, 0x93e368a6L, 0x2f1a093bL), 0 },
	{ __LINE__, HEXCONSTE(1.25L, 0x3fff, 0xa0000000L, 0x00000000L), HEXCONSTE(0.0770998717435417698634765188027188596L, 0x3ffb, 0x9de6899dL, 0x507fdfcfL), FLAG_INEXACT|FLAG_FAIL_ARANYM }, /* too inexact when using double */
	{ __LINE__, HEXCONSTE(2.0L, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(0.00467773498104726583793074363274707139L, 0x3ff7, 0x9947af61L, 0xa873346cL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.93115949630737304688e+00, 0x4000, 0xfb981e00L, 0x00000000L), HEXCONSTE(2.705500297238986897105236321218861842255e-8L, 0x3fe5, 0xe86694a9L, 0xc24115c3L), FLAG_FAIL_ARANYM }, /* too inexact when using double */
	{ __LINE__, HEXCONSTE(4.125L, 0x4001, 0x84000000L, 0x00000000L), HEXCONSTE(0.542340079956506600531223408575531062e-8L, 0x3fe3, 0xba58bce8L, 0xf5d404f9L), FLAG_FAIL_ARANYM }, /* too inexact when using double */
	{ __LINE__, HEXCONSTE(7.99414110183715820312e+00, 0x4001, 0xffd00100L, 0x00000000L), HEXCONSTE(1.233585992097580296336099501489175967033e-29L, 0x3f9e, 0xfa33725bL, 0xea2f7d7bL), FLAG_INEXACT|FLAG_FAIL_ARANYM }, /* too inexact when using double */
	{ __LINE__, HEXCONSTE(7.99998664855957031250e+00, 0x4001, 0xffffe400L, 0x00000000L), HEXCONSTE(1.122671365033056305522366683719541099329e-29L, 0x3f9e, 0xe3b46e15L, 0xad97825dL), FLAG_FAIL_ARANYM }, /* too inexact when using double */
#ifdef TEST_LDOUBLE
	/* The result can only be represented in long double.  */
# if LDBL_MIN_10_EXP < -319
	{ __LINE__, HEXCONSTE(27.0L, 0x4003, 0xd8000000L, 0x00000000L), HEXCONSTE(0.523704892378925568501606768284954709e-318L, 0x3bdd, 0xcf07866fL, 0xc1d3afd1L), 0 },
# endif
# if LDBL_MANT_DIG >= 106
	{ __LINE__, HEXCONSTE(7.99995958116319444073e+00, 0x4001, 0xffffab3cL, 0x4d5e6f78L), HEXCONSTE(1.123161416304655390092138725253789378459e-29L, 0x3f9e, 0xe3cddffbL, 0xbe84faf8L), 0 },
# endif
#endif
};

int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_f_f(erfc_data, ARRAY_SIZE(erfc_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

```

`tests/exp.c`:

```c
#include "testconfig.h"
#define TEST_FUNC_F_F __MATH_PRECNAME(exp)
#include "testdriver.h"



static test_f_f_data const fetox_data[] = {
	{ __LINE__, ZERO_P, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, ZERO_M, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, INF_P, INF_P, FLAG_FAIL_JIT|FLAG_FAIL_ARANYM },
	{ __LINE__, INF_M, ZERO_P, FLAG_FAIL_JIT|FLAG_FAIL_ARANYM },
	{ __LINE__, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_P, 0 },
	{ __LINE__, SNAN_P, QNAN_P, 0 },
	{ __LINE__, SNAN_M, QNAN_P, 0 },

	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(2.71828182845904523543e+00, 0x4000, 0xadf85458L, 0xa2bb4a9bL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(7.38905609893065022740e+00, 0x4001, 0xec7325c6L, 0xa6ed6e62L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(3.00000000000000000000e+00, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(2.00855369231876677415e+01, 0x4003, 0xa0af2dfbL, 0x7d882f97L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(7.50000000000000000000e-01, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(2.11700001661267466846e+00, 0x4000, 0x877ceda3L, 0x3ee7bdeaL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(5.00000000000000000000e+01, 0x4004, 0xc8000000L, 0x00000000L), HEXCONSTE(5.18470552858707246387e+21, 0x4047, 0x8c881f20L, 0x405a2b32L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(8.87226943969726562500e+01, 0x4005, 0xb1720500L, 0x00000000L), HEXCONSTE(3.40233126623160774934e+38, 0x407e, 0xfff68444L, 0x10e1f547L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.09750000000000000000e+02, 0x4008, 0xb1700000L, 0x00000000L), HEXCONSTE(1.73983687326416055766e+308, 0x43fe, 0xf7c2d08fL, 0x39f969a2L), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
#if defined TEST_LDOUBLE && LDBL_MAX_EXP > 1024
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+03, 0x4008, 0xfa000000L, 0x00000000L), HEXCONSTE(1.97007111401704699387e+434, 0x45a1, 0xcf391bcdL, 0x76b9d6c0L), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(7.10000000000000000000e+02, 0x4008, 0xb1800000L, 0x00000000L), HEXCONSTE(2.23399476616171103119e+308, 0x43ff, 0x9f10d232L, 0x283fca50L), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(-1.23400000000000000000e+03, 0xc009, 0x9a400000L, 0x00000000L), HEXCONSTE(1.20395244043727320129e-536, 0x390a, 0xd202c22eL, 0x749b3087L), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(7.10475891113281250000e+02, 0x4008, 0xb19e7500L, 0x00000000L), HEXCONSTE(3.59549786986379802282e+308, 0x4400, 0x80010461L, 0x80f9b78eL), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(7.10475830078125000000e+02, 0x4008, 0xb19e7400L, 0x00000000L), HEXCONSTE(3.59527842478651475867e+308, 0x43ff, 0xfffe08c2L, 0xdeed02b1L), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(7.10475860073943977113e+02, 0x4008, 0xb19e747dL, 0xcfc3f000L), HEXCONSTE(3.59538626972475751208e+308, 0x4400, 0x80000000L, 0x0004eb96L), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(7.10475860073943863426e+02, 0x4008, 0xb19e747dL, 0xcfc3e800L), HEXCONSTE(3.59538626972434876418e+308, 0x43ff, 0xffffffffL, 0xffe9d72dL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.10475860073943942141e+02, 0x4008, 0xb19e747dL, 0xcfc3ed8aL), HEXCONSTE(3.59538626972463177433e+308, 0x43ff, 0xffffffffL, 0xffffff2dL), FLAG_INEXACT3 },
#endif
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+05, 0x400f, 0xc3500000L, 0x00000000L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), INF_P, FLAG_FAIL_ARANYM },
#if defined TEST_LDOUBLE && LDBL_MAX_EXP > 1024
	{ __LINE__, HEXCONSTE(-7.44440002441406250000e+02, 0xc008, 0xba1c2900L, 0x00000000L), HEXCONSTE(4.94099974702544439299e-324, 0x3bcd, 0x800246dcL, 0x4b34e080L), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(-7.44440063476562500000e+02, 0xc008, 0xba1c2a00L, 0x00000000L), HEXCONSTE(4.94069818153699545601e-324, 0x3bcd, 0x800046d7L, 0x2fd09526L), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(-7.44440061921381129650e+02, 0xc008, 0xba1c29f9L, 0x7a230000L), HEXCONSTE(4.94070586522473866525e-324, 0x3bcd, 0x800053e2L, 0xf1b31f42L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.44440061921381243337e+02, 0xc008, 0xba1c29f9L, 0x7a230800L), HEXCONSTE(4.94070586522417697175e-324, 0x3bcd, 0x800053e2L, 0xf1a31f37L), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(-7.44440061921381239951e+02, 0xc008, 0xba1c29f9L, 0x7a2307c3L), HEXCONSTE(4.94070586522419370224e-324, 0x3bcd, 0x800053e2L, 0xf1a39938L), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(-7.44440061921381240007e+02, 0xc008, 0xba1c29f9L, 0x7a2307c4L), HEXCONSTE(4.94070586522419342798e-324, 0x3bcd, 0x800053e2L, 0xf1a39738L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.47883361816406250000e+02, 0xc008, 0xbaf88900L, 0x00000000L), HEXCONSTE(1.57900263911926618176e-325, 0x3bc8, 0x82e7d3d9L, 0x2bb5656eL), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(-7.47883422851562500000e+02, 0xc008, 0xbaf88a00L, 0x00000000L), HEXCONSTE(1.57890626738753014504e-325, 0x3bc8, 0x82e5c83dL, 0xf389e114L), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(-7.47883415584969952761e+02, 0xc008, 0xbaf889e1L, 0x858e4000L), HEXCONSTE(1.57891774069773141724e-325, 0x3bc8, 0x82e60694L, 0x26eadca6L), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
#endif
	{ __LINE__, HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), FLAG_FAIL_ARANYM },
#if defined TEST_LDOUBLE && LDBL_MAX_EXP > 1024
	{ __LINE__, HEXCONSTE(-1.13428125000000000000e+04, 0xc00c, 0xb13b4000L, 0x00000000L), HEXCONSTE(7.57045507827611838830e-4927, 0x0012, 0xdbe48e25L, 0x32594eccL), FLAG_INEXACT5|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(-1.13551367187500000000e+04, 0xc00c, 0xb16c8c00L, 0x00000000L), HEXCONSTE(3.36342532490578472002e-4932, 0x0001, 0x800ce2e8L, 0x21237048L), FLAG_INEXACT5|FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(-1.13551376953125000000e+04, 0xc00c, 0xb16c8d00L, 0x00000000L), HEXCONSTE(3.36014233314616039875e-4932, 0x0000, 0xffd9c75eL, 0xf1b3a563L), FLAG_INEXACT_SUBNORM|FLAG_FAIL_X87 }, /* 68030: 0000:ffd9c75e:f1b3a2ea */
	{ __LINE__, HEXCONSTE(-1.13551371119330233341e+04, 0xc00c, 0xb16c8c67L, 0x1210e800L), HEXCONSTE(3.36210314311453016213e-4932, 0x0001, 0x80000000L, 0x0065ff91L), FLAG_INEXACT5|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(-1.13551371119330251531e+04, 0xc00c, 0xb16c8c67L, 0x1210f000L), HEXCONSTE(3.36210314310841453177e-4932, 0x0000, 0xffffffffL, 0xfecbff21L), FLAG_INEXACT_SUBNORM }, /* 68030: 0000:ffffffff:fecbfca9 */
	{ __LINE__, HEXCONSTE(-1.13551371119330240589e+04, 0xc00c, 0xb16c8c67L, 0x1210eb30L), HEXCONSTE(3.36210314311209346544e-4932, 0x0000, 0xffffffffL, 0xffffff21L), FLAG_INEXACT_SUBNORM|FLAG_FAIL_ARANYM }, /* 68030: 0000:ffffffff:fffffca9 */
	{ __LINE__, HEXCONSTE(-7.08413452148437500000e+02, 0xc008, 0xb11a7600L, 0x00000000L), HEXCONSTE(2.18749377543153346474e-308, 0x3c00, 0xfbad237cL, 0x846f8da5L), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(-7.08413513183593750000e+02, 0xc008, 0xb11a7700L, 0x00000000L), HEXCONSTE(2.18736026548159587328e-308, 0x3c00, 0xfba934cfL, 0xd3dc1b49L), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(-7.08413467407226562500e+02, 0xc008, 0xb11a7640L, 0x00000000L), HEXCONSTE(2.18746039718009511977e-308, 0x3c00, 0xfbac27cfL, 0xdec97101L), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(-7.08428039550781250000e+02, 0xc008, 0xb11b6500L, 0x00000000L), HEXCONSTE(2.15581553694847398749e-308, 0x3c00, 0xf8081b4dL, 0x93f88db6L), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(-7.08428100585937500000e+02, 0xc008, 0xb11b6600L, 0x00000000L), HEXCONSTE(2.15568396042576781757e-308, 0x3c00, 0xf8043b34L, 0xe6f8c29fL), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(-7.08428070068359375000e+02, 0xc008, 0xb11b6580L, 0x00000000L), HEXCONSTE(2.15574974768327169992e-308, 0x3c00, 0xf8062b3fL, 0x4d6c51acL), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(-7.08402893066406250000e+02, 0xc008, 0xb119c900L, 0x00000000L), HEXCONSTE(2.21071407844761514284e-308, 0x3c00, 0xfe590e3bL, 0x45eaf941L), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(-7.08402954101562500000e+02, 0xc008, 0xb119ca00L, 0x00000000L), HEXCONSTE(2.21057915128610509729e-308, 0x3c00, 0xfe5514deL, 0xffbbba6eL), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(-7.08402938842773437500e+02, 0xc008, 0xb119c9c0L, 0x00000000L), HEXCONSTE(2.21061288230442712452e-308, 0x3c00, 0xfe561334L, 0x93c56efdL), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(-7.08413513183593750000e+02, 0xc008, 0xb11a7700L, 0x00000000L), HEXCONSTE(2.18736026548159587328e-308, 0x3c00, 0xfba934cfL, 0xd3dc1b49L), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(-7.08413574218750000000e+02, 0xc008, 0xb11a7800L, 0x00000000L), HEXCONSTE(2.18722676368021026056e-308, 0x3c00, 0xfba54632L, 0xdddbf5ffL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.08413543701171875000e+02, 0xc008, 0xb11a7780L, 0x00000000L), HEXCONSTE(2.18729351356236515365e-308, 0x3c00, 0xfba73d7fL, 0x618d8da5L), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(-7.08421936035156250000e+02, 0xc008, 0xb11b0100L, 0x00000000L), HEXCONSTE(2.16901382777714292319e-308, 0x3c00, 0xf98cd75cL, 0x11ed6e6eL), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(-7.08417419433593750000e+02, 0xc008, 0xb11ab700L, 0x00000000L), HEXCONSTE(2.17883255597073741154e-308, 0x3c00, 0xfaae0945L, 0xb761a57aL), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(-7.08417480468750000000e+02, 0xc008, 0xb11ab800L, 0x00000000L), HEXCONSTE(2.17869957464355047520e-308, 0x3c00, 0xfaaa1e95L, 0x67b0a041L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.08417449951171875000e+02, 0xc008, 0xb11ab780L, 0x00000000L), HEXCONSTE(2.17876606429257693297e-308, 0x3c00, 0xfaac13ebL, 0x9a30fb05L), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(-7.08444091796875000000e+02, 0xc008, 0xb11c6c00L, 0x00000000L), HEXCONSTE(2.12148612465217699159e-308, 0x3c00, 0xf414fd14L, 0x5db5ac5cL), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(-7.08444152832031250000e+02, 0xc008, 0xb11c6d00L, 0x00000000L), HEXCONSTE(2.12135664336657208446e-308, 0x3c00, 0xf4112cc8L, 0x0a01f2a8L), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(-7.08444137573242187500e+02, 0xc008, 0xb11c6cc0L, 0x00000000L), HEXCONSTE(2.12138901294707922053e-308, 0x3c00, 0xf41220d9L, 0xb0d2bbbcL), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(-7.08412353515625000000e+02, 0xc008, 0xb11a6400L, 0x00000000L), HEXCONSTE(2.18989834849993977756e-308, 0x3c00, 0xfbf3f623L, 0xa7723f83L), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(-7.08412414550781250000e+02, 0xc008, 0xb11a6500L, 0x00000000L), HEXCONSTE(2.18976469179098801663e-308, 0x3c00, 0xfbf0065bL, 0xae78d362L), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(-7.08412399291992187500e+02, 0xc008, 0xb11a64c0L, 0x00000000L), HEXCONSTE(2.18979810520344002356e-308, 0x3c00, 0xfbf1024cL, 0x32ccaf06L), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(-7.08623535156250000000e+02, 0xc008, 0xb127e800L, 0x00000000L), HEXCONSTE(1.77300081349513834186e-308, 0x3c00, 0xcbfce8eaL, 0x1e6c3d01L), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(-7.08672119140625000000e+02, 0xc008, 0xb12b0400L, 0x00000000L), HEXCONSTE(1.68892038869162891565e-308, 0x3c00, 0xc250747fL, 0xcd46dd67L), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(-7.08845947265625000000e+02, 0xc008, 0xb1362400L, 0x00000000L), HEXCONSTE(1.41943850803859062422e-308, 0x3c00, 0xa34f4bd9L, 0x75192ca0L), FLAG_INEXACT3 },
#endif
#if defined TEST_DOUBLE
	{ __LINE__, HEXCONSTE(-7.08413452148437500000e+02, 0xc008, 0xb11a7600L, 0x00000000L), HEXCONSTE(2.2062838169693674602824e-308, 0x3c00, 0xfdd691beL, 0x4237c800L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.08413513183593750000e+02, 0xc008, 0xb11a7700L, 0x00000000L), HEXCONSTE(2.2062170619943987009802e-308, 0x3c00, 0xfdd49a67L, 0xe9ee1000L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.08413467407226562500e+02, 0xc008, 0xb11a7640L, 0x00000000L), HEXCONSTE(2.2062671278436482359294e-308, 0x3c00, 0xfdd613e7L, 0xef64b800L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.08428039550781250000e+02, 0xc008, 0xb11b6500L, 0x00000000L), HEXCONSTE(2.1904446977278377206321e-308, 0x3c00, 0xfc040da6L, 0xc9fc4800L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.08428100585937500000e+02, 0xc008, 0xb11b6600L, 0x00000000L), HEXCONSTE(2.1903789094664845598611e-308, 0x3c00, 0xfc021d9aL, 0x737c6000L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.08428070068359375000e+02, 0xc008, 0xb11b6580L, 0x00000000L), HEXCONSTE(2.1904118030952365156933e-308, 0x3c00, 0xfc03159fL, 0xa6b62800L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.08402893066406250000e+02, 0xc008, 0xb119c900L, 0x00000000L), HEXCONSTE(2.2178939684774083671239e-308, 0x3c00, 0xff2c871dL, 0xa2f58000L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.08402954101562500000e+02, 0xc008, 0xb119ca00L, 0x00000000L), HEXCONSTE(2.2178265048966533261942e-308, 0x3c00, 0xff2a8a6fL, 0x7fdde000L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.08402938842773437500e+02, 0xc008, 0xb119c9c0L, 0x00000000L), HEXCONSTE(2.2178433704058142694272e-308, 0x3c00, 0xff2b099aL, 0x49e2b800L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.08413513183593750000e+02, 0xc008, 0xb11a7700L, 0x00000000L), HEXCONSTE(2.2062170619943987009802e-308, 0x3c00, 0xfdd49a67L, 0xe9ee1000L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.08413574218750000000e+02, 0xc008, 0xb11a7800L, 0x00000000L), HEXCONSTE(2.2061503110937057292502e-308, 0x3c00, 0xfdd2a319L, 0x6eedf800L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.08413543701171875000e+02, 0xc008, 0xb11a7780L, 0x00000000L), HEXCONSTE(2.2061836860347833047365e-308, 0x3c00, 0xfdd39ebfL, 0xb0c6c800L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.08421936035156250000e+02, 0xc008, 0xb11b0100L, 0x00000000L), HEXCONSTE(2.1970438431421721773840e-308, 0x3c00, 0xfcc66baeL, 0x08f6b800L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.08417419433593750000e+02, 0xc008, 0xb11ab700L, 0x00000000L), HEXCONSTE(2.2019532072389693127583e-308, 0x3c00, 0xfd5704a2L, 0xdbb0d000L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.08417480468750000000e+02, 0xc008, 0xb11ab800L, 0x00000000L), HEXCONSTE(2.2018867165753759252229e-308, 0x3c00, 0xfd550f4aL, 0xb3d85000L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.08417449951171875000e+02, 0xc008, 0xb11ab780L, 0x00000000L), HEXCONSTE(2.2019199613998892349261e-308, 0x3c00, 0xfd5609f5L, 0xcd188000L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.08444091796875000000e+02, 0xc008, 0xb11c6c00L, 0x00000000L), HEXCONSTE(2.1732799915796892435508e-308, 0x3c00, 0xfa0a7e8aL, 0x2edad800L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.08444152832031250000e+02, 0xc008, 0xb11c6d00L, 0x00000000L), HEXCONSTE(2.1732152509368866927658e-308, 0x3c00, 0xfa089664L, 0x0500f800L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.08444137573242187500e+02, 0xc008, 0xb11c6cc0L, 0x00000000L), HEXCONSTE(2.1732314357271403676698e-308, 0x3c00, 0xfa09106cL, 0xd8696000L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.08412353515625000000e+02, 0xc008, 0xb11a6400L, 0x00000000L), HEXCONSTE(2.2074861035035705878619e-308, 0x3c00, 0xfdf9fb11L, 0xd3b92000L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.08412414550781250000e+02, 0xc008, 0xb11a6500L, 0x00000000L), HEXCONSTE(2.2074192751490946476308e-308, 0x3c00, 0xfdf8032dL, 0xd73c6800L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.08412399291992187500e+02, 0xc008, 0xb11a64c0L, 0x00000000L), HEXCONSTE(2.2074359818553207184037e-308, 0x3c00, 0xfdf88126L, 0x19665800L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.08623535156250000000e+02, 0xc008, 0xb127e800L, 0x00000000L), HEXCONSTE(1.9990373360011699087349e-308, 0x3c00, 0xe5fe7475L, 0x0f362000L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.08672119140625000000e+02, 0xc008, 0xb12b0400L, 0x00000000L), HEXCONSTE(1.9569971235994151894772e-308, 0x3c00, 0xe1283a3fL, 0xe6a37000L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.08845947265625000000e+02, 0xc008, 0xb1362400L, 0x00000000L), HEXCONSTE(1.8222561832728960557655e-308, 0x3c00, 0xd1a7a5ecL, 0xba8c9800L), FLAG_INEXACT3 },
#endif
	{ __LINE__, HEXCONSTE(9.76562500000000000000e-04, 0x3ff5, 0x80000000L, 0x00000000L), HEXCONSTE(1.00097703949241653525e+00, 0x3fff, 0x80200400L, 0x555aaaefL), 0 },
	{ __LINE__, HEXCONSTE(-9.76562500000000000000e-04, 0xbff5, 0x80000000L, 0x00000000L), HEXCONSTE(9.99023914181975662208e-01, 0x3ffe, 0xffc007ffL, 0x555fff77L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.53674316406250000000e-07, 0x3feb, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000095367477115371e+00, 0x3fff, 0x80000800L, 0x00400001L), 0 },
	{ __LINE__, HEXCONSTE(-9.53674316406250000000e-07, 0xbfeb, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999046326138340938e-01, 0x3ffe, 0xfffff000L, 0x007ffffdL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.31322574615478515625e-10, 0x3fe1, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000093132257505e+00, 0x3fff, 0x80000002L, 0x00000004L), 0 },
	{ __LINE__, HEXCONSTE(-9.31322574615478515625e-10, 0xbfe1, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999999068677425818e-01, 0x3ffe, 0xfffffffcL, 0x00000008L), 0 },
	{ __LINE__, HEXCONSTE(9.09494701772928237915e-13, 0x3fd7, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000090949470e+00, 0x3fff, 0x80000000L, 0x00800000L), 0 },
	{ __LINE__, HEXCONSTE(-9.09494701772928237915e-13, 0xbfd7, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999999999090505298e-01, 0x3ffe, 0xffffffffL, 0xff000000L), 0 },
	{ __LINE__, HEXCONSTE(8.88178419700125232339e-16, 0x3fcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000088818e+00, 0x3fff, 0x80000000L, 0x00002000L), 0 },
	{ __LINE__, HEXCONSTE(-8.88178419700125232339e-16, 0xbfcd, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999999999999111822e-01, 0x3ffe, 0xffffffffL, 0xffffc000L), 0 },
	{ __LINE__, HEXCONSTE(8.67361737988403547206e-19, 0x3fc3, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000087e+00, 0x3fff, 0x80000000L, 0x00000008L), 0 },
	{ __LINE__, HEXCONSTE(-8.67361737988403547206e-19, 0xbfc3, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999999999999999133e-01, 0x3ffe, 0xffffffffL, 0xfffffff0L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(7.88860905221011805412e-31, 0x3f9b, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-7.88860905221011805412e-31, 0xbf9b, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.40991986510288411774e-181, 0x3da7, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-2.40991986510288411774e-181, 0xbda7, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(5.01237274920645200930e-3011, 0x18ef, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-5.01237274920645200930e-3011, 0x98ef, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(8.87228317260742187500e+01, 0x4005, 0xb1721700L, 0x00000000L), HEXCONSTE(3.40279853741184865681e+38, 0x407e, 0xffff8417L, 0x363ff68fL), FLAG_INEXACT2|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(8.87228393554687500000e+01, 0x4005, 0xb1721800L, 0x00000000L), HEXCONSTE(3.40282449880343565562e+38, 0x407f, 0x8000020bL, 0x8c25c3c3L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-8.73365478515625000000e+01, 0xc005, 0xaeac5000L, 0x00000000L), HEXCONSTE(1.17549070560891844817e-38, 0x3f80, 0xffffcbf9L, 0x49674072L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-8.73365402221679687500e+01, 0xc005, 0xaeac4f00L, 0x00000000L), HEXCONSTE(1.17549967392549072525e-38, 0x3f81, 0x800025fcL, 0xa7b1f1fdL), FLAG_INEXACT2 },
#if defined TEST_LDOUBLE && LDBL_MAX_EXP > 1024
	{ __LINE__, HEXCONSTE(7.09782714843750000000e+02, 0x4008, 0xb1721800L, 0x00000000L), HEXCONSTE(1.79769664102530940090e+308, 0x43ff, 0x8000105cL, 0x621855efL), FLAG_INEXACT2|FLAG_FAIL_ARANYM },
#endif
	{ __LINE__, HEXCONSTE(7.09782653808593750000e+02, 0x4008, 0xb1721700L, 0x00000000L), HEXCONSTE(1.79758692167833712539e+308, 0x43fe, 0xfffc20c0L, 0x4143f640L), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(7.09782712893383973096e+02, 0x4008, 0xb17217f7L, 0xd1cf7800L), HEXCONSTE(1.79769313486227321780e+308, 0x43fe, 0xffffffffL, 0xfff950d8L), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
#if defined TEST_LDOUBLE && LDBL_MAX_EXP > 1024
	{ __LINE__, HEXCONSTE(7.09782714843750000000e+02, 0x4008, 0xb1721800L, 0x00000000L), HEXCONSTE(1.79769664102530940090e+308, 0x43ff, 0x8000105cL, 0x621855efL), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
#endif
	{ __LINE__, HEXCONSTE(7.09782653808593750000e+02, 0x4008, 0xb1721700L, 0x00000000L), HEXCONSTE(1.79758692167833712539e+308, 0x43fe, 0xfffc20c0L, 0x4143f640L), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
#if defined TEST_LDOUBLE && LDBL_MAX_EXP > 1024
	{ __LINE__, HEXCONSTE(7.09782712893384086783e+02, 0x4008, 0xb17217f7L, 0xd1cf8000L), HEXCONSTE(1.79769313486247759184e+308, 0x43ff, 0x80000000L, 0x000ca86cL), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
#endif
	{ __LINE__, HEXCONSTE(-7.08396362304687500000e+02, 0xc008, 0xb1195e00L, 0x00000000L), HEXCONSTE(2.22519897253543144472e-308, 0x3c01, 0x8001d7afL, 0x3231a984L), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
#if defined TEST_LDOUBLE && LDBL_MAX_EXP > 1024
	{ __LINE__, HEXCONSTE(-7.08396423339843750000e+02, 0xc008, 0xb1195f00L, 0x00000000L), HEXCONSTE(2.22506316131312715353e-308, 0x3c00, 0xffffaf57L, 0xa6fc91a7L), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(-7.08396418532264192436e+02, 0xc008, 0xb1195eebL, 0xd5e69800L), HEXCONSTE(2.22507385850700955631e-308, 0x3c00, 0xffffffffL, 0xffe7bbd0L), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
#endif
	{ __LINE__, HEXCONSTE(-7.08396362304687500000e+02, 0xc008, 0xb1195e00L, 0x00000000L), HEXCONSTE(2.22519897253543144472e-308, 0x3c01, 0x8001d7afL, 0x3231a984L), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
#if defined TEST_LDOUBLE && LDBL_MAX_EXP > 1024
	{ __LINE__, HEXCONSTE(-7.08396423339843750000e+02, 0xc008, 0xb1195f00L, 0x00000000L), HEXCONSTE(2.22506316131312715353e-308, 0x3c00, 0xffffaf57L, 0xa6fc91a7L), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
#endif
	{ __LINE__, HEXCONSTE(-7.08396418532264078749e+02, 0xc008, 0xb1195eebL, 0xd5e69000L), HEXCONSTE(2.22507385850726251792e-308, 0x3c01, 0x80000000L, 0x0003dde8L), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
#if defined TEST_LDOUBLE && LDBL_MAX_EXP > 1024
	{ __LINE__, HEXCONSTE(7.09782714843750000000e+02, 0x4008, 0xb1721800L, 0x00000000L), HEXCONSTE(1.79769664102530940090e+308, 0x43ff, 0x8000105cL, 0x621855efL), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
#endif
	{ __LINE__, HEXCONSTE(7.09782653808593750000e+02, 0x4008, 0xb1721700L, 0x00000000L), HEXCONSTE(1.79758692167833712539e+308, 0x43fe, 0xfffc20c0L, 0x4143f640L), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
#if defined TEST_LDOUBLE && LDBL_MAX_EXP > 1024
	{ __LINE__, HEXCONSTE(7.09782712893384086783e+02, 0x4008, 0xb17217f7L, 0xd1cf8000L), HEXCONSTE(1.79769313486247759184e+308, 0x43ff, 0x80000000L, 0x000ca86cL), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
#endif
	{ __LINE__, HEXCONSTE(7.09782712893383973096e+02, 0x4008, 0xb17217f7L, 0xd1cf7800L), HEXCONSTE(1.79769313486227321780e+308, 0x43fe, 0xffffffffL, 0xfff950d8L), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
#if defined TEST_LDOUBLE && LDBL_MAX_EXP > 1024
	{ __LINE__, HEXCONSTE(7.09782712893383996799e+02, 0x4008, 0xb17217f7L, 0xd1cf79abL), HEXCONSTE(1.79769313486231582899e+308, 0x43fe, 0xffffffffL, 0xfffffcd8L), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(7.09782712893383996744e+02, 0x4008, 0xb17217f7L, 0xd1cf79aaL), HEXCONSTE(1.79769313486231572920e+308, 0x43fe, 0xffffffffL, 0xfffff8d8L), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(7.09782714843750000000e+02, 0x4008, 0xb1721800L, 0x00000000L), HEXCONSTE(1.79769664102530940090e+308, 0x43ff, 0x8000105cL, 0x621855efL), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
#endif
	{ __LINE__, HEXCONSTE(7.09782653808593750000e+02, 0x4008, 0xb1721700L, 0x00000000L), HEXCONSTE(1.79758692167833712539e+308, 0x43fe, 0xfffc20c0L, 0x4143f640L), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
#if defined TEST_LDOUBLE && LDBL_MAX_EXP > 1024
	{ __LINE__, HEXCONSTE(7.09782712893384086783e+02, 0x4008, 0xb17217f7L, 0xd1cf8000L), HEXCONSTE(1.79769313486247759184e+308, 0x43ff, 0x80000000L, 0x000ca86cL), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
#endif
	{ __LINE__, HEXCONSTE(7.09782712893383973096e+02, 0x4008, 0xb17217f7L, 0xd1cf7800L), HEXCONSTE(1.79769313486227321780e+308, 0x43fe, 0xffffffffL, 0xfff950d8L), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
#if defined TEST_LDOUBLE && LDBL_MAX_EXP > 1024
	{ __LINE__, HEXCONSTE(7.09782712893383996799e+02, 0x4008, 0xb17217f7L, 0xd1cf79abL), HEXCONSTE(1.79769313486231582899e+308, 0x43fe, 0xffffffffL, 0xfffffcd8L), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(7.09782712893383996744e+02, 0x4008, 0xb17217f7L, 0xd1cf79aaL), HEXCONSTE(1.79769313486231572920e+308, 0x43fe, 0xffffffffL, 0xfffff8d8L), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
#endif
	{ __LINE__, HEXCONSTE(-6.71659606933593750000e+02, 0xc008, 0xa7ea3700L, 0x00000000L), HEXCONSTE(2.00419046409018950849e-292, 0x3c36, 0x80005c84L, 0xb6995d8eL), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(-6.71659667968750000000e+02, 0xc008, 0xa7ea3800L, 0x00000000L), HEXCONSTE(2.00406814174507870099e-292, 0x3c35, 0xfffcb90eL, 0x890823f5L), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(-6.71659617962586935391e+02, 0xc008, 0xa7ea372eL, 0x424a9000L), HEXCONSTE(2.00416836000911193551e-292, 0x3c36, 0x80000000L, 0x0009c5a0L), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(-6.71659617962587049078e+02, 0xc008, 0xa7ea372eL, 0x424a9800L), HEXCONSTE(2.00416836000888408783e-292, 0x3c35, 0xffffffffL, 0xfff38b3fL), FLAG_INEXACT3 },
#if defined TEST_LDOUBLE && LDBL_MAX_EXP > 1024
	{ __LINE__, HEXCONSTE(-6.71659617962587004780e+02, 0xc008, 0xa7ea372eL, 0x424a94e2L), HEXCONSTE(2.00416836000897286839e-292, 0x3c36, 0x80000000L, 0x000001a0L), FLAG_INEXACT3 },
#endif
	{ __LINE__, HEXCONSTE(-6.71659617962587004836e+02, 0xc008, 0xa7ea372eL, 0x424a94e3L), HEXCONSTE(2.00416836000897275703e-292, 0x3c35, 0xffffffffL, 0xffffff3fL), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(-6.71659606933593750000e+02, 0xc008, 0xa7ea3700L, 0x00000000L), HEXCONSTE(2.00419046409018950849e-292, 0x3c36, 0x80005c84L, 0xb6995d8eL), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(-6.71659667968750000000e+02, 0xc008, 0xa7ea3800L, 0x00000000L), HEXCONSTE(2.00406814174507870099e-292, 0x3c35, 0xfffcb90eL, 0x890823f5L), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(-6.71659617962586935391e+02, 0xc008, 0xa7ea372eL, 0x424a9000L), HEXCONSTE(2.00416836000911193551e-292, 0x3c36, 0x80000000L, 0x0009c5a0L), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(-6.71659617962587049078e+02, 0xc008, 0xa7ea372eL, 0x424a9800L), HEXCONSTE(2.00416836000888408783e-292, 0x3c35, 0xffffffffL, 0xfff38b3fL), FLAG_INEXACT3 },
#if defined TEST_LDOUBLE && LDBL_MAX_EXP > 1024
	{ __LINE__, HEXCONSTE(-6.71659617962587004780e+02, 0xc008, 0xa7ea372eL, 0x424a94e2L), HEXCONSTE(2.00416836000897286839e-292, 0x3c36, 0x80000000L, 0x000001a0L), FLAG_INEXACT3 },
#endif
	{ __LINE__, HEXCONSTE(-6.71659617962587004836e+02, 0xc008, 0xa7ea372eL, 0x424a94e3L), HEXCONSTE(2.00416836000897275703e-292, 0x3c35, 0xffffffffL, 0xffffff3fL), FLAG_INEXACT3|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(1.13565234375000000000e+04, 0x400c, 0xb1721800L, 0x00000000L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(1.13565234062941453885e+04, 0x400c, 0xb17217f7L, 0xd1cf8000L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(1.13565234375000000000e+04, 0x400c, 0xb1721800L, 0x00000000L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(1.13565234062941453885e+04, 0x400c, 0xb17217f7L, 0xd1cf8000L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(1.13565234062941439497e+04, 0x400c, 0xb17217f7L, 0xd1cf79acL), INF_P, 0 },
	{ __LINE__, HEXCONSTE(1.13565234375000000000e+04, 0x400c, 0xb1721800L, 0x00000000L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(1.13565234062941453885e+04, 0x400c, 0xb17217f7L, 0xd1cf8000L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(1.13565234062941439497e+04, 0x400c, 0xb17217f7L, 0xd1cf79acL), INF_P, 0 },
	{ __LINE__, HEXCONSTE(1.13565234375000000000e+04, 0x400c, 0xb1721800L, 0x00000000L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(1.13565234062941453885e+04, 0x400c, 0xb17217f7L, 0xd1cf8000L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(1.13565234062941439497e+04, 0x400c, 0xb17217f7L, 0xd1cf79acL), INF_P, 0 },
#if defined TEST_LDOUBLE && LDBL_MAX_EXP > 1024
	{ __LINE__, HEXCONSTE(1.13565224609375000000e+04, 0x400c, 0xb1721700L, 0x00000000L), HEXCONSTE(1.18860730624712589538e+4932, 0x7ffe, 0xffc2130aL, 0xbb1e4163L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(1.13565234062941435695e+04, 0x400c, 0xb17217f7L, 0xd1cf7800L), HEXCONSTE(1.18973149535677972347e+4932, 0x7ffe, 0xffffffffL, 0xff950d87L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(1.13565234062941439488e+04, 0x400c, 0xb17217f7L, 0xd1cf79abL), HEXCONSTE(1.18973149535723093174e+4932, 0x7ffe, 0xffffffffL, 0xffffcd87L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(1.13565224609375000000e+04, 0x400c, 0xb1721700L, 0x00000000L), HEXCONSTE(1.18860730624712589538e+4932, 0x7ffe, 0xffc2130aL, 0xbb1e4163L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(1.13565234062941435695e+04, 0x400c, 0xb17217f7L, 0xd1cf7800L), HEXCONSTE(1.18973149535677972347e+4932, 0x7ffe, 0xffffffffL, 0xff950d87L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(-1.13551367187500000000e+04, 0xc00c, 0xb16c8c00L, 0x00000000L), HEXCONSTE(3.36342532490578483558e-4932, 0x0001, 0x800ce2e8L, 0x21237185L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(-1.13551376953125000000e+04, 0xc00c, 0xb16c8d00L, 0x00000000L), HEXCONSTE(3.36014233314616039875e-4932, 0x0000, 0xffd9c75eL, 0xf1b3a563L), FLAG_INEXACT_SUBNORM|FLAG_FAIL_X87 },
	{ __LINE__, HEXCONSTE(-1.13551371119330233341e+04, 0xc00c, 0xb16c8c67L, 0x1210e800L), HEXCONSTE(3.36210314311453016213e-4932, 0x0001, 0x80000000L, 0x0065fe54L), FLAG_INEXACT_SUBNORM },
	{ __LINE__, HEXCONSTE(-1.13551371119330251531e+04, 0xc00c, 0xb16c8c67L, 0x1210f000L), HEXCONSTE(3.36210314310841453177e-4932, 0x0000, 0x7fffffffL, 0xff65ff90L), FLAG_INEXACT_SUBNORM },
	{ __LINE__, HEXCONSTE(-1.13551371119330240589e+04, 0xc00c, 0xb16c8c67L, 0x1210eb30L), HEXCONSTE(3.36210314311209346544e-4932, 0x0000, 0x7fffffffL, 0xffffff90L), FLAG_INEXACT_SUBNORM|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(-1.13551367187500000000e+04, 0xc00c, 0xb16c8c00L, 0x00000000L), HEXCONSTE(3.36342532490578483558e-4932, 0x0001, 0x800ce2e8L, 0x21237185L), FLAG_INEXACT_SUBNORM },
	{ __LINE__, HEXCONSTE(-1.13551376953125000000e+04, 0xc00c, 0xb16c8d00L, 0x00000000L), HEXCONSTE(3.36014233314616039875e-4932, 0x0000, 0xffd9c75eL, 0xf1b3a563L), FLAG_INEXACT_SUBNORM|FLAG_FAIL_X87 },
	{ __LINE__, HEXCONSTE(-1.13551371119330233341e+04, 0xc00c, 0xb16c8c67L, 0x1210e800L), HEXCONSTE(3.36210314311453016213e-4932, 0x0001, 0x80000000L, 0x0065ff91L), FLAG_INEXACT_SUBNORM },
	{ __LINE__, HEXCONSTE(-1.13551371119330251531e+04, 0xc00c, 0xb16c8c67L, 0x1210f000L), HEXCONSTE(3.36210314310841453177e-4932, 0x0000, 0x7fffffffL, 0xff65ff90L), FLAG_INEXACT_SUBNORM },
	{ __LINE__, HEXCONSTE(-1.13551371119330240580e+04, 0xc00c, 0xb16c8c67L, 0x1210eb2fL), HEXCONSTE(3.36210314311209645195e-4932, 0x0001, 0x80000000L, 0x00001f91L), FLAG_INEXACT_SUBNORM },
	{ __LINE__, HEXCONSTE(-1.13558300781250000000e+04, 0xc00c, 0xb16f5200L, 0x00000000L), HEXCONSTE(1.68135585023427364400e-4932, 0x0000, 0x8005ee61L, 0x32fc6ff7L), FLAG_INEXACT_SUBNORM|FLAG_FAIL_X87 },
	{ __LINE__, HEXCONSTE(-1.13558310546875000000e+04, 0xc00c, 0xb16f5300L, 0x00000000L), HEXCONSTE(1.67971470263380771669e-4932, 0x0000, 0x7fe5f0e5L, 0x74cec62dL), FLAG_INEXACT_SUBNORM|FLAG_FAIL_X87 },
	{ __LINE__, HEXCONSTE(-1.13558302591135834518e+04, 0xc00c, 0xb16f522fL, 0x71f03000L), HEXCONSTE(1.68105157155697527731e-4932, 0x0000, 0x80000000L, 0x004dbc67L), FLAG_INEXACT_SUBNORM|FLAG_FAIL_X87 },
	{ __LINE__, HEXCONSTE(-1.13558302591135852708e+04, 0xc00c, 0xb16f522fL, 0x71f03800L), HEXCONSTE(1.68105157155391746232e-4932, 0x0000, 0x7fffffffL, 0xff4dbc67L), FLAG_INEXACT_SUBNORM|FLAG_FAIL_X87 },
	{ __LINE__, HEXCONSTE(-1.13558302591135840043e+04, 0xc00c, 0xb16f522fL, 0x71f0326eL), HEXCONSTE(1.68105157155604658545e-4932, 0x0000, 0x7fffffffL, 0xfffffc67L), FLAG_INEXACT_SUBNORM|FLAG_FAIL_X87 },
	{ __LINE__, HEXCONSTE(-1.13558300781250000000e+04, 0xc00c, 0xb16f5200L, 0x00000000L), HEXCONSTE(1.68135585023427364400e-4932, 0x0000, 0x8005ee61L, 0x32fc6ff7L), FLAG_INEXACT_SUBNORM|FLAG_FAIL_X87 },
	{ __LINE__, HEXCONSTE(-1.13558310546875000000e+04, 0xc00c, 0xb16f5300L, 0x00000000L), HEXCONSTE(1.67971470263380771669e-4932, 0x0000, 0x7fe5f0e5L, 0x74cec62dL), FLAG_INEXACT_SUBNORM|FLAG_FAIL_X87 },
	{ __LINE__, HEXCONSTE(-1.13558302591135834518e+04, 0xc00c, 0xb16f522fL, 0x71f03000L), HEXCONSTE(1.68105157155697527731e-4932, 0x0000, 0x80000000L, 0x004dbc67L), FLAG_INEXACT_SUBNORM|FLAG_FAIL_X87 },
	{ __LINE__, HEXCONSTE(-1.13558302591135852708e+04, 0xc00c, 0xb16f522fL, 0x71f03800L), HEXCONSTE(1.68105157155391746232e-4932, 0x0000, 0x7fffffffL, 0xff4dbc67L), FLAG_INEXACT_SUBNORM|FLAG_FAIL_X87 },
	{ __LINE__, HEXCONSTE(-1.13558302591135840034e+04, 0xc00c, 0xb16f522fL, 0x71f0326dL), HEXCONSTE(1.68105157155604807853e-4932, 0x0000, 0x80000000L, 0x00001c67L), FLAG_INEXACT_SUBNORM|FLAG_FAIL_X87 },
	{ __LINE__, HEXCONSTE(1.13565224609375000000e+04, 0x400c, 0xb1721700L, 0x00000000L), HEXCONSTE(1.18860730624712589538e+4932, 0x7ffe, 0xffc2130aL, 0xbb1e4163L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(1.13565234062941435695e+04, 0x400c, 0xb17217f7L, 0xd1cf7800L), HEXCONSTE(1.18973149535677972347e+4932, 0x7ffe, 0xffffffffL, 0xff950d87L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(1.13565234062941439488e+04, 0x400c, 0xb17217f7L, 0xd1cf79abL), HEXCONSTE(1.18973149535723093174e+4932, 0x7ffe, 0xffffffffL, 0xffffcd87L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(1.13565224609375000000e+04, 0x400c, 0xb1721700L, 0x00000000L), HEXCONSTE(1.18860730624712589538e+4932, 0x7ffe, 0xffc2130aL, 0xbb1e4163L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(1.13565234062941435695e+04, 0x400c, 0xb17217f7L, 0xd1cf7800L), HEXCONSTE(1.18973149535677972347e+4932, 0x7ffe, 0xffffffffL, 0xff950d87L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(1.13565234062941439488e+04, 0x400c, 0xb17217f7L, 0xd1cf79abL), HEXCONSTE(1.18973149535723093174e+4932, 0x7ffe, 0xffffffffL, 0xffffcd87L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(-1.13551367187500000000e+04, 0xc00c, 0xb16c8c00L, 0x00000000L), HEXCONSTE(3.36342532490578483558e-4932, 0x0001, 0x800ce2e8L, 0x21237185L), FLAG_INEXACT_SUBNORM },
	{ __LINE__, HEXCONSTE(-1.13551376953125000000e+04, 0xc00c, 0xb16c8d00L, 0x00000000L), HEXCONSTE(3.36014233314616039875e-4932, 0x0000, 0xffd9c75eL, 0xf1b3a563L), FLAG_INEXACT_SUBNORM|FLAG_FAIL_X87 },
	{ __LINE__, HEXCONSTE(-1.13551371119330233341e+04, 0xc00c, 0xb16c8c67L, 0x1210e800L), HEXCONSTE(3.36210314311453016213e-4932, 0x0001, 0x80000000L, 0x0065ff91L), FLAG_INEXACT_SUBNORM },
	{ __LINE__, HEXCONSTE(-1.13551371119330251531e+04, 0xc00c, 0xb16c8c67L, 0x1210f000L), HEXCONSTE(3.36210314310841453177e-4932, 0x0000, 0xffffffffL, 0xfecbff21L), FLAG_INEXACT_SUBNORM },
	{ __LINE__, HEXCONSTE(-1.13551371119330240580e+04, 0xc00c, 0xb16c8c67L, 0x1210eb2fL), HEXCONSTE(3.36210314311209645195e-4932, 0x0001, 0x80000000L, 0x00001f91L), FLAG_INEXACT_SUBNORM },
	{ __LINE__, HEXCONSTE(-1.13551371119330240589e+04, 0xc00c, 0xb16c8c67L, 0x1210eb30L), HEXCONSTE(3.36210314311209346544e-4932, 0x0000, 0xffffffffL, 0xffffff21L), FLAG_INEXACT_SUBNORM|FLAG_FAIL_X87 },
	{ __LINE__, HEXCONSTE(-1.13551367187500000000e+04, 0xc00c, 0xb16c8c00L, 0x00000000L), HEXCONSTE(3.36342532490578483558e-4932, 0x0001, 0x800ce2e8L, 0x21237185L), FLAG_INEXACT_SUBNORM },
	{ __LINE__, HEXCONSTE(-1.13551376953125000000e+04, 0xc00c, 0xb16c8d00L, 0x00000000L), HEXCONSTE(3.36014233314616039875e-4932, 0x0000, 0xffd9c75eL, 0xf1b3a563L), FLAG_INEXACT_SUBNORM|FLAG_FAIL_X87 },
	{ __LINE__, HEXCONSTE(-1.13551371119330233341e+04, 0xc00c, 0xb16c8c67L, 0x1210e800L), HEXCONSTE(3.36210314311453016213e-4932, 0x0001, 0x80000000L, 0x0065ff91L), FLAG_INEXACT_SUBNORM },
	{ __LINE__, HEXCONSTE(-1.13551371119330251531e+04, 0xc00c, 0xb16c8c67L, 0x1210f000L), HEXCONSTE(3.36210314310841453177e-4932, 0x0000, 0xffffffffL, 0xfecbff21L), FLAG_INEXACT_SUBNORM },
	{ __LINE__, HEXCONSTE(-1.13551371119330240580e+04, 0xc00c, 0xb16c8c67L, 0x1210eb2fL), HEXCONSTE(3.36210314311209645195e-4932, 0x0001, 0x80000000L, 0x00001f91L), FLAG_INEXACT_SUBNORM },
	{ __LINE__, HEXCONSTE(-1.13551371119330240589e+04, 0xc00c, 0xb16c8c67L, 0x1210eb30L), HEXCONSTE(3.36210314311209346544e-4932, 0x0000, 0xffffffffL, 0xffffff21L), FLAG_INEXACT_SUBNORM|FLAG_FAIL_ARANYM },
#endif
	{ __LINE__, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#ifdef TEST_LDOUBLE
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#ifdef TEST_LDOUBLE
	{ __LINE__, HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, SUBNORM_P, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, SUBNORM_M, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.46113300323486328125e+00, 0xbfff, 0xbb066800L, 0x00000000L), HEXCONSTE(2.31973299283384839565e-01, 0x3ffc, 0xed8a6897L, 0xde9320a8L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-1.46113312244415283203e+00, 0xbfff, 0xbb066900L, 0x00000000L), HEXCONSTE(2.31973271630014285502e-01, 0x3ffc, 0xed8a66bcL, 0xc9c3cbffL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-1.46113307947665860276e+00, 0xbfff, 0xbb0668a3L, 0xba5ec800L), HEXCONSTE(2.31973281597324709747e-01, 0x3ffc, 0xed8a6768L, 0x0675acccL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.29658746719360351562e+00, 0x3fff, 0xa5f69400L, 0x00000000L), HEXCONSTE(3.65679641325948655609e+00, 0x4000, 0xea08f3d2L, 0xc51817cfL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-4.97809417724609375000e+02, 0xc007, 0xf8e79b00L, 0x00000000L), HEXCONSTE(6.36966867634404076472e-217, 0x3d30, 0xe0d9b4d7L, 0x8a7eccbaL), FLAG_INEXACT2|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(3.14265656471252441406e+00, 0x4000, 0xc9214900L, 0x00000000L), HEXCONSTE(2.31653253742593108182e+01, 0x4003, 0xb952961cL, 0x1d243fffL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.94023716449737548828e+00, 0x3fff, 0xf859b100L, 0x00000000L), HEXCONSTE(6.96040153503348557997e+00, 0x4001, 0xdebb9bffL, 0xffe79409L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.35369329452514648438e+01, 0x4002, 0xd8974700L, 0x00000000L), HEXCONSTE(7.56859523549448935228e+05, 0x4012, 0xb8c7b860L, 0x75631040L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.35369319915771484375e+01, 0x4002, 0xd8974600L, 0x00000000L), HEXCONSTE(7.56858801752304378397e+05, 0x4012, 0xb8c7acd3L, 0xfa396cc4L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.35369326159368661422e+01, 0x4002, 0xd89746a7L, 0x99ac5000L), HEXCONSTE(7.56859274304599704067e+05, 0x4012, 0xb8c7b463L, 0x8d384df1L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.35369326159368643658e+01, 0x4002, 0xd89746a7L, 0x99ac4800L), HEXCONSTE(7.56859274304598359606e+05, 0x4012, 0xb8c7b463L, 0x8d37f18dL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.35369326159368659037e+01, 0x4002, 0xd89746a7L, 0x99ac4eedL), HEXCONSTE(7.56859274304599523532e+05, 0x4012, 0xb8c7b463L, 0x8d384189L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-3.96658182144165039062e-01, 0xbffd, 0xcb16c800L, 0x00000000L), HEXCONSTE(6.72563880689747289182e-01, 0x3ffe, 0xac2d2580L, 0x088709f3L), FLAG_INEXACT2 },

	/* have to be checked: */
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(-40.0, 0xc004, 0xa0000000L, 0x00000000L), HEXCONSTE(4.248354255291e-18, 0x3fc5, 0x9cbc924cL, 0xd8b93cd0L), 0 },
	{ __LINE__, HEXCONSTE(-30.0, 0xc003, 0xf0000000L, 0x00000000L), HEXCONSTE(9.357622968840e-14, 0x3fd3, 0xd2b70615L, 0x63f753f8L), 0 },
	{ __LINE__, HEXCONSTE(-20.0, 0xc003, 0xa0000000L, 0x00000000L), HEXCONSTE(2.061153622438e-09, 0x3fe2, 0x8da432afL, 0x9b69113aL), 0 },
	{ __LINE__, HEXCONSTE(-10.0, 0xc002, 0xa0000000L, 0x00000000L), HEXCONSTE(4.539992976248e-05, 0x3ff0, 0xbe6bcdabL, 0x23ce7534L), 0 },
	{ __LINE__, HEXCONSTE(-2.0, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(1.353352832366e-01, 0x3ffc, 0x8a95551dL, 0xfc0012ceL), 0 },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(0.36787944117144232159552377016146087, 0x3ffd, 0xbc5ab1b1L, 0x6779be35L), 0 },
	{ __LINE__, HEXCONSTE(-0.25, 0xbffd, 0x80000000L, 0x00000000L), HEXCONSTE(0.77880078307140486824517026697832065, 0x3ffe, 0xc75f7cf5L, 0x64105743L), 0 },
	{ __LINE__, HEXCONSTE(0.25, 0x3ffd, 0x80000000L, 0x00000000L), HEXCONSTE(1.28402541668774148407342056806243646, 0x3fff, 0xa45af1e1L, 0xf40c333bL), 0 },
	{ __LINE__, HEXCONSTE(10.0, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(2.202646579480e04, 0x400d, 0xac14ee7cL, 0xa7f14b31L), 0 },
	{ __LINE__, HEXCONSTE(20.0, 0x4003, 0xa0000000L, 0x00000000L), HEXCONSTE(4.851651954097e08, 0x401b, 0xe758445bL, 0x4710cb29L), 0 },
	{ __LINE__, HEXCONSTE(30.0, 0x4003, 0xf0000000L, 0x00000000L), HEXCONSTE(1.068647458152e13, 0x402a, 0x9b823857L, 0x61000000L), 0 },
	{ __LINE__, HEXCONSTE(40.0, 0x4004, 0xa0000000L, 0x00000000L), HEXCONSTE(2.353852668370e17, 0x4038, 0xd11069cbL, 0xcb83d000L), 0 },
#endif

#if defined(TEST_DOUBLE)
	{ __LINE__, HEXCONSTE(-40.0, 0xc004, 0xa0000000L, 0x00000000L), HEXCONSTE(4.2483542552915888709545e-18, 0x3fc5, 0x9cbc924cL, 0xd8d12000L), 0 },
	{ __LINE__, HEXCONSTE(-30.0, 0xc003, 0xf0000000L, 0x00000000L), HEXCONSTE(9.3576229688401748166173e-14, 0x3fd3, 0xd2b70615L, 0x63fba800L), 0 },
	{ __LINE__, HEXCONSTE(-20.0, 0xc003, 0xa0000000L, 0x00000000L), HEXCONSTE(2.0611536224385578699415e-09, 0x3fe2, 0x8da432afL, 0x9b933800L), 0 },
	{ __LINE__, HEXCONSTE(-10.0, 0xc002, 0xa0000000L, 0x00000000L), HEXCONSTE(4.5399929762484854173146e-05, 0x3ff0, 0xbe6bcdabL, 0x23e4d800L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-2.0, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(1.3533528323661270231781e-01, 0x3ffc, 0x8a95551dL, 0xfc0e6000L), 0 },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(0.36787944117144233402428, 0x3ffd, 0xbc5ab1b1L, 0x6779c000L), 0 },
	{ __LINE__, HEXCONSTE(-0.25, 0xbffd, 0x80000000L, 0x00000000L), HEXCONSTE(0.77880078307140487847704, 0x3ffe, 0xc75f7cf5L, 0x64105800L), 0 },
	{ __LINE__, HEXCONSTE(0.25, 0x3ffd, 0x80000000L, 0x00000000L), HEXCONSTE(1.28402541668774148407342056806243646, 0x3fff, 0xa45af1e1L, 0xf40c333bL), 0 },
	{ __LINE__, HEXCONSTE(10.0, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(2.2026465794806717894971e+04, 0x400d, 0xac14ee7cL, 0xa82b0000L), 0 },
	{ __LINE__, HEXCONSTE(20.0, 0x4003, 0xa0000000L, 0x00000000L), HEXCONSTE(4.8516519540979027748108e+08, 0x401b, 0xe758445bL, 0x47402000L), 0 },
	{ __LINE__, HEXCONSTE(30.0, 0x4003, 0xf0000000L, 0x00000000L), HEXCONSTE(1.0686474581524462890625e+13, 0x402a, 0x9b823857L, 0x61476800L), 0 },
	{ __LINE__, HEXCONSTE(40.0, 0x4004, 0xa0000000L, 0x00000000L), HEXCONSTE(2.3538526683702000000000e+17, 0x4038, 0xd11069cbL, 0xcb975800L), FLAG_INEXACT },
#endif

#ifndef TEST_FLOAT
	{ __LINE__, HEXCONSTE(709.75L, 0x4008, 0xb1700000L, 0x00000000L), HEXCONSTE(1.739836873264160557698252711673830393864768e+308L, 0x43fe, 0xf7c2d08fL, 0x39f969a2L), 0 },
#endif
#if defined TEST_LDOUBLE && LDBL_MAX_EXP > 1024
	/* The result can only be represented in sane long double.	*/
	{ __LINE__, HEXCONSTE(1000.0L, 0x4008, 0xfa000000L, 0x00000000L), HEXCONSTE(0.197007111401704699388887935224332313e435L, 0x45a1, 0xcf391bcdL, 0x76b9d6c0L), 0 },
#endif

#if !(defined TEST_LDOUBLE && LDBL_MAX_EXP > 1024)
	{ __LINE__, HEXCONSTE(710, 0x4008, 0xb1800000L, 0x00000000L), INF_P, OVERFLOW_EXCEPTION|ERRNO_ERANGE },
	{ __LINE__, HEXCONSTE(-1234, 0xc009, 0x9a400000L, 0x00000000L), ZERO_P, UNDERFLOW_EXCEPTION },
#endif
	{ __LINE__, HEXCONSTE(1e5, 0x400f, 0xc3500000L, 0x00000000L), INF_P, OVERFLOW_EXCEPTION|ERRNO_ERANGE },
	{ __LINE__, MAX_P, INF_P, OVERFLOW_EXCEPTION|ERRNO_ERANGE },
	{ __LINE__, MAX_M, ZERO_P, UNDERFLOW_EXCEPTION },
};

int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_f_f(fetox_data, ARRAY_SIZE(fetox_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

```

`tests/exp10.c`:

```c
#include "testconfig.h"
#ifdef HAVE_EXP10
#define TEST_FUNC_F_F __MATH_PRECNAME(exp10)
#include "testdriver.h"



static test_f_f_data const ftentox_data[] = {
	{ __LINE__, ZERO_P, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, ZERO_M, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, INF_P, INF_P, 0 },
	{ __LINE__, INF_M, ZERO_P, 0 },
	{ __LINE__, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_P, 0 },
	{ __LINE__, SNAN_P, QNAN_P, 0 },
	{ __LINE__, SNAN_M, QNAN_P, 0 },

	{ __LINE__, HEXCONSTE(3.00000000000000000000e+00, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+03, 0x4008, 0xfa000000L, 0x00000000L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000001e-01, 0x3ffb, 0xccccccccL, 0xcccccccdL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.60000000000000000000e+01, 0x4004, 0x90000000L, 0x00000000L), HEXCONSTE(9.99999999999999999979e+35, 0x4076, 0xc097ce7bL, 0xc90715b3L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-3.60000000000000000000e+01, 0xc004, 0x90000000L, 0x00000000L), HEXCONSTE(1.00000000000000000001e-36, 0x3f87, 0xaa242499L, 0x697392d3L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(3.05000000000000000000e+02, 0x4007, 0x98800000L, 0x00000000L), HEXCONSTE(9.99999999999999999971e+304, 0x43f4, 0x91d28b74L, 0x16cdd27eL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(-3.05000000000000000000e+02, 0xc007, 0x98800000L, 0x00000000L), HEXCONSTE(9.99999999999999999988e-306, 0x3c09, 0xe0b62e29L, 0x29aba83cL), FLAG_INEXACT4 },
#if defined TEST_LDOUBLE && LDBL_MAX_EXP > 1024
	{ __LINE__, HEXCONSTE(4932, 0x400b, 0x9a200000L, 0x00000000L), HEXCONSTE(1.00000000000000000001e+4932, 0x7ffe, 0xd72cb2a9L, 0x5c7ef6cdL), FLAG_INEXACT5 },
	{ __LINE__, HEXCONSTE(-4.93200000000000000000e+03, 0xc00b, 0x9a200000L, 0x00000000L), HEXCONSTE(6.2514147381127979648749e-4934, 0x0000, 0x4c248f91L, 0xe526afe1L), FLAG_INEXACT5|FLAG_FAIL_X87 }, /* 0000:261247c8:f29357f0 */
	{ __LINE__, HEXCONSTE(-4.93147314453125000000e+03, 0xc00b, 0x9a1bc900L, 0x00000000L), HEXCONSTE(3.36399598471665197864e-4932, 0x0001, 0x801272baL, 0xf1d7936dL), FLAG_INEXACT5 },
	{ __LINE__, HEXCONSTE(-4.93147363281250000000e+03, 0xc00b, 0x9a1bca00L, 0x00000000L), HEXCONSTE(3.36021593869467811619e-4932, 0x0000, 0xffdb36abL, 0x6ab817c7L), FLAG_INEXACT5|FLAG_FAIL_X87 }, /* 0000:7fed9b55:b55c0be4 */
	{ __LINE__, HEXCONSTE(-4.93147338896733981528e+03, 0xc00b, 0x9a1bc980L, 0x27a81800L), HEXCONSTE(3.36210314311305895704e-4932, 0x0001, 0x80000000L, 0x002867adL), FLAG_INEXACT5 }, /* 0001:80000000:002869ea */
	{ __LINE__, HEXCONSTE(-4.93147338896734072478e+03, 0xc00b, 0x9a1bc980L, 0x27a82000L), HEXCONSTE(3.36210314310601807772e-4932, 0x0000, 0xffffffffL, 0xfe035d9cL), FLAG_INEXACT5|FLAG_FAIL_X87 }, /* 0000:7fffffff:ff01aece */
	{ __LINE__, HEXCONSTE(-4.93147338896733994007e+03, 0xc00b, 0x9a1bc980L, 0x27a81919L), HEXCONSTE(3.36210314311209289897e-4932, 0x0000, 0xffffffffL, 0xfffff2fbL), FLAG_INEXACT5|FLAG_FAIL_X87 }, /* 0000:7fffffff:fffff97e */
#endif
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+05, 0x400f, 0xc3500000L, 0x00000000L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(-1.00000000000000000000e+05, 0xc00f, 0xc3500000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+06, 0x4012, 0xf4240000L, 0x00000000L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(-1.00000000000000000000e+06, 0xc012, 0xf4240000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), INF_P, 0 },
	{ __LINE__, HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(7.50000000000000000000e-01, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(5.62341325190349080416e+00, 0x4001, 0xb3f30059L, 0x1a312cafL), FLAG_INEXACT },
#if 0
	{ __LINE__, HEXCONSTE(3.08555755615234375000e+02, 0x4007, 0x9a472300L, 0x00000000L), HEXCONSTE(3.59546955137109251511e+308, 0x4400, 0x8000c24fL, 0x300afdf0L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(3.08555725097656250000e+02, 0x4007, 0x9a472200L, 0x00000000L), HEXCONSTE(3.59521690904557163237e+308, 0x43ff, 0xfffce9b5L, 0x8e132b78L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(3.08555745555580756445e+02, 0x4007, 0x9a4722abL, 0x9d0ef000L), HEXCONSTE(3.59538626972489136085e+308, 0x4400, 0x80000000L, 0x000a28ddL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(3.08555745555580699602e+02, 0x4007, 0x9a4722abL, 0x9d0ee800L), HEXCONSTE(3.59538626972442077211e+308, 0x43ff, 0xffffffffL, 0xffef7a56L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(3.08555745555580725081e+02, 0x4007, 0x9a4722abL, 0x9d0eeb96L), HEXCONSTE(3.59538626972463170982e+308, 0x43ff, 0xffffffffL, 0xfffffde2L), FLAG_INEXACT3 },
#endif
	{ __LINE__, HEXCONSTE(-3.07664093017578125000e+02, 0xc007, 0x99d50100L, 0x00000000L), HEXCONSTE(2.16723987374440566298e-308, 0x3c00, 0xf958979eL, 0x90866c7dL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(-3.07664123535156250000e+02, 0xc007, 0x99d50200L, 0x00000000L), HEXCONSTE(2.16708758862174190021e-308, 0x3c00, 0xf9541b60L, 0xf113b85dL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(-3.07664108276367187500e+02, 0xc007, 0x99d50180L, 0x00000000L), HEXCONSTE(2.16716372984545227090e-308, 0x3c00, 0xf956597dL, 0x2bd2112cL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(-3.07676116943359375000e+02, 0xc007, 0x99d68b00L, 0x00000000L), HEXCONSTE(2.10806043177688685520e-308, 0x3c00, 0xf2898e65L, 0x2f51079fL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(-3.07676147460937500000e+02, 0xc007, 0x99d68c00L, 0x00000000L), HEXCONSTE(2.10791230500729160919e-308, 0x3c00, 0xf2853182L, 0x41edc5ecL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(-3.07676132202148437500e+02, 0xc007, 0x99d68b80L, 0x00000000L), HEXCONSTE(2.10798636709099330202e-308, 0x3c00, 0xf2875ff1L, 0x35b0ef16L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(-3.07686676025390625000e+02, 0xc007, 0x99d7e500L, 0x00000000L), HEXCONSTE(2.05742481959131162146e-308, 0x3c00, 0xecb62a42L, 0x3418d0caL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(9.76562500000000000000e-04, 0x3ff5, 0x80000000L, 0x00000000L), HEXCONSTE(1.00225114829291291551e+00, 0x3fff, 0x8049c400L, 0x25f3f2adL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-9.76562500000000000000e-04, 0xbff5, 0x80000000L, 0x00000000L), HEXCONSTE(9.97753907993273751655e-01, 0x3ffe, 0xff6cccd4L, 0x498cbd18L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(9.53674316406250000000e-07, 0x3feb, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000219591867555422e+00, 0x3fff, 0x8000126bL, 0xb30f07b2L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-9.53674316406250000000e-07, 0xbfeb, 0x80000000L, 0x00000000L), HEXCONSTE(9.99997804086146494028e-01, 0x3ffe, 0xffffdb28L, 0x9f2f39ceL), 0 },
	{ __LINE__, HEXCONSTE(9.31322574615478515625e-10, 0x3fe1, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000214444947943e+00, 0x3fff, 0x80000004L, 0x9aec6f03L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-9.31322574615478515625e-10, 0xbfe1, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999997855550525235e-01, 0x3ffe, 0xfffffff6L, 0xca272250L), 0 },
	{ __LINE__, HEXCONSTE(9.09494701772928237915e-13, 0x3fd7, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000209418897e+00, 0x3fff, 0x80000000L, 0x0126bb1cL), 0 },
	{ __LINE__, HEXCONSTE(-9.09494701772928237915e-13, 0xbfd7, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999999997905811083e-01, 0x3ffe, 0xffffffffL, 0xfdb289c9L), 0 },
	{ __LINE__, HEXCONSTE(8.88178419700125232339e-16, 0x3fcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000204513e+00, 0x3fff, 0x80000000L, 0x000049afL), 0 },
	{ __LINE__, HEXCONSTE(-8.88178419700125232339e-16, 0xbfcd, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999999999997954869e-01, 0x3ffe, 0xffffffffL, 0xffff6ca2L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(8.67361737988403547206e-19, 0x3fc3, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000195e+00, 0x3fff, 0x80000000L, 0x00000012L), 0 },
	{ __LINE__, HEXCONSTE(-8.67361737988403547206e-19, 0xbfc3, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999999999999997994e-01, 0x3ffe, 0xffffffffL, 0xffffffdbL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(7.88860905221011805412e-31, 0x3f9b, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-7.88860905221011805412e-31, 0xbf9b, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.40991986510288411774e-181, 0x3da7, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-2.40991986510288411774e-181, 0xbda7, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(5.01237274920645200930e-3011, 0x18ef, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-5.01237274920645200930e-3011, 0x98ef, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.85318374633789062500e+01, 0x4004, 0x9a209a00L, 0x00000000L), HEXCONSTE(3.40280814274831903438e+38, 0x407e, 0xffffb372L, 0xd9da7f63L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(3.85318412780761718750e+01, 0x4004, 0x9a209b00L, 0x00000000L), HEXCONSTE(3.40283803200657038054e+38, 0x407f, 0x80002368L, 0x3308b43aL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-3.79297828674316406250e+01, 0xc004, 0x97b81900L, 0x00000000L), HEXCONSTE(1.17548511089003535002e-38, 0x3f80, 0xffff7c1fL, 0x8f49429aL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-3.79297790527343750000e+01, 0xc004, 0x97b81800L, 0x00000000L), HEXCONSTE(1.17549543600287630726e-38, 0x3f81, 0x800007beL, 0x7dd38b62L), FLAG_INEXACT3 },
#if 0
	{ __LINE__, HEXCONSTE(3.08254730224609375000e+02, 0x4007, 0x9a209b00L, 0x00000000L), HEXCONSTE(1.79775383805671663300e+308, 0x43ff, 0x80011b42L, 0xaa830e13L), FLAG_INEXACT3 },
#endif
	{ __LINE__, HEXCONSTE(3.08254699707031250000e+02, 0x4007, 0x9a209a00L, 0x00000000L), HEXCONSTE(1.79762751555450338500e+308, 0x43fe, 0xfffd9b99L, 0x4fc5990cL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(3.08254715559916689926e+02, 0x4007, 0x9a209a84L, 0xfbcff000L), HEXCONSTE(1.79769313486209249758e+308, 0x43fe, 0xffffffffL, 0xffdd04f8L), FLAG_INEXACT4 },
#if 0
	{ __LINE__, HEXCONSTE(3.08254730224609375000e+02, 0x4007, 0x9a209b00L, 0x00000000L), HEXCONSTE(1.79775383805671663300e+308, 0x43ff, 0x80011b42L, 0xaa830e13L), FLAG_INEXACT3 },
#endif
	{ __LINE__, HEXCONSTE(3.08254699707031250000e+02, 0x4007, 0x9a209a00L, 0x00000000L), HEXCONSTE(1.79762751555450338500e+308, 0x43fe, 0xfffd9b99L, 0x4fc5990cL), FLAG_INEXACT4 },
#if 0
	{ __LINE__, HEXCONSTE(3.08254715559916746770e+02, 0x4007, 0x9a209a84L, 0xfbcff800L), HEXCONSTE(1.79769313486232779194e+308, 0x43ff, 0x80000000L, 0x0000ee2eL), FLAG_INEXACT3 },
#endif
	{ __LINE__, HEXCONSTE(-3.07652648925781250000e+02, 0xc007, 0x99d38a00L, 0x00000000L), HEXCONSTE(2.22510789267305492351e-308, 0x3c01, 0x8000804fL, 0x5d9baf4eL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(-3.07652679443359375000e+02, 0xc007, 0x99d38b00L, 0x00000000L), HEXCONSTE(2.22495154134689074577e-308, 0x3c00, 0xfffc65b8L, 0x490f5c13L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(-3.07652655568588784263e+02, 0xc007, 0x99d38a37L, 0xb9521000L), HEXCONSTE(2.22507385850718727122e-308, 0x3c00, 0xffffffffL, 0xfffe36ffL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(-3.07652648925781250000e+02, 0xc007, 0x99d38a00L, 0x00000000L), HEXCONSTE(2.22510789267305492351e-308, 0x3c01, 0x8000804fL, 0x5d9baf4eL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(-3.07652679443359375000e+02, 0xc007, 0x99d38b00L, 0x00000000L), HEXCONSTE(2.22495154134689074577e-308, 0x3c00, 0xfffc65b8L, 0x490f5c13L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(-3.07652655568588727419e+02, 0xc007, 0x99d38a37L, 0xb9520800L), HEXCONSTE(2.22507385850747850398e-308, 0x3c01, 0x80000000L, 0x00118731L), FLAG_INEXACT4 },
#if 0
	{ __LINE__, HEXCONSTE(3.08254730224609375000e+02, 0x4007, 0x9a209b00L, 0x00000000L), HEXCONSTE(1.79775383805671663300e+308, 0x43ff, 0x80011b42L, 0xaa830e13L), FLAG_INEXACT3 },
#endif
	{ __LINE__, HEXCONSTE(3.08254699707031250000e+02, 0x4007, 0x9a209a00L, 0x00000000L), HEXCONSTE(1.79762751555450338500e+308, 0x43fe, 0xfffd9b99L, 0x4fc5990cL), FLAG_INEXACT4 },
#if 0
	{ __LINE__, HEXCONSTE(3.08254715559916746770e+02, 0x4007, 0x9a209a84L, 0xfbcff800L), HEXCONSTE(1.79769313486232779194e+308, 0x43ff, 0x80000000L, 0x0000ee2eL), FLAG_INEXACT3 },
#endif
	{ __LINE__, HEXCONSTE(3.08254715559916689926e+02, 0x4007, 0x9a209a84L, 0xfbcff000L), HEXCONSTE(1.79769313486209249758e+308, 0x43fe, 0xffffffffL, 0xffdd04f8L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(3.08254715559916743883e+02, 0x4007, 0x9a209a84L, 0xfbcff798L), HEXCONSTE(1.79769313486231584331e+308, 0x43fe, 0xffffffffL, 0xfffffd6bL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(3.08254715559916743856e+02, 0x4007, 0x9a209a84L, 0xfbcff797L), HEXCONSTE(1.79769313486231572842e+308, 0x43fe, 0xffffffffL, 0xfffff8d0L), FLAG_INEXACT4 },
#if 0
	{ __LINE__, HEXCONSTE(3.08254730224609375000e+02, 0x4007, 0x9a209b00L, 0x00000000L), HEXCONSTE(1.79775383805671663300e+308, 0x43ff, 0x80011b42L, 0xaa830e13L), FLAG_INEXACT4 },
#endif
	{ __LINE__, HEXCONSTE(3.08254699707031250000e+02, 0x4007, 0x9a209a00L, 0x00000000L), HEXCONSTE(1.79762751555450338500e+308, 0x43fe, 0xfffd9b99L, 0x4fc5990cL), FLAG_INEXACT4 },
#if 0
	{ __LINE__, HEXCONSTE(3.08254715559916746770e+02, 0x4007, 0x9a209a84L, 0xfbcff800L), HEXCONSTE(1.79769313486232779194e+308, 0x43ff, 0x80000000L, 0x0000ee2eL), FLAG_INEXACT4 },
#endif
	{ __LINE__, HEXCONSTE(3.08254715559916689926e+02, 0x4007, 0x9a209a84L, 0xfbcff000L), HEXCONSTE(1.79769313486209249758e+308, 0x43fe, 0xffffffffL, 0xffdd04f8L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(3.08254715559916743883e+02, 0x4007, 0x9a209a84L, 0xfbcff798L), HEXCONSTE(1.79769313486231584331e+308, 0x43fe, 0xffffffffL, 0xfffffd6bL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(3.08254715559916743856e+02, 0x4007, 0x9a209a84L, 0xfbcff797L), HEXCONSTE(1.79769313486231572842e+308, 0x43fe, 0xffffffffL, 0xfffff8d0L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(-2.91698059082031250000e+02, 0xc007, 0x91d95a00L, 0x00000000L), HEXCONSTE(2.00419935472324277647e-292, 0x3c36, 0x800081bbL, 0x1a65e9f4L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(-2.91698089599609375000e+02, 0xc007, 0x91d95b00L, 0x00000000L), HEXCONSTE(2.00405852594453940983e-292, 0x3c35, 0xfffc688fL, 0xb58dca2dL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(-2.91698065798397749404e+02, 0xc007, 0x91d95a38L, 0x57498800L), HEXCONSTE(2.00416836000910548953e-292, 0x3c36, 0x80000000L, 0x000951bfL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-2.91698065798397806248e+02, 0xc007, 0x91d95a38L, 0x57499000L), HEXCONSTE(2.00416836000884317038e-292, 0x3c35, 0xffffffffL, 0xffedcc1bL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(-2.91698065798397778159e+02, 0xc007, 0x91d95a38L, 0x57498c0cL), HEXCONSTE(2.00416836000897279299e-292, 0x3c36, 0x80000000L, 0x00000045L), FLAG_INEXACT3|FLAG_FAIL_ARANYM }, /* to inaccurate */
	{ __LINE__, HEXCONSTE(-2.91698065798397778187e+02, 0xc007, 0x91d95a38L, 0x57498c0dL), HEXCONSTE(2.00416836000897266479e-292, 0x3c35, 0xffffffffL, 0xfffffbeeL), FLAG_INEXACT5 },
	{ __LINE__, HEXCONSTE(-2.91698059082031250000e+02, 0xc007, 0x91d95a00L, 0x00000000L), HEXCONSTE(2.00419935472324277647e-292, 0x3c36, 0x800081bbL, 0x1a65e9f4L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(-2.91698089599609375000e+02, 0xc007, 0x91d95b00L, 0x00000000L), HEXCONSTE(2.00405852594453940983e-292, 0x3c35, 0xfffc688fL, 0xb58dca2dL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(-2.91698065798397749404e+02, 0xc007, 0x91d95a38L, 0x57498800L), HEXCONSTE(2.00416836000910548953e-292, 0x3c36, 0x80000000L, 0x000951bfL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-2.91698065798397806248e+02, 0xc007, 0x91d95a38L, 0x57499000L), HEXCONSTE(2.00416836000884317038e-292, 0x3c35, 0xffffffffL, 0xffedcc1bL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(-2.91698065798397778159e+02, 0xc007, 0x91d95a38L, 0x57498c0cL), HEXCONSTE(2.00416836000897279299e-292, 0x3c36, 0x80000000L, 0x00000045L), FLAG_INEXACT3|FLAG_FAIL_ARANYM }, /* to inaccurate */
	{ __LINE__, HEXCONSTE(-2.91698065798397778187e+02, 0xc007, 0x91d95a38L, 0x57498c0dL), HEXCONSTE(2.00416836000897266479e-292, 0x3c35, 0xffffffffL, 0xfffffbeeL), FLAG_INEXACT5 },
#ifdef TEST_LDOUBLE
	{ __LINE__, HEXCONSTE(4.93207568359375000000e+03, 0x400b, 0x9a209b00L, 0x00000000L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(4.93207519531250000000e+03, 0x400b, 0x9a209a00L, 0x00000000L), HEXCONSTE(1.18903684520405024369e+4932, 0x7ffe, 0xffd9bc43L, 0x94211e89L), FLAG_INEXACT5 }, /* 7ffe:ffd9bc43:94212301 */
	{ __LINE__, HEXCONSTE(4.93207544895866794832e+03, 0x400b, 0x9a209a84L, 0xfbcff800L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(4.93207544895866703882e+03, 0x400b, 0x9a209a84L, 0xfbcff000L), HEXCONSTE(1.18973149535486608305e+4932, 0x7ffe, 0xffffffffL, 0xfdd04f79L), FLAG_INEXACT5 }, /* 7ffe:ffffffff:fdd053f2 */
	{ __LINE__, HEXCONSTE(4.93207544895866790213e+03, 0x400b, 0x9a209a84L, 0xfbcff798L), HEXCONSTE(1.18973149535723108298e+4932, 0x7ffe, 0xffffffffL, 0xffffd6b0L), FLAG_INEXACT5 }, /* 7ffe:ffffffff:ffffdb29 */
	{ __LINE__, HEXCONSTE(4.93207568359375000000e+03, 0x400b, 0x9a209b00L, 0x00000000L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(4.93207519531250000000e+03, 0x400b, 0x9a209a00L, 0x00000000L), HEXCONSTE(1.18903684520405024369e+4932, 0x7ffe, 0xffd9bc43L, 0x94211e89L), FLAG_INEXACT5 }, /* 7ffe:ffd9bc43:94212301 */
	{ __LINE__, HEXCONSTE(4.93207544895866794832e+03, 0x400b, 0x9a209a84L, 0xfbcff800L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(4.93207544895866703882e+03, 0x400b, 0x9a209a84L, 0xfbcff000L), HEXCONSTE(1.18973149535486608305e+4932, 0x7ffe, 0xffffffffL, 0xfdd04f79L), FLAG_INEXACT5 }, /* 7ffe:ffffffff:fdd053f2 */
	{ __LINE__, HEXCONSTE(4.93207544895866790258e+03, 0x400b, 0x9a209a84L, 0xfbcff799L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(-4.93147314453125000000e+03, 0xc00b, 0x9a1bc900L, 0x00000000L), HEXCONSTE(3.36399598471665197864e-4932, 0x0001, 0x801272baL, 0xf1d7936dL), FLAG_INEXACT5 }, /* got 0001:801272ba:f1d79130 */
	{ __LINE__, HEXCONSTE(-4.93147363281250000000e+03, 0xc00b, 0x9a1bca00L, 0x00000000L), HEXCONSTE(3.36021593869467811619e-4932, 0x0000, 0xffdb36abL, 0x6ab817c7L), FLAG_INEXACT5|FLAG_FAIL_X87 }, /* 0000:7fed9b55:b55c0be4 */
	{ __LINE__, HEXCONSTE(-4.93147338896733981528e+03, 0xc00b, 0x9a1bc980L, 0x27a81800L), HEXCONSTE(3.36210314311305895704e-4932, 0x0001, 0x80000000L, 0x002869eaL), FLAG_INEXACT5 }, /* 0001:80000000:002867ad */
	{ __LINE__, HEXCONSTE(-4.93147338896734072478e+03, 0xc00b, 0x9a1bc980L, 0x27a82000L), HEXCONSTE(3.36210314310601807772e-4932, 0x0000, 0xffffffffL, 0xfe035d9cL), FLAG_INEXACT5|FLAG_FAIL_X87 }, /* 0000:7fffffff:ff01aece */
	{ __LINE__, HEXCONSTE(-4.93147338896733994007e+03, 0xc00b, 0x9a1bc980L, 0x27a81919L), HEXCONSTE(3.36210314311209289897e-4932, 0x0000, 0xffffffffL, 0xfffff2fbL), FLAG_INEXACT5|FLAG_FAIL_X87 }, /* 0000:7fffffff:fffff97e */
	{ __LINE__, HEXCONSTE(-4.93147314453125000000e+03, 0xc00b, 0x9a1bc900L, 0x00000000L), HEXCONSTE(3.36399598471665197864e-4932, 0x0001, 0x801272baL, 0xf1d7936dL), FLAG_INEXACT5 }, /* 0001:801272ba:f1d79130 */
	{ __LINE__, HEXCONSTE(-4.93147363281250000000e+03, 0xc00b, 0x9a1bca00L, 0x00000000L), HEXCONSTE(3.36021593869467811619e-4932, 0x0000, 0xffdb36abL, 0x6ab817c7L), FLAG_INEXACT5|FLAG_FAIL_X87 }, /* 0000:7fed9b55:b55c0be4 */
	{ __LINE__, HEXCONSTE(-4.93147338896733981528e+03, 0xc00b, 0x9a1bc980L, 0x27a81800L), HEXCONSTE(3.36210314311305895704e-4932, 0x0001, 0x80000000L, 0x002869eaL), FLAG_INEXACT5 }, /* 0001:80000000:002867ad */
	{ __LINE__, HEXCONSTE(-4.93147338896734072478e+03, 0xc00b, 0x9a1bc980L, 0x27a82000L), HEXCONSTE(3.36210314310601807772e-4932, 0x0000, 0xffffffffL, 0xfe035d9cL), FLAG_INEXACT5|FLAG_FAIL_X87 }, /* 0000:7fffffff:ff01aece */
	{ __LINE__, HEXCONSTE(-4.93147338896733993963e+03, 0xc00b, 0x9a1bc980L, 0x27a81918L), HEXCONSTE(3.36210314311209633676e-4932, 0x0001, 0x80000000L, 0x00001e55L), FLAG_INEXACT5 }, /* 0001:80000000:00001c19 */
	{ __LINE__, HEXCONSTE(-4.93177441406250000000e+03, 0xc00b, 0x9a1e3200L, 0x00000000L), HEXCONSTE(1.68107054035864420578e-4932, 0x0000, 0x80005ea7L, 0xf8a5baa4L), FLAG_INEXACT5|FLAG_FAIL_X87 }, /* 0000:40002f53:fc52dd52 */
	{ __LINE__, HEXCONSTE(-4.93177490234375000000e+03, 0xc00b, 0x9a1e3300L, 0x00000000L), HEXCONSTE(1.67918155950444280499e-4932, 0x0000, 0x7fdb8c76L, 0x0da3c778L), FLAG_INEXACT5|FLAG_FAIL_X87 }, /* 0000:3fedc63b:06d1e3bc */
	{ __LINE__, HEXCONSTE(-4.93177441896300388180e+03, 0xc00b, 0x9a1e3202L, 0x91bc0800L), HEXCONSTE(1.68105157155619921141e-4932, 0x0000, 0x80000000L, 0x000cc389L), FLAG_INEXACT5|FLAG_FAIL_X87 }, /* 0000:40000000:000661c4 */
	{ __LINE__, HEXCONSTE(-4.93177441896300479129e+03, 0xc00b, 0x9a1e3202L, 0x91bc1000L), HEXCONSTE(1.68105157155267877175e-4932, 0x0000, 0x7fffffffL, 0xfee6086dL), FLAG_INEXACT5|FLAG_FAIL_X87 }, /* 0000:3fffffff:ff730436 */
	{ __LINE__, HEXCONSTE(-4.93177441896300392132e+03, 0xc00b, 0x9a1e3202L, 0x91bc0859L), HEXCONSTE(1.68105157155604622385e-4932, 0x0000, 0x7fffffffL, 0xfffff4a7L), FLAG_INEXACT5|FLAG_FAIL_X87 }, /* 0000:3fffffff:fffffa54 */
	{ __LINE__, HEXCONSTE(-4.93177441406250000000e+03, 0xc00b, 0x9a1e3200L, 0x00000000L), HEXCONSTE(1.68107054035864420578e-4932, 0x0000, 0x80005ea7L, 0xf8a5baa4L), FLAG_INEXACT5|FLAG_FAIL_X87 }, /* 0000:40002f53:fc52dd52 */
	{ __LINE__, HEXCONSTE(-4.93177490234375000000e+03, 0xc00b, 0x9a1e3300L, 0x00000000L), HEXCONSTE(1.67918155950444280499e-4932, 0x0000, 0x7fdb8c76L, 0x0da3c778L), FLAG_INEXACT5|FLAG_FAIL_X87 }, /* 0000:3fedc63b:06d1e3bc */
	{ __LINE__, HEXCONSTE(-4.93177441896300388180e+03, 0xc00b, 0x9a1e3202L, 0x91bc0800L), HEXCONSTE(1.68105157155619921141e-4932, 0x0000, 0x80000000L, 0x000cc389L), FLAG_INEXACT5|FLAG_FAIL_X87 }, /* 0000:40000000:000661c4 */
	{ __LINE__, HEXCONSTE(-4.93177441896300479129e+03, 0xc00b, 0x9a1e3202L, 0x91bc1000L), HEXCONSTE(1.68105157155267877175e-4932, 0x0000, 0x7fffffffL, 0xfee6086dL), FLAG_INEXACT5|FLAG_FAIL_X87 }, /* 0000:3fffffff:ff730436 */
	{ __LINE__, HEXCONSTE(-4.93177441896300392088e+03, 0xc00b, 0x9a1e3202L, 0x91bc0858L), HEXCONSTE(1.68105157155604794292e-4932, 0x0000, 0x80000000L, 0x0000197fL), FLAG_INEXACT5|FLAG_FAIL_X87 }, /* 0000:40000000:00000cc0 */
	{ __LINE__, HEXCONSTE(4.93207568359375000000e+03, 0x400b, 0x9a209b00L, 0x00000000L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(4.93207519531250000000e+03, 0x400b, 0x9a209a00L, 0x00000000L), HEXCONSTE(1.18903684520405024369e+4932, 0x7ffe, 0xffd9bc43L, 0x94212301L), FLAG_INEXACT5 }, /* 7ffe:ffd9bc43:94211e89 */
	{ __LINE__, HEXCONSTE(4.93207544895866794832e+03, 0x400b, 0x9a209a84L, 0xfbcff800L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(4.93207544895866703882e+03, 0x400b, 0x9a209a84L, 0xfbcff000L), HEXCONSTE(1.18973149535486608305e+4932, 0x7ffe, 0xffffffffL, 0xfdd053f2L), FLAG_INEXACT5 }, /* 7ffe:ffffffff:fdd04f79 */
	{ __LINE__, HEXCONSTE(4.93207544895866790258e+03, 0x400b, 0x9a209a84L, 0xfbcff799L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(4.93207544895866790213e+03, 0x400b, 0x9a209a84L, 0xfbcff798L), HEXCONSTE(1.18973149535723108298e+4932, 0x7ffe, 0xffffffffL, 0xffffdb29L), FLAG_INEXACT5 }, /* 7ffe:ffffffff:ffffd6b0 */
	{ __LINE__, HEXCONSTE(4.93207568359375000000e+03, 0x400b, 0x9a209b00L, 0x00000000L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(4.93207519531250000000e+03, 0x400b, 0x9a209a00L, 0x00000000L), HEXCONSTE(1.18903684520405024369e+4932, 0x7ffe, 0xffd9bc43L, 0x94212301L), FLAG_INEXACT5 }, /* 7ffe:ffd9bc43:94211e89 */
	{ __LINE__, HEXCONSTE(4.93207544895866794832e+03, 0x400b, 0x9a209a84L, 0xfbcff800L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(4.93207544895866703882e+03, 0x400b, 0x9a209a84L, 0xfbcff000L), HEXCONSTE(1.18973149535486608305e+4932, 0x7ffe, 0xffffffffL, 0xfdd053f2L), FLAG_INEXACT5 }, /* 7ffe:ffffffff:fdd04f79 */
	{ __LINE__, HEXCONSTE(4.93207544895866790258e+03, 0x400b, 0x9a209a84L, 0xfbcff799L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(4.93207544895866790213e+03, 0x400b, 0x9a209a84L, 0xfbcff798L), HEXCONSTE(1.18973149535723108298e+4932, 0x7ffe, 0xffffffffL, 0xffffdb29L), FLAG_INEXACT5 }, /* 7ffe:ffffffff:ffffd6b0 */
	{ __LINE__, HEXCONSTE(-4.93147314453125000000e+03, 0xc00b, 0x9a1bc900L, 0x00000000L), HEXCONSTE(3.36399598471665197864e-4932, 0x0001, 0x801272baL, 0xf1d79130L), FLAG_INEXACT5 }, /* 0001:801272ba:f1d7936d */
	{ __LINE__, HEXCONSTE(-4.93147363281250000000e+03, 0xc00b, 0x9a1bca00L, 0x00000000L), HEXCONSTE(3.36021593869467811619e-4932, 0x0000, 0xffdb36abL, 0x6ab817c7L), FLAG_INEXACT5|FLAG_FAIL_X87 }, /* 0000:7fed9b55:b55c0be4 */
	{ __LINE__, HEXCONSTE(-4.93147338896733981528e+03, 0xc00b, 0x9a1bc980L, 0x27a81800L), HEXCONSTE(3.36210314311305895704e-4932, 0x0001, 0x80000000L, 0x002867adL), FLAG_INEXACT5 }, /* 0001:80000000:002869ea */
	{ __LINE__, HEXCONSTE(-4.93147338896734072478e+03, 0xc00b, 0x9a1bc980L, 0x27a82000L), HEXCONSTE(3.36210314310601807772e-4932, 0x0000, 0xffffffffL, 0xfe035d9cL), FLAG_INEXACT5|FLAG_FAIL_X87 }, /* 0000:7fffffff:ff01aece */
	{ __LINE__, HEXCONSTE(-4.93147338896733993963e+03, 0xc00b, 0x9a1bc980L, 0x27a81918L), HEXCONSTE(3.36210314311209633676e-4932, 0x0001, 0x80000000L, 0x00001c19L), FLAG_INEXACT5 }, /* 0001:80000000:00001e55 */
	{ __LINE__, HEXCONSTE(-4.93147338896733994007e+03, 0xc00b, 0x9a1bc980L, 0x27a81919L), HEXCONSTE(3.36210314311209289897e-4932, 0x0000, 0xffffffffL, 0xfffff2fbL), FLAG_INEXACT5|FLAG_FAIL_X87 }, /* 0000:7fffffff:fffff97e */
	{ __LINE__, HEXCONSTE(-4.93147314453125000000e+03, 0xc00b, 0x9a1bc900L, 0x00000000L), HEXCONSTE(3.36399598471665197864e-4932, 0x0001, 0x801272baL, 0xf1d79130L), FLAG_INEXACT5 }, /* 0001:801272ba:f1d7936d */
	{ __LINE__, HEXCONSTE(-4.93147363281250000000e+03, 0xc00b, 0x9a1bca00L, 0x00000000L), HEXCONSTE(3.36021593869467811619e-4932, 0x0000, 0xffdb36abL, 0x6ab817c7L), FLAG_INEXACT5|FLAG_FAIL_X87 }, /* 0000:7fed9b55:b55c0be4 */
	{ __LINE__, HEXCONSTE(-4.93147338896733981528e+03, 0xc00b, 0x9a1bc980L, 0x27a81800L), HEXCONSTE(3.36210314311305895704e-4932, 0x0001, 0x80000000L, 0x002867adL), FLAG_INEXACT5 }, /* 0001:80000000:002869ea */
	{ __LINE__, HEXCONSTE(-4.93147338896734072478e+03, 0xc00b, 0x9a1bc980L, 0x27a82000L), HEXCONSTE(3.36210314310601807772e-4932, 0x0000, 0xffffffffL, 0xfe035d9cL), FLAG_INEXACT5|FLAG_FAIL_X87 }, /* 0000:7fffffff:ff01aece */
	{ __LINE__, HEXCONSTE(-4.93147338896733993963e+03, 0xc00b, 0x9a1bc980L, 0x27a81918L), HEXCONSTE(3.36210314311209633676e-4932, 0x0001, 0x80000000L, 0x00001c19L), FLAG_INEXACT5 }, /* 0001:80000000:00001e55 */
	{ __LINE__, HEXCONSTE(-4.93147338896733994007e+03, 0xc00b, 0x9a1bc980L, 0x27a81919L), HEXCONSTE(3.36210314311209289897e-4932, 0x0000, 0xffffffffL, 0xfffff2fbL), FLAG_INEXACT5|FLAG_FAIL_X87 }, /* 0000:7fffffff:fffff97e */
#endif
	{ __LINE__, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#ifdef TEST_LDOUBLE
	{ __LINE__, HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#ifdef TEST_LDOUBLE
	{ __LINE__, HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#ifdef TEST_LDOUBLE
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#ifdef TEST_LDOUBLE
	{ __LINE__, HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(8.72861266136169433594e-01, 0x3ffe, 0xdf73d600L, 0x00000000L), HEXCONSTE(7.46210346028826756798e+00, 0x4001, 0xeec98d32L, 0x29cf353bL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.79845368862152099609e+00, 0x3fff, 0xe633bb00L, 0x00000000L), HEXCONSTE(6.28714806980470528458e+01, 0x4004, 0xfb7c656fL, 0xa4d451bcL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(5.68768024444580078125e+00, 0x4001, 0xb6017a00L, 0x00000000L), HEXCONSTE(4.87169672354115564445e+05, 0x4011, 0xede03583L, 0xecc735c5L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(5.68767976760864257812e+00, 0x4001, 0xb6017900L, 0x00000000L), HEXCONSTE(4.87169137462505655122e+05, 0x4011, 0xede02466L, 0x17c4c6e1L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(5.68768009755876313704e+00, 0x4001, 0xb60179b1L, 0x23ffd000L), HEXCONSTE(4.87169507583663986821e+05, 0x4011, 0xede0303eL, 0x201899d5L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(5.68768009755876224887e+00, 0x4001, 0xb60179b1L, 0x23ffc800L), HEXCONSTE(4.87169507583662990498e+05, 0x4011, 0xede0303eL, 0x201810e6L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(5.68768009755876256719e+00, 0x4001, 0xb60179b1L, 0x23ffcadeL), HEXCONSTE(4.87169507583663347589e+05, 0x4011, 0xede0303eL, 0x201841faL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.32700332641601562500e+02, 0x4006, 0xe8b34900L, 0x00000000L), HEXCONSTE(5.01571257818422521444e+232, 0x4304, 0x813a5156L, 0x4fd07c32L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(3.28656721115112304688e+00, 0x4000, 0xd2571e00L, 0x00000000L), HEXCONSTE(1.93449321645361247268e+03, 0x4009, 0xf1cfc86dL, 0xdf43ab63L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.59501857757568359375e+01, 0x4002, 0xff33f600L, 0x00000000L), HEXCONSTE(8.91632265188541608350e+15, 0x4033, 0xfd6ac922L, 0xf27b40abL), FLAG_INEXACT2 },
};

int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_f_f(ftentox_data, ARRAY_SIZE(ftentox_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

#else

int main(void)
{
	return 77;
}

#endif

```

`tests/exp2.c`:

```c
#include "testconfig.h"
#ifdef HAVE_EXP2
#define TEST_FUNC_F_F __MATH_PRECNAME(exp2)
#include "testdriver.h"



static test_f_f_data const ftwotox_data[] = {
	{ __LINE__, ZERO_P, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, ZERO_M, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, INF_P, INF_P, FLAG_FAIL_JIT|FLAG_XFAIL_LINUX },
	{ __LINE__, INF_M, ZERO_P, FLAG_FAIL_JIT|FLAG_XFAIL_LINUX },
	{ __LINE__, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_P, 0 },
	{ __LINE__, SNAN_P, QNAN_P, 0 },
	{ __LINE__, SNAN_M, QNAN_P, 0 },

	{ __LINE__, HEXCONSTE(1.00000000000000000000e+01, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(1.02400000000000000000e+03, 0x4009, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(5.00000000000000000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+06, 0x4012, 0xf4240000L, 0x00000000L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(-1.00000000000000000000e+06, 0xc012, 0xf4240000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), INF_P, 0 },
	{ __LINE__, HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(7.50000000000000000000e-01, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(1.68179283050742908604e+00, 0x3fff, 0xd744fccaL, 0xd69d6af4L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.00500000000000000000e+02, 0x4005, 0xc9000000L, 0x00000000L), HEXCONSTE(1.79272867119315647735e+30, 0x4063, 0xb504f333L, 0xf9de6484L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-1.16500000000000000000e+02, 0xc005, 0xe9000000L, 0x00000000L), HEXCONSTE(8.51148827354028015500e-36, 0x3f8a, 0xb504f333L, 0xf9de6484L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-1.23500000000000000000e+02, 0xc005, 0xf7000000L, 0x00000000L), HEXCONSTE(6.64960021370334387110e-38, 0x3f83, 0xb504f333L, 0xf9de6484L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-1.24500000000000000000e+02, 0xc005, 0xf9000000L, 0x00000000L), HEXCONSTE(3.32480010685167193555e-38, 0x3f82, 0xb504f333L, 0xf9de6484L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-1.25500000000000000000e+02, 0xc005, 0xfb000000L, 0x00000000L), HEXCONSTE(1.66240005342583596777e-38, 0x3f81, 0xb504f333L, 0xf9de6484L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.27000000000000000000e+02, 0x4005, 0xfe000000L, 0x00000000L), HEXCONSTE(1.70141183460469231732e+38, 0x407e, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.49000000000000000000e+02, 0xc006, 0x95000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.00025000000000000000e+03, 0x4008, 0xfa100000L, 0x00000000L), HEXCONSTE(1.27424565945256487474e+301, 0x43e7, 0x9837f051L, 0x8db8a96fL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-1.01950000000000000000e+03, 0xc008, 0xfee00000L, 0x00000000L), HEXCONSTE(1.25869185119308692415e-307, 0x3c03, 0xb504f333L, 0xf9de6484L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-1.02050000000000000000e+03, 0xc008, 0xff200000L, 0x00000000L), HEXCONSTE(6.29345925596543462075e-308, 0x3c02, 0xb504f333L, 0xf9de6484L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-1.02150000000000000000e+03, 0xc008, 0xff600000L, 0x00000000L), HEXCONSTE(3.14672962798271731037e-308, 0x3c01, 0xb504f333L, 0xf9de6484L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.02300000000000000000e+03, 0x4008, 0xffc00000L, 0x00000000L), HEXCONSTE(8.98846567431157953865e+307, 0x43fe, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.07400000000000000000e+03, 0xc009, 0x86400000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), FLAG_SUBNORM },
#ifdef TEST_LDOUBLE
	{ __LINE__, HEXCONSTE(1.63830000000000000000e+04, 0x400c, 0xfffc0000L, 0x00000000L), HEXCONSTE(5.94865747678615882543e+4931, 0x7ffe, 0x80000000L, 0x00000000L), 0 },
#if __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(-1.64000000000000000000e+04, 0xc00d, 0x80200000L, 0x00000000L), HEXCONSTE(1.28254056667789211512e-4937, 0x0000, 0x00004000L, 0x00000000L), FLAG_FAIL_X87 },
#else
	{ __LINE__, HEXCONSTE(-1.64000000000000000000e+04, 0xc00d, 0x80200000L, 0x00000000L), HEXCONSTE(1.28254056667789211512e-4937, 0x0000, 0x00002000L, 0x00000000L), FLAG_FAIL_X87 },
#endif
#endif
	{ __LINE__, HEXCONSTE(-1.26125000000000000000e+02, 0xc005, 0xfc400000L, 0x00000000L), HEXCONSTE(1.07793307246828789602e-38, 0x3f80, 0xeac0c6e7L, 0xdd24392fL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-1.26250000000000000000e+02, 0xc005, 0xfc800000L, 0x00000000L), HEXCONSTE(9.88468985757453879590e-39, 0x3f80, 0xd744fccaL, 0xd69d6af4L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-1.26375000000000000000e+02, 0xc005, 0xfcc00000L, 0x00000000L), HEXCONSTE(9.06430056522005789823e-39, 0x3f80, 0xc5672a11L, 0x5506daddL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-1.26500000000000000000e+02, 0xc005, 0xfd000000L, 0x00000000L), HEXCONSTE(8.31200026712917983887e-39, 0x3f80, 0xb504f333L, 0xf9de6484L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-1.26625000000000000000e+02, 0xc005, 0xfd400000L, 0x00000000L), HEXCONSTE(7.62213785207576524858e-39, 0x3f80, 0xa5fed6a9L, 0xb15138eaL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-1.26750000000000000000e+02, 0xc005, 0xfd800000L, 0x00000000L), HEXCONSTE(6.98953122821684501786e-39, 0x3f80, 0x9837f051L, 0x8db8a96fL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-1.26875000000000000000e+02, 0xc005, 0xfdc00000L, 0x00000000L), HEXCONSTE(6.40942839638015852804e-39, 0x3f80, 0x8b95c1e3L, 0xea8bd6e7L), FLAG_INEXACT2 },
#if 0
	{ __LINE__, HEXCONSTE(-1.02212500000000000000e+03, 0xc008, 0xff880000L, 0x00000000L), HEXCONSTE(2.04040172468012222027e-308, 0x3c00, 0xeac0c6e7L, 0xdd24392fL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-1.02225000000000000000e+03, 0xc008, 0xff900000L, 0x00000000L), HEXCONSTE(1.87105663129345649192e-308, 0x3c00, 0xd744fccaL, 0xd69d6af4L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-1.02237500000000000000e+03, 0xc008, 0xff980000L, 0x00000000L), HEXCONSTE(1.71576649596101138792e-308, 0x3c00, 0xc5672a11L, 0x5506daddL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-1.02250000000000000000e+03, 0xc008, 0xffa00000L, 0x00000000L), HEXCONSTE(1.57336481399135865519e-308, 0x3c00, 0xb504f333L, 0xf9de6484L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-1.02262500000000000000e+03, 0xc008, 0xffa80000L, 0x00000000L), HEXCONSTE(1.44278189586604136836e-308, 0x3c00, 0xa5fed6a9L, 0xb15138eaL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-1.02275000000000000000e+03, 0xc008, 0xffb00000L, 0x00000000L), HEXCONSTE(1.32303683197166086893e-308, 0x3c00, 0x9837f051L, 0x8db8a96fL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-1.02287500000000000000e+03, 0xc008, 0xffb80000L, 0x00000000L), HEXCONSTE(1.21323012422671225631e-308, 0x3c00, 0x8b95c1e3L, 0xea8bd6e7L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-1.02230664062500000000e+03, 0xc008, 0xff93a000L, 0x00000000L), HEXCONSTE(1.79902171454620233154e-308, 0x3c00, 0xcefb505eL, 0x7e0af001L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-1.02231713867187500000e+03, 0xc008, 0xff944c00L, 0x00000000L), HEXCONSTE(1.78597830235888235660e-308, 0x3c00, 0xcd7b241bL, 0xc8bef000L), FLAG_INEXACT2 },
#endif
	{ __LINE__, HEXCONSTE(-1.63821250000000000000e+04, 0xc00c, 0xfff88000L, 0x00000000L), HEXCONSTE(3.08306217590492313920e-4932, 0x0000, 0xeac0c6e7L, 0xdd24392fL), FLAG_INEXACT2|FLAG_FAIL_X87 }, /* 0000:75606373:ee921c98 */
	{ __LINE__, HEXCONSTE(-1.63822500000000000000e+04, 0xc00c, 0xfff90000L, 0x00000000L), HEXCONSTE(2.82718048075620583510e-4932, 0x0000, 0xd744fccaL, 0xd69d6af4L), FLAG_INEXACT2|FLAG_FAIL_X87 }, /* 0000:6ba27e65:6b4eb57a */
	{ __LINE__, HEXCONSTE(-1.63823750000000000000e+04, 0xc00c, 0xfff98000L, 0x00000000L), HEXCONSTE(2.59253593172276695929e-4932, 0x0000, 0xc5672a11L, 0x5506daddL), FLAG_INEXACT2|FLAG_FAIL_X87 }, /* 0000:62b39508:aa836d6e */
	{ __LINE__, HEXCONSTE(-1.63825000000000000000e+04, 0xc00c, 0xfffa0000L, 0x00000000L), HEXCONSTE(2.37736593154316677945e-4932, 0x0000, 0xb504f333L, 0xf9de6484L), FLAG_INEXACT2|FLAG_FAIL_X87 }, /* 0000:5a827999:fcef3242 */
	{ __LINE__, HEXCONSTE(-1.63826250000000000000e+04, 0xc00c, 0xfffa8000L, 0x00000000L), HEXCONSTE(2.18005417140212357933e-4932, 0x0000, 0xa5fed6a9L, 0xb15138eaL), FLAG_INEXACT2|FLAG_FAIL_X87 }, /* 0000:52ff6b54:d8a89c75 */
	{ __LINE__, HEXCONSTE(-1.63827500000000000000e+04, 0xc00c, 0xfffb0000L, 0x00000000L), HEXCONSTE(1.99911848958095667371e-4932, 0x0000, 0x9837f051L, 0x8db8a96fL), FLAG_INEXACT2|FLAG_FAIL_X87 }, /* 0000:4c1bf828:c6dc54b8 */
	{ __LINE__, HEXCONSTE(-1.63828750000000000000e+04, 0xc00c, 0xfffb8000L, 0x00000000L), HEXCONSTE(1.83319973779095268933e-4932, 0x0000, 0x8b95c1e3L, 0xea8bd6e7L), FLAG_INEXACT2|FLAG_FAIL_X87 }, /* 0000:45cae0f1:f545eb74 */
	{ __LINE__, HEXCONSTE(9.76562500000000000000e-04, 0x3ff5, 0x80000000L, 0x00000000L), HEXCONSTE(1.00067713069306635666e+00, 0x3fff, 0x8016302fL, 0x17467628L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-9.76562500000000000000e-04, 0xbff5, 0x80000000L, 0x00000000L), HEXCONSTE(9.99323327502650752370e-01, 0x3ffe, 0xffd3a751L, 0xc0f7e10cL), 0 },
	{ __LINE__, HEXCONSTE(9.53674316406250000000e-07, 0x3feb, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000066103688207422e+00, 0x3fff, 0x8000058bL, 0x90de7e4dL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-9.53674316406250000000e-07, 0xbfeb, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999338963554895254e-01, 0x3ffe, 0xfffff4e8L, 0xdebe025eL), 0 },
	{ __LINE__, HEXCONSTE(9.31322574615478515625e-10, 0x3fe1, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000064554361704e+00, 0x3fff, 0x80000001L, 0x62e42ff2L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-9.31322574615478515625e-10, 0xbfe1, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999999354456383445e-01, 0x3ffe, 0xfffffffdL, 0x3a37a025L), 0 },
	{ __LINE__, HEXCONSTE(9.09494701772928237915e-13, 0x3fd7, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000063041369e+00, 0x3fff, 0x80000000L, 0x0058b90cL), 0 },
	{ __LINE__, HEXCONSTE(-9.09494701772928237915e-13, 0xbfd7, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999999999369586310e-01, 0x3ffe, 0xffffffffL, 0xff4e8de8L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(8.88178419700125232339e-16, 0x3fcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000061561e+00, 0x3fff, 0x80000000L, 0x0000162eL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-8.88178419700125232339e-16, 0xbfcd, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999999999999384336e-01, 0x3ffe, 0xffffffffL, 0xffffd3a3L), 0 },
	{ __LINE__, HEXCONSTE(8.67361737988403547206e-19, 0x3fc3, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000065e+00, 0x3fff, 0x80000000L, 0x00000006L), 0 },
	{ __LINE__, HEXCONSTE(-8.67361737988403547206e-19, 0xbfc3, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999999999999999404e-01, 0x3ffe, 0xffffffffL, 0xfffffff5L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(7.88860905221011805412e-31, 0x3f9b, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-7.88860905221011805412e-31, 0xbf9b, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.40991986510288411774e-181, 0x3da7, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-2.40991986510288411774e-181, 0xbda7, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(5.01237274920645200930e-3011, 0x18ef, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-5.01237274920645200930e-3011, 0x98ef, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.27999992370605468750e+02, 0x4005, 0xffffff00L, 0x00000000L), HEXCONSTE(3.40280567412732569415e+38, 0x407e, 0xffffa747L, 0x0363f451L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.28000015258789062500e+02, 0x4006, 0x80000100L, 0x00000000L), HEXCONSTE(3.40285965965899358974e+38, 0x407f, 0x800058b9L, 0x2abbae02L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.26000007629394531250e+02, 0xc005, 0xfc000100L, 0x00000000L), HEXCONSTE(1.17548813447981455733e-38, 0x3f80, 0xffffa747L, 0x0363f451L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.25999992370605468750e+02, 0xc005, 0xfbffff00L, 0x00000000L), HEXCONSTE(1.17550056719763438781e-38, 0x3f81, 0x80002c5cL, 0x8dade4d7L), FLAG_INEXACT },
#ifdef TEST_LDOUBLE
	{ __LINE__, HEXCONSTE(1.02400000000000000000e+03, 0x4009, 0x80000000L, 0x00000000L), HEXCONSTE(1.79769313486231590773e+308, 0x43ff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, HEXCONSTE(1.02399993896484375000e+03, 0x4008, 0xffffff00L, 0x00000000L), HEXCONSTE(1.79761708264246330453e+308, 0x43fe, 0xfffd3a3bL, 0x7814eb54L), 0 },
	{ __LINE__, HEXCONSTE(1.02399999999999988631e+03, 0x4008, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.79769313486217424643e+308, 0x43fe, 0xffffffffL, 0xffe9d1bdL), 0 },
#ifdef TEST_LDOUBLE
	{ __LINE__, HEXCONSTE(1.02400012207031250000e+03, 0x4009, 0x80000100L, 0x00000000L), HEXCONSTE(1.79784524895483611227e+308, 0x43ff, 0x8002c5d0L, 0x0fdcfcb7L), 0 },
	{ __LINE__, HEXCONSTE(1.02400000000000000000e+03, 0x4009, 0x80000000L, 0x00000000L), HEXCONSTE(1.79769313486231590773e+308, 0x43ff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.02400000000000022737e+03, 0x4009, 0x80000000L, 0x00000800L), HEXCONSTE(1.79769313486259923032e+308, 0x43ff, 0x80000000L, 0x00162e43L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-1.02200000000000000000e+03, 0xc008, 0xff800000L, 0x00000000L), HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.02200006103515625000e+03, 0xc008, 0xff800100L, 0x00000000L), HEXCONSTE(2.22497972575284315367e-308, 0x3c00, 0xfffd3a3bL, 0x7814eb54L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(-1.02200000000000011369e+03, 0xc008, 0xff800000L, 0x00000800L), HEXCONSTE(2.22507385850702604346e-308, 0x3c00, 0xffffffffL, 0xffe9d1bdL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(-1.02199993896484375000e+03, 0xc008, 0xff7fff00L, 0x00000000L), HEXCONSTE(2.22516799524405677445e-308, 0x3c01, 0x800162e6L, 0x1bed4a49L), 0 },
	{ __LINE__, HEXCONSTE(-1.02200000000000000000e+03, 0xc008, 0xff800000L, 0x00000000L), HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.02199999999999988631e+03, 0xc008, 0xff7fffffL, 0xfffff800L), HEXCONSTE(2.22507385850737672260e-308, 0x3c01, 0x80000000L, 0x000b1721L), FLAG_INEXACT4 },
#ifdef TEST_LDOUBLE
	{ __LINE__, HEXCONSTE(1.02400000000000000000e+03, 0x4009, 0x80000000L, 0x00000000L), HEXCONSTE(1.79769313486231590773e+308, 0x43ff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, HEXCONSTE(1.02399993896484375000e+03, 0x4008, 0xffffff00L, 0x00000000L), HEXCONSTE(1.79761708264246330453e+308, 0x43fe, 0xfffd3a3bL, 0x7814eb54L), 0 },
	{ __LINE__, HEXCONSTE(1.02399999999999988631e+03, 0x4008, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.79769313486217424643e+308, 0x43fe, 0xffffffffL, 0xffe9d1bdL), 0 },
	{ __LINE__, HEXCONSTE(1.02399999999999999994e+03, 0x4008, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.79769313486231583854e+308, 0x43fe, 0xffffffffL, 0xfffffd3aL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(1.02399999999999999989e+03, 0x4008, 0xffffffffL, 0xfffffffeL), HEXCONSTE(1.79769313486231576935e+308, 0x43fe, 0xffffffffL, 0xfffffa74L), FLAG_INEXACT4 },
#ifdef TEST_LDOUBLE
	{ __LINE__, HEXCONSTE(1.02400000000000000000e+03, 0x4009, 0x80000000L, 0x00000000L), HEXCONSTE(1.79769313486231590773e+308, 0x43ff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, HEXCONSTE(1.02399993896484375000e+03, 0x4008, 0xffffff00L, 0x00000000L), HEXCONSTE(1.79761708264246330453e+308, 0x43fe, 0xfffd3a3bL, 0x7814eb54L), 0 },
	{ __LINE__, HEXCONSTE(1.02399999999999988631e+03, 0x4008, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.79769313486217424643e+308, 0x43fe, 0xffffffffL, 0xffe9d1bdL), 0 },
	{ __LINE__, HEXCONSTE(1.02399999999999999994e+03, 0x4008, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.79769313486231583854e+308, 0x43fe, 0xffffffffL, 0xfffffd3aL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(1.02399999999999999989e+03, 0x4008, 0xffffffffL, 0xfffffffeL), HEXCONSTE(1.79769313486231576935e+308, 0x43fe, 0xffffffffL, 0xfffffa74L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(-9.69000000000000000000e+02, 0xc008, 0xf2400000L, 0x00000000L), HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-9.69000061035156250000e+02, 0xc008, 0xf2400100L, 0x00000000L), HEXCONSTE(2.00408357276148256190e-292, 0x3c35, 0xfffd3a3bL, 0x7814eb54L), 0 },
	{ __LINE__, HEXCONSTE(-9.69000000000000113687e+02, 0xc008, 0xf2400000L, 0x00000800L), HEXCONSTE(2.00416836000881484610e-292, 0x3c35, 0xffffffffL, 0xffe9d1bdL), 0 },
	{ __LINE__, HEXCONSTE(-9.69000000000000000056e+02, 0xc008, 0xf2400000L, 0x00000001L), HEXCONSTE(2.00416836000897270086e-292, 0x3c35, 0xffffffffL, 0xfffffd3aL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-9.68999938964843750000e+02, 0xc008, 0xf23fff00L, 0x00000000L), HEXCONSTE(2.00425315084357754099e-292, 0x3c36, 0x800162e6L, 0x1bed4a49L), 0 },
	{ __LINE__, HEXCONSTE(-9.69000000000000000000e+02, 0xc008, 0xf2400000L, 0x00000000L), HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-9.68999999999999886313e+02, 0xc008, 0xf23fffffL, 0xfffff800L), HEXCONSTE(2.00416836000913070978e-292, 0x3c36, 0x80000000L, 0x000b1721L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(-9.68999999999999999944e+02, 0xc008, 0xf23fffffL, 0xffffffffL), HEXCONSTE(2.00416836000897285513e-292, 0x3c36, 0x80000000L, 0x00000163L), FLAG_INEXACT4 },
#ifdef TEST_LDOUBLE
	{ __LINE__, HEXCONSTE(1.63840000000000000000e+04, 0x400d, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(1.63839990234375000000e+04, 0x400c, 0xffffff00L, 0x00000000L), HEXCONSTE(1.18892643677509333225e+4932, 0x7ffe, 0xffd3a751L, 0xc0f7e10cL), 0 },
	{ __LINE__, HEXCONSTE(1.63839999999999981810e+04, 0x400c, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.18973149535573171904e+4932, 0x7ffe, 0xffffffffL, 0xfe9d1bd0L), 0 },
	{ __LINE__, HEXCONSTE(1.63839999999999999991e+04, 0x400c, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.18973149535723103261e+4932, 0x7ffe, 0xffffffffL, 0xffffd3a3L), 0 },
	{ __LINE__, HEXCONSTE(1.63840019531250000000e+04, 0x400d, 0x80000100L, 0x00000000L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(1.63840000000000000000e+04, 0x400d, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(1.63840000000000036380e+04, 0x400d, 0x80000000L, 0x00000800L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(1.63840000000000000018e+04, 0x400d, 0x80000000L, 0x00000001L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(-1.63820000000000000000e+04, 0xc00c, 0xfff80000L, 0x00000000L), HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), 0 },
#if __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(-1.63820009765625000000e+04, 0xc00c, 0xfff80100L, 0x00000000L), HEXCONSTE(3.35982810038189809104e-4932, 0x0000, 0xffd3a751L, 0xc0f7e10cL), FLAG_FAIL_X87 },
	{ __LINE__, HEXCONSTE(-1.63820000000000018190e+04, 0xc00c, 0xfff80000L, 0x00000800L), HEXCONSTE(3.36210314310785447457e-4932, 0x0000, 0xffffffffL, 0xfe9d1bd0L), FLAG_FAIL_X87 },
	{ __LINE__, HEXCONSTE(-1.63820000000000000009e+04, 0xc00c, 0xfff80000L, 0x00000001L), HEXCONSTE(3.36210314311209143652e-4932, 0x0000, 0xffffffffL, 0xffffd3a3L), FLAG_FAIL_X87 },
#else
	{ __LINE__, HEXCONSTE(-1.63820009765625000000e+04, 0xc00c, 0xfff80100L, 0x00000000L), HEXCONSTE(3.35982810038189809104e-4932, 0x0000, 0x7fe9d3a8L, 0xe07bf086L), 0 },
	{ __LINE__, HEXCONSTE(-1.63820000000000018190e+04, 0xc00c, 0xfff80000L, 0x00000800L), HEXCONSTE(3.36210314310785447457e-4932, 0x0000, 0x7fffffffL, 0xff4e8de8L), 0 },
	{ __LINE__, HEXCONSTE(-1.63820000000000000009e+04, 0xc00c, 0xfff80000L, 0x00000001L), HEXCONSTE(3.36210314311209143652e-4932, 0x0000, 0x7fffffffL, 0xffffe9d2L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-1.63819990234375000000e+04, 0xc00c, 0xfff7ff00L, 0x00000000L), HEXCONSTE(3.36437972634354957423e-4932, 0x0001, 0x8016302fL, 0x17467628L), 0 },
	{ __LINE__, HEXCONSTE(-1.63820000000000000000e+04, 0xc00c, 0xfff80000L, 0x00000000L), HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.63819999999999981810e+04, 0xc00c, 0xfff7ffffL, 0xfffff800L), HEXCONSTE(3.36210314311633253796e-4932, 0x0001, 0x80000000L, 0x00b17218L), 0 },
	{ __LINE__, HEXCONSTE(-1.63819999999999999991e+04, 0xc00c, 0xfff7ffffL, 0xffffffffL), HEXCONSTE(3.36210314311209557601e-4932, 0x0001, 0x80000000L, 0x0000162eL), 0 },
#if __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(-1.63830000000000000000e+04, 0xc00c, 0xfffc0000L, 0x00000000L), HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x80000000L, 0x00000000L), FLAG_FAIL_X87 },
	{ __LINE__, HEXCONSTE(-1.63830009765625000000e+04, 0xc00c, 0xfffc0100L, 0x00000000L), HEXCONSTE(1.67991405019094904552e-4932, 0x0000, 0x7fe9d3a8L, 0xe07bf086L), FLAG_FAIL_X87 },
	{ __LINE__, HEXCONSTE(-1.63830000000000018190e+04, 0xc00c, 0xfffc0000L, 0x00000800L), HEXCONSTE(1.68105157155392723728e-4932, 0x0000, 0x7fffffffL, 0xff4e8de8L), FLAG_FAIL_X87 },
	{ __LINE__, HEXCONSTE(-1.63830000000000000009e+04, 0xc00c, 0xfffc0000L, 0x00000001L), HEXCONSTE(1.68105157155604571826e-4932, 0x0000, 0x7fffffffL, 0xffffe9d2L), FLAG_FAIL_X87 },
	{ __LINE__, HEXCONSTE(-1.63829990234375000000e+04, 0xc00c, 0xfffbff00L, 0x00000000L), HEXCONSTE(1.68218986317177478712e-4932, 0x0000, 0x8016302fL, 0x17467628L), FLAG_FAIL_X87 },
	{ __LINE__, HEXCONSTE(-1.63830000000000000000e+04, 0xc00c, 0xfffc0000L, 0x00000000L), HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x80000000L, 0x00000000L), FLAG_FAIL_X87 },
	{ __LINE__, HEXCONSTE(-1.63829999999999981810e+04, 0xc00c, 0xfffbffffL, 0xfffff800L), HEXCONSTE(1.68105157155816626898e-4932, 0x0000, 0x80000000L, 0x00b17218L), FLAG_FAIL_X87 },
	{ __LINE__, HEXCONSTE(-1.63829999999999999991e+04, 0xc00c, 0xfffbffffL, 0xffffffffL), HEXCONSTE(1.68105157155604778800e-4932, 0x0000, 0x80000000L, 0x0000162eL), FLAG_FAIL_X87 },
#else
	{ __LINE__, HEXCONSTE(-1.63830000000000000000e+04, 0xc00c, 0xfffc0000L, 0x00000000L), HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.63830009765625000000e+04, 0xc00c, 0xfffc0100L, 0x00000000L), HEXCONSTE(1.67991405019094904552e-4932, 0x0000, 0x3ff4e9d4L, 0x703df843L), 0 },
	{ __LINE__, HEXCONSTE(-1.63830000000000018190e+04, 0xc00c, 0xfffc0000L, 0x00000800L), HEXCONSTE(1.68105157155392723728e-4932, 0x0000, 0x3fffffffL, 0xffa746f4L), 0 },
	{ __LINE__, HEXCONSTE(-1.63830000000000000009e+04, 0xc00c, 0xfffc0000L, 0x00000001L), HEXCONSTE(1.68105157155604571826e-4932, 0x0000, 0x3fffffffL, 0xfffff4e9L), 0 },
	{ __LINE__, HEXCONSTE(-1.63829990234375000000e+04, 0xc00c, 0xfffbff00L, 0x00000000L), HEXCONSTE(1.68218986317177478712e-4932, 0x0000, 0x400b1817L, 0x8ba33b14L), 0 },
	{ __LINE__, HEXCONSTE(-1.63830000000000000000e+04, 0xc00c, 0xfffc0000L, 0x00000000L), HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.63829999999999981810e+04, 0xc00c, 0xfffbffffL, 0xfffff800L), HEXCONSTE(1.68105157155816626898e-4932, 0x0000, 0x40000000L, 0x0058b90cL), 0 },
	{ __LINE__, HEXCONSTE(-1.63829999999999999991e+04, 0xc00c, 0xfffbffffL, 0xffffffffL), HEXCONSTE(1.68105157155604778800e-4932, 0x0000, 0x40000000L, 0x00000b17L), 0 },
#endif
	{ __LINE__, HEXCONSTE(1.63840000000000000000e+04, 0x400d, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(1.63839990234375000000e+04, 0x400c, 0xffffff00L, 0x00000000L), HEXCONSTE(1.18892643677509333225e+4932, 0x7ffe, 0xffd3a751L, 0xc0f7e10cL), 0 },
	{ __LINE__, HEXCONSTE(1.63839999999999981810e+04, 0x400c, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.18973149535573171904e+4932, 0x7ffe, 0xffffffffL, 0xfe9d1bd0L), 0 },
	{ __LINE__, HEXCONSTE(1.63839999999999999991e+04, 0x400c, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.18973149535723103261e+4932, 0x7ffe, 0xffffffffL, 0xffffd3a3L), 0 },
	{ __LINE__, HEXCONSTE(1.63840019531250000000e+04, 0x400d, 0x80000100L, 0x00000000L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(1.63840000000000000000e+04, 0x400d, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(1.63840000000000036380e+04, 0x400d, 0x80000000L, 0x00000800L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(1.63840000000000000018e+04, 0x400d, 0x80000000L, 0x00000001L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(-1.63820000000000000000e+04, 0xc00c, 0xfff80000L, 0x00000000L), HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), 0 },
#if __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(-1.63820009765625000000e+04, 0xc00c, 0xfff80100L, 0x00000000L), HEXCONSTE(3.35982810038189809104e-4932, 0x0000, 0xffd3a751L, 0xc0f7e10cL), FLAG_FAIL_X87 },
	{ __LINE__, HEXCONSTE(-1.63820000000000018190e+04, 0xc00c, 0xfff80000L, 0x00000800L), HEXCONSTE(3.36210314310785447457e-4932, 0x0000, 0xffffffffL, 0xfe9d1bd0L), FLAG_FAIL_X87 },
	{ __LINE__, HEXCONSTE(-1.63820000000000000009e+04, 0xc00c, 0xfff80000L, 0x00000001L), HEXCONSTE(3.36210314311209143652e-4932, 0x0000, 0xffffffffL, 0xffffd3a3L), FLAG_FAIL_X87 },
#else
	{ __LINE__, HEXCONSTE(-1.63820009765625000000e+04, 0xc00c, 0xfff80100L, 0x00000000L), HEXCONSTE(3.35982810038189809104e-4932, 0x0000, 0x7fe9d3a8L, 0xe07bf086L), 0 },
	{ __LINE__, HEXCONSTE(-1.63820000000000018190e+04, 0xc00c, 0xfff80000L, 0x00000800L), HEXCONSTE(3.36210314310785447457e-4932, 0x0000, 0x7fffffffL, 0xff4e8de8L), 0 },
	{ __LINE__, HEXCONSTE(-1.63820000000000000009e+04, 0xc00c, 0xfff80000L, 0x00000001L), HEXCONSTE(3.36210314311209143652e-4932, 0x0000, 0x7fffffffL, 0xffffe9d2L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-1.63819990234375000000e+04, 0xc00c, 0xfff7ff00L, 0x00000000L), HEXCONSTE(3.36437972634354957423e-4932, 0x0001, 0x8016302fL, 0x17467628L), 0 },
	{ __LINE__, HEXCONSTE(-1.63820000000000000000e+04, 0xc00c, 0xfff80000L, 0x00000000L), HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.63819999999999981810e+04, 0xc00c, 0xfff7ffffL, 0xfffff800L), HEXCONSTE(3.36210314311633253796e-4932, 0x0001, 0x80000000L, 0x00b17218L), 0 },
	{ __LINE__, HEXCONSTE(-1.63819999999999999991e+04, 0xc00c, 0xfff7ffffL, 0xffffffffL), HEXCONSTE(3.36210314311209557601e-4932, 0x0001, 0x80000000L, 0x0000162eL), 0 },
#endif
	{ __LINE__, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#ifdef TEST_LDOUBLE
	{ __LINE__, HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#ifdef TEST_LDOUBLE
	{ __LINE__, HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#ifdef TEST_LDOUBLE
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#ifdef TEST_LDOUBLE
	{ __LINE__, HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(7.15199708938598632812e-01, 0x3ffe, 0xb7175400L, 0x00000000L), HEXCONSTE(1.64171046007520776992e+00, 0x3fff, 0xd223917fL, 0xc316ba1bL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.38417510986328125000e+01, 0x4002, 0xdd77d000L, 0x00000000L), HEXCONSTE(1.46819003882407028394e+04, 0x400c, 0xe56799ffL, 0x5ffe1631L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(7.54436731338500976562e-01, 0x3ffe, 0xc122c400L, 0x00000000L), HEXCONSTE(1.68697282209948673515e+00, 0x3fff, 0xd7eeb9b6L, 0x143d5400L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-1.33784151077270507812e+00, 0xbfff, 0xab3e6400L, 0x00000000L), HEXCONSTE(3.95612108712255675390e-01, 0x3ffd, 0xca8dab99L, 0xa4375a0bL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-1.73335969448089599609e+00, 0xbfff, 0xdddebb00L, 0x00000000L), HEXCONSTE(3.00750763605720910230e-01, 0x3ffd, 0x99fc010bL, 0xde009a48L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-3.04273406982421875000e+02, 0xc007, 0x9822ff00L, 0x00000000L), HEXCONSTE(2.53850261671860504029e-92, 0x3ece, 0xd3ce1638L, 0x8003d33aL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.05301618576049804688e+01, 0x4002, 0xa87b8b00L, 0x00000000L), HEXCONSTE(1.47874938949252782949e+03, 0x4009, 0xb8d7faffL, 0xac4bf024L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-8.85962069034576416016e-01, 0xbffe, 0xe2ce6900L, 0x00000000L), HEXCONSTE(5.41126549235311420181e-01, 0x3ffe, 0x8a8744ffL, 0xf686ede8L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-1.84770935447886586189e-04, 0xbff2, 0xc1bf1200L, 0x00000000L), HEXCONSTE(9.99871934748099433499e-01, 0x3ffe, 0xfff79b6bL, 0xee6bd800L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-2.84401386976242065430e-01, 0xbffd, 0x919d0f00L, 0x00000000L), HEXCONSTE(8.21082227267288189410e-01, 0x3ffe, 0xd23271e1L, 0x70998000L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(9.73588526248931884766e-01, 0x3ffe, 0xf93d1900L, 0x00000000L), HEXCONSTE(1.96371903467015826536e+00, 0x3fff, 0xfb5b2534L, 0x38735709L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(9.73588466644287109375e-01, 0x3ffe, 0xf93d1800L, 0x00000000L), HEXCONSTE(1.96371895353951750969e+00, 0x3fff, 0xfb5b2485L, 0xfe68bb3bL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(9.73588511227635122758e-01, 0x3ffe, 0xf93d18bfL, 0x7be8d800L), HEXCONSTE(1.96371901422397567840e+00, 0x3fff, 0xfb5b2508L, 0x500af4ccL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(9.73588511227635011736e-01, 0x3ffe, 0xf93d18bfL, 0x7be8d000L), HEXCONSTE(1.96371901422397552727e+00, 0x3fff, 0xfb5b2508L, 0x500aef5aL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(9.73588511227635045671e-01, 0x3ffe, 0xf93d18bfL, 0x7be8d272L), HEXCONSTE(1.96371901422397557345e+00, 0x3fff, 0xfb5b2508L, 0x500af104L), FLAG_INEXACT2 },
};

int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_f_f(ftwotox_data, ARRAY_SIZE(ftwotox_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

#else

int main(void)
{
	return 77;
}

#endif

```

`tests/expm1.c`:

```c
#include "testconfig.h"
#define TEST_FUNC_F_F __MATH_PRECNAME(expm1)
#include "testdriver.h"



static test_f_f_data const fetoxm1_data[] = {
	{ __LINE__, ZERO_P, ZERO_P, 0 },
	{ __LINE__, ZERO_M, ZERO_M, FLAG_FAIL_ARANYM2 },
	{ __LINE__, INF_P, INF_P, 0 },
	{ __LINE__, INF_M, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_P, 0 },
	{ __LINE__, SNAN_P, QNAN_P, 0 },
	{ __LINE__, SNAN_M, QNAN_P, 0 },

	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.71828182845904523532e+00, 0x3fff, 0xdbf0a8b1L, 0x45769535L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(7.50000000000000000000e-01, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(1.11700001661267466857e+00, 0x3fff, 0x8ef9db46L, 0x7dcf7bd5L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(6.38905609893065022740e+00, 0x4001, 0xcc7325c6L, 0xa6ed6e62L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(3.00000000000000000000e+00, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(1.90855369231876677415e+01, 0x4003, 0x98af2dfbL, 0x7d882f97L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(4.00000000000000000000e+00, 0x4001, 0x80000000L, 0x00000000L), HEXCONSTE(5.35981500331442390767e+01, 0x4004, 0xd6648171L, 0x39d2c33cL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(5.00000000000000000000e+00, 0x4001, 0xa0000000L, 0x00000000L), HEXCONSTE(1.47413159102576603418e+02, 0x4006, 0x9369c4cbL, 0x819c78fbL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+01, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(2.20254657948067165165e+04, 0x400d, 0xac12ee7cL, 0xa82afcf8L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.50000000000000000000e+01, 0x4002, 0xf0000000L, 0x00000000L), HEXCONSTE(3.26901637247211063936e+06, 0x4014, 0xc786617dL, 0x69543779L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.00000000000000000000e+01, 0x4003, 0xa0000000L, 0x00000000L), HEXCONSTE(4.85165194409790277976e+08, 0x401b, 0xe7584453L, 0x47402011L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.50000000000000000000e+01, 0x4003, 0xc8000000L, 0x00000000L), HEXCONSTE(7.20048993363858725205e+10, 0x4023, 0x861e9c90L, 0x43164455L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(3.00000000000000000000e+01, 0x4003, 0xf0000000L, 0x00000000L), HEXCONSTE(1.06864745815234621468e+13, 0x402a, 0x9b823857L, 0x613764f4L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(3.50000000000000000000e+01, 0x4004, 0x8c000000L, 0x00000000L), HEXCONSTE(1.58601345231342972815e+15, 0x4031, 0xb44f110dL, 0xe46ab74dL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(4.00000000000000000000e+01, 0x4004, 0xa0000000L, 0x00000000L), HEXCONSTE(2.35385266837019984406e+17, 0x4038, 0xd11069cbL, 0xcb97541aL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(5.00000000000000000000e+01, 0x4004, 0xc8000000L, 0x00000000L), HEXCONSTE(5.18470552858707246387e+21, 0x4047, 0x8c881f20L, 0x405a2b32L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(6.00000000000000000000e+01, 0x4004, 0xf0000000L, 0x00000000L), HEXCONSTE(1.14200738981568428370e+26, 0x4055, 0xbcede4eeL, 0x29e3324aL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(7.00000000000000000000e+01, 0x4005, 0x8c000000L, 0x00000000L), HEXCONSTE(2.51543867091916700623e+30, 0x4063, 0xfdfe90ceL, 0x21d82398L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(8.00000000000000000000e+01, 0x4005, 0xa0000000L, 0x00000000L), HEXCONSTE(5.54062238439351005243e+34, 0x4072, 0xaabbcdccL, 0x279f59e4L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(9.00000000000000000000e+01, 0x4005, 0xb4000000L, 0x00000000L), HEXCONSTE(1.22040329431784080201e+39, 0x4080, 0xe58847fdL, 0xf60b1e4cL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+02, 0x4005, 0xc8000000L, 0x00000000L), HEXCONSTE(2.68811714181613544840e+43, 0x408f, 0x9a4a54d8L, 0xb8dfa566L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.27000000000000000000e+02, 0x4005, 0xfe000000L, 0x00000000L), HEXCONSTE(1.43020799583481044630e+55, 0x40b6, 0x95521837L, 0x49160e8bL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(5.00000000000000000000e+02, 0x4007, 0xfa000000L, 0x00000000L), HEXCONSTE(1.40359221785283741074e+217, 0x42d0, 0xa2dd154fL, 0xbf21c4a4L), FLAG_INEXACT2 },
#if defined(TEST_LDOUBLE) && LDBL_MAX_EXP > 1024
	{ __LINE__, HEXCONSTE(1.13562500000000000000e+04, 0x400c, 0xb1710000L, 0x00000000L), HEXCONSTE(9.05128237311923300076e+4931, 0x7ffe, 0xc2c2b72bL, 0xac3ba40dL), FLAG_INEXACT4 },
#endif
	{ __LINE__, HEXCONSTE(-1.00000000000000000000e+01, 0xc002, 0xa0000000L, 0x00000000L), HEXCONSTE(-9.99954600070237515166e-01, 0xbffe, 0xfffd0650L, 0xc953706dL), 0 },
	{ __LINE__, HEXCONSTE(-1.60000000000000000000e+01, 0xc003, 0x80000000L, 0x00000000L), HEXCONSTE(-9.99999887464825280761e-01, 0xbffe, 0xfffffe1cL, 0xaa445118L), 0 },
	{ __LINE__, HEXCONSTE(-1.70000000000000000000e+01, 0xc003, 0x88000000L, 0x00000000L), HEXCONSTE(-9.99999958600622812163e-01, 0xbffe, 0xffffff4eL, 0x30e7452dL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.80000000000000000000e+01, 0xc003, 0x90000000L, 0x00000000L), HEXCONSTE(-9.99999984770020255314e-01, 0xbffe, 0xffffffbeL, 0x9675ce5aL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-3.60000000000000000000e+01, 0xc004, 0x90000000L, 0x00000000L), HEXCONSTE(-9.99999999999999768035e-01, 0xbffe, 0xffffffffL, 0xffffef49L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-3.70000000000000000000e+01, 0xc004, 0x94000000L, 0x00000000L), HEXCONSTE(-9.99999999999999914673e-01, 0xbffe, 0xffffffffL, 0xfffff9daL), 0 },
	{ __LINE__, HEXCONSTE(-3.80000000000000000000e+01, 0xc004, 0x98000000L, 0x00000000L), HEXCONSTE(-9.99999999999999968612e-01, 0xbffe, 0xffffffffL, 0xfffffdbdL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-4.40000000000000000000e+01, 0xc004, 0xb0000000L, 0x00000000L), HEXCONSTE(-9.99999999999999999946e-01, 0xbffe, 0xffffffffL, 0xffffffffL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-4.50000000000000000000e+01, 0xc004, 0xb4000000L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+00, 0xbffe, 0xffffffffL, 0xffffffffL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-4.60000000000000000000e+01, 0xc004, 0xb8000000L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-7.30000000000000000000e+01, 0xc005, 0x92000000L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-7.40000000000000000000e+01, 0xc005, 0x94000000L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-7.50000000000000000000e+01, 0xc005, 0x96000000L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-7.80000000000000000000e+01, 0xc005, 0x9c000000L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-7.90000000000000000000e+01, 0xc005, 0x9e000000L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-8.00000000000000000000e+01, 0xc005, 0xa0000000L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.00000000000000000000e+02, 0xc005, 0xc8000000L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.00000000000000000000e+03, 0xc008, 0xfa000000L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.00000000000000000000e+04, 0xc00c, 0x9c400000L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.00000000000000000000e+05, 0xc00f, 0xc3500000L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+05, 0x400f, 0xc3500000L, 0x00000000L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), INF_P, 0 },
	{ __LINE__, HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.50000000000000000000e-01, 0x3ffd, 0x80000000L, 0x00000000L), HEXCONSTE(2.84025416687741484074e-01, 0x3ffd, 0x916bc787L, 0xd030ccedL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-2.50000000000000000000e-01, 0xbffd, 0x80000000L, 0x00000000L), HEXCONSTE(-2.21199216928595131755e-01, 0xbffc, 0xe2820c2aL, 0x6fbea2f3L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(9.76562500000000000000e-04, 0x3ff5, 0x80000000L, 0x00000000L), HEXCONSTE(9.77039492416535242833e-04, 0x3ff5, 0x80100155L, 0x6aabbbc7L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-9.76562500000000000000e-04, 0xbff5, 0x80000000L, 0x00000000L), HEXCONSTE(-9.76085818024337765268e-04, 0xbff4, 0xffe002aaL, 0x8002220bL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(9.53674316406250000000e-07, 0x3feb, 0x80000000L, 0x00000000L), HEXCONSTE(9.53674771153745446823e-07, 0x3feb, 0x80000400L, 0x00155556L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-9.53674316406250000000e-07, 0xbfeb, 0x80000000L, 0x00000000L), HEXCONSTE(-9.53673861659043673791e-07, 0xbfea, 0xfffff800L, 0x002aaaaaL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(1.86264514923095703125e-09, 0x3fe2, 0x80000000L, 0x00000000L), HEXCONSTE(1.86264515096568050824e-09, 0x3fe2, 0x80000002L, 0x00000005L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-1.86264514923095703125e-09, 0xbfe2, 0x80000000L, 0x00000000L), HEXCONSTE(-1.86264514749623355638e-09, 0xbfe1, 0xfffffffcL, 0x0000000bL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(2.32830643653869628906e-10, 0x3fdf, 0x80000000L, 0x00000000L), HEXCONSTE(2.32830643680974683218e-10, 0x3fdf, 0x80000000L, 0x40000000L), 0 },
	{ __LINE__, HEXCONSTE(-2.32830643653869628906e-10, 0xbfdf, 0x80000000L, 0x00000000L), HEXCONSTE(-2.32830643626764574594e-10, 0xbfde, 0xffffffffL, 0x80000000L), 0 },
	{ __LINE__, HEXCONSTE(8.88178419700125232339e-16, 0x3fcd, 0x80000000L, 0x00000000L), HEXCONSTE(8.88178419700125626769e-16, 0x3fcd, 0x80000000L, 0x00001000L), 0 },
	{ __LINE__, HEXCONSTE(-8.88178419700125232339e-16, 0xbfcd, 0x80000000L, 0x00000000L), HEXCONSTE(-8.88178419700124837908e-16, 0xbfcc, 0xffffffffL, 0xffffe000L), 0 },
	{ __LINE__, HEXCONSTE(5.42101086242752217004e-20, 0x3fbf, 0x80000000L, 0x00000000L), HEXCONSTE(5.42101086242752217004e-20, 0x3fbf, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-5.42101086242752217004e-20, 0xbfbf, 0x80000000L, 0x00000000L), HEXCONSTE(-5.42101086242752217004e-20, 0xbfbe, 0xffffffffL, 0xffffffffL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(7.88860905221011805412e-31, 0x3f9b, 0x80000000L, 0x00000000L), HEXCONSTE(7.88860905221011805412e-31, 0x3f9b, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-7.88860905221011805412e-31, 0xbf9b, 0x80000000L, 0x00000000L), HEXCONSTE(-7.88860905221011805412e-31, 0xbf9b, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.40991986510288411774e-181, 0x3da7, 0x80000000L, 0x00000000L), HEXCONSTE(2.40991986510288411774e-181, 0x3da7, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-2.40991986510288411774e-181, 0xbda7, 0x80000000L, 0x00000000L), HEXCONSTE(-2.40991986510288411774e-181, 0xbda7, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(5.01237274920645200930e-3011, 0x18ef, 0x80000000L, 0x00000000L), HEXCONSTE(5.01237274920645200930e-3011, 0x18ef, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-5.01237274920645200930e-3011, 0x98ef, 0x80000000L, 0x00000000L), HEXCONSTE(-5.01237274920645200930e-3011, 0x98ef, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.23643872580741754047e-17, 0x3fc6, 0xe4152b00L, 0x00000000L), HEXCONSTE(1.23643872580741754814e-17, 0x3fc6, 0xe4152b00L, 0x00000066L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(1.23643864308935628516e-17, 0x3fc6, 0xe4152a00L, 0x00000000L), HEXCONSTE(1.23643864308935629284e-17, 0x3fc6, 0xe4152a00L, 0x00000066L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(1.23643870690103443592e-17, 0x3fc6, 0xe4152ac5L, 0x7cd1f000L), HEXCONSTE(1.23643870690103444359e-17, 0x3fc6, 0xe4152ac5L, 0x7cd1f066L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(1.23643870690103428184e-17, 0x3fc6, 0xe4152ac5L, 0x7cd1e800L), HEXCONSTE(1.23643870690103428952e-17, 0x3fc6, 0xe4152ac5L, 0x7cd1e866L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(1.23643870690103432954e-17, 0x3fc6, 0xe4152ac5L, 0x7cd1ea7aL), HEXCONSTE(1.23643870690103433721e-17, 0x3fc6, 0xe4152ac5L, 0x7cd1eae0L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(3.99904519319534301758e-01, 0x3ffd, 0xccc04900L, 0x00000000L), HEXCONSTE(4.91682264003942510165e-01, 0x3ffd, 0xfbbdc717L, 0xd720aa7aL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(3.99904489517211914062e-01, 0x3ffd, 0xccc04800L, 0x00000000L), HEXCONSTE(4.91682219548347440748e-01, 0x3ffd, 0xfbbdc599L, 0xf83d7e06L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(3.99904516648060037731e-01, 0x3ffd, 0xccc048e9L, 0x0d5db000L), HEXCONSTE(4.91682260018951737090e-01, 0x3ffd, 0xfbbdc6f5L, 0x9c0a4bbcL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(3.84912937879562377930e-01, 0x3ffd, 0xc5134f00L, 0x00000000L), HEXCONSTE(4.69486379271633239019e-01, 0x3ffd, 0xf06084c9L, 0xc73a5a00L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(3.81665438413619995117e-01, 0x3ffd, 0xc369a700L, 0x00000000L), HEXCONSTE(4.64721963445890885611e-01, 0x3ffd, 0xedf00985L, 0x774cee95L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(3.81665408611297607422e-01, 0x3ffd, 0xc369a600L, 0x00000000L), HEXCONSTE(4.64721919793775373116e-01, 0x3ffd, 0xedf0080eL, 0x7f488997L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(3.81665414231567357017e-01, 0x3ffd, 0xc369a630L, 0x471a9800L), HEXCONSTE(4.64721928025907693633e-01, 0x3ffd, 0xedf00855L, 0x35ef0b3aL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(3.81665414231567301506e-01, 0x3ffd, 0xc369a630L, 0x471a9000L), HEXCONSTE(4.64721928025907612318e-01, 0x3ffd, 0xedf00855L, 0x35eeff82L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(3.81665414231567331566e-01, 0x3ffd, 0xc369a630L, 0x471a9455L), HEXCONSTE(4.64721928025907656364e-01, 0x3ffd, 0xedf00855L, 0x35ef05dbL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(3.73914510011672973633e-01, 0x3ffd, 0xbf71b900L, 0x00000000L), HEXCONSTE(4.53412892894291496610e-01, 0x3ffd, 0xe825bc15L, 0x21a7b987L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(3.73914480209350585938e-01, 0x3ffd, 0xbf71b800L, 0x00000000L), HEXCONSTE(4.53412849579212545590e-01, 0x3ffd, 0xe825baa1L, 0x0eca0bfbL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(3.73914503704421197217e-01, 0x3ffd, 0xbf71b8c9L, 0xd234e800L), HEXCONSTE(4.53412883727250474964e-01, 0x3ffd, 0xe825bbc6L, 0x631e6898L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(2.15667054057121276855e-01, 0x3ffc, 0xdcd7d300L, 0x00000000L), HEXCONSTE(2.40689227781214067612e-01, 0x3ffc, 0xf6773ca7L, 0x477c06f4L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(2.15667039155960083008e-01, 0x3ffc, 0xdcd7d200L, 0x00000000L), HEXCONSTE(2.40689209293504030707e-01, 0x3ffc, 0xf6773b69L, 0xa9ad04d5L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.15667044690144610319e-01, 0x3ffc, 0xdcd7d25fL, 0x1399d800L), HEXCONSTE(2.40689216159707074989e-01, 0x3ffc, 0xf6773bdfL, 0x9f8e6305L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.15667044690144582564e-01, 0x3ffc, 0xdcd7d25fL, 0x1399d000L), HEXCONSTE(2.40689216159707040552e-01, 0x3ffc, 0xf6773bdfL, 0x9f8e5918L), 0 },
	{ __LINE__, HEXCONSTE(2.15667044690144599355e-01, 0x3ffc, 0xdcd7d25fL, 0x1399d4d7L), HEXCONSTE(2.40689216159707061382e-01, 0x3ffc, 0xf6773bdfL, 0x9f8e5f19L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.83894395828247070312e+00, 0xc001, 0xfad8a100L, 0x00000000L), HEXCONSTE(-9.99605915008823195085e-01, 0xbffe, 0xffe62c59L, 0xd9de7d61L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-7.83894443511962890625e+00, 0xc001, 0xfad8a200L, 0x00000000L), HEXCONSTE(-9.99605915196737517588e-01, 0xbffe, 0xffe62c5aL, 0xa87bab58L), 0 },
	{ __LINE__, HEXCONSTE(-7.83894415353756901510e+00, 0xc001, 0xfad8a168L, 0xd3a80800L), HEXCONSTE(-9.99605915085770291295e-01, 0xbffe, 0xffe62c5aL, 0x2e792c00L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(7.23432388305664062500e+01, 0x4005, 0x90afbd00L, 0x00000000L), HEXCONSTE(2.61980777759408685416e+31, 0x4067, 0xa5554702L, 0xde7b884cL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(3.67167860269546508789e-01, 0x3ffd, 0xbbfd6d00L, 0x00000000L), HEXCONSTE(4.43640228615443474764e-01, 0x3ffd, 0xe324cfe2L, 0x2fc41c77L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.36210314311209350809e-4932, 0x0001, 0x80000000L, 0x00000005L), HEXCONSTE(3.36210314311209350809e-4932, 0x0001, 0x80000000L, 0x00000005L), 0 },
	{ __LINE__, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), 0 },
#if defined(TEST_LDOUBLE) && LDBL_MAX_EXP > 1024
	{ __LINE__, HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), 0 },
#if defined(TEST_LDOUBLE) && LDBL_MAX_EXP > 1024
	{ __LINE__, HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), 0 },
#if defined(TEST_LDOUBLE) && LDBL_MAX_EXP > 1024
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), 0 },
#if defined(TEST_LDOUBLE) && LDBL_MAX_EXP > 1024
	{ __LINE__, HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), 0 },
#endif

	{ __LINE__, HEXCONSTE(0.75L, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(1.11700001661267466854536981983709561L, 0x3fff, 0x8ef9db46L, 0x7dcf7bd5L), FLAG_INEXACT },
#ifndef TEST_FLOAT
	{ __LINE__, HEXCONSTE(127.0L, 0x4005, 0xfe000000L, 0x00000000L), HEXCONSTE(1.4302079958348104463583671072905261080748e+55L, 0x40b6, 0x95521837L, 0x49160e8bL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(500.0L, 0x4007, 0xfa000000L, 0x00000000L), HEXCONSTE(1.4035922178528374107397703328409120821806e+217L, 0x42d0, 0xa2dd154fL, 0xbf21c4a4L), FLAG_INEXACT },
#endif

#ifdef TEST_FLOAT
	{ __LINE__, HEXCONSTE(8.87216949462890625000e+01, 0x4005, 0xb1718200L, 0x00000000L), HEXCONSTE(3.39893250265297041415e+038, 0x407e, 0xffb50f11L, 0x531ff167L), 0 },
	{ __LINE__, HEXCONSTE(8.87228393554687500000e+01, 0x4005, 0xb1721800L, 0x00000000L), INF_P, OVERFLOW_EXCEPTION|ERRNO_ERANGE },
#endif
	
	{ __LINE__, HEXCONSTE(-10.0, 0xc002, 0xa0000000L, 0x00000000L), HEXCONSTE(-0.9999546000702375151484644084844394493898L, 0xbffe, 0xfffd0650L, 0xc953706dL), 0 },
	{ __LINE__, HEXCONSTE(-16.0, 0xc003, 0x80000000L, 0x00000000L), HEXCONSTE(-0.9999998874648252807408854862248209398728L, 0xbffe, 0xfffffe1cL, 0xaa445118L), 0 },
	{ __LINE__, HEXCONSTE(-17.0, 0xc003, 0x88000000L, 0x00000000L), HEXCONSTE(-0.9999999586006228121483334034897228104472L, 0xbffe, 0xffffff4eL, 0x30e7452dL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-18.0, 0xc003, 0x90000000L, 0x00000000L), HEXCONSTE(-0.9999999847700202552873715638633707664826L, 0xbffe, 0xffffffbeL, 0x9675ce5aL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-36.0, 0xc004, 0x90000000L, 0x00000000L), HEXCONSTE(-0.9999999999999997680477169756430611687736L, 0xbffe, 0xffffffffL, 0xffffef49L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-37.0, 0xc004, 0x94000000L, 0x00000000L), HEXCONSTE(-0.9999999999999999146695237425593420572195L, 0xbffe, 0xffffffffL, 0xfffff9daL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-38.0, 0xc004, 0x98000000L, 0x00000000L), HEXCONSTE(-0.9999999999999999686086720795197037129104L, 0xbffe, 0xffffffffL, 0xfffffdbdL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-44.0, 0xc004, 0xb0000000L, 0x00000000L), HEXCONSTE(-0.9999999999999999999221886775886620348429L, 0xbffe, 0xffffffffL, 0xffffffffL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-45.0, 0xc004, 0xb4000000L, 0x00000000L), HEXCONSTE(-0.9999999999999999999713748141945060635553L, 0xbffe, 0xffffffffL, 0xffffffffL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-46.0, 0xc004, 0xb8000000L, 0x00000000L), HEXCONSTE(-0.9999999999999999999894693826424461876212L, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-73.0, 0xc005, 0x92000000L, 0x00000000L), HEXCONSTE(-0.9999999999999999999999999999999802074012L, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-74.0, 0xc005, 0x94000000L, 0x00000000L), HEXCONSTE(-0.9999999999999999999999999999999927187098L, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-75.0, 0xc005, 0x96000000L, 0x00000000L), HEXCONSTE(-0.9999999999999999999999999999999973213630L, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-78.0, 0xc005, 0x9c000000L, 0x00000000L), HEXCONSTE(-0.9999999999999999999999999999999998666385L, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-79.0, 0xc005, 0x9e000000L, 0x00000000L), HEXCONSTE(-0.9999999999999999999999999999999999509391L, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-80.0, 0xc005, 0xa0000000L, 0x00000000L), HEXCONSTE(-0.9999999999999999999999999999999999819515L, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-100.0, 0xc005, 0xc8000000L, 0x00000000L), HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1000.0, 0xc008, 0xfa000000L, 0x00000000L), HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-10000.0, 0xc00c, 0x9c400000L, 0x00000000L), HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-100000.0, 0xc00f, 0xc3500000L, 0x00000000L), HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), 0 },

};

int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_f_f(fetoxm1_data, ARRAY_SIZE(fetoxm1_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

```

`tests/fabs.c`:

```c
#include "testconfig.h"
#define TEST_FUNC_F_F __MATH_PRECNAME(fabs)
#include "testdriver.h"



static test_f_f_data const fabs_data[] = {
	{ __LINE__, ZERO_P, ZERO_P, 0 },
	{ __LINE__, ZERO_M, ZERO_P, 0 },
	{ __LINE__, INF_P, INF_P, 0 },
	{ __LINE__, INF_M, INF_P, 0 },
	{ __LINE__, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_P, 0 },
	{ __LINE__, SNAN_P, QNAN_P, 0 },
	{ __LINE__, SNAN_M, QNAN_P, 0 },
	{ __LINE__, SUBNORM_P, SUBNORM_P, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, SUBNORM_P, FLAG_SUBNORM },
	{ __LINE__, MIN_M, MIN_P, 0 },
	{ __LINE__, MIN_P, MIN_P, 0 },
	{ __LINE__, MAX_M, MAX_P, 0 },
	{ __LINE__, MAX_P, MAX_P, 0 },

	{ __LINE__, HEXCONSTE(38.0, 0x4004, 0x98000000L, 0x00000000L), HEXCONSTE(38.0, 0x4004, 0x98000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE("2.718281828459045235360287471352662498", 0x4000, 0xadf85458L, 0xa2bb4a9aL), HEXCONSTE("2.718281828459045235360287471352662498", 0x4000, 0xadf85458L, 0xa2bb4a9aL), 0 },
	{ __LINE__, HEXCONSTE("-2.718281828459045235360287471352662498", 0xc000, 0xadf85458L, 0xa2bb4a9aL), HEXCONSTE("2.718281828459045235360287471352662498", 0x4000, 0xadf85458L, 0xa2bb4a9aL), 0 },
	{ __LINE__, HEXCONSTE(-55, 0xc004, 0xdc000000L, 0x00000000L), HEXCONSTE(55, 0x4004, 0xdc000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1024, 0xc009, 0x80000000L, 0x00000000L), HEXCONSTE(1024, 0x4009, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.2345, 0x3fff, 0x9e041893L, 0x74bc6a7fL), HEXCONSTE(1.2345, 0x3fff, 0x9e041893L, 0x74bc6a7fL), 0 },
	{ __LINE__, HEXCONSTE(-1.2345, 0xbfff, 0x9e041893L, 0x74bc6a7fL), HEXCONSTE(1.2345, 0x3fff, 0x9e041893L, 0x74bc6a7fL), 0 },
	{ __LINE__, HEXCONSTE(1.2345e+20, 0x4041, 0xd626d01dL, 0xe23f2000L), HEXCONSTE(1.2345e+20, 0x4041, 0xd626d01dL, 0xe23f2000L), 0 },
	{ __LINE__, HEXCONSTE(-9.987e+25, 0xc055, 0xa5389718L, 0xbb9cafaeL), HEXCONSTE(9.987e+25, 0x4055, 0xa5389718L, 0xbb9cafaeL), 0 },
	{ __LINE__, HEXCONSTE(-7.89e-24, 0xbfb2, 0x989d633cL, 0x5d6fc7a1L), HEXCONSTE(7.89e-24, 0x3fb2, 0x989d633cL, 0x5d6fc7a1L), 0 },
	{ __LINE__, HEXCONSTE(5.67e-15, 0x3fcf, 0xcc4884faL, 0x9b8365a7L), HEXCONSTE(5.67e-15, 0x3fcf, 0xcc4884faL, 0x9b8365a7L), 0 },
};

int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_f_f(fabs_data, ARRAY_SIZE(fabs_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

```

`tests/fadd.c`:

```c
#include "testconfig.h"
#define TEST_FUNC_FF_F __MATH_PRECNAME(wrap_add)
static REAL TEST_FUNC_FF_F(REAL x, REAL y)
{
	return x + y;
}
#include "testdriver.h"


static test_ff_f_data const fadd_data[] = {
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L),  HEXCONSTE(3.0, 0x4000, 0xc0000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-2.0, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-2.0, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(-3.0, 0xc000, 0xc0000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), ZERO_P, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), ZERO_M, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), ZERO_P, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), ZERO_M, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), INF_P, INF_P, 0 },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), INF_M, INF_M, 0 },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), INF_P, INF_P, 0 },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), INF_M, INF_M, 0 },
	{ __LINE__, ZERO_P, HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L),  HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, ZERO_P, HEXCONSTE(-2.0, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(-2.0, 0xc000, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, ZERO_M, HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, ZERO_M, HEXCONSTE(-2.0, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(-2.0, 0xc000, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, ZERO_P, ZERO_P, ZERO_P, 0 },
	{ __LINE__, ZERO_P, ZERO_M, ZERO_P, 0 },
	{ __LINE__, ZERO_M, ZERO_P, ZERO_P, 0 },
	{ __LINE__, ZERO_M, ZERO_M, ZERO_M, FLAG_FAIL_ARANYM2 },
	{ __LINE__, ZERO_P, INF_P, INF_P, 0 },
	{ __LINE__, ZERO_P, INF_M, INF_M, 0 },
	{ __LINE__, ZERO_M, INF_P, INF_P, 0 },
	{ __LINE__, ZERO_M, INF_M, INF_M, 0 },
	{ __LINE__, INF_P, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__, INF_P, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__, INF_M, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), INF_M, 0 },
	{ __LINE__, INF_M, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), INF_M, 0 },
	{ __LINE__, INF_P, ZERO_P, INF_P, 0 },
	{ __LINE__, INF_P, ZERO_M, INF_P, 0 },
	{ __LINE__, INF_M, ZERO_P, INF_M, 0 },
	{ __LINE__, INF_M, ZERO_M, INF_M, 0 },
	{ __LINE__, INF_P, INF_P, INF_P, 0 },
	{ __LINE__, INF_P, INF_M, QNAN_P, 0 },
	{ __LINE__, INF_M, INF_P, QNAN_P, 0 },
	{ __LINE__, INF_M, INF_M, INF_M, 0 },
	
	{ __LINE__, ZERO_P, QNAN_P, QNAN_P, 0 },
	{ __LINE__, ZERO_P, QNAN_M, QNAN_P, 0 },
	{ __LINE__, ZERO_M, QNAN_P, QNAN_P, 0 },
	{ __LINE__, ZERO_M, QNAN_M, QNAN_P, 0 },
	{ __LINE__, INF_P, QNAN_P, QNAN_P, 0 },
	{ __LINE__, INF_P, QNAN_M, QNAN_M, 0 },
	{ __LINE__, INF_M, QNAN_P, QNAN_M, 0 },
	{ __LINE__, INF_M, QNAN_M, QNAN_P, 0 },
	{ __LINE__, QNAN_P, ZERO_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, ZERO_P, QNAN_P, 0 },
	{ __LINE__, QNAN_P, ZERO_M, QNAN_P, 0 },
	{ __LINE__, QNAN_M, ZERO_M, QNAN_P, 0 },
	{ __LINE__, QNAN_P, INF_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, INF_P, QNAN_M, 0 },
	{ __LINE__, QNAN_P, INF_M, QNAN_M, 0 },
	{ __LINE__, QNAN_M, INF_M, QNAN_P, 0 },
	{ __LINE__, QNAN_P, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_P, QNAN_M, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_M, QNAN_P, 0 },
	{ __LINE__, QNAN_P, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_P, QNAN_M, 0 },
	{ __LINE__, QNAN_P, QNAN_M, QNAN_M, 0 },
	{ __LINE__, QNAN_M, QNAN_M, QNAN_P, 0 },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), QNAN_P, QNAN_P, 0 },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), QNAN_M, QNAN_P, 0 },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), QNAN_P, QNAN_P, 0 },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), QNAN_M, QNAN_P, 0 },
	{ __LINE__, QNAN_P, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__, QNAN_M, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__, QNAN_P, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__, QNAN_M, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), QNAN_P, 0 },

	{ __LINE__, HEXCONST_PI, HEXCONSTE(3.0, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(6.141592653589793238462643383279502884, 0x4001, 0xc487ed51L, 0x10b4611aL), 0 },
	{ __LINE__, HEXCONSTE("0x1p16382", 0x7ffd, 0x80000000L, 0x0L), HEXCONSTE("0x1p16382", 0x7ffd, 0x80000000L, 0x0L), HEXCONSTE("0x1p16383", 0x7ffe, 0x80000000L, 0x0L), 0 },
	{ __LINE__, HEXCONSTE("0x1p16383", 0x7ffe, 0x80000000L, 0x0L), HEXCONSTE("0x1p16383", 0x7ffe, 0x80000000L, 0x0L), INF_P, 0 },
};


int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_ff_f(fadd_data, ARRAY_SIZE(fadd_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

```

`tests/fcmp.c`:

```c
#include "testconfig.h"
#if defined(HAVE_ISLESS) && defined(HAVE_ISLESSGREATER) && defined(HAVE_ISUNORDERED)
#define TEST_FUNC_I_FF __MATH_PRECNAME(wrap_fcmp)
#define NO_PRINTF_DOUBLE
static uint32_t TEST_FUNC_I_FF(REAL x, REAL y)
{
	uint32_t cc = 0;
	
	if (isless(x, y))
		cc |= FPSR_CCB_NEGATIVE;
	if (!islessgreater(x, y))
		cc |= FPSR_CCB_ZERO;
	if (isunordered(x, y))
		cc |= FPSR_CCB_NAN;
	return cc;
}
#include "testdriver.h"



typedef struct { int line; union ld_union x; union ld_union y; uint32_t cc; flag_t flags; } test_i_ff_data;

#define TEST_OP_BODY_I_FF(_x, _y) fp0 = _x; cc = TEST_FUNC_I_FF(fp0.x, _y.x)


static int test_table_i_ff(const test_i_ff_data *data, size_t n, const char *file)
{
	size_t l;
	int i;
	int status = 0, this_fail;
	union ld_union fp0;
	uint32_t cc;
	
	for (l = 0; l < n; l++)
	{
		numtests++;
		if (!SKIP_TEST(data[l].x, data[l].flags) && !SKIP_TEST(data[l].y, data[l].flags))
		{
			if (testonly == 0 || testonly == numtests)
			{
				for (i = 0; i < jit_loops; i++)
				{
					TEST_OP_BODY_I_FF(data[l].x, data[l].y);
					/*
					 * fcmp on '040 sets N flag if either (or both) parameters are negative nan
					 */
					if ((data[l].x.v.exponent == 0xffff && ((data[l].x.v.mantissa0 & 0x7fffffff) != 0 || data[l].x.v.mantissa1 != 0)) ||
						(data[l].y.v.exponent == 0xffff && ((data[l].y.v.mantissa0 & 0x7fffffff) != 0 || data[l].y.v.mantissa1 != 0)))
						cc &= ~FPSR_CCB_NEGATIVE;
					this_fail = data[l].cc != (cc & FPSR_CCB);
					if (this_fail)
					{
						fprintf(stderr, "%s:%d: test %d(%d): expected %c%c%c%c, got %c%c%c%c" CR "\n", file, data[l].line, numtests, i,
							data[l].cc & FPSR_CCB_NEGATIVE ? 'N' : '-',
							data[l].cc & FPSR_CCB_ZERO ? 'Z' : '-',
							data[l].cc & FPSR_CCB_INFINITY ? 'I' : '-',
							data[l].cc & FPSR_CCB_NAN ? 'U' : '-',
							cc & FPSR_CCB_NEGATIVE ? 'N' : '-',
							cc & FPSR_CCB_ZERO ? 'Z' : '-',
							cc & FPSR_CCB_INFINITY ? 'I' : '-',
							cc & FPSR_CCB_NAN ? 'U' : '-');
						status |= this_fail;
						break;
					}
				}
			}
		}
	}
	
	return status;
}



static test_i_ff_data const fcmp_data[] = {
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L),  FPSR_CCB_NEGATIVE, 0 },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-2.0, 0xc000, 0x80000000L, 0x00000000L), 0, 0 },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), FPSR_CCB_NEGATIVE, 0 },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-2.0, 0xc000, 0x80000000L, 0x00000000L), 0, 0 },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), ZERO_P, 0, 0 },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), ZERO_M, 0, 0 },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), ZERO_P, FPSR_CCB_NEGATIVE, 0 },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), ZERO_M, FPSR_CCB_NEGATIVE, 0 },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), INF_P, FPSR_CCB_NEGATIVE, 0 },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), INF_M, 0, 0 },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), INF_P, FPSR_CCB_NEGATIVE, 0 },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), INF_M, 0, 0 },
	{ __LINE__, ZERO_P, HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L),  FPSR_CCB_NEGATIVE, 0 },
	{ __LINE__, ZERO_P, HEXCONSTE(-2.0, 0xc000, 0x80000000L, 0x00000000L), 0, 0 },
	{ __LINE__, ZERO_M, HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), FPSR_CCB_NEGATIVE, 0 },
	{ __LINE__, ZERO_M, HEXCONSTE(-2.0, 0xc000, 0x80000000L, 0x00000000L), 0, 0 },
	{ __LINE__, ZERO_P, ZERO_P, FPSR_CCB_ZERO, 0 },
	{ __LINE__, ZERO_P, ZERO_M, FPSR_CCB_ZERO, 0 },
	{ __LINE__, ZERO_M, ZERO_P, FPSR_CCB_ZERO|FPSR_CCB_NEGATIVE, 0 },
	{ __LINE__, ZERO_M, ZERO_M, FPSR_CCB_ZERO|FPSR_CCB_NEGATIVE, 0 },
	{ __LINE__, ZERO_P, INF_P, FPSR_CCB_NEGATIVE, 0 },
	{ __LINE__, ZERO_P, INF_M, 0, 0 },
	{ __LINE__, ZERO_M, INF_P, FPSR_CCB_NEGATIVE, 0 },
	{ __LINE__, ZERO_M, INF_M, 0, 0 },
	{ __LINE__, INF_P, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0, 0 },
	{ __LINE__, INF_P, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), 0, 0 },
	{ __LINE__, INF_M, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), FPSR_CCB_NEGATIVE, 0 },
	{ __LINE__, INF_M, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), FPSR_CCB_NEGATIVE, 0 },
	{ __LINE__, INF_P, ZERO_P, 0, 0 },
	{ __LINE__, INF_P, ZERO_M, 0, 0 },
	{ __LINE__, INF_M, ZERO_P, FPSR_CCB_NEGATIVE, 0 },
	{ __LINE__, INF_M, ZERO_M, FPSR_CCB_NEGATIVE, 0 },
	{ __LINE__, INF_P, INF_P, FPSR_CCB_ZERO, 0 },
	{ __LINE__, INF_P, INF_M, 0, 0 },
	{ __LINE__, INF_M, INF_P, FPSR_CCB_NEGATIVE, 0 },
	{ __LINE__, INF_M, INF_M, FPSR_CCB_ZERO|FPSR_CCB_NEGATIVE, 0 },

	{ __LINE__, ZERO_P, QNAN_P, FPSR_CCB_NAN, 0 },
	{ __LINE__, ZERO_P, QNAN_M, FPSR_CCB_NAN, 0 },
	{ __LINE__, ZERO_M, QNAN_P, FPSR_CCB_NAN, 0 },
	{ __LINE__, ZERO_M, QNAN_M, FPSR_CCB_NAN, 0 },
	{ __LINE__, INF_P, QNAN_P, FPSR_CCB_NAN, 0 },
	{ __LINE__, INF_P, QNAN_M, FPSR_CCB_NAN, 0 },
	{ __LINE__, INF_M, QNAN_P, FPSR_CCB_NAN, 0 },
	{ __LINE__, INF_M, QNAN_M, FPSR_CCB_NAN, 0 },
	{ __LINE__, QNAN_P, ZERO_P, FPSR_CCB_NAN, 0 },
	{ __LINE__, QNAN_M, ZERO_P, FPSR_CCB_NAN, 0 },
	{ __LINE__, QNAN_P, ZERO_M, FPSR_CCB_NAN, 0 },
	{ __LINE__, QNAN_M, ZERO_M, FPSR_CCB_NAN, 0 },
	{ __LINE__, QNAN_P, INF_P, FPSR_CCB_NAN, 0 },
	{ __LINE__, QNAN_M, INF_P, FPSR_CCB_NAN, 0 },
	{ __LINE__, QNAN_P, INF_M, FPSR_CCB_NAN, 0 },
	{ __LINE__, QNAN_M, INF_M, FPSR_CCB_NAN, 0 },
	{ __LINE__, QNAN_P, QNAN_P, FPSR_CCB_NAN, 0 },
	{ __LINE__, QNAN_M, QNAN_P, FPSR_CCB_NAN, 0 },
	{ __LINE__, QNAN_P, QNAN_M, FPSR_CCB_NAN, 0 },
	{ __LINE__, QNAN_M, QNAN_M, FPSR_CCB_NAN, 0 },
	{ __LINE__, QNAN_P, QNAN_P, FPSR_CCB_NAN, 0 },
	{ __LINE__, QNAN_M, QNAN_P, FPSR_CCB_NAN, 0 },
	{ __LINE__, QNAN_P, QNAN_M, FPSR_CCB_NAN, 0 },
	{ __LINE__, QNAN_M, QNAN_M, FPSR_CCB_NAN, 0 },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), QNAN_P, FPSR_CCB_NAN, 0 },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), QNAN_M, FPSR_CCB_NAN, 0 },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), QNAN_P, FPSR_CCB_NAN, 0 },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), QNAN_M, FPSR_CCB_NAN, 0 },
	{ __LINE__, QNAN_P, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), FPSR_CCB_NAN, 0 },
	{ __LINE__, QNAN_M, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), FPSR_CCB_NAN, 0 },
	{ __LINE__, QNAN_P, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), FPSR_CCB_NAN, 0 },
	{ __LINE__, QNAN_M, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), FPSR_CCB_NAN, 0 },

	{ __LINE__, HEXCONST_PI, HEXCONSTE(3.0, 0x4000, 0xc0000000L, 0x00000000L), 0, 0 },
};


int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_i_ff(fcmp_data, ARRAY_SIZE(fcmp_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

#else

int main(void)
{
	return 77;
}

#endif

```

`tests/fdim.c`:

```c
#include "testconfig.h"
#ifdef HAVE_FDIM
#define TEST_FUNC_FF_F __MATH_PRECNAME(fdim)
#include "testdriver.h"


static test_ff_f_data const fdim_data[] = {
	{ __LINE__, ZERO_P, ZERO_P, ZERO_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(9, 0x4002, 0x90000000L, 0x00000000L), ZERO_P, HEXCONSTE(9, 0x4002, 0x90000000L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_P, HEXCONSTE(9, 0x4002, 0x90000000L, 0x00000000L), ZERO_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-9, 0xc002, 0x90000000L, 0x00000000L), ZERO_P, ZERO_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_P, HEXCONSTE(-9, 0xc002, 0x90000000L, 0x00000000L), HEXCONSTE(9, 0x4002, 0x90000000L, 0x00000000L), NO_INEXACT_EXCEPTION },

	{ __LINE__, ZERO_P, ZERO_P, ZERO_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_M, ZERO_M, ZERO_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_P, ZERO_M, ZERO_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_M, ZERO_P, ZERO_P, NO_INEXACT_EXCEPTION },

	{ __LINE__, INF_P, HEXCONSTE(9, 0x4002, 0x90000000L, 0x00000000L), INF_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, INF_P, HEXCONSTE(-9, 0xc002, 0x90000000L, 0x00000000L), INF_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, INF_M, HEXCONSTE(9, 0x4002, 0x90000000L, 0x00000000L), ZERO_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, INF_M, HEXCONSTE(-9, 0xc002, 0x90000000L, 0x00000000L), ZERO_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(9, 0x4002, 0x90000000L, 0x00000000L), INF_M, INF_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-9, 0xc002, 0x90000000L, 0x00000000L), INF_M, INF_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(9, 0x4002, 0x90000000L, 0x00000000L), INF_P, ZERO_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-9, 0xc002, 0x90000000L, 0x00000000L), INF_P, ZERO_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, INF_P, INF_P, ZERO_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, INF_M, INF_M, ZERO_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, INF_P, INF_M, INF_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, INF_M, INF_P, ZERO_P, NO_INEXACT_EXCEPTION },

	/* If x or y is a NaN, a NaN is returned. */
	{ __LINE__, ZERO_P, QNAN_P, QNAN_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(9, 0x4002, 0x90000000L, 0x00000000L), QNAN_P, QNAN_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-9, 0xc002, 0x90000000L, 0x00000000L), QNAN_P, QNAN_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_P, HEXCONSTE(9, 0x4002, 0x90000000L, 0x00000000L), QNAN_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_P, HEXCONSTE(-9, 0xc002, 0x90000000L, 0x00000000L), QNAN_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, INF_P, QNAN_P, QNAN_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, INF_M, QNAN_P, QNAN_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_P, INF_P, QNAN_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_P, INF_M, QNAN_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_P, QNAN_P, QNAN_P, NO_INEXACT_EXCEPTION },

	{ __LINE__, INF_P, INF_P, ZERO_P, NO_INEXACT_EXCEPTION },
};

int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_ff_f(fdim_data, ARRAY_SIZE(fdim_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

#else

int main(void)
{
	return 77;
}

#endif

```

`tests/fdiv.c`:

```c
#include "testconfig.h"
#define TEST_FUNC_FF_F __MATH_PRECNAME(wrap_div)
/* FIXME: sometimes totally bogus values in ARAnyM when inlined */
__attribute__((__noinline__))
static REAL TEST_FUNC_FF_F(REAL x, REAL y)
{
	return x / y;
}
#include "testdriver.h"



static test_ff_f_data const fdiv_data[] = {
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(0.5, 0x3ffe, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-2.0, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(-0.5, 0xbffe, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-0.5, 0xbffe, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-2.0, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(0.5, 0x3ffe, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), ZERO_P, INF_P, 0 },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), ZERO_M, INF_M, 0 },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), ZERO_P, INF_M, 0 },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), ZERO_M, INF_P, 0 },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), INF_P, ZERO_P, FLAG_IGNORE_ZEROSIGN },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), INF_M, ZERO_P, FLAG_IGNORE_ZEROSIGN },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), INF_P, ZERO_P, FLAG_IGNORE_ZEROSIGN },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), INF_M, ZERO_P, FLAG_IGNORE_ZEROSIGN },
	{ __LINE__, ZERO_P, HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), ZERO_P, 0 },
	{ __LINE__, ZERO_P, HEXCONSTE(-2.0, 0xc000, 0x80000000L, 0x00000000L), ZERO_P, FLAG_IGNORE_ZEROSIGN },
	{ __LINE__, ZERO_M, HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), ZERO_P, FLAG_IGNORE_ZEROSIGN },
	{ __LINE__, ZERO_M, HEXCONSTE(-2.0, 0xc000, 0x80000000L, 0x00000000L), ZERO_P, 0 },
	{ __LINE__, ZERO_P, ZERO_P, QNAN_P, 0 },
	{ __LINE__, ZERO_P, ZERO_M, QNAN_P, 0 },
	{ __LINE__, ZERO_M, ZERO_P, QNAN_P, 0 },
	{ __LINE__, ZERO_M, ZERO_M, QNAN_P, 0 },
	{ __LINE__, ZERO_P, INF_P, ZERO_P, 0 },
	{ __LINE__, ZERO_P, INF_M, ZERO_M, FLAG_FAIL_ARANYM2 },
	{ __LINE__, ZERO_M, INF_P, ZERO_M, FLAG_FAIL_ARANYM2 },
	{ __LINE__, ZERO_M, INF_M, ZERO_P, 0 },
	{ __LINE__, INF_P, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__, INF_P, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), INF_M, 0 },
	{ __LINE__, INF_M, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), INF_M, 0 },
	{ __LINE__, INF_M, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__, INF_P, ZERO_P, INF_P, 0 },
	{ __LINE__, INF_P, ZERO_M, INF_M, 0 },
	{ __LINE__, INF_M, ZERO_P, INF_M, 0 },
	{ __LINE__, INF_M, ZERO_M, INF_P, 0 },
	{ __LINE__, INF_P, INF_P, QNAN_P, 0 },
	{ __LINE__, INF_P, INF_M, QNAN_P, 0 },
	{ __LINE__, INF_M, INF_P, QNAN_P, 0 },
	{ __LINE__, INF_M, INF_M, QNAN_P, 0 },

	{ __LINE__, ZERO_P, QNAN_P, QNAN_P, 0 },
	{ __LINE__, ZERO_P, QNAN_M, QNAN_P, 0 },
	{ __LINE__, ZERO_M, QNAN_P, QNAN_P, 0 },
	{ __LINE__, ZERO_M, QNAN_M, QNAN_P, 0 },
	{ __LINE__, INF_P, QNAN_P, QNAN_P, 0 },
	{ __LINE__, INF_P, QNAN_M, QNAN_M, 0 },
	{ __LINE__, INF_M, QNAN_P, QNAN_M, 0 },
	{ __LINE__, INF_M, QNAN_M, QNAN_P, 0 },
	{ __LINE__, QNAN_P, ZERO_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, ZERO_P, QNAN_P, 0 },
	{ __LINE__, QNAN_P, ZERO_M, QNAN_P, 0 },
	{ __LINE__, QNAN_M, ZERO_M, QNAN_P, 0 },
	{ __LINE__, QNAN_P, INF_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, INF_P, QNAN_M, 0 },
	{ __LINE__, QNAN_P, INF_M, QNAN_M, 0 },
	{ __LINE__, QNAN_M, INF_M, QNAN_P, 0 },
	{ __LINE__, QNAN_P, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_P, QNAN_M, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_M, QNAN_P, 0 },
	{ __LINE__, QNAN_P, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_P, QNAN_M, 0 },
	{ __LINE__, QNAN_P, QNAN_M, QNAN_M, 0 },
	{ __LINE__, QNAN_M, QNAN_M, QNAN_P, 0 },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), QNAN_P, QNAN_P, 0 },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), QNAN_M, QNAN_P, 0 },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), QNAN_P, QNAN_P, 0 },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), QNAN_M, QNAN_P, 0 },
	{ __LINE__, QNAN_P, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__, QNAN_M, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__, QNAN_P, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__, QNAN_M, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), QNAN_P, 0 },

	{ __LINE__, HEXCONST_PI, HEXCONSTE(3.0, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(1.04719755119659774613e+00, 0x3fff, 0x860a91c1L, 0x6b9b2c23L), 0 },
	{ __LINE__, HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(1023, 0x4008, 0xffc00000L, 0x00000000L), HEXCONSTE(-9.77517106549364613880e-04, 0xbff5, 0x80200802L, 0x00802008L), 0 },
	{ __LINE__, HEXCONSTE(10.0, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(3.0, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(3.33333333333333333333333333333333333333, 0x4000, 0xd5555555L, 0x55555555L), FLAG_INEXACT },
};

int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);

	status |= test_table_ff_f(fdiv_data, ARRAY_SIZE(fdiv_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

```

`tests/finite.c`:

```c
#include "testconfig.h"
#if defined(HAVE_FINITE) || defined(HAVE___FINITE)
/* FIXME: that would use the function from mintlib */
#if defined(HAVE___FINITE) && 0
int __MATH_PRECNAME(__finite)(REAL x);
#define TEST_FUNC_F_I __MATH_PRECNAME(__finite)
#else
#define TEST_FUNC_F_I __MATH_PRECNAME(finite)
#endif
#include "testdriver.h"

/* make sure we don't test the builtin */
#undef finite
#undef __finite

static test_f_i_data const finite_data[] = {
	{ __LINE__, ZERO_P, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_M, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, SUBNORM_P, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, SUBNORM_M, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, INF_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, INF_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, SNAN_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, SNAN_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, MAX_P, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, MAX_M, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, MIN_P, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, MIN_M, 1, NO_INEXACT_EXCEPTION },

	{ __LINE__, HEXCONSTE(10, 0x4002, 0xa0000000L, 0x00000000L), 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-10, 0xc002, 0xa0000000L, 0x00000000L), 1, NO_INEXACT_EXCEPTION },
};

int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_f_i(finite_data, ARRAY_SIZE(finite_data), __FILE__);
	(void)check_fp;
		
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

#else

int main(void)
{
	return 77;
}

#endif

```

`tests/floor.c`:

```c
#include "testconfig.h"
#define TEST_FUNC_F_F __MATH_PRECNAME(floor)
#include "testdriver.h"



static test_f_f_data const floor_data[] = {
	{ __LINE__, ZERO_P, ZERO_P, 0 },
	{ __LINE__, ZERO_M, ZERO_M, FLAG_FAIL_ARANYM2 },
	{ __LINE__, INF_P, INF_P, 0 },
	{ __LINE__, INF_M, INF_M, 0 },
	{ __LINE__, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_P, 0 },
	{ __LINE__, SNAN_P, QNAN_P, 0 },
	{ __LINE__, SNAN_M, QNAN_P, 0 },

	{ __LINE__, HEXCONST_PI, HEXCONSTE(3.0, 0x4000, 0xc0000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONST_PI_M, HEXCONSTE(-4.0, 0xc001, 0x80000000L, 0x00000000L), 0 },

	{ __LINE__, HEXCONSTE(0.1, 0x3ffb, 0xccccccccL, 0xcccccccdL), ZERO_P, 0 },
	{ __LINE__, HEXCONSTE(0.25, 0x3ffd, 0x80000000L, 0x00000000L), ZERO_P, 0 },
	{ __LINE__, HEXCONSTE(0.625, 0x3ffe, 0xa0000000L, 0x00000000L), ZERO_P, 0 },
	{ __LINE__, HEXCONSTE(-0.1, 0xbffb, 0xccccccccL, 0xcccccccdL), HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-0.25, 0xbffd, 0x80000000L, 0x00000000L), HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-0.625, 0xbffe, 0xa0000000L, 0x00000000L), HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-0.942695, 0xbffe, 0xf15475a3L, 0x1a4bdba1L), HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	
#ifdef TEST_LDOUBLE
	/* The result can only be represented in long double.  */
	{ __LINE__, HEXCONSTE(4503599627370495.5L, 0x4032, 0xffffffffL, 0xfffff800L), HEXCONSTE(4503599627370495.0L, 0x4032, 0xffffffffL, 0xfffff000L), 0 },
	{ __LINE__, HEXCONSTE(4503599627370496.25L, 0x4033, 0x80000000L, 0x00000200L), HEXCONSTE(4503599627370496.0L, 0x4033, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4503599627370496.5L, 0x4033, 0x80000000L, 0x00000400L), HEXCONSTE(4503599627370496.0L, 0x4033, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4503599627370496.75L, 0x4033, 0x80000000L, 0x00000600L), HEXCONSTE(4503599627370496.0L, 0x4033, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4503599627370497.5L, 0x4033, 0x80000000L, 0x00000c00L), HEXCONSTE(4503599627370497.0L, 0x4033, 0x80000000L, 0x00000800L), 0 },
# if LDBL_MANT_DIG > 100
	{ __LINE__, HEXCONSTE(4503599627370494.5000000000001L, 0x4032, 0xffffffffL, 0xffffe800L), HEXCONSTE(4503599627370494.0L, 0x4032, 0xffffffffL, 0xffffe000L), 0 },
	{ __LINE__, HEXCONSTE(4503599627370495.5000000000001L, 0x4032, 0xffffffffL, 0xfffff800L), HEXCONSTE(4503599627370495.0L, 0x4032, 0xffffffffL, 0xfffff000L), 0 },
	{ __LINE__, HEXCONSTE(4503599627370496.5000000000001L, 0x4033, 0x80000000L, 0x00000400L), HEXCONSTE(4503599627370496.0L, 0x4033, 0x80000000L, 0x00000000L), 0 },
# endif

	{ __LINE__, HEXCONSTE(-4503599627370495.5L, 0xc032, 0xffffffffL, 0xfffff800L), HEXCONSTE(-4503599627370496.0L, 0xc033, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-4503599627370496.25L, 0xc033, 0x80000000L, 0x00000200L), HEXCONSTE(-4503599627370497.0L, 0xc033, 0x80000000L, 0x00000800L), 0 },
	{ __LINE__, HEXCONSTE(-4503599627370496.5L, 0xc033, 0x80000000L, 0x00000400L), HEXCONSTE(-4503599627370497.0L, 0xc033, 0x80000000L, 0x00000800L), 0 },
	{ __LINE__, HEXCONSTE(-4503599627370496.75L, 0xc033, 0x80000000L, 0x00000600L), HEXCONSTE(-4503599627370497.0L, 0xc033, 0x80000000L, 0x00000800L), 0 },
	{ __LINE__, HEXCONSTE(-4503599627370497.5L, 0xc033, 0x80000000L, 0x00000c00L), HEXCONSTE(-4503599627370498.0L, 0xc033, 0x80000000L, 0x00001000L), 0 },
# if LDBL_MANT_DIG > 100
	{ __LINE__, HEXCONSTE(-4503599627370494.5000000000001L, 0xc032, 0xffffffffL, 0xffffe800L), HEXCONSTE(-4503599627370495.0L, 0xc032, 0xffffffffL, 0xfffff000L), 0 },
	{ __LINE__, HEXCONSTE(-4503599627370495.5000000000001L, 0xc032, 0xffffffffL, 0xfffff800L), HEXCONSTE(-4503599627370496.0L, 0xc033, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-4503599627370496.5000000000001L, 0xc033, 0x80000000L, 0x00000400L), HEXCONSTE(-4503599627370497.0L, 0xc033, 0x80000000L, 0x00000800L), 0 },
# endif

	{ __LINE__, HEXCONSTE(9007199254740991.5L, 0x4033, 0xffffffffL, 0xfffffc00L), HEXCONSTE(9007199254740991.0L, 0x4033, 0xffffffffL, 0xfffff800L), 0 },
	{ __LINE__, HEXCONSTE(9007199254740992.25L, 0x4034, 0x80000000L, 0x00000100L), HEXCONSTE(9007199254740992.0L, 0x4034, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9007199254740992.5L, 0x4034, 0x80000000L, 0x00000200L), HEXCONSTE(9007199254740992.0L, 0x4034, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9007199254740992.75L, 0x4034, 0x80000000L, 0x00000300L), HEXCONSTE(9007199254740992.0L, 0x4034, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9007199254740993.5L, 0x4034, 0x80000000L, 0x00000600L), HEXCONSTE(9007199254740993.0L, 0x4034, 0x80000000L, 0x00000400L), 0 },

# if LDBL_MANT_DIG > 100
	{ __LINE__, HEXCONSTE(9007199254740991.0000000000001L, 0x4033, 0xffffffffL, 0xfffff800L), HEXCONSTE(9007199254740991.0L, 0x4033, 0xffffffffL, 0xfffff800L), 0 },
	{ __LINE__, HEXCONSTE(9007199254740992.0000000000001L, 0x4034, 0x80000000L, 0x00000000L), HEXCONSTE(9007199254740992.0L, 0x4034, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9007199254740993.0000000000001L, 0x4034, 0x80000000L, 0x00000400L), HEXCONSTE(9007199254740993.0L, 0x4034, 0x80000000L, 0x00000400L), 0 },
	{ __LINE__, HEXCONSTE(9007199254740991.5000000000001L, 0x4033, 0xffffffffL, 0xfffffc00L), HEXCONSTE(9007199254740991.0L, 0x4033, 0xffffffffL, 0xfffff800L), 0 },
	{ __LINE__, HEXCONSTE(9007199254740992.5000000000001L, 0x4034, 0x80000000L, 0x00000200L), HEXCONSTE(9007199254740992.0L, 0x4034, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9007199254740993.5000000000001L, 0x4034, 0x80000000L, 0x00000600L), HEXCONSTE(9007199254740993.0L, 0x4034, 0x80000000L, 0x00000400L), 0 },
# endif

	{ __LINE__, HEXCONSTE(-9007199254740991.5L, 0xc033, 0xffffffffL, 0xfffffc00L), HEXCONSTE(-9007199254740992.0L, 0xc034, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-9007199254740992.25L, 0xc034, 0x80000000L, 0x00000100L), HEXCONSTE(-9007199254740993.0L, 0xc034, 0x80000000L, 0x00000400L), 0 },
	{ __LINE__, HEXCONSTE(-9007199254740992.5L, 0xc034, 0x80000000L, 0x00000200L), HEXCONSTE(-9007199254740993.0L, 0xc034, 0x80000000L, 0x00000400L), 0 },
	{ __LINE__, HEXCONSTE(-9007199254740992.75L, 0xc034, 0x80000000L, 0x00000300L), HEXCONSTE(-9007199254740993.0L, 0xc034, 0x80000000L, 0x00000400L), 0 },
	{ __LINE__, HEXCONSTE(-9007199254740993.5L, 0xc034, 0x80000000L, 0x00000600L), HEXCONSTE(-9007199254740994.0L, 0xc034, 0x80000000L, 0x00000800L), 0 },

# if LDBL_MANT_DIG > 100
	{ __LINE__, HEXCONSTE(-9007199254740991.0000000000001L, 0xc033, 0xffffffffL, 0xfffff800L), HEXCONSTE(-9007199254740992.0L, 0xc034, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-9007199254740992.0000000000001L, 0xc034, 0x80000000L, 0x00000000L), HEXCONSTE(-9007199254740993.0L, 0xc034, 0x80000000L, 0x00000400L), 0 },
	{ __LINE__, HEXCONSTE(-9007199254740993.0000000000001L, 0xc034, 0x80000000L, 0x00000400L), HEXCONSTE(-9007199254740994.0L, 0xc034, 0x80000000L, 0x00000800L), 0 },
	{ __LINE__, HEXCONSTE(-9007199254740991.5000000000001L, 0xc033, 0xffffffffL, 0xfffffc00L), HEXCONSTE(-9007199254740992.0L, 0xc034, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-9007199254740992.5000000000001L, 0xc034, 0x80000000L, 0x00000200L), HEXCONSTE(-9007199254740993.0L, 0xc034, 0x80000000L, 0x00000400L), 0 },
	{ __LINE__, HEXCONSTE(-9007199254740993.5000000000001L, 0xc034, 0x80000000L, 0x00000600L), HEXCONSTE(-9007199254740994.0L, 0xc034, 0x80000000L, 0x00000800L), 0 },
# endif

	{ __LINE__, HEXCONSTE(72057594037927935.5L, 0x4036, 0xffffffffL, 0xffffff80L), HEXCONSTE(72057594037927935.0L, 0x4036, 0xffffffffL, 0xffffff00L), 0 },
	{ __LINE__, HEXCONSTE(72057594037927936.25L, 0x4037, 0x80000000L, 0x00000020L), HEXCONSTE(72057594037927936.0L, 0x4037, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(72057594037927936.5L, 0x4037, 0x80000000L, 0x00000040L), HEXCONSTE(72057594037927936.0L, 0x4037, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(72057594037927936.75L, 0x4037, 0x80000000L, 0x00000060L), HEXCONSTE(72057594037927936.0L, 0x4037, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(72057594037927937.5L, 0x4037, 0x80000000L, 0x000000c0L), HEXCONSTE(72057594037927937.0L, 0x4037, 0x80000000L, 0x00000080L), 0 },

	{ __LINE__, HEXCONSTE(-72057594037927935.5L, 0xc036, 0xffffffffL, 0xffffff80L), HEXCONSTE(-72057594037927936.0L, 0xc037, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-72057594037927936.25L, 0xc037, 0x80000000L, 0x00000020L), HEXCONSTE(-72057594037927937.0L, 0xc037, 0x80000000L, 0x00000080L), 0 },
	{ __LINE__, HEXCONSTE(-72057594037927936.5L, 0xc037, 0x80000000L, 0x00000040L), HEXCONSTE(-72057594037927937.0L, 0xc037, 0x80000000L, 0x00000080L), 0 },
	{ __LINE__, HEXCONSTE(-72057594037927936.75L, 0xc037, 0x80000000L, 0x00000060L), HEXCONSTE(-72057594037927937.0L, 0xc037, 0x80000000L, 0x00000080L), 0 },
	{ __LINE__, HEXCONSTE(-72057594037927937.5L, 0xc037, 0x80000000L, 0x000000c0L), HEXCONSTE(-72057594037927938.0L, 0xc037, 0x80000000L, 0x00000100L), 0 },

	{ __LINE__, HEXCONSTE(10141204801825835211973625643007.5L, 0x4066, 0x80000000L, 0x00000000L), HEXCONSTE(10141204801825835211973625643007.0L, 0x4066, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(10141204801825835211973625643008.25L, 0x4066, 0x80000000L, 0x00000000L), HEXCONSTE(10141204801825835211973625643008.0L, 0x4066, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(10141204801825835211973625643008.5L, 0x4066, 0x80000000L, 0x00000000L), HEXCONSTE(10141204801825835211973625643008.0L, 0x4066, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(10141204801825835211973625643008.75L, 0x4066, 0x80000000L, 0x00000000L), HEXCONSTE(10141204801825835211973625643008.0L, 0x4066, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(10141204801825835211973625643009.5L, 0x4066, 0x80000000L, 0x00000000L), HEXCONSTE(10141204801825835211973625643009.0L, 0x4066, 0x80000000L, 0x00000000L), 0 },

	{ __LINE__, HEXCONSTE(2.25179981368524799902e+15, 0x4031, 0xffffffffL, 0xfffffff8L), HEXCONSTE(2.25179981368524700000e+15, 0x4031, 0xffffffffL, 0xffffe000L), 0 },
	{ __LINE__, HEXCONSTE(-2.25179981368524800098e+15, 0xc032, 0x80000000L, 0x00000004L), HEXCONSTE(-2.25179981368524900000e+15, 0xc032, 0x80000000L, 0x00001000L), 0 },
#endif
};

int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_f_f(floor_data, ARRAY_SIZE(floor_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

```

`tests/fma.c`:

```c
#include "testconfig.h"
#ifdef HAVE_FMA
#define TEST_FUNC_FFF_F __MATH_PRECNAME(fma)
#include "testdriver.h"


#define ONE_P HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L)
#define ONE_M HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L)

#define LDBL_HALF_MAX_P HEXCONSTE(5.9486574767861588251063e+4931, 0x7ffd, 0xffffffffL, 0xffffffffL)
#define LDBL_HALF_MAX_M HEXCONSTE(-5.9486574767861588251063e+4931, 0xfffd, 0xffffffffL, 0xffffffffL)
#define LDBL_4TH_MAX_M HEXCONSTE(-2.9743287383930794125532e+4931, 0xfffc, 0xffffffffL, 0xffffffffL)


static test_fff_f_data const fma_data[] = {
	{ __LINE__, ONE_P, HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(3.0, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(5.0, 0x4001, 0xa0000000L, 0x00000000L), 0 },
	{ __LINE__, QNAN_P, HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(3.0, 0x4000, 0xc0000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__, ONE_P, QNAN_P, HEXCONSTE(3.0, 0x4000, 0xc0000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__, ONE_P, HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	{ __LINE__, INF_P, ZERO_P, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	{ __LINE__, INF_M, ZERO_P, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	{ __LINE__, ZERO_P, INF_P, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	{ __LINE__, ZERO_P, INF_M, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	{ __LINE__, INF_P, ZERO_P, ONE_P, QNAN_P, INVALID_EXCEPTION },
	{ __LINE__, INF_M, ZERO_P, ONE_P, QNAN_P, INVALID_EXCEPTION },
	{ __LINE__, ZERO_P, INF_P, ONE_P, QNAN_P, INVALID_EXCEPTION },
	{ __LINE__, ZERO_P, INF_M, ONE_P, QNAN_P, INVALID_EXCEPTION },

	{ __LINE__, INF_P, INF_P, INF_M, QNAN_P, INVALID_EXCEPTION },
	{ __LINE__, INF_M, INF_P, INF_P, QNAN_P, INVALID_EXCEPTION },
	{ __LINE__, INF_P, INF_M, INF_P, QNAN_P, INVALID_EXCEPTION },
	{ __LINE__, INF_M, INF_M, INF_M, QNAN_P, INVALID_EXCEPTION },
	{ __LINE__, INF_P, HEXCONSTE(3.5L, 0x4000, 0xe0000000L, 0x00000000L), INF_M, QNAN_P, INVALID_EXCEPTION },
	{ __LINE__, INF_M, HEXCONSTE(-7.5L, 0xc001, 0xf0000000L, 0x00000000L), INF_M, QNAN_P, INVALID_EXCEPTION },
	{ __LINE__, HEXCONSTE(-13.5L, 0xc002, 0xd8000000L, 0x00000000L), INF_P, INF_P, QNAN_P, INVALID_EXCEPTION },
	{ __LINE__, INF_M, HEXCONSTE(7.5L, 0x4001, 0xf0000000L, 0x00000000L), INF_P, QNAN_P, INVALID_EXCEPTION },

	{ __LINE__, HEXCONSTE(1.25L, 0x3fff, 0xa0000000L, 0x00000000L), HEXCONSTE(0.75L, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(0.0625L, 0x3ffb, 0x80000000L, 0x00000000L), ONE_P, 0 },

	/* If x times y is an exact infinity, and z is an infinity with the opposite sign, a domain error occurs, and a NaN is returned.*/
	{ __LINE__, MAX_M, MAX_M, INF_M, QNAN_P, 0 },
	{ __LINE__, LDBL_HALF_MAX_P, LDBL_HALF_MAX_P, INF_M, QNAN_P, 0 },
	{ __LINE__, MAX_M, MAX_P, INF_P, QNAN_P, 0 },
	{ __LINE__, LDBL_HALF_MAX_P, LDBL_4TH_MAX_M, INF_P, QNAN_M, 0 },
#ifdef TEST_LDOUBLE
	{ __LINE__, INF_P, HEXCONSTE(4, 0x4001, 0x80000000L, 0x00000000L), INF_P, QNAN_M, 0 },
	{ __LINE__, HEXCONSTE(2, 0x4000, 0x80000000L, 0x00000000L), INF_M, INF_M, QNAN_M, 0 },
	{ __LINE__, INF_M, INF_M, INF_P, QNAN_M, 0 },
	{ __LINE__, INF_P, INF_M, INF_M, QNAN_M, 0 },
#endif

	{ __LINE__, ZERO_P, ZERO_P, ZERO_P, ZERO_P, 0 },
	{ __LINE__, ZERO_P, ZERO_P, ZERO_M, ZERO_P, 0 },
	{ __LINE__, ZERO_P, ZERO_M, ZERO_P, ZERO_P, 0 },
	{ __LINE__, ZERO_P, ZERO_M, ZERO_M, ZERO_M, 0 },
	{ __LINE__, ZERO_M, ZERO_P, ZERO_P, ZERO_P, 0 },
	{ __LINE__, ZERO_M, ZERO_P, ZERO_M, ZERO_M, 0 },
	{ __LINE__, ZERO_M, ZERO_M, ZERO_P, ZERO_P, 0 },
	{ __LINE__, ZERO_M, ZERO_M, ZERO_M, ZERO_P, 0 },
	{ __LINE__, ONE_P, ZERO_P, ZERO_P, ZERO_P, 0 },
	{ __LINE__, ONE_P, ZERO_P, ZERO_M, ZERO_P, 0 },
	{ __LINE__, ONE_P, ZERO_M, ZERO_P, ZERO_P, 0 },
	{ __LINE__, ONE_P, ZERO_M, ZERO_M, ZERO_M, 0 },
	{ __LINE__, ONE_M, ZERO_P, ZERO_P, ZERO_P, 0 },
	{ __LINE__, ONE_M, ZERO_P, ZERO_M, ZERO_M, 0 },
	{ __LINE__, ONE_M, ZERO_M, ZERO_P, ZERO_P, 0 },
	{ __LINE__, ONE_M, ZERO_M, ZERO_M, ZERO_P, 0 },
	{ __LINE__, ZERO_P, ONE_P, ZERO_P, ZERO_P, 0 },
	{ __LINE__, ZERO_P, ONE_P, ZERO_M, ZERO_P, 0 },
	{ __LINE__, ZERO_P, ONE_M, ZERO_P, ZERO_P, 0 },
	{ __LINE__, ZERO_P, ONE_M, ZERO_M, ZERO_M, 0 },
	{ __LINE__, ZERO_M, ONE_P, ZERO_P, ZERO_P, 0 },
	{ __LINE__, ZERO_M, ONE_P, ZERO_M, ZERO_M, 0 },
	{ __LINE__, ZERO_M, ONE_M, ZERO_P, ZERO_P, 0 },
	{ __LINE__, ZERO_M, ONE_M, ZERO_M, ZERO_P, 0 },

	{ __LINE__, ONE_P, ONE_P, ONE_M, ZERO_P, 0 },
	{ __LINE__, ONE_P, ONE_M, ONE_P, ZERO_P, 0 },
	{ __LINE__, ONE_M, ONE_P, ONE_P, ZERO_P, 0 },
	{ __LINE__, ONE_M, ONE_M, ONE_M, ZERO_P, 0 },

	{ __LINE__, MIN_P, MIN_P, ZERO_P, ZERO_P, UNDERFLOW_EXCEPTION },
	{ __LINE__, MIN_P, MIN_P, ZERO_M, ZERO_P, UNDERFLOW_EXCEPTION },
	{ __LINE__, MIN_P, MIN_M, ZERO_P, ZERO_M, UNDERFLOW_EXCEPTION },
	{ __LINE__, MIN_P, MIN_M, ZERO_M, ZERO_M, UNDERFLOW_EXCEPTION },
	{ __LINE__, MIN_M, MIN_P, ZERO_P, ZERO_M, UNDERFLOW_EXCEPTION },
	{ __LINE__, MIN_M, MIN_P, ZERO_M, ZERO_M, UNDERFLOW_EXCEPTION },
	{ __LINE__, MIN_M, MIN_M, ZERO_P, ZERO_P, UNDERFLOW_EXCEPTION },
	{ __LINE__, MIN_M, MIN_M, ZERO_M, ZERO_P, UNDERFLOW_EXCEPTION },

	{ __LINE__, MAX_P, MAX_P, MIN_P, INF_P, OVERFLOW_EXCEPTION },
	{ __LINE__, MAX_P, MAX_P, MIN_M, INF_P, OVERFLOW_EXCEPTION },
	{ __LINE__, MAX_P, MAX_M, MIN_P, INF_M, OVERFLOW_EXCEPTION },
	{ __LINE__, MAX_P, MAX_M, MIN_M, INF_M, OVERFLOW_EXCEPTION },
	{ __LINE__, MAX_M, MAX_P, MIN_P, INF_M, OVERFLOW_EXCEPTION },
	{ __LINE__, MAX_M, MAX_P, MIN_M, INF_M, OVERFLOW_EXCEPTION },
	{ __LINE__, MAX_M, MAX_M, MIN_P, INF_P, OVERFLOW_EXCEPTION },
	{ __LINE__, MAX_M, MAX_M, MIN_M, INF_P, OVERFLOW_EXCEPTION },

#if defined (TEST_FLOAT) && FLT_MANT_DIG == 24
	{ __LINE__, HEXCONSTE(1.22870000000000000000e+04, 0x400c, 0xbffc0000L, 0x00000000L), HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(1.19208380056079477072e-07, 0x3fe7, 0xffff8000L, 0x00000000L), HEXCONSTE(1.22870009765625000000e+04, 0x400c, 0xbffc0100L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.99975585937500000000e+00, 0x3fff, 0xfff80000L, 0x00000000L), HEXCONSTE(1.00000095367431640625e+00, 0x3fff, 0x80000800L, 0x00000000L), HEXCONSTE(-1.99975585937500000000e+00, 0xbfff, 0xfff80000L, 0x00000000L), HEXCONSTE(1.90711580216884613037e-06, 0x3feb, 0xfff80000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.72982066388076033078e+38, 0x407e, 0xcd5e6f00L, 0x00000000L), HEXCONSTE(7.10520959454037574281e-39, 0x3f80, 0x9abcde00L, 0x00000000L), HEXCONSTE(-1.93959474563598632812e+00, 0xbfff, 0xf844a400L, 0x00000000L), HEXCONSTE(5.16020293162000598386e-08, 0x3fe6, 0xdda10800L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.03387488713917160837e+30, 0x4063, 0xcd5e6f00L, 0x00000000L), HEXCONSTE(7.10520959454037574281e-39, 0x3f80, 0x9abcde00L, 0x00000000L), HEXCONSTE(-1.44511069777308875928e-08, 0xbfe4, 0xf844a400L, 0x00000000L), HEXCONSTE(3.84465078385174720277e-16, 0x3fcb, 0xdda10800L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.00024414062500000000e+00, 0x3fff, 0x80080000L, 0x00000000L), HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(8.30767447847970849150e+34, 0x4072, 0xffffff00L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.99999988079071044922e+00, 0x3fff, 0xffffff00L, 0x00000000L), HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-3.40282306073709652508e+38, 0xc07e, 0xfffffd00L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.46936793852785938496e-38, 0x3f81, 0xa0000000L, 0x00000000L), HEXCONSTE(5.00000119209289550781e-01, 0x3ffe, 0x80000200L, 0x00000000L), HEXCONSTE(2.93873587705571876992e-39, 0x3f7f, 0x80000000L, 0x00000000L), HEXCONSTE(1.02855769709934800195e-38, 0x3f80, 0xe0000200L, 0x00000000L), UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(-1.46936793852785938496e-38, 0xbf81, 0xa0000000L, 0x00000000L), HEXCONSTE(5.00000119209289550781e-01, 0x3ffe, 0x80000200L, 0x00000000L), HEXCONSTE(-2.93873587705571876992e-39, 0xbf7f, 0x80000000L, 0x00000000L), HEXCONSTE(-1.02855769709934800195e-38, 0xbf80, 0xe0000200L, 0x00000000L), UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(2.35098814112518928601e-38, 0x3f81, 0xfffffc00L, 0x00000000L), HEXCONSTE(5.00000059604644775391e-01, 0x3ffe, 0x80000100L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), UNDERFLOW_EXCEPTION_BEFORE_ROUNDING },
	{ __LINE__, HEXCONSTE(-2.35098814112518928601e-38, 0xbf81, 0xfffffc00L, 0x00000000L), HEXCONSTE(5.00000059604644775391e-01, 0x3ffe, 0x80000100L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), UNDERFLOW_EXCEPTION_BEFORE_ROUNDING },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(5.00000000000000000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.17549421069244107549e-38, 0x3f80, 0xfffffe00L, 0x00000000L), HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(5.00000000000000000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(-1.17549421069244107549e-38, 0xbf80, 0xfffffe00L, 0x00000000L), HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(5.31250000000000000000e-01, 0x3ffe, 0x88000000L, 0x00000000L), HEXCONSTE(1.17549421069244107549e-38, 0x3f80, 0xfffffe00L, 0x00000000L), HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(5.31250000000000000000e-01, 0x3ffe, 0x88000000L, 0x00000000L), HEXCONSTE(-1.17549421069244107549e-38, 0xbf80, 0xfffffe00L, 0x00000000L), HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.70141183460469231732e+38, 0x407e, 0x80000000L, 0x00000000L), HEXCONSTE(1.70141183460469231732e+38, 0x407e, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.70141183460469231732e+38, 0x407e, 0x80000000L, 0x00000000L), HEXCONSTE(1.70141183460469231732e+38, 0x407e, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.70141183460469231732e+38, 0xc07e, 0x80000000L, 0x00000000L), HEXCONSTE(-1.70141183460469231732e+38, 0xc07e, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.70141183460469231732e+38, 0xc07e, 0x80000000L, 0x00000000L), HEXCONSTE(-1.70141183460469231732e+38, 0xc07e, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), UNDERFLOW_EXCEPTION_BEFORE_ROUNDING },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), UNDERFLOW_EXCEPTION_BEFORE_ROUNDING },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.17549421069244107549e-38, 0x3f80, 0xfffffe00L, 0x00000000L), HEXCONSTE(1.17549421069244107549e-38, 0x3f80, 0xfffffe00L, 0x00000000L), UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.17549421069244107549e-38, 0x3f80, 0xfffffe00L, 0x00000000L), HEXCONSTE(1.17549421069244107549e-38, 0x3f80, 0xfffffe00L, 0x00000000L), UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.17549421069244107549e-38, 0xbf80, 0xfffffe00L, 0x00000000L), HEXCONSTE(-1.17549421069244107549e-38, 0xbf80, 0xfffffe00L, 0x00000000L), UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.17549421069244107549e-38, 0xbf80, 0xfffffe00L, 0x00000000L), HEXCONSTE(-1.17549421069244107549e-38, 0xbf80, 0xfffffe00L, 0x00000000L), UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(9.99755859375000000000e-01, 0x3ffe, 0xfff00000L, 0x00000000L), HEXCONSTE(9.99755859375000000000e-01, 0x3ffe, 0xfff00000L, 0x00000000L), HEXCONSTE(-9.99511718750000000000e-01, 0xbffe, 0xffe00000L, 0x00000000L), HEXCONSTE(5.96046447753906250000e-08, 0x3fe7, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9.99755859375000000000e-01, 0x3ffe, 0xfff00000L, 0x00000000L), HEXCONSTE(-9.99755859375000000000e-01, 0xbffe, 0xfff00000L, 0x00000000L), HEXCONSTE(9.99511718750000000000e-01, 0x3ffe, 0xffe00000L, 0x00000000L), HEXCONSTE(-5.96046447753906250000e-08, 0xbfe7, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-9.99755859375000000000e-01, 0xbffe, 0xfff00000L, 0x00000000L), HEXCONSTE(9.99755859375000000000e-01, 0x3ffe, 0xfff00000L, 0x00000000L), HEXCONSTE(9.99511718750000000000e-01, 0x3ffe, 0xffe00000L, 0x00000000L), HEXCONSTE(-5.96046447753906250000e-08, 0xbfe7, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-9.99755859375000000000e-01, 0xbffe, 0xfff00000L, 0x00000000L), HEXCONSTE(-9.99755859375000000000e-01, 0xbffe, 0xfff00000L, 0x00000000L), HEXCONSTE(-9.99511718750000000000e-01, 0xbffe, 0xffe00000L, 0x00000000L), HEXCONSTE(5.96046447753906250000e-08, 0x3fe7, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.17549449095213394045e-38, 0x3f81, 0x80000100L, 0x00000000L), HEXCONSTE(1.49011629702044956503e-08, 0x3fe5, 0x80000100L, 0x00000000L), HEXCONSTE(1.70141183460469231732e+38, 0x407e, 0x80000000L, 0x00000000L), HEXCONSTE(1.70141183460469231732e+38, 0x407e, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.17549449095213394045e-38, 0x3f81, 0x80000100L, 0x00000000L), HEXCONSTE(-1.49011629702044956503e-08, 0xbfe5, 0x80000100L, 0x00000000L), HEXCONSTE(1.70141183460469231732e+38, 0x407e, 0x80000000L, 0x00000000L), HEXCONSTE(1.70141183460469231732e+38, 0x407e, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.17549449095213394045e-38, 0x3f81, 0x80000100L, 0x00000000L), HEXCONSTE(1.49011629702044956503e-08, 0x3fe5, 0x80000100L, 0x00000000L), HEXCONSTE(-1.70141183460469231732e+38, 0xc07e, 0x80000000L, 0x00000000L), HEXCONSTE(-1.70141183460469231732e+38, 0xc07e, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.17549449095213394045e-38, 0x3f81, 0x80000100L, 0x00000000L), HEXCONSTE(-1.49011629702044956503e-08, 0xbfe5, 0x80000100L, 0x00000000L), HEXCONSTE(-1.70141183460469231732e+38, 0xc07e, 0x80000000L, 0x00000000L), HEXCONSTE(-1.70141183460469231732e+38, 0xc07e, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.17549449095213394045e-38, 0x3f81, 0x80000100L, 0x00000000L), HEXCONSTE(1.49011629702044956503e-08, 0x3fe5, 0x80000100L, 0x00000000L), HEXCONSTE(1.01412048018258352120e+31, 0x4066, 0x80000000L, 0x00000000L), HEXCONSTE(1.01412048018258352120e+31, 0x4066, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.17549449095213394045e-38, 0x3f81, 0x80000100L, 0x00000000L), HEXCONSTE(-1.49011629702044956503e-08, 0xbfe5, 0x80000100L, 0x00000000L), HEXCONSTE(1.01412048018258352120e+31, 0x4066, 0x80000000L, 0x00000000L), HEXCONSTE(1.01412048018258352120e+31, 0x4066, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.17549449095213394045e-38, 0x3f81, 0x80000100L, 0x00000000L), HEXCONSTE(1.49011629702044956503e-08, 0x3fe5, 0x80000100L, 0x00000000L), HEXCONSTE(-1.01412048018258352120e+31, 0xc066, 0x80000000L, 0x00000000L), HEXCONSTE(-1.01412048018258352120e+31, 0xc066, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.17549449095213394045e-38, 0x3f81, 0x80000100L, 0x00000000L), HEXCONSTE(-1.49011629702044956503e-08, 0xbfe5, 0x80000100L, 0x00000000L), HEXCONSTE(-1.01412048018258352120e+31, 0xc066, 0x80000000L, 0x00000000L), HEXCONSTE(-1.01412048018258352120e+31, 0xc066, 0x80000000L, 0x00000000L), 0 },
#endif
#if defined (TEST_DOUBLE) && DBL_MANT_DIG == 53
	{ __LINE__, HEXCONSTE(1.22560000000000000000e+04, 0x400c, 0xbf800000L, 0x00000000L), HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(7.10369263412502505162e-15, 0x3fcf, 0xfff00000L, 0x00000000L), HEXCONSTE(1.22560000000000018190e+04, 0x400c, 0xbf800000L, 0x00000800L), 0 },
	{ __LINE__, HEXCONSTE(1.99975585937500000000e+00, 0x3fff, 0xfff80000L, 0x00000000L), HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(-1.99975585937500000000e+00, 0xbfff, 0xfff80000L, 0x00000000L), HEXCONSTE(4.44034999741438340948e-16, 0x3fcb, 0xfff80000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.00000000745058059692e+00, 0x3fff, 0x80000010L, 0x00000000L), HEXCONSTE(9.99999992549419403076e-01, 0x3ffe, 0xffffffe0L, 0x00000000L), HEXCONSTE(4.90909346529772655310e-91, 0x3ed3, 0x80000000L, 0x00000000L), HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.00000000745058059692e+00, 0x3fff, 0x80000010L, 0x00000000L), HEXCONSTE(9.99999992549419403076e-01, 0x3ffe, 0xffffffe0L, 0x00000000L), HEXCONSTE(-4.90909346529772655310e-91, 0xbed3, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), 0 },
	{ __LINE__, HEXCONSTE(1.68069805317375865044e+308, 0x43fe, 0xef56df77L, 0x97f76800L), HEXCONSTE(1.93545524363825017444e-308, 0x3c00, 0xdeadbeefL, 0x2feed000L), HEXCONSTE(-3.25291585998774968047e+00, 0xc000, 0xd02fc600L, 0xd25fd800L), HEXCONSTE(1.15158208725138169733e-16, 0x3fca, 0x84c4b43dL, 0xe4ed2000L), 0 },
	{ __LINE__, HEXCONSTE(1.58052085355501590052e+271, 0x4383, 0xef56df77L, 0x97f76800L), HEXCONSTE(1.93545524363825017444e-308, 0x3c00, 0xdeadbeefL, 0x2feed000L), HEXCONSTE(-3.05902737369265831580e-37, 0xbf85, 0xd02fc600L, 0xd25fd800L), HEXCONSTE(1.08294259045771022372e-53, 0x3f4f, 0x84c4b43dL, 0xe4ed2000L), 0 },
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.00024414062500000000e+00, 0x3fff, 0x80080000L, 0x00000000L), HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(4.38889925503495045934e+304, 0x43f2, 0xffffffffL, 0xfffff800L), 0 },
	{ __LINE__, HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.99999999999999977796e+00, 0x3fff, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.79769313486231530898e+308, 0xc3fe, 0xffffffffL, 0xffffe800L), 0 },
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), 0 },
	{ __LINE__, HEXCONSTE(1.57172778470262854957e-162, 0x3de5, 0xb504f333L, 0xf9de6000L), HEXCONSTE(1.57172778470262854957e-162, 0x3de5, 0xb504f333L, 0xf9de6000L), ZERO_P, ZERO_P, UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.82791618850005775053e-149, 0x3e10, 0xef56df77L, 0x97f76800L), HEXCONSTE(1.82791618850005775053e-149, 0x3e10, 0xef56df77L, 0x97f76800L), HEXCONSTE(-3.34127759218057860347e-298, 0xbc22, 0xdfc352bcL, 0x352ba000L), HEXCONSTE(5.50261588891002961624e-315, 0x3beb, 0x84c4b43eL, 0x00000000L), UNDERFLOW_EXCEPTION|FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(7.14029761132835058799e-152, 0x3e08, 0xef56df77L, 0x97f76800L), HEXCONSTE(7.14029761132835058799e-152, 0x3e08, 0xef56df77L, 0x97f76800L), HEXCONSTE(-5.09838499783413483195e-303, 0xbc12, 0xdfc352bcL, 0x352ba000L), HEXCONSTE(8.39615158542614377174e-320, 0x3bdb, 0x84c40000L, 0x00000000L), UNDERFLOW_EXCEPTION|FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(2.22275874948507748344e-162, 0x3de6, 0x80000000L, 0x00000000L), HEXCONSTE(1.11137937474253874172e-162, 0x3de5, 0x80000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(9.88131291682493088353e-324, 0x3bce, 0x80000000L, 0x00000000L), UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(6.01250496056917516558e-292, 0x3c37, 0xbfffffc0L, 0x00000000L), HEXCONSTE(1.23259516440783094596e-32, 0x3f95, 0x80000000L, 0x00000000L), HEXCONSTE(1.32624736935329519694e-315, 0x3be9, 0x80000000L, 0x00000000L), HEXCONSTE(1.32624737429395165536e-315, 0x3be9, 0x80000008L, 0x00000000L), UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.00208419195026070584e-291, 0x3c38, 0xa0000020L, 0x00000000L), HEXCONSTE(1.23259516440783094596e-32, 0x3f95, 0x80000000L, 0x00000000L), HEXCONSTE(1.32624736935329519694e-315, 0x3be9, 0x80000000L, 0x00000000L), HEXCONSTE(1.32624738417526457218e-315, 0x3be9, 0x80000018L, 0x00000000L), UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.00208418000448638900e-291, 0x3c38, 0xa0000000L, 0x00000000L), HEXCONSTE(-1.23259516440783094596e-32, 0xbf95, 0x80000000L, 0x00000000L), HEXCONSTE(-1.32624736935329519694e-315, 0xbbe9, 0x80000000L, 0x00000000L), HEXCONSTE(-1.32624737923460811377e-315, 0xbbe9, 0x80000010L, 0x00000000L), UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(-2.25903320843691287941e-289, 0xbc40, 0x8ce55b36L, 0xb9f0b800L), HEXCONSTE(1.09552820860933426296e-32, 0x3f94, 0xe3884546L, 0x2ffa8800L), HEXCONSTE(-1.11853546624563400596e-308, 0xbc00, 0x80b0ad65L, 0xd9b64000L), HEXCONSTE(-1.11853546624588153284e-308, 0xbc00, 0x80b0ad65L, 0xd9d59000L), UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(-3.56972370854509549663e-295, 0xbc2c, 0xe97576b7L, 0x474e9800L), HEXCONSTE(-1.41465128783349729973e-19, 0xbfc0, 0xa7033631L, 0x564ee800L), HEXCONSTE(-1.27136071315873422165e-308, 0xbc00, 0x9245e6b0L, 0x03454000L), HEXCONSTE(-1.27135566324449266374e-308, 0xbc00, 0x9245c09cL, 0x5fb5d000L), UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.00094353880352101309e-273, 0x3c74, 0x8a9eb285L, 0xdcf83000L), HEXCONSTE(2.76428921941130553870e-38, 0x3f82, 0x96809186L, 0xa4203800L), HEXCONSTE(-1.55122423784859904827e-308, 0xbc00, 0xb278d5acL, 0xfc3c0000L), HEXCONSTE(-1.54845734041504526743e-308, 0xbc00, 0xb2275712L, 0x3bbe9000L), UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(-1.85653473271011680903e-214, 0xbd38, 0xffffffffL, 0xfffff800L), HEXCONSTE(3.29443685725953814185e-83, 0x3eec, 0xffffffffL, 0xfffff800L), HEXCONSTE(2.44649443426719370386e-296, 0x3c28, 0xffffff00L, 0x003ff800L), HEXCONSTE(1.83487078924492417933e-296, 0x3c28, 0xbfffff00L, 0x003ff800L), 0 },
	{ __LINE__, HEXCONSTE(2.78134232313400172886e-308, 0x3c01, 0xa0000000L, 0x00000000L), HEXCONSTE(5.00000000000000222045e-01, 0x3ffe, 0x80000000L, 0x00001000L), HEXCONSTE(5.56268464626800345773e-309, 0x3bff, 0x80000000L, 0x00000000L), HEXCONSTE(1.94693962619380170427e-308, 0x3c00, 0xe0000000L, 0x00001000L), UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(-2.78134232313400172886e-308, 0xbc01, 0xa0000000L, 0x00000000L), HEXCONSTE(5.00000000000000222045e-01, 0x3ffe, 0x80000000L, 0x00001000L), HEXCONSTE(-5.56268464626800345773e-309, 0xbbff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.94693962619380170427e-308, 0xbc00, 0xe0000000L, 0x00001000L), UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(4.45014771701440078992e-308, 0x3c01, 0xffffffffL, 0xffffe000L), HEXCONSTE(5.00000000000000111022e-01, 0x3ffe, 0x80000000L, 0x00000800L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), UNDERFLOW_EXCEPTION_BEFORE_ROUNDING },
	{ __LINE__, HEXCONSTE(-4.45014771701440078992e-308, 0xbc01, 0xffffffffL, 0xffffe000L), HEXCONSTE(5.00000000000000111022e-01, 0x3ffe, 0x80000000L, 0x00000800L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), UNDERFLOW_EXCEPTION_BEFORE_ROUNDING },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(5.00000000000000000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(2.22507385850720088902e-308, 0x3c00, 0xffffffffL, 0xfffff000L), HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(5.00000000000000000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(-2.22507385850720088902e-308, 0xbc00, 0xffffffffL, 0xfffff000L), HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(5.31250000000000000000e-01, 0x3ffe, 0x88000000L, 0x00000000L), HEXCONSTE(2.22507385850720088902e-308, 0x3c00, 0xffffffffL, 0xfffff000L), HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(5.31250000000000000000e-01, 0x3ffe, 0x88000000L, 0x00000000L), HEXCONSTE(-2.22507385850720088902e-308, 0xbc00, 0xffffffffL, 0xfffff000L), HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(8.98846567431157953865e+307, 0x43fe, 0x80000000L, 0x00000000L), HEXCONSTE(8.98846567431157953865e+307, 0x43fe, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(8.98846567431157953865e+307, 0x43fe, 0x80000000L, 0x00000000L), HEXCONSTE(8.98846567431157953865e+307, 0x43fe, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(-8.98846567431157953865e+307, 0xc3fe, 0x80000000L, 0x00000000L), HEXCONSTE(-8.98846567431157953865e+307, 0xc3fe, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-8.98846567431157953865e+307, 0xc3fe, 0x80000000L, 0x00000000L), HEXCONSTE(-8.98846567431157953865e+307, 0xc3fe, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), UNDERFLOW_EXCEPTION_BEFORE_ROUNDING },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), UNDERFLOW_EXCEPTION_BEFORE_ROUNDING },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(2.22507385850720088902e-308, 0x3c00, 0xffffffffL, 0xfffff000L), HEXCONSTE(2.22507385850720088902e-308, 0x3c00, 0xffffffffL, 0xfffff000L), UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(2.22507385850720088902e-308, 0x3c00, 0xffffffffL, 0xfffff000L), HEXCONSTE(2.22507385850720088902e-308, 0x3c00, 0xffffffffL, 0xfffff000L), UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(-2.22507385850720088902e-308, 0xbc00, 0xffffffffL, 0xfffff000L), HEXCONSTE(-2.22507385850720088902e-308, 0xbc00, 0xffffffffL, 0xfffff000L), UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-2.22507385850720088902e-308, 0xbc00, 0xffffffffL, 0xfffff000L), HEXCONSTE(-2.22507385850720088902e-308, 0xbc00, 0xffffffffL, 0xfffff000L), UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-9.99999999999999777955e-01, 0xbffe, 0xffffffffL, 0xfffff000L), HEXCONSTE(1.23259516440783094596e-32, 0x3f95, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-9.99999999999999888978e-01, 0xbffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(9.99999999999999777955e-01, 0x3ffe, 0xffffffffL, 0xfffff000L), HEXCONSTE(-1.23259516440783094596e-32, 0xbf95, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-9.99999999999999888978e-01, 0xbffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(9.99999999999999777955e-01, 0x3ffe, 0xffffffffL, 0xfffff000L), HEXCONSTE(-1.23259516440783094596e-32, 0xbf95, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-9.99999999999999888978e-01, 0xbffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-9.99999999999999888978e-01, 0xbffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-9.99999999999999777955e-01, 0xbffe, 0xffffffffL, 0xfffff000L), HEXCONSTE(1.23259516440783094596e-32, 0x3f95, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.22507385850720187716e-308, 0x3c01, 0x80000000L, 0x00000800L), HEXCONSTE(2.77555756156289196736e-17, 0x3fc8, 0x80000000L, 0x00000800L), HEXCONSTE(8.98846567431157953865e+307, 0x43fe, 0x80000000L, 0x00000000L), HEXCONSTE(8.98846567431157953865e+307, 0x43fe, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.22507385850720187716e-308, 0x3c01, 0x80000000L, 0x00000800L), HEXCONSTE(-2.77555756156289196736e-17, 0xbfc8, 0x80000000L, 0x00000800L), HEXCONSTE(8.98846567431157953865e+307, 0x43fe, 0x80000000L, 0x00000000L), HEXCONSTE(8.98846567431157953865e+307, 0x43fe, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.22507385850720187716e-308, 0x3c01, 0x80000000L, 0x00000800L), HEXCONSTE(2.77555756156289196736e-17, 0x3fc8, 0x80000000L, 0x00000800L), HEXCONSTE(-8.98846567431157953865e+307, 0xc3fe, 0x80000000L, 0x00000000L), HEXCONSTE(-8.98846567431157953865e+307, 0xc3fe, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.22507385850720187716e-308, 0x3c01, 0x80000000L, 0x00000800L), HEXCONSTE(-2.77555756156289196736e-17, 0xbfc8, 0x80000000L, 0x00000800L), HEXCONSTE(-8.98846567431157953865e+307, 0xc3fe, 0x80000000L, 0x00000000L), HEXCONSTE(-8.98846567431157953865e+307, 0xc3fe, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.22507385850720187716e-308, 0x3c01, 0x80000000L, 0x00000800L), HEXCONSTE(2.77555756156289196736e-17, 0x3fc8, 0x80000000L, 0x00000800L), HEXCONSTE(9.97920154767359905828e+291, 0x43c9, 0x80000000L, 0x00000000L), HEXCONSTE(9.97920154767359905828e+291, 0x43c9, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.22507385850720187716e-308, 0x3c01, 0x80000000L, 0x00000800L), HEXCONSTE(-2.77555756156289196736e-17, 0xbfc8, 0x80000000L, 0x00000800L), HEXCONSTE(9.97920154767359905828e+291, 0x43c9, 0x80000000L, 0x00000000L), HEXCONSTE(9.97920154767359905828e+291, 0x43c9, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.22507385850720187716e-308, 0x3c01, 0x80000000L, 0x00000800L), HEXCONSTE(2.77555756156289196736e-17, 0x3fc8, 0x80000000L, 0x00000800L), HEXCONSTE(-9.97920154767359905828e+291, 0xc3c9, 0x80000000L, 0x00000000L), HEXCONSTE(-9.97920154767359905828e+291, 0xc3c9, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.22507385850720187716e-308, 0x3c01, 0x80000000L, 0x00000800L), HEXCONSTE(-2.77555756156289196736e-17, 0xbfc8, 0x80000000L, 0x00000800L), HEXCONSTE(-9.97920154767359905828e+291, 0xc3c9, 0x80000000L, 0x00000000L), HEXCONSTE(-9.97920154767359905828e+291, 0xc3c9, 0x80000000L, 0x00000000L), 0 },
#endif
#if defined (TEST_LDOUBLE) && LDBL_MANT_DIG == 64
	{ __LINE__, HEXCONSTE(-3.24188838352884987521e+1113, 0xce72, 0x803fc000L, 0x00000000L), HEXCONSTE(7.58484317697911551527e-1848, 0x2806, 0xffffffffL, 0xffffffffL), HEXCONSTE(2.47152251874819186499e-737, 0x3670, 0x83ffffffL, 0xffffffffL), HEXCONSTE(-2.45644997611491690729e-734, 0xb67a, 0x801ec000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9.84695762613665278681e+612, 0x47f3, 0x9fc00000L, 0x00000000L), HEXCONSTE(-1.91305453305165915613e-1087, 0xb1e5, 0x8000e1f0L, 0x00ff800fL), HEXCONSTE(-7.54669553718169991629e-475, 0xb9d7, 0xffffffffL, 0xffffc0ffL), HEXCONSTE(-2.63844624606300283282e-474, 0xb9d9, 0xdfc119fbL, 0x093ed092L), 0 },
	{ __LINE__, HEXCONSTE(4.64580802288587437207e-359, 0x3b58, 0xc7fc0000L, 0x03ffffffL), HEXCONSTE(6.25387407867252868367e+4614, 0x7be1, 0x81e0003fL, 0xffffffffL), HEXCONSTE(-1.11773801122906527630e+4237, 0xf6fa, 0x8fffe000L, 0x00000000L), HEXCONSTE(2.90542983688148396412e+4256, 0x773a, 0xcae9f164L, 0x020effffL), 0 },
	{ __LINE__, HEXCONSTE(-1.42897238002446878212e+542, 0xc708, 0x80001fc0L, 0x00000003L), HEXCONSTE(6.05746502655573363042e-671, 0x374c, 0xc0000000L, 0x00000000L), HEXCONSTE(1.17671232669529647052e-140, 0x3e2e, 0x8f7e0000L, 0x00000007L), HEXCONSTE(-8.65595021590056155688e-129, 0xbe55, 0xc0002f9fL, 0xfee10404L), 0 },
	{ __LINE__, HEXCONSTE(3.25864703793047743153e+3050, 0x6794, 0xc0000000L, 0x000007ffL), HEXCONSTE(-2.92395563241758324667e+1334, 0xd150, 0x80000000L, 0x00000001L), HEXCONSTE(8.48197122819917944650e+4369, 0x78b3, 0xc0700000L, 0x0001ffffL), HEXCONSTE(-9.52813936061768503789e+4384, 0xf8e5, 0xbfffffffL, 0xffffd7e4L), 0 },
	{ __LINE__, HEXCONSTE(1.14522654783539566347e-1437, 0x2d59, 0xbffff000L, 0x00000000L), HEXCONSTE(2.20181253616229718191e-3495, 0x12a6, 0x8000000fL, 0xffffffffL), HEXCONSTE(-9.19389197395040574310e-4934, 0x8000, 0x03800fffL, 0x80000000L), HEXCONSTE(2.42963525003034082019e-4932, 0x0000, 0x5c7fe80cL, 0x7ffeffffL), UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(4.20262892889011688283e-4932, 0x0001, 0xa0000000L, 0x00000000L), HEXCONSTE(5.00000000000000000108e-01, 0x3ffe, 0x80000000L, 0x00000002L), HEXCONSTE(8.40525785778023376566e-4933, 0x0000, 0x20000000L, 0x00000000L), HEXCONSTE(2.94184025022308181834e-4932, 0x0000, 0x70000000L, 0x00000001L), UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(-4.20262892889011688283e-4932, 0x8001, 0xa0000000L, 0x00000000L), HEXCONSTE(5.00000000000000000108e-01, 0x3ffe, 0x80000000L, 0x00000002L), HEXCONSTE(-8.40525785778023376566e-4933, 0x8000, 0x20000000L, 0x00000000L), HEXCONSTE(-2.94184025022308181834e-4932, 0x8000, 0x70000000L, 0x00000001L), UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(6.72420628622418701107e-4932, 0x0001, 0xffffffffL, 0xfffffffcL), HEXCONSTE(5.00000000000000000054e-01, 0x3ffe, 0x80000000L, 0x00000001L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), UNDERFLOW_EXCEPTION_BEFORE_ROUNDING },
	{ __LINE__, HEXCONSTE(-6.72420628622418701107e-4932, 0x8001, 0xffffffffL, 0xfffffffcL), HEXCONSTE(5.00000000000000000054e-01, 0x3ffe, 0x80000000L, 0x00000001L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), UNDERFLOW_EXCEPTION_BEFORE_ROUNDING },
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(5.00000000000000000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(3.36210314311209350590e-4932, 0x0000, 0x7fffffffL, 0xffffffffL), HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(5.00000000000000000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(-3.36210314311209350590e-4932, 0x8000, 0x7fffffffL, 0xffffffffL), HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(5.31250000000000000000e-01, 0x3ffe, 0x88000000L, 0x00000000L), HEXCONSTE(3.36210314311209350590e-4932, 0x0000, 0x7fffffffL, 0xffffffffL), HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(5.31250000000000000000e-01, 0x3ffe, 0x88000000L, 0x00000000L), HEXCONSTE(-3.36210314311209350590e-4932, 0x8000, 0x7fffffffL, 0xffffffffL), HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(5.94865747678615882543e+4931, 0x7ffe, 0x80000000L, 0x00000000L), HEXCONSTE(5.94865747678615882543e+4931, 0x7ffe, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(5.94865747678615882543e+4931, 0x7ffe, 0x80000000L, 0x00000000L), HEXCONSTE(5.94865747678615882543e+4931, 0x7ffe, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(-5.94865747678615882543e+4931, 0xfffe, 0x80000000L, 0x00000000L), HEXCONSTE(-5.94865747678615882543e+4931, 0xfffe, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(-5.94865747678615882543e+4931, 0xfffe, 0x80000000L, 0x00000000L), HEXCONSTE(-5.94865747678615882543e+4931, 0xfffe, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), UNDERFLOW_EXCEPTION_BEFORE_ROUNDING },
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), UNDERFLOW_EXCEPTION_BEFORE_ROUNDING },
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(3.36210314311209350590e-4932, 0x0000, 0x7fffffffL, 0xffffffffL), HEXCONSTE(3.36210314311209350590e-4932, 0x0000, 0x7fffffffL, 0xffffffffL), UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(3.36210314311209350590e-4932, 0x0000, 0x7fffffffL, 0xffffffffL), HEXCONSTE(3.36210314311209350590e-4932, 0x0000, 0x7fffffffL, 0xffffffffL), UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(-3.36210314311209350590e-4932, 0x8000, 0x7fffffffL, 0xffffffffL), HEXCONSTE(-3.36210314311209350590e-4932, 0x8000, 0x7fffffffL, 0xffffffffL), UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(-3.36210314311209350590e-4932, 0x8000, 0x7fffffffL, 0xffffffffL), HEXCONSTE(-3.36210314311209350590e-4932, 0x8000, 0x7fffffffL, 0xffffffffL), UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-9.99999999999999999892e-01, 0xbffe, 0xffffffffL, 0xfffffffeL), HEXCONSTE(2.93873587705571876992e-39, 0x3f7f, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-9.99999999999999999946e-01, 0xbffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(9.99999999999999999892e-01, 0x3ffe, 0xffffffffL, 0xfffffffeL), HEXCONSTE(-2.93873587705571876992e-39, 0xbf7f, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-9.99999999999999999946e-01, 0xbffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(9.99999999999999999892e-01, 0x3ffe, 0xffffffffL, 0xfffffffeL), HEXCONSTE(-2.93873587705571876992e-39, 0xbf7f, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-9.99999999999999999946e-01, 0xbffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-9.99999999999999999946e-01, 0xbffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-9.99999999999999999892e-01, 0xbffe, 0xffffffffL, 0xfffffffeL), HEXCONSTE(2.93873587705571876992e-39, 0x3f7f, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.36210314311209350663e-4932, 0x0001, 0x80000000L, 0x00000001L), HEXCONSTE(1.35525271560688054266e-20, 0x3fbd, 0x80000000L, 0x00000001L), HEXCONSTE(5.94865747678615882543e+4931, 0x7ffe, 0x80000000L, 0x00000000L), HEXCONSTE(5.94865747678615882543e+4931, 0x7ffe, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.36210314311209350663e-4932, 0x0001, 0x80000000L, 0x00000001L), HEXCONSTE(-1.35525271560688054266e-20, 0xbfbd, 0x80000000L, 0x00000001L), HEXCONSTE(5.94865747678615882543e+4931, 0x7ffe, 0x80000000L, 0x00000000L), HEXCONSTE(5.94865747678615882543e+4931, 0x7ffe, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.36210314311209350663e-4932, 0x0001, 0x80000000L, 0x00000001L), HEXCONSTE(1.35525271560688054266e-20, 0x3fbd, 0x80000000L, 0x00000001L), HEXCONSTE(-5.94865747678615882543e+4931, 0xfffe, 0x80000000L, 0x00000000L), HEXCONSTE(-5.94865747678615882543e+4931, 0xfffe, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.36210314311209350663e-4932, 0x0001, 0x80000000L, 0x00000001L), HEXCONSTE(-1.35525271560688054266e-20, 0xbfbd, 0x80000000L, 0x00000001L), HEXCONSTE(-5.94865747678615882543e+4931, 0xfffe, 0x80000000L, 0x00000000L), HEXCONSTE(-5.94865747678615882543e+4931, 0xfffe, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.36210314311209350663e-4932, 0x0001, 0x80000000L, 0x00000001L), HEXCONSTE(1.35525271560688054266e-20, 0x3fbd, 0x80000000L, 0x00000001L), HEXCONSTE(3.22477367985184627972e+4912, 0x7fbe, 0x80000000L, 0x00000000L), HEXCONSTE(3.22477367985184627972e+4912, 0x7fbe, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.36210314311209350663e-4932, 0x0001, 0x80000000L, 0x00000001L), HEXCONSTE(-1.35525271560688054266e-20, 0xbfbd, 0x80000000L, 0x00000001L), HEXCONSTE(3.22477367985184627972e+4912, 0x7fbe, 0x80000000L, 0x00000000L), HEXCONSTE(3.22477367985184627972e+4912, 0x7fbe, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.36210314311209350663e-4932, 0x0001, 0x80000000L, 0x00000001L), HEXCONSTE(1.35525271560688054266e-20, 0x3fbd, 0x80000000L, 0x00000001L), HEXCONSTE(-3.22477367985184627972e+4912, 0xffbe, 0x80000000L, 0x00000000L), HEXCONSTE(-3.22477367985184627972e+4912, 0xffbe, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.36210314311209350663e-4932, 0x0001, 0x80000000L, 0x00000001L), HEXCONSTE(-1.35525271560688054266e-20, 0xbfbd, 0x80000000L, 0x00000001L), HEXCONSTE(-3.22477367985184627972e+4912, 0xffbe, 0x80000000L, 0x00000000L), HEXCONSTE(-3.22477367985184627972e+4912, 0xffbe, 0x80000000L, 0x00000000L), 0 },
#endif

};


int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_fff_f(fma_data, ARRAY_SIZE(fma_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

#else

int main(void)
{
	return 77;
}

#endif

```

`tests/fmax.c`:

```c
#include "testconfig.h"
#ifdef HAVE_FMAX
/* FIXME: not declared for fpu version */
double fmax(double, double);
#define TEST_FUNC_FF_F __MATH_PRECNAME(fmax)
#include "testdriver.h"


static test_ff_f_data const fmax_data[] = {
	{ __LINE__, HEXCONSTE(6.0, 0x4001, 0xc0000000L, 0x00000000L), HEXCONSTE(5.0, 0x4001, 0xa0000000L, 0x00000000L), HEXCONSTE(6.0, 0x4001, 0xc0000000L, 0x00000000L), 0 },
	{ __LINE__, ZERO_P, ZERO_P, ZERO_P, 0 },
	{ __LINE__, HEXCONSTE(0.1, 0x3ffb, 0xccccccccL, 0xcccccccdL), HEXCONSTE(0.2, 0x3ffc, 0xccccccccL, 0xcccccccdL), HEXCONSTE(0.2, 0x3ffc, 0xccccccccL, 0xcccccccdL), 0 },
	{ __LINE__, HEXCONSTE(-0.1, 0xbffb, 0xccccccccL, 0xcccccccdL), HEXCONSTE(-0.2, 0xbffc, 0xccccccccL, 0xcccccccdL), HEXCONSTE(-0.1, 0xbffb, 0xccccccccL, 0xcccccccdL), 0 },
	{ __LINE__, HEXCONSTE(-0.1, 0xbffb, 0xccccccccL, 0xcccccccdL), HEXCONSTE(0.2, 0x3ffc, 0xccccccccL, 0xcccccccdL), HEXCONSTE(0.2, 0x3ffc, 0xccccccccL, 0xcccccccdL), 0 },
	{ __LINE__, HEXCONSTE(0.1, 0x3ffb, 0xccccccccL, 0xcccccccdL), HEXCONSTE(0.2, 0x3ffc, 0xccccccccL, 0xcccccccdL), HEXCONSTE(0.2, 0x3ffc, 0xccccccccL, 0xcccccccdL), 0 },
	{ __LINE__, HEXCONSTE(0.1, 0x3ffb, 0xccccccccL, 0xcccccccdL), HEXCONSTE(-0.2, 0xbffc, 0xccccccccL, 0xcccccccdL), HEXCONSTE(0.1, 0x3ffb, 0xccccccccL, 0xcccccccdL), 0 },
	{ __LINE__, HEXCONSTE(1e10, 0x4020, 0x9502f900L, 0x00000000L), HEXCONSTE(1.1e10, 0x4020, 0xa3e9ab80L, 0x00000000L), HEXCONSTE(1.1e10, 0x4020, 0xa3e9ab80L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1e10, 0xc020, 0x9502f900L, 0x00000000L), HEXCONSTE(-1.1e10, 0xc020, 0xa3e9ab80L, 0x00000000L), HEXCONSTE(-1e10, 0xc020, 0x9502f900L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1e-10, 0x3fdd, 0xdbe6feceL, 0xbdedd5bfL), HEXCONSTE(1.1e-10, 0x3fdd, 0xf1e47eb0L, 0x37526b1fL), HEXCONSTE(1.1e-10, 0x3fdd, 0xf1e47eb0L, 0x37526b1fL), 0 },

	{ __LINE__, ZERO_P, ZERO_P, ZERO_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_M, ZERO_P, ZERO_P, NO_INEXACT_EXCEPTION|FLAG_FAIL_SOFTFLOAT|FLAG_FAIL_ARANYM|FLAG_XFAIL }, /* returns -0 */
	{ __LINE__, ZERO_M, ZERO_M, ZERO_M, NO_INEXACT_EXCEPTION|FLAG_FAIL_ARANYM2 },
	{ __LINE__, ZERO_M, ZERO_P, ZERO_P, NO_INEXACT_EXCEPTION|FLAG_FAIL_SOFTFLOAT|FLAG_FAIL_ARANYM|FLAG_XFAIL }, /* returns -0 */
	{ __LINE__, HEXCONSTE(9, 0x4002, 0x90000000L, 0x00000000L), ZERO_P, HEXCONSTE(9, 0x4002, 0x90000000L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-9, 0xc002, 0x90000000L, 0x00000000L), ZERO_P, ZERO_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_P, HEXCONSTE(9, 0x4002, 0x90000000L, 0x00000000L), HEXCONSTE(9, 0x4002, 0x90000000L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_P, HEXCONSTE(-9, 0xc002, 0x90000000L, 0x00000000L), ZERO_P, NO_INEXACT_EXCEPTION },

	{ __LINE__, INF_P, HEXCONSTE(9, 0x4002, 0x90000000L, 0x00000000L), INF_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, INF_P, HEXCONSTE(-9, 0xc002, 0x90000000L, 0x00000000L), INF_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-9, 0xc002, 0x90000000L, 0x00000000L), INF_P, INF_P, NO_INEXACT_EXCEPTION|FLAG_FAIL_ARANYM }, /* FIXME: fcmp/fjun problem? */
	{ __LINE__, HEXCONSTE(9, 0xc002, 0x90000000L, 0x00000000L), INF_P, INF_P, NO_INEXACT_EXCEPTION|FLAG_FAIL_ARANYM }, /* FIXME: fcmp/fjun problem? */
	{ __LINE__, ZERO_P, INF_P, INF_P, NO_INEXACT_EXCEPTION|FLAG_FAIL_ARANYM },
	{ __LINE__, ZERO_M, INF_P, INF_P, NO_INEXACT_EXCEPTION|FLAG_FAIL_ARANYM },
	{ __LINE__, INF_P, ZERO_P, INF_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, INF_P, ZERO_M, INF_P, NO_INEXACT_EXCEPTION },

	{ __LINE__, INF_M, HEXCONSTE(9, 0x4002, 0x90000000L, 0x00000000L), HEXCONSTE(9, 0x4002, 0x90000000L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, INF_M, HEXCONSTE(-9, 0xc002, 0x90000000L, 0x00000000L), HEXCONSTE(-9, 0xc002, 0x90000000L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(9, 0x4002, 0x90000000L, 0x00000000L), INF_M, HEXCONSTE(9, 0x4002, 0x90000000L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-9, 0xc002, 0x90000000L, 0x00000000L), INF_M, HEXCONSTE(-9, 0xc002, 0x90000000L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_P, INF_M, ZERO_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_M, INF_M, ZERO_M, NO_INEXACT_EXCEPTION|FLAG_FAIL_ARANYM2 },
	{ __LINE__, INF_M, ZERO_P, ZERO_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, INF_M, ZERO_M, ZERO_M, NO_INEXACT_EXCEPTION|FLAG_FAIL_ARANYM2 },

	/* If one argument is a NaN, the other argument is returned. */
	{ __LINE__, ZERO_P, QNAN_P, ZERO_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_M, QNAN_P, ZERO_M, NO_INEXACT_EXCEPTION|FLAG_FAIL_ARANYM2 },
	{ __LINE__, HEXCONSTE(9, 0x4002, 0x90000000L, 0x00000000L), QNAN_P, HEXCONSTE(9, 0x4002, 0x90000000L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-9, 0xc002, 0x90000000L, 0x00000000L), QNAN_P, HEXCONSTE(-9, 0xc002, 0x90000000L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_P, ZERO_P, ZERO_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_P, ZERO_M, ZERO_M, NO_INEXACT_EXCEPTION|FLAG_FAIL_ARANYM2 },
	{ __LINE__, QNAN_P, HEXCONSTE(9, 0x4002, 0x90000000L, 0x00000000L), HEXCONSTE(9, 0x4002, 0x90000000L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_P, HEXCONSTE(-9, 0xc002, 0x90000000L, 0x00000000L), HEXCONSTE(-9, 0xc002, 0x90000000L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, INF_P, QNAN_P, INF_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, INF_M, QNAN_P, INF_M, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_P, INF_P, INF_P, NO_INEXACT_EXCEPTION|FLAG_FAIL_ARANYM }, /* FIXME: fcmp/fjun problem? */
	{ __LINE__, QNAN_P, INF_M, INF_M, NO_INEXACT_EXCEPTION|FLAG_FAIL_ARANYM }, /* FIXME: fcmp/fjun problem? */

	/* If both arguments are NaN, a NaN is returned. */
	{ __LINE__, QNAN_P, QNAN_P, QNAN_P, NO_INEXACT_EXCEPTION },
};

int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_ff_f(fmax_data, ARRAY_SIZE(fmax_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

#else

int main(void)
{
	return 77;
}

#endif

```

`tests/fmin.c`:

```c
#include "testconfig.h"
#ifdef HAVE_FMIN
/* FIXME: not declared for fpu version */
double fmin(double, double);
#define TEST_FUNC_FF_F __MATH_PRECNAME(fmin)
#include "testdriver.h"


static test_ff_f_data const fmin_data[] = {
	{ __LINE__, HEXCONSTE(6.0, 0x4001, 0xc0000000L, 0x00000000L), HEXCONSTE(5.0, 0x4001, 0xa0000000L, 0x00000000L), HEXCONSTE(5.0, 0x4001, 0xa0000000L, 0x00000000L), 0 },
	{ __LINE__, ZERO_P, ZERO_P, ZERO_P, 0 },
	{ __LINE__, HEXCONSTE(0.1, 0x3ffb, 0xccccccccL, 0xcccccccdL), HEXCONSTE(0.2, 0x3ffc, 0xccccccccL, 0xcccccccdL), HEXCONSTE(0.1, 0x3ffb, 0xccccccccL, 0xcccccccdL), 0 },
	{ __LINE__, HEXCONSTE(-0.1, 0xbffb, 0xccccccccL, 0xcccccccdL), HEXCONSTE(-0.2, 0xbffc, 0xccccccccL, 0xcccccccdL), HEXCONSTE(-0.2, 0xbffc, 0xccccccccL, 0xcccccccdL), 0 },
	{ __LINE__, HEXCONSTE(-0.1, 0xbffb, 0xccccccccL, 0xcccccccdL), HEXCONSTE(0.2, 0x3ffc, 0xccccccccL, 0xcccccccdL), HEXCONSTE(-0.1, 0xbffb, 0xccccccccL, 0xcccccccdL), 0 },
	{ __LINE__, HEXCONSTE(0.1, 0x3ffb, 0xccccccccL, 0xcccccccdL), HEXCONSTE(0.2, 0x3ffc, 0xccccccccL, 0xcccccccdL), HEXCONSTE(0.1, 0x3ffb, 0xccccccccL, 0xcccccccdL), 0 },
	{ __LINE__, HEXCONSTE(0.1, 0x3ffb, 0xccccccccL, 0xcccccccdL), HEXCONSTE(-0.2, 0xbffc, 0xccccccccL, 0xcccccccdL), HEXCONSTE(-0.2, 0xbffc, 0xccccccccL, 0xcccccccdL), 0 },
	{ __LINE__, HEXCONSTE(1e10, 0x4020, 0x9502f900L, 0x00000000L), HEXCONSTE(1.1e10, 0x4020, 0xa3e9ab80L, 0x00000000L), HEXCONSTE(1e10, 0x4020, 0x9502f900L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1e10, 0xc020, 0x9502f900L, 0x00000000L), HEXCONSTE(-1.1e10, 0xc020, 0xa3e9ab80L, 0x00000000L), HEXCONSTE(-1.1e10, 0xc020, 0xa3e9ab80L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1e-10, 0x3fdd, 0xdbe6feceL, 0xbdedd5bfL), HEXCONSTE(1.1e-10, 0x3fdd, 0xf1e47eb0L, 0x37526b1fL), HEXCONSTE(1e-10, 0x3fdd, 0xdbe6feceL, 0xbdedd5bfL), 0 },

	{ __LINE__, ZERO_P, ZERO_P, ZERO_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_M, ZERO_P, ZERO_P, NO_INEXACT_EXCEPTION|FLAG_IGNORE_ZEROSIGN },
	{ __LINE__, ZERO_P, ZERO_M, ZERO_P, NO_INEXACT_EXCEPTION|FLAG_IGNORE_ZEROSIGN },
	{ __LINE__, ZERO_M, ZERO_M, ZERO_M, NO_INEXACT_EXCEPTION|FLAG_FAIL_ARANYM2 },
	{ __LINE__, HEXCONSTE(9, 0x4002, 0x90000000L, 0x00000000L), ZERO_P, ZERO_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-9, 0xc002, 0x90000000L, 0x00000000L), ZERO_P, HEXCONSTE(-9, 0xc002, 0x90000000L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_P, HEXCONSTE(9, 0x4002, 0x90000000L, 0x00000000L), ZERO_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_P, HEXCONSTE(-9, 0xc002, 0x90000000L, 0x00000000L), HEXCONSTE(-9, 0xc002, 0x90000000L, 0x00000000L), NO_INEXACT_EXCEPTION },

	{ __LINE__, INF_P, HEXCONSTE(9, 0x4002, 0x90000000L, 0x00000000L), HEXCONSTE(9, 0x4002, 0x90000000L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, INF_P, HEXCONSTE(-9, 0xc002, 0x90000000L, 0x00000000L), HEXCONSTE(-9, 0xc002, 0x90000000L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(9, 0x4002, 0x90000000L, 0x00000000L), INF_P, HEXCONSTE(9, 0x4002, 0x90000000L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-9, 0xc002, 0x90000000L, 0x00000000L), INF_P, HEXCONSTE(-9, 0xc002, 0x90000000L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_P, INF_P, ZERO_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_M, INF_P, ZERO_M, NO_INEXACT_EXCEPTION|FLAG_FAIL_ARANYM2 },
	{ __LINE__, INF_P, ZERO_P, ZERO_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, INF_P, ZERO_M, ZERO_M, NO_INEXACT_EXCEPTION|FLAG_FAIL_ARANYM2 },

	{ __LINE__, INF_M, HEXCONSTE(9, 0x4002, 0x90000000L, 0x00000000L), INF_M, NO_INEXACT_EXCEPTION },
	{ __LINE__, INF_M, HEXCONSTE(-9, 0xc002, 0x90000000L, 0x00000000L), INF_M, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(9, 0x4002, 0x90000000L, 0x00000000L), INF_M, INF_M, NO_INEXACT_EXCEPTION|FLAG_FAIL_ARANYM }, /* FIXME: fcmp/fjun problem? */
	{ __LINE__, HEXCONSTE(-9, 0xc002, 0x90000000L, 0x00000000L), INF_M, INF_M, NO_INEXACT_EXCEPTION|FLAG_FAIL_ARANYM }, /* FIXME: fcmp/fjun problem? */
	{ __LINE__, ZERO_P, INF_M, INF_M, NO_INEXACT_EXCEPTION|FLAG_FAIL_ARANYM }, /* FIXME: fcmp/fjun problem? */
	{ __LINE__, ZERO_M, INF_M, INF_M, NO_INEXACT_EXCEPTION|FLAG_FAIL_ARANYM }, /* FIXME: fcmp/fjun problem? */
	{ __LINE__, INF_M, ZERO_P, INF_M, NO_INEXACT_EXCEPTION },
	{ __LINE__, INF_M, ZERO_M, INF_M, NO_INEXACT_EXCEPTION },

	/* If one argument is a NaN, the other argument is returned. */
	{ __LINE__, ZERO_P, QNAN_P, ZERO_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_M, QNAN_P, ZERO_M, NO_INEXACT_EXCEPTION|FLAG_FAIL_ARANYM2 },
	{ __LINE__, HEXCONSTE(9, 0x4002, 0x90000000L, 0x00000000L), QNAN_P, HEXCONSTE(9, 0x4002, 0x90000000L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-9, 0xc002, 0x90000000L, 0x00000000L), QNAN_P, HEXCONSTE(-9, 0xc002, 0x90000000L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_P, ZERO_P, ZERO_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_P, ZERO_M, ZERO_M, NO_INEXACT_EXCEPTION|FLAG_FAIL_ARANYM2 },
	{ __LINE__, QNAN_P, HEXCONSTE(9, 0x4002, 0x90000000L, 0x00000000L), HEXCONSTE(9, 0x4002, 0x90000000L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_P, HEXCONSTE(-9, 0xc002, 0x90000000L, 0x00000000L), HEXCONSTE(-9, 0xc002, 0x90000000L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, INF_P, QNAN_P, INF_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, INF_M, QNAN_P, INF_M, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_P, INF_P, INF_P, NO_INEXACT_EXCEPTION|FLAG_FAIL_ARANYM }, /* FIXME: fcmp/fjun problem? */
	{ __LINE__, QNAN_P, INF_M, INF_M, NO_INEXACT_EXCEPTION|FLAG_FAIL_ARANYM }, /* FIXME: fcmp/fjun problem? */

	/* If both arguments are NaN, a NaN is returned. */
	{ __LINE__, QNAN_P, QNAN_P, QNAN_P, NO_INEXACT_EXCEPTION },
};

int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_ff_f(fmin_data, ARRAY_SIZE(fmin_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

#else

int main(void)
{
	return 77;
}

#endif

```

`tests/fmod.c`:

```c
#include "testconfig.h"
#define TEST_FUNC_FF_F __MATH_PRECNAME(fmod)
#include "testdriver.h"


static test_ff_f_data const fmod_data[] = {
	/* fmod (+0, y) == +0 for y != 0.  */
	{ __LINE__, ZERO_P, HEXCONSTE(3, 0x4000, 0xc0000000L, 0x00000000L), ZERO_P, 0 },
	{ __LINE__, ZERO_P, SUBNORM_P, ZERO_P, FLAG_SUBNORM },
	{ __LINE__, ZERO_P, SUBNORM_M, ZERO_P, FLAG_SUBNORM },
	{ __LINE__, ZERO_P, MIN_P, ZERO_P, FLAG_MINVAL },
	{ __LINE__, ZERO_P, MIN_M, ZERO_P, FLAG_MINVAL },
	{ __LINE__, ZERO_P, MAX_P, ZERO_P, 0 },
	{ __LINE__, ZERO_P, MAX_M, ZERO_P, 0 },
	
	/* fmod (-0, y) == -0 for y != 0.  */
	{ __LINE__, ZERO_M, HEXCONSTE(3, 0x4000, 0xc0000000L, 0x00000000L), ZERO_M, FLAG_FAIL_X87 },
	{ __LINE__, ZERO_M, SUBNORM_P, ZERO_M, FLAG_SUBNORM },
	{ __LINE__, ZERO_M, SUBNORM_M, ZERO_M, FLAG_SUBNORM },
	{ __LINE__, ZERO_M, MIN_P, ZERO_M, FLAG_MINVAL },
	{ __LINE__, ZERO_M, MIN_M, ZERO_M, FLAG_MINVAL },
	{ __LINE__, ZERO_M, MAX_P, ZERO_M, FLAG_FAIL_STONX },
	{ __LINE__, ZERO_M, MAX_M, ZERO_M, FLAG_FAIL_STONX },
	
	/* fmod (+inf, y) == qNaN plus invalid exception.  */
	{ __LINE__, INF_P, HEXCONSTE(3, 0x4000, 0xc0000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__, INF_P, HEXCONSTE(-1.1, 0xbfff, 0x8cccccccL, 0xcccccccdL), QNAN_P, 0 },
	{ __LINE__, INF_P, ZERO_P, QNAN_P, 0 },
	{ __LINE__, INF_P, ZERO_M, QNAN_P, 0 },
	{ __LINE__, INF_P, SUBNORM_P, QNAN_P, FLAG_SUBNORM },
	{ __LINE__, INF_P, MIN_P, QNAN_P, 0 },
	{ __LINE__, INF_P, MAX_P, QNAN_P, 0 },
	{ __LINE__, INF_P, INF_P, QNAN_P, 0 },
	{ __LINE__, INF_P, INF_M, QNAN_P, 0 },

	/* fmod (-inf, y) == qNaN plus invalid exception.  */
	{ __LINE__, INF_M, HEXCONSTE(3, 0x4000, 0xc0000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__, INF_M, HEXCONSTE(-1.1, 0xbfff, 0x8cccccccL, 0xcccccccdL), QNAN_P, 0 },
	{ __LINE__, INF_M, ZERO_P, QNAN_P, 0 },
	{ __LINE__, INF_M, ZERO_M, QNAN_P, 0 },
	{ __LINE__, INF_M, SUBNORM_P, QNAN_P, FLAG_SUBNORM },
	{ __LINE__, INF_M, MIN_P, QNAN_P, 0 },
	{ __LINE__, INF_M, MAX_P, QNAN_P, 0 },
	{ __LINE__, INF_M, INF_P, QNAN_P, 0 },
	{ __LINE__, INF_M, INF_M, QNAN_P, 0 },

	/* fmod (x, +0) == qNaN plus invalid exception.  */
	{ __LINE__, HEXCONSTE(3, 0x4000, 0xc0000000L, 0x00000000L), ZERO_P, QNAN_P, 0 },
	{ __LINE__, HEXCONSTE(-1.1, 0xbfff, 0x8cccccccL, 0xcccccccdL), ZERO_P, QNAN_P, 0 },
	{ __LINE__, ZERO_P, ZERO_P, QNAN_P, 0 },
	{ __LINE__, ZERO_M, ZERO_P, QNAN_P, 0 },
	{ __LINE__, SUBNORM_P, ZERO_P, QNAN_P, FLAG_SUBNORM },
	{ __LINE__, MIN_P, ZERO_P, QNAN_P, 0 },
	{ __LINE__, MAX_P, ZERO_P, QNAN_P, 0 },

	/* fmod (x, -0) == qNaN plus invalid exception.  */
	{ __LINE__, HEXCONSTE(3, 0x4000, 0xc0000000L, 0x00000000L), ZERO_M, QNAN_P, 0 },
	{ __LINE__, HEXCONSTE(-1.1, 0xbfff, 0x8cccccccL, 0xcccccccdL), ZERO_M, QNAN_P, 0 },
	{ __LINE__, ZERO_P, ZERO_M, QNAN_P, 0 },
	{ __LINE__, ZERO_M, ZERO_M, QNAN_P, 0 },
	{ __LINE__, SUBNORM_P, ZERO_M, QNAN_P, FLAG_SUBNORM },
	{ __LINE__, MIN_P, ZERO_M, QNAN_P, 0 },
	{ __LINE__, MAX_P, ZERO_M, QNAN_P, 0 },
	
	/* fmod (x, +inf) == x for x not infinite.  */
	{ __LINE__, ZERO_P, INF_P, ZERO_P, FLAG_FAIL_ARANYM|FLAG_FAIL_STONX|FLAG_XFAIL_LINUX },
	{ __LINE__, ZERO_M, INF_P, ZERO_M, FLAG_FAIL_ARANYM|FLAG_FAIL_STONX|FLAG_XFAIL_LINUX },
	{ __LINE__, SUBNORM_P, INF_P, SUBNORM_P, FLAG_SUBNORM },
	{ __LINE__, MIN_P, INF_P, MIN_P, FLAG_MINVAL },
	{ __LINE__, MAX_P, INF_P, MAX_P, FLAG_MINVAL },
	{ __LINE__, HEXCONSTE(3.0, 0x4000, 0xc0000000L, 0x00000000L), INF_P, HEXCONSTE(3.0, 0x4000, 0xc0000000L, 0x00000000L), FLAG_FAIL_ARANYM|FLAG_FAIL_STONX|FLAG_XFAIL_LINUX },

	/* fmod (x, -inf) == x for x not infinite.  */
	{ __LINE__, ZERO_P, INF_M, ZERO_P, FLAG_FAIL_ARANYM|FLAG_FAIL_STONX|FLAG_XFAIL_LINUX },
	{ __LINE__, ZERO_M, INF_M, ZERO_M, FLAG_FAIL_ARANYM|FLAG_FAIL_STONX|FLAG_XFAIL_LINUX },
	{ __LINE__, SUBNORM_P, INF_M, SUBNORM_P, FLAG_SUBNORM },
	{ __LINE__, MIN_P, INF_M, MIN_P, FLAG_MINVAL },
	{ __LINE__, MAX_P, INF_M, MAX_P, FLAG_MINVAL },
	{ __LINE__, HEXCONSTE(3.0, 0x4000, 0xc0000000L, 0x00000000L), INF_M, HEXCONSTE(3.0, 0x4000, 0xc0000000L, 0x00000000L), FLAG_FAIL_ARANYM|FLAG_FAIL_STONX|FLAG_XFAIL_LINUX },
	
	{ __LINE__, ZERO_P, QNAN_P, QNAN_P, 0 },
	{ __LINE__, ZERO_P, QNAN_M, QNAN_P, 0 },
	{ __LINE__, ZERO_M, QNAN_P, QNAN_P, 0 },
	{ __LINE__, ZERO_M, QNAN_M, QNAN_P, 0 },
	{ __LINE__, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), QNAN_P, QNAN_P, 0 },
	{ __LINE__, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), QNAN_M, QNAN_P, 0 },
	{ __LINE__, INF_P, QNAN_P, QNAN_P, 0 },
	{ __LINE__, INF_P, QNAN_M, QNAN_P, 0 },
	{ __LINE__, INF_M, QNAN_P, QNAN_P, 0 },
	{ __LINE__, INF_M, QNAN_M, QNAN_P, 0 },
	{ __LINE__, ZERO_P, SNAN_P, QNAN_P, 0 },
	{ __LINE__, ZERO_P, SNAN_M, QNAN_P, 0 },
	{ __LINE__, ZERO_M, SNAN_P, QNAN_P, 0 },
	{ __LINE__, ZERO_M, SNAN_M, QNAN_P, 0 },
	{ __LINE__, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), SNAN_P, QNAN_P, 0 },
	{ __LINE__, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), SNAN_M, QNAN_P, 0 },
	{ __LINE__, INF_P, SNAN_P, QNAN_P, 0 },
	{ __LINE__, INF_P, SNAN_M, QNAN_P, 0 },
	{ __LINE__, INF_M, SNAN_P, QNAN_P, 0 },
	{ __LINE__, INF_M, SNAN_M, QNAN_P, 0 },
	{ __LINE__, QNAN_P, ZERO_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, ZERO_P, QNAN_P, 0 },
	{ __LINE__, QNAN_P, ZERO_M, QNAN_P, 0 },
	{ __LINE__, QNAN_M, ZERO_M, QNAN_P, 0 },
	{ __LINE__, QNAN_P, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__, QNAN_M, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__, QNAN_P, INF_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, INF_P, QNAN_P, 0 },
	{ __LINE__, QNAN_P, INF_M, QNAN_P, 0 },
	{ __LINE__, QNAN_M, INF_M, QNAN_P, 0 },
	{ __LINE__, SNAN_P, ZERO_P, QNAN_P, 0 },
	{ __LINE__, SNAN_M, ZERO_P, QNAN_P, 0 },
	{ __LINE__, SNAN_P, ZERO_M, QNAN_P, 0 },
	{ __LINE__, SNAN_M, ZERO_M, QNAN_P, 0 },
	{ __LINE__, SNAN_P, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__, SNAN_M, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__, SNAN_P, INF_P, QNAN_P, 0 },
	{ __LINE__, SNAN_M, INF_P, QNAN_P, 0 },
	{ __LINE__, SNAN_P, INF_M, QNAN_P, 0 },
	{ __LINE__, SNAN_M, INF_M, QNAN_P, 0 },
	{ __LINE__, QNAN_P, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_P, QNAN_M, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_M, QNAN_P, 0 },
	{ __LINE__, QNAN_P, SNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_P, SNAN_M, QNAN_P, 0 },
	{ __LINE__, QNAN_M, SNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, SNAN_M, QNAN_P, 0 },
	{ __LINE__, SNAN_P, QNAN_P, QNAN_P, 0 },
	{ __LINE__, SNAN_P, QNAN_M, QNAN_P, 0 },
	{ __LINE__, SNAN_M, QNAN_P, QNAN_P, 0 },
	{ __LINE__, SNAN_M, QNAN_M, QNAN_P, 0 },
	{ __LINE__, SNAN_P, SNAN_P, QNAN_P, 0 },
	{ __LINE__, SNAN_P, SNAN_M, QNAN_P, 0 },
	{ __LINE__, SNAN_M, SNAN_P, QNAN_P, 0 },
	{ __LINE__, SNAN_M, SNAN_M, QNAN_P, 0 },
	
	{ __LINE__, HEXCONSTE(6.5, 0x4001, 0xd0000000L, 0x00000000L), HEXCONSTE(2.25L, 0x4000, 0x90000000L, 0x00000000L), HEXCONSTE(2.0L, 0x4000, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-6.5, 0xc001, 0xd0000000L, 0x00000000L), HEXCONSTE(2.25L, 0x4000, 0x90000000L, 0x00000000L), HEXCONSTE(-2.0L, 0xc000, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(6.5, 0x4001, 0xd0000000L, 0x00000000L), HEXCONSTE(-2.25L, 0xc000, 0x90000000L, 0x00000000L), HEXCONSTE(2.0L, 0x4000, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-6.5, 0xc001, 0xd0000000L, 0x00000000L), HEXCONSTE(-2.25L, 0xc000, 0x90000000L, 0x00000000L), HEXCONSTE(-2.0L, 0xc000, 0x80000000L, 0x00000000L), 0 },
	
	{ __LINE__, MAX_P, MAX_P, ZERO_P, 0 },
	{ __LINE__, MAX_P, MAX_M, ZERO_P, 0 },
	{ __LINE__, MAX_P, MIN_P, ZERO_P, FLAG_MINVAL },
	{ __LINE__, MAX_P, MIN_M, ZERO_P, FLAG_MINVAL },
	{ __LINE__, MAX_P, SUBNORM_P, ZERO_P, FLAG_SUBNORM },
	{ __LINE__, MAX_P, SUBNORM_M, ZERO_P, FLAG_SUBNORM },
	{ __LINE__, MAX_M, MAX_P, ZERO_M, FLAG_FAIL_STONX },
	{ __LINE__, MAX_M, MAX_M, ZERO_M, FLAG_FAIL_STONX },
	{ __LINE__, MAX_M, MIN_P, ZERO_M, FLAG_MINVAL },
	{ __LINE__, MAX_M, MIN_M, ZERO_M, FLAG_MINVAL },
	{ __LINE__, MAX_M, SUBNORM_P, ZERO_M, FLAG_SUBNORM },
	{ __LINE__, MAX_M, SUBNORM_M, ZERO_M, FLAG_SUBNORM },
	
	{ __LINE__, MIN_P, MAX_P, MIN_P, FLAG_MINVAL },
	{ __LINE__, MIN_P, MAX_M, MIN_P, FLAG_MINVAL },
	{ __LINE__, MIN_P, MIN_P, ZERO_P, FLAG_MINVAL },
	{ __LINE__, MIN_P, MIN_M, ZERO_P, FLAG_MINVAL },
	{ __LINE__, MIN_P, SUBNORM_P, ZERO_P, FLAG_MINVAL },
	{ __LINE__, MIN_P, SUBNORM_M, ZERO_P, FLAG_MINVAL },
	{ __LINE__, MIN_M, MAX_P, MIN_M, FLAG_MINVAL },
	{ __LINE__, MIN_M, MAX_M, MIN_M, FLAG_MINVAL },
	{ __LINE__, MIN_M, MIN_P, ZERO_M, FLAG_MINVAL },
	{ __LINE__, MIN_M, MIN_M, ZERO_M, FLAG_MINVAL },
	{ __LINE__, MIN_M, SUBNORM_P, ZERO_M, FLAG_MINVAL },
	{ __LINE__, MIN_M, SUBNORM_M, ZERO_M, FLAG_MINVAL },
	
	{ __LINE__, SUBNORM_P, MAX_P, SUBNORM_P, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_P, MAX_M, SUBNORM_P, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_P, MIN_P, SUBNORM_P, FLAG_MINVAL },
	{ __LINE__, SUBNORM_P, MIN_M, SUBNORM_P, FLAG_MINVAL },
	{ __LINE__, SUBNORM_P, SUBNORM_P, ZERO_P, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_P, SUBNORM_M, ZERO_P, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, MAX_P, SUBNORM_M, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, MAX_M, SUBNORM_M, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, MIN_P, SUBNORM_M, FLAG_MINVAL },
	{ __LINE__, SUBNORM_M, MIN_M, SUBNORM_M, FLAG_MINVAL },
	{ __LINE__, SUBNORM_M, SUBNORM_P, ZERO_M, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, SUBNORM_M, ZERO_M, FLAG_SUBNORM },
	
	{ __LINE__, HEXCONSTE(1.70141183460469231732e+38, 0x407e, 0x80000000L, 0x00000000L), HEXCONSTE(4.20389539297445121277e-45, 0x3f6b, 0xc0000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), FLAG_FAIL_ARANYM|FLAG_FAIL_STONX },
	{ __LINE__, HEXCONSTE(1.70141183460469231732e+38, 0x407e, 0x80000000L, 0x00000000L), HEXCONSTE(-4.20389539297445121277e-45, 0xbf6b, 0xc0000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), FLAG_FAIL_ARANYM|FLAG_FAIL_STONX },
	{ __LINE__, HEXCONSTE(1.70141183460469231732e+38, 0x407e, 0x80000000L, 0x00000000L), HEXCONSTE(8.40779078594890242554e-45, 0x3f6c, 0xc0000000L, 0x00000000L), HEXCONSTE(5.60519385729926828369e-45, 0x3f6c, 0x80000000L, 0x00000000L), FLAG_FAIL_ARANYM|FLAG_FAIL_STONX },
	{ __LINE__, HEXCONSTE(1.70141183460469231732e+38, 0x407e, 0x80000000L, 0x00000000L), HEXCONSTE(-8.40779078594890242554e-45, 0xbf6c, 0xc0000000L, 0x00000000L), HEXCONSTE(5.60519385729926828369e-45, 0x3f6c, 0x80000000L, 0x00000000L), FLAG_FAIL_ARANYM|FLAG_FAIL_STONX },
	{ __LINE__, HEXCONSTE(1.70141183460469231732e+38, 0x407e, 0x80000000L, 0x00000000L), HEXCONSTE(3.52648305246686252391e-38, 0x3f82, 0xc0000000L, 0x00000000L), HEXCONSTE(2.35098870164457501594e-38, 0x3f82, 0x80000000L, 0x00000000L), FLAG_FAIL_ARANYM|FLAG_FAIL_STONX },
	{ __LINE__, HEXCONSTE(1.70141183460469231732e+38, 0x407e, 0x80000000L, 0x00000000L), HEXCONSTE(-3.52648305246686252391e-38, 0xbf82, 0xc0000000L, 0x00000000L), HEXCONSTE(2.35098870164457501594e-38, 0x3f82, 0x80000000L, 0x00000000L), FLAG_FAIL_ARANYM|FLAG_FAIL_STONX },
	{ __LINE__, HEXCONSTE(-1.70141183460469231732e+38, 0xc07e, 0x80000000L, 0x00000000L), HEXCONSTE(4.20389539297445121277e-45, 0x3f6b, 0xc0000000L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), FLAG_FAIL_ARANYM|FLAG_FAIL_STONX },
	{ __LINE__, HEXCONSTE(-1.70141183460469231732e+38, 0xc07e, 0x80000000L, 0x00000000L), HEXCONSTE(-4.20389539297445121277e-45, 0xbf6b, 0xc0000000L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), FLAG_FAIL_ARANYM|FLAG_FAIL_STONX },
	{ __LINE__, HEXCONSTE(-1.70141183460469231732e+38, 0xc07e, 0x80000000L, 0x00000000L), HEXCONSTE(8.40779078594890242554e-45, 0x3f6c, 0xc0000000L, 0x00000000L), HEXCONSTE(-5.60519385729926828369e-45, 0xbf6c, 0x80000000L, 0x00000000L), FLAG_FAIL_ARANYM|FLAG_FAIL_STONX },
	{ __LINE__, HEXCONSTE(-1.70141183460469231732e+38, 0xc07e, 0x80000000L, 0x00000000L), HEXCONSTE(-8.40779078594890242554e-45, 0xbf6c, 0xc0000000L, 0x00000000L), HEXCONSTE(-5.60519385729926828369e-45, 0xbf6c, 0x80000000L, 0x00000000L), FLAG_FAIL_ARANYM|FLAG_FAIL_STONX },
	{ __LINE__, HEXCONSTE(-1.70141183460469231732e+38, 0xc07e, 0x80000000L, 0x00000000L), HEXCONSTE(3.52648305246686252391e-38, 0x3f82, 0xc0000000L, 0x00000000L), HEXCONSTE(-2.35098870164457501594e-38, 0xbf82, 0x80000000L, 0x00000000L), FLAG_FAIL_ARANYM|FLAG_FAIL_STONX },
	{ __LINE__, HEXCONSTE(-1.70141183460469231732e+38, 0xc07e, 0x80000000L, 0x00000000L), HEXCONSTE(-3.52648305246686252391e-38, 0xbf82, 0xc0000000L, 0x00000000L), HEXCONSTE(-2.35098870164457501594e-38, 0xbf82, 0x80000000L, 0x00000000L), FLAG_FAIL_ARANYM|FLAG_FAIL_STONX },
	{ __LINE__, HEXCONSTE(8.98846567431157953865e+307, 0x43fe, 0x80000000L, 0x00000000L), HEXCONSTE(1.48219693752373963253e-323, 0x3bce, 0xc0000000L, 0x00000000L), HEXCONSTE(9.88131291682493088353e-324, 0x3bce, 0x80000000L, 0x00000000L), FLAG_FAIL_ARANYM|FLAG_FAIL_STONX },
	{ __LINE__, HEXCONSTE(8.98846567431157953865e+307, 0x43fe, 0x80000000L, 0x00000000L), HEXCONSTE(-1.48219693752373963253e-323, 0xbbce, 0xc0000000L, 0x00000000L), HEXCONSTE(9.88131291682493088353e-324, 0x3bce, 0x80000000L, 0x00000000L), FLAG_FAIL_ARANYM|FLAG_FAIL_STONX },
	{ __LINE__, HEXCONSTE(8.98846567431157953865e+307, 0x43fe, 0x80000000L, 0x00000000L), HEXCONSTE(2.96439387504747926506e-323, 0x3bcf, 0xc0000000L, 0x00000000L), HEXCONSTE(9.88131291682493088353e-324, 0x3bce, 0x80000000L, 0x00000000L), FLAG_FAIL_ARANYM|FLAG_FAIL_STONX },
	{ __LINE__, HEXCONSTE(8.98846567431157953865e+307, 0x43fe, 0x80000000L, 0x00000000L), HEXCONSTE(-2.96439387504747926506e-323, 0xbbcf, 0xc0000000L, 0x00000000L), HEXCONSTE(9.88131291682493088353e-324, 0x3bce, 0x80000000L, 0x00000000L), FLAG_FAIL_ARANYM|FLAG_FAIL_STONX },
	{ __LINE__, HEXCONSTE(8.98846567431157953865e+307, 0x43fe, 0x80000000L, 0x00000000L), HEXCONSTE(6.67522157552160414927e-308, 0x3c02, 0xc0000000L, 0x00000000L), HEXCONSTE(4.45014771701440276618e-308, 0x3c02, 0x80000000L, 0x00000000L), FLAG_FAIL_ARANYM|FLAG_FAIL_STONX },
	{ __LINE__, HEXCONSTE(8.98846567431157953865e+307, 0x43fe, 0x80000000L, 0x00000000L), HEXCONSTE(-6.67522157552160414927e-308, 0xbc02, 0xc0000000L, 0x00000000L), HEXCONSTE(4.45014771701440276618e-308, 0x3c02, 0x80000000L, 0x00000000L), FLAG_FAIL_ARANYM|FLAG_FAIL_STONX },
	{ __LINE__, HEXCONSTE(-8.98846567431157953865e+307, 0xc3fe, 0x80000000L, 0x00000000L), HEXCONSTE(1.48219693752373963253e-323, 0x3bce, 0xc0000000L, 0x00000000L), HEXCONSTE(-9.88131291682493088353e-324, 0xbbce, 0x80000000L, 0x00000000L), FLAG_FAIL_ARANYM|FLAG_FAIL_STONX },
	{ __LINE__, HEXCONSTE(-8.98846567431157953865e+307, 0xc3fe, 0x80000000L, 0x00000000L), HEXCONSTE(-1.48219693752373963253e-323, 0xbbce, 0xc0000000L, 0x00000000L), HEXCONSTE(-9.88131291682493088353e-324, 0xbbce, 0x80000000L, 0x00000000L), FLAG_FAIL_ARANYM|FLAG_FAIL_STONX },
	{ __LINE__, HEXCONSTE(-8.98846567431157953865e+307, 0xc3fe, 0x80000000L, 0x00000000L), HEXCONSTE(2.96439387504747926506e-323, 0x3bcf, 0xc0000000L, 0x00000000L), HEXCONSTE(-9.88131291682493088353e-324, 0xbbce, 0x80000000L, 0x00000000L), FLAG_FAIL_ARANYM|FLAG_FAIL_STONX },
	{ __LINE__, HEXCONSTE(-8.98846567431157953865e+307, 0xc3fe, 0x80000000L, 0x00000000L), HEXCONSTE(-2.96439387504747926506e-323, 0xbbcf, 0xc0000000L, 0x00000000L), HEXCONSTE(-9.88131291682493088353e-324, 0xbbce, 0x80000000L, 0x00000000L), FLAG_FAIL_ARANYM|FLAG_FAIL_STONX },
	{ __LINE__, HEXCONSTE(-8.98846567431157953865e+307, 0xc3fe, 0x80000000L, 0x00000000L), HEXCONSTE(6.67522157552160414927e-308, 0x3c02, 0xc0000000L, 0x00000000L), HEXCONSTE(-4.45014771701440276618e-308, 0xbc02, 0x80000000L, 0x00000000L), FLAG_FAIL_ARANYM|FLAG_FAIL_STONX },
	{ __LINE__, HEXCONSTE(-8.98846567431157953865e+307, 0xc3fe, 0x80000000L, 0x00000000L), HEXCONSTE(-6.67522157552160414927e-308, 0xbc02, 0xc0000000L, 0x00000000L), HEXCONSTE(-4.45014771701440276618e-308, 0xbc02, 0x80000000L, 0x00000000L), FLAG_FAIL_ARANYM|FLAG_FAIL_STONX },
#if __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(5.94865747678615882543e+4931, 0x7ffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.09355985956474238076e-4950, 0x0000, 0x00000000L, 0x00000003L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000002L), FLAG_FAIL_ARANYM|FLAG_FAIL_STONX },
	{ __LINE__, HEXCONSTE(5.94865747678615882543e+4931, 0x7ffe, 0x80000000L, 0x00000000L), HEXCONSTE(-1.09355985956474238076e-4950, 0x8000, 0x00000000L, 0x00000003L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000002L), FLAG_FAIL_ARANYM|FLAG_FAIL_STONX },
	{ __LINE__, HEXCONSTE(5.94865747678615882543e+4931, 0x7ffe, 0x80000000L, 0x00000000L), HEXCONSTE(2.18711971912948476152e-4950, 0x0000, 0x00000000L, 0x00000006L), HEXCONSTE(1.45807981275298984101e-4950, 0x0000, 0x00000000L, 0x00000002L), FLAG_FAIL_ARANYM|FLAG_FAIL_STONX },
	{ __LINE__, HEXCONSTE(5.94865747678615882543e+4931, 0x7ffe, 0x80000000L, 0x00000000L), HEXCONSTE(-2.18711971912948476152e-4950, 0x8000, 0x00000000L, 0x00000006L), HEXCONSTE(1.45807981275298984101e-4950, 0x0000, 0x00000000L, 0x00000002L), FLAG_FAIL_ARANYM|FLAG_FAIL_STONX },
#else
	{ __LINE__, HEXCONSTE(5.94865747678615882543e+4931, 0x7ffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.09355985956474238076e-4950, 0x0000, 0x00000000L, 0x00000003L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), FLAG_FAIL_ARANYM|FLAG_FAIL_STONX },
	{ __LINE__, HEXCONSTE(5.94865747678615882543e+4931, 0x7ffe, 0x80000000L, 0x00000000L), HEXCONSTE(-1.09355985956474238076e-4950, 0x8000, 0x00000000L, 0x00000003L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), FLAG_FAIL_ARANYM|FLAG_FAIL_STONX },
	{ __LINE__, HEXCONSTE(5.94865747678615882543e+4931, 0x7ffe, 0x80000000L, 0x00000000L), HEXCONSTE(2.18711971912948476152e-4950, 0x0000, 0x00000000L, 0x00000006L), HEXCONSTE(1.45807981275298984101e-4950, 0x0000, 0x00000000L, 0x00000004L), FLAG_FAIL_ARANYM|FLAG_FAIL_STONX },
	{ __LINE__, HEXCONSTE(5.94865747678615882543e+4931, 0x7ffe, 0x80000000L, 0x00000000L), HEXCONSTE(-2.18711971912948476152e-4950, 0x8000, 0x00000000L, 0x00000006L), HEXCONSTE(1.45807981275298984101e-4950, 0x0000, 0x00000000L, 0x00000004L), FLAG_FAIL_ARANYM|FLAG_FAIL_STONX },
#endif
	{ __LINE__, HEXCONSTE(5.94865747678615882543e+4931, 0x7ffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.00863094293362805188e-4931, 0x0002, 0xc0000000L, 0x00000000L), HEXCONSTE(6.72420628622418701253e-4932, 0x0002, 0x80000000L, 0x00000000L), FLAG_FAIL_ARANYM|FLAG_FAIL_STONX },
	{ __LINE__, HEXCONSTE(5.94865747678615882543e+4931, 0x7ffe, 0x80000000L, 0x00000000L), HEXCONSTE(-1.00863094293362805188e-4931, 0x8002, 0xc0000000L, 0x00000000L), HEXCONSTE(6.72420628622418701253e-4932, 0x0002, 0x80000000L, 0x00000000L), FLAG_FAIL_ARANYM|FLAG_FAIL_STONX },
#if __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(-5.94865747678615882543e+4931, 0xfffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.09355985956474238076e-4950, 0x0000, 0x00000000L, 0x00000003L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000002L), FLAG_FAIL_ARANYM|FLAG_FAIL_STONX },
	{ __LINE__, HEXCONSTE(-5.94865747678615882543e+4931, 0xfffe, 0x80000000L, 0x00000000L), HEXCONSTE(-1.09355985956474238076e-4950, 0x8000, 0x00000000L, 0x00000003L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000002L), FLAG_FAIL_ARANYM|FLAG_FAIL_STONX },
	{ __LINE__, HEXCONSTE(-5.94865747678615882543e+4931, 0xfffe, 0x80000000L, 0x00000000L), HEXCONSTE(2.18711971912948476152e-4950, 0x0000, 0x00000000L, 0x00000006L), HEXCONSTE(-1.45807981275298984101e-4950, 0x8000, 0x00000000L, 0x00000002L), FLAG_FAIL_ARANYM|FLAG_FAIL_STONX },
	{ __LINE__, HEXCONSTE(-5.94865747678615882543e+4931, 0xfffe, 0x80000000L, 0x00000000L), HEXCONSTE(-2.18711971912948476152e-4950, 0x8000, 0x00000000L, 0x00000006L), HEXCONSTE(-1.45807981275298984101e-4950, 0x8000, 0x00000000L, 0x00000002L), FLAG_FAIL_ARANYM|FLAG_FAIL_STONX },
#else
	{ __LINE__, HEXCONSTE(-5.94865747678615882543e+4931, 0xfffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.09355985956474238076e-4950, 0x0000, 0x00000000L, 0x00000003L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), FLAG_FAIL_ARANYM|FLAG_FAIL_STONX },
	{ __LINE__, HEXCONSTE(-5.94865747678615882543e+4931, 0xfffe, 0x80000000L, 0x00000000L), HEXCONSTE(-1.09355985956474238076e-4950, 0x8000, 0x00000000L, 0x00000003L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), FLAG_FAIL_ARANYM|FLAG_FAIL_STONX },
	{ __LINE__, HEXCONSTE(-5.94865747678615882543e+4931, 0xfffe, 0x80000000L, 0x00000000L), HEXCONSTE(2.18711971912948476152e-4950, 0x0000, 0x00000000L, 0x00000006L), HEXCONSTE(-1.45807981275298984101e-4950, 0x8000, 0x00000000L, 0x00000004L), FLAG_FAIL_ARANYM|FLAG_FAIL_STONX },
	{ __LINE__, HEXCONSTE(-5.94865747678615882543e+4931, 0xfffe, 0x80000000L, 0x00000000L), HEXCONSTE(-2.18711971912948476152e-4950, 0x8000, 0x00000000L, 0x00000006L), HEXCONSTE(-1.45807981275298984101e-4950, 0x8000, 0x00000000L, 0x00000004L), FLAG_FAIL_ARANYM|FLAG_FAIL_STONX },
#endif
	{ __LINE__, HEXCONSTE(-5.94865747678615882543e+4931, 0xfffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.00863094293362805188e-4931, 0x0002, 0xc0000000L, 0x00000000L), HEXCONSTE(-6.72420628622418701253e-4932, 0x8002, 0x80000000L, 0x00000000L), FLAG_FAIL_ARANYM|FLAG_FAIL_STONX },
	{ __LINE__, HEXCONSTE(-5.94865747678615882543e+4931, 0xfffe, 0x80000000L, 0x00000000L), HEXCONSTE(-1.00863094293362805188e-4931, 0x8002, 0xc0000000L, 0x00000000L), HEXCONSTE(-6.72420628622418701253e-4932, 0x8002, 0x80000000L, 0x00000000L), FLAG_FAIL_ARANYM|FLAG_FAIL_STONX },
	
	{ __LINE__, HEXCONSTE(1.17549421069244107549e-38, 0x3f80, 0xfffffe00L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), ZERO_P, 0 },
#ifndef TEST_FLOAT
	{ __LINE__, HEXCONSTE(2.22507385850720088902e-308, 0x3c00, 0xffffffffL, 0xfffff000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), ZERO_P, 0 },
#endif
#if defined TEST_LDOUBLE && LDBL_MIN_EXP <= -16381
	{ __LINE__, HEXCONSTE(3.36210314311209350590e-4932, 0x0000, 0x7fffffffL, 0xffffffffL), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), ZERO_P, 0 },
#endif
	{ __LINE__, HEXCONSTE(-1.00000000000000005551e+00, 0xbfff, 0x80000000L, 0x00000200L), HEXCONSTE(9.99999999999999944489e-01, 0x3ffe, 0xffffffffL, 0xfffffc00L), HEXCONSTE(-1.11022302462515654042e-16, 0xbfca, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE
	{ __LINE__, HEXCONSTE(9.99999999999999958367e-01, 0x3ffe, 0xffffffffL, 0xfffffd00L), HEXCONSTE(9.99999999999999944489e-01, 0x3ffe, 0xffffffffL, 0xfffffc00L), HEXCONSTE(1.38777878078144567553e-17, 0x3fc7, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-9.99999999999999958367e-01, 0xbffe, 0xffffffffL, 0xfffffd00L), HEXCONSTE(9.99999999999999944489e-01, 0x3ffe, 0xffffffffL, 0xfffffc00L), HEXCONSTE(-1.38777878078144567553e-17, 0xbfc7, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9.99999999999999958367e-01, 0x3ffe, 0xffffffffL, 0xfffffd00L), HEXCONSTE(-9.99999999999999944489e-01, 0xbffe, 0xffffffffL, 0xfffffc00L), HEXCONSTE(1.38777878078144567553e-17, 0x3fc7, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-9.99999999999999958367e-01, 0xbffe, 0xffffffffL, 0xfffffd00L), HEXCONSTE(-9.99999999999999944489e-01, 0xbffe, 0xffffffffL, 0xfffffc00L), HEXCONSTE(-1.38777878078144567553e-17, 0xbfc7, 0x80000000L, 0x00000000L), 0 },
#endif

	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(3.0, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.0, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(3.0, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.0, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0 },
};


int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_ff_f(fmod_data, ARRAY_SIZE(fmod_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

```

`tests/fmul.c`:

```c
#include "testconfig.h"
#define TEST_FUNC_FF_F __MATH_PRECNAME(wrap_mul)
static REAL TEST_FUNC_FF_F(REAL x, REAL y)
{
	return x * y;
}
#include "testdriver.h"



static test_ff_f_data const fmul_data[] = {
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-2.0, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(-2.0, 0xc000, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-2.0, 0xc000, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-2.0, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), ZERO_P, ZERO_P, 0 },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), ZERO_P, ZERO_P, FLAG_IGNORE_ZEROSIGN },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), ZERO_P, ZERO_P, FLAG_IGNORE_ZEROSIGN },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), ZERO_M, ZERO_P, FLAG_IGNORE_ZEROSIGN },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), INF_P, INF_P, 0 },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), INF_M, INF_M, 0 },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), INF_P, INF_P, 0 },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), INF_M, INF_M, 0 },
	{ __LINE__, ZERO_P, HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), ZERO_P, 0 },
	{ __LINE__, ZERO_P, HEXCONSTE(-2.0, 0xc000, 0x80000000L, 0x00000000L), ZERO_M, FLAG_FAIL_ARANYM2 },
	{ __LINE__, ZERO_M, HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), ZERO_M, FLAG_FAIL_ARANYM2 },
	{ __LINE__, ZERO_M, HEXCONSTE(-2.0, 0xc000, 0x80000000L, 0x00000000L), ZERO_P, 0 },
	{ __LINE__, ZERO_P, ZERO_P, ZERO_P, 0 },
	{ __LINE__, ZERO_P, ZERO_M, ZERO_M, FLAG_FAIL_ARANYM2 },
	{ __LINE__, ZERO_M, ZERO_P, ZERO_M, FLAG_FAIL_ARANYM2 },
	{ __LINE__, ZERO_M, ZERO_M, ZERO_P, 0 },
	{ __LINE__, ZERO_P, INF_P, QNAN_P, 0 },
	{ __LINE__, ZERO_P, INF_M, QNAN_P, 0 },
	{ __LINE__, ZERO_M, INF_P, QNAN_P, 0 },
	{ __LINE__, ZERO_M, INF_M, QNAN_P, 0 },
	{ __LINE__, INF_P, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__, INF_P, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__, INF_M, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), INF_M, 0 },
	{ __LINE__, INF_M, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), INF_M, 0 },
	{ __LINE__, INF_P, ZERO_P, QNAN_P, 0 },
	{ __LINE__, INF_P, ZERO_M, QNAN_P, 0 },
	{ __LINE__, INF_M, ZERO_P, QNAN_P, 0 },
	{ __LINE__, INF_M, ZERO_M, QNAN_P, 0 },
	{ __LINE__, INF_P, INF_P, INF_P, 0 },
	{ __LINE__, INF_P, INF_M, INF_M, 0 },
	{ __LINE__, INF_M, INF_P, INF_M, 0 },
	{ __LINE__, INF_M, INF_M, INF_P, 0 },

	{ __LINE__, ZERO_P, QNAN_P, QNAN_P, 0 },
	{ __LINE__, ZERO_P, QNAN_M, QNAN_P, 0 },
	{ __LINE__, ZERO_M, QNAN_P, QNAN_P, 0 },
	{ __LINE__, ZERO_M, QNAN_M, QNAN_P, 0 },
	{ __LINE__, INF_P, QNAN_P, QNAN_P, 0 },
	{ __LINE__, INF_P, QNAN_M, QNAN_M, 0 },
	{ __LINE__, INF_M, QNAN_P, QNAN_M, 0 },
	{ __LINE__, INF_M, QNAN_M, QNAN_P, 0 },
	{ __LINE__, QNAN_P, ZERO_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, ZERO_P, QNAN_P, 0 },
	{ __LINE__, QNAN_P, ZERO_M, QNAN_P, 0 },
	{ __LINE__, QNAN_M, ZERO_M, QNAN_P, 0 },
	{ __LINE__, QNAN_P, INF_P, QNAN_P, FLAG_FAIL_SOFTFLOAT }, /* returns Inf instead of NaN */
	{ __LINE__, QNAN_M, INF_P, QNAN_M, FLAG_FAIL_SOFTFLOAT }, /* returns Inf instead of NaN */
	{ __LINE__, QNAN_P, INF_M, QNAN_M, FLAG_FAIL_SOFTFLOAT }, /* returns Inf instead of NaN */
	{ __LINE__, QNAN_M, INF_M, QNAN_P, FLAG_FAIL_SOFTFLOAT }, /* returns Inf instead of NaN */
	{ __LINE__, QNAN_P, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_P, QNAN_M, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_M, QNAN_P, 0 },
	{ __LINE__, QNAN_P, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_P, QNAN_M, 0 },
	{ __LINE__, QNAN_P, QNAN_M, QNAN_M, 0 },
	{ __LINE__, QNAN_M, QNAN_M, QNAN_P, 0 },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), QNAN_P, QNAN_P, 0 },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), QNAN_M, QNAN_P, 0 },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), QNAN_P, QNAN_P, 0 },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), QNAN_M, QNAN_P, 0 },
	{ __LINE__, QNAN_P, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__, QNAN_M, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__, QNAN_P, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__, QNAN_M, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), QNAN_P, 0 },

	{ __LINE__, HEXCONST_PI, HEXCONSTE(3.0, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(9.42477796076937971576e+00, 0x4002, 0x96cbe3f9L, 0x990e91a8L), 0 },
	{ __LINE__, HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(1023, 0x4008, 0xffc00000L, 0x00000000L), HEXCONSTE(-1023, 0xc008, 0xffc00000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE("0x1p16382", 0x7ffd, 0x80000000L, 0x0L), HEXCONSTE("0x1p16383", 0x7ffe, 0x80000000L, 0x0L), 0 },
	{ __LINE__, HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE("0x1p16383", 0x7ffe, 0x80000000L, 0x0L), INF_P, 0 },
};

int main(int argc, char **argv)
{
	int status;
	
 	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_ff_f(fmul_data, ARRAY_SIZE(fmul_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

```

`tests/fneg.c`:

```c
#include "testconfig.h"
#define TEST_FUNC_F_F __MATH_PRECNAME(wrap_neg)
static REAL TEST_FUNC_F_F(REAL x)
{
	return -x;
}
#include "testdriver.h"



static test_f_f_data const fneg_data[] = {
	{ __LINE__, ZERO_P, ZERO_M, FLAG_FAIL_ARANYM2 },
	{ __LINE__, ZERO_M, ZERO_P, 0 },
	{ __LINE__, INF_P, INF_M, 0 },
	{ __LINE__, INF_M, INF_P, 0 },
	{ __LINE__, QNAN_P, QNAN_M, 0 },
	{ __LINE__, QNAN_M, QNAN_P, 0 },
	{ __LINE__, SNAN_P, QNAN_P, 0 },
	{ __LINE__, SNAN_M, QNAN_P, 0 },
	{ __LINE__, SUBNORM_P, SUBNORM_M, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, SUBNORM_P, FLAG_SUBNORM },
	{ __LINE__, MIN_M, MIN_P, FLAG_MINVAL },
	{ __LINE__, MIN_P, MIN_M, FLAG_MINVAL },
	{ __LINE__, MAX_M, MAX_P, 0 },
	{ __LINE__, MAX_P, MAX_M, 0 },

	{ __LINE__, HEXCONSTE(38.0, 0x4004, 0x98000000L, 0x00000000L), HEXCONSTE(-38.0, 0xc004, 0x98000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.718281828459045235360287471352662498, 0x4000, 0xadf85458L, 0xa2bb4a9aL), HEXCONSTE(-2.718281828459045235360287471352662498, 0xc000, 0xadf85458L, 0xa2bb4a9aL), 0 },
	{ __LINE__, HEXCONSTE(-2.718281828459045235360287471352662498, 0xc000, 0xadf85458L, 0xa2bb4a9aL), HEXCONSTE(2.718281828459045235360287471352662498, 0x4000, 0xadf85458L, 0xa2bb4a9aL), 0 },
	{ __LINE__, HEXCONSTE(-55, 0xc004, 0xdc000000L, 0x00000000L), HEXCONSTE(55, 0x4004, 0xdc000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1024, 0xc009, 0x80000000L, 0x00000000L), HEXCONSTE(1024, 0x4009, 0x80000000L, 0x00000000L), 0 },
};

int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_f_f(fneg_data, ARRAY_SIZE(fneg_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

```

`tests/fpclass.c`:

```c
#include "testconfig.h"
#if defined(HAVE_FPCLASSIFY) || defined(HAVE___FPCLASSIFY)
#ifdef HAVE___FPCLASSIFY
int __MATH_PRECNAME(__fpclassify)(REAL x);
#define TEST_FUNC_F_I __MATH_PRECNAME(__fpclassify)
#else
#define TEST_FUNC_F_I __MATH_PRECNAME(fpclassify)
#endif
#include "testdriver.h"

/* make sure we don't test the builtin */
#undef fpclassify
#undef __fpclassify

static test_f_i_data const fpclassify_data[] = {
	{ __LINE__, QNAN_P, FP_NAN, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_M, FP_NAN, NO_INEXACT_EXCEPTION },
	{ __LINE__, SNAN_P, FP_NAN, NO_INEXACT_EXCEPTION },
	{ __LINE__, SNAN_M, FP_NAN, NO_INEXACT_EXCEPTION },
	{ __LINE__, INF_P, FP_INFINITE, NO_INEXACT_EXCEPTION },
	{ __LINE__, INF_M, FP_INFINITE, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_P, FP_ZERO, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_M, FP_ZERO, NO_INEXACT_EXCEPTION },
#ifdef TEST_LDOUBLE /* FIXME: messed up by truncxfdf2 */
	{ __LINE__, SUBNORM_P, FP_SUBNORMAL, NO_INEXACT_EXCEPTION },
	{ __LINE__, SUBNORM_M, FP_SUBNORMAL, NO_INEXACT_EXCEPTION },
#endif
	{ __LINE__, MAX_P, FP_NORMAL, NO_INEXACT_EXCEPTION },
	{ __LINE__, MAX_M, FP_NORMAL, NO_INEXACT_EXCEPTION },
	{ __LINE__, MIN_P, FP_NORMAL, NO_INEXACT_EXCEPTION },
	{ __LINE__, MIN_M, FP_NORMAL, NO_INEXACT_EXCEPTION },

	{ __LINE__, HEXCONSTE(1000, 0x4008, 0xfa000000L, 0x00000000L), FP_NORMAL, NO_INEXACT_EXCEPTION },
};

int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_f_i(fpclassify_data, ARRAY_SIZE(fpclassify_data), __FILE__);
	(void)check_fp;
		
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

#else

int main(void)
{
	return 77;
}

#endif

```

`tests/frexp.c`:

```c
#include "testconfig.h"
#define TEST_FUNC_FIP_F __MATH_PRECNAME(frexp)
#include "testdriver.h"



static test_fip_f_data const frexp_data[] = {
	{ __LINE__, ZERO_P, ZERO_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_M, ZERO_M, 0, NO_INEXACT_EXCEPTION|FLAG_FAIL_ARANYM2 },
	{ __LINE__, INF_P, INF_P, 0, NO_INEXACT_EXCEPTION|FLAG_FAIL_ARANYM|FLAG_FAIL_HARDFLOAT }, /* glibc returns NaN; inline version in math-68881.h returns NaN */
	{ __LINE__, INF_M, INF_M, 0, NO_INEXACT_EXCEPTION|FLAG_FAIL_ARANYM|FLAG_FAIL_HARDFLOAT }, /* glibc returns NaN; inline version in math-68881.h returns NaN */
	{ __LINE__, QNAN_P, QNAN_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_M, QNAN_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, SNAN_P, QNAN_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, SNAN_M, QNAN_P, 0, NO_INEXACT_EXCEPTION },

	{ __LINE__, HEXCONSTE(12.8, 0x4002, 0xccccccccL, 0xcccccccdL), HEXCONSTE(0.8, 0x3ffe, 0xccccccccL, 0xcccccccdL), 4, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-27.34, 0xc003, 0xdab851ebL, 0x851eb852L), HEXCONSTE(-0.854375L, 0xbffe, 0xdab851ebL, 0x851eb852L), 5, NO_INEXACT_EXCEPTION },

	{ __LINE__, HEXCONSTE(0.25, 0x3ffd, 0x80000000L, 0x00000000L), HEXCONSTE(0.5, 0x3ffe, 0x80000000L, 0x00000000L), -1, 0 },
	{ __LINE__, HEXCONSTE(0.5, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(0.5, 0x3ffe, 0x80000000L, 0x00000000L), 0, 0 },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.5, 0x3ffe, 0x80000000L, 0x00000000L), 1, 0 },
	{ __LINE__, HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(0.5, 0x3ffe, 0x80000000L, 0x00000000L), 2, 0 },
	{ __LINE__, HEXCONSTE(4.0, 0x4001, 0x80000000L, 0x00000000L), HEXCONSTE(0.5, 0x3ffe, 0x80000000L, 0x00000000L), 3, 0 },
	{ __LINE__, HEXCONSTE(8.0, 0x4002, 0x80000000L, 0x00000000L), HEXCONSTE(0.5, 0x3ffe, 0x80000000L, 0x00000000L), 4, 0 },
	{ __LINE__, HEXCONSTE(256, 0x4007, 0x80000000L, 0x00000000L), HEXCONSTE(0.5, 0x3ffe, 0x80000000L, 0x00000000L), 9, 0 },
	{ __LINE__, HEXCONSTE(4096, 0x400b, 0x80000000L, 0x00000000L), HEXCONSTE(0.5, 0x3ffe, 0x80000000L, 0x00000000L), 13, 0 },
	{ __LINE__, HEXCONSTE(32768, 0x400e, 0x80000000L, 0x00000000L), HEXCONSTE(5.000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), 16, 0 },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-5.000000e-01, 0xbffe, 0x80000000L, 0x00000000L), 1, 0 },
	{ __LINE__, HEXCONSTE(-2.0, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(-5.000000e-01, 0xbffe, 0x80000000L, 0x00000000L), 2, 0 },
	{ __LINE__, HEXCONSTE(-4.0, 0xc001, 0x80000000L, 0x00000000L), HEXCONSTE(-5.000000e-01, 0xbffe, 0x80000000L, 0x00000000L), 3, 0 },
	{ __LINE__, HEXCONSTE(-8.0, 0xc002, 0x80000000L, 0x00000000L), HEXCONSTE(-5.000000e-01, 0xbffe, 0x80000000L, 0x00000000L), 4, 0 },
	{ __LINE__, HEXCONSTE(-256, 0xc007, 0x80000000L, 0x00000000L), HEXCONSTE(-5.000000e-01, 0xbffe, 0x80000000L, 0x00000000L), 9, 0 },
	{ __LINE__, HEXCONSTE(-4096, 0xc00b, 0x80000000L, 0x00000000L), HEXCONSTE(-0.5, 0xbffe, 0x80000000L, 0x00000000L), 13, 0 },
	{ __LINE__, HEXCONSTE(-32768, 0xc00e, 0x80000000L, 0x00000000L), HEXCONSTE(-5.000000e-01, 0xbffe, 0x80000000L, 0x00000000L), 16, 0 },
	{ __LINE__, HEXCONSTE(1.234500e+00, 0x3fff, 0x9e041893L, 0x74bc6a7fL), HEXCONSTE(6.172500e-01, 0x3ffe, 0x9e041893L, 0x74bc6a7fL), 1, 0 },
	{ __LINE__, HEXCONSTE(1.234500e+10, 0x4020, 0xb7f47010L, 0x00000000L), HEXCONSTE(7.185736e-01, 0x3ffe, 0xb7f47010L, 0x00000000l), 34, 0 },
	{ __LINE__, HEXCONSTE(3.456700e+20, 0x4043, 0x95e9144cL, 0x7eaa3800L), HEXCONSTE(5.855878e-01, 0x3ffe, 0x95e9144cL, 0x7eaa3800L), 69, 0 },
	{ __LINE__, HEXCONSTE(3.456700e-05, 0x3ff0, 0x90fc089bL, 0xfd438487L), HEXCONSTE(5.663457e-01, 0x3ffe, 0x90fc089bL, 0xfd438487L), -14, 0 },
	{ __LINE__, HEXCONSTE(-1.234500e+00, 0xbfff, 0x9e041893L, 0x74bc6a7fL), HEXCONSTE(-6.172500e-01, 0xbffe, 0x9e041893L, 0x74bc6a7fL), 1, 0 },
	{ __LINE__, HEXCONSTE(-1.234500e+10, 0xc020, 0xb7f47010L, 0x00000000L), HEXCONSTE(-7.185736e-01, 0xbffe, 0xb7f47010L, 0x00000000L), 34, 0 },
	{ __LINE__, HEXCONSTE(-3.456700e+20, 0xc043, 0x95e9144cL, 0x7eaa3800L), HEXCONSTE(-5.855878e-01, 0xbffe, 0x95e9144cL, 0x7eaa3800L), 69, 0 },
	{ __LINE__, HEXCONSTE(-3.456700e-05, 0xbff0, 0x90fc089bL, 0xfd438487L), HEXCONSTE(-5.663457e-01, 0xbffe, 0x90fc089bL, 0xfd438487L), -14, 0 },

	{ __LINE__, HEXCONSTE(1.70141183460469231732e+38, 0x407e, 0x80000000L, 0x00000000L), HEXCONSTE(0.5, 0x3ffe, 0x80000000L, 0x00000000L), 128, 0 },
	{ __LINE__, HEXCONSTE(-1.70141183460469231732e+38, 0xc07e, 0x80000000L, 0x00000000L), HEXCONSTE(-0.5, 0xbffe, 0x80000000L, 0x00000000L), 128, 0 },
	{ __LINE__, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(0.5, 0x3ffe, 0x80000000L, 0x00000000L), -125, 0 },
	{ __LINE__, HEXCONSTE(5.87747175411143753984e-39, 0x3f80, 0x80000000L, 0x00000000L), HEXCONSTE(0.5, 0x3ffe, 0x80000000L, 0x00000000L), -126, 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(0.5, 0x3ffe, 0x80000000L, 0x00000000L), -148, 0 },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-0.5, 0xbffe, 0x80000000L, 0x00000000L), -148, 0 },
	{ __LINE__, HEXCONSTE(8.98846567431157953865e+307, 0x43fe, 0x80000000L, 0x00000000L), HEXCONSTE(0.5, 0x3ffe, 0x80000000L, 0x00000000L), 1024,  },
	{ __LINE__, HEXCONSTE(-8.98846567431157953865e+307, 0xc3fe, 0x80000000L, 0x00000000L), HEXCONSTE(-0.5, 0xbffe, 0x80000000L, 0x00000000L), 1024, 0 },
	{ __LINE__, HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(0.5, 0x3ffe, 0x80000000L, 0x00000000L), -1021, 0 },
	{ __LINE__, HEXCONSTE(1.11253692925360069155e-308, 0x3c00, 0x80000000L, 0x00000000L), HEXCONSTE(0.5, 0x3ffe, 0x80000000L, 0x00000000L), -1022, 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(0.5, 0x3ffe, 0x80000000L, 0x00000000L), -1073, 0 },
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-0.5, 0xbffe, 0x80000000L, 0x00000000L), -1073, 0 },
	{ __LINE__, HEXCONSTE(5.94865747678615882543e+4931, 0x7ffe, 0x80000000L, 0x00000000L), HEXCONSTE(0.5, 0x3ffe, 0x80000000L, 0x00000000L), 16384, 0 },
	{ __LINE__, HEXCONSTE(-5.94865747678615882543e+4931, 0xfffe, 0x80000000L, 0x00000000L), HEXCONSTE(-0.5, 0xbffe, 0x80000000L, 0x00000000L), 16384, 0 },
	{ __LINE__, HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(0.5, 0x3ffe, 0x80000000L, 0x00000000L), -16381, 0 },
#if defined(TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x80000000L, 0x00000000L), HEXCONSTE(0.5, 0x3ffe, 0x80000000L, 0x00000000L), -16381, FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(8.40525785778023376566e-4933, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(0.5, 0x3ffe, 0x80000000L, 0x00000000L), -16382, FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(0.5, 0x3ffe, 0x80000000L, 0x00000000L), -16444, FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(-0.5, 0xbffe, 0x80000000L, 0x00000000L), -16444, FLAG_SUBNORM },
#endif
#if defined(TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16381)
	{ __LINE__, HEXCONSTE(3.36210314311209350626e-4932, 0x0000, 0x80000000L, 0x00000000L), HEXCONSTE(0.5, 0x3ffe, 0x80000000L, 0x00000000L), -16381, 0 },
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(0.5, 0x3ffe, 0x80000000L, 0x00000000L), -16382, 0 },
	{ __LINE__, HEXCONSTE(1.82259976594123730126e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(0.5, 0x3ffe, 0x80000000L, 0x00000000L), -16444, 0 },
	{ __LINE__, HEXCONSTE(-1.82259976594123730126e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(-0.5, 0xbffe, 0x80000000L, 0x00000000L), -16444, 0 },
#endif
};

int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_fip_f(frexp_data, ARRAY_SIZE(frexp_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

```

`tests/fsub.c`:

```c
#include "testconfig.h"
#define TEST_FUNC_FF_F __MATH_PRECNAME(wrap_sub)
/* FIXME: sometimes totally bogus values in ARAnyM when inlined */
__attribute__((__noinline__))
static REAL TEST_FUNC_FF_F(REAL x, REAL y)
{
	return x - y;
}
#include "testdriver.h"



static test_ff_f_data const fsub_data[] = {
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L),  HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-2.0, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(3.0, 0x4000, 0xc0000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-3.0, 0xc000, 0xc0000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-2.0, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), ZERO_P, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), ZERO_M, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), ZERO_P, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), ZERO_M, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), INF_P, INF_P, 0 },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), INF_M, INF_M, 0 },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), INF_P, INF_P, 0 },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), INF_M, INF_M, 0 },
	{ __LINE__, ZERO_P, HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L),  HEXCONSTE(-2.0, 0xc000, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, ZERO_P, HEXCONSTE(-2.0, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, ZERO_M, HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-2.0, 0xc000, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, ZERO_M, HEXCONSTE(-2.0, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, ZERO_P, ZERO_P, ZERO_P, 0 },
	{ __LINE__, ZERO_P, ZERO_M, ZERO_P, 0 },
	{ __LINE__, ZERO_M, ZERO_P, ZERO_M, FLAG_FAIL_ARANYM2 },
	{ __LINE__, ZERO_M, ZERO_M, ZERO_P, 0 },
	{ __LINE__, ZERO_P, INF_P, INF_P, 0 },
	{ __LINE__, ZERO_P, INF_M, INF_M, 0 },
	{ __LINE__, ZERO_M, INF_P, INF_P, 0 },
	{ __LINE__, ZERO_M, INF_M, INF_M, 0 },
	{ __LINE__, INF_P, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__, INF_P, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__, INF_M, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), INF_M, 0 },
	{ __LINE__, INF_M, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), INF_M, 0 },
	{ __LINE__, INF_P, ZERO_P, INF_P, 0 },
	{ __LINE__, INF_P, ZERO_M, INF_P, 0 },
	{ __LINE__, INF_M, ZERO_P, INF_M, 0 },
	{ __LINE__, INF_M, ZERO_M, INF_M, 0 },
	{ __LINE__, INF_P, INF_P, QNAN_P, 0 },
	{ __LINE__, INF_P, INF_M, INF_P, 0 }, /* documentation says -inf, but is wrong */
	{ __LINE__, INF_M, INF_P, INF_M, 0 },
	{ __LINE__, INF_M, INF_M, QNAN_P, 0 },

	{ __LINE__, ZERO_P, QNAN_P, QNAN_P, 0 },
	{ __LINE__, ZERO_P, QNAN_M, QNAN_P, 0 },
	{ __LINE__, ZERO_M, QNAN_P, QNAN_P, 0 },
	{ __LINE__, ZERO_M, QNAN_M, QNAN_P, 0 },
	{ __LINE__, INF_P, QNAN_P, QNAN_P, 0 },
	{ __LINE__, INF_P, QNAN_M, QNAN_M, 0 },
	{ __LINE__, INF_M, QNAN_P, QNAN_M, 0 },
	{ __LINE__, INF_M, QNAN_M, QNAN_P, 0 },
	{ __LINE__, QNAN_P, ZERO_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, ZERO_P, QNAN_P, 0 },
	{ __LINE__, QNAN_P, ZERO_M, QNAN_P, 0 },
	{ __LINE__, QNAN_M, ZERO_M, QNAN_P, 0 },
	{ __LINE__, QNAN_P, INF_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, INF_P, QNAN_M, 0 },
	{ __LINE__, QNAN_P, INF_M, QNAN_M, 0 },
	{ __LINE__, QNAN_M, INF_M, QNAN_P, 0 },
	{ __LINE__, QNAN_P, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_P, QNAN_M, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_M, QNAN_P, 0 },
	{ __LINE__, QNAN_P, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_P, QNAN_M, 0 },
	{ __LINE__, QNAN_P, QNAN_M, QNAN_M, 0 },
	{ __LINE__, QNAN_M, QNAN_M, QNAN_P, 0 },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), QNAN_P, QNAN_P, 0 },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), QNAN_M, QNAN_P, 0 },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), QNAN_P, QNAN_P, 0 },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), QNAN_M, QNAN_P, 0 },
	{ __LINE__, QNAN_P, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__, QNAN_M, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__, QNAN_P, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__, QNAN_M, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), QNAN_P, 0 },

#ifdef TEST_LDOUBLE
	{ __LINE__, HEXCONST_PI, HEXCONSTE(3.0, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(0.141592653589793238462643383279502884, 0x3ffc, 0x90fdaa22L, 0x168c2350L), 0 },
#endif
#ifdef TEST_DOUBLE
	{ __LINE__, HEXCONST_PI, HEXCONSTE(3.0, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(1.4159265358979311599796e-01, 0x3ffc, 0x90fdaa22L, 0x168c0000L), 0 },
#endif
};


int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_ff_f(fsub_data, ARRAY_SIZE(fsub_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

```

`tests/hypot.c`:

```c
#include "testconfig.h"
#ifdef HAVE_HYPOT
#define TEST_FUNC_FF_F __MATH_PRECNAME(hypot)
#include "testdriver.h"


static test_ff_f_data const hypot_data[] = {
	/* If x or y is an infinity, positive infinity is returned. */
	{ __LINE__, INF_P, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__, INF_M, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), INF_P, 0 },

	{ __LINE__, INF_P, QNAN_P, INF_P, FLAG_FAIL_HARDFLOAT }, /* inline hypot in math-68881.h does not handle INF */
	{ __LINE__, INF_M, QNAN_P, INF_P, FLAG_FAIL_HARDFLOAT },
	{ __LINE__, QNAN_P, INF_P, INF_P, FLAG_FAIL_HARDFLOAT },
	{ __LINE__, QNAN_P, INF_M, INF_P, FLAG_FAIL_HARDFLOAT },

	/* If x or y is a NaN, and the other argument is not an infinity, a NaN is returned. */
	{ __LINE__, QNAN_P, QNAN_P, QNAN_P, 0 },
	{ __LINE__, ZERO_P, QNAN_P, QNAN_P, 0 },
	{ __LINE__, ZERO_M, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_P, ZERO_P, QNAN_P, 0 },
	{ __LINE__, QNAN_P, ZERO_M, QNAN_P, 0 },
	{ __LINE__, HEXCONSTE(0.7L, 0x3ffe, 0xb3333333L, 0x33333333L), QNAN_P, QNAN_P, 0 },
	{ __LINE__, HEXCONSTE(-0.7L, 0xbffe, 0xb3333333L, 0x33333333L), QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_P, HEXCONSTE(0.7L, 0x3ffe, 0xb3333333L, 0x33333333L), QNAN_P, 0 },
	{ __LINE__, QNAN_P, HEXCONSTE(-0.7L, 0xbffe, 0xb3333333L, 0x33333333L), QNAN_P, 0 },

	/* hypot (x,y) == hypot (+-x, +-y)	*/
	{ __LINE__, HEXCONSTE(0.7L, 0x3ffe, 0xb3333333L, 0x33333333L), HEXCONSTE(12.4L, 0x4002, 0xc6666666L, 0x66666666L), HEXCONSTE(12.419742348374220601176836866763271L, 0x4002, 0xc6b743c0L, 0xb0375cd1L), 0 },
	{ __LINE__, HEXCONSTE(-0.7L, 0xbffe, 0xb3333333L, 0x33333333L), HEXCONSTE(12.4L, 0x4002, 0xc6666666L, 0x66666666L), HEXCONSTE(12.419742348374220601176836866763271L, 0x4002, 0xc6b743c0L, 0xb0375cd1L), 0 },
	{ __LINE__, HEXCONSTE(0.7L, 0x3ffe, 0xb3333333L, 0x33333333L), HEXCONSTE(-12.4L, 0xc002, 0xc6666666L, 0x66666666L), HEXCONSTE(12.419742348374220601176836866763271L, 0x4002, 0xc6b743c0L, 0xb0375cd1L), 0 },
	{ __LINE__, HEXCONSTE(-0.7L, 0xbffe, 0xb3333333L, 0x33333333L), HEXCONSTE(-12.4L, 0xc002, 0xc6666666L, 0x66666666L), HEXCONSTE(12.419742348374220601176836866763271L, 0x4002, 0xc6b743c0L, 0xb0375cd1L), 0 },
	{ __LINE__, HEXCONSTE(12.4L, 0x4002, 0xc6666666L, 0x66666666L), HEXCONSTE(0.7L, 0x3ffe, 0xb3333333L, 0x33333333L), HEXCONSTE(12.419742348374220601176836866763271L, 0x4002, 0xc6b743c0L, 0xb0375cd1L), 0 },
	{ __LINE__, HEXCONSTE(-12.4L, 0xc002, 0xc6666666L, 0x66666666L), HEXCONSTE(0.7L, 0x3ffe, 0xb3333333L, 0x33333333L), HEXCONSTE(12.419742348374220601176836866763271L, 0x4002, 0xc6b743c0L, 0xb0375cd1L), 0 },
	{ __LINE__, HEXCONSTE(12.4L, 0x4002, 0xc6666666L, 0x66666666L), HEXCONSTE(-0.7L, 0xbffe, 0xb3333333L, 0x33333333L), HEXCONSTE(12.419742348374220601176836866763271L, 0x4002, 0xc6b743c0L, 0xb0375cd1L), 0 },
	{ __LINE__, HEXCONSTE(-12.4L, 0xc002, 0xc6666666L, 0x66666666L), HEXCONSTE(-0.7L, 0xbffe, 0xb3333333L, 0x33333333L), HEXCONSTE(12.419742348374220601176836866763271L, 0x4002, 0xc6b743c0L, 0xb0375cd1L), 0 },

	/*	hypot (x,0) == fabs (x)  */
	{ __LINE__, HEXCONSTE(HEXCONSTE(0.75L, 0x3ffe, 0xc0000000L, 0x00000000L), 0x3ffe, 0xc0000000L, 0x00000000L), ZERO_P, HEXCONSTE(0.75L, 0x3ffe, 0xc0000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(HEXCONSTE(-0.75L, 0xbffe, 0xc0000000L, 0x00000000L), 0xbffe, 0xc0000000L, 0x00000000L), ZERO_P, HEXCONSTE(0.75L, 0x3ffe, 0xc0000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(HEXCONSTE(-5.7e7, 0xc018, 0xd9701000L, 0x00000000L), 0xc018, 0xd9701000L, 0x00000000L), ZERO_P, HEXCONSTE(5.7e7L, 0x4018, 0xd9701000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(HEXCONSTE(0.75L, 0x3ffe, 0xc0000000L, 0x00000000L), 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(1.25L, 0x3fff, 0xa0000000L, 0x00000000L), HEXCONSTE(1.45773797371132511771853821938639577L, 0x3fff, 0xba97286dL, 0x9d1d0d8eL), FLAG_INEXACT },

	{ __LINE__, HEXCONSTE(1.0L, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(4.33680868994201773603e-19, 0x3fc2, 0x80000000L, 0x00000000L), HEXCONSTE(1.0L, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.0L, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(2.84690038089772755836e-39, 0x3f7e, 0xf8000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },

#if !defined(TEST_FLOAT)
	{ __LINE__, HEXCONSTE(1.27605887595351923799e+38, 0x407d, 0xc0000000L, 0x00000000L), HEXCONSTE(1.70141183460469231732e+38, 0x407e, 0x80000000L, 0x00000000L), HEXCONSTE(2.12676479325586539665e+38, 0x407e, 0xa0000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.33745124252463186320e-38, 0x3f81, 0x91a2b300L, 0x00000000L), HEXCONSTE(1.33745124252463186320e-38, 0x3f81, 0x91a2b300L, 0x00000000L), HEXCONSTE(1.891441686191081936598531534017449451173e-38L, 0x3f81, 0xcdf5b2e9L, 0x9af0dac2L), UNDERFLOW_EXCEPTION_OK },
#endif

#if defined(TEST_DOUBLE)
	{ __LINE__, HEXCONSTE(6.74134925573368465398e+307, 0x43fd, 0xc0000000L, 0x00000000L), HEXCONSTE(8.98846567431157953865e+307, 0x43fe, 0x80000000L, 0x00000000L), HEXCONSTE(1.12355820928894744233e+308, 0x43fe, 0xa0000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(5.38885075107212834967e-309, 0x3bfe, 0xf8000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif

#if defined(TEST_LDOUBLE) && LDBL_MAX_EXP >= 16384
	{ __LINE__, HEXCONSTE(4.46149310758961911907e+4931, 0x7ffd, 0xc0000000L, 0x00000000L), HEXCONSTE(5.94865747678615882543e+4931, 0x7ffe, 0x80000000L, 0x00000000L), HEXCONSTE(7.43582184598269853179e+4931, 0x7ffe, 0xa0000000L, 0x00000000L), 0 },
#endif

	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.9817352931807469938024533350782879785095e-45L, 0x3f6a, 0xb504f333L, 0xf9de6484L), UNDERFLOW_EXCEPTION_FLOAT|FLAG_INEXACT },

#ifndef TEST_FLOAT
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(6.9871433705131320800651344656990806305791e-324L, 0x3bcd, 0xb504f333L, 0xf9de6484L), UNDERFLOW_EXCEPTION_DOUBLE },
#endif

#if defined TEST_LDOUBLE && LDBL_MIN_EXP <= -16381
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(5.1550906155442528702558159159596215039925e-4951L, 0x0000, 0x00000000L, 0x00000001L), UNDERFLOW_EXCEPTION },
#endif
};


int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_ff_f(hypot_data, ARRAY_SIZE(hypot_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

#else

int main(void)
{
	return 77;
}

#endif

```

`tests/ilogb.c`:

```c
#include "testconfig.h"
#ifdef HAVE_ILOGB
#define TEST_FUNC_F_I __MATH_PRECNAME(ilogb)
#include "testdriver.h"


#ifndef FP_ILOGB0
/* The values returned by `ilogb' for 0 and NaN respectively.  */
# ifndef __FP_LOGB0_IS_MIN
#   define __FP_LOGB0_IS_MIN 1
# endif
# if __FP_LOGB0_IS_MIN
#   define FP_ILOGB0	(-__INT_MAX__ - 1)
# else
#   define FP_ILOGB0	(-__INT_MAX__)
# endif
# ifndef __FP_LOGBNAN_IS_MIN
#   ifdef __mc68000__
#     define __FP_LOGBNAN_IS_MIN 0
#   else
#     define __FP_LOGBNAN_IS_MIN 1
#   endif
# endif
# if __FP_LOGBNAN_IS_MIN
#   define FP_ILOGBNAN	(-__INT_MAX__ - 1)
# else
#   define FP_ILOGBNAN	(__INT_MAX__)
# endif
#endif


static test_f_i_data const ilogb_data[] = {
	/* ilogb (0.0) == FP_ILOGB0 plus invalid exception	*/
	{ __LINE__, ZERO_P, FP_ILOGB0, NO_INEXACT_EXCEPTION|INVALID_EXCEPTION|ERRNO_EDOM|FLAG_FAIL_SOFTFLOAT|FLAG_XFAIL }, /* only implemented as softfloat and thus always fails */
	{ __LINE__, ZERO_M, FP_ILOGB0, NO_INEXACT_EXCEPTION|INVALID_EXCEPTION|ERRNO_EDOM|FLAG_FAIL_SOFTFLOAT|FLAG_XFAIL }, /* only implemented as softfloat and thus always fails */
	/* ilogb (qNaN) == FP_ILOGBNAN plus invalid exception  */
	{ __LINE__, QNAN_P, FP_ILOGBNAN, NO_INEXACT_EXCEPTION|INVALID_EXCEPTION|ERRNO_EDOM|FLAG_FAIL_HARDFLOAT }, /* not handled by inline version in math-68881.h */
	{ __LINE__, QNAN_M, FP_ILOGBNAN, NO_INEXACT_EXCEPTION|INVALID_EXCEPTION|ERRNO_EDOM|FLAG_FAIL_HARDFLOAT }, /* not handled by inline version in math-68881.h */
	/* ilogb (inf) == INT_MAX plus invalid exception  */
	{ __LINE__, INF_P, INT_MAX, NO_INEXACT_EXCEPTION|INVALID_EXCEPTION|ERRNO_EDOM|FLAG_FAIL_HARDFLOAT|FLAG_FAIL_ARANYM }, /* not handled by inline version in math-68881.h */
	/* ilogb (-inf) == INT_MAX plus invalid exception  */
	{ __LINE__, INF_M, INT_MAX, NO_INEXACT_EXCEPTION|INVALID_EXCEPTION|ERRNO_EDOM|FLAG_FAIL_HARDFLOAT|FLAG_FAIL_ARANYM }, /* not handled by inline version in math-68881.h */

	{ __LINE__, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONST_E, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1024, 0x4009, 0x80000000L, 0x00000000L), 10, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-2000, 0xc009, 0xfa000000L, 0x00000000L), 10, NO_INEXACT_EXCEPTION },

	{ __LINE__, HEXCONSTE(8.50705917302346158658e+37, 0x407d, 0x80000000L, 0x00000000L), 126, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), -126, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.46936793852785938496e-39, 0x3f7e, 0x80000000L, 0x00000000L), -129, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.83670992315982423120e-40, 0x3f7b, 0x80000000L, 0x00000000L), -132, NO_INEXACT_EXCEPTION },
#if defined(TEST_FLOAT)
	{ __LINE__, MAX_P, FLT_MAX_EXP - 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, MIN_P, FLT_MIN_EXP - 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, SUBNORM_P, FLT_MIN_EXP - FLT_MANT_DIG, FLAG_SUBNORM|NO_INEXACT_EXCEPTION },
#endif

#if defined(TEST_DOUBLE) && DBL_MAX_EXP >= 1024
	{ __LINE__, HEXCONSTE(8.98846567431157953865e+307, 0x43fe, 0x80000000L, 0x00000000L), 1023, NO_INEXACT_EXCEPTION },
	{ __LINE__, MAX_P, DBL_MAX_EXP - 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.11253692925360069155e-308, 0x3c00, 0x80000000L, 0x00000000L), -1023, NO_INEXACT_EXCEPTION },
	{ __LINE__, MIN_P, DBL_MIN_EXP - 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(3.47667790391750216108e-310, 0x3bfb, 0x80000000L, 0x00000000L), -1028, NO_INEXACT_EXCEPTION },
	{ __LINE__, SUBNORM_P, DBL_MIN_EXP - DBL_MANT_DIG, FLAG_SUBNORM|NO_INEXACT_EXCEPTION },
#endif

#if defined(TEST_LDOUBLE) && LDBL_MAX_EXP >= 16384
	{ __LINE__, HEXCONSTE(5.94865747678615882543e+4931, 0x7ffe, 0x80000000L, 0x00000000L), 16383, NO_INEXACT_EXCEPTION },
	{ __LINE__, MAX_P, LDBL_MAX_EXP - 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), -16383, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(8.40525785778023376566e-4933, 0x0000, 0x20000000L, 0x00000000L), -16384, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(8.20825962673850953677e-4936, 0x0000, 0x00080000L, 0x00000000L), -16394, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(7.64453748868639537764e-4945, 0x0000, 0x00000000L, 0x00200000L), -16424, NO_INEXACT_EXCEPTION },
	{ __LINE__, MIN_P, LDBL_MIN_EXP - 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, SUBNORM_P, LDBL_MIN_EXP - LDBL_MANT_DIG, FLAG_SUBNORM|NO_INEXACT_EXCEPTION },
#endif
};

int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_f_i(ilogb_data, ARRAY_SIZE(ilogb_data), __FILE__);
	(void)check_fp;
		
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

#else

int main(void)
{
	return 77;
}

#endif

```

`tests/isfini.c`:

```c
#include "testconfig.h"
#if defined(HAVE_ISFINITE) || defined(HAVE___ISFINITE)
#ifdef HAVE___ISFINITE
int __MATH_PRECNAME(__isfinite)(REAL x);
#define TEST_FUNC_F_I __MATH_PRECNAME(__isfinite)
#else
#define TEST_FUNC_F_I __MATH_PRECNAME(isfinite)
#endif
#include "testdriver.h"

/* make sure we don't test the builtin */
#undef isfinite
#undef __isfinite

static test_f_i_data const isfinite_data[] = {
	{ __LINE__, ZERO_P, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_M, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, SUBNORM_P, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, SUBNORM_M, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, INF_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, INF_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, SNAN_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, SNAN_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, MAX_P, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, MAX_M, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, MIN_P, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, MIN_M, 1, NO_INEXACT_EXCEPTION },

	{ __LINE__, HEXCONSTE(10, 0x4002, 0xa0000000L, 0x00000000L), 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-10, 0xc002, 0xa0000000L, 0x00000000L), 1, NO_INEXACT_EXCEPTION },
};

int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_f_i(isfinite_data, ARRAY_SIZE(isfinite_data), __FILE__);
	(void)check_fp;
		
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

#else

int main(void)
{
	return 77;
}

#endif

```

`tests/isgr.c`:

```c
#include "testconfig.h"

#if defined(HAVE_ISGREATER) || defined(HAVE___ISGREATER)
#define TEST_FUNC_FF_I __MATH_PRECNAME(wrap_isgreater)
static int TEST_FUNC_FF_I(REAL x, REAL y)
{
#ifdef HAVE___ISGREATER
	return __isgreater(x, y);
#else
	return isgreater(x, y);
#endif
}
#include "testdriver.h"



static test_ff_i_data const isgreater_data[] = {
	{ __LINE__, ZERO_M, ZERO_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_M, ZERO_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_M, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_M, QNAN_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_M, QNAN_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_P, ZERO_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_P, ZERO_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_P, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_P, QNAN_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_P, QNAN_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), ZERO_M, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), ZERO_P, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), QNAN_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), QNAN_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_P, ZERO_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_P, ZERO_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_P, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_P, QNAN_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_M, ZERO_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_M, ZERO_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_M, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_M, QNAN_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_M, QNAN_M, 0, NO_INEXACT_EXCEPTION },
};

int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_ff_i(isgreater_data, ARRAY_SIZE(isgreater_data), __FILE__);
	(void)check_fp;
		
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

#else

int main(void)
{
	return 77;
}

#endif

```

`tests/isgreq.c`:

```c
#include "testconfig.h"

#if defined(HAVE_ISGREATEREQUAL) || defined(HAVE___ISGREATEREQUAL)
#define TEST_FUNC_FF_I __MATH_PRECNAME(wrap_isgreaterequal)
static int TEST_FUNC_FF_I(REAL x, REAL y)
{
#ifdef HAVE___ISGREATEREQUAL
	return __isgreaterequal(x, y);
#else
	return isgreaterequal(x, y);
#endif
}
#include "testdriver.h"



static test_ff_i_data const isgreaterequal_data[] = {
	{ __LINE__, ZERO_M, ZERO_M, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_M, ZERO_P, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_M, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_M, QNAN_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_M, QNAN_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_P, ZERO_M, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_P, ZERO_P, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_P, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_P, QNAN_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_P, QNAN_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), ZERO_M, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), ZERO_P, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), QNAN_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), QNAN_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_P, ZERO_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_P, ZERO_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_P, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_P, QNAN_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_M, ZERO_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_M, ZERO_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_M, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_M, QNAN_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_M, QNAN_M, 0, NO_INEXACT_EXCEPTION },
};

int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_ff_i(isgreaterequal_data, ARRAY_SIZE(isgreaterequal_data), __FILE__);
	(void)check_fp;
		
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

#else

int main(void)
{
	return 77;
}

#endif

```

`tests/isinf.c`:

```c
#include "testconfig.h"
#if defined(HAVE_ISINF) || defined(HAVE___ISINF)
/* FIXME: that would use the function from mintlib */
#if defined(HAVE___ISINF) && 0
int __MATH_PRECNAME(__isinf)(REAL x);
#define TEST_FUNC_F_I __MATH_PRECNAME(__isinf)
#else
#define TEST_FUNC_F_I __MATH_PRECNAME(isinf)
#endif
#include "testdriver.h"

/* make sure we don't test the builtin */
#undef isinf
#undef __isinf

static test_f_i_data const isinf_data[] = {
	{ __LINE__, ZERO_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, SUBNORM_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, SUBNORM_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, INF_P, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, INF_M, -1, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, SNAN_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, SNAN_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, MAX_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, MAX_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, MIN_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, MIN_M, 0, NO_INEXACT_EXCEPTION },

	{ __LINE__, HEXCONSTE(10, 0x4002, 0xa0000000L, 0x00000000L), 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-10, 0xc002, 0xa0000000L, 0x00000000L), 0, NO_INEXACT_EXCEPTION },
};

int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_f_i(isinf_data, ARRAY_SIZE(isinf_data), __FILE__);
	(void)check_fp;
		
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

#else

int main(void)
{
	return 77;
}

#endif

```

`tests/isls.c`:

```c
#include "testconfig.h"

#if defined(HAVE_ISLESS) || defined(HAVE___ISLESS)
#define TEST_FUNC_FF_I __MATH_PRECNAME(wrap_isless)
static int TEST_FUNC_FF_I(REAL x, REAL y)
{
#ifdef HAVE___ISLESS
	return __isless(x, y);
#else
	return isless(x, y);
#endif
}
#include "testdriver.h"



static test_ff_i_data const isless_data[] = {
	{ __LINE__, ZERO_M, ZERO_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_M, ZERO_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_M, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_M, QNAN_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_M, QNAN_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_P, ZERO_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_P, ZERO_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_P, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_P, QNAN_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_P, QNAN_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), ZERO_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), ZERO_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), QNAN_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), QNAN_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_P, ZERO_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_P, ZERO_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_P, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_P, QNAN_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_M, ZERO_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_M, ZERO_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_M, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_M, QNAN_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_M, QNAN_M, 0, NO_INEXACT_EXCEPTION },
};

int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_ff_i(isless_data, ARRAY_SIZE(isless_data), __FILE__);
	(void)check_fp;
		
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

#else

int main(void)
{
	return 77;
}

#endif

```

`tests/islseq.c`:

```c
#include "testconfig.h"

#if defined(HAVE_ISLESSEQUAL) || defined(HAVE___ISLESSEQUAL)
#define TEST_FUNC_FF_I __MATH_PRECNAME(wrap_islessequal)
static int TEST_FUNC_FF_I(REAL x, REAL y)
{
#ifdef HAVE___ISLESSEQUAL
	return __islessequal(x, y);
#else
	return islessequal(x, y);
#endif
}
#include "testdriver.h"



static test_ff_i_data const islessequal_data[] = {
	{ __LINE__, ZERO_M, ZERO_M, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_M, ZERO_P, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_M, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_M, QNAN_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_M, QNAN_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_P, ZERO_M, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_P, ZERO_P, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_P, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_P, QNAN_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_P, QNAN_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), ZERO_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), ZERO_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), QNAN_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), QNAN_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_P, ZERO_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_P, ZERO_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_P, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_P, QNAN_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_M, ZERO_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_M, ZERO_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_M, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_M, QNAN_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_M, QNAN_M, 0, NO_INEXACT_EXCEPTION },
};

int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_ff_i(islessequal_data, ARRAY_SIZE(islessequal_data), __FILE__);
	(void)check_fp;
		
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

#else

int main(void)
{
	return 77;
}

#endif

```

`tests/islsgr.c`:

```c
#include "testconfig.h"

#if defined(HAVE_ISLESSGREATER) || defined(HAVE___ISLESSGREATER)
#define TEST_FUNC_FF_I __MATH_PRECNAME(wrap_islessgreater)
static int TEST_FUNC_FF_I(REAL x, REAL y)
{
#ifdef HAVE___ISLESSGREATER
	return __islessgreater(x, y);
#else
	return islessgreater(x, y);
#endif
}
#include "testdriver.h"



static test_ff_i_data const islessgreater_data[] = {
	{ __LINE__, ZERO_M, ZERO_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_M, ZERO_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_M, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_M, QNAN_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_M, QNAN_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_P, ZERO_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_P, ZERO_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_P, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_P, QNAN_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_P, QNAN_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), ZERO_M, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), ZERO_P, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), QNAN_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), QNAN_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_P, ZERO_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_P, ZERO_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_P, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_P, QNAN_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_M, ZERO_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_M, ZERO_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_M, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_M, QNAN_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_M, QNAN_M, 0, NO_INEXACT_EXCEPTION },
};

int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_ff_i(islessgreater_data, ARRAY_SIZE(islessgreater_data), __FILE__);
	(void)check_fp;
		
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

#else

int main(void)
{
	return 77;
}

#endif

```

`tests/isnan.c`:

```c
#include "testconfig.h"
#if defined(HAVE_ISNAN) || defined(HAVE___ISNAN)
/* FIXME: that would use the function from mintlib */
#if defined(HAVE___ISNAN) && 0
int __MATH_PRECNAME(__isnan)(REAL x);
#define TEST_FUNC_F_I __MATH_PRECNAME(__isnan)
#else
#define TEST_FUNC_F_I __MATH_PRECNAME(isnan)
#endif
#include "testdriver.h"

/* make sure we don't test the builtin */
#undef isnan
#undef __isnan

static test_f_i_data const isnan_data[] = {
	{ __LINE__, ZERO_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, SUBNORM_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, SUBNORM_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, INF_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, INF_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_P, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_M, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, SNAN_P, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, SNAN_M, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, MAX_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, MAX_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, MIN_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, MIN_M, 0, NO_INEXACT_EXCEPTION },

	{ __LINE__, HEXCONSTE(10, 0x4002, 0xa0000000L, 0x00000000L), 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-10, 0xc002, 0xa0000000L, 0x00000000L), 0, NO_INEXACT_EXCEPTION },
};

int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_f_i(isnan_data, ARRAY_SIZE(isnan_data), __FILE__);
	(void)check_fp;
		
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

#else

int main(void)
{
	return 77;
}

#endif

```

`tests/isnorm.c`:

```c
#include "testconfig.h"
#if defined(HAVE_ISNORMAL) || defined(HAVE___ISNORMAL)
#ifdef HAVE___ISNORMAL
int __MATH_PRECNAME(__isnormal)(REAL x);
#define TEST_FUNC_F_I __MATH_PRECNAME(__isnormal)
#else
#define TEST_FUNC_F_I __MATH_PRECNAME(isnormal)
#endif
#include "testdriver.h"

/* make sure we don't test the builtin */
#undef isnormal
#undef __isnormal

static test_f_i_data const isnormal_data[] = {
	{ __LINE__, ZERO_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_M, 0, NO_INEXACT_EXCEPTION },
#ifdef TEST_LDOUBLE /* FIXME: messed up by truncxfdf2 */
	{ __LINE__, SUBNORM_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, SUBNORM_M, 0, NO_INEXACT_EXCEPTION },
#endif
	{ __LINE__, INF_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, INF_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, SNAN_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, SNAN_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, MAX_P, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, MAX_M, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, MIN_P, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, MIN_M, 1, NO_INEXACT_EXCEPTION },

	{ __LINE__, HEXCONSTE(10, 0x4002, 0xa0000000L, 0x00000000L), 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-10, 0xc002, 0xa0000000L, 0x00000000L), 1, NO_INEXACT_EXCEPTION },
};

int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_f_i(isnormal_data, ARRAY_SIZE(isnormal_data), __FILE__);
	(void)check_fp;
		
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

#else

int main(void)
{
	return 77;
}

#endif

```

`tests/issign.c`:

```c
#include "testconfig.h"
#if defined(HAVE_ISSIGNALING) || defined(HAVE___ISSIGNALING)
#ifdef HAVE___ISSIGNALING
int __MATH_PRECNAME(__issignaling)(REAL x);
#define TEST_FUNC_F_I __MATH_PRECNAME(__issignaling)
#else
#define TEST_FUNC_F_I __MATH_PRECNAME(issignaling)
#endif
#include "testdriver.h"

/* make sure we don't test the builtin */
#undef issignaling
#undef __issignaling

static test_f_i_data const issignaling_data[] = {
	{ __LINE__, ZERO_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, SUBNORM_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, SUBNORM_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, INF_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, INF_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, SNAN_P, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, SNAN_M, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, MAX_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, MAX_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, MIN_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, MIN_M, 0, NO_INEXACT_EXCEPTION },

	{ __LINE__, HEXCONSTE(10, 0x4002, 0xa0000000L, 0x00000000L), 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-10, 0xc002, 0xa0000000L, 0x00000000L), 0, NO_INEXACT_EXCEPTION },
};

int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_f_i(issignaling_data, ARRAY_SIZE(issignaling_data), __FILE__);
	(void)check_fp;
		
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

#else

int main(void)
{
	return 77;
}

#endif

```

`tests/isunor.c`:

```c
#include "testconfig.h"

#if defined(HAVE_ISUNORDERED) || defined(HAVE___ISUNORDERED)
#define TEST_FUNC_FF_I __MATH_PRECNAME(wrap_isunordered)
static int TEST_FUNC_FF_I(REAL x, REAL y)
{
#ifdef HAVE___ISUNORDERED
	return __isunordered(x, y);
#else
	return isunordered(x, y);
#endif
}
#include "testdriver.h"



static test_ff_i_data const isunordered_data[] = {
	{ __LINE__, ZERO_M, ZERO_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_M, ZERO_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_M, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_M, QNAN_P, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_M, QNAN_M, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_P, ZERO_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_P, ZERO_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_P, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_P, QNAN_P, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_P, QNAN_M, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), ZERO_M, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), ZERO_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), QNAN_P, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), QNAN_M, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_P, ZERO_M, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_P, ZERO_P, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_M, ZERO_M, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_M, ZERO_P, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_P, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_P, QNAN_P, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_M, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_M, QNAN_P, 1, NO_INEXACT_EXCEPTION },
};

int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_ff_i(isunordered_data, ARRAY_SIZE(isunordered_data), __FILE__);
	(void)check_fp;
		
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

#else

int main(void)
{
	return 77;
}

#endif

```

`tests/j0.c`:

```c
#include "testconfig.h"
#define TEST_FUNC_F_F __MATH_PRECNAME(j0)
#include "testdriver.h"


static test_f_f_data const j0_data[] = {
	{ __LINE__, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_P, 0 },
	{ __LINE__, SNAN_P, QNAN_P, 0 },
	{ __LINE__, SNAN_M, QNAN_P, 0 },
	{ __LINE__, INF_P, ZERO_P, 0 },
	{ __LINE__, INF_M, ZERO_P, 0 },
	{ __LINE__, ZERO_P, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, ZERO_M, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, MIN_P, ZERO_P, 0 },
	{ __LINE__, MIN_M, ZERO_M, 0 },

#if defined(TEST_LDOUBLE) && LDBL_MAX_EXP >= 16384
	{ __LINE__, SUBNORM_P, ZERO_P, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, ZERO_M, FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(0.765197686557966551449717526102663221L, 0x3ffe, 0xc3e3fedeL, 0xbdc77c1dL), 0 },
	{ __LINE__, HEXCONSTE(0.125L, 0x3ffc, 0x80000000L, 0x00000000L), HEXCONSTE(0.996097563041985204618e, 0x3ffe, 0xff003ff8L, 0xe3fffb73L), 0 },
	{ __LINE__, HEXCONSTE(0.75L, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(0.864242275166648623566, 0x3ffe, 0xdd3efb53L, 0xa950c68fL), 0 },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.765197686557966551453, 0x3ffe, 0xc3e3fedeL, 0xbdc77c1dL), 0 },
	{ __LINE__, HEXCONSTE(1.5, 0x3fff, 0xc0000000L, 0x00000000L), HEXCONSTE(0.511827671735918128732, 0x3ffe, 0x83072367L, 0x4b28d6eaL), 0 },
	{ __LINE__, HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(0.223890779141235668056, 0x3ffc, 0xe5439fd9L, 0x2677be47L), 0 },
	{ __LINE__, HEXCONSTE(8.0, 0x4002, 0x80000000L, 0x00000000L), HEXCONSTE(0.171650807137553906091, 0x3ffc, 0xafc53aabL, 0xf3812962L), 0 },
	{ __LINE__, HEXCONSTE(10.0, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(-0.245935764451348335197, 0xbffc, 0xfbd695c4L, 0xf0f29c19L), 0 },
	{ __LINE__, HEXCONSTE(4.0, 0x4001, 0x80000000L, 0x00000000L), HEXCONSTE(-0.397149809863847372282, 0xbffd, 0xcb573849L, 0xf4a7cb9aL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-4.0, 0xc001, 0x80000000L, 0x00000000L), HEXCONSTE(-0.397149809863847372282, 0xbffd, 0xcb573849L, 0xf4a7cb9aL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.99042308591513901914e+32, 0x406a, 0xebe71d00L, 0x00000000L), HEXCONSTE(2.77552364729123080260e-17, 0x3fc7, 0xffff3300L, 0x34dddb30L), 0 },
	{ __LINE__, HEXCONSTE(2.97432873839307941271e+4931, 0x7ffd, 0x80000000L, 0x00000000L), HEXCONSTE(-1.2193782500509000574176799046642541129387e-2466L, 0x9fff, 0xaa3e927dL, 0x898c8098L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(5.94865747678615882543e+4931, 0x7ffe, 0x80000000L, 0x00000000L), HEXCONSTE(9.5859502826270374691362975419147645151233e-2467L, 0x1fff, 0x85d5c0e6L, 0xffc90411L), 0 },
	{ __LINE__, HEXCONSTE(-3.24260049552016421366e+178, 0xc250, 0x80080000L, 0x08000000L), HEXCONSTE(-3.927269966354206207832593635798954916263e-90L, 0xbed5, 0xffffeb78L, 0x29d45532L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(8.98846567431157953865e+307, 0x43fe, 0x80000000L, 0x00000000L), HEXCONSTE(-1.5665258060609012834424478437196679802783e-155L, 0xbdfc, 0xd713e11dL, 0xe5fcbec1L), 0 },

	{ __LINE__, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, HEXCONSTE(3.12500000000000000000e-02, 0x3ffa, 0x80000000L, 0x00000000L), HEXCONSTE(9.99755874275756980130e-01, 0x3ffe, 0xfff0003fL, 0xff8e3955L), 0 },
	{ __LINE__, HEXCONSTE(9.76562500000000000000e-04, 0x3ff5, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999761581435109292e-01, 0x3ffe, 0xfffffc00L, 0x00040000L), 0 },
	{ __LINE__, HEXCONSTE(3.05175781250000000000e-05, 0x3ff0, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999999767169356346e-01, 0x3ffe, 0xffffffffL, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9.53674316406250000000e-07, 0x3feb, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999999999772626325e-01, 0x3ffe, 0xffffffffL, 0xffc00000L), 0 },
	{ __LINE__, HEXCONSTE(2.98023223876953125000e-08, 0x3fe6, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999999999999777955e-01, 0x3ffe, 0xffffffffL, 0xfffff000L), 0 },
	{ __LINE__, HEXCONSTE(9.31322574615478515625e-10, 0x3fe1, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999999999999999783e-01, 0x3ffe, 0xffffffffL, 0xfffffffcL), 0 },
	{ __LINE__, HEXCONSTE(2.91038304567337036133e-11, 0x3fdc, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9.09494701772928237915e-13, 0x3fd7, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.84217094304040074348e-14, 0x3fd2, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(8.88178419700125232339e-16, 0x3fcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.77555756156289135106e-17, 0x3fc8, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(8.67361737988403547206e-19, 0x3fc3, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(7.88860905221011805412e-31, 0x3f9b, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.40991986510288411774e-181, 0x3da7, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(5.01237274920645200930e-3011, 0x18ef, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },

	{ __LINE__, HEXCONSTE(0.125L, 0x3ffc, 0x80000000L, 0x00000000L), HEXCONSTE(0.996097563041985204618e, 0x3ffe, 0xff003ff8L, 0xe3fffb73L), 0 },
	{ __LINE__, HEXCONSTE(0.75L, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(0.864242275166648623566, 0x3ffe, 0xdd3efb53L, 0xa950c68fL), 0 },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.765197686557966551453, 0x3ffe, 0xc3e3fedeL, 0xbdc77c1dL), 0 },
	{ __LINE__, HEXCONSTE(1.5, 0x3fff, 0xc0000000L, 0x00000000L), HEXCONSTE(0.511827671735918128732, 0x3ffe, 0x83072367L, 0x4b28d6eaL), 0 },
	{ __LINE__, HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(0.223890779141235668056, 0x3ffc, 0xe5439fd9L, 0x2677be47L), 0 },
	{ __LINE__, HEXCONSTE(8.0, 0x4002, 0x80000000L, 0x00000000L), HEXCONSTE(0.171650807137553906091, 0x3ffc, 0xafc53aabL, 0xf3812962L), 0 },
	{ __LINE__, HEXCONSTE(10.0, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(-0.245935764451348335197, 0xbffc, 0xfbd695c4L, 0xf0f29c19L), 0 },
	{ __LINE__, HEXCONSTE(4.0, 0x4001, 0x80000000L, 0x00000000L), HEXCONSTE(-0.397149809863847372282, 0xbffd, 0xcb573849L, 0xf4a7cb9aL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-4.0, 0xc001, 0x80000000L, 0x00000000L), HEXCONSTE(-0.397149809863847372282, 0xbffd, 0xcb573849L, 0xf4a7cb9aL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.99042308591513901914e+32, 0x406a, 0xebe71d00L, 0x00000000L), HEXCONSTE(2.77552364729123080260e-17, 0x3fc7, 0xffff3300L, 0x34dddb30L), 0 },
	{ __LINE__, HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.01279820264082199887e-20, 0x3fbc, 0xbf4fea77L, 0xb82264a4L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-3.24260049552016421366e+178, 0xc250, 0x80080000L, 0x08000000L), HEXCONSTE(-3.92726996635420620793e-90, 0xbed5, 0xffffeb78L, 0x29d45532L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.01279820264082199887e-20, 0x3fbc, 0xbf4fea77L, 0xb82264a4L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(8.98846567431157953865e+307, 0x43fe, 0x80000000L, 0x00000000L), HEXCONSTE(-1.56652580606090128344e-155, 0xbdfc, 0xd713e11dL, 0xe5fcbec1L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.01279820264082199887e-20, 0x3fbc, 0xbf4fea77L, 0xb82264a4L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-4.18698684958537317299e-155, 0xbdfe, 0x8fb6ce72L, 0x94f33634L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.97432873839307941271e+4931, 0x7ffd, 0x80000000L, 0x00000000L), HEXCONSTE(-1.21937825005090005743e-2466, 0x9fff, 0xaa3e927dL, 0x898c8098L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.01279820264082199887e-20, 0x3fbc, 0xbf4fea77L, 0xb82264a4L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-4.18698684958537317299e-155, 0xbdfe, 0x8fb6ce72L, 0x94f33634L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(5.94865747678615882543e+4931, 0x7ffe, 0x80000000L, 0x00000000L), HEXCONSTE(9.58595028262703746946e-2467, 0x1fff, 0x85d5c0e6L, 0xffc90411L), FLAG_INEXACT },
#endif

#if defined(TEST_FLOAT)
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(7.65197694301605224609e-01, 0x3ffe, 0xc3e3ff00L, 0x00000000L), 0 },
 	{ __LINE__, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.12500000000000000000e-02, 0x3ffa, 0x80000000L, 0x00000000L), HEXCONSTE(9.99755859375000000000e-01, 0x3ffe, 0xfff00000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9.76562500000000000000e-04, 0x3ff5, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999761581420898438e-01, 0x3ffe, 0xfffffc00L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.05175781250000000000e-05, 0x3ff0, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9.53674316406250000000e-07, 0x3feb, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.98023223876953125000e-08, 0x3fe6, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9.31322574615478515625e-10, 0x3fe1, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.91038304567337036133e-11, 0x3fdc, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9.09494701772928237915e-13, 0x3fd7, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.84217094304040074348e-14, 0x3fd2, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(8.88178419700125232339e-16, 0x3fcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.77555756156289135106e-17, 0x3fc8, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(8.67361737988403547206e-19, 0x3fc3, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(7.88860905221011805412e-31, 0x3f9b, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },

	{ __LINE__, HEXCONSTE(1.25000000000000000000e-01, 0x3ffc, 0x80000000L, 0x00000000L), HEXCONSTE(9.96097564697265625000e-01, 0x3ffe, 0xff004000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(7.50000000000000000000e-01, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(8.64242255687713623047e-01, 0x3ffe, 0xdd3efb00L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(7.65197694301605224609e-01, 0x3ffe, 0xc3e3ff00L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.50000000000000000000e+00, 0x3fff, 0xc0000000L, 0x00000000L), HEXCONSTE(5.11827647686004638672e-01, 0x3ffe, 0x83072300L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(2.23890781402587890625e-01, 0x3ffc, 0xe543a000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(8.00000000000000000000e+00, 0x4002, 0x80000000L, 0x00000000L), HEXCONSTE(1.71650812029838562012e-01, 0x3ffc, 0xafc53b00L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+01, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(-2.45935767889022827148e-01, 0xbffc, 0xfbd69600L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.00000000000000000000e+00, 0x4001, 0x80000000L, 0x00000000L), HEXCONSTE(-3.97149801254272460938e-01, 0xbffd, 0xcb573800L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-4.00000000000000000000e+00, 0xc001, 0x80000000L, 0x00000000L), HEXCONSTE(-3.97149801254272460938e-01, 0xbffd, 0xcb573800L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.99042308591513901914e+32, 0x406a, 0xebe71d00L, 0x00000000L), HEXCONSTE(2.77552364715777667692e-17, 0x3fc7, 0xffff3300L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.01279816486407980322e-20, 0x3fbc, 0xbf4fea00L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.01279816486407980322e-20, 0x3fbc, 0xbf4fea00L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.01279816486407980322e-20, 0x3fbc, 0xbf4fea00L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.01279816486407980322e-20, 0x3fbc, 0xbf4fea00L, 0x00000000L), 0 },
#endif

#if defined(TEST_DOUBLE)
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(7.65197686557966605392e-01, 0x3ffe, 0xc3e3fedeL, 0xbdc78000L), 0 },
	{ __LINE__, HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },

	{ __LINE__, HEXCONSTE(3.12500000000000000000e-02, 0x3ffa, 0x80000000L, 0x00000000L), HEXCONSTE(9.99755874275756961644e-01, 0x3ffe, 0xfff0003fL, 0xff8e3800L), 0 },
	{ __LINE__, HEXCONSTE(9.76562500000000000000e-04, 0x3ff5, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999761581435109292e-01, 0x3ffe, 0xfffffc00L, 0x00040000L), 0 },
	{ __LINE__, HEXCONSTE(3.05175781250000000000e-05, 0x3ff0, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999999767169356346e-01, 0x3ffe, 0xffffffffL, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9.53674316406250000000e-07, 0x3feb, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999999999772626325e-01, 0x3ffe, 0xffffffffL, 0xffc00000L), 0 },
	{ __LINE__, HEXCONSTE(2.98023223876953125000e-08, 0x3fe6, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999999999999777955e-01, 0x3ffe, 0xffffffffL, 0xfffff000L), 0 },
	{ __LINE__, HEXCONSTE(9.31322574615478515625e-10, 0x3fe1, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.91038304567337036133e-11, 0x3fdc, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9.09494701772928237915e-13, 0x3fd7, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.84217094304040074348e-14, 0x3fd2, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(8.88178419700125232339e-16, 0x3fcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.77555756156289135106e-17, 0x3fc8, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(8.67361737988403547206e-19, 0x3fc3, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(7.88860905221011805412e-31, 0x3f9b, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.40991986510288411774e-181, 0x3da7, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },

	{ __LINE__, HEXCONSTE(1.25000000000000000000e-01, 0x3ffc, 0x80000000L, 0x00000000L), HEXCONSTE(9.96097563041985156751e-01, 0x3ffe, 0xff003ff8L, 0xe3fff800L), 0 },
	{ __LINE__, HEXCONSTE(7.50000000000000000000e-01, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(8.64242275166648643570e-01, 0x3ffe, 0xdd3efb53L, 0xa950c800L), 0 },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(7.65197686557966605392e-01, 0x3ffe, 0xc3e3fedeL, 0xbdc78000L), 0 },
	{ __LINE__, HEXCONSTE(1.50000000000000000000e+00, 0x3fff, 0xc0000000L, 0x00000000L), HEXCONSTE(5.11827671735918143803e-01, 0x3ffe, 0x83072367L, 0x4b28d800L), 0 },
	{ __LINE__, HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(2.23890779141235674032e-01, 0x3ffc, 0xe5439fd9L, 0x2677c000L), 0 },
	{ __LINE__, HEXCONSTE(8.00000000000000000000e+00, 0x4002, 0x80000000L, 0x00000000L), HEXCONSTE(1.71650807137553901294e-01, 0x3ffc, 0xafc53aabL, 0xf3812800L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+01, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(-2.45935764451348348736e-01, 0xbffc, 0xfbd695c4L, 0xf0f29000L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(4.00000000000000000000e+00, 0x4001, 0x80000000L, 0x00000000L), HEXCONSTE(-3.97149809863847347291e-01, 0xbffd, 0xcb573849L, 0xf4a7d000L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(-4.00000000000000000000e+00, 0xc001, 0x80000000L, 0x00000000L), HEXCONSTE(-3.97149809863847347291e-01, 0xbffd, 0xcb573849L, 0xf4a7d000L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(2.99042308591513901914e+32, 0x406a, 0xebe71d00L, 0x00000000L), HEXCONSTE(2.77552364729123067982e-17, 0x3fc7, 0xffff3300L, 0x34ddd800L), FLAG_INEXACT4|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.01279820264082206206e-20, 0x3fbc, 0xbf4fea77L, 0xb8225800L), FLAG_INEXACT4|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(-3.24260049552016421366e+178, 0xc250, 0x80080000L, 0x08000000L), HEXCONSTE(-3.92726996635420636080e-90, 0xbed5, 0xffffeb78L, 0x29d45800L), FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.01279820264082206206e-20, 0x3fbc, 0xbf4fea77L, 0xb8225800L), FLAG_INEXACT4|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(8.98846567431157953865e+307, 0x43fe, 0x80000000L, 0x00000000L), HEXCONSTE(-1.56652580606090131569e-155, 0xbdfc, 0xd713e11dL, 0xe5fcc000L), FLAG_INEXACT|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.01279820264082206206e-20, 0x3fbc, 0xbf4fea77L, 0xb8225800L), FLAG_INEXACT4|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-4.18698684958537335897e-155, 0xbdfe, 0x8fb6ce72L, 0x94f33800L), FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.01279820264082206206e-20, 0x3fbc, 0xbf4fea77L, 0xb8225800L), FLAG_INEXACT4|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-4.18698684958537335897e-155, 0xbdfe, 0x8fb6ce72L, 0x94f33800L), FLAG_FAIL_ARANYM },
#endif
};


int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_f_f(j0_data, ARRAY_SIZE(j0_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

```

`tests/j1.c`:

```c
#include "testconfig.h"
#define TEST_FUNC_F_F __MATH_PRECNAME(j1)
#include "testdriver.h"



static test_f_f_data const j1_data[] = {
	{ __LINE__, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_P, 0 },
	{ __LINE__, SNAN_P, QNAN_P, 0 },
	{ __LINE__, SNAN_M, QNAN_P, 0 },
	{ __LINE__, INF_P, ZERO_P, 0 },
#if 0 /* ZERO_P also ok */
	{ __LINE__, INF_M, ZERO_M, 0 },
#endif
	{ __LINE__, ZERO_P, ZERO_P, 0 },
#if 0 /* ZERO_P also ok */
	{ __LINE__, ZERO_M, ZERO_M, 0 },
#endif
	{ __LINE__, SUBNORM_P, ZERO_P, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, ZERO_M, FLAG_SUBNORM },
	{ __LINE__, MIN_P, ZERO_P, 0 },
	{ __LINE__, MIN_M, ZERO_M, 0 },
	{ __LINE__, MAX_P, MAX_P, 0 },
	{ __LINE__, MAX_M, MAX_M, 0 },

	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-0.440050585744933515959682203718914913L, 0xbffd, 0xe14e4f74L, 0xb863629bL), 0 },
	{ __LINE__, HEXCONSTE(0.125L, 0x3ffc, 0x80000000L, 0x00000000L), HEXCONSTE(0.0623780091344946810942311355879361177L, 0x3ffa, 0xff801553L, 0x8e4fa438L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(0.75L, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(0.349243602174862192523281016426251335L, 0x3ffd, 0xb2d00eb3L, 0x5b45e3bcL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.440050585744933515959682203718914913L, 0x3ffd, 0xe14e4f74L, 0xb863629bL), 0 },
	{ __LINE__, HEXCONSTE(1.5, 0x3fff, 0xc0000000L, 0x00000000L), HEXCONSTE(0.557936507910099641990121213156089400L, 0x3ffe, 0x8ed4ed4eL, 0xb7e408abL), 0 },
	{ __LINE__, HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(0.576724807756873387202448242269137087L, 0x3ffe, 0x93a43cacL, 0x1b8f7ed8L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(8.0, 0x4002, 0x80000000L, 0x00000000L), HEXCONSTE(0.234636346853914624381276651590454612L, 0x3ffc, 0xf04482b0L, 0xc30c16a5L), FLAG_INEXACT|FLAG_FAIL_ARANYM }, /* seems to be precision error */
	{ __LINE__, HEXCONSTE(10.0, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(0.0434727461688614366697487680258592883L, 0x3ffa, 0xb2107a71L, 0x00488615L), FLAG_INEXACT|FLAG_FAIL_ARANYM }, /* seems to be precision error */

	{ __LINE__, HEXCONSTE(2.36072207283297986806e+22, 0x4049, 0x9ff80000L, 0x00000000L), HEXCONSTE(1.818984347516051243459364437186082741567e-12L, 0x3fd7, 0xffffd15dL, 0xc983090bL), FLAG_INEXACT|FLAG_FAIL_ARANYM },

#ifndef TEST_FLOAT
	{ __LINE__, HEXCONSTE(1.46344799023407084313e+253, 0x4347, 0xff800000L, 0x00001000L), HEXCONSTE(1.846591691699331493194965158699937660696e-127L, 0x3e59, 0xffffdb5eL, 0x5de330edL), FLAG_INEXACT|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(8.98846567431157953865e+307, 0x43fe, 0x80000000L, 0x00000000L), HEXCONSTE(8.2687542933709649327986678723012001545638e-155L, 0x3dff, 0x8de88730L, 0x43bf1671L), FLAG_INEXACT|FLAG_FAIL_ARANYM },
#endif

#if defined(TEST_LDOUBLE) && LDBL_MAX_EXP >= 16384
	{ __LINE__, HEXCONSTE(2.97432873839307941271e+4931, 0x7ffd, 0x80000000L, 0x00000000L), HEXCONSTE(8.0839224448726336195866026476176740513439e-2467L, 0x1ffe, 0xe1ba855bL, 0xa7e7ba4aL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(5.94865747678615882543e+4931, 0x7ffe, 0x80000000L, 0x00000000L), HEXCONSTE(-3.8895531955766020648617743624167352352217e-2467L, 0x9ffd, 0xd937989aL, 0x926f460eL), OVERFLOW_EXCEPTION_OK },
#endif

#ifdef TEST_FLOAT
	{ __LINE__, HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-4.40050572156906127930e-01, 0xbffd, 0xe14e4f00L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.25000000000000000000e-01, 0x3ffc, 0x80000000L, 0x00000000L), HEXCONSTE(6.23780079185962677002e-02, 0x3ffa, 0xff801500L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(7.50000000000000000000e-01, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(3.49243611097335815430e-01, 0x3ffd, 0xb2d00f00L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(4.40050572156906127930e-01, 0x3ffd, 0xe14e4f00L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.50000000000000000000e+00, 0x3fff, 0xc0000000L, 0x00000000L), HEXCONSTE(5.57936489582061767578e-01, 0x3ffe, 0x8ed4ed00L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(5.76724827289581298828e-01, 0x3ffe, 0x93a43d00L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(8.00000000000000000000e+00, 0x4002, 0x80000000L, 0x00000000L), HEXCONSTE(2.34636351466178894043e-01, 0x3ffc, 0xf0448300L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+01, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(4.34727445244789123535e-02, 0x3ffa, 0xb2107a00L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.36072207283297986806e+22, 0x4049, 0x9ff80000L, 0x00000000L), HEXCONSTE(1.81898430779564579396e-12, 0x3fd7, 0xffffd100L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-4.20509381294835813262e-20, 0xbfbe, 0xc6947700L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-4.20509381294835813262e-20, 0xbfbe, 0xc6947700L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-4.20509381294835813262e-20, 0xbfbe, 0xc6947700L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-4.20509381294835813262e-20, 0xbfbe, 0xc6947700L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.12500000000000000000e-02, 0x3ffa, 0x80000000L, 0x00000000L), HEXCONSTE(1.56230926513671875000e-02, 0x3ff8, 0xfff80000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9.76562500000000000000e-04, 0x3ff5, 0x80000000L, 0x00000000L), HEXCONSTE(4.88281191792339086533e-04, 0x3ff3, 0xfffffe00L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.05175781250000000000e-05, 0x3ff0, 0x80000000L, 0x00000000L), HEXCONSTE(1.52587890625000000000e-05, 0x3fef, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9.53674316406250000000e-07, 0x3feb, 0x80000000L, 0x00000000L), HEXCONSTE(4.76837158203125000000e-07, 0x3fea, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.98023223876953125000e-08, 0x3fe6, 0x80000000L, 0x00000000L), HEXCONSTE(1.49011611938476562500e-08, 0x3fe5, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9.31322574615478515625e-10, 0x3fe1, 0x80000000L, 0x00000000L), HEXCONSTE(4.65661287307739257812e-10, 0x3fe0, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.91038304567337036133e-11, 0x3fdc, 0x80000000L, 0x00000000L), HEXCONSTE(1.45519152283668518066e-11, 0x3fdb, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9.09494701772928237915e-13, 0x3fd7, 0x80000000L, 0x00000000L), HEXCONSTE(4.54747350886464118958e-13, 0x3fd6, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.84217094304040074348e-14, 0x3fd2, 0x80000000L, 0x00000000L), HEXCONSTE(1.42108547152020037174e-14, 0x3fd1, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(8.88178419700125232339e-16, 0x3fcd, 0x80000000L, 0x00000000L), HEXCONSTE(4.44089209850062616169e-16, 0x3fcc, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.77555756156289135106e-17, 0x3fc8, 0x80000000L, 0x00000000L), HEXCONSTE(1.38777878078144567553e-17, 0x3fc7, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(8.67361737988403547206e-19, 0x3fc3, 0x80000000L, 0x00000000L), HEXCONSTE(4.33680868994201773603e-19, 0x3fc2, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(7.88860905221011805412e-31, 0x3f9b, 0x80000000L, 0x00000000L), HEXCONSTE(3.94430452610505902706e-31, 0x3f9a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(5.87747175411143753984e-39, 0x3f80, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-5.87747175411143753984e-39, 0xbf80, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), 0 },
#endif

#ifdef TEST_DOUBLE
	{ __LINE__, HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-4.40050585744933497878e-01, 0xbffd, 0xe14e4f74L, 0xb8636000L), 0 },
	{ __LINE__, HEXCONSTE(0.125, 0x3ffc, 0x80000000L, 0x00000000L), HEXCONSTE(6.23780091344946843734e-02, 0x3ffa, 0xff801553L, 0x8e4fa800L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(0.75, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(3.49243602174862166621e-01, 0x3ffd, 0xb2d00eb3L, 0x5b45e000L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(4.40050585744933497878e-01, 0x3ffd, 0xe14e4f74L, 0xb8636000L), 0 },
	{ __LINE__, HEXCONSTE(1.5, 0x3fff, 0xc0000000L, 0x00000000L), HEXCONSTE(5.57936507910099632745e-01, 0x3ffe, 0x8ed4ed4eL, 0xb7e40800L), 0 },
	{ __LINE__, HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(5.76724807756873403264e-01, 0x3ffe, 0x93a43cacL, 0x1b8f8000L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(8.0, 0x4002, 0x80000000L, 0x00000000L), HEXCONSTE(2.34636346853914629085e-01, 0x3ffc, 0xf04482b0L, 0xc30c1800L), FLAG_INEXACT|FLAG_FAIL_ARANYM }, /* seems to be precision error */
	{ __LINE__, HEXCONSTE(10.0, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(4.34727461688614383317e-02, 0x3ffa, 0xb2107a71L, 0x00488800L), FLAG_INEXACT|FLAG_FAIL_ARANYM }, /* seems to be precision error */
	{ __LINE__, HEXCONSTE(2.36072207283297986806e+22, 0x4049, 0x9ff80000L, 0x00000000L), HEXCONSTE(1.81898434751605121714e-12, 0x3fd7, 0xffffd15dL, 0xc9830800L), FLAG_INEXACT|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-4.20509388323757104137e-20, 0xbfbe, 0xc6947737L, 0xb0589800L), FLAG_INEXACT|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(1.46344799023407084313e+253, 0x4347, 0xff800000L, 0x00001000L), HEXCONSTE(1.84659169169933146950e-127, 0x3e59, 0xffffdb5eL, 0x5de33000L), FLAG_INEXACT|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-4.20509388323757104137e-20, 0xbfbe, 0xc6947737L, 0xb0589800L), FLAG_INEXACT|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(8.98846567431157953865e+307, 0x43fe, 0x80000000L, 0x00000000L), HEXCONSTE(8.26875429337096525540e-155, 0x3dff, 0x8de88730L, 0x43bf1800L), FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-4.20509388323757104137e-20, 0xbfbe, 0xc6947737L, 0xb0589800L), FLAG_INEXACT|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(4.22874584882999497959e-155, 0x3dfe, 0x9125bd84L, 0x36acc000L), FLAG_INEXACT|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-4.20509388323757104137e-20, 0xbfbe, 0xc6947737L, 0xb0589800L), FLAG_INEXACT|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(4.22874584882999497959e-155, 0x3dfe, 0x9125bd84L, 0x36acc000L), FLAG_INEXACT|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(3.12500000000000000000e-02, 0x3ffa, 0x80000000L, 0x00000000L), HEXCONSTE(1.56230927289758222964e-02, 0x3ff8, 0xfff80015L, 0x5538e000L), 0 },
	{ __LINE__, HEXCONSTE(9.76562500000000000000e-04, 0x3ff5, 0x80000000L, 0x00000000L), HEXCONSTE(4.88281191792341417567e-04, 0x3ff3, 0xfffffe00L, 0x00015800L), 0 },
	{ __LINE__, HEXCONSTE(3.05175781250000000000e-05, 0x3ff0, 0x80000000L, 0x00000000L), HEXCONSTE(1.52587890607236431606e-05, 0x3fee, 0xffffffffL, 0x80000000L), 0 },
	{ __LINE__, HEXCONSTE(9.53674316406250000000e-07, 0x3feb, 0x80000000L, 0x00000000L), HEXCONSTE(4.76837158203070789891e-07, 0x3fe9, 0xffffffffL, 0xffe00000L), 0 },
	{ __LINE__, HEXCONSTE(2.98023223876953125000e-08, 0x3fe6, 0x80000000L, 0x00000000L), HEXCONSTE(1.49011611938476545956e-08, 0x3fe4, 0xffffffffL, 0xfffff800L), 0 },
	{ __LINE__, HEXCONSTE(9.31322574615478515625e-10, 0x3fe1, 0x80000000L, 0x00000000L), HEXCONSTE(4.65661287307739257812e-10, 0x3fe0, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.91038304567337036133e-11, 0x3fdc, 0x80000000L, 0x00000000L), HEXCONSTE(1.45519152283668518066e-11, 0x3fdb, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9.09494701772928237915e-13, 0x3fd7, 0x80000000L, 0x00000000L), HEXCONSTE(4.54747350886464118958e-13, 0x3fd6, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.84217094304040074348e-14, 0x3fd2, 0x80000000L, 0x00000000L), HEXCONSTE(1.42108547152020037174e-14, 0x3fd1, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(8.88178419700125232339e-16, 0x3fcd, 0x80000000L, 0x00000000L), HEXCONSTE(4.44089209850062616169e-16, 0x3fcc, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.77555756156289135106e-17, 0x3fc8, 0x80000000L, 0x00000000L), HEXCONSTE(1.38777878078144567553e-17, 0x3fc7, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(8.67361737988403547206e-19, 0x3fc3, 0x80000000L, 0x00000000L), HEXCONSTE(4.33680868994201773603e-19, 0x3fc2, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(7.88860905221011805412e-31, 0x3f9b, 0x80000000L, 0x00000000L), HEXCONSTE(3.94430452610505902706e-31, 0x3f9a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(7.00649232162408535462e-46, 0x3f69, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.40991986510288411774e-181, 0x3da7, 0x80000000L, 0x00000000L), HEXCONSTE(1.20495993255144205887e-181, 0x3da6, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(7.00649232162408535462e-46, 0x3f69, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(5.87747175411143753984e-39, 0x3f80, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(1.00208418000448638900e-292, 0x3c35, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-5.87747175411143753984e-39, 0xbf80, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-1.00208418000448638900e-292, 0xbc35, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(7.00649232162408535462e-46, 0x3f69, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-7.00649232162408535462e-46, 0xbf69, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), 0 },
#endif

#if defined(TEST_LDOUBLE) && LDBL_MAX_EXP >= 16384
	{ __LINE__, HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-4.40050585744933515957e-01, 0xbffd, 0xe14e4f74L, 0xb863629bL), 0 },
	{ __LINE__, HEXCONSTE(1.25000000000000000000e-01, 0x3ffc, 0x80000000L, 0x00000000L), HEXCONSTE(6.23780091344946810937e-02, 0x3ffa, 0xff801553L, 0x8e4fa438L), 0 },
	{ __LINE__, HEXCONSTE(7.50000000000000000000e-01, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(3.49243602174862192533e-01, 0x3ffd, 0xb2d00eb3L, 0x5b45e3bcL), 0 },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(4.40050585744933515957e-01, 0x3ffd, 0xe14e4f74L, 0xb863629bL), 0 },
	{ __LINE__, HEXCONSTE(1.50000000000000000000e+00, 0x3fff, 0xc0000000L, 0x00000000L), HEXCONSTE(5.57936507910099642015e-01, 0x3ffe, 0x8ed4ed4eL, 0xb7e408abL), 0 },
	{ __LINE__, HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(5.76724807756873387218e-01, 0x3ffe, 0x93a43cacL, 0x1b8f7ed8L), 0 },
	{ __LINE__, HEXCONSTE(8.00000000000000000000e+00, 0x4002, 0x80000000L, 0x00000000L), HEXCONSTE(2.34636346853914624382e-01, 0x3ffc, 0xf04482b0L, 0xc30c16a5L), 0 },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+01, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(4.34727461688614366681e-02, 0x3ffa, 0xb2107a71L, 0x00488615L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.36072207283297986806e+22, 0x4049, 0x9ff80000L, 0x00000000L), HEXCONSTE(1.81898434751605124347e-12, 0x3fd7, 0xffffd15dL, 0xc983090bL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-4.20509388323757114188e-20, 0xbfbe, 0xc6947737L, 0xb0589956L), 0 },
	{ __LINE__, HEXCONSTE(1.46344799023407084313e+253, 0x4347, 0xff800000L, 0x00001000L), HEXCONSTE(1.84659169169933149323e-127, 0x3e59, 0xffffdb5eL, 0x5de330edL), 0 },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-4.20509388323757114188e-20, 0xbfbe, 0xc6947737L, 0xb0589956L), 0 },
	{ __LINE__, HEXCONSTE(8.98846567431157953865e+307, 0x43fe, 0x80000000L, 0x00000000L), HEXCONSTE(8.26875429337096493275e-155, 0x3dff, 0x8de88730L, 0x43bf1671L), 0 },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-4.20509388323757114188e-20, 0xbfbe, 0xc6947737L, 0xb0589956L), 0 },
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(4.22874584882999520196e-155, 0x3dfe, 0x9125bd84L, 0x36acc226L), 0 },
	{ __LINE__, HEXCONSTE(2.97432873839307941271e+4931, 0x7ffd, 0x80000000L, 0x00000000L), HEXCONSTE(8.08392244487263361951e-2467, 0x1ffe, 0xe1ba855bL, 0xa7e7ba4aL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-4.20509388323757114188e-20, 0xbfbe, 0xc6947737L, 0xb0589956L), 0 },
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(4.22874584882999520196e-155, 0x3dfe, 0x9125bd84L, 0x36acc226L), 0 },
	{ __LINE__, HEXCONSTE(5.94865747678615882543e+4931, 0x7ffe, 0x80000000L, 0x00000000L), HEXCONSTE(-3.88955319557660206490e-2467, 0x9ffd, 0xd937989aL, 0x926f460eL), 0 },
	{ __LINE__, HEXCONSTE(3.12500000000000000000e-02, 0x3ffa, 0x80000000L, 0x00000000L), HEXCONSTE(1.56230927289758230867e-02, 0x3ff8, 0xfff80015L, 0x5538e3a5L), 0 },
	{ __LINE__, HEXCONSTE(9.76562500000000000000e-04, 0x3ff5, 0x80000000L, 0x00000000L), HEXCONSTE(4.88281191792341399488e-04, 0x3ff3, 0xfffffe00L, 0x00015555L), 0 },
	{ __LINE__, HEXCONSTE(3.05175781250000000000e-05, 0x3ff0, 0x80000000L, 0x00000000L), HEXCONSTE(1.52587890607236431606e-05, 0x3fee, 0xffffffffL, 0x80000000L), 0 },
	{ __LINE__, HEXCONSTE(9.53674316406250000000e-07, 0x3feb, 0x80000000L, 0x00000000L), HEXCONSTE(4.76837158203070789891e-07, 0x3fe9, 0xffffffffL, 0xffe00000L), 0 },
	{ __LINE__, HEXCONSTE(2.98023223876953125000e-08, 0x3fe6, 0x80000000L, 0x00000000L), HEXCONSTE(1.49011611938476545956e-08, 0x3fe4, 0xffffffffL, 0xfffff800L), 0 },
	{ __LINE__, HEXCONSTE(9.31322574615478515625e-10, 0x3fe1, 0x80000000L, 0x00000000L), HEXCONSTE(4.65661287307739257762e-10, 0x3fdf, 0xffffffffL, 0xfffffffeL), 0 },
	{ __LINE__, HEXCONSTE(2.91038304567337036133e-11, 0x3fdc, 0x80000000L, 0x00000000L), HEXCONSTE(1.45519152283668518066e-11, 0x3fdb, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9.09494701772928237915e-13, 0x3fd7, 0x80000000L, 0x00000000L), HEXCONSTE(4.54747350886464118958e-13, 0x3fd6, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.84217094304040074348e-14, 0x3fd2, 0x80000000L, 0x00000000L), HEXCONSTE(1.42108547152020037174e-14, 0x3fd1, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(8.88178419700125232339e-16, 0x3fcd, 0x80000000L, 0x00000000L), HEXCONSTE(4.44089209850062616169e-16, 0x3fcc, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.77555756156289135106e-17, 0x3fc8, 0x80000000L, 0x00000000L), HEXCONSTE(1.38777878078144567553e-17, 0x3fc7, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(8.67361737988403547206e-19, 0x3fc3, 0x80000000L, 0x00000000L), HEXCONSTE(4.33680868994201773603e-19, 0x3fc2, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(7.88860905221011805412e-31, 0x3f9b, 0x80000000L, 0x00000000L), HEXCONSTE(3.94430452610505902706e-31, 0x3f9a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(7.00649232162408535462e-46, 0x3f69, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.40991986510288411774e-181, 0x3da7, 0x80000000L, 0x00000000L), HEXCONSTE(1.20495993255144205887e-181, 0x3da6, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(7.00649232162408535462e-46, 0x3f69, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(2.47032822920623272088e-324, 0x3bcc, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(5.01237274920645200930e-3011, 0x18ef, 0x80000000L, 0x00000000L), HEXCONSTE(2.50618637460322600465e-3011, 0x18ee, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(5.87747175411143753984e-39, 0x3f80, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(1.11253692925360069155e-308, 0x3c00, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(8.40525785778023376566e-4933, 0x0000, 0x20000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(1.00208418000448638900e-292, 0x3c35, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-5.87747175411143753984e-39, 0xbf80, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-1.11253692925360069155e-308, 0xbc00, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-8.40525785778023376566e-4933, 0x8000, 0x20000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-1.00208418000448638900e-292, 0xbc35, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(7.00649232162408535462e-46, 0x3f69, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(2.47032822920623272088e-324, 0x3bcc, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-7.00649232162408535462e-46, 0xbf69, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-2.47032822920623272088e-324, 0xbbcc, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), 0 },
#endif

};


int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_f_f(j1_data, ARRAY_SIZE(j1_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

```

`tests/jn.c`:

```c
#include "testconfig.h"
#define TEST_FUNC_IF_F __MATH_PRECNAME(jn)
#include "testdriver.h"



static test_if_f_data const jn_data[] = {
	{ __LINE__, 0, QNAN_P, QNAN_P, 0 },
	{ __LINE__, 0, QNAN_M, QNAN_P, 0 },
	{ __LINE__, 0, SNAN_P, QNAN_P, 0 },
	{ __LINE__, 0, SNAN_M, QNAN_P, 0 },
	{ __LINE__, 0, INF_P, ZERO_P, 0 },
	{ __LINE__, 0, INF_M, ZERO_P, 0 },
	{ __LINE__, 0, ZERO_P, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, 0, ZERO_M, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, 0, SUBNORM_P, ZERO_P, FLAG_SUBNORM },
	{ __LINE__, 0, SUBNORM_M, ZERO_M, FLAG_SUBNORM },
	{ __LINE__, 0, MIN_P, ZERO_P, 0 },
	{ __LINE__, 0, MIN_M, ZERO_M, 0 },
	{ __LINE__, 0, MAX_P, MAX_P, 0 },
	{ __LINE__, 0, MAX_M, MAX_M, 0 },

	/* jn (0, x) == j0 (x)	*/
	{ __LINE__, 0, QNAN_P, QNAN_P, 0 },
	{ __LINE__, 0, INF_P, ZERO_P, 0 },
	{ __LINE__, 0, INF_M, ZERO_P, 0 },
	{ __LINE__, 0, ZERO_P, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, 0, ZERO_M, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if defined(TEST_LDOUBLE) && LDBL_MAX_EXP >= 16384
	{ __LINE__, 0, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(0.765197686557966551449717526102663221L, 0x3ffe, 0xc3e3fedeL, 0xbdc77c1dL), 0 },
	{ __LINE__, 0, HEXCONSTE(0.125L, 0x3ffc, 0x80000000L, 0x00000000L), HEXCONSTE(0.996097563041985204620768999453174712L, 0x3ffe, 0xff003ff8L, 0xe3fffb73L), 0 },
	{ __LINE__, 0, HEXCONSTE(0.75L, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(0.864242275166648623555731103820923211L, 0x3ffe, 0xdd3efb53L, 0xa950c68fL), 0 },
	{ __LINE__, 0, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.765197686557966551449717526102663221L, 0x3ffe, 0xc3e3fedeL, 0xbdc77c1dL), 0 },
	{ __LINE__, 0, HEXCONSTE(1.5, 0x3fff, 0xc0000000L, 0x00000000L), HEXCONSTE(0.511827671735918128749051744283411720L, 0x3ffe, 0x83072367L, 0x4b28d6eaL), 0 },
	{ __LINE__, 0, HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(0.223890779141235668051827454649948626L, 0x3ffc, 0xe5439fd9L, 0x2677be47L), 0 },
	{ __LINE__, 0, HEXCONSTE(8.0, 0x4002, 0x80000000L, 0x00000000L), HEXCONSTE(0.171650807137553906090869407851972001L, 0x3ffc, 0xafc53aabL, 0xf3812962L), 0 },
	{ __LINE__, 0, HEXCONSTE(10.0, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(-0.245935764451348335197760862485328754L, 0xbffc, 0xfbd695c4L, 0xf0f29c19L), 0 },
	{ __LINE__, 0, HEXCONSTE(4.0, 0x4001, 0x80000000L, 0x00000000L), HEXCONSTE(-3.9714980986384737228659076845169804197562E-1L, 0xbffd, 0xcb573849L, 0xf4a7cb9aL), FLAG_INEXACT },
	{ __LINE__, 0, HEXCONSTE(-4.0, 0xc001, 0x80000000L, 0x00000000L), HEXCONSTE(-3.9714980986384737228659076845169804197562E-1L, 0xbffd, 0xcb573849L, 0xf4a7cb9aL), FLAG_INEXACT },
#endif

	/* jn (1, x) == j1 (x)	*/
	{ __LINE__, 1, QNAN_P, QNAN_P, 0 },
	{ __LINE__, 1, INF_P, ZERO_P, 0 },
#if 0 /* ZERO_P also ok */
	{ __LINE__, 1, INF_M, ZERO_M, 0 },
#endif
	{ __LINE__, 1, ZERO_P, ZERO_P, 0 },
	{ __LINE__, 1, ZERO_M, ZERO_M, FLAG_FAIL_ARANYM2 },
	{ __LINE__, 1, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-0.440050585744933515959682203718914913L, 0xbffd, 0xe14e4f74L, 0xb863629bL), 0 },
	{ __LINE__, 1, HEXCONSTE(0.125L, 0x3ffc, 0x80000000L, 0x00000000L), HEXCONSTE(0.0623780091344946810942311355879361177L, 0x3ffa, 0xff801553L, 0x8e4fa438L), FLAG_INEXACT },
	{ __LINE__, 1, HEXCONSTE(0.75L, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(0.349243602174862192523281016426251335L, 0x3ffd, 0xb2d00eb3L, 0x5b45e3bcL), FLAG_INEXACT },
	{ __LINE__, 1, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.440050585744933515959682203718914913L, 0x3ffd, 0xe14e4f74L, 0xb863629bL), 0 },
	{ __LINE__, 1, HEXCONSTE(1.5, 0x3fff, 0xc0000000L, 0x00000000L), HEXCONSTE(0.557936507910099641990121213156089400L, 0x3ffe, 0x8ed4ed4eL, 0xb7e408abL), 0 },
	{ __LINE__, 1, HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(0.576724807756873387202448242269137087L, 0x3ffe, 0x93a43cacL, 0x1b8f7ed8L), FLAG_INEXACT },
	{ __LINE__, 1, HEXCONSTE(8.0, 0x4002, 0x80000000L, 0x00000000L), HEXCONSTE(0.234636346853914624381276651590454612L, 0x3ffc, 0xf04482b0L, 0xc30c16a5L), FLAG_INEXACT|FLAG_FAIL_ARANYM }, /* seems to be precision error */
	{ __LINE__, 1, HEXCONSTE(10.0, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(0.0434727461688614366697487680258592883L, 0x3ffa, 0xb2107a71L, 0x00488615L), FLAG_INEXACT|FLAG_FAIL_ARANYM }, /* seems to be precision error */

	/* jn (3, x)  */
	{ __LINE__, 3, QNAN_P, QNAN_P, 0 },
	{ __LINE__, 3, INF_P, ZERO_P, 0 },

	{ __LINE__, 3, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-0.0195633539826684059189053216217515083L, 0xbff9, 0xa04353b1L, 0xc7bd1561L), FLAG_INEXACT },
	{ __LINE__, 3, ZERO_P, ZERO_P, 0 },
	{ __LINE__, 3, HEXCONSTE(0.125L, 0x3ffc, 0x80000000L, 0x00000000L), HEXCONSTE(0.406503832554912875023029337653442868e-4L, 0x3ff0, 0xaa800444L, 0x0797f972L), FLAG_INEXACT },
	{ __LINE__, 3, HEXCONSTE(0.75L, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(0.848438342327410884392755236884386804e-2L, 0x3ff8, 0x8b021555L, 0x1996c263L), FLAG_INEXACT },
	{ __LINE__, 3, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.0195633539826684059189053216217515083L, 0x3ff9, 0xa04353b1L, 0xc7bd1561L), FLAG_INEXACT },
	{ __LINE__, 3, HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(0.128943249474402051098793332969239835L, 0x3ffc, 0x8409b2feL, 0x214e7ed1L), FLAG_INEXACT },
	{ __LINE__, 3, HEXCONSTE(10.0, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(0.0583793793051868123429354784103409563L, 0x3ffa, 0xef1f374eL, 0x06602c7bL), FLAG_INEXACT|FLAG_FAIL_ARANYM }, /* seems to be precision error */

	/*	jn (10, x)	*/
	{ __LINE__, 10, QNAN_P, QNAN_P, 0 },
	{ __LINE__, 10, INF_P, ZERO_P, 0 },

	{ __LINE__, 10, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(0.263061512368745320699785368779050294e-9L, 0x3fdf, 0x909e9dd5L, 0x2794ac6dL), FLAG_INEXACT },
	{ __LINE__, 10, ZERO_P, ZERO_P, 0 },
	{ __LINE__, 10, HEXCONSTE(0.125L, 0x3ffc, 0x80000000L, 0x00000000L), HEXCONSTE(0.250543369809369890173993791865771547e-18L, 0x3fc1, 0x93e50b28L, 0x841a1b65L), FLAG_INEXACT },
	{ __LINE__, 10, HEXCONSTE(0.75L, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(0.149621713117596814698712483621682835e-10L, 0x3fdb, 0x839bd087L, 0xccdc8399L), FLAG_INEXACT },
	{ __LINE__, 10, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.263061512368745320699785368779050294e-9L, 0x3fdf, 0x909e9dd5L, 0x2794ac6dL), FLAG_INEXACT },
	{ __LINE__, 10, HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(0.251538628271673670963516093751820639e-6L, 0x3fe9, 0x870b34b1L, 0x1b70d655L), FLAG_INEXACT },
	{ __LINE__, 10, HEXCONSTE(10.0, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(0.207486106633358857697278723518753428L, 0x3ffc, 0xd4773ce9L, 0x75657ccaL), FLAG_INEXACT2|FLAG_FAIL_ARANYM }, /* seems to be precision error */

	/* BZ #11589 .*/
	{ __LINE__, 2, HEXCONSTE(2.4048255576957729L, 0x4000, 0x99e8a974L, 0xb8da003fL), HEXCONSTE(0.43175480701968038399746111312430703L, 0x3ffd, 0xdd0ef750L, 0x14a49f9eL), FLAG_INEXACT|FLAG_FAIL_ARANYM },
	{ __LINE__, 3, HEXCONSTE(2.4048255576957729L, 0x4000, 0x99e8a974L, 0xb8da003fL), HEXCONSTE(0.19899990535769083404042146764530813L, 0x3ffc, 0xcbc6a195L, 0xac6b1a49L), FLAG_INEXACT|FLAG_FAIL_SOFTFLOAT|FLAG_FAIL_HARDFLOAT|FLAG_FAIL_ARANYM },
	{ __LINE__, 4, HEXCONSTE(2.4048255576957729L, 0x4000, 0x99e8a974L, 0xb8da003fL), HEXCONSTE(0.647466661641779720084932282551219891E-1L, 0x3ffb, 0x8499e66dL, 0x99f4e87dL), FLAG_INEXACT|FLAG_FAIL_SOFTFLOAT|FLAG_FAIL_HARDFLOAT|FLAG_FAIL_ARANYM },
	{ __LINE__, 5, HEXCONSTE(2.4048255576957729L, 0x4000, 0x99e8a974L, 0xb8da003fL), HEXCONSTE(0.163892432048058525099230549946147698E-1L, 0x3ff9, 0x8642bbf2L, 0x4440245dL), FLAG_INEXACT|FLAG_FAIL_SOFTFLOAT|FLAG_FAIL_HARDFLOAT|FLAG_FAIL_ARANYM },
	{ __LINE__, 6, HEXCONSTE(2.4048255576957729L, 0x4000, 0x99e8a974L, 0xb8da003fL), HEXCONSTE(0.34048184720278336646673682895929161E-2L, 0x3ff6, 0xdf235ffcL, 0x760bbb65L), FLAG_INEXACT|FLAG_FAIL_SOFTFLOAT|FLAG_FAIL_HARDFLOAT|FLAG_FAIL_ARANYM },
	{ __LINE__, 7, HEXCONSTE(2.4048255576957729L, 0x4000, 0x99e8a974L, 0xb8da003fL), HEXCONSTE(0.60068836573295394221291569249883076E-3L, 0x3ff4, 0x9d77838bL, 0x2c2e4f57L), FLAG_INEXACT|FLAG_FAIL_SOFTFLOAT|FLAG_FAIL_HARDFLOAT|FLAG_FAIL_ARANYM },
	{ __LINE__, 8, HEXCONSTE(2.4048255576957729L, 0x4000, 0x99e8a974L, 0xb8da003fL), HEXCONSTE(0.92165786705344923232879022467054148E-4L, 0x3ff1, 0xc1492145L, 0x4d000160L), FLAG_INEXACT|FLAG_FAIL_SOFTFLOAT|FLAG_FAIL_HARDFLOAT|FLAG_FAIL_ARANYM },
	{ __LINE__, 9, HEXCONSTE(2.4048255576957729L, 0x4000, 0x99e8a974L, 0xb8da003fL), HEXCONSTE(0.12517270977961513005428966643852564E-4L, 0x3fee, 0xd20144fdL, 0x00b01a7fL), FLAG_INEXACT|FLAG_FAIL_SOFTFLOAT|FLAG_FAIL_HARDFLOAT|FLAG_FAIL_ARANYM },

	/* Bug 14155: spurious exception may occur.  */
	{ __LINE__, 2, HEXCONSTE(1.26764463115699505427e+30, 0x4062, 0xffffb100L, 0x00000000L), HEXCONSTE(-4.43860668048170034334926693188979974489e-16L, 0xbfcb, 0xffde45efL, 0x5192d053L), UNDERFLOW_EXCEPTION_OK|FLAG_INEXACT|FLAG_FAIL_ARANYM },
};


int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_if_f(jn_data, ARRAY_SIZE(jn_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

```

`tests/ldexp.c`:

```c
#include "testconfig.h"
#define TEST_FUNC_FI_F __MATH_PRECNAME(ldexp)
#include "testdriver.h"



static test_fi_f_data const ldexp_data[] = {
	{ __LINE__, ZERO_P, 0, ZERO_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_M, 0, ZERO_M, NO_INEXACT_EXCEPTION|FLAG_FAIL_ARANYM2 },

	{ __LINE__, INF_P, 1, INF_P, NO_INEXACT_EXCEPTION|FLAG_FAIL_ARANYM }, /* glibc returns NaN */
	{ __LINE__, INF_M, 1, INF_M, NO_INEXACT_EXCEPTION|FLAG_FAIL_ARANYM }, /* glibc returns NaN */
	{ __LINE__, QNAN_P, 1, QNAN_P, NO_INEXACT_EXCEPTION },

	{ __LINE__, QNAN_P, 1, QNAN_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_M, 1, QNAN_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, SNAN_P, 1, QNAN_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, SNAN_M, 1, QNAN_P, NO_INEXACT_EXCEPTION },

	{ __LINE__, HEXCONSTE(0.000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0, HEXCONSTE(0.000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(5.000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), 1, HEXCONSTE(1.000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(5.000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), 2, HEXCONSTE(2.000000e+00, 0x4000, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(5.000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), 3, HEXCONSTE(4.000000e+00, 0x4001, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(5.000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), 4, HEXCONSTE(8.000000e+00, 0x4002, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(5.000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), 9, HEXCONSTE(2.560000e+02, 0x4007, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(5.000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), 16, HEXCONSTE(3.276800e+04, 0x400e, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-5.000000e-01, 0xbffe, 0x80000000L, 0x00000000L), 1, HEXCONSTE(-1.000000e+00, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-5.000000e-01, 0xbffe, 0x80000000L, 0x00000000L), 2, HEXCONSTE(-2.000000e+00, 0xc000, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-5.000000e-01, 0xbffe, 0x80000000L, 0x00000000L), 3, HEXCONSTE(-4.000000e+00, 0xc001, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-5.000000e-01, 0xbffe, 0x80000000L, 0x00000000L), 4, HEXCONSTE(-8.000000e+00, 0xc002, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-5.000000e-01, 0xbffe, 0x80000000L, 0x00000000L), 9, HEXCONSTE(-2.560000e+02, 0xc007, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-5.000000e-01, 0xbffe, 0x80000000L, 0x00000000L), 16, HEXCONSTE(-3.276800e+04, 0xc00e, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(6.172500e-01, 0x3ffe, 0x9e041893L, 0x74bc6a7fL), 1, HEXCONSTE(1.234500e+00, 0x3fff, 0x9e041893L, 0x74bc6a7fL), 0 },
	{ __LINE__, HEXCONSTE(7.185736e-01, 0x3ffe, 0xb7f4707fL, 0xc4dc3d83L), 34, HEXCONSTE(1.234500e+10, 0x4020, 0xb7f4707fL, 0xc4dc3d83), 0 },
	{ __LINE__, HEXCONSTE(5.855878e-01, 0x3ffe, 0x95e91501L, 0xefc4489aL), 69, HEXCONSTE(3.456700e+20, 0x4043, 0x95e91501L, 0xefc4489aL), 0 },
	{ __LINE__, HEXCONSTE(5.663457e-01, 0x3ffe, 0x90fc0823L, 0xbaf02b77L), -14, HEXCONSTE(3.456700e-05, 0x3ff0, 0x90fc0823L, 0xbaf02b77L), 0 },
	{ __LINE__, HEXCONSTE(-6.172500e-01, 0xbffe, 0x9e041893L, 0x74bc6a7fL), 1, HEXCONSTE(-1.234500e+00, 0xbfff, 0x9e041893L, 0x74bc6a7fL), 0 },
	{ __LINE__, HEXCONSTE(-7.185736e-01, 0xbffe, 0xb7f4707fL, 0xc4dc3d83L), 34, HEXCONSTE(-1.234500e+10, 0xc020, 0xb7f4707fL, 0xc4dc3d83L), 0 },
	{ __LINE__, HEXCONSTE(-5.855878e-01, 0xbffe, 0x95e91501L, 0xefc4489aL), 69, HEXCONSTE(-3.456700e+20, 0xc043, 0x95e91501L, 0xefc4489aL), FLAG_XFAIL }, /* slighly different */
	{ __LINE__, HEXCONSTE(-5.663457e-01, 0xbffe, 0x90fc0823L, 0xbaf02b77L), -14, HEXCONSTE(-3.456700e-05, 0xbff0, 0x90fc0823L, 0xbaf02b77L), FLAG_XFAIL }, /* slighly different */
	
	{ __LINE__, HEXCONSTE(0.8L, 0x3ffe, 0xccccccccL, 0xcccccccdL), 4, HEXCONSTE(12.8L, 0x4002, 0xccccccccL, 0xcccccccdL), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-0.854375L, 0xbffe, 0xdab851ebL, 0x851eb852L), 5, HEXCONSTE(-27.34L, 0xc003, 0xdab851ebL, 0x851eb852L), NO_INEXACT_EXCEPTION },

	/* ldexp (x, 0) == x.  */
	{ __LINE__, HEXCONSTE(1.0L, 0x3fff, 0x80000000L, 0x00000000L), 0L, HEXCONSTE(1.0L, 0x3fff, 0x80000000L, 0x00000000L), NO_INEXACT_EXCEPTION },
};

int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_fi_f(ldexp_data, ARRAY_SIZE(ldexp_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

```

`tests/lgamma.c`:

```c
#include "testconfig.h"
#define TEST_FUNC_F_F __MATH_PRECNAME(lgamma)
#include "testdriver.h"

#define M_LOG_SQRT_PI         HEXCONSTE(0.57236494292470008707171367567652933L, 0x3ffe, 0x92868247L, 0x3d0de85fL)  /* log(sqrt(M_PI))  */
#define M_LOG_2_SQRT_PI       HEXCONSTE(1.265512123484645396488945797134706L, 0x3fff, 0xa1fc4d1fL, 0x876eb105L)    /* log(2*sqrt(M_PIl))  */


static test_f_f_data const lgamma_data[] = {
	{ __LINE__, QNAN_P, QNAN_P, /* signgam = 0, */ 0 },
	{ __LINE__, QNAN_M, QNAN_M, /* signgam = 0, */ 0 },
	{ __LINE__, SNAN_P, QNAN_P, /* signgam = 0, */ 0 },
	{ __LINE__, SNAN_M, QNAN_M, /* signgam = 0, */ 0 },
	{ __LINE__, INF_P, INF_P, /* signgam = 1, */ 0 },
	{ __LINE__, INF_M, INF_P, /* signgam = 0, */ 0 },
	{ __LINE__, ZERO_P, INF_P, /* signgam = 1, */ DIVIDE_BY_ZERO_EXCEPTION|ERRNO_ERANGE },
	{ __LINE__, ZERO_M, INF_P, /* signgam = -1, */ DIVIDE_BY_ZERO_EXCEPTION|ERRNO_ERANGE },
	{ __LINE__, MAX_M, INF_P, /* signgam = 0, */ DIVIDE_BY_ZERO_EXCEPTION|ERRNO_ERANGE },
	{ __LINE__, MAX_P, INF_P, /* signgam = 1, */ OVERFLOW_EXCEPTION|ERRNO_ERANGE },

	/* lgamma (x) == +inf plus divide by zero exception for integer x <= 0.  */
	{ __LINE__, HEXCONSTE(-3, 0xc000, 0xc0000000L, 0x00000000L), INF_P, /* signgam = 0, */ DIVIDE_BY_ZERO_EXCEPTION|ERRNO_ERANGE },

	{ __LINE__, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), ZERO_P, /* signgam = 1, */ 0 },
	{ __LINE__, HEXCONSTE(2, 0x4000, 0x80000000L, 0x00000000L), ZERO_P, /* signgam = 1, */ 0 },
	{ __LINE__, HEXCONSTE(3, 0x4000, 0xc0000000L, 0x00000000L), HEXCONST_LN2, /* signgam = 1, */ 0 },

	{ __LINE__, HEXCONSTE(0.5, 0x3ffe, 0x80000000L, 0x00000000L), M_LOG_SQRT_PI, /* signgam = 1, */ 0 },
	{ __LINE__, HEXCONSTE(-0.5, 0xbffe, 0x80000000L, 0x00000000L), M_LOG_2_SQRT_PI, /* signgam = -1 */ FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(0.7L, 0x3ffe, 0xb3333333L, 0x33333333L), HEXCONSTE(0.260867246531666514385732417016759578L, 0x3ffd, 0x85906448L, 0xe6f39423L), /* signgam = 1, */ FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.2L, 0x3fff, 0x99999999L, 0x9999999aL), HEXCONSTE(-0.853740900033158497197028392998854470e-1L, 0xbffb, 0xaed89c63L, 0xeb863966L), /* signgam = 1, */ FLAG_INEXACT },
};


int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_f_f(lgamma_data, ARRAY_SIZE(lgamma_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

```

`tests/llrint.c`:

```c
#include "testconfig.h"
#if defined(HAVE_LLRINT)
#define TEST_FUNC_F_LL __MATH_PRECNAME(llrint)
#include "testdriver.h"



static test_f_ll_data const llrint_data[] = {
	{ __LINE__, QNAN_P, LONG_LONG_MIN, 0 },
	{ __LINE__, QNAN_M, LONG_LONG_MIN, 0 },
	{ __LINE__, SNAN_P, LONG_LONG_MIN, 0 },
	{ __LINE__, SNAN_M, LONG_LONG_MIN, 0 },
	{ __LINE__, INF_P, LONG_LONG_MIN, 0 },
	{ __LINE__, INF_M, LONG_LONG_MIN, 0 },
	{ __LINE__, ZERO_P, 0, 0 },
	{ __LINE__, ZERO_M, 0, 0 },
	{ __LINE__, SUBNORM_P, 0, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, 0, FLAG_SUBNORM },
	{ __LINE__, MIN_P, 0, 0 },
	{ __LINE__, MIN_M, 0, 0 },
	{ __LINE__, MAX_P, LONG_LONG_MIN, 0 },
	{ __LINE__, MAX_M, LONG_LONG_MIN, 0 },

	{ __LINE__, HEXCONSTE(0.2L, 0x3ffc, 0xccccccccL, 0xcccccccdL), 0, INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-0.2L, 0xbffc, 0xccccccccL, 0xcccccccdL), 0, INEXACT_EXCEPTION },

	{ __LINE__, HEXCONSTE(1.0L, 0x3fff, 0x80000000L, 0x00000000L), 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.4L, 0x3fff, 0xb3333333L, 0x33333333L), 1, INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.5L, 0x3fff, 0xc0000000L, 0x00000000L), 2, INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.6L, 0x3fff, 0xccccccccL, 0xcccccccdL), 2, INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(2.4L, 0x4000, 0x99999999L, 0x9999999aL), 2, INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(2.5L, 0x4000, 0xa0000000L, 0x00000000L), 2, INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(2.6L, 0x4000, 0xa6666666L, 0x66666666L), 3, INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(3.4L, 0x4000, 0xd9999999L, 0x9999999aL), 3, INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(3.5L, 0x4000, 0xe0000000L, 0x00000000L), 4, INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(3.6L, 0x4000, 0xe6666666L, 0x66666666L), 4, INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-0.4L, 0xbffd, 0xccccccccL, 0xcccccccdL), 0, INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-0.5L, 0xbffe, 0x80000000L, 0x00000000L), 0, INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-0.6L, 0xbffe, 0x99999999L, 0x9999999aL), -1, INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-1.0L, 0xbfff, 0x80000000L, 0x00000000L), -1, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-1.4L, 0xbfff, 0xb3333333L, 0x33333333L), -1, INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-1.5L, 0xbfff, 0xc0000000L, 0x00000000L), -2, INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-1.6L, 0xbfff, 0xccccccccL, 0xcccccccdL), -2, INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-2.4L, 0xc000, 0x99999999L, 0x9999999aL), -2, INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-2.5L, 0xc000, 0xa0000000L, 0x00000000L), -2, INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-2.6L, 0xc000, 0xa6666666L, 0x66666666L), -3, INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-3.4L, 0xc000, 0xd9999999L, 0x9999999aL), -3, INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-3.5L, 0xc000, 0xe0000000L, 0x00000000L), -4, INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-3.6L, 0xc000, 0xe6666666L, 0x66666666L), -4, INEXACT_EXCEPTION },

	{ __LINE__, HEXCONSTE(8388600.3L, 0x4015, 0xfffff099L, 0x9999999aL), 8388600LL, 0 },
	{ __LINE__, HEXCONSTE(-8388600.3L, 0xc015, 0xfffff099L, 0x9999999aL), -8388600LL, 0 },

#ifndef TEST_FLOAT
	{ __LINE__, HEXCONSTE(1071930.0008, 0x4013, 0x82d9d001L, 0xa36e2eb2L), 1071930LL, 0 },
#endif

	/* Test boundary conditions.  */
	/* 0x1FFFFF */
	{ __LINE__, HEXCONSTE(2097151.0, 0x4013, 0xfffff800L, 0x00000000L), 2097151LL, 0 },
	/* 0x800000 */
	{ __LINE__, HEXCONSTE(8388608.0, 0x4016, 0x80000000L, 0x00000000L), 8388608LL, 0 },
	/* 0x1000000 */
	{ __LINE__, HEXCONSTE(16777216.0, 0x4017, 0x80000000L, 0x00000000L), 16777216LL, NO_INEXACT_EXCEPTION },
	/* 0x20000000000 */
	{ __LINE__, HEXCONSTE(2199023255552.0, 0x4028, 0x80000000L, 0x00000000L), 2199023255552LL, NO_INEXACT_EXCEPTION },
	/* 0x40000000000 */
	{ __LINE__, HEXCONSTE(4398046511104.0, 0x4029, 0x80000000L, 0x00000000L), 4398046511104LL, NO_INEXACT_EXCEPTION },
	/* 0x1000000000000 */
	{ __LINE__, HEXCONSTE(281474976710656.0, 0x402f, 0x80000000L, 0x00000000L), 281474976710656LL, NO_INEXACT_EXCEPTION },
	/* 0x10000000000000 */
	{ __LINE__, HEXCONSTE(4503599627370496.0, 0x4033, 0x80000000L, 0x00000000L), 4503599627370496LL, NO_INEXACT_EXCEPTION },
	/* 0x10000080000000 */
	{ __LINE__, HEXCONSTE(4503601774854144.0, 0x4033, 0x80000400L, 0x00000000L), 4503601774854144LL, 0 },
	/* 0x20000000000000 */
	{ __LINE__, HEXCONSTE(9007199254740992.0, 0x4034, 0x80000000L, 0x00000000L), 9007199254740992LL, NO_INEXACT_EXCEPTION },
	/* 0x80000000000000 */
	{ __LINE__, HEXCONSTE(36028797018963968.0, 0x4036, 0x80000000L, 0x00000000L), 36028797018963968LL, NO_INEXACT_EXCEPTION },
	/* 0x100000000000000 */
	{ __LINE__, HEXCONSTE(72057594037927936.0, 0x4037, 0x80000000L, 0x00000000L), 72057594037927936LL, NO_INEXACT_EXCEPTION },
#ifdef TEST_LDOUBLE
	/* The input can only be represented in long double.  */
	{ __LINE__, HEXCONSTE(4503599627370495.5L, 0x4032, 0xffffffffL, 0xfffff800L), 4503599627370496LL, 0 },
	{ __LINE__, HEXCONSTE(4503599627370496.25L, 0x4033, 0x80000000L, 0x00000200L), 4503599627370496LL, 0 },
	{ __LINE__, HEXCONSTE(4503599627370496.5L, 0x4033, 0x80000000L, 0x00000400L), 4503599627370496LL, 0 },
	{ __LINE__, HEXCONSTE(4503599627370496.75L, 0x4033, 0x80000000L, 0x00000600L), 4503599627370497LL, 0 },
	{ __LINE__, HEXCONSTE(4503599627370497.5L, 0x4033, 0x80000000L, 0x00000c00L), 4503599627370498LL, 0 },

	{ __LINE__, HEXCONSTE(-4503599627370495.5L, 0xc032, 0xffffffffL, 0xfffff800L), -4503599627370496LL, 0 },
	{ __LINE__, HEXCONSTE(-4503599627370496.25L, 0xc033, 0x80000000L, 0x00000200L), -4503599627370496LL, 0 },
	{ __LINE__, HEXCONSTE(-4503599627370496.5L, 0xc033, 0x80000000L, 0x00000400L), -4503599627370496LL, 0 },
	{ __LINE__, HEXCONSTE(-4503599627370496.75L, 0xc033, 0x80000000L, 0x00000600L), -4503599627370497LL, 0 },
	{ __LINE__, HEXCONSTE(-4503599627370497.5L, 0xc033, 0x80000000L, 0x00000c00L), -4503599627370498LL, 0 },

	{ __LINE__, HEXCONSTE(9007199254740991.5L, 0x4033, 0xffffffffL, 0xfffffc00L), 9007199254740992LL, 0 },
	{ __LINE__, HEXCONSTE(9007199254740992.25L, 0x4034, 0x80000000L, 0x00000100L), 9007199254740992LL, 0 },
	{ __LINE__, HEXCONSTE(9007199254740992.5L, 0x4034, 0x80000000L, 0x00000200L), 9007199254740992LL, 0 },
	{ __LINE__, HEXCONSTE(9007199254740992.75L, 0x4034, 0x80000000L, 0x00000300L), 9007199254740993LL, 0 },
	{ __LINE__, HEXCONSTE(9007199254740993.5L, 0x4034, 0x80000000L, 0x00000600L), 9007199254740994LL, 0 },

	{ __LINE__, HEXCONSTE(-9007199254740991.5L, 0xc033, 0xffffffffL, 0xfffffc00L), -9007199254740992LL, 0 },
	{ __LINE__, HEXCONSTE(-9007199254740992.25L, 0xc034, 0x80000000L, 0x00000100L), -9007199254740992LL, 0 },
	{ __LINE__, HEXCONSTE(-9007199254740992.5L, 0xc034, 0x80000000L, 0x00000200L), -9007199254740992LL, 0 },
	{ __LINE__, HEXCONSTE(-9007199254740992.75L, 0xc034, 0x80000000L, 0x00000300L), -9007199254740993LL, 0 },
	{ __LINE__, HEXCONSTE(-9007199254740993.5L, 0xc034, 0x80000000L, 0x00000600L), -9007199254740994LL, 0 },

	{ __LINE__, HEXCONSTE(72057594037927935.5L, 0x4036, 0xffffffffL, 0xffffff80L), 72057594037927936LL, 0 },
	{ __LINE__, HEXCONSTE(72057594037927936.25L, 0x4037, 0x80000000L, 0x00000020L), 72057594037927936LL, 0 },
	{ __LINE__, HEXCONSTE(72057594037927936.5L, 0x4037, 0x80000000L, 0x00000040L), 72057594037927936LL, 0 },
	{ __LINE__, HEXCONSTE(72057594037927936.75L, 0x4037, 0x80000000L, 0x00000060L), 72057594037927937LL, 0 },
	{ __LINE__, HEXCONSTE(72057594037927937.5L, 0x4037, 0x80000000L, 0x000000c0L), 72057594037927938LL, 0 },

	{ __LINE__, HEXCONSTE(-72057594037927935.5L, 0xc036, 0xffffffffL, 0xffffff80L), -72057594037927936LL, 0 },
	{ __LINE__, HEXCONSTE(-72057594037927936.25L, 0xc037, 0x80000000L, 0x00000020L), -72057594037927936LL, 0 },
	{ __LINE__, HEXCONSTE(-72057594037927936.5L, 0xc037, 0x80000000L, 0x00000040L), -72057594037927936LL, 0 },
	{ __LINE__, HEXCONSTE(-72057594037927936.75L, 0xc037, 0x80000000L, 0x00000060L), -72057594037927937LL, 0 },
	{ __LINE__, HEXCONSTE(-72057594037927937.5L, 0xc037, 0x80000000L, 0x000000c0L), -72057594037927938LL, 0 },
#endif

#if 0
	{ __LINE__, HEXCONSTE(0.2L, 0x3ffc, 0xccccccccL, 0xcccccccdL), 0, INEXACT_EXCEPTION|ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(-0.2L, 0xbffc, 0xccccccccL, 0xcccccccdL), 0, INEXACT_EXCEPTION|ROUND_TONEAREST },

	{ __LINE__, HEXCONSTE(1.4L, 0x3fff, 0xb3333333L, 0x33333333L), 1, INEXACT_EXCEPTION|ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(-1.4L, 0xbfff, 0xb3333333L, 0x33333333L), -1, INEXACT_EXCEPTION|ROUND_TONEAREST },

	{ __LINE__, HEXCONSTE(8388600.3L, 0x4015, 0xfffff099L, 0x9999999aL), 8388600LL, ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(-8388600.3L, 0xc015, 0xfffff099L, 0x9999999aL), -8388600LL, ROUND_TONEAREST },

#ifndef TEST_FLOAT
	{ __LINE__, HEXCONSTE(1071930.0008, 0x4013, 0x82d9d001L, 0xa36e2eb2L), 1071930LL, ROUND_TONEAREST },
#endif

	/* Test boundary conditions.  */
	/* 0x1FFFFF */
	{ __LINE__, HEXCONSTE(2097151.0, 0x4013, 0xfffff800L, 0x00000000L),2097151LL, ROUND_TONEAREST },
	/* 0x800000 */
	{ __LINE__, HEXCONSTE(8388608.0, 0x4016, 0x80000000L, 0x00000000L), 8388608LL, NO_INEXACT_EXCEPTION|ROUND_TONEAREST },
	/* 0x1000000 */
	{ __LINE__, HEXCONSTE(16777216.0, 0x4017, 0x80000000L, 0x00000000L), 16777216LL, NO_INEXACT_EXCEPTION|ROUND_TONEAREST },
	/* 0x80000000 */
	{ __LINE__, HEXCONSTE(2147483648.0, 0x401e, 0x80000000L, 0x00000000L), 2147483648LL, NO_INEXACT_EXCEPTION|ROUND_TONEAREST },
#ifndef TEST_FLOAT
	{ __LINE__, HEXCONSTE(2147483648.2, 0x401e, 0x80000000L, 0x33333333L), 2147483648LL, ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(2147483648.5, 0x401e, 0x80000000L, 0x80000000L), 2147483648LL, ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(2147483648.7, 0x401e, 0x80000000L, 0xb3333333L), 2147483649LL, ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(-2147483648.2, 0xc01e, 0x80000000L, 0x33333333L), -2147483648LL, ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(-2147483648.5, 0xc01e, 0x80000000L, 0x80000000L), -2147483648LL, ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(-2147483648.7, 0xc01e, 0x80000000L, 0xb3333333L), -2147483649LL, ROUND_TONEAREST },
#endif
	/* 0x20000000000 */
	{ __LINE__, HEXCONSTE(2199023255552.0, 0x4028, 0x80000000L, 0x00000000L), 2199023255552LL, NO_INEXACT_EXCEPTION|ROUND_TONEAREST },
	/* 0x40000000000 */
	{ __LINE__, HEXCONSTE(4398046511104.0, 0x4029, 0x80000000L, 0x00000000L), 4398046511104LL, NO_INEXACT_EXCEPTION|ROUND_TONEAREST },
	/* 0x1000000000000 */
	{ __LINE__, HEXCONSTE(281474976710656.0, 0x402f, 0x80000000L, 0x00000000L), 281474976710656LL, NO_INEXACT_EXCEPTION|ROUND_TONEAREST },
	/* 0x10000000000000 */
	{ __LINE__, HEXCONSTE(4503599627370496.0, 0x4033, 0x80000000L, 0x00000000L), 4503599627370496LL, NO_INEXACT_EXCEPTION|ROUND_TONEAREST },
	/* 0x10000080000000 */
	{ __LINE__, HEXCONSTE(4503601774854144.0, 0x4033, 0x80000400L, 0x00000000L), 4503601774854144LL, ROUND_TONEAREST },
	/* 0x20000000000000 */
	{ __LINE__, HEXCONSTE(9007199254740992.0, 0x4034, 0x80000000L, 0x00000000L), 9007199254740992LL, NO_INEXACT_EXCEPTION|ROUND_TONEAREST },
	/* 0x80000000000000 */
	{ __LINE__, HEXCONSTE(36028797018963968.0, 0x4036, 0x80000000L, 0x00000000L), 36028797018963968LL, NO_INEXACT_EXCEPTION|ROUND_TONEAREST },
	/* 0x100000000000000 */
	{ __LINE__, HEXCONSTE(72057594037927936.0, 0x4037, 0x80000000L, 0x00000000L), 72057594037927936LL, NO_INEXACT_EXCEPTION|ROUND_TONEAREST },
#ifdef TEST_LDOUBLE
	/* The input can only be represented in long double.  */
	{ __LINE__, HEXCONSTE(4503599627370495.5L, 0x4032, 0xffffffffL, 0xfffff800L), 4503599627370496LL, ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(4503599627370496.25L, 0x4033, 0x80000000L, 0x00000200L), 4503599627370496LL, ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(4503599627370496.5L, 0x4033, 0x80000000L, 0x00000400L), 4503599627370496LL, ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(4503599627370496.75L, 0x4033, 0x80000000L, 0x00000600L), 4503599627370497LL, ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(4503599627370497.5L, 0x4033, 0x80000000L, 0x00000c00L), 4503599627370498LL, ROUND_TONEAREST },

	{ __LINE__, HEXCONSTE(-4503599627370495.5L, 0xc032, 0xffffffffL, 0xfffff800L), -4503599627370496LL, ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(-4503599627370496.25L, 0xc033, 0x80000000L, 0x00000200L), -4503599627370496LL, ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(-4503599627370496.5L, 0xc033, 0x80000000L, 0x00000400L), -4503599627370496LL, ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(-4503599627370496.75L, 0xc033, 0x80000000L, 0x00000600L), -4503599627370497LL, ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(-4503599627370497.5L, 0xc033, 0x80000000L, 0x00000c00L), -4503599627370498LL, ROUND_TONEAREST },

	{ __LINE__, HEXCONSTE(9007199254740991.5L, 0x4033, 0xffffffffL, 0xfffffc00L), 9007199254740992LL, ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(9007199254740992.25L, 0x4034, 0x80000000L, 0x00000100L), 9007199254740992LL, ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(9007199254740992.5L, 0x4034, 0x80000000L, 0x00000200L), 9007199254740992LL, ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(9007199254740992.75L, 0x4034, 0x80000000L, 0x00000300L), 9007199254740993LL, ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(9007199254740993.5L, 0x4034, 0x80000000L, 0x00000600L), 9007199254740994LL, ROUND_TONEAREST },

	{ __LINE__, HEXCONSTE(-9007199254740991.5L, 0xc033, 0xffffffffL, 0xfffffc00L), -9007199254740992LL, ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(-9007199254740992.25L, 0xc034, 0x80000000L, 0x00000100L), -9007199254740992LL, ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(-9007199254740992.5L, 0xc034, 0x80000000L, 0x00000200L), -9007199254740992LL, ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(-9007199254740992.75L, 0xc034, 0x80000000L, 0x00000300L), -9007199254740993LL, ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(-9007199254740993.5L, 0xc034, 0x80000000L, 0x00000600L), -9007199254740994LL, ROUND_TONEAREST },

	{ __LINE__, HEXCONSTE(72057594037927935.5L, 0x4036, 0xffffffffL, 0xffffff80L), 72057594037927936LL, ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(72057594037927936.25L, 0x4037, 0x80000000L, 0x00000020L), 72057594037927936LL, ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(72057594037927936.5L, 0x4037, 0x80000000L, 0x00000040L), 72057594037927936LL, ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(72057594037927936.75L, 0x4037, 0x80000000L, 0x00000060L), 72057594037927937LL, ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(72057594037927937.5L, 0x4037, 0x80000000L, 0x000000c0L), 72057594037927938LL, ROUND_TONEAREST },

	{ __LINE__, HEXCONSTE(-72057594037927935.5L, 0xc036, 0xffffffffL, 0xffffff80L), -72057594037927936LL, ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(-72057594037927936.25L, 0xc037, 0x80000000L, 0x00000020L), -72057594037927936LL, ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(-72057594037927936.5L, 0xc037, 0x80000000L, 0x00000040L), -72057594037927936LL, ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(-72057594037927936.75L, 0xc037, 0x80000000L, 0x00000060L), -72057594037927937LL, ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(-72057594037927937.5L, 0xc037, 0x80000000L, 0x000000c0L), -72057594037927938LL, ROUND_TONEAREST },
#endif

	{ __LINE__, ZERO_P, 0, NO_INEXACT_EXCEPTION|ROUND_TOWARDZERO },
	{ __LINE__, ZERO_M, 0, NO_INEXACT_EXCEPTION|ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(0.2L, 0x3ffc, 0xccccccccL, 0xcccccccdL), 0, INEXACT_EXCEPTION|ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-0.2L, 0xbffc, 0xccccccccL, 0xcccccccdL), 0, INEXACT_EXCEPTION|ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(0.5L, 0x3ffe, 0x80000000L, 0x00000000L), 0, INEXACT_EXCEPTION|ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-0.5L, 0xbffe, 0x80000000L, 0x00000000L), 0, INEXACT_EXCEPTION|ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(0.8L, 0x3ffe, 0xccccccccL, 0xcccccccdL), 0, INEXACT_EXCEPTION|ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-0.8L, 0xbffe, 0xccccccccL, 0xcccccccdL), 0, INEXACT_EXCEPTION|ROUND_TOWARDZERO },

	{ __LINE__, HEXCONSTE(1.4L, 0x3fff, 0xb3333333L, 0x33333333L), 1, INEXACT_EXCEPTION|ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-1.4L, 0xbfff, 0xb3333333L, 0x33333333L), -1, INEXACT_EXCEPTION|ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(1.5L, 0x3fff, 0xc0000000L, 0x00000000L), 1, INEXACT_EXCEPTION|ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-1.5L, 0xbfff, 0xc0000000L, 0x00000000L), -1, INEXACT_EXCEPTION|ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(1.8L, 0x3fff, 0xe6666666L, 0x66666666L), 1, INEXACT_EXCEPTION|ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-1.8L, 0xbfff, 0xe6666666L, 0x66666666L), -1, INEXACT_EXCEPTION|ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(3.0L, 0x4000, 0xc0000000L, 0x00000000L), 3, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-3.0L, 0xc000, 0xc0000000L, 0x00000000L), -3, ROUND_TOWARDZERO },

	{ __LINE__, HEXCONSTE(8388600.3L, 0x4015, 0xfffff099L, 0x9999999aL), 8388600LL, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-8388600.3L, 0xc015, 0xfffff099L, 0x9999999aL), -8388600LL, ROUND_TOWARDZERO },

#ifndef TEST_FLOAT
	{ __LINE__, HEXCONSTE(1071930.0008, 0x4013, 0x82d9d001L, 0xa36e2eb2L), 1071930LL, ROUND_TOWARDZERO },
#endif

	/* Test boundary conditions.  */
	/* 0x1FFFFF */
	{ __LINE__, HEXCONSTE(2097151.0, 0x4013, 0xfffff800L, 0x00000000L),2097151LL, ROUND_TOWARDZERO },
	/* 0x800000 */
	{ __LINE__, HEXCONSTE(8388608.0, 0x4016, 0x80000000L, 0x00000000L), 8388608LL, NO_INEXACT_EXCEPTION|ROUND_TOWARDZERO },
	/* 0x1000000 */
	{ __LINE__, HEXCONSTE(16777216.0, 0x4017, 0x80000000L, 0x00000000L), 16777216LL, NO_INEXACT_EXCEPTION|ROUND_TOWARDZERO },
	/* 0x80000000 */
	{ __LINE__, HEXCONSTE(2147483648.0, 0x401e, 0x80000000L, 0x00000000L), 2147483648LL, NO_INEXACT_EXCEPTION|ROUND_TOWARDZERO },
#ifndef TEST_FLOAT
	{ __LINE__, HEXCONSTE(2147483648.2, 0x401e, 0x80000000L, 0x33333333L), 2147483648LL, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(2147483648.5, 0x401e, 0x80000000L, 0x80000000L), 2147483648LL, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(2147483648.7, 0x401e, 0x80000000L, 0xb3333333L), 2147483648LL, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-2147483648.2, 0xc01e, 0x80000000L, 0x33333333L), -2147483648LL, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-2147483648.5, 0xc01e, 0x80000000L, 0x80000000L), -2147483648LL, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-2147483648.7, 0xc01e, 0x80000000L, 0xb3333333L), -2147483648LL, ROUND_TOWARDZERO },
#endif
	/* 0x20000000000 */
	{ __LINE__, HEXCONSTE(2199023255552.0, 0x4028, 0x80000000L, 0x00000000L), 2199023255552LL, NO_INEXACT_EXCEPTION|ROUND_TOWARDZERO },
	/* 0x40000000000 */
	{ __LINE__, HEXCONSTE(4398046511104.0, 0x4029, 0x80000000L, 0x00000000L), 4398046511104LL, NO_INEXACT_EXCEPTION|ROUND_TOWARDZERO },
	/* 0x1000000000000 */
	{ __LINE__, HEXCONSTE(281474976710656.0, 0x402f, 0x80000000L, 0x00000000L), 281474976710656LL, NO_INEXACT_EXCEPTION|ROUND_TOWARDZERO },
	/* 0x10000000000000 */
	{ __LINE__, HEXCONSTE(4503599627370496.0, 0x4033, 0x80000000L, 0x00000000L), 4503599627370496LL, NO_INEXACT_EXCEPTION|ROUND_TOWARDZERO },
	/* 0x10000080000000 */
	{ __LINE__, HEXCONSTE(4503601774854144.0, 0x4033, 0x80000400L, 0x00000000L), 4503601774854144LL, ROUND_TOWARDZERO },
	/* 0x20000000000000 */
	{ __LINE__, HEXCONSTE(9007199254740992.0, 0x4034, 0x80000000L, 0x00000000L), 9007199254740992LL, NO_INEXACT_EXCEPTION|ROUND_TOWARDZERO },
	/* 0x80000000000000 */
	{ __LINE__, HEXCONSTE(36028797018963968.0, 0x4036, 0x80000000L, 0x00000000L), 36028797018963968LL, NO_INEXACT_EXCEPTION|ROUND_TOWARDZERO },
	/* 0x100000000000000 */
	{ __LINE__, HEXCONSTE(72057594037927936.0, 0x4037, 0x80000000L, 0x00000000L), 72057594037927936LL, NO_INEXACT_EXCEPTION|ROUND_TOWARDZERO },
#ifdef TEST_LDOUBLE
	/* The input can only be represented in long double.  */
	{ __LINE__, HEXCONSTE(4503599627370495.5L, 0x4032, 0xffffffffL, 0xfffff800L), 4503599627370495LL, ROUND_TOWARDZEROL },
	{ __LINE__, HEXCONSTE(4503599627370496.25L, 0x4033, 0x80000000L, 0x00000200L), 4503599627370496LL, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(4503599627370496.5L, 0x4033, 0x80000000L, 0x00000400L), 4503599627370496LL, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(4503599627370496.75L, 0x4033, 0x80000000L, 0x00000600L), 4503599627370496LL, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(4503599627370497.5L, 0x4033, 0x80000000L, 0x00000c00L), 4503599627370497LL, ROUND_TOWARDZERO },

	{ __LINE__, HEXCONSTE(-4503599627370495.5L, 0xc032, 0xffffffffL, 0xfffff800L), -4503599627370495LL, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-4503599627370496.25L, 0xc033, 0x80000000L, 0x00000200L), -4503599627370496LL, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-4503599627370496.5L, 0xc033, 0x80000000L, 0x00000400L), -4503599627370496LL, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-4503599627370496.75L, 0xc033, 0x80000000L, 0x00000600L), -4503599627370496LL, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-4503599627370497.5L, 0xc033, 0x80000000L, 0x00000c00L), -4503599627370497LL, ROUND_TOWARDZERO },

	{ __LINE__, HEXCONSTE(9007199254740991.5L, 0x4033, 0xffffffffL, 0xfffffc00L), 9007199254740991LL, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(9007199254740992.25L, 0x4034, 0x80000000L, 0x00000100L), 9007199254740992LL, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(9007199254740992.5L, 0x4034, 0x80000000L, 0x00000200L), 9007199254740992LL, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(9007199254740992.75L, 0x4034, 0x80000000L, 0x00000300L), 9007199254740992LL, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(9007199254740993.5L, 0x4034, 0x80000000L, 0x00000600L), 9007199254740993LL, ROUND_TOWARDZERO },

	{ __LINE__, HEXCONSTE(-9007199254740991.5L, 0xc033, 0xffffffffL, 0xfffffc00L), -9007199254740991LL, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-9007199254740992.25L, 0xc034, 0x80000000L, 0x00000100L), -9007199254740992LL, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-9007199254740992.5L, 0xc034, 0x80000000L, 0x00000200L), -9007199254740992LL, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-9007199254740992.75L, 0xc034, 0x80000000L, 0x00000300L), -9007199254740992LL, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-9007199254740993.5L, 0xc034, 0x80000000L, 0x00000600L), -9007199254740993LL, ROUND_TOWARDZERO },

	{ __LINE__, HEXCONSTE(72057594037927935.5L, 0x4036, 0xffffffffL, 0xffffff80L), 72057594037927935LL, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(72057594037927936.25L, 0x4037, 0x80000000L, 0x00000020L), 72057594037927936LL, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(72057594037927936.5L, 0x4037, 0x80000000L, 0x00000040L), 72057594037927936LL, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(72057594037927936.75L, 0x4037, 0x80000000L, 0x00000060L), 72057594037927936LL, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(72057594037927937.5L, 0x4037, 0x80000000L, 0x000000c0L), 72057594037927937LL, ROUND_TOWARDZERO },

	{ __LINE__, HEXCONSTE(-72057594037927935.5L, 0xc036, 0xffffffffL, 0xffffff80L), -72057594037927935LL, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-72057594037927936.25L, 0xc037, 0x80000000L, 0x00000020L), -72057594037927936LL, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-72057594037927936.5L, 0xc037, 0x80000000L, 0x00000040L), -72057594037927936LL, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-72057594037927936.75L, 0xc037, 0x80000000L, 0x00000060L), -72057594037927936LL, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-72057594037927937.5L, 0xc037, 0x80000000L, 0x000000c0L), -72057594037927937LL, ROUND_TOWARDZERO },
#endif

	{ __LINE__, ZERO_P, 0, NO_INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, ZERO_M, 0, NO_INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(0.2L, 0x3ffc, 0xccccccccL, 0xcccccccdL), 0, INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-0.2L, 0xbffc, 0xccccccccL, 0xcccccccdL), -1, INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-0.2L, 0xbffc, 0xccccccccL, 0xcccccccdL), -1, INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(0.5L, 0x3ffe, 0x80000000L, 0x00000000L), 0, INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-0.5L, 0xbffe, 0x80000000L, 0x00000000L), -1, INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(0.8L, 0x3ffe, 0xccccccccL, 0xcccccccdL), 0, INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-0.8L, 0xbffe, 0xccccccccL, 0xcccccccdL), -1, INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(3.0L, 0x4000, 0xc0000000L, 0x00000000L), 3, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-3.0L, 0xc000, 0xc0000000L, 0x00000000L), -3, ROUND_DOWNWARD },

	{ __LINE__, HEXCONSTE(1.4L, 0x3fff, 0xb3333333L, 0x33333333L), 1, INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-1.4L, 0xbfff, 0xb3333333L, 0x33333333L), -2, INEXACT_EXCEPTION|ROUND_DOWNWARD },

	{ __LINE__, HEXCONSTE(8388600.3L, 0x4015, 0xfffff099L, 0x9999999aL), 8388600LL, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-8388600.3L, 0xc015, 0xfffff099L, 0x9999999aL), -8388601LL, ROUND_DOWNWARD },

#ifndef TEST_FLOAT
	{ __LINE__, HEXCONSTE(1071930.0008, 0x4013, 0x82d9d001L, 0xa36e2eb2L), 1071930LL, ROUND_DOWNWARD },
#endif

	/* Test boundary conditions.  */
	/* 0x1FFFFF */
	{ __LINE__, HEXCONSTE(2097151.0, 0x4013, 0xfffff800L, 0x00000000L),2097151LL, ROUND_DOWNWARD },
	/* 0x800000 */
	{ __LINE__, HEXCONSTE(8388608.0, 0x4016, 0x80000000L, 0x00000000L), 8388608LL, NO_INEXACT_EXCEPTION|ROUND_DOWNWARD },
	/* 0x1000000 */
	{ __LINE__, HEXCONSTE(16777216.0, 0x4017, 0x80000000L, 0x00000000L), 16777216LL, NO_INEXACT_EXCEPTION|ROUND_DOWNWARD },
	/* 0x80000000 */
	{ __LINE__, HEXCONSTE(2147483648.0, 0x401e, 0x80000000L, 0x00000000L), 2147483648LL, NO_INEXACT_EXCEPTION|ROUND_DOWNWARD },
#ifndef TEST_FLOAT
	{ __LINE__, HEXCONSTE(2147483648.2, 0x401e, 0x80000000L, 0x33333333L), 2147483648LL, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(2147483648.5, 0x401e, 0x80000000L, 0x80000000L), 2147483648LL, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(2147483648.7, 0x401e, 0x80000000L, 0xb3333333L), 2147483648LL, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-2147483648.2, 0xc01e, 0x80000000L, 0x33333333L), -2147483649LL, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-2147483648.5, 0xc01e, 0x80000000L, 0x80000000L), -2147483649LL, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-2147483648.7, 0xc01e, 0x80000000L, 0xb3333333L), -2147483649LL, ROUND_DOWNWARD },
#endif
	/* 0x20000000000 */
	{ __LINE__, HEXCONSTE(2199023255552.0, 0x4028, 0x80000000L, 0x00000000L), 2199023255552LL, NO_INEXACT_EXCEPTION|ROUND_DOWNWARD },
	/* 0x40000000000 */
	{ __LINE__, HEXCONSTE(4398046511104.0, 0x4029, 0x80000000L, 0x00000000L), 4398046511104LL, NO_INEXACT_EXCEPTION|ROUND_DOWNWARD },
	/* 0x1000000000000 */
	{ __LINE__, HEXCONSTE(281474976710656.0, 0x402f, 0x80000000L, 0x00000000L), 281474976710656LL, NO_INEXACT_EXCEPTION|ROUND_DOWNWARD },
	/* 0x10000000000000 */
	{ __LINE__, HEXCONSTE(4503599627370496.0, 0x4033, 0x80000000L, 0x00000000L), 4503599627370496LL, NO_INEXACT_EXCEPTION|ROUND_DOWNWARD },
	/* 0x10000080000000 */
	{ __LINE__, HEXCONSTE(4503601774854144.0, 0x4033, 0x80000400L, 0x00000000L), 4503601774854144LL, ROUND_DOWNWARD },
	/* 0x20000000000000 */
	{ __LINE__, HEXCONSTE(9007199254740992.0, 0x4034, 0x80000000L, 0x00000000L), 9007199254740992LL, NO_INEXACT_EXCEPTION|ROUND_DOWNWARD },
	/* 0x80000000000000 */
	{ __LINE__, HEXCONSTE(36028797018963968.0, 0x4036, 0x80000000L, 0x00000000L), 36028797018963968LL, NO_INEXACT_EXCEPTION|ROUND_DOWNWARD },
	/* 0x100000000000000 */
	{ __LINE__, HEXCONSTE(72057594037927936.0, 0x4037, 0x80000000L, 0x00000000L), 72057594037927936LL, NO_INEXACT_EXCEPTION|ROUND_DOWNWARD },
#ifdef TEST_LDOUBLE
	/* The input can only be represented in long double.  */
	{ __LINE__, HEXCONSTE(4503599627370495.5L, 0x4032, 0xffffffffL, 0xfffff800L), 4503599627370495LL, ROUND_DOWNWARDL },
	{ __LINE__, HEXCONSTE(4503599627370496.25L, 0x4033, 0x80000000L, 0x00000200L), 4503599627370496LL, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(4503599627370496.5L, 0x4033, 0x80000000L, 0x00000400L), 4503599627370496LL, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(4503599627370496.75L, 0x4033, 0x80000000L, 0x00000600L), 4503599627370496LL, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(4503599627370497.5L, 0x4033, 0x80000000L, 0x00000c00L), 4503599627370497LL, ROUND_DOWNWARD },

	{ __LINE__, HEXCONSTE(4503599627370495.4999999999999L, 0x4032, 0xffffffffL, 0xfffff800L), 4503599627370495LL, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(4503599627370496.4999999999999L, 0x4033, 0x80000000L, 0x00000400L), 4503599627370496LL, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(4503599627370497.4999999999999L, 0x4033, 0x80000000L, 0x00000c00L), 4503599627370497LL, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(4503599627370494.5000000000001L, 0x4032, 0xffffffffL, 0xffffe800L), 4503599627370494LL, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(4503599627370495.5000000000001L, 0x4032, 0xffffffffL, 0xfffff800L), 4503599627370495LL, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(4503599627370496.5000000000001L, 0x4033, 0x80000000L, 0x00000400L), 4503599627370496LL, ROUND_DOWNWARD },

	{ __LINE__, HEXCONSTE(-4503599627370495.5L, 0xc032, 0xffffffffL, 0xfffff800L), -4503599627370496LL, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-4503599627370496.25L, 0xc033, 0x80000000L, 0x00000200L), -4503599627370497LL, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-4503599627370496.5L, 0xc033, 0x80000000L, 0x00000400L), -4503599627370497LL, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-4503599627370496.75L, 0xc033, 0x80000000L, 0x00000600L), -4503599627370497LL, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-4503599627370497.5L, 0xc033, 0x80000000L, 0x00000c00L), -4503599627370498LL, ROUND_DOWNWARD },

	{ __LINE__, HEXCONSTE(-4503599627370495.4999999999999L, 0xc032, 0xffffffffL, 0xfffff800L), -4503599627370496LL, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-4503599627370496.4999999999999L, 0xc033, 0x80000000L, 0x00000400L), -4503599627370497LL, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-4503599627370497.4999999999999L, 0xc033, 0x80000000L, 0x00000c00L), -4503599627370498LL, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-4503599627370494.5000000000001L, 0xc032, 0xffffffffL, 0xffffe800L), -4503599627370495LL, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-4503599627370495.5000000000001L, 0xc032, 0xffffffffL, 0xfffff800L), -4503599627370496LL, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-4503599627370496.5000000000001L, 0xc033, 0x80000000L, 0x00000400L), -4503599627370497LL, ROUND_DOWNWARD },

	{ __LINE__, HEXCONSTE(9007199254740991.5L, 0x4033, 0xffffffffL, 0xfffffc00L), 9007199254740991LL, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(9007199254740992.25L, 0x4034, 0x80000000L, 0x00000100L), 9007199254740992LL, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(9007199254740992.5L, 0x4034, 0x80000000L, 0x00000200L), 9007199254740992LL, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(9007199254740992.75L, 0x4034, 0x80000000L, 0x00000300L), 9007199254740992LL, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(9007199254740993.5L, 0x4034, 0x80000000L, 0x00000600L), 9007199254740993LL, ROUND_DOWNWARD },

	{ __LINE__, HEXCONSTE(9007199254740991.4999999999999L, 0x4033, 0xffffffffL, 0xfffffc00L), 9007199254740991LL, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(9007199254740992.4999999999999L, 0x4034, 0x80000000L, 0x00000200L), 9007199254740992LL, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(9007199254740993.4999999999999L, 0x4034, 0x80000000L, 0x00000600L), 9007199254740993LL, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(9007199254740991.5000000000001L, 0x4033, 0xffffffffL, 0xfffffc00L), 9007199254740991LL, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(9007199254740992.5000000000001L, 0x4034, 0x80000000L, 0x00000200L), 9007199254740992LL, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(9007199254740993.5000000000001L, 0x4034, 0x80000000L, 0x00000600L), 9007199254740993LL, ROUND_DOWNWARD },

	{ __LINE__, HEXCONSTE(-9007199254740991.5L, 0xc033, 0xffffffffL, 0xfffffc00L), -9007199254740992LL, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-9007199254740992.25L, 0xc034, 0x80000000L, 0x00000100L), -9007199254740993LL, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-9007199254740992.5L, 0xc034, 0x80000000L, 0x00000200L), -9007199254740993LL, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-9007199254740992.75L, 0xc034, 0x80000000L, 0x00000300L), -9007199254740993LL, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-9007199254740993.5L, 0xc034, 0x80000000L, 0x00000600L), -9007199254740994LL, ROUND_DOWNWARD },

	{ __LINE__, HEXCONSTE(-9007199254740991.4999999999999L, 0xc033, 0xffffffffL, 0xfffffc00L), -9007199254740992LL, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-9007199254740992.4999999999999L, 0xc034, 0x80000000L, 0x00000200L), -9007199254740993LL, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-9007199254740993.4999999999999L, 0xc034, 0x80000000L, 0x00000600L), -9007199254740994LL, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-9007199254740991.5000000000001L, 0xc033, 0xffffffffL, 0xfffffc00L), -9007199254740992LL, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-9007199254740992.5000000000001L, 0xc034, 0x80000000L, 0x00000200L), -9007199254740993LL, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-9007199254740993.5000000000001L, 0xc034, 0x80000000L, 0x00000600L), -9007199254740994LL, ROUND_DOWNWARD },

	{ __LINE__, HEXCONSTE(72057594037927935.5L, 0x4036, 0xffffffffL, 0xffffff80L), 72057594037927935LL, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(72057594037927936.25L, 0x4037, 0x80000000L, 0x00000020L), 72057594037927936LL, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(72057594037927936.5L, 0x4037, 0x80000000L, 0x00000040L), 72057594037927936LL, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(72057594037927936.75L, 0x4037, 0x80000000L, 0x00000060L), 72057594037927936LL, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(72057594037927937.5L, 0x4037, 0x80000000L, 0x000000c0L), 72057594037927937LL, ROUND_DOWNWARD },

	{ __LINE__, HEXCONSTE(-72057594037927935.5L, 0xc036, 0xffffffffL, 0xffffff80L), -72057594037927936LL, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-72057594037927936.25L, 0xc037, 0x80000000L, 0x00000020L), -72057594037927937LL, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-72057594037927936.5L, 0xc037, 0x80000000L, 0x00000040L), -72057594037927937LL, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-72057594037927936.75L, 0xc037, 0x80000000L, 0x00000060L), -72057594037927937LL, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-72057594037927937.5L, 0xc037, 0x80000000L, 0x000000c0L), -72057594037927938LL, ROUND_DOWNWARD },
#endif

	{ __LINE__, ZERO_P, 0, NO_INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, ZERO_M, 0, NO_INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(0.2L, 0x3ffc, 0xccccccccL, 0xcccccccdL), 1, INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-0.2L, 0xbffc, 0xccccccccL, 0xcccccccdL), 0, INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(0.5L, 0x3ffe, 0x80000000L, 0x00000000L), 1, INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-0.5L, 0xbffe, 0x80000000L, 0x00000000L), 0, INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(0.8L, 0x3ffe, 0xccccccccL, 0xcccccccdL), 1, INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-0.8L, 0xbffe, 0xccccccccL, 0xcccccccdL), 0, INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(3.0L, 0x4000, 0xc0000000L, 0x00000000L), 3, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-3.0L, 0xc000, 0xc0000000L, 0x00000000L), -3, ROUND_UPWARD },

	{ __LINE__, HEXCONSTE(1.4L, 0x3fff, 0xb3333333L, 0x33333333L), 2, INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-1.4L, 0xbfff, 0xb3333333L, 0x33333333L), -1, INEXACT_EXCEPTION|ROUND_UPWARD },

	{ __LINE__, HEXCONSTE(8388600.3L, 0x4015, 0xfffff099L, 0x9999999aL), 8388601LL, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-8388600.3L, 0xc015, 0xfffff099L, 0x9999999aL), -8388600LL, ROUND_UPWARD },
#ifndef TEST_FLOAT
	{ __LINE__, HEXCONSTE(1071930.0008, 0x4013, 0x82d9d001L, 0xa36e2eb2L), 1071931LL, ROUND_UPWARD },
#endif
	/* Test boundary conditions.  */
	/* 0x1FFFFF */
	{ __LINE__, HEXCONSTE(2097151.0, 0x4013, 0xfffff800L, 0x00000000L),2097151LL, ROUND_UPWARD },
	/* 0x800000 */
	{ __LINE__, HEXCONSTE(8388608.0, 0x4016, 0x80000000L, 0x00000000L), 8388608LL, NO_INEXACT_EXCEPTION|ROUND_UPWARD },
	/* 0x1000000 */
	{ __LINE__, HEXCONSTE(16777216.0, 0x4017, 0x80000000L, 0x00000000L), 16777216LL, NO_INEXACT_EXCEPTION|ROUND_UPWARD },
	/* 0x80000000 */
	{ __LINE__, HEXCONSTE(2147483648.0, 0x401e, 0x80000000L, 0x00000000L), 2147483648LL, NO_INEXACT_EXCEPTION|ROUND_UPWARD },
#ifndef TEST_FLOAT
	{ __LINE__, HEXCONSTE(2147483648.2, 0x401e, 0x80000000L, 0x33333333L), 2147483649LL, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(2147483648.5, 0x401e, 0x80000000L, 0x80000000L), 2147483649LL, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(2147483648.7, 0x401e, 0x80000000L, 0xb3333333L), 2147483649LL, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-2147483648.2, 0xc01e, 0x80000000L, 0x33333333L), -2147483648LL, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-2147483648.5, 0xc01e, 0x80000000L, 0x80000000L), -2147483648LL, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-2147483648.7, 0xc01e, 0x80000000L, 0xb3333333L), -2147483648LL, ROUND_UPWARD },
#endif
	/* 0x20000000000 */
	{ __LINE__, HEXCONSTE(2199023255552.0, 0x4028, 0x80000000L, 0x00000000L), 2199023255552LL, NO_INEXACT_EXCEPTION|ROUND_UPWARD },
	/* 0x40000000000 */
	{ __LINE__, HEXCONSTE(4398046511104.0, 0x4029, 0x80000000L, 0x00000000L), 4398046511104LL, NO_INEXACT_EXCEPTION|ROUND_UPWARD },
	/* 0x1000000000000 */
	{ __LINE__, HEXCONSTE(281474976710656.0, 0x402f, 0x80000000L, 0x00000000L), 281474976710656LL, NO_INEXACT_EXCEPTION|ROUND_UPWARD },
	/* 0x10000000000000 */
	{ __LINE__, HEXCONSTE(4503599627370496.0, 0x4033, 0x80000000L, 0x00000000L), 4503599627370496LL, NO_INEXACT_EXCEPTION|ROUND_UPWARD },
	/* 0x10000080000000 */
	{ __LINE__, HEXCONSTE(4503601774854144.0, 0x4033, 0x80000400L, 0x00000000L), 4503601774854144LL, ROUND_UPWARD },
	/* 0x20000000000000 */
	{ __LINE__, HEXCONSTE(9007199254740992.0, 0x4034, 0x80000000L, 0x00000000L), 9007199254740992LL, NO_INEXACT_EXCEPTION|ROUND_UPWARD },
	/* 0x80000000000000 */
	{ __LINE__, HEXCONSTE(36028797018963968.0, 0x4036, 0x80000000L, 0x00000000L), 36028797018963968LL, NO_INEXACT_EXCEPTION|ROUND_UPWARD },
	/* 0x100000000000000 */
	{ __LINE__, HEXCONSTE(72057594037927936.0, 0x4037, 0x80000000L, 0x00000000L), 72057594037927936LL, NO_INEXACT_EXCEPTION|ROUND_UPWARD },
#ifdef TEST_LDOUBLE
	/* The input can only be represented in long double.  */
	{ __LINE__, HEXCONSTE(4503599627370495.5L, 0x4032, 0xffffffffL, 0xfffff800L), 4503599627370496LL, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(4503599627370496.25L, 0x4033, 0x80000000L, 0x00000200L), 4503599627370497LL, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(4503599627370496.5L, 0x4033, 0x80000000L, 0x00000400L), 4503599627370497LL, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(4503599627370496.75L, 0x4033, 0x80000000L, 0x00000600L), 4503599627370497LL, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(4503599627370497.5L, 0x4033, 0x80000000L, 0x00000c00L), 4503599627370498LL, ROUND_UPWARD },

	{ __LINE__, HEXCONSTE(4503599627370495.4999999999999L, 0x4032, 0xffffffffL, 0xfffff800L), 4503599627370496LL, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(4503599627370496.4999999999999L, 0x4033, 0x80000000L, 0x00000400L), 4503599627370497LL, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(4503599627370497.4999999999999L, 0x4033, 0x80000000L, 0x00000c00L), 4503599627370498LL, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(4503599627370494.5000000000001L, 0x4032, 0xffffffffL, 0xffffe800L), 4503599627370495LL, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(4503599627370495.5000000000001L, 0x4032, 0xffffffffL, 0xfffff800L), 4503599627370496LL, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(4503599627370496.5000000000001L, 0x4033, 0x80000000L, 0x00000400L), 4503599627370497LL, ROUND_UPWARD },

	{ __LINE__, HEXCONSTE(-4503599627370495.5L, 0xc032, 0xffffffffL, 0xfffff800L), -4503599627370495LL, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-4503599627370496.25L, 0xc033, 0x80000000L, 0x00000200L), -4503599627370496LL, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-4503599627370496.5L, 0xc033, 0x80000000L, 0x00000400L), -4503599627370496LL, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-4503599627370496.75L, 0xc033, 0x80000000L, 0x00000600L), -4503599627370496LL, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-4503599627370497.5L, 0xc033, 0x80000000L, 0x00000c00L), -4503599627370497LL, ROUND_UPWARD },

	{ __LINE__, HEXCONSTE(-4503599627370495.4999999999999L, 0xc032, 0xffffffffL, 0xfffff800L), -4503599627370495LL, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-4503599627370496.4999999999999L, 0xc033, 0x80000000L, 0x00000400L), -4503599627370496LL, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-4503599627370497.4999999999999L, 0xc033, 0x80000000L, 0x00000c00L), -4503599627370497LL, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-4503599627370494.5000000000001L, 0xc032, 0xffffffffL, 0xffffe800L), -4503599627370494LL, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-4503599627370495.5000000000001L, 0xc032, 0xffffffffL, 0xfffff800L), -4503599627370495LL, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-4503599627370496.5000000000001L, 0xc033, 0x80000000L, 0x00000400L), -4503599627370496LL, ROUND_UPWARD },

	{ __LINE__, HEXCONSTE(9007199254740991.5L, 0x4033, 0xffffffffL, 0xfffffc00L), 9007199254740992LL, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(9007199254740992.25L, 0x4034, 0x80000000L, 0x00000100L), 9007199254740993LL, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(9007199254740992.5L, 0x4034, 0x80000000L, 0x00000200L), 9007199254740993LL, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(9007199254740992.75L, 0x4034, 0x80000000L, 0x00000300L), 9007199254740993LL, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(9007199254740993.5L, 0x4034, 0x80000000L, 0x00000600L), 9007199254740994LL, ROUND_UPWARD },

	{ __LINE__, HEXCONSTE(9007199254740991.4999999999999L, 0x4033, 0xffffffffL, 0xfffffc00L), 9007199254740992LL, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(9007199254740992.4999999999999L, 0x4034, 0x80000000L, 0x00000200L), 9007199254740993LL, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(9007199254740993.4999999999999L, 0x4034, 0x80000000L, 0x00000600L), 9007199254740994LL, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(9007199254740991.5000000000001L, 0x4033, 0xffffffffL, 0xfffffc00L), 9007199254740992LL, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(9007199254740992.5000000000001L, 0x4034, 0x80000000L, 0x00000200L), 9007199254740993LL, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(9007199254740993.5000000000001L, 0x4034, 0x80000000L, 0x00000600L), 9007199254740994LL, ROUND_UPWARD },

	{ __LINE__, HEXCONSTE(-9007199254740991.5L, 0xc033, 0xffffffffL, 0xfffffc00L), -9007199254740991LL, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-9007199254740992.25L, 0xc034, 0x80000000L, 0x00000100L), -9007199254740992LL, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-9007199254740992.5L, 0xc034, 0x80000000L, 0x00000200L), -9007199254740992LL, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-9007199254740992.75L, 0xc034, 0x80000000L, 0x00000300L), -9007199254740992LL, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-9007199254740993.5L, 0xc034, 0x80000000L, 0x00000600L), -9007199254740993LL, ROUND_UPWARD },

	{ __LINE__, HEXCONSTE(-9007199254740991.4999999999999L, 0xc033, 0xffffffffL, 0xfffffc00L), -9007199254740991LL, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-9007199254740992.4999999999999L, 0xc034, 0x80000000L, 0x00000200L), -9007199254740992LL, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-9007199254740993.4999999999999L, 0xc034, 0x80000000L, 0x00000600L), -9007199254740993LL, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-9007199254740991.5000000000001L, 0xc033, 0xffffffffL, 0xfffffc00L), -9007199254740991LL, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-9007199254740992.5000000000001L, 0xc034, 0x80000000L, 0x00000200L), -9007199254740992LL, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-9007199254740993.5000000000001L, 0xc034, 0x80000000L, 0x00000600L), -9007199254740993LL, ROUND_UPWARD },

	{ __LINE__, HEXCONSTE(72057594037927935.5L, 0x4036, 0xffffffffL, 0xffffff80L), 72057594037927936LL, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(72057594037927936.25L, 0x4037, 0x80000000L, 0x00000020L), 72057594037927937LL, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(72057594037927936.5L, 0x4037, 0x80000000L, 0x00000040L), 72057594037927937LL, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(72057594037927936.75L, 0x4037, 0x80000000L, 0x00000060L), 72057594037927937LL, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(72057594037927937.5L, 0x4037, 0x80000000L, 0x000000c0L), 72057594037927938LL, ROUND_UPWARD },

	{ __LINE__, HEXCONSTE(-72057594037927935.5L, 0xc036, 0xffffffffL, 0xffffff80L), -72057594037927935LL, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-72057594037927936.25L, 0xc037, 0x80000000L, 0x00000020L), -72057594037927936LL, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-72057594037927936.5L, 0xc037, 0x80000000L, 0x00000040L), -72057594037927936LL, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-72057594037927936.75L, 0xc037, 0x80000000L, 0x00000060L), -72057594037927936LL, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-72057594037927937.5L, 0xc037, 0x80000000L, 0x000000c0L), -72057594037927937LL, ROUND_UPWARD },
#endif
#endif
};


int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_f_ll(llrint_data, ARRAY_SIZE(llrint_data), __FILE__);
	(void)check_fp;

	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

#else

int main(void)
{
	return 77;
}

#endif

```

`tests/llround.c`:

```c
#include "testconfig.h"
#if defined(HAVE_LLROUND)
#define TEST_FUNC_F_LL __MATH_PRECNAME(llround)
#include "testdriver.h"



static test_f_ll_data const llround_data[] = {
	{ __LINE__, QNAN_P, LONG_LONG_MIN, FLAG_FAIL_SOFTFLOAT|FLAG_FAIL_HARDFLOAT },
	{ __LINE__, QNAN_M, LONG_LONG_MIN, FLAG_FAIL_SOFTFLOAT|FLAG_FAIL_HARDFLOAT },
	{ __LINE__, SNAN_P, LONG_LONG_MIN, FLAG_FAIL_SOFTFLOAT|FLAG_FAIL_HARDFLOAT },
	{ __LINE__, SNAN_M, LONG_LONG_MIN, FLAG_FAIL_SOFTFLOAT|FLAG_FAIL_HARDFLOAT },
	{ __LINE__, INF_P, LONG_LONG_MIN, FLAG_FAIL_SOFTFLOAT|FLAG_XFAIL },
	{ __LINE__, INF_M, LONG_LONG_MIN, FLAG_FAIL_SOFTFLOAT|FLAG_XFAIL },
	{ __LINE__, ZERO_P, 0, 0 },
	{ __LINE__, ZERO_M, 0, 0 },
	{ __LINE__, SUBNORM_P, 0, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, 0, FLAG_SUBNORM },
	{ __LINE__, MIN_P, 0, 0 },
	{ __LINE__, MIN_M, 0, 0 },
	{ __LINE__, MAX_P, LONG_LONG_MIN, 0 },
	{ __LINE__, MAX_M, LONG_LONG_MIN, 0 },

	{ __LINE__, HEXCONSTE(0.2L, 0x3ffc, 0xccccccccL, 0xcccccccdL), 0, 0 },
	{ __LINE__, HEXCONSTE(-0.2L, 0xbffc, 0xccccccccL, 0xcccccccdL), 0, 0 },
	{ __LINE__, HEXCONSTE(0.5, 0x3ffe, 0x80000000L, 0x00000000L), 1, 0 },
	{ __LINE__, HEXCONSTE(-0.5, 0xbffe, 0x80000000L, 0x00000000L), -1, 0 },
	{ __LINE__, HEXCONSTE(0.8L, 0x3ffe, 0xccccccccL, 0xcccccccdL), 1, 0 },
	{ __LINE__, HEXCONSTE(-0.8L, 0xbffe, 0xccccccccL, 0xcccccccdL), -1, 0 },
	{ __LINE__, HEXCONSTE(1.5, 0x3fff, 0xc0000000L, 0x00000000L), 2, 0 },
	{ __LINE__, HEXCONSTE(-1.5, 0xbfff, 0xc0000000L, 0x00000000L), -2, 0 },
	{ __LINE__, HEXCONSTE(22514.5, 0x400d, 0xafe50000L, 0x00000000L), 22515LL, 0 },
	{ __LINE__, HEXCONSTE(-22514.5, 0xc00d, 0xafe50000L, 0x00000000L), -22515LL, 0 },
	{ __LINE__, HEXCONSTE(1071930.0008, 0x4013, 0x82d9d001L, 0xa36e2eb2L), 1071930LL, 0 },
#ifndef TEST_FLOAT
	{ __LINE__, HEXCONSTE(2097152.5, 0x4014, 0x80000200L, 0x00000000L), 2097153LL, 0 },
	{ __LINE__, HEXCONSTE(-2097152.5, 0xc014, 0x80000200L, 0x00000000L), -2097153LL, 0 },
	{ __LINE__, HEXCONSTE(34359738368.5, 0x4022, 0x80000000L, 0x08000000L), 34359738369ll, 0 },
	{ __LINE__, HEXCONSTE(-34359738368.5, 0xc022, 0x80000000L, 0x08000000L), -34359738369ll, 0 },
	{ __LINE__, HEXCONSTE(-3.65309740835E17, 0xc039, 0xa23ae8c2L, 0xeeb9d800L), -365309740835000000LL, 0 },
#endif

	/* Test boundary conditions.  */
	/* 0x1FFFFF */
	{ __LINE__, HEXCONSTE(2097151.0, 0x4013, 0xfffff800L, 0x00000000L), 2097151LL, 0 },
	/* 0x800000 */
	{ __LINE__, HEXCONSTE(8388608.0, 0x4016, 0x80000000L, 0x00000000L), 8388608LL, 0 },
	/* 0x1000000 */
	{ __LINE__, HEXCONSTE(16777216.0, 0x4017, 0x80000000L, 0x00000000L), 16777216LL, 0 },
	/* 0x20000000000 */
	{ __LINE__, HEXCONSTE(2199023255552.0, 0x4028, 0x80000000L, 0x00000000L), 2199023255552LL, 0 },
	/* 0x40000000000 */
	{ __LINE__, HEXCONSTE(4398046511104.0, 0x4029, 0x80000000L, 0x00000000L), 4398046511104LL, 0 },
	/* 0x1000000000000 */
	{ __LINE__, HEXCONSTE(281474976710656.0, 0x402f, 0x80000000L, 0x00000000L), 281474976710656LL, 0 },
	/* 0x10000000000000 */
	{ __LINE__, HEXCONSTE(4503599627370496.0, 0x4033, 0x80000000L, 0x00000000L), 4503599627370496LL, 0 },
	/* 0x10000080000000 */
	{ __LINE__, HEXCONSTE(4503601774854144.0, 0x4033, 0x80000400L, 0x00000000L), 4503601774854144LL, 0 },
	/* 0x20000000000000 */
	{ __LINE__, HEXCONSTE(9007199254740992.0, 0x4034, 0x80000000L, 0x00000000L), 9007199254740992LL, 0 },
	/* 0x80000000000000 */
	{ __LINE__, HEXCONSTE(36028797018963968.0, 0x4036, 0x80000000L, 0x00000000L), 36028797018963968LL, 0 },
	/* 0x100000000000000 */
	{ __LINE__, HEXCONSTE(72057594037927936.0, 0x4037, 0x80000000L, 0x00000000L), 72057594037927936LL, 0 },

#ifndef TEST_FLOAT
	/* 0x100000000 */
	{ __LINE__, HEXCONSTE(4294967295.5, 0x401e, 0xffffffffL, 0x80000000L), 4294967296LL, 0 },
	/* 0x200000000 */
	{ __LINE__, HEXCONSTE(8589934591.5, 0x401f, 0xffffffffL, 0xc0000000L), 8589934592LL, 0 },

	/* nextafter(0.5,-1)  */
	{ __LINE__, HEXCONSTE(4.99999999999999944489e-01, 0x3ffd, 0xffffffffL, 0xfffff800L), 0, 0 },
	/* nextafter(-0.5,1)  */
	{ __LINE__, HEXCONSTE(-4.99999999999999944489e-01, 0xbffd, 0xffffffffL, 0xfffff800L), 0, 0 },
	/* On PowerPC an exponent of '52' is the largest incrementally
	 * representable sequence of whole-numbers in the 'double' range.  We test
	 * lround to make sure that a guard bit set during the lround operation
	 * hasn't forced an erroneous shift giving us an incorrect result.	The odd
	 * numbers between +-(2^52+1 and 2^53-1) are affected since they have the
	 * rightmost bit set.  */
	/* +-(2^52+1)  */
	{ __LINE__, HEXCONSTE(4.50359962737049700000e+15, 0x4033, 0x80000000L, 0x00000800L), 4503599627370497LL, 0 },
	{ __LINE__, HEXCONSTE(-4.50359962737049700000e+15, 0xc033, 0x80000000L, 0x00000800L), -4503599627370497LL, 0 },
	/* +-(2^53-1): Input is the last (positive and negative) incrementally
	 * representable whole-number in the 'double' range that might round
	 * erroneously.  */
	{ __LINE__, HEXCONSTE(9.00719925474099100000e+15, 0x4033, 0xffffffffL, 0xfffff800L), 9007199254740991LL, 0 },
	{ __LINE__, HEXCONSTE(-9.00719925474099100000e+15, 0xc033, 0xffffffffL, 0xfffff800L), -9007199254740991LL, 0 },
#else
	/* nextafter(0.5,-1)  */
	{ __LINE__, HEXCONSTE(4.99999970197677612305e-01, 0x3ffd, 0xffffff00L, 0x00000000L), 0, 0 },
	/* nextafter(-0.5,1)  */
	{ __LINE__, HEXCONSTE(-4.99999970197677612305e-01, 0xbffd, 0xffffff00L, 0x00000000L), 0, 0 },
	/* As above, on PowerPC an exponent of '23' is the largest incrementally
	 * representable sequence of whole-numbers in the 'float' range.
	 * Likewise, numbers between +-(2^23+1 and 2^24-1) are affected.  */
	{ __LINE__, HEXCONSTE(8.38860900000000000000e+06, 0x4016, 0x80000100L, 0x00000000L), 8388609LL, 0 },
	{ __LINE__, HEXCONSTE(-8.38860900000000000000e+06, 0xc016, 0x80000100L, 0x00000000L), -8388609LL, 0 },
	{ __LINE__, HEXCONSTE(1.67772150000000000000e+07, 0x4016, 0xffffff00L, 0x00000000L), 16777215LL, 0 },
	{ __LINE__, HEXCONSTE(-1.67772150000000000000e+07, 0xc016, 0xffffff00L, 0x00000000L), -16777215LL, 0 },
#endif


#ifdef TEST_LDOUBLE
	/* The input can only be represented in long double.  */
	{ __LINE__, HEXCONSTE(4503599627370495.5L, 0x4032, 0xffffffffL, 0xfffff800L), 4503599627370496LL, 0 },
	{ __LINE__, HEXCONSTE(4503599627370496.25L, 0x4033, 0x80000000L, 0x00000200L), 4503599627370496LL, 0 },
	{ __LINE__, HEXCONSTE(4503599627370496.5L, 0x4033, 0x80000000L, 0x00000400L), 4503599627370497LL, 0 },
	{ __LINE__, HEXCONSTE(4503599627370496.75L, 0x4033, 0x80000000L, 0x00000600L), 4503599627370497LL, 0 },
	{ __LINE__, HEXCONSTE(4503599627370497.5L, 0x4033, 0x80000000L, 0x00000c00L), 4503599627370498LL, 0 },

# if LDBL_MANT_DIG > 100
	{ __LINE__, HEXCONSTE(4503599627370495.4999999999999L, 0x4032, 0xffffffffL, 0xfffff800L), 4503599627370495LL, 0 },
	{ __LINE__, HEXCONSTE(4503599627370496.4999999999999L, 0x4033, 0x80000000L, 0x00000400L), 4503599627370496LL, 0 },
	{ __LINE__, HEXCONSTE(4503599627370497.4999999999999L, 0x4033, 0x80000000L, 0x00000c00L), 4503599627370497LL, 0 },
	{ __LINE__, HEXCONSTE(4503599627370494.5000000000001L, 0x4032, 0xffffffffL, 0xffffe800L), 4503599627370495LL, 0 },
	{ __LINE__, HEXCONSTE(4503599627370495.5000000000001L, 0x4032, 0xffffffffL, 0xfffff800L), 4503599627370496LL, 0 },
	{ __LINE__, HEXCONSTE(4503599627370496.5000000000001L, 0x4033, 0x80000000L, 0x00000400L), 4503599627370497LL, 0 },

	{ __LINE__, HEXCONSTE(-4503599627370495.4999999999999L, 0xc032, 0xffffffffL, 0xfffff800L), -4503599627370495LL, 0 },
	{ __LINE__, HEXCONSTE(-4503599627370496.4999999999999L, 0xc033, 0x80000000L, 0x00000400L), -4503599627370496LL, 0 },
	{ __LINE__, HEXCONSTE(-4503599627370497.4999999999999L, 0xc033, 0x80000000L, 0x00000c00L), -4503599627370497LL, 0 },
	{ __LINE__, HEXCONSTE(-4503599627370494.5000000000001L, 0xc032, 0xffffffffL, 0xffffe800L), -4503599627370495LL, 0 },
	{ __LINE__, HEXCONSTE(-4503599627370495.5000000000001L, 0xc032, 0xffffffffL, 0xfffff800L), -4503599627370496LL, 0 },
	{ __LINE__, HEXCONSTE(-4503599627370496.5000000000001L, 0xc033, 0x80000000L, 0x00000400L), -4503599627370497LL, 0 },
# endif

	{ __LINE__, HEXCONSTE(-4503599627370495.5L, 0xc032, 0xffffffffL, 0xfffff800L), -4503599627370496LL, 0 },
	{ __LINE__, HEXCONSTE(-4503599627370496.25L, 0xc033, 0x80000000L, 0x00000200L), -4503599627370496LL, 0 },
	{ __LINE__, HEXCONSTE(-4503599627370496.5L, 0xc033, 0x80000000L, 0x00000400L), -4503599627370497LL, 0 },
	{ __LINE__, HEXCONSTE(-4503599627370496.75L, 0xc033, 0x80000000L, 0x00000600L), -4503599627370497LL, 0 },
	{ __LINE__, HEXCONSTE(-4503599627370497.5L, 0xc033, 0x80000000L, 0x00000c00L), -4503599627370498LL, 0 },

	{ __LINE__, HEXCONSTE(9007199254740991.5L, 0x4033, 0xffffffffL, 0xfffffc00L), 9007199254740992LL, 0 },
	{ __LINE__, HEXCONSTE(9007199254740992.25L, 0x4034, 0x80000000L, 0x00000100L), 9007199254740992LL, 0 },
	{ __LINE__, HEXCONSTE(9007199254740992.5L, 0x4034, 0x80000000L, 0x00000200L), 9007199254740993LL, 0 },
	{ __LINE__, HEXCONSTE(9007199254740992.75L, 0x4034, 0x80000000L, 0x00000300L), 9007199254740993LL, 0 },
	{ __LINE__, HEXCONSTE(9007199254740993.5L, 0x4034, 0x80000000L, 0x00000600L), 9007199254740994LL, 0 },

# if LDBL_MANT_DIG > 100
	{ __LINE__, HEXCONSTE(9007199254740991.4999999999999L, 0x4033, 0xffffffffL, 0xfffffc00L), 9007199254740991LL, 0 },
	{ __LINE__, HEXCONSTE(9007199254740992.4999999999999L, 0x4034, 0x80000000L, 0x00000200L), 9007199254740992LL, 0 },
	{ __LINE__, HEXCONSTE(9007199254740993.4999999999999L, 0x4034, 0x80000000L, 0x00000600L), 9007199254740993LL, 0 },
	{ __LINE__, HEXCONSTE(9007199254740991.5000000000001L, 0x4033, 0xffffffffL, 0xfffffc00L), 9007199254740992LL, 0 },
	{ __LINE__, HEXCONSTE(9007199254740992.5000000000001L, 0x4034, 0x80000000L, 0x00000200L), 9007199254740993LL, 0 },
	{ __LINE__, HEXCONSTE(9007199254740993.5000000000001L, 0x4034, 0x80000000L, 0x00000600L), 9007199254740994LL, 0 },

	{ __LINE__, HEXCONSTE(-9007199254740991.4999999999999L, 0xc033, 0xffffffffL, 0xfffffc00L), -9007199254740991LL, 0 },
	{ __LINE__, HEXCONSTE(-9007199254740992.4999999999999L, 0xc034, 0x80000000L, 0x00000200L), -9007199254740992LL, 0 },
	{ __LINE__, HEXCONSTE(-9007199254740993.4999999999999L, 0xc034, 0x80000000L, 0x00000600L), -9007199254740993LL, 0 },
	{ __LINE__, HEXCONSTE(-9007199254740991.5000000000001L, 0xc033, 0xffffffffL, 0xfffffc00L), -9007199254740992LL, 0 },
	{ __LINE__, HEXCONSTE(-9007199254740992.5000000000001L, 0xc034, 0x80000000L, 0x00000200L), -9007199254740993LL, 0 },
	{ __LINE__, HEXCONSTE(-9007199254740993.5000000000001L, 0xc034, 0x80000000L, 0x00000600L), -9007199254740994LL, 0 },
# endif

	{ __LINE__, HEXCONSTE(-9007199254740991.5L, 0xc033, 0xffffffffL, 0xfffffc00L), -9007199254740992LL, 0 },
	{ __LINE__, HEXCONSTE(-9007199254740992.25L, 0xc034, 0x80000000L, 0x00000100L), -9007199254740992LL, 0 },
	{ __LINE__, HEXCONSTE(-9007199254740992.5L, 0xc034, 0x80000000L, 0x00000200L), -9007199254740993LL, 0 },
	{ __LINE__, HEXCONSTE(-9007199254740992.75L, 0xc034, 0x80000000L, 0x00000300L), -9007199254740993LL, 0 },
	{ __LINE__, HEXCONSTE(-9007199254740993.5L, 0xc034, 0x80000000L, 0x00000600L), -9007199254740994LL, 0 },

	{ __LINE__, HEXCONSTE(72057594037927935.5L, 0x4036, 0xffffffffL, 0xffffff80L), 72057594037927936LL, 0 },
	{ __LINE__, HEXCONSTE(72057594037927936.25L, 0x4037, 0x80000000L, 0x00000020L), 72057594037927936LL, 0 },
	{ __LINE__, HEXCONSTE(72057594037927936.5L, 0x4037, 0x80000000L, 0x00000040L), 72057594037927937LL, 0 },
	{ __LINE__, HEXCONSTE(72057594037927936.75L, 0x4037, 0x80000000L, 0x00000060L), 72057594037927937LL, 0 },
	{ __LINE__, HEXCONSTE(72057594037927937.5L, 0x4037, 0x80000000L, 0x000000c0L), 72057594037927938LL, 0 },

	{ __LINE__, HEXCONSTE(-72057594037927935.5L, 0xc036, 0xffffffffL, 0xffffff80L), -72057594037927936LL, 0 },
	{ __LINE__, HEXCONSTE(-72057594037927936.25L, 0xc037, 0x80000000L, 0x00000020L), -72057594037927936LL, 0 },
	{ __LINE__, HEXCONSTE(-72057594037927936.5L, 0xc037, 0x80000000L, 0x00000040L), -72057594037927937LL, 0 },
	{ __LINE__, HEXCONSTE(-72057594037927936.75L, 0xc037, 0x80000000L, 0x00000060L), -72057594037927937LL, 0 },
	{ __LINE__, HEXCONSTE(-72057594037927937.5L, 0xc037, 0x80000000L, 0x000000c0L), -72057594037927938LL, 0 },

	{ __LINE__, HEXCONSTE(9223372036854775806.25L, 0x403d, 0xffffffffL, 0xfffffffcL), 9223372036854775806LL, 0 },
	{ __LINE__, HEXCONSTE(-9223372036854775806.25L, 0xc03d, 0xffffffffL, 0xfffffffcL), -9223372036854775806LL, 0 },
	{ __LINE__, HEXCONSTE(9223372036854775806.5L, 0x403d, 0xffffffffL, 0xfffffffdL), 9223372036854775807LL, 0 },
	{ __LINE__, HEXCONSTE(-9223372036854775806.5L, 0xc03d, 0xffffffffL, 0xfffffffdL), -9223372036854775807LL, 0 },
	{ __LINE__, HEXCONSTE(9223372036854775807.0L, 0x403d, 0xffffffffL, 0xfffffffeL), 9223372036854775807LL, 0 },
	{ __LINE__, HEXCONSTE(-9223372036854775807.0L, 0xc03d, 0xffffffffL, 0xfffffffeL), -9223372036854775807LL, 0 },
#endif
};


int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_f_ll(llround_data, ARRAY_SIZE(llround_data), __FILE__);
	(void)check_fp;

	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

#else

int main(void)
{
	return 77;
}

#endif

```

`tests/log.c`:

```c
#include "testconfig.h"
#define TEST_FUNC_F_F __MATH_PRECNAME(log)
#include "testdriver.h"



static test_f_f_data const flogn_data[] = {
	{ __LINE__, ZERO_P, INF_M, 0 },
	{ __LINE__, ZERO_M, INF_M, 0 },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__, MIN_M, QNAN_P, FLAG_MINVAL },
	{ __LINE__, MAX_M, QNAN_P, 0 },
#if __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, SUBNORM_P, HEXCONSTE(-1.13994985314888605581e+04, 0xc00c, 0xb21dfe7fL, 0x09e2baa9L), FLAG_SUBNORM|FLAG_INEXACT },
#else
	{ __LINE__, SUBNORM_P, HEXCONSTE(-1.13994985314888605590e+04, 0xc00c, 0xb21dfe7fL, 0x09e2baaaL), FLAG_SUBNORM|FLAG_INEXACT },
#endif
	{ __LINE__, SUBNORM_M, QNAN_P, FLAG_SUBNORM },
	{ __LINE__, INF_P, INF_P, FLAG_FAIL_ARANYM },
	{ __LINE__, INF_M, QNAN_P, 0 },
	{ __LINE__, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_P, 0 },
	{ __LINE__, SNAN_P, QNAN_P, 0 },
	{ __LINE__, SNAN_M, QNAN_P, 0 },

	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.71828198432922363281e+00, 0x4000, 0xadf85500L, 0x00000000L), HEXCONSTE(1.00000005734143248008e+00, 0x3fff, 0x8000007bL, 0x23c92f9aL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.71828174591064453125e+00, 0x4000, 0xadf85400L, 0x00000000L), HEXCONSTE(9.99999969632140018282e-01, 0x3ffe, 0xffffff7dL, 0x922f51a3L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.71828182845904553488e+00, 0x4000, 0xadf85458L, 0xa2bb5000L), HEXCONSTE(1.00000000000000011015e+00, 0x3fff, 0x80000000L, 0x000003f8L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.71828182845904509080e+00, 0x4000, 0xadf85458L, 0xa2bb4800L), HEXCONSTE(9.99999999999999946820e-01, 0x3ffe, 0xffffffffL, 0xfffffc2bL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.71828182845904523543e+00, 0x4000, 0xadf85458L, 0xa2bb4a9bL), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.71828182845904523521e+00, 0x4000, 0xadf85458L, 0xa2bb4a9aL), HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(3.67879450321197509766e-01, 0x3ffd, 0xbc5ab200L, 0x00000000L), HEXCONSTE(-9.99999975128387046423e-01, 0xbffe, 0xffffff95L, 0x2d5f52b9L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(3.67879420518875122070e-01, 0x3ffd, 0xbc5ab100L, 0x00000000L), HEXCONSTE(-1.00000005613949970531e+00, 0xbfff, 0x80000078L, 0x8f042fa1L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(3.67879441171442334024e-01, 0x3ffd, 0xbc5ab1b1L, 0x6779c000L), HEXCONSTE(-9.99999999999999966227e-01, 0xbffe, 0xffffffffL, 0xfffffd91L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(3.67879441171442278513e-01, 0x3ffd, 0xbc5ab1b1L, 0x6779b800L), HEXCONSTE(-1.00000000000000011709e+00, 0xbfff, 0x80000000L, 0x00000438L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(3.67879441171442321610e-01, 0x3ffd, 0xbc5ab1b1L, 0x6779be36L), HEXCONSTE(-9.99999999999999999946e-01, 0xbffe, 0xffffffffL, 0xffffffffL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(3.67879441171442321583e-01, 0x3ffd, 0xbc5ab1b1L, 0x6779be35L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(6.93147180559945309429e-01, 0x3ffe, 0xb17217f7L, 0xd1cf79acL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+01, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(2.30258509299404568404e+00, 0x4000, 0x935d8dddL, 0xaaa8ac17L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(7.50000000000000000000e-01, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(-2.87682072451780927443e-01, 0xbffd, 0x934b1089L, 0xa6dc93c2L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(1.19209282445354457085e-07, 0x3fe7, 0xffffff00L, 0x00015555L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(1.19209282445354457085e-07, 0x3fe7, 0xffffff00L, 0x00015555L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(2.22044604925031283433e-16, 0x3fca, 0xffffffffL, 0xfffff800L), 0 },
	{ __LINE__, HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(1.19209282445354457085e-07, 0x3fe7, 0xffffff00L, 0x00015555L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(2.22044604925031283433e-16, 0x3fca, 0xffffffffL, 0xfffff800L), FLAG_INEXACT },
#if defined(TEST_LDOUBLE) && LDBL_MAX_EXP > 1024
	{ __LINE__, HEXCONSTE(1.00000000000000000011e+00, 0x3fff, 0x80000000L, 0x00000001L), HEXCONSTE(1.08420217248550443395e-19, 0x3fbf, 0xffffffffL, 0xffffffffL), FLAG_INEXACT },
#endif
	{ __LINE__, HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(1.19209282445354457085e-07, 0x3fe7, 0xffffff00L, 0x00015555L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(2.22044604925031283433e-16, 0x3fca, 0xffffffffL, 0xfffff800L), 0 },
#if defined(TEST_LDOUBLE) && LDBL_MAX_EXP > 1024
	{ __LINE__, HEXCONSTE(1.00000000000000000011e+00, 0x3fff, 0x80000000L, 0x00000001L), HEXCONSTE(1.08420217248550443395e-19, 0x3fbf, 0xffffffffL, 0xffffffffL), FLAG_INEXACT },
#endif
	{ __LINE__, HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(1.19209282445354457085e-07, 0x3fe7, 0xffffff00L, 0x00015555L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(2.22044604925031283433e-16, 0x3fca, 0xffffffffL, 0xfffff800L), 0 },
#if defined(TEST_LDOUBLE) && LDBL_MAX_EXP > 1024
	{ __LINE__, HEXCONSTE(1.00000000000000000011e+00, 0x3fff, 0x80000000L, 0x00000001L), HEXCONSTE(1.08420217248550443395e-19, 0x3fbf, 0xffffffffL, 0xffffffffL), FLAG_INEXACT },
#endif
	{ __LINE__, HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-5.96046465517475349885e-08, 0xbfe7, 0x80000040L, 0x00002aabL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-5.96046465517475349885e-08, 0xbfe7, 0x80000040L, 0x00002aabL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.11022302462515660205e-16, 0xbfca, 0x80000000L, 0x00000200L), 0 },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-5.96046465517475349885e-08, 0xbfe7, 0x80000040L, 0x00002aabL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.11022302462515660205e-16, 0xbfca, 0x80000000L, 0x00000200L), 0 },
#if defined(TEST_LDOUBLE) && LDBL_MAX_EXP > 1024
	{ __LINE__, HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-5.42101086242752217004e-20, 0xbfbf, 0x80000000L, 0x00000000L), FLAG_INEXACT },
#endif
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-5.96046465517475349885e-08, 0xbfe7, 0x80000040L, 0x00002aabL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.11022302462515660205e-16, 0xbfca, 0x80000000L, 0x00000200L), 0 },
#if defined(TEST_LDOUBLE) && LDBL_MAX_EXP > 1024
	{ __LINE__, HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-5.42101086242752217004e-20, 0xbfbf, 0x80000000L, 0x00000000L), FLAG_INEXACT },
#endif
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-5.96046465517475349885e-08, 0xbfe7, 0x80000040L, 0x00002aabL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.11022302462515660205e-16, 0xbfca, 0x80000000L, 0x00000200L), 0 },
#if defined(TEST_LDOUBLE) && LDBL_MAX_EXP > 1024
	{ __LINE__, HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-5.42101086242752217004e-20, 0xbfbf, 0x80000000L, 0x00000000L), FLAG_INEXACT },
#endif
	{ __LINE__, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(-8.73365447505531089858e+01, 0xc005, 0xaeac4f97L, 0xf2883bc5L), 0 },
	{ __LINE__, HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(-7.08396418532264106227e+02, 0xc008, 0xb1195eebL, 0xd5e691efL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(-1.13551371119330240589e+04, 0xc00c, 0xb16c8c67L, 0x1210eb30L), 0 },
#if defined(TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.13565234062941439497e+04, 0xc00c, 0xb17217f7L, 0xd1cf79acL), FLAG_SUBNORM|FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(-1.13988053843083006136e+04, 0xc00c, 0xb21dfe7fL, 0x09e2baaaL), FLAG_SUBNORM|FLAG_INEXACT },
#endif
#if defined(TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16381)
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.13558302591135840043e+04, 0xc00c, 0xb16f522fL, 0x71f0326eL), FLAG_SUBNORM|FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(-1.13988053843083006136e+04, 0xc00c, 0xb21b38b6L, 0xaa03736cL), FLAG_SUBNORM|FLAG_INEXACT },
#endif
	{ __LINE__, HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(-6.71659617962587004836e+02, 0xc008, 0xa7ea372eL, 0x424a94e3L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.03278929903431851103e+02, 0xc005, 0xce8ecfe6L, 0x7a3b83a2L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(-7.44440071921381262332e+02, 0xc008, 0xba1c2a23L, 0x6b8e1b1dL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(8.87228390520683530551e+01, 0x4005, 0xb17217f5L, 0xd1cf78acL), 0 },
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(7.09782712893383996744e+02, 0x4008, 0xb17217f7L, 0xd1cf79aaL), 0 },
	{ __LINE__, HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.13565234062941439497e+04, 0x400c, 0xb17217f7L, 0xd1cf79acL), 0 },
	{ __LINE__, HEXCONSTE(6.90763413906097412109e-01, 0x3ffe, 0xb0d5df00L, 0x00000000L), HEXCONSTE(-3.69957896031518082254e-01, 0xbffd, 0xbd6b1f10L, 0xb465b128L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.42284202575683593750e+00, 0x3fff, 0xb61fb000L, 0x00000000L), HEXCONSTE(3.52656298016666307216e-01, 0x3ffd, 0xb48f5dc5L, 0x6b869f00L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(6.67580127716064453125e-01, 0x3ffe, 0xaae68800L, 0x00000000L), HEXCONSTE(-4.04095854389945499001e-01, 0xbffd, 0xcee5a6deL, 0x1ba5184eL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.76951415275520000000e+13, 0x402b, 0x80bfc500L, 0x00000000L), HEXCONSTE(3.05043112278602514056e+01, 0x4003, 0xf408d453L, 0x3552b4c4L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(7.17688586240000000000e+10, 0x4023, 0x85ae0f00L, 0x00000000L), HEXCONSTE(2.49967164950154518994e+01, 0x4003, 0xc7f9467fL, 0x6bcd0801L), 0 },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(8.87228390520683530551e+01, 0x4005, 0xb17217f5L, 0xd1cf78acL), 0 },
	{ __LINE__, HEXCONSTE(4.77814749966756723348e+279, 0x43a0, 0x86c5f0a2L, 0x1fa4e000L), HEXCONSTE(6.43985293864353479876e+02, 0x4008, 0xa0ff0f0dL, 0xff164000L), 0 },
	{ __LINE__, HEXCONSTE(1.57271742820739746094e+00, 0x3fff, 0xc94ece00L, 0x00000000L), HEXCONSTE(4.52804969164463860771e-01, 0x3ffd, 0xe7d60d8cL, 0x0e298bffL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(1.46485054492950439453e+00, 0x3fff, 0xbb803900L, 0x00000000L), HEXCONSTE(3.81753220151964734759e-01, 0x3ffd, 0xc3752877L, 0x640869b9L), FLAG_INEXACT3 },

	{ __LINE__, HEXCONSTE(4.999999999999999999e-02L, 0x3ffa, 0xccccccccL, 0xcccccccaL), HEXCONSTE(-2.995732273553990993e00L, 0xc000, 0xbfba13dbL, 0x9f1c8a80L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.500000000000000000e-01L, 0x3ffd, 0x80000000L, 0x00000000L), HEXCONSTE(-1.386294361119890618e00L, 0xbfff, 0xb17217f7L, 0xd1cf79a4L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(5.000000000000000000e-01L, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(-6.931471805599453094e-01L, 0xbffe, 0xb17217f7L, 0xd1cf79abL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.000000000000000000e00L, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.000000000000000000e00L, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.0L, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(0.69314718055994530941723212145817657L, 0x3ffe, 0xb17217f7L, 0xd1cf79acL), 0 },
	{ __LINE__, HEXCONSTE(4.0L, 0x4001, 0x80000000L, 0x00000000L), HEXCONSTE(1.38629436111989061883446424291635313L, 0x3fff, 0xb17217f7L, 0xd1cf79acL), 0 },
	{ __LINE__, HEXCONSTE(10.0L, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(2.30258509299404568401799145468436421L, 0x4000, 0x935d8dddL, 0xaaa8ac17L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.000000000000000000e01L, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(2.302585092994045684e00L, 0x4000, 0x935d8dddL, 0xaaa8ac17L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.000000000000000000e01L, 0x4003, 0xf0000000L, 0x00000000L), HEXCONSTE(3.401197381662155375e00L, 0x4000, 0xd9ad37c8L, 0x5eb4d673L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(5.000000000000000000e01L, 0x4004, 0xc8000000L, 0x00000000L), HEXCONSTE(3.912023005428146058e00L, 0x4000, 0xfa5e95bdL, 0x60dd79c0L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.000000000000000000e02L, 0x4006, 0xc8000000L, 0x00000000L), HEXCONSTE(5.298317366548036677e00L, 0x4001, 0xa98bd0dcL, 0xa4e29b4bL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.999999999999999999e32L, 0x406a, 0x9dc5ada8L, 0x2b70b598L), HEXCONSTE(7.437587015636940721e01L, 0x4005, 0x94c0720dL, 0x9a4c4b0cL), FLAG_INEXACT },

	{ __LINE__, HEXCONST_E, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(.3678794411714423215955237701, 0x3ffd, 0xbc5ab1b1L, 0x6779be35L), HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2L, 0x4000, 0x80000000L, 0x00000000L), HEXCONST_LN2, 0 },
#if defined(TEST_LDOUBLE) && LDBL_MAX_EXP > 1024
	{ __LINE__, HEXCONSTE(10L, 0x4002, 0xa0000000L, 0x00000000L), HEXCONST_LN10, 0 },
#endif
#if defined(TEST_DOUBLE)
	{ __LINE__, HEXCONSTE(10L, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(2.3025850929940459010936e+00, 0x4000, 0x935d8dddL, 0xaaa8b000L), 0 },
#endif
	{ __LINE__, HEXCONSTE(0.75L, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(-0.287682072451780927439219005993827432L, 0xbffd, 0x934b1089L, 0xa6dc93c2L), 0 },
};


int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_f_f(flogn_data, ARRAY_SIZE(flogn_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

```

`tests/log10.c`:

```c
#include "testconfig.h"
#define TEST_FUNC_F_F __MATH_PRECNAME(log10)
#include "testdriver.h"



static test_f_f_data const flog10_data[] = {
	{ __LINE__, ZERO_P, INF_M, 0 },
	{ __LINE__, ZERO_M, INF_M, 0 },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), QNAN_P, INVALID_EXCEPTION|ERRNO_EDOM },
	{ __LINE__, MIN_M, QNAN_P, FLAG_MINVAL },
	{ __LINE__, MAX_M, QNAN_P, 0 },
#if __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, SUBNORM_P, HEXCONSTE(-4.95073930868983473674e+03, 0xc00b, 0x9ab5ea1aL, 0xaca3e911L), FLAG_SUBNORM|FLAG_INEXACT },
#else
	{ __LINE__, SUBNORM_P, HEXCONSTE(-4.95043827869417075549e+03, 0xc00b, 0x9ab38198L, 0x428ff9d1L), FLAG_SUBNORM|FLAG_INEXACT },
#endif
	{ __LINE__, SUBNORM_M, QNAN_P, FLAG_SUBNORM },
	{ __LINE__, INF_P, INF_P, FLAG_FAIL_ARANYM },
	{ __LINE__, INF_M, QNAN_P, 0 },
	{ __LINE__, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_P, 0 },
	{ __LINE__, SNAN_P, QNAN_P, 0 },
	{ __LINE__, SNAN_M, QNAN_P, 0 },

	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.00000001490116119385e-01, 0x3ffb, 0xcccccd00L, 0x00000000L), HEXCONSTE(-9.99999993528507967802e-01, 0xbffe, 0xffffffe4L, 0x3484ee53L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.99999940395355224609e-02, 0x3ffb, 0xcccccc00L, 0x00000000L), HEXCONSTE(-1.00000002588596909319e+00, 0xbfff, 0x80000037L, 0x96f64619L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.00000000000000005551e-01, 0x3ffb, 0xccccccccL, 0xccccd000L), HEXCONSTE(-9.99999999999999975877e-01, 0xbffe, 0xffffffffL, 0xfffffe43L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.99999999999999916733e-02, 0x3ffb, 0xccccccccL, 0xccccc800L), HEXCONSTE(-1.00000000000000003621e+00, 0xbfff, 0x80000000L, 0x0000014eL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.00000000000000000001e-01, 0x3ffb, 0xccccccccL, 0xcccccccdL), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.99999999999999999946e-02, 0x3ffb, 0xccccccccL, 0xccccccccL), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+01, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+02, 0x4005, 0xc8000000L, 0x00000000L), HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+04, 0x400c, 0x9c400000L, 0x00000000L), HEXCONSTE(4.00000000000000000000e+00, 0x4001, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.71828198432922363281e+00, 0x4000, 0xadf85500L, 0x00000000L), HEXCONSTE(4.34294506806319538208e-01, 0x3ffd, 0xde5bd97fL, 0x2195405bL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.71828174591064453125e+00, 0x4000, 0xadf85400L, 0x00000000L), HEXCONSTE(4.34294468714657810383e-01, 0x3ffd, 0xde5bd837L, 0xed220e54L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.71828182845904553488e+00, 0x4000, 0xadf85458L, 0xa2bb5000L), HEXCONSTE(4.34294481903251875513e-01, 0x3ffd, 0xde5bd8a9L, 0x3728787bL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.71828182845904509080e+00, 0x4000, 0xadf85458L, 0xa2bb4800L), HEXCONSTE(4.34294481903251804552e-01, 0x3ffd, 0xde5bd8a9L, 0x37286e41L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.71828182845904523543e+00, 0x4000, 0xadf85458L, 0xa2bb4a9bL), HEXCONSTE(4.34294481903251827673e-01, 0x3ffd, 0xde5bd8a9L, 0x37287196L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.71828182845904523521e+00, 0x4000, 0xadf85458L, 0xa2bb4a9aL), HEXCONSTE(4.34294481903251827618e-01, 0x3ffd, 0xde5bd8a9L, 0x37287194L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(7.50000000000000000000e-01, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(-1.24938736608299953132e-01, 0xbffb, 0xffdfe15dL, 0xe3c01bacL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(5.17719335576636270452e-08, 0x3fe6, 0xde5bd7caL, 0xdb50f0d9L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(5.17719335576636270452e-08, 0x3fe6, 0xde5bd7caL, 0xdb50f0d9L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(9.64327466553287003638e-17, 0x3fc9, 0xde5bd8a9L, 0x37286aa2L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(5.17719335576636270452e-08, 0x3fe6, 0xde5bd7caL, 0xdb50f0d9L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(9.64327466553287003638e-17, 0x3fc9, 0xde5bd8a9L, 0x37286aa2L), FLAG_INEXACT },
#if defined(TEST_LDOUBLE) && LDBL_MAX_EXP > 1024
	{ __LINE__, HEXCONSTE(1.00000000000000000011e+00, 0x3fff, 0x80000000L, 0x00000001L), HEXCONSTE(4.70863020777972221996e-20, 0x3fbe, 0xde5bd8a9L, 0x37287194L), FLAG_INEXACT },
#endif
	{ __LINE__, HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(5.17719335576636270452e-08, 0x3fe6, 0xde5bd7caL, 0xdb50f0d9L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(9.64327466553287003638e-17, 0x3fc9, 0xde5bd8a9L, 0x37286aa2L), FLAG_INEXACT },
#if defined(TEST_LDOUBLE) && LDBL_MAX_EXP > 1024
	{ __LINE__, HEXCONSTE(1.00000000000000000011e+00, 0x3fff, 0x80000000L, 0x00000001L), HEXCONSTE(4.70863020777972221996e-20, 0x3fbe, 0xde5bd8a9L, 0x37287194L), FLAG_INEXACT },
#endif
	{ __LINE__, HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(5.17719335576636270452e-08, 0x3fe6, 0xde5bd7caL, 0xdb50f0d9L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(9.64327466553287003638e-17, 0x3fc9, 0xde5bd8a9L, 0x37286aa2L), FLAG_INEXACT },
#if defined(TEST_LDOUBLE) && LDBL_MAX_EXP > 1024
	{ __LINE__, HEXCONSTE(1.00000000000000000011e+00, 0x3fff, 0x80000000L, 0x00000001L), HEXCONSTE(4.70863020777972221996e-20, 0x3fbe, 0xde5bd8a9L, 0x37287194L), FLAG_INEXACT },
#endif
	{ __LINE__, HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-2.58859690932176412836e-08, 0xbfe5, 0xde5bd918L, 0x6515104fL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-2.58859690932176412836e-08, 0xbfe5, 0xde5bd918L, 0x6515104fL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-4.82163733276643582136e-17, 0xbfc8, 0xde5bd8a9L, 0x3728750fL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-2.58859690932176412836e-08, 0xbfe5, 0xde5bd918L, 0x6515104fL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-4.82163733276643582136e-17, 0xbfc8, 0xde5bd8a9L, 0x3728750fL), FLAG_INEXACT },
#if defined(TEST_LDOUBLE) && LDBL_MAX_EXP > 1024
	{ __LINE__, HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-2.35431510388986111027e-20, 0xbfbd, 0xde5bd8a9L, 0x37287196L), FLAG_INEXACT },
#endif
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-2.58859690932176412836e-08, 0xbfe5, 0xde5bd918L, 0x6515104fL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-4.82163733276643582136e-17, 0xbfc8, 0xde5bd8a9L, 0x3728750fL), FLAG_INEXACT },
#if defined(TEST_LDOUBLE) && LDBL_MAX_EXP > 1024
	{ __LINE__, HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-2.35431510388986111027e-20, 0xbfbd, 0xde5bd8a9L, 0x37287196L), FLAG_INEXACT },
#endif
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-2.58859690932176412836e-08, 0xbfe5, 0xde5bd918L, 0x6515104fL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-4.82163733276643582136e-17, 0xbfc8, 0xde5bd8a9L, 0x3728750fL), FLAG_INEXACT },
#if defined(TEST_LDOUBLE) && LDBL_MAX_EXP > 1024
	{ __LINE__, HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-2.35431510388986111027e-20, 0xbfbd, 0xde5bd8a9L, 0x37287196L), FLAG_INEXACT },
#endif
	{ __LINE__, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(-3.79297794536616305963e+01, 0xc004, 0x97b8181aL, 0xe7e0b7baL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(-3.07652655568588781515e+02, 0xc007, 0x99d38a37L, 0xb9520f9dL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(-4.93147338896733994007e+03, 0xc00b, 0x9a1bc980L, 0x27a81919L), FLAG_INEXACT },
#if defined(TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(-4.93207544895866790258e+03, 0xc00b, 0x9a209a84L, 0xfbcff799L), FLAG_SUBNORM|FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(-4.95073930868983473674e+03, 0xc00b, 0x9ab5ea1aL, 0xaca3e911L), FLAG_SUBNORM|FLAG_INEXACT },
#endif
#if defined(TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16381)
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(-4.93177441896300392132e+03, 0xc00b, 0x9a1e3202L, 0x91bc0859L), FLAG_SUBNORM|FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(-4.95043827869417075549e+03, 0xc00b, 0x9ab38198L, 0x428ff9d1L), FLAG_SUBNORM|FLAG_INEXACT },
#endif
	{ __LINE__, HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(-2.91698065798397778159e+02, 0xc007, 0x91d95a38L, 0x57498c0cL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(-4.48534693539331980883e+01, 0xc004, 0xb369f3deL, 0xcd201638L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(-3.23306215343115803673e+02, 0xc007, 0xa1a73210L, 0x7a1b9f30L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(3.85318394191036238949e+01, 0x4004, 0x9a209a83L, 0x3f184568L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(3.08254715559916743856e+02, 0x4007, 0x9a209a84L, 0xfbcff797L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(4.93207544895866790258e+03, 0x400b, 0x9a209a84L, 0xfbcff799L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(6.04841411113739013672e-01, 0x3ffe, 0x9ad6e300L, 0x00000000L), HEXCONSTE(-2.18358482052973862519e-01, 0xbffc, 0xdf995dacL, 0xe30c0e71L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(1.44292724132537841797e+00, 0x3fff, 0xb8b1d700L, 0x00000000L), HEXCONSTE(1.59244432626718630480e-01, 0x3ffc, 0xa310f8f8L, 0xcead051bL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(6.63342714309692382812e-01, 0x3ffe, 0xa9d0d400L, 0x00000000L), HEXCONSTE(-1.78262036484639944633e-01, 0xbffc, 0xb68a52c3L, 0x47908de9L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(1.14500081539154052734e+00, 0x3fff, 0x928f6300L, 0x00000000L), HEXCONSTE(5.88057959509465818891e-02, 0x3ffa, 0xf0de58a6L, 0xcb0472dcL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.00852215290069580078e+00, 0x3fff, 0x81174100L, 0x00000000L), HEXCONSTE(3.68544223828828325762e-03, 0x3ff6, 0xf18775e2L, 0x7ea99658L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(6.06310367584228515625e-01, 0x3ffe, 0x9b372800L, 0x00000000L), HEXCONSTE(-2.17305005497303086761e-01, 0xbffc, 0xde85340fL, 0x78d9710cL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(6.06310307979583740234e-01, 0x3ffe, 0x9b372700L, 0x00000000L), HEXCONSTE(-2.17305048191558336401e-01, 0xbffc, 0xde8536ecL, 0xf42b732bL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(6.06310361063795322245e-01, 0x3ffe, 0x9b3727e3L, 0xfeb53800L), HEXCONSTE(-2.17305010167828814390e-01, 0xbffc, 0xde85345fL, 0xb609ec59L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(9.84156727790832519531e-01, 0x3ffe, 0xfbf1b200L, 0x00000000L), HEXCONSTE(-6.93573429767623192709e-03, 0xbff7, 0xe34527fdL, 0xbadb933aL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(1.12458482646722559815e+29, 0x405f, 0xb5afbd00L, 0x00000000L), HEXCONSTE(2.90509922194668117612e+01, 0x4003, 0xe8686e9bL, 0xd7aeec00L), FLAG_INEXACT },

	{ __LINE__, HEXCONSTE(1.00e-10, 0x3fdd, 0xdbe6feceL, 0xbdedd5bfL), HEXCONSTE(-1.000000000000000000e01, 0xc002, 0xa0000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.00e-05, 0x3fee, 0xa7c5ac47L, 0x1b478423L), HEXCONSTE(-5.000000000000000000e00, 0xc001, 0xa0000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(5.00e-01, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(-3.010299956639811952e-01, 0xbffd, 0x9a209a84L, 0xfbcff798L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.00e00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.000000000000000000e00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.50e00, 0x3fff, 0xc0000000L, 0x00000000L), HEXCONSTE(1.760912590556812420e-01, 0x3ffc, 0xb451445bL, 0x05bfe155L), 0 },
	{ __LINE__, HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(0.30102999566398119521373889472449303, 0x3ffd, 0x9a209a84L, 0xfbcff799L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.71828182845904523536028747135266250, 0x4000, 0xadf85458L, 0xa2bb4a9bL), HEXCONSTE(0.43429448190325182765112891891660508, 0x3ffd, 0xde5bd8a9L, 0x37287195L), 0 },
	{ __LINE__, HEXCONSTE(1.00e05, 0x400f, 0xc3500000L, 0x00000000L), HEXCONSTE(5.000000000000000000e00, 0x4001, 0xa0000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.00e20, 0x4041, 0xad78ebc5L, 0xac620000L), HEXCONSTE(2.000000000000000000e01, 0x4003, 0xa0000000L, 0x00000000L), 0 },

	{ __LINE__, HEXCONSTE(0.1L, 0x3ffb, 0xccccccccL, 0xcccccccdL), HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(10.0, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(100.0, 0x4005, 0xc8000000L, 0x00000000L), HEXCONSTE(2, 0x4000, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(10000.0, 0x400c, 0x9c400000L, 0x00000000L), HEXCONSTE(4, 0x4001, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONST_E, HEXCONST_LOG10E, 0 },
#if defined(TEST_LDOUBLE) && LDBL_MAX_EXP > 1024
	{ __LINE__, HEXCONSTE(0.75L, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(-0.124938736608299953132449886193870744L, 0xbffb, 0xffdfe15dL, 0xe3c01bacL), 0 },
#endif
#if defined(TEST_DOUBLE)
	{ __LINE__, HEXCONSTE(0.75L, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(-1.2493873660829993288424e-01, 0xbffb, 0xffdfe15dL, 0xe3c01000L), FLAG_INEXACT },
#endif
};


int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_f_f(flog10_data, ARRAY_SIZE(flog10_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

```

`tests/log1p.c`:

```c
#include "testconfig.h"
#define TEST_FUNC_F_F __MATH_PRECNAME(log1p)
#include "testdriver.h"



static test_f_f_data const flognp1_data[] = {
	{ __LINE__, ZERO_P, ZERO_P, 0 },
	{ __LINE__, ZERO_M, ZERO_M, FLAG_FAIL_ARANYM }, /* hm, flognp1(-0.0) = flogn(1.0), that should just be +zero? does not make much sense... */
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), INF_M, 0 }, /* Documentation says NaN is returned, but is wrong */
	{ __LINE__, HEXCONSTE(-2.0, 0xc000, 0x80000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__, MIN_M, MIN_M, FLAG_MINVAL },
	{ __LINE__, MAX_M, QNAN_P, 0 },
	{ __LINE__, SUBNORM_P, SUBNORM_P, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, SUBNORM_M, FLAG_SUBNORM },
	{ __LINE__, INF_P, INF_P, FLAG_FAIL_ARANYM },
	{ __LINE__, INF_M, QNAN_P, 0 },
	{ __LINE__, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_P, 0 },
	{ __LINE__, SNAN_P, QNAN_P, 0 },
	{ __LINE__, SNAN_M, QNAN_P, 0 },

	{ __LINE__, HEXCONSTE(1.71828186511993408203e+00, 0x3fff, 0xdbf0a900L, 0x00000000L), HEXCONSTE(1.00000001348678721079e+00, 0x3fff, 0x8000001cL, 0xf6708edbL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.71828174591064453125e+00, 0x3fff, 0xdbf0a800L, 0x00000000L), HEXCONSTE(9.99999969632140018282e-01, 0x3ffe, 0xffffff7dL, 0x922f51a3L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.71828182845904531284e+00, 0x3fff, 0xdbf0a8b1L, 0x45769800L), HEXCONSTE(1.00000000000000002851e+00, 0x3fff, 0x80000000L, 0x00000107L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.71828182845904509080e+00, 0x3fff, 0xdbf0a8b1L, 0x45769000L), HEXCONSTE(9.99999999999999946820e-01, 0x3ffe, 0xffffffffL, 0xfffffc2bL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.71828182845904523532e+00, 0x3fff, 0xdbf0a8b1L, 0x45769535L), HEXCONSTE(9.99999999999999946820e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.71828182845904523543e+00, 0x3fff, 0xdbf0a8b1L, 0x45769536L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-2.50000000000000000000e-01, 0xbffd, 0x80000000L, 0x00000000L), HEXCONSTE(-2.87682072451780927443e-01, 0xbffd, 0x934b1089L, 0xa6dc93c2L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-8.75000000000000000000e-01, 0xbffe, 0xe0000000L, 0x00000000L), HEXCONSTE(-2.07944154167983592829e+00, 0xc000, 0x851591f9L, 0xdd5b9b41L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(3.12500000000000000000e-02, 0x3ffa, 0x80000000L, 0x00000000L), HEXCONSTE(3.07716586667536883714e-02, 0x3ff9, 0xfc14d873L, 0xc1980268L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(9.76562500000000000000e-04, 0x3ff5, 0x80000000L, 0x00000000L), HEXCONSTE(9.76085973055458895953e-04, 0x3ff4, 0xffe00554L, 0x55887de0L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(3.05175781250000000000e-05, 0x3ff0, 0x80000000L, 0x00000000L), HEXCONSTE(3.05171124731863785698e-05, 0x3fef, 0xffff0001L, 0x55535559L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(9.53674316406250000000e-07, 0x3feb, 0x80000000L, 0x00000000L), HEXCONSTE(9.53673861659188233891e-07, 0x3fea, 0xfffff800L, 0x00555551L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.98023223876953125000e-08, 0x3fe6, 0x80000000L, 0x00000000L), HEXCONSTE(2.98023219436061114727e-08, 0x3fe5, 0xffffffc0L, 0x00001555L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.31322574615478515625e-10, 0x3fe1, 0x80000000L, 0x00000000L), HEXCONSTE(9.31322574181797646883e-10, 0x3fe0, 0xfffffffeL, 0x00000005L), 0 },
	{ __LINE__, HEXCONSTE(2.91038304567337036133e-11, 0x3fdc, 0x80000000L, 0x00000000L), HEXCONSTE(2.91038304563101871397e-11, 0x3fdb, 0xffffffffL, 0xf0000000L), 0 },
	{ __LINE__, HEXCONSTE(9.09494701772928237915e-13, 0x3fd7, 0x80000000L, 0x00000000L), HEXCONSTE(9.09494701772514647609e-13, 0x3fd6, 0xffffffffL, 0xff800000L), 0 },
	{ __LINE__, HEXCONSTE(2.84217094304040074348e-14, 0x3fd2, 0x80000000L, 0x00000000L), HEXCONSTE(2.84217094304036035381e-14, 0x3fd1, 0xffffffffL, 0xfffc0000L), 0 },
	{ __LINE__, HEXCONSTE(8.88178419700125232339e-16, 0x3fcd, 0x80000000L, 0x00000000L), HEXCONSTE(8.88178419700124837908e-16, 0x3fcc, 0xffffffffL, 0xffffe000L), 0 },
	{ __LINE__, HEXCONSTE(2.77555756156289135106e-17, 0x3fc8, 0x80000000L, 0x00000000L), HEXCONSTE(2.77555756156289131254e-17, 0x3fc7, 0xffffffffL, 0xffffff00L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(8.67361737988403547206e-19, 0x3fc3, 0x80000000L, 0x00000000L), HEXCONSTE(8.67361737988403546830e-19, 0x3fc2, 0xffffffffL, 0xfffffff8L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(7.88860905221011805412e-31, 0x3f9b, 0x80000000L, 0x00000000L), HEXCONSTE(7.88860905221011805412e-31, 0x3f9b, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.40991986510288411774e-181, 0x3da7, 0x80000000L, 0x00000000L), HEXCONSTE(2.40991986510288411774e-181, 0x3da7, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(5.01237274920645200930e-3011, 0x18ef, 0x80000000L, 0x00000000L), HEXCONSTE(5.01237274920645200930e-3011, 0x18ef, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), 0 },
#ifdef TEST_LDOUBLE
	{ __LINE__, HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), 0 },
#ifdef TEST_LDOUBLE
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), 0 },
#endif
	{ __LINE__, HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), 0 },
#ifdef TEST_LDOUBLE
	{ __LINE__, HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), 0 },
#ifdef TEST_LDOUBLE
	{ __LINE__, HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), 0 },
#endif
	{ __LINE__, HEXCONSTE(1.02400000000000000000e+03, 0x4009, 0x80000000L, 0x00000000L), HEXCONSTE(6.93244789157250855321e+00, 0x4001, 0xddd69cf5L, 0xf0e6045bL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.04857600000000000000e+06, 0x4013, 0x80000000L, 0x00000000L), HEXCONSTE(1.38629445648727678475e+01, 0x4002, 0xddce9ef5L, 0xc63b5817L), 0 },
	{ __LINE__, HEXCONSTE(1.07374182400000000000e+09, 0x401d, 0x80000000L, 0x00000000L), HEXCONSTE(2.07944154177296818570e+01, 0x4003, 0xa65af678L, 0x74b28211L), 0 },
	{ __LINE__, HEXCONSTE(1.12589990684262400000e+15, 0x4031, 0x80000000L, 0x00000000L), HEXCONSTE(3.46573590279972663583e+01, 0x4004, 0x8aa122b9L, 0x9bea180eL), 0 },
	{ __LINE__, HEXCONSTE(1.15292150460684697600e+18, 0x403b, 0x80000000L, 0x00000000L), HEXCONSTE(4.15888308335967185649e+01, 0x4004, 0xa65af678L, 0x54b28211L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.26765060022822940150e+30, 0x4063, 0x80000000L, 0x00000000L), HEXCONSTE(6.93147180559945309403e+01, 0x4005, 0x8aa122b9L, 0x9bea170eL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(8.87228390520683530551e+01, 0x4005, 0xb17217f5L, 0xd1cf78acL), 0 },
	{ __LINE__, HEXCONSTE(1.07150860718626732095e+301, 0x43e7, 0x80000000L, 0x00000000L), HEXCONSTE(6.93147180559945309430e+02, 0x4008, 0xad496b68L, 0x02e49cd2L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(8.87228390520683530551e+01, 0x4005, 0xb17217f5L, 0xd1cf78acL), 0 },
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(7.09782712893383996744e+02, 0x4008, 0xb17217f7L, 0xd1cf79aaL), 0 },
#ifdef TEST_LDOUBLE
	{ __LINE__, HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.13565234062941439497e+04, 0x400c, 0xb17217f7L, 0xd1cf79acL), 0 },
#endif
	{ __LINE__, HEXCONSTE(4.47818189859390258789e-01, 0x3ffd, 0xe5486d00L, 0x00000000L), HEXCONSTE(3.70057726590900684178e-01, 0x3ffd, 0xbd7834d2L, 0xae1826bbL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(4.26667302846908569336e-01, 0x3ffd, 0xda742300L, 0x00000000L), HEXCONSTE(3.55341166846226615687e-01, 0x3ffd, 0xb5ef4705L, 0x0dd5ede1L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(5.01541376113891601562e+00, 0x4001, 0xa07e4500L, 0x00000000L), HEXCONSTE(1.79432513528011229479e+00, 0x3fff, 0xe5ac722fL, 0x359d2474L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(4.46847349405288696289e-01, 0x3ffd, 0xe4c92d00L, 0x00000000L), HEXCONSTE(3.69386947547633246711e-01, 0x3ffd, 0xbd204936L, 0x929cc151L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(4.46847319602966308594e-01, 0x3ffd, 0xe4c92c00L, 0x00000000L), HEXCONSTE(3.69386926949521976113e-01, 0x3ffd, 0xbd204885L, 0xa2e2f98cL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(4.46847332765786697806e-01, 0x3ffd, 0xe4c92c71L, 0x11592000L), HEXCONSTE(3.69386936047109642068e-01, 0x3ffd, 0xbd2048d3L, 0xc8b18710L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(5.29399693012237548828e-01, 0x3ffe, 0x8786bd00L, 0x00000000L), HEXCONSTE(4.24875300903655772161e-01, 0x3ffd, 0xd9894164L, 0x84caefefL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(4.71157163381576538086e-01, 0x3ffd, 0xf13b8300L, 0x00000000L), HEXCONSTE(3.86049277096128215124e-01, 0x3ffd, 0xc5a84037L, 0x8b6c8c58L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(4.71157133579254150391e-01, 0x3ffd, 0xf13b8200L, 0x00000000L), HEXCONSTE(3.86049256838385921264e-01, 0x3ffd, 0xc5a83f89L, 0x882d77acL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(4.71157161417916026114e-01, 0x3ffd, 0xf13b82efL, 0x21dd6800L), HEXCONSTE(3.86049275761355451100e-01, 0x3ffd, 0xc5a8402cL, 0x143a486bL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(5.94189643859863281250e-01, 0x3ffe, 0x981cd000L, 0x00000000L), HEXCONSTE(4.66365546854507051499e-01, 0x3ffd, 0xeec77707L, 0x7149719aL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(5.94189584255218505859e-01, 0x3ffe, 0x981ccf00L, 0x00000000L), HEXCONSTE(4.66365509465827405238e-01, 0x3ffd, 0xeec775c6L, 0x46b5fa79L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(5.94189616043658164202e-01, 0x3ffe, 0x981ccf88L, 0x87c25000L), HEXCONSTE(4.66365529406014981035e-01, 0x3ffd, 0xeec77671L, 0x8fa5a53aL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(5.94189616043658053179e-01, 0x3ffe, 0x981ccf88L, 0x87c24800L), HEXCONSTE(4.66365529406014911402e-01, 0x3ffd, 0xeec77671L, 0x8fa59b31L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(5.94189616043658087603e-01, 0x3ffe, 0x981ccf88L, 0x87c24a7bL), HEXCONSTE(4.66365529406014932978e-01, 0x3ffd, 0xeec77671L, 0x8fa59e4dL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(6.44569814205169677734e-01, 0x3ffe, 0xa5028700L, 0x00000000L), HEXCONSTE(4.97478838895861903924e-01, 0x3ffd, 0xfeb58bdfL, 0x0501d5d5L), FLAG_INEXACT5 },
	{ __LINE__, HEXCONSTE(6.44569754600524902344e-01, 0x3ffe, 0xa5028600L, 0x00000000L), HEXCONSTE(4.97478802652556608717e-01, 0x3ffd, 0xfeb58aa7L, 0xb122ceb9L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(6.44569756635426815983e-01, 0x3ffe, 0xa5028608L, 0xbd65f800L), HEXCONSTE(4.97478803889902672434e-01, 0x3ffd, 0xfeb58ab2L, 0x5216b769L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(6.44569756635426704960e-01, 0x3ffe, 0xa5028608L, 0xbd65f000L), HEXCONSTE(4.97478803889902604943e-01, 0x3ffd, 0xfeb58ab2L, 0x5216adafL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(6.44569756635426754237e-01, 0x3ffe, 0xa5028608L, 0xbd65f38dL), HEXCONSTE(4.97478803889902634894e-01, 0x3ffd, 0xfeb58ab2L, 0x5216b200L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(3.59245806932449340820e-01, 0x3ffd, 0xb7ef1100L, 0x00000000L), HEXCONSTE(3.06929992200031935768e-01, 0x3ffd, 0x9d25ed8dL, 0x5243a23bL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(3.59245777130126953125e-01, 0x3ffd, 0xb7ef1000L, 0x00000000L), HEXCONSTE(3.06929970274400410965e-01, 0x3ffd, 0x9d25ecd0L, 0xfb4a635aL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(3.59245804111232969191e-01, 0x3ffd, 0xb7ef10e7L, 0xc4146000L), HEXCONSTE(3.06929990124457113186e-01, 0x3ffd, 0x9d25ed7bL, 0x7e06e24fL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(3.59245804111232913680e-01, 0x3ffd, 0xb7ef10e7L, 0xc4145800L), HEXCONSTE(3.06929990124457072339e-01, 0x3ffd, 0x9d25ed7bL, 0x7e06dc6cL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(3.59245804111232931380e-01, 0x3ffd, 0xb7ef10e7L, 0xc4145a8dL), HEXCONSTE(3.06929990124457085376e-01, 0x3ffd, 0x9d25ed7bL, 0x7e06de4dL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(4.79081720113754272461e-01, 0x3ffd, 0xf54a3300L, 0x00000000L), HEXCONSTE(3.91421435828846050320e-01, 0x3ffd, 0xc86863f3L, 0xad2ff2b3L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(2.33715248107910156250e+00, 0x4000, 0x9593e800L, 0x00000000L), HEXCONSTE(1.20511789278555936367e+00, 0x3fff, 0x9a414d98L, 0xab511400L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(4.99057948589324951172e-01, 0x3ffd, 0xff848600L, 0x00000000L), HEXCONSTE(4.04836876538246344951e-01, 0x3ffd, 0xcf46c771L, 0xe4a3377bL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(4.99057918787002563477e-01, 0x3ffd, 0xff848500L, 0x00000000L), HEXCONSTE(4.04836856657545460795e-01, 0x3ffd, 0xcf46c6c7L, 0x1e83947bL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(4.99057926735368584392e-01, 0x3ffd, 0xff848544L, 0x46a44800L), HEXCONSTE(4.04836861959786221640e-01, 0x3ffd, 0xcf46c6f4L, 0xaa43c4f4L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(4.99057926735368528881e-01, 0x3ffd, 0xff848544L, 0x46a44000L), HEXCONSTE(4.04836861959786184587e-01, 0x3ffd, 0xcf46c6f4L, 0xaa43bf9dL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(4.99057926735368569620e-01, 0x3ffd, 0xff848544L, 0x46a445dfL), HEXCONSTE(4.04836861959786211774e-01, 0x3ffd, 0xcf46c6f4L, 0xaa43c388L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-3.09445589780807495117e-01, 0xbffd, 0x9e6fa700L, 0x00000000L), HEXCONSTE(-3.70260510947288434342e-01, 0xbffd, 0xbd92c923L, 0x09a734bbL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-3.09445619583129882812e-01, 0xbffd, 0x9e6fa800L, 0x00000000L), HEXCONSTE(-3.70260554104384515060e-01, 0xbffd, 0xbd92ca95L, 0xc11c6f36L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-3.09445606964839747821e-01, 0xbffd, 0x9e6fa793L, 0x9c162800L), HEXCONSTE(-3.70260535831688870011e-01, 0xbffd, 0xbd92c9f8L, 0xcb0745acL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-3.09445606964839803332e-01, 0xbffd, 0x9e6fa793L, 0x9c163000L), HEXCONSTE(-3.70260535831688950405e-01, 0xbffd, 0xbd92c9f8L, 0xcb075142L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-3.09445606964839758094e-01, 0xbffd, 0x9e6fa793L, 0x9c16297bL), HEXCONSTE(-3.70260535831688884892e-01, 0xbffd, 0xbd92c9f8L, 0xcb0747d1L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-3.09445606964839758121e-01, 0xbffd, 0x9e6fa793L, 0x9c16297cL), HEXCONSTE(-3.70260535831688884919e-01, 0xbffd, 0xbd92c9f8L, 0xcb0747d2L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(4.48923438787460327148e-01, 0x3ffd, 0xe5d94b00L, 0x00000000L), HEXCONSTE(3.70820824666872537312e-01, 0x3ffd, 0xbddc3a25L, 0x3d6c6619L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(4.48923408985137939453e-01, 0x3ffd, 0xe5d94a00L, 0x00000000L), HEXCONSTE(3.70820804098275262698e-01, 0x3ffd, 0xbddc3974L, 0x8e998569L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(4.48923411849659392825e-01, 0x3ffd, 0xe5d94a18L, 0x9b263800L), HEXCONSTE(3.70820806075275173646e-01, 0x3ffd, 0xbddc3985L, 0x8a118767L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(4.48923411849659337314e-01, 0x3ffd, 0xe5d94a18L, 0x9b263000L), HEXCONSTE(3.70820806075275135320e-01, 0x3ffd, 0xbddc3985L, 0x8a1181e1L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(4.48923411849659356585e-01, 0x3ffd, 0xe5d94a18L, 0x9b2632c7L), HEXCONSTE(3.70820806075275148628e-01, 0x3ffd, 0xbddc3985L, 0x8a1183ccL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(4.48923411849659356558e-01, 0x3ffd, 0xe5d94a18L, 0x9b2632c6L), HEXCONSTE(3.70820806075275148601e-01, 0x3ffd, 0xbddc3985L, 0x8a1183cbL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-3.90608966350555419922e-01, 0xbffd, 0xc7fde600L, 0x00000000L), HEXCONSTE(-4.95295125946312517749e-01, 0xbffd, 0xfd97529fL, 0x9d7f7e14L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-3.90608996152877807617e-01, 0xbffd, 0xc7fde700L, 0x00000000L), HEXCONSTE(-4.95295174851402141355e-01, 0xbffd, 0xfd975443L, 0xb4ed6b0dL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-3.90608967853182387220e-01, 0xbffd, 0xc7fde60cL, 0xe84fc800L), HEXCONSTE(-4.95295128412097024231e-01, 0xbffd, 0xfd9752b4L, 0xcbd0c3fcL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-3.90608967853182442731e-01, 0xbffd, 0xc7fde60cL, 0xe84fd000L), HEXCONSTE(-4.95295128412097115304e-01, 0xbffd, 0xfd9752b4L, 0xcbd0d11cL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-3.90608967853182390554e-01, 0xbffd, 0xc7fde60cL, 0xe84fc87bL), HEXCONSTE(-4.95295128412097029706e-01, 0xbffd, 0xfd9752b4L, 0xcbd0c4c6L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-3.90608967853182390581e-01, 0xbffd, 0xc7fde60cL, 0xe84fc87cL), HEXCONSTE(-4.95295128412097029734e-01, 0xbffd, 0xfd9752b4L, 0xcbd0c4c7L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(4.17804569005966186523e-01, 0x3ffd, 0xd5ea7b00L, 0x00000000L), HEXCONSTE(3.49109597036187463659e-01, 0x3ffd, 0xb2be7e3bL, 0xfaf6bc09L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(4.17804539203643798828e-01, 0x3ffd, 0xd5ea7a00L, 0x00000000L), HEXCONSTE(3.49109576016137625751e-01, 0x3ffd, 0xb2be7d87L, 0x6b62a848L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(4.17804539433889066125e-01, 0x3ffd, 0xd5ea7a01L, 0xfa509000L), HEXCONSTE(3.49109576178533259909e-01, 0x3ffd, 0xb2be7d88L, 0xd07f45a4L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(4.17804539433889010613e-01, 0x3ffd, 0xd5ea7a01L, 0xfa508800L), HEXCONSTE(3.49109576178533220769e-01, 0x3ffd, 0xb2be7d88L, 0xd07f4000L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(4.17804539433889036011e-01, 0x3ffd, 0xd5ea7a01L, 0xfa508ba9L), HEXCONSTE(3.49109576178533238659e-01, 0x3ffd, 0xb2be7d88L, 0xd07f4294L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(4.17804539433889035984e-01, 0x3ffd, 0xd5ea7a01L, 0xfa508ba8L), HEXCONSTE(3.49109576178533238659e-01, 0x3ffd, 0xb2be7d88L, 0xd07f4294L), FLAG_INEXACT3 },
};


int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_f_f(flognp1_data, ARRAY_SIZE(flognp1_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

```

`tests/log2.c`:

```c
#include "testconfig.h"
#ifdef HAVE_LOG2
#define TEST_FUNC_F_F __MATH_PRECNAME(log2)
#include "testdriver.h"



static test_f_f_data const flog2_data[] = {
	{ __LINE__, ZERO_P, INF_M, 0 },
	{ __LINE__, ZERO_M, INF_M, 0 },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__, MIN_M, QNAN_P, FLAG_MINVAL },
	{ __LINE__, MAX_M, QNAN_P, 0 },
#if __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, SUBNORM_P, HEXCONSTE(-16446, 0xc00d, 0x807c0000L, 0x00000000L), FLAG_SUBNORM|FLAG_INEXACT },
#else
	{ __LINE__, SUBNORM_P, HEXCONSTE(-16445, 0xc00d, 0x807a0000L, 0x00000000L), FLAG_SUBNORM|FLAG_INEXACT },
#endif
	{ __LINE__, SUBNORM_M, QNAN_P, FLAG_SUBNORM },
	{ __LINE__, INF_P, INF_P, FLAG_FAIL_JIT },
	{ __LINE__, INF_M, QNAN_P, 0 },
	{ __LINE__, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_P, 0 },
	{ __LINE__, SNAN_P, QNAN_P, 0 },
	{ __LINE__, SNAN_M, QNAN_P, 0 },

	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.71828198432922363281e+00, 0x4000, 0xadf85500L, 0x00000000L), HEXCONSTE(1.44269512361516368394e+00, 0x3fff, 0xb8aa3bdbL, 0x034d96a6L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.71828174591064453125e+00, 0x4000, 0xadf85400L, 0x00000000L), HEXCONSTE(1.44269499707740240927e+00, 0x3fff, 0xb8aa3acbL, 0x466ee273L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.71828182845904553488e+00, 0x4000, 0xadf85458L, 0xa2bb5000L), HEXCONSTE(1.44269504088896356633e+00, 0x3fff, 0xb8aa3b29L, 0x5c17f676L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.71828182845904509080e+00, 0x4000, 0xadf85458L, 0xa2bb4800L), HEXCONSTE(1.44269504088896333063e+00, 0x3fff, 0xb8aa3b29L, 0x5c17edf8L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.71828182845904523543e+00, 0x4000, 0xadf85458L, 0xa2bb4a9bL), HEXCONSTE(1.44269504088896340739e+00, 0x3fff, 0xb8aa3b29L, 0x5c17f0bcL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.71828182845904523521e+00, 0x4000, 0xadf85458L, 0xa2bb4a9aL), HEXCONSTE(1.44269504088896340728e+00, 0x3fff, 0xb8aa3b29L, 0x5c17f0bbL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.60000000000000000000e+01, 0x4003, 0x80000000L, 0x00000000L), HEXCONSTE(4.00000000000000000000e+00, 0x4001, 0x80000000L, 0x00000000L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.56000000000000000000e+02, 0x4007, 0x80000000L, 0x00000000L), HEXCONSTE(8.00000000000000000000e+00, 0x4002, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(7.50000000000000000000e-01, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(-4.15037499278843818553e-01, 0xbffd, 0xd47fcb8cL, 0x0852f0c1L), FLAG_INEXACT2 },
#ifdef TEST_LDOUBLE
	{ __LINE__, HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(1.71982640611844636194e-07, 0x3fe8, 0xb8aa3a70L, 0xb1ddbd98L), 0 },
	{ __LINE__, HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(1.71982640611844636194e-07, 0x3fe8, 0xb8aa3a70L, 0xb1ddbd98L), 0 },
#endif
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(3.20342650381491733023e-16, 0x3fcb, 0xb8aa3b29L, 0x5c17eaf6L), FLAG_INEXACT },
#ifdef TEST_LDOUBLE
	{ __LINE__, HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(1.71982640611844636194e-07, 0x3fe8, 0xb8aa3a70L, 0xb1ddbd98L), 0 },
#endif
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(3.20342650381491733023e-16, 0x3fcb, 0xb8aa3b29L, 0x5c17eaf6L), FLAG_INEXACT },
#ifdef TEST_LDOUBLE
	{ __LINE__, HEXCONSTE(1.00000000000000000011e+00, 0x3fff, 0x80000000L, 0x00000001L), HEXCONSTE(1.56417309756587777627e-19, 0x3fc0, 0xb8aa3b29L, 0x5c17f0bbL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(1.71982640611844636194e-07, 0x3fe8, 0xb8aa3a70L, 0xb1ddbd98L), 0 },
#endif
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#ifdef TEST_LDOUBLE
	{ __LINE__, HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(3.20342650381491733023e-16, 0x3fcb, 0xb8aa3b29L, 0x5c17eaf6L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.00000000000000000011e+00, 0x3fff, 0x80000000L, 0x00000001L), HEXCONSTE(1.56417309756587777627e-19, 0x3fc0, 0xb8aa3b29L, 0x5c17f0bbL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(1.71982640611844636194e-07, 0x3fe8, 0xb8aa3a70L, 0xb1ddbd98L), 0 },
#endif
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(3.20342650381491733023e-16, 0x3fcb, 0xb8aa3b29L, 0x5c17eaf6L), FLAG_INEXACT },
#ifdef TEST_LDOUBLE
	{ __LINE__, HEXCONSTE(1.00000000000000000011e+00, 0x3fff, 0x80000000L, 0x00000001L), HEXCONSTE(1.56417309756587777627e-19, 0x3fc0, 0xb8aa3b29L, 0x5c17f0bbL), FLAG_INEXACT },
#endif
	{ __LINE__, HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-8.59913279941456217510e-08, 0xbfe7, 0xb8aa3b85L, 0xb135c2f8L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-8.59913279941456217510e-08, 0xbfe7, 0xb8aa3b85L, 0xb135c2f8L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.60171325190745893186e-16, 0xbfca, 0xb8aa3b29L, 0x5c17f39eL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-8.59913279941456217510e-08, 0xbfe7, 0xb8aa3b85L, 0xb135c2f8L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.60171325190745893186e-16, 0xbfca, 0xb8aa3b29L, 0x5c17f39eL), FLAG_INEXACT },
#ifdef TEST_LDOUBLE
	{ __LINE__, HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-7.82086548782938888195e-20, 0xbfbf, 0xb8aa3b29L, 0x5c17f0bcL), FLAG_INEXACT },
#endif
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-8.59913279941456217510e-08, 0xbfe7, 0xb8aa3b85L, 0xb135c2f8L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.60171325190745893186e-16, 0xbfca, 0xb8aa3b29L, 0x5c17f39eL), FLAG_INEXACT },
#ifdef TEST_LDOUBLE
	{ __LINE__, HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-7.82086548782938888195e-20, 0xbfbf, 0xb8aa3b29L, 0x5c17f0bcL), FLAG_INEXACT },
#endif
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-8.59913279941456217510e-08, 0xbfe7, 0xb8aa3b85L, 0xb135c2f8L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.60171325190745893186e-16, 0xbfca, 0xb8aa3b29L, 0x5c17f39eL), FLAG_INEXACT },
#ifdef TEST_LDOUBLE
	{ __LINE__, HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-7.82086548782938888195e-20, 0xbfbf, 0xb8aa3b29L, 0x5c17f0bcL), FLAG_INEXACT },
#endif
	{ __LINE__, HEXCONSTE(1.15948033332824707031e+00, 0x3fff, 0x9469da00L, 0x00000000L), HEXCONSTE(2.13478349737746999043e-01, 0x3ffc, 0xda9a118aL, 0x1c5673acL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(9.28128838539123535156e-01, 0x3ffe, 0xed99da00L, 0x00000000L), HEXCONSTE(-1.07603007401175819906e-01, 0xbffb, 0xdc5ef72dL, 0xea1412a7L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(1.38992333412170410156e+00, 0x3fff, 0xb1e90200L, 0x00000000L), HEXCONSTE(4.75005308464772099393e-01, 0x3ffd, 0xf333e552L, 0x90af645cL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(1.38992321491241455078e+00, 0x3fff, 0xb1e90100L, 0x00000000L), HEXCONSTE(4.75005184729416331241e-01, 0x3ffd, 0xf333e12bL, 0xafc2a033L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(1.38992326340264593654e+00, 0x3fff, 0xb1e90168L, 0x21c96000L), HEXCONSTE(4.75005235060696779655e-01, 0x3ffd, 0xf333e2dcL, 0x076a9c1fL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(9.90675032138824462891e-01, 0x3ffe, 0xfd9ce100L, 0x00000000L), HEXCONSTE(-1.35162023672842129968e-02, 0xbff8, 0xdd730fc8L, 0x8cf5971cL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(9.90674972534179687500e-01, 0x3ffe, 0xfd9ce000L, 0x00000000L), HEXCONSTE(-1.35162891680263621323e-02, 0xbff8, 0xdd736cfcL, 0x282d9566L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(9.90675013895320089041e-01, 0x3ffe, 0xfd9ce0b1L, 0xa50e0800L), HEXCONSTE(-1.35162289348393416535e-02, 0xbff8, 0xdd732c4fL, 0x627319bcL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.02841734886169433594e+00, 0x3fff, 0x83a32e00L, 0x00000000L), HEXCONSTE(4.04258529987304141293e-02, 0x3ffa, 0xa5959448L, 0xade0bdcbL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.02841722965240478516e+00, 0x3fff, 0x83a32d00L, 0x00000000L), HEXCONSTE(4.04256857683146487057e-02, 0x3ffa, 0xa5956764L, 0xb14a9d7eL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(1.02841734059462108775e+00, 0x3fff, 0x83a32deeL, 0x3f20e000L), HEXCONSTE(4.04258414014293388701e-02, 0x3ffa, 0xa595912bL, 0xb7fff0baL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.02841734059462086570e+00, 0x3fff, 0x83a32deeL, 0x3f20d800L), HEXCONSTE(4.04258414014290273788e-02, 0x3ffa, 0xa595912bL, 0xb7fe899aL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.02841734059462093758e+00, 0x3fff, 0x83a32deeL, 0x3f20da97L), HEXCONSTE(4.04258414014291282198e-02, 0x3ffa, 0xa595912bL, 0xb7fefdddL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(5.43729151330010762599e-14, 0x3fd2, 0xf4dfb400L, 0x00000000L), HEXCONSTE(-4.40641051499986271429e+01, 0xc004, 0xb041a4c7L, 0xcaff42bdL), 0 },
	{ __LINE__, HEXCONSTE(1.04041373729705810547e+00, 0x3fff, 0x852c4700L, 0x00000000L), HEXCONSTE(5.71573534126692562429e-02, 0x3ffa, 0xea1dd43aL, 0x221d02a3L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.44015097618103027344e-01, 0x3ffe, 0xbe77c600L, 0x00000000L), HEXCONSTE(-4.26596197965653242483e-01, 0xbffd, 0xda6ad11dL, 0xb889492cL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.31206500530242919922e+00, 0x3fff, 0xa7f1bf00L, 0x00000000L), HEXCONSTE(3.91839198998837258474e-01, 0x3ffd, 0xc89f25c1L, 0xfb4fa369L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(9.23028625488281250000e+02, 0x4008, 0xe6c1d500L, 0x00000000L), HEXCONSTE(9.85023158001804244321e+00, 0x4002, 0x9d9a8c6dL, 0xe3432c00L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.42479920387268066406e-01, 0x3ffe, 0xbe132a00L, 0x00000000L), HEXCONSTE(-4.29576084663417567810e-01, 0xbffd, 0xdbf16585L, 0x8bd48000L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.09953486919403076172e-01, 0x3ffe, 0xb5bf8300L, 0x00000000L), HEXCONSTE(-4.94203586310681732506e-01, 0xbffd, 0xfd0840a1L, 0x8a63a046L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.09953427314758300781e-01, 0x3ffe, 0xb5bf8200L, 0x00000000L), HEXCONSTE(-4.94203707433164578916e-01, 0xbffd, 0xfd0844b1L, 0xf98bb3e6L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.09953478612022181871e-01, 0x3ffe, 0xb5bf82dcL, 0x51f02800L), HEXCONSTE(-4.94203603192093698118e-01, 0xbffd, 0xfd084132L, 0x8d01b4afL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.09953478612022070848e-01, 0x3ffe, 0xb5bf82dcL, 0x51f02000L), HEXCONSTE(-4.94203603192093923714e-01, 0xbffd, 0xfd084132L, 0x8d01d532L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.09953478612022073721e-01, 0x3ffe, 0xb5bf82dcL, 0x51f02035L), HEXCONSTE(-4.94203603192093917886e-01, 0xbffd, 0xfd084132L, 0x8d01d45bL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.16557383537292480469e-01, 0x3ffe, 0xb7704e00L, 0x00000000L), HEXCONSTE(-4.80845851488972676958e-01, 0xbffd, 0xf6316d6dL, 0x1ff446a1L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.16557323932647705078e-01, 0x3ffe, 0xb7704d00L, 0x00000000L), HEXCONSTE(-4.80845971495173134171e-01, 0xbffd, 0xf6317173L, 0xf8613bcaL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.16557370905037460673e-01, 0x3ffe, 0xb7704dc9L, 0xbeb05000L), HEXCONSTE(-4.80845876922374455576e-01, 0xbffd, 0xf6316e47L, 0x98989f5dL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.08730936050415039062e-01, 0x3ffe, 0xb56f6400L, 0x00000000L), HEXCONSTE(-4.96690070949499838085e-01, 0xbffd, 0xfe4e2935L, 0xf3b9161eL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.08730876445770263672e-01, 0x3ffe, 0xb56f6300L, 0x00000000L), HEXCONSTE(-4.96690192280917267915e-01, 0xbffd, 0xfe4e2d48L, 0x2e54e087L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.08730921511758316100e-01, 0x3ffe, 0xb56f63c1L, 0x8e93f000L), HEXCONSTE(-4.96690100544437921959e-01, 0xbffd, 0xfe4e2a34L, 0x2bae1a2bL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.08730921511758205078e-01, 0x3ffe, 0xb56f63c1L, 0x8e93e800L), HEXCONSTE(-4.96690100544438147961e-01, 0xbffd, 0xfe4e2a34L, 0x2bae3abdL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.08730921511758299458e-01, 0x3ffe, 0xb56f63c1L, 0x8e93eecdL), HEXCONSTE(-4.96690100544437955840e-01, 0xbffd, 0xfe4e2a34L, 0x2bae1f0dL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.26000000000000000000e+02, 0xc005, 0xfc000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(-1.02200000000000000000e+03, 0xc008, 0xff800000L, 0x00000000L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(-1.63820000000000000000e+04, 0xc00c, 0xfff80000L, 0x00000000L), 0 },
#if __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(-16384, 0xc00d, 0x80000000L, 0x00000000L), FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(-16446, 0xc00d, 0x807c0000L, 0x00000000L), FLAG_INEXACT|FLAG_SUBNORM },
#else
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(-16383, 0xc00c, 0xfffc0000L, 0x00000000L), FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(-16445, 0xc00d, 0x807a0000L, 0x00000000L), FLAG_SUBNORM },
#endif
	{ __LINE__, HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(-9.69000000000000000000e+02, 0xc008, 0xf2400000L, 0x00000000L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.49000000000000000000e+02, 0xc006, 0x95000000L, 0x00000000L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(-1.07400000000000000000e+03, 0xc009, 0x86400000L, 0x00000000L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.27999999914008672004e+02, 0x4005, 0xfffffffdL, 0x1d5711e9L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.02399999999999999983e+03, 0x4008, 0xffffffffL, 0xfffffffdL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.63840000000000000000e+04, 0x400d, 0x80000000L, 0x00000000L), FLAG_INEXACT },

	{ __LINE__, HEXCONST_E, HEXCONST_LOG2E, 0 },
	{ __LINE__, HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(16.0, 0x4003, 0x80000000L, 0x00000000L), HEXCONSTE(4, 0x4001, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(256.0, 0x4007, 0x80000000L, 0x00000000L), HEXCONSTE(8, 0x4002, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.75L, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(-.415037499278843818546261056052183492L, 0xbffd, 0xd47fcb8cL, 0x0852f0c1L), 0 },
};


int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_f_f(flog2_data, ARRAY_SIZE(flog2_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

#else

int main(void)
{
	return 77;
}

#endif

```

`tests/logb.c`:

```c
#include "testconfig.h"
#ifdef HAVE_LOGB
#define TEST_FUNC_F_F __MATH_PRECNAME(logb)
#include "testdriver.h"



static test_f_f_data const logb_data[] = {
	{ __LINE__, ZERO_P, INF_M, FLAG_FAIL_HARDFLOAT|FLAG_FAIL_ARANYM },
	{ __LINE__, ZERO_M, INF_M, FLAG_FAIL_HARDFLOAT|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), ZERO_P, 0 },
	{ __LINE__, MIN_M, QNAN_P, FLAG_MINVAL },
#if defined (TEST_LDOUBLE) && LDBL_MAX_EXP == 16384
	{ __LINE__, MAX_M, HEXCONSTE(16383, 0x400c, 0xfffc0000L, 0x00000000L), 0 },
#endif
#if defined (TEST_DOUBLE) && DBL_MAX_EXP == 1024
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308L, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1023, 0x4008, 0xffc00000L, 0x00000000L), 0 },
#endif
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, SUBNORM_P, HEXCONSTE(-16446, 0xc00d, 0x807c0000L, 0x00000000L), FLAG_SUBNORM|FLAG_INEXACT },
#endif
#if defined (TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16381)
	{ __LINE__, SUBNORM_P, HEXCONSTE(-16445, 0xc00d, 0x807a0000L, 0x00000000L), FLAG_SUBNORM|FLAG_INEXACT },
#endif
	{ __LINE__, SUBNORM_M, QNAN_P, FLAG_SUBNORM },
	{ __LINE__, INF_P, INF_P, FLAG_FAIL_HARDFLOAT|FLAG_FAIL_ARANYM },
	{ __LINE__, INF_M, INF_P, FLAG_FAIL_HARDFLOAT|FLAG_FAIL_ARANYM },
	{ __LINE__, QNAN_P, QNAN_P, FLAG_FAIL_ARANYM },
	{ __LINE__, QNAN_M, QNAN_P, FLAG_FAIL_ARANYM },
	{ __LINE__, SNAN_P, QNAN_P, FLAG_FAIL_ARANYM },
	{ __LINE__, SNAN_M, QNAN_P, FLAG_FAIL_ARANYM },

	{ __LINE__, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), ZERO_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONST_E, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1024, 0x4009, 0x80000000L, 0x00000000L), HEXCONSTE(10, 0x4002, 0xa0000000L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-2000, 0xc009, 0xfa000000L, 0x00000000L), HEXCONSTE(10, 0x4002, 0xa0000000L, 0x00000000L), NO_INEXACT_EXCEPTION },

	{ __LINE__, HEXCONSTE(3.67341984631964846240e-40, 0x3f7c, 0x80000000L, 0x00000000L), HEXCONSTE(-131, 0xc006, 0x83000000L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(2.29588740394978028900e-41, 0x3f78, 0x80000000L, 0x00000000L), HEXCONSTE(-135, 0xc006, 0x87000000L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(2.43938036669664155706e-41, 0x3f78, 0x88000000L, 0x00000000L), HEXCONSTE(-135, 0xc006, 0x87000000L, 0x00000000L), NO_INEXACT_EXCEPTION },
#ifndef TEST_FLOAT
	{ __LINE__, HEXCONSTE(1.11253692925360069155e-308, 0x3c00, 0x80000000L, 0x00000000L), HEXCONSTE(-1023, 0xc008, 0xffc00000L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.39067116156700086443e-309, 0x3bfd, 0x80000000L, 0x00000000L), HEXCONSTE(-1026, 0xc009, 0x80400000L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(5.79304850933519342025e-312, 0x3bf5, 0x88800000L, 0x00000000L), HEXCONSTE(-1034, 0xc009, 0x81400000L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(2.12199579096527231511e-314, 0x3bed, 0x80000000L, 0x00000000L), HEXCONSTE(-1042, 0xc009, 0x82400000L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(2.25462052790060183481e-314, 0x3bed, 0x88000000L, 0x00000000L), HEXCONSTE(-1042, 0xc009, 0x82400000L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(-1074, 0xc009, 0x86400000L, 0x00000000L), NO_INEXACT_EXCEPTION },
#endif
#if defined TEST_LDOUBLE && LDBL_MIN_EXP - LDBL_MANT_DIG <= -16400
	{ __LINE__, HEXCONSTE(1.28254056667789211512e-4937, 0x0000, 0x00002000L, 0x00000000L), HEXCONSTE(-16400, 0xc00d, 0x80200000L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.91113437217159884441e-4945, 0x0000, 0x00000000L, 0x00080000L), HEXCONSTE(-16426, 0xc00d, 0x80540000L, 0x00000000L), NO_INEXACT_EXCEPTION },
#endif
};


int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_f_f(logb_data, ARRAY_SIZE(logb_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

#else

int main(void)
{
	return 77;
}

#endif

```

`tests/lrint.c`:

```c
#include "testconfig.h"
#if defined(HAVE_LRINT)
#define TEST_FUNC_F_L __MATH_PRECNAME(lrint)
#include "testdriver.h"



static test_f_l_data const lrint_data[] = {
	{ __LINE__, QNAN_P, LONG_MIN, 0 },
	{ __LINE__, QNAN_M, LONG_MIN, 0 },
	{ __LINE__, SNAN_P, LONG_MIN, 0 },
	{ __LINE__, SNAN_M, LONG_MIN, 0 },
	{ __LINE__, INF_P, LONG_MIN, 0 },
	{ __LINE__, INF_M, LONG_MIN, 0 },
	{ __LINE__, ZERO_P, 0, 0 },
	{ __LINE__, ZERO_M, 0, 0 },
	{ __LINE__, SUBNORM_P, 0, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, 0, FLAG_SUBNORM },
	{ __LINE__, MIN_P, 0, 0 },
	{ __LINE__, MIN_M, 0, 0 },
	{ __LINE__, MAX_P, LONG_MIN, 0 },
	{ __LINE__, MAX_M, LONG_MIN, 0 },

	{ __LINE__, HEXCONSTE(0.4L, 0x3ffd, 0xccccccccL, 0xcccccccdL), 0, 0 },
	{ __LINE__, HEXCONSTE(0.5L, 0x3ffe, 0x80000000L, 0x00000000L), 0, FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(0.6L, 0x3ffe, 0x99999999L, 0x9999999aL), 1, 0 },
	{ __LINE__, HEXCONSTE(1.0L, 0x3fff, 0x80000000L, 0x00000000L), 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.4L, 0x3fff, 0xb3333333L, 0x33333333L), 1, 0 },
	{ __LINE__, HEXCONSTE(1.5L, 0x3fff, 0xc0000000L, 0x00000000L), 2, 0 },
	{ __LINE__, HEXCONSTE(1.6L, 0x3fff, 0xccccccccL, 0xcccccccdL), 2, 0 },
	{ __LINE__, HEXCONSTE(2.4L, 0x4000, 0x99999999L, 0x9999999aL), 2, 0 },
	{ __LINE__, HEXCONSTE(2.5L, 0x4000, 0xa0000000L, 0x00000000L), 2, FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(2.6L, 0x4000, 0xa6666666L, 0x66666666L), 3, 0 },
	{ __LINE__, HEXCONSTE(3.4L, 0x4000, 0xd9999999L, 0x9999999aL), 3, 0 },
	{ __LINE__, HEXCONSTE(3.5L, 0x4000, 0xe0000000L, 0x00000000L), 4, INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(3.6L, 0x4000, 0xe6666666L, 0x66666666L), 4, INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-0.4L, 0xbffd, 0xccccccccL, 0xcccccccdL), 0, INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-0.5L, 0xbffe, 0x80000000L, 0x00000000L), 0, INEXACT_EXCEPTION|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(-0.6L, 0xbffe, 0x99999999L, 0x9999999aL), -1, INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-1.0L, 0xbfff, 0x80000000L, 0x00000000L), -1, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-1.4L, 0xbfff, 0xb3333333L, 0x33333333L), -1, INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-1.5L, 0xbfff, 0xc0000000L, 0x00000000L), -2, INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-1.6L, 0xbfff, 0xccccccccL, 0xcccccccdL), -2, INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-2.4L, 0xc000, 0x99999999L, 0x9999999aL), -2, INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-2.5L, 0xc000, 0xa0000000L, 0x00000000L), -2, INEXACT_EXCEPTION|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(-2.6L, 0xc000, 0xa6666666L, 0x66666666L), -3, INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-3.4L, 0xc000, 0xd9999999L, 0x9999999aL), -3, INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-3.5L, 0xc000, 0xe0000000L, 0x00000000L), -4, INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-3.6L, 0xc000, 0xe6666666L, 0x66666666L), -4, INEXACT_EXCEPTION },

	{ __LINE__, HEXCONSTE(8388600.3L, 0x4015, 0xfffff099L, 0x9999999aL), 8388600L, 0 },
	{ __LINE__, HEXCONSTE(-8388600.3L, 0xc015, 0xfffff099L, 0x9999999aL), -8388600L, 0 },

	{ __LINE__, HEXCONSTE(1048576.0, 0x4013, 0x80000000L, 0x00000000L), 1048576L, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1048576.4, 0x4013, 0x80000333L, 0x33333333L), 1048576L, 0 },
	{ __LINE__, HEXCONSTE(1048576.5, 0x4013, 0x80000400L, 0x00000000L), 1048576L, FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(1048576.6, 0x4013, 0x800004ccL, 0xcccccccdL), 1048577L, 0 },
	{ __LINE__, HEXCONSTE(1048577.0, 0x4013, 0x80000800L, 0x00000000L), 1048577L, 0 },
	{ __LINE__, HEXCONSTE(1048577.4, 0x4013, 0x80000b33L, 0x33333333L), 1048577L, 0 },
	{ __LINE__, HEXCONSTE(1048577.5, 0x4013, 0x80000c00L, 0x00000000L), 1048578L, 0 },
	{ __LINE__, HEXCONSTE(1048577.6, 0x4013, 0x80000cccL, 0xcccccccdL), 1048578L, 0 },
	{ __LINE__, HEXCONSTE(1048578.0, 0x4013, 0x80001000L, 0x00000000L), 1048578L, 0 },
	{ __LINE__, HEXCONSTE(1048578.4, 0x4013, 0x80001333L, 0x33333333L), 1048578L, 0 },
	{ __LINE__, HEXCONSTE(1048578.5, 0x4013, 0x80001400L, 0x00000000L), 1048578L, FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(1048578.6, 0x4013, 0x800014ccL, 0xcccccccdL), 1048579L, 0 },
	{ __LINE__, HEXCONSTE(1048579.0, 0x4013, 0x80001800L, 0x00000000L), 1048579L, 0 },
	{ __LINE__, HEXCONSTE(1048579.4, 0x4013, 0x80001b33L, 0x33333333L), 1048579L, 0 },
	{ __LINE__, HEXCONSTE(1048579.5, 0x4013, 0x80001c00L, 0x00000000L), 1048580L, 0 },
	{ __LINE__, HEXCONSTE(1048579.6, 0x4013, 0x80001cccL, 0xcccccccdL), 1048580L, 0 },
	{ __LINE__, HEXCONSTE(-1048576.0, 0xc013, 0x80000000L, 0x00000000L), -1048576L, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-1048576.4, 0xc013, 0x80000333L, 0x33333333L), -1048576L, 0 },
	{ __LINE__, HEXCONSTE(-1048576.5, 0xc013, 0x80000400L, 0x00000000L), -1048576L, FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(-1048576.6, 0xc013, 0x800004ccL, 0xcccccccdL), -1048577L, 0 },
	{ __LINE__, HEXCONSTE(-1048577.0, 0xc013, 0x80000800L, 0x00000000L), -1048577L, 0 },
	{ __LINE__, HEXCONSTE(-1048577.4, 0xc013, 0x80000b33L, 0x33333333L), -1048577L, 0 },
	{ __LINE__, HEXCONSTE(-1048577.5, 0xc013, 0x80000c00L, 0x00000000L), -1048578L, 0 },
	{ __LINE__, HEXCONSTE(-1048577.6, 0xc013, 0x80000cccL, 0xcccccccdL), -1048578L, 0 },
	{ __LINE__, HEXCONSTE(-1048578.0, 0xc013, 0x80001000L, 0x00000000L), -1048578L, 0 },
	{ __LINE__, HEXCONSTE(-1048578.4, 0xc013, 0x80001333L, 0x33333333L), -1048578L, 0 },
	{ __LINE__, HEXCONSTE(-1048578.5, 0xc013, 0x80001400L, 0x00000000L), -1048578L, FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(-1048578.6, 0xc013, 0x800014ccL, 0xcccccccdL), -1048579L, 0 },
	{ __LINE__, HEXCONSTE(-1048579.0, 0xc013, 0x80001800L, 0x00000000L), -1048579L, 0 },
	{ __LINE__, HEXCONSTE(-1048579.4, 0xc013, 0x80001b33L, 0x33333333L), -1048579L, 0 },
	{ __LINE__, HEXCONSTE(-1048579.5, 0xc013, 0x80001c00L, 0x00000000L), -1048580L, 0 },
	{ __LINE__, HEXCONSTE(-1048579.6, 0xc013, 0x80001cccL, 0xcccccccdL), -1048580L, 0 },

	{ __LINE__, HEXCONSTE(2097152.0, 0x4014, 0x80000000L, 0x00000000L), 2097152L, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(2097152.4, 0x4014, 0x80000199L, 0x9999999aL), 2097152L, 0 },
	{ __LINE__, HEXCONSTE(2097152.5, 0x4014, 0x80000200L, 0x00000000L), 2097152L, FLAG_FAIL_ARANYM },
#ifdef TEST_FLOAT
	{ __LINE__, HEXCONSTE(2097152.6, 0x4014, 0x80000266L, 0x66666666L), 2097152L, 0 },
#else
	{ __LINE__, HEXCONSTE(2097152.6, 0x4014, 0x80000266L, 0x66666666L), 2097153L, 0 },
#endif
	{ __LINE__, HEXCONSTE(2097153.0, 0x4014, 0x80000400L, 0x00000000L), 2097153L, 0 },
#ifdef TEST_FLOAT
	{ __LINE__, HEXCONSTE(2097153.4, 0x4014, 0x80000599L, 0x9999999aL), 2097154L, 0 },
#else
	{ __LINE__, HEXCONSTE(2097153.4, 0x4014, 0x80000599L, 0x9999999aL), 2097153L, 0 },
#endif
	{ __LINE__, HEXCONSTE(2097153.5, 0x4014, 0x80000600L, 0x00000000L), 2097154L, 0 },
	{ __LINE__, HEXCONSTE(2097153.6, 0x4014, 0x80000666L, 0x66666666L), 2097154L, 0 },
	{ __LINE__, HEXCONSTE(2097154.0, 0x4014, 0x80000800L, 0x00000000L), 2097154L, 0 },
	{ __LINE__, HEXCONSTE(2097154.4, 0x4014, 0x80000999L, 0x9999999aL), 2097154L, 0 },
	{ __LINE__, HEXCONSTE(2097154.5, 0x4014, 0x80000a00L, 0x00000000L), 2097154L, FLAG_FAIL_ARANYM },
#ifdef TEST_FLOAT
	{ __LINE__, HEXCONSTE(2097154.6, 0x4014, 0x80000a66L, 0x66666666L), 2097154L, 0 },
#else
	{ __LINE__, HEXCONSTE(2097154.6, 0x4014, 0x80000a66L, 0x66666666L), 2097155L, 0 },
#endif
	{ __LINE__, HEXCONSTE(2097155.0, 0x4014, 0x80000c00L, 0x00000000L), 2097155L, 0 },
#ifdef TEST_FLOAT
	{ __LINE__, HEXCONSTE(2097155.4, 0x4014, 0x80000d99L, 0x9999999aL), 2097156L, 0 },
#else
	{ __LINE__, HEXCONSTE(2097155.4, 0x4014, 0x80000d99L, 0x9999999aL), 2097155L, 0 },
#endif
	{ __LINE__, HEXCONSTE(2097155.5, 0x4014, 0x80000e00L, 0x00000000L), 2097156L, 0 },
	{ __LINE__, HEXCONSTE(2097155.6, 0x4014, 0x80000e66L, 0x66666666L), 2097156L, 0 },
	
	{ __LINE__, HEXCONSTE(-2097152.0, 0xc014, 0x80000000L, 0x00000000L), -2097152L, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-2097152.4, 0xc014, 0x80000199L, 0x9999999aL), -2097152L, 0 },
	{ __LINE__, HEXCONSTE(-2097152.5, 0xc014, 0x80000200L, 0x00000000L), -2097152L, FLAG_FAIL_ARANYM },
#ifdef TEST_FLOAT
	{ __LINE__, HEXCONSTE(-2097152.6, 0xc014, 0x80000266L, 0x66666666L), -2097152L, 0 },
#else
	{ __LINE__, HEXCONSTE(-2097152.6, 0xc014, 0x80000266L, 0x66666666L), -2097153L, 0 },
#endif
	{ __LINE__, HEXCONSTE(-2097153.0, 0xc014, 0x80000400L, 0x00000000L), -2097153L, 0 },
#ifdef TEST_FLOAT
	{ __LINE__, HEXCONSTE(-2097153.4, 0xc014, 0x80000599L, 0x9999999aL), -2097154L, 0 },
#else
	{ __LINE__, HEXCONSTE(-2097153.4, 0xc014, 0x80000599L, 0x9999999aL), -2097153L, 0 },
#endif
	{ __LINE__, HEXCONSTE(-2097153.5, 0xc014, 0x80000600L, 0x00000000L), -2097154L, 0 },
	{ __LINE__, HEXCONSTE(-2097153.6, 0xc014, 0x80000666L, 0x66666666L), -2097154L, 0 },
	{ __LINE__, HEXCONSTE(-2097154.0, 0xc014, 0x80000800L, 0x00000000L), -2097154L, 0 },
	{ __LINE__, HEXCONSTE(-2097154.4, 0xc014, 0x80000999L, 0x9999999aL), -2097154L, 0 },
	{ __LINE__, HEXCONSTE(-2097154.5, 0xc014, 0x80000a00L, 0x00000000L), -2097154L, FLAG_FAIL_ARANYM },
#ifdef TEST_FLOAT
	{ __LINE__, HEXCONSTE(-2097154.6, 0xc014, 0x80000a66L, 0x66666666L), -2097154L, 0 },
#else
	{ __LINE__, HEXCONSTE(-2097154.6, 0xc014, 0x80000a66L, 0x66666666L), -2097155L, 0 },
#endif
	{ __LINE__, HEXCONSTE(-2097155.0, 0xc014, 0x80000c00L, 0x00000000L), -2097155L, 0 },
#ifdef TEST_FLOAT
	{ __LINE__, HEXCONSTE(-2097155.4, 0xc014, 0x80000d99L, 0x9999999aL), -2097156L, 0 },
#else
	{ __LINE__, HEXCONSTE(-2097155.4, 0xc014, 0x80000d99L, 0x9999999aL), -2097155L, 0 },
#endif
	{ __LINE__, HEXCONSTE(-2097155.5, 0xc014, 0x80000e00L, 0x00000000L), -2097156L, 0 },
	{ __LINE__, HEXCONSTE(-2097155.6, 0xc014, 0x80000e66L, 0x66666666L), -2097156L, 0 },
	
#ifndef TEST_FLOAT
	{ __LINE__, HEXCONSTE(1071930.0008, 0x4013, 0x82d9d001L, 0xa36e2eb2L), 1071930L, 0 },
	{ __LINE__, HEXCONSTE(1073741824.01, 0x401d, 0x80000000L, 0x051eb852L), 1073741824L, 0 },
# if LONG_MAX > 281474976710656L
	{ __LINE__, HEXCONSTE(281474976710656.025L, 0x402f, 0x80000000L, 0x00000333L), 281474976710656L, 0 },
# endif
# if LONG_MAX > 21480603647L
	{ __LINE__, HEXCONSTE(21480603647.0, 0x4021, 0xa00affffL, 0xe0000000L), 21480603647L, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(21480603648.0, 0x4021, 0xa00b0000L, 0x00000000L), 21480603648L, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-21480603648.0, 0xc021, 0xa00b0000L, 0x00000000L), -21480603648L, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-21480603649.0, 0xc021, 0xa00b0000L, 0x20000000L), -21480603649L, NO_INEXACT_EXCEPTION },
# else
    /*
     * "If the rounded value is too large to be stored in a long, then a domain error occurs, and the return value is unspecified."
     *
     * In the softfloat version, the return value will be LONG_MAX (from fixdfsi). The FPU will return LONG_MIN.
     */
#ifdef __HAVE_68881__
	{ __LINE__, HEXCONSTE(21480603647.0, 0x4021, 0xa00affffL, 0xe0000000L), LONG_MIN, INVALID_EXCEPTION },
	{ __LINE__, HEXCONSTE(21480603648.0, 0x4021, 0xa00b0000L, 0x00000000L), LONG_MIN, INVALID_EXCEPTION },
#else
	{ __LINE__, HEXCONSTE(21480603647.0, 0x4021, 0xa00affffL, 0xe0000000L), LONG_MAX, INVALID_EXCEPTION },
	{ __LINE__, HEXCONSTE(21480603648.0, 0x4021, 0xa00b0000L, 0x00000000L), LONG_MAX, INVALID_EXCEPTION },
#endif
	{ __LINE__, HEXCONSTE(-21480603648.0, 0xc021, 0xa00b0000L, 0x00000000L), LONG_MIN, INVALID_EXCEPTION },
	{ __LINE__, HEXCONSTE(-21480603649.0, 0xc021, 0xa00b0000L, 0x20000000L), LONG_MIN, INVALID_EXCEPTION },
# endif
#endif

	{ __LINE__, HEXCONSTE(0.0, 0x0000, 0x00000000L, 0x00000000L), 0, NO_INEXACT_EXCEPTION|ROUND_TONEAREST },
	{ __LINE__, ZERO_M, 0, NO_INEXACT_EXCEPTION|ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(0.2L, 0x3ffc, 0xccccccccL, 0xcccccccdL), 0, INEXACT_EXCEPTION|ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(-0.2L, 0xbffc, 0xccccccccL, 0xcccccccdL), 0, INEXACT_EXCEPTION|ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(0.5L, 0x3ffe, 0x80000000L, 0x00000000L), 0, INEXACT_EXCEPTION|ROUND_TONEAREST|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(-0.5L, 0xbffe, 0x80000000L, 0x00000000L), 0, INEXACT_EXCEPTION|ROUND_TONEAREST|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(0.8L, 0x3ffe, 0xccccccccL, 0xcccccccdL), 1, INEXACT_EXCEPTION|ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(-0.8L, 0xbffe, 0xccccccccL, 0xcccccccdL), -1, INEXACT_EXCEPTION|ROUND_TONEAREST },

	{ __LINE__, HEXCONSTE(1.4L, 0x3fff, 0xb3333333L, 0x33333333L), 1, INEXACT_EXCEPTION|ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(-1.4L, 0xbfff, 0xb3333333L, 0x33333333L), -1, INEXACT_EXCEPTION|ROUND_TONEAREST },

	{ __LINE__, HEXCONSTE(8388600.3L, 0x4015, 0xfffff099L, 0x9999999aL), 8388600L, ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(-8388600.3L, 0xc015, 0xfffff099L, 0x9999999aL), -8388600L, ROUND_TONEAREST },

#ifndef TEST_FLOAT
	{ __LINE__, HEXCONSTE(1071930.0008, 0x4013, 0x82d9d001L, 0xa36e2eb2L), 1071930L, ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(1073741824.01, 0x401d, 0x80000000L, 0x051eb852L), 1073741824L, ROUND_TONEAREST },
# if LONG_MAX > 281474976710656L
	{ __LINE__, HEXCONSTE(281474976710656.025L, 0x402f, 0x80000000L, 0x00000333L), 281474976710656L, ROUND_TONEAREST },
# endif
#endif

#if 0
	{ __LINE__, HEXCONSTE(0.0, 0x0000, 0x00000000L, 0x00000000L), 0, NO_INEXACT_EXCEPTION|ROUND_TOWARDZERO },
	{ __LINE__, ZERO_M, 0, NO_INEXACT_EXCEPTION|ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(0.2L, 0x3ffc, 0xccccccccL, 0xcccccccdL), 0, INEXACT_EXCEPTION|ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-0.2L, 0xbffc, 0xccccccccL, 0xcccccccdL), 0, INEXACT_EXCEPTION|ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(0.5L, 0x3ffe, 0x80000000L, 0x00000000L), 0, INEXACT_EXCEPTION|ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-0.5L, 0xbffe, 0x80000000L, 0x00000000L), 0, INEXACT_EXCEPTION|ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(0.8L, 0x3ffe, 0xccccccccL, 0xcccccccdL), 0, INEXACT_EXCEPTION|ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-0.8L, 0xbffe, 0xccccccccL, 0xcccccccdL), 0, INEXACT_EXCEPTION|ROUND_TOWARDZERO },

	{ __LINE__, HEXCONSTE(1.4L, 0x3fff, 0xb3333333L, 0x33333333L), 1, INEXACT_EXCEPTION|ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-1.4L, 0xbfff, 0xb3333333L, 0x33333333L), -1, INEXACT_EXCEPTION|ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(1.5L, 0x3fff, 0xc0000000L, 0x00000000L), 1, INEXACT_EXCEPTION|ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-1.5L, 0xbfff, 0xc0000000L, 0x00000000L), -1, INEXACT_EXCEPTION|ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(1.8L, 0x3fff, 0xe6666666L, 0x66666666L), 1, INEXACT_EXCEPTION|ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-1.8L, 0xbfff, 0xe6666666L, 0x66666666L), -1, INEXACT_EXCEPTION|ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(3.0L, 0x4000, 0xc0000000L, 0x00000000L), 3, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-3.0L, 0xc000, 0xc0000000L, 0x00000000L), -3, ROUND_TOWARDZERO },

	{ __LINE__, HEXCONSTE(8388600.3L, 0x4015, 0xfffff099L, 0x9999999aL), 8388600L, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-8388600.3L, 0xc015, 0xfffff099L, 0x9999999aL), -8388600L, ROUND_TOWARDZERO },

	{ __LINE__, HEXCONSTE(1048576.0, 0x4013, 0x80000000L, 0x00000000L), 1048576L, NO_INEXACT_EXCEPTION|ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(1048576.4, 0x4013, 0x80000333L, 0x33333333L), 1048576L, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(1048576.5, 0x4013, 0x80000400L, 0x00000000L), 1048576L, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(1048576.6, 0x4013, 0x800004ccL, 0xcccccccdL), 1048576L, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(1048577.0, 0x4013, 0x80000800L, 0x00000000L), 1048577L, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(1048577.4, 0x4013, 0x80000b33L, 0x33333333L), 1048577L, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(1048577.5, 0x4013, 0x80000c00L, 0x00000000L), 1048577L, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(1048577.6, 0x4013, 0x80000cccL, 0xcccccccdL), 1048577L, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(1048578.0, 0x4013, 0x80001000L, 0x00000000L), 1048578L, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(1048578.4, 0x4013, 0x80001333L, 0x33333333L), 1048578L, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(1048578.5, 0x4013, 0x80001400L, 0x00000000L), 1048578L, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(1048578.6, 0x4013, 0x800014ccL, 0xcccccccdL), 1048578L, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(1048579.0, 0x4013, 0x80001800L, 0x00000000L), 1048579L, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(1048579.4, 0x4013, 0x80001b33L, 0x33333333L), 1048579L, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(1048579.5, 0x4013, 0x80001c00L, 0x00000000L), 1048579L, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(1048579.6, 0x4013, 0x80001cccL, 0xcccccccdL), 1048579L, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-1048576.0, 0xc013, 0x80000000L, 0x00000000L), -1048576L, NO_INEXACT_EXCEPTION|ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-1048576.4, 0xc013, 0x80000333L, 0x33333333L), -1048576L, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-1048576.5, 0xc013, 0x80000400L, 0x00000000L), -1048576L, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-1048576.6, 0xc013, 0x800004ccL, 0xcccccccdL), -1048576L, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-1048577.0, 0xc013, 0x80000800L, 0x00000000L), -1048577L, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-1048577.4, 0xc013, 0x80000b33L, 0x33333333L), -1048577L, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-1048577.5, 0xc013, 0x80000c00L, 0x00000000L), -1048577L, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-1048577.6, 0xc013, 0x80000cccL, 0xcccccccdL), -1048577L, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-1048578.0, 0xc013, 0x80001000L, 0x00000000L), -1048578L, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-1048578.4, 0xc013, 0x80001333L, 0x33333333L), -1048578L, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-1048578.5, 0xc013, 0x80001400L, 0x00000000L), -1048578L, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-1048578.6, 0xc013, 0x800014ccL, 0xcccccccdL), -1048578L, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-1048579.0, 0xc013, 0x80001800L, 0x00000000L), -1048579L, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-1048579.4, 0xc013, 0x80001b33L, 0x33333333L), -1048579L, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-1048579.5, 0xc013, 0x80001c00L, 0x00000000L), -1048579L, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-1048579.6, 0xc013, 0x80001cccL, 0xcccccccdL), -1048579L, ROUND_TOWARDZERO },

#ifndef TEST_FLOAT
	{ __LINE__, HEXCONSTE(1071930.0008, 0x4013, 0x82d9d001L, 0xa36e2eb2L), 1071930L, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(1073741824.01, 0x401d, 0x80000000L, 0x051eb852L), 1073741824L, ROUND_TOWARDZERO },
# if LONG_MAX > 281474976710656L
	{ __LINE__, HEXCONSTE(281474976710656.025L, 0x402f, 0x80000000L, 0x00000333L), 281474976710656L, ROUND_TOWARDZERO },
# endif
# if LONG_MAX > 21480603647L
	{ __LINE__, HEXCONSTE(21480603647.0, 0x4021, 0xa00affffL, 0xe0000000L), 21480603647L, NO_INEXACT_EXCEPTION|ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(21480603647.2, 0x4021, 0xa00affffL, 0xe6666666L), 21480603647L, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(21480603647.5, 0x4021, 0xa00affffL, 0xf0000000L), 21480603647L, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(21480603647.8, 0x4021, 0xa00affffL, 0xf999999aL), 21480603647L, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(21480603648.0, 0x4021, 0xa00b0000L, 0x00000000L), 21480603648L, NO_INEXACT_EXCEPTION|ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-21480603648.0, 0xc021, 0xa00b0000L, 0x00000000L), -21480603648L, NO_INEXACT_EXCEPTION|ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-21480603648.2, 0xc021, 0xa00b0000L, 0x06666666L), -21480603648L, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-21480603648.5, 0xc021, 0xa00b0000L, 0x10000000L), -21480603648L, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-21480603648.8, 0xc021, 0xa00b0000L, 0x1999999aL), -21480603648L, ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-21480603649.0, 0xc021, 0xa00b0000L, 0x20000000L), -21480603649L, ROUND_TOWARDZERO },
#endif
#endif

	{ __LINE__, HEXCONSTE(0.0, 0x0000, 0x00000000L, 0x00000000L), 0, NO_INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, ZERO_M, 0, NO_INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(0.2L, 0x3ffc, 0xccccccccL, 0xcccccccdL), 0, INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-0.2L, 0xbffc, 0xccccccccL, 0xcccccccdL), -1, INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(0.5L, 0x3ffe, 0x80000000L, 0x00000000L), 0, INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-0.5L, 0xbffe, 0x80000000L, 0x00000000L), -1, INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(0.8L, 0x3ffe, 0xccccccccL, 0xcccccccdL), 0, INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-0.8L, 0xbffe, 0xccccccccL, 0xcccccccdL), -1, INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(3.0L, 0x4000, 0xc0000000L, 0x00000000L), 3, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-3.0L, 0xc000, 0xc0000000L, 0x00000000L), -3, ROUND_DOWNWARD },

	{ __LINE__, HEXCONSTE(1.4L, 0x3fff, 0xb3333333L, 0x33333333L), 1, INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-1.4L, 0xbfff, 0xb3333333L, 0x33333333L), -2, INEXACT_EXCEPTION|ROUND_DOWNWARD },

	{ __LINE__, HEXCONSTE(8388600.3L, 0x4015, 0xfffff099L, 0x9999999aL), 8388600L, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-8388600.3L, 0xc015, 0xfffff099L, 0x9999999aL), -8388601L, ROUND_DOWNWARD },

	{ __LINE__, HEXCONSTE(1048576.0, 0x4013, 0x80000000L, 0x00000000L), 1048576L, NO_INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(1048576.4, 0x4013, 0x80000333L, 0x33333333L), 1048576L, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(1048576.5, 0x4013, 0x80000400L, 0x00000000L), 1048576L, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(1048576.6, 0x4013, 0x800004ccL, 0xcccccccdL), 1048576L, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(1048577.0, 0x4013, 0x80000800L, 0x00000000L), 1048577L, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(1048577.4, 0x4013, 0x80000b33L, 0x33333333L), 1048577L, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(1048577.5, 0x4013, 0x80000c00L, 0x00000000L), 1048577L, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(1048577.6, 0x4013, 0x80000cccL, 0xcccccccdL), 1048577L, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(1048578.0, 0x4013, 0x80001000L, 0x00000000L), 1048578L, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(1048578.4, 0x4013, 0x80001333L, 0x33333333L), 1048578L, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(1048578.5, 0x4013, 0x80001400L, 0x00000000L), 1048578L, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(1048578.6, 0x4013, 0x800014ccL, 0xcccccccdL), 1048578L, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(1048579.0, 0x4013, 0x80001800L, 0x00000000L), 1048579L, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(1048579.4, 0x4013, 0x80001b33L, 0x33333333L), 1048579L, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(1048579.5, 0x4013, 0x80001c00L, 0x00000000L), 1048579L, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(1048579.6, 0x4013, 0x80001cccL, 0xcccccccdL), 1048579L, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-1048576.0, 0xc013, 0x80000000L, 0x00000000L), -1048576L, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-1048576.4, 0xc013, 0x80000333L, 0x33333333L), -1048577L, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-1048576.5, 0xc013, 0x80000400L, 0x00000000L), -1048577L, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-1048576.6, 0xc013, 0x800004ccL, 0xcccccccdL), -1048577L, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-1048577.0, 0xc013, 0x80000800L, 0x00000000L), -1048577L, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-1048577.4, 0xc013, 0x80000b33L, 0x33333333L), -1048578L, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-1048577.5, 0xc013, 0x80000c00L, 0x00000000L), -1048578L, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-1048577.6, 0xc013, 0x80000cccL, 0xcccccccdL), -1048578L, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-1048578.0, 0xc013, 0x80001000L, 0x00000000L), -1048578L, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-1048578.4, 0xc013, 0x80001333L, 0x33333333L), -1048579L, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-1048578.5, 0xc013, 0x80001400L, 0x00000000L), -1048579L, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-1048578.6, 0xc013, 0x800014ccL, 0xcccccccdL), -1048579L, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-1048579.0, 0xc013, 0x80001800L, 0x00000000L), -1048579L, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-1048579.4, 0xc013, 0x80001b33L, 0x33333333L), -1048580L, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-1048579.5, 0xc013, 0x80001c00L, 0x00000000L), -1048580L, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-1048579.6, 0xc013, 0x80001cccL, 0xcccccccdL), -1048580L, ROUND_DOWNWARD },

#ifndef TEST_FLOAT
	{ __LINE__, HEXCONSTE(1071930.0008, 0x4013, 0x82d9d001L, 0xa36e2eb2L), 1071930L, ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(1073741824.01, 0x401d, 0x80000000L, 0x051eb852L), 1073741824L, ROUND_DOWNWARD },
# if LONG_MAX > 281474976710656L
	{ __LINE__, HEXCONSTE(281474976710656.025L, 0x402f, 0x80000000L, 0x00000333L), 281474976710656L, ROUND_DOWNWARD },
# endif
#endif

	{ __LINE__, HEXCONSTE(0.0, 0x0000, 0x00000000L, 0x00000000L), 0, NO_INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, ZERO_M, 0, NO_INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(0.2L, 0x3ffc, 0xccccccccL, 0xcccccccdL), 1, INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-0.2L, 0xbffc, 0xccccccccL, 0xcccccccdL), 0, INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(0.5L, 0x3ffe, 0x80000000L, 0x00000000L), 1, INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-0.5L, 0xbffe, 0x80000000L, 0x00000000L), 0, INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(0.8L, 0x3ffe, 0xccccccccL, 0xcccccccdL), 1, INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-0.8L, 0xbffe, 0xccccccccL, 0xcccccccdL), 0, INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(3.0L, 0x4000, 0xc0000000L, 0x00000000L), 3, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-3.0L, 0xc000, 0xc0000000L, 0x00000000L), -3, ROUND_UPWARD },

	{ __LINE__, HEXCONSTE(1.4L, 0x3fff, 0xb3333333L, 0x33333333L), 2, INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-1.4L, 0xbfff, 0xb3333333L, 0x33333333L), -1, INEXACT_EXCEPTION|ROUND_UPWARD },

	{ __LINE__, HEXCONSTE(8388600.3L, 0x4015, 0xfffff099L, 0x9999999aL), 8388601L, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-8388600.3L, 0xc015, 0xfffff099L, 0x9999999aL), -8388600L, ROUND_UPWARD },

	{ __LINE__, HEXCONSTE(1048576.0, 0x4013, 0x80000000L, 0x00000000L), 1048576L, NO_INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(1048576.4, 0x4013, 0x80000333L, 0x33333333L), 1048577L, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(1048576.5, 0x4013, 0x80000400L, 0x00000000L), 1048577L, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(1048576.6, 0x4013, 0x800004ccL, 0xcccccccdL), 1048577L, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(1048577.0, 0x4013, 0x80000800L, 0x00000000L), 1048577L, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(1048577.4, 0x4013, 0x80000b33L, 0x33333333L), 1048578L, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(1048577.5, 0x4013, 0x80000c00L, 0x00000000L), 1048578L, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(1048577.6, 0x4013, 0x80000cccL, 0xcccccccdL), 1048578L, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(1048578.0, 0x4013, 0x80001000L, 0x00000000L), 1048578L, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(1048578.4, 0x4013, 0x80001333L, 0x33333333L), 1048579L, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(1048578.5, 0x4013, 0x80001400L, 0x00000000L), 1048579L, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(1048578.6, 0x4013, 0x800014ccL, 0xcccccccdL), 1048579L, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(1048579.0, 0x4013, 0x80001800L, 0x00000000L), 1048579L, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(1048579.4, 0x4013, 0x80001b33L, 0x33333333L), 1048580L, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(1048579.5, 0x4013, 0x80001c00L, 0x00000000L), 1048580L, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(1048579.6, 0x4013, 0x80001cccL, 0xcccccccdL), 1048580L, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-1048576.0, 0xc013, 0x80000000L, 0x00000000L), -1048576L, NO_INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-1048576.4, 0xc013, 0x80000333L, 0x33333333L), -1048576L, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-1048576.5, 0xc013, 0x80000400L, 0x00000000L), -1048576L, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-1048576.6, 0xc013, 0x800004ccL, 0xcccccccdL), -1048576L, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-1048577.0, 0xc013, 0x80000800L, 0x00000000L), -1048577L, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-1048577.4, 0xc013, 0x80000b33L, 0x33333333L), -1048577L, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-1048577.5, 0xc013, 0x80000c00L, 0x00000000L), -1048577L, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-1048577.6, 0xc013, 0x80000cccL, 0xcccccccdL), -1048577L, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-1048578.0, 0xc013, 0x80001000L, 0x00000000L), -1048578L, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-1048578.4, 0xc013, 0x80001333L, 0x33333333L), -1048578L, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-1048578.5, 0xc013, 0x80001400L, 0x00000000L), -1048578L, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-1048578.6, 0xc013, 0x800014ccL, 0xcccccccdL), -1048578L, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-1048579.0, 0xc013, 0x80001800L, 0x00000000L), -1048579L, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-1048579.4, 0xc013, 0x80001b33L, 0x33333333L), -1048579L, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-1048579.5, 0xc013, 0x80001c00L, 0x00000000L), -1048579L, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-1048579.6, 0xc013, 0x80001cccL, 0xcccccccdL), -1048579L, ROUND_UPWARD },

#ifndef TEST_FLOAT
	{ __LINE__, HEXCONSTE(1071930.0008, 0x4013, 0x82d9d001L, 0xa36e2eb2L), 1071931L, ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(1073741824.01, 0x401d, 0x80000000L, 0x051eb852L), 1073741825L, ROUND_UPWARD },
#ifdef TEST_LDOUBLE
# if LONG_MAX > 281474976710656
	{ __LINE__, HEXCONSTE(281474976710656.025L, 0x402f, 0x80000000L, 0x00000333L), 281474976710657L, ROUND_UPWARD },
# endif
#endif
#endif
#endif
};


int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_f_l(lrint_data, ARRAY_SIZE(lrint_data), __FILE__);
	(void)check_fp;

	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

#else

int main(void)
{
	return 77;
}

#endif

```

`tests/lround.c`:

```c
#include "testconfig.h"
#define TEST_FUNC_F_L __MATH_PRECNAME(lround)
#include "testdriver.h"


static test_f_l_data const lround_data[] = {
	{ __LINE__, QNAN_P, LONG_MIN, FLAG_FAIL_SOFTFLOAT|FLAG_FAIL_HARDFLOAT },
	{ __LINE__, QNAN_M, LONG_MIN, FLAG_FAIL_HARDFLOAT },
	{ __LINE__, SNAN_P, LONG_MIN, FLAG_FAIL_SOFTFLOAT|FLAG_FAIL_HARDFLOAT },
	{ __LINE__, SNAN_M, LONG_MIN, FLAG_FAIL_HARDFLOAT },
	{ __LINE__, INF_P, LONG_MIN, FLAG_FAIL_SOFTFLOAT|FLAG_XFAIL },
	{ __LINE__, INF_M, LONG_MIN, FLAG_FAIL_SOFTFLOAT|FLAG_XFAIL },
	{ __LINE__, ZERO_P, 0, 0 },
	{ __LINE__, ZERO_M, 0, 0 },
	{ __LINE__, SUBNORM_P, 0, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, 0, FLAG_SUBNORM },
	{ __LINE__, MIN_P, 0, 0 },
	{ __LINE__, MIN_M, 0, 0 },
	{ __LINE__, MAX_P, LONG_MIN, 0 },
	{ __LINE__, MAX_M, LONG_MIN, 0 },

	{ __LINE__, HEXCONSTE(4.5, 0x4001, 0x90000000L, 0x00000000L), 5, 0 },
	{ __LINE__, HEXCONSTE(3.5, 0x4000, 0xe0000000L, 0x00000000L), 4, 0 },
	{ __LINE__, HEXCONSTE(2.5, 0x4000, 0xa0000000L, 0x00000000L), 3, 0 },
	{ __LINE__, HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), 2, 0 },
	{ __LINE__, HEXCONSTE(1.5, 0x3fff, 0xc0000000L, 0x00000000L), 2, 0 },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 1, 0 },
	{ __LINE__, HEXCONSTE(0.5, 0x3ffe, 0x80000000L, 0x00000000L), 1, 0 },
	{ __LINE__, HEXCONSTE(-0.5, 0xbffe, 0x80000000L, 0x00000000L), -1, 0 },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), -1, 0 },
	{ __LINE__, HEXCONSTE(-1.5, 0xbfff, 0xc0000000L, 0x00000000L), -2, 0 },
	{ __LINE__, HEXCONSTE(-2.0, 0xc000, 0x80000000L, 0x00000000L), -2, 0 },
	{ __LINE__, HEXCONSTE(-2.5, 0xc000, 0xa0000000L, 0x00000000L), -3, 0 },
	{ __LINE__, HEXCONSTE(-3.5, 0xc000, 0xe0000000L, 0x00000000L), -4, 0 },
	{ __LINE__, HEXCONSTE(-4.5, 0xc001, 0x90000000L, 0x00000000L), -5, 0 },
	{ __LINE__, HEXCONSTE(0.1, 0x3ffb, 0xccccccccL, 0xcccccccdL), 0, 0 },
	{ __LINE__, HEXCONSTE(0.25, 0x3ffd, 0x80000000L, 0x00000000L), 0, 0 },
	{ __LINE__, HEXCONSTE(0.625, 0x3ffe, 0xa0000000L, 0x00000000L), 1, 0 },
	{ __LINE__, HEXCONSTE(-0.1, 0xbffb, 0xccccccccL, 0xcccccccdL), 0, 0 },
	{ __LINE__, HEXCONSTE(-0.25, 0xbffd, 0x80000000L, 0x00000000L), 0, 0 },
	{ __LINE__, HEXCONSTE(-0.625, 0xbffe, 0xa0000000L, 0x00000000L), -1, 0 },
	{ __LINE__, HEXCONSTE(22514.5, 0x400d, 0xafe50000L, 0x00000000L), 22515, 0 },
	{ __LINE__, HEXCONSTE(-22514.5, 0xc00d, 0xafe50000L, 0x00000000L), -22515, 0 },
	{ __LINE__, HEXCONSTE(262144.75, 0x4011, 0x80001800L, 0x00000000L), 262145L, 0 },
	{ __LINE__, HEXCONSTE(262142.75, 0x4010, 0xffffb000L, 0x00000000L), 262143L, 0 },
	{ __LINE__, HEXCONSTE(524286.75, 0x4011, 0xffffd800L, 0x00000000L), 524287L, 0 },
	{ __LINE__, HEXCONSTE(524288.75, 0x4012, 0x80000c00L, 0x00000000L), 524289L, 0 },
	{ __LINE__, HEXCONSTE(1048576.75, 0x4013, 0x80000600L, 0x00000000L), 1048577L, 0 },
	{ __LINE__, HEXCONSTE(1071930.0008, 0x4013, 0x82d9d001L, 0xa36e2eb2L), 1071930L, 0 },
	{ __LINE__, HEXCONSTE(2097152.75, 0x4014, 0x80000300L, 0x00000000L), 2097153L, 0 },
	{ __LINE__, HEXCONSTE(2492472.75, 0x4014, 0x9820e300L, 0x00000000L), 2492473L, 0 },
	{ __LINE__, HEXCONSTE(2886220.75, 0x4014, 0xb0293300L, 0x00000000L), 2886221L, 0 },
	{ __LINE__, HEXCONSTE(3058792.75, 0x4014, 0xbab1a300L, 0x00000000L), 3058793L, 0 },
	{ __LINE__, HEXCONSTE(-1048576.75, 0xc013, 0x80000600L, 0x00000000L), -1048577L, 0 },
	{ __LINE__, HEXCONSTE(-2097152.75, 0xc014, 0x80000300L, 0x00000000L), -2097153L, 0 },
	{ __LINE__, HEXCONSTE(-2492472.75, 0xc014, 0x9820e300L, 0x00000000L), -2492473L, 0 },
	{ __LINE__, HEXCONSTE(-2886220.75, 0xc014, 0xb0293300L, 0x00000000L), -2886221L, 0 },
	{ __LINE__, HEXCONSTE(-3058792.75, 0xc014, 0xbab1a300L, 0x00000000L), -3058793L, 0 },
	{ __LINE__, HEXCONSTE(1073741824.01, 0x401d, 0x80000000L, 0x051eb852L), 1073741824L, 0 },

	{ __LINE__, HEXCONSTE(8.38860800000000000000e+06, 0x4016, 0x80000000L, 0x00000000L), 8388608L, 0 },
	{ __LINE__, HEXCONSTE(1.67772160000000000000e+07, 0x4017, 0x80000000L, 0x00000000L), 16777216L, 0 },
	{ __LINE__, HEXCONSTE(3.35544320000000000000e+07, 0x4018, 0x80000000L, 0x00000000L), 33554432L, 0 },
	{ __LINE__, HEXCONSTE(-8.38860800000000000000e+06, 0xc016, 0x80000000L, 0x00000000L), -8388608L, 0 },
	{ __LINE__, HEXCONSTE(-1.67772160000000000000e+07, 0xc017, 0x80000000L, 0x00000000L), -16777216L, 0 },
	{ __LINE__, HEXCONSTE(-3.35544320000000000000e+07, 0xc018, 0x80000000L, 0x00000000L), -33554432L, 0 },

#if LONG_MAX > 2147483647L
	{ __LINE__, HEXCONSTE(70368744177664.75, 0x402d, 0x80000000L, 0x00018000L), 70368744177665L, 0 },
	{ __LINE__, HEXCONSTE(140737488355328.75, 0x402e, 0x80000000L, 0x0000c000L), 140737488355329L, 0 },
	{ __LINE__, HEXCONSTE(281474976710656.75, 0x402f, 0x80000000L, 0x00006000L), 281474976710657L, 0 },
	{ __LINE__, HEXCONSTE(562949953421312.75, 0x4030, 0x80000000L, 0x00003000L), 562949953421313L, 0 },
	{ __LINE__, HEXCONSTE(1125899906842624.75, 0x4031, 0x80000000L, 0x00001800L), 1125899906842625L, 0 },
	{ __LINE__, HEXCONSTE(-70368744177664.75, 0xc02d, 0x80000000L, 0x00018000L), -70368744177665L, 0 },
	{ __LINE__, HEXCONSTE(-140737488355328.75, 0xc02e, 0x80000000L, 0x0000c000L), -140737488355329L, 0 },
	{ __LINE__, HEXCONSTE(-281474976710656.75, 0xc02f, 0x80000000L, 0x00006000L), -281474976710657L, 0 },
	{ __LINE__, HEXCONSTE(-562949953421312.75, 0xc030, 0x80000000L, 0x00003000L), -562949953421313L, 0 },
	{ __LINE__, HEXCONSTE(-1125899906842624.75, 0xc031, 0x80000000L, 0x00001800L), -1125899906842625L, 0 },

	{ __LINE__, HEXCONSTE(4.50359962737049600000e+15, 0x4033, 0x80000000L, 0x00000000L), 4503599627370496L, 0 },
	{ __LINE__, HEXCONSTE(9.00719925474099200000e+15, 0x4034, 0x80000000L, 0x00000000L), 9007199254740992L, 0 },
	{ __LINE__, HEXCONSTE(1.80143985094819840000e+16, 0x4035, 0x80000000L, 0x00000000L), 18014398509481984L, 0 },
	{ __LINE__, HEXCONSTE(-4.50359962737049600000e+15, 0xc033, 0x80000000L, 0x00000000L), -4503599627370496L, 0 },
	{ __LINE__, HEXCONSTE(-9.00719925474099200000e+15, 0xc034, 0x80000000L, 0x00000000L), -9007199254740992L, 0 },
	{ __LINE__, HEXCONSTE(-1.80143985094819840000e+16, 0xc035, 0x80000000L, 0x00000000L), -18014398509481984, 0 },

	{ __LINE__, HEXCONSTE(281474976710656.025, 0x402f, 0x80000000L, 0x00000333L), 281474976710656L, 0 },
	{ __LINE__, HEXCONSTE(18014398509481974, 0x4034, 0xffffffffL, 0xffffd800L), 18014398509481974L, 0 },
#endif

	{ __LINE__, HEXCONSTE(0.2, 0x3ffc, 0xccccccccL, 0xcccccccdL), 0, 0 },
	{ __LINE__, HEXCONSTE(-0.2, 0xbffc, 0xccccccccL, 0xcccccccdL), 0, 0 },
	{ __LINE__, HEXCONSTE(0.5, 0x3ffe, 0x80000000L, 0x00000000L), 1, 0 },
	{ __LINE__, HEXCONSTE(-0.5, 0xbffe, 0x80000000L, 0x00000000L), -1, 0 },
	{ __LINE__, HEXCONSTE(0.8, 0x3ffe, 0xccccccccL, 0xcccccccdL), 1, 0 },
	{ __LINE__, HEXCONSTE(-0.8, 0xbffe, 0xccccccccL, 0xcccccccdL), -1, 0 },
	{ __LINE__, HEXCONSTE(1.5, 0x3fff, 0xc0000000L, 0x00000000L), 2, 0 },
	{ __LINE__, HEXCONSTE(-1.5, 0xbfff, 0xc0000000L, 0x00000000L), -2, 0 },
	{ __LINE__, HEXCONSTE(0.1, 0x3ffb, 0xccccccccL, 0xcccccccdL), 0, 0 },
	{ __LINE__, HEXCONSTE(0.25, 0x3ffd, 0x80000000L, 0x00000000L), 0, 0 },
	{ __LINE__, HEXCONSTE(0.625, 0x3ffe, 0xa0000000L, 0x00000000L), 1, 0 },
	{ __LINE__, HEXCONSTE(-0.1, 0xbffb, 0xccccccccL, 0xcccccccdL), 0, 0 },
	{ __LINE__, HEXCONSTE(-0.25, 0xbffd, 0x80000000L, 0x00000000L), 0, 0 },
	{ __LINE__, HEXCONSTE(-0.625, 0xbffe, 0xa0000000L, 0x00000000L), -1, 0 },
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(2097152.5, 0x4014, 0x80000200L, 0x00000000L), 2097153L, 0 },
	{ __LINE__, HEXCONSTE(-2097152.5, 0xc014, 0x80000200L, 0x00000000L), -2097153L, 0 },
#endif

	{ __LINE__, HEXCONSTE(-4.45015e-308, 0xbc02, 0x8000044dL, 0xb01f4deeL), 0, 0 },
};


int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_f_l(lround_data, ARRAY_SIZE(lround_data), __FILE__);
	(void)check_fp;

	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

```

`tests/modf.c`:

```c
#include "testconfig.h"
#define TEST_FUNC_F_FFP __MATH_PRECNAME(modf)
#include "testdriver.h"


static test_f_ffp_data const modf_data[] = {
	{ __LINE__, ZERO_P, ZERO_P, ZERO_P, 0 },
	{ __LINE__, ZERO_M, ZERO_M, ZERO_M, FLAG_FAIL_ARANYM2|FLAG_FAIL_HARDFLOAT },
	{ __LINE__, INF_P, ZERO_P, INF_P, NO_INEXACT_EXCEPTION|FLAG_FAIL_ARANYM|FLAG_FAIL_HARDFLOAT }, /* not handled by inline version in math-68881.h */
	{ __LINE__, INF_M, ZERO_M, INF_M, NO_INEXACT_EXCEPTION|FLAG_FAIL_ARANYM|FLAG_FAIL_HARDFLOAT }, /* not handled by inline version in math-68881.h */
	{ __LINE__, QNAN_P, QNAN_P, QNAN_P, NO_INEXACT_EXCEPTION|FLAG_XFAIL },

	{ __LINE__, HEXCONSTE(0.000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(0.000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(0.000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(0.000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(2.000000e+00, 0x4000, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.000000e+00, 0x4001, 0x80000000L, 0x00000000L), HEXCONSTE(0.000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(4.000000e+00, 0x4001, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(8.000000e+00, 0x4002, 0x80000000L, 0x00000000L), HEXCONSTE(0.000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(8.000000e+00, 0x4002, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.560000e+02, 0x4007, 0x80000000L, 0x00000000L), HEXCONSTE(0.000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(2.560000e+02, 0x4007, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.276800e+04, 0x400e, 0x80000000L, 0x00000000L), HEXCONSTE(0.000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(3.276800e+04, 0x400e, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.000000e+00, 0xbfff, 0x80000000L, 0x00000000L), ZERO_M, HEXCONSTE(-1.000000e+00, 0xbfff, 0x80000000L, 0x00000000L), FLAG_IGNORE_ZEROSIGN },
	{ __LINE__, HEXCONSTE(-2.000000e+00, 0xc000, 0x80000000L, 0x00000000L), ZERO_M, HEXCONSTE(-2.000000e+00, 0xc000, 0x80000000L, 0x00000000L), FLAG_IGNORE_ZEROSIGN },
	{ __LINE__, HEXCONSTE(-4.000000e+00, 0xc001, 0x80000000L, 0x00000000L), ZERO_M, HEXCONSTE(-4.000000e+00, 0xc001, 0x80000000L, 0x00000000L), FLAG_IGNORE_ZEROSIGN },
	{ __LINE__, HEXCONSTE(-8.000000e+00, 0xc002, 0x80000000L, 0x00000000L), ZERO_M, HEXCONSTE(-8.000000e+00, 0xc002, 0x80000000L, 0x00000000L), FLAG_IGNORE_ZEROSIGN },
	{ __LINE__, HEXCONSTE(-2.560000e+02, 0xc007, 0x80000000L, 0x00000000L), ZERO_M, HEXCONSTE(-2.560000e+02, 0xc007, 0x80000000L, 0x00000000L), FLAG_IGNORE_ZEROSIGN },
	{ __LINE__, HEXCONSTE(-3.276800e+04, 0xc00e, 0x80000000L, 0x00000000L), ZERO_M, HEXCONSTE(-3.276800e+04, 0xc00e, 0x80000000L, 0x00000000L), FLAG_IGNORE_ZEROSIGN },
#ifdef TEST_LDOUBLE
	{ __LINE__, HEXCONSTE(1.234500e+00, 0x3fff, 0x9e041893L, 0x74bc6a7fL), HEXCONSTE(2.345000e-01, 0x3ffc, 0xf020c49bL, 0xa5e353f8L), HEXCONSTE(1.000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, HEXCONSTE(1.234500e+10, 0x4020, 0xb7f47010L, 0x00000000L), HEXCONSTE(0.000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.234500e+10, 0x4020, 0xb7f47010L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.456700e+20, 0x4043, 0x95e9144cL, 0x7eaa3800L), HEXCONSTE(0.000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(3.456700e+20, 0x4043, 0x95e9144cL, 0x7eaa3800L), 0 },
	{ __LINE__, HEXCONSTE(3.456700e-05, 0x3ff0, 0x90fc089bL, 0xfd438487L), HEXCONSTE(3.456700e-05, 0x3ff0, 0x90fc089bL, 0xfd438487L), HEXCONSTE(0.000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#ifdef TEST_LDOUBLE
	{ __LINE__, HEXCONSTE(-1.234500e+00, 0xbfff, 0x9e041893L, 0x74bc6a7fL), HEXCONSTE(-2.345000e-01, 0xbffc, 0xf020c49bL, 0xa5e353f8L), HEXCONSTE(-1.000000e+00, 0xbfff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-1.234500e+10, 0xc020, 0xb7f47010L, 0x00000000L), ZERO_M, HEXCONSTE(-1.234500e+10, 0xc020, 0xb7f47010L, 0x00000000L), FLAG_IGNORE_ZEROSIGN },
	{ __LINE__, HEXCONSTE(-3.456700e+20, 0xc043, 0x95e9144cL, 0x7eaa3800L), ZERO_M, HEXCONSTE(-3.456700e+20, 0xc043, 0x95e9144cL, 0x7eaa3800L), FLAG_IGNORE_ZEROSIGN },
	{ __LINE__, HEXCONSTE(-3.456700e-05, 0xbff0, 0x90fc089bL, 0xfd438487L), HEXCONSTE(-3.456700e-05, 0xbff0, 0x90fc089bL, 0xfd438487L), ZERO_M, FLAG_IGNORE_ZEROSIGN },
	
	{ __LINE__, HEXCONSTE(1.5, 0x3fff, 0xc0000000L, 0x00000000L), HEXCONSTE(0.5, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.5, 0x4000, 0xa0000000L, 0x00000000L), HEXCONSTE(0.5, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(2, 0x4000, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-2.5, 0xc000, 0xa0000000L, 0x00000000L), HEXCONSTE(-0.5, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(-2, 0xc000, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(20, 0x4003, 0xa0000000L, 0x00000000L), HEXCONSTE(0, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(20, 0x4003, 0xa0000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(21, 0x4003, 0xa8000000L, 0x00000000L), HEXCONSTE(0, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(21, 0x4003, 0xa8000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(89.5, 0x4005, 0xb3000000L, 0x00000000L), HEXCONSTE(0.5, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(89, 0x4005, 0xb2000000L, 0x00000000L), 0 },
};


int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_f_ffp(modf_data, ARRAY_SIZE(modf_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

```

`tests/nearby.c`:

```c
#include "testconfig.h"
#if defined(HAVE_NEARBYINT)
#define TEST_FUNC_F_F __MATH_PRECNAME(nearbyint)
#include "testdriver.h"



static test_f_f_data const nearbyint_data[] = {
	{ __LINE__, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_P, 0 },
	{ __LINE__, SNAN_P, QNAN_P, 0 },
	{ __LINE__, SNAN_M, QNAN_P, 0 },
	{ __LINE__, INF_P, INF_P, 0 },
	{ __LINE__, INF_M, INF_M, 0 },
	{ __LINE__, ZERO_P, ZERO_P, 0 },
	{ __LINE__, ZERO_M, ZERO_M, FLAG_IGNORE_ZEROSIGN },
	{ __LINE__, SUBNORM_P, ZERO_P, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, ZERO_M, FLAG_SUBNORM },
	{ __LINE__, MIN_P, ZERO_P, 0 },
	{ __LINE__, MIN_M, ZERO_M, 0 },
	{ __LINE__, MAX_P, MAX_P, 0 },
	{ __LINE__, MAX_M, MAX_M, 0 },
	
	/* Subnormal values */
	{ __LINE__, HEXCONSTE(-8.98847e+307, 0xc3fe, 0x80000409L, 0x7954f717L), HEXCONSTE(-8.98847e+307, 0xc3fe, 0x80000409L, 0x7954f717L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-4.45015e-308, 0xbc02, 0x8000044dL, 0xb01f4deeL), ZERO_M, NO_INEXACT_EXCEPTION|FLAG_IGNORE_ZEROSIGN },

	/* Default rounding mode is round to nearest.  */
	{ __LINE__, HEXCONSTE(0.5, 0x3ffe, 0x80000000L, 0x00000000L), ZERO_P, NO_INEXACT_EXCEPTION|FLAG_FAIL_ARANYM }, /* FIXME: x86 used round-to-odd */
	{ __LINE__, HEXCONSTE(1.5, 0x3fff, 0xc0000000L, 0x00000000L), HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-0.5, 0xbffe, 0x80000000L, 0x00000000L), ZERO_M, NO_INEXACT_EXCEPTION|FLAG_FAIL_ARANYM }, /* FIXME: x86 used round-to-odd */
	{ __LINE__, HEXCONSTE(-1.5, 0xbfff, 0xc0000000L, 0x00000000L), HEXCONSTE(-2.0, 0xc000, 0x80000000L, 0x00000000L), NO_INEXACT_EXCEPTION },

	{ __LINE__, HEXCONSTE(262144.75, 0x4011, 0x80001800L, 0x00000000L), HEXCONSTE(262145.0, 0x4011, 0x80002000L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(262142.75, 0x4010, 0xffffb000L, 0x00000000L), HEXCONSTE(262143.0, 0x4010, 0xffffc000L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(524286.75, 0x4011, 0xffffd800L, 0x00000000L), HEXCONSTE(524287.0, 0x4011, 0xffffe000L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(524288.75, 0x4012, 0x80000c00L, 0x00000000L), HEXCONSTE(524289.0, 0x4012, 0x80001000L, 0x00000000L), NO_INEXACT_EXCEPTION },

	{ __LINE__, HEXCONSTE(1048576.75, 0x4013, 0x80000600L, 0x00000000L), HEXCONSTE(1048577.0, 0x4013, 0x80000800L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(2097152.75, 0x4014, 0x80000300L, 0x00000000L), HEXCONSTE(2097153.0, 0x4014, 0x80000400L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(2492472.75, 0x4014, 0x9820e300L, 0x00000000L), HEXCONSTE(2492473.0, 0x4014, 0x9820e400L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(2886220.75, 0x4014, 0xb0293300L, 0x00000000L), HEXCONSTE(2886221.0, 0x4014, 0xb0293400L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(3058792.75, 0x4014, 0xbab1a300L, 0x00000000L), HEXCONSTE(3058793.0, 0x4014, 0xbab1a400L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-1048576.75, 0xc013, 0x80000600L, 0x00000000L), HEXCONSTE(-1048577.0, 0xc013, 0x80000800L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-2097152.75, 0xc014, 0x80000300L, 0x00000000L), HEXCONSTE(-2097153.0, 0xc014, 0x80000400L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-2492472.75, 0xc014, 0x9820e300L, 0x00000000L), HEXCONSTE(-2492473.0, 0xc014, 0x9820e400L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-2886220.75, 0xc014, 0xb0293300L, 0x00000000L), HEXCONSTE(-2886221.0, 0xc014, 0xb0293400L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-3058792.75, 0xc014, 0xbab1a300L, 0x00000000L), HEXCONSTE(-3058793.0, 0xc014, 0xbab1a400L, 0x00000000L), NO_INEXACT_EXCEPTION },
#ifndef TEST_FLOAT
	{ __LINE__, HEXCONSTE(70368744177664.75, 0x402d, 0x80000000L, 0x00018000L), HEXCONSTE(70368744177665.0, 0x402d, 0x80000000L, 0x00020000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(140737488355328.75, 0x402e, 0x80000000L, 0x0000c000L), HEXCONSTE(140737488355329.0, 0x402e, 0x80000000L, 0x00010000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(281474976710656.75, 0x402f, 0x80000000L, 0x00006000L), HEXCONSTE(281474976710657.0, 0x402f, 0x80000000L, 0x00008000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(562949953421312.75, 0x4030, 0x80000000L, 0x00003000L), HEXCONSTE(562949953421313.0, 0x4030, 0x80000000L, 0x00004000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1125899906842624.75, 0x4031, 0x80000000L, 0x00001800L), HEXCONSTE(1125899906842625.0, 0x4031, 0x80000000L, 0x00002000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-70368744177664.75, 0xc02d, 0x80000000L, 0x00018000L), HEXCONSTE(-70368744177665.0, 0xc02d, 0x80000000L, 0x00020000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-140737488355328.75, 0xc02e, 0x80000000L, 0x0000c000L), HEXCONSTE(-140737488355329.0, 0xc02e, 0x80000000L, 0x00010000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-281474976710656.75, 0xc02f, 0x80000000L, 0x00006000L), HEXCONSTE(-281474976710657.0, 0xc02f, 0x80000000L, 0x00008000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-562949953421312.75, 0xc030, 0x80000000L, 0x00003000L), HEXCONSTE(-562949953421313.0, 0xc030, 0x80000000L, 0x00004000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-1125899906842624.75, 0xc031, 0x80000000L, 0x00001800L), HEXCONSTE(-1125899906842625.0, 0xc031, 0x80000000L, 0x00002000L), NO_INEXACT_EXCEPTION },
#endif
};


int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_f_f(nearbyint_data, ARRAY_SIZE(nearbyint_data), __FILE__);

	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

#else

int main(void)
{
	return 77;
}

#endif

```

`tests/nextaf.c`:

```c
#include "testconfig.h"
#ifdef HAVE_NEXTAFTER
#define TEST_FUNC_FF_F __MATH_PRECNAME(nextafter)
#include "testdriver.h"


static test_ff_f_data const nextafter_data[] = {
	{ __LINE__, ZERO_P, ZERO_P, ZERO_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_M, ZERO_P, ZERO_P, NO_INEXACT_EXCEPTION|FLAG_FAIL_SOFTFLOAT|FLAG_FAIL_HARDFLOAT },
	{ __LINE__, ZERO_P, ZERO_M, ZERO_M, NO_INEXACT_EXCEPTION|FLAG_FAIL_SOFTFLOAT|FLAG_FAIL_HARDFLOAT },
	{ __LINE__, ZERO_M, ZERO_M, ZERO_M, NO_INEXACT_EXCEPTION|FLAG_FAIL_ARANYM2 },

	{ __LINE__, HEXCONSTE(9, 0x4002, 0x90000000L, 0x00000000L), HEXCONSTE(9, 0x4002, 0x90000000L, 0x00000000L), HEXCONSTE(9, 0x4002, 0x90000000L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-9, 0xc002, 0x90000000L, 0x00000000L), HEXCONSTE(-9, 0xc002, 0x90000000L, 0x00000000L), HEXCONSTE(-9, 0xc002, 0x90000000L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, INF_P, INF_P, INF_P, NO_INEXACT_EXCEPTION|FLAG_FAIL_ARANYM2 },
	{ __LINE__, INF_M, INF_M, INF_M, NO_INEXACT_EXCEPTION|FLAG_FAIL_ARANYM2 },

	{ __LINE__, QNAN_P, HEXCONSTE(1.1L, 0x3fff, 0x8cccccccL, 0xcccccccdL), QNAN_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.1L, 0x3fff, 0x8cccccccL, 0xcccccccdL), QNAN_P, QNAN_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_P, QNAN_P, QNAN_P, NO_INEXACT_EXCEPTION },

	{ __LINE__, MAX_P, INF_P, INF_P, INEXACT_EXCEPTION|OVERFLOW_EXCEPTION },
	{ __LINE__, MAX_M, INF_M, INF_M, INEXACT_EXCEPTION|OVERFLOW_EXCEPTION },
};

int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_ff_f(nextafter_data, ARRAY_SIZE(nextafter_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

#else

int main(void)
{
	return 77;
}

#endif

```

`tests/nextto.c`:

```c
#include "testconfig.h"
#ifdef HAVE_NEXTTOWARD
#define TEST_FUNC_FFL_F __MATH_PRECNAME(nexttoward)
#include "testdriver.h"

#define FP_FLT_MAX_P HEXCONSTE(3.4028234663852885981170e+38, 0x407e, 0xffffff00L, 0x00000000L)
#define FP_FLT_MAX_M HEXCONSTE(-3.4028234663852885981170e+38, 0xc07e, 0xffffff00L, 0x00000000L)
#define FP_FLT_MIN_P HEXCONSTE(1.1754943508222875e-38, 0x3f80, 0xffffffffL, 0xffffff83L)
#define FP_FLT_MIN_M HEXCONSTE(-1.1754943508222875e-38, 0xbf80, 0xffffffffL, 0xffffff83L)


/* FIXME: 2nd arg always long double */
static test_ff_f_data const nexttoward_data[] = {
	{ __LINE__, ZERO_P, ZERO_P, ZERO_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_M, ZERO_P, ZERO_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_P, ZERO_M, ZERO_M, NO_INEXACT_EXCEPTION|FLAG_IGNORE_ZEROSIGN },
	{ __LINE__, ZERO_M, ZERO_M, ZERO_M, NO_INEXACT_EXCEPTION|FLAG_IGNORE_ZEROSIGN },
	{ __LINE__, ZERO_P, INF_P, ZERO_P, UNDERFLOW_EXCEPTION|FLAG_FAIL_SOFTFLOAT|FLAG_FAIL_ARANYM }, /* fails because of bug in __truncxfdf2 */
	{ __LINE__, ZERO_P, INF_M, ZERO_M, UNDERFLOW_EXCEPTION|FLAG_FAIL_SOFTFLOAT|FLAG_FAIL_ARANYM }, /* fails because of bug in __truncxfdf2 */
	{ __LINE__, ZERO_M, INF_P, ZERO_M, UNDERFLOW_EXCEPTION|FLAG_FAIL_SOFTFLOAT|FLAG_FAIL_ARANYM }, /* fails because of bug in __truncxfdf2 */
	{ __LINE__, ZERO_M, INF_M, ZERO_M, UNDERFLOW_EXCEPTION|FLAG_FAIL_SOFTFLOAT|FLAG_FAIL_ARANYM }, /* fails because of bug in __truncxfdf2 */

	{ __LINE__, HEXCONSTE(9, 0x4002, 0x90000000L, 0x00000000L), HEXCONSTE(9, 0x4002, 0x90000000L, 0x00000000L), HEXCONSTE(9, 0x4002, 0x90000000L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-9, 0xc002, 0x90000000L, 0x00000000L), HEXCONSTE(-9, 0xc002, 0x90000000L, 0x00000000L), HEXCONSTE(-9, 0xc002, 0x90000000L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, INF_P, INF_P, INF_P, NO_INEXACT_EXCEPTION|FLAG_FAIL_SOFTFLOAT }, /* fails because of bug in __truncxfdf2 */
	{ __LINE__, INF_M, INF_M, INF_M, NO_INEXACT_EXCEPTION|FLAG_FAIL_SOFTFLOAT }, /* fails because of bug in __truncxfdf2 */

	{ __LINE__, QNAN_P, HEXCONSTE(1.1L, 0x3fff, 0x8cccccccL, 0xcccccccdL), QNAN_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.1L, 0x3fff, 0x8cccccccL, 0xcccccccdL), QNAN_P, QNAN_P, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_P, QNAN_P, QNAN_P, NO_INEXACT_EXCEPTION },

#ifdef TEST_FLOAT
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.1L, 0x3fff, 0x8cccccccL, 0xcccccccdL), HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), MAX_P, HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.9L, 0x3ffe, 0xe6666666L, 0x66666666L), HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), MAX_M, 0x0.ffffffp0, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.1L, 0xbfff, 0x8cccccccL, 0xcccccccdL), HEXCONSTE(-1.00000011920928955078e+00, 0xbfff, 0x80000100L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), MAX_M, HEXCONSTE(-1.00000011920928955078e+00, 0xbfff, 0x80000100L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.00000000000000022204e+00, 0xbfff, 0x80000000L, 0x00000800L), HEXCONSTE(-1.00000011920928955078e+00, 0xbfff, 0x80000100L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-0.9L, 0xbffe, 0xe6666666L, 0x66666666L), HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), MAX_P, HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-9.99999999999999888978e-01, 0xbffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-2.66246708221715243476e-44, 0xbf6e, 0x98000000L, 0x00000000L), HEXCONSTE(-2.80259692864963414185e-44, 0xbf6e, 0xa0000000L, 0x00000000L), HEXCONSTE(-2.80259692864963414185e-44, 0xbf6e, 0xa0000000L, 0x00000000L), INEXACT_EXCEPTION|UNDERFLOW_EXCEPTION },
	{ __LINE__, FP_FLT_MAX_P, HEXCONSTE(6.8056471355946732327508e+38, 0x407f, 0xffffff80L, 0x00000000L), INF_P, OVERFLOW_EXCEPTION },
	{ __LINE__, FP_FLT_MAX_M, HEXCONSTE(-6.8056471355946732327508e+38, 0xc07f, 0xffffff80L, 0x00000000L), INF_M, OVERFLOW_EXCEPTION },
	{ __LINE__, FP_FLT_MIN_P, ZERO_P, ZERO_P, UNDERFLOW_EXCEPTION },
	{ __LINE__, FP_FLT_MIN_M, ZERO_M, ZERO_M, UNDERFLOW_EXCEPTION },
# if LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000173e+00, 0x3fff, 0x80000000L, 0x00000010L), HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.00000000000000000173e+00, 0xbfff, 0x80000000L, 0x00000010L), HEXCONSTE(-1.00000011920928955078e+00, 0xbfff, 0x80000100L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-9.99999999999999999946e-01, 0xbffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), NO_INEXACT_EXCEPTION },
# endif
#endif
#ifdef TEST_DOUBLE
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.1L, 0x3fff, 0x8cccccccL, 0xcccccccdL), HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), MAX_P, HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.9L, 0x3ffe, 0xe6666666L, 0x66666666L), HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), MAX_P, HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.1L, 0xbfff, 0x8cccccccL, 0xcccccccdL), HEXCONSTE(-1.00000000000000022204e+00, 0xbfff, 0x80000000L, 0x00000800L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), MAX_M, HEXCONSTE(-1.00000000000000022204e+00, 0xbfff, 0x80000000L, 0x00000800L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.00000000000000022204e+00, 0xbfff, 0x80000000L, 0x00000800L), HEXCONSTE(-1.00000000000000022204e+00, 0xbfff, 0x80000000L, 0x00000800L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-0.9L, 0xbffe, 0xe6666666L, 0x66666666L), HEXCONSTE(-9.99999999999999888978e-01, 0xbffe, 0xffffffffL, 0xfffff800L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), MAX_P, HEXCONSTE(-9.99999999999999888978e-01, 0xbffe, 0xffffffffL, 0xfffff800L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-9.99999999999999888978e-01, 0xbffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-9.99999999999999888978e-01, 0xbffe, 0xffffffffL, 0xfffff800L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.00009999999999998899e+00, 0xbfff, 0x800346dcL, 0x5d638800L), HEXCONSTE(-1.00000000000000022204e+00, 0xbfff, 0x80000000L, 0x00000800L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(9.88131291682493088353e-324, 0x3bce, 0x80000000L, 0x00000000L), HEXCONSTE(9.88131291682493088353e-324, 0x3bce, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION|UNDERFLOW_EXCEPTION },
# if LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000173e+00, 0x3fff, 0x80000000L, 0x00000010L), HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), NO_INEXACT_EXCEPTION|FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.00000000000000000173e+00, 0xbfff, 0x80000000L, 0x00000010L), HEXCONSTE(-1.00000000000000022204e+00, 0xbfff, 0x80000000L, 0x00000800L), NO_INEXACT_EXCEPTION|FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-9.99999999999999999946e-01, 0xbffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-9.99999999999999888978e-01, 0xbffe, 0xffffffffL, 0xfffff800L), NO_INEXACT_EXCEPTION },
# endif
#if DBL_MAX_EXP != LDBL_MAX_EXP
	{ __LINE__, HEXCONSTE(-1.7976931348623157081453e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.7986931348623157080845e+308, 0x43ff, 0x80123a51L, 0x6e82d5baL), INF_P, OVERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(-1.7976931348623157081453e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.7986931348623157080845e+308, 0xc3ff, 0x80123a51L, 0x6e82d5baL), INF_M, OVERFLOW_EXCEPTION },
#endif
	{ __LINE__, HEXCONSTE(2.2250738585072013830902e-308, 0x3c01, 0x80000000L, 0x00000000L), ZERO_P, ZERO_P, UNDERFLOW_EXCEPTION|FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(-2.2250738585072013830902e-308, 0xbc01, 0x80000000L, 0x00000000L), ZERO_M, ZERO_M, UNDERFLOW_EXCEPTION|FLAG_SUBNORM },
#endif
#ifdef TEST_LDOUBLE
	{ __LINE__, MAX_P, INF_P, INF_P, OVERFLOW_EXCEPTION },
	{ __LINE__, MAX_M, INF_M, INF_M, OVERFLOW_EXCEPTION },
	{ __LINE__, MIN_P, ZERO_P, ZERO_P, UNDERFLOW_EXCEPTION },
	{ __LINE__, MIN_M, ZERO_M, ZERO_M, UNDERFLOW_EXCEPTION },
#endif
};

int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_ffl_f(nexttoward_data, ARRAY_SIZE(nexttoward_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

#else

int main(void)
{
	return 77;
}

#endif

```

`tests/pow.c`:

```c
#include "testconfig.h"
#define TEST_FUNC_FF_F __MATH_PRECNAME(pow)
#include "testdriver.h"


static test_ff_f_data const fpow_data[] = {
	/* If y is 0, the result is 1.0 (even if x is a NaN). */
	{ __LINE__,  QNAN_P, ZERO_P, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), FLAG_FAIL_HARDFLOAT|FLAG_FAIL_ARANYM }, /* glibc returns NaN */
	{ __LINE__,  QNAN_M, ZERO_P, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), FLAG_FAIL_HARDFLOAT|FLAG_FAIL_ARANYM }, /* glibc returns NaN */
	{ __LINE__,  QNAN_P, ZERO_M, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), FLAG_FAIL_HARDFLOAT|FLAG_FAIL_ARANYM }, /* glibc returns NaN */
	{ __LINE__,  QNAN_M, ZERO_M, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), FLAG_FAIL_HARDFLOAT|FLAG_FAIL_ARANYM }, /* glibc returns NaN */
	{ __LINE__,  ZERO_P, ZERO_P, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), FLAG_FAIL_HARDFLOAT|FLAG_FAIL_ARANYM }, /* glibc returns NaN */
	{ __LINE__,  ZERO_M, ZERO_P, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), FLAG_FAIL_HARDFLOAT|FLAG_FAIL_ARANYM }, /* glibc returns NaN */
	{ __LINE__,  ZERO_P, ZERO_M, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), FLAG_FAIL_HARDFLOAT|FLAG_FAIL_ARANYM }, /* glibc returns NaN */
	{ __LINE__,  ZERO_M, ZERO_M, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), FLAG_FAIL_HARDFLOAT|FLAG_FAIL_ARANYM }, /* glibc returns NaN */

	{ __LINE__,  SNAN_P, ZERO_P, QNAN_P, FLAG_FAIL_SOFTFLOAT },
	{ __LINE__,  SNAN_M, ZERO_P, QNAN_P, FLAG_FAIL_SOFTFLOAT },
	{ __LINE__,  SNAN_P, ZERO_M, QNAN_P, FLAG_FAIL_SOFTFLOAT },
	{ __LINE__,  SNAN_M, ZERO_M, QNAN_P, FLAG_FAIL_SOFTFLOAT },
	
	/* If the absolute value of x is greater than 1, and y is positive infinity, the result is positive infinity. */
	{ __LINE__,  HEXCONSTE(1.1L, 0x3fff, 0x8cccccccL, 0xcccccccdL), INF_P, INF_P, FLAG_FAIL_ARANYM }, /* returns zero */
	{ __LINE__,  INF_P, INF_P, INF_P, FLAG_FAIL_ARANYM }, /* glibc returns NaN */
	{ __LINE__,  HEXCONSTE(-1.1L, 0xbfff, 0x8cccccccL, 0xcccccccdL), INF_P, INF_P, FLAG_FAIL_ARANYM }, /* returns zero */
	{ __LINE__,  INF_M, INF_P, INF_P, FLAG_FAIL_ARANYM }, /* glibc returns NaN */
	
	/* If the absolute value of x is less than 1, and y is positive infinity, the result is +0. */
	{ __LINE__,  HEXCONSTE(0.9L, 0x3ffe, 0xe6666666L, 0x66666666L), INF_P, ZERO_P, FLAG_FAIL_ARANYM },
	{ __LINE__,  HEXCONSTE(1e-7L, 0x3fe7, 0xd6bf94d5L, 0xe57a42bcL), INF_P, ZERO_P, FLAG_FAIL_ARANYM }, /* inf treated as NaN? */
	{ __LINE__,  HEXCONSTE(-0.9L, 0xbffe, 0xe6666666L, 0x66666666L), INF_P, ZERO_P, FLAG_IGNORE_ZEROSIGN|FLAG_FAIL_ARANYM },
	{ __LINE__,  HEXCONSTE(-1e-7L, 0xbfe7, 0xd6bf94d5L, 0xe57a42bcL), INF_P, ZERO_P, FLAG_IGNORE_ZEROSIGN|FLAG_FAIL_ARANYM },
	
	/* If the absolute value of x is greater than 1, and y is negative infinity, the result is +0. */
	{ __LINE__,  HEXCONSTE(1.1L, 0x3fff, 0x8cccccccL, 0xcccccccdL), INF_M, ZERO_P, FLAG_FAIL_ARANYM }, /* inf treated as NaN? */
	{ __LINE__,  INF_P, INF_M, ZERO_P, FLAG_FAIL_ARANYM }, /* glibc returns NaN */
	{ __LINE__,  HEXCONSTE(-1.1L, 0xbfff, 0x8cccccccL, 0xcccccccdL), INF_M, ZERO_P, FLAG_FAIL_ARANYM }, /* inf treated as NaN? */
	{ __LINE__,  INF_M, INF_M, ZERO_P, FLAG_FAIL_ARANYM }, /* glibc returns NaN */
	
	/* If the absolute value of x is less than 1, and y is negative infinity, the result is positive infinity. */
	{ __LINE__,  HEXCONSTE(0.9L, 0x3ffe, 0xe6666666L, 0x66666666L), INF_M, INF_P, FLAG_FAIL_ARANYM }, /* returns zero */
	{ __LINE__,  HEXCONSTE(1e-7L, 0x3fe7, 0xd6bf94d5L, 0xe57a42bcL), INF_M, INF_P, FLAG_FAIL_ARANYM }, /* returns zero */
	{ __LINE__,  HEXCONSTE(-0.9L, 0xbffe, 0xe6666666L, 0x66666666L), INF_M, INF_P, FLAG_FAIL_ARANYM }, /* returns zero */
	{ __LINE__,  HEXCONSTE(-1e-7L, 0xbfe7, 0xd6bf94d5L, 0xe57a42bcL), INF_M, INF_P, FLAG_FAIL_ARANYM }, /* returns zero */
	
	/* If x is positive infinity, and y greater than 0, the result is positive infinity. */
	{ __LINE__,  INF_P, HEXCONSTE(1e-7L, 0x3fe7, 0xd6bf94d5L, 0xe57a42bcL), INF_P, FLAG_FAIL_ARANYM }, /* returns zero */
	{ __LINE__,  INF_P, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), INF_P, FLAG_FAIL_ARANYM }, /* returns zero */
	{ __LINE__,  INF_P, HEXCONSTE(1e7L, 0x4016, 0x98968000L, 0x00000000L), INF_P, FLAG_FAIL_ARANYM }, /* returns zero */
	{ __LINE__,  INF_P, SUBNORM_P, INF_P, FLAG_SUBNORM },
	
	/* If x is positive infinity, and y less than 0, the result is +0. */
	{ __LINE__,  INF_P, HEXCONSTE(-1e-7L, 0xbfe7, 0xd6bf94d5L, 0xe57a42bcL), ZERO_P, FLAG_FAIL_ARANYM }, /* inf treated as NaN? */
	{ __LINE__,  INF_P, HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), ZERO_P, FLAG_FAIL_ARANYM }, /* inf treated as NaN? */
	{ __LINE__,  INF_P, HEXCONSTE(-1e7L, 0xc016, 0x98968000L, 0x00000000L), ZERO_P, FLAG_FAIL_ARANYM }, /* inf treated as NaN? */
	{ __LINE__,  INF_P, SUBNORM_M, ZERO_P, FLAG_SUBNORM },
	
	/* If x is negative infinity, and y is an odd integer greater than 0, the result is negative infinity. */
	{ __LINE__,  INF_M, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), INF_M, FLAG_FAIL_ARANYM }, /* returns zero */
	{ __LINE__,  INF_M, HEXCONSTE(11, 0x4002, 0xb0000000L, 0x00000000L), INF_M, FLAG_FAIL_ARANYM }, /* returns zero */
	{ __LINE__,  INF_M, HEXCONSTE(1001, 0x4008, 0xfa400000L, 0x00000000L), INF_M, FLAG_FAIL_ARANYM }, /* returns zero */
	
	/* If x is negative infinity, and y greater than 0 and not an odd integer, the result is positive infinity. */
	{ __LINE__,  INF_M, HEXCONSTE(2, 0x4000, 0x80000000L, 0x00000000L), INF_P, FLAG_FAIL_ARANYM }, /* returns zero */
	{ __LINE__,  INF_M, HEXCONSTE(12, 0x4002, 0xc0000000L, 0x00000000L), INF_P, FLAG_FAIL_ARANYM }, /* returns zero */
	{ __LINE__,  INF_M, HEXCONSTE(1002, 0x4008, 0xfa800000L, 0x00000000L), INF_P, FLAG_FAIL_ARANYM }, /* returns zero */
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  INF_M, HEXCONSTE(0.1L, 0x3ffb, 0xccccccccL, 0xcccccccdL), INF_P, FLAG_FAIL_ARANYM }, /* returns zero */
	{ __LINE__,  INF_M, HEXCONSTE(1.1L, 0x3fff, 0x8cccccccL, 0xcccccccdL), INF_P, FLAG_FAIL_ARANYM }, /* returns zero */
	{ __LINE__,  INF_M, HEXCONSTE(11.1L, 0x4002, 0xb1999999L, 0x9999999aL), INF_P, FLAG_FAIL_ARANYM }, /* returns zero */
	{ __LINE__,  INF_M, HEXCONSTE(1001.1L, 0x4008, 0xfa466666L, 0x66666666L), INF_P, FLAG_FAIL_ARANYM }, /* returns zero */
#endif
	{ __LINE__,  INF_M, SUBNORM_P, INF_P, FLAG_SUBNORM },
	
	/* If x is negative infinity, and y is an odd integer less than 0, the result is -0. */
	{ __LINE__,  INF_M, HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), ZERO_M, FLAG_FAIL_SOFTFLOAT|FLAG_FAIL_ARANYM }, /* returns +zero */
	{ __LINE__,  INF_M, HEXCONSTE(-11, 0xc002, 0xb0000000L, 0x00000000L), ZERO_M, FLAG_FAIL_ARANYM }, /* returns NaN */
	{ __LINE__,  INF_M, HEXCONSTE(-1001, 0xc008, 0xfa400000L, 0x00000000L), ZERO_M, FLAG_FAIL_ARANYM }, /* returns NaN */

	/* If x is negative infinity, and y less than 0 and not an odd integer, the result is +0. */
	{ __LINE__,  INF_M, HEXCONSTE(-2, 0xc000, 0x80000000L, 0x00000000L), ZERO_P, FLAG_FAIL_ARANYM }, /* inf treated as NaN? */
	{ __LINE__,  INF_M, HEXCONSTE(-12, 0xc002, 0xc0000000L, 0x00000000L), ZERO_P, FLAG_FAIL_ARANYM }, /* inf treated as NaN? */
	{ __LINE__,  INF_M, HEXCONSTE(-1002, 0xc008, 0xfa800000L, 0x00000000L), ZERO_P, FLAG_FAIL_ARANYM }, /* inf treated as NaN? */
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  INF_M, HEXCONSTE(-0.1L, 0xbffb, 0xccccccccL, 0xcccccccdL), ZERO_P, FLAG_FAIL_ARANYM }, /* returns NaN */
	{ __LINE__,  INF_M, HEXCONSTE(-1.1L, 0xbfff, 0x8cccccccL, 0xcccccccdL), ZERO_P, FLAG_FAIL_ARANYM }, /* returns NaN */
	{ __LINE__,  INF_M, HEXCONSTE(-11.1L, 0xc002, 0xb1999999L, 0x9999999aL), ZERO_P, FLAG_FAIL_ARANYM }, /* returns NaN */
	{ __LINE__,  INF_M, HEXCONSTE(-1001.1L, 0xc008, 0xfa466666L, 0x66666666L), ZERO_P, FLAG_FAIL_ARANYM }, /* returns NaN */
	{ __LINE__,  INF_M, SUBNORM_M, ZERO_P, FLAG_SUBNORM },
#endif

	{ __LINE__,  QNAN_P, QNAN_P, QNAN_P, 0 },
	{ __LINE__,  QNAN_P, QNAN_M, QNAN_P, 0 },
	{ __LINE__,  QNAN_M, QNAN_P, QNAN_P, 0 },
	{ __LINE__,  QNAN_M, QNAN_M, QNAN_P, 0 },
	{ __LINE__,  QNAN_P, SNAN_P, QNAN_P, 0 },
	{ __LINE__,  QNAN_P, SNAN_M, QNAN_P, 0 },
	{ __LINE__,  QNAN_M, SNAN_P, QNAN_P, 0 },
	{ __LINE__,  QNAN_M, SNAN_M, QNAN_P, 0 },
	{ __LINE__,  SNAN_P, QNAN_P, QNAN_P, 0 },
	{ __LINE__,  SNAN_P, QNAN_M, QNAN_P, 0 },
	{ __LINE__,  SNAN_M, QNAN_P, QNAN_P, 0 },
	{ __LINE__,  SNAN_M, QNAN_M, QNAN_P, 0 },
	{ __LINE__,  SNAN_P, SNAN_P, QNAN_P, 0 },
	{ __LINE__,  SNAN_P, SNAN_M, QNAN_P, 0 },
	{ __LINE__,  SNAN_M, SNAN_P, QNAN_P, 0 },
	{ __LINE__,  SNAN_M, SNAN_M, QNAN_P, 0 },
	{ __LINE__,  ZERO_P, QNAN_P, QNAN_P, 0 },
	{ __LINE__,  ZERO_P, QNAN_M, QNAN_P, 0 },
	{ __LINE__,  ZERO_P, SNAN_P, QNAN_P, 0 },
	{ __LINE__,  ZERO_P, SNAN_M, QNAN_P, 0 },
	
	/* If x is +1, the result is 1.0 (even if y is a NaN) */
	{ __LINE__,  HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), QNAN_P, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), FLAG_FAIL_ARANYM }, /* returns NaN */
	{ __LINE__,  HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), QNAN_M, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), FLAG_FAIL_ARANYM }, /* returns NaN */
	{ __LINE__,  HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), SNAN_P, QNAN_P, FLAG_FAIL_SOFTFLOAT },
	{ __LINE__,  HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), SNAN_M, QNAN_P, FLAG_FAIL_SOFTFLOAT },

	{ __LINE__,  HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), QNAN_P, QNAN_P, 0 },
	{ __LINE__,  HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), QNAN_M, QNAN_P, 0 },
	{ __LINE__,  HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), SNAN_P, QNAN_P, 0 },
	{ __LINE__,  HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), SNAN_M, QNAN_P, 0 },
	{ __LINE__,  QNAN_P, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__,  QNAN_M, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__,  SNAN_P, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__,  SNAN_M, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__,  QNAN_P, HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__,  QNAN_M, HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__,  SNAN_P, HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__,  SNAN_M, HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), QNAN_P, 0 },

	/*  pow (x, qNaN or sNaN) == qNaN.  */
	{ __LINE__,  HEXCONSTE(3.0, 0x4000, 0xc0000000L, 0x00000000L), QNAN_P, QNAN_P, 0 },
	{ __LINE__,  HEXCONSTE(3.0, 0x4000, 0xc0000000L, 0x00000000L), QNAN_M, QNAN_P, 0 },
	{ __LINE__,  ZERO_M, QNAN_P, QNAN_P, 0 },
	{ __LINE__,  ZERO_M, QNAN_M, QNAN_P, 0 },
	{ __LINE__,  INF_P, QNAN_P, QNAN_P, 0 },
	{ __LINE__,  INF_P, QNAN_M, QNAN_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.0, 0xc000, 0xc0000000L, 0x00000000L), QNAN_P, QNAN_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.0, 0xc000, 0xc0000000L, 0x00000000L), QNAN_M, QNAN_P, 0 },
	{ __LINE__,  INF_M, QNAN_P, QNAN_P, 0 },
	{ __LINE__,  INF_M, QNAN_M, QNAN_P, 0 },
	{ __LINE__,  HEXCONSTE(3.0, 0x4000, 0xc0000000L, 0x00000000L), SNAN_P, QNAN_P, 0 },
	{ __LINE__,  HEXCONSTE(3.0, 0x4000, 0xc0000000L, 0x00000000L), SNAN_M, QNAN_P, 0 },
	{ __LINE__,  ZERO_M, SNAN_P, QNAN_P, 0 },
	{ __LINE__,  ZERO_M, SNAN_M, QNAN_P, 0 },
	{ __LINE__,  INF_P, SNAN_P, QNAN_P, 0 },
	{ __LINE__,  INF_P, SNAN_M, QNAN_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.0, 0xc000, 0xc0000000L, 0x00000000L), SNAN_P, QNAN_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.0, 0xc000, 0xc0000000L, 0x00000000L), SNAN_M, QNAN_P, 0 },
	{ __LINE__,  INF_M, SNAN_P, QNAN_P, 0 },
	{ __LINE__,  INF_M, SNAN_M, QNAN_P, 0 },

	{ __LINE__,  QNAN_P, HEXCONSTE(3.0, 0x4000, 0xc0000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__,  QNAN_M, HEXCONSTE(3.0, 0x4000, 0xc0000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__,  QNAN_P, HEXCONSTE(-3.0, 0xc000, 0xc0000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__,  QNAN_M, HEXCONSTE(-3.0, 0xc000, 0xc0000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__,  QNAN_P, INF_P, QNAN_P, 0 },
	{ __LINE__,  QNAN_M, INF_P, QNAN_P, 0 },
	{ __LINE__,  QNAN_P, INF_M, QNAN_P, 0 },
	{ __LINE__,  QNAN_M, INF_M, QNAN_P, 0 },
	{ __LINE__,  QNAN_P, HEXCONSTE(2.5, 0x4000, 0xa0000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__,  QNAN_M, HEXCONSTE(2.5, 0x4000, 0xa0000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__,  QNAN_P, HEXCONSTE(-2.5, 0xc000, 0xa0000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__,  QNAN_M, HEXCONSTE(-2.5, 0xc000, 0xa0000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__,  QNAN_P, SUBNORM_P, QNAN_P, FLAG_SUBNORM },
	{ __LINE__,  QNAN_M, SUBNORM_P, QNAN_P, FLAG_SUBNORM },
	{ __LINE__,  QNAN_P, SUBNORM_M, QNAN_P, FLAG_SUBNORM },
	{ __LINE__,  QNAN_M, SUBNORM_M, QNAN_P, FLAG_SUBNORM },
	{ __LINE__,  SNAN_P, HEXCONSTE(3.0, 0x4000, 0xc0000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__,  SNAN_M, HEXCONSTE(3.0, 0x4000, 0xc0000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__,  SNAN_P, HEXCONSTE(-3.0, 0xc000, 0xc0000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__,  SNAN_M, HEXCONSTE(-3.0, 0xc000, 0xc0000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__,  SNAN_P, INF_P, QNAN_P, 0 },
	{ __LINE__,  SNAN_M, INF_P, QNAN_P, 0 },
	{ __LINE__,  SNAN_P, INF_M, QNAN_P, 0 },
	{ __LINE__,  SNAN_M, INF_M, QNAN_P, 0 },
	{ __LINE__,  SNAN_P, HEXCONSTE(2.5, 0x4000, 0xa0000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__,  SNAN_M, HEXCONSTE(2.5, 0x4000, 0xa0000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__,  SNAN_P, HEXCONSTE(-2.5, 0xc000, 0xa0000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__,  SNAN_M, HEXCONSTE(-2.5, 0xc000, 0xa0000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__,  SNAN_P, SUBNORM_P, QNAN_P, FLAG_SUBNORM },
	{ __LINE__,  SNAN_M, SUBNORM_P, QNAN_P, FLAG_SUBNORM },
	{ __LINE__,  SNAN_P, SUBNORM_M, QNAN_P, FLAG_SUBNORM },
	{ __LINE__,  SNAN_M, SUBNORM_M, QNAN_P, FLAG_SUBNORM },

	{ __LINE__,  HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), INF_P, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), FLAG_FAIL_SOFTFLOAT|FLAG_FAIL_HARDFLOAT|FLAG_FAIL_ARANYM }, /* returns NaN */
	{ __LINE__,  HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), INF_P, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), FLAG_FAIL_SOFTFLOAT|FLAG_FAIL_HARDFLOAT|FLAG_FAIL_ARANYM }, /* returns NaN */
	{ __LINE__,  HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), INF_M, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), FLAG_FAIL_SOFTFLOAT|FLAG_FAIL_HARDFLOAT|FLAG_FAIL_ARANYM }, /* returns NaN */
	{ __LINE__,  HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), INF_M, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), FLAG_FAIL_SOFTFLOAT|FLAG_FAIL_HARDFLOAT|FLAG_FAIL_ARANYM }, /* returns NaN */

	/*  pow (x, +-0) == 1.  */
	{ __LINE__,  INF_P, ZERO_P, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), FLAG_FAIL_HARDFLOAT|FLAG_FAIL_ARANYM }, /* glibc returns NaN */
	{ __LINE__,  INF_P, ZERO_M, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), FLAG_FAIL_HARDFLOAT|FLAG_FAIL_ARANYM }, /* glibc returns NaN */
	{ __LINE__,  INF_M, ZERO_P, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), FLAG_FAIL_HARDFLOAT|FLAG_FAIL_ARANYM }, /* glibc returns NaN */
	{ __LINE__,  INF_M, ZERO_M, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), FLAG_FAIL_HARDFLOAT|FLAG_FAIL_ARANYM }, /* glibc returns NaN */

	{ __LINE__,  HEXCONSTE(-0.1L, 0xbffb, 0xccccccccL, 0xcccccccdL), HEXCONSTE(1.1L, 0x3fff, 0x8cccccccL, 0xcccccccdL), QNAN_P, 0 },
	{ __LINE__,  HEXCONSTE(-0.1L, 0xbffb, 0xccccccccL, 0xcccccccdL), HEXCONSTE(-1.1L, 0xbfff, 0x8cccccccL, 0xcccccccdL), QNAN_P, 0 },
	{ __LINE__,  HEXCONSTE(-10.1L, 0xc002, 0xa1999999L, 0x9999999aL), HEXCONSTE(1.1L, 0x3fff, 0x8cccccccL, 0xcccccccdL), QNAN_P, 0 },
	{ __LINE__,  HEXCONSTE(-10.1L, 0xc002, 0xa1999999L, 0x9999999aL), HEXCONSTE(-1.1L, 0xbfff, 0x8cccccccL, 0xcccccccdL), QNAN_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.01L, 0xbfff, 0x8147ae14L, 0x7ae147aeL), SUBNORM_P, QNAN_P, FLAG_SUBNORM },
	{ __LINE__,  HEXCONSTE(-1.01L, 0xbfff, 0x8147ae14L, 0x7ae147aeL), SUBNORM_M, QNAN_P, FLAG_SUBNORM },
	{ __LINE__,  HEXCONSTE(-1.0L, 0xbfff, 0x80000000L, 0x00000000L), SUBNORM_P, QNAN_P, FLAG_SUBNORM },
	{ __LINE__,  HEXCONSTE(-1.0L, 0xbfff, 0x80000000L, 0x00000000L), SUBNORM_M, QNAN_P, FLAG_SUBNORM },

#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  ZERO_P, HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), INF_P, FLAG_FAIL_ARANYM }, /* returns NaN */
	{ __LINE__,  ZERO_P, HEXCONSTE(-11, 0xc002, 0xb0000000L, 0x00000000L), INF_P, FLAG_FAIL_ARANYM }, /* returns NaN */
	{ __LINE__,  ZERO_P, HEXCONSTE(-1.67772150000000000000e+07, 0xc016, 0xffffff00L, 0x00000000L), INF_P, FLAG_FAIL_ARANYM }, /* returns NaN */
	{ __LINE__,  ZERO_P, HEXCONSTE(-9.00719925474099100000e+15, 0xc033, 0xffffffffL, 0xfffff800L), INF_P, FLAG_FAIL_ARANYM }, /* returns NaN */
	{ __LINE__,  ZERO_P, HEXCONSTE(-1.84467440737095516150e+19, 0xc03e, 0xffffffffL, 0xffffffffL), INF_P, FLAG_FAIL_ARANYM }, /* returns NaN */
	{ __LINE__,  ZERO_M, HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), INF_M, FLAG_FAIL_ARANYM }, /* returns NaN */
	{ __LINE__,  ZERO_M, HEXCONSTE(-11L, 0xc002, 0xb0000000L, 0x00000000L), INF_M, FLAG_FAIL_ARANYM }, /* returns NaN */
	{ __LINE__,  ZERO_M, HEXCONSTE(-1.67772150000000000000e+07, 0xc016, 0xffffff00L, 0x00000000L), INF_M, FLAG_FAIL_ARANYM }, /* returns NaN */
	{ __LINE__,  ZERO_M, HEXCONSTE(-3.35544300000000000000e+07, 0xc017, 0xffffff00L, 0x00000000L), INF_P, FLAG_FAIL_ARANYM }, /* returns NaN */
	{ __LINE__,  ZERO_M, HEXCONSTE(-9.00719925474099100000e+15, 0xc033, 0xffffffffL, 0xfffff800L), INF_M, FLAG_FAIL_ARANYM }, /* returns NaN */
	{ __LINE__,  ZERO_M, HEXCONSTE(-1.80143985094819820000e+16, 0xc034, 0xffffffffL, 0xfffff800L), INF_P, FLAG_FAIL_ARANYM }, /* returns NaN */
	{ __LINE__,  ZERO_M, HEXCONSTE(-1.84467440737095516150e+19, 0xc03e, 0xffffffffL, 0xffffffffL), INF_M, FLAG_FAIL_ARANYM }, /* returns NaN */
	{ __LINE__,  ZERO_M, HEXCONSTE(-3.68934881474191032300e+19, 0xc03f, 0xffffffffL, 0xffffffffL), INF_P, FLAG_FAIL_ARANYM }, /* returns NaN */
#endif

#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  ZERO_P, HEXCONSTE(-2, 0xc000, 0x80000000L, 0x00000000L), INF_P, FLAG_FAIL_ARANYM }, /* returns NaN */
	{ __LINE__,  ZERO_P, HEXCONSTE(-11.1L, 0xc002, 0xb1999999L, 0x9999999aL), INF_P, FLAG_FAIL_ARANYM }, /* returns NaN */
#endif
	{ __LINE__,  ZERO_P, SUBNORM_M, INF_P, FLAG_SUBNORM },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  ZERO_P, HEXCONSTE(-1.67772160000000000000e+07, 0xc017, 0x80000000L, 0x00000000L), INF_P, FLAG_FAIL_ARANYM }, /* returns NaN */
	{ __LINE__,  ZERO_P, HEXCONSTE(-1.70141183460469231732e+38, 0xc07e, 0x80000000L, 0x00000000L), INF_P, FLAG_FAIL_ARANYM }, /* returns NaN */
#endif
	{ __LINE__,  ZERO_P, MAX_M, INF_P, 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  ZERO_M, HEXCONSTE(-2, 0xc000, 0x80000000L, 0x00000000L), INF_P, FLAG_FAIL_ARANYM }, /* returns NaN */
	{ __LINE__,  ZERO_M, HEXCONSTE(-11.1L, 0xc002, 0xb1999999L, 0x9999999aL), INF_P, FLAG_FAIL_ARANYM }, /* returns NaN */
#endif
	{ __LINE__,  ZERO_M, SUBNORM_M, INF_P, FLAG_SUBNORM },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  ZERO_M, HEXCONSTE(-1.67772160000000000000e+07, 0xc017, 0x80000000L, 0x00000000L), INF_P, FLAG_FAIL_ARANYM }, /* returns NaN */
	{ __LINE__,  ZERO_M, HEXCONSTE(-1.70141183460469231732e+38, 0xc07e, 0x80000000L, 0x00000000L), INF_P, FLAG_FAIL_ARANYM }, /* returns NaN */
#endif
	{ __LINE__,  ZERO_M, MAX_M, INF_P, 0 },

	/* If the absolute value of x is less than 1, and y is positive infinity, the result is +0 */
	{ __LINE__,  ZERO_P, INF_P, ZERO_P, 0 },
	{ __LINE__,  ZERO_M, INF_P, ZERO_P, 0 },
	
	/* If the absolute value of x is less than 1, and y is negative infinity, the result is positive infinity. */
	{ __LINE__,  ZERO_P, INF_M, INF_P, FLAG_FAIL_ARANYM|FLAG_FAIL_HARDFLOAT }, /* glibc returns NaN */
	{ __LINE__,  ZERO_M, INF_M, INF_P, FLAG_FAIL_ARANYM|FLAG_FAIL_HARDFLOAT }, /* glibc returns NaN */

	/*  pow (x, +inf) == +inf for |x| > 1.  */
	{ __LINE__,  HEXCONSTE(1.5, 0x3fff, 0xc0000000L, 0x00000000L), INF_P, INF_P, FLAG_FAIL_ARANYM }, /* returns zero */

	/*  pow (x, +inf) == +0 for |x| < 1.  */
	{ __LINE__,  HEXCONSTE(0.5, 0x3ffe, 0x80000000L, 0x00000000L), INF_P, ZERO_P, FLAG_FAIL_ARANYM }, /* inf treated as NaN? */

	/*  pow (x, -inf) == +0 for |x| > 1.  */
	{ __LINE__,  HEXCONSTE(1.5, 0x3fff, 0xc0000000L, 0x00000000L), INF_M, ZERO_P, FLAG_FAIL_ARANYM }, /* inf treated as NaN? */

	/*  pow (x, -inf) == +inf for |x| < 1.  */
	{ __LINE__,  HEXCONSTE(0.5, 0x3ffe, 0x80000000L, 0x00000000L), INF_M, INF_P, FLAG_FAIL_ARANYM }, /* returns zero */

	/*  pow (+inf, y) == +inf for y > 0.  */
	{ __LINE__,  INF_P, HEXCONSTE(2, 0x4000, 0x80000000L, 0x00000000L), INF_P, FLAG_FAIL_ARANYM },
	{ __LINE__,  INF_P, HEXCONSTE(1.67772150000000000000e+07, 0x4016, 0xffffff00L, 0x00000000L), INF_P, FLAG_FAIL_ARANYM },
	{ __LINE__,  INF_P, HEXCONSTE(9.00719925474099100000e+15, 0x4033, 0xffffffffL, 0xfffff800L), INF_P, FLAG_FAIL_ARANYM },
	{ __LINE__,  INF_P, HEXCONSTE(1.84467440737095516150e+19, 0x403e, 0xffffffffL, 0xffffffffL), INF_P, FLAG_FAIL_ARANYM },
	{ __LINE__,  INF_P, HEXCONSTE(1.67772160000000000000e+07, 0x4017, 0x80000000L, 0x00000000L), INF_P, FLAG_FAIL_ARANYM },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  INF_P, HEXCONSTE(1.70141183460469231732e+38, 0x407e, 0x80000000L, 0x00000000L), INF_P, 0 },
#endif
	{ __LINE__,  INF_P, MAX_P, INF_P, 0 },

	/*  pow (+inf, y) == +0 for y < 0.  */
	{ __LINE__,  INF_P, HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), ZERO_P, FLAG_FAIL_ARANYM }, /* inf treated as NaN? */
	{ __LINE__,  INF_P, HEXCONSTE(-1.67772150000000000000e+07, 0xc016, 0xffffff00L, 0x00000000L), ZERO_P, FLAG_FAIL_ARANYM }, /* inf treated as NaN? */
	{ __LINE__,  INF_P, HEXCONSTE(-9.00719925474099100000e+15, 0xc033, 0xffffffffL, 0xfffff800L), ZERO_P, FLAG_FAIL_ARANYM }, /* inf treated as NaN? */
	{ __LINE__,  INF_P, HEXCONSTE(-1.84467440737095516150e+19, 0xc03e, 0xffffffffL, 0xffffffffL), ZERO_P, FLAG_FAIL_ARANYM }, /* inf treated as NaN? */
	{ __LINE__,  INF_P, HEXCONSTE(-1.67772160000000000000e+07, 0xc017, 0x80000000L, 0x00000000L), ZERO_P, FLAG_FAIL_ARANYM }, /* inf treated as NaN? */
	{ __LINE__,  INF_P, HEXCONSTE(-1.70141183460469231732e+38, 0xc07e, 0x80000000L, 0x00000000L), ZERO_P, FLAG_FAIL_ARANYM }, /* inf treated as NaN? */
	{ __LINE__,  INF_P, MAX_M, ZERO_P, 0 },

	/*  pow (-inf, y) == -inf for y an odd integer > 0.  */
	{ __LINE__,  INF_M, HEXCONSTE(27, 0x4003, 0xd8000000L, 0x00000000L), INF_M, FLAG_FAIL_ARANYM },
	{ __LINE__,  INF_M, HEXCONSTE(1.67772150000000000000e+07, 0x4016, 0xffffff00L, 0x00000000L), INF_M, FLAG_FAIL_ARANYM },
	{ __LINE__,  INF_M, HEXCONSTE(3.35544300000000000000e+07, 0x4017, 0xffffff00L, 0x00000000L), INF_P, FLAG_FAIL_ARANYM },
	{ __LINE__,  INF_M, HEXCONSTE(9.00719925474099100000e+15, 0x4033, 0xffffffffL, 0xfffff800L), INF_M, FLAG_FAIL_ARANYM },
	{ __LINE__,  INF_M, HEXCONSTE(1.80143985094819820000e+16, 0x4034, 0xffffffffL, 0xfffff800L), INF_P, FLAG_FAIL_ARANYM },
	{ __LINE__,  INF_M, HEXCONSTE(1.84467440737095516150e+19, 0x403e, 0xffffffffL, 0xffffffffL), INF_M, FLAG_FAIL_ARANYM },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  INF_M, HEXCONSTE(3.68934881474191032300e+19, 0x403f, 0xffffffffL, 0xffffffffL), INF_P, 0 },
#endif

	/*  pow (-inf, y) == +inf for y > 0 and not an odd integer.  */
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  INF_M, HEXCONSTE(0.5, 0x3ffe, 0x80000000L, 0x00000000L), INF_P, FLAG_FAIL_ARANYM },
	{ __LINE__,  INF_M, HEXCONSTE(28, 0x4003, 0xe0000000L, 0x00000000L), INF_P, FLAG_FAIL_ARANYM },
	{ __LINE__,  INF_M, HEXCONSTE(1.67772160000000000000e+07, 0x4017, 0x80000000L, 0x00000000L), INF_P, FLAG_FAIL_ARANYM },
	{ __LINE__,  INF_M, HEXCONSTE(1.70141183460469231732e+38, 0x407e, 0x80000000L, 0x00000000L), INF_P, 0 },
#endif
	{ __LINE__,  INF_M, MAX_P, INF_P, 0 },

	/*  pow (-inf, y) == -0 for y an odd integer < 0. */
	{ __LINE__,  INF_M, HEXCONSTE(-3, 0xc000, 0xc0000000L, 0x00000000L), ZERO_M, FLAG_FAIL_ARANYM },
	{ __LINE__,  INF_M, HEXCONSTE(-1.67772150000000000000e+07, 0xc016, 0xffffff00L, 0x00000000L), ZERO_M, FLAG_FAIL_ARANYM }, /* inf treated as NaN? */
	{ __LINE__,  INF_M, HEXCONSTE(-3.35544300000000000000e+07, 0xc017, 0xffffff00L, 0x00000000L), ZERO_P, FLAG_FAIL_ARANYM }, /* inf treated as NaN? */
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  INF_M, HEXCONSTE(-9.00719925474099100000e+15, 0xc033, 0xffffffffL, 0xfffff800L), ZERO_M, FLAG_FAIL_ARANYM }, /* inf treated as NaN? */
#endif
	{ __LINE__,  INF_M, HEXCONSTE(-1.80143985094819820000e+16, 0xc034, 0xffffffffL, 0xfffff800L), ZERO_P, FLAG_FAIL_ARANYM }, /* inf treated as NaN? */
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  INF_M, HEXCONSTE(-1.84467440737095516150e+19, 0xc03e, 0xffffffffL, 0xffffffffL), ZERO_M, 0 },
#endif
	{ __LINE__,  INF_M, HEXCONSTE(-3.68934881474191032300e+19, 0xc03f, 0xffffffffL, 0xffffffffL), ZERO_P, FLAG_FAIL_ARANYM }, /* inf treated as NaN? */

	/*  pow (-inf, y) == +0 for y < 0 and not an odd integer.  */
	{ __LINE__,  INF_M, HEXCONSTE(-2.0, 0xc000, 0x80000000L, 0x00000000L), ZERO_P, FLAG_FAIL_ARANYM }, /* inf treated as NaN? */
	{ __LINE__,  INF_M, HEXCONSTE(-1.67772160000000000000e+07, 0xc017, 0x80000000L, 0x00000000L), ZERO_P, FLAG_FAIL_ARANYM }, /* inf treated as NaN? */
	{ __LINE__,  INF_M, HEXCONSTE(-1.70141183460469231732e+38, 0xc07e, 0x80000000L, 0x00000000L), ZERO_P, FLAG_FAIL_ARANYM }, /* inf treated as NaN? */
	{ __LINE__,  INF_M, MAX_M, ZERO_P, 0 },

	{ __LINE__,  MAX_M, HEXCONSTE(0.5, 0x3ffe, 0x80000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__,  MAX_M, HEXCONSTE(1.5, 0x3fff, 0xc0000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__,  MAX_M, HEXCONSTE(1000.5, 0x4008, 0xfa200000L, 0x00000000L), QNAN_P, 0 },

	{ __LINE__,  MIN_M, HEXCONSTE(0.5, 0x3ffe, 0x80000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__,  MIN_M, HEXCONSTE(1.5, 0x3fff, 0xc0000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__,  MIN_M, HEXCONSTE(1000.5, 0x4008, 0xfa200000L, 0x00000000L), QNAN_P, 0 },

	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+01, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+01, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+01, 0xc002, 0xa0000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+01, 0xc002, 0xa0000000L, 0x00000000L), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.25000000000000000000e+00, 0x3fff, 0xa0000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.25000000000000000000e+00, 0xbfff, 0xa0000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(4.61168601842738790400e+18, 0x403d, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(9.22337203685477580800e+18, 0x403e, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.84467440737095516160e+19, 0x403f, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(4.72236648286964521370e+21, 0x4047, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(3.27500000000000000000e+01, 0x4004, 0x83000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(3.27500000000000000000e+01, 0x4004, 0x83000000L, 0x00000000L), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.27500000000000000000e+01, 0xc004, 0x83000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.27500000000000000000e+01, 0xc004, 0x83000000L, 0x00000000L), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(4.72236648286964521370e+21, 0x4047, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(4.72236648286964521370e+21, 0x4047, 0x80000000L, 0x00000000L), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(2.11758236813575084767e-22, 0x3fb7, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(2.11758236813575084767e-22, 0x3fb7, 0x80000000L, 0x00000000L), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(4.72236648286964521370e+21, 0x4047, 0x80000000L, 0x00000000L), HEXCONSTE(4.72236648286964521370e+21, 0x4047, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+01, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(-4.72236648286964521370e+21, 0xc047, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), INF_P, 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), INF_P, 0 },
#endif
	{ __LINE__,  HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), INF_P, 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), INF_P, 0 },
#endif
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+01, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+01, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+01, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.10000000000000000000e+01, 0x4002, 0xb0000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), ZERO_P, FLAG_IGNORE_ZEROSIGN },
	{ __LINE__,  HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.10000000000000000000e+01, 0x4002, 0xb0000000L, 0x00000000L), ZERO_P, FLAG_IGNORE_ZEROSIGN },
	{ __LINE__,  HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.11000003814697265625e+01, 0x4002, 0xb1999a00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.10999994277954101562e+01, 0x4002, 0xb1999900L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.11000000000000014211e+01, 0x4002, 0xb1999999L, 0x9999a000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.10999999999999996447e+01, 0x4002, 0xb1999999L, 0x99999800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.11000000000000000003e+01, 0x4002, 0xb1999999L, 0x9999999aL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.10999999999999999995e+01, 0x4002, 0xb1999999L, 0x99999999L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.11000003814697265625e+01, 0x4002, 0xb1999a00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.10999994277954101562e+01, 0x4002, 0xb1999900L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.11000000000000014211e+01, 0x4002, 0xb1999999L, 0x9999a000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.10999999999999996447e+01, 0x4002, 0xb1999999L, 0x99999800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.11000000000000000003e+01, 0x4002, 0xb1999999L, 0x9999999aL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.10999999999999999995e+01, 0x4002, 0xb1999999L, 0x99999999L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(2.70000000000000000000e+01, 0x4003, 0xd8000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.67772150000000000000e+07, 0x4016, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(9.00719925474099200000e+15, 0x4034, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(9.00719871787008000000e+15, 0x4033, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(9.00719925474099100000e+15, 0x4033, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.84467440737095516160e+19, 0x403f, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.84467429741979238400e+19, 0x403e, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.84467440737095495680e+19, 0x403e, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.84467440737095516150e+19, 0x403e, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(8.11296384146066816958e+31, 0x4069, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(8.11296335789034032373e+31, 0x4068, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(8.11296384146066726886e+31, 0x4068, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(8.11296384146066816914e+31, 0x4068, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.03845937170696552571e+34, 0x4070, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.03845930980996356144e+34, 0x406f, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.03845937170696541041e+34, 0x406f, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.03845937170696552565e+34, 0x406f, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(2.70000000000000000000e+01, 0x4003, 0xd8000000L, 0x00000000L), ZERO_P, FLAG_IGNORE_ZEROSIGN },
	{ __LINE__,  HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.67772150000000000000e+07, 0x4016, 0xffffff00L, 0x00000000L), ZERO_P, FLAG_IGNORE_ZEROSIGN },
	{ __LINE__,  HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(3.35544300000000000000e+07, 0x4017, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(9.00719925474099200000e+15, 0x4034, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(9.00719871787008000000e+15, 0x4033, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(9.00719925474099100000e+15, 0x4033, 0xffffffffL, 0xfffff800L), ZERO_P, FLAG_IGNORE_ZEROSIGN },
	{ __LINE__,  HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.80143985094819840000e+16, 0x4035, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.80143974357401600000e+16, 0x4034, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.80143985094819820000e+16, 0x4034, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.84467440737095516160e+19, 0x403f, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.84467429741979238400e+19, 0x403e, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.84467440737095495680e+19, 0x403e, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.84467440737095516150e+19, 0x403e, 0xffffffffL, 0xffffffffL), ZERO_P, FLAG_IGNORE_ZEROSIGN },
	{ __LINE__,  HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(3.68934881474191032320e+19, 0x4040, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(3.68934859483958476800e+19, 0x403f, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(3.68934881474190991360e+19, 0x403f, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(3.68934881474191032300e+19, 0x403f, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(8.11296384146066816958e+31, 0x4069, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(8.11296335789034032373e+31, 0x4068, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(8.11296384146066726886e+31, 0x4068, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(8.11296384146066816914e+31, 0x4068, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.62259276829213363392e+32, 0x406a, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.62259267157806806475e+32, 0x4069, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.62259276829213345377e+32, 0x4069, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.62259276829213363383e+32, 0x4069, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.03845937170696552571e+34, 0x4070, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.03845930980996356144e+34, 0x406f, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.03845937170696541041e+34, 0x406f, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.03845937170696552565e+34, 0x406f, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(2.07691874341393105141e+34, 0x4071, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(2.07691861961992712287e+34, 0x4070, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(2.07691874341393082083e+34, 0x4070, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(2.07691874341393105130e+34, 0x4070, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(4.00000000000000000000e+00, 0x4001, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.67772160000000000000e+07, 0x4017, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.70141183460469231732e+38, 0x407e, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(5.00000000000000000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(4.00000000000000000000e+00, 0x4001, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.67772160000000000000e+07, 0x4017, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.70141183460469231732e+38, 0x407e, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(1.60000000000000000000e+01, 0x4003, 0x80000000L, 0x00000000L), HEXCONSTE(2.50000000000000000000e-01, 0x3ffd, 0x80000000L, 0x00000000L), HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.84467440737095516160e+19, 0x403f, 0x80000000L, 0x00000000L), HEXCONSTE(1.25000000000000000000e-01, 0x3ffc, 0x80000000L, 0x00000000L), HEXCONSTE(2.56000000000000000000e+02, 0x4007, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(4.00000000000000000000e+00, 0x4001, 0x80000000L, 0x00000000L), HEXCONSTE(1.60000000000000000000e+01, 0x4003, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(2.56000000000000000000e+02, 0x4007, 0x80000000L, 0x00000000L), HEXCONSTE(8.00000000000000000000e+00, 0x4002, 0x80000000L, 0x00000000L), HEXCONSTE(1.84467440737095516160e+19, 0x403f, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(7.50000000000000000000e-01, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(1.25000000000000000000e+00, 0x3fff, 0xa0000000L, 0x00000000L), HEXCONSTE(6.97953644326574699195e-01, 0x3ffe, 0xb2ad170cL, 0x81b4183dL), 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-9.80817973168046080000e+16, 0xc037, 0xae3a7000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-9.80818059067392000000e+16, 0xc037, 0xae3a7100L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-9.80818000000000000000e+16, 0xc037, 0xae3a704fL, 0xf7280000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-7.49320999999999959167e+133, 0xc1bb, 0xd322818aL, 0xade07800L), HEXCONSTE(-9.80817973168046080000e+16, 0xc037, 0xae3a7000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-7.49320999999999959167e+133, 0xc1bb, 0xd322818aL, 0xade07800L), HEXCONSTE(-9.80818059067392000000e+16, 0xc037, 0xae3a7100L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-7.49320999999999959167e+133, 0xc1bb, 0xd322818aL, 0xade07800L), HEXCONSTE(-9.80818000000000000000e+16, 0xc037, 0xae3a704fL, 0xf7280000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-7.49321000000000060036e+133, 0xc1bb, 0xd322818aL, 0xade08000L), HEXCONSTE(-9.80817973168046080000e+16, 0xc037, 0xae3a7000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-7.49321000000000060036e+133, 0xc1bb, 0xd322818aL, 0xade08000L), HEXCONSTE(-9.80818059067392000000e+16, 0xc037, 0xae3a7100L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-7.49321000000000060036e+133, 0xc1bb, 0xd322818aL, 0xade08000L), HEXCONSTE(-9.80818000000000000000e+16, 0xc037, 0xae3a704fL, 0xf7280000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-7.49320999999999999997e+133, 0xc1bb, 0xd322818aL, 0xade07b3dL), HEXCONSTE(-9.80817973168046080000e+16, 0xc037, 0xae3a7000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-7.49320999999999999997e+133, 0xc1bb, 0xd322818aL, 0xade07b3dL), HEXCONSTE(-9.80818059067392000000e+16, 0xc037, 0xae3a7100L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-7.49320999999999999997e+133, 0xc1bb, 0xd322818aL, 0xade07b3dL), HEXCONSTE(-9.80818000000000000000e+16, 0xc037, 0xae3a704fL, 0xf7280000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-7.49321000000000000046e+133, 0xc1bb, 0xd322818aL, 0xade07b3eL), HEXCONSTE(-9.80817973168046080000e+16, 0xc037, 0xae3a7000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-7.49321000000000000046e+133, 0xc1bb, 0xd322818aL, 0xade07b3eL), HEXCONSTE(-9.80818059067392000000e+16, 0xc037, 0xae3a7100L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-7.49321000000000000046e+133, 0xc1bb, 0xd322818aL, 0xade07b3eL), HEXCONSTE(-9.80818000000000000000e+16, 0xc037, 0xae3a704fL, 0xf7280000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.67772150000000000000e+07, 0xc016, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-3.35544300000000000000e+07, 0xc017, 0xffffff00L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-9.00719871787008000000e+15, 0xc033, 0xffffff00L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-9.00719925474099200000e+15, 0xc034, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-9.00719925474099100000e+15, 0xc033, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.80143974357401600000e+16, 0xc034, 0xffffff00L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.80143985094819840000e+16, 0xc035, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.80143985094819820000e+16, 0xc034, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.84467429741979238400e+19, 0xc03e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.84467440737095516160e+19, 0xc03f, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.84467440737095495680e+19, 0xc03e, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.84467440737095516150e+19, 0xc03e, 0xffffffffL, 0xffffffffL), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-3.68934859483958476800e+19, 0xc03f, 0xffffff00L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-3.68934881474191032320e+19, 0xc040, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-3.68934881474190991360e+19, 0xc03f, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-3.68934881474191032300e+19, 0xc03f, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-8.11296335789034032373e+31, 0xc068, 0xffffff00L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-8.11296384146066816958e+31, 0xc069, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-8.11296384146066726886e+31, 0xc068, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-8.11296384146066816914e+31, 0xc068, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.62259267157806806475e+32, 0xc069, 0xffffff00L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.62259276829213363392e+32, 0xc06a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.62259276829213345377e+32, 0xc069, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.62259276829213363383e+32, 0xc069, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.03845930980996356144e+34, 0xc06f, 0xffffff00L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.03845937170696552571e+34, 0xc070, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.03845937170696541041e+34, 0xc06f, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.03845937170696552565e+34, 0xc06f, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-2.07691861961992712287e+34, 0xc070, 0xffffff00L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-2.07691874341393105141e+34, 0xc071, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-2.07691874341393082083e+34, 0xc070, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-2.07691874341393105130e+34, 0xc070, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(1.67772150000000000000e+07, 0x4016, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(3.35544300000000000000e+07, 0x4017, 0xffffff00L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(9.00719925474099200000e+15, 0x4034, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(9.00719871787008000000e+15, 0x4033, 0xffffff00L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(9.00719925474099100000e+15, 0x4033, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), 0 },
#endif
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(1.80143985094819840000e+16, 0x4035, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(1.80143974357401600000e+16, 0x4034, 0xffffff00L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(1.80143985094819820000e+16, 0x4034, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(1.84467440737095516160e+19, 0x403f, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(1.84467429741979238400e+19, 0x403e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(1.84467440737095495680e+19, 0x403e, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(1.84467440737095516150e+19, 0x403e, 0xffffffffL, 0xffffffffL), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), 0 },
#endif
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(3.68934881474191032320e+19, 0x4040, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(3.68934859483958476800e+19, 0x403f, 0xffffff00L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(3.68934881474190991360e+19, 0x403f, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(3.68934881474191032300e+19, 0x403f, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(8.11296384146066816958e+31, 0x4069, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(8.11296335789034032373e+31, 0x4068, 0xffffff00L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(8.11296384146066726886e+31, 0x4068, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(8.11296384146066816914e+31, 0x4068, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(1.62259276829213363392e+32, 0x406a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(1.62259267157806806475e+32, 0x4069, 0xffffff00L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(1.62259276829213345377e+32, 0x4069, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(1.62259276829213363383e+32, 0x4069, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(1.03845937170696552571e+34, 0x4070, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(1.03845930980996356144e+34, 0x406f, 0xffffff00L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(1.03845937170696541041e+34, 0x406f, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(1.03845937170696552565e+34, 0x406f, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(2.07691874341393105141e+34, 0x4071, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(2.07691861961992712287e+34, 0x4070, 0xffffff00L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(2.07691874341393082083e+34, 0x4070, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(2.07691874341393105130e+34, 0x4070, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(1.26000000000000000000e+02, 0x4005, 0xfc000000L, 0x00000000L), HEXCONSTE(8.50705917302346158658e+37, 0x407d, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(1.27000000000000000000e+02, 0x4005, 0xfe000000L, 0x00000000L), HEXCONSTE(-1.70141183460469231732e+38, 0xc07e, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.26000000000000000000e+02, 0xc005, 0xfc000000L, 0x00000000L), HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.27000000000000000000e+02, 0xc005, 0xfe000000L, 0x00000000L), HEXCONSTE(-5.87747175411143753984e-39, 0xbf80, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.67772150000000000000e+07, 0xc016, 0xffffff00L, 0x00000000L), ZERO_P, FLAG_IGNORE_ZEROSIGN },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(-3.35544300000000000000e+07, 0xc017, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(-9.00719871787008000000e+15, 0xc033, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(-9.00719925474099200000e+15, 0xc034, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(-9.00719925474099100000e+15, 0xc033, 0xffffffffL, 0xfffff800L), ZERO_P, FLAG_IGNORE_ZEROSIGN },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.80143974357401600000e+16, 0xc034, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.80143985094819840000e+16, 0xc035, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.80143985094819820000e+16, 0xc034, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.84467429741979238400e+19, 0xc03e, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.84467440737095516160e+19, 0xc03f, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.84467440737095495680e+19, 0xc03e, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.84467440737095516150e+19, 0xc03e, 0xffffffffL, 0xffffffffL), ZERO_P, FLAG_IGNORE_ZEROSIGN },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(-3.68934859483958476800e+19, 0xc03f, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(-3.68934881474191032320e+19, 0xc040, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(-3.68934881474190991360e+19, 0xc03f, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(-3.68934881474191032300e+19, 0xc03f, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(-8.11296335789034032373e+31, 0xc068, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(-8.11296384146066816958e+31, 0xc069, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(-8.11296384146066726886e+31, 0xc068, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(-8.11296384146066816914e+31, 0xc068, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.62259267157806806475e+32, 0xc069, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.62259276829213363392e+32, 0xc06a, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.62259276829213345377e+32, 0xc069, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.62259276829213363383e+32, 0xc069, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.03845930980996356144e+34, 0xc06f, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.03845937170696552571e+34, 0xc070, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.03845937170696541041e+34, 0xc06f, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.03845937170696552565e+34, 0xc06f, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(-2.07691861961992712287e+34, 0xc070, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(-2.07691874341393105141e+34, 0xc071, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(-2.07691874341393082083e+34, 0xc070, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(-2.07691874341393105130e+34, 0xc070, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(1.67772150000000000000e+07, 0x4016, 0xffffff00L, 0x00000000L), INF_M, 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(3.35544300000000000000e+07, 0x4017, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(9.00719925474099200000e+15, 0x4034, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(9.00719871787008000000e+15, 0x4033, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(9.00719925474099100000e+15, 0x4033, 0xffffffffL, 0xfffff800L), INF_M, 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(1.80143985094819840000e+16, 0x4035, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(1.80143974357401600000e+16, 0x4034, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(1.80143985094819820000e+16, 0x4034, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(1.84467440737095516160e+19, 0x403f, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(1.84467429741979238400e+19, 0x403e, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(1.84467440737095495680e+19, 0x403e, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(1.84467440737095516150e+19, 0x403e, 0xffffffffL, 0xffffffffL), INF_M, 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(3.68934881474191032320e+19, 0x4040, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(3.68934859483958476800e+19, 0x403f, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(3.68934881474190991360e+19, 0x403f, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(3.68934881474191032300e+19, 0x403f, 0xffffffffL, 0xffffffffL), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(8.11296384146066816958e+31, 0x4069, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(8.11296335789034032373e+31, 0x4068, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(8.11296384146066726886e+31, 0x4068, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(8.11296384146066816914e+31, 0x4068, 0xffffffffL, 0xffffffffL), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(1.62259276829213363392e+32, 0x406a, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(1.62259267157806806475e+32, 0x4069, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(1.62259276829213345377e+32, 0x4069, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(1.62259276829213363383e+32, 0x4069, 0xffffffffL, 0xffffffffL), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(1.03845937170696552571e+34, 0x4070, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(1.03845930980996356144e+34, 0x406f, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(1.03845937170696541041e+34, 0x406f, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(1.03845937170696552565e+34, 0x406f, 0xffffffffL, 0xffffffffL), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(2.07691874341393105141e+34, 0x4071, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(2.07691861961992712287e+34, 0x4070, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(2.07691874341393082083e+34, 0x4070, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(2.07691874341393105130e+34, 0x4070, 0xffffffffL, 0xffffffffL), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), INF_P, 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), INF_P, 0 },
#endif
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(8.63616958460605456449e-78, 0x3eff, 0x80000100L, 0x00018000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(3.09434604738257896256e-617, 0x37ff, 0x80000000L, 0x00000800L), 0 },
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-3.00000000000000000000e+00, 0xc000, 0xc0000000L, 0x00000000L), HEXCONSTE(-2.53794229113506834416e-116, 0xbe7f, 0x80000180L, 0x00030000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-3.00000000000000000000e+00, 0xc000, 0xc0000000L, 0x00000000L), HEXCONSTE(-1.72128712480151578340e-925, 0xb3ff, 0x80000000L, 0x00000c00L), 0 },
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-3.00000000000000000000e+00, 0xc000, 0xc0000000L, 0x00000000L), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(1.15792075433823913219e+77, 0x40fe, 0xfffffe00L, 0x00010000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(3.23170060713110001249e+616, 0x47fe, 0xffffffffL, 0xfffff000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), INF_P, 0 },
#endif
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(3.00000000000000000000e+00, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(-3.94019991507671508429e+115, 0xc17e, 0xfffffd00L, 0x00030000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(3.00000000000000000000e+00, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(-5.80960599536995612787e+924, 0xcbfe, 0xffffffffL, 0xffffe800L), 0 },
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(3.00000000000000000000e+00, 0x4000, 0xc0000000L, 0x00000000L), INF_M, 0 },
#endif
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.67772150000000000000e+07, 0xc016, 0xffffff00L, 0x00000000L), ZERO_P, FLAG_IGNORE_ZEROSIGN },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.67772150000000000000e+07, 0xc016, 0xffffff00L, 0x00000000L), ZERO_P, FLAG_IGNORE_ZEROSIGN },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-1.67772150000000000000e+07, 0xc016, 0xffffff00L, 0x00000000L), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-3.35544300000000000000e+07, 0xc017, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-3.35544300000000000000e+07, 0xc017, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-3.35544300000000000000e+07, 0xc017, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-9.00719871787008000000e+15, 0xc033, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-9.00719925474099200000e+15, 0xc034, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-9.00719925474099100000e+15, 0xc033, 0xffffffffL, 0xfffff800L), ZERO_P, FLAG_IGNORE_ZEROSIGN },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-9.00719871787008000000e+15, 0xc033, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-9.00719925474099200000e+15, 0xc034, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-9.00719925474099100000e+15, 0xc033, 0xffffffffL, 0xfffff800L), ZERO_P, FLAG_IGNORE_ZEROSIGN },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-9.00719871787008000000e+15, 0xc033, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-9.00719925474099200000e+15, 0xc034, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-9.00719925474099100000e+15, 0xc033, 0xffffffffL, 0xfffff800L), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.80143974357401600000e+16, 0xc034, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.80143985094819840000e+16, 0xc035, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.80143985094819820000e+16, 0xc034, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.80143974357401600000e+16, 0xc034, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.80143985094819840000e+16, 0xc035, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.80143985094819820000e+16, 0xc034, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-1.80143974357401600000e+16, 0xc034, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-1.80143985094819840000e+16, 0xc035, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-1.80143985094819820000e+16, 0xc034, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.84467429741979238400e+19, 0xc03e, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.84467440737095516160e+19, 0xc03f, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.84467440737095495680e+19, 0xc03e, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.84467440737095516150e+19, 0xc03e, 0xffffffffL, 0xffffffffL), ZERO_P, FLAG_IGNORE_ZEROSIGN },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.84467429741979238400e+19, 0xc03e, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.84467440737095516160e+19, 0xc03f, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.84467440737095495680e+19, 0xc03e, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.84467440737095516150e+19, 0xc03e, 0xffffffffL, 0xffffffffL), ZERO_P, FLAG_IGNORE_ZEROSIGN },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-1.84467429741979238400e+19, 0xc03e, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-1.84467440737095516160e+19, 0xc03f, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-1.84467440737095495680e+19, 0xc03e, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-1.84467440737095516150e+19, 0xc03e, 0xffffffffL, 0xffffffffL), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-3.68934859483958476800e+19, 0xc03f, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-3.68934881474191032320e+19, 0xc040, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-3.68934881474190991360e+19, 0xc03f, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-3.68934881474191032300e+19, 0xc03f, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-3.68934859483958476800e+19, 0xc03f, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-3.68934881474191032320e+19, 0xc040, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-3.68934881474190991360e+19, 0xc03f, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-3.68934881474191032300e+19, 0xc03f, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-3.68934859483958476800e+19, 0xc03f, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-3.68934881474191032320e+19, 0xc040, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-3.68934881474190991360e+19, 0xc03f, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-3.68934881474191032300e+19, 0xc03f, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-8.11296335789034032373e+31, 0xc068, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-8.11296384146066816958e+31, 0xc069, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-8.11296384146066726886e+31, 0xc068, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-8.11296384146066816914e+31, 0xc068, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-8.11296335789034032373e+31, 0xc068, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-8.11296384146066816958e+31, 0xc069, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-8.11296384146066726886e+31, 0xc068, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-8.11296384146066816914e+31, 0xc068, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-8.11296335789034032373e+31, 0xc068, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-8.11296384146066816958e+31, 0xc069, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-8.11296384146066726886e+31, 0xc068, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-8.11296384146066816914e+31, 0xc068, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.62259267157806806475e+32, 0xc069, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.62259276829213363392e+32, 0xc06a, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.62259276829213345377e+32, 0xc069, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.62259276829213363383e+32, 0xc069, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.62259267157806806475e+32, 0xc069, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.62259276829213363392e+32, 0xc06a, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.62259276829213345377e+32, 0xc069, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.62259276829213363383e+32, 0xc069, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-1.62259267157806806475e+32, 0xc069, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-1.62259276829213363392e+32, 0xc06a, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-1.62259276829213345377e+32, 0xc069, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-1.62259276829213363383e+32, 0xc069, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.03845930980996356144e+34, 0xc06f, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.03845937170696552571e+34, 0xc070, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.03845937170696541041e+34, 0xc06f, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.03845937170696552565e+34, 0xc06f, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.03845930980996356144e+34, 0xc06f, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.03845937170696552571e+34, 0xc070, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.03845937170696541041e+34, 0xc06f, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.03845937170696552565e+34, 0xc06f, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-1.03845930980996356144e+34, 0xc06f, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-1.03845937170696552571e+34, 0xc070, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-1.03845937170696541041e+34, 0xc06f, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-1.03845937170696552565e+34, 0xc06f, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-2.07691861961992712287e+34, 0xc070, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-2.07691874341393105141e+34, 0xc071, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-2.07691874341393082083e+34, 0xc070, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-2.07691874341393105130e+34, 0xc070, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-2.07691861961992712287e+34, 0xc070, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-2.07691874341393105141e+34, 0xc071, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-2.07691874341393082083e+34, 0xc070, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-2.07691874341393105130e+34, 0xc070, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-2.07691861961992712287e+34, 0xc070, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-2.07691874341393105141e+34, 0xc071, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-2.07691874341393082083e+34, 0xc070, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-2.07691874341393105130e+34, 0xc070, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.67772150000000000000e+07, 0x4016, 0xffffff00L, 0x00000000L), INF_M, 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.67772150000000000000e+07, 0x4016, 0xffffff00L, 0x00000000L), INF_M, 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.67772150000000000000e+07, 0x4016, 0xffffff00L, 0x00000000L), INF_M, 0 },
#endif
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(3.35544300000000000000e+07, 0x4017, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(3.35544300000000000000e+07, 0x4017, 0xffffff00L, 0x00000000L), INF_P, 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(3.35544300000000000000e+07, 0x4017, 0xffffff00L, 0x00000000L), INF_P, 0 },
#endif
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(9.00719925474099200000e+15, 0x4034, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(9.00719871787008000000e+15, 0x4033, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(9.00719925474099100000e+15, 0x4033, 0xffffffffL, 0xfffff800L), INF_M, 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(9.00719925474099200000e+15, 0x4034, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(9.00719871787008000000e+15, 0x4033, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(9.00719925474099100000e+15, 0x4033, 0xffffffffL, 0xfffff800L), INF_M, 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(9.00719925474099200000e+15, 0x4034, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(9.00719871787008000000e+15, 0x4033, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(9.00719925474099100000e+15, 0x4033, 0xffffffffL, 0xfffff800L), INF_M, 0 },
#endif
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.80143985094819840000e+16, 0x4035, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.80143974357401600000e+16, 0x4034, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.80143985094819820000e+16, 0x4034, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.80143985094819840000e+16, 0x4035, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.80143974357401600000e+16, 0x4034, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.80143985094819820000e+16, 0x4034, 0xffffffffL, 0xfffff800L), INF_P, 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.80143985094819840000e+16, 0x4035, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.80143974357401600000e+16, 0x4034, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.80143985094819820000e+16, 0x4034, 0xffffffffL, 0xfffff800L), INF_P, 0 },
#endif
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.84467440737095516160e+19, 0x403f, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.84467429741979238400e+19, 0x403e, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.84467440737095495680e+19, 0x403e, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.84467440737095516150e+19, 0x403e, 0xffffffffL, 0xffffffffL), INF_M, 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.84467440737095516160e+19, 0x403f, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.84467429741979238400e+19, 0x403e, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.84467440737095495680e+19, 0x403e, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.84467440737095516150e+19, 0x403e, 0xffffffffL, 0xffffffffL), INF_M, 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.84467440737095516160e+19, 0x403f, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.84467429741979238400e+19, 0x403e, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.84467440737095495680e+19, 0x403e, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.84467440737095516150e+19, 0x403e, 0xffffffffL, 0xffffffffL), INF_M, 0 },
#endif
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(3.68934881474191032320e+19, 0x4040, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(3.68934859483958476800e+19, 0x403f, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(3.68934881474190991360e+19, 0x403f, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(3.68934881474191032300e+19, 0x403f, 0xffffffffL, 0xffffffffL), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(3.68934881474191032320e+19, 0x4040, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(3.68934859483958476800e+19, 0x403f, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(3.68934881474190991360e+19, 0x403f, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(3.68934881474191032300e+19, 0x403f, 0xffffffffL, 0xffffffffL), INF_P, 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(3.68934881474191032320e+19, 0x4040, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(3.68934859483958476800e+19, 0x403f, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(3.68934881474190991360e+19, 0x403f, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(3.68934881474191032300e+19, 0x403f, 0xffffffffL, 0xffffffffL), INF_P, 0 },
#endif
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(8.11296384146066816958e+31, 0x4069, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(8.11296335789034032373e+31, 0x4068, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(8.11296384146066726886e+31, 0x4068, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(8.11296384146066816914e+31, 0x4068, 0xffffffffL, 0xffffffffL), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(8.11296384146066816958e+31, 0x4069, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(8.11296335789034032373e+31, 0x4068, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(8.11296384146066726886e+31, 0x4068, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(8.11296384146066816914e+31, 0x4068, 0xffffffffL, 0xffffffffL), INF_P, 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(8.11296384146066816958e+31, 0x4069, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(8.11296335789034032373e+31, 0x4068, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(8.11296384146066726886e+31, 0x4068, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(8.11296384146066816914e+31, 0x4068, 0xffffffffL, 0xffffffffL), INF_P, 0 },
#endif
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.62259276829213363392e+32, 0x406a, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.62259267157806806475e+32, 0x4069, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.62259276829213345377e+32, 0x4069, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.62259276829213363383e+32, 0x4069, 0xffffffffL, 0xffffffffL), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.62259276829213363392e+32, 0x406a, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.62259267157806806475e+32, 0x4069, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.62259276829213345377e+32, 0x4069, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.62259276829213363383e+32, 0x4069, 0xffffffffL, 0xffffffffL), INF_P, 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.62259276829213363392e+32, 0x406a, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.62259267157806806475e+32, 0x4069, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.62259276829213345377e+32, 0x4069, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.62259276829213363383e+32, 0x4069, 0xffffffffL, 0xffffffffL), INF_P, 0 },
#endif
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.03845937170696552571e+34, 0x4070, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.03845930980996356144e+34, 0x406f, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.03845937170696541041e+34, 0x406f, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.03845937170696552565e+34, 0x406f, 0xffffffffL, 0xffffffffL), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.03845937170696552571e+34, 0x4070, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.03845930980996356144e+34, 0x406f, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.03845937170696541041e+34, 0x406f, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.03845937170696552565e+34, 0x406f, 0xffffffffL, 0xffffffffL), INF_P, 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.03845937170696552571e+34, 0x4070, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.03845930980996356144e+34, 0x406f, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.03845937170696541041e+34, 0x406f, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.03845937170696552565e+34, 0x406f, 0xffffffffL, 0xffffffffL), INF_P, 0 },
#endif
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(2.07691874341393105141e+34, 0x4071, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(2.07691861961992712287e+34, 0x4070, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(2.07691874341393082083e+34, 0x4070, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(2.07691874341393105130e+34, 0x4070, 0xffffffffL, 0xffffffffL), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(2.07691874341393105141e+34, 0x4071, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(2.07691861961992712287e+34, 0x4070, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(2.07691874341393082083e+34, 0x4070, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(2.07691874341393105130e+34, 0x4070, 0xffffffffL, 0xffffffffL), INF_P, 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(2.07691874341393105141e+34, 0x4071, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(2.07691861961992712287e+34, 0x4070, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(2.07691874341393082083e+34, 0x4070, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(2.07691874341393105130e+34, 0x4070, 0xffffffffL, 0xffffffffL), INF_P, 0 },
#endif
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), INF_P, 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), INF_P, 0 },
#endif
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), INF_P, 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), INF_P, 0 },
#endif
	{ __LINE__,  HEXCONSTE(-3.68934881474191032320e+19, 0xc040, 0x80000000L, 0x00000000L), HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(1.36112946768375385385e+39, 0x4081, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.68934881474191032320e+19, 0xc040, 0x80000000L, 0x00000000L), HEXCONSTE(3.00000000000000000000e+00, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(-5.02168138830934461107e+58, 0xc0c2, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.68934881474191032320e+19, 0xc040, 0x80000000L, 0x00000000L), HEXCONSTE(4.00000000000000000000e+00, 0x4001, 0x80000000L, 0x00000000L), HEXCONSTE(1.85267342779705912678e+78, 0x4103, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.68934881474191032320e+19, 0xc040, 0x80000000L, 0x00000000L), HEXCONSTE(5.00000000000000000000e+00, 0x4001, 0xa0000000L, 0x00000000L), HEXCONSTE(-6.83515851494691226366e+97, 0xc144, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-8.79609302220800000000e+12, 0xc02a, 0x80000000L, 0x00000000L), HEXCONSTE(3.00000000000000000000e+00, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(-6.80564733841876926927e+38, 0xc080, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-8.79609302220800000000e+12, 0xc02a, 0x80000000L, 0x00000000L), HEXCONSTE(4.00000000000000000000e+00, 0x4001, 0x80000000L, 0x00000000L), HEXCONSTE(5.98631070650737835296e+51, 0x40ab, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-8.79609302220800000000e+12, 0xc02a, 0x80000000L, 0x00000000L), HEXCONSTE(5.00000000000000000000e+00, 0x4001, 0xa0000000L, 0x00000000L), HEXCONSTE(-5.26561458342785933490e+64, 0xc0d6, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-8.58993459200000000000e+09, 0xc020, 0x80000000L, 0x00000000L), HEXCONSTE(4.00000000000000000000e+00, 0x4001, 0x80000000L, 0x00000000L), HEXCONSTE(5.44451787073501541541e+39, 0x4083, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-8.58993459200000000000e+09, 0xc020, 0x80000000L, 0x00000000L), HEXCONSTE(5.00000000000000000000e+00, 0x4001, 0xa0000000L, 0x00000000L), HEXCONSTE(-4.67680523945888933825e+49, 0xc0a4, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-6.71088640000000000000e+07, 0xc019, 0x80000000L, 0x00000000L), HEXCONSTE(5.00000000000000000000e+00, 0x4001, 0xa0000000L, 0x00000000L), HEXCONSTE(-1.36112946768375385385e+39, 0xc081, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.71050543121376108502e-20, 0xbfbe, 0x80000000L, 0x00000000L), HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(1.36112946768375385385e+39, 0x4081, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.71050543121376108502e-20, 0xbfbe, 0x80000000L, 0x00000000L), HEXCONSTE(-3.00000000000000000000e+00, 0xc000, 0xc0000000L, 0x00000000L), HEXCONSTE(-5.02168138830934461107e+58, 0xc0c2, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.71050543121376108502e-20, 0xbfbe, 0x80000000L, 0x00000000L), HEXCONSTE(-4.00000000000000000000e+00, 0xc001, 0x80000000L, 0x00000000L), HEXCONSTE(1.85267342779705912678e+78, 0x4103, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.71050543121376108502e-20, 0xbfbe, 0x80000000L, 0x00000000L), HEXCONSTE(-5.00000000000000000000e+00, 0xc001, 0xa0000000L, 0x00000000L), HEXCONSTE(-6.83515851494691226366e+97, 0xc144, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.13686837721616029739e-13, 0xbfd4, 0x80000000L, 0x00000000L), HEXCONSTE(-3.00000000000000000000e+00, 0xc000, 0xc0000000L, 0x00000000L), HEXCONSTE(-6.80564733841876926927e+38, 0xc080, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.13686837721616029739e-13, 0xbfd4, 0x80000000L, 0x00000000L), HEXCONSTE(-4.00000000000000000000e+00, 0xc001, 0x80000000L, 0x00000000L), HEXCONSTE(5.98631070650737835296e+51, 0x40ab, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.13686837721616029739e-13, 0xbfd4, 0x80000000L, 0x00000000L), HEXCONSTE(-5.00000000000000000000e+00, 0xc001, 0xa0000000L, 0x00000000L), HEXCONSTE(-5.26561458342785933490e+64, 0xc0d6, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.16415321826934814453e-10, 0xbfde, 0x80000000L, 0x00000000L), HEXCONSTE(-4.00000000000000000000e+00, 0xc001, 0x80000000L, 0x00000000L), HEXCONSTE(5.44451787073501541541e+39, 0x4083, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.16415321826934814453e-10, 0xbfde, 0x80000000L, 0x00000000L), HEXCONSTE(-5.00000000000000000000e+00, 0xc001, 0xa0000000L, 0x00000000L), HEXCONSTE(-4.67680523945888933825e+49, 0xc0a4, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.49011611938476562500e-08, 0xbfe5, 0x80000000L, 0x00000000L), HEXCONSTE(-5.00000000000000000000e+00, 0xc001, 0xa0000000L, 0x00000000L), HEXCONSTE(-1.36112946768375385385e+39, 0xc081, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(1.15792075433823913219e+77, 0x40fe, 0xfffffe00L, 0x00010000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-2.68156158598851941991e+154, 0xc200, 0x80000000L, 0x00000000L), HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(7.19077253944926363092e+308, 0x4401, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(3.00000000000000000000e+00, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(-3.94019991507671508429e+115, 0xc17e, 0xfffffd00L, 0x00030000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-2.68156158598851941991e+154, 0xc200, 0x80000000L, 0x00000000L), HEXCONSTE(3.00000000000000000000e+00, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(-1.92824994153682607086e+463, 0xc602, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(4.00000000000000000000e+00, 0x4001, 0x80000000L, 0x00000000L), HEXCONSTE(1.34078047332723673806e+154, 0x41fe, 0xfffffc00L, 0x00060000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-2.68156158598851941991e+154, 0xc200, 0x80000000L, 0x00000000L), HEXCONSTE(4.00000000000000000000e+00, 0x4001, 0x80000000L, 0x00000000L), HEXCONSTE(5.17072097140976116811e+617, 0x4803, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(5.00000000000000000000e+00, 0x4001, 0xa0000000L, 0x00000000L), HEXCONSTE(-4.56243925790909569817e+192, 0xc27e, 0xfffffb00L, 0x000a0000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-2.68156158598851941991e+154, 0xc200, 0x80000000L, 0x00000000L), HEXCONSTE(5.00000000000000000000e+00, 0x4001, 0xa0000000L, 0x00000000L), HEXCONSTE(-1.38656067287976569376e+772, 0xca04, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(3.00000000000000000000e+00, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(-3.94019991507671508429e+115, 0xc17e, 0xfffffd00L, 0x00030000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-8.95897896871121684223e+102, 0xc155, 0x80000000L, 0x00000000L), HEXCONSTE(3.00000000000000000000e+00, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(-7.19077253944926363092e+308, 0xc401, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(4.00000000000000000000e+00, 0x4001, 0x80000000L, 0x00000000L), HEXCONSTE(1.34078047332723673806e+154, 0x41fe, 0xfffffc00L, 0x00060000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-8.95897896871121684223e+102, 0xc155, 0x80000000L, 0x00000000L), HEXCONSTE(4.00000000000000000000e+00, 0x4001, 0x80000000L, 0x00000000L), HEXCONSTE(6.44219799497121017112e+411, 0x4557, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(5.00000000000000000000e+00, 0x4001, 0xa0000000L, 0x00000000L), HEXCONSTE(-4.56243925790909569817e+192, 0xc27e, 0xfffffb00L, 0x000a0000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-8.95897896871121684223e+102, 0xc155, 0x80000000L, 0x00000000L), HEXCONSTE(5.00000000000000000000e+00, 0x4001, 0xa0000000L, 0x00000000L), HEXCONSTE(-5.77155163492206414036e+514, 0xc6ad, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(4.00000000000000000000e+00, 0x4001, 0x80000000L, 0x00000000L), HEXCONSTE(1.34078047332723673806e+154, 0x41fe, 0xfffffc00L, 0x00060000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-2.31584178474632390847e+77, 0xc100, 0x80000000L, 0x00000000L), HEXCONSTE(4.00000000000000000000e+00, 0x4001, 0x80000000L, 0x00000000L), HEXCONSTE(2.87630901577970545237e+309, 0x4403, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(5.00000000000000000000e+00, 0x4001, 0xa0000000L, 0x00000000L), HEXCONSTE(-4.56243925790909569817e+192, 0xc27e, 0xfffffb00L, 0x000a0000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-2.31584178474632390847e+77, 0xc100, 0x80000000L, 0x00000000L), HEXCONSTE(5.00000000000000000000e+00, 0x4001, 0xa0000000L, 0x00000000L), HEXCONSTE(-6.66107660458521541243e+386, 0xc504, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(5.00000000000000000000e+00, 0x4001, 0xa0000000L, 0x00000000L), HEXCONSTE(-4.56243925790909569817e+192, 0xc27e, 0xfffffb00L, 0x000a0000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-5.14220174162876888173e+61, 0xc0cc, 0x80000000L, 0x00000000L), HEXCONSTE(5.00000000000000000000e+00, 0x4001, 0xa0000000L, 0x00000000L), HEXCONSTE(-3.59538626972463181546e+308, 0xc400, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(5.09258994083621521567e+89, 0x4129, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-3.72917036560010337165e-155, 0xbdfe, 0x80000000L, 0x00000000L), HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(7.19077253944926363092e+308, 0x4401, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-3.00000000000000000000e+00, 0xc000, 0xc0000000L, 0x00000000L), HEXCONSTE(-3.63419362147803445275e+134, 0xc1be, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-3.72917036560010337165e-155, 0xbdfe, 0x80000000L, 0x00000000L), HEXCONSTE(-3.00000000000000000000e+00, 0xc000, 0xc0000000L, 0x00000000L), HEXCONSTE(-1.92824994153682607086e+463, 0xc602, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-4.00000000000000000000e+00, 0xc001, 0x80000000L, 0x00000000L), HEXCONSTE(2.59344723055062059907e+179, 0x4253, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-3.72917036560010337165e-155, 0xbdfe, 0x80000000L, 0x00000000L), HEXCONSTE(-4.00000000000000000000e+00, 0xc001, 0x80000000L, 0x00000000L), HEXCONSTE(5.17072097140976116811e+617, 0x4803, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-5.00000000000000000000e+00, 0xc001, 0xa0000000L, 0x00000000L), HEXCONSTE(-1.85074578797901741880e+224, 0xc2e8, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-3.72917036560010337165e-155, 0xbdfe, 0x80000000L, 0x00000000L), HEXCONSTE(-5.00000000000000000000e+00, 0xc001, 0xa0000000L, 0x00000000L), HEXCONSTE(-1.38656067287976569376e+772, 0xca04, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-3.00000000000000000000e+00, 0xc000, 0xc0000000L, 0x00000000L), HEXCONSTE(-3.63419362147803445275e+134, 0xc1be, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-1.11619862429909666232e-103, 0xbea9, 0x80000000L, 0x00000000L), HEXCONSTE(-3.00000000000000000000e+00, 0xc000, 0xc0000000L, 0x00000000L), HEXCONSTE(-7.19077253944926363092e+308, 0xc401, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-4.00000000000000000000e+00, 0xc001, 0x80000000L, 0x00000000L), HEXCONSTE(2.59344723055062059907e+179, 0x4253, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-1.11619862429909666232e-103, 0xbea9, 0x80000000L, 0x00000000L), HEXCONSTE(-4.00000000000000000000e+00, 0xc001, 0x80000000L, 0x00000000L), HEXCONSTE(6.44219799497121017112e+411, 0x4557, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-5.00000000000000000000e+00, 0xc001, 0xa0000000L, 0x00000000L), HEXCONSTE(-1.85074578797901741880e+224, 0xc2e8, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-1.11619862429909666232e-103, 0xbea9, 0x80000000L, 0x00000000L), HEXCONSTE(-5.00000000000000000000e+00, 0xc001, 0xa0000000L, 0x00000000L), HEXCONSTE(-5.77155163492206414036e+514, 0xc6ad, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-4.00000000000000000000e+00, 0xc001, 0x80000000L, 0x00000000L), HEXCONSTE(2.59344723055062059907e+179, 0x4253, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-4.31808427754722231269e-78, 0xbefe, 0x80000000L, 0x00000000L), HEXCONSTE(-4.00000000000000000000e+00, 0xc001, 0x80000000L, 0x00000000L), HEXCONSTE(2.87630901577970545237e+309, 0x4403, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-5.00000000000000000000e+00, 0xc001, 0xa0000000L, 0x00000000L), HEXCONSTE(-1.85074578797901741880e+224, 0xc2e8, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-4.31808427754722231269e-78, 0xbefe, 0x80000000L, 0x00000000L), HEXCONSTE(-5.00000000000000000000e+00, 0xc001, 0xa0000000L, 0x00000000L), HEXCONSTE(-6.66107660458521541243e+386, 0xc504, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-5.00000000000000000000e+00, 0xc001, 0xa0000000L, 0x00000000L), HEXCONSTE(-1.85074578797901741880e+224, 0xc2e8, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-1.94469227433160678348e-62, 0xbf32, 0x80000000L, 0x00000000L), HEXCONSTE(-5.00000000000000000000e+00, 0xc001, 0xa0000000L, 0x00000000L), HEXCONSTE(-3.59538626972463181546e+308, 0xc400, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(1.15792075433823913219e+77, 0x40fe, 0xfffffe00L, 0x00010000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(3.23170060713110001249e+616, 0x47fe, 0xffffffffL, 0xfffff000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-1.09074813561941592946e+2466, 0xdfff, 0x80000000L, 0x00000000L), HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(3.00000000000000000000e+00, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(-3.94019991507671508429e+115, 0xc17e, 0xfffffd00L, 0x00030000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(3.00000000000000000000e+00, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(-5.80960599536995612787e+924, 0xcbfe, 0xffffffffL, 0xffffe800L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-1.09074813561941592946e+2466, 0xdfff, 0x80000000L, 0x00000000L), HEXCONSTE(3.00000000000000000000e+00, 0x4000, 0xc0000000L, 0x00000000L), INF_M, 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(4.00000000000000000000e+00, 0x4001, 0x80000000L, 0x00000000L), HEXCONSTE(1.34078047332723673806e+154, 0x41fe, 0xfffffc00L, 0x00060000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(4.00000000000000000000e+00, 0x4001, 0x80000000L, 0x00000000L), HEXCONSTE(1.04438888141315204289e+1233, 0x4ffe, 0xffffffffL, 0xffffe000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-1.09074813561941592946e+2466, 0xdfff, 0x80000000L, 0x00000000L), HEXCONSTE(4.00000000000000000000e+00, 0x4001, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(5.00000000000000000000e+00, 0x4001, 0xa0000000L, 0x00000000L), HEXCONSTE(-4.56243925790909569817e+192, 0xc27e, 0xfffffb00L, 0x000a0000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(5.00000000000000000000e+00, 0x4001, 0xa0000000L, 0x00000000L), HEXCONSTE(-1.87749072224295658266e+1541, 0xd3fe, 0xffffffffL, 0xffffd800L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-1.09074813561941592946e+2466, 0xdfff, 0x80000000L, 0x00000000L), HEXCONSTE(5.00000000000000000000e+00, 0x4001, 0xa0000000L, 0x00000000L), INF_M, 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(3.00000000000000000000e+00, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(-3.94019991507671508429e+115, 0xc17e, 0xfffffd00L, 0x00030000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(3.00000000000000000000e+00, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(-5.80960599536995612787e+924, 0xcbfe, 0xffffffffL, 0xffffe800L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-1.68203998945250901701e+1644, 0xd555, 0x80000000L, 0x00000000L), HEXCONSTE(3.00000000000000000000e+00, 0x4000, 0xc0000000L, 0x00000000L), INF_M, 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(4.00000000000000000000e+00, 0x4001, 0x80000000L, 0x00000000L), HEXCONSTE(1.34078047332723673806e+154, 0x41fe, 0xfffffc00L, 0x00060000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(4.00000000000000000000e+00, 0x4001, 0x80000000L, 0x00000000L), HEXCONSTE(1.04438888141315204289e+1233, 0x4ffe, 0xffffffffL, 0xffffe000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-1.68203998945250901701e+1644, 0xd555, 0x80000000L, 0x00000000L), HEXCONSTE(4.00000000000000000000e+00, 0x4001, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(5.00000000000000000000e+00, 0x4001, 0xa0000000L, 0x00000000L), HEXCONSTE(-4.56243925790909569817e+192, 0xc27e, 0xfffffb00L, 0x000a0000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(5.00000000000000000000e+00, 0x4001, 0xa0000000L, 0x00000000L), HEXCONSTE(-1.87749072224295658266e+1541, 0xd3fe, 0xffffffffL, 0xffffd800L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-1.68203998945250901701e+1644, 0xd555, 0x80000000L, 0x00000000L), HEXCONSTE(5.00000000000000000000e+00, 0x4001, 0xa0000000L, 0x00000000L), INF_M, 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(4.00000000000000000000e+00, 0x4001, 0x80000000L, 0x00000000L), HEXCONSTE(1.34078047332723673806e+154, 0x41fe, 0xfffffc00L, 0x00060000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(4.00000000000000000000e+00, 0x4001, 0x80000000L, 0x00000000L), HEXCONSTE(1.04438888141315204289e+1233, 0x4ffe, 0xffffffffL, 0xffffe000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-2.08877776282630501338e+1233, 0xd000, 0x80000000L, 0x00000000L), HEXCONSTE(4.00000000000000000000e+00, 0x4001, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(5.00000000000000000000e+00, 0x4001, 0xa0000000L, 0x00000000L), HEXCONSTE(-4.56243925790909569817e+192, 0xc27e, 0xfffffb00L, 0x000a0000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(5.00000000000000000000e+00, 0x4001, 0xa0000000L, 0x00000000L), HEXCONSTE(-1.87749072224295658266e+1541, 0xd3fe, 0xffffffffL, 0xffffd800L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-2.08877776282630501338e+1233, 0xd000, 0x80000000L, 0x00000000L), HEXCONSTE(5.00000000000000000000e+00, 0x4001, 0xa0000000L, 0x00000000L), INF_M, 0 },
	{ __LINE__,  HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(5.00000000000000000000e+00, 0x4001, 0xa0000000L, 0x00000000L), HEXCONSTE(-4.56243925790909569817e+192, 0xc27e, 0xfffffb00L, 0x000a0000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(5.00000000000000000000e+00, 0x4001, 0xa0000000L, 0x00000000L), HEXCONSTE(-1.87749072224295658266e+1541, 0xd3fe, 0xffffffffL, 0xffffd800L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-2.98741660675683357550e+986, 0xcccc, 0x80000000L, 0x00000000L), HEXCONSTE(5.00000000000000000000e+00, 0x4001, 0xa0000000L, 0x00000000L), INF_M, 0 },
	{ __LINE__,  HEXCONSTE(-1.84467440737095516160e+19, 0xc03f, 0x80000000L, 0x00000000L), HEXCONSTE(2.57000000000000000000e+02, 0x4007, 0x80800000L, 0x00000000L), INF_M, 0 },
	{ __LINE__,  HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(5.09258994083621521567e+89, 0x4129, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(4.09666721438767321452e+646, 0x4863, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-9.16801933777423582811e-2467, 0x9fff, 0x80000000L, 0x00000000L), HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-3.00000000000000000000e+00, 0xc000, 0xc0000000L, 0x00000000L), HEXCONSTE(-3.63419362147803445275e+134, 0xc1be, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-3.00000000000000000000e+00, 0xc000, 0xc0000000L, 0x00000000L), HEXCONSTE(-8.29174675242248408884e+969, 0xcc95, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-9.16801933777423582811e-2467, 0x9fff, 0x80000000L, 0x00000000L), HEXCONSTE(-3.00000000000000000000e+00, 0xc000, 0xc0000000L, 0x00000000L), INF_M, 0 },
	{ __LINE__,  HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-4.00000000000000000000e+00, 0xc001, 0x80000000L, 0x00000000L), HEXCONSTE(2.59344723055062059907e+179, 0x4253, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-4.00000000000000000000e+00, 0xc001, 0x80000000L, 0x00000000L), HEXCONSTE(1.67826822654388580915e+1293, 0x50c7, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-9.16801933777423582811e-2467, 0x9fff, 0x80000000L, 0x00000000L), HEXCONSTE(-4.00000000000000000000e+00, 0xc001, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-5.00000000000000000000e+00, 0xc001, 0xa0000000L, 0x00000000L), HEXCONSTE(-1.85074578797901741880e+224, 0xc2e8, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-5.00000000000000000000e+00, 0xc001, 0xa0000000L, 0x00000000L), HEXCONSTE(-3.39685270706546537607e+1616, 0xd4f9, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-9.16801933777423582811e-2467, 0x9fff, 0x80000000L, 0x00000000L), HEXCONSTE(-5.00000000000000000000e+00, 0xc001, 0xa0000000L, 0x00000000L), INF_M, 0 },
	{ __LINE__,  HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-3.00000000000000000000e+00, 0xc000, 0xc0000000L, 0x00000000L), HEXCONSTE(-3.63419362147803445275e+134, 0xc1be, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-3.00000000000000000000e+00, 0xc000, 0xc0000000L, 0x00000000L), HEXCONSTE(-8.29174675242248408884e+969, 0xcc95, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-5.94516186458499272259e-1645, 0xaaa9, 0x80000000L, 0x00000000L), HEXCONSTE(-3.00000000000000000000e+00, 0xc000, 0xc0000000L, 0x00000000L), INF_M, 0 },
	{ __LINE__,  HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-4.00000000000000000000e+00, 0xc001, 0x80000000L, 0x00000000L), HEXCONSTE(2.59344723055062059907e+179, 0x4253, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-4.00000000000000000000e+00, 0xc001, 0x80000000L, 0x00000000L), HEXCONSTE(1.67826822654388580915e+1293, 0x50c7, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-5.94516186458499272259e-1645, 0xaaa9, 0x80000000L, 0x00000000L), HEXCONSTE(-4.00000000000000000000e+00, 0xc001, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-5.00000000000000000000e+00, 0xc001, 0xa0000000L, 0x00000000L), HEXCONSTE(-1.85074578797901741880e+224, 0xc2e8, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-5.00000000000000000000e+00, 0xc001, 0xa0000000L, 0x00000000L), HEXCONSTE(-3.39685270706546537607e+1616, 0xd4f9, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-5.94516186458499272259e-1645, 0xaaa9, 0x80000000L, 0x00000000L), HEXCONSTE(-5.00000000000000000000e+00, 0xc001, 0xa0000000L, 0x00000000L), INF_M, 0 },
	{ __LINE__,  HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-4.00000000000000000000e+00, 0xc001, 0x80000000L, 0x00000000L), HEXCONSTE(2.59344723055062059907e+179, 0x4253, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-4.00000000000000000000e+00, 0xc001, 0x80000000L, 0x00000000L), HEXCONSTE(1.67826822654388580915e+1293, 0x50c7, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-4.78748873047609267897e-1234, 0xaffe, 0x80000000L, 0x00000000L), HEXCONSTE(-4.00000000000000000000e+00, 0xc001, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-5.00000000000000000000e+00, 0xc001, 0xa0000000L, 0x00000000L), HEXCONSTE(-1.85074578797901741880e+224, 0xc2e8, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-5.00000000000000000000e+00, 0xc001, 0xa0000000L, 0x00000000L), HEXCONSTE(-3.39685270706546537607e+1616, 0xd4f9, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-4.78748873047609267897e-1234, 0xaffe, 0x80000000L, 0x00000000L), HEXCONSTE(-5.00000000000000000000e+00, 0xc001, 0xa0000000L, 0x00000000L), INF_M, 0 },
	{ __LINE__,  HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-5.00000000000000000000e+00, 0xc001, 0xa0000000L, 0x00000000L), HEXCONSTE(-1.85074578797901741880e+224, 0xc2e8, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-5.00000000000000000000e+00, 0xc001, 0xa0000000L, 0x00000000L), HEXCONSTE(-3.39685270706546537607e+1616, 0xd4f9, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.34737377350797089948e-987, 0xb332, 0x80000000L, 0x00000000L), HEXCONSTE(-5.00000000000000000000e+00, 0xc001, 0xa0000000L, 0x00000000L), INF_M, 0 },
	{ __LINE__,  HEXCONSTE(-5.42101086242752217004e-20, 0xbfbf, 0x80000000L, 0x00000000L), HEXCONSTE(-2.57000000000000000000e+02, 0xc007, 0x80800000L, 0x00000000L), INF_M, 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.26000000000000000000e+02, 0x4005, 0xfc000000L, 0x00000000L), HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.27000000000000000000e+02, 0x4005, 0xfe000000L, 0x00000000L), HEXCONSTE(-5.87747175411143753984e-39, 0xbf80, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(-1.26000000000000000000e+02, 0xc005, 0xfc000000L, 0x00000000L), HEXCONSTE(8.50705917302346158658e+37, 0x407d, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(-1.27000000000000000000e+02, 0xc005, 0xfe000000L, 0x00000000L), HEXCONSTE(-1.70141183460469231732e+38, 0xc07e, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(-1.67772150000000000000e+07, 0xc016, 0xffffff00L, 0x00000000L), INF_M, 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(-3.35544300000000000000e+07, 0xc017, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(-9.00719871787008000000e+15, 0xc033, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(-9.00719925474099200000e+15, 0xc034, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(-9.00719925474099100000e+15, 0xc033, 0xffffffffL, 0xfffff800L), INF_M, 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(-1.80143974357401600000e+16, 0xc034, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(-1.80143985094819840000e+16, 0xc035, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(-1.80143985094819820000e+16, 0xc034, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(-1.84467429741979238400e+19, 0xc03e, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(-1.84467440737095516160e+19, 0xc03f, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(-1.84467440737095495680e+19, 0xc03e, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(-1.84467440737095516150e+19, 0xc03e, 0xffffffffL, 0xffffffffL), INF_M, 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(-3.68934859483958476800e+19, 0xc03f, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(-3.68934881474191032320e+19, 0xc040, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(-3.68934881474190991360e+19, 0xc03f, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(-3.68934881474191032300e+19, 0xc03f, 0xffffffffL, 0xffffffffL), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(-8.11296335789034032373e+31, 0xc068, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(-8.11296384146066816958e+31, 0xc069, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(-8.11296384146066726886e+31, 0xc068, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(-8.11296384146066816914e+31, 0xc068, 0xffffffffL, 0xffffffffL), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(-1.62259267157806806475e+32, 0xc069, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(-1.62259276829213363392e+32, 0xc06a, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(-1.62259276829213345377e+32, 0xc069, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(-1.62259276829213363383e+32, 0xc069, 0xffffffffL, 0xffffffffL), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(-1.03845930980996356144e+34, 0xc06f, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(-1.03845937170696552571e+34, 0xc070, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(-1.03845937170696541041e+34, 0xc06f, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(-1.03845937170696552565e+34, 0xc06f, 0xffffffffL, 0xffffffffL), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(-2.07691861961992712287e+34, 0xc070, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(-2.07691874341393105141e+34, 0xc071, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(-2.07691874341393082083e+34, 0xc070, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(-2.07691874341393105130e+34, 0xc070, 0xffffffffL, 0xffffffffL), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), INF_P, 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), INF_P, 0 },
#endif
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.67772150000000000000e+07, 0x4016, 0xffffff00L, 0x00000000L), ZERO_P, FLAG_IGNORE_ZEROSIGN },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(3.35544300000000000000e+07, 0x4017, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(9.00719925474099200000e+15, 0x4034, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(9.00719871787008000000e+15, 0x4033, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(9.00719925474099100000e+15, 0x4033, 0xffffffffL, 0xfffff800L), ZERO_P, FLAG_IGNORE_ZEROSIGN },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.80143985094819840000e+16, 0x4035, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.80143974357401600000e+16, 0x4034, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.80143985094819820000e+16, 0x4034, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.84467440737095516160e+19, 0x403f, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.84467429741979238400e+19, 0x403e, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.84467440737095495680e+19, 0x403e, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.84467440737095516150e+19, 0x403e, 0xffffffffL, 0xffffffffL), ZERO_P, FLAG_IGNORE_ZEROSIGN },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(3.68934881474191032320e+19, 0x4040, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(3.68934859483958476800e+19, 0x403f, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(3.68934881474190991360e+19, 0x403f, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(3.68934881474191032300e+19, 0x403f, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(8.11296384146066816958e+31, 0x4069, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(8.11296335789034032373e+31, 0x4068, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(8.11296384146066726886e+31, 0x4068, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(8.11296384146066816914e+31, 0x4068, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.62259276829213363392e+32, 0x406a, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.62259267157806806475e+32, 0x4069, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.62259276829213345377e+32, 0x4069, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.62259276829213363383e+32, 0x4069, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.03845937170696552571e+34, 0x4070, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.03845930980996356144e+34, 0x406f, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.03845937170696541041e+34, 0x406f, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.03845937170696552565e+34, 0x406f, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(2.07691874341393105141e+34, 0x4071, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(2.07691861961992712287e+34, 0x4070, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(2.07691874341393082083e+34, 0x4070, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(2.07691874341393105130e+34, 0x4070, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#endif
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(7.23700557733226221397e+75, 0x40fb, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(2.01981287945693795629e+615, 0x47fb, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(2.48961158822727886846e+583, 0x4791, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-3.00000000000000000000e+00, 0xc000, 0xc0000000L, 0x00000000L), HEXCONSTE(-6.15656346818663737692e+113, 0xc179, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-3.00000000000000000000e+00, 0xc000, 0xc0000000L, 0x00000000L), HEXCONSTE(-9.07750936776555947322e+922, 0xcbf9, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-3.00000000000000000000e+00, 0xc000, 0xc0000000L, 0x00000000L), INF_M, 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-3.00000000000000000000e+00, 0xc000, 0xc0000000L, 0x00000000L), INF_M, 0 },
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-3.00000000000000000000e+00, 0xc000, 0xc0000000L, 0x00000000L), HEXCONSTE(-1.24221679071718941465e+875, 0xcb5a, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(1.38178696881511114006e-76, 0x3f03, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(4.95095367581212524077e-616, 0x3803, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(4.01669081526105551552e-584, 0x386d, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(3.00000000000000000000e+00, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(-1.62428277588201550290e-114, 0xbe85, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(3.00000000000000000000e+00, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(-1.10162375987296973446e-923, 0xb405, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(3.00000000000000000000e+00, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(3.00000000000000000000e+00, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(3.00000000000000000000e+00, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(-8.05012464388485347938e-876, 0xb4a4, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.67772150000000000000e+07, 0xc016, 0xffffff00L, 0x00000000L), INF_M, 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-1.67772150000000000000e+07, 0xc016, 0xffffff00L, 0x00000000L), INF_M, 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-1.67772150000000000000e+07, 0xc016, 0xffffff00L, 0x00000000L), INF_M, 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.67772150000000000000e+07, 0xc016, 0xffffff00L, 0x00000000L), INF_M, 0 },
#endif
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-1.67772150000000000000e+07, 0xc016, 0xffffff00L, 0x00000000L), INF_M, 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-3.35544300000000000000e+07, 0xc017, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-3.35544300000000000000e+07, 0xc017, 0xffffff00L, 0x00000000L), INF_P, 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-3.35544300000000000000e+07, 0xc017, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-3.35544300000000000000e+07, 0xc017, 0xffffff00L, 0x00000000L), INF_P, 0 },
#endif
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-3.35544300000000000000e+07, 0xc017, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-9.00719871787008000000e+15, 0xc033, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-9.00719925474099200000e+15, 0xc034, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-9.00719925474099100000e+15, 0xc033, 0xffffffffL, 0xfffff800L), INF_M, 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-9.00719871787008000000e+15, 0xc033, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-9.00719925474099200000e+15, 0xc034, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-9.00719925474099100000e+15, 0xc033, 0xffffffffL, 0xfffff800L), INF_M, 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-9.00719871787008000000e+15, 0xc033, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-9.00719925474099200000e+15, 0xc034, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-9.00719925474099100000e+15, 0xc033, 0xffffffffL, 0xfffff800L), INF_M, 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-9.00719871787008000000e+15, 0xc033, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-9.00719925474099200000e+15, 0xc034, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-9.00719925474099100000e+15, 0xc033, 0xffffffffL, 0xfffff800L), INF_M, 0 },
#endif
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-9.00719871787008000000e+15, 0xc033, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-9.00719925474099200000e+15, 0xc034, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-9.00719925474099100000e+15, 0xc033, 0xffffffffL, 0xfffff800L), INF_M, 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.80143974357401600000e+16, 0xc034, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.80143985094819840000e+16, 0xc035, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.80143985094819820000e+16, 0xc034, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-1.80143974357401600000e+16, 0xc034, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-1.80143985094819840000e+16, 0xc035, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-1.80143985094819820000e+16, 0xc034, 0xffffffffL, 0xfffff800L), INF_P, 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-1.80143974357401600000e+16, 0xc034, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-1.80143985094819840000e+16, 0xc035, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-1.80143985094819820000e+16, 0xc034, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.80143974357401600000e+16, 0xc034, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.80143985094819840000e+16, 0xc035, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.80143985094819820000e+16, 0xc034, 0xffffffffL, 0xfffff800L), INF_P, 0 },
#endif
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-1.80143974357401600000e+16, 0xc034, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-1.80143985094819840000e+16, 0xc035, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-1.80143985094819820000e+16, 0xc034, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.84467429741979238400e+19, 0xc03e, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.84467440737095516160e+19, 0xc03f, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.84467440737095495680e+19, 0xc03e, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.84467440737095516150e+19, 0xc03e, 0xffffffffL, 0xffffffffL), INF_M, 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-1.84467429741979238400e+19, 0xc03e, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-1.84467440737095516160e+19, 0xc03f, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-1.84467440737095495680e+19, 0xc03e, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-1.84467440737095516150e+19, 0xc03e, 0xffffffffL, 0xffffffffL), INF_M, 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-1.84467429741979238400e+19, 0xc03e, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-1.84467440737095516160e+19, 0xc03f, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-1.84467440737095495680e+19, 0xc03e, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-1.84467440737095516150e+19, 0xc03e, 0xffffffffL, 0xffffffffL), INF_M, 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.84467429741979238400e+19, 0xc03e, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.84467440737095516160e+19, 0xc03f, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.84467440737095495680e+19, 0xc03e, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.84467440737095516150e+19, 0xc03e, 0xffffffffL, 0xffffffffL), INF_M, 0 },
#endif
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-1.84467429741979238400e+19, 0xc03e, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-1.84467440737095516160e+19, 0xc03f, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-1.84467440737095495680e+19, 0xc03e, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-1.84467440737095516150e+19, 0xc03e, 0xffffffffL, 0xffffffffL), INF_M, 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-3.68934859483958476800e+19, 0xc03f, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-3.68934881474191032320e+19, 0xc040, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-3.68934881474190991360e+19, 0xc03f, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-3.68934881474191032300e+19, 0xc03f, 0xffffffffL, 0xffffffffL), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-3.68934859483958476800e+19, 0xc03f, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-3.68934881474191032320e+19, 0xc040, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-3.68934881474190991360e+19, 0xc03f, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-3.68934881474191032300e+19, 0xc03f, 0xffffffffL, 0xffffffffL), INF_P, 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-3.68934859483958476800e+19, 0xc03f, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-3.68934881474191032320e+19, 0xc040, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-3.68934881474190991360e+19, 0xc03f, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-3.68934881474191032300e+19, 0xc03f, 0xffffffffL, 0xffffffffL), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-3.68934859483958476800e+19, 0xc03f, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-3.68934881474191032320e+19, 0xc040, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-3.68934881474190991360e+19, 0xc03f, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-3.68934881474191032300e+19, 0xc03f, 0xffffffffL, 0xffffffffL), INF_P, 0 },
#endif
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-3.68934859483958476800e+19, 0xc03f, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-3.68934881474191032320e+19, 0xc040, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-3.68934881474190991360e+19, 0xc03f, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-3.68934881474191032300e+19, 0xc03f, 0xffffffffL, 0xffffffffL), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-8.11296335789034032373e+31, 0xc068, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-8.11296384146066816958e+31, 0xc069, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-8.11296384146066726886e+31, 0xc068, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-8.11296384146066816914e+31, 0xc068, 0xffffffffL, 0xffffffffL), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-8.11296335789034032373e+31, 0xc068, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-8.11296384146066816958e+31, 0xc069, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-8.11296384146066726886e+31, 0xc068, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-8.11296384146066816914e+31, 0xc068, 0xffffffffL, 0xffffffffL), INF_P, 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-8.11296335789034032373e+31, 0xc068, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-8.11296384146066816958e+31, 0xc069, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-8.11296384146066726886e+31, 0xc068, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-8.11296384146066816914e+31, 0xc068, 0xffffffffL, 0xffffffffL), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-8.11296335789034032373e+31, 0xc068, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-8.11296384146066816958e+31, 0xc069, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-8.11296384146066726886e+31, 0xc068, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-8.11296384146066816914e+31, 0xc068, 0xffffffffL, 0xffffffffL), INF_P, 0 },
#endif
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-8.11296335789034032373e+31, 0xc068, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-8.11296384146066816958e+31, 0xc069, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-8.11296384146066726886e+31, 0xc068, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-8.11296384146066816914e+31, 0xc068, 0xffffffffL, 0xffffffffL), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.62259267157806806475e+32, 0xc069, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.62259276829213363392e+32, 0xc06a, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.62259276829213345377e+32, 0xc069, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.62259276829213363383e+32, 0xc069, 0xffffffffL, 0xffffffffL), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-1.62259267157806806475e+32, 0xc069, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-1.62259276829213363392e+32, 0xc06a, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-1.62259276829213345377e+32, 0xc069, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-1.62259276829213363383e+32, 0xc069, 0xffffffffL, 0xffffffffL), INF_P, 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-1.62259267157806806475e+32, 0xc069, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-1.62259276829213363392e+32, 0xc06a, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-1.62259276829213345377e+32, 0xc069, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-1.62259276829213363383e+32, 0xc069, 0xffffffffL, 0xffffffffL), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.62259267157806806475e+32, 0xc069, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.62259276829213363392e+32, 0xc06a, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.62259276829213345377e+32, 0xc069, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.62259276829213363383e+32, 0xc069, 0xffffffffL, 0xffffffffL), INF_P, 0 },
#endif
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-1.62259267157806806475e+32, 0xc069, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-1.62259276829213363392e+32, 0xc06a, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-1.62259276829213345377e+32, 0xc069, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-1.62259276829213363383e+32, 0xc069, 0xffffffffL, 0xffffffffL), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.03845930980996356144e+34, 0xc06f, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.03845937170696552571e+34, 0xc070, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.03845937170696541041e+34, 0xc06f, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.03845937170696552565e+34, 0xc06f, 0xffffffffL, 0xffffffffL), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-1.03845930980996356144e+34, 0xc06f, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-1.03845937170696552571e+34, 0xc070, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-1.03845937170696541041e+34, 0xc06f, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-1.03845937170696552565e+34, 0xc06f, 0xffffffffL, 0xffffffffL), INF_P, 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-1.03845930980996356144e+34, 0xc06f, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-1.03845937170696552571e+34, 0xc070, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-1.03845937170696541041e+34, 0xc06f, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-1.03845937170696552565e+34, 0xc06f, 0xffffffffL, 0xffffffffL), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.03845930980996356144e+34, 0xc06f, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.03845937170696552571e+34, 0xc070, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.03845937170696541041e+34, 0xc06f, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.03845937170696552565e+34, 0xc06f, 0xffffffffL, 0xffffffffL), INF_P, 0 },
#endif
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-1.03845930980996356144e+34, 0xc06f, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-1.03845937170696552571e+34, 0xc070, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-1.03845937170696541041e+34, 0xc06f, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-1.03845937170696552565e+34, 0xc06f, 0xffffffffL, 0xffffffffL), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-2.07691861961992712287e+34, 0xc070, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-2.07691874341393105141e+34, 0xc071, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-2.07691874341393082083e+34, 0xc070, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-2.07691874341393105130e+34, 0xc070, 0xffffffffL, 0xffffffffL), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-2.07691861961992712287e+34, 0xc070, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-2.07691874341393105141e+34, 0xc071, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-2.07691874341393082083e+34, 0xc070, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-2.07691874341393105130e+34, 0xc070, 0xffffffffL, 0xffffffffL), INF_P, 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-2.07691861961992712287e+34, 0xc070, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-2.07691874341393105141e+34, 0xc071, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-2.07691874341393082083e+34, 0xc070, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-2.07691874341393105130e+34, 0xc070, 0xffffffffL, 0xffffffffL), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-2.07691861961992712287e+34, 0xc070, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-2.07691874341393105141e+34, 0xc071, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-2.07691874341393082083e+34, 0xc070, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-2.07691874341393105130e+34, 0xc070, 0xffffffffL, 0xffffffffL), INF_P, 0 },
#endif
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-2.07691861961992712287e+34, 0xc070, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-2.07691874341393105141e+34, 0xc071, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-2.07691874341393082083e+34, 0xc070, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-2.07691874341393105130e+34, 0xc070, 0xffffffffL, 0xffffffffL), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), INF_P, 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), INF_P, 0 },
#endif
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), INF_P, 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), INF_P, 0 },
#endif
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), INF_P, 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), INF_P, 0 },
#endif
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(1.67772150000000000000e+07, 0x4016, 0xffffff00L, 0x00000000L), ZERO_P, FLAG_IGNORE_ZEROSIGN },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(1.67772150000000000000e+07, 0x4016, 0xffffff00L, 0x00000000L), ZERO_P, FLAG_IGNORE_ZEROSIGN },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(1.67772150000000000000e+07, 0x4016, 0xffffff00L, 0x00000000L), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(1.67772150000000000000e+07, 0x4016, 0xffffff00L, 0x00000000L), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(1.67772150000000000000e+07, 0x4016, 0xffffff00L, 0x00000000L), ZERO_P, FLAG_IGNORE_ZEROSIGN },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(3.35544300000000000000e+07, 0x4017, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(3.35544300000000000000e+07, 0x4017, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(3.35544300000000000000e+07, 0x4017, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(3.35544300000000000000e+07, 0x4017, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(3.35544300000000000000e+07, 0x4017, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(9.00719925474099200000e+15, 0x4034, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(9.00719871787008000000e+15, 0x4033, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(9.00719925474099100000e+15, 0x4033, 0xffffffffL, 0xfffff800L), ZERO_P, FLAG_IGNORE_ZEROSIGN },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(9.00719925474099200000e+15, 0x4034, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(9.00719871787008000000e+15, 0x4033, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(9.00719925474099100000e+15, 0x4033, 0xffffffffL, 0xfffff800L), ZERO_P, FLAG_IGNORE_ZEROSIGN },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(9.00719925474099200000e+15, 0x4034, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(9.00719871787008000000e+15, 0x4033, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(9.00719925474099100000e+15, 0x4033, 0xffffffffL, 0xfffff800L), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(9.00719925474099200000e+15, 0x4034, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(9.00719871787008000000e+15, 0x4033, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(9.00719925474099100000e+15, 0x4033, 0xffffffffL, 0xfffff800L), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), 0 },
#endif
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(9.00719925474099200000e+15, 0x4034, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(9.00719871787008000000e+15, 0x4033, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(9.00719925474099100000e+15, 0x4033, 0xffffffffL, 0xfffff800L), ZERO_P, FLAG_IGNORE_ZEROSIGN },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(1.80143985094819840000e+16, 0x4035, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(1.80143974357401600000e+16, 0x4034, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(1.80143985094819820000e+16, 0x4034, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(1.80143985094819840000e+16, 0x4035, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(1.80143974357401600000e+16, 0x4034, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(1.80143985094819820000e+16, 0x4034, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(1.80143985094819840000e+16, 0x4035, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(1.80143974357401600000e+16, 0x4034, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(1.80143985094819820000e+16, 0x4034, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(1.80143985094819840000e+16, 0x4035, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(1.80143974357401600000e+16, 0x4034, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(1.80143985094819820000e+16, 0x4034, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#endif
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(1.80143985094819840000e+16, 0x4035, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(1.80143974357401600000e+16, 0x4034, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(1.80143985094819820000e+16, 0x4034, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(1.84467440737095516160e+19, 0x403f, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(1.84467429741979238400e+19, 0x403e, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(1.84467440737095495680e+19, 0x403e, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(1.84467440737095516150e+19, 0x403e, 0xffffffffL, 0xffffffffL), ZERO_P, FLAG_IGNORE_ZEROSIGN },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(1.84467440737095516160e+19, 0x403f, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(1.84467429741979238400e+19, 0x403e, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(1.84467440737095495680e+19, 0x403e, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(1.84467440737095516150e+19, 0x403e, 0xffffffffL, 0xffffffffL), ZERO_P, FLAG_IGNORE_ZEROSIGN },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(1.84467440737095516160e+19, 0x403f, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(1.84467429741979238400e+19, 0x403e, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(1.84467440737095495680e+19, 0x403e, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(1.84467440737095516150e+19, 0x403e, 0xffffffffL, 0xffffffffL), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(1.84467440737095516160e+19, 0x403f, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(1.84467429741979238400e+19, 0x403e, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(1.84467440737095495680e+19, 0x403e, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(1.84467440737095516150e+19, 0x403e, 0xffffffffL, 0xffffffffL), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), 0 },
#endif
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(1.84467440737095516160e+19, 0x403f, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(1.84467429741979238400e+19, 0x403e, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(1.84467440737095495680e+19, 0x403e, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(1.84467440737095516150e+19, 0x403e, 0xffffffffL, 0xffffffffL), ZERO_P, FLAG_IGNORE_ZEROSIGN },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(3.68934881474191032320e+19, 0x4040, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(3.68934859483958476800e+19, 0x403f, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(3.68934881474190991360e+19, 0x403f, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(3.68934881474191032300e+19, 0x403f, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(3.68934881474191032320e+19, 0x4040, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(3.68934859483958476800e+19, 0x403f, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(3.68934881474190991360e+19, 0x403f, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(3.68934881474191032300e+19, 0x403f, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(3.68934881474191032320e+19, 0x4040, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(3.68934859483958476800e+19, 0x403f, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(3.68934881474190991360e+19, 0x403f, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(3.68934881474191032300e+19, 0x403f, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(3.68934881474191032320e+19, 0x4040, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(3.68934859483958476800e+19, 0x403f, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(3.68934881474190991360e+19, 0x403f, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(3.68934881474191032300e+19, 0x403f, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#endif
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(3.68934881474191032320e+19, 0x4040, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(3.68934859483958476800e+19, 0x403f, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(3.68934881474190991360e+19, 0x403f, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(3.68934881474191032300e+19, 0x403f, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(8.11296384146066816958e+31, 0x4069, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(8.11296335789034032373e+31, 0x4068, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(8.11296384146066726886e+31, 0x4068, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(8.11296384146066816914e+31, 0x4068, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(8.11296384146066816958e+31, 0x4069, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(8.11296335789034032373e+31, 0x4068, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(8.11296384146066726886e+31, 0x4068, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(8.11296384146066816914e+31, 0x4068, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(8.11296384146066816958e+31, 0x4069, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(8.11296335789034032373e+31, 0x4068, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(8.11296384146066726886e+31, 0x4068, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(8.11296384146066816914e+31, 0x4068, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(8.11296384146066816958e+31, 0x4069, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(8.11296335789034032373e+31, 0x4068, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(8.11296384146066726886e+31, 0x4068, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(8.11296384146066816914e+31, 0x4068, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#endif
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(8.11296384146066816958e+31, 0x4069, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(8.11296335789034032373e+31, 0x4068, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(8.11296384146066726886e+31, 0x4068, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(8.11296384146066816914e+31, 0x4068, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(1.62259276829213363392e+32, 0x406a, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(1.62259267157806806475e+32, 0x4069, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(1.62259276829213345377e+32, 0x4069, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(1.62259276829213363383e+32, 0x4069, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(1.62259276829213363392e+32, 0x406a, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(1.62259267157806806475e+32, 0x4069, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(1.62259276829213345377e+32, 0x4069, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(1.62259276829213363383e+32, 0x4069, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(1.62259276829213363392e+32, 0x406a, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(1.62259267157806806475e+32, 0x4069, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(1.62259276829213345377e+32, 0x4069, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(1.62259276829213363383e+32, 0x4069, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(1.62259276829213363392e+32, 0x406a, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(1.62259267157806806475e+32, 0x4069, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(1.62259276829213345377e+32, 0x4069, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(1.62259276829213363383e+32, 0x4069, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#endif
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(1.62259276829213363392e+32, 0x406a, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(1.62259267157806806475e+32, 0x4069, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(1.62259276829213345377e+32, 0x4069, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(1.62259276829213363383e+32, 0x4069, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(1.03845937170696552571e+34, 0x4070, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(1.03845930980996356144e+34, 0x406f, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(1.03845937170696541041e+34, 0x406f, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(1.03845937170696552565e+34, 0x406f, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(1.03845937170696552571e+34, 0x4070, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(1.03845930980996356144e+34, 0x406f, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(1.03845937170696541041e+34, 0x406f, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(1.03845937170696552565e+34, 0x406f, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(1.03845937170696552571e+34, 0x4070, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(1.03845930980996356144e+34, 0x406f, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(1.03845937170696541041e+34, 0x406f, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(1.03845937170696552565e+34, 0x406f, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(1.03845937170696552571e+34, 0x4070, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(1.03845930980996356144e+34, 0x406f, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(1.03845937170696541041e+34, 0x406f, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(1.03845937170696552565e+34, 0x406f, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#endif
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(1.03845937170696552571e+34, 0x4070, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(1.03845930980996356144e+34, 0x406f, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(1.03845937170696541041e+34, 0x406f, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(1.03845937170696552565e+34, 0x406f, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(2.07691874341393105141e+34, 0x4071, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(2.07691861961992712287e+34, 0x4070, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(2.07691874341393082083e+34, 0x4070, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(2.07691874341393105130e+34, 0x4070, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(2.07691874341393105141e+34, 0x4071, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(2.07691861961992712287e+34, 0x4070, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(2.07691874341393082083e+34, 0x4070, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(2.07691874341393105130e+34, 0x4070, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(2.07691874341393105141e+34, 0x4071, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(2.07691861961992712287e+34, 0x4070, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(2.07691874341393082083e+34, 0x4070, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(2.07691874341393105130e+34, 0x4070, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(2.07691874341393105141e+34, 0x4071, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(2.07691861961992712287e+34, 0x4070, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(2.07691874341393082083e+34, 0x4070, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(2.07691874341393105130e+34, 0x4070, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#endif
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(2.07691874341393105141e+34, 0x4071, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(2.07691861961992712287e+34, 0x4070, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(2.07691874341393082083e+34, 0x4070, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(2.07691874341393105130e+34, 0x4070, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#endif
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#endif
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+01, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(9.99999403953712118209e-01, 0x3ffe, 0xfffff600L, 0x002d0000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+02, 0x4005, 0xc8000000L, 0x00000000L), HEXCONSTE(9.99994039553108359387e-01, 0x3ffe, 0xffff9c00L, 0x1355fd88L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+03, 0x4008, 0xfa000000L, 0x00000000L), HEXCONSTE(9.99940397129769905239e-01, 0x3ffe, 0xfffc1807L, 0x9f221888L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(1.67772160000000000000e+07, 0x4017, 0x80000000L, 0x00000000L), HEXCONSTE(3.67879430207780343709e-01, 0x3ffd, 0xbc5ab153L, 0x3a20be44L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(1.07374182400000000000e+09, 0x401d, 0x80000000L, 0x00000000L), HEXCONSTE(1.60380783152492423385e-28, 0x3fa2, 0xcb4e8a2fL, 0x3c38e77bL), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(1.22167948800000000000e+09, 0x401d, 0x91a2b300L, 0x00000000L), HEXCONSTE(2.37488471213529509998e-32, 0x3f95, 0xf69f43d1L, 0xf84c9cb7L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+01, 0xc002, 0xa0000000L, 0x00000000L), HEXCONSTE(1.00000059604664315316e+00, 0x3fff, 0x80000500L, 0x001b8000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+02, 0xc005, 0xc8000000L, 0x00000000L), HEXCONSTE(1.00000596048241877946e+00, 0x3fff, 0x80003200L, 0x09dd014fL), 0 },
	{ __LINE__,  HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+03, 0xc008, 0xfa000000L, 0x00000000L), HEXCONSTE(1.00005960642294398639e+00, 0x3fff, 0x8001f403L, 0xd18efb67L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.67772160000000000000e+07, 0xc017, 0x80000000L, 0x00000000L), HEXCONSTE(2.71828190947016105406e+00, 0x4000, 0xadf854afL, 0x9ee5c6a9L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.07374182400000000000e+09, 0xc01d, 0x80000000L, 0x00000000L), HEXCONSTE(6.23516097342650579883e+27, 0x405b, 0xa12cd58dL, 0x463b2692L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.22167948800000000000e+09, 0xc01d, 0x91a2b300L, 0x00000000L), HEXCONSTE(4.21073071416963535004e+31, 0x4068, 0x84de0307L, 0x52c5106dL), 0 },
	{ __LINE__,  HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(1.67772160000000000000e+07, 0x4017, 0x80000000L, 0x00000000L), HEXCONSTE(7.38905521808664472825e+00, 0x4001, 0xec7323edL, 0xc0a63082L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(6.10839744000000000000e+08, 0x401c, 0x91a2b300L, 0x00000000L), HEXCONSTE(4.21070330065074951882e+31, 0x4068, 0x84ddca56L, 0xba2da80eL), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(-6.10839744000000000000e+08, 0xc01c, 0x91a2b300L, 0x00000000L), HEXCONSTE(2.37490017367277690992e-32, 0x3f95, 0xf69fad0bL, 0xc4745715L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(5.24707399690983833600e+18, 0x403d, 0x91a2b400L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(5.24707344715402444800e+18, 0x403d, 0x91a2b300L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(5.24707386985516134400e+18, 0x403d, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(5.24707399690983833600e+18, 0x403d, 0x91a2b400L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(5.24707344715402444800e+18, 0x403d, 0x91a2b300L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(5.24707386985516134400e+18, 0x403d, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(5.24707399690983833600e+18, 0x403d, 0x91a2b400L, 0x00000000L), HEXCONSTE(1.01186200145503886838e-253, 0x3cb6, 0xbdea0deeL, 0xfbcfce6dL), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(5.24707344715402444800e+18, 0x403d, 0x91a2b300L, 0x00000000L), HEXCONSTE(1.01192376249517930885e-253, 0x3cb6, 0xbded059dL, 0x22e416edL), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(5.24707386985516134400e+18, 0x403d, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(1.01187627478272528173e-253, 0x3cb6, 0xbdeabd7fL, 0xfdaef65fL), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-5.24707344715402444800e+18, 0xc03d, 0x91a2b300L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-5.24707399690983833600e+18, 0xc03d, 0x91a2b400L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-5.24707386985516134400e+18, 0xc03d, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-5.24707344715402444800e+18, 0xc03d, 0x91a2b300L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-5.24707399690983833600e+18, 0xc03d, 0x91a2b400L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-5.24707386985516134400e+18, 0xc03d, 0x91a2b3c4L, 0xd5e6f800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-5.24707344715402444800e+18, 0xc03d, 0x91a2b300L, 0x00000000L), HEXCONSTE(9.88216738318529097366e+252, 0x4347, 0xac87cd32L, 0xc350b66cL), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-5.24707399690983833600e+18, 0xc03d, 0x91a2b400L, 0x00000000L), HEXCONSTE(9.88277056122295797870e+252, 0x4347, 0xac8a7f57L, 0x5c615da0L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-5.24707386985516134400e+18, 0xc03d, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(9.88263115680545618108e+252, 0x4347, 0xac89dfd6L, 0x7a57811bL), 0 },
	{ __LINE__,  HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(2.62353699845491916800e+18, 0x403c, 0x91a2b400L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(2.62353672357701222400e+18, 0x403c, 0x91a2b300L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(2.62353693492758067200e+18, 0x403c, 0x91a2b3c4L, 0xd5e6f800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(2.62353699845491916800e+18, 0x403c, 0x91a2b400L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(2.62353672357701222400e+18, 0x403c, 0x91a2b300L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(2.62353693492758067200e+18, 0x403c, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(2.62353699845491916800e+18, 0x403c, 0x91a2b400L, 0x00000000L), HEXCONSTE(9.88277056122199922381e+252, 0x4347, 0xac8a7f57L, 0x5c4ef61bL), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(2.62353672357701222400e+18, 0x403c, 0x91a2b300L, 0x00000000L), HEXCONSTE(9.88216738318433227759e+252, 0x4347, 0xac87cd32L, 0xc33e4f31L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(2.62353693492758067200e+18, 0x403c, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(9.88263115680449743971e+252, 0x4347, 0xac89dfd6L, 0x7a4519a7L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(-2.62353672357701222400e+18, 0xc03c, 0x91a2b300L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(-2.62353699845491916800e+18, 0xc03c, 0x91a2b400L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(-2.62353693492758067200e+18, 0xc03c, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-2.62353672357701222400e+18, 0xc03c, 0x91a2b300L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-2.62353699845491916800e+18, 0xc03c, 0x91a2b400L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-2.62353693492758067200e+18, 0xc03c, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(-2.62353672357701222400e+18, 0xc03c, 0x91a2b300L, 0x00000000L), HEXCONSTE(1.01192376249527747837e-253, 0x3cb6, 0xbded059dL, 0x22f8592bL), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(-2.62353699845491916800e+18, 0xc03c, 0x91a2b400L, 0x00000000L), HEXCONSTE(1.01186200145513703191e-253, 0x3cb6, 0xbdea0deeL, 0xfbe4105aL), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(-2.62353693492758067200e+18, 0xc03c, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(1.01187627478282344667e-253, 0x3cb6, 0xbdeabd7fL, 0xfdc3385fL), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.71936120730741582594e+23, 0x404c, 0x91a2b400L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.71936102716343073112e+23, 0x404c, 0x91a2b300L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.71936116567413926920e+23, 0x404c, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.71936116567413893366e+23, 0x404c, 0x91a2b3c4L, 0xd5e6f000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.71936116567413924938e+23, 0x404c, 0x91a2b3c4L, 0xd5e6f787L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(1.71936120730741582594e+23, 0x404c, 0x91a2b400L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(1.71936102716343073112e+23, 0x404c, 0x91a2b300L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(1.71936116567413926920e+23, 0x404c, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(1.71936116567413893366e+23, 0x404c, 0x91a2b3c4L, 0xd5e6f000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(1.71936116567413924938e+23, 0x404c, 0x91a2b3c4L, 0xd5e6f787L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.71936120730741582594e+23, 0x404c, 0x91a2b400L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.71936102716343073112e+23, 0x404c, 0x91a2b300L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.71936116567413926920e+23, 0x404c, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.71936116567413893366e+23, 0x404c, 0x91a2b3c4L, 0xd5e6f000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.71936116567413924938e+23, 0x404c, 0x91a2b3c4L, 0xd5e6f787L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#if defined(TEST_LDOUBLE) && LDBL_MAX_EXP > 1024
	{ __LINE__,  HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.71936120730741582594e+23, 0x404c, 0x91a2b400L, 0x00000000L), HEXCONSTE(1.20764863229484099184e-4048, 0x0b78, 0x89e15c1eL, 0x4e6cded0L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.71936102716343073112e+23, 0x404c, 0x91a2b300L, 0x00000000L), HEXCONSTE(1.20882855270155586633e-4048, 0x0b78, 0x8a03d8c4L, 0xbcd2be3dL), 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.71936116567413926920e+23, 0x404c, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(1.20792122264190700422e-4048, 0x0b78, 0x89e953c0L, 0x65ee9108L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.71936116567413893366e+23, 0x404c, 0x91a2b3c4L, 0xd5e6f000L), HEXCONSTE(1.20792122264410420007e-4048, 0x0b78, 0x89e953c0L, 0x670263afL), 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.71936116567413924938e+23, 0x404c, 0x91a2b3c4L, 0xd5e6f787L), HEXCONSTE(1.20792122264203681900e-4048, 0x0b78, 0x89e953c0L, 0x65fedcdaL), 0 },
#endif
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.71936102716343073112e+23, 0xc04c, 0x91a2b300L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.71936120730741582594e+23, 0xc04c, 0x91a2b400L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.71936116567413893366e+23, 0xc04c, 0x91a2b3c4L, 0xd5e6f000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.71936116567413926920e+23, 0xc04c, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.71936116567413924938e+23, 0xc04c, 0x91a2b3c4L, 0xd5e6f787L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.71936102716343073112e+23, 0xc04c, 0x91a2b300L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.71936120730741582594e+23, 0xc04c, 0x91a2b400L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.71936116567413893366e+23, 0xc04c, 0x91a2b3c4L, 0xd5e6f000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.71936116567413926920e+23, 0xc04c, 0x91a2b3c4L, 0xd5e6f800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.71936116567413924938e+23, 0xc04c, 0x91a2b3c4L, 0xd5e6f787L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.71936102716343073112e+23, 0xc04c, 0x91a2b300L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.71936120730741582594e+23, 0xc04c, 0x91a2b400L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.71936116567413893366e+23, 0xc04c, 0x91a2b3c4L, 0xd5e6f000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.71936116567413926920e+23, 0xc04c, 0x91a2b3c4L, 0xd5e6f800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.71936116567413924938e+23, 0xc04c, 0x91a2b3c4L, 0xd5e6f787L), INF_P, 0 },
#if defined(TEST_LDOUBLE) && LDBL_MAX_EXP > 1024
	{ __LINE__,  HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-1.71936102716343073112e+23, 0xc04c, 0x91a2b300L, 0x00000000L), HEXCONSTE(8.27247170630728032745e+4047, 0x7485, 0xed6c6574L, 0xaa8366c9L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-1.71936120730741582594e+23, 0xc04c, 0x91a2b400L, 0x00000000L), HEXCONSTE(8.28055423786424094193e+4047, 0x7485, 0xeda7c7faL, 0x092bd59dL), 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-1.71936116567413893366e+23, 0xc04c, 0x91a2b3c4L, 0xd5e6f000L), HEXCONSTE(8.27868557364220549372e+4047, 0x7485, 0xed9a0d2fL, 0x9b8fade4L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-1.71936116567413926920e+23, 0xc04c, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(8.27868557365726433487e+4047, 0x7485, 0xed9a0d2fL, 0x9d6ae1feL), 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-1.71936116567413924938e+23, 0xc04c, 0x91a2b3c4L, 0xd5e6f787L), HEXCONSTE(8.27868557365637462797e+4047, 0x7485, 0xed9a0d2fL, 0x9d4ece8aL), 0 },
#endif
	{ __LINE__,  HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(8.59680603653707912970e+22, 0x404b, 0x91a2b400L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(8.59680513581715365560e+22, 0x404b, 0x91a2b300L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(8.59680582837069634601e+22, 0x404b, 0x91a2b3c4L, 0xd5e6f800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(8.59680582837069466829e+22, 0x404b, 0x91a2b3c4L, 0xd5e6f000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(8.59680582837069624689e+22, 0x404b, 0x91a2b3c4L, 0xd5e6f787L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(8.59680603653707912970e+22, 0x404b, 0x91a2b400L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(8.59680513581715365560e+22, 0x404b, 0x91a2b300L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(8.59680582837069634601e+22, 0x404b, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(8.59680582837069466829e+22, 0x404b, 0x91a2b3c4L, 0xd5e6f000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(8.59680582837069624689e+22, 0x404b, 0x91a2b3c4L, 0xd5e6f787L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(8.59680603653707912970e+22, 0x404b, 0x91a2b400L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(8.59680513581715365560e+22, 0x404b, 0x91a2b300L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(8.59680582837069634601e+22, 0x404b, 0x91a2b3c4L, 0xd5e6f800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(8.59680582837069466829e+22, 0x404b, 0x91a2b3c4L, 0xd5e6f000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(8.59680582837069624689e+22, 0x404b, 0x91a2b3c4L, 0xd5e6f787L), INF_P, 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(1.00000000000000000011e+00, 0x3fff, 0x80000000L, 0x00000001L), HEXCONSTE(8.59680603653707912970e+22, 0x404b, 0x91a2b400L, 0x00000000L), HEXCONSTE(8.28055423786423466607e+4047, 0x7485, 0xeda7c7faL, 0x092ba2eaL), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000011e+00, 0x3fff, 0x80000000L, 0x00000001L), HEXCONSTE(8.59680513581715365560e+22, 0x404b, 0x91a2b300L, 0x00000000L), HEXCONSTE(8.27247170630727405788e+4047, 0x7485, 0xed6c6574L, 0xaa833423L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000011e+00, 0x3fff, 0x80000000L, 0x00000001L), HEXCONSTE(8.59680582837069634601e+22, 0x404b, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(8.27868557365725806046e+4047, 0x7485, 0xed9a0d2fL, 0x9d6aaf4eL), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000011e+00, 0x3fff, 0x80000000L, 0x00000001L), HEXCONSTE(8.59680582837069466829e+22, 0x404b, 0x91a2b3c4L, 0xd5e6f000L), HEXCONSTE(8.27868557364219921931e+4047, 0x7485, 0xed9a0d2fL, 0x9b8f7b34L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000011e+00, 0x3fff, 0x80000000L, 0x00000001L), HEXCONSTE(8.59680582837069624689e+22, 0x404b, 0x91a2b3c4L, 0xd5e6f787L), HEXCONSTE(8.27868557365636835356e+4047, 0x7485, 0xed9a0d2fL, 0x9d4e9bdaL), 0 },
#endif
	{ __LINE__,  HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(-8.59680513581715365560e+22, 0xc04b, 0x91a2b300L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(-8.59680603653707912970e+22, 0xc04b, 0x91a2b400L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(-8.59680582837069466829e+22, 0xc04b, 0x91a2b3c4L, 0xd5e6f000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(-8.59680582837069634601e+22, 0xc04b, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(-8.59680582837069624689e+22, 0xc04b, 0x91a2b3c4L, 0xd5e6f787L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-8.59680513581715365560e+22, 0xc04b, 0x91a2b300L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-8.59680603653707912970e+22, 0xc04b, 0x91a2b400L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-8.59680582837069466829e+22, 0xc04b, 0x91a2b3c4L, 0xd5e6f000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-8.59680582837069634601e+22, 0xc04b, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-8.59680582837069624689e+22, 0xc04b, 0x91a2b3c4L, 0xd5e6f787L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(-8.59680513581715365560e+22, 0xc04b, 0x91a2b300L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(-8.59680603653707912970e+22, 0xc04b, 0x91a2b400L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(-8.59680582837069466829e+22, 0xc04b, 0x91a2b3c4L, 0xd5e6f000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(-8.59680582837069634601e+22, 0xc04b, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(-8.59680582837069624689e+22, 0xc04b, 0x91a2b3c4L, 0xd5e6f787L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(1.00000000000000000011e+00, 0x3fff, 0x80000000L, 0x00000001L), HEXCONSTE(-8.59680513581715365560e+22, 0xc04b, 0x91a2b300L, 0x00000000L), HEXCONSTE(1.20882855270155678246e-4048, 0x0b78, 0x8a03d8c4L, 0xbcd2dbaeL), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000011e+00, 0x3fff, 0x80000000L, 0x00000001L), HEXCONSTE(-8.59680603653707912970e+22, 0xc04b, 0x91a2b400L, 0x00000000L), HEXCONSTE(1.20764863229484190712e-4048, 0x0b78, 0x89e15c1eL, 0x4e6cfc3aL), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000011e+00, 0x3fff, 0x80000000L, 0x00000001L), HEXCONSTE(-8.59680582837069466829e+22, 0xc04b, 0x91a2b3c4L, 0xd5e6f000L), HEXCONSTE(1.20792122264410511559e-4048, 0x0b78, 0x89e953c0L, 0x6702811bL), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000011e+00, 0x3fff, 0x80000000L, 0x00000001L), HEXCONSTE(-8.59680582837069634601e+22, 0xc04b, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(1.20792122264190791975e-4048, 0x0b78, 0x89e953c0L, 0x65eeae74L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000011e+00, 0x3fff, 0x80000000L, 0x00000001L), HEXCONSTE(-8.59680582837069624689e+22, 0xc04b, 0x91a2b3c4L, 0xd5e6f787L), HEXCONSTE(1.20792122264203773453e-4048, 0x0b78, 0x89e953c0L, 0x65fefa46L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(9.67914311568120504738e+37, 0x407d, 0x91a2b400L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(9.67914210156072486479e+37, 0x407d, 0x91a2b300L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(9.67914288130669406345e+37, 0x407d, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(9.67914288130669217451e+37, 0x407d, 0x91a2b3c4L, 0xd5e6f000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(9.67914288130669394631e+37, 0x407d, 0x91a2b3c4L, 0xd5e6f781L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(9.67914288130669394539e+37, 0x407d, 0x91a2b3c4L, 0xd5e6f780L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(9.67914311568120504738e+37, 0x407d, 0x91a2b400L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(9.67914210156072486479e+37, 0x407d, 0x91a2b300L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(9.67914288130669406345e+37, 0x407d, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(9.67914288130669217451e+37, 0x407d, 0x91a2b3c4L, 0xd5e6f000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(9.67914288130669394631e+37, 0x407d, 0x91a2b3c4L, 0xd5e6f781L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(9.67914288130669394539e+37, 0x407d, 0x91a2b3c4L, 0xd5e6f780L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(9.67914311568120504738e+37, 0x407d, 0x91a2b400L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(9.67914210156072486479e+37, 0x407d, 0x91a2b300L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(9.67914288130669406345e+37, 0x407d, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(9.67914288130669217451e+37, 0x407d, 0x91a2b3c4L, 0xd5e6f000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(9.67914288130669394631e+37, 0x407d, 0x91a2b3c4L, 0xd5e6f781L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(9.67914288130669394539e+37, 0x407d, 0x91a2b3c4L, 0xd5e6f780L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#if defined(TEST_LDOUBLE) && LDBL_MAX_EXP > 1024
	{ __LINE__,  HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(9.67914311568120504738e+37, 0x407d, 0x91a2b400L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(9.67914210156072486479e+37, 0x407d, 0x91a2b300L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(9.67914288130669406345e+37, 0x407d, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(9.67914288130669217451e+37, 0x407d, 0x91a2b3c4L, 0xd5e6f000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(9.67914288130669394631e+37, 0x407d, 0x91a2b3c4L, 0xd5e6f781L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(9.67914288130669394539e+37, 0x407d, 0x91a2b3c4L, 0xd5e6f780L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-9.67914210156072486479e+37, 0xc07d, 0x91a2b300L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-9.67914311568120504738e+37, 0xc07d, 0x91a2b400L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-9.67914288130669217451e+37, 0xc07d, 0x91a2b3c4L, 0xd5e6f000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-9.67914288130669406345e+37, 0xc07d, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-9.67914288130669394539e+37, 0xc07d, 0x91a2b3c4L, 0xd5e6f780L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-9.67914288130669394631e+37, 0xc07d, 0x91a2b3c4L, 0xd5e6f781L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-9.67914210156072486479e+37, 0xc07d, 0x91a2b300L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-9.67914311568120504738e+37, 0xc07d, 0x91a2b400L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-9.67914288130669217451e+37, 0xc07d, 0x91a2b3c4L, 0xd5e6f000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-9.67914288130669406345e+37, 0xc07d, 0x91a2b3c4L, 0xd5e6f800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-9.67914288130669394539e+37, 0xc07d, 0x91a2b3c4L, 0xd5e6f780L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-9.67914288130669394631e+37, 0xc07d, 0x91a2b3c4L, 0xd5e6f781L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-9.67914210156072486479e+37, 0xc07d, 0x91a2b300L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-9.67914311568120504738e+37, 0xc07d, 0x91a2b400L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-9.67914288130669217451e+37, 0xc07d, 0x91a2b3c4L, 0xd5e6f000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-9.67914288130669406345e+37, 0xc07d, 0x91a2b3c4L, 0xd5e6f800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-9.67914288130669394539e+37, 0xc07d, 0x91a2b3c4L, 0xd5e6f780L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-9.67914288130669394631e+37, 0xc07d, 0x91a2b3c4L, 0xd5e6f781L), INF_P, 0 },
#if defined(TEST_LDOUBLE) && LDBL_MAX_EXP > 1024
	{ __LINE__,  HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-9.67914210156072486479e+37, 0xc07d, 0x91a2b300L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-9.67914311568120504738e+37, 0xc07d, 0x91a2b400L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-9.67914288130669217451e+37, 0xc07d, 0x91a2b3c4L, 0xd5e6f000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-9.67914288130669406345e+37, 0xc07d, 0x91a2b3c4L, 0xd5e6f800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-9.67914288130669394539e+37, 0xc07d, 0x91a2b3c4L, 0xd5e6f780L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-9.67914288130669394631e+37, 0xc07d, 0x91a2b3c4L, 0xd5e6f781L), INF_P, 0 },
#endif
	{ __LINE__,  HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(4.83957155784060252369e+37, 0x407c, 0x91a2b400L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(4.83957105078036243240e+37, 0x407c, 0x91a2b300L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(4.83957144065334703173e+37, 0x407c, 0x91a2b3c4L, 0xd5e6f800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(4.83957144065334608725e+37, 0x407c, 0x91a2b3c4L, 0xd5e6f000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(4.83957144065334697316e+37, 0x407c, 0x91a2b3c4L, 0xd5e6f781L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(4.83957144065334697270e+37, 0x407c, 0x91a2b3c4L, 0xd5e6f780L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(4.83957155784060252369e+37, 0x407c, 0x91a2b400L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(4.83957105078036243240e+37, 0x407c, 0x91a2b300L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(4.83957144065334703173e+37, 0x407c, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(4.83957144065334608725e+37, 0x407c, 0x91a2b3c4L, 0xd5e6f000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(4.83957144065334697316e+37, 0x407c, 0x91a2b3c4L, 0xd5e6f781L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(4.83957144065334697270e+37, 0x407c, 0x91a2b3c4L, 0xd5e6f780L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(4.83957155784060252369e+37, 0x407c, 0x91a2b400L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(4.83957105078036243240e+37, 0x407c, 0x91a2b300L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(4.83957144065334703173e+37, 0x407c, 0x91a2b3c4L, 0xd5e6f800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(4.83957144065334608725e+37, 0x407c, 0x91a2b3c4L, 0xd5e6f000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(4.83957144065334697316e+37, 0x407c, 0x91a2b3c4L, 0xd5e6f781L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(4.83957144065334697270e+37, 0x407c, 0x91a2b3c4L, 0xd5e6f780L), INF_P, 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(1.00000000000000000011e+00, 0x3fff, 0x80000000L, 0x00000001L), HEXCONSTE(4.83957155784060252369e+37, 0x407c, 0x91a2b400L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000011e+00, 0x3fff, 0x80000000L, 0x00000001L), HEXCONSTE(4.83957105078036243240e+37, 0x407c, 0x91a2b300L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000011e+00, 0x3fff, 0x80000000L, 0x00000001L), HEXCONSTE(4.83957144065334703173e+37, 0x407c, 0x91a2b3c4L, 0xd5e6f800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000011e+00, 0x3fff, 0x80000000L, 0x00000001L), HEXCONSTE(4.83957144065334608725e+37, 0x407c, 0x91a2b3c4L, 0xd5e6f000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000011e+00, 0x3fff, 0x80000000L, 0x00000001L), HEXCONSTE(4.83957144065334697316e+37, 0x407c, 0x91a2b3c4L, 0xd5e6f781L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000011e+00, 0x3fff, 0x80000000L, 0x00000001L), HEXCONSTE(4.83957144065334697270e+37, 0x407c, 0x91a2b3c4L, 0xd5e6f780L), INF_P, 0 },
#endif
	{ __LINE__,  HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(-4.83957105078036243240e+37, 0xc07c, 0x91a2b300L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(-4.83957155784060252369e+37, 0xc07c, 0x91a2b400L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(-4.83957144065334608725e+37, 0xc07c, 0x91a2b3c4L, 0xd5e6f000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(-4.83957144065334703173e+37, 0xc07c, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(-4.83957144065334697270e+37, 0xc07c, 0x91a2b3c4L, 0xd5e6f780L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(-4.83957144065334697316e+37, 0xc07c, 0x91a2b3c4L, 0xd5e6f781L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-4.83957105078036243240e+37, 0xc07c, 0x91a2b300L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-4.83957155784060252369e+37, 0xc07c, 0x91a2b400L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-4.83957144065334608725e+37, 0xc07c, 0x91a2b3c4L, 0xd5e6f000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-4.83957144065334703173e+37, 0xc07c, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-4.83957144065334697270e+37, 0xc07c, 0x91a2b3c4L, 0xd5e6f780L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-4.83957144065334697316e+37, 0xc07c, 0x91a2b3c4L, 0xd5e6f781L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(-4.83957105078036243240e+37, 0xc07c, 0x91a2b300L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(-4.83957155784060252369e+37, 0xc07c, 0x91a2b400L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(-4.83957144065334608725e+37, 0xc07c, 0x91a2b3c4L, 0xd5e6f000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(-4.83957144065334703173e+37, 0xc07c, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(-4.83957144065334697270e+37, 0xc07c, 0x91a2b3c4L, 0xd5e6f780L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(-4.83957144065334697316e+37, 0xc07c, 0x91a2b3c4L, 0xd5e6f781L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(1.00000000000000000011e+00, 0x3fff, 0x80000000L, 0x00000001L), HEXCONSTE(-4.83957105078036243240e+37, 0xc07c, 0x91a2b300L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000011e+00, 0x3fff, 0x80000000L, 0x00000001L), HEXCONSTE(-4.83957155784060252369e+37, 0xc07c, 0x91a2b400L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000011e+00, 0x3fff, 0x80000000L, 0x00000001L), HEXCONSTE(-4.83957144065334608725e+37, 0xc07c, 0x91a2b3c4L, 0xd5e6f000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000011e+00, 0x3fff, 0x80000000L, 0x00000001L), HEXCONSTE(-4.83957144065334703173e+37, 0xc07c, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000011e+00, 0x3fff, 0x80000000L, 0x00000001L), HEXCONSTE(-4.83957144065334697270e+37, 0xc07c, 0x91a2b3c4L, 0xd5e6f780L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000011e+00, 0x3fff, 0x80000000L, 0x00000001L), HEXCONSTE(-4.83957144065334697316e+37, 0xc07c, 0x91a2b3c4L, 0xd5e6f781L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+01, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(9.99999403953712118209e-01, 0x3ffe, 0xfffff600L, 0x002d0000L), 0 },
	{ __LINE__,  HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+02, 0x4005, 0xc8000000L, 0x00000000L), HEXCONSTE(9.99994039553108359387e-01, 0x3ffe, 0xffff9c00L, 0x1355fd88L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+03, 0x4008, 0xfa000000L, 0x00000000L), HEXCONSTE(9.99940397129769905239e-01, 0x3ffe, 0xfffc1807L, 0x9f221888L), 0 },
	{ __LINE__,  HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(1.67772160000000000000e+07, 0x4017, 0x80000000L, 0x00000000L), HEXCONSTE(3.67879430207780343709e-01, 0x3ffd, 0xbc5ab153L, 0x3a20be44L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(1.07374182400000000000e+09, 0x401d, 0x80000000L, 0x00000000L), HEXCONSTE(1.60380783152492423385e-28, 0x3fa2, 0xcb4e8a2fL, 0x3c38e77bL), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(1.22167948800000000000e+09, 0x401d, 0x91a2b300L, 0x00000000L), HEXCONSTE(2.37488471213529509998e-32, 0x3f95, 0xf69f43d1L, 0xf84c9cb7L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+01, 0xc002, 0xa0000000L, 0x00000000L), HEXCONSTE(1.00000059604664315316e+00, 0x3fff, 0x80000500L, 0x001b8000L), 0 },
	{ __LINE__,  HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+02, 0xc005, 0xc8000000L, 0x00000000L), HEXCONSTE(1.00000596048241877946e+00, 0x3fff, 0x80003200L, 0x09dd014fL), 0 },
	{ __LINE__,  HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+03, 0xc008, 0xfa000000L, 0x00000000L), HEXCONSTE(1.00005960642294398639e+00, 0x3fff, 0x8001f403L, 0xd18efb67L), 0 },
	{ __LINE__,  HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.67772160000000000000e+07, 0xc017, 0x80000000L, 0x00000000L), HEXCONSTE(2.71828190947016105406e+00, 0x4000, 0xadf854afL, 0x9ee5c6a9L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.07374182400000000000e+09, 0xc01d, 0x80000000L, 0x00000000L), HEXCONSTE(6.23516097342650579883e+27, 0x405b, 0xa12cd58dL, 0x463b2692L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.22167948800000000000e+09, 0xc01d, 0x91a2b300L, 0x00000000L), HEXCONSTE(4.21073071416963535004e+31, 0x4068, 0x84de0307L, 0x52c5106dL), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000011920928955078e+00, 0xbfff, 0x80000100L, 0x00000000L), HEXCONSTE(1.67772160000000000000e+07, 0x4017, 0x80000000L, 0x00000000L), HEXCONSTE(7.38905521808664472825e+00, 0x4001, 0xec7323edL, 0xc0a63082L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000011920928955078e+00, 0xbfff, 0x80000100L, 0x00000000L), HEXCONSTE(6.10839744000000000000e+08, 0x401c, 0x91a2b300L, 0x00000000L), HEXCONSTE(4.21070330065074951882e+31, 0x4068, 0x84ddca56L, 0xba2da80eL), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000011920928955078e+00, 0xbfff, 0x80000100L, 0x00000000L), HEXCONSTE(-6.10839744000000000000e+08, 0xc01c, 0x91a2b300L, 0x00000000L), HEXCONSTE(2.37490017367277690992e-32, 0x3f95, 0xf69fad0bL, 0xc4745715L), FLAG_INEXACT },
#if defined(TEST_LDOUBLE) && LDBL_MAX_EXP > 1024
	{ __LINE__,  HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(5.24707399690983833600e+18, 0x403d, 0x91a2b400L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(5.24707344715402444800e+18, 0x403d, 0x91a2b300L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(5.24707386985516134400e+18, 0x403d, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(5.24707399690983833600e+18, 0x403d, 0x91a2b400L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(5.24707344715402444800e+18, 0x403d, 0x91a2b300L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(5.24707386985516134400e+18, 0x403d, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-9.99999999999999888978e-01, 0xbffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(5.24707399690983833600e+18, 0x403d, 0x91a2b400L, 0x00000000L), HEXCONSTE(1.01186200145503886838e-253, 0x3cb6, 0xbdea0deeL, 0xfbcfce6dL), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(-9.99999999999999888978e-01, 0xbffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(5.24707344715402444800e+18, 0x403d, 0x91a2b300L, 0x00000000L), HEXCONSTE(1.01192376249517930885e-253, 0x3cb6, 0xbded059dL, 0x22e416edL), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(-9.99999999999999888978e-01, 0xbffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(5.24707386985516134400e+18, 0x403d, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(1.01187627478272528173e-253, 0x3cb6, 0xbdeabd7fL, 0xfdaef65fL), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-5.24707344715402444800e+18, 0xc03d, 0x91a2b300L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-5.24707399690983833600e+18, 0xc03d, 0x91a2b400L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-5.24707386985516134400e+18, 0xc03d, 0x91a2b3c4L, 0xd5e6f800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-5.24707344715402444800e+18, 0xc03d, 0x91a2b300L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-5.24707399690983833600e+18, 0xc03d, 0x91a2b400L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-5.24707386985516134400e+18, 0xc03d, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-9.99999999999999888978e-01, 0xbffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-5.24707344715402444800e+18, 0xc03d, 0x91a2b300L, 0x00000000L), HEXCONSTE(9.88216738318529097366e+252, 0x4347, 0xac87cd32L, 0xc350b66cL), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(-9.99999999999999888978e-01, 0xbffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-5.24707399690983833600e+18, 0xc03d, 0x91a2b400L, 0x00000000L), HEXCONSTE(9.88277056122295797870e+252, 0x4347, 0xac8a7f57L, 0x5c615da0L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(-9.99999999999999888978e-01, 0xbffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-5.24707386985516134400e+18, 0xc03d, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(9.88263115680545618108e+252, 0x4347, 0xac89dfd6L, 0x7a57811bL), 0 },
#if defined(TEST_LDOUBLE) && LDBL_MAX_EXP > 1024
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(2.62353699845491916800e+18, 0x403c, 0x91a2b400L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(2.62353672357701222400e+18, 0x403c, 0x91a2b300L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(2.62353693492758067200e+18, 0x403c, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-1.00000011920928955078e+00, 0xbfff, 0x80000100L, 0x00000000L), HEXCONSTE(2.62353699845491916800e+18, 0x403c, 0x91a2b400L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.00000011920928955078e+00, 0xbfff, 0x80000100L, 0x00000000L), HEXCONSTE(2.62353672357701222400e+18, 0x403c, 0x91a2b300L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.00000011920928955078e+00, 0xbfff, 0x80000100L, 0x00000000L), HEXCONSTE(2.62353693492758067200e+18, 0x403c, 0x91a2b3c4L, 0xd5e6f800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000022204e+00, 0xbfff, 0x80000000L, 0x00000800L), HEXCONSTE(2.62353699845491916800e+18, 0x403c, 0x91a2b400L, 0x00000000L), HEXCONSTE(9.88277056122199922381e+252, 0x4347, 0xac8a7f57L, 0x5c4ef61bL), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(-1.00000000000000022204e+00, 0xbfff, 0x80000000L, 0x00000800L), HEXCONSTE(2.62353672357701222400e+18, 0x403c, 0x91a2b300L, 0x00000000L), HEXCONSTE(9.88216738318433227759e+252, 0x4347, 0xac87cd32L, 0xc33e4f31L), FLAG_INEXACT },
#if defined(TEST_LDOUBLE) && LDBL_MAX_EXP > 1024
	{ __LINE__,  HEXCONSTE(-1.00000000000000022204e+00, 0xbfff, 0x80000000L, 0x00000800L), HEXCONSTE(2.62353693492758067200e+18, 0x403c, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(9.88263115680449743971e+252, 0x4347, 0xac89dfd6L, 0x7a4519a7L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-2.62353672357701222400e+18, 0xc03c, 0x91a2b300L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-2.62353699845491916800e+18, 0xc03c, 0x91a2b400L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-2.62353693492758067200e+18, 0xc03c, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000011920928955078e+00, 0xbfff, 0x80000100L, 0x00000000L), HEXCONSTE(-2.62353672357701222400e+18, 0xc03c, 0x91a2b300L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000011920928955078e+00, 0xbfff, 0x80000100L, 0x00000000L), HEXCONSTE(-2.62353699845491916800e+18, 0xc03c, 0x91a2b400L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000011920928955078e+00, 0xbfff, 0x80000100L, 0x00000000L), HEXCONSTE(-2.62353693492758067200e+18, 0xc03c, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000022204e+00, 0xbfff, 0x80000000L, 0x00000800L), HEXCONSTE(-2.62353672357701222400e+18, 0xc03c, 0x91a2b300L, 0x00000000L), HEXCONSTE(1.01192376249527747837e-253, 0x3cb6, 0xbded059dL, 0x22f8592bL), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000022204e+00, 0xbfff, 0x80000000L, 0x00000800L), HEXCONSTE(-2.62353699845491916800e+18, 0xc03c, 0x91a2b400L, 0x00000000L), HEXCONSTE(1.01186200145513703191e-253, 0x3cb6, 0xbdea0deeL, 0xfbe4105aL), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000022204e+00, 0xbfff, 0x80000000L, 0x00000800L), HEXCONSTE(-2.62353693492758067200e+18, 0xc03c, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(1.01187627478282344667e-253, 0x3cb6, 0xbdeabd7fL, 0xfdc3385fL), 0 },
#if defined(TEST_LDOUBLE) && LDBL_MAX_EXP > 1024
	{ __LINE__,  HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(1.71936120730741582594e+23, 0x404c, 0x91a2b400L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(1.71936102716343073112e+23, 0x404c, 0x91a2b300L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(1.71936116567413926920e+23, 0x404c, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(1.71936116567413893366e+23, 0x404c, 0x91a2b3c4L, 0xd5e6f000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(1.71936116567413924938e+23, 0x404c, 0x91a2b3c4L, 0xd5e6f787L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(1.71936120730741582594e+23, 0x404c, 0x91a2b400L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(1.71936102716343073112e+23, 0x404c, 0x91a2b300L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(1.71936116567413926920e+23, 0x404c, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(1.71936116567413893366e+23, 0x404c, 0x91a2b3c4L, 0xd5e6f000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(1.71936116567413924938e+23, 0x404c, 0x91a2b3c4L, 0xd5e6f787L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-9.99999999999999888978e-01, 0xbffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.71936120730741582594e+23, 0x404c, 0x91a2b400L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-9.99999999999999888978e-01, 0xbffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.71936102716343073112e+23, 0x404c, 0x91a2b300L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-9.99999999999999888978e-01, 0xbffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.71936116567413926920e+23, 0x404c, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-9.99999999999999888978e-01, 0xbffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.71936116567413893366e+23, 0x404c, 0x91a2b3c4L, 0xd5e6f000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-9.99999999999999888978e-01, 0xbffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.71936116567413924938e+23, 0x404c, 0x91a2b3c4L, 0xd5e6f787L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-9.99999999999999999946e-01, 0xbffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.71936120730741582594e+23, 0x404c, 0x91a2b400L, 0x00000000L), HEXCONSTE(1.20764863229484099184e-4048, 0x0b78, 0x89e15c1eL, 0x4e6cded0L), 0 },
	{ __LINE__,  HEXCONSTE(-9.99999999999999999946e-01, 0xbffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.71936102716343073112e+23, 0x404c, 0x91a2b300L, 0x00000000L), HEXCONSTE(1.20882855270155586633e-4048, 0x0b78, 0x8a03d8c4L, 0xbcd2be3dL), 0 },
	{ __LINE__,  HEXCONSTE(-9.99999999999999999946e-01, 0xbffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.71936116567413926920e+23, 0x404c, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(1.20792122264190700422e-4048, 0x0b78, 0x89e953c0L, 0x65ee9108L), 0 },
	{ __LINE__,  HEXCONSTE(-9.99999999999999999946e-01, 0xbffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.71936116567413893366e+23, 0x404c, 0x91a2b3c4L, 0xd5e6f000L), HEXCONSTE(1.20792122264410420007e-4048, 0x0b78, 0x89e953c0L, 0x670263afL), 0 },
	{ __LINE__,  HEXCONSTE(-9.99999999999999999946e-01, 0xbffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.71936116567413924938e+23, 0x404c, 0x91a2b3c4L, 0xd5e6f787L), HEXCONSTE(1.20792122264203681900e-4048, 0x0b78, 0x89e953c0L, 0x65fedcdaL), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.71936102716343073112e+23, 0xc04c, 0x91a2b300L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.71936120730741582594e+23, 0xc04c, 0x91a2b400L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.71936116567413893366e+23, 0xc04c, 0x91a2b3c4L, 0xd5e6f000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.71936116567413926920e+23, 0xc04c, 0x91a2b3c4L, 0xd5e6f800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.71936116567413924938e+23, 0xc04c, 0x91a2b3c4L, 0xd5e6f787L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.71936102716343073112e+23, 0xc04c, 0x91a2b300L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.71936120730741582594e+23, 0xc04c, 0x91a2b400L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.71936116567413893366e+23, 0xc04c, 0x91a2b3c4L, 0xd5e6f000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.71936116567413926920e+23, 0xc04c, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.71936116567413924938e+23, 0xc04c, 0x91a2b3c4L, 0xd5e6f787L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-9.99999999999999888978e-01, 0xbffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.71936102716343073112e+23, 0xc04c, 0x91a2b300L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-9.99999999999999888978e-01, 0xbffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.71936120730741582594e+23, 0xc04c, 0x91a2b400L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-9.99999999999999888978e-01, 0xbffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.71936116567413893366e+23, 0xc04c, 0x91a2b3c4L, 0xd5e6f000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-9.99999999999999888978e-01, 0xbffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.71936116567413926920e+23, 0xc04c, 0x91a2b3c4L, 0xd5e6f800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-9.99999999999999888978e-01, 0xbffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.71936116567413924938e+23, 0xc04c, 0x91a2b3c4L, 0xd5e6f787L), INF_P, 0 },
#if defined(TEST_LDOUBLE) && LDBL_MAX_EXP > 1024
	{ __LINE__,  HEXCONSTE(-9.99999999999999999946e-01, 0xbffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-1.71936102716343073112e+23, 0xc04c, 0x91a2b300L, 0x00000000L), HEXCONSTE(8.27247170630728032745e+4047, 0x7485, 0xed6c6574L, 0xaa8366c9L), 0 },
	{ __LINE__,  HEXCONSTE(-9.99999999999999999946e-01, 0xbffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-1.71936120730741582594e+23, 0xc04c, 0x91a2b400L, 0x00000000L), HEXCONSTE(8.28055423786424094193e+4047, 0x7485, 0xeda7c7faL, 0x092bd59dL), 0 },
	{ __LINE__,  HEXCONSTE(-9.99999999999999999946e-01, 0xbffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-1.71936116567413893366e+23, 0xc04c, 0x91a2b3c4L, 0xd5e6f000L), HEXCONSTE(8.27868557364220549372e+4047, 0x7485, 0xed9a0d2fL, 0x9b8fade4L), 0 },
	{ __LINE__,  HEXCONSTE(-9.99999999999999999946e-01, 0xbffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-1.71936116567413926920e+23, 0xc04c, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(8.27868557365726433487e+4047, 0x7485, 0xed9a0d2fL, 0x9d6ae1feL), 0 },
	{ __LINE__,  HEXCONSTE(-9.99999999999999999946e-01, 0xbffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-1.71936116567413924938e+23, 0xc04c, 0x91a2b3c4L, 0xd5e6f787L), HEXCONSTE(8.27868557365637462797e+4047, 0x7485, 0xed9a0d2fL, 0x9d4ece8aL), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(8.59680603653707912970e+22, 0x404b, 0x91a2b400L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(8.59680513581715365560e+22, 0x404b, 0x91a2b300L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(8.59680582837069634601e+22, 0x404b, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(8.59680582837069466829e+22, 0x404b, 0x91a2b3c4L, 0xd5e6f000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(8.59680582837069624689e+22, 0x404b, 0x91a2b3c4L, 0xd5e6f787L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-1.00000011920928955078e+00, 0xbfff, 0x80000100L, 0x00000000L), HEXCONSTE(8.59680603653707912970e+22, 0x404b, 0x91a2b400L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.00000011920928955078e+00, 0xbfff, 0x80000100L, 0x00000000L), HEXCONSTE(8.59680513581715365560e+22, 0x404b, 0x91a2b300L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.00000011920928955078e+00, 0xbfff, 0x80000100L, 0x00000000L), HEXCONSTE(8.59680582837069634601e+22, 0x404b, 0x91a2b3c4L, 0xd5e6f800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.00000011920928955078e+00, 0xbfff, 0x80000100L, 0x00000000L), HEXCONSTE(8.59680582837069466829e+22, 0x404b, 0x91a2b3c4L, 0xd5e6f000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.00000011920928955078e+00, 0xbfff, 0x80000100L, 0x00000000L), HEXCONSTE(8.59680582837069624689e+22, 0x404b, 0x91a2b3c4L, 0xd5e6f787L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000022204e+00, 0xbfff, 0x80000000L, 0x00000800L), HEXCONSTE(8.59680603653707912970e+22, 0x404b, 0x91a2b400L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000022204e+00, 0xbfff, 0x80000000L, 0x00000800L), HEXCONSTE(8.59680513581715365560e+22, 0x404b, 0x91a2b300L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000022204e+00, 0xbfff, 0x80000000L, 0x00000800L), HEXCONSTE(8.59680582837069634601e+22, 0x404b, 0x91a2b3c4L, 0xd5e6f800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000022204e+00, 0xbfff, 0x80000000L, 0x00000800L), HEXCONSTE(8.59680582837069466829e+22, 0x404b, 0x91a2b3c4L, 0xd5e6f000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000022204e+00, 0xbfff, 0x80000000L, 0x00000800L), HEXCONSTE(8.59680582837069624689e+22, 0x404b, 0x91a2b3c4L, 0xd5e6f787L), INF_P, 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-1.00000000000000000011e+00, 0xbfff, 0x80000000L, 0x00000001L), HEXCONSTE(8.59680603653707912970e+22, 0x404b, 0x91a2b400L, 0x00000000L), HEXCONSTE(8.28055423786423466607e+4047, 0x7485, 0xeda7c7faL, 0x092ba2eaL), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000011e+00, 0xbfff, 0x80000000L, 0x00000001L), HEXCONSTE(8.59680513581715365560e+22, 0x404b, 0x91a2b300L, 0x00000000L), HEXCONSTE(8.27247170630727405788e+4047, 0x7485, 0xed6c6574L, 0xaa833423L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000011e+00, 0xbfff, 0x80000000L, 0x00000001L), HEXCONSTE(8.59680582837069634601e+22, 0x404b, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(8.27868557365725806046e+4047, 0x7485, 0xed9a0d2fL, 0x9d6aaf4eL), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000011e+00, 0xbfff, 0x80000000L, 0x00000001L), HEXCONSTE(8.59680582837069466829e+22, 0x404b, 0x91a2b3c4L, 0xd5e6f000L), HEXCONSTE(8.27868557364219921931e+4047, 0x7485, 0xed9a0d2fL, 0x9b8f7b34L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000011e+00, 0xbfff, 0x80000000L, 0x00000001L), HEXCONSTE(8.59680582837069624689e+22, 0x404b, 0x91a2b3c4L, 0xd5e6f787L), HEXCONSTE(8.27868557365636835356e+4047, 0x7485, 0xed9a0d2fL, 0x9d4e9bdaL), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-8.59680513581715365560e+22, 0xc04b, 0x91a2b300L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-8.59680603653707912970e+22, 0xc04b, 0x91a2b400L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-8.59680582837069466829e+22, 0xc04b, 0x91a2b3c4L, 0xd5e6f000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-8.59680582837069634601e+22, 0xc04b, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-8.59680582837069624689e+22, 0xc04b, 0x91a2b3c4L, 0xd5e6f787L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000011920928955078e+00, 0xbfff, 0x80000100L, 0x00000000L), HEXCONSTE(-8.59680513581715365560e+22, 0xc04b, 0x91a2b300L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000011920928955078e+00, 0xbfff, 0x80000100L, 0x00000000L), HEXCONSTE(-8.59680603653707912970e+22, 0xc04b, 0x91a2b400L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000011920928955078e+00, 0xbfff, 0x80000100L, 0x00000000L), HEXCONSTE(-8.59680582837069466829e+22, 0xc04b, 0x91a2b3c4L, 0xd5e6f000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000011920928955078e+00, 0xbfff, 0x80000100L, 0x00000000L), HEXCONSTE(-8.59680582837069634601e+22, 0xc04b, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000011920928955078e+00, 0xbfff, 0x80000100L, 0x00000000L), HEXCONSTE(-8.59680582837069624689e+22, 0xc04b, 0x91a2b3c4L, 0xd5e6f787L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000022204e+00, 0xbfff, 0x80000000L, 0x00000800L), HEXCONSTE(-8.59680513581715365560e+22, 0xc04b, 0x91a2b300L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000022204e+00, 0xbfff, 0x80000000L, 0x00000800L), HEXCONSTE(-8.59680603653707912970e+22, 0xc04b, 0x91a2b400L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000022204e+00, 0xbfff, 0x80000000L, 0x00000800L), HEXCONSTE(-8.59680582837069466829e+22, 0xc04b, 0x91a2b3c4L, 0xd5e6f000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000022204e+00, 0xbfff, 0x80000000L, 0x00000800L), HEXCONSTE(-8.59680582837069634601e+22, 0xc04b, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000022204e+00, 0xbfff, 0x80000000L, 0x00000800L), HEXCONSTE(-8.59680582837069624689e+22, 0xc04b, 0x91a2b3c4L, 0xd5e6f787L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-1.00000000000000000011e+00, 0xbfff, 0x80000000L, 0x00000001L), HEXCONSTE(-8.59680513581715365560e+22, 0xc04b, 0x91a2b300L, 0x00000000L), HEXCONSTE(1.20882855270155678246e-4048, 0x0b78, 0x8a03d8c4L, 0xbcd2dbaeL), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000011e+00, 0xbfff, 0x80000000L, 0x00000001L), HEXCONSTE(-8.59680603653707912970e+22, 0xc04b, 0x91a2b400L, 0x00000000L), HEXCONSTE(1.20764863229484190712e-4048, 0x0b78, 0x89e15c1eL, 0x4e6cfc3aL), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000011e+00, 0xbfff, 0x80000000L, 0x00000001L), HEXCONSTE(-8.59680582837069466829e+22, 0xc04b, 0x91a2b3c4L, 0xd5e6f000L), HEXCONSTE(1.20792122264410511559e-4048, 0x0b78, 0x89e953c0L, 0x6702811bL), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000011e+00, 0xbfff, 0x80000000L, 0x00000001L), HEXCONSTE(-8.59680582837069634601e+22, 0xc04b, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(1.20792122264190791975e-4048, 0x0b78, 0x89e953c0L, 0x65eeae74L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000011e+00, 0xbfff, 0x80000000L, 0x00000001L), HEXCONSTE(-8.59680582837069624689e+22, 0xc04b, 0x91a2b3c4L, 0xd5e6f787L), HEXCONSTE(1.20792122264203773453e-4048, 0x0b78, 0x89e953c0L, 0x65fefa46L), 0 },
#endif
#if defined(TEST_LDOUBLE) && LDBL_MAX_EXP > 1024
	{ __LINE__,  HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(9.67914311568120504738e+37, 0x407d, 0x91a2b400L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(9.67914210156072486479e+37, 0x407d, 0x91a2b300L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(9.67914288130669406345e+37, 0x407d, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(9.67914288130669217451e+37, 0x407d, 0x91a2b3c4L, 0xd5e6f000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(9.67914288130669394631e+37, 0x407d, 0x91a2b3c4L, 0xd5e6f781L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(9.67914288130669394539e+37, 0x407d, 0x91a2b3c4L, 0xd5e6f780L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(9.67914311568120504738e+37, 0x407d, 0x91a2b400L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(9.67914210156072486479e+37, 0x407d, 0x91a2b300L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(9.67914288130669406345e+37, 0x407d, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(9.67914288130669217451e+37, 0x407d, 0x91a2b3c4L, 0xd5e6f000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(9.67914288130669394631e+37, 0x407d, 0x91a2b3c4L, 0xd5e6f781L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(9.67914288130669394539e+37, 0x407d, 0x91a2b3c4L, 0xd5e6f780L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-9.99999999999999888978e-01, 0xbffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(9.67914311568120504738e+37, 0x407d, 0x91a2b400L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-9.99999999999999888978e-01, 0xbffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(9.67914210156072486479e+37, 0x407d, 0x91a2b300L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-9.99999999999999888978e-01, 0xbffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(9.67914288130669406345e+37, 0x407d, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-9.99999999999999888978e-01, 0xbffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(9.67914288130669217451e+37, 0x407d, 0x91a2b3c4L, 0xd5e6f000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-9.99999999999999888978e-01, 0xbffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(9.67914288130669394631e+37, 0x407d, 0x91a2b3c4L, 0xd5e6f781L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-9.99999999999999888978e-01, 0xbffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(9.67914288130669394539e+37, 0x407d, 0x91a2b3c4L, 0xd5e6f780L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-9.99999999999999999946e-01, 0xbffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(9.67914311568120504738e+37, 0x407d, 0x91a2b400L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-9.99999999999999999946e-01, 0xbffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(9.67914210156072486479e+37, 0x407d, 0x91a2b300L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-9.99999999999999999946e-01, 0xbffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(9.67914288130669406345e+37, 0x407d, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-9.99999999999999999946e-01, 0xbffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(9.67914288130669217451e+37, 0x407d, 0x91a2b3c4L, 0xd5e6f000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-9.99999999999999999946e-01, 0xbffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(9.67914288130669394631e+37, 0x407d, 0x91a2b3c4L, 0xd5e6f781L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-9.99999999999999999946e-01, 0xbffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(9.67914288130669394539e+37, 0x407d, 0x91a2b3c4L, 0xd5e6f780L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-9.67914210156072486479e+37, 0xc07d, 0x91a2b300L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-9.67914311568120504738e+37, 0xc07d, 0x91a2b400L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-9.67914288130669217451e+37, 0xc07d, 0x91a2b3c4L, 0xd5e6f000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-9.67914288130669406345e+37, 0xc07d, 0x91a2b3c4L, 0xd5e6f800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-9.67914288130669394539e+37, 0xc07d, 0x91a2b3c4L, 0xd5e6f780L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-9.67914288130669394631e+37, 0xc07d, 0x91a2b3c4L, 0xd5e6f781L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-9.67914210156072486479e+37, 0xc07d, 0x91a2b300L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-9.67914311568120504738e+37, 0xc07d, 0x91a2b400L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-9.67914288130669217451e+37, 0xc07d, 0x91a2b3c4L, 0xd5e6f000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-9.67914288130669406345e+37, 0xc07d, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-9.67914288130669394539e+37, 0xc07d, 0x91a2b3c4L, 0xd5e6f780L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-9.67914288130669394631e+37, 0xc07d, 0x91a2b3c4L, 0xd5e6f781L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-9.99999999999999888978e-01, 0xbffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-9.67914210156072486479e+37, 0xc07d, 0x91a2b300L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-9.99999999999999888978e-01, 0xbffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-9.67914311568120504738e+37, 0xc07d, 0x91a2b400L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-9.99999999999999888978e-01, 0xbffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-9.67914288130669217451e+37, 0xc07d, 0x91a2b3c4L, 0xd5e6f000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-9.99999999999999888978e-01, 0xbffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-9.67914288130669406345e+37, 0xc07d, 0x91a2b3c4L, 0xd5e6f800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-9.99999999999999888978e-01, 0xbffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-9.67914288130669394539e+37, 0xc07d, 0x91a2b3c4L, 0xd5e6f780L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-9.99999999999999888978e-01, 0xbffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-9.67914288130669394631e+37, 0xc07d, 0x91a2b3c4L, 0xd5e6f781L), INF_P, 0 },
#if defined(TEST_LDOUBLE) && LDBL_MAX_EXP > 1024
	{ __LINE__,  HEXCONSTE(-9.99999999999999999946e-01, 0xbffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-9.67914210156072486479e+37, 0xc07d, 0x91a2b300L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-9.99999999999999999946e-01, 0xbffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-9.67914311568120504738e+37, 0xc07d, 0x91a2b400L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-9.99999999999999999946e-01, 0xbffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-9.67914288130669217451e+37, 0xc07d, 0x91a2b3c4L, 0xd5e6f000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-9.99999999999999999946e-01, 0xbffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-9.67914288130669406345e+37, 0xc07d, 0x91a2b3c4L, 0xd5e6f800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-9.99999999999999999946e-01, 0xbffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-9.67914288130669394539e+37, 0xc07d, 0x91a2b3c4L, 0xd5e6f780L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-9.99999999999999999946e-01, 0xbffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-9.67914288130669394631e+37, 0xc07d, 0x91a2b3c4L, 0xd5e6f781L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(4.83957155784060252369e+37, 0x407c, 0x91a2b400L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(4.83957105078036243240e+37, 0x407c, 0x91a2b300L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(4.83957144065334703173e+37, 0x407c, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(4.83957144065334608725e+37, 0x407c, 0x91a2b3c4L, 0xd5e6f000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(4.83957144065334697316e+37, 0x407c, 0x91a2b3c4L, 0xd5e6f781L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(4.83957144065334697270e+37, 0x407c, 0x91a2b3c4L, 0xd5e6f780L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(-1.00000011920928955078e+00, 0xbfff, 0x80000100L, 0x00000000L), HEXCONSTE(4.83957155784060252369e+37, 0x407c, 0x91a2b400L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.00000011920928955078e+00, 0xbfff, 0x80000100L, 0x00000000L), HEXCONSTE(4.83957105078036243240e+37, 0x407c, 0x91a2b300L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.00000011920928955078e+00, 0xbfff, 0x80000100L, 0x00000000L), HEXCONSTE(4.83957144065334703173e+37, 0x407c, 0x91a2b3c4L, 0xd5e6f800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.00000011920928955078e+00, 0xbfff, 0x80000100L, 0x00000000L), HEXCONSTE(4.83957144065334608725e+37, 0x407c, 0x91a2b3c4L, 0xd5e6f000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.00000011920928955078e+00, 0xbfff, 0x80000100L, 0x00000000L), HEXCONSTE(4.83957144065334697316e+37, 0x407c, 0x91a2b3c4L, 0xd5e6f781L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.00000011920928955078e+00, 0xbfff, 0x80000100L, 0x00000000L), HEXCONSTE(4.83957144065334697270e+37, 0x407c, 0x91a2b3c4L, 0xd5e6f780L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000022204e+00, 0xbfff, 0x80000000L, 0x00000800L), HEXCONSTE(4.83957155784060252369e+37, 0x407c, 0x91a2b400L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000022204e+00, 0xbfff, 0x80000000L, 0x00000800L), HEXCONSTE(4.83957105078036243240e+37, 0x407c, 0x91a2b300L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000022204e+00, 0xbfff, 0x80000000L, 0x00000800L), HEXCONSTE(4.83957144065334703173e+37, 0x407c, 0x91a2b3c4L, 0xd5e6f800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000022204e+00, 0xbfff, 0x80000000L, 0x00000800L), HEXCONSTE(4.83957144065334608725e+37, 0x407c, 0x91a2b3c4L, 0xd5e6f000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000022204e+00, 0xbfff, 0x80000000L, 0x00000800L), HEXCONSTE(4.83957144065334697316e+37, 0x407c, 0x91a2b3c4L, 0xd5e6f781L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000022204e+00, 0xbfff, 0x80000000L, 0x00000800L), HEXCONSTE(4.83957144065334697270e+37, 0x407c, 0x91a2b3c4L, 0xd5e6f780L), INF_P, 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-1.00000000000000000011e+00, 0xbfff, 0x80000000L, 0x00000001L), HEXCONSTE(4.83957155784060252369e+37, 0x407c, 0x91a2b400L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000011e+00, 0xbfff, 0x80000000L, 0x00000001L), HEXCONSTE(4.83957105078036243240e+37, 0x407c, 0x91a2b300L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000011e+00, 0xbfff, 0x80000000L, 0x00000001L), HEXCONSTE(4.83957144065334703173e+37, 0x407c, 0x91a2b3c4L, 0xd5e6f800L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000011e+00, 0xbfff, 0x80000000L, 0x00000001L), HEXCONSTE(4.83957144065334608725e+37, 0x407c, 0x91a2b3c4L, 0xd5e6f000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000011e+00, 0xbfff, 0x80000000L, 0x00000001L), HEXCONSTE(4.83957144065334697316e+37, 0x407c, 0x91a2b3c4L, 0xd5e6f781L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000011e+00, 0xbfff, 0x80000000L, 0x00000001L), HEXCONSTE(4.83957144065334697270e+37, 0x407c, 0x91a2b3c4L, 0xd5e6f780L), INF_P, 0 },
#endif
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-4.83957105078036243240e+37, 0xc07c, 0x91a2b300L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-4.83957155784060252369e+37, 0xc07c, 0x91a2b400L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-4.83957144065334608725e+37, 0xc07c, 0x91a2b3c4L, 0xd5e6f000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-4.83957144065334703173e+37, 0xc07c, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-4.83957144065334697270e+37, 0xc07c, 0x91a2b3c4L, 0xd5e6f780L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-4.83957144065334697316e+37, 0xc07c, 0x91a2b3c4L, 0xd5e6f781L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000011920928955078e+00, 0xbfff, 0x80000100L, 0x00000000L), HEXCONSTE(-4.83957105078036243240e+37, 0xc07c, 0x91a2b300L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000011920928955078e+00, 0xbfff, 0x80000100L, 0x00000000L), HEXCONSTE(-4.83957155784060252369e+37, 0xc07c, 0x91a2b400L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000011920928955078e+00, 0xbfff, 0x80000100L, 0x00000000L), HEXCONSTE(-4.83957144065334608725e+37, 0xc07c, 0x91a2b3c4L, 0xd5e6f000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000011920928955078e+00, 0xbfff, 0x80000100L, 0x00000000L), HEXCONSTE(-4.83957144065334703173e+37, 0xc07c, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000011920928955078e+00, 0xbfff, 0x80000100L, 0x00000000L), HEXCONSTE(-4.83957144065334697270e+37, 0xc07c, 0x91a2b3c4L, 0xd5e6f780L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000011920928955078e+00, 0xbfff, 0x80000100L, 0x00000000L), HEXCONSTE(-4.83957144065334697316e+37, 0xc07c, 0x91a2b3c4L, 0xd5e6f781L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000022204e+00, 0xbfff, 0x80000000L, 0x00000800L), HEXCONSTE(-4.83957105078036243240e+37, 0xc07c, 0x91a2b300L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000022204e+00, 0xbfff, 0x80000000L, 0x00000800L), HEXCONSTE(-4.83957155784060252369e+37, 0xc07c, 0x91a2b400L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000022204e+00, 0xbfff, 0x80000000L, 0x00000800L), HEXCONSTE(-4.83957144065334608725e+37, 0xc07c, 0x91a2b3c4L, 0xd5e6f000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000022204e+00, 0xbfff, 0x80000000L, 0x00000800L), HEXCONSTE(-4.83957144065334703173e+37, 0xc07c, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000022204e+00, 0xbfff, 0x80000000L, 0x00000800L), HEXCONSTE(-4.83957144065334697270e+37, 0xc07c, 0x91a2b3c4L, 0xd5e6f780L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000022204e+00, 0xbfff, 0x80000000L, 0x00000800L), HEXCONSTE(-4.83957144065334697316e+37, 0xc07c, 0x91a2b3c4L, 0xd5e6f781L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-1.00000000000000000011e+00, 0xbfff, 0x80000000L, 0x00000001L), HEXCONSTE(-4.83957105078036243240e+37, 0xc07c, 0x91a2b300L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000011e+00, 0xbfff, 0x80000000L, 0x00000001L), HEXCONSTE(-4.83957155784060252369e+37, 0xc07c, 0x91a2b400L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000011e+00, 0xbfff, 0x80000000L, 0x00000001L), HEXCONSTE(-4.83957144065334608725e+37, 0xc07c, 0x91a2b3c4L, 0xd5e6f000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000011e+00, 0xbfff, 0x80000000L, 0x00000001L), HEXCONSTE(-4.83957144065334703173e+37, 0xc07c, 0x91a2b3c4L, 0xd5e6f800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000011e+00, 0xbfff, 0x80000000L, 0x00000001L), HEXCONSTE(-4.83957144065334697270e+37, 0xc07c, 0x91a2b3c4L, 0xd5e6f780L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000000000000000011e+00, 0xbfff, 0x80000000L, 0x00000001L), HEXCONSTE(-4.83957144065334697316e+37, 0xc07c, 0x91a2b3c4L, 0xd5e6f781L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(1.07374182400000000000e+09, 0x401d, 0x80000000L, 0x00000000L), HEXCONSTE(3.88767874524884743622e+55, 0x40b7, 0xcaf240b5L, 0xb0dee3a8L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(-1.00000011920928955078e+00, 0xbfff, 0x80000100L, 0x00000000L), HEXCONSTE(1.07374182400000000000e+09, 0x401d, 0x80000000L, 0x00000000L), HEXCONSTE(3.88767874524884743622e+55, 0x40b7, 0xcaf240b5L, 0xb0dee3a8L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), INF_P, 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), INF_P, 0 },
#endif
	{ __LINE__,  HEXCONSTE(-1.00000011920928955078e+00, 0xbfff, 0x80000100L, 0x00000000L), HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.00000011920928955078e+00, 0xbfff, 0x80000100L, 0x00000000L), HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), INF_P, 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-1.00000011920928955078e+00, 0xbfff, 0x80000100L, 0x00000000L), HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(1.00000083446502685547e+00, 0x3fff, 0x80000700L, 0x00000000L), HEXCONSTE(1.07374182400000000000e+09, 0x401d, 0x80000000L, 0x00000000L), HEXCONSTE(1.34181742881446768735e+389, 0x450b, 0xc97107c6L, 0xe5829f58L), 0 },
	{ __LINE__,  HEXCONSTE(-1.00000083446502685547e+00, 0xbfff, 0x80000700L, 0x00000000L), HEXCONSTE(1.07374182400000000000e+09, 0x401d, 0x80000000L, 0x00000000L), HEXCONSTE(1.34181742881446768735e+389, 0x450b, 0xc97107c6L, 0xe5829f58L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(1.00000083446502685547e+00, 0x3fff, 0x80000700L, 0x00000000L), HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(1.00000083446502685547e+00, 0x3fff, 0x80000700L, 0x00000000L), HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), INF_P, 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(1.00000083446502685547e+00, 0x3fff, 0x80000700L, 0x00000000L), HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), INF_P, 0 },
#endif
	{ __LINE__,  HEXCONSTE(-1.00000083446502685547e+00, 0xbfff, 0x80000700L, 0x00000000L), HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__,  HEXCONSTE(-1.00000083446502685547e+00, 0xbfff, 0x80000700L, 0x00000000L), HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), INF_P, 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(-1.00000083446502685547e+00, 0xbfff, 0x80000700L, 0x00000000L), HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), INF_P, 0 },
#endif
	{ __LINE__,  HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(7.50000000000000000000e-01, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(7.92281589724894490530e+28, 0x405e, 0xffffff3fL, 0xffffe800L), 0 },
	{ __LINE__,  HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(7.50000000000000000000e-01, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(1.55251809230070880588e+231, 0x42fe, 0xffffffffL, 0xfffffa00L), FLAG_INEXACT },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(1.00000000000000000001e+4932, 0x7ffe, 0xd72cb2a9L, 0x5c7ef6cdL), HEXCONSTE(7.50000000000000000000e-01, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(1.00000000000000000001e+3699, 0x6ffe, 0xe0b9d894L, 0xb9a782d8L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999999942e+4931, 0x7ffe, 0xd72cb2a9L, 0x5c7ef6ccL), HEXCONSTE(7.50000000000000000000e-01, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(9.99999999999999999944e+3698, 0x6ffe, 0xe0b9d894L, 0xb9a782d7L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(7.50000000000000000000e-01, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(7.92281589724894490530e+28, 0x405e, 0xffffff3fL, 0xffffe800L), 0 },
	{ __LINE__,  HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(7.50000000000000000000e-01, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(1.55251809230070880588e+231, 0x42fe, 0xffffffffL, 0xfffffa00L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(1.00000000000000000005e+4928, 0x7ff1, 0xb045626fL, 0xb50a35e8L), HEXCONSTE(7.50000000000000000000e-01, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(1.00000000000000000007e+3696, 0x6ff4, 0xe61e8ff4L, 0x7461cdabL), 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999999973e+4927, 0x7ff1, 0xb045626fL, 0xb50a35e7L), HEXCONSTE(7.50000000000000000000e-01, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(1.00000000000000000001e+3696, 0x6ff4, 0xe61e8ff4L, 0x7461cdaaL), 0 },
	{ __LINE__,  HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(7.50000000000000000000e-01, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(7.92281589724894490530e+28, 0x405e, 0xffffff3fL, 0xffffe800L), 0 },
	{ __LINE__,  HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(7.50000000000000000000e-01, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(1.55251809230070880588e+231, 0x42fe, 0xffffffffL, 0xfffffa00L), FLAG_INEXACT },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(1.00000000000000000006e+4924, 0x7fe4, 0x9066b70aL, 0x00085d50L), HEXCONSTE(7.50000000000000000000e-01, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(1.00000000000000000004e+3693, 0x6fea, 0xeba46a73L, 0x274d9f67L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999999968e+4923, 0x7fe4, 0x9066b70aL, 0x00085d4fL), HEXCONSTE(7.50000000000000000000e-01, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(9.99999999999999999984e+3692, 0x6fea, 0xeba46a73L, 0x274d9f66L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(7.50000000000000000000e-01, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(7.92281589724894490530e+28, 0x405e, 0xffffff3fL, 0xffffe800L), 0 },
	{ __LINE__,  HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(7.50000000000000000000e-01, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(1.55251809230070880588e+231, 0x42fe, 0xffffffffL, 0xfffffa00L), FLAG_INEXACT },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(1.00000000000000000004e+4920, 0x7fd6, 0xec96440eL, 0xbeed5893L), HEXCONSTE(7.50000000000000000000e-01, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(1.00000000000000000003e+3690, 0x6fe0, 0xf14c33a9L, 0x1e01a95fL), 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999999978e+4919, 0x7fd6, 0xec96440eL, 0xbeed5892L), HEXCONSTE(7.50000000000000000000e-01, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(9.99999999999999999972e+3689, 0x6fe0, 0xf14c33a9L, 0x1e01a95eL), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+01, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(4.93200000000000000000e+03, 0x400b, 0x9a200000L, 0x00000000L), HEXCONSTE(1.00000000000000000001e+4932, 0x7ffe, 0xd72cb2a9L, 0x5c7ef6cdL), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+01, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(4.93100000000000000000e+03, 0x400b, 0x9a180000L, 0x00000000L), HEXCONSTE(1.00000000000000000001e+4931, 0x7ffb, 0xac23c221L, 0x16cbf8a4L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+01, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(4.93000000000000000000e+03, 0x400b, 0x9a100000L, 0x00000000L), HEXCONSTE(1.00000000000000000003e+4930, 0x7ff8, 0x89b634e7L, 0x456ffa1dL), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+01, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(4.92900000000000000000e+03, 0x400b, 0x9a080000L, 0x00000000L), HEXCONSTE(9.99999999999999999988e+4928, 0x7ff4, 0xdc56bb0bL, 0xa24cc361L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+01, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(-4.93100000000000000000e+03, 0xc00b, 0x9a180000L, 0x00000000L), HEXCONSTE(1.00000000000000000001e-4931, 0x0002, 0xbe5b66ecL, 0xbce0b7b1L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+01, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(-4.93000000000000000000e+03, 0xc00b, 0x9a100000L, 0x00000000L), HEXCONSTE(9.99999999999999999994e-4931, 0x0005, 0xedf240a7L, 0xec18e59dL), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+01, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(-4.92900000000000000000e+03, 0xc00b, 0x9a080000L, 0x00000000L), HEXCONSTE(9.99999999999999999982e-4930, 0x0009, 0x94b76868L, 0xf38f8f82L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000006227113104857e+27, 0x4058, 0xcecb9000L, 0x00000000L), HEXCONSTE(1.82000000000000000000e+02, 0x4006, 0xb6000000L, 0x00000000L), HEXCONSTE(1.00001133340972057289e+4914, 0x7fc2, 0xf8150d73L, 0xa5bad7b7L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999988484154753735e+26, 0x4058, 0xcecb8f00L, 0x00000000L), HEXCONSTE(1.82000000000000000000e+02, 0x4006, 0xb6000000L, 0x00000000L), HEXCONSTE(9.99997904118349474843e+4913, 0x7fc2, 0xf814331dL, 0xd58d7f20L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000001329e+27, 0x4058, 0xcecb8f27L, 0xf4201000L), HEXCONSTE(1.82000000000000000000e+02, 0x4006, 0xb6000000L, 0x00000000L), HEXCONSTE(1.00000000000000241834e+4914, 0x7fc2, 0xf8145531L, 0x10d16d4aL), 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999875849e+26, 0x4058, 0xcecb8f27L, 0xf4200800L), HEXCONSTE(1.82000000000000000000e+02, 0x4006, 0xb6000000L, 0x00000000L), HEXCONSTE(9.99999999999977404472e+4913, 0x7fc2, 0xf8145531L, 0x10ca9a9eL), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+27, 0x4058, 0xcecb8f27L, 0xf4200f3aL), HEXCONSTE(1.82000000000000000000e+02, 0x4006, 0xb6000000L, 0x00000000L), HEXCONSTE(1.00000000000000000001e+4914, 0x7fc2, 0xf8145531L, 0x10d0c46cL), 0 },
	{ __LINE__,  HEXCONSTE(1.00000006227113104857e+27, 0x4058, 0xcecb9000L, 0x00000000L), HEXCONSTE(-1.82000000000000000000e+02, 0xc006, 0xb6000000L, 0x00000000L), HEXCONSTE(9.99988666718724147310e-4915, 0x003b, 0x8415d1d3L, 0x9fa9bc66L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999988484154753735e+26, 0x4058, 0xcecb8f00L, 0x00000000L), HEXCONSTE(-1.82000000000000000000e+02, 0xc006, 0xb6000000L, 0x00000000L), HEXCONSTE(1.00000209588604325430e-4914, 0x003b, 0x84164613L, 0x4c345c43L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000001329e+27, 0x4058, 0xcecb8f27L, 0xf4201000L), HEXCONSTE(-1.82000000000000000000e+02, 0xc006, 0xb6000000L, 0x00000000L), HEXCONSTE(9.99999999999997581630e-4915, 0x003b, 0x841633eeL, 0xb6e53abfL), 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999875849e+26, 0x4058, 0xcecb8f27L, 0xf4200800L), HEXCONSTE(-1.82000000000000000000e+02, 0xc006, 0xb6000000L, 0x00000000L), HEXCONSTE(1.00000000000002259557e-4914, 0x003b, 0x841633eeL, 0xb6e8dcbeL), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+27, 0x4058, 0xcecb8f27L, 0xf4200f3aL), HEXCONSTE(-1.82000000000000000000e+02, 0xc006, 0xb6000000L, 0x00000000L), HEXCONSTE(1.00000000000000000003e-4914, 0x003b, 0x841633eeL, 0xb6e594a9L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.90000009536743164062e-01, 0x3ffe, 0xfd70a400L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.90000009536743164062e-01, 0x3ffe, 0xfd70a400L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(9.90000009536743164062e-01, 0x3ffe, 0xfd70a400L, 0x00000000L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(9.90000009536743164062e-01, 0x3ffe, 0xfd70a400L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.89999949932098388672e-01, 0x3ffe, 0xfd70a300L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.89999949932098388672e-01, 0x3ffe, 0xfd70a300L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(9.89999949932098388672e-01, 0x3ffe, 0xfd70a300L, 0x00000000L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(9.89999949932098388672e-01, 0x3ffe, 0xfd70a300L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.90000000000000102141e-01, 0x3ffe, 0xfd70a3d7L, 0x0a3d7800L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.90000000000000102141e-01, 0x3ffe, 0xfd70a3d7L, 0x0a3d7800L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(9.90000000000000102141e-01, 0x3ffe, 0xfd70a3d7L, 0x0a3d7800L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(9.90000000000000102141e-01, 0x3ffe, 0xfd70a3d7L, 0x0a3d7800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.89999999999999991118e-01, 0x3ffe, 0xfd70a3d7L, 0x0a3d7000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.89999999999999991118e-01, 0x3ffe, 0xfd70a3d7L, 0x0a3d7000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(9.89999999999999991118e-01, 0x3ffe, 0xfd70a3d7L, 0x0a3d7000L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(9.89999999999999991118e-01, 0x3ffe, 0xfd70a3d7L, 0x0a3d7000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.90000000000000000009e-01, 0x3ffe, 0xfd70a3d7L, 0x0a3d70a4L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.90000000000000000009e-01, 0x3ffe, 0xfd70a3d7L, 0x0a3d70a4L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(9.90000000000000000009e-01, 0x3ffe, 0xfd70a3d7L, 0x0a3d70a4L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(9.90000000000000000009e-01, 0x3ffe, 0xfd70a3d7L, 0x0a3d70a4L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.89999999999999999954e-01, 0x3ffe, 0xfd70a3d7L, 0x0a3d70a3L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.89999999999999999954e-01, 0x3ffe, 0xfd70a3d7L, 0x0a3d70a3L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(9.89999999999999999954e-01, 0x3ffe, 0xfd70a3d7L, 0x0a3d70a3L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(9.89999999999999999954e-01, 0x3ffe, 0xfd70a3d7L, 0x0a3d70a3L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.90000009536743164062e-01, 0x3ffe, 0xfd70a400L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.90000009536743164062e-01, 0x3ffe, 0xfd70a400L, 0x00000000L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(9.90000009536743164062e-01, 0x3ffe, 0xfd70a400L, 0x00000000L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(9.90000009536743164062e-01, 0x3ffe, 0xfd70a400L, 0x00000000L), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.89999949932098388672e-01, 0x3ffe, 0xfd70a300L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.89999949932098388672e-01, 0x3ffe, 0xfd70a300L, 0x00000000L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(9.89999949932098388672e-01, 0x3ffe, 0xfd70a300L, 0x00000000L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(9.89999949932098388672e-01, 0x3ffe, 0xfd70a300L, 0x00000000L), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.90000000000000102141e-01, 0x3ffe, 0xfd70a3d7L, 0x0a3d7800L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.90000000000000102141e-01, 0x3ffe, 0xfd70a3d7L, 0x0a3d7800L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(9.90000000000000102141e-01, 0x3ffe, 0xfd70a3d7L, 0x0a3d7800L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(9.90000000000000102141e-01, 0x3ffe, 0xfd70a3d7L, 0x0a3d7800L), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.89999999999999991118e-01, 0x3ffe, 0xfd70a3d7L, 0x0a3d7000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.89999999999999991118e-01, 0x3ffe, 0xfd70a3d7L, 0x0a3d7000L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(9.89999999999999991118e-01, 0x3ffe, 0xfd70a3d7L, 0x0a3d7000L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(9.89999999999999991118e-01, 0x3ffe, 0xfd70a3d7L, 0x0a3d7000L), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.90000000000000000009e-01, 0x3ffe, 0xfd70a3d7L, 0x0a3d70a4L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.90000000000000000009e-01, 0x3ffe, 0xfd70a3d7L, 0x0a3d70a4L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(9.90000000000000000009e-01, 0x3ffe, 0xfd70a3d7L, 0x0a3d70a4L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(9.90000000000000000009e-01, 0x3ffe, 0xfd70a3d7L, 0x0a3d70a4L), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.89999999999999999954e-01, 0x3ffe, 0xfd70a3d7L, 0x0a3d70a3L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.89999999999999999954e-01, 0x3ffe, 0xfd70a3d7L, 0x0a3d70a3L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(9.89999999999999999954e-01, 0x3ffe, 0xfd70a3d7L, 0x0a3d70a3L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(9.89999999999999999954e-01, 0x3ffe, 0xfd70a3d7L, 0x0a3d70a3L), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.01000010967254638672e+00, 0x3fff, 0x8147af00L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.01000010967254638672e+00, 0x3fff, 0x8147af00L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(1.01000010967254638672e+00, 0x3fff, 0x8147af00L, 0x00000000L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(1.01000010967254638672e+00, 0x3fff, 0x8147af00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00999999046325683594e+00, 0x3fff, 0x8147ae00L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00999999046325683594e+00, 0x3fff, 0x8147ae00L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(1.00999999046325683594e+00, 0x3fff, 0x8147ae00L, 0x00000000L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(1.00999999046325683594e+00, 0x3fff, 0x8147ae00L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.01000000000000000888e+00, 0x3fff, 0x8147ae14L, 0x7ae14800L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.01000000000000000888e+00, 0x3fff, 0x8147ae14L, 0x7ae14800L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(1.01000000000000000888e+00, 0x3fff, 0x8147ae14L, 0x7ae14800L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(1.01000000000000000888e+00, 0x3fff, 0x8147ae14L, 0x7ae14800L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00999999999999978684e+00, 0x3fff, 0x8147ae14L, 0x7ae14000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00999999999999978684e+00, 0x3fff, 0x8147ae14L, 0x7ae14000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(1.00999999999999978684e+00, 0x3fff, 0x8147ae14L, 0x7ae14000L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(1.00999999999999978684e+00, 0x3fff, 0x8147ae14L, 0x7ae14000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.01000000000000000010e+00, 0x3fff, 0x8147ae14L, 0x7ae147afL), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.01000000000000000010e+00, 0x3fff, 0x8147ae14L, 0x7ae147afL), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(1.01000000000000000010e+00, 0x3fff, 0x8147ae14L, 0x7ae147afL), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(1.01000000000000000010e+00, 0x3fff, 0x8147ae14L, 0x7ae147afL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00999999999999999999e+00, 0x3fff, 0x8147ae14L, 0x7ae147aeL), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00999999999999999999e+00, 0x3fff, 0x8147ae14L, 0x7ae147aeL), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(1.00999999999999999999e+00, 0x3fff, 0x8147ae14L, 0x7ae147aeL), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(1.00999999999999999999e+00, 0x3fff, 0x8147ae14L, 0x7ae147aeL), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.01000010967254638672e+00, 0x3fff, 0x8147af00L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.01000010967254638672e+00, 0x3fff, 0x8147af00L, 0x00000000L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(1.01000010967254638672e+00, 0x3fff, 0x8147af00L, 0x00000000L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(1.01000010967254638672e+00, 0x3fff, 0x8147af00L, 0x00000000L), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00999999046325683594e+00, 0x3fff, 0x8147ae00L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00999999046325683594e+00, 0x3fff, 0x8147ae00L, 0x00000000L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(1.00999999046325683594e+00, 0x3fff, 0x8147ae00L, 0x00000000L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(1.00999999046325683594e+00, 0x3fff, 0x8147ae00L, 0x00000000L), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.01000000000000000888e+00, 0x3fff, 0x8147ae14L, 0x7ae14800L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.01000000000000000888e+00, 0x3fff, 0x8147ae14L, 0x7ae14800L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(1.01000000000000000888e+00, 0x3fff, 0x8147ae14L, 0x7ae14800L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(1.01000000000000000888e+00, 0x3fff, 0x8147ae14L, 0x7ae14800L), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00999999999999978684e+00, 0x3fff, 0x8147ae14L, 0x7ae14000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00999999999999978684e+00, 0x3fff, 0x8147ae14L, 0x7ae14000L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(1.00999999999999978684e+00, 0x3fff, 0x8147ae14L, 0x7ae14000L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(1.00999999999999978684e+00, 0x3fff, 0x8147ae14L, 0x7ae14000L), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.01000000000000000010e+00, 0x3fff, 0x8147ae14L, 0x7ae147afL), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.01000000000000000010e+00, 0x3fff, 0x8147ae14L, 0x7ae147afL), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(1.01000000000000000010e+00, 0x3fff, 0x8147ae14L, 0x7ae147afL), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(1.01000000000000000010e+00, 0x3fff, 0x8147ae14L, 0x7ae147afL), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00999999999999999999e+00, 0x3fff, 0x8147ae14L, 0x7ae147aeL), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00999999999999999999e+00, 0x3fff, 0x8147ae14L, 0x7ae147aeL), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(1.00999999999999999999e+00, 0x3fff, 0x8147ae14L, 0x7ae147aeL), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(1.00999999999999999999e+00, 0x3fff, 0x8147ae14L, 0x7ae147aeL), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+05, 0xc00f, 0xc3500000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.26125000000000000000e+02, 0xc005, 0xfc400000L, 0x00000000L), HEXCONSTE(1.07793307246828789602e-38, 0x3f80, 0xeac0c6e7L, 0xdd24392fL), 0 },
	{ __LINE__,  HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.26250000000000000000e+02, 0xc005, 0xfc800000L, 0x00000000L), HEXCONSTE(9.88468985757453879590e-39, 0x3f80, 0xd744fccaL, 0xd69d6af4L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.26375000000000000000e+02, 0xc005, 0xfcc00000L, 0x00000000L), HEXCONSTE(9.06430056522005789823e-39, 0x3f80, 0xc5672a11L, 0x5506daddL), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.26500000000000000000e+02, 0xc005, 0xfd000000L, 0x00000000L), HEXCONSTE(8.31200026712917983887e-39, 0x3f80, 0xb504f333L, 0xf9de6484L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.26625000000000000000e+02, 0xc005, 0xfd400000L, 0x00000000L), HEXCONSTE(7.62213785207576524858e-39, 0x3f80, 0xa5fed6a9L, 0xb15138eaL), 0 },
	{ __LINE__,  HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.26750000000000000000e+02, 0xc005, 0xfd800000L, 0x00000000L), HEXCONSTE(6.98953122821684501786e-39, 0x3f80, 0x9837f051L, 0x8db8a96fL), 0 },
	{ __LINE__,  HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.26875000000000000000e+02, 0xc005, 0xfdc00000L, 0x00000000L), HEXCONSTE(6.40942839638015852804e-39, 0x3f80, 0x8b95c1e3L, 0xea8bd6e7L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-9.69125000000000000000e+02, 0xc008, 0xf2480000L, 0x00000000L), HEXCONSTE(1.83783048939110316058e-292, 0x3c35, 0xeac0c6e7L, 0xdd24392fL), 0 },
	{ __LINE__,  HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-9.69250000000000000000e+02, 0xc008, 0xf2500000L, 0x00000000L), HEXCONSTE(1.68529798949646123644e-292, 0x3c35, 0xd744fccaL, 0xd69d6af4L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-9.69375000000000000000e+02, 0xc008, 0xf2580000L, 0x00000000L), HEXCONSTE(1.54542507037295850337e-292, 0x3c35, 0xc5672a11L, 0x5506daddL), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-9.69500000000000000000e+02, 0xc008, 0xf2600000L, 0x00000000L), HEXCONSTE(1.41716103800186651817e-292, 0x3c35, 0xb504f333L, 0xf9de6484L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-9.69625000000000000000e+02, 0xc008, 0xf2680000L, 0x00000000L), HEXCONSTE(1.29954240171984033396e-292, 0x3c35, 0xa5fed6a9L, 0xb15138eaL), 0 },
	{ __LINE__,  HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-9.69750000000000000000e+02, 0xc008, 0xf2700000L, 0x00000000L), HEXCONSTE(1.19168563669300268360e-292, 0x3c35, 0x9837f051L, 0x8db8a96fL), 0 },
	{ __LINE__,  HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-9.69875000000000000000e+02, 0xc008, 0xf2780000L, 0x00000000L), HEXCONSTE(1.09278054707641637781e-292, 0x3c35, 0x8b95c1e3L, 0xea8bd6e7L), FLAG_INEXACT },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.02212500000000000000e+03, 0xc008, 0xff880000L, 0x00000000L), HEXCONSTE(2.04040172468012222027e-308, 0x3c00, 0xeac0c6e7L, 0xdd24392fL), 0 },
	{ __LINE__,  HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.02225000000000000000e+03, 0xc008, 0xff900000L, 0x00000000L), HEXCONSTE(1.87105663129345649192e-308, 0x3c00, 0xd744fccaL, 0xd69d6af4L), 0 },
	{ __LINE__,  HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.02237500000000000000e+03, 0xc008, 0xff980000L, 0x00000000L), HEXCONSTE(1.71576649596101138792e-308, 0x3c00, 0xc5672a11L, 0x5506daddL), 0 },
	{ __LINE__,  HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.02250000000000000000e+03, 0xc008, 0xffa00000L, 0x00000000L), HEXCONSTE(1.57336481399135865519e-308, 0x3c00, 0xb504f333L, 0xf9de6484L), 0 },
	{ __LINE__,  HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.02262500000000000000e+03, 0xc008, 0xffa80000L, 0x00000000L), HEXCONSTE(1.44278189586604136836e-308, 0x3c00, 0xa5fed6a9L, 0xb15138eaL), 0 },
	{ __LINE__,  HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.02275000000000000000e+03, 0xc008, 0xffb00000L, 0x00000000L), HEXCONSTE(1.32303683197166086893e-308, 0x3c00, 0x9837f051L, 0x8db8a96fL), 0 },
	{ __LINE__,  HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.02287500000000000000e+03, 0xc008, 0xffb80000L, 0x00000000L), HEXCONSTE(1.21323012422671225631e-308, 0x3c00, 0x8b95c1e3L, 0xea8bd6e7L), 0 },
	{ __LINE__,  HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.63821250000000000000e+04, 0xc00c, 0xfff88000L, 0x00000000L), HEXCONSTE(3.08306217590492313920e-4932, 0x0000, 0x75606373L, 0xee921c98L), 0 },
	{ __LINE__,  HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.63822500000000000000e+04, 0xc00c, 0xfff90000L, 0x00000000L), HEXCONSTE(2.82718048075620583510e-4932, 0x0000, 0x6ba27e65L, 0x6b4eb57aL), 0 },
	{ __LINE__,  HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.63823750000000000000e+04, 0xc00c, 0xfff98000L, 0x00000000L), HEXCONSTE(2.59253593172276695929e-4932, 0x0000, 0x62b39508L, 0xaa836d6eL), 0 },
	{ __LINE__,  HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.63825000000000000000e+04, 0xc00c, 0xfffa0000L, 0x00000000L), HEXCONSTE(2.37736593154316677945e-4932, 0x0000, 0x5a827999L, 0xfcef3242L), 0 },
	{ __LINE__,  HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.63826250000000000000e+04, 0xc00c, 0xfffa8000L, 0x00000000L), HEXCONSTE(2.18005417140212357933e-4932, 0x0000, 0x52ff6b54L, 0xd8a89c75L), 0 },
	{ __LINE__,  HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.63827500000000000000e+04, 0xc00c, 0xfffb0000L, 0x00000000L), HEXCONSTE(1.99911848958095667371e-4932, 0x0000, 0x4c1bf828L, 0xc6dc54b8L), 0 },
	{ __LINE__,  HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.63828750000000000000e+04, 0xc00c, 0xfffb8000L, 0x00000000L), HEXCONSTE(1.83319973779095268933e-4932, 0x0000, 0x45cae0f1L, 0xf545eb74L), 0 },
	{ __LINE__,  HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.63831250000000000000e+04, 0xc00c, 0xfffc8000L, 0x00000000L), HEXCONSTE(1.54153108795246156960e-4932, 0x0000, 0x3ab031b9L, 0xf7490e4cL), 0 },
	{ __LINE__,  HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.63832500000000000000e+04, 0xc00c, 0xfffd0000L, 0x00000000L), HEXCONSTE(1.41359024037810291755e-4932, 0x0000, 0x35d13f32L, 0xb5a75abdL), 0 },
	{ __LINE__,  HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.63833750000000000000e+04, 0xc00c, 0xfffd8000L, 0x00000000L), HEXCONSTE(1.29626796586138348001e-4932, 0x0000, 0x3159ca84L, 0x5541b6b8L), 0 },
	{ __LINE__,  HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.63835000000000000000e+04, 0xc00c, 0xfffe0000L, 0x00000000L), HEXCONSTE(1.18868296577158338972e-4932, 0x0000, 0x2d413cccL, 0xfe779921L), 0 },
	{ __LINE__,  HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.63836250000000000000e+04, 0xc00c, 0xfffe8000L, 0x00000000L), HEXCONSTE(1.09002708570106178948e-4932, 0x0000, 0x297fb5aaL, 0x6c544e3aL), 0 },
	{ __LINE__,  HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.63837500000000000000e+04, 0xc00c, 0xffff0000L, 0x00000000L), HEXCONSTE(9.99559244790478336855e-4933, 0x0000, 0x260dfc14L, 0x636e2a5cL), 0 },
	{ __LINE__,  HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.63838750000000000000e+04, 0xc00c, 0xffff8000L, 0x00000000L), HEXCONSTE(9.16599868895476344664e-4933, 0x0000, 0x22e57078L, 0xfaa2f5baL), 0 },
#endif
	{ __LINE__,  HEXCONSTE(5.00000000000000000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.26125000000000000000e+02, 0x4005, 0xfc400000L, 0x00000000L), HEXCONSTE(1.07793307246828789602e-38, 0x3f80, 0xeac0c6e7L, 0xdd24392fL), 0 },
	{ __LINE__,  HEXCONSTE(5.00000000000000000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.26250000000000000000e+02, 0x4005, 0xfc800000L, 0x00000000L), HEXCONSTE(9.88468985757453879590e-39, 0x3f80, 0xd744fccaL, 0xd69d6af4L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(5.00000000000000000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.26375000000000000000e+02, 0x4005, 0xfcc00000L, 0x00000000L), HEXCONSTE(9.06430056522005789823e-39, 0x3f80, 0xc5672a11L, 0x5506daddL), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(5.00000000000000000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.26500000000000000000e+02, 0x4005, 0xfd000000L, 0x00000000L), HEXCONSTE(8.31200026712917983887e-39, 0x3f80, 0xb504f333L, 0xf9de6484L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(5.00000000000000000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.26625000000000000000e+02, 0x4005, 0xfd400000L, 0x00000000L), HEXCONSTE(7.62213785207576524858e-39, 0x3f80, 0xa5fed6a9L, 0xb15138eaL), 0 },
	{ __LINE__,  HEXCONSTE(5.00000000000000000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.26750000000000000000e+02, 0x4005, 0xfd800000L, 0x00000000L), HEXCONSTE(6.98953122821684501786e-39, 0x3f80, 0x9837f051L, 0x8db8a96fL), 0 },
	{ __LINE__,  HEXCONSTE(5.00000000000000000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.26875000000000000000e+02, 0x4005, 0xfdc00000L, 0x00000000L), HEXCONSTE(6.40942839638015852804e-39, 0x3f80, 0x8b95c1e3L, 0xea8bd6e7L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(5.00000000000000000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(9.69125000000000000000e+02, 0x4008, 0xf2480000L, 0x00000000L), HEXCONSTE(1.83783048939110316058e-292, 0x3c35, 0xeac0c6e7L, 0xdd24392fL), 0 },
	{ __LINE__,  HEXCONSTE(5.00000000000000000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(9.69250000000000000000e+02, 0x4008, 0xf2500000L, 0x00000000L), HEXCONSTE(1.68529798949646123644e-292, 0x3c35, 0xd744fccaL, 0xd69d6af4L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(5.00000000000000000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(9.69375000000000000000e+02, 0x4008, 0xf2580000L, 0x00000000L), HEXCONSTE(1.54542507037295850337e-292, 0x3c35, 0xc5672a11L, 0x5506daddL), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(5.00000000000000000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(9.69500000000000000000e+02, 0x4008, 0xf2600000L, 0x00000000L), HEXCONSTE(1.41716103800186651817e-292, 0x3c35, 0xb504f333L, 0xf9de6484L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(5.00000000000000000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(9.69625000000000000000e+02, 0x4008, 0xf2680000L, 0x00000000L), HEXCONSTE(1.29954240171984033396e-292, 0x3c35, 0xa5fed6a9L, 0xb15138eaL), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(5.00000000000000000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(9.69750000000000000000e+02, 0x4008, 0xf2700000L, 0x00000000L), HEXCONSTE(1.19168563669300268360e-292, 0x3c35, 0x9837f051L, 0x8db8a96fL), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(5.00000000000000000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(9.69875000000000000000e+02, 0x4008, 0xf2780000L, 0x00000000L), HEXCONSTE(1.09278054707641637781e-292, 0x3c35, 0x8b95c1e3L, 0xea8bd6e7L), FLAG_INEXACT },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(5.00000000000000000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.02212500000000000000e+03, 0x4008, 0xff880000L, 0x00000000L), HEXCONSTE(2.04040172468012222027e-308, 0x3c00, 0xeac0c6e7L, 0xdd24392fL), 0 },
	{ __LINE__,  HEXCONSTE(5.00000000000000000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.02225000000000000000e+03, 0x4008, 0xff900000L, 0x00000000L), HEXCONSTE(1.87105663129345649192e-308, 0x3c00, 0xd744fccaL, 0xd69d6af4L), 0 },
	{ __LINE__,  HEXCONSTE(5.00000000000000000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.02237500000000000000e+03, 0x4008, 0xff980000L, 0x00000000L), HEXCONSTE(1.71576649596101138792e-308, 0x3c00, 0xc5672a11L, 0x5506daddL), 0 },
	{ __LINE__,  HEXCONSTE(5.00000000000000000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.02250000000000000000e+03, 0x4008, 0xffa00000L, 0x00000000L), HEXCONSTE(1.57336481399135865519e-308, 0x3c00, 0xb504f333L, 0xf9de6484L), 0 },
	{ __LINE__,  HEXCONSTE(5.00000000000000000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.02262500000000000000e+03, 0x4008, 0xffa80000L, 0x00000000L), HEXCONSTE(1.44278189586604136836e-308, 0x3c00, 0xa5fed6a9L, 0xb15138eaL), 0 },
	{ __LINE__,  HEXCONSTE(5.00000000000000000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.02275000000000000000e+03, 0x4008, 0xffb00000L, 0x00000000L), HEXCONSTE(1.32303683197166086893e-308, 0x3c00, 0x9837f051L, 0x8db8a96fL), 0 },
	{ __LINE__,  HEXCONSTE(5.00000000000000000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.02287500000000000000e+03, 0x4008, 0xffb80000L, 0x00000000L), HEXCONSTE(1.21323012422671225631e-308, 0x3c00, 0x8b95c1e3L, 0xea8bd6e7L), 0 },
	{ __LINE__,  HEXCONSTE(5.00000000000000000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.63821250000000000000e+04, 0x400c, 0xfff88000L, 0x00000000L), HEXCONSTE(3.08306217590492313920e-4932, 0x0000, 0x75606373L, 0xee921c98L), 0 },
	{ __LINE__,  HEXCONSTE(5.00000000000000000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.63822500000000000000e+04, 0x400c, 0xfff90000L, 0x00000000L), HEXCONSTE(2.82718048075620583510e-4932, 0x0000, 0x6ba27e65L, 0x6b4eb57aL), 0 },
	{ __LINE__,  HEXCONSTE(5.00000000000000000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.63823750000000000000e+04, 0x400c, 0xfff98000L, 0x00000000L), HEXCONSTE(2.59253593172276695929e-4932, 0x0000, 0x62b39508L, 0xaa836d6eL), 0 },
	{ __LINE__,  HEXCONSTE(5.00000000000000000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.63825000000000000000e+04, 0x400c, 0xfffa0000L, 0x00000000L), HEXCONSTE(2.37736593154316677945e-4932, 0x0000, 0x5a827999L, 0xfcef3242L), 0 },
	{ __LINE__,  HEXCONSTE(5.00000000000000000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.63826250000000000000e+04, 0x400c, 0xfffa8000L, 0x00000000L), HEXCONSTE(2.18005417140212357933e-4932, 0x0000, 0x52ff6b54L, 0xd8a89c75L), 0 },
	{ __LINE__,  HEXCONSTE(5.00000000000000000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.63827500000000000000e+04, 0x400c, 0xfffb0000L, 0x00000000L), HEXCONSTE(1.99911848958095667371e-4932, 0x0000, 0x4c1bf828L, 0xc6dc54b8L), 0 },
	{ __LINE__,  HEXCONSTE(5.00000000000000000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.63828750000000000000e+04, 0x400c, 0xfffb8000L, 0x00000000L), HEXCONSTE(1.83319973779095268933e-4932, 0x0000, 0x45cae0f1L, 0xf545eb74L), 0 },
	{ __LINE__,  HEXCONSTE(5.00000000000000000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.63831250000000000000e+04, 0x400c, 0xfffc8000L, 0x00000000L), HEXCONSTE(1.54153108795246156960e-4932, 0x0000, 0x3ab031b9L, 0xf7490e4cL), 0 },
	{ __LINE__,  HEXCONSTE(5.00000000000000000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.63832500000000000000e+04, 0x400c, 0xfffd0000L, 0x00000000L), HEXCONSTE(1.41359024037810291755e-4932, 0x0000, 0x35d13f32L, 0xb5a75abdL), 0 },
	{ __LINE__,  HEXCONSTE(5.00000000000000000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.63833750000000000000e+04, 0x400c, 0xfffd8000L, 0x00000000L), HEXCONSTE(1.29626796586138348001e-4932, 0x0000, 0x3159ca84L, 0x5541b6b8L), 0 },
	{ __LINE__,  HEXCONSTE(5.00000000000000000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.63835000000000000000e+04, 0x400c, 0xfffe0000L, 0x00000000L), HEXCONSTE(1.18868296577158338972e-4932, 0x0000, 0x2d413cccL, 0xfe779921L), 0 },
	{ __LINE__,  HEXCONSTE(5.00000000000000000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.63836250000000000000e+04, 0x400c, 0xfffe8000L, 0x00000000L), HEXCONSTE(1.09002708570106178948e-4932, 0x0000, 0x297fb5aaL, 0x6c544e3aL), 0 },
	{ __LINE__,  HEXCONSTE(5.00000000000000000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.63837500000000000000e+04, 0x400c, 0xffff0000L, 0x00000000L), HEXCONSTE(9.99559244790478336855e-4933, 0x0000, 0x260dfc14L, 0x636e2a5cL), 0 },
	{ __LINE__,  HEXCONSTE(5.00000000000000000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.63838750000000000000e+04, 0x400c, 0xffff8000L, 0x00000000L), HEXCONSTE(9.16599868895476344664e-4933, 0x0000, 0x22e57078L, 0xfaa2f5baL), 0 },
#endif
	{ __LINE__,  HEXCONSTE(2.00000190734863281250e+00, 0x4000, 0x80000800L, 0x00000000L), HEXCONSTE(-1.26000000000000000000e+02, 0xc005, 0xfc000000L, 0x00000000L), HEXCONSTE(1.17535310849065169555e-38, 0x3f80, 0xfff8201fL, 0x40aca8a8L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00000381469726562500e+00, 0xc000, 0x80001000L, 0x00000000L), HEXCONSTE(-1.26000000000000000000e+02, 0xc005, 0xfc000000L, 0x00000000L), HEXCONSTE(1.17521188326476003093e-38, 0x3f80, 0xfff0407dL, 0x01654a80L), 0 },
	{ __LINE__,  HEXCONSTE(2.00000572204589843750e+00, 0x4000, 0x80001800L, 0x00000000L), HEXCONSTE(-1.26000000000000000000e+02, 0xc005, 0xfc000000L, 0x00000000L), HEXCONSTE(1.17507067514252454093e-38, 0x3f80, 0xffe86119L, 0x4035ed26L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(-2.00000762939453125000e+00, 0xc000, 0x80002000L, 0x00000000L), HEXCONSTE(-1.26000000000000000000e+02, 0xc005, 0xfc000000L, 0x00000000L), HEXCONSTE(1.17492948412185750939e-38, 0x3f80, 0xffe081f3L, 0xfb2aa7f9L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(2.00000953674316406250e+00, 0x4000, 0x80002800L, 0x00000000L), HEXCONSTE(-1.26000000000000000000e+02, 0xc005, 0xfc000000L, 0x00000000L), HEXCONSTE(1.17478831020067147688e-38, 0x3f80, 0xffd8a30dL, 0x304fa215L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00001144409179687500e+00, 0xc000, 0x80003000L, 0x00000000L), HEXCONSTE(-1.26000000000000000000e+02, 0xc005, 0xfc000000L, 0x00000000L), HEXCONSTE(1.17464715337687924064e-38, 0x3f80, 0xffd0c464L, 0xddb11252L), 0 },
	{ __LINE__,  HEXCONSTE(2.00001335144042968750e+00, 0x4000, 0x80003800L, 0x00000000L), HEXCONSTE(-1.26000000000000000000e+02, 0xc005, 0xfc000000L, 0x00000000L), HEXCONSTE(1.17450601364839385492e-38, 0x3f80, 0xffc8e5fbL, 0x015b3f49L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(2.00000190734863281250e+00, 0x4000, 0x80000800L, 0x00000000L), HEXCONSTE(-9.69000000000000000000e+02, 0xc008, 0xf2400000L, 0x00000000L), HEXCONSTE(2.00231714353756874151e-292, 0x3c35, 0xffc3772bL, 0x3bf7e275L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00000381469726562500e+00, 0xc000, 0x80001000L, 0x00000000L), HEXCONSTE(-9.69000000000000000000e+02, 0xc008, 0xf2400000L, 0x00000000L), HEXCONSTE(-2.00046763876656887574e-292, 0xbc35, 0xff86fcaaL, 0xac03e34aL), 0 },
	{ __LINE__,  HEXCONSTE(2.00000572204589843750e+00, 0x4000, 0x80001800L, 0x00000000L), HEXCONSTE(-9.69000000000000000000e+02, 0xc008, 0xf2400000L, 0x00000000L), HEXCONSTE(1.99861984411164414236e-292, 0x3c35, 0xff4a907aL, 0xeaf545c9L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(-2.00000762939453125000e+00, 0xc000, 0x80002000L, 0x00000000L), HEXCONSTE(-9.69000000000000000000e+02, 0xc008, 0xf2400000L, 0x00000000L), HEXCONSTE(-1.99677375798993344742e-292, 0xbc35, 0xff0e3298L, 0x946b7781L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(2.00000953674316406250e+00, 0x4000, 0x80002800L, 0x00000000L), HEXCONSTE(-9.69000000000000000000e+02, 0xc008, 0xf2400000L, 0x00000000L), HEXCONSTE(1.99492937882004227995e-292, 0x3c35, 0xfed1e300L, 0x44d3df54L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(-2.00001144409179687500e+00, 0xc000, 0x80003000L, 0x00000000L), HEXCONSTE(-9.69000000000000000000e+02, 0xc008, 0xf2400000L, 0x00000000L), HEXCONSTE(-1.99308670502204135197e-292, 0xbc35, 0xfe95a1aeL, 0x9969ac91L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(2.00001335144042968750e+00, 0x4000, 0x80003800L, 0x00000000L), HEXCONSTE(-9.69000000000000000000e+02, 0xc008, 0xf2400000L, 0x00000000L), HEXCONSTE(1.99124573501746523888e-292, 0x3c35, 0xfe596ea0L, 0x3035a612L), FLAG_INEXACT },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(2.00000190734863281250e+00, 0x4000, 0x80000800L, 0x00000000L), HEXCONSTE(-1.02200000000000000000e+03, 0xc008, 0xff800000L, 0x00000000L), HEXCONSTE(2.22290623635608018625e-308, 0x3c00, 0xffc027f9L, 0x56dfe4ccL), 0 },
	{ __LINE__,  HEXCONSTE(-2.00000381469726562500e+00, 0xc000, 0x80001000L, 0x00000000L), HEXCONSTE(-1.02200000000000000000e+03, 0xc008, 0xff800000L, 0x00000000L), HEXCONSTE(2.22074072792299609502e-308, 0x3c00, 0xff805fe2L, 0xb354443bL), 0 },
	{ __LINE__,  HEXCONSTE(2.00000572204589843750e+00, 0x4000, 0x80001800L, 0x00000000L), HEXCONSTE(-1.02200000000000000000e+03, 0xc008, 0xff800000L, 0x00000000L), HEXCONSTE(2.21857733114478185967e-308, 0x3c00, 0xff40a7b8L, 0x19db8e41L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00000762939453125000e+00, 0xc000, 0x80002000L, 0x00000000L), HEXCONSTE(-1.02200000000000000000e+03, 0xc008, 0xff800000L, 0x00000000L), HEXCONSTE(2.21641604396028602061e-308, 0x3c00, 0xff00ff75L, 0x8ff332e5L), 0 },
	{ __LINE__,  HEXCONSTE(2.00000953674316406250e+00, 0x4000, 0x80002800L, 0x00000000L), HEXCONSTE(-1.02200000000000000000e+03, 0xc008, 0xff800000L, 0x00000000L), HEXCONSTE(2.21425686431037093693e-308, 0x3c00, 0xfec16717L, 0x1c176269L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00001144409179687500e+00, 0xc000, 0x80003000L, 0x00000000L), HEXCONSTE(-1.02200000000000000000e+03, 0xc008, 0xff800000L, 0x00000000L), HEXCONSTE(2.21209979013791081705e-308, 0x3c00, 0xfe81de98L, 0xc5c2cd83L), 0 },
	{ __LINE__,  HEXCONSTE(2.00001335144042968750e+00, 0x4000, 0x80003800L, 0x00000000L), HEXCONSTE(-1.02200000000000000000e+03, 0xc008, 0xff800000L, 0x00000000L), HEXCONSTE(2.20994481938778975083e-308, 0x3c00, 0xfe4265f6L, 0x956e65a3L), 0 },
	{ __LINE__,  HEXCONSTE(2.00000190734863281250e+00, 0x4000, 0x80000800L, 0x00000000L), HEXCONSTE(-1.63820000000000000000e+04, 0xc00c, 0xfff80000L, 0x00000000L), HEXCONSTE(3.30998490318593574615e-4932, 0x0000, 0x7e040a80L, 0x3c133cc2L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00000381469726562500e+00, 0xc000, 0x80001000L, 0x00000000L), HEXCONSTE(-1.63820000000000000000e+04, 0xc00c, 0xfff80000L, 0x00000000L), HEXCONSTE(3.25867463197883697768e-4932, 0x0000, 0x7c0ff4ecL, 0x2227618cL), 0 },
	{ __LINE__,  HEXCONSTE(2.00000572204589843750e+00, 0x4000, 0x80001800L, 0x00000000L), HEXCONSTE(-1.63820000000000000000e+04, 0xc00c, 0xfff80000L, 0x00000000L), HEXCONSTE(3.20815980311461223662e-4932, 0x0000, 0x7a23a002L, 0xb22d44bcL), 0 },
	{ __LINE__,  HEXCONSTE(-2.00000762939453125000e+00, 0xc000, 0x80002000L, 0x00000000L), HEXCONSTE(-1.63820000000000000000e+04, 0xc00c, 0xfff80000L, 0x00000000L), HEXCONSTE(3.15842808443193287565e-4932, 0x0000, 0x783eecfeL, 0xf93700c0L), 0 },
	{ __LINE__,  HEXCONSTE(2.00000953674316406250e+00, 0x4000, 0x80002800L, 0x00000000L), HEXCONSTE(-1.63820000000000000000e+04, 0xc00c, 0xfff80000L, 0x00000000L), HEXCONSTE(3.10946733497294672390e-4932, 0x0000, 0x7661bd96L, 0x250fba1cL), 0 },
	{ __LINE__,  HEXCONSTE(-2.00001144409179687500e+00, 0xc000, 0x80003000L, 0x00000000L), HEXCONSTE(-1.63820000000000000000e+04, 0xc00c, 0xfff80000L, 0x00000000L), HEXCONSTE(3.06126560201859370891e-4932, 0x0000, 0x748bf3f5L, 0x9f7610f4L), 0 },
	{ __LINE__,  HEXCONSTE(2.00001335144042968750e+00, 0x4000, 0x80003800L, 0x00000000L), HEXCONSTE(-1.63820000000000000000e+04, 0xc00c, 0xfff80000L, 0x00000000L), HEXCONSTE(3.01381111816989283009e-4932, 0x0000, 0x72bd72c1L, 0x30daee6cL), 0 },
	{ __LINE__,  HEXCONSTE(2.00000190734863281250e+00, 0x4000, 0x80000800L, 0x00000000L), HEXCONSTE(-1.63830000000000000000e+04, 0xc00c, 0xfffc0000L, 0x00000000L), HEXCONSTE(1.65499087327067814818e-4932, 0x0000, 0x3f02014fL, 0xfdf49e82L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00000381469726562500e+00, 0xc000, 0x80001000L, 0x00000000L), HEXCONSTE(-1.63830000000000000000e+04, 0xc00c, 0xfffc0000L, 0x00000000L), HEXCONSTE(-1.62933420828104392922e-4932, 0x8000, 0x3e07f2b5L, 0x12bd0e6eL), 0 },
	{ __LINE__,  HEXCONSTE(2.00000572204589843750e+00, 0x4000, 0x80001800L, 0x00000000L), HEXCONSTE(-1.63830000000000000000e+04, 0xc00c, 0xfffc0000L, 0x00000000L), HEXCONSTE(1.60407531226102546401e-4932, 0x0000, 0x3d11c48eL, 0x043c0192L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00000762939453125000e+00, 0xc000, 0x80002000L, 0x00000000L), HEXCONSTE(-1.63830000000000000000e+04, 0xc00c, 0xfffc0000L, 0x00000000L), HEXCONSTE(-1.57920801801545826132e-4932, 0x8000, 0x3c1f6777L, 0xa2bd97b1L), 0 },
	{ __LINE__,  HEXCONSTE(2.00000953674316406250e+00, 0x4000, 0x80002800L, 0x00000000L), HEXCONSTE(-1.63830000000000000000e+04, 0xc00c, 0xfffc0000L, 0x00000000L), HEXCONSTE(1.55472625397398607488e-4932, 0x0000, 0x3b30cc4bL, 0xd2b02b38L), 0 },
	{ __LINE__,  HEXCONSTE(-2.00001144409179687500e+00, 0xc000, 0x80003000L, 0x00000000L), HEXCONSTE(-1.63830000000000000000e+04, 0xc00c, 0xfffc0000L, 0x00000000L), HEXCONSTE(-1.53062404270827122597e-4932, 0x8000, 0x3a45e420L, 0x9a2ecea9L), 0 },
	{ __LINE__,  HEXCONSTE(2.00001335144042968750e+00, 0x4000, 0x80003800L, 0x00000000L), HEXCONSTE(-1.63830000000000000000e+04, 0xc00c, 0xfffc0000L, 0x00000000L), HEXCONSTE(1.50689549947219893151e-4932, 0x0000, 0x395ea047L, 0x324e5134L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(4.99992847442626953125e-01, 0x3ffd, 0xffff1000L, 0x00000000L), HEXCONSTE(1.26000000000000000000e+02, 0x4005, 0xfc000000L, 0x00000000L), HEXCONSTE(1.17337748074663812902e-38, 0x3f80, 0xff89fb05L, 0x4bca3399L), 0 },
	{ __LINE__,  HEXCONSTE(-4.99993324279785156250e-01, 0xbffd, 0xffff2000L, 0x00000000L), HEXCONSTE(1.26000000000000000000e+02, 0x4005, 0xfc000000L, 0x00000000L), HEXCONSTE(1.17351848768407883598e-38, 0x3f80, 0xff91d789L, 0xf88ded26L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(4.99993801116943359375e-01, 0x3ffd, 0xffff3000L, 0x00000000L), HEXCONSTE(1.26000000000000000000e+02, 0x4005, 0xfc000000L, 0x00000000L), HEXCONSTE(1.17365951143208278985e-38, 0x3f80, 0xff99b44cL, 0x1143d750L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(-4.99994277954101562500e-01, 0xbffd, 0xffff4000L, 0x00000000L), HEXCONSTE(1.26000000000000000000e+02, 0x4005, 0xfc000000L, 0x00000000L), HEXCONSTE(1.17380055199263807726e-38, 0x3f80, 0xffa1914bL, 0x97c7ff72L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(4.99994754791259765625e-01, 0x3ffd, 0xffff5000L, 0x00000000L), HEXCONSTE(1.26000000000000000000e+02, 0x4005, 0xfc000000L, 0x00000000L), HEXCONSTE(1.17394160936773301798e-38, 0x3f80, 0xffa96e88L, 0x8df68132L), 0 },
	{ __LINE__,  HEXCONSTE(-4.99995231628417968750e-01, 0xbffd, 0xffff6000L, 0x00000000L), HEXCONSTE(1.26000000000000000000e+02, 0x4005, 0xfc000000L, 0x00000000L), HEXCONSTE(1.17408268355935616518e-38, 0x3f80, 0xffb14c02L, 0xf5ab8684L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(4.99995708465576171875e-01, 0x3ffd, 0xffff7000L, 0x00000000L), HEXCONSTE(1.26000000000000000000e+02, 0x4005, 0xfc000000L, 0x00000000L), HEXCONSTE(1.17422377456949630528e-38, 0x3f80, 0xffb929baL, 0xd0c347a9L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(4.99992847442626953125e-01, 0x3ffd, 0xffff1000L, 0x00000000L), HEXCONSTE(9.69000000000000000000e+02, 0x4008, 0xf2400000L, 0x00000000L), HEXCONSTE(1.97657873066936000348e-292, 0x3c35, 0xfc79d2c5L, 0x6315dbb2L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(-4.99993324279785156250e-01, 0xbffd, 0xffff2000L, 0x00000000L), HEXCONSTE(9.69000000000000000000e+02, 0x4008, 0xf2400000L, 0x00000000L), HEXCONSTE(-1.97840617717724951142e-292, 0xbc35, 0xfcb5949eL, 0xb638d153L), 0 },
	{ __LINE__,  HEXCONSTE(4.99993801116943359375e-01, 0x3ffd, 0xffff3000L, 0x00000000L), HEXCONSTE(9.69000000000000000000e+02, 0x4008, 0xf2400000L, 0x00000000L), HEXCONSTE(1.98023531150617315725e-292, 0x3c35, 0xfcf16499L, 0x10eb1ddfL), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(-4.99994277954101562500e-01, 0xbffd, 0xffff4000L, 0x00000000L), HEXCONSTE(9.69000000000000000000e+02, 0x4008, 0xf2400000L, 0x00000000L), HEXCONSTE(-1.98206613521338265959e-292, 0xbc35, 0xfd2d42b7L, 0xc9809fd0L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(4.99994754791259765625e-01, 0x3ffd, 0xffff5000L, 0x00000000L), HEXCONSTE(9.69000000000000000000e+02, 0x4008, 0xf2400000L, 0x00000000L), HEXCONSTE(1.98389864985756503325e-292, 0x3c35, 0xfd692efeL, 0x3716ca11L), 0 },
	{ __LINE__,  HEXCONSTE(-4.99995231628417968750e-01, 0xbffd, 0xffff6000L, 0x00000000L), HEXCONSTE(9.69000000000000000000e+02, 0x4008, 0xf2400000L, 0x00000000L), HEXCONSTE(-1.98573285699884391032e-292, 0xbc35, 0xfda5296fL, 0xb194d37eL), 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	{ __LINE__,  HEXCONSTE(4.99995708465576171875e-01, 0x3ffd, 0xffff7000L, 0x00000000L), HEXCONSTE(9.69000000000000000000e+02, 0x4008, 0xf2400000L, 0x00000000L), HEXCONSTE(1.98756875819878086331e-292, 0x3c35, 0xfde1320fL, 0x91abe676L), 0 },
	{ __LINE__,  HEXCONSTE(4.99992847442626953125e-01, 0x3ffd, 0xffff1000L, 0x00000000L), HEXCONSTE(1.02200000000000000000e+03, 0x4008, 0xff800000L, 0x00000000L), HEXCONSTE(2.19278007204446471136e-308, 0x3c00, 0xfc48d68aL, 0x75dd1bc7L), 0 },
	{ __LINE__,  HEXCONSTE(-4.99993324279785156250e-01, 0xbffd, 0xffff2000L, 0x00000000L), HEXCONSTE(1.02200000000000000000e+03, 0x4008, 0xff800000L, 0x00000000L), HEXCONSTE(2.19491834787767397184e-308, 0x3c00, 0xfc87d14bL, 0x25ac6f34L), 0 },
	{ __LINE__,  HEXCONSTE(4.99993801116943359375e-01, 0x3ffd, 0xffff3000L, 0x00000000L), HEXCONSTE(1.02200000000000000000e+03, 0x4008, 0xff800000L, 0x00000000L), HEXCONSTE(2.19705870679501885051e-308, 0x3c00, 0xfcc6dbc0L, 0xb9708f15L), 0 },
	{ __LINE__,  HEXCONSTE(-4.99994277954101562500e-01, 0xbffd, 0xffff4000L, 0x00000000L), HEXCONSTE(1.02200000000000000000e+03, 0x4008, 0xff800000L, 0x00000000L), HEXCONSTE(2.19920115082382684342e-308, 0x3c00, 0xfd05f5efL, 0x1af543f5L), 0 },
	{ __LINE__,  HEXCONSTE(4.99994754791259765625e-01, 0x3ffd, 0xffff5000L, 0x00000000L), HEXCONSTE(1.02200000000000000000e+03, 0x4008, 0xff800000L, 0x00000000L), HEXCONSTE(2.20134568199339657351e-308, 0x3c00, 0xfd451fdaL, 0x34ffb00eL), 0 },
	{ __LINE__,  HEXCONSTE(-4.99995231628417968750e-01, 0xbffd, 0xffff6000L, 0x00000000L), HEXCONSTE(1.02200000000000000000e+03, 0x4008, 0xff800000L, 0x00000000L), HEXCONSTE(2.20349230233499970498e-308, 0x3c00, 0xfd845985L, 0xf34e8d48L), 0 },
	{ __LINE__,  HEXCONSTE(4.99995708465576171875e-01, 0x3ffd, 0xffff7000L, 0x00000000L), HEXCONSTE(1.02200000000000000000e+03, 0x4008, 0xff800000L, 0x00000000L), HEXCONSTE(2.20564101388188286058e-308, 0x3c00, 0xfdc3a2f6L, 0x429a6b50L), 0 },
	{ __LINE__,  HEXCONSTE(4.99992847442626953125e-01, 0x3ffd, 0xffff1000L, 0x00000000L), HEXCONSTE(1.63820000000000000000e+04, 0x400c, 0xfff80000L, 0x00000000L), HEXCONSTE(2.65971413147155051021e-4932, 0x0000, 0x654251daL, 0x326ef752L), 0 },
	{ __LINE__,  HEXCONSTE(-4.99993324279785156250e-01, 0xbffd, 0xffff2000L, 0x00000000L), HEXCONSTE(1.63820000000000000000e+04, 0x400c, 0xfff80000L, 0x00000000L), HEXCONSTE(2.70159396531411688133e-4932, 0x0000, 0x66da7e09L, 0xfb94e936L), 0 },
	{ __LINE__,  HEXCONSTE(4.99993801116943359375e-01, 0x3ffd, 0xffff3000L, 0x00000000L), HEXCONSTE(1.63820000000000000000e+04, 0x400c, 0xfff80000L, 0x00000000L), HEXCONSTE(2.74413319774186890145e-4932, 0x0000, 0x68791774L, 0xe63198c4L), 0 },
	{ __LINE__,  HEXCONSTE(-4.99994277954101562500e-01, 0xbffd, 0xffff4000L, 0x00000000L), HEXCONSTE(1.63820000000000000000e+04, 0x400c, 0xfff80000L, 0x00000000L), HEXCONSTE(2.78734221035123519122e-4932, 0x0000, 0x6a1e3802L, 0x01b2c62cL), 0 },
	{ __LINE__,  HEXCONSTE(4.99994754791259765625e-01, 0x3ffd, 0xffff5000L, 0x00000000L), HEXCONSTE(1.63820000000000000000e+04, 0x400c, 0xfff80000L, 0x00000000L), HEXCONSTE(2.83123154817675836303e-4932, 0x0000, 0x6bc9fa00L, 0xc22e6452L), 0 },
	{ __LINE__,  HEXCONSTE(-4.99995231628417968750e-01, 0xbffd, 0xffff6000L, 0x00000000L), HEXCONSTE(1.63820000000000000000e+04, 0x400c, 0xfff80000L, 0x00000000L), HEXCONSTE(2.87581192226395178357e-4932, 0x0000, 0x6d7c782aL, 0xa516444cL), 0 },
	{ __LINE__,  HEXCONSTE(4.99995708465576171875e-01, 0x3ffd, 0xffff7000L, 0x00000000L), HEXCONSTE(1.63820000000000000000e+04, 0x400c, 0xfff80000L, 0x00000000L), HEXCONSTE(2.92109421228265595610e-4932, 0x0000, 0x6f35cda4L, 0xdc8b10d2L), 0 },
	{ __LINE__,  HEXCONSTE(4.99992847442626953125e-01, 0x3ffd, 0xffff1000L, 0x00000000L), HEXCONSTE(1.63830000000000000000e+04, 0x400c, 0xfffc0000L, 0x00000000L), HEXCONSTE(1.32983804197785400131e-4932, 0x0000, 0x32a0f976L, 0x02d93405L), 0 },
	{ __LINE__,  HEXCONSTE(-4.99993324279785156250e-01, 0xbffd, 0xffff2000L, 0x00000000L), HEXCONSTE(1.63830000000000000000e+04, 0x400c, 0xfffc0000L, 0x00000000L), HEXCONSTE(-1.35077894757161189338e-4932, 0x8000, 0x336d1205L, 0x66a6168aL), 0 },
	{ __LINE__,  HEXCONSTE(4.99993801116943359375e-01, 0x3ffd, 0xffff3000L, 0x00000000L), HEXCONSTE(1.63830000000000000000e+04, 0x400c, 0xfffc0000L, 0x00000000L), HEXCONSTE(1.37204958831014980365e-4932, 0x0000, 0x343c6149L, 0x41914edeL), 0 },
	{ __LINE__,  HEXCONSTE(-4.99994277954101562500e-01, 0xbffd, 0xffff4000L, 0x00000000L), HEXCONSTE(1.63830000000000000000e+04, 0x400c, 0xfffc0000L, 0x00000000L), HEXCONSTE(-1.39365515587555531326e-4932, 0x8000, 0x350ef435L, 0xabd8a272L), 0 },
	{ __LINE__,  HEXCONSTE(4.99994754791259765625e-01, 0x3ffd, 0xffff5000L, 0x00000000L), HEXCONSTE(1.63830000000000000000e+04, 0x400c, 0xfffc0000L, 0x00000000L), HEXCONSTE(1.41560092368791705746e-4932, 0x0000, 0x35e4d7f2L, 0xf326ef69L), 0 },
	{ __LINE__,  HEXCONSTE(-4.99995231628417968750e-01, 0xbffd, 0xffff6000L, 0x00000000L), HEXCONSTE(1.63830000000000000000e+04, 0x400c, 0xfffc0000L, 0x00000000L), HEXCONSTE(-1.43789224819213050168e-4932, 0x8000, 0x36be19deL, 0x6cfdce8fL), 0 },
	{ __LINE__,  HEXCONSTE(4.99995708465576171875e-01, 0x3ffd, 0xffff7000L, 0x00000000L), HEXCONSTE(1.63830000000000000000e+04, 0x400c, 0xfffc0000L, 0x00000000L), HEXCONSTE(1.46053457016496072197e-4932, 0x0000, 0x379ac78bL, 0x4c6f2a62L), 0 },
#endif
#if defined(TEST_LDOUBLE) && LDBL_MAX_EXP > 1024
	{ __LINE__,  HEXCONSTE(2.00017070770263671875e+00, 0x4000, 0x8002cc00L, 0x00000000L), HEXCONSTE(-1.02200000000000000000e+03, 0xc008, 0xff800000L, 0x00000000L), HEXCONSTE(2.03920942589966866653e-308, 0x3c00, 0xea9da8e3L, 0x3d761ff3L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(2.00008416175842285156e+00, 0x4000, 0x80016100L, 0x00000000L), HEXCONSTE(-1.02200000000000000000e+03, 0xc008, 0xff800000L, 0x00000000L), HEXCONSTE(2.13141132926681923956e-308, 0x3c00, 0xf53951d5L, 0x0228fdbaL), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(2.00008392333984375000e+00, 0x4000, 0x80016000L, 0x00000000L), HEXCONSTE(-1.02200000000000000000e+03, 0xc008, 0xff800000L, 0x00000000L), HEXCONSTE(2.13167100805201266221e-308, 0x3c00, 0xf540f7d4L, 0x23ee0657L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(2.00008404254913330078e+00, 0x4000, 0x80016080L, 0x00000000L), HEXCONSTE(-1.02200000000000000000e+03, 0xc008, 0xff800000L, 0x00000000L), HEXCONSTE(2.13154116470106799502e-308, 0x3c00, 0xf53d24ccL, 0xef0aeabbL), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.02231713867187500000e+03, 0xc008, 0xff944c00L, 0x00000000L), HEXCONSTE(1.78597830235888235660e-308, 0x3c00, 0xcd7b241bL, 0xc8bef000L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.02230664062500000000e+03, 0xc008, 0xff93a000L, 0x00000000L), HEXCONSTE(1.79902171454620233154e-308, 0x3c00, 0xcefb505eL, 0x7e0af001L), FLAG_INEXACT },
#endif
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+01, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000001e-01, 0x3ffb, 0xccccccccL, 0xcccccccdL), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+01, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999999999999999980e-03, 0x3ff8, 0xa3d70a3dL, 0x70a3d70aL), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+01, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(-3.00000000000000000000e+00, 0xc000, 0xc0000000L, 0x00000000L), HEXCONSTE(9.99999999999999999958e-04, 0x3ff5, 0x83126e97L, 0x8d4fdf3bL), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+01, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(-4.00000000000000000000e+00, 0xc001, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000001e-04, 0x3ff1, 0xd1b71758L, 0xe219652cL), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+01, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(-5.00000000000000000000e+00, 0xc001, 0xa0000000L, 0x00000000L), HEXCONSTE(9.99999999999999999995e-06, 0x3fee, 0xa7c5ac47L, 0x1b478423L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+01, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(-6.00000000000000000000e+00, 0xc001, 0xc0000000L, 0x00000000L), HEXCONSTE(1.00000000000000000004e-06, 0x3feb, 0x8637bd05L, 0xaf6c69b6L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+01, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(-7.00000000000000000000e+00, 0xc001, 0xe0000000L, 0x00000000L), HEXCONSTE(9.99999999999999999985e-08, 0x3fe7, 0xd6bf94d5L, 0xe57a42bcL), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), 0 },
#if defined(TEST_LDOUBLE) && LDBL_MAX_EXP > 1024
	{ __LINE__,  HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), 0 },
#endif
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999880790714001932e-01, 0x3ffe, 0xfffffe00L, 0x00010000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999999999999777955e-01, 0x3ffe, 0xffffffffL, 0xfffff000L), 0 },
#if defined(TEST_LDOUBLE) && LDBL_MAX_EXP > 1024
	{ __LINE__,  HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999999999999999892e-01, 0x3ffe, 0xffffffffL, 0xfffffffeL), 0 },
#endif
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(3.00000000000000000000e+00, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(3.00000000000000000000e+00, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(9.99999821186076331969e-01, 0x3ffe, 0xfffffd00L, 0x00030000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(3.00000000000000000000e+00, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(9.99999999999999666933e-01, 0x3ffe, 0xffffffffL, 0xffffe800L), 0 },
#if defined(TEST_LDOUBLE) && LDBL_MAX_EXP > 1024
	{ __LINE__,  HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(3.00000000000000000000e+00, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(9.99999999999999999837e-01, 0x3ffe, 0xffffffffL, 0xfffffffdL), 0 },
#endif
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(4.00000000000000000000e+00, 0x4001, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(4.00000000000000000000e+00, 0x4001, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999761581442214720e-01, 0x3ffe, 0xfffffc00L, 0x00060000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(4.00000000000000000000e+00, 0x4001, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999999999999555911e-01, 0x3ffe, 0xffffffffL, 0xffffe000L), 0 },
#if defined(TEST_LDOUBLE) && LDBL_MAX_EXP > 1024
	{ __LINE__,  HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(4.00000000000000000000e+00, 0x4001, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999999999999999783e-01, 0x3ffe, 0xffffffffL, 0xfffffffcL), 0 },
#endif
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(5.00000000000000000000e+00, 0x4001, 0xa0000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(5.00000000000000000000e+00, 0x4001, 0xa0000000L, 0x00000000L), HEXCONSTE(9.99999701976811650184e-01, 0x3ffe, 0xfffffb00L, 0x000a0000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(5.00000000000000000000e+00, 0x4001, 0xa0000000L, 0x00000000L), HEXCONSTE(9.99999999999999444888e-01, 0x3ffe, 0xffffffffL, 0xffffd800L), 0 },
#if defined(TEST_LDOUBLE) && LDBL_MAX_EXP > 1024
	{ __LINE__,  HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(5.00000000000000000000e+00, 0x4001, 0xa0000000L, 0x00000000L), HEXCONSTE(9.99999999999999999729e-01, 0x3ffe, 0xffffffffL, 0xfffffffbL), FLAG_INEXACT },
#endif
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(6.00000000000000000000e+00, 0x4001, 0xc0000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(6.00000000000000000000e+00, 0x4001, 0xc0000000L, 0x00000000L), HEXCONSTE(9.99999642372184638361e-01, 0x3ffe, 0xfffffa00L, 0x000f0000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(6.00000000000000000000e+00, 0x4001, 0xc0000000L, 0x00000000L), HEXCONSTE(9.99999999999999333866e-01, 0x3ffe, 0xffffffffL, 0xffffd000L), 0 },
#if defined(TEST_LDOUBLE) && LDBL_MAX_EXP > 1024
	{ __LINE__,  HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(6.00000000000000000000e+00, 0x4001, 0xc0000000L, 0x00000000L), HEXCONSTE(9.99999999999999999675e-01, 0x3ffe, 0xffffffffL, 0xfffffffaL), FLAG_INEXACT },
#endif
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(7.00000000000000000000e+00, 0x4001, 0xe0000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(7.00000000000000000000e+00, 0x4001, 0xe0000000L, 0x00000000L), HEXCONSTE(9.99999582767561179253e-01, 0x3ffe, 0xfffff900L, 0x00150000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(7.00000000000000000000e+00, 0x4001, 0xe0000000L, 0x00000000L), HEXCONSTE(9.99999999999999222844e-01, 0x3ffe, 0xffffffffL, 0xffffc800L), 0 },
#if defined(TEST_LDOUBLE) && LDBL_MAX_EXP > 1024
	{ __LINE__,  HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(7.00000000000000000000e+00, 0x4001, 0xe0000000L, 0x00000000L), HEXCONSTE(9.99999999999999999621e-01, 0x3ffe, 0xffffffffL, 0xfffffff9L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000005960464832810e+00, 0x3fff, 0x80000080L, 0x00008000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000011102e+00, 0x3fff, 0x80000000L, 0x00000400L), FLAG_INEXACT },
#if defined(TEST_LDOUBLE) && LDBL_MAX_EXP > 1024
	{ __LINE__,  HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000011e+00, 0x3fff, 0x80000000L, 0x00000001L), FLAG_INEXACT },
#endif
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000011920930020892e+00, 0x3fff, 0x80000100L, 0x00018000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), 0 },
#if defined(TEST_LDOUBLE) && LDBL_MAX_EXP > 1024
	{ __LINE__,  HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000011e+00, 0x3fff, 0x80000000L, 0x00000001L), FLAG_INEXACT },
#endif
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-3.00000000000000000000e+00, 0xc000, 0xc0000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-3.00000000000000000000e+00, 0xc000, 0xc0000000L, 0x00000000L), HEXCONSTE(1.00000017881395564245e+00, 0x3fff, 0x80000180L, 0x00030000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-3.00000000000000000000e+00, 0xc000, 0xc0000000L, 0x00000000L), HEXCONSTE(1.00000000000000033307e+00, 0x3fff, 0x80000000L, 0x00000c00L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-3.00000000000000000000e+00, 0xc000, 0xc0000000L, 0x00000000L), HEXCONSTE(1.00000000000000000022e+00, 0x3fff, 0x80000000L, 0x00000002L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-4.00000000000000000000e+00, 0xc001, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-4.00000000000000000000e+00, 0xc001, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000023841861462870e+00, 0x3fff, 0x80000200L, 0x00050000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-4.00000000000000000000e+00, 0xc001, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000044409e+00, 0x3fff, 0x80000000L, 0x00001000L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-4.00000000000000000000e+00, 0xc001, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000022e+00, 0x3fff, 0x80000000L, 0x00000002L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-5.00000000000000000000e+00, 0xc001, 0xa0000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-5.00000000000000000000e+00, 0xc001, 0xa0000000L, 0x00000000L), HEXCONSTE(1.00000029802327716766e+00, 0x3fff, 0x80000280L, 0x00078000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-5.00000000000000000000e+00, 0xc001, 0xa0000000L, 0x00000000L), HEXCONSTE(1.00000000000000055511e+00, 0x3fff, 0x80000000L, 0x00001400L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-5.00000000000000000000e+00, 0xc001, 0xa0000000L, 0x00000000L), HEXCONSTE(1.00000000000000000033e+00, 0x3fff, 0x80000000L, 0x00000003L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-6.00000000000000000000e+00, 0xc001, 0xc0000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-6.00000000000000000000e+00, 0xc001, 0xc0000000L, 0x00000000L), HEXCONSTE(1.00000035762794325933e+00, 0x3fff, 0x80000300L, 0x000a8000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-6.00000000000000000000e+00, 0xc001, 0xc0000000L, 0x00000000L), HEXCONSTE(1.00000000000000066613e+00, 0x3fff, 0x80000000L, 0x00001800L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-6.00000000000000000000e+00, 0xc001, 0xc0000000L, 0x00000000L), HEXCONSTE(1.00000000000000000033e+00, 0x3fff, 0x80000000L, 0x00000003L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-7.00000000000000000000e+00, 0xc001, 0xe0000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-7.00000000000000000000e+00, 0xc001, 0xe0000000L, 0x00000000L), HEXCONSTE(1.00000041723261290372e+00, 0x3fff, 0x80000380L, 0x000e0000L), 0 },
	{ __LINE__,  HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-7.00000000000000000000e+00, 0xc001, 0xe0000000L, 0x00000000L), HEXCONSTE(1.00000000000000077716e+00, 0x3fff, 0x80000000L, 0x00001c00L), FLAG_INEXACT },
#if defined(TEST_LDOUBLE) && LDBL_MAX_EXP > 1024
	{ __LINE__,  HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-7.00000000000000000000e+00, 0xc001, 0xe0000000L, 0x00000000L), HEXCONSTE(1.00000000000000000043e+00, 0x3fff, 0x80000000L, 0x00000004L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000011e+00, 0x3fff, 0x80000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000011e+00, 0x3fff, 0x80000000L, 0x00000001L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000023841859331242e+00, 0x3fff, 0x80000200L, 0x00020000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000044409e+00, 0x3fff, 0x80000000L, 0x00001000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000011e+00, 0x3fff, 0x80000000L, 0x00000001L), HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000022e+00, 0x3fff, 0x80000000L, 0x00000002L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(3.00000000000000000000e+00, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(1.00000035762791128491e+00, 0x3fff, 0x80000300L, 0x00060000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(3.00000000000000000000e+00, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(3.00000000000000000000e+00, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(1.00000000000000066613e+00, 0x3fff, 0x80000000L, 0x00001800L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000011e+00, 0x3fff, 0x80000000L, 0x00000001L), HEXCONSTE(3.00000000000000000000e+00, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(1.00000000000000000033e+00, 0x3fff, 0x80000000L, 0x00000003L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(4.00000000000000000000e+00, 0x4001, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000047683724346825e+00, 0x3fff, 0x80000400L, 0x000c0000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(4.00000000000000000000e+00, 0x4001, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(4.00000000000000000000e+00, 0x4001, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000088818e+00, 0x3fff, 0x80000000L, 0x00002000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000011e+00, 0x3fff, 0x80000000L, 0x00000001L), HEXCONSTE(4.00000000000000000000e+00, 0x4001, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000043e+00, 0x3fff, 0x80000000L, 0x00000004L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(5.00000000000000000000e+00, 0x4001, 0xa0000000L, 0x00000000L), HEXCONSTE(1.00000059604658986245e+00, 0x3fff, 0x80000500L, 0x00140000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(5.00000000000000000000e+00, 0x4001, 0xa0000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(5.00000000000000000000e+00, 0x4001, 0xa0000000L, 0x00000000L), HEXCONSTE(1.00000000000000111022e+00, 0x3fff, 0x80000000L, 0x00002800L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000011e+00, 0x3fff, 0x80000000L, 0x00000001L), HEXCONSTE(5.00000000000000000000e+00, 0x4001, 0xa0000000L, 0x00000000L), HEXCONSTE(1.00000000000000000054e+00, 0x3fff, 0x80000000L, 0x00000005L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(6.00000000000000000000e+00, 0x4001, 0xc0000000L, 0x00000000L), HEXCONSTE(1.00000071525595046751e+00, 0x3fff, 0x80000600L, 0x001e0000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(6.00000000000000000000e+00, 0x4001, 0xc0000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(6.00000000000000000000e+00, 0x4001, 0xc0000000L, 0x00000000L), HEXCONSTE(1.00000000000000133227e+00, 0x3fff, 0x80000000L, 0x00003000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000011e+00, 0x3fff, 0x80000000L, 0x00000001L), HEXCONSTE(6.00000000000000000000e+00, 0x4001, 0xc0000000L, 0x00000000L), HEXCONSTE(1.00000000000000000065e+00, 0x3fff, 0x80000000L, 0x00000006L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(7.00000000000000000000e+00, 0x4001, 0xe0000000L, 0x00000000L), HEXCONSTE(1.00000083446532528353e+00, 0x3fff, 0x80000700L, 0x002a0001L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(7.00000000000000000000e+00, 0x4001, 0xe0000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(7.00000000000000000000e+00, 0x4001, 0xe0000000L, 0x00000000L), HEXCONSTE(1.00000000000000155431e+00, 0x3fff, 0x80000000L, 0x00003800L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000011e+00, 0x3fff, 0x80000000L, 0x00000001L), HEXCONSTE(7.00000000000000000000e+00, 0x4001, 0xe0000000L, 0x00000000L), HEXCONSTE(1.00000000000000000076e+00, 0x3fff, 0x80000000L, 0x00000007L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999880790724660073e-01, 0x3ffe, 0xfffffe00L, 0x00040000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999999999999777955e-01, 0x3ffe, 0xffffffffL, 0xfffff000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000011e+00, 0x3fff, 0x80000000L, 0x00000001L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999999999999999892e-01, 0x3ffe, 0xffffffffL, 0xfffffffeL), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999761581463531002e-01, 0x3ffe, 0xfffffc00L, 0x000c0000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999999999999555911e-01, 0x3ffe, 0xffffffffL, 0xffffe000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000011e+00, 0x3fff, 0x80000000L, 0x00000001L), HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999999999999999783e-01, 0x3ffe, 0xffffffffL, 0xfffffffcL), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(-3.00000000000000000000e+00, 0xc000, 0xc0000000L, 0x00000000L), HEXCONSTE(9.99999642372216612785e-01, 0x3ffe, 0xfffffa00L, 0x00180000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-3.00000000000000000000e+00, 0xc000, 0xc0000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(-3.00000000000000000000e+00, 0xc000, 0xc0000000L, 0x00000000L), HEXCONSTE(9.99999999999999333866e-01, 0x3ffe, 0xffffffffL, 0xffffd000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000011e+00, 0x3fff, 0x80000000L, 0x00000001L), HEXCONSTE(-3.00000000000000000000e+00, 0xc000, 0xc0000000L, 0x00000000L), HEXCONSTE(9.99999999999999999675e-01, 0x3ffe, 0xffffffffL, 0xfffffffaL), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(-4.00000000000000000000e+00, 0xc001, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999523162983905368e-01, 0x3ffe, 0xfffff800L, 0x0027ffffL), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-4.00000000000000000000e+00, 0xc001, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(-4.00000000000000000000e+00, 0xc001, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999999999999111822e-01, 0x3ffe, 0xffffffffL, 0xffffc000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000011e+00, 0x3fff, 0x80000000L, 0x00000001L), HEXCONSTE(-4.00000000000000000000e+00, 0xc001, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999999999999999566e-01, 0x3ffe, 0xffffffffL, 0xfffffff8L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(-5.00000000000000000000e+00, 0xc001, 0xa0000000L, 0x00000000L), HEXCONSTE(9.99999403953765408860e-01, 0x3ffe, 0xfffff600L, 0x003bffffL), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-5.00000000000000000000e+00, 0xc001, 0xa0000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(-5.00000000000000000000e+00, 0xc001, 0xa0000000L, 0x00000000L), HEXCONSTE(9.99999999999998889777e-01, 0x3ffe, 0xffffffffL, 0xffffb000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000011e+00, 0x3fff, 0x80000000L, 0x00000001L), HEXCONSTE(-5.00000000000000000000e+00, 0xc001, 0xa0000000L, 0x00000000L), HEXCONSTE(9.99999999999999999458e-01, 0x3ffe, 0xffffffffL, 0xfffffff6L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(-6.00000000000000000000e+00, 0xc001, 0xc0000000L, 0x00000000L), HEXCONSTE(9.99999284744561123153e-01, 0x3ffe, 0xfffff400L, 0x0053fffeL), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-6.00000000000000000000e+00, 0xc001, 0xc0000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(-6.00000000000000000000e+00, 0xc001, 0xc0000000L, 0x00000000L), HEXCONSTE(9.99999999999998667732e-01, 0x3ffe, 0xffffffffL, 0xffffa000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000011e+00, 0x3fff, 0x80000000L, 0x00000001L), HEXCONSTE(-6.00000000000000000000e+00, 0xc001, 0xc0000000L, 0x00000000L), HEXCONSTE(9.99999999999999999349e-01, 0x3ffe, 0xffffffffL, 0xfffffff4L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(-7.00000000000000000000e+00, 0xc001, 0xe0000000L, 0x00000000L), HEXCONSTE(9.99999165535371048301e-01, 0x3ffe, 0xfffff200L, 0x006ffffdL), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-7.00000000000000000000e+00, 0xc001, 0xe0000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(-7.00000000000000000000e+00, 0xc001, 0xe0000000L, 0x00000000L), HEXCONSTE(9.99999999999998445688e-01, 0x3ffe, 0xffffffffL, 0xffff9000L), 0 },
	{ __LINE__,  HEXCONSTE(1.00000000000000000011e+00, 0x3fff, 0x80000000L, 0x00000001L), HEXCONSTE(-7.00000000000000000000e+00, 0xc001, 0xe0000000L, 0x00000000L), HEXCONSTE(9.99999999999999999241e-01, 0x3ffe, 0xffffffffL, 0xfffffff2L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(1.06250000000000000000e+00, 0x3fff, 0x88000000L, 0x00000000L), HEXCONSTE(1.12500000000000000000e+00, 0x3fff, 0x90000000L, 0x00000000L), HEXCONSTE(1.07058229302876136216e+00, 0x3fff, 0x8908d730L, 0x1e1ba6a0L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(1.50000000000000000000e+00, 0x3fff, 0xc0000000L, 0x00000000L), HEXCONSTE(1.03125000000000000000e+00, 0x3fff, 0x84000000L, 0x00000000L), HEXCONSTE(1.51912709871474318406e+00, 0x3fff, 0xc272c1bbL, 0xb93d60c6L), 0 },
	{ __LINE__,  HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.50000000000000000000e+00, 0x3fff, 0xc0000000L, 0x00000000L), HEXCONSTE(6.27710117417006039155e+57, 0x40be, 0xfffffe80L, 0x00006000L), 0 },
	{ __LINE__,  HEXCONSTE(1.49357829132402765485e+205, 0x42a8, 0xbe8d0537L, 0x90000000L), HEXCONSTE(1.50000000000000000000e+00, 0x3fff, 0xc0000000L, 0x00000000L), HEXCONSTE(5.77220822056602682675e+307, 0x43fd, 0xa465dfdcL, 0x82053400L), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(1.80653297901153564453e+00, 0x3fff, 0xe73c7900L, 0x00000000L), HEXCONSTE(-3.99451828002929687500e+01, 0xc004, 0x9fc7de00L, 0x00000000L), HEXCONSTE(5.49849462130295096918e-11, 0x3fdc, 0xf1d38bbaL, 0xcb34009aL), 0 },
	{ __LINE__,  HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-5.70981264114379882812e+00, 0xc001, 0xb6b6c900L, 0x00000000L), HEXCONSTE(9.78174187501496214280e-221, 0x3d24, 0x8d6f08ffL, 0x7f0c2c0eL), FLAG_INEXACT },
	{ __LINE__,  HEXCONSTE(1.26192164421081542969e+00, 0x3fff, 0xa186a600L, 0x00000000L), HEXCONSTE(8.08921203613281250000e+01, 0x4005, 0xa1c8c400L, 0x00000000L), HEXCONSTE(1.48841555176933137220e+08, 0x401a, 0x8df24532L, 0xd4b7d75fL), FLAG_INEXACT },
#if defined(TEST_LDOUBLE) && LDBL_MAX_EXP > 1024
	{ __LINE__,  HEXCONSTE(5.96560120582580566406e-01, 0x3ffe, 0x98b82a00L, 0x00000000L), HEXCONSTE(-6.55302978515625000000e+03, 0xc00b, 0xccc83d00L, 0x00000000L), HEXCONSTE(1.39505874306152339711e+1470, 0x5312, 0xd20e27f1L, 0x91eac857L), 0 },
#endif
	{ __LINE__,  HEXCONSTE(8.40579330921173095703e-01, 0x3ffe, 0xd7303500L, 0x00000000L), HEXCONSTE(-3.27732421875000000000e+02, 0xc007, 0xa3ddc000L, 0x00000000L), HEXCONSTE(5.22399857785103091761e+24, 0x4051, 0x8a4730f8L, 0xb21a6325L), 0 },
	{ __LINE__,  HEXCONSTE(1.02191865444183349609e+00, 0x3fff, 0x82ce3b00L, 0x00000000L), HEXCONSTE(4.09202319335937500000e+03, 0x400a, 0xffc05f00L, 0x00000000L), HEXCONSTE(3.40273710581749986659e+38, 0x407e, 0xfffe5535L, 0xa38f9be6L), 0 },
};

int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_ff_f(fpow_data, ARRAY_SIZE(fpow_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

```

`tests/remain.c`:

```c
#include "testconfig.h"
#define TEST_FUNC_FF_F __MATH_PRECNAME(remainder)
#include "testdriver.h"


#define MAX_2_P HEXCONSTE(+5.94865747678615882511e+4931, 0x7ffd, 0xffffffffL, 0xffffffffL) /* LDBL_MAX / 2 */
#define MAX_4_P HEXCONSTE(+2.97432873839307941255e+4931, 0x7ffc, 0xffffffffL, 0xffffffffL) /* LDBL_MAX / 4 */
#define MAX_8_P HEXCONSTE(+1.48716436919653970628e+4931, 0x7ffb, 0xffffffffL, 0xffffffffL) /* LDBL_MAX / 8 */
#define MAX_2_M HEXCONSTE(-5.94865747678615882511e+4931, 0xfffd, 0xffffffffL, 0xffffffffL) /* -LDBL_MAX / 2 */
#define MAX_4_M HEXCONSTE(-2.97432873839307941255e+4931, 0xfffc, 0xffffffffL, 0xffffffffL) /* -LDBL_MAX / 4 */
#define MAX_8_M HEXCONSTE(-1.48716436919653970628e+4931, 0xfffb, 0xffffffffL, 0xffffffffL) /* -LDBL_MAX / 8 */


static test_ff_f_data const remainder_data[] = {
	/* remainder (x, +0) == qNaN plus invalid exception.  */
	{ __LINE__, HEXCONSTE(3, 0x4000, 0xc0000000L, 0x00000000L), ZERO_P, QNAN_P, 0 },
	{ __LINE__, HEXCONSTE(-1.1, 0xbfff, 0x8cccccccL, 0xcccccccdL), ZERO_P, QNAN_P, 0 },
	{ __LINE__, ZERO_P, ZERO_P, QNAN_P, 0 },
	{ __LINE__, ZERO_M, ZERO_P, QNAN_P, 0 },
	{ __LINE__, SUBNORM_P, ZERO_P, QNAN_P, FLAG_SUBNORM },
	{ __LINE__, MIN_P, ZERO_P, QNAN_P, 0 },
	{ __LINE__, MAX_P, ZERO_P, QNAN_P, 0 },
	{ __LINE__, INF_P, ZERO_P, QNAN_P, 0 },
	{ __LINE__, INF_M, ZERO_P, QNAN_P, 0 },

	/* remainder (x, -0) == qNaN plus invalid exception.  */
	{ __LINE__, HEXCONSTE(3, 0x4000, 0xc0000000L, 0x00000000L), ZERO_M, QNAN_P, 0 },
	{ __LINE__, HEXCONSTE(-1.1, 0xbfff, 0x8cccccccL, 0xcccccccdL), ZERO_M, QNAN_P, 0 },
	{ __LINE__, ZERO_P, ZERO_M, QNAN_P, 0 },
	{ __LINE__, ZERO_M, ZERO_M, QNAN_P, 0 },
	{ __LINE__, SUBNORM_P, ZERO_M, QNAN_P, FLAG_SUBNORM },
	{ __LINE__, MIN_P, ZERO_M, QNAN_P, 0 },
	{ __LINE__, MAX_P, ZERO_M, QNAN_P, 0 },
	{ __LINE__, INF_P, ZERO_M, QNAN_P, 0 },
	{ __LINE__, INF_M, ZERO_M, QNAN_P, 0 },
	
	/* remainder (+inf, y) == qNaN plus invalid exception.  */
	{ __LINE__, INF_P, HEXCONSTE(3, 0x4000, 0xc0000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__, INF_P, HEXCONSTE(-1.1, 0xbfff, 0x8cccccccL, 0xcccccccdL), QNAN_P, 0 },
	{ __LINE__, INF_P, SUBNORM_P, QNAN_P, FLAG_SUBNORM },
	{ __LINE__, INF_P, MIN_P, QNAN_P, 0 },
	{ __LINE__, INF_P, MAX_P, QNAN_P, 0 },
	{ __LINE__, INF_P, INF_P, QNAN_P, 0 },
	{ __LINE__, INF_P, INF_M, QNAN_P, 0 },

	/* remainder (-inf, y) == qNaN plus invalid exception.  */
	{ __LINE__, INF_M, HEXCONSTE(3, 0x4000, 0xc0000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__, INF_M, HEXCONSTE(-1.1, 0xbfff, 0x8cccccccL, 0xcccccccdL), QNAN_P, 0 },
	{ __LINE__, INF_M, SUBNORM_P, QNAN_P, FLAG_SUBNORM },
	{ __LINE__, INF_M, MIN_P, QNAN_P, 0 },
	{ __LINE__, INF_M, MAX_P, QNAN_P, 0 },
	{ __LINE__, INF_M, INF_P, QNAN_P, 0 },
	{ __LINE__, INF_M, INF_M, QNAN_P, 0 },

	/* remainder (+0, y) == +0 for y != 0.  */
	{ __LINE__, ZERO_P, HEXCONSTE(3, 0x4000, 0xc0000000L, 0x00000000L), ZERO_P, 0 },
	{ __LINE__, ZERO_P, SUBNORM_P, ZERO_P, FLAG_SUBNORM },
	{ __LINE__, ZERO_P, SUBNORM_M, ZERO_P, FLAG_SUBNORM },
	{ __LINE__, ZERO_P, MIN_P, ZERO_P, FLAG_MINVAL },
	{ __LINE__, ZERO_P, MIN_M, ZERO_P, FLAG_MINVAL },
	{ __LINE__, ZERO_P, MAX_P, ZERO_P, 0 },
	{ __LINE__, ZERO_P, MAX_M, ZERO_P, 0 },
	
	/* remainder (-0, y) == -0 for y != 0.  */
	{ __LINE__, ZERO_M, HEXCONSTE(3, 0x4000, 0xc0000000L, 0x00000000L), ZERO_M, FLAG_FAIL_ARANYM|FLAG_FAIL_STONX },
	{ __LINE__, ZERO_M, SUBNORM_P, ZERO_M, FLAG_SUBNORM },
	{ __LINE__, ZERO_M, SUBNORM_M, ZERO_M, FLAG_SUBNORM },
	{ __LINE__, ZERO_M, MIN_P, ZERO_M, FLAG_MINVAL },
	{ __LINE__, ZERO_M, MIN_M, ZERO_M, FLAG_MINVAL },
	{ __LINE__, ZERO_M, MAX_P, ZERO_M, FLAG_FAIL_STONX },
	{ __LINE__, ZERO_M, MAX_M, ZERO_M, FLAG_FAIL_STONX },
	
	/* remainder (x, +inf) == x for x not infinite.  */
	{ __LINE__, ZERO_P, INF_P, ZERO_P, FLAG_FAIL_ARANYM|FLAG_FAIL_STONX|FLAG_XFAIL_LINUX },
	{ __LINE__, ZERO_M, INF_P, ZERO_M, FLAG_FAIL_ARANYM|FLAG_FAIL_STONX|FLAG_XFAIL_LINUX },
	{ __LINE__, SUBNORM_P, INF_P, SUBNORM_P, FLAG_SUBNORM },
	{ __LINE__, MIN_P, INF_P, MIN_P, FLAG_MINVAL },
	{ __LINE__, MAX_P, INF_P, MAX_P, FLAG_MINVAL },
	{ __LINE__, HEXCONSTE(3.0, 0x4000, 0xc0000000L, 0x00000000L), INF_P, HEXCONSTE(3.0, 0x4000, 0xc0000000L, 0x00000000L), FLAG_FAIL_ARANYM|FLAG_FAIL_STONX|FLAG_XFAIL_LINUX },

	/* remainder (x, -inf) == x for x not infinite.  */
	{ __LINE__, ZERO_P, INF_M, ZERO_P, FLAG_FAIL_ARANYM|FLAG_FAIL_STONX|FLAG_XFAIL_LINUX },
	{ __LINE__, ZERO_M, INF_M, ZERO_M, FLAG_FAIL_ARANYM|FLAG_FAIL_STONX|FLAG_XFAIL_LINUX },
	{ __LINE__, SUBNORM_P, INF_M, SUBNORM_P, FLAG_SUBNORM },
	{ __LINE__, MIN_P, INF_M, MIN_P, FLAG_MINVAL },
	{ __LINE__, MAX_P, INF_M, MAX_P, FLAG_MINVAL },
	{ __LINE__, HEXCONSTE(3.0, 0x4000, 0xc0000000L, 0x00000000L), INF_M, HEXCONSTE(3.0, 0x4000, 0xc0000000L, 0x00000000L), FLAG_FAIL_ARANYM|FLAG_FAIL_STONX|FLAG_XFAIL_LINUX },
	
	{ __LINE__, ZERO_P, QNAN_P, QNAN_P, 0 },
	{ __LINE__, ZERO_P, QNAN_M, QNAN_P, 0 },
	{ __LINE__, ZERO_M, QNAN_P, QNAN_P, 0 },
	{ __LINE__, ZERO_M, QNAN_M, QNAN_P, 0 },
	{ __LINE__, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), QNAN_P, QNAN_P, 0 },
	{ __LINE__, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), QNAN_M, QNAN_P, 0 },
	{ __LINE__, INF_P, QNAN_P, QNAN_P, 0 },
	{ __LINE__, INF_P, QNAN_M, QNAN_P, 0 },
	{ __LINE__, INF_M, QNAN_P, QNAN_P, 0 },
	{ __LINE__, INF_M, QNAN_M, QNAN_P, 0 },
	{ __LINE__, ZERO_P, SNAN_P, QNAN_P, 0 },
	{ __LINE__, ZERO_P, SNAN_M, QNAN_P, 0 },
	{ __LINE__, ZERO_M, SNAN_P, QNAN_P, 0 },
	{ __LINE__, ZERO_M, SNAN_M, QNAN_P, 0 },
	{ __LINE__, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), SNAN_P, QNAN_P, 0 },
	{ __LINE__, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), SNAN_M, QNAN_P, 0 },
	{ __LINE__, INF_P, SNAN_P, QNAN_P, 0 },
	{ __LINE__, INF_P, SNAN_M, QNAN_P, 0 },
	{ __LINE__, INF_M, SNAN_P, QNAN_P, 0 },
	{ __LINE__, INF_M, SNAN_M, QNAN_P, 0 },
	{ __LINE__, QNAN_P, ZERO_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, ZERO_P, QNAN_P, 0 },
	{ __LINE__, QNAN_P, ZERO_M, QNAN_P, 0 },
	{ __LINE__, QNAN_M, ZERO_M, QNAN_P, 0 },
	{ __LINE__, QNAN_P, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__, QNAN_M, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__, QNAN_P, INF_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, INF_P, QNAN_P, 0 },
	{ __LINE__, QNAN_P, INF_M, QNAN_P, 0 },
	{ __LINE__, QNAN_M, INF_M, QNAN_P, 0 },
	{ __LINE__, SNAN_P, ZERO_P, QNAN_P, 0 },
	{ __LINE__, SNAN_M, ZERO_P, QNAN_P, 0 },
	{ __LINE__, SNAN_P, ZERO_M, QNAN_P, 0 },
	{ __LINE__, SNAN_M, ZERO_M, QNAN_P, 0 },
	{ __LINE__, SNAN_P, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__, SNAN_M, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__, SNAN_P, INF_P, QNAN_P, 0 },
	{ __LINE__, SNAN_M, INF_P, QNAN_P, 0 },
	{ __LINE__, SNAN_P, INF_M, QNAN_P, 0 },
	{ __LINE__, SNAN_M, INF_M, QNAN_P, 0 },
	{ __LINE__, QNAN_P, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_P, QNAN_M, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_M, QNAN_P, 0 },
	{ __LINE__, QNAN_P, SNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_P, SNAN_M, QNAN_P, 0 },
	{ __LINE__, QNAN_M, SNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, SNAN_M, QNAN_P, 0 },
	{ __LINE__, SNAN_P, QNAN_P, QNAN_P, 0 },
	{ __LINE__, SNAN_P, QNAN_M, QNAN_P, 0 },
	{ __LINE__, SNAN_M, QNAN_P, QNAN_P, 0 },
	{ __LINE__, SNAN_M, QNAN_M, QNAN_P, 0 },
	{ __LINE__, SNAN_P, SNAN_P, QNAN_P, 0 },
	{ __LINE__, SNAN_P, SNAN_M, QNAN_P, 0 },
	{ __LINE__, SNAN_M, SNAN_P, QNAN_P, 0 },
	{ __LINE__, SNAN_M, SNAN_M, QNAN_P, 0 },
	
	{ __LINE__, MAX_P, MAX_P, ZERO_P, 0 },
	{ __LINE__, MAX_P, MAX_M, ZERO_P, 0 },
	{ __LINE__, MAX_P, MIN_P, ZERO_P, FLAG_MINVAL },
	{ __LINE__, MAX_P, MIN_M, ZERO_P, FLAG_MINVAL },
	{ __LINE__, MAX_P, SUBNORM_P, ZERO_P, FLAG_SUBNORM },
	{ __LINE__, MAX_P, SUBNORM_M, ZERO_P, FLAG_SUBNORM },
	{ __LINE__, MAX_M, MAX_P, ZERO_M, FLAG_FAIL_STONX },
	{ __LINE__, MAX_M, MAX_M, ZERO_M, FLAG_FAIL_STONX },
	{ __LINE__, MAX_M, MIN_P, ZERO_M, FLAG_MINVAL },
	{ __LINE__, MAX_M, MIN_M, ZERO_M, FLAG_MINVAL },
	{ __LINE__, MAX_M, SUBNORM_P, ZERO_M, FLAG_SUBNORM },
	{ __LINE__, MAX_M, SUBNORM_M, ZERO_M, FLAG_SUBNORM },
	
	{ __LINE__, MIN_P, MAX_P, MIN_P, FLAG_MINVAL },
	{ __LINE__, MIN_P, MAX_M, MIN_P, FLAG_MINVAL },
	{ __LINE__, MIN_P, MIN_P, ZERO_P, FLAG_MINVAL },
	{ __LINE__, MIN_P, MIN_M, ZERO_P, FLAG_MINVAL },
	{ __LINE__, MIN_P, SUBNORM_P, ZERO_P, FLAG_MINVAL },
	{ __LINE__, MIN_P, SUBNORM_M, ZERO_P, FLAG_MINVAL },
	{ __LINE__, MIN_M, MAX_P, MIN_M, FLAG_MINVAL },
	{ __LINE__, MIN_M, MAX_M, MIN_M, FLAG_MINVAL },
	{ __LINE__, MIN_M, MIN_P, ZERO_M, FLAG_MINVAL },
	{ __LINE__, MIN_M, MIN_M, ZERO_M, FLAG_MINVAL },
	{ __LINE__, MIN_M, SUBNORM_P, ZERO_M, FLAG_MINVAL },
	{ __LINE__, MIN_M, SUBNORM_M, ZERO_M, FLAG_MINVAL },
	
	{ __LINE__, SUBNORM_P, MAX_P, SUBNORM_P, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_P, MAX_M, SUBNORM_P, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_P, MIN_P, SUBNORM_P, FLAG_MINVAL },
	{ __LINE__, SUBNORM_P, MIN_M, SUBNORM_P, FLAG_MINVAL },
	{ __LINE__, SUBNORM_P, SUBNORM_P, ZERO_P, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_P, SUBNORM_M, ZERO_P, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, MAX_P, SUBNORM_M, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, MAX_M, SUBNORM_M, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, MIN_P, SUBNORM_M, FLAG_MINVAL },
	{ __LINE__, SUBNORM_M, MIN_M, SUBNORM_M, FLAG_MINVAL },
	{ __LINE__, SUBNORM_M, SUBNORM_P, ZERO_M, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, SUBNORM_M, ZERO_M, FLAG_SUBNORM },

	{ __LINE__, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), MAX_P, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), MAX_M, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), MAX_2_P, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), MAX_2_M, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), MAX_4_P, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), MAX_4_M, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), MAX_8_P, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), MAX_8_M, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), MAX_P, HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), MAX_M, HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), MAX_2_P, HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), MAX_2_M, HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), MAX_4_P, HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), MAX_4_M, HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), MAX_8_P, HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), MAX_8_M, HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, MAX_P, MAX_2_P, ZERO_P, 0 },
	{ __LINE__, MAX_P, MAX_2_M, ZERO_P, 0 },
	{ __LINE__, MAX_M, MAX_2_P, ZERO_M, FLAG_FAIL_STONX|FLAG_FAIL_ARANYM }, /* should be ZERO_P */
	{ __LINE__, MAX_M, MAX_2_M, ZERO_M, FLAG_FAIL_STONX|FLAG_FAIL_ARANYM }, /* should be ZERO_P */
	
	{ __LINE__, HEXCONSTE(2, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), ZERO_P, 0 },
	{ __LINE__, HEXCONSTE(2, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), ZERO_P, 0 },
	{ __LINE__, HEXCONSTE(-2, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), ZERO_M, FLAG_FAIL_STONX|FLAG_FAIL_ARANYM }, /* should be ZERO_P */
	{ __LINE__, HEXCONSTE(-2, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), ZERO_M, FLAG_FAIL_STONX|FLAG_FAIL_ARANYM }, /* should be ZERO_P */
	
	{ __LINE__, HEXCONSTE(6.5, 0x4001, 0xd0000000L, 0x00000000L), HEXCONSTE(2.25L, 0x4000, 0x90000000L, 0x00000000L), HEXCONSTE(-2.50000000000000000000e-01, 0xbffd, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-6.5, 0xc001, 0xd0000000L, 0x00000000L), HEXCONSTE(2.25L, 0x4000, 0x90000000L, 0x00000000L), HEXCONSTE(2.50000000000000000000e-01, 0x3ffd, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(6.5, 0x4001, 0xd0000000L, 0x00000000L), HEXCONSTE(-2.25L, 0xc000, 0x90000000L, 0x00000000L), HEXCONSTE(-2.50000000000000000000e-01, 0xbffd, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-6.5, 0xc001, 0xd0000000L, 0x00000000L), HEXCONSTE(-2.25L, 0xc000, 0x90000000L, 0x00000000L), HEXCONSTE(2.50000000000000000000e-01, 0x3ffd, 0x80000000L, 0x00000000L), 0 },
	
	{ __LINE__, HEXCONSTE(1.17549421069244107549e-38, 0x3f80, 0xfffffe00L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), ZERO_P, 0 },
	{ __LINE__, HEXCONSTE(2.22507385850720088902e-308, 0x3c00, 0xffffffffL, 0xfffff000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), ZERO_P, 0 },
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(3.36210314311209350590e-4932, 0x0000, 0x7fffffffL, 0xffffffffL), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), ZERO_P, 0 },
#endif
	{ __LINE__, HEXCONSTE(-1.00000000000000005551e+00, 0xbfff, 0x80000000L, 0x00000200L), HEXCONSTE(9.99999999999999944489e-01, 0x3ffe, 0xffffffffL, 0xfffffc00L), HEXCONSTE(-1.11022302462515654042e-16, 0xbfca, 0x80000000L, 0x00000000L), 0 },
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(9.99999999999999958367e-01, 0x3ffe, 0xffffffffL, 0xfffffd00L), HEXCONSTE(9.99999999999999944489e-01, 0x3ffe, 0xffffffffL, 0xfffffc00L), HEXCONSTE(1.38777878078144567553e-17, 0x3fc7, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-9.99999999999999958367e-01, 0xbffe, 0xffffffffL, 0xfffffd00L), HEXCONSTE(9.99999999999999944489e-01, 0x3ffe, 0xffffffffL, 0xfffffc00L), HEXCONSTE(-1.38777878078144567553e-17, 0xbfc7, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9.99999999999999958367e-01, 0x3ffe, 0xffffffffL, 0xfffffd00L), HEXCONSTE(-9.99999999999999944489e-01, 0xbffe, 0xffffffffL, 0xfffffc00L), HEXCONSTE(1.38777878078144567553e-17, 0x3fc7, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-9.99999999999999958367e-01, 0xbffe, 0xffffffffL, 0xfffffd00L), HEXCONSTE(-9.99999999999999944489e-01, 0xbffe, 0xffffffffL, 0xfffffc00L), HEXCONSTE(-1.38777878078144567553e-17, 0xbfc7, 0x80000000L, 0x00000000L), 0 },
#endif

	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(3.0, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.0, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(3.0, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.0, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), 0 },

	{ __LINE__, HEXCONSTE(1.625, 0x3fff, 0xd0000000L, 0x00000000L), HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-0.375, 0xbffd, 0xc0000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.625, 0xbfff, 0xd0000000L, 0x00000000L), HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.375, 0x3ffd, 0xc0000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.625, 0x3fff, 0xd0000000L, 0x00000000L), HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-0.375, 0xbffd, 0xc0000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.625, 0xbfff, 0xd0000000L, 0x00000000L), HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(0.375, 0x3ffd, 0xc0000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(5.0, 0x4001, 0xa0000000L, 0x00000000L), HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), FLAG_FAIL_STONX|FLAG_FAIL_ARANYM }, /* returns -1, which is OK */
	{ __LINE__, HEXCONSTE(3.0, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), 0 },
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(-3.00000000000000005551e+00, 0xc000, 0xc0000000L, 0x00000100L), HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999999999999944489e-01, 0x3ffe, 0xffffffffL, 0xfffffc00L), 0 },
	{ __LINE__, HEXCONSTE(9.99999999999999986122e-01, 0x3ffe, 0xffffffffL, 0xffffff00L), HEXCONSTE(-1.00000000000000001388e+00, 0xbfff, 0x80000000L, 0x00000080L), HEXCONSTE(-2.77555756156289135106e-17, 0xbfc8, 0x80000000L, 0x00000000L), 0 },
#endif

	{ __LINE__, HEXCONSTE(3419, 0x400a, 0xd5b00000L, 0x00000000L), HEXCONSTE(360, 0x4007, 0xb4000000L, 0x00000000L), HEXCONSTE(179, 0x4006, 0xb3000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-3419, 0xc00a, 0xd5b00000L, 0x00000000L), HEXCONSTE(360, 0x4007, 0xb4000000L, 0x00000000L), HEXCONSTE(-179, 0xc006, 0xb3000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3419, 0x400a, 0xd5b00000L, 0x00000000L), HEXCONSTE(-360, 0xc007, 0xb4000000L, 0x00000000L), HEXCONSTE(179, 0x4006, 0xb3000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-3419, 0xc00a, 0xd5b00000L, 0x00000000L), HEXCONSTE(-360, 0xc007, 0xb4000000L, 0x00000000L), HEXCONSTE(-179, 0xc006, 0xb3000000L, 0x00000000L), 0 },
};


int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_ff_f(remainder_data, ARRAY_SIZE(remainder_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

```

`tests/remquo.c`:

```c
#include "testconfig.h"
#ifdef HAVE_REMQUO
#define TEST_FUNC_FF_FI __MATH_PRECNAME(remquo)
#include "testdriver.h"

typedef struct { int line; ld_union x; ld_union y; ld_union e; int exp; flag_t flags; } test_ff_fi_data;

#ifdef TEST_LDOUBLE
#define TEST_OP_BODY_FF_FI(_x, _y, q) r.x = TEST_FUNC_FF_FI(_x.x, _y.x, &(q))
#endif
#ifdef TEST_DOUBLE
#define TEST_OP_BODY_FF_FI(_x, _y, q) r.x = my_extenddfxf2(TEST_FUNC_FF_FI(my_truncxfdf2(_x.x), my_truncxfdf2(_y.x), &(q)))
#endif
#ifdef TEST_FLOAT
#define TEST_OP_BODY_FF_FI(_x, _y, q) r.x = my_extenddfxf2(TEST_FUNC_FF_FI(my_truncxfsf2(_x.x), my_truncxfsf2(_y.x), &(q)))
#endif

static int test_table_ff_fi(const test_ff_fi_data *data, size_t n, const char *file)
{
	size_t l;
	int i;
	int status = 0, this_fail;
	ld_union r;
	int q;

	for (l = 0; l < n; l++)
	{
		numtests++;
		if (!SKIP_TEST(data[l].x, data[l].flags))
		{
			if (testonly == 0 || testonly == numtests)
			{
				for (i = 0; i < jit_loops; i++)
				{
					q = 0;
					TEST_OP_BODY_FF_FI(data[l].x, data[l].y, q);
					this_fail = check_fp(data[l].e.v.exponent, data[l].e.v.mantissa0, data[l].e.v.mantissa1, &r, data[l].flags, i, file, data[l].line);
					this_fail |= check_int(data[l].exp, q, data[l].flags, i, file, data[l].line);
					if (this_fail)
					{
						status |= this_fail != 0;
						break;
					}
				}
			}
		}
	}
	
	return status;
}


static test_ff_fi_data const remquo_data[] = {
	{ __LINE__, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), ZERO_P, QNAN_P, 0, NO_INEXACT_EXCEPTION|INVALID_EXCEPTION },
	{ __LINE__, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), ZERO_M, QNAN_P, 0, NO_INEXACT_EXCEPTION|INVALID_EXCEPTION },
	{ __LINE__, INF_P, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), QNAN_P, 0, NO_INEXACT_EXCEPTION|INVALID_EXCEPTION },
	{ __LINE__, INF_M, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), QNAN_P, 0, NO_INEXACT_EXCEPTION|INVALID_EXCEPTION },
	{ __LINE__, QNAN_P, QNAN_P, QNAN_P, 0, NO_INEXACT_EXCEPTION },

	{ __LINE__, HEXCONSTE(1.625, 0x3fff, 0xd0000000L, 0x00000000L), HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-0.375, 0xbffd, 0xc0000000L, 0x00000000L), 2, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-1.625, 0xbfff, 0xd0000000L, 0x00000000L), HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.375, 0x3ffd, 0xc0000000L, 0x00000000L), -2, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1.625, 0x3fff, 0xd0000000L, 0x00000000L), HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-0.375, 0xbffd, 0xc0000000L, 0x00000000L), -2, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-1.625, 0xbfff, 0xd0000000L, 0x00000000L), HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(0.375, 0x3ffd, 0xc0000000L, 0x00000000L), 2, NO_INEXACT_EXCEPTION },

	{ __LINE__, HEXCONSTE(5, 0x4001, 0xa0000000L, 0x00000000L), HEXCONSTE(2, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), 2, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(3, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(2, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), 2, NO_INEXACT_EXCEPTION },
};


int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_ff_fi(remquo_data, ARRAY_SIZE(remquo_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

#else

int main(void)
{
	return 77;
}

#endif

```

`tests/rint.c`:

```c
#include "testconfig.h"
#if defined(HAVE_RINT)
#define TEST_FUNC_F_F __MATH_PRECNAME(rint)
#include "testdriver.h"



static test_f_f_data const rint_data[] = {
	{ __LINE__, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_P, 0 },
	{ __LINE__, SNAN_P, QNAN_P, 0 },
	{ __LINE__, SNAN_M, QNAN_P, 0 },
	{ __LINE__, INF_P, INF_P, 0 },
	{ __LINE__, INF_M, INF_M, 0 },
	{ __LINE__, ZERO_P, ZERO_P, 0 },
	{ __LINE__, ZERO_M, ZERO_M, FLAG_FAIL_ARANYM2 },
	{ __LINE__, SUBNORM_P, ZERO_P, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, ZERO_M, FLAG_SUBNORM },
	{ __LINE__, MIN_P, ZERO_P, 0 },
	{ __LINE__, MIN_M, ZERO_M, 0 },
	{ __LINE__, MAX_P, MAX_P, 0 },
	{ __LINE__, MAX_M, MAX_M, 0 },
	
	/* Default rounding mode is round to even.	*/
	{ __LINE__, HEXCONSTE(0.5, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(0.0, 0x0000, 0x00000000L, 0x00000000L), INEXACT_EXCEPTION|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(1.5, 0x3fff, 0xc0000000L, 0x00000000L), HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(2.5, 0x4000, 0xa0000000L, 0x00000000L), HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(3.5, 0x4000, 0xe0000000L, 0x00000000L), HEXCONSTE(4.0, 0x4001, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(4.5, 0x4001, 0x90000000L, 0x00000000L), HEXCONSTE(4.0, 0x4001, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(-0.5, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), INEXACT_EXCEPTION|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(-1.5, 0xbfff, 0xc0000000L, 0x00000000L), HEXCONSTE(-2.0, 0xc000, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-2.5, 0xc000, 0xa0000000L, 0x00000000L), HEXCONSTE(-2.0, 0xc000, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(-3.5, 0xc000, 0xe0000000L, 0x00000000L), HEXCONSTE(-4.0, 0xc001, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-4.5, 0xc001, 0x90000000L, 0x00000000L), HEXCONSTE(-4.0, 0xc001, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(0.1, 0x3ffb, 0xccccccccL, 0xcccccccdL), HEXCONSTE(0.0, 0x0000, 0x00000000L, 0x00000000L), INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(0.25, 0x3ffd, 0x80000000L, 0x00000000L), HEXCONSTE(0.0, 0x0000, 0x00000000L, 0x00000000L), INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(0.625, 0x3ffe, 0xa0000000L, 0x00000000L), HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-0.1, 0xbffb, 0xccccccccL, 0xcccccccdL), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), INEXACT_EXCEPTION|FLAG_IGNORE_ZEROSIGN },
	{ __LINE__, HEXCONSTE(-0.25, 0xbffd, 0x80000000L, 0x00000000L), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), INEXACT_EXCEPTION|FLAG_IGNORE_ZEROSIGN },
	{ __LINE__, HEXCONSTE(-0.625, 0xbffe, 0xa0000000L, 0x00000000L), HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(262144.75, 0x4011, 0x80001800L, 0x00000000L), HEXCONSTE(262145.0, 0x4011, 0x80002000L, 0x00000000L), INEXACT_EXCEPTION|FLAG_FAIL_SOFTFLOAT },
	{ __LINE__, HEXCONSTE(262142.75, 0x4010, 0xffffb000L, 0x00000000L), HEXCONSTE(262143.0, 0x4010, 0xffffc000L, 0x00000000L), INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(524286.75, 0x4011, 0xffffd800L, 0x00000000L), HEXCONSTE(524287.0, 0x4011, 0xffffe000L, 0x00000000L), INEXACT_EXCEPTION|FLAG_FAIL_SOFTFLOAT },
	{ __LINE__, HEXCONSTE(524288.75, 0x4012, 0x80000c00L, 0x00000000L), HEXCONSTE(524289.0, 0x4012, 0x80001000L, 0x00000000L), INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1048576.75, 0x4013, 0x80000600L, 0x00000000L), HEXCONSTE(1048577.0, 0x4013, 0x80000800L, 0x00000000L), INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(2097152.75, 0x4014, 0x80000300L, 0x00000000L), HEXCONSTE(2097153.0, 0x4014, 0x80000400L, 0x00000000L), INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-1048576.75, 0xc013, 0x80000600L, 0x00000000L), HEXCONSTE(-1048577.0, 0xc013, 0x80000800L, 0x00000000L), INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-2097152.75, 0xc014, 0x80000300L, 0x00000000L), HEXCONSTE(-2097153.0, 0xc014, 0x80000400L, 0x00000000L), INEXACT_EXCEPTION },
#ifndef TEST_FLOAT
	{ __LINE__, HEXCONSTE(70368744177664.75, 0x402d, 0x80000000L, 0x00018000L), HEXCONSTE(70368744177665.0, 0x402d, 0x80000000L, 0x00020000L), INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(140737488355328.75, 0x402e, 0x80000000L, 0x0000c000L), HEXCONSTE(140737488355329.0, 0x402e, 0x80000000L, 0x00010000L), INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(281474976710656.75, 0x402f, 0x80000000L, 0x00006000L), HEXCONSTE(281474976710657.0, 0x402f, 0x80000000L, 0x00008000L), INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(562949953421312.75, 0x4030, 0x80000000L, 0x00003000L), HEXCONSTE(562949953421313.0, 0x4030, 0x80000000L, 0x00004000L), INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(1125899906842624.75, 0x4031, 0x80000000L, 0x00001800L), HEXCONSTE(1125899906842625.0, 0x4031, 0x80000000L, 0x00002000L), INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-70368744177664.75, 0xc02d, 0x80000000L, 0x00018000L), HEXCONSTE(-70368744177665.0, 0xc02d, 0x80000000L, 0x00020000L), INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-140737488355328.75, 0xc02e, 0x80000000L, 0x0000c000L), HEXCONSTE(-140737488355329.0, 0xc02e, 0x80000000L, 0x00010000L), INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-281474976710656.75, 0xc02f, 0x80000000L, 0x00006000L), HEXCONSTE(-281474976710657.0, 0xc02f, 0x80000000L, 0x00008000L), INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-562949953421312.75, 0xc030, 0x80000000L, 0x00003000L), HEXCONSTE(-562949953421313.0, 0xc030, 0x80000000L, 0x00004000L), INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-1125899906842624.75, 0xc031, 0x80000000L, 0x00001800L), HEXCONSTE(-1125899906842625.0, 0xc031, 0x80000000L, 0x00002000L), INEXACT_EXCEPTION },
#endif
#ifdef TEST_LDOUBLE
	/* The result can only be represented in long double.  */
	{ __LINE__, HEXCONSTE(4503599627370495.5L, 0x4032, 0xffffffffL, 0xfffff800L), HEXCONSTE(4503599627370496.0L, 0x4033, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(4503599627370496.25L, 0x4033, 0x80000000L, 0x00000200L), HEXCONSTE(4503599627370496.0L, 0x4033, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(4503599627370496.5L, 0x4033, 0x80000000L, 0x00000400L), HEXCONSTE(4503599627370496.0L, 0x4033, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(4503599627370496.75L, 0x4033, 0x80000000L, 0x00000600L), HEXCONSTE(4503599627370497.0L, 0x4033, 0x80000000L, 0x00000800L), INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(4503599627370497.5L, 0x4033, 0x80000000L, 0x00000c00L), HEXCONSTE(4503599627370498.0L, 0x4033, 0x80000000L, 0x00001000L), INEXACT_EXCEPTION },

	{ __LINE__, HEXCONSTE(-4503599627370495.5L, 0xc032, 0xffffffffL, 0xfffff800L), HEXCONSTE(-4503599627370496.0L, 0xc033, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-4503599627370496.25L, 0xc033, 0x80000000L, 0x00000200L), HEXCONSTE(-4503599627370496.0L, 0xc033, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-4503599627370496.5L, 0xc033, 0x80000000L, 0x00000400L), HEXCONSTE(-4503599627370496.0L, 0xc033, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-4503599627370496.75L, 0xc033, 0x80000000L, 0x00000600L), HEXCONSTE(-4503599627370497.0L, 0xc033, 0x80000000L, 0x00000800L), INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-4503599627370497.5L, 0xc033, 0x80000000L, 0x00000c00L), HEXCONSTE(-4503599627370498.0L, 0xc033, 0x80000000L, 0x00001000L), INEXACT_EXCEPTION },

	{ __LINE__, HEXCONSTE(9007199254740991.5L, 0x4033, 0xffffffffL, 0xfffffc00L), HEXCONSTE(9007199254740992.0L, 0x4034, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(9007199254740992.25L, 0x4034, 0x80000000L, 0x00000100L), HEXCONSTE(9007199254740992.0L, 0x4034, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(9007199254740992.5L, 0x4034, 0x80000000L, 0x00000200L), HEXCONSTE(9007199254740992.0L, 0x4034, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(9007199254740992.75L, 0x4034, 0x80000000L, 0x00000300L), HEXCONSTE(9007199254740993.0L, 0x4034, 0x80000000L, 0x00000400L), INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(9007199254740993.5L, 0x4034, 0x80000000L, 0x00000600L), HEXCONSTE(9007199254740994.0L, 0x4034, 0x80000000L, 0x00000800L), INEXACT_EXCEPTION },

	{ __LINE__, HEXCONSTE(-9007199254740991.5L, 0xc033, 0xffffffffL, 0xfffffc00L), HEXCONSTE(-9007199254740992.0L, 0xc034, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-9007199254740992.25L, 0xc034, 0x80000000L, 0x00000100L), HEXCONSTE(-9007199254740992.0L, 0xc034, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-9007199254740992.5L, 0xc034, 0x80000000L, 0x00000200L), HEXCONSTE(-9007199254740992.0L, 0xc034, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-9007199254740992.75L, 0xc034, 0x80000000L, 0x00000300L), HEXCONSTE(-9007199254740993.0L, 0xc034, 0x80000000L, 0x00000400L), INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-9007199254740993.5L, 0xc034, 0x80000000L, 0x00000600L), HEXCONSTE(-9007199254740994.0L, 0xc034, 0x80000000L, 0x00000800L), INEXACT_EXCEPTION },

	{ __LINE__, HEXCONSTE(72057594037927935.5L, 0x4036, 0xffffffffL, 0xffffff80L), HEXCONSTE(72057594037927936.0L, 0x4037, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(72057594037927936.25L, 0x4037, 0x80000000L, 0x00000020L), HEXCONSTE(72057594037927936.0L, 0x4037, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(72057594037927936.5L, 0x4037, 0x80000000L, 0x00000040L), HEXCONSTE(72057594037927936.0L, 0x4037, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(72057594037927936.75L, 0x4037, 0x80000000L, 0x00000060L), HEXCONSTE(72057594037927937.0L, 0x4037, 0x80000000L, 0x00000080L), INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(72057594037927937.5L, 0x4037, 0x80000000L, 0x000000c0L), HEXCONSTE(72057594037927938.0L, 0x4037, 0x80000000L, 0x00000100L), INEXACT_EXCEPTION },

	{ __LINE__, HEXCONSTE(-72057594037927935.5L, 0xc036, 0xffffffffL, 0xffffff80L), HEXCONSTE(-72057594037927936.0L, 0xc037, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-72057594037927936.25L, 0xc037, 0x80000000L, 0x00000020L), HEXCONSTE(-72057594037927936.0L, 0xc037, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-72057594037927936.5L, 0xc037, 0x80000000L, 0x00000040L), HEXCONSTE(-72057594037927936.0L, 0xc037, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-72057594037927936.75L, 0xc037, 0x80000000L, 0x00000060L), HEXCONSTE(-72057594037927937.0L, 0xc037, 0x80000000L, 0x00000080L), INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-72057594037927937.5L, 0xc037, 0x80000000L, 0x000000c0L), HEXCONSTE(-72057594037927938.0L, 0xc037, 0x80000000L, 0x00000100L), INEXACT_EXCEPTION },
#endif

	{ __LINE__, HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), NO_INEXACT_EXCEPTION|ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(1.5, 0x3fff, 0xc0000000L, 0x00000000L), HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), NO_INEXACT_EXCEPTION|ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(0.5, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(0.0, 0x0000, 0x00000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_TONEAREST|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(0.0, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(0.0, 0x0000, 0x00000000L, 0x00000000L), NO_INEXACT_EXCEPTION|ROUND_TONEAREST },
	{ __LINE__, ZERO_M, ZERO_M, NO_INEXACT_EXCEPTION|ROUND_TONEAREST|FLAG_FAIL_ARANYM2 },
	{ __LINE__, HEXCONSTE(-0.5, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_TONEAREST|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), NO_INEXACT_EXCEPTION|ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(-1.5, 0xbfff, 0xc0000000L, 0x00000000L), HEXCONSTE(-2.0, 0xc000, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(-2.0, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(-2.0, 0xc000, 0x80000000L, 0x00000000L), NO_INEXACT_EXCEPTION|ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(0.1, 0x3ffb, 0xccccccccL, 0xcccccccdL), HEXCONSTE(0.0, 0x0000, 0x00000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(0.25, 0x3ffd, 0x80000000L, 0x00000000L), HEXCONSTE(0.0, 0x0000, 0x00000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(0.625, 0x3ffe, 0xa0000000L, 0x00000000L), HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(-0.1, 0xbffb, 0xccccccccL, 0xcccccccdL), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_TONEAREST|FLAG_IGNORE_ZEROSIGN },
	{ __LINE__, HEXCONSTE(-0.25, 0xbffd, 0x80000000L, 0x00000000L), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_TONEAREST|FLAG_IGNORE_ZEROSIGN },
	{ __LINE__, HEXCONSTE(-0.625, 0xbffe, 0xa0000000L, 0x00000000L), HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(1048576.75, 0x4013, 0x80000600L, 0x00000000L), HEXCONSTE(1048577.0, 0x4013, 0x80000800L, 0x00000000L), INEXACT_EXCEPTION|ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(2097152.75, 0x4014, 0x80000300L, 0x00000000L), HEXCONSTE(2097153.0, 0x4014, 0x80000400L, 0x00000000L), INEXACT_EXCEPTION|ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(-1048576.75, 0xc013, 0x80000600L, 0x00000000L), HEXCONSTE(-1048577.0, 0xc013, 0x80000800L, 0x00000000L), INEXACT_EXCEPTION|ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(-2097152.75, 0xc014, 0x80000300L, 0x00000000L), HEXCONSTE(-2097153.0, 0xc014, 0x80000400L, 0x00000000L), INEXACT_EXCEPTION|ROUND_TONEAREST },
#ifndef TEST_FLOAT
	{ __LINE__, HEXCONSTE(70368744177664.75, 0x402d, 0x80000000L, 0x00018000L), HEXCONSTE(70368744177665.0, 0x402d, 0x80000000L, 0x00020000L), INEXACT_EXCEPTION|ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(140737488355328.75, 0x402e, 0x80000000L, 0x0000c000L), HEXCONSTE(140737488355329.0, 0x402e, 0x80000000L, 0x00010000L), INEXACT_EXCEPTION|ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(281474976710656.75, 0x402f, 0x80000000L, 0x00006000L), HEXCONSTE(281474976710657.0, 0x402f, 0x80000000L, 0x00008000L), INEXACT_EXCEPTION|ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(562949953421312.75, 0x4030, 0x80000000L, 0x00003000L), HEXCONSTE(562949953421313.0, 0x4030, 0x80000000L, 0x00004000L), INEXACT_EXCEPTION|ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(1125899906842624.75, 0x4031, 0x80000000L, 0x00001800L), HEXCONSTE(1125899906842625.0, 0x4031, 0x80000000L, 0x00002000L), INEXACT_EXCEPTION|ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(-70368744177664.75, 0xc02d, 0x80000000L, 0x00018000L), HEXCONSTE(-70368744177665.0, 0xc02d, 0x80000000L, 0x00020000L), INEXACT_EXCEPTION|ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(-140737488355328.75, 0xc02e, 0x80000000L, 0x0000c000L), HEXCONSTE(-140737488355329.0, 0xc02e, 0x80000000L, 0x00010000L), INEXACT_EXCEPTION|ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(-281474976710656.75, 0xc02f, 0x80000000L, 0x00006000L), HEXCONSTE(-281474976710657.0, 0xc02f, 0x80000000L, 0x00008000L), INEXACT_EXCEPTION|ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(-562949953421312.75, 0xc030, 0x80000000L, 0x00003000L), HEXCONSTE(-562949953421313.0, 0xc030, 0x80000000L, 0x00004000L), INEXACT_EXCEPTION|ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(-1125899906842624.75, 0xc031, 0x80000000L, 0x00001800L), HEXCONSTE(-1125899906842625.0, 0xc031, 0x80000000L, 0x00002000L), INEXACT_EXCEPTION|ROUND_TONEAREST },
#endif
#ifdef TEST_LDOUBLE
	/* The result can only be represented in long double.  */
	{ __LINE__, HEXCONSTE(4503599627370495.5L, 0x4032, 0xffffffffL, 0xfffff800L), HEXCONSTE(4503599627370496.0L, 0x4033, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(4503599627370496.25L, 0x4033, 0x80000000L, 0x00000200L), HEXCONSTE(4503599627370496.0L, 0x4033, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(4503599627370496.5L, 0x4033, 0x80000000L, 0x00000400L), HEXCONSTE(4503599627370496.0L, 0x4033, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(4503599627370496.75L, 0x4033, 0x80000000L, 0x00000600L), HEXCONSTE(4503599627370497.0L, 0x4033, 0x80000000L, 0x00000800L), INEXACT_EXCEPTION|ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(4503599627370497.5L, 0x4033, 0x80000000L, 0x00000c00L), HEXCONSTE(4503599627370498.0L, 0x4033, 0x80000000L, 0x00001000L), INEXACT_EXCEPTION|ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(-4503599627370495.5L, 0xc032, 0xffffffffL, 0xfffff800L), HEXCONSTE(-4503599627370496.0L, 0xc033, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(-4503599627370496.25L, 0xc033, 0x80000000L, 0x00000200L), HEXCONSTE(-4503599627370496.0L, 0xc033, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(-4503599627370496.5L, 0xc033, 0x80000000L, 0x00000400L), HEXCONSTE(-4503599627370496.0L, 0xc033, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(-4503599627370496.75L, 0xc033, 0x80000000L, 0x00000600L), HEXCONSTE(-4503599627370497.0L, 0xc033, 0x80000000L, 0x00000800L), INEXACT_EXCEPTION|ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(-4503599627370497.5L, 0xc033, 0x80000000L, 0x00000c00L), HEXCONSTE(-4503599627370498.0L, 0xc033, 0x80000000L, 0x00001000L), INEXACT_EXCEPTION|ROUND_TONEAREST },
#endif

#if 0
	{ __LINE__, HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), NO_INEXACT_EXCEPTION|ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(1.5, 0x3fff, 0xc0000000L, 0x00000000L), HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), NO_INEXACT_EXCEPTION|ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(0.5, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(0.0, 0x0000, 0x00000000L, 0x00000000L), ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(0.0, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(0.0, 0x0000, 0x00000000L, 0x00000000L), NO_INEXACT_EXCEPTION|ROUND_TOWARDZERO },
	{ __LINE__, ZERO_M, ZERO_M, NO_INEXACT_EXCEPTION|ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-0.5, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), NO_INEXACT_EXCEPTION|ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-1.5, 0xbfff, 0xc0000000L, 0x00000000L), HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-2.0, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(-2.0, 0xc000, 0x80000000L, 0x00000000L), NO_INEXACT_EXCEPTION|ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(0.1, 0x3ffb, 0xccccccccL, 0xcccccccdL), HEXCONSTE(0.0, 0x0000, 0x00000000L, 0x00000000L), ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(0.25, 0x3ffd, 0x80000000L, 0x00000000L), HEXCONSTE(0.0, 0x0000, 0x00000000L, 0x00000000L), ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(0.625, 0x3ffe, 0xa0000000L, 0x00000000L), HEXCONSTE(0.0, 0x0000, 0x00000000L, 0x00000000L), ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-0.1, 0xbffb, 0xccccccccL, 0xcccccccdL), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-0.25, 0xbffd, 0x80000000L, 0x00000000L), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-0.625, 0xbffe, 0xa0000000L, 0x00000000L), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(1048576.75, 0x4013, 0x80000600L, 0x00000000L), HEXCONSTE(1048576.0, 0x4013, 0x80000000L, 0x00000000L), ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(2097152.75, 0x4014, 0x80000300L, 0x00000000L), HEXCONSTE(2097152.0, 0x4014, 0x80000000L, 0x00000000L), ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-1048576.75, 0xc013, 0x80000600L, 0x00000000L), HEXCONSTE(-1048576.0, 0xc013, 0x80000000L, 0x00000000L), ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-2097152.75, 0xc014, 0x80000300L, 0x00000000L), HEXCONSTE(-2097152.0, 0xc014, 0x80000000L, 0x00000000L), ROUND_TOWARDZERO },
#ifndef TEST_FLOAT
	{ __LINE__, HEXCONSTE(70368744177664.75, 0x402d, 0x80000000L, 0x00018000L), HEXCONSTE(70368744177664.0, 0x402d, 0x80000000L, 0x00000000L), ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(140737488355328.75, 0x402e, 0x80000000L, 0x0000c000L), HEXCONSTE(140737488355328.0, 0x402e, 0x80000000L, 0x00000000L), ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(281474976710656.75, 0x402f, 0x80000000L, 0x00006000L), HEXCONSTE(281474976710656.0, 0x402f, 0x80000000L, 0x00000000L), ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(562949953421312.75, 0x4030, 0x80000000L, 0x00003000L), HEXCONSTE(562949953421312.0, 0x4030, 0x80000000L, 0x00000000L), ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(1125899906842624.75, 0x4031, 0x80000000L, 0x00001800L), HEXCONSTE(1125899906842624.0, 0x4031, 0x80000000L, 0x00000000L), ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-70368744177664.75, 0xc02d, 0x80000000L, 0x00018000L), HEXCONSTE(-70368744177664.0, 0xc02d, 0x80000000L, 0x00000000L), ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-140737488355328.75, 0xc02e, 0x80000000L, 0x0000c000L), HEXCONSTE(-140737488355328.0, 0xc02e, 0x80000000L, 0x00000000L), ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-281474976710656.75, 0xc02f, 0x80000000L, 0x00006000L), HEXCONSTE(-281474976710656.0, 0xc02f, 0x80000000L, 0x00000000L), ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-562949953421312.75, 0xc030, 0x80000000L, 0x00003000L), HEXCONSTE(-562949953421312.0, 0xc030, 0x80000000L, 0x00000000L), ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-1125899906842624.75, 0xc031, 0x80000000L, 0x00001800L), HEXCONSTE(-1125899906842624.0, 0xc031, 0x80000000L, 0x00000000L), ROUND_TOWARDZERO },
#endif
#ifdef TEST_LDOUBLE
	/* The result can only be represented in long double.  */
	{ __LINE__, HEXCONSTE(4503599627370495.5L, 0x4032, 0xffffffffL, 0xfffff800L), HEXCONSTE(4503599627370495.0L, 0x4032, 0xffffffffL, 0xfffff000L), ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(4503599627370496.25L, 0x4033, 0x80000000L, 0x00000200L), HEXCONSTE(4503599627370496.0L, 0x4033, 0x80000000L, 0x00000000L), ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(4503599627370496.5L, 0x4033, 0x80000000L, 0x00000400L), HEXCONSTE(4503599627370496.0L, 0x4033, 0x80000000L, 0x00000000L), ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(4503599627370496.75L, 0x4033, 0x80000000L, 0x00000600L), HEXCONSTE(4503599627370496.0L, 0x4033, 0x80000000L, 0x00000000L), ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(4503599627370497.5L, 0x4033, 0x80000000L, 0x00000c00L), HEXCONSTE(4503599627370497.0L, 0x4033, 0x80000000L, 0x00000800L), ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-4503599627370495.5L, 0xc032, 0xffffffffL, 0xfffff800L), HEXCONSTE(-4503599627370495.0L, 0xc032, 0xffffffffL, 0xfffff000L), ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-4503599627370496.25L, 0xc033, 0x80000000L, 0x00000200L), HEXCONSTE(-4503599627370496.0L, 0xc033, 0x80000000L, 0x00000000L), ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-4503599627370496.5L, 0xc033, 0x80000000L, 0x00000400L), HEXCONSTE(-4503599627370496.0L, 0xc033, 0x80000000L, 0x00000000L), ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-4503599627370496.75L, 0xc033, 0x80000000L, 0x00000600L), HEXCONSTE(-4503599627370496.0L, 0xc033, 0x80000000L, 0x00000000L), ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(-4503599627370497.5L, 0xc033, 0x80000000L, 0x00000c00L), HEXCONSTE(-4503599627370497.0L, 0xc033, 0x80000000L, 0x00000800L), ROUND_TOWARDZERO },
#endif

	{ __LINE__, HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), NO_INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(1.5, 0x3fff, 0xc0000000L, 0x00000000L), HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), NO_INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(0.5, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(0.0, 0x0000, 0x00000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(0.0, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(0.0, 0x0000, 0x00000000L, 0x00000000L), NO_INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, ZERO_M, ZERO_M, NO_INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-0.5, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), NO_INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-1.5, 0xbfff, 0xc0000000L, 0x00000000L), HEXCONSTE(-2.0, 0xc000, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-2.0, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(-2.0, 0xc000, 0x80000000L, 0x00000000L), NO_INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(0.1, 0x3ffb, 0xccccccccL, 0xcccccccdL), HEXCONSTE(0.0, 0x0000, 0x00000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(0.25, 0x3ffd, 0x80000000L, 0x00000000L), HEXCONSTE(0.0, 0x0000, 0x00000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(0.625, 0x3ffe, 0xa0000000L, 0x00000000L), HEXCONSTE(0.0, 0x0000, 0x00000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-0.1, 0xbffb, 0xccccccccL, 0xcccccccdL), HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-0.25, 0xbffd, 0x80000000L, 0x00000000L), HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-0.625, 0xbffe, 0xa0000000L, 0x00000000L), HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(1048576.75, 0x4013, 0x80000600L, 0x00000000L), HEXCONSTE(1048576.0, 0x4013, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(2097152.75, 0x4014, 0x80000300L, 0x00000000L), HEXCONSTE(2097152.0, 0x4014, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-1048576.75, 0xc013, 0x80000600L, 0x00000000L), HEXCONSTE(-1048577.0, 0xc013, 0x80000800L, 0x00000000L), INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-2097152.75, 0xc014, 0x80000300L, 0x00000000L), HEXCONSTE(-2097153.0, 0xc014, 0x80000400L, 0x00000000L), INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-1048576.0, 0xc013, 0x80000000L, 0x00000000L), HEXCONSTE(-1048576.0, 0xc013, 0x80000000L, 0x00000000L), NO_INEXACT_EXCEPTION|ROUND_DOWNWARD },
#ifndef TEST_FLOAT
	{ __LINE__, HEXCONSTE(70368744177664.75, 0x402d, 0x80000000L, 0x00018000L), HEXCONSTE(70368744177664.0, 0x402d, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(140737488355328.75, 0x402e, 0x80000000L, 0x0000c000L), HEXCONSTE(140737488355328.0, 0x402e, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(281474976710656.75, 0x402f, 0x80000000L, 0x00006000L), HEXCONSTE(281474976710656.0, 0x402f, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(562949953421312.75, 0x4030, 0x80000000L, 0x00003000L), HEXCONSTE(562949953421312.0, 0x4030, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(1125899906842624.75, 0x4031, 0x80000000L, 0x00001800L), HEXCONSTE(1125899906842624.0, 0x4031, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-70368744177664.75, 0xc02d, 0x80000000L, 0x00018000L), HEXCONSTE(-70368744177665.0, 0xc02d, 0x80000000L, 0x00020000L), INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-140737488355328.75, 0xc02e, 0x80000000L, 0x0000c000L), HEXCONSTE(-140737488355329.0, 0xc02e, 0x80000000L, 0x00010000L), INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-281474976710656.75, 0xc02f, 0x80000000L, 0x00006000L), HEXCONSTE(-281474976710657.0, 0xc02f, 0x80000000L, 0x00008000L), INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-562949953421312.75, 0xc030, 0x80000000L, 0x00003000L), HEXCONSTE(-562949953421313.0, 0xc030, 0x80000000L, 0x00004000L), INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-1125899906842624.75, 0xc031, 0x80000000L, 0x00001800L), HEXCONSTE(-1125899906842625.0, 0xc031, 0x80000000L, 0x00002000L), INEXACT_EXCEPTION|ROUND_DOWNWARD },
#endif
#ifdef TEST_LDOUBLE
	/* The result can only be represented in long double.  */
	{ __LINE__, HEXCONSTE(4503599627370495.5L, 0x4032, 0xffffffffL, 0xfffff800L), HEXCONSTE(4503599627370495.0L, 0x4032, 0xffffffffL, 0xfffff000L), INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(4503599627370496.25L, 0x4033, 0x80000000L, 0x00000200L), HEXCONSTE(4503599627370496.0L, 0x4033, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(4503599627370496.5L, 0x4033, 0x80000000L, 0x00000400L), HEXCONSTE(4503599627370496.0L, 0x4033, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(4503599627370496.75L, 0x4033, 0x80000000L, 0x00000600L), HEXCONSTE(4503599627370496.0L, 0x4033, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(4503599627370497.5L, 0x4033, 0x80000000L, 0x00000c00L), HEXCONSTE(4503599627370497.0L, 0x4033, 0x80000000L, 0x00000800L), INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-4503599627370495.5L, 0xc032, 0xffffffffL, 0xfffff800L), HEXCONSTE(-4503599627370496.0L, 0xc033, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-4503599627370496.25L, 0xc033, 0x80000000L, 0x00000200L), HEXCONSTE(-4503599627370497.0L, 0xc033, 0x80000000L, 0x00000800L), INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-4503599627370496.5L, 0xc033, 0x80000000L, 0x00000400L), HEXCONSTE(-4503599627370497.0L, 0xc033, 0x80000000L, 0x00000800L), INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-4503599627370496.75L, 0xc033, 0x80000000L, 0x00000600L), HEXCONSTE(-4503599627370497.0L, 0xc033, 0x80000000L, 0x00000800L), INEXACT_EXCEPTION|ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(-4503599627370497.5L, 0xc033, 0x80000000L, 0x00000c00L), HEXCONSTE(-4503599627370498.0L, 0xc033, 0x80000000L, 0x00001000L), INEXACT_EXCEPTION|ROUND_DOWNWARD },
#endif

	{ __LINE__, HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), NO_INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(1.5, 0x3fff, 0xc0000000L, 0x00000000L), HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), NO_INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(0.5, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(0.0, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(0.0, 0x0000, 0x00000000L, 0x00000000L), NO_INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, ZERO_M, ZERO_M, NO_INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-0.5, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), NO_INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-1.5, 0xbfff, 0xc0000000L, 0x00000000L), HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-2.0, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(-2.0, 0xc000, 0x80000000L, 0x00000000L), NO_INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(0.1, 0x3ffb, 0xccccccccL, 0xcccccccdL), HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(0.25, 0x3ffd, 0x80000000L, 0x00000000L), HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(0.625, 0x3ffe, 0xa0000000L, 0x00000000L), HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-0.1, 0xbffb, 0xccccccccL, 0xcccccccdL), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-0.25, 0xbffd, 0x80000000L, 0x00000000L), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-0.625, 0xbffe, 0xa0000000L, 0x00000000L), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(1048576.75, 0x4013, 0x80000600L, 0x00000000L), HEXCONSTE(1048577.0, 0x4013, 0x80000800L, 0x00000000L), INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(2097152.75, 0x4014, 0x80000300L, 0x00000000L), HEXCONSTE(2097153.0, 0x4014, 0x80000400L, 0x00000000L), INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-1048576.75, 0xc013, 0x80000600L, 0x00000000L), HEXCONSTE(-1048576.0, 0xc013, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-2097152.75, 0xc014, 0x80000300L, 0x00000000L), HEXCONSTE(-2097152.0, 0xc014, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_UPWARD },
#ifndef TEST_FLOAT
	{ __LINE__, HEXCONSTE(70368744177664.75, 0x402d, 0x80000000L, 0x00018000L), HEXCONSTE(70368744177665.0, 0x402d, 0x80000000L, 0x00020000L), INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(140737488355328.75, 0x402e, 0x80000000L, 0x0000c000L), HEXCONSTE(140737488355329.0, 0x402e, 0x80000000L, 0x00010000L), INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(281474976710656.75, 0x402f, 0x80000000L, 0x00006000L), HEXCONSTE(281474976710657.0, 0x402f, 0x80000000L, 0x00008000L), INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(562949953421312.75, 0x4030, 0x80000000L, 0x00003000L), HEXCONSTE(562949953421313.0, 0x4030, 0x80000000L, 0x00004000L), INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(1125899906842624.75, 0x4031, 0x80000000L, 0x00001800L), HEXCONSTE(1125899906842625.0, 0x4031, 0x80000000L, 0x00002000L), INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-70368744177664.75, 0xc02d, 0x80000000L, 0x00018000L), HEXCONSTE(-70368744177664.0, 0xc02d, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-140737488355328.75, 0xc02e, 0x80000000L, 0x0000c000L), HEXCONSTE(-140737488355328.0, 0xc02e, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-281474976710656.75, 0xc02f, 0x80000000L, 0x00006000L), HEXCONSTE(-281474976710656.0, 0xc02f, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-562949953421312.75, 0xc030, 0x80000000L, 0x00003000L), HEXCONSTE(-562949953421312.0, 0xc030, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-1125899906842624.75, 0xc031, 0x80000000L, 0x00001800L), HEXCONSTE(-1125899906842624.0, 0xc031, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_UPWARD },
#endif
#ifdef TEST_LDOUBLE
	/* The result can only be represented in long double.  */
	{ __LINE__, HEXCONSTE(4503599627370495.5L, 0x4032, 0xffffffffL, 0xfffff800L), HEXCONSTE(4503599627370496.0L, 0x4033, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(4503599627370496.25L, 0x4033, 0x80000000L, 0x00000200L), HEXCONSTE(4503599627370497.0L, 0x4033, 0x80000000L, 0x00000800L), INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(4503599627370496.5L, 0x4033, 0x80000000L, 0x00000400L), HEXCONSTE(4503599627370497.0L, 0x4033, 0x80000000L, 0x00000800L), INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(4503599627370496.75L, 0x4033, 0x80000000L, 0x00000600L), HEXCONSTE(4503599627370497.0L, 0x4033, 0x80000000L, 0x00000800L), INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(4503599627370497.5L, 0x4033, 0x80000000L, 0x00000c00L), HEXCONSTE(4503599627370498.0L, 0x4033, 0x80000000L, 0x00001000L), INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-4503599627370495.5L, 0xc032, 0xffffffffL, 0xfffff800L), HEXCONSTE(-4503599627370495.0L, 0xc032, 0xffffffffL, 0xfffff000L), INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-4503599627370496.25L, 0xc033, 0x80000000L, 0x00000200L), HEXCONSTE(-4503599627370496.0L, 0xc033, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-4503599627370496.5L, 0xc033, 0x80000000L, 0x00000400L), HEXCONSTE(-4503599627370496.0L, 0xc033, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-4503599627370496.75L, 0xc033, 0x80000000L, 0x00000600L), HEXCONSTE(-4503599627370496.0L, 0xc033, 0x80000000L, 0x00000000L), INEXACT_EXCEPTION|ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(-4503599627370497.5L, 0xc033, 0x80000000L, 0x00000c00L), HEXCONSTE(-4503599627370497.0L, 0xc033, 0x80000000L, 0x00000800L), INEXACT_EXCEPTION|ROUND_UPWARD },
#endif
#endif
};


int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_f_f(rint_data, ARRAY_SIZE(rint_data), __FILE__);

	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

#else

int main(void)
{
	return 77;
}

#endif

```

`tests/round.c`:

```c
#include "testconfig.h"
#define TEST_FUNC_F_F __MATH_PRECNAME(round)
#include "testdriver.h"


static test_f_f_data const round_data[] = {
	{ __LINE__, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_P, 0 },
	{ __LINE__, SNAN_P, QNAN_P, 0 },
	{ __LINE__, SNAN_M, QNAN_P, 0 },
	{ __LINE__, INF_P, INF_P, FLAG_FAIL_SOFTFLOAT },
	{ __LINE__, INF_M, INF_M, FLAG_FAIL_SOFTFLOAT },
	{ __LINE__, ZERO_P, ZERO_P, 0 },
	{ __LINE__, ZERO_M, ZERO_M, FLAG_FAIL_ARANYM2|FLAG_FAIL_SOFTFLOAT },
	{ __LINE__, SUBNORM_P, ZERO_P, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, ZERO_M, FLAG_SUBNORM },
	{ __LINE__, MIN_P, ZERO_P, 0 },
	{ __LINE__, MIN_M, ZERO_M, 0 },
	{ __LINE__, MAX_P, MAX_P, 0 },
	{ __LINE__, MAX_M, MAX_M, 0 },
	
	{ __LINE__, HEXCONSTE(4.5, 0x4001, 0x90000000L, 0x00000000L), HEXCONSTE(5.0, 0x4001, 0xa0000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.5, 0x4000, 0xe0000000L, 0x00000000L), HEXCONSTE(4.0, 0x4001, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.5, 0x4000, 0xa0000000L, 0x00000000L), HEXCONSTE(3.0, 0x4000, 0xc0000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.5, 0x3fff, 0xc0000000L, 0x00000000L), HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.5, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-0.5, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.5, 0xbfff, 0xc0000000L, 0x00000000L), HEXCONSTE(-2.0, 0xc000, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-2.0, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(-2.0, 0xc000, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-2.5, 0xc000, 0xa0000000L, 0x00000000L), HEXCONSTE(-3.0, 0xc000, 0xc0000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-3.5, 0xc000, 0xe0000000L, 0x00000000L), HEXCONSTE(-4.0, 0xc001, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-4.5, 0xc001, 0x90000000L, 0x00000000L), HEXCONSTE(-5.0, 0xc001, 0xa0000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.1, 0x3ffb, 0xccccccccL, 0xcccccccdL), HEXCONSTE(0.0, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.25, 0x3ffd, 0x80000000L, 0x00000000L), HEXCONSTE(0.0, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.625, 0x3ffe, 0xa0000000L, 0x00000000L), HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-0.1, 0xbffb, 0xccccccccL, 0xcccccccdL), ZERO_P, FLAG_IGNORE_ZEROSIGN },
	{ __LINE__, HEXCONSTE(-0.25, 0xbffd, 0x80000000L, 0x00000000L), ZERO_P, FLAG_IGNORE_ZEROSIGN },
	{ __LINE__, HEXCONSTE(-0.625, 0xbffe, 0xa0000000L, 0x00000000L), HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(262144.75, 0x4011, 0x80001800L, 0x00000000L), HEXCONSTE(262145.0, 0x4011, 0x80002000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(262142.75, 0x4010, 0xffffb000L, 0x00000000L), HEXCONSTE(262143.0, 0x4010, 0xffffc000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(524286.75, 0x4011, 0xffffd800L, 0x00000000L), HEXCONSTE(524287.0, 0x4011, 0xffffe000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(524288.75, 0x4012, 0x80000c00L, 0x00000000L), HEXCONSTE(524289.0, 0x4012, 0x80001000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1048576.75, 0x4013, 0x80000600L, 0x00000000L), HEXCONSTE(1048577.0, 0x4013, 0x80000800L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2097152.75, 0x4014, 0x80000300L, 0x00000000L), HEXCONSTE(2097153.0, 0x4014, 0x80000400L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2492472.75, 0x4014, 0x9820e300L, 0x00000000L), HEXCONSTE(2492473.0, 0x4014, 0x9820e400L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2886220.75, 0x4014, 0xb0293300L, 0x00000000L), HEXCONSTE(2886221.0, 0x4014, 0xb0293400L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3058792.75, 0x4014, 0xbab1a300L, 0x00000000L), HEXCONSTE(3058793.0, 0x4014, 0xbab1a400L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1048576.75, 0xc013, 0x80000600L, 0x00000000L), HEXCONSTE(-1048577.0, 0xc013, 0x80000800L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-2097152.75, 0xc014, 0x80000300L, 0x00000000L), HEXCONSTE(-2097153.0, 0xc014, 0x80000400L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-2492472.75, 0xc014, 0x9820e300L, 0x00000000L), HEXCONSTE(-2492473.0, 0xc014, 0x9820e400L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-2886220.75, 0xc014, 0xb0293300L, 0x00000000L), HEXCONSTE(-2886221.0, 0xc014, 0xb0293400L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-3058792.75, 0xc014, 0xbab1a300L, 0x00000000L), HEXCONSTE(-3058793.0, 0xc014, 0xbab1a400L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(70368744177664.75, 0x402d, 0x80000000L, 0x00018000L), HEXCONSTE(70368744177665.0, 0x402d, 0x80000000L, 0x00020000L), 0 },
	{ __LINE__, HEXCONSTE(140737488355328.75, 0x402e, 0x80000000L, 0x0000c000L), HEXCONSTE(140737488355329.0, 0x402e, 0x80000000L, 0x00010000L), 0 },
	{ __LINE__, HEXCONSTE(281474976710656.75, 0x402f, 0x80000000L, 0x00006000L), HEXCONSTE(281474976710657.0, 0x402f, 0x80000000L, 0x00008000L), 0 },
	{ __LINE__, HEXCONSTE(562949953421312.75, 0x4030, 0x80000000L, 0x00003000L), HEXCONSTE(562949953421313.0, 0x4030, 0x80000000L, 0x00004000L), 0 },
	{ __LINE__, HEXCONSTE(1125899906842624.75, 0x4031, 0x80000000L, 0x00001800L), HEXCONSTE(1125899906842625.0, 0x4031, 0x80000000L, 0x00002000L), 0 },
	{ __LINE__, HEXCONSTE(-70368744177664.75, 0xc02d, 0x80000000L, 0x00018000L), HEXCONSTE(-70368744177665.0, 0xc02d, 0x80000000L, 0x00020000L), 0 },
	{ __LINE__, HEXCONSTE(-140737488355328.75, 0xc02e, 0x80000000L, 0x0000c000L), HEXCONSTE(-140737488355329.0, 0xc02e, 0x80000000L, 0x00010000L), 0 },
	{ __LINE__, HEXCONSTE(-281474976710656.75, 0xc02f, 0x80000000L, 0x00006000L), HEXCONSTE(-281474976710657.0, 0xc02f, 0x80000000L, 0x00008000L), 0 },
	{ __LINE__, HEXCONSTE(-562949953421312.75, 0xc030, 0x80000000L, 0x00003000L), HEXCONSTE(-562949953421313.0, 0xc030, 0x80000000L, 0x00004000L), 0 },
	{ __LINE__, HEXCONSTE(-1125899906842624.75, 0xc031, 0x80000000L, 0x00001800L), HEXCONSTE(-1125899906842625.0, 0xc031, 0x80000000L, 0x00002000L), 0 },

	{ __LINE__, HEXCONSTE(8.38860800000000000000e+06, 0x4016, 0x80000000L, 0x00000000L), HEXCONSTE(8.38860800000000000000e+06, 0x4016, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.67772160000000000000e+07, 0x4017, 0x80000000L, 0x00000000L), HEXCONSTE(1.67772160000000000000e+07, 0x4017, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.35544320000000000000e+07, 0x4018, 0x80000000L, 0x00000000L), HEXCONSTE(3.35544320000000000000e+07, 0x4018, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.50359962737049600000e+15, 0x4033, 0x80000000L, 0x00000000L), HEXCONSTE(4.50359962737049600000e+15, 0x4033, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9.00719925474099200000e+15, 0x4034, 0x80000000L, 0x00000000L), HEXCONSTE(9.00719925474099200000e+15, 0x4034, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.80143985094819840000e+16, 0x4035, 0x80000000L, 0x00000000L), HEXCONSTE(1.80143985094819840000e+16, 0x4035, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9.22337203685477580800e+18, 0x403e, 0x80000000L, 0x00000000L), HEXCONSTE(9.22337203685477580800e+18, 0x403e, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.84467440737095516160e+19, 0x403f, 0x80000000L, 0x00000000L), HEXCONSTE(1.84467440737095516160e+19, 0x403f, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.68934881474191032320e+19, 0x4040, 0x80000000L, 0x00000000L), HEXCONSTE(3.68934881474191032320e+19, 0x4040, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.05648192073033408479e+31, 0x4068, 0x80000000L, 0x00000000L), HEXCONSTE(4.05648192073033408479e+31, 0x4068, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(8.11296384146066816958e+31, 0x4069, 0x80000000L, 0x00000000L), HEXCONSTE(8.11296384146066816958e+31, 0x4069, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.62259276829213363392e+32, 0x406a, 0x80000000L, 0x00000000L), HEXCONSTE(1.62259276829213363392e+32, 0x406a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(5.19229685853482762853e+33, 0x406f, 0x80000000L, 0x00000000L), HEXCONSTE(5.19229685853482762853e+33, 0x406f, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.03845937170696552571e+34, 0x4070, 0x80000000L, 0x00000000L), HEXCONSTE(1.03845937170696552571e+34, 0x4070, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.07691874341393105141e+34, 0x4071, 0x80000000L, 0x00000000L), HEXCONSTE(2.07691874341393105141e+34, 0x4071, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-8.38860800000000000000e+06, 0xc016, 0x80000000L, 0x00000000L), HEXCONSTE(-8.38860800000000000000e+06, 0xc016, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.67772160000000000000e+07, 0xc017, 0x80000000L, 0x00000000L), HEXCONSTE(-1.67772160000000000000e+07, 0xc017, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-3.35544320000000000000e+07, 0xc018, 0x80000000L, 0x00000000L), HEXCONSTE(-3.35544320000000000000e+07, 0xc018, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-4.50359962737049600000e+15, 0xc033, 0x80000000L, 0x00000000L), HEXCONSTE(-4.50359962737049600000e+15, 0xc033, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-9.00719925474099200000e+15, 0xc034, 0x80000000L, 0x00000000L), HEXCONSTE(-9.00719925474099200000e+15, 0xc034, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.80143985094819840000e+16, 0xc035, 0x80000000L, 0x00000000L), HEXCONSTE(-1.80143985094819840000e+16, 0xc035, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-9.22337203685477580800e+18, 0xc03e, 0x80000000L, 0x00000000L), HEXCONSTE(-9.22337203685477580800e+18, 0xc03e, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.84467440737095516160e+19, 0xc03f, 0x80000000L, 0x00000000L), HEXCONSTE(-1.84467440737095516160e+19, 0xc03f, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-3.68934881474191032320e+19, 0xc040, 0x80000000L, 0x00000000L), HEXCONSTE(-3.68934881474191032320e+19, 0xc040, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-4.05648192073033408479e+31, 0xc068, 0x80000000L, 0x00000000L), HEXCONSTE(-4.05648192073033408479e+31, 0xc068, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-8.11296384146066816958e+31, 0xc069, 0x80000000L, 0x00000000L), HEXCONSTE(-8.11296384146066816958e+31, 0xc069, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.62259276829213363392e+32, 0xc06a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.62259276829213363392e+32, 0xc06a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-5.19229685853482762853e+33, 0xc06f, 0x80000000L, 0x00000000L), HEXCONSTE(-5.19229685853482762853e+33, 0xc06f, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.03845937170696552571e+34, 0xc070, 0x80000000L, 0x00000000L), HEXCONSTE(-1.03845937170696552571e+34, 0xc070, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-2.07691874341393105141e+34, 0xc071, 0x80000000L, 0x00000000L), HEXCONSTE(-2.07691874341393105141e+34, 0xc071, 0x80000000L, 0x00000000L), 0 },

	{ __LINE__, HEXCONSTE(0.2, 0x3ffc, 0xccccccccL, 0xcccccccdL), ZERO_P, 0 },
	{ __LINE__, HEXCONSTE(-0.2, 0xbffc, 0xccccccccL, 0xcccccccdL), ZERO_P, FLAG_IGNORE_ZEROSIGN },
	{ __LINE__, HEXCONSTE(0.5, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-0.5, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.8, 0x3ffe, 0xccccccccL, 0xcccccccdL), HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-0.8, 0xbffe, 0xccccccccL, 0xcccccccdL), HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.5, 0x3fff, 0xc0000000L, 0x00000000L), HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.5, 0xbfff, 0xc0000000L, 0x00000000L), HEXCONSTE(-2.0, 0xc000, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.1, 0x3ffb, 0xccccccccL, 0xcccccccdL), ZERO_P, 0 },
	{ __LINE__, HEXCONSTE(0.25, 0x3ffd, 0x80000000L, 0x00000000L), ZERO_P, 0 },
	{ __LINE__, HEXCONSTE(0.625, 0x3ffe, 0xa0000000L, 0x00000000L), HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-0.1, 0xbffb, 0xccccccccL, 0xcccccccdL), ZERO_P, FLAG_IGNORE_ZEROSIGN },
	{ __LINE__, HEXCONSTE(-0.25, 0xbffd, 0x80000000L, 0x00000000L), ZERO_P, FLAG_IGNORE_ZEROSIGN },
	{ __LINE__, HEXCONSTE(-0.625, 0xbffe, 0xa0000000L, 0x00000000L), HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), 0 },
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(2097152.5, 0x4014, 0x80000200L, 0x00000000L), HEXCONSTE(2097153, 0x4014, 0x80000400L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-2097152.5, 0xc014, 0x80000200L, 0x00000000L), HEXCONSTE(-2097153, 0xc014, 0x80000400L, 0x00000000L), 0 },
#endif

	{ __LINE__, HEXCONSTE(2.81474976710655000000e+14, 0x402e, 0xffffffffL, 0xffff0000L), HEXCONSTE(2.81474976710655000000e+14, 0x402e, 0xffffffffL, 0xffff0000L), 0 },
	{ __LINE__, HEXCONSTE(2.81474976710655250000e+14, 0x402e, 0xffffffffL, 0xffff4000L), HEXCONSTE(2.81474976710655000000e+14, 0x402e, 0xffffffffL, 0xffff0000L), 0 },
	{ __LINE__, HEXCONSTE(2.81474976710655500000e+14, 0x402e, 0xffffffffL, 0xffff8000L), HEXCONSTE(2.81474976710656000000e+14, 0x402f, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.81474976710655750000e+14, 0x402e, 0xffffffffL, 0xffffc000L), HEXCONSTE(2.81474976710656000000e+14, 0x402f, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-2.81474976710655000000e+14, 0xc02e, 0xffffffffL, 0xffff0000L), HEXCONSTE(-2.81474976710655000000e+14, 0xc02e, 0xffffffffL, 0xffff0000L), 0 },
	{ __LINE__, HEXCONSTE(-2.81474976710655250000e+14, 0xc02e, 0xffffffffL, 0xffff4000L), HEXCONSTE(-2.81474976710655000000e+14, 0xc02e, 0xffffffffL, 0xffff0000L), 0 },
	{ __LINE__, HEXCONSTE(-2.81474976710655500000e+14, 0xc02e, 0xffffffffL, 0xffff8000L), HEXCONSTE(-2.81474976710656000000e+14, 0xc02f, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-2.81474976710655750000e+14, 0xc02e, 0xffffffffL, 0xffffc000L), HEXCONSTE(-2.81474976710656000000e+14, 0xc02f, 0x80000000L, 0x00000000L), 0 },

#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	/* The result can only be represented in long double. */
	{ __LINE__, HEXCONSTE(4503599627370495.5, 0x4032, 0xffffffffL, 0xfffff800L), HEXCONSTE(4503599627370496.0, 0x4033, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4503599627370496.25, 0x4033, 0x80000000L, 0x00000200L), HEXCONSTE(4503599627370496.0, 0x4033, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4503599627370496.5, 0x4033, 0x80000000L, 0x00000400L), HEXCONSTE(4503599627370497.0, 0x4033, 0x80000000L, 0x00000800L), 0 },
	{ __LINE__, HEXCONSTE(4503599627370496.75, 0x4033, 0x80000000L, 0x00000600L), HEXCONSTE(4503599627370497.0, 0x4033, 0x80000000L, 0x00000800L), 0 },
	{ __LINE__, HEXCONSTE(4503599627370497.5, 0x4033, 0x80000000L, 0x00000c00L), HEXCONSTE(4503599627370498.0, 0x4033, 0x80000000L, 0x00001000L), 0 },
	{ __LINE__, HEXCONSTE(-4503599627370495.5, 0xc032, 0xffffffffL, 0xfffff800L), HEXCONSTE(-4503599627370496.0, 0xc033, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-4503599627370496.25, 0xc033, 0x80000000L, 0x00000200L), HEXCONSTE(-4503599627370496.0, 0xc033, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-4503599627370496.5, 0xc033, 0x80000000L, 0x00000400L), HEXCONSTE(-4503599627370497.0, 0xc033, 0x80000000L, 0x00000800L), 0 },
	{ __LINE__, HEXCONSTE(-4503599627370496.75, 0xc033, 0x80000000L, 0x00000600L), HEXCONSTE(-4503599627370497.0, 0xc033, 0x80000000L, 0x00000800L), 0 },
	{ __LINE__, HEXCONSTE(-4503599627370497.5, 0xc033, 0x80000000L, 0x00000c00L), HEXCONSTE(-4503599627370498.0, 0xc033, 0x80000000L, 0x00001000L), 0 },
	
	{ __LINE__, HEXCONSTE(9007199254740991.5, 0x4033, 0xffffffffL, 0xfffffc00L), HEXCONSTE(9007199254740992.0, 0x4034, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9007199254740992.25, 0x4034, 0x80000000L, 0x00000100L), HEXCONSTE(9007199254740992.0, 0x4034, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9007199254740992.5, 0x4034, 0x80000000L, 0x00000200L), HEXCONSTE(9007199254740993.0, 0x4034, 0x80000000L, 0x00000400L), 0 },
	{ __LINE__, HEXCONSTE(9007199254740992.75, 0x4034, 0x80000000L, 0x00000300L), HEXCONSTE(9007199254740993.0, 0x4034, 0x80000000L, 0x00000400L), 0 },
	{ __LINE__, HEXCONSTE(9007199254740993.5, 0x4034, 0x80000000L, 0x00000600L), HEXCONSTE(9007199254740994.0, 0x4034, 0x80000000L, 0x00000800L), 0 },
	
	{ __LINE__, HEXCONSTE(-9007199254740991.5, 0xc033, 0xffffffffL, 0xfffffc00L), HEXCONSTE(-9007199254740992.0, 0xc034, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-9007199254740992.25, 0xc034, 0x80000000L, 0x00000100L), HEXCONSTE(-9007199254740992.0, 0xc034, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-9007199254740992.5, 0xc034, 0x80000000L, 0x00000200L), HEXCONSTE(-9007199254740993.0, 0xc034, 0x80000000L, 0x00000400L), 0 },
	{ __LINE__, HEXCONSTE(-9007199254740992.75, 0xc034, 0x80000000L, 0x00000300L), HEXCONSTE(-9007199254740993.0, 0xc034, 0x80000000L, 0x00000400L), 0 },
	{ __LINE__, HEXCONSTE(-9007199254740993.5, 0xc034, 0x80000000L, 0x00000600L), HEXCONSTE(-9007199254740994.0, 0xc034, 0x80000000L, 0x00000800L), 0 },
	
	{ __LINE__, HEXCONSTE(72057594037927935.5, 0x4036, 0xffffffffL, 0xffffff80L), HEXCONSTE(72057594037927936.0, 0x4037, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(72057594037927936.25, 0x4037, 0x80000000L, 0x00000020L), HEXCONSTE(72057594037927936.0, 0x4037, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(72057594037927936.5, 0x4037, 0x80000000L, 0x00000040L), HEXCONSTE(72057594037927937.0, 0x4037, 0x80000000L, 0x00000080L), 0 },
	{ __LINE__, HEXCONSTE(72057594037927936.75, 0x4037, 0x80000000L, 0x00000060L), HEXCONSTE(72057594037927937.0, 0x4037, 0x80000000L, 0x00000080L), 0 },
	{ __LINE__, HEXCONSTE(72057594037927937.5, 0x4037, 0x80000000L, 0x000000c0L), HEXCONSTE(72057594037927938.0, 0x4037, 0x80000000L, 0x00000100L), 0 },
	
	{ __LINE__, HEXCONSTE(-72057594037927935.5, 0xc036, 0xffffffffL, 0xffffff80L), HEXCONSTE(-72057594037927936.0, 0xc037, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-72057594037927936.25, 0xc037, 0x80000000L, 0x00000020L), HEXCONSTE(-72057594037927936.0, 0xc037, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-72057594037927936.5, 0xc037, 0x80000000L, 0x00000040L), HEXCONSTE(-72057594037927937.0, 0xc037, 0x80000000L, 0x00000080L), 0 },
	{ __LINE__, HEXCONSTE(-72057594037927936.75, 0xc037, 0x80000000L, 0x00000060L), HEXCONSTE(-72057594037927937.0, 0xc037, 0x80000000L, 0x00000080L), 0 },
	{ __LINE__, HEXCONSTE(-72057594037927937.5, 0xc037, 0x80000000L, 0x000000c0L), HEXCONSTE(-72057594037927938.0, 0xc037, 0x80000000L, 0x00000100L), 0 },
	
	{ __LINE__, HEXCONSTE(34503599627370498.515625, 0x4035, 0xf529ae9eL, 0x86000508L), HEXCONSTE(34503599627370499.0, 0x4035, 0xf529ae9eL, 0x86000600L), 0 },
	{ __LINE__, HEXCONSTE(-34503599627370498.515625, 0xc035, 0xf529ae9eL, 0x86000508L), HEXCONSTE(-34503599627370499.0, 0xc035, 0xf529ae9eL, 0x86000600L), 0 },

	{ __LINE__, HEXCONSTE(10141204801825835211973625643007.5, 0x4066, 0x80000000L, 0x00000000L), HEXCONSTE(10141204801825835211973625643008.0, 0x4066, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(10141204801825835211973625643008.25, 0x4066, 0x80000000L, 0x00000000L), HEXCONSTE(10141204801825835211973625643008.0, 0x4066, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(10141204801825835211973625643008.5, 0x4066, 0x80000000L, 0x00000000L), HEXCONSTE(10141204801825835211973625643009.0, 0x4066, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(10141204801825835211973625643008.75, 0x4066, 0x80000000L, 0x00000000L), HEXCONSTE(10141204801825835211973625643009.0, 0x4066, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(10141204801825835211973625643009.5, 0x4066, 0x80000000L, 0x00000000L), HEXCONSTE(10141204801825835211973625643010.0, 0x4066, 0x80000000L, 0x00000000L), 0 },
#endif

	{ __LINE__, HEXCONSTE(-8.98847e+307, 0xc3fe, 0x80000409L, 0x7954f717L), HEXCONSTE(-8.98847e+307, 0xc3fe, 0x80000409L, 0x7954f717L), 0 },
	{ __LINE__, HEXCONSTE(-4.45015e-308, 0xbc02, 0x8000044dL, 0xb01f4deeL), ZERO_P, FLAG_IGNORE_ZEROSIGN },
};


int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_f_f(round_data, ARRAY_SIZE(round_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

```

`tests/scalb.c`:

```c
#include "testconfig.h"
#define TEST_FUNC_FF_F __MATH_PRECNAME(scalb)
#include "testdriver.h"

#define ONE_P HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L)
#define ONE_M HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L)


#if __LDBL_MIN_EXP__ <= (-16382)
#define MIN_HALF_P HEXCONSTE(+8.40525785778023376566e-4933, 0x0000, 0x40000000L, 0x00000000L) /* min_value / 2 */
#define MIN_HALF_M HEXCONSTE(-8.40525785778023376566e-4933, 0x8000, 0x40000000L, 0x00000000L) /* -min_value / 2 */
#define MIN_P_2    HEXCONSTE(+3.36205184148942639058e-4932, 0x0000, 0x7fff8000L, 0x00000000L) /* min_value * 0x0.ffffp0 */
#define MIN_M_2    HEXCONSTE(-3.36205184148942639058e-4932, 0x8000, 0x7fff8000L, 0x00000000L) /* -min_value * 0x0.ffffp0 */
#define MIN_P_15   HEXCONSTE(+2.52157735733407012970e-4932, 0x0000, 0xc0000000L, 0x00000000L) /* min_value * 1.5 */
#define MIN_M_15   HEXCONSTE(-2.52157735733407012970e-4932, 0x8000, 0xc0000000L, 0x00000000L) /* -min_value * 1.5 */
#define MIN_P_125  HEXCONSTE(+2.10131446444505844141e-4932, 0x0000, 0xa0000000L, 0x00000000L) /* min_value * 1.25 */
#define MIN_M_125  HEXCONSTE(-2.10131446444505844141e-4932, 0x8000, 0xa0000000L, 0x00000000L) /* -min_value * 1.25 */
#define MIN_4TH_P  HEXCONSTE(+4.20262892889011688283e-4933, 0x0000, 0x20000000L, 0x00000000L) /* min_value / 4 */
#define MIN_4TH_M  HEXCONSTE(-4.20262892889011688283e-4933, 0x8000, 0x20000000L, 0x00000000L) /* -min_value / 4 */
#define SUBNORM2_P HEXCONSTE(+7.29039906376494920506e-4951, 0x0000, 0x00000000L, 0x00000002L) /* subnorm_value * 2 */
#define SUBNORM2_M HEXCONSTE(-7.29039906376494920506e-4951, 0x8000, 0x00000000L, 0x00000002L) /* -subnorm_value * 2 */
#else
#define MIN_HALF_P HEXCONSTE(+1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L) /* min_value / 2 */
#define MIN_HALF_M HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L) /* -min_value / 2 */
#define MIN_P_2    HEXCONSTE(+3.36205184148942639058e-4932, 0x0000, 0x7fff8000L, 0x00000000L) /* min_value * 0x0.ffffp0 */
#define MIN_M_2    HEXCONSTE(-3.36205184148942639058e-4932, 0x8000, 0x7fff8000L, 0x00000000L) /* -min_value * 0x0.ffffp0 */
#define MIN_P_15   HEXCONSTE(+5.04315471466814025939e-4932, 0x0001, 0xc0000000L, 0x00000000L) /* min_value * 1.5 */
#define MIN_M_15   HEXCONSTE(-5.04315471466814025939e-4932, 0x8001, 0xc0000000L, 0x00000000L) /* -min_value * 1.5 */
#define MIN_P_125  HEXCONSTE(+4.20262892889011688283e-4932, 0x0001, 0xa0000000L, 0x00000000L) /* min_value * 1.25 */
#define MIN_M_125  HEXCONSTE(-4.20262892889011688283e-4932, 0x8001, 0xa0000000L, 0x00000000L) /* -min_value * 1.25 */
#define MIN_4TH_P  HEXCONSTE(+8.40525785778023376566e-4933, 0x0000, 0x20000000L, 0x00000000L) /* min_value / 4 */
#define MIN_4TH_M  HEXCONSTE(-8.40525785778023376566e-4933, 0x8000, 0x20000000L, 0x00000000L) /* -min_value / 4 */
#define SUBNORM2_P HEXCONSTE(+7.29039906376494920506e-4951, 0x0000, 0x00000000L, 0x00000002L) /* subnorm_value * 2 */
#define SUBNORM2_M HEXCONSTE(-7.29039906376494920506e-4951, 0x8000, 0x00000000L, 0x00000002L) /* -subnorm_value * 2 */
#endif

#define FP_INT_MAX HEXCONSTE(2147483647, 0x401d, 0xfffffffeL, 0x00000000L)
#define FP_INT_MIN HEXCONSTE(-2147483648, 0xc01e, 0x80000000L, 0x00000000L)

#define MANTDIG_P_M1 HEXCONSTE(63, 0x4004, 0xfc000000L, 0x00000000L)  /* LDBL_MANT_DIG - 1 */
#define MANTDIG_M_P1 HEXCONSTE(-63, 0xc004, 0xfc000000L, 0x00000000L) /* -LDBL_MANT_DIG + 1 */
#define MANTDIG_P    HEXCONSTE(64, 0x4005, 0x80000000L, 0x00000000L)  /* LDBL_MANT_DIG */
#define MANTDIG_M    HEXCONSTE(-64, 0xc005, 0x80000000L, 0x00000000L) /* -LDBL_MANT_DIG */
#define MANTDIG_M_M1 HEXCONSTE(-65, 0xc005, 0x82000000L, 0x00000000L) /* -LDBL_MANT_DIG - 1 */

#define plus_uflow ZERO_P
#define minus_uflow ZERO_M
#define plus_oflow INF_P
#define minus_oflow INF_M


static test_ff_f_data const scalb_data[] = {
	{ __LINE__, ZERO_P, ZERO_P, ZERO_P, 0 },
	{ __LINE__, ZERO_M, ZERO_P, ZERO_M, FLAG_FAIL_ARANYM2 }, /* returns +0 */
	{ __LINE__, ZERO_P, HEXCONSTE(2, 0x4000, 0x80000000L, 0x00000000L), ZERO_P, 0 },
	{ __LINE__, ZERO_M, HEXCONSTE(-4, 0xc001, 0x80000000L, 0x00000000L), ZERO_M, FLAG_FAIL_ARANYM2 }, /* returns +0 */
	{ __LINE__, ZERO_P, ZERO_P, ZERO_P, 0 },
	{ __LINE__, ZERO_M, ZERO_P, ZERO_M, FLAG_FAIL_ARANYM2 }, /* returns +0 */
	{ __LINE__, ZERO_P, HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), ZERO_P, 0 },
	{ __LINE__, ZERO_M, HEXCONSTE(-10, 0xc002, 0xa0000000L, 0x00000000L), ZERO_M, FLAG_FAIL_ARANYM2 }, /* returns +0 */
	{ __LINE__, ZERO_P, INF_M, ZERO_P, 0 },
	{ __LINE__, ZERO_M, INF_M, ZERO_M, FLAG_FAIL_ARANYM2 }, /* returns +0 */
	{ __LINE__, ZERO_P, INF_P, QNAN_P, INVALID_EXCEPTION|FLAG_FAIL_HARDFLOAT|FLAG_FAIL_ARANYM }, /* glibc returns inf */
	{ __LINE__, ZERO_M, INF_P, QNAN_P, INVALID_EXCEPTION|FLAG_FAIL_HARDFLOAT|FLAG_FAIL_ARANYM }, /* glibc returns inf */
	
	{ __LINE__, INF_P, ONE_P, INF_P, FLAG_XFAIL_LINUX },
	{ __LINE__, INF_M, ONE_P, INF_M, FLAG_XFAIL_LINUX },
	{ __LINE__, INF_P, ONE_M, INF_P, 0 },
	{ __LINE__, INF_M, HEXCONSTE(-10, 0xc002, 0xa0000000L, 0x00000000L), INF_M, 0 },
	{ __LINE__, INF_P, ZERO_P, INF_P, 0 },
	{ __LINE__, INF_M, ZERO_P, INF_M, 0 },
	{ __LINE__, INF_P, HEXCONSTE(2, 0x4000, 0x80000000L, 0x00000000L), INF_P, 0 },
	{ __LINE__, INF_M, HEXCONSTE(100, 0x4005, 0xc8000000L, 0x00000000L), INF_M, 0 },
	{ __LINE__, INF_P, INF_P, INF_P, 0 },
	{ __LINE__, INF_M, INF_P, INF_M, 0 },
	{ __LINE__, INF_P, INF_M, QNAN_P, INVALID_EXCEPTION|FLAG_FAIL_HARDFLOAT|FLAG_FAIL_ARANYM }, /* glibc returns inf */
	{ __LINE__, INF_M, INF_M, QNAN_P, INVALID_EXCEPTION|FLAG_FAIL_HARDFLOAT|FLAG_FAIL_ARANYM }, /* glibc returns inf */

	{ __LINE__, QNAN_P, ONE_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, ONE_P, QNAN_P, 0 },
	{ __LINE__, SNAN_P, ONE_P, QNAN_P, 0 },
	{ __LINE__, SNAN_M, ONE_P, QNAN_P, 0 },
	
	{ __LINE__, HEXCONSTE(0.8L, 0x3ffe, 0xccccccccL, 0xcccccccdL), HEXCONSTE(4, 0x4001, 0x80000000L, 0x00000000L), HEXCONSTE(12.8L, 0x4002, 0xccccccccL, 0xcccccccdL), 0 },
	{ __LINE__, HEXCONSTE(-0.854375L, 0xbffe, 0xdab851ebL, 0x851eb852L), HEXCONSTE(5, 0x4001, 0xa0000000L, 0x00000000L), HEXCONSTE(-27.34L, 0xc003, 0xdab851ebL, 0x851eb852L), 0 },
	
	{ __LINE__, ONE_P, ZERO_P, ONE_P, 0 },
	
#ifdef TEST_LDOUBLE
	{ __LINE__, MIN_HALF_P, ZERO_P, MIN_HALF_P, 0 },
	{ __LINE__, MIN_HALF_M, ZERO_P, MIN_HALF_M, 0 },
	{ __LINE__, MIN_HALF_P, ONE_P, MIN_P, FLAG_MINVAL|FLAG_SUBNORM },
	{ __LINE__, MIN_HALF_M, ONE_P, MIN_M, FLAG_MINVAL|FLAG_SUBNORM },
	{ __LINE__, MIN_P_2, ZERO_P, MIN_P_2, 0 },
	{ __LINE__, MIN_M_2, ZERO_P, MIN_M_2, 0 },
	{ __LINE__, SUBNORM_P, ZERO_P, SUBNORM_P, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, ZERO_P, SUBNORM_M, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_P, MANTDIG_P_M1, MIN_P, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, MANTDIG_P_M1, MIN_M, FLAG_SUBNORM },
#endif
	
#ifdef TEST_LDOUBLE
	{ __LINE__, MIN_P, MANTDIG_M_P1, SUBNORM_P, FLAG_SUBNORM },
	{ __LINE__, MIN_M, MANTDIG_M_P1, SUBNORM_M, FLAG_SUBNORM },
	{ __LINE__, MIN_P, MANTDIG_M, plus_uflow, FLAG_MINVAL|FLAG_SUBNORM },
	{ __LINE__, MIN_M, MANTDIG_M, minus_uflow, FLAG_MINVAL|FLAG_SUBNORM },
	{ __LINE__, MIN_P, MANTDIG_M_M1, plus_uflow, FLAG_MINVAL|FLAG_SUBNORM },
	{ __LINE__, MIN_M, MANTDIG_M_M1, minus_uflow, FLAG_MINVAL|FLAG_SUBNORM },
	{ __LINE__, MIN_P_15, MANTDIG_M_P1, SUBNORM2_P, FLAG_SUBNORM },
	{ __LINE__, MIN_M_15, MANTDIG_M_P1, SUBNORM2_M, FLAG_MINVAL|FLAG_SUBNORM },
	{ __LINE__, MIN_P_15, MANTDIG_M, SUBNORM_P, FLAG_SUBNORM },
	{ __LINE__, MIN_M_15, MANTDIG_M, SUBNORM_M, FLAG_SUBNORM },
	{ __LINE__, MIN_P_15, MANTDIG_M_M1, plus_uflow, 0 },
	{ __LINE__, MIN_M_15, MANTDIG_M_M1, minus_uflow, 0 },
	{ __LINE__, MIN_P_125, MANTDIG_M_P1, SUBNORM_P, FLAG_SUBNORM }, /* works in STonX, but fails in ARAnyM */
	{ __LINE__, MIN_M_125, MANTDIG_M_P1, SUBNORM_M, FLAG_XFAIL_LINUX|FLAG_SUBNORM },
	{ __LINE__, MIN_P_125, MANTDIG_M, SUBNORM_P, FLAG_XFAIL_LINUX|FLAG_SUBNORM },
	{ __LINE__, MIN_M_125, MANTDIG_M, SUBNORM_M, FLAG_SUBNORM }, /* works in STonX, but fails in ARAnyM */
	{ __LINE__, MIN_P_125, MANTDIG_M_M1, plus_uflow, 0 },
	{ __LINE__, MIN_M_125, MANTDIG_M_M1, minus_uflow, 0 },
#endif
	
	{ __LINE__, ONE_P, FP_INT_MAX, plus_oflow, FLAG_FAIL_ARANYM }, /* glibc returns nan */
	{ __LINE__, ONE_P, FP_INT_MIN, plus_uflow, 0 },
	{ __LINE__, MAX_P, FP_INT_MAX, plus_oflow, 0 },
	{ __LINE__, MAX_P, FP_INT_MIN, plus_uflow, 0 },
	{ __LINE__, MIN_P, FP_INT_MAX, plus_oflow, 0 },
	{ __LINE__, MIN_P, FP_INT_MIN, plus_uflow, 0 },
#ifdef TEST_LDOUBLE
	{ __LINE__, MIN_4TH_P, FP_INT_MAX, plus_oflow, 0 },
	{ __LINE__, MIN_4TH_P, FP_INT_MIN, plus_uflow, 0 },
	{ __LINE__, SUBNORM_P, FP_INT_MAX, plus_oflow, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_P, FP_INT_MIN, plus_uflow, FLAG_SUBNORM },
#endif
	
	{ __LINE__, ONE_M, FP_INT_MAX, minus_oflow, FLAG_FAIL_ARANYM }, /* glibc returns nan */
	{ __LINE__, ONE_M, FP_INT_MIN, minus_uflow, FLAG_FAIL_SOFTFLOAT|FLAG_FAIL_ARANYM }, /* returns +0 */
#ifdef TEST_LDOUBLE
	{ __LINE__, MAX_M, FP_INT_MAX, minus_oflow, 0 },
	{ __LINE__, MAX_M, FP_INT_MIN, minus_uflow, 0 },
	{ __LINE__, MIN_M, FP_INT_MAX, minus_oflow, 0 },
	{ __LINE__, MIN_M, FP_INT_MIN, minus_uflow, 0 },
	{ __LINE__, MIN_4TH_M, FP_INT_MAX, minus_oflow, 0 },
	{ __LINE__, MIN_4TH_M, FP_INT_MIN, minus_uflow, FLAG_XFAIL_LINUX|FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, FP_INT_MAX, minus_oflow, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, FP_INT_MIN, minus_uflow, FLAG_SUBNORM },
#endif

	{ __LINE__, HEXCONSTE(5.0, 0x4001, 0xa0000000L, 0x00000000L), ONE_P, HEXCONSTE(10.0, 0x4002, 0xa0000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(5.0, 0x4001, 0xa0000000L, 0x00000000L), ONE_M, HEXCONSTE(2.5, 0x4000, 0xa0000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0x1p16382, 0x7ffd, 0x80000000L, 0x0L), ONE_P, HEXCONSTE("0x1p16383", 0x7ffe, 0x80000000L, 0x0L), 0 },
	{ __LINE__, HEXCONSTE(0x1p16383, 0x7ffe, 0x80000000L, 0x0L), ONE_P, INF_P, 0 },

	{ __LINE__, HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(0.5, 0x3ffe, 0x80000000L, 0x00000000L), QNAN_P, INVALID_EXCEPTION|FLAG_FAIL_HARDFLOAT|FLAG_FAIL_ARANYM }, /* glibc returns 2.0 */
	{ __LINE__, HEXCONSTE(3.0, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(-2.5, 0xc000, 0xa0000000L, 0x00000000L), QNAN_P, INVALID_EXCEPTION|FLAG_FAIL_HARDFLOAT|FLAG_FAIL_ARANYM }, /* glibc returns 0.75 */

	{ __LINE__, ZERO_P, QNAN_P, QNAN_P, FLAG_FAIL_HARDFLOAT|FLAG_FAIL_ARANYM }, /* glibc returns 0 */
	{ __LINE__, ONE_P, QNAN_P, QNAN_P, FLAG_FAIL_HARDFLOAT|FLAG_FAIL_ARANYM }, /* glibc returns 0 */

	{ __LINE__, ONE_P, ZERO_P, ONE_P, 0 },
	{ __LINE__, ONE_M, ZERO_P, ONE_M, 0 },

	{ __LINE__, HEXCONSTE(0.1L, 0x3ffb, 0xccccccccL, 0xcccccccdL), INF_M, ZERO_P, 0 },
	{ __LINE__, HEXCONSTE(-0.1L, 0xbffb, 0xccccccccL, 0xcccccccdL), INF_M, ZERO_M, FLAG_FAIL_SOFTFLOAT|FLAG_FAIL_ARANYM }, /* returns +0 */

	{ __LINE__, ONE_P, INF_P, INF_P, FLAG_FAIL_ARANYM }, /* glibc returns 0 */
	{ __LINE__, ONE_M, INF_P, INF_M, FLAG_FAIL_ARANYM }, /* glibc returns 0 */

	{ __LINE__, QNAN_P, ONE_P, QNAN_P, 0 },
	{ __LINE__, ONE_P, QNAN_P, QNAN_P, FLAG_FAIL_HARDFLOAT|FLAG_FAIL_ARANYM }, /* glibc returns 0 */
	{ __LINE__, QNAN_P, ZERO_P, QNAN_P, 0 },
	{ __LINE__, ZERO_P, QNAN_P, QNAN_P, FLAG_FAIL_HARDFLOAT|FLAG_FAIL_ARANYM }, /* glibc returns 0 */
	{ __LINE__, QNAN_P, INF_P, QNAN_P, 0 },
	{ __LINE__, INF_P, QNAN_P, QNAN_P, FLAG_FAIL_SOFTFLOAT|FLAG_FAIL_HARDFLOAT|FLAG_FAIL_ARANYM }, /* glibc returns 0 */
	{ __LINE__, QNAN_P, QNAN_P, QNAN_P, 0 },

	{ __LINE__, HEXCONSTE(0.8L, 0x3ffe, 0xccccccccL, 0xcccccccdL), HEXCONSTE(4, 0x4001, 0x80000000L, 0x00000000L), HEXCONSTE(12.8L, 0x4002, 0xccccccccL, 0xcccccccdL), 0 },
	{ __LINE__, HEXCONSTE(-0.854375L, 0xbffe, 0xdab851ebL, 0x851eb852L), HEXCONSTE(5, 0x4001, 0xa0000000L, 0x00000000L), HEXCONSTE(-27.34L, 0xc003, 0xdab851ebL, 0x851eb852L), 0 },
};

int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_ff_f(scalb_data, ARRAY_SIZE(scalb_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

```

`tests/scbln.c`:

```c
#include "testconfig.h"
#ifdef HAVE_SCALBLN
#define TEST_FUNC_FL_F __MATH_PRECNAME(scalbln)
#include "testdriver.h"

#define ONE_P HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L)
#define ONE_M HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L)


#if __LDBL_MIN_EXP__ <= (-16382)
#define MIN_HALF_P HEXCONSTE(+8.40525785778023376566e-4933, 0x0000, 0x40000000L, 0x00000000L) /* min_value / 2 */
#define MIN_HALF_M HEXCONSTE(-8.40525785778023376566e-4933, 0x8000, 0x40000000L, 0x00000000L) /* -min_value / 2 */
#define MIN_P_2    HEXCONSTE(+3.36205184148942639058e-4932, 0x0000, 0x7fff8000L, 0x00000000L) /* min_value * 0x0.ffffp0 */
#define MIN_M_2    HEXCONSTE(-3.36205184148942639058e-4932, 0x8000, 0x7fff8000L, 0x00000000L) /* -min_value * 0x0.ffffp0 */
#define MIN_P_15   HEXCONSTE(+2.52157735733407012970e-4932, 0x0000, 0xc0000000L, 0x00000000L) /* min_value * 1.5 */
#define MIN_M_15   HEXCONSTE(-2.52157735733407012970e-4932, 0x8000, 0xc0000000L, 0x00000000L) /* -min_value * 1.5 */
#define MIN_P_125  HEXCONSTE(+2.10131446444505844141e-4932, 0x0000, 0xa0000000L, 0x00000000L) /* min_value * 1.25 */
#define MIN_M_125  HEXCONSTE(-2.10131446444505844141e-4932, 0x8000, 0xa0000000L, 0x00000000L) /* -min_value * 1.25 */
#define MIN_4TH_P  HEXCONSTE(+4.20262892889011688283e-4933, 0x0000, 0x20000000L, 0x00000000L) /* min_value / 4 */
#define MIN_4TH_M  HEXCONSTE(-4.20262892889011688283e-4933, 0x8000, 0x20000000L, 0x00000000L) /* -min_value / 4 */
#define SUBNORM2_P HEXCONSTE(+7.29039906376494920506e-4951, 0x0000, 0x00000000L, 0x00000002L) /* subnorm_value * 2 */
#define SUBNORM2_M HEXCONSTE(-7.29039906376494920506e-4951, 0x8000, 0x00000000L, 0x00000002L) /* -subnorm_value * 2 */
#else
#define MIN_HALF_P HEXCONSTE(+1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L) /* min_value / 2 */
#define MIN_HALF_M HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L) /* -min_value / 2 */
#define MIN_P_2    HEXCONSTE(+3.36205184148942639058e-4932, 0x0000, 0x7fff8000L, 0x00000000L) /* min_value * 0x0.ffffp0 */
#define MIN_M_2    HEXCONSTE(-3.36205184148942639058e-4932, 0x8000, 0x7fff8000L, 0x00000000L) /* -min_value * 0x0.ffffp0 */
#define MIN_P_15   HEXCONSTE(+5.04315471466814025939e-4932, 0x0001, 0xc0000000L, 0x00000000L) /* min_value * 1.5 */
#define MIN_M_15   HEXCONSTE(-5.04315471466814025939e-4932, 0x8001, 0xc0000000L, 0x00000000L) /* -min_value * 1.5 */
#define MIN_P_125  HEXCONSTE(+4.20262892889011688283e-4932, 0x0001, 0xa0000000L, 0x00000000L) /* min_value * 1.25 */
#define MIN_M_125  HEXCONSTE(-4.20262892889011688283e-4932, 0x8001, 0xa0000000L, 0x00000000L) /* -min_value * 1.25 */
#define MIN_4TH_P  HEXCONSTE(+8.40525785778023376566e-4933, 0x0000, 0x20000000L, 0x00000000L) /* min_value / 4 */
#define MIN_4TH_M  HEXCONSTE(-8.40525785778023376566e-4933, 0x8000, 0x20000000L, 0x00000000L) /* -min_value / 4 */
#define SUBNORM2_P HEXCONSTE(+7.29039906376494920506e-4951, 0x0000, 0x00000000L, 0x00000002L) /* subnorm_value * 2 */
#define SUBNORM2_M HEXCONSTE(-7.29039906376494920506e-4951, 0x8000, 0x00000000L, 0x00000002L) /* -subnorm_value * 2 */
#endif

#define plus_uflow ZERO_P
#define minus_uflow ZERO_M
#define plus_oflow INF_P
#define minus_oflow INF_M


static test_fl_f_data const scalbln_data[] = {
	{ __LINE__, ZERO_P, 0, ZERO_P, 0 },
	{ __LINE__, ZERO_M, 0, ZERO_M, FLAG_FAIL_ARANYM2 },
	
	{ __LINE__, INF_P, 1, INF_P, FLAG_XFAIL_LINUX },
	{ __LINE__, INF_M, 1, INF_M, FLAG_XFAIL_LINUX },
	{ __LINE__, QNAN_P, 1, QNAN_P, 0 },
	{ __LINE__, QNAN_M, 1, QNAN_P, 0 },
	{ __LINE__, SNAN_P, 1, QNAN_P, 0 },
	{ __LINE__, SNAN_M, 1, QNAN_P, 0 },
	
	{ __LINE__, HEXCONSTE(0.8L, 0x3ffe, 0xccccccccL, 0xcccccccdL), 4, HEXCONSTE(12.8L, 0x4002, 0xccccccccL, 0xcccccccdL), 0 },
	{ __LINE__, HEXCONSTE(-0.854375L, 0xbffe, 0xdab851ebL, 0x851eb852L), 5, HEXCONSTE(-27.34L, 0xc003, 0xdab851ebL, 0x851eb852L), 0 },
	
	{ __LINE__, ONE_P, 0, ONE_P, 0 },
	
#ifdef TEST_LDOUBLE
	{ __LINE__, MIN_HALF_P, 0, MIN_HALF_P, 0 },
	{ __LINE__, MIN_HALF_M, 0, MIN_HALF_M, 0 },
	{ __LINE__, MIN_HALF_P, 1, MIN_P, FLAG_MINVAL|FLAG_SUBNORM },
	{ __LINE__, MIN_HALF_M, 1, MIN_M, FLAG_MINVAL|FLAG_SUBNORM },
	{ __LINE__, MIN_P_2, 0, MIN_P_2, 0 },
	{ __LINE__, MIN_M_2, 0, MIN_M_2, 0 },
	{ __LINE__, SUBNORM_P, 0, SUBNORM_P, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, 0, SUBNORM_M, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_P, LDBL_MANT_DIG - 1, MIN_P, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, LDBL_MANT_DIG - 1, MIN_M, FLAG_SUBNORM },
#endif
	
#ifdef TEST_LDOUBLE
	{ __LINE__, MIN_P, -LDBL_MANT_DIG + 1, SUBNORM_P, FLAG_SUBNORM },
	{ __LINE__, MIN_M, -LDBL_MANT_DIG + 1, SUBNORM_M, FLAG_SUBNORM },
	{ __LINE__, MIN_P, -LDBL_MANT_DIG, plus_uflow, FLAG_MINVAL|FLAG_SUBNORM },
	{ __LINE__, MIN_M, -LDBL_MANT_DIG, minus_uflow, FLAG_MINVAL|FLAG_SUBNORM },
	{ __LINE__, MIN_P, -LDBL_MANT_DIG - 1, plus_uflow, FLAG_MINVAL|FLAG_SUBNORM },
	{ __LINE__, MIN_M, -LDBL_MANT_DIG - 1, minus_uflow, FLAG_MINVAL|FLAG_SUBNORM },
	{ __LINE__, MIN_P_15, -LDBL_MANT_DIG + 1, SUBNORM2_P, FLAG_SUBNORM },
	{ __LINE__, MIN_M_15, -LDBL_MANT_DIG + 1, SUBNORM2_M, FLAG_MINVAL|FLAG_SUBNORM },
	{ __LINE__, MIN_P_15, -LDBL_MANT_DIG, SUBNORM_P, FLAG_SUBNORM },
	{ __LINE__, MIN_M_15, -LDBL_MANT_DIG, SUBNORM_M, FLAG_SUBNORM },
	{ __LINE__, MIN_P_15, -LDBL_MANT_DIG - 1, plus_uflow, 0 },
	{ __LINE__, MIN_M_15, -LDBL_MANT_DIG - 1, minus_uflow, 0 },
	{ __LINE__, MIN_P_125, -LDBL_MANT_DIG + 1, SUBNORM_P, FLAG_SUBNORM }, /* works in STonX, but fails in ARAnyM */
	{ __LINE__, MIN_M_125, -LDBL_MANT_DIG + 1, SUBNORM_M, FLAG_XFAIL_LINUX|FLAG_SUBNORM },
	{ __LINE__, MIN_P_125, -LDBL_MANT_DIG, SUBNORM_P, FLAG_XFAIL_LINUX|FLAG_SUBNORM },
	{ __LINE__, MIN_M_125, -LDBL_MANT_DIG, SUBNORM_M, FLAG_SUBNORM }, /* works in STonX, but fails in ARAnyM */
	{ __LINE__, MIN_P_125, -LDBL_MANT_DIG - 1, plus_uflow, 0 },
	{ __LINE__, MIN_M_125, -LDBL_MANT_DIG - 1, minus_uflow, 0 },
#endif
	
	{ __LINE__, ONE_P, INT_MAX, plus_oflow, FLAG_FAIL_ARANYM }, /* glibc returns nan */
	{ __LINE__, ONE_P, INT_MIN, plus_uflow, 0 },
	{ __LINE__, MAX_P, INT_MAX, plus_oflow, 0 },
	{ __LINE__, MAX_P, INT_MIN, plus_uflow, 0 },
	{ __LINE__, MIN_P, INT_MAX, plus_oflow, 0 },
	{ __LINE__, MIN_P, INT_MIN, plus_uflow, 0 },
#ifdef TEST_LDOUBLE
	{ __LINE__, MIN_4TH_P, INT_MAX, plus_oflow, 0 },
	{ __LINE__, MIN_4TH_P, INT_MIN, plus_uflow, 0 },
	{ __LINE__, SUBNORM_P, INT_MAX, plus_oflow, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_P, INT_MIN, plus_uflow, FLAG_SUBNORM },
#endif
	
	{ __LINE__, ONE_M, INT_MAX, minus_oflow, FLAG_FAIL_ARANYM }, /* glibc returns nan */
	{ __LINE__, ONE_M, INT_MIN, minus_uflow, FLAG_IGNORE_ZEROSIGN },
#ifdef TEST_LDOUBLE
	{ __LINE__, MAX_M, INT_MAX, minus_oflow, 0 },
	{ __LINE__, MAX_M, INT_MIN, minus_uflow, 0 },
	{ __LINE__, MIN_M, INT_MAX, minus_oflow, 0 },
	{ __LINE__, MIN_M, INT_MIN, minus_uflow, 0 },
	{ __LINE__, MIN_4TH_M, INT_MAX, minus_oflow, 0 },
	{ __LINE__, MIN_4TH_M, INT_MIN, minus_uflow, FLAG_XFAIL_LINUX|FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, INT_MAX, minus_oflow, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, INT_MIN, minus_uflow, FLAG_SUBNORM },
#endif

	{ __LINE__, ONE_P, LONG_MAX, plus_oflow, FLAG_FAIL_ARANYM }, /* glibc returns nan */
	{ __LINE__, ONE_P, LONG_MIN, plus_uflow, 0 },
	{ __LINE__, MAX_P, LONG_MAX, plus_oflow, 0 },
	{ __LINE__, MAX_P, LONG_MIN, plus_uflow, 0 },
	{ __LINE__, MIN_P, LONG_MAX, plus_oflow, 0 },
	{ __LINE__, MIN_P, LONG_MIN, plus_uflow, 0 },
#ifdef TEST_LDOUBLE
	{ __LINE__, MIN_4TH_P, LONG_MAX, plus_oflow, 0 },
	{ __LINE__, MIN_4TH_P, LONG_MIN, plus_uflow, 0 },
	{ __LINE__, SUBNORM_P, LONG_MAX, plus_oflow, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_P, LONG_MIN, plus_uflow, FLAG_SUBNORM },
#endif
	
	{ __LINE__, ONE_M, LONG_MAX, minus_oflow, FLAG_FAIL_ARANYM }, /* glibc returns nan */
	{ __LINE__, ONE_M, LONG_MIN, minus_uflow, FLAG_IGNORE_ZEROSIGN },
#ifdef TEST_LDOUBLE
	{ __LINE__, MAX_M, LONG_MAX, minus_oflow, 0 },
	{ __LINE__, MAX_M, LONG_MIN, minus_uflow, 0 },
	{ __LINE__, MIN_M, LONG_MAX, minus_oflow, 0 },
	{ __LINE__, MIN_M, LONG_MIN, minus_uflow, 0 },
	{ __LINE__, MIN_4TH_M, LONG_MAX, minus_oflow, 0 },
	{ __LINE__, MIN_4TH_M, LONG_MIN, minus_uflow, FLAG_XFAIL_LINUX|FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, LONG_MAX, minus_oflow, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, LONG_MIN, minus_uflow, FLAG_SUBNORM },
#endif

	{ __LINE__, ONE_P, 0, ONE_P, 0 },
	{ __LINE__, ONE_M, 0, ONE_M, 0 },

	{ __LINE__, HEXCONSTE(5.0, 0x4001, 0xa0000000L, 0x00000000L), 1, HEXCONSTE(10.0, 0x4002, 0xa0000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(5.0, 0x4001, 0xa0000000L, 0x00000000L), -1, HEXCONSTE(2.5, 0x4000, 0xa0000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE("0x1p16382", 0x7ffd, 0x80000000L, 0x0L), 1, HEXCONSTE("0x1p16383", 0x7ffe, 0x80000000L, 0x0L), 0 },
	{ __LINE__, HEXCONSTE("0x1p16383", 0x7ffe, 0x80000000L, 0x0L), 1, INF_P, 0 },
};

int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_fl_f(scalbln_data, ARRAY_SIZE(scalbln_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

#else

int main(void)
{
	return 77;
}

#endif

```

`tests/scbn.c`:

```c
#include "testconfig.h"
#define TEST_FUNC_FI_F __MATH_PRECNAME(scalbn)
#include "testdriver.h"

#define ONE_P HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L)
#define ONE_M HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L)


#if __LDBL_MIN_EXP__ <= (-16382)
#define MIN_HALF_P HEXCONSTE(+8.40525785778023376566e-4933, 0x0000, 0x40000000L, 0x00000000L) /* min_value / 2 */
#define MIN_HALF_M HEXCONSTE(-8.40525785778023376566e-4933, 0x8000, 0x40000000L, 0x00000000L) /* -min_value / 2 */
#define MIN_P_2    HEXCONSTE(+3.36205184148942639058e-4932, 0x0000, 0x7fff8000L, 0x00000000L) /* min_value * 0x0.ffffp0 */
#define MIN_M_2    HEXCONSTE(-3.36205184148942639058e-4932, 0x8000, 0x7fff8000L, 0x00000000L) /* -min_value * 0x0.ffffp0 */
#define MIN_P_15   HEXCONSTE(+2.52157735733407012970e-4932, 0x0000, 0xc0000000L, 0x00000000L) /* min_value * 1.5 */
#define MIN_M_15   HEXCONSTE(-2.52157735733407012970e-4932, 0x8000, 0xc0000000L, 0x00000000L) /* -min_value * 1.5 */
#define MIN_P_125  HEXCONSTE(+2.10131446444505844141e-4932, 0x0000, 0xa0000000L, 0x00000000L) /* min_value * 1.25 */
#define MIN_M_125  HEXCONSTE(-2.10131446444505844141e-4932, 0x8000, 0xa0000000L, 0x00000000L) /* -min_value * 1.25 */
#define MIN_4TH_P  HEXCONSTE(+4.20262892889011688283e-4933, 0x0000, 0x20000000L, 0x00000000L) /* min_value / 4 */
#define MIN_4TH_M  HEXCONSTE(-4.20262892889011688283e-4933, 0x8000, 0x20000000L, 0x00000000L) /* -min_value / 4 */
#define SUBNORM2_P HEXCONSTE(+7.29039906376494920506e-4951, 0x0000, 0x00000000L, 0x00000002L) /* subnorm_value * 2 */
#define SUBNORM2_M HEXCONSTE(-7.29039906376494920506e-4951, 0x8000, 0x00000000L, 0x00000002L) /* -subnorm_value * 2 */
#else
#define MIN_HALF_P HEXCONSTE(+1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L) /* min_value / 2 */
#define MIN_HALF_M HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L) /* -min_value / 2 */
#define MIN_P_2    HEXCONSTE(+3.36205184148942639058e-4932, 0x0000, 0x7fff8000L, 0x00000000L) /* min_value * 0x0.ffffp0 */
#define MIN_M_2    HEXCONSTE(-3.36205184148942639058e-4932, 0x8000, 0x7fff8000L, 0x00000000L) /* -min_value * 0x0.ffffp0 */
#define MIN_P_15   HEXCONSTE(+5.04315471466814025939e-4932, 0x0001, 0xc0000000L, 0x00000000L) /* min_value * 1.5 */
#define MIN_M_15   HEXCONSTE(-5.04315471466814025939e-4932, 0x8001, 0xc0000000L, 0x00000000L) /* -min_value * 1.5 */
#define MIN_P_125  HEXCONSTE(+4.20262892889011688283e-4932, 0x0001, 0xa0000000L, 0x00000000L) /* min_value * 1.25 */
#define MIN_M_125  HEXCONSTE(-4.20262892889011688283e-4932, 0x8001, 0xa0000000L, 0x00000000L) /* -min_value * 1.25 */
#define MIN_4TH_P  HEXCONSTE(+8.40525785778023376566e-4933, 0x0000, 0x20000000L, 0x00000000L) /* min_value / 4 */
#define MIN_4TH_M  HEXCONSTE(-8.40525785778023376566e-4933, 0x8000, 0x20000000L, 0x00000000L) /* -min_value / 4 */
#define SUBNORM2_P HEXCONSTE(+7.29039906376494920506e-4951, 0x0000, 0x00000000L, 0x00000002L) /* subnorm_value * 2 */
#define SUBNORM2_M HEXCONSTE(-7.29039906376494920506e-4951, 0x8000, 0x00000000L, 0x00000002L) /* -subnorm_value * 2 */
#endif

#define plus_uflow ZERO_P
#define minus_uflow ZERO_M
#define plus_oflow INF_P
#define minus_oflow INF_M


static test_fi_f_data const scalbn_data[] = {
	{ __LINE__, ZERO_P, 0, ZERO_P, 0 },
	{ __LINE__, ZERO_M, 0, ZERO_M, FLAG_FAIL_ARANYM2 },
	
	{ __LINE__, INF_P, 1, INF_P, FLAG_XFAIL_LINUX },
	{ __LINE__, INF_M, 1, INF_M, FLAG_XFAIL_LINUX },
	{ __LINE__, QNAN_P, 1, QNAN_P, 0 },
	{ __LINE__, QNAN_M, 1, QNAN_P, 0 },
	{ __LINE__, SNAN_P, 1, QNAN_P, 0 },
	{ __LINE__, SNAN_M, 1, QNAN_P, 0 },
	
	{ __LINE__, HEXCONSTE(0.8L, 0x3ffe, 0xccccccccL, 0xcccccccdL), 4, HEXCONSTE(12.8L, 0x4002, 0xccccccccL, 0xcccccccdL), 0 },
	{ __LINE__, HEXCONSTE(-0.854375L, 0xbffe, 0xdab851ebL, 0x851eb852L), 5, HEXCONSTE(-27.34L, 0xc003, 0xdab851ebL, 0x851eb852L), 0 },
	
	{ __LINE__, ONE_P, 0, ONE_P, 0 },
	
#ifdef TEST_LDOUBLE
	{ __LINE__, MIN_HALF_P, 0, MIN_HALF_P, 0 },
	{ __LINE__, MIN_HALF_M, 0, MIN_HALF_M, 0 },
	{ __LINE__, MIN_HALF_P, 1, MIN_P, FLAG_MINVAL|FLAG_SUBNORM },
	{ __LINE__, MIN_HALF_M, 1, MIN_M, FLAG_MINVAL|FLAG_SUBNORM },
	{ __LINE__, MIN_P_2, 0, MIN_P_2, 0 },
	{ __LINE__, MIN_M_2, 0, MIN_M_2, 0 },
	{ __LINE__, SUBNORM_P, 0, SUBNORM_P, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, 0, SUBNORM_M, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_P, LDBL_MANT_DIG - 1, MIN_P, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, LDBL_MANT_DIG - 1, MIN_M, FLAG_SUBNORM },
#endif
	
#ifdef TEST_LDOUBLE
	{ __LINE__, MIN_P, -LDBL_MANT_DIG + 1, SUBNORM_P, FLAG_SUBNORM },
	{ __LINE__, MIN_M, -LDBL_MANT_DIG + 1, SUBNORM_M, FLAG_SUBNORM },
	{ __LINE__, MIN_P, -LDBL_MANT_DIG, plus_uflow, FLAG_MINVAL|FLAG_SUBNORM },
	{ __LINE__, MIN_M, -LDBL_MANT_DIG, minus_uflow, FLAG_MINVAL|FLAG_SUBNORM },
	{ __LINE__, MIN_P, -LDBL_MANT_DIG - 1, plus_uflow, FLAG_MINVAL|FLAG_SUBNORM },
	{ __LINE__, MIN_M, -LDBL_MANT_DIG - 1, minus_uflow, FLAG_MINVAL|FLAG_SUBNORM },
	{ __LINE__, MIN_P_15, -LDBL_MANT_DIG + 1, SUBNORM2_P, FLAG_SUBNORM },
	{ __LINE__, MIN_M_15, -LDBL_MANT_DIG + 1, SUBNORM2_M, FLAG_MINVAL|FLAG_SUBNORM },
	{ __LINE__, MIN_P_15, -LDBL_MANT_DIG, SUBNORM_P, FLAG_SUBNORM },
	{ __LINE__, MIN_M_15, -LDBL_MANT_DIG, SUBNORM_M, FLAG_SUBNORM },
	{ __LINE__, MIN_P_15, -LDBL_MANT_DIG - 1, plus_uflow, 0 },
	{ __LINE__, MIN_M_15, -LDBL_MANT_DIG - 1, minus_uflow, 0 },
	{ __LINE__, MIN_P_125, -LDBL_MANT_DIG + 1, SUBNORM_P, FLAG_SUBNORM }, /* works in STonX, but fails in ARAnyM */
	{ __LINE__, MIN_M_125, -LDBL_MANT_DIG + 1, SUBNORM_M, FLAG_XFAIL_LINUX|FLAG_SUBNORM },
	{ __LINE__, MIN_P_125, -LDBL_MANT_DIG, SUBNORM_P, FLAG_XFAIL_LINUX|FLAG_SUBNORM },
	{ __LINE__, MIN_M_125, -LDBL_MANT_DIG, SUBNORM_M, FLAG_SUBNORM }, /* works in STonX, but fails in ARAnyM */
	{ __LINE__, MIN_P_125, -LDBL_MANT_DIG - 1, plus_uflow, 0 },
	{ __LINE__, MIN_M_125, -LDBL_MANT_DIG - 1, minus_uflow, 0 },
#endif
	
	{ __LINE__, ONE_P, INT_MAX, plus_oflow, FLAG_FAIL_ARANYM }, /* glibc returns nan */
	{ __LINE__, ONE_P, INT_MIN, plus_uflow, 0 },
	{ __LINE__, MAX_P, INT_MAX, plus_oflow, 0 },
	{ __LINE__, MAX_P, INT_MIN, plus_uflow, 0 },
	{ __LINE__, MIN_P, INT_MAX, plus_oflow, 0 },
	{ __LINE__, MIN_P, INT_MIN, plus_uflow, 0 },
#ifdef TEST_LDOUBLE
	{ __LINE__, MIN_4TH_P, INT_MAX, plus_oflow, 0 },
	{ __LINE__, MIN_4TH_P, INT_MIN, plus_uflow, 0 },
	{ __LINE__, SUBNORM_P, INT_MAX, plus_oflow, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_P, INT_MIN, plus_uflow, FLAG_SUBNORM },
#endif
	
	{ __LINE__, ONE_M, INT_MAX, minus_oflow, FLAG_FAIL_ARANYM }, /* glibc returns nan */
	{ __LINE__, ONE_M, INT_MIN, minus_uflow, FLAG_FAIL_SOFTFLOAT|FLAG_FAIL_ARANYM2 },
#ifdef TEST_LDOUBLE
	{ __LINE__, MAX_M, INT_MAX, minus_oflow, 0 },
	{ __LINE__, MAX_M, INT_MIN, minus_uflow, 0 },
	{ __LINE__, MIN_M, INT_MAX, minus_oflow, 0 },
	{ __LINE__, MIN_M, INT_MIN, minus_uflow, 0 },
	{ __LINE__, MIN_4TH_M, INT_MAX, minus_oflow, 0 },
	{ __LINE__, MIN_4TH_M, INT_MIN, minus_uflow, FLAG_XFAIL_LINUX|FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, INT_MAX, minus_oflow, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, INT_MIN, minus_uflow, FLAG_SUBNORM },
#endif

	{ __LINE__, ONE_P, 0, ONE_P, 0 },
	{ __LINE__, ONE_M, 0, ONE_M, 0 },

	{ __LINE__, HEXCONSTE(5.0, 0x4001, 0xa0000000L, 0x00000000L), 1, HEXCONSTE(10.0, 0x4002, 0xa0000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(5.0, 0x4001, 0xa0000000L, 0x00000000L), -1, HEXCONSTE(2.5, 0x4000, 0xa0000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE("0x1p16382", 0x7ffd, 0x80000000L, 0x0L), 1, HEXCONSTE("0x1p16383", 0x7ffe, 0x80000000L, 0x0L), 0 },
	{ __LINE__, HEXCONSTE("0x1p16383", 0x7ffe, 0x80000000L, 0x0L), 1, INF_P, 0 },
};

int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_fi_f(scalbn_data, ARRAY_SIZE(scalbn_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

```

`tests/signb.c`:

```c
#include "testconfig.h"
#if defined(HAVE_SIGNBIT) || defined(HAVE___SIGNBIT)
/* FIXME: that use in the function from mintlib */
#if defined(HAVE___SIGNBIT) && 0
int __MATH_PRECNAME(__signbit)(REAL x);
#define TEST_FUNC_F_I __MATH_PRECNAME(__signbit)
#else
/* FIXME: not declared */
#undef signbit
int __MATH_PRECNAME(signbit)(REAL x);
#define TEST_FUNC_F_I __MATH_PRECNAME(signbit)
#endif
#define INT_IS_BOOL
#include "testdriver.h"

/* make sure we don't test the builtin */
#undef signbit
#undef __signbit

static test_f_i_data const signbit_data[] = {
	{ __LINE__, ZERO_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, ZERO_M, 1, NO_INEXACT_EXCEPTION|FLAG_FAIL_ARANYM2 },
	{ __LINE__, SUBNORM_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, SUBNORM_M, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, INF_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, INF_M, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, QNAN_M, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, SNAN_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, SNAN_M, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, MAX_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, MAX_M, 1, NO_INEXACT_EXCEPTION },
	{ __LINE__, MIN_P, 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, MIN_M, 1, NO_INEXACT_EXCEPTION },

	{ __LINE__, HEXCONSTE(10, 0x4002, 0xa0000000L, 0x00000000L), 0, NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-10, 0xc002, 0xa0000000L, 0x00000000L), 1, NO_INEXACT_EXCEPTION },

	/* signbit (x) != 0 for x < 0.	*/
	{ __LINE__, HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), 1, NO_INEXACT_EXCEPTION },
	/* signbit (x) == 0 for x >= 0.  */
	{ __LINE__, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), 0, NO_INEXACT_EXCEPTION },
};

int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_f_i(signbit_data, ARRAY_SIZE(signbit_data), __FILE__);
	(void)check_fp;
		
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

#else

int main(void)
{
	return 77;
}

#endif

```

`tests/signi.c`:

```c
#include "testconfig.h"
#ifdef HAVE_SIGNIFICAND
#define TEST_FUNC_F_F __MATH_PRECNAME(wrap_significand)
static REAL TEST_FUNC_F_F(REAL x)
{
	return __MATH_PRECNAME(significand)(x);
}
#include "testdriver.h"



static test_f_f_data const significand_data[] = {
	{ __LINE__, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_P, 0 },
	{ __LINE__, SNAN_P, QNAN_P, 0 },
	{ __LINE__, SNAN_M, QNAN_P, 0 },
	{ __LINE__, INF_P, INF_P, FLAG_FAIL_SOFTFLOAT|FLAG_XFAIL },
	{ __LINE__, INF_M, INF_M, FLAG_FAIL_SOFTFLOAT|FLAG_XFAIL },
	{ __LINE__, ZERO_P, ZERO_P, 0 },
	{ __LINE__, ZERO_M, ZERO_M, FLAG_FAIL_ARANYM2 },
	{ __LINE__, SUBNORM_P, ZERO_P, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, ZERO_M, FLAG_SUBNORM },
	{ __LINE__, MIN_P, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, MIN_M, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, MAX_P, HEXCONSTE(1.9999999999999999998916e+00, 0x3fff, 0xffffffffL, 0xffffffffL), 0 },
	{ __LINE__, MAX_M, HEXCONSTE(-1.9999999999999999998916e+00, 0xbfff, 0xffffffffL, 0xffffffffL), 0 },

	{ __LINE__, HEXCONSTE(4.0, 0x4001, 0x80000000L, 0x00000000L), HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(6.0, 0x4001, 0xc0000000L, 0x00000000L), HEXCONSTE(1.5, 0x3fff, 0xc0000000L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(8.0, 0x4002, 0x80000000L, 0x00000000L), HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(0.4, 0x3ffd, 0xccccccccL, 0xcccccccdL), HEXCONSTE(1.6, 0x3fff, 0xccccccccL, 0xcccccccdL), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(0.6, 0x3ffe, 0x99999999L, 0x9999999aL), HEXCONSTE(1.2, 0x3fff, 0x99999999L, 0x9999999aL), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(0.8, 0x3ffe, 0xccccccccL, 0xcccccccdL), HEXCONSTE(1.6, 0x3fff, 0xccccccccL, 0xcccccccdL), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(0.0004, 0x3ff3, 0xd1b71758L, 0xe219652cL), HEXCONSTE(1.6384, 0x3fff, 0xd1b71758L, 0xe219652cL), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(0.0006, 0x3ff4, 0x9d495182L, 0xa9930be1L), HEXCONSTE(1.2288, 0x3fff, 0x9d495182L, 0xa9930be1L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(0.0008, 0x3ff4, 0xd1b71758L, 0xe219652cL), HEXCONSTE(1.6384, 0x3fff, 0xd1b71758L, 0xe219652cL), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-4.0, 0xc001, 0x80000000L, 0x00000000L), HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-6.0, 0xc001, 0xc0000000L, 0x00000000L), HEXCONSTE(-1.5, 0xbfff, 0xc0000000L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-8.0, 0xc002, 0x80000000L, 0x00000000L), HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-0.4, 0xbffd, 0xccccccccL, 0xcccccccdL), HEXCONSTE(-1.6, 0xbfff, 0xccccccccL, 0xcccccccdL), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-0.6, 0xbffe, 0x99999999L, 0x9999999aL), HEXCONSTE(-1.2, 0xbfff, 0x99999999L, 0x9999999aL), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-0.8, 0xbffe, 0xccccccccL, 0xcccccccdL), HEXCONSTE(-1.6, 0xbfff, 0xccccccccL, 0xcccccccdL), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-0.0004, 0xbff3, 0xd1b71758L, 0xe219652cL), HEXCONSTE(-1.6384, 0xbfff, 0xd1b71758L, 0xe219652cL), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-0.0006, 0xbff4, 0x9d495182L, 0xa9930be1L), HEXCONSTE(-1.2288, 0xbfff, 0x9d495182L, 0xa9930be1L), NO_INEXACT_EXCEPTION },
	{ __LINE__, HEXCONSTE(-0.0008, 0xbff4, 0xd1b71758L, 0xe219652cL), HEXCONSTE(-1.6384, 0xbfff, 0xd1b71758L, 0xe219652cL), NO_INEXACT_EXCEPTION },
};


int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_f_f(significand_data, ARRAY_SIZE(significand_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

#else

int main(void)
{
	return 77;
}

#endif

```

`tests/sin.c`:

```c
#include "testconfig.h"
#define TEST_FUNC_F_F __MATH_PRECNAME(sin)
#include "testdriver.h"



static test_f_f_data const fsin_data[] = {
	{ __LINE__, ZERO_P, ZERO_P, 0 },
	{ __LINE__, ZERO_M, ZERO_M, FLAG_FAIL_ARANYM2 },
	{ __LINE__, INF_P, QNAN_P, 0 },
	{ __LINE__, INF_M, QNAN_P, 0 },
	{ __LINE__, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_P, 0 },
	{ __LINE__, SNAN_P, QNAN_P, 0 },
	{ __LINE__, SNAN_M, QNAN_P, 0 },

	{ __LINE__, HEXCONSTE(5.23598790168762207031e-01, 0x3ffe, 0x860a9200L, 0x00000000L), HEXCONSTE(5.00000012618391339030e-01, 0x3ffe, 0x80000036L, 0x32116885L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(5.23598730564117431641e-01, 0x3ffe, 0x860a9100L, 0x00000000L), HEXCONSTE(4.99999960999254326060e-01, 0x3ffd, 0xfffffeb0L, 0xfc740a1aL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(5.23598775598298926681e-01, 0x3ffe, 0x860a91c1L, 0x6b9b3000L), HEXCONSTE(5.00000000000000046404e-01, 0x3ffe, 0x80000000L, 0x00000358L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(5.23598775598298815659e-01, 0x3ffe, 0x860a91c1L, 0x6b9b2800L), HEXCONSTE(4.99999999999999950262e-01, 0x3ffd, 0xffffffffL, 0xfffff8d5L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(5.23598775598298873122e-01, 0x3ffe, 0x860a91c1L, 0x6b9b2c24L), HEXCONSTE(5.00000000000000000054e-01, 0x3ffe, 0x80000000L, 0x00000001L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(5.23598775598298873067e-01, 0x3ffe, 0x860a91c1L, 0x6b9b2c23L), HEXCONSTE(5.00000000000000000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-5.23598730564117431641e-01, 0xbffe, 0x860a9100L, 0x00000000L), HEXCONSTE(-4.99999960999254326060e-01, 0xbffd, 0xfffffeb0L, 0xfc740a1aL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-5.23598790168762207031e-01, 0xbffe, 0x860a9200L, 0x00000000L), HEXCONSTE(-5.00000012618391339030e-01, 0xbffe, 0x80000036L, 0x32116885L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-5.23598775598298815659e-01, 0xbffe, 0x860a91c1L, 0x6b9b2800L), HEXCONSTE(-4.99999999999999950262e-01, 0xbffd, 0xffffffffL, 0xfffff8d5L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-5.23598775598298926681e-01, 0xbffe, 0x860a91c1L, 0x6b9b3000L), HEXCONSTE(-5.00000000000000046404e-01, 0xbffe, 0x80000000L, 0x00000358L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-5.23598775598298873067e-01, 0xbffe, 0x860a91c1L, 0x6b9b2c23L), HEXCONSTE(-5.00000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-5.23598775598298873122e-01, 0xbffe, 0x860a91c1L, 0x6b9b2c24L), HEXCONSTE(-5.00000000000000000054e-01, 0xbffe, 0x80000000L, 0x00000001L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(1.57079637050628662109e+00, 0x3fff, 0xc90fdb00L, 0x00000000L), HEXCONSTE(9.99999999999999044655e-01, 0x3ffe, 0xffffffffL, 0xffffbb29L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.57079625129699707031e+00, 0x3fff, 0xc90fda00L, 0x00000000L), HEXCONSTE(9.99999999999997150012e-01, 0x3ffe, 0xffffffffL, 0xffff32a3L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.57079632679489678004e+00, 0x3fff, 0xc90fdaa2L, 0x2168c800L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.57079632679489655800e+00, 0x3fff, 0xc90fdaa2L, 0x2168c000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.57079632679489661915e+00, 0x3fff, 0xc90fdaa2L, 0x2168c234L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.57079637050628662109e+00, 0xbfff, 0xc90fdb00L, 0x00000000L), HEXCONSTE(-9.99999999999999044655e-01, 0xbffe, 0xffffffffL, 0xffffbb29L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-1.57079625129699707031e+00, 0xbfff, 0xc90fda00L, 0x00000000L), HEXCONSTE(-9.99999999999997150012e-01, 0xbffe, 0xffffffffL, 0xffff32a3L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-1.57079632679489678004e+00, 0xbfff, 0xc90fdaa2L, 0x2168c800L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.57079632679489655800e+00, 0xbfff, 0xc90fdaa2L, 0x2168c000L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.57079632679489661915e+00, 0xbfff, 0xc90fdaa2L, 0x2168c234L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.14159274101257324219e+00, 0x4000, 0xc90fdb00L, 0x00000000L), HEXCONSTE(-8.74227800037247452581e-08, 0xbfe7, 0xbbbd2e7bL, 0x96762febL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(3.14159250259399414062e+00, 0x4000, 0xc90fda00L, 0x00000000L), HEXCONSTE(1.50995799097837069610e-07, 0x3fe8, 0xa22168c2L, 0x34c418f9L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(3.14159265358979356009e+00, 0x4000, 0xc90fdaa2L, 0x2168c800L), HEXCONSTE(-3.21624529935327298437e-16, 0xbfcb, 0xb9676733L, 0xae8fe47cL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(3.14159265358979311600e+00, 0x4000, 0xc90fdaa2L, 0x2168c000L), HEXCONSTE(1.22464679914735317720e-16, 0x3fca, 0x8d313198L, 0xa2e03707L), FLAG_INEXACT4 },
#if 0
	{ __LINE__, HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), HEXCONSTE(-5.01655761266833202345e-20, 0xbfbf, 0x80000000L, 0x00000000L), FLAG_INEXACT4|FLAG_FAIL_X87 }, /* bfbe:ece675d1:fc8f8cbb */
#endif
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(3.14159265358979323830e+00, 0x4000, 0xc90fdaa2L, 0x2168c234L), HEXCONSTE(1.66674858370417566564e-19, 0x3fc0, 0xc4c6628bL, 0x80dc1cd1L), FLAG_INEXACT4 },
#endif
	{ __LINE__, HEXCONSTE(-3.14159274101257324219e+00, 0xc000, 0xc90fdb00L, 0x00000000L), HEXCONSTE(8.74227800037247452581e-08, 0x3fe7, 0xbbbd2e7bL, 0x96762febL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(-3.14159250259399414062e+00, 0xc000, 0xc90fda00L, 0x00000000L), HEXCONSTE(-1.50995799097837069610e-07, 0xbfe8, 0xa22168c2L, 0x34c418f9L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(-3.14159265358979356009e+00, 0xc000, 0xc90fdaa2L, 0x2168c800L), HEXCONSTE(3.21624529935327298437e-16, 0x3fcb, 0xb9676733L, 0xae8fe47cL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(-3.14159265358979311600e+00, 0xc000, 0xc90fdaa2L, 0x2168c000L), HEXCONSTE(-1.22464679914735317720e-16, 0xbfca, 0x8d313198L, 0xa2e03707L), FLAG_INEXACT4 },
#if 0
	{ __LINE__, HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), HEXCONSTE(5.01655761266833202345e-20, 0x3fbf, 0x80000000L, 0x00000000L), FLAG_INEXACT4|FLAG_FAIL_X87 }, /* 3fbe:ece675d1:fc8f8cbb */
#endif
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(-3.14159265358979323830e+00, 0xc000, 0xc90fdaa2L, 0x2168c234L), HEXCONSTE(-1.66674858370417566564e-19, 0xbfc0, 0xc4c6628bL, 0x80dc1cd1L), FLAG_INEXACT4 },
#endif
	{ __LINE__, HEXCONSTE(7.50000000000000000000e-01, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(6.81638760023334166756e-01, 0x3ffe, 0xae7fe0b5L, 0xfc786b2eL), FLAG_INEXACT2 },
#if 0
	{ __LINE__, HEXCONSTE(3.68934881474191032320e+19, 0x4040, 0x80000000L, 0x00000000L), HEXCONSTE(-4.71838762123546738049e-02, 0x3ff3, 0x9b17d865L, 0xe6dd4a05L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* bffa:c143e153:b0701e80 */
	{ __LINE__, HEXCONSTE(-3.68934881474191032320e+19, 0xc040, 0x80000000L, 0x00000000L), HEXCONSTE(4.71838762123546738049e-02, 0xbff3, 0x9b17d865L, 0xe6dd4a05L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* 3ffa:c143e153:b0701e80 */
	{ __LINE__, HEXCONSTE(1.51822828163721243443e+31, 0x4066, 0xbfa09a00L, 0x00000000L), HEXCONSTE(-6.67032293297886570718e-08, 0xbffe, 0xffa337baL, 0x41245dcfL), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* bfe7:8f3e7cf6:0848b612 */
#endif
#ifdef TEST_DOUBLE
	{ __LINE__, HEXCONSTE(8.01901280879974365234e-01, 0x3ffe, 0xcd496700L, 0x00000000L), HEXCONSTE(7.18679428673139419556e-01, 0x3ffe, 0xb7fb6002L, 0x75877a60L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(8.01901221275329589844e-01, 0x3ffe, 0xcd496600L, 0x00000000L), HEXCONSTE(7.18679387227551729931e-01, 0x3ffe, 0xb7fb5f50L, 0x739fa5f9L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(8.01901271840588458772e-01, 0x3ffe, 0xcd4966d9L, 0x2d171000L), HEXCONSTE(7.18679422387678733231e-01, 0x3ffe, 0xb7fb5fe7L, 0x769793e6L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(8.01901271840588347750e-01, 0x3ffe, 0xcd4966d9L, 0x2d170800L), HEXCONSTE(7.18679422387678656036e-01, 0x3ffe, 0xb7fb5fe7L, 0x76978e56L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(8.01901271840588350027e-01, 0x3ffe, 0xcd4966d9L, 0x2d17082aL), HEXCONSTE(7.18679422387678657662e-01, 0x3ffe, 0xb7fb5fe7L, 0x76978e74L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(8.01901271840588349973e-01, 0x3ffe, 0xcd4966d9L, 0x2d170829L), HEXCONSTE(7.18679422387678657608e-01, 0x3ffe, 0xb7fb5fe7L, 0x76978e73L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.52246409654617309570e-01, 0x3ffd, 0x81267100L, 0x00000000L), HEXCONSTE(2.49579907398498439944e-01, 0x3ffc, 0xff91e010L, 0x0fa01e33L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(2.52246379852294921875e-01, 0x3ffd, 0x81267000L, 0x00000000L), HEXCONSTE(2.49579878539294072628e-01, 0x3ffc, 0xff91de20L, 0x43809bf8L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(2.52246400000000037256e-01, 0x3ffd, 0x812670adL, 0x1145a800L), HEXCONSTE(2.49579898049409177639e-01, 0x3ffc, 0xff91df6fL, 0x71e56373L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(2.52246399999999981745e-01, 0x3ffd, 0x812670adL, 0x1145a000L), HEXCONSTE(2.49579898049409123890e-01, 0x3ffc, 0xff91df6fL, 0x71e553f5L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(2.52246400000000000014e-01, 0x3ffd, 0x812670adL, 0x1145a2a2L), HEXCONSTE(2.49579898049409141576e-01, 0x3ffc, 0xff91df6fL, 0x71e5590eL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(2.52246399999999999986e-01, 0x3ffd, 0x812670adL, 0x1145a2a1L), HEXCONSTE(2.49579898049409141549e-01, 0x3ffc, 0xff91df6fL, 0x71e5590cL), FLAG_INEXACT3 },
#endif
#if 0
	{ __LINE__, HEXCONSTE(1.00000009040962152038e+22, 0x4048, 0x87867900L, 0x00000000L), HEXCONSTE(-3.00169493130367990501e-01, 0x3ff6, 0xbe835a6eL, 0x2c556b4eL), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* bffd:99afd0d8:80ef7e1c */
	{ __LINE__, HEXCONSTE(9.99999977819630836122e+21, 0x4048, 0x87867800L, 0x00000000L), HEXCONSTE(-7.34081535296101525979e-01, 0xbffd, 0xfcdcce9aL, 0x988c4f93L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* bffe:bbecc47a:b1b8c708 */
#endif
#ifndef TEST_FLOAT
#if 0
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+22, 0x4048, 0x87867832L, 0x6eac9000L), HEXCONSTE(-8.52200849767188801768e-01, 0xbffe, 0xa755cb95L, 0x96c75048L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* bffe:da29d5bb:5f9cb87d */
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-5.21876523333658540562e-01, 0x3ffe, 0xf3e8111bL, 0x794ca429L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* bffe:8599b328:44aba907 */
	{ __LINE__, HEXCONSTE(8.98846567431157953865e+307, 0x43fe, 0x80000000L, 0x00000000L), HEXCONSTE(5.63127779850884013443e-01, 0xbffe, 0xec660098L, 0xb6d15fecL), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* 3ffe:90292465:edbaff2d */
#endif
#endif
#if 0
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-5.21876523333658540562e-01, 0x3ffe, 0xf3e8111bL, 0x794ca429L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* bffe:8599b328:44aba907 */
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(4.96195478918406179070e-03, 0xbffe, 0xcbafef50L, 0x1d8a7cb4L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* 3ff7:a297e4c5:9a74b5b1 */
#endif
#if defined(TEST_LDOUBLE) && LDBL_MAX_EXP >= 16384
	{ __LINE__, HEXCONSTE(5.94865747678615882543e+4931, 0x7ffe, 0x80000000L, 0x00000000L), HEXCONSTE(3.89362998589420812698e-01, 0xbffe, 0xfab8efb2L, 0x149f3907L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* 3ffd:c75a9642:6d98d104 */
#endif
#if 0
	{ __LINE__, HEXCONSTE(1.32922799578491587290e+36, 0x4077, 0x80000000L, 0x00000000L), HEXCONSTE(3.77820109360752022661e-01, 0xbffe, 0xebcdeef4L, 0xbae324c6L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* 3ffd:c171a32a:f37e5b6c */
	{ __LINE__, HEXCONSTE(1.70141183460469231732e+38, 0x407e, 0x80000000L, 0x00000000L), HEXCONSTE(6.23385512955870240359e-01, 0xbffe, 0xcb5f91faL, 0xbda011daL), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* 3ffe:9f963166:f215eb89 */
	{ __LINE__, HEXCONSTE(3.40282285791300048857e+38, 0x407e, 0xfffffc00L, 0x00000000L), HEXCONSTE(4.85786063130487339716e-02, 0x3ffd, 0xe31da09cL, 0xa53611daL), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* 3ffa:c6fa5c56:65984d89 */
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-5.21876523333658540562e-01, 0x3ffe, 0xf3e8111bL, 0x794ca429L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* bffe:8599b328:44aba907 */
#endif
	{ __LINE__, HEXCONSTE(1.12589990684262400000e+15, 0x4031, 0x80000000L, 0x00000000L), HEXCONSTE(4.96396515208940840872e-01, 0x3ffd, 0xfe27d956L, 0x1866fd92L), FLAG_INEXACT4 }, /* 3ffd:fe27af1d:576ed715 */
	{ __LINE__, HEXCONSTE(2.68435456000000000000e+08, 0x401b, 0x80000000L, 0x00000000L), HEXCONSTE(-9.86198211836975655704e-01, 0xbffe, 0xfc777c6bL, 0x36b76bafL), FLAG_INEXACT4 }, /* bffe:fc777c6b:36a750a6 */
	{ __LINE__, HEXCONSTE(9.33405876159667968750e-01, 0x3ffe, 0xeef3b000L, 0x00000000L), HEXCONSTE(8.03651436066817327598e-01, 0x3ffe, 0xcdbc19bbL, 0x4a58a819L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(9.33405816555023193359e-01, 0x3ffe, 0xeef3af00L, 0x00000000L), HEXCONSTE(8.03651400596073800205e-01, 0x3ffe, 0xcdbc1922L, 0xf1d9f2c7L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(9.33405822926488437652e-01, 0x3ffe, 0xeef3af1bL, 0x5d800800L), HEXCONSTE(8.03651404387734979464e-01, 0x3ffe, 0xcdbc1933L, 0x3ad3b0c3L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(9.33405822926488326630e-01, 0x3ffe, 0xeef3af1bL, 0x5d800000L), HEXCONSTE(8.03651404387734913382e-01, 0x3ffe, 0xcdbc1933L, 0x3ad3ac00L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(9.33405822926488326684e-01, 0x3ffe, 0xeef3af1bL, 0x5d800001L), HEXCONSTE(8.03651404387734913436e-01, 0x3ffe, 0xcdbc1933L, 0x3ad3ac01L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(2.33284330368041992188e+00, 0x4000, 0x954d4e00L, 0x00000000L), HEXCONSTE(7.23424286879281333931e-01, 0x3ffe, 0xb9325585L, 0x4754a36dL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.33284306526184082031e+00, 0x4000, 0x954d4d00L, 0x00000000L), HEXCONSTE(7.23424451484335489777e-01, 0x3ffe, 0xb9325848L, 0x40806c61L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.33284326807709163631e+00, 0x4000, 0x954d4dd9L, 0xc56e8000L), HEXCONSTE(7.23424311459951285830e-01, 0x3ffe, 0xb93255eeL, 0xda102400L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.33284326807709119223e+00, 0x4000, 0x954d4dd9L, 0xc56e7800L), HEXCONSTE(7.23424311459951592442e-01, 0x3ffe, 0xb93255eeL, 0xda103a18L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.33284326807709163610e+00, 0x4000, 0x954d4dd9L, 0xc56e7fffL), HEXCONSTE(7.23424311459951285992e-01, 0x3ffe, 0xb93255eeL, 0xda102403L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(3.74394798278808593750e+00, 0x4000, 0xef9cd800L, 0x00000000L), HEXCONSTE(-5.66584842472178015803e-01, 0xbffe, 0x910bb448L, 0xd3cb0167L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(3.74394774436950683594e+00, 0x4000, 0xef9cd700L, 0x00000000L), HEXCONSTE(-5.66584646014440218922e-01, 0xbffe, 0x910bb0fdL, 0x0c39d5a0L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(3.74394775036364535481e+00, 0x4000, 0xef9cd706L, 0x6fa80000L), HEXCONSTE(-5.66584650953631585590e-01, 0xbffe, 0x910bb112L, 0x42ec9c00L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(3.74394775036364491072e+00, 0x4000, 0xef9cd706L, 0x6fa7f800L), HEXCONSTE(-5.66584650953631219672e-01, 0xbffe, 0x910bb112L, 0x42ec81a2L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(3.74394775036364535459e+00, 0x4000, 0xef9cd706L, 0x6fa7ffffL), HEXCONSTE(-5.66584650953631585428e-01, 0xbffe, 0x910bb112L, 0x42ec9bfdL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(3.92251610755920410156e+00, 0x4000, 0xfb0a8100L, 0x00000000L), HEXCONSTE(-7.03935615168888099676e-01, 0xbffe, 0xb4351fddL, 0xa3d81514L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(3.92251586914062500000e+00, 0x4000, 0xfb0a8000L, 0x00000000L), HEXCONSTE(-7.03935445828784776888e-01, 0xbffe, 0xb4351d06L, 0x546e7181L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(3.92251600697924418526e+00, 0x4000, 0xfb0a8094L, 0x00ca8800L), HEXCONSTE(-7.03935543730581130364e-01, 0xbffe, 0xb4351eaaL, 0xd0984abaL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(3.92251600697924374117e+00, 0x4000, 0xfb0a8094L, 0x00ca8000L), HEXCONSTE(-7.03935543730580814969e-01, 0xbffe, 0xb4351eaaL, 0xd0983400L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(3.92251600697924374139e+00, 0x4000, 0xfb0a8094L, 0x00ca8001L), HEXCONSTE(-7.03935543730580815132e-01, 0xbffe, 0xb4351eaaL, 0xd0983403L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(4.07116556167602539062e+00, 0x4001, 0x8246fd00L, 0x00000000L), HEXCONSTE(-8.01364537721184272607e-01, 0xbffe, 0xcd2639f1L, 0xafc7f46aL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(4.07116508483886718750e+00, 0x4001, 0x8246fc00L, 0x00000000L), HEXCONSTE(-8.01364252488409439356e-01, 0xbffe, 0xcd263528L, 0x9f074d2bL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(4.07116516399312988739e+00, 0x4001, 0x8246fc2aL, 0x7ee10800L), HEXCONSTE(-8.01364299836640624002e-01, 0xbffe, 0xcd2635f3L, 0xfaf59249L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(4.07116516399312899921e+00, 0x4001, 0x8246fc2aL, 0x7ee10000L), HEXCONSTE(-8.01364299836640092689e-01, 0xbffe, 0xcd2635f3L, 0xfaf56c00L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(4.07116516399312899964e+00, 0x4001, 0x8246fc2aL, 0x7ee10001L), HEXCONSTE(-8.01364299836640092960e-01, 0xbffe, 0xcd2635f3L, 0xfaf56c05L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(4.78584384918212890625e+00, 0x4001, 0x9925a200L, 0x00000000L), HEXCONSTE(-9.97303403935616231829e-01, 0xbffe, 0xff4f46a0L, 0x17cb8840L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(4.78584337234497070312e+00, 0x4001, 0x9925a100L, 0x00000000L), HEXCONSTE(-9.97303438930024413814e-01, 0xbffe, 0xff4f4736L, 0x648dc2a0L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(4.78584384785421068642e+00, 0x4001, 0x9925a1ffL, 0x497e0800L), HEXCONSTE(-9.97303404033070596611e-01, 0xbffe, 0xff4f46a0L, 0x82f27f4eL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(4.78584384785420979824e+00, 0x4001, 0x9925a1ffL, 0x497e0000L), HEXCONSTE(-9.97303404033070661772e-01, 0xbffe, 0xff4f46a0L, 0x82f28400L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(4.78584384785420979868e+00, 0x4001, 0x9925a1ffL, 0x497e0001L), HEXCONSTE(-9.97303404033070661717e-01, 0xbffe, 0xff4f46a0L, 0x82f283ffL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(5.98407697677612304688e+00, 0x4001, 0xbf7d8f00L, 0x00000000L), HEXCONSTE(-2.94668244792096755335e-01, 0xbffd, 0x96dec195L, 0x1a82a178L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(5.98407649993896484375e+00, 0x4001, 0xbf7d8e00L, 0x00000000L), HEXCONSTE(-2.94668700457468382117e-01, 0xbffd, 0x96ded0dfL, 0x3d425d1eL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(5.98407676625780116098e+00, 0x4001, 0xbf7d8e8eL, 0xfa950800L), HEXCONSTE(-2.94668445963317716132e-01, 0xbffd, 0x96dec855L, 0x26b419afL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(5.98407676625780027280e+00, 0x4001, 0xbf7d8e8eL, 0xfa950000L), HEXCONSTE(-2.94668445963318564873e-01, 0xbffd, 0x96dec855L, 0x26b49400L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(5.98407676625780027323e+00, 0x4001, 0xbf7d8e8eL, 0xfa950001L), HEXCONSTE(-2.94668445963318564466e-01, 0xbffd, 0x96dec855L, 0x26b493f1L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(8.41470984807896506665e-01, 0x3ffe, 0xd76aa478L, 0x48677021L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(9.09297426825681695377e-01, 0x3ffe, 0xe8c7b756L, 0x8da22efdL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(3.00000000000000000000e+00, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(1.41120008059867222102e-01, 0x3ffc, 0x9081c36dL, 0xb6aada79L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(4.00000000000000000000e+00, 0x4001, 0x80000000L, 0x00000000L), HEXCONSTE(-7.56802495307928251348e-01, 0xbffe, 0xc1bdceeeL, 0xe0f57386L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(5.00000000000000000000e+00, 0x4001, 0xa0000000L, 0x00000000L), HEXCONSTE(-9.58924274663138468875e-01, 0xbffe, 0xf57c0fafL, 0x04c99913L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(6.00000000000000000000e+00, 0x4001, 0xc0000000L, 0x00000000L), HEXCONSTE(-2.79415498198925872810e-01, 0xbffd, 0x8f0f8c55L, 0x851601d3L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.00000000000000000000e+00, 0x4001, 0xe0000000L, 0x00000000L), HEXCONSTE(6.56986598718789090406e-01, 0x3ffe, 0xa8304613L, 0x6850421eL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(8.00000000000000000000e+00, 0x4002, 0x80000000L, 0x00000000L), HEXCONSTE(9.89358246623381777825e-01, 0x3ffe, 0xfd469501L, 0x467bd750L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(9.00000000000000000000e+00, 0x4002, 0x90000000L, 0x00000000L), HEXCONSTE(4.12118485241756569759e-01, 0x3ffd, 0xd30131b0L, 0x617c8491L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+01, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(-5.44021110889369813378e-01, 0xbffe, 0x8b44f7afL, 0x9a7a92ceL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(4.83192217600000000000e+09, 0x401f, 0x9000a400L, 0x00000000L), HEXCONSTE(-3.34317677937172457288e-01, 0xbffd, 0xab2bafcaL, 0x6117fc42L), FLAG_INEXACT4 }, /* bffd:ab2bafca:6dfc6bdb */
	{ __LINE__, HEXCONSTE(4.83192166400000000000e+09, 0x401f, 0x9000a300L, 0x00000000L), HEXCONSTE(2.58315989272713190142e-01, 0x3ffd, 0x8441fe4b, 0xde66f073L), FLAG_INEXACT4 }, /* 3ffd:8441fe4b:eb9e0549 */
	{ __LINE__, HEXCONSTE(4.83192181546018028259e+09, 0x401f, 0x9000a34bL, 0xbae73000L), HEXCONSTE(-3.91677716048526663436e-01, 0xbffd, 0xc889fb4aL, 0x0cca17a3L), FLAG_INEXACT4 }, /* bffd:c889fb4a:0033f3eb */
#if 0
	{ __LINE__, HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(5.21876523333658540562e-01, 0xbffe, 0xf3e8111bL, 0x794ca429L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* 3ffe:8599b328:44aba907 */
	{ __LINE__, HEXCONSTE(-3.64229140925048708372e+307, 0xc3fc, 0xcf78c83dL, 0xafa1f800L), HEXCONSTE(-9.92195624918954397636e-01, 0x3ffd, 0xb9899a90L, 0x322e15a0L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* bffe:fe008850:42dd770d */
	{ __LINE__, HEXCONSTE(7.59194657019045731761e+34, 0x4072, 0xe9f1e600L, 0x00000000L), HEXCONSTE(7.79108221354363387633e-01, 0x3ffe, 0xb022a84fL, 0x76653b3cL), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* 3ffe:c773a2ea:c3000ddf */
	{ __LINE__, HEXCONSTE(7.59194607501444160346e+34, 0x4072, 0xe9f1e500L, 0x00000000L), HEXCONSTE(4.66512683316143507688e-01, 0x3ffe, 0xea5cd76fL, 0x02f8721eL), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* 3ffd:eedac01c:062a4370 */
	{ __LINE__, HEXCONSTE(7.59194643911056501837e+34, 0x4072, 0xe9f1e5bcL, 0x3bb88000L), HEXCONSTE(9.92187350026198468548e-01, 0xbffe, 0xc17ebb77L, 0xe04d1035L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* 3ffe:fdfffd7b:de0fb4ec */
	{ __LINE__, HEXCONSTE(1.31933767361251141222e+21, 0x4045, 0x8f0afa00L, 0x00000000L), HEXCONSTE(-1.24929881576082082729e-01, 0xbffe, 0xf7d9ca6bL, 0x4cf46ea2L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* bffb:ffdb3cdd:4ca5bb0c */
#endif
	{ __LINE__, HEXCONSTE(6.15815448760986328125e+00, 0x4001, 0xc50f9a00L, 0x00000000L), HEXCONSTE(-1.24705312431196324671e-01, 0xbffb, 0xff657fb4L, 0x3c508673L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(6.15815401077270507812e+00, 0x4001, 0xc50f9900L, 0x00000000L), HEXCONSTE(-1.24705785546065730596e-01, 0xbffb, 0xff65bf34L, 0x56b74e20L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(6.15815403791391346999e+00, 0x4001, 0xc50f990eL, 0x92426000L), HEXCONSTE(-1.24705758616727947154e-01, 0xbffb, 0xff65bb97L, 0x0dc18073L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(6.15815403791391258181e+00, 0x4001, 0xc50f990eL, 0x92425800L), HEXCONSTE(-1.24705758616728828401e-01, 0xbffb, 0xff65bb97L, 0x0dc37c74L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(6.15815403791391312478e+00, 0x4001, 0xc50f990eL, 0x92425ce4L), HEXCONSTE(-1.24705758616728289667e-01, 0xbffb, 0xff65bb97L, 0x0dc245e5L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-1.01128077507019042969e+00, 0xbfff, 0x8171a600L, 0x00000000L), HEXCONSTE(-8.47512343819588481741e-01, 0xbffe, 0xd8f691a7L, 0xa9542600L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.55009582519531250000e+02, 0x4006, 0xff027400L, 0x00000000L), HEXCONSTE(-5.14631300183308550763e-01, 0xbffe, 0x83bee07bL, 0xc9076425L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(3.01631975173950195312e+00, 0x4000, 0xc10b6200L, 0x00000000L), HEXCONSTE(1.24945501318506756680e-01, 0x3ffb, 0xffe36d4fL, 0x8fff6c4bL), FLAG_INEXACT3 },
#if 0
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-5.21876523333658540562e-01, 0x3ffe, 0xf3e8111bL, 0x794ca429L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* bffe:8599b328:44aba907 */
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(4.96195478918406179070e-03, 0xbffe, 0xcbafef50L, 0x1d8a7cb4L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* 3ff7:a297e4c5:9a74b5b1 */
#endif
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, MAX_P, HEXCONSTE(9.92151099123526495965e-01, 0xbffb, 0xd5533512L, 0x6b40ccd2L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* 3ffe:fdfd9d4b:6d0e5f7c */
	{ __LINE__, MAX_M, HEXCONSTE(-9.92151099123526495965e-01, 0x3ffb, 0xd5533512L, 0x6b40ccd2L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* bffe:fdfd9d4b:6d0e5f7c */
	{ __LINE__, HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(5.21876523333658540562e-01, 0xbffe, 0xf3e8111bL, 0x794ca429L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* 3ffe:8599b328:44aba907 */
	{ __LINE__, HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-4.96195478918406179070e-03, 0x3ffe, 0xcbafef50L, 0x1d8a7cb4L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* bff7:a297e4c5:9a74b5b1 */
#endif
	{ __LINE__, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), 0 },
#if defined(TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16381)
	{ __LINE__, HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), 0 },
#endif
#if defined(TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), 0 },
#if defined(TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16381)
	{ __LINE__, HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), 0 },
#endif
#if defined(TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), 0 },
#if defined(TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16381)
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), 0 },
	{ __LINE__, HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), 0 },
#endif
	{ __LINE__, SUBNORM_P, SUBNORM_P, FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, SUBNORM_M, SUBNORM_M, FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(1.51742398738861083984e+00, 0x3fff, 0xc23af300L, 0x00000000L), HEXCONSTE(9.98576034767698972555e-01, 0x3ffe, 0xffa2add3L, 0xe58948d1L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.51742386817932128906e+00, 0x3fff, 0xc23af200L, 0x00000000L), HEXCONSTE(9.98576028408233484540e-01, 0x3ffe, 0xffa2adb8L, 0x953ae262L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.51742396872239759809e+00, 0x3fff, 0xc23af2d7L, 0xea240800L), HEXCONSTE(9.98576033771912254552e-01, 0x3ffe, 0xffa2adcfL, 0x9ea83dbeL), FLAG_INEXACT },

	{ __LINE__, HEXCONSTE(5.00e-11, 0x3fdc, 0xdbe6feceL, 0xbdedd5bfL), HEXCONSTE(5.000000000000000000e-11, 0x3fdc, 0xdbe6feceL, 0xbdedd5bfL), 0 },
	{ __LINE__, HEXCONSTE(0.25, 0x3ffd, 0x80000000L, 0x00000000L), HEXCONSTE(0.24740395925452292959684870484938920, 0x3ffc, 0xfd5776a7L, 0x98abb5d4L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(0.5, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(0.47942553860420300027328793521557139, 0x3ffd, 0xf57743a2L, 0x582f7f44L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(0.78539816339744830961556084581987572, 0x3ffe, 0xc90fdaa2L, 0x2168c235L), HEXCONSTE(0.70710678118654752440084436210484903, 0x3ffe, 0xb504f333L, 0xf9de6484L), 0 },
	{ __LINE__, HEXCONSTE(-0.7853981633974483096155608458198757, 0xbffe, 0xc90fdaa2L, 0x2168c235L), HEXCONSTE(-0.7071067811865475244008443621048490, 0xbffe, 0xb504f333L, 0xf9de6484L), 0 },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.84147098480789650665250232163029900, 0x3ffe, 0xd76aa478L, 0x48677021L), 0 },
	{ __LINE__, HEXCONSTE(2.00e00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(9.092974268256816953e-01, 0x3ffe, 0xe8c7b756L, 0x8da22efcL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.50e00, 0x4000, 0xa0000000L, 0x00000000L), HEXCONSTE(5.984721441039564939e-01, 0x3ffe, 0x9935786eL, 0x7e558403L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.50e00, 0x4000, 0xe0000000L, 0x00000000L), HEXCONSTE(-3.507832276896198480e-01, 0xbffd, 0xb399dbf5L, 0xd310f9aaL), 0 },
	{ __LINE__, HEXCONSTE(4.00e00, 0x4001, 0x80000000L, 0x00000000L), HEXCONSTE(-7.568024953079282514e-01, 0xbffe, 0xc1bdceeeL, 0xe0f57387L), 0 },
	{ __LINE__, HEXCONSTE(5.00e00, 0x4001, 0xa0000000L, 0x00000000L), HEXCONSTE(-9.589242746631384689e-01, 0xbffe, 0xf57c0fafL, 0x04c99913L), 0 },
	{ __LINE__, HEXCONSTE(6.00e00, 0x4001, 0xc0000000L, 0x00000000L), HEXCONSTE(-2.794154981989258727e-01, 0xbffd, 0x8f0f8c55L, 0x851601cfL), 0 },
	{ __LINE__, HEXCONSTE(7.50e00, 0x4001, 0xf0000000L, 0x00000000L), HEXCONSTE(9.379999767747388579e-01, 0x3ffe, 0xf020c437L, 0xe5717d2aL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(8.00e00, 0x4002, 0x80000000L, 0x00000000L), HEXCONSTE(9.893582466233817778e-01, 0x3ffe, 0xfd469501L, 0x467bd750L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.00e00, 0x4002, 0x90000000L, 0x00000000L), HEXCONSTE(4.121184852417565697e-01, 0x3ffd, 0xd30131b0L, 0x617c848fL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.50e00, 0x4002, 0x98000000L, 0x00000000L), HEXCONSTE(-7.515112046180930728e-02, 0xbffb, 0x99e8d4a5L, 0x213bd3a7L), 0 },
	{ __LINE__, HEXCONSTE(-5.00e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(-4.794255386042030000e-01, 0xbffd, 0xf57743a2L, 0x582f7f3aL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.00e00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-8.414709848078965066e-01, 0xbffe, 0xd76aa478L, 0x48677020L), 0 },
	{ __LINE__, HEXCONSTE(-2.00e00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(-9.092974268256816953e-01, 0xbffe, 0xe8c7b756L, 0x8da22efcL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-2.50e00, 0xc000, 0xa0000000L, 0x00000000L), HEXCONSTE(-5.984721441039564939e-01, 0xbffe, 0x9935786eL, 0x7e558403L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-3.50e00, 0xc000, 0xe0000000L, 0x00000000L), HEXCONSTE(3.507832276896198480e-01, 0x3ffd, 0xb399dbf5L, 0xd310f9aaL), 0 },
	{ __LINE__, HEXCONSTE(-4.00e00, 0xc001, 0x80000000L, 0x00000000L), HEXCONSTE(7.568024953079282514e-01, 0x3ffe, 0xc1bdceeeL, 0xe0f57387L), 0 },
	{ __LINE__, HEXCONSTE(-5.00e00, 0xc001, 0xa0000000L, 0x00000000L), HEXCONSTE(9.589242746631384689e-01, 0x3ffe, 0xf57c0fafL, 0x04c99913L), 0 },
	{ __LINE__, HEXCONSTE(-5.50e00, 0xc001, 0xb0000000L, 0x00000000L), HEXCONSTE(7.055403255703919063e-01, 0x3ffe, 0xb49e4a70L, 0x5582b6b8L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-6.50e00, 0xc001, 0xd0000000L, 0x00000000L), HEXCONSTE(-2.151199880878155242e-01, 0xbffc, 0xdc486a06L, 0x3659e21fL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-7.50e00, 0xc001, 0xf0000000L, 0x00000000L), HEXCONSTE(-9.379999767747388579e-01, 0xbffe, 0xf020c437L, 0xe5717d2aL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-8.00e00, 0xc002, 0x80000000L, 0x00000000L), HEXCONSTE(-9.893582466233817778e-01, 0xbffe, 0xfd469501L, 0x467bd750L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-9.00e00, 0xc002, 0x90000000L, 0x00000000L), HEXCONSTE(-4.121184852417565697e-01, 0xbffd, 0xd30131b0L, 0x617c848fL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-9.50e00, 0xc002, 0x98000000L, 0x00000000L), HEXCONSTE(7.515112046180930728e-02, 0x3ffb, 0x99e8d4a5L, 0x213bd3a7L), FLAG_INEXACT },

	{ __LINE__, HEXCONSTE(.523598775598298873077107230546, 0x3ffe, 0x860a91c1L, 0x6b9b2c23L), HEXCONSTE(0.5, 0x3ffe, 0x80000000L, 0x00000000L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-.523598775598298873077107230546, 0xbffe, 0x860a91c1L, 0x6b9b2c23L), HEXCONSTE(-0.5, 0xbffe, 0x80000000L, 0x00000000L), FLAG_INEXACT },
	{ __LINE__, HEXCONST_PI_2, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONST_PI_2_M, HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.75L, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(0.681638760023334166733241952779893935L, 0x3ffe, 0xae7fe0b5L, 0xfc786b2eL), 0 },

#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(2.68435456000000000000e+08, 0x401b, 0x80000000L, 0x00000000L), HEXCONSTE(-9.86198211836975655703110310527108292055548e-01L, 0xbffe, 0xfc777c6bL, 0x36a750a6L), 0 },
#endif

	{ __LINE__, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.8414709848078965066525023216302989996226L, 0x3ffe, 0xd76aa478L, 0x48677021L), ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(2, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(0.9092974268256816953960198659117448427023L, 0x3ffe, 0xe8c7b756L, 0x8da22efdL), ROUND_TONEAREST|FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(0.1411200080598672221007448028081102798469L, 0x3ffc, 0x9081c36dL, 0xb6aada79L), ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(4, 0x4001, 0x80000000L, 0x00000000L), HEXCONSTE(-0.7568024953079282513726390945118290941359L, 0xbffe, 0xc1bdceeeL, 0xe0f57386L), ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(5, 0x4001, 0xa0000000L, 0x00000000L), HEXCONSTE(-0.9589242746631384688931544061559939733525L, 0xbffe, 0xf57c0fafL, 0x04c99913L), ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(6, 0x4001, 0xc0000000L, 0x00000000L), HEXCONSTE(-0.2794154981989258728115554466118947596280L, 0xbffd, 0x8f0f8c55L, 0x851601d3L), ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(7, 0x4001, 0xe0000000L, 0x00000000L), HEXCONSTE(0.6569865987187890903969990915936351779369L, 0x3ffe, 0xa8304613L, 0x6850421eL), ROUND_TONEAREST },
	{ __LINE__, HEXCONSTE(8, 0x4002, 0x80000000L, 0x00000000L), HEXCONSTE(0.9893582466233817778081235982452886721164L, 0x3ffe, 0xfd469501L, 0x467bd750L), ROUND_TONEAREST|FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9, 0x4002, 0x90000000L, 0x00000000L), HEXCONSTE(0.4121184852417565697562725663524351793439L, 0x3ffd, 0xd30131b0L, 0x617c8491L), ROUND_TONEAREST|FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(10, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(-0.5440211108893698134047476618513772816836L, 0xbffe, 0x8b44f7afL, 0x9a7a92ceL), ROUND_TONEAREST },

#if 0
	{ __LINE__, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.8414709848078965066525023216302989996226L, 0x3ffe, 0xd76aa478L, 0x48677021L), ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(2, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(0.9092974268256816953960198659117448427023L, 0x3ffe, 0xe8c7b756L, 0x8da22efdL), ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(3, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(0.1411200080598672221007448028081102798469L, 0x3ffc, 0x9081c36dL, 0xb6aada79L), ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(4, 0x4001, 0x80000000L, 0x00000000L), HEXCONSTE(-0.7568024953079282513726390945118290941359L, 0xbffe, 0xc1bdceeeL, 0xe0f57386L), ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(5, 0x4001, 0xa0000000L, 0x00000000L), HEXCONSTE(-0.9589242746631384688931544061559939733525L, 0xbffe, 0xf57c0fafL, 0x04c99913L), ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(6, 0x4001, 0xc0000000L, 0x00000000L), HEXCONSTE(-0.2794154981989258728115554466118947596280L, 0xbffd, 0x8f0f8c55L, 0x851601d3L), ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(7, 0x4001, 0xe0000000L, 0x00000000L), HEXCONSTE(0.6569865987187890903969990915936351779369L, 0x3ffe, 0xa8304613L, 0x6850421eL), ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(8, 0x4002, 0x80000000L, 0x00000000L), HEXCONSTE(0.9893582466233817778081235982452886721164L, 0x3ffe, 0xfd469501L, 0x467bd750L), ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(9, 0x4002, 0x90000000L, 0x00000000L), HEXCONSTE(0.4121184852417565697562725663524351793439L, 0x3ffd, 0xd30131b0L, 0x617c8491L), ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(10, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(-0.5440211108893698134047476618513772816836L, 0xbffe, 0x8b44f7afL, 0x9a7a92ceL), ROUND_TOWARDZERO },

	{ __LINE__, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.8414709848078965066525023216302989996226L, 0x3ffe, 0xd76aa478L, 0x48677021L), ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(2, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(0.9092974268256816953960198659117448427023L, 0x3ffe, 0xe8c7b756L, 0x8da22efdL), ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(3, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(0.1411200080598672221007448028081102798469L, 0x3ffc, 0x9081c36dL, 0xb6aada79L), ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(4, 0x4001, 0x80000000L, 0x00000000L), HEXCONSTE(-0.7568024953079282513726390945118290941359L, 0xbffe, 0xc1bdceeeL, 0xe0f57386L), ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(5, 0x4001, 0xa0000000L, 0x00000000L), HEXCONSTE(-0.9589242746631384688931544061559939733525L, 0xbffe, 0xf57c0fafL, 0x04c99913L), ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(6, 0x4001, 0xc0000000L, 0x00000000L), HEXCONSTE(-0.2794154981989258728115554466118947596280L, 0xbffd, 0x8f0f8c55L, 0x851601d3L), ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(7, 0x4001, 0xe0000000L, 0x00000000L), HEXCONSTE(0.6569865987187890903969990915936351779369L, 0x3ffe, 0xa8304613L, 0x6850421eL), ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(8, 0x4002, 0x80000000L, 0x00000000L), HEXCONSTE(0.9893582466233817778081235982452886721164L, 0x3ffe, 0xfd469501L, 0x467bd750L), ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(9, 0x4002, 0x90000000L, 0x00000000L), HEXCONSTE(0.4121184852417565697562725663524351793439L, 0x3ffd, 0xd30131b0L, 0x617c8491L), ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(10, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(-0.5440211108893698134047476618513772816836L, 0xbffe, 0x8b44f7afL, 0x9a7a92ceL), ROUND_DOWNWARD },

	{ __LINE__, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.8414709848078965066525023216302989996226L, 0x3ffe, 0xd76aa478L, 0x48677021L), ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(2, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(0.9092974268256816953960198659117448427023L, 0x3ffe, 0xe8c7b756L, 0x8da22efdL), ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(3, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(0.1411200080598672221007448028081102798469L, 0x3ffc, 0x9081c36dL, 0xb6aada79L), ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(4, 0x4001, 0x80000000L, 0x00000000L), HEXCONSTE(-0.7568024953079282513726390945118290941359L, 0xbffe, 0xc1bdceeeL, 0xe0f57386L), ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(5, 0x4001, 0xa0000000L, 0x00000000L), HEXCONSTE(-0.9589242746631384688931544061559939733525L, 0xbffe, 0xf57c0fafL, 0x04c99913L), ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(6, 0x4001, 0xc0000000L, 0x00000000L), HEXCONSTE(-0.2794154981989258728115554466118947596280L, 0xbffd, 0x8f0f8c55L, 0x851601d3L), ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(7, 0x4001, 0xe0000000L, 0x00000000L), HEXCONSTE(0.6569865987187890903969990915936351779369L, 0x3ffe, 0xa8304613L, 0x6850421eL), ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(8, 0x4002, 0x80000000L, 0x00000000L), HEXCONSTE(0.9893582466233817778081235982452886721164L, 0x3ffe, 0xfd469501L, 0x467bd750L), ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(9, 0x4002, 0x90000000L, 0x00000000L), HEXCONSTE(0.4121184852417565697562725663524351793439L, 0x3ffd, 0xd30131b0L, 0x617c8491L), ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(10, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(-0.5440211108893698134047476618513772816836L, 0xbffe, 0x8b44f7afL, 0x9a7a92ceL), ROUND_UPWARD },
#endif
};

int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_f_f(fsin_data, ARRAY_SIZE(fsin_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

```

`tests/sincos.c`:

```c
#include "testconfig.h"
#ifdef HAVE_SINCOS
#define TEST_FUNC_F_FF __MATH_PRECNAME(sincos)
#include "testdriver.h"



static test_f_ff_data const fsincos_data[] = {
	{ __LINE__, ZERO_P, ZERO_P, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, ZERO_M, ZERO_M, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), FLAG_IGNORE_ZEROSIGN },
	{ __LINE__, INF_P, QNAN_P, QNAN_P, 0 },
	{ __LINE__, INF_M, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_P, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_P, QNAN_P, 0 },
	{ __LINE__, SNAN_P, QNAN_P, QNAN_P, 0 },
	{ __LINE__, SNAN_M, QNAN_P, QNAN_P, 0 },

	{ __LINE__, HEXCONSTE(1.57079637050628662109e+00, 0x3fff, 0xc90fdb00L, 0x00000000L), HEXCONSTE(9.99999999999999044655e-01, 0x3ffe, 0xffffffffL, 0xffffbb29L), HEXCONSTE(-4.37113900018624143888e-08, 0xbfe6, 0xbbbd2e7bL, 0x96766267L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(1.57079625129699707031e+00, 0x3fff, 0xc90fda00L, 0x00000000L), HEXCONSTE(9.99999999999997150012e-01, 0x3ffe, 0xffffffffL, 0xffff32a3L), HEXCONSTE(7.54978995489187499690e-08, 0x3fe7, 0xa22168c2L, 0x34c49b08L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(1.57079632679489678004e+00, 0x3fff, 0xc90fdaa2L, 0x2168c800L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.60812264967663649219e-16, 0xbfca, 0xb9676733L, 0xae8fe47cL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(1.57079632679489655800e+00, 0x3fff, 0xc90fdaa2L, 0x2168c000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(6.12323399573676588601e-17, 0x3fc9, 0x8d313198L, 0xa2e03707L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-2.50827880633416601173e-20, 0xbfbe, 0x80000000L, 0x00000000L), FLAG_FAIL_X87 }, /* bfbd:ece675d1:fc8f8cbb */
	{ __LINE__, HEXCONSTE(1.57079632679489661915e+00, 0x3fff, 0xc90fdaa2L, 0x2168c234L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(6.1232339957367660358688e-17, 0x3fc9, 0x8d313198L, 0xa2e03800L), FLAG_INEXACT4 }, /* 3fbf:c4c6628b:80dc1cd1 */
	{ __LINE__, HEXCONSTE(5.23598790168762207031e-01, 0x3ffe, 0x860a9200L, 0x00000000L), HEXCONSTE(5.00000012618391339030e-01, 0x3ffe, 0x80000036L, 0x32116885L), HEXCONSTE(8.66025396499206887837e-01, 0x3ffe, 0xddb3d723L, 0x7832e30fL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(5.23598730564117431641e-01, 0x3ffe, 0x860a9100L, 0x00000000L), HEXCONSTE(4.99999960999254326060e-01, 0x3ffd, 0xfffffeb0L, 0xfc740a1aL), HEXCONSTE(8.66025426301528489324e-01, 0x3ffe, 0xddb3d7a3L, 0x7832aa68L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(5.23598775598298926681e-01, 0x3ffe, 0x860a91c1L, 0x6b9b3000L), HEXCONSTE(5.00000000000000046404e-01, 0x3ffe, 0x80000000L, 0x00000358L), HEXCONSTE(8.66025403784438619953e-01, 0x3ffe, 0xddb3d742L, 0xc26551afL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(5.23598775598298815659e-01, 0x3ffe, 0x860a91c1L, 0x6b9b2800L), HEXCONSTE(4.99999999999999950262e-01, 0x3ffd, 0xffffffffL, 0xfffff8d5L), HEXCONSTE(8.66025403784438675464e-01, 0x3ffe, 0xddb3d742L, 0xc26555afL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(5.23598775598298873122e-01, 0x3ffe, 0x860a91c1L, 0x6b9b2c24L), HEXCONSTE(5.00000000000000000054e-01, 0x3ffe, 0x80000000L, 0x00000001L), HEXCONSTE(8.66025403784438646733e-01, 0x3ffe, 0xddb3d742L, 0xc265539dL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(5.23598775598298873067e-01, 0x3ffe, 0x860a91c1L, 0x6b9b2c23L), HEXCONSTE(5.00000000000000000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(8.66025403784438646787e-01, 0x3ffe, 0xddb3d742L, 0xc265539eL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(1.04719758033752441406e+00, 0x3fff, 0x860a9200L, 0x00000000L), HEXCONSTE(8.66025418354901612989e-01, 0x3ffe, 0xddb3d781L, 0x56ca0cfbL), HEXCONSTE(4.99999974763217003483e-01, 0x3ffd, 0xffffff27L, 0x37ba3007L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(1.04719746112823486328e+00, 0x3fff, 0x860a9100L, 0x00000000L), HEXCONSTE(8.66025358750253692599e-01, 0x3ffe, 0xddb3d681L, 0x56c92a5cL), HEXCONSTE(5.00000078001488305771e-01, 0x3ffe, 0x8000014fL, 0x038b1ab1L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.04719755119659785336e+00, 0x3fff, 0x860a91c1L, 0x6b9b3000L), HEXCONSTE(8.66025403784438700346e-01, 0x3ffe, 0xddb3d742L, 0xc265577aL), HEXCONSTE(4.99999999999999907165e-01, 0x3ffd, 0xffffffffL, 0xfffff29fL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.04719755119659763132e+00, 0x3fff, 0x860a91c1L, 0x6b9b2800L), HEXCONSTE(8.66025403784438589324e-01, 0x3ffe, 0xddb3d742L, 0xc2654f7aL), HEXCONSTE(5.00000000000000099476e-01, 0x3ffe, 0x80000000L, 0x0000072bL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.04719755119659774624e+00, 0x3fff, 0x860a91c1L, 0x6b9b2c24L), HEXCONSTE(8.66025403784438646787e-01, 0x3ffe, 0xddb3d742L, 0xc265539eL), HEXCONSTE(4.99999999999999999919e-01, 0x3ffe, 0x80000000L, 0x00000033L), FLAG_INEXACT3 }, /* 3ffd:ffffffff:fffffffd */
	{ __LINE__, HEXCONSTE(1.04719755119659774613e+00, 0x3fff, 0x860a91c1L, 0x6b9b2c23L), HEXCONSTE(8.66025403784438646733e-01, 0x3ffe, 0xddb3d742L, 0xc265539dL), HEXCONSTE(5.00000000000000000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(3.14159274101257324219e+00, 0x4000, 0xc90fdb00L, 0x00000000L), HEXCONSTE(-8.74227800037247452581e-08, 0xbfe7, 0xbbbd2e7bL, 0x967fbcb0L), HEXCONSTE(-9.99999999999996178621e-01, 0xbffe, 0xffffffffL, 0xfffeeca4L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* bfe7:bbbd2e7b:96762feb */
	{ __LINE__, HEXCONSTE(3.14159250259399414062e+00, 0x4000, 0xc90fda00L, 0x00000000L), HEXCONSTE(1.50995799097837069610e-07, 0x3fe8, 0xa22168c2L, 0x34c418f9L), HEXCONSTE(-9.99999999999988600156e-01, 0xbffe, 0xffffffffL, 0xfffcca8eL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(3.14159265358979356009e+00, 0x4000, 0xc90fdaa2L, 0x2168c800L), HEXCONSTE(-3.21624529935327298437e-16, 0xbfcb, 0xb9680000L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), FLAG_INEXACT4 }, /* bfcb:b9676733:ae8fe47c */
	{ __LINE__, HEXCONSTE(3.14159265358979311600e+00, 0x4000, 0xc90fdaa2L, 0x2168c000L), HEXCONSTE(1.22464679914735317720e-16, 0x3fca, 0x8d300000L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), FLAG_INEXACT4 }, /* 3fca:8d313198:a2e03707 */
	{ __LINE__, HEXCONSTE(3.14159265358979323851e+00, 0x4000, 0xc90fdaa2L, 0x2168c235L), HEXCONSTE(-5.01655761266833202345e-20, 0xbfbf, 0x80000000L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), FLAG_INEXACT4|FLAG_FAIL_X87 }, /* bfbe:ece675d1:fc8f8cbb */
	{ __LINE__, HEXCONSTE(3.14159265358979323830e+00, 0x4000, 0xc90fdaa2L, 0x2168c234L), HEXCONSTE(1.2246467991473532071738e-16, 0x3fca, 0x8d313198L, 0xa2e03800L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), FLAG_INEXACT4 }, /* 3fc0:c4c6628b:80dc1cd1 */
	{ __LINE__, HEXCONSTE(-3.14159274101257324219e+00, 0xc000, 0xc90fdb00L, 0x00000000L), HEXCONSTE(8.74227800037247452581e-08, 0x3fe7, 0xbbbd2e7bL, 0x96762febL), HEXCONSTE(-9.99999999999996178621e-01, 0xbffe, 0xffffffffL, 0xfffeeca4L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(-3.14159250259399414062e+00, 0xc000, 0xc90fda00L, 0x00000000L), HEXCONSTE(-1.50995799097837069610e-07, 0xbfe8, 0xa22168c2L, 0x34c418f9L), HEXCONSTE(-9.99999999999988600156e-01, 0xbffe, 0xffffffffL, 0xfffcca8eL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(-3.14159265358979356009e+00, 0xc000, 0xc90fdaa2L, 0x2168c800L), HEXCONSTE(3.21624529935327298437e-16, 0x3fcb, 0xb9680000L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), FLAG_INEXACT4 }, /* 3fcb:b9676733:ae8fe47c */
	{ __LINE__, HEXCONSTE(-3.14159265358979311600e+00, 0xc000, 0xc90fdaa2L, 0x2168c000L), HEXCONSTE(-1.22464679914735317720e-16, 0xbfca, 0x8d300000L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), FLAG_INEXACT4 }, /* bfca:8d313198:a2e03707 */
	{ __LINE__, HEXCONSTE(-3.14159265358979323851e+00, 0xc000, 0xc90fdaa2L, 0x2168c235L), HEXCONSTE(5.01655761266833202345e-20, 0x3fbf, 0x80000000L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), FLAG_INEXACT4|FLAG_FAIL_X87 }, /* 3fbe:ece675d1:fc8f8cbb */
	{ __LINE__, HEXCONSTE(-3.14159265358979323830e+00, 0xc000, 0xc90fdaa2L, 0x2168c234L), HEXCONSTE(-1.2246467991473532071738e-16, 0xbfca, 0x8d313198L, 0xa2e03800L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), FLAG_INEXACT4 }, /* bfc0:c4c6628b:80dc1cd1 */
	{ __LINE__, HEXCONSTE(7.50000000000000000000e-01, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(6.81638760023334166756e-01, 0x3ffe, 0xae7fe0b5L, 0xfc786b2eL), HEXCONSTE(7.31688868873820886325e-01, 0x3ffe, 0xbb4ff632L, 0xa908f73fL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(3.68934881474191032320e+19, 0x4040, 0x80000000L, 0x00000000L), HEXCONSTE(-4.71838762123546738049e-02, 0x3ff3, 0x9b17d865L, 0xe6dd4a05L), HEXCONSTE(9.98886220660580136132e-01, 0x3ffe, 0xffffff44L, 0x143b3309L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* bffa:c143e153:b0701e80, 3ffe:ffb701e2:2987fbe7 */
	{ __LINE__, HEXCONSTE(-3.68934881474191032320e+19, 0xc040, 0x80000000L, 0x00000000L), HEXCONSTE(4.71838762123546738049e-02, 0xbff3, 0x9b17d865L, 0xe6dd4a05L), HEXCONSTE(9.98886220660580136132e-01, 0x3ffe, 0xffffff44L, 0x143b3309L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* 3ffa:c143e153:b0701e80, 3ffe:ffb701e2:2987fbe7 */
	{ __LINE__, HEXCONSTE(8.01901280879974365234e-01, 0x3ffe, 0xcd496700L, 0x00000000L), HEXCONSTE(7.18679428673139419556e-01, 0x3ffe, 0xb7fb6002L, 0x75877a60L), HEXCONSTE(6.95341555497763925725e-01, 0x3ffe, 0xb201e778L, 0x69a46ae2L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(8.01901221275329589844e-01, 0x3ffe, 0xcd496600L, 0x00000000L), HEXCONSTE(7.18679387227551729931e-01, 0x3ffe, 0xb7fb5f50L, 0x739fa5f9L), HEXCONSTE(6.95341598334394744017e-01, 0x3ffe, 0xb201e830L, 0x65041457L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(8.01901271840588458772e-01, 0x3ffe, 0xcd4966d9L, 0x2d171000L), HEXCONSTE(7.18679422387678733231e-01, 0x3ffe, 0xb7fb5fe7L, 0x769793e6L), HEXCONSTE(6.95341561994184596124e-01, 0x3ffe, 0xb201e794L, 0x50884640L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(8.01901271840588347750e-01, 0x3ffe, 0xcd4966d9L, 0x2d170800L), HEXCONSTE(7.18679422387678656036e-01, 0x3ffe, 0xb7fb5fe7L, 0x76978e56L), HEXCONSTE(6.95341561994184675921e-01, 0x3ffe, 0xb201e794L, 0x50884c00L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(8.01901271840588350027e-01, 0x3ffe, 0xcd4966d9L, 0x2d17082aL), HEXCONSTE(7.18679422387678657662e-01, 0x3ffe, 0xb7fb5fe7L, 0x76978e74L), HEXCONSTE(6.95341561994184674295e-01, 0x3ffe, 0xb201e794L, 0x50884be2L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(8.01901271840588349973e-01, 0x3ffe, 0xcd4966d9L, 0x2d170829L), HEXCONSTE(7.18679422387678657608e-01, 0x3ffe, 0xb7fb5fe7L, 0x76978e73L), HEXCONSTE(6.95341561994184674349e-01, 0x3ffe, 0xb201e794L, 0x50884be3L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.00000009040962152038e+22, 0x4048, 0x87867900L, 0x00000000L), HEXCONSTE(-3.00169493130367990501e-01, 0x3ff6, 0xbe835a6eL, 0x2c556b4eL), HEXCONSTE(9.53885881745745288040e-01, 0x3ffe, 0xffffb91cL, 0x575ebf69L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* bffd:99afd0d8:80ef7e1c, 3ffe:f431dd7a:36cf37de */
	{ __LINE__, HEXCONSTE(9.99999977819630836122e+21, 0x4048, 0x87867800L, 0x00000000L), HEXCONSTE(-7.34081535296101525979e-01, 0xbffd, 0xfcdcce9aL, 0x988c4f93L), HEXCONSTE(6.79061337095050972191e-01, 0x3ffe, 0xde99d0e1, 0xcd8755dbL), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* bffe:bbecc47a:b1b8c708, 3ffe:add6f6ba:cd20654c */
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+22, 0x4048, 0x87867832L, 0x6eac9000L), HEXCONSTE(-8.52200849767188801768e-01, 0xbffe, 0xa755cb95L, 0x96c75048L), HEXCONSTE(5.23214785395138945478e-01, 0x3ffe, 0xc1bd48bdL, 0x5cb29cccL), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* bffe:da29d5bb:5f9cb87d, 3ffe:85f16778:0e479c9a */
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-5.21876523333658540562e-01, 0x3ffe, 0xf3e8111bL, 0x794ca429L), HEXCONSTE(8.53021039830304158072e-01, 0xbffd, 0x9b81d0beL, 0xfeb2a614L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* bffe:8599b328:44aba907, 3ffe:da5f963c:defe6d53 */
	{ __LINE__, HEXCONSTE(8.98846567431157953865e+307, 0x43fe, 0x80000000L, 0x00000000L), HEXCONSTE(5.63127779850884013443e-01, 0xbffe, 0xec660098L, 0xb6d15fecL), HEXCONSTE(-8.26369834614147994497e-01, 0x3ffd, 0xc47ca4cbL, 0x9b2c544eL), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* 3ffe:90292465:edbaff2d, bffe:d38cf936:1195f50b */
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-5.21876523333658540562e-01, 0x3ffe, 0xf3e8111bL, 0x794ca429L), HEXCONSTE(8.53021039830304158072e-01, 0xbffd, 0x9b81d0beL, 0xfeb2a614L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* bffe:8599b328:44aba907, 3ffe:da5f963c:defe6d53 */
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(4.96195478918406179070e-03, 0xbffe, 0xcbafef50L, 0x1d8a7cb4L), HEXCONSTE(-9.99987689426559937453e-01, 0xbffe, 0x9b1294d0L, 0x9cf3e650L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* 3ff7:a297e4c5:9a74b5b1, bffe:ffff3176:7d5ba9e0 */
#ifdef TEST_LDOUBLE
	{ __LINE__, HEXCONSTE(5.94865747678615882543e+4931, 0x7ffe, 0x80000000L, 0x00000000L), HEXCONSTE(3.89362998589420812698e-01, 0xbffe, 0xfab8efb2L, 0x149f3907L), HEXCONSTE(9.21084390992190620712e-01, 0xbffc, 0xceda821fL, 0x1ee0da71L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* 3ffd:c75a9642:6d98d104, 3ffe:ebcc2fc8:2ae39ec0 */
#endif
	{ __LINE__, HEXCONSTE(1.32922799578491587290e+36, 0x4077, 0x80000000L, 0x00000000L), HEXCONSTE(3.77820109360752022661e-01, 0xbffe, 0xebcdeef4L, 0xbae324c6L), HEXCONSTE(-9.25879022854837867307e-01, 0xbffd, 0xc752525eL, 0xef6da9eaL), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* 3ffd:c171a32a:f37e5b6c, bffe:ed06685b:36c66c4d */
	{ __LINE__, HEXCONSTE(1.70141183460469231732e+38, 0x407e, 0x80000000L, 0x00000000L), HEXCONSTE(6.23385512955870240359e-01, 0xbffe, 0xcb5f91faL, 0xbda011daL), HEXCONSTE(7.81914638714960072267e-01, 0x3ffe, 0x9b7beb35L, 0x84744aa2L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* 3ffe:9f963166:f215eb89, 3ffe:c82b8ec9:8b5e62fd */
	{ __LINE__, HEXCONSTE(3.40282285791300048857e+38, 0x407e, 0xfffffc00L, 0x00000000L), HEXCONSTE(4.85786063130487339716e-02, 0x3ffd, 0xe31da09cL, 0xa53611daL), HEXCONSTE(9.98819362551949040704e-01, 0x3ffe, 0xe56f778fL, 0x34e98637L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* 3ffa:c6fa5c56:65984d89, 3ffe:ffb2a030:c5ae20be */
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-5.21876523333658540562e-01, 0x3ffe, 0xf3e8111bL, 0x794ca429L), HEXCONSTE(8.53021039830304158072e-01, 0xbffd, 0x9b81d0beL, 0xfeb2a614L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* bffe:8599b328:44aba907, 3ffe:da5f963c:defe6d53 */
	{ __LINE__, HEXCONSTE(1.12589990684262400000e+15, 0x4031, 0x80000000L, 0x00000000L), HEXCONSTE(4.96396515208940840872e-01, 0x3ffd, 0xfe27d956L, 0x1866fd77L), HEXCONSTE(8.68095904660550604312e-01, 0x3ffe, 0xde3b7c6d, 0xf5ef66a2L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* 3ffd:fe27af1d:576ed715, 3ffe:de3b8880:4f00552d */
	{ __LINE__, HEXCONSTE(2.68435456000000000000e+08, 0x401b, 0x80000000L, 0x00000000L), HEXCONSTE(-9.86198211836975655704e-01, 0xbffe, 0xfc777c6bL, 0x36b76baeL), HEXCONSTE(-1.65568979490578758871e-01, 0xbffc, 0xa98aea20L, 0x921738b3L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(5.21876523333658540562e-01, 0xbffe, 0xf3e8111bL, 0x794ca429L), HEXCONSTE(8.53021039830304158072e-01, 0xbffd, 0x9b81d0beL, 0xfeb2a614L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* 3ffe:8599b328:44aba907, 3ffe:da5f963c:defe6d53 */
	{ __LINE__, HEXCONSTE(-3.64229140925048708372e+307, 0xc3fc, 0xcf78c83dL, 0xafa1f800L), HEXCONSTE(-9.92195624918954397636e-01, 0x3ffd, 0xb9899a90L, 0x322e15a0L), HEXCONSTE(-1.24690985607162313507e-01, 0x3ffe, 0xee999947L, 0x53db5fcdL), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* bffe:fe008850:42dd770d, bffb:ff5dfcca:4f66099b */
	{ __LINE__, HEXCONSTE(7.59194657019045731761e+34, 0x4072, 0xe9f1e600L, 0x00000000L), HEXCONSTE(7.79108221354363387633e-01, 0x3ffe, 0xb022a84fL, 0x76653b3cL), HEXCONSTE(-6.26889447524872842987e-01, 0xbffe, 0xb9c66259L, 0x794192baL), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* 3ffe:c773a2ea:c3000ddf, bffe:a07bd3ab:53ab9711 */
	{ __LINE__, HEXCONSTE(7.59194607501444160346e+34, 0x4072, 0xe9f1e500L, 0x00000000L), HEXCONSTE(4.66512683316143507688e-01, 0x3ffe, 0xea5cd76fL, 0x02f8721eL), HEXCONSTE(8.84514508815526213101e-01, 0xbffd, 0xce02d6f2L, 0x4e16e8acL), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* 3ffd:eedac01c:062a4370, 3ffe:e26f8af8:333f9271 */
	{ __LINE__, HEXCONSTE(7.59194643911056501837e+34, 0x4072, 0xe9f1e5bcL, 0x3bb88000L), HEXCONSTE(9.92187350026198468548e-01, 0xbffe, 0xc17ebb77L, 0xe04d1035L), HEXCONSTE(1.24756813232744614799e-01, 0xbffe, 0xa79e1c50L, 0xa3e666e2L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* 3ffe:fdfffd7b:de0fb4ec, 3ffb:ff808006:4d739b18 */
	{ __LINE__, HEXCONSTE(1.31933767361251141222e+21, 0x4045, 0x8f0afa00L, 0x00000000L), HEXCONSTE(-1.24929881576082082729e-01, 0xbffe, 0xf7d9ca6bL, 0x4cf46ea2L), HEXCONSTE(-9.92165573223232789748e-01, 0x3ffd, 0x8028022fL, 0xef29e109L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* bffb:ffdb3cdd:4ca5bb0c, bffe:fdfe9021:35fc1c18 */
	{ __LINE__, HEXCONSTE(6.15815448760986328125e+00, 0x4001, 0xc50f9a00L, 0x00000000L), HEXCONSTE(-1.24705312431196324671e-01, 0xbffb, 0xff657fb4L, 0x3c508673L), HEXCONSTE(9.92193824336473942447e-01, 0x3ffe, 0xfe006a1aL, 0xd17db69bL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(6.15815401077270507812e+00, 0x4001, 0xc50f9900L, 0x00000000L), HEXCONSTE(-1.24705785546065730596e-01, 0xbffb, 0xff65bf34L, 0x56b74e20L), HEXCONSTE(9.92193764872234350576e-01, 0x3ffe, 0xfe00691bL, 0x6bde4252L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(6.15815403791391346999e+00, 0x4001, 0xc50f990eL, 0x92426000L), HEXCONSTE(-1.24705758616727947154e-01, 0xbffb, 0xff65bb97L, 0x0dc18073L), HEXCONSTE(9.92193768256899698266e-01, 0x3ffe, 0xfe006929L, 0xf558dbe6L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(6.15815403791391258181e+00, 0x4001, 0xc50f990eL, 0x92425800L), HEXCONSTE(-1.24705758616728828401e-01, 0xbffb, 0xff65bb97L, 0x0dc37c74L), HEXCONSTE(9.92193768256899587515e-01, 0x3ffe, 0xfe006929L, 0xf558d3ebL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(6.15815403791391312478e+00, 0x4001, 0xc50f990eL, 0x92425ce4L), HEXCONSTE(-1.24705758616728289667e-01, 0xbffb, 0xff65bb97L, 0x0dc245e5L), HEXCONSTE(9.92193768256899655223e-01, 0x3ffe, 0xfe006929L, 0xf558d8ccL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-1.01128077507019042969e+00, 0xbfff, 0x8171a600L, 0x00000000L), HEXCONSTE(-8.47512343819588481741e-01, 0xbffe, 0xd8f691a7L, 0xa9542600L), HEXCONSTE(5.30775684327595814770e-01, 0x3ffe, 0x87e0ea4dL, 0xb2f48867L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(2.55009582519531250000e+02, 0x4006, 0xff027400L, 0x00000000L), HEXCONSTE(-5.14631300183308550763e-01, 0xbffe, 0x83bee07bL, 0xc9076425L), HEXCONSTE(-8.57411584288221151643e-01, 0xbffe, 0xdb7f5359L, 0xbabdb66cL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(3.01631975173950195312e+00, 0x4000, 0xc10b6200L, 0x00000000L), HEXCONSTE(1.24945501318506756680e-01, 0x3ffb, 0xffe36d4fL, 0x8fff6c4bL), HEXCONSTE(-9.92163606317157264374e-01, 0xbffe, 0xfdfe6f21L, 0x69e24f27L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-5.21876523333658540562e-01, 0x3ffe, 0xf3e8111bL, 0x794ca429L), HEXCONSTE(8.53021039830304158072e-01, 0xbffd, 0x9b81d0beL, 0xfeb2a614L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* bffe:8599b328:44aba907, 3ffe:da5f963c:defe6d53 */
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(4.96195478918406179070e-03, 0xbffe, 0xcbafef50L, 0x1d8a7cb4L), HEXCONSTE(-9.99987689426559937453e-01, 0xbffe, 0x9b1294d0L, 0x9cf3e650L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* 3ff7:a297e4c5:9a74b5b1, bffe:ffff3176:7d5ba9e0 */
#ifdef TEST_LDOUBLE
	{ __LINE__, HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(9.92151099123526495965e-01, 0xbffb, 0xd5533512L, 0x6b40ccd2L), HEXCONSTE(-1.25044778011631903473e-01, 0x3ffe, 0xfe9b80a4L, 0x0c3bfcf5L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* 3ffe:fdfd9d4b:6d0e5f7c, bffc:800bbd00:61d4f543 */
	{ __LINE__, HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-9.92151099123526495965e-01, 0x3ffb, 0xd5533512L, 0x6b40ccd2L), HEXCONSTE(-1.25044778011631903473e-01, 0x3ffe, 0xfe9b80a4L, 0x0c3bfcf5L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* bffe:fdfd9d4b:6d0e5f7c, bffc:800bbd00:61d4f543 */
#endif
	{ __LINE__, HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(5.21876523333658540562e-01, 0xbffe, 0xf3e8111bL, 0x794ca429L), HEXCONSTE(8.53021039830304158072e-01, 0xbffd, 0x9b81d0beL, 0xfeb2a614L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* 3ffe:8599b328:44aba907, 3ffe:da5f963c:defe6d53 */
	{ __LINE__, HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-4.96195478918406179070e-03, 0x3ffe, 0xcbafef50L, 0x1d8a7cb4L), HEXCONSTE(-9.99987689426559937453e-01, 0xbffe, 0x9b1294d0L, 0x9cf3e650L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* bff7:a297e4c5:9a74b5b1, bffe:ffff3176:7d5ba9e0 */
	{ __LINE__, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if defined(TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16381)
	{ __LINE__, HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
#if defined(TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if defined(TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16381)
	{ __LINE__, HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
#if defined(TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#ifdef TEST_LDOUBLE
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951L, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.82259976594123730126e-4951L, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), FLAG_SUBNORM },
	{ __LINE__, HEXCONSTE(1.82259976594123730126e-4951L, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), FLAG_SUBNORM },
#endif
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#ifdef TEST_LDOUBLE
	{ __LINE__, HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, HEXCONSTE(1.51742398738861083984e+00, 0x3fff, 0xc23af300L, 0x00000000L), HEXCONSTE(9.98576034767698972555e-01, 0x3ffe, 0xffa2add3L, 0xe58948d1L), HEXCONSTE(5.33470035486460361106e-02, 0x3ffa, 0xda826339L, 0x4be6d0e6L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.51742386817932128906e+00, 0x3fff, 0xc23af200L, 0x00000000L), HEXCONSTE(9.98576028408233484540e-01, 0x3ffe, 0xffa2adb8L, 0x953ae262L), HEXCONSTE(5.33471225881853241497e-02, 0x3ffa, 0xda82832dL, 0xa19f9892L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.51742396872239759809e+00, 0x3fff, 0xc23af2d7L, 0xea240800L), HEXCONSTE(9.98576033771912254552e-01, 0x3ffe, 0xffa2adcfL, 0x9ea83dbeL), HEXCONSTE(5.33470221882792298984e-02, 0x3ffa, 0xda82683aL, 0x33cbec00L), FLAG_INEXACT2 },
};



int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_f_ff(fsincos_data, ARRAY_SIZE(fsincos_data), __FILE__);

#if defined(__mc68000__) && (defined(__HAVE_68881__))
	{
		ld_union fp0;
		ld_union fp1;
		int this_fail;
		int i;
		static ld_union const pi_2 = HEXCONST_PI_2;
		
		/* test that we get the sin in the result when using the same register */
		numtests++;
		if (testonly == 0 || testonly == numtests)
		{
			for (i = 0; i < jit_loops; i++)
			{
				__asm__ __volatile__(
					"\tfmove.x %[x],%[fp0]\n"
					"\tfsincos.x %[fp0],%[r1],%[r1]\n"
				: [fp0]"=&f"(fp0.x), [r1]"=&f"(fp1.x)
				: [x]"m"(pi_2)
				: "cc", "memory");
				EXPECT_FP(fp1, 0x3fff, 0x80000000L, 0x00000000L);
				if (this_fail) break;
			}
		}
	}
#endif
		
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

#else

int main(void)
{
	return 77;
}

#endif

```

`tests/sinh.c`:

```c
#include "testconfig.h"
#define TEST_FUNC_F_F __MATH_PRECNAME(sinh)
#include "testdriver.h"



static test_f_f_data const fsinh_data[] = {
	{ __LINE__, ZERO_P, ZERO_P, 0 },
	{ __LINE__, ZERO_M, ZERO_M, FLAG_IGNORE_ZEROSIGN },
	{ __LINE__, INF_P, INF_P, 0 },
	{ __LINE__, INF_M, INF_M, 0 },
	{ __LINE__, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_P, 0 },
	{ __LINE__, SNAN_P, QNAN_P, 0 },
	{ __LINE__, SNAN_M, QNAN_P, 0 },

	{ __LINE__, HEXCONSTE(7.50000000000000000000e-01, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(8.22316731935829980710e-01, 0x3ffe, 0xd283596eL, 0x9e347f2fL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.86264514923095703125e-09, 0x3fe2, 0x80000000L, 0x00000000L), HEXCONSTE(1.86264514923095703226e-09, 0x3fe2, 0x80000000L, 0x00000005L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(3.12500000000000000000e-02, 0x3ffa, 0x80000000L, 0x00000000L), HEXCONSTE(3.12550865113792945466e-02, 0x3ffa, 0x80055566L, 0x6680681eL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-3.12500000000000000000e-02, 0xbffa, 0x80000000L, 0x00000000L), HEXCONSTE(-3.12550865113792945466e-02, 0xbffa, 0x80055566L, 0x6680681eL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(9.76562500000000000000e-04, 0x3ff5, 0x80000000L, 0x00000000L), HEXCONSTE(9.76562655220436504024e-04, 0x3ff5, 0x80000155L, 0x55566666L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-9.76562500000000000000e-04, 0xbff5, 0x80000000L, 0x00000000L), HEXCONSTE(-9.76562655220436504024e-04, 0xbff5, 0x80000155L, 0x55566666L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(9.53674316406250000000e-07, 0x3feb, 0x80000000L, 0x00000000L), HEXCONSTE(9.53674316406394560255e-07, 0x3feb, 0x80000000L, 0x00155555L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-9.53674316406250000000e-07, 0xbfeb, 0x80000000L, 0x00000000L), HEXCONSTE(-9.53674316406394560255e-07, 0xbfeb, 0x80000000L, 0x00155555L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(9.31322574615478515625e-10, 0x3fe1, 0x80000000L, 0x00000000L), HEXCONSTE(9.31322574615478515726e-10, 0x3fe1, 0x80000000L, 0x00000001L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-9.31322574615478515625e-10, 0xbfe1, 0x80000000L, 0x00000000L), HEXCONSTE(-9.31322574615478515726e-10, 0xbfe1, 0x80000000L, 0x00000001L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(9.09494701772928237915e-13, 0x3fd7, 0x80000000L, 0x00000000L), HEXCONSTE(9.09494701772928237915e-13, 0x3fd7, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-9.09494701772928237915e-13, 0xbfd7, 0x80000000L, 0x00000000L), HEXCONSTE(-9.09494701772928237915e-13, 0xbfd7, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(8.88178419700125232339e-16, 0x3fcd, 0x80000000L, 0x00000000L), HEXCONSTE(8.88178419700125232339e-16, 0x3fcd, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-8.88178419700125232339e-16, 0xbfcd, 0x80000000L, 0x00000000L), HEXCONSTE(-8.88178419700125232339e-16, 0xbfcd, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(8.67361737988403547206e-19, 0x3fc3, 0x80000000L, 0x00000000L), HEXCONSTE(8.67361737988403547206e-19, 0x3fc3, 0x80000000L, 0x00000000L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-8.67361737988403547206e-19, 0xbfc3, 0x80000000L, 0x00000000L), HEXCONSTE(-8.67361737988403547206e-19, 0xbfc3, 0x80000000L, 0x00000000L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(8.47032947254300339068e-22, 0x3fb9, 0x80000000L, 0x00000000L), HEXCONSTE(8.47032947254300339068e-22, 0x3fb9, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-8.47032947254300339068e-22, 0xbfb9, 0x80000000L, 0x00000000L), HEXCONSTE(-8.47032947254300339068e-22, 0xbfb9, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(7.88860905221011805412e-31, 0x3f9b, 0x80000000L, 0x00000000L), HEXCONSTE(7.88860905221011805412e-31, 0x3f9b, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-7.88860905221011805412e-31, 0xbf9b, 0x80000000L, 0x00000000L), HEXCONSTE(-7.88860905221011805412e-31, 0xbf9b, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9.33263618503218878990e-302, 0x3c17, 0x80000000L, 0x00000000L), HEXCONSTE(9.33263618503218878990e-302, 0x3c17, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-9.33263618503218878990e-302, 0xbc17, 0x80000000L, 0x00000000L), HEXCONSTE(-9.33263618503218878990e-302, 0xbc17, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(5.01237274920645200930e-3011, 0x18ef, 0x80000000L, 0x00000000L), HEXCONSTE(5.01237274920645200930e-3011, 0x18ef, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-5.01237274920645200930e-3011, 0x98ef, 0x80000000L, 0x00000000L), HEXCONSTE(-5.01237274920645200930e-3011, 0x98ef, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.20000000000000000000e+01, 0x4003, 0xb0000000L, 0x00000000L), HEXCONSTE(1.79245642306579578074e+09, 0x401d, 0xd5ad6dceL, 0x21affc0dL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.30000000000000000000e+01, 0x4003, 0xb8000000L, 0x00000000L), HEXCONSTE(4.87240172312445130013e+09, 0x401f, 0x9135799dL, 0x8fee052cL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.40000000000000000000e+01, 0x4003, 0xc0000000L, 0x00000000L), HEXCONSTE(1.32445610649217361473e+10, 0x4020, 0xc55bfdaaL, 0x3afdb99cL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-4.58457916975021362305e-01, 0xbffd, 0xeabaff00L, 0x00000000L), HEXCONSTE(-4.74687602807401976571e-01, 0xbffd, 0xf30a40e3L, 0xbfb531afL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-2.46966332197189331055e-01, 0xbffc, 0xfce4be00L, 0x00000000L), HEXCONSTE(-2.49484509710473543914e-01, 0xbffc, 0xff78de08L, 0x42a3e2c5L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.77106130123138427734e+00, 0x3fff, 0xe2b22300L, 0x00000000L), HEXCONSTE(2.85346755134676659661e+00, 0x4000, 0xb69f365dL, 0x4ed1eed3L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(4.24505382776260375977e-01, 0x3ffd, 0xd958c500L, 0x00000000L), HEXCONSTE(4.37370407029838015355e-01, 0x3ffd, 0xdfef0394L, 0xdcdb94ceL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(4.24505352973937988281e-01, 0x3ffd, 0xd958c400L, 0x00000000L), HEXCONSTE(4.37370374501686997248e-01, 0x3ffd, 0xdfef027dL, 0x72b27b12L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(4.24505363525834178429e-01, 0x3ffd, 0xd958c45aL, 0xa3dd7800L), HEXCONSTE(4.37370386018697886925e-01, 0x3ffd, 0xdfef02e0L, 0x60df3982L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-5.76872253417968750000e+00, 0xc001, 0xb8996000L, 0x00000000L), HEXCONSTE(-1.60062697169396860764e+02, 0xc006, 0xa0100cebL, 0xf41c7d70L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-5.76872301101684570312e+00, 0xc001, 0xb8996100L, 0x00000000L), HEXCONSTE(-1.60062773494746228273e+02, 0xc006, 0xa01011ecL, 0x7afd9d17L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-5.76872266656940713148e+00, 0xc001, 0xb8996047L, 0x13812800L), HEXCONSTE(-1.60062718360467416981e+02, 0xc006, 0xa0100e4fL, 0x7b10f8b9L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-1.39221668243408203125e+00, 0xbfff, 0xb2342800L, 0x00000000L), HEXCONSTE(-1.88761788822762363420e+00, 0xbfff, 0xf19d7684L, 0xa42002f0L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-1.39221680164337158203e+00, 0xbfff, 0xb2342900L, 0x00000000L), HEXCONSTE(-1.88761814287556951560e+00, 0xbfff, 0xf19d78a7L, 0x7e505465L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-1.39221673949753865784e+00, 0xbfff, 0xb234287aL, 0x8af79000L), HEXCONSTE(-1.88761801012325501181e+00, 0xbfff, 0xf19d778aL, 0x68f50357L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-4.78704392910003662109e-01, 0xbffd, 0xf518be00L, 0x00000000L), HEXCONSTE(-4.97198174499491059742e-01, 0xbffd, 0xfe90c256L, 0x3661d910L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-4.78704422712326049805e-01, 0xbffd, 0xf518bf00L, 0x00000000L), HEXCONSTE(-4.97198207782241708975e-01, 0xbffd, 0xfe90c374L, 0x1becc68fL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-4.78704417306402063570e-01, 0xbffd, 0xf518bed1L, 0x903f5800L), HEXCONSTE(-4.97198201744993379840e-01, 0xbffd, 0xfe90c340L, 0x3fe01c25L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-4.78704417306402119081e-01, 0xbffd, 0xf518bed1L, 0x903f6000L), HEXCONSTE(-4.97198201744993441829e-01, 0xbffd, 0xfe90c340L, 0x3fe02514L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-4.78704417306402096367e-01, 0xbffd, 0xf518bed1L, 0x903f5cbaL), HEXCONSTE(-4.97198201744993416458e-01, 0xbffd, 0xfe90c340L, 0x3fe0216cL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.05569684505462646484e-01, 0x3ffc, 0xd280dc00L, 0x00000000L), HEXCONSTE(2.07020604787804042671e-01, 0x3ffc, 0xd3fd359cL, 0xa5a4406eL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-2.45032161474227905273e-01, 0xbffc, 0xfae9b600L, 0x00000000L), HEXCONSTE(-2.47491519167881710405e-01, 0xbffc, 0xfd6e6ab3L, 0x74218283L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-2.45032176375389099121e-01, 0xbffc, 0xfae9b700L, 0x00000000L), HEXCONSTE(-2.47491534518624150738e-01, 0xbffc, 0xfd6e6bbbL, 0x2d68fe4cL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-2.45032175617604847107e-01, 0xbffc, 0xfae9b6f2L, 0xfb3ac800L), HEXCONSTE(-2.47491533737976874559e-01, 0xbffc, 0xfd6e6badL, 0xc4164c3eL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-2.33578777313232421875e+00, 0xc000, 0x957d8c00L, 0x00000000L), HEXCONSTE(-5.12043307925785205065e+00, 0xc001, 0xa3da9679L, 0x189c0fd0L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-2.36916333436965942383e-01, 0xbffc, 0xf29a3200L, 0x00000000L), HEXCONSTE(-2.39138888400282744048e-01, 0xbffc, 0xf4e0d323L, 0x8626ffa4L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-2.36916348338127136230e-01, 0xbffc, 0xf29a3300L, 0x00000000L), HEXCONSTE(-2.39138903721599957084e-01, 0xbffc, 0xf4e0d42aL, 0xbe049f18L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-2.36916338606045578929e-01, 0xbffc, 0xf29a3258L, 0xcdda4800L), HEXCONSTE(-2.39138893715110742420e-01, 0xbffc, 0xf4e0d37eL, 0xd50358cbL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-2.23352447152137756348e-01, 0xbffc, 0xe4b68100L, 0x00000000L), HEXCONSTE(-2.25214123144648980650e-01, 0xbffc, 0xe69e87f6L, 0x03ab897aL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-2.23352462053298950195e-01, 0xbffc, 0xe4b68200L, 0x00000000L), HEXCONSTE(-2.25214138419039940479e-01, 0xbffc, 0xe69e88fcL, 0x6d26e551L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-2.23352453326705419068e-01, 0xbffc, 0xe4b6816aL, 0x14092800L), HEXCONSTE(-2.25214129473871191653e-01, 0xbffc, 0xe69e8862L, 0xbfe23c1aL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-2.23352453326705446823e-01, 0xbffc, 0xe4b6816aL, 0x14093000L), HEXCONSTE(-2.25214129473871220113e-01, 0xbffc, 0xe69e8862L, 0xbfe2444eL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-2.23352453326705435615e-01, 0xbffc, 0xe4b6816aL, 0x14092cc5L), HEXCONSTE(-2.25214129473871208621e-01, 0xbffc, 0xe69e8862L, 0xbfe240feL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-2.02730715274810791016e-01, 0xbffc, 0xcf98a400L, 0x00000000L), HEXCONSTE(-2.04122268536041366575e-01, 0xbffc, 0xd1056d8eL, 0xfd920dfdL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-2.02730730175971984863e-01, 0xbffc, 0xcf98a500L, 0x00000000L), HEXCONSTE(-2.04122283744469754560e-01, 0xbffc, 0xd1056e94L, 0x44f228efL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-2.02730726178070697063e-01, 0xbffc, 0xcf98a4bbL, 0x510b5000L), HEXCONSTE(-2.04122279664130329118e-01, 0xbffc, 0xd1056e4eL, 0x2b6c6183L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-2.02730726178070724819e-01, 0xbffc, 0xcf98a4bbL, 0x510b5800L), HEXCONSTE(-2.04122279664130357443e-01, 0xbffc, 0xd1056e4eL, 0x2b6c69adL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-2.02730726178070701441e-01, 0xbffc, 0xcf98a4bbL, 0x510b5143L), HEXCONSTE(-2.04122279664130333590e-01, 0xbffc, 0xd1056e4eL, 0x2b6c62cdL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(4.64391350746154785156e-01, 0x3ffd, 0xedc4b400L, 0x00000000L), HEXCONSTE(4.81263984969579431360e-01, 0x3ffd, 0xf6683ba8L, 0x5fbbbd46L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(4.64391320943832397461e-01, 0x3ffd, 0xedc4b300L, 0x00000000L), HEXCONSTE(4.81263951895512991417e-01, 0x3ffd, 0xf6683a8cL, 0x451793d9L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(4.64391340097278393362e-01, 0x3ffd, 0xedc4b3a4L, 0x86df8800L), HEXCONSTE(4.81263973151653225011e-01, 0x3ffd, 0xf6683b42L, 0xdbd6bb61L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(2.39960223436355590820e-01, 0x3ffc, 0xf5b82200L, 0x00000000L), HEXCONSTE(2.42269717181145852877e-01, 0x3ffc, 0xf8158d80L, 0x6ab0fa99L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-4.63026642799377441406e-01, 0xbffd, 0xed11d400L, 0x00000000L), HEXCONSTE(-4.79749904999036021842e-01, 0xbffd, 0xf5a1c790L, 0x75be2f7eL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-8.66431772708892822266e-01, 0xbffe, 0xddce7900L, 0x00000000L), HEXCONSTE(-9.78979928257233524469e-01, 0xbffe, 0xfa9e6db7L, 0x4e247cefL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.38192001342773437500e+02, 0x4006, 0x8a312700L, 0x00000000L), HEXCONSTE(5.18792430301803409658e+59, 0x40c5, 0xa54bfb67L, 0x25b233f8L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(4.27665421739220619202e-04, 0x3ff3, 0xe0384800L, 0x00000000L), HEXCONSTE(4.27665434775725329170e-04, 0x3ff3, 0xe0384872L, 0xab995001L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(7.18604862689971923828e-01, 0x3ffe, 0xb7f67d00L, 0x00000000L), HEXCONSTE(7.82068588275683684462e-01, 0x3ffe, 0xc835a5a1L, 0xdf79ae5fL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(7.18604803085327148438e-01, 0x3ffe, 0xb7f67c00L, 0x00000000L), HEXCONSTE(7.82068512607564427289e-01, 0x3ffe, 0xc835a45cL, 0xe17f9353L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(7.18604815547913666762e-01, 0x3ffe, 0xb7f67c35L, 0x86c24000L), HEXCONSTE(7.82068528428822531962e-01, 0x3ffe, 0xc835a4a0L, 0xd527d500L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-1.24161589145660400391e+00, 0xbfff, 0x9eed4500L, 0x00000000L), HEXCONSTE(-1.58614244644867517006e+00, 0xbfff, 0xcb06b737L, 0x25b1e338L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-3.70744794607162475586e-01, 0xbffd, 0xbdd24300L, 0x00000000L), HEXCONSTE(-3.79296607136249390029e-01, 0xbffd, 0xc2332a36L, 0x44954557L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-1.73822927474975585938e+00, 0xbfff, 0xde7e4c00L, 0x00000000L), HEXCONSTE(-2.75571622255457729183e+00, 0xc000, 0xb05da793L, 0x3b6da477L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-4.13020521402359008789e-01, 0xbffd, 0xd3776d00L, 0x00000000L), HEXCONSTE(-4.24863668221186623232e-01, 0xbffd, 0xd987bb10L, 0x8984c3d3L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-4.13020551204681396484e-01, 0xbffd, 0xd3776e00L, 0x00000000L), HEXCONSTE(-4.24863700601778828786e-01, 0xbffd, 0xd987bc26L, 0xaf31a389L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-4.13020543634378012321e-01, 0xbffd, 0xd3776dbeL, 0xf8ba1000L), HEXCONSTE(-4.24863692376550451234e-01, 0xbffd, 0xd987bbe0L, 0x07b9b4f0L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), INF_P, 0 },
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, MAX_P, INF_P, 0 },
	{ __LINE__, MAX_M, INF_M, 0 },
#endif
	{ __LINE__, HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), INF_M, 0 },
	{ __LINE__, HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), INF_M, 0 },
	{ __LINE__, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), 0 },
#if defined(TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16381)
	{ __LINE__, HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), 0 },
#endif
#if defined(TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), 0 },
#if defined(TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16381)
	{ __LINE__, HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), 0 },
#endif
#if defined(TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), 0 },
#if defined(TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16381)
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), 0 },
#endif
	{ __LINE__, HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), 0 },
#if defined(TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16381)
	{ __LINE__, HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L), FLAG_IGNORE_ZEROSIGN },
	{ __LINE__, HEXCONSTE(8.94159851074218750000e+01, 0x4005, 0xb2d4fc00L, 0x00000000L), HEXCONSTE(3.40281963750862078946e+38, 0x407e, 0xffffec1fL, 0x473940d2L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(8.94159927368164062500e+01, 0x4005, 0xb2d4fd00L, 0x00000000L), HEXCONSTE(3.40284559906118936553e+38, 0x407f, 0x8000360fL, 0xaea473a4L), FLAG_INEXACT2 },
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(7.10475891113281250000e+02, 0x4008, 0xb19e7500L, 0x00000000L), HEXCONSTE(1.79774893493189901141e+308, 0x43ff, 0x80010461L, 0x80f9b78eL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(7.10475830078125000000e+02, 0x4008, 0xb19e7400L, 0x00000000L), HEXCONSTE(1.79763921239325737934e+308, 0x43fe, 0xfffe08c2L, 0xdeed02b1L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.10475860073943863426e+02, 0x4008, 0xb19e747dL, 0xcfc3e800L), HEXCONSTE(1.79769313486217438209e+308, 0x43fe, 0xffffffffL, 0xffe9d72dL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.10475891113281250000e+02, 0x4008, 0xb19e7500L, 0x00000000L), HEXCONSTE(1.79774893493189901141e+308, 0x43ff, 0x80010461L, 0x80f9b78eL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.10475830078125000000e+02, 0x4008, 0xb19e7400L, 0x00000000L), HEXCONSTE(1.79763921239325737934e+308, 0x43fe, 0xfffe08c2L, 0xdeed02b1L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.10475860073943977113e+02, 0x4008, 0xb19e747dL, 0xcfc3f000L), HEXCONSTE(1.79769313486237875604e+308, 0x43ff, 0x80000000L, 0x0004eb96L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.10475891113281250000e+02, 0x4008, 0xb19e7500L, 0x00000000L), HEXCONSTE(1.79774893493189901141e+308, 0x43ff, 0x80010461L, 0x80f9b78eL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.10475830078125000000e+02, 0x4008, 0xb19e7400L, 0x00000000L), HEXCONSTE(1.79763921239325737934e+308, 0x43fe, 0xfffe08c2L, 0xdeed02b1L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.10475860073943977113e+02, 0x4008, 0xb19e747dL, 0xcfc3f000L), HEXCONSTE(1.79769313486237875604e+308, 0x43ff, 0x80000000L, 0x0004eb96L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.10475860073943863426e+02, 0x4008, 0xb19e747dL, 0xcfc3e800L), HEXCONSTE(1.79769313486217438209e+308, 0x43fe, 0xffffffffL, 0xffe9d72dL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.10475860073943942141e+02, 0x4008, 0xb19e747dL, 0xcfc3ed8aL), HEXCONSTE(1.79769313486231588717e+308, 0x43fe, 0xffffffffL, 0xffffff2dL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.10475860073943942086e+02, 0x4008, 0xb19e747dL, 0xcfc3ed89L), HEXCONSTE(1.79769313486231578737e+308, 0x43fe, 0xffffffffL, 0xfffffb2dL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.10475891113281250000e+02, 0x4008, 0xb19e7500L, 0x00000000L), HEXCONSTE(1.79774893493189901141e+308, 0x43ff, 0x80010461L, 0x80f9b78eL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.10475830078125000000e+02, 0x4008, 0xb19e7400L, 0x00000000L), HEXCONSTE(1.79763921239325737934e+308, 0x43fe, 0xfffe08c2L, 0xdeed02b1L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.10475860073943977113e+02, 0x4008, 0xb19e747dL, 0xcfc3f000L), HEXCONSTE(1.79769313486237875604e+308, 0x43ff, 0x80000000L, 0x0004eb96L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.10475860073943863426e+02, 0x4008, 0xb19e747dL, 0xcfc3e800L), HEXCONSTE(1.79769313486217438209e+308, 0x43fe, 0xffffffffL, 0xffe9d72dL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.10475860073943942141e+02, 0x4008, 0xb19e747dL, 0xcfc3ed8aL), HEXCONSTE(1.79769313486231588717e+308, 0x43fe, 0xffffffffL, 0xffffff2dL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.10475860073943942086e+02, 0x4008, 0xb19e747dL, 0xcfc3ed89L), HEXCONSTE(1.79769313486231578737e+308, 0x43fe, 0xffffffffL, 0xfffffb2dL), FLAG_INEXACT3 },
#endif
	{ __LINE__, HEXCONSTE(1.13572167968750000000e+04, 0x400c, 0xb174de00L, 0x00000000L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(1.13572165534747055062e+04, 0x400c, 0xb174ddc0L, 0x31aec800L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(1.13572167968750000000e+04, 0x400c, 0xb174de00L, 0x00000000L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(1.13572165534747055062e+04, 0x400c, 0xb174ddc0L, 0x31aec800L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(1.13572165534747038951e+04, 0x400c, 0xb174ddc0L, 0x31aec0eaL), INF_P, 0 },
	{ __LINE__, HEXCONSTE(1.13572167968750000000e+04, 0x400c, 0xb174de00L, 0x00000000L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(1.13572165534747055062e+04, 0x400c, 0xb174ddc0L, 0x31aec800L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(1.13572165534747038951e+04, 0x400c, 0xb174ddc0L, 0x31aec0eaL), INF_P, 0 },
	{ __LINE__, HEXCONSTE(1.13572167968750000000e+04, 0x400c, 0xb174de00L, 0x00000000L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(1.13572165534747055062e+04, 0x400c, 0xb174ddc0L, 0x31aec800L), INF_P, 0 },
	{ __LINE__, HEXCONSTE(1.13572165534747038951e+04, 0x400c, 0xb174ddc0L, 0x31aec0eaL), INF_P, 0 },

#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(1.13572158203125000000e+04, 0x400c, 0xb174dd00L, 0x00000000L), HEXCONSTE(1.18885954887021453402e+4932, 0x7ffe, 0xffcff816L, 0x5c0f3207L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(1.13572165534747036872e+04, 0x400c, 0xb174ddc0L, 0x31aec000L), HEXCONSTE(1.18973149535698482656e+4932, 0x7ffe, 0xffffffffL, 0xffc593dbL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(1.13572165534747038942e+04, 0x400c, 0xb174ddc0L, 0x31aec0e9L), HEXCONSTE(1.18973149535723103622e+4932, 0x7ffe, 0xffffffffL, 0xffffd3dbL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(1.13572158203125000000e+04, 0x400c, 0xb174dd00L, 0x00000000L), HEXCONSTE(1.18885954887021453402e+4932, 0x7ffe, 0xffcff816L, 0x5c0f3207L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(1.13572165534747036872e+04, 0x400c, 0xb174ddc0L, 0x31aec000L), HEXCONSTE(1.18973149535698482656e+4932, 0x7ffe, 0xffffffffL, 0xffc593dbL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(1.13572158203125000000e+04, 0x400c, 0xb174dd00L, 0x00000000L), HEXCONSTE(1.18885954887021453402e+4932, 0x7ffe, 0xffcff816L, 0x5c0f3207L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(1.13572165534747036872e+04, 0x400c, 0xb174ddc0L, 0x31aec000L), HEXCONSTE(1.18973149535698482656e+4932, 0x7ffe, 0xffffffffL, 0xffc593dbL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(1.13572165534747038942e+04, 0x400c, 0xb174ddc0L, 0x31aec0e9L), HEXCONSTE(1.18973149535723103622e+4932, 0x7ffe, 0xffffffffL, 0xffffd3dbL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(1.13572158203125000000e+04, 0x400c, 0xb174dd00L, 0x00000000L), HEXCONSTE(1.18885954887021453402e+4932, 0x7ffe, 0xffcff816L, 0x5c0f3207L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(1.13572165534747036872e+04, 0x400c, 0xb174ddc0L, 0x31aec000L), HEXCONSTE(1.18973149535698482656e+4932, 0x7ffe, 0xffffffffL, 0xffc593dbL), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(1.13572165534747038942e+04, 0x400c, 0xb174ddc0L, 0x31aec0e9L), HEXCONSTE(1.18973149535723103622e+4932, 0x7ffe, 0xffffffffL, 0xffffd3dbL), FLAG_INEXACT4 },
#endif

	{ __LINE__, HEXCONSTE(-8.000000000000000000e01L, 0xc005, 0xa0000000L, 0x00000000L), HEXCONSTE(-2.770311192196755026e34, 0xc071, 0xaabbcdccL, 0x279f59e3L), 0 },
	{ __LINE__, HEXCONSTE(-1.000000000000000000e01L, 0xc002, 0xa0000000L, 0x00000000L), HEXCONSTE(-1.101323287470339337e04, 0xc00c, 0xac14ee76L, 0xb4cc8f97L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-5.000000000000000000e-01L, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(-5.210953054937473615e-01, 0xbffe, 0x8566807fL, 0x31dcb64fL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.500000000000000000e00L, 0x3fff, 0xc0000000L, 0x00000000L), HEXCONSTE(2.129279455094817497e00, 0x4000, 0x88461d55L, 0xeb530367L), 0 },
	{ __LINE__, HEXCONSTE(1.000000000000000000e01L, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(1.101323287470339337e04, 0x400c, 0xac14ee76L, 0xb4cc8f97L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(8.000000000000000000e01L, 0x4005, 0xa0000000L, 0x00000000L), HEXCONSTE(2.770311192196755026e34, 0x4071, 0xaabbcdccL, 0x279f59e3L), 0 },

	{ __LINE__, HEXCONSTE(0.75L, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(0.822316731935829980703661634446913849L, 0x3ffe, 0xd283596eL, 0x9e347f2fL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.86264514923095703125e-09, 0x3fe2, 0x80000000L, 0x00000000L), HEXCONSTE(1.86264514923095703232705808926175479e-9L, 0x3fe2, 0x80000000L, 0x00000005L), 0 },

	{ __LINE__, HEXCONSTE(22, 0x4003, 0xb0000000L, 0x00000000L), HEXCONSTE(1792456423.065795780701106568345764104225L, 0x401d, 0xd5ad6dceL, 0x21affc0dL), ROUND_TONEAREST|FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(23, 0x4003, 0xb8000000L, 0x00000000L), HEXCONSTE(4872401723.124451299966006944252978187305L, 0x401f, 0x9135799dL, 0x8fee052cL), ROUND_TONEAREST|FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(24, 0x4003, 0xc0000000L, 0x00000000L), HEXCONSTE(13244561064.92173614705070540368454568168L, 0x4020, 0xc55bfdaaL, 0x3afdb99cL), ROUND_TONEAREST },

#if 0
	{ __LINE__, HEXCONSTE(22, 0x4003, 0xb0000000L, 0x00000000L), HEXCONSTE(1792456423.065795780701106568345764104225L, 0x401d, 0xd5ad6dceL, 0x21affc0dL), ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(23, 0x4003, 0xb8000000L, 0x00000000L), HEXCONSTE(4872401723.124451299966006944252978187305L, 0x401f, 0x9135799dL, 0x8fee052cL), ROUND_TOWARDZERO },
	{ __LINE__, HEXCONSTE(24, 0x4003, 0xc0000000L, 0x00000000L), HEXCONSTE(13244561064.92173614705070540368454568168L, 0x4020, 0xc55bfdaaL, 0x3afdb99cL), ROUND_TOWARDZERO },

	{ __LINE__, HEXCONSTE(22, 0x4003, 0xb0000000L, 0x00000000L), HEXCONSTE(1792456423.065795780701106568345764104225L, 0x401d, 0xd5ad6dceL, 0x21affc0dL), ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(23, 0x4003, 0xb8000000L, 0x00000000L), HEXCONSTE(4872401723.124451299966006944252978187305L, 0x401f, 0x9135799dL, 0x8fee052cL), ROUND_DOWNWARD },
	{ __LINE__, HEXCONSTE(24, 0x4003, 0xc0000000L, 0x00000000L), HEXCONSTE(13244561064.92173614705070540368454568168L, 0x4020, 0xc55bfdaaL, 0x3afdb99cL), ROUND_DOWNWARD },

	{ __LINE__, HEXCONSTE(22, 0x4003, 0xb0000000L, 0x00000000L), HEXCONSTE(1792456423.065795780701106568345764104225L, 0x401d, 0xd5ad6dceL, 0x21affc0dL), ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(23, 0x4003, 0xb8000000L, 0x00000000L), HEXCONSTE(4872401723.124451299966006944252978187305L, 0x401f, 0x9135799dL, 0x8fee052cL), ROUND_UPWARD },
	{ __LINE__, HEXCONSTE(24, 0x4003, 0xc0000000L, 0x00000000L), HEXCONSTE(13244561064.92173614705070540368454568168L, 0x4020, 0xc55bfdaaL, 0x3afdb99cL), ROUND_UPWARD },
#endif
};

int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_f_f(fsinh_data, ARRAY_SIZE(fsinh_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

```

`tests/sqrt.c`:

```c
#include "testconfig.h"
#define TEST_FUNC_F_F __MATH_PRECNAME(sqrt)
#include "testdriver.h"



static test_f_f_data const fsqrt_data[] = {
	{ __LINE__, ZERO_P, ZERO_P, 0 },
	{ __LINE__, ZERO_M, ZERO_M, FLAG_FAIL_ARANYM2 },
	{ __LINE__, INF_P, INF_P, 0 },
	{ __LINE__, INF_M, QNAN_P, 0 },
	{ __LINE__, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_P, 0 },
	{ __LINE__, SNAN_P, QNAN_P, 0 },
	{ __LINE__, SNAN_M, QNAN_P, 0 },

	{ __LINE__, HEXCONSTE(-1, 0xbfff, 0x80000000L, 0x00000000L), QNAN_P, 0 },
	{ __LINE__, HEXCONSTE(-1.1, 0xbfff, 0x8cccccccL, 0xcccccccdL), QNAN_P, 0 },
	{ __LINE__, MIN_M, QNAN_P, 0 },
	{ __LINE__, SUBNORM_M, QNAN_P, FLAG_SUBNORM },
	{ __LINE__, MAX_M, QNAN_P, 0 },

	{ __LINE__, HEXCONSTE(2.20900000000000000000e+03, 0x400a, 0x8a100000L, 0x00000000L), HEXCONSTE(4.70000000000000000000e+01, 0x4004, 0xbc000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.00000000000000000000e+00, 0x4001, 0x80000000L, 0x00000000L), HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(1.41421356237309504876e+00, 0x3fff, 0xb504f333L, 0xf9de6484L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.50000000000000000000e-01, 0x3ffd, 0x80000000L, 0x00000000L), HEXCONSTE(5.00000000000000000000e-01, 0x3ffe, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(6.64225000000000000000e+03, 0x400b, 0xcf920000L, 0x00000000L), HEXCONSTE(8.15000000000000000000e+01, 0x4005, 0xa3000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.51905625000000000000e+04, 0x400c, 0xed5a4000L, 0x00000000L), HEXCONSTE(1.23250000000000000000e+02, 0x4005, 0xf6800000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(7.50000000000000000000e-01, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(8.66025403784438646787e-01, 0x3ffe, 0xddb3d742L, 0xc265539eL), 0 },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.84467435239537295360e+19, 0x403e, 0xffffff7fL, 0xffffe000L), 0 },
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.34078079299425963553e+154, 0x41fe, 0xffffffffL, 0xfffffc00L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.84467435239537295360e+19, 0x403e, 0xffffff7fL, 0xffffe000L), 0 },
	{ __LINE__, HEXCONSTE(1.79769313486231490981e+308, 0x43fe, 0xffffffffL, 0xffffd800L), HEXCONSTE(1.34078079299425933782e+154, 0x41fe, 0xffffffffL, 0xffffec00L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.84467435239537295360e+19, 0x403e, 0xffffff7fL, 0xffffe000L), 0 },
	{ __LINE__, HEXCONSTE(1.79769313486231411147e+308, 0x43fe, 0xffffffffL, 0xffffb800L), HEXCONSTE(1.34078079299425904010e+154, 0x41fe, 0xffffffffL, 0xffffdc00L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.84467435239537295360e+19, 0x403e, 0xffffff7fL, 0xffffe000L), 0 },
	{ __LINE__, HEXCONSTE(1.79769313486231331314e+308, 0x43fe, 0xffffffffL, 0xffff9800L), HEXCONSTE(1.34078079299425874239e+154, 0x41fe, 0xffffffffL, 0xffffcc00L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.84467435239537295360e+19, 0x403e, 0xffffff7fL, 0xffffe000L), 0 },
	{ __LINE__, HEXCONSTE(1.79769313486231251480e+308, 0x43fe, 0xffffffffL, 0xffff7800L), HEXCONSTE(1.34078079299425844468e+154, 0x41fe, 0xffffffffL, 0xffffbc00L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.84467435239537295360e+19, 0x403e, 0xffffff7fL, 0xffffe000L), 0 },
	{ __LINE__, HEXCONSTE(1.79769313486231171646e+308, 0x43fe, 0xffffffffL, 0xffff5800L), HEXCONSTE(1.34078079299425814696e+154, 0x41fe, 0xffffffffL, 0xffffac00L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.84467435239537295360e+19, 0x403e, 0xffffff7fL, 0xffffe000L), 0 },
	{ __LINE__, HEXCONSTE(1.79769313486231091813e+308, 0x43fe, 0xffffffffL, 0xffff3800L), HEXCONSTE(1.34078079299425784925e+154, 0x41fe, 0xffffffffL, 0xffff9c00L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.84467435239537295360e+19, 0x403e, 0xffffff7fL, 0xffffe000L), 0 },
	{ __LINE__, HEXCONSTE(1.79769313486231011979e+308, 0x43fe, 0xffffffffL, 0xffff1800L), HEXCONSTE(1.34078079299425755154e+154, 0x41fe, 0xffffffffL, 0xffff8c00L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.84467435239537295360e+19, 0x403e, 0xffffff7fL, 0xffffe000L), 0 },
	{ __LINE__, HEXCONSTE(1.79769313486230932146e+308, 0x43fe, 0xffffffffL, 0xfffef800L), HEXCONSTE(1.34078079299425725382e+154, 0x41fe, 0xffffffffL, 0xffff7c00L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.84467435239537295360e+19, 0x403e, 0xffffff7fL, 0xffffe000L), 0 },
	{ __LINE__, HEXCONSTE(1.79769313486230852312e+308, 0x43fe, 0xffffffffL, 0xfffed800L), HEXCONSTE(1.34078079299425695611e+154, 0x41fe, 0xffffffffL, 0xffff6c00L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.84467435239537295360e+19, 0x403e, 0xffffff7fL, 0xffffe000L), 0 },
	{ __LINE__, HEXCONSTE(1.79769313486230772478e+308, 0x43fe, 0xffffffffL, 0xfffeb800L), HEXCONSTE(1.34078079299425665840e+154, 0x41fe, 0xffffffffL, 0xffff5c00L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(3.74339213057464375341e-23, 0x3fb4, 0xb504f333L, 0xf9de6484L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.22507385850720286529e-308, 0x3c01, 0x80000000L, 0x00001800L), HEXCONSTE(1.49166814624004184548e-154, 0x3e00, 0x80000000L, 0x00000c00L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(3.74339213057464375341e-23, 0x3fb4, 0xb504f333L, 0xf9de6484L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.22507385850720484155e-308, 0x3c01, 0x80000000L, 0x00003800L), HEXCONSTE(1.49166814624004250792e-154, 0x3e00, 0x80000000L, 0x00001c00L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(3.74339213057464375341e-23, 0x3fb4, 0xb504f333L, 0xf9de6484L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.22507385850720681781e-308, 0x3c01, 0x80000000L, 0x00005800L), HEXCONSTE(1.49166814624004317035e-154, 0x3e00, 0x80000000L, 0x00002c00L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(3.74339213057464375341e-23, 0x3fb4, 0xb504f333L, 0xf9de6484L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.22507385850720879407e-308, 0x3c01, 0x80000000L, 0x00007800L), HEXCONSTE(1.49166814624004383278e-154, 0x3e00, 0x80000000L, 0x00003c00L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(3.74339213057464375341e-23, 0x3fb4, 0xb504f333L, 0xf9de6484L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.22507385850721077034e-308, 0x3c01, 0x80000000L, 0x00009800L), HEXCONSTE(1.49166814624004449522e-154, 0x3e00, 0x80000000L, 0x00004c00L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(3.74339213057464375341e-23, 0x3fb4, 0xb504f333L, 0xf9de6484L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.22507385850721274660e-308, 0x3c01, 0x80000000L, 0x0000b800L), HEXCONSTE(1.49166814624004515765e-154, 0x3e00, 0x80000000L, 0x00005c00L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(3.74339213057464375341e-23, 0x3fb4, 0xb504f333L, 0xf9de6484L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.22507385850721472286e-308, 0x3c01, 0x80000000L, 0x0000d800L), HEXCONSTE(1.49166814624004582009e-154, 0x3e00, 0x80000000L, 0x00006c00L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(3.74339213057464375341e-23, 0x3fb4, 0xb504f333L, 0xf9de6484L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.22507385850721669913e-308, 0x3c01, 0x80000000L, 0x0000f800L), HEXCONSTE(1.49166814624004648252e-154, 0x3e00, 0x80000000L, 0x00007c00L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(3.74339213057464375341e-23, 0x3fb4, 0xb504f333L, 0xf9de6484L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.22507385850721867539e-308, 0x3c01, 0x80000000L, 0x00011800L), HEXCONSTE(1.49166814624004714495e-154, 0x3e00, 0x80000000L, 0x00008c00L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(3.74339213057464375341e-23, 0x3fb4, 0xb504f333L, 0xf9de6484L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.22507385850722065165e-308, 0x3c01, 0x80000000L, 0x00013800L), HEXCONSTE(1.49166814624004780739e-154, 0x3e00, 0x80000000L, 0x00009c00L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(3.74339213057464375341e-23, 0x3fb4, 0xb504f333L, 0xf9de6484L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.22507385850722262791e-308, 0x3c01, 0x80000000L, 0x00015800L), HEXCONSTE(1.49166814624004846982e-154, 0x3e00, 0x80000000L, 0x0000ac00L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(3.74339213057464375341e-23, 0x3fb4, 0xb504f333L, 0xf9de6484L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.22507385850722460418e-308, 0x3c01, 0x80000000L, 0x00017800L), HEXCONSTE(1.49166814624004913225e-154, 0x3e00, 0x80000000L, 0x0000bc00L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(3.74339213057464375341e-23, 0x3fb4, 0xb504f333L, 0xf9de6484L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.22507385850722658044e-308, 0x3c01, 0x80000000L, 0x00019800L), HEXCONSTE(1.49166814624004979469e-154, 0x3e00, 0x80000000L, 0x0000cc00L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(3.74339213057464375341e-23, 0x3fb4, 0xb504f333L, 0xf9de6484L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.22507385850722855670e-308, 0x3c01, 0x80000000L, 0x0001b800L), HEXCONSTE(1.49166814624005045712e-154, 0x3e00, 0x80000000L, 0x0000dc00L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.23513107299804687500e+01, 0x4005, 0xb8b3df00L, 0x00000000L), HEXCONSTE(9.60995893487482436262e+00, 0x4002, 0x99c2644cL, 0xd30bbba3L), 0 },
	{ __LINE__, HEXCONSTE(9.23513031005859375000e+01, 0x4005, 0xb8b3de00L, 0x00000000L), HEXCONSTE(9.60995853792231184264e+00, 0x4002, 0x99c263e2L, 0x44ad482bL), 0 },
	{ __LINE__, HEXCONSTE(9.23513039189064528500e+01, 0x4005, 0xb8b3de1bL, 0x7551d800L), HEXCONSTE(9.60995858049900508746e+00, 0x4002, 0x99c263edL, 0xb2866400L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.33599624633789062500e+01, 0x4005, 0xbab84d00L, 0x00000000L), HEXCONSTE(9.66229592091749724895e+00, 0x4002, 0x9a98c39bL, 0x89d67019L), 0 },
	{ __LINE__, HEXCONSTE(9.33599548339843750000e+01, 0x4005, 0xbab84c00L, 0x00000000L), HEXCONSTE(9.66229552611512576468e+00, 0x4002, 0x9a98c331L, 0x8f39aaffL), 0 },
	{ __LINE__, HEXCONSTE(9.33599596388915955458e+01, 0x4005, 0xbab84ca1L, 0x39d6b800L), HEXCONSTE(9.66229577475723910851e+00, 0x4002, 0x9a98c374L, 0x4dc7fc00L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.54205017089843750000e+01, 0x4005, 0xbed74c00L, 0x00000000L), HEXCONSTE(9.76834180959001736107e+00, 0x4002, 0x9c4b20c8L, 0x056ad6c7L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.54204940795898437500e+01, 0x4005, 0xbed74b00L, 0x00000000L), HEXCONSTE(9.76834141907365171437e+00, 0x4002, 0x9c4b205fL, 0x315647f8L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.54204962888612442384e+01, 0x4005, 0xbed74b4aL, 0x217f3000L), HEXCONSTE(9.76834153215689138250e+00, 0x4002, 0x9c4b207dL, 0x8c5bac00L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.58791732788085937500e+01, 0x4005, 0xbfc22300L, 0x00000000L), HEXCONSTE(9.79179111699226321659e+00, 0x4002, 0x9cab2d29L, 0x8bebd96dL), 0 },
	{ __LINE__, HEXCONSTE(9.58791656494140625000e+01, 0x4005, 0xbfc22200L, 0x00000000L), HEXCONSTE(9.79179072741110324927e+00, 0x4002, 0x9cab2cc0L, 0xf81b9a91L), 0 },
	{ __LINE__, HEXCONSTE(9.58791694188544880717e+01, 0x4005, 0xbfc2227eL, 0x7b3f2800L), HEXCONSTE(9.79179091989072691860e+00, 0x4002, 0x9cab2cf4L, 0xa334f400L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.68480453491210937500e+01, 0x4005, 0xc1b23300L, 0x00000000L), HEXCONSTE(9.84114044961868704182e+00, 0x4002, 0x9d754fb0L, 0x2747aa6dL), 0 },
	{ __LINE__, HEXCONSTE(9.68480377197265625000e+01, 0x4005, 0xc1b23200L, 0x00000000L), HEXCONSTE(9.84114006199111884723e+00, 0x4002, 0x9d754f48L, 0x19b75ebfL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.68480417488402167692e+01, 0x4005, 0xc1b23287L, 0x31d2a000L), HEXCONSTE(9.84114026669878416698e+00, 0x4002, 0x9d754f7fL, 0x0d1eb400L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.74363937377929687500e+01, 0x4005, 0xc2df6f00L, 0x00000000L), HEXCONSTE(9.87098747531334722808e+00, 0x4002, 0x9def9090L, 0x1b2497a9L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.74363861083984375000e+01, 0x4005, 0xc2df6e00L, 0x00000000L), HEXCONSTE(9.87098708885785330273e+00, 0x4002, 0x9def9028L, 0x5e1fa539L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.74363905088315505054e+01, 0x4005, 0xc2df6e93L, 0xa76ec000L), HEXCONSTE(9.87098731175516963532e+00, 0x4002, 0x9def9064L, 0x3382b400L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.75095825195312500000e+01, 0x4005, 0xc304e800L, 0x00000000L), HEXCONSTE(9.87469404688222479605e+00, 0x4002, 0x9dfebf2fL, 0x55d73ac0L), 0 },
	{ __LINE__, HEXCONSTE(9.75095748901367187500e+01, 0x4005, 0xc304e700L, 0x00000000L), HEXCONSTE(9.87469366057179106198e+00, 0x4002, 0x9dfebec7L, 0xa2ca3556L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.75095797988304724413e+01, 0x4005, 0xc304e7a4L, 0xb55bb800L), HEXCONSTE(9.87469390912095423829e+00, 0x4002, 0x9dfebf0aL, 0x5af55400L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.78049697875976562500e+01, 0x4005, 0xc39c2500L, 0x00000000L), HEXCONSTE(9.88963951757583812577e+00, 0x4002, 0x9e3bf6a5L, 0x937aa469L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.78049621582031250000e+01, 0x4005, 0xc39c2400L, 0x00000000L), HEXCONSTE(9.88963913184920640799e+00, 0x4002, 0x9e3bf63eL, 0x088bf98aL), 0 },
	{ __LINE__, HEXCONSTE(9.78049689388261214162e+01, 0x4005, 0xc39c24e3L, 0x851ba800L), HEXCONSTE(9.88963947466368065164e+00, 0x4002, 0x9e3bf69aL, 0x0e93fc00L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.82751846313476562500e+01, 0x4005, 0xc48ce500L, 0x00000000L), HEXCONSTE(9.91338411599932186561e+00, 0x4002, 0x9e9d38a9L, 0xae7283d9L), 0 },
	{ __LINE__, HEXCONSTE(9.82751770019531250000e+01, 0x4005, 0xc48ce400L, 0x00000000L), HEXCONSTE(9.91338373119658497739e+00, 0x4002, 0x9e9d3842L, 0x63012d63L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.82751822888191952643e+01, 0x4005, 0xc48ce4b1L, 0x65d57000L), HEXCONSTE(9.91338399784953328009e+00, 0x4002, 0x9e9d3889L, 0xf7417400L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.94729385375976562500e+01, 0x4005, 0xc6f22500L, 0x00000000L), HEXCONSTE(9.97361211084518046056e+00, 0x4002, 0x9f93ea4aL, 0xf11cfcc5L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.94729309082031250000e+01, 0x4005, 0xc6f22400L, 0x00000000L), HEXCONSTE(9.97361172836616519718e+00, 0x4002, 0x9f93e9e4L, 0x455afe27L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.94729356488015525883e+01, 0x4005, 0xc6f2249fL, 0x116e3000L), HEXCONSTE(9.97361196602321964377e+00, 0x4002, 0x9f93ea24L, 0x11061c00L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.00570472717285156250e+02, 0x4005, 0xc9241500L, 0x00000000L), HEXCONSTE(1.00284830715958810082e+01, 0x4002, 0xa074aaaaL, 0x4fe728deL), 0 },
	{ __LINE__, HEXCONSTE(1.00570465087890625000e+02, 0x4005, 0xc9241400L, 0x00000000L), HEXCONSTE(1.00284826912096041666e+01, 0x4002, 0xa074aa44L, 0x33f5023aL), 0 },
	{ __LINE__, HEXCONSTE(1.00570471308785386100e+02, 0x4005, 0xc92414d0L, 0xbd144000L), HEXCONSTE(1.00284830013709145291e+01, 0x4002, 0xa074aa97L, 0x76147c00L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.00609550476074218750e+02, 0x4005, 0xc9381700L, 0x00000000L), HEXCONSTE(1.00304312208436093110e+01, 0x4002, 0xa07ca572L, 0xa4cf7c2aL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.00609542846679687500e+02, 0x4005, 0xc9381600L, 0x00000000L), HEXCONSTE(1.00304308405312125703e+01, 0x4002, 0xa07ca50cL, 0x8df10bebL), 0 },
	{ __LINE__, HEXCONSTE(1.00609546088784810536e+02, 0x4005, 0xc938166cL, 0xc9789000L), HEXCONSTE(1.00304310021446640988e+01, 0x4002, 0xa07ca537L, 0xefeef400L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.00679092407226562500e+02, 0x4005, 0xc95bb200L, 0x00000000L), HEXCONSTE(1.00338971694564700922e+01, 0x4002, 0xa08ad7c2L, 0x23e15144L), 0 },
	{ __LINE__, HEXCONSTE(1.00679084777832031250e+02, 0x4005, 0xc95bb100L, 0x00000000L), HEXCONSTE(1.00338967892754423756e+01, 0x4002, 0xa08ad75cL, 0x1609f282L), 0 },
	{ __LINE__, HEXCONSTE(1.00679091098783786151e+02, 0x4005, 0xc95bb1d4L, 0x188fe800L), HEXCONSTE(1.00338971042553444235e+01, 0x4002, 0xa08ad7b0L, 0xa34afc00L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.01122688293457031250e+02, 0x4005, 0xca3ed100L, 0x00000000L), HEXCONSTE(1.00559777393079501214e+01, 0x4002, 0xa0e548e9L, 0xfa1b46efL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.01122680664062500000e+02, 0x4005, 0xca3ed000L, 0x00000000L), HEXCONSTE(1.00559773599617108524e+01, 0x4002, 0xa0e54884L, 0x25a1a91eL), 0 },
	{ __LINE__, HEXCONSTE(1.01122680958777252158e+02, 0x4005, 0xca3ed009L, 0xe3949800L), HEXCONSTE(1.00559773746154208496e+01, 0x4002, 0xa0e54888L, 0x14a07400L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.01302772521972656250e+02, 0x4005, 0xca9b0500L, 0x00000000L), HEXCONSTE(1.00649278448468102393e+01, 0x4002, 0xa109f1c7L, 0xa3780ff9L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.01302764892578125000e+02, 0x4005, 0xca9b0400L, 0x00000000L), HEXCONSTE(1.00649274658378996682e+01, 0x4002, 0xa109f161L, 0xe62ccb8eL), 0 },
	{ __LINE__, HEXCONSTE(1.01302769128774599494e+02, 0x4005, 0xca9b048eL, 0x24a69000L), HEXCONSTE(1.00649276762813650876e+01, 0x4002, 0xa109f19aL, 0x63bd6400L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(3.74339213057464375341e-23, 0x3fb4, 0xb504f333L, 0xf9de6484L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.45932313565506983983e-307, 0x3c04, 0xb0d82630L, 0x00000000L), HEXCONSTE(4.95915631499458770578e-154, 0x3e01, 0xd4c5c478L, 0xc5a36c00L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(3.74339213057464375341e-23, 0x3fb4, 0xb504f333L, 0xf9de6484L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(5.61095730518040884157e-307, 0x3c05, 0xc9bc4f88L, 0x00000000L), HEXCONSTE(7.49063235326658442303e-154, 0x3e02, 0xa0b15721L, 0xeac10c00L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(3.74339213057464375341e-23, 0x3fb4, 0xb504f333L, 0xf9de6484L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(5.80738879774085240816e-307, 0x3c05, 0xd0cc4da0L, 0x00000000L), HEXCONSTE(7.62062254526548008609e-154, 0x3e02, 0xa37b39b7L, 0x5a25dc00L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(3.74339213057464375341e-23, 0x3fb4, 0xb504f333L, 0xf9de6484L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(7.02613708047142671466e-307, 0x3c05, 0xfc9de480L, 0x00000000L), HEXCONSTE(8.38220560501317380697e-154, 0x3e02, 0xb3d1b762L, 0x01dd7400L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(3.74339213057464375341e-23, 0x3fb4, 0xb504f333L, 0xf9de6484L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(8.43869776919497200685e-307, 0x3c06, 0x97b3af18L, 0x00000000L), HEXCONSTE(9.18623849526832827432e-154, 0x3e02, 0xc51155b6L, 0xe7f70c00L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(3.74339213057464375341e-23, 0x3fb4, 0xb504f333L, 0xf9de6484L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.16077925158367948812e-306, 0x3c06, 0xd0ac2840L, 0x00000000L), HEXCONSTE(1.07739465915869449706e-153, 0x3e02, 0xe720c54bL, 0x67ac4c00L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(3.74339213057464375341e-23, 0x3fb4, 0xb504f333L, 0xf9de6484L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.28274138274231933813e-306, 0x3c06, 0xe698f83cL, 0x00000000L), HEXCONSTE(1.13258173336069628584e-153, 0x3e02, 0xf2f78e32L, 0xee675c00L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(3.74339213057464375341e-23, 0x3fb4, 0xb504f333L, 0xf9de6484L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.71166045960874566820e-306, 0x3c07, 0x99da1d84L, 0x00000000L), HEXCONSTE(1.30830442161170794856e-153, 0x3e03, 0x8c54fb03L, 0xf0b80c00L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(3.74339213057464375341e-23, 0x3fb4, 0xb504f333L, 0xf9de6484L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.03817325168699408556e-306, 0x3c07, 0xb733542cL, 0x00000000L), HEXCONSTE(1.42764605266396267420e-153, 0x3e03, 0x99220150L, 0x05a2f400L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(3.74339213057464375341e-23, 0x3fb4, 0xb504f333L, 0xf9de6484L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.17157206085693087211e-306, 0x3c07, 0xc330e5fcL, 0x00000000L), HEXCONSTE(1.47362548188368772930e-153, 0x3e03, 0x9e109023L, 0x5feff400L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(3.74339213057464375341e-23, 0x3fb4, 0xb504f333L, 0xf9de6484L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.46813996318040944798e-306, 0x3c07, 0xddd910daL, 0x00000000L), HEXCONSTE(1.57103149655899943319e-153, 0x3e03, 0xa88340dcL, 0x9cc98400L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(3.74339213057464375341e-23, 0x3fb4, 0xb504f333L, 0xf9de6484L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.51755339642005880740e-306, 0x3c07, 0xe24a179eL, 0x00000000L), HEXCONSTE(1.58667999181311251814e-153, 0x3e03, 0xaa30f2c9L, 0x13d5ac00L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(3.74339213057464375341e-23, 0x3fb4, 0xb504f333L, 0xf9de6484L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.64615054688296252900e-306, 0x3c07, 0xedd92c64L, 0x00000000L), HEXCONSTE(1.62669927979419801822e-153, 0x3e03, 0xae7bd87bL, 0xc69d7400L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(3.74339213057464375341e-23, 0x3fb4, 0xb504f333L, 0xf9de6484L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.81670763677204134715e-306, 0x3c08, 0xab881f52L, 0x00000000L), HEXCONSTE(1.95363958722483952101e-153, 0x3e03, 0xd18d5ca3L, 0x69a05400L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(3.74339213057464375341e-23, 0x3fb4, 0xb504f333L, 0xf9de6484L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(4.57432207785627657865e-306, 0x3c08, 0xcd94a7c4L, 0x00000000L), HEXCONSTE(2.13876648511619345940e-153, 0x3e03, 0xe568cbf1L, 0x4742d400L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(1.00000005960464299903e+00, 0x3fff, 0x8000007fL, 0xffffc000L), 0 },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(1.00000000000000011102e+00, 0x3fff, 0x80000000L, 0x00000400L), 0 },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(9.99999970197677168215e-01, 0x3ffe, 0xffffff7fL, 0xffffe000L), 0 },
	{ __LINE__, HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(9.99999999999999944489e-01, 0x3ffe, 0xffffffffL, 0xfffffc00L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.84467435239537295360e+19, 0x403e, 0xffffff7fL, 0xffffe000L), 0 },
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.34078079299425963553e+154, 0x41fe, 0xffffffffL, 0xfffffc00L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.09074813561941592940e+2466, 0x5ffe, 0xffffffffL, 0xffffffffL), 0 },
	{ __LINE__, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(1.08420217248550443401e-19, 0x3fc0, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(1.49166814624004134866e-154, 0x3e00, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(1.83360386755484716562e-2466, 0x2000, 0x80000000L, 0x00000000L), 0 },
#if defined(TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(9.16801933777423582811e-2467, 0x1fff, 0x80000000L, 0x00000000L), FLAG_SUBNORM },
	{ __LINE__, SUBNORM_P, HEXCONSTE(4.26919168689019783778e-2476, 0x1fe0, 0x80000000L, 0x00000000L), FLAG_SUBNORM },
#endif
#if defined(TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16381)
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(1.29655372875791258242e-2466, 0x1fff, 0xb504f333L, 0xf9de6484L), FLAG_SUBNORM },
	{ __LINE__, SUBNORM_P, HEXCONSTE(6.03754878397058966765e-2476, 0x1fe0, 0xb504f333L, 0xf9de6484L), FLAG_SUBNORM },
#endif
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(1.41568653310292274528e-146, 0x3e1a, 0xb504f333L, 0xf9de6484L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(3.74339213057464375341e-23, 0x3fb4, 0xb504f333L, 0xf9de6484L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(2.22275874948507748344e-162, 0x3de6, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, SUBNORM_P, HEXCONSTE(4.26919168689019783778e-2476, 0x1fe0, 0x80000000L, 0x00000000L), FLAG_SUBNORM },
#endif
};

int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_f_f(fsqrt_data, ARRAY_SIZE(fsqrt_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

```

`tests/tan.c`:

```c
#include "testconfig.h"
#define TEST_FUNC_F_F __MATH_PRECNAME(tan)
#include "testdriver.h"



static test_f_f_data const ftan_data[] = {
	{ __LINE__, ZERO_P, ZERO_P, 0 },
	{ __LINE__, ZERO_M, ZERO_M, FLAG_IGNORE_ZEROSIGN },
	{ __LINE__, INF_P, QNAN_P, 0 },
	{ __LINE__, INF_M, QNAN_P, 0 },
	{ __LINE__, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_P, 0 },
	{ __LINE__, SNAN_P, QNAN_P, 0 },
	{ __LINE__, SNAN_M, QNAN_P, 0 },
	{ __LINE__, SUBNORM_M, SUBNORM_M, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_P, SUBNORM_P, FLAG_SUBNORM },

	{ __LINE__, HEXCONSTE(7.85398185253143310547e-01, 0x3ffe, 0xc90fdb00L, 0x00000000L), HEXCONSTE(1.00000004371139095724e+00, 0x3fff, 0x8000005dL, 0xde976037L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.85398125648498535156e-01, 0x3ffe, 0xc90fda00L, 0x00000000L), HEXCONSTE(9.99999924502103301044e-01, 0x3ffe, 0xfffffebbL, 0xbd2f48f3L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.85398163397448390022e-01, 0x3ffe, 0xc90fdaa2L, 0x2168c800L), HEXCONSTE(1.00000000000000016079e+00, 0x3fff, 0x80000000L, 0x000005cbL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.85398163397448278999e-01, 0x3ffe, 0xc90fdaa2L, 0x2168c000L), HEXCONSTE(9.99999999999999938743e-01, 0x3ffe, 0xffffffffL, 0xfffffb96L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.85398163397448309628e-01, 0x3ffe, 0xc90fdaa2L, 0x2168c235L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(7.85398163397448309574e-01, 0x3ffe, 0xc90fdaa2L, 0x2168c234L), HEXCONSTE(9.99999999999999999892e-01, 0x3ffe, 0xffffffffL, 0xfffffffeL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.57079637050628662109e+00, 0x3fff, 0xc90fdb00L, 0x00000000L), HEXCONSTE(-2.28773324288564598737e+07, 0xc017, 0xae8a4a36L, 0xe4bbda07L), FLAG_INEXACT4 }, /* c017:ae8a4a36:e4c4baeb */
	{ __LINE__, HEXCONSTE(1.57079625129699707031e+00, 0x3fff, 0xc90fda00L, 0x00000000L), HEXCONSTE(1.32454016068625678863e+07, 0x4016, 0xca1bd99bL, 0x5b5e560aL), FLAG_INEXACT4 }, /* 4016:ca1bd99b:5b58623d */
	{ __LINE__, HEXCONSTE(1.57079632679489678004e+00, 0x3fff, 0xc90fdaa2L, 0x2168c800L), HEXCONSTE(-6.21843116382373801758e+15, 0xc033, 0xb0bc78fdL, 0x05d3363dL), FLAG_INEXACT4 }, /* c033:b0bd0aa4:a3b3d024 */
	{ __LINE__, HEXCONSTE(1.57079632679489655800e+00, 0x3fff, 0xc90fdaa2L, 0x2168c000L), HEXCONSTE(1.63312393531953697559e+16, 0x4034, 0xe816aa36L, 0x9f558f5bL), FLAG_INEXACT4 }, /* 4034:e814b3e1:8e6da706 */
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(1.57079632679489661926e+00, 0x3fff, 0xc90fdaa2L, 0x2168c235L), HEXCONSTE(-3.98679762981171070680e+19, 0xc040, 0x80000000L, 0x00000000L), FLAG_INEXACT4 }, /* c040:8a51e04d:aabda35f */
	{ __LINE__, HEXCONSTE(1.57079632679489661915e+00, 0x3fff, 0xc90fdaa2L, 0x2168c234L), HEXCONSTE(1.19994102263174429330e+19, 0x403e, 0xaaaaaaaaL, 0xaaaaaaabL), FLAG_INEXACT4 }, /* 403e:a6867806:75d73f75 */
#endif
	{ __LINE__, HEXCONSTE(-1.57079637050628662109e+00, 0xbfff, 0xc90fdb00L, 0x00000000L), HEXCONSTE(2.28773324288564598737e+07, 0x4017, 0xae8a4a36L, 0xe4bbda07L), FLAG_INEXACT4 }, /* 4017:ae8a4a36:e4c4baeb */
	{ __LINE__, HEXCONSTE(-1.57079625129699707031e+00, 0xbfff, 0xc90fda00L, 0x00000000L), HEXCONSTE(-1.32454016068625678863e+07, 0xc016, 0xca1bd99bL, 0x5b58623dL), FLAG_INEXACT4 }, /* c016:ca1bd99b:5b58623d */
	{ __LINE__, HEXCONSTE(-1.57079632679489678004e+00, 0xbfff, 0xc90fdaa2L, 0x2168c800L), HEXCONSTE(6.21843116382373801758e+15, 0x4033, 0xb0bc78fdL, 0x05d3363dL), FLAG_INEXACT4 }, /* 4033:b0bd0aa4:a3b3d024 */
	{ __LINE__, HEXCONSTE(-1.57079632679489655800e+00, 0xbfff, 0xc90fdaa2L, 0x2168c000L), HEXCONSTE(-1.63312393531953697559e+16, 0xc034, 0xe816aa36L, 0x9f558f5bL), FLAG_INEXACT4 }, /* c034:e814b3e1:8e6da706 */
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(-1.57079632679489661926e+00, 0xbfff, 0xc90fdaa2L, 0x2168c235L), HEXCONSTE(3.98679762981171070680e+19, 0x4040, 0x80000000L, 0x00000000L), FLAG_INEXACT4 }, /* 4040:8a51e04d:aabda35f */
	{ __LINE__, HEXCONSTE(-1.57079632679489661915e+00, 0xbfff, 0xc90fdaa2L, 0x2168c234L), HEXCONSTE(-1.19994102263174429330e+19, 0xc03e, 0xaaaaaaaaL, 0xaaaaaaabL), FLAG_INEXACT4 }, /* c03e:a6867806:75d73f75 */
#endif
	{ __LINE__, HEXCONSTE(7.50000000000000000000e-01, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(9.31596459944072461160e-01, 0x3ffe, 0xee7d1b08L, 0x87775f05L), FLAG_INEXACT2 },
#if 0
	{ __LINE__, HEXCONSTE(3.68934881474191032320e+19, 0x4040, 0x80000000L, 0x00000000L), HEXCONSTE(-4.72364872359047946782e-02, 0x3ff3, 0x9b17d8d7L, 0xc01ece1bL), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* bffa:c17b0bfd:b2b8061e */
	{ __LINE__, HEXCONSTE(-3.68934881474191032320e+19, 0xc040, 0x80000000L, 0x00000000L), HEXCONSTE(4.72364872359047946782e-02, 0xbff3, 0x9b17d8d7L, 0xc01ece1bL), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* 3ffa:c17b0bfd:b2b8061e */
#endif
	{ __LINE__, HEXCONSTE(7.45058059692382812500e-09, 0x3fe4, 0x80000000L, 0x00000000L), HEXCONSTE(7.45058059692382826313e-09, 0x3fe4, 0x80000000L, 0x000000abL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-7.45058059692382812500e-09, 0xbfe4, 0x80000000L, 0x00000000L), HEXCONSTE(-7.45058059692382826313e-09, 0xbfe4, 0x80000000L, 0x000000abL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(7.85156250000000000000e-01, 0x3ffe, 0xc9000000L, 0x00000000L), HEXCONSTE(9.99516290211545781826e-01, 0x3ffe, 0xffe04cb2L, 0x472021f1L), FLAG_INEXACT3 }, /* 3ffe:ffe04cb2:472021f2 */
	{ __LINE__, HEXCONSTE(7.85278320312500000000e-01, 0x3ffe, 0xc9080000L, 0x00000000L), HEXCONSTE(9.99760342550244141089e-01, 0x3ffe, 0xfff04b37L, 0x174f6f34L), FLAG_INEXACT3 }, /* 3ffe:fff04b37:174f6f35 */
	{ __LINE__, HEXCONSTE(7.85339355468750000000e-01, 0x3ffe, 0xc90c0000L, 0x00000000L), HEXCONSTE(9.99882391058806030285e-01, 0x3ffe, 0xfff84ad9L, 0x71a07663L), FLAG_INEXACT3 }, /* 3ffe:fff84ad9:71a07664 */
	{ __LINE__, HEXCONSTE(7.85369873046875000000e-01, 0x3ffe, 0xc90e0000L, 0x00000000L), HEXCONSTE(9.99943420899480875331e-01, 0x3ffe, 0xfffc4ac2L, 0x9d1711ccL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.85385131835937500000e-01, 0x3ffe, 0xc90f0000L, 0x00000000L), HEXCONSTE(9.99973937216615670228e-01, 0x3ffe, 0xfffe4abdL, 0x329de183L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.85392761230468750000e-01, 0x3ffe, 0xc90f8000L, 0x00000000L), HEXCONSTE(9.99989195724407276499e-01, 0x3ffe, 0xffff4abbL, 0xfd5b29a3L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.85396575927734375000e-01, 0x3ffe, 0xc90fc000L, 0x00000000L), HEXCONSTE(9.99996825065612240295e-01, 0x3ffe, 0xffffcabbL, 0xc2b925c1L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.85397529602050781250e-01, 0x3ffe, 0xc90fd000L, 0x00000000L), HEXCONSTE(9.99998732410008335807e-01, 0x3ffe, 0xffffeabbL, 0xbe109e1fL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.85398006439208984375e-01, 0x3ffe, 0xc90fd800L, 0x00000000L), HEXCONSTE(9.99999686083570621278e-01, 0x3ffe, 0xfffffabbL, 0xbd3c59feL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.85398125648498535156e-01, 0x3ffe, 0xc90fda00L, 0x00000000L), HEXCONSTE(9.99999924502103301044e-01, 0x3ffe, 0xfffffebbL, 0xbd2f48f3L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.89062500000000000000e-01, 0x3ffe, 0xca000000L, 0x00000000L), HEXCONSTE(1.00735565974072721650e+00, 0x3fff, 0x80f107bfL, 0x03725a03L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.87109375000000000000e-01, 0x3ffe, 0xc9800000L, 0x00000000L), HEXCONSTE(1.00342829308630446543e+00, 0x3fff, 0x8070569bL, 0x57e86d1bL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(7.86132812500000000000e-01, 0x3ffe, 0xc9400000L, 0x00000000L), HEXCONSTE(1.00147037868200822371e+00, 0x3fff, 0x80302e6eL, 0x2d0d0e0fL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(7.85644531250000000000e-01, 0x3ffe, 0xc9200000L, 0x00000000L), HEXCONSTE(1.00049285713923005714e+00, 0x3fff, 0x80102662L, 0xa5b53afeL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(7.85400390625000000000e-01, 0x3ffe, 0xc9100000L, 0x00000000L), HEXCONSTE(1.00000445446502449535e+00, 0x3fff, 0x8000255dL, 0xe40b839eL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(7.85398483276367187500e-01, 0x3ffe, 0xc90fe000L, 0x00000000L), HEXCONSTE(1.00000063975804240086e+00, 0x3fff, 0x8000055dL, 0xdeb40ae9L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(7.85398244857788085938e-01, 0x3ffe, 0xc90fdc00L, 0x00000000L), HEXCONSTE(1.00000016292069282423e+00, 0x3fff, 0x8000015dL, 0xde991bf4L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.85398185253143310547e-01, 0x3ffe, 0xc90fdb00L, 0x00000000L), HEXCONSTE(1.00000004371139095724e+00, 0x3fff, 0x8000005dL, 0xde976037L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.85156250000000000000e-01, 0xbffe, 0xc9000000L, 0x00000000L), HEXCONSTE(-9.99516290211545781826e-01, 0xbffe, 0xffe04cb2L, 0x472021f2L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.85278320312500000000e-01, 0xbffe, 0xc9080000L, 0x00000000L), HEXCONSTE(-9.99760342550244141089e-01, 0xbffe, 0xfff04b37L, 0x174f6f35L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.85339355468750000000e-01, 0xbffe, 0xc90c0000L, 0x00000000L), HEXCONSTE(-9.99882391058806030285e-01, 0xbffe, 0xfff84ad9L, 0x71a07664L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.85369873046875000000e-01, 0xbffe, 0xc90e0000L, 0x00000000L), HEXCONSTE(-9.99943420899480875331e-01, 0xbffe, 0xfffc4ac2L, 0x9d1711ccL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.85385131835937500000e-01, 0xbffe, 0xc90f0000L, 0x00000000L), HEXCONSTE(-9.99973937216615670228e-01, 0xbffe, 0xfffe4abdL, 0x329de183L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.85392761230468750000e-01, 0xbffe, 0xc90f8000L, 0x00000000L), HEXCONSTE(-9.99989195724407276499e-01, 0xbffe, 0xffff4abbL, 0xfd5b29a3L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.85396575927734375000e-01, 0xbffe, 0xc90fc000L, 0x00000000L), HEXCONSTE(-9.99996825065612240295e-01, 0xbffe, 0xffffcabbL, 0xc2b925c1L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.85397529602050781250e-01, 0xbffe, 0xc90fd000L, 0x00000000L), HEXCONSTE(-9.99998732410008335807e-01, 0xbffe, 0xffffeabbL, 0xbe109e1fL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.85398006439208984375e-01, 0xbffe, 0xc90fd800L, 0x00000000L), HEXCONSTE(-9.99999686083570621278e-01, 0xbffe, 0xfffffabbL, 0xbd3c59feL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.85398125648498535156e-01, 0xbffe, 0xc90fda00L, 0x00000000L), HEXCONSTE(-9.99999924502103301044e-01, 0xbffe, 0xfffffebbL, 0xbd2f48f3L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.89062500000000000000e-01, 0xbffe, 0xca000000L, 0x00000000L), HEXCONSTE(-1.00735565974072721650e+00, 0xbfff, 0x80f107bfL, 0x03725a03L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.87109375000000000000e-01, 0xbffe, 0xc9800000L, 0x00000000L), HEXCONSTE(-1.00342829308630446543e+00, 0xbfff, 0x8070569bL, 0x57e86d1bL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.86132812500000000000e-01, 0xbffe, 0xc9400000L, 0x00000000L), HEXCONSTE(-1.00147037868200822371e+00, 0xbfff, 0x80302e6eL, 0x2d0d0e0fL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.85644531250000000000e-01, 0xbffe, 0xc9200000L, 0x00000000L), HEXCONSTE(-1.00049285713923005714e+00, 0xbfff, 0x80102662L, 0xa5b53afeL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.85400390625000000000e-01, 0xbffe, 0xc9100000L, 0x00000000L), HEXCONSTE(-1.00000445446502449535e+00, 0xbfff, 0x8000255dL, 0xe40b839eL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.85398483276367187500e-01, 0xbffe, 0xc90fe000L, 0x00000000L), HEXCONSTE(-1.00000063975804240086e+00, 0xbfff, 0x8000055dL, 0xdeb40ae9L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.85398244857788085938e-01, 0xbffe, 0xc90fdc00L, 0x00000000L), HEXCONSTE(-1.00000016292069282423e+00, 0xbfff, 0x8000015dL, 0xde991bf4L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-7.85398185253143310547e-01, 0xbffe, 0xc90fdb00L, 0x00000000L), HEXCONSTE(-1.00000004371139095724e+00, 0xbfff, 0x8000005dL, 0xde976037L), FLAG_INEXACT3 },
#if 0
	{ __LINE__, HEXCONSTE(1.00000009040962152038e+22, 0x4048, 0x87867900L, 0x00000000L), HEXCONSTE(-3.14680716922883491765e-01, 0x3ff6, 0xbe838f2fL, 0x91a2bb15L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* bffd:a11dd4b7:bb32541a */
	{ __LINE__, HEXCONSTE(9.99999977819630836122e+21, 0x4048, 0x87867800L, 0x00000000L), HEXCONSTE(-1.08102390048654640640e+00, 0xbffe, 0x9166ad50L, 0xc4461ff7L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* bfff:8a5efdbd:645c945d */
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+22, 0x4048, 0x87867832L, 0x6eac9000L), HEXCONSTE(-1.62877822560689887856e+00, 0xbffe, 0xdd1c4380L, 0xfe2e929eL), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* bfff:d07bce0d:b592bba5 */
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-6.11797949834248061182e-01, 0xc000, 0xc8c34476L, 0x95a35cddL), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* bffe:9c9eca5a:4c460f93 */
	{ __LINE__, HEXCONSTE(8.98846567431157953865e+307, 0x43fe, 0x80000000L, 0x00000000L), HEXCONSTE(-6.81447647606621501287e-01, 0xc000, 0x9a0006baL, 0x40ac7102L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* bffe:ae735a60:68151a9e */
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-6.11797949834248061182e-01, 0xc000, 0xc8c34476L, 0x95a35cddL), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* bffe:9c9eca5a:4c460f93 */
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-4.96201587444489490058e-03, 0x3fff, 0xa820a48bL, 0xbe4ad518L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* bff7:a29867f3:94a41dc7 */
	{ __LINE__, HEXCONSTE(5.94865747678615882543e+4931, 0x7ffe, 0x80000000L, 0x00000000L), HEXCONSTE(4.22722393732022337789e-01, 0x4001, 0x9b2555fdL, 0x81e76442L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* 3ffd:d86f11d0:bb537c9f */
#endif
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.55740772465490223046e+00, 0x3fff, 0xc75922e5L, 0xf71d2dc5L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-2.18503986326151899175e+00, 0xc000, 0x8bd7b170L, 0x4a87c1dbL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(3.00000000000000000000e+00, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(-1.42546543074277805291e-01, 0xbffc, 0x91f7b892L, 0xa5c37866L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(4.00000000000000000000e+00, 0x4001, 0x80000000L, 0x00000000L), HEXCONSTE(1.15782128234957758315e+00, 0x3fff, 0x94337cdfL, 0x26f09b87L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(5.00000000000000000000e+00, 0x4001, 0xa0000000L, 0x00000000L), HEXCONSTE(-3.38051500624658563692e+00, 0xc000, 0xd85a5b9cL, 0xddd83421L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(6.00000000000000000000e+00, 0x4001, 0xc0000000L, 0x00000000L), HEXCONSTE(-2.91006191384749157063e-01, 0xbffd, 0x94fec375L, 0xdcadf182L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(7.00000000000000000000e+00, 0x4001, 0xe0000000L, 0x00000000L), HEXCONSTE(8.71447982724318736451e-01, 0x3ffe, 0xdf173709L, 0xf753c4c1L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(8.00000000000000000000e+00, 0x4002, 0x80000000L, 0x00000000L), HEXCONSTE(-6.79971145522037869998e+00, 0xc001, 0xd9973c7aL, 0x4d0f1d39L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(9.00000000000000000000e+00, 0x4002, 0x90000000L, 0x00000000L), HEXCONSTE(-4.52315659441809840596e-01, 0xbffd, 0xe795eb09L, 0x8ae0df01L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+01, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(6.48360827459086671264e-01, 0x3ffe, 0xa5faf9a5L, 0xf1bc12f0L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-1.02408266067504882812e+00, 0xbfff, 0x83152400L, 0x00000000L), HEXCONSTE(-1.64313524714176713022e+00, 0xbfff, 0xd252417aL, 0xb07b7267L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-1.31020736694335937500e+00, 0xbfff, 0xa7b4e000L, 0x00000000L), HEXCONSTE(-3.75020232812174444817e+00, 0xc000, 0xf00350a0L, 0x2a9efb7aL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(1.42443704605102539062e+00, 0x3fff, 0xb653f400L, 0x00000000L), HEXCONSTE(6.78364522457327409144e+00, 0x4001, 0xd9139f26L, 0x66ae63b5L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-1.70864486694335937500e+00, 0xbfff, 0xdab4e000L, 0x00000000L), HEXCONSTE(7.20833087491041078158e+00, 0x4001, 0xe6aaa582L, 0xcf97ced2L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-2.07316565513610839844e+00, 0xc000, 0x84aebf00L, 0x00000000L), HEXCONSTE(1.82022401449273296551e+00, 0x3fff, 0xe8fd19baL, 0xd1ef63f4L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(2.03560495376586914062e+00, 0x4000, 0x82475a00L, 0x00000000L), HEXCONSTE(-1.99420835595249289825e+00, 0xbfff, 0xff42382bL, 0x1ce9c3b9L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-5.18815183639526367188e+00, 0xc001, 0xa6055700L, 0x00000000L), HEXCONSTE(1.94085400773404880253e+00, 0x3fff, 0xf86de774L, 0xc39e5f97L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-5.18815231323242187500e+00, 0xc001, 0xa6055800L, 0x00000000L), HEXCONSTE(1.94085173469429407838e+00, 0x3fff, 0xf86dd463L, 0x72cc5c99L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-5.18815193733241741825e+00, 0xc001, 0xa6055736L, 0x30b26000L), HEXCONSTE(1.94085352657538355440e+00, 0x3fff, 0xf86de36bL, 0x7bd85373L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-5.18815193733241830643e+00, 0xc001, 0xa6055736L, 0x30b26800L), HEXCONSTE(1.94085352657537932048e+00, 0x3fff, 0xf86de36bL, 0x7bd7bae8L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-5.18815193733241794907e+00, 0xc001, 0xa6055736L, 0x30b264c8L), HEXCONSTE(1.94085352657538102398e+00, 0x3fff, 0xf86de36bL, 0x7bd7f848L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(1.10478901863098144531e+00, 0x3fff, 0x8d69ba00L, 0x00000000L), HEXCONSTE(1.98825690274209654069e+00, 0x3fff, 0xfe7f33c2L, 0xa96a53e6L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-1.05208921432495117188e+00, 0xbfff, 0x86aadc00L, 0x00000000L), HEXCONSTE(-1.75178481602246248624e+00, 0xbfff, 0xe03a7c1fL, 0x3911b78dL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(1.57079708576202392578e+00, 0x3fff, 0xc90fe100L, 0x00000000L), HEXCONSTE(-1.31758012174867739395e+06, 0xc013, 0xa0d660f9L, 0x575e6548L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* c013:a0d660f9:575edde */
	{ __LINE__, HEXCONSTE(1.57079696655273437500e+00, 0x3fff, 0xc90fe000L, 0x00000000L), HEXCONSTE(-1.56309144020462858066e+06, 0xc013, 0xbece9b85L, 0x8a0070a5L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* c013:bece9b85:8a011a6 */
	{ __LINE__, HEXCONSTE(1.57079697000000018114e+00, 0x3fff, 0xc90fe007L, 0x67278800L), HEXCONSTE(-1.55471403205930036495e+06, 0xc013, 0xbdc8d041L, 0xa84dccd8L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* c013:bdc8d041:a84e74c */
	{ __LINE__, HEXCONSTE(1.57079696999999995910e+00, 0x3fff, 0xc90fe007L, 0x67278000L), HEXCONSTE(-1.55471403259601231139e+06, 0xc013, 0xbdc8d042L, 0xc1b20ee8L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* c013:bdc8d042:c1b2b6dc */
#if 0
	{ __LINE__, HEXCONSTE(1.57079697000000000008e+00, 0x3fff, 0xc90fe007L, 0x6727817aL), HEXCONSTE(-1.55471403249695121974e+06, 0xc013, 0xbdc8d042L, 0x8dc24db6L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* c013:bdc8d042:8dc2f5ab */
	{ __LINE__, HEXCONSTE(1.57079696999999999997e+00, 0x3fff, 0xc90fe007L, 0x67278179L), HEXCONSTE(-1.55471403249721328609e+06, 0xc013, 0xbdc8d042L, 0x8de57a3eL), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* c013:bdc8d042:8de62233 */
#endif
	{ __LINE__, HEXCONSTE(-1.57079696655273437500e+00, 0xbfff, 0xc90fe000L, 0x00000000L), HEXCONSTE(1.56309144020462858066e+06, 0x4013, 0xbece9b85L, 0x8a0070a5L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* 4013:bece9b85:8a011a6a */
	{ __LINE__, HEXCONSTE(-1.57079708576202392578e+00, 0xbfff, 0xc90fe100L, 0x00000000L), HEXCONSTE(1.31758012174867739395e+06, 0x4013, 0xa0d660f9L, 0x575e6548L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* 4013:a0d660f9:575edde8 */
	{ __LINE__, HEXCONSTE(-1.57079696999999995910e+00, 0xbfff, 0xc90fe007L, 0x67278000L), HEXCONSTE(1.55471403259601231139e+06, 0x4013, 0xbdc8d042L, 0xc1b20ee8L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* 4013:bdc8d042:c1b2b6dc */
	{ __LINE__, HEXCONSTE(-1.57079697000000018114e+00, 0xbfff, 0xc90fe007L, 0x67278800L), HEXCONSTE(1.55471403205930036495e+06, 0x4013, 0xbdc8d041L, 0xa84dccd8L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* 4013:bdc8d041:a84e74cd */
#if 0
	{ __LINE__, HEXCONSTE(-1.57079696999999999997e+00, 0xbfff, 0xc90fe007L, 0x67278179L), HEXCONSTE(1.55471403249721328609e+06, 0x4013, 0xbdc8d042L, 0x8de57a3eL), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* 4013:bdc8d042:8de62233 */
	{ __LINE__, HEXCONSTE(-1.57079697000000000008e+00, 0xbfff, 0xc90fe007L, 0x6727817aL), HEXCONSTE(1.55471403249695121974e+06, 0x4013, 0xbdc8d042L, 0x8dc24db6L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* 4013:bdc8d042:8dc2f5ab */
#endif
	{ __LINE__, HEXCONSTE(3.12500000000000000000e-02, 0x3ffa, 0x80000000L, 0x00000000L), HEXCONSTE(3.12601765012559564221e-02, 0x3ffa, 0x800aabbbL, 0xd76042bfL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(9.76562500000000000000e-04, 0x3ff5, 0x80000000L, 0x00000000L), HEXCONSTE(9.76562810440976628977e-04, 0x3ff5, 0x800002aaL, 0xaabbbbbcL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(3.05175781250000000000e-05, 0x3ff0, 0x80000000L, 0x00000000L), HEXCONSTE(3.05175781344739031479e-05, 0x3ff0, 0x80000000L, 0xaaaaaaacL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(9.53674316406250000000e-07, 0x3feb, 0x80000000L, 0x00000000L), HEXCONSTE(9.53674316406539120614e-07, 0x3feb, 0x80000000L, 0x002aaaabL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(2.98023223876953125000e-08, 0x3fe6, 0x80000000L, 0x00000000L), HEXCONSTE(2.98023223876953213243e-08, 0x3fe6, 0x80000000L, 0x00000aabL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(9.31322574615478515625e-10, 0x3fe1, 0x80000000L, 0x00000000L), HEXCONSTE(9.31322574615478515928e-10, 0x3fe1, 0x80000000L, 0x00000003L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(2.91038304567337036133e-11, 0x3fdc, 0x80000000L, 0x00000000L), HEXCONSTE(2.91038304567337036133e-11, 0x3fdc, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9.09494701772928237915e-13, 0x3fd7, 0x80000000L, 0x00000000L), HEXCONSTE(9.09494701772928237915e-13, 0x3fd7, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.84217094304040074348e-14, 0x3fd2, 0x80000000L, 0x00000000L), HEXCONSTE(2.84217094304040074348e-14, 0x3fd2, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(8.88178419700125232339e-16, 0x3fcd, 0x80000000L, 0x00000000L), HEXCONSTE(8.88178419700125232339e-16, 0x3fcd, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.77555756156289135106e-17, 0x3fc8, 0x80000000L, 0x00000000L), HEXCONSTE(2.77555756156289135106e-17, 0x3fc8, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(8.67361737988403547206e-19, 0x3fc3, 0x80000000L, 0x00000000L), HEXCONSTE(8.67361737988403547206e-19, 0x3fc3, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(7.88860905221011805412e-31, 0x3f9b, 0x80000000L, 0x00000000L), HEXCONSTE(7.88860905221011805412e-31, 0x3f9b, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.40991986510288411774e-181, 0x3da7, 0x80000000L, 0x00000000L), HEXCONSTE(2.40991986510288411774e-181, 0x3da7, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(5.01237274920645200930e-3011, 0x18ef, 0x80000000L, 0x00000000L), HEXCONSTE(5.01237274920645200930e-3011, 0x18ef, 0x80000000L, 0x00000000L), 0 },
#if 0
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(-6.11797949834248061182e-01, 0xc000, 0xc8c34476L, 0x95a35cddL), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* bffe:9c9eca5a:4c460f93 */
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-4.96201587444489490058e-03, 0x3fff, 0xa820a48bL, 0xbe4ad518L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* bff7:a29867f3:94a41dc7 */
#endif
#if defined(TEST_LDOUBLE) && __LDBL_MAX_EXP__ >= (16381)
	{ __LINE__, HEXCONSTE(1.18973149535723176502e+4932, 0x7ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-7.93436651174057592855e+00, 0xbffb, 0xd67de6dcL, 0xf70ec995L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* c001:fde65499:4ce86fdb */
	{ __LINE__, HEXCONSTE(-1.18973149535723176502e+4932, 0xfffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(7.93436651174057592855e+00, 0x3ffb, 0xd67de6dcL, 0xf70ec995L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* 4001:fde65499:4ce86fdb */
#endif
#if 0
	{ __LINE__, HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(6.11797949834248061182e-01, 0x4000, 0xc8c34476L, 0x95a35cddL), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* 3ffe:9c9eca5a:4c460f93 */
	{ __LINE__, HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(4.96201587444489490058e-03, 0xbfff, 0xa820a48bL, 0xbe4ad518L), FLAG_INEXACT3|FLAG_FAIL_X87 }, /* 3ff7:a29867f3:94a41dc7 */
#endif
	{ __LINE__, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), 0 },
#if defined(TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16381)
	{ __LINE__, HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), 0 },
#endif
#if defined(TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), 0 },
#if defined(TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16381)
	{ __LINE__, HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), 0 },
#endif
#if defined(TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), 0 },
#if defined(TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16381)
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), 0 },
	{ __LINE__, HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), 0 },
#endif
	{ __LINE__, HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), 0 },
};

int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_f_f(ftan_data, ARRAY_SIZE(ftan_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

```

`tests/tanh.c`:

```c
#include "testconfig.h"
#define TEST_FUNC_F_F __MATH_PRECNAME(tanh)
#include "testdriver.h"



static test_f_f_data const ftanh_data[] = {
	{ __LINE__, ZERO_P, ZERO_P, 0 },
	{ __LINE__, ZERO_M, ZERO_M, FLAG_FAIL_ARANYM2 },
	{ __LINE__, INF_P, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), FLAG_XFAIL_LINUX },
	{ __LINE__, INF_M, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), FLAG_XFAIL_LINUX },
	{ __LINE__, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_P, 0 },
	{ __LINE__, SNAN_P, QNAN_P, 0 },
	{ __LINE__, SNAN_M, QNAN_P, 0 },

	{ __LINE__, HEXCONSTE(7.50000000000000000000e-01, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(6.35148952387287319223e-01, 0x3ffe, 0xa2991f2aL, 0x9791413aL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-7.50000000000000000000e-01, 0xbffe, 0xc0000000L, 0x00000000L), HEXCONSTE(-6.35148952387287319223e-01, 0xbffe, 0xa2991f2aL, 0x9791413aL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(7.61594155955764888109e-01, 0x3ffe, 0xc2f7d5a8L, 0xa79ca2acL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-7.61594155955764888109e-01, 0xbffe, 0xc2f7d5a8L, 0xa79ca2acL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.00000000000000000000e+00, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(9.64027580075816883953e-01, 0x3ffe, 0xf6ca82f0L, 0xde1e9e9aL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-2.00000000000000000000e+00, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(-9.64027580075816883953e-01, 0xbffe, 0xf6ca82f0L, 0xde1e9e9aL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.00000000000000000000e+00, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(9.95054753686730451313e-01, 0x3ffe, 0xfebbe888L, 0xd057ff10L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-3.00000000000000000000e+00, 0xc000, 0xc0000000L, 0x00000000L), HEXCONSTE(-9.95054753686730451313e-01, 0xbffe, 0xfebbe888L, 0xd057ff10L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(4.00000000000000000000e+00, 0x4001, 0x80000000L, 0x00000000L), HEXCONSTE(9.99329299739067043783e-01, 0x3ffe, 0xffd40b84L, 0x505a10b4L), 0 },
	{ __LINE__, HEXCONSTE(-4.00000000000000000000e+00, 0xc001, 0x80000000L, 0x00000000L), HEXCONSTE(-9.99329299739067043783e-01, 0xbffe, 0xffd40b84L, 0x505a10b4L), 0 },
	{ __LINE__, HEXCONSTE(5.00000000000000000000e+00, 0x4001, 0xa0000000L, 0x00000000L), HEXCONSTE(9.99909204262595131211e-01, 0x3ffe, 0xfffa0cb3L, 0x46f889a8L), 0 },
	{ __LINE__, HEXCONSTE(-5.00000000000000000000e+00, 0xc001, 0xa0000000L, 0x00000000L), HEXCONSTE(-9.99909204262595131211e-01, 0xbffe, 0xfffa0cb3L, 0x46f889a8L), 0 },
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(6.00000000000000000000e+00, 0x4001, 0xc0000000L, 0x00000000L), HEXCONSTE(9.99987711650795570574e-01, 0x3ffe, 0xffff31d5L, 0xf129deeeL), 0 },
	{ __LINE__, HEXCONSTE(-6.00000000000000000000e+00, 0xc001, 0xc0000000L, 0x00000000L), HEXCONSTE(-9.99987711650795570574e-01, 0xbffe, 0xffff31d5L, 0xf129deeeL), 0 },
#endif
	{ __LINE__, HEXCONSTE(7.00000000000000000000e+00, 0x4001, 0xe0000000L, 0x00000000L), HEXCONSTE(9.99998336943944671760e-01, 0x3ffe, 0xffffe419L, 0x3a878ed7L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-7.00000000000000000000e+00, 0xc001, 0xe0000000L, 0x00000000L), HEXCONSTE(-9.99998336943944671760e-01, 0xbffe, 0xffffe419L, 0x3a878ed7L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(8.00000000000000000000e+00, 0x4002, 0x80000000L, 0x00000000L), HEXCONSTE(9.99999774929675889785e-01, 0x3ffe, 0xfffffc39L, 0x548fc348L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-8.00000000000000000000e+00, 0xc002, 0x80000000L, 0x00000000L), HEXCONSTE(-9.99999774929675889785e-01, 0xbffe, 0xfffffc39L, 0x548fc348L), FLAG_INEXACT },
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(9.00000000000000000000e+00, 0x4002, 0x90000000L, 0x00000000L), HEXCONSTE(9.99999969540040974504e-01, 0x3ffe, 0xffffff7dL, 0x2cebbe21L), 0 },
	{ __LINE__, HEXCONSTE(-9.00000000000000000000e+00, 0xc002, 0x90000000L, 0x00000000L), HEXCONSTE(-9.99999969540040974504e-01, 0xbffe, 0xffffff7dL, 0x2cebbe21L), 0 },
#endif
	{ __LINE__, HEXCONSTE(1.00000000000000000000e+01, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(9.99999995877692763604e-01, 0x3ffe, 0xffffffeeL, 0x4b79aaa9L), 0 },
	{ __LINE__, HEXCONSTE(-1.00000000000000000000e+01, 0xc002, 0xa0000000L, 0x00000000L), HEXCONSTE(-9.99999995877692763604e-01, 0xbffe, 0xffffffeeL, 0x4b79aaa9L), 0 },
	{ __LINE__, HEXCONSTE(1.50000000000000000000e+01, 0x4002, 0xf0000000L, 0x00000000L), HEXCONSTE(9.99999999999812847515e-01, 0x3ffe, 0xffffffffL, 0xffcb523eL), 0 },
	{ __LINE__, HEXCONSTE(-1.50000000000000000000e+01, 0xc002, 0xf0000000L, 0x00000000L), HEXCONSTE(-9.99999999999812847515e-01, 0xbffe, 0xffffffffL, 0xffcb523eL), 0 },
	{ __LINE__, HEXCONSTE(2.00000000000000000000e+01, 0x4003, 0xa0000000L, 0x00000000L), HEXCONSTE(9.99999999999999991489e-01, 0x3ffe, 0xffffffffL, 0xffffff63L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-2.00000000000000000000e+01, 0xc003, 0xa0000000L, 0x00000000L), HEXCONSTE(-9.99999999999999991489e-01, 0xbffe, 0xffffffffL, 0xffffff63L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.20000000000000000000e+01, 0x4003, 0xb0000000L, 0x00000000L), HEXCONSTE(9.99999999999999999837e-01, 0x3ffe, 0xffffffffL, 0xfffffffdL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-2.20000000000000000000e+01, 0xc003, 0xb0000000L, 0x00000000L), HEXCONSTE(-9.99999999999999999837e-01, 0xbffe, 0xffffffffL, 0xfffffffdL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.50000000000000000000e+01, 0x4003, 0xc8000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-2.50000000000000000000e+01, 0xc003, 0xc8000000L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.00000000000000000000e+01, 0x4003, 0xf0000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-3.00000000000000000000e+01, 0xc003, 0xf0000000L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.50000000000000000000e+01, 0x4004, 0x8c000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-3.50000000000000000000e+01, 0xc004, 0x8c000000L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.00000000000000000000e+01, 0x4004, 0xa0000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-4.00000000000000000000e+01, 0xc004, 0xa0000000L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.50000000000000000000e+01, 0x4004, 0xb4000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-4.50000000000000000000e+01, 0xc004, 0xb4000000L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(5.00000000000000000000e+01, 0x4004, 0xc8000000L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-5.00000000000000000000e+01, 0xc004, 0xc8000000L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(6.93889390390722837765e-18, 0x3fc6, 0x80000000L, 0x00000000L), HEXCONSTE(6.93889390390722837765e-18, 0x3fc6, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9.01464045047760009766e-01, 0x3ffe, 0xe6c65900L, 0x00000000L), HEXCONSTE(7.17009991844966219671e-01, 0x3ffe, 0xb78df781L, 0xe11d83e5L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(5.47448992729187011719e-01, 0x3ffe, 0x8c259e00L, 0x00000000L), HEXCONSTE(4.98605843319011067717e-01, 0x3ffd, 0xff4943ddL, 0x4c9f4514L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(3.96516621112823486328e-01, 0x3ffd, 0xcb043a00L, 0x00000000L), HEXCONSTE(3.76964510303130499882e-01, 0x3ffd, 0xc1017e07L, 0x025b009bL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(5.30424416065216064453e-01, 0x3ffe, 0x87c9e500L, 0x00000000L), HEXCONSTE(4.85705449612686392059e-01, 0x3ffd, 0xf8ae627bL, 0x26a334feL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-2.31946453452110290527e-01, 0xbffc, 0xed835f00L, 0x00000000L), HEXCONSTE(-2.27874549155812908719e-01, 0xbffc, 0xe957f220L, 0xdc1eb288L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(4.82811272144317626953e-01, 0x3ffd, 0xf7330a00L, 0x00000000L), HEXCONSTE(4.48492237471829255813e-01, 0x3ffd, 0xe5a0c648L, 0xe71a47aaL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(4.76942539215087890625e-01, 0x3ffd, 0xf431d000L, 0x00000000L), HEXCONSTE(4.43791654161363958097e-01, 0x3ffd, 0xe338a8e1L, 0xb8bad812L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-1.48562371730804443359e-01, 0xbffc, 0x9820bc00L, 0x00000000L), HEXCONSTE(-1.47478972918774734710e-01, 0xbffc, 0x9704ba56L, 0x229e576eL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.13921783142723143101e-04, 0x3ff2, 0xe0503100L, 0x00000000L), HEXCONSTE(2.13921779879522579631e-04, 0x3ff2, 0xe05030c6L, 0x97d9e583L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.36342117190361022949e-01, 0x3ffc, 0xf203ab00L, 0x00000000L), HEXCONSTE(2.32037763159495026577e-01, 0x3ffc, 0xed9b4eb0L, 0xd3fe4d34L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.36342102289199829102e-01, 0x3ffc, 0xf203aa00L, 0x00000000L), HEXCONSTE(2.32037749060635005059e-01, 0x3ffc, 0xed9b4dbeL, 0x9c8d1de4L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.36342111527542142468e-01, 0x3ffc, 0xf203aa9eL, 0xb6a8c000L), HEXCONSTE(2.32037757801570935064e-01, 0x3ffc, 0xed9b4e54L, 0xc79810eaL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.25237971544265747070e-01, 0x3ffc, 0x803e6200L, 0x00000000L), HEXCONSTE(1.24587286465171515829e-01, 0x3ffb, 0xff279e86L, 0xec1fd6d8L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(1.25237956643104553223e-01, 0x3ffc, 0x803e6100L, 0x00000000L), HEXCONSTE(1.24587271795305998827e-01, 0x3ffb, 0xff279c8eL, 0xde9f66b9L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(1.25237962086789667016e-01, 0x3ffc, 0x803e615dL, 0x85949000L), HEXCONSTE(1.24587277154494292374e-01, 0x3ffb, 0xff279d47L, 0x028a9a28L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-1.46172380447387695312e+01, 0xc002, 0xe9e03500L, 0x00000000L), HEXCONSTE(-9.99999999999597599665e-01, 0xbffe, 0xffffffffL, 0xff8ebc00L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-2.34581664204597473145e-01, 0xbffc, 0xf0362d00L, 0x00000000L), HEXCONSTE(-2.30371416677539751056e-01, 0xbffc, 0xebe67c12L, 0x40bd5298L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-2.34581679105758666992e-01, 0xbffc, 0xf0362e00L, 0x00000000L), HEXCONSTE(-2.30371430787881525379e-01, 0xbffc, 0xebe67d04L, 0xaaadcfd6L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(-2.34581669040965334894e-01, 0xbffc, 0xf0362d53L, 0x16922000L), HEXCONSTE(-2.30371421257236779103e-01, 0xbffc, 0xebe67c60L, 0xee75c7a6L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(-1.99059486389160156250e-01, 0xbffc, 0xcbd64000L, 0x00000000L), HEXCONSTE(-1.96471278664374300404e-01, 0xbffc, 0xc92fc451L, 0xddfe3ebeL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(1.81386277079582214355e-01, 0x3ffc, 0xb9bd5300L, 0x00000000L), HEXCONSTE(1.79422850321223587014e-01, 0x3ffc, 0xb7ba9fa9L, 0x2397b4cdL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(2.01537311077117919922e-01, 0x3ffc, 0xce5fcc00L, 0x00000000L), HEXCONSTE(1.98852292930891770209e-01, 0x3ffc, 0xcb9fef7bL, 0x7dbd391aL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(2.01537296175956726074e-01, 0x3ffc, 0xce5fcb00L, 0x00000000L), HEXCONSTE(1.98852278618955742768e-01, 0x3ffc, 0xcb9fee85L, 0x9d2dc874L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(2.01537308518033669857e-01, 0x3ffc, 0xce5fcbd4L, 0x09074800L), HEXCONSTE(1.98852290472999428174e-01, 0x3ffc, 0xcb9fef51L, 0x43d076d1L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.01537308518033642102e-01, 0x3ffc, 0xce5fcbd4L, 0x09074000L), HEXCONSTE(1.98852290472999401503e-01, 0x3ffc, 0xcb9fef51L, 0x43d06f21L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.01537308518033644758e-01, 0x3ffc, 0xce5fcbd4L, 0x090740c4L), HEXCONSTE(1.98852290472999404064e-01, 0x3ffc, 0xcb9fef51L, 0x43d06fdeL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(5.15659987926483154297e-01, 0x3ffe, 0x84024b00L, 0x00000000L), HEXCONSTE(4.74343441290915907840e-01, 0x3ffd, 0xf2dd24beL, 0xd549f41eL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(5.15659928321838378906e-01, 0x3ffe, 0x84024a00L, 0x00000000L), HEXCONSTE(4.74343395097416246404e-01, 0x3ffd, 0xf2dd2332L, 0x08b57887L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(5.15659932445832080994e-01, 0x3ffe, 0x84024a11L, 0xb6610800L), HEXCONSTE(4.74343398293504527996e-01, 0x3ffd, 0xf2dd234dL, 0x7cfb3856L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(5.15659932445831969972e-01, 0x3ffe, 0x84024a11L, 0xb6610000L), HEXCONSTE(4.74343398293504441964e-01, 0x3ffd, 0xf2dd234dL, 0x7cfb2bf0L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(5.15659932445832059472e-01, 0x3ffe, 0x84024a11L, 0xb6610673L), HEXCONSTE(4.74343398293504511326e-01, 0x3ffd, 0xf2dd234dL, 0x7cfb35efL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(5.15659932445832059418e-01, 0x3ffe, 0x84024a11L, 0xb6610672L), HEXCONSTE(4.74343398293504511272e-01, 0x3ffd, 0xf2dd234dL, 0x7cfb35edL), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(3.12500000000000000000e-02, 0x3ffa, 0x80000000L, 0x00000000L), HEXCONSTE(3.12398314460312567690e-02, 0x3ff9, 0xffeaacccL, 0x958ef142L), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(9.76562500000000000000e-04, 0x3ff5, 0x80000000L, 0x00000000L), HEXCONSTE(9.76562189559260218587e-04, 0x3ff4, 0xfffffaaaL, 0xaaccccccL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(3.05175781250000000000e-05, 0x3ff0, 0x80000000L, 0x00000000L), HEXCONSTE(3.05175781155260968604e-05, 0x3fef, 0xfffffffeL, 0xaaaaaaadL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(9.53674316406250000000e-07, 0x3feb, 0x80000000L, 0x00000000L), HEXCONSTE(9.53674316405960879438e-07, 0x3fea, 0xffffffffL, 0xffaaaaabL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(2.98023223876953125000e-08, 0x3fe6, 0x80000000L, 0x00000000L), HEXCONSTE(2.98023223876953036773e-08, 0x3fe5, 0xffffffffL, 0xffffeaabL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(9.31322574615478515625e-10, 0x3fe1, 0x80000000L, 0x00000000L), HEXCONSTE(9.31322574615478515373e-10, 0x3fe0, 0xffffffffL, 0xfffffffbL), FLAG_INEXACT3 },
	{ __LINE__, HEXCONSTE(2.91038304567337036133e-11, 0x3fdc, 0x80000000L, 0x00000000L), HEXCONSTE(2.91038304567337036133e-11, 0x3fdc, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9.09494701772928237915e-13, 0x3fd7, 0x80000000L, 0x00000000L), HEXCONSTE(9.09494701772928237915e-13, 0x3fd7, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.84217094304040074348e-14, 0x3fd2, 0x80000000L, 0x00000000L), HEXCONSTE(2.84217094304040074348e-14, 0x3fd2, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(8.88178419700125232339e-16, 0x3fcd, 0x80000000L, 0x00000000L), HEXCONSTE(8.88178419700125232339e-16, 0x3fcd, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.77555756156289135106e-17, 0x3fc8, 0x80000000L, 0x00000000L), HEXCONSTE(2.77555756156289135106e-17, 0x3fc8, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(8.67361737988403547206e-19, 0x3fc3, 0x80000000L, 0x00000000L), HEXCONSTE(8.67361737988403547206e-19, 0x3fc2, 0xffffffffL, 0xfffffff0L), FLAG_INEXACT2 },
	{ __LINE__, HEXCONSTE(7.88860905221011805412e-31, 0x3f9b, 0x80000000L, 0x00000000L), HEXCONSTE(7.88860905221011805412e-31, 0x3f9b, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.40991986510288411774e-181, 0x3da7, 0x80000000L, 0x00000000L), HEXCONSTE(2.40991986510288411774e-181, 0x3da7, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), 0 },
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, HEXCONSTE(5.01237274920645200930e-3011, 0x18ef, 0x80000000L, 0x00000000L), HEXCONSTE(5.01237274920645200930e-3011, 0x18ef, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, HEXCONSTE(3.40282346638528859812e+38, 0x407e, 0xffffff00L, 0x00000000L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.79769313486231570815e+308, 0x43fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, MAX_P, HEXCONSTE(1.00000000000000000000e+00, 0x3fff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-3.40282346638528859812e+38, 0xc07e, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.79769313486231570815e+308, 0xc3fe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), 0 },
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
	{ __LINE__, MAX_M, HEXCONSTE(-1.00000000000000000000e+00, 0xbfff, 0x80000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), HEXCONSTE(1.17549435082228750797e-38, 0x3f81, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), HEXCONSTE(2.22507385850720138309e-308, 0x3c01, 0x80000000L, 0x00000000L), 0 },
#if defined(TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16381)
	{ __LINE__, HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), HEXCONSTE(3.36210314311209350626e-4932, 0x0001, 0x80000000L, 0x00000000L), 0 },
#endif
#if defined(TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), HEXCONSTE(2.00416836000897277800e-292, 0x3c36, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), HEXCONSTE(-1.17549435082228750797e-38, 0xbf81, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), HEXCONSTE(-2.22507385850720138309e-308, 0xbc01, 0x80000000L, 0x00000000L), 0 },
#if defined(TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16381)
	{ __LINE__, HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), HEXCONSTE(-3.36210314311209350626e-4932, 0x8001, 0x80000000L, 0x00000000L), 0 },
#endif
#if defined(TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16382)
	{ __LINE__, HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), 0 },
#endif
	{ __LINE__, HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), HEXCONSTE(-2.00416836000897277800e-292, 0xbc36, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), 0 },
#if defined(TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16381)
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), 0 },
#endif
	{ __LINE__, HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), HEXCONSTE(0.00000000000000000000e+00, 0x0000, 0x00000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), 0 },
#if defined(TEST_LDOUBLE) && __LDBL_MIN_EXP__ <= (-16381)
	{ __LINE__, HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), 0 },
#endif

	{ __LINE__, HEXCONSTE(-8.000000000000000000e01, 0xc005, 0xa0000000L, 0x00000000L), HEXCONSTE(-1.000000000000000000e00, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.000000000000000000e01, 0xc002, 0xa0000000L, 0x00000000L), HEXCONSTE(-9.999999958776927635e-01, 0xbffe, 0xffffffeeL, 0x4b79aaa7L), 0 },
	{ __LINE__, HEXCONSTE(-5.000000000000000000e-01, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(-4.621171572600097586e-01, 0xbffd, 0xec9a9ebaL, 0xb4579b2cL), 0 },
	{ __LINE__, HEXCONSTE(1.500000000000000000e00, 0x3fff, 0xc0000000L, 0x00000000L), HEXCONSTE(9.051482536448664383e-01, 0x3ffe, 0xe7b7cbc3L, 0x6fabbb08L), 0 },
	{ __LINE__, HEXCONSTE(1.000000000000000000e01, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(9.999999958776927635e-01, 0x3ffe, 0xffffffeeL, 0x4b79aaa7L), 0 },
	{ __LINE__, HEXCONSTE(8.000000000000000000e01, 0x4005, 0xa0000000L, 0x00000000L), HEXCONSTE(1.000000000000000000e00, 0x3fff, 0x80000000L, 0x00000000L), 0 },

	{ __LINE__, HEXCONSTE(0.75L, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(0.635148952387287319214434357312496495L, 0x3ffe, 0xa2991f2aL, 0x9791413aL), 0 },
	{ __LINE__, HEXCONSTE(-0.75L, 0xbffe, 0xc0000000L, 0x00000000L), HEXCONSTE(-0.635148952387287319214434357312496495L, 0xbffe, 0xa2991f2aL, 0x9791413aL), 0 },

	{ __LINE__, HEXCONSTE(1.0L, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.7615941559557648881194582826047935904L, 0x3ffe, 0xc2f7d5a8L, 0xa79ca2acL), 0 },
	{ __LINE__, HEXCONSTE(-1.0L, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-0.7615941559557648881194582826047935904L, 0xbffe, 0xc2f7d5a8L, 0xa79ca2acL), 0 },

	/* 2^-57  */
	{ __LINE__, HEXCONSTE(6.93889390390722837765e-18, 0x3fc6, 0x80000000L, 0x00000000L), HEXCONSTE(6.938893903907228377647697925567626953125e-18L, 0x3fc6, 0x80000000L, 0x00000000L), 0 },
};

int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_f_f(ftanh_data, ARRAY_SIZE(ftanh_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

```

`tests/testcomplex.h`:

```h


static void test_cabs(void)
{
	struct test *testp = lookup("cabs" },

	TEST_c_f(cabs, 1.000000000000e00, 2.000000000000e00, 2.23606798052788e00, 0 },
	TEST_c_f(cabs, 0.000000000000e00, 2.000000000000e00, 2.00000000000000e00, 0 },
	TEST_c_f(cabs, 1.000000000000e00, 0.000000000000e00, 1.00000000000000e00, 0 },
	TEST_c_f(cabs, -2.000000000000e00, 2.000000000000e00, 2.82842713594437e00, 0 },
	TEST_c_f(cabs, -1.000000000000e00, -2.000000000000e00, 2.23606798052788e00, 0 },
	TEST_c_f(cabs, 1.000000000000e00, -2.000000000000e00, 2.23606798052788e00, 0 },

	/* cabs (x + iy) is specified as hypot (x,y) */

	/* cabs (+inf + i x) == +inf.  */
	TEST_c_f (cabs, INF_P, 1.0, INF_P, 0 },
	/* cabs (-inf + i x) == +inf.  */
	TEST_c_f (cabs, INF_M, 1.0, INF_P, 0 },

	TEST_c_f (cabs, INF_M, QNAN_P, INF_P, 0 },
	TEST_c_f (cabs, INF_M, QNAN_P, INF_P, 0 },

	TEST_c_f (cabs, QNAN_P, QNAN_P, QNAN_P, 0 },

	/* cabs (x,y) == cabs (y,x).  */
	TEST_c_f (cabs, 0.75L, 12.390625L, 12.4133028598606664302388810868156657L, 0 },
	/* cabs (x,y) == cabs (-x,y).  */
	TEST_c_f (cabs, -12.390625L, 0.75L, 12.4133028598606664302388810868156657L, 0 },
	/* cabs (x,y) == cabs (-y,x).  */
	TEST_c_f (cabs, -0.75L, 12.390625L, 12.4133028598606664302388810868156657L, 0 },
	/* cabs (x,y) == cabs (-x,-y).	*/
	TEST_c_f (cabs, -12.390625L, -0.75L, 12.4133028598606664302388810868156657L, 0 },
	/* cabs (x,y) == cabs (-y,-x).	*/
	TEST_c_f (cabs, -0.75L, -12.390625L, 12.4133028598606664302388810868156657L, 0 },
	/* cabs (x,0) == fabs (x).	*/
	TEST_c_f (cabs, -0.75L, 0, 0.75L, 0 },
	TEST_c_f (cabs, 0.75L, 0, 0.75L, 0 },
	TEST_c_f (cabs, -1.0L, 0, 1.0L, 0 },
	TEST_c_f (cabs, 1.0L, 0, 1.0L, 0 },
	TEST_c_f (cabs, -5.7e7L, 0, 5.7e7L, 0 },
	TEST_c_f (cabs, 5.7e7L, 0, 5.7e7L, 0 },

	TEST_c_f (cabs, 0.75L, 1.25L, 1.45773797371132511771853821938639577L, 0 },
}


static void test_carg(void)
{
	struct test *testp = lookup("carg" },

	/* carg (x + iy) is specified as atan2 (y, x) */

	/* carg (x + i 0) == 0 for x > 0.  */
	TEST_c_f (carg, 2.0, 0, 0, 0 },
	/* carg (x - i 0) == -0 for x > 0.	*/
	TEST_c_f (carg, 2.0, ZERO_M, ZERO_M, 0 },

	TEST_c_f (carg, 0, 0, 0, 0 },
	TEST_c_f (carg, 0, ZERO_M, ZERO_M, 0 },

	/* carg (x + i 0) == +pi for x < 0.  */
	TEST_c_f (carg, -2.0, 0, M_PIl, 0 },

	/* carg (x - i 0) == -pi for x < 0.  */
	TEST_c_f (carg, -2.0, ZERO_M, -M_PIl, 0 },

	TEST_c_f (carg, ZERO_M, 0, M_PIl, 0 },
	TEST_c_f (carg, ZERO_M, ZERO_M, -M_PIl, 0 },

	/* carg (+0 + i y) == pi/2 for y > 0.  */
	TEST_c_f (carg, 0, 2.0, M_PI_2l, 0 },

	/* carg (-0 + i y) == pi/2 for y > 0.  */
	TEST_c_f (carg, ZERO_M, 2.0, M_PI_2l, 0 },

	/* carg (+0 + i y) == -pi/2 for y < 0.	*/
	TEST_c_f (carg, 0, -2.0, -M_PI_2l, 0 },

	/* carg (-0 + i y) == -pi/2 for y < 0.	*/
	TEST_c_f (carg, ZERO_M, -2.0, -M_PI_2l, 0 },

	/* carg (inf + i y) == +0 for finite y > 0.  */
	TEST_c_f (carg, INF_P, 2.0, 0, 0 },

	/* carg (inf + i y) == -0 for finite y < 0.  */
	TEST_c_f (carg, INF_P, -2.0, ZERO_M, 0 },

	/* carg(x + i inf) == pi/2 for finite x.  */
	TEST_c_f (carg, 10.0, INF_P, M_PI_2l, 0 },

	/* carg(x - i inf) == -pi/2 for finite x.  */
	TEST_c_f (carg, 10.0, INF_M, -M_PI_2l, 0 },

	/* carg (-inf + i y) == +pi for finite y > 0.  */
	TEST_c_f (carg, INF_M, 10.0, M_PIl, 0 },

	/* carg (-inf + i y) == -pi for finite y < 0.  */
	TEST_c_f (carg, INF_M, -10.0, -M_PIl, 0 },

	TEST_c_f (carg, INF_P, INF_P, M_PI_4l, 0 },

	TEST_c_f (carg, INF_P, INF_M, -M_PI_4l, 0 },

	TEST_c_f (carg, INF_M, INF_P, M_PI_34l, 0 },

	TEST_c_f (carg, INF_M, INF_M, -M_PI_34l, 0 },

	TEST_c_f (carg, QNAN_P, QNAN_P, QNAN_P, 0 },
}


static void test_cimag(void)
{
	struct test *testp = lookup("cimag" },

	TEST_c_f (cimag, 1.0, 0.0, 0.0, NO_INEXACT_EXCEPTION },
	TEST_c_f (cimag, 1.0, ZERO_M, ZERO_M, NO_INEXACT_EXCEPTION },
	TEST_c_f (cimag, 1.0, QNAN_P, QNAN_P, NO_INEXACT_EXCEPTION },
	TEST_c_f (cimag, QNAN_P, QNAN_P, QNAN_P, NO_INEXACT_EXCEPTION },
	TEST_c_f (cimag, 1.0, INF_P, INF_P, NO_INEXACT_EXCEPTION },
	TEST_c_f (cimag, 1.0, INF_M, INF_M, NO_INEXACT_EXCEPTION },
	TEST_c_f (cimag, 2.0, 3.0, 3.0, NO_INEXACT_EXCEPTION },
}


static void test_creal(void)
{
	struct test *testp = lookup("creal" },

	TEST_c_f (creal, 0.0, 1.0, 0.0, NO_INEXACT_EXCEPTION },
	TEST_c_f (creal, ZERO_M, 1.0, ZERO_M, NO_INEXACT_EXCEPTION },
	TEST_c_f (creal, QNAN_P, 1.0, QNAN_P, NO_INEXACT_EXCEPTION },
	TEST_c_f (creal, QNAN_P, QNAN_P, QNAN_P, NO_INEXACT_EXCEPTION },
	TEST_c_f (creal, INF_P, 1.0, INF_P, NO_INEXACT_EXCEPTION },
	TEST_c_f (creal, INF_M, 1.0, INF_M, NO_INEXACT_EXCEPTION },
	TEST_c_f (creal, 2.0, 3.0, 2.0, NO_INEXACT_EXCEPTION },
}


static void test_cadd(void)
{
	struct test *testp = lookup("cadd" },

	TEST_cc_c(cadd, 1.122999995946884155e00, 2.340000003576278686e00, 3.560000002384185791e00, 4.100000023841857910e00, 4.683000028133392334e00, 6.440000057220458984e00, 0 },
	TEST_cc_c(cadd, -1.345669999718666076e00, 2.234566986560821533e00, 3.348675012588500976e00, -4.122219979763031005e00, 2.003005027770996093e00, -1.887652993202209472e00, 0 },
	TEST_cc_c(cadd, 3.857562988996505737e-01, 1.000030040740966796e-01, 3.333939403295516967e00, 4.349979996681213378e00, 3.719695717096328735e00, 4.449983000755310058e00, 0 },
	TEST_cc_c(cadd, 1.575757563114166259e00, 0.000000000000000000e00, 3.378574609756469726e00, 0.000000000000000000e00, 4.954332172870635986e00, 0.000000000000000000e00, 0 },
	TEST_cc_c(cadd, -1.233999997377395629e00, -2.334455549716949462e00, -3.000000000000000000e00, -4.000000000000000000e00, -4.234000027179718017e00, -6.334455549716949462e00, 0 },
	TEST_cc_c(cadd, 1.227000000000000000e04, 1.300000000000000000e03, 0.000000000000000000e00, 3.452000021934509277e-02, 1.227000000000000000e04, 1.300034515380859375e03, 0 },
}


static void test_csub(void)
{
	struct test *testp = lookup("csub" },

	TEST_cc_c(csub, 1.122999995946884155e00, 2.340000003576278686e00, 3.560000002384185791e00, 4.100000023841857910e00, -2.437000006437301635e00, -1.760000020265579223e00, 0 },
	TEST_cc_c(csub, -1.345669999718666076e00, 2.234566986560821533e00, 3.348675012588500976e00, -4.122219979763031005e00, -4.694344997406005859e00, 6.356786966323852539e00, 0 },
	TEST_cc_c(csub, 3.857562988996505737e-01, 1.000030040740966796e-01, 3.333939403295516967e00, 4.349979996681213378e00, -2.948183119297027587e00, -4.249976992607116699e00, 0 },
	TEST_cc_c(csub, 1.575757563114166259e00, 0.000000000000000000e00, 3.378574609756469726e00, 0.000000000000000000e00, -1.802817046642303466e00, 0.000000000000000000e00, 0 },
	TEST_cc_c(csub, -1.233999997377395629e00, -2.334455549716949462e00, -3.000000000000000000e00, -4.000000000000000000e00, 1.766000002622604370e00, 1.665544450283050537e00, 0 },
	TEST_cc_c(csub, 1.227000000000000000e04, 1.300000000000000000e03, 0.000000000000000000e00, 3.452000021934509277e-02, 1.227000000000000000e04, 1.299965484619140625e03, 0 },
}


static void test_cmul(void)
{
	struct test *testp = lookup("cmul" },

	TEST_cc_c(cmul, 1.122999995946884155e00, 2.340000003576278686e00, 3.560000002384185791e00, 4.100000023841857910e00, -5.596120119094848632e00, 1.293470001220703125e01, 0 },
	TEST_cc_c(cmul, -1.345669999718666076e00, 2.234566986560821533e00, 3.348675012588500976e00, -4.122219979763031005e00, 4.705165147781372070e00, 1.302998638153076171e01, 0 },
	TEST_cc_c(cmul, 3.857562988996505737e-01, 1.000030040740966796e-01, 3.333939403295516967e00, 4.349979996681213378e00, 8.510770574212074279e-01, 2.011436134576797485e00, 0 },
	TEST_cc_c(cmul, 1.575757563114166259e00, 0.000000000000000000e00, 3.378574609756469726e00, 0.000000000000000000e00, 5.323814511299133300e00, 0.000000000000000000e00, 0 },
	TEST_cc_c(cmul, -1.233999997377395629e00, -2.334455549716949462e00, -3.000000000000000000e00, -4.000000000000000000e00, -5.635822236537933349e00, 1.193936669826507568e01, 0 },
	TEST_cc_c(cmul, 1.227000000000000000e04, 1.300000000000000000e03, 0.000000000000000000e00, 3.452000021934509277e-02, -4.487600040435791015e01, 4.235604019165039062e02, 0 },
	TEST_cc_c(cmul, 1, 2, 3, 4, -5, 10, 0 },
}


static void test_cdiv(void)
{
	struct test *testp = lookup("cdiv" },

	TEST_cc_c(cdiv, 1.122999995946884155e00, 2.340000003576278686e00, 3.560000002384185791e00, 4.100000023841857910e00, 4.609979800879955291e-01, 1.263787318021059036e-01, 0 },
	TEST_cc_c(cdiv, -1.345669999718666076e00, 2.234566986560821533e00, 3.348675012588500976e00, -4.122219979763031005e00, -4.863302707672119140e-01, 6.862613558769226074e-02, 0 },
	TEST_cc_c(cdiv, 3.857562988996505737e-01, 1.000030040740966796e-01, 3.333939403295516967e00, 4.349979996681213378e00, 5.729839205741882324e-02, -4.476501746103167533e-02, 0 },
	TEST_cc_c(cdiv, 1.575757563114166259e00, 0.000000000000000000e00, 3.378574609756469726e00, 0.000000000000000000e00, 4.663971476256847381e-01, 0.000000000000000000e00, 0 },
	TEST_cc_c(cdiv, -1.233999997377395629e00, -2.334455549716949462e00, -3.000000000000000000e00, -4.000000000000000000e00, 5.215928852558135986e-01, 8.269466646015644073e-02, 0 },
	TEST_cc_c(cdiv, 1.227000000000000000e04, 1.300000000000000000e03, 0.000000000000000000e00, 3.452000021934509277e-02, 3.765932763671875000e04, -3.554461171875000000e05, 0 },
	TEST_cc_c(cdiv, -5, 10, 3, 4, 1, 2, 0 },
}


static void test_cacos(void)
{
	struct test *testp = lookup("cacos" },

	TEST_c_c(cacos, 1.0, 2.0, 1.143717750906944274e00, -1.528570920228958129e00, 0 },
	TEST_c_c(cacos, 0.0, 2.0, 1.570796325802803039e00, -1.443635478615760803e00, 0 },
	TEST_c_c(cacos, 1.0, 0.0, ZERO_P, ZERO_M, 0 },
	TEST_c_c(cacos, -2.0, 2.0, 2.325045466423034668e00, -1.734324529767036438e00, 0 },
	TEST_c_c(cacos, -1.0, -2.0, 1.997874900698661804e00, 1.528570890426635742e00, 0 },
	TEST_c_c(cacos, 1.0, -2.0, 1.143717750906944274e00, 1.528570890426635742e00, 0 },

	TEST_c_c(cacos, 0, 0, M_PI_2l, ZERO_M, 0 },
	TEST_c_c(cacos, ZERO_M, 0, M_PI_2l, ZERO_M, 0 },
	TEST_c_c(cacos, ZERO_M, ZERO_M, M_PI_2l, 0.0, 0 },
	TEST_c_c(cacos, 0, ZERO_M, M_PI_2l, 0.0, 0 },

	TEST_c_c(cacos, INF_M, INF_P, M_PI_34l, INF_M, 0 },
	TEST_c_c(cacos, INF_M, INF_M, M_PI_34l, INF_P, 0 },

	TEST_c_c(cacos, INF_P, INF_P, M_PI_4l, INF_M, 0 },
	TEST_c_c(cacos, INF_P, INF_M, M_PI_4l, INF_P, 0 },

	TEST_c_c(cacos, -10.0, INF_P, M_PI_2l, INF_M, 0 },
	TEST_c_c(cacos, -10.0, INF_M, M_PI_2l, INF_P, 0 },
	TEST_c_c(cacos, 0, INF_P, M_PI_2l, INF_M, 0 },
	TEST_c_c(cacos, 0, INF_M, M_PI_2l, INF_P, 0 },
	TEST_c_c(cacos, 0.1L, INF_P, M_PI_2l, INF_M, 0 },
	TEST_c_c(cacos, 0.1L, INF_M, M_PI_2l, INF_P, 0 },

	TEST_c_c(cacos, INF_M, 0, M_PIl, INF_M, 0 },
	TEST_c_c(cacos, INF_M, ZERO_M, M_PIl, INF_P, 0 },
	TEST_c_c(cacos, INF_M, 100, M_PIl, INF_M, 0 },
	TEST_c_c(cacos, INF_M, -100, M_PIl, INF_P, 0 },

	TEST_c_c(cacos, INF_P, 0, 0.0, INF_M, 0 },
	TEST_c_c(cacos, INF_P, ZERO_M, 0.0, INF_P, 0 },
	TEST_c_c(cacos, INF_P, 0.5, 0.0, INF_M, 0 },
	TEST_c_c(cacos, INF_P, -0.5, 0.0, INF_P, 0 },

	TEST_c_c(cacos, INF_P, QNAN_P, QNAN_P, INF_P, IGNORE_ZERO_INF_SIGN },
	TEST_c_c(cacos, INF_M, QNAN_P, QNAN_P, INF_P, IGNORE_ZERO_INF_SIGN },

	TEST_c_c(cacos, 0, QNAN_P, M_PI_2l, QNAN_P, 0 },
	TEST_c_c(cacos, ZERO_M, QNAN_P, M_PI_2l, QNAN_P, 0 },

	TEST_c_c(cacos, QNAN_P, INF_P, QNAN_P, INF_M, 0 },
	TEST_c_c(cacos, QNAN_P, INF_M, QNAN_P, INF_P, 0 },

	TEST_c_c(cacos, 10.5, QNAN_P, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	TEST_c_c(cacos, -10.5, QNAN_P, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },

	TEST_c_c(cacos, QNAN_P, 0.75, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	TEST_c_c(cacos, QNAN_P, -0.75, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },

	TEST_c_c(cacos, QNAN_P, QNAN_P, QNAN_P, QNAN_P, 0 },

	TEST_c_c(cacos, ZERO_P, -1.5L, M_PI_2l, 1.194763217287109304111930828519090523536L, 0 },
	TEST_c_c(cacos, ZERO_M, -1.5L, M_PI_2l, 1.194763217287109304111930828519090523536L, 0 },
	TEST_c_c(cacos, ZERO_P, -1.0L, M_PI_2l, 0.8813735870195430252326093249797923090282L, 0 },
	TEST_c_c(cacos, ZERO_M, -1.0L, M_PI_2l, 0.8813735870195430252326093249797923090282L, 0 },
	TEST_c_c(cacos, ZERO_P, -0.5L, M_PI_2l, 0.4812118250596034474977589134243684231352L, 0 },
	TEST_c_c(cacos, ZERO_M, -0.5L, M_PI_2l, 0.4812118250596034474977589134243684231352L, 0 },
	TEST_c_c(cacos, ZERO_P, 0.5L, M_PI_2l, -0.4812118250596034474977589134243684231352L, 0 },
	TEST_c_c(cacos, ZERO_M, 0.5L, M_PI_2l, -0.4812118250596034474977589134243684231352L, 0 },
	TEST_c_c(cacos, ZERO_P, 1.0L, M_PI_2l, -0.8813735870195430252326093249797923090282L, 0 },
	TEST_c_c(cacos, ZERO_M, 1.0L, M_PI_2l, -0.8813735870195430252326093249797923090282L, 0 },
	TEST_c_c(cacos, ZERO_P, 1.5L, M_PI_2l, -1.194763217287109304111930828519090523536L, 0 },
	TEST_c_c(cacos, ZERO_M, 1.5L, M_PI_2l, -1.194763217287109304111930828519090523536L, 0 },

	TEST_c_c(cacos, -1.5L, ZERO_P, M_PIl, -0.9624236501192068949955178268487368462704L, 0 },
	TEST_c_c(cacos, -1.5L, ZERO_M, M_PIl, 0.9624236501192068949955178268487368462704L, 0 },
	TEST_c_c(cacos, -1.0L, ZERO_P, M_PIl, ZERO_M, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -1.0L, ZERO_M, M_PIl, ZERO_P, 0 },
	TEST_c_c(cacos, -0.5L, ZERO_P, 2.094395102393195492308428922186335256131L, ZERO_M, 0|XFAIL_NATIVE_LINUXL|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacos, -0.5L, ZERO_M, 2.094395102393195492308428922186335256131L, ZERO_P, 0 },
	TEST_c_c(cacos, 0.5L, ZERO_P, 1.047197551196597746154214461093167628066L, ZERO_M, 0|XFAIL_NATIVE_LINUXL|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacos, 0.5L, ZERO_M, 1.047197551196597746154214461093167628066L, ZERO_P, 0 },
	TEST_c_c(cacos, 1.0L, ZERO_P, ZERO_P, ZERO_M, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, 1.0L, ZERO_M, ZERO_P, ZERO_P, 0 },
	TEST_c_c(cacos, 1.5L, ZERO_P, ZERO_P, -0.9624236501192068949955178268487368462704L, 0 },
	TEST_c_c(cacos, 1.5L, ZERO_M, ZERO_P, 0.9624236501192068949955178268487368462704L, 0 },

	TEST_c_c(cacos, 0x1p50L, 1.0L, 8.881784197001252323389053344727730248720e-16L, -3.535050620855721078027883819436720218708e1L, XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, 0x1p50L, -1.0L, 8.881784197001252323389053344727730248720e-16L, 3.535050620855721078027883819436720218708e1L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacos, -0x1p50L, 1.0L, 3.141592653589792350284223683154270545292L, -3.535050620855721078027883819436720218708e1L, XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0x1p50L, -1.0L, 3.141592653589792350284223683154270545292L, 3.535050620855721078027883819436720218708e1L, 0 },
	TEST_c_c(cacos, 1.0L, 0x1p50L, 1.570796326794895731052901991514519103193L, -3.535050620855721078027883819436759661753e1L, XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -1.0L, 0x1p50L, 1.570796326794897507409741391764983781004L, -3.535050620855721078027883819436759661753e1L, XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, 1.0L, -0x1p50L, 1.570796326794895731052901991514519103193L, 3.535050620855721078027883819436759661753e1L, 0 },
	TEST_c_c(cacos, -1.0L, -0x1p50L, 1.570796326794897507409741391764983781004L, 3.535050620855721078027883819436759661753e1L, 0 },
#ifndef TEST_FLOAT
	TEST_c_c(cacos, 0x1p500L, 1.0L, 3.054936363499604682051979393213617699789e-151L, -3.472667374605326000180332928505464606058e2L, XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, 0x1p500L, -1.0L, 3.054936363499604682051979393213617699789e-151L, 3.472667374605326000180332928505464606058e2L, XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0x1p500L, 1.0L, 3.141592653589793238462643383279502884197L, -3.472667374605326000180332928505464606058e2L, XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0x1p500L, -1.0L, 3.141592653589793238462643383279502884197L, 3.472667374605326000180332928505464606058e2L, 0 },
	TEST_c_c(cacos, 1.0L, 0x1p500L, 1.570796326794896619231321691639751442099L, -3.472667374605326000180332928505464606058e2L, XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -1.0L, 0x1p500L, 1.570796326794896619231321691639751442099L, -3.472667374605326000180332928505464606058e2L, XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, 1.0L, -0x1p500L, 1.570796326794896619231321691639751442099L, 3.472667374605326000180332928505464606058e2L, 0 },
	TEST_c_c(cacos, -1.0L, -0x1p500L, 1.570796326794896619231321691639751442099L, 3.472667374605326000180332928505464606058e2L, 0 },
#endif
#if defined TEST_LDOUBLE && LDBL_MAX_EXP >= 16384
	TEST_c_c(cacos, 0x1p5000L, 1.0L, 7.079811261048172892385615158694057552948e-1506L, -3.466429049980286492395577839412341016946e3L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacos, 0x1p5000L, -1.0L, 7.079811261048172892385615158694057552948e-1506L, 3.466429049980286492395577839412341016946e3L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacos, -0x1p5000L, 1.0L, 3.141592653589793238462643383279502884197L, -3.466429049980286492395577839412341016946e3L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacos, -0x1p5000L, -1.0L, 3.141592653589793238462643383279502884197L, 3.466429049980286492395577839412341016946e3L, 0 },
	TEST_c_c(cacos, 1.0L, 0x1p5000L, 1.570796326794896619231321691639751442099L, -3.466429049980286492395577839412341016946e3L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacos, -1.0L, 0x1p5000L, 1.570796326794896619231321691639751442099L, -3.466429049980286492395577839412341016946e3L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacos, 1.0L, -0x1p5000L, 1.570796326794896619231321691639751442099L, 3.466429049980286492395577839412341016946e3L, 0 },
	TEST_c_c(cacos, -1.0L, -0x1p5000L, 1.570796326794896619231321691639751442099L, 3.466429049980286492395577839412341016946e3L, 0 },
#endif

	TEST_c_c(cacos, 0x1.fp127L, 0x1.fp127L, 7.853981633974483096156608458198757210493e-1L, -8.973081118419833726837456344608533993585e1L, XFAIL_NATIVE_LINUX },
#ifndef TEST_FLOAT
	TEST_c_c(cacos, 0x1.fp1023L, 0x1.fp1023L, 7.853981633974483096156608458198757210493e-1L, -7.107906849659093345062145442726115449315e2L, XFAIL_NATIVE_LINUX },
#endif
#if defined TEST_LDOUBLE && LDBL_MAX_EXP >= 16384
	TEST_c_c(cacos, 0x1.fp16383L, 0x1.fp16383L, 7.853981633974483096156608458198757210493e-1L, -1.135753137836666928715489992987020363057e4L, 0|XFAIL_NATIVE_LINUXL },
#endif

	TEST_c_c(cacos, 0x1.fp-129L, 1.5L, 1.570796326794896619231321691639751442097L, -1.194763217287109304111930828519090523536L, 0 },
	TEST_c_c(cacos, 0x1.fp-129L, -1.5L, 1.570796326794896619231321691639751442097L, 1.194763217287109304111930828519090523536L, 0 },
	TEST_c_c(cacos, -0x1.fp-129L, 1.5L, 1.570796326794896619231321691639751442100L, -1.194763217287109304111930828519090523536L, 0 },
	TEST_c_c(cacos, -0x1.fp-129L, -1.5L, 1.570796326794896619231321691639751442100L, 1.194763217287109304111930828519090523536L, 0 },
	TEST_c_c(cacos, 1.5L, 0x1.fp-129L, 2.546345110742945032959687790021055102355e-39L, -9.624236501192068949955178268487368462704e-1L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -1.5L, 0x1.fp-129L, 3.141592653589793238462643383279502884195L, -9.624236501192068949955178268487368462704e-1L, 0 },
	TEST_c_c(cacos, 1.5L, -0x1.fp-129L, 2.546345110742945032959687790021055102355e-39L, 9.624236501192068949955178268487368462704e-1L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -1.5L, -0x1.fp-129L, 3.141592653589793238462643383279502884195L, 9.624236501192068949955178268487368462704e-1L, 0 },
#ifndef TEST_FLOAT
	TEST_c_c(cacos, 0x1.fp-1025L, 1.5L, 1.570796326794896619231321691639751442099L, -1.194763217287109304111930828519090523536L, 0 },
	TEST_c_c(cacos, 0x1.fp-1025L, -1.5L, 1.570796326794896619231321691639751442099L, 1.194763217287109304111930828519090523536L, 0 },
	TEST_c_c(cacos, -0x1.fp-1025L, 1.5L, 1.570796326794896619231321691639751442099L, -1.194763217287109304111930828519090523536L, 0 },
	TEST_c_c(cacos, -0x1.fp-1025L, -1.5L, 1.570796326794896619231321691639751442099L, 1.194763217287109304111930828519090523536L, 0 },
	TEST_c_c(cacos, 1.5L, 0x1.fp-1025L, 4.819934639999230680322935210539402497827e-309L, -9.624236501192068949955178268487368462704e-1L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -1.5L, 0x1.fp-1025L, 3.141592653589793238462643383279502884197L, -9.624236501192068949955178268487368462704e-1L, 0 },
	TEST_c_c(cacos, 1.5L, -0x1.fp-1025L, 4.819934639999230680322935210539402497827e-309L, 9.624236501192068949955178268487368462704e-1L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -1.5L, -0x1.fp-1025L, 3.141592653589793238462643383279502884197L, 9.624236501192068949955178268487368462704e-1L, 0 },
#endif
#if defined TEST_LDOUBLE && LDBL_MIN_EXP <= -16381
	TEST_c_c(cacos, 0x1.fp-16385L, 1.5L, 1.570796326794896619231321691639751442099L, -1.194763217287109304111930828519090523536L, 0 },
	TEST_c_c(cacos, 0x1.fp-16385L, -1.5L, 1.570796326794896619231321691639751442099L, 1.194763217287109304111930828519090523536L, 0 },
	TEST_c_c(cacos, -0x1.fp-16385L, 1.5L, 1.570796326794896619231321691639751442099L, -1.194763217287109304111930828519090523536L, 0 },
	TEST_c_c(cacos, -0x1.fp-16385L, -1.5L, 1.570796326794896619231321691639751442099L, 1.194763217287109304111930828519090523536L, 0 },
	TEST_c_c(cacos, 1.5L, 0x1.fp-16385L, 7.282957076134209141226696333885150260319e-4933L, -9.624236501192068949955178268487368462704e-1L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacos, -1.5L, 0x1.fp-16385L, 3.141592653589793238462643383279502884197L, -9.624236501192068949955178268487368462704e-1L, 0 },
	TEST_c_c(cacos, 1.5L, -0x1.fp-16385L, 7.282957076134209141226696333885150260319e-4933L, 9.624236501192068949955178268487368462704e-1L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacos, -1.5L, -0x1.fp-16385L, 3.141592653589793238462643383279502884197L, 9.624236501192068949955178268487368462704e-1L, 0 },
#endif

	TEST_c_c(cacos, 0.5L, 1.0L, 1.221357263937683325603909865564381489366L, -9.261330313501824245501244453057873152694e-1L, 0 },
	TEST_c_c(cacos, 0.5L, -1.0L, 1.221357263937683325603909865564381489366L, 9.261330313501824245501244453057873152694e-1L, 0 },
	TEST_c_c(cacos, -0.5L, 1.0L, 1.920235389652109912858733517715121394831L, -9.261330313501824245501244453057873152694e-1L, 0 },
	TEST_c_c(cacos, -0.5L, -1.0L, 1.920235389652109912858733517715121394831L, 9.261330313501824245501244453057873152694e-1L, 0 },
	TEST_c_c(cacos, 1.0L, 0.5L, 6.748888455860063801646649673121744318756e-1L, -7.328576759736452608886724437653071523305e-1L, 0 },
	TEST_c_c(cacos, -1.0L, 0.5L, 2.466703808003786858297978415967328452322L, -7.328576759736452608886724437653071523305e-1L, 0 },
	TEST_c_c(cacos, 1.0L, -0.5L, 6.748888455860063801646649673121744318756e-1L, 7.328576759736452608886724437653071523305e-1L, 0 },
	TEST_c_c(cacos, -1.0L, -0.5L, 2.466703808003786858297978415967328452322L, 7.328576759736452608886724437653071523305e-1L, 0 },
	TEST_c_c(cacos, 0.25L, 1.0L, 1.394493894017929688812643125003661339452L, -8.924633639033482359562124741744951972772e-1L, 0 },
	TEST_c_c(cacos, 0.25L, -1.0L, 1.394493894017929688812643125003661339452L, 8.924633639033482359562124741744951972772e-1L, 0 },
	TEST_c_c(cacos, -0.25L, 1.0L, 1.747098759571863549650000258275841544745L, -8.924633639033482359562124741744951972772e-1L, 0 },
	TEST_c_c(cacos, -0.25L, -1.0L, 1.747098759571863549650000258275841544745L, 8.924633639033482359562124741744951972772e-1L, 0 },
	TEST_c_c(cacos, 1.0L, 0.25L, 4.890443302710802929202843732146540079124e-1L, -5.097911466811016354623559941115413499164e-1L, 0 },
	TEST_c_c(cacos, -1.0L, 0.25L, 2.652548323318712945542359010064848876285L, -5.097911466811016354623559941115413499164e-1L, 0 },
	TEST_c_c(cacos, 1.0L, -0.25L, 4.890443302710802929202843732146540079124e-1L, 5.097911466811016354623559941115413499164e-1L, 0 },
	TEST_c_c(cacos, -1.0L, -0.25L, 2.652548323318712945542359010064848876285L, 5.097911466811016354623559941115413499164e-1L, 0 },
	TEST_c_c(cacos, 0x1.fp-10L, 1.0L, 1.569458417435338878318763342108699202986L, -8.813742198809567991336704287826445879025e-1L, 0 },
	TEST_c_c(cacos, 0x1.fp-10L, -1.0L, 1.569458417435338878318763342108699202986L, 8.813742198809567991336704287826445879025e-1L, 0 },
	TEST_c_c(cacos, -0x1.fp-10L, 1.0L, 1.572134236154454360143880041170803681211L, -8.813742198809567991336704287826445879025e-1L, 0 },
	TEST_c_c(cacos, -0x1.fp-10L, -1.0L, 1.572134236154454360143880041170803681211L, 8.813742198809567991336704287826445879025e-1L, 0 },
	TEST_c_c(cacos, 1.0L, 0x1.fp-10L, 4.349129763101882771258049954181971959031e-2L, -4.350501469856803800217957402220976497152e-2L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacos, -1.0L, 0x1.fp-10L, 3.098101355958774410750062883737683164607L, -4.350501469856803800217957402220976497152e-2L, 0 },
	TEST_c_c(cacos, 1.0L, -0x1.fp-10L, 4.349129763101882771258049954181971959031e-2L, 4.350501469856803800217957402220976497152e-2L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacos, -1.0L, -0x1.fp-10L, 3.098101355958774410750062883737683164607L, 4.350501469856803800217957402220976497152e-2L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacos, 0x1.fp-30L, 1.0L, 1.570796325518966635014803151387033957091L, -8.813735870195430258081932989769495326854e-1L, 0 },
	TEST_c_c(cacos, 0x1.fp-30L, -1.0L, 1.570796325518966635014803151387033957091L, 8.813735870195430258081932989769495326854e-1L, 0 },
	TEST_c_c(cacos, -0x1.fp-30L, 1.0L, 1.570796328070826603447840231892468927106L, -8.813735870195430258081932989769495326854e-1L, 0 },
	TEST_c_c(cacos, -0x1.fp-30L, -1.0L, 1.570796328070826603447840231892468927106L, 8.813735870195430258081932989769495326854e-1L, 0 },
	TEST_c_c(cacos, 1.0L, 0x1.fp-30L, 4.247867097467650115899790787875186617316e-5L, -4.247867098745151888768727039216644758847e-5L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacos, -1.0L, 0x1.fp-30L, 3.141550174918818561961484385371624132331L, -4.247867098745151888768727039216644758847e-5L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacos, 1.0L, -0x1.fp-30L, 4.247867097467650115899790787875186617316e-5L, 4.247867098745151888768727039216644758847e-5L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacos, -1.0L, -0x1.fp-30L, 3.141550174918818561961484385371624132331L, 4.247867098745151888768727039216644758847e-5L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacos, 0x1.fp-100L, 1.0L, 1.570796326794896619231321691638670687364L, -8.813735870195430252326093249797923090282e-1L, 0 },
	TEST_c_c(cacos, 0x1.fp-100L, -1.0L, 1.570796326794896619231321691638670687364L, 8.813735870195430252326093249797923090282e-1L, 0 },
	TEST_c_c(cacos, -0x1.fp-100L, 1.0L, 1.570796326794896619231321691640832196834L, -8.813735870195430252326093249797923090282e-1L, 0 },
	TEST_c_c(cacos, -0x1.fp-100L, -1.0L, 1.570796326794896619231321691640832196834L, 8.813735870195430252326093249797923090282e-1L, 0 },
	TEST_c_c(cacos, 1.0L, 0x1.fp-100L, 1.236292038260260888664514866456887257525e-15L, -1.236292038260260888664514866457202186027e-15L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -1.0L, 0x1.fp-100L, 3.141592653589792002170605123018614219682L, -1.236292038260260888664514866457202186027e-15L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, 1.0L, -0x1.fp-100L, 1.236292038260260888664514866456887257525e-15L, 1.236292038260260888664514866457202186027e-15L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -1.0L, -0x1.fp-100L, 3.141592653589792002170605123018614219682L, 1.236292038260260888664514866457202186027e-15L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, 0x1.fp-129L, 1.0L, 1.570796326794896619231321691639751442097L, -8.813735870195430252326093249797923090282e-1L, 0 },
	TEST_c_c(cacos, 0x1.fp-129L, -1.0L, 1.570796326794896619231321691639751442097L, 8.813735870195430252326093249797923090282e-1L, 0 },
	TEST_c_c(cacos, -0x1.fp-129L, 1.0L, 1.570796326794896619231321691639751442101L, -8.813735870195430252326093249797923090282e-1L, 0 },
	TEST_c_c(cacos, -0x1.fp-129L, -1.0L, 1.570796326794896619231321691639751442101L, 8.813735870195430252326093249797923090282e-1L, 0 },
	TEST_c_c(cacos, 1.0L, 0x1.fp-129L, 5.335635276982233498398987585285818977930e-20L, -5.335635276982233498398987585285818977933e-20L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -1.0L, 0x1.fp-129L, 3.141592653589793238409287030509680549213L, -5.335635276982233498398987585285818977933e-20L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, 1.0L, -0x1.fp-129L, 5.335635276982233498398987585285818977930e-20L, 5.335635276982233498398987585285818977933e-20L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -1.0L, -0x1.fp-129L, 3.141592653589793238409287030509680549213L, 5.335635276982233498398987585285818977933e-20L, 0|XFAIL_NATIVE_LINUX },
#ifndef TEST_FLOAT
	TEST_c_c(cacos, 0x1.fp-1000L, 1.0L, 1.570796326794896619231321691639751442099L, -8.813735870195430252326093249797923090282e-1L, 0 },
	TEST_c_c(cacos, 0x1.fp-1000L, -1.0L, 1.570796326794896619231321691639751442099L, 8.813735870195430252326093249797923090282e-1L, 0 },
	TEST_c_c(cacos, -0x1.fp-1000L, 1.0L, 1.570796326794896619231321691639751442099L, -8.813735870195430252326093249797923090282e-1L, 0 },
	TEST_c_c(cacos, -0x1.fp-1000L, -1.0L, 1.570796326794896619231321691639751442099L, 8.813735870195430252326093249797923090282e-1L, 0 },
	TEST_c_c(cacos, 1.0L, 0x1.fp-1000L, 4.252291453851660175550490409247739011867e-151L, -4.252291453851660175550490409247739011867e-151L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -1.0L, 0x1.fp-1000L, 3.141592653589793238462643383279502884197L, -4.252291453851660175550490409247739011867e-151L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, 1.0L, -0x1.fp-1000L, 4.252291453851660175550490409247739011867e-151L, 4.252291453851660175550490409247739011867e-151L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -1.0L, -0x1.fp-1000L, 3.141592653589793238462643383279502884197L, 4.252291453851660175550490409247739011867e-151L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, 0x1.fp-1025L, 1.0L, 1.570796326794896619231321691639751442099L, -8.813735870195430252326093249797923090282e-1L, 0 },
	TEST_c_c(cacos, 0x1.fp-1025L, -1.0L, 1.570796326794896619231321691639751442099L, 8.813735870195430252326093249797923090282e-1L, 0 },
	TEST_c_c(cacos, -0x1.fp-1025L, 1.0L, 1.570796326794896619231321691639751442099L, -8.813735870195430252326093249797923090282e-1L, 0 },
	TEST_c_c(cacos, -0x1.fp-1025L, -1.0L, 1.570796326794896619231321691639751442099L, 8.813735870195430252326093249797923090282e-1L, 0 },
	TEST_c_c(cacos, 1.0L, 0x1.fp-1025L, 7.340879205566679497036857179189356754017e-155L, -7.340879205566679497036857179189356754017e-155L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -1.0L, 0x1.fp-1025L, 3.141592653589793238462643383279502884197L, -7.340879205566679497036857179189356754017e-155L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, 1.0L, -0x1.fp-1025L, 7.340879205566679497036857179189356754017e-155L, 7.340879205566679497036857179189356754017e-155L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -1.0L, -0x1.fp-1025L, 3.141592653589793238462643383279502884197L, 7.340879205566679497036857179189356754017e-155L, 0|XFAIL_NATIVE_LINUX },
#endif
#if defined TEST_LDOUBLE && LDBL_MIN_EXP <= -16381
	TEST_c_c(cacos, 0x1.fp-10000L, 1.0L, 1.570796326794896619231321691639751442099L, -8.813735870195430252326093249797923090282e-1L, 0 },
	TEST_c_c(cacos, 0x1.fp-10000L, -1.0L, 1.570796326794896619231321691639751442099L, 8.813735870195430252326093249797923090282e-1L, 0 },
	TEST_c_c(cacos, -0x1.fp-10000L, 1.0L, 1.570796326794896619231321691639751442099L, -8.813735870195430252326093249797923090282e-1L, 0 },
	TEST_c_c(cacos, -0x1.fp-10000L, -1.0L, 1.570796326794896619231321691639751442099L, 8.813735870195430252326093249797923090282e-1L, 0 },
	TEST_c_c(cacos, 1.0L, 0x1.fp-10000L, 9.854680208706673586644342922051388714633e-1506L, -9.854680208706673586644342922051388714633e-1506L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacos, -1.0L, 0x1.fp-10000L, 3.141592653589793238462643383279502884197L, -9.854680208706673586644342922051388714633e-1506L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacos, 1.0L, -0x1.fp-10000L, 9.854680208706673586644342922051388714633e-1506L, 9.854680208706673586644342922051388714633e-1506L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacos, -1.0L, -0x1.fp-10000L, 3.141592653589793238462643383279502884197L, 9.854680208706673586644342922051388714633e-1506L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacos, 0x1.fp-16385L, 1.0L, 1.570796326794896619231321691639751442099L, -8.813735870195430252326093249797923090282e-1L, 0 },
	TEST_c_c(cacos, 0x1.fp-16385L, -1.0L, 1.570796326794896619231321691639751442099L, 8.813735870195430252326093249797923090282e-1L, 0 },
	TEST_c_c(cacos, -0x1.fp-16385L, 1.0L, 1.570796326794896619231321691639751442099L, -8.813735870195430252326093249797923090282e-1L, 0 },
	TEST_c_c(cacos, -0x1.fp-16385L, -1.0L, 1.570796326794896619231321691639751442099L, 8.813735870195430252326093249797923090282e-1L, 0 },
	TEST_c_c(cacos, 1.0L, 0x1.fp-16385L, 9.023632056840860275214893047597614177639e-2467L, -9.023632056840860275214893047597614177639e-2467L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacos, -1.0L, 0x1.fp-16385L, 3.141592653589793238462643383279502884197L, -9.023632056840860275214893047597614177639e-2467L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacos, 1.0L, -0x1.fp-16385L, 9.023632056840860275214893047597614177639e-2467L, 9.023632056840860275214893047597614177639e-2467L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacos, -1.0L, -0x1.fp-16385L, 3.141592653589793238462643383279502884197L, 9.023632056840860275214893047597614177639e-2467L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
#endif

	TEST_c_c(cacos, 0x1p-23L, 0x1.000002p0L, 1.570796242501204621739026081991856762292L, -8.813736713132400470205730751186547909968e-1L, 0 },
	TEST_c_c(cacos, 0x1p-23L, -0x1.000002p0L, 1.570796242501204621739026081991856762292L, 8.813736713132400470205730751186547909968e-1L, 0 },
	TEST_c_c(cacos, -0x1p-23L, 0x1.000002p0L, 1.570796411088588616723617301287646121905L, -8.813736713132400470205730751186547909968e-1L, 0 },
	TEST_c_c(cacos, -0x1p-23L, -0x1.000002p0L, 1.570796411088588616723617301287646121905L, 8.813736713132400470205730751186547909968e-1L, 0 },
	TEST_c_c(cacos, 0x1.000002p0L, 0x1p-23L, 2.222118384408546368406374049167636760903e-4L, -5.364668491573609633134147164031476452679e-4L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacos, -0x1.000002p0L, 0x1p-23L, 3.141370441751352383825802745874586120521L, -5.364668491573609633134147164031476452679e-4L, 0 },
	TEST_c_c(cacos, 0x1.000002p0L, -0x1p-23L, 2.222118384408546368406374049167636760903e-4L, 5.364668491573609633134147164031476452679e-4L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacos, -0x1.000002p0L, -0x1p-23L, 3.141370441751352383825802745874586120521L, 5.364668491573609633134147164031476452679e-4L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacos, 0x1.fp-129L, 0x1.000002p0L, 1.570796326794896619231321691639751442097L, -8.813736713132375348727889167749389235161e-1L, 0 },
	TEST_c_c(cacos, 0x1.fp-129L, -0x1.000002p0L, 1.570796326794896619231321691639751442097L, 8.813736713132375348727889167749389235161e-1L, 0 },
	TEST_c_c(cacos, -0x1.fp-129L, 0x1.000002p0L, 1.570796326794896619231321691639751442101L, -8.813736713132375348727889167749389235161e-1L, 0 },
	TEST_c_c(cacos, -0x1.fp-129L, -0x1.000002p0L, 1.570796326794896619231321691639751442101L, 8.813736713132375348727889167749389235161e-1L, 0 },
	TEST_c_c(cacos, 0x1.000002p0L, 0x1.fp-129L, 5.830451806317544230969669308596361881467e-36L, -4.882812451493617206486388134172712975070e-4L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0x1.000002p0L, 0x1.fp-129L, 3.141592653589793238462643383279502878367L, -4.882812451493617206486388134172712975070e-4L, 0 },
	TEST_c_c(cacos, 0x1.000002p0L, -0x1.fp-129L, 5.830451806317544230969669308596361881467e-36L, 4.882812451493617206486388134172712975070e-4L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0x1.000002p0L, -0x1.fp-129L, 3.141592653589793238462643383279502878367L, 4.882812451493617206486388134172712975070e-4L, 0 },
	TEST_c_c(cacos, 0.0L, 0x1.000002p0L, 1.570796326794896619231321691639751442099L, -8.813736713132375348727889167749389235161e-1L, 0 },
	TEST_c_c(cacos, 0.0L, -0x1.000002p0L, 1.570796326794896619231321691639751442099L, 8.813736713132375348727889167749389235161e-1L, 0 },
	TEST_c_c(cacos, -0.0L, 0x1.000002p0L, 1.570796326794896619231321691639751442099L, -8.813736713132375348727889167749389235161e-1L, 0 },
	TEST_c_c(cacos, -0.0L, -0x1.000002p0L, 1.570796326794896619231321691639751442099L, 8.813736713132375348727889167749389235161e-1L, 0 },
	TEST_c_c(cacos, 0x1.000002p0L, 0.0L, 0.0L, -4.882812451493617206486388134172712975070e-4L, 0 },
	TEST_c_c(cacos, -0x1.000002p0L, 0.0L, 3.141592653589793238462643383279502884197L, -4.882812451493617206486388134172712975070e-4L, 0 },
	TEST_c_c(cacos, 0x1.000002p0L, -0.0L, 0.0L, 4.882812451493617206486388134172712975070e-4L, 0 },
	TEST_c_c(cacos, -0x1.000002p0L, -0.0L, 3.141592653589793238462643383279502884197L, 4.882812451493617206486388134172712975070e-4L, 0 },
#ifndef TEST_FLOAT
	TEST_c_c(cacos, 0x1p-52L, 0x1.0000000000001p0L, 1.570796326794896462222075823262262934288L, -8.813735870195431822418551933572982483664e-1L, 0 },
	TEST_c_c(cacos, 0x1p-52L, -0x1.0000000000001p0L, 1.570796326794896462222075823262262934288L, 8.813735870195431822418551933572982483664e-1L, 0 },
	TEST_c_c(cacos, -0x1p-52L, 0x1.0000000000001p0L, 1.570796326794896776240567560017239949909L, -8.813735870195431822418551933572982483664e-1L, 0 },
	TEST_c_c(cacos, -0x1p-52L, -0x1.0000000000001p0L, 1.570796326794896776240567560017239949909L, 8.813735870195431822418551933572982483664e-1L, 0 },
	TEST_c_c(cacos, 0x1.0000000000001p0L, 0x1p-52L, 9.590301705980041385828904092662391018164e-9L, -2.315303644582684770975188768022139415020e-8L, 0 },
	TEST_c_c(cacos, -0x1.0000000000001p0L, 0x1p-52L, 3.141592643999491532482601997450598791535L, -2.315303644582684770975188768022139415020e-8L, 0 },
	TEST_c_c(cacos, 0x1.0000000000001p0L, -0x1p-52L, 9.590301705980041385828904092662391018164e-9L, 2.315303644582684770975188768022139415020e-8L, 0 },
	TEST_c_c(cacos, -0x1.0000000000001p0L, -0x1p-52L, 3.141592643999491532482601997450598791535L, 2.315303644582684770975188768022139415020e-8L, 0 },
	TEST_c_c(cacos, 0x1.fp-1025L, 0x1.0000000000001p0L, 1.570796326794896619231321691639751442099L, -8.813735870195431822418551933572895326024e-1L, 0 },
	TEST_c_c(cacos, 0x1.fp-1025L, -0x1.0000000000001p0L, 1.570796326794896619231321691639751442099L, 8.813735870195431822418551933572895326024e-1L, 0 },
	TEST_c_c(cacos, -0x1.fp-1025L, 0x1.0000000000001p0L, 1.570796326794896619231321691639751442099L, -8.813735870195431822418551933572895326024e-1L, 0 },
	TEST_c_c(cacos, -0x1.fp-1025L, -0x1.0000000000001p0L, 1.570796326794896619231321691639751442099L, 8.813735870195431822418551933572895326024e-1L, 0 },
	TEST_c_c(cacos, 0x1.0000000000001p0L, 0x1.fp-1025L, 2.557178503953494342609835913586108008322e-301L, -2.107342425544701550354780375182800088393e-8L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0x1.0000000000001p0L, 0x1.fp-1025L, 3.141592653589793238462643383279502884197L, -2.107342425544701550354780375182800088393e-8L, 0 },
	TEST_c_c(cacos, 0x1.0000000000001p0L, -0x1.fp-1025L, 2.557178503953494342609835913586108008322e-301L, 2.107342425544701550354780375182800088393e-8L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0x1.0000000000001p0L, -0x1.fp-1025L, 3.141592653589793238462643383279502884197L, 2.107342425544701550354780375182800088393e-8L, 0 },
	TEST_c_c(cacos, 0.0L, 0x1.0000000000001p0L, 1.570796326794896619231321691639751442099L, -8.813735870195431822418551933572895326024e-1L, 0 },
	TEST_c_c(cacos, 0.0L, -0x1.0000000000001p0L, 1.570796326794896619231321691639751442099L, 8.813735870195431822418551933572895326024e-1L, 0 },
	TEST_c_c(cacos, -0.0L, 0x1.0000000000001p0L, 1.570796326794896619231321691639751442099L, -8.813735870195431822418551933572895326024e-1L, 0 },
	TEST_c_c(cacos, -0.0L, -0x1.0000000000001p0L, 1.570796326794896619231321691639751442099L, 8.813735870195431822418551933572895326024e-1L, 0 },
	TEST_c_c(cacos, 0x1.0000000000001p0L, 0.0L, 0.0L, -2.107342425544701550354780375182800088393e-8L, 0 },
	TEST_c_c(cacos, -0x1.0000000000001p0L, 0.0L, 3.141592653589793238462643383279502884197L, -2.107342425544701550354780375182800088393e-8L, 0 },
	TEST_c_c(cacos, 0x1.0000000000001p0L, -0.0L, 0.0L, 2.107342425544701550354780375182800088393e-8L, 0 },
	TEST_c_c(cacos, -0x1.0000000000001p0L, -0.0L, 3.141592653589793238462643383279502884197L, 2.107342425544701550354780375182800088393e-8L, 0 },
#endif
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	TEST_c_c(cacos, 0x1p-63L, 0x1.0000000000000002p0L, 1.570796326794896619154657020805582738031L, -8.813735870195430253092739958139610131001e-1L, 0 },
	TEST_c_c(cacos, 0x1p-63L, -0x1.0000000000000002p0L, 1.570796326794896619154657020805582738031L, 8.813735870195430253092739958139610131001e-1L, 0 },
	TEST_c_c(cacos, -0x1p-63L, 0x1.0000000000000002p0L, 1.570796326794896619307986362473920146166L, -8.813735870195430253092739958139610131001e-1L, 0 },
	TEST_c_c(cacos, -0x1p-63L, -0x1.0000000000000002p0L, 1.570796326794896619307986362473920146166L, 8.813735870195430253092739958139610131001e-1L, 0 },
	TEST_c_c(cacos, 0x1.0000000000000002p0L, 0x1p-63L, 2.119177303101063432592523199680782317447e-10L, -5.116146586219826555037807251857670783420e-10L, 0 },
	TEST_c_c(cacos, -0x1.0000000000000002p0L, 0x1p-63L, 3.141592653377875508152537040020250564229L, -5.116146586219826555037807251857670783420e-10L, 0 },
	TEST_c_c(cacos, 0x1.0000000000000002p0L, -0x1p-63L, 2.119177303101063432592523199680782317447e-10L, 5.116146586219826555037807251857670783420e-10L, 0 },
	TEST_c_c(cacos, -0x1.0000000000000002p0L, -0x1p-63L, 3.141592653377875508152537040020250564229L, 5.116146586219826555037807251857670783420e-10L, 0 },
# if LDBL_MIN_EXP <= -16381
	TEST_c_c(cacos, 0x1.fp-16385L, 0x1.0000000000000002p0L, 1.570796326794896619231321691639751442099L, -8.813735870195430253092739958139610130980e-1L, 0 },
	TEST_c_c(cacos, 0x1.fp-16385L, -0x1.0000000000000002p0L, 1.570796326794896619231321691639751442099L, 8.813735870195430253092739958139610130980e-1L, 0 },
	TEST_c_c(cacos, -0x1.fp-16385L, 0x1.0000000000000002p0L, 1.570796326794896619231321691639751442099L, -8.813735870195430253092739958139610130980e-1L, 0 },
	TEST_c_c(cacos, -0x1.fp-16385L, -0x1.0000000000000002p0L, 1.570796326794896619231321691639751442099L, 8.813735870195430253092739958139610130980e-1L, 0 },
	TEST_c_c(cacos, 0x1.0000000000000002p0L, 0x1.fp-16385L, 1.748608650034385653922359120438227480943e-4923L, -4.656612873077392578082927418388212703712e-10L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacos, -0x1.0000000000000002p0L, 0x1.fp-16385L, 3.141592653589793238462643383279502884197L, -4.656612873077392578082927418388212703712e-10L, 0 },
	TEST_c_c(cacos, 0x1.0000000000000002p0L, -0x1.fp-16385L, 1.748608650034385653922359120438227480943e-4923L, 4.656612873077392578082927418388212703712e-10L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacos, -0x1.0000000000000002p0L, -0x1.fp-16385L, 3.141592653589793238462643383279502884197L, 4.656612873077392578082927418388212703712e-10L, 0 },
# endif
	TEST_c_c(cacos, 0.0L, 0x1.0000000000000002p0L, 1.570796326794896619231321691639751442099L, -8.813735870195430253092739958139610130980e-1L, 0 },
	TEST_c_c(cacos, 0.0L, -0x1.0000000000000002p0L, 1.570796326794896619231321691639751442099L, 8.813735870195430253092739958139610130980e-1L, 0 },
	TEST_c_c(cacos, -0.0L, 0x1.0000000000000002p0L, 1.570796326794896619231321691639751442099L, -8.813735870195430253092739958139610130980e-1L, 0 },
	TEST_c_c(cacos, -0.0L, -0x1.0000000000000002p0L, 1.570796326794896619231321691639751442099L, 8.813735870195430253092739958139610130980e-1L, 0 },
	TEST_c_c(cacos, 0x1.0000000000000002p0L, 0.0L, 0.0L, -4.656612873077392578082927418388212703712e-10L, 0 },
	TEST_c_c(cacos, -0x1.0000000000000002p0L, 0.0L, 3.141592653589793238462643383279502884197L, -4.656612873077392578082927418388212703712e-10L, 0 },
	TEST_c_c(cacos, 0x1.0000000000000002p0L, -0.0L, 0.0L, 4.656612873077392578082927418388212703712e-10L, 0 },
	TEST_c_c(cacos, -0x1.0000000000000002p0L, -0.0L, 3.141592653589793238462643383279502884197L, 4.656612873077392578082927418388212703712e-10L, 0 },
#endif
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 106
	TEST_c_c(cacos, 0x1p-106L, 0x1.000000000000000000000000008p0L, 1.570796326794896619231321691639742726335L, -8.813735870195430252326093249798097405561e-1L, 0 },
	TEST_c_c(cacos, 0x1p-106L, -0x1.000000000000000000000000008p0L, 1.570796326794896619231321691639742726335L, 8.813735870195430252326093249798097405561e-1L, 0 },
	TEST_c_c(cacos, -0x1p-106L, 0x1.000000000000000000000000008p0L, 1.570796326794896619231321691639760157863L, -8.813735870195430252326093249798097405561e-1L, 0 },
	TEST_c_c(cacos, -0x1p-106L, -0x1.000000000000000000000000008p0L, 1.570796326794896619231321691639760157863L, 8.813735870195430252326093249798097405561e-1L, 0 },
	TEST_c_c(cacos, 0x1.000000000000000000000000008p0L, 0x1p-106L, 5.394221422390606848017034778914096659726e-17L, -2.285028863093221674154232933662774454211e-16L, 0 },
	TEST_c_c(cacos, -0x1.000000000000000000000000008p0L, 0x1p-106L, 3.141592653589793184520429159373434404027L, -2.285028863093221674154232933662774454211e-16L, 0 },
	TEST_c_c(cacos, 0x1.000000000000000000000000008p0L, -0x1p-106L, 5.394221422390606848017034778914096659726e-17L, 2.285028863093221674154232933662774454211e-16L, 0 },
	TEST_c_c(cacos, -0x1.000000000000000000000000008p0L, -0x1p-106L, 3.141592653589793184520429159373434404027L, 2.285028863093221674154232933662774454211e-16L, 0 },
	TEST_c_c(cacos, 0x1.fp-1025L, 0x1.000000000000000000000000008p0L, 1.570796326794896619231321691639751442099L, -8.813735870195430252326093249798097405561e-1L, 0 },
	TEST_c_c(cacos, 0x1.fp-1025L, -0x1.000000000000000000000000008p0L, 1.570796326794896619231321691639751442099L, 8.813735870195430252326093249798097405561e-1L, 0 },
	TEST_c_c(cacos, -0x1.fp-1025L, 0x1.000000000000000000000000008p0L, 1.570796326794896619231321691639751442099L, -8.813735870195430252326093249798097405561e-1L, 0 },
	TEST_c_c(cacos, -0x1.fp-1025L, -0x1.000000000000000000000000008p0L, 1.570796326794896619231321691639751442099L, 8.813735870195430252326093249798097405561e-1L, 0 },
	TEST_c_c(cacos, 0x1.000000000000000000000000008p0L, 0x1.fp-1025L, 2.426922623448365473354662093431821897807e-293L, -2.220446049250313080847263336181636063482e-16L, 0 },
	TEST_c_c(cacos, -0x1.000000000000000000000000008p0L, 0x1.fp-1025L, 3.141592653589793238462643383279502884197L, -2.220446049250313080847263336181636063482e-16L, 0 },
	TEST_c_c(cacos, 0x1.000000000000000000000000008p0L, -0x1.fp-1025L, 2.426922623448365473354662093431821897807e-293L, 2.220446049250313080847263336181636063482e-16L, 0 },
	TEST_c_c(cacos, -0x1.000000000000000000000000008p0L, -0x1.fp-1025L, 3.141592653589793238462643383279502884197L, 2.220446049250313080847263336181636063482e-16L, 0 },
	TEST_c_c(cacos, 0.0L, 0x1.000000000000000000000000008p0L, 1.570796326794896619231321691639751442099L, -8.813735870195430252326093249798097405561e-1L, 0 },
	TEST_c_c(cacos, 0.0L, -0x1.000000000000000000000000008p0L, 1.570796326794896619231321691639751442099L, 8.813735870195430252326093249798097405561e-1L, 0 },
	TEST_c_c(cacos, -0.0L, 0x1.000000000000000000000000008p0L, 1.570796326794896619231321691639751442099L, -8.813735870195430252326093249798097405561e-1L, 0 },
	TEST_c_c(cacos, -0.0L, -0x1.000000000000000000000000008p0L, 1.570796326794896619231321691639751442099L, 8.813735870195430252326093249798097405561e-1L, 0 },
	TEST_c_c(cacos, 0x1.000000000000000000000000008p0L, 0.0L, 0.0L, -2.220446049250313080847263336181636063482e-16L, 0 },
	TEST_c_c(cacos, -0x1.000000000000000000000000008p0L, 0.0L, 3.141592653589793238462643383279502884197L, -2.220446049250313080847263336181636063482e-16L, 0 },
	TEST_c_c(cacos, 0x1.000000000000000000000000008p0L, -0.0L, 0.0L, 2.220446049250313080847263336181636063482e-16L, 0 },
	TEST_c_c(cacos, -0x1.000000000000000000000000008p0L, -0.0L, 3.141592653589793238462643383279502884197L, 2.220446049250313080847263336181636063482e-16L, 0 },
#endif
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 113
	TEST_c_c(cacos, 0x1p-113L, 0x1.0000000000000000000000000001p0L, 1.570796326794896619231321691639751374007L, -8.813735870195430252326093249797924452120e-1L, 0 },
	TEST_c_c(cacos, 0x1p-113L, -0x1.0000000000000000000000000001p0L, 1.570796326794896619231321691639751374007L, 8.813735870195430252326093249797924452120e-1L, 0 },
	TEST_c_c(cacos, -0x1p-113L, 0x1.0000000000000000000000000001p0L, 1.570796326794896619231321691639751510190L, -8.813735870195430252326093249797924452120e-1L, 0 },
	TEST_c_c(cacos, -0x1p-113L, -0x1.0000000000000000000000000001p0L, 1.570796326794896619231321691639751510190L, 8.813735870195430252326093249797924452120e-1L, 0 },
	TEST_c_c(cacos, 0x1.0000000000000000000000000001p0L, 0x1p-113L, 4.767863183742677481693563511435642755521e-18L, -2.019699255375255198156433710951064632386e-17L, 0 },
	TEST_c_c(cacos, -0x1.0000000000000000000000000001p0L, 0x1p-113L, 3.141592653589793233694780199536825402504L, -2.019699255375255198156433710951064632386e-17L, 0 },
	TEST_c_c(cacos, 0x1.0000000000000000000000000001p0L, -0x1p-113L, 4.767863183742677481693563511435642755521e-18L, 2.019699255375255198156433710951064632386e-17L, 0 },
	TEST_c_c(cacos, -0x1.0000000000000000000000000001p0L, -0x1p-113L, 3.141592653589793233694780199536825402504L, 2.019699255375255198156433710951064632386e-17L, 0 },
	TEST_c_c(cacos, 0x1.fp-16385L, 0x1.0000000000000000000000000001p0L, 1.570796326794896619231321691639751442099L, -8.813735870195430252326093249797924452120e-1L, 0 },
	TEST_c_c(cacos, 0x1.fp-16385L, -0x1.0000000000000000000000000001p0L, 1.570796326794896619231321691639751442099L, 8.813735870195430252326093249797924452120e-1L, 0 },
	TEST_c_c(cacos, -0x1.fp-16385L, 0x1.0000000000000000000000000001p0L, 1.570796326794896619231321691639751442099L, -8.813735870195430252326093249797924452120e-1L, 0 },
	TEST_c_c(cacos, -0x1.fp-16385L, -0x1.0000000000000000000000000001p0L, 1.570796326794896619231321691639751442099L, 8.813735870195430252326093249797924452120e-1L, 0 },
	TEST_c_c(cacos, 0x1.0000000000000000000000000001p0L, 0x1.fp-16385L, 4.148847925325683229178506116378864361396e-4916L, -1.962615573354718824241727964954454332780e-17L, 0 },
	TEST_c_c(cacos, -0x1.0000000000000000000000000001p0L, 0x1.fp-16385L, 3.141592653589793238462643383279502884197L, -1.962615573354718824241727964954454332780e-17L, 0 },
	TEST_c_c(cacos, 0x1.0000000000000000000000000001p0L, -0x1.fp-16385L, 4.148847925325683229178506116378864361396e-4916L, 1.962615573354718824241727964954454332780e-17L, 0 },
	TEST_c_c(cacos, -0x1.0000000000000000000000000001p0L, -0x1.fp-16385L, 3.141592653589793238462643383279502884197L, 1.962615573354718824241727964954454332780e-17L, 0 },
	TEST_c_c(cacos, 0.0L, 0x1.0000000000000000000000000001p0L, 1.570796326794896619231321691639751442099L, -8.813735870195430252326093249797924452120e-1L, 0 },
	TEST_c_c(cacos, 0.0L, -0x1.0000000000000000000000000001p0L, 1.570796326794896619231321691639751442099L, 8.813735870195430252326093249797924452120e-1L, 0 },
	TEST_c_c(cacos, -0.0L, 0x1.0000000000000000000000000001p0L, 1.570796326794896619231321691639751442099L, -8.813735870195430252326093249797924452120e-1L, 0 },
	TEST_c_c(cacos, -0.0L, -0x1.0000000000000000000000000001p0L, 1.570796326794896619231321691639751442099L, 8.813735870195430252326093249797924452120e-1L, 0 },
	TEST_c_c(cacos, 0x1.0000000000000000000000000001p0L, 0.0L, 0.0L, -1.962615573354718824241727964954454332780e-17L, 0 },
	TEST_c_c(cacos, -0x1.0000000000000000000000000001p0L, 0.0L, 3.141592653589793238462643383279502884197L, -1.962615573354718824241727964954454332780e-17L, 0 },
	TEST_c_c(cacos, 0x1.0000000000000000000000000001p0L, -0.0L, 0.0L, 1.962615573354718824241727964954454332780e-17L, 0 },
	TEST_c_c(cacos, -0x1.0000000000000000000000000001p0L, -0.0L, 3.141592653589793238462643383279502884197L, 1.962615573354718824241727964954454332780e-17L, 0 },
#endif

	TEST_c_c(cacos, 0x1p-23L, 0x0.ffffffp0L, 1.570796242501197085295336701632142060969L, -8.813735448726963984495965873956465777250e-1L, 0 },
	TEST_c_c(cacos, 0x1p-23L, -0x0.ffffffp0L, 1.570796242501197085295336701632142060969L, 8.813735448726963984495965873956465777250e-1L, 0 },
	TEST_c_c(cacos, -0x1p-23L, 0x0.ffffffp0L, 1.570796411088596153167306681647360823228L, -8.813735448726963984495965873956465777250e-1L, 0 },
	TEST_c_c(cacos, -0x1p-23L, -0x0.ffffffp0L, 1.570796411088596153167306681647360823228L, 8.813735448726963984495965873956465777250e-1L, 0 },
	TEST_c_c(cacos, 0x0.ffffffp0L, 0x1p-23L, 4.391863861910487109445187743978204002614e-4L, -2.714321200917194650737217746780928423385e-4L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacos, -0x0.ffffffp0L, 0x1p-23L, 3.141153467203602189751698864505105063797L, -2.714321200917194650737217746780928423385e-4L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacos, 0x0.ffffffp0L, -0x1p-23L, 4.391863861910487109445187743978204002614e-4L, 2.714321200917194650737217746780928423385e-4L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacos, -0x0.ffffffp0L, -0x1p-23L, 3.141153467203602189751698864505105063797L, 2.714321200917194650737217746780928423385e-4L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacos, 0x1.fp-129L, 0x0.ffffffp0L, 1.570796326794896619231321691639751442097L, -8.813735448726938863015878255140556727969e-1L, 0 },
	TEST_c_c(cacos, 0x1.fp-129L, -0x0.ffffffp0L, 1.570796326794896619231321691639751442097L, 8.813735448726938863015878255140556727969e-1L, 0 },
	TEST_c_c(cacos, -0x1.fp-129L, 0x0.ffffffp0L, 1.570796326794896619231321691639751442101L, -8.813735448726938863015878255140556727969e-1L, 0 },
	TEST_c_c(cacos, -0x1.fp-129L, -0x0.ffffffp0L, 1.570796326794896619231321691639751442101L, 8.813735448726938863015878255140556727969e-1L, 0 },
	TEST_c_c(cacos, 0x0.ffffffp0L, 0x1.fp-129L, 3.452669847162035876032494826387364972849e-4L, -8.245504387859737323891843603996428534945e-36L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0x0.ffffffp0L, 0x1.fp-129L, 3.141247386605077034875040133796864147700L, -8.245504387859737323891843603996428534945e-36L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, 0x0.ffffffp0L, -0x1.fp-129L, 3.452669847162035876032494826387364972849e-4L, 8.245504387859737323891843603996428534945e-36L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0x0.ffffffp0L, -0x1.fp-129L, 3.141247386605077034875040133796864147700L, 8.245504387859737323891843603996428534945e-36L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, 0.0L, 0x0.ffffffp0L, 1.570796326794896619231321691639751442099L, -8.813735448726938863015878255140556727969e-1L, 0 },
	TEST_c_c(cacos, 0.0L, -0x0.ffffffp0L, 1.570796326794896619231321691639751442099L, 8.813735448726938863015878255140556727969e-1L, 0 },
	TEST_c_c(cacos, -0.0L, 0x0.ffffffp0L, 1.570796326794896619231321691639751442099L, -8.813735448726938863015878255140556727969e-1L, 0 },
	TEST_c_c(cacos, -0.0L, -0x0.ffffffp0L, 1.570796326794896619231321691639751442099L, 8.813735448726938863015878255140556727969e-1L, 0 },
	TEST_c_c(cacos, 0x0.ffffffp0L, 0.0L, 3.452669847162035876032494826387364972849e-4L, -0.0L, 0|XFAIL_NATIVE_LINUXF|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0x0.ffffffp0L, 0.0L, 3.141247386605077034875040133796864147700L, -0.0L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, 0x0.ffffffp0L, -0.0L, 3.452669847162035876032494826387364972849e-4L, 0.0L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacos, -0x0.ffffffp0L, -0.0L, 3.141247386605077034875040133796864147700L, 0.0L, 0 },
	TEST_c_c(cacos, 0x1p-23L, 0.5L, 1.570796220170866625230343643673321150378L, -4.812118250596059896127318386463676808798e-1L, 0 },
	TEST_c_c(cacos, 0x1p-23L, -0.5L, 1.570796220170866625230343643673321150378L, 4.812118250596059896127318386463676808798e-1L, 0 },
	TEST_c_c(cacos, -0x1p-23L, 0.5L, 1.570796433418926613232299739606181733819L, -4.812118250596059896127318386463676808798e-1L, 0 },
	TEST_c_c(cacos, -0x1p-23L, -0.5L, 1.570796433418926613232299739606181733819L, 4.812118250596059896127318386463676808798e-1L, 0 },
	TEST_c_c(cacos, 0.5L, 0x1p-23L, 1.047197551196603215914744618665204532273L, -1.376510308240943236356088341381173571841e-7L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacos, -0.5L, 0x1p-23L, 2.094395102393190022547898764614298351924L, -1.376510308240943236356088341381173571841e-7L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacos, 0.5L, -0x1p-23L, 1.047197551196603215914744618665204532273L, 1.376510308240943236356088341381173571841e-7L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacos, -0.5L, -0x1p-23L, 2.094395102393190022547898764614298351924L, 1.376510308240943236356088341381173571841e-7L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacos, 0x1.fp-129L, 0.5L, 1.570796326794896619231321691639751442096L, -4.812118250596034474977589134243684231352e-1L, 0 },
	TEST_c_c(cacos, 0x1.fp-129L, -0.5L, 1.570796326794896619231321691639751442096L, 4.812118250596034474977589134243684231352e-1L, 0 },
	TEST_c_c(cacos, -0x1.fp-129L, 0.5L, 1.570796326794896619231321691639751442101L, -4.812118250596034474977589134243684231352e-1L, 0 },
	TEST_c_c(cacos, -0x1.fp-129L, -0.5L, 1.570796326794896619231321691639751442101L, 4.812118250596034474977589134243684231352e-1L, 0 },
	TEST_c_c(cacos, 0.5L, 0x1.fp-129L, 1.047197551196597746154214461093167628066L, -3.287317402534702257036015056278368274737e-39L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0.5L, 0x1.fp-129L, 2.094395102393195492308428922186335256131L, -3.287317402534702257036015056278368274737e-39L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, 0.5L, -0x1.fp-129L, 1.047197551196597746154214461093167628066L, 3.287317402534702257036015056278368274737e-39L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0.5L, -0x1.fp-129L, 2.094395102393195492308428922186335256131L, 3.287317402534702257036015056278368274737e-39L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, 0x1p-23L, 0x1p-23L, 1.570796207585607068450636380271254316214L, -1.192092895507818146886315028596704749235e-7L, 0 },
	TEST_c_c(cacos, 0x1p-23L, -0x1p-23L, 1.570796207585607068450636380271254316214L, 1.192092895507818146886315028596704749235e-7L, 0 },
	TEST_c_c(cacos, -0x1p-23L, 0x1p-23L, 1.570796446004186170012007003008248567984L, -1.192092895507818146886315028596704749235e-7L, 0 },
	TEST_c_c(cacos, -0x1p-23L, -0x1p-23L, 1.570796446004186170012007003008248567984L, 1.192092895507818146886315028596704749235e-7L, 0 },
	TEST_c_c(cacos, 0x1.fp-129L, 0x1p-23L, 1.570796326794896619231321691639751442096L, -1.192092895507809676556842485683592032154e-7L, 0 },
	TEST_c_c(cacos, 0x1.fp-129L, -0x1p-23L, 1.570796326794896619231321691639751442096L, 1.192092895507809676556842485683592032154e-7L, 0 },
	TEST_c_c(cacos, -0x1.fp-129L, 0x1p-23L, 1.570796326794896619231321691639751442101L, -1.192092895507809676556842485683592032154e-7L, 0 },
	TEST_c_c(cacos, -0x1.fp-129L, -0x1p-23L, 1.570796326794896619231321691639751442101L, 1.192092895507809676556842485683592032154e-7L, 0 },
	TEST_c_c(cacos, 0x1p-23L, 0x1.fp-129L, 1.570796207585607068449789347324000006847L, -2.846900380897747786805634596726756660388e-39L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0x1p-23L, 0x1.fp-129L, 1.570796446004186170012854035955502877351L, -2.846900380897747786805634596726756660388e-39L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, 0x1p-23L, -0x1.fp-129L, 1.570796207585607068449789347324000006847L, 2.846900380897747786805634596726756660388e-39L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0x1p-23L, -0x1.fp-129L, 1.570796446004186170012854035955502877351L, 2.846900380897747786805634596726756660388e-39L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, 0.0L, 0x1p-23L, 1.570796326794896619231321691639751442099L, -1.192092895507809676556842485683592032154e-7L, 0 },
	TEST_c_c(cacos, 0.0L, -0x1p-23L, 1.570796326794896619231321691639751442099L, 1.192092895507809676556842485683592032154e-7L, 0 },
	TEST_c_c(cacos, -0.0L, 0x1p-23L, 1.570796326794896619231321691639751442099L, -1.192092895507809676556842485683592032154e-7L, 0 },
	TEST_c_c(cacos, -0.0L, -0x1p-23L, 1.570796326794896619231321691639751442099L, 1.192092895507809676556842485683592032154e-7L, 0 },
	TEST_c_c(cacos, 0x1p-23L, 0.0L, 1.570796207585607068449789347324000006847L, -0.0L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0x1p-23L, 0.0L, 1.570796446004186170012854035955502877351L, -0.0L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, 0x1p-23L, -0.0L, 1.570796207585607068449789347324000006847L, 0.0L, 0 },
	TEST_c_c(cacos, -0x1p-23L, -0.0L, 1.570796446004186170012854035955502877351L, 0.0L, 0 },
	TEST_c_c(cacos, 0x1.fp-129L, 0x1.fp-129L, 1.570796326794896619231321691639751442096L, -2.846900380897727558361783801085126250967e-39L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, 0x1.fp-129L, -0x1.fp-129L, 1.570796326794896619231321691639751442096L, 2.846900380897727558361783801085126250967e-39L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0x1.fp-129L, 0x1.fp-129L, 1.570796326794896619231321691639751442101L, -2.846900380897727558361783801085126250967e-39L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0x1.fp-129L, -0x1.fp-129L, 1.570796326794896619231321691639751442101L, 2.846900380897727558361783801085126250967e-39L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
#ifndef TEST_FLOAT
	TEST_c_c(cacos, 0x1p-52L, 0x0.fffffffffffff8p0L, 1.570796326794896462222075823262236786996L, -8.813735870195429467279863907910458761820e-1L, 0 },
	TEST_c_c(cacos, 0x1p-52L, -0x0.fffffffffffff8p0L, 1.570796326794896462222075823262236786996L, 8.813735870195429467279863907910458761820e-1L, 0 },
	TEST_c_c(cacos, -0x1p-52L, 0x0.fffffffffffff8p0L, 1.570796326794896776240567560017266097201L, -8.813735870195429467279863907910458761820e-1L, 0 },
	TEST_c_c(cacos, -0x1p-52L, -0x0.fffffffffffff8p0L, 1.570796326794896776240567560017266097201L, 8.813735870195429467279863907910458761820e-1L, 0 },
	TEST_c_c(cacos, 0x0.fffffffffffff8p0L, 0x1p-52L, 1.895456983915074112227925127005564372844e-8L, -1.171456840272878582596796205397918831268e-8L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0x0.fffffffffffff8p0L, 0x1p-52L, 3.141592634635223399311902261000251614142L, -1.171456840272878582596796205397918831268e-8L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, 0x0.fffffffffffff8p0L, -0x1p-52L, 1.895456983915074112227925127005564372844e-8L, 1.171456840272878582596796205397918831268e-8L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0x0.fffffffffffff8p0L, -0x1p-52L, 3.141592634635223399311902261000251614142L, 1.171456840272878582596796205397918831268e-8L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, 0x1.fp-1025L, 0x0.fffffffffffff8p0L, 1.570796326794896619231321691639751442099L, -8.813735870195429467279863907910371604180e-1L, 0 },
	TEST_c_c(cacos, 0x1.fp-1025L, -0x0.fffffffffffff8p0L, 1.570796326794896619231321691639751442099L, 8.813735870195429467279863907910371604180e-1L, 0 },
	TEST_c_c(cacos, -0x1.fp-1025L, 0x0.fffffffffffff8p0L, 1.570796326794896619231321691639751442099L, -8.813735870195429467279863907910371604180e-1L, 0 },
	TEST_c_c(cacos, -0x1.fp-1025L, -0x0.fffffffffffff8p0L, 1.570796326794896619231321691639751442099L, 8.813735870195429467279863907910371604180e-1L, 0 },
	TEST_c_c(cacos, 0x0.fffffffffffff8p0L, 0x1.fp-1025L, 1.490116119384765638786343542550461592240e-8L, -3.616396521699973256461764099945789620604e-301L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0x0.fffffffffffff8p0L, 0x1.fp-1025L, 3.141592638688632044614986995416067458693L, -3.616396521699973256461764099945789620604e-301L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, 0x0.fffffffffffff8p0L, -0x1.fp-1025L, 1.490116119384765638786343542550461592240e-8L, 3.616396521699973256461764099945789620604e-301L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0x0.fffffffffffff8p0L, -0x1.fp-1025L, 3.141592638688632044614986995416067458693L, 3.616396521699973256461764099945789620604e-301L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, 0.0L, 0x0.fffffffffffff8p0L, 1.570796326794896619231321691639751442099L, -8.813735870195429467279863907910371604180e-1L, 0 },
	TEST_c_c(cacos, 0.0L, -0x0.fffffffffffff8p0L, 1.570796326794896619231321691639751442099L, 8.813735870195429467279863907910371604180e-1L, 0 },
	TEST_c_c(cacos, -0.0L, 0x0.fffffffffffff8p0L, 1.570796326794896619231321691639751442099L, -8.813735870195429467279863907910371604180e-1L, 0 },
	TEST_c_c(cacos, -0.0L, -0x0.fffffffffffff8p0L, 1.570796326794896619231321691639751442099L, 8.813735870195429467279863907910371604180e-1L, 0 },
	TEST_c_c(cacos, 0x0.fffffffffffff8p0L, 0.0L, 1.490116119384765638786343542550461592240e-8L, -0.0L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0x0.fffffffffffff8p0L, 0.0L, 3.141592638688632044614986995416067458693L, -0.0L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, 0x0.fffffffffffff8p0L, -0.0L, 1.490116119384765638786343542550461592240e-8L, 0.0L, 0 },
	TEST_c_c(cacos, -0x0.fffffffffffff8p0L, -0.0L, 3.141592638688632044614986995416067458693L, 0.0L, 0 },
#endif
	TEST_c_c(cacos, 0x1p-52L, 0.5L, 1.570796326794896420628589431857911675917L, -4.812118250596034474977589134243772428682e-1L, 0 },
	TEST_c_c(cacos, 0x1p-52L, -0.5L, 1.570796326794896420628589431857911675917L, 4.812118250596034474977589134243772428682e-1L, 0 },
	TEST_c_c(cacos, -0x1p-52L, 0.5L, 1.570796326794896817834053951421591208280L, -4.812118250596034474977589134243772428682e-1L, 0 },
	TEST_c_c(cacos, -0x1p-52L, -0.5L, 1.570796326794896817834053951421591208280L, 4.812118250596034474977589134243772428682e-1L, 0 },
	TEST_c_c(cacos, 0.5L, 0x1p-52L, 1.047197551196597746154214461093186605110L, -2.563950248511418570403591756798643804971e-16L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0.5L, 0x1p-52L, 2.094395102393195492308428922186316279087L, -2.563950248511418570403591756798643804971e-16L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, 0.5L, -0x1p-52L, 1.047197551196597746154214461093186605110L, 2.563950248511418570403591756798643804971e-16L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0.5L, -0x1p-52L, 2.094395102393195492308428922186316279087L, 2.563950248511418570403591756798643804971e-16L, 0|XFAIL_NATIVE_LINUX },
#ifndef TEST_FLOAT
	TEST_c_c(cacos, 0x1.fp-1025L, 0.5L, 1.570796326794896619231321691639751442099L, -4.812118250596034474977589134243684231352e-1L, 0 },
	TEST_c_c(cacos, 0x1.fp-1025L, -0.5L, 1.570796326794896619231321691639751442099L, 4.812118250596034474977589134243684231352e-1L, 0 },
	TEST_c_c(cacos, -0x1.fp-1025L, 0.5L, 1.570796326794896619231321691639751442099L, -4.812118250596034474977589134243684231352e-1L, 0 },
	TEST_c_c(cacos, -0x1.fp-1025L, -0.5L, 1.570796326794896619231321691639751442099L, 4.812118250596034474977589134243684231352e-1L, 0 },
	TEST_c_c(cacos, 0.5L, 0x1.fp-1025L, 1.047197551196597746154214461093167628066L, -6.222508863508420569166420770843207333493e-309L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0.5L, 0x1.fp-1025L, 2.094395102393195492308428922186335256131L, -6.222508863508420569166420770843207333493e-309L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, 0.5L, -0x1.fp-1025L, 1.047197551196597746154214461093167628066L, 6.222508863508420569166420770843207333493e-309L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0.5L, -0x1.fp-1025L, 2.094395102393195492308428922186335256131L, 6.222508863508420569166420770843207333493e-309L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
#endif
	TEST_c_c(cacos, 0x1p-52L, 0x1p-52L, 1.570796326794896397186716766608443357372L, -2.220446049250313080847263336181677117148e-16L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacos, 0x1p-52L, -0x1p-52L, 1.570796326794896397186716766608443357372L, 2.220446049250313080847263336181677117148e-16L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacos, -0x1p-52L, 0x1p-52L, 1.570796326794896841275926616671059526825L, -2.220446049250313080847263336181677117148e-16L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacos, -0x1p-52L, -0x1p-52L, 1.570796326794896841275926616671059526825L, 2.220446049250313080847263336181677117148e-16L, 0|XFAIL_NATIVE_LINUXF },
#ifndef TEST_FLOAT
	TEST_c_c(cacos, 0x1.fp-1025L, 0x1p-52L, 1.570796326794896619231321691639751442099L, -2.220446049250313080847263336181622378926e-16L, 0 },
	TEST_c_c(cacos, 0x1.fp-1025L, -0x1p-52L, 1.570796326794896619231321691639751442099L, 2.220446049250313080847263336181622378926e-16L, 0 },
	TEST_c_c(cacos, -0x1.fp-1025L, 0x1p-52L, 1.570796326794896619231321691639751442099L, -2.220446049250313080847263336181622378926e-16L, 0 },
	TEST_c_c(cacos, -0x1.fp-1025L, -0x1p-52L, 1.570796326794896619231321691639751442099L, 2.220446049250313080847263336181622378926e-16L, 0 },
	TEST_c_c(cacos, 0x1p-52L, 0x1.fp-1025L, 1.570796326794896397186716766608443357372L, -5.388850751072128349671657362289548938458e-309L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0x1p-52L, 0x1.fp-1025L, 1.570796326794896841275926616671059526825L, -5.388850751072128349671657362289548938458e-309L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, 0x1p-52L, -0x1.fp-1025L, 1.570796326794896397186716766608443357372L, 5.388850751072128349671657362289548938458e-309L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0x1p-52L, -0x1.fp-1025L, 1.570796326794896841275926616671059526825L, 5.388850751072128349671657362289548938458e-309L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
#endif
	TEST_c_c(cacos, 0.0L, 0x1p-52L, 1.570796326794896619231321691639751442099L, -2.220446049250313080847263336181622378926e-16L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacos, 0.0L, -0x1p-52L, 1.570796326794896619231321691639751442099L, 2.220446049250313080847263336181622378926e-16L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacos, -0.0L, 0x1p-52L, 1.570796326794896619231321691639751442099L, -2.220446049250313080847263336181622378926e-16L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacos, -0.0L, -0x1p-52L, 1.570796326794896619231321691639751442099L, 2.220446049250313080847263336181622378926e-16L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacos, 0x1p-52L, 0.0L, 1.570796326794896397186716766608443357372L, -0.0L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0x1p-52L, 0.0L, 1.570796326794896841275926616671059526825L, -0.0L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, 0x1p-52L, -0.0L, 1.570796326794896397186716766608443357372L, 0.0L, 0 },
	TEST_c_c(cacos, -0x1p-52L, -0.0L, 1.570796326794896841275926616671059526825L, 0.0L, 0 },
#ifndef TEST_FLOAT
	TEST_c_c(cacos, 0x1.fp-1025L, 0x1.fp-1025L, 1.570796326794896619231321691639751442099L, -5.388850751072128349671657362289416093031e-309L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, 0x1.fp-1025L, -0x1.fp-1025L, 1.570796326794896619231321691639751442099L, 5.388850751072128349671657362289416093031e-309L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0x1.fp-1025L, 0x1.fp-1025L, 1.570796326794896619231321691639751442099L, -5.388850751072128349671657362289416093031e-309L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0x1.fp-1025L, -0x1.fp-1025L, 1.570796326794896619231321691639751442099L, 5.388850751072128349671657362289416093031e-309L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
#endif
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	TEST_c_c(cacos, 0x1p-63L, 0x0.ffffffffffffffffp0L, 1.570796326794896619154657020805582738025L, -8.813735870195430251942769895627079569937e-1L, 0 },
	TEST_c_c(cacos, 0x1p-63L, -0x0.ffffffffffffffffp0L, 1.570796326794896619154657020805582738025L, 8.813735870195430251942769895627079569937e-1L, 0 },
	TEST_c_c(cacos, -0x1p-63L, 0x0.ffffffffffffffffp0L, 1.570796326794896619307986362473920146173L, -8.813735870195430251942769895627079569937e-1L, 0 },
	TEST_c_c(cacos, -0x1p-63L, -0x0.ffffffffffffffffp0L, 1.570796326794896619307986362473920146173L, 8.813735870195430251942769895627079569937e-1L, 0 },
	TEST_c_c(cacos, 0x0.ffffffffffffffffp0L, 0x1p-63L, 4.188407771167967636741951941902992986043e-10L, -2.588578361325995866221775673638805081337e-10L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacos, -0x0.ffffffffffffffffp0L, 0x1p-63L, 3.141592653170952461345846619605307690007L, -2.588578361325995866221775673638805081337e-10L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacos, 0x0.ffffffffffffffffp0L, -0x1p-63L, 4.188407771167967636741951941902992986043e-10L, 2.588578361325995866221775673638805081337e-10L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacos, -0x0.ffffffffffffffffp0L, -0x1p-63L, 3.141592653170952461345846619605307690007L, 2.588578361325995866221775673638805081337e-10L, 0|XFAIL_NATIVE_LINUXL },
# if LDBL_MIN_EXP <= -16381
	TEST_c_c(cacos, 0x1.fp-16385L, 0x0.ffffffffffffffffp0L, 1.570796326794896619231321691639751442099L, -8.813735870195430251942769895627079569917e-1L, 0 },
	TEST_c_c(cacos, 0x1.fp-16385L, -0x0.ffffffffffffffffp0L, 1.570796326794896619231321691639751442099L, 8.813735870195430251942769895627079569917e-1L, 0 },
	TEST_c_c(cacos, -0x1.fp-16385L, 0x0.ffffffffffffffffp0L, 1.570796326794896619231321691639751442099L, -8.813735870195430251942769895627079569917e-1L, 0 },
	TEST_c_c(cacos, -0x1.fp-16385L, -0x0.ffffffffffffffffp0L, 1.570796326794896619231321691639751442099L, 8.813735870195430251942769895627079569917e-1L, 0 },
	TEST_c_c(cacos, 0x0.ffffffffffffffffp0L, 0x1.fp-16385L, 3.292722539913596233371825532007990724506e-10L, -2.472906068161537187835415298076415423459e-4923L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacos, -0x0.ffffffffffffffffp0L, 0x1.fp-16385L, 3.141592653260520984471283759942320330996L, -2.472906068161537187835415298076415423459e-4923L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacos, 0x0.ffffffffffffffffp0L, -0x1.fp-16385L, 3.292722539913596233371825532007990724506e-10L, 2.472906068161537187835415298076415423459e-4923L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacos, -0x0.ffffffffffffffffp0L, -0x1.fp-16385L, 3.141592653260520984471283759942320330996L, 2.472906068161537187835415298076415423459e-4923L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
# endif
	TEST_c_c(cacos, 0.0L, 0x0.ffffffffffffffffp0L, 1.570796326794896619231321691639751442099L, -8.813735870195430251942769895627079569917e-1L, 0 },
	TEST_c_c(cacos, 0.0L, -0x0.ffffffffffffffffp0L, 1.570796326794896619231321691639751442099L, 8.813735870195430251942769895627079569917e-1L, 0 },
	TEST_c_c(cacos, -0.0L, 0x0.ffffffffffffffffp0L, 1.570796326794896619231321691639751442099L, -8.813735870195430251942769895627079569917e-1L, 0 },
	TEST_c_c(cacos, -0.0L, -0x0.ffffffffffffffffp0L, 1.570796326794896619231321691639751442099L, 8.813735870195430251942769895627079569917e-1L, 0 },
	TEST_c_c(cacos, 0x0.ffffffffffffffffp0L, 0.0L, 3.292722539913596233371825532007990724506e-10L, -0.0L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacos, -0x0.ffffffffffffffffp0L, 0.0L, 3.141592653260520984471283759942320330996L, -0.0L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacos, 0x0.ffffffffffffffffp0L, -0.0L, 3.292722539913596233371825532007990724506e-10L, 0.0L, 0 },
	TEST_c_c(cacos, -0x0.ffffffffffffffffp0L, -0.0L, 3.141592653260520984471283759942320330996L, 0.0L, 0 },
#endif
	TEST_c_c(cacos, 0x1p-63L, 0.5L, 1.570796326794896619134347701278529840650L, -4.812118250596034474977589134243684231373e-1L, 0 },
	TEST_c_c(cacos, 0x1p-63L, -0.5L, 1.570796326794896619134347701278529840650L, 4.812118250596034474977589134243684231373e-1L, 0 },
	TEST_c_c(cacos, -0x1p-63L, 0.5L, 1.570796326794896619328295682000973043547L, -4.812118250596034474977589134243684231373e-1L, 0 },
	TEST_c_c(cacos, -0x1p-63L, -0.5L, 1.570796326794896619328295682000973043547L, 4.812118250596034474977589134243684231373e-1L, 0 },
	TEST_c_c(cacos, 0.5L, 0x1p-63L, 1.047197551196597746154214461093167628070L, -1.251928832280966098829878787499365228659e-19L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0.5L, 0x1p-63L, 2.094395102393195492308428922186335256127L, -1.251928832280966098829878787499365228659e-19L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, 0.5L, -0x1p-63L, 1.047197551196597746154214461093167628070L, 1.251928832280966098829878787499365228659e-19L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0.5L, -0x1p-63L, 2.094395102393195492308428922186335256127L, 1.251928832280966098829878787499365228659e-19L, 0|XFAIL_NATIVE_LINUX },
#if defined TEST_LDOUBLE && LDBL_MIN_EXP <= -16381
	TEST_c_c(cacos, 0x1.fp-16385L, 0.5L, 1.570796326794896619231321691639751442099L, -4.812118250596034474977589134243684231352e-1L, 0 },
	TEST_c_c(cacos, 0x1.fp-16385L, -0.5L, 1.570796326794896619231321691639751442099L, 4.812118250596034474977589134243684231352e-1L, 0 },
	TEST_c_c(cacos, -0x1.fp-16385L, 0.5L, 1.570796326794896619231321691639751442099L, -4.812118250596034474977589134243684231352e-1L, 0 },
	TEST_c_c(cacos, -0x1.fp-16385L, -0.5L, 1.570796326794896619231321691639751442099L, 4.812118250596034474977589134243684231352e-1L, 0 },
	TEST_c_c(cacos, 0.5L, 0x1.fp-16385L, 1.047197551196597746154214461093167628066L, -9.402257155670418112159334875199821342890e-4933L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacos, -0.5L, 0x1.fp-16385L, 2.094395102393195492308428922186335256131L, -9.402257155670418112159334875199821342890e-4933L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacos, 0.5L, -0x1.fp-16385L, 1.047197551196597746154214461093167628066L, 9.402257155670418112159334875199821342890e-4933L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacos, -0.5L, -0x1.fp-16385L, 2.094395102393195492308428922186335256131L, 9.402257155670418112159334875199821342890e-4933L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
#endif
	TEST_c_c(cacos, 0x1p-63L, 0x1p-63L, 1.570796326794896619122901474391200998698L, -1.084202172485504434007452800869941711430e-19L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, 0x1p-63L, -0x1p-63L, 1.570796326794896619122901474391200998698L, 1.084202172485504434007452800869941711430e-19L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0x1p-63L, 0x1p-63L, 1.570796326794896619339741908888301885499L, -1.084202172485504434007452800869941711430e-19L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0x1p-63L, -0x1p-63L, 1.570796326794896619339741908888301885499L, 1.084202172485504434007452800869941711430e-19L, 0|XFAIL_NATIVE_LINUX },
#if defined TEST_LDOUBLE && LDBL_MIN_EXP <= -16381
	TEST_c_c(cacos, 0x1.fp-16385L, 0x1p-63L, 1.570796326794896619231321691639751442099L, -1.084202172485504434007452800869941711424e-19L, 0 },
	TEST_c_c(cacos, 0x1.fp-16385L, -0x1p-63L, 1.570796326794896619231321691639751442099L, 1.084202172485504434007452800869941711424e-19L, 0 },
	TEST_c_c(cacos, -0x1.fp-16385L, 0x1p-63L, 1.570796326794896619231321691639751442099L, -1.084202172485504434007452800869941711424e-19L, 0 },
	TEST_c_c(cacos, -0x1.fp-16385L, -0x1p-63L, 1.570796326794896619231321691639751442099L, 1.084202172485504434007452800869941711424e-19L, 0 },
	TEST_c_c(cacos, 0x1p-63L, 0x1.fp-16385L, 1.570796326794896619122901474391200998698L, -8.142593549724601460479922838826119584465e-4933L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacos, -0x1p-63L, 0x1.fp-16385L, 1.570796326794896619339741908888301885499L, -8.142593549724601460479922838826119584465e-4933L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacos, 0x1p-63L, -0x1.fp-16385L, 1.570796326794896619122901474391200998698L, 8.142593549724601460479922838826119584465e-4933L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacos, -0x1p-63L, -0x1.fp-16385L, 1.570796326794896619339741908888301885499L, 8.142593549724601460479922838826119584465e-4933L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
#endif
	TEST_c_c(cacos, 0.0L, 0x1p-63L, 1.570796326794896619231321691639751442099L, -1.084202172485504434007452800869941711424e-19L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, 0.0L, -0x1p-63L, 1.570796326794896619231321691639751442099L, 1.084202172485504434007452800869941711424e-19L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0.0L, 0x1p-63L, 1.570796326794896619231321691639751442099L, -1.084202172485504434007452800869941711424e-19L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0.0L, -0x1p-63L, 1.570796326794896619231321691639751442099L, 1.084202172485504434007452800869941711424e-19L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, 0x1p-63L, 0.0L, 1.570796326794896619122901474391200998698L, -0.0L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0x1p-63L, 0.0L, 1.570796326794896619339741908888301885499L, -0.0L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, 0x1p-63L, -0.0L, 1.570796326794896619122901474391200998698L, 0.0L, 0 },
	TEST_c_c(cacos, -0x1p-63L, -0.0L, 1.570796326794896619339741908888301885499L, 0.0L, 0 },
#if defined TEST_LDOUBLE && LDBL_MIN_EXP <= -16381
	TEST_c_c(cacos, 0x1.fp-16385L, 0x1.fp-16385L, 1.570796326794896619231321691639751442099L, -8.142593549724601460479922838826119584417e-4933L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacos, 0x1.fp-16385L, -0x1.fp-16385L, 1.570796326794896619231321691639751442099L, 8.142593549724601460479922838826119584417e-4933L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacos, -0x1.fp-16385L, 0x1.fp-16385L, 1.570796326794896619231321691639751442099L, -8.142593549724601460479922838826119584417e-4933L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacos, -0x1.fp-16385L, -0x1.fp-16385L, 1.570796326794896619231321691639751442099L, 8.142593549724601460479922838826119584417e-4933L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
#endif
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 106
	TEST_c_c(cacos, 0x1p-105L, 0x0.ffffffffffffffffffffffffffcp0L, 1.570796326794896619231321691639734010571L, -8.813735870195430252326093249797835932642e-1L, 0 },
	TEST_c_c(cacos, 0x1p-105L, -0x0.ffffffffffffffffffffffffffcp0L, 1.570796326794896619231321691639734010571L, 8.813735870195430252326093249797835932642e-1L, 0 },
	TEST_c_c(cacos, -0x1p-105L, 0x0.ffffffffffffffffffffffffffcp0L, 1.570796326794896619231321691639768873627L, -8.813735870195430252326093249797835932642e-1L, 0 },
	TEST_c_c(cacos, -0x1p-105L, -0x0.ffffffffffffffffffffffffffcp0L, 1.570796326794896619231321691639768873627L, 8.813735870195430252326093249797835932642e-1L, 0 },
	TEST_c_c(cacos, 0x0.ffffffffffffffffffffffffffcp0L, 0x1p-105L, 1.997188458999618357060632049675702684031e-16L, -1.234330349600789959989661887846005659983e-16L, 0 },
	TEST_c_c(cacos, -0x0.ffffffffffffffffffffffffffcp0L, 0x1p-105L, 3.141592653589793038743797483317667178134L, -1.234330349600789959989661887846005659983e-16L, 0 },
	TEST_c_c(cacos, 0x0.ffffffffffffffffffffffffffcp0L, -0x1p-105L, 1.997188458999618357060632049675702684031e-16L, 1.234330349600789959989661887846005659983e-16L, 0 },
	TEST_c_c(cacos, -0x0.ffffffffffffffffffffffffffcp0L, -0x1p-105L, 3.141592653589793038743797483317667178134L, 1.234330349600789959989661887846005659983e-16L, 0 },
	TEST_c_c(cacos, 0x1.fp-1025L, 0x0.ffffffffffffffffffffffffffcp0L, 1.570796326794896619231321691639751442099L, -8.813735870195430252326093249797835932642e-1L, 0 },
	TEST_c_c(cacos, 0x1.fp-1025L, -0x0.ffffffffffffffffffffffffffcp0L, 1.570796326794896619231321691639751442099L, 8.813735870195430252326093249797835932642e-1L, 0 },
	TEST_c_c(cacos, -0x1.fp-1025L, 0x0.ffffffffffffffffffffffffffcp0L, 1.570796326794896619231321691639751442099L, -8.813735870195430252326093249797835932642e-1L, 0 },
	TEST_c_c(cacos, -0x1.fp-1025L, -0x0.ffffffffffffffffffffffffffcp0L, 1.570796326794896619231321691639751442099L, 8.813735870195430252326093249797835932642e-1L, 0 },
	TEST_c_c(cacos, 0x0.ffffffffffffffffffffffffffcp0L, 0x1.fp-1025L, 1.570092458683775059393382371963565104164e-16L, -3.432186888910770473784103112009399360940e-293L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM },
	TEST_c_c(cacos, -0x0.ffffffffffffffffffffffffffcp0L, 0x1.fp-1025L, 3.141592653589793081453397514901996944859L, -3.432186888910770473784103112009399360940e-293L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM },
	TEST_c_c(cacos, 0x0.ffffffffffffffffffffffffffcp0L, -0x1.fp-1025L, 1.570092458683775059393382371963565104164e-16L, 3.432186888910770473784103112009399360940e-293L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM },
	TEST_c_c(cacos, -0x0.ffffffffffffffffffffffffffcp0L, -0x1.fp-1025L, 3.141592653589793081453397514901996944859L, 3.432186888910770473784103112009399360940e-293L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM },
	TEST_c_c(cacos, 0.0L, 0x0.ffffffffffffffffffffffffffcp0L, 1.570796326794896619231321691639751442099L, -8.813735870195430252326093249797835932642e-1L, 0 },
	TEST_c_c(cacos, 0.0L, -0x0.ffffffffffffffffffffffffffcp0L, 1.570796326794896619231321691639751442099L, 8.813735870195430252326093249797835932642e-1L, 0 },
	TEST_c_c(cacos, -0.0L, 0x0.ffffffffffffffffffffffffffcp0L, 1.570796326794896619231321691639751442099L, -8.813735870195430252326093249797835932642e-1L, 0 },
	TEST_c_c(cacos, -0.0L, -0x0.ffffffffffffffffffffffffffcp0L, 1.570796326794896619231321691639751442099L, 8.813735870195430252326093249797835932642e-1L, 0 },
	TEST_c_c(cacos, 0x0.ffffffffffffffffffffffffffcp0L, 0.0L, 1.570092458683775059393382371963565104164e-16L, -0.0L, 0 },
	TEST_c_c(cacos, -0x0.ffffffffffffffffffffffffffcp0L, 0.0L, 3.141592653589793081453397514901996944859L, -0.0L, 0 },
	TEST_c_c(cacos, 0x0.ffffffffffffffffffffffffffcp0L, -0.0L, 1.570092458683775059393382371963565104164e-16L, 0.0L, 0 },
	TEST_c_c(cacos, -0x0.ffffffffffffffffffffffffffcp0L, -0.0L, 3.141592653589793081453397514901996944859L, 0.0L, 0 },
#endif
	TEST_c_c(cacos, 0x1p-105L, 0.5L, 1.570796326794896619231321691639729392766L, -4.812118250596034474977589134243684231352e-1L, 0 },
	TEST_c_c(cacos, 0x1p-105L, -0.5L, 1.570796326794896619231321691639729392766L, 4.812118250596034474977589134243684231352e-1L, 0 },
	TEST_c_c(cacos, -0x1p-105L, 0.5L, 1.570796326794896619231321691639773491431L, -4.812118250596034474977589134243684231352e-1L, 0 },
	TEST_c_c(cacos, -0x1p-105L, -0.5L, 1.570796326794896619231321691639773491431L, 4.812118250596034474977589134243684231352e-1L, 0 },
	TEST_c_c(cacos, 0.5L, 0x1p-105L, 1.047197551196597746154214461093167628066L, -2.846556599890768890940941645338546615370e-32L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0.5L, 0x1p-105L, 2.094395102393195492308428922186335256131L, -2.846556599890768890940941645338546615370e-32L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, 0.5L, -0x1p-105L, 1.047197551196597746154214461093167628066L, 2.846556599890768890940941645338546615370e-32L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0.5L, -0x1p-105L, 2.094395102393195492308428922186335256131L, 2.846556599890768890940941645338546615370e-32L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, 0x1p-105L, 0x1p-105L, 1.570796326794896619231321691639726790195L, -2.465190328815661891911651766508706967729e-32L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, 0x1p-105L, -0x1p-105L, 1.570796326794896619231321691639726790195L, 2.465190328815661891911651766508706967729e-32L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0x1p-105L, 0x1p-105L, 1.570796326794896619231321691639776094002L, -2.465190328815661891911651766508706967729e-32L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0x1p-105L, -0x1p-105L, 1.570796326794896619231321691639776094002L, 2.465190328815661891911651766508706967729e-32L, 0|XFAIL_NATIVE_LINUX },
#ifndef TEST_FLOAT
	TEST_c_c(cacos, 0x1.fp-1025L, 0x1p-105L, 1.570796326794896619231321691639751442099L, -2.465190328815661891911651766508706967729e-32L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, 0x1.fp-1025L, -0x1p-105L, 1.570796326794896619231321691639751442099L, 2.465190328815661891911651766508706967729e-32L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0x1.fp-1025L, 0x1p-105L, 1.570796326794896619231321691639751442099L, -2.465190328815661891911651766508706967729e-32L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0x1.fp-1025L, -0x1p-105L, 1.570796326794896619231321691639751442099L, 2.465190328815661891911651766508706967729e-32L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, 0x1p-105L, 0x1.fp-1025L, 1.570796326794896619231321691639726790195L, -5.388850751072128349671657362289416093031e-309L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0x1p-105L, 0x1.fp-1025L, 1.570796326794896619231321691639776094002L, -5.388850751072128349671657362289416093031e-309L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, 0x1p-105L, -0x1.fp-1025L, 1.570796326794896619231321691639726790195L, 5.388850751072128349671657362289416093031e-309L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0x1p-105L, -0x1.fp-1025L, 1.570796326794896619231321691639776094002L, 5.388850751072128349671657362289416093031e-309L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
#endif
	TEST_c_c(cacos, 0.0L, 0x1p-105L, 1.570796326794896619231321691639751442099L, -2.465190328815661891911651766508706967729e-32L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, 0.0L, -0x1p-105L, 1.570796326794896619231321691639751442099L, 2.465190328815661891911651766508706967729e-32L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0.0L, 0x1p-105L, 1.570796326794896619231321691639751442099L, -2.465190328815661891911651766508706967729e-32L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0.0L, -0x1p-105L, 1.570796326794896619231321691639751442099L, 2.465190328815661891911651766508706967729e-32L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, 0x1p-105L, 0.0L, 1.570796326794896619231321691639726790195L, -0.0L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0x1p-105L, 0.0L, 1.570796326794896619231321691639776094002L, -0.0L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, 0x1p-105L, -0.0L, 1.570796326794896619231321691639726790195L, 0.0L, 0 },
	TEST_c_c(cacos, -0x1p-105L, -0.0L, 1.570796326794896619231321691639776094002L, 0.0L, 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 113
	TEST_c_c(cacos, 0x1p-112L, 0x0.ffffffffffffffffffffffffffff8p0L, 1.570796326794896619231321691639751305915L, -8.813735870195430252326093249797922409363e-1L, 0 },
	TEST_c_c(cacos, 0x1p-112L, -0x0.ffffffffffffffffffffffffffff8p0L, 1.570796326794896619231321691639751305915L, 8.813735870195430252326093249797922409363e-1L, 0 },
	TEST_c_c(cacos, -0x1p-112L, 0x0.ffffffffffffffffffffffffffff8p0L, 1.570796326794896619231321691639751578282L, -8.813735870195430252326093249797922409363e-1L, 0 },
	TEST_c_c(cacos, -0x1p-112L, -0x0.ffffffffffffffffffffffffffff8p0L, 1.570796326794896619231321691639751578282L, 8.813735870195430252326093249797922409363e-1L, 0 },
	TEST_c_c(cacos, 0x0.ffffffffffffffffffffffffffff8p0L, 0x1p-112L, 1.765281878332676474347460257221369818872e-17L, -1.091004200533850618345330909857103457781e-17L, 0 },
	TEST_c_c(cacos, -0x0.ffffffffffffffffffffffffffff8p0L, 0x1p-112L, 3.141592653589793220809824599952738140723L, -1.091004200533850618345330909857103457781e-17L, 0 },
	TEST_c_c(cacos, 0x0.ffffffffffffffffffffffffffff8p0L, -0x1p-112L, 1.765281878332676474347460257221369818872e-17L, 1.091004200533850618345330909857103457781e-17L, 0 },
	TEST_c_c(cacos, -0x0.ffffffffffffffffffffffffffff8p0L, -0x1p-112L, 3.141592653589793220809824599952738140723L, 1.091004200533850618345330909857103457781e-17L, 0 },
	TEST_c_c(cacos, 0x1.fp-16385L, 0x0.ffffffffffffffffffffffffffff8p0L, 1.570796326794896619231321691639751442099L, -8.813735870195430252326093249797922409363e-1L, 0 },
	TEST_c_c(cacos, 0x1.fp-16385L, -0x0.ffffffffffffffffffffffffffff8p0L, 1.570796326794896619231321691639751442099L, 8.813735870195430252326093249797922409363e-1L, 0 },
	TEST_c_c(cacos, -0x1.fp-16385L, 0x0.ffffffffffffffffffffffffffff8p0L, 1.570796326794896619231321691639751442099L, -8.813735870195430252326093249797922409363e-1L, 0 },
	TEST_c_c(cacos, -0x1.fp-16385L, -0x0.ffffffffffffffffffffffffffff8p0L, 1.570796326794896619231321691639751442099L, 8.813735870195430252326093249797922409363e-1L, 0 },
	TEST_c_c(cacos, 0x0.ffffffffffffffffffffffffffff8p0L, 0x1.fp-16385L, 1.387778780781445675529539585113525401762e-17L, -5.867357004219059108790368268900490184505e-4916L, 0 },
	TEST_c_c(cacos, -0x0.ffffffffffffffffffffffffffff8p0L, 0x1.fp-16385L, 3.141592653589793224584855575465046128902L, -5.867357004219059108790368268900490184505e-4916L, 0 },
	TEST_c_c(cacos, 0x0.ffffffffffffffffffffffffffff8p0L, -0x1.fp-16385L, 1.387778780781445675529539585113525401762e-17L, 5.867357004219059108790368268900490184505e-4916L, 0 },
	TEST_c_c(cacos, -0x0.ffffffffffffffffffffffffffff8p0L, -0x1.fp-16385L, 3.141592653589793224584855575465046128902L, 5.867357004219059108790368268900490184505e-4916L, 0 },
	TEST_c_c(cacos, 0.0L, 0x0.ffffffffffffffffffffffffffff8p0L, 1.570796326794896619231321691639751442099L, -8.813735870195430252326093249797922409363e-1L, 0 },
	TEST_c_c(cacos, 0.0L, -0x0.ffffffffffffffffffffffffffff8p0L, 1.570796326794896619231321691639751442099L, 8.813735870195430252326093249797922409363e-1L, 0 },
	TEST_c_c(cacos, -0.0L, 0x0.ffffffffffffffffffffffffffff8p0L, 1.570796326794896619231321691639751442099L, -8.813735870195430252326093249797922409363e-1L, 0 },
	TEST_c_c(cacos, -0.0L, -0x0.ffffffffffffffffffffffffffff8p0L, 1.570796326794896619231321691639751442099L, 8.813735870195430252326093249797922409363e-1L, 0 },
	TEST_c_c(cacos, 0x0.ffffffffffffffffffffffffffff8p0L, 0.0L, 1.387778780781445675529539585113525401762e-17L, -0.0L, 0 },
	TEST_c_c(cacos, -0x0.ffffffffffffffffffffffffffff8p0L, 0.0L, 3.141592653589793224584855575465046128902L, -0.0L, 0 },
	TEST_c_c(cacos, 0x0.ffffffffffffffffffffffffffff8p0L, -0.0L, 1.387778780781445675529539585113525401762e-17L, 0.0L, 0 },
	TEST_c_c(cacos, -0x0.ffffffffffffffffffffffffffff8p0L, -0.0L, 3.141592653589793224584855575465046128902L, 0.0L, 0 },
#endif
	TEST_c_c(cacos, 0x1p-112L, 0.5L, 1.570796326794896619231321691639751269838L, -4.812118250596034474977589134243684231352e-1L, 0 },
	TEST_c_c(cacos, 0x1p-112L, -0.5L, 1.570796326794896619231321691639751269838L, 4.812118250596034474977589134243684231352e-1L, 0 },
	TEST_c_c(cacos, -0x1p-112L, 0.5L, 1.570796326794896619231321691639751614359L, -4.812118250596034474977589134243684231352e-1L, 0 },
	TEST_c_c(cacos, -0x1p-112L, -0.5L, 1.570796326794896619231321691639751614359L, 4.812118250596034474977589134243684231352e-1L, 0 },
	TEST_c_c(cacos, 0.5L, 0x1p-112L, 1.047197551196597746154214461093167628066L, -2.223872343664663196047610660420739543258e-34L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0.5L, 0x1p-112L, 2.094395102393195492308428922186335256131L, -2.223872343664663196047610660420739543258e-34L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, 0.5L, -0x1p-112L, 1.047197551196597746154214461093167628066L, 2.223872343664663196047610660420739543258e-34L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0.5L, -0x1p-112L, 2.094395102393195492308428922186335256131L, 2.223872343664663196047610660420739543258e-34L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, 0x1p-112L, 0x1p-112L, 1.570796326794896619231321691639751249506L, -1.925929944387235853055977942584927318538e-34L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, 0x1p-112L, -0x1p-112L, 1.570796326794896619231321691639751249506L, 1.925929944387235853055977942584927318538e-34L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0x1p-112L, 0x1p-112L, 1.570796326794896619231321691639751634692L, -1.925929944387235853055977942584927318538e-34L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0x1p-112L, -0x1p-112L, 1.570796326794896619231321691639751634692L, 1.925929944387235853055977942584927318538e-34L, 0|XFAIL_NATIVE_LINUX },
#if defined TEST_LDOUBLE && LDBL_MIN_EXP <= -16381
	TEST_c_c(cacos, 0x1.fp-16385L, 0x1p-112L, 1.570796326794896619231321691639751442099L, -1.925929944387235853055977942584927318538e-34L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacos, 0x1.fp-16385L, -0x1p-112L, 1.570796326794896619231321691639751442099L, 1.925929944387235853055977942584927318538e-34L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacos, -0x1.fp-16385L, 0x1p-112L, 1.570796326794896619231321691639751442099L, -1.925929944387235853055977942584927318538e-34L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacos, -0x1.fp-16385L, -0x1p-112L, 1.570796326794896619231321691639751442099L, 1.925929944387235853055977942584927318538e-34L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacos, 0x1p-112L, 0x1.fp-16385L, 1.570796326794896619231321691639751249506L, -8.142593549724601460479922838826119584417e-4933L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacos, -0x1p-112L, 0x1.fp-16385L, 1.570796326794896619231321691639751634692L, -8.142593549724601460479922838826119584417e-4933L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacos, 0x1p-112L, -0x1.fp-16385L, 1.570796326794896619231321691639751249506L, 8.142593549724601460479922838826119584417e-4933L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacos, -0x1p-112L, -0x1.fp-16385L, 1.570796326794896619231321691639751634692L, 8.142593549724601460479922838826119584417e-4933L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
#endif
	TEST_c_c(cacos, 0.0L, 0x1p-112L, 1.570796326794896619231321691639751442099L, -1.925929944387235853055977942584927318538e-34L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, 0.0L, -0x1p-112L, 1.570796326794896619231321691639751442099L, 1.925929944387235853055977942584927318538e-34L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0.0L, 0x1p-112L, 1.570796326794896619231321691639751442099L, -1.925929944387235853055977942584927318538e-34L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0.0L, -0x1p-112L, 1.570796326794896619231321691639751442099L, 1.925929944387235853055977942584927318538e-34L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, 0x1p-112L, 0.0L, 1.570796326794896619231321691639751249506L, -0.0L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, -0x1p-112L, 0.0L, 1.570796326794896619231321691639751634692L, -0.0L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacos, 0x1p-112L, -0.0L, 1.570796326794896619231321691639751249506L, 0.0L, 0 },
	TEST_c_c(cacos, -0x1p-112L, -0.0L, 1.570796326794896619231321691639751634692L, 0.0L, 0 },

	TEST_c_c(cacos, 0.75L, 1.25L, 1.11752014915610270578240049553777969L, -1.13239363160530819522266333696834467L, 0 },
	TEST_c_c(cacos, -2, -3, 2.1414491111159960199416055713254211L, 1.9833870299165354323470769028940395L, 0 },
}


static void test_cacosh(void)
{
	struct test *testp = lookup("cacosh" },

	TEST_c_c(cacosh, 0, 0, 0.0, M_PI_2l, 0 },
	TEST_c_c(cacosh, ZERO_M, 0, 0.0, M_PI_2l, 0 },
	TEST_c_c(cacosh, 0, ZERO_M, 0.0, -M_PI_2l, 0 },
	TEST_c_c(cacosh, ZERO_M, ZERO_M, 0.0, -M_PI_2l, 0 },
	TEST_c_c(cacosh, INF_M, INF_P, INF_P, M_PI_34l, INVALID_EXCEPTION_OK },
	TEST_c_c(cacosh, INF_M, INF_M, INF_P, -M_PI_34l, 0 },

	TEST_c_c(cacosh, INF_P, INF_P, INF_P, M_PI_4l, 0 },
	TEST_c_c(cacosh, INF_P, INF_M, INF_P, -M_PI_4l, 0 },

	TEST_c_c(cacosh, -10.0, INF_P, INF_P, M_PI_2l, 0 },
	TEST_c_c(cacosh, -10.0, INF_M, INF_P, -M_PI_2l, 0 },
	TEST_c_c(cacosh, 0, INF_P, INF_P, M_PI_2l, 0 },
	TEST_c_c(cacosh, 0, INF_M, INF_P, -M_PI_2l, 0 },
	TEST_c_c(cacosh, 0.1L, INF_P, INF_P, M_PI_2l, 0 },
	TEST_c_c(cacosh, 0.1L, INF_M, INF_P, -M_PI_2l, 0 },

	TEST_c_c(cacosh, INF_M, 0, INF_P, M_PIl, 0 },
	TEST_c_c(cacosh, INF_M, ZERO_M, INF_P, -M_PIl, 0 },
	TEST_c_c(cacosh, INF_M, 100, INF_P, M_PIl, 0 },
	TEST_c_c(cacosh, INF_M, -100, INF_P, -M_PIl, 0 },

	TEST_c_c(cacosh, INF_P, 0, INF_P, 0.0, 0 },
	TEST_c_c(cacosh, INF_P, ZERO_M, INF_P, ZERO_M, 0 },
	TEST_c_c(cacosh, INF_P, 0.5, INF_P, 0.0, 0 },
	TEST_c_c(cacosh, INF_P, -0.5, INF_P, ZERO_M, 0 },

	TEST_c_c(cacosh, INF_P, QNAN_P, INF_P, QNAN_P, 0 },
	TEST_c_c(cacosh, INF_M, QNAN_P, INF_P, QNAN_P, 0 },

	TEST_c_c(cacosh, 0, QNAN_P, QNAN_P, QNAN_P, 0 },
	TEST_c_c(cacosh, ZERO_M, QNAN_P, QNAN_P, QNAN_P, 0 },

	TEST_c_c(cacosh, QNAN_P, INF_P, INF_P, QNAN_P, 0 },
	TEST_c_c(cacosh, QNAN_P, INF_M, INF_P, QNAN_P, 0 },

	TEST_c_c(cacosh, 10.5, QNAN_P, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	TEST_c_c(cacosh, -10.5, QNAN_P, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },

	TEST_c_c(cacosh, QNAN_P, 0.75, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	TEST_c_c(cacosh, QNAN_P, -0.75, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },

	TEST_c_c(cacosh, QNAN_P, QNAN_P, QNAN_P, QNAN_P, 0 },

	TEST_c_c(cacosh, ZERO_P, -1.5L, 1.194763217287109304111930828519090523536L, -M_PI_2l, 0 },
	TEST_c_c(cacosh, ZERO_M, -1.5L, 1.194763217287109304111930828519090523536L, -M_PI_2l, 0 },
	TEST_c_c(cacosh, ZERO_P, -1.0L, 0.8813735870195430252326093249797923090282L, -M_PI_2l, 0 },
	TEST_c_c(cacosh, ZERO_M, -1.0L, 0.8813735870195430252326093249797923090282L, -M_PI_2l, 0 },
	TEST_c_c(cacosh, ZERO_P, -0.5L, 0.4812118250596034474977589134243684231352L, -M_PI_2l, 0 },
	TEST_c_c(cacosh, ZERO_M, -0.5L, 0.4812118250596034474977589134243684231352L, -M_PI_2l, 0 },
	TEST_c_c(cacosh, ZERO_P, 0.5L, 0.4812118250596034474977589134243684231352L, M_PI_2l, 0 },
	TEST_c_c(cacosh, ZERO_M, 0.5L, 0.4812118250596034474977589134243684231352L, M_PI_2l, 0 },
	TEST_c_c(cacosh, ZERO_P, 1.0L, 0.8813735870195430252326093249797923090282L, M_PI_2l, 0 },
	TEST_c_c(cacosh, ZERO_M, 1.0L, 0.8813735870195430252326093249797923090282L, M_PI_2l, 0 },
	TEST_c_c(cacosh, ZERO_P, 1.5L, 1.194763217287109304111930828519090523536L, M_PI_2l, 0 },
	TEST_c_c(cacosh, ZERO_M, 1.5L, 1.194763217287109304111930828519090523536L, M_PI_2l, 0 },

	TEST_c_c(cacosh, -1.5L, ZERO_P, 0.9624236501192068949955178268487368462704L, M_PIl, 0 },
	TEST_c_c(cacosh, -1.5L, ZERO_M, 0.9624236501192068949955178268487368462704L, -M_PIl, 0 },
	TEST_c_c(cacosh, -1.0L, ZERO_P, ZERO_P, M_PIl, 0 },
	TEST_c_c(cacosh, -1.0L, ZERO_M, ZERO_P, -M_PIl, 0 },
	TEST_c_c(cacosh, -0.5L, ZERO_P, ZERO_P, 2.094395102393195492308428922186335256131L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, -0.5L, ZERO_M, ZERO_P, -2.094395102393195492308428922186335256131L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, 0.5L, ZERO_P, ZERO_P, 1.047197551196597746154214461093167628066L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, 0.5L, ZERO_M, ZERO_P, -1.047197551196597746154214461093167628066L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, 1.0L, ZERO_P, ZERO_P, ZERO_P, 0 },
	TEST_c_c(cacosh, 1.0L, ZERO_M, ZERO_P, ZERO_M, 0 },
	TEST_c_c(cacosh, 1.5L, ZERO_P, 0.9624236501192068949955178268487368462704L, ZERO_P, 0 },
	TEST_c_c(cacosh, 1.5L, ZERO_M, 0.9624236501192068949955178268487368462704L, ZERO_M, 0 },

	TEST_c_c(cacosh, 0x1p50L, 1.0L, 3.535050620855721078027883819436720218708e1L, 8.881784197001252323389053344727730248720e-16L, 0 },
	TEST_c_c(cacosh, 0x1p50L, -1.0L, 3.535050620855721078027883819436720218708e1L, -8.881784197001252323389053344727730248720e-16L, 0 },
	TEST_c_c(cacosh, -0x1p50L, 1.0L, 3.535050620855721078027883819436720218708e1L, 3.141592653589792350284223683154270545292L, 0 },
	TEST_c_c(cacosh, -0x1p50L, -1.0L, 3.535050620855721078027883819436720218708e1L, -3.141592653589792350284223683154270545292L, 0 },
	TEST_c_c(cacosh, 1.0L, 0x1p50L, 3.535050620855721078027883819436759661753e1L, 1.570796326794895731052901991514519103193L, 0 },
	TEST_c_c(cacosh, -1.0L, 0x1p50L, 3.535050620855721078027883819436759661753e1L, 1.570796326794897507409741391764983781004L, 0 },
	TEST_c_c(cacosh, 1.0L, -0x1p50L, 3.535050620855721078027883819436759661753e1L, -1.570796326794895731052901991514519103193L, 0 },
	TEST_c_c(cacosh, -1.0L, -0x1p50L, 3.535050620855721078027883819436759661753e1L, -1.570796326794897507409741391764983781004L, 0 },
#ifndef TEST_FLOAT
	TEST_c_c(cacosh, 0x1p500L, 1.0L, 3.472667374605326000180332928505464606058e2L, 3.054936363499604682051979393213617699789e-151L, 0 },
	TEST_c_c(cacosh, 0x1p500L, -1.0L, 3.472667374605326000180332928505464606058e2L, -3.054936363499604682051979393213617699789e-151L, 0 },
	TEST_c_c(cacosh, -0x1p500L, 1.0L, 3.472667374605326000180332928505464606058e2L, 3.141592653589793238462643383279502884197L, 0 },
	TEST_c_c(cacosh, -0x1p500L, -1.0L, 3.472667374605326000180332928505464606058e2L, -3.141592653589793238462643383279502884197L, 0 },
	TEST_c_c(cacosh, 1.0L, 0x1p500L, 3.472667374605326000180332928505464606058e2L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -1.0L, 0x1p500L, 3.472667374605326000180332928505464606058e2L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 1.0L, -0x1p500L, 3.472667374605326000180332928505464606058e2L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -1.0L, -0x1p500L, 3.472667374605326000180332928505464606058e2L, -1.570796326794896619231321691639751442099L, 0 },
#endif
#if defined TEST_LDOUBLE && LDBL_MAX_EXP >= 16384
	TEST_c_c(cacosh, 0x1p5000L, 1.0L, 3.466429049980286492395577839412341016946e3L, 7.079811261048172892385615158694057552948e-1506L, 0 },
	TEST_c_c(cacosh, 0x1p5000L, -1.0L, 3.466429049980286492395577839412341016946e3L, -7.079811261048172892385615158694057552948e-1506L, 0 },
	TEST_c_c(cacosh, -0x1p5000L, 1.0L, 3.466429049980286492395577839412341016946e3L, 3.141592653589793238462643383279502884197L, 0 },
	TEST_c_c(cacosh, -0x1p5000L, -1.0L, 3.466429049980286492395577839412341016946e3L, -3.141592653589793238462643383279502884197L, 0 },
	TEST_c_c(cacosh, 1.0L, 0x1p5000L, 3.466429049980286492395577839412341016946e3L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -1.0L, 0x1p5000L, 3.466429049980286492395577839412341016946e3L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 1.0L, -0x1p5000L, 3.466429049980286492395577839412341016946e3L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -1.0L, -0x1p5000L, 3.466429049980286492395577839412341016946e3L, -1.570796326794896619231321691639751442099L, 0 },
#endif
	TEST_c_c(cacosh, 0x1.fp127L, 0x1.fp127L, 8.973081118419833726837456344608533993585e1L, 7.853981633974483096156608458198757210493e-1L, 0|XFAIL_NATIVE_LINUXF },
#ifndef TEST_FLOAT
	TEST_c_c(cacosh, 0x1.fp1023L, 0x1.fp1023L, 7.107906849659093345062145442726115449315e2L, 7.853981633974483096156608458198757210493e-1L, 0|XFAIL_NATIVE_LINUX },
#endif
#if defined TEST_LDOUBLE && LDBL_MAX_EXP >= 16384
	TEST_c_c(cacosh, 0x1.fp16383L, 0x1.fp16383L, 1.135753137836666928715489992987020363057e4L, 7.853981633974483096156608458198757210493e-1L, 0|XFAIL_NATIVE_LINUXL },
#endif
	TEST_c_c(cacosh, 0x1.fp-129L, 1.5L, 1.194763217287109304111930828519090523536L, 1.570796326794896619231321691639751442097L, 0 },
	TEST_c_c(cacosh, 0x1.fp-129L, -1.5L, 1.194763217287109304111930828519090523536L, -1.570796326794896619231321691639751442097L, 0 },
	TEST_c_c(cacosh, -0x1.fp-129L, 1.5L, 1.194763217287109304111930828519090523536L, 1.570796326794896619231321691639751442100L, 0 },
	TEST_c_c(cacosh, -0x1.fp-129L, -1.5L, 1.194763217287109304111930828519090523536L, -1.570796326794896619231321691639751442100L, 0 },
	TEST_c_c(cacosh, 1.5L, 0x1.fp-129L, 9.624236501192068949955178268487368462704e-1L, 2.546345110742945032959687790021055102355e-39L, UNDERFLOW_EXCEPTION_FLOAT },
	TEST_c_c(cacosh, -1.5L, 0x1.fp-129L, 9.624236501192068949955178268487368462704e-1L, 3.141592653589793238462643383279502884195L, 0 },
	TEST_c_c(cacosh, 1.5L, -0x1.fp-129L, 9.624236501192068949955178268487368462704e-1L, -2.546345110742945032959687790021055102355e-39L, UNDERFLOW_EXCEPTION_FLOAT },
	TEST_c_c(cacosh, -1.5L, -0x1.fp-129L, 9.624236501192068949955178268487368462704e-1L, -3.141592653589793238462643383279502884195L, 0 },
#ifndef TEST_FLOAT
	TEST_c_c(cacosh, 0x1.fp-1025L, 1.5L, 1.194763217287109304111930828519090523536L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 0x1.fp-1025L, -1.5L, 1.194763217287109304111930828519090523536L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0x1.fp-1025L, 1.5L, 1.194763217287109304111930828519090523536L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0x1.fp-1025L, -1.5L, 1.194763217287109304111930828519090523536L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 1.5L, 0x1.fp-1025L, 9.624236501192068949955178268487368462704e-1L, 4.819934639999230680322935210539402497827e-309L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(cacosh, -1.5L, 0x1.fp-1025L, 9.624236501192068949955178268487368462704e-1L, 3.141592653589793238462643383279502884197L, 0 },
	TEST_c_c(cacosh, 1.5L, -0x1.fp-1025L, 9.624236501192068949955178268487368462704e-1L, -4.819934639999230680322935210539402497827e-309L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(cacosh, -1.5L, -0x1.fp-1025L, 9.624236501192068949955178268487368462704e-1L, -3.141592653589793238462643383279502884197L, 0 },
#endif
#if defined TEST_LDOUBLE && LDBL_MIN_EXP <= -16381
	TEST_c_c(cacosh, 0x1.fp-16385L, 1.5L, 1.194763217287109304111930828519090523536L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 0x1.fp-16385L, -1.5L, 1.194763217287109304111930828519090523536L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0x1.fp-16385L, 1.5L, 1.194763217287109304111930828519090523536L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0x1.fp-16385L, -1.5L, 1.194763217287109304111930828519090523536L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 1.5L, 0x1.fp-16385L, 9.624236501192068949955178268487368462704e-1L, 7.282957076134209141226696333885150260319e-4933L, UNDERFLOW_EXCEPTION },
	TEST_c_c(cacosh, -1.5L, 0x1.fp-16385L, 9.624236501192068949955178268487368462704e-1L, 3.141592653589793238462643383279502884197L, 0 },
	TEST_c_c(cacosh, 1.5L, -0x1.fp-16385L, 9.624236501192068949955178268487368462704e-1L, -7.282957076134209141226696333885150260319e-4933L, UNDERFLOW_EXCEPTION },
	TEST_c_c(cacosh, -1.5L, -0x1.fp-16385L, 9.624236501192068949955178268487368462704e-1L, -3.141592653589793238462643383279502884197L, 0 },
#endif
	TEST_c_c(cacosh, 0.5L, 1.0L, 9.261330313501824245501244453057873152694e-1L, 1.221357263937683325603909865564381489366L, 0 },
	TEST_c_c(cacosh, 0.5L, -1.0L, 9.261330313501824245501244453057873152694e-1L, -1.221357263937683325603909865564381489366L, 0 },
	TEST_c_c(cacosh, -0.5L, 1.0L, 9.261330313501824245501244453057873152694e-1L, 1.920235389652109912858733517715121394831L, 0 },
	TEST_c_c(cacosh, -0.5L, -1.0L, 9.261330313501824245501244453057873152694e-1L, -1.920235389652109912858733517715121394831L, 0 },
	TEST_c_c(cacosh, 1.0L, 0.5L, 7.328576759736452608886724437653071523305e-1L, 6.748888455860063801646649673121744318756e-1L, 0 },
	TEST_c_c(cacosh, -1.0L, 0.5L, 7.328576759736452608886724437653071523305e-1L, 2.466703808003786858297978415967328452322L, 0 },
	TEST_c_c(cacosh, 1.0L, -0.5L, 7.328576759736452608886724437653071523305e-1L, -6.748888455860063801646649673121744318756e-1L, 0 },
	TEST_c_c(cacosh, -1.0L, -0.5L, 7.328576759736452608886724437653071523305e-1L, -2.466703808003786858297978415967328452322L, 0 },
	TEST_c_c(cacosh, 0.25L, 1.0L, 8.924633639033482359562124741744951972772e-1L, 1.394493894017929688812643125003661339452L, 0 },
	TEST_c_c(cacosh, 0.25L, -1.0L, 8.924633639033482359562124741744951972772e-1L, -1.394493894017929688812643125003661339452L, 0 },
	TEST_c_c(cacosh, -0.25L, 1.0L, 8.924633639033482359562124741744951972772e-1L, 1.747098759571863549650000258275841544745L, 0 },
	TEST_c_c(cacosh, -0.25L, -1.0L, 8.924633639033482359562124741744951972772e-1L, -1.747098759571863549650000258275841544745L, 0 },
	TEST_c_c(cacosh, 1.0L, 0.25L, 5.097911466811016354623559941115413499164e-1L, 4.890443302710802929202843732146540079124e-1L, 0 },
	TEST_c_c(cacosh, -1.0L, 0.25L, 5.097911466811016354623559941115413499164e-1L, 2.652548323318712945542359010064848876285L, 0 },
	TEST_c_c(cacosh, 1.0L, -0.25L, 5.097911466811016354623559941115413499164e-1L, -4.890443302710802929202843732146540079124e-1L, 0 },
	TEST_c_c(cacosh, -1.0L, -0.25L, 5.097911466811016354623559941115413499164e-1L, -2.652548323318712945542359010064848876285L, 0 },
	TEST_c_c(cacosh, 0x1.fp-10L, 1.0L, 8.813742198809567991336704287826445879025e-1L, 1.569458417435338878318763342108699202986L, 0 },
	TEST_c_c(cacosh, 0x1.fp-10L, -1.0L, 8.813742198809567991336704287826445879025e-1L, -1.569458417435338878318763342108699202986L, 0 },
	TEST_c_c(cacosh, -0x1.fp-10L, 1.0L, 8.813742198809567991336704287826445879025e-1L, 1.572134236154454360143880041170803681211L, 0 },
	TEST_c_c(cacosh, -0x1.fp-10L, -1.0L, 8.813742198809567991336704287826445879025e-1L, -1.572134236154454360143880041170803681211L, 0 },
	TEST_c_c(cacosh, 1.0L, 0x1.fp-10L, 4.350501469856803800217957402220976497152e-2L, 4.349129763101882771258049954181971959031e-2L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacosh, -1.0L, 0x1.fp-10L, 4.350501469856803800217957402220976497152e-2L, 3.098101355958774410750062883737683164607L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacosh, 1.0L, -0x1.fp-10L, 4.350501469856803800217957402220976497152e-2L, -4.349129763101882771258049954181971959031e-2L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacosh, -1.0L, -0x1.fp-10L, 4.350501469856803800217957402220976497152e-2L, -3.098101355958774410750062883737683164607L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacosh, 0x1.fp-30L, 1.0L, 8.813735870195430258081932989769495326854e-1L, 1.570796325518966635014803151387033957091L, 0 },
	TEST_c_c(cacosh, 0x1.fp-30L, -1.0L, 8.813735870195430258081932989769495326854e-1L, -1.570796325518966635014803151387033957091L, 0 },
	TEST_c_c(cacosh, -0x1.fp-30L, 1.0L, 8.813735870195430258081932989769495326854e-1L, 1.570796328070826603447840231892468927106L, 0 },
	TEST_c_c(cacosh, -0x1.fp-30L, -1.0L, 8.813735870195430258081932989769495326854e-1L, -1.570796328070826603447840231892468927106L, 0 },
	TEST_c_c(cacosh, 1.0L, 0x1.fp-30L, 4.247867098745151888768727039216644758847e-5L, 4.247867097467650115899790787875186617316e-5L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacosh, -1.0L, 0x1.fp-30L, 4.247867098745151888768727039216644758847e-5L, 3.141550174918818561961484385371624132331L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacosh, 1.0L, -0x1.fp-30L, 4.247867098745151888768727039216644758847e-5L, -4.247867097467650115899790787875186617316e-5L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacosh, -1.0L, -0x1.fp-30L, 4.247867098745151888768727039216644758847e-5L, -3.141550174918818561961484385371624132331L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacosh, 0x1.fp-100L, 1.0L, 8.813735870195430252326093249797923090282e-1L, 1.570796326794896619231321691638670687364L, 0 },
	TEST_c_c(cacosh, 0x1.fp-100L, -1.0L, 8.813735870195430252326093249797923090282e-1L, -1.570796326794896619231321691638670687364L, 0 },
	TEST_c_c(cacosh, -0x1.fp-100L, 1.0L, 8.813735870195430252326093249797923090282e-1L, 1.570796326794896619231321691640832196834L, 0 },
	TEST_c_c(cacosh, -0x1.fp-100L, -1.0L, 8.813735870195430252326093249797923090282e-1L, -1.570796326794896619231321691640832196834L, 0 },
	TEST_c_c(cacosh, 1.0L, 0x1.fp-100L, 1.236292038260260888664514866457202186027e-15L, 1.236292038260260888664514866456887257525e-15L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, -1.0L, 0x1.fp-100L, 1.236292038260260888664514866457202186027e-15L, 3.141592653589792002170605123018614219682L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, 1.0L, -0x1.fp-100L, 1.236292038260260888664514866457202186027e-15L, -1.236292038260260888664514866456887257525e-15L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, -1.0L, -0x1.fp-100L, 1.236292038260260888664514866457202186027e-15L, -3.141592653589792002170605123018614219682L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, 0x1.fp-129L, 1.0L, 8.813735870195430252326093249797923090282e-1L, 1.570796326794896619231321691639751442097L, 0 },
	TEST_c_c(cacosh, 0x1.fp-129L, -1.0L, 8.813735870195430252326093249797923090282e-1L, -1.570796326794896619231321691639751442097L, 0 },
	TEST_c_c(cacosh, -0x1.fp-129L, 1.0L, 8.813735870195430252326093249797923090282e-1L, 1.570796326794896619231321691639751442101L, 0 },
	TEST_c_c(cacosh, -0x1.fp-129L, -1.0L, 8.813735870195430252326093249797923090282e-1L, -1.570796326794896619231321691639751442101L, 0 },
	TEST_c_c(cacosh, 1.0L, 0x1.fp-129L, 5.335635276982233498398987585285818977933e-20L, 5.335635276982233498398987585285818977930e-20L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, -1.0L, 0x1.fp-129L, 5.335635276982233498398987585285818977933e-20L, 3.141592653589793238409287030509680549213L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, 1.0L, -0x1.fp-129L, 5.335635276982233498398987585285818977933e-20L, -5.335635276982233498398987585285818977930e-20L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, -1.0L, -0x1.fp-129L, 5.335635276982233498398987585285818977933e-20L, -3.141592653589793238409287030509680549213L, 0|XFAIL_NATIVE_LINUX },
#ifndef TEST_FLOAT
	TEST_c_c(cacosh, 0x1.fp-1000L, 1.0L, 8.813735870195430252326093249797923090282e-1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 0x1.fp-1000L, -1.0L, 8.813735870195430252326093249797923090282e-1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0x1.fp-1000L, 1.0L, 8.813735870195430252326093249797923090282e-1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0x1.fp-1000L, -1.0L, 8.813735870195430252326093249797923090282e-1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 1.0L, 0x1.fp-1000L, 4.252291453851660175550490409247739011867e-151L, 4.252291453851660175550490409247739011867e-151L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, -1.0L, 0x1.fp-1000L, 4.252291453851660175550490409247739011867e-151L, 3.141592653589793238462643383279502884197L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, 1.0L, -0x1.fp-1000L, 4.252291453851660175550490409247739011867e-151L, -4.252291453851660175550490409247739011867e-151L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, -1.0L, -0x1.fp-1000L, 4.252291453851660175550490409247739011867e-151L, -3.141592653589793238462643383279502884197L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, 0x1.fp-1025L, 1.0L, 8.813735870195430252326093249797923090282e-1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 0x1.fp-1025L, -1.0L, 8.813735870195430252326093249797923090282e-1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0x1.fp-1025L, 1.0L, 8.813735870195430252326093249797923090282e-1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0x1.fp-1025L, -1.0L, 8.813735870195430252326093249797923090282e-1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 1.0L, 0x1.fp-1025L, 7.340879205566679497036857179189356754017e-155L, 7.340879205566679497036857179189356754017e-155L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, -1.0L, 0x1.fp-1025L, 7.340879205566679497036857179189356754017e-155L, 3.141592653589793238462643383279502884197L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, 1.0L, -0x1.fp-1025L, 7.340879205566679497036857179189356754017e-155L, -7.340879205566679497036857179189356754017e-155L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, -1.0L, -0x1.fp-1025L, 7.340879205566679497036857179189356754017e-155L, -3.141592653589793238462643383279502884197L, 0|XFAIL_NATIVE_LINUX },
#endif
#if defined TEST_LDOUBLE && LDBL_MIN_EXP <= -16381
	TEST_c_c(cacosh, 0x1.fp-10000L, 1.0L, 8.813735870195430252326093249797923090282e-1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 0x1.fp-10000L, -1.0L, 8.813735870195430252326093249797923090282e-1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0x1.fp-10000L, 1.0L, 8.813735870195430252326093249797923090282e-1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0x1.fp-10000L, -1.0L, 8.813735870195430252326093249797923090282e-1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 1.0L, 0x1.fp-10000L, 9.854680208706673586644342922051388714633e-1506L, 9.854680208706673586644342922051388714633e-1506L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacosh, -1.0L, 0x1.fp-10000L, 9.854680208706673586644342922051388714633e-1506L, 3.141592653589793238462643383279502884197L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacosh, 1.0L, -0x1.fp-10000L, 9.854680208706673586644342922051388714633e-1506L, -9.854680208706673586644342922051388714633e-1506L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacosh, -1.0L, -0x1.fp-10000L, 9.854680208706673586644342922051388714633e-1506L, -3.141592653589793238462643383279502884197L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacosh, 0x1.fp-16385L, 1.0L, 8.813735870195430252326093249797923090282e-1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 0x1.fp-16385L, -1.0L, 8.813735870195430252326093249797923090282e-1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0x1.fp-16385L, 1.0L, 8.813735870195430252326093249797923090282e-1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0x1.fp-16385L, -1.0L, 8.813735870195430252326093249797923090282e-1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 1.0L, 0x1.fp-16385L, 9.023632056840860275214893047597614177639e-2467L, 9.023632056840860275214893047597614177639e-2467L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacosh, -1.0L, 0x1.fp-16385L, 9.023632056840860275214893047597614177639e-2467L, 3.141592653589793238462643383279502884197L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacosh, 1.0L, -0x1.fp-16385L, 9.023632056840860275214893047597614177639e-2467L, -9.023632056840860275214893047597614177639e-2467L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacosh, -1.0L, -0x1.fp-16385L, 9.023632056840860275214893047597614177639e-2467L, -3.141592653589793238462643383279502884197L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
#endif
	TEST_c_c(cacosh, 0x1p-23L, 0x1.000002p0L, 8.813736713132400470205730751186547909968e-1L, 1.570796242501204621739026081991856762292L, 0 },
	TEST_c_c(cacosh, 0x1p-23L, -0x1.000002p0L, 8.813736713132400470205730751186547909968e-1L, -1.570796242501204621739026081991856762292L, 0 },
	TEST_c_c(cacosh, -0x1p-23L, 0x1.000002p0L, 8.813736713132400470205730751186547909968e-1L, 1.570796411088588616723617301287646121905L, 0 },
	TEST_c_c(cacosh, -0x1p-23L, -0x1.000002p0L, 8.813736713132400470205730751186547909968e-1L, -1.570796411088588616723617301287646121905L, 0 },
	TEST_c_c(cacosh, 0x1.000002p0L, 0x1p-23L, 5.364668491573609633134147164031476452679e-4L, 2.222118384408546368406374049167636760903e-4L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacosh, -0x1.000002p0L, 0x1p-23L, 5.364668491573609633134147164031476452679e-4L, 3.141370441751352383825802745874586120521L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacosh, 0x1.000002p0L, -0x1p-23L, 5.364668491573609633134147164031476452679e-4L, -2.222118384408546368406374049167636760903e-4L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacosh, -0x1.000002p0L, -0x1p-23L, 5.364668491573609633134147164031476452679e-4L, -3.141370441751352383825802745874586120521L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacosh, 0x1.fp-129L, 0x1.000002p0L, 8.813736713132375348727889167749389235161e-1L, 1.570796326794896619231321691639751442097L, 0 },
	TEST_c_c(cacosh, 0x1.fp-129L, -0x1.000002p0L, 8.813736713132375348727889167749389235161e-1L, -1.570796326794896619231321691639751442097L, 0 },
	TEST_c_c(cacosh, -0x1.fp-129L, 0x1.000002p0L, 8.813736713132375348727889167749389235161e-1L, 1.570796326794896619231321691639751442101L, 0 },
	TEST_c_c(cacosh, -0x1.fp-129L, -0x1.000002p0L, 8.813736713132375348727889167749389235161e-1L, -1.570796326794896619231321691639751442101L, 0 },
	TEST_c_c(cacosh, 0x1.000002p0L, 0x1.fp-129L, 4.882812451493617206486388134172712975070e-4L, 5.830451806317544230969669308596361881467e-36L, 0 },
	TEST_c_c(cacosh, -0x1.000002p0L, 0x1.fp-129L, 4.882812451493617206486388134172712975070e-4L, 3.141592653589793238462643383279502878367L, 0 },
	TEST_c_c(cacosh, 0x1.000002p0L, -0x1.fp-129L, 4.882812451493617206486388134172712975070e-4L, -5.830451806317544230969669308596361881467e-36L, 0 },
	TEST_c_c(cacosh, -0x1.000002p0L, -0x1.fp-129L, 4.882812451493617206486388134172712975070e-4L, -3.141592653589793238462643383279502878367L, 0 },
	TEST_c_c(cacosh, 0.0L, 0x1.000002p0L, 8.813736713132375348727889167749389235161e-1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 0.0L, -0x1.000002p0L, 8.813736713132375348727889167749389235161e-1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0.0L, 0x1.000002p0L, 8.813736713132375348727889167749389235161e-1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0.0L, -0x1.000002p0L, 8.813736713132375348727889167749389235161e-1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 0x1.000002p0L, 0.0L, 4.882812451493617206486388134172712975070e-4L, 0.0L, 0 },
	TEST_c_c(cacosh, -0x1.000002p0L, 0.0L, 4.882812451493617206486388134172712975070e-4L, 3.141592653589793238462643383279502884197L, 0 },
	TEST_c_c(cacosh, 0x1.000002p0L, -0.0L, 4.882812451493617206486388134172712975070e-4L, -0.0L, 0 },
	TEST_c_c(cacosh, -0x1.000002p0L, -0.0L, 4.882812451493617206486388134172712975070e-4L, -3.141592653589793238462643383279502884197L, 0 },
#ifndef TEST_FLOAT
	TEST_c_c(cacosh, 0x1p-52L, 0x1.0000000000001p0L, 8.813735870195431822418551933572982483664e-1L, 1.570796326794896462222075823262262934288L, 0 },
	TEST_c_c(cacosh, 0x1p-52L, -0x1.0000000000001p0L, 8.813735870195431822418551933572982483664e-1L, -1.570796326794896462222075823262262934288L, 0 },
	TEST_c_c(cacosh, -0x1p-52L, 0x1.0000000000001p0L, 8.813735870195431822418551933572982483664e-1L, 1.570796326794896776240567560017239949909L, 0 },
	TEST_c_c(cacosh, -0x1p-52L, -0x1.0000000000001p0L, 8.813735870195431822418551933572982483664e-1L, -1.570796326794896776240567560017239949909L, 0 },
	TEST_c_c(cacosh, 0x1.0000000000001p0L, 0x1p-52L, 2.315303644582684770975188768022139415020e-8L, 9.590301705980041385828904092662391018164e-9L, 0 },
	TEST_c_c(cacosh, -0x1.0000000000001p0L, 0x1p-52L, 2.315303644582684770975188768022139415020e-8L, 3.141592643999491532482601997450598791535L, 0 },
	TEST_c_c(cacosh, 0x1.0000000000001p0L, -0x1p-52L, 2.315303644582684770975188768022139415020e-8L, -9.590301705980041385828904092662391018164e-9L, 0 },
	TEST_c_c(cacosh, -0x1.0000000000001p0L, -0x1p-52L, 2.315303644582684770975188768022139415020e-8L, -3.141592643999491532482601997450598791535L, 0 },
	TEST_c_c(cacosh, 0x1.fp-1025L, 0x1.0000000000001p0L, 8.813735870195431822418551933572895326024e-1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 0x1.fp-1025L, -0x1.0000000000001p0L, 8.813735870195431822418551933572895326024e-1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0x1.fp-1025L, 0x1.0000000000001p0L, 8.813735870195431822418551933572895326024e-1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0x1.fp-1025L, -0x1.0000000000001p0L, 8.813735870195431822418551933572895326024e-1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 0x1.0000000000001p0L, 0x1.fp-1025L, 2.107342425544701550354780375182800088393e-8L, 2.557178503953494342609835913586108008322e-301L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM },
	TEST_c_c(cacosh, -0x1.0000000000001p0L, 0x1.fp-1025L, 2.107342425544701550354780375182800088393e-8L, 3.141592653589793238462643383279502884197L, 0 },
	TEST_c_c(cacosh, 0x1.0000000000001p0L, -0x1.fp-1025L, 2.107342425544701550354780375182800088393e-8L, -2.557178503953494342609835913586108008322e-301L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM },
	TEST_c_c(cacosh, -0x1.0000000000001p0L, -0x1.fp-1025L, 2.107342425544701550354780375182800088393e-8L, -3.141592653589793238462643383279502884197L, 0 },
	TEST_c_c(cacosh, 0.0L, 0x1.0000000000001p0L, 8.813735870195431822418551933572895326024e-1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 0.0L, -0x1.0000000000001p0L, 8.813735870195431822418551933572895326024e-1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0.0L, 0x1.0000000000001p0L, 8.813735870195431822418551933572895326024e-1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0.0L, -0x1.0000000000001p0L, 8.813735870195431822418551933572895326024e-1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 0x1.0000000000001p0L, 0.0L, 2.107342425544701550354780375182800088393e-8L, 0.0L, 0 },
	TEST_c_c(cacosh, -0x1.0000000000001p0L, 0.0L, 2.107342425544701550354780375182800088393e-8L, 3.141592653589793238462643383279502884197L, 0 },
	TEST_c_c(cacosh, 0x1.0000000000001p0L, -0.0L, 2.107342425544701550354780375182800088393e-8L, -0.0L, 0 },
	TEST_c_c(cacosh, -0x1.0000000000001p0L, -0.0L, 2.107342425544701550354780375182800088393e-8L, -3.141592653589793238462643383279502884197L, 0 },
#endif
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	TEST_c_c(cacosh, 0x1p-63L, 0x1.0000000000000002p0L, 8.813735870195430253092739958139610131001e-1L, 1.570796326794896619154657020805582738031L, 0 },
	TEST_c_c(cacosh, 0x1p-63L, -0x1.0000000000000002p0L, 8.813735870195430253092739958139610131001e-1L, -1.570796326794896619154657020805582738031L, 0 },
	TEST_c_c(cacosh, -0x1p-63L, 0x1.0000000000000002p0L, 8.813735870195430253092739958139610131001e-1L, 1.570796326794896619307986362473920146166L, 0 },
	TEST_c_c(cacosh, -0x1p-63L, -0x1.0000000000000002p0L, 8.813735870195430253092739958139610131001e-1L, -1.570796326794896619307986362473920146166L, 0 },
	TEST_c_c(cacosh, 0x1.0000000000000002p0L, 0x1p-63L, 5.116146586219826555037807251857670783420e-10L, 2.119177303101063432592523199680782317447e-10L, 0 },
	TEST_c_c(cacosh, -0x1.0000000000000002p0L, 0x1p-63L, 5.116146586219826555037807251857670783420e-10L, 3.141592653377875508152537040020250564229L, 0 },
	TEST_c_c(cacosh, 0x1.0000000000000002p0L, -0x1p-63L, 5.116146586219826555037807251857670783420e-10L, -2.119177303101063432592523199680782317447e-10L, 0 },
	TEST_c_c(cacosh, -0x1.0000000000000002p0L, -0x1p-63L, 5.116146586219826555037807251857670783420e-10L, -3.141592653377875508152537040020250564229L, 0 },
# if LDBL_MIN_EXP <= -16381
	TEST_c_c(cacosh, 0x1.fp-16385L, 0x1.0000000000000002p0L, 8.813735870195430253092739958139610130980e-1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 0x1.fp-16385L, -0x1.0000000000000002p0L, 8.813735870195430253092739958139610130980e-1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0x1.fp-16385L, 0x1.0000000000000002p0L, 8.813735870195430253092739958139610130980e-1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0x1.fp-16385L, -0x1.0000000000000002p0L, 8.813735870195430253092739958139610130980e-1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 0x1.0000000000000002p0L, 0x1.fp-16385L, 4.656612873077392578082927418388212703712e-10L, 1.748608650034385653922359120438227480943e-4923L, 0 },
	TEST_c_c(cacosh, -0x1.0000000000000002p0L, 0x1.fp-16385L, 4.656612873077392578082927418388212703712e-10L, 3.141592653589793238462643383279502884197L, 0 },
	TEST_c_c(cacosh, 0x1.0000000000000002p0L, -0x1.fp-16385L, 4.656612873077392578082927418388212703712e-10L, -1.748608650034385653922359120438227480943e-4923L, 0 },
	TEST_c_c(cacosh, -0x1.0000000000000002p0L, -0x1.fp-16385L, 4.656612873077392578082927418388212703712e-10L, -3.141592653589793238462643383279502884197L, 0 },
# endif
	TEST_c_c(cacosh, 0.0L, 0x1.0000000000000002p0L, 8.813735870195430253092739958139610130980e-1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 0.0L, -0x1.0000000000000002p0L, 8.813735870195430253092739958139610130980e-1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0.0L, 0x1.0000000000000002p0L, 8.813735870195430253092739958139610130980e-1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0.0L, -0x1.0000000000000002p0L, 8.813735870195430253092739958139610130980e-1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 0x1.0000000000000002p0L, 0.0L, 4.656612873077392578082927418388212703712e-10L, 0.0L, 0 },
	TEST_c_c(cacosh, -0x1.0000000000000002p0L, 0.0L, 4.656612873077392578082927418388212703712e-10L, 3.141592653589793238462643383279502884197L, 0 },
	TEST_c_c(cacosh, 0x1.0000000000000002p0L, -0.0L, 4.656612873077392578082927418388212703712e-10L, -0.0L, 0 },
	TEST_c_c(cacosh, -0x1.0000000000000002p0L, -0.0L, 4.656612873077392578082927418388212703712e-10L, -3.141592653589793238462643383279502884197L, 0 },
#endif
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 106
	TEST_c_c(cacosh, 0x1p-106L, 0x1.000000000000000000000000008p0L, 8.813735870195430252326093249798097405561e-1L, 1.570796326794896619231321691639742726335L, 0 },
	TEST_c_c(cacosh, 0x1p-106L, -0x1.000000000000000000000000008p0L, 8.813735870195430252326093249798097405561e-1L, -1.570796326794896619231321691639742726335L, 0 },
	TEST_c_c(cacosh, -0x1p-106L, 0x1.000000000000000000000000008p0L, 8.813735870195430252326093249798097405561e-1L, 1.570796326794896619231321691639760157863L, 0 },
	TEST_c_c(cacosh, -0x1p-106L, -0x1.000000000000000000000000008p0L, 8.813735870195430252326093249798097405561e-1L, -1.570796326794896619231321691639760157863L, 0 },
	TEST_c_c(cacosh, 0x1.000000000000000000000000008p0L, 0x1p-106L, 2.285028863093221674154232933662774454211e-16L, 5.394221422390606848017034778914096659726e-17L, 0 },
	TEST_c_c(cacosh, -0x1.000000000000000000000000008p0L, 0x1p-106L, 2.285028863093221674154232933662774454211e-16L, 3.141592653589793184520429159373434404027L, 0 },
	TEST_c_c(cacosh, 0x1.000000000000000000000000008p0L, -0x1p-106L, 2.285028863093221674154232933662774454211e-16L, -5.394221422390606848017034778914096659726e-17L, 0 },
	TEST_c_c(cacosh, -0x1.000000000000000000000000008p0L, -0x1p-106L, 2.285028863093221674154232933662774454211e-16L, -3.141592653589793184520429159373434404027L, 0 },
	TEST_c_c(cacosh, 0x1.fp-1025L, 0x1.000000000000000000000000008p0L, 8.813735870195430252326093249798097405561e-1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 0x1.fp-1025L, -0x1.000000000000000000000000008p0L, 8.813735870195430252326093249798097405561e-1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0x1.fp-1025L, 0x1.000000000000000000000000008p0L, 8.813735870195430252326093249798097405561e-1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0x1.fp-1025L, -0x1.000000000000000000000000008p0L, 8.813735870195430252326093249798097405561e-1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 0x1.000000000000000000000000008p0L, 0x1.fp-1025L, 2.220446049250313080847263336181636063482e-16L, 2.426922623448365473354662093431821897807e-293L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM, 0 },
	TEST_c_c(cacosh, -0x1.000000000000000000000000008p0L, 0x1.fp-1025L, 2.220446049250313080847263336181636063482e-16L, 3.141592653589793238462643383279502884197L, 0 },
	TEST_c_c(cacosh, 0x1.000000000000000000000000008p0L, -0x1.fp-1025L, 2.220446049250313080847263336181636063482e-16L, -2.426922623448365473354662093431821897807e-293L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM, 0 },
	TEST_c_c(cacosh, -0x1.000000000000000000000000008p0L, -0x1.fp-1025L, 2.220446049250313080847263336181636063482e-16L, -3.141592653589793238462643383279502884197L, 0 },
	TEST_c_c(cacosh, 0.0L, 0x1.000000000000000000000000008p0L, 8.813735870195430252326093249798097405561e-1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 0.0L, -0x1.000000000000000000000000008p0L, 8.813735870195430252326093249798097405561e-1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0.0L, 0x1.000000000000000000000000008p0L, 8.813735870195430252326093249798097405561e-1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0.0L, -0x1.000000000000000000000000008p0L, 8.813735870195430252326093249798097405561e-1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 0x1.000000000000000000000000008p0L, 0.0L, 2.220446049250313080847263336181636063482e-16L, 0.0L, 0 },
	TEST_c_c(cacosh, -0x1.000000000000000000000000008p0L, 0.0L, 2.220446049250313080847263336181636063482e-16L, 3.141592653589793238462643383279502884197L, 0 },
	TEST_c_c(cacosh, 0x1.000000000000000000000000008p0L, -0.0L, 2.220446049250313080847263336181636063482e-16L, -0.0L, 0 },
	TEST_c_c(cacosh, -0x1.000000000000000000000000008p0L, -0.0L, 2.220446049250313080847263336181636063482e-16L, -3.141592653589793238462643383279502884197L, 0 },
#endif
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 113
	TEST_c_c(cacosh, 0x1p-113L, 0x1.0000000000000000000000000001p0L, 8.813735870195430252326093249797924452120e-1L, 1.570796326794896619231321691639751374007L, 0 },
	TEST_c_c(cacosh, 0x1p-113L, -0x1.0000000000000000000000000001p0L, 8.813735870195430252326093249797924452120e-1L, -1.570796326794896619231321691639751374007L, 0 },
	TEST_c_c(cacosh, -0x1p-113L, 0x1.0000000000000000000000000001p0L, 8.813735870195430252326093249797924452120e-1L, 1.570796326794896619231321691639751510190L, 0 },
	TEST_c_c(cacosh, -0x1p-113L, -0x1.0000000000000000000000000001p0L, 8.813735870195430252326093249797924452120e-1L, -1.570796326794896619231321691639751510190L, 0 },
	TEST_c_c(cacosh, 0x1.0000000000000000000000000001p0L, 0x1p-113L, 2.019699255375255198156433710951064632386e-17L, 4.767863183742677481693563511435642755521e-18L, 0 },
	TEST_c_c(cacosh, -0x1.0000000000000000000000000001p0L, 0x1p-113L, 2.019699255375255198156433710951064632386e-17L, 3.141592653589793233694780199536825402504L, 0 },
	TEST_c_c(cacosh, 0x1.0000000000000000000000000001p0L, -0x1p-113L, 2.019699255375255198156433710951064632386e-17L, -4.767863183742677481693563511435642755521e-18L, 0 },
	TEST_c_c(cacosh, -0x1.0000000000000000000000000001p0L, -0x1p-113L, 2.019699255375255198156433710951064632386e-17L, -3.141592653589793233694780199536825402504L, 0 },
	TEST_c_c(cacosh, 0x1.fp-16385L, 0x1.0000000000000000000000000001p0L, 8.813735870195430252326093249797924452120e-1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 0x1.fp-16385L, -0x1.0000000000000000000000000001p0L, 8.813735870195430252326093249797924452120e-1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0x1.fp-16385L, 0x1.0000000000000000000000000001p0L, 8.813735870195430252326093249797924452120e-1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0x1.fp-16385L, -0x1.0000000000000000000000000001p0L, 8.813735870195430252326093249797924452120e-1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 0x1.0000000000000000000000000001p0L, 0x1.fp-16385L, 1.962615573354718824241727964954454332780e-17L, 4.148847925325683229178506116378864361396e-4916L, 0 },
	TEST_c_c(cacosh, -0x1.0000000000000000000000000001p0L, 0x1.fp-16385L, 1.962615573354718824241727964954454332780e-17L, 3.141592653589793238462643383279502884197L, 0 },
	TEST_c_c(cacosh, 0x1.0000000000000000000000000001p0L, -0x1.fp-16385L, 1.962615573354718824241727964954454332780e-17L, -4.148847925325683229178506116378864361396e-4916L, 0 },
	TEST_c_c(cacosh, -0x1.0000000000000000000000000001p0L, -0x1.fp-16385L, 1.962615573354718824241727964954454332780e-17L, -3.141592653589793238462643383279502884197L, 0 },
	TEST_c_c(cacosh, 0.0L, 0x1.0000000000000000000000000001p0L, 8.813735870195430252326093249797924452120e-1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 0.0L, -0x1.0000000000000000000000000001p0L, 8.813735870195430252326093249797924452120e-1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0.0L, 0x1.0000000000000000000000000001p0L, 8.813735870195430252326093249797924452120e-1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0.0L, -0x1.0000000000000000000000000001p0L, 8.813735870195430252326093249797924452120e-1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 0x1.0000000000000000000000000001p0L, 0.0L, 1.962615573354718824241727964954454332780e-17L, 0.0L, 0 },
	TEST_c_c(cacosh, -0x1.0000000000000000000000000001p0L, 0.0L, 1.962615573354718824241727964954454332780e-17L, 3.141592653589793238462643383279502884197L, 0 },
	TEST_c_c(cacosh, 0x1.0000000000000000000000000001p0L, -0.0L, 1.962615573354718824241727964954454332780e-17L, -0.0L, 0 },
	TEST_c_c(cacosh, -0x1.0000000000000000000000000001p0L, -0.0L, 1.962615573354718824241727964954454332780e-17L, -3.141592653589793238462643383279502884197L, 0 },
#endif
	TEST_c_c(cacosh, 0x1p-23L, 0x0.ffffffp0L, 8.813735448726963984495965873956465777250e-1L, 1.570796242501197085295336701632142060969L, 0 },
	TEST_c_c(cacosh, 0x1p-23L, -0x0.ffffffp0L, 8.813735448726963984495965873956465777250e-1L, -1.570796242501197085295336701632142060969L, 0 },
	TEST_c_c(cacosh, -0x1p-23L, 0x0.ffffffp0L, 8.813735448726963984495965873956465777250e-1L, 1.570796411088596153167306681647360823228L, 0 },
	TEST_c_c(cacosh, -0x1p-23L, -0x0.ffffffp0L, 8.813735448726963984495965873956465777250e-1L, -1.570796411088596153167306681647360823228L, 0 },
	TEST_c_c(cacosh, 0x0.ffffffp0L, 0x1p-23L, 2.714321200917194650737217746780928423385e-4L, 4.391863861910487109445187743978204002614e-4L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacosh, -0x0.ffffffp0L, 0x1p-23L, 2.714321200917194650737217746780928423385e-4L, 3.141153467203602189751698864505105063797L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacosh, 0x0.ffffffp0L, -0x1p-23L, 2.714321200917194650737217746780928423385e-4L, -4.391863861910487109445187743978204002614e-4L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacosh, -0x0.ffffffp0L, -0x1p-23L, 2.714321200917194650737217746780928423385e-4L, -3.141153467203602189751698864505105063797L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacosh, 0x1.fp-129L, 0x0.ffffffp0L, 8.813735448726938863015878255140556727969e-1L, 1.570796326794896619231321691639751442097L, 0 },
	TEST_c_c(cacosh, 0x1.fp-129L, -0x0.ffffffp0L, 8.813735448726938863015878255140556727969e-1L, -1.570796326794896619231321691639751442097L, 0 },
	TEST_c_c(cacosh, -0x1.fp-129L, 0x0.ffffffp0L, 8.813735448726938863015878255140556727969e-1L, 1.570796326794896619231321691639751442101L, 0 },
	TEST_c_c(cacosh, -0x1.fp-129L, -0x0.ffffffp0L, 8.813735448726938863015878255140556727969e-1L, -1.570796326794896619231321691639751442101L, 0 },
	TEST_c_c(cacosh, 0x0.ffffffp0L, 0x1.fp-129L, 8.245504387859737323891843603996428534945e-36L, 3.452669847162035876032494826387364972849e-4L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, -0x0.ffffffp0L, 0x1.fp-129L, 8.245504387859737323891843603996428534945e-36L, 3.141247386605077034875040133796864147700L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, 0x0.ffffffp0L, -0x1.fp-129L, 8.245504387859737323891843603996428534945e-36L, -3.452669847162035876032494826387364972849e-4L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, -0x0.ffffffp0L, -0x1.fp-129L, 8.245504387859737323891843603996428534945e-36L, -3.141247386605077034875040133796864147700L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, 0.0L, 0x0.ffffffp0L, 8.813735448726938863015878255140556727969e-1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 0.0L, -0x0.ffffffp0L, 8.813735448726938863015878255140556727969e-1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0.0L, 0x0.ffffffp0L, 8.813735448726938863015878255140556727969e-1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0.0L, -0x0.ffffffp0L, 8.813735448726938863015878255140556727969e-1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 0x0.ffffffp0L, 0.0L, 0.0L, 3.452669847162035876032494826387364972849e-4L, 0 },
	TEST_c_c(cacosh, -0x0.ffffffp0L, 0.0L, 0.0L, 3.141247386605077034875040133796864147700L, 0 },
	TEST_c_c(cacosh, 0x0.ffffffp0L, -0.0L, 0.0L, -3.452669847162035876032494826387364972849e-4L, 0 },
	TEST_c_c(cacosh, -0x0.ffffffp0L, -0.0L, 0.0L, -3.141247386605077034875040133796864147700L, 0 },
	TEST_c_c(cacosh, 0x1p-23L, 0.5L, 4.812118250596059896127318386463676808798e-1L, 1.570796220170866625230343643673321150378L, 0 },
	TEST_c_c(cacosh, 0x1p-23L, -0.5L, 4.812118250596059896127318386463676808798e-1L, -1.570796220170866625230343643673321150378L, 0 },
	TEST_c_c(cacosh, -0x1p-23L, 0.5L, 4.812118250596059896127318386463676808798e-1L, 1.570796433418926613232299739606181733819L, 0 },
	TEST_c_c(cacosh, -0x1p-23L, -0.5L, 4.812118250596059896127318386463676808798e-1L, -1.570796433418926613232299739606181733819L, 0 },
	TEST_c_c(cacosh, 0.5L, 0x1p-23L, 1.376510308240943236356088341381173571841e-7L, 1.047197551196603215914744618665204532273L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacosh, -0.5L, 0x1p-23L, 1.376510308240943236356088341381173571841e-7L, 2.094395102393190022547898764614298351924L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacosh, 0.5L, -0x1p-23L, 1.376510308240943236356088341381173571841e-7L, -1.047197551196603215914744618665204532273L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacosh, -0.5L, -0x1p-23L, 1.376510308240943236356088341381173571841e-7L, -2.094395102393190022547898764614298351924L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacosh, 0x1.fp-129L, 0.5L, 4.812118250596034474977589134243684231352e-1L, 1.570796326794896619231321691639751442096L, 0 },
	TEST_c_c(cacosh, 0x1.fp-129L, -0.5L, 4.812118250596034474977589134243684231352e-1L, -1.570796326794896619231321691639751442096L, 0 },
	TEST_c_c(cacosh, -0x1.fp-129L, 0.5L, 4.812118250596034474977589134243684231352e-1L, 1.570796326794896619231321691639751442101L, 0 },
	TEST_c_c(cacosh, -0x1.fp-129L, -0.5L, 4.812118250596034474977589134243684231352e-1L, -1.570796326794896619231321691639751442101L, 0 },
	TEST_c_c(cacosh, 0.5L, 0x1.fp-129L, 3.287317402534702257036015056278368274737e-39L, 1.047197551196597746154214461093167628066L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, -0.5L, 0x1.fp-129L, 3.287317402534702257036015056278368274737e-39L, 2.094395102393195492308428922186335256131L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, 0.5L, -0x1.fp-129L, 3.287317402534702257036015056278368274737e-39L, -1.047197551196597746154214461093167628066L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, -0.5L, -0x1.fp-129L, 3.287317402534702257036015056278368274737e-39L, -2.094395102393195492308428922186335256131L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, 0x1p-23L, 0x1p-23L, 1.192092895507818146886315028596704749235e-7L, 1.570796207585607068450636380271254316214L, 0 },
	TEST_c_c(cacosh, 0x1p-23L, -0x1p-23L, 1.192092895507818146886315028596704749235e-7L, -1.570796207585607068450636380271254316214L, 0 },
	TEST_c_c(cacosh, -0x1p-23L, 0x1p-23L, 1.192092895507818146886315028596704749235e-7L, 1.570796446004186170012007003008248567984L, 0 },
	TEST_c_c(cacosh, -0x1p-23L, -0x1p-23L, 1.192092895507818146886315028596704749235e-7L, -1.570796446004186170012007003008248567984L, 0 },
	TEST_c_c(cacosh, 0x1.fp-129L, 0x1p-23L, 1.192092895507809676556842485683592032154e-7L, 1.570796326794896619231321691639751442096L, 0 },
	TEST_c_c(cacosh, 0x1.fp-129L, -0x1p-23L, 1.192092895507809676556842485683592032154e-7L, -1.570796326794896619231321691639751442096L, 0 },
	TEST_c_c(cacosh, -0x1.fp-129L, 0x1p-23L, 1.192092895507809676556842485683592032154e-7L, 1.570796326794896619231321691639751442101L, 0 },
	TEST_c_c(cacosh, -0x1.fp-129L, -0x1p-23L, 1.192092895507809676556842485683592032154e-7L, -1.570796326794896619231321691639751442101L, 0 },
	TEST_c_c(cacosh, 0x1p-23L, 0x1.fp-129L, 2.846900380897747786805634596726756660388e-39L, 1.570796207585607068449789347324000006847L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, -0x1p-23L, 0x1.fp-129L, 2.846900380897747786805634596726756660388e-39L, 1.570796446004186170012854035955502877351L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, 0x1p-23L, -0x1.fp-129L, 2.846900380897747786805634596726756660388e-39L, -1.570796207585607068449789347324000006847L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, -0x1p-23L, -0x1.fp-129L, 2.846900380897747786805634596726756660388e-39L, -1.570796446004186170012854035955502877351L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, 0.0L, 0x1p-23L, 1.192092895507809676556842485683592032154e-7L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 0.0L, -0x1p-23L, 1.192092895507809676556842485683592032154e-7L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0.0L, 0x1p-23L, 1.192092895507809676556842485683592032154e-7L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0.0L, -0x1p-23L, 1.192092895507809676556842485683592032154e-7L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 0x1p-23L, 0.0L, 0.0L, 1.570796207585607068449789347324000006847L, 0 },
	TEST_c_c(cacosh, -0x1p-23L, 0.0L, 0.0L, 1.570796446004186170012854035955502877351L, 0 },
	TEST_c_c(cacosh, 0x1p-23L, -0.0L, 0.0L, -1.570796207585607068449789347324000006847L, 0 },
	TEST_c_c(cacosh, -0x1p-23L, -0.0L, 0.0L, -1.570796446004186170012854035955502877351L, 0 },
	TEST_c_c(cacosh, 0x1.fp-129L, 0x1.fp-129L, 2.846900380897727558361783801085126250967e-39L, 1.570796326794896619231321691639751442096L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, 0x1.fp-129L, -0x1.fp-129L, 2.846900380897727558361783801085126250967e-39L, -1.570796326794896619231321691639751442096L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, -0x1.fp-129L, 0x1.fp-129L, 2.846900380897727558361783801085126250967e-39L, 1.570796326794896619231321691639751442101L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, -0x1.fp-129L, -0x1.fp-129L, 2.846900380897727558361783801085126250967e-39L, -1.570796326794896619231321691639751442101L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
#ifndef TEST_FLOAT
	TEST_c_c(cacosh, 0x1p-52L, 0x0.fffffffffffff8p0L, 8.813735870195429467279863907910458761820e-1L, 1.570796326794896462222075823262236786996L, 0 },
	TEST_c_c(cacosh, 0x1p-52L, -0x0.fffffffffffff8p0L, 8.813735870195429467279863907910458761820e-1L, -1.570796326794896462222075823262236786996L, 0 },
	TEST_c_c(cacosh, -0x1p-52L, 0x0.fffffffffffff8p0L, 8.813735870195429467279863907910458761820e-1L, 1.570796326794896776240567560017266097201L, 0 },
	TEST_c_c(cacosh, -0x1p-52L, -0x0.fffffffffffff8p0L, 8.813735870195429467279863907910458761820e-1L, -1.570796326794896776240567560017266097201L, 0 },
	TEST_c_c(cacosh, 0x0.fffffffffffff8p0L, 0x1p-52L, 1.171456840272878582596796205397918831268e-8L, 1.895456983915074112227925127005564372844e-8L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, -0x0.fffffffffffff8p0L, 0x1p-52L, 1.171456840272878582596796205397918831268e-8L, 3.141592634635223399311902261000251614142L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, 0x0.fffffffffffff8p0L, -0x1p-52L, 1.171456840272878582596796205397918831268e-8L, -1.895456983915074112227925127005564372844e-8L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, -0x0.fffffffffffff8p0L, -0x1p-52L, 1.171456840272878582596796205397918831268e-8L, -3.141592634635223399311902261000251614142L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, 0x1.fp-1025L, 0x0.fffffffffffff8p0L, 8.813735870195429467279863907910371604180e-1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 0x1.fp-1025L, -0x0.fffffffffffff8p0L, 8.813735870195429467279863907910371604180e-1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0x1.fp-1025L, 0x0.fffffffffffff8p0L, 8.813735870195429467279863907910371604180e-1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0x1.fp-1025L, -0x0.fffffffffffff8p0L, 8.813735870195429467279863907910371604180e-1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 0x0.fffffffffffff8p0L, 0x1.fp-1025L, 3.616396521699973256461764099945789620604e-301L, 1.490116119384765638786343542550461592240e-8L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, -0x0.fffffffffffff8p0L, 0x1.fp-1025L, 3.616396521699973256461764099945789620604e-301L, 3.141592638688632044614986995416067458693L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, 0x0.fffffffffffff8p0L, -0x1.fp-1025L, 3.616396521699973256461764099945789620604e-301L, -1.490116119384765638786343542550461592240e-8L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, -0x0.fffffffffffff8p0L, -0x1.fp-1025L, 3.616396521699973256461764099945789620604e-301L, -3.141592638688632044614986995416067458693L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, 0.0L, 0x0.fffffffffffff8p0L, 8.813735870195429467279863907910371604180e-1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 0.0L, -0x0.fffffffffffff8p0L, 8.813735870195429467279863907910371604180e-1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0.0L, 0x0.fffffffffffff8p0L, 8.813735870195429467279863907910371604180e-1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0.0L, -0x0.fffffffffffff8p0L, 8.813735870195429467279863907910371604180e-1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 0x0.fffffffffffff8p0L, 0.0L, 0.0L, 1.490116119384765638786343542550461592240e-8L, 0 },
	TEST_c_c(cacosh, -0x0.fffffffffffff8p0L, 0.0L, 0.0L, 3.141592638688632044614986995416067458693L, 0 },
	TEST_c_c(cacosh, 0x0.fffffffffffff8p0L, -0.0L, 0.0L, -1.490116119384765638786343542550461592240e-8L, 0 },
	TEST_c_c(cacosh, -0x0.fffffffffffff8p0L, -0.0L, 0.0L, -3.141592638688632044614986995416067458693L, 0 },
#endif
	TEST_c_c(cacosh, 0x1p-52L, 0.5L, 4.812118250596034474977589134243772428682e-1L, 1.570796326794896420628589431857911675917L, 0 },
	TEST_c_c(cacosh, 0x1p-52L, -0.5L, 4.812118250596034474977589134243772428682e-1L, -1.570796326794896420628589431857911675917L, 0 },
	TEST_c_c(cacosh, -0x1p-52L, 0.5L, 4.812118250596034474977589134243772428682e-1L, 1.570796326794896817834053951421591208280L, 0 },
	TEST_c_c(cacosh, -0x1p-52L, -0.5L, 4.812118250596034474977589134243772428682e-1L, -1.570796326794896817834053951421591208280L, 0 },
	TEST_c_c(cacosh, 0.5L, 0x1p-52L, 2.563950248511418570403591756798643804971e-16L, 1.047197551196597746154214461093186605110L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, -0.5L, 0x1p-52L, 2.563950248511418570403591756798643804971e-16L, 2.094395102393195492308428922186316279087L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, 0.5L, -0x1p-52L, 2.563950248511418570403591756798643804971e-16L, -1.047197551196597746154214461093186605110L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, -0.5L, -0x1p-52L, 2.563950248511418570403591756798643804971e-16L, -2.094395102393195492308428922186316279087L, 0|XFAIL_NATIVE_LINUX },
#ifndef TEST_FLOAT
	TEST_c_c(cacosh, 0x1.fp-1025L, 0.5L, 4.812118250596034474977589134243684231352e-1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 0x1.fp-1025L, -0.5L, 4.812118250596034474977589134243684231352e-1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0x1.fp-1025L, 0.5L, 4.812118250596034474977589134243684231352e-1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0x1.fp-1025L, -0.5L, 4.812118250596034474977589134243684231352e-1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 0.5L, 0x1.fp-1025L, 6.222508863508420569166420770843207333493e-309L, 1.047197551196597746154214461093167628066L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, -0.5L, 0x1.fp-1025L, 6.222508863508420569166420770843207333493e-309L, 2.094395102393195492308428922186335256131L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, 0.5L, -0x1.fp-1025L, 6.222508863508420569166420770843207333493e-309L, -1.047197551196597746154214461093167628066L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, -0.5L, -0x1.fp-1025L, 6.222508863508420569166420770843207333493e-309L, -2.094395102393195492308428922186335256131L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
#endif
	TEST_c_c(cacosh, 0x1p-52L, 0x1p-52L, 2.220446049250313080847263336181677117148e-16L, 1.570796326794896397186716766608443357372L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacosh, 0x1p-52L, -0x1p-52L, 2.220446049250313080847263336181677117148e-16L, -1.570796326794896397186716766608443357372L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacosh, -0x1p-52L, 0x1p-52L, 2.220446049250313080847263336181677117148e-16L, 1.570796326794896841275926616671059526825L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacosh, -0x1p-52L, -0x1p-52L, 2.220446049250313080847263336181677117148e-16L, -1.570796326794896841275926616671059526825L, 0|XFAIL_NATIVE_LINUXF },
#ifndef TEST_FLOAT
	TEST_c_c(cacosh, 0x1.fp-1025L, 0x1p-52L, 2.220446049250313080847263336181622378926e-16L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 0x1.fp-1025L, -0x1p-52L, 2.220446049250313080847263336181622378926e-16L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0x1.fp-1025L, 0x1p-52L, 2.220446049250313080847263336181622378926e-16L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0x1.fp-1025L, -0x1p-52L, 2.220446049250313080847263336181622378926e-16L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 0x1p-52L, 0x1.fp-1025L, 5.388850751072128349671657362289548938458e-309L, 1.570796326794896397186716766608443357372L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, -0x1p-52L, 0x1.fp-1025L, 5.388850751072128349671657362289548938458e-309L, 1.570796326794896841275926616671059526825L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, 0x1p-52L, -0x1.fp-1025L, 5.388850751072128349671657362289548938458e-309L, -1.570796326794896397186716766608443357372L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, -0x1p-52L, -0x1.fp-1025L, 5.388850751072128349671657362289548938458e-309L, -1.570796326794896841275926616671059526825L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
#endif
	TEST_c_c(cacosh, 0.0L, 0x1p-52L, 2.220446049250313080847263336181622378926e-16L, 1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacosh, 0.0L, -0x1p-52L, 2.220446049250313080847263336181622378926e-16L, -1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacosh, -0.0L, 0x1p-52L, 2.220446049250313080847263336181622378926e-16L, 1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacosh, -0.0L, -0x1p-52L, 2.220446049250313080847263336181622378926e-16L, -1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cacosh, 0x1p-52L, 0.0L, 0.0L, 1.570796326794896397186716766608443357372L, 0 },
	TEST_c_c(cacosh, -0x1p-52L, 0.0L, 0.0L, 1.570796326794896841275926616671059526825L, 0 },
	TEST_c_c(cacosh, 0x1p-52L, -0.0L, 0.0L, -1.570796326794896397186716766608443357372L, 0 },
	TEST_c_c(cacosh, -0x1p-52L, -0.0L, 0.0L, -1.570796326794896841275926616671059526825L, 0 },
#ifndef TEST_FLOAT
	TEST_c_c(cacosh, 0x1.fp-1025L, 0x1.fp-1025L, 5.388850751072128349671657362289416093031e-309L, 1.570796326794896619231321691639751442099L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, 0x1.fp-1025L, -0x1.fp-1025L, 5.388850751072128349671657362289416093031e-309L, -1.570796326794896619231321691639751442099L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, -0x1.fp-1025L, 0x1.fp-1025L, 5.388850751072128349671657362289416093031e-309L, 1.570796326794896619231321691639751442099L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, -0x1.fp-1025L, -0x1.fp-1025L, 5.388850751072128349671657362289416093031e-309L, -1.570796326794896619231321691639751442099L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
#endif
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	TEST_c_c(cacosh, 0x1p-63L, 0x0.ffffffffffffffffp0L, 8.813735870195430251942769895627079569937e-1L, 1.570796326794896619154657020805582738025L, 0 },
	TEST_c_c(cacosh, 0x1p-63L, -0x0.ffffffffffffffffp0L, 8.813735870195430251942769895627079569937e-1L, -1.570796326794896619154657020805582738025L, 0 },
	TEST_c_c(cacosh, -0x1p-63L, 0x0.ffffffffffffffffp0L, 8.813735870195430251942769895627079569937e-1L, 1.570796326794896619307986362473920146173L, 0 },
	TEST_c_c(cacosh, -0x1p-63L, -0x0.ffffffffffffffffp0L, 8.813735870195430251942769895627079569937e-1L, -1.570796326794896619307986362473920146173L, 0 },
	TEST_c_c(cacosh, 0x0.ffffffffffffffffp0L, 0x1p-63L, 2.588578361325995866221775673638805081337e-10L, 4.188407771167967636741951941902992986043e-10L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacosh, -0x0.ffffffffffffffffp0L, 0x1p-63L, 2.588578361325995866221775673638805081337e-10L, 3.141592653170952461345846619605307690007L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacosh, 0x0.ffffffffffffffffp0L, -0x1p-63L, 2.588578361325995866221775673638805081337e-10L, -4.188407771167967636741951941902992986043e-10L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacosh, -0x0.ffffffffffffffffp0L, -0x1p-63L, 2.588578361325995866221775673638805081337e-10L, -3.141592653170952461345846619605307690007L, 0|XFAIL_NATIVE_LINUXL },
# if LDBL_MIN_EXP <= -16381
	TEST_c_c(cacosh, 0x1.fp-16385L, 0x0.ffffffffffffffffp0L, 8.813735870195430251942769895627079569917e-1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 0x1.fp-16385L, -0x0.ffffffffffffffffp0L, 8.813735870195430251942769895627079569917e-1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0x1.fp-16385L, 0x0.ffffffffffffffffp0L, 8.813735870195430251942769895627079569917e-1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0x1.fp-16385L, -0x0.ffffffffffffffffp0L, 8.813735870195430251942769895627079569917e-1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 0x0.ffffffffffffffffp0L, 0x1.fp-16385L, 2.472906068161537187835415298076415423459e-4923L, 3.292722539913596233371825532007990724506e-10L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacosh, -0x0.ffffffffffffffffp0L, 0x1.fp-16385L, 2.472906068161537187835415298076415423459e-4923L, 3.141592653260520984471283759942320330996L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacosh, 0x0.ffffffffffffffffp0L, -0x1.fp-16385L, 2.472906068161537187835415298076415423459e-4923L, -3.292722539913596233371825532007990724506e-10L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacosh, -0x0.ffffffffffffffffp0L, -0x1.fp-16385L, 2.472906068161537187835415298076415423459e-4923L, -3.141592653260520984471283759942320330996L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
# endif
	TEST_c_c(cacosh, 0.0L, 0x0.ffffffffffffffffp0L, 8.813735870195430251942769895627079569917e-1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 0.0L, -0x0.ffffffffffffffffp0L, 8.813735870195430251942769895627079569917e-1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0.0L, 0x0.ffffffffffffffffp0L, 8.813735870195430251942769895627079569917e-1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0.0L, -0x0.ffffffffffffffffp0L, 8.813735870195430251942769895627079569917e-1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 0x0.ffffffffffffffffp0L, 0.0L, 0.0L, 3.292722539913596233371825532007990724506e-10L, 0 },
	TEST_c_c(cacosh, -0x0.ffffffffffffffffp0L, 0.0L, 0.0L, 3.141592653260520984471283759942320330996L, 0 },
	TEST_c_c(cacosh, 0x0.ffffffffffffffffp0L, -0.0L, 0.0L, -3.292722539913596233371825532007990724506e-10L, 0 },
	TEST_c_c(cacosh, -0x0.ffffffffffffffffp0L, -0.0L, 0.0L, -3.141592653260520984471283759942320330996L, 0 },
#endif
	TEST_c_c(cacosh, 0x1p-63L, 0.5L, 4.812118250596034474977589134243684231373e-1L, 1.570796326794896619134347701278529840650L, 0 },
	TEST_c_c(cacosh, 0x1p-63L, -0.5L, 4.812118250596034474977589134243684231373e-1L, -1.570796326794896619134347701278529840650L, 0 },
	TEST_c_c(cacosh, -0x1p-63L, 0.5L, 4.812118250596034474977589134243684231373e-1L, 1.570796326794896619328295682000973043547L, 0 },
	TEST_c_c(cacosh, -0x1p-63L, -0.5L, 4.812118250596034474977589134243684231373e-1L, -1.570796326794896619328295682000973043547L, 0 },
	TEST_c_c(cacosh, 0.5L, 0x1p-63L, 1.251928832280966098829878787499365228659e-19L, 1.047197551196597746154214461093167628070L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, -0.5L, 0x1p-63L, 1.251928832280966098829878787499365228659e-19L, 2.094395102393195492308428922186335256127L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, 0.5L, -0x1p-63L, 1.251928832280966098829878787499365228659e-19L, -1.047197551196597746154214461093167628070L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, -0.5L, -0x1p-63L, 1.251928832280966098829878787499365228659e-19L, -2.094395102393195492308428922186335256127L, 0|XFAIL_NATIVE_LINUX },
#if defined TEST_LDOUBLE && LDBL_MIN_EXP <= -16381
	TEST_c_c(cacosh, 0x1.fp-16385L, 0.5L, 4.812118250596034474977589134243684231352e-1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 0x1.fp-16385L, -0.5L, 4.812118250596034474977589134243684231352e-1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0x1.fp-16385L, 0.5L, 4.812118250596034474977589134243684231352e-1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0x1.fp-16385L, -0.5L, 4.812118250596034474977589134243684231352e-1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 0.5L, 0x1.fp-16385L, 9.402257155670418112159334875199821342890e-4933L, 1.047197551196597746154214461093167628066L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacosh, -0.5L, 0x1.fp-16385L, 9.402257155670418112159334875199821342890e-4933L, 2.094395102393195492308428922186335256131L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacosh, 0.5L, -0x1.fp-16385L, 9.402257155670418112159334875199821342890e-4933L, -1.047197551196597746154214461093167628066L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacosh, -0.5L, -0x1.fp-16385L, 9.402257155670418112159334875199821342890e-4933L, -2.094395102393195492308428922186335256131L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
#endif
	TEST_c_c(cacosh, 0x1p-63L, 0x1p-63L, 1.084202172485504434007452800869941711430e-19L, 1.570796326794896619122901474391200998698L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, 0x1p-63L, -0x1p-63L, 1.084202172485504434007452800869941711430e-19L, -1.570796326794896619122901474391200998698L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, -0x1p-63L, 0x1p-63L, 1.084202172485504434007452800869941711430e-19L, 1.570796326794896619339741908888301885499L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, -0x1p-63L, -0x1p-63L, 1.084202172485504434007452800869941711430e-19L, -1.570796326794896619339741908888301885499L, 0|XFAIL_NATIVE_LINUX },
#if defined TEST_LDOUBLE && LDBL_MIN_EXP <= -16381
	TEST_c_c(cacosh, 0x1.fp-16385L, 0x1p-63L, 1.084202172485504434007452800869941711424e-19L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 0x1.fp-16385L, -0x1p-63L, 1.084202172485504434007452800869941711424e-19L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0x1.fp-16385L, 0x1p-63L, 1.084202172485504434007452800869941711424e-19L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0x1.fp-16385L, -0x1p-63L, 1.084202172485504434007452800869941711424e-19L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 0x1p-63L, 0x1.fp-16385L, 8.142593549724601460479922838826119584465e-4933L, 1.570796326794896619122901474391200998698L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacosh, -0x1p-63L, 0x1.fp-16385L, 8.142593549724601460479922838826119584465e-4933L, 1.570796326794896619339741908888301885499L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacosh, 0x1p-63L, -0x1.fp-16385L, 8.142593549724601460479922838826119584465e-4933L, -1.570796326794896619122901474391200998698L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacosh, -0x1p-63L, -0x1.fp-16385L, 8.142593549724601460479922838826119584465e-4933L, -1.570796326794896619339741908888301885499L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
#endif
	TEST_c_c(cacosh, 0.0L, 0x1p-63L, 1.084202172485504434007452800869941711424e-19L, 1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, 0.0L, -0x1p-63L, 1.084202172485504434007452800869941711424e-19L, -1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, -0.0L, 0x1p-63L, 1.084202172485504434007452800869941711424e-19L, 1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, -0.0L, -0x1p-63L, 1.084202172485504434007452800869941711424e-19L, -1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, 0x1p-63L, 0.0L, 0.0L, 1.570796326794896619122901474391200998698L, 0 },
	TEST_c_c(cacosh, -0x1p-63L, 0.0L, 0.0L, 1.570796326794896619339741908888301885499L, 0 },
	TEST_c_c(cacosh, 0x1p-63L, -0.0L, 0.0L, -1.570796326794896619122901474391200998698L, 0 },
	TEST_c_c(cacosh, -0x1p-63L, -0.0L, 0.0L, -1.570796326794896619339741908888301885499L, 0 },
#if defined TEST_LDOUBLE && LDBL_MIN_EXP <= -16381
	TEST_c_c(cacosh, 0x1.fp-16385L, 0x1.fp-16385L, 8.142593549724601460479922838826119584417e-4933L, 1.570796326794896619231321691639751442099L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacosh, 0x1.fp-16385L, -0x1.fp-16385L, 8.142593549724601460479922838826119584417e-4933L, -1.570796326794896619231321691639751442099L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacosh, -0x1.fp-16385L, 0x1.fp-16385L, 8.142593549724601460479922838826119584417e-4933L, 1.570796326794896619231321691639751442099L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacosh, -0x1.fp-16385L, -0x1.fp-16385L, 8.142593549724601460479922838826119584417e-4933L, -1.570796326794896619231321691639751442099L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
#endif
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 106
	TEST_c_c(cacosh, 0x1p-105L, 0x0.ffffffffffffffffffffffffffcp0L, 8.813735870195430252326093249797835932642e-1L, 1.570796326794896619231321691639734010571L, 0 },
	TEST_c_c(cacosh, 0x1p-105L, -0x0.ffffffffffffffffffffffffffcp0L, 8.813735870195430252326093249797835932642e-1L, -1.570796326794896619231321691639734010571L, 0 },
	TEST_c_c(cacosh, -0x1p-105L, 0x0.ffffffffffffffffffffffffffcp0L, 8.813735870195430252326093249797835932642e-1L, 1.570796326794896619231321691639768873627L, 0 },
	TEST_c_c(cacosh, -0x1p-105L, -0x0.ffffffffffffffffffffffffffcp0L, 8.813735870195430252326093249797835932642e-1L, -1.570796326794896619231321691639768873627L, 0 },
	TEST_c_c(cacosh, 0x0.ffffffffffffffffffffffffffcp0L, 0x1p-105L, 1.234330349600789959989661887846005659983e-16L, 1.997188458999618357060632049675702684031e-16L, 0 },
	TEST_c_c(cacosh, -0x0.ffffffffffffffffffffffffffcp0L, 0x1p-105L, 1.234330349600789959989661887846005659983e-16L, 3.141592653589793038743797483317667178134L, 0 },
	TEST_c_c(cacosh, 0x0.ffffffffffffffffffffffffffcp0L, -0x1p-105L, 1.234330349600789959989661887846005659983e-16L, -1.997188458999618357060632049675702684031e-16L, 0 },
	TEST_c_c(cacosh, -0x0.ffffffffffffffffffffffffffcp0L, -0x1p-105L, 1.234330349600789959989661887846005659983e-16L, -3.141592653589793038743797483317667178134L, 0 },
	TEST_c_c(cacosh, 0x1.fp-1025L, 0x0.ffffffffffffffffffffffffffcp0L, 8.813735870195430252326093249797835932642e-1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 0x1.fp-1025L, -0x0.ffffffffffffffffffffffffffcp0L, 8.813735870195430252326093249797835932642e-1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0x1.fp-1025L, 0x0.ffffffffffffffffffffffffffcp0L, 8.813735870195430252326093249797835932642e-1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0x1.fp-1025L, -0x0.ffffffffffffffffffffffffffcp0L, 8.813735870195430252326093249797835932642e-1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 0x0.ffffffffffffffffffffffffffcp0L, 0x1.fp-1025L, 3.432186888910770473784103112009399360940e-293L, 1.570092458683775059393382371963565104164e-16L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM, 0 },
	TEST_c_c(cacosh, -0x0.ffffffffffffffffffffffffffcp0L, 0x1.fp-1025L, 3.432186888910770473784103112009399360940e-293L, 3.141592653589793081453397514901996944859L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM, 0 },
	TEST_c_c(cacosh, 0x0.ffffffffffffffffffffffffffcp0L, -0x1.fp-1025L, 3.432186888910770473784103112009399360940e-293L, -1.570092458683775059393382371963565104164e-16L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM, 0 },
	TEST_c_c(cacosh, -0x0.ffffffffffffffffffffffffffcp0L, -0x1.fp-1025L, 3.432186888910770473784103112009399360940e-293L, -3.141592653589793081453397514901996944859L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM, 0 },
	TEST_c_c(cacosh, 0.0L, 0x0.ffffffffffffffffffffffffffcp0L, 8.813735870195430252326093249797835932642e-1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 0.0L, -0x0.ffffffffffffffffffffffffffcp0L, 8.813735870195430252326093249797835932642e-1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0.0L, 0x0.ffffffffffffffffffffffffffcp0L, 8.813735870195430252326093249797835932642e-1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0.0L, -0x0.ffffffffffffffffffffffffffcp0L, 8.813735870195430252326093249797835932642e-1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 0x0.ffffffffffffffffffffffffffcp0L, 0.0L, 0.0L, 1.570092458683775059393382371963565104164e-16L, 0 },
	TEST_c_c(cacosh, -0x0.ffffffffffffffffffffffffffcp0L, 0.0L, 0.0L, 3.141592653589793081453397514901996944859L, 0 },
	TEST_c_c(cacosh, 0x0.ffffffffffffffffffffffffffcp0L, -0.0L, 0.0L, -1.570092458683775059393382371963565104164e-16L, 0 },
	TEST_c_c(cacosh, -0x0.ffffffffffffffffffffffffffcp0L, -0.0L, 0.0L, -3.141592653589793081453397514901996944859L, 0 },
#endif
	TEST_c_c(cacosh, 0x1p-105L, 0.5L, 4.812118250596034474977589134243684231352e-1L, 1.570796326794896619231321691639729392766L, 0 },
	TEST_c_c(cacosh, 0x1p-105L, -0.5L, 4.812118250596034474977589134243684231352e-1L, -1.570796326794896619231321691639729392766L, 0 },
	TEST_c_c(cacosh, -0x1p-105L, 0.5L, 4.812118250596034474977589134243684231352e-1L, 1.570796326794896619231321691639773491431L, 0 },
	TEST_c_c(cacosh, -0x1p-105L, -0.5L, 4.812118250596034474977589134243684231352e-1L, -1.570796326794896619231321691639773491431L, 0 },
	TEST_c_c(cacosh, 0.5L, 0x1p-105L, 2.846556599890768890940941645338546615370e-32L, 1.047197551196597746154214461093167628066L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, -0.5L, 0x1p-105L, 2.846556599890768890940941645338546615370e-32L, 2.094395102393195492308428922186335256131L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, 0.5L, -0x1p-105L, 2.846556599890768890940941645338546615370e-32L, -1.047197551196597746154214461093167628066L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, -0.5L, -0x1p-105L, 2.846556599890768890940941645338546615370e-32L, -2.094395102393195492308428922186335256131L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, 0x1p-105L, 0x1p-105L, 2.465190328815661891911651766508706967729e-32L, 1.570796326794896619231321691639726790195L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, 0x1p-105L, -0x1p-105L, 2.465190328815661891911651766508706967729e-32L, -1.570796326794896619231321691639726790195L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, -0x1p-105L, 0x1p-105L, 2.465190328815661891911651766508706967729e-32L, 1.570796326794896619231321691639776094002L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, -0x1p-105L, -0x1p-105L, 2.465190328815661891911651766508706967729e-32L, -1.570796326794896619231321691639776094002L, 0|XFAIL_NATIVE_LINUX },
#ifndef TEST_FLOAT
	TEST_c_c(cacosh, 0x1.fp-1025L, 0x1p-105L, 2.465190328815661891911651766508706967729e-32L, 1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, 0x1.fp-1025L, -0x1p-105L, 2.465190328815661891911651766508706967729e-32L, -1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, -0x1.fp-1025L, 0x1p-105L, 2.465190328815661891911651766508706967729e-32L, 1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, -0x1.fp-1025L, -0x1p-105L, 2.465190328815661891911651766508706967729e-32L, -1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, 0x1p-105L, 0x1.fp-1025L, 5.388850751072128349671657362289416093031e-309L, 1.570796326794896619231321691639726790195L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, -0x1p-105L, 0x1.fp-1025L, 5.388850751072128349671657362289416093031e-309L, 1.570796326794896619231321691639776094002L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, 0x1p-105L, -0x1.fp-1025L, 5.388850751072128349671657362289416093031e-309L, -1.570796326794896619231321691639726790195L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, -0x1p-105L, -0x1.fp-1025L, 5.388850751072128349671657362289416093031e-309L, -1.570796326794896619231321691639776094002L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
#endif
	TEST_c_c(cacosh, 0.0L, 0x1p-105L, 2.465190328815661891911651766508706967729e-32L, 1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, 0.0L, -0x1p-105L, 2.465190328815661891911651766508706967729e-32L, -1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, -0.0L, 0x1p-105L, 2.465190328815661891911651766508706967729e-32L, 1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, -0.0L, -0x1p-105L, 2.465190328815661891911651766508706967729e-32L, -1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, 0x1p-105L, 0.0L, 0.0L, 1.570796326794896619231321691639726790195L, 0 },
	TEST_c_c(cacosh, -0x1p-105L, 0.0L, 0.0L, 1.570796326794896619231321691639776094002L, 0 },
	TEST_c_c(cacosh, 0x1p-105L, -0.0L, 0.0L, -1.570796326794896619231321691639726790195L, 0 },
	TEST_c_c(cacosh, -0x1p-105L, -0.0L, 0.0L, -1.570796326794896619231321691639776094002L, 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 113
	TEST_c_c(cacosh, 0x1p-112L, 0x0.ffffffffffffffffffffffffffff8p0L, 8.813735870195430252326093249797922409363e-1L, 1.570796326794896619231321691639751305915L, 0 },
	TEST_c_c(cacosh, 0x1p-112L, -0x0.ffffffffffffffffffffffffffff8p0L, 8.813735870195430252326093249797922409363e-1L, -1.570796326794896619231321691639751305915L, 0 },
	TEST_c_c(cacosh, -0x1p-112L, 0x0.ffffffffffffffffffffffffffff8p0L, 8.813735870195430252326093249797922409363e-1L, 1.570796326794896619231321691639751578282L, 0 },
	TEST_c_c(cacosh, -0x1p-112L, -0x0.ffffffffffffffffffffffffffff8p0L, 8.813735870195430252326093249797922409363e-1L, -1.570796326794896619231321691639751578282L, 0 },
	TEST_c_c(cacosh, 0x0.ffffffffffffffffffffffffffff8p0L, 0x1p-112L, 1.091004200533850618345330909857103457781e-17L, 1.765281878332676474347460257221369818872e-17L, 0 },
	TEST_c_c(cacosh, -0x0.ffffffffffffffffffffffffffff8p0L, 0x1p-112L, 1.091004200533850618345330909857103457781e-17L, 3.141592653589793220809824599952738140723L, 0 },
	TEST_c_c(cacosh, 0x0.ffffffffffffffffffffffffffff8p0L, -0x1p-112L, 1.091004200533850618345330909857103457781e-17L, -1.765281878332676474347460257221369818872e-17L, 0 },
	TEST_c_c(cacosh, -0x0.ffffffffffffffffffffffffffff8p0L, -0x1p-112L, 1.091004200533850618345330909857103457781e-17L, -3.141592653589793220809824599952738140723L, 0 },
	TEST_c_c(cacosh, 0x1.fp-16385L, 0x0.ffffffffffffffffffffffffffff8p0L, 8.813735870195430252326093249797922409363e-1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 0x1.fp-16385L, -0x0.ffffffffffffffffffffffffffff8p0L, 8.813735870195430252326093249797922409363e-1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0x1.fp-16385L, 0x0.ffffffffffffffffffffffffffff8p0L, 8.813735870195430252326093249797922409363e-1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0x1.fp-16385L, -0x0.ffffffffffffffffffffffffffff8p0L, 8.813735870195430252326093249797922409363e-1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 0x0.ffffffffffffffffffffffffffff8p0L, 0x1.fp-16385L, 5.867357004219059108790368268900490184505e-4916L, 1.387778780781445675529539585113525401762e-17L, 0 },
	TEST_c_c(cacosh, -0x0.ffffffffffffffffffffffffffff8p0L, 0x1.fp-16385L, 5.867357004219059108790368268900490184505e-4916L, 3.141592653589793224584855575465046128902L, 0 },
	TEST_c_c(cacosh, 0x0.ffffffffffffffffffffffffffff8p0L, -0x1.fp-16385L, 5.867357004219059108790368268900490184505e-4916L, -1.387778780781445675529539585113525401762e-17L, 0 },
	TEST_c_c(cacosh, -0x0.ffffffffffffffffffffffffffff8p0L, -0x1.fp-16385L, 5.867357004219059108790368268900490184505e-4916L, -3.141592653589793224584855575465046128902L, 0 },
	TEST_c_c(cacosh, 0.0L, 0x0.ffffffffffffffffffffffffffff8p0L, 8.813735870195430252326093249797922409363e-1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 0.0L, -0x0.ffffffffffffffffffffffffffff8p0L, 8.813735870195430252326093249797922409363e-1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0.0L, 0x0.ffffffffffffffffffffffffffff8p0L, 8.813735870195430252326093249797922409363e-1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, -0.0L, -0x0.ffffffffffffffffffffffffffff8p0L, 8.813735870195430252326093249797922409363e-1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(cacosh, 0x0.ffffffffffffffffffffffffffff8p0L, 0.0L, 0.0L, 1.387778780781445675529539585113525401762e-17L, 0 },
	TEST_c_c(cacosh, -0x0.ffffffffffffffffffffffffffff8p0L, 0.0L, 0.0L, 3.141592653589793224584855575465046128902L, 0 },
	TEST_c_c(cacosh, 0x0.ffffffffffffffffffffffffffff8p0L, -0.0L, 0.0L, -1.387778780781445675529539585113525401762e-17L, 0 },
	TEST_c_c(cacosh, -0x0.ffffffffffffffffffffffffffff8p0L, -0.0L, 0.0L, -3.141592653589793224584855575465046128902L, 0 },
#endif
	TEST_c_c(cacosh, 0x1p-112L, 0.5L, 4.812118250596034474977589134243684231352e-1L, 1.570796326794896619231321691639751269838L, 0 },
	TEST_c_c(cacosh, 0x1p-112L, -0.5L, 4.812118250596034474977589134243684231352e-1L, -1.570796326794896619231321691639751269838L, 0 },
	TEST_c_c(cacosh, -0x1p-112L, 0.5L, 4.812118250596034474977589134243684231352e-1L, 1.570796326794896619231321691639751614359L, 0 },
	TEST_c_c(cacosh, -0x1p-112L, -0.5L, 4.812118250596034474977589134243684231352e-1L, -1.570796326794896619231321691639751614359L, 0 },
	TEST_c_c(cacosh, 0.5L, 0x1p-112L, 2.223872343664663196047610660420739543258e-34L, 1.047197551196597746154214461093167628066L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, -0.5L, 0x1p-112L, 2.223872343664663196047610660420739543258e-34L, 2.094395102393195492308428922186335256131L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, 0.5L, -0x1p-112L, 2.223872343664663196047610660420739543258e-34L, -1.047197551196597746154214461093167628066L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, -0.5L, -0x1p-112L, 2.223872343664663196047610660420739543258e-34L, -2.094395102393195492308428922186335256131L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, 0x1p-112L, 0x1p-112L, 1.925929944387235853055977942584927318538e-34L, 1.570796326794896619231321691639751249506L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, 0x1p-112L, -0x1p-112L, 1.925929944387235853055977942584927318538e-34L, -1.570796326794896619231321691639751249506L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, -0x1p-112L, 0x1p-112L, 1.925929944387235853055977942584927318538e-34L, 1.570796326794896619231321691639751634692L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, -0x1p-112L, -0x1p-112L, 1.925929944387235853055977942584927318538e-34L, -1.570796326794896619231321691639751634692L, 0|XFAIL_NATIVE_LINUX },
#if defined TEST_LDOUBLE && LDBL_MIN_EXP <= -16381
	TEST_c_c(cacosh, 0x1.fp-16385L, 0x1p-112L, 1.925929944387235853055977942584927318538e-34L, 1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacosh, 0x1.fp-16385L, -0x1p-112L, 1.925929944387235853055977942584927318538e-34L, -1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacosh, -0x1.fp-16385L, 0x1p-112L, 1.925929944387235853055977942584927318538e-34L, 1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacosh, -0x1.fp-16385L, -0x1p-112L, 1.925929944387235853055977942584927318538e-34L, -1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacosh, 0x1p-112L, 0x1.fp-16385L, 8.142593549724601460479922838826119584417e-4933L, 1.570796326794896619231321691639751249506L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacosh, -0x1p-112L, 0x1.fp-16385L, 8.142593549724601460479922838826119584417e-4933L, 1.570796326794896619231321691639751634692L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacosh, 0x1p-112L, -0x1.fp-16385L, 8.142593549724601460479922838826119584417e-4933L, -1.570796326794896619231321691639751249506L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cacosh, -0x1p-112L, -0x1.fp-16385L, 8.142593549724601460479922838826119584417e-4933L, -1.570796326794896619231321691639751634692L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
#endif
	TEST_c_c(cacosh, 0.0L, 0x1p-112L, 1.925929944387235853055977942584927318538e-34L, 1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, 0.0L, -0x1p-112L, 1.925929944387235853055977942584927318538e-34L, -1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, -0.0L, 0x1p-112L, 1.925929944387235853055977942584927318538e-34L, 1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, -0.0L, -0x1p-112L, 1.925929944387235853055977942584927318538e-34L, -1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cacosh, 0x1p-112L, 0.0L, 0.0L, 1.570796326794896619231321691639751249506L, 0 },
	TEST_c_c(cacosh, -0x1p-112L, 0.0L, 0.0L, 1.570796326794896619231321691639751634692L, 0 },
	TEST_c_c(cacosh, 0x1p-112L, -0.0L, 0.0L, -1.570796326794896619231321691639751249506L, 0 },
	TEST_c_c(cacosh, -0x1p-112L, -0.0L, 0.0L, -1.570796326794896619231321691639751634692L, 0 },

	TEST_c_c(cacosh, 0.75L, 1.25L, 1.13239363160530819522266333696834467L, 1.11752014915610270578240049553777969L, 0 },
	TEST_c_c(cacosh, -2, -3, 1.9833870299165354323470769028940395L, -2.1414491111159960199416055713254211L, 0 },
}


static void test_casin(void)
{
	struct test *testp = lookup("casin" },

	TEST_c_c(casin, 1.0, 2.0, 4.270785786211490631e-01, 1.528570890426635742e00, 0 },
	TEST_c_c(casin, 0.0, 2.0, 0.000000000000000000e00, 1.443635478615760803e00, 0 },
	TEST_c_c(casin, 1.0, 0.0, 1.570796325802803039e00, ZERO_P, 0 },
	TEST_c_c(casin, -2.0, 2.0, -7.542491331696510314e-01, 1.734324455261230468e00, 0 },
	TEST_c_c(casin, -1.0, -2.0, -4.270785823464393615e-01, -1.528570920228958129e00, 0 },
	TEST_c_c(casin, 1.0, -2.0, 4.270785823464393615e-01, -1.528570920228958129e00, 0 },

	TEST_c_c(casin, 0, 0, 0.0, 0.0, 0 },
	TEST_c_c(casin, ZERO_M, 0, ZERO_M, 0.0, 0 },
	TEST_c_c(casin, 0, ZERO_M, 0.0, ZERO_M, 0 },
	TEST_c_c(casin, ZERO_M, ZERO_M, ZERO_M, ZERO_M, 0 },

	TEST_c_c(casin, INF_P, INF_P, M_PI_4l, INF_P, 0 },
	TEST_c_c(casin, INF_P, INF_M, M_PI_4l, INF_M, 0 },
	TEST_c_c(casin, INF_M, INF_P, -M_PI_4l, INF_P, 0 },
	TEST_c_c(casin, INF_M, INF_M, -M_PI_4l, INF_M, 0 },

	TEST_c_c(casin, -10.0, INF_P, ZERO_M, INF_P, 0 },
	TEST_c_c(casin, -10.0, INF_M, ZERO_M, INF_M, 0 },
	TEST_c_c(casin, 0, INF_P, 0.0, INF_P, 0 },
	TEST_c_c(casin, 0, INF_M, 0.0, INF_M, 0 },
	TEST_c_c(casin, ZERO_M, INF_P, ZERO_M, INF_P, 0 },
	TEST_c_c(casin, ZERO_M, INF_M, ZERO_M, INF_M, 0 },
	TEST_c_c(casin, 0.1L, INF_P, 0.0, INF_P, 0 },
	TEST_c_c(casin, 0.1L, INF_M, 0.0, INF_M, 0 },

	TEST_c_c(casin, INF_M, 0, -M_PI_2l, INF_P, 0 },
	TEST_c_c(casin, INF_M, ZERO_M, -M_PI_2l, INF_M, 0 },
	TEST_c_c(casin, INF_M, 100, -M_PI_2l, INF_P, 0 },
	TEST_c_c(casin, INF_M, -100, -M_PI_2l, INF_M, 0 },

	TEST_c_c(casin, INF_P, 0, M_PI_2l, INF_P, 0 },
	TEST_c_c(casin, INF_P, ZERO_M, M_PI_2l, INF_M, 0 },
	TEST_c_c(casin, INF_P, 0.5, M_PI_2l, INF_P, 0 },
	TEST_c_c(casin, INF_P, -0.5, M_PI_2l, INF_M, 0 },

	TEST_c_c(casin, QNAN_P, INF_P, QNAN_P, INF_P, 0 },
	TEST_c_c(casin, QNAN_P, INF_M, QNAN_P, INF_M, 0 },

	TEST_c_c(casin, 0.0, QNAN_P, 0.0, QNAN_P, 0 },
	TEST_c_c(casin, ZERO_M, QNAN_P, ZERO_M, QNAN_P, 0 },

	TEST_c_c(casin, INF_P, QNAN_P, QNAN_P, INF_P, IGNORE_ZERO_INF_SIGN },
	TEST_c_c(casin, INF_M, QNAN_P, QNAN_P, INF_P, IGNORE_ZERO_INF_SIGN },

	TEST_c_c(casin, QNAN_P, 10.5, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	TEST_c_c(casin, QNAN_P, -10.5, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },

	TEST_c_c(casin, 0.75, QNAN_P, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	TEST_c_c(casin, -0.75, QNAN_P, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },

	TEST_c_c(casin, QNAN_P, QNAN_P, QNAN_P, QNAN_P, 0 },

	TEST_c_c(casin, ZERO_P, -1.5L, ZERO_P, -1.194763217287109304111930828519090523536L, 0 },
	TEST_c_c(casin, ZERO_M, -1.5L, ZERO_M, -1.194763217287109304111930828519090523536L, 0 },
	TEST_c_c(casin, ZERO_P, -1.0L, ZERO_P, -0.8813735870195430252326093249797923090282L, 0 },
	TEST_c_c(casin, ZERO_M, -1.0L, ZERO_M, -0.8813735870195430252326093249797923090282L, 0 },
	TEST_c_c(casin, ZERO_P, -0.5L, ZERO_P, -0.4812118250596034474977589134243684231352L, 0 },
	TEST_c_c(casin, ZERO_M, -0.5L, ZERO_M, -0.4812118250596034474977589134243684231352L, 0 },
	TEST_c_c(casin, ZERO_P, 0.5L, ZERO_P, 0.4812118250596034474977589134243684231352L, 0 },
	TEST_c_c(casin, ZERO_M, 0.5L, ZERO_M, 0.4812118250596034474977589134243684231352L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, ZERO_P, 1.0L, ZERO_P, 0.8813735870195430252326093249797923090282L, 0 },
	TEST_c_c(casin, ZERO_M, 1.0L, ZERO_M, 0.8813735870195430252326093249797923090282L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, ZERO_P, 1.5L, ZERO_P, 1.194763217287109304111930828519090523536L, 0 },
	TEST_c_c(casin, ZERO_M, 1.5L, ZERO_M, 1.194763217287109304111930828519090523536L, 0|XFAIL_NATIVE_LINUX },

	TEST_c_c(casin, -1.5L, ZERO_P, -M_PI_2l, 0.9624236501192068949955178268487368462704L, 0 },
	TEST_c_c(casin, -1.5L, ZERO_M, -M_PI_2l, -0.9624236501192068949955178268487368462704L, 0 },
	TEST_c_c(casin, -1.0L, ZERO_P, -M_PI_2l, ZERO_P, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -1.0L, ZERO_M, -M_PI_2l, ZERO_M, 0 },
	TEST_c_c(casin, -0.5L, ZERO_P, -0.5235987755982988730771072305465838140329L, ZERO_P, 0|XFAIL_NATIVE_LINUXL|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casin, -0.5L, ZERO_M, -0.5235987755982988730771072305465838140329L, ZERO_M, 0 },
	TEST_c_c(casin, 0.5L, ZERO_P, 0.5235987755982988730771072305465838140329L, ZERO_P, 0|XFAIL_NATIVE_LINUXL|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casin, 0.5L, ZERO_M, 0.5235987755982988730771072305465838140329L, ZERO_M, 0 },
	TEST_c_c(casin, 1.0L, ZERO_P, M_PI_2l, ZERO_P, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 1.0L, ZERO_M, M_PI_2l, ZERO_M, 0 },
	TEST_c_c(casin, 1.5L, ZERO_P, M_PI_2l, 0.9624236501192068949955178268487368462704L, 0 },
	TEST_c_c(casin, 1.5L, ZERO_M, M_PI_2l, -0.9624236501192068949955178268487368462704L, 0 },

	TEST_c_c(casin, 0x1p50L, 1.0L, 1.570796326794895731052901991514519103193L, 3.535050620855721078027883819436720218708e1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0x1p50L, -1.0L, 1.570796326794895731052901991514519103193L, -3.535050620855721078027883819436720218708e1L, 0 },
	TEST_c_c(casin, -0x1p50L, 1.0L, -1.570796326794895731052901991514519103193L, 3.535050620855721078027883819436720218708e1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0x1p50L, -1.0L, -1.570796326794895731052901991514519103193L, -3.535050620855721078027883819436720218708e1L, 0 },
	TEST_c_c(casin, 1.0L, 0x1p50L, 8.881784197001252323389053344720723756399e-16L, 3.535050620855721078027883819436759661753e1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -1.0L, 0x1p50L, -8.881784197001252323389053344720723756399e-16L, 3.535050620855721078027883819436759661753e1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 1.0L, -0x1p50L, 8.881784197001252323389053344720723756399e-16L, -3.535050620855721078027883819436759661753e1L, 0 },
	TEST_c_c(casin, -1.0L, -0x1p50L, -8.881784197001252323389053344720723756399e-16L, -3.535050620855721078027883819436759661753e1L, 0 },
#ifndef TEST_FLOAT
	TEST_c_c(casin, 0x1p500L, 1.0L, 1.570796326794896619231321691639751442099L, 3.472667374605326000180332928505464606058e2L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0x1p500L, -1.0L, 1.570796326794896619231321691639751442099L, -3.472667374605326000180332928505464606058e2L, 0 },
	TEST_c_c(casin, -0x1p500L, 1.0L, -1.570796326794896619231321691639751442099L, 3.472667374605326000180332928505464606058e2L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0x1p500L, -1.0L, -1.570796326794896619231321691639751442099L, -3.472667374605326000180332928505464606058e2L, 0 },
	TEST_c_c(casin, 1.0L, 0x1p500L, 3.054936363499604682051979393213617699789e-151L, 3.472667374605326000180332928505464606058e2L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -1.0L, 0x1p500L, -3.054936363499604682051979393213617699789e-151L, 3.472667374605326000180332928505464606058e2L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 1.0L, -0x1p500L, 3.054936363499604682051979393213617699789e-151L, -3.472667374605326000180332928505464606058e2L, 0 },
	TEST_c_c(casin, -1.0L, -0x1p500L, -3.054936363499604682051979393213617699789e-151L, -3.472667374605326000180332928505464606058e2L, 0 },
#endif
#if defined TEST_LDOUBLE && LDBL_MAX_EXP >= 16384
	TEST_c_c(casin, 0x1p5000L, 1.0L, 1.570796326794896619231321691639751442099L, 3.466429049980286492395577839412341016946e3L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0x1p5000L, -1.0L, 1.570796326794896619231321691639751442099L, -3.466429049980286492395577839412341016946e3L, 0 },
	TEST_c_c(casin, -0x1p5000L, 1.0L, -1.570796326794896619231321691639751442099L, 3.466429049980286492395577839412341016946e3L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0x1p5000L, -1.0L, -1.570796326794896619231321691639751442099L, -3.466429049980286492395577839412341016946e3L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(casin, 1.0L, 0x1p5000L, 7.079811261048172892385615158694057552948e-1506L, 3.466429049980286492395577839412341016946e3L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -1.0L, 0x1p5000L, -7.079811261048172892385615158694057552948e-1506L, 3.466429049980286492395577839412341016946e3L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 1.0L, -0x1p5000L, 7.079811261048172892385615158694057552948e-1506L, -3.466429049980286492395577839412341016946e3L, 0 },
	TEST_c_c(casin, -1.0L, -0x1p5000L, -7.079811261048172892385615158694057552948e-1506L, -3.466429049980286492395577839412341016946e3L, 0 },
#endif

	TEST_c_c(casin, 0x1.fp127L, 0x1.fp127L, 7.853981633974483096156608458198757210493e-1L, 8.973081118419833726837456344608533993585e1L, 0|XFAIL_NATIVE_LINUX },
#ifndef TEST_FLOAT
	TEST_c_c(casin, 0x1.fp1023L, 0x1.fp1023L, 7.853981633974483096156608458198757210493e-1L, 7.107906849659093345062145442726115449315e2L, 0|XFAIL_NATIVE_LINUX },
#endif
#if defined TEST_LDOUBLE && LDBL_MAX_EXP >= 16384
	TEST_c_c(casin, 0x1.fp16383L, 0x1.fp16383L, 7.853981633974483096156608458198757210493e-1L, 1.135753137836666928715489992987020363057e4L, 0|XFAIL_NATIVE_LINUX },
#endif

	TEST_c_c(casin, 0x1.fp-129L, 1.5L, 1.579176199917649005841160751101628985741e-39L, 1.194763217287109304111930828519090523536L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0x1.fp-129L, -1.5L, 1.579176199917649005841160751101628985741e-39L, -1.194763217287109304111930828519090523536L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0x1.fp-129L, 1.5L, -1.579176199917649005841160751101628985741e-39L, 1.194763217287109304111930828519090523536L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0x1.fp-129L, -1.5L, -1.579176199917649005841160751101628985741e-39L, -1.194763217287109304111930828519090523536L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 1.5L, 0x1.fp-129L, 1.570796326794896619231321691639751442096L, 9.624236501192068949955178268487368462704e-1L, 0 },
	TEST_c_c(casin, -1.5L, 0x1.fp-129L, -1.570796326794896619231321691639751442096L, 9.624236501192068949955178268487368462704e-1L, 0 },
	TEST_c_c(casin, 1.5L, -0x1.fp-129L, 1.570796326794896619231321691639751442096L, -9.624236501192068949955178268487368462704e-1L, 0 },
	TEST_c_c(casin, -1.5L, -0x1.fp-129L, -1.570796326794896619231321691639751442096L, -9.624236501192068949955178268487368462704e-1L, 0 },
#ifndef TEST_FLOAT
	TEST_c_c(casin, 0x1.fp-1025L, 1.5L, 2.989196569048182929051881765490354365918e-309L, 1.194763217287109304111930828519090523536L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(casin, 0x1.fp-1025L, -1.5L, 2.989196569048182929051881765490354365918e-309L, -1.194763217287109304111930828519090523536L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(casin, -0x1.fp-1025L, 1.5L, -2.989196569048182929051881765490354365918e-309L, 1.194763217287109304111930828519090523536L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(casin, -0x1.fp-1025L, -1.5L, -2.989196569048182929051881765490354365918e-309L, -1.194763217287109304111930828519090523536L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(casin, 1.5L, 0x1.fp-1025L, 1.570796326794896619231321691639751442099L, 9.624236501192068949955178268487368462704e-1L, 0 },
	TEST_c_c(casin, -1.5L, 0x1.fp-1025L, -1.570796326794896619231321691639751442099L, 9.624236501192068949955178268487368462704e-1L, 0 },
	TEST_c_c(casin, 1.5L, -0x1.fp-1025L, 1.570796326794896619231321691639751442099L, -9.624236501192068949955178268487368462704e-1L, 0 },
	TEST_c_c(casin, -1.5L, -0x1.fp-1025L, -1.570796326794896619231321691639751442099L, -9.624236501192068949955178268487368462704e-1L, 0 },
#endif
#if defined TEST_LDOUBLE && LDBL_MIN_EXP <= -16381
	TEST_c_c(casin, 0x1.fp-16385L, 1.5L, 4.516698239814521372306784062043266700598e-4933L, 1.194763217287109304111930828519090523536L, UNDERFLOW_EXCEPTION },
	TEST_c_c(casin, 0x1.fp-16385L, -1.5L, 4.516698239814521372306784062043266700598e-4933L, -1.194763217287109304111930828519090523536L, UNDERFLOW_EXCEPTION },
	TEST_c_c(casin, -0x1.fp-16385L, 1.5L, -4.516698239814521372306784062043266700598e-4933L, 1.194763217287109304111930828519090523536L, UNDERFLOW_EXCEPTION },
	TEST_c_c(casin, -0x1.fp-16385L, -1.5L, -4.516698239814521372306784062043266700598e-4933L, -1.194763217287109304111930828519090523536L, UNDERFLOW_EXCEPTION },
	TEST_c_c(casin, 1.5L, 0x1.fp-16385L, 1.570796326794896619231321691639751442099L, 9.624236501192068949955178268487368462704e-1L, 0 },
	TEST_c_c(casin, -1.5L, 0x1.fp-16385L, -1.570796326794896619231321691639751442099L, 9.624236501192068949955178268487368462704e-1L, 0 },
	TEST_c_c(casin, 1.5L, -0x1.fp-16385L, 1.570796326794896619231321691639751442099L, -9.624236501192068949955178268487368462704e-1L, 0 },
	TEST_c_c(casin, -1.5L, -0x1.fp-16385L, -1.570796326794896619231321691639751442099L, -9.624236501192068949955178268487368462704e-1L, 0 },
#endif

	TEST_c_c(casin, 0.5L, 1.0L, 3.494390628572132936274118260753699527325e-1L, 9.261330313501824245501244453057873152694e-1L, 0 },
	TEST_c_c(casin, 0.5L, -1.0L, 3.494390628572132936274118260753699527325e-1L, -9.261330313501824245501244453057873152694e-1L, 0 },
	TEST_c_c(casin, -0.5L, 1.0L, -3.494390628572132936274118260753699527325e-1L, 9.261330313501824245501244453057873152694e-1L, 0 },
	TEST_c_c(casin, -0.5L, -1.0L, -3.494390628572132936274118260753699527325e-1L, -9.261330313501824245501244453057873152694e-1L, 0 },
	TEST_c_c(casin, 1.0L, 0.5L, 8.959074812088902390666567243275770102229e-1L, 7.328576759736452608886724437653071523305e-1L, 0 },
	TEST_c_c(casin, -1.0L, 0.5L, -8.959074812088902390666567243275770102229e-1L, 7.328576759736452608886724437653071523305e-1L, 0 },
	TEST_c_c(casin, 1.0L, -0.5L, 8.959074812088902390666567243275770102229e-1L, -7.328576759736452608886724437653071523305e-1L, 0 },
	TEST_c_c(casin, -1.0L, -0.5L, -8.959074812088902390666567243275770102229e-1L, -7.328576759736452608886724437653071523305e-1L, 0 },
	TEST_c_c(casin, 0.25L, 1.0L, 1.763024327769669304186785666360901026468e-1L, 8.924633639033482359562124741744951972772e-1L, 0 },
	TEST_c_c(casin, 0.25L, -1.0L, 1.763024327769669304186785666360901026468e-1L, -8.924633639033482359562124741744951972772e-1L, 0 },
	TEST_c_c(casin, -0.25L, 1.0L, -1.763024327769669304186785666360901026468e-1L, 8.924633639033482359562124741744951972772e-1L, 0 },
	TEST_c_c(casin, -0.25L, -1.0L, -1.763024327769669304186785666360901026468e-1L, -8.924633639033482359562124741744951972772e-1L, 0 },
	TEST_c_c(casin, 1.0L, 0.25L, 1.081751996523816326311037318425097434186L, 5.097911466811016354623559941115413499164e-1L, 0 },
	TEST_c_c(casin, -1.0L, 0.25L, -1.081751996523816326311037318425097434186L, 5.097911466811016354623559941115413499164e-1L, 0 },
	TEST_c_c(casin, 1.0L, -0.25L, 1.081751996523816326311037318425097434186L, -5.097911466811016354623559941115413499164e-1L, 0 },
	TEST_c_c(casin, -1.0L, -0.25L, -1.081751996523816326311037318425097434186L, -5.097911466811016354623559941115413499164e-1L, 0 },
	TEST_c_c(casin, 0x1.fp-10L, 1.0L, 1.337909359557740912558349531052239112857e-3L, 8.813742198809567991336704287826445879025e-1L, 0 },
	TEST_c_c(casin, 0x1.fp-10L, -1.0L, 1.337909359557740912558349531052239112857e-3L, -8.813742198809567991336704287826445879025e-1L, 0 },
	TEST_c_c(casin, -0x1.fp-10L, 1.0L, -1.337909359557740912558349531052239112857e-3L, 8.813742198809567991336704287826445879025e-1L, 0 },
	TEST_c_c(casin, -0x1.fp-10L, -1.0L, -1.337909359557740912558349531052239112857e-3L, -8.813742198809567991336704287826445879025e-1L, 0 },
	TEST_c_c(casin, 1.0L, 0x1.fp-10L, 1.527305029163877791518741192097931722508L, 4.350501469856803800217957402220976497152e-2L, 0 },
	TEST_c_c(casin, -1.0L, 0x1.fp-10L, -1.527305029163877791518741192097931722508L, 4.350501469856803800217957402220976497152e-2L, 0 },
	TEST_c_c(casin, 1.0L, -0x1.fp-10L, 1.527305029163877791518741192097931722508L, -4.350501469856803800217957402220976497152e-2L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casin, -1.0L, -0x1.fp-10L, -1.527305029163877791518741192097931722508L, -4.350501469856803800217957402220976497152e-2L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casin, 0x1.fp-30L, 1.0L, 1.275929984216518540252717485007112529021e-9L, 8.813735870195430258081932989769495326854e-1L, 0 },
	TEST_c_c(casin, 0x1.fp-30L, -1.0L, 1.275929984216518540252717485007112529021e-9L, -8.813735870195430258081932989769495326854e-1L, 0 },
	TEST_c_c(casin, -0x1.fp-30L, 1.0L, -1.275929984216518540252717485007112529021e-9L, 8.813735870195430258081932989769495326854e-1L, 0 },
	TEST_c_c(casin, -0x1.fp-30L, -1.0L, -1.275929984216518540252717485007112529021e-9L, -8.813735870195430258081932989769495326854e-1L, 0 },
	TEST_c_c(casin, 1.0L, 0x1.fp-30L, 1.570753848123921942730162693731872690232L, 4.247867098745151888768727039216644758847e-5L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casin, -1.0L, 0x1.fp-30L, -1.570753848123921942730162693731872690232L, 4.247867098745151888768727039216644758847e-5L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casin, 1.0L, -0x1.fp-30L, 1.570753848123921942730162693731872690232L, -4.247867098745151888768727039216644758847e-5L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casin, -1.0L, -0x1.fp-30L, -1.570753848123921942730162693731872690232L, -4.247867098745151888768727039216644758847e-5L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casin, 0x1.fp-100L, 1.0L, 1.080754735021050612990719608916167354321e-30L, 8.813735870195430252326093249797923090282e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0x1.fp-100L, -1.0L, 1.080754735021050612990719608916167354321e-30L, -8.813735870195430252326093249797923090282e-1L, 0 },
	TEST_c_c(casin, -0x1.fp-100L, 1.0L, -1.080754735021050612990719608916167354321e-30L, 8.813735870195430252326093249797923090282e-1L, 0 },
	TEST_c_c(casin, -0x1.fp-100L, -1.0L, -1.080754735021050612990719608916167354321e-30L, -8.813735870195430252326093249797923090282e-1L, 0 },
	TEST_c_c(casin, 1.0L, 0x1.fp-100L, 1.570796326794895382939283431378862777584L, 1.236292038260260888664514866457202186027e-15L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -1.0L, 0x1.fp-100L, -1.570796326794895382939283431378862777584L, 1.236292038260260888664514866457202186027e-15L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 1.0L, -0x1.fp-100L, 1.570796326794895382939283431378862777584L, -1.236292038260260888664514866457202186027e-15L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -1.0L, -0x1.fp-100L, -1.570796326794895382939283431378862777584L, -1.236292038260260888664514866457202186027e-15L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0x1.fp-129L, 1.0L, 2.013062564695348242280482517399205554874e-39L, 8.813735870195430252326093249797923090282e-1L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casin, 0x1.fp-129L, -1.0L, 2.013062564695348242280482517399205554874e-39L, -8.813735870195430252326093249797923090282e-1L, UNDERFLOW_EXCEPTION_FLOAT },
	TEST_c_c(casin, -0x1.fp-129L, 1.0L, -2.013062564695348242280482517399205554874e-39L, 8.813735870195430252326093249797923090282e-1L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casin, -0x1.fp-129L, -1.0L, -2.013062564695348242280482517399205554874e-39L, -8.813735870195430252326093249797923090282e-1L, UNDERFLOW_EXCEPTION_FLOAT },
	TEST_c_c(casin, 1.0L, 0x1.fp-129L, 1.570796326794896619177965338869929107115L, 5.335635276982233498398987585285818977933e-20L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -1.0L, 0x1.fp-129L, -1.570796326794896619177965338869929107115L, 5.335635276982233498398987585285818977933e-20L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 1.0L, -0x1.fp-129L, 1.570796326794896619177965338869929107115L, -5.335635276982233498398987585285818977933e-20L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -1.0L, -0x1.fp-129L, -1.570796326794896619177965338869929107115L, -5.335635276982233498398987585285818977933e-20L, 0|XFAIL_NATIVE_LINUX },
#ifndef TEST_FLOAT
	TEST_c_c(casin, 0x1.fp-1000L, 1.0L, 1.278589251976747242280879285935084814093e-301L, 8.813735870195430252326093249797923090282e-1L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM },
	TEST_c_c(casin, 0x1.fp-1000L, -1.0L, 1.278589251976747242280879285935084814093e-301L, -8.813735870195430252326093249797923090282e-1L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM },
	TEST_c_c(casin, -0x1.fp-1000L, 1.0L, -1.278589251976747242280879285935084814093e-301L, 8.813735870195430252326093249797923090282e-1L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM },
	TEST_c_c(casin, -0x1.fp-1000L, -1.0L, -1.278589251976747242280879285935084814093e-301L, -8.813735870195430252326093249797923090282e-1L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM },
	TEST_c_c(casin, 1.0L, 0x1.fp-1000L, 1.570796326794896619231321691639751442099L, 4.252291453851660175550490409247739011867e-151L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -1.0L, 0x1.fp-1000L, -1.570796326794896619231321691639751442099L, 4.252291453851660175550490409247739011867e-151L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 1.0L, -0x1.fp-1000L, 1.570796326794896619231321691639751442099L, -4.252291453851660175550490409247739011867e-151L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -1.0L, -0x1.fp-1000L, -1.570796326794896619231321691639751442099L, -4.252291453851660175550490409247739011867e-151L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0x1.fp-1025L, 1.0L, 3.810492908885321743133304375216617626230e-309L, 8.813735870195430252326093249797923090282e-1L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(casin, 0x1.fp-1025L, -1.0L, 3.810492908885321743133304375216617626230e-309L, -8.813735870195430252326093249797923090282e-1L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(casin, -0x1.fp-1025L, 1.0L, -3.810492908885321743133304375216617626230e-309L, 8.813735870195430252326093249797923090282e-1L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(casin, -0x1.fp-1025L, -1.0L, -3.810492908885321743133304375216617626230e-309L, -8.813735870195430252326093249797923090282e-1L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(casin, 1.0L, 0x1.fp-1025L, 1.570796326794896619231321691639751442099L, 7.340879205566679497036857179189356754017e-155L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -1.0L, 0x1.fp-1025L, -1.570796326794896619231321691639751442099L, 7.340879205566679497036857179189356754017e-155L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 1.0L, -0x1.fp-1025L, 1.570796326794896619231321691639751442099L, -7.340879205566679497036857179189356754017e-155L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -1.0L, -0x1.fp-1025L, -1.570796326794896619231321691639751442099L, -7.340879205566679497036857179189356754017e-155L, 0|XFAIL_NATIVE_LINUX },
#endif
#if defined TEST_LDOUBLE && LDBL_MIN_EXP <= -16381
	TEST_c_c(casin, 0x1.fp-10000L, 1.0L, 6.867047849047171855399183659351043150871e-3011L, 8.813735870195430252326093249797923090282e-1L, 0 },
	TEST_c_c(casin, 0x1.fp-10000L, -1.0L, 6.867047849047171855399183659351043150871e-3011L, -8.813735870195430252326093249797923090282e-1L, 0 },
	TEST_c_c(casin, -0x1.fp-10000L, 1.0L, -6.867047849047171855399183659351043150871e-3011L, 8.813735870195430252326093249797923090282e-1L, 0 },
	TEST_c_c(casin, -0x1.fp-10000L, -1.0L, -6.867047849047171855399183659351043150871e-3011L, -8.813735870195430252326093249797923090282e-1L, 0 },
	TEST_c_c(casin, 1.0L, 0x1.fp-10000L, 1.570796326794896619231321691639751442099L, 9.854680208706673586644342922051388714633e-1506L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -1.0L, 0x1.fp-10000L, -1.570796326794896619231321691639751442099L, 9.854680208706673586644342922051388714633e-1506L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 1.0L, -0x1.fp-10000L, 1.570796326794896619231321691639751442099L, -9.854680208706673586644342922051388714633e-1506L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -1.0L, -0x1.fp-10000L, -1.570796326794896619231321691639751442099L, -9.854680208706673586644342922051388714633e-1506L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0x1.fp-16385L, 1.0L, 5.757683115456107044131264955348448954458e-4933L, 8.813735870195430252326093249797923090282e-1L, UNDERFLOW_EXCEPTION },
	TEST_c_c(casin, 0x1.fp-16385L, -1.0L, 5.757683115456107044131264955348448954458e-4933L, -8.813735870195430252326093249797923090282e-1L, UNDERFLOW_EXCEPTION },
	TEST_c_c(casin, -0x1.fp-16385L, 1.0L, -5.757683115456107044131264955348448954458e-4933L, 8.813735870195430252326093249797923090282e-1L, UNDERFLOW_EXCEPTION },
	TEST_c_c(casin, -0x1.fp-16385L, -1.0L, -5.757683115456107044131264955348448954458e-4933L, -8.813735870195430252326093249797923090282e-1L, UNDERFLOW_EXCEPTION },
	TEST_c_c(casin, 1.0L, 0x1.fp-16385L, 1.570796326794896619231321691639751442099L, 9.023632056840860275214893047597614177639e-2467L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -1.0L, 0x1.fp-16385L, -1.570796326794896619231321691639751442099L, 9.023632056840860275214893047597614177639e-2467L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 1.0L, -0x1.fp-16385L, 1.570796326794896619231321691639751442099L, -9.023632056840860275214893047597614177639e-2467L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -1.0L, -0x1.fp-16385L, -1.570796326794896619231321691639751442099L, -9.023632056840860275214893047597614177639e-2467L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUX },
#endif

	TEST_c_c(casin, 0x1p-23L, 0x1.000002p0L, 8.429369199749229560964789467980644296420e-8L, 8.813736713132400470205730751186547909968e-1L, 0 },
	TEST_c_c(casin, 0x1p-23L, -0x1.000002p0L, 8.429369199749229560964789467980644296420e-8L, -8.813736713132400470205730751186547909968e-1L, 0 },
	TEST_c_c(casin, -0x1p-23L, 0x1.000002p0L, -8.429369199749229560964789467980644296420e-8L, 8.813736713132400470205730751186547909968e-1L, 0 },
	TEST_c_c(casin, -0x1p-23L, -0x1.000002p0L, -8.429369199749229560964789467980644296420e-8L, -8.813736713132400470205730751186547909968e-1L, 0 },
	TEST_c_c(casin, 0x1.000002p0L, 0x1p-23L, 1.570574114956455764594481054234834678422L, 5.364668491573609633134147164031476452679e-4L, 0 },
	TEST_c_c(casin, -0x1.000002p0L, 0x1p-23L, -1.570574114956455764594481054234834678422L, 5.364668491573609633134147164031476452679e-4L, 0 },
	TEST_c_c(casin, 0x1.000002p0L, -0x1p-23L, 1.570574114956455764594481054234834678422L, -5.364668491573609633134147164031476452679e-4L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casin, -0x1.000002p0L, -0x1p-23L, -1.570574114956455764594481054234834678422L, -5.364668491573609633134147164031476452679e-4L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casin, 0x1.fp-129L, 0x1.000002p0L, 2.013062444707472738895109955455676357057e-39L, 8.813736713132375348727889167749389235161e-1L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casin, 0x1.fp-129L, -0x1.000002p0L, 2.013062444707472738895109955455676357057e-39L, -8.813736713132375348727889167749389235161e-1L, UNDERFLOW_EXCEPTION_FLOAT },
	TEST_c_c(casin, -0x1.fp-129L, 0x1.000002p0L, -2.013062444707472738895109955455676357057e-39L, 8.813736713132375348727889167749389235161e-1L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casin, -0x1.fp-129L, -0x1.000002p0L, -2.013062444707472738895109955455676357057e-39L, -8.813736713132375348727889167749389235161e-1L, UNDERFLOW_EXCEPTION_FLOAT },
	TEST_c_c(casin, 0x1.000002p0L, 0x1.fp-129L, 1.570796326794896619231321691639751436268L, 4.882812451493617206486388134172712975070e-4L, 0 },
	TEST_c_c(casin, -0x1.000002p0L, 0x1.fp-129L, -1.570796326794896619231321691639751436268L, 4.882812451493617206486388134172712975070e-4L, 0 },
	TEST_c_c(casin, 0x1.000002p0L, -0x1.fp-129L, 1.570796326794896619231321691639751436268L, -4.882812451493617206486388134172712975070e-4L, 0 },
	TEST_c_c(casin, -0x1.000002p0L, -0x1.fp-129L, -1.570796326794896619231321691639751436268L, -4.882812451493617206486388134172712975070e-4L, 0 },
	TEST_c_c(casin, 0.0L, 0x1.000002p0L, 0.0L, 8.813736713132375348727889167749389235161e-1L, 0 },
	TEST_c_c(casin, 0.0L, -0x1.000002p0L, 0.0L, -8.813736713132375348727889167749389235161e-1L, 0 },
	TEST_c_c(casin, -0.0L, 0x1.000002p0L, -0.0L, 8.813736713132375348727889167749389235161e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0.0L, -0x1.000002p0L, -0.0L, -8.813736713132375348727889167749389235161e-1L, 0 },
	TEST_c_c(casin, 0x1.000002p0L, 0.0L, 1.570796326794896619231321691639751442099L, 4.882812451493617206486388134172712975070e-4L, 0 },
	TEST_c_c(casin, -0x1.000002p0L, 0.0L, -1.570796326794896619231321691639751442099L, 4.882812451493617206486388134172712975070e-4L, 0 },
	TEST_c_c(casin, 0x1.000002p0L, -0.0L, 1.570796326794896619231321691639751442099L, -4.882812451493617206486388134172712975070e-4L, 0 },
	TEST_c_c(casin, -0x1.000002p0L, -0.0L, -1.570796326794896619231321691639751442099L, -4.882812451493617206486388134172712975070e-4L, 0 },
#ifndef TEST_FLOAT
	TEST_c_c(casin, 0x1p-52L, 0x1.0000000000001p0L, 1.570092458683774885078102529858632363236e-16L, 8.813735870195431822418551933572982483664e-1L, 0 },
	TEST_c_c(casin, 0x1p-52L, -0x1.0000000000001p0L, 1.570092458683774885078102529858632363236e-16L, -8.813735870195431822418551933572982483664e-1L, 0 },
	TEST_c_c(casin, -0x1p-52L, 0x1.0000000000001p0L, -1.570092458683774885078102529858632363236e-16L, 8.813735870195431822418551933572982483664e-1L, 0 },
	TEST_c_c(casin, -0x1p-52L, -0x1.0000000000001p0L, -1.570092458683774885078102529858632363236e-16L, -8.813735870195431822418551933572982483664e-1L, 0 },
	TEST_c_c(casin, 0x1.0000000000001p0L, 0x1p-52L, 1.570796317204594913251280305810847349436L, 2.315303644582684770975188768022139415020e-8L, 0 },
	TEST_c_c(casin, -0x1.0000000000001p0L, 0x1p-52L, -1.570796317204594913251280305810847349436L, 2.315303644582684770975188768022139415020e-8L, 0 },
	TEST_c_c(casin, 0x1.0000000000001p0L, -0x1p-52L, 1.570796317204594913251280305810847349436L, -2.315303644582684770975188768022139415020e-8L, 0 },
	TEST_c_c(casin, -0x1.0000000000001p0L, -0x1p-52L, -1.570796317204594913251280305810847349436L, -2.315303644582684770975188768022139415020e-8L, 0 },
	TEST_c_c(casin, 0x1.fp-1025L, 0x1.0000000000001p0L, 3.810492908885321320083608113679347200012e-309L, 8.813735870195431822418551933572895326024e-1L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(casin, 0x1.fp-1025L, -0x1.0000000000001p0L, 3.810492908885321320083608113679347200012e-309L, -8.813735870195431822418551933572895326024e-1L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(casin, -0x1.fp-1025L, 0x1.0000000000001p0L, -3.810492908885321320083608113679347200012e-309L, 8.813735870195431822418551933572895326024e-1L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(casin, -0x1.fp-1025L, -0x1.0000000000001p0L, -3.810492908885321320083608113679347200012e-309L, -8.813735870195431822418551933572895326024e-1L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(casin, 0x1.0000000000001p0L, 0x1.fp-1025L, 1.570796326794896619231321691639751442099L, 2.107342425544701550354780375182800088393e-8L, 0 },
	TEST_c_c(casin, -0x1.0000000000001p0L, 0x1.fp-1025L, -1.570796326794896619231321691639751442099L, 2.107342425544701550354780375182800088393e-8L, 0 },
	TEST_c_c(casin, 0x1.0000000000001p0L, -0x1.fp-1025L, 1.570796326794896619231321691639751442099L, -2.107342425544701550354780375182800088393e-8L, 0 },
	TEST_c_c(casin, -0x1.0000000000001p0L, -0x1.fp-1025L, -1.570796326794896619231321691639751442099L, -2.107342425544701550354780375182800088393e-8L, 0 },
	TEST_c_c(casin, 0.0L, 0x1.0000000000001p0L, 0.0L, 8.813735870195431822418551933572895326024e-1L, 0 },
	TEST_c_c(casin, 0.0L, -0x1.0000000000001p0L, 0.0L, -8.813735870195431822418551933572895326024e-1L, 0 },
	TEST_c_c(casin, -0.0L, 0x1.0000000000001p0L, -0.0L, 8.813735870195431822418551933572895326024e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0.0L, -0x1.0000000000001p0L, -0.0L, -8.813735870195431822418551933572895326024e-1L, 0 },
	TEST_c_c(casin, 0x1.0000000000001p0L, 0.0L, 1.570796326794896619231321691639751442099L, 2.107342425544701550354780375182800088393e-8L, 0 },
	TEST_c_c(casin, -0x1.0000000000001p0L, 0.0L, -1.570796326794896619231321691639751442099L, 2.107342425544701550354780375182800088393e-8L, 0 },
	TEST_c_c(casin, 0x1.0000000000001p0L, -0.0L, 1.570796326794896619231321691639751442099L, -2.107342425544701550354780375182800088393e-8L, 0 },
	TEST_c_c(casin, -0x1.0000000000001p0L, -0.0L, -1.570796326794896619231321691639751442099L, -2.107342425544701550354780375182800088393e-8L, 0 },
#endif
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	TEST_c_c(casin, 0x1p-63L, 0x1.0000000000000002p0L, 7.666467083416870406778649849746878368519e-20L, 8.813735870195430253092739958139610131001e-1L, 0 },
	TEST_c_c(casin, 0x1p-63L, -0x1.0000000000000002p0L, 7.666467083416870406778649849746878368519e-20L, -8.813735870195430253092739958139610131001e-1L, 0 },
	TEST_c_c(casin, -0x1p-63L, 0x1.0000000000000002p0L, -7.666467083416870406778649849746878368519e-20L, 8.813735870195430253092739958139610131001e-1L, 0 },
	TEST_c_c(casin, -0x1p-63L, -0x1.0000000000000002p0L, -7.666467083416870406778649849746878368519e-20L, -8.813735870195430253092739958139610131001e-1L, 0 },
	TEST_c_c(casin, 0x1.0000000000000002p0L, 0x1p-63L, 1.570796326582978888921215348380499122131L, 5.116146586219826555037807251857670783420e-10L, 0 },
	TEST_c_c(casin, -0x1.0000000000000002p0L, 0x1p-63L, -1.570796326582978888921215348380499122131L, 5.116146586219826555037807251857670783420e-10L, 0 },
	TEST_c_c(casin, 0x1.0000000000000002p0L, -0x1p-63L, 1.570796326582978888921215348380499122131L, -5.116146586219826555037807251857670783420e-10L, 0 },
	TEST_c_c(casin, -0x1.0000000000000002p0L, -0x1p-63L, -1.570796326582978888921215348380499122131L, -5.116146586219826555037807251857670783420e-10L, 0 },
# if LDBL_MIN_EXP <= -16381
	TEST_c_c(casin, 0x1.fp-16385L, 0x1.0000000000000002p0L, 5.757683115456107043819140328235418018963e-4933L, 8.813735870195430253092739958139610130980e-1L, UNDERFLOW_EXCEPTION },
	TEST_c_c(casin, 0x1.fp-16385L, -0x1.0000000000000002p0L, 5.757683115456107043819140328235418018963e-4933L, -8.813735870195430253092739958139610130980e-1L, UNDERFLOW_EXCEPTION },
	TEST_c_c(casin, -0x1.fp-16385L, 0x1.0000000000000002p0L, -5.757683115456107043819140328235418018963e-4933L, 8.813735870195430253092739958139610130980e-1L, UNDERFLOW_EXCEPTION },
	TEST_c_c(casin, -0x1.fp-16385L, -0x1.0000000000000002p0L, -5.757683115456107043819140328235418018963e-4933L, -8.813735870195430253092739958139610130980e-1L, UNDERFLOW_EXCEPTION },
	TEST_c_c(casin, 0x1.0000000000000002p0L, 0x1.fp-16385L, 1.570796326794896619231321691639751442099L, 4.656612873077392578082927418388212703712e-10L, 0 },
	TEST_c_c(casin, -0x1.0000000000000002p0L, 0x1.fp-16385L, -1.570796326794896619231321691639751442099L, 4.656612873077392578082927418388212703712e-10L, 0 },
	TEST_c_c(casin, 0x1.0000000000000002p0L, -0x1.fp-16385L, 1.570796326794896619231321691639751442099L, -4.656612873077392578082927418388212703712e-10L, 0 },
	TEST_c_c(casin, -0x1.0000000000000002p0L, -0x1.fp-16385L, -1.570796326794896619231321691639751442099L, -4.656612873077392578082927418388212703712e-10L, 0 },
# endif
	TEST_c_c(casin, 0.0L, 0x1.0000000000000002p0L, 0.0L, 8.813735870195430253092739958139610130980e-1L, 0 },
	TEST_c_c(casin, 0.0L, -0x1.0000000000000002p0L, 0.0L, -8.813735870195430253092739958139610130980e-1L, 0 },
	TEST_c_c(casin, -0.0L, 0x1.0000000000000002p0L, -0.0L, 8.813735870195430253092739958139610130980e-1L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(casin, -0.0L, -0x1.0000000000000002p0L, -0.0L, -8.813735870195430253092739958139610130980e-1L, 0 },
	TEST_c_c(casin, 0x1.0000000000000002p0L, 0.0L, 1.570796326794896619231321691639751442099L, 4.656612873077392578082927418388212703712e-10L, 0 },
	TEST_c_c(casin, -0x1.0000000000000002p0L, 0.0L, -1.570796326794896619231321691639751442099L, 4.656612873077392578082927418388212703712e-10L, 0 },
	TEST_c_c(casin, 0x1.0000000000000002p0L, -0.0L, 1.570796326794896619231321691639751442099L, -4.656612873077392578082927418388212703712e-10L, 0 },
	TEST_c_c(casin, -0x1.0000000000000002p0L, -0.0L, -1.570796326794896619231321691639751442099L, -4.656612873077392578082927418388212703712e-10L, 0 },
#endif
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 106
	TEST_c_c(casin, 0x1p-106L, 0x1.000000000000000000000000008p0L, 8.715763992105246878957416200936726072500e-33L, 8.813735870195430252326093249798097405561e-1L, 0 },
	TEST_c_c(casin, 0x1p-106L, -0x1.000000000000000000000000008p0L, 8.715763992105246878957416200936726072500e-33L, -8.813735870195430252326093249798097405561e-1L, 0 },
	TEST_c_c(casin, -0x1p-106L, 0x1.000000000000000000000000008p0L, -8.715763992105246878957416200936726072500e-33L, 8.813735870195430252326093249798097405561e-1L, 0 },
	TEST_c_c(casin, -0x1p-106L, -0x1.000000000000000000000000008p0L, -8.715763992105246878957416200936726072500e-33L, -8.813735870195430252326093249798097405561e-1L, 0 },
	TEST_c_c(casin, 0x1.000000000000000000000000008p0L, 0x1p-106L, 1.570796326794896565289107467733682961928L, 2.285028863093221674154232933662774454211e-16L, 0 },
	TEST_c_c(casin, -0x1.000000000000000000000000008p0L, 0x1p-106L, -1.570796326794896565289107467733682961928L, 2.285028863093221674154232933662774454211e-16L, 0 },
	TEST_c_c(casin, 0x1.000000000000000000000000008p0L, -0x1p-106L, 1.570796326794896565289107467733682961928L, -2.285028863093221674154232933662774454211e-16L, 0 },
	TEST_c_c(casin, -0x1.000000000000000000000000008p0L, -0x1p-106L, -1.570796326794896565289107467733682961928L, -2.285028863093221674154232933662774454211e-16L, 0 },
	TEST_c_c(casin, 0x1.fp-1025L, 0x1.000000000000000000000000008p0L, 3.810492908885321743133304375216570658278e-309L, 8.813735870195430252326093249798097405561e-1L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(casin, 0x1.fp-1025L, -0x1.000000000000000000000000008p0L, 3.810492908885321743133304375216570658278e-309L, -8.813735870195430252326093249798097405561e-1L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(casin, -0x1.fp-1025L, 0x1.000000000000000000000000008p0L, -3.810492908885321743133304375216570658278e-309L, 8.813735870195430252326093249798097405561e-1L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(casin, -0x1.fp-1025L, -0x1.000000000000000000000000008p0L, -3.810492908885321743133304375216570658278e-309L, -8.813735870195430252326093249798097405561e-1L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(casin, 0x1.000000000000000000000000008p0L, 0x1.fp-1025L, 1.570796326794896619231321691639751442099L, 2.220446049250313080847263336181636063482e-16L, 0 },
	TEST_c_c(casin, -0x1.000000000000000000000000008p0L, 0x1.fp-1025L, -1.570796326794896619231321691639751442099L, 2.220446049250313080847263336181636063482e-16L, 0 },
	TEST_c_c(casin, 0x1.000000000000000000000000008p0L, -0x1.fp-1025L, 1.570796326794896619231321691639751442099L, -2.220446049250313080847263336181636063482e-16L, 0 },
	TEST_c_c(casin, -0x1.000000000000000000000000008p0L, -0x1.fp-1025L, -1.570796326794896619231321691639751442099L, -2.220446049250313080847263336181636063482e-16L, 0 },
	TEST_c_c(casin, 0.0L, 0x1.000000000000000000000000008p0L, 0.0L, 8.813735870195430252326093249798097405561e-1L, 0 },
	TEST_c_c(casin, 0.0L, -0x1.000000000000000000000000008p0L, 0.0L, -8.813735870195430252326093249798097405561e-1L, 0 },
	TEST_c_c(casin, -0.0L, 0x1.000000000000000000000000008p0L, -0.0L, 8.813735870195430252326093249798097405561e-1L, 0 },
	TEST_c_c(casin, -0.0L, -0x1.000000000000000000000000008p0L, -0.0L, -8.813735870195430252326093249798097405561e-1L, 0 },
	TEST_c_c(casin, 0x1.000000000000000000000000008p0L, 0.0L, 1.570796326794896619231321691639751442099L, 2.220446049250313080847263336181636063482e-16L, 0 },
	TEST_c_c(casin, -0x1.000000000000000000000000008p0L, 0.0L, -1.570796326794896619231321691639751442099L, 2.220446049250313080847263336181636063482e-16L, 0 },
	TEST_c_c(casin, 0x1.000000000000000000000000008p0L, -0.0L, 1.570796326794896619231321691639751442099L, -2.220446049250313080847263336181636063482e-16L, 0 },
	TEST_c_c(casin, -0x1.000000000000000000000000008p0L, -0.0L, -1.570796326794896619231321691639751442099L, -2.220446049250313080847263336181636063482e-16L, 0 },
#endif
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 113
	TEST_c_c(casin, 0x1p-113L, 0x1.0000000000000000000000000001p0L, 6.809190618832224124185481406981900518193e-35L, 8.813735870195430252326093249797924452120e-1L, 0 },
	TEST_c_c(casin, 0x1p-113L, -0x1.0000000000000000000000000001p0L, 6.809190618832224124185481406981900518193e-35L, -8.813735870195430252326093249797924452120e-1L, 0 },
	TEST_c_c(casin, -0x1p-113L, 0x1.0000000000000000000000000001p0L, -6.809190618832224124185481406981900518193e-35L, 8.813735870195430252326093249797924452120e-1L, 0 },
	TEST_c_c(casin, -0x1p-113L, -0x1.0000000000000000000000000001p0L, -6.809190618832224124185481406981900518193e-35L, -8.813735870195430252326093249797924452120e-1L, 0 },
	TEST_c_c(casin, 0x1.0000000000000000000000000001p0L, 0x1p-113L, 1.570796326794896614463458507897073960405L, 2.019699255375255198156433710951064632386e-17L, 0 },
	TEST_c_c(casin, -0x1.0000000000000000000000000001p0L, 0x1p-113L, -1.570796326794896614463458507897073960405L, 2.019699255375255198156433710951064632386e-17L, 0 },
	TEST_c_c(casin, 0x1.0000000000000000000000000001p0L, -0x1p-113L, 1.570796326794896614463458507897073960405L, -2.019699255375255198156433710951064632386e-17L, 0 },
	TEST_c_c(casin, -0x1.0000000000000000000000000001p0L, -0x1p-113L, -1.570796326794896614463458507897073960405L, -2.019699255375255198156433710951064632386e-17L, 0 },
	TEST_c_c(casin, 0x1.fp-16385L, 0x1.0000000000000000000000000001p0L, 5.757683115456107044131264955348448400014e-4933L, 8.813735870195430252326093249797924452120e-1L, UNDERFLOW_EXCEPTION },
	TEST_c_c(casin, 0x1.fp-16385L, -0x1.0000000000000000000000000001p0L, 5.757683115456107044131264955348448400014e-4933L, -8.813735870195430252326093249797924452120e-1L, UNDERFLOW_EXCEPTION },
	TEST_c_c(casin, -0x1.fp-16385L, 0x1.0000000000000000000000000001p0L, -5.757683115456107044131264955348448400014e-4933L, 8.813735870195430252326093249797924452120e-1L, UNDERFLOW_EXCEPTION },
	TEST_c_c(casin, -0x1.fp-16385L, -0x1.0000000000000000000000000001p0L, -5.757683115456107044131264955348448400014e-4933L, -8.813735870195430252326093249797924452120e-1L, UNDERFLOW_EXCEPTION },
	TEST_c_c(casin, 0x1.0000000000000000000000000001p0L, 0x1.fp-16385L, 1.570796326794896619231321691639751442099L, 1.962615573354718824241727964954454332780e-17L, 0 },
	TEST_c_c(casin, -0x1.0000000000000000000000000001p0L, 0x1.fp-16385L, -1.570796326794896619231321691639751442099L, 1.962615573354718824241727964954454332780e-17L, 0 },
	TEST_c_c(casin, 0x1.0000000000000000000000000001p0L, -0x1.fp-16385L, 1.570796326794896619231321691639751442099L, -1.962615573354718824241727964954454332780e-17L, 0 },
	TEST_c_c(casin, -0x1.0000000000000000000000000001p0L, -0x1.fp-16385L, -1.570796326794896619231321691639751442099L, -1.962615573354718824241727964954454332780e-17L, 0 },
	TEST_c_c(casin, 0.0L, 0x1.0000000000000000000000000001p0L, 0.0L, 8.813735870195430252326093249797924452120e-1L, 0 },
	TEST_c_c(casin, 0.0L, -0x1.0000000000000000000000000001p0L, 0.0L, -8.813735870195430252326093249797924452120e-1L, 0 },
	TEST_c_c(casin, -0.0L, 0x1.0000000000000000000000000001p0L, -0.0L, 8.813735870195430252326093249797924452120e-1L, 0 },
	TEST_c_c(casin, -0.0L, -0x1.0000000000000000000000000001p0L, -0.0L, -8.813735870195430252326093249797924452120e-1L, 0 },
	TEST_c_c(casin, 0x1.0000000000000000000000000001p0L, 0.0L, 1.570796326794896619231321691639751442099L, 1.962615573354718824241727964954454332780e-17L, 0 },
	TEST_c_c(casin, -0x1.0000000000000000000000000001p0L, 0.0L, -1.570796326794896619231321691639751442099L, 1.962615573354718824241727964954454332780e-17L, 0 },
	TEST_c_c(casin, 0x1.0000000000000000000000000001p0L, -0.0L, 1.570796326794896619231321691639751442099L, -1.962615573354718824241727964954454332780e-17L, 0 },
	TEST_c_c(casin, -0x1.0000000000000000000000000001p0L, -0.0L, -1.570796326794896619231321691639751442099L, -1.962615573354718824241727964954454332780e-17L, 0 },
#endif

	TEST_c_c(casin, 0x1p-23L, 0x0.ffffffp0L, 8.429369953393598499000760938112968755257e-8L, 8.813735448726963984495965873956465777250e-1L, 0 },
	TEST_c_c(casin, 0x1p-23L, -0x0.ffffffp0L, 8.429369953393598499000760938112968755257e-8L, -8.813735448726963984495965873956465777250e-1L, 0 },
	TEST_c_c(casin, -0x1p-23L, 0x0.ffffffp0L, -8.429369953393598499000760938112968755257e-8L, 8.813735448726963984495965873956465777250e-1L, 0 },
	TEST_c_c(casin, -0x1p-23L, -0x0.ffffffp0L, -8.429369953393598499000760938112968755257e-8L, -8.813735448726963984495965873956465777250e-1L, 0 },
	TEST_c_c(casin, 0x0.ffffffp0L, 0x1p-23L, 1.570357140408705570520377172865353621698L, 2.714321200917194650737217746780928423385e-4L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casin, -0x0.ffffffp0L, 0x1p-23L, -1.570357140408705570520377172865353621698L, 2.714321200917194650737217746780928423385e-4L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casin, 0x0.ffffffp0L, -0x1p-23L, 1.570357140408705570520377172865353621698L, -2.714321200917194650737217746780928423385e-4L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casin, -0x0.ffffffp0L, -0x1p-23L, -1.570357140408705570520377172865353621698L, -2.714321200917194650737217746780928423385e-4L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casin, 0x1.fp-129L, 0x0.ffffffp0L, 2.013062624689288675911339929224634593425e-39L, 8.813735448726938863015878255140556727969e-1L, UNDERFLOW_EXCEPTION_FLOAT },
	TEST_c_c(casin, 0x1.fp-129L, -0x0.ffffffp0L, 2.013062624689288675911339929224634593425e-39L, -8.813735448726938863015878255140556727969e-1L, UNDERFLOW_EXCEPTION_FLOAT },
	TEST_c_c(casin, -0x1.fp-129L, 0x0.ffffffp0L, -2.013062624689288675911339929224634593425e-39L, 8.813735448726938863015878255140556727969e-1L, UNDERFLOW_EXCEPTION_FLOAT },
	TEST_c_c(casin, -0x1.fp-129L, -0x0.ffffffp0L, -2.013062624689288675911339929224634593425e-39L, -8.813735448726938863015878255140556727969e-1L, UNDERFLOW_EXCEPTION_FLOAT },
	TEST_c_c(casin, 0x0.ffffffp0L, 0x1.fp-129L, 1.570451059810180415643718442157112705601L, 8.245504387859737323891843603996428534945e-36L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0x0.ffffffp0L, 0x1.fp-129L, -1.570451059810180415643718442157112705601L, 8.245504387859737323891843603996428534945e-36L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0x0.ffffffp0L, -0x1.fp-129L, 1.570451059810180415643718442157112705601L, -8.245504387859737323891843603996428534945e-36L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0x0.ffffffp0L, -0x1.fp-129L, -1.570451059810180415643718442157112705601L, -8.245504387859737323891843603996428534945e-36L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0.0L, 0x0.ffffffp0L, 0.0L, 8.813735448726938863015878255140556727969e-1L, 0 },
	TEST_c_c(casin, 0.0L, -0x0.ffffffp0L, 0.0L, -8.813735448726938863015878255140556727969e-1L, 0 },
	TEST_c_c(casin, -0.0L, 0x0.ffffffp0L, -0.0L, 8.813735448726938863015878255140556727969e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0.0L, -0x0.ffffffp0L, -0.0L, -8.813735448726938863015878255140556727969e-1L, 0 },
	TEST_c_c(casin, 0x0.ffffffp0L, 0.0L, 1.570451059810180415643718442157112705601L, 0.0L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0x0.ffffffp0L, 0.0L, -1.570451059810180415643718442157112705601L, 0.0L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0x0.ffffffp0L, -0.0L, 1.570451059810180415643718442157112705601L, -0.0L, 0 },
	TEST_c_c(casin, -0x0.ffffffp0L, -0.0L, -1.570451059810180415643718442157112705601L, -0.0L, 0 },
	TEST_c_c(casin, 0x1p-23L, 0.5L, 1.066240299940009780479664302917201696886e-7L, 4.812118250596059896127318386463676808798e-1L, 0 },
	TEST_c_c(casin, 0x1p-23L, -0.5L, 1.066240299940009780479664302917201696886e-7L, -4.812118250596059896127318386463676808798e-1L, 0 },
	TEST_c_c(casin, -0x1p-23L, 0.5L, -1.066240299940009780479664302917201696886e-7L, 4.812118250596059896127318386463676808798e-1L, 0 },
	TEST_c_c(casin, -0x1p-23L, -0.5L, -1.066240299940009780479664302917201696886e-7L, -4.812118250596059896127318386463676808798e-1L, 0 },
	TEST_c_c(casin, 0.5L, 0x1p-23L, 5.235987755982934033165770729745469098254e-1L, 1.376510308240943236356088341381173571841e-7L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casin, -0.5L, 0x1p-23L, -5.235987755982934033165770729745469098254e-1L, 1.376510308240943236356088341381173571841e-7L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casin, 0.5L, -0x1p-23L, 5.235987755982934033165770729745469098254e-1L, -1.376510308240943236356088341381173571841e-7L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casin, -0.5L, -0x1p-23L, -5.235987755982934033165770729745469098254e-1L, -1.376510308240943236356088341381173571841e-7L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casin, 0x1.fp-129L, 0.5L, 2.546345110742945032959687790021055102355e-39L, 4.812118250596034474977589134243684231352e-1L, UNDERFLOW_EXCEPTION_FLOAT },
	TEST_c_c(casin, 0x1.fp-129L, -0.5L, 2.546345110742945032959687790021055102355e-39L, -4.812118250596034474977589134243684231352e-1L, UNDERFLOW_EXCEPTION_FLOAT },
	TEST_c_c(casin, -0x1.fp-129L, 0.5L, -2.546345110742945032959687790021055102355e-39L, 4.812118250596034474977589134243684231352e-1L, UNDERFLOW_EXCEPTION_FLOAT },
	TEST_c_c(casin, -0x1.fp-129L, -0.5L, -2.546345110742945032959687790021055102355e-39L, -4.812118250596034474977589134243684231352e-1L, UNDERFLOW_EXCEPTION_FLOAT },
	TEST_c_c(casin, 0.5L, 0x1.fp-129L, 5.235987755982988730771072305465838140329e-1L, 3.287317402534702257036015056278368274737e-39L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0.5L, 0x1.fp-129L, -5.235987755982988730771072305465838140329e-1L, 3.287317402534702257036015056278368274737e-39L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0.5L, -0x1.fp-129L, 5.235987755982988730771072305465838140329e-1L, -3.287317402534702257036015056278368274737e-39L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0.5L, -0x1.fp-129L, -5.235987755982988730771072305465838140329e-1L, -3.287317402534702257036015056278368274737e-39L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0x1p-23L, 0x1p-23L, 1.192092895507806853113684971258850504935e-7L, 1.192092895507818146886315028596704749235e-7L, 0 },
	TEST_c_c(casin, 0x1p-23L, -0x1p-23L, 1.192092895507806853113684971258850504935e-7L, -1.192092895507818146886315028596704749235e-7L, 0 },
	TEST_c_c(casin, -0x1p-23L, 0x1p-23L, -1.192092895507806853113684971258850504935e-7L, 1.192092895507818146886315028596704749235e-7L, 0 },
	TEST_c_c(casin, -0x1p-23L, -0x1p-23L, -1.192092895507806853113684971258850504935e-7L, -1.192092895507818146886315028596704749235e-7L, 0 },
	/* Bug 15319: underflow exception may be missing.  */
	TEST_c_c(casin, 0x1.fp-129L, 0x1p-23L, 2.846900380897707329917933005874691056564e-39L, 1.192092895507809676556842485683592032154e-7L, UNDERFLOW_EXCEPTION_OK_FLOAT },
	TEST_c_c(casin, 0x1.fp-129L, -0x1p-23L, 2.846900380897707329917933005874691056564e-39L, -1.192092895507809676556842485683592032154e-7L, UNDERFLOW_EXCEPTION_OK_FLOAT },
	TEST_c_c(casin, -0x1.fp-129L, 0x1p-23L, -2.846900380897707329917933005874691056564e-39L, 1.192092895507809676556842485683592032154e-7L, UNDERFLOW_EXCEPTION_OK_FLOAT },
	TEST_c_c(casin, -0x1.fp-129L, -0x1p-23L, -2.846900380897707329917933005874691056564e-39L, -1.192092895507809676556842485683592032154e-7L, UNDERFLOW_EXCEPTION_OK_FLOAT },
	TEST_c_c(casin, 0x1p-23L, 0x1.fp-129L, 1.192092895507815323443157514352519154304e-7L, 2.846900380897747786805634596726756660388e-39L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0x1p-23L, 0x1.fp-129L, -1.192092895507815323443157514352519154304e-7L, 2.846900380897747786805634596726756660388e-39L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0x1p-23L, -0x1.fp-129L, 1.192092895507815323443157514352519154304e-7L, -2.846900380897747786805634596726756660388e-39L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0x1p-23L, -0x1.fp-129L, -1.192092895507815323443157514352519154304e-7L, -2.846900380897747786805634596726756660388e-39L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0.0L, 0x1p-23L, 0.0L, 1.192092895507809676556842485683592032154e-7L, 0 },
	TEST_c_c(casin, 0.0L, -0x1p-23L, 0.0L, -1.192092895507809676556842485683592032154e-7L, 0 },
	TEST_c_c(casin, -0.0L, 0x1p-23L, -0.0L, 1.192092895507809676556842485683592032154e-7L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0.0L, -0x1p-23L, -0.0L, -1.192092895507809676556842485683592032154e-7L, 0 },
	TEST_c_c(casin, 0x1p-23L, 0.0L, 1.192092895507815323443157514352519154304e-7L, 0.0L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0x1p-23L, 0.0L, -1.192092895507815323443157514352519154304e-7L, 0.0L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0x1p-23L, -0.0L, 1.192092895507815323443157514352519154304e-7L, -0.0L, 0 },
	TEST_c_c(casin, -0x1p-23L, -0.0L, -1.192092895507815323443157514352519154304e-7L, -0.0L, 0 },
	TEST_c_c(casin, 0x1.fp-129L, 0x1.fp-129L, 2.846900380897727558361783801085126250967e-39L, 2.846900380897727558361783801085126250967e-39L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0x1.fp-129L, -0x1.fp-129L, 2.846900380897727558361783801085126250967e-39L, -2.846900380897727558361783801085126250967e-39L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0x1.fp-129L, 0x1.fp-129L, -2.846900380897727558361783801085126250967e-39L, 2.846900380897727558361783801085126250967e-39L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0x1.fp-129L, -0x1.fp-129L, -2.846900380897727558361783801085126250967e-39L, -2.846900380897727558361783801085126250967e-39L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
#ifndef TEST_FLOAT
	TEST_c_c(casin, 0x1p-52L, 0x0.fffffffffffff8p0L, 1.570092458683775146551022293016031474627e-16L, 8.813735870195429467279863907910458761820e-1L, 0 },
	TEST_c_c(casin, 0x1p-52L, -0x0.fffffffffffff8p0L, 1.570092458683775146551022293016031474627e-16L, -8.813735870195429467279863907910458761820e-1L, 0 },
	TEST_c_c(casin, -0x1p-52L, 0x0.fffffffffffff8p0L, -1.570092458683775146551022293016031474627e-16L, 8.813735870195429467279863907910458761820e-1L, 0 },
	TEST_c_c(casin, -0x1p-52L, -0x0.fffffffffffff8p0L, -1.570092458683775146551022293016031474627e-16L, -8.813735870195429467279863907910458761820e-1L, 0 },
	TEST_c_c(casin, 0x0.fffffffffffff8p0L, 0x1p-52L, 1.570796307840326780080580569360500172043L, 1.171456840272878582596796205397918831268e-8L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0x0.fffffffffffff8p0L, 0x1p-52L, -1.570796307840326780080580569360500172043L, 1.171456840272878582596796205397918831268e-8L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0x0.fffffffffffff8p0L, -0x1p-52L, 1.570796307840326780080580569360500172043L, -1.171456840272878582596796205397918831268e-8L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0x0.fffffffffffff8p0L, -0x1p-52L, -1.570796307840326780080580569360500172043L, -1.171456840272878582596796205397918831268e-8L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0x1.fp-1025L, 0x0.fffffffffffff8p0L, 3.810492908885321954658152505985270452320e-309L, 8.813735870195429467279863907910371604180e-1L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(casin, 0x1.fp-1025L, -0x0.fffffffffffff8p0L, 3.810492908885321954658152505985270452320e-309L, -8.813735870195429467279863907910371604180e-1L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(casin, -0x1.fp-1025L, 0x0.fffffffffffff8p0L, -3.810492908885321954658152505985270452320e-309L, 8.813735870195429467279863907910371604180e-1L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(casin, -0x1.fp-1025L, -0x0.fffffffffffff8p0L, -3.810492908885321954658152505985270452320e-309L, -8.813735870195429467279863907910371604180e-1L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(casin, 0x0.fffffffffffff8p0L, 0x1.fp-1025L, 1.570796311893735425383665303776316016594L, 3.616396521699973256461764099945789620604e-301L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0x0.fffffffffffff8p0L, 0x1.fp-1025L, -1.570796311893735425383665303776316016594L, 3.616396521699973256461764099945789620604e-301L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0x0.fffffffffffff8p0L, -0x1.fp-1025L, 1.570796311893735425383665303776316016594L, -3.616396521699973256461764099945789620604e-301L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0x0.fffffffffffff8p0L, -0x1.fp-1025L, -1.570796311893735425383665303776316016594L, -3.616396521699973256461764099945789620604e-301L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0.0L, 0x0.fffffffffffff8p0L, 0.0L, 8.813735870195429467279863907910371604180e-1L, 0 },
	TEST_c_c(casin, 0.0L, -0x0.fffffffffffff8p0L, 0.0L, -8.813735870195429467279863907910371604180e-1L, 0 },
	TEST_c_c(casin, -0.0L, 0x0.fffffffffffff8p0L, -0.0L, 8.813735870195429467279863907910371604180e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0.0L, -0x0.fffffffffffff8p0L, -0.0L, -8.813735870195429467279863907910371604180e-1L, 0 },
	TEST_c_c(casin, 0x0.fffffffffffff8p0L, 0.0L, 1.570796311893735425383665303776316016594L, 0.0L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0x0.fffffffffffff8p0L, 0.0L, -1.570796311893735425383665303776316016594L, 0.0L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0x0.fffffffffffff8p0L, -0.0L, 1.570796311893735425383665303776316016594L, -0.0L, 0 },
	TEST_c_c(casin, -0x0.fffffffffffff8p0L, -0.0L, -1.570796311893735425383665303776316016594L, -0.0L, 0 },
#endif
	TEST_c_c(casin, 0x1p-52L, 0.5L, 1.986027322597818397661816253158024383707e-16L, 4.812118250596034474977589134243772428682e-1L, 0 },
	TEST_c_c(casin, 0x1p-52L, -0.5L, 1.986027322597818397661816253158024383707e-16L, -4.812118250596034474977589134243772428682e-1L, 0 },
	TEST_c_c(casin, -0x1p-52L, 0.5L, -1.986027322597818397661816253158024383707e-16L, 4.812118250596034474977589134243772428682e-1L, 0 },
	TEST_c_c(casin, -0x1p-52L, -0.5L, -1.986027322597818397661816253158024383707e-16L, -4.812118250596034474977589134243772428682e-1L, 0 },
	TEST_c_c(casin, 0.5L, 0x1p-52L, 5.235987755982988730771072305465648369889e-1L, 2.563950248511418570403591756798643804971e-16L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0.5L, 0x1p-52L, -5.235987755982988730771072305465648369889e-1L, 2.563950248511418570403591756798643804971e-16L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0.5L, -0x1p-52L, 5.235987755982988730771072305465648369889e-1L, -2.563950248511418570403591756798643804971e-16L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0.5L, -0x1p-52L, -5.235987755982988730771072305465648369889e-1L, -2.563950248511418570403591756798643804971e-16L, 0|XFAIL_NATIVE_LINUX },
#ifndef TEST_FLOAT
	TEST_c_c(casin, 0x1.fp-1025L, 0.5L, 4.819934639999230680322935210539402497827e-309L, 4.812118250596034474977589134243684231352e-1L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(casin, 0x1.fp-1025L, -0.5L, 4.819934639999230680322935210539402497827e-309L, -4.812118250596034474977589134243684231352e-1L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(casin, -0x1.fp-1025L, 0.5L, -4.819934639999230680322935210539402497827e-309L, 4.812118250596034474977589134243684231352e-1L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(casin, -0x1.fp-1025L, -0.5L, -4.819934639999230680322935210539402497827e-309L, -4.812118250596034474977589134243684231352e-1L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(casin, 0.5L, 0x1.fp-1025L, 5.235987755982988730771072305465838140329e-1L, 6.222508863508420569166420770843207333493e-309L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0.5L, 0x1.fp-1025L, -5.235987755982988730771072305465838140329e-1L, 6.222508863508420569166420770843207333493e-309L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0.5L, -0x1.fp-1025L, 5.235987755982988730771072305465838140329e-1L, -6.222508863508420569166420770843207333493e-309L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0.5L, -0x1.fp-1025L, -5.235987755982988730771072305465838140329e-1L, -6.222508863508420569166420770843207333493e-309L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
#endif
	TEST_c_c(casin, 0x1p-52L, 0x1p-52L, 2.220446049250313080847263336181604132852e-16L, 2.220446049250313080847263336181677117148e-16L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casin, 0x1p-52L, -0x1p-52L, 2.220446049250313080847263336181604132852e-16L, -2.220446049250313080847263336181677117148e-16L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casin, -0x1p-52L, 0x1p-52L, -2.220446049250313080847263336181604132852e-16L, 2.220446049250313080847263336181677117148e-16L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casin, -0x1p-52L, -0x1p-52L, -2.220446049250313080847263336181604132852e-16L, -2.220446049250313080847263336181677117148e-16L, 0|XFAIL_NATIVE_LINUXF },
#ifndef TEST_FLOAT
	/* Bug 15319: underflow exception may be missing.  */
	TEST_c_c(casin, 0x1.fp-1025L, 0x1p-52L, 5.388850751072128349671657362289283247603e-309L, 2.220446049250313080847263336181622378926e-16L, UNDERFLOW_EXCEPTION_OK_DOUBLE },
	TEST_c_c(casin, 0x1.fp-1025L, -0x1p-52L, 5.388850751072128349671657362289283247603e-309L, -2.220446049250313080847263336181622378926e-16L, UNDERFLOW_EXCEPTION_OK_DOUBLE },
	TEST_c_c(casin, -0x1.fp-1025L, 0x1p-52L, -5.388850751072128349671657362289283247603e-309L, 2.220446049250313080847263336181622378926e-16L, UNDERFLOW_EXCEPTION_OK_DOUBLE },
	TEST_c_c(casin, -0x1.fp-1025L, -0x1p-52L, -5.388850751072128349671657362289283247603e-309L, -2.220446049250313080847263336181622378926e-16L, UNDERFLOW_EXCEPTION_OK_DOUBLE },
	TEST_c_c(casin, 0x1p-52L, 0x1.fp-1025L, 2.220446049250313080847263336181658871074e-16L, 5.388850751072128349671657362289548938458e-309L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0x1p-52L, 0x1.fp-1025L, -2.220446049250313080847263336181658871074e-16L, 5.388850751072128349671657362289548938458e-309L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0x1p-52L, -0x1.fp-1025L, 2.220446049250313080847263336181658871074e-16L, -5.388850751072128349671657362289548938458e-309L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0x1p-52L, -0x1.fp-1025L, -2.220446049250313080847263336181658871074e-16L, -5.388850751072128349671657362289548938458e-309L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
#endif
	TEST_c_c(casin, 0.0L, 0x1p-52L, 0.0L, 2.220446049250313080847263336181622378926e-16L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casin, 0.0L, -0x1p-52L, 0.0L, -2.220446049250313080847263336181622378926e-16L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casin, -0.0L, 0x1p-52L, -0.0L, 2.220446049250313080847263336181622378926e-16L, 0|XFAIL_NATIVE_LINUXF|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0.0L, -0x1p-52L, -0.0L, -2.220446049250313080847263336181622378926e-16L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casin, 0x1p-52L, 0.0L, 2.220446049250313080847263336181658871074e-16L, 0.0L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0x1p-52L, 0.0L, -2.220446049250313080847263336181658871074e-16L, 0.0L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0x1p-52L, -0.0L, 2.220446049250313080847263336181658871074e-16L, -0.0L, 0 },
	TEST_c_c(casin, -0x1p-52L, -0.0L, -2.220446049250313080847263336181658871074e-16L, -0.0L, 0 },
#ifndef TEST_FLOAT
	TEST_c_c(casin, 0x1.fp-1025L, 0x1.fp-1025L, 5.388850751072128349671657362289416093031e-309L, 5.388850751072128349671657362289416093031e-309L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0x1.fp-1025L, -0x1.fp-1025L, 5.388850751072128349671657362289416093031e-309L, -5.388850751072128349671657362289416093031e-309L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0x1.fp-1025L, 0x1.fp-1025L, -5.388850751072128349671657362289416093031e-309L, 5.388850751072128349671657362289416093031e-309L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0x1.fp-1025L, -0x1.fp-1025L, -5.388850751072128349671657362289416093031e-309L, -5.388850751072128349671657362289416093031e-309L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
#endif
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	TEST_c_c(casin, 0x1p-63L, 0x0.ffffffffffffffffp0L, 7.666467083416870407402049869781566856442e-20L, 8.813735870195430251942769895627079569937e-1L, 0 },
	TEST_c_c(casin, 0x1p-63L, -0x0.ffffffffffffffffp0L, 7.666467083416870407402049869781566856442e-20L, -8.813735870195430251942769895627079569937e-1L, 0 },
	TEST_c_c(casin, -0x1p-63L, 0x0.ffffffffffffffffp0L, -7.666467083416870407402049869781566856442e-20L, 8.813735870195430251942769895627079569937e-1L, 0 },
	TEST_c_c(casin, -0x1p-63L, -0x0.ffffffffffffffffp0L, -7.666467083416870407402049869781566856442e-20L, -8.813735870195430251942769895627079569937e-1L, 0 },
	TEST_c_c(casin, 0x0.ffffffffffffffffp0L, 0x1p-63L, 1.570796326376055842114524927965556247908L, 2.588578361325995866221775673638805081337e-10L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0x0.ffffffffffffffffp0L, 0x1p-63L, -1.570796326376055842114524927965556247908L, 2.588578361325995866221775673638805081337e-10L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0x0.ffffffffffffffffp0L, -0x1p-63L, 1.570796326376055842114524927965556247908L, -2.588578361325995866221775673638805081337e-10L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0x0.ffffffffffffffffp0L, -0x1p-63L, -1.570796326376055842114524927965556247908L, -2.588578361325995866221775673638805081337e-10L, 0|XFAIL_NATIVE_LINUX },
# if LDBL_MIN_EXP <= -16381
	TEST_c_c(casin, 0x1.fp-16385L, 0x0.ffffffffffffffffp0L, 5.757683115456107044287327268904964422212e-4933L, 8.813735870195430251942769895627079569917e-1L, UNDERFLOW_EXCEPTION },
	TEST_c_c(casin, 0x1.fp-16385L, -0x0.ffffffffffffffffp0L, 5.757683115456107044287327268904964422212e-4933L, -8.813735870195430251942769895627079569917e-1L, UNDERFLOW_EXCEPTION },
	TEST_c_c(casin, -0x1.fp-16385L, 0x0.ffffffffffffffffp0L, -5.757683115456107044287327268904964422212e-4933L, 8.813735870195430251942769895627079569917e-1L, UNDERFLOW_EXCEPTION },
	TEST_c_c(casin, -0x1.fp-16385L, -0x0.ffffffffffffffffp0L, -5.757683115456107044287327268904964422212e-4933L, -8.813735870195430251942769895627079569917e-1L, UNDERFLOW_EXCEPTION },
	TEST_c_c(casin, 0x0.ffffffffffffffffp0L, 0x1.fp-16385L, 1.570796326465624365239962068302568888898L, 2.472906068161537187835415298076415423459e-4923L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0x0.ffffffffffffffffp0L, 0x1.fp-16385L, -1.570796326465624365239962068302568888898L, 2.472906068161537187835415298076415423459e-4923L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0x0.ffffffffffffffffp0L, -0x1.fp-16385L, 1.570796326465624365239962068302568888898L, -2.472906068161537187835415298076415423459e-4923L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0x0.ffffffffffffffffp0L, -0x1.fp-16385L, -1.570796326465624365239962068302568888898L, -2.472906068161537187835415298076415423459e-4923L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUX },
# endif
	TEST_c_c(casin, 0.0L, 0x0.ffffffffffffffffp0L, 0.0L, 8.813735870195430251942769895627079569917e-1L, 0 },
	TEST_c_c(casin, 0.0L, -0x0.ffffffffffffffffp0L, 0.0L, -8.813735870195430251942769895627079569917e-1L, 0 },
	TEST_c_c(casin, -0.0L, 0x0.ffffffffffffffffp0L, -0.0L, 8.813735870195430251942769895627079569917e-1L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(casin, -0.0L, -0x0.ffffffffffffffffp0L, -0.0L, -8.813735870195430251942769895627079569917e-1L, 0 },
	TEST_c_c(casin, 0x0.ffffffffffffffffp0L, 0.0L, 1.570796326465624365239962068302568888898L, 0.0L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(casin, -0x0.ffffffffffffffffp0L, 0.0L, -1.570796326465624365239962068302568888898L, 0.0L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(casin, 0x0.ffffffffffffffffp0L, -0.0L, 1.570796326465624365239962068302568888898L, -0.0L, 0 },
	TEST_c_c(casin, -0x0.ffffffffffffffffp0L, -0.0L, -1.570796326465624365239962068302568888898L, -0.0L, 0 },
#endif
	TEST_c_c(casin, 0x1p-63L, 0.5L, 9.697399036122160144833087173623140436413e-20L, 4.812118250596034474977589134243684231373e-1L, 0 },
	TEST_c_c(casin, 0x1p-63L, -0.5L, 9.697399036122160144833087173623140436413e-20L, -4.812118250596034474977589134243684231373e-1L, 0 },
	TEST_c_c(casin, -0x1p-63L, 0.5L, -9.697399036122160144833087173623140436413e-20L, 4.812118250596034474977589134243684231373e-1L, 0 },
	TEST_c_c(casin, -0x1p-63L, -0.5L, -9.697399036122160144833087173623140436413e-20L, -4.812118250596034474977589134243684231373e-1L, 0 },
	TEST_c_c(casin, 0.5L, 0x1p-63L, 5.235987755982988730771072305465838140283e-1L, 1.251928832280966098829878787499365228659e-19L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0.5L, 0x1p-63L, -5.235987755982988730771072305465838140283e-1L, 1.251928832280966098829878787499365228659e-19L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0.5L, -0x1p-63L, 5.235987755982988730771072305465838140283e-1L, -1.251928832280966098829878787499365228659e-19L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0.5L, -0x1p-63L, -5.235987755982988730771072305465838140283e-1L, -1.251928832280966098829878787499365228659e-19L, 0|XFAIL_NATIVE_LINUX },
#if defined TEST_LDOUBLE && LDBL_MIN_EXP <= -16381
	TEST_c_c(casin, 0x1.fp-16385L, 0.5L, 7.282957076134209141226696333885150260319e-4933L, 4.812118250596034474977589134243684231352e-1L, UNDERFLOW_EXCEPTION },
	TEST_c_c(casin, 0x1.fp-16385L, -0.5L, 7.282957076134209141226696333885150260319e-4933L, -4.812118250596034474977589134243684231352e-1L, UNDERFLOW_EXCEPTION },
	TEST_c_c(casin, -0x1.fp-16385L, 0.5L, -7.282957076134209141226696333885150260319e-4933L, 4.812118250596034474977589134243684231352e-1L, UNDERFLOW_EXCEPTION },
	TEST_c_c(casin, -0x1.fp-16385L, -0.5L, -7.282957076134209141226696333885150260319e-4933L, -4.812118250596034474977589134243684231352e-1L, UNDERFLOW_EXCEPTION },
	TEST_c_c(casin, 0.5L, 0x1.fp-16385L, 5.235987755982988730771072305465838140329e-1L, 9.402257155670418112159334875199821342890e-4933L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0.5L, 0x1.fp-16385L, -5.235987755982988730771072305465838140329e-1L, 9.402257155670418112159334875199821342890e-4933L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0.5L, -0x1.fp-16385L, 5.235987755982988730771072305465838140329e-1L, -9.402257155670418112159334875199821342890e-4933L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0.5L, -0x1.fp-16385L, -5.235987755982988730771072305465838140329e-1L, -9.402257155670418112159334875199821342890e-4933L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUX },
#endif
	TEST_c_c(casin, 0x1p-63L, 0x1p-63L, 1.084202172485504434007452800869941711422e-19L, 1.084202172485504434007452800869941711430e-19L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0x1p-63L, -0x1p-63L, 1.084202172485504434007452800869941711422e-19L, -1.084202172485504434007452800869941711430e-19L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0x1p-63L, 0x1p-63L, -1.084202172485504434007452800869941711422e-19L, 1.084202172485504434007452800869941711430e-19L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0x1p-63L, -0x1p-63L, -1.084202172485504434007452800869941711422e-19L, -1.084202172485504434007452800869941711430e-19L, 0|XFAIL_NATIVE_LINUX },
#if defined TEST_LDOUBLE && LDBL_MIN_EXP <= -16381
	/* Bug 15319: underflow exception may be missing.  */
	TEST_c_c(casin, 0x1.fp-16385L, 0x1p-63L, 8.142593549724601460479922838826119584369e-4933L, 1.084202172485504434007452800869941711424e-19L, UNDERFLOW_EXCEPTION_OK },
	TEST_c_c(casin, 0x1.fp-16385L, -0x1p-63L, 8.142593549724601460479922838826119584369e-4933L, -1.084202172485504434007452800869941711424e-19L, UNDERFLOW_EXCEPTION_OK },
	TEST_c_c(casin, -0x1.fp-16385L, 0x1p-63L, -8.142593549724601460479922838826119584369e-4933L, 1.084202172485504434007452800869941711424e-19L, UNDERFLOW_EXCEPTION_OK },
	TEST_c_c(casin, -0x1.fp-16385L, -0x1p-63L, -8.142593549724601460479922838826119584369e-4933L, -1.084202172485504434007452800869941711424e-19L, UNDERFLOW_EXCEPTION_OK },
	TEST_c_c(casin, 0x1p-63L, 0x1.fp-16385L, 1.084202172485504434007452800869941711428e-19L, 8.142593549724601460479922838826119584465e-4933L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0x1p-63L, 0x1.fp-16385L, -1.084202172485504434007452800869941711428e-19L, 8.142593549724601460479922838826119584465e-4933L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0x1p-63L, -0x1.fp-16385L, 1.084202172485504434007452800869941711428e-19L, -8.142593549724601460479922838826119584465e-4933L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0x1p-63L, -0x1.fp-16385L, -1.084202172485504434007452800869941711428e-19L, -8.142593549724601460479922838826119584465e-4933L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUX },
#endif
	TEST_c_c(casin, 0.0L, 0x1p-63L, 0.0L, 1.084202172485504434007452800869941711424e-19L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0.0L, -0x1p-63L, 0.0L, -1.084202172485504434007452800869941711424e-19L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0.0L, 0x1p-63L, -0.0L, 1.084202172485504434007452800869941711424e-19L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0.0L, -0x1p-63L, -0.0L, -1.084202172485504434007452800869941711424e-19L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0x1p-63L, 0.0L, 1.084202172485504434007452800869941711428e-19L, 0.0L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0x1p-63L, 0.0L, -1.084202172485504434007452800869941711428e-19L, 0.0L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0x1p-63L, -0.0L, 1.084202172485504434007452800869941711428e-19L, -0.0L, 0 },
	TEST_c_c(casin, -0x1p-63L, -0.0L, -1.084202172485504434007452800869941711428e-19L, -0.0L, 0 },
#if defined TEST_LDOUBLE && LDBL_MIN_EXP <= -16381
	TEST_c_c(casin, 0x1.fp-16385L, 0x1.fp-16385L, 8.142593549724601460479922838826119584417e-4933L, 8.142593549724601460479922838826119584417e-4933L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0x1.fp-16385L, -0x1.fp-16385L, 8.142593549724601460479922838826119584417e-4933L, -8.142593549724601460479922838826119584417e-4933L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0x1.fp-16385L, 0x1.fp-16385L, -8.142593549724601460479922838826119584417e-4933L, 8.142593549724601460479922838826119584417e-4933L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0x1.fp-16385L, -0x1.fp-16385L, -8.142593549724601460479922838826119584417e-4933L, -8.142593549724601460479922838826119584417e-4933L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUX },
#endif
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 106
	TEST_c_c(casin, 0x1p-105L, 0x0.ffffffffffffffffffffffffffcp0L, 1.743152798421049375791483240187377443526e-32L, 8.813735870195430252326093249797835932642e-1L, 0 },
	TEST_c_c(casin, 0x1p-105L, -0x0.ffffffffffffffffffffffffffcp0L, 1.743152798421049375791483240187377443526e-32L, -8.813735870195430252326093249797835932642e-1L, 0 },
	TEST_c_c(casin, -0x1p-105L, 0x0.ffffffffffffffffffffffffffcp0L, -1.743152798421049375791483240187377443526e-32L, 8.813735870195430252326093249797835932642e-1L, 0 },
	TEST_c_c(casin, -0x1p-105L, -0x0.ffffffffffffffffffffffffffcp0L, -1.743152798421049375791483240187377443526e-32L, -8.813735870195430252326093249797835932642e-1L, 0 },
	TEST_c_c(casin, 0x0.ffffffffffffffffffffffffffcp0L, 0x1p-105L, 1.570796326794896419512475791677915736035L, 1.234330349600789959989661887846005659983e-16L, 0 },
	TEST_c_c(casin, -0x0.ffffffffffffffffffffffffffcp0L, 0x1p-105L, -1.570796326794896419512475791677915736035L, 1.234330349600789959989661887846005659983e-16L, 0 },
	TEST_c_c(casin, 0x0.ffffffffffffffffffffffffffcp0L, -0x1p-105L, 1.570796326794896419512475791677915736035L, -1.234330349600789959989661887846005659983e-16L, 0 },
	TEST_c_c(casin, -0x0.ffffffffffffffffffffffffffcp0L, -0x1p-105L, -1.570796326794896419512475791677915736035L, -1.234330349600789959989661887846005659983e-16L, 0 },
	TEST_c_c(casin, 0x1.fp-1025L, 0x0.ffffffffffffffffffffffffffcp0L, 3.810492908885321743133304375216641110205e-309L, 8.813735870195430252326093249797835932642e-1L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(casin, 0x1.fp-1025L, -0x0.ffffffffffffffffffffffffffcp0L, 3.810492908885321743133304375216641110205e-309L, -8.813735870195430252326093249797835932642e-1L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(casin, -0x1.fp-1025L, 0x0.ffffffffffffffffffffffffffcp0L, -3.810492908885321743133304375216641110205e-309L, 8.813735870195430252326093249797835932642e-1L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(casin, -0x1.fp-1025L, -0x0.ffffffffffffffffffffffffffcp0L, -3.810492908885321743133304375216641110205e-309L, -8.813735870195430252326093249797835932642e-1L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(casin, 0x0.ffffffffffffffffffffffffffcp0L, 0x1.fp-1025L, 1.570796326794896462222075823262245502760L, 3.432186888910770473784103112009399360940e-293L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM },
	TEST_c_c(casin, -0x0.ffffffffffffffffffffffffffcp0L, 0x1.fp-1025L, -1.570796326794896462222075823262245502760L, 3.432186888910770473784103112009399360940e-293L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM },
	TEST_c_c(casin, 0x0.ffffffffffffffffffffffffffcp0L, -0x1.fp-1025L, 1.570796326794896462222075823262245502760L, -3.432186888910770473784103112009399360940e-293L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM },
	TEST_c_c(casin, -0x0.ffffffffffffffffffffffffffcp0L, -0x1.fp-1025L, -1.570796326794896462222075823262245502760L, -3.432186888910770473784103112009399360940e-293L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM },
	TEST_c_c(casin, 0.0L, 0x0.ffffffffffffffffffffffffffcp0L, 0.0L, 8.813735870195430252326093249797835932642e-1L, 0 },
	TEST_c_c(casin, 0.0L, -0x0.ffffffffffffffffffffffffffcp0L, 0.0L, -8.813735870195430252326093249797835932642e-1L, 0 },
	TEST_c_c(casin, -0.0L, 0x0.ffffffffffffffffffffffffffcp0L, -0.0L, 8.813735870195430252326093249797835932642e-1L, 0 },
	TEST_c_c(casin, -0.0L, -0x0.ffffffffffffffffffffffffffcp0L, -0.0L, -8.813735870195430252326093249797835932642e-1L, 0 },
	TEST_c_c(casin, 0x0.ffffffffffffffffffffffffffcp0L, 0.0L, 1.570796326794896462222075823262245502760L, 0.0L, 0 },
	TEST_c_c(casin, -0x0.ffffffffffffffffffffffffffcp0L, 0.0L, -1.570796326794896462222075823262245502760L, 0.0L, 0 },
	TEST_c_c(casin, 0x0.ffffffffffffffffffffffffffcp0L, -0.0L, 1.570796326794896462222075823262245502760L, -0.0L, 0 },
	TEST_c_c(casin, -0x0.ffffffffffffffffffffffffffcp0L, -0.0L, -1.570796326794896462222075823262245502760L, -0.0L, 0 },
#endif
	TEST_c_c(casin, 0x1p-105L, 0.5L, 2.204933261082751447436996198490110245167e-32L, 4.812118250596034474977589134243684231352e-1L, 0 },
	TEST_c_c(casin, 0x1p-105L, -0.5L, 2.204933261082751447436996198490110245167e-32L, -4.812118250596034474977589134243684231352e-1L, 0 },
	TEST_c_c(casin, -0x1p-105L, 0.5L, -2.204933261082751447436996198490110245167e-32L, 4.812118250596034474977589134243684231352e-1L, 0 },
	TEST_c_c(casin, -0x1p-105L, -0.5L, -2.204933261082751447436996198490110245167e-32L, -4.812118250596034474977589134243684231352e-1L, 0 },
	TEST_c_c(casin, 0.5L, 0x1p-105L, 5.235987755982988730771072305465838140329e-1L, 2.846556599890768890940941645338546615370e-32L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0.5L, 0x1p-105L, -5.235987755982988730771072305465838140329e-1L, 2.846556599890768890940941645338546615370e-32L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0.5L, -0x1p-105L, 5.235987755982988730771072305465838140329e-1L, -2.846556599890768890940941645338546615370e-32L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0.5L, -0x1p-105L, -5.235987755982988730771072305465838140329e-1L, -2.846556599890768890940941645338546615370e-32L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0x1p-105L, 0x1p-105L, 2.465190328815661891911651766508706967729e-32L, 2.465190328815661891911651766508706967729e-32L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0x1p-105L, -0x1p-105L, 2.465190328815661891911651766508706967729e-32L, -2.465190328815661891911651766508706967729e-32L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0x1p-105L, 0x1p-105L, -2.465190328815661891911651766508706967729e-32L, 2.465190328815661891911651766508706967729e-32L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0x1p-105L, -0x1p-105L, -2.465190328815661891911651766508706967729e-32L, -2.465190328815661891911651766508706967729e-32L, 0|XFAIL_NATIVE_LINUX },
#ifndef TEST_FLOAT
	/* Bug 15319: underflow exception may be missing.  */
	TEST_c_c(casin, 0x1.fp-1025L, 0x1p-105L, 5.388850751072128349671657362289416093031e-309L, 2.465190328815661891911651766508706967729e-32L, UNDERFLOW_EXCEPTION_OK_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0x1.fp-1025L, -0x1p-105L, 5.388850751072128349671657362289416093031e-309L, -2.465190328815661891911651766508706967729e-32L, UNDERFLOW_EXCEPTION_OK_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0x1.fp-1025L, 0x1p-105L, -5.388850751072128349671657362289416093031e-309L, 2.465190328815661891911651766508706967729e-32L, UNDERFLOW_EXCEPTION_OK_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0x1.fp-1025L, -0x1p-105L, -5.388850751072128349671657362289416093031e-309L, -2.465190328815661891911651766508706967729e-32L, UNDERFLOW_EXCEPTION_OK_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0x1p-105L, 0x1.fp-1025L, 2.465190328815661891911651766508706967729e-32L, 5.388850751072128349671657362289416093031e-309L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0x1p-105L, 0x1.fp-1025L, -2.465190328815661891911651766508706967729e-32L, 5.388850751072128349671657362289416093031e-309L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0x1p-105L, -0x1.fp-1025L, 2.465190328815661891911651766508706967729e-32L, -5.388850751072128349671657362289416093031e-309L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0x1p-105L, -0x1.fp-1025L, -2.465190328815661891911651766508706967729e-32L, -5.388850751072128349671657362289416093031e-309L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
#endif
	TEST_c_c(casin, 0.0L, 0x1p-105L, 0.0L, 2.465190328815661891911651766508706967729e-32L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0.0L, -0x1p-105L, 0.0L, -2.465190328815661891911651766508706967729e-32L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0.0L, 0x1p-105L, -0.0L, 2.465190328815661891911651766508706967729e-32L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0.0L, -0x1p-105L, -0.0L, -2.465190328815661891911651766508706967729e-32L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0x1p-105L, 0.0L, 2.465190328815661891911651766508706967729e-32L, 0.0L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0x1p-105L, 0.0L, -2.465190328815661891911651766508706967729e-32L, 0.0L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0x1p-105L, -0.0L, 2.465190328815661891911651766508706967729e-32L, -0.0L, 0 },
	TEST_c_c(casin, -0x1p-105L, -0.0L, -2.465190328815661891911651766508706967729e-32L, -0.0L, 0 },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 113
	TEST_c_c(casin, 0x1p-112L, 0x0.ffffffffffffffffffffffffffff8p0L, 1.361838123766444824837096281396380300349e-34L, 8.813735870195430252326093249797922409363e-1L, 0 },
	TEST_c_c(casin, 0x1p-112L, -0x0.ffffffffffffffffffffffffffff8p0L, 1.361838123766444824837096281396380300349e-34L, -8.813735870195430252326093249797922409363e-1L, 0 },
	TEST_c_c(casin, -0x1p-112L, 0x0.ffffffffffffffffffffffffffff8p0L, -1.361838123766444824837096281396380300349e-34L, 8.813735870195430252326093249797922409363e-1L, 0 },
	TEST_c_c(casin, -0x1p-112L, -0x0.ffffffffffffffffffffffffffff8p0L, -1.361838123766444824837096281396380300349e-34L, -8.813735870195430252326093249797922409363e-1L, 0 },
	TEST_c_c(casin, 0x0.ffffffffffffffffffffffffffff8p0L, 0x1p-112L, 1.570796326794896601578502908312986698624L, 1.091004200533850618345330909857103457781e-17L, 0 },
	TEST_c_c(casin, -0x0.ffffffffffffffffffffffffffff8p0L, 0x1p-112L, -1.570796326794896601578502908312986698624L, 1.091004200533850618345330909857103457781e-17L, 0 },
	TEST_c_c(casin, 0x0.ffffffffffffffffffffffffffff8p0L, -0x1p-112L, 1.570796326794896601578502908312986698624L, -1.091004200533850618345330909857103457781e-17L, 0 },
	TEST_c_c(casin, -0x0.ffffffffffffffffffffffffffff8p0L, -0x1p-112L, -1.570796326794896601578502908312986698624L, -1.091004200533850618345330909857103457781e-17L, 0 },
	TEST_c_c(casin, 0x1.fp-16385L, 0x0.ffffffffffffffffffffffffffff8p0L, 5.757683115456107044131264955348449231681e-4933L, 8.813735870195430252326093249797922409363e-1L, UNDERFLOW_EXCEPTION },
	TEST_c_c(casin, 0x1.fp-16385L, -0x0.ffffffffffffffffffffffffffff8p0L, 5.757683115456107044131264955348449231681e-4933L, -8.813735870195430252326093249797922409363e-1L, UNDERFLOW_EXCEPTION },
	TEST_c_c(casin, -0x1.fp-16385L, 0x0.ffffffffffffffffffffffffffff8p0L, -5.757683115456107044131264955348449231681e-4933L, 8.813735870195430252326093249797922409363e-1L, UNDERFLOW_EXCEPTION },
	TEST_c_c(casin, -0x1.fp-16385L, -0x0.ffffffffffffffffffffffffffff8p0L, -5.757683115456107044131264955348449231681e-4933L, -8.813735870195430252326093249797922409363e-1L, UNDERFLOW_EXCEPTION },
	TEST_c_c(casin, 0x0.ffffffffffffffffffffffffffff8p0L, 0x1.fp-16385L, 1.570796326794896605353533883825294686803L, 5.867357004219059108790368268900490184505e-4916L, 0 },
	TEST_c_c(casin, -0x0.ffffffffffffffffffffffffffff8p0L, 0x1.fp-16385L, -1.570796326794896605353533883825294686803L, 5.867357004219059108790368268900490184505e-4916L, 0 },
	TEST_c_c(casin, 0x0.ffffffffffffffffffffffffffff8p0L, -0x1.fp-16385L, 1.570796326794896605353533883825294686803L, -5.867357004219059108790368268900490184505e-4916L, 0 },
	TEST_c_c(casin, -0x0.ffffffffffffffffffffffffffff8p0L, -0x1.fp-16385L, -1.570796326794896605353533883825294686803L, -5.867357004219059108790368268900490184505e-4916L, 0 },
	TEST_c_c(casin, 0.0L, 0x0.ffffffffffffffffffffffffffff8p0L, 0.0L, 8.813735870195430252326093249797922409363e-1L, 0 },
	TEST_c_c(casin, 0.0L, -0x0.ffffffffffffffffffffffffffff8p0L, 0.0L, -8.813735870195430252326093249797922409363e-1L, 0 },
	TEST_c_c(casin, -0.0L, 0x0.ffffffffffffffffffffffffffff8p0L, -0.0L, 8.813735870195430252326093249797922409363e-1L, 0 },
	TEST_c_c(casin, -0.0L, -0x0.ffffffffffffffffffffffffffff8p0L, -0.0L, -8.813735870195430252326093249797922409363e-1L, 0 },
	TEST_c_c(casin, 0x0.ffffffffffffffffffffffffffff8p0L, 0.0L, 1.570796326794896605353533883825294686803L, 0.0L, 0 },
	TEST_c_c(casin, -0x0.ffffffffffffffffffffffffffff8p0L, 0.0L, -1.570796326794896605353533883825294686803L, 0.0L, 0 },
	TEST_c_c(casin, 0x0.ffffffffffffffffffffffffffff8p0L, -0.0L, 1.570796326794896605353533883825294686803L, -0.0L, 0 },
	TEST_c_c(casin, -0x0.ffffffffffffffffffffffffffff8p0L, -0.0L, -1.570796326794896605353533883825294686803L, -0.0L, 0 },
#endif
	TEST_c_c(casin, 0x1p-112L, 0.5L, 1.722604110220899568310153280070398629037e-34L, 4.812118250596034474977589134243684231352e-1L, 0 },
	TEST_c_c(casin, 0x1p-112L, -0.5L, 1.722604110220899568310153280070398629037e-34L, -4.812118250596034474977589134243684231352e-1L, 0 },
	TEST_c_c(casin, -0x1p-112L, 0.5L, -1.722604110220899568310153280070398629037e-34L, 4.812118250596034474977589134243684231352e-1L, 0 },
	TEST_c_c(casin, -0x1p-112L, -0.5L, -1.722604110220899568310153280070398629037e-34L, -4.812118250596034474977589134243684231352e-1L, 0 },
	TEST_c_c(casin, 0.5L, 0x1p-112L, 5.235987755982988730771072305465838140329e-1L, 2.223872343664663196047610660420739543258e-34L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0.5L, 0x1p-112L, -5.235987755982988730771072305465838140329e-1L, 2.223872343664663196047610660420739543258e-34L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0.5L, -0x1p-112L, 5.235987755982988730771072305465838140329e-1L, -2.223872343664663196047610660420739543258e-34L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0.5L, -0x1p-112L, -5.235987755982988730771072305465838140329e-1L, -2.223872343664663196047610660420739543258e-34L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0x1p-112L, 0x1p-112L, 1.925929944387235853055977942584927318538e-34L, 1.925929944387235853055977942584927318538e-34L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0x1p-112L, -0x1p-112L, 1.925929944387235853055977942584927318538e-34L, -1.925929944387235853055977942584927318538e-34L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0x1p-112L, 0x1p-112L, -1.925929944387235853055977942584927318538e-34L, 1.925929944387235853055977942584927318538e-34L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0x1p-112L, -0x1p-112L, -1.925929944387235853055977942584927318538e-34L, -1.925929944387235853055977942584927318538e-34L, 0|XFAIL_NATIVE_LINUX },
#if defined TEST_LDOUBLE && LDBL_MIN_EXP <= -16381
	/* Bug 15319: underflow exception may be missing.  */
	TEST_c_c(casin, 0x1.fp-16385L, 0x1p-112L, 8.142593549724601460479922838826119584417e-4933L, 1.925929944387235853055977942584927318538e-34L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0x1.fp-16385L, -0x1p-112L, 8.142593549724601460479922838826119584417e-4933L, -1.925929944387235853055977942584927318538e-34L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0x1.fp-16385L, 0x1p-112L, -8.142593549724601460479922838826119584417e-4933L, 1.925929944387235853055977942584927318538e-34L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0x1.fp-16385L, -0x1p-112L, -8.142593549724601460479922838826119584417e-4933L, -1.925929944387235853055977942584927318538e-34L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0x1p-112L, 0x1.fp-16385L, 1.925929944387235853055977942584927318538e-34L, 8.142593549724601460479922838826119584417e-4933L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0x1p-112L, 0x1.fp-16385L, -1.925929944387235853055977942584927318538e-34L, 8.142593549724601460479922838826119584417e-4933L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0x1p-112L, -0x1.fp-16385L, 1.925929944387235853055977942584927318538e-34L, -8.142593549724601460479922838826119584417e-4933L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0x1p-112L, -0x1.fp-16385L, -1.925929944387235853055977942584927318538e-34L, -8.142593549724601460479922838826119584417e-4933L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUX },
#endif
	TEST_c_c(casin, 0.0L, 0x1p-112L, 0.0L, 1.925929944387235853055977942584927318538e-34L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0.0L, -0x1p-112L, 0.0L, -1.925929944387235853055977942584927318538e-34L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0.0L, 0x1p-112L, -0.0L, 1.925929944387235853055977942584927318538e-34L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0.0L, -0x1p-112L, -0.0L, -1.925929944387235853055977942584927318538e-34L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0x1p-112L, 0.0L, 1.925929944387235853055977942584927318538e-34L, 0.0L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, -0x1p-112L, 0.0L, -1.925929944387235853055977942584927318538e-34L, 0.0L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casin, 0x1p-112L, -0.0L, 1.925929944387235853055977942584927318538e-34L, -0.0L, 0 },
	TEST_c_c(casin, -0x1p-112L, -0.0L, -1.925929944387235853055977942584927318538e-34L, -0.0L, 0 },

	TEST_c_c(casin, 0.75L, 1.25L, 0.453276177638793913448921196101971749L, 1.13239363160530819522266333696834467L, 0 },
	TEST_c_c(casin, -2, -3, -0.57065278432109940071028387968566963L, -1.9833870299165354323470769028940395L, 0 },
}


static void test_casinh(void)
{
	struct test *testp = lookup("casinh" },

	TEST_c_c(casinh, 0, 0, 0.0, 0.0, 0 },
	TEST_c_c(casinh, ZERO_M, 0, ZERO_M, 0, 0 },
	TEST_c_c(casinh, 0, ZERO_M, 0.0, ZERO_M, 0 },
	TEST_c_c(casinh, ZERO_M, ZERO_M, ZERO_M, ZERO_M, 0 },

	TEST_c_c(casinh, INF_P, INF_P, INF_P, M_PI_4l, 0 },
	TEST_c_c(casinh, INF_P, INF_M, INF_P, -M_PI_4l, 0 },
	TEST_c_c(casinh, INF_M, INF_P, INF_M, M_PI_4l, 0 },
	TEST_c_c(casinh, INF_M, INF_M, INF_M, -M_PI_4l, 0 },

	TEST_c_c(casinh, -10.0, INF_P, INF_M, M_PI_2l, 0 },
	TEST_c_c(casinh, -10.0, INF_M, INF_M, -M_PI_2l, 0 },
	TEST_c_c(casinh, 0, INF_P, INF_P, M_PI_2l, 0 },
	TEST_c_c(casinh, 0, INF_M, INF_P, -M_PI_2l, 0 },
	TEST_c_c(casinh, ZERO_M, INF_P, INF_M, M_PI_2l, 0 },
	TEST_c_c(casinh, ZERO_M, INF_M, INF_M, -M_PI_2l, 0 },
	TEST_c_c(casinh, 0.1L, INF_P, INF_P, M_PI_2l, 0 },
	TEST_c_c(casinh, 0.1L, INF_M, INF_P, -M_PI_2l, 0 },

	TEST_c_c(casinh, INF_M, 0, INF_M, 0.0, 0 },
	TEST_c_c(casinh, INF_M, ZERO_M, INF_M, ZERO_M, 0 },
	TEST_c_c(casinh, INF_M, 100, INF_M, 0.0, 0 },
	TEST_c_c(casinh, INF_M, -100, INF_M, ZERO_M, 0 },

	TEST_c_c(casinh, INF_P, 0, INF_P, 0.0, 0 },
	TEST_c_c(casinh, INF_P, ZERO_M, INF_P, ZERO_M, 0 },
	TEST_c_c(casinh, INF_P, 0.5, INF_P, 0.0, 0 },
	TEST_c_c(casinh, INF_P, -0.5, INF_P, ZERO_M, 0 },

	TEST_c_c(casinh, INF_P, QNAN_P, INF_P, QNAN_P, 0 },
	TEST_c_c(casinh, INF_M, QNAN_P, INF_M, QNAN_P, 0 },

	TEST_c_c(casinh, QNAN_P, 0, QNAN_P, 0.0, 0 },
	TEST_c_c(casinh, QNAN_P, ZERO_M, QNAN_P, ZERO_M, 0 },

	TEST_c_c(casinh, QNAN_P, INF_P, INF_P, QNAN_P, IGNORE_ZERO_INF_SIGN },
	TEST_c_c(casinh, QNAN_P, INF_M, INF_P, QNAN_P, IGNORE_ZERO_INF_SIGN },

	TEST_c_c(casinh, 10.5, QNAN_P, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	TEST_c_c(casinh, -10.5, QNAN_P, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },

	TEST_c_c(casinh, QNAN_P, 0.75, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	TEST_c_c(casinh, -0.75, QNAN_P, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },

	TEST_c_c(casinh, QNAN_P, QNAN_P, QNAN_P, QNAN_P, 0 },

	TEST_c_c(casinh, ZERO_P, -1.5L, 0.9624236501192068949955178268487368462704L, -M_PI_2l, 0 },
	TEST_c_c(casinh, ZERO_M, -1.5L, -0.9624236501192068949955178268487368462704L, -M_PI_2l, 0 },
	TEST_c_c(casinh, ZERO_P, -1.0L, ZERO_P, -M_PI_2l, 0 },
	TEST_c_c(casinh, ZERO_M, -1.0L, ZERO_M, -M_PI_2l, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, ZERO_P, -0.5L, ZERO_P, -0.5235987755982988730771072305465838140329L, 0 },
	TEST_c_c(casinh, ZERO_M, -0.5L, ZERO_M, -0.5235987755982988730771072305465838140329L, 0|XFAIL_NATIVE_LINUXL|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casinh, ZERO_P, 0.5L, ZERO_P, 0.5235987755982988730771072305465838140329L, 0 },
	TEST_c_c(casinh, ZERO_M, 0.5L, ZERO_M, 0.5235987755982988730771072305465838140329L, 0|XFAIL_NATIVE_LINUXL|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casinh, ZERO_P, 1.0L, ZERO_P, M_PI_2l, 0 },
	TEST_c_c(casinh, ZERO_M, 1.0L, ZERO_M, M_PI_2l, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, ZERO_P, 1.5L, 0.9624236501192068949955178268487368462704L, M_PI_2l, 0 },
	TEST_c_c(casinh, ZERO_M, 1.5L, -0.9624236501192068949955178268487368462704L, M_PI_2l, 0 },

	TEST_c_c(casinh, -1.5L, ZERO_P, -1.194763217287109304111930828519090523536L, ZERO_P, 0 },
	TEST_c_c(casinh, -1.5L, ZERO_M, -1.194763217287109304111930828519090523536L, ZERO_M, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -1.0L, ZERO_P, -0.8813735870195430252326093249797923090282L, ZERO_P, 0 },
	TEST_c_c(casinh, -1.0L, ZERO_M, -0.8813735870195430252326093249797923090282L, ZERO_M, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0.5L, ZERO_P, -0.4812118250596034474977589134243684231352L, ZERO_P, 0 },
	TEST_c_c(casinh, -0.5L, ZERO_M, -0.4812118250596034474977589134243684231352L, ZERO_M, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, 0.5L, ZERO_P, 0.4812118250596034474977589134243684231352L, ZERO_P, 0 },
	TEST_c_c(casinh, 0.5L, ZERO_M, 0.4812118250596034474977589134243684231352L, ZERO_M, 0 },
	TEST_c_c(casinh, 1.0L, ZERO_P, 0.8813735870195430252326093249797923090282L, ZERO_P, 0 },
	TEST_c_c(casinh, 1.0L, ZERO_M, 0.8813735870195430252326093249797923090282L, ZERO_M, 0 },
	TEST_c_c(casinh, 1.5L, ZERO_P, 1.194763217287109304111930828519090523536L, ZERO_P, 0 },
	TEST_c_c(casinh, 1.5L, ZERO_M, 1.194763217287109304111930828519090523536L, ZERO_M, 0 },

	TEST_c_c(casinh, 0x1p50L, 1.0L, 3.535050620855721078027883819436759661753e1L, 8.881784197001252323389053344720723756399e-16L, 0 },
	TEST_c_c(casinh, 0x1p50L, -1.0L, 3.535050620855721078027883819436759661753e1L, -8.881784197001252323389053344720723756399e-16L, 0 },
	TEST_c_c(casinh, -0x1p50L, 1.0L, -3.535050620855721078027883819436759661753e1L, 8.881784197001252323389053344720723756399e-16L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0x1p50L, -1.0L, -3.535050620855721078027883819436759661753e1L, -8.881784197001252323389053344720723756399e-16L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, 1.0L, 0x1p50L, 3.535050620855721078027883819436720218708e1L, 1.570796326794895731052901991514519103193L, 0 },
	TEST_c_c(casinh, -1.0L, 0x1p50L, -3.535050620855721078027883819436720218708e1L, 1.570796326794895731052901991514519103193L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, 1.0L, -0x1p50L, 3.535050620855721078027883819436720218708e1L, -1.570796326794895731052901991514519103193L, 0 },
	TEST_c_c(casinh, -1.0L, -0x1p50L, -3.535050620855721078027883819436720218708e1L, -1.570796326794895731052901991514519103193L, 0|XFAIL_NATIVE_LINUX },
#ifndef TEST_FLOAT
	TEST_c_c(casinh, 0x1p500L, 1.0L, 3.472667374605326000180332928505464606058e2L, 3.054936363499604682051979393213617699789e-151L, 0 },
	TEST_c_c(casinh, 0x1p500L, -1.0L, 3.472667374605326000180332928505464606058e2L, -3.054936363499604682051979393213617699789e-151L, 0 },
	TEST_c_c(casinh, -0x1p500L, 1.0L, -3.472667374605326000180332928505464606058e2L, 3.054936363499604682051979393213617699789e-151L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0x1p500L, -1.0L, -3.472667374605326000180332928505464606058e2L, -3.054936363499604682051979393213617699789e-151L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, 1.0L, 0x1p500L, 3.472667374605326000180332928505464606058e2L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(casinh, -1.0L, 0x1p500L, -3.472667374605326000180332928505464606058e2L, 1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, 1.0L, -0x1p500L, 3.472667374605326000180332928505464606058e2L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(casinh, -1.0L, -0x1p500L, -3.472667374605326000180332928505464606058e2L, -1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
#endif
#if defined TEST_LDOUBLE && LDBL_MAX_EXP >= 16384
	TEST_c_c(casinh, 0x1p5000L, 1.0L, 3.466429049980286492395577839412341016946e3L, 7.079811261048172892385615158694057552948e-1506L, 0 },
	TEST_c_c(casinh, 0x1p5000L, -1.0L, 3.466429049980286492395577839412341016946e3L, -7.079811261048172892385615158694057552948e-1506L, 0 },
	TEST_c_c(casinh, -0x1p5000L, 1.0L, -3.466429049980286492395577839412341016946e3L, 7.079811261048172892385615158694057552948e-1506L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(casinh, -0x1p5000L, -1.0L, -3.466429049980286492395577839412341016946e3L, -7.079811261048172892385615158694057552948e-1506L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(casinh, 1.0L, 0x1p5000L, 3.466429049980286492395577839412341016946e3L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(casinh, -1.0L, 0x1p5000L, -3.466429049980286492395577839412341016946e3L, 1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(casinh, 1.0L, -0x1p5000L, 3.466429049980286492395577839412341016946e3L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(casinh, -1.0L, -0x1p5000L, -3.466429049980286492395577839412341016946e3L, -1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUXL },
#endif

	TEST_c_c(casinh, 0x1.fp127L, 0x1.fp127L, 8.973081118419833726837456344608533993585e1L, 7.853981633974483096156608458198757210493e-1L, 0|XFAIL_NATIVE_LINUXF },
#ifndef TEST_FLOAT
	TEST_c_c(casinh, 0x1.fp1023L, 0x1.fp1023L, 7.107906849659093345062145442726115449315e2L, 7.853981633974483096156608458198757210493e-1L, 0|XFAIL_NATIVE_LINUX },
#endif
#if defined TEST_LDOUBLE && LDBL_MAX_EXP >= 16384
	TEST_c_c(casinh, 0x1.fp16383L, 0x1.fp16383L, 1.135753137836666928715489992987020363057e4L, 7.853981633974483096156608458198757210493e-1L, 0|XFAIL_NATIVE_LINUXL },
#endif

	TEST_c_c(casinh, 0x1.fp-129L, 1.5L, 9.624236501192068949955178268487368462704e-1L, 1.570796326794896619231321691639751442096L, 0 },
	TEST_c_c(casinh, 0x1.fp-129L, -1.5L, 9.624236501192068949955178268487368462704e-1L, -1.570796326794896619231321691639751442096L, 0 },
	TEST_c_c(casinh, -0x1.fp-129L, 1.5L, -9.624236501192068949955178268487368462704e-1L, 1.570796326794896619231321691639751442096L, 0 },
	TEST_c_c(casinh, -0x1.fp-129L, -1.5L, -9.624236501192068949955178268487368462704e-1L, -1.570796326794896619231321691639751442096L, 0 },
	TEST_c_c(casinh, 1.5L, 0x1.fp-129L, 1.194763217287109304111930828519090523536L, 1.579176199917649005841160751101628985741e-39L, UNDERFLOW_EXCEPTION_FLOAT },
	TEST_c_c(casinh, -1.5L, 0x1.fp-129L, -1.194763217287109304111930828519090523536L, 1.579176199917649005841160751101628985741e-39L, UNDERFLOW_EXCEPTION_FLOAT },
	TEST_c_c(casinh, 1.5L, -0x1.fp-129L, 1.194763217287109304111930828519090523536L, -1.579176199917649005841160751101628985741e-39L, UNDERFLOW_EXCEPTION_FLOAT },
	TEST_c_c(casinh, -1.5L, -0x1.fp-129L, -1.194763217287109304111930828519090523536L, -1.579176199917649005841160751101628985741e-39L, UNDERFLOW_EXCEPTION_FLOAT },
#ifndef TEST_FLOAT
	TEST_c_c(casinh, 0x1.fp-1025L, 1.5L, 9.624236501192068949955178268487368462704e-1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(casinh, 0x1.fp-1025L, -1.5L, 9.624236501192068949955178268487368462704e-1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(casinh, -0x1.fp-1025L, 1.5L, -9.624236501192068949955178268487368462704e-1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(casinh, -0x1.fp-1025L, -1.5L, -9.624236501192068949955178268487368462704e-1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(casinh, 1.5L, 0x1.fp-1025L, 1.194763217287109304111930828519090523536L, 2.989196569048182929051881765490354365918e-309L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(casinh, -1.5L, 0x1.fp-1025L, -1.194763217287109304111930828519090523536L, 2.989196569048182929051881765490354365918e-309L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(casinh, 1.5L, -0x1.fp-1025L, 1.194763217287109304111930828519090523536L, -2.989196569048182929051881765490354365918e-309L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(casinh, -1.5L, -0x1.fp-1025L, -1.194763217287109304111930828519090523536L, -2.989196569048182929051881765490354365918e-309L, UNDERFLOW_EXCEPTION_DOUBLE },
#endif
#if defined TEST_LDOUBLE && LDBL_MIN_EXP <= -16381
	TEST_c_c(casinh, 0x1.fp-16385L, 1.5L, 9.624236501192068949955178268487368462704e-1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(casinh, 0x1.fp-16385L, -1.5L, 9.624236501192068949955178268487368462704e-1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(casinh, -0x1.fp-16385L, 1.5L, -9.624236501192068949955178268487368462704e-1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(casinh, -0x1.fp-16385L, -1.5L, -9.624236501192068949955178268487368462704e-1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(casinh, 1.5L, 0x1.fp-16385L, 1.194763217287109304111930828519090523536L, 4.516698239814521372306784062043266700598e-4933L, UNDERFLOW_EXCEPTION },
	TEST_c_c(casinh, -1.5L, 0x1.fp-16385L, -1.194763217287109304111930828519090523536L, 4.516698239814521372306784062043266700598e-4933L, UNDERFLOW_EXCEPTION },
	TEST_c_c(casinh, 1.5L, -0x1.fp-16385L, 1.194763217287109304111930828519090523536L, -4.516698239814521372306784062043266700598e-4933L, UNDERFLOW_EXCEPTION },
	TEST_c_c(casinh, -1.5L, -0x1.fp-16385L, -1.194763217287109304111930828519090523536L, -4.516698239814521372306784062043266700598e-4933L, UNDERFLOW_EXCEPTION },
#endif

	TEST_c_c(casinh, 0.5L, 1.0L, 7.328576759736452608886724437653071523305e-1L, 8.959074812088902390666567243275770102229e-1L, 0 },
	TEST_c_c(casinh, 0.5L, -1.0L, 7.328576759736452608886724437653071523305e-1L, -8.959074812088902390666567243275770102229e-1L, 0 },
	TEST_c_c(casinh, -0.5L, 1.0L, -7.328576759736452608886724437653071523305e-1L, 8.959074812088902390666567243275770102229e-1L, 0 },
	TEST_c_c(casinh, -0.5L, -1.0L, -7.328576759736452608886724437653071523305e-1L, -8.959074812088902390666567243275770102229e-1L, 0 },
	TEST_c_c(casinh, 1.0L, 0.5L, 9.261330313501824245501244453057873152694e-1L, 3.494390628572132936274118260753699527325e-1L, 0 },
	TEST_c_c(casinh, -1.0L, 0.5L, -9.261330313501824245501244453057873152694e-1L, 3.494390628572132936274118260753699527325e-1L, 0 },
	TEST_c_c(casinh, 1.0L, -0.5L, 9.261330313501824245501244453057873152694e-1L, -3.494390628572132936274118260753699527325e-1L, 0 },
	TEST_c_c(casinh, -1.0L, -0.5L, -9.261330313501824245501244453057873152694e-1L, -3.494390628572132936274118260753699527325e-1L, 0 },
	TEST_c_c(casinh, 0.25L, 1.0L, 5.097911466811016354623559941115413499164e-1L, 1.081751996523816326311037318425097434186L, 0 },
	TEST_c_c(casinh, 0.25L, -1.0L, 5.097911466811016354623559941115413499164e-1L, -1.081751996523816326311037318425097434186L, 0 },
	TEST_c_c(casinh, -0.25L, 1.0L, -5.097911466811016354623559941115413499164e-1L, 1.081751996523816326311037318425097434186L, 0 },
	TEST_c_c(casinh, -0.25L, -1.0L, -5.097911466811016354623559941115413499164e-1L, -1.081751996523816326311037318425097434186L, 0 },
	TEST_c_c(casinh, 1.0L, 0.25L, 8.924633639033482359562124741744951972772e-1L, 1.763024327769669304186785666360901026468e-1L, 0 },
	TEST_c_c(casinh, -1.0L, 0.25L, -8.924633639033482359562124741744951972772e-1L, 1.763024327769669304186785666360901026468e-1L, 0 },
	TEST_c_c(casinh, 1.0L, -0.25L, 8.924633639033482359562124741744951972772e-1L, -1.763024327769669304186785666360901026468e-1L, 0 },
	TEST_c_c(casinh, -1.0L, -0.25L, -8.924633639033482359562124741744951972772e-1L, -1.763024327769669304186785666360901026468e-1L, 0 },
	TEST_c_c(casinh, 0x1.fp-10L, 1.0L, 4.350501469856803800217957402220976497152e-2L, 1.527305029163877791518741192097931722508L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casinh, 0x1.fp-10L, -1.0L, 4.350501469856803800217957402220976497152e-2L, -1.527305029163877791518741192097931722508L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casinh, -0x1.fp-10L, 1.0L, -4.350501469856803800217957402220976497152e-2L, 1.527305029163877791518741192097931722508L, 0 },
	TEST_c_c(casinh, -0x1.fp-10L, -1.0L, -4.350501469856803800217957402220976497152e-2L, -1.527305029163877791518741192097931722508L, 0 },
	TEST_c_c(casinh, 1.0L, 0x1.fp-10L, 8.813742198809567991336704287826445879025e-1L, 1.337909359557740912558349531052239112857e-3L, 0 },
	TEST_c_c(casinh, -1.0L, 0x1.fp-10L, -8.813742198809567991336704287826445879025e-1L, 1.337909359557740912558349531052239112857e-3L, 0 },
	TEST_c_c(casinh, 1.0L, -0x1.fp-10L, 8.813742198809567991336704287826445879025e-1L, -1.337909359557740912558349531052239112857e-3L, 0 },
	TEST_c_c(casinh, -1.0L, -0x1.fp-10L, -8.813742198809567991336704287826445879025e-1L, -1.337909359557740912558349531052239112857e-3L, 0 },
	TEST_c_c(casinh, 0x1.fp-30L, 1.0L, 4.247867098745151888768727039216644758847e-5L, 1.570753848123921942730162693731872690232L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casinh, 0x1.fp-30L, -1.0L, 4.247867098745151888768727039216644758847e-5L, -1.570753848123921942730162693731872690232L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casinh, -0x1.fp-30L, 1.0L, -4.247867098745151888768727039216644758847e-5L, 1.570753848123921942730162693731872690232L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casinh, -0x1.fp-30L, -1.0L, -4.247867098745151888768727039216644758847e-5L, -1.570753848123921942730162693731872690232L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casinh, 1.0L, 0x1.fp-30L, 8.813735870195430258081932989769495326854e-1L, 1.275929984216518540252717485007112529021e-9L, 0 },
	TEST_c_c(casinh, -1.0L, 0x1.fp-30L, -8.813735870195430258081932989769495326854e-1L, 1.275929984216518540252717485007112529021e-9L, 0 },
	TEST_c_c(casinh, 1.0L, -0x1.fp-30L, 8.813735870195430258081932989769495326854e-1L, -1.275929984216518540252717485007112529021e-9L, 0 },
	TEST_c_c(casinh, -1.0L, -0x1.fp-30L, -8.813735870195430258081932989769495326854e-1L, -1.275929984216518540252717485007112529021e-9L, 0 },
	TEST_c_c(casinh, 0x1.fp-100L, 1.0L, 1.236292038260260888664514866457202186027e-15L, 1.570796326794895382939283431378862777584L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, 0x1.fp-100L, -1.0L, 1.236292038260260888664514866457202186027e-15L, -1.570796326794895382939283431378862777584L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0x1.fp-100L, 1.0L, -1.236292038260260888664514866457202186027e-15L, 1.570796326794895382939283431378862777584L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0x1.fp-100L, -1.0L, -1.236292038260260888664514866457202186027e-15L, -1.570796326794895382939283431378862777584L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, 1.0L, 0x1.fp-100L, 8.813735870195430252326093249797923090282e-1L, 1.080754735021050612990719608916167354321e-30L, 0 },
	TEST_c_c(casinh, -1.0L, 0x1.fp-100L, -8.813735870195430252326093249797923090282e-1L, 1.080754735021050612990719608916167354321e-30L, 0 },
	TEST_c_c(casinh, 1.0L, -0x1.fp-100L, 8.813735870195430252326093249797923090282e-1L, -1.080754735021050612990719608916167354321e-30L, 0 },
	TEST_c_c(casinh, -1.0L, -0x1.fp-100L, -8.813735870195430252326093249797923090282e-1L, -1.080754735021050612990719608916167354321e-30L, 0 },
	TEST_c_c(casinh, 0x1.fp-129L, 1.0L, 5.335635276982233498398987585285818977933e-20L, 1.570796326794896619177965338869929107115L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, 0x1.fp-129L, -1.0L, 5.335635276982233498398987585285818977933e-20L, -1.570796326794896619177965338869929107115L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0x1.fp-129L, 1.0L, -5.335635276982233498398987585285818977933e-20L, 1.570796326794896619177965338869929107115L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0x1.fp-129L, -1.0L, -5.335635276982233498398987585285818977933e-20L, -1.570796326794896619177965338869929107115L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, 1.0L, 0x1.fp-129L, 8.813735870195430252326093249797923090282e-1L, 2.013062564695348242280482517399205554874e-39L, UNDERFLOW_EXCEPTION_FLOAT },
	TEST_c_c(casinh, -1.0L, 0x1.fp-129L, -8.813735870195430252326093249797923090282e-1L, 2.013062564695348242280482517399205554874e-39L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casinh, 1.0L, -0x1.fp-129L, 8.813735870195430252326093249797923090282e-1L, -2.013062564695348242280482517399205554874e-39L, UNDERFLOW_EXCEPTION_FLOAT },
	TEST_c_c(casinh, -1.0L, -0x1.fp-129L, -8.813735870195430252326093249797923090282e-1L, -2.013062564695348242280482517399205554874e-39L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUXF },
#ifndef TEST_FLOAT
	TEST_c_c(casinh, 0x1.fp-1000L, 1.0L, 4.252291453851660175550490409247739011867e-151L, 1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, 0x1.fp-1000L, -1.0L, 4.252291453851660175550490409247739011867e-151L, -1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0x1.fp-1000L, 1.0L, -4.252291453851660175550490409247739011867e-151L, 1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0x1.fp-1000L, -1.0L, -4.252291453851660175550490409247739011867e-151L, -1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, 1.0L, 0x1.fp-1000L, 8.813735870195430252326093249797923090282e-1L, 1.278589251976747242280879285935084814093e-301L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM },
	TEST_c_c(casinh, -1.0L, 0x1.fp-1000L, -8.813735870195430252326093249797923090282e-1L, 1.278589251976747242280879285935084814093e-301L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM },
	TEST_c_c(casinh, 1.0L, -0x1.fp-1000L, 8.813735870195430252326093249797923090282e-1L, -1.278589251976747242280879285935084814093e-301L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM },
	TEST_c_c(casinh, -1.0L, -0x1.fp-1000L, -8.813735870195430252326093249797923090282e-1L, -1.278589251976747242280879285935084814093e-301L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM },
	TEST_c_c(casinh, 0x1.fp-1025L, 1.0L, 7.340879205566679497036857179189356754017e-155L, 1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, 0x1.fp-1025L, -1.0L, 7.340879205566679497036857179189356754017e-155L, -1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0x1.fp-1025L, 1.0L, -7.340879205566679497036857179189356754017e-155L, 1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0x1.fp-1025L, -1.0L, -7.340879205566679497036857179189356754017e-155L, -1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, 1.0L, 0x1.fp-1025L, 8.813735870195430252326093249797923090282e-1L, 3.810492908885321743133304375216617626230e-309L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(casinh, -1.0L, 0x1.fp-1025L, -8.813735870195430252326093249797923090282e-1L, 3.810492908885321743133304375216617626230e-309L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(casinh, 1.0L, -0x1.fp-1025L, 8.813735870195430252326093249797923090282e-1L, -3.810492908885321743133304375216617626230e-309L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(casinh, -1.0L, -0x1.fp-1025L, -8.813735870195430252326093249797923090282e-1L, -3.810492908885321743133304375216617626230e-309L, UNDERFLOW_EXCEPTION_DOUBLE },
#endif
#if defined TEST_LDOUBLE && LDBL_MIN_EXP <= -16381
	TEST_c_c(casinh, 0x1.fp-10000L, 1.0L, 9.854680208706673586644342922051388714633e-1506L, 1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(casinh, 0x1.fp-10000L, -1.0L, 9.854680208706673586644342922051388714633e-1506L, -1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(casinh, -0x1.fp-10000L, 1.0L, -9.854680208706673586644342922051388714633e-1506L, 1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(casinh, -0x1.fp-10000L, -1.0L, -9.854680208706673586644342922051388714633e-1506L, -1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(casinh, 1.0L, 0x1.fp-10000L, 8.813735870195430252326093249797923090282e-1L, 6.867047849047171855399183659351043150871e-3011L, 0 },
	TEST_c_c(casinh, -1.0L, 0x1.fp-10000L, -8.813735870195430252326093249797923090282e-1L, 6.867047849047171855399183659351043150871e-3011L, 0 },
	TEST_c_c(casinh, 1.0L, -0x1.fp-10000L, 8.813735870195430252326093249797923090282e-1L, -6.867047849047171855399183659351043150871e-3011L, 0 },
	TEST_c_c(casinh, -1.0L, -0x1.fp-10000L, -8.813735870195430252326093249797923090282e-1L, -6.867047849047171855399183659351043150871e-3011L, 0 },
	TEST_c_c(casinh, 0x1.fp-16385L, 1.0L, 9.023632056840860275214893047597614177639e-2467L, 1.570796326794896619231321691639751442099L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(casinh, 0x1.fp-16385L, -1.0L, 9.023632056840860275214893047597614177639e-2467L, -1.570796326794896619231321691639751442099L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(casinh, -0x1.fp-16385L, 1.0L, -9.023632056840860275214893047597614177639e-2467L, 1.570796326794896619231321691639751442099L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(casinh, -0x1.fp-16385L, -1.0L, -9.023632056840860275214893047597614177639e-2467L, -1.570796326794896619231321691639751442099L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(casinh, 1.0L, 0x1.fp-16385L, 8.813735870195430252326093249797923090282e-1L, 5.757683115456107044131264955348448954458e-4933L, UNDERFLOW_EXCEPTION },
	TEST_c_c(casinh, -1.0L, 0x1.fp-16385L, -8.813735870195430252326093249797923090282e-1L, 5.757683115456107044131264955348448954458e-4933L, UNDERFLOW_EXCEPTION },
	TEST_c_c(casinh, 1.0L, -0x1.fp-16385L, 8.813735870195430252326093249797923090282e-1L, -5.757683115456107044131264955348448954458e-4933L, UNDERFLOW_EXCEPTION },
	TEST_c_c(casinh, -1.0L, -0x1.fp-16385L, -8.813735870195430252326093249797923090282e-1L, -5.757683115456107044131264955348448954458e-4933L, UNDERFLOW_EXCEPTION },
#endif

	TEST_c_c(casinh, 0x1p-23L, 0x1.000002p0L, 5.364668491573609633134147164031476452679e-4L, 1.570574114956455764594481054234834678422L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casinh, 0x1p-23L, -0x1.000002p0L, 5.364668491573609633134147164031476452679e-4L, -1.570574114956455764594481054234834678422L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casinh, -0x1p-23L, 0x1.000002p0L, -5.364668491573609633134147164031476452679e-4L, 1.570574114956455764594481054234834678422L, 0 },
	TEST_c_c(casinh, -0x1p-23L, -0x1.000002p0L, -5.364668491573609633134147164031476452679e-4L, -1.570574114956455764594481054234834678422L, 0 },
	TEST_c_c(casinh, 0x1.000002p0L, 0x1p-23L, 8.813736713132400470205730751186547909968e-1L, 8.429369199749229560964789467980644296420e-8L, 0 },
	TEST_c_c(casinh, -0x1.000002p0L, 0x1p-23L, -8.813736713132400470205730751186547909968e-1L, 8.429369199749229560964789467980644296420e-8L, 0 },
	TEST_c_c(casinh, 0x1.000002p0L, -0x1p-23L, 8.813736713132400470205730751186547909968e-1L, -8.429369199749229560964789467980644296420e-8L, 0 },
	TEST_c_c(casinh, -0x1.000002p0L, -0x1p-23L, -8.813736713132400470205730751186547909968e-1L, -8.429369199749229560964789467980644296420e-8L, 0 },
	TEST_c_c(casinh, 0x1.fp-129L, 0x1.000002p0L, 4.882812451493617206486388134172712975070e-4L, 1.570796326794896619231321691639751436268L, 0 },
	TEST_c_c(casinh, 0x1.fp-129L, -0x1.000002p0L, 4.882812451493617206486388134172712975070e-4L, -1.570796326794896619231321691639751436268L, 0 },
	TEST_c_c(casinh, -0x1.fp-129L, 0x1.000002p0L, -4.882812451493617206486388134172712975070e-4L, 1.570796326794896619231321691639751436268L, 0 },
	TEST_c_c(casinh, -0x1.fp-129L, -0x1.000002p0L, -4.882812451493617206486388134172712975070e-4L, -1.570796326794896619231321691639751436268L, 0 },
	TEST_c_c(casinh, 0x1.000002p0L, 0x1.fp-129L, 8.813736713132375348727889167749389235161e-1L, 2.013062444707472738895109955455676357057e-39L, UNDERFLOW_EXCEPTION_FLOAT },
	TEST_c_c(casinh, -0x1.000002p0L, 0x1.fp-129L, -8.813736713132375348727889167749389235161e-1L, 2.013062444707472738895109955455676357057e-39L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casinh, 0x1.000002p0L, -0x1.fp-129L, 8.813736713132375348727889167749389235161e-1L, -2.013062444707472738895109955455676357057e-39L, UNDERFLOW_EXCEPTION_FLOAT },
	TEST_c_c(casinh, -0x1.000002p0L, -0x1.fp-129L, -8.813736713132375348727889167749389235161e-1L, -2.013062444707472738895109955455676357057e-39L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casinh, 0.0L, 0x1.000002p0L, 4.882812451493617206486388134172712975070e-4L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(casinh, 0.0L, -0x1.000002p0L, 4.882812451493617206486388134172712975070e-4L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(casinh, -0.0L, 0x1.000002p0L, -4.882812451493617206486388134172712975070e-4L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(casinh, -0.0L, -0x1.000002p0L, -4.882812451493617206486388134172712975070e-4L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(casinh, 0x1.000002p0L, 0.0L, 8.813736713132375348727889167749389235161e-1L, 0.0L, 0 },
	TEST_c_c(casinh, -0x1.000002p0L, 0.0L, -8.813736713132375348727889167749389235161e-1L, 0.0L, 0 },
	TEST_c_c(casinh, 0x1.000002p0L, -0.0L, 8.813736713132375348727889167749389235161e-1L, -0.0L, 0 },
	TEST_c_c(casinh, -0x1.000002p0L, -0.0L, -8.813736713132375348727889167749389235161e-1L, -0.0L, 0|XFAIL_NATIVE_LINUX },
#ifndef TEST_FLOAT
	TEST_c_c(casinh, 0x1p-52L, 0x1.0000000000001p0L, 2.315303644582684770975188768022139415020e-8L, 1.570796317204594913251280305810847349436L, 0 },
	TEST_c_c(casinh, 0x1p-52L, -0x1.0000000000001p0L, 2.315303644582684770975188768022139415020e-8L, -1.570796317204594913251280305810847349436L, 0 },
	TEST_c_c(casinh, -0x1p-52L, 0x1.0000000000001p0L, -2.315303644582684770975188768022139415020e-8L, 1.570796317204594913251280305810847349436L, 0 },
	TEST_c_c(casinh, -0x1p-52L, -0x1.0000000000001p0L, -2.315303644582684770975188768022139415020e-8L, -1.570796317204594913251280305810847349436L, 0 },
	TEST_c_c(casinh, 0x1.0000000000001p0L, 0x1p-52L, 8.813735870195431822418551933572982483664e-1L, 1.570092458683774885078102529858632363236e-16L, 0 },
	TEST_c_c(casinh, -0x1.0000000000001p0L, 0x1p-52L, -8.813735870195431822418551933572982483664e-1L, 1.570092458683774885078102529858632363236e-16L, 0 },
	TEST_c_c(casinh, 0x1.0000000000001p0L, -0x1p-52L, 8.813735870195431822418551933572982483664e-1L, -1.570092458683774885078102529858632363236e-16L, 0 },
	TEST_c_c(casinh, -0x1.0000000000001p0L, -0x1p-52L, -8.813735870195431822418551933572982483664e-1L, -1.570092458683774885078102529858632363236e-16L, 0 },
	TEST_c_c(casinh, 0x1.fp-1025L, 0x1.0000000000001p0L, 2.107342425544701550354780375182800088393e-8L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(casinh, 0x1.fp-1025L, -0x1.0000000000001p0L, 2.107342425544701550354780375182800088393e-8L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(casinh, -0x1.fp-1025L, 0x1.0000000000001p0L, -2.107342425544701550354780375182800088393e-8L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(casinh, -0x1.fp-1025L, -0x1.0000000000001p0L, -2.107342425544701550354780375182800088393e-8L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(casinh, 0x1.0000000000001p0L, 0x1.fp-1025L, 8.813735870195431822418551933572895326024e-1L, 3.810492908885321320083608113679347200012e-309L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(casinh, -0x1.0000000000001p0L, 0x1.fp-1025L, -8.813735870195431822418551933572895326024e-1L, 3.810492908885321320083608113679347200012e-309L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(casinh, 0x1.0000000000001p0L, -0x1.fp-1025L, 8.813735870195431822418551933572895326024e-1L, -3.810492908885321320083608113679347200012e-309L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(casinh, -0x1.0000000000001p0L, -0x1.fp-1025L, -8.813735870195431822418551933572895326024e-1L, -3.810492908885321320083608113679347200012e-309L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(casinh, 0.0L, 0x1.0000000000001p0L, 2.107342425544701550354780375182800088393e-8L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(casinh, 0.0L, -0x1.0000000000001p0L, 2.107342425544701550354780375182800088393e-8L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(casinh, -0.0L, 0x1.0000000000001p0L, -2.107342425544701550354780375182800088393e-8L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(casinh, -0.0L, -0x1.0000000000001p0L, -2.107342425544701550354780375182800088393e-8L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(casinh, 0x1.0000000000001p0L, 0.0L, 8.813735870195431822418551933572895326024e-1L, 0.0L, 0 },
	TEST_c_c(casinh, -0x1.0000000000001p0L, 0.0L, -8.813735870195431822418551933572895326024e-1L, 0.0L, 0 },
	TEST_c_c(casinh, 0x1.0000000000001p0L, -0.0L, 8.813735870195431822418551933572895326024e-1L, -0.0L, 0 },
	TEST_c_c(casinh, -0x1.0000000000001p0L, -0.0L, -8.813735870195431822418551933572895326024e-1L, -0.0L, 0|XFAIL_NATIVE_LINUX },
#endif
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	TEST_c_c(casinh, 0x1p-63L, 0x1.0000000000000002p0L, 5.116146586219826555037807251857670783420e-10L, 1.570796326582978888921215348380499122131L, 0 },
	TEST_c_c(casinh, 0x1p-63L, -0x1.0000000000000002p0L, 5.116146586219826555037807251857670783420e-10L, -1.570796326582978888921215348380499122131L, 0 },
	TEST_c_c(casinh, -0x1p-63L, 0x1.0000000000000002p0L, -5.116146586219826555037807251857670783420e-10L, 1.570796326582978888921215348380499122131L, 0 },
	TEST_c_c(casinh, -0x1p-63L, -0x1.0000000000000002p0L, -5.116146586219826555037807251857670783420e-10L, -1.570796326582978888921215348380499122131L, 0 },
	TEST_c_c(casinh, 0x1.0000000000000002p0L, 0x1p-63L, 8.813735870195430253092739958139610131001e-1L, 7.666467083416870406778649849746878368519e-20L, 0 },
	TEST_c_c(casinh, -0x1.0000000000000002p0L, 0x1p-63L, -8.813735870195430253092739958139610131001e-1L, 7.666467083416870406778649849746878368519e-20L, 0 },
	TEST_c_c(casinh, 0x1.0000000000000002p0L, -0x1p-63L, 8.813735870195430253092739958139610131001e-1L, -7.666467083416870406778649849746878368519e-20L, 0 },
	TEST_c_c(casinh, -0x1.0000000000000002p0L, -0x1p-63L, -8.813735870195430253092739958139610131001e-1L, -7.666467083416870406778649849746878368519e-20L, 0 },
# if LDBL_MIN_EXP <= -16381
	TEST_c_c(casinh, 0x1.fp-16385L, 0x1.0000000000000002p0L, 4.656612873077392578082927418388212703712e-10L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(casinh, 0x1.fp-16385L, -0x1.0000000000000002p0L, 4.656612873077392578082927418388212703712e-10L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(casinh, -0x1.fp-16385L, 0x1.0000000000000002p0L, -4.656612873077392578082927418388212703712e-10L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(casinh, -0x1.fp-16385L, -0x1.0000000000000002p0L, -4.656612873077392578082927418388212703712e-10L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(casinh, 0x1.0000000000000002p0L, 0x1.fp-16385L, 8.813735870195430253092739958139610130980e-1L, 5.757683115456107043819140328235418018963e-4933L, UNDERFLOW_EXCEPTION },
	TEST_c_c(casinh, -0x1.0000000000000002p0L, 0x1.fp-16385L, -8.813735870195430253092739958139610130980e-1L, 5.757683115456107043819140328235418018963e-4933L, UNDERFLOW_EXCEPTION },
	TEST_c_c(casinh, 0x1.0000000000000002p0L, -0x1.fp-16385L, 8.813735870195430253092739958139610130980e-1L, -5.757683115456107043819140328235418018963e-4933L, UNDERFLOW_EXCEPTION },
	TEST_c_c(casinh, -0x1.0000000000000002p0L, -0x1.fp-16385L, -8.813735870195430253092739958139610130980e-1L, -5.757683115456107043819140328235418018963e-4933L, UNDERFLOW_EXCEPTION },
# endif
	TEST_c_c(casinh, 0.0L, 0x1.0000000000000002p0L, 4.656612873077392578082927418388212703712e-10L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(casinh, 0.0L, -0x1.0000000000000002p0L, 4.656612873077392578082927418388212703712e-10L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(casinh, -0.0L, 0x1.0000000000000002p0L, -4.656612873077392578082927418388212703712e-10L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(casinh, -0.0L, -0x1.0000000000000002p0L, -4.656612873077392578082927418388212703712e-10L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(casinh, 0x1.0000000000000002p0L, 0.0L, 8.813735870195430253092739958139610130980e-1L, 0.0L, 0 },
	TEST_c_c(casinh, -0x1.0000000000000002p0L, 0.0L, -8.813735870195430253092739958139610130980e-1L, 0.0L, 0 },
	TEST_c_c(casinh, 0x1.0000000000000002p0L, -0.0L, 8.813735870195430253092739958139610130980e-1L, -0.0L, 0 },
	TEST_c_c(casinh, -0x1.0000000000000002p0L, -0.0L, -8.813735870195430253092739958139610130980e-1L, -0.0L, 0|XFAIL_NATIVE_LINUXL },
#endif
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 106
	TEST_c_c(casinh, 0x1p-106L, 0x1.000000000000000000000000008p0L, 2.285028863093221674154232933662774454211e-16L, 1.570796326794896565289107467733682961928L, 0 },
	TEST_c_c(casinh, 0x1p-106L, -0x1.000000000000000000000000008p0L, 2.285028863093221674154232933662774454211e-16L, -1.570796326794896565289107467733682961928L, 0 },
	TEST_c_c(casinh, -0x1p-106L, 0x1.000000000000000000000000008p0L, -2.285028863093221674154232933662774454211e-16L, 1.570796326794896565289107467733682961928L, 0 },
	TEST_c_c(casinh, -0x1p-106L, -0x1.000000000000000000000000008p0L, -2.285028863093221674154232933662774454211e-16L, -1.570796326794896565289107467733682961928L, 0 },
	TEST_c_c(casinh, 0x1.000000000000000000000000008p0L, 0x1p-106L, 8.813735870195430252326093249798097405561e-1L, 8.715763992105246878957416200936726072500e-33L, 0 },
	TEST_c_c(casinh, -0x1.000000000000000000000000008p0L, 0x1p-106L, -8.813735870195430252326093249798097405561e-1L, 8.715763992105246878957416200936726072500e-33L, 0 },
	TEST_c_c(casinh, 0x1.000000000000000000000000008p0L, -0x1p-106L, 8.813735870195430252326093249798097405561e-1L, -8.715763992105246878957416200936726072500e-33L, 0 },
	TEST_c_c(casinh, -0x1.000000000000000000000000008p0L, -0x1p-106L, -8.813735870195430252326093249798097405561e-1L, -8.715763992105246878957416200936726072500e-33L, 0 },
	TEST_c_c(casinh, 0x1.fp-1025L, 0x1.000000000000000000000000008p0L, 2.220446049250313080847263336181636063482e-16L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(casinh, 0x1.fp-1025L, -0x1.000000000000000000000000008p0L, 2.220446049250313080847263336181636063482e-16L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(casinh, -0x1.fp-1025L, 0x1.000000000000000000000000008p0L, -2.220446049250313080847263336181636063482e-16L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(casinh, -0x1.fp-1025L, -0x1.000000000000000000000000008p0L, -2.220446049250313080847263336181636063482e-16L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(casinh, 0x1.000000000000000000000000008p0L, 0x1.fp-1025L, 8.813735870195430252326093249798097405561e-1L, 3.810492908885321743133304375216570658278e-309L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(casinh, -0x1.000000000000000000000000008p0L, 0x1.fp-1025L, -8.813735870195430252326093249798097405561e-1L, 3.810492908885321743133304375216570658278e-309L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(casinh, 0x1.000000000000000000000000008p0L, -0x1.fp-1025L, 8.813735870195430252326093249798097405561e-1L, -3.810492908885321743133304375216570658278e-309L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(casinh, -0x1.000000000000000000000000008p0L, -0x1.fp-1025L, -8.813735870195430252326093249798097405561e-1L, -3.810492908885321743133304375216570658278e-309L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(casinh, 0.0L, 0x1.000000000000000000000000008p0L, 2.220446049250313080847263336181636063482e-16L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(casinh, 0.0L, -0x1.000000000000000000000000008p0L, 2.220446049250313080847263336181636063482e-16L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(casinh, -0.0L, 0x1.000000000000000000000000008p0L, -2.220446049250313080847263336181636063482e-16L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(casinh, -0.0L, -0x1.000000000000000000000000008p0L, -2.220446049250313080847263336181636063482e-16L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(casinh, 0x1.000000000000000000000000008p0L, 0.0L, 8.813735870195430252326093249798097405561e-1L, 0.0L, 0 },
	TEST_c_c(casinh, -0x1.000000000000000000000000008p0L, 0.0L, -8.813735870195430252326093249798097405561e-1L, 0.0L, 0 },
	TEST_c_c(casinh, 0x1.000000000000000000000000008p0L, -0.0L, 8.813735870195430252326093249798097405561e-1L, -0.0L, 0 },
	TEST_c_c(casinh, -0x1.000000000000000000000000008p0L, -0.0L, -8.813735870195430252326093249798097405561e-1L, -0.0L, 0 },
#endif
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 113
	TEST_c_c(casinh, 0x1p-113L, 0x1.0000000000000000000000000001p0L, 2.019699255375255198156433710951064632386e-17L, 1.570796326794896614463458507897073960405L, 0 },
	TEST_c_c(casinh, 0x1p-113L, -0x1.0000000000000000000000000001p0L, 2.019699255375255198156433710951064632386e-17L, -1.570796326794896614463458507897073960405L, 0 },
	TEST_c_c(casinh, -0x1p-113L, 0x1.0000000000000000000000000001p0L, -2.019699255375255198156433710951064632386e-17L, 1.570796326794896614463458507897073960405L, 0 },
	TEST_c_c(casinh, -0x1p-113L, -0x1.0000000000000000000000000001p0L, -2.019699255375255198156433710951064632386e-17L, -1.570796326794896614463458507897073960405L, 0 },
	TEST_c_c(casinh, 0x1.0000000000000000000000000001p0L, 0x1p-113L, 8.813735870195430252326093249797924452120e-1L, 6.809190618832224124185481406981900518193e-35L, 0 },
	TEST_c_c(casinh, -0x1.0000000000000000000000000001p0L, 0x1p-113L, -8.813735870195430252326093249797924452120e-1L, 6.809190618832224124185481406981900518193e-35L, 0 },
	TEST_c_c(casinh, 0x1.0000000000000000000000000001p0L, -0x1p-113L, 8.813735870195430252326093249797924452120e-1L, -6.809190618832224124185481406981900518193e-35L, 0 },
	TEST_c_c(casinh, -0x1.0000000000000000000000000001p0L, -0x1p-113L, -8.813735870195430252326093249797924452120e-1L, -6.809190618832224124185481406981900518193e-35L, 0 },
	TEST_c_c(casinh, 0x1.fp-16385L, 0x1.0000000000000000000000000001p0L, 1.962615573354718824241727964954454332780e-17L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(casinh, 0x1.fp-16385L, -0x1.0000000000000000000000000001p0L, 1.962615573354718824241727964954454332780e-17L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(casinh, -0x1.fp-16385L, 0x1.0000000000000000000000000001p0L, -1.962615573354718824241727964954454332780e-17L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(casinh, -0x1.fp-16385L, -0x1.0000000000000000000000000001p0L, -1.962615573354718824241727964954454332780e-17L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(casinh, 0x1.0000000000000000000000000001p0L, 0x1.fp-16385L, 8.813735870195430252326093249797924452120e-1L, 5.757683115456107044131264955348448400014e-4933L, UNDERFLOW_EXCEPTION },
	TEST_c_c(casinh, -0x1.0000000000000000000000000001p0L, 0x1.fp-16385L, -8.813735870195430252326093249797924452120e-1L, 5.757683115456107044131264955348448400014e-4933L, UNDERFLOW_EXCEPTION },
	TEST_c_c(casinh, 0x1.0000000000000000000000000001p0L, -0x1.fp-16385L, 8.813735870195430252326093249797924452120e-1L, -5.757683115456107044131264955348448400014e-4933L, UNDERFLOW_EXCEPTION },
	TEST_c_c(casinh, -0x1.0000000000000000000000000001p0L, -0x1.fp-16385L, -8.813735870195430252326093249797924452120e-1L, -5.757683115456107044131264955348448400014e-4933L, UNDERFLOW_EXCEPTION },
	TEST_c_c(casinh, 0.0L, 0x1.0000000000000000000000000001p0L, 1.962615573354718824241727964954454332780e-17L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(casinh, 0.0L, -0x1.0000000000000000000000000001p0L, 1.962615573354718824241727964954454332780e-17L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(casinh, -0.0L, 0x1.0000000000000000000000000001p0L, -1.962615573354718824241727964954454332780e-17L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(casinh, -0.0L, -0x1.0000000000000000000000000001p0L, -1.962615573354718824241727964954454332780e-17L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(casinh, 0x1.0000000000000000000000000001p0L, 0.0L, 8.813735870195430252326093249797924452120e-1L, 0.0L, 0 },
	TEST_c_c(casinh, -0x1.0000000000000000000000000001p0L, 0.0L, -8.813735870195430252326093249797924452120e-1L, 0.0L, 0 },
	TEST_c_c(casinh, 0x1.0000000000000000000000000001p0L, -0.0L, 8.813735870195430252326093249797924452120e-1L, -0.0L, 0 },
	TEST_c_c(casinh, -0x1.0000000000000000000000000001p0L, -0.0L, -8.813735870195430252326093249797924452120e-1L, -0.0L, 0 },
#endif

	TEST_c_c(casinh, 0x1p-23L, 0x0.ffffffp0L, 2.714321200917194650737217746780928423385e-4L, 1.570357140408705570520377172865353621698L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casinh, 0x1p-23L, -0x0.ffffffp0L, 2.714321200917194650737217746780928423385e-4L, -1.570357140408705570520377172865353621698L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casinh, -0x1p-23L, 0x0.ffffffp0L, -2.714321200917194650737217746780928423385e-4L, 1.570357140408705570520377172865353621698L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casinh, -0x1p-23L, -0x0.ffffffp0L, -2.714321200917194650737217746780928423385e-4L, -1.570357140408705570520377172865353621698L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casinh, 0x0.ffffffp0L, 0x1p-23L, 8.813735448726963984495965873956465777250e-1L, 8.429369953393598499000760938112968755257e-8L, 0 },
	TEST_c_c(casinh, -0x0.ffffffp0L, 0x1p-23L, -8.813735448726963984495965873956465777250e-1L, 8.429369953393598499000760938112968755257e-8L, 0 },
	TEST_c_c(casinh, 0x0.ffffffp0L, -0x1p-23L, 8.813735448726963984495965873956465777250e-1L, -8.429369953393598499000760938112968755257e-8L, 0 },
	TEST_c_c(casinh, -0x0.ffffffp0L, -0x1p-23L, -8.813735448726963984495965873956465777250e-1L, -8.429369953393598499000760938112968755257e-8L, 0 },
	TEST_c_c(casinh, 0x1.fp-129L, 0x0.ffffffp0L, 8.245504387859737323891843603996428534945e-36L, 1.570451059810180415643718442157112705601L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, 0x1.fp-129L, -0x0.ffffffp0L, 8.245504387859737323891843603996428534945e-36L, -1.570451059810180415643718442157112705601L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0x1.fp-129L, 0x0.ffffffp0L, -8.245504387859737323891843603996428534945e-36L, 1.570451059810180415643718442157112705601L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0x1.fp-129L, -0x0.ffffffp0L, -8.245504387859737323891843603996428534945e-36L, -1.570451059810180415643718442157112705601L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, 0x0.ffffffp0L, 0x1.fp-129L, 8.813735448726938863015878255140556727969e-1L, 2.013062624689288675911339929224634593425e-39L, UNDERFLOW_EXCEPTION_FLOAT },
	TEST_c_c(casinh, -0x0.ffffffp0L, 0x1.fp-129L, -8.813735448726938863015878255140556727969e-1L, 2.013062624689288675911339929224634593425e-39L, UNDERFLOW_EXCEPTION_FLOAT },
	TEST_c_c(casinh, 0x0.ffffffp0L, -0x1.fp-129L, 8.813735448726938863015878255140556727969e-1L, -2.013062624689288675911339929224634593425e-39L, UNDERFLOW_EXCEPTION_FLOAT },
	TEST_c_c(casinh, -0x0.ffffffp0L, -0x1.fp-129L, -8.813735448726938863015878255140556727969e-1L, -2.013062624689288675911339929224634593425e-39L, UNDERFLOW_EXCEPTION_FLOAT },
	TEST_c_c(casinh, 0.0L, 0x0.ffffffp0L, 0.0L, 1.570451059810180415643718442157112705601L, 0 },
	TEST_c_c(casinh, 0.0L, -0x0.ffffffp0L, 0.0L, -1.570451059810180415643718442157112705601L, 0 },
	TEST_c_c(casinh, -0.0L, 0x0.ffffffp0L, -0.0L, 1.570451059810180415643718442157112705601L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0.0L, -0x0.ffffffp0L, -0.0L, -1.570451059810180415643718442157112705601L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, 0x0.ffffffp0L, 0.0L, 8.813735448726938863015878255140556727969e-1L, 0.0L, 0 },
	TEST_c_c(casinh, -0x0.ffffffp0L, 0.0L, -8.813735448726938863015878255140556727969e-1L, 0.0L, 0 },
	TEST_c_c(casinh, 0x0.ffffffp0L, -0.0L, 8.813735448726938863015878255140556727969e-1L, -0.0L, 0 },
	TEST_c_c(casinh, -0x0.ffffffp0L, -0.0L, -8.813735448726938863015878255140556727969e-1L, -0.0L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, 0x1p-23L, 0.5L, 1.376510308240943236356088341381173571841e-7L, 5.235987755982934033165770729745469098254e-1L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casinh, 0x1p-23L, -0.5L, 1.376510308240943236356088341381173571841e-7L, -5.235987755982934033165770729745469098254e-1L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casinh, -0x1p-23L, 0.5L, -1.376510308240943236356088341381173571841e-7L, 5.235987755982934033165770729745469098254e-1L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casinh, -0x1p-23L, -0.5L, -1.376510308240943236356088341381173571841e-7L, -5.235987755982934033165770729745469098254e-1L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casinh, 0.5L, 0x1p-23L, 4.812118250596059896127318386463676808798e-1L, 1.066240299940009780479664302917201696886e-7L, 0 },
	TEST_c_c(casinh, -0.5L, 0x1p-23L, -4.812118250596059896127318386463676808798e-1L, 1.066240299940009780479664302917201696886e-7L, 0 },
	TEST_c_c(casinh, 0.5L, -0x1p-23L, 4.812118250596059896127318386463676808798e-1L, -1.066240299940009780479664302917201696886e-7L, 0 },
	TEST_c_c(casinh, -0.5L, -0x1p-23L, -4.812118250596059896127318386463676808798e-1L, -1.066240299940009780479664302917201696886e-7L, 0 },
	TEST_c_c(casinh, 0x1.fp-129L, 0.5L, 3.287317402534702257036015056278368274737e-39L, 5.235987755982988730771072305465838140329e-1L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, 0x1.fp-129L, -0.5L, 3.287317402534702257036015056278368274737e-39L, -5.235987755982988730771072305465838140329e-1L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0x1.fp-129L, 0.5L, -3.287317402534702257036015056278368274737e-39L, 5.235987755982988730771072305465838140329e-1L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0x1.fp-129L, -0.5L, -3.287317402534702257036015056278368274737e-39L, -5.235987755982988730771072305465838140329e-1L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, 0.5L, 0x1.fp-129L, 4.812118250596034474977589134243684231352e-1L, 2.546345110742945032959687790021055102355e-39L, UNDERFLOW_EXCEPTION_FLOAT },
	TEST_c_c(casinh, -0.5L, 0x1.fp-129L, -4.812118250596034474977589134243684231352e-1L, 2.546345110742945032959687790021055102355e-39L, UNDERFLOW_EXCEPTION_FLOAT },
	TEST_c_c(casinh, 0.5L, -0x1.fp-129L, 4.812118250596034474977589134243684231352e-1L, -2.546345110742945032959687790021055102355e-39L, UNDERFLOW_EXCEPTION_FLOAT },
	TEST_c_c(casinh, -0.5L, -0x1.fp-129L, -4.812118250596034474977589134243684231352e-1L, -2.546345110742945032959687790021055102355e-39L, UNDERFLOW_EXCEPTION_FLOAT },
	TEST_c_c(casinh, 0x1p-23L, 0x1p-23L, 1.192092895507818146886315028596704749235e-7L, 1.192092895507806853113684971258850504935e-7L, 0 },
	TEST_c_c(casinh, 0x1p-23L, -0x1p-23L, 1.192092895507818146886315028596704749235e-7L, -1.192092895507806853113684971258850504935e-7L, 0 },
	TEST_c_c(casinh, -0x1p-23L, 0x1p-23L, -1.192092895507818146886315028596704749235e-7L, 1.192092895507806853113684971258850504935e-7L, 0 },
	TEST_c_c(casinh, -0x1p-23L, -0x1p-23L, -1.192092895507818146886315028596704749235e-7L, -1.192092895507806853113684971258850504935e-7L, 0 },
	TEST_c_c(casinh, 0x1.fp-129L, 0x1p-23L, 2.846900380897747786805634596726756660388e-39L, 1.192092895507815323443157514352519154304e-7L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, 0x1.fp-129L, -0x1p-23L, 2.846900380897747786805634596726756660388e-39L, -1.192092895507815323443157514352519154304e-7L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0x1.fp-129L, 0x1p-23L, -2.846900380897747786805634596726756660388e-39L, 1.192092895507815323443157514352519154304e-7L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0x1.fp-129L, -0x1p-23L, -2.846900380897747786805634596726756660388e-39L, -1.192092895507815323443157514352519154304e-7L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	/* Bug 15319: underflow exception may be missing.  */
	TEST_c_c(casinh, 0x1p-23L, 0x1.fp-129L, 1.192092895507809676556842485683592032154e-7L, 2.846900380897707329917933005874691056564e-39L, UNDERFLOW_EXCEPTION_OK_FLOAT },
	TEST_c_c(casinh, -0x1p-23L, 0x1.fp-129L, -1.192092895507809676556842485683592032154e-7L, 2.846900380897707329917933005874691056564e-39L, UNDERFLOW_EXCEPTION_OK_FLOAT },
	TEST_c_c(casinh, 0x1p-23L, -0x1.fp-129L, 1.192092895507809676556842485683592032154e-7L, -2.846900380897707329917933005874691056564e-39L, UNDERFLOW_EXCEPTION_OK_FLOAT },
	TEST_c_c(casinh, -0x1p-23L, -0x1.fp-129L, -1.192092895507809676556842485683592032154e-7L, -2.846900380897707329917933005874691056564e-39L, UNDERFLOW_EXCEPTION_OK_FLOAT },
	TEST_c_c(casinh, 0.0L, 0x1p-23L, 0.0L, 1.192092895507815323443157514352519154304e-7L, 0 },
	TEST_c_c(casinh, 0.0L, -0x1p-23L, 0.0L, -1.192092895507815323443157514352519154304e-7L, 0 },
	TEST_c_c(casinh, -0.0L, 0x1p-23L, -0.0L, 1.192092895507815323443157514352519154304e-7L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0.0L, -0x1p-23L, -0.0L, -1.192092895507815323443157514352519154304e-7L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, 0x1p-23L, 0.0L, 1.192092895507809676556842485683592032154e-7L, 0.0L, 0 },
	TEST_c_c(casinh, -0x1p-23L, 0.0L, -1.192092895507809676556842485683592032154e-7L, 0.0L, 0 },
	TEST_c_c(casinh, 0x1p-23L, -0.0L, 1.192092895507809676556842485683592032154e-7L, -0.0L, 0 },
	TEST_c_c(casinh, -0x1p-23L, -0.0L, -1.192092895507809676556842485683592032154e-7L, -0.0L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, 0x1.fp-129L, 0x1.fp-129L, 2.846900380897727558361783801085126250967e-39L, 2.846900380897727558361783801085126250967e-39L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, 0x1.fp-129L, -0x1.fp-129L, 2.846900380897727558361783801085126250967e-39L, -2.846900380897727558361783801085126250967e-39L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0x1.fp-129L, 0x1.fp-129L, -2.846900380897727558361783801085126250967e-39L, 2.846900380897727558361783801085126250967e-39L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0x1.fp-129L, -0x1.fp-129L, -2.846900380897727558361783801085126250967e-39L, -2.846900380897727558361783801085126250967e-39L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
#ifndef TEST_FLOAT
	TEST_c_c(casinh, 0x1p-52L, 0x0.fffffffffffff8p0L, 1.171456840272878582596796205397918831268e-8L, 1.570796307840326780080580569360500172043L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, 0x1p-52L, -0x0.fffffffffffff8p0L, 1.171456840272878582596796205397918831268e-8L, -1.570796307840326780080580569360500172043L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0x1p-52L, 0x0.fffffffffffff8p0L, -1.171456840272878582596796205397918831268e-8L, 1.570796307840326780080580569360500172043L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0x1p-52L, -0x0.fffffffffffff8p0L, -1.171456840272878582596796205397918831268e-8L, -1.570796307840326780080580569360500172043L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, 0x0.fffffffffffff8p0L, 0x1p-52L, 8.813735870195429467279863907910458761820e-1L, 1.570092458683775146551022293016031474627e-16L, 0 },
	TEST_c_c(casinh, -0x0.fffffffffffff8p0L, 0x1p-52L, -8.813735870195429467279863907910458761820e-1L, 1.570092458683775146551022293016031474627e-16L, 0 },
	TEST_c_c(casinh, 0x0.fffffffffffff8p0L, -0x1p-52L, 8.813735870195429467279863907910458761820e-1L, -1.570092458683775146551022293016031474627e-16L, 0 },
	TEST_c_c(casinh, -0x0.fffffffffffff8p0L, -0x1p-52L, -8.813735870195429467279863907910458761820e-1L, -1.570092458683775146551022293016031474627e-16L, 0 },
	TEST_c_c(casinh, 0x1.fp-1025L, 0x0.fffffffffffff8p0L, 3.616396521699973256461764099945789620604e-301L, 1.570796311893735425383665303776316016594L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, 0x1.fp-1025L, -0x0.fffffffffffff8p0L, 3.616396521699973256461764099945789620604e-301L, -1.570796311893735425383665303776316016594L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0x1.fp-1025L, 0x0.fffffffffffff8p0L, -3.616396521699973256461764099945789620604e-301L, 1.570796311893735425383665303776316016594L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0x1.fp-1025L, -0x0.fffffffffffff8p0L, -3.616396521699973256461764099945789620604e-301L, -1.570796311893735425383665303776316016594L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, 0x0.fffffffffffff8p0L, 0x1.fp-1025L, 8.813735870195429467279863907910371604180e-1L, 3.810492908885321954658152505985270452320e-309L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(casinh, -0x0.fffffffffffff8p0L, 0x1.fp-1025L, -8.813735870195429467279863907910371604180e-1L, 3.810492908885321954658152505985270452320e-309L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(casinh, 0x0.fffffffffffff8p0L, -0x1.fp-1025L, 8.813735870195429467279863907910371604180e-1L, -3.810492908885321954658152505985270452320e-309L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(casinh, -0x0.fffffffffffff8p0L, -0x1.fp-1025L, -8.813735870195429467279863907910371604180e-1L, -3.810492908885321954658152505985270452320e-309L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(casinh, 0.0L, 0x0.fffffffffffff8p0L, 0.0L, 1.570796311893735425383665303776316016594L, 0 },
	TEST_c_c(casinh, 0.0L, -0x0.fffffffffffff8p0L, 0.0L, -1.570796311893735425383665303776316016594L, 0 },
	TEST_c_c(casinh, -0.0L, 0x0.fffffffffffff8p0L, -0.0L, 1.570796311893735425383665303776316016594L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0.0L, -0x0.fffffffffffff8p0L, -0.0L, -1.570796311893735425383665303776316016594L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, 0x0.fffffffffffff8p0L, 0.0L, 8.813735870195429467279863907910371604180e-1L, 0.0L, 0 },
	TEST_c_c(casinh, -0x0.fffffffffffff8p0L, 0.0L, -8.813735870195429467279863907910371604180e-1L, 0.0L, 0 },
	TEST_c_c(casinh, 0x0.fffffffffffff8p0L, -0.0L, 8.813735870195429467279863907910371604180e-1L, -0.0L, 0 },
	TEST_c_c(casinh, -0x0.fffffffffffff8p0L, -0.0L, -8.813735870195429467279863907910371604180e-1L, -0.0L, 0|XFAIL_NATIVE_LINUX },
#endif
	TEST_c_c(casinh, 0x1p-52L, 0.5L, 2.563950248511418570403591756798643804971e-16L, 5.235987755982988730771072305465648369889e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, 0x1p-52L, -0.5L, 2.563950248511418570403591756798643804971e-16L, -5.235987755982988730771072305465648369889e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0x1p-52L, 0.5L, -2.563950248511418570403591756798643804971e-16L, 5.235987755982988730771072305465648369889e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0x1p-52L, -0.5L, -2.563950248511418570403591756798643804971e-16L, -5.235987755982988730771072305465648369889e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, 0.5L, 0x1p-52L, 4.812118250596034474977589134243772428682e-1L, 1.986027322597818397661816253158024383707e-16L, 0 },
	TEST_c_c(casinh, -0.5L, 0x1p-52L, -4.812118250596034474977589134243772428682e-1L, 1.986027322597818397661816253158024383707e-16L, 0 },
	TEST_c_c(casinh, 0.5L, -0x1p-52L, 4.812118250596034474977589134243772428682e-1L, -1.986027322597818397661816253158024383707e-16L, 0 },
	TEST_c_c(casinh, -0.5L, -0x1p-52L, -4.812118250596034474977589134243772428682e-1L, -1.986027322597818397661816253158024383707e-16L, 0 },
#ifndef TEST_FLOAT
	TEST_c_c(casinh, 0x1.fp-1025L, 0.5L, 6.222508863508420569166420770843207333493e-309L, 5.235987755982988730771072305465838140329e-1L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, 0x1.fp-1025L, -0.5L, 6.222508863508420569166420770843207333493e-309L, -5.235987755982988730771072305465838140329e-1L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0x1.fp-1025L, 0.5L, -6.222508863508420569166420770843207333493e-309L, 5.235987755982988730771072305465838140329e-1L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0x1.fp-1025L, -0.5L, -6.222508863508420569166420770843207333493e-309L, -5.235987755982988730771072305465838140329e-1L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, 0.5L, 0x1.fp-1025L, 4.812118250596034474977589134243684231352e-1L, 4.819934639999230680322935210539402497827e-309L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(casinh, -0.5L, 0x1.fp-1025L, -4.812118250596034474977589134243684231352e-1L, 4.819934639999230680322935210539402497827e-309L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(casinh, 0.5L, -0x1.fp-1025L, 4.812118250596034474977589134243684231352e-1L, -4.819934639999230680322935210539402497827e-309L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(casinh, -0.5L, -0x1.fp-1025L, -4.812118250596034474977589134243684231352e-1L, -4.819934639999230680322935210539402497827e-309L, UNDERFLOW_EXCEPTION_DOUBLE },
#endif
	TEST_c_c(casinh, 0x1p-52L, 0x1p-52L, 2.220446049250313080847263336181677117148e-16L, 2.220446049250313080847263336181604132852e-16L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casinh, 0x1p-52L, -0x1p-52L, 2.220446049250313080847263336181677117148e-16L, -2.220446049250313080847263336181604132852e-16L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casinh, -0x1p-52L, 0x1p-52L, -2.220446049250313080847263336181677117148e-16L, 2.220446049250313080847263336181604132852e-16L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casinh, -0x1p-52L, -0x1p-52L, -2.220446049250313080847263336181677117148e-16L, -2.220446049250313080847263336181604132852e-16L, 0|XFAIL_NATIVE_LINUXF },
#ifndef TEST_FLOAT
	TEST_c_c(casinh, 0x1.fp-1025L, 0x1p-52L, 5.388850751072128349671657362289548938458e-309L, 2.220446049250313080847263336181658871074e-16L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, 0x1.fp-1025L, -0x1p-52L, 5.388850751072128349671657362289548938458e-309L, -2.220446049250313080847263336181658871074e-16L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0x1.fp-1025L, 0x1p-52L, -5.388850751072128349671657362289548938458e-309L, 2.220446049250313080847263336181658871074e-16L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0x1.fp-1025L, -0x1p-52L, -5.388850751072128349671657362289548938458e-309L, -2.220446049250313080847263336181658871074e-16L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	/* Bug 15319: underflow exception may be missing.  */
	TEST_c_c(casinh, 0x1p-52L, 0x1.fp-1025L, 2.220446049250313080847263336181622378926e-16L, 5.388850751072128349671657362289283247603e-309L, UNDERFLOW_EXCEPTION_OK_DOUBLE },
	TEST_c_c(casinh, -0x1p-52L, 0x1.fp-1025L, -2.220446049250313080847263336181622378926e-16L, 5.388850751072128349671657362289283247603e-309L, UNDERFLOW_EXCEPTION_OK_DOUBLE },
	TEST_c_c(casinh, 0x1p-52L, -0x1.fp-1025L, 2.220446049250313080847263336181622378926e-16L, -5.388850751072128349671657362289283247603e-309L, UNDERFLOW_EXCEPTION_OK_DOUBLE },
	TEST_c_c(casinh, -0x1p-52L, -0x1.fp-1025L, -2.220446049250313080847263336181622378926e-16L, -5.388850751072128349671657362289283247603e-309L, UNDERFLOW_EXCEPTION_OK_DOUBLE },
#endif
	TEST_c_c(casinh, 0.0L, 0x1p-52L, 0.0L, 2.220446049250313080847263336181658871074e-16L, 0 },
	TEST_c_c(casinh, 0.0L, -0x1p-52L, 0.0L, -2.220446049250313080847263336181658871074e-16L, 0 },
	TEST_c_c(casinh, -0.0L, 0x1p-52L, -0.0L, 2.220446049250313080847263336181658871074e-16L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0.0L, -0x1p-52L, -0.0L, -2.220446049250313080847263336181658871074e-16L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, 0x1p-52L, 0.0L, 2.220446049250313080847263336181622378926e-16L, 0.0L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casinh, -0x1p-52L, 0.0L, -2.220446049250313080847263336181622378926e-16L, 0.0L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casinh, 0x1p-52L, -0.0L, 2.220446049250313080847263336181622378926e-16L, -0.0L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(casinh, -0x1p-52L, -0.0L, -2.220446049250313080847263336181622378926e-16L, -0.0L, 0|XFAIL_NATIVE_LINUXF|XFAIL_NATIVE_LINUX },
#ifndef TEST_FLOAT
	TEST_c_c(casinh, 0x1.fp-1025L, 0x1.fp-1025L, 5.388850751072128349671657362289416093031e-309L, 5.388850751072128349671657362289416093031e-309L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, 0x1.fp-1025L, -0x1.fp-1025L, 5.388850751072128349671657362289416093031e-309L, -5.388850751072128349671657362289416093031e-309L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0x1.fp-1025L, 0x1.fp-1025L, -5.388850751072128349671657362289416093031e-309L, 5.388850751072128349671657362289416093031e-309L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0x1.fp-1025L, -0x1.fp-1025L, -5.388850751072128349671657362289416093031e-309L, -5.388850751072128349671657362289416093031e-309L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
#endif
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	TEST_c_c(casinh, 0x1p-63L, 0x0.ffffffffffffffffp0L, 2.588578361325995866221775673638805081337e-10L, 1.570796326376055842114524927965556247908L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(casinh, 0x1p-63L, -0x0.ffffffffffffffffp0L, 2.588578361325995866221775673638805081337e-10L, -1.570796326376055842114524927965556247908L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(casinh, -0x1p-63L, 0x0.ffffffffffffffffp0L, -2.588578361325995866221775673638805081337e-10L, 1.570796326376055842114524927965556247908L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(casinh, -0x1p-63L, -0x0.ffffffffffffffffp0L, -2.588578361325995866221775673638805081337e-10L, -1.570796326376055842114524927965556247908L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(casinh, 0x0.ffffffffffffffffp0L, 0x1p-63L, 8.813735870195430251942769895627079569937e-1L, 7.666467083416870407402049869781566856442e-20L, 0 },
	TEST_c_c(casinh, -0x0.ffffffffffffffffp0L, 0x1p-63L, -8.813735870195430251942769895627079569937e-1L, 7.666467083416870407402049869781566856442e-20L, 0 },
	TEST_c_c(casinh, 0x0.ffffffffffffffffp0L, -0x1p-63L, 8.813735870195430251942769895627079569937e-1L, -7.666467083416870407402049869781566856442e-20L, 0 },
	TEST_c_c(casinh, -0x0.ffffffffffffffffp0L, -0x1p-63L, -8.813735870195430251942769895627079569937e-1L, -7.666467083416870407402049869781566856442e-20L, 0 },
# if LDBL_MIN_EXP <= -16381
	TEST_c_c(casinh, 0x1.fp-16385L, 0x0.ffffffffffffffffp0L, 2.472906068161537187835415298076415423459e-4923L, 1.570796326465624365239962068302568888898L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(casinh, 0x1.fp-16385L, -0x0.ffffffffffffffffp0L, 2.472906068161537187835415298076415423459e-4923L, -1.570796326465624365239962068302568888898L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(casinh, -0x1.fp-16385L, 0x0.ffffffffffffffffp0L, -2.472906068161537187835415298076415423459e-4923L, 1.570796326465624365239962068302568888898L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(casinh, -0x1.fp-16385L, -0x0.ffffffffffffffffp0L, -2.472906068161537187835415298076415423459e-4923L, -1.570796326465624365239962068302568888898L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(casinh, 0x0.ffffffffffffffffp0L, 0x1.fp-16385L, 8.813735870195430251942769895627079569917e-1L, 5.757683115456107044287327268904964422212e-4933L, UNDERFLOW_EXCEPTION },
	TEST_c_c(casinh, -0x0.ffffffffffffffffp0L, 0x1.fp-16385L, -8.813735870195430251942769895627079569917e-1L, 5.757683115456107044287327268904964422212e-4933L, UNDERFLOW_EXCEPTION },
	TEST_c_c(casinh, 0x0.ffffffffffffffffp0L, -0x1.fp-16385L, 8.813735870195430251942769895627079569917e-1L, -5.757683115456107044287327268904964422212e-4933L, UNDERFLOW_EXCEPTION },
	TEST_c_c(casinh, -0x0.ffffffffffffffffp0L, -0x1.fp-16385L, -8.813735870195430251942769895627079569917e-1L, -5.757683115456107044287327268904964422212e-4933L, UNDERFLOW_EXCEPTION },
# endif
	TEST_c_c(casinh, 0.0L, 0x0.ffffffffffffffffp0L, 0.0L, 1.570796326465624365239962068302568888898L, 0 },
	TEST_c_c(casinh, 0.0L, -0x0.ffffffffffffffffp0L, 0.0L, -1.570796326465624365239962068302568888898L, 0 },
	TEST_c_c(casinh, -0.0L, 0x0.ffffffffffffffffp0L, -0.0L, 1.570796326465624365239962068302568888898L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(casinh, -0.0L, -0x0.ffffffffffffffffp0L, -0.0L, -1.570796326465624365239962068302568888898L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(casinh, 0x0.ffffffffffffffffp0L, 0.0L, 8.813735870195430251942769895627079569917e-1L, 0.0L, 0 },
	TEST_c_c(casinh, -0x0.ffffffffffffffffp0L, 0.0L, -8.813735870195430251942769895627079569917e-1L, 0.0L, 0 },
	TEST_c_c(casinh, 0x0.ffffffffffffffffp0L, -0.0L, 8.813735870195430251942769895627079569917e-1L, -0.0L, 0 },
	TEST_c_c(casinh, -0x0.ffffffffffffffffp0L, -0.0L, -8.813735870195430251942769895627079569917e-1L, -0.0L, 0|XFAIL_NATIVE_LINUXL },
#endif
	TEST_c_c(casinh, 0x1p-63L, 0.5L, 1.251928832280966098829878787499365228659e-19L, 5.235987755982988730771072305465838140283e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, 0x1p-63L, -0.5L, 1.251928832280966098829878787499365228659e-19L, -5.235987755982988730771072305465838140283e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0x1p-63L, 0.5L, -1.251928832280966098829878787499365228659e-19L, 5.235987755982988730771072305465838140283e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0x1p-63L, -0.5L, -1.251928832280966098829878787499365228659e-19L, -5.235987755982988730771072305465838140283e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, 0.5L, 0x1p-63L, 4.812118250596034474977589134243684231373e-1L, 9.697399036122160144833087173623140436413e-20L, 0 },
	TEST_c_c(casinh, -0.5L, 0x1p-63L, -4.812118250596034474977589134243684231373e-1L, 9.697399036122160144833087173623140436413e-20L, 0 },
	TEST_c_c(casinh, 0.5L, -0x1p-63L, 4.812118250596034474977589134243684231373e-1L, -9.697399036122160144833087173623140436413e-20L, 0 },
	TEST_c_c(casinh, -0.5L, -0x1p-63L, -4.812118250596034474977589134243684231373e-1L, -9.697399036122160144833087173623140436413e-20L, 0 },
#if defined TEST_LDOUBLE && LDBL_MIN_EXP <= -16381
	TEST_c_c(casinh, 0x1.fp-16385L, 0.5L, 9.402257155670418112159334875199821342890e-4933L, 5.235987755982988730771072305465838140329e-1L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(casinh, 0x1.fp-16385L, -0.5L, 9.402257155670418112159334875199821342890e-4933L, -5.235987755982988730771072305465838140329e-1L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(casinh, -0x1.fp-16385L, 0.5L, -9.402257155670418112159334875199821342890e-4933L, 5.235987755982988730771072305465838140329e-1L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(casinh, -0x1.fp-16385L, -0.5L, -9.402257155670418112159334875199821342890e-4933L, -5.235987755982988730771072305465838140329e-1L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(casinh, 0.5L, 0x1.fp-16385L, 4.812118250596034474977589134243684231352e-1L, 7.282957076134209141226696333885150260319e-4933L, UNDERFLOW_EXCEPTION },
	TEST_c_c(casinh, -0.5L, 0x1.fp-16385L, -4.812118250596034474977589134243684231352e-1L, 7.282957076134209141226696333885150260319e-4933L, UNDERFLOW_EXCEPTION },
	TEST_c_c(casinh, 0.5L, -0x1.fp-16385L, 4.812118250596034474977589134243684231352e-1L, -7.282957076134209141226696333885150260319e-4933L, UNDERFLOW_EXCEPTION },
	TEST_c_c(casinh, -0.5L, -0x1.fp-16385L, -4.812118250596034474977589134243684231352e-1L, -7.282957076134209141226696333885150260319e-4933L, UNDERFLOW_EXCEPTION },
#endif
	TEST_c_c(casinh, 0x1p-63L, 0x1p-63L, 1.084202172485504434007452800869941711430e-19L, 1.084202172485504434007452800869941711422e-19L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, 0x1p-63L, -0x1p-63L, 1.084202172485504434007452800869941711430e-19L, -1.084202172485504434007452800869941711422e-19L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0x1p-63L, 0x1p-63L, -1.084202172485504434007452800869941711430e-19L, 1.084202172485504434007452800869941711422e-19L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0x1p-63L, -0x1p-63L, -1.084202172485504434007452800869941711430e-19L, -1.084202172485504434007452800869941711422e-19L, 0|XFAIL_NATIVE_LINUX },
#if defined TEST_LDOUBLE && LDBL_MIN_EXP <= -16381
	TEST_c_c(casinh, 0x1.fp-16385L, 0x1p-63L, 8.142593549724601460479922838826119584465e-4933L, 1.084202172485504434007452800869941711428e-19L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(casinh, 0x1.fp-16385L, -0x1p-63L, 8.142593549724601460479922838826119584465e-4933L, -1.084202172485504434007452800869941711428e-19L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(casinh, -0x1.fp-16385L, 0x1p-63L, -8.142593549724601460479922838826119584465e-4933L, 1.084202172485504434007452800869941711428e-19L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(casinh, -0x1.fp-16385L, -0x1p-63L, -8.142593549724601460479922838826119584465e-4933L, -1.084202172485504434007452800869941711428e-19L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	/* Bug 15319: underflow exception may be missing.  */
	TEST_c_c(casinh, 0x1p-63L, 0x1.fp-16385L, 1.084202172485504434007452800869941711424e-19L, 8.142593549724601460479922838826119584369e-4933L, UNDERFLOW_EXCEPTION_OK },
	TEST_c_c(casinh, -0x1p-63L, 0x1.fp-16385L, -1.084202172485504434007452800869941711424e-19L, 8.142593549724601460479922838826119584369e-4933L, UNDERFLOW_EXCEPTION_OK },
	TEST_c_c(casinh, 0x1p-63L, -0x1.fp-16385L, 1.084202172485504434007452800869941711424e-19L, -8.142593549724601460479922838826119584369e-4933L, UNDERFLOW_EXCEPTION_OK },
	TEST_c_c(casinh, -0x1p-63L, -0x1.fp-16385L, -1.084202172485504434007452800869941711424e-19L, -8.142593549724601460479922838826119584369e-4933L, UNDERFLOW_EXCEPTION_OK },
#endif
	TEST_c_c(casinh, 0.0L, 0x1p-63L, 0.0L, 1.084202172485504434007452800869941711428e-19L, 0 },
	TEST_c_c(casinh, 0.0L, -0x1p-63L, 0.0L, -1.084202172485504434007452800869941711428e-19L, 0 },
	TEST_c_c(casinh, -0.0L, 0x1p-63L, -0.0L, 1.084202172485504434007452800869941711428e-19L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0.0L, -0x1p-63L, -0.0L, -1.084202172485504434007452800869941711428e-19L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, 0x1p-63L, 0.0L, 1.084202172485504434007452800869941711424e-19L, 0.0L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0x1p-63L, 0.0L, -1.084202172485504434007452800869941711424e-19L, 0.0L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, 0x1p-63L, -0.0L, 1.084202172485504434007452800869941711424e-19L, -0.0L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0x1p-63L, -0.0L, -1.084202172485504434007452800869941711424e-19L, -0.0L, 0|XFAIL_NATIVE_LINUX },
#if defined TEST_LDOUBLE && LDBL_MIN_EXP <= -16381
	TEST_c_c(casinh, 0x1.fp-16385L, 0x1.fp-16385L, 8.142593549724601460479922838826119584417e-4933L, 8.142593549724601460479922838826119584417e-4933L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(casinh, 0x1.fp-16385L, -0x1.fp-16385L, 8.142593549724601460479922838826119584417e-4933L, -8.142593549724601460479922838826119584417e-4933L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(casinh, -0x1.fp-16385L, 0x1.fp-16385L, -8.142593549724601460479922838826119584417e-4933L, 8.142593549724601460479922838826119584417e-4933L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(casinh, -0x1.fp-16385L, -0x1.fp-16385L, -8.142593549724601460479922838826119584417e-4933L, -8.142593549724601460479922838826119584417e-4933L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
#endif
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 106
	TEST_c_c(casinh, 0x1p-105L, 0x0.ffffffffffffffffffffffffffcp0L, 1.234330349600789959989661887846005659983e-16L, 1.570796326794896419512475791677915736035L, 0 },
	TEST_c_c(casinh, 0x1p-105L, -0x0.ffffffffffffffffffffffffffcp0L, 1.234330349600789959989661887846005659983e-16L, -1.570796326794896419512475791677915736035L, 0 },
	TEST_c_c(casinh, -0x1p-105L, 0x0.ffffffffffffffffffffffffffcp0L, -1.234330349600789959989661887846005659983e-16L, 1.570796326794896419512475791677915736035L, 0 },
	TEST_c_c(casinh, -0x1p-105L, -0x0.ffffffffffffffffffffffffffcp0L, -1.234330349600789959989661887846005659983e-16L, -1.570796326794896419512475791677915736035L, 0 },
	TEST_c_c(casinh, 0x0.ffffffffffffffffffffffffffcp0L, 0x1p-105L, 8.813735870195430252326093249797835932642e-1L, 1.743152798421049375791483240187377443526e-32L, 0 },
	TEST_c_c(casinh, -0x0.ffffffffffffffffffffffffffcp0L, 0x1p-105L, -8.813735870195430252326093249797835932642e-1L, 1.743152798421049375791483240187377443526e-32L, 0 },
	TEST_c_c(casinh, 0x0.ffffffffffffffffffffffffffcp0L, -0x1p-105L, 8.813735870195430252326093249797835932642e-1L, -1.743152798421049375791483240187377443526e-32L, 0 },
	TEST_c_c(casinh, -0x0.ffffffffffffffffffffffffffcp0L, -0x1p-105L, -8.813735870195430252326093249797835932642e-1L, -1.743152798421049375791483240187377443526e-32L, 0 },
	TEST_c_c(casinh, 0x1.fp-1025L, 0x0.ffffffffffffffffffffffffffcp0L, 3.432186888910770473784103112009399360940e-293L, 1.570796326794896462222075823262245502760L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM },
	TEST_c_c(casinh, 0x1.fp-1025L, -0x0.ffffffffffffffffffffffffffcp0L, 3.432186888910770473784103112009399360940e-293L, -1.570796326794896462222075823262245502760L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM },
	TEST_c_c(casinh, -0x1.fp-1025L, 0x0.ffffffffffffffffffffffffffcp0L, -3.432186888910770473784103112009399360940e-293L, 1.570796326794896462222075823262245502760L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM },
	TEST_c_c(casinh, -0x1.fp-1025L, -0x0.ffffffffffffffffffffffffffcp0L, -3.432186888910770473784103112009399360940e-293L, -1.570796326794896462222075823262245502760L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM },
	TEST_c_c(casinh, 0x0.ffffffffffffffffffffffffffcp0L, 0x1.fp-1025L, 8.813735870195430252326093249797835932642e-1L, 3.810492908885321743133304375216641110205e-309L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(casinh, -0x0.ffffffffffffffffffffffffffcp0L, 0x1.fp-1025L, -8.813735870195430252326093249797835932642e-1L, 3.810492908885321743133304375216641110205e-309L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(casinh, 0x0.ffffffffffffffffffffffffffcp0L, -0x1.fp-1025L, 8.813735870195430252326093249797835932642e-1L, -3.810492908885321743133304375216641110205e-309L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(casinh, -0x0.ffffffffffffffffffffffffffcp0L, -0x1.fp-1025L, -8.813735870195430252326093249797835932642e-1L, -3.810492908885321743133304375216641110205e-309L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(casinh, 0.0L, 0x0.ffffffffffffffffffffffffffcp0L, 0.0L, 1.570796326794896462222075823262245502760L, 0 },
	TEST_c_c(casinh, 0.0L, -0x0.ffffffffffffffffffffffffffcp0L, 0.0L, -1.570796326794896462222075823262245502760L, 0 },
	TEST_c_c(casinh, -0.0L, 0x0.ffffffffffffffffffffffffffcp0L, -0.0L, 1.570796326794896462222075823262245502760L, 0 },
	TEST_c_c(casinh, -0.0L, -0x0.ffffffffffffffffffffffffffcp0L, -0.0L, -1.570796326794896462222075823262245502760L, 0 },
	TEST_c_c(casinh, 0x0.ffffffffffffffffffffffffffcp0L, 0.0L, 8.813735870195430252326093249797835932642e-1L, 0.0L, 0 },
	TEST_c_c(casinh, -0x0.ffffffffffffffffffffffffffcp0L, 0.0L, -8.813735870195430252326093249797835932642e-1L, 0.0L, 0 },
	TEST_c_c(casinh, 0x0.ffffffffffffffffffffffffffcp0L, -0.0L, 8.813735870195430252326093249797835932642e-1L, -0.0L, 0 },
	TEST_c_c(casinh, -0x0.ffffffffffffffffffffffffffcp0L, -0.0L, -8.813735870195430252326093249797835932642e-1L, -0.0L, 0 },
#endif
	TEST_c_c(casinh, 0x1p-105L, 0.5L, 2.846556599890768890940941645338546615370e-32L, 5.235987755982988730771072305465838140329e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, 0x1p-105L, -0.5L, 2.846556599890768890940941645338546615370e-32L, -5.235987755982988730771072305465838140329e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0x1p-105L, 0.5L, -2.846556599890768890940941645338546615370e-32L, 5.235987755982988730771072305465838140329e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0x1p-105L, -0.5L, -2.846556599890768890940941645338546615370e-32L, -5.235987755982988730771072305465838140329e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, 0.5L, 0x1p-105L, 4.812118250596034474977589134243684231352e-1L, 2.204933261082751447436996198490110245167e-32L, 0 },
	TEST_c_c(casinh, -0.5L, 0x1p-105L, -4.812118250596034474977589134243684231352e-1L, 2.204933261082751447436996198490110245167e-32L, 0 },
	TEST_c_c(casinh, 0.5L, -0x1p-105L, 4.812118250596034474977589134243684231352e-1L, -2.204933261082751447436996198490110245167e-32L, 0 },
	TEST_c_c(casinh, -0.5L, -0x1p-105L, -4.812118250596034474977589134243684231352e-1L, -2.204933261082751447436996198490110245167e-32L, 0 },
	TEST_c_c(casinh, 0x1p-105L, 0x1p-105L, 2.465190328815661891911651766508706967729e-32L, 2.465190328815661891911651766508706967729e-32L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, 0x1p-105L, -0x1p-105L, 2.465190328815661891911651766508706967729e-32L, -2.465190328815661891911651766508706967729e-32L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0x1p-105L, 0x1p-105L, -2.465190328815661891911651766508706967729e-32L, 2.465190328815661891911651766508706967729e-32L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0x1p-105L, -0x1p-105L, -2.465190328815661891911651766508706967729e-32L, -2.465190328815661891911651766508706967729e-32L, 0|XFAIL_NATIVE_LINUX },
#ifndef TEST_FLOAT
	TEST_c_c(casinh, 0x1.fp-1025L, 0x1p-105L, 5.388850751072128349671657362289416093031e-309L, 2.465190328815661891911651766508706967729e-32L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, 0x1.fp-1025L, -0x1p-105L, 5.388850751072128349671657362289416093031e-309L, -2.465190328815661891911651766508706967729e-32L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0x1.fp-1025L, 0x1p-105L, -5.388850751072128349671657362289416093031e-309L, 2.465190328815661891911651766508706967729e-32L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0x1.fp-1025L, -0x1p-105L, -5.388850751072128349671657362289416093031e-309L, -2.465190328815661891911651766508706967729e-32L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	/* Bug 15319: underflow exception may be missing.  */
	TEST_c_c(casinh, 0x1p-105L, 0x1.fp-1025L, 2.465190328815661891911651766508706967729e-32L, 5.388850751072128349671657362289416093031e-309L, UNDERFLOW_EXCEPTION_OK_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0x1p-105L, 0x1.fp-1025L, -2.465190328815661891911651766508706967729e-32L, 5.388850751072128349671657362289416093031e-309L, UNDERFLOW_EXCEPTION_OK_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, 0x1p-105L, -0x1.fp-1025L, 2.465190328815661891911651766508706967729e-32L, -5.388850751072128349671657362289416093031e-309L, UNDERFLOW_EXCEPTION_OK_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0x1p-105L, -0x1.fp-1025L, -2.465190328815661891911651766508706967729e-32L, -5.388850751072128349671657362289416093031e-309L, UNDERFLOW_EXCEPTION_OK_DOUBLE|XFAIL_NATIVE_LINUX },
#endif
	TEST_c_c(casinh, 0.0L, 0x1p-105L, 0.0L, 2.465190328815661891911651766508706967729e-32L, 0 },
	TEST_c_c(casinh, 0.0L, -0x1p-105L, 0.0L, -2.465190328815661891911651766508706967729e-32L, 0 },
	TEST_c_c(casinh, -0.0L, 0x1p-105L, -0.0L, 2.465190328815661891911651766508706967729e-32L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0.0L, -0x1p-105L, -0.0L, -2.465190328815661891911651766508706967729e-32L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, 0x1p-105L, 0.0L, 2.465190328815661891911651766508706967729e-32L, 0.0L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0x1p-105L, 0.0L, -2.465190328815661891911651766508706967729e-32L, 0.0L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, 0x1p-105L, -0.0L, 2.465190328815661891911651766508706967729e-32L, -0.0L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0x1p-105L, -0.0L, -2.465190328815661891911651766508706967729e-32L, -0.0L, 0|XFAIL_NATIVE_LINUX },
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 113
	TEST_c_c(casinh, 0x1p-112L, 0x0.ffffffffffffffffffffffffffff8p0L, 1.091004200533850618345330909857103457781e-17L, 1.570796326794896601578502908312986698624L, 0 },
	TEST_c_c(casinh, 0x1p-112L, -0x0.ffffffffffffffffffffffffffff8p0L, 1.091004200533850618345330909857103457781e-17L, -1.570796326794896601578502908312986698624L, 0 },
	TEST_c_c(casinh, -0x1p-112L, 0x0.ffffffffffffffffffffffffffff8p0L, -1.091004200533850618345330909857103457781e-17L, 1.570796326794896601578502908312986698624L, 0 },
	TEST_c_c(casinh, -0x1p-112L, -0x0.ffffffffffffffffffffffffffff8p0L, -1.091004200533850618345330909857103457781e-17L, -1.570796326794896601578502908312986698624L, 0 },
	TEST_c_c(casinh, 0x0.ffffffffffffffffffffffffffff8p0L, 0x1p-112L, 8.813735870195430252326093249797922409363e-1L, 1.361838123766444824837096281396380300349e-34L, 0 },
	TEST_c_c(casinh, -0x0.ffffffffffffffffffffffffffff8p0L, 0x1p-112L, -8.813735870195430252326093249797922409363e-1L, 1.361838123766444824837096281396380300349e-34L, 0 },
	TEST_c_c(casinh, 0x0.ffffffffffffffffffffffffffff8p0L, -0x1p-112L, 8.813735870195430252326093249797922409363e-1L, -1.361838123766444824837096281396380300349e-34L, 0 },
	TEST_c_c(casinh, -0x0.ffffffffffffffffffffffffffff8p0L, -0x1p-112L, -8.813735870195430252326093249797922409363e-1L, -1.361838123766444824837096281396380300349e-34L, 0 },
	TEST_c_c(casinh, 0x1.fp-16385L, 0x0.ffffffffffffffffffffffffffff8p0L, 5.867357004219059108790368268900490184505e-4916L, 1.570796326794896605353533883825294686803L, 0 },
	TEST_c_c(casinh, 0x1.fp-16385L, -0x0.ffffffffffffffffffffffffffff8p0L, 5.867357004219059108790368268900490184505e-4916L, -1.570796326794896605353533883825294686803L, 0 },
	TEST_c_c(casinh, -0x1.fp-16385L, 0x0.ffffffffffffffffffffffffffff8p0L, -5.867357004219059108790368268900490184505e-4916L, 1.570796326794896605353533883825294686803L, 0 },
	TEST_c_c(casinh, -0x1.fp-16385L, -0x0.ffffffffffffffffffffffffffff8p0L, -5.867357004219059108790368268900490184505e-4916L, -1.570796326794896605353533883825294686803L, 0 },
	TEST_c_c(casinh, 0x0.ffffffffffffffffffffffffffff8p0L, 0x1.fp-16385L, 8.813735870195430252326093249797922409363e-1L, 5.757683115456107044131264955348449231681e-4933L, UNDERFLOW_EXCEPTION },
	TEST_c_c(casinh, -0x0.ffffffffffffffffffffffffffff8p0L, 0x1.fp-16385L, -8.813735870195430252326093249797922409363e-1L, 5.757683115456107044131264955348449231681e-4933L, UNDERFLOW_EXCEPTION },
	TEST_c_c(casinh, 0x0.ffffffffffffffffffffffffffff8p0L, -0x1.fp-16385L, 8.813735870195430252326093249797922409363e-1L, -5.757683115456107044131264955348449231681e-4933L, UNDERFLOW_EXCEPTION },
	TEST_c_c(casinh, -0x0.ffffffffffffffffffffffffffff8p0L, -0x1.fp-16385L, -8.813735870195430252326093249797922409363e-1L, -5.757683115456107044131264955348449231681e-4933L, UNDERFLOW_EXCEPTION },
	TEST_c_c(casinh, 0.0L, 0x0.ffffffffffffffffffffffffffff8p0L, 0.0L, 1.570796326794896605353533883825294686803L, 0 },
	TEST_c_c(casinh, 0.0L, -0x0.ffffffffffffffffffffffffffff8p0L, 0.0L, -1.570796326794896605353533883825294686803L, 0 },
	TEST_c_c(casinh, -0.0L, 0x0.ffffffffffffffffffffffffffff8p0L, -0.0L, 1.570796326794896605353533883825294686803L, 0 },
	TEST_c_c(casinh, -0.0L, -0x0.ffffffffffffffffffffffffffff8p0L, -0.0L, -1.570796326794896605353533883825294686803L, 0 },
	TEST_c_c(casinh, 0x0.ffffffffffffffffffffffffffff8p0L, 0.0L, 8.813735870195430252326093249797922409363e-1L, 0.0L, 0 },
	TEST_c_c(casinh, -0x0.ffffffffffffffffffffffffffff8p0L, 0.0L, -8.813735870195430252326093249797922409363e-1L, 0.0L, 0 },
	TEST_c_c(casinh, 0x0.ffffffffffffffffffffffffffff8p0L, -0.0L, 8.813735870195430252326093249797922409363e-1L, -0.0L, 0 },
	TEST_c_c(casinh, -0x0.ffffffffffffffffffffffffffff8p0L, -0.0L, -8.813735870195430252326093249797922409363e-1L, -0.0L, 0 },
#endif
	TEST_c_c(casinh, 0x1p-112L, 0.5L, 2.223872343664663196047610660420739543258e-34L, 5.235987755982988730771072305465838140329e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, 0x1p-112L, -0.5L, 2.223872343664663196047610660420739543258e-34L, -5.235987755982988730771072305465838140329e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0x1p-112L, 0.5L, -2.223872343664663196047610660420739543258e-34L, 5.235987755982988730771072305465838140329e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0x1p-112L, -0.5L, -2.223872343664663196047610660420739543258e-34L, -5.235987755982988730771072305465838140329e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, 0.5L, 0x1p-112L, 4.812118250596034474977589134243684231352e-1L, 1.722604110220899568310153280070398629037e-34L, 0 },
	TEST_c_c(casinh, -0.5L, 0x1p-112L, -4.812118250596034474977589134243684231352e-1L, 1.722604110220899568310153280070398629037e-34L, 0 },
	TEST_c_c(casinh, 0.5L, -0x1p-112L, 4.812118250596034474977589134243684231352e-1L, -1.722604110220899568310153280070398629037e-34L, 0 },
	TEST_c_c(casinh, -0.5L, -0x1p-112L, -4.812118250596034474977589134243684231352e-1L, -1.722604110220899568310153280070398629037e-34L, 0 },
	TEST_c_c(casinh, 0x1p-112L, 0x1p-112L, 1.925929944387235853055977942584927318538e-34L, 1.925929944387235853055977942584927318538e-34L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, 0x1p-112L, -0x1p-112L, 1.925929944387235853055977942584927318538e-34L, -1.925929944387235853055977942584927318538e-34L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0x1p-112L, 0x1p-112L, -1.925929944387235853055977942584927318538e-34L, 1.925929944387235853055977942584927318538e-34L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0x1p-112L, -0x1p-112L, -1.925929944387235853055977942584927318538e-34L, -1.925929944387235853055977942584927318538e-34L, 0|XFAIL_NATIVE_LINUX },
#if defined TEST_LDOUBLE && LDBL_MIN_EXP <= -16381
	TEST_c_c(casinh, 0x1.fp-16385L, 0x1p-112L, 8.142593549724601460479922838826119584417e-4933L, 1.925929944387235853055977942584927318538e-34L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(casinh, 0x1.fp-16385L, -0x1p-112L, 8.142593549724601460479922838826119584417e-4933L, -1.925929944387235853055977942584927318538e-34L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(casinh, -0x1.fp-16385L, 0x1p-112L, -8.142593549724601460479922838826119584417e-4933L, 1.925929944387235853055977942584927318538e-34L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(casinh, -0x1.fp-16385L, -0x1p-112L, -8.142593549724601460479922838826119584417e-4933L, -1.925929944387235853055977942584927318538e-34L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	/* Bug 15319: underflow exception may be missing.  */
	TEST_c_c(casinh, 0x1p-112L, 0x1.fp-16385L, 1.925929944387235853055977942584927318538e-34L, 8.142593549724601460479922838826119584417e-4933L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(casinh, -0x1p-112L, 0x1.fp-16385L, -1.925929944387235853055977942584927318538e-34L, 8.142593549724601460479922838826119584417e-4933L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(casinh, 0x1p-112L, -0x1.fp-16385L, 1.925929944387235853055977942584927318538e-34L, -8.142593549724601460479922838826119584417e-4933L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(casinh, -0x1p-112L, -0x1.fp-16385L, -1.925929944387235853055977942584927318538e-34L, -8.142593549724601460479922838826119584417e-4933L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
#endif
	TEST_c_c(casinh, 0.0L, 0x1p-112L, 0.0L, 1.925929944387235853055977942584927318538e-34L, 0 },
	TEST_c_c(casinh, 0.0L, -0x1p-112L, 0.0L, -1.925929944387235853055977942584927318538e-34L, 0 },
	TEST_c_c(casinh, -0.0L, 0x1p-112L, -0.0L, 1.925929944387235853055977942584927318538e-34L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0.0L, -0x1p-112L, -0.0L, -1.925929944387235853055977942584927318538e-34L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, 0x1p-112L, 0.0L, 1.925929944387235853055977942584927318538e-34L, 0.0L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0x1p-112L, 0.0L, -1.925929944387235853055977942584927318538e-34L, 0.0L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, 0x1p-112L, -0.0L, 1.925929944387235853055977942584927318538e-34L, -0.0L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(casinh, -0x1p-112L, -0.0L, -1.925929944387235853055977942584927318538e-34L, -0.0L, 0|XFAIL_NATIVE_LINUX },

	TEST_c_c(casinh, 0.75L, 1.25L, 1.03171853444778027336364058631006594L, 0.911738290968487636358489564316731207L, 0 },
	TEST_c_c(casinh, -2, -3, -1.9686379257930962917886650952454982L, -0.96465850440760279204541105949953237L, 0 },
}


static void test_catan(void)
{
	struct test *testp = lookup("catan" },

	TEST_c_c(catan, 0, 0, 0, 0, 0 },
	TEST_c_c(catan, ZERO_M, 0, ZERO_M, 0, 0 },
	TEST_c_c(catan, 0, ZERO_M, 0, ZERO_M, 0 },
	TEST_c_c(catan, ZERO_M, ZERO_M, ZERO_M, ZERO_M, 0 },

	TEST_c_c(catan, 1.0L, ZERO_P, M_PI_4l, ZERO_P, 0 },
	TEST_c_c(catan, 1.0L, ZERO_M, M_PI_4l, ZERO_M, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -1.0L, ZERO_P, -M_PI_4l, ZERO_P, 0 },
	TEST_c_c(catan, -1.0L, ZERO_M, -M_PI_4l, ZERO_M, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, ZERO_P, 1.0L, ZERO_P, INF_P, DIVIDE_BY_ZERO_EXCEPTION },
	TEST_c_c(catan, ZERO_M, 1.0L, ZERO_M, INF_P, DIVIDE_BY_ZERO_EXCEPTION },
	TEST_c_c(catan, ZERO_P, -1.0L, ZERO_P, INF_M, DIVIDE_BY_ZERO_EXCEPTION },
	TEST_c_c(catan, ZERO_M, -1.0L, ZERO_M, INF_M, DIVIDE_BY_ZERO_EXCEPTION },

	TEST_c_c(catan, INF_P, INF_P, M_PI_2l, 0, 0 },
	TEST_c_c(catan, INF_P, INF_M, M_PI_2l, ZERO_M, 0 },
	TEST_c_c(catan, INF_M, INF_P, -M_PI_2l, 0, 0 },
	TEST_c_c(catan, INF_M, INF_M, -M_PI_2l, ZERO_M, 0 },


	TEST_c_c(catan, INF_P, -10.0, M_PI_2l, ZERO_M, 0 },
	TEST_c_c(catan, INF_M, -10.0, -M_PI_2l, ZERO_M, 0 },
	TEST_c_c(catan, INF_P, ZERO_M, M_PI_2l, ZERO_M, 0 },
	TEST_c_c(catan, INF_M, ZERO_M, -M_PI_2l, ZERO_M, 0 },
	TEST_c_c(catan, INF_P, 0.0, M_PI_2l, 0, 0 },
	TEST_c_c(catan, INF_M, 0.0, -M_PI_2l, 0, 0 },
	TEST_c_c(catan, INF_P, 0.1L, M_PI_2l, 0, 0 },
	TEST_c_c(catan, INF_M, 0.1L, -M_PI_2l, 0, 0 },

	TEST_c_c(catan, 0.0, INF_M, M_PI_2l, ZERO_M, 0 },
	TEST_c_c(catan, ZERO_M, INF_M, -M_PI_2l, ZERO_M, 0 },
	TEST_c_c(catan, 100.0, INF_M, M_PI_2l, ZERO_M, 0 },
	TEST_c_c(catan, -100.0, INF_M, -M_PI_2l, ZERO_M, 0 },

	TEST_c_c(catan, 0.0, INF_P, M_PI_2l, 0, 0 },
	TEST_c_c(catan, ZERO_M, INF_P, -M_PI_2l, 0, 0 },
	TEST_c_c(catan, 0.5, INF_P, M_PI_2l, 0, 0 },
	TEST_c_c(catan, -0.5, INF_P, -M_PI_2l, 0, 0 },

	TEST_c_c(catan, QNAN_P, 0.0, QNAN_P, 0, 0 },
	TEST_c_c(catan, QNAN_P, ZERO_M, QNAN_P, ZERO_M, 0 },

	TEST_c_c(catan, QNAN_P, INF_P, QNAN_P, 0, 0 },
	TEST_c_c(catan, QNAN_P, INF_M, QNAN_P, ZERO_M, 0 },

	TEST_c_c(catan, 0.0, QNAN_P, QNAN_P, QNAN_P, 0 },
	TEST_c_c(catan, ZERO_M, QNAN_P, QNAN_P, QNAN_P, 0 },

	TEST_c_c(catan, INF_P, QNAN_P, M_PI_2l, 0, 0 },
	TEST_c_c(catan, INF_M, QNAN_P, -M_PI_2l, 0, 0 },

	TEST_c_c(catan, QNAN_P, 10.5, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	TEST_c_c(catan, QNAN_P, -10.5, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },

	TEST_c_c(catan, 0.75, QNAN_P, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	TEST_c_c(catan, -0.75, QNAN_P, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },

	TEST_c_c(catan, QNAN_P, QNAN_P, QNAN_P, QNAN_P, 0 },

	TEST_c_c(catan, 0x1p50L, 0.0L, 1.570796326794895731052901991514519103193L, 0.0L, 0 },
	TEST_c_c(catan, 0x1p50L, -0.0L, 1.570796326794895731052901991514519103193L, -0.0L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -0x1p50L, 0.0L, -1.570796326794895731052901991514519103193L, 0.0L, 0 },
	TEST_c_c(catan, -0x1p50L, -0.0L, -1.570796326794895731052901991514519103193L, -0.0L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, 0.0L, 0x1p50L, 1.570796326794896619231321691639751442099L, 8.881784197001252323389053344728897997441e-16L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catan, -0.0L, 0x1p50L, -1.570796326794896619231321691639751442099L, 8.881784197001252323389053344728897997441e-16L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catan, 0.0L, -0x1p50L, 1.570796326794896619231321691639751442099L, -8.881784197001252323389053344728897997441e-16L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catan, -0.0L, -0x1p50L, -1.570796326794896619231321691639751442099L, -8.881784197001252323389053344728897997441e-16L, 0|XFAIL_NATIVE_LINUXF },
#ifndef TEST_FLOAT
	TEST_c_c(catan, 0x1p500L, 0.0L, 1.570796326794896619231321691639751442099L, 0.0L, 0 },
	TEST_c_c(catan, 0x1p500L, -0.0L, 1.570796326794896619231321691639751442099L, -0.0L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -0x1p500L, 0.0L, -1.570796326794896619231321691639751442099L, 0.0L, 0 },
	TEST_c_c(catan, -0x1p500L, -0.0L, -1.570796326794896619231321691639751442099L, -0.0L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, 0.0L, 0x1p500L, 1.570796326794896619231321691639751442099L, 3.054936363499604682051979393213617699789e-151L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -0.0L, 0x1p500L, -1.570796326794896619231321691639751442099L, 3.054936363499604682051979393213617699789e-151L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, 0.0L, -0x1p500L, 1.570796326794896619231321691639751442099L, -3.054936363499604682051979393213617699789e-151L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -0.0L, -0x1p500L, -1.570796326794896619231321691639751442099L, -3.054936363499604682051979393213617699789e-151L, 0|XFAIL_NATIVE_LINUX },
#endif
#if defined TEST_LDOUBLE && LDBL_MAX_EXP >= 16384
	TEST_c_c(catan, 0x1p5000L, 0.0L, 1.570796326794896619231321691639751442099L, 0.0L, 0 },
	TEST_c_c(catan, 0x1p5000L, -0.0L, 1.570796326794896619231321691639751442099L, -0.0L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, -0x1p5000L, 0.0L, -1.570796326794896619231321691639751442099L, 0.0L, 0 },
	TEST_c_c(catan, -0x1p5000L, -0.0L, -1.570796326794896619231321691639751442099L, -0.0L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, 0.0L, 0x1p5000L, 1.570796326794896619231321691639751442099L, 7.079811261048172892385615158694057552948e-1506L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, -0.0L, 0x1p5000L, -1.570796326794896619231321691639751442099L, 7.079811261048172892385615158694057552948e-1506L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, 0.0L, -0x1p5000L, 1.570796326794896619231321691639751442099L, -7.079811261048172892385615158694057552948e-1506L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, -0.0L, -0x1p5000L, -1.570796326794896619231321691639751442099L, -7.079811261048172892385615158694057552948e-1506L, 0|XFAIL_NATIVE_LINUXL },
#endif
	TEST_c_c(catan, 0x1p63L, 0.5L, 1.570796326794896619122901474391200998698L, 5.877471754111437539843682686111228389007e-39L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, 0x1p63L, -0.5L, 1.570796326794896619122901474391200998698L, -5.877471754111437539843682686111228389007e-39L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -0x1p63L, 0.5L, -1.570796326794896619122901474391200998698L, 5.877471754111437539843682686111228389007e-39L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -0x1p63L, -0.5L, -1.570796326794896619122901474391200998698L, -5.877471754111437539843682686111228389007e-39L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, 0.5L, 0x1p63L, 1.570796326794896619231321691639751442093L, 1.084202172485504434007452800869941711427e-19L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -0.5L, 0x1p63L, -1.570796326794896619231321691639751442093L, 1.084202172485504434007452800869941711427e-19L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, 0.5L, -0x1p63L, 1.570796326794896619231321691639751442093L, -1.084202172485504434007452800869941711427e-19L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -0.5L, -0x1p63L, -1.570796326794896619231321691639751442093L, -1.084202172485504434007452800869941711427e-19L, 0|XFAIL_NATIVE_LINUX },
#ifndef TEST_FLOAT
	TEST_c_c(catan, 0x1p511L, 0.5L, 1.570796326794896619231321691639751442099L, 1.112536929253600691545116358666202032110e-308L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, 0x1p511L, -0.5L, 1.570796326794896619231321691639751442099L, -1.112536929253600691545116358666202032110e-308L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -0x1p511L, 0.5L, -1.570796326794896619231321691639751442099L, 1.112536929253600691545116358666202032110e-308L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -0x1p511L, -0.5L, -1.570796326794896619231321691639751442099L, -1.112536929253600691545116358666202032110e-308L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, 0.5L, 0x1p511L, 1.570796326794896619231321691639751442099L, 1.491668146240041348658193063092586767475e-154L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -0.5L, 0x1p511L, -1.570796326794896619231321691639751442099L, 1.491668146240041348658193063092586767475e-154L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, 0.5L, -0x1p511L, 1.570796326794896619231321691639751442099L, -1.491668146240041348658193063092586767475e-154L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -0.5L, -0x1p511L, -1.570796326794896619231321691639751442099L, -1.491668146240041348658193063092586767475e-154L, 0|XFAIL_NATIVE_LINUX },
#endif
#if defined TEST_LDOUBLE && LDBL_MAX_EXP >= 16384
	TEST_c_c(catan, 0x1p8191L, 0.5L, 1.570796326794896619231321691639751442099L, 1.681051571556046753131338908660876301299e-4932L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, 0x1p8191L, -0.5L, 1.570796326794896619231321691639751442099L, -1.681051571556046753131338908660876301299e-4932L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, -0x1p8191L, 0.5L, -1.570796326794896619231321691639751442099L, 1.681051571556046753131338908660876301299e-4932L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, -0x1p8191L, -0.5L, -1.570796326794896619231321691639751442099L, -1.681051571556046753131338908660876301299e-4932L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, 0.5L, 0x1p8191L, 1.570796326794896619231321691639751442099L, 1.833603867554847165621412392048483165956e-2466L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, -0.5L, 0x1p8191L, -1.570796326794896619231321691639751442099L, 1.833603867554847165621412392048483165956e-2466L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, 0.5L, -0x1p8191L, 1.570796326794896619231321691639751442099L, -1.833603867554847165621412392048483165956e-2466L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, -0.5L, -0x1p8191L, -1.570796326794896619231321691639751442099L, -1.833603867554847165621412392048483165956e-2466L, 0|XFAIL_NATIVE_LINUXL },
#endif
	TEST_c_c(catan, 0x1p100L, 0.0L, 1.570796326794896619231321691638962581193L, 0.0L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catan, 0x1p100L, -0.0L, 1.570796326794896619231321691638962581193L, -0.0L, 0|XFAIL_NATIVE_LINUXF|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -0x1p100L, 0.0L, -1.570796326794896619231321691638962581193L, 0.0L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catan, -0x1p100L, -0.0L, -1.570796326794896619231321691638962581193L, -0.0L, 0|XFAIL_NATIVE_LINUXF|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, 0.0L, 0x1p100L, 1.570796326794896619231321691639751442099L, 7.888609052210118054117285652827862296732e-31L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -0.0L, 0x1p100L, -1.570796326794896619231321691639751442099L, 7.888609052210118054117285652827862296732e-31L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, 0.0L, -0x1p100L, 1.570796326794896619231321691639751442099L, -7.888609052210118054117285652827862296732e-31L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -0.0L, -0x1p100L, -1.570796326794896619231321691639751442099L, -7.888609052210118054117285652827862296732e-31L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, 0x1.fp127L, 0.0L, 1.570796326794896619231321691639751442096L, 0.0L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catan, 0x1.fp127L, -0.0L, 1.570796326794896619231321691639751442096L, -0.0L, 0|XFAIL_NATIVE_LINUXF|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -0x1.fp127L, 0.0L, -1.570796326794896619231321691639751442096L, 0.0L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catan, -0x1.fp127L, -0.0L, -1.570796326794896619231321691639751442096L, -0.0L, 0|XFAIL_NATIVE_LINUXF|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, 0.0L, 0x1.fp127L, 1.570796326794896619231321691639751442099L, 3.033533808573645181854803967025150136306e-39L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -0.0L, 0x1.fp127L, -1.570796326794896619231321691639751442099L, 3.033533808573645181854803967025150136306e-39L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, 0.0L, -0x1.fp127L, 1.570796326794896619231321691639751442099L, -3.033533808573645181854803967025150136306e-39L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -0.0L, -0x1.fp127L, -1.570796326794896619231321691639751442099L, -3.033533808573645181854803967025150136306e-39L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, 0x1.fp127L, 0x1.fp127L, 1.570796326794896619231321691639751442097L, 1.516766904286822590927401983512575068153e-39L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, 0x1.fp127L, -0x1.fp127L, 1.570796326794896619231321691639751442097L, -1.516766904286822590927401983512575068153e-39L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -0x1.fp127L, 0x1.fp127L, -1.570796326794896619231321691639751442097L, 1.516766904286822590927401983512575068153e-39L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -0x1.fp127L, -0x1.fp127L, -1.570796326794896619231321691639751442097L, -1.516766904286822590927401983512575068153e-39L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
#ifndef TEST_FLOAT
	TEST_c_c(catan, 0x1p900L, 0.0L, 1.570796326794896619231321691639751442099L, 0.0L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, 0x1p900L, -0.0L, 1.570796326794896619231321691639751442099L, -0.0L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -0x1p900L, 0.0L, -1.570796326794896619231321691639751442099L, 0.0L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -0x1p900L, -0.0L, -1.570796326794896619231321691639751442099L, -0.0L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, 0.0L, 0x1p900L, 1.570796326794896619231321691639751442099L, 1.183052186166774710972751597518026531652e-271L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -0.0L, 0x1p900L, -1.570796326794896619231321691639751442099L, 1.183052186166774710972751597518026531652e-271L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, 0.0L, -0x1p900L, 1.570796326794896619231321691639751442099L, -1.183052186166774710972751597518026531652e-271L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -0.0L, -0x1p900L, -1.570796326794896619231321691639751442099L, -1.183052186166774710972751597518026531652e-271L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, 0x1.fp1023L, 0.0L, 1.570796326794896619231321691639751442099L, 0.0L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, 0x1.fp1023L, -0.0L, 1.570796326794896619231321691639751442099L, -0.0L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -0x1.fp1023L, 0.0L, -1.570796326794896619231321691639751442099L, 0.0L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -0x1.fp1023L, -0.0L, -1.570796326794896619231321691639751442099L, -0.0L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, 0.0L, 0x1.fp1023L, 1.570796326794896619231321691639751442099L, 5.742126086470197117652213464083623391533e-309L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -0.0L, 0x1.fp1023L, -1.570796326794896619231321691639751442099L, 5.742126086470197117652213464083623391533e-309L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, 0.0L, -0x1.fp1023L, 1.570796326794896619231321691639751442099L, -5.742126086470197117652213464083623391533e-309L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -0.0L, -0x1.fp1023L, -1.570796326794896619231321691639751442099L, -5.742126086470197117652213464083623391533e-309L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, 0x1.fp1023L, 0x1.fp1023L, 1.570796326794896619231321691639751442099L, 2.871063043235098558826106732041811695767e-309L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, 0x1.fp1023L, -0x1.fp1023L, 1.570796326794896619231321691639751442099L, -2.871063043235098558826106732041811695767e-309L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -0x1.fp1023L, 0x1.fp1023L, -1.570796326794896619231321691639751442099L, 2.871063043235098558826106732041811695767e-309L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -0x1.fp1023L, -0x1.fp1023L, -1.570796326794896619231321691639751442099L, -2.871063043235098558826106732041811695767e-309L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
#endif
#if defined TEST_LDOUBLE && LDBL_MAX_EXP >= 16384
	TEST_c_c(catan, 0x1p10000L, 0.0L, 1.570796326794896619231321691639751442099L, 0.0L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, 0x1p10000L, -0.0L, 1.570796326794896619231321691639751442099L, -0.0L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, -0x1p10000L, 0.0L, -1.570796326794896619231321691639751442099L, 0.0L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, -0x1p10000L, -0.0L, -1.570796326794896619231321691639751442099L, -0.0L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, 0.0L, 0x1p10000L, 1.570796326794896619231321691639751442099L, 5.012372749206452009297555933742977749322e-3011L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, -0.0L, 0x1p10000L, -1.570796326794896619231321691639751442099L, 5.012372749206452009297555933742977749322e-3011L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, 0.0L, -0x1p10000L, 1.570796326794896619231321691639751442099L, -5.012372749206452009297555933742977749322e-3011L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, -0.0L, -0x1p10000L, -1.570796326794896619231321691639751442099L, -5.012372749206452009297555933742977749322e-3011L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, 0x1.fp16383L, 0.0L, 1.570796326794896619231321691639751442099L, 0.0L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, 0x1.fp16383L, -0.0L, 1.570796326794896619231321691639751442099L, -0.0L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, -0x1.fp16383L, 0.0L, -1.570796326794896619231321691639751442099L, 0.0L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, -0x1.fp16383L, -0.0L, -1.570796326794896619231321691639751442099L, -0.0L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, 0.0L, 0x1.fp16383L, 1.570796326794896619231321691639751442099L, 8.676395208031209048419813722120651877672e-4933L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, -0.0L, 0x1.fp16383L, -1.570796326794896619231321691639751442099L, 8.676395208031209048419813722120651877672e-4933L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, 0.0L, -0x1.fp16383L, 1.570796326794896619231321691639751442099L, -8.676395208031209048419813722120651877672e-4933L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, -0.0L, -0x1.fp16383L, -1.570796326794896619231321691639751442099L, -8.676395208031209048419813722120651877672e-4933L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, 0x1.fp16383L, 0x1.fp16383L, 1.570796326794896619231321691639751442099L, 4.338197604015604524209906861060325938836e-4933L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, 0x1.fp16383L, -0x1.fp16383L, 1.570796326794896619231321691639751442099L, -4.338197604015604524209906861060325938836e-4933L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, -0x1.fp16383L, 0x1.fp16383L, -1.570796326794896619231321691639751442099L, 4.338197604015604524209906861060325938836e-4933L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, -0x1.fp16383L, -0x1.fp16383L, -1.570796326794896619231321691639751442099L, -4.338197604015604524209906861060325938836e-4933L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
#endif
	TEST_c_c(catan, 0x1p-13L, 1.0L, 7.854286809755354140031716771044626356262e-1L, 4.852030264850939738801379894163661227127L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catan, 0x1p-13L, -1.0L, 7.854286809755354140031716771044626356262e-1L, -4.852030264850939738801379894163661227127L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catan, -0x1p-13L, 1.0L, -7.854286809755354140031716771044626356262e-1L, 4.852030264850939738801379894163661227127L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catan, -0x1p-13L, -1.0L, -7.854286809755354140031716771044626356262e-1L, -4.852030264850939738801379894163661227127L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catan, 1.0L, 0x1p-13L, 7.853981671227386080775748393881580082970e-1L, 6.103515609841754902688560615027452023669e-5L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catan, -1.0L, 0x1p-13L, -7.853981671227386080775748393881580082970e-1L, 6.103515609841754902688560615027452023669e-5L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catan, 1.0L, -0x1p-13L, 7.853981671227386080775748393881580082970e-1L, -6.103515609841754902688560615027452023669e-5L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catan, -1.0L, -0x1p-13L, -7.853981671227386080775748393881580082970e-1L, -6.103515609841754902688560615027452023669e-5L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catan, 0x1p-27L, 1.0L, 7.853981652600934588466178684534110069553e-1L, 9.704060527839234335310696652368086117807L, 0 },
	TEST_c_c(catan, 0x1p-27L, -1.0L, 7.853981652600934588466178684534110069553e-1L, -9.704060527839234335310696652368086117807L, 0 },
	TEST_c_c(catan, -0x1p-27L, 1.0L, -7.853981652600934588466178684534110069553e-1L, 9.704060527839234335310696652368086117807L, 0 },
	TEST_c_c(catan, -0x1p-27L, -1.0L, -7.853981652600934588466178684534110069553e-1L, -9.704060527839234335310696652368086117807L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catan, 1.0L, 0x1p-27L, 7.853981633974483234934486536343324763447e-1L, 3.725290298461914028034141143623846306386e-9L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catan, -1.0L, 0x1p-27L, -7.853981633974483234934486536343324763447e-1L, 3.725290298461914028034141143623846306386e-9L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catan, 1.0L, -0x1p-27L, 7.853981633974483234934486536343324763447e-1L, -3.725290298461914028034141143623846306386e-9L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catan, -1.0L, -0x1p-27L, -7.853981633974483234934486536343324763447e-1L, -3.725290298461914028034141143623846306386e-9L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catan, 0x1p-33L, 1.0L, 7.853981634265521400723945494331241018449e-1L, 1.178350206951907026009379309773625595762e1L, 0 },
	TEST_c_c(catan, 0x1p-33L, -1.0L, 7.853981634265521400723945494331241018449e-1L, -1.178350206951907026009379309773625595762e1L, 0 },
	TEST_c_c(catan, -0x1p-33L, 1.0L, -7.853981634265521400723945494331241018449e-1L, 1.178350206951907026009379309773625595762e1L, 0 },
	TEST_c_c(catan, -0x1p-33L, -1.0L, -7.853981634265521400723945494331241018449e-1L, -1.178350206951907026009379309773625595762e1L, 0 },
	TEST_c_c(catan, 1.0L, 0x1p-33L, 7.853981633974483096190489776088929224056e-1L, 5.820766091346740722643102318246316469910e-11L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catan, -1.0L, 0x1p-33L, -7.853981633974483096190489776088929224056e-1L, 5.820766091346740722643102318246316469910e-11L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catan, 1.0L, -0x1p-33L, 7.853981633974483096190489776088929224056e-1L, -5.820766091346740722643102318246316469910e-11L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catan, -1.0L, -0x1p-33L, -7.853981633974483096190489776088929224056e-1L, -5.820766091346740722643102318246316469910e-11L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catan, 0x1p-54L, 1.0L, 7.853981633974483234934486536343324763447e-1L, 1.906154746539849600897388334009985581467e1L, 0 },
	TEST_c_c(catan, 0x1p-54L, -1.0L, 7.853981633974483234934486536343324763447e-1L, -1.906154746539849600897388334009985581467e1L, 0 },
	TEST_c_c(catan, -0x1p-54L, 1.0L, -7.853981633974483234934486536343324763447e-1L, 1.906154746539849600897388334009985581467e1L, 0 },
	TEST_c_c(catan, -0x1p-54L, -1.0L, -7.853981633974483234934486536343324763447e-1L, -1.906154746539849600897388334009985581467e1L, 0 },
	TEST_c_c(catan, 1.0L, 0x1p-54L, 7.853981633974483096156608458198764914213e-1L, 2.775557561562891351059079170227049355775e-17L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -1.0L, 0x1p-54L, -7.853981633974483096156608458198764914213e-1L, 2.775557561562891351059079170227049355775e-17L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, 1.0L, -0x1p-54L, 7.853981633974483096156608458198764914213e-1L, -2.775557561562891351059079170227049355775e-17L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -1.0L, -0x1p-54L, -7.853981633974483096156608458198764914213e-1L, -2.775557561562891351059079170227049355775e-17L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, 0x1p-57L, 1.0L, 7.853981633974483113503843217966828154612e-1L, 2.010126823623841397309973152228712047720e1L, 0 },
	TEST_c_c(catan, 0x1p-57L, -1.0L, 7.853981633974483113503843217966828154612e-1L, -2.010126823623841397309973152228712047720e1L, 0 },
	TEST_c_c(catan, -0x1p-57L, 1.0L, -7.853981633974483113503843217966828154612e-1L, 2.010126823623841397309973152228712047720e1L, 0 },
	TEST_c_c(catan, -0x1p-57L, -1.0L, -7.853981633974483113503843217966828154612e-1L, -2.010126823623841397309973152228712047720e1L, 0 },
	TEST_c_c(catan, 1.0L, 0x1p-57L, 7.853981633974483096156608458198757330864e-1L, 3.469446951953614188823848962783813448721e-18L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -1.0L, 0x1p-57L, -7.853981633974483096156608458198757330864e-1L, 3.469446951953614188823848962783813448721e-18L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, 1.0L, -0x1p-57L, 7.853981633974483096156608458198757330864e-1L, -3.469446951953614188823848962783813448721e-18L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -1.0L, -0x1p-57L, -7.853981633974483096156608458198757330864e-1L, -3.469446951953614188823848962783813448721e-18L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, 0x1p-13L, 0x1.000002p0L, 7.859169620684960844300240092596908675974e-1L, 4.852030056234795712498957387213592193975L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catan, 0x1p-13L, -0x1.000002p0L, 7.859169620684960844300240092596908675974e-1L, -4.852030056234795712498957387213592193975L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catan, -0x1p-13L, 0x1.000002p0L, -7.859169620684960844300240092596908675974e-1L, 4.852030056234795712498957387213592193975L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catan, -0x1p-13L, -0x1.000002p0L, -7.859169620684960844300240092596908675974e-1L, -4.852030056234795712498957387213592193975L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catan, 0x1.000002p0L, 0x1p-13L, 7.853982267273793866654490522673596014524e-1L, 6.103514882246036852433556327261700380577e-5L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catan, -0x1.000002p0L, 0x1p-13L, -7.853982267273793866654490522673596014524e-1L, 6.103514882246036852433556327261700380577e-5L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catan, 0x1.000002p0L, -0x1p-13L, 7.853982267273793866654490522673596014524e-1L, -6.103514882246036852433556327261700380577e-5L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catan, -0x1.000002p0L, -0x1p-13L, -7.853982267273793866654490522673596014524e-1L, -6.103514882246036852433556327261700380577e-5L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catan, 0x1p-13L, 0x0.ffffffp0L, 7.851845403708474595909269086711426246675e-1L, 4.852030190345140708455871037447717761868L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catan, 0x1p-13L, -0x0.ffffffp0L, 7.851845403708474595909269086711426246675e-1L, -4.852030190345140708455871037447717761868L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catan, -0x1p-13L, 0x0.ffffffp0L, -7.851845403708474595909269086711426246675e-1L, 4.852030190345140708455871037447717761868L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catan, -0x1p-13L, -0x0.ffffffp0L, -7.851845403708474595909269086711426246675e-1L, -4.852030190345140708455871037447717761868L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catan, 0x0.ffffffp0L, 0x1p-13L, 7.853981373204155542484315721351697277336e-1L, 6.103515973639646453881721999956617260502e-5L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catan, -0x0.ffffffp0L, 0x1p-13L, -7.853981373204155542484315721351697277336e-1L, 6.103515973639646453881721999956617260502e-5L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catan, 0x0.ffffffp0L, -0x1p-13L, 7.853981373204155542484315721351697277336e-1L, -6.103515973639646453881721999956617260502e-5L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catan, -0x0.ffffffp0L, -0x1p-13L, -7.853981373204155542484315721351697277336e-1L, -6.103515973639646453881721999956617260502e-5L, 0|XFAIL_NATIVE_LINUXF },
#ifndef TEST_FLOAT
	TEST_c_c(catan, 0x1p-27L, 0x1.0000000000001p0L, 7.853981801612546526942695000283242525531e-1L, 9.704060527839234168777242958594699810015L, 0 },
	TEST_c_c(catan, 0x1p-27L, -0x1.0000000000001p0L, 7.853981801612546526942695000283242525531e-1L, -9.704060527839234168777242958594699810015L, 0 },
	TEST_c_c(catan, -0x1p-27L, 0x1.0000000000001p0L, -7.853981801612546526942695000283242525531e-1L, 9.704060527839234168777242958594699810015L, 0 },
	TEST_c_c(catan, -0x1p-27L, -0x1.0000000000001p0L, -7.853981801612546526942695000283242525531e-1L, -9.704060527839234168777242958594699810015L, 0 },
	TEST_c_c(catan, 0x1.0000000000001p0L, 0x1p-27L, 7.853981633974484345157511161499711112683e-1L, 3.725290298461913200853528590596263270474e-9L, 0 },
	TEST_c_c(catan, -0x1.0000000000001p0L, 0x1p-27L, -7.853981633974484345157511161499711112683e-1L, 3.725290298461913200853528590596263270474e-9L, 0 },
	TEST_c_c(catan, 0x1.0000000000001p0L, -0x1p-27L, 7.853981633974484345157511161499711112683e-1L, -3.725290298461913200853528590596263270474e-9L, 0 },
	TEST_c_c(catan, -0x1.0000000000001p0L, -0x1p-27L, -7.853981633974484345157511161499711112683e-1L, -3.725290298461913200853528590596263270474e-9L, 0 },
	TEST_c_c(catan, 0x1p-27L, 0x0.fffffffffffff8p0L, 7.853981578095128619227903983047292781021e-1L, 9.704060527839234252043969805481351363824L, 0 },
	TEST_c_c(catan, 0x1p-27L, -0x0.fffffffffffff8p0L, 7.853981578095128619227903983047292781021e-1L, -9.704060527839234252043969805481351363824L, 0 },
	TEST_c_c(catan, -0x1p-27L, 0x0.fffffffffffff8p0L, -7.853981578095128619227903983047292781021e-1L, 9.704060527839234252043969805481351363824L, 0 },
	TEST_c_c(catan, -0x1p-27L, -0x0.fffffffffffff8p0L, -7.853981578095128619227903983047292781021e-1L, -9.704060527839234252043969805481351363824L, 0 },
	TEST_c_c(catan, 0x0.fffffffffffff8p0L, 0x1p-27L, 7.853981633974482679822974223765039144191e-1L, 3.725290298461914441624447420137706700965e-9L, 0 },
	TEST_c_c(catan, -0x0.fffffffffffff8p0L, 0x1p-27L, -7.853981633974482679822974223765039144191e-1L, 3.725290298461914441624447420137706700965e-9L, 0 },
	TEST_c_c(catan, 0x0.fffffffffffff8p0L, -0x1p-27L, 7.853981633974482679822974223765039144191e-1L, -3.725290298461914441624447420137706700965e-9L, 0 },
	TEST_c_c(catan, -0x0.fffffffffffff8p0L, -0x1p-27L, -7.853981633974482679822974223765039144191e-1L, -3.725290298461914441624447420137706700965e-9L, 0 },
#endif
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	TEST_c_c(catan, 0x1p-33L, 0x1.0000000000000002p0L, 7.853981638922134273801338071094141188767e-1L, 1.178350206951907025990405771755129268176e1L, 0 },
	TEST_c_c(catan, 0x1p-33L, -0x1.0000000000000002p0L, 7.853981638922134273801338071094141188767e-1L, -1.178350206951907025990405771755129268176e1L, 0 },
	TEST_c_c(catan, -0x1p-33L, 0x1.0000000000000002p0L, -7.853981638922134273801338071094141188767e-1L, 1.178350206951907025990405771755129268176e1L, 0 },
	TEST_c_c(catan, -0x1p-33L, -0x1.0000000000000002p0L, -7.853981638922134273801338071094141188767e-1L, -1.178350206951907025990405771755129268176e1L, 0 },
	TEST_c_c(catan, 0x1.0000000000000002p0L, 0x1p-33L, 7.853981633974483096732590862331681441026e-1L, 5.820766091346740722012013594069507025615e-11L, 0 },
	TEST_c_c(catan, -0x1.0000000000000002p0L, 0x1p-33L, -7.853981633974483096732590862331681441026e-1L, 5.820766091346740722012013594069507025615e-11L, 0 },
	TEST_c_c(catan, 0x1.0000000000000002p0L, -0x1p-33L, 7.853981633974483096732590862331681441026e-1L, -5.820766091346740722012013594069507025615e-11L, 0 },
	TEST_c_c(catan, -0x1.0000000000000002p0L, -0x1p-33L, -7.853981633974483096732590862331681441026e-1L, -5.820766091346740722012013594069507025615e-11L, 0 },
	TEST_c_c(catan, 0x1p-33L, 0x0.ffffffffffffffffp0L, 7.853981631937214964185249205444919953948e-1L, 1.178350206951907026002603046195591193050e1L, 0 },
	TEST_c_c(catan, 0x1p-33L, -0x0.ffffffffffffffffp0L, 7.853981631937214964185249205444919953948e-1L, -1.178350206951907026002603046195591193050e1L, 0 },
	TEST_c_c(catan, -0x1p-33L, 0x0.ffffffffffffffffp0L, -7.853981631937214964185249205444919953948e-1L, 1.178350206951907026002603046195591193050e1L, 0 },
	TEST_c_c(catan, -0x1p-33L, -0x0.ffffffffffffffffp0L, -7.853981631937214964185249205444919953948e-1L, -1.178350206951907026002603046195591193050e1L, 0 },
	TEST_c_c(catan, 0x0.ffffffffffffffffp0L, 0x1p-33L, 7.853981633974483095919439232967553115548e-1L, 5.820766091346740722958646680334721192083e-11L, 0 },
	TEST_c_c(catan, -0x0.ffffffffffffffffp0L, 0x1p-33L, -7.853981633974483095919439232967553115548e-1L, 5.820766091346740722958646680334721192083e-11L, 0 },
	TEST_c_c(catan, 0x0.ffffffffffffffffp0L, -0x1p-33L, 7.853981633974483095919439232967553115548e-1L, -5.820766091346740722958646680334721192083e-11L, 0 },
	TEST_c_c(catan, -0x0.ffffffffffffffffp0L, -0x1p-33L, -7.853981633974483095919439232967553115548e-1L, -5.820766091346740722958646680334721192083e-11L, 0 },
#endif
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 106
	TEST_c_c(catan, 0x1p-54L, 0x1.000000000000000000000000008p0L, 7.853981633974485455380535786656405610710e-1L, 1.906154746539849600897388334009981267384e1L, 0 },
	TEST_c_c(catan, 0x1p-54L, -0x1.000000000000000000000000008p0L, 7.853981633974485455380535786656405610710e-1L, -1.906154746539849600897388334009981267384e1L, 0 },
	TEST_c_c(catan, -0x1p-54L, 0x1.000000000000000000000000008p0L, -7.853981633974485455380535786656405610710e-1L, 1.906154746539849600897388334009981267384e1L, 0 },
	TEST_c_c(catan, -0x1p-54L, -0x1.000000000000000000000000008p0L, -7.853981633974485455380535786656405610710e-1L, -1.906154746539849600897388334009981267384e1L, 0 },
	TEST_c_c(catan, 0x1.000000000000000000000000008p0L, 0x1p-54L, 7.853981633974483096156608458198888173729e-1L, 2.775557561562891351059079170226980932999e-17L, 0 },
	TEST_c_c(catan, -0x1.000000000000000000000000008p0L, 0x1p-54L, -7.853981633974483096156608458198888173729e-1L, 2.775557561562891351059079170226980932999e-17L, 0 },
	TEST_c_c(catan, 0x1.000000000000000000000000008p0L, -0x1p-54L, 7.853981633974483096156608458198888173729e-1L, -2.775557561562891351059079170226980932999e-17L, 0 },
	TEST_c_c(catan, -0x1.000000000000000000000000008p0L, -0x1p-54L, -7.853981633974483096156608458198888173729e-1L, -2.775557561562891351059079170226980932999e-17L, 0 },
	TEST_c_c(catan, 0x1p-54L, 0x0.ffffffffffffffffffffffffffcp0L, 7.853981633974482124711461911186784339815e-1L, 1.906154746539849600897388334009984040723e1L, 0 },
	TEST_c_c(catan, 0x1p-54L, -0x0.ffffffffffffffffffffffffffcp0L, 7.853981633974482124711461911186784339815e-1L, -1.906154746539849600897388334009984040723e1L, 0 },
	TEST_c_c(catan, -0x1p-54L, 0x0.ffffffffffffffffffffffffffcp0L, -7.853981633974482124711461911186784339815e-1L, 1.906154746539849600897388334009984040723e1L, 0 },
	TEST_c_c(catan, -0x1p-54L, -0x0.ffffffffffffffffffffffffffcp0L, -7.853981633974482124711461911186784339815e-1L, -1.906154746539849600897388334009984040723e1L, 0 },
	TEST_c_c(catan, 0x0.ffffffffffffffffffffffffffcp0L, 0x1p-54L, 7.853981633974483096156608458198703284454e-1L, 2.775557561562891351059079170227083567164e-17L, 0 },
	TEST_c_c(catan, -0x0.ffffffffffffffffffffffffffcp0L, 0x1p-54L, -7.853981633974483096156608458198703284454e-1L, 2.775557561562891351059079170227083567164e-17L, 0 },
	TEST_c_c(catan, 0x0.ffffffffffffffffffffffffffcp0L, -0x1p-54L, 7.853981633974483096156608458198703284454e-1L, -2.775557561562891351059079170227083567164e-17L, 0 },
	TEST_c_c(catan, -0x0.ffffffffffffffffffffffffffcp0L, -0x1p-54L, -7.853981633974483096156608458198703284454e-1L, -2.775557561562891351059079170227083567164e-17L, 0 },
#endif
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 113
	TEST_c_c(catan, 0x1p-57L, 0x1.0000000000000000000000000001p0L, 7.853981633974483252281721296111395707566e-1L, 2.010126823623841397309973152228712033275e1L, 0 },
	TEST_c_c(catan, 0x1p-57L, -0x1.0000000000000000000000000001p0L, 7.853981633974483252281721296111395707566e-1L, -2.010126823623841397309973152228712033275e1L, 0 },
	TEST_c_c(catan, -0x1p-57L, 0x1.0000000000000000000000000001p0L, -7.853981633974483252281721296111395707566e-1L, 2.010126823623841397309973152228712033275e1L, 0 },
	TEST_c_c(catan, -0x1p-57L, -0x1.0000000000000000000000000001p0L, -7.853981633974483252281721296111395707566e-1L, -2.010126823623841397309973152228712033275e1L, 0 },
	TEST_c_c(catan, 0x1.0000000000000000000000000001p0L, 0x1p-57L, 7.853981633974483096156608458198758293829e-1L, 3.469446951953614188823848962783812780530e-18L, 0 },
	TEST_c_c(catan, -0x1.0000000000000000000000000001p0L, 0x1p-57L, -7.853981633974483096156608458198758293829e-1L, 3.469446951953614188823848962783812780530e-18L, 0 },
	TEST_c_c(catan, 0x1.0000000000000000000000000001p0L, -0x1p-57L, 7.853981633974483096156608458198758293829e-1L, -3.469446951953614188823848962783812780530e-18L, 0 },
	TEST_c_c(catan, -0x1.0000000000000000000000000001p0L, -0x1p-57L, -7.853981633974483096156608458198758293829e-1L, -3.469446951953614188823848962783812780530e-18L, 0 },
	TEST_c_c(catan, 0x1p-57L, 0x0.ffffffffffffffffffffffffffff8p0L, 7.853981633974483044114904178894544378135e-1L, 2.010126823623841397309973152228712040498e1L, 0 },
	TEST_c_c(catan, 0x1p-57L, -0x0.ffffffffffffffffffffffffffff8p0L, 7.853981633974483044114904178894544378135e-1L, -2.010126823623841397309973152228712040498e1L, 0 },
	TEST_c_c(catan, -0x1p-57L, 0x0.ffffffffffffffffffffffffffff8p0L, -7.853981633974483044114904178894544378135e-1L, 2.010126823623841397309973152228712040498e1L, 0 },
	TEST_c_c(catan, -0x1p-57L, -0x0.ffffffffffffffffffffffffffff8p0L, -7.853981633974483044114904178894544378135e-1L, -2.010126823623841397309973152228712040498e1L, 0 },
	TEST_c_c(catan, 0x0.ffffffffffffffffffffffffffff8p0L, 0x1p-57L, 7.853981633974483096156608458198756849381e-1L, 3.469446951953614188823848962783813782817e-18L, 0 },
	TEST_c_c(catan, -0x0.ffffffffffffffffffffffffffff8p0L, 0x1p-57L, -7.853981633974483096156608458198756849381e-1L, 3.469446951953614188823848962783813782817e-18L, 0 },
	TEST_c_c(catan, 0x0.ffffffffffffffffffffffffffff8p0L, -0x1p-57L, 7.853981633974483096156608458198756849381e-1L, -3.469446951953614188823848962783813782817e-18L, 0 },
	TEST_c_c(catan, -0x0.ffffffffffffffffffffffffffff8p0L, -0x1p-57L, -7.853981633974483096156608458198756849381e-1L, -3.469446951953614188823848962783813782817e-18L, 0 },
#endif
	TEST_c_c(catan, 1.0L, 0x1p-64L, 7.853981633974483096156608458198757210500e-1L, 2.710505431213761085018632002174854278563e-20L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, 1.0L, -0x1p-64L, 7.853981633974483096156608458198757210500e-1L, -2.710505431213761085018632002174854278563e-20L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -1.0L, 0x1p-64L, -7.853981633974483096156608458198757210500e-1L, 2.710505431213761085018632002174854278563e-20L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -1.0L, -0x1p-64L, -7.853981633974483096156608458198757210500e-1L, -2.710505431213761085018632002174854278563e-20L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, 0x1p-64L, 1.0L, 7.853981633974483096292133729759445264744e-1L, 2.252728336819822255606004394739073846245e1L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catan, -0x1p-64L, 1.0L, -7.853981633974483096292133729759445264744e-1L, 2.252728336819822255606004394739073846245e1L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catan, 0x1p-64L, -1.0L, 7.853981633974483096292133729759445264744e-1L, -2.252728336819822255606004394739073846245e1L, 0 },
	TEST_c_c(catan, -0x1p-64L, -1.0L, -7.853981633974483096292133729759445264744e-1L, -2.252728336819822255606004394739073846245e1L, 0 },
	TEST_c_c(catan, 1.0L, 0x1.3p-73L, 7.853981633974483096156608458198757210493e-1L, 6.286572655403010329022706059731717687100e-23L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, 1.0L, -0x1.3p-73L, 7.853981633974483096156608458198757210493e-1L, -6.286572655403010329022706059731717687100e-23L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -1.0L, 0x1.3p-73L, -7.853981633974483096156608458198757210493e-1L, 6.286572655403010329022706059731717687100e-23L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -1.0L, -0x1.3p-73L, -7.853981633974483096156608458198757210493e-1L, -6.286572655403010329022706059731717687100e-23L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, 0x1.3p-73L, 1.0L, 7.853981633974483096156922786831527361009e-1L, 2.556052055225464683726753902092495938633e1L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catan, -0x1.3p-73L, 1.0L, -7.853981633974483096156922786831527361009e-1L, 2.556052055225464683726753902092495938633e1L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catan, 0x1.3p-73L, -1.0L, 7.853981633974483096156922786831527361009e-1L, -2.556052055225464683726753902092495938633e1L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catan, -0x1.3p-73L, -1.0L, -7.853981633974483096156922786831527361009e-1L, -2.556052055225464683726753902092495938633e1L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catan, 1.0L, 0x1p-124L, 7.853981633974483096156608458198757210493e-1L, 2.350988701644575015937473074444491355637e-38L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, 1.0L, -0x1p-124L, 7.853981633974483096156608458198757210493e-1L, -2.350988701644575015937473074444491355637e-38L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -1.0L, 0x1p-124L, -7.853981633974483096156608458198757210493e-1L, 2.350988701644575015937473074444491355637e-38L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -1.0L, -0x1p-124L, -7.853981633974483096156608458198757210493e-1L, -2.350988701644575015937473074444491355637e-38L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, 0x1p-124L, 1.0L, 7.853981633974483096156608458198757210610e-1L, 4.332169878499658183857700759113603550472e1L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catan, -0x1p-124L, 1.0L, -7.853981633974483096156608458198757210610e-1L, 4.332169878499658183857700759113603550472e1L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catan, 0x1p-124L, -1.0L, 7.853981633974483096156608458198757210610e-1L, -4.332169878499658183857700759113603550472e1L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catan, -0x1p-124L, -1.0L, -7.853981633974483096156608458198757210610e-1L, -4.332169878499658183857700759113603550472e1L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catan, 0x1.000002p0L, 0x1p-126L, 7.853982230020895322927482174768220815493e-1L, 5.877471053462247139383742414506671233336e-39L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, 0x1.000002p0L, -0x1p-126L, 7.853982230020895322927482174768220815493e-1L, -5.877471053462247139383742414506671233336e-39L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -0x1.000002p0L, 0x1p-126L, -7.853982230020895322927482174768220815493e-1L, 5.877471053462247139383742414506671233336e-39L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -0x1.000002p0L, -0x1p-126L, -7.853982230020895322927482174768220815493e-1L, -5.877471053462247139383742414506671233336e-39L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, 0x1p-126L, 0x1.000002p0L, 1.570796326794896619231321691639702138295L, 8.317766196521665212523713550410777685446L, 0 },
	TEST_c_c(catan, -0x1p-126L, 0x1.000002p0L, -1.570796326794896619231321691639702138295L, 8.317766196521665212523713550410777685446L, 0 },
	TEST_c_c(catan, 0x1p-126L, -0x1.000002p0L, 1.570796326794896619231321691639702138295L, -8.317766196521665212523713550410777685446L, 0 },
	TEST_c_c(catan, -0x1p-126L, -0x1.000002p0L, -1.570796326794896619231321691639702138295L, -8.317766196521665212523713550410777685446L, 0 },
	TEST_c_c(catan, 0x0.ffffffp0L, 0x1p-126L, 7.853981335951250337419109991749089175724e-1L, 5.877472104436064061535099214664320916184e-39L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, 0x0.ffffffp0L, -0x1p-126L, 7.853981335951250337419109991749089175724e-1L, -5.877472104436064061535099214664320916184e-39L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -0x0.ffffffp0L, 0x1p-126L, -7.853981335951250337419109991749089175724e-1L, 5.877472104436064061535099214664320916184e-39L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -0x0.ffffffp0L, -0x1p-126L, -7.853981335951250337419109991749089175724e-1L, -5.877472104436064061535099214664320916184e-39L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, 0x1p-126L, 0x0.ffffffp0L, 9.860761609136244031334147100512154160097e-32L, 8.664339742098154951823135931565866792454L, 0 },
	TEST_c_c(catan, -0x1p-126L, 0x0.ffffffp0L, -9.860761609136244031334147100512154160097e-32L, 8.664339742098154951823135931565866792454L, 0 },
	TEST_c_c(catan, 0x1p-126L, -0x0.ffffffp0L, 9.860761609136244031334147100512154160097e-32L, -8.664339742098154951823135931565866792454L, 0 },
	TEST_c_c(catan, -0x1p-126L, -0x0.ffffffp0L, -9.860761609136244031334147100512154160097e-32L, -8.664339742098154951823135931565866792454L, 0 },
#ifndef TEST_FLOAT
	TEST_c_c(catan, 1.0L, 0x1p-512L, 7.853981633974483096156608458198757210493e-1L, 3.729170365600103371645482657731466918688e-155L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, 1.0L, -0x1p-512L, 7.853981633974483096156608458198757210493e-1L, -3.729170365600103371645482657731466918688e-155L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -1.0L, 0x1p-512L, -7.853981633974483096156608458198757210493e-1L, 3.729170365600103371645482657731466918688e-155L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -1.0L, -0x1p-512L, -7.853981633974483096156608458198757210493e-1L, -3.729170365600103371645482657731466918688e-155L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, 0x1p-512L, 1.0L, 7.853981633974483096156608458198757210493e-1L, 1.777922518136259718655200391540222897114e2L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -0x1p-512L, 1.0L, -7.853981633974483096156608458198757210493e-1L, 1.777922518136259718655200391540222897114e2L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, 0x1p-512L, -1.0L, 7.853981633974483096156608458198757210493e-1L, -1.777922518136259718655200391540222897114e2L, 0 },
	TEST_c_c(catan, -0x1p-512L, -1.0L, -7.853981633974483096156608458198757210493e-1L, -1.777922518136259718655200391540222897114e2L, 0 },
	TEST_c_c(catan, 1.0L, 0x1.3p-536L, 7.853981633974483096156608458198757210493e-1L, 2.639526015013529511588222179446290115084e-162L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, 1.0L, -0x1.3p-536L, 7.853981633974483096156608458198757210493e-1L, -2.639526015013529511588222179446290115084e-162L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -1.0L, 0x1.3p-536L, -7.853981633974483096156608458198757210493e-1L, 2.639526015013529511588222179446290115084e-162L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -1.0L, -0x1.3p-536L, -7.853981633974483096156608458198757210493e-1L, -2.639526015013529511588222179446290115084e-162L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, 0x1.3p-536L, 1.0L, 7.853981633974483096156608458198757210493e-1L, 1.860240928518819859673567751384928348958e2L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -0x1.3p-536L, 1.0L, -7.853981633974483096156608458198757210493e-1L, 1.860240928518819859673567751384928348958e2L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, 0x1.3p-536L, -1.0L, 7.853981633974483096156608458198757210493e-1L, -1.860240928518819859673567751384928348958e2L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -0x1.3p-536L, -1.0L, -7.853981633974483096156608458198757210493e-1L, -1.860240928518819859673567751384928348958e2L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, 1.0L, 0x1p-1020L, 7.853981633974483096156608458198757210493e-1L, 4.450147717014402766180465434664808128438e-308L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, 1.0L, -0x1p-1020L, 7.853981633974483096156608458198757210493e-1L, -4.450147717014402766180465434664808128438e-308L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -1.0L, 0x1p-1020L, -7.853981633974483096156608458198757210493e-1L, 4.450147717014402766180465434664808128438e-308L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -1.0L, -0x1p-1020L, -7.853981633974483096156608458198757210493e-1L, -4.450147717014402766180465434664808128438e-308L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, 0x1p-1020L, 1.0L, 7.853981633974483096156608458198757210493e-1L, 3.538516356758520804574969980043991380025e2L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -0x1p-1020L, 1.0L, -7.853981633974483096156608458198757210493e-1L, 3.538516356758520804574969980043991380025e2L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, 0x1p-1020L, -1.0L, 7.853981633974483096156608458198757210493e-1L, -3.538516356758520804574969980043991380025e2L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -0x1p-1020L, -1.0L, -7.853981633974483096156608458198757210493e-1L, -3.538516356758520804574969980043991380025e2L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, 0x1.0000000000001p0L, 0x1p-1022L, 7.853981633974484206379633083355174374608e-1L, 1.112536929253600444512293438042957369978e-308L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, 0x1.0000000000001p0L, -0x1p-1022L, 7.853981633974484206379633083355174374608e-1L, -1.112536929253600444512293438042957369978e-308L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -0x1.0000000000001p0L, 0x1p-1022L, -7.853981633974484206379633083355174374608e-1L, 1.112536929253600444512293438042957369978e-308L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -0x1.0000000000001p0L, -0x1p-1022L, -7.853981633974484206379633083355174374608e-1L, -1.112536929253600444512293438042957369978e-308L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, 0x1p-1022L, 0x1.0000000000001p0L, 1.570796326794896619231321691639751442099L, 1.836840028483855075506780244989950299369e1L, 0 },
	TEST_c_c(catan, -0x1p-1022L, 0x1.0000000000001p0L, -1.570796326794896619231321691639751442099L, 1.836840028483855075506780244989950299369e1L, 0 },
	TEST_c_c(catan, 0x1p-1022L, -0x1.0000000000001p0L, 1.570796326794896619231321691639751442099L, -1.836840028483855075506780244989950299369e1L, 0 },
	TEST_c_c(catan, -0x1p-1022L, -0x1.0000000000001p0L, -1.570796326794896619231321691639751442099L, -1.836840028483855075506780244989950299369e1L, 0 },
	TEST_c_c(catan, 0x0.fffffffffffff8p0L, 0x1p-1022L, 7.853981633974482541045096145620456183798e-1L, 1.112536929253600815061527818977844932790e-308L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, 0x0.fffffffffffff8p0L, -0x1p-1022L, 7.853981633974482541045096145620456183798e-1L, -1.112536929253600815061527818977844932790e-308L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -0x0.fffffffffffff8p0L, 0x1p-1022L, -7.853981633974482541045096145620456183798e-1L, 1.112536929253600815061527818977844932790e-308L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, -0x0.fffffffffffff8p0L, -0x1p-1022L, -7.853981633974482541045096145620456183798e-1L, -1.112536929253600815061527818977844932790e-308L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(catan, 0x1p-1022L, 0x0.fffffffffffff8p0L, 1.002084180004486444624900488355118689113e-292L, 1.871497387511852332650969166374185305708e1L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM },
	TEST_c_c(catan, -0x1p-1022L, 0x0.fffffffffffff8p0L, -1.002084180004486444624900488355118689113e-292L, 1.871497387511852332650969166374185305708e1L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM },
	TEST_c_c(catan, 0x1p-1022L, -0x0.fffffffffffff8p0L, 1.002084180004486444624900488355118689113e-292L, -1.871497387511852332650969166374185305708e1L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM },
	TEST_c_c(catan, -0x1p-1022L, -0x0.fffffffffffff8p0L, -1.002084180004486444624900488355118689113e-292L, -1.871497387511852332650969166374185305708e1L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM },
#endif
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	TEST_c_c(catan, 0x1.0000000000000002p0L, 0x1p-1022L, 7.853981633974483096698709544441509427467e-1L, 1.112536929253600691424494863099491450042e-308L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, 0x1.0000000000000002p0L, -0x1p-1022L, 7.853981633974483096698709544441509427467e-1L, -1.112536929253600691424494863099491450042e-308L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, -0x1.0000000000000002p0L, 0x1p-1022L, -7.853981633974483096698709544441509427467e-1L, 1.112536929253600691424494863099491450042e-308L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, -0x1.0000000000000002p0L, -0x1p-1022L, -7.853981633974483096698709544441509427467e-1L, -1.112536929253600691424494863099491450042e-308L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, 0x1p-1022L, 0x1.0000000000000002p0L, 1.570796326794896619231321691639751442099L, 2.218070977791824990137853294097378778927e1L, 0 },
	TEST_c_c(catan, -0x1p-1022L, 0x1.0000000000000002p0L, -1.570796326794896619231321691639751442099L, 2.218070977791824990137853294097378778927e1L, 0 },
	TEST_c_c(catan, 0x1p-1022L, -0x1.0000000000000002p0L, 1.570796326794896619231321691639751442099L, -2.218070977791824990137853294097378778927e1L, 0 },
	TEST_c_c(catan, -0x1p-1022L, -0x1.0000000000000002p0L, -1.570796326794896619231321691639751442099L, -2.218070977791824990137853294097378778927e1L, 0 },
	TEST_c_c(catan, 0x0.ffffffffffffffffp0L, 0x1p-1022L, 7.853981633974483095885557915077381101984e-1L, 1.112536929253600691605427106449557323148e-308L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, 0x0.ffffffffffffffffp0L, -0x1p-1022L, 7.853981633974483095885557915077381101984e-1L, -1.112536929253600691605427106449557323148e-308L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, -0x0.ffffffffffffffffp0L, 0x1p-1022L, -7.853981633974483095885557915077381101984e-1L, 1.112536929253600691605427106449557323148e-308L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, -0x0.ffffffffffffffffp0L, -0x1p-1022L, -7.853981633974483095885557915077381101984e-1L, -1.112536929253600691605427106449557323148e-308L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, 0x1p-1022L, 0x0.ffffffffffffffffp0L, 2.052268400649188124723641491045245971623e-289L, 2.252728336819822255604649142023466965703e1L, 0 },
	TEST_c_c(catan, -0x1p-1022L, 0x0.ffffffffffffffffp0L, -2.052268400649188124723641491045245971623e-289L, 2.252728336819822255604649142023466965703e1L, 0 },
	TEST_c_c(catan, 0x1p-1022L, -0x0.ffffffffffffffffp0L, 2.052268400649188124723641491045245971623e-289L, -2.252728336819822255604649142023466965703e1L, 0 },
	TEST_c_c(catan, -0x1p-1022L, -0x0.ffffffffffffffffp0L, -2.052268400649188124723641491045245971623e-289L, -2.252728336819822255604649142023466965703e1L, 0 },
#endif
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 106
	TEST_c_c(catan, 0x1.000000000000000000000000008p0L, 0x1p-1022L, 7.853981633974483096156608458198880470009e-1L, 1.112536929253600691545116358666174605957e-308L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(catan, 0x1.000000000000000000000000008p0L, -0x1p-1022L, 7.853981633974483096156608458198880470009e-1L, -1.112536929253600691545116358666174605957e-308L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(catan, -0x1.000000000000000000000000008p0L, 0x1p-1022L, -7.853981633974483096156608458198880470009e-1L, 1.112536929253600691545116358666174605957e-308L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(catan, -0x1.000000000000000000000000008p0L, -0x1p-1022L, -7.853981633974483096156608458198880470009e-1L, -1.112536929253600691545116358666174605957e-308L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(catan, 0x1p-1022L, 0x1.000000000000000000000000008p0L, 1.570796326794896619231321691639751442099L, 3.673680056967710139911330243728336427098e1L, 0 },
	TEST_c_c(catan, -0x1p-1022L, 0x1.000000000000000000000000008p0L, -1.570796326794896619231321691639751442099L, 3.673680056967710139911330243728336427098e1L, 0 },
	TEST_c_c(catan, 0x1p-1022L, -0x1.000000000000000000000000008p0L, 1.570796326794896619231321691639751442099L, -3.673680056967710139911330243728336427098e1L, 0 },
	TEST_c_c(catan, -0x1p-1022L, -0x1.000000000000000000000000008p0L, -1.570796326794896619231321691639751442099L, -3.673680056967710139911330243728336427098e1L, 0 },
	TEST_c_c(catan, 0x0.ffffffffffffffffffffffffffcp0L, 0x1p-1022L, 7.853981633974483096156608458198695580735e-1L, 1.112536929253600691545116358666215745186e-308L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(catan, 0x0.ffffffffffffffffffffffffffcp0L, -0x1p-1022L, 7.853981633974483096156608458198695580735e-1L, -1.112536929253600691545116358666215745186e-308L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(catan, -0x0.ffffffffffffffffffffffffffcp0L, 0x1p-1022L, -7.853981633974483096156608458198695580735e-1L, 1.112536929253600691545116358666215745186e-308L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(catan, -0x0.ffffffffffffffffffffffffffcp0L, -0x1p-1022L, -7.853981633974483096156608458198695580735e-1L, -1.112536929253600691545116358666215745186e-308L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(catan, 0x1p-1022L, 0x0.ffffffffffffffffffffffffffcp0L, 9.025971879324147880346310405868788320726e-277L, 3.708337415995707405382191849801244331055e1L, 0 },
	TEST_c_c(catan, -0x1p-1022L, 0x0.ffffffffffffffffffffffffffcp0L, -9.025971879324147880346310405868788320726e-277L, 3.708337415995707405382191849801244331055e1L, 0 },
	TEST_c_c(catan, 0x1p-1022L, -0x0.ffffffffffffffffffffffffffcp0L, 9.025971879324147880346310405868788320726e-277L, -3.708337415995707405382191849801244331055e1L, 0 },
	TEST_c_c(catan, -0x1p-1022L, -0x0.ffffffffffffffffffffffffffcp0L, -9.025971879324147880346310405868788320726e-277L, -3.708337415995707405382191849801244331055e1L, 0 },
#endif
#if defined TEST_LDOUBLE && LDBL_MAX_EXP >= 16384
	TEST_c_c(catan, 1.0L, 0x1p-8192L, 7.853981633974483096156608458198757210493e-1L, 4.584009668887117914053530980121207914891e-2467L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, 1.0L, -0x1p-8192L, 7.853981633974483096156608458198757210493e-1L, -4.584009668887117914053530980121207914891e-2467L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, -1.0L, 0x1p-8192L, -7.853981633974483096156608458198757210493e-1L, 4.584009668887117914053530980121207914891e-2467L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, -1.0L, -0x1p-8192L, -7.853981633974483096156608458198757210493e-1L, -4.584009668887117914053530980121207914891e-2467L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, 0x1p-8192L, 1.0L, 7.853981633974483096156608458198757210493e-1L, 2.839477425163815960027691385553420311121e3L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, -0x1p-8192L, 1.0L, -7.853981633974483096156608458198757210493e-1L, 2.839477425163815960027691385553420311121e3L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, 0x1p-8192L, -1.0L, 7.853981633974483096156608458198757210493e-1L, -2.839477425163815960027691385553420311121e3L, 0 },
	TEST_c_c(catan, -0x1p-8192L, -1.0L, -7.853981633974483096156608458198757210493e-1L, -2.839477425163815960027691385553420311121e3L, 0 },
	TEST_c_c(catan, 1.0L, 0x1.3p-8221L, 7.853981633974483096156608458198757210493e-1L, 1.013933025636421986471594877335044443409e-2475L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, 1.0L, -0x1.3p-8221L, 7.853981633974483096156608458198757210493e-1L, -1.013933025636421986471594877335044443409e-2475L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, -1.0L, 0x1.3p-8221L, -7.853981633974483096156608458198757210493e-1L, 1.013933025636421986471594877335044443409e-2475L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, -1.0L, -0x1.3p-8221L, -7.853981633974483096156608458198757210493e-1L, -1.013933025636421986471594877335044443409e-2475L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, 0x1.3p-8221L, 1.0L, 7.853981633974483096156608458198757210493e-1L, 2.849442134153471837403071201841536297726e3L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, -0x1.3p-8221L, 1.0L, -7.853981633974483096156608458198757210493e-1L, 2.849442134153471837403071201841536297726e3L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, 0x1.3p-8221L, -1.0L, 7.853981633974483096156608458198757210493e-1L, -2.849442134153471837403071201841536297726e3L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, -0x1.3p-8221L, -1.0L, -7.853981633974483096156608458198757210493e-1L, -2.849442134153471837403071201841536297726e3L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, 1.0L, 0x1.3p-8246L, 7.853981633974483096156608458198757210493e-1L, 3.021755890954798419688924781486524472858e-2483L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, 1.0L, -0x1.3p-8246L, 7.853981633974483096156608458198757210493e-1L, -3.021755890954798419688924781486524472858e-2483L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, -1.0L, 0x1.3p-8246L, -7.853981633974483096156608458198757210493e-1L, 3.021755890954798419688924781486524472858e-2483L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, -1.0L, -0x1.3p-8246L, -7.853981633974483096156608458198757210493e-1L, -3.021755890954798419688924781486524472858e-2483L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, 0x1.3p-8246L, 1.0L, 7.853981633974483096156608458198757210493e-1L, 2.858106473910471153770786603359763504827e3L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, -0x1.3p-8246L, 1.0L, -7.853981633974483096156608458198757210493e-1L, 2.858106473910471153770786603359763504827e3L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, 0x1.3p-8246L, -1.0L, 7.853981633974483096156608458198757210493e-1L, -2.858106473910471153770786603359763504827e3L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, -0x1.3p-8246L, -1.0L, -7.853981633974483096156608458198757210493e-1L, -2.858106473910471153770786603359763504827e3L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, 1.0L, 0x1p-16380L, 7.853981633974483096156608458198757210493e-1L, 6.724206286224187012525355634643505205196e-4932L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, 1.0L, -0x1p-16380L, 7.853981633974483096156608458198757210493e-1L, -6.724206286224187012525355634643505205196e-4932L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, -1.0L, 0x1p-16380L, -7.853981633974483096156608458198757210493e-1L, 6.724206286224187012525355634643505205196e-4932L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, -1.0L, -0x1p-16380L, -7.853981633974483096156608458198757210493e-1L, -6.724206286224187012525355634643505205196e-4932L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, 0x1p-16380L, 1.0L, 7.853981633974483096156608458198757210493e-1L, 5.677221982376232056781839690803195180822e3L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, -0x1p-16380L, 1.0L, -7.853981633974483096156608458198757210493e-1L, 5.677221982376232056781839690803195180822e3L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, 0x1p-16380L, -1.0L, 7.853981633974483096156608458198757210493e-1L, -5.677221982376232056781839690803195180822e3L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, -0x1p-16380L, -1.0L, -7.853981633974483096156608458198757210493e-1L, -5.677221982376232056781839690803195180822e3L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, 0x1.0000000000000002p0L, 0x1p-16382L, 7.853981633974483096698709544441509427467e-1L, 1.681051571556046752949078932066752571182e-4932L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, 0x1.0000000000000002p0L, -0x1p-16382L, 7.853981633974483096698709544441509427467e-1L, -1.681051571556046752949078932066752571182e-4932L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, -0x1.0000000000000002p0L, 0x1p-16382L, -7.853981633974483096698709544441509427467e-1L, 1.681051571556046752949078932066752571182e-4932L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, -0x1.0000000000000002p0L, -0x1p-16382L, -7.853981633974483096698709544441509427467e-1L, -1.681051571556046752949078932066752571182e-4932L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, 0x1p-16382L, 0x1.0000000000000002p0L, 1.570796326794896619231321691639751442099L, 2.218070977791824990137853294097378778927e1L, 0 },
	TEST_c_c(catan, -0x1p-16382L, 0x1.0000000000000002p0L, -1.570796326794896619231321691639751442099L, 2.218070977791824990137853294097378778927e1L, 0 },
	TEST_c_c(catan, 0x1p-16382L, -0x1.0000000000000002p0L, 1.570796326794896619231321691639751442099L, -2.218070977791824990137853294097378778927e1L, 0 },
	TEST_c_c(catan, -0x1p-16382L, -0x1.0000000000000002p0L, -1.570796326794896619231321691639751442099L, -2.218070977791824990137853294097378778927e1L, 0 },
	TEST_c_c(catan, 0x0.ffffffffffffffffp0L, 0x1p-16382L, 7.853981633974483095885557915077381101984e-1L, 1.681051571556046753222468896957938166365e-4932L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, 0x0.ffffffffffffffffp0L, -0x1p-16382L, 7.853981633974483095885557915077381101984e-1L, -1.681051571556046753222468896957938166365e-4932L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, -0x0.ffffffffffffffffp0L, 0x1p-16382L, -7.853981633974483095885557915077381101984e-1L, 1.681051571556046753222468896957938166365e-4932L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, -0x0.ffffffffffffffffp0L, -0x1p-16382L, -7.853981633974483095885557915077381101984e-1L, -1.681051571556046753222468896957938166365e-4932L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catan, 0x1p-16382L, 0x0.ffffffffffffffffp0L, 3.100992811520163369065387859792822623745e-4913L, 2.252728336819822255604649142023466965703e1L, 0 },
	TEST_c_c(catan, -0x1p-16382L, 0x0.ffffffffffffffffp0L, -3.100992811520163369065387859792822623745e-4913L, 2.252728336819822255604649142023466965703e1L, 0 },
	TEST_c_c(catan, 0x1p-16382L, -0x0.ffffffffffffffffp0L, 3.100992811520163369065387859792822623745e-4913L, -2.252728336819822255604649142023466965703e1L, 0 },
	TEST_c_c(catan, -0x1p-16382L, -0x0.ffffffffffffffffp0L, -3.100992811520163369065387859792822623745e-4913L, -2.252728336819822255604649142023466965703e1L, 0 },
# if LDBL_MANT_DIG >= 113
	TEST_c_c(catan, 0x1.0000000000000000000000000001p0L, 0x1p-16382L, 7.853981633974483096156608458198758173458e-1L, 1.681051571556046753131338908660875977540e-4932L, UNDERFLOW_EXCEPTION },
	TEST_c_c(catan, 0x1.0000000000000000000000000001p0L, -0x1p-16382L, 7.853981633974483096156608458198758173458e-1L, -1.681051571556046753131338908660875977540e-4932L, UNDERFLOW_EXCEPTION },
	TEST_c_c(catan, -0x1.0000000000000000000000000001p0L, 0x1p-16382L, -7.853981633974483096156608458198758173458e-1L, 1.681051571556046753131338908660875977540e-4932L, UNDERFLOW_EXCEPTION },
	TEST_c_c(catan, -0x1.0000000000000000000000000001p0L, -0x1p-16382L, -7.853981633974483096156608458198758173458e-1L, -1.681051571556046753131338908660875977540e-4932L, UNDERFLOW_EXCEPTION },
	TEST_c_c(catan, 0x1p-16382L, 0x1.0000000000000000000000000001p0L, 1.570796326794896619231321691639751442099L, 3.916281570163690998207361486238697614441e1L, 0 },
	TEST_c_c(catan, -0x1p-16382L, 0x1.0000000000000000000000000001p0L, -1.570796326794896619231321691639751442099L, 3.916281570163690998207361486238697614441e1L, 0 },
	TEST_c_c(catan, 0x1p-16382L, -0x1.0000000000000000000000000001p0L, 1.570796326794896619231321691639751442099L, -3.916281570163690998207361486238697614441e1L, 0 },
	TEST_c_c(catan, -0x1p-16382L, -0x1.0000000000000000000000000001p0L, -1.570796326794896619231321691639751442099L, -3.916281570163690998207361486238697614441e1L, 0 },
	TEST_c_c(catan, 0x0.ffffffffffffffffffffffffffff8p0L, 0x1p-16382L, 7.853981633974483096156608458198756729010e-1L, 1.681051571556046753131338908660876463178e-4932L, UNDERFLOW_EXCEPTION },
	TEST_c_c(catan, 0x0.ffffffffffffffffffffffffffff8p0L, -0x1p-16382L, 7.853981633974483096156608458198756729010e-1L, -1.681051571556046753131338908660876463178e-4932L, UNDERFLOW_EXCEPTION },
	TEST_c_c(catan, -0x0.ffffffffffffffffffffffffffff8p0L, 0x1p-16382L, -7.853981633974483096156608458198756729010e-1L, 1.681051571556046753131338908660876463178e-4932L, UNDERFLOW_EXCEPTION },
	TEST_c_c(catan, -0x0.ffffffffffffffffffffffffffff8p0L, -0x1p-16382L, -7.853981633974483096156608458198756729010e-1L, -1.681051571556046753131338908660876463178e-4932L, UNDERFLOW_EXCEPTION },
	TEST_c_c(catan, 0x1p-16382L, 0x0.ffffffffffffffffffffffffffff8p0L, 1.745703758805099310527547423749501866998e-4898L, 3.950938929191688263678223092311606435623e1L, 0 },
	TEST_c_c(catan, -0x1p-16382L, 0x0.ffffffffffffffffffffffffffff8p0L, -1.745703758805099310527547423749501866998e-4898L, 3.950938929191688263678223092311606435623e1L, 0 },
	TEST_c_c(catan, 0x1p-16382L, -0x0.ffffffffffffffffffffffffffff8p0L, 1.745703758805099310527547423749501866998e-4898L, -3.950938929191688263678223092311606435623e1L, 0 },
	TEST_c_c(catan, -0x1p-16382L, -0x0.ffffffffffffffffffffffffffff8p0L, -1.745703758805099310527547423749501866998e-4898L, -3.950938929191688263678223092311606435623e1L, 0 },
# endif
#endif

	TEST_c_c(catan, 0.75L, 1.25L, 1.10714871779409050301706546017853704L, 0.549306144334054845697622618461262852L, 0 },
	TEST_c_c(catan, -2, -3, -1.4099210495965755225306193844604208L, -0.22907268296853876629588180294200276L, 0 },
}


static void test_catanh(void)
{
	struct test *testp = lookup("catanh" },

	TEST_c_c(catan, 1.0e00, 2.0e00, 1.338972523808479309e00, 4.023594781756401062e-01, 0 },
	TEST_c_c(catan, 0.0e00, 2.0e00, 1.570796325802803039e00, 5.493061468005180358e-01, 0 },
	TEST_c_c(catan, 1.0e00, 0.0e00, 7.853981629014015197e-01, 0.0e00, 0 },
	TEST_c_c(catan, -2.0e00, 2.0e00, -1.311223268508911132e00, 2.388778626918792724e-01, 0 },
	TEST_c_c(catan, -1.0e00, -2.0e00, -1.338972523808479309e00, -4.023594819009304046e-01, 0 },
	TEST_c_c(catan, 1.0e00, -2.0e00, 1.338972523808479309e00, -4.023594819009304046e-01, 0 },

	TEST_c_c(catanh, 0, 0, 0.0, 0.0, 0 },
	TEST_c_c(catanh, ZERO_M, 0, ZERO_M, 0.0, 0 },
	TEST_c_c(catanh, 0, ZERO_M, 0.0, ZERO_M, 0 },
	TEST_c_c(catanh, ZERO_M, ZERO_M, ZERO_M, ZERO_M, 0 },

	TEST_c_c(catanh, 1.0L, ZERO_P, INF_P, ZERO_P, DIVIDE_BY_ZERO_EXCEPTION },
	TEST_c_c(catanh, 1.0L, ZERO_M, INF_P, ZERO_M, DIVIDE_BY_ZERO_EXCEPTION },
	TEST_c_c(catanh, -1.0L, ZERO_P, INF_M, ZERO_P, DIVIDE_BY_ZERO_EXCEPTION },
	TEST_c_c(catanh, -1.0L, ZERO_M, INF_M, ZERO_M, DIVIDE_BY_ZERO_EXCEPTION },
	TEST_c_c(catanh, ZERO_P, 1.0L, ZERO_P, M_PI_4l, 0 },
	TEST_c_c(catanh, ZERO_M, 1.0L, ZERO_M, M_PI_4l, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, ZERO_P, -1.0L, ZERO_P, -M_PI_4l, 0 },
	TEST_c_c(catanh, ZERO_M, -1.0L, ZERO_M, -M_PI_4l, 0|XFAIL_NATIVE_LINUX },

	TEST_c_c(catanh, INF_P, INF_P, 0.0, M_PI_2l, 0 },
	TEST_c_c(catanh, INF_P, INF_M, 0.0, -M_PI_2l, 0 },
	TEST_c_c(catanh, INF_M, INF_P, ZERO_M, M_PI_2l, 0 },
	TEST_c_c(catanh, INF_M, INF_M, ZERO_M, -M_PI_2l, 0 },

	TEST_c_c(catanh, -10.0, INF_P, ZERO_M, M_PI_2l, 0 },
	TEST_c_c(catanh, -10.0, INF_M, ZERO_M, -M_PI_2l, 0 },
	TEST_c_c(catanh, ZERO_M, INF_P, ZERO_M, M_PI_2l, 0 },
	TEST_c_c(catanh, ZERO_M, INF_M, ZERO_M, -M_PI_2l, 0 },
	TEST_c_c(catanh, 0, INF_P, 0.0, M_PI_2l, 0 },
	TEST_c_c(catanh, 0, INF_M, 0.0, -M_PI_2l, 0 },
	TEST_c_c(catanh, 0.1L, INF_P, 0.0, M_PI_2l, 0 },
	TEST_c_c(catanh, 0.1L, INF_M, 0.0, -M_PI_2l, 0 },

	TEST_c_c(catanh, INF_M, 0, ZERO_M, M_PI_2l, 0 },
	TEST_c_c(catanh, INF_M, ZERO_M, ZERO_M, -M_PI_2l, 0 },
	TEST_c_c(catanh, INF_M, 100, ZERO_M, M_PI_2l, 0 },
	TEST_c_c(catanh, INF_M, -100, ZERO_M, -M_PI_2l, 0 },

	TEST_c_c(catanh, INF_P, 0, 0.0, M_PI_2l, 0 },
	TEST_c_c(catanh, INF_P, ZERO_M, 0.0, -M_PI_2l, 0 },
	TEST_c_c(catanh, INF_P, 0.5, 0.0, M_PI_2l, 0 },
	TEST_c_c(catanh, INF_P, -0.5, 0.0, -M_PI_2l, 0 },

	TEST_c_c(catanh, 0, QNAN_P, 0.0, QNAN_P, 0 },
	TEST_c_c(catanh, ZERO_M, QNAN_P, ZERO_M, QNAN_P, 0 },

	TEST_c_c(catanh, INF_P, QNAN_P, 0.0, QNAN_P, 0 },
	TEST_c_c(catanh, INF_M, QNAN_P, ZERO_M, QNAN_P, 0 },

	TEST_c_c(catanh, QNAN_P, 0, QNAN_P, QNAN_P, 0 },
	TEST_c_c(catanh, QNAN_P, ZERO_M, QNAN_P, QNAN_P, 0 },

	TEST_c_c(catanh, QNAN_P, INF_P, 0.0, M_PI_2l, 0 },
	TEST_c_c(catanh, QNAN_P, INF_M, 0.0, -M_PI_2l, 0 },

	TEST_c_c(catanh, 10.5, QNAN_P, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	TEST_c_c(catanh, -10.5, QNAN_P, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },

	TEST_c_c(catanh, QNAN_P, 0.75, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	TEST_c_c(catanh, QNAN_P, -0.75, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },

	TEST_c_c(catanh, QNAN_P, QNAN_P, QNAN_P, QNAN_P, 0 },

	TEST_c_c(catanh, 0x1p50L, 0.0L, 8.881784197001252323389053344728897997441e-16L, 1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 0x1p50L, -0.0L, 8.881784197001252323389053344728897997441e-16L, -1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -0x1p50L, 0.0L, -8.881784197001252323389053344728897997441e-16L, 1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -0x1p50L, -0.0L, -8.881784197001252323389053344728897997441e-16L, -1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 0.0L, 0x1p50L, 0.0L, 1.570796326794895731052901991514519103193L, 0 },
	TEST_c_c(catanh, -0.0L, 0x1p50L, -0.0L, 1.570796326794895731052901991514519103193L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 0.0L, -0x1p50L, 0.0L, -1.570796326794895731052901991514519103193L, 0 },
	TEST_c_c(catanh, -0.0L, -0x1p50L, -0.0L, -1.570796326794895731052901991514519103193L, 0|XFAIL_NATIVE_LINUX },
#ifndef TEST_FLOAT
	TEST_c_c(catanh, 0x1p500L, 0.0L, 3.054936363499604682051979393213617699789e-151L, 1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 0x1p500L, -0.0L, 3.054936363499604682051979393213617699789e-151L, -1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -0x1p500L, 0.0L, -3.054936363499604682051979393213617699789e-151L, 1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -0x1p500L, -0.0L, -3.054936363499604682051979393213617699789e-151L, -1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 0.0L, 0x1p500L, 0.0L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(catanh, -0.0L, 0x1p500L, -0.0L, 1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 0.0L, -0x1p500L, 0.0L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(catanh, -0.0L, -0x1p500L, -0.0L, -1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
#endif
#if defined TEST_LDOUBLE && LDBL_MAX_EXP >= 16384
	TEST_c_c(catanh, 0x1p5000L, 0.0L, 7.079811261048172892385615158694057552948e-1506L, 1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, 0x1p5000L, -0.0L, 7.079811261048172892385615158694057552948e-1506L, -1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, -0x1p5000L, 0.0L, -7.079811261048172892385615158694057552948e-1506L, 1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, -0x1p5000L, -0.0L, -7.079811261048172892385615158694057552948e-1506L, -1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, 0.0L, 0x1p5000L, 0.0L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(catanh, -0.0L, 0x1p5000L, -0.0L, 1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, 0.0L, -0x1p5000L, 0.0L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(catanh, -0.0L, -0x1p5000L, -0.0L, -1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUXL },
#endif
	TEST_c_c(catanh, 0x1p63L, 0.5L, 1.084202172485504434007452800869941711427e-19L, 1.570796326794896619231321691639751442093L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 0x1p63L, -0.5L, 1.084202172485504434007452800869941711427e-19L, -1.570796326794896619231321691639751442093L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -0x1p63L, 0.5L, -1.084202172485504434007452800869941711427e-19L, 1.570796326794896619231321691639751442093L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -0x1p63L, -0.5L, -1.084202172485504434007452800869941711427e-19L, -1.570796326794896619231321691639751442093L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 0.5L, 0x1p63L, 5.877471754111437539843682686111228389007e-39L, 1.570796326794896619122901474391200998698L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -0.5L, 0x1p63L, -5.877471754111437539843682686111228389007e-39L, 1.570796326794896619122901474391200998698L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 0.5L, -0x1p63L, 5.877471754111437539843682686111228389007e-39L, -1.570796326794896619122901474391200998698L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -0.5L, -0x1p63L, -5.877471754111437539843682686111228389007e-39L, -1.570796326794896619122901474391200998698L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
#ifndef TEST_FLOAT
	TEST_c_c(catanh, 0x1p511L, 0.5L, 1.491668146240041348658193063092586767475e-154L, 1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 0x1p511L, -0.5L, 1.491668146240041348658193063092586767475e-154L, -1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -0x1p511L, 0.5L, -1.491668146240041348658193063092586767475e-154L, 1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -0x1p511L, -0.5L, -1.491668146240041348658193063092586767475e-154L, -1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 0.5L, 0x1p511L, 1.112536929253600691545116358666202032110e-308L, 1.570796326794896619231321691639751442099L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -0.5L, 0x1p511L, -1.112536929253600691545116358666202032110e-308L, 1.570796326794896619231321691639751442099L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 0.5L, -0x1p511L, 1.112536929253600691545116358666202032110e-308L, -1.570796326794896619231321691639751442099L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -0.5L, -0x1p511L, -1.112536929253600691545116358666202032110e-308L, -1.570796326794896619231321691639751442099L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
#endif
#if defined TEST_LDOUBLE && LDBL_MAX_EXP >= 16384
	TEST_c_c(catanh, 0x1p8191L, 0.5L, 1.833603867554847165621412392048483165956e-2466L, 1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, 0x1p8191L, -0.5L, 1.833603867554847165621412392048483165956e-2466L, -1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, -0x1p8191L, 0.5L, -1.833603867554847165621412392048483165956e-2466L, 1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, -0x1p8191L, -0.5L, -1.833603867554847165621412392048483165956e-2466L, -1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, 0.5L, 0x1p8191L, 1.681051571556046753131338908660876301299e-4932L, 1.570796326794896619231321691639751442099L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, -0.5L, 0x1p8191L, -1.681051571556046753131338908660876301299e-4932L, 1.570796326794896619231321691639751442099L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, 0.5L, -0x1p8191L, 1.681051571556046753131338908660876301299e-4932L, -1.570796326794896619231321691639751442099L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, -0.5L, -0x1p8191L, -1.681051571556046753131338908660876301299e-4932L, -1.570796326794896619231321691639751442099L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
#endif
	TEST_c_c(catanh, 0x1p100L, 0.0L, 7.888609052210118054117285652827862296732e-31L, 1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 0x1p100L, -0.0L, 7.888609052210118054117285652827862296732e-31L, -1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -0x1p100L, 0.0L, -7.888609052210118054117285652827862296732e-31L, 1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -0x1p100L, -0.0L, -7.888609052210118054117285652827862296732e-31L, -1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 0.0L, 0x1p100L, 0.0L, 1.570796326794896619231321691638962581193L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catanh, -0.0L, 0x1p100L, -0.0L, 1.570796326794896619231321691638962581193L, 0|XFAIL_NATIVE_LINUXF|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 0.0L, -0x1p100L, 0.0L, -1.570796326794896619231321691638962581193L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catanh, -0.0L, -0x1p100L, -0.0L, -1.570796326794896619231321691638962581193L, 0|XFAIL_NATIVE_LINUXF|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 0x1.fp127L, 0.0L, 3.033533808573645181854803967025150136306e-39L, 1.570796326794896619231321691639751442099L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 0x1.fp127L, -0.0L, 3.033533808573645181854803967025150136306e-39L, -1.570796326794896619231321691639751442099L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -0x1.fp127L, 0.0L, -3.033533808573645181854803967025150136306e-39L, 1.570796326794896619231321691639751442099L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -0x1.fp127L, -0.0L, -3.033533808573645181854803967025150136306e-39L, -1.570796326794896619231321691639751442099L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 0.0L, 0x1.fp127L, 0.0L, 1.570796326794896619231321691639751442096L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catanh, -0.0L, 0x1.fp127L, -0.0L, 1.570796326794896619231321691639751442096L, 0|XFAIL_NATIVE_LINUXF|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 0.0L, -0x1.fp127L, 0.0L, -1.570796326794896619231321691639751442096L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catanh, -0.0L, -0x1.fp127L, -0.0L, -1.570796326794896619231321691639751442096L, 0|XFAIL_NATIVE_LINUXF|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 0x1.fp127L, 0x1.fp127L, 1.516766904286822590927401983512575068153e-39L, 1.570796326794896619231321691639751442097L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 0x1.fp127L, -0x1.fp127L, 1.516766904286822590927401983512575068153e-39L, -1.570796326794896619231321691639751442097L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -0x1.fp127L, 0x1.fp127L, -1.516766904286822590927401983512575068153e-39L, 1.570796326794896619231321691639751442097L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -0x1.fp127L, -0x1.fp127L, -1.516766904286822590927401983512575068153e-39L, -1.570796326794896619231321691639751442097L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
#ifndef TEST_FLOAT
	TEST_c_c(catanh, 0x1p900L, 0.0L, 1.183052186166774710972751597518026531652e-271L, 1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 0x1p900L, -0.0L, 1.183052186166774710972751597518026531652e-271L, -1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -0x1p900L, 0.0L, -1.183052186166774710972751597518026531652e-271L, 1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -0x1p900L, -0.0L, -1.183052186166774710972751597518026531652e-271L, -1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 0.0L, 0x1p900L, 0.0L, 1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -0.0L, 0x1p900L, -0.0L, 1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 0.0L, -0x1p900L, 0.0L, -1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -0.0L, -0x1p900L, -0.0L, -1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 0x1.fp1023L, 0.0L, 5.742126086470197117652213464083623391533e-309L, 1.570796326794896619231321691639751442099L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 0x1.fp1023L, -0.0L, 5.742126086470197117652213464083623391533e-309L, -1.570796326794896619231321691639751442099L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -0x1.fp1023L, 0.0L, -5.742126086470197117652213464083623391533e-309L, 1.570796326794896619231321691639751442099L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -0x1.fp1023L, -0.0L, -5.742126086470197117652213464083623391533e-309L, -1.570796326794896619231321691639751442099L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 0.0L, 0x1.fp1023L, 0.0L, 1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -0.0L, 0x1.fp1023L, -0.0L, 1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 0.0L, -0x1.fp1023L, 0.0L, -1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -0.0L, -0x1.fp1023L, -0.0L, -1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 0x1.fp1023L, 0x1.fp1023L, 2.871063043235098558826106732041811695767e-309L, 1.570796326794896619231321691639751442099L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 0x1.fp1023L, -0x1.fp1023L, 2.871063043235098558826106732041811695767e-309L, -1.570796326794896619231321691639751442099L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -0x1.fp1023L, 0x1.fp1023L, -2.871063043235098558826106732041811695767e-309L, 1.570796326794896619231321691639751442099L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -0x1.fp1023L, -0x1.fp1023L, -2.871063043235098558826106732041811695767e-309L, -1.570796326794896619231321691639751442099L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
#endif
#if defined TEST_LDOUBLE && LDBL_MAX_EXP >= 16384
	TEST_c_c(catanh, 0x1p10000L, 0.0L, 5.012372749206452009297555933742977749322e-3011L, 1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, 0x1p10000L, -0.0L, 5.012372749206452009297555933742977749322e-3011L, -1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, -0x1p10000L, 0.0L, -5.012372749206452009297555933742977749322e-3011L, 1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, -0x1p10000L, -0.0L, -5.012372749206452009297555933742977749322e-3011L, -1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, 0.0L, 0x1p10000L, 0.0L, 1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, -0.0L, 0x1p10000L, -0.0L, 1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, 0.0L, -0x1p10000L, 0.0L, -1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, -0.0L, -0x1p10000L, -0.0L, -1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, 0x1.fp16383L, 0.0L, 8.676395208031209048419813722120651877672e-4933L, 1.570796326794896619231321691639751442099L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, 0x1.fp16383L, -0.0L, 8.676395208031209048419813722120651877672e-4933L, -1.570796326794896619231321691639751442099L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, -0x1.fp16383L, 0.0L, -8.676395208031209048419813722120651877672e-4933L, 1.570796326794896619231321691639751442099L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, -0x1.fp16383L, -0.0L, -8.676395208031209048419813722120651877672e-4933L, -1.570796326794896619231321691639751442099L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, 0.0L, 0x1.fp16383L, 0.0L, 1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, -0.0L, 0x1.fp16383L, -0.0L, 1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, 0.0L, -0x1.fp16383L, 0.0L, -1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, -0.0L, -0x1.fp16383L, -0.0L, -1.570796326794896619231321691639751442099L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, 0x1.fp16383L, 0x1.fp16383L, 4.338197604015604524209906861060325938836e-4933L, 1.570796326794896619231321691639751442099L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, 0x1.fp16383L, -0x1.fp16383L, 4.338197604015604524209906861060325938836e-4933L, -1.570796326794896619231321691639751442099L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, -0x1.fp16383L, 0x1.fp16383L, -4.338197604015604524209906861060325938836e-4933L, 1.570796326794896619231321691639751442099L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, -0x1.fp16383L, -0x1.fp16383L, -4.338197604015604524209906861060325938836e-4933L, -1.570796326794896619231321691639751442099L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
#endif
	TEST_c_c(catanh, 0x1p-13L, 1.0L, 6.103515609841754902688560615027452023669e-5L, 7.853981671227386080775748393881580082970e-1L, 0 },
	TEST_c_c(catanh, 0x1p-13L, -1.0L, 6.103515609841754902688560615027452023669e-5L, -7.853981671227386080775748393881580082970e-1L, 0 },
	TEST_c_c(catanh, -0x1p-13L, 1.0L, -6.103515609841754902688560615027452023669e-5L, 7.853981671227386080775748393881580082970e-1L, 0 },
	TEST_c_c(catanh, -0x1p-13L, -1.0L, -6.103515609841754902688560615027452023669e-5L, -7.853981671227386080775748393881580082970e-1L, 0 },
	TEST_c_c(catanh, 1.0L, 0x1p-13L, 4.852030264850939738801379894163661227127L, 7.854286809755354140031716771044626356262e-1L, 0 },
	TEST_c_c(catanh, -1.0L, 0x1p-13L, -4.852030264850939738801379894163661227127L, 7.854286809755354140031716771044626356262e-1L, 0 },
	TEST_c_c(catanh, 1.0L, -0x1p-13L, 4.852030264850939738801379894163661227127L, -7.854286809755354140031716771044626356262e-1L, 0 },
	TEST_c_c(catanh, -1.0L, -0x1p-13L, -4.852030264850939738801379894163661227127L, -7.854286809755354140031716771044626356262e-1L, 0 },
	TEST_c_c(catanh, 0x1p-27L, 1.0L, 3.725290298461914028034141143623846306386e-9L, 7.853981633974483234934486536343324763447e-1L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catanh, 0x1p-27L, -1.0L, 3.725290298461914028034141143623846306386e-9L, -7.853981633974483234934486536343324763447e-1L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catanh, -0x1p-27L, 1.0L, -3.725290298461914028034141143623846306386e-9L, 7.853981633974483234934486536343324763447e-1L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catanh, -0x1p-27L, -1.0L, -3.725290298461914028034141143623846306386e-9L, -7.853981633974483234934486536343324763447e-1L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catanh, 1.0L, 0x1p-27L, 9.704060527839234335310696652368086117807L, 7.853981652600934588466178684534110069553e-1L, 0 },
	TEST_c_c(catanh, -1.0L, 0x1p-27L, -9.704060527839234335310696652368086117807L, 7.853981652600934588466178684534110069553e-1L, 0 },
	TEST_c_c(catanh, 1.0L, -0x1p-27L, 9.704060527839234335310696652368086117807L, -7.853981652600934588466178684534110069553e-1L, 0 },
	TEST_c_c(catanh, -1.0L, -0x1p-27L, -9.704060527839234335310696652368086117807L, -7.853981652600934588466178684534110069553e-1L, 0 },
	TEST_c_c(catanh, 0x1p-33L, 1.0L, 5.820766091346740722643102318246316469910e-11L, 7.853981633974483096190489776088929224056e-1L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catanh, 0x1p-33L, -1.0L, 5.820766091346740722643102318246316469910e-11L, -7.853981633974483096190489776088929224056e-1L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catanh, -0x1p-33L, 1.0L, -5.820766091346740722643102318246316469910e-11L, 7.853981633974483096190489776088929224056e-1L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catanh, -0x1p-33L, -1.0L, -5.820766091346740722643102318246316469910e-11L, -7.853981633974483096190489776088929224056e-1L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catanh, 1.0L, 0x1p-33L, 1.178350206951907026009379309773625595762e1L, 7.853981634265521400723945494331241018449e-1L, 0 },
	TEST_c_c(catanh, -1.0L, 0x1p-33L, -1.178350206951907026009379309773625595762e1L, 7.853981634265521400723945494331241018449e-1L, 0 },
	TEST_c_c(catanh, 1.0L, -0x1p-33L, 1.178350206951907026009379309773625595762e1L, -7.853981634265521400723945494331241018449e-1L, 0 },
	TEST_c_c(catanh, -1.0L, -0x1p-33L, -1.178350206951907026009379309773625595762e1L, -7.853981634265521400723945494331241018449e-1L, 0 },
	TEST_c_c(catanh, 0x1p-54L, 1.0L, 2.775557561562891351059079170227049355775e-17L, 7.853981633974483096156608458198764914213e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 0x1p-54L, -1.0L, 2.775557561562891351059079170227049355775e-17L, -7.853981633974483096156608458198764914213e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -0x1p-54L, 1.0L, -2.775557561562891351059079170227049355775e-17L, 7.853981633974483096156608458198764914213e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -0x1p-54L, -1.0L, -2.775557561562891351059079170227049355775e-17L, -7.853981633974483096156608458198764914213e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 1.0L, 0x1p-54L, 1.906154746539849600897388334009985581467e1L, 7.853981633974483234934486536343324763447e-1L, 0 },
	TEST_c_c(catanh, -1.0L, 0x1p-54L, -1.906154746539849600897388334009985581467e1L, 7.853981633974483234934486536343324763447e-1L, 0 },
	TEST_c_c(catanh, 1.0L, -0x1p-54L, 1.906154746539849600897388334009985581467e1L, -7.853981633974483234934486536343324763447e-1L, 0 },
	TEST_c_c(catanh, -1.0L, -0x1p-54L, -1.906154746539849600897388334009985581467e1L, -7.853981633974483234934486536343324763447e-1L, 0 },
	TEST_c_c(catanh, 0x1p-57L, 1.0L, 3.469446951953614188823848962783813448721e-18L, 7.853981633974483096156608458198757330864e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 0x1p-57L, -1.0L, 3.469446951953614188823848962783813448721e-18L, -7.853981633974483096156608458198757330864e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -0x1p-57L, 1.0L, -3.469446951953614188823848962783813448721e-18L, 7.853981633974483096156608458198757330864e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -0x1p-57L, -1.0L, -3.469446951953614188823848962783813448721e-18L, -7.853981633974483096156608458198757330864e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 1.0L, 0x1p-57L, 2.010126823623841397309973152228712047720e1L, 7.853981633974483113503843217966828154612e-1L, 0 },
	TEST_c_c(catanh, -1.0L, 0x1p-57L, -2.010126823623841397309973152228712047720e1L, 7.853981633974483113503843217966828154612e-1L, 0 },
	TEST_c_c(catanh, 1.0L, -0x1p-57L, 2.010126823623841397309973152228712047720e1L, -7.853981633974483113503843217966828154612e-1L, 0 },
	TEST_c_c(catanh, -1.0L, -0x1p-57L, -2.010126823623841397309973152228712047720e1L, -7.853981633974483113503843217966828154612e-1L, 0 },
	TEST_c_c(catanh, 0x1p-13L, 0x1.000002p0L, 6.103514882246036852433556327261700380577e-5L, 7.853982267273793866654490522673596014524e-1L, 0 },
	TEST_c_c(catanh, 0x1p-13L, -0x1.000002p0L, 6.103514882246036852433556327261700380577e-5L, -7.853982267273793866654490522673596014524e-1L, 0 },
	TEST_c_c(catanh, -0x1p-13L, 0x1.000002p0L, -6.103514882246036852433556327261700380577e-5L, 7.853982267273793866654490522673596014524e-1L, 0 },
	TEST_c_c(catanh, -0x1p-13L, -0x1.000002p0L, -6.103514882246036852433556327261700380577e-5L, -7.853982267273793866654490522673596014524e-1L, 0 },
	TEST_c_c(catanh, 0x1.000002p0L, 0x1p-13L, 4.852030056234795712498957387213592193975L, 7.859169620684960844300240092596908675974e-1L, 0 },
	TEST_c_c(catanh, -0x1.000002p0L, 0x1p-13L, -4.852030056234795712498957387213592193975L, 7.859169620684960844300240092596908675974e-1L, 0 },
	TEST_c_c(catanh, 0x1.000002p0L, -0x1p-13L, 4.852030056234795712498957387213592193975L, -7.859169620684960844300240092596908675974e-1L, 0 },
	TEST_c_c(catanh, -0x1.000002p0L, -0x1p-13L, -4.852030056234795712498957387213592193975L, -7.859169620684960844300240092596908675974e-1L, 0 },
	TEST_c_c(catanh, 0x1p-13L, 0x0.ffffffp0L, 6.103515973639646453881721999956617260502e-5L, 7.853981373204155542484315721351697277336e-1L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catanh, 0x1p-13L, -0x0.ffffffp0L, 6.103515973639646453881721999956617260502e-5L, -7.853981373204155542484315721351697277336e-1L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catanh, -0x1p-13L, 0x0.ffffffp0L, -6.103515973639646453881721999956617260502e-5L, 7.853981373204155542484315721351697277336e-1L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catanh, -0x1p-13L, -0x0.ffffffp0L, -6.103515973639646453881721999956617260502e-5L, -7.853981373204155542484315721351697277336e-1L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catanh, 0x0.ffffffp0L, 0x1p-13L, 4.852030190345140708455871037447717761868L, 7.851845403708474595909269086711426246675e-1L, 0 },
	TEST_c_c(catanh, -0x0.ffffffp0L, 0x1p-13L, -4.852030190345140708455871037447717761868L, 7.851845403708474595909269086711426246675e-1L, 0 },
	TEST_c_c(catanh, 0x0.ffffffp0L, -0x1p-13L, 4.852030190345140708455871037447717761868L, -7.851845403708474595909269086711426246675e-1L, 0 },
	TEST_c_c(catanh, -0x0.ffffffp0L, -0x1p-13L, -4.852030190345140708455871037447717761868L, -7.851845403708474595909269086711426246675e-1L, 0 },
#ifndef TEST_FLOAT
	TEST_c_c(catanh, 0x1p-27L, 0x1.0000000000001p0L, 3.725290298461913200853528590596263270474e-9L, 7.853981633974484345157511161499711112683e-1L, 0 },
	TEST_c_c(catanh, 0x1p-27L, -0x1.0000000000001p0L, 3.725290298461913200853528590596263270474e-9L, -7.853981633974484345157511161499711112683e-1L, 0 },
	TEST_c_c(catanh, -0x1p-27L, 0x1.0000000000001p0L, -3.725290298461913200853528590596263270474e-9L, 7.853981633974484345157511161499711112683e-1L, 0 },
	TEST_c_c(catanh, -0x1p-27L, -0x1.0000000000001p0L, -3.725290298461913200853528590596263270474e-9L, -7.853981633974484345157511161499711112683e-1L, 0 },
	TEST_c_c(catanh, 0x1.0000000000001p0L, 0x1p-27L, 9.704060527839234168777242958594699810015L, 7.853981801612546526942695000283242525531e-1L, 0 },
	TEST_c_c(catanh, -0x1.0000000000001p0L, 0x1p-27L, -9.704060527839234168777242958594699810015L, 7.853981801612546526942695000283242525531e-1L, 0 },
	TEST_c_c(catanh, 0x1.0000000000001p0L, -0x1p-27L, 9.704060527839234168777242958594699810015L, -7.853981801612546526942695000283242525531e-1L, 0 },
	TEST_c_c(catanh, -0x1.0000000000001p0L, -0x1p-27L, -9.704060527839234168777242958594699810015L, -7.853981801612546526942695000283242525531e-1L, 0 },
	TEST_c_c(catanh, 0x1p-27L, 0x0.fffffffffffff8p0L, 3.725290298461914441624447420137706700965e-9L, 7.853981633974482679822974223765039144191e-1L, 0 },
	TEST_c_c(catanh, 0x1p-27L, -0x0.fffffffffffff8p0L, 3.725290298461914441624447420137706700965e-9L, -7.853981633974482679822974223765039144191e-1L, 0 },
	TEST_c_c(catanh, -0x1p-27L, 0x0.fffffffffffff8p0L, -3.725290298461914441624447420137706700965e-9L, 7.853981633974482679822974223765039144191e-1L, 0 },
	TEST_c_c(catanh, -0x1p-27L, -0x0.fffffffffffff8p0L, -3.725290298461914441624447420137706700965e-9L, -7.853981633974482679822974223765039144191e-1L, 0 },
	TEST_c_c(catanh, 0x0.fffffffffffff8p0L, 0x1p-27L, 9.704060527839234252043969805481351363824L, 7.853981578095128619227903983047292781021e-1L, 0 },
	TEST_c_c(catanh, -0x0.fffffffffffff8p0L, 0x1p-27L, -9.704060527839234252043969805481351363824L, 7.853981578095128619227903983047292781021e-1L, 0 },
	TEST_c_c(catanh, 0x0.fffffffffffff8p0L, -0x1p-27L, 9.704060527839234252043969805481351363824L, -7.853981578095128619227903983047292781021e-1L, 0 },
	TEST_c_c(catanh, -0x0.fffffffffffff8p0L, -0x1p-27L, -9.704060527839234252043969805481351363824L, -7.853981578095128619227903983047292781021e-1L, 0 },
#endif
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	TEST_c_c(catanh, 0x1p-33L, 0x1.0000000000000002p0L, 5.820766091346740722012013594069507025615e-11L, 7.853981633974483096732590862331681441026e-1L, 0 },
	TEST_c_c(catanh, 0x1p-33L, -0x1.0000000000000002p0L, 5.820766091346740722012013594069507025615e-11L, -7.853981633974483096732590862331681441026e-1L, 0 },
	TEST_c_c(catanh, -0x1p-33L, 0x1.0000000000000002p0L, -5.820766091346740722012013594069507025615e-11L, 7.853981633974483096732590862331681441026e-1L, 0 },
	TEST_c_c(catanh, -0x1p-33L, -0x1.0000000000000002p0L, -5.820766091346740722012013594069507025615e-11L, -7.853981633974483096732590862331681441026e-1L, 0 },
	TEST_c_c(catanh, 0x1.0000000000000002p0L, 0x1p-33L, 1.178350206951907025990405771755129268176e1L, 7.853981638922134273801338071094141188767e-1L, 0 },
	TEST_c_c(catanh, -0x1.0000000000000002p0L, 0x1p-33L, -1.178350206951907025990405771755129268176e1L, 7.853981638922134273801338071094141188767e-1L, 0 },
	TEST_c_c(catanh, 0x1.0000000000000002p0L, -0x1p-33L, 1.178350206951907025990405771755129268176e1L, -7.853981638922134273801338071094141188767e-1L, 0 },
	TEST_c_c(catanh, -0x1.0000000000000002p0L, -0x1p-33L, -1.178350206951907025990405771755129268176e1L, -7.853981638922134273801338071094141188767e-1L, 0 },
	TEST_c_c(catanh, 0x1p-33L, 0x0.ffffffffffffffffp0L, 5.820766091346740722958646680334721192083e-11L, 7.853981633974483095919439232967553115548e-1L, 0 },
	TEST_c_c(catanh, 0x1p-33L, -0x0.ffffffffffffffffp0L, 5.820766091346740722958646680334721192083e-11L, -7.853981633974483095919439232967553115548e-1L, 0 },
	TEST_c_c(catanh, -0x1p-33L, 0x0.ffffffffffffffffp0L, -5.820766091346740722958646680334721192083e-11L, 7.853981633974483095919439232967553115548e-1L, 0 },
	TEST_c_c(catanh, -0x1p-33L, -0x0.ffffffffffffffffp0L, -5.820766091346740722958646680334721192083e-11L, -7.853981633974483095919439232967553115548e-1L, 0 },
	TEST_c_c(catanh, 0x0.ffffffffffffffffp0L, 0x1p-33L, 1.178350206951907026002603046195591193050e1L, 7.853981631937214964185249205444919953948e-1L, 0 },
	TEST_c_c(catanh, -0x0.ffffffffffffffffp0L, 0x1p-33L, -1.178350206951907026002603046195591193050e1L, 7.853981631937214964185249205444919953948e-1L, 0 },
	TEST_c_c(catanh, 0x0.ffffffffffffffffp0L, -0x1p-33L, 1.178350206951907026002603046195591193050e1L, -7.853981631937214964185249205444919953948e-1L, 0 },
	TEST_c_c(catanh, -0x0.ffffffffffffffffp0L, -0x1p-33L, -1.178350206951907026002603046195591193050e1L, -7.853981631937214964185249205444919953948e-1L, 0 },
#endif
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 106
	TEST_c_c(catanh, 0x1p-54L, 0x1.000000000000000000000000008p0L, 2.775557561562891351059079170226980932999e-17L, 7.853981633974483096156608458198888173729e-1L, 0 },
	TEST_c_c(catanh, 0x1p-54L, -0x1.000000000000000000000000008p0L, 2.775557561562891351059079170226980932999e-17L, -7.853981633974483096156608458198888173729e-1L, 0 },
	TEST_c_c(catanh, -0x1p-54L, 0x1.000000000000000000000000008p0L, -2.775557561562891351059079170226980932999e-17L, 7.853981633974483096156608458198888173729e-1L, 0 },
	TEST_c_c(catanh, -0x1p-54L, -0x1.000000000000000000000000008p0L, -2.775557561562891351059079170226980932999e-17L, -7.853981633974483096156608458198888173729e-1L, 0 },
	TEST_c_c(catanh, 0x1.000000000000000000000000008p0L, 0x1p-54L, 1.906154746539849600897388334009981267384e1L, 7.853981633974485455380535786656405610710e-1L, 0 },
	TEST_c_c(catanh, -0x1.000000000000000000000000008p0L, 0x1p-54L, -1.906154746539849600897388334009981267384e1L, 7.853981633974485455380535786656405610710e-1L, 0 },
	TEST_c_c(catanh, 0x1.000000000000000000000000008p0L, -0x1p-54L, 1.906154746539849600897388334009981267384e1L, -7.853981633974485455380535786656405610710e-1L, 0 },
	TEST_c_c(catanh, -0x1.000000000000000000000000008p0L, -0x1p-54L, -1.906154746539849600897388334009981267384e1L, -7.853981633974485455380535786656405610710e-1L, 0 },
	TEST_c_c(catanh, 0x1p-54L, 0x0.ffffffffffffffffffffffffffcp0L, 2.775557561562891351059079170227083567164e-17L, 7.853981633974483096156608458198703284454e-1L, 0 },
	TEST_c_c(catanh, 0x1p-54L, -0x0.ffffffffffffffffffffffffffcp0L, 2.775557561562891351059079170227083567164e-17L, -7.853981633974483096156608458198703284454e-1L, 0 },
	TEST_c_c(catanh, -0x1p-54L, 0x0.ffffffffffffffffffffffffffcp0L, -2.775557561562891351059079170227083567164e-17L, 7.853981633974483096156608458198703284454e-1L, 0 },
	TEST_c_c(catanh, -0x1p-54L, -0x0.ffffffffffffffffffffffffffcp0L, -2.775557561562891351059079170227083567164e-17L, -7.853981633974483096156608458198703284454e-1L, 0 },
	TEST_c_c(catanh, 0x0.ffffffffffffffffffffffffffcp0L, 0x1p-54L, 1.906154746539849600897388334009984040723e1L, 7.853981633974482124711461911186784339815e-1L, 0 },
	TEST_c_c(catanh, -0x0.ffffffffffffffffffffffffffcp0L, 0x1p-54L, -1.906154746539849600897388334009984040723e1L, 7.853981633974482124711461911186784339815e-1L, 0 },
	TEST_c_c(catanh, 0x0.ffffffffffffffffffffffffffcp0L, -0x1p-54L, 1.906154746539849600897388334009984040723e1L, -7.853981633974482124711461911186784339815e-1L, 0 },
	TEST_c_c(catanh, -0x0.ffffffffffffffffffffffffffcp0L, -0x1p-54L, -1.906154746539849600897388334009984040723e1L, -7.853981633974482124711461911186784339815e-1L, 0 },
#endif
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 113
	TEST_c_c(catanh, 0x1p-57L, 0x1.0000000000000000000000000001p0L, 3.469446951953614188823848962783812780530e-18L, 7.853981633974483096156608458198758293829e-1L, 0 },
	TEST_c_c(catanh, 0x1p-57L, -0x1.0000000000000000000000000001p0L, 3.469446951953614188823848962783812780530e-18L, -7.853981633974483096156608458198758293829e-1L, 0 },
	TEST_c_c(catanh, -0x1p-57L, 0x1.0000000000000000000000000001p0L, -3.469446951953614188823848962783812780530e-18L, 7.853981633974483096156608458198758293829e-1L, 0 },
	TEST_c_c(catanh, -0x1p-57L, -0x1.0000000000000000000000000001p0L, -3.469446951953614188823848962783812780530e-18L, -7.853981633974483096156608458198758293829e-1L, 0 },
	TEST_c_c(catanh, 0x1.0000000000000000000000000001p0L, 0x1p-57L, 2.010126823623841397309973152228712033275e1L, 7.853981633974483252281721296111395707566e-1L, 0 },
	TEST_c_c(catanh, -0x1.0000000000000000000000000001p0L, 0x1p-57L, -2.010126823623841397309973152228712033275e1L, 7.853981633974483252281721296111395707566e-1L, 0 },
	TEST_c_c(catanh, 0x1.0000000000000000000000000001p0L, -0x1p-57L, 2.010126823623841397309973152228712033275e1L, -7.853981633974483252281721296111395707566e-1L, 0 },
	TEST_c_c(catanh, -0x1.0000000000000000000000000001p0L, -0x1p-57L, -2.010126823623841397309973152228712033275e1L, -7.853981633974483252281721296111395707566e-1L, 0 },
	TEST_c_c(catanh, 0x1p-57L, 0x0.ffffffffffffffffffffffffffff8p0L, 3.469446951953614188823848962783813782817e-18L, 7.853981633974483096156608458198756849381e-1L, 0 },
	TEST_c_c(catanh, 0x1p-57L, -0x0.ffffffffffffffffffffffffffff8p0L, 3.469446951953614188823848962783813782817e-18L, -7.853981633974483096156608458198756849381e-1L, 0 },
	TEST_c_c(catanh, -0x1p-57L, 0x0.ffffffffffffffffffffffffffff8p0L, -3.469446951953614188823848962783813782817e-18L, 7.853981633974483096156608458198756849381e-1L, 0 },
	TEST_c_c(catanh, -0x1p-57L, -0x0.ffffffffffffffffffffffffffff8p0L, -3.469446951953614188823848962783813782817e-18L, -7.853981633974483096156608458198756849381e-1L, 0 },
	TEST_c_c(catanh, 0x0.ffffffffffffffffffffffffffff8p0L, 0x1p-57L, 2.010126823623841397309973152228712040498e1L, 7.853981633974483044114904178894544378135e-1L, 0 },
	TEST_c_c(catanh, -0x0.ffffffffffffffffffffffffffff8p0L, 0x1p-57L, -2.010126823623841397309973152228712040498e1L, 7.853981633974483044114904178894544378135e-1L, 0 },
	TEST_c_c(catanh, 0x0.ffffffffffffffffffffffffffff8p0L, -0x1p-57L, 2.010126823623841397309973152228712040498e1L, -7.853981633974483044114904178894544378135e-1L, 0 },
	TEST_c_c(catanh, -0x0.ffffffffffffffffffffffffffff8p0L, -0x1p-57L, -2.010126823623841397309973152228712040498e1L, -7.853981633974483044114904178894544378135e-1L, 0 },
#endif
	TEST_c_c(catanh, 1.0L, 0x1p-64L, 2.252728336819822255606004394739073846245e1L, 7.853981633974483096292133729759445264744e-1L, 0 },
	TEST_c_c(catanh, 1.0L, -0x1p-64L, 2.252728336819822255606004394739073846245e1L, -7.853981633974483096292133729759445264744e-1L, 0 },
	TEST_c_c(catanh, -1.0L, 0x1p-64L, -2.252728336819822255606004394739073846245e1L, 7.853981633974483096292133729759445264744e-1L, 0 },
	TEST_c_c(catanh, -1.0L, -0x1p-64L, -2.252728336819822255606004394739073846245e1L, -7.853981633974483096292133729759445264744e-1L, 0 },
	TEST_c_c(catanh, 0x1p-64L, 1.0L, 2.710505431213761085018632002174854278563e-20L, 7.853981633974483096156608458198757210500e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -0x1p-64L, 1.0L, -2.710505431213761085018632002174854278563e-20L, 7.853981633974483096156608458198757210500e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 0x1p-64L, -1.0L, 2.710505431213761085018632002174854278563e-20L, -7.853981633974483096156608458198757210500e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -0x1p-64L, -1.0L, -2.710505431213761085018632002174854278563e-20L, -7.853981633974483096156608458198757210500e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 1.0L, 0x1.3p-73L, 2.556052055225464683726753902092495938633e1L, 7.853981633974483096156922786831527361009e-1L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catanh, 1.0L, -0x1.3p-73L, 2.556052055225464683726753902092495938633e1L, -7.853981633974483096156922786831527361009e-1L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catanh, -1.0L, 0x1.3p-73L, -2.556052055225464683726753902092495938633e1L, 7.853981633974483096156922786831527361009e-1L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catanh, -1.0L, -0x1.3p-73L, -2.556052055225464683726753902092495938633e1L, -7.853981633974483096156922786831527361009e-1L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catanh, 0x1.3p-73L, 1.0L, 6.286572655403010329022706059731717687100e-23L, 7.853981633974483096156608458198757210493e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -0x1.3p-73L, 1.0L, -6.286572655403010329022706059731717687100e-23L, 7.853981633974483096156608458198757210493e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 0x1.3p-73L, -1.0L, 6.286572655403010329022706059731717687100e-23L, -7.853981633974483096156608458198757210493e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -0x1.3p-73L, -1.0L, -6.286572655403010329022706059731717687100e-23L, -7.853981633974483096156608458198757210493e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 1.0L, 0x1p-124L, 4.332169878499658183857700759113603550472e1L, 7.853981633974483096156608458198757210610e-1L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catanh, 1.0L, -0x1p-124L, 4.332169878499658183857700759113603550472e1L, -7.853981633974483096156608458198757210610e-1L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catanh, -1.0L, 0x1p-124L, -4.332169878499658183857700759113603550472e1L, 7.853981633974483096156608458198757210610e-1L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catanh, -1.0L, -0x1p-124L, -4.332169878499658183857700759113603550472e1L, -7.853981633974483096156608458198757210610e-1L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(catanh, 0x1p-124L, 1.0L, 2.350988701644575015937473074444491355637e-38L, 7.853981633974483096156608458198757210493e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -0x1p-124L, 1.0L, -2.350988701644575015937473074444491355637e-38L, 7.853981633974483096156608458198757210493e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 0x1p-124L, -1.0L, 2.350988701644575015937473074444491355637e-38L, -7.853981633974483096156608458198757210493e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -0x1p-124L, -1.0L, -2.350988701644575015937473074444491355637e-38L, -7.853981633974483096156608458198757210493e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 0x1.000002p0L, 0x1p-126L, 8.317766196521665212523713550410777685446L, 1.570796326794896619231321691639702138295L, 0 },
	TEST_c_c(catanh, 0x1.000002p0L, -0x1p-126L, 8.317766196521665212523713550410777685446L, -1.570796326794896619231321691639702138295L, 0 },
	TEST_c_c(catanh, -0x1.000002p0L, 0x1p-126L, -8.317766196521665212523713550410777685446L, 1.570796326794896619231321691639702138295L, 0 },
	TEST_c_c(catanh, -0x1.000002p0L, -0x1p-126L, -8.317766196521665212523713550410777685446L, -1.570796326794896619231321691639702138295L, 0 },
	TEST_c_c(catanh, 0x1p-126L, 0x1.000002p0L, 5.877471053462247139383742414506671233336e-39L, 7.853982230020895322927482174768220815493e-1L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -0x1p-126L, 0x1.000002p0L, -5.877471053462247139383742414506671233336e-39L, 7.853982230020895322927482174768220815493e-1L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 0x1p-126L, -0x1.000002p0L, 5.877471053462247139383742414506671233336e-39L, -7.853982230020895322927482174768220815493e-1L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -0x1p-126L, -0x1.000002p0L, -5.877471053462247139383742414506671233336e-39L, -7.853982230020895322927482174768220815493e-1L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 0x0.ffffffp0L, 0x1p-126L, 8.664339742098154951823135931565866792454L, 9.860761609136244031334147100512154160097e-32L, 0 },
	TEST_c_c(catanh, 0x0.ffffffp0L, -0x1p-126L, 8.664339742098154951823135931565866792454L, -9.860761609136244031334147100512154160097e-32L, 0 },
	TEST_c_c(catanh, -0x0.ffffffp0L, 0x1p-126L, -8.664339742098154951823135931565866792454L, 9.860761609136244031334147100512154160097e-32L, 0 },
	TEST_c_c(catanh, -0x0.ffffffp0L, -0x1p-126L, -8.664339742098154951823135931565866792454L, -9.860761609136244031334147100512154160097e-32L, 0 },
	TEST_c_c(catanh, 0x1p-126L, 0x0.ffffffp0L, 5.877472104436064061535099214664320916184e-39L, 7.853981335951250337419109991749089175724e-1L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -0x1p-126L, 0x0.ffffffp0L, -5.877472104436064061535099214664320916184e-39L, 7.853981335951250337419109991749089175724e-1L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 0x1p-126L, -0x0.ffffffp0L, 5.877472104436064061535099214664320916184e-39L, -7.853981335951250337419109991749089175724e-1L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -0x1p-126L, -0x0.ffffffp0L, -5.877472104436064061535099214664320916184e-39L, -7.853981335951250337419109991749089175724e-1L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
#ifndef TEST_FLOAT
	TEST_c_c(catanh, 1.0L, 0x1p-512L, 1.777922518136259718655200391540222897114e2L, 7.853981633974483096156608458198757210493e-1L, 0 },
	TEST_c_c(catanh, 1.0L, -0x1p-512L, 1.777922518136259718655200391540222897114e2L, -7.853981633974483096156608458198757210493e-1L, 0 },
	TEST_c_c(catanh, -1.0L, 0x1p-512L, -1.777922518136259718655200391540222897114e2L, 7.853981633974483096156608458198757210493e-1L, 0 },
	TEST_c_c(catanh, -1.0L, -0x1p-512L, -1.777922518136259718655200391540222897114e2L, -7.853981633974483096156608458198757210493e-1L, 0 },
	TEST_c_c(catanh, 0x1p-512L, 1.0L, 3.729170365600103371645482657731466918688e-155L, 7.853981633974483096156608458198757210493e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -0x1p-512L, 1.0L, -3.729170365600103371645482657731466918688e-155L, 7.853981633974483096156608458198757210493e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 0x1p-512L, -1.0L, 3.729170365600103371645482657731466918688e-155L, -7.853981633974483096156608458198757210493e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -0x1p-512L, -1.0L, -3.729170365600103371645482657731466918688e-155L, -7.853981633974483096156608458198757210493e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 1.0L, 0x1.3p-536L, 1.860240928518819859673567751384928348958e2L, 7.853981633974483096156608458198757210493e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 1.0L, -0x1.3p-536L, 1.860240928518819859673567751384928348958e2L, -7.853981633974483096156608458198757210493e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -1.0L, 0x1.3p-536L, -1.860240928518819859673567751384928348958e2L, 7.853981633974483096156608458198757210493e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -1.0L, -0x1.3p-536L, -1.860240928518819859673567751384928348958e2L, -7.853981633974483096156608458198757210493e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 0x1.3p-536L, 1.0L, 2.639526015013529511588222179446290115084e-162L, 7.853981633974483096156608458198757210493e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -0x1.3p-536L, 1.0L, -2.639526015013529511588222179446290115084e-162L, 7.853981633974483096156608458198757210493e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 0x1.3p-536L, -1.0L, 2.639526015013529511588222179446290115084e-162L, -7.853981633974483096156608458198757210493e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -0x1.3p-536L, -1.0L, -2.639526015013529511588222179446290115084e-162L, -7.853981633974483096156608458198757210493e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 1.0L, 0x1p-1020L, 3.538516356758520804574969980043991380025e2L, 7.853981633974483096156608458198757210493e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 1.0L, -0x1p-1020L, 3.538516356758520804574969980043991380025e2L, -7.853981633974483096156608458198757210493e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -1.0L, 0x1p-1020L, -3.538516356758520804574969980043991380025e2L, 7.853981633974483096156608458198757210493e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -1.0L, -0x1p-1020L, -3.538516356758520804574969980043991380025e2L, -7.853981633974483096156608458198757210493e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 0x1p-1020L, 1.0L, 4.450147717014402766180465434664808128438e-308L, 7.853981633974483096156608458198757210493e-1L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -0x1p-1020L, 1.0L, -4.450147717014402766180465434664808128438e-308L, 7.853981633974483096156608458198757210493e-1L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 0x1p-1020L, -1.0L, 4.450147717014402766180465434664808128438e-308L, -7.853981633974483096156608458198757210493e-1L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -0x1p-1020L, -1.0L, -4.450147717014402766180465434664808128438e-308L, -7.853981633974483096156608458198757210493e-1L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 0x1.0000000000001p0L, 0x1p-1022L, 1.836840028483855075506780244989950299369e1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(catanh, 0x1.0000000000001p0L, -0x1p-1022L, 1.836840028483855075506780244989950299369e1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(catanh, -0x1.0000000000001p0L, 0x1p-1022L, -1.836840028483855075506780244989950299369e1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(catanh, -0x1.0000000000001p0L, -0x1p-1022L, -1.836840028483855075506780244989950299369e1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(catanh, 0x1p-1022L, 0x1.0000000000001p0L, 1.112536929253600444512293438042957369978e-308L, 7.853981633974484206379633083355174374608e-1L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -0x1p-1022L, 0x1.0000000000001p0L, -1.112536929253600444512293438042957369978e-308L, 7.853981633974484206379633083355174374608e-1L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 0x1p-1022L, -0x1.0000000000001p0L, 1.112536929253600444512293438042957369978e-308L, -7.853981633974484206379633083355174374608e-1L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -0x1p-1022L, -0x1.0000000000001p0L, -1.112536929253600444512293438042957369978e-308L, -7.853981633974484206379633083355174374608e-1L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 0x0.fffffffffffff8p0L, 0x1p-1022L, 1.871497387511852332650969166374185305708e1L, 1.002084180004486444624900488355118689113e-292L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM },
	TEST_c_c(catanh, 0x0.fffffffffffff8p0L, -0x1p-1022L, 1.871497387511852332650969166374185305708e1L, -1.002084180004486444624900488355118689113e-292L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM },
	TEST_c_c(catanh, -0x0.fffffffffffff8p0L, 0x1p-1022L, -1.871497387511852332650969166374185305708e1L, 1.002084180004486444624900488355118689113e-292L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM },
	TEST_c_c(catanh, -0x0.fffffffffffff8p0L, -0x1p-1022L, -1.871497387511852332650969166374185305708e1L, -1.002084180004486444624900488355118689113e-292L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM },
	TEST_c_c(catanh, 0x1p-1022L, 0x0.fffffffffffff8p0L, 1.112536929253600815061527818977844932790e-308L, 7.853981633974482541045096145620456183798e-1L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -0x1p-1022L, 0x0.fffffffffffff8p0L, -1.112536929253600815061527818977844932790e-308L, 7.853981633974482541045096145620456183798e-1L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, 0x1p-1022L, -0x0.fffffffffffff8p0L, 1.112536929253600815061527818977844932790e-308L, -7.853981633974482541045096145620456183798e-1L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(catanh, -0x1p-1022L, -0x0.fffffffffffff8p0L, -1.112536929253600815061527818977844932790e-308L, -7.853981633974482541045096145620456183798e-1L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
#endif
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	TEST_c_c(catanh, 0x1.0000000000000002p0L, 0x1p-1022L, 2.218070977791824990137853294097378778927e1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(catanh, 0x1.0000000000000002p0L, -0x1p-1022L, 2.218070977791824990137853294097378778927e1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(catanh, -0x1.0000000000000002p0L, 0x1p-1022L, -2.218070977791824990137853294097378778927e1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(catanh, -0x1.0000000000000002p0L, -0x1p-1022L, -2.218070977791824990137853294097378778927e1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(catanh, 0x1p-1022L, 0x1.0000000000000002p0L, 1.112536929253600691424494863099491450042e-308L, 7.853981633974483096698709544441509427467e-1L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, -0x1p-1022L, 0x1.0000000000000002p0L, -1.112536929253600691424494863099491450042e-308L, 7.853981633974483096698709544441509427467e-1L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, 0x1p-1022L, -0x1.0000000000000002p0L, 1.112536929253600691424494863099491450042e-308L, -7.853981633974483096698709544441509427467e-1L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, -0x1p-1022L, -0x1.0000000000000002p0L, -1.112536929253600691424494863099491450042e-308L, -7.853981633974483096698709544441509427467e-1L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, 0x0.ffffffffffffffffp0L, 0x1p-1022L, 2.252728336819822255604649142023466965703e1L, 2.052268400649188124723641491045245971623e-289L, 0 },
	TEST_c_c(catanh, 0x0.ffffffffffffffffp0L, -0x1p-1022L, 2.252728336819822255604649142023466965703e1L, -2.052268400649188124723641491045245971623e-289L, 0 },
	TEST_c_c(catanh, -0x0.ffffffffffffffffp0L, 0x1p-1022L, -2.252728336819822255604649142023466965703e1L, 2.052268400649188124723641491045245971623e-289L, 0 },
	TEST_c_c(catanh, -0x0.ffffffffffffffffp0L, -0x1p-1022L, -2.252728336819822255604649142023466965703e1L, -2.052268400649188124723641491045245971623e-289L, 0 },
	TEST_c_c(catanh, 0x1p-1022L, 0x0.ffffffffffffffffp0L, 1.112536929253600691605427106449557323148e-308L, 7.853981633974483095885557915077381101984e-1L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, -0x1p-1022L, 0x0.ffffffffffffffffp0L, -1.112536929253600691605427106449557323148e-308L, 7.853981633974483095885557915077381101984e-1L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, 0x1p-1022L, -0x0.ffffffffffffffffp0L, 1.112536929253600691605427106449557323148e-308L, -7.853981633974483095885557915077381101984e-1L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, -0x1p-1022L, -0x0.ffffffffffffffffp0L, -1.112536929253600691605427106449557323148e-308L, -7.853981633974483095885557915077381101984e-1L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUXL },
#endif
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 106
	TEST_c_c(catanh, 0x1.000000000000000000000000008p0L, 0x1p-1022L, 3.673680056967710139911330243728336427098e1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(catanh, 0x1.000000000000000000000000008p0L, -0x1p-1022L, 3.673680056967710139911330243728336427098e1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(catanh, -0x1.000000000000000000000000008p0L, 0x1p-1022L, -3.673680056967710139911330243728336427098e1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(catanh, -0x1.000000000000000000000000008p0L, -0x1p-1022L, -3.673680056967710139911330243728336427098e1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(catanh, 0x1p-1022L, 0x1.000000000000000000000000008p0L, 1.112536929253600691545116358666174605957e-308L, 7.853981633974483096156608458198880470009e-1L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(catanh, -0x1p-1022L, 0x1.000000000000000000000000008p0L, -1.112536929253600691545116358666174605957e-308L, 7.853981633974483096156608458198880470009e-1L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(catanh, 0x1p-1022L, -0x1.000000000000000000000000008p0L, 1.112536929253600691545116358666174605957e-308L, -7.853981633974483096156608458198880470009e-1L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(catanh, -0x1p-1022L, -0x1.000000000000000000000000008p0L, -1.112536929253600691545116358666174605957e-308L, -7.853981633974483096156608458198880470009e-1L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(catanh, 0x0.ffffffffffffffffffffffffffcp0L, 0x1p-1022L, 3.708337415995707405382191849801244331055e1L, 9.025971879324147880346310405868788320726e-277L, 0 },
	TEST_c_c(catanh, 0x0.ffffffffffffffffffffffffffcp0L, -0x1p-1022L, 3.708337415995707405382191849801244331055e1L, -9.025971879324147880346310405868788320726e-277L, 0 },
	TEST_c_c(catanh, -0x0.ffffffffffffffffffffffffffcp0L, 0x1p-1022L, -3.708337415995707405382191849801244331055e1L, 9.025971879324147880346310405868788320726e-277L, 0 },
	TEST_c_c(catanh, -0x0.ffffffffffffffffffffffffffcp0L, -0x1p-1022L, -3.708337415995707405382191849801244331055e1L, -9.025971879324147880346310405868788320726e-277L, 0 },
	TEST_c_c(catanh, 0x1p-1022L, 0x0.ffffffffffffffffffffffffffcp0L, 1.112536929253600691545116358666215745186e-308L, 7.853981633974483096156608458198695580735e-1L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(catanh, -0x1p-1022L, 0x0.ffffffffffffffffffffffffffcp0L, -1.112536929253600691545116358666215745186e-308L, 7.853981633974483096156608458198695580735e-1L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(catanh, 0x1p-1022L, -0x0.ffffffffffffffffffffffffffcp0L, 1.112536929253600691545116358666215745186e-308L, -7.853981633974483096156608458198695580735e-1L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(catanh, -0x1p-1022L, -0x0.ffffffffffffffffffffffffffcp0L, -1.112536929253600691545116358666215745186e-308L, -7.853981633974483096156608458198695580735e-1L, UNDERFLOW_EXCEPTION_DOUBLE },
#endif
#if defined TEST_LDOUBLE && LDBL_MAX_EXP >= 16384
	TEST_c_c(catanh, 1.0L, 0x1p-8192L, 2.839477425163815960027691385553420311121e3L, 7.853981633974483096156608458198757210493e-1L, 0 },
	TEST_c_c(catanh, 1.0L, -0x1p-8192L, 2.839477425163815960027691385553420311121e3L, -7.853981633974483096156608458198757210493e-1L, 0 },
	TEST_c_c(catanh, -1.0L, 0x1p-8192L, -2.839477425163815960027691385553420311121e3L, 7.853981633974483096156608458198757210493e-1L, 0 },
	TEST_c_c(catanh, -1.0L, -0x1p-8192L, -2.839477425163815960027691385553420311121e3L, -7.853981633974483096156608458198757210493e-1L, 0 },
	TEST_c_c(catanh, 0x1p-8192L, 1.0L, 4.584009668887117914053530980121207914891e-2467L, 7.853981633974483096156608458198757210493e-1L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, -0x1p-8192L, 1.0L, -4.584009668887117914053530980121207914891e-2467L, 7.853981633974483096156608458198757210493e-1L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, 0x1p-8192L, -1.0L, 4.584009668887117914053530980121207914891e-2467L, -7.853981633974483096156608458198757210493e-1L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, -0x1p-8192L, -1.0L, -4.584009668887117914053530980121207914891e-2467L, -7.853981633974483096156608458198757210493e-1L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, 1.0L, 0x1.3p-8221L, 2.849442134153471837403071201841536297726e3L, 7.853981633974483096156608458198757210493e-1L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, 1.0L, -0x1.3p-8221L, 2.849442134153471837403071201841536297726e3L, -7.853981633974483096156608458198757210493e-1L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, -1.0L, 0x1.3p-8221L, -2.849442134153471837403071201841536297726e3L, 7.853981633974483096156608458198757210493e-1L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, -1.0L, -0x1.3p-8221L, -2.849442134153471837403071201841536297726e3L, -7.853981633974483096156608458198757210493e-1L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, 0x1.3p-8221L, 1.0L, 1.013933025636421986471594877335044443409e-2475L, 7.853981633974483096156608458198757210493e-1L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, -0x1.3p-8221L, 1.0L, -1.013933025636421986471594877335044443409e-2475L, 7.853981633974483096156608458198757210493e-1L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, 0x1.3p-8221L, -1.0L, 1.013933025636421986471594877335044443409e-2475L, -7.853981633974483096156608458198757210493e-1L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, -0x1.3p-8221L, -1.0L, -1.013933025636421986471594877335044443409e-2475L, -7.853981633974483096156608458198757210493e-1L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, 1.0L, 0x1.3p-8246L, 2.858106473910471153770786603359763504827e3L, 7.853981633974483096156608458198757210493e-1L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, 1.0L, -0x1.3p-8246L, 2.858106473910471153770786603359763504827e3L, -7.853981633974483096156608458198757210493e-1L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, -1.0L, 0x1.3p-8246L, -2.858106473910471153770786603359763504827e3L, 7.853981633974483096156608458198757210493e-1L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, -1.0L, -0x1.3p-8246L, -2.858106473910471153770786603359763504827e3L, -7.853981633974483096156608458198757210493e-1L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, 0x1.3p-8246L, 1.0L, 3.021755890954798419688924781486524472858e-2483L, 7.853981633974483096156608458198757210493e-1L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, -0x1.3p-8246L, 1.0L, -3.021755890954798419688924781486524472858e-2483L, 7.853981633974483096156608458198757210493e-1L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, 0x1.3p-8246L, -1.0L, 3.021755890954798419688924781486524472858e-2483L, -7.853981633974483096156608458198757210493e-1L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, -0x1.3p-8246L, -1.0L, -3.021755890954798419688924781486524472858e-2483L, -7.853981633974483096156608458198757210493e-1L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, 1.0L, 0x1p-16380L, 5.677221982376232056781839690803195180822e3L, 7.853981633974483096156608458198757210493e-1L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, 1.0L, -0x1p-16380L, 5.677221982376232056781839690803195180822e3L, -7.853981633974483096156608458198757210493e-1L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, -1.0L, 0x1p-16380L, -5.677221982376232056781839690803195180822e3L, 7.853981633974483096156608458198757210493e-1L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, -1.0L, -0x1p-16380L, -5.677221982376232056781839690803195180822e3L, -7.853981633974483096156608458198757210493e-1L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, 0x1p-16380L, 1.0L, 6.724206286224187012525355634643505205196e-4932L, 7.853981633974483096156608458198757210493e-1L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, -0x1p-16380L, 1.0L, -6.724206286224187012525355634643505205196e-4932L, 7.853981633974483096156608458198757210493e-1L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, 0x1p-16380L, -1.0L, 6.724206286224187012525355634643505205196e-4932L, -7.853981633974483096156608458198757210493e-1L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, -0x1p-16380L, -1.0L, -6.724206286224187012525355634643505205196e-4932L, -7.853981633974483096156608458198757210493e-1L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, 0x1.0000000000000002p0L, 0x1p-16382L, 2.218070977791824990137853294097378778927e1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(catanh, 0x1.0000000000000002p0L, -0x1p-16382L, 2.218070977791824990137853294097378778927e1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(catanh, -0x1.0000000000000002p0L, 0x1p-16382L, -2.218070977791824990137853294097378778927e1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(catanh, -0x1.0000000000000002p0L, -0x1p-16382L, -2.218070977791824990137853294097378778927e1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(catanh, 0x1p-16382L, 0x1.0000000000000002p0L, 1.681051571556046752949078932066752571182e-4932L, 7.853981633974483096698709544441509427467e-1L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, -0x1p-16382L, 0x1.0000000000000002p0L, -1.681051571556046752949078932066752571182e-4932L, 7.853981633974483096698709544441509427467e-1L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, 0x1p-16382L, -0x1.0000000000000002p0L, 1.681051571556046752949078932066752571182e-4932L, -7.853981633974483096698709544441509427467e-1L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, -0x1p-16382L, -0x1.0000000000000002p0L, -1.681051571556046752949078932066752571182e-4932L, -7.853981633974483096698709544441509427467e-1L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, 0x0.ffffffffffffffffp0L, 0x1p-16382L, 2.252728336819822255604649142023466965703e1L, 3.100992811520163369065387859792822623745e-4913L, 0 },
	TEST_c_c(catanh, 0x0.ffffffffffffffffp0L, -0x1p-16382L, 2.252728336819822255604649142023466965703e1L, -3.100992811520163369065387859792822623745e-4913L, 0 },
	TEST_c_c(catanh, -0x0.ffffffffffffffffp0L, 0x1p-16382L, -2.252728336819822255604649142023466965703e1L, 3.100992811520163369065387859792822623745e-4913L, 0 },
	TEST_c_c(catanh, -0x0.ffffffffffffffffp0L, -0x1p-16382L, -2.252728336819822255604649142023466965703e1L, -3.100992811520163369065387859792822623745e-4913L, 0 },
	TEST_c_c(catanh, 0x1p-16382L, 0x0.ffffffffffffffffp0L, 1.681051571556046753222468896957938166365e-4932L, 7.853981633974483095885557915077381101984e-1L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, -0x1p-16382L, 0x0.ffffffffffffffffp0L, -1.681051571556046753222468896957938166365e-4932L, 7.853981633974483095885557915077381101984e-1L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, 0x1p-16382L, -0x0.ffffffffffffffffp0L, 1.681051571556046753222468896957938166365e-4932L, -7.853981633974483095885557915077381101984e-1L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(catanh, -0x1p-16382L, -0x0.ffffffffffffffffp0L, -1.681051571556046753222468896957938166365e-4932L, -7.853981633974483095885557915077381101984e-1L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
# if LDBL_MANT_DIG >= 113
	TEST_c_c(catanh, 0x1.0000000000000000000000000001p0L, 0x1p-16382L, 3.916281570163690998207361486238697614441e1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(catanh, 0x1.0000000000000000000000000001p0L, -0x1p-16382L, 3.916281570163690998207361486238697614441e1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(catanh, -0x1.0000000000000000000000000001p0L, 0x1p-16382L, -3.916281570163690998207361486238697614441e1L, 1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(catanh, -0x1.0000000000000000000000000001p0L, -0x1p-16382L, -3.916281570163690998207361486238697614441e1L, -1.570796326794896619231321691639751442099L, 0 },
	TEST_c_c(catanh, 0x1p-16382L, 0x1.0000000000000000000000000001p0L, 1.681051571556046753131338908660875977540e-4932L, 7.853981633974483096156608458198758173458e-1L, UNDERFLOW_EXCEPTION },
	TEST_c_c(catanh, -0x1p-16382L, 0x1.0000000000000000000000000001p0L, -1.681051571556046753131338908660875977540e-4932L, 7.853981633974483096156608458198758173458e-1L, UNDERFLOW_EXCEPTION },
	TEST_c_c(catanh, 0x1p-16382L, -0x1.0000000000000000000000000001p0L, 1.681051571556046753131338908660875977540e-4932L, -7.853981633974483096156608458198758173458e-1L, UNDERFLOW_EXCEPTION },
	TEST_c_c(catanh, -0x1p-16382L, -0x1.0000000000000000000000000001p0L, -1.681051571556046753131338908660875977540e-4932L, -7.853981633974483096156608458198758173458e-1L, UNDERFLOW_EXCEPTION },
	TEST_c_c(catanh, 0x0.ffffffffffffffffffffffffffff8p0L, 0x1p-16382L, 3.950938929191688263678223092311606435623e1L, 1.745703758805099310527547423749501866998e-4898L, 0 },
	TEST_c_c(catanh, 0x0.ffffffffffffffffffffffffffff8p0L, -0x1p-16382L, 3.950938929191688263678223092311606435623e1L, -1.745703758805099310527547423749501866998e-4898L, 0 },
	TEST_c_c(catanh, -0x0.ffffffffffffffffffffffffffff8p0L, 0x1p-16382L, -3.950938929191688263678223092311606435623e1L, 1.745703758805099310527547423749501866998e-4898L, 0 },
	TEST_c_c(catanh, -0x0.ffffffffffffffffffffffffffff8p0L, -0x1p-16382L, -3.950938929191688263678223092311606435623e1L, -1.745703758805099310527547423749501866998e-4898L, 0 },
	TEST_c_c(catanh, 0x1p-16382L, 0x0.ffffffffffffffffffffffffffff8p0L, 1.681051571556046753131338908660876463178e-4932L, 7.853981633974483096156608458198756729010e-1L, UNDERFLOW_EXCEPTION },
	TEST_c_c(catanh, -0x1p-16382L, 0x0.ffffffffffffffffffffffffffff8p0L, -1.681051571556046753131338908660876463178e-4932L, 7.853981633974483096156608458198756729010e-1L, UNDERFLOW_EXCEPTION },
	TEST_c_c(catanh, 0x1p-16382L, -0x0.ffffffffffffffffffffffffffff8p0L, 1.681051571556046753131338908660876463178e-4932L, -7.853981633974483096156608458198756729010e-1L, UNDERFLOW_EXCEPTION },
	TEST_c_c(catanh, -0x1p-16382L, -0x0.ffffffffffffffffffffffffffff8p0L, -1.681051571556046753131338908660876463178e-4932L, -7.853981633974483096156608458198756729010e-1L, UNDERFLOW_EXCEPTION },
# endif
#endif

	TEST_c_c(catanh, 0.75L, 1.25L, 0.261492138795671927078652057366532140L, 0.996825126463918666098902241310446708L, 0 },
	TEST_c_c(catanh, -2, -3, -0.14694666622552975204743278515471595L, -1.3389725222944935611241935759091443L, 0 },
}


static void test_ccos(void)
{
	struct test *testp = lookup("ccos" },

	TEST_c_c(ccos, 1.0e00, 2.0e00, 2.032723009586334228e00, -3.051897794008255004e00, 0 },
	TEST_c_c(ccos, 0.0e00, 2.0e00, 3.76219569108363138810e+00, -0.0e00, 0 },
	TEST_c_c(ccos, 1.0e00, 0.0e00, 5.40302305868139765010e-01, -0.0e00, 0 },
	TEST_c_c(ccos, -2.0e00, 2.0e00, -1.565625846385955810e00, 3.297894805669784545e00, 0 },
	TEST_c_c(ccos, -1.0e00, -2.0e00, 2.032723009586334228e00, -3.051897794008255004e00, 0 },
	TEST_c_c(ccos, 1.0e00, -2.0e00, 2.032723009586334228e00, 3.051897794008255004e00, 0 },

	TEST_c_c(ccos, 0.0, 0.0, 1.0, ZERO_M, 0 },
	TEST_c_c(ccos, ZERO_M, 0.0, 1.0, 0.0, 0 },
	TEST_c_c(ccos, 0.0, ZERO_M, 1.0, 0.0, 0 },
	TEST_c_c(ccos, ZERO_M, ZERO_M, 1.0, ZERO_M, 0 },

	TEST_c_c(ccos, INF_P, 0.0, QNAN_P, 0.0, INVALID_EXCEPTION },
	TEST_c_c(ccos, INF_P, ZERO_M, QNAN_P, 0.0, INVALID_EXCEPTION },
	TEST_c_c(ccos, INF_M, 0.0, QNAN_P, 0.0, INVALID_EXCEPTION },
	TEST_c_c(ccos, INF_M, ZERO_M, QNAN_P, 0.0, INVALID_EXCEPTION },

	TEST_c_c(ccos, 0.0, INF_P, INF_P, ZERO_M, 0 },
	TEST_c_c(ccos, 0.0, INF_M, INF_P, 0.0, 0 },
	TEST_c_c(ccos, ZERO_M, INF_P, INF_P, 0.0, 0 },
	TEST_c_c(ccos, ZERO_M, INF_M, INF_P, ZERO_M, 0 },

	TEST_c_c(ccos, INF_P, INF_P, INF_P, QNAN_P, INVALID_EXCEPTION },
	TEST_c_c(ccos, INF_M, INF_P, INF_P, QNAN_P, INVALID_EXCEPTION },
	TEST_c_c(ccos, INF_P, INF_M, INF_P, QNAN_P, INVALID_EXCEPTION },
	TEST_c_c(ccos, INF_M, INF_M, INF_P, QNAN_P, INVALID_EXCEPTION },

	TEST_c_c(ccos, 4.625, INF_P, INF_M, INF_P, 0 },
	TEST_c_c(ccos, 4.625, INF_M, INF_M, INF_M, 0 },
	TEST_c_c(ccos, -4.625, INF_P, INF_M, INF_M, 0 },
	TEST_c_c(ccos, -4.625, INF_M, INF_M, INF_P, 0 },

	TEST_c_c(ccos, INF_P, 6.75, QNAN_P, QNAN_P, INVALID_EXCEPTION },
	TEST_c_c(ccos, INF_P, -6.75, QNAN_P, QNAN_P, INVALID_EXCEPTION },
	TEST_c_c(ccos, INF_M, 6.75, QNAN_P, QNAN_P, INVALID_EXCEPTION },
	TEST_c_c(ccos, INF_M, -6.75, QNAN_P, QNAN_P, INVALID_EXCEPTION },

	TEST_c_c(ccos, QNAN_P, 0.0, QNAN_P, 0.0, 0 },
	TEST_c_c(ccos, QNAN_P, ZERO_M, QNAN_P, 0.0, 0 },

	TEST_c_c(ccos, QNAN_P, INF_P, INF_P, QNAN_P, 0 },
	TEST_c_c(ccos, QNAN_P, INF_M, INF_P, QNAN_P, 0 },

	TEST_c_c(ccos, QNAN_P, 9.0, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	TEST_c_c(ccos, QNAN_P, -9.0, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },

	TEST_c_c(ccos, 0.0, QNAN_P, QNAN_P, 0.0, IGNORE_ZERO_INF_SIGN },
	TEST_c_c(ccos, ZERO_M, QNAN_P, QNAN_P, 0.0, IGNORE_ZERO_INF_SIGN },

	TEST_c_c(ccos, 10.0, QNAN_P, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	TEST_c_c(ccos, -10.0, QNAN_P, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },

	TEST_c_c(ccos, INF_P, QNAN_P, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	TEST_c_c(ccos, INF_M, QNAN_P, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },

	TEST_c_c(ccos, QNAN_P, QNAN_P, QNAN_P, QNAN_P, 0 },

	TEST_c_c(ccos, 0.75L, 1.25L, 1.38173873063425888530729933139078645L, -1.09193013555397466170919531722024128L, 0 },
	TEST_c_c(ccos, -2, -3, -4.18962569096880723013255501961597373L, -9.10922789375533659797919726277886212L, 0 },

	TEST_c_c(ccos, 0.75, 89.5, 2.708024460708609732016532185663087200560e38L, -2.522786001038096774676288412995370563339e38L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(ccos, 0.75, -89.5, 2.708024460708609732016532185663087200560e38L, 2.522786001038096774676288412995370563339e38L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(ccos, -0.75, 89.5, 2.708024460708609732016532185663087200560e38L, 2.522786001038096774676288412995370563339e38L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(ccos, -0.75, -89.5, 2.708024460708609732016532185663087200560e38L, -2.522786001038096774676288412995370563339e38L, 0|XFAIL_NATIVE_LINUXF },

#ifndef TEST_FLOAT
	TEST_c_c(ccos, 0.75, 710.5, 1.347490911916428129246890157395342279438e308L, -1.255317763348154410745082950806112487736e308L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(ccos, 0.75, -710.5, 1.347490911916428129246890157395342279438e308L, 1.255317763348154410745082950806112487736e308L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(ccos, -0.75, 710.5, 1.347490911916428129246890157395342279438e308L, 1.255317763348154410745082950806112487736e308L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(ccos, -0.75, -710.5, 1.347490911916428129246890157395342279438e308L, -1.255317763348154410745082950806112487736e308L, 0|XFAIL_NATIVE_LINUX },
#endif

#if defined TEST_LDOUBLE && LDBL_MAX_EXP >= 16384
	TEST_c_c(ccos, 0.75, 11357.25, 9.001213196851067077465606717616495588201e4931L, -8.385498349388321535962327491346664141020e4931L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(ccos, 0.75, -11357.25, 9.001213196851067077465606717616495588201e4931L, 8.385498349388321535962327491346664141020e4931L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(ccos, -0.75, 11357.25, 9.001213196851067077465606717616495588201e4931L, 8.385498349388321535962327491346664141020e4931L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(ccos, -0.75, -11357.25, 9.001213196851067077465606717616495588201e4931L, -8.385498349388321535962327491346664141020e4931L, 0|XFAIL_NATIVE_LINUXL },
#endif

#ifdef TEST_FLOAT
	TEST_c_c(ccos, 0x1p-149, 180, INF_P, -1.043535896672617552965983803453927655332e33L, OVERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXF },
#endif

#if defined TEST_DOUBLE || (defined TEST_LDOUBLE && LDBL_MAX_EXP == 1024)
	TEST_c_c(ccos, 0x1p-1074, 1440, INF_P, -5.981479269486130556466515778180916082415e301L, OVERFLOW_EXCEPTION|XFAIL_NATIVE_LINUX },
#endif

#if defined TEST_LDOUBLE && LDBL_MAX_EXP >= 16384
	TEST_c_c(ccos, 0x1p-16434L, 22730, INF_P, -1.217853148905605987081057582351152052687e4924L, OVERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
#endif

	TEST_c_c(ccos, SUBNORM_P * 0x1p120, 0x1p-120, 1.0, SUBNORM_M, UNDERFLOW_EXCEPTION },
	TEST_c_c(ccos, 0x1p-120, SUBNORM_P * 0x1p120, 1.0, SUBNORM_M, UNDERFLOW_EXCEPTION },
}


static void test_ccosh(void)
{
	struct test *testp = lookup("ccosh" },

	TEST_c_c(ccosh, 1.0e00, 2.0e0, -6.421481221914291381e-01, 1.068607419729232788e00, 0 },
	TEST_c_c(ccosh, 0.0e00, 2.0e00, -4.161468371748924255e-01, 0.0e00, 0 },
	TEST_c_c(ccosh, 1.0e00, 0.0e00, 1.543080642819404602e00, 0.0e00, 0 },
	TEST_c_c(ccosh, -2.0e00, 2.0e00, -1.565625831484794616e00, -3.297894805669784545e00, 0 },
	TEST_c_c(ccosh, -1.0e00, -2.0e00, -6.421481221914291381e-01, 1.068607419729232788e00, 0 },
	TEST_c_c(ccosh, 1.0e00, -2.0e00, -6.421481221914291381e-01, -1.068607419729232788e00, 0 },

	TEST_c_c(ccosh, 0.0, 0.0, 1.0, 0.0, 0 },
	TEST_c_c(ccosh, ZERO_M, 0.0, 1.0, ZERO_M, 0 },
	TEST_c_c(ccosh, 0.0, ZERO_M, 1.0, ZERO_M, 0 },
	TEST_c_c(ccosh, ZERO_M, ZERO_M, 1.0, 0.0, 0 },

	TEST_c_c(ccosh, 0.0, INF_P, QNAN_P, 0.0, INVALID_EXCEPTION|IGNORE_ZERO_INF_SIGN },
	TEST_c_c(ccosh, ZERO_M, INF_P, QNAN_P, 0.0, INVALID_EXCEPTION|IGNORE_ZERO_INF_SIGN },
	TEST_c_c(ccosh, 0.0, INF_M, QNAN_P, 0.0, INVALID_EXCEPTION|IGNORE_ZERO_INF_SIGN },
	TEST_c_c(ccosh, ZERO_M, INF_M, QNAN_P, 0.0, INVALID_EXCEPTION|IGNORE_ZERO_INF_SIGN },

	TEST_c_c(ccosh, INF_P, 0.0, INF_P, 0.0, 0 },
	TEST_c_c(ccosh, INF_M, 0.0, INF_P, ZERO_M, 0 },
	TEST_c_c(ccosh, INF_P, ZERO_M, INF_P, ZERO_M, 0 },
	TEST_c_c(ccosh, INF_M, ZERO_M, INF_P, 0.0, 0 },

	TEST_c_c(ccosh, INF_P, INF_P, INF_P, QNAN_P, INVALID_EXCEPTION },
	TEST_c_c(ccosh, INF_M, INF_P, INF_P, QNAN_P, INVALID_EXCEPTION },
	TEST_c_c(ccosh, INF_P, INF_M, INF_P, QNAN_P, INVALID_EXCEPTION },
	TEST_c_c(ccosh, INF_M, INF_M, INF_P, QNAN_P, INVALID_EXCEPTION },

	TEST_c_c(ccosh, INF_P, 4.625, INF_M, INF_M, 0 },
	TEST_c_c(ccosh, INF_M, 4.625, INF_M, INF_P, 0 },
	TEST_c_c(ccosh, INF_P, -4.625, INF_M, INF_P, 0 },
	TEST_c_c(ccosh, INF_M, -4.625, INF_M, INF_M, 0 },

	TEST_c_c(ccosh, 6.75, INF_P, QNAN_P, QNAN_P, INVALID_EXCEPTION },
	TEST_c_c(ccosh, -6.75, INF_P, QNAN_P, QNAN_P, INVALID_EXCEPTION },
	TEST_c_c(ccosh, 6.75, INF_M, QNAN_P, QNAN_P, INVALID_EXCEPTION },
	TEST_c_c(ccosh, -6.75, INF_M, QNAN_P, QNAN_P, INVALID_EXCEPTION },

	TEST_c_c(ccosh, 0.0, QNAN_P, QNAN_P, 0.0, IGNORE_ZERO_INF_SIGN },
	TEST_c_c(ccosh, ZERO_M, QNAN_P, QNAN_P, 0.0, IGNORE_ZERO_INF_SIGN },

	TEST_c_c(ccosh, INF_P, QNAN_P, INF_P, QNAN_P, 0 },
	TEST_c_c(ccosh, INF_M, QNAN_P, INF_P, QNAN_P, 0 },

	TEST_c_c(ccosh, 9.0, QNAN_P, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	TEST_c_c(ccosh, -9.0, QNAN_P, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },

	TEST_c_c(ccosh, QNAN_P, 0.0, QNAN_P, 0.0, IGNORE_ZERO_INF_SIGN },
	TEST_c_c(ccosh, QNAN_P, ZERO_M, QNAN_P, 0.0, IGNORE_ZERO_INF_SIGN },

	TEST_c_c(ccosh, QNAN_P, 10.0, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	TEST_c_c(ccosh, QNAN_P, -10.0, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },

	TEST_c_c(ccosh, QNAN_P, INF_P, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	TEST_c_c(ccosh, QNAN_P, INF_M, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },

	TEST_c_c(ccosh, QNAN_P, QNAN_P, QNAN_P, QNAN_P, 0 },

	TEST_c_c(ccosh, 0.75L, 1.25L, 0.408242591877968807788852146397499084L, 0.780365930845853240391326216300863152L, 0 },

	TEST_c_c(ccosh, -2, -3, -3.72454550491532256547397070325597253L, 0.511822569987384608834463849801875634L, 0 },

	TEST_c_c(ccosh, 89.5, 0.75, 2.708024460708609732016532185663087200560e38L, 2.522786001038096774676288412995370563339e38L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(ccosh, -89.5, 0.75, 2.708024460708609732016532185663087200560e38L, -2.522786001038096774676288412995370563339e38L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(ccosh, 89.5, -0.75, 2.708024460708609732016532185663087200560e38L, -2.522786001038096774676288412995370563339e38L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(ccosh, -89.5, -0.75, 2.708024460708609732016532185663087200560e38L, 2.522786001038096774676288412995370563339e38L, 0|XFAIL_NATIVE_LINUXF },

#ifndef TEST_FLOAT
	TEST_c_c(ccosh, 710.5, 0.75, 1.347490911916428129246890157395342279438e308L, 1.255317763348154410745082950806112487736e308L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(ccosh, -710.5, 0.75, 1.347490911916428129246890157395342279438e308L, -1.255317763348154410745082950806112487736e308L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(ccosh, 710.5, -0.75, 1.347490911916428129246890157395342279438e308L, -1.255317763348154410745082950806112487736e308L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(ccosh, -710.5, -0.75, 1.347490911916428129246890157395342279438e308L, 1.255317763348154410745082950806112487736e308L, 0|XFAIL_NATIVE_LINUX },
#endif

#if defined TEST_LDOUBLE && LDBL_MAX_EXP >= 16384
	TEST_c_c(ccosh, 11357.25, 0.75, 9.001213196851067077465606717616495588201e4931L, 8.385498349388321535962327491346664141020e4931L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(ccosh, -11357.25, 0.75, 9.001213196851067077465606717616495588201e4931L, -8.385498349388321535962327491346664141020e4931L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(ccosh, 11357.25, -0.75, 9.001213196851067077465606717616495588201e4931L, -8.385498349388321535962327491346664141020e4931L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(ccosh, -11357.25, -0.75, 9.001213196851067077465606717616495588201e4931L, 8.385498349388321535962327491346664141020e4931L, 0|XFAIL_NATIVE_LINUXL },
#endif

#ifdef TEST_FLOAT
	TEST_c_c(ccosh, 180, 0x1p-149, INF_P, 1.043535896672617552965983803453927655332e33L, OVERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXF },
#endif

#if defined TEST_DOUBLE || (defined TEST_LDOUBLE && LDBL_MAX_EXP == 1024)
	TEST_c_c(ccosh, 1440, 0x1p-1074, INF_P, 5.981479269486130556466515778180916082415e301L, OVERFLOW_EXCEPTION|XFAIL_NATIVE_LINUX },
#endif

#if defined TEST_LDOUBLE && LDBL_MAX_EXP >= 16384
	TEST_c_c(ccosh, 22730, 0x1p-16434L, INF_P, 1.217853148905605987081057582351152052687e4924L, OVERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
#endif

	TEST_c_c(ccosh, SUBNORM_P * 0x1p120, 0x1p-120, 1.0, SUBNORM_P, UNDERFLOW_EXCEPTION },
	TEST_c_c(ccosh, 0x1p-120, SUBNORM_P * 0x1p120, 1.0, SUBNORM_P, UNDERFLOW_EXCEPTION },
}

static void test_cexp(void)
{
	struct test *testp = lookup("cexp" },

	TEST_c_c(cexp, 1.0e00, 2.0e00, -1.131204381585121154e00, 2.471726655960083007e00, 0 },
	TEST_c_c(cexp, 0.0e00, 2.0e00, -4.161468371748924255e-01, 9.092974215745925903e-01, 0 },
	TEST_c_c(cexp, 1.0e00, 0.0e00, 2.718281835317611694e00, 0.0e00, 0 },
	TEST_c_c(cexp, -2.0e00, 2.0e00, -5.631934991106390953e-02, 1.230600243434309959e-01, 0 },
	TEST_c_c(cexp, -1.0e00, -2.0e00, -1.530918665230274200e-01, -3.345118276774883270e-01, 0 },
	TEST_c_c(cexp, 1.0e00, -2.0e00, -1.131204381585121154e00, -2.471726655960083007e00, 0 },

	TEST_c_c(cexp, ZERO_P, ZERO_P, 1, 0.0, 0 },
	TEST_c_c(cexp, ZERO_M, ZERO_P, 1, 0.0, 0 },
	TEST_c_c(cexp, ZERO_P, ZERO_M, 1, ZERO_M, 0 },
	TEST_c_c(cexp, ZERO_M, ZERO_M, 1, ZERO_M, 0 },

	TEST_c_c(cexp, INF_P, ZERO_P, INF_P, 0.0, 0 },
	TEST_c_c(cexp, INF_P, ZERO_M, INF_P, ZERO_M, 0 },

	TEST_c_c(cexp, INF_M, ZERO_P, 0.0, 0.0, 0 },
	TEST_c_c(cexp, INF_M, ZERO_M, 0.0, ZERO_M, 0 },

	TEST_c_c(cexp, 0.0, INF_P, QNAN_P, QNAN_P, INVALID_EXCEPTION },
	TEST_c_c(cexp, ZERO_M, INF_P, QNAN_P, QNAN_P, INVALID_EXCEPTION },

	TEST_c_c(cexp, 0.0, INF_M, QNAN_P, QNAN_P, INVALID_EXCEPTION },
	TEST_c_c(cexp, ZERO_M, INF_M, QNAN_P, QNAN_P, INVALID_EXCEPTION },

	TEST_c_c(cexp, 100.0, INF_P, QNAN_P, QNAN_P, INVALID_EXCEPTION },
	TEST_c_c(cexp, -100.0, INF_P, QNAN_P, QNAN_P, INVALID_EXCEPTION },

	TEST_c_c(cexp, 100.0, INF_M, QNAN_P, QNAN_P, INVALID_EXCEPTION },
	TEST_c_c(cexp, -100.0, INF_M, QNAN_P, QNAN_P, INVALID_EXCEPTION },

	TEST_c_c(cexp, INF_M, 2.0, ZERO_M, 0.0, 0 },
	TEST_c_c(cexp, INF_M, 4.0, ZERO_M, ZERO_M, 0 },
	TEST_c_c(cexp, INF_P, 2.0, INF_M, INF_P, 0 },
	TEST_c_c(cexp, INF_P, 4.0, INF_M, INF_M, 0 },

	TEST_c_c(cexp, INF_P, INF_P, INF_P, QNAN_P, INVALID_EXCEPTION|IGNORE_ZERO_INF_SIGN },
	TEST_c_c(cexp, INF_P, INF_M, INF_P, QNAN_P, INVALID_EXCEPTION|IGNORE_ZERO_INF_SIGN },

	TEST_c_c(cexp, INF_M, INF_P, 0.0, 0.0, IGNORE_ZERO_INF_SIGN },
	TEST_c_c(cexp, INF_M, INF_M, 0.0, ZERO_M, IGNORE_ZERO_INF_SIGN },

	TEST_c_c(cexp, INF_M, QNAN_P, 0, 0, IGNORE_ZERO_INF_SIGN },

	TEST_c_c(cexp, INF_P, QNAN_P, INF_P, QNAN_P, 0 },

	TEST_c_c(cexp, QNAN_P, 0.0, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	TEST_c_c(cexp, QNAN_P, 1.0, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },

	TEST_c_c(cexp, QNAN_P, INF_P, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	TEST_c_c(cexp, 0, QNAN_P, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	TEST_c_c(cexp, 1, QNAN_P, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	TEST_c_c(cexp, QNAN_P, QNAN_P, QNAN_P, QNAN_P, 0 },

	TEST_c_c(cexp, 0.75L, 1.25L, 0.667537446429131586942201977015932112L, 2.00900045494094876258347228145863909L, 0 },
	TEST_c_c(cexp, -2.0, -3.0, -0.13398091492954261346140525546115575L, -0.019098516261135196432576240858800925L, 0 },

	TEST_c_c(cexp, 0, 0x1p65, 0.99888622066058013610642172179340364209972L, -0.047183876212354673805106149805700013943218L, 0|XFAIL_NATIVE_LINUXL|XFAIL_FPU },
	TEST_c_c(cexp, 0, -0x1p65, 0.99888622066058013610642172179340364209972L, 0.047183876212354673805106149805700013943218L, 0|XFAIL_NATIVE_LINUXL|XFAIL_FPU },
	TEST_c_c(cexp, 50, 0x1p127, 4.053997150228616856622417636046265337193e21L, 3.232070315463388524466674772633810238819e21L, 0|XFAIL_NATIVE_LINUXL|XFAIL_FPU },

#ifndef TEST_FLOAT
	TEST_c_c(cexp, 0, 1e22, 0.5232147853951389454975944733847094921409L, -0.8522008497671888017727058937530293682618L, 0|XFAIL_NATIVE_LINUXL|XFAIL_FPU },
	TEST_c_c(cexp, 0, 0x1p1023, -0.826369834614147994500785680811743734805L, 0.5631277798508840134529434079444683477104L, 0|XFAIL_NATIVE_LINUXL|XFAIL_FPU },
	TEST_c_c(cexp, 500, 0x1p1023, -1.159886268932754433233243794561351783426e217L, 7.904017694554466595359379965081774849708e216L, 0|XFAIL_NATIVE_LINUXL|XFAIL_FPU },
#endif

#if defined TEST_LDOUBLE && LDBL_MAX_EXP >= 16384
	TEST_c_c(cexp, 0, 0x1p16383L, 0.9210843909921906206874509522505756251609L, 0.3893629985894208126948115852610595405563L, 0|XFAIL_NATIVE_LINUXL|XFAIL_FPU },
	TEST_c_c(cexp, -10000, 0x1p16383L, 1.045876464564882298442774542991176546722e-4343L, 4.421154026488516836023811173959413420548e-4344L, 0|XFAIL_NATIVE_LINUXL|XFAIL_FPU },
#endif

	TEST_c_c(cexp, 88.75, 0.75, 2.558360358486542817001900410314204322891e38L, 2.383359453227311447654736314679677655100e38L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(cexp, -95, 0.75, 4.039714446238306526889476684000081624047e-42L, 3.763383677300535390271646960780570275931e-42L, UNDERFLOW_EXCEPTION_FLOAT },

#ifndef TEST_FLOAT
	TEST_c_c(cexp, 709.8125, 0.75, 1.355121963080879535248452862759108365762e308L, 1.262426823598609432507811340856186873507e308L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(cexp, -720, 0.75, 1.486960657116368433685753325516638551722e-313L, 1.385247284245720590980701226843815229385e-313L, UNDERFLOW_EXCEPTION_DOUBLE },
#endif

#if defined TEST_LDOUBLE && LDBL_MAX_EXP >= 16384
	TEST_c_c(cexp, 11356.5625, 0.75, 9.052188470850960144814815984311663764287e4931L, 8.432986734191301036267148978260970230200e4931L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(cexp, -11370, 0.75, 8.631121063182211587489310508568170739592e-4939L, 8.040721827809267291427062346918413482824e-4939L, UNDERFLOW_EXCEPTION|XFAIL_TODO },
#endif

#ifdef TEST_FLOAT
	TEST_c_c(cexp, 180, 0x1p-149, INF_P, 2.087071793345235105931967606907855310664e33L, OVERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXF },
#endif

#if defined TEST_DOUBLE || (defined TEST_LDOUBLE && LDBL_MAX_EXP == 1024)
	TEST_c_c(cexp, 1440, 0x1p-1074, INF_P, 1.196295853897226111293303155636183216483e302L, OVERFLOW_EXCEPTION|XFAIL_NATIVE_LINUX },
#endif

#if defined TEST_LDOUBLE && LDBL_MAX_EXP >= 16384
	TEST_c_c(cexp, 22730, 0x1p-16434L, INF_P, 2.435706297811211974162115164702304105374e4924L, OVERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
#endif

	TEST_c_c(cexp, 1e6, 0, INF_P, 0, OVERFLOW_EXCEPTION|XFAIL_NATIVE_LINUX },
	TEST_c_c(cexp, 1e6, MIN_P, INF_P, INF_P, OVERFLOW_EXCEPTION },
	TEST_c_c(cexp, 1e6, MIN_M, INF_P, INF_M, OVERFLOW_EXCEPTION },

	TEST_c_c(cexp, MIN_P, SUBNORM_P, 1.0, SUBNORM_P, UNDERFLOW_EXCEPTION },
	TEST_c_c(cexp, MIN_P, SUBNORM_M, 1.0, SUBNORM_M, UNDERFLOW_EXCEPTION },
}


static void test_clog(void)
{
	struct test *testp = lookup("clog" },

	TEST_c_c(clog, 1.0e00, 2.0e00, 8.047189563512802124e-01, 1.107148721814155578e00, 0 },
	TEST_c_c(clog, 0.0e00, 2.0e00, 6.931471824645996093e-01, 1.570796325802803039e00, 0 },
	TEST_c_c(clog, 1.0e00, 0.0e00, 0.0e00, 0.0e00, 0 },
	TEST_c_c(clog, -2.0e00, 2.0e00, 1.039720773696899414e00, 2.356194496154785156e00, 0 },
	TEST_c_c(clog, -1.0e00, -2.0e00, 8.047189563512802124e-01, -2.034443944692611694e00, 0 },
	TEST_c_c(clog, 1.0e00, -2.0e00, 8.047189563512802124e-01, -1.107148721814155578e00, 0 },

	TEST_c_c(clog, ZERO_M, 0, INF_M, M_PIl, DIVIDE_BY_ZERO_EXCEPTION },
	TEST_c_c(clog, ZERO_M, ZERO_M, INF_M, -M_PIl, DIVIDE_BY_ZERO_EXCEPTION },

	TEST_c_c(clog, 0, 0, INF_M, 0.0, DIVIDE_BY_ZERO_EXCEPTION },
	TEST_c_c(clog, 0, ZERO_M, INF_M, ZERO_M, DIVIDE_BY_ZERO_EXCEPTION },

	TEST_c_c(clog, INF_M, INF_P, INF_P, M_PI_34l, 0 },
	TEST_c_c(clog, INF_M, INF_M, INF_P, -M_PI_34l, 0 },

	TEST_c_c(clog, INF_P, INF_P, INF_P, M_PI_4l, 0 },
	TEST_c_c(clog, INF_P, INF_M, INF_P, -M_PI_4l, 0 },

	TEST_c_c(clog, 0, INF_P, INF_P, M_PI_2l, 0 },
	TEST_c_c(clog, 3, INF_P, INF_P, M_PI_2l, 0 },
	TEST_c_c(clog, ZERO_M, INF_P, INF_P, M_PI_2l, 0 },
	TEST_c_c(clog, -3, INF_P, INF_P, M_PI_2l, 0 },
	TEST_c_c(clog, 0, INF_M, INF_P, -M_PI_2l, 0 },
	TEST_c_c(clog, 3, INF_M, INF_P, -M_PI_2l, 0 },
	TEST_c_c(clog, ZERO_M, INF_M, INF_P, -M_PI_2l, 0 },
	TEST_c_c(clog, -3, INF_M, INF_P, -M_PI_2l, 0 },

	TEST_c_c(clog, INF_M, 0, INF_P, M_PIl, 0 },
	TEST_c_c(clog, INF_M, 1, INF_P, M_PIl, 0 },
	TEST_c_c(clog, INF_M, ZERO_M, INF_P, -M_PIl, 0 },
	TEST_c_c(clog, INF_M, -1, INF_P, -M_PIl, 0 },

	TEST_c_c(clog, INF_P, 0, INF_P, 0.0, 0 },
	TEST_c_c(clog, INF_P, 1, INF_P, 0.0, 0 },
	TEST_c_c(clog, INF_P, ZERO_M, INF_P, ZERO_M, 0 },
	TEST_c_c(clog, INF_P, -1, INF_P, ZERO_M, 0 },

	TEST_c_c(clog, INF_P, QNAN_P, INF_P, QNAN_P, 0 },
	TEST_c_c(clog, INF_M, QNAN_P, INF_P, QNAN_P, 0 },

	TEST_c_c(clog, QNAN_P, INF_P, INF_P, QNAN_P, 0 },
	TEST_c_c(clog, QNAN_P, INF_M, INF_P, QNAN_P, 0 },

	TEST_c_c(clog, 0, QNAN_P, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	TEST_c_c(clog, 3, QNAN_P, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	TEST_c_c(clog, ZERO_M, QNAN_P, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	TEST_c_c(clog, -3, QNAN_P, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },

	TEST_c_c(clog, QNAN_P, 0, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	TEST_c_c(clog, QNAN_P, 5, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	TEST_c_c(clog, QNAN_P, ZERO_M, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	TEST_c_c(clog, QNAN_P, -5, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },

	TEST_c_c(clog, QNAN_P, QNAN_P, QNAN_P, QNAN_P, 0 },

	TEST_c_c(clog, 0.75L, 1.25L, 0.376885901188190075998919126749298416L, 1.03037682652431246378774332703115153L, 0 },
	TEST_c_c(clog, -2, -3, 1.2824746787307683680267437207826593L, -2.1587989303424641704769327722648368L, 0 },

	TEST_c_c(clog, 0x1.fffffep+127L, 0x1.fffffep+127L, 89.06941264234832570836679262104313101776L, M_PI_4l, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(clog, 0x1.fffffep+127L, 1.0L, 88.72283905206835305365817656031404273372L, 2.938736052218037251011746307725933020145e-39L, UNDERFLOW_EXCEPTION_FLOAT },
	TEST_c_c(clog, 0x1p-149L, 0x1p-149L, -102.9323563131518784484589700365392203592L, M_PI_4l, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(clog, 0x1p-147L, 0x1p-147L, -101.5460619520319878296245057936228672231L, M_PI_4l, 0|XFAIL_NATIVE_LINUXF },

#ifndef TEST_FLOAT
	TEST_c_c(clog, 0x1.fffffffffffffp+1023L, 0x1.fffffffffffffp+1023L, 710.1292864836639693869320059713862337880L, M_PI_4l, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(clog, 0x1.fffffffffffffp+1023L, 0x1p+1023L, 709.8942846690411016323109979483151967689L, 0.4636476090008061606231772164674799632783L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(clog, 0x1p-1074L, 0x1p-1074L, -744.0934983311012896593986823853525458290L, M_PI_4l, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(clog, 0x1p-1073L, 0x1p-1073L, -743.4003511505413443499814502638943692610L, M_PI_4l, 0|XFAIL_NATIVE_LINUX },
#endif

#if defined TEST_LDOUBLE && LDBL_MAX_EXP >= 16384
	TEST_c_c(clog, 0x1.fp+16383L, 0x1.fp+16383L, 11356.83823118610934184548269774874545400L, M_PI_4l, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(clog, 0x1.fp+16383L, 0x1p+16383L, 11356.60974243783798653123798337822335902L, 0.4764674194737066993385333770295162295856L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(clog, 0x1p-16440L, 0x1p-16441L, -11395.22807662984378194141292922726786191L, 0.4636476090008061162142562314612144020285L, 0|XFAIL_NATIVE_LINUXL },
#endif

	TEST_c_c(clog, 0x1p-149L, 0x1.fp+127L, 88.69109041335841930424871526389807508374L, M_PI_2l, 0 },
	TEST_c_c(clog, -0x1p-149L, 0x1.fp+127L, 88.69109041335841930424871526389807508374L, M_PI_2l, 0 },
	TEST_c_c(clog, 0x1p-149L, -0x1.fp+127L, 88.69109041335841930424871526389807508374L, -M_PI_2l, 0 },
	TEST_c_c(clog, -0x1p-149L, -0x1.fp+127L, 88.69109041335841930424871526389807508374L, -M_PI_2l, 0 },
	TEST_c_c(clog, -0x1.fp+127L, 0x1p-149L, 88.69109041335841930424871526389807508374L, M_PIl, 0 },
	TEST_c_c(clog, -0x1.fp+127L, -0x1p-149L, 88.69109041335841930424871526389807508374L, -M_PIl, 0 },
#ifdef TEST_FLOAT
	TEST_c_c(clog, 0x1.fp+127L, 0x1p-149L, 88.69109041335841930424871526389807508374L, ZERO_P, UNDERFLOW_EXCEPTION },
	TEST_c_c(clog, 0x1.fp+127L, -0x1p-149L, 88.69109041335841930424871526389807508374L, ZERO_M, UNDERFLOW_EXCEPTION },
#endif

#ifndef TEST_FLOAT
	TEST_c_c(clog, 0x1p-1074L, 0x1.fp+1023L, 709.7509641950694165420886960904242800794L, M_PI_2l, 0 },
	TEST_c_c(clog, -0x1p-1074L, 0x1.fp+1023L, 709.7509641950694165420886960904242800794L, M_PI_2l, 0 },
	TEST_c_c(clog, 0x1p-1074L, -0x1.fp+1023L, 709.7509641950694165420886960904242800794L, -M_PI_2l, 0 },
	TEST_c_c(clog, -0x1p-1074L, -0x1.fp+1023L, 709.7509641950694165420886960904242800794L, -M_PI_2l, 0 },
	TEST_c_c(clog, -0x1.fp+1023L, 0x1p-1074L, 709.7509641950694165420886960904242800794L, M_PIl, 0 },
	TEST_c_c(clog, -0x1.fp+1023L, -0x1p-1074L, 709.7509641950694165420886960904242800794L, -M_PIl, 0 },
#endif
#if defined TEST_DOUBLE || (defined TEST_LDOUBLE && LDBL_MAX_EXP == 1024)
	TEST_c_c(clog, 0x1.fp+1023L, 0x1p-1074L, 709.7509641950694165420886960904242800794L, ZERO_P, UNDERFLOW_EXCEPTION },
	TEST_c_c(clog, 0x1.fp+1023L, -0x1p-1074L, 709.7509641950694165420886960904242800794L, ZERO_M, UNDERFLOW_EXCEPTION },
#endif

#if defined TEST_LDOUBLE && LDBL_MAX_EXP >= 16384
	TEST_c_c(clog, 0x1p-16445L, 0x1.fp+16383L, 11356.49165759582936919077408168801636572L, M_PI_2l, 0 },
	TEST_c_c(clog, -0x1p-16445L, 0x1.fp+16383L, 11356.49165759582936919077408168801636572L, M_PI_2l, 0 },
	TEST_c_c(clog, 0x1p-16445L, -0x1.fp+16383L, 11356.49165759582936919077408168801636572L, -M_PI_2l, 0 },
	TEST_c_c(clog, -0x1p-16445L, -0x1.fp+16383L, 11356.49165759582936919077408168801636572L, -M_PI_2l, 0 },
	TEST_c_c(clog, -0x1.fp+16383L, 0x1p-16445L, 11356.49165759582936919077408168801636572L, M_PIl, 0 },
	TEST_c_c(clog, -0x1.fp+16383L, -0x1p-16445L, 11356.49165759582936919077408168801636572L, -M_PIl, 0 },
	TEST_c_c(clog, 0x1.fp+16383L, 0x1p-16445L, 11356.49165759582936919077408168801636572L, ZERO_P, UNDERFLOW_EXCEPTION },
	TEST_c_c(clog, 0x1.fp+16383L, -0x1p-16445L, 11356.49165759582936919077408168801636572L, ZERO_M, UNDERFLOW_EXCEPTION },
# if LDBL_MANT_DIG >= 113
	TEST_c_c(clog, 0x1p-16494L, 0x1.fp+16383L, 11356.49165759582936919077408168801636572L, M_PI_2l, 0 },
	TEST_c_c(clog, -0x1p-16494L, 0x1.fp+16383L, 11356.49165759582936919077408168801636572L, M_PI_2l, 0 },
	TEST_c_c(clog, 0x1p-16494L, -0x1.fp+16383L, 11356.49165759582936919077408168801636572L, -M_PI_2l, 0 },
	TEST_c_c(clog, -0x1p-16494L, -0x1.fp+16383L, 11356.49165759582936919077408168801636572L, -M_PI_2l, 0 },
	TEST_c_c(clog, -0x1.fp+16383L, 0x1p-16494L, 11356.49165759582936919077408168801636572L, M_PIl, 0 },
	TEST_c_c(clog, -0x1.fp+16383L, -0x1p-16494L, 11356.49165759582936919077408168801636572L, -M_PIl, 0 },
	TEST_c_c(clog, 0x1.fp+16383L, 0x1p-16494L, 11356.49165759582936919077408168801636572L, ZERO_P, UNDERFLOW_EXCEPTION },
	TEST_c_c(clog, 0x1.fp+16383L, -0x1p-16494L, 11356.49165759582936919077408168801636572L, ZERO_M, UNDERFLOW_EXCEPTION },
# endif
#endif

	TEST_c_c(clog, 1.0L, 0x1.234566p-10L, 6.172834701221959432440126967147726538097e-7L, 1.111110564353742042376451655136933182201e-3L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(clog, -1.0L, 0x1.234566p-20L, 5.886877547844618300918562490463748605537e-13L, 3.141591568520436206990380699322226378452L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(clog, 0x1.234566p-30L, 1.0L, 5.614163921211322622623353961365728040115e-19L, 1.570796325735258575254858696548386439740L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(clog, -0x1.234566p-40L, -1.0L, 5.354083939753840089583620652120903838944e-25L, -1.570796326795931422008642456283782656359L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(clog, 0x1.234566p-50L, 1.0L, 5.106052341226425256332038420428899201070e-31L, 1.570796326794895608681734464330528755366L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(clog, 0x1.234566p-60L, 1.0L, 4.869510976053643471080816669875627875933e-37L, 1.570796326794896618244456860363082279319L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(clog, 0x1p-62L, 1.0L, 2.350988701644575015937473074444491355582e-38L, 1.570796326794896619014481257142650555297L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(clog, 0x1p-63L, 1.0L, 5.877471754111437539843682686111228389059e-39L, 1.570796326794896619122901474391200998698L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(clog, 0x1p-64L, 1.0L, 1.469367938527859384960920671527807097271e-39L, 1.570796326794896619177111583015476220398L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
#ifndef TEST_FLOAT
	TEST_c_c(clog, 0x1p-510L, 1.0L, 4.450147717014402766180465434664808128438e-308L, 1.570796326794896619231321691639751442099L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM|XFAIL_NATIVE_LINUX },
	TEST_c_c(clog, 0x1p-511L, 1.0L, 1.112536929253600691545116358666202032110e-308L, 1.570796326794896619231321691639751442099L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(clog, 0x1p-512L, 1.0L, 2.781342323134001728862790896665505080274e-309L, 1.570796326794896619231321691639751442099L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
#endif
#if defined TEST_LDOUBLE && LDBL_MAX_EXP >= 16384
	TEST_c_c(clog, 0x1p-8190L, 1.0L, 6.724206286224187012525355634643505205196e-4932L, 1.570796326794896619231321691639751442099L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(clog, 0x1p-8191L, 1.0L, 1.681051571556046753131338908660876301299e-4932L, 1.570796326794896619231321691639751442099L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(clog, 0x1p-8192L, 1.0L, 4.202628928890116882828347271652190753248e-4933L, 1.570796326794896619231321691639751442099L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
#endif

	TEST_c_c(clog, 0x1.000566p0L, 0x1.234p-10L, 8.298731898331237038231468223024422855654e-5L, 1.110938609507128729312743251313024793990e-3L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(clog, 0x1.000566p0L, 0x1.234p-100L, 8.237022655933121125560939513260027133767e-5L, 8.974094312218060110948251664314290484113e-31L, 0 },
#ifndef TEST_FLOAT
	TEST_c_c(clog, -0x1.0000000123456p0L, 0x1.2345678p-30L, 2.649094282537168795982991778475646793277e-10L, 3.141592652530155111500161671113150737892L, 0 },
	TEST_c_c(clog, -0x1.0000000123456p0L, 0x1.2345678p-1000L, 2.649094276923003995420209214900915462737e-10L, 3.141592653589793238462643383279502884197L, 0 },
#endif
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 106
	TEST_c_c(clog, 0x1.00000000000000123456789abcp0L, 0x1.23456789p-60L, 9.868649107778739757272772275265050767867e-19L, 9.868649106423871142816660980898339912137e-19L, 0 },
	TEST_c_c(clog, 0x1.00000000000000123456789abcp0L, 0x1.23456789p-1000L, 9.868649107778739752403260515979017248596e-19L, 1.061846605795612822522063052130030717368e-301L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM },
#endif

	TEST_c_c(clog, 0x0.ffffffp0L, 0x0.ffffffp-100L, -5.960464655174753498633255797994360530379e-8L, 7.888609052210118054117285652827862296732e-31L, 0 },
#ifndef TEST_FLOAT
	TEST_c_c(clog, 0x0.fffffffffffff8p0L, 0x0.fffffffffffff8p-1000L, -1.110223024625156602053389888482372171810e-16L, 9.332636185032188789900895447238171696171e-302L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM },
#endif
#if defined TEST_LDOUBLE && LDBL_MIN_EXP <= -16381
	TEST_c_c(clog, 0x0.ffffffffffffffffp0L, 0x0.ffffffffffffffffp-15000L, -5.421010862427522170184200798202494495630e-20L, 3.548665303440282824232502561095699343814e-4516L, 0 },
#endif

	TEST_c_c(clog, 0x1a6p-10L, 0x3a5p-10L, -1.4305135209763571252847059962654228661815e-06L, 1.1460277178115757370775644871674016684074L, 0 },
	TEST_c_c(clog, 0xf2p-10L, 0x3e3p-10L, 6.1988446308070710970664736815277450078106e-06L, 1.3322126499153926210226335249558203898460L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(clog, 0x4d4ep-15L, 0x6605p-15L, -1.6298145321400412054744424587143483169412e-08L, 0.9223574537155056772124552172295398141249L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(clog, 0x2818p-15L, 0x798fp-15L, 1.5366822245016167178749091974664853785194e-08L, 1.2522014929038946066987318471922169174157L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(clog, 0x9b57bp-20L, 0xcb7b4p-20L, -3.9563019528687610863490232935890272740908e-11L, 0.9187593477446338910857133065497364950682L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(clog, 0x2731p-20L, 0xfffd0p-20L, 4.4110493034041283943115971658295280288115e-11L, 1.5612279663766352262688735061954290528838L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(clog, 0x2ede88p-23L, 0x771c3fp-23L, -4.4764192352906350039050902870893173560494e-13L, 1.1959106857549200806818600493552847793381L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(clog, 0x11682p-23L, 0x7ffed1p-23L, 1.1723955140027907954461000991619077811832e-12L, 1.5622968405332756349813737986164832897108L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(clog, 0xa1f2c1p-24L, 0xc643aep-24L, -1.0480505352462576151523512837107080269981e-13L, 0.8858771987699967480545613322309315260313L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(clog, 0x659feap-24L, 0xeaf6f9p-24L, 3.7303493627403868207597214252239749960738e-14L, 1.1625816408046866464773042283673653469061L, 0|XFAIL_NATIVE_LINUXF },
#ifndef TEST_FLOAT
	/* disabled because real result is close to zero, but not exactly determinable */
#ifndef TEST_DOUBLE
	TEST_c_c(clog, 0x4447d7175p-35L, 0x6c445e00ap-35L, -1.4823076576950255933915367361099865652625e-20L, 1.0081311552703893116404606212158840190615L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(clog, 0x2dd46725bp-35L, 0x7783a1284p-35L, 4.4469229730850767799109418892826021157328e-20L, 1.2046235979300843056806465045930070146351L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(clog, 0x55cb6d0c83af5p-55L, 0x7fe33c0c7c4e90p-55L, -5.2000108498455368032511404449795741611813e-32L, 1.5288921536982513453421343495466824420259L, 0|XFAIL_NATIVE_LINUX },
#endif
	TEST_c_c(clog, 0x164c74eea876p-45L, 0x16f393482f77p-45L, -3.0292258760486853327810377824479932031744e-26L, 0.7998237934177411746093524982030330293980L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(clog, 0xfe961079616p-45L, 0x1bc37e09e6d1p-45L, 5.3718272201930019901317065495843842735179e-26L, 1.0503831592447830576186444373011142397404L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(clog, 0xa4722f19346cp-51L, 0x7f9631c5e7f07p-51L, -6.2122796286154679676173624516405339768606e-30L, 1.4904138780720095276446375492434049214172L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(clog, 0x10673dd0f2481p-51L, 0x7ef1d17cefbd2p-51L, 3.2047474274603604594851472963586149973093e-29L, 1.4422922682185099608731642353544207976604L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(clog, 0x8ecbf810c4ae6p-52L, 0xd479468b09a37p-52L, -9.7375017988218644730510244778042114638107e-30L, 0.9790637929494922564724108399524154766631L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(clog, 0x5b06b680ea2ccp-52L, 0xef452b965da9fp-52L, 8.3076914081087805757422664530653247447136e-30L, 1.2072712126771536614482822173033535043206L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(clog, 0x659b70ab7971bp-53L, 0x1f5d111e08abecp-53L, -2.5083311595699359750201056724289010648701e-30L, 1.3710185432462268491534742969536240564640L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(clog, 0x15cfbd1990d1ffp-53L, 0x176a3973e09a9ap-53L, 1.0168910106364605304135563536838075568606e-30L, 0.8208373755522359859870890246475340086663L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(clog, 0x1367a310575591p-54L, 0x3cfcc0a0541f60p-54L, 5.0844550531823026520677817684239496041087e-32L, 1.2627468605458094918919206628466016525397L, 0|XFAIL_NATIVE_LINUX },
#endif
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	TEST_c_c(clog, 0x298c62cb546588a7p-63L, 0x7911b1dfcc4ecdaep-63L, -1.1931267660846218205882675852805793644095e-36L, 1.2402109774337032400594953899784058127412L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(clog, 0x4d9c37e2b5cb4533p-63L, 0x65c98be2385a042ep-63L, 6.4064442119814669184296141278612389400075e-37L, 0.9193591364645830864185131402313014890145L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(clog, 0x602fd5037c4792efp-64L, 0xed3e2086dcca80b8p-64L, -2.3362950222592964220878638677292132852104e-37L, 1.1856121127236268105413184264288408265852L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(clog, 0x6b10b4f3520217b6p-64L, 0xe8893cbb449253a1p-64L, 2.4244570985709679851855191080208817099132e-37L, 1.1393074519572050614551047548718495655972L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(clog, 0x81b7efa81fc35ad1p-65L, 0x1ef4b835f1c79d812p-65L, -9.9182335850630508484862145328126979066934e-39L, 1.3146479888794807046338799047003947008804L, 0|XFAIL_NATIVE_LINUXL },
#endif
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 106
	TEST_c_c(clog, 0x3f96469050f650869c2p-75L, 0x6f16b2c9c8b05988335p-75L, -1.0509738482436128031927971874674370984602e-45L, 1.0509191467640012308402149909370784281448L, 0 },
	TEST_c_c(clog, 0x3157fc1d73233e580c8p-75L, 0x761b52ccd435d7c7f5fp-75L, 1.3487497719126364307640897239165442763573e-43L, 1.1750493008528425228929764149024375035382L, 0 },
	TEST_c_c(clog, 0x155f8afc4c48685bf63610p-85L, 0x17d0cf2652cdbeb1294e19p-85L, -4.7775669192897997174762089350332738583822e-50L, 0.8393953487996880419413728440067635213372L, 0 },
	TEST_c_c(clog, 0x13836d58a13448d750b4b9p-85L, 0x195ca7bc3ab4f9161edbe6p-85L, 2.8398125044729578740243199963484494962411e-50L, 0.9149964976334130461795060758257083099706L, 0 },
	TEST_c_c(clog, 0x1df515eb171a808b9e400266p-95L, 0x7c71eb0cd4688dfe98581c77p-95L, -3.5048022044913950094635368750889659723004e-57L, 1.3345633256521815205858155673950177421079L, 0 },
	TEST_c_c(clog, 0xe33f66c9542ca25cc43c867p-95L, 0x7f35a68ebd3704a43c465864p-95L, 4.1101771307217268747345114262406964584250e-56L, 1.4596065864518742494094402406719567059585L, 0 },
	TEST_c_c(clog, 0x6771f22c64ed551b857c128b4cp-105L, 0x1f570e7a13cc3cf2f44fd793ea1p-105L, -1.4281333889622737316199756373421183559948e-62L, 1.3673546561165378090903506783353927980633L, 0 },
	TEST_c_c(clog, 0x15d8ab6ed05ca514086ac3a1e84p-105L, 0x1761e480aa094c0b10b34b09ce9p-105L, 1.0027319539522347477331743836657426754857e-62L, 0.8193464073721167323313606647411269414759L, 0 },
	TEST_c_c(clog, 0x187190c1a334497bdbde5a95f48p-106L, 0x3b25f08062d0a095c4cfbbc338dp-106L, -1.7471844652198029695350765775994001163767e-63L, 1.1789110097072986038243729592318526094314L, 0 },
	TEST_c_c(clog, 0x6241ef0da53f539f02fad67dabp-106L, 0x3fb46641182f7efd9caa769dac0p-106L, 4.3299788920664682288477984749202524623248e-63L, 1.4746938237585656250866370987773473745867L, 0 },
#endif
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 113
	TEST_c_c(clog, 0x3e1d0a105ac4ebeacd9c6952d34cp-112L, 0xf859b3d1b06d005dcbb5516d5479p-112L, -1.1683999374665377365054966073875064467108e-66L, 1.3257197596350832748781065387304444940172L, 0 },
	TEST_c_c(clog, 0x47017a2e36807acb1e5214b209dep-112L, 0xf5f4a550c9d75e3bb1839d865f0dp-112L, 1.5077923002544367932999503838191154621839e-65L, 1.2897445708311412721399861948957141824914L, 0 },
	TEST_c_c(clog, 0x148f818cb7a9258fca942ade2a0cap-113L, 0x18854a34780b8333ec53310ad7001p-113L, -7.1865869169568789348552370692485515571497e-67L, 0.8730167479365994646287897223471819363668L, 0 },
	TEST_c_c(clog, 0xfd95243681c055c2632286921092p-113L, 0x1bccabcd29ca2152860ec29e34ef7p-113L, 6.6255694866654064502633121109394710807528e-66L, 1.0526409614996288387567810726095850312049L, 0 },
	TEST_c_c(clog, 0xdb85c467ee2aadd5f425fe0f4b8dp-114L, 0x3e83162a0f95f1dcbf97dddf410eap-114L, 4.6017338806965821566734340588575402712716e-67L, 1.3547418904611758959096647942223384691728L, 0 },
	TEST_c_c(clog, 0x1415bcaf2105940d49a636e98ae59p-115L, 0x7e6a150adfcd1b0921d44b31f40f4p-115L, 2.5993421227864195179698176012564317527271e-67L, 1.4132318089683022770487383611430906982461L, 0 },
#endif
}


static void test_clog10(void)
{
	struct test *testp = lookup("clog10" },

	TEST_c_c(clog10, ZERO_M, 0, INF_M, M_PIl, DIVIDE_BY_ZERO_EXCEPTION },
	TEST_c_c(clog10, ZERO_M, ZERO_M, INF_M, -M_PIl, DIVIDE_BY_ZERO_EXCEPTION },

	TEST_c_c(clog10, 0, 0, INF_M, 0.0, DIVIDE_BY_ZERO_EXCEPTION },
	TEST_c_c(clog10, 0, ZERO_M, INF_M, ZERO_M, DIVIDE_BY_ZERO_EXCEPTION },

	TEST_c_c(clog10, INF_M, INF_P, INF_P, M_PI_34_LOG10El, 0 },

	TEST_c_c(clog10, INF_P, INF_P, INF_P, M_PI4_LOG10El, 0 },
	TEST_c_c(clog10, INF_P, INF_M, INF_P, -M_PI4_LOG10El, 0 },

	TEST_c_c(clog10, 0, INF_P, INF_P, M_PI2_LOG10El, 0 },
	TEST_c_c(clog10, 3, INF_P, INF_P, M_PI2_LOG10El, 0 },
	TEST_c_c(clog10, ZERO_M, INF_P, INF_P, M_PI2_LOG10El, 0 },
	TEST_c_c(clog10, -3, INF_P, INF_P, M_PI2_LOG10El, 0 },
	TEST_c_c(clog10, 0, INF_M, INF_P, -M_PI2_LOG10El, 0 },
	TEST_c_c(clog10, 3, INF_M, INF_P, -M_PI2_LOG10El, 0 },
	TEST_c_c(clog10, ZERO_M, INF_M, INF_P, -M_PI2_LOG10El, 0 },
	TEST_c_c(clog10, -3, INF_M, INF_P, -M_PI2_LOG10El, 0 },

	TEST_c_c(clog10, INF_M, 0, INF_P, M_PI_LOG10El, 0 },
	TEST_c_c(clog10, INF_M, 1, INF_P, M_PI_LOG10El, 0 },
	TEST_c_c(clog10, INF_M, ZERO_M, INF_P, -M_PI_LOG10El, 0 },
	TEST_c_c(clog10, INF_M, -1, INF_P, -M_PI_LOG10El, 0 },

	TEST_c_c(clog10, INF_P, 0, INF_P, 0.0, 0 },
	TEST_c_c(clog10, INF_P, 1, INF_P, 0.0, 0 },
	TEST_c_c(clog10, INF_P, ZERO_M, INF_P, ZERO_M, 0 },
	TEST_c_c(clog10, INF_P, -1, INF_P, ZERO_M, 0 },

	TEST_c_c(clog10, INF_P, QNAN_P, INF_P, QNAN_P, 0 },
	TEST_c_c(clog10, INF_M, QNAN_P, INF_P, QNAN_P, 0 },

	TEST_c_c(clog10, QNAN_P, INF_P, INF_P, QNAN_P, 0 },
	TEST_c_c(clog10, QNAN_P, INF_M, INF_P, QNAN_P, 0 },

	TEST_c_c(clog10, 0, QNAN_P, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	TEST_c_c(clog10, 3, QNAN_P, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	TEST_c_c(clog10, ZERO_M, QNAN_P, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	TEST_c_c(clog10, -3, QNAN_P, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },

	TEST_c_c(clog10, QNAN_P, 0, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	TEST_c_c(clog10, QNAN_P, 5, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	TEST_c_c(clog10, QNAN_P, ZERO_M, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	TEST_c_c(clog10, QNAN_P, -5, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },

	TEST_c_c(clog10, QNAN_P, QNAN_P, QNAN_P, QNAN_P, 0 },

	TEST_c_c(clog10, 0.75L, 1.25L, 0.163679467193165171449476605077428975L, 0.447486970040493067069984724340855636L, 0 },
	TEST_c_c(clog10, -2, -3, 0.556971676153418384603252578971164214L, -0.937554462986374708541507952140189646L, 0 },

	TEST_c_c(clog10, 0x1.fffffep+127L, 0x1.fffffep+127L, 38.68235441693561449174780668781319348761L, M_PI4_LOG10El, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(clog10, 0x1.fffffep+127L, 1.0L, 38.53183941910362389414093724045094697423L, 1.276276851248440096917018665609900318458e-39L, UNDERFLOW_EXCEPTION_FLOAT },
	TEST_c_c(clog10, 0x1p-149L, 0x1p-149L, -44.70295435610120748924022586658721447508L, M_PI4_LOG10El, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(clog10, 0x1p-147L, 0x1p-147L, -44.10089436477324509881274807713822842154L, M_PI4_LOG10El, 0|XFAIL_NATIVE_LINUXF },

#ifndef TEST_FLOAT
	TEST_c_c(clog10, 0x1.fffffffffffffp+1023L, 0x1.fffffffffffffp+1023L, 308.4052305577487344482591243175787477115L, M_PI4_LOG10El, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(clog10, 0x1.fffffffffffffp+1023L, 0x1p+1023L, 308.3031705664207720674749211936626341569L, 0.2013595981366865903254995612594728746470L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(clog10, 0x1p-1074L, 0x1p-1074L, -323.1557003452838130619487034867432642357L, M_PI4_LOG10El, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(clog10, 0x1p-1073L, 0x1p-1073L, -322.8546703496198318667349645920187712089L, M_PI4_LOG10El, 0|XFAIL_NATIVE_LINUX },
#endif

#if defined TEST_LDOUBLE && LDBL_MAX_EXP >= 16384
	TEST_c_c(clog10, 0x1.fp+16383L, 0x1.fp+16383L, 4932.212175672014259683102930239951947672L, M_PI4_LOG10El, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(clog10, 0x1.fp+16383L, 0x1p+16383L, 4932.112944269463028900262609694408579449L, 0.2069271710841128115912940666587802677383L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(clog10, 0x1p-16440L, 0x1p-16441L, -4948.884673709346821106688037612752099609L, 0.2013595981366865710389502301937289472543L, 0|XFAIL_NATIVE_LINUXL },
#endif

	TEST_c_c(clog10, 0x1p-149L, 0x1.fp+127L, 38.51805116050395969095658815123105801479L, 0.6821881769209206737428918127156778851051L, 0 },
	TEST_c_c(clog10, -0x1p-149L, 0x1.fp+127L, 38.51805116050395969095658815123105801479L, 0.6821881769209206737428918127156778851051L, 0 },
	TEST_c_c(clog10, 0x1p-149L, -0x1.fp+127L, 38.51805116050395969095658815123105801479L, -0.6821881769209206737428918127156778851051L, 0 },
	TEST_c_c(clog10, -0x1p-149L, -0x1.fp+127L, 38.51805116050395969095658815123105801479L, -0.6821881769209206737428918127156778851051L, 0 },
	TEST_c_c(clog10, -0x1.fp+127L, 0x1p-149L, 38.51805116050395969095658815123105801479L, 1.364376353841841347485783625431355770210L, 0 },
	TEST_c_c(clog10, -0x1.fp+127L, -0x1p-149L, 38.51805116050395969095658815123105801479L, -1.364376353841841347485783625431355770210L, 0 },
#ifdef TEST_FLOAT
	TEST_c_c(clog10, 0x1.fp+127L, 0x1p-149L, 38.51805116050395969095658815123105801479L, ZERO_P, UNDERFLOW_EXCEPTION },
	TEST_c_c(clog10, 0x1.fp+127L, -0x1p-149L, 38.51805116050395969095658815123105801479L, ZERO_M, UNDERFLOW_EXCEPTION },
#endif

#ifndef TEST_FLOAT
	TEST_c_c(clog10, 0x1p-1074L, 0x1.fp+1023L, 308.2409272754311106024666378243768099991L, 0.6821881769209206737428918127156778851051L, 0 },
	TEST_c_c(clog10, -0x1p-1074L, 0x1.fp+1023L, 308.2409272754311106024666378243768099991L, 0.6821881769209206737428918127156778851051L, 0 },
	TEST_c_c(clog10, 0x1p-1074L, -0x1.fp+1023L, 308.2409272754311106024666378243768099991L, -0.6821881769209206737428918127156778851051L, 0 },
	TEST_c_c(clog10, -0x1p-1074L, -0x1.fp+1023L, 308.2409272754311106024666378243768099991L, -0.6821881769209206737428918127156778851051L, 0 },
	TEST_c_c(clog10, -0x1.fp+1023L, 0x1p-1074L, 308.2409272754311106024666378243768099991L, 1.364376353841841347485783625431355770210L, 0 },
	TEST_c_c(clog10, -0x1.fp+1023L, -0x1p-1074L, 308.2409272754311106024666378243768099991L, -1.364376353841841347485783625431355770210L, 0 },
#endif
#if defined TEST_DOUBLE || (defined TEST_LDOUBLE && LDBL_MAX_EXP == 1024)
	TEST_c_c(clog10, 0x1.fp+1023L, 0x1p-1074L, 308.2409272754311106024666378243768099991L, ZERO_P, UNDERFLOW_EXCEPTION },
	TEST_c_c(clog10, 0x1.fp+1023L, -0x1p-1074L, 308.2409272754311106024666378243768099991L, ZERO_M, UNDERFLOW_EXCEPTION },
#endif

#if defined TEST_LDOUBLE && LDBL_MAX_EXP >= 16384
	TEST_c_c(clog10, 0x1p-16445L, 0x1.fp+16383L, 4932.061660674182269085496060792589701158L, 0.6821881769209206737428918127156778851051L, 0 },
	TEST_c_c(clog10, -0x1p-16445L, 0x1.fp+16383L, 4932.061660674182269085496060792589701158L, 0.6821881769209206737428918127156778851051L, 0 },
	TEST_c_c(clog10, 0x1p-16445L, -0x1.fp+16383L, 4932.061660674182269085496060792589701158L, -0.6821881769209206737428918127156778851051L, 0 },
	TEST_c_c(clog10, -0x1p-16445L, -0x1.fp+16383L, 4932.061660674182269085496060792589701158L, -0.6821881769209206737428918127156778851051L, 0 },
	TEST_c_c(clog10, -0x1.fp+16383L, 0x1p-16445L, 4932.061660674182269085496060792589701158L, 1.364376353841841347485783625431355770210L, 0 },
	TEST_c_c(clog10, -0x1.fp+16383L, -0x1p-16445L, 4932.061660674182269085496060792589701158L, -1.364376353841841347485783625431355770210L, 0 },
	TEST_c_c(clog10, 0x1.fp+16383L, 0x1p-16445L, 4932.061660674182269085496060792589701158L, ZERO_P, UNDERFLOW_EXCEPTION },
	TEST_c_c(clog10, 0x1.fp+16383L, -0x1p-16445L, 4932.061660674182269085496060792589701158L, ZERO_M, UNDERFLOW_EXCEPTION },
# if LDBL_MANT_DIG >= 113
	TEST_c_c(clog10, 0x1p-16494L, 0x1.fp+16383L, 4932.061660674182269085496060792589701158L, 0.6821881769209206737428918127156778851051L, 0 },
	TEST_c_c(clog10, -0x1p-16494L, 0x1.fp+16383L, 4932.061660674182269085496060792589701158L, 0.6821881769209206737428918127156778851051L, 0 },
	TEST_c_c(clog10, 0x1p-16494L, -0x1.fp+16383L, 4932.061660674182269085496060792589701158L, -0.6821881769209206737428918127156778851051L, 0 },
	TEST_c_c(clog10, -0x1p-16494L, -0x1.fp+16383L, 4932.061660674182269085496060792589701158L, -0.6821881769209206737428918127156778851051L, 0 },
	TEST_c_c(clog10, -0x1.fp+16383L, 0x1p-16494L, 4932.061660674182269085496060792589701158L, 1.364376353841841347485783625431355770210L, 0 },
	TEST_c_c(clog10, -0x1.fp+16383L, -0x1p-16494L, 4932.061660674182269085496060792589701158L, -1.364376353841841347485783625431355770210L, 0 },
	TEST_c_c(clog10, 0x1.fp+16383L, 0x1p-16494L, 4932.061660674182269085496060792589701158L, ZERO_P, UNDERFLOW_EXCEPTION },
	TEST_c_c(clog10, 0x1.fp+16383L, -0x1p-16494L, 4932.061660674182269085496060792589701158L, ZERO_M, UNDERFLOW_EXCEPTION },
# endif
#endif

	TEST_c_c(clog10, 1.0L, 0x1.234566p-10L, 2.680828048441605163181684680300513080769e-7L, 4.825491868832381486767558728169977751564e-4L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(clog10, -1.0L, 0x1.234566p-20L, 2.556638434669064077889576526006849923281e-13L, 1.364375882602207106407956770293808181427L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(clog10, 0x1.234566p-30L, 1.0L, 2.438200411482400072282924063740535840474e-19L, 6.821881764607257184291586401763604544928e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(clog10, -0x1.234566p-40L, -1.0L, 2.325249110681915353442924915876654139373e-25L, -6.821881769213700828789403802671540158935e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(clog10, 0x1.234566p-50L, 1.0L, 2.217530356103816369479108963807448194409e-31L, 6.821881769209202348667823902864283966959e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(clog10, 0x1.234566p-60L, 1.0L, 2.114801746467415208319767917450504756866e-37L, 6.821881769209206733143018621078368211515e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(clog10, 0x1p-61L, 1.0L, 4.084085680564517578238994467153626207224e-38L, 6.821881769209206735545466044044889962925e-1L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(clog10, 0x1p-62L, 1.0L, 1.021021420141129394559748616788406551878e-38L, 6.821881769209206736487192085600834406988e-1L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
	TEST_c_c(clog10, 0x1p-63L, 1.0L, 2.552553550352823486399371541971016379740e-39L, 6.821881769209206736958055106378806629019e-1L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUX },
#ifndef TEST_FLOAT
	TEST_c_c(clog10, 0x1p-509L, 1.0L, 7.730698388614835910296270976605350994446e-308L, 6.821881769209206737428918127156778851051e-1L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM|XFAIL_NATIVE_LINUX },
	TEST_c_c(clog10, 0x1p-510L, 1.0L, 1.932674597153708977574067744151337748612e-308L, 6.821881769209206737428918127156778851051e-1L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
	TEST_c_c(clog10, 0x1p-511L, 1.0L, 4.831686492884272443935169360378344371529e-309L, 6.821881769209206737428918127156778851051e-1L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
#endif
#if defined TEST_LDOUBLE && LDBL_MAX_EXP >= 16384
	TEST_c_c(clog10, 0x1p-8189L, 1.0L, 1.168114274114528946314738738025008370069e-4931L, 6.821881769209206737428918127156778851051e-1L, UNDERFLOW_EXCEPTION_OK|XFAIL_NATIVE_LINUXL },
	TEST_c_c(clog10, 0x1p-8190L, 1.0L, 2.920285685286322365786846845062520925172e-4932L, 6.821881769209206737428918127156778851051e-1L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(clog10, 0x1p-8191L, 1.0L, 7.300714213215805914467117112656302312931e-4933L, 6.821881769209206737428918127156778851051e-1L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
#endif

	TEST_c_c(clog10, 0x1.000566p0L, 0x1.234p-10L, 3.604093470239754109961125085078190708674e-5L, 4.824745078422174667425851670822596859720e-4L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(clog10, 0x1.000566p0L, 0x1.234p-100L, 3.577293486783822178310971763308187385546e-5L, 3.897399639875661463735636919790792140598e-31L, 0 },
#ifndef TEST_FLOAT
	TEST_c_c(clog10, -0x1.0000000123456p0L, 0x1.2345678p-30L, 1.150487028947346337782682105935961875822e-10L, 1.364376353381646356131680448946397884147L, 0 },
	TEST_c_c(clog10, -0x1.0000000123456p0L, 0x1.2345678p-1000L, 1.150487026509145544402795327729455391948e-10L, 1.364376353841841347485783625431355770210L, 0 },
#endif
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 106
	TEST_c_c(clog10, 0x1.00000000000000123456789abcp0L, 0x1.23456789p-60L, 4.285899851347756188767674032946882584784e-19L, 4.285899850759344225805480528847018395861e-19L, 0 },
	TEST_c_c(clog10, 0x1.00000000000000123456789abcp0L, 0x1.23456789p-1000L, 4.285899851347756186652871946325962330640e-19L, 4.611541215247321502041995872887317363241e-302L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM },
#endif

	TEST_c_c(clog10, 0x0.ffffffp0L, 0x0.ffffffp-100L, -2.588596909321764128428416045209904492216e-8L, 3.425979381266895667295625489912064603415e-31L, 0 },
#ifndef TEST_FLOAT
	TEST_c_c(clog10, 0x0.fffffffffffff8p0L, 0x0.fffffffffffff8p-1000L, -4.821637332766435821255375046554377090472e-17L, 4.053112396770095089737411317782466262176e-302L, UNDERFLOW_EXCEPTION_LDOUBLE_IBM },
#endif
#if defined TEST_LDOUBLE && LDBL_MIN_EXP <= -16381
	TEST_c_c(clog10, 0x0.ffffffffffffffffp0L, 0x0.ffffffffffffffffp-15000L, -2.354315103889861110220423157644627849164e-20L, 1.541165759405643564697852372112893034397e-4516L, 0 },
#endif

	TEST_c_c(clog10, 0x1a6p-10L, 0x3a5p-10L, -6.2126412844802358329771948751248003038444e-07L, 0.4977135139537443711784513409096950995985L, 0 },
	TEST_c_c(clog10, 0xf2p-10L, 0x3e3p-10L, 2.6921240173351112953324592659528481616879e-06L, 0.5785726025799636431142862788413361783862L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(clog10, 0x4d4ep-15L, 0x6605p-15L, -7.0781945783414996953799915941870192015212e-09L, 0.4005747524909781155537088181659175147564L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(clog10, 0x2818p-15L, 0x798fp-15L, 6.6737261053986614395049481326819059203910e-09L, 0.5438241985991753781478398141908629586460L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(clog10, 0x9b57bp-20L, 0xcb7b4p-20L, -1.7182001068739620267773842120965071561416e-11L, 0.3990121149225253562859800593935899629087L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(clog10, 0x2731p-20L, 0xfffd0p-20L, 1.9156943718715958194239364991329064049438e-11L, 0.6780326907904082601285090019969008967595L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(clog10, 0x2ede88p-23L, 0x771c3fp-23L, -1.9440841725722970687903291200493082253766e-13L, 0.5193774116724956222518530053006822210323L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(clog10, 0x11682p-23L, 0x7ffed1p-23L, 5.0916490233953865181284669870035717560498e-13L, 0.6784968969384861816694467029319146542069L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(clog10, 0xa1f2c1p-24L, 0xc643aep-24L, -4.5516256421319921959681423447271490869664e-14L, 0.3847315790697197749315054516562206543710L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(clog10, 0x659feap-24L, 0xeaf6f9p-24L, 1.6200701438094619117335617123525612051457e-14L, 0.5049027913635038013499728086604870749732L, 0|XFAIL_NATIVE_LINUXF },
#ifndef TEST_FLOAT
	/* disabled because real result is close to zero, but not exactly determinable */
#ifndef TEST_DOUBLE
	TEST_c_c(clog10, 0x4447d7175p-35L, 0x6c445e00ap-35L, -6.4375803621988389731799033530075237868110e-21L, 0.4378257977686804492768642780897650927167L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(clog10, 0x2dd46725bp-35L, 0x7783a1284p-35L, 1.9312741086596516918394613098872836703188e-20L, 0.5231613813514771042838490538484014771862L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(clog10, 0x55cb6d0c83af5p-55L, 0x7fe33c0c7c4e90p-55L, -2.2583360179249556400630343805573865814771e-32L, 0.6639894257763289307423302343317622430835L, 0|XFAIL_NATIVE_LINUX },
#endif
	TEST_c_c(clog10, 0x164c74eea876p-45L, 0x16f393482f77p-45L, -1.3155760824064879362415202279780039150764e-26L, 0.3473590599762514228227328130640352044313L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(clog10, 0xfe961079616p-45L, 0x1bc37e09e6d1p-45L, 2.3329549194675052736016290082882121135546e-26L, 0.4561756099441139182878993697611751382976L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(clog10, 0xa4722f19346cp-51L, 0x7f9631c5e7f07p-51L, -2.6979587627476803379953050733225113494503e-30L, 0.6472785229986997177606324374555347813105L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(clog10, 0x10673dd0f2481p-51L, 0x7ef1d17cefbd2p-51L, 1.3918041236396763648388478552321724382899e-29L, 0.6263795733790237053262025311642907438291L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(clog10, 0x8ecbf810c4ae6p-52L, 0xd479468b09a37p-52L, -4.2289432987513243393180377141513840878196e-30L, 0.4252020027092323591068799049905597805296L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(clog10, 0x5b06b680ea2ccp-52L, 0xef452b965da9fp-52L, 3.6079845358966994996207055940336690133424e-30L, 0.5243112258263349992771652393178033846555L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(clog10, 0x659b70ab7971bp-53L, 0x1f5d111e08abecp-53L, -1.0893543813872082317104059174982092534059e-30L, 0.5954257879188711495921161433751775633232L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(clog10, 0x15cfbd1990d1ffp-53L, 0x176a3973e09a9ap-53L, 4.4163015461643576961232672330852798804976e-31L, 0.3564851427422832755956993418877523303529L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(clog10, 0x1367a310575591p-54L, 0x3cfcc0a0541f60p-54L, 2.2081507730821788480616336165447731164865e-32L, 0.5484039935757001196548030312819898864760L, 0|XFAIL_NATIVE_LINUX },
#endif
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 64
	TEST_c_c(clog10, 0x298c62cb546588a7p-63L, 0x7911b1dfcc4ecdaep-63L, -5.1816837072162316773907242302011632570857e-37L, 0.5386167838952956925896424154370364458140L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(clog10, 0x4d9c37e2b5cb4533p-63L, 0x65c98be2385a042ep-63L, 2.7822833698845776001753149807484078521508e-37L, 0.3992725998539071066769046272515417679815L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(clog10, 0x602fd5037c4792efp-64L, 0xed3e2086dcca80b8p-64L, -1.0146400362652473358437501879334790111898e-37L, 0.5149047982335273098246594109614460842099L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(clog10, 0x6b10b4f3520217b6p-64L, 0xe8893cbb449253a1p-64L, 1.0529283395205396881397407610630442563938e-37L, 0.4947949395762683446121140513971996916447L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(clog10, 0x81b7efa81fc35ad1p-65L, 0x1ef4b835f1c79d812p-65L, -4.3074341162203896332989394770760901408798e-39L, 0.5709443672155660428417571212549720987784L, 0|XFAIL_NATIVE_LINUXL },
#endif
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 106
	TEST_c_c(clog10, 0x3f96469050f650869c2p-75L, 0x6f16b2c9c8b05988335p-75L, -4.5643214291682663316715446865040356750881e-46L, 0.4564083863660793840592614609053162690362L, 0 },
	TEST_c_c(clog10, 0x3157fc1d73233e580c8p-75L, 0x761b52ccd435d7c7f5fp-75L, 5.8575458340992751256451490143468457830297e-44L, 0.5103174273246635294300470585396890237265L, 0 },
	TEST_c_c(clog10, 0x155f8afc4c48685bf63610p-85L, 0x17d0cf2652cdbeb1294e19p-85L, -2.0748709499710785084693619097712106753591e-50L, 0.3645447681189598740620098186365764884771L, 0 },
	TEST_c_c(clog10, 0x13836d58a13448d750b4b9p-85L, 0x195ca7bc3ab4f9161edbe6p-85L, 1.2333149003324592532859843519619084433953e-50L, 0.3973779298829931059309198145608711073016L, 0 },
	TEST_c_c(clog10, 0x1df515eb171a808b9e400266p-95L, 0x7c71eb0cd4688dfe98581c77p-95L, -1.5221162575729652613635150540947625639689e-57L, 0.5795934880811949230121092882659698986043L, 0 },
	TEST_c_c(clog10, 0xe33f66c9542ca25cc43c867p-95L, 0x7f35a68ebd3704a43c465864p-95L, 1.7850272475173865337808494725293124613817e-56L, 0.6338990862456906754888183278564382516852L, 0 },
	TEST_c_c(clog10, 0x6771f22c64ed551b857c128b4cp-105L, 0x1f570e7a13cc3cf2f44fd793ea1p-105L, -6.2023045024810589256360494043570293518879e-63L, 0.5938345819561308555003145899438513900776L, 0 },
	TEST_c_c(clog10, 0x15d8ab6ed05ca514086ac3a1e84p-105L, 0x1761e480aa094c0b10b34b09ce9p-105L, 4.3548095442952115860848857519953610343042e-63L, 0.3558376234889641500775150477035448866763L, 0 },
	TEST_c_c(clog10, 0x187190c1a334497bdbde5a95f48p-106L, 0x3b25f08062d0a095c4cfbbc338dp-106L, -7.5879257211204444302994221436282805900756e-64L, 0.5119945461708707332160859198685423099187L, 0 },
	TEST_c_c(clog10, 0x6241ef0da53f539f02fad67dabp-106L, 0x3fb46641182f7efd9caa769dac0p-106L, 1.8804859395820231849002915747252695375405e-63L, 0.6404513901551516189871978418046651877394L, 0 },
#endif
#if defined TEST_LDOUBLE && LDBL_MANT_DIG >= 113
	TEST_c_c(clog10, 0x3e1d0a105ac4ebeacd9c6952d34cp-112L, 0xf859b3d1b06d005dcbb5516d5479p-112L, -5.0742964549782184008668435276046798273476e-67L, 0.5757527761596220360985719127090110408283L, 0 },
	TEST_c_c(clog10, 0x47017a2e36807acb1e5214b209dep-112L, 0xf5f4a550c9d75e3bb1839d865f0dp-112L, 6.5482587585671294601662599808612773010057e-66L, 0.5601289501766423782280643144987875760229L, 0 },
	TEST_c_c(clog10, 0x148f818cb7a9258fca942ade2a0cap-113L, 0x18854a34780b8333ec53310ad7001p-113L, -3.1210950417524756037077807411854181477733e-67L, 0.3791463562379872585396164879981280044658L, 0 },
	TEST_c_c(clog10, 0xfd95243681c055c2632286921092p-113L, 0x1bccabcd29ca2152860ec29e34ef7p-113L, 2.8774482675253468630312378575186855052697e-66L, 0.4571561610046221605554903008571429975493L, 0 },
	TEST_c_c(clog10, 0xdb85c467ee2aadd5f425fe0f4b8dp-114L, 0x3e83162a0f95f1dcbf97dddf410eap-114L, 1.9985076315737626043096596036300177494613e-67L, 0.5883569274304683249184005177865521205198L, 0 },
	TEST_c_c(clog10, 0x1415bcaf2105940d49a636e98ae59p-115L, 0x7e6a150adfcd1b0921d44b31f40f4p-115L, 1.1288799405048268615023706955013387413519e-67L, 0.6137587762850841972073301550420510507903L, 0 },
#endif
}


static void test_conj(void)
{
	struct test *testp = lookup("conj" },

	TEST_c_c(conj, 0.0, 0.0, 0.0, ZERO_M, NO_INEXACT_EXCEPTION },
	TEST_c_c(conj, 0.0, ZERO_M, 0.0, 0.0, NO_INEXACT_EXCEPTION },
	TEST_c_c(conj, QNAN_P, QNAN_P, QNAN_P, QNAN_P, NO_INEXACT_EXCEPTION },
	TEST_c_c(conj, INF_P, INF_M, INF_P, INF_P, NO_INEXACT_EXCEPTION },
	TEST_c_c(conj, INF_P, INF_P, INF_P, INF_M, NO_INEXACT_EXCEPTION },
	TEST_c_c(conj, 1.0, 2.0, 1.0, -2.0, NO_INEXACT_EXCEPTION },
	TEST_c_c(conj, 3.0, -4.0, 3.0, 4.0, NO_INEXACT_EXCEPTION },
}


static void test_cproj(void)
{
	struct test *testp = lookup("cproj" },

	TEST_c_c(cproj, 0.0, 0.0, 0.0, 0.0, NO_INEXACT_EXCEPTION },
	TEST_c_c(cproj, ZERO_M, ZERO_M, ZERO_M, ZERO_M, NO_INEXACT_EXCEPTION },
	TEST_c_c(cproj, 0.0, ZERO_M, 0.0, ZERO_M, NO_INEXACT_EXCEPTION },
	TEST_c_c(cproj, ZERO_M, 0.0, ZERO_M, 0.0, NO_INEXACT_EXCEPTION },

	TEST_c_c(cproj, QNAN_P, QNAN_P, QNAN_P, QNAN_P, NO_INEXACT_EXCEPTION },

	TEST_c_c(cproj, INF_P, INF_P, INF_P, 0.0, NO_INEXACT_EXCEPTION },
	TEST_c_c(cproj, INF_P, INF_M, INF_P, ZERO_M, NO_INEXACT_EXCEPTION },
	TEST_c_c(cproj, INF_M, INF_P, INF_P, 0.0, NO_INEXACT_EXCEPTION },
	TEST_c_c(cproj, INF_M, INF_M, INF_P, ZERO_M, NO_INEXACT_EXCEPTION },

	TEST_c_c(cproj, 1.0, 0.0, 1.0, 0.0, NO_INEXACT_EXCEPTION },
	TEST_c_c(cproj, 2.0, 3.0, 2.0, 3.0, NO_INEXACT_EXCEPTION|XFAIL_NATIVE_LINUX },
}


static void test_csin(void)
{
	struct test *testp = lookup("csin" },

	TEST_c_c(csin, 1.0e00, 2.0e00, 3.165778547525405883e00, 1.959601044654846191e00, 0 },
	TEST_c_c(csin, 0.0e00, 2.0e00, 0.0e00, 3.626860409975051879e00, 0 },
	TEST_c_c(csin, 1.0e00, 0.0e00, 8.414709866046905517e-01, 0.0e00, 0 },
	TEST_c_c(csin, -2.0e00, 2.0e00, -3.420954853296279907e00, -1.509306490421295166e00, 0 },
	TEST_c_c(csin, -1.0e00, -2.0e00, -3.165778547525405883e00, -1.959601044654846191e00, 0 },
	TEST_c_c(csin, 1.0e00, -2.0e00, 3.165778547525405883e00, -1.959601044654846191e00, 0 },

	TEST_c_c(csin, 0.0, 0.0, 0.0, 0.0, 0 },
	TEST_c_c(csin, ZERO_M, 0.0, ZERO_M, 0.0, 0 },
	TEST_c_c(csin, 0.0, ZERO_M, 0, ZERO_M, 0 },
	TEST_c_c(csin, ZERO_M, ZERO_M, ZERO_M, ZERO_M, 0 },

	TEST_c_c(csin, 0.0, INF_P, 0.0, INF_P, 0 },
	TEST_c_c(csin, ZERO_M, INF_P, ZERO_M, INF_P, 0 },
	TEST_c_c(csin, 0.0, INF_M, 0.0, INF_M, 0 },
	TEST_c_c(csin, ZERO_M, INF_M, ZERO_M, INF_M, 0 },

	TEST_c_c(csin, INF_P, 0.0, QNAN_P, 0.0, INVALID_EXCEPTION|IGNORE_ZERO_INF_SIGN },
	TEST_c_c(csin, INF_M, 0.0, QNAN_P, 0.0, INVALID_EXCEPTION|IGNORE_ZERO_INF_SIGN },
	TEST_c_c(csin, INF_P, ZERO_M, QNAN_P, 0.0, INVALID_EXCEPTION|IGNORE_ZERO_INF_SIGN },
	TEST_c_c(csin, INF_M, ZERO_M, QNAN_P, 0.0, INVALID_EXCEPTION|IGNORE_ZERO_INF_SIGN },

	TEST_c_c(csin, INF_P, INF_P, QNAN_P, INF_P, INVALID_EXCEPTION|IGNORE_ZERO_INF_SIGN },
	TEST_c_c(csin, INF_M, INF_P, QNAN_P, INF_P, INVALID_EXCEPTION|IGNORE_ZERO_INF_SIGN },
	TEST_c_c(csin, INF_P, INF_M, QNAN_P, INF_P, INVALID_EXCEPTION|IGNORE_ZERO_INF_SIGN },
	TEST_c_c(csin, INF_M, INF_M, QNAN_P, INF_P, INVALID_EXCEPTION|IGNORE_ZERO_INF_SIGN },

	TEST_c_c(csin, INF_P, 6.75, QNAN_P, QNAN_P, INVALID_EXCEPTION },
	TEST_c_c(csin, INF_P, -6.75, QNAN_P, QNAN_P, INVALID_EXCEPTION },
	TEST_c_c(csin, INF_M, 6.75, QNAN_P, QNAN_P, INVALID_EXCEPTION },
	TEST_c_c(csin, INF_M, -6.75,  QNAN_P, QNAN_P, INVALID_EXCEPTION },

	TEST_c_c(csin, 4.625, INF_P, INF_M, INF_M, 0 },
	TEST_c_c(csin, 4.625, INF_M, INF_M, INF_P, 0 },
	TEST_c_c(csin, -4.625, INF_P, INF_P, INF_M, 0 },
	TEST_c_c(csin, -4.625, INF_M, INF_P, INF_P, 0 },

	TEST_c_c(csin, QNAN_P, 0.0, QNAN_P, 0.0, IGNORE_ZERO_INF_SIGN },
	TEST_c_c(csin, QNAN_P, ZERO_M, QNAN_P, 0.0, IGNORE_ZERO_INF_SIGN },

	TEST_c_c(csin, QNAN_P, INF_P, QNAN_P, INF_P, IGNORE_ZERO_INF_SIGN },
	TEST_c_c(csin, QNAN_P, INF_M, QNAN_P, INF_P, IGNORE_ZERO_INF_SIGN },

	TEST_c_c(csin, QNAN_P, 9.0, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	TEST_c_c(csin, QNAN_P, -9.0, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },

	TEST_c_c(csin, 0.0, QNAN_P, 0.0, QNAN_P, 0 },
	TEST_c_c(csin, ZERO_M, QNAN_P, ZERO_M, QNAN_P, 0 },

	TEST_c_c(csin, 10.0, QNAN_P, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	TEST_c_c(csin, QNAN_P, -10.0, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },

	TEST_c_c(csin, INF_P, QNAN_P, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	TEST_c_c(csin, INF_M, QNAN_P, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },

	TEST_c_c(csin, QNAN_P, QNAN_P, QNAN_P, QNAN_P, 0 },

	TEST_c_c(csin, 0.75L, 1.25L, 1.28722291002649188575873510790565441L, 1.17210635989270256101081285116138863L, 0 },
	TEST_c_c(csin, -2, -3, -9.15449914691142957346729954460983256L, 4.16890695996656435075481305885375484L, 0 },

	TEST_c_c(csin, 0.75, 89.5, 2.522786001038096774676288412995370563339e38L, 2.708024460708609732016532185663087200560e38L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(csin, 0.75, -89.5, 2.522786001038096774676288412995370563339e38L, -2.708024460708609732016532185663087200560e38L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(csin, -0.75, 89.5, -2.522786001038096774676288412995370563339e38L, 2.708024460708609732016532185663087200560e38L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(csin, -0.75, -89.5, -2.522786001038096774676288412995370563339e38L, -2.708024460708609732016532185663087200560e38L, 0|XFAIL_NATIVE_LINUXF },

#ifndef TEST_FLOAT
	TEST_c_c(csin, 0.75, 710.5, 1.255317763348154410745082950806112487736e308L, 1.347490911916428129246890157395342279438e308L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(csin, 0.75, -710.5, 1.255317763348154410745082950806112487736e308L, -1.347490911916428129246890157395342279438e308L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(csin, -0.75, 710.5, -1.255317763348154410745082950806112487736e308L, 1.347490911916428129246890157395342279438e308L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(csin, -0.75, -710.5, -1.255317763348154410745082950806112487736e308L, -1.347490911916428129246890157395342279438e308L, 0|XFAIL_NATIVE_LINUX },
#endif

#if defined TEST_LDOUBLE && LDBL_MAX_EXP >= 16384
	TEST_c_c(csin, 0.75, 11357.25, 8.385498349388321535962327491346664141020e4931L, 9.001213196851067077465606717616495588201e4931L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(csin, 0.75, -11357.25, 8.385498349388321535962327491346664141020e4931L, -9.001213196851067077465606717616495588201e4931L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(csin, -0.75, 11357.25, -8.385498349388321535962327491346664141020e4931L, 9.001213196851067077465606717616495588201e4931L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(csin, -0.75, -11357.25, -8.385498349388321535962327491346664141020e4931L, -9.001213196851067077465606717616495588201e4931L, 0|XFAIL_NATIVE_LINUXL },
#endif

#ifdef TEST_FLOAT
	TEST_c_c(csin, 0x1p-149, 180, 1.043535896672617552965983803453927655332e33L, INF_P, OVERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXF },
#endif

#if defined TEST_DOUBLE || (defined TEST_LDOUBLE && LDBL_MAX_EXP == 1024)
	TEST_c_c(csin, 0x1p-1074, 1440, 5.981479269486130556466515778180916082415e301L, INF_P, OVERFLOW_EXCEPTION|XFAIL_NATIVE_LINUX },
#endif

#if defined TEST_LDOUBLE && LDBL_MAX_EXP >= 16384
	TEST_c_c(csin, 0x1p-16434L, 22730, 1.217853148905605987081057582351152052687e4924L, INF_P, OVERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
#endif

	TEST_c_c(csin, SUBNORM_P, MIN_P, SUBNORM_P, MIN_P, UNDERFLOW_EXCEPTION },
	TEST_c_c(csin, MIN_P, SUBNORM_P, MIN_P, SUBNORM_P, UNDERFLOW_EXCEPTION },
}


static void test_csinh(void)
{
	struct test *testp = lookup("csinh" },

	TEST_c_c(csinh, 1.0e00, 2.0e00, -4.890562593936920166e-01, 1.403119236230850219e00, 0 },
	TEST_c_c(csinh, 0.0e00, 2.0e00, -0.0e00, 9.09297426825681709417e-01, 0 },
	TEST_c_c(csinh, 1.0e00, 0.0e00, 1.175201192498207092e00, 0.0e00, 0 },
	TEST_c_c(csinh, -2.0e00, 2.0e00, 1.509306475520133972e00, 3.420954853296279907e00, 0 },
	TEST_c_c(csinh, -1.0e00, -2.0e00, 4.890562593936920166e-01, -1.403119236230850219e00, 0 },
	TEST_c_c(csinh, 1.0e00, -2.0e00, -4.890562593936920166e-01, -1.403119236230850219e00, 0 },

	TEST_c_c(csinh, 0.0, 0.0, 0.0, 0.0, 0 },
	TEST_c_c(csinh, ZERO_M, 0.0, ZERO_M, 0.0, 0 },
	TEST_c_c(csinh, 0.0, ZERO_M, 0.0, ZERO_M, 0 },
	TEST_c_c(csinh, ZERO_M, ZERO_M, ZERO_M, ZERO_M, 0 },

	TEST_c_c(csinh, 0.0, INF_P, 0.0, QNAN_P, INVALID_EXCEPTION|IGNORE_ZERO_INF_SIGN },
	TEST_c_c(csinh, ZERO_M, INF_P, 0.0, QNAN_P, INVALID_EXCEPTION|IGNORE_ZERO_INF_SIGN },
	TEST_c_c(csinh, 0.0, INF_M, 0.0, QNAN_P, INVALID_EXCEPTION|IGNORE_ZERO_INF_SIGN },
	TEST_c_c(csinh, ZERO_M, INF_M, 0.0, QNAN_P, INVALID_EXCEPTION|IGNORE_ZERO_INF_SIGN },

	TEST_c_c(csinh, INF_P, 0.0, INF_P, 0.0, 0 },
	TEST_c_c(csinh, INF_M, 0.0, INF_M, 0.0, 0 },
	TEST_c_c(csinh, INF_P, ZERO_M, INF_P, ZERO_M, 0 },
	TEST_c_c(csinh, INF_M, ZERO_M, INF_M, ZERO_M, 0 },

	TEST_c_c(csinh, INF_P, INF_P, INF_P, QNAN_P, INVALID_EXCEPTION|IGNORE_ZERO_INF_SIGN },
	TEST_c_c(csinh, INF_M, INF_P, INF_P, QNAN_P, INVALID_EXCEPTION|IGNORE_ZERO_INF_SIGN },
	TEST_c_c(csinh, INF_P, INF_M, INF_P, QNAN_P, INVALID_EXCEPTION|IGNORE_ZERO_INF_SIGN },
	TEST_c_c(csinh, INF_M, INF_M, INF_P, QNAN_P, INVALID_EXCEPTION|IGNORE_ZERO_INF_SIGN },

	TEST_c_c(csinh, INF_P, 4.625, INF_M, INF_M, 0 },
	TEST_c_c(csinh, INF_M, 4.625, INF_P, INF_M, 0 },
	TEST_c_c(csinh, INF_P, -4.625, INF_M, INF_P, 0 },
	TEST_c_c(csinh, INF_M, -4.625, INF_P, INF_P, 0 },

	TEST_c_c(csinh, 6.75, INF_P, QNAN_P, QNAN_P, INVALID_EXCEPTION },
	TEST_c_c(csinh, -6.75, INF_P, QNAN_P, QNAN_P, INVALID_EXCEPTION },
	TEST_c_c(csinh, 6.75, INF_M, QNAN_P, QNAN_P, INVALID_EXCEPTION },
	TEST_c_c(csinh, -6.75, INF_M, QNAN_P, QNAN_P, INVALID_EXCEPTION },

	TEST_c_c(csinh, 0.0, QNAN_P, 0.0, QNAN_P, IGNORE_ZERO_INF_SIGN },
	TEST_c_c(csinh, ZERO_M, QNAN_P, 0.0, QNAN_P, IGNORE_ZERO_INF_SIGN },

	TEST_c_c(csinh, INF_P, QNAN_P, INF_P, QNAN_P, IGNORE_ZERO_INF_SIGN },
	TEST_c_c(csinh, INF_M, QNAN_P, INF_P, QNAN_P, IGNORE_ZERO_INF_SIGN },

	TEST_c_c(csinh, 9.0, QNAN_P, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	TEST_c_c(csinh, -9.0, QNAN_P, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },

	TEST_c_c(csinh, QNAN_P, 0.0, QNAN_P, 0.0, 0 },
	TEST_c_c(csinh, QNAN_P, ZERO_M, QNAN_P, ZERO_M, 0 },

	TEST_c_c(csinh, QNAN_P, 10.0, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	TEST_c_c(csinh, QNAN_P, -10.0, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },

	TEST_c_c(csinh, QNAN_P, INF_P, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	TEST_c_c(csinh, QNAN_P, INF_M, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },

	TEST_c_c(csinh, QNAN_P, QNAN_P, QNAN_P, QNAN_P, 0 },

	TEST_c_c(csinh, 0.75L, 1.25L, 0.259294854551162779153349830618433028L, 1.22863452409509552219214606515777594L, 0 },
	TEST_c_c(csinh, -2, -3, 3.59056458998577995201256544779481679L, -0.530921086248519805267040090660676560L, 0 },

	TEST_c_c(csinh, 89.5, 0.75, 2.708024460708609732016532185663087200560e38L, 2.522786001038096774676288412995370563339e38L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(csinh, -89.5, 0.75, -2.708024460708609732016532185663087200560e38L, 2.522786001038096774676288412995370563339e38L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(csinh, 89.5, -0.75, 2.708024460708609732016532185663087200560e38L, -2.522786001038096774676288412995370563339e38L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(csinh, -89.5, -0.75, -2.708024460708609732016532185663087200560e38L, -2.522786001038096774676288412995370563339e38L, 0|XFAIL_NATIVE_LINUXF },

#ifndef TEST_FLOAT
	TEST_c_c(csinh, 710.5, 0.75, 1.347490911916428129246890157395342279438e308L, 1.255317763348154410745082950806112487736e308L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(csinh, -710.5, 0.75, -1.347490911916428129246890157395342279438e308L, 1.255317763348154410745082950806112487736e308L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(csinh, 710.5, -0.75, 1.347490911916428129246890157395342279438e308L, -1.255317763348154410745082950806112487736e308L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(csinh, -710.5, -0.75, -1.347490911916428129246890157395342279438e308L, -1.255317763348154410745082950806112487736e308L, 0|XFAIL_NATIVE_LINUX },
#endif

#if defined TEST_LDOUBLE && LDBL_MAX_EXP >= 16384
	TEST_c_c(csinh, 11357.25, 0.75, 9.001213196851067077465606717616495588201e4931L, 8.385498349388321535962327491346664141020e4931L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(csinh, -11357.25, 0.75, -9.001213196851067077465606717616495588201e4931L, 8.385498349388321535962327491346664141020e4931L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(csinh, 11357.25, -0.75, 9.001213196851067077465606717616495588201e4931L, -8.385498349388321535962327491346664141020e4931L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(csinh, -11357.25, -0.75, -9.001213196851067077465606717616495588201e4931L, -8.385498349388321535962327491346664141020e4931L, 0|XFAIL_NATIVE_LINUXL },
#endif

#ifdef TEST_FLOAT
	TEST_c_c(csinh, 180, 0x1p-149, INF_P, 1.043535896672617552965983803453927655332e33L, OVERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXF },
#endif

#if defined TEST_DOUBLE || (defined TEST_LDOUBLE && LDBL_MAX_EXP == 1024)
	TEST_c_c(csinh, 1440, 0x1p-1074, INF_P, 5.981479269486130556466515778180916082415e301L, OVERFLOW_EXCEPTION|XFAIL_NATIVE_LINUX },
#endif

#if defined TEST_LDOUBLE && LDBL_MAX_EXP >= 16384
	TEST_c_c(csinh, 22730, 0x1p-16434L, INF_P, 1.217853148905605987081057582351152052687e4924L, OVERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
#endif

	TEST_c_c(csinh, SUBNORM_P, MIN_P, SUBNORM_P, MIN_P, UNDERFLOW_EXCEPTION },
	TEST_c_c(csinh, MIN_P, SUBNORM_P, MIN_P, SUBNORM_P, UNDERFLOW_EXCEPTION },
}


static void test_csqrt(void)
{
	struct test *testp = lookup("csqrt" },

	TEST_c_c(csqrt, 0.0, 0.0, 0.000000000000000000e00, 0.000000000000000000e00, 0 },
	TEST_c_c(csqrt, 1.0, 2.0, 1.272019654512405395e00, 7.861513718962669372e-01, 0 },
	TEST_c_c(csqrt, 0.0, 2.0, 1.000000000000000000e00, 1.000000000000000000e00, 0 },
	TEST_c_c(csqrt, 1.0, 0.0, 1.000000000000000000e00, 0.000000000000000000e00, 0 },
	TEST_c_c(csqrt, -2.0, 2.0, 6.435942575335502624e-01, 1.553773969411849975e00, 0 },
	TEST_c_c(csqrt, -1.0, 2.0, 7.861513718962669372e-01, 1.272019654512405395e00, 0 },
	TEST_c_c(csqrt, 1.0, 2.0, 1.272019654512405395e00, 7.861513718962669372e-01, 0 },

	TEST_c_c(csqrt, 0, 0, 0.0, 0.0, 0 },
	TEST_c_c(csqrt, 0, ZERO_M, 0, ZERO_M, 0 },
	TEST_c_c(csqrt, ZERO_M, 0, 0.0, 0.0, 0 },
	TEST_c_c(csqrt, ZERO_M, ZERO_M, 0.0, ZERO_M, 0 },

	TEST_c_c(csqrt, INF_M, 0, 0.0, INF_P, 0 },
	TEST_c_c(csqrt, INF_M, 6, 0.0, INF_P, 0 },
	TEST_c_c(csqrt, INF_M, ZERO_M, 0.0, INF_M, 0 },
	TEST_c_c(csqrt, INF_M, -6, 0.0, INF_M, 0 },

	TEST_c_c(csqrt, INF_P, 0, INF_P, 0.0, 0 },
	TEST_c_c(csqrt, INF_P, 6, INF_P, 0.0, 0 },
	TEST_c_c(csqrt, INF_P, ZERO_M, INF_P, ZERO_M, 0 },
	TEST_c_c(csqrt, INF_P, -6, INF_P, ZERO_M, 0 },

	TEST_c_c(csqrt, 0, INF_P, INF_P, INF_P, 0 },
	TEST_c_c(csqrt, 4, INF_P, INF_P, INF_P, 0 },
	TEST_c_c(csqrt, INF_P, INF_P, INF_P, INF_P, 0 },
	TEST_c_c(csqrt, ZERO_M, INF_P, INF_P, INF_P, 0 },
	TEST_c_c(csqrt, -4, INF_P, INF_P, INF_P, 0 },
	TEST_c_c(csqrt, INF_M, INF_P, INF_P, INF_P, 0 },
	TEST_c_c(csqrt, 0, INF_M, INF_P, INF_M, 0 },
	TEST_c_c(csqrt, 4, INF_M, INF_P, INF_M, 0 },
	TEST_c_c(csqrt, INF_P, INF_M, INF_P, INF_M, 0 },
	TEST_c_c(csqrt, ZERO_M, INF_M, INF_P, INF_M, 0 },
	TEST_c_c(csqrt, -4, INF_M, INF_P, INF_M, 0 },
	TEST_c_c(csqrt, INF_M, INF_M, INF_P, INF_M, 0 },

	TEST_c_c(csqrt, INF_M, QNAN_P, QNAN_P, INF_P, IGNORE_ZERO_INF_SIGN },

	TEST_c_c(csqrt, INF_P, QNAN_P, INF_P, QNAN_P, 0 },

	TEST_c_c(csqrt, 0, QNAN_P, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	TEST_c_c(csqrt, 1, QNAN_P, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	TEST_c_c(csqrt, ZERO_M, QNAN_P, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	TEST_c_c(csqrt, -1, QNAN_P, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },

	TEST_c_c(csqrt, QNAN_P, 0, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	TEST_c_c(csqrt, QNAN_P, 8, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	TEST_c_c(csqrt, QNAN_P, ZERO_M, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	TEST_c_c(csqrt, QNAN_P, -8, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },

	TEST_c_c(csqrt, QNAN_P, QNAN_P, QNAN_P, QNAN_P, 0 },

	TEST_c_c(csqrt, 16.0, -30.0, 5.0, -3.0, 0 },
	TEST_c_c(csqrt, -1, 0, 0.0, 1.0, 0 },
	TEST_c_c(csqrt, 0, 2, 1.0, 1.0, 0 },
	TEST_c_c(csqrt, 119, 120, 12.0, 5.0, 0 },
	TEST_c_c(csqrt, 0.75L, 1.25L, 1.05065169626078392338656675760808326L, 0.594868882070379067881984030639932657L, 0 },
	TEST_c_c(csqrt, -2, -3, 0.89597747612983812471573375529004348L, -1.6741492280355400404480393008490519L, 0 },
	TEST_c_c(csqrt, -2, 3, 0.89597747612983812471573375529004348L, 1.6741492280355400404480393008490519L, 0 },
	/* Principal square root should be returned (i.e., non-negative real
	   part).  */
	TEST_c_c(csqrt, 0, -1, M_SQRT1_2l, -M_SQRT1_2l, 0 },

	TEST_c_c(csqrt, 0x1.fffffep+127L, 0x1.fffffep+127L, 2.026714405498316804978751017492482558075e+19L, 8.394925938143272988211878516208015586281e+18L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(csqrt, 0x1.fffffep+127L, 1.0L, 1.844674352395372953599975585936590505260e+19L, 2.710505511993121390769065968615872097053e-20L, 0 },
	TEST_c_c(csqrt, 0x1p-149L, 0x1p-149L, 4.112805464342778798097003462770175200803e-23L, 1.703579802732953750368659735601389709551e-23L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(csqrt, 0x1p-147L, 0x1p-147L, 8.225610928685557596194006925540350401606e-23L, 3.407159605465907500737319471202779419102e-23L, 0|XFAIL_NATIVE_LINUXF },

	TEST_c_c(csqrt, ZERO_P, 0x1p-149L, 2.646977960169688559588507814623881131411e-23L, 2.646977960169688559588507814623881131411e-23L, 0|XFAIL_NATIVE_LINUXF },
	TEST_c_c(csqrt, 0x1p-50L, 0x1p-149L, 2.980232238769531250000000000000000000000e-8L, 2.350988701644575015937473074444491355637e-38L, 0|XFAIL_NATIVE_LINUXF },
#ifdef TEST_FLOAT
	TEST_c_c(csqrt, 0x1p+127L, 0x1p-149L, 1.304381782533278221234957180625250836888e19L, ZERO_P, UNDERFLOW_EXCEPTION },
#endif
	TEST_c_c(csqrt, 0x1p-149L, 0x1p+127L, 9.223372036854775808000000000000000000000e18L, 9.223372036854775808000000000000000000000e18L, 0 },
	TEST_c_c(csqrt, 0x1.000002p-126L, 0x1.000002p-126L, 1.191195773697904627170323731331667740087e-19L, 4.934094449071842328766868579214125217132e-20L, UNDERFLOW_EXCEPTION_OK },
	TEST_c_c(csqrt, -0x1.000002p-126L, -0x1.000002p-126L, 4.934094449071842328766868579214125217132e-20L, -1.191195773697904627170323731331667740087e-19L, UNDERFLOW_EXCEPTION_OK },

#ifndef TEST_FLOAT
	TEST_c_c(csqrt, 0x1.fffffffffffffp+1023L, 0x1.fffffffffffffp+1023L, 1.473094556905565378990473658199034571917e+154L, 6.101757441282702188537080005372547713595e+153L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(csqrt, 0x1.fffffffffffffp+1023L, 0x1p+1023L, 1.379778091031440685006200821918878702861e+154L, 3.257214233483129514781233066898042490248e+153L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(csqrt, 0x1p-1074L, 0x1p-1074L, 2.442109726130830256743814843868934877597e-162L, 1.011554969366634726113090867589031782487e-162L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(csqrt, 0x1p-1073L, 0x1p-1073L, 3.453664695497464982856905711457966660085e-162L, 1.430554756764195530630723976279903095110e-162L, 0|XFAIL_NATIVE_LINUX },

	TEST_c_c(csqrt, ZERO_P, 0x1p-1074L, 1.571727784702628688909515672805082228285e-162L, 1.571727784702628688909515672805082228285e-162L, 0|XFAIL_NATIVE_LINUX },
	TEST_c_c(csqrt, 0x1p-500L, 0x1p-1074L, 5.527147875260444560247265192192255725514e-76L, 4.469444793151709302716387622440056066334e-249L, 0|XFAIL_NATIVE_LINUX },
#if defined TEST_DOUBLE || (defined TEST_LDOUBLE && LDBL_MAX_EXP == 1024)
	TEST_c_c(csqrt, 0x1p+1023L, 0x1p-1074L, 9.480751908109176726832526455652159260085e153L, ZERO_P, UNDERFLOW_EXCEPTION },
#endif
	TEST_c_c(csqrt, 0x1p-1074L, 0x1p+1023L, 6.703903964971298549787012499102923063740e153L, 6.703903964971298549787012499102923063740e153L, 0 },
	TEST_c_c(csqrt, 0x1.0000000000001p-1022L, 0x1.0000000000001p-1022L, 1.638872094839911521020410942677082920935e-154L, 6.788430486774966350907249113759995429568e-155L, 0 },
	TEST_c_c(csqrt, -0x1.0000000000001p-1022L, -0x1.0000000000001p-1022L, 6.788430486774966350907249113759995429568e-155L, -1.638872094839911521020410942677082920935e-154L, 0 },
#endif

#if defined TEST_LDOUBLE && LDBL_MAX_EXP >= 16384
	TEST_c_c(csqrt, 0x1.fp+16383L, 0x1.fp+16383L, 1.179514222452201722651836720466795901016e+2466L, 4.885707879516577666702435054303191575148e+2465L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(csqrt, 0x1.fp+16383L, 0x1p+16383L, 1.106698967236475180613254276996359485630e+2466L, 2.687568007603946993388538156299100955642e+2465L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(csqrt, 0x1p-16440L, 0x1p-16441L, 3.514690655930285351254618340783294558136e-2475L,  8.297059146828716918029689466551384219370e-2476L, 0|XFAIL_NATIVE_LINUXL },

	TEST_c_c(csqrt, ZERO_P, 0x1p-16445L, 4.269191686890197837775136325621239761720e-2476L, 4.269191686890197837775136325621239761720e-2476L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(csqrt, 0x1p-5000L, 0x1p-16445L, 2.660791472672778409283210520357607795518e-753L, 6.849840675828785164910701384823702064234e-4199L, 0|XFAIL_NATIVE_LINUXL },
	TEST_c_c(csqrt, 0x1p+16383L, 0x1p-16445L, 7.712754032630730034273323365543179095045e2465L, ZERO_P, UNDERFLOW_EXCEPTION },
	TEST_c_c(csqrt, 0x1p-16445L, 0x1p+16383L, 5.453740678097079647314921223668914312241e2465L, 5.453740678097079647314921223668914312241e2465L, 0 },
	TEST_c_c(csqrt, 0x1.0000000000000002p-16382L, 0x1.0000000000000002p-16382L, 2.014551439675644900131815801350165472778e-2466L, 8.344545284118961664300307045791497724440e-2467L, 0 },
	TEST_c_c(csqrt, -0x1.0000000000000002p-16382L, -0x1.0000000000000002p-16382L, 8.344545284118961664300307045791497724440e-2467L, -2.014551439675644900131815801350165472778e-2466L, 0 },

# if LDBL_MANT_DIG >= 113
	TEST_c_c(csqrt, ZERO_P, 0x1p-16494L, 1.799329752913293143453817328207572571442e-2483L, 1.799329752913293143453817328207572571442e-2483L, 0 },
	TEST_c_c(csqrt, 0x1p-5000L, 0x1p-16494L, 2.660791472672778409283210520357607795518e-753L, 1.216776133331049643422030716668249905907e-4213L, 0 },
	TEST_c_c(csqrt, 0x1p+16383L, 0x1p-16494L, 7.712754032630730034273323365543179095045e2465L, ZERO_P, UNDERFLOW_EXCEPTION },
	TEST_c_c(csqrt, 0x1p-16494L, 0x1p+16383L, 5.453740678097079647314921223668914312241e2465L, 5.453740678097079647314921223668914312241e2465L, 0 },
	TEST_c_c(csqrt, 0x1.0000000000000000000000000001p-16382L, 0x1.0000000000000000000000000001p-16382L, 2.014551439675644900022606748976158925145e-2466L, 8.344545284118961663847948339519226074126e-2467L, 0 },
	TEST_c_c(csqrt, -0x1.0000000000000000000000000001p-16382L, -0x1.0000000000000000000000000001p-16382L, 8.344545284118961663847948339519226074126e-2467L, -2.014551439675644900022606748976158925145e-2466L, 0 },
# endif
#endif
}


static void test_ctan(void)
{
	struct test *testp = lookup("ctan" },

	TEST_c_c(ctan, 1.0e00, 2.0e00, 3.381283208727836608e-02, 1.014793619513511657e00, 0 },
	TEST_c_c(ctan, 0.0e00, 2.0e00, 0.0e00, 9.640275761485099792e-01, 0 },
	TEST_c_c(ctan, 1.0e00, 0.0e00, 1.557407721877098083e00, 0.0e00, 0 },
	TEST_c_c(ctan, -2.0e00, 2.0e00, 2.839295566082000732e-02, 1.023835599422454834e00, 0 },
	TEST_c_c(ctan, -1.0e00, -2.0e00, -3.381283208727836608e-02, -1.014793619513511657e00, 0 },
	TEST_c_c(ctan, 1.0e00, -2.0e00, 3.381283208727836608e-02, -1.014793619513511657e00, 0 },

	TEST_c_c(ctan, 0, 0, 0.0, 0.0, 0 },
	TEST_c_c(ctan, 0, ZERO_M, 0.0, ZERO_M, 0 },
	TEST_c_c(ctan, ZERO_M, 0, ZERO_M, 0.0, 0 },
	TEST_c_c(ctan, ZERO_M, ZERO_M, ZERO_M, ZERO_M, 0 },

	TEST_c_c(ctan, 0, INF_P, 0.0, 1.0, 0 },
	TEST_c_c(ctan, 1, INF_P, 0.0, 1.0, 0 },
	TEST_c_c(ctan, ZERO_M, INF_P, ZERO_M, 1.0, 0 },
	TEST_c_c(ctan, -1, INF_P, ZERO_M, 1.0, 0 },

	TEST_c_c(ctan, 0, INF_M, 0.0, -1.0, 0 },
	TEST_c_c(ctan, 1, INF_M, 0.0, -1.0, 0 },
	TEST_c_c(ctan, ZERO_M, INF_M, ZERO_M, -1.0, 0 },
	TEST_c_c(ctan, -1, INF_M, ZERO_M, -1.0, 0 },

	TEST_c_c(ctan, INF_P, 0, QNAN_P, QNAN_P, INVALID_EXCEPTION },
	TEST_c_c(ctan, INF_P, 2, QNAN_P, QNAN_P, INVALID_EXCEPTION },
	TEST_c_c(ctan, INF_M, 0, QNAN_P, QNAN_P, INVALID_EXCEPTION },
	TEST_c_c(ctan, INF_M, 2, QNAN_P, QNAN_P, INVALID_EXCEPTION },
	TEST_c_c(ctan, INF_P, ZERO_M, QNAN_P, QNAN_P, INVALID_EXCEPTION },
	TEST_c_c(ctan, INF_P, -2, QNAN_P, QNAN_P, INVALID_EXCEPTION },
	TEST_c_c(ctan, INF_M, ZERO_M, QNAN_P, QNAN_P, INVALID_EXCEPTION },
	TEST_c_c(ctan, INF_M, -2, QNAN_P, QNAN_P, INVALID_EXCEPTION },

	TEST_c_c(ctan, QNAN_P, INF_P, 0.0, 1.0, IGNORE_ZERO_INF_SIGN },
	TEST_c_c(ctan, QNAN_P, INF_M, 0.0, -1.0, IGNORE_ZERO_INF_SIGN },

	TEST_c_c(ctan, 0, QNAN_P, 0.0, QNAN_P, 0 },
	TEST_c_c(ctan, ZERO_M, QNAN_P, ZERO_M, QNAN_P, 0 },

	TEST_c_c(ctan, 0.5, QNAN_P, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	TEST_c_c(ctan, -4.5, QNAN_P, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },

	TEST_c_c(ctan, QNAN_P, 0, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	TEST_c_c(ctan, QNAN_P, 5, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	TEST_c_c(ctan, QNAN_P, ZERO_M, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	TEST_c_c(ctan, QNAN_P, -0.25, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },

	TEST_c_c(ctan, QNAN_P, QNAN_P, QNAN_P, QNAN_P, 0 },

	TEST_c_c(ctan, 0.75L, 1.25L, 0.160807785916206426725166058173438663L, 0.975363285031235646193581759755216379L, 0 },
	TEST_c_c(ctan, -2, -3, 0.376402564150424829275122113032269084e-2L, -1.00323862735360980144635859782192726L, 0 },

	TEST_c_c(ctan, 1, 45, 1.490158918874345552942703234806348520895e-39L, 1.000000000000000000000000000000000000001L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUXF },
	TEST_c_c(ctan, 1, 47, 2.729321264492904590777293425576722354636e-41L, 1.0, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUXF },

#ifndef TEST_FLOAT
	TEST_c_c(ctan, 1, 355, 8.140551093483276762350406321792653551513e-309L, 1.0, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(ctan, 1, 365, 1.677892637497921890115075995898773550884e-317L, 1.0, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
#endif

#if defined TEST_LDOUBLE && LDBL_MAX_EXP >= 16384
	TEST_c_c(ctan, 1, 5680, 4.725214596136812019616700920476949798307e-4934L, 1.0, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(ctan, 1, 5690, 9.739393181626937151720816611272607059057e-4943L, 1.0, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
#endif

	TEST_c_c(ctan, 0x3.243f6cp-1, 0, -2.287733242885645987394874673945769518150e7L, 0.0, 0|XFAIL_NATIVE_LINUX },

	TEST_c_c(ctan, 0x1p127, 1, 0.2446359391192790896381501310437708987204L, 0.9101334047676183761532873794426475906201L, 0|XFAIL_NATIVE_LINUXL|XFAIL_NATIVE_LINUXF|XFAIL_FPU },

#ifndef TEST_FLOAT
	TEST_c_c(ctan, 0x1p1023, 1, -0.2254627924997545057926782581695274244229L, 0.8786063118883068695462540226219865087189L, 0|XFAIL_NATIVE_LINUX|XFAIL_FPU },
#endif

#if defined TEST_LDOUBLE && LDBL_MAX_EXP >= 16384
	TEST_c_c(ctan, 0x1p16383L, 1, 0.1608598776370396607204448234354670036772L, 0.8133818522051542536316746743877629761488L, 0|XFAIL_NATIVE_LINUXL|XFAIL_FPU },
#endif

	TEST_c_c(ctan, 50000, 50000, ZERO_P, 1.0, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUX },
	TEST_c_c(ctan, 50000, -50000, ZERO_P, -1.0, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUX },
	TEST_c_c(ctan, -50000, 50000, ZERO_M, 1.0, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUX },
	TEST_c_c(ctan, -50000, -50000, ZERO_M, -1.0, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUX },

	TEST_c_c(ctan, 0x1.921fb6p+0, 0x1p-149, -2.287733242885645987394874673945769518150e7L, 7.334008549954377778731880988481078535821e-31L, 0|ROUND_TONEAREST|XFAIL_NATIVE_LINUX },

#ifndef TEST_FLOAT
	TEST_c_c(ctan, 0x1.921fb54442d18p+0, 0x1p-1074, 1.633123935319536975596773704152891653086e16L, 1.317719414943508315995636961402669067843e-291L, 0|ROUND_TONEAREST|XFAIL_NATIVE_LINUX|XFAIL_FPU },
#endif

#if defined TEST_LDOUBLE && LDBL_MIN_EXP <= -16381
	TEST_c_c(ctan, 0x1.921fb54442d1846ap+0L, 0x1p-16445L, -3.986797629811710706723242948653362815645e19L, 5.793882568875674066286163141055208625180e-4912L, 0|ROUND_TONEAREST|XFAIL_NATIVE_LINUXL|XFAIL_FPU },
#endif

	TEST_c_c(ctan, 0x1.921fb6p+0, 0x1p-149, -2.287733242885645987394874673945769518150e7L, 7.334008549954377778731880988481078535821e-31L, 0|ROUND_TOWARDZERO|XFAIL_NATIVE_LINUX },

#ifndef TEST_FLOAT
	TEST_c_c(ctan, 0x1.921fb54442d18p+0, 0x1p-1074, 1.633123935319536975596773704152891653086e16L, 1.317719414943508315995636961402669067843e-291L, 0|ROUND_TOWARDZERO|XFAIL_NATIVE_LINUX|XFAIL_FPU },
#endif

#if defined TEST_LDOUBLE && LDBL_MIN_EXP <= -16381
	TEST_c_c(ctan, 0x1.921fb54442d1846ap+0L, 0x1p-16445L, -3.986797629811710706723242948653362815645e19L, 5.793882568875674066286163141055208625180e-4912L, 0|ROUND_TOWARDZERO|XFAIL_NATIVE_LINUXL|XFAIL_FPU },
#endif

	TEST_c_c(ctan, 0x1.921fb6p+0, 0x1p-149, -2.287733242885645987394874673945769518150e7L, 7.334008549954377778731880988481078535821e-31L, 0|ROUND_DOWNWARD|XFAIL_NATIVE_LINUX },

#ifndef TEST_FLOAT
	TEST_c_c(ctan, 0x1.921fb54442d18p+0, 0x1p-1074, 1.633123935319536975596773704152891653086e16L, 1.317719414943508315995636961402669067843e-291L, 0|ROUND_DOWNWARD|XFAIL_NATIVE_LINUX|XFAIL_FPU },
#endif

#if defined TEST_LDOUBLE && LDBL_MIN_EXP <= -16381
	TEST_c_c(ctan, 0x1.921fb54442d1846ap+0L, 0x1p-16445L, -3.986797629811710706723242948653362815645e19L, 5.793882568875674066286163141055208625180e-4912L, 0|ROUND_DOWNWARD|XFAIL_NATIVE_LINUXL|XFAIL_FPU },
#endif

	TEST_c_c(ctan, 0x1.921fb6p+0, 0x1p-149, -2.287733242885645987394874673945769518150e7L, 7.334008549954377778731880988481078535821e-31L, 0|ROUND_UPWARD|XFAIL_NATIVE_LINUX },

#ifndef TEST_FLOAT
	TEST_c_c(ctan, 0x1.921fb54442d18p+0, 0x1p-1074, 1.633123935319536975596773704152891653086e16L, 1.317719414943508315995636961402669067843e-291L, 0|ROUND_UPWARD|XFAIL_NATIVE_LINUX|XFAIL_FPU },
#endif

#if defined TEST_LDOUBLE && LDBL_MIN_EXP <= -16381
	TEST_c_c(ctan, 0x1.921fb54442d1846ap+0L, 0x1p-16445L, -3.986797629811710706723242948653362815645e19L, 5.793882568875674066286163141055208625180e-4912L, 0|ROUND_UPWARD|XFAIL_NATIVE_LINUXL|XFAIL_FPU },
#endif
}


static void test_ctanh(void)
{
	struct test *testp = lookup("ctanh" },

	TEST_c_c(ctanh, 1.0e00, 2.0e00, 1.166736245155334472e00, -2.434581927955150604e-01, 0 },
	TEST_c_c(ctanh, 0.0e00, 2.0e00, 0.0e00, -2.185039848089218139e00, 0 },
	TEST_c_c(ctanh, 1.0e00, 0.0e00, 7.615941539406776428e-01, 0.0e00, 0 },
	TEST_c_c(ctanh, -2.0e00, 2.0e00, -1.023835599422454834e00, -2.839295566082000732e-02, 0 },
	TEST_c_c(ctanh, -1.0e00, -2.0e00, -1.166736245155334472e00, 2.434581927955150604e-01, 0 },
	TEST_c_c(ctanh, 1.0e00, -2.0e00, 1.166736245155334472e00, 2.434581927955150604e-01, 0 },

	TEST_c_c(ctanh, 0, 0, 0.0, 0.0, 0 },
	TEST_c_c(ctanh, 0, ZERO_M, 0.0, ZERO_M, 0 },
	TEST_c_c(ctanh, ZERO_M, 0, ZERO_M, 0.0, 0 },
	TEST_c_c(ctanh, ZERO_M, ZERO_M, ZERO_M, ZERO_M, 0 },

	TEST_c_c(ctanh, INF_P, 0, 1.0, 0.0, 0 },
	TEST_c_c(ctanh, INF_P, 1, 1.0, 0.0, 0 },
	TEST_c_c(ctanh, INF_P, ZERO_M, 1.0, ZERO_M, 0 },
	TEST_c_c(ctanh, INF_P, -1, 1.0, ZERO_M, 0 },
	TEST_c_c(ctanh, INF_M, 0, -1.0, 0.0, 0 },
	TEST_c_c(ctanh, INF_M, 1, -1.0, 0.0, 0 },
	TEST_c_c(ctanh, INF_M, ZERO_M, -1.0, ZERO_M, 0 },
	TEST_c_c(ctanh, INF_M, -1, -1.0, ZERO_M, 0 },

	TEST_c_c(ctanh, 0, INF_P, QNAN_P, QNAN_P, INVALID_EXCEPTION },
	TEST_c_c(ctanh, 2, INF_P, QNAN_P, QNAN_P, INVALID_EXCEPTION },
	TEST_c_c(ctanh, 0, INF_M, QNAN_P, QNAN_P, INVALID_EXCEPTION },
	TEST_c_c(ctanh, 2, INF_M, QNAN_P, QNAN_P, INVALID_EXCEPTION },
	TEST_c_c(ctanh, ZERO_M, INF_P, QNAN_P, QNAN_P, INVALID_EXCEPTION },
	TEST_c_c(ctanh, -2, INF_P, QNAN_P, QNAN_P, INVALID_EXCEPTION },
	TEST_c_c(ctanh, ZERO_M, INF_M, QNAN_P, QNAN_P, INVALID_EXCEPTION },
	TEST_c_c(ctanh, -2, INF_M, QNAN_P, QNAN_P, INVALID_EXCEPTION },

	TEST_c_c(ctanh, INF_P, QNAN_P, 1.0, 0.0, IGNORE_ZERO_INF_SIGN },
	TEST_c_c(ctanh, INF_M, QNAN_P, -1.0, 0.0, IGNORE_ZERO_INF_SIGN },

	TEST_c_c(ctanh, QNAN_P, 0, QNAN_P, 0.0, 0 },
	TEST_c_c(ctanh, QNAN_P, ZERO_M, QNAN_P, ZERO_M, 0 },

	TEST_c_c(ctanh, QNAN_P, 0.5, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	TEST_c_c(ctanh, QNAN_P, -4.5, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },

	TEST_c_c(ctanh, 0, QNAN_P, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	TEST_c_c(ctanh, 5, QNAN_P, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	TEST_c_c(ctanh, ZERO_M, QNAN_P, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },
	TEST_c_c(ctanh, -0.25, QNAN_P, QNAN_P, QNAN_P, INVALID_EXCEPTION_OK },

	TEST_c_c(ctanh, QNAN_P, QNAN_P, QNAN_P, QNAN_P, 0 },

	TEST_c_c(ctanh, 0, M_PI_4l, 0.0, 1.0, 0 },

	TEST_c_c(ctanh, 0.75L, 1.25L, 1.37260757053378320258048606571226857L, 0.385795952609750664177596760720790220L, 0 },
	TEST_c_c(ctanh, -2, -3, -0.965385879022133124278480269394560686L, 0.988437503832249372031403430350121098e-2L, 0 },

	TEST_c_c(ctanh, 45, 1, 1.000000000000000000000000000000000000001L, 1.490158918874345552942703234806348520895e-39L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUXF },
	TEST_c_c(ctanh, 47, 1, 1.0, 2.729321264492904590777293425576722354636e-41L, UNDERFLOW_EXCEPTION_FLOAT|XFAIL_NATIVE_LINUXF },

#ifndef TEST_FLOAT
	TEST_c_c(ctanh, 355, 1, 1.0, 8.140551093483276762350406321792653551513e-309L, UNDERFLOW_EXCEPTION_DOUBLE },
	TEST_c_c(ctanh, 365, 1, 1.0, 1.677892637497921890115075995898773550884e-317L, UNDERFLOW_EXCEPTION_DOUBLE|XFAIL_NATIVE_LINUX },
#endif

#if defined TEST_LDOUBLE && LDBL_MAX_EXP >= 16384
	TEST_c_c(ctanh, 5680, 1, 1.0, 4.725214596136812019616700920476949798307e-4934L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
	TEST_c_c(ctanh, 5690, 1, 1.0, 9.739393181626937151720816611272607059057e-4943L, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUXL },
#endif

	TEST_c_c(ctanh, 0, 0x3.243f6cp-1, 0.0, -2.287733242885645987394874673945769518150e7L, 0|XFAIL_NATIVE_LINUX },

	TEST_c_c(ctanh, 1, 0x1p127, 0.9101334047676183761532873794426475906201L, 0.2446359391192790896381501310437708987204L, 0|XFAIL_NATIVE_LINUXL|XFAIL_NATIVE_LINUXF|XFAIL_FPU },

#ifndef TEST_FLOAT
	TEST_c_c(ctanh, 1, 0x1p1023, 0.8786063118883068695462540226219865087189L, -0.2254627924997545057926782581695274244229L, 0|XFAIL_NATIVE_LINUX|XFAIL_FPU },
#endif

#if defined TEST_LDOUBLE && LDBL_MAX_EXP >= 16384
	TEST_c_c(ctanh, 1, 0x1p16383L, 0.8133818522051542536316746743877629761488L, 0.1608598776370396607204448234354670036772L, 0|XFAIL_NATIVE_LINUXL|XFAIL_FPU },
#endif

	TEST_c_c(ctanh, 50000, 50000, 1.0, ZERO_P, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUX },
	TEST_c_c(ctanh, 50000, -50000, 1.0, ZERO_M, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUX },
	TEST_c_c(ctanh, -50000, 50000, -1.0, ZERO_P, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUX },
	TEST_c_c(ctanh, -50000, -50000, -1.0, ZERO_M, UNDERFLOW_EXCEPTION|XFAIL_NATIVE_LINUX },

	TEST_c_c(ctanh, 0x1p-149, 0x1.921fb6p+0, 7.334008549954377778731880988481078535821e-31L, -2.287733242885645987394874673945769518150e7L, 0|ROUND_TONEAREST|XFAIL_NATIVE_LINUX },

#ifndef TEST_FLOAT
	TEST_c_c(ctanh, 0x1p-1074, 0x1.921fb54442d18p+0, 1.317719414943508315995636961402669067843e-291L, 1.633123935319536975596773704152891653086e16L, 0|ROUND_TONEAREST|XFAIL_NATIVE_LINUX|XFAIL_FPU },
#endif

#if defined TEST_LDOUBLE && LDBL_MIN_EXP <= -16381
	TEST_c_c(ctanh, 0x1p-16445L, 0x1.921fb54442d1846ap+0L, 5.793882568875674066286163141055208625180e-4912L, -3.986797629811710706723242948653362815645e19L, 0|ROUND_TONEAREST|XFAIL_NATIVE_LINUXL|XFAIL_FPU },
#endif

	TEST_c_c(ctanh, 0x1p-149, 0x1.921fb6p+0, 7.334008549954377778731880988481078535821e-31L, -2.287733242885645987394874673945769518150e7L, 0|ROUND_TOWARDZERO|XFAIL_NATIVE_LINUX },

#ifndef TEST_FLOAT
	TEST_c_c(ctanh, 0x1p-1074, 0x1.921fb54442d18p+0, 1.317719414943508315995636961402669067843e-291L, 1.633123935319536975596773704152891653086e16L, 0|ROUND_TOWARDZERO|XFAIL_NATIVE_LINUX|XFAIL_FPU },
#endif

#if defined TEST_LDOUBLE && LDBL_MIN_EXP <= -16381
	TEST_c_c(ctanh, 0x1p-16445L, 0x1.921fb54442d1846ap+0L, 5.793882568875674066286163141055208625180e-4912L, -3.986797629811710706723242948653362815645e19L, 0|ROUND_TOWARDZERO|XFAIL_NATIVE_LINUXL|XFAIL_FPU },
#endif

	TEST_c_c(ctanh, 0x1p-149, 0x1.921fb6p+0, 7.334008549954377778731880988481078535821e-31L, -2.287733242885645987394874673945769518150e7L, 0|ROUND_DOWNWARD|XFAIL_NATIVE_LINUX },

#ifndef TEST_FLOAT
	TEST_c_c(ctanh, 0x1p-1074, 0x1.921fb54442d18p+0, 1.317719414943508315995636961402669067843e-291L, 1.633123935319536975596773704152891653086e16L, 0|ROUND_DOWNWARD|XFAIL_NATIVE_LINUX|XFAIL_FPU },
#endif

#if defined TEST_LDOUBLE && LDBL_MIN_EXP <= -16381
	TEST_c_c(ctanh, 0x1p-16445L, 0x1.921fb54442d1846ap+0L, 5.793882568875674066286163141055208625180e-4912L, -3.986797629811710706723242948653362815645e19L, 0|ROUND_DOWNWARD|XFAIL_NATIVE_LINUXL|XFAIL_FPU },
#endif

	TEST_c_c(ctanh, 0x1p-149, 0x1.921fb6p+0, 7.334008549954377778731880988481078535821e-31L, -2.287733242885645987394874673945769518150e7L, 0|ROUND_UPWARD|XFAIL_NATIVE_LINUX },

#ifndef TEST_FLOAT
	TEST_c_c(ctanh, 0x1p-1074, 0x1.921fb54442d18p+0, 1.317719414943508315995636961402669067843e-291L, 1.633123935319536975596773704152891653086e16L, 0|ROUND_UPWARD|XFAIL_NATIVE_LINUX|XFAIL_FPU },
#endif

#if defined TEST_LDOUBLE && LDBL_MIN_EXP <= -16381
	TEST_c_c(ctanh, 0x1p-16445L, 0x1.921fb54442d1846ap+0L, 5.793882568875674066286163141055208625180e-4912L, -3.986797629811710706723242948653362815645e19L, 0|ROUND_UPWARD|XFAIL_NATIVE_LINUXL|XFAIL_FPU },
#endif
}


#if defined(NATIVE_WIN32) || defined(NATIVE_LINUX)
#if defined(TEST_FLOAT)
#include "../src/crcpf.c"
#elif defined(TEST_LDOUBLE)
#include "../src/crcpl.c"
#else
#include "../src/crcp.c"
#endif
#include "../src/p_pmlerrs.c"
#include "../src/p_matherr.c"
#include "../src/s_signgam.c"
#include "../src/s_issignaling.c"
#include "../src/s_issignalingf.c"
#include "../src/s_issignalingl.c"
#endif


static void test_crcp(void)
{
	struct test *testp = lookup("crcp" },

	TEST_c_c(crcp, 1.0e00, 2.0e00, 1.999999992549419403e-01, -3.999999985098838806e-01, 0 },
	TEST_c_c(crcp, 0.0e00, 2.0e00, 0.0e00, -5.0e-01, 0 },
	TEST_c_c(crcp, 1.0e00, 0.0e00, 1.0e00, -0.0e00, 0 },
	TEST_c_c(crcp, -2.0e00, 2.0e00, -2.5e-01, -2.5e-01, 0 },
	TEST_c_c(crcp, -1.0e00, -2.0e00, -1.999999992549419403e-01, 3.999999985098838806e-01, 0 },
	TEST_c_c(crcp, 1.0e00, -2.0e00, 1.999999992549419403e-01, 3.999999985098838806e-01, 0 },
}


static void test_cpow(void)
{
	struct test *testp = lookup("cpow" },

	TEST_cc_c (cpow, 1, 0, 0, 0, 1.0, 0.0, 0 },
	TEST_cc_c (cpow, 2, 0, 10, 0, 1024.0, 0.0, 0 },
#if 0
	/* Disabled until we fix bug 14473.  */
	TEST_cc_c (cpow, M_El, 0, 0, 2 * M_PIl, 1.0, 0.0, 0 },
#endif
	TEST_cc_c (cpow, 2, 3, 4, 0, -119.0, -120.0, 0 },

	TEST_cc_c (cpow, QNAN_P, QNAN_P, QNAN_P, QNAN_P, QNAN_P, QNAN_P, 0 },

	TEST_cc_c (cpow, 0.75L, 1.25L, 0.75L, 1.25L, 0.117506293914473555420279832210420483L, 0.346552747708338676483025352060418001L, 0 },
	TEST_cc_c (cpow, 0.75L, 1.25L, 1.0L, 1.0L, 0.0846958290317209430433805274189191353L, 0.513285749182902449043287190519090481L, 0 },
	TEST_cc_c (cpow, 0.75L, 1.25L, 1.0L, 0.0L, 0.75L, 1.25L, 0 },
	TEST_cc_c (cpow, 0.75L, 1.25L, 0.0L, 1.0L, 0.331825439177608832276067945276730566L, 0.131338600281188544930936345230903032L, 0 },
}

```

`tests/testconfig.h`:

```h
#ifndef __TESTCONFIG_H__
#define __TESTCONFIG_H__ 1

#define _GNU_SOURCE

#include "config.h"
#include <float.h>

#ifdef LIBCMINI
#define CR "\r"
#else
#define CR
#endif

/*
 * set to 1 to allow for small differences in the last few
 * bits of floating point values,
 * since at least the JIT compiler cannot guarantee bit exactness
 * in all cases.
 * Theoretically, when running the tests on real hardware,
 * this should be set to 0. However, it turns out that different types
 * of FPUs return slightly different values, so getting this exactly
 * right for all cases is almost impossible.
 */
#define ALLOW_INEXACT 1

/*
 * set to 1 to allow for testing m68k minimum subnormal value.
 * Problem with this is that this value cannot be represented
 * by x87.
 * When using a softfloat emulation, or running the tests on real hardware,
 * this should be set to 1.
 * Note: if this is enabled, it will be disabled when a runtime check
 * can be performed to detect the cpu type, and it is '040 or '060
 * (currently only done for the amiga version).
 */
#define ALLOW_SUBNORM_MIN 0


/*
 * For the same reason as above, m68k minval cannot be represent
 * in x87.
 * When using a softfloat emulation, or running the tests on real hardware,
 * this should be set to 1
 */
#define ALLOW_MINVAL 0


/*
 * number of iterations each single test is run.
 * mainly intended to get the code compiled by JIT
 */
#ifndef JIT_LOOPS
#  define JIT_LOOPS 128
#endif




/*
 * remaining stuff should normally not needed to be changed
 */

#ifndef __ORDER_BIG_ENDIAN__
#  define __ORDER_BIG_ENDIAN__ 4321
#endif

#ifdef __PUREC__
#  define __mc68000__ 1
#  define __BYTE_ORDER__ __ORDER_BIG_ENDIAN__
#endif

#ifndef __BYTE_ORDER__
  #error "__BYTE_ORDER__ not defined"
#endif

#ifndef __mc68000__
#define __HAVE_68881__
#endif

#if (defined(__68881__) || defined(_M68881) || defined(__M68881__) || defined(__FPU__)) && !defined(__HAVE_68881__)
#define __HAVE_68881__
#endif

#ifndef __USER_LABEL_PREFIX__
#  if defined(__PUREC__) || defined(__ELF__)
#    define __USER_LABEL_PREFIX__
#  else
#    define __USER_LABEL_PREFIX__ _
#  endif
#endif

#ifndef __SYMBOL_PREFIX
# define __SYMBOL_PREFIX __STRINGIFY(__USER_LABEL_PREFIX__)
#endif
#ifndef __ASM_SYMBOL_PREFIX
# define __ASM_SYMBOL_PREFIX __USER_LABEL_PREFIX__
#endif

#ifndef C_SYMBOL_NAME
# define C_SYMBOL_NAME(name) __SYMBOL_PREFIX #name
#endif

#ifndef __STRINGIFY
#define __STRING(x)	#x
#define __STRINGIFY(x)	__STRING(x)
#endif

#include <math.h>
#include <sys/types.h>
#include <stdint.h>

#ifdef TEST_DOUBLE
#define REAL double
#define __MATH_PRECNAME(name) name
#endif
#ifdef TEST_FLOAT
#define REAL float
#define __MATH_PRECNAME(name) name##f
#endif
#ifdef TEST_LDOUBLE
#define REAL long double
#define __MATH_PRECNAME(name) name##l
#endif
#ifndef REAL
#error "don't know what to test"
#endif

/*
 * ColdFire has no long double format
 */
#if DBL_MANT_DIG == LDBL_MANT_DIG && !defined(__NO_LONG_DOUBLE_MATH)
#  define __NO_LONG_DOUBLE_MATH 1
#endif

#endif /* __TESTCONFIG_H__ */

```

`tests/testdriver.h`:

```h
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>
#include "testconfig.h"
#include "fdlibm.h"

#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
struct float96 {
	uint16_t exponent;
	uint16_t empty;
	uint32_t mantissa0;
	uint32_t mantissa1;
};
struct float64 {
	uint32_t msw;
	uint32_t lsw;
};
#define HEXCONSTE(v, exp, mant0, mant1) { { exp, 0, mant0, mant1 } }
#else
struct float96 {
	uint32_t mantissa1;
	uint32_t mantissa0;
	uint16_t exponent;
	uint16_t empty;
};
struct float64 {
	uint32_t lsw;
	uint32_t msw;
};
#define HEXCONSTE(v, exp, mant0, mant1) { { mant1, mant0, exp, 0 } }
#endif

typedef union _ld_union {
	struct float96 v;
	long double x;
	double d;
	float s;
} ld_union;

typedef unsigned int flag_t;

typedef struct { int line; ld_union x; ld_union e; flag_t flags; } test_f_f_data;
typedef struct { int line; ld_union x; int e; flag_t flags; } test_f_i_data;
typedef struct { int line; ld_union x; long e; flag_t flags; } test_f_l_data;
typedef struct { int line; ld_union x; long long e; flag_t flags; } test_f_ll_data;
typedef struct { int line; ld_union x; ld_union y; int e; flag_t flags; } test_ff_i_data;
typedef struct { int line; ld_union x; ld_union y; ld_union e; flag_t flags; } test_ff_f_data;
typedef struct { int line; ld_union a; ld_union b; ld_union c; ld_union e; flag_t flags; } test_fff_f_data;
typedef struct { int line; ld_union x; ld_union e; ld_union e2; flag_t flags; } test_f_ffp_data;
typedef struct { int line; ld_union x; ld_union r1; ld_union r2; flag_t flags; } test_f_ff_data;
typedef struct { int line; ld_union x; ld_union e; int exp; flag_t flags; } test_fip_f_data;
typedef struct { int line; ld_union x; int exp; ld_union e; flag_t flags; } test_fi_f_data;
typedef struct { int line; ld_union x; long exp; ld_union e; flag_t flags; } test_fl_f_data;
typedef struct { int line; int i; ld_union x; ld_union e; flag_t flags; } test_if_f_data;

#define FLAG_INEXACT             0x00000001 /* accept slightly inexact values */
#define FLAG_SUBNORM             0x00000002 /* test uses subnormal min values */
#define FLAG_MINVAL              0x00000004 /* test uses minimum values */
#define FLAG_FAIL_ARANYM         0x00000008 /* test currently fails on ARAnyM, but shouldn't */
#define FLAG_FAIL_HATARI         0x00000010 /* test currently fails on Hatari, but shouldn't */
#define FLAG_FAIL_STONX          0x00000020 /* test currently fails on STonX, but shouldn't */
#define FLAG_FAIL_JIT            0x00000040 /* test currently fails when using JIT */
#define FLAG_XFAIL_LINUX         0x00000080 /* test currently fails on linux */
#define FLAG_FAIL_X87            0x00000100 /* test currently fails when emulation uses x87 host FPU */
#define FLAG_INEXACT2            0x00000200 /* accept even more inexact values */
#define FLAG_INEXACT3            0x00000400 /* accept even more inexact values */
#define FLAG_INEXACT4            0x00000800 /* accept even more inexact values */
#define FLAG_INEXACT5            0x00001000 /* accept even more inexact values */
#define FLAG_INEXACT_SUBNORM     0x00002000 /* accept inexact subnorm results */
#define FLAG_FAIL_ARANYM2        0x00004000 /* test only occassionaly fails on ARAnyM */
#define FLAG_FAIL_SOFTFLOAT      0x00008000 /* test currently fails with softfloat version and has to be fixed */
#define FLAG_XFAIL               0x00010000 /* test currently fails and has to be fixed */
#define FLAG_IGNORE_ZEROSIGN     0x00020000 /* accept both +/-0 */
#define FLAG_FAIL_HARDFLOAT      0x00040000 /* test currently fails with FPU version and has to be fixed */

/*
 * exceptions that should be raised (not checked yet)
 */
#define INEXACT_EXCEPTION        0x01000000
#define NO_INEXACT_EXCEPTION     0x02000000
#define UNDERFLOW_EXCEPTION      0x04000000
#define OVERFLOW_EXCEPTION       0x08000000
#define INVALID_EXCEPTION        0x10000000
#define DIVIDE_BY_ZERO_EXCEPTION 0x20000000
#define UNDERFLOW_EXCEPTION_OK   0x00000000
#define OVERFLOW_EXCEPTION_OK    0x00000000
#define INVALID_EXCEPTION_OK     0x00000000
#define UNDERFLOW_EXCEPTION_BEFORE_ROUNDING 0

/* Values underflowing only for float.  */
#if defined(TEST_FLOAT)
# define UNDERFLOW_EXCEPTION_FLOAT	UNDERFLOW_EXCEPTION
# define UNDERFLOW_EXCEPTION_OK_FLOAT	UNDERFLOW_EXCEPTION_OK
#else
# define UNDERFLOW_EXCEPTION_FLOAT	0
# define UNDERFLOW_EXCEPTION_OK_FLOAT	0
#endif
/* Values underflowing only for double or types with a larger least
   positive normal value.  */
#if defined(TEST_FLOAT) || defined(TEST_DOUBLE) || (defined(TEST_LDOUBLE) && LDBL_MIN_EXP >= DBL_MIN_EXP)
# define UNDERFLOW_EXCEPTION_DOUBLE	UNDERFLOW_EXCEPTION
# define UNDERFLOW_EXCEPTION_OK_DOUBLE	UNDERFLOW_EXCEPTION_OK
#else
# define UNDERFLOW_EXCEPTION_DOUBLE	0
# define UNDERFLOW_EXCEPTION_OK_DOUBLE	0
#endif

/* not implemented yet */
#define ERRNO_ERANGE    0
#define ERRNO_EDOM      0
#define ERRNO_UNCHANGED 0

/* not implemented yet */
#define ROUND_TONEAREST  0
#define ROUND_TOWARDZERO 0
#define ROUND_DOWNWARD   0
#define ROUND_UPWARD     0


#define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))


/*
 * Replace some conversion functions from libgcc.
 * The default implementation will generate NaNs
 * when converting INFs, but we need to preverse them
 */

union double_long {
	struct {
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
		int32_t upper;
		uint32_t lower;
#else
		uint32_t lower;
		int32_t upper;
#endif
	} l;
	double d;
};

#ifdef __NO_LONG_DOUBLE_MATH

#define my_truncxfdf2(x) x
#define my_extenddfxf2(x) x

#else

union long_double_long {
	long double ld;
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
	struct
	{
	    int16_t sign_exponent;
	    uint16_t empty;
		uint32_t middle;
		uint32_t lower;
	} l;
#else
	struct
	{
		uint32_t lower;
		uint32_t middle;
	    int16_t sign_exponent;
	    uint16_t empty;
	} l;
#endif
};

/* convert long double to double */
double my_truncxfdf2(long double ld);
double my_truncxfdf2(long double ld)
{
	int32_t exp;
	union double_long dl;
	union long_double_long ldl;

	ldl.ld = ld;

	dl.l.upper = ((int32_t)(ldl.l.sign_exponent & 0x8000)) << 16;
	exp = ldl.l.sign_exponent & 0x7FFF;
	if (exp == 0 && !(ldl.l.middle & 0x7FFFFFFFL) && !ldl.l.lower)
	{
		dl.l.lower = 0;
	} else
	{
		if (exp == IEEE854_LONG_DOUBLE_MAXEXP)
		{
			exp = IEEE754_DOUBLE_MAXEXP;
		} else
		{
	 		exp = exp - IEEE854_LONG_DOUBLE_BIAS + IEEE754_DOUBLE_BIAS;
			if (exp >= IEEE754_DOUBLE_MAXEXP)
				exp = IEEE754_DOUBLE_MAXEXP - 1;
	 	}
	 	dl.l.upper |= exp << (32 - (11 + 1));
		/* +1-1: add one for sign bit, but take one off for explicit-integer-bit */
		dl.l.upper |= (ldl.l.middle & 0x7FFFFFFFL) >> (11 + 1 - 1);
		dl.l.lower = (ldl.l.middle & 0x7FFFFFFFL) << (32 - (11 + 1 - 1));
		dl.l.lower |= ldl.l.lower >> (11 + 1 - 1);
	}
	
	/* printf("%04x:%08x:%08x %.22Le -> %08x:%08x %.22e\n", (uint16_t)ldl.l.sign_exponent, ldl.l.middle, ldl.l.lower, ldl.ld, dl.l.upper, dl.l.lower, dl.d); */
	return dl.d;
}


/* convert double to long double */
long double my_extenddfxf2(double d);
long double my_extenddfxf2(double d)
{
	union double_long dl;
	union long_double_long ldl;
	int32_t exp;

	dl.d = d;

	ldl.l.sign_exponent = (dl.l.upper & 0x80000000L) >> 16;
	ldl.l.empty = 0;
	if ((dl.l.upper & 0x7fffffffL) == 0 && !dl.l.lower)
	{
		ldl.l.middle = 0;
		ldl.l.lower = 0;
	} else
	{
		exp = (((dl.l.upper) >> 20) & 0x7FFL);
		if (exp == IEEE754_DOUBLE_MAXEXP)
		{
			exp = IEEE854_LONG_DOUBLE_MAXEXP;
		} else
		{
			exp = exp - IEEE754_DOUBLE_BIAS + IEEE854_LONG_DOUBLE_BIAS;
		}
		ldl.l.sign_exponent |= exp;
		ldl.l.middle = (1L << 31L);
		/* 31-20: # mantissa bits in ldl.l.middle - # mantissa bits in dl.l.upper */
		ldl.l.middle |= (dl.l.upper & 0xFFFFFL) << (31 - 20);
		/* 1+20: explicit-integer-bit + # mantissa bits in dl.l.upper */
		ldl.l.middle |= dl.l.lower >> (1 + 20);
		/* 32 - 21: # bits of dl.l.lower in ldl.l.middle */
		ldl.l.lower = dl.l.lower << (32 - 21);
		if (exp == IEEE854_LONG_DOUBLE_MAXEXP && ldl.l.lower != 0)
		{
			ldl.l.lower |= 0x7ff;
		}
	}

	/* printf("%08x:%08x %.22e -> %04x:%08x:%08x %.22Le\n", dl.l.upper, dl.l.lower, dl.d, (uint16_t)ldl.l.sign_exponent, ldl.l.middle, ldl.l.lower, ldl.ld); */
	return ldl.ld;
}


/* convert float to long double */
long double my_extendsfxf2(float f);
long double my_extendsfxf2(float f)
{
	return f; /* TODO */
}


/* convert long double to float */
float my_truncxfsf2(long double x);
float my_truncxfsf2(long double x)
{
	return x; /* TODO */
}


#endif /* __NO_LONG_DOUBLE_MATH */

/* convert float to double */
double my_extendsfxd2(float f);
double my_extendsfxd2(float f)
{
	return f; /* TODO */
}


#if defined(__AMIGA__) && ALLOW_SUBNORM_MIN
#include <exec/execbase.h>
#undef ALLOW_SUBNORM_MIN
/*
 * 040/060 does not handle denormals like 6888x
 */
#define ALLOW_SUBNORM_MIN (!is_040_or_060())
static __inline int is_040_or_060(void)
{
	struct ExecBase *AbsSysBase = *((struct ExecBase **)4);
	
	return (AbsSysBase->AttnFlags & (AFF_68040|AFF_68060)) != 0;
}
#endif


int numtests;
int testonly;
int jit_loops = JIT_LOOPS;

static enum {
	EMULATOR_NONE,
	EMULATOR_ARANYM,
	EMULATOR_HATARI,
	EMULATOR_STONX
} emulator;


#define CHECK(var) \
	this_fail = var; \
	if (var) \
	{ \
		fprintf(stderr, "%s:%d: test %d(%d): failed" CR "\n", __FILE__, __LINE__, numtests, i); \
		status |= this_fail != 0; \
	}


#ifdef TEST_DOUBLE
__attribute__((__noinline__))
static int skip_double_test(const ld_union *x, flag_t flags)
{
	/*
	 * skip tests involving sub-normals for now,
	 * they are currently only designed for long doubles
	 */
	if (flags & (FLAG_SUBNORM|FLAG_MINVAL))
		return 1;
	/*
	 * allow tests involving infs and nans
	 */
	if ((x->v.exponent & IEEE854_LONG_DOUBLE_MAXEXP) == IEEE854_LONG_DOUBLE_MAXEXP)
		return 0;
	/*
	 * ... and zeroes
	 */
	if ((x->v.exponent & IEEE854_LONG_DOUBLE_MAXEXP) == 0)
	{
		/* ... but not for min values */
		if (x->v.mantissa0 == 0x80000000UL && x->v.mantissa1 == 0x00000000)
			return 1;
		return 0;
	}
	/*
	 * skip tests whos exponent exceeds the range for doubles
	 */
	if (((x->v.exponent & IEEE854_LONG_DOUBLE_MAXEXP) - IEEE854_LONG_DOUBLE_BIAS + IEEE754_DOUBLE_BIAS) <= 0)
		return 1;
	if (((x->v.exponent & IEEE854_LONG_DOUBLE_MAXEXP) - IEEE854_LONG_DOUBLE_BIAS) >= (IEEE754_DOUBLE_MAXEXP - IEEE754_DOUBLE_BIAS))
		return 1;
	
	/* allow anything else */
	return 0;
}
#define SKIP_TEST(x, flags) skip_double_test(&(x), flags)
#endif

#ifdef TEST_FLOAT
__attribute__((__noinline__))
static int skip_float_test(const ld_union *x, flag_t flags)
{
	/*
	 * skip tests involving sub-normals for now,
	 * they are currently only designed for long doubles
	 */
	if (flags & (FLAG_SUBNORM|FLAG_MINVAL))
		return 1;
	/*
	 * allow tests involving infs and nans
	 */
	if ((x->v.exponent & IEEE854_LONG_DOUBLE_MAXEXP) == IEEE854_LONG_DOUBLE_MAXEXP)
		return 0;
	/*
	 * ... and zeroes
	 */
	if ((x->v.exponent & IEEE854_LONG_DOUBLE_MAXEXP) == 0)
	{
		/* ... but not for min values */
		if (x->v.mantissa0 == 0x80000000UL && x->v.mantissa1 == 0x00000000)
			return 1;
		return 0;
	}
	/*
	 * skip tests whos exponent exceeds the range for doubles
	 */
	if (((x->v.exponent & IEEE854_LONG_DOUBLE_MAXEXP) - IEEE854_LONG_DOUBLE_BIAS + IEEE754_FLOAT_BIAS) <= 0)
		return 1;
	if (((x->v.exponent & IEEE854_LONG_DOUBLE_MAXEXP) - IEEE854_LONG_DOUBLE_BIAS) >= (IEEE754_FLOAT_MAXEXP - IEEE754_FLOAT_BIAS))
		return 1;
	
	/* allow anything else */
	return 0;
}
#define SKIP_TEST(x, flags) skip_float_test(&(x), flags)
#endif

#ifdef TEST_LDOUBLE
#define SKIP_TEST(x, flags) 0
#endif


#if !defined(NO_PRINTF_DOUBLE)
/*
 * libcmini does not correctly print inf & NaN;
 * mintlib seems to be buggy with printing subnormal & low values
 */
static const char *print_ld(const ld_union *x)
{
	int sign = (x->v.exponent & 0x8000) != 0;
	static int nbuf = 0;
	static char buf[2][8000];		/* yes, it has to be that large; mintlib sometimes prints lots of digits */
	char *p;
	ld_union r;
	
	if ((x->v.exponent & IEEE854_LONG_DOUBLE_MAXEXP) == 0)
	{
		/*
		 * zero, or subnormal
		 */
		if (x->v.mantissa0 == 0 && x->v.mantissa1 == 0)
			return sign ? "-zero" : "+zero";
		return sign ? "-denorm" : "+denorm";
	} else if ((x->v.exponent & IEEE854_LONG_DOUBLE_MAXEXP) == IEEE854_LONG_DOUBLE_MAXEXP)
	{
		/* inf or nan */
 		if ((x->v.mantissa0 & 0x7fffffff) == 0 && x->v.mantissa1 == 0)
			return sign ? "-inf" : "+inf";
		if ((x->v.mantissa0 & 0x40000000L) == 0)
			return sign ? "-sNaN" : "+sNaN";
		return sign ? "-NaN" : "+NaN";
	} else if ((x->v.exponent & IEEE854_LONG_DOUBLE_MAXEXP) <= 0x0001 && !(x->v.mantissa0 & 0x80000000))
	{
		/*
		 * subnormal
		 */
		return sign ? "-denorm" : "+denorm";
	}
	/*
	 * hopefully some printable value now
	 */
	p = buf[nbuf];
	nbuf++;
	if (nbuf >= 2)
		nbuf = 0;
	/*
	 * avoid problems with impossible patterns
	 */
	r = *x;
	r.v.mantissa0 |= 0x80000000L;
#ifdef __AMIGA__
	sprintf(p, "%.22e", (double)r.x);
#else
	sprintf(p, "%.22Le", r.x);
#endif
	return p;
}

__attribute__((__noinline__))
static int check_fp(uint16_t exponent, uint32_t mant0, uint32_t mant1, const ld_union *f, int flags, int i, const char *file, int line)
{
	ld_union r;
	
#ifdef TEST_DOUBLE
	/* mask off the precision for double */
	if ((exponent & IEEE854_LONG_DOUBLE_MAXEXP) != IEEE854_LONG_DOUBLE_MAXEXP)
		mant1 &= ~((uint32_t)0x7ff);
#endif
	if (exponent == f->v.exponent && mant0 == f->v.mantissa0 && mant1 == f->v.mantissa1)
		return 0;
	if ((exponent & IEEE854_LONG_DOUBLE_MAXEXP) == 0 &&
		(flags & FLAG_IGNORE_ZEROSIGN) &&
		(f->v.exponent & IEEE854_LONG_DOUBLE_MAXEXP) == 0 &&
		mant0 == f->v.mantissa0 && mant1 == f->v.mantissa1)
		return 0;

	/*
	 * if we expect a nan, accept *any* value that would be interpreted as NaN
	 * (that is, any non-zero bit pattern in the mantissa)
	 */
	if ((exponent & IEEE854_LONG_DOUBLE_MAXEXP) == IEEE854_LONG_DOUBLE_MAXEXP && (f->v.exponent & IEEE854_LONG_DOUBLE_MAXEXP) == IEEE854_LONG_DOUBLE_MAXEXP)
	{
		if (((mant0 & 0x7fffffff) != 0 || mant1 != 0) && ((f->v.mantissa0 & 0x7fffffff) != 0 || f->v.mantissa1 != 0))
			return 0;
		if (((mant0 & 0x7fffffff) == 0 && mant1 == 0) && ((f->v.mantissa0 & 0x7fffffff) == 0 && f->v.mantissa1 == 0))
			return 0;
	}
	if (flags & (FLAG_INEXACT|FLAG_INEXACT2|FLAG_INEXACT3|FLAG_INEXACT4|FLAG_INEXACT5|FLAG_INEXACT_SUBNORM))
	{
#if ALLOW_INEXACT
		/*
		 * allow for inexactness in least-significant 2 bits
		 */
		int expdiff = (exponent & IEEE854_LONG_DOUBLE_MAXEXP) - (f->v.exponent & IEEE854_LONG_DOUBLE_MAXEXP);

		if ((flags & FLAG_INEXACT_SUBNORM) && (exponent & IEEE854_LONG_DOUBLE_MAXEXP) == 0 && exponent == f->v.exponent)
		{
			if ((f->v.mantissa0 & 0x7fffffff) == (mant0 & 0x7fffffff))
				return 0;
		} else if ((flags & FLAG_INEXACT_SUBNORM) && (exponent & IEEE854_LONG_DOUBLE_MAXEXP) == 1 && exponent == f->v.exponent)
		{
			if ((f->v.mantissa0 & 0x7fffffff) == (mant0 & 0x7fffffff) && (f->v.mantissa1 & 0xffff0000) == (mant1 & 0xffff0000))
				return 0;
		} else if ((flags & FLAG_INEXACT4) && expdiff == 0)
		{
			ld_union diffval, t;

			/*
			 * used for cos(x) with x near pi, which should yield values close to zero
			 */
			t = *f;
			diffval.v.mantissa0 = mant0;
			diffval.v.mantissa1 = mant1;
			diffval.v.exponent = 0x3fff;
			t.v.exponent = 0x3fff - expdiff;
			diffval.x -= t.x;
			diffval.v.exponent &= IEEE854_LONG_DOUBLE_MAXEXP;
			expdiff = 0x3fff - diffval.v.exponent;
			if (expdiff >= 2)
				return 0;
		} else if (expdiff == 1 || expdiff == -1)
		{
			ld_union diffval, t;

			t = *f;
			diffval.v.mantissa0 = mant0;
			diffval.v.mantissa1 = mant1;
			diffval.v.exponent = 0x3fff;
			t.v.exponent = 0x3fff - expdiff;
			diffval.x -= t.x;
			diffval.v.exponent &= IEEE854_LONG_DOUBLE_MAXEXP;
			expdiff = 0x3fff - diffval.v.exponent;
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
			if (expdiff >= 60)
				return 0;
			if (flags & FLAG_INEXACT2)
				if (expdiff >= 57)
					return 0;
			if (flags & FLAG_INEXACT3)
				if (expdiff >= 54)
					return 0;
			if (flags & FLAG_INEXACT5)
				if (expdiff >= 51)
					return 0;
#endif
#if defined(TEST_DOUBLE) || (defined(TEST_LDOUBLE) && LDBL_MANT_DIG < 64)
			if (expdiff >= 49)
				return 0;
			if (flags & FLAG_INEXACT2)
				if (expdiff >= 46)
					return 0;
			if (flags & FLAG_INEXACT3)
				if (expdiff >= 43)
					return 0;
			if (flags & FLAG_INEXACT5)
				if (expdiff >= 40)
					return 0;
#endif
		} else if (expdiff == 0)
		{
			uint32_t diff;

			if (mant1 > f->v.mantissa1)
			{
				diff = mant1 - f->v.mantissa1;
			} else
			{
				diff = f->v.mantissa1 - mant1;
			}
			if (mant0 == (f->v.mantissa0 + 1))
				diff = -diff;
			else if (mant0 != f->v.mantissa0)
				diff = 0x7fffffff;
#if defined(TEST_LDOUBLE) && LDBL_MANT_DIG >= 64
			if (diff <= 4)
				return 0;
			if (flags & FLAG_INEXACT2)
				if (diff <= 32)
					return 0;
			if (flags & FLAG_INEXACT3)
				if (diff <= 128)
					return 0;
			if (flags & FLAG_INEXACT5)
				if (diff <= 1280)
					return 0;
#endif
#if defined(TEST_DOUBLE) || (defined(TEST_LDOUBLE) && LDBL_MANT_DIG < 64)
			if (diff <= (4 << 11))
				return 0;
			if (flags & FLAG_INEXACT2)
				if (diff <= (32 << 11))
					return 0;
			if (flags & FLAG_INEXACT3)
				if (diff <= (128 << 11))
					return 0;
			if (flags & FLAG_INEXACT5)
				if (diff <= (1280 << 11))
					return 0;
#endif
		}
#endif
	}
	if (flags & FLAG_SUBNORM)
	{
		if (!ALLOW_SUBNORM_MIN)
			return 0;
	}
	if (flags & FLAG_MINVAL)
	{
		if (!ALLOW_MINVAL)
			return 0;
	}
	if (flags & FLAG_XFAIL_LINUX)
	{
#ifdef __linux__
		return 0;
#endif
	}
	if (flags & FLAG_FAIL_X87)
	{
#if defined(__i386__) || defined(__x86_64__)
		return 0;
#endif
	}
	if (flags & (FLAG_FAIL_STONX|FLAG_FAIL_X87))
	{
		if (emulator == EMULATOR_STONX)
			return 0;
	}
#ifndef __HAVE_68881__
	if (flags & (FLAG_FAIL_SOFTFLOAT))
	{
		return 0;
	}
#endif
#ifdef __HAVE_68881__
	if (flags & (FLAG_FAIL_HARDFLOAT))
	{
		return 0;
	}
#endif
	if (flags & (FLAG_FAIL_ARANYM|FLAG_FAIL_ARANYM2|FLAG_FAIL_X87))
	{
		if (emulator == EMULATOR_ARANYM)
			return 0;
	}
	if (flags & (FLAG_XFAIL))
	{
		return 0;
	}
	if (flags & FLAG_FAIL_HATARI)
	{
		if (emulator == EMULATOR_HATARI)
			return 0;
	}
	r.v.exponent = exponent;
	r.v.mantissa0 = mant0;
	r.v.mantissa1 = mant1;
	fprintf(stderr, "%s:%d: test %d(%d):" CR "\n"
	                "  expected %04x:%08lx:%08lx (%s)" CR "\n"
	                "  got      %04x:%08lx:%08lx (%s)" CR "\n\n",
		file, line, numtests, i,
		exponent, (unsigned long)mant0, (unsigned long)mant1,
		print_ld(&r),
		f->v.exponent, (unsigned long)f->v.mantissa0, (unsigned long)f->v.mantissa1,
		print_ld(f));
	return 1;
}

#endif



#if defined(TEST_FUNC_F_I) || defined(TEST_FUNC_FF_I) || defined(TEST_FUNC_FIP_F) || defined(TEST_FUNC_FF_FI)
__attribute__((__noinline__))
static int check_int(int e, int f, int flags, int i, const char *file, int line)
{
	if (e == f)
		return 0;

	/*
	 * if we expect a nan, accept *any* value that would be interpreted as NaN
	 * (that is, any non-zero bit pattern in the mantissa)
	 */
	if (flags & FLAG_SUBNORM)
	{
		if (!ALLOW_SUBNORM_MIN)
			return 0;
	}
	if (flags & FLAG_MINVAL)
	{
		if (!ALLOW_MINVAL)
			return 0;
	}
	if (flags & FLAG_XFAIL_LINUX)
	{
#ifdef __linux__
		return 0;
#endif
	}
	if (flags & FLAG_FAIL_X87)
	{
#if defined(__i386__) || defined(__x86_64__)
		return 0;
#endif
	}
	if (flags & (FLAG_FAIL_STONX|FLAG_FAIL_X87))
	{
		if (emulator == EMULATOR_STONX)
			return 0;
	}
#ifndef __HAVE_68881__
	if (flags & (FLAG_FAIL_SOFTFLOAT))
	{
		return 0;
	}
#endif
#ifdef __HAVE_68881__
	if (flags & (FLAG_FAIL_HARDFLOAT))
	{
		return 0;
	}
#endif
	if (flags & (FLAG_FAIL_ARANYM|FLAG_FAIL_ARANYM2|FLAG_FAIL_X87))
	{
		if (emulator == EMULATOR_ARANYM)
			return 0;
	}
	if (flags & (FLAG_XFAIL))
	{
		return 0;
	}
	if (flags & FLAG_FAIL_HATARI)
	{
		if (emulator == EMULATOR_HATARI)
			return 0;
	}
	fprintf(stderr, "%s:%d: test %d(%d): expected %d got %d" CR "\n",
		file, line, numtests, i,
		e, f);
	return 1;
}
#endif


#if defined(TEST_FUNC_F_L)
__attribute__((__noinline__))
static int check_long(long e, long f, int flags, int i, const char *file, int line)
{
	if (e == f)
		return 0;

	/*
	 * if we expect a nan, accept *any* value that would be interpreted as NaN
	 * (that is, any non-zero bit pattern in the mantissa)
	 */
	if (flags & FLAG_SUBNORM)
	{
		if (!ALLOW_SUBNORM_MIN)
			return 0;
	}
	if (flags & FLAG_MINVAL)
	{
		if (!ALLOW_MINVAL)
			return 0;
	}
	if (flags & FLAG_XFAIL_LINUX)
	{
#ifdef __linux__
		return 0;
#endif
	}
	if (flags & FLAG_FAIL_X87)
	{
#if defined(__i386__) || defined(__x86_64__)
		return 0;
#endif
	}
	if (flags & (FLAG_FAIL_STONX|FLAG_FAIL_X87))
	{
		if (emulator == EMULATOR_STONX)
			return 0;
	}
#ifndef __HAVE_68881__
	if (flags & (FLAG_FAIL_SOFTFLOAT))
	{
		return 0;
	}
#endif
#ifdef __HAVE_68881__
	if (flags & (FLAG_FAIL_HARDFLOAT))
	{
		return 0;
	}
#endif
	if (flags & (FLAG_FAIL_ARANYM|FLAG_FAIL_ARANYM2|FLAG_FAIL_X87))
	{
		if (emulator == EMULATOR_ARANYM)
			return 0;
	}
	if (flags & (FLAG_XFAIL))
	{
		return 0;
	}
	if (flags & FLAG_FAIL_HATARI)
	{
		if (emulator == EMULATOR_HATARI)
			return 0;
	}
	fprintf(stderr, "%s:%d: test %d(%d): expected %ld got %ld" CR "\n",
		file, line, numtests, i,
		e, f);
	return 1;
}
#endif


#if defined(TEST_FUNC_F_LL)
__attribute__((__noinline__))
static int check_longlong(long long e, long long f, int flags, int i, const char *file, int line)
{
	if (e == f)
		return 0;

	/*
	 * if we expect a nan, accept *any* value that would be interpreted as NaN
	 * (that is, any non-zero bit pattern in the mantissa)
	 */
	if (flags & FLAG_SUBNORM)
	{
		if (!ALLOW_SUBNORM_MIN)
			return 0;
	}
	if (flags & FLAG_MINVAL)
	{
		if (!ALLOW_MINVAL)
			return 0;
	}
	if (flags & FLAG_XFAIL_LINUX)
	{
#ifdef __linux__
		return 0;
#endif
	}
	if (flags & FLAG_FAIL_X87)
	{
#if defined(__i386__) || defined(__x86_64__)
		return 0;
#endif
	}
	if (flags & (FLAG_FAIL_STONX|FLAG_FAIL_X87))
	{
		if (emulator == EMULATOR_STONX)
			return 0;
	}
#ifndef __HAVE_68881__
	if (flags & (FLAG_FAIL_SOFTFLOAT))
	{
		return 0;
	}
#endif
#ifdef __HAVE_68881__
	if (flags & (FLAG_FAIL_HARDFLOAT))
	{
		return 0;
	}
#endif
	if (flags & (FLAG_FAIL_ARANYM|FLAG_FAIL_ARANYM2|FLAG_FAIL_X87))
	{
		if (emulator == EMULATOR_ARANYM)
			return 0;
	}
	if (flags & (FLAG_XFAIL))
	{
		return 0;
	}
	if (flags & FLAG_FAIL_HATARI)
	{
		if (emulator == EMULATOR_HATARI)
			return 0;
	}
	fprintf(stderr, "%s:%d: test %d(%d): expected %ld got %ld" CR "\n",
		file, line, numtests, i,
		e, f);
	return 1;
}
#endif


#define EXPECT_FP_FLAGS(f, exp, mant0, mant1, flags) \
	this_fail = check_fp(exp, mant0, mant1, &f, flags, i, __FILE__, __LINE__); \
	status |= this_fail != 0

#define EXPECT_FP(f, exp, mant0, mant1) EXPECT_FP_FLAGS(f, exp, mant0, mant1, 0)

#define EXPECT_FP_CONST(f, c) EXPECT_FP(f, c.v.exponent, c.v.mantissa0, c.v.mantissa1)

#define EXPECT_FP_CONST_FLAGS(f, c, flags) EXPECT_FP_FLAGS(f, c.v.exponent, c.v.mantissa0, c.v.mantissa1, flags)

#ifdef __HAVE_68881__
#define EXPECT_FAIL_68881 if (((flags) & (FLAG_FAIL_ARANYM|FLAG_FAIL_ARANYM2|FLAG_FAIL_X87)) && (emulator == EMULATOR_ARANYM)) this_fail = 0
#else
#define EXPECT_FAIL_68881
#endif

#define EXPECT_FLAGS(r, v, flags) \
	this_fail = ((r) != (v)); \
	if (((flags) & (FLAG_FAIL_STONX|FLAG_FAIL_X87)) && (emulator == EMULATOR_STONX)) this_fail = 0; \
	EXPECT_FAIL_68881; \
	if (((flags) & (FLAG_FAIL_HATARI|FLAG_FAIL_X87)) && (emulator == EMULATOR_HATARI)) this_fail = 0; \
	if (this_fail) \
	{ \
		fprintf(stderr, "%s:%d: test %d(%d): expected 0x%08lx, got 0x%08lx" CR "\n", __FILE__, __LINE__, numtests, i, v, r); \
		status |= this_fail != 0; \
	}

#define EXPECT(r, v) EXPECT_FLAGS(r, v, 0)


#ifdef TEST_FUNC_F_F

/*
 * body for monadic operations:
 * fabs, facos, fasin, fatan, fatanh, fcos, fcosh,
 * fetox, fetoxm1, fgetexp, fgetman, fint, fintrz,
 * flog10, flog2, flogn, flognp1, fneg,
 * fsinh, fsqrt, ftan, ftanh, ftentox, ftst, ftwotox
 */
#ifdef TEST_LDOUBLE
#define TEST_OP_BODY_F_F(_x) fp0.x = TEST_FUNC_F_F(_x.x)
#endif
#ifdef TEST_DOUBLE
#define TEST_OP_BODY_F_F(_x) fp0.x = my_extenddfxf2(TEST_FUNC_F_F(my_truncxfdf2(_x.x)))
#endif
#ifdef TEST_FLOAT
#define TEST_OP_BODY_F_F(_x) fp0.x = my_extendsfxf2(TEST_FUNC_F_F(my_truncxfsf2(_x.x)))
#endif

#define TEST_CONST_FLAGS(_x, e, flags) \
	++numtests; \
	if (!SKIP_TEST(_x, flags)) \
	{ \
		for (i = 0; i < jit_loops; i++) \
		{ \
			TEST_OP_BODY_F_F(_x); \
			EXPECT_FP_CONST_FLAGS(fp0, e, flags); \
			if (this_fail) break; \
		} \
	}

#define TEST_CONST(v, e) TEST_CONST_FLAGS(v, e, 0)

#endif


#ifdef TEST_FUNC_F_I
/*
 * body for monadic operations returning int:
 * ilogb
 */

#ifdef TEST_LDOUBLE
#define TEST_OP_BODY_F_I(_x) x = TEST_FUNC_F_I(_x.x)
#endif
#ifdef TEST_DOUBLE
#define TEST_OP_BODY_F_I(_x) x = TEST_FUNC_F_I(my_truncxfdf2(_x.x))
#endif
#ifdef TEST_FLOAT
#define TEST_OP_BODY_F_I(_x) x = TEST_FUNC_F_I(my_truncxfsf2(_x.x))
#endif
#endif


#ifdef TEST_FUNC_FF_I
/*
 * body for dyadic operations returning int:
 * isunordered etc.
 */

#ifdef TEST_LDOUBLE
#define TEST_OP_BODY_FF_I(_x, _y) x = TEST_FUNC_FF_I(_x.x, _y.x)
#endif
#ifdef TEST_DOUBLE
#define TEST_OP_BODY_FF_I(_x, _y) x = TEST_FUNC_FF_I(my_truncxfdf2(_x.x), my_truncxfdf2(_y.x))
#endif
#ifdef TEST_FLOAT
#define TEST_OP_BODY_FF_I(_x, _y) x = TEST_FUNC_FF_I(my_truncxfsf2(_x.x), my_truncxfsf2(_y.x))
#endif
#endif


#ifdef TEST_FUNC_F_L
/*
 * body for monadic operations returning long:
 * lround, lrint
 */

#ifdef TEST_LDOUBLE
#define TEST_OP_BODY_F_L(_x) x = TEST_FUNC_F_L(_x.x)
#endif
#ifdef TEST_DOUBLE
#define TEST_OP_BODY_F_L(_x) x = TEST_FUNC_F_L(my_truncxfdf2(_x.x))
#endif
#ifdef TEST_FLOAT
#define TEST_OP_BODY_F_L(_x) x = TEST_FUNC_F_L(my_truncxfsf2(_x.x))
#endif
#endif


#ifdef TEST_FUNC_F_LL
/*
 * body for monadic operations returning long long:
 * llrint
 */

#ifdef TEST_LDOUBLE
#define TEST_OP_BODY_F_LL(_x) x = TEST_FUNC_F_LL(_x.x)
#endif
#ifdef TEST_DOUBLE
#define TEST_OP_BODY_F_LL(_x) x = TEST_FUNC_F_LL(my_truncxfdf2(_x.x))
#endif
#ifdef TEST_FLOAT
#define TEST_OP_BODY_F_LL(_x) x = TEST_FUNC_F_LL(my_truncxfsf2(_x.x))
#endif
#endif


#ifdef TEST_FUNC_FF_F
/*
 * body for dyadic operations:
 * fadd, fcmp, fdiv, fmod, fmul, frem,
 * fscale, fsgldiv, fsglmul, fsub
 */
#ifdef TEST_LDOUBLE
#define TEST_OP_BODY_FF_F(_x, _y) fp0.x = TEST_FUNC_FF_F(_x.x, _y.x)
#endif
#ifdef TEST_DOUBLE
#define TEST_OP_BODY_FF_F(_x, _y) fp0.x = my_extenddfxf2(TEST_FUNC_FF_F(my_truncxfdf2(_x.x), my_truncxfdf2(_y.x)))
#endif
#ifdef TEST_FLOAT
#define TEST_OP_BODY_FF_F(_x, _y) fp0.x = my_extendsfxf2(TEST_FUNC_FF_F(my_truncxfsf2(_x.x), my_truncxfsf2(_y.x)))
#endif

#define TEST_CONST_FLAGS(_x, _y, e, flags) \
	++numtests; \
	if (!SKIP_TEST(_x, flags) && !SKIP_TEST(_y, flags)) \
	{ \
		for (i = 0; i < jit_loops; i++) \
		{ \
			TEST_OP_BODY_FF_F(_x, _y); \
			EXPECT_FP_CONST_FLAGS(fp0, e, flags); \
			if (this_fail) break; \
		} \
	}

#endif


#ifdef TEST_FUNC_FFL_F
/*
 * body for dyadic operations, with long double 2nd arg:
 * nexttoward
 */
#ifdef TEST_LDOUBLE
#define TEST_OP_BODY_FFL_F(_x, _y) fp0.x = TEST_FUNC_FFL_F(_x.x, _y.x)
#endif
#ifdef TEST_DOUBLE
#define TEST_OP_BODY_FFL_F(_x, _y) fp0.x = my_extenddfxf2(TEST_FUNC_FFL_F(my_truncxfdf2(_x.x), _y.x))
#endif
#ifdef TEST_FLOAT
#define TEST_OP_BODY_FFL_F(_x, _y) fp0.x = my_extendsfxf2(TEST_FUNC_FFL_F(my_truncxfsf2(_x.x), _y.x))
#endif

#define TEST_CONST_FLAGS(_x, _y, e, flags) \
	++numtests; \
	if (!SKIP_TEST(_x, flags) && !SKIP_TEST(_y, flags)) \
	{ \
		for (i = 0; i < jit_loops; i++) \
		{ \
			TEST_OP_BODY_FFL_F(_x, _y); \
			EXPECT_FP_CONST_FLAGS(fp0, e, flags); \
			if (this_fail) break; \
		} \
	}

#endif


#ifdef TEST_FUNC_FFF_F
/*
 * body for triadic operations:
 * fma
 */
#ifdef TEST_LDOUBLE
#define TEST_OP_BODY_FFF_F(_x, _y, _z) fp0.x = TEST_FUNC_FFF_F(_x.x, _y.x, _z.x)
#endif
#ifdef TEST_DOUBLE
#define TEST_OP_BODY_FFF_F(_x, _y, _z) fp0.x = my_extenddfxf2(TEST_FUNC_FFF_F(my_truncxfdf2(_x.x), my_truncxfdf2(_y.x), my_truncxfdf2(_z.x)))
#endif
#ifdef TEST_FLOAT
#define TEST_OP_BODY_FFF_F(_x, _y, _z) fp0.x = my_extendsfxf2(TEST_FUNC_FFF_F(my_truncxfsf2(_x.x), my_truncxfsf2(_y.x), my_truncxfsf2(_z.x)))
#endif
#endif


#ifdef TEST_FUNC_F_FFP
#ifdef TEST_LDOUBLE
#define TEST_OP_BODY_F_FFP(_x) r.x = TEST_FUNC_F_FFP(_x.x, &r2.x)
#endif
#ifdef TEST_DOUBLE
#define TEST_OP_BODY_F_FFP(_x) r.x = my_extenddfxf2(TEST_FUNC_F_FFP(my_truncxfdf2(_x.x), &r2.d)), r2.x = my_extenddfxf2(r2.d)
#endif
#ifdef TEST_FLOAT
#define TEST_OP_BODY_F_FFP(_x) r.x = my_extendsfxf2(TEST_FUNC_F_FFP(my_truncxfsf2(_x.x), &r2.s)), r2.x = my_extendsfxf2(r2.s)
#endif
#endif


#ifdef TEST_FUNC_FIP_F
#ifdef TEST_LDOUBLE
#define TEST_OP_BODY_FIP_F(_x) fp0.x = TEST_FUNC_FIP_F(_x.x, &exp)
#endif
#ifdef TEST_DOUBLE
#define TEST_OP_BODY_FIP_F(_x) fp0.x = my_extenddfxf2(TEST_FUNC_FIP_F(my_truncxfdf2(_x.x), &exp))
#endif
#ifdef TEST_FLOAT
#define TEST_OP_BODY_FIP_F(_x) fp0.x = my_extendsfxf2(TEST_FUNC_FIP_F(my_truncxfsf2(_x.x), &exp))
#endif
#endif


#ifdef TEST_FUNC_FI_F
#ifdef TEST_LDOUBLE
#define TEST_OP_BODY_FI_F(_x, exp) fp0.x = TEST_FUNC_FI_F(_x.x, exp)
#endif
#ifdef TEST_DOUBLE
#define TEST_OP_BODY_FI_F(_x, exp) fp0.x = my_extenddfxf2(TEST_FUNC_FI_F(my_truncxfdf2(_x.x), exp))
#endif
#ifdef TEST_FLOAT
#define TEST_OP_BODY_FI_F(_x, exp) fp0.x = my_extendsfxf2(TEST_FUNC_FI_F(my_truncxfsf2(_x.x), exp))
#endif
#endif


#ifdef TEST_FUNC_FL_F
#ifdef TEST_LDOUBLE
#define TEST_OP_BODY_FL_F(_x, exp) fp0.x = TEST_FUNC_FL_F(_x.x, exp)
#endif
#ifdef TEST_DOUBLE
#define TEST_OP_BODY_FL_F(_x, exp) fp0.x = my_extenddfxf2(TEST_FUNC_FL_F(my_truncxfdf2(_x.x), exp))
#endif
#ifdef TEST_FLOAT
#define TEST_OP_BODY_FL_F(_x, exp) fp0.x = my_extendsfxf2(TEST_FUNC_FL_F(my_truncxfsf2(_x.x), exp))
#endif
#endif


#ifdef TEST_FUNC_F_FF
/*
 * body for sincos which returns two values
 */
#ifdef TEST_LDOUBLE
#define TEST_OP_BODY_F_FF(_x, _r1, _r2) fp0.x = _x.x, TEST_FUNC_F_FF(fp0.x, &(_r1.x), &(_r2.x))
#endif
#ifdef TEST_DOUBLE
#define TEST_OP_BODY_F_FF(_x, _r1, _r2) fp0.d = my_truncxfdf2(_x.x), TEST_FUNC_F_FF(fp0.d, &(_r1.d), &(_r2.d)), _r1.x = my_extenddfxf2(_r1.d), _r2.x = my_extenddfxf2(_r2.d)
#endif
#ifdef TEST_FLOAT
#define TEST_OP_BODY_F_FF(_x, _r1, _r2) fp0.s = my_truncxfsf2(_x.x), TEST_FUNC_F_FF(fp0.s, &(_r1.s), &(_r2.s)), _r1.x = my_extendsfxf2(_r1.d), _r2.x = my_extendsfxf2(_r2.d)
#endif

#endif


#ifdef TEST_FUNC_IF_F
#ifdef TEST_LDOUBLE
#define TEST_OP_BODY_IF_F(_i, _x) fp0.x = TEST_FUNC_IF_F(_i, _x.x)
#endif
#ifdef TEST_DOUBLE
#define TEST_OP_BODY_IF_F(_i, _x) fp0.x = my_extenddfxf2(TEST_FUNC_IF_F(_i, my_truncxfdf2(_x.x)))
#endif
#ifdef TEST_FLOAT
#define TEST_OP_BODY_IF_F(_i, _x) fp0.x = my_extendsfxf2(TEST_FUNC_IF_F(_i, my_truncxfsf2(_x.x)))
#endif
#endif


#if !defined(NO_PRINTF_DOUBLE)
#if defined(TEST_FUNC_F_F)

static int test_table_f_f(const test_f_f_data *data, size_t n, const char *file)
{
	size_t l;
	int i;
	int status = 0, this_fail;
	ld_union fp0;
	
	for (l = 0; l < n; l++)
	{
		numtests++;
		if (!SKIP_TEST(data[l].x, data[l].flags))
		{
			if (testonly == 0 || testonly == numtests)
			{
				for (i = 0; i < jit_loops; i++)
				{
					TEST_OP_BODY_F_F(data[l].x);
					this_fail = check_fp(data[l].e.v.exponent, data[l].e.v.mantissa0, data[l].e.v.mantissa1, &fp0, data[l].flags, i, file, data[l].line);
					if (this_fail)
					{
						status |= this_fail != 0;
						break;
					}
				}
			}
		}
	}
	
	return status;
}
#endif


#if defined(TEST_FUNC_IF_F)

static int test_table_if_f(const test_if_f_data *data, size_t n, const char *file)
{
	size_t l;
	int i;
	int status = 0, this_fail;
	ld_union fp0;
	
	for (l = 0; l < n; l++)
	{
		numtests++;
		if (!SKIP_TEST(data[l].x, data[l].flags))
		{
			if (testonly == 0 || testonly == numtests)
			{
				for (i = 0; i < jit_loops; i++)
				{
					TEST_OP_BODY_IF_F(data[l].i, data[l].x);
					this_fail = check_fp(data[l].e.v.exponent, data[l].e.v.mantissa0, data[l].e.v.mantissa1, &fp0, data[l].flags, i, file, data[l].line);
					if (this_fail)
					{
						status |= this_fail != 0;
						break;
					}
				}
			}
		}
	}
	
	return status;
}
#endif


#if defined(TEST_FUNC_F_I)

static int test_table_f_i(const test_f_i_data *data, size_t n, const char *file)
{
	size_t l;
	int i;
	int status = 0, this_fail;
	int x;

	for (l = 0; l < n; l++)
	{
		numtests++;
		if (!SKIP_TEST(data[l].x, data[l].flags))
		{
			if (testonly == 0 || testonly == numtests)
			{
				for (i = 0; i < jit_loops; i++)
				{
					TEST_OP_BODY_F_I(data[l].x);
#ifdef INT_IS_BOOL
					x = x != 0;
#endif
					this_fail = check_int(data[l].e, x, data[l].flags, i, file, data[l].line);
					if (this_fail)
					{
						status |= this_fail != 0;
						break;
					}
				}
			}
		}
	}

	return status;
}

#endif


#if defined(TEST_FUNC_FF_I)

static int test_table_ff_i(const test_ff_i_data *data, size_t n, const char *file)
{
	size_t l;
	int i;
	int status = 0, this_fail;
	int x;

	for (l = 0; l < n; l++)
	{
		numtests++;
		if (!SKIP_TEST(data[l].x, data[l].flags) &&
			!SKIP_TEST(data[l].y, data[l].flags))
		{
			if (testonly == 0 || testonly == numtests)
			{
				for (i = 0; i < jit_loops; i++)
				{
					TEST_OP_BODY_FF_I(data[l].x, data[l].y);
#ifdef INT_IS_BOOL
					x = x != 0;
#endif
					this_fail = check_int(data[l].e, x, data[l].flags, i, file, data[l].line);
					if (this_fail)
					{
						status |= this_fail != 0;
						break;
					}
				}
			}
		}
	}

	return status;
}

#endif


#if defined(TEST_FUNC_F_L)

static int test_table_f_l(const test_f_l_data *data, size_t n, const char *file)
{
	size_t l;
	int i;
	int status = 0, this_fail;
	long x;

	for (l = 0; l < n; l++)
	{
		numtests++;
		if (!SKIP_TEST(data[l].x, data[l].flags))
		{
			if (testonly == 0 || testonly == numtests)
			{
				for (i = 0; i < jit_loops; i++)
				{
					TEST_OP_BODY_F_L(data[l].x);
					this_fail = check_long(data[l].e, x, data[l].flags, i, file, data[l].line);
					if (this_fail)
					{
						status |= this_fail != 0;
						break;
					}
				}
			}
		}
	}

	return status;
}

#endif


#if defined(TEST_FUNC_F_LL)

static int test_table_f_ll(const test_f_ll_data *data, size_t n, const char *file)
{
	size_t l;
	int i;
	int status = 0, this_fail;
	long long x;

	for (l = 0; l < n; l++)
	{
		numtests++;
		if (!SKIP_TEST(data[l].x, data[l].flags))
		{
			if (testonly == 0 || testonly == numtests)
			{
				for (i = 0; i < jit_loops; i++)
				{
					TEST_OP_BODY_F_LL(data[l].x);
					this_fail = check_longlong(data[l].e, x, data[l].flags, i, file, data[l].line);
					if (this_fail)
					{
						status |= this_fail != 0;
						break;
					}
				}
			}
		}
	}

	return status;
}

#endif


#if defined(TEST_FUNC_FF_F)

static int test_table_ff_f(const test_ff_f_data *data, size_t n, const char *file)
{
	size_t l;
	int i;
	int status = 0, this_fail;
	ld_union fp0;
	
	for (l = 0; l < n; l++)
	{
		numtests++;
		if (!SKIP_TEST(data[l].x, data[l].flags) && !SKIP_TEST(data[l].y, data[l].flags))
		{
			if (testonly == 0 || testonly == numtests)
			{
				for (i = 0; i < jit_loops; i++)
				{
					TEST_OP_BODY_FF_F(data[l].x, data[l].y);
					this_fail = check_fp(data[l].e.v.exponent, data[l].e.v.mantissa0, data[l].e.v.mantissa1, &fp0, data[l].flags, i, file, data[l].line);
					if (this_fail)
					{
						status |= this_fail != 0;
						break;
					}
				}
			}
		}
	}
	
	return status;
}

#endif
	

#if defined(TEST_FUNC_FFL_F)

static int test_table_ffl_f(const test_ff_f_data *data, size_t n, const char *file)
{
	size_t l;
	int i;
	int status = 0, this_fail;
	ld_union fp0;
	
	for (l = 0; l < n; l++)
	{
		numtests++;
		if (!SKIP_TEST(data[l].x, data[l].flags) && !SKIP_TEST(data[l].y, data[l].flags))
		{
			if (testonly == 0 || testonly == numtests)
			{
				for (i = 0; i < jit_loops; i++)
				{
					TEST_OP_BODY_FFL_F(data[l].x, data[l].y);
					this_fail = check_fp(data[l].e.v.exponent, data[l].e.v.mantissa0, data[l].e.v.mantissa1, &fp0, data[l].flags, i, file, data[l].line);
					if (this_fail)
					{
						status |= this_fail != 0;
						break;
					}
				}
			}
		}
	}
	
	return status;
}

#endif
	

#if defined(TEST_FUNC_FFF_F)

static int test_table_fff_f(const test_fff_f_data *data, size_t n, const char *file)
{
	size_t l;
	int i;
	int status = 0, this_fail;
	ld_union fp0;
	
	for (l = 0; l < n; l++)
	{
		numtests++;
		if (!SKIP_TEST(data[l].a, data[l].flags) &&
			!SKIP_TEST(data[l].b, data[l].flags) &&
			!SKIP_TEST(data[l].c, data[l].flags))
		{
			if (testonly == 0 || testonly == numtests)
			{
				for (i = 0; i < jit_loops; i++)
				{
					TEST_OP_BODY_FFF_F(data[l].a, data[l].b, data[l].c);
					this_fail = check_fp(data[l].e.v.exponent, data[l].e.v.mantissa0, data[l].e.v.mantissa1, &fp0, data[l].flags, i, file, data[l].line);
					if (this_fail)
					{
						status |= this_fail != 0;
						break;
					}
				}
			}
		}
	}
	
	return status;
}

#endif
	

#if defined(TEST_FUNC_F_FFP)

static int test_table_f_ffp(const test_f_ffp_data *data, size_t n, const char *file)
{
	size_t l;
	int i;
	int status = 0, this_fail;
	ld_union r, r2;
	
	for (l = 0; l < n; l++)
	{
		numtests++;
		if (!SKIP_TEST(data[l].x, data[l].flags))
		{
			if (testonly == 0 || testonly == numtests)
			{
				for (i = 0; i < jit_loops; i++)
				{
					TEST_OP_BODY_F_FFP(data[l].x);
					this_fail = check_fp(data[l].e.v.exponent, data[l].e.v.mantissa0, data[l].e.v.mantissa1, &r, data[l].flags, i, file, data[l].line);
					this_fail |= check_fp(data[l].e2.v.exponent, data[l].e2.v.mantissa0, data[l].e2.v.mantissa1, &r2, data[l].flags, i, file, data[l].line);
					if (this_fail)
					{
						status |= this_fail != 0;
						break;
					}
				}
			}
		}
	}
	
	return status;
}

#endif
	

#if defined(TEST_FUNC_F_FF)

static int test_table_f_ff(const test_f_ff_data *data, size_t n, const char *file)
{
	size_t l;
	int i;
	int status = 0, this_fail;
	ld_union fp0;
	ld_union fp1;
	ld_union fp2;
	
	for (l = 0; l < n; l++)
	{
		numtests++;
		if (!SKIP_TEST(data[l].x, data[l].flags))
		{
			if (testonly == 0 || testonly == numtests)
			{
				for (i = 0; i < jit_loops; i++)
				{
					TEST_OP_BODY_F_FF(data[l].x, fp1, fp2);
					this_fail = check_fp(data[l].r1.v.exponent, data[l].r1.v.mantissa0, data[l].r1.v.mantissa1, &fp1, data[l].flags, i, file, data[l].line);
					this_fail |= check_fp(data[l].r2.v.exponent, data[l].r2.v.mantissa0, data[l].r2.v.mantissa1, &fp2, data[l].flags, i, file, data[l].line);
					if (this_fail)
					{
						status |= this_fail != 0;
						break;
					}
				}
			}
		}
	}
	
	return status;
}

#endif

#if defined(TEST_FUNC_FIP_F)

static int test_table_fip_f(const test_fip_f_data *data, size_t n, const char *file)
{
	size_t l;
	int i;
	int status = 0, this_fail;
	ld_union fp0;
	int exp;
	
	for (l = 0; l < n; l++)
	{
		numtests++;
		if (!SKIP_TEST(data[l].x, data[l].flags))
		{
			if (testonly == 0 || testonly == numtests)
			{
				for (i = 0; i < jit_loops; i++)
				{
					exp = 0;
					TEST_OP_BODY_FIP_F(data[l].x);
					if ((data[l].x.v.exponent & IEEE854_LONG_DOUBLE_MAXEXP) == IEEE854_LONG_DOUBLE_MAXEXP)
						exp = 0;
					this_fail = check_fp(data[l].e.v.exponent, data[l].e.v.mantissa0, data[l].e.v.mantissa1, &fp0, data[l].flags, i, file, data[l].line);
					this_fail |= check_int(data[l].exp, exp, data[l].flags, i, file, data[l].line);
					if (this_fail)
					{
						status |= this_fail != 0;
						break;
					}
				}
			}
		}
	}
	
	return status;
}
#endif


#if defined(TEST_FUNC_FI_F)

static int test_table_fi_f(const test_fi_f_data *data, size_t n, const char *file)
{
	size_t l;
	int i;
	int status = 0, this_fail;
	ld_union fp0;
	
	for (l = 0; l < n; l++)
	{
		numtests++;
		if (!SKIP_TEST(data[l].x, data[l].flags))
		{
			if (testonly == 0 || testonly == numtests)
			{
				for (i = 0; i < jit_loops; i++)
				{
					TEST_OP_BODY_FI_F(data[l].x, data[l].exp);
					this_fail = check_fp(data[l].e.v.exponent, data[l].e.v.mantissa0, data[l].e.v.mantissa1, &fp0, data[l].flags, i, file, data[l].line);
					if (this_fail)
					{
						status |= this_fail != 0;
						break;
					}
				}
			}
		}
	}
	
	return status;
}
#endif


#if defined(TEST_FUNC_FL_F)

static int test_table_fl_f(const test_fl_f_data *data, size_t n, const char *file)
{
	size_t l;
	int i;
	int status = 0, this_fail;
	ld_union fp0;
	
	for (l = 0; l < n; l++)
	{
		numtests++;
		if (!SKIP_TEST(data[l].x, data[l].flags))
		{
			if (testonly == 0 || testonly == numtests)
			{
				for (i = 0; i < jit_loops; i++)
				{
					TEST_OP_BODY_FL_F(data[l].x, data[l].exp);
					this_fail = check_fp(data[l].e.v.exponent, data[l].e.v.mantissa0, data[l].e.v.mantissa1, &fp0, data[l].flags, i, file, data[l].line);
					if (this_fail)
					{
						status |= this_fail != 0;
						break;
					}
				}
			}
		}
	}
	
	return status;
}
#endif


#endif


/*
 * enable:
 *   -1: query only
 *   0/1: disable/enable
 * returns:
 *   previous state as 0/1, or -1 if JIT is not available
 */
static __inline int jit_state(int enable)
{
	register long state __asm__("d0");
	
	__asm__ __volatile__(
		"\t.dc.w 0x713b\n" /* M68K_EMUL_OP_JIT */
		: "=d"(state)
		: "0"(enable)
		: "cc", "memory");
	return state;
}


/* Exception Enable Byte */
#define		FPCR_EXCEPTION_ENABLE	0x0000ff00
#define		FPCR_EXCEPTION_BSUN		0x00008000
#define		FPCR_EXCEPTION_SNAN		0x00004000
#define		FPCR_EXCEPTION_OPERR	0x00002000
#define		FPCR_EXCEPTION_OVFL		0x00001000
#define		FPCR_EXCEPTION_UNFL		0x00000800
#define		FPCR_EXCEPTION_DZ		0x00000400
#define		FPCR_EXCEPTION_INEX2	0x00000200
#define		FPCR_EXCEPTION_INEX1	0x00000100

/* Rounding precision */
#define		FPCR_ROUNDING_PRECISION	0x000000c0
#define		FPCR_PRECISION_SINGLE	0x00000040
#define		FPCR_PRECISION_DOUBLE	0x00000080
#define		FPCR_PRECISION_EXTENDED	0x00000000

/* Rounding mode */
#define		FPCR_ROUNDING_MODE		0x00000030
#define		FPCR_ROUND_NEAR			0x00000000
#define		FPCR_ROUND_ZERO			0x00000010
#define		FPCR_ROUND_MINF			0x00000020
#define		FPCR_ROUND_PINF			0x00000030
	
/* Floating-Point Condition Code Byte */
#define		FPSR_CCB				0x0f000000
#define		FPSR_CCB_NEGATIVE		0x08000000
#define		FPSR_CCB_ZERO			0x04000000
#define		FPSR_CCB_INFINITY		0x02000000
#define		FPSR_CCB_NAN			0x01000000

/* Quotient Byte */
#define		FPSR_QUOTIENT			0x00ff0000
#define		FPSR_QUOTIENT_SIGN		0x00800000
#define		FPSR_QUOTIENT_VALUE		0x007f0000

/* Exception Status Byte */
#define		FPSR_EXCEPTION			FPCR_EXCEPTION_ENABLE
#define		FPSR_EXCEPTION_BSUN		FPCR_EXCEPTION_BSUN
#define		FPSR_EXCEPTION_SNAN		FPCR_EXCEPTION_SNAN
#define		FPSR_EXCEPTION_OPERR	FPCR_EXCEPTION_OPERR
#define		FPSR_EXCEPTION_OVFL		FPCR_EXCEPTION_OVFL
#define		FPSR_EXCEPTION_UNFL		FPCR_EXCEPTION_UNFL
#define		FPSR_EXCEPTION_DZ		FPCR_EXCEPTION_DZ
#define		FPSR_EXCEPTION_INEX2	FPCR_EXCEPTION_INEX2
#define		FPSR_EXCEPTION_INEX1	FPCR_EXCEPTION_INEX1

/* Accrued Exception Byte */
#define		FPSR_ACCRUED_EXCEPTION	0x000000f8
#define		FPSR_ACCR_IOP			0x00000080
#define		FPSR_ACCR_OVFL			0x00000040
#define		FPSR_ACCR_UNFL			0x00000020
#define		FPSR_ACCR_DZ			0x00000010
#define		FPSR_ACCR_INEX			0x00000008


#ifdef __mc68000__

static uint32_t get_fpcr(void)
{
#ifdef __HAVE_68881__
	uint32_t fpcr;
	
	__asm__ __volatile__(
		"\tfmove.l %%fpcr,%[fpcr]\n"
		: [fpcr]"=d"(fpcr)
		:
		: "cc", "memory");
	return fpcr;
#else
	return FPCR_PRECISION_DOUBLE|FPCR_ROUND_NEAR;
#endif
}

static void set_fpcr(uint32_t fpcr)
{
#ifdef __HAVE_68881__
	__asm__ __volatile__(
		"\tfmove.l %[fpcr],%%fpcr\n"
		:
		: [fpcr]"d"(fpcr)
		: "cc", "memory");
#else
	(void) fpcr;
#endif
}

#else

#include <fpu_control.h>
#include <fenv.h>
#include <stdlib.h>

static void set_fpcr(uint32_t fpcr)
{
	fpu_control_t cw;
	
	_FPU_GETCW(cw);
	cw &= ~(_FPU_RC_NEAREST|_FPU_RC_DOWN|_FPU_RC_UP|_FPU_RC_ZERO);
	cw &= ~(_FPU_EXTENDED|_FPU_DOUBLE|_FPU_SINGLE);
	switch (fpcr & FPCR_ROUNDING_MODE)
	{
	case FPCR_ROUND_NEAR:
		fesetround(1);
		cw |= _FPU_RC_NEAREST;
		break;
	case FPCR_ROUND_ZERO:
		fesetround(0);
		cw |= _FPU_RC_ZERO;
		break;
	case FPCR_ROUND_MINF:
		fesetround(3);
		cw |= _FPU_RC_DOWN;
		break;
	case FPCR_ROUND_PINF:
		fesetround(2);
		cw |= _FPU_RC_UP;
		break;
	default:
		abort();
	}
	switch (fpcr & FPCR_ROUNDING_PRECISION)
	{
		case FPCR_PRECISION_SINGLE: cw |= _FPU_SINGLE; break;
		case FPCR_PRECISION_DOUBLE: cw |= _FPU_DOUBLE; break;
		case FPCR_PRECISION_EXTENDED: cw |= _FPU_EXTENDED; break;
		default: abort();
	}
	_FPU_SETCW(cw);
}

static uint32_t get_fpcr(void)
{
	uint32_t fpcr = 0;
	fpu_control_t cw;
	
	_FPU_GETCW(cw);
	switch (cw & (_FPU_RC_NEAREST|_FPU_RC_DOWN|_FPU_RC_UP|_FPU_RC_ZERO))
	{
		case _FPU_RC_NEAREST: fpcr |= FPCR_ROUND_NEAR; break;
		case _FPU_RC_ZERO: fpcr |= FPCR_ROUND_ZERO; break;
		case _FPU_RC_DOWN: fpcr |= FPCR_ROUND_MINF; break;
		case _FPU_RC_UP: fpcr |= FPCR_ROUND_PINF; break;
	}
	switch (cw & (_FPU_EXTENDED|_FPU_DOUBLE|_FPU_SINGLE))
	{
		case _FPU_SINGLE: fpcr |= FPCR_PRECISION_SINGLE; break;
		case _FPU_DOUBLE: fpcr |= FPCR_PRECISION_DOUBLE; break;
		case _FPU_EXTENDED: fpcr |= FPCR_PRECISION_EXTENDED; break;
	}
	return fpcr;
}

#endif

static void set_precision(uint32_t prec)
{
	uint32_t fpcr;
	
	fpcr = get_fpcr();
	fpcr &= ~FPCR_ROUNDING_PRECISION;
	fpcr |= prec;
	set_fpcr(fpcr);
}


static void set_rounding(uint32_t rounding)
{
	uint32_t fpcr;
	
	fpcr = get_fpcr();
	fpcr &= ~FPCR_ROUNDING_MODE;
	fpcr |= rounding;
	set_fpcr(fpcr);
}

#if defined(__GNUC__) && defined(__mc68000__) && !defined(__mcoldfire__)

#define NATFEAT_ID   0x7300
#define NATFEAT_CALL 0x7301

#pragma GCC optimize "-fomit-frame-pointer"

#define ASM_NATFEAT3(opcode) "\t.word " #opcode "\n"
#define ASM_NATFEAT2(opcode) ASM_NATFEAT3(opcode)
#define ASM_NATFEAT(n) ASM_NATFEAT2(n)

static unsigned short const nf_id_opcodes[] = { NATFEAT_ID, 0x4e75 };
static unsigned short const nf_call_opcodes[] = { NATFEAT_CALL, 0x4e75 };

#define _nf_get_id(feature_name) ((long (__CDECL *)(const char *))nf_id_opcodes)(feature_name)
#define _nf_call(id, ...) ((long (__CDECL *)(long, ...))nf_call_opcodes)(id, __VA_ARGS__)



/*
 * on ColdFire, the NATFEAT_ID opcode is actually
 * "mvs.b d0,d1",
 * which means the following code will NOT detect
 * the presence of an emulator (should there ever
 * be an emulator capable of emulating a ColdFire processor).
 * Luckily, executing the code on a CF processor is still
 * harmless since all it does is clobber D1.
 */
static long _nf_detect_tos(void)
{
	register long ret __asm__ ("d0");
	register const char *nf_version __asm__("a1") = "NF_VERSION";
	
	__asm__ volatile(
	"\tmove.l	%1,-(%%sp)\n"
	"\tmoveq	#0,%%d0\n"			/* assume no NatFeats available */
	"\tmove.l	%%d0,-(%%sp)\n"
	"\tlea		(1f:w,%%pc),%%a1\n"
	"\tmove.l	(0x0010).w,%%a0\n"	/* illegal instruction vector */
	"\tmove.l	%%a1,(0x0010).w\n"
	"\tmove.l	%%sp,%%a1\n"		/* save the ssp */

	"\tnop\n"						/* flush pipelines (for 68040+) */

	ASM_NATFEAT(NATFEAT_ID)			/* Jump to NATFEAT_ID */
	"\ttst.l	%%d0\n"
	"\tbeq.s	1f\n"
	"\tmoveq	#1,%%d0\n"			/* NatFeats detected */
	"\tmove.l	%%d0,(%%sp)\n"

"1:\n"
	"\tmove.l	%%a1,%%sp\n"
	"\tmove.l	%%a0,(0x0010).w\n"
	"\tmove.l	(%%sp)+,%%d0\n"
	"\taddq.l	#4,%%sp\n"			/* pop nf_version argument */

	"\tnop\n"						/* flush pipelines (for 68040+) */
	: "=g"(ret)  /* outputs */
	: "g"(nf_version)		/* inputs  */
	: __CLOBBER_RETURN("d0") "a0", "d1", "cc" AND_MEMORY
	);
	return ret;
}

static long nf_name_id;

#include <osbind.h>

static __attribute__((noinline)) void nf_init(void)
{
	long ret;
	char buf[80];
	
	ret = Supexec(_nf_detect_tos);
	if (ret == 1)
	{
		nf_name_id = _nf_get_id("NF_NAME");
		if (nf_name_id)
		{
			ret = _nf_call(nf_name_id | 0, (uint32_t)buf, (uint32_t)sizeof(buf));
			if (ret != 0)
			{
				fprintf(stderr, "emulator: %s\n\n", buf);
				if (strcmp(buf, "ARAnyM") == 0)
					emulator = EMULATOR_ARANYM;
				else if (strcmp(buf, "Hatari") == 0)
					emulator = EMULATOR_HATARI;
				else if (strcmp(buf, "STonX") == 0)
					emulator = EMULATOR_STONX;
			}
		}
	}
}

#else

static void nf_init(void)
{
}

#endif


static void test_init(int argc, char **argv)
{
	if (argc > 1)
		testonly = (int)strtol(argv[1], NULL, 0);
	
	set_precision(FPCR_PRECISION_EXTENDED);
	set_rounding(FPCR_ROUND_NEAR);

	nf_init();

	/*
	 * only ARAnyM has JIT so far;
	 * no need to run more than 1 loop for other emulators
	 */
	if (emulator != EMULATOR_ARANYM)
		jit_loops = 1;
}
 

/*
 * some constants
 */
#define ZERO_P HEXCONSTE(+0.0, 0x0000, 0x00000000L, 0x00000000L)
#define ZERO_M HEXCONSTE(-0.0, 0x8000, 0x00000000L, 0x00000000L)
#if defined(__i386__) || defined(__x86_64__)
/* 387 needs the explicit integer bit for INFs, otherwise it is interpreted as NaN */
#define INF_P HEXCONSTE("+inf", 0x7fff, 0x80000000L, 0x00000000L)
#define INF_M HEXCONSTE("-inf", 0xffff, 0x80000000L, 0x00000000L)
#else
#define INF_P HEXCONSTE("+inf", 0x7fff, 0x00000000L, 0x00000000L)
#define INF_M HEXCONSTE("-inf", 0xffff, 0x00000000L, 0x00000000L)
#endif
#define QNAN_P HEXCONSTE("nan", 0x7fff, 0xffffffffL, 0xffffffffL)
#define QNAN_M HEXCONSTE("-nan", 0xffff, 0xffffffffL, 0xffffffffL)
#define SNAN_P HEXCONSTE("snan", 0x7fff, 0xbfffffffL, 0xffffffffL)
#define SNAN_M HEXCONSTE("-snan", 0xffff, 0xbfffffffL, 0xffffffffL)

#ifndef __LDBL_MIN_EXP__
#ifdef __mc68000__
#define __LDBL_MIN_EXP__ (-16382)
#else
#define __LDBL_MIN_EXP__ (-16381)
#endif
#endif

#if __LDBL_MIN_EXP__ <= (-16382)
#define SUBNORM_P HEXCONSTE(+1.82259976594123730126e-4951 /* LDBL_DENORM_MIN */, 0x0000, 0x00000000L, 0x00000001L)
#define SUBNORM_M HEXCONSTE(-1.82259976594123730126e-4951 /* -LDBL_DENORM_MIN */, 0x8000, 0x00000000L, 0x00000001L)
#define MIN_P HEXCONSTE(+1.68105157155604675313e-4932 /* LDBL_MIN */, 0x0000, 0x80000000L, 0x00000000L)
#define MIN_M HEXCONSTE(-1.68105157155604675313e-4932 /* -LDBL_MIN */, 0x8000, 0x80000000L, 0x00000000L)
#else
#define SUBNORM_P HEXCONSTE(+3.64519953188247460253e-4951 /* LDBL_DENORM_MIN */, 0x0000, 0x00000000L, 0x00000001L)
#define SUBNORM_M HEXCONSTE(-3.64519953188247460253e-4951 /* -LDBL_DENORM_MIN */, 0x8000, 0x00000000L, 0x00000001L)
#define MIN_P HEXCONSTE(+3.36210314311209350626e-4932 /* LDBL_MIN */, 0x0001, 0x80000000L, 0x00000000L)
#define MIN_M HEXCONSTE(-3.36210314311209350626e-4932 /* -LDBL_MIN */, 0x8001, 0x80000000L, 0x00000000L)
#endif
#define MAX_P HEXCONSTE(+1.18973149535723176502e+4932 /* LDBL_MAX */, 0x7ffe, 0xffffffffL, 0xffffffffL)
#define MAX_M HEXCONSTE(-1.18973149535723176502e+4932 /* -LDBL_MAX */, 0xfffe, 0xffffffffL, 0xffffffffL)

static ld_union const zero_p = ZERO_P;
static ld_union const zero_m = ZERO_M;
static ld_union const inf_p = INF_P;
static ld_union const inf_m = INF_M;
static ld_union const qnan_p = QNAN_P;
static ld_union const qnan_m = QNAN_M;
static ld_union const snan_p = SNAN_P;
static ld_union const snan_m = SNAN_M;
static ld_union const subnorm_p = SUBNORM_P;
static ld_union const subnorm_m = SUBNORM_M;
static ld_union const min_p = MIN_P;
static ld_union const min_m = MIN_M;
static ld_union const max_p = MAX_P;
static ld_union const max_m = MAX_M;

#define HEXCONST_E        HEXCONSTE("2.718281828459045235360287471352662498", 0x4000, 0xadf85458L, 0xa2bb4a9aL) /* e */
#define HEXCONST_LOG2E    HEXCONSTE("1.442695040888963407359924681001892137", 0x3fff, 0xb8aa3b29L, 0x5c17f0bcL) /* log2(e) */
#define HEXCONST_LOG10E   HEXCONSTE("0.434294481903251827651128918916605082", 0x3ffd, 0xde5bd8a9L, 0x37287195L) /* log10(e) */
#define HEXCONST_LN2      HEXCONSTE("0.693147180559945309417232121458176568", 0x3ffe, 0xb17217f7L, 0xd1cf79acL) /* ln(2) */
#define HEXCONST_LN10     HEXCONSTE("2.302585092994045684017991454684364208", 0x4000, 0x935d8dddL, 0xaaa8ac17L) /* ln(10) */
#define HEXCONST_PI       HEXCONSTE("3.141592653589793238462643383279502884", 0x4000, 0xc90fdaa2L, 0x2168c235L) /* pi */
#define HEXCONST_PI_2     HEXCONSTE("1.570796326794896619231321691639751442", 0x3fff, 0xc90fdaa2L, 0x2168c235L) /* pi/2 */
#define HEXCONST_PI_4     HEXCONSTE("0.785398163397448309615660845819875721", 0x3ffe, 0xc90fdaa2L, 0x2168c235L) /* pi/4 */
#define HEXCONST_1_PI     HEXCONSTE("0.318309886183790671537767526745028724", 0x3ffd, 0xa2f9836eL, 0x4e44152aL) /* 1/pi */
#define HEXCONST_2_PI     HEXCONSTE("0.636619772367581343075535053490057448", 0x3ffe, 0xa2f9836eL, 0x4e44152aL) /* 2/pi */
#define HEXCONST_2_SQRTPI HEXCONSTE("1.128379167095512573896158903121545172", 0x3fff, 0x906eba82L, 0x14db688dL) /* 2/sqrt(pi) */
#define HEXCONST_SQRT2    HEXCONSTE("1.414213562373095048801688724209698079", 0x3fff, 0xb504f333L, 0xf9de6484L) /* sqrt(2) */
#define HEXCONST_SQRT1_2  HEXCONSTE("0.707106781186547524400844362104849039", 0x3ffe, 0xb504f333L, 0xf9de6484L) /* 1/sqrt(2) */

#define HEXCONST_PI_M     HEXCONSTE("3.141592653589793238462643383279502884", 0xc000, 0xc90fdaa2L, 0x2168c235L) /* -pi */
#define HEXCONST_PI_2_M   HEXCONSTE("-1.570796326794896619231321691639751442", 0xbfff, 0xc90fdaa2L, 0x2168c235L) /* -pi/2 */
#define HEXCONST_PI_4_M   HEXCONSTE("-0.785398163397448309615660845819875721", 0xbffe, 0xc90fdaa2L, 0x2168c235L) /* -pi/4 */

```

`tests/tgamma.c`:

```c
#include "testconfig.h"
#ifdef HAVE_TGAMMA
#define TEST_FUNC_F_F __MATH_PRECNAME(tgamma)
#include "testdriver.h"


static test_f_f_data const lgamma_data[] = {
	{ __LINE__, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_M, 0 },
	{ __LINE__, SNAN_P, QNAN_P, 0 },
	{ __LINE__, SNAN_M, QNAN_M, 0 },
	{ __LINE__, INF_P, INF_P, 0|FLAG_XFAIL_LINUX },
	{ __LINE__, INF_M, QNAN_P, INVALID_EXCEPTION|ERRNO_EDOM },
	{ __LINE__, ZERO_P, INF_P, DIVIDE_BY_ZERO_EXCEPTION|ERRNO_ERANGE },
	{ __LINE__, ZERO_M, INF_M, DIVIDE_BY_ZERO_EXCEPTION|ERRNO_ERANGE },
	{ __LINE__, MAX_P, INF_P, OVERFLOW_EXCEPTION|ERRNO_ERANGE },
	{ __LINE__, MAX_M, QNAN_P, INVALID_EXCEPTION|ERRNO_EDOM },

	/* tgamma (x) == qNaN plus invalid exception for integer x <= 0.  */
	{ __LINE__, HEXCONSTE(-2, 0xc000, 0x80000000L, 0x00000000L), QNAN_P, INVALID_EXCEPTION|ERRNO_EDOM },

	{ __LINE__, HEXCONSTE(0.5, 0x3ffe, 0x80000000L, 0x00000000L), HEXCONSTE(1.77245385090551602731e+00, 0x3fff, 0xe2dfc48dL, 0xa77b553dL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-0.5, 0xbffe, 0x80000000L, 0x00000000L), HEXCONSTE(-3.5449077018110320545963349666822903L, 0xc000, 0xe2dfc48dL, 0xa77b553dL), 0 },

	{ __LINE__, HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(1, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3, 0x4000, 0xc0000000L, 0x00000000L), HEXCONSTE(2, 0x4000, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4, 0x4001, 0x80000000L, 0x00000000L), HEXCONSTE(6, 0x4001, 0xc0000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(5, 0x4001, 0xa0000000L, 0x00000000L), HEXCONSTE(24, 0x4003, 0xc0000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(6, 0x4001, 0xc0000000L, 0x00000000L), HEXCONSTE(120, 0x4005, 0xf0000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(7, 0x4001, 0xe0000000L, 0x00000000L), HEXCONSTE(720, 0x4008, 0xb4000000L, 0x00000000L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(8, 0x4002, 0x80000000L, 0x00000000L), HEXCONSTE(5040, 0x400b, 0x9d800000L, 0x00000000L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9, 0x4002, 0x90000000L, 0x00000000L),  HEXCONSTE(40320, 0x400e, 0x9d800000L, 0x00000000L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(10, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(362880, 0x4011, 0xb1300000L, 0x00000000L), FLAG_INEXACT },

	{ __LINE__, HEXCONSTE(0.7L, 0x3ffe, 0xb3333333L, 0x33333333L), HEXCONSTE(1.29805533264755778568117117915281162L, 0x3fff, 0xa626ad59L, 0x0f5113ccL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.2L, 0x3fff, 0x99999999L, 0x9999999aL), HEXCONSTE(0.918168742399760610640951655185830401L, 0x3ffe, 0xeb0d1b50L, 0xd100ed14L), FLAG_INEXACT },

	{ __LINE__, HEXCONSTE(1.5L, 0x3fff, 0xc0000000L, 0x00000000L), HEXCONSTE(8.8622692545275801364908374167057259139877e-01L, 0x3ffe, 0xe2dfc48dL, 0xa77b553dL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.5L, 0x4000, 0xa0000000L, 0x00000000L), HEXCONSTE(1.3293403881791370204736256125058588870982e+00L, 0x3fff, 0xaa27d36aL, 0x3d9c7feeL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.5L, 0x4000, 0xe0000000L, 0x00000000L), HEXCONSTE(3.3233509704478425511840640312646472177454e+00L, 0x4000, 0xd4b1c844L, 0xcd039fe9L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(4.5L, 0x4001, 0x90000000L, 0x00000000L), HEXCONSTE(1.1631728396567448929144224109426265262109e+01L, 0x4002, 0xba1b8f3cL, 0x33632becL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(5.5L, 0x4001, 0xb0000000L, 0x00000000L), HEXCONSTE(5.2342777784553520181149008492418193679490e+01L, 0x4004, 0xd15f0123L, 0xb9cf9169L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(6.5L, 0x4001, 0xd0000000L, 0x00000000L), HEXCONSTE(2.8788527781504436099631954670830006523720e+02L, 0x4007, 0x8ff150c8L, 0x8fbeb3f8L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(7.5L, 0x4001, 0xf0000000L, 0x00000000L), HEXCONSTE(1.8712543057977883464760770536039504240418e+03L, 0x4009, 0xe9e82345L, 0xe995e474L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(8.5L, 0x4002, 0x88000000L, 0x00000000L), HEXCONSTE(1.4034407293483412598570577902029628180313e+04L, 0x400c, 0xdb49a111L, 0x8afc862dL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.5L, 0x4002, 0x98000000L, 0x00000000L), HEXCONSTE(1.1929246199460900708784991216725183953266e+05L, 0x400f, 0xe8fe3b22L, 0xa3ac4e8fL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.5L, 0xbfff, 0xc0000000L, 0x00000000L), HEXCONSTE(2.3632718012073547030642233111215269103967e+00L, 0x4000, 0x973fd85eL, 0x6fa78e29L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-2.5L, 0xc000, 0xa0000000L, 0x00000000L), HEXCONSTE(-9.4530872048294188122568932444861076415869e-01L, 0xbffe, 0xf1ffc097L, 0x190c16a7L), 0 },
	{ __LINE__, HEXCONSTE(-3.5L, 0xc000, 0xe0000000L, 0x00000000L), HEXCONSTE(2.7008820585226910892162552127103164690248e-01L, 0x3ffd, 0x8a490056L, 0x57749f3bL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-4.5L, 0xc001, 0x90000000L, 0x00000000L), HEXCONSTE(-6.0019601300504246427027893615784810422774e-02L, 0xbffa, 0xf5d71d0bL, 0x4624a94dL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-5.5L, 0xc001, 0xb0000000L, 0x00000000L), HEXCONSTE(1.0912654781909862986732344293779056440504e-02L, 0x3ff8, 0xb2cafdd9L, 0xa7607b20L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-6.5L, 0xc001, 0xd0000000L, 0x00000000L), HEXCONSTE(-1.6788699664476712287280529682737009908468e-03L, 0xbff5, 0xdc0d8733L, 0x4427fa00L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-7.5L, 0xc001, 0xf0000000L, 0x00000000L), HEXCONSTE(2.2384932885968949716374039576982679877958e-04L, 0x3ff2, 0xeab918bfL, 0x37a21bbcL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-8.5L, 0xc002, 0x88000000L, 0x00000000L), HEXCONSTE(-2.6335215159963470254557693619979623385833e-05L, 0xbfef, 0xdcea71a4L, 0xe9110b0cL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-9.5L, 0xc002, 0x98000000L, 0x00000000L), HEXCONSTE(2.7721279115751021320587045915768024616666e-06L, 0x3fec, 0xba08cb7dL, 0x65f3679eL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(5.96046447753906250000e-08, 0x3fe7, 0x80000000L, 0x00000000L), HEXCONSTE(1.6777215422784394050795179874582764575261e+07L, 0x4016, 0xffffff6cL, 0x3b9919b5L), 0 },
	{ __LINE__, HEXCONSTE(-5.96046447753906250000e-08, 0xbfe7, 0x80000000L, 0x00000000L), HEXCONSTE(-1.6777216577215723853867349114260580375249e+07L, 0xc017, 0x80000049L, 0xe2347058L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.11022302462515654042e-16, 0x3fca, 0x80000000L, 0x00000000L), HEXCONSTE(9.0071992547409914227843350984672492007618e+15L, 0x4033, 0xffffffffL, 0xfffffb62L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.11022302462515654042e-16, 0xbfca, 0x80000000L, 0x00000000L), HEXCONSTE(-9.0071992547409925772156649015329704137860e+15L, 0xc034, 0x80000000L, 0x0000024fL), 0 },
	{ __LINE__, HEXCONSTE(5.42101086242752217004e-20, 0x3fbf, 0x80000000L, 0x00000000L), HEXCONSTE(1.8446744073709551615422784335098467139447e+19L, 0x403e, 0xffffffffL, 0xffffffffL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-5.42101086242752217004e-20, 0xbfbf, 0x80000000L, 0x00000000L), HEXCONSTE(-1.8446744073709551616577215664901532860660e+19L, 0xc03f, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.23259516440783094596e-32, 0x3f95, 0x80000000L, 0x00000000L), HEXCONSTE(8.1129638414606681695789005144063422784335e+31L, 0x4069, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.23259516440783094596e-32, 0xbf95, 0x80000000L, 0x00000000L), HEXCONSTE(-8.1129638414606681695789005144064577215665e+31L, 0xc069, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9.62964972193617926528e-35, 0x3f8e, 0x80000000L, 0x00000000L), HEXCONSTE(1.0384593717069655257060992658440191422784e+34L, 0x4070, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-9.62964972193617926528e-35, 0xbf8e, 0x80000000L, 0x00000000L), HEXCONSTE(-1.0384593717069655257060992658440192577216e+34L, 0xc070, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(5.87747175411143753984e-39, 0x3f80, 0x80000000L, 0x00000000L), HEXCONSTE(1.7014118346046923173168730371588410572742e+38L, 0x407e, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-5.87747175411143753984e-39, 0xbf80, 0x80000000L, 0x00000000L), HEXCONSTE(-1.7014118346046923173168730371588410572858e+38L, 0xc07e, 0x80000000L, 0x00000000L), 0 },
#ifdef TEST_FLOAT
	{ __LINE__, HEXCONSTE(2.93873587705571876992e-39, 0x3f7f, 0x80000000L, 0x00000000L), INF_P, OVERFLOW_EXCEPTION|ERRNO_ERANGE },
	{ __LINE__, HEXCONSTE(-2.93873587705571876992e-39, 0xbf7f, 0x80000000L, 0x00000000L), INF_M, OVERFLOW_EXCEPTION|ERRNO_ERANGE },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), INF_P, OVERFLOW_EXCEPTION|ERRNO_ERANGE },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), INF_M, OVERFLOW_EXCEPTION|ERRNO_ERANGE },
#else
	{ __LINE__, HEXCONSTE(2.93873587705571876992e-39, 0x3f7f, 0x80000000L, 0x00000000L), HEXCONSTE(3.4028236692093846346337460743176821145542e+38L, 0x407f, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-2.93873587705571876992e-39, 0xbf7f, 0x80000000L, 0x00000000L), HEXCONSTE(-3.4028236692093846346337460743176821145658e+38L, 0xc07f, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.40129846432481707092e-45, 0x3f6a, 0x80000000L, 0x00000000L), HEXCONSTE(7.1362384635297994052914298472474756819137e+44L, 0x4094, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.40129846432481707092e-45, 0xbf6a, 0x80000000L, 0x00000000L), HEXCONSTE(-7.1362384635297994052914298472474756819137e+44L, 0xc094, 0x80000000L, 0x00000000L), 0 },
#endif
#ifndef TEST_FLOAT
	{ __LINE__, HEXCONSTE(1.11253692925360069155e-308, 0x3c00, 0x80000000L, 0x00000000L), HEXCONSTE(8.9884656743115795386465259539451236680899e+307L, 0x43fe, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.11253692925360069155e-308, 0xbc00, 0x80000000L, 0x00000000L), HEXCONSTE(-8.9884656743115795386465259539451236680899e+307L, 0xc3fe, 0x80000000L, 0x00000000L), 0 },
# if !defined TEST_LDOUBLE || LDBL_MAX_EXP <= 1024
	{ __LINE__, HEXCONSTE(5.56268464626800345773e-309, 0x3bff, 0x80000000L, 0x00000000L), INF_P, OVERFLOW_EXCEPTION|ERRNO_ERANGE },
	{ __LINE__, HEXCONSTE(-5.56268464626800345773e-309, 0xbbff, 0x80000000L, 0x00000000L), INF_M, OVERFLOW_EXCEPTION|ERRNO_ERANGE },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), INF_P, OVERFLOW_EXCEPTION|ERRNO_ERANGE },
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), INF_M, OVERFLOW_EXCEPTION|ERRNO_ERANGE },
# else
	{ __LINE__, HEXCONSTE(5.56268464626800345773e-309, 0x3bff, 0x80000000L, 0x00000000L), HEXCONSTE(1.7976931348623159077293051907890247336180e+308L, 0x43ff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-5.56268464626800345773e-309, 0xbbff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.7976931348623159077293051907890247336180e+308L, 0xc3ff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.94065645841246544177e-324, 0x3bcd, 0x80000000L, 0x00000000L), HEXCONSTE(2.0240225330731061835249534671891730704956e+323L, 0x4431, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-4.94065645841246544177e-324, 0xbbcd, 0x80000000L, 0x00000000L), HEXCONSTE(-2.0240225330731061835249534671891730704956e+323L, 0xc431, 0x80000000L, 0x00000000L), 0 },
# endif
#endif
#if defined TEST_LDOUBLE && LDBL_MIN_EXP <= -16381
	{ __LINE__, HEXCONSTE(1.68105157155604675313e-4932, 0x0000, 0x40000000L, 0x00000000L), HEXCONSTE(5.9486574767861588254287966331400356538172e+4931L, 0x7ffe, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.68105157155604675313e-4932, 0x8000, 0x40000000L, 0x00000000L), HEXCONSTE(-5.9486574767861588254287966331400356538172e+4931L, 0xfffe, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(8.40525785778023376566e-4933, 0x0000, 0x20000000L, 0x00000000L), INF_P, OVERFLOW_EXCEPTION|ERRNO_ERANGE },
	{ __LINE__, HEXCONSTE(-8.40525785778023376566e-4933, 0x8000, 0x20000000L, 0x00000000L), INF_M, OVERFLOW_EXCEPTION|ERRNO_ERANGE },
	{ __LINE__, HEXCONSTE(3.64519953188247460253e-4951, 0x0000, 0x00000000L, 0x00000001L), INF_P, OVERFLOW_EXCEPTION|ERRNO_ERANGE },
	{ __LINE__, HEXCONSTE(-3.64519953188247460253e-4951, 0x8000, 0x00000000L, 0x00000001L), INF_M, OVERFLOW_EXCEPTION|ERRNO_ERANGE },
#endif

#ifndef TEST_FLOAT
	/*
	 * disabled because exact results depend on intermediate results
	 * being rounded to float; with i386 fpu and m68k intermediates
	 * are calculated using extended precision
	 */
	{ __LINE__, HEXCONSTE(8.00000095367431640625e+00, 0x4002, 0x80000100L, 0x00000000L), HEXCONSTE(5.0400096882277802019946778420223050233915e+03L, 0x400b, 0x9d8013d7L, 0x6bebc6ffL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(7.99999952316284179688e+00, 0x4001, 0xffffff00L, 0x00000000L), HEXCONSTE(5.0399951558933225045148935487583089307135e+03L, 0x400b, 0x9d7ff614L, 0x4b01ef40L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(7.00000047683715820312e+00, 0x4001, 0xe0000100L, 0x00000000L), HEXCONSTE(7.2000064296977505705636258629805621178587e+02L, 0x4008, 0xb4000a88L, 0xcf89fef6L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(6.99999952316284179688e+00, 0x4001, 0xdfffff00L, 0x00000000L), HEXCONSTE(7.1999935703082425988147448928288557689866e+02L, 0x4008, 0xb3fff577L, 0x311abe38L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(6.00000047683715820312e+00, 0x4001, 0xc0000100L, 0x00000000L), HEXCONSTE(1.2000009762487825358530770343720418162783e+02L, 0x4005, 0xf0000ccbL, 0xbf51999eL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(5.99999952316284179688e+00, 0x4001, 0xbfffff00L, 0x00000000L), HEXCONSTE(1.1999990237520611552119807476573441975106e+02L, 0x4005, 0xeffff334L, 0x4167edf8L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(4.99999952316284179688e+00, 0x4001, 0x9fffff00L, 0x00000000L), HEXCONSTE(2.3999982763857938712639837029547357501709e+01L, 0x4003, 0xbffff6f6L, 0x9aab15beL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-4.99999952316284179688e+00, 0xc001, 0x9fffff00L, 0x00000000L), HEXCONSTE(-1.7476280884325863043793087474680780379554e+04L, 0xc00d, 0x88888fd0L, 0x120314e1L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-5.99999952316284179688e+00, 0xc001, 0xbfffff00L, 0x00000000L), HEXCONSTE(2.9127137122026653716311560165769071985443e+03L, 0x400a, 0xb60b6b5dL, 0x7c934328L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-6.00000047683715820312e+00, 0xc001, 0xc0000100L, 0x00000000L), HEXCONSTE(-2.9127085100239567622341538102130981196910e+03L, 0xc00a, 0xb60b560eL, 0x9b5c8500L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-6.99999952316284179688e+00, 0xc001, 0xdfffff00L, 0x00000000L), HEXCONSTE(-4.1610198723079349791939054365613377035519e+02L, 0xc007, 0xd00d0deaL, 0xe66f1010L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-7.99999952316284179688e+00, 0xc001, 0xffffff00L, 0x00000000L), HEXCONSTE(5.2012751504050764429534086402871289946986e+01L, 0x4004, 0xd00d0ebaL, 0xf37dcb04L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-8.00000095367431640625e+00, 0xc002, 0x80000100L, 0x00000000L), HEXCONSTE(-2.6006296115134418896533598545925084576702e+01L, 0xc003, 0xd00ce4faL, 0x44c0e157L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-9.99999904632568359375e+00, 0xc002, 0x9fffff00L, 0x00000000L), HEXCONSTE(2.8896008370721717567612135720915723136310e-01L, 0x3ffd, 0x93f2937aL, 0xbe6c535aL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.00000009536743164062e+01, 0xc002, 0xa0000100L, 0x00000000L), HEXCONSTE(-2.8895878754728051776830454190076999107021e-01L, 0xbffd, 0x93f267fcL, 0xd0945b82L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.99999980926513671875e+01, 0xc003, 0x9fffff00L, 0x00000000L), HEXCONSTE(2.1550026214525536756224040483579183652119e-13L, 0x3fd4, 0xf2a1b8bcL, 0x047b2d6cL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-2.00000019073486328125e+01, 0xc003, 0xa0000100L, 0x00000000L), HEXCONSTE(-2.1549777908265594916405421768142757507179e-13L, 0xbfd4, 0xf2a10184L, 0x4a874e2cL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-2.99999980926513671875e+01, 0xc003, 0xefffff00L, 0x00000000L), HEXCONSTE(1.9765721589464867957912772592816027583176e-27L, 0x3fa6, 0x9c99a569L, 0x5c570514L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-3.00000019073486328125e+01, 0xc003, 0xf0000100L, 0x00000000L), HEXCONSTE(-1.9765463890341964384070157599286498212650e-27L, 0xbfa6, 0x9c991f9bL, 0x45972556L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-3.99999961853027343750e+01, 0xc004, 0x9fffff00L, 0x00000000L), HEXCONSTE(3.2129279441390812141195076945616975790225e-43L, 0x3f71, 0xe5483e3eL, 0x3f4f570cL), FLAG_INEXACT|UNDERFLOW_EXCEPTION_FLOAT },
	{ __LINE__, HEXCONSTE(-7.00000047683715820312e+00, 0xc001, 0xe0000100L, 0x00000000L), HEXCONSTE(4.1610118737306415004517215226199741948733e+02L, 0x4007, 0xd00cf3b5L, 0x350a120cL), FLAG_INEXACT },
#endif
	{ __LINE__, HEXCONSTE(5.00000047683715820312e+00, 0x4001, 0xa0000100L, 0x00000000L), HEXCONSTE(2.4000017236155647574166073485628713443799e+01L, 0x4003, 0xc0000909L, 0x65cc6bdcL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(4.00000047683715820312e+00, 0x4001, 0x80000100L, 0x00000000L), HEXCONSTE(6.0000035937827461765660468073471093546129e+00L, 0x4001, 0xc0000789L, 0x65bd5910L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.99999976158142089844e+00, 0x4000, 0xffffff00L, 0x00000000L), HEXCONSTE(5.9999982031095793171233994481968816873643e+00L, 0x4001, 0xbffffc3bL, 0x4d42d5f9L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.00000023841857910156e+00, 0x4000, 0xc0000100L, 0x00000000L), HEXCONSTE(2.0000004400179308360529417942462250547999e+00L, 0x4000, 0x800001d8L, 0x77353566L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.99999976158142089844e+00, 0x4000, 0xbfffff00L, 0x00000000L), HEXCONSTE(1.9999995599822108706107786027549565954046e+00L, 0x3fff, 0xfffffc4fL, 0x11a986b9L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.00000023841857910156e+00, 0x4000, 0x80000100L, 0x00000000L), HEXCONSTE(1.0000001007996638509889062631687945799175e+00L, 0x3fff, 0x800000d8L, 0x77338478L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.99999988079071044922e+00, 0x3fff, 0xffffff00L, 0x00000000L), HEXCONSTE(9.9999994960018563231526611134590489120697e-01L, 0x3ffe, 0xffffff27L, 0x88d16cb5L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.00000011920928955078e+00, 0x3fff, 0x80000100L, 0x00000000L), HEXCONSTE(9.9999993119054472483596471908942669644327e-01L, 0x3ffe, 0xfffffed8L, 0x77342dd0L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.99999940395355224609e-01, 0x3ffe, 0xffffff00L, 0x00000000L), HEXCONSTE(1.0000000344047381790797322460568297132998e+00L, 0x3fff, 0x80000049L, 0xe2347058L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-9.99999940395355224609e-01, 0xbffe, 0xffffff00L, 0x00000000L), HEXCONSTE(-1.6777216422784419250710305882992376932423e+07L, 0xc017, 0x80000036L, 0x1dccc2f8L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.00000011920928955078e+00, 0xbfff, 0x80000100L, 0x00000000L), HEXCONSTE(8.3886075772158332060084424806449513922858e+06L, 0x4015, 0xffffff27L, 0x88d56cb5L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.99999988079071044922e+00, 0xbfff, 0xffffff00L, 0x00000000L), HEXCONSTE(4.1943044613922792026014320172298377770578e+06L, 0x4015, 0x800000ecL, 0x3b9bdb9bL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-2.00000023841857910156e+00, 0xc000, 0x80000100L, 0x00000000L), HEXCONSTE(-2.0971515386080557574407223895988378776747e+06L, 0xc013, 0xfffffc4fL, 0x11bd86b9L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-2.99999976158142089844e+00, 0xc000, 0xbfffff00L, 0x00000000L), HEXCONSTE(-6.9905087601970247876992248591045142913324e+05L, 0xc012, 0xaaaaae04L, 0x2d3c4cc4L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-3.00000023841857910156e+00, 0xc000, 0xc0000100L, 0x00000000L), HEXCONSTE(6.9905045731381300146131914617735687322025e+05L, 0x4012, 0xaaaaa751L, 0x2849ed9bL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-3.99999976158142089844e+00, 0xc000, 0xffffff00L, 0x00000000L), HEXCONSTE(1.7476272942159602684441970627092458855771e+05L, 0x4010, 0xaaaaaeaeL, 0xd7eafb9cL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-4.00000047683715820312e+00, 0xc001, 0x80000100L, 0x00000000L), HEXCONSTE(-8.7381270578483499672965708923121931082305e+04L, 0xc00f, 0xaaaaa2a2L, 0x50d4d0f2L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-5.00000047683715820312e+00, 0xc001, 0xa0000100L, 0x00000000L), HEXCONSTE(1.7476252449031389167286893378510439443844e+04L, 0x400d, 0x88888140L, 0xffdb725bL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-4.00000038146972656250e+01, 0xc004, 0xa0000100L, 0x00000000L), HEXCONSTE(-3.2128372159115252365699015758097981155793e-43L, 0xbf71, 0xe54695ecL, 0xc67a5675L), FLAG_INEXACT|UNDERFLOW_EXCEPTION_FLOAT },
	{ __LINE__, HEXCONSTE(-4.09999961853027343750e+01, 0xc004, 0xa3ffff00L, 0x00000000L), HEXCONSTE(-7.8364103489619817539676737414096652170685e-45L, 0xbf6c, 0xb2f3b4cbL, 0x0b7d99ddL), FLAG_INEXACT|UNDERFLOW_EXCEPTION_FLOAT },
	{ __LINE__, HEXCONSTE(-4.10000038146972656250e+01, 0xc004, 0xa4000100L, 0x00000000L), HEXCONSTE(7.8361876024016854597745353972619195760515e-45L, 0x3f6c, 0xb2f2676fL, 0x846cda16L), FLAG_INEXACT|UNDERFLOW_EXCEPTION_FLOAT },
#ifdef TEST_FLOAT
	{ __LINE__, HEXCONSTE(-4.19999961853027343750e+01, 0xc004, 0xa7ffff00L, 0x00000000L), ZERO_P, UNDERFLOW_EXCEPTION_FLOAT },
	{ __LINE__, HEXCONSTE(-4.20000038146972656250e+01, 0xc004, 0xa8000100L, 0x00000000L), ZERO_M, UNDERFLOW_EXCEPTION_FLOAT },
#else
	{ __LINE__, HEXCONSTE(-4.19999961853027343750e+01, 0xc004, 0xa7ffff00L, 0x00000000L), HEXCONSTE(1.8658121573125798145204120066590953505132e-46L, 0x3f67, 0x88582908L, 0xf09e39b5L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-4.20000038146972656250e+01, 0xc004, 0xa8000100L, 0x00000000L), HEXCONSTE(-1.8657587834931410688246126853566488626385e-46L, 0xbf67, 0x8857296cL, 0xd3e30c85L), FLAG_INEXACT },
#endif
#ifndef TEST_FLOAT
	{ __LINE__, HEXCONSTE(8.00000000000000177636e+00, 0x4002, 0x80000000L, 0x00000800L), HEXCONSTE(5.0400000000000180457125667322294144477136e+03L, 0x400b, 0x9d800000L, 0x00009ebbL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(7.99999999999999911182e+00, 0x4001, 0xffffffffL, 0xfffff800L), HEXCONSTE(5.0399999999999909771437166339103165198442e+03L, 0x400b, 0x9d7fffffL, 0xffffb0a2L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(7.00000000000000088818e+00, 0x4001, 0xe0000000L, 0x00000800L), HEXCONSTE(7.2000000000000119762397445457359071259652e+02L, 0x4008, 0xb4000000L, 0x00005446L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(6.99999999999999911182e+00, 0x4001, 0xdfffffffL, 0xfffff800L), HEXCONSTE(7.1999999999999880237602554542848858572672e+02L, 0x4008, 0xb3ffffffL, 0xffffabbaL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(6.00000000000000088818e+00, 0x4001, 0xc0000000L, 0x00000800L), HEXCONSTE(1.2000000000000018184042734842640022086408e+02L, 0x4005, 0xf0000000L, 0x0000665eL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(5.99999999999999911182e+00, 0x4001, 0xbfffffffL, 0xfffff800L), HEXCONSTE(1.1999999999999981815957265157389249327533e+02L, 0x4005, 0xefffffffL, 0xffff99a2L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(5.00000000000000088818e+00, 0x4001, 0xa0000000L, 0x00000800L), HEXCONSTE(2.4000000000000032104829055124673225982803e+01L, 0x4003, 0xc0000000L, 0x0000484bL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(4.99999999999999911182e+00, 0x4001, 0x9fffffffL, 0xfffff800L), HEXCONSTE(2.3999999999999967895170944875373910918544e+01L, 0x4003, 0xbfffffffL, 0xffffb7b5L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(4.00000000000000088818e+00, 0x4001, 0x80000000L, 0x00000800L), HEXCONSTE(6.0000000000000066939396342309789716341613e+00L, 0x4001, 0xc0000000L, 0x00003c4bL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.99999999999999955591e+00, 0x4000, 0xffffffffL, 0xfffff800L), HEXCONSTE(5.9999999999999966530301828845138185025345e+00L, 0x4001, 0xbfffffffL, 0xffffe1daL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.00000000000000044409e+00, 0x4000, 0xc0000000L, 0x00000800L), HEXCONSTE(2.0000000000000008195971324717875960213536e+00L, 0x4000, 0x80000000L, 0x00000ec4L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.99999999999999955591e+00, 0x4000, 0xbfffffffL, 0xfffff800L), HEXCONSTE(1.9999999999999991804028675282128956223990e+00L, 0x3fff, 0xffffffffL, 0xffffe279L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.00000000000000044409e+00, 0x4000, 0x80000000L, 0x00000800L), HEXCONSTE(1.0000000000000001877539613108624482361963e+00L, 0x3fff, 0x80000000L, 0x000006c4L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.99999999999999977796e+00, 0x3fff, 0xffffffffL, 0xfffff800L), HEXCONSTE(9.9999999999999990612301934456883679778984e-01L, 0x3ffe, 0xffffffffL, 0xfffff93cL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.00000000000000022204e+00, 0x3fff, 0x80000000L, 0x00000800L), HEXCONSTE(9.9999999999999987183237573039992418700531e-01L, 0x3ffe, 0xffffffffL, 0xfffff6c4L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.99999999999999888978e-01, 0x3ffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(1.0000000000000000640838121348000744796665e+00L, 0x3fff, 0x80000000L, 0x0000024fL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-9.99999999999999888978e-01, 0xbffe, 0xffffffffL, 0xfffff800L), HEXCONSTE(-9.0071992547409924227843350984672961392521e+15L, 0xc034, 0x80000000L, 0x000001b1L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.00000000000000022204e+00, 0xbfff, 0x80000000L, 0x00000800L), HEXCONSTE(4.5035996273704955772156649015331740980405e+15L, 0x4032, 0xffffffffL, 0xfffff93cL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.99999999999999977796e+00, 0xbfff, 0xffffffffL, 0xfffff800L), HEXCONSTE(2.2517998136852484613921675492337776673289e+15L, 0x4032, 0x80000000L, 0x00000762L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-2.00000000000000044409e+00, 0xc000, 0x80000000L, 0x00000800L), HEXCONSTE(-1.1258999068426235386078324507668462444260e+15L, 0xc030, 0xffffffffL, 0xffffe279L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-2.99999999999999955591e+00, 0xc000, 0xbfffffffL, 0xfffff800L), HEXCONSTE(-3.7529996894754154268627807196691509198813e+14L, 0xc02f, 0xaaaaaaaaL, 0xaaaac577L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-3.00000000000000044409e+00, 0xc000, 0xc0000000L, 0x00000800L), HEXCONSTE(3.7529996894754112398038859470009084971438e+14L, 0x402f, 0xaaaaaaaaL, 0xaaaa8fdfL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-3.99999999999999955591e+00, 0xc000, 0xffffffffL, 0xfffff800L), HEXCONSTE(9.3824992236885396088236184658402406857503e+13L, 0x402d, 0xaaaaaaaaL, 0xaaaacaccL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-4.00000000000000088818e+00, 0xc001, 0x80000000L, 0x00000800L), HEXCONSTE(-4.6912496118442603911763815341745722862351e+13L, 0xc02c, 0xaaaaaaaaL, 0xaaaa6a68L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-4.99999999999999911182e+00, 0xc001, 0x9fffffffL, 0xfffff800L), HEXCONSTE(-9.3824992236885475509805702650262155809819e+12L, 0xc02a, 0x88888888L, 0x8888c2c5L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-5.00000000000000088818e+00, 0xc001, 0xa0000000L, 0x00000800L), HEXCONSTE(9.3824992236885191156860964016850034672946e+12L, 0x402a, 0x88888888L, 0x88884e4cL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-5.99999999999999911182e+00, 0xc001, 0xbfffffffL, 0xfffff800L), HEXCONSTE(1.5637498706147581566449098589862357835505e+12L, 0x4027, 0xb60b60b6L, 0x0b610b47L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-6.00000000000000088818e+00, 0xc001, 0xc0000000L, 0x00000800L), HEXCONSTE(-1.5637498706147529544662012521330708016396e+12L, 0xc027, 0xb60b60b6L, 0x0b6060d0L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-6.99999999999999911182e+00, 0xc001, 0xdfffffffL, 0xfffff800L), HEXCONSTE(-2.2339283865925119357965832452642909859289e+11L, 0xc024, 0xd00d00d0L, 0x0d0138e4L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-7.00000000000000088818e+00, 0xc001, 0xe0000000L, 0x00000800L), HEXCONSTE(2.2339283865925039372192897706214475877342e+11L, 0x4024, 0xd00d00d0L, 0x0d006736L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-7.99999999999999911182e+00, 0xc001, 0xffffffffL, 0xfffff800L), HEXCONSTE(2.7924104832406402297655703264222230055898e+10L, 0x4021, 0xd00d00d0L, 0x0d013f64L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-8.00000000000000177636e+00, 0xc002, 0x80000000L, 0x00000800L), HEXCONSTE(-1.3962052416203121511868106259843527348026e+10L, 0xc020, 0xd00d00d0L, 0x0cfff15fL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-9.99999999999999822364e+00, 0xc002, 0x9fffffffL, 0xfffff800L), HEXCONSTE(1.5513391573559147700413058496716749249803e+08L, 0x401a, 0x93f27dbbL, 0xc4fb918fL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.00000000000000017764e+01, 0xc002, 0xa0000000L, 0x00000800L), HEXCONSTE(-1.5513391573559018084419393002828541166901e+08L, 0xc01a, 0x93f27dbbL, 0xc4fa35a0L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.99999999999999964473e+01, 0xc003, 0x9fffffffL, 0xfffff800L), HEXCONSTE(1.1569515572952029402736625857313236848570e-04L, 0x3ff1, 0xf2a15d20L, 0x1014051cL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-2.00000000000000035527e+01, 0xc003, 0xa0000000L, 0x00000800L), HEXCONSTE(-1.1569515572951781096476686854873801225397e-04L, 0xbff1, 0xf2a15d20L, 0x100e4b5eL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-2.99999999999999964473e+01, 0xc003, 0xefffffffL, 0xfffff800L), HEXCONSTE(1.0611571800204311628217068863959963842891e-18L, 0x3fc3, 0x9c996282L, 0x3eb28a3fL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-3.00000000000000035527e+01, 0xc003, 0xf0000000L, 0x00000800L), HEXCONSTE(-1.0611571800204053929094168642022073530425e-18L, 0xbfc3, 0x9c996282L, 0x3eae5bceL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-3.99999999999999928946e+01, 0xc004, 0x9fffffffL, 0xfffff800L), HEXCONSTE(1.7249032006742266376460389310340465554361e-34L, 0x3f8e, 0xe5476a15L, 0x095db947L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-4.00000000000000071054e+01, 0xc004, 0xa0000000L, 0x00000800L), HEXCONSTE(-1.7249032006741359094184881234822934593822e-34L, 0xbf8e, 0xe5476a15L, 0x095076bbL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-4.09999999999999928946e+01, 0xc004, 0xa3ffffffL, 0xfffff800L), HEXCONSTE(-4.2070809772542120404320040128839297118648e-36L, 0xbf89, 0xb2f30e1cL, 0xe8173badL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-4.10000000000000071054e+01, 0xc004, 0xa4000000L, 0x00000800L), HEXCONSTE(4.2070809772539892938717205103652583609422e-36L, 0x3f89, 0xb2f30e1cL, 0xe80cd0d1L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-4.19999999999999928946e+01, 0xc004, 0xa7ffffffL, 0xfffff800L), HEXCONSTE(1.0016859469652887505173040814397197718981e-37L, 0x3f84, 0x8857a93aL, 0x98734027L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-4.20000000000000071054e+01, 0xc004, 0xa8000000L, 0x00000800L), HEXCONSTE(-1.0016859469652353766978684241048308120274e-37L, 0xbf84, 0x8857a93aL, 0x986b4346L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-4.99999999999999928946e+01, 0xc004, 0xc7ffffffL, 0xfffff800L), HEXCONSTE(4.6273774273632946947805289899230181990085e-51L, 0x3f57, 0xdd9b7b70L, 0x96728b4cL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-5.00000000000000071054e+01, 0xc004, 0xc8000000L, 0x00000800L), HEXCONSTE(-4.6273774273630367887073532197576655720178e-51L, 0xbf57, 0xdd9b7b70L, 0x9664f6baL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-9.99999999999999857891e+01, 0xc005, 0xc7ffffffL, 0xfffff800L), HEXCONSTE(7.5400833348840965463348754984345825364294e-145L, 0x3e20, 0x96a50f30L, 0x3f46e1acL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.00000000000000014211e+02, 0xc005, 0xc8000000L, 0x00000800L), HEXCONSTE(-7.5400833348831085791638490135462230991587e-145L, 0xbe20, 0x96a50f30L, 0x3f312db3L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.49999999999999971578e+02, 0xc006, 0x95ffffffL, 0xfffff800L), HEXCONSTE(6.1582369322723207086020016423767264008839e-250L, 0x3cc3, 0x8d17957bL, 0x20356d42L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.50000000000000028422e+02, 0xc006, 0x96000000L, 0x00000800L), HEXCONSTE(-6.1582369322705655439003240743176243138734e-250L, 0xbcc3, 0x8d17957bL, 0x2009365dL), FLAG_INEXACT },
#ifdef TEST_LDOUBLE
	{ __LINE__, HEXCONSTE(-1.80999999999999971578e+02, 0xc006, 0xb4ffffffL, 0xfffff800L), HEXCONSTE(-9.6760879059917574597728750098636253931457e-319L, 0xbbde, 0xbf418cc5L, 0x37d2800dL), FLAG_INEXACT|UNDERFLOW_EXCEPTION_DOUBLE },
	{ __LINE__, HEXCONSTE(-1.81000000000000028422e+02, 0xc006, 0xb5000000L, 0x00000800L), HEXCONSTE(9.6760879059888966544677044221698800670218e-319L, 0x3bde, 0xbf418cc5L, 0x379453b4L), FLAG_INEXACT|UNDERFLOW_EXCEPTION_DOUBLE },
	{ __LINE__, HEXCONSTE(-1.81999999999999971578e+02, 0xc006, 0xb5ffffffL, 0xfffff800L), HEXCONSTE(5.3165318164789884455066481673086605454904e-321L, 0x3bd7, 0x86827f22L, 0x9d69de90L), FLAG_INEXACT|UNDERFLOW_EXCEPTION_DOUBLE },
	{ __LINE__, HEXCONSTE(-1.82000000000000028422e+02, 0xc006, 0xb6000000L, 0x00000800L), HEXCONSTE(-5.3165318164774149139661976747137185876909e-321L, 0xbbd7, 0x86827f22L, 0x9d3e18d3L), FLAG_INEXACT|UNDERFLOW_EXCEPTION_DOUBLE },
	{ __LINE__, HEXCONSTE(-1.82999999999999971578e+02, 0xc006, 0xb6ffffffL, 0xfffff800L), HEXCONSTE(-2.9052086428846935908287469917922960610289e-323L, 0xbbcf, 0xbc2aa974L, 0xf82f698aL), FLAG_INEXACT|UNDERFLOW_EXCEPTION_DOUBLE },
	{ __LINE__, HEXCONSTE(-1.83000000000000028422e+02, 0xc006, 0xb7000000L, 0x00000800L), HEXCONSTE(2.9052086428838328351126988236541632950925e-323L, 0x3bcf, 0xbc2aa974L, 0xf7f21d4cL), FLAG_INEXACT|UNDERFLOW_EXCEPTION_DOUBLE },
#endif
# if !defined TEST_LDOUBLE || LDBL_MAX_EXP <= 1024
	{ __LINE__, HEXCONSTE(-1.83999999999999971578e+02, 0xc006, 0xb7ffffffL, 0xfffff800L), ZERO_P, UNDERFLOW_EXCEPTION_DOUBLE },
	{ __LINE__, HEXCONSTE(-1.84000000000000028422e+02, 0xc006, 0xb8000000L, 0x00000800L), ZERO_M, UNDERFLOW_EXCEPTION_DOUBLE|FLAG_IGNORE_ZEROSIGN },
# else
	{ __LINE__, HEXCONSTE(-1.83999999999999971578e+02, 0xc006, 0xb7ffffffL, 0xfffff800L), HEXCONSTE(1.5789177406982032823826953250736039527543e-325L, 0x3bc8, 0x82e60694L, 0x2715dfceL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.84000000000000028422e+02, 0xc006, 0xb8000000L, 0x00000800L), HEXCONSTE(-1.5789177406977349925854817486109369828857e-325L, 0xbbc8, 0x82e60694L, 0x26eb3015L), FLAG_INEXACT },
# endif
#endif
#if defined TEST_LDOUBLE && LDBL_MAX_EXP >= 16384
	{ __LINE__, HEXCONSTE(8.00000000000000000087e+00, 0x4002, 0x80000000L, 0x00000001L), HEXCONSTE(5.0400000000000000088113830892247051102283e+03L, 0x400b, 0x9d800000L, 0x00000014L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(7.99999999999999999957e+00, 0x4001, 0xffffffffL, 0xffffffffL), HEXCONSTE(5.0399999999999999955943084553876474508520e+03L, 0x400b, 0x9d7fffffL, 0xfffffff6L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(7.00000000000000000043e+00, 0x4001, 0xe0000000L, 0x00000001L), HEXCONSTE(7.2000000000000000058477733127664675369681e+02L, 0x4008, 0xb4000000L, 0x0000000bL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(6.99999999999999999957e+00, 0x4001, 0xdfffffffL, 0xffffffffL), HEXCONSTE(7.1999999999999999941522266872335324679893e+02L, 0x4008, 0xb3ffffffL, 0xfffffff5L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(6.00000000000000000043e+00, 0x4001, 0xc0000000L, 0x00000001L), HEXCONSTE(1.2000000000000000008878927116622375680433e+02L, 0x4005, 0xf0000000L, 0x0000000dL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(5.99999999999999999957e+00, 0x4001, 0xbfffffffL, 0xffffffffL), HEXCONSTE(1.1999999999999999991121072883377624326546e+02L, 0x4005, 0xefffffffL, 0xfffffff3L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(5.00000000000000000043e+00, 0x4001, 0xa0000000L, 0x00000001L), HEXCONSTE(2.4000000000000000015676186062072582846211e+01L, 0x4003, 0xc0000000L, 0x00000009L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(4.99999999999999999957e+00, 0x4001, 0x9fffffffL, 0xffffffffL), HEXCONSTE(2.3999999999999999984323813937927417165027e+01L, 0x4003, 0xbfffffffL, 0xfffffff7L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(4.00000000000000000043e+00, 0x4001, 0x80000000L, 0x00000001L), HEXCONSTE(6.0000000000000000032685252120268430507939e+00L, 0x4001, 0xc0000000L, 0x00000008L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.99999999999999999978e+00, 0x4000, 0xffffffffL, 0xffffffffL), HEXCONSTE(5.9999999999999999983657373939865784753909e+00L, 0x4001, 0xbfffffffL, 0xfffffffcL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.00000000000000000022e+00, 0x4000, 0xc0000000L, 0x00000001L), HEXCONSTE(2.0000000000000000004001939123397399171482e+00L, 0x4000, 0x80000000L, 0x00000002L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.99999999999999999978e+00, 0x4000, 0xbfffffffL, 0xffffffffL), HEXCONSTE(1.9999999999999999995998060876602600829690e+00L, 0x3fff, 0xffffffffL, 0xfffffffcL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.00000000000000000022e+00, 0x4000, 0x80000000L, 0x00000001L), HEXCONSTE(1.0000000000000000000916767389213195151634e+00L, 0x3fff, 0x80000000L, 0x00000001L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.99999999999999999989e+00, 0x3fff, 0xffffffffL, 0xffffffffL), HEXCONSTE(9.9999999999999999995416163053934024243282e-01L, 0x3ffe, 0xffffffffL, 0xffffffffL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.00000000000000000011e+00, 0x3fff, 0x80000000L, 0x00000001L), HEXCONSTE(9.9999999999999999993741815221210931418291e-01L, 0x3ffe, 0xffffffffL, 0xffffffffL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.99999999999999999946e-01, 0x3ffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.0000000000000000000312909238939453429173e+00L, 0x3fff, 0x80000000L, 0x00000000L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-9.99999999999999999946e-01, 0xbffe, 0xffffffffL, 0xffffffffL), HEXCONSTE(-1.8446744073709551616422784335098467139470e+19L, 0xc03f, 0x80000000L, 0x00000000L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.00000000000000000011e+00, 0xbfff, 0x80000000L, 0x00000001L), HEXCONSTE(9.2233720368547758075772156649015328607596e+18L, 0x403d, 0xffffffffL, 0xffffffffL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.99999999999999999989e+00, 0xbfff, 0xffffffffL, 0xffffffffL), HEXCONSTE(4.6116860184273879044613921675492335697983e+18L, 0x403d, 0x80000000L, 0x00000001L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-2.00000000000000000022e+00, 0xc000, 0x80000000L, 0x00000001L), HEXCONSTE(-2.3058430092136939515386078324507664305064e+18L, 0xc03b, 0xffffffffL, 0xfffffffcL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-2.99999999999999999978e+00, 0xc000, 0xbfffffffL, 0xffffffffL), HEXCONSTE(-7.6861433640456465087601961140530007887063e+17L, 0xc03a, 0xaaaaaaaaL, 0xaaaaaaaeL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-3.00000000000000000022e+00, 0xc000, 0xc0000000L, 0x00000001L), HEXCONSTE(7.6861433640456465045731372192803325462836e+17L, 0x403a, 0xaaaaaaaaL, 0xaaaaaaa7L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-3.99999999999999999978e+00, 0xc000, 0xffffffffL, 0xffffffffL), HEXCONSTE(1.9215358410114116272942156951799168638773e+17L, 0x4038, 0xaaaaaaaaL, 0xaaaaaaafL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-4.00000000000000000043e+00, 0xc001, 0x80000000L, 0x00000001L), HEXCONSTE(-9.6076792050570581270578430482008313684602e+16L, 0xc037, 0xaaaaaaaaL, 0xaaaaaaa3L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-4.99999999999999999957e+00, 0xc001, 0x9fffffffL, 0xffffffffL), HEXCONSTE(-1.9215358410114116280884313903598337283601e+16L, 0xc035, 0x88888888L, 0x88888890L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-5.00000000000000000043e+00, 0xc001, 0xa0000000L, 0x00000001L), HEXCONSTE(1.9215358410114116252449019429734996071487e+16L, 0x4035, 0x88888888L, 0x88888881L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-5.99999999999999999957e+00, 0xc001, 0xbfffffffL, 0xffffffffL), HEXCONSTE(3.2025597350190193803788671320812043622696e+15L, 0x4032, 0xb60b60b6L, 0x0b60b616L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-6.00000000000000000043e+00, 0xc001, 0xc0000000L, 0x00000001L), HEXCONSTE(-3.2025597350190193751766884234743511972877e+15L, 0xc032, 0xb60b60b6L, 0x0b60b601L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-6.99999999999999999957e+00, 0xc001, 0xdfffffffL, 0xffffffffL), HEXCONSTE(-4.5750853357414562579675426149912896787735e+14L, 0xc02f, 0xd00d00d0L, 0x0d00d01aL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-7.00000000000000000043e+00, 0xc001, 0xe0000000L, 0x00000001L), HEXCONSTE(4.5750853357414562499689653215166468353753e+14L, 0x402f, 0xd00d00d0L, 0x0d00d000L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-7.99999999999999999957e+00, 0xc001, 0xffffffffL, 0xffffffffL), HEXCONSTE(5.7188566696768203227694481100089533685959e+13L, 0x402c, 0xd00d00d0L, 0x0d00d01bL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-8.00000000000000000087e+00, 0xc002, 0x80000000L, 0x00000001L), HEXCONSTE(-2.8594283348384101534210280804672371201060e+13L, 0xc02b, 0xd00d00d0L, 0x0d00cff1L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-9.99999999999999999913e+00, 0xc002, 0x9fffffffL, 0xffffffffL), HEXCONSTE(3.1771425942649001828476427167843945971988e+11L, 0x4025, 0x93f27dbbL, 0xc4fae3adL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.00000000000000000009e+01, 0xc002, 0xa0000000L, 0x00000001L), HEXCONSTE(-3.1771425942649001698860433502350057763905e+11L, 0xc025, 0x93f27dbbL, 0xc4fae382L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.99999999999999999983e+01, 0xc003, 0x9fffffffL, 0xffffffffL), HEXCONSTE(2.3694367893405502075347562184931828448654e-01L, 0x3ffc, 0xf2a15d20L, 0x10112899L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-2.00000000000000000017e+01, 0xc003, 0xa0000000L, 0x00000001L), HEXCONSTE(-2.3694367893405501827041302245929389013031e-01L, 0xbffc, 0xf2a15d20L, 0x101127e2L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-2.99999999999999999983e+01, 0xc003, 0xefffffffL, 0xffffffffL), HEXCONSTE(2.1732499046818166459536268654187775086902e-15L, 0x3fce, 0x9c996282L, 0x3eb07349L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-3.00000000000000000017e+01, 0xc003, 0xf0000000L, 0x00000001L), HEXCONSTE(-2.1732499046818166201837145753965837196590e-15L, 0xbfce, 0x9c996282L, 0x3eb072c3L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-3.99999999999999999965e+01, 0xc004, 0x9fffffffL, 0xffffffffL), HEXCONSTE(3.5326017549807232935581894777156474496719e-31L, 0x3f99, 0xe5476a15L, 0x095718d5L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-4.00000000000000000035e+01, 0xc004, 0xa0000000L, 0x00000001L), HEXCONSTE(-3.5326017549807232028299619269080956965758e-31L, 0xbf99, 0xe5476a15L, 0x0957172dL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-4.09999999999999999965e+01, 0xc004, 0xa3ffffffL, 0xffffffffL), HEXCONSTE(-8.6161018414163982777002940498289948893044e-33L, 0xbf94, 0xb2f30e1cL, 0xe81206e6L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-4.10000000000000000035e+01, 0xc004, 0xa4000000L, 0x00000001L), HEXCONSTE(8.6161018414163980549537337663264762179535e-33L, 0x3f94, 0xb2f30e1cL, 0xe8120598L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-4.19999999999999999965e+01, 0xc004, 0xa7ffffffL, 0xffffffffL), HEXCONSTE(2.0514528193848567329552463626090806737389e-34L, 0x3f8f, 0x8857a93aL, 0x986f4236L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-4.20000000000000000035e+01, 0xc004, 0xa8000000L, 0x00000001L), HEXCONSTE(-2.0514528193848566795814269269517457847791e-34L, 0xbf8f, 0x8857a93aL, 0x986f4136L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-4.99999999999999999965e+01, 0xc004, 0xc7ffffffL, 0xffffffffL), HEXCONSTE(9.4768689712397635680446279661359728835046e-48L, 0x3f62, 0xdd9b7b70L, 0x966bc1dcL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-5.00000000000000000035e+01, 0xc004, 0xc8000000L, 0x00000001L), HEXCONSTE(-9.4768689712397633101385547903658075308777e-48L, 0xbf62, 0xdd9b7b70L, 0x966bc02aL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-9.99999999999999999931e+01, 0xc005, 0xc7ffffffL, 0xffffffffL), HEXCONSTE(1.5442090669841618542494279375256856430049e-141L, 0x3e2b, 0x96a50f30L, 0x3f3c090aL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.00000000000000000007e+02, 0xc005, 0xc8000000L, 0x00000001L), HEXCONSTE(-1.5442090669841617554527108348771968070612e-141L, 0xbe2b, 0x96a50f30L, 0x3f3c0654L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.49999999999999999986e+02, 0xc006, 0x95ffffffL, 0xffffffffL), HEXCONSTE(1.2612069237291916400144732227892704713839e-246L, 0x3cce, 0x8d17957bL, 0x201f5493L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.50000000000000000014e+02, 0xc006, 0x96000000L, 0x00000001L), HEXCONSTE(-1.2612069237291914644980030550324645611752e-246L, 0xbcce, 0x8d17957bL, 0x201f4f0cL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.80999999999999999986e+02, 0xc006, 0xb4ffffffL, 0xffffffffL), HEXCONSTE(-1.9816628031468191243385005680879281767694e-315L, 0xbbe9, 0xbf418cc5L, 0x37b36dc3L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.81000000000000000014e+02, 0xc006, 0xb5000000L, 0x00000001L), HEXCONSTE(1.9816628031468188382579700510291588022368e-315L, 0x3be9, 0xbf418cc5L, 0x37b365feL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.81999999999999999986e+02, 0xc006, 0xb5ffffffL, 0xffffffffL), HEXCONSTE(1.0888257160147357826865964233809723297472e-317L, 0x3be2, 0x86827f22L, 0x9d53fe6eL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.82000000000000000014e+02, 0xc006, 0xb6000000L, 0x00000001L), HEXCONSTE(-1.0888257160147356253334423783317128355514e-317L, 0xbbe2, 0x86827f22L, 0x9d53f8f5L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.82999999999999999986e+02, 0xc006, 0xb6ffffffL, 0xffffffffL), HEXCONSTE(-5.9498673006269714905418984659220067091260e-320L, 0xbbda, 0xbc2aa974L, 0xf810c740L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.83000000000000000014e+02, 0xc006, 0xb7000000L, 0x00000001L), HEXCONSTE(5.9498673006269706297861824177538685763601e-320L, 0x3bda, 0xbc2aa974L, 0xf810bf96L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.83999999999999999986e+02, 0xc006, 0xb7ffffffL, 0xffffffffL), HEXCONSTE(3.2336235329494410277123118903958061569834e-322L, 0x3bd3, 0x82e60694L, 0x27008a9cL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.84000000000000000014e+02, 0xc006, 0xb8000000L, 0x00000001L), HEXCONSTE(-3.2336235329494405594225146768193434900135e-322L, 0xbbd3, 0x82e60694L, 0x27008546L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.87999999999999999986e+02, 0xc006, 0xbbffffffL, 0xffffffffL), HEXCONSTE(2.6730392040715350119087465463119939092815e-331L, 0x3bb4, 0xe85ec8f7L, 0x94e783c8L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.88000000000000000014e+02, 0xc006, 0xbc000000L, 0x00000001L), HEXCONSTE(-2.6730392040715346232108532050343031951651e-331L, 0xbbb4, 0xe85ec8f7L, 0x94e77a45L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.88999999999999999986e+02, 0xc006, 0xbcffffffL, 0xffffffffL), HEXCONSTE(-1.4143064571807063556111222197839950086445e-333L, 0xbbad, 0x9d5f58b2L, 0x82a4eb89L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.89000000000000000014e+02, 0xc006, 0xbd000000L, 0x00000001L), HEXCONSTE(1.4143064571807061497431633629389135273431e-333L, 0x3bad, 0x9d5f58b2L, 0x82a4e517L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.89999999999999999986e+02, 0xc006, 0xbdffffffL, 0xffffffffL), HEXCONSTE(7.4437181956879281879706555863416819210399e-336L, 0x3ba5, 0xd409e5fdL, 0xfe2c5b00L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.90000000000000000014e+02, 0xc006, 0xbe000000L, 0x00000001L), HEXCONSTE(-7.4437181956879271033676895858841525581153e-336L, 0xbba5, 0xd409e5fdL, 0xfe2c524eL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.90999999999999999986e+02, 0xc006, 0xbeffffffL, 0xffffffffL), HEXCONSTE(-3.8972346574282346536709453101948570578636e-338L, 0xbb9e, 0x8e1965dbL, 0xce864508L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.91000000000000000014e+02, 0xc006, 0xbf000000L, 0x00000001L), HEXCONSTE(3.8972346574282340852496542564155275274974e-338L, 0x3b9e, 0x8e1965dbL, 0xce863f32L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-2.49999999999999999986e+02, 0xc006, 0xf9ffffffL, 0xffffffffL), HEXCONSTE(2.2289142548411573883553287678043297937797e-476L, 0x39d2, 0xf1f35238L, 0xf43b5eeeL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-2.50000000000000000014e+02, 0xc006, 0xfa000000L, 0x00000001L), HEXCONSTE(-2.2289142548411570466476165308364665814265e-476L, 0xb9d2, 0xf1f35238L, 0xf43b547eL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-4.99999999999999999972e+02, 0xc007, 0xf9ffffffL, 0xffffffffL), HEXCONSTE(2.9528489142763141594943668922610562530068e-1118L, 0x317e, 0xc85dd278L, 0xe10f5cb2L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-5.00000000000000000028e+02, 0xc007, 0xfa000000L, 0x00000001L), HEXCONSTE(-2.9528489142763131406565394149878256133744e-1118L, 0xb17e, 0xc85dd278L, 0xe10f493dL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-7.49999999999999999944e+02, 0xc008, 0xbb7fffffL, 0xffffffffL), HEXCONSTE(6.9801511765871818502006905472380418430269e-1817L, 0x286d, 0xe84f75c0L, 0x44c366aaL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-7.50000000000000000056e+02, 0xc008, 0xbb800000L, 0x00000001L), HEXCONSTE(-6.9801511765871767194421856376592926002995e-1817L, 0xa86d, 0xe84f75c0L, 0x44c33699L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-9.99999999999999999944e+02, 0xc008, 0xf9ffffffL, 0xffffffffL), HEXCONSTE(4.4768809295877296071892611539415773519036e-2552L, 0x1ee3, 0xc247c19eL, 0x84925a9aL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.00000000000000000006e+03, 0xc008, 0xfa000000L, 0x00000001L), HEXCONSTE(-4.4768809295877261735541135972060089530309e-2552L, 0x9ee3, 0xc247c19eL, 0x849230a9L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.24999999999999999989e+03, 0xc009, 0x9c3fffffL, 0xffffffffL), HEXCONSTE(5.4651488569236507565341414077911790252381e-3315L, 0x14fd, 0x9921a2cbL, 0xcfc849eaL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.25000000000000000011e+03, 0xc009, 0x9c400000L, 0x00000001L), HEXCONSTE(-5.4651488569236421026544487194247355967789e-3315L, 0x94fd, 0x9921a2cbL, 0xcfc805aaL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.49999999999999999989e+03, 0xc009, 0xbb7fffffL, 0xffffffffL), HEXCONSTE(1.8718211510339187689122114747834510481993e-4099L, 0x0acf, 0x9fead01fL, 0x21151ecfL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.50000000000000000011e+03, 0xc009, 0xbb800000L, 0x00000001L), HEXCONSTE(-1.8718211510339157291960718369454861898499e-4099L, 0x8acf, 0x9fead01fL, 0x2114d5b6L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.74999999999999999989e+03, 0xc009, 0xdabfffffL, 0xffffffffL), HEXCONSTE(4.2925786447266492555651378780094011518063e-4902L, 0x0065, 0x80eb5143L, 0x485824e1L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.75000000000000000011e+03, 0xc009, 0xdac00000L, 0x00000001L), HEXCONSTE(-4.2925786447266421378134368786479937285900e-4902L, 0x8065, 0x80eb5143L, 0x4857e8b5L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.76299999999999999989e+03, 0xc009, 0xdc5fffffL, 0xffffffffL), HEXCONSTE(-2.8229173528168668283609231628661510187536e-4944L, 0x8000, 0x00000000L, 0x00762acdL), FLAG_INEXACT|UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(-1.76300000000000000011e+03, 0xc009, 0xdc600000L, 0x00000001L), HEXCONSTE(2.8229173528168621428945467532322397890424e-4944L, 0x0000, 0x00000000L, 0x00762acdL), FLAG_INEXACT|UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(-1.76399999999999999989e+03, 0xc009, 0xdc7fffffL, 0xffffffffL), HEXCONSTE(1.6002932839097884515524894602387278842659e-4947L, 0x0000, 0x00000000L, 0x00001126L), FLAG_INEXACT|UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(-1.76400000000000000011e+03, 0xc009, 0xdc800000L, 0x00000001L), HEXCONSTE(-1.6002932839097857951909742110188634438017e-4947L, 0x8000, 0x00000000L, 0x00001126L), FLAG_INEXACT|UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(-1.76499999999999999989e+03, 0xc009, 0xdc9fffffL, 0xffffffffL), HEXCONSTE(-9.0668174725767051085164382743343408095146e-4951L, 0x8000, 0x00000000L, 0x00000002L), FLAG_INEXACT|UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(-1.76500000000000000011e+03, 0xc009, 0xdca00000L, 0x00000001L), HEXCONSTE(9.0668174725766900571689083050287838090189e-4951L, 0x0000, 0x00000000L, 0x00000002L), FLAG_INEXACT|UNDERFLOW_EXCEPTION },
# if LDBL_MANT_DIG <= 64
	{ __LINE__, HEXCONSTE(-1.76599999999999999989e+03, 0xc009, 0xdcbfffffL, 0xffffffffL), ZERO_P, UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(-1.76600000000000000011e+03, 0xc009, 0xdcc00000L, 0x00000001L), ZERO_M, UNDERFLOW_EXCEPTION },
# else
	{ __LINE__, HEXCONSTE(-1.76599999999999999989e+03, 0xc009, 0xdcbfffffL, 0xffffffffL), HEXCONSTE(5.1340982290921319983501912122292601780326e-4954L, 0x0000, 0x00000000L, 0x00000000L), UNDERFLOW_EXCEPTION },
	{ __LINE__, HEXCONSTE(-1.76600000000000000011e+03, 0xc009, 0xdcc00000L, 0x00000001L), HEXCONSTE(-5.1340982290921234748578193083614111497314e-4954L, 0x8000, 0x00000000L, 0x00000000L), UNDERFLOW_EXCEPTION },
# endif
#endif
#ifndef TEST_FLOAT
	{ __LINE__, HEXCONSTE(-3.32747230529785156250e+01, 0xc004, 0x85195100L, 0x00000000L), HEXCONSTE(1.8125267978155035272941154746083439329912e-37L, 0x3f84, 0xf6b55750L, 0x3d661374L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(-1.72000000014901189616e+02, 0xc006, 0xac000000L, 0x40000800L), HEXCONSTE(-3.1439271448823567326093363350637118195240e-304L, 0xbc0e, 0xdcc62996L, 0x3ba2d24fL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(3.50400962829589843750e+01, 0x4004, 0x8c290f00L, 0x00000000L), HEXCONSTE(3.4027979115654976101247558405326779640190e+38L, 0x407e, 0xffff8101L, 0x4863292cL), FLAG_INEXACT },
#endif
	{ __LINE__, HEXCONSTE(18.5L, 0x4003, 0x94000000L, 0x00000000L), HEXCONSTE(1.4986120533153361177371791123515513270334e+15L, 0x4031, 0xaa5f59e3L, 0x01e103c5L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(19.5L, 0x4003, 0x9c000000L, 0x00000000L), HEXCONSTE(2.7724322986333718178137813578503699550119e+16L, 0x4035, 0xc4fe3feeL, 0x7a2c2c5bL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(23.5L, 0x4003, 0xbc000000L, 0x00000000L), HEXCONSTE(5.3613035875444147334274983856108155717836e+21L, 0x4047, 0x9151844bL, 0xbbe21b62L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(29.5L, 0x4003, 0xec000000L, 0x00000000L), HEXCONSTE(1.6348125198274266444378807806868221866931e+30L, 0x4063, 0xa512e9c5L, 0xc15bee3fL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(30.5L, 0x4003, 0xf4000000L, 0x00000000L), HEXCONSTE(4.8226969334909086010917483030261254507447e+31L, 0x4068, 0x982d6f82L, 0x4e40bfa2L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(31.5L, 0x4003, 0xfc000000L, 0x00000000L), HEXCONSTE(1.4709225647147271233329832324229682624771e+33L, 0x406d, 0x910b4e48L, 0x3295b6a6L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(32.5L, 0x4004, 0x82000000L, 0x00000000L), HEXCONSTE(4.6334060788513904384988971821323500268029e+34L, 0x4072, 0x8ec7210fL, 0x11cb5fccL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(33.5L, 0x4004, 0x86000000L, 0x00000000L), HEXCONSTE(1.5058569756267018925121415841930137587110e+36L, 0x4077, 0x91023d93L, 0x4e128d4bL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(34.5L, 0x4004, 0x8a000000L, 0x00000000L), HEXCONSTE(5.0446208683494513399156743070465960916817e+37L, 0x407c, 0x97ce5876L, 0x35bb6beaL), FLAG_INEXACT },
#ifdef TEST_FLOAT
	{ __LINE__, HEXCONSTE(3.50401000976562500000e+01, 0x4004, 0x8c291000L, 0x00000000L), INF_P, OVERFLOW_EXCEPTION|ERRNO_ERANGE },
#else
	{ __LINE__, HEXCONSTE(3.50401000976562500000e+01, 0x4004, 0x8c291000L, 0x00000000L), HEXCONSTE(3.4028438913396451054667218138127983367181e+38L, 0x407f, 0x800031d9L, 0xf558cc96L), FLAG_INEXACT },
#endif
#ifndef TEST_FLOAT
	{ __LINE__, HEXCONSTE(1.71624376956302711505e+02, 0x4006, 0xab9fd72bL, 0x0fb23800L), HEXCONSTE(1.7976931348622298700886249281842651388250e+308L, 0x43fe, 0xffffffffL, 0xfff28752L), FLAG_INEXACT },
# if !defined TEST_LDOUBLE || LDBL_MAX_EXP <= 1024
	{ __LINE__, HEXCONSTE(1.71624376956302739927e+02, 0x4006, 0xab9fd72bL, 0x0fb24000L), INF_P, OVERFLOW_EXCEPTION|ERRNO_ERANGE },
# else
	{ __LINE__, HEXCONSTE(1.71624376956302739927e+02, 0x4006, 0xab9fd72bL, 0x0fb24000L), HEXCONSTE(1.7976931348624926129589466917917870782484e+308L, 0x43ff, 0x80000000L, 0x000dd578L), FLAG_INEXACT },
# endif
#endif
#if defined TEST_LDOUBLE && LDBL_MAX_EXP >= 16384
	/* { __LINE__, HEXCONSTE(1.75554834290446291700e+03, 0x4009, 0xdb718c06L, 0x6b352e21L), HEXCONSTE(1.1897314953572317517071551278058233700012e+4932L, 0x7ffe, 0xffffffffL, 0xffffff31L), FLAG_INEXACT }, */
	{ __LINE__, HEXCONSTE(1.75554834290446291711e+03, 0x4009, 0xdb718c06L, 0x6b352e22L), INF_P, OVERFLOW_EXCEPTION|ERRNO_ERANGE },
#endif
};


int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_f_f(lgamma_data, ARRAY_SIZE(lgamma_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

#else

int main(void)
{
	return 77;
}

#endif

```

`tests/trunc.c`:

```c
#include "testconfig.h"
#ifdef HAVE_TRUNC
#define TEST_FUNC_F_F __MATH_PRECNAME(trunc)
#include "testdriver.h"



static test_f_f_data const fintrz_data[] = {
	{ __LINE__, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_P, 0 },
	{ __LINE__, SNAN_P, QNAN_P, 0 },
	{ __LINE__, SNAN_M, QNAN_P, 0 },
	{ __LINE__, INF_P, INF_P, FLAG_XFAIL_LINUX }, /* generates NaN */
	{ __LINE__, INF_M, INF_M, FLAG_XFAIL_LINUX }, /* generates NaN */
	{ __LINE__, ZERO_P, ZERO_P, 0 },
	{ __LINE__, ZERO_M, ZERO_M, FLAG_FAIL_ARANYM2 },
	{ __LINE__, SUBNORM_P, ZERO_P, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, ZERO_M, FLAG_SUBNORM },
	{ __LINE__, MIN_P, ZERO_P, FLAG_MINVAL }, /* generates NaN */
	{ __LINE__, MIN_M, ZERO_M, FLAG_MINVAL }, /* generates NaN */
	{ __LINE__, MAX_P, MAX_P, 0 },
	{ __LINE__, MAX_M, MAX_M, 0 },
	
	{ __LINE__, HEXCONSTE(4.5, 0x4001, 0x90000000L, 0x00000000L), HEXCONSTE(4.0, 0x4001, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.5, 0x4000, 0xe0000000L, 0x00000000L), HEXCONSTE(3.0, 0x4000, 0xc0000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.5, 0x4000, 0xa0000000L, 0x00000000L), HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.5, 0x3fff, 0xc0000000L, 0x00000000L), HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.5, 0x3ffe, 0x80000000L, 0x00000000L), ZERO_P, 0 },
	{ __LINE__, HEXCONSTE(-0.5, 0xbffe, 0x80000000L, 0x00000000L), ZERO_M, FLAG_IGNORE_ZEROSIGN },
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.5, 0xbfff, 0xc0000000L, 0x00000000L), HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-2.0, 0xc000, 0x80000000L, 0x00000000L), HEXCONSTE(-2.0, 0xc000, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-2.5, 0xc000, 0xa0000000L, 0x00000000L), HEXCONSTE(-2.0, 0xc000, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-3.5, 0xc000, 0xe0000000L, 0x00000000L), HEXCONSTE(-3.0, 0xc000, 0xc0000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-4.5, 0xc001, 0x90000000L, 0x00000000L), HEXCONSTE(-4.0, 0xc001, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.1, 0x3ffb, 0xccccccccL, 0xcccccccdL), ZERO_P, 0 },
	{ __LINE__, HEXCONSTE(0.25, 0x3ffd, 0x80000000L, 0x00000000L), ZERO_P, 0 },
	{ __LINE__, HEXCONSTE(0.625, 0x3ffe, 0xa0000000L, 0x00000000L), ZERO_P, 0 },
	{ __LINE__, HEXCONSTE(1.625, 0x3fff, 0xd0000000L, 0x00000000L), HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-0.1, 0xbffb, 0xccccccccL, 0xcccccccdL), ZERO_M, FLAG_IGNORE_ZEROSIGN },
	{ __LINE__, HEXCONSTE(-0.25, 0xbffd, 0x80000000L, 0x00000000L), ZERO_M, FLAG_IGNORE_ZEROSIGN },
	{ __LINE__, HEXCONSTE(-0.625, 0xbffe, 0xa0000000L, 0x00000000L), ZERO_M, FLAG_IGNORE_ZEROSIGN },
	{ __LINE__, HEXCONSTE(-1.625, 0xbfff, 0xd0000000L, 0x00000000L), HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(262144.75, 0x4011, 0x80001800L, 0x00000000L), HEXCONSTE(262144.0, 0x4011, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(262142.75, 0x4010, 0xffffb000L, 0x00000000L), HEXCONSTE(262142.0, 0x4010, 0xffff8000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(524286.75, 0x4011, 0xffffd800L, 0x00000000L), HEXCONSTE(524286.0, 0x4011, 0xffffc000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(524288.75, 0x4012, 0x80000c00L, 0x00000000L), HEXCONSTE(524288.0, 0x4012, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1048576.75, 0x4013, 0x80000600L, 0x00000000L), HEXCONSTE(1048576.0, 0x4013, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1048580.625, 0x4013, 0x80002500L, 0x00000000L), HEXCONSTE(1048580, 0x4013, 0x80002000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2097152.75, 0x4014, 0x80000300L, 0x00000000L), HEXCONSTE(2097152.0, 0x4014, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2492472.75, 0x4014, 0x9820e300L, 0x00000000L), HEXCONSTE(2492472.0, 0x4014, 0x9820e000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2886220.75, 0x4014, 0xb0293300L, 0x00000000L), HEXCONSTE(2886220.0, 0x4014, 0xb0293000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3058792.75, 0x4014, 0xbab1a300L, 0x00000000L), HEXCONSTE(3058792.0, 0x4014, 0xbab1a000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(8388610.125, 0x4016, 0x80000220L, 0x00000000L), HEXCONSTE(8388610.0, 0x4016, 0x80000200L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4294967296.625, 0x401f, 0x80000000L, 0x50000000L), HEXCONSTE(4294967296.0, 0x401f, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1048580.625, 0xc013, 0x80002500L, 0x00000000L), HEXCONSTE(-1048580, 0xc013, 0x80002000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1048576.75, 0xc013, 0x80000600L, 0x00000000L), HEXCONSTE(-1048576.0, 0xc013, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-2097152.75, 0xc014, 0x80000300L, 0x00000000L), HEXCONSTE(-2097152.0, 0xc014, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-2492472.75, 0xc014, 0x9820e300L, 0x00000000L), HEXCONSTE(-2492472.0, 0xc014, 0x9820e000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-2886220.75, 0xc014, 0xb0293300L, 0x00000000L), HEXCONSTE(-2886220.0, 0xc014, 0xb0293000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-3058792.75, 0xc014, 0xbab1a300L, 0x00000000L), HEXCONSTE(-3058792.0, 0xc014, 0xbab1a000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-8388610.125, 0xc016, 0x80000220L, 0x00000000L), HEXCONSTE(-8388610.0, 0xc016, 0x80000200L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-4294967296.625, 0xc01f, 0x80000000L, 0x50000000L), HEXCONSTE(-4294967296.0, 0xc01f, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(70368744177664.75, 0x402d, 0x80000000L, 0x00018000L), HEXCONSTE(70368744177664.0, 0x402d, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(140737488355328.75, 0x402e, 0x80000000L, 0x0000c000L), HEXCONSTE(140737488355328.0, 0x402e, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(281474976710656.75, 0x402f, 0x80000000L, 0x00006000L), HEXCONSTE(281474976710656.0, 0x402f, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(562949953421312.75, 0x4030, 0x80000000L, 0x00003000L), HEXCONSTE(562949953421312.0, 0x4030, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1125899906842624.75, 0x4031, 0x80000000L, 0x00001800L), HEXCONSTE(1125899906842624.0, 0x4031, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-70368744177664.75, 0xc02d, 0x80000000L, 0x00018000L), HEXCONSTE(-70368744177664.0, 0xc02d, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-140737488355328.75, 0xc02e, 0x80000000L, 0x0000c000L), HEXCONSTE(-140737488355328.0, 0xc02e, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-281474976710656.75, 0xc02f, 0x80000000L, 0x00006000L), HEXCONSTE(-281474976710656.0, 0xc02f, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-562949953421312.75, 0xc030, 0x80000000L, 0x00003000L), HEXCONSTE(-562949953421312.0, 0xc030, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1125899906842624.75, 0xc031, 0x80000000L, 0x00001800L), HEXCONSTE(-1125899906842624.0, 0xc031, 0x80000000L, 0x00000000L), 0 },

	{ __LINE__, HEXCONSTE(8.38860800000000000000e+06, 0x4016, 0x80000000L, 0x00000000L), HEXCONSTE(8.38860800000000000000e+06, 0x4016, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.67772160000000000000e+07, 0x4017, 0x80000000L, 0x00000000L), HEXCONSTE(1.67772160000000000000e+07, 0x4017, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.35544320000000000000e+07, 0x4018, 0x80000000L, 0x00000000L), HEXCONSTE(3.35544320000000000000e+07, 0x4018, 0x80000000L, 0x00000000L), 0 },

	{ __LINE__, HEXCONSTE(4.50359962737049600000e+15, 0x4033, 0x80000000L, 0x00000000L), HEXCONSTE(4.50359962737049600000e+15, 0x4033, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4503599627370495.5, 0x4032, 0xffffffffL, 0xfffff800L), HEXCONSTE(4503599627370495.0, 0x4032, 0xffffffffL, 0xfffff000L), 0 },
	{ __LINE__, HEXCONSTE(4503599627370496.25, 0x4033, 0x80000000L, 0x00000200L), HEXCONSTE(4503599627370496.0, 0x4033, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4503599627370496.5, 0x4033, 0x80000000L, 0x00000400L), HEXCONSTE(4503599627370496.0, 0x4033, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4503599627370496.75, 0x4033, 0x80000000L, 0x00000600L), HEXCONSTE(4503599627370496.0, 0x4033, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4503599627370497.5, 0x4033, 0x80000000L, 0x00000c00L), HEXCONSTE(4503599627370497.0, 0x4033, 0x80000000L, 0x00000800L), 0 },
	{ __LINE__, HEXCONSTE(9.00719925474099200000e+15, 0x4034, 0x80000000L, 0x00000000L), HEXCONSTE(9.00719925474099200000e+15, 0x4034, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.80143985094819840000e+16, 0x4035, 0x80000000L, 0x00000000L), HEXCONSTE(1.80143985094819840000e+16, 0x4035, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(72057594037927935.5, 0x4036, 0xffffffffL, 0xffffff80L), HEXCONSTE(72057594037927935.0, 0x4036, 0xffffffffL, 0xffffff00L), 0 },
	{ __LINE__, HEXCONSTE(72057594037927936.25, 0x4037, 0x80000000L, 0x00000020L), HEXCONSTE(72057594037927936.0, 0x4037, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(72057594037927936.5, 0x4037, 0x80000000L, 0x00000040L), HEXCONSTE(72057594037927936.0, 0x4037, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(72057594037927936.75, 0x4037, 0x80000000L, 0x00000060L), HEXCONSTE(72057594037927936.0, 0x4037, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(72057594037927937.5, 0x4037, 0x80000000L, 0x000000c0L), HEXCONSTE(72057594037927937.0, 0x4037, 0x80000000L, 0x00000080L), 0 },
	{ __LINE__, HEXCONSTE(9.22337203685477580800e+18, 0x403e, 0x80000000L, 0x00000000L), HEXCONSTE(9.22337203685477580800e+18, 0x403e, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.84467440737095516160e+19, 0x403f, 0x80000000L, 0x00000000L), HEXCONSTE(1.84467440737095516160e+19, 0x403f, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(3.68934881474191032320e+19, 0x4040, 0x80000000L, 0x00000000L), HEXCONSTE(3.68934881474191032320e+19, 0x4040, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4.05648192073033408479e+31, 0x4068, 0x80000000L, 0x00000000L), HEXCONSTE(4.05648192073033408479e+31, 0x4068, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(8.11296384146066816958e+31, 0x4069, 0x80000000L, 0x00000000L), HEXCONSTE(8.11296384146066816958e+31, 0x4069, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.62259276829213363392e+32, 0x406a, 0x80000000L, 0x00000000L), HEXCONSTE(1.62259276829213363392e+32, 0x406a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(5.19229685853482762853e+33, 0x406f, 0x80000000L, 0x00000000L), HEXCONSTE(5.19229685853482762853e+33, 0x406f, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(1.03845937170696552571e+34, 0x4070, 0x80000000L, 0x00000000L), HEXCONSTE(1.03845937170696552571e+34, 0x4070, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(2.07691874341393105141e+34, 0x4071, 0x80000000L, 0x00000000L), HEXCONSTE(2.07691874341393105141e+34, 0x4071, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-8.38860800000000000000e+06, 0xc016, 0x80000000L, 0x00000000L), HEXCONSTE(-8.38860800000000000000e+06, 0xc016, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.67772160000000000000e+07, 0xc017, 0x80000000L, 0x00000000L), HEXCONSTE(-1.67772160000000000000e+07, 0xc017, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-3.35544320000000000000e+07, 0xc018, 0x80000000L, 0x00000000L), HEXCONSTE(-3.35544320000000000000e+07, 0xc018, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-4.50359962737049600000e+15, 0xc033, 0x80000000L, 0x00000000L), HEXCONSTE(-4.50359962737049600000e+15, 0xc033, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-4503599627370495.5, 0xc032, 0xffffffffL, 0xfffff800L), HEXCONSTE(-4503599627370495.0, 0xc032, 0xffffffffL, 0xfffff000L), 0 },
	{ __LINE__, HEXCONSTE(-4503599627370496.25, 0xc033, 0x80000000L, 0x00000200L), HEXCONSTE(-4503599627370496.0, 0xc033, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-4503599627370496.5, 0xc033, 0x80000000L, 0x00000400L), HEXCONSTE(-4503599627370496.0, 0xc033, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-4503599627370496.75, 0xc033, 0x80000000L, 0x00000600L), HEXCONSTE(-4503599627370496.0, 0xc033, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-4503599627370497.5, 0xc033, 0x80000000L, 0x00000c00L), HEXCONSTE(-4503599627370497.0, 0xc033, 0x80000000L, 0x00000800L), 0 },
	{ __LINE__, HEXCONSTE(-9007199254740991.5, 0xc033, 0xffffffffL, 0xfffffc00L), HEXCONSTE(-9007199254740991.0, 0xc033, 0xffffffffL, 0xfffff800L), 0 },
	{ __LINE__, HEXCONSTE(-9007199254740992.25, 0xc034, 0x80000000L, 0x00000100L), HEXCONSTE(-9007199254740992.0, 0xc034, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-9007199254740992.5, 0xc034, 0x80000000L, 0x00000200L), HEXCONSTE(-9007199254740992.0, 0xc034, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-9007199254740992.75, 0xc034, 0x80000000L, 0x00000300L), HEXCONSTE(-9007199254740992.0, 0xc034, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-9007199254740993.5, 0xc034, 0x80000000L, 0x00000600L), HEXCONSTE(-9007199254740993.0, 0xc034, 0x80000000L, 0x00000400L), 0 },
	{ __LINE__, HEXCONSTE(-9.00719925474099200000e+15, 0xc034, 0x80000000L, 0x00000000L), HEXCONSTE(-9.00719925474099200000e+15, 0xc034, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.80143985094819840000e+16, 0xc035, 0x80000000L, 0x00000000L), HEXCONSTE(-1.80143985094819840000e+16, 0xc035, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-72057594037927935.5, 0xc036, 0xffffffffL, 0xffffff80L), HEXCONSTE(-72057594037927935.0, 0xc036, 0xffffffffL, 0xffffff00L), 0 },
	{ __LINE__, HEXCONSTE(-72057594037927936.25, 0xc037, 0x80000000L, 0x00000020L), HEXCONSTE(-72057594037927936.0, 0xc037, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-72057594037927936.5, 0xc037, 0x80000000L, 0x00000040L), HEXCONSTE(-72057594037927936.0, 0xc037, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-72057594037927936.75, 0xc037, 0x80000000L, 0x00000060L), HEXCONSTE(-72057594037927936.0, 0xc037, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-72057594037927937.5, 0xc037, 0x80000000L, 0x000000c0L), HEXCONSTE(-72057594037927937.0, 0xc037, 0x80000000L, 0x00000080L), 0 },
	{ __LINE__, HEXCONSTE(-9.22337203685477580800e+18, 0xc03e, 0x80000000L, 0x00000000L), HEXCONSTE(-9.22337203685477580800e+18, 0xc03e, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.84467440737095516160e+19, 0xc03f, 0x80000000L, 0x00000000L), HEXCONSTE(-1.84467440737095516160e+19, 0xc03f, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-3.68934881474191032320e+19, 0xc040, 0x80000000L, 0x00000000L), HEXCONSTE(-3.68934881474191032320e+19, 0xc040, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-4.05648192073033408479e+31, 0xc068, 0x80000000L, 0x00000000L), HEXCONSTE(-4.05648192073033408479e+31, 0xc068, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-8.11296384146066816958e+31, 0xc069, 0x80000000L, 0x00000000L), HEXCONSTE(-8.11296384146066816958e+31, 0xc069, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.62259276829213363392e+32, 0xc06a, 0x80000000L, 0x00000000L), HEXCONSTE(-1.62259276829213363392e+32, 0xc06a, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-5.19229685853482762853e+33, 0xc06f, 0x80000000L, 0x00000000L), HEXCONSTE(-5.19229685853482762853e+33, 0xc06f, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.03845937170696552571e+34, 0xc070, 0x80000000L, 0x00000000L), HEXCONSTE(-1.03845937170696552571e+34, 0xc070, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-2.07691874341393105141e+34, 0xc071, 0x80000000L, 0x00000000L), HEXCONSTE(-2.07691874341393105141e+34, 0xc071, 0x80000000L, 0x00000000L), 0 },
	
	{ __LINE__, HEXCONSTE(0.2, 0x3ffc, 0xccccccccL, 0xcccccccdL), ZERO_P, 0 },
	{ __LINE__, HEXCONSTE(-0.2, 0xbffc, 0xccccccccL, 0xcccccccdL), ZERO_M, FLAG_IGNORE_ZEROSIGN },
	{ __LINE__, HEXCONSTE(0.5, 0x3ffe, 0x80000000L, 0x00000000L), ZERO_P, 0 },
	{ __LINE__, HEXCONSTE(-0.5, 0xbffe, 0x80000000L, 0x00000000L), ZERO_M, FLAG_IGNORE_ZEROSIGN },
	{ __LINE__, HEXCONSTE(0.8, 0x3ffe, 0xccccccccL, 0xcccccccdL), ZERO_P, 0 },
	{ __LINE__, HEXCONSTE(-0.8, 0xbffe, 0xccccccccL, 0xcccccccdL), ZERO_M, FLAG_IGNORE_ZEROSIGN },
	{ __LINE__, HEXCONSTE(1.5, 0x3fff, 0xc0000000L, 0x00000000L), HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-1.5, 0xbfff, 0xc0000000L, 0x00000000L), HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(0.1, 0x3ffb, 0xccccccccL, 0xcccccccdL), ZERO_P, 0 },
	{ __LINE__, HEXCONSTE(0.25, 0x3ffd, 0x80000000L, 0x00000000L), ZERO_P, 0 },
	{ __LINE__, HEXCONSTE(0.625, 0x3ffe, 0xa0000000L, 0x00000000L), ZERO_P, 0 },
	{ __LINE__, HEXCONSTE(-0.1, 0xbffb, 0xccccccccL, 0xcccccccdL), ZERO_M, FLAG_IGNORE_ZEROSIGN },
	{ __LINE__, HEXCONSTE(-0.25, 0xbffd, 0x80000000L, 0x00000000L), ZERO_M, FLAG_IGNORE_ZEROSIGN },
	{ __LINE__, HEXCONSTE(-0.625, 0xbffe, 0xa0000000L, 0x00000000L), ZERO_M, FLAG_IGNORE_ZEROSIGN },
	{ __LINE__, HEXCONSTE(2097152.5, 0x4014, 0x80000200L, 0x00000000L), HEXCONSTE(2097152, 0x4014, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-2097152.5, 0xc014, 0x80000200L, 0x00000000L), HEXCONSTE(-2097152, 0xc014, 0x80000000L, 0x00000000L), 0 },
	
	{ __LINE__, HEXCONSTE(2.81474976710655000000e+14, 0x402e, 0xffffffffL, 0xffff0000L), HEXCONSTE(2.81474976710655000000e+14, 0x402e, 0xffffffffL, 0xffff0000L), 0 },
	{ __LINE__, HEXCONSTE(2.81474976710655250000e+14, 0x402e, 0xffffffffL, 0xffff4000L), HEXCONSTE(2.81474976710655000000e+14, 0x402e, 0xffffffffL, 0xffff0000L), 0 },
	{ __LINE__, HEXCONSTE(2.81474976710655500000e+14, 0x402e, 0xffffffffL, 0xffff8000L), HEXCONSTE(2.81474976710655000000e+14, 0x402e, 0xffffffffL, 0xffff0000L), 0 },
	{ __LINE__, HEXCONSTE(2.81474976710655750000e+14, 0x402e, 0xffffffffL, 0xffffc000L), HEXCONSTE(2.81474976710655000000e+14, 0x402e, 0xffffffffL, 0xffff0000L), 0 },
	{ __LINE__, HEXCONSTE(-2.81474976710655000000e+14, 0xc02e, 0xffffffffL, 0xffff0000L), HEXCONSTE(-2.81474976710655000000e+14, 0xc02e, 0xffffffffL, 0xffff0000L), 0 },
	{ __LINE__, HEXCONSTE(-2.81474976710655250000e+14, 0xc02e, 0xffffffffL, 0xffff4000L), HEXCONSTE(-2.81474976710655000000e+14, 0xc02e, 0xffffffffL, 0xffff0000L), 0 },
	{ __LINE__, HEXCONSTE(-2.81474976710655500000e+14, 0xc02e, 0xffffffffL, 0xffff8000L), HEXCONSTE(-2.81474976710655000000e+14, 0xc02e, 0xffffffffL, 0xffff0000L), 0 },
	{ __LINE__, HEXCONSTE(-2.81474976710655750000e+14, 0xc02e, 0xffffffffL, 0xffffc000L), HEXCONSTE(-2.81474976710655000000e+14, 0xc02e, 0xffffffffL, 0xffff0000L), 0 },
	
	/* The result can only be represented in long double. */
	{ __LINE__, HEXCONSTE(4503599627370495.5, 0x4032, 0xffffffffL, 0xfffff800L), HEXCONSTE(4503599627370495.0, 0x4032, 0xffffffffL, 0xfffff000L), 0 },
	{ __LINE__, HEXCONSTE(4503599627370496.25, 0x4033, 0x80000000L, 0x00000200L), HEXCONSTE(4503599627370496.0, 0x4033, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4503599627370496.5, 0x4033, 0x80000000L, 0x00000400L), HEXCONSTE(4503599627370496.0, 0x4033, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4503599627370496.75, 0x4033, 0x80000000L, 0x00000600L), HEXCONSTE(4503599627370496.0, 0x4033, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(4503599627370497.5, 0x4033, 0x80000000L, 0x00000c00L), HEXCONSTE(4503599627370497.0, 0x4033, 0x80000000L, 0x00000800L), 0 },
	{ __LINE__, HEXCONSTE(-4503599627370495.5, 0xc032, 0xffffffffL, 0xfffff800L), HEXCONSTE(-4503599627370495.0, 0xc032, 0xffffffffL, 0xfffff000L), 0 },
	{ __LINE__, HEXCONSTE(-4503599627370496.25, 0xc033, 0x80000000L, 0x00000200L), HEXCONSTE(-4503599627370496.0, 0xc033, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-4503599627370496.5, 0xc033, 0x80000000L, 0x00000400L), HEXCONSTE(-4503599627370496.0, 0xc033, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-4503599627370496.75, 0xc033, 0x80000000L, 0x00000600L), HEXCONSTE(-4503599627370496.0, 0xc033, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-4503599627370497.5, 0xc033, 0x80000000L, 0x00000c00L), HEXCONSTE(-4503599627370497.0, 0xc033, 0x80000000L, 0x00000800L), 0 },
	
	{ __LINE__, HEXCONSTE(9007199254740991.5, 0x4033, 0xffffffffL, 0xfffffc00L), HEXCONSTE(9007199254740991.0, 0x4033, 0xffffffffL, 0xfffff800L), 0 },
	{ __LINE__, HEXCONSTE(9007199254740992.25, 0x4034, 0x80000000L, 0x00000100L), HEXCONSTE(9007199254740992.0, 0x4034, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9007199254740992.5, 0x4034, 0x80000000L, 0x00000200L), HEXCONSTE(9007199254740992.0, 0x4034, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9007199254740992.75, 0x4034, 0x80000000L, 0x00000300L), HEXCONSTE(9007199254740992.0, 0x4034, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(9007199254740993.5, 0x4034, 0x80000000L, 0x00000600L), HEXCONSTE(9007199254740993.0, 0x4034, 0x80000000L, 0x00000400L), 0 },
	
	{ __LINE__, HEXCONSTE(-9007199254740991.5, 0xc033, 0xffffffffL, 0xfffffc00L), HEXCONSTE(-9007199254740991.0, 0xc033, 0xffffffffL, 0xfffff800L), 0 },
	{ __LINE__, HEXCONSTE(-9007199254740992.25, 0xc034, 0x80000000L, 0x00000100L), HEXCONSTE(-9007199254740992.0, 0xc034, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-9007199254740992.5, 0xc034, 0x80000000L, 0x00000200L), HEXCONSTE(-9007199254740992.0, 0xc034, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-9007199254740992.75, 0xc034, 0x80000000L, 0x00000300L), HEXCONSTE(-9007199254740992.0, 0xc034, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-9007199254740993.5, 0xc034, 0x80000000L, 0x00000600L), HEXCONSTE(-9007199254740993.0, 0xc034, 0x80000000L, 0x00000400L), 0 },
	
	{ __LINE__, HEXCONSTE(72057594037927935.5, 0x4036, 0xffffffffL, 0xffffff80L), HEXCONSTE(72057594037927935.0, 0x4036, 0xffffffffL, 0xffffff00L), 0 },
	{ __LINE__, HEXCONSTE(72057594037927936.25, 0x4037, 0x80000000L, 0x00000020L), HEXCONSTE(72057594037927936.0, 0x4037, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(72057594037927936.5, 0x4037, 0x80000000L, 0x00000040L), HEXCONSTE(72057594037927936.0, 0x4037, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(72057594037927936.75, 0x4037, 0x80000000L, 0x00000060L), HEXCONSTE(72057594037927936.0, 0x4037, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(72057594037927937.5, 0x4037, 0x80000000L, 0x000000c0L), HEXCONSTE(72057594037927937.0, 0x4037, 0x80000000L, 0x00000080L), 0 },
	
	{ __LINE__, HEXCONSTE(-72057594037927935.5, 0xc036, 0xffffffffL, 0xffffff80L), HEXCONSTE(-72057594037927935.0, 0xc036, 0xffffffffL, 0xffffff00L), 0 },
	{ __LINE__, HEXCONSTE(-72057594037927936.25, 0xc037, 0x80000000L, 0x00000020L), HEXCONSTE(-72057594037927936.0, 0xc037, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-72057594037927936.5, 0xc037, 0x80000000L, 0x00000040L), HEXCONSTE(-72057594037927936.0, 0xc037, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-72057594037927936.75, 0xc037, 0x80000000L, 0x00000060L), HEXCONSTE(-72057594037927936.0, 0xc037, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(-72057594037927937.5, 0xc037, 0x80000000L, 0x000000c0L), HEXCONSTE(-72057594037927937.0, 0xc037, 0x80000000L, 0x00000080L), 0 },
	
	{ __LINE__, HEXCONSTE(34503599627370498.515625, 0x4035, 0xf529ae9eL, 0x86000508L), HEXCONSTE(34503599627370498.0, 0x4035, 0xf529ae9eL, 0x86000400L), 0 },
	{ __LINE__, HEXCONSTE(-34503599627370498.515625, 0xc035, 0xf529ae9eL, 0x86000508L), HEXCONSTE(-34503599627370498.0, 0xc035, 0xf529ae9eL, 0x86000400L), 0 },
	
	{ __LINE__, HEXCONSTE(10141204801825835211973625643007.5, 0x4066, 0x80000000L, 0x00000000L), HEXCONSTE(10141204801825835211973625643007.0, 0x4066, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(10141204801825835211973625643008.25, 0x4066, 0x80000000L, 0x00000000L), HEXCONSTE(10141204801825835211973625643008.0, 0x4066, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(10141204801825835211973625643008.5, 0x4066, 0x80000000L, 0x00000000L), HEXCONSTE(10141204801825835211973625643008.0, 0x4066, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(10141204801825835211973625643008.75, 0x4066, 0x80000000L, 0x00000000L), HEXCONSTE(10141204801825835211973625643008.0, 0x4066, 0x80000000L, 0x00000000L), 0 },
	{ __LINE__, HEXCONSTE(10141204801825835211973625643009.5, 0x4066, 0x80000000L, 0x00000000L), HEXCONSTE(10141204801825835211973625643009.0, 0x4066, 0x80000000L, 0x00000000L), 0 },
	
	{ __LINE__, HEXCONSTE(-8.98847e+307, 0xc3fe, 0x80000409L, 0x7954f717L), HEXCONSTE(-8.98847e+307, 0xc3fe, 0x80000409L, 0x7954f717L), 0 },
	{ __LINE__, HEXCONSTE(-4.45015e-308, 0xbc02, 0x8000044dL, 0xb01f4deeL), ZERO_M, FLAG_IGNORE_ZEROSIGN },
};


int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_f_f(fintrz_data, ARRAY_SIZE(fintrz_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

#else

int main(void)
{
	return 77;
}

#endif

```

`tests/y0.c`:

```c
#include "testconfig.h"
#define TEST_FUNC_F_F __MATH_PRECNAME(y0)
#include "testdriver.h"



static test_f_f_data const y0_data[] = {
	{ __LINE__, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_P, 0 },
	{ __LINE__, SNAN_P, QNAN_P, 0 },
	{ __LINE__, SNAN_M, QNAN_P, 0 },
	{ __LINE__, INF_P, ZERO_P, 0 },
	{ __LINE__, INF_M, QNAN_P, 0 },
	{ __LINE__, ZERO_P, INF_M, 0 },
	{ __LINE__, ZERO_M, INF_M, 0 },
	{ __LINE__, SUBNORM_P, ZERO_P, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, ZERO_M, FLAG_SUBNORM },
	{ __LINE__, MIN_P, ZERO_P, 0 },
	{ __LINE__, MIN_M, ZERO_M, 0 },
	{ __LINE__, MAX_P, MAX_P, 0 },
	{ __LINE__, MAX_M, INF_M, INVALID_EXCEPTION|ERRNO_EDOM },

#if 0 /* TODO: could be either inf or nan */
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), INF_M, INVALID_EXCEPTION|ERRNO_EDOM },
#endif
	{ __LINE__, HEXCONSTE(0.125L, 0x3ffc, 0x80000000L, 0x00000000L), HEXCONSTE(-1.38968062514384052915582277745018693L, 0xbfff, 0xb1e10e02L, 0x70563121L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(0.75L, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(-0.137172769385772397522814379396581855L, 0xbffc, 0x8c7704b9L, 0xa791e343L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.0882569642156769579829267660235151628L, 0x3ffb, 0xb4c01137L, 0x9ac6f94fL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.5, 0x3fff, 0xc0000000L, 0x00000000L), HEXCONSTE(0.382448923797758843955068554978089862L, 0x3ffd, 0xc3d05868L, 0x341b3e63L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(0.510375672649745119596606592727157873L, 0x3ffe, 0x82a7fae6L, 0xb46465e1L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(8.0, 0x4002, 0x80000000L, 0x00000000L), HEXCONSTE(0.223521489387566220527323400498620359L, 0x3ffc, 0xe4e2d13bL, 0x7dc16072L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(10.0, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(0.0556711672835993914244598774101900481L, 0x3ffa, 0xe407732dL, 0x02e2c469L), FLAG_INEXACT4 },

	{ __LINE__, HEXCONSTE(2.36072207283297986806e+22, 0x4049, 0x9ff80000L, 0x00000000L), HEXCONSTE(1.818984347516051243459467456433028748678e-12L, 0x3fd7, 0xffffd15dL, 0xc983090bL), FLAG_INEXACT|FLAG_FAIL_ARANYM },

#ifndef TEST_FLOAT
	{ __LINE__, HEXCONSTE(1.46344799023407084313e+253, 0x4347, 0xff800000L, 0x00001000L), HEXCONSTE(1.846591691699331493194965158699937660696e-127L, 0x3e59, 0xffffdb5eL, 0x5de330edL), FLAG_INEXACT|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(8.98846567431157953865e+307, 0x43fe, 0x80000000L, 0x00000000L), HEXCONSTE(8.2687542933709649327986678723012001545638e-155L, 0x3dff, 0x8de88730L, 0x43bf1671L), FLAG_INEXACT|FLAG_FAIL_ARANYM },
#endif

#if defined TEST_LDOUBLE && LDBL_MAX_EXP >= 16384
	{ __LINE__, HEXCONSTE(2.97432873839307941271e+4931, 0x7ffd, 0x80000000L, 0x00000000L), HEXCONSTE(8.0839224448726336195866026476176740513439e-2467L, 0x1ffe, 0xe1ba855bL, 0xa7e7ba4aL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(5.94865747678615882543e+4931, 0x7ffe, 0x80000000L, 0x00000000L), HEXCONSTE(-3.8895531955766020648617743624167352352217e-2467L, 0x9ffd, 0xd937989aL, 0x926f460eL), OVERFLOW_EXCEPTION_OK },
#endif

	{ __LINE__, HEXCONSTE(9.76562500000000000000e-04, 0x3ff5, 0x80000000L, 0x00000000L), HEXCONSTE(-4.4865150767109739412411806297168793661098L, 0xc001, 0x8f918810L, 0xef818d09L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.53674316406250000000e-07, 0x3feb, 0x80000000L, 0x00000000L), HEXCONSTE(-8.8992283012125827603076426611387876938160L, 0xc002, 0x8e633d37L, 0x1587e7dbL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.31322574615478515625e-10, 0x3fe1, 0x80000000L, 0x00000000L), HEXCONSTE(-1.3311940304267782826037118027401817264906e+1L, 0xc002, 0xd4fdb51dL, 0xd22691e1L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.09494701772928237915e-13, 0x3fd7, 0x80000000L, 0x00000000L), HEXCONSTE(-1.7724652307320814696990854700366226762563e+1L, 0xc003, 0x8dcc1682L, 0x474f8b9cL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(8.88178419700125232339e-16, 0x3fcd, 0x80000000L, 0x00000000L), HEXCONSTE(-2.2137364310373846564919987139743760738155e+1L, 0xc003, 0xb1195275L, 0xa58bce46L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(8.67361737988403547206e-19, 0x3fc3, 0x80000000L, 0x00000000L), HEXCONSTE(-2.6550076313426878432849115782108205929120e+1L, 0xc003, 0xd4668e69L, 0x03c810f0L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(8.47032947254300339068e-22, 0x3fb9, 0x80000000L, 0x00000000L), HEXCONSTE(-3.0962788316479910300778244424468159753887e+1L, 0xc003, 0xf7b3ca5cL, 0x6204539aL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(8.27180612553027674871e-25, 0x3faf, 0x80000000L, 0x00000000L), HEXCONSTE(-3.5375500319532942168707373066828113573541e+1L, 0xc004, 0x8d808327L, 0xe0204b22L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(8.07793566946316088742e-28, 0x3fa5, 0x80000000L, 0x00000000L), HEXCONSTE(-3.9788212322585974036636501709188067393195e+1L, 0xc004, 0x9f272121L, 0x8f3e6c77L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(7.88860905221011805412e-31, 0x3f9b, 0x80000000L, 0x00000000L), HEXCONSTE(-4.420092432563900590456563035154802121284e+1L, 0xc004, 0xb0cdbf1bL, 0x3e5c8dccL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(7.70371977754894341222e-34, 0x3f91, 0x80000000L, 0x00000000L), HEXCONSTE(-4.861363632869203777249475899390797503250e+1L, 0xc004, 0xc2745d14L, 0xed7aaf21L), FLAG_INEXACT },
};


int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_f_f(y0_data, ARRAY_SIZE(y0_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

```

`tests/y1.c`:

```c
#include "testconfig.h"
#define TEST_FUNC_F_F __MATH_PRECNAME(y1)
#include "testdriver.h"



static test_f_f_data const y1_data[] = {
	{ __LINE__, QNAN_P, QNAN_P, 0 },
	{ __LINE__, QNAN_M, QNAN_P, 0 },
	{ __LINE__, SNAN_P, QNAN_P, 0 },
	{ __LINE__, SNAN_M, QNAN_P, 0 },
	{ __LINE__, INF_P, ZERO_P, 0 },
	{ __LINE__, INF_M, QNAN_P, 0 },
	{ __LINE__, ZERO_P, INF_M, 0 },
	{ __LINE__, ZERO_M, INF_M, 0 },
	{ __LINE__, SUBNORM_P, ZERO_P, FLAG_SUBNORM },
	{ __LINE__, SUBNORM_M, ZERO_M, FLAG_SUBNORM },
	{ __LINE__, MIN_P, ZERO_P, 0 },
	{ __LINE__, MIN_M, ZERO_M, 0 },
	{ __LINE__, MAX_P, INF_P, 0 },
	{ __LINE__, MAX_M, INF_M, 0 },

	/* y1 is the Bessel function of the second kind of order 1 */
#if 0 /* TODO: could be either inf or nan */
	{ __LINE__, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), INF_M, INVALID_EXCEPTION },
#endif

	{ __LINE__, HEXCONSTE(0.125L, 0x3ffc, 0x80000000L, 0x00000000L), HEXCONSTE(-5.19993611253477499595928744876579921L, 0xc001, 0xa665e06bL, 0x140a1c74L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(0.75L, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(-1.03759455076928541973767132140642198L, 0xbfff, 0x84cfe5f3L, 0x07ec1815L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-0.781212821300288716547150000047964821L, 0xbffe, 0xc7fd903eL, 0xb35ca24fL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(1.5, 0x3fff, 0xc0000000L, 0x00000000L), HEXCONSTE(-0.412308626973911295952829820633445323L, 0xbffd, 0xd31a1dc9L, 0x6c5877f2L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-0.107032431540937546888370772277476637L, 0xbffb, 0xdb33d1c8L, 0xa3323ac6L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(8.0, 0x4002, 0x80000000L, 0x00000000L), HEXCONSTE(-0.158060461731247494255555266187483550L, 0xbffc, 0xa1da9a07L, 0xb499b086L), FLAG_INEXACT4 },
	{ __LINE__, HEXCONSTE(10.0, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(0.249015424206953883923283474663222803L, 0x3ffc, 0xfefde63cL, 0xac79e011L), FLAG_INEXACT4 },

	{ __LINE__, HEXCONSTE(7.32570512175965063567e+29, 0x4062, 0x93f10200L, 0x00000000L), HEXCONSTE(-8.881610148467797208469612080785210013461e-16L, 0xbfcc, 0xfffeb73bL, 0x4b2a6b65L), FLAG_INEXACT|FLAG_FAIL_ARANYM },

#ifndef TEST_FLOAT
	{ __LINE__, HEXCONSTE(3.24260049552016421366e+178, 0x4250, 0x80080000L, 0x08000000L), HEXCONSTE(3.927269966354206207832593635798954916263e-90L, 0x3ed5, 0xffffeb78L, 0x29d45532L), FLAG_INEXACT|FLAG_FAIL_ARANYM },
	{ __LINE__, HEXCONSTE(8.98846567431157953865e+307, 0x43fe, 0x80000000L, 0x00000000L), HEXCONSTE(1.5665258060609012834424478437196679802783e-155L, 0x3dfc, 0xd713e11dL, 0xe5fcbec1L), FLAG_INEXACT|FLAG_FAIL_ARANYM },
#endif

#if defined TEST_LDOUBLE && LDBL_MAX_EXP >= 16384
	{ __LINE__, HEXCONSTE(2.97432873839307941271e+4931, 0x7ffd, 0x80000000L, 0x00000000L), HEXCONSTE(1.2193782500509000574176799046642541129387e-2466L, 0x1fff, 0xaa3e927dL, 0x898c8098L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(5.94865747678615882543e+4931, 0x7ffe, 0x80000000L, 0x00000000L), HEXCONSTE(-9.5859502826270374691362975419147645151233e-2467L, 0x9fff, 0x85d5c0e6L, 0xffc90411L), OVERFLOW_EXCEPTION_OK },
#endif

	{ __LINE__, HEXCONSTE(9.76562500000000000000e-04, 0x3ff5, 0x80000000L, 0x00000000L), HEXCONSTE(-6.5190099301063115047395187618929589514382e+02L, 0xc008, 0xa2f9a9deL, 0x96a576baL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.53674316406250000000e-07, 0x3feb, 0x80000000L, 0x00000000L), HEXCONSTE(-6.6754421443450423911167962313100637952285e+05L, 0xc012, 0xa2f9836eL, 0x52dfed75L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.31322574615478515625e-10, 0x3fe1, 0x80000000L, 0x00000000L), HEXCONSTE(-6.8356527557643159612937462812258975438856e+08L, 0xc01c, 0xa2f9836eL, 0x4e441597L), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(9.09494701772928237915e-13, 0x3fd7, 0x80000000L, 0x00000000L), HEXCONSTE(-6.9997084219026594793707805777425993547887e+11L, 0xc026, 0xa2f9836eL, 0x4e44152aL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(8.88178419700125232339e-16, 0x3fcd, 0x80000000L, 0x00000000L), HEXCONSTE(-7.1677014240283233068755952926181262431559e+14L, 0xc030, 0xa2f9836eL, 0x4e44152aL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(8.67361737988403547206e-19, 0x3fc3, 0x80000000L, 0x00000000L), HEXCONSTE(-7.3397262582050030662406095795388448059822e+17L, 0xc03a, 0xa2f9836eL, 0x4e44152aL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(8.47032947254300339068e-22, 0x3fb9, 0x80000000L, 0x00000000L), HEXCONSTE(-7.5158796884019231398303842094477769620063e+20L, 0xc044, 0xa2f9836eL, 0x4e44152aL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(8.27180612553027674871e-25, 0x3faf, 0x80000000L, 0x00000000L), HEXCONSTE(-7.6962608009235692951863134304745236090943e+23L, 0xc04e, 0xa2f9836eL, 0x4e44152aL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(8.07793566946316088742e-28, 0x3fa5, 0x80000000L, 0x00000000L), HEXCONSTE(-7.8809710601457349582707849528059121757126e+26L, 0xc058, 0xa2f9836eL, 0x4e44152aL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(7.88860905221011805412e-31, 0x3f9b, 0x80000000L, 0x00000000L), HEXCONSTE(-8.0701143655892325972692837916732540679297e+29L, 0xc062, 0xa2f9836eL, 0x4e44152aL), FLAG_INEXACT },
	{ __LINE__, HEXCONSTE(7.70371977754894341222e-34, 0x3f91, 0x80000000L, 0x00000000L), HEXCONSTE(-8.2637971103633741796037466026734121655600e+32L, 0xc06c, 0xa2f9836eL, 0x4e44152aL), FLAG_INEXACT },
};


int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_f_f(y1_data, ARRAY_SIZE(y1_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

```

`tests/yn.c`:

```c
#include "testconfig.h"
#define TEST_FUNC_IF_F __MATH_PRECNAME(yn)
#include "testdriver.h"



static test_if_f_data const yn_data[] = {
	{ __LINE__, 0, QNAN_P, QNAN_P, 0 },
	{ __LINE__, 0, QNAN_M, QNAN_P, 0 },
	{ __LINE__, 0, SNAN_P, QNAN_P, 0 },
	{ __LINE__, 0, SNAN_M, QNAN_P, 0 },
	{ __LINE__, 0, INF_P, ZERO_P, 0 },
	{ __LINE__, 0, INF_M, QNAN_P, 0 },
	{ __LINE__, 0, ZERO_P, INF_M, 0 },
	{ __LINE__, 0, ZERO_M, INF_M, 0 },
	{ __LINE__, 0, SUBNORM_P, ZERO_P, FLAG_SUBNORM },
	{ __LINE__, 0, SUBNORM_M, ZERO_M, FLAG_SUBNORM },
	{ __LINE__, 0, MIN_P, ZERO_P, 0 },
	{ __LINE__, 0, MIN_M, ZERO_M, 0 },
	{ __LINE__, 0, MAX_P, MAX_P, 0 },
	{ __LINE__, 0, MAX_M, INF_M, INVALID_EXCEPTION|ERRNO_EDOM },

	/* yn (0, x) == y0 (x)	*/
#if 0 /* TODO: could be either inf or nan */
	{ __LINE__, 0, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), QNAN_P, INVALID_EXCEPTION|ERRNO_EDOM },
#endif

	{ __LINE__, 0, HEXCONSTE(0.125L, 0x3ffc, 0x80000000L, 0x00000000L), HEXCONSTE(-1.38968062514384052915582277745018693L, 0xbfff, 0xb1e10e02L, 0x70563121L), FLAG_INEXACT },
	{ __LINE__, 0, HEXCONSTE(0.75L, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(-0.137172769385772397522814379396581855L, 0xbffc, 0x8c7704b9L, 0xa791e343L), FLAG_INEXACT },
	{ __LINE__, 0, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(0.0882569642156769579829267660235151628L, 0x3ffb, 0xb4c01137L, 0x9ac6f94fL), FLAG_INEXACT },
	{ __LINE__, 0, HEXCONSTE(1.5, 0x3fff, 0xc0000000L, 0x00000000L), HEXCONSTE(0.382448923797758843955068554978089862L, 0x3ffd, 0xc3d05868L, 0x341b3e63L), FLAG_INEXACT },
	{ __LINE__, 0, HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(0.510375672649745119596606592727157873L, 0x3ffe, 0x82a7fae6L, 0xb46465e1L), FLAG_INEXACT },
	{ __LINE__, 0, HEXCONSTE(8.0, 0x4002, 0x80000000L, 0x00000000L), HEXCONSTE(0.223521489387566220527323400498620359L, 0x3ffc, 0xe4e2d13bL, 0x7dc16072L), FLAG_INEXACT4 },
	{ __LINE__, 0, HEXCONSTE(10.0, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(0.0556711672835993914244598774101900481L, 0x3ffa, 0xe407732dL, 0x02e2c469L), FLAG_INEXACT4 },

	/* yn (1, x) == y1 (x)	*/
#if 0 /* TODO: could be either inf or nan */
	{ __LINE__, 1, HEXCONSTE(-1.0, 0xbfff, 0x80000000L, 0x00000000L), INF_M, INVALID_EXCEPTION|ERRNO_EDOM },
#endif
	{ __LINE__, 1, ZERO_P, INF_M, 0 },
	{ __LINE__, 1, INF_P, ZERO_P, 0 },
	{ __LINE__, 1, INF_M, QNAN_P, 0 },
	{ __LINE__, 1, QNAN_P, QNAN_P, 0 },

	{ __LINE__, 1, HEXCONSTE(0.125L, 0x3ffc, 0x80000000L, 0x00000000L), HEXCONSTE(-5.19993611253477499595928744876579921L, 0xc001, 0xa665e06bL, 0x140a1c74L), FLAG_INEXACT },
	{ __LINE__, 1, HEXCONSTE(0.75L, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(-1.03759455076928541973767132140642198L, 0xbfff, 0x84cfe5f3L, 0x07ec1815L), FLAG_INEXACT },
	{ __LINE__, 1, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-0.781212821300288716547150000047964821L, 0xbffe, 0xc7fd903eL, 0xb35ca24fL), FLAG_INEXACT },
	{ __LINE__, 1, HEXCONSTE(1.5, 0x3fff, 0xc0000000L, 0x00000000L), HEXCONSTE(-0.412308626973911295952829820633445323L, 0xbffd, 0xd31a1dc9L, 0x6c5877f2L), FLAG_INEXACT },
	{ __LINE__, 1, HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-0.107032431540937546888370772277476637L, 0xbffb, 0xdb33d1c8L, 0xa3323ac6L), FLAG_INEXACT },
	{ __LINE__, 1, HEXCONSTE(8.0, 0x4002, 0x80000000L, 0x00000000L), HEXCONSTE(-0.158060461731247494255555266187483550L, 0xbffc, 0xa1da9a07L, 0xb499b086L), FLAG_INEXACT4 },
	{ __LINE__, 1, HEXCONSTE(10.0, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(0.249015424206953883923283474663222803L, 0x3ffc, 0xfefde63cL, 0xac79e011L), FLAG_INEXACT4 },

	/* yn (3, x)  */
	{ __LINE__, 3, INF_P, ZERO_P, 0 },
	{ __LINE__, 3, QNAN_P, QNAN_P, 0 },

	{ __LINE__, 3, HEXCONSTE(0.125L, 0x3ffc, 0x80000000L, 0x00000000L), HEXCONSTE(-2612.69757350066712600220955744091741L, 0xc00a, 0xa34b2942L, 0xd4bebea1L), FLAG_INEXACT },
	{ __LINE__, 3, HEXCONSTE(0.75L, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(-12.9877176234475433186319774484809207L, 0xc002, 0xcfcdb0feL, 0xa63d9bf9L), FLAG_INEXACT },
	{ __LINE__, 3, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-5.82151760596472884776175706442981440L, 0xc001, 0xba49df4aL, 0x569d7d9aL), FLAG_INEXACT },
	{ __LINE__, 3, HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-1.12778377684042778608158395773179238L, 0xbfff, 0x905b3803L, 0x3e97898eL), FLAG_INEXACT },
	{ __LINE__, 3, HEXCONSTE(10.0, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(-0.251362657183837329779204747654240998L, 0xbffd, 0x80b29b30L, 0x149a70e4L), FLAG_INEXACT3 },

	/* yn (10, x)  */
	{ __LINE__, 10, INF_P, ZERO_P, 0 },
	{ __LINE__, 10, QNAN_P, QNAN_P, 0 },

	{ __LINE__, 10, HEXCONSTE(0.125L, 0x3ffc, 0x80000000L, 0x00000000L), HEXCONSTE(-127057845771019398.252538486899753195L, 0xc037, 0xe1b33801L, 0x8dd24320L), FLAG_INEXACT },
	{ __LINE__, 10, HEXCONSTE(0.75L, 0x3ffe, 0xc0000000L, 0x00000000L), HEXCONSTE(-2133501638.90573424452445412893839236L, 0xc01d, 0xfe554d8dL, 0xcfbc661eL), FLAG_INEXACT },
	{ __LINE__, 10, HEXCONSTE(1.0, 0x3fff, 0x80000000L, 0x00000000L), HEXCONSTE(-121618014.278689189288130426667971145L, 0xc019, 0xe7f7cbc8L, 0xeb059738L), FLAG_INEXACT },
	{ __LINE__, 10, HEXCONSTE(2.0, 0x4000, 0x80000000L, 0x00000000L), HEXCONSTE(-129184.542208039282635913145923304214L, 0xc00f, 0xfc504567L, 0x12b22c71L), FLAG_INEXACT },
	{ __LINE__, 10, HEXCONSTE(10.0, 0x4002, 0xa0000000L, 0x00000000L), HEXCONSTE(-0.359814152183402722051986577343560609L, 0xbffd, 0xb8398f80L, 0x88076e0aL), FLAG_INEXACT3 },

	/* Check whether yn returns correct value for LDBL_MIN, DBL_MIN,
	   and FLT_MIN.  See Bug 14173.  */
#ifdef TEST_LDOUBLE
	{ __LINE__, 10, MIN_P, INF_M, UNDERFLOW_EXCEPTION /* |ERRNO_ERANGE */ },
#else
	{ __LINE__, 10, MIN_P, INF_M, OVERFLOW_EXCEPTION /* |ERRNO_ERANGE */ },
#endif
};


int main(int argc, char **argv)
{
	int status;
	
	status = 0;
	
	test_init(argc, argv);
	
	status |= test_table_if_f(yn_data, ARRAY_SIZE(yn_data), __FILE__);
	
	return status ? EXIT_FAILURE : EXIT_SUCCESS;
}

```

`truncxfdf2.c`:

```c
#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

/*
 * we cannot replace that single function, because it is
 * not compiled separately in libgcc.a and leads
 * to duplicate definition errors :(
 */
#if 0

#ifndef __NO_LONG_DOUBLE_MATH

#define EXPDBITS	11
#define MANTXMASK IC(0x7fffffff)

double __truncxfdf2(long double ld);

/* convert long double to double */
double __truncxfdf2(long double ld)
{
	int32_t exp;
	ieee_double_shape_type dl;
	ieee_long_double_shape_type ldl;

	ldl.value = ld;

	exp = ldl.parts.sign_exponent & IEEE854_LONG_DOUBLE_MAXEXP;
	dl.parts.msw = (int32_t)(ldl.parts.sign_exponent & 0x8000) << 16;
	if (exp == 0 &&
		(ldl.parts.msw & MANTXMASK) == 0 &&
		ldl.parts.lsw == 0)
	{
		dl.parts.lsw = 0;
	} else
	{
		if (exp == IEEE854_LONG_DOUBLE_MAXEXP)
		{
			exp = IEEE754_DOUBLE_MAXEXP;
		} else
		{
			exp = exp - IEEE854_LONG_DOUBLE_BIAS + IEEE754_DOUBLE_BIAS;
			/* ??? quick and dirty: keep `exp' sane */
			if (exp >= IEEE754_DOUBLE_MAXEXP)
				exp = IEEE754_DOUBLE_MAXEXP - 1;
		}
		dl.parts.msw |= exp << (32 - (EXPDBITS + 1));
		/* +1-1: add one for sign bit, but take one off for explicit-integer-bit */
		dl.parts.msw |= (ldl.parts.msw & MANTXMASK) >> (EXPDBITS + 1 - 1);
		dl.parts.lsw = (ldl.parts.msw & MANTXMASK) << (32 - (EXPDBITS + 1 - 1));
		dl.parts.lsw |= ldl.parts.lsw >> (EXPDBITS + 1 - 1);
	}
		
	return dl.value;
}

#endif

#endif

```

`w_gamma.c`:

```c
/* @(#)w_gamma.c 1.3 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 *
 */

/* double gamma(double x)
 * Return the logarithm of the Gamma function of x.
 *
 * Method: call gamma_r
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

double __gamma(double x)
{
	return gamma_r(x, &signgam);
}

__typeof(__gamma) gamma __attribute__((weak, alias("__gamma")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(__gammal) __gammal __attribute__((alias("__gamma")));
__typeof(__gammal) gammal __attribute__((weak, alias("__gamma")));
#endif

```

`w_gamma_r.c`:

```c
/* @(#)w_gamma_r.c 1.3 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice 
 * is preserved.
 * ====================================================
 */

/* 
 * wrapper double gamma_r(double x, int *signgamp)
 */

#include "fdlibm.h"


double __gamma_r(double x, int *signgamp) /* wrapper lgamma_r */
{
	double y = __ieee754_lgamma_r(x, signgamp);

	if (_LIB_VERSION != _IEEE_ && !isfinite(y) && isfinite(x))
		return __kernel_standard(x, x, y, __ieee754_floor(x) == x && x <= 0.0 ? KMATHERR_LGAMMA_MINUS	/* lgamma pole */
								 : KMATHERR_LGAMMA_OVERFLOW);	/* lgamma overflow */

	return y;
}             

__typeof(__gamma_r) gamma_r __attribute__((weak, alias("__gamma_r")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(__gammal_r) __gammal_r __attribute__((alias("__gamma_r")));
__typeof(__gammal_r) gammal_r __attribute__((weak, alias("__gamma_r")));
#endif

```

`w_gammaf.c`:

```c
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice 
 * is preserved.
 * ====================================================
 *
 */

/* float gammaf(double x)
 * Return the logarithm of the Gamma function of x.
 *
 * Method: call gammaf_r
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

float __gammaf(float x)
{
	return gammaf_r(x, &signgam);
}

__typeof(__gammaf) gammaf __attribute__((weak, alias("__gammaf")));

```

`w_gammaf_r.c`:

```c
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice 
 * is preserved.
 * ====================================================
 *
 */

/* float gammaf_r(float x, int *signgamp)
 * Return the logarithm of the Gamma function of x.
 *
 * Method: call __ieee754_gammaf_r
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

float __gammaf_r(float x, int *signgamp)
{
	float y = __ieee754_lgammaf_r(x, signgamp);

	if (!isfinite(y) && isfinite(x) && _LIB_VERSION != _IEEE_)
		return __kernel_standard_f(x, x, y, __ieee754_floorf(x) == x && x <= 0.0F ? KMATHERRF_LGAMMA_MINUS	/* lgamma pole */
								 : KMATHERRF_LGAMMA_OVERFLOW);	/* lgamma overflow */

	return y;
}

__typeof(__gammaf_r) gammaf_r __attribute__((weak, alias("__gammaf_r")));

```

`w_gammal.c`:

```c
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice 
 * is preserved.
 * ====================================================
 *
 */

/* long double gammal(long double x)
 * Return the logarithm of the Gamma function of x.
 *
 * Method: call gammal_r
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

long double __gammal(long double x)
{
	return gammal_r(x, &signgam);
}

__typeof(__gammal) gammal __attribute__((weak, alias("__gammal")));

#endif

```

`w_gammal_r.c`:

```c
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice 
 * is preserved.
 * ====================================================
 *
 */

/* double gamma(double x)
 * Return the logarithm of the Gamma function of x.
 *
 * Method: call __ieee754_gammal_r
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

long double __gammal_r(long double x, int *signgamp)
{
	long double y = __ieee754_lgammal_r(x, signgamp);

	if (!isfinite(y) && isfinite(x) && _LIB_VERSION != _IEEE_)
		return __kernel_standard_l(x, x, y, __ieee754_floorl(x) == x && x <= 0.0 ? KMATHERRL_LGAMMA_MINUS	/* lgamma pole */
								 : KMATHERRL_LGAMMA_OVERFLOW);	/* lgamma overflow */

	return y;
}

__typeof(__gammal_r) gammal_r __attribute__((weak, alias("__gammal_r")));

#endif

```

`w_lgamma.c`:

```c
/* @(#)w_lgamma.c 1.3 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 *
 */

/* double lgamma(double x)
 * Return the logarithm of the Gamma function of x.
 *
 * Method: call lgamma_r
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

double __lgamma(double x)
{
	return lgamma_r(x, &signgam);
}             

__typeof(__lgamma) lgamma __attribute__((weak, alias("__lgamma")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(__lgammal) __lgammal __attribute__((alias("__lgamma")));
__typeof(__lgammal) lgammal __attribute__((weak, alias("__lgamma")));
#endif

```

`w_lgamma_r.c`:

```c
/* @(#)w_lgamma_r.c 1.3 95/01/18 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/* 
 * wrapper double lgamma_r(double x, int *signgamp)
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

double __lgamma_r(double x, int *signgamp)
{
	double y = __ieee754_lgamma_r(x, signgamp);

	if (_LIB_VERSION != _IEEE_ && !isfinite(y) && isfinite(x))
		return __kernel_standard(x, x, y, __ieee754_floor(x) == x && x <= 0.0 ? KMATHERR_LGAMMA_MINUS	/* lgamma pole */
								 : KMATHERR_LGAMMA_OVERFLOW);	/* lgamma overflow */

	return y;
}

__typeof(__lgamma_r) lgamma_r __attribute__((weak, alias("__lgamma_r")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(__lgammal_r) __lgammal_r __attribute__((alias("__lgamma_r")));
__typeof(__lgammal_r) lgammal_r __attribute__((weak, alias("__lgamma_r")));
#endif

```

`w_lgammaf.c`:

```c
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice 
 * is preserved.
 * ====================================================
 *
 */

/* float lgammaf(double x)
 * Return the logarithm of the Gamma function of x.
 *
 * Method: call lgammaf_r
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

float __lgammaf(float x)
{
	return lgammaf_r(x, &signgam);
}

__typeof(__lgammaf) lgammaf __attribute__((weak, alias("__lgammaf")));

```

`w_lgammaf_r.c`:

```c
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice 
 * is preserved.
 * ====================================================
 *
 */

/* float lgammaf_r(float x, int *signgamp)
 * Return the logarithm of the Gamma function of x.
 *
 * Method: call __ieee754_lgammaf_r
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

float __lgammaf_r(float x, int *signgamp)
{
	float y = __ieee754_lgammaf_r(x, signgamp);

	if (!isfinite(y) && isfinite(x) && _LIB_VERSION != _IEEE_)
		return __kernel_standard_f(x, x, y, __ieee754_floorf(x) == x && x <= 0.0F ? KMATHERRF_LGAMMA_MINUS	/* lgamma pole */
								 : KMATHERRF_LGAMMA_OVERFLOW);	/* lgamma overflow */

	return y;
}

__typeof(__lgammaf_r) lgammaf_r __attribute__((weak, alias("__lgammaf_r")));

```

`w_lgammal.c`:

```c
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice 
 * is preserved.
 * ====================================================
 *
 */

/* long double lgammal(long double x)
 * Return the logarithm of the Gamma function of x.
 *
 * Method: call lgammal_r
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

long double __lgammal(long double x)
{
	return lgammal_r(x, &signgam);
}

__typeof(__lgammal) lgammal __attribute__((weak, alias("__lgammal")));

#endif

```

`w_lgammal_r.c`:

```c
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice 
 * is preserved.
 * ====================================================
 *
 */

/* double lgamma(double x)
 * Return the logarithm of the Gamma function of x.
 *
 * Method: call __ieee754_lgammal_r
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

long double __lgammal_r(long double x, int *signgamp)
{
	long double y = __ieee754_lgammal_r(x, signgamp);

	if (!isfinite(y) && isfinite(x) && _LIB_VERSION != _IEEE_)
		return __kernel_standard_l(x, x, y, __ieee754_floorl(x) == x && x <= 0.0 ? KMATHERRL_LGAMMA_MINUS	/* lgamma pole */
								 : KMATHERRL_LGAMMA_OVERFLOW);	/* lgamma overflow */

	return y;
}

__typeof(__lgammal_r) lgammal_r __attribute__((weak, alias("__lgammal_r")));

#endif

```

`w_tgamma.c`:

```c
/* @(#)w_gamma.c 5.1 93/09/24 */
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/* double gamma(double x)
 * Return  the logarithm of the Gamma function of x or the Gamma function of x,
 * depending on the library mode.
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

double __tgamma(double x)
{
	int local_signgam;
	double y = __ieee754_tgamma_r(x, &local_signgam);

	if (!isfinite(y) && (isfinite(x) || isinf(x) < 0) && _LIB_VERSION != _IEEE_)
	{
		if (x == 0.0)
			return __kernel_standard(x, x, y, KMATHERR_TGAMMA_ZERO);	/* tgamma pole */
		else if (__ieee754_floor(x) == x && x < 0.0)
			return __kernel_standard(x, x, y, KMATHERR_TGAMMA_MINUS);	/* tgamma domain */
		else if (y == 0)
			return __kernel_standard(x, x, y, KMATHERR_TGAMMA_UNDERFLOW);	/* tgamma underflow */
		else
			return __kernel_standard(x, x, y, KMATHERR_TGAMMA_OVERFLOW);	/* tgamma overflow */
	}
	return local_signgam < 0 ? -y : y;
}

__typeof(__tgamma) tgamma __attribute__((weak, alias("__tgamma")));
#ifdef __NO_LONG_DOUBLE_MATH
__typeof(__tgammal) __tgammal __attribute__((alias("__tgamma")));
__typeof(__tgammal) tgammal __attribute__((weak, alias("__tgamma")));
#endif

```

`w_tgammaf.c`:

```c
/* w_gammaf.c -- float version of w_gamma.c.
 * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

float __tgammaf(float x)
{
	int local_signgam;
	float y = __ieee754_tgammaf_r(x, &local_signgam);

	if (!isfinite(y) && (isfinite(x) || isinf(x) < 0) && _LIB_VERSION != _IEEE_)
	{
		if (x == 0.0F)
			return __kernel_standard_f(x, x, y, KMATHERRF_TGAMMA_ZERO);	/* tgammaf pole */
		else if (__ieee754_floorf(x) == x && x < 0.0f)
			return __kernel_standard_f(x, x, y, KMATHERRF_TGAMMA_MINUS);	/* tgammaf domain */
		else if (y == 0)
			return __kernel_standard_f(x, x, y, KMATHERRF_TGAMMA_UNDERFLOW);	/* tgamma underflow */
		else
			return __kernel_standard_f(x, x, y, KMATHERRF_TGAMMA_OVERFLOW);	/* tgammaf overflow */
	}
	return local_signgam < 0 ? -y : y;
}

__typeof(__tgammaf) tgammaf __attribute__((weak, alias("__tgammaf")));

```

`w_tgammal.c`:

```c
/* w_gammal.c -- long double version of w_gamma.c.
 * Conversion to long double by Ulrich Drepper,
 * Cygnus Support, drepper@cygnus.com.
 */

/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunPro, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */

/* long double gammal(double x)
 * Return the Gamma function of x.
 */

#ifndef __FDLIBM_H__
#include "fdlibm.h"
#endif

#ifndef __NO_LONG_DOUBLE_MATH

long double __tgammal(long double x)
{
	int local_signgam;
	long double y = __ieee754_tgammal_r(x, &local_signgam);

	if (!isfinite(y) && (isfinite(x) || isinf(x) < 0) && _LIB_VERSION != _IEEE_)
	{
		if (x == 0.0)
			return __kernel_standard_l(x, x, y, KMATHERRL_TGAMMA_ZERO);	/* tgamma pole */
		else if (__ieee754_floorl(x) == x && x < 0.0L)
			return __kernel_standard_l(x, x, y, KMATHERRL_TGAMMA_MINUS);	/* tgamma domain */
		else if (y == 0)
			return __kernel_standard_l(x, x, y, KMATHERRL_TGAMMA_UNDERFLOW);	/* tgamma underflow */
		else
			return __kernel_standard_l(x, x, y, KMATHERRL_TGAMMA_OVERFLOW);	/* tgamma overflow */
	}
	return local_signgam < 0 ? -y : y;
}

__typeof(__tgammal) tgammal __attribute__((weak, alias("__tgammal")));

#endif

```