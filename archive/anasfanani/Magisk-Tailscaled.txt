Project Path: arc_anasfanani_Magisk-Tailscaled_s99ouqo1

Source Tree:

```txt
arc_anasfanani_Magisk-Tailscaled_s99ouqo1
├── CHANGELOG.md
├── LICENSE
├── META-INF
│   └── com
│       └── google
│           └── android
│               ├── update-binary
│               └── updater-script
├── README.md
├── customize.sh
├── module.prop
├── service.sh
├── tailscale
│   ├── scripts
│   │   ├── start.sh
│   │   ├── tailscaled.inotify
│   │   └── tailscaled.service
│   └── settings.sh
├── uninstall.sh
├── update-arm.json
├── update-arm64.json
└── update.json

```

`CHANGELOG.md`:

```md
## v2.0.0.1

- 429e1b0 build: fix version bump and add pre-release for build version
- 75834b4 fix: path order

## v2.0.0.0

### ⚠️ Important Notice
This build may be unstable. Please test thoroughly and report any issues you encounter.

**Exit Node Warning**: Using exit nodes may cause battery drain. Not recommended for 24/7 use.

**Testing Your Connection**:
- Check IP: https://browserleaks.com/ip
- Check DNS leaks: https://browserleaks.com/dns

### Major Rewrite
This is a complete rewrite of the module with significant improvements.

### What's New
- **Better DNS handling** - Improved DNS configuration and compatibility
- **SSH support** - Enhanced SSH functionality
- **Exit node support** - Better exit node handling
- **Hotspot client support** - Works with Android hotspot clients
- **VPN compatibility** - Can now run alongside other VPN apps
- **Root & Non-root mode** - Works in both root and non-root environments

### Technical Changes
- Removed all wrapper scripts for better performance
- Now uses tailscaled binaries from [tailscale-android-cli](https://github.com/anasfanani/tailscale-android-cli)
- Simplified module structure
- Improved stability and reliability

### Breaking Changes
This is a major version update. Please backup your configuration before upgrading.

```

`LICENSE`:

```
BSD 3-Clause License

Copyright (c) 2023 ANASFANANI & AUTHORS.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its
   contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

Copyright (c) 2022 hev for hev-socks5-tunnel

https://github.com/heiher/hev-socks5-tunnel/releases/tag/2.6.8

BSD 3-Clause License

Copyright (c) 2020 Tailscale Inc & AUTHORS.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its
   contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
```

`META-INF/com/google/android/update-binary`:

```
#!/sbin/sh

#################
# Initialization
#################

umask 022

# echo before loading util_functions
ui_print() { echo "$1"; }

require_new_magisk() {
  ui_print "*******************************"
  ui_print " Please install Magisk v20.4+! "
  ui_print "*******************************"
  exit 1
}

#########################
# Load util_functions.sh
#########################

OUTFD=$2
ZIPFILE=$3

mount /data 2>/dev/null

[ -f /data/adb/magisk/util_functions.sh ] || require_new_magisk
. /data/adb/magisk/util_functions.sh
[ $MAGISK_VER_CODE -lt 20400 ] && require_new_magisk

install_module
exit 0
```

`META-INF/com/google/android/updater-script`:

```
#MAGISK
```

`README.md`:

```md
[![anasfanani - Magisk-Tailscaled](https://img.shields.io/static/v1?label=anasfanani&message=Magisk-Tailscaled&color=blue&logo=github)](https://github.com/anasfanani/Magisk-Tailscaled "Go to GitHub repo")
[![Check and Update Tailscale Binary](https://github.com/anasfanani/Magisk-Tailscaled/actions/workflows/update.yml/badge.svg)](https://github.com/anasfanani/Magisk-Tailscaled/actions/workflows/update.yml)
[![Github All Releases](https://img.shields.io/github/downloads/anasfanani/Magisk-Tailscaled/total.svg)]()
[![GitHub release](https://img.shields.io/github/release/anasfanani/Magisk-Tailscaled?include_prereleases=&sort=semver&color=blue)](https://github.com/anasfanani/Magisk-Tailscaled/releases/)
[![issues - Magisk-Tailscaled](https://img.shields.io/github/issues/anasfanani/Magisk-Tailscaled)](https://github.com/anasfanani/Magisk-Tailscaled/issues)
[![Static Badge](https://img.shields.io/badge/Discussion-Telegram-blue?style=flat&logo=telegram&link=t.me%2Fsystembinsh%2F158)](https://t.me/systembinsh/158)

# Magisk Tailscaled

This repository contains a Magisk module for running Tailscale on rooted Android devices.

## What is Tailscale?

Tailscale is a networking tool that allows you to connect each of your devices as if they were on the same VPN. For example, an Android phone connected to the Tailscale network can communicate with any other device connected to Tailscale. You can install it on your PC and Android device and then connect them using the Tailscale IP. For more information, check out [How Tailscale Works](https://tailscale.com/blog/how-tailscale-works).

## Difference between this Magisk module and the Tailscale app on Play Store

The [Tailscale app](https://play.google.com/store/apps/details?id=com.tailscale.ipn) on the Play Store runs with Android's VPN, which means you can't use Tailscale while another VPN is active. This Magisk module, on the other hand, allows you to use both an Android VPN and Tailscale at the same time.

## Requirements

- A basic networking knowledge.
- An Android device with Magisk root installed.

## Quick Start & Installation

1. Download the latest zip file from the [Releases](https://github.com/anasfanani/Magisk-Tailscaled/releases/latest) page.
2. Install the downloaded zip file using Magisk & reboot your phone.
3. Open the Terminal.
4. Login with `su -c tailscale login`
5. Disable accept-dns `su -c tailscale set --accept-dns=false`
6. Run 'tailscale login' to login to your Tailscale account.
7. Open the URL in a browser to authorize your device.
8. Run 'tailscale ip' to retrieve your Tailscale IP.
9. Alternatively, you can open the [Tailscale Admin Dashboard](https://login.tailscale.com/admin/machines) to manage your devices.

After installation, the Tailscale daemon (`tailscaled`) will run automatically on boot.

## Limitation

- This module only support for `arm` or `arm64` architecture, you can download manually for other architecture.
- Tailscale binary is designed to run in Linux environment, Some feature might not works properly.
- MagicDNS currently not working.
- Runs in userspace mode, read more at [https://tailscale.com/kb/1112/userspace-networking](https://tailscale.com/kb/1112/userspace-networking) 
- Subnet routes is manually routed with socks5-tun, you must define your own ip routes to `tailscaled.tun.up` and `tailscaled.tun.down`

## Usage of this module

This module runs `tailscaled` with the following command:

```bash
tailscaled -tun=userspace-networking -statedir=/data/adb/tailscale/tmp/ -state=/data/adb/tailscale/tmp/tailscaled.state -socket=/data/adb/tailscale/tmp/tailscaled.sock -port=41641
```
The state file for tailscaled is stored at `/data/adb/tailscale/tmp/tailscaled.state`, and the log output is written to `/data/adb/tailscale/run/tailscaled.log`.

## Available command

- `tailscale`: This command is execute tailscale operation.
- `tailscaled`: This command is execute tailscaled daemon operation.
- `tailscaled.service`: This command for manage tailscaled service, you can start,stop,restart daemon and view live logs the tailscaled operation.
- `tailscaled.tun`: This command is for manage hev-socks5-tunnel.
  
## Example of Using Tailscale

### SSH to Termux

You can use Tailscale to connect SSH from Termux on Android to a Windows PC. Here's how:

#### On your Android device:

1. Set up SSHD:

```bash
apt update && apt upgrade
apt install openssh
passwd
```

Enter your password when prompted, for example, `123`.

2. Run ssh daemon with command `sshd`
3. Get your IP with the command `tailscale ip` or check your IP in the [Tailscale Admin Dashboard](https://login.tailscale.com/admin/machines).

#### On your Windows PC:

1. Download & install [Tailscale for Windows](https://tailscale.com/download/windows)
1. Open app & login to the Tailscale.
3. Open the terminal & SSH to your Android IP:

```bash
ssh <root>@<tailscale_ip> -p 8022
```

For example:

```bash
ssh root@100.95.95.95 -p 8022
```

### SSH access to your Android device

You can also enable SSH access to your Android device using [Tailscale SSH](https://tailscale.com/kb/1193/tailscale-ssh?slug=kb&slug=1193&slug=tailscale-ssh). To do this, advertise SSH on the host with the command `tailscale up --ssh`.

By default, Tailscale's SSH feature may not work on Android because it requires `getent`, which is part of GNU libc, and relies on glibc-specific features like nsswitch.conf.

To overcome this, I've created a mock `getent` and placed it in `tailscale/bin/`. This mock `getent` is used by Tailscale's [userLookupGetent](https://github.com/tailscale/tailscale/blob/5812093d31c8a7f9c5e3a455f0fd20dcc011d8cd/util/osuser/user.go#L121C19-L121C33) function.

After advertising SSH on the host, you can SSH into your Android device using `ssh root@<tailscale_ip>`.

### ADB over Tailscale

You can run ADB over Tailscale. First, you need to enable ADB over TCP/IP. You can do this with the following commands:

```bash
setprop service.adb.tcp.port 5555
stop adbd
start adbd
```

These commands set the ADB daemon to listen on TCP port 5555 and then restart the ADB daemon to apply the change.

After enabling ADB over TCP/IP, you can connect to your Android device from your Windows machine using the `adb connect` command followed by your Tailscale IP and the port number:

```bash
adb connect <tailscale_ip>:5555
```

## Avalilable command

```
USAGE
  tailscale [flags] <subcommand> [command flags]

For help on subcommands, add --help after: "tailscale status --help".

This CLI is still under active development. Commands and flags will
change in the future.

SUBCOMMANDS
  up         Connect to Tailscale, logging in if needed
  down       Disconnect from Tailscale
  set        Change specified preferences
  login      Log in to a Tailscale account
  logout     Disconnect from Tailscale and expire current node key
  switch     Switches to a different Tailscale account
  configure  [ALPHA] Configure the host to enable more Tailscale features
  netcheck   Print an analysis of local network conditions
  ip         Show Tailscale IP addresses
  status     Show state of tailscaled and its connections
  ping       Ping a host at the Tailscale layer, see how it routed
  nc         Connect to a port on a host, connected to stdin/stdout
  ssh        SSH to a Tailscale machine
  funnel     Turn on/off Funnel service
  serve      Serve content and local servers
  version    Print Tailscale version
  web        Run a web server for controlling Tailscale
  file       Send or receive files
  bugreport  Print a shareable identifier to help diagnose issues
  cert       Get TLS certs
  lock       Manage tailnet lock
  licenses   Get open source license information
  exit-node

FLAGS
  --socket string
        path to tailscaled socket (default /var/run/tailscale/tailscaled.sock)
```

For more details about CLI commands, check out the [Tailscale CLI documentation](https://tailscale.com/kb/1080/cli#using-the-cli).

## FAQ & Troubleshooting

Tailscale has manny issues. You can check them out [here](https://github.com/tailscale/tailscale/issues).

### Cannot access other tailnet devices

This module runs the `tailscaled` binary in userspace-networking mode. To access other devices in the tailnet, you must use a local proxy on port 1099. I've implemented a workaround using `hev-socks5-tunnel` to tunnel local socks5 on port 1099 and bind it to the interface named `tailscale0`. 

Please note, this `tailscale0` interface is different from the original `tailscale0` interface on Linux. In Linux, `tailscale0` is managed by the `tailscaled` daemon, whereas in this module, `tailscale0` is managed by `hev-socks5-tunnel`. The default gateway is `100.100.100.100`, as defined in the `tailscaled.tun.config.yaml` file.

This solution should work on most common devices. However, if you encounter problems accessing other tailnet devices, follow these troubleshooting steps:

1. Verify that `tailscaled.service` is running. If not, restart it with `tailscaled.service restart`.
2. Verify that `tailscaled.tun` is running. If not, restart it with `tailscaled.tun restart`.
3. Check if your device is connected to tailscaled and try a ping connection with `tailscale ping <your_tailnet_ip>`.
4. Verify the port you want to access is accessible. You can do this by accessing it with another tailscale device or using the Tailscale Android App.
5. Check if the local socks5 server is working with curl. Execute the following command:
    ```
    curl 1.1.1.1 -vI -x localhost:1099
    ```
    If it connects, then the local socks5 server is running and working.

6. Check if the local socks5 server can connect to the tailnet network.
    ```
    curl <your_tailnet_ip>:<port> -vI -x localhost:1099
    ```
    If it connects, then the local socks5 server is functioning correctly.

7. Finally, check the connection directly with `curl <your_tailnet_ip>:<port> -vI`.

If the last step fails, the problem likely lies with `socks5-tun`. Verify there is an interface named `tailscale0`. If it exists, the problem may be with the iptables route, either due to a conflict with another rule or some other issue. Feel free to explore your own solutions. If you're unable to resolve the issue, contact me on Telegram and I'll see if I can assist you.

### My subnet-routes is'nt working

Yes because we need define the routes with `iptables` in file `tailscaled.tun.up` and `tailscaled.tun.down`, you can check this [issue reference](https://github.com/anasfanani/Magisk-Tailscaled/issues/17).
I suppose you're already know the iptables works, if dont, there are chatAI to ask.
You can copy whole `tailscaled.tun.up` script to chatAI and send instruction with please add 192.168.1.1/24 to this route, also dont forget `tailscaled.tun.down` 

If you still can't do it by yourself, I'm verry welcome to people who needs help.

### Exit nodes

You can check this [issue reference](https://github.com/anasfanani/Magisk-Tailscaled/issues/17).

### ipv6

Unfortunately, I'm verry lazy to learn ipv6.

### Headscale 

Check [this](https://github.com/anasfanani/Magisk-Tailscaled/issues/19#issuecomment-2091579177).
Also explore on the issue first, then you can ask trough telegram.


### Other Error & Bugs

You can explore to the issue tab, if there not exists, you can open issue, for help me resolve the problem, you can include fresh log.

1. Restart tailscaled with `tailscaled.service restart`
2. Reproduce what are you doing which has problem.
3. Get log at `/data/adb/tailscale/run/tailscaled.log`

## Notes

This module is confirmed to be supported for KernelSU, as [confirmed by the author of KernelSU](https://github.com/anasfanani/Magisk-Tailscaled/issues/2#issue-2055047162). If you encounter any problems, please let me know.

For more information, check out the links below:

## Links

- [Tailscale Userspace Networking](https://tailscale.com/kb/1112/userspace-networking/)
- [Termux Issue #10166](https://github.com/termux/termux-packages/issues/10166)
- [Tailscale Static Packages](https://pkgs.tailscale.com/stable/#static)
- [Tailscale Knowledge Base](https://tailscale.com/kb)

## Credits

- [Tailscale Inc & AUTHORS](https://github.com/tailscale/tailscale). for the static binaries of tailscale & tailscaled
- [John Wu & Authors](https://github.com/topjohnwu/Magisk). for The Magic Mask for Android
- [heiher & Authors](https://github.com/heiher/hev-socks5-tunnel). for the hev-socks5-tunnel

## Disclaimer

This module is provided as-is, I'm not employee at official tailscale, not a verry genius people which can resolve all your problem.
This module is not affiliated with the official Tailscale. It is a third-party implementation and the author is not responsible for any damage to your device that may occur from its use. Use at your own risk.
Any improvements is required, any PR is verry required, not just welcome.

## License

Released under [BSD 3-Clause License](/LICENSE).
```

`customize.sh`:

```sh
#!/system/bin/sh

# DEBUG=1
[ -n "${DEBUG:-}" ] && {
	PS4="+ \${0##*/}:\${LINENO}: "
	set -e
	set -u
	set -x
	set
} || true

# Github download helper
gh_download() {
	REPO=$1
	MATCH=$2
	DOWNLOAD_URL=$(
		wget --no-check-certificate --timeout=10 -qO- "https://api.github.com/repos/${REPO}/releases/latest" |
			grep "browser_download_url" |
			grep "${MATCH}" |
			sed 's/.*"browser_download_url": "\([^"]*\)".*/\1/' ||
			true
	)
	if [ -z "$DOWNLOAD_URL" ]; then
		ui_print "! Unable to get release from https://github.com/${REPO}/releases"
		return 1
	fi
	FILENAME=$(basename "$DOWNLOAD_URL")
	ui_print "- Downloading $FILENAME..."
	wget --no-check-certificate --timeout=100 -qO "$TMPDIR/$FILENAME" "$DOWNLOAD_URL" || {
		ui_print "! Download timeout or failed"
		return 1
	}
}

# shellcheck disable=SC2034
SKIPUNZIP=1
# shellcheck disable=SC2034
SKIPMOUNT=false

if [ "$BOOTMODE" != true ]; then
	ui_print "! Please install in Magisk Manager or KernelSU Manager"
	ui_print "! Install from recovery is NOT supported"
	abort "-----------------------------------------------------------"
elif [ "$KSU" = true ] && [ "$KSU_VER_CODE" -lt 10670 ]; then
	abort "error: Please update your KernelSU and KernelSU Manager"
fi

SERVICE_DIR="/data/adb/service.d"

TS_DIR="/data/adb/tailscale"
TS_BIN_DIR="$TS_DIR/bin"
TS_SCRIPTS_DIR="$TS_DIR/scripts"

case $ARCH in
arm) F_ARCH="armv7a" ;;
arm64) F_ARCH="aarch64" ;;
*)
	ui_print "Unsupported architecture: $ARCH"
	abort
	;;
esac
ui_print "- Detected architecture: $ARCH"

if [ -d "$TS_DIR" ]; then
	[ -f "$TS_DIR/tmp/tailscaled.state" ] && mv -f "$TS_DIR/tmp/tailscaled.state" "$TS_DIR/tailscaled.state"
	ui_print "- Backup old files"
	PROP_FILE="$(echo "$MODPATH" | sed 's/_update//')/module.prop"
	[ ! -f "$PROP_FILE" ] && PROP_FILE="$MODPATH/module.prop"
	versionCode=$(grep '^versionCode=' "$PROP_FILE" | cut -d= -f2)
	# shellcheck disable=SC2154
	rm -rf "$TS_DIR/backups/$versionCode/" && mkdir -p "$TS_DIR/backups/$versionCode/"
	for p in "$TS_DIR"/*; do
		case "$(basename "$p")" in
		ssh | certs | backups | tailscaled.state) ;;
		*)
			mv -f -- "$p" "$TS_DIR/backups/$versionCode/"
			;;
		esac
	done
fi

mkdir -p "$TS_BIN_DIR"
unzip -qqjo "$ZIPFILE" "tailscale/bin/*-$ARCH" -d "$TS_BIN_DIR" 2>/dev/null || true
for f in "$TS_BIN_DIR"/*-"$ARCH"; do
	[ -f "$f" ] && mv "$f" "${f%-"$ARCH"}"
done

[ -f "$TS_BIN_DIR/tailscaled" ] || {
	gh_download "anasfanani/tailscale-android-cli" "tailscale_.*_${ARCH}\.tgz" || abort "error: Unable to download."
	tar -xzf "$TMPDIR/$FILENAME" -C $TS_BIN_DIR || abort "error: Unable extract archive."
}

[ -f "$TS_BIN_DIR/jq" ] || {
	gh_download "theshoqanebi/jq-build-for-android" "jq-${F_ARCH}-linux-android" || abort "error: Unable to download."
	mv -f "$TMPDIR/$FILENAME" "$TS_BIN_DIR/jq" || abort "error: Unable to move file."
}

ui_print "- Extracting files..."
unzip -qqo "$ZIPFILE" -x 'META-INF/*' 'tailscale/*' -d "$MODPATH"

mkdir -p "$TS_DIR" "$TS_SCRIPTS_DIR" "$SERVICE_DIR" "$MODPATH/system/bin/"
unzip -qqjo "$ZIPFILE" 'tailscale/scripts/*' -d "$TS_SCRIPTS_DIR"
unzip -qqjo "$ZIPFILE" 'tailscale/settings.sh' -d "$TS_DIR"
ln -sf "$TS_BIN_DIR/tailscaled" "$TS_BIN_DIR/tailscale"
ln -sf "$TS_BIN_DIR/"* "$MODPATH/system/bin/"

ln -sf "$TS_SCRIPTS_DIR/tailscaled.service" "$MODPATH/system/bin/"

ui_print "- Setting permissions"
set_perm_recursive "$TS_BIN_DIR/" 0 0 0755 0755 "u:object_r:system_file:s0"
set_perm_recursive "$TS_SCRIPTS_DIR/" 0 0 0755 0755 "u:object_r:system_file:s0"
set_perm_recursive "$MODPATH/system/bin/" 0 0 0755 0755 "u:object_r:system_file:s0"
set_perm "$MODPATH/service.sh" 0 0 0755 "u:object_r:system_file:s0"

if [ ! -f "$SERVICE_DIR/tailscaled_service.sh" ]; then
	# offer to move module scripts to general scripts
	ui_print "-----------------------------------------------------------"
	ui_print "- Do you want to move Module Scripts to General Scripts ?"
	ui_print "- This option allows you to toggle the 'tailscaled' service"
	ui_print "  on or off by enabling or disabling modules."
	ui_print "- Your service directory is :"
	ui_print "  '$SERVICE_DIR'."
	ui_print "- Because the Developer Guides mentioned :"
	ui_print "  Modules should NOT add general scripts during installation."
	ui_print "- I offer this option to you."
	ui_print "- You have 10 seconds to make a selection. Default is [Yes]."
	ui_print "- [ Vol UP(+): Yes ]"
	ui_print "- [ Vol DOWN(-): No ]"
	timeout 10 sh -c '
  while true; do
    if getevent -lc 1 2>&1 | grep -q KEY_VOLUMEUP; then
      echo "up"
      break
    elif getevent -lc 1 2>&1 | grep -q KEY_VOLUMEDOWN; then
      echo "down"
      break
    fi
  done
' >"$TMPDIR/choice" || true

	choice=$(cat "$TMPDIR/choice" 2>/dev/null)
	if [ "$choice" = "up" ] || [ -z "$choice" ]; then
		ui_print "- [Yes] Move Module Scripts to General Scripts."
		mv -f "$MODPATH/service.sh" "$SERVICE_DIR/tailscaled_service.sh"
	else
		ui_print "- [No] Skip and keep using Module Scripts."
	fi
else
	ui_print "- Move General Scripts."
	mv -f "$MODPATH/service.sh" "$SERVICE_DIR/tailscaled_service.sh"
fi
ui_print "- Starting service in background."
${TS_SCRIPTS_DIR}/start.sh postinstall 2>&1 &
if [ ! -f "/system/bin/tailscale" ] || ! cmp --silent "/system/bin/tailscale" "$MODPATH/system/bin/tailscale"; then
	ui_print "- Link file to /dev/."
	ln -sf "$TS_SCRIPTS_DIR/tailscaled.service" /dev/tailscaled.service
	ln -sf "$TS_BIN_DIR/tailscaled" /dev/tailscaled
	ln -sf "$TS_BIN_DIR/tailscaled" /dev/tailscale
	ui_print "-----------------------------------------------------------"
	ui_print " Instructions       "
	ui_print "-----------------------------------------------------------"
	ui_print "- If you not reboot, execute with /dev/tailscale or /dev/tailscaled.service."
	ui_print "- After reboot, you can use tailscale and tailscaled.service directly."
	if [ ! -f "$TS_DIR/tailscaled.state" ]; then
		ui_print "- Quickstart to new user :"
		ui_print "  su -c '/dev/tailscale login'"
		ui_print "  su -c '/dev/tailscaled.service status'"
		ui_print "- Read the README.md"
	else
		ui_print "- Tailscaled service manager :"
		ui_print "  su -c '/dev/tailscaled.service'"
	fi
else
	if [ ! -f "$TS_DIR/tailscaled.state" ]; then
		ui_print "- Quickstart to login :"
		ui_print "  su -c 'tailscale login'"
		ui_print "  su -c 'tailscaled.service status'"
		ui_print "- Read the README.md"
	else
		ui_print "- Tailscaled service manager :"
		ui_print "  su -c 'tailscaled.service'"
	fi
fi
[ -n "${DEBUG:-}" ] && { set +ue; } || true

```

`module.prop`:

```prop
id=magisk-tailscaled
name=Magisk Tailscaled
version=v2.0.0.1
versionCode=02000001
author=anasfanani
description=Tailscale. The easiest, most secure way to use WireGuard and 2FA.
updateJson=https://raw.githubusercontent.com/anasfanani/Magisk-Tailscaled/master/update.json
```

`service.sh`:

```sh
#!/system/bin/sh
# this service later will moved to General Scripts for enabling and disabling tailscaled service when default state is disabled
# wait for boot to complete
while [ "$(getprop sys.boot_completed)" != 1 ]; do
    sleep 1
done
# ensure boot has actually completed & network is ready
sleep 5
# start service
/data/adb/tailscale/scripts/start.sh
```

`tailscale/scripts/start.sh`:

```sh
#!/system/bin/sh
DIR=$(dirname "$(realpath "$0")")
# shellcheck source=../settings.sh
. "$DIR"/../settings.sh
case "$1" in
    postinstall)
      rm -rf $TS_RUN_DIR && mkdir -p $TS_RUN_DIR
      tailscaled.service restart >> "/dev/null" 2>&1 &
      return 0
    ;;
esac
start_service() {
  if [ ! -f "${TS_MOD_DIR}/disable" ]; then
    tailscaled.service start >> "/dev/null" 2>&1
  fi
}
start_inotifyd() {
  for PID in $(busybox pidof inotifyd); do
    if grep -q "tailscaled.inotify" "/proc/$PID/cmdline"; then
      kill -9 "$PID"
    fi
  done
  echo "${CURRENT_TIME} [Info]: Starting tailscaled inotify service" > "${TS_RUN_LOG_FILE}"
  inotifyd "tailscaled.inotify" "${TS_MOD_DIR}" >> "/dev/null" 2>&1 &
}

module_version=$(busybox awk -F'=' '!/^ *#/ && /version=/ { print $2 }' "$TS_MOD_PROP" 2>/dev/null)
log Info "Magisk Tailscaled version : ${module_version}."
start_service
start_inotifyd
```

`tailscale/scripts/tailscaled.inotify`:

```inotify
#!/system/bin/sh
DIR=$(dirname "$(realpath "$0")")
# shellcheck source=../settings.sh
. "$DIR"/../settings.sh

events="$1"
# monitor_dir="$2"
monitor_file="$3"

service_control() {
  if [ "${monitor_file}" = "disable" ]; then
    if [ "${events}" = "d" ]; then
      echo "${CURRENT_TIME} [Info]: ✔ Starting tailscaled service" >>"${TS_RUN_LOG_FILE}"
      tailscaled.service start >>"${TS_RUN_LOG_FILE}" 2>&1
    elif [ "${events}" = "n" ]; then
      echo "${CURRENT_TIME} [Info]: ✘ Stopping tailscaled service" >>"${TS_RUN_LOG_FILE}"
      tailscaled.service stop >>"${TS_RUN_LOG_FILE}" 2>&1
    fi
  fi
}
service_control

```

`tailscale/scripts/tailscaled.service`:

```service
#!/system/bin/sh
# @title Tailscaled Service Manager
# @header Manage and customize how tailscaled runs on your Android.
#
# @cmd start | Start tailscaled service
# @desc Read configuration file in ${TS_DIR}/ and store output log to ${TS_LOG_FILE} then write pid file to ${TS_RUN_DIR}.
#
# @cmd stop | Stop tailscaled service
# @desc Kill with signal 15, waiting to process doing self cleanup, if still running, then force kill.
#
# @cmd restart | Restart tailscaled service
# @desc Kill, waiting, then start the process again, this command also rename file log to ${TS_LOG_FILE}.bak, always have .bak from last running process.
#
# @cmd status | Show current process status
# @sub summary | Show summary with Self info and peer counts (default)
# @sub peer | Show all peers (online/offline)
# @sub exit-node | Show all exit nodes
# @sub all | Show everything (Self + peers + exit nodes)
# @desc Retrieving info from daemon, useful for inspect current running process.
#
# @cmd log | Logging tools
# @sub daemon | Tailscaled daemon log (follow mode)
# @sub service | Service operation log
# @desc View logs from tailscaled daemon, service.
#
# @cmd help | Show this help message
# @sub all | Show detailed descriptions for all commands
#
set -e
DIR=$(dirname "$(realpath "$0")")
# shellcheck source=../settings.sh
. "$DIR"/../settings.sh
scripts_name=$(basename "$0")

program(){

  # logdir
  # command
  # pre_up
  # pre_down
  # post_up
  # post_down

  # log Debug "logdir ${logdir}"
  # log Debug "command ${command}"
  # log Debug "pre_up ${pre_up}"
  # log Debug "pre_down ${pre_down}"
  # log Debug "post_up ${post_up}"
  # log Debug "post_down ${post_down}"

  program_name=$(echo "$command" | awk '{print $1}' | xargs basename)
  log_file="${logdir}/${program_name}.log"
  pid_file="${logdir}/${program_name}.pid"
  is_running(){
    if PID=$(busybox pgrep -f "${command}"); then
      log Info "✔ ${program_name} service is running with PID: ${PID}."
      return 0
    fi
    return 1
  }
  start(){
    log Info "Starting ${program_name} service."
    if is_running; then return 0; fi 
    if ! command -v "$program_name" > /dev/null 2>&1; then log Error "program not found: ${program_name}"; return 1; fi
    [ -f "${log_file}" ] && mv "${log_file}" "${log_file}.bak" # log for old output
    if [ ! -z "${pre_up}" ];then $pre_up  2>&1; fi
    # shellcheck disable=SC2086
    nohup $command > "${logdir}/${program_name}.log" 2>&1 &
    PID=$!
    # log Debug "Command: ${command}"
    sleep 3 # waiting for program really started
    PID_INFO=$(ps -p $PID -o pid,stime | grep $PID)
    if [ -n "$PID_INFO" ]; then
      # shellcheck disable=SC2086
      set -- $PID_INFO
      pid=$1
      stime=$2
      log Info "✔ ${program_name} service success running with PID: ${pid}, Start time: $stime."
      echo "$pid" > "${pid_file}"
      if [ ! -z "${post_up}" ];then ${post_up} 2>&1; fi
      return 0
    else
      log Error "No process with PID $PID found."
      return 1
    fi
  }
  stop(){
    log Info "Stopping ${program_name} service."
    if PID=$(busybox pgrep -f "${command}"); then
      if [ ! -z "${pre_down}" ];then $pre_down  2>&1; fi
      # Use `busybox pkill` to kill the binary with signal 15, otherwise use `killall`.
      if busybox pkill -f -15 -e "${command}" >/dev/null 2>&1; then
        : # Do nothing if busybox pkill is successful
      else
        busybox killall "${program_name}" >/dev/null 2>&1 || busybox kill -15 "$PID" >/dev/null 2>&1
      fi
    else
      log Info "✘ ${program_name} service is not running."
      [ -t 1 ] && echo "${yellow}--------------------------------------------${normal}"
      return 0
    fi
    sleep 3 # wait the binary has stopped properly
    if ! busybox pgrep -f "${command}" >/dev/null 2>&1; then
      log Info "✘ ${program_name} shutting down, service is stopped."
      log Info "✘ ${program_name} disconnected."
      if [ ! -z "${post_down}" ];then $post_down  2>&1; fi
      [ -t 1 ] && echo "${yellow}--------------------------------------------${normal}"
      return 0
    else
      log Warning "⚠️ ${program_name} Not stopped; may still be shutting down or failed to shut down."
      # try forcing it to shut down.
      log Warning "⚠️ try forcing it to shut down."
      # Use `busybox pkill` to kill the binary with signal 9, otherwise use `killall`.
      if busybox pkill -9 "${command}"; then
        : # Do nothing if busybox pkill is successful
      else
        if command -v killall >/dev/null 2>&1; then
          killall -9 "${program_name}" >/dev/null 2>&1 || true
        else
          pkill -9 "${program_name}" >/dev/null 2>&1 || true
        fi
      fi
      sleep 2
      if ! busybox pgrep -f "${command}" >/dev/null 2>&1; then
        log Info "✔ done, you can sleep peacefully."
        if [ ! -z "${post_down}" ];then post_down  2>&1; fi
        [ -t 1 ] && echo "${yellow}--------------------------------------------${normal}"
        return 0
      fi
    fi
  }
  restart(){
    log Info "Restarting ${program_name} service."
    program stop 
    sleep 0.5
    program start
  }
  
  $1
}

_tailscaled(){
  logdir="${TS_DIR}/run"
  command="${TS_DAEMON_CMD}"
  tailscaled_up(){
    sed -Ei "s/^description=(\[.*][[:space:]]*)?/description=[ ⏲ $CURRENT_TIME | ✔ tailscaled service is running!!! ] /g" "$TS_MOD_PROP"
  }
  tailscaled_down(){
    sed -Ei "s/^description=(\[.*][[:space:]]*)?/description=[ ⏲ $CURRENT_TIME | ✘ tailscaled shutting down, service is stopped !!! ] /g" "$TS_MOD_PROP"
  }
  pre_up=""
  pre_down=""
  post_up="tailscaled_up"
  post_down="tailscaled_down"
  case "$1" in
    status)
      program is_running
    ;;
    start)
      if ! program is_running && ! program start; then
        log Warning "Got unfriendly response after start tailscaled !"
        return 1
      fi
      return 0
    ;;
    restart)
      log Info "Stopping !"
      _tailscaled stop
      log Info "Stop success !"
      sleep 1
      log Info "Restarting !"
      _tailscaled start
      log Info "Restart success !"
    ;;
    stop)
      if ! program stop; then
        log Error "Got unfriendly response after stop tailscaled !"
        return 1
      fi
    ;;
  esac
}

status_tailscaled(){
  mode="${1:-summary}"
  humanize_bytes() {
    awk -v bytes="$1" 'BEGIN {
      if (bytes < 1024) printf "%.0fB", bytes
      else if (bytes < 1048576) printf "%.2fKB", bytes/1024
      else if (bytes < 1073741824) printf "%.2fMB", bytes/1048576
      else printf "%.2fGB", bytes/1073741824
    }'
  }
  echo "${blue}Service Status Info${normal}"
  echo ""
  if _tailscaled status >/dev/null 2>&1; then
      printf "  ${blue}Daemon: ${green}%s${normal}" "running"
      ts_status=$(timeout 10 tailscale status --json 2>/dev/null || echo '{}')
      ts_status_backend="$(echo "$ts_status" | jq -r .BackendState)"
      if [ "$ts_status_backend" != "Running" ]; then
        printf " | ${blue}Backend: ${yellow}%s${normal}\n" "$ts_status_backend"
        return 1
      fi
      printf " | ${blue}Backend: ${green}%s${normal}\n" "$ts_status_backend"
      echo ""
      
      # Show Self section for summary and all modes only
      case "$mode" in
        summary|all)
          self_hostname=$(echo "$ts_status" | jq -r '.Self.HostName')
          self_os=$(echo "$ts_status" | jq -r '.Self.OS')
          self_relay=$(echo "$ts_status" | jq -r '.Self.Relay')
          if [ -f "${TS_DIR}/derpmap.cached.json" ] && [ "$self_relay" != "null" ]; then
            self_relay_name=$(jq -r --arg code "$self_relay" '.Regions | to_entries[] | select(.value.RegionCode == $code) | .value.RegionName' "${TS_DIR}/derpmap.cached.json")
            [ -n "$self_relay_name" ] && self_relay="$self_relay_name"
          fi
          ipv4=$(echo "$ts_status" | jq -r '.Self.TailscaleIPs[0]')
          ipv6=$(echo "$ts_status" | jq -r '.Self.TailscaleIPs[1]')
          
          printf "  ${blue}Self:${normal} ${yellow}%s${normal} ${orange}(%s)${normal}\n" "$self_hostname" "$self_os"
          printf "    ↳ Relay: ${yellow}%s${normal}\n" "$self_relay"
          printf "    ↳ Tailscale IPs: ${yellow}%s${normal}, ${yellow}%s${normal}\n" "$ipv4" "$ipv6"
          
          magic_dns=$(echo "$ts_status" | jq -r '.CurrentTailnet.MagicDNSEnabled')
          magic_dns_suffix=$(echo "$ts_status" | jq -r '.MagicDNSSuffix')
          printf "    ↳ DNS: "
          if [ "$magic_dns" = "true" ]; then
            printf "${green}%s${normal} (${yellow}%s${normal})\n" "Enabled" "$magic_dns_suffix"
          else
            printf "${red}%s${normal}\n" "Disabled"
          fi
          
          addr_count=$(echo "$ts_status" | jq -r '.Self.Addrs | length')
          printf "    ↳ Endpoints ${orange}(%s)${normal}:\n" "$addr_count"
          echo "$ts_status" | jq -r '.Self.Addrs[]' | while read -r addr; do
            ip_addr=$(echo "$addr" | sed 's/\[//g;s/\].*//g;s/:.*//g')
            iface=$(ip -o addr show | grep "$ip_addr" | awk '{print $2}' | head -1)
            
            if echo "$addr" | grep -q '^\['; then
              addr_type="IPv6"
            elif echo "$ip_addr" | grep -qE '^(10\.|172\.(1[6-9]|2[0-9]|3[01])\.|192\.168\.)'; then
              addr_type="Private"
            else
              addr_type="Public"
            fi
            
            if [ -n "$iface" ]; then
              printf "      ↳ ${yellow}%s${normal} ${orange}(%s, %s)${normal}\n" "$addr" "$iface" "$addr_type"
            else
              printf "      ↳ ${yellow}%s${normal} ${orange}(%s)${normal}\n" "$addr" "$addr_type"
            fi
          done
          echo ""
          
          # Show current exit node connection if exists
          exit_node_id=$(echo "$ts_status" | jq -r '.ExitNodeStatus.ID // empty')
          if [ -n "$exit_node_id" ]; then
            exit_node_online=$(echo "$ts_status" | jq -r '.ExitNodeStatus.Online')
            exit_node_ip=$(echo "$ts_status" | jq -r '.ExitNodeStatus.TailscaleIPs[0]' | cut -d'/' -f1)
            exit_node_hostname=$(echo "$ts_status" | jq -r --arg id "$exit_node_id" '.Peer | to_entries[] | select(.value.ID == $id) | .value.HostName')
            exit_node_rx=$(echo "$ts_status" | jq -r --arg id "$exit_node_id" '.Peer | to_entries[] | select(.value.ID == $id) | .value.RxBytes')
            exit_node_tx=$(echo "$ts_status" | jq -r --arg id "$exit_node_id" '.Peer | to_entries[] | select(.value.ID == $id) | .value.TxBytes')
            if [ "$exit_node_online" = "true" ]; then
              printf "  ${blue}Exit Node: ${green}Connected${normal} to ${yellow}%s${normal}\n" "$exit_node_hostname"
            else
              printf "  ${blue}Exit Node: ${red}Offline${normal} ${yellow}%s${normal}\n" "$exit_node_hostname"
            fi
            printf "    ↳ IP: ${yellow}%s${normal}\n" "$exit_node_ip"
            printf "    ↳ Traffic: ${green}↓${normal} ${yellow}%s${normal} | ${red}↑${normal} ${yellow}%s${normal}\n" "$(humanize_bytes "$exit_node_rx")" "$(humanize_bytes "$exit_node_tx")"
            echo ""
          fi
        ;;
      esac
      
      online_count=$(echo "$ts_status" | jq '[.Peer | to_entries | .[] | select(.value.Online == true)] | length')
      offline_count=$(echo "$ts_status" | jq '[.Peer | to_entries | .[] | select(.value.Online == false)] | length')
      exit_online=$(echo "$ts_status" | jq '[.Peer | to_entries | .[] | select(.value.ExitNodeOption == true and .value.Online == true)] | length')
      exit_offline=$(echo "$ts_status" | jq '[.Peer | to_entries | .[] | select(.value.ExitNodeOption == true and .value.Online == false)] | length')
      
      case "$mode" in
        summary)
          printf "  ${blue}Peers:${normal} ${green}%s online${normal}, ${red}%s offline${normal}\n" "$online_count" "$offline_count"
          printf "    ↳ By OS: "
          first=true
          echo "$ts_status" | jq -r '
            [.Peer | to_entries | .[] | {os: .value.OS, online: .value.Online}] |
            group_by(.os) | 
            map({
              os: .[0].os,
              online: map(select(.online == true)) | length,
              offline: map(select(.online == false)) | length
            }) | 
            .[] | "\(.os):\(.online):\(.offline)"
          ' | while IFS=: read -r os online offline; do
            if [ "$first" = true ]; then
              first=false
            else
              printf ", "
            fi
            printf "%s (${green}%s${normal}|${red}%s${normal})" "$os" "$online" "$offline"
          done
          printf "\n"
          printf "    ↳ By Relay:\n"
          if [ -f "${TS_DIR}/derpmap.cached.json" ]; then
            echo "$ts_status" | jq -r --slurpfile derp "${TS_DIR}/derpmap.cached.json" '
              [.Peer | to_entries | .[].value.Relay] | group_by(.) | map(. as $group | {
                code: $group[0],
                count: ($group | length),
                name: ([$derp[0].Regions | to_entries[] | select(.value.RegionCode == $group[0]) | .value.RegionName][0] // $group[0])
              }) | .[] | "\(.name):\(.count)"
            ' | while IFS=: read -r region count; do
              printf "      ↳ %s: ${yellow}%s${normal}\n" "$region" "$count"
            done
          else
            echo "$ts_status" | jq -r '[.Peer | to_entries | .[].value.Relay] | group_by(.) | .[] | "\(.[0]):\(length)"' | while IFS=: read -r region count; do
              printf "      ↳ %s: ${yellow}%s${normal}\n" "$region" "$count"
            done
          fi
          printf "    ↳ Exit Nodes: ${green}%s online${normal}, ${red}%s offline${normal}\n" "$exit_online" "$exit_offline"
        ;;
        peer|all)
          printf "  ${blue}Peers:${normal} ${green}%s online${normal}, ${red}%s offline${normal}\n" "$online_count" "$offline_count"
          echo "$ts_status" | jq -r --arg green "$green" --arg red "$red" --arg orange "$orange" --arg yellow "$yellow" --arg normal "$normal" '
            (.Peer | to_entries | map(select(.value.Online == true)) | "    ↳ Online (\($green)\(length)\($normal))"),
            (.Peer | to_entries | map(select(.value.Online == true)) | .[] | "      ↳ \($green)\(.value.HostName)\($normal)\t\($orange)\(.value.Relay)\($normal) \($yellow)\(.value.TailscaleIPs[0])\($normal) \($orange)\(.value.OS)\($normal)"),
            (.Peer | to_entries | map(select(.value.Online == false)) | "    ↳ Offline (\($red)\(length)\($normal))"),
            (.Peer | to_entries | map(select(.value.Online == false)) | .[] | "      ↳ \($red)\(.value.HostName)\($normal)\t\($orange)\(.value.Relay)\($normal) \($yellow)\(.value.TailscaleIPs[0])\($normal) \($orange)\(.value.OS)\($normal)")
          ' | while IFS= read -r line; do echo "$line"; done
          [ "$mode" = "all" ] && echo ""
        ;;
      esac
      
      case "$mode" in
        exit-node|all)
          printf "  ${blue}Exit Nodes:${normal} ${green}%s online${normal}, ${red}%s offline${normal}\n" "$exit_online" "$exit_offline"
          echo "$ts_status" | jq -r --arg green "$green" --arg red "$red" --arg orange "$orange" --arg yellow "$yellow" --arg normal "$normal" '.Peer | to_entries | map(select(.value.ExitNodeOption == true)) | .[] | if .value.Online then "    ↳ \($green)\(.value.HostName)\($normal)\t\($orange)\(.value.Relay)\($normal) \($yellow)\(.value.TailscaleIPs[0])\($normal) \($orange)\(.value.OS)\($normal)" else "    ↳ \($red)\(.value.HostName)\($normal)\t\($orange)\(.value.Relay)\($normal) \($yellow)\(.value.TailscaleIPs[0])\($normal) \($orange)\(.value.OS)\($normal)" end' | while IFS= read -r line; do echo "$line"; done
        ;;
      esac
  else
      printf "  ${blue}Daemon: ${red}%s${normal}\n" "stopped"
  fi
}
_log(){
  case "$1" in
    service)
      busybox less -F~ "${TS_RUN_LOG_FILE}"
      ;;
    daemon)
      busybox tail -q -n +1 -F "${TS_LOG_FILE}"
      ;;
    *)
      usage log
      ;;
  esac
  
}
_troubleshoot(){
  echo "${red}Not yet ready!${normal}";
  echo "${orange}Solution: ${yellow}Join telegram group at: [ ${green}https://t.me/systembinsh/158${normal} ${yellow}]${normal}";
}
usage(){
    cmd="$1"
    cmds=""
    opts=""
    in_cmd=false
    while IFS= read -r line; do
        case "$line" in
            "# @cmd "*)
                if [ -z "$cmd" ]; then
                    # Global usage: collect all commands
                    line="${line#\# @cmd }"
                    c="${line%%\|*}"
                    c=$(echo "$c" | xargs)
                    [ -z "$cmds" ] && cmds="$c" || cmds="$cmds|$c"
                elif echo "$line" | grep -q "^# @cmd $cmd "; then
                    # Found target command
                    in_cmd=true
                elif [ "$in_cmd" = true ]; then
                    # Hit next command, stop
                    break
                fi
                ;;
            "# @sub "*)
                if [ "$in_cmd" = true ]; then
                    line="${line#\# @sub }"
                    subcmd="${line%%\|*}"
                    subcmd=$(echo "$subcmd" | xargs)
                    [ -z "$opts" ] && opts="$subcmd" || opts="$opts|$subcmd"
                fi
                ;;
        esac
    done < "$0"
    
    if [ -z "$cmd" ]; then
        echo "${yellow}usage${normal}: ${green}${scripts_name}${normal} {${orange}$cmds${normal}}"
    else
        echo "${yellow}usage${normal}: ${green}${scripts_name}${normal} ${yellow}$cmd${normal} {${orange}$opts${normal}}"
    fi
}

help(){
    show_all="${1}"
    
    # Parse and display title/header
    while IFS= read -r line; do
        case "$line" in
            "# @title "*)
                title="${line#\# @title }"
                echo "${green}${title}${normal}"
                ;;
            "# @header "*)
                header="${line#\# @header }"
                echo "${header}"
                ;;
            "# @cmd "*)
                break
                ;;
        esac
    done < "$0"
    
    echo "${blue}Available Command:${normal}"
    
    # Parse and display commands
    while IFS= read -r line; do
        case "$line" in
            "# @cmd "*)
                line="${line#\# @cmd }"
                IFS='|' read -r cmd desc <<EOF
$line
EOF
                cmd=$(echo "$cmd" | xargs)
                desc=$(echo "$desc" | xargs)
                printf "${yellow}%-15s${normal}\t• %s\n" "$cmd" "$desc"
                ;;
            "# @sub "*)
                line="${line#\# @sub }"
                IFS='|' read -r subcmd desc <<EOF
$line
EOF
                subcmd=$(echo "$subcmd" | xargs)
                desc=$(echo "$desc" | xargs)
                printf "  ${yellow}↳${normal} ${orange}%-11s${normal}\t- %s\n" "$subcmd" "$desc"
                ;;
            "# @desc "*)
                if [ "$show_all" = "all" ]; then
                    desc="${line#\# @desc }"
                    first=true
                    echo "$desc" | busybox fold -sw70 | while IFS= read -r dline; do
                        if [ "$first" = true ]; then
                            printf "    ${yellow}↳${normal} %s\n" "$dline"
                            first=false
                        else
                            printf "      %s\n" "$dline"
                        fi
                    done
                fi
                ;;
        esac
    done < "$0"
}

case "$1" in
  start)
    _tailscaled start
    ;;
  stop)
    _tailscaled stop
    ;;
  restart)
    _tailscaled restart
    ;;
  status)
    status_tailscaled "$2"
    ;;
  log)
    _log "$2"
    ;;
  troubleshoot)
    _troubleshoot "$2"
    ;;
  help)
    help "$2" "$3"
    ;;
  *)
    if [ -n "$1" ]; then
      echo "${yellow}${scripts_name} ${orange}$1 ${red}not found${normal}, run ${yellow}${scripts_name} help${normal} for all commands"
      return
    fi
    usage
    ;;
esac
```

`tailscale/settings.sh`:

```sh
#!/system/bin/sh
set -e

# Custom settings

# Set Magisk Tailscale module variables
TS_MOD_DIR="/data/adb/modules/magisk-tailscaled" # Bad code, if magisk in the future change the path location, need to change this.
export TS_MOD_PROP="${TS_MOD_DIR}/module.prop"

# Set tailscale directory variables
TS_DIR="/data/adb/tailscale"

# Set path environment for busybox & other.
export PATH="${TS_DIR}/bin:${TS_DIR}/scripts:/data/adb/magisk:/data/adb/ksu/bin:$PATH:/system/bin:${TS_MOD_DIR}/system/bin"
export HOME="/data/adb/tailscale/" # Because tailscaled will write log to $HOME

# Set tailscaled & tailscale configuration
export TS_DAEMON_CMD="tailscaled -no-logs-no-support"

# Set tailscaled directory variables
export TS_RUN_DIR="${TS_DIR}/run"

# Set tailscaled log variables
export TS_LOG_FILE="${TS_RUN_DIR}/tailscaled.log"
export TS_RUN_LOG_FILE="${TS_RUN_DIR}/runs.log"

# Take the current time
CURRENT_TIME=$(date +"%I:%M %P")

# Coloring
normal="\033[0m"
orange="\033[1;38;5;208m"
red="\033[1;31m"
green="\033[1;32m"
yellow="\033[1;33m"
blue="\033[1;34m"

# Logs function
log() {
  # Selects the text color according to the parameters
  case $1 in
  Info) color="${blue}" ;;
  Success) color="${green}" ;;
  Error) color="${red}" ;;
  Warning) color="${yellow}" ;;
  Debug) color="${orange}" ;;
  *) color="${normal}" ;;
  esac
  # Add messages to time and parameters
  message="${CURRENT_TIME} [$1]: $2"
  if [ -z "$color" ]; then
    echo "${CURRENT_TIME} [Debug]: $1 $2" >>${TS_RUN_LOG_FILE} 2>&1
    return
  fi
  if [ -t 1 ]; then
    # Prints messages to the console
    echo "${color}${message}${normal}"
    echo "${message}" >>${TS_RUN_LOG_FILE} 2>&1
  else
    # Print messages to a log file
    echo "${message}" >>${TS_RUN_LOG_FILE} 2>&1
  fi
}

[ -n "${DEBUG:-}" ] && set -u && set -x && PS4='+ ${0##*/}:${LINENO}: ' || true
```

`uninstall.sh`:

```sh
#!/system/bin/sh
rm -rf /data/adb/tailscale
SERVICE_DIR="/data/adb/service.d"
if [ -f "$SERVICE_DIR/tailscaled_service.sh" ]; then
    rm -f "$SERVICE_DIR/tailscaled_service.sh"
fi
```

`update-arm.json`:

```json
{
  "version": "v2.0.0.1",
  "versionCode": "02000001",
  "zipUrl": "https://github.com/anasfanani/Magisk-Tailscaled/releases/download/v2.0.0.1/Magisk-Tailscaled-v2.0.0.1.zip",
  "changelog": "https://raw.githubusercontent.com/anasfanani/Magisk-Tailscaled/master/CHANGELOG.md"
}

```

`update-arm64.json`:

```json
{
  "version": "v2.0.0.1",
  "versionCode": "02000001",
  "zipUrl": "https://github.com/anasfanani/Magisk-Tailscaled/releases/download/v2.0.0.1/Magisk-Tailscaled-v2.0.0.1.zip",
  "changelog": "https://raw.githubusercontent.com/anasfanani/Magisk-Tailscaled/master/CHANGELOG.md"
}

```

`update.json`:

```json
{
  "version": "v2.0.0.1",
  "versionCode": "02000001",
  "zipUrl": "https://github.com/anasfanani/Magisk-Tailscaled/releases/download/v2.0.0.1/Magisk-Tailscaled-v2.0.0.1.zip",
  "changelog": "https://raw.githubusercontent.com/anasfanani/Magisk-Tailscaled/master/CHANGELOG.md"
}

```