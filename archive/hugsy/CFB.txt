Project Path: arc_hugsy_CFB_w_1kdx1g

Source Tree:

```txt
arc_hugsy_CFB_w_1kdx1g
├── Assets
│   ├── Fonts
│   │   ├── fa-brands-400.ttf
│   │   ├── fa-regular-400.ttf
│   │   └── fa-solid-900.ttf
│   └── Images
│       └── logo
│           ├── Logo_v1.png
│           ├── Logo_v1.svg
│           ├── Logo_v2.png
│           ├── Logo_v2_small.png
│           └── logo.ico
├── Broker
│   ├── CMakeLists.txt
│   ├── Headers
│   │   ├── Broker.hpp
│   │   ├── BrokerUtils.hpp
│   │   ├── ConnectorManager.hpp
│   │   ├── Connectors
│   │   │   ├── Base.hpp
│   │   │   ├── Dummy.hpp
│   │   │   └── JsonQueue.hpp
│   │   ├── Context.hpp
│   │   ├── DriverManager.hpp
│   │   ├── Error.hpp
│   │   ├── IrpManager.hpp
│   │   ├── ManagerBase.hpp
│   │   ├── Native.hpp
│   │   ├── Resource.h
│   │   ├── ServiceManager.hpp
│   │   ├── States.hpp
│   │   └── pch.hpp
│   ├── Source
│   │   ├── Broker.rc.in
│   │   ├── BrokerUtils.cpp
│   │   ├── ConnectorManager.cpp
│   │   ├── Connectors
│   │   │   ├── Dummy.cpp
│   │   │   └── JsonQueue.cpp
│   │   ├── Context.cpp
│   │   ├── DriverManager.cpp
│   │   ├── DriverManagerListener.cpp
│   │   ├── IrpManager.cpp
│   │   ├── Main.cpp
│   │   ├── ManagerBase.cpp
│   │   └── ServiceManager.cpp
│   └── Tests
│       └── CMakeLists.txt
├── CMakeLists.txt
├── Common
│   ├── CMakeLists.txt
│   ├── Headers
│   │   ├── Common.hpp
│   │   ├── Comms.hpp
│   │   ├── CompileInfo.hpp.in
│   │   ├── IoctlCodes.hpp
│   │   ├── Log.hpp
│   │   ├── Messages.hpp
│   │   └── Utils.hpp
│   ├── Source
│   │   ├── Comms.cpp
│   │   ├── Log.cpp
│   │   ├── Messages.cpp
│   │   └── Utils.cpp
│   └── Tests
│       ├── CMakeLists.txt
│       ├── Comms.cpp
│       └── Utils.cpp
├── Docs
│   ├── README.md
│   ├── _sidebar.md
│   ├── concept.md
│   ├── crash-analysis.md
│   ├── debugging.md
│   ├── faq.md
│   ├── fuzzing-vm-setup.md
│   ├── gallery.md
│   ├── index.html
│   ├── setup.md
│   └── usage.md
├── Driver
│   ├── CMakeLists.txt
│   ├── Client
│   │   ├── CMakeLists.txt
│   │   └── Main.cpp
│   ├── Headers
│   │   ├── Callbacks.hpp
│   │   ├── CapturedIrp.hpp
│   │   ├── CapturedIrpManager.hpp
│   │   ├── Context.hpp
│   │   ├── DriverUtils.hpp
│   │   ├── HookedDriver.hpp
│   │   ├── HookedDriverManager.hpp
│   │   └── Native.hpp
│   └── Source
│       ├── Callbacks.cpp
│       ├── CapturedIrp.cpp
│       ├── CapturedIrpManager.cpp
│       ├── Driver.rc.in
│       ├── DriverUtils.cpp
│       ├── Entry.cpp
│       ├── HookedDriver.cpp
│       ├── HookedDriverManager.cpp
│       └── IrpMonitor.inf
├── GUI
│   ├── CMakeLists.txt
│   ├── Headers
│   │   ├── Addons
│   │   │   ├── icons_font_awesome_6.h
│   │   │   └── imgui_hexeditor.h
│   │   ├── App.hpp
│   │   ├── GuiUtils.hpp
│   │   ├── Helpers.hpp
│   │   └── Network.hpp
│   ├── Source
│   │   ├── App.cpp
│   │   ├── GUI.rc.in
│   │   ├── GuiUtils.cpp
│   │   ├── Helpers.cpp
│   │   └── main.cpp
│   └── Tests
│       └── CMakeLists.txt
├── README.md
└── cmake
    ├── FindArgparse.cmake
    ├── FindCatch2.cmake
    ├── FindImgui.cmake
    ├── FindJson.cmake
    ├── FindPhNt.cmake
    ├── FindWdk.cmake
    └── FindWil.cmake

```

`Assets/Images/logo/Logo_v1.svg`:

```svg
<svg id="Layer_1" data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 925.54 527"><defs><style>.cls-1,.cls-6{fill:#fff;}.cls-1,.cls-10,.cls-2,.cls-3,.cls-4,.cls-7,.cls-8{stroke:#000;}.cls-1,.cls-10,.cls-2,.cls-3,.cls-4,.cls-7,.cls-8,.cls-9{stroke-miterlimit:10;}.cls-2,.cls-5,.cls-9{fill:none;}.cls-3{fill:#8b001b;}.cls-4{fill:#8c6239;}.cls-8{fill:#512e12;}.cls-9{stroke:#b91400;}.cls-10,.cls-9{stroke-width:2px;}.cls-11{font-size:57px;fill:#730006;font-family:MVBoli, MV Boli;}.cls-12{font-size:32px;}</style></defs><title>Logo_v1</title><text x="-51" y="-20"/><path class="cls-1" d="M743.5,160.5" transform="translate(-51 -20)"/><path class="cls-2" d="M627.5,128.5" transform="translate(-51 -20)"/><path class="cls-3" d="M17.5,263.5" transform="translate(-51 -20)"/><circle class="cls-4" cx="98" cy="49" r="48.5"/><circle class="cls-4" cx="409.5" cy="48.5" r="45"/><circle class="cls-4" cx="253.5" cy="273.5" r="253"/><path class="cls-5" d="M149,313" transform="translate(-51 -20)"/><path class="cls-6" d="M349,321.57c14.32,18.23,29.2,36.66,48.81,49.06s45.08,17.9,66.28,8.5c12.21-5.42,22-15.22,30.11-25.79,30.63-39.69,41.72-93.73,29.19-142.25l-.39-.79Q434.71,262,349.6,318.88" transform="translate(-51 -20)"/><path d="M347.94,322.63c14.33,18.22,29.26,36.78,49.11,49.3,17.85,11.25,40.75,17.22,61.42,10.89C479,376.54,493.69,358.54,504.6,341a169.14,169.14,0,0,0,23.12-62.12,171,171,0,0,0,2-36.23,167.48,167.48,0,0,0-1.93-17.86c-.8-4.86-1.32-10.74-3.49-15.22a1.52,1.52,0,0,0-2-.54Q434,260.74,348.84,317.59c-1.6,1.07-.1,3.67,1.51,2.59q85.09-56.82,173.41-108.59l-2-.53c1.81,3.73,2.21,8.86,2.92,12.93a159.9,159.9,0,0,1,2,17,167.85,167.85,0,0,1-19.79,90.14c-9.6,17.7-22.85,36.45-41.33,45.63-19.94,9.92-44,5.53-62.75-5-21.68-12.13-37.59-32.11-52.69-51.33-1.19-1.51-3.3.62-2.12,2.13Z" transform="translate(-51 -20)"/><ellipse class="cls-7" cx="347.52" cy="303" rx="21.53" ry="25.5"/><path class="cls-6" d="M260.45,317.57c-14.3,18.23-29.16,36.66-48.74,49.06s-45,17.9-66.18,8.5c-12.2-5.42-21.93-15.22-30.07-25.79-30.58-39.69-41.65-93.73-29.14-142.25l.38-.79Q174.87,258,259.85,314.88" transform="translate(-51 -20)"/><path d="M259.39,316.5c-13.46,17.15-27.38,34.63-45.6,47-17.71,12-40.78,18.9-61.85,12.44-20.43-6.26-35-24.9-45.52-42.51a168,168,0,0,1-23.56-91.6,159.91,159.91,0,0,1,1.71-18.67c.76-5,1.2-11.48,3.43-16.08l-2,.53q88.14,51.75,173.15,108.59c1.61,1.08,3.11-1.52,1.51-2.59Q175.65,256.77,87.46,205a1.52,1.52,0,0,0-2,.54c-1.86,3.83-2.34,8.71-3.08,12.86-.91,5.11-1.58,10.27-2,15.44a167.35,167.35,0,0,0,.62,33.49,171.38,171.38,0,0,0,19.32,61.35c9.91,18.3,23.8,37.83,43.06,47.07,19.54,9.37,42.53,6,61.37-3.42,23.68-11.9,40.79-33.28,56.82-53.7,1.18-1.51-.93-3.64-2.12-2.13Z" transform="translate(-51 -20)"/><ellipse class="cls-7" cx="160" cy="299" rx="21.5" ry="25.5"/><ellipse class="cls-8" cx="255.5" cy="364" rx="29" ry="21.5"/><path class="cls-2" d="M284.12,340l45.88.33A293,293,0,0,1,293.08,352l22.87-.13-30.84,4.31c12.29.69,24.79,1.62,36.73-.52" transform="translate(-51 -20)"/><path class="cls-9" d="M110.33,344.65l18-32.69,5.19,20.8a20.76,20.76,0,0,0,6.92-16.68,13,13,0,0,1,5,8.17c5.19,2.95,9.43,1.27,14.62,4.23" transform="translate(-51 -20)"/><path class="cls-9" d="M82,258.54l44-5.42-20.33,16.62a125.63,125.63,0,0,1,31-4.4" transform="translate(-51 -20)"/><path class="cls-9" d="M525.71,235.23a242.22,242.22,0,0,0-50.07,26.21l32.19.62-18.9,11.46,11.84,0a128.07,128.07,0,0,1-29.62,11.22l-2.25-4.14c-4.29-.45-8.83,1.46-10.42,4.38" transform="translate(-51 -20)"/><path class="cls-9" d="M505.31,327.87l-13.09-26.1-2.74,24.84L476.15,307.2c.09,4.74,0,9.93-3,13.55s-10.23,3.65-11.57-.89" transform="translate(-51 -20)"/><path d="M307.53,446.33a1.5,1.5,0,0,0,0-3,1.5,1.5,0,0,0,0,3Z" transform="translate(-51 -20)"/><path d="M307.53,447.16a1.5,1.5,0,0,0,0-3,1.5,1.5,0,0,0,0,3Z" transform="translate(-51 -20)"/><path d="M307.53,447.16a1.5,1.5,0,0,0,0-3,1.5,1.5,0,0,0,0,3Z" transform="translate(-51 -20)"/><path class="cls-2" d="M257.15,489.22" transform="translate(-51 -20)"/><path class="cls-1" d="M317.92,486a501.93,501.93,0,0,0-126.66,13.14c-11.78,2.77-26.28,5.2-34.25-3.74-3.93-4.41-5-10.51-5.81-16.31a251.35,251.35,0,0,1-1.7-47.57c.45-7.41,1.72-15.76,8.16-19.69,7.36-4.5,17-.68,25,2.59,39.6,16.19,86.6,13.94,124.4-5.94h1c37.8,19.88,84.8,22.13,124.4,5.94,8-3.27,17.47-7.2,24.83-2.7,6.43,3.94,7.84,12.39,8.29,19.8a251.35,251.35,0,0,1-1.7,47.57c-.76,5.8-1.88,11.9-5.81,16.31-8,8.94-22.47,6.51-34.25,3.74A501.93,501.93,0,0,0,297.14,486Z" transform="translate(-51 -20)"/><line class="cls-1" x1="372.01" y1="398.49" x2="372.83" y2="480.01"/><line class="cls-1" x1="342.63" y1="404.88" x2="343.45" y2="473.62"/><line class="cls-1" x1="310.8" y1="404.48" x2="313.25" y2="469.22"/><line class="cls-1" x1="201.44" y1="404.88" x2="201.44" y2="469.62"/><line class="cls-1" x1="169.61" y1="404.88" x2="170.43" y2="473.62"/><line class="cls-1" x1="141.05" y1="399.29" x2="140.23" y2="478.41"/><line class="cls-1" x1="397.31" y1="428.46" x2="282.24" y2="434.85"/><line class="cls-1" x1="116.56" y1="428.46" x2="231.64" y2="434.85"/><path class="cls-1" d="M307.94,510h22l2.45-91.11-25.3-10.39Q307.52,459.25,307.94,510Z" transform="translate(-51 -20)"/><path class="cls-1" d="M306.31,510h-22l-2.45-91.11,25.3-10.39Z" transform="translate(-51 -20)"/><polyline class="cls-1" points="406.29 390.9 397.31 429.26 397.31 434.06 402.21 478.81"/><polyline class="cls-1" points="106.77 481.21 115.89 435.5 116.2 430.64 107.22 392.28"/><ellipse class="cls-10" cx="294.38" cy="390.04" rx="7.77" ry="11.35" transform="translate(-245.2 378.94) rotate(-54)"/><ellipse class="cls-10" cx="319.62" cy="389.54" rx="12.46" ry="7.58" transform="matrix(0.81, -0.59, 0.59, 0.81, -218.93, 242.26)"/><path class="cls-1" d="M538.5,197.5a1457.34,1457.34,0,0,1-236,20,1457.39,1457.39,0,0,1-233-18,296.56,296.56,0,0,1,56-86,1737.83,1737.83,0,0,0,176,7,1736.77,1736.77,0,0,0,177-11,274.68,274.68,0,0,1,60,88Z" transform="translate(-51 -20)"/><text x="-51" y="-20"/><text class="cls-11" transform="translate(54.92 160.65)">C<tspan class="cls-12" x="33.93" y="0">anadian </tspan><tspan x="157.01" y="0">F</tspan><tspan class="cls-12" x="188.48" y="0">urious </tspan><tspan x="291.45" y="0">B</tspan><tspan class="cls-12" x="325.94" y="0">eaver</tspan></text></svg>
```

`Broker/CMakeLists.txt`:

```txt
project(Broker
    LANGUAGES CXX
    VERSION 0.2.0
)

message(STATUS "Configuring '${PROJECT_NAME}'")

set(BROKER_SOURCE_DIR ${CFB_ROOT_DIR}/Broker/Source)
set(BROKER_HEADER_DIR ${CFB_ROOT_DIR}/Broker/Headers)

set(BROKER_VERSION_MAJOR ${PROJECT_VERSION_MAJOR} CACHE INTERNAL "BROKER_VERSION_MAJOR")
set(BROKER_VERSION_MINOR ${PROJECT_VERSION_MINOR} CACHE INTERNAL "BROKER_VERSION_MINOR")
set(BROKER_VERSION_PATCH ${PROJECT_VERSION_PATCH} CACHE INTERNAL "BROKER_VERSION_PATCH")

set(BROKER_RC_FILE ${BROKER_SOURCE_DIR}/Broker.rc)
set(BROKER_RES_FILE ${BROKER_SOURCE_DIR}/Broker.res)

#
# Source files
#
set(
    HEADER_FILES

    ${BROKER_HEADER_DIR}/Resource.h
    ${BROKER_HEADER_DIR}/Error.hpp
    ${BROKER_HEADER_DIR}/Broker.hpp
    ${BROKER_HEADER_DIR}/Native.hpp
    ${BROKER_HEADER_DIR}/Context.hpp
    ${BROKER_HEADER_DIR}/States.hpp
    ${BROKER_HEADER_DIR}/BrokerUtils.hpp
    ${BROKER_HEADER_DIR}/ManagerBase.hpp
    ${BROKER_HEADER_DIR}/ServiceManager.hpp
    ${BROKER_HEADER_DIR}/IrpManager.hpp
    ${BROKER_HEADER_DIR}/ConnectorManager.hpp
    ${BROKER_HEADER_DIR}/DriverManager.hpp

    ${BROKER_HEADER_DIR}/Connectors/Base.hpp
    ${BROKER_HEADER_DIR}/Connectors/Dummy.hpp
    ${BROKER_HEADER_DIR}/Connectors/JsonQueue.hpp
)

set(
    SOURCE_FILES

    ${BROKER_SOURCE_DIR}/Main.cpp
    ${BROKER_SOURCE_DIR}/Context.cpp
    ${BROKER_SOURCE_DIR}/BrokerUtils.cpp
    ${BROKER_SOURCE_DIR}/ManagerBase.cpp
    ${BROKER_SOURCE_DIR}/ServiceManager.cpp
    ${BROKER_SOURCE_DIR}/IrpManager.cpp
    ${BROKER_SOURCE_DIR}/ConnectorManager.cpp
    ${BROKER_SOURCE_DIR}/DriverManager.cpp
    ${BROKER_SOURCE_DIR}/DriverManagerListener.cpp

    ${BROKER_SOURCE_DIR}/Connectors/Dummy.cpp
    ${BROKER_SOURCE_DIR}/Connectors/JsonQueue.cpp
)

#
# Create the broker rc file
#
cmake_path(SET CFB_BROKER_DRIVER_PATH "$ENV{TEMP}/IrpMonitor.sys")
cmake_path(SET CFB_BROKER_ICON_PATH "${CFB_ROOT_DIR}/Assets/Images/logo/logo.ico")
configure_file(${BROKER_RC_FILE}.in ${BROKER_RC_FILE} NEWLINE_STYLE WIN32 ESCAPE_QUOTES)

#
# Create the executable target
#
add_executable(${PROJECT_NAME} WIN32 ${SOURCE_FILES})
add_executable(CFB::User::Broker ALIAS ${PROJECT_NAME})
add_dependencies(${PROJECT_NAME} CFB::Kernel::Driver)

target_include_directories(${PROJECT_NAME}
    PRIVATE
    ${BROKER_HEADER_DIR}

    $<TARGET_PROPERTY:Deps::Argparse,INTERFACE_INCLUDE_DIRECTORIES>
    $<TARGET_PROPERTY:Deps::JSON,INTERFACE_INCLUDE_DIRECTORIES>
    $<TARGET_PROPERTY:Deps::WIL,INTERFACE_INCLUDE_DIRECTORIES>
)

target_precompile_headers(${PROJECT_NAME}
    PRIVATE
    ${BROKER_HEADER_DIR}/pch.hpp
)

#
# Compilation directives
#
target_compile_features(${PROJECT_NAME} PUBLIC cxx_std_20)

target_compile_options(
    ${PROJECT_NAME}
    PUBLIC
    $<$<COMPILE_LANGUAGE:CXX>:/Zc:__cplusplus>
    $<$<NOT:$<STREQUAL:${CMAKE_GENERATOR_PLATFORM},arm64>>:$<$<CONFIG:Debug>:/fsanitize=address>>

    PRIVATE
    $<IF:$<CONFIG:Debug>,/WX /Gm- /permissive-,/WX /permissive>
)

#
# Linking directives
#
target_link_options(
    ${PROJECT_NAME}
    PUBLIC
    /SUBSYSTEM:Console
    $<$<NOT:$<STREQUAL:${CMAKE_GENERATOR_PLATFORM},arm64>>:$<$<CONFIG:Debug>:/InferAsanLibs>>

    PRIVATE
)

target_link_libraries(${PROJECT_NAME}
    ${BROKER_RES_FILE}

    CFB::User::CommonLib

    Deps::WIL
    Deps::JSON

    ws2_32.lib
    Userenv.lib
    Rpcrt4.lib
    kernel32.lib
    ntdll.lib
    Advapi32.lib
)

set_target_properties(${PROJECT_NAME}
    PROPERTIES
    LINK_FLAGS " /level='requireAdministrator' /uiAccess='false' "
)

#
# Install directives
#
install(TARGETS ${PROJECT_NAME} DESTINATION Tools)
install(FILES $<TARGET_PDB_FILE:${PROJECT_NAME}> DESTINATION Tools OPTIONAL)

#
# Custom command directives
#
add_custom_command(
    TARGET ${PROJECT_NAME} PRE_BUILD
    COMMAND
    rc /nologo /I ${BROKER_HEADER_DIR} /fo ${BROKER_RES_FILE} /r ${BROKER_RC_FILE}
    COMMENT
    "Compiling '${BROKER_RES_FILE}' resource file"
)

```

`Broker/Headers/Broker.hpp`:

```hpp
#pragma once

// clang-format off
#include "pch.hpp"

#include "Native.hpp"
#include "Common.hpp"
#include "CompileInfo.hpp"
#include "Error.hpp"
// clang-format on

```

`Broker/Headers/BrokerUtils.hpp`:

```hpp
#pragma once

// clang-format off
#include "Broker.hpp"


// clang-format on


namespace CFB::Broker::Utils
{

namespace Base64
{

///
/// @brief Encode a vector of bytes to base64
///
/// @param bytes
/// @return std::string
///
std::string
Encode(std::vector<u8> const& bytes);

///
/// @brief Encode a char* to base64
///
/// @param bytes_to_encode
/// @param in_len
/// @return std::string
///
std::string
Encode(const u8* bytes_to_encode, const usize in_len);

///
/// @brief Decode a given base64-encoded string to an array of bytes
///
/// @param encoded_string
/// @return std::vector<u8>
///
std::vector<u8>
Decode(std::string const& encoded_string);
} // namespace Base64


///
/// @brief Helper function to enumerate objects from the Object Manager
///
/// @param Root the root to start dumping objects
/// @return Result<std::vector<std::pair<std::wstring, std::wstring>>>
///
Result<std::vector<std::pair<std::wstring, std::wstring>>>
EnumerateObjectDirectory(std::wstring const& Root = L"\\");


///
/// @brief Try to acquire a privilege from its name
///
/// @param lpszPrivilegeName
/// @return Result<bool>
///
Result<bool>
AcquirePrivileges(std::vector<std::wstring_view> const& privilege_names);


///
/// @brief
///
/// @param lpszPrivilegeName
/// @param lpHasPriv
/// @return Result<bool>
///
Result<bool>
HasPrivilege(std::wstring_view const& privilege_name);


} // namespace CFB::Broker::Utils

```

`Broker/Headers/ConnectorManager.hpp`:

```hpp
#pragma once

// clang-format off
#include "Common.hpp"
#include "ManagerBase.hpp"

#include "Connectors/Base.hpp"
// clang-format on


namespace CFB::Broker
{
class ConnectorManager : public ManagerBase
{
public:
    ///
    /// @brief Construct a new Connector Manager object
    ///
    ///
    ConnectorManager()
    {
    }

    ///
    /// @brief Destroy the Connector Manager object
    ///
    ///
    ~ConnectorManager()
    {
    }

    ///
    /// @brief
    ///
    /// @return std::string const
    ///
    std::string const
    Name();

    ///
    /// @brief
    ///
    /// @return Result<bool>
    ///
    Result<bool>
    Setup();

    ///
    /// @brief
    ///
    ///
    void
    Run();

    ///
    ///@brief Get the Connector By Name object
    ///
    ///@param ConnectorName
    ///@return Result<std::shared_ptr<Connectors::ConnectorBase>>
    ///
    Result<std::shared_ptr<Connectors::ConnectorBase>>
    GetConnectorByName(std::string_view const& ConnectorName);

private:
};
} // namespace CFB::Broker

```

`Broker/Headers/Connectors/Base.hpp`:

```hpp
#pragma once

#include "Common.hpp"
#include "Comms.hpp"
#include "Error.hpp"

namespace CFB::Broker::Connectors
{
class ConnectorBase
{
public:
    ConnectorBase() : m_Enabled {false}
    {
    }

    ~ConnectorBase()
    {
    }

    virtual std::string const
    Name() const = 0;

    void
    Enable()
    {
        m_Enabled = true;
    }

    void
    Disable()
    {
        m_Enabled = false;
    }

    bool
    IsEnabled() const
    {
        return m_Enabled;
    }

    virtual Result<u32>
    IrpCallback(CFB::Comms::CapturedIrp const& Irp) = 0;

protected:
    bool m_Enabled;
};
} // namespace CFB::Broker::Connectors

```

`Broker/Headers/Connectors/Dummy.hpp`:

```hpp
#pragma once

///
/// This is an example of connector to print out IRP to terminal
///

#include "Connectors/Base.hpp"

namespace CFB::Broker::Connectors
{

class Dummy : public ConnectorBase
{
public:
    Dummy();

    ~Dummy();

    std::string const
    Name() const override;

    Result<u32>
    IrpCallback(CFB::Comms::CapturedIrp const& Irp) override;

private:
};

} // namespace CFB::Broker::Connectors

```

`Broker/Headers/Connectors/JsonQueue.hpp`:

```hpp
#pragma once

#include <queue>
#include <mutex>

#include "Connectors/Base.hpp"

namespace CFB::Broker::Connectors
{

class JsonQueue : public ConnectorBase
{
public:
    JsonQueue();

    ~JsonQueue();

    std::string const
    Name() const override;

    Result<u32>
    IrpCallback(CFB::Comms::CapturedIrp const& Irp) override;

    std::unique_ptr<CFB::Comms::CapturedIrp>
    Pop();

private:
    std::queue<std::unique_ptr<CFB::Comms::CapturedIrp>> m_Queue;
    std::mutex m_Lock;
};

} // namespace CFB::Broker::Connectors

```

`Broker/Headers/Context.hpp`:

```hpp
#pragma once

// clang-format off
#include <atomic>
#include <mutex>
#include <stop_token>
#include <thread>

#include "States.hpp"

#include "ServiceManager.hpp"
#include "IrpManager.hpp"
#include "ConnectorManager.hpp"
#include "DriverManager.hpp"
// clang-format on

namespace fs = std::filesystem;

class GlobalContext
{
public:
    ///
    /// @brief Construct a new Global Context object
    ///
    GlobalContext();

    ///
    /// @brief Destroy the Global Context object
    ///
    ///
    ~GlobalContext();

    ///
    /// @brief
    ///
    /// @return true
    /// @return false
    ///
    bool
    Stop();

    ///
    /// @brief Set new state
    ///
    /// @return true
    /// @return false
    ///
    bool SetState(CFB::Broker::State);

    ///
    /// @brief
    ///
    /// @return true
    /// @return false
    ///
    bool
    WaitForState(CFB::Broker::State WantedState);

    ///
    /// @brief
    ///
    /// @return CFB::Broker::State const
    ///
    CFB::Broker::State const
    State() const;

    ///
    /// @brief Read-only access to the current process ID
    ///
    /// @return u32 const
    ///
    u32 const
    Pid() const;

    ///
    /// @brief Read-only access to the broker path
    ///
    /// @return fs::path&
    ///
    fs::path const&
    Path() const;

    ///
    /// @brief Get a shared pointer to the service manager object
    ///
    /// @return std::shared_ptr<CFB::Broker::ServiceManager>
    ///
    std::shared_ptr<CFB::Broker::ServiceManager>
    ServiceManager() const;

    ///
    /// @brief Get a shared pointer to the driver manager
    ///
    /// @return std::shared_ptr<CFB::Broker::DriverManager>
    ///
    std::shared_ptr<CFB::Broker::DriverManager>
    DriverManager() const;

    ///
    ///@brief
    ///
    ///@return std::shared_ptr<CFB::Broker::IrpManager>
    ///
    std::shared_ptr<CFB::Broker::IrpManager>
    IrpManager() const;

    ///
    ///@brief
    ///
    ///@return std::shared_ptr<CFB::Broker::ConnectorManager>
    ///
    std::shared_ptr<CFB::Broker::ConnectorManager>
    ConnectorManager() const;

    ///
    /// @brief
    ///
    /// @return const HANDLE
    ///
    const HANDLE
    TerminationEvent() const;

private:
    ///
    /// @brief This mutex protects state changes
    ///
    std::mutex m_StateMutex;

    ///
    /// @brief The manager current state
    ///
    CFB::Broker::State m_State;

    ///
    /// @brief The current process ID
    ///
    u32 m_Pid;

    ///
    /// @brief Broker path
    ///
    fs::path m_BrokerPath;

    ///
    /// @brief
    ///
    ///
    wil::unique_handle m_hTerminationEvent;

    ///
    /// @brief
    ///
    ///
    bool m_bIsShuttingDown;


    //////////////////////////////////////////////////////////////////////////////
    ///
    /// Manager declaration below: each manager is its own jthread
    ///

    ///
    /// @brief A global thread interruption token: if set all the threads will attempt
    /// to exit cleanly
    ///
    std::stop_token m_InterruptToken;

    ///
    /// @brief The service manager self-extracts and creates the driver service
    ///
    std::jthread m_ServiceManagerThread;

    ///
    /// @brief
    ///
    std::jthread m_IrpManagerThread;

    ///
    /// @brief
    ///
    std::jthread m_ConnectorManagerThread;

    ///
    /// @brief
    ///
    std::jthread m_DriverManagerThread;

    ///
    /// @brief
    ///
    std::shared_ptr<CFB::Broker::ServiceManager> m_ServiceManager;

    ///
    /// @brief
    ///
    std::shared_ptr<CFB::Broker::IrpManager> m_IrpManager;

    ///
    /// @brief
    ///
    std::shared_ptr<CFB::Broker::ConnectorManager> m_ConnectorManager;

    ///
    /// @brief
    ///
    std::shared_ptr<CFB::Broker::DriverManager> m_DriverManager;
};


extern GlobalContext Globals;

```

`Broker/Headers/DriverManager.hpp`:

```hpp
#pragma once

// clang-format off
#include <mutex>

#include "Common.hpp"
#include "Broker.hpp"
#include "Error.hpp"
#include "ManagerBase.hpp"
#include "Messages.hpp"

#include <wil/resource.h>

#include <nlohmann/json.hpp>
using json = nlohmann::json;
// clang-format on

namespace CFB::Broker
{

class DriverManager : public ManagerBase
{
public:
    class TcpClient
    {
    public:
        TcpClient() : m_Id {0}, m_Socket {0}, m_IpAddress {}, m_Port {0}, m_ThreadId {0}, m_hThread {nullptr}
        {
        }

        ~TcpClient();

        ///
        /// @brief Synchronous send
        ///
        /// @return Result<u32>
        ///
        Result<u32>
        SendSynchronous(json const&);

        ///
        /// @brief
        ///
        /// @return Result<std::vector<u8>>
        ///
        Result<json>
        ReceiveSynchronous();

        std::string
        Name();

        usize m_Id      = 0;
        SOCKET m_Socket = 0;
        std::string m_IpAddress;
        u16 m_Port                   = 0;
        u32 m_ThreadId               = 0;
        wil::unique_handle m_hThread = nullptr;
    };


    class TcpListener
    {
    public:
        ///
        /// @brief Construct a new Tcp Listener object
        ///
        TcpListener();

        ///
        /// @brief Destroy the Tcp Listener object
        ///
        ~TcpListener();

        ///
        /// @brief Create the listening socket
        ///
        /// @return Result<bool>
        ///
        Result<bool>
        Initialize();

        ///
        /// @brief
        ///
        /// @return Result<bool>
        ///
        Result<bool>
        Listen();

        ///
        /// @brief Accept a client socket
        ///
        /// @return SOCKET
        ///
        Result<std::shared_ptr<TcpClient>>
        Accept();

        ///
        /// @brief
        ///
        /// @return true
        /// @return false
        ///
        bool
        Reconnect();

        ///
        /// @brief
        ///
        /// @return true
        /// @return false
        ///
        Result<bool>
        Terminate();

        ///
        /// @brief
        ///
        /// @return Result<u32>
        ///
        Result<u32>
        RunForever();

        std::string
        Name();


    private:
        SOCKET m_ServerSocket;

        std::vector<std::shared_ptr<TcpClient>> m_Clients;
    };


    ///
    /// @brief Construct a new Driver Manager object
    ///
    DriverManager();

    ///
    /// @brief Destroy the Driver Manager object
    ///
    ~DriverManager();

    ///
    /// @brief
    ///
    /// @return std::string const
    ///
    std::string const
    Name();

    ///
    /// @brief
    ///
    /// @return Result<bool>
    ///
    Result<bool>
    Setup();

    ///
    /// @brief
    ///
    void
    Run();

    ///
    /// @brief Execute command directly on the broker. This can be used to have the broker build commands directly
    /// to the driver.
    ///
    /// @return Result<json>
    ///
    Result<json>
    ExecuteCommand(json const& Request);

private:
    ///
    /// @brief Handle to the device
    ///
    wil::unique_handle m_hDevice;

    ///
    /// @brief For now only use TCP
    ///
    TcpListener m_Listener;

    ///
    /// @brief
    ///
    ///
    std::mutex m_ManagerLock;

    usize m_RequestNumber;
};

} // namespace CFB::Broker

```

`Broker/Headers/Error.hpp`:

```hpp
#pragma once


#include <optional>
#include <variant>

#include "Common.hpp"


enum class ErrorCode : u32
{
    GenericError,
    RuntimeError,
    UnexpectedStateError,
    InvalidInput,
    InvalidParameter,
    InitializationError,
    UnexpectedType,
    ArithmeticError,
    OverflowError,
    UnderflowError,
    IllegalValue,
    NotImplementedError,
    PendingIoError,
    NetworkError,
    ConnectionError,
    TerminationError,
    ServiceError,
    FilesystemError,
    InsufficientPrivilegeError,
    SocketInitializationFailed,
    LookupError,
    DeviceNotInitialized,
    InvalidRequestId,
    NotFound,
};

///
/// @brief Rust-like type of error handling
///
struct ErrorType
{
    const ErrorCode code;
    const u32 number;
};


template<class T>
using SuccessType = std::optional<T>;

template<class T>
using Result = std::variant<SuccessType<T>, ErrorType>;

struct Err : ErrorType
{
#ifdef _WIN32
    Err(ErrorCode ErrCode = ErrorCode::GenericError) : ErrorType {ErrCode, ::GetLastError()}
#else
    Err(ErrorCode ErrCode = ErrorCode::GenericError) : ErrorType {ErrCode, ::errno}
#endif // _WIN32
    {
    }

    bool
    operator==(const Err& rhs) const
    {
        return this->code == rhs.code;
    }

    bool
    operator==(ErrorCode code) const
    {
        return this->code == code;
    }
};

template<class T>
struct Ok : SuccessType<T>
{
    Ok(T value) : SuccessType<T>(value)
    {
    }
};

template<class T>
constexpr bool
Success(Result<T> const& f)
{
    if ( const SuccessType<T>* c = std::get_if<SuccessType<T>>(&f); c != nullptr )
    {
        return true;
    }
    return false;
}

template<class T>
constexpr bool
Failed(Result<T> const& f)
{
    if ( Success(f) )
    {
        return false;
    }

    if ( const ErrorType* c = std::get_if<ErrorType>(&f); c != nullptr )
    {
        return true;
    }

    throw std::bad_variant_access();
}

template<class T>
constexpr T const&
Value(Result<T> const& f)
{
    if ( const SuccessType<T>* c = std::get_if<SuccessType<T>>(&f); c != nullptr && c->has_value() )
    {
        return c->value();
    }
    throw std::bad_variant_access();
}

template<class T>
constexpr ErrorType const&
Error(Result<T> const& f)
{
    if ( const ErrorType* c = std::get_if<ErrorType>(&f); c != nullptr )
    {
        return *c;
    }
    throw std::bad_variant_access();
}


namespace CFB::Broker::Utils
{
#define CaseToString(x)                                                                                                \
    {                                                                                                                  \
    case (x):                                                                                                          \
        return #x;                                                                                                     \
    }

constexpr const char*
ToString(ErrorType const& x)
{
    switch ( x.code )
    {
        CaseToString(ErrorCode::GenericError);
        CaseToString(ErrorCode::RuntimeError);
        CaseToString(ErrorCode::UnexpectedStateError);
        CaseToString(ErrorCode::InvalidInput);
        CaseToString(ErrorCode::InvalidParameter);
        CaseToString(ErrorCode::InitializationError);
        CaseToString(ErrorCode::UnexpectedType);
        CaseToString(ErrorCode::ArithmeticError);
        CaseToString(ErrorCode::OverflowError);
        CaseToString(ErrorCode::UnderflowError);
        CaseToString(ErrorCode::IllegalValue);
        CaseToString(ErrorCode::NotImplementedError);
        CaseToString(ErrorCode::PendingIoError);
        CaseToString(ErrorCode::NetworkError);
        CaseToString(ErrorCode::ConnectionError);
        CaseToString(ErrorCode::TerminationError);
        CaseToString(ErrorCode::ServiceError);
        CaseToString(ErrorCode::FilesystemError);
        CaseToString(ErrorCode::InsufficientPrivilegeError);
        CaseToString(ErrorCode::SocketInitializationFailed);
        CaseToString(ErrorCode::LookupError);
        CaseToString(ErrorCode::DeviceNotInitialized);
        CaseToString(ErrorCode::InvalidRequestId);
        CaseToString(ErrorCode::NotFound);

    default:
        throw std::invalid_argument("Unimplemented item");
    }
}
#undef CaseAsString
} // namespace CFB::Broker::Utils

```

`Broker/Headers/IrpManager.hpp`:

```hpp
#pragma once

// clang-format off
#include "Common.hpp"
#include "ManagerBase.hpp"
#include "Comms.hpp"

#include <condition_variable>
#include <mutex>
#include <queue>
#include <functional>
#include <thread>
#include <vector>

#include <wil/resource.h>
// clang-format on

namespace CFB::Broker
{

class IrpManager : public ManagerBase
{
public:
    ///
    /// @brief Construct a new IRP Manager object
    ///
    IrpManager();

    ///
    /// @brief Destroy the IRP Manager object
    ///
    ~IrpManager();

    ///
    /// @brief
    ///
    /// @return std::string const
    ///
    std::string const
    Name();

    ///
    /// @brief
    ///
    void
    Run();

    ///
    /// @brief
    ///
    /// @return Result<bool>
    ///
    Result<bool>
    Setup();

    ///
    ///@brief
    ///
    ///@param cb
    ///@return true
    ///@return false
    ///
    bool
    SetCallback(std::function<bool(CFB::Comms::CapturedIrp const&)> cb);

private:
    ///
    /// @brief Pop the next IRP from the IrpMonitor and push it to the local queue `m_Irps`
    ///
    /// @return usize
    ///
    std::vector<CFB::Comms::CapturedIrp>
    GetNextIrps();

    ///
    /// @brief Handle to the device
    ///
    wil::unique_handle m_hDevice;

    ///
    /// @brief Handle to the notification event
    ///
    wil::unique_handle m_hNewIrpEvent;

    ///
    /// @brief
    ///
    std::function<bool(CFB::Comms::CapturedIrp const&)> m_CallbackDispatcher;

    std::mutex m_CallbackLock;
};

} // namespace CFB::Broker

```

`Broker/Headers/ManagerBase.hpp`:

```hpp
#pragma once

#include <wil/resource.h>

#include "Error.hpp"
#include "States.hpp"

namespace CFB::Broker
{
class ManagerBase
{
public:
    ///
    /// @brief Construct a new Manager Base object
    ///
    ///
    ManagerBase();

    ///
    /// @brief Destroy the Manager Base object
    ///
    ///
    ~ManagerBase();

    ///
    /// @brief Synchronizes on the Global state semaphore to execute code only when in a specific state
    ///
    /// @param NewState
    /// @return true
    /// @return false
    ///
    bool
    WaitForState(CFB::Broker::State WantedState);

    ///
    /// @brief Simple wrapper of `Globals.NotifyNewState`
    ///
    /// @param NewState
    /// @return true
    /// @return false
    ///
    bool
    SetState(CFB::Broker::State NewState);

    ///
    /// @brief
    ///
    /// @return true
    /// @return false
    ///
    bool
    NotifyStateChange();

    ///
    /// @brief
    ///
    /// @return true
    /// @return false
    ///
    bool
    NotifyTermination();

    ///
    /// @brief
    ///
    ///
    virtual Result<bool>
    Setup() = 0;


    ///
    /// @brief
    ///
    ///
    virtual void
    Run() = 0;

    ///
    /// @brief
    ///
    /// @return std::string const&
    ///
    virtual std::string const
    Name() = 0;


protected:
    ///
    /// @brief
    ///
    ///
    wil::unique_handle m_hChangedStateEvent;

    ///
    /// @brief
    ///
    ///
    wil::unique_handle m_hTerminationEvent;

    ///
    /// @brief
    ///
    ///
    bool m_bIsShuttingDown;
};


} // namespace CFB::Broker

```

`Broker/Headers/Native.hpp`:

```hpp
#pragma once

/************************************************************************************
 *
 *  (C) COPYRIGHT AUTHORS, 2015 - 2019, translated from Microsoft sources/debugger
 *
 *  TITLE:       NTOS.H
 *
 *  VERSION:     1.121
 *
 *  DATE:        18 Oct 2019
 *
 *  Common header file for the ntos API functions and definitions.
 *
 *  Only projects required API/definitions.
 *
 *  Depends on:    Windows.h
 *                 NtStatus.h
 *
 *  Include:       Windows.h
 *                 NtStatus.h
 *
 * THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
 * ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
 * TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
 * PARTICULAR PURPOSE.
 *
 ************************************************************************************/

#include <Windows.h>

//
// NTOS_RTL HEADER BEGIN
//

#if defined(__cplusplus)
extern "C"
{
#endif

#pragma comment(lib, "ntdll.lib")

#pragma warning(push)
#pragma warning(disable : 4201) // nonstandard extension used : nameless struct/union
#pragma warning(disable : 4214) // nonstandard extension used : bit field types other than int

#ifndef PAGE_SIZE
#define PAGE_SIZE 0x1000ull
#endif

#ifndef ABSOLUTE_TIME
#define ABSOLUTE_TIME(wait) (wait)
#endif

#ifndef RELATIVE_TIME
#define RELATIVE_TIME(wait) (-(wait))
#endif

#ifndef NANOSECONDS
#define NANOSECONDS(nanos) (((signed __int64)(nanos)) / 100L)
#endif

#ifndef MICROSECONDS
#define MICROSECONDS(micros) (((signed __int64)(micros)) * NANOSECONDS(1000L))
#endif

#ifndef MILLISECONDS
#define MILLISECONDS(milli) (((signed __int64)(milli)) * MICROSECONDS(1000L))
#endif

#ifndef SECONDS
#define SECONDS(seconds) (((signed __int64)(seconds)) * MILLISECONDS(1000L))
#endif

#ifndef POI // poi-poi
#define POI(addr) *(ULONG*)(addr)
#endif

    typedef char CCHAR;
    typedef unsigned char UCHAR;
    typedef CCHAR KPROCESSOR_MODE;
    typedef UCHAR KIRQL;
    typedef KIRQL* PKIRQL;
    typedef ULONG CLONG;
    typedef LONG KPRIORITY;
    typedef short CSHORT;
    typedef ULONGLONG REGHANDLE, *PREGHANDLE;
    typedef PVOID* PDEVICE_MAP;
    typedef PVOID PHEAD;

#ifndef _WIN32_WINNT_WIN10
#define _WIN32_WINNT_WIN10 0x0A00
#endif
#if ( _WIN32_WINNT < _WIN32_WINNT_WIN10 )
    typedef PVOID PMEM_EXTENDED_PARAMETER;
#endif

#ifndef IN_REGION
#define IN_REGION(x, Base, Size)                                                                                       \
    (((ULONG_PTR)(x) >= (ULONG_PTR)(Base)) && ((ULONG_PTR)(x) <= (ULONG_PTR)(Base) + (ULONG_PTR)(Size)))
#endif

    //
    // Define alignment macros to align structure sizes and pointers up and down.
    //

#ifndef ALIGN_UP_TYPE
#define ALIGN_UP_TYPE(Address, Align) (((ULONG_PTR)(Address) + (Align)-1) & ~((Align)-1))
#endif

#ifndef ALIGN_UP
#define ALIGN_UP(Address, Type) ALIGN_UP_TYPE(Address, sizeof(Type))
#endif

#ifndef ALIGN_DOWN_TYPE
#define ALIGN_DOWN_TYPE(Address, Align) ((ULONG_PTR)(Address) & ~((ULONG_PTR)(Align)-1))
#endif

#ifndef ALIGN_DOWN
#define ALIGN_DOWN(Address, Type) ALIGN_DOWN_TYPE(Address, sizeof(Type))
#endif

#ifndef ALIGN_UP_BY
#define ALIGN_UP_BY(Address, Align) (((ULONG_PTR)(Address) + (Align)-1) & ~((Align)-1))
#endif

#ifndef ALIGN_DOWN_BY
#define ALIGN_DOWN_BY(Address, Align) ((ULONG_PTR)(Address) & ~((ULONG_PTR)(Align)-1))
#endif

#ifndef ALIGN_UP_POINTER_BY
#define ALIGN_UP_POINTER_BY(Pointer, Align) ((PVOID)ALIGN_UP_BY(Pointer, Align))
#endif

#ifndef ALIGN_DOWN_POINTER_BY
#define ALIGN_DOWN_POINTER_BY(Pointer, Align) ((PVOID)ALIGN_DOWN_BY(Pointer, Align))
#endif

#ifndef ALIGN_UP_POINTER
#define ALIGN_UP_POINTER(Pointer, Type) ((PVOID)ALIGN_UP(Pointer, Type))
#endif

#ifndef ALIGN_DOWN_POINTER
#define ALIGN_DOWN_POINTER(Pointer, Type) ((PVOID)ALIGN_DOWN(Pointer, Type))
#endif

#ifndef ARGUMENT_PRESENT
#define ARGUMENT_PRESENT(ArgumentPointer) ((CHAR*)((ULONG_PTR)(ArgumentPointer)) != (CHAR*)(NULL))
#endif

#ifndef LOGICAL
#define LOGICAL ULONG
#endif

#define NtCurrentProcess() ((HANDLE)(LONG_PTR)-1)
#define ZwCurrentProcess() NtCurrentProcess()
#define NtCurrentThread() ((HANDLE)(LONG_PTR)-2)
#define ZwCurrentThread() NtCurrentThread()
#define NtCurrentSession() ((HANDLE)(LONG_PTR)-3)
#define ZwCurrentSession() NtCurrentSession()

// Valid Only for Windows 8+
#define NtCurrentProcessToken() ((HANDLE)(LONG_PTR)-4)
#define NtCurrentThreadToken() ((HANDLE)(LONG_PTR)-5)
#define NtCurrentEffectiveToken() ((HANDLE)(LONG_PTR)-6)

//
// ntdef.h begin
//
#ifndef RTL_CONSTANT_STRING
    char
    _RTL_CONSTANT_STRING_type_check(const void* s);
#define _RTL_CONSTANT_STRING_remove_const_macro(s) (s)
#define RTL_CONSTANT_STRING(s)                                                                                         \
    {                                                                                                                  \
        sizeof(s) - sizeof((s)[0]), sizeof(s) / sizeof(_RTL_CONSTANT_STRING_type_check(s)),                            \
            _RTL_CONSTANT_STRING_remove_const_macro(s)                                                                 \
    }
#endif

#ifndef RTL_CONSTANT_OBJECT_ATTRIBUTES
#define RTL_CONSTANT_OBJECT_ATTRIBUTES(n, a)                                                                           \
    {                                                                                                                  \
        sizeof(OBJECT_ATTRIBUTES), NULL, RTL_CONST_CAST(PUNICODE_STRING)(n), a, NULL, NULL                             \
    }
#endif

    // This synonym is more appropriate for initializing what isn't actually const.
#ifndef RTL_INIT_OBJECT_ATTRIBUTES
#define RTL_INIT_OBJECT_ATTRIBUTES(n, a) RTL_CONSTANT_OBJECT_ATTRIBUTES(n, a)
#endif

//
// ntdef.h end
//
#ifndef RtlOffsetToPointer
#define RtlOffsetToPointer(Base, Offset) ((PCHAR)(((PCHAR)(Base)) + ((ULONG_PTR)(Offset))))
#endif

#ifndef RtlPointerToOffset
#define RtlPointerToOffset(Base, Pointer) ((ULONG)(((PCHAR)(Pointer)) - ((PCHAR)(Base))))
#endif

//
// Valid values for the OBJECT_ATTRIBUTES.Attributes field
//
#define OBJ_INHERIT 0x00000002L
#define OBJ_PERMANENT 0x00000010L
#define OBJ_EXCLUSIVE 0x00000020L
#define OBJ_CASE_INSENSITIVE 0x00000040L
#define OBJ_OPENIF 0x00000080L
#define OBJ_OPENLINK 0x00000100L
#define OBJ_KERNEL_HANDLE 0x00000200L
#define OBJ_FORCE_ACCESS_CHECK 0x00000400L
#define OBJ_VALID_ATTRIBUTES 0x000007F2L

//
// Callback Object Rights
//
#define CALLBACK_MODIFY_STATE 0x0001
#define CALLBACK_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | CALLBACK_MODIFY_STATE)

//
// CompositionSurface Access Rights
//
#ifndef COMPOSITIONSURFACE_READ
#define COMPOSITIONSURFACE_READ 0x0001L
#endif

#ifndef COMPOSITIONSURFACE_WRITE
#define COMPOSITIONSURFACE_WRITE 0x0002L
#endif

#ifndef COMPOSITIONSURFACE_ALL_ACCESS
#define COMPOSITIONSURFACE_ALL_ACCESS (COMPOSITIONSURFACE_READ | COMPOSITIONSURFACE_WRITE)
#endif

//
// Debug Object Access Rights
//
#define DEBUG_READ_EVENT (0x0001)
#define DEBUG_PROCESS_ASSIGN (0x0002)
#define DEBUG_SET_INFORMATION (0x0004)
#define DEBUG_QUERY_INFORMATION (0x0008)
#define DEBUG_ALL_ACCESS                                                                                               \
    (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | DEBUG_READ_EVENT | DEBUG_PROCESS_ASSIGN | DEBUG_SET_INFORMATION |        \
     DEBUG_QUERY_INFORMATION)

//
// Directory Object Access Rights
//
#define DIRECTORY_QUERY (0x0001)
#define DIRECTORY_TRAVERSE (0x0002)
#define DIRECTORY_CREATE_OBJECT (0x0004)
#define DIRECTORY_CREATE_SUBDIRECTORY (0x0008)
#define DIRECTORY_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0xF)

//
// Event Object Access Rights
//
#define EVENT_QUERY_STATE 0x0001
#define EVENT_MODIFY_STATE 0x0002


//
// EventPair Object Access Rights
//
#define EVENT_PAIR_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE)

//
// I/O Completion Object Access Rights
//
#define IO_COMPLETION_QUERY_STATE 0x0001
#define IO_COMPLETION_MODIFY_STATE 0x0002


//
// KeyedEvent Object Access Rights
//
#define KEYEDEVENT_WAIT 0x0001
#define KEYEDEVENT_WAKE 0x0002
#define KEYEDEVENT_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | KEYEDEVENT_WAIT | KEYEDEVENT_WAKE)

//
// Mutant Object Access Rights
//
#define MUTANT_QUERY_STATE 0x0001
#ifndef MUTANT_ALL_ACCESS // SDK compatibility
#define MUTANT_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | MUTANT_QUERY_STATE)
#endif

//
// Port Object Access Rights
//
#define PORT_CONNECT (0x0001)
#define PORT_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | PORT_CONNECT)

//
// Profile Object Access Rights
//
#define PROFILE_CONTROL (0x0001)
#define PROFILE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | PROFILE_CONTROL)

//
// Semaphore Object Access Rights
//
#define SEMAPHORE_QUERY_STATE 0x0001
#define SEMAPHORE_MODIFY_STATE 0x0002

//
// SymbolicLink Object Access Rights
//
#define SYMBOLIC_LINK_QUERY (0x0001)
#define SYMBOLIC_LINK_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | SYMBOLIC_LINK_QUERY)

//
// Thread Object Access Rights
//
#define THREAD_ALERT (0x0004)

#define THREAD_CREATE_FLAGS_CREATE_SUSPENDED 0x00000001
#define THREAD_CREATE_FLAGS_SKIP_THREAD_ATTACH 0x00000002
#define THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER 0x00000004
#define THREAD_CREATE_FLAGS_HAS_SECURITY_DESCRIPTOR 0x00000010
#define THREAD_CREATE_FLAGS_ACCESS_CHECK_IN_TARGET 0x00000020
#define THREAD_CREATE_FLAGS_INITIAL_THREAD 0x00000080

//
// Worker Factory Object Access Rights
//
#define WORKER_FACTORY_RELEASE_WORKER 0x0001
#define WORKER_FACTORY_WAIT 0x0002
#define WORKER_FACTORY_SET_INFORMATION 0x0004
#define WORKER_FACTORY_QUERY_INFORMATION 0x0008
#define WORKER_FACTORY_READY_WORKER 0x0010
#define WORKER_FACTORY_SHUTDOWN 0x0020

#define WORKER_FACTORY_ALL_ACCESS                                                                                      \
    (STANDARD_RIGHTS_REQUIRED | WORKER_FACTORY_RELEASE_WORKER | WORKER_FACTORY_WAIT | WORKER_FACTORY_SET_INFORMATION | \
     WORKER_FACTORY_QUERY_INFORMATION | WORKER_FACTORY_READY_WORKER | WORKER_FACTORY_SHUTDOWN)

//
// Type Object Access Rights
//
#define OBJECT_TYPE_CREATE (0x0001)
#define OBJECT_TYPE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | OBJECT_TYPE_CREATE)

//
// WMI Object Access Rights
//
#define WMIGUID_QUERY 0x0001
#define WMIGUID_SET 0x0002
#define WMIGUID_NOTIFICATION 0x0004
#define WMIGUID_READ_DESCRIPTION 0x0008
#define WMIGUID_EXECUTE 0x0010
#define TRACELOG_CREATE_REALTIME 0x0020
#define TRACELOG_CREATE_ONDISK 0x0040
#define TRACELOG_GUID_ENABLE 0x0080
#define TRACELOG_ACCESS_KERNEL_LOGGER 0x0100
#define TRACELOG_CREATE_INPROC 0x0200
#define TRACELOG_ACCESS_REALTIME 0x0400
#define TRACELOG_REGISTER_GUIDS 0x0800
#define TRACELOG_JOIN_GROUP 0x1000

//
// Memory Partition Object Access Rights
//
#define MEMORY_PARTITION_QUERY_ACCESS 0x0001
#define MEMORY_PARTITION_MODIFY_ACCESS 0x0002

#define MEMORY_PARTITION_ALL_ACCESS                                                                                    \
    (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | MEMORY_PARTITION_QUERY_ACCESS | MEMORY_PARTITION_MODIFY_ACCESS)

//
// NtCreateProcessEx specific flags.
//
#define PS_REQUEST_BREAKAWAY 1
#define PS_NO_DEBUG_INHERIT 2
#define PS_INHERIT_HANDLES 4
#define PS_LARGE_PAGES 8
#define PS_ALL_FLAGS (PS_REQUEST_BREAKAWAY | PS_NO_DEBUG_INHERIT | PS_INHERIT_HANDLES | PS_LARGE_PAGES)

//
// Define special ByteOffset parameters for read and write operations
//
#ifndef FILE_WRITE_TO_END_OF_FILE
#define FILE_WRITE_TO_END_OF_FILE 0xffffffff
#endif
#ifndef FILE_USE_FILE_POINTER_POSITION
#define FILE_USE_FILE_POINTER_POSITION 0xfffffffe
#endif

//
// This is the maximum MaximumLength for a UNICODE_STRING.
//
#ifndef MAXUSHORT
#define MAXUSHORT 0xffff
#endif
#ifndef MAX_USTRING
#define MAX_USTRING (sizeof(WCHAR) * (MAXUSHORT / sizeof(WCHAR)))
#endif

    typedef struct _EX_RUNDOWN_REF
    {
        union
        {
            ULONG Count;
            PVOID Ptr;
        };
    } EX_RUNDOWN_REF, *PEX_RUNDOWN_REF;

#ifdef _WIN64
#define MAX_FAST_REFS 15
#else
#define MAX_FAST_REFS 7
#endif

    typedef struct _EX_FAST_REF
    {
        union
        {
            PVOID Object;
#if defined(_WIN64)
            ULONG_PTR RefCnt : 4;
#else
        ULONG_PTR RefCnt : 3;
#endif
            ULONG_PTR Value;
        };
    } EX_FAST_REF, *PEX_FAST_REF;

    typedef struct _UNICODE_STRING
    {
        USHORT Length;
        USHORT MaximumLength;
        PWSTR Buffer;
    } UNICODE_STRING, *PUNICODE_STRING;
    typedef const UNICODE_STRING* PCUNICODE_STRING;

#ifndef STATIC_UNICODE_STRING
#define STATIC_UNICODE_STRING(string, value)                                                                           \
    static UNICODE_STRING string = {sizeof(value) - sizeof(WCHAR), sizeof(value), value};
#endif

    typedef struct _STRING
    {
        USHORT Length;
        USHORT MaximumLength;
        PCHAR Buffer;
    } STRING;
    typedef STRING* PSTRING;

    typedef STRING ANSI_STRING;
    typedef PSTRING PANSI_STRING;

    typedef STRING OEM_STRING;
    typedef PSTRING POEM_STRING;
    typedef CONST STRING* PCOEM_STRING;
    typedef CONST char* PCSZ;

    typedef struct _CSTRING
    {
        USHORT Length;
        USHORT MaximumLength;
        CONST char* Buffer;
    } CSTRING;
    typedef CSTRING* PCSTRING;
#define ANSI_NULL ((CHAR)0)

    typedef STRING CANSI_STRING;
    typedef PSTRING PCANSI_STRING;

    typedef struct _OBJECT_ATTRIBUTES
    {
        ULONG Length;
        HANDLE RootDirectory;
        PUNICODE_STRING ObjectName;
        ULONG Attributes;
        PVOID SecurityDescriptor;
        PVOID SecurityQualityOfService;
    } OBJECT_ATTRIBUTES;
    typedef OBJECT_ATTRIBUTES* POBJECT_ATTRIBUTES;

    typedef struct _IO_STATUS_BLOCK
    {
        union
        {
            NTSTATUS Status;
            PVOID Pointer;
        } DUMMYUNIONNAME;

        ULONG_PTR Information;
    } IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;

    /*
    ** FileCache and MemoryList START
    */

    typedef enum _SYSTEM_MEMORY_LIST_COMMAND
    {
        MemoryCaptureAccessedBits,
        MemoryCaptureAndResetAccessedBits,
        MemoryEmptyWorkingSets,
        MemoryFlushModifiedList,
        MemoryPurgeStandbyList,
        MemoryPurgeLowPriorityStandbyList,
        MemoryCommandMax
    } SYSTEM_MEMORY_LIST_COMMAND;

    typedef struct _SYSTEM_FILECACHE_INFORMATION
    {
        SIZE_T CurrentSize;
        SIZE_T PeakSize;
        ULONG PageFaultCount;
        SIZE_T MinimumWorkingSet;
        SIZE_T MaximumWorkingSet;
        SIZE_T CurrentSizeIncludingTransitionInPages;
        SIZE_T PeakSizeIncludingTransitionInPages;
        ULONG TransitionRePurposeCount;
        ULONG Flags;
    } SYSTEM_FILECACHE_INFORMATION, *PSYSTEM_FILECACHE_INFORMATION;

    /*
    ** FileCache and MemoryList END
    */

    /*
    ** Processes START
    */

    typedef struct _SYSTEM_TIMEOFDAY_INFORMATION
    {
        LARGE_INTEGER BootTime;
        LARGE_INTEGER CurrentTime;
        LARGE_INTEGER TimeZoneBias;
        ULONG TimeZoneId;
        ULONG Reserved;
        ULONGLONG BootTimeBias;
        ULONGLONG SleepTimeBias;
    } SYSTEM_TIMEOFDAY_INFORMATION, *PSYSTEM_TIMEOFDAY_INFORMATION;

    typedef enum _THREAD_STATE
    {
        StateInitialized,
        StateReady,
        StateRunning,
        StateStandby,
        StateTerminated,
        StateWait,
        StateTransition,
        StateUnknown
    } THREAD_STATE;

    typedef enum _KWAIT_REASON
    {
        Executive,
        FreePage,
        PageIn,
        PoolAllocation,
        DelayExecution,
        Suspended,
        UserRequest,
        WrExecutive,
        WrFreePage,
        WrPageIn,
        WrPoolAllocation,
        WrDelayExecution,
        WrSuspended,
        WrUserRequest,
        WrEventPair, // has no effect after 7
        WrQueue,
        WrLpcReceive,
        WrLpcReply,
        WrVirtualMemory,
        WrPageOut,
        WrRendezvous,
        WrKeyedEvent,
        WrTerminated,
        WrProcessInSwap,
        WrCpuRateControl,
        WrCalloutStack,
        WrKernel,
        WrResource,
        WrPushLock,
        WrMutex,
        WrQuantumEnd,
        WrDispatchInt,
        WrPreempted,
        WrYieldExecution,
        WrFastMutex,
        WrGuardedMutex,
        WrRundown,
        WrAlertByThreadId,
        WrDeferredPreempt,
        WrPhysicalFault,
        MaximumWaitReason
    } KWAIT_REASON;

    typedef VOID
    KSTART_ROUTINE(_In_ PVOID StartContext);
    typedef KSTART_ROUTINE* PKSTART_ROUTINE;

    typedef struct _CLIENT_ID
    {
        HANDLE UniqueProcess;
        HANDLE UniqueThread;
    } CLIENT_ID, *PCLIENT_ID;

    typedef struct _CLIENT_ID64
    {
        ULONG64 UniqueProcess;
        ULONG64 UniqueThread;
    } CLIENT_ID64, *PCLIENT_ID64;

    typedef struct _CLIENT_ID32
    {
        ULONG32 UniqueProcess;
        ULONG32 UniqueThread;
    } CLIENT_ID32, *PCLIENT_ID32;

    typedef struct _VM_COUNTERS
    {
        SIZE_T PeakVirtualSize;
        SIZE_T VirtualSize;
        ULONG PageFaultCount;
        SIZE_T PeakWorkingSetSize;
        SIZE_T WorkingSetSize;
        SIZE_T QuotaPeakPagedPoolUsage;
        SIZE_T QuotaPagedPoolUsage;
        SIZE_T QuotaPeakNonPagedPoolUsage;
        SIZE_T QuotaNonPagedPoolUsage;
        SIZE_T PagefileUsage;
        SIZE_T PeakPagefileUsage;
        SIZE_T PrivatePageCount;
    } VM_COUNTERS;

    typedef struct _SYSTEM_THREAD_INFORMATION
    {
        LARGE_INTEGER KernelTime;
        LARGE_INTEGER UserTime;
        LARGE_INTEGER CreateTime;
        ULONG WaitTime;
        PVOID StartAddress;
        CLIENT_ID ClientId;
        KPRIORITY Priority;
        KPRIORITY BasePriority;
        ULONG ContextSwitchCount;
        THREAD_STATE State;
        KWAIT_REASON WaitReason;
    } SYSTEM_THREAD_INFORMATION, *PSYSTEM_THREAD_INFORMATION;

    typedef struct _SYSTEM_EXTENDED_THREAD_INFORMATION
    {
        SYSTEM_THREAD_INFORMATION ThreadInfo;
        PVOID StackBase;
        PVOID StackLimit;
        PVOID Win32StartAddress;
        PVOID TebBase;
        ULONG_PTR Reserved2;
        ULONG_PTR Reserved3;
        ULONG_PTR Reserved4;
    } SYSTEM_EXTENDED_THREAD_INFORMATION, *PSYSTEM_EXTENDED_THREAD_INFORMATION;

    typedef struct _SYSTEM_PROCESSES_INFORMATION
    {
        ULONG NextEntryDelta;
        ULONG ThreadCount;
        LARGE_INTEGER SpareLi1;
        LARGE_INTEGER SpareLi2;
        LARGE_INTEGER SpareLi3;
        LARGE_INTEGER CreateTime;
        LARGE_INTEGER UserTime;
        LARGE_INTEGER KernelTime;
        UNICODE_STRING ImageName;
        KPRIORITY BasePriority;
        HANDLE UniqueProcessId;
        HANDLE InheritedFromUniqueProcessId;
        ULONG HandleCount;
        ULONG SessionId;
        ULONG_PTR PageDirectoryBase;
        VM_COUNTERS VmCounters;
        IO_COUNTERS IoCounters;
        SYSTEM_THREAD_INFORMATION Threads[1];
    } SYSTEM_PROCESSES_INFORMATION, *PSYSTEM_PROCESSES_INFORMATION;

    typedef enum _SYSTEM_PROCESS_CLASSIFICATION
    {
        SystemProcessClassificationNormal,
        SystemProcessClassificationSystem,
        SystemProcessClassificationSecureSystem,
        SystemProcessClassificationMemCompression,
        SystemProcessClassificationRegistry,
        SystemProcessClassificationMaximum
    } SYSTEM_PROCESS_CLASSIFICATION;

    typedef struct _PROCESS_DISK_COUNTERS
    {
        ULONGLONG BytesRead;
        ULONGLONG BytesWritten;
        ULONGLONG ReadOperationCount;
        ULONGLONG WriteOperationCount;
        ULONGLONG FlushOperationCount;
    } PROCESS_DISK_COUNTERS, *PPROCESS_DISK_COUNTERS;

    typedef union _ENERGY_STATE_DURATION
    {
        union
        {
            ULONGLONG Value;
            ULONG LastChangeTime;
        };

        ULONG Duration  : 31;
        ULONG IsInState : 1;
    } ENERGY_STATE_DURATION, *PENERGY_STATE_DURATION;

    typedef struct _PROCESS_ENERGY_VALUES
    {
        ULONGLONG Cycles[2][4];
        ULONGLONG DiskEnergy;
        ULONGLONG NetworkTailEnergy;
        ULONGLONG MBBTailEnergy;
        ULONGLONG NetworkTxRxBytes;
        ULONGLONG MBBTxRxBytes;
        union
        {
            ENERGY_STATE_DURATION Durations[3];
            struct
            {
                ENERGY_STATE_DURATION ForegroundDuration;
                ENERGY_STATE_DURATION DesktopVisibleDuration;
                ENERGY_STATE_DURATION PSMForegroundDuration;
            };
        };
        ULONG CompositionRendered;
        ULONG CompositionDirtyGenerated;
        ULONG CompositionDirtyPropagated;
        ULONG Reserved1;
        ULONGLONG AttributedCycles[4][2];
        ULONGLONG WorkOnBehalfCycles[4][2];
    } PROCESS_ENERGY_VALUES, *PPROCESS_ENERGY_VALUES;

    typedef struct _SYSTEM_PROCESS_INFORMATION_EXTENSION
    {
        PROCESS_DISK_COUNTERS DiskCounters;
        ULONGLONG ContextSwitches;
        union
        {
            ULONG Flags;
            struct
            {
                ULONG HasStrongId                 : 1;
                ULONG Classification              : 4; // SYSTEM_PROCESS_CLASSIFICATION
                ULONG BackgroundActivityModerated : 1;
                ULONG Spare                       : 26;
            };
        };
        ULONG UserSidOffset;
        ULONG PackageFullNameOffset;
        PROCESS_ENERGY_VALUES EnergyValues;
        ULONG AppIdOffset;
        SIZE_T SharedCommitCharge;
        ULONG JobObjectId;
        ULONG SpareUlong;
        ULONGLONG ProcessSequenceNumber;
    } SYSTEM_PROCESS_INFORMATION_EXTENSION, *PSYSTEM_PROCESS_INFORMATION_EXTENSION;

    typedef struct _SYSTEM_PROCESSES_FULL_INFORMATION
    {
        SYSTEM_PROCESSES_INFORMATION ProcessAndThreads;
        SYSTEM_PROCESS_INFORMATION_EXTENSION ExtendedInfo;
    } SYSTEM_PROCESSES_FULL_INFORMATION, *PSYSTEM_PROCESSES_FULL_INFORMATION;

    typedef struct _SYSTEM_PROCESS_ID_INFORMATION
    {
        HANDLE ProcessId;
        UNICODE_STRING ImageName;
    } SYSTEM_PROCESS_ID_INFORMATION, *PSYSTEM_PROCESS_ID_INFORMATION;

    typedef struct _SYSTEM_SECUREBOOT_INFORMATION
    {
        BOOLEAN SecureBootEnabled;
        BOOLEAN SecureBootCapable;
    } SYSTEM_SECUREBOOT_INFORMATION, *PSYSTEM_SECUREBOOT_INFORMATION;

    typedef struct _SYSTEM_SECUREBOOT_POLICY_INFORMATION
    {
        GUID PolicyPublisher;
        ULONG PolicyVersion;
        ULONG PolicyOptions;
    } SYSTEM_SECUREBOOT_POLICY_INFORMATION, *PSYSTEM_SECUREBOOT_POLICY_INFORMATION;

    typedef struct _SYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION
    {
        SYSTEM_SECUREBOOT_POLICY_INFORMATION PolicyInformation;
        ULONG PolicySize;
        UCHAR Policy[1];
    } SYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION, *PSYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION;

    typedef struct _SYSTEM_BASIC_INFORMATION
    {
        ULONG Reserved;
        ULONG TimerResolution;
        ULONG PageSize;
        ULONG NumberOfPhysicalPages;
        ULONG LowestPhysicalPageNumber;
        ULONG HighestPhysicalPageNumber;
        ULONG AllocationGranularity;
        ULONG_PTR MinimumUserModeAddress;
        ULONG_PTR MaximumUserModeAddress;
        ULONG_PTR ActiveProcessorsAffinityMask;
        CCHAR NumberOfProcessors;
    } SYSTEM_BASIC_INFORMATION, *PSYSTEM_BASIC_INFORMATION;

    typedef struct _SYSTEM_ISOLATED_USER_MODE_INFORMATION
    {
        BOOLEAN SecureKernelRunning    : 1;
        BOOLEAN HvciEnabled            : 1;
        BOOLEAN HvciStrictMode         : 1;
        BOOLEAN DebugEnabled           : 1;
        BOOLEAN FirmwarePageProtection : 1;
        BOOLEAN EncryptionKeyAvailable : 1;
        BOOLEAN SpareFlags             : 2;
        BOOLEAN TrustletRunning        : 1;
        BOOLEAN HvciDisableAllowed     : 1;
        BOOLEAN SpareFlags2            : 6;
        BOOLEAN Spare0[6];
        ULONGLONG Spare1;
    } SYSTEM_ISOLATED_USER_MODE_INFORMATION, *PSYSTEM_ISOLATED_USER_MODE_INFORMATION;

    typedef enum _PROCESSINFOCLASS
    {
        ProcessBasicInformation                     = 0,
        ProcessQuotaLimits                          = 1,
        ProcessIoCounters                           = 2,
        ProcessVmCounters                           = 3,
        ProcessTimes                                = 4,
        ProcessBasePriority                         = 5,
        ProcessRaisePriority                        = 6,
        ProcessDebugPort                            = 7,
        ProcessExceptionPort                        = 8,
        ProcessAccessToken                          = 9,
        ProcessLdtInformation                       = 10,
        ProcessLdtSize                              = 11,
        ProcessDefaultHardErrorMode                 = 12,
        ProcessIoPortHandlers                       = 13,
        ProcessPooledUsageAndLimits                 = 14,
        ProcessWorkingSetWatch                      = 15,
        ProcessUserModeIOPL                         = 16,
        ProcessEnableAlignmentFaultFixup            = 17,
        ProcessPriorityClass                        = 18,
        ProcessWx86Information                      = 19,
        ProcessHandleCount                          = 20,
        ProcessAffinityMask                         = 21,
        ProcessPriorityBoost                        = 22,
        ProcessDeviceMap                            = 23,
        ProcessSessionInformation                   = 24,
        ProcessForegroundInformation                = 25,
        ProcessWow64Information                     = 26,
        ProcessImageFileName                        = 27,
        ProcessLUIDDeviceMapsEnabled                = 28,
        ProcessBreakOnTermination                   = 29,
        ProcessDebugObjectHandle                    = 30,
        ProcessDebugFlags                           = 31,
        ProcessHandleTracing                        = 32,
        ProcessIoPriority                           = 33,
        ProcessExecuteFlags                         = 34,
        ProcessTlsInformation                       = 35,
        ProcessCookie                               = 36,
        ProcessImageInformation                     = 37,
        ProcessCycleTime                            = 38,
        ProcessPagePriority                         = 39,
        ProcessInstrumentationCallback              = 40,
        ProcessThreadStackAllocation                = 41,
        ProcessWorkingSetWatchEx                    = 42,
        ProcessImageFileNameWin32                   = 43,
        ProcessImageFileMapping                     = 44,
        ProcessAffinityUpdateMode                   = 45,
        ProcessMemoryAllocationMode                 = 46,
        ProcessGroupInformation                     = 47,
        ProcessTokenVirtualizationEnabled           = 48,
        ProcessOwnerInformation                     = 49,
        ProcessWindowInformation                    = 50,
        ProcessHandleInformation                    = 51,
        ProcessMitigationPolicy                     = 52,
        ProcessDynamicFunctionTableInformation      = 53,
        ProcessHandleCheckingMode                   = 54,
        ProcessKeepAliveCount                       = 55,
        ProcessRevokeFileHandles                    = 56,
        ProcessWorkingSetControl                    = 57,
        ProcessHandleTable                          = 58,
        ProcessCheckStackExtentsMode                = 59,
        ProcessCommandLineInformation               = 60,
        ProcessProtectionInformation                = 61,
        ProcessMemoryExhaustion                     = 62,
        ProcessFaultInformation                     = 63,
        ProcessTelemetryIdInformation               = 64,
        ProcessCommitReleaseInformation             = 65,
        ProcessDefaultCpuSetsInformation            = 66,
        ProcessAllowedCpuSetsInformation            = 67,
        ProcessSubsystemProcess                     = 68,
        ProcessJobMemoryInformation                 = 69,
        ProcessInPrivate                            = 70,
        ProcessRaiseUMExceptionOnInvalidHandleClose = 71,
        ProcessIumChallengeResponse                 = 72,
        ProcessChildProcessInformation              = 73,
        ProcessHighGraphicsPriorityInformation      = 74,
        ProcessSubsystemInformation                 = 75,
        ProcessEnergyValues                         = 76,
        ProcessActivityThrottleState                = 77,
        ProcessActivityThrottlePolicy               = 78,
        ProcessWin32kSyscallFilterInformation       = 79,
        ProcessDisableSystemAllowedCpuSets          = 80,
        ProcessWakeInformation                      = 81,
        ProcessEnergyTrackingState                  = 82,
        ProcessManageWritesToExecutableMemory       = 83,
        ProcessCaptureTrustletLiveDump              = 84,
        ProcessTelemetryCoverage                    = 85,
        ProcessEnclaveInformation                   = 86,
        ProcessEnableReadWriteVmLogging             = 87,
        ProcessUptimeInformation                    = 88,
        ProcessImageSection                         = 89,
        ProcessDebugAuthInformation                 = 90,
        ProcessSystemResourceManagement             = 91,
        ProcessSequenceNumber                       = 92,
        ProcessLoaderDetour                         = 93,
        ProcessSecurityDomainInformation            = 94,
        ProcessCombineSecurityDomainsInformation    = 95,
        ProcessEnableLogging                        = 96,
        ProcessLeapSecondInformation                = 97,
        ProcessFiberShadowStackAllocation           = 98,
        ProcessFreeFiberShadowStackAllocation       = 99,
        MaxProcessInfoClass
    } PROCESSINFOCLASS;

    typedef enum _THREADINFOCLASS
    {
        ThreadBasicInformation,
        ThreadTimes,
        ThreadPriority,
        ThreadBasePriority,
        ThreadAffinityMask,
        ThreadImpersonationToken,
        ThreadDescriptorTableEntry,
        ThreadEnableAlignmentFaultFixup,
        ThreadEventPair,
        ThreadQuerySetWin32StartAddress,
        ThreadZeroTlsCell,
        ThreadPerformanceCount,
        ThreadAmILastThread,
        ThreadIdealProcessor,
        ThreadPriorityBoost,
        ThreadSetTlsArrayAddress,
        ThreadIsIoPending,
        ThreadHideFromDebugger,
        ThreadBreakOnTermination,
        ThreadSwitchLegacyState,
        ThreadIsTerminated,
        ThreadLastSystemCall,
        ThreadIoPriority,
        ThreadCycleTime,
        ThreadPagePriority,
        ThreadActualBasePriority,
        ThreadTebInformation,
        ThreadCSwitchMon,
        ThreadCSwitchPmu,
        ThreadWow64Context,
        ThreadGroupInformation,
        ThreadUmsInformation,
        ThreadCounterProfiling,
        ThreadIdealProcessorEx,
        ThreadCpuAccountingInformation,
        ThreadSuspendCount,
        ThreadHeterogeneousCpuPolicy,
        ThreadContainerId,
        ThreadNameInformation,
        ThreadSelectedCpuSets,
        ThreadSystemThreadInformation,
        ThreadActualGroupAffinity,
        ThreadDynamicCodePolicyInfo,
        ThreadExplicitCaseSensitivity,
        ThreadWorkOnBehalfTicket,
        ThreadSubsystemInformation,
        ThreadDbgkWerReportActive,
        ThreadAttachContainer,
        ThreadManageWritesToExecutableMemory,
        ThreadPowerThrottlingState,
        ThreadWorkloadClass,
        MaxThreadInfoClass
    } THREADINFOCLASS;

    typedef struct _PROCESS_BASIC_INFORMATION
    {
        NTSTATUS ExitStatus;
        PVOID PebBaseAddress;
        ULONG_PTR AffinityMask;
        KPRIORITY BasePriority;
        ULONG_PTR UniqueProcessId;
        ULONG_PTR InheritedFromUniqueProcessId;
    } PROCESS_BASIC_INFORMATION, *PPROCESS_BASIC_INFORMATION;

    typedef struct _THREAD_BASIC_INFORMATION
    {
        NTSTATUS ExitStatus;
        PVOID TebBaseAddress;
        CLIENT_ID ClientId;
        ULONG_PTR AffinityMask;
        KPRIORITY Priority;
        LONG BasePriority;
    } THREAD_BASIC_INFORMATION, *PTHREAD_BASIC_INFORMATION;

    typedef struct _PROCESS_EXTENDED_BASIC_INFORMATION
    {
        SIZE_T Size;
        PROCESS_BASIC_INFORMATION BasicInfo;
        union
        {
            ULONG Flags;
            struct
            {
                ULONG IsProtectedProcess   : 1;
                ULONG IsWow64Process       : 1;
                ULONG IsProcessDeleting    : 1;
                ULONG IsCrossSessionCreate : 1;
                ULONG IsFrozen             : 1;
                ULONG IsBackground         : 1;
                ULONG IsStronglyNamed      : 1;
                ULONG IsSecureProcess      : 1;
                ULONG IsSubsystemProcess   : 1;
                ULONG SpareBits            : 23;
            } DUMMYSTRUCTNAME;
        } DUMMYUNIONNAME;
    } PROCESS_EXTENDED_BASIC_INFORMATION, *PPROCESS_EXTENDED_BASIC_INFORMATION;

    typedef struct _PROCESS_ACCESS_TOKEN
    {
        HANDLE Token;
        HANDLE Thread;
    } PROCESS_ACCESS_TOKEN, *PPROCESS_ACCESS_TOKEN;

    typedef struct _PROCESS_HANDLE_TABLE_ENTRY_INFO
    {
        HANDLE HandleValue;
        ULONG_PTR HandleCount;
        ULONG_PTR PointerCount;
        ULONG GrantedAccess;
        ULONG ObjectTypeIndex;
        ULONG HandleAttributes;
        ULONG Reserved;
    } PROCESS_HANDLE_TABLE_ENTRY_INFO, *PPROCESS_HANDLE_TABLE_ENTRY_INFO;

    typedef struct _PROCESS_HANDLE_SNAPSHOT_INFORMATION
    {
        ULONG NumberOfHandles;
        ULONG Reserved;
        PROCESS_HANDLE_TABLE_ENTRY_INFO Handles[1];
    } PROCESS_HANDLE_SNAPSHOT_INFORMATION, *PPROCESS_HANDLE_SNAPSHOT_INFORMATION;

    //
    // Process/Thread System and User Time
    //  NtQueryInformationProcess using ProcessTimes
    //  NtQueryInformationThread using ThreadTimes
    //
    typedef struct _KERNEL_USER_TIMES
    {
        LARGE_INTEGER CreateTime;
        LARGE_INTEGER ExitTime;
        LARGE_INTEGER KernelTime;
        LARGE_INTEGER UserTime;
    } KERNEL_USER_TIMES, *PKERNEL_USER_TIMES;

    typedef enum _PS_MITIGATION_OPTION
    {
        PS_MITIGATION_OPTION_NX,
        PS_MITIGATION_OPTION_SEHOP,
        PS_MITIGATION_OPTION_FORCE_RELOCATE_IMAGES,
        PS_MITIGATION_OPTION_HEAP_TERMINATE,
        PS_MITIGATION_OPTION_BOTTOM_UP_ASLR,
        PS_MITIGATION_OPTION_HIGH_ENTROPY_ASLR,
        PS_MITIGATION_OPTION_STRICT_HANDLE_CHECKS,
        PS_MITIGATION_OPTION_WIN32K_SYSTEM_CALL_DISABLE,
        PS_MITIGATION_OPTION_EXTENSION_POINT_DISABLE,
        PS_MITIGATION_OPTION_PROHIBIT_DYNAMIC_CODE,
        PS_MITIGATION_OPTION_CONTROL_FLOW_GUARD,
        PS_MITIGATION_OPTION_BLOCK_NON_MICROSOFT_BINARIES,
        PS_MITIGATION_OPTION_FONT_DISABLE,
        PS_MITIGATION_OPTION_IMAGE_LOAD_NO_REMOTE,
        PS_MITIGATION_OPTION_IMAGE_LOAD_NO_LOW_LABEL,
        PS_MITIGATION_OPTION_IMAGE_LOAD_PREFER_SYSTEM32,
        PS_MITIGATION_OPTION_RETURN_FLOW_GUARD,
        PS_MITIGATION_OPTION_LOADER_INTEGRITY_CONTINUITY,
        PS_MITIGATION_OPTION_STRICT_CONTROL_FLOW_GUARD,
        PS_MITIGATION_OPTION_RESTRICT_SET_THREAD_CONTEXT,
        PS_MITIGATION_OPTION_ROP_STACKPIVOT,
        PS_MITIGATION_OPTION_ROP_CALLER_CHECK,
        PS_MITIGATION_OPTION_ROP_SIMEXEC,
        PS_MITIGATION_OPTION_EXPORT_ADDRESS_FILTER,
        PS_MITIGATION_OPTION_EXPORT_ADDRESS_FILTER_PLUS,
        PS_MITIGATION_OPTION_RESTRICT_CHILD_PROCESS_CREATION,
        PS_MITIGATION_OPTION_IMPORT_ADDRESS_FILTER,
        PS_MITIGATION_OPTION_MODULE_TAMPERING_PROTECTION,
        PS_MITIGATION_OPTION_RESTRICT_INDIRECT_BRANCH_PREDICTION,
        PS_MITIGATION_OPTION_SPECULATIVE_STORE_BYPASS_DISABLE,
        PS_MITIGATION_OPTION_ALLOW_DOWNGRADE_DYNAMIC_CODE_POLICY,
        PS_MITIGATION_OPTION_CET_SHADOW_STACKS
    } PS_MITIGATION_OPTION;

    typedef enum _PS_CREATE_STATE
    {
        PsCreateInitialState,
        PsCreateFailOnFileOpen,
        PsCreateFailOnSectionCreate,
        PsCreateFailExeFormat,
        PsCreateFailMachineMismatch,
        PsCreateFailExeName,
        PsCreateSuccess,
        PsCreateMaximumStates
    } PS_CREATE_STATE;

    typedef struct _PS_CREATE_INFO
    {
        SIZE_T Size;
        PS_CREATE_STATE State;
        union
        {
            struct
            {
                union
                {
                    ULONG InitFlags;
                    struct
                    {
                        UCHAR WriteOutputOnExit               : 1;
                        UCHAR DetectManifest                  : 1;
                        UCHAR IFEOSkipDebugger                : 1;
                        UCHAR IFEODoNotPropagateKeyState      : 1;
                        UCHAR SpareBits1                      : 4;
                        UCHAR SpareBits2                      : 8;
                        USHORT ProhibitedImageCharacteristics : 16;
                    };
                };
                ACCESS_MASK AdditionalFileAccess;
            } InitState;

            struct
            {
                HANDLE FileHandle;
            } FailSection;

            struct
            {
                USHORT DllCharacteristics;
            } ExeFormat;

            struct
            {
                HANDLE IFEOKey;
            } ExeName;

            struct
            {
                union
                {
                    ULONG OutputFlags;
                    struct
                    {
                        UCHAR ProtectedProcess      : 1;
                        UCHAR AddressSpaceOverride  : 1;
                        UCHAR DevOverrideEnabled    : 1;
                        UCHAR ManifestDetected      : 1;
                        UCHAR ProtectedProcessLight : 1;
                        UCHAR SpareBits1            : 3;
                        UCHAR SpareBits2            : 8;
                        USHORT SpareBits3           : 16;
                    };
                };
                HANDLE FileHandle;
                HANDLE SectionHandle;
                ULONGLONG UserProcessParametersNative;
                ULONG UserProcessParametersWow64;
                ULONG CurrentParameterFlags;
                ULONGLONG PebAddressNative;
                ULONG PebAddressWow64;
                ULONGLONG ManifestAddress;
                ULONG ManifestSize;
            } SuccessState;
        };
    } PS_CREATE_INFO, *PPS_CREATE_INFO;

    typedef struct _PS_ATTRIBUTE
    {
        ULONG Attribute;
        SIZE_T Size;
        union
        {
            ULONG Value;
            PVOID ValuePtr;
        };
        PSIZE_T ReturnLength;
    } PS_ATTRIBUTE, *PPS_ATTRIBUTE;

    typedef struct _PS_ATTRIBUTE_LIST
    {
        SIZE_T TotalLength;
        PS_ATTRIBUTE Attributes[1];
    } PS_ATTRIBUTE_LIST, *PPS_ATTRIBUTE_LIST;

    typedef enum _PS_PROTECTED_TYPE
    {
        PsProtectedTypeNone,
        PsProtectedTypeProtectedLight,
        PsProtectedTypeProtected,
        PsProtectedTypeMax
    } PS_PROTECTED_TYPE;

    typedef enum _PS_PROTECTED_SIGNER
    {
        PsProtectedSignerNone,
        PsProtectedSignerAuthenticode,
        PsProtectedSignerCodeGen,
        PsProtectedSignerAntimalware,
        PsProtectedSignerLsa,
        PsProtectedSignerWindows,
        PsProtectedSignerWinTcb,
        PsProtectedSignerWinSystem,
        PsProtectedSignerApp,
        PsProtectedSignerMax
    } PS_PROTECTED_SIGNER;

    typedef struct _PS_PROTECTION
    {
        union
        {
            UCHAR Level;
            struct
            {
                UCHAR Type   : 3;
                UCHAR Audit  : 1;
                UCHAR Signer : 4;
            };
        };
    } PS_PROTECTION, *PPS_PROTECTION;

    // begin_rev
#define PS_ATTRIBUTE_NUMBER_MASK 0x0000ffff
#define PS_ATTRIBUTE_THREAD 0x00010000
#define PS_ATTRIBUTE_INPUT 0x00020000
#define PS_ATTRIBUTE_ADDITIVE 0x00040000
    // end_rev

    typedef enum _PS_ATTRIBUTE_NUM
    {
        PsAttributeParentProcess,
        PsAttributeDebugPort,
        PsAttributeToken,
        PsAttributeClientId,
        PsAttributeTebAddress,
        PsAttributeImageName,
        PsAttributeImageInfo,
        PsAttributeMemoryReserve,
        PsAttributePriorityClass,
        PsAttributeErrorMode,
        PsAttributeStdHandleInfo,
        PsAttributeHandleList,
        PsAttributeGroupAffinity,
        PsAttributePreferredNode,
        PsAttributeIdealProcessor,
        PsAttributeUmsThread,
        PsAttributeMitigationOptions,
        PsAttributeProtectionLevel,
        PsAttributeSecureProcess,
        PsAttributeJobList,
        PsAttributeChildProcessPolicy,
        PsAttributeAllApplicationPackagesPolicy,
        PsAttributeWin32kFilter,
        PsAttributeSafeOpenPromptOriginClaim,
        PsAttributeBnoIsolation,
        PsAttributeDesktopAppPolicy,
        PsAttributeChpe,
        PsAttributeMax
    } PS_ATTRIBUTE_NUM;

#define PsAttributeValue(Number, Thread, Input, Unknown)                                                               \
    (((Number)&PS_ATTRIBUTE_NUMBER_MASK) | ((Thread) ? PS_ATTRIBUTE_THREAD : 0) | ((Input) ? PS_ATTRIBUTE_INPUT : 0) | \
     ((Unknown) ? PS_ATTRIBUTE_ADDITIVE : 0))

#define PS_ATTRIBUTE_PARENT_PROCESS PsAttributeValue(PsAttributeParentProcess, FALSE, TRUE, TRUE)
#define PS_ATTRIBUTE_DEBUG_PORT PsAttributeValue(PsAttributeDebugPort, FALSE, TRUE, TRUE)
#define PS_ATTRIBUTE_TOKEN PsAttributeValue(PsAttributeToken, FALSE, TRUE, TRUE)
#define PS_ATTRIBUTE_CLIENT_ID PsAttributeValue(PsAttributeClientId, TRUE, FALSE, FALSE)
#define PS_ATTRIBUTE_TEB_ADDRESS PsAttributeValue(PsAttributeTebAddress, TRUE, FALSE, FALSE)
#define PS_ATTRIBUTE_IMAGE_NAME PsAttributeValue(PsAttributeImageName, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_IMAGE_INFO PsAttributeValue(PsAttributeImageInfo, FALSE, FALSE, FALSE)
#define PS_ATTRIBUTE_MEMORY_RESERVE PsAttributeValue(PsAttributeMemoryReserve, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_PRIORITY_CLASS PsAttributeValue(PsAttributePriorityClass, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_ERROR_MODE PsAttributeValue(PsAttributeErrorMode, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_STD_HANDLE_INFO PsAttributeValue(PsAttributeStdHandleInfo, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_HANDLE_LIST PsAttributeValue(PsAttributeHandleList, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_GROUP_AFFINITY PsAttributeValue(PsAttributeGroupAffinity, TRUE, TRUE, FALSE)
#define PS_ATTRIBUTE_PREFERRED_NODE PsAttributeValue(PsAttributePreferredNode, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_IDEAL_PROCESSOR PsAttributeValue(PsAttributeIdealProcessor, TRUE, TRUE, FALSE)
#define PS_ATTRIBUTE_UMS_THREAD PsAttributeValue(PsAttributeUmsThread, TRUE, TRUE, FALSE)
#define PS_ATTRIBUTE_MITIGATION_OPTIONS PsAttributeValue(PsAttributeMitigationOptions, FALSE, TRUE, TRUE)
#define PS_ATTRIBUTE_PROTECTION_LEVEL PsAttributeValue(PsAttributeProtectionLevel, FALSE, TRUE, TRUE)
#define PS_ATTRIBUTE_SECURE_PROCESS PsAttributeValue(PsAttributeSecureProcess, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_JOB_LIST PsAttributeValue(PsAttributeJobList, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_CHILD_PROCESS_POLICY PsAttributeValue(PsAttributeChildProcessPolicy, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_ALL_APPLICATION_PACKAGES_POLICY                                                                   \
    PsAttributeValue(PsAttributeAllApplicationPackagesPolicy, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_WIN32K_FILTER PsAttributeValue(PsAttributeWin32kFilter, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_SAFE_OPEN_PROMPT_ORIGIN_CLAIM                                                                     \
    PsAttributeValue(PsAttributeSafeOpenPromptOriginClaim, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_BNO_ISOLATION PsAttributeValue(PsAttributeBnoIsolation, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_DESKTOP_APP_POLICY PsAttributeValue(PsAttributeDesktopAppPolicy, FALSE, TRUE, FALSE)

#define RTL_USER_PROC_PARAMS_NORMALIZED 0x00000001
#define RTL_USER_PROC_PROFILE_USER 0x00000002
#define RTL_USER_PROC_PROFILE_KERNEL 0x00000004
#define RTL_USER_PROC_PROFILE_SERVER 0x00000008
#define RTL_USER_PROC_RESERVE_1MB 0x00000020
#define RTL_USER_PROC_RESERVE_16MB 0x00000040
#define RTL_USER_PROC_CASE_SENSITIVE 0x00000080
#define RTL_USER_PROC_DISABLE_HEAP_DECOMMIT 0x00000100
#define RTL_USER_PROC_DLL_REDIRECTION_LOCAL 0x00001000
#define RTL_USER_PROC_APP_MANIFEST_PRESENT 0x00002000
#define RTL_USER_PROC_IMAGE_KEY_MISSING 0x00004000
#define RTL_USER_PROC_OPTIN_PROCESS 0x00020000

    /*
    ** Processes END
    */

    typedef enum _SYSTEM_INFORMATION_CLASS
    {
        SystemBasicInformation                                = 0,
        SystemProcessorInformation                            = 1,
        SystemPerformanceInformation                          = 2,
        SystemTimeOfDayInformation                            = 3,
        SystemPathInformation                                 = 4,
        SystemProcessInformation                              = 5,
        SystemCallCountInformation                            = 6,
        SystemDeviceInformation                               = 7,
        SystemProcessorPerformanceInformation                 = 8,
        SystemFlagsInformation                                = 9,
        SystemCallTimeInformation                             = 10,
        SystemModuleInformation                               = 11,
        SystemLocksInformation                                = 12,
        SystemStackTraceInformation                           = 13,
        SystemPagedPoolInformation                            = 14,
        SystemNonPagedPoolInformation                         = 15,
        SystemHandleInformation                               = 16,
        SystemObjectInformation                               = 17,
        SystemPageFileInformation                             = 18,
        SystemVdmInstemulInformation                          = 19,
        SystemVdmBopInformation                               = 20,
        SystemFileCacheInformation                            = 21,
        SystemPoolTagInformation                              = 22,
        SystemInterruptInformation                            = 23,
        SystemDpcBehaviorInformation                          = 24,
        SystemFullMemoryInformation                           = 25,
        SystemLoadGdiDriverInformation                        = 26,
        SystemUnloadGdiDriverInformation                      = 27,
        SystemTimeAdjustmentInformation                       = 28,
        SystemSummaryMemoryInformation                        = 29,
        SystemMirrorMemoryInformation                         = 30,
        SystemPerformanceTraceInformation                     = 31,
        SystemObsolete0                                       = 32,
        SystemExceptionInformation                            = 33,
        SystemCrashDumpStateInformation                       = 34,
        SystemKernelDebuggerInformation                       = 35,
        SystemContextSwitchInformation                        = 36,
        SystemRegistryQuotaInformation                        = 37,
        SystemExtendServiceTableInformation                   = 38,
        SystemPrioritySeperation                              = 39,
        SystemVerifierAddDriverInformation                    = 40,
        SystemVerifierRemoveDriverInformation                 = 41,
        SystemProcessorIdleInformation                        = 42,
        SystemLegacyDriverInformation                         = 43,
        SystemCurrentTimeZoneInformation                      = 44,
        SystemLookasideInformation                            = 45,
        SystemTimeSlipNotification                            = 46,
        SystemSessionCreate                                   = 47,
        SystemSessionDetach                                   = 48,
        SystemSessionInformation                              = 49,
        SystemRangeStartInformation                           = 50,
        SystemVerifierInformation                             = 51,
        SystemVerifierThunkExtend                             = 52,
        SystemSessionProcessInformation                       = 53,
        SystemLoadGdiDriverInSystemSpace                      = 54,
        SystemNumaProcessorMap                                = 55,
        SystemPrefetcherInformation                           = 56,
        SystemExtendedProcessInformation                      = 57,
        SystemRecommendedSharedDataAlignment                  = 58,
        SystemComPlusPackage                                  = 59,
        SystemNumaAvailableMemory                             = 60,
        SystemProcessorPowerInformation                       = 61,
        SystemEmulationBasicInformation                       = 62,
        SystemEmulationProcessorInformation                   = 63,
        SystemExtendedHandleInformation                       = 64,
        SystemLostDelayedWriteInformation                     = 65,
        SystemBigPoolInformation                              = 66,
        SystemSessionPoolTagInformation                       = 67,
        SystemSessionMappedViewInformation                    = 68,
        SystemHotpatchInformation                             = 69,
        SystemObjectSecurityMode                              = 70,
        SystemWatchdogTimerHandler                            = 71,
        SystemWatchdogTimerInformation                        = 72,
        SystemLogicalProcessorInformation                     = 73,
        SystemWow64SharedInformationObsolete                  = 74,
        SystemRegisterFirmwareTableInformationHandler         = 75,
        SystemFirmwareTableInformation                        = 76,
        SystemModuleInformationEx                             = 77,
        SystemVerifierTriageInformation                       = 78,
        SystemSuperfetchInformation                           = 79,
        SystemMemoryListInformation                           = 80,
        SystemFileCacheInformationEx                          = 81,
        SystemThreadPriorityClientIdInformation               = 82,
        SystemProcessorIdleCycleTimeInformation               = 83,
        SystemVerifierCancellationInformation                 = 84,
        SystemProcessorPowerInformationEx                     = 85,
        SystemRefTraceInformation                             = 86,
        SystemSpecialPoolInformation                          = 87,
        SystemProcessIdInformation                            = 88,
        SystemErrorPortInformation                            = 89,
        SystemBootEnvironmentInformation                      = 90,
        SystemHypervisorInformation                           = 91,
        SystemVerifierInformationEx                           = 92,
        SystemTimeZoneInformation                             = 93,
        SystemImageFileExecutionOptionsInformation            = 94,
        SystemCoverageInformation                             = 95,
        SystemPrefetchPatchInformation                        = 96,
        SystemVerifierFaultsInformation                       = 97,
        SystemSystemPartitionInformation                      = 98,
        SystemSystemDiskInformation                           = 99,
        SystemProcessorPerformanceDistribution                = 100,
        SystemNumaProximityNodeInformation                    = 101,
        SystemDynamicTimeZoneInformation                      = 102,
        SystemCodeIntegrityInformation                        = 103,
        SystemProcessorMicrocodeUpdateInformation             = 104,
        SystemProcessorBrandString                            = 105,
        SystemVirtualAddressInformation                       = 106,
        SystemLogicalProcessorAndGroupInformation             = 107,
        SystemProcessorCycleTimeInformation                   = 108,
        SystemStoreInformation                                = 109,
        SystemRegistryAppendString                            = 110,
        SystemAitSamplingValue                                = 111,
        SystemVhdBootInformation                              = 112,
        SystemCpuQuotaInformation                             = 113,
        SystemNativeBasicInformation                          = 114,
        SystemErrorPortTimeouts                               = 115,
        SystemLowPriorityIoInformation                        = 116,
        SystemBootEntropyInformation                          = 117,
        SystemVerifierCountersInformation                     = 118,
        SystemPagedPoolInformationEx                          = 119,
        SystemSystemPtesInformationEx                         = 120,
        SystemNodeDistanceInformation                         = 121,
        SystemAcpiAuditInformation                            = 122,
        SystemBasicPerformanceInformation                     = 123,
        SystemQueryPerformanceCounterInformation              = 124,
        SystemSessionBigPoolInformation                       = 125,
        SystemBootGraphicsInformation                         = 126,
        SystemScrubPhysicalMemoryInformation                  = 127,
        SystemBadPageInformation                              = 128,
        SystemProcessorProfileControlArea                     = 129,
        SystemCombinePhysicalMemoryInformation                = 130,
        SystemEntropyInterruptTimingInformation               = 131,
        SystemConsoleInformation                              = 132,
        SystemPlatformBinaryInformation                       = 133,
        SystemPolicyInformation                               = 134,
        SystemHypervisorProcessorCountInformation             = 135,
        SystemDeviceDataInformation                           = 136,
        SystemDeviceDataEnumerationInformation                = 137,
        SystemMemoryTopologyInformation                       = 138,
        SystemMemoryChannelInformation                        = 139,
        SystemBootLogoInformation                             = 140,
        SystemProcessorPerformanceInformationEx               = 141,
        SystemSpare0                                          = 142,
        SystemSecureBootPolicyInformation                     = 143,
        SystemPageFileInformationEx                           = 144,
        SystemSecureBootInformation                           = 145,
        SystemEntropyInterruptTimingRawInformation            = 146,
        SystemPortableWorkspaceEfiLauncherInformation         = 147,
        SystemFullProcessInformation                          = 148,
        SystemKernelDebuggerInformationEx                     = 149,
        SystemBootMetadataInformation                         = 150,
        SystemSoftRebootInformation                           = 151,
        SystemElamCertificateInformation                      = 152,
        SystemOfflineDumpConfigInformation                    = 153,
        SystemProcessorFeaturesInformation                    = 154,
        SystemRegistryReconciliationInformation               = 155,
        SystemEdidInformation                                 = 156,
        SystemManufacturingInformation                        = 157,
        SystemEnergyEstimationConfigInformation               = 158,
        SystemHypervisorDetailInformation                     = 159,
        SystemProcessorCycleStatsInformation                  = 160,
        SystemVmGenerationCountInformation                    = 161,
        SystemTrustedPlatformModuleInformation                = 162,
        SystemKernelDebuggerFlags                             = 163,
        SystemCodeIntegrityPolicyInformation                  = 164,
        SystemIsolatedUserModeInformation                     = 165,
        SystemHardwareSecurityTestInterfaceResultsInformation = 166,
        SystemSingleModuleInformation                         = 167,
        SystemAllowedCpuSetsInformation                       = 168,
        SystemDmaProtectionInformation                        = 169,
        SystemInterruptCpuSetsInformation                     = 170,
        SystemSecureBootPolicyFullInformation                 = 171,
        SystemCodeIntegrityPolicyFullInformation              = 172,
        SystemAffinitizedInterruptProcessorInformation        = 173,
        SystemRootSiloInformation                             = 174,
        SystemCpuSetInformation                               = 175,
        SystemCpuSetTagInformation                            = 176,
        SystemWin32WerStartCallout                            = 177,
        SystemSecureKernelProfileInformation                  = 178,
        SystemCodeIntegrityPlatformManifestInformation        = 179,
        SystemInterruptSteeringInformation                    = 180,
        SystemSupportedProcessorArchitectures                 = 181,
        SystemMemoryUsageInformation                          = 182,
        SystemCodeIntegrityCertificateInformation             = 183,
        SystemPhysicalMemoryInformation                       = 184,
        SystemControlFlowTransition                           = 185,
        SystemKernelDebuggingAllowed                          = 186,
        SystemActivityModerationExeState                      = 187,
        SystemActivityModerationUserSettings                  = 188,
        SystemCodeIntegrityPoliciesFullInformation            = 189,
        SystemCodeIntegrityUnlockInformation                  = 190,
        SystemIntegrityQuotaInformation                       = 191,
        SystemFlushInformation                                = 192,
        SystemProcessorIdleMaskInformation                    = 193,
        SystemSecureDumpEncryptionInformation                 = 194,
        SystemWriteConstraintInformation                      = 195,
        SystemKernelVaShadowInformation                       = 196,
        SystemHypervisorSharedPageInformation                 = 197,
        SystemFirmwareBootPerformanceInformation              = 198,
        SystemCodeIntegrityVerificationInformation            = 199,
        SystemFirmwarePartitionInformation                    = 200,
        SystemSpeculationControlInformation                   = 201,
        SystemDmaGuardPolicyInformation                       = 202,
        SystemEnclaveLaunchControlInformation                 = 203,
        SystemWorkloadAllowedCpuSetsInformation               = 204,
        SystemCodeIntegrityUnlockModeInformation              = 205,
        SystemLeapSecondInformation                           = 206,
        SystemFlags2Information                               = 207,
        SystemSecurityModelInformation                        = 208,
        SystemCodeIntegritySyntheticCacheInformation          = 209,
        MaxSystemInfoClass
    } SYSTEM_INFORMATION_CLASS, *PSYSTEM_INFORMATION_CLASS;

    // msdn.microsoft.com/en-us/library/windows/desktop/ms724509(v=vs.85).aspx
    typedef struct _SYSTEM_SPECULATION_CONTROL_INFORMATION
    {
        struct
        {
            ULONG BpbEnabled                               : 1;
            ULONG BpbDisabledSystemPolicy                  : 1;
            ULONG BpbDisabledNoHardwareSupport             : 1;
            ULONG SpecCtrlEnumerated                       : 1;
            ULONG SpecCmdEnumerated                        : 1;
            ULONG IbrsPresent                              : 1;
            ULONG StibpPresent                             : 1;
            ULONG SmepPresent                              : 1;
            ULONG SpeculativeStoreBypassDisableAvailable   : 1;
            ULONG SpeculativeStoreBypassDisableSupported   : 1;
            ULONG SpeculativeStoreBypassDisabledSystemWide : 1;
            ULONG SpeculativeStoreBypassDisabledKernel     : 1;
            ULONG SpeculativeStoreBypassDisableRequired    : 1;
            ULONG BpbDisabledKernelToUser                  : 1;
            ULONG SpecCtrlRetpolineEnabled                 : 1;
            ULONG SpecCtrlImportOptimizationEnabled        : 1;
            ULONG EnhancedIbrs                             : 1;
            ULONG HvL1tfStatusAvailable                    : 1;
            ULONG HvL1tfProcessorNotAffected               : 1;
            ULONG HvL1tfMigitationEnabled                  : 1;
            ULONG HvL1tfMigitationNotEnabled_Hardware      : 1;
            ULONG HvL1tfMigitationNotEnabled_LoadOption    : 1;
            ULONG HvL1tfMigitationNotEnabled_CoreScheduler : 1;
            ULONG EnhancedIbrsReported                     : 1;
            ULONG Reserved                                 : 8;
        } SpeculationControlFlags;
    } SYSTEM_SPECULATION_CONTROL_INFORMATION, *PSYSTEM_SPECULATION_CONTROL_INFORMATION;

    typedef struct _SYSTEM_KERNEL_VA_SHADOW_INFORMATION
    {
        struct
        {
            ULONG KvaShadowEnabled                 : 1;
            ULONG KvaShadowUserGlobal              : 1;
            ULONG KvaShadowPcid                    : 1;
            ULONG KvaShadowInvpcid                 : 1;
            ULONG KvaShadowRequired                : 1;
            ULONG KvaShadowRequiredAvailable       : 1;
            ULONG InvalidPteBit                    : 6;
            ULONG L1DataCacheFlushSupported        : 1;
            ULONG L1TerminalFaultMitigationPresent : 1;
            ULONG Reserved                         : 18;
        } KvaShadowFlags;
    } SYSTEM_KERNEL_VA_SHADOW_INFORMATION, *PSYSTEM_KERNEL_VA_SHADOW_INFORMATION;

    typedef struct _SYSTEM_CODEINTEGRITY_INFORMATION
    {
        ULONG Length;
        ULONG CodeIntegrityOptions;
    } SYSTEM_CODEINTEGRITY_INFORMATION, *PSYSTEM_CODEINTEGRITY_INFORMATION;

#define CODEINTEGRITY_OPTION_ENABLED 0x01
#define CODEINTEGRITY_OPTION_TESTSIGN 0x02
#define CODEINTEGRITY_OPTION_UMCI_ENABLED 0x04
#define CODEINTEGRITY_OPTION_UMCI_AUDITMODE_ENABLED 0x08
#define CODEINTEGRITY_OPTION_UMCI_EXCLUSIONPATHS_ENABLED 0x10
#define CODEINTEGRITY_OPTION_TEST_BUILD 0x20
#define CODEINTEGRITY_OPTION_PREPRODUCTION_BUILD 0x40
#define CODEINTEGRITY_OPTION_DEBUGMODE_ENABLED 0x80
#define CODEINTEGRITY_OPTION_FLIGHT_BUILD 0x100
#define CODEINTEGRITY_OPTION_FLIGHTING_ENABLED 0x200
#define CODEINTEGRITY_OPTION_HVCI_KMCI_ENABLED 0x400
#define CODEINTEGRITY_OPTION_HVCI_KMCI_AUDITMODE_ENABLED 0x800
#define CODEINTEGRITY_OPTION_HVCI_KMCI_STRICTMODE_ENABLED 0x1000
#define CODEINTEGRITY_OPTION_HVCI_IUM_ENABLED 0x2000

    typedef VOID(
        NTAPI* PIO_APC_ROUTINE)(_In_ PVOID ApcContext, _In_ PIO_STATUS_BLOCK IoStatusBlock, _In_ ULONG Reserved);

#define InitializeObjectAttributes(p, n, a, r, s)                                                                      \
    {                                                                                                                  \
        (p)->Length                   = sizeof(OBJECT_ATTRIBUTES);                                                     \
        (p)->RootDirectory            = r;                                                                             \
        (p)->Attributes               = a;                                                                             \
        (p)->ObjectName               = n;                                                                             \
        (p)->SecurityDescriptor       = s;                                                                             \
        (p)->SecurityQualityOfService = NULL;                                                                          \
    }

    typedef struct _SYSTEM_VHD_BOOT_INFORMATION
    {
        BOOLEAN OsDiskIsVhd;
        ULONG OsVhdFilePathOffset;
        WCHAR OsVhdParentVolume[ANYSIZE_ARRAY];
    } SYSTEM_VHD_BOOT_INFORMATION, *PSYSTEM_VHD_BOOT_INFORMATION;

    typedef struct _SYSTEM_OBJECTTYPE_INFORMATION
    {
        ULONG NextEntryOffset;
        ULONG NumberOfObjects;
        ULONG NumberOfHandles;
        ULONG TypeIndex;
        ULONG InvalidAttributes;
        GENERIC_MAPPING GenericMapping;
        ULONG ValidAccessMask;
        ULONG PoolType;
        BOOLEAN SecurityRequired;
        BOOLEAN WaitableObject;
        UNICODE_STRING TypeName;
    } SYSTEM_OBJECTTYPE_INFORMATION, *PSYSTEM_OBJECTTYPE_INFORMATION;

    typedef struct _SYSTEM_OBJECT_INFORMATION
    {
        ULONG NextEntryOffset;
        PVOID Object;
        HANDLE CreatorUniqueProcess;
        USHORT CreatorBackTraceIndex;
        USHORT Flags;
        LONG PointerCount;
        LONG HandleCount;
        ULONG PagedPoolCharge;
        ULONG NonPagedPoolCharge;
        HANDLE ExclusiveProcessId;
        PVOID SecurityDescriptor;
        UNICODE_STRING NameInfo;
    } SYSTEM_OBJECT_INFORMATION, *PSYSTEM_OBJECT_INFORMATION;

    /*
    ** Boot Entry START
    */

    typedef struct _FILE_PATH
    {
        ULONG Version;
        ULONG Length;
        ULONG Type;
        UCHAR FilePath[ANYSIZE_ARRAY];
    } FILE_PATH, *PFILE_PATH;

    typedef struct _BOOT_ENTRY
    {
        ULONG Version;
        ULONG Length;
        ULONG Id;
        ULONG Attributes;
        ULONG FriendlyNameOffset;
        ULONG BootFilePathOffset;
        ULONG OsOptionsLength;
        UCHAR OsOptions[ANYSIZE_ARRAY];
    } BOOT_ENTRY, *PBOOT_ENTRY;

    typedef struct _BOOT_ENTRY_LIST
    {
        ULONG NextEntryOffset;
        BOOT_ENTRY BootEntry;
    } BOOT_ENTRY_LIST, *PBOOT_ENTRY_LIST;

    /*
    ** Boot Entry END
    */

    /*
    ** File start
    */

#define FILE_SUPERSEDE 0x00000000
#define FILE_OPEN 0x00000001
#define FILE_CREATE 0x00000002
#define FILE_OPEN_IF 0x00000003
#define FILE_OVERWRITE 0x00000004
#define FILE_OVERWRITE_IF 0x00000005
#define FILE_MAXIMUM_DISPOSITION 0x00000005

#define FILE_DIRECTORY_FILE 0x00000001
#define FILE_WRITE_THROUGH 0x00000002
#define FILE_SEQUENTIAL_ONLY 0x00000004
#define FILE_NO_INTERMEDIATE_BUFFERING 0x00000008

#define FILE_SYNCHRONOUS_IO_ALERT 0x00000010
#define FILE_SYNCHRONOUS_IO_NONALERT 0x00000020
#define FILE_NON_DIRECTORY_FILE 0x00000040
#define FILE_CREATE_TREE_CONNECTION 0x00000080

#define FILE_COMPLETE_IF_OPLOCKED 0x00000100
#define FILE_NO_EA_KNOWLEDGE 0x00000200
#define FILE_OPEN_FOR_RECOVERY 0x00000400
#define FILE_RANDOM_ACCESS 0x00000800

#define FILE_DELETE_ON_CLOSE 0x00001000
#define FILE_OPEN_BY_FILE_ID 0x00002000
#define FILE_OPEN_FOR_BACKUP_INTENT 0x00004000
#define FILE_NO_COMPRESSION 0x00008000

#define FILE_RESERVE_OPFILTER 0x00100000
#define FILE_OPEN_REPARSE_POINT 0x00200000
#define FILE_OPEN_NO_RECALL 0x00400000
#define FILE_OPEN_FOR_FREE_SPACE_QUERY 0x00800000


#define FILE_COPY_STRUCTURED_STORAGE 0x00000041
#define FILE_STRUCTURED_STORAGE 0x00000441

#define FILE_VALID_OPTION_FLAGS 0x00ffffff
#define FILE_VALID_PIPE_OPTION_FLAGS 0x00000032
#define FILE_VALID_MAILSLOT_OPTION_FLAGS 0x00000032
#define FILE_VALID_SET_FLAGS 0x00000036

    typedef enum _FILE_INFORMATION_CLASS
    {
        FileDirectoryInformation = 1,
        FileFullDirectoryInformation,
        FileBothDirectoryInformation,
        FileBasicInformation,
        FileStandardInformation,
        FileInternalInformation,
        FileEaInformation,
        FileAccessInformation,
        FileNameInformation,
        FileRenameInformation,
        FileLinkInformation,
        FileNamesInformation,
        FileDispositionInformation,
        FilePositionInformation,
        FileFullEaInformation,
        FileModeInformation,
        FileAlignmentInformation,
        FileAllInformation,
        FileAllocationInformation,
        FileEndOfFileInformation,
        FileAlternateNameInformation,
        FileStreamInformation,
        FilePipeInformation,
        FilePipeLocalInformation,
        FilePipeRemoteInformation,
        FileMailslotQueryInformation,
        FileMailslotSetInformation,
        FileCompressionInformation,
        FileObjectIdInformation,
        FileCompletionInformation,
        FileMoveClusterInformation,
        FileQuotaInformation,
        FileReparsePointInformation,
        FileNetworkOpenInformation,
        FileAttributeTagInformation,
        FileTrackingInformation,
        FileIdBothDirectoryInformation,
        FileIdFullDirectoryInformation,
        FileValidDataLengthInformation,
        FileShortNameInformation,
        FileIoCompletionNotificationInformation,
        FileIoStatusBlockRangeInformation,
        FileIoPriorityHintInformation,
        FileSfioReserveInformation,
        FileSfioVolumeInformation,
        FileHardLinkInformation,
        FileProcessIdsUsingFileInformation,
        FileNormalizedNameInformation,
        FileNetworkPhysicalNameInformation,
        FileIdGlobalTxDirectoryInformation,
        FileIsRemoteDeviceInformation,
        FileUnusedInformation,
        FileNumaNodeInformation,
        FileStandardLinkInformation,
        FileRemoteProtocolInformation,
        FileRenameInformationBypassAccessCheck,
        FileLinkInformationBypassAccessCheck,
        FileVolumeNameInformation,
        FileIdInformation,
        FileIdExtdDirectoryInformation,
        FileReplaceCompletionInformation,
        FileHardLinkFullIdInformation,
        FileIdExtdBothDirectoryInformation,
        FileDispositionInformationEx,
        FileRenameInformationEx,
        FileRenameInformationExBypassAccessCheck,
        FileDesiredStorageClassInformation,
        FileStatInformation,
        FileMemoryPartitionInformation,
        FileStatLxInformation,
        FileCaseSensitiveInformation,
        FileLinkInformationEx,
        FileLinkInformationExBypassAccessCheck,
        FileStorageReserveIdInformation,
        FileCaseSensitiveInformationForceAccessCheck,
        FileMaximumInformation
    } FILE_INFORMATION_CLASS, *PFILE_INFORMATION_CLASS;

    typedef enum _FSINFOCLASS
    {
        FileFsVolumeInformation = 1,
        FileFsLabelInformation,
        FileFsSizeInformation,
        FileFsDeviceInformation,
        FileFsAttributeInformation,
        FileFsControlInformation,
        FileFsFullSizeInformation,
        FileFsObjectIdInformation,
        FileFsDriverPathInformation,
        FileFsVolumeFlagsInformation,
        FileFsSectorSizeInformation,
        FileFsDataCopyInformation,
        FileFsMetadataSizeInformation,
        FileFsFullSizeInformationEx,
        FileFsMaximumInformation
    } FS_INFORMATION_CLASS, *PFS_INFORMATION_CLASS;

    typedef struct _FILE_BASIC_INFORMATION
    {
        LARGE_INTEGER CreationTime;
        LARGE_INTEGER LastAccessTime;
        LARGE_INTEGER LastWriteTime;
        LARGE_INTEGER ChangeTime;
        ULONG FileAttributes;
    } FILE_BASIC_INFORMATION, *PFILE_BASIC_INFORMATION;

    typedef struct _FILE_STANDARD_INFORMATION
    {
        LARGE_INTEGER AllocationSize;
        LARGE_INTEGER EndOfFile;
        ULONG NumberOfLinks;
        UCHAR DeletePending;
        UCHAR Directory;
    } FILE_STANDARD_INFORMATION;

    typedef struct _FILE_STANDARD_INFORMATION_EX
    {
        LARGE_INTEGER AllocationSize;
        LARGE_INTEGER EndOfFile;
        ULONG NumberOfLinks;
        BOOLEAN DeletePending;
        BOOLEAN Directory;
        BOOLEAN AlternateStream;
        BOOLEAN MetadataAttribute;
    } FILE_STANDARD_INFORMATION_EX, *PFILE_STANDARD_INFORMATION_EX;

    typedef struct _FILE_INTERNAL_INFORMATION
    {
        LARGE_INTEGER IndexNumber;
    } FILE_INTERNAL_INFORMATION, *PFILE_INTERNAL_INFORMATION;

    typedef struct _FILE_EA_INFORMATION
    {
        ULONG EaSize;
    } FILE_EA_INFORMATION, *PFILE_EA_INFORMATION;

    typedef struct _FILE_ACCESS_INFORMATION
    {
        ACCESS_MASK AccessFlags;
    } FILE_ACCESS_INFORMATION, *PFILE_ACCESS_INFORMATION;

    typedef struct _FILE_POSITION_INFORMATION
    {
        LARGE_INTEGER CurrentByteOffset;
    } FILE_POSITION_INFORMATION, *PFILE_POSITION_INFORMATION;

    typedef struct _FILE_MODE_INFORMATION
    {
        ULONG Mode;
    } FILE_MODE_INFORMATION, *PFILE_MODE_INFORMATION;

    typedef struct _FILE_ALIGNMENT_INFORMATION
    {
        ULONG AlignmentRequirement;
    } FILE_ALIGNMENT_INFORMATION, *PFILE_ALIGNMENT_INFORMATION;

    typedef struct _FILE_NAME_INFORMATION
    {
        ULONG FileNameLength;
        WCHAR FileName[1];
    } FILE_NAME_INFORMATION, *PFILE_NAME_INFORMATION;

    typedef struct _FILE_ALL_INFORMATION
    {
        FILE_BASIC_INFORMATION BasicInformation;
        FILE_STANDARD_INFORMATION StandardInformation;
        FILE_INTERNAL_INFORMATION InternalInformation;
        FILE_EA_INFORMATION EaInformation;
        FILE_ACCESS_INFORMATION AccessInformation;
        FILE_POSITION_INFORMATION PositionInformation;
        FILE_MODE_INFORMATION ModeInformation;
        FILE_ALIGNMENT_INFORMATION AlignmentInformation;
        FILE_NAME_INFORMATION NameInformation;
    } FILE_ALL_INFORMATION, *PFILE_ALL_INFORMATION;

    typedef struct _FILE_NETWORK_OPEN_INFORMATION
    {
        LARGE_INTEGER CreationTime;
        LARGE_INTEGER LastAccessTime;
        LARGE_INTEGER LastWriteTime;
        LARGE_INTEGER ChangeTime;
        LARGE_INTEGER AllocationSize;
        LARGE_INTEGER EndOfFile;
        ULONG FileAttributes;
    } FILE_NETWORK_OPEN_INFORMATION, *PFILE_NETWORK_OPEN_INFORMATION;

    typedef struct _FILE_ATTRIBUTE_TAG_INFORMATION
    {
        ULONG FileAttributes;
        ULONG ReparseTag;
    } FILE_ATTRIBUTE_TAG_INFORMATION, *PFILE_ATTRIBUTE_TAG_INFORMATION;

    typedef struct _FILE_ALLOCATION_INFORMATION
    {
        LARGE_INTEGER AllocationSize;
    } FILE_ALLOCATION_INFORMATION, *PFILE_ALLOCATION_INFORMATION;

    typedef struct _FILE_COMPRESSION_INFORMATION
    {
        LARGE_INTEGER CompressedFileSize;
        USHORT CompressionFormat;
        UCHAR CompressionUnitShift;
        UCHAR ChunkShift;
        UCHAR ClusterShift;
        UCHAR Reserved[3];
    } FILE_COMPRESSION_INFORMATION, *PFILE_COMPRESSION_INFORMATION;

    typedef struct _FILE_DISPOSITION_INFORMATION
    {
        BOOLEAN DeleteFile;
    } FILE_DISPOSITION_INFORMATION, *PFILE_DISPOSITION_INFORMATION;

    typedef struct _FILE_END_OF_FILE_INFORMATION
    {
        LARGE_INTEGER EndOfFile;
    } FILE_END_OF_FILE_INFORMATION, *PFILE_END_OF_FILE_INFORMATION;

    typedef struct _FILE_VALID_DATA_LENGTH_INFORMATION
    {
        LARGE_INTEGER ValidDataLength;
    } FILE_VALID_DATA_LENGTH_INFORMATION, *PFILE_VALID_DATA_LENGTH_INFORMATION;

    typedef struct _FILE_LINK_INFORMATION
    {
        BOOLEAN ReplaceIfExists;
        HANDLE RootDirectory;
        ULONG FileNameLength;
        WCHAR FileName[1];
    } FILE_LINK_INFORMATION, *PFILE_LINK_INFORMATION;

    typedef struct _FILE_MOVE_CLUSTER_INFORMATION
    {
        ULONG ClusterCount;
        HANDLE RootDirectory;
        ULONG FileNameLength;
        WCHAR FileName[1];
    } FILE_MOVE_CLUSTER_INFORMATION, *PFILE_MOVE_CLUSTER_INFORMATION;

    typedef struct _FILE_RENAME_INFORMATION
    {
        BOOLEAN ReplaceIfExists;
        HANDLE RootDirectory;
        ULONG FileNameLength;
        WCHAR FileName[1];
    } FILE_RENAME_INFORMATION, *PFILE_RENAME_INFORMATION;

    typedef struct _FILE_STREAM_INFORMATION
    {
        ULONG NextEntryOffset;
        ULONG StreamNameLength;
        LARGE_INTEGER StreamSize;
        LARGE_INTEGER StreamAllocationSize;
        WCHAR StreamName[1];
    } FILE_STREAM_INFORMATION, *PFILE_STREAM_INFORMATION;

    typedef struct _FILE_TRACKING_INFORMATION
    {
        HANDLE DestinationFile;
        ULONG ObjectInformationLength;
        CHAR ObjectInformation[1];
    } FILE_TRACKING_INFORMATION, *PFILE_TRACKING_INFORMATION;

    typedef struct _FILE_COMPLETION_INFORMATION
    {
        HANDLE Port;
        PVOID Key;
    } FILE_COMPLETION_INFORMATION, *PFILE_COMPLETION_INFORMATION;

    //
    // Define the NamedPipeType flags for NtCreateNamedPipeFile
    //

#define FILE_PIPE_BYTE_STREAM_TYPE 0x00000000
#define FILE_PIPE_MESSAGE_TYPE 0x00000001

    //
    // Define the CompletionMode flags for NtCreateNamedPipeFile
    //

#define FILE_PIPE_QUEUE_OPERATION 0x00000000
#define FILE_PIPE_COMPLETE_OPERATION 0x00000001

    //
    // Define the ReadMode flags for NtCreateNamedPipeFile
    //

#define FILE_PIPE_BYTE_STREAM_MODE 0x00000000
#define FILE_PIPE_MESSAGE_MODE 0x00000001

    //
    // Define the NamedPipeConfiguration flags for NtQueryInformation
    //

#define FILE_PIPE_INBOUND 0x00000000
#define FILE_PIPE_OUTBOUND 0x00000001
#define FILE_PIPE_FULL_DUPLEX 0x00000002

    //
    // Define the NamedPipeState flags for NtQueryInformation
    //

#define FILE_PIPE_DISCONNECTED_STATE 0x00000001
#define FILE_PIPE_LISTENING_STATE 0x00000002
#define FILE_PIPE_CONNECTED_STATE 0x00000003
#define FILE_PIPE_CLOSING_STATE 0x00000004

    //
    // Define the NamedPipeEnd flags for NtQueryInformation
    //

#define FILE_PIPE_CLIENT_END 0x00000000
#define FILE_PIPE_SERVER_END 0x00000001


    typedef struct _FILE_PIPE_INFORMATION
    {
        ULONG ReadMode;
        ULONG CompletionMode;
    } FILE_PIPE_INFORMATION, *PFILE_PIPE_INFORMATION;

    typedef struct _FILE_PIPE_LOCAL_INFORMATION
    {
        ULONG NamedPipeType;
        ULONG NamedPipeConfiguration;
        ULONG MaximumInstances;
        ULONG CurrentInstances;
        ULONG InboundQuota;
        ULONG ReadDataAvailable;
        ULONG OutboundQuota;
        ULONG WriteQuotaAvailable;
        ULONG NamedPipeState;
        ULONG NamedPipeEnd;
    } FILE_PIPE_LOCAL_INFORMATION, *PFILE_PIPE_LOCAL_INFORMATION;

    typedef struct _FILE_PIPE_REMOTE_INFORMATION
    {
        LARGE_INTEGER CollectDataTime;
        ULONG MaximumCollectionCount;
    } FILE_PIPE_REMOTE_INFORMATION, *PFILE_PIPE_REMOTE_INFORMATION;

    typedef struct _FILE_MAILSLOT_QUERY_INFORMATION
    {
        ULONG MaximumMessageSize;
        ULONG MailslotQuota;
        ULONG NextMessageSize;
        ULONG MessagesAvailable;
        LARGE_INTEGER ReadTimeout;
    } FILE_MAILSLOT_QUERY_INFORMATION, *PFILE_MAILSLOT_QUERY_INFORMATION;

    typedef struct _FILE_MAILSLOT_SET_INFORMATION
    {
        PLARGE_INTEGER ReadTimeout;
    } FILE_MAILSLOT_SET_INFORMATION, *PFILE_MAILSLOT_SET_INFORMATION;

    typedef struct _FILE_REPARSE_POINT_INFORMATION
    {
        LONGLONG FileReference;
        ULONG Tag;
    } FILE_REPARSE_POINT_INFORMATION, *PFILE_REPARSE_POINT_INFORMATION;

    typedef struct _FILE_LINK_ENTRY_INFORMATION
    {
        ULONG NextEntryOffset;
        LONGLONG ParentFileId;
        ULONG FileNameLength;
        WCHAR FileName[1];
    } FILE_LINK_ENTRY_INFORMATION, *PFILE_LINK_ENTRY_INFORMATION;

    typedef struct _FILE_LINKS_INFORMATION
    {
        ULONG BytesNeeded;
        ULONG EntriesReturned;
        FILE_LINK_ENTRY_INFORMATION Entry;
    } FILE_LINKS_INFORMATION, *PFILE_LINKS_INFORMATION;

    typedef struct _FILE_NETWORK_PHYSICAL_NAME_INFORMATION
    {
        ULONG FileNameLength;
        WCHAR FileName[1];
    } FILE_NETWORK_PHYSICAL_NAME_INFORMATION, *PFILE_NETWORK_PHYSICAL_NAME_INFORMATION;

    typedef struct _FILE_STANDARD_LINK_INFORMATION
    {
        ULONG NumberOfAccessibleLinks;
        ULONG TotalNumberOfLinks;
        BOOLEAN DeletePending;
        BOOLEAN Directory;
    } FILE_STANDARD_LINK_INFORMATION, *PFILE_STANDARD_LINK_INFORMATION;

    typedef struct _FILE_SFIO_RESERVE_INFORMATION
    {
        ULONG RequestsPerPeriod;
        ULONG Period;
        BOOLEAN RetryFailures;
        BOOLEAN Discardable;
        ULONG RequestSize;
        ULONG NumOutstandingRequests;
    } FILE_SFIO_RESERVE_INFORMATION, *PFILE_SFIO_RESERVE_INFORMATION;

    typedef struct _FILE_SFIO_VOLUME_INFORMATION
    {
        ULONG MaximumRequestsPerPeriod;
        ULONG MinimumPeriod;
        ULONG MinimumTransferSize;
    } FILE_SFIO_VOLUME_INFORMATION, *PFILE_SFIO_VOLUME_INFORMATION;

    //
    // Define the flags for NtSet(Query)EaFile service structure entries
    //

#define FILE_NEED_EA 0x00000080

    //
    // Define EA type values
    //

#define FILE_EA_TYPE_BINARY 0xfffe
#define FILE_EA_TYPE_ASCII 0xfffd
#define FILE_EA_TYPE_BITMAP 0xfffb
#define FILE_EA_TYPE_METAFILE 0xfffa
#define FILE_EA_TYPE_ICON 0xfff9
#define FILE_EA_TYPE_EA 0xffee
#define FILE_EA_TYPE_MVMT 0xffdf
#define FILE_EA_TYPE_MVST 0xffde
#define FILE_EA_TYPE_ASN1 0xffdd
#define FILE_EA_TYPE_FAMILY_IDS 0xff01

    typedef struct _FILE_FULL_EA_INFORMATION
    {
        ULONG NextEntryOffset;
        UCHAR Flags;
        UCHAR EaNameLength;
        USHORT EaValueLength;
        CHAR EaName[1];
    } FILE_FULL_EA_INFORMATION, *PFILE_FULL_EA_INFORMATION;

    typedef struct _FILE_GET_EA_INFORMATION
    {
        ULONG NextEntryOffset;
        UCHAR EaNameLength;
        CHAR EaName[1];
    } FILE_GET_EA_INFORMATION, *PFILE_GET_EA_INFORMATION;

    typedef struct _FILE_GET_QUOTA_INFORMATION
    {
        ULONG NextEntryOffset;
        ULONG SidLength;
        SID Sid;
    } FILE_GET_QUOTA_INFORMATION, *PFILE_GET_QUOTA_INFORMATION;

    typedef struct _FILE_QUOTA_INFORMATION
    {
        ULONG NextEntryOffset;
        ULONG SidLength;
        LARGE_INTEGER ChangeTime;
        LARGE_INTEGER QuotaUsed;
        LARGE_INTEGER QuotaThreshold;
        LARGE_INTEGER QuotaLimit;
        SID Sid;
    } FILE_QUOTA_INFORMATION, *PFILE_QUOTA_INFORMATION;

    typedef struct _FILE_DIRECTORY_INFORMATION
    {
        ULONG NextEntryOffset;
        ULONG FileIndex;
        LARGE_INTEGER CreationTime;
        LARGE_INTEGER LastAccessTime;
        LARGE_INTEGER LastWriteTime;
        LARGE_INTEGER ChangeTime;
        LARGE_INTEGER EndOfFile;
        LARGE_INTEGER AllocationSize;
        ULONG FileAttributes;
        ULONG FileNameLength;
        WCHAR FileName[1];
    } FILE_DIRECTORY_INFORMATION, *PFILE_DIRECTORY_INFORMATION;

    typedef struct _FILE_FULL_DIR_INFORMATION
    {
        ULONG NextEntryOffset;
        ULONG FileIndex;
        LARGE_INTEGER CreationTime;
        LARGE_INTEGER LastAccessTime;
        LARGE_INTEGER LastWriteTime;
        LARGE_INTEGER ChangeTime;
        LARGE_INTEGER EndOfFile;
        LARGE_INTEGER AllocationSize;
        ULONG FileAttributes;
        ULONG FileNameLength;
        ULONG EaSize;
        WCHAR FileName[1];
    } FILE_FULL_DIR_INFORMATION, *PFILE_FULL_DIR_INFORMATION;

    typedef struct _FILE_ID_FULL_DIR_INFORMATION
    {
        ULONG NextEntryOffset;
        ULONG FileIndex;
        LARGE_INTEGER CreationTime;
        LARGE_INTEGER LastAccessTime;
        LARGE_INTEGER LastWriteTime;
        LARGE_INTEGER ChangeTime;
        LARGE_INTEGER EndOfFile;
        LARGE_INTEGER AllocationSize;
        ULONG FileAttributes;
        ULONG FileNameLength;
        ULONG EaSize;
        LARGE_INTEGER FileId;
        WCHAR FileName[1];
    } FILE_ID_FULL_DIR_INFORMATION, *PFILE_ID_FULL_DIR_INFORMATION;

    typedef struct _FILE_BOTH_DIR_INFORMATION
    {
        ULONG NextEntryOffset;
        ULONG FileIndex;
        LARGE_INTEGER CreationTime;
        LARGE_INTEGER LastAccessTime;
        LARGE_INTEGER LastWriteTime;
        LARGE_INTEGER ChangeTime;
        LARGE_INTEGER EndOfFile;
        LARGE_INTEGER AllocationSize;
        ULONG FileAttributes;
        ULONG FileNameLength;
        ULONG EaSize;
        CCHAR ShortNameLength;
        WCHAR ShortName[12];
        WCHAR FileName[1];
    } FILE_BOTH_DIR_INFORMATION, *PFILE_BOTH_DIR_INFORMATION;

    typedef struct _FILE_ID_BOTH_DIR_INFORMATION
    {
        ULONG NextEntryOffset;
        ULONG FileIndex;
        LARGE_INTEGER CreationTime;
        LARGE_INTEGER LastAccessTime;
        LARGE_INTEGER LastWriteTime;
        LARGE_INTEGER ChangeTime;
        LARGE_INTEGER EndOfFile;
        LARGE_INTEGER AllocationSize;
        ULONG FileAttributes;
        ULONG FileNameLength;
        ULONG EaSize;
        CCHAR ShortNameLength;
        WCHAR ShortName[12];
        LARGE_INTEGER FileId;
        WCHAR FileName[1];
    } FILE_ID_BOTH_DIR_INFORMATION, *PFILE_ID_BOTH_DIR_INFORMATION;

    typedef struct _FILE_NAMES_INFORMATION
    {
        ULONG NextEntryOffset;
        ULONG FileIndex;
        ULONG FileNameLength;
        WCHAR FileName[1];
    } FILE_NAMES_INFORMATION, *PFILE_NAMES_INFORMATION;

    typedef struct _FILE_OBJECTID_INFORMATION
    {
        LONGLONG FileReference;
        UCHAR ObjectId[16];
        union
        {
            struct
            {
                UCHAR BirthVolumeId[16];
                UCHAR BirthObjectId[16];
                UCHAR DomainId[16];
            };
            UCHAR ExtendedInfo[48];
        };
    } FILE_OBJECTID_INFORMATION, *PFILE_OBJECTID_INFORMATION;

    typedef struct _FILE_FS_VOLUME_INFORMATION
    {
        LARGE_INTEGER VolumeCreationTime;
        ULONG VolumeSerialNumber;
        ULONG VolumeLabelLength;
        BOOLEAN SupportsObjects;
        WCHAR VolumeLabel[1];
    } FILE_FS_VOLUME_INFORMATION, *PFILE_FS_VOLUME_INFORMATION;

    typedef struct _FILE_ID_GLOBAL_TX_DIR_INFORMATION
    {
        ULONG NextEntryOffset;
        ULONG FileIndex;
        LARGE_INTEGER CreationTime;
        LARGE_INTEGER LastAccessTime;
        LARGE_INTEGER LastWriteTime;
        LARGE_INTEGER ChangeTime;
        LARGE_INTEGER EndOfFile;
        LARGE_INTEGER AllocationSize;
        ULONG FileAttributes;
        ULONG FileNameLength;
        LARGE_INTEGER FileId;
        GUID LockingTransactionId;
        ULONG TxInfoFlags;
        WCHAR FileName[1];
    } FILE_ID_GLOBAL_TX_DIR_INFORMATION, *PFILE_ID_GLOBAL_TX_DIR_INFORMATION;

    /*
    ** File END
    */

    /*
    ** Section START
    */

    typedef enum _SECTION_INFORMATION_CLASS
    {
        SectionBasicInformation,
        SectionImageInformation,
        SectionRelocationInformation,
        SectionOriginalBaseInformation,
        SectionInternalImageInformation,
        MaxSectionInfoClass
    } SECTION_INFORMATION_CLASS;

    typedef struct _SECTION_BASIC_INFO
    {
        PVOID BaseAddress;
        ULONG AllocationAttributes;
        LARGE_INTEGER MaximumSize;
    } SECTION_BASIC_INFORMATION, *PSECTION_BASIC_INFORMATION;

    typedef struct _SECTION_IMAGE_INFORMATION
    {
        PVOID TransferAddress;
        ULONG ZeroBits;
        SIZE_T MaximumStackSize;
        SIZE_T CommittedStackSize;
        ULONG SubSystemType;
        union
        {
            struct
            {
                USHORT SubSystemMinorVersion;
                USHORT SubSystemMajorVersion;
            };
            ULONG SubSystemVersion;
        };
        union
        {
            struct
            {
                USHORT MajorOperatingSystemVersion;
                USHORT MinorOperatingSystemVersion;
            };
            ULONG OperatingSystemVersion;
        };
        USHORT ImageCharacteristics;
        USHORT DllCharacteristics;
        USHORT Machine;
        BOOLEAN ImageContainsCode;
        union
        {
            UCHAR ImageFlags;
            struct
            {
                UCHAR ComPlusNativeReady        : 1;
                UCHAR ComPlusILOnly             : 1;
                UCHAR ImageDynamicallyRelocated : 1;
                UCHAR ImageMappedFlat           : 1;
                UCHAR BaseBelow4gb              : 1;
                UCHAR ComPlusPrefer32bit        : 1;
                UCHAR Reserved                  : 2;
            };
        };
        ULONG LoaderFlags;
        ULONG ImageFileSize;
        ULONG CheckSum;
    } SECTION_IMAGE_INFORMATION, *PSECTION_IMAGE_INFORMATION;

    typedef struct _SECTION_IMAGE_INFORMATION64
    {
        ULONGLONG TransferAddress;
        ULONG ZeroBits;
        ULONGLONG MaximumStackSize;
        ULONGLONG CommittedStackSize;
        ULONG SubSystemType;
        union
        {
            struct
            {
                USHORT SubSystemMinorVersion;
                USHORT SubSystemMajorVersion;
            };
            ULONG SubSystemVersion;
        };
        union
        {
            struct
            {
                USHORT MajorOperatingSystemVersion;
                USHORT MinorOperatingSystemVersion;
            };
            ULONG OperatingSystemVersion;
        };
        USHORT ImageCharacteristics;
        USHORT DllCharacteristics;
        USHORT Machine;
        BOOLEAN ImageContainsCode;
        union
        {
            UCHAR ImageFlags;
            struct
            {
                UCHAR ComPlusNativeReady        : 1;
                UCHAR ComPlusILOnly             : 1;
                UCHAR ImageDynamicallyRelocated : 1;
                UCHAR ImageMappedFlat           : 1;
                UCHAR BaseBelow4gb              : 1;
                UCHAR ComPlusPrefer32bit        : 1;
                UCHAR Reserved                  : 2;
            };
        };
        ULONG LoaderFlags;
        ULONG ImageFileSize;
        ULONG CheckSum;
    } SECTION_IMAGE_INFORMATION64, *PSECTION_IMAGE_INFORMATION64;

    typedef struct _SECTION_INTERNAL_IMAGE_INFORMATION
    {
        SECTION_IMAGE_INFORMATION SectionInformation;
        union
        {
            ULONG ExtendedFlags;
            struct
            {
                ULONG ImageExportSuppressionEnabled : 1;
                ULONG Reserved                      : 31;
            };
        };
    } SECTION_INTERNAL_IMAGE_INFORMATION, *PSECTION_INTERNAL_IMAGE_INFORMATION;

    typedef enum _SECTION_INHERIT
    {
        ViewShare = 1,
        ViewUnmap = 2
    } SECTION_INHERIT;

#ifndef SEC_BASED
#define SEC_BASED 0x200000
#endif

#ifndef SEC_NO_IMAGE
#define SEC_NO_CHANGE 0x400000
#endif

#ifndef SEC_FILE
#define SEC_FILE 0x800000
#endif

#ifndef SEC_IMAGE
#define SEC_IMAGE 0x1000000
#endif

#ifndef SEC_RESERVE
#define SEC_RESERVE 0x4000000
#endif

#ifndef SEC_COMMIT
#define SEC_COMMIT 0x8000000
#endif

#ifndef SEC_NOCACHE
#define SEC_NOCACHE 0x10000000
#endif

#ifndef SEC_GLOBAL
#define SEC_GLOBAL 0x20000000
#endif

#ifndef SEC_LARGE_PAGES
#define SEC_LARGE_PAGES 0x80000000
#endif

    /*
    ** Section END
    */

    /*
    ** System Table START
    */
#define NUMBER_SERVICE_TABLES 2
#define NTOS_SERVICE_INDEX 0
#define WIN32K_SERVICE_INDEX 1
#define SERVICE_NUMBER_MASK ((1 << 12) - 1)

#if defined(_WIN64)

#if defined(_AMD64_)

#define SERVICE_TABLE_SHIFT (12 - 4)
#define SERVICE_TABLE_MASK (((1 << 1) - 1) << 4)
#define SERVICE_TABLE_TEST (WIN32K_SERVICE_INDEX << 4)

#else

#define SERVICE_TABLE_SHIFT (12 - 5)
#define SERVICE_TABLE_MASK (((1 << 1) - 1) << 5)
#define SERVICE_TABLE_TEST (WIN32K_SERVICE_INDEX << 5)

#endif

#else

#define SERVICE_TABLE_SHIFT (12 - 4)
#define SERVICE_TABLE_MASK (((1 << 1) - 1) << 4)
#define SERVICE_TABLE_TEST (WIN32K_SERVICE_INDEX << 4)

#endif

    typedef struct _KSERVICE_TABLE_DESCRIPTOR
    {
        ULONG_PTR Base; // e.g. KiServiceTable
        PULONG Count;
        ULONG Limit;   // e.g. KiServiceLimit
        PUCHAR Number; // e.g. KiArgumentTable
    } KSERVICE_TABLE_DESCRIPTOR, *PKSERVICE_TABLE_DESCRIPTOR;
    /*
    ** System Table END
    */

    /*
    ** System Boot Environment START
    */

    // Size=20
    typedef struct _SYSTEM_BOOT_ENVIRONMENT_INFORMATION_V1
    {
        struct _GUID BootIdentifier;
        enum _FIRMWARE_TYPE FirmwareType;
    } SYSTEM_BOOT_ENVIRONMENT_INFORMATION_V1, *PSYSTEM_BOOT_ENVIRONMENT_INFORMATION_V1;

    // Size=32
    typedef struct _SYSTEM_BOOT_ENVIRONMENT_INFORMATION
    {
        struct _GUID BootIdentifier;
        enum _FIRMWARE_TYPE FirmwareType;
        unsigned __int64 BootFlags;
    } SYSTEM_BOOT_ENVIRONMENT_INFORMATION, *PSYSTEM_BOOT_ENVIRONMENT_INFORMATION;

    /*
    ** System Boot Environment END
    */

    /*
    ** Key START
    */

    typedef enum _KEY_INFORMATION_CLASS
    {
        KeyBasicInformation,
        KeyNodeInformation,
        KeyFullInformation,
        KeyNameInformation,
        KeyCachedInformation,
        KeyFlagsInformation,
        KeyVirtualizationInformation,
        KeyHandleTagsInformation,
        KeyTrustInformation,
        KeyLayerInformation,
        MaxKeyInfoClass
    } KEY_INFORMATION_CLASS;

    typedef enum _KEY_SET_INFORMATION_CLASS
    {
        KeyWriteTimeInformation,
        KeyWow64FlagsInformation,
        KeyControlFlagsInformation,
        KeySetVirtualizationInformation,
        KeySetDebugInformation,
        KeySetHandleTagsInformation,
        KeySetLayerInformation,
        MaxKeySetInfoClass
    } KEY_SET_INFORMATION_CLASS;

    typedef struct _KEY_FULL_INFORMATION
    {
        LARGE_INTEGER LastWriteTime;
        ULONG TitleIndex;
        ULONG ClassOffset;
        ULONG ClassLength;
        ULONG SubKeys;
        ULONG MaxNameLen;
        ULONG MaxClassLen;
        ULONG Values;
        ULONG MaxValueNameLen;
        ULONG MaxValueDataLen;
        WCHAR Class[1];
    } KEY_FULL_INFORMATION, *PKEY_FULL_INFORMATION;

    typedef struct _KEY_BASIC_INFORMATION
    {
        LARGE_INTEGER LastWriteTime;
        ULONG TitleIndex;
        ULONG NameLength;
        WCHAR Name[1];
    } KEY_BASIC_INFORMATION, *PKEY_BASIC_INFORMATION;

    typedef enum _KEY_VALUE_INFORMATION_CLASS
    {
        KeyValueBasicInformation,
        KeyValueFullInformation,
        KeyValuePartialInformation,
        KeyValueFullInformationAlign64,
        KeyValuePartialInformationAlign64,
        KeyValueLayerInformation,
        MaxKeyValueInfoClass
    } KEY_VALUE_INFORMATION_CLASS;

    typedef struct _KEY_VALUE_BASIC_INFORMATION
    {
        ULONG TitleIndex;
        ULONG Type;
        ULONG NameLength;
        WCHAR Name[1]; // Variable size
    } KEY_VALUE_BASIC_INFORMATION, *PKEY_VALUE_BASIC_INFORMATION;

    typedef struct _KEY_VALUE_FULL_INFORMATION
    {
        ULONG TitleIndex;
        ULONG Type;
        ULONG DataOffset;
        ULONG DataLength;
        ULONG NameLength;
        WCHAR Name[1]; // Variable size
                       //          Data[1];            // Variable size data not declared
    } KEY_VALUE_FULL_INFORMATION, *PKEY_VALUE_FULL_INFORMATION;

    typedef struct _KEY_VALUE_PARTIAL_INFORMATION
    {
        ULONG TitleIndex;
        ULONG Type;
        ULONG DataLength;
        UCHAR Data[1]; // Variable size
    } KEY_VALUE_PARTIAL_INFORMATION, *PKEY_VALUE_PARTIAL_INFORMATION;

    typedef struct _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64
    {
        ULONG Type;
        ULONG DataLength;
        UCHAR Data[1]; // Variable size
    } KEY_VALUE_PARTIAL_INFORMATION_ALIGN64, *PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64;

    typedef struct _KEY_VALUE_ENTRY
    {
        PUNICODE_STRING ValueName;
        ULONG DataLength;
        ULONG DataOffset;
        ULONG Type;
    } KEY_VALUE_ENTRY, *PKEY_VALUE_ENTRY;

    /*
    ** Key END
    */


    /*
    ** TIME_FIELDS START
    */

    typedef struct _TIME_FIELDS
    {
        CSHORT Year;         // range [1601...]
        CSHORT Month;        // range [1..12]
        CSHORT Day;          // range [1..31]
        CSHORT Hour;         // range [0..23]
        CSHORT Minute;       // range [0..59]
        CSHORT Second;       // range [0..59]
        CSHORT Milliseconds; // range [0..999]
        CSHORT Weekday;      // range [0..6] == [Sunday..Saturday]
    } TIME_FIELDS;
    typedef TIME_FIELDS* PTIME_FIELDS;

    /*
    ** TIME_FIELDS END
    */

    /*
    ** HANDLE START
    */

    typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO
    {
        USHORT UniqueProcessId;
        USHORT CreatorBackTraceIndex;
        UCHAR ObjectTypeIndex;
        UCHAR HandleAttributes;
        USHORT HandleValue;
        PVOID Object;
        ULONG GrantedAccess;
    } SYSTEM_HANDLE_TABLE_ENTRY_INFO, *PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

    typedef struct _SYSTEM_HANDLE_INFORMATION
    {
        ULONG NumberOfHandles;
        SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];
    } SYSTEM_HANDLE_INFORMATION, *PSYSTEM_HANDLE_INFORMATION;

    typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX
    {
        PVOID Object;
        ULONG_PTR UniqueProcessId;
        ULONG_PTR HandleValue;
        ULONG GrantedAccess;
        USHORT CreatorBackTraceIndex;
        USHORT ObjectTypeIndex;
        ULONG HandleAttributes;
        ULONG Reserved;
    } SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX, *PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX;

    typedef struct _SYSTEM_HANDLE_INFORMATION_EX
    {
        ULONG_PTR NumberOfHandles;
        ULONG_PTR Reserved;
        SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX Handles[1];
    } SYSTEM_HANDLE_INFORMATION_EX, *PSYSTEM_HANDLE_INFORMATION_EX;

    /*
    ** HANDLE END
    */

    // Privileges

#define SE_MIN_WELL_KNOWN_PRIVILEGE (2L)
#define SE_CREATE_TOKEN_PRIVILEGE (2L)
#define SE_ASSIGNPRIMARYTOKEN_PRIVILEGE (3L)
#define SE_LOCK_MEMORY_PRIVILEGE (4L)
#define SE_INCREASE_QUOTA_PRIVILEGE (5L)
#define SE_MACHINE_ACCOUNT_PRIVILEGE (6L)
#define SE_TCB_PRIVILEGE (7L)
#define SE_SECURITY_PRIVILEGE (8L)
#define SE_TAKE_OWNERSHIP_PRIVILEGE (9L)
#define SE_LOAD_DRIVER_PRIVILEGE (10L)
#define SE_SYSTEM_PROFILE_PRIVILEGE (11L)
#define SE_SYSTEMTIME_PRIVILEGE (12L)
#define SE_PROF_SINGLE_PROCESS_PRIVILEGE (13L)
#define SE_INC_BASE_PRIORITY_PRIVILEGE (14L)
#define SE_CREATE_PAGEFILE_PRIVILEGE (15L)
#define SE_CREATE_PERMANENT_PRIVILEGE (16L)
#define SE_BACKUP_PRIVILEGE (17L)
#define SE_RESTORE_PRIVILEGE (18L)
#define SE_SHUTDOWN_PRIVILEGE (19L)
#define SE_DEBUG_PRIVILEGE (20L)
#define SE_AUDIT_PRIVILEGE (21L)
#define SE_SYSTEM_ENVIRONMENT_PRIVILEGE (22L)
#define SE_CHANGE_NOTIFY_PRIVILEGE (23L)
#define SE_REMOTE_SHUTDOWN_PRIVILEGE (24L)
#define SE_UNDOCK_PRIVILEGE (25L)
#define SE_SYNC_AGENT_PRIVILEGE (26L)
#define SE_ENABLE_DELEGATION_PRIVILEGE (27L)
#define SE_MANAGE_VOLUME_PRIVILEGE (28L)
#define SE_IMPERSONATE_PRIVILEGE (29L)
#define SE_CREATE_GLOBAL_PRIVILEGE (30L)
#define SE_TRUSTED_CREDMAN_ACCESS_PRIVILEGE (31L)
#define SE_RELABEL_PRIVILEGE (32L)
#define SE_INC_WORKING_SET_PRIVILEGE (33L)
#define SE_TIME_ZONE_PRIVILEGE (34L)
#define SE_CREATE_SYMBOLIC_LINK_PRIVILEGE (35L)
#define SE_DELEGATE_SESSION_USER_IMPERSONATE_PRIVILEGE (36L)
#define SE_MAX_WELL_KNOWN_PRIVILEGE SE_DELEGATE_SESSION_USER_IMPERSONATE_PRIVILEGE

    //
    // Generic test for success on any status value (non-negative numbers
    // indicate success).
    //

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)

    //
    // Generic test for information on any status value.
    //

#define NT_INFORMATION(Status) ((ULONG)(Status) >> 30 == 1)

    //
    // Generic test for warning on any status value.
    //

#define NT_WARNING(Status) ((ULONG)(Status) >> 30 == 2)

    //
    // Generic test for error on any status value.
    //

#define NT_ERROR(Status) ((ULONG)(Status) >> 30 == 3)


    /*
    ** OBJECT MANAGER START
    */

    //
    // Header flags
    //

#define OB_FLAG_NEW_OBJECT 0x01
#define OB_FLAG_KERNEL_OBJECT 0x02
#define OB_FLAG_CREATOR_INFO 0x04
#define OB_FLAG_EXCLUSIVE_OBJECT 0x08
#define OB_FLAG_PERMANENT_OBJECT 0x10
#define OB_FLAG_DEFAULT_SECURITY_QUOTA 0x20
#define OB_FLAG_SINGLE_HANDLE_ENTRY 0x40
#define OB_FLAG_DELETED_INLINE 0x80

    //
    // InfoMask values
    //

#define OB_INFOMASK_PROCESS_INFO 0x10
#define OB_INFOMASK_QUOTA 0x08
#define OB_INFOMASK_HANDLE 0x04
#define OB_INFOMASK_NAME 0x02
#define OB_INFOMASK_CREATOR_INFO 0x01

#define OBJ_INVALID_SESSION_ID 0xFFFFFFFF
#define NUMBER_HASH_BUCKETS 37

    typedef struct _OBJECT_DIRECTORY_ENTRY
    {
        PVOID ChainLink;
        PVOID Object;
        ULONG HashValue;
    } OBJECT_DIRECTORY_ENTRY, *POBJECT_DIRECTORY_ENTRY;

    typedef struct _EX_PUSH_LOCK
    {
        union
        {
            ULONG Locked         : 1;
            ULONG Waiting        : 1;
            ULONG Waking         : 1;
            ULONG MultipleShared : 1;
            ULONG Shared         : 28;
            ULONG Value;
            PVOID Ptr;
        };
    } EX_PUSH_LOCK, *PEX_PUSH_LOCK;

    typedef struct _OBJECT_NAMESPACE_LOOKUPTABLE
    {
        LIST_ENTRY HashBuckets[NUMBER_HASH_BUCKETS];
        EX_PUSH_LOCK Lock;
        ULONG NumberOfPrivateSpaces;
    } OBJECT_NAMESPACE_LOOKUPTABLE, *POBJECT_NAMESPACE_LOOKUPTABLE;

    typedef struct _OBJECT_NAMESPACE_ENTRY
    {
        LIST_ENTRY ListEntry;
        PVOID NamespaceRootDirectory;
        ULONG SizeOfBoundaryInformation;
        ULONG Reserved;
        UCHAR HashValue;
        ULONG_PTR Alignment;
    } OBJECT_NAMESPACE_ENTRY, *POBJECT_NAMESPACE_ENTRY;

    typedef enum _BOUNDARY_ENTRY_TYPE
    {
        OBNS_Invalid        = 0,
        OBNS_Name           = 1,
        OBNS_SID            = 2,
        OBNS_IntegrityLabel = 3
    } BOUNDARY_ENTRY_TYPE;

    typedef struct _OBJECT_BOUNDARY_ENTRY
    {
        BOUNDARY_ENTRY_TYPE EntryType;
        ULONG EntrySize;
    } OBJECT_BOUNDARY_ENTRY, *POBJECT_BOUNDARY_ENTRY;

    typedef struct _OBJECT_BOUNDARY_DESCRIPTOR
    {
        ULONG Version;
        ULONG Items;
        ULONG TotalSize;
        ULONG Reserved;
    } OBJECT_BOUNDARY_DESCRIPTOR, *POBJECT_BOUNDARY_DESCRIPTOR;

    typedef struct _OBJECT_DIRECTORY
    {
        POBJECT_DIRECTORY_ENTRY HashBuckets[NUMBER_HASH_BUCKETS];
        EX_PUSH_LOCK Lock;
        PDEVICE_MAP DeviceMap;
        ULONG SessionId;
        PVOID NamespaceEntry;
        ULONG Flags;
    } OBJECT_DIRECTORY, *POBJECT_DIRECTORY;

    typedef struct _OBJECT_DIRECTORY_V2
    {
        POBJECT_DIRECTORY_ENTRY HashBuckets[NUMBER_HASH_BUCKETS];
        EX_PUSH_LOCK Lock;
        PDEVICE_MAP DeviceMap;
        POBJECT_DIRECTORY ShadowDirectory;
        ULONG SessionId;
        PVOID NamespaceEntry;
        ULONG Flags;
        LONG Padding[1];
    } OBJECT_DIRECTORY_V2, *POBJECT_DIRECTORY_V2;

    typedef struct _OBJECT_DIRECTORY_V3
    {
        POBJECT_DIRECTORY_ENTRY HashBuckets[NUMBER_HASH_BUCKETS];
        EX_PUSH_LOCK Lock;
        PDEVICE_MAP DeviceMap;
        POBJECT_DIRECTORY ShadowDirectory;
        PVOID NamespaceEntry;
        PVOID SessionObject;
        ULONG Flags;
        ULONG SessionId;
    } OBJECT_DIRECTORY_V3, *POBJECT_DIRECTORY_V3;

    typedef struct _OBJECT_HEADER_NAME_INFO
    {
        POBJECT_DIRECTORY Directory;
        UNICODE_STRING Name;
        ULONG QueryReferences;
    } OBJECT_HEADER_NAME_INFO, *POBJECT_HEADER_NAME_INFO;

    typedef struct _OBJECT_HEADER_CREATOR_INFO
    {                                 // Size=32
        LIST_ENTRY TypeList;          // Size=16 Offset=0
        PVOID CreatorUniqueProcess;   // Size=8 Offset=16
        USHORT CreatorBackTraceIndex; // Size=2 Offset=24
        USHORT Reserved;              // Size=2 Offset=26
    } OBJECT_HEADER_CREATOR_INFO, *POBJECT_HEADER_CREATOR_INFO;

    typedef struct _OBJECT_HANDLE_COUNT_ENTRY
    {                  // Size=16
        PVOID Process; // Size=8 Offset=0
        struct
        {
            unsigned long HandleCount : 24; // Size=4 Offset=8 BitOffset=0 BitCount=24
            unsigned long LockCount   : 8;  // Size=4 Offset=8 BitOffset=24 BitCount=8
        };
    } OBJECT_HANDLE_COUNT_ENTRY, *POBJECT_HANDLE_COUNT_ENTRY;

    typedef struct _OBJECT_HEADER_HANDLE_INFO
    { // Size=16
        union
        {
            PVOID HandleCountDataBase;                     // Size=8 Offset=0
            struct _OBJECT_HANDLE_COUNT_ENTRY SingleEntry; // Size=16 Offset=0
        };
    } OBJECT_HEADER_HANDLE_INFO, *POBJECT_HEADER_HANDLE_INFO;

    typedef struct _OBJECT_HEADER_PROCESS_INFO
    {                           // Size=16
        PVOID ExclusiveProcess; // Size=8 Offset=0
        PVOID Reserved;         // Size=8 Offset=8
    } OBJECT_HEADER_PROCESS_INFO, *POBJECT_HEADER_PROCESS_INFO;

    typedef struct _OBJECT_HEADER_QUOTA_INFO
    {
        ULONG PagedPoolCharge;              // 4
        ULONG NonPagedPoolCharge;           // 4
        ULONG SecurityDescriptorCharge;     // 4
        PVOID SecurityDescriptorQuotaBlock; // sizeof(pointer)
        unsigned __int64 Reserved;          // sizeof(uint64)
    } OBJECT_HEADER_QUOTA_INFO, *POBJECT_HEADER_QUOTA_INFO;

    typedef struct _OBJECT_HEADER_PADDING_INFO
    {
        ULONG PaddingAmount;
    } OBJECT_HEADER_PADDING_INFO, *POBJECT_HEADER_PADDING_INFO;

    typedef struct _OBJECT_HEADER_AUDIT_INFO
    {
        PVOID SecurityDescriptor;
        PVOID Reserved;
    } OBJECT_HEADER_AUDIT_INFO, *POBJECT_HEADER_AUDIT_INFO;

    typedef struct _OBJECT_HEADER_EXTENDED_INFO
    {
        struct _OBJECT_FOOTER* Footer;
        PVOID Reserved;
    } OBJECT_HEADER_EXTENDED_INFO, POBJECT_HEADER_EXTENDED_INFO;

    typedef struct _OB_HANDLE_REVOCATION_BLOCK
    {
        LIST_ENTRY RevocationInfos;
        struct _EX_PUSH_LOCK Lock;
        struct _EX_RUNDOWN_REF Rundown;
    } OB_HANDLE_REVOCATION_BLOCK, *POB_HANDLE_REVOCATION_BLOCK;

    typedef struct _OBJECT_HEADER_HANDLE_REVOCATION_INFO
    {
        LIST_ENTRY ListEntry;
        OB_HANDLE_REVOCATION_BLOCK* RevocationBlock;
        unsigned char Padding1[4];
        unsigned char Padding2[4];
    } OBJECT_HEADER_HANDLE_REVOCATION_INFO, *POBJECT_HEADER_HANDLE_REVOCATION_INFO;

    typedef struct _QUAD
    {
        union
        {
            INT64 UseThisFieldToCopy;
            float DoNotUseThisField;
        };
    } QUAD, *PQUAD;

    typedef struct _OBJECT_CREATE_INFORMATION
    {
        ULONG Attributes;
        PVOID RootDirectory;
        CHAR ProbeMode;
        ULONG PagedPoolCharge;
        ULONG NonPagedPoolCharge;
        ULONG SecurityDescriptorCharge;
        PVOID SecurityDescriptor;
        PSECURITY_QUALITY_OF_SERVICE SecurityQos;
        SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    } OBJECT_CREATE_INFORMATION, *POBJECT_CREATE_INFORMATION;

    typedef struct _SECURITY_CLIENT_CONTEXT
    {
        struct _SECURITY_QUALITY_OF_SERVICE SecurityQos;
        void* ClientToken;
        UCHAR DirectlyAccessClientToken;
        UCHAR DirectAccessEffectiveOnly;
        UCHAR ServerIsRemote;
        struct _TOKEN_CONTROL ClientTokenControl;
        LONG __PADDING__[1];
    } SECURITY_CLIENT_CONTEXT, *PSECURITY_CLIENT_CONTEXT;

    typedef enum _POOL_TYPE
    {
        NonPagedPool,
        NonPagedPoolExecute = NonPagedPool,
        PagedPool,
        NonPagedPoolMustSucceed = NonPagedPool + 2,
        DontUseThisType,
        NonPagedPoolCacheAligned = NonPagedPool + 4,
        PagedPoolCacheAligned,
        NonPagedPoolCacheAlignedMustS = NonPagedPool + 6,
        MaxPoolType,
        NonPagedPoolBase                     = 0,
        NonPagedPoolBaseMustSucceed          = NonPagedPoolBase + 2,
        NonPagedPoolBaseCacheAligned         = NonPagedPoolBase + 4,
        NonPagedPoolBaseCacheAlignedMustS    = NonPagedPoolBase + 6,
        NonPagedPoolSession                  = 32,
        PagedPoolSession                     = NonPagedPoolSession + 1,
        NonPagedPoolMustSucceedSession       = PagedPoolSession + 1,
        DontUseThisTypeSession               = NonPagedPoolMustSucceedSession + 1,
        NonPagedPoolCacheAlignedSession      = DontUseThisTypeSession + 1,
        PagedPoolCacheAlignedSession         = NonPagedPoolCacheAlignedSession + 1,
        NonPagedPoolCacheAlignedMustSSession = PagedPoolCacheAlignedSession + 1,
        NonPagedPoolNx                       = 512,
        NonPagedPoolNxCacheAligned           = NonPagedPoolNx + 4,
        NonPagedPoolSessionNx                = NonPagedPoolNx + 32
    } POOL_TYPE;

    //
    // WARNING this structure is incomplete, refer to complete definitions below if you need actual full variant.
    //
    typedef struct _OBJECT_TYPE_INITIALIZER_COMPATIBLE
    {                                    // Size=120
        USHORT Length;                   // Size=2 Offset=0
        UCHAR ObjectTypeFlags;           // Size=1 Offset=2
        ULONG ObjectTypeCode;            // Size=4 Offset=4
        ULONG InvalidAttributes;         // Size=4 Offset=8
        GENERIC_MAPPING GenericMapping;  // Size=16 Offset=12
        ULONG ValidAccessMask;           // Size=4 Offset=28
        ULONG RetainAccess;              // Size=4 Offset=32
        POOL_TYPE PoolType;              // Size=4 Offset=36
        ULONG DefaultPagedPoolCharge;    // Size=4 Offset=40
        ULONG DefaultNonPagedPoolCharge; // Size=4 Offset=44
        PVOID DumpProcedure;             // Size=8 Offset=48
        PVOID OpenProcedure;             // Size=8 Offset=56
        PVOID CloseProcedure;            // Size=8 Offset=64
        PVOID DeleteProcedure;           // Size=8 Offset=72
        PVOID ParseProcedure;            // Size=8 Offset=80
        PVOID SecurityProcedure;         // Size=8 Offset=88
        PVOID QueryNameProcedure;        // Size=8 Offset=96
        PVOID OkayToCloseProcedure;      // Size=8 Offset=104
    } OBJECT_TYPE_INITIALIZER_COMPATIBLE, *POBJECT_TYPE_INITIALIZER_COMPATIBLE;

    //
    // WARNING this structure is incomplete, refer to complete definitions below if you need actual full variant.
    //
    typedef struct _OBJECT_TYPE_COMPATIBLE
    {
        LIST_ENTRY TypeList;
        UNICODE_STRING Name;
        PVOID DefaultObject;
        UCHAR Index;
        ULONG TotalNumberOfObjects;
        ULONG TotalNumberOfHandles;
        ULONG HighWaterNumberOfObjects;
        ULONG HighWaterNumberOfHandles;
        OBJECT_TYPE_INITIALIZER_COMPATIBLE TypeInfo;
    } OBJECT_TYPE_COMPATIBLE, *POBJECT_TYPE_COMPATIBLE;
    typedef POBJECT_TYPE_COMPATIBLE POBJECT_TYPE;

    //
    // Complete definitions of OBJECT_TYPE + OBJECT_TYPE_INITIALIZER per Windows version.
    //

    typedef struct _OBJECT_TYPE_INITIALIZER_7
    {
        USHORT Length;
        union
        {
            UCHAR ObjectTypeFlags;
            struct
            {
                UCHAR CaseInsensitive         : 1;
                UCHAR UnnamedObjectsOnly      : 1;
                UCHAR UseDefaultObject        : 1;
                UCHAR SecurityRequired        : 1;
                UCHAR MaintainHandleCount     : 1;
                UCHAR MaintainTypeList        : 1;
                UCHAR SupportsObjectCallbacks : 1;
            };
        };
        ULONG ObjectTypeCode;
        ULONG InvalidAttributes;
        GENERIC_MAPPING GenericMapping;
        ULONG ValidAccessMask;
        ULONG RetainAccess;
        POOL_TYPE PoolType;
        ULONG DefaultPagedPoolCharge;
        ULONG DefaultNonPagedPoolCharge;
        PVOID DumpProcedure;
        PVOID OpenProcedure;
        PVOID CloseProcedure;
        PVOID DeleteProcedure;
        PVOID ParseProcedure;
        PVOID SecurityProcedure;
        PVOID QueryNameProcedure;
        PVOID OkayToCloseProcedure;
    } OBJECT_TYPE_INITIALIZER_7, *POBJECT_TYPE_INITIALIZER_7;

    //
    // Windows 8, new object type flag, WaitObject* members added
    //
    typedef struct _OBJECT_TYPE_INITIALIZER_8
    {
        USHORT Length;
        union
        {
            UCHAR ObjectTypeFlags;
            struct
            {
                UCHAR CaseInsensitive         : 1;
                UCHAR UnnamedObjectsOnly      : 1;
                UCHAR UseDefaultObject        : 1;
                UCHAR SecurityRequired        : 1;
                UCHAR MaintainHandleCount     : 1;
                UCHAR MaintainTypeList        : 1;
                UCHAR SupportsObjectCallbacks : 1;
                UCHAR CacheAligned            : 1;
            };
        };
        ULONG ObjectTypeCode;
        ULONG InvalidAttributes;
        GENERIC_MAPPING GenericMapping;
        ULONG ValidAccessMask;
        ULONG RetainAccess;
        POOL_TYPE PoolType;
        ULONG DefaultPagedPoolCharge;
        ULONG DefaultNonPagedPoolCharge;
        PVOID DumpProcedure;
        PVOID OpenProcedure;
        PVOID CloseProcedure;
        PVOID DeleteProcedure;
        PVOID ParseProcedure;
        PVOID SecurityProcedure;
        PVOID QueryNameProcedure;
        PVOID OkayToCloseProcedure;
        ULONG WaitObjectFlagMask;
        USHORT WaitObjectFlagOffset;
        USHORT WaitObjectPointerOffset;
    } OBJECT_TYPE_INITIALIZER_8, *POBJECT_TYPE_INITIALIZER_8;

    //
    // Windows 10 RS1, new ObjectTypeFlags2 flag added,
    // ParseProcedure now has two variants with different parameters.
    //
    typedef struct _OBJECT_TYPE_INITIALIZER_RS1
    {
        USHORT Length;
        union
        {
            UCHAR ObjectTypeFlags;
            struct
            {
                UCHAR CaseInsensitive         : 1;
                UCHAR UnnamedObjectsOnly      : 1;
                UCHAR UseDefaultObject        : 1;
                UCHAR SecurityRequired        : 1;
                UCHAR MaintainHandleCount     : 1;
                UCHAR MaintainTypeList        : 1;
                UCHAR SupportsObjectCallbacks : 1;
                UCHAR CacheAligned            : 1;
            };
        };
        union
        {
            UCHAR ObjectTypeFlags2; // for ParseProcedureEx
            struct
            {
                UCHAR UseExtendedParameters : 1;
                UCHAR Reserved              : 7;
            };
        };
        ULONG ObjectTypeCode;
        ULONG InvalidAttributes;
        GENERIC_MAPPING GenericMapping;
        ULONG ValidAccessMask;
        ULONG RetainAccess;
        POOL_TYPE PoolType;
        ULONG DefaultPagedPoolCharge;
        ULONG DefaultNonPagedPoolCharge;
        PVOID DumpProcedure;
        PVOID OpenProcedure;
        PVOID CloseProcedure;
        PVOID DeleteProcedure;
        union
        {
            PVOID ParseProcedure;
            PVOID ParseProcedureEx;
        };
        PVOID SecurityProcedure;
        PVOID QueryNameProcedure;
        PVOID OkayToCloseProcedure;
        ULONG WaitObjectFlagMask;
        USHORT WaitObjectFlagOffset;
        USHORT WaitObjectPointerOffset;
    } OBJECT_TYPE_INITIALIZER_RS1, *POBJECT_TYPE_INITIALIZER_RS1;

    //
    // ObjectTypeFlags2 moved to extended to USHORT ObjectTypeFlags field.
    // It was that hard to do this since beginning?
    //
    typedef struct _OBJECT_TYPE_INITIALIZER_RS2
    {
        USHORT Length;
        union
        {
            USHORT ObjectTypeFlags;
            struct
            {
                UCHAR CaseInsensitive         : 1;
                UCHAR UnnamedObjectsOnly      : 1;
                UCHAR UseDefaultObject        : 1;
                UCHAR SecurityRequired        : 1;
                UCHAR MaintainHandleCount     : 1;
                UCHAR MaintainTypeList        : 1;
                UCHAR SupportsObjectCallbacks : 1;
                UCHAR CacheAligned            : 1;
            };
            struct
            {
                UCHAR UseExtendedParameters : 1; // for ParseProcedureEx
                UCHAR Reserved              : 7;
            };
        };
        ULONG ObjectTypeCode;
        ULONG InvalidAttributes;
        GENERIC_MAPPING GenericMapping;
        ULONG ValidAccessMask;
        ULONG RetainAccess;
        POOL_TYPE PoolType;
        ULONG DefaultPagedPoolCharge;
        ULONG DefaultNonPagedPoolCharge;
        PVOID DumpProcedure;
        PVOID OpenProcedure;
        PVOID CloseProcedure;
        PVOID DeleteProcedure;
        union
        {
            PVOID ParseProcedure;
            PVOID ParseProcedureEx;
        };
        PVOID SecurityProcedure;
        PVOID QueryNameProcedure;
        PVOID OkayToCloseProcedure;
        ULONG WaitObjectFlagMask;
        USHORT WaitObjectFlagOffset;
        USHORT WaitObjectPointerOffset;
    } OBJECT_TYPE_INITIALIZER_RS2, *POBJECT_TYPE_INITIALIZER_RS2;

    //
    // OBJECT_TYPE definition vary only because of OBJECT_TYPE_INITIALIZER changes.
    //
    typedef struct _OBJECT_TYPE_7
    {
        LIST_ENTRY TypeList;
        UNICODE_STRING Name;
        PVOID DefaultObject;
        UCHAR Index;
        ULONG TotalNumberOfObjects;
        ULONG TotalNumberOfHandles;
        ULONG HighWaterNumberOfObjects;
        ULONG HighWaterNumberOfHandles;
        OBJECT_TYPE_INITIALIZER_7 TypeInfo;
        EX_PUSH_LOCK TypeLock;
        ULONG Key;
        LIST_ENTRY CallbackList;
    } OBJECT_TYPE_7, POBJECT_TYPE_7;

    typedef struct _OBJECT_TYPE_8
    {
        LIST_ENTRY TypeList;
        UNICODE_STRING Name;
        PVOID DefaultObject;
        UCHAR Index;
        ULONG TotalNumberOfObjects;
        ULONG TotalNumberOfHandles;
        ULONG HighWaterNumberOfObjects;
        ULONG HighWaterNumberOfHandles;
        OBJECT_TYPE_INITIALIZER_8 TypeInfo;
        EX_PUSH_LOCK TypeLock;
        ULONG Key;
        LIST_ENTRY CallbackList;
    } OBJECT_TYPE_8, POBJECT_TYPE_8;

    typedef struct _OBJECT_TYPE_RS1
    {
        LIST_ENTRY TypeList;
        UNICODE_STRING Name;
        PVOID DefaultObject;
        UCHAR Index;
        ULONG TotalNumberOfObjects;
        ULONG TotalNumberOfHandles;
        ULONG HighWaterNumberOfObjects;
        ULONG HighWaterNumberOfHandles;
        OBJECT_TYPE_INITIALIZER_RS1 TypeInfo;
        EX_PUSH_LOCK TypeLock;
        ULONG Key;
        LIST_ENTRY CallbackList;
    } OBJECT_TYPE_RS1, POBJECT_TYPE_RS1;

    typedef struct _OBJECT_TYPE_RS2
    {
        LIST_ENTRY TypeList;
        UNICODE_STRING Name;
        PVOID DefaultObject;
        UCHAR Index;
        ULONG TotalNumberOfObjects;
        ULONG TotalNumberOfHandles;
        ULONG HighWaterNumberOfObjects;
        ULONG HighWaterNumberOfHandles;
        OBJECT_TYPE_INITIALIZER_RS2 TypeInfo;
        EX_PUSH_LOCK TypeLock;
        ULONG Key;
        LIST_ENTRY CallbackList;
    } OBJECT_TYPE_RS2, POBJECT_TYPE_RS2;

    /*
    ** brand new header starting from 6.1
    */

    typedef struct _OBJECT_HEADER
    {
        LONG_PTR PointerCount;
        union
        {
            LONG_PTR HandleCount;
            PVOID NextToFree;
        };
        EX_PUSH_LOCK Lock;
        UCHAR TypeIndex;
        UCHAR TraceFlags;
        UCHAR InfoMask;
        UCHAR Flags;
        union
        {
            POBJECT_CREATE_INFORMATION ObjectCreateInfo;
            PVOID QuotaBlockCharged;
        };
        PVOID SecurityDescriptor;
        QUAD Body;
    } OBJECT_HEADER, *POBJECT_HEADER;

#define OBJECT_TO_OBJECT_HEADER(obj) CONTAINING_RECORD((obj), OBJECT_HEADER, Body)

    /*
    ** OBJECT MANAGER END
    */

    /*
     * WDM START
     */
#define TIMER_TOLERABLE_DELAY_BITS 6
#define TIMER_EXPIRED_INDEX_BITS 6
#define TIMER_PROCESSOR_INDEX_BITS 5

    typedef struct _DISPATCHER_HEADER
    {
        union
        {
            union
            {
                volatile LONG Lock;
                LONG LockNV;
            } DUMMYUNIONNAME;

            struct
            {               // Events, Semaphores, Gates, etc.
                UCHAR Type; // All (accessible via KOBJECT_TYPE)
                UCHAR Signalling;
                UCHAR Size;
                UCHAR Reserved1;
            } DUMMYSTRUCTNAME;

            struct
            { // Timer
                UCHAR TimerType;
                union
                {
                    UCHAR TimerControlFlags;
                    struct
                    {
                        UCHAR Absolute : 1;
                        UCHAR Wake     : 1;
                        UCHAR EncodedTolerableDelay : TIMER_TOLERABLE_DELAY_BITS;
                    } DUMMYSTRUCTNAME;
                };

                UCHAR Hand;
                union
                {
                    UCHAR TimerMiscFlags;
                    struct
                    {

#if !defined(KENCODED_TIMER_PROCESSOR)

                        UCHAR Index : TIMER_EXPIRED_INDEX_BITS;

#else

                    UCHAR Index : 1;
                    UCHAR Processor : TIMER_PROCESSOR_INDEX_BITS;

#endif

                        UCHAR Inserted         : 1;
                        volatile UCHAR Expired : 1;
                    } DUMMYSTRUCTNAME;
                } DUMMYUNIONNAME;
            } DUMMYSTRUCTNAME2;

            struct
            { // Timer2
                UCHAR Timer2Type;
                union
                {
                    UCHAR Timer2Flags;
                    struct
                    {
                        UCHAR Timer2Inserted      : 1;
                        UCHAR Timer2Expiring      : 1;
                        UCHAR Timer2CancelPending : 1;
                        UCHAR Timer2SetPending    : 1;
                        UCHAR Timer2Running       : 1;
                        UCHAR Timer2Disabled      : 1;
                        UCHAR Timer2ReservedFlags : 2;
                    } DUMMYSTRUCTNAME;
                } DUMMYUNIONNAME;

                UCHAR Timer2Reserved1;
                UCHAR Timer2Reserved2;
            } DUMMYSTRUCTNAME3;

            struct
            { // Queue
                UCHAR QueueType;
                union
                {
                    UCHAR QueueControlFlags;
                    struct
                    {
                        UCHAR Abandoned                 : 1;
                        UCHAR DisableIncrement          : 1;
                        UCHAR QueueReservedControlFlags : 6;
                    } DUMMYSTRUCTNAME;
                } DUMMYUNIONNAME;

                UCHAR QueueSize;
                UCHAR QueueReserved;
            } DUMMYSTRUCTNAME4;

            struct
            { // Thread
                UCHAR ThreadType;
                UCHAR ThreadReserved;
                union
                {
                    UCHAR ThreadControlFlags;
                    struct
                    {
                        UCHAR CycleProfiling             : 1;
                        UCHAR CounterProfiling           : 1;
                        UCHAR GroupScheduling            : 1;
                        UCHAR AffinitySet                : 1;
                        UCHAR ThreadReservedControlFlags : 4;
                    } DUMMYSTRUCTNAME;
                } DUMMYUNIONNAME;

                union
                {
                    UCHAR DebugActive;

#if !defined(_X86_)

                    struct
                    {
                        BOOLEAN ActiveDR7    : 1;
                        BOOLEAN Instrumented : 1;
                        BOOLEAN Minimal      : 1;
                        BOOLEAN Reserved4    : 3;
                        BOOLEAN UmsScheduled : 1;
                        BOOLEAN UmsPrimary   : 1;
                    } DUMMYSTRUCTNAME;

#endif

                } DUMMYUNIONNAME2;
            } DUMMYSTRUCTNAME5;

            struct
            { // Mutant
                UCHAR MutantType;
                UCHAR MutantSize;
                BOOLEAN DpcActive;
                UCHAR MutantReserved;
            } DUMMYSTRUCTNAME6;
        } DUMMYUNIONNAME;

        LONG SignalState;        // Object lock
        LIST_ENTRY WaitListHead; // Object lock
    } DISPATCHER_HEADER, *PDISPATCHER_HEADER;

    typedef struct _KEVENT
    {
        DISPATCHER_HEADER Header;
    } KEVENT, *PKEVENT, *PRKEVENT;

    typedef struct _FAST_MUTEX
    {
        LONG_PTR Count;
        void* Owner;
        ULONG Contention;
        struct _KEVENT Event;
        ULONG OldIrql;
        LONG __PADDING__[1];
    } FAST_MUTEX, *PFAST_MUTEX;

    typedef struct _KMUTANT
    {
        DISPATCHER_HEADER Header;
        LIST_ENTRY MutantListEntry;
        struct _KTHREAD* OwnerThread;
        BOOLEAN Abandoned;
        UCHAR ApcDisable;
    } KMUTANT, *PKMUTANT, *PRKMUTANT, KMUTEX, *PKMUTEX, *PRKMUTEX;

    typedef struct _KSEMAPHORE
    {
        DISPATCHER_HEADER Header;
        LONG Limit;
    } KSEMAPHORE, *PKSEMAPHORE, *PRKSEMAPHORE;

    typedef struct _KTIMER
    {
        DISPATCHER_HEADER Header;
        ULARGE_INTEGER DueTime;
        LIST_ENTRY TimerListEntry;
        struct _KDPC* Dpc;
        ULONG Processor;
        LONG Period;
    } KTIMER, *PKTIMER, *PRKTIMER;

    typedef struct _KDEVICE_QUEUE_ENTRY
    {
        LIST_ENTRY DeviceListEntry;
        ULONG SortKey;
        BOOLEAN Inserted;
    } KDEVICE_QUEUE_ENTRY, *PKDEVICE_QUEUE_ENTRY, *PRKDEVICE_QUEUE_ENTRY;

    typedef enum _KDPC_IMPORTANCE
    {
        LowImportance,
        MediumImportance,
        HighImportance
    } KDPC_IMPORTANCE;

    typedef struct _KDPC
    {
        union
        {
            ULONG TargetInfoAsUlong;
            struct
            {
                UCHAR Type;
                UCHAR Importance;
                volatile USHORT Number;
            } DUMMYSTRUCTNAME;
        } DUMMYUNIONNAME;

        SINGLE_LIST_ENTRY DpcListEntry;
        KAFFINITY ProcessorHistory;
        PVOID DeferredRoutine;
        PVOID DeferredContext;
        PVOID SystemArgument1;
        PVOID SystemArgument2;
        __volatile PVOID DpcData;
    } KDPC, *PKDPC, *PRKDPC;

    typedef struct _WAIT_CONTEXT_BLOCK
    {
        union
        {
            KDEVICE_QUEUE_ENTRY WaitQueueEntry;
            struct
            {
                LIST_ENTRY DmaWaitEntry;
                ULONG NumberOfChannels;
                ULONG SyncCallback : 1;
                ULONG DmaContext   : 1;
                ULONG Reserved     : 30;
            };
        };
        PVOID DeviceRoutine;
        PVOID DeviceContext;
        ULONG NumberOfMapRegisters;
        PVOID DeviceObject;
        PVOID CurrentIrp;
        PKDPC BufferChainingDpc;
    } WAIT_CONTEXT_BLOCK, *PWAIT_CONTEXT_BLOCK;

#define MAXIMUM_VOLUME_LABEL_LENGTH (32 * sizeof(WCHAR)) // 32 characters

    typedef struct _VPB
    {
        CSHORT Type;
        CSHORT Size;
        USHORT Flags;
        USHORT VolumeLabelLength; // in bytes
        struct _DEVICE_OBJECT* DeviceObject;
        struct _DEVICE_OBJECT* RealDevice;
        ULONG SerialNumber;
        ULONG ReferenceCount;
        WCHAR VolumeLabel[MAXIMUM_VOLUME_LABEL_LENGTH / sizeof(WCHAR)];
    } VPB, *PVPB;

    typedef struct _KQUEUE
    {
        DISPATCHER_HEADER Header;
        LIST_ENTRY EntryListHead;
        ULONG CurrentCount;
        ULONG MaximumCount;
        LIST_ENTRY ThreadListHead;
    } KQUEUE, *PKQUEUE;

    typedef struct _KDEVICE_QUEUE
    {
        CSHORT Type;
        CSHORT Size;
        LIST_ENTRY DeviceListHead;
        KSPIN_LOCK Lock;

#if defined(_AMD64_)

        union
        {
            BOOLEAN Busy;
            struct
            {
                LONG64 Reserved : 8;
                LONG64 Hint     : 56;
            };
        };

#else

    BOOLEAN Busy;

#endif

    } KDEVICE_QUEUE, *PKDEVICE_QUEUE, *PRKDEVICE_QUEUE;

    enum _KOBJECTS
    {
        EventNotificationObject    = 0x0,
        EventSynchronizationObject = 0x1,
        MutantObject               = 0x2,
        ProcessObject              = 0x3,
        QueueObject                = 0x4,
        SemaphoreObject            = 0x5,
        ThreadObject               = 0x6,
        GateObject                 = 0x7,
        TimerNotificationObject    = 0x8,
        TimerSynchronizationObject = 0x9,
        Spare2Object               = 0xa,
        Spare3Object               = 0xb,
        Spare4Object               = 0xc,
        Spare5Object               = 0xd,
        Spare6Object               = 0xe,
        Spare7Object               = 0xf,
        Spare8Object               = 0x10,
        Spare9Object               = 0x11,
        ApcObject                  = 0x12,
        DpcObject                  = 0x13,
        DeviceQueueObject          = 0x14,
        EventPairObject            = 0x15,
        InterruptObject            = 0x16,
        ProfileObject              = 0x17,
        ThreadedDpcObject          = 0x18,
        MaximumKernelObject        = 0x19,
    };

#define DO_VERIFY_VOLUME 0x00000002         // ntddk nthal ntifs wdm
#define DO_BUFFERED_IO 0x00000004           // ntddk nthal ntifs wdm
#define DO_EXCLUSIVE 0x00000008             // ntddk nthal ntifs wdm
#define DO_DIRECT_IO 0x00000010             // ntddk nthal ntifs wdm
#define DO_MAP_IO_BUFFER 0x00000020         // ntddk nthal ntifs wdm
#define DO_DEVICE_HAS_NAME 0x00000040       // ntddk nthal ntifs
#define DO_DEVICE_INITIALIZING 0x00000080   // ntddk nthal ntifs wdm
#define DO_SYSTEM_BOOT_PARTITION 0x00000100 // ntddk nthal ntifs
#define DO_LONG_TERM_REQUESTS 0x00000200    // ntddk nthal ntifs
#define DO_NEVER_LAST_DEVICE 0x00000400     // ntddk nthal ntifs
#define DO_SHUTDOWN_REGISTERED 0x00000800   // ntddk nthal ntifs wdm
#define DO_BUS_ENUMERATED_DEVICE 0x00001000 // ntddk nthal ntifs wdm
#define DO_POWER_PAGABLE 0x00002000         // ntddk nthal ntifs wdm
#define DO_POWER_INRUSH 0x00004000          // ntddk nthal ntifs wdm
#define DO_POWER_NOOP 0x00008000
#define DO_LOW_PRIORITY_FILESYSTEM 0x00010000 // ntddk nthal ntifs
#define DO_XIP 0x00020000

#define FILE_REMOVABLE_MEDIA 0x00000001
#define FILE_READ_ONLY_DEVICE 0x00000002
#define FILE_FLOPPY_DISKETTE 0x00000004
#define FILE_WRITE_ONCE_MEDIA 0x00000008
#define FILE_REMOTE_DEVICE 0x00000010
#define FILE_DEVICE_IS_MOUNTED 0x00000020
#define FILE_VIRTUAL_VOLUME 0x00000040
#define FILE_AUTOGENERATED_DEVICE_NAME 0x00000080
#define FILE_DEVICE_SECURE_OPEN 0x00000100
#define FILE_CHARACTERISTIC_PNP_DEVICE 0x00000800
#define FILE_CHARACTERISTIC_TS_DEVICE 0x00001000
#define FILE_CHARACTERISTIC_WEBDAV_DEVICE 0x00002000
#define FILE_CHARACTERISTIC_CSV 0x00010000
#define FILE_DEVICE_ALLOW_APPCONTAINER_TRAVERSAL 0x00020000
#define FILE_PORTABLE_DEVICE 0x00040000

#define FILE_DEVICE_BEEP 0x00000001
#define FILE_DEVICE_CD_ROM 0x00000002
#define FILE_DEVICE_CD_ROM_FILE_SYSTEM 0x00000003
#define FILE_DEVICE_CONTROLLER 0x00000004
#define FILE_DEVICE_DATALINK 0x00000005
#define FILE_DEVICE_DFS 0x00000006
#define FILE_DEVICE_DISK 0x00000007
#define FILE_DEVICE_DISK_FILE_SYSTEM 0x00000008
#define FILE_DEVICE_FILE_SYSTEM 0x00000009
#define FILE_DEVICE_INPORT_PORT 0x0000000a
#define FILE_DEVICE_KEYBOARD 0x0000000b
#define FILE_DEVICE_MAILSLOT 0x0000000c
#define FILE_DEVICE_MIDI_IN 0x0000000d
#define FILE_DEVICE_MIDI_OUT 0x0000000e
#define FILE_DEVICE_MOUSE 0x0000000f
#define FILE_DEVICE_MULTI_UNC_PROVIDER 0x00000010
#define FILE_DEVICE_NAMED_PIPE 0x00000011
#define FILE_DEVICE_NETWORK 0x00000012
#define FILE_DEVICE_NETWORK_BROWSER 0x00000013
#define FILE_DEVICE_NETWORK_FILE_SYSTEM 0x00000014
#define FILE_DEVICE_NULL 0x00000015
#define FILE_DEVICE_PARALLEL_PORT 0x00000016
#define FILE_DEVICE_PHYSICAL_NETCARD 0x00000017
#define FILE_DEVICE_PRINTER 0x00000018
#define FILE_DEVICE_SCANNER 0x00000019
#define FILE_DEVICE_SERIAL_MOUSE_PORT 0x0000001a
#define FILE_DEVICE_SERIAL_PORT 0x0000001b
#define FILE_DEVICE_SCREEN 0x0000001c
#define FILE_DEVICE_SOUND 0x0000001d
#define FILE_DEVICE_STREAMS 0x0000001e
#define FILE_DEVICE_TAPE 0x0000001f
#define FILE_DEVICE_TAPE_FILE_SYSTEM 0x00000020
#define FILE_DEVICE_TRANSPORT 0x00000021
#define FILE_DEVICE_UNKNOWN 0x00000022
#define FILE_DEVICE_VIDEO 0x00000023
#define FILE_DEVICE_VIRTUAL_DISK 0x00000024
#define FILE_DEVICE_WAVE_IN 0x00000025
#define FILE_DEVICE_WAVE_OUT 0x00000026
#define FILE_DEVICE_8042_PORT 0x00000027
#define FILE_DEVICE_NETWORK_REDIRECTOR 0x00000028
#define FILE_DEVICE_BATTERY 0x00000029
#define FILE_DEVICE_BUS_EXTENDER 0x0000002a
#define FILE_DEVICE_MODEM 0x0000002b
#define FILE_DEVICE_VDM 0x0000002c
#define FILE_DEVICE_MASS_STORAGE 0x0000002d
#define FILE_DEVICE_SMB 0x0000002e
#define FILE_DEVICE_KS 0x0000002f
#define FILE_DEVICE_CHANGER 0x00000030
#define FILE_DEVICE_SMARTCARD 0x00000031
#define FILE_DEVICE_ACPI 0x00000032
#define FILE_DEVICE_DVD 0x00000033
#define FILE_DEVICE_FULLSCREEN_VIDEO 0x00000034
#define FILE_DEVICE_DFS_FILE_SYSTEM 0x00000035
#define FILE_DEVICE_DFS_VOLUME 0x00000036
#define FILE_DEVICE_SERENUM 0x00000037
#define FILE_DEVICE_TERMSRV 0x00000038
#define FILE_DEVICE_KSEC 0x00000039
#define FILE_DEVICE_FIPS 0x0000003A
#define FILE_DEVICE_INFINIBAND 0x0000003B
#define FILE_DEVICE_VMBUS 0x0000003E
#define FILE_DEVICE_CRYPT_PROVIDER 0x0000003F
#define FILE_DEVICE_WPD 0x00000040
#define FILE_DEVICE_BLUETOOTH 0x00000041
#define FILE_DEVICE_MT_COMPOSITE 0x00000042
#define FILE_DEVICE_MT_TRANSPORT 0x00000043
#define FILE_DEVICE_BIOMETRIC 0x00000044
#define FILE_DEVICE_PMI 0x00000045
#define FILE_DEVICE_EHSTOR 0x00000046
#define FILE_DEVICE_DEVAPI 0x00000047
#define FILE_DEVICE_GPIO 0x00000048
#define FILE_DEVICE_USBEX 0x00000049
#define FILE_DEVICE_CONSOLE 0x00000050
#define FILE_DEVICE_NFP 0x00000051
#define FILE_DEVICE_SYSENV 0x00000052
#define FILE_DEVICE_VIRTUAL_BLOCK 0x00000053
#define FILE_DEVICE_POINT_OF_SERVICE 0x00000054

#define FILE_BYTE_ALIGNMENT 0x00000000
#define FILE_WORD_ALIGNMENT 0x00000001
#define FILE_LONG_ALIGNMENT 0x00000003
#define FILE_QUAD_ALIGNMENT 0x00000007
#define FILE_OCTA_ALIGNMENT 0x0000000f
#define FILE_32_BYTE_ALIGNMENT 0x0000001f
#define FILE_64_BYTE_ALIGNMENT 0x0000003f
#define FILE_128_BYTE_ALIGNMENT 0x0000007f
#define FILE_256_BYTE_ALIGNMENT 0x000000ff
#define FILE_512_BYTE_ALIGNMENT 0x000001ff

#define DPC_NORMAL 0
#define DPC_THREADED 1

    typedef struct _DEVICE_OBJECT
    {
        CSHORT Type;
        USHORT Size;
        LONG ReferenceCount;
        struct _DRIVER_OBJECT* DriverObject;
        struct _DEVICE_OBJECT* NextDevice;
        struct _DEVICE_OBJECT* AttachedDevice;
        struct _IRP* CurrentIrp;
        PVOID Timer;
        ULONG Flags;
        ULONG Characteristics;
        __volatile PVPB Vpb;
        PVOID DeviceExtension;
        DEVICE_TYPE DeviceType;
        CCHAR StackSize;
        union
        {
            LIST_ENTRY ListEntry;
            WAIT_CONTEXT_BLOCK Wcb;
        } Queue;
        ULONG AlignmentRequirement;
        KDEVICE_QUEUE DeviceQueue;
        KDPC Dpc;
        ULONG ActiveThreadCount;
        PSECURITY_DESCRIPTOR SecurityDescriptor;
        KEVENT DeviceLock;
        USHORT SectorSize;
        USHORT Spare1;
        struct _DEVOBJ_EXTENSION* DeviceObjectExtension;
        PVOID Reserved;
    } DEVICE_OBJECT, *PDEVICE_OBJECT;

    typedef struct _DEVOBJ_EXTENSION
    {

        CSHORT Type;
        USHORT Size;

        //
        // Public part of the DeviceObjectExtension structure
        //

        PDEVICE_OBJECT DeviceObject; // owning device object

        // end_ntddk end_nthal end_ntifs end_wdm end_ntosp

        //
        // Universal Power Data - all device objects must have this
        //

        ULONG PowerFlags; // see ntos\po\pop.h
        // WARNING: Access via PO macros
        // and with PO locking rules ONLY.

        //
        // Pointer to the non-universal power data
        //  Power data that only some device objects need is stored in the
        //  device object power extension -> DOPE
        //  see po.h
        //

        struct _DEVICE_OBJECT_POWER_EXTENSION* Dope;

        //
        // power state information
        //

        //
        // Device object extension flags.  Protected by the IopDatabaseLock.
        //

        ULONG ExtensionFlags;

        //
        // PnP manager fields
        //

        PVOID DeviceNode;

        //
        // AttachedTo is a pointer to the device object that this device
        // object is attached to.  The attachment chain is now doubly
        // linked: this pointer and DeviceObject->AttachedDevice provide the
        // linkage.
        //

        PDEVICE_OBJECT AttachedTo;

        //
        // The next two fields are used to prevent recursion in IoStartNextPacket
        // interfaces.
        //

        LONG StartIoCount;  // Used to keep track of number of pending start ios.
        LONG StartIoKey;    // Next startio key
        ULONG StartIoFlags; // Start Io Flags. Need a separate flag so that it can be accessed without locks
        PVPB Vpb;           // If not NULL contains the VPB of the mounted volume.
                            // Set in the filesystem's volume device object.
                            // This is a reverse VPB pointer.

        // begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntosp

    } DEVOBJ_EXTENSION, *PDEVOBJ_EXTENSION;

    typedef struct _FAST_IO_DISPATCH
    {
        ULONG SizeOfFastIoDispatch;
        PVOID FastIoCheckIfPossible;
        PVOID FastIoRead;
        PVOID FastIoWrite;
        PVOID FastIoQueryBasicInfo;
        PVOID FastIoQueryStandardInfo;
        PVOID FastIoLock;
        PVOID FastIoUnlockSingle;
        PVOID FastIoUnlockAll;
        PVOID FastIoUnlockAllByKey;
        PVOID FastIoDeviceControl;
        PVOID AcquireFileForNtCreateSection;
        PVOID ReleaseFileForNtCreateSection;
        PVOID FastIoDetachDevice;
        PVOID FastIoQueryNetworkOpenInfo;
        PVOID AcquireForModWrite;
        PVOID MdlRead;
        PVOID MdlReadComplete;
        PVOID PrepareMdlWrite;
        PVOID MdlWriteComplete;
        PVOID FastIoReadCompressed;
        PVOID FastIoWriteCompressed;
        PVOID MdlReadCompleteCompressed;
        PVOID MdlWriteCompleteCompressed;
        PVOID FastIoQueryOpen;
        PVOID ReleaseForModWrite;
        PVOID AcquireForCcFlush;
        PVOID ReleaseForCcFlush;
    } FAST_IO_DISPATCH, *PFAST_IO_DISPATCH;

#define IO_TYPE_ADAPTER 0x00000001
#define IO_TYPE_CONTROLLER 0x00000002
#define IO_TYPE_DEVICE 0x00000003
#define IO_TYPE_DRIVER 0x00000004
#define IO_TYPE_FILE 0x00000005
#define IO_TYPE_IRP 0x00000006
#define IO_TYPE_MASTER_ADAPTER 0x00000007
#define IO_TYPE_OPEN_PACKET 0x00000008
#define IO_TYPE_TIMER 0x00000009
#define IO_TYPE_VPB 0x0000000a
#define IO_TYPE_ERROR_LOG 0x0000000b
#define IO_TYPE_ERROR_MESSAGE 0x0000000c
#define IO_TYPE_DEVICE_OBJECT_EXTENSION 0x0000000d

#define IRP_MJ_CREATE 0x00
#define IRP_MJ_CREATE_NAMED_PIPE 0x01
#define IRP_MJ_CLOSE 0x02
#define IRP_MJ_READ 0x03
#define IRP_MJ_WRITE 0x04
#define IRP_MJ_QUERY_INFORMATION 0x05
#define IRP_MJ_SET_INFORMATION 0x06
#define IRP_MJ_QUERY_EA 0x07
#define IRP_MJ_SET_EA 0x08
#define IRP_MJ_FLUSH_BUFFERS 0x09
#define IRP_MJ_QUERY_VOLUME_INFORMATION 0x0a
#define IRP_MJ_SET_VOLUME_INFORMATION 0x0b
#define IRP_MJ_DIRECTORY_CONTROL 0x0c
#define IRP_MJ_FILE_SYSTEM_CONTROL 0x0d
#define IRP_MJ_DEVICE_CONTROL 0x0e
#define IRP_MJ_INTERNAL_DEVICE_CONTROL 0x0f
#define IRP_MJ_SHUTDOWN 0x10
#define IRP_MJ_LOCK_CONTROL 0x11
#define IRP_MJ_CLEANUP 0x12
#define IRP_MJ_CREATE_MAILSLOT 0x13
#define IRP_MJ_QUERY_SECURITY 0x14
#define IRP_MJ_SET_SECURITY 0x15
#define IRP_MJ_POWER 0x16
#define IRP_MJ_SYSTEM_CONTROL 0x17
#define IRP_MJ_DEVICE_CHANGE 0x18
#define IRP_MJ_QUERY_QUOTA 0x19
#define IRP_MJ_SET_QUOTA 0x1a
#define IRP_MJ_PNP 0x1b
#define IRP_MJ_PNP_POWER IRP_MJ_PNP
#define IRP_MJ_MAXIMUM_FUNCTION 0x1b

    typedef struct _DRIVER_EXTENSION
    {

        //
        // Back pointer to Driver Object
        //

        struct _DRIVER_OBJECT* DriverObject;

        //
        // The AddDevice entry point is called by the Plug & Play manager
        // to inform the driver when a new device instance arrives that this
        // driver must control.
        //

        PVOID AddDevice;

        //
        // The count field is used to count the number of times the driver has
        // had its registered reinitialization routine invoked.
        //

        ULONG Count;

        //
        // The service name field is used by the pnp manager to determine
        // where the driver related info is stored in the registry.
        //

        UNICODE_STRING ServiceKeyName;

    } DRIVER_EXTENSION, *PDRIVER_EXTENSION;

#define DRVO_UNLOAD_INVOKED 0x00000001
#define DRVO_LEGACY_DRIVER 0x00000002
#define DRVO_BUILTIN_DRIVER 0x00000004 // Driver objects for Hal, PnP Mgr
#define DRVO_REINIT_REGISTERED 0x00000008
#define DRVO_INITIALIZED 0x00000010
#define DRVO_BOOTREINIT_REGISTERED 0x00000020
#define DRVO_LEGACY_RESOURCES 0x00000040
    // end_ntddk end_nthal end_ntifs end_ntosp
#define DRVO_BASE_FILESYSTEM_DRIVER                                                                                    \
    0x00000080 // A driver that is at the bottom of the filesystem stack.
               // begin_ntddk begin_nthal begin_ntifs begin_ntosp

    typedef struct _DRIVER_OBJECT
    {
        CSHORT Type;
        CSHORT Size;

        //
        // The following links all of the devices created by a single driver
        // together on a list, and the Flags word provides an extensible flag
        // location for driver objects.
        //

        PDEVICE_OBJECT DeviceObject;
        ULONG Flags;

        //
        // The following section describes where the driver is loaded.  The count
        // field is used to count the number of times the driver has had its
        // registered reinitialization routine invoked.
        //

        PVOID DriverStart;
        ULONG DriverSize;
        PVOID DriverSection; // PLDR_DATA_TABLE_ENTRY
        PDRIVER_EXTENSION DriverExtension;

        //
        // The driver name field is used by the error log thread
        // determine the name of the driver that an I/O request is/was bound.
        //

        UNICODE_STRING DriverName;

        //
        // The following section is for registry support.  Thise is a pointer
        // to the path to the hardware information in the registry
        //

        PUNICODE_STRING HardwareDatabase;

        //
        // The following section contains the optional pointer to an array of
        // alternate entry points to a driver for "fast I/O" support.  Fast I/O
        // is performed by invoking the driver routine directly with separate
        // parameters, rather than using the standard IRP call mechanism.  Note
        // that these functions may only be used for synchronous I/O, and when
        // the file is cached.
        //

        PFAST_IO_DISPATCH FastIoDispatch;

        //
        // The following section describes the entry points to this particular
        // driver.  Note that the major function dispatch table must be the last
        // field in the object so that it remains extensible.
        //

        PVOID DriverInit;
        PVOID DriverStartIo;
        PVOID DriverUnload;
        PVOID MajorFunction[IRP_MJ_MAXIMUM_FUNCTION + 1];

    } DRIVER_OBJECT;
    typedef struct _DRIVER_OBJECT* PDRIVER_OBJECT;

#define RESOURCE_TYPE_LEVEL 0
#define RESOURCE_NAME_LEVEL 1
#define RESOURCE_LANGUAGE_LEVEL 2
#define RESOURCE_DATA_LEVEL 3

    typedef struct _LDR_RESOURCE_INFO
    {
        ULONG_PTR Type;
        ULONG_PTR Name;
        ULONG Lang;
    } LDR_RESOURCE_INFO, *PLDR_RESOURCE_INFO;

    typedef struct _LDR_DATA_TABLE_ENTRY_COMPATIBLE
    {
        LIST_ENTRY InLoadOrderLinks;
        LIST_ENTRY InMemoryOrderLinks;
        union
        {
            LIST_ENTRY InInitializationOrderLinks;
            LIST_ENTRY InProgressLinks;
        } DUMMYUNION0;
        PVOID DllBase;
        PVOID EntryPoint;
        ULONG SizeOfImage;
        UNICODE_STRING FullDllName;
        UNICODE_STRING BaseDllName;
        union
        {
            ULONG Flags;
            struct
            {
                ULONG PackagedBinary          : 1; // Size=4 Offset=104 BitOffset=0 BitCount=1
                ULONG MarkedForRemoval        : 1; // Size=4 Offset=104 BitOffset=1 BitCount=1
                ULONG ImageDll                : 1; // Size=4 Offset=104 BitOffset=2 BitCount=1
                ULONG LoadNotificationsSent   : 1; // Size=4 Offset=104 BitOffset=3 BitCount=1
                ULONG TelemetryEntryProcessed : 1; // Size=4 Offset=104 BitOffset=4 BitCount=1
                ULONG ProcessStaticImport     : 1; // Size=4 Offset=104 BitOffset=5 BitCount=1
                ULONG InLegacyLists           : 1; // Size=4 Offset=104 BitOffset=6 BitCount=1
                ULONG InIndexes               : 1; // Size=4 Offset=104 BitOffset=7 BitCount=1
                ULONG ShimDll                 : 1; // Size=4 Offset=104 BitOffset=8 BitCount=1
                ULONG InExceptionTable        : 1; // Size=4 Offset=104 BitOffset=9 BitCount=1
                ULONG ReservedFlags1          : 2; // Size=4 Offset=104 BitOffset=10 BitCount=2
                ULONG LoadInProgress          : 1; // Size=4 Offset=104 BitOffset=12 BitCount=1
                ULONG LoadConfigProcessed     : 1; // Size=4 Offset=104 BitOffset=13 BitCount=1
                ULONG EntryProcessed          : 1; // Size=4 Offset=104 BitOffset=14 BitCount=1
                ULONG ProtectDelayLoad        : 1; // Size=4 Offset=104 BitOffset=15 BitCount=1
                ULONG ReservedFlags3          : 2; // Size=4 Offset=104 BitOffset=16 BitCount=2
                ULONG DontCallForThreads      : 1; // Size=4 Offset=104 BitOffset=18 BitCount=1
                ULONG ProcessAttachCalled     : 1; // Size=4 Offset=104 BitOffset=19 BitCount=1
                ULONG ProcessAttachFailed     : 1; // Size=4 Offset=104 BitOffset=20 BitCount=1
                ULONG CorDeferredValidate     : 1; // Size=4 Offset=104 BitOffset=21 BitCount=1
                ULONG CorImage                : 1; // Size=4 Offset=104 BitOffset=22 BitCount=1
                ULONG DontRelocate            : 1; // Size=4 Offset=104 BitOffset=23 BitCount=1
                ULONG CorILOnly               : 1; // Size=4 Offset=104 BitOffset=24 BitCount=1
                ULONG ChpeImage               : 1; // Size=4 Offset=104 BitOffset=25 BitCount=1
                ULONG ReservedFlags5          : 2; // Size=4 Offset=104 BitOffset=26 BitCount=2
                ULONG Redirected              : 1; // Size=4 Offset=104 BitOffset=28 BitCount=1
                ULONG ReservedFlags6          : 2; // Size=4 Offset=104 BitOffset=29 BitCount=2
                ULONG CompatDatabaseProcessed : 1; // Size=4 Offset=104 BitOffset=31 BitCount=1
            };
        } ENTRYFLAGSUNION;
        WORD ObsoleteLoadCount;
        WORD TlsIndex;
        union
        {
            LIST_ENTRY HashLinks;
            struct
            {
                PVOID SectionPointer;
                ULONG CheckSum;
            };
        } DUMMYUNION1;
        union
        {
            ULONG TimeDateStamp;
            PVOID LoadedImports;
        } DUMMYUNION2;
        // fields below removed for compatibility
    } LDR_DATA_TABLE_ENTRY_COMPATIBLE, *PLDR_DATA_TABLE_ENTRY_COMPATIBLE;
    typedef LDR_DATA_TABLE_ENTRY_COMPATIBLE LDR_DATA_TABLE_ENTRY;
    typedef LDR_DATA_TABLE_ENTRY_COMPATIBLE* PLDR_DATA_TABLE_ENTRY;
    typedef LDR_DATA_TABLE_ENTRY* PCLDR_DATA_TABLE_ENTRY;

    typedef struct _LDR_DLL_LOADED_NOTIFICATION_DATA
    {
        ULONG Flags;                  // Reserved.
        PCUNICODE_STRING FullDllName; // The full path name of the DLL module.
        PCUNICODE_STRING BaseDllName; // The base file name of the DLL module.
        PVOID DllBase;                // A pointer to the base address for the DLL in memory.
        ULONG SizeOfImage;            // The size of the DLL image, in bytes.
    } LDR_DLL_LOADED_NOTIFICATION_DATA, *PLDR_DLL_LOADED_NOTIFICATION_DATA;

    typedef struct _LDR_DLL_UNLOADED_NOTIFICATION_DATA
    {
        ULONG Flags;                  // Reserved.
        PCUNICODE_STRING FullDllName; // The full path name of the DLL module.
        PCUNICODE_STRING BaseDllName; // The base file name of the DLL module.
        PVOID DllBase;                // A pointer to the base address for the DLL in memory.
        ULONG SizeOfImage;            // The size of the DLL image, in bytes.
    } LDR_DLL_UNLOADED_NOTIFICATION_DATA, *PLDR_DLL_UNLOADED_NOTIFICATION_DATA;

    typedef union _LDR_DLL_NOTIFICATION_DATA
    {
        LDR_DLL_LOADED_NOTIFICATION_DATA Loaded;
        LDR_DLL_UNLOADED_NOTIFICATION_DATA Unloaded;
    } LDR_DLL_NOTIFICATION_DATA, *PLDR_DLL_NOTIFICATION_DATA;
    typedef const LDR_DLL_NOTIFICATION_DATA* PCLDR_DLL_NOTIFICATION_DATA;

#define LDR_DLL_NOTIFICATION_REASON_LOADED 1
#define LDR_DLL_NOTIFICATION_REASON_UNLOADED 2

    typedef enum _LDR_DLL_LOAD_REASON
    {
        LoadReasonStaticDependency,
        LoadReasonStaticForwarderDependency,
        LoadReasonDynamicForwarderDependency,
        LoadReasonDelayloadDependency,
        LoadReasonDynamicLoad,
        LoadReasonAsImageLoad,
        LoadReasonAsDataLoad,
        LoadReasonEnclavePrimary,
        LoadReasonEnclaveDependency,
        LoadReasonUnknown = -1
    } LDR_DLL_LOAD_REASON, *PLDR_DLL_LOAD_REASON;

    /*
     * WDM END
     */


    /*
    ** Callbacks START
    */

    typedef struct _EX_CALLBACK
    {
        EX_FAST_REF RoutineBlock;
    } EX_CALLBACK, *PEX_CALLBACK;

    typedef struct _EX_CALLBACK_ROUTINE_BLOCK
    {
        EX_RUNDOWN_REF RundownProtect;
        PVOID Function; // PEX_CALLBACK_FUNCTION
        PVOID Context;
    } EX_CALLBACK_ROUTINE_BLOCK, *PEX_CALLBACK_ROUTINE_BLOCK;

    typedef struct _KBUGCHECK_CALLBACK_RECORD
    {
        LIST_ENTRY Entry;
        PVOID CallbackRoutine;
        PVOID Buffer;
        ULONG Length;
        PUCHAR Component;
        ULONG_PTR Checksum;
        UCHAR State;
    } KBUGCHECK_CALLBACK_RECORD, *PKBUGCHECK_CALLBACK_RECORD;

    typedef enum _KBUGCHECK_CALLBACK_REASON
    {
        KbCallbackInvalid,
        KbCallbackReserved1,
        KbCallbackSecondaryDumpData,
        KbCallbackDumpIo,
        KbCallbackAddPages,
        KbCallbackSecondaryMultiPartDumpData,
        KbCallbackRemovePages,
        KbCallbackTriageDumpData
    } KBUGCHECK_CALLBACK_REASON;

    typedef struct _KBUGCHECK_REASON_CALLBACK_RECORD
    {
        LIST_ENTRY Entry;
        PVOID CallbackRoutine;
        PUCHAR Component;
        ULONG_PTR Checksum;
        KBUGCHECK_CALLBACK_REASON Reason;
        UCHAR State;
    } KBUGCHECK_REASON_CALLBACK_RECORD, *PKBUGCHECK_REASON_CALLBACK_RECORD;

    typedef struct _CM_CALLBACK_CONTEXT_BLOCK
    {
        LIST_ENTRY CallbackListEntry;
        LIST_ENTRY PreCallListHead;
        PVOID Unknown1;
        PVOID Function; // PEX_CALLBACK_FUNCTION
        UNICODE_STRING Altitude;
        LIST_ENTRY ObjectContextListHead;
    } CM_CALLBACK_CONTEXT_BLOCK, *PCM_CALLBACK_CONTEXT_BLOCK;

    typedef struct _SEP_LOGON_SESSION_TERMINATED_NOTIFICATION
    {
        struct _SEP_LOGON_SESSION_TERMINATED_NOTIFICATION* Next;
        PVOID CallbackRoutine; // PSE_LOGON_SESSION_TERMINATED_ROUTINE
    } SEP_LOGON_SESSION_TERMINATED_NOTIFICATION, *PSEP_LOGON_SESSION_TERMINATED_NOTIFICATION;

    typedef struct _NOTIFICATION_PACKET
    {
        LIST_ENTRY ListEntry;
        PVOID DriverObject;        // PDRIVER_OBJECT
        PVOID NotificationRoutine; // PDRIVER_FS_NOTIFICATION
    } NOTIFICATION_PACKET, *PNOTIFICATION_PACKET;

    typedef struct _SHUTDOWN_PACKET
    {
        LIST_ENTRY ListEntry;
        PVOID DeviceObject; // PDEVICE_OBJECT
    } SHUTDOWN_PACKET, *PSHUTDOWN_PACKET;

#define EX_CALLBACK_SIGNATURE 'llaC'

    typedef struct _CALLBACK_OBJECT
    {
        ULONG Signature;
        KSPIN_LOCK Lock;
        LIST_ENTRY RegisteredCallbacks;
        BOOLEAN AllowMultipleCallbacks;
        UCHAR reserved[3];
    } CALLBACK_OBJECT, *PCALLBACK_OBJECT;

    typedef struct _CALLBACK_REGISTRATION
    {
        LIST_ENTRY Link;
        PCALLBACK_OBJECT CallbackObject;
        PVOID CallbackFunction; // PCALLBACK_FUNCTION
        PVOID CallbackContext;
        ULONG Busy;
        BOOLEAN UnregisterWaiting;
    } CALLBACK_REGISTRATION, *PCALLBACK_REGISTRATION;

    typedef ULONG OB_OPERATION;

    typedef struct _OB_CALLBACK_CONTEXT_BLOCK
    {
        LIST_ENTRY CallbackListEntry;
        OB_OPERATION Operations;
        ULONG Flags;
        PVOID Registration; // POB_CALLBACK_REGISTRATION
        POBJECT_TYPE ObjectType;
        PVOID PreCallback;  // POB_PRE_OPERATION_CALLBACK
        PVOID PostCallback; // POB_POST_OPERATION_CALLBACK
        EX_RUNDOWN_REF RundownReference;
    } OB_CALLBACK_CONTEXT_BLOCK, *POB_CALLBACK_CONTEXT_BLOCK;

    typedef struct _OB_OPERATION_REGISTRATION
    {
        PVOID* ObjectType;
        OB_OPERATION Operations;
        PVOID PreOperation;
        PVOID PostOperation;
    } OB_OPERATION_REGISTRATION, *POB_OPERATION_REGISTRATION;

    typedef struct _OB_CALLBACK_REGISTRATION
    {
        USHORT Version;
        USHORT OperationRegistrationCount;
        UNICODE_STRING Altitude;
        PVOID RegistrationContext;
        OB_OPERATION_REGISTRATION* OperationRegistration;
    } OB_CALLBACK_REGISTRATION, *POB_CALLBACK_REGISTRATION;

#define PO_POWER_SETTINGS_REGISTRATION_TAG 'teSP'

    typedef struct _POP_POWER_SETTING_REGISTRATION_V1
    {
        LIST_ENTRY Link;
        ULONG Tag;
        PVOID CallbackThread; // PKTHREAD
        UCHAR UnregisterOnReturn;
        UCHAR UnregisterPending;
        GUID Guid;
        PVOID LastValue; // PPOP_POWER_SETTING_VALUE
        PVOID Callback;
        PVOID Context;
        PDEVICE_OBJECT DeviceObject;
    } POP_POWER_SETTING_REGISTRATION_V1, *PPOP_POWER_SETTING_REGISTRATION_V1;

    //
    // WARNING: this structure definition is incomplete.
    // Tail is incorrect/incomplete for newest Win10 versions.
    //
    typedef struct _POP_POWER_SETTING_REGISTRATION_V2
    {
        LIST_ENTRY Link;
        ULONG Tag;
        PVOID CallbackThread; // PKTHREAD
        UCHAR UnregisterOnReturn;
        UCHAR UnregisterPending;
        GUID Guid;
        GUID Guid2;
        PVOID LastValue; // PPOP_POWER_SETTING_VALUE
        PVOID Callback;
        PVOID Context;
        PDEVICE_OBJECT DeviceObject;
    } POP_POWER_SETTING_REGISTRATION_V2, *PPOP_POWER_SETTING_REGISTRATION_V2;

    typedef struct _RTL_CALLBACK_REGISTER
    {
        ULONG Flags;
        EX_RUNDOWN_REF RundownReference;
        PVOID DebugPrintCallback;
        LIST_ENTRY ListEntry;
    } RTL_CALLBACK_REGISTER, *PRTL_CALLBACK_REGISTER;

    /*
    ** Callbacks END
    */

    /*
     *  NTQSI Modules START
     */

    typedef struct _RTL_PROCESS_MODULE_INFORMATION
    {
        HANDLE Section;
        PVOID MappedBase;
        PVOID ImageBase;
        ULONG ImageSize;
        ULONG Flags;
        USHORT LoadOrderIndex;
        USHORT InitOrderIndex;
        USHORT LoadCount;
        USHORT OffsetToFileName;
        UCHAR FullPathName[256];
    } RTL_PROCESS_MODULE_INFORMATION, *PRTL_PROCESS_MODULE_INFORMATION;

    typedef struct _RTL_PROCESS_MODULE_INFORMATION_EX
    {
        USHORT NextOffset;
        RTL_PROCESS_MODULE_INFORMATION BaseInfo;
        ULONG ImageChecksum;
        ULONG TimeDateStamp;
        PVOID DefaultBase;
    } RTL_PROCESS_MODULE_INFORMATION_EX, *PRTL_PROCESS_MODULE_INFORMATION_EX;

    typedef struct _RTL_PROCESS_MODULES
    {
        ULONG NumberOfModules;
        RTL_PROCESS_MODULE_INFORMATION Modules[1];
    } RTL_PROCESS_MODULES, *PRTL_PROCESS_MODULES;

    /*
     *	NTQSI Modules END
     */

    /*
    ** Virtual Memory START
    */

    typedef enum _MEMORY_INFORMATION_CLASS
    {
        MemoryBasicInformation,
        MemoryWorkingSetInformation,
        MemoryMappedFilenameInformation,
        MemoryRegionInformation,
        MemoryWorkingSetExInformation,
        MemorySharedCommitInformation,
        MemoryImageInformation,
        MemoryRegionInformationEx,
        MemoryPrivilegedBasicInformation,
        MemoryEnclaveImageInformation,
        MemoryBasicInformationCapped
    } MEMORY_INFORMATION_CLASS, *PMEMORY_INFORMATION_CLASS;

    typedef enum _VIRTUAL_MEMORY_INFORMATION_CLASS
    {
        VmPrefetchInformation,
        VmPagePriorityInformation,
        VmCfgCallTargetInformation,
        VmPageDirtyStateInformation
    } VIRTUAL_MEMORY_INFORMATION_CLASS;

    typedef struct _MEMORY_REGION_INFORMATION
    {
        PVOID AllocationBase;
        ULONG AllocationProtect;
        union
        {
            ULONG RegionType;
            struct
            {
                ULONG Private         : 1;
                ULONG MappedDataFile  : 1;
                ULONG MappedImage     : 1;
                ULONG MappedPageFile  : 1;
                ULONG MappedPhysical  : 1;
                ULONG DirectMapped    : 1;
                ULONG SoftwareEnclave : 1;
                ULONG PageSize64K     : 1;
                ULONG Reserved        : 24;
            };
        };
        SIZE_T RegionSize;
        // SIZE_T CommitSize;
    } MEMORY_REGION_INFORMATION, *PMEMORY_REGION_INFORMATION;

    typedef struct _MEMORY_RANGE_ENTRY
    {
        PVOID VirtualAddress;
        SIZE_T NumberOfBytes;
    } MEMORY_RANGE_ENTRY, *PMEMORY_RANGE_ENTRY;

    /*
    ** Virtual Memory END
    */

    /*
    ** System Firmware START
    */

    typedef enum _SYSTEM_FIRMWARE_TABLE_ACTION
    {
        SystemFirmwareTable_Enumerate,
        SystemFirmwareTable_Get,
        SystemFirmwareTableMax
    } SYSTEM_FIRMWARE_TABLE_ACTION, *PSYSTEM_FIRMWARE_TABLE_ACTION;

    typedef struct _SYSTEM_FIRMWARE_TABLE_INFORMATION
    {
        ULONG ProviderSignature;
        SYSTEM_FIRMWARE_TABLE_ACTION Action;
        ULONG TableID;
        ULONG TableBufferLength;
        UCHAR TableBuffer[ANYSIZE_ARRAY];
    } SYSTEM_FIRMWARE_TABLE_INFORMATION, *PSYSTEM_FIRMWARE_TABLE_INFORMATION;

    /*
    ** System Firmware END
    */

    //
    //  PEB/TEB
    //
#define GDI_HANDLE_BUFFER_SIZE32 34
#define GDI_HANDLE_BUFFER_SIZE64 60

#if !defined(_M_X64)
#define GDI_HANDLE_BUFFER_SIZE GDI_HANDLE_BUFFER_SIZE32
#else
#define GDI_HANDLE_BUFFER_SIZE GDI_HANDLE_BUFFER_SIZE64
#endif

    typedef ULONG GDI_HANDLE_BUFFER32[GDI_HANDLE_BUFFER_SIZE32];
    typedef ULONG GDI_HANDLE_BUFFER64[GDI_HANDLE_BUFFER_SIZE64];
    typedef ULONG GDI_HANDLE_BUFFER[GDI_HANDLE_BUFFER_SIZE];

#define RTL_MAX_DRIVE_LETTERS 32
#define RTL_DRIVE_LETTER_VALID (USHORT)0x0001

#define GDI_MAX_HANDLE_COUNT 0x4000

    // 32-bit definitions
    typedef struct _STRING32
    {
        USHORT Length;
        USHORT MaximumLength;
        ULONG Buffer;
    } STRING32;
    typedef STRING32* PSTRING32;

    typedef STRING32 UNICODE_STRING32;

#if ( _MSC_VER < 1300 ) && !defined(_WINDOWS_)
    typedef struct LIST_ENTRY32
    {
        DWORD Flink;
        DWORD Blink;
    } LIST_ENTRY32;
    typedef LIST_ENTRY32* PLIST_ENTRY32;

    typedef struct LIST_ENTRY64
    {
        ULONGLONG Flink;
        ULONGLONG Blink;
    } LIST_ENTRY64;
    typedef LIST_ENTRY64* PLIST_ENTRY64;
#endif

#define WOW64_POINTER(Type) ULONG

    typedef struct _PEB_LDR_DATA32
    {
        ULONG Length;
        BOOLEAN Initialized;
        WOW64_POINTER(HANDLE) SsHandle;
        LIST_ENTRY32 InLoadOrderModuleList;
        LIST_ENTRY32 InMemoryOrderModuleList;
        LIST_ENTRY32 InInitializationOrderModuleList;
        WOW64_POINTER(PVOID) EntryInProgress;
        BOOLEAN ShutdownInProgress;
        WOW64_POINTER(HANDLE) ShutdownThreadId;
    } PEB_LDR_DATA32, *PPEB_LDR_DATA32;

#define LDR_DATA_TABLE_ENTRY_SIZE_WINXP32 FIELD_OFFSET(LDR_DATA_TABLE_ENTRY32, ForwarderLinks)

    typedef struct _LDR_DATA_TABLE_ENTRY32
    {
        LIST_ENTRY32 InLoadOrderLinks;
        LIST_ENTRY32 InMemoryOrderLinks;
        LIST_ENTRY32 InInitializationOrderLinks;
        WOW64_POINTER(PVOID) DllBase;
        WOW64_POINTER(PVOID) EntryPoint;
        ULONG SizeOfImage;
        UNICODE_STRING32 FullDllName;
        UNICODE_STRING32 BaseDllName;
        ULONG Flags;
        USHORT LoadCount;
        USHORT TlsIndex;
        union
        {
            LIST_ENTRY32 HashLinks;
            struct
            {
                WOW64_POINTER(PVOID) SectionPointer;
                ULONG CheckSum;
            };
        };
        union
        {
            ULONG TimeDateStamp;
            WOW64_POINTER(PVOID) LoadedImports;
        };
        WOW64_POINTER(PVOID) EntryPointActivationContext;
        WOW64_POINTER(PVOID) PatchInformation;
        LIST_ENTRY32 ForwarderLinks;
        LIST_ENTRY32 ServiceTagLinks;
        LIST_ENTRY32 StaticLinks;
        WOW64_POINTER(PVOID) ContextInformation;
        WOW64_POINTER(ULONG_PTR) OriginalBase;
        LARGE_INTEGER LoadTime;
    } LDR_DATA_TABLE_ENTRY32, *PLDR_DATA_TABLE_ENTRY32;

    typedef struct _CURDIR32
    {
        UNICODE_STRING32 DosPath;
        WOW64_POINTER(HANDLE) Handle;
    } CURDIR32, *PCURDIR32;

    typedef struct _RTL_DRIVE_LETTER_CURDIR32
    {
        USHORT Flags;
        USHORT Length;
        ULONG TimeStamp;
        STRING32 DosPath;
    } RTL_DRIVE_LETTER_CURDIR32, *PRTL_DRIVE_LETTER_CURDIR32;

    typedef struct _RTL_USER_PROCESS_PARAMETERS32
    {
        ULONG MaximumLength;
        ULONG Length;

        ULONG Flags;
        ULONG DebugFlags;

        WOW64_POINTER(HANDLE) ConsoleHandle;
        ULONG ConsoleFlags;
        WOW64_POINTER(HANDLE) StandardInput;
        WOW64_POINTER(HANDLE) StandardOutput;
        WOW64_POINTER(HANDLE) StandardError;

        CURDIR32 CurrentDirectory;
        UNICODE_STRING32 DllPath;
        UNICODE_STRING32 ImagePathName;
        UNICODE_STRING32 CommandLine;
        WOW64_POINTER(PVOID) Environment;

        ULONG StartingX;
        ULONG StartingY;
        ULONG CountX;
        ULONG CountY;
        ULONG CountCharsX;
        ULONG CountCharsY;
        ULONG FillAttribute;

        ULONG WindowFlags;
        ULONG ShowWindowFlags;
        UNICODE_STRING32 WindowTitle;
        UNICODE_STRING32 DesktopInfo;
        UNICODE_STRING32 ShellInfo;
        UNICODE_STRING32 RuntimeData;
        RTL_DRIVE_LETTER_CURDIR32 CurrentDirectories[RTL_MAX_DRIVE_LETTERS];

        ULONG EnvironmentSize;
        ULONG EnvironmentVersion;
    } RTL_USER_PROCESS_PARAMETERS32, *PRTL_USER_PROCESS_PARAMETERS32;

    typedef struct _PEB32
    {
        BOOLEAN InheritedAddressSpace;
        BOOLEAN ReadImageFileExecOptions;
        BOOLEAN BeingDebugged;
        union
        {
            BOOLEAN BitField;
            struct
            {
                BOOLEAN ImageUsesLargePages          : 1;
                BOOLEAN IsProtectedProcess           : 1;
                BOOLEAN IsLegacyProcess              : 1;
                BOOLEAN IsImageDynamicallyRelocated  : 1;
                BOOLEAN SkipPatchingUser32Forwarders : 1;
                BOOLEAN SpareBits                    : 3;
            };
        };
        WOW64_POINTER(HANDLE) Mutant;

        WOW64_POINTER(PVOID) ImageBaseAddress;
        WOW64_POINTER(PPEB_LDR_DATA) Ldr;
        WOW64_POINTER(PRTL_USER_PROCESS_PARAMETERS) ProcessParameters;
        WOW64_POINTER(PVOID) SubSystemData;
        WOW64_POINTER(PVOID) ProcessHeap;
        WOW64_POINTER(PRTL_CRITICAL_SECTION) FastPebLock;
        WOW64_POINTER(PVOID) AtlThunkSListPtr;
        WOW64_POINTER(PVOID) IFEOKey;
        union
        {
            ULONG CrossProcessFlags;
            struct
            {
                ULONG ProcessInJob               : 1;
                ULONG ProcessInitializing        : 1;
                ULONG ProcessUsingVEH            : 1;
                ULONG ProcessUsingVCH            : 1;
                ULONG ProcessUsingFTH            : 1;
                ULONG ProcessPreviouslyThrottled : 1;
                ULONG ProcessCurrentlyThrottled  : 1;
                ULONG ReservedBits0              : 25;
            };
            ULONG EnvironmentUpdateCount;
        };
        union
        {
            WOW64_POINTER(PVOID) KernelCallbackTable;
            WOW64_POINTER(PVOID) UserSharedInfoPtr;
        };
        ULONG SystemReserved[1];
        ULONG AtlThunkSListPtr32;
        WOW64_POINTER(PVOID) ApiSetMap;
        ULONG TlsExpansionCounter;
        WOW64_POINTER(PVOID) TlsBitmap;
        ULONG TlsBitmapBits[2];
        WOW64_POINTER(PVOID) ReadOnlySharedMemoryBase;
        WOW64_POINTER(PVOID) HotpatchInformation;
        WOW64_POINTER(PPVOID) ReadOnlyStaticServerData;
        WOW64_POINTER(PVOID) AnsiCodePageData;
        WOW64_POINTER(PVOID) OemCodePageData;
        WOW64_POINTER(PVOID) UnicodeCaseTableData;

        ULONG NumberOfProcessors;
        ULONG NtGlobalFlag;

        LARGE_INTEGER CriticalSectionTimeout;
        WOW64_POINTER(SIZE_T) HeapSegmentReserve;
        WOW64_POINTER(SIZE_T) HeapSegmentCommit;
        WOW64_POINTER(SIZE_T) HeapDeCommitTotalFreeThreshold;
        WOW64_POINTER(SIZE_T) HeapDeCommitFreeBlockThreshold;

        ULONG NumberOfHeaps;
        ULONG MaximumNumberOfHeaps;
        WOW64_POINTER(PPVOID) ProcessHeaps;

        WOW64_POINTER(PVOID) GdiSharedHandleTable;
        WOW64_POINTER(PVOID) ProcessStarterHelper;
        ULONG GdiDCAttributeList;

        WOW64_POINTER(PRTL_CRITICAL_SECTION) LoaderLock;

        ULONG OSMajorVersion;
        ULONG OSMinorVersion;
        USHORT OSBuildNumber;
        USHORT OSCSDVersion;
        ULONG OSPlatformId;
        ULONG ImageSubsystem;
        ULONG ImageSubsystemMajorVersion;
        ULONG ImageSubsystemMinorVersion;
        WOW64_POINTER(ULONG_PTR) ImageProcessAffinityMask;
        GDI_HANDLE_BUFFER32 GdiHandleBuffer;
        WOW64_POINTER(PVOID) PostProcessInitRoutine;

        WOW64_POINTER(PVOID) TlsExpansionBitmap;
        ULONG TlsExpansionBitmapBits[32];

        ULONG SessionId;

        // Rest of structure not included.
    } PEB32, *PPEB32;

#define GDI_BATCH_BUFFER_SIZE 310

    typedef struct _GDI_TEB_BATCH32
    {
        ULONG Offset;
        WOW64_POINTER(ULONG_PTR) HDC;
        ULONG Buffer[GDI_BATCH_BUFFER_SIZE];
    } GDI_TEB_BATCH32, *PGDI_TEB_BATCH32;

#if ( _MSC_VER < 1300 ) && !defined(_WINDOWS_)
    //
    // 32 and 64 bit specific version for wow64 and the debugger
    //
    typedef struct _NT_TIB32
    {
        DWORD ExceptionList;
        DWORD StackBase;
        DWORD StackLimit;
        DWORD SubSystemTib;
        union
        {
            DWORD FiberData;
            DWORD Version;
        };
        DWORD ArbitraryUserPointer;
        DWORD Self;
    } NT_TIB32, *PNT_TIB32;

    typedef struct _NT_TIB64
    {
        DWORD64 ExceptionList;
        DWORD64 StackBase;
        DWORD64 StackLimit;
        DWORD64 SubSystemTib;
        union
        {
            DWORD64 FiberData;
            DWORD Version;
        };
        DWORD64 ArbitraryUserPointer;
        DWORD64 Self;
    } NT_TIB64, *PNT_TIB64;
#endif

    typedef struct _TEB32
    {
        NT_TIB32 NtTib;

        WOW64_POINTER(PVOID) EnvironmentPointer;
        CLIENT_ID32 ClientId;
        WOW64_POINTER(PVOID) ActiveRpcHandle;
        WOW64_POINTER(PVOID) ThreadLocalStoragePointer;
        WOW64_POINTER(PPEB) ProcessEnvironmentBlock;

        ULONG LastErrorValue;
        ULONG CountOfOwnedCriticalSections;
        WOW64_POINTER(PVOID) CsrClientThread;
        WOW64_POINTER(PVOID) Win32ThreadInfo;
        ULONG User32Reserved[26];
        ULONG UserReserved[5];
        WOW64_POINTER(PVOID) WOW32Reserved;
        LCID CurrentLocale;
        ULONG FpSoftwareStatusRegister;
        WOW64_POINTER(PVOID) SystemReserved1[54];
        NTSTATUS ExceptionCode;
        WOW64_POINTER(PVOID) ActivationContextStackPointer;
        BYTE SpareBytes[36];
        ULONG TxFsContext;

        GDI_TEB_BATCH32 GdiTebBatch;
        CLIENT_ID32 RealClientId;
        WOW64_POINTER(HANDLE) GdiCachedProcessHandle;
        ULONG GdiClientPID;
        ULONG GdiClientTID;
        WOW64_POINTER(PVOID) GdiThreadLocalInfo;
        WOW64_POINTER(ULONG_PTR) Win32ClientInfo[62];
        WOW64_POINTER(PVOID) glDispatchTable[233];
        WOW64_POINTER(ULONG_PTR) glReserved1[29];
        WOW64_POINTER(PVOID) glReserved2;
        WOW64_POINTER(PVOID) glSectionInfo;
        WOW64_POINTER(PVOID) glSection;
        WOW64_POINTER(PVOID) glTable;
        WOW64_POINTER(PVOID) glCurrentRC;
        WOW64_POINTER(PVOID) glContext;

        NTSTATUS LastStatusValue;
        UNICODE_STRING32 StaticUnicodeString;
        WCHAR StaticUnicodeBuffer[261];

        WOW64_POINTER(PVOID) DeallocationStack;
        WOW64_POINTER(PVOID) TlsSlots[64];
        LIST_ENTRY32 TlsLinks;
    } TEB32, *PTEB32;

    typedef struct _PEB_LDR_DATA
    {
        ULONG Length;
        BOOLEAN Initialized;
        HANDLE SsHandle;
        LIST_ENTRY InLoadOrderModuleList;
        LIST_ENTRY InMemoryOrderModuleList;
        LIST_ENTRY InInitializationOrderModuleList;
        PVOID EntryInProgress;
        BOOLEAN ShutdownInProgress;
        HANDLE ShutdownThreadId;
    } PEB_LDR_DATA, *PPEB_LDR_DATA;

    typedef struct _GDI_HANDLE_ENTRY
    {
        union
        {
            PVOID Object;
            PVOID NextFree;
        };
        union
        {
            struct
            {
                USHORT ProcessId;
                USHORT Lock  : 1;
                USHORT Count : 15;
            };
            ULONG Value;
        } Owner;
        USHORT Unique;
        UCHAR Type;
        UCHAR Flags;
        PVOID UserPointer;
    } GDI_HANDLE_ENTRY, *PGDI_HANDLE_ENTRY;

    typedef struct _GDI_SHARED_MEMORY
    {
        GDI_HANDLE_ENTRY Handles[GDI_MAX_HANDLE_COUNT];
    } GDI_SHARED_MEMORY, *PGDI_SHARED_MEMORY;

#ifndef FLS_MAXIMUM_AVAILABLE
#define FLS_MAXIMUM_AVAILABLE 128
#endif
#ifndef TLS_MINIMUM_AVAILABLE
#define TLS_MINIMUM_AVAILABLE 64
#endif
#ifndef TLS_EXPANSION_SLOTS
#define TLS_EXPANSION_SLOTS 1024
#endif

#define DOS_MAX_COMPONENT_LENGTH 255
#define DOS_MAX_PATH_LENGTH (DOS_MAX_COMPONENT_LENGTH + 5)

    typedef struct _CURDIR
    {
        UNICODE_STRING DosPath;
        HANDLE Handle;
    } CURDIR, *PCURDIR;

#define RTL_USER_PROC_CURDIR_CLOSE 0x00000002
#define RTL_USER_PROC_CURDIR_INHERIT 0x00000003

    typedef struct _RTL_DRIVE_LETTER_CURDIR
    {
        USHORT Flags;
        USHORT Length;
        ULONG TimeStamp;
        STRING DosPath;
    } RTL_DRIVE_LETTER_CURDIR, *PRTL_DRIVE_LETTER_CURDIR;

    typedef struct _RTL_USER_PROCESS_PARAMETERS
    {
        ULONG MaximumLength;
        ULONG Length;

        ULONG Flags;
        ULONG DebugFlags;

        HANDLE ConsoleHandle;
        ULONG ConsoleFlags;
        HANDLE StandardInput;
        HANDLE StandardOutput;
        HANDLE StandardError;

        CURDIR CurrentDirectory;
        UNICODE_STRING DllPath;
        UNICODE_STRING ImagePathName;
        UNICODE_STRING CommandLine;
        PVOID Environment;

        ULONG StartingX;
        ULONG StartingY;
        ULONG CountX;
        ULONG CountY;
        ULONG CountCharsX;
        ULONG CountCharsY;
        ULONG FillAttribute;

        ULONG WindowFlags;
        ULONG ShowWindowFlags;
        UNICODE_STRING WindowTitle;
        UNICODE_STRING DesktopInfo;
        UNICODE_STRING ShellInfo;
        UNICODE_STRING RuntimeData;
        RTL_DRIVE_LETTER_CURDIR CurrentDirectories[RTL_MAX_DRIVE_LETTERS];

        ULONG EnvironmentSize;
        ULONG EnvironmentVersion;
        PVOID PackageDependencyData; // 8+
        ULONG ProcessGroupId;
        // ULONG LoaderThreads;
    } RTL_USER_PROCESS_PARAMETERS, *PRTL_USER_PROCESS_PARAMETERS;

    typedef struct _PEB
    {
        BOOLEAN InheritedAddressSpace;
        BOOLEAN ReadImageFileExecOptions;
        BOOLEAN BeingDebugged;
        union
        {
            BOOLEAN BitField;
            struct
            {
                BOOLEAN ImageUsesLargePages          : 1;
                BOOLEAN IsProtectedProcess           : 1;
                BOOLEAN IsImageDynamicallyRelocated  : 1;
                BOOLEAN SkipPatchingUser32Forwarders : 1;
                BOOLEAN IsPackagedProcess            : 1;
                BOOLEAN IsAppContainer               : 1;
                BOOLEAN IsProtectedProcessLight      : 1;
                BOOLEAN IsLongPathAwareProcess       : 1;
            };
        };
        HANDLE Mutant;

        PVOID ImageBaseAddress;
        PPEB_LDR_DATA Ldr;
        PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
        PVOID SubSystemData;
        PVOID ProcessHeap;
        PRTL_CRITICAL_SECTION FastPebLock;
        PVOID AtlThunkSListPtr;
        PVOID IFEOKey;
        union
        {
            ULONG CrossProcessFlags;
            struct
            {
                ULONG ProcessInJob               : 1;
                ULONG ProcessInitializing        : 1;
                ULONG ProcessUsingVEH            : 1;
                ULONG ProcessUsingVCH            : 1;
                ULONG ProcessUsingFTH            : 1;
                ULONG ProcessPreviouslyThrottled : 1;
                ULONG ProcessCurrentlyThrottled  : 1;
                ULONG ProcessImagesHotPatched    : 1;
                ULONG ReservedBits0              : 24;
            };
            ULONG EnvironmentUpdateCount;
        };
        union
        {
            PVOID KernelCallbackTable;
            PVOID UserSharedInfoPtr;
        };
        ULONG SystemReserved[1];
        ULONG AtlThunkSListPtr32;
        PVOID ApiSetMap;
        ULONG TlsExpansionCounter;
        PVOID TlsBitmap;
        ULONG TlsBitmapBits[2];
        PVOID ReadOnlySharedMemoryBase;
        PVOID HotpatchInformation;
        PVOID* ReadOnlyStaticServerData;
        PVOID AnsiCodePageData;
        PVOID OemCodePageData;
        PVOID UnicodeCaseTableData;

        ULONG NumberOfProcessors;
        ULONG NtGlobalFlag;

        LARGE_INTEGER CriticalSectionTimeout;
        SIZE_T HeapSegmentReserve;
        SIZE_T HeapSegmentCommit;
        SIZE_T HeapDeCommitTotalFreeThreshold;
        SIZE_T HeapDeCommitFreeBlockThreshold;

        ULONG NumberOfHeaps;
        ULONG MaximumNumberOfHeaps;
        PVOID* ProcessHeaps;

        PVOID GdiSharedHandleTable;
        PVOID ProcessStarterHelper;
        ULONG GdiDCAttributeList;

        PRTL_CRITICAL_SECTION LoaderLock;

        ULONG OSMajorVersion;
        ULONG OSMinorVersion;
        USHORT OSBuildNumber;
        USHORT OSCSDVersion;
        ULONG OSPlatformId;
        ULONG ImageSubsystem;
        ULONG ImageSubsystemMajorVersion;
        ULONG ImageSubsystemMinorVersion;
        ULONG_PTR ImageProcessAffinityMask;
        GDI_HANDLE_BUFFER GdiHandleBuffer;
        PVOID PostProcessInitRoutine;

        PVOID TlsExpansionBitmap;
        ULONG TlsExpansionBitmapBits[32];

        ULONG SessionId;

        ULARGE_INTEGER AppCompatFlags;
        ULARGE_INTEGER AppCompatFlagsUser;
        PVOID pShimData;
        PVOID AppCompatInfo;

        UNICODE_STRING CSDVersion;

        PVOID ActivationContextData;
        PVOID ProcessAssemblyStorageMap;
        PVOID SystemDefaultActivationContextData;
        PVOID SystemAssemblyStorageMap;

        SIZE_T MinimumStackCommit;

        PVOID* FlsCallback;
        LIST_ENTRY FlsListHead;
        PVOID FlsBitmap;
        ULONG FlsBitmapBits[FLS_MAXIMUM_AVAILABLE / (sizeof(ULONG) * 8)];
        ULONG FlsHighIndex;

        PVOID WerRegistrationData;
        PVOID WerShipAssertPtr;
        PVOID pContextData;
        PVOID pImageHeaderHash;
        union
        {
            ULONG TracingFlags;
            struct
            {
                ULONG HeapTracingEnabled      : 1;
                ULONG CritSecTracingEnabled   : 1;
                ULONG LibLoaderTracingEnabled : 1;
                ULONG SpareTracingBits        : 29;
            };
        };
        ULONGLONG CsrServerReadOnlySharedMemoryBase;
    } PEB, *PPEB;

    typedef struct _TEB_ACTIVE_FRAME_CONTEXT
    {
        ULONG Flags;
        PSTR FrameName;
    } TEB_ACTIVE_FRAME_CONTEXT, *PTEB_ACTIVE_FRAME_CONTEXT;

    typedef struct _TEB_ACTIVE_FRAME
    {
        ULONG Flags;
        struct _TEB_ACTIVE_FRAME* Previous;
        PTEB_ACTIVE_FRAME_CONTEXT Context;
    } TEB_ACTIVE_FRAME, *PTEB_ACTIVE_FRAME;

#define GDI_BATCH_BUFFER_SIZE 310

    typedef struct _GDI_TEB_BATCH
    {
        ULONG Offset;
        UCHAR Alignment[4];
        ULONG_PTR HDC;
        ULONG Buffer[GDI_BATCH_BUFFER_SIZE];
    } GDI_TEB_BATCH, *PGDI_TEB_BATCH;

    typedef struct _TEB
    {
        NT_TIB NtTib;

        PVOID EnvironmentPointer;
        CLIENT_ID ClientId;
        PVOID ActiveRpcHandle;
        PVOID ThreadLocalStoragePointer;
        PPEB ProcessEnvironmentBlock;

        ULONG LastErrorValue;
        ULONG CountOfOwnedCriticalSections;
        PVOID CsrClientThread;
        PVOID Win32ThreadInfo;
        ULONG User32Reserved[26];
        ULONG UserReserved[5];
        PVOID WOW32Reserved;
        LCID CurrentLocale;
        ULONG FpSoftwareStatusRegister;
        PVOID SystemReserved1[54];
        NTSTATUS ExceptionCode;
        PVOID ActivationContextStackPointer;
#if defined(_M_X64)
        UCHAR SpareBytes[24];
#else
    UCHAR SpareBytes[36];
#endif
        ULONG TxFsContext;

        GDI_TEB_BATCH GdiTebBatch;
        CLIENT_ID RealClientId;
        HANDLE GdiCachedProcessHandle;
        ULONG GdiClientPID;
        ULONG GdiClientTID;
        PVOID GdiThreadLocalInfo;
        ULONG_PTR Win32ClientInfo[62];
        PVOID glDispatchTable[233];
        ULONG_PTR glReserved1[29];
        PVOID glReserved2;
        PVOID glSectionInfo;
        PVOID glSection;
        PVOID glTable;
        PVOID glCurrentRC;
        PVOID glContext;

        NTSTATUS LastStatusValue;
        UNICODE_STRING StaticUnicodeString;
        WCHAR StaticUnicodeBuffer[261];

        PVOID DeallocationStack;
        PVOID TlsSlots[64];
        LIST_ENTRY TlsLinks;

        PVOID Vdm;
        PVOID ReservedForNtRpc;
        PVOID DbgSsReserved[2];

        ULONG HardErrorMode;
#if defined(_M_X64)
        PVOID Instrumentation[11];
#else
    PVOID Instrumentation[9];
#endif
        GUID ActivityId;

        PVOID SubProcessTag;
        PVOID EtwLocalData;
        PVOID EtwTraceData;
        PVOID WinSockData;
        ULONG GdiBatchCount;

        union
        {
            PROCESSOR_NUMBER CurrentIdealProcessor;
            ULONG IdealProcessorValue;
            struct
            {
                UCHAR ReservedPad0;
                UCHAR ReservedPad1;
                UCHAR ReservedPad2;
                UCHAR IdealProcessor;
            };
        };

        ULONG GuaranteedStackBytes;
        PVOID ReservedForPerf;
        PVOID ReservedForOle;
        ULONG WaitingOnLoaderLock;
        PVOID SavedPriorityState;
        ULONG_PTR SoftPatchPtr1;
        PVOID ThreadPoolData;
        PVOID* TlsExpansionSlots;
#if defined(_M_X64)
        PVOID DeallocationBStore;
        PVOID BStoreLimit;
#endif
        ULONG MuiGeneration;
        ULONG IsImpersonating;
        PVOID NlsCache;
        PVOID pShimData;
        ULONG HeapVirtualAffinity;
        HANDLE CurrentTransactionHandle;
        PTEB_ACTIVE_FRAME ActiveFrame;
        PVOID FlsData;

        PVOID PreferredLanguages;
        PVOID UserPrefLanguages;
        PVOID MergedPrefLanguages;
        ULONG MuiImpersonation;

        union
        {
            USHORT CrossTebFlags;
            USHORT SpareCrossTebBits : 16;
        };
        union
        {
            USHORT SameTebFlags;
            struct
            {
                USHORT SafeThunkCall        : 1;
                USHORT InDebugPrint         : 1;
                USHORT HasFiberData         : 1;
                USHORT SkipThreadAttach     : 1;
                USHORT WerInShipAssertCode  : 1;
                USHORT RanProcessInit       : 1;
                USHORT ClonedThread         : 1;
                USHORT SuppressDebugMsg     : 1;
                USHORT DisableUserStackWalk : 1;
                USHORT RtlExceptionAttached : 1;
                USHORT InitialThread        : 1;
                USHORT SpareSameTebBits     : 1;
            };
        };

        PVOID TxnScopeEnterCallback;
        PVOID TxnScopeExitCallback;
        PVOID TxnScopeContext;
        ULONG LockCount;
        ULONG SpareUlong0;
        PVOID ResourceRetValue;
    } TEB, *PTEB;

    typedef struct _PROCESS_DEVICEMAP_INFORMATION
    {
        union
        {
            struct
            {
                HANDLE DirectoryHandle;
            } Set;
            struct
            {
                ULONG DriveMap;
                UCHAR DriveType[32];
            } Query;
        };
    } PROCESS_DEVICEMAP_INFORMATION, *PPROCESS_DEVICEMAP_INFORMATION;

    __inline struct _PEB*
    NtCurrentPeb()
    {
        return NtCurrentTeb()->ProcessEnvironmentBlock;
    }

    /*
    ** PEB/TEB END
    */

    /*
    **  MITIGATION POLICY START
    */

    // redefine enum

#define ProcessDEPPolicy 0
#define ProcessASLRPolicy 1
#define ProcessDynamicCodePolicy 2
#define ProcessStrictHandleCheckPolicy 3
#define ProcessSystemCallDisablePolicy 4
#define ProcessMitigationOptionsMask 5
#define ProcessExtensionPointDisablePolicy 6
#define ProcessControlFlowGuardPolicy 7
#define ProcessSignaturePolicy 8
#define ProcessFontDisablePolicy 9
#define ProcessImageLoadPolicy 10
#define ProcessSystemCallFilterPolicy 11
#define ProcessPayloadRestrictionPolicy 12
#define ProcessChildProcessPolicy 13
#define ProcessSideChannelIsolationPolicy 14

    typedef struct tagPROCESS_MITIGATION_BINARY_SIGNATURE_POLICY_W10
    {
        union
        {
            DWORD Flags;
            struct
            {
                DWORD MicrosoftSignedOnly      : 1;
                DWORD StoreSignedOnly          : 1;
                DWORD MitigationOptIn          : 1;
                DWORD AuditMicrosoftSignedOnly : 1;
                DWORD AuditStoreSignedOnly     : 1;
                DWORD ReservedFlags            : 27;
            } DUMMYSTRUCTNAME;
        } DUMMYUNIONNAME;
    } PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY_W10, *PPROCESS_MITIGATION_BINARY_SIGNATURE_POLICY_W10;

    typedef struct tagPROCESS_MITIGATION_DYNAMIC_CODE_POLICY_W10
    {
        union
        {
            DWORD Flags;
            struct
            {
                DWORD ProhibitDynamicCode      : 1;
                DWORD AllowThreadOptOut        : 1;
                DWORD AllowRemoteDowngrade     : 1;
                DWORD AuditProhibitDynamicCode : 1;
                DWORD ReservedFlags            : 28;
            } DUMMYSTRUCTNAME;
        } DUMMYUNIONNAME;
    } PROCESS_MITIGATION_DYNAMIC_CODE_POLICY_W10, *PPROCESS_MITIGATION_DYNAMIC_CODE_POLICY_W10;

    typedef struct tagPROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY_W10
    {
        union
        {
            DWORD Flags;
            struct
            {
                DWORD EnableControlFlowGuard  : 1;
                DWORD EnableExportSuppression : 1;
                DWORD StrictMode              : 1;
                DWORD ReservedFlags           : 29;
            } DUMMYSTRUCTNAME;
        } DUMMYUNIONNAME;
    } PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY_W10, *PPROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY_W10;

    typedef struct tagPROCESS_MITIGATION_FONT_DISABLE_POLICY_W10
    {
        union
        {
            DWORD Flags;
            struct
            {
                DWORD DisableNonSystemFonts     : 1;
                DWORD AuditNonSystemFontLoading : 1;
                DWORD ReservedFlags             : 30;
            } DUMMYSTRUCTNAME;
        } DUMMYUNIONNAME;
    } PROCESS_MITIGATION_FONT_DISABLE_POLICY_W10, *PPROCESS_MITIGATION_FONT_DISABLE_POLICY_W10;

    typedef struct tagPROCESS_MITIGATION_IMAGE_LOAD_POLICY_W10
    {
        union
        {
            DWORD Flags;
            struct
            {
                DWORD NoRemoteImages                 : 1;
                DWORD NoLowMandatoryLabelImages      : 1;
                DWORD PreferSystem32Images           : 1;
                DWORD AuditNoRemoteImages            : 1;
                DWORD AuditNoLowMandatoryLabelImages : 1;
                DWORD ReservedFlags                  : 27;
            } DUMMYSTRUCTNAME;
        } DUMMYUNIONNAME;
    } PROCESS_MITIGATION_IMAGE_LOAD_POLICY_W10, *PPROCESS_MITIGATION_IMAGE_LOAD_POLICY_W10;

    typedef struct tagPROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY_W10
    {
        union
        {
            ULONG Flags;
            struct
            {
                ULONG FilterId      : 4;
                ULONG ReservedFlags : 28;
            } DUMMYSTRUCTNAME;
        } DUMMYUNIONNAME;
    } PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY_W10, *PPROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY_W10;

    typedef struct tagPROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY_W10
    {
        union
        {
            ULONG Flags;
            struct
            {
                ULONG EnableExportAddressFilter     : 1;
                ULONG AuditExportAddressFilter      : 1;
                ULONG EnableExportAddressFilterPlus : 1;
                ULONG AuditExportAddressFilterPlus  : 1;
                ULONG EnableImportAddressFilter     : 1;
                ULONG AuditImportAddressFilter      : 1;
                ULONG EnableRopStackPivot           : 1;
                ULONG AuditRopStackPivot            : 1;
                ULONG EnableRopCallerCheck          : 1;
                ULONG AuditRopCallerCheck           : 1;
                ULONG EnableRopSimExec              : 1;
                ULONG AuditRopSimExec               : 1;
                ULONG ReservedFlags                 : 20;
            } DUMMYSTRUCTNAME;
        } DUMMYUNIONNAME;
    } PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY_W10, *PPROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY_W10;

    typedef struct tagPROCESS_MITIGATION_CHILD_PROCESS_POLICY_W10
    {
        union
        {
            ULONG Flags;
            struct
            {
                ULONG NoChildProcessCreation      : 1;
                ULONG AuditNoChildProcessCreation : 1;
                ULONG AllowSecureProcessCreation  : 1;
                ULONG ReservedFlags               : 29;
            } DUMMYSTRUCTNAME;
        } DUMMYUNIONNAME;
    } PROCESS_MITIGATION_CHILD_PROCESS_POLICY_W10, *PPROCESS_MITIGATION_CHILD_PROCESS_POLICY_W10;

    typedef struct _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY_W10
    {
        union
        {
            DWORD Flags;
            struct
            {
                DWORD SmtBranchTargetIsolation      : 1;
                DWORD IsolateSecurityDomain         : 1;
                DWORD DisablePageCombine            : 1;
                DWORD SpeculativeStoreBypassDisable : 1;
                DWORD ReservedFlags                 : 28;
            } DUMMYSTRUCTNAME;
        } DUMMYUNIONNAME;
    } PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY_W10, *PPROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY_W10;

    typedef struct _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY_W10
    {
        union
        {
            DWORD Flags;
            struct
            {
                DWORD DisallowWin32kSystemCalls      : 1;
                DWORD AuditDisallowWin32kSystemCalls : 1;
                DWORD ReservedFlags                  : 30;
            } DUMMYSTRUCTNAME;
        } DUMMYUNIONNAME;
    } PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY_W10, *PPROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY_W10;

    typedef struct _PROCESS_MITIGATION_POLICY_INFORMATION
    {
        PROCESS_MITIGATION_POLICY Policy;
        union
        {
            PROCESS_MITIGATION_ASLR_POLICY ASLRPolicy;
            PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY StrictHandleCheckPolicy;
            PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY_W10 SystemCallDisablePolicy;
            PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY ExtensionPointDisablePolicy;
            PROCESS_MITIGATION_DYNAMIC_CODE_POLICY_W10 DynamicCodePolicy;
            PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY_W10 ControlFlowGuardPolicy;
            PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY_W10 SignaturePolicy;
            PROCESS_MITIGATION_FONT_DISABLE_POLICY_W10 FontDisablePolicy;
            PROCESS_MITIGATION_IMAGE_LOAD_POLICY_W10 ImageLoadPolicy;
            PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY_W10 SystemCallFilterPolicy;
            PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY_W10 PayloadRestrictionPolicy;
            PROCESS_MITIGATION_CHILD_PROCESS_POLICY_W10 ChildProcessPolicy;
            PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY_W10 SideChannelIsolationPolicy;
        };
    } PROCESS_MITIGATION_POLICY_INFORMATION, *PPROCESS_MITIGATION_POLICY_INFORMATION;

    /*
    **  MITIGATION POLICY END
    */

    /*
    ** KUSER_SHARED_DATA START
    */
#define NX_SUPPORT_POLICY_ALWAYSOFF 0
#define NX_SUPPORT_POLICY_ALWAYSON 1
#define NX_SUPPORT_POLICY_OPTIN 2
#define NX_SUPPORT_POLICY_OPTOUT 3

#include <pshpack4.h>
    typedef struct _KSYSTEM_TIME
    {
        ULONG LowPart;
        LONG High1Time;
        LONG High2Time;
    } KSYSTEM_TIME, *PKSYSTEM_TIME;
#include <poppack.h>

    typedef enum _NT_PRODUCT_TYPE
    {
        NtProductWinNt = 1,
        NtProductLanManNt,
        NtProductServer
    } NT_PRODUCT_TYPE, *PNT_PRODUCT_TYPE;

#define PROCESSOR_FEATURE_MAX 64

    typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE
    {
        StandardDesign, // None == 0 == standard design
        NEC98x86,       // NEC PC98xx series on X86
        EndAlternatives // past end of known alternatives
    } ALTERNATIVE_ARCHITECTURE_TYPE;

    //
    // Define Address of User Shared Data
    //
#define MM_SHARED_USER_DATA_VA 0x000000007FFE0000

//
// WARNING: this definition is OS version dependent.
// Structure maybe incomplete.
//
#include <pshpack4.h>
    typedef struct _KUSER_SHARED_DATA
    {

        ULONG TickCountLowDeprecated;
        ULONG TickCountMultiplier;

        volatile KSYSTEM_TIME InterruptTime;
        volatile KSYSTEM_TIME SystemTime;
        volatile KSYSTEM_TIME TimeZoneBias;

        USHORT ImageNumberLow;
        USHORT ImageNumberHigh;

        WCHAR NtSystemRoot[260];

        ULONG MaxStackTraceDepth;
        ULONG CryptoExponent;
        ULONG TimeZoneId;
        ULONG LargePageMinimum;

        union
        {
            ULONG Reserved2[7];
            struct
            {
                ULONG AitSamplingValue;
                ULONG AppCompatFlag;
                struct
                {
                    ULONG LowPart;
                    ULONG HighPart;
                } RNGSeedVersion;
                ULONG GlobalValidationRunlevel;
                LONG TimeZoneBiasStamp;
                ULONG NtBuildNumber;
            };
        };

        NT_PRODUCT_TYPE NtProductType;
        BOOLEAN ProductTypeIsValid;
        UCHAR Reserved0[1];
        USHORT NativeProcessorArchitecture;

        ULONG NtMajorVersion;
        ULONG NtMinorVersion;

        BOOLEAN ProcessorFeatures[PROCESSOR_FEATURE_MAX];
        ULONG Reserved1;
        ULONG Reserved3;
        volatile ULONG TimeSlip;
        ALTERNATIVE_ARCHITECTURE_TYPE AlternativeArchitecture;
        ULONG AltArchitecturePad;
        LARGE_INTEGER SystemExpirationDate;
        ULONG SuiteMask;
        BOOLEAN KdDebuggerEnabled;

        union
        {
            UCHAR MitigationPolicies;
            struct
            {
                UCHAR NXSupportPolicy             : 2;
                UCHAR SEHValidationPolicy         : 2;
                UCHAR CurDirDevicesSkippedForDlls : 2;
                UCHAR Reserved                    : 2;
            };
        };

        UCHAR Reserved6[2];

        volatile ULONG ActiveConsoleId;
        volatile ULONG DismountCount;
        ULONG ComPlusPackage;
        ULONG LastSystemRITEventTickCount;
        ULONG NumberOfPhysicalPages;
        BOOLEAN SafeBootMode;
        UCHAR VirtualizationFlags;
        UCHAR Reserved12[2];

        union
        {
            ULONG SharedDataFlags;
            struct
            {
                ULONG DbgErrorPortPresent       : 1;
                ULONG DbgElevationEnabled       : 1;
                ULONG DbgVirtEnabled            : 1;
                ULONG DbgInstallerDetectEnabled : 1;
                ULONG DbgLkgEnabled             : 1;
                ULONG DbgDynProcessorEnabled    : 1;
                ULONG DbgConsoleBrokerEnabled   : 1;
                ULONG DbgSecureBootEnabled      : 1;
                ULONG DbgMultiSessionSku        : 1;
                ULONG DbgMultiUsersInSessionSku : 1;
                ULONG DbgStateSeparationEnabled : 1;
                ULONG SpareBits                 : 21;
            };
        };
        ULONG DataFlagsPad[1];
        ULONGLONG TestRetInstruction;
        LONGLONG QpcFrequency;

        ULONG SystemCall;
        ULONG SystemCallPad0;

        ULONGLONG SystemCallPad[2];

        union
        {
            volatile KSYSTEM_TIME TickCount;
            volatile ULONG64 TickCountQuad;
            ULONG ReservedTickCountOverlay[3];
        };

        ULONG TickCountPad[1];

        ULONG Cookie;
        ULONG CookiedPad;

        ULONG ConsoleSessionForegroundProcessId;

        ULONGLONG TimeUpdateLock;
        ULONGLONG BaselineSystemTimeQpc;
        ULONGLONG BaselineInterruptTimeQpc;
        ULONGLONG QpcSystemTimeIncrement;
        ULONGLONG QpcInterruptTimeIncrement;
        UCHAR QpcSystemTimeIncrementShift;
        UCHAR QpcInterruptTimeIncrementShift;
        USHORT UnparkedProcessorCount;

        ULONG EnclaveFeatureMask[4];
        union
        {
            ULONG Reserved8;
            ULONG TelemetryCoverageRound;
        };

        USHORT UserModeGlobalLogger[16];

        ULONG ImageFileExecutionOptions;
        ULONG LangGenerationCount;
        ULONGLONG Reserved4;

        volatile ULONG64 InterruptTimeBias;
        volatile ULONG64 QpcBias;

        ULONG ActiveProcessorCount;
        volatile UCHAR ActiveGroupCount;
        UCHAR Reserved9;

        union
        {
            USHORT QpcData;
            struct
            {
                UCHAR QpcBypassEnabled : 1;
                UCHAR QpcShift         : 1;
            };
        };

        LARGE_INTEGER TimeZoneBiasEffectiveStart;
        LARGE_INTEGER TimeZoneBiasEffectiveEnd;

        XSTATE_CONFIGURATION XState;

    } KUSER_SHARED_DATA, *PKUSER_SHARED_DATA;
#include <poppack.h>

#define USER_SHARED_DATA ((KUSER_SHARED_DATA* const)MM_SHARED_USER_DATA_VA)

    /*
    ** KUSER_SHARED_DATA END
    */

    /*
    ** FLT MANAGER START
    */

#define FLTFL_MANDATORY_UNLOAD_IN_PROGRESS 0x1
#define FLTFL_FILTERING_INITIATED 0x2
#define FLTFL_NAME_PROVIDER 0x4
#define FLTFL_SUPPORTS_PIPES_MAILSLOTS 0x8

#define FLT_OBFL_DRAINING 0x1
#define FLT_OBFL_ZOMBIED 0x2
#define FLT_OBFL_TYPE_INSTANCE 0x1000000
#define FLT_OBFL_TYPE_FILTER 0x2000000
#define FLT_OBFL_TYPE_VOLUME 0x4000000

    typedef struct _FLT_OBJECT
    {
        ULONG Flags;
        ULONG PointerCount;
        EX_RUNDOWN_REF RundownRef;
        LIST_ENTRY PrimaryLink;
    } FLT_OBJECT, *PFLT_OBJECT;

    typedef struct _FLT_SERVER_PORT_OBJECT
    {
        LIST_ENTRY FilterLink;
        PVOID ConnectNotify;
        PVOID DisconnectNotify;
        PVOID MessageNotify;
        PVOID Filter;
        PVOID Cookie;
        ULONG Flags;
        ULONG NumberOfConnections;
        ULONG MaxConnections;
    } FLT_SERVER_PORT_OBJECT, *PFLT_SERVER_PORT_OBJECT;

    /*
    ** FLT MANAGER END
    */

    /*
    ** SILO START
    */

    typedef struct _SYSTEM_ROOT_SILO_INFORMATION
    {
        ULONG NumberOfSilos;
        ULONG SiloIdList[1];
    } SYSTEM_ROOT_SILO_INFORMATION, *PSYSTEM_ROOT_SILO_INFORMATION;

    typedef struct _SILO_USER_SHARED_DATA
    {
        ULONG64 ServiceSessionId;
        ULONG ActiveConsoleId;
        LONGLONG ConsoleSessionForegroundProcessId;
        NT_PRODUCT_TYPE NtProductType;
        ULONG SuiteMask;
        ULONG SharedUserSessionId;
        BOOLEAN IsMultiSessionSku;
        WCHAR NtSystemRoot[260];
        USHORT UserModeGlobalLogger[16];
    } SILO_USER_SHARED_DATA, *PSILO_USER_SHARED_DATA;

    typedef struct _OBP_SYSTEM_DOS_DEVICE_STATE
    {
        ULONG GlobalDeviceMap;
        ULONG LocalDeviceCount[26];
    } OBP_SYSTEM_DOS_DEVICE_STATE, *POBP_SYSTEM_DOS_DEVICE_STATE;

    typedef struct _OBP_SILODRIVERSTATE
    {
        PDEVICE_MAP SystemDeviceMap;
        OBP_SYSTEM_DOS_DEVICE_STATE SystemDosDeviceState;
        EX_PUSH_LOCK DeviceMapLock;
        OBJECT_NAMESPACE_LOOKUPTABLE PrivateNamespaceLookupTable;
    } OBP_SILODRIVERSTATE, *POBP_SILODRIVERSTATE;

    // incomplete, values not important, change between versions.
    typedef struct _ESERVERSILO_GLOBALS
    {
        OBP_SILODRIVERSTATE ObSiloState;
        // incomplete
    } ESERVERSILO_GLOBALS, *PESERVERSILO_GLOBALS;

    /*
    ** SILO END
    */

    /*
    ** SOFTWARE LICENSING START
    */
#pragma pack(push, 1)
    typedef struct _SL_CACHE_VALUE_DESCRIPTOR
    {
        USHORT Size;
        USHORT NameLength;
        USHORT Type;
        USHORT DataLength;
        ULONG Attributes;
        ULONG Reserved;
        WCHAR Name[ANYSIZE_ARRAY];
    } SL_CACHE_VALUE_DESCRIPTOR, *PSL_CACHE_VALUE_DESCRIPTOR;
    typedef SL_CACHE_VALUE_DESCRIPTOR SL_KMEM_CACHE_VALUE_DESCRIPTOR;
#pragma pack(pop)

    typedef struct _SL_CACHE
    {
        ULONG TotalSize;
        ULONG SizeOfData;
        ULONG SignatureSize;
        ULONG Flags;
        ULONG Version;
        SL_KMEM_CACHE_VALUE_DESCRIPTOR Descriptors[ANYSIZE_ARRAY];
    } SL_CACHE, *PSL_CACHE;
    typedef SL_CACHE SL_KMEM_CACHE;

    typedef struct _SL_APPX_CACHE_VALUE_DESCRIPTOR
    {
        UCHAR HashedName[32];
        ULONGLONG Expiration;
        ULONG DataSize;
        WCHAR Name[ANYSIZE_ARRAY];
    } SL_APPX_CACHE_VALUE_DESCRIPTOR, *PSL_APPX_CACHE_VALUE_DESCRIPTOR;

    typedef struct _SL_APPX_CACHE
    {
        ULONG Version;
        ULONG Flags;
        ULONG DataSize;
        ULONGLONG DataCheckSum;
        SL_APPX_CACHE_VALUE_DESCRIPTOR Descriptors[ANYSIZE_ARRAY];
    } SL_APPX_CACHE, *PSL_APPX_CACHE;


    /*
    ** SOFTWARE LICENSING END
    */


    /*
    **  LDR START
    */
    //
    // Dll Characteristics for LdrLoadDll
    //
#define LDR_IGNORE_CODE_AUTHZ_LEVEL 0x00001000

//
// LdrAddRef Flags
//
#define LDR_ADDREF_DLL_PIN 0x00000001

//
// LdrLockLoaderLock Flags
//
#define LDR_LOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS 0x00000001
#define LDR_LOCK_LOADER_LOCK_FLAG_TRY_ONLY 0x00000002

//
// LdrUnlockLoaderLock Flags
//
#define LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS 0x00000001

//
// LdrGetDllHandleEx Flags
//
#define LDR_GET_DLL_HANDLE_EX_UNCHANGED_REFCOUNT 0x00000001
#define LDR_GET_DLL_HANDLE_EX_PIN 0x00000002

    typedef VOID(NTAPI* PLDR_LOADED_MODULE_ENUMERATION_CALLBACK_FUNCTION)(
        _In_ PCLDR_DATA_TABLE_ENTRY DataTableEntry,
        _In_ PVOID Context,
        _Inout_ BOOLEAN* StopEnumeration);

    typedef VOID(CALLBACK* PLDR_DLL_NOTIFICATION_FUNCTION)(
        _In_ ULONG NotificationReason,
        _In_ PCLDR_DLL_NOTIFICATION_DATA NotificationData,
        _In_opt_ PVOID Context);

    NTSYSAPI
    NTSTATUS
    NTAPI
    LdrAccessResource(
        _In_ PVOID DllHandle,
        _In_ CONST IMAGE_RESOURCE_DATA_ENTRY* ResourceDataEntry,
        _Out_opt_ PVOID* Address,
        _Out_opt_ PULONG Size);

    NTSYSAPI
    NTSTATUS
    NTAPI
    LdrAddRefDll(_In_ ULONG Flags, _In_ PVOID DllHandle);

    NTSYSAPI
    NTSTATUS
    NTAPI
    LdrEnumerateLoadedModules(
        _In_opt_ ULONG Flags,
        _In_ PLDR_LOADED_MODULE_ENUMERATION_CALLBACK_FUNCTION CallbackFunction,
        _In_opt_ PVOID Context);

    NTSYSAPI
    NTSTATUS
    NTAPI
    LdrFindResource_U(
        _In_ PVOID DllHandle,
        _In_ CONST ULONG_PTR* ResourceIdPath,
        _In_ ULONG ResourceIdPathLength,
        _Out_ PIMAGE_RESOURCE_DATA_ENTRY* ResourceDataEntry);

    NTSYSAPI
    NTSTATUS
    NTAPI
    LdrFindResourceDirectory_U(
        _In_ PVOID DllHandle,
        _In_ PLDR_RESOURCE_INFO ResourceInfo,
        _In_ ULONG Level,
        _Out_ PIMAGE_RESOURCE_DIRECTORY* ResourceDirectory);

    NTSYSAPI
    NTSTATUS
    NTAPI
    LdrFindEntryForAddress(_In_ PVOID Address, _Out_ PLDR_DATA_TABLE_ENTRY* TableEntry);

    NTSYSAPI
    NTSTATUS
    NTAPI
    LdrGetDllHandle(
        _In_opt_ PCWSTR DllPath,
        _In_opt_ PULONG DllCharacteristics,
        _In_ PCUNICODE_STRING DllName,
        _Out_ PVOID* DllHandle);

    NTSYSAPI
    NTSTATUS
    NTAPI
    LdrGetDllHandleEx(
        _In_ ULONG Flags,
        _In_opt_ PWSTR DllPath,
        _In_opt_ PULONG DllCharacteristics,
        _In_ PUNICODE_STRING DllName,
        _Out_opt_ PVOID* DllHandle);

    NTSYSAPI
    NTSTATUS
    NTAPI
    LdrGetDllHandleByMapping(_In_ PVOID BaseAddress, _Out_ PVOID* DllHandle);

    NTSYSAPI
    NTSTATUS
    NTAPI
    LdrGetDllHandleByName(
        _In_opt_ PUNICODE_STRING BaseDllName,
        _In_opt_ PUNICODE_STRING FullDllName,
        _Out_ PVOID* DllHandle);

    NTSYSAPI
    NTSTATUS
    NTAPI
    LdrGetDllFullName(_In_ PVOID DllHandle, _Out_ PUNICODE_STRING FullDllName);

    NTSYSAPI
    NTSTATUS
    NTAPI
    LdrGetDllDirectory(_Out_ PUNICODE_STRING DllDirectory);

    NTSYSAPI
    NTSTATUS
    NTAPI
    LdrSetDllDirectory(_In_ PUNICODE_STRING DllDirectory);

    NTSYSAPI
    NTSTATUS
    NTAPI
    LdrGetProcedureAddress(
        _In_ PVOID DllHandle,
        _In_opt_ CONST ANSI_STRING* ProcedureName,
        _In_opt_ ULONG ProcedureNumber,
        _Out_ PVOID* ProcedureAddress);

    NTSYSAPI
    NTSTATUS
    NTAPI
    LdrGetProcedureAddressForCaller(
        _In_ PVOID DllHandle,
        _In_opt_ PANSI_STRING ProcedureName,
        _In_opt_ ULONG ProcedureNumber,
        _Out_ PVOID* ProcedureAddress,
        _In_ ULONG Flags,
        _In_ PVOID* Callback);

    NTSYSAPI
    NTSTATUS
    NTAPI
    LdrGetKnownDllSectionHandle(_In_ PCWSTR DllName, _In_ BOOLEAN KnownDlls32, _Out_ PHANDLE Section);

    NTSYSAPI
    NTSTATUS
    NTAPI
    LdrLoadDll(
        _In_opt_ PCWSTR DllPath,
        _In_opt_ PULONG DllCharacteristics,
        _In_ PCUNICODE_STRING DllName,
        _Out_ PVOID* DllHandle);

    NTSYSAPI
    NTSTATUS
    NTAPI
    LdrUnloadDll(_In_ PVOID DllHandle);

    NTSYSAPI
    NTSTATUS
    NTAPI
    LdrQueryProcessModuleInformation(
        _Out_ PRTL_PROCESS_MODULES ModuleInformation,
        _In_ ULONG ModuleInformationLength,
        _Out_opt_ PULONG ReturnLength);

    NTSYSAPI
    NTSTATUS
    NTAPI
    LdrRegisterDllNotification(
        _In_ ULONG Flags,
        _In_ PLDR_DLL_NOTIFICATION_FUNCTION NotificationFunction,
        _In_opt_ PVOID Context,
        _Out_ PVOID* Cookie);

    NTSYSAPI
    NTSTATUS
    NTAPI
    LdrUnregisterDllNotification(_In_ PVOID Cookie);

    NTSYSAPI
    NTSTATUS
    NTAPI
    LdrResSearchResource(
        _In_ PVOID File,
        _In_ CONST ULONG_PTR* ResIds,
        _In_ ULONG ResIdCount,
        _In_ ULONG Flags,
        _Out_ LPVOID* Resource,
        _Out_ ULONG_PTR* Size,
        _In_opt_ USHORT* FoundLanguage,
        _In_opt_ ULONG* FoundLanguageLength);

    NTSYSAPI
    NTSTATUS
    NTAPI
    LdrOpenImageFileOptionsKey(_In_ PCUNICODE_STRING ImagePathName, _In_ BOOLEAN Wow64Path, _Out_ PHANDLE KeyHandle);

    NTSYSAPI
    NTSTATUS
    NTAPI
    LdrQueryImageFileExecutionOptions(
        _In_ PCUNICODE_STRING ImagePathName,
        _In_ PCWSTR OptionName,
        _In_ ULONG Type,
        _Out_ PVOID Buffer,
        _In_ ULONG BufferSize,
        _Out_opt_ PULONG ResultSize);

    NTSYSAPI
    BOOLEAN
    NTAPI
    LdrIsModuleSxsRedirected( // LdrEntry->Flags->Redirected
        _In_ PVOID DllHandle);

    NTSYSAPI
    NTSTATUS
    NTAPI
    LdrQueryImageFileExecutionOptionsEx(
        _In_ PCUNICODE_STRING ImagePathName,
        _In_ PCWSTR OptionName,
        _In_ ULONG Type,
        _Out_ PVOID Buffer,
        _In_ ULONG BufferSize,
        _Out_opt_ PULONG ResultSize,
        _In_ BOOLEAN Wow64Path);

    NTSYSAPI
    NTSTATUS
    NTAPI
    LdrQueryImageFileKeyOption(
        _In_ HANDLE KeyHandle,
        _In_ PCWSTR OptionName,
        _In_ ULONG Type,
        _Out_ PVOID Buffer,
        _In_ ULONG BufferSize,
        _Out_opt_ PULONG ResultSize);

    NTSYSAPI
    NTSTATUS
    NTAPI
    LdrDisableThreadCalloutsForDll(_In_ PVOID DllImageBase);

#define LDR_LOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS 0x00000001
#define LDR_LOCK_LOADER_LOCK_FLAG_TRY_ONLY 0x00000002

#define LDR_LOCK_LOADER_LOCK_DISPOSITION_INVALID 0x00000000
#define LDR_LOCK_LOADER_LOCK_DISPOSITION_LOCK_ACQUIRED 0x00000001
#define LDR_LOCK_LOADER_LOCK_DISPOSITION_LOCK_NOT_ACQUIRED 0x00000002

#define LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS 0x00000001

    NTSYSAPI
    NTSTATUS
    NTAPI
    LdrLockLoaderLock(_In_ ULONG Flags, _Out_opt_ ULONG* Disposition, _Out_ PVOID* Cookie);

    NTSYSAPI
    NTSTATUS
    NTAPI
    LdrUnlockLoaderLock(_In_ ULONG Flags, _Inout_ PVOID Cookie);

    NTSYSAPI
    NTSTATUS
    NTAPI
    LdrRelocateImage(
        _In_ PVOID NewBase,
        _In_ PSTR LoaderName,
        _In_ NTSTATUS Success,
        _In_ NTSTATUS Conflict,
        _In_ NTSTATUS Invalid);

    NTSYSAPI
    PIMAGE_BASE_RELOCATION
    NTAPI
    LdrProcessRelocationBlock(_In_ ULONG_PTR VA, _In_ ULONG SizeOfBlock, _In_ PUSHORT NextOffset, _In_ LONG_PTR Diff);

    NTSYSAPI
    NTSTATUS
    NTAPI
    LdrShutdownProcess(VOID);

    NTSYSAPI
    NTSTATUS
    NTAPI
    LdrShutdownThread(VOID);

    NTSYSAPI
    BOOLEAN
    NTAPI
    LdrControlFlowGuardEnforced(VOID);

    /*
    **  LDR END
    */

    typedef struct _HANDLEENTRY
    {
        PHEAD phead;  // Pointer to the Object.
        PVOID pOwner; // PTI or PPI
        BYTE bType;   // Object handle type
        BYTE bFlags;  // Flags
        WORD wUniq;   // Access count.
    } HANDLEENTRY, *PHANDLEENTRY;

    typedef struct _SERVERINFO
    {
        WORD wRIPFlags;
        WORD wSRVIFlags;
        WORD wRIPPID;
        WORD wRIPError;
        ULONG cHandleEntries;
        // incomplete
    } SERVERINFO, *PSERVERINFO;

    typedef struct _SHAREDINFO
    {
        PSERVERINFO psi;
        PHANDLEENTRY aheList;
        ULONG HeEntrySize;
        // incomplete
    } SHAREDINFO, *PSHAREDINFO;

    typedef struct _USERCONNECT
    {
        ULONG ulVersion;
        ULONG ulCurrentVersion;
        DWORD dwDispatchCount;
        SHAREDINFO siClient;
    } USERCONNECT, *PUSERCONNECT;

    /*
    ** Runtime Library API START
    */

    /************************************************************************************
     *
     * CSR API.
     *
     ************************************************************************************/

    NTSYSAPI
    ULONG
    NTAPI
    CsrGetProcessId(VOID);

    NTSYSAPI
    NTSTATUS
    NTAPI
    CsrClientConnectToServer(
        _In_ PWSTR ObjectDirectory,
        _In_ ULONG ServerDllIndex,
        _Inout_ PVOID ConnectionInformation,
        _Inout_ ULONG* ConnectionInformationLength,
        _Out_ PBOOLEAN CalledFromServer);

    /************************************************************************************
     *
     * RTL Strings API.
     *
     ************************************************************************************/

#define RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE (0x00000001)
#define RTL_DUPLICATE_UNICODE_STRING_ALLOCATE_NULL_STRING (0x00000002)

#ifndef RtlInitEmptyUnicodeString
#define RtlInitEmptyUnicodeString(_ucStr, _buf, _bufSize)                                                              \
    ((_ucStr)->Buffer = (_buf), (_ucStr)->Length = 0, (_ucStr)->MaximumLength = (USHORT)(_bufSize))
#endif

    NTSYSAPI
    BOOLEAN
    NTAPI
    RtlCreateUnicodeString(_Out_ PUNICODE_STRING DestinationString, _In_ PCWSTR SourceString);

    NTSYSAPI
    BOOLEAN
    NTAPI
    RtlCreateUnicodeStringFromAsciiz(_Out_ PUNICODE_STRING DestinationString, _In_ PSTR SourceString);

    NTSYSAPI
    VOID NTAPI
    RtlInitString(_Inout_ PSTRING DestinationString, _In_ PCSZ SourceString);

    NTSYSAPI
    VOID NTAPI
    RtlInitUnicodeString(_Out_ PUNICODE_STRING DestinationString, _In_opt_ PCWSTR SourceString);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlInitUnicodeStringEx(_Out_ PUNICODE_STRING DestinationString, _In_opt_ PWSTR SourceString);

    NTSYSAPI
    BOOLEAN
    NTAPI
    RtlEqualUnicodeString(_In_ PCUNICODE_STRING String1, _In_ PCUNICODE_STRING String2, _In_ BOOLEAN CaseInSensitive);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlDuplicateUnicodeString(_In_ ULONG Flags, _In_ PUNICODE_STRING StringIn, _Out_ PUNICODE_STRING StringOut);

    NTSYSAPI
    WCHAR
    NTAPI
    RtlUpcaseUnicodeChar(_In_ WCHAR SourceCharacter);

    NTSYSAPI
    WCHAR
    NTAPI
    RtlDowncaseUnicodeChar(_In_ WCHAR SourceCharacter);

    NTSYSAPI
    BOOLEAN
    NTAPI
    RtlIsNameInExpression(
        _In_ PUNICODE_STRING Expression,
        _In_ PUNICODE_STRING Name,
        _In_ BOOLEAN IgnoreCase,
        _In_opt_ PWCH UpcaseTable);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlStringFromGUID(_In_ GUID* Guid, _Out_ PUNICODE_STRING GuidString);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlGUIDFromString(_In_ PUNICODE_STRING GuidString, _Out_ GUID* Guid);

    NTSYSAPI
    BOOLEAN
    NTAPI
    RtlPrefixUnicodeString(_In_ PCUNICODE_STRING String1, _In_ PCUNICODE_STRING String2, _In_ BOOLEAN CaseInSensitive);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlExpandEnvironmentStrings(
        _In_opt_ PVOID Environment,
        _In_reads_(SrcLength) PWSTR Src,
        _In_ SIZE_T SrcLength,
        _Out_writes_opt_(DstLength) PWSTR Dst,
        _In_ SIZE_T DstLength,
        _Out_opt_ PSIZE_T ReturnLength);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlExpandEnvironmentStrings_U(
        _In_opt_ PVOID Environment,
        _In_ PCUNICODE_STRING Source,
        _Out_ PUNICODE_STRING Destination,
        _Out_opt_ PULONG ReturnedLength);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlFormatCurrentUserKeyPath(_Out_ PUNICODE_STRING CurrentUserKeyPath);

    NTSYSAPI
    VOID NTAPI
    RtlFreeUnicodeString(_In_ PUNICODE_STRING UnicodeString);

    NTSYSAPI
    VOID NTAPI
    RtlEraseUnicodeString(_Inout_ PUNICODE_STRING String);

    NTSYSAPI
    VOID NTAPI
    RtlFreeAnsiString(_In_ PANSI_STRING AnsiString);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlAnsiStringToUnicodeString(
        _Out_ PUNICODE_STRING DestinationString,
        _In_ PCANSI_STRING SourceString,
        _In_ BOOLEAN AllocateDestinationString);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlUnicodeStringToAnsiString(
        _Inout_ PANSI_STRING DestinationString,
        _In_ PUNICODE_STRING SourceString,
        _In_ BOOLEAN AllocateDestinationString);

    NTSYSAPI
    WCHAR
    NTAPI
    RtlAnsiCharToUnicodeChar(_Inout_ PUCHAR* SourceCharacter);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlUnicodeToMultiByteSize(
        _Out_ PULONG BytesInMultiByteString,
        _In_reads_bytes_(BytesInUnicodeString) PWCH UnicodeString,
        _In_ ULONG BytesInUnicodeString);

    NTSYSAPI
    BOOLEAN
    NTAPI
    RtlDosPathNameToNtPathName_U(
        _In_ PCWSTR DosFileName,
        _Out_ PUNICODE_STRING NtFileName,
        _Out_opt_ PWSTR* FilePart,
        _Reserved_ PVOID Reserved);

    NTSYSAPI
    LONG NTAPI
    RtlCompareUnicodeStrings(
        _In_reads_(String1Length) PWCHAR String1,
        _In_ SIZE_T String1Length,
        _In_reads_(String2Length) PWCHAR String2,
        _In_ SIZE_T String2Length,
        _In_ BOOLEAN CaseInSensitive);

    NTSYSAPI
    VOID NTAPI
    RtlCopyString(_In_ PSTRING DestinationString, _In_opt_ PSTRING SourceString);

    NTSYSAPI
    CHAR NTAPI
    RtlUpperChar(_In_ CHAR Character);

    NTSYSAPI
    VOID NTAPI
    RtlUpperString(_In_ PSTRING DestinationString, _In_ PSTRING SourceString);

    //
    // preallocated heap-growable buffers
    //
    typedef struct _RTL_BUFFER
    {
        PUCHAR Buffer;
        PUCHAR StaticBuffer;
        SIZE_T Size;
        SIZE_T StaticSize;
        SIZE_T ReservedForAllocatedSize; // for future doubling
        PVOID ReservedForIMalloc;        // for future pluggable growth
    } RTL_BUFFER, *PRTL_BUFFER;

    typedef struct _RTL_UNICODE_STRING_BUFFER
    {
        UNICODE_STRING String;
        RTL_BUFFER ByteBuffer;
        UCHAR MinimumStaticBufferForTerminalNul[sizeof(WCHAR)];
    } RTL_UNICODE_STRING_BUFFER, *PRTL_UNICODE_STRING_BUFFER;

    //
    // These are OUT Disposition values.
    //
#define RTL_NT_PATH_NAME_TO_DOS_PATH_NAME_AMBIGUOUS (0x00000001)
#define RTL_NT_PATH_NAME_TO_DOS_PATH_NAME_UNC (0x00000002)
#define RTL_NT_PATH_NAME_TO_DOS_PATH_NAME_DRIVE (0x00000003)
#define RTL_NT_PATH_NAME_TO_DOS_PATH_NAME_ALREADY_DOS (0x00000004)

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlNtPathNameToDosPathName(
        _In_ ULONG Flags,
        _Inout_ PRTL_UNICODE_STRING_BUFFER Path,
        _Out_opt_ PULONG Disposition,
        _Inout_opt_ PWSTR* FilePart);

    NTSYSAPI
    ULONG
    NTAPI
    RtlIsDosDeviceName_U(_In_ PCWSTR DosFileName);

    NTSYSAPI
    ULONG
    NTAPI
    RtlGetFullPathName_U(
        _In_ PCWSTR lpFileName,
        _In_ ULONG nBufferLength,
        _Out_writes_bytes_(nBufferLength) PWSTR lpBuffer,
        _Out_opt_ PWSTR* lpFilePart);

    NTSYSAPI
    BOOLEAN
    NTAPI
    RtlGetSearchPath(_Out_ PWSTR* SearchPath);

    typedef enum _RTL_PATH_TYPE
    {
        RtlPathTypeUnknown,        // 0
        RtlPathTypeUncAbsolute,    // 1
        RtlPathTypeDriveAbsolute,  // 2
        RtlPathTypeDriveRelative,  // 3
        RtlPathTypeRooted,         // 4
        RtlPathTypeRelative,       // 5
        RtlPathTypeLocalDevice,    // 6
        RtlPathTypeRootLocalDevice // 7
    } RTL_PATH_TYPE;

    NTSYSAPI
    RTL_PATH_TYPE
    NTAPI
    RtlDetermineDosPathNameType_U(_In_ PCWSTR DosFileName);

#define HASH_STRING_ALGORITHM_DEFAULT (0)
#define HASH_STRING_ALGORITHM_X65599 (1)
#define HASH_STRING_ALGORITHM_INVALID (0xffffffff)

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlHashUnicodeString(
        _In_ const UNICODE_STRING* String,
        _In_ BOOLEAN CaseInSensitive,
        _In_ ULONG HashAlgorithm,
        _Out_ PULONG HashValue);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlAppendUnicodeStringToString(_In_ PUNICODE_STRING Destination, _In_ PUNICODE_STRING Source);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlAppendUnicodeToString(_In_ PUNICODE_STRING Destination, _In_opt_ PWSTR Source);

    NTSYSAPI
    VOID NTAPI
    RtlCopyUnicodeString(_In_ PUNICODE_STRING DestinationString, _In_ PUNICODE_STRING SourceString);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlUpcaseUnicodeString(
        _Inout_ PUNICODE_STRING DestinationString,
        _In_ PUNICODE_STRING SourceString,
        _In_ BOOLEAN AllocateDestinationString);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlDowncaseUnicodeString(
        _Inout_ PUNICODE_STRING DestinationString,
        _In_ PUNICODE_STRING SourceString,
        _In_ BOOLEAN AllocateDestinationString);

    NTSYSAPI
    VOID NTAPI
    RtlEraseUnicodeString(_Inout_ PUNICODE_STRING String);

#define RTL_ENSURE_BUFFER_SIZE_NO_COPY (0x00000001)

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlpEnsureBufferSize(_In_ ULONG Flags, _Inout_ PRTL_BUFFER Buffer, _In_ SIZE_T NewSizeBytes);

#define RtlInitBuffer(Buff, StatBuff, StatSize)                                                                        \
    do                                                                                                                 \
    {                                                                                                                  \
        (Buff)->Buffer       = (StatBuff);                                                                             \
        (Buff)->Size         = (StatSize);                                                                             \
        (Buff)->StaticBuffer = (StatBuff);                                                                             \
        (Buff)->StaticSize   = (StatSize);                                                                             \
    } while ( 0 )

#define RtlEnsureBufferSize(Flags, Buff, NewSizeBytes)                                                                 \
    (((Buff) != NULL && (NewSizeBytes) <= (Buff)->Size) ? STATUS_SUCCESS :                                             \
                                                          RtlpEnsureBufferSize((Flags), (Buff), (NewSizeBytes)))

#define RtlFreeBuffer(Buff)                                                                                            \
    do                                                                                                                 \
    {                                                                                                                  \
        if ( (Buff) != NULL && (Buff)->Buffer != NULL )                                                                \
        {                                                                                                              \
            if ( RTLP_BUFFER_IS_HEAP_ALLOCATED(Buff) )                                                                 \
            {                                                                                                          \
                UNICODE_STRING UnicodeString;                                                                          \
                UnicodeString.Buffer = (PWSTR)(PVOID)(Buff)->Buffer;                                                   \
                RtlFreeUnicodeString(&UnicodeString);                                                                  \
            }                                                                                                          \
            (Buff)->Buffer = (Buff)->StaticBuffer;                                                                     \
            (Buff)->Size   = (Buff)->StaticSize;                                                                       \
        }                                                                                                              \
    } while ( 0 )


    /************************************************************************************
     *
     * RTL Integer conversion API.
     *
     ************************************************************************************/

    NTSYSAPI
    PWSTR
    NTAPI
    RtlIpv4AddressToStringW(_In_ const struct in_addr* Addr, _Out_ PWSTR S);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlIpv4StringToAddressW(
        _In_ PCWSTR AddressString,
        _In_ BOOLEAN Strict,
        _Out_ LPCWSTR* Terminator,
        _Out_ struct in_addr* Address);

    // taken from ph2

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlIntegerToChar(_In_ ULONG Value, _In_opt_ ULONG Base, _In_ LONG OutputLength, _Out_ PSTR String);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlCharToInteger(_In_ PSTR String, _In_opt_ ULONG Base, _Out_ PULONG Value);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlLargeIntegerToChar(_In_ PLARGE_INTEGER Value, _In_opt_ ULONG Base, _In_ LONG OutputLength, _Out_ PSTR String);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlIntegerToUnicodeString(_In_ ULONG Value, _In_opt_ ULONG Base, _Inout_ PUNICODE_STRING String);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlInt64ToUnicodeString(_In_ ULONGLONG Value, _In_opt_ ULONG Base, _Inout_ PUNICODE_STRING String);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlUnicodeStringToInteger(_In_ PUNICODE_STRING String, _In_opt_ ULONG Base, _Out_ PULONG Value);

    /************************************************************************************
     *
     * RTL Process/Thread API.
     *
     ************************************************************************************/

    typedef NTSTATUS (*PUSER_PROCESS_START_ROUTINE)(PRTL_USER_PROCESS_PARAMETERS ProcessParameters);

    typedef NTSTATUS (*PUSER_THREAD_START_ROUTINE)(PVOID ThreadParameter);

    typedef struct _RTL_USER_PROCESS_INFORMATION
    {
        ULONG Length;
        HANDLE Process;
        HANDLE Thread;
        CLIENT_ID ClientId;
        SECTION_IMAGE_INFORMATION ImageInformation;
    } RTL_USER_PROCESS_INFORMATION, *PRTL_USER_PROCESS_INFORMATION;

    //
    // This structure is used only by Wow64 processes. The offsets
    // of structure elements should the same as viewed by a native Win64 application.
    //
    typedef struct _RTL_USER_PROCESS_INFORMATION64
    {
        ULONG Length;
        LONGLONG Process;
        LONGLONG Thread;
        CLIENT_ID64 ClientId;
        SECTION_IMAGE_INFORMATION64 ImageInformation;
    } RTL_USER_PROCESS_INFORMATION64, *PRTL_USER_PROCESS_INFORMATION64;

    NTSYSAPI
    NTSTATUS
    STDAPIVCALLTYPE
    RtlSetProcessIsCritical(_In_ BOOLEAN NewValue, _Out_opt_ PBOOLEAN OldValue, _In_ BOOLEAN CheckFlag);

    NTSYSAPI
    NTSTATUS
    STDAPIVCALLTYPE
    RtlSetThreadIsCritical(_In_ BOOLEAN NewValue, _Out_opt_ PBOOLEAN OldValue, _In_ BOOLEAN CheckFlag);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlCreateEnvironment(_In_ BOOLEAN CloneCurrentEnvironment, _Out_ PVOID* Environment);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlCreateEnvironmentEx(_In_ PVOID SourceEnv, _Out_ PVOID* Environment, _In_ ULONG Flags);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlSetCurrentEnvironment(_In_ PVOID Environment, _Out_opt_ PVOID* PreviousEnvironment);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlQueryEnvironmentVariable_U(_In_opt_ PVOID Environment, _In_ PUNICODE_STRING Name, _Out_ PUNICODE_STRING Value);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlDestroyEnvironment(_In_ PVOID Environment);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlCreateProcessParameters(
        _Out_ PRTL_USER_PROCESS_PARAMETERS* pProcessParameters,
        _In_ PUNICODE_STRING ImagePathName,
        _In_opt_ PUNICODE_STRING DllPath,
        _In_opt_ PUNICODE_STRING CurrentDirectory,
        _In_opt_ PUNICODE_STRING CommandLine,
        _In_opt_ PVOID Environment,
        _In_opt_ PUNICODE_STRING WindowTitle,
        _In_opt_ PUNICODE_STRING DesktopInfo,
        _In_opt_ PUNICODE_STRING ShellInfo,
        _In_opt_ PUNICODE_STRING RuntimeData);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlDestroyProcessParameters(_In_ PRTL_USER_PROCESS_PARAMETERS ProcessParameters);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlCreateProcessParametersEx(
        _Out_ PRTL_USER_PROCESS_PARAMETERS* pProcessParameters,
        _In_ PUNICODE_STRING ImagePathName,
        _In_opt_ PUNICODE_STRING DllPath,
        _In_opt_ PUNICODE_STRING CurrentDirectory,
        _In_opt_ PUNICODE_STRING CommandLine,
        _In_opt_ PVOID Environment,
        _In_opt_ PUNICODE_STRING WindowTitle,
        _In_opt_ PUNICODE_STRING DesktopInfo,
        _In_opt_ PUNICODE_STRING ShellInfo,
        _In_opt_ PUNICODE_STRING RuntimeData,
        _In_ ULONG Flags);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlCreateUserProcess(
        _In_ PUNICODE_STRING NtImagePathName,
        _In_ ULONG Attributes,
        _In_ PRTL_USER_PROCESS_PARAMETERS ProcessParameters,
        _In_opt_ PSECURITY_DESCRIPTOR ProcessSecurityDescriptor,
        _In_opt_ PSECURITY_DESCRIPTOR ThreadSecurityDescriptor,
        _In_opt_ HANDLE ParentProcess,
        _In_ BOOLEAN InheritHandles,
        _In_opt_ HANDLE DebugPort,
        _In_opt_ HANDLE ExceptionPort,
        _Out_ PRTL_USER_PROCESS_INFORMATION ProcessInformationn);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlCreateUserThread(
        _In_ HANDLE Process,
        _In_opt_ PSECURITY_DESCRIPTOR ThreadSecurityDescriptor,
        _In_ BOOLEAN CreateSuspended,
        _In_ ULONG StackZeroBits,
        _In_opt_ SIZE_T MaximumStackSize,
        _In_opt_ SIZE_T InitialStackSize,
        _In_ PUSER_THREAD_START_ROUTINE StartAddress,
        _In_opt_ PVOID Parameter,
        _Out_opt_ PHANDLE Thread,
        _Out_opt_ PCLIENT_ID ClientId);

    NTSYSAPI
    VOID NTAPI
    RtlExitUserThread(_In_ NTSTATUS ExitStatus);

    NTSYSAPI
    VOID NTAPI
    RtlExitUserProcess(_In_ NTSTATUS ExitStatus);

    NTSYSAPI
    VOID NTAPI
    RtlFreeUserThreadStack(_In_ HANDLE hProcess, _In_ HANDLE hThread);

    NTSYSAPI
    VOID NTAPI
    RtlPushFrame(_In_ PTEB_ACTIVE_FRAME Frame);

    NTSYSAPI
    VOID NTAPI
    RtlPopFrame(_In_ PTEB_ACTIVE_FRAME Frame);

    NTSYSAPI
    PTEB_ACTIVE_FRAME
    NTAPI
    RtlGetFrame(VOID);

    NTSYSAPI
    PVOID
    NTAPI
    RtlEncodePointer(_In_ PVOID Ptr);

    NTSYSAPI
    PVOID
    NTAPI
    RtlDecodePointer(_In_ PVOID Ptr);

    /************************************************************************************
     *
     * RTL Memory Buffer API.
     *
     ************************************************************************************/

    NTSYSAPI
    SIZE_T
    NTAPI
    RtlCompareMemoryUlong(_In_ PVOID Source, _In_ SIZE_T Length, _In_ ULONG Pattern);

    NTSYSAPI
    VOID NTAPI
    RtlFillMemoryUlong(_Out_ PVOID Destination, _In_ SIZE_T Length, _In_ ULONG Pattern);

    NTSYSAPI
    VOID NTAPI
    RtlFillMemoryUlonglong(_Out_ PVOID Destination, _In_ SIZE_T Length, _In_ ULONGLONG Pattern);

    /************************************************************************************
     *
     * RTL PEB API.
     *
     ************************************************************************************/

    NTSYSAPI
    PPEB NTAPI RtlGetCurrentPeb(VOID);

    NTSYSAPI
    VOID NTAPI RtlAcquirePebLock(VOID);

    NTSYSAPI
    VOID NTAPI RtlReleasePebLock(VOID);

    /************************************************************************************
     *
     * RTL Exception Handling API.
     *
     ************************************************************************************/

    NTSYSAPI
    PVOID
    NTAPI
    RtlAddVectoredExceptionHandler(_In_ ULONG First, _In_ PVECTORED_EXCEPTION_HANDLER Handler);

    NTSYSAPI
    ULONG
    NTAPI
    RtlRemoveVectoredExceptionHandler(_In_ PVOID Handle);

    NTSYSAPI
    BOOLEAN
    NTAPI
    RtlDispatchException(_In_ PEXCEPTION_RECORD ExceptionRecord, _In_ PCONTEXT ContextRecord);

    NTSYSAPI
    PVOID
    NTAPI
    RtlAddVectoredContinueHandler(_In_ ULONG First, _In_ PVECTORED_EXCEPTION_HANDLER Handler);

    NTSYSAPI
    ULONG
    NTAPI
    RtlRemoveVectoredContinueHandler(_In_ PVOID Handle);

    NTSYSAPI
    VOID NTAPI
    RtlRaiseException(_In_ PEXCEPTION_RECORD ExceptionRecord);

    NTSYSAPI
    DECLSPEC_NORETURN
    VOID NTAPI
    RtlRaiseStatus(_In_ NTSTATUS Status);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtContinue(_In_ PCONTEXT ContextRecord, _In_ BOOLEAN TestAlert);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtRaiseException(_In_ PEXCEPTION_RECORD ExceptionRecord, _In_ PCONTEXT ContextRecord, _In_ BOOLEAN FirstChance);

    /************************************************************************************
     *
     * RTL Security API.
     *
     ************************************************************************************/

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlGetOwnerSecurityDescriptor(
        _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
        _Out_ PSID* Owner,
        _Out_ PBOOLEAN OwnerDefaulted);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlGetGroupSecurityDescriptor(
        _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
        _Out_ PSID* Group,
        _Out_ PBOOLEAN GroupDefaulted);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlGetDaclSecurityDescriptor(
        _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
        _Out_ PBOOLEAN DaclPresent,
        _Out_ PACL* Dacl,
        _Out_ PBOOLEAN DaclDefaulted);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlGetSaclSecurityDescriptor(
        _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
        _Out_ PBOOLEAN SaclPresent,
        _Out_ PACL* Sacl,
        _Out_ PBOOLEAN SaclDefaulted);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlCreateAcl(_Out_writes_bytes_(AclLength) PACL Acl, _In_ ULONG AclLength, _In_ ULONG AclRevision);

    NTSYSAPI
    BOOLEAN
    NTAPI
    RtlValidAcl(_In_ PACL Acl);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlQueryInformationAcl(
        _In_ PACL Acl,
        _Out_writes_bytes_(AclInformationLength) PVOID AclInformation,
        _In_ ULONG AclInformationLength,
        _In_ ACL_INFORMATION_CLASS AclInformationClass);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlSetInformationAcl(
        _Inout_ PACL Acl,
        _In_reads_bytes_(AclInformationLength) PVOID AclInformation,
        _In_ ULONG AclInformationLength,
        _In_ ACL_INFORMATION_CLASS AclInformationClass);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlAddAce(
        _Inout_ PACL Acl,
        _In_ ULONG AceRevision,
        _In_ ULONG StartingAceIndex,
        _In_reads_bytes_(AceListLength) PVOID AceList,
        _In_ ULONG AceListLength);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlDeleteAce(_Inout_ PACL Acl, _In_ ULONG AceIndex);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlGetAce(_In_ PACL Acl, _In_ ULONG AceIndex, _Outptr_ PVOID* Ace);

    NTSYSAPI
    BOOLEAN
    NTAPI
    RtlFirstFreeAce(_In_ PACL Acl, _Out_ PVOID* FirstFree);

    NTSYSAPI
    BOOLEAN
    NTAPI
    RtlOwnerAcesPresent(_In_ PACL pAcl);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlAddAccessAllowedAce(_Inout_ PACL Acl, _In_ ULONG AceRevision, _In_ ACCESS_MASK AccessMask, _In_ PSID Sid);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlAddAccessAllowedAceEx(
        _Inout_ PACL Acl,
        _In_ ULONG AceRevision,
        _In_ ULONG AceFlags,
        _In_ ACCESS_MASK AccessMask,
        _In_ PSID Sid);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlAddAccessDeniedAce(_Inout_ PACL Acl, _In_ ULONG AceRevision, _In_ ACCESS_MASK AccessMask, _In_ PSID Sid);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlAddAccessDeniedAceEx(
        _Inout_ PACL Acl,
        _In_ ULONG AceRevision,
        _In_ ULONG AceFlags,
        _In_ ACCESS_MASK AccessMask,
        _In_ PSID Sid);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlAddAuditAccessAce(
        _Inout_ PACL Acl,
        _In_ ULONG AceRevision,
        _In_ ACCESS_MASK AccessMask,
        _In_ PSID Sid,
        _In_ BOOLEAN AuditSuccess,
        _In_ BOOLEAN AuditFailure);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlAddAuditAccessAceEx(
        _Inout_ PACL Acl,
        _In_ ULONG AceRevision,
        _In_ ULONG AceFlags,
        _In_ ACCESS_MASK AccessMask,
        _In_ PSID Sid,
        _In_ BOOLEAN AuditSuccess,
        _In_ BOOLEAN AuditFailure);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlAddAccessAllowedObjectAce(
        _Inout_ PACL Acl,
        _In_ ULONG AceRevision,
        _In_ ULONG AceFlags,
        _In_ ACCESS_MASK AccessMask,
        _In_opt_ GUID* ObjectTypeGuid,
        _In_opt_ GUID* InheritedObjectTypeGuid,
        _In_ PSID Sid);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlAddAccessDeniedObjectAce(
        _Inout_ PACL Acl,
        _In_ ULONG AceRevision,
        _In_ ULONG AceFlags,
        _In_ ACCESS_MASK AccessMask,
        _In_opt_ GUID* ObjectTypeGuid,
        _In_opt_ GUID* InheritedObjectTypeGuid,
        _In_ PSID Sid);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlAddAuditAccessObjectAce(
        _Inout_ PACL Acl,
        _In_ ULONG AceRevision,
        _In_ ULONG AceFlags,
        _In_ ACCESS_MASK AccessMask,
        _In_opt_ GUID* ObjectTypeGuid,
        _In_opt_ GUID* InheritedObjectTypeGuid,
        _In_ PSID Sid,
        _In_ BOOLEAN AuditSuccess,
        _In_ BOOLEAN AuditFailure);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlAddCompoundAce(
        _Inout_ PACL Acl,
        _In_ ULONG AceRevision,
        _In_ UCHAR AceType,
        _In_ ACCESS_MASK AccessMask,
        _In_ PSID ServerSid,
        _In_ PSID ClientSid);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlAddMandatoryAce(
        _Inout_ PACL Acl,
        _In_ ULONG AceRevision,
        _In_ ULONG AceFlags,
        _In_ PSID Sid,
        _In_ UCHAR AceType,
        _In_ ACCESS_MASK AccessMask);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlDefaultNpAcl(_Out_ PACL* Acl);

    NTSYSAPI
    ULONG
    NTAPI
    RtlLengthSecurityDescriptor(_In_ PSECURITY_DESCRIPTOR SecurityDescriptor);

    NTSYSAPI
    VOID NTAPI
    RtlMapGenericMask(_In_ PACCESS_MASK AccessMask, _In_ PGENERIC_MAPPING GenericMapping);

    NTSYSAPI
    BOOLEAN
    NTAPI
    RtlValidSid(_In_ PSID Sid);

    NTSYSAPI
    BOOLEAN
    NTAPI
    RtlEqualSid(_In_ PSID Sid1, _In_ PSID Sid2);

    NTSYSAPI
    BOOLEAN
    NTAPI
    RtlEqualPrefixSid(_In_ PSID Sid1, _In_ PSID Sid2);

    NTSYSAPI
    ULONG
    NTAPI
    RtlLengthRequiredSid(_In_ ULONG SubAuthorityCount);

    NTSYSAPI
    PVOID
    NTAPI
    RtlFreeSid(_In_ PSID Sid);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlAllocateAndInitializeSid(
        _In_ PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
        _In_ UCHAR SubAuthorityCount,
        _In_ ULONG SubAuthority0,
        _In_ ULONG SubAuthority1,
        _In_ ULONG SubAuthority2,
        _In_ ULONG SubAuthority3,
        _In_ ULONG SubAuthority4,
        _In_ ULONG SubAuthority5,
        _In_ ULONG SubAuthority6,
        _In_ ULONG SubAuthority7,
        _Out_ PSID* Sid);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlInitializeSid(_Out_ PSID Sid, _In_ PSID_IDENTIFIER_AUTHORITY IdentifierAuthority, _In_ UCHAR SubAuthorityCount);

    NTSYSAPI
    PSID_IDENTIFIER_AUTHORITY
    NTAPI
    RtlIdentifierAuthoritySid(_In_ PSID Sid);

    NTSYSAPI
    PULONG
    NTAPI
    RtlSubAuthoritySid(_In_ PSID Sid, _In_ ULONG SubAuthority);

    NTSYSAPI
    PUCHAR
    NTAPI
    RtlSubAuthorityCountSid(_In_ PSID Sid);

    NTSYSAPI
    ULONG
    NTAPI
    RtlLengthSid(_In_ PSID Sid);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlCopySid(_In_ ULONG DestinationSidLength, _In_ PSID DestinationSid, _In_ PSID SourceSid);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlCopySidAndAttributesArray(
        _In_ ULONG ArrayLength,
        _In_ PSID_AND_ATTRIBUTES Source,
        _In_ ULONG TargetSidBufferSize,
        _Out_ PSID_AND_ATTRIBUTES TargetArrayElement,
        _Out_ PSID TargetSid,
        _Out_ PSID* NextTargetSid,
        _Out_ PULONG RemainingTargetSidBufferSize);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlLengthSidAsUnicodeString(_In_ PSID Sid, _Out_ PULONG StringLength);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlConvertSidToUnicodeString(
        _In_ PUNICODE_STRING UnicodeString,
        _In_ PSID Sid,
        _In_ BOOLEAN AllocateDestinationString);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlCreateServiceSid(
        _In_ PUNICODE_STRING ServiceName,
        _Out_writes_bytes_opt_(*ServiceSidLength) PSID ServiceSid,
        _Inout_ PULONG ServiceSidLength);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlCreateSecurityDescriptor(_In_ PSECURITY_DESCRIPTOR SecurityDescriptor, _In_ ULONG Revision);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlSetOwnerSecurityDescriptor(
        _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
        _In_ PSID Owner,
        _In_ BOOLEAN OwnerDefaulted);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlCopySecurityDescriptor(
        _In_ PSECURITY_DESCRIPTOR InputSecurityDescriptor,
        _Out_ PSECURITY_DESCRIPTOR* OutputSecurityDescriptor);

    FORCEINLINE LUID NTAPI
    RtlConvertLongToLuid(_In_ LONG Long)
    {
        LUID TempLuid;
        LARGE_INTEGER TempLi;

        TempLi.QuadPart   = Long;
        TempLuid.LowPart  = TempLi.LowPart;
        TempLuid.HighPart = TempLi.HighPart;
        return (TempLuid);
    }

    NTSYSAPI
    ULONG
    NTAPI
    RtlUniform(_Inout_ PULONG Seed);

    NTSYSAPI
    ULONG
    NTAPI
    RtlRandomEx(_Inout_ PULONG Seed);

    NTSYSAPI
    ULONG32
    NTAPI
    RtlComputeCrc32(_In_ ULONG32 PartialCrc, _In_ PVOID Buffer, _In_ ULONG Length);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlAdjustPrivilege(_In_ ULONG Privilege, _In_ BOOLEAN Enable, _In_ BOOLEAN Client, _Out_ PBOOLEAN WasEnabled);

    /************************************************************************************
     *
     * RTL Version API.
     *
     ************************************************************************************/

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlGetVersion(_Inout_ PRTL_OSVERSIONINFOW lpVersionInformation);

    NTSYSAPI
    VOID NTAPI
    RtlGetNtVersionNumbers(_Out_opt_ PULONG MajorVersion, _Out_opt_ PULONG MinorVersion, _Out_opt_ PULONG BuildNumber);

    /************************************************************************************
     *
     * RTL Error Status API.
     *
     ************************************************************************************/

    NTSYSAPI
    ULONG
    NTAPI
    RtlNtStatusToDosError(_In_ NTSTATUS Status);

    NTSYSAPI
    VOID NTAPI
    RtlSetLastWin32Error(_In_ LONG Win32Error);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlGetLastNtStatus(VOID);

    NTSYSAPI
    LONG NTAPI RtlGetLastWin32Error(VOID);

    NTSYSAPI
    ULONG
    NTAPI
    RtlNtStatusToDosErrorNoTeb(_In_ NTSTATUS Status);

    NTSYSAPI
    VOID NTAPI
    RtlSetLastWin32ErrorAndNtStatusFromNtStatus(_In_ NTSTATUS Status);

    /************************************************************************************
     *
     * RTL WOW64 Support API.
     *
     ************************************************************************************/

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlWow64EnableFsRedirection(_In_ BOOLEAN Wow64FsEnableRedirection);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlWow64EnableFsRedirectionEx(_In_ PVOID DisableFsRedirection, _Out_ PVOID* OldFsRedirectionLevel);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlWow64GetThreadContext(_In_ HANDLE ThreadHandle, _Inout_ PWOW64_CONTEXT ThreadContext);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlWow64SetThreadContext(_In_ HANDLE ThreadHandle, _In_ PWOW64_CONTEXT ThreadContext);

    /************************************************************************************
     *
     * RTL Heap Management API.
     *
     ************************************************************************************/

    typedef NTSTATUS(
        NTAPI* PRTL_HEAP_COMMIT_ROUTINE)(_In_ PVOID Base, _Inout_ PVOID* CommitAddress, _Inout_ PSIZE_T CommitSize);

    typedef struct _RTL_HEAP_PARAMETERS
    {
        ULONG Length;
        SIZE_T SegmentReserve;
        SIZE_T SegmentCommit;
        SIZE_T DeCommitFreeBlockThreshold;
        SIZE_T DeCommitTotalFreeThreshold;
        SIZE_T MaximumAllocationSize;
        SIZE_T VirtualMemoryThreshold;
        SIZE_T InitialCommit;
        SIZE_T InitialReserve;
        PRTL_HEAP_COMMIT_ROUTINE CommitRoutine;
        SIZE_T Reserved[2];
    } RTL_HEAP_PARAMETERS, *PRTL_HEAP_PARAMETERS;

    NTSYSAPI
    PVOID
    NTAPI
    RtlCreateHeap(
        _In_ ULONG Flags,
        _In_opt_ PVOID HeapBase,
        _In_opt_ SIZE_T ReserveSize,
        _In_opt_ SIZE_T CommitSize,
        _In_opt_ PVOID Lock,
        _In_opt_ PRTL_HEAP_PARAMETERS Parameters);

    NTSYSAPI
    PVOID
    NTAPI
    RtlDestroyHeap(_In_ PVOID HeapHandle);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlSetHeapInformation(
        _In_ PVOID HeapHandle,
        _In_ HEAP_INFORMATION_CLASS HeapInformationClass,
        _In_opt_ PVOID HeapInformation,
        _In_opt_ SIZE_T HeapInformationLength);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlQueryHeapInformation(
        _In_ PVOID HeapHandle,
        _In_ HEAP_INFORMATION_CLASS HeapInformationClass,
        _Out_opt_ PVOID HeapInformation,
        _In_opt_ SIZE_T HeapInformationLength,
        _Out_opt_ PSIZE_T ReturnLength);

    NTSYSAPI
    PVOID
    NTAPI
    RtlAllocateHeap(_In_ PVOID HeapHandle, _In_ ULONG Flags, _In_ SIZE_T Size);

    NTSYSAPI
    BOOLEAN
    NTAPI
    RtlFreeHeap(_In_ PVOID HeapHandle, _In_ ULONG Flags, _In_ PVOID BaseAddress);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlZeroHeap(_In_ PVOID HeapHandle, _In_ ULONG Flags);

    NTSYSAPI
    SIZE_T
    NTAPI
    RtlSizeHeap(_In_ PVOID HeapHandle, _In_ ULONG Flags, _In_ PVOID BaseAddress);

    NTSYSAPI
    VOID NTAPI
    RtlProtectHeap(_In_ PVOID HeapHandle, _In_ BOOLEAN MakeReadOnly);

    NTSYSAPI
    PVOID
    NTAPI
    RtlReAllocateHeap(_In_ PVOID HeapHandle, _In_ ULONG Flags, _Frees_ptr_opt_ PVOID BaseAddress, _In_ SIZE_T Size);

    NTSYSAPI
    ULONG
    NTAPI
    RtlGetProcessHeaps(_In_ ULONG NumberOfHeaps, _Out_ PVOID* ProcessHeaps);

    typedef NTSTATUS(NTAPI* PRTL_ENUM_HEAPS_ROUTINE)(_In_ PVOID HeapHandle, _In_ PVOID Parameter);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlEnumProcessHeaps(_In_ PRTL_ENUM_HEAPS_ROUTINE EnumRoutine, _In_ PVOID Parameter);

    /************************************************************************************
     *
     * RTL Compression API.
     *
     ************************************************************************************/

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlGetCompressionWorkSpaceSize(
        _In_ USHORT CompressionFormatAndEngine,
        _Out_ PULONG CompressBufferWorkSpaceSize,
        _Out_ PULONG CompressFragmentWorkSpaceSize);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlCompressBuffer(
        _In_ USHORT CompressionFormatAndEngine,
        _In_reads_bytes_(UncompressedBufferSize) PUCHAR UncompressedBuffer,
        _In_ ULONG UncompressedBufferSize,
        _Out_writes_bytes_to_(CompressedBufferSize, *FinalCompressedSize) PUCHAR CompressedBuffer,
        _In_ ULONG CompressedBufferSize,
        _In_ ULONG UncompressedChunkSize,
        _Out_ PULONG FinalCompressedSize,
        _In_ PVOID WorkSpace);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlDecompressBuffer(
        _In_ USHORT CompressionFormat,
        _Out_writes_bytes_to_(UncompressedBufferSize, *FinalUncompressedSize) PUCHAR UncompressedBuffer,
        _In_ ULONG UncompressedBufferSize,
        _In_reads_bytes_(CompressedBufferSize) PUCHAR CompressedBuffer,
        _In_ ULONG CompressedBufferSize,
        _Out_ PULONG FinalUncompressedSize);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlDecompressBufferEx(
        _In_ USHORT CompressionFormat,
        _Out_writes_bytes_to_(UncompressedBufferSize, *FinalUncompressedSize) PUCHAR UncompressedBuffer,
        _In_ ULONG UncompressedBufferSize,
        _In_reads_bytes_(CompressedBufferSize) PUCHAR CompressedBuffer,
        _In_ ULONG CompressedBufferSize,
        _Out_ PULONG FinalUncompressedSize,
        _In_ PVOID WorkSpace);

    /************************************************************************************
     *
     * RTL Image API.
     *
     ************************************************************************************/

#define RTL_IMAGE_NT_HEADER_EX_FLAG_NO_RANGE_CHECK (0x00000001)

    NTSYSAPI
    PIMAGE_NT_HEADERS
    NTAPI
    RtlImageNtHeader(_In_ PVOID Base);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlImageNtHeaderEx(_In_ ULONG Flags, _In_ PVOID Base, _In_ ULONG64 Size, _Out_ PIMAGE_NT_HEADERS* OutHeaders);

    NTSYSAPI
    PVOID
    NTAPI
    RtlAddressInSectionTable(_In_ PIMAGE_NT_HEADERS NtHeaders, _In_ PVOID BaseOfImage, _In_ ULONG VirtualAddress);

    NTSYSAPI
    PIMAGE_SECTION_HEADER
    NTAPI
    RtlSectionTableFromVirtualAddress(
        _In_ PIMAGE_NT_HEADERS NtHeaders,
        _In_ PVOID BaseOfImage,
        _In_ ULONG VirtualAddress);

    NTSYSAPI
    PVOID
    NTAPI
    RtlImageDirectoryEntryToData(
        _In_ PVOID BaseOfImage,
        _In_ BOOLEAN MappedAsImage,
        _In_ USHORT DirectoryEntry,
        _Out_ PULONG Size);

    NTSYSAPI
    PIMAGE_SECTION_HEADER
    NTAPI
    RtlImageRvaToSection(_In_ PIMAGE_NT_HEADERS NtHeaders, _In_ PVOID Base, _In_ ULONG Rva);

    NTSYSAPI
    PVOID
    NTAPI
    RtlImageRvaToVa(
        _In_ PIMAGE_NT_HEADERS NtHeaders,
        _In_ PVOID Base,
        _In_ ULONG Rva,
        _Inout_opt_ PIMAGE_SECTION_HEADER* LastRvaSection);

    NTSYSAPI
    PVOID
    NTAPI
    RtlFindExportedRoutineByName(_In_ PVOID BaseOfImage, _In_ PSTR RoutineName);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlGuardCheckLongJumpTarget(_In_ PVOID PcValue, _In_ BOOL IsFastFail, _Out_ PBOOL IsLongJumpTarget);

    /************************************************************************************
     *
     * RTL Time API.
     *
     ************************************************************************************/

    NTSYSAPI
    VOID NTAPI
    RtlSecondsSince1970ToTime(_In_ ULONG ElapsedSeconds, _Out_ PLARGE_INTEGER Time);

    NTSYSAPI
    BOOLEAN
    NTAPI
    RtlTimeToSecondsSince1970(_In_ PLARGE_INTEGER Time, _Out_ PULONG ElapsedSeconds);


    NTSYSAPI
    VOID NTAPI
    RtlSecondsSince1980ToTime(_In_ ULONG ElapsedSeconds, _Out_ PLARGE_INTEGER Time);

    NTSYSAPI
    BOOLEAN
    NTAPI
    RtlTimeToSecondsSince1980(_In_ PLARGE_INTEGER Time, _Out_ PULONG ElapsedSeconds);

    NTSYSAPI
    VOID NTAPI
    RtlTimeToTimeFields(_In_ PLARGE_INTEGER Time, _Out_ PTIME_FIELDS TimeFields);

    NTSYSAPI
    BOOLEAN
    NTAPI
    RtlTimeFieldsToTime(_In_ PTIME_FIELDS TimeFields, _Out_ PLARGE_INTEGER Time);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlSystemTimeToLocalTime(_In_ PLARGE_INTEGER SystemTime, _Out_ PLARGE_INTEGER LocalTime);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlLocalTimeToSystemTime(_In_ PLARGE_INTEGER LocalTime, _Out_ PLARGE_INTEGER SystemTime);

    /************************************************************************************
     *
     * RTL Debug Support API.
     *
     ************************************************************************************/

    NTSYSAPI
    ULONG
    STDAPIVCALLTYPE
    DbgPrint(_In_z_ _Printf_format_string_ PCH Format, ...);

    NTSYSAPI
    ULONG
    STDAPIVCALLTYPE
    DbgPrintEx(_In_ ULONG ComponentId, _In_ ULONG Level, _In_z_ _Printf_format_string_ PSTR Format, ...);

    NTSYSAPI
    NTSTATUS
    NTAPI
    DbgQueryDebugFilterState(_In_ ULONG ComponentId, _In_ ULONG Level);

    NTSYSAPI
    NTSTATUS
    NTAPI
    DbgSetDebugFilterState(_In_ ULONG ComponentId, _In_ ULONG Level, _In_ BOOLEAN State);

    NTSYSAPI
    VOID NTAPI DbgUserBreakPoint(VOID);

    NTSYSAPI
    VOID NTAPI DbgBreakPoint(VOID);

    NTSYSAPI
    NTSTATUS
    NTAPI
    DbgUiConnectToDbg(VOID);

    NTSYSAPI
    VOID NTAPI
    DbgUiSetThreadDebugObject(_In_ HANDLE DebugObject);

    NTSYSAPI
    NTSTATUS
    NTAPI
    DbgUiContinue(_In_ PCLIENT_ID AppClientId, _In_ NTSTATUS ContinueStatus);

    NTSYSAPI
    NTSTATUS
    NTAPI
    DbgUiStopDebugging(_In_ HANDLE Process);

    NTSYSAPI
    NTSTATUS
    NTAPI
    DbgUiDebugActiveProcess(_In_ HANDLE Process);

    /************************************************************************************
     *
     * RTL AVL Tree API.
     *
     ************************************************************************************/

    typedef enum _TABLE_SEARCH_RESULT
    {
        TableEmptyTree,
        TableFoundNode,
        TableInsertAsLeft,
        TableInsertAsRight
    } TABLE_SEARCH_RESULT;

    typedef enum _RTL_GENERIC_COMPARE_RESULTS
    {
        GenericLessThan,
        GenericGreaterThan,
        GenericEqual
    } RTL_GENERIC_COMPARE_RESULTS;

    //
    // Add an empty typedef so that functions can reference the
    // a pointer to the generic table struct before it is declared.
    //

#if defined(__cplusplus)
    struct _RTL_AVL_TABLE;
#else
typedef struct _RTL_AVL_TABLE RTL_AVL_TABLE;
typedef struct PRTL_AVL_TABLE* _RTL_AVL_TABLE;
#endif

    typedef RTL_GENERIC_COMPARE_RESULTS(NTAPI* PRTL_AVL_COMPARE_ROUTINE)(
        _In_ struct _RTL_AVL_TABLE* Table,
        _In_ PVOID FirstStruct,
        _In_ PVOID SecondStruct);

    typedef PVOID(NTAPI* PRTL_AVL_ALLOCATE_ROUTINE)(_In_ struct _RTL_AVL_TABLE* Table, _In_ ULONG ByteSize);

    typedef VOID(NTAPI* PRTL_AVL_FREE_ROUTINE)(_In_ struct _RTL_AVL_TABLE* Table, _In_ _Post_invalid_ PVOID Buffer);

    typedef NTSTATUS(
        NTAPI* PRTL_AVL_MATCH_FUNCTION)(_In_ struct _RTL_AVL_TABLE* Table, _In_ PVOID UserData, _In_ PVOID MatchData);

    typedef struct _RTL_BALANCED_LINKS
    {
        struct _RTL_BALANCED_LINKS* Parent;
        struct _RTL_BALANCED_LINKS* LeftChild;
        struct _RTL_BALANCED_LINKS* RightChild;
        CHAR Balance;
        UCHAR Reserved[3];
    } RTL_BALANCED_LINKS, *PRTL_BALANCED_LINKS;

    typedef struct _RTL_AVL_TABLE
    {
        RTL_BALANCED_LINKS BalancedRoot;
        PVOID OrderedPointer;
        ULONG WhichOrderedElement;
        ULONG NumberGenericTableElements;
        ULONG DepthOfTree;
        PRTL_BALANCED_LINKS RestartKey;
        ULONG DeleteCount;
        PRTL_AVL_COMPARE_ROUTINE CompareRoutine;
        PRTL_AVL_ALLOCATE_ROUTINE AllocateRoutine;
        PRTL_AVL_FREE_ROUTINE FreeRoutine;
        PVOID TableContext;
    } RTL_AVL_TABLE, *PRTL_AVL_TABLE;

    NTSYSAPI
    VOID NTAPI
    RtlInitializeGenericTableAvl(
        _Out_ PRTL_AVL_TABLE Table,
        _In_ PRTL_AVL_COMPARE_ROUTINE CompareRoutine,
        _In_ PRTL_AVL_ALLOCATE_ROUTINE AllocateRoutine,
        _In_ PRTL_AVL_FREE_ROUTINE FreeRoutine,
        _In_opt_ PVOID TableContext);

    NTSYSAPI
    PVOID
    NTAPI
    RtlInsertElementGenericTableAvl(
        _In_ PRTL_AVL_TABLE Table,
        _In_reads_bytes_(BufferSize) PVOID Buffer,
        _In_ CLONG BufferSize,
        _Out_opt_ PBOOLEAN NewElement);

    NTSYSAPI
    PVOID
    NTAPI
    RtlInsertElementGenericTableFullAvl(
        _In_ PRTL_AVL_TABLE Table,
        _In_reads_bytes_(BufferSize) PVOID Buffer,
        _In_ CLONG BufferSize,
        _Out_opt_ PBOOLEAN NewElement,
        _In_ PVOID NodeOrParent,
        _In_ TABLE_SEARCH_RESULT SearchResult);

    NTSYSAPI
    BOOLEAN
    NTAPI
    RtlDeleteElementGenericTableAvl(_In_ PRTL_AVL_TABLE Table, _In_ PVOID Buffer);

    NTSYSAPI
    PVOID
    NTAPI
    RtlLookupElementGenericTableAvl(_In_ PRTL_AVL_TABLE Table, _In_ PVOID Buffer);

    NTSYSAPI
    PVOID
    NTAPI
    RtlLookupElementGenericTableFullAvl(
        _In_ PRTL_AVL_TABLE Table,
        _In_ PVOID Buffer,
        _Out_ PVOID* NodeOrParent,
        _Out_ TABLE_SEARCH_RESULT* SearchResult);

    NTSYSAPI
    PVOID
    NTAPI
    RtlEnumerateGenericTableAvl(_In_ PRTL_AVL_TABLE Table, _In_ BOOLEAN Restart);

    NTSYSAPI
    PVOID
    NTAPI
    RtlEnumerateGenericTableWithoutSplayingAvl(_In_ PRTL_AVL_TABLE Table, _Inout_ PVOID* RestartKey);

    NTSYSAPI
    PVOID
    NTAPI
    RtlLookupFirstMatchingElementGenericTableAvl(_In_ PRTL_AVL_TABLE Table, _In_ PVOID Buffer, _Out_ PVOID* RestartKey);

    NTSYSAPI
    PVOID
    NTAPI
    RtlEnumerateGenericTableLikeADirectory(
        _In_ PRTL_AVL_TABLE Table,
        _In_opt_ PRTL_AVL_MATCH_FUNCTION MatchFunction,
        _In_opt_ PVOID MatchData,
        _In_ ULONG NextFlag,
        _Inout_ PVOID* RestartKey,
        _Inout_ PULONG DeleteCount,
        _In_ PVOID Buffer);

    NTSYSAPI
    PVOID
    NTAPI
    RtlGetElementGenericTableAvl(_In_ PRTL_AVL_TABLE Table, _In_ ULONG I);

    NTSYSAPI
    ULONG
    NTAPI
    RtlNumberGenericTableElementsAvl(_In_ PRTL_AVL_TABLE Table);

    NTSYSAPI
    BOOLEAN
    NTAPI
    RtlIsGenericTableEmptyAvl(_In_ PRTL_AVL_TABLE Table);

    /************************************************************************************
     *
     * RTL Critical Section Support API.
     *
     ************************************************************************************/

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlEnterCriticalSection(_In_ PRTL_CRITICAL_SECTION CriticalSection);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlLeaveCriticalSection(_In_ PRTL_CRITICAL_SECTION CriticalSection);

    NTSYSAPI
    LOGICAL
    NTAPI
    RtlIsCriticalSectionLocked(_In_ PRTL_CRITICAL_SECTION CriticalSection);

    NTSYSAPI
    LOGICAL
    NTAPI
    RtlIsCriticalSectionLockedByThread(_In_ PRTL_CRITICAL_SECTION CriticalSection);

    NTSYSAPI
    ULONG
    NTAPI
    RtlGetCriticalSectionRecursionCount(_In_ PRTL_CRITICAL_SECTION CriticalSection);

    NTSYSAPI
    LOGICAL
    NTAPI
    RtlTryEnterCriticalSection(_In_ PRTL_CRITICAL_SECTION CriticalSection);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlInitializeCriticalSection(_In_ PRTL_CRITICAL_SECTION CriticalSection);

    NTSYSAPI
    VOID NTAPI RtlEnableEarlyCriticalSectionEventCreation(VOID);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlInitializeCriticalSectionAndSpinCount(_In_ PRTL_CRITICAL_SECTION CriticalSection, _In_ ULONG SpinCount);

    NTSYSAPI
    ULONG
    NTAPI
    RtlSetCriticalSectionSpinCount(_In_ PRTL_CRITICAL_SECTION CriticalSection, _In_ ULONG SpinCount);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlDeleteCriticalSection(_In_ PRTL_CRITICAL_SECTION CriticalSection);

    /************************************************************************************
     *
     * RTL SRW Lock Support API.
     *
     ************************************************************************************/

    NTSYSAPI
    VOID NTAPI
    RtlInitializeSRWLock(_Out_ PRTL_SRWLOCK SRWLock);

    NTSYSAPI
    VOID NTAPI
    RtlAcquireSRWLockExclusive(_Inout_ PRTL_SRWLOCK SRWLock);

    NTSYSAPI
    VOID NTAPI
    RtlAcquireSRWLockShared(_Inout_ PRTL_SRWLOCK SRWLock);

    NTSYSAPI
    VOID NTAPI
    RtlReleaseSRWLockExclusive(_Inout_ PRTL_SRWLOCK SRWLock);

    NTSYSAPI
    VOID NTAPI
    RtlReleaseSRWLockShared(_Inout_ PRTL_SRWLOCK SRWLock);

    NTSYSAPI
    BOOLEAN
    NTAPI
    RtlTryAcquireSRWLockExclusive(_Inout_ PRTL_SRWLOCK SRWLock);

    NTSYSAPI
    BOOLEAN
    NTAPI
    RtlTryAcquireSRWLockShared(_Inout_ PRTL_SRWLOCK SRWLock);

    NTSYSAPI
    VOID NTAPI
    RtlAcquireReleaseSRWLockExclusive(_Inout_ PRTL_SRWLOCK SRWLock);

    NTSYSAPI
    VOID NTAPI
    RtlUpdateClonedSRWLock(_Inout_ PRTL_SRWLOCK SRWLock, _In_ LOGICAL Shared);

    /************************************************************************************
     *
     * RTL UAC Support API.
     *
     ************************************************************************************/

#define DBG_FLAG_ELEVATION_ENABLED 1
#define DBG_FLAG_VIRTUALIZATION_ENABLED 2
#define DBG_FLAG_INSTALLER_DETECT_ENABLED 3

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlQueryElevationFlags(_Inout_ ULONG* ElevationFlags);

    /************************************************************************************
     *
     * RTL Misc Support API.
     *
     ************************************************************************************/

    NTSYSAPI
    BOOLEAN
    NTAPI
    RtlDoesFileExists_U(_In_ PCWSTR FileName);

    NTSYSAPI
    ULONG
    NTAPI
    RtlGetLongestNtPathLength(VOID);

    NTSYSAPI
    BOOLEAN
    NTAPI
    RtlAreLongPathsEnabled(VOID);

    /************************************************************************************
     *
     * RTL Boundary Descriptor API.
     *
     ************************************************************************************/

    NTSYSAPI
    PVOID
    NTAPI
    RtlCreateBoundaryDescriptor(_In_ PUNICODE_STRING Name, _In_ ULONG Flags);

    NTSYSAPI
    VOID NTAPI
    RtlDeleteBoundaryDescriptor(_In_ PVOID BoundaryDescriptor);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlAddSIDToBoundaryDescriptor(_Inout_ PVOID* BoundaryDescriptor, _In_ PSID RequiredSid);

    NTSYSAPI
    NTSTATUS
    NTAPI
    RtlAddIntegrityLabelToBoundaryDescriptor(_Inout_ PVOID* BoundaryDescriptor, _In_ PSID IntegrityLabel);

    /************************************************************************************
     *
     * ETW API.
     *
     ************************************************************************************/

    struct _EVENT_FILTER_DESCRIPTOR;

    typedef VOID(NTAPI* PENABLECALLBACK)(
        _In_ LPCGUID SourceId,
        _In_ ULONG IsEnabled,
        _In_ UCHAR Level,
        _In_ ULONGLONG MatchAnyKeyword,
        _In_ ULONGLONG MatchAllKeyword,
        _In_opt_ struct _EVENT_FILTER_DESCRIPTOR* FilterData,
        _Inout_opt_ PVOID CallbackContext);

    NTSYSAPI
    NTSTATUS
    NTAPI
    EtwEventRegister(
        _In_ LPCGUID ProviderId,
        _In_opt_ PENABLECALLBACK EnableCallback,
        _In_opt_ PVOID CallbackContext,
        _Out_ PREGHANDLE RegHandle);

    /*
    ** Runtime Library API END
    */

    /*
    ** Native API START
    */

    /************************************************************************************
     *
     * System Information API.
     *
     ************************************************************************************/

    NTSYSAPI
    NTSTATUS
    WINAPI
    NtQuerySystemInformation(
        _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
        _Out_writes_bytes_opt_(SystemInformationLength) PVOID SystemInformation,
        _In_ ULONG SystemInformationLength,
        _Out_opt_ PULONG ReturnLength);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtQuerySystemInformationEx(
        _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
        _In_reads_bytes_(InputBufferLength) PVOID InputBuffer,
        _In_ ULONG InputBufferLength,
        _Out_writes_bytes_opt_(SystemInformationLength) PVOID SystemInformation,
        _In_ ULONG SystemInformationLength,
        _Out_opt_ PULONG ReturnLength);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtSetSystemInformation(
        _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
        _In_reads_bytes_opt_(SystemInformationLength) PVOID SystemInformation,
        _In_ ULONG SystemInformationLength);

    /************************************************************************************
     *
     * Event (EventPair) API.
     *
     ************************************************************************************/

    typedef enum _EVENT_INFORMATION_CLASS
    {
        EventBasicInformation
    } EVENT_INFORMATION_CLASS;

    typedef enum _EVENT_TYPE
    {
        NotificationEvent,
        SynchronizationEvent
    } EVENT_TYPE;

    typedef struct _EVENT_BASIC_INFORMATION
    {
        EVENT_TYPE EventType;
        LONG EventState;
    } EVENT_BASIC_INFORMATION, *PEVENT_BASIC_INFORMATION;

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtCreateEvent(
        _Out_ PHANDLE EventHandle,
        _In_ ACCESS_MASK DesiredAccess,
        _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
        _In_ EVENT_TYPE EventType,
        _In_ BOOLEAN InitialState);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtOpenEvent(_Out_ PHANDLE EventHandle, _In_ ACCESS_MASK DesiredAccess, _In_ POBJECT_ATTRIBUTES ObjectAttributes);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtSetEvent(_In_ HANDLE EventHandle, _Out_opt_ PLONG PreviousState);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtClearEvent(_In_ HANDLE EventHandle);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtResetEvent(_In_ HANDLE EventHandle, _Out_opt_ PLONG PreviousState);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtPulseEvent(_In_ HANDLE EventHandle, _Out_opt_ PLONG PreviousState);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtOpenKeyedEvent(
        _Out_ PHANDLE KeyedEventHandle,
        _In_ ACCESS_MASK DesiredAccess,
        _In_ POBJECT_ATTRIBUTES ObjectAttributes);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtQueryEvent(
        _In_ HANDLE EventHandle,
        _In_ EVENT_INFORMATION_CLASS EventInformationClass,
        _Out_writes_bytes_(EventInformationLength) PVOID EventInformation,
        _In_ ULONG EventInformationLength,
        _Out_opt_ PULONG ReturnLength);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtCreateEventPair(
        _Out_ PHANDLE EventPairHandle,
        _In_ ACCESS_MASK DesiredAccess,
        _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtOpenEventPair(
        _Out_ PHANDLE EventPairHandle,
        _In_ ACCESS_MASK DesiredAccess,
        _In_ POBJECT_ATTRIBUTES ObjectAttributes);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtSetLowEventPair(_In_ HANDLE EventPairHandle);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtSetHighEventPair(_In_ HANDLE EventPairHandle);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtWaitLowEventPair(_In_ HANDLE EventPairHandle);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtWaitHighEventPair(_In_ HANDLE EventPairHandle);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtSetLowWaitHighEventPair(_In_ HANDLE EventPairHandle);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtSetHighWaitLowEventPair(_In_ HANDLE EventPairHandle);

    /************************************************************************************
     *
     * Mutant API.
     *
     ************************************************************************************/

    typedef enum _MUTANT_INFORMATION_CLASS
    {
        MutantBasicInformation,
        MutantOwnerInformation
    } MUTANT_INFORMATION_CLASS;

    typedef struct _MUTANT_BASIC_INFORMATION
    {
        LONG CurrentCount;
        BOOLEAN OwnedByCaller;
        BOOLEAN AbandonedState;
    } MUTANT_BASIC_INFORMATION, *PMUTANT_BASIC_INFORMATION;

    typedef struct _MUTANT_OWNER_INFORMATION
    {
        CLIENT_ID ClientId;
    } MUTANT_OWNER_INFORMATION, *PMUTANT_OWNER_INFORMATION;

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtCreateMutant(
        _Out_ PHANDLE MutantHandle,
        _In_ ACCESS_MASK DesiredAccess,
        _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
        _In_ BOOLEAN InitialOwner);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtOpenMutant(_Out_ PHANDLE MutantHandle, _In_ ACCESS_MASK DesiredAccess, _In_ POBJECT_ATTRIBUTES ObjectAttributes);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtQueryMutant(
        _In_ HANDLE MutantHandle,
        _In_ MUTANT_INFORMATION_CLASS MutantInformationClass,
        _Out_writes_bytes_(MutantInformationLength) PVOID MutantInformation,
        _In_ ULONG MutantInformationLength,
        _Out_opt_ PULONG ReturnLength);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtReleaseMutant(_In_ HANDLE MutantHandle, _Out_opt_ PLONG PreviousCount);

    /************************************************************************************
     *
     * Timer API.
     *
     ************************************************************************************/

    typedef VOID (*PTIMER_APC_ROUTINE)(_In_ PVOID TimerContext, _In_ ULONG TimerLowValue, _In_ LONG TimerHighValue);

    typedef enum _TIMER_TYPE
    {
        NotificationTimer,
        SynchronizationTimer
    } TIMER_TYPE;

    typedef enum _TIMER_INFORMATION_CLASS
    {
        TimerBasicInformation
    } TIMER_INFORMATION_CLASS;

    typedef struct _TIMER_BASIC_INFORMATION
    {
        LARGE_INTEGER RemainingTime;
        BOOLEAN TimerState;
    } TIMER_BASIC_INFORMATION, *PTIMER_BASIC_INFORMATION;

    typedef enum _TIMER_SET_INFORMATION_CLASS
    {
        TimerSetCoalescableTimer,
        MaxTimerInfoClass
    } TIMER_SET_INFORMATION_CLASS;

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtCreateTimer(
        _In_ PHANDLE TimerHandle,
        _In_ ACCESS_MASK DesiredAccess,
        _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
        _In_ TIMER_TYPE TimerType);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtSetTimer(
        _In_ HANDLE TimerHandle,
        _In_ PLARGE_INTEGER DueTime,
        _In_opt_ PTIMER_APC_ROUTINE TimerApcRoutine,
        _In_opt_ PVOID TimerContext,
        _In_ BOOLEAN WakeTimer,
        _In_opt_ LONG Period,
        _Out_opt_ PBOOLEAN PreviousState);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtSetTimerEx(
        _In_ HANDLE TimerHandle,
        _In_ TIMER_SET_INFORMATION_CLASS TimerSetInformationClass,
        _Inout_updates_bytes_opt_(TimerSetInformationLength) PVOID TimerSetInformation,
        _In_ ULONG TimerSetInformationLength);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtOpenTimer(_In_ PHANDLE TimerHandle, _In_ ACCESS_MASK DesiredAccess, _In_ POBJECT_ATTRIBUTES ObjectAttributes);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtQueryTimer(
        _In_ HANDLE TimerHandle,
        _In_ TIMER_INFORMATION_CLASS TimerInformationClass,
        _Out_writes_bytes_(TimerInformationLength) PVOID TimerInformation,
        _In_ ULONG TimerInformationLength,
        _Out_opt_ PULONG ReturnLength);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtCancelTimer(_In_ HANDLE TimerHandle, _Out_opt_ PBOOLEAN CurrentState);

    // ref from ph2

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtCreateIRTimer(_Out_ PHANDLE TimerHandle, _In_ ACCESS_MASK DesiredAccess);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtSetIRTimer(_In_ HANDLE TimerHandle, _In_opt_ PLARGE_INTEGER DueTime);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtCreateTimer2(
        _Out_ PHANDLE TimerHandle,
        _In_opt_ PVOID Reserved1,
        _In_opt_ PVOID Reserved2,
        _In_ ULONG Attributes,
        _In_ ACCESS_MASK DesiredAccess);

    /************************************************************************************
     *
     * Semaphore API.
     *
     ************************************************************************************/

    typedef enum _SEMAPHORE_INFORMATION_CLASS
    {
        SemaphoreBasicInformation
    } SEMAPHORE_INFORMATION_CLASS;

    typedef struct _SEMAPHORE_BASIC_INFORMATION
    {
        LONG CurrentCount;
        LONG MaximumCount;
    } SEMAPHORE_BASIC_INFORMATION, *PSEMAPHORE_BASIC_INFORMATION;

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtCreateSemaphore(
        _Out_ PHANDLE SemaphoreHandle,
        _In_ ACCESS_MASK DesiredAccess,
        _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
        _In_ LONG InitialCount,
        _In_ LONG MaximumCount);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtOpenSemaphore(
        _Out_ PHANDLE SemaphoreHandle,
        _In_ ACCESS_MASK DesiredAccess,
        _In_ POBJECT_ATTRIBUTES ObjectAttributes);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtQuerySemaphore(
        _In_ HANDLE SemaphoreHandle,
        _In_ SEMAPHORE_INFORMATION_CLASS SemaphoreInformationClass,
        _Out_writes_bytes_(SemaphoreInformationLength) PVOID SemaphoreInformation,
        _In_ ULONG SemaphoreInformationLength,
        _Out_opt_ PULONG ReturnLength);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtReleaseSemaphore(_In_ HANDLE SemaphoreHandle, _In_ LONG ReleaseCount, _Out_opt_ PLONG PreviousCount);

    /************************************************************************************
     *
     * Object and Handle API.
     *
     ************************************************************************************/
    typedef enum _OBJECT_INFORMATION_CLASS
    {
        ObjectBasicInformation,
        ObjectNameInformation,
        ObjectTypeInformation,
        ObjectTypesInformation,
        ObjectHandleFlagInformation,
        ObjectSessionInformation,
        ObjectSessionObjectInformation,
        MaxObjectInfoClass
    } OBJECT_INFORMATION_CLASS;

    typedef struct _OBJECT_DIRECTORY_INFORMATION
    {
        UNICODE_STRING Name;
        UNICODE_STRING TypeName;
    } OBJECT_DIRECTORY_INFORMATION, *POBJECT_DIRECTORY_INFORMATION;

    typedef struct _OBJECT_BASIC_INFORMATION
    {
        ULONG Attributes;
        ACCESS_MASK GrantedAccess;
        ULONG HandleCount;
        ULONG PointerCount;
        ULONG PagedPoolCharge;
        ULONG NonPagedPoolCharge;
        ULONG Reserved[3];
        ULONG NameInfoSize;
        ULONG TypeInfoSize;
        ULONG SecurityDescriptorSize;
        LARGE_INTEGER CreationTime;
    } OBJECT_BASIC_INFORMATION, *POBJECT_BASIC_INFORMATION;

    typedef struct _OBJECT_NAME_INFORMATION
    {
        UNICODE_STRING Name;
    } OBJECT_NAME_INFORMATION, *POBJECT_NAME_INFORMATION;

    typedef struct _OBJECT_TYPE_INFORMATION
    {
        UNICODE_STRING TypeName;
        ULONG TotalNumberOfObjects;
        ULONG TotalNumberOfHandles;
        ULONG TotalPagedPoolUsage;
        ULONG TotalNonPagedPoolUsage;
        ULONG TotalNamePoolUsage;
        ULONG TotalHandleTableUsage;
        ULONG HighWaterNumberOfObjects;
        ULONG HighWaterNumberOfHandles;
        ULONG HighWaterPagedPoolUsage;
        ULONG HighWaterNonPagedPoolUsage;
        ULONG HighWaterNamePoolUsage;
        ULONG HighWaterHandleTableUsage;
        ULONG InvalidAttributes;
        GENERIC_MAPPING GenericMapping;
        ULONG ValidAccessMask;
        BOOLEAN SecurityRequired;
        BOOLEAN MaintainHandleCount;
        ULONG PoolType;
        ULONG DefaultPagedPoolCharge;
        ULONG DefaultNonPagedPoolCharge;
    } OBJECT_TYPE_INFORMATION, *POBJECT_TYPE_INFORMATION;

    typedef struct _OBJECT_TYPE_INFORMATION_V2
    {
        UNICODE_STRING TypeName;
        ULONG TotalNumberOfObjects;
        ULONG TotalNumberOfHandles;
        ULONG TotalPagedPoolUsage;
        ULONG TotalNonPagedPoolUsage;
        ULONG TotalNamePoolUsage;
        ULONG TotalHandleTableUsage;
        ULONG HighWaterNumberOfObjects;
        ULONG HighWaterNumberOfHandles;
        ULONG HighWaterPagedPoolUsage;
        ULONG HighWaterNonPagedPoolUsage;
        ULONG HighWaterNamePoolUsage;
        ULONG HighWaterHandleTableUsage;
        ULONG InvalidAttributes;
        GENERIC_MAPPING GenericMapping;
        ULONG ValidAccessMask;
        BOOLEAN SecurityRequired;
        BOOLEAN MaintainHandleCount;
        UCHAR TypeIndex;
        CHAR ReservedByte;
        ULONG PoolType;
        ULONG DefaultPagedPoolCharge;
        ULONG DefaultNonPagedPoolCharge;
    } OBJECT_TYPE_INFORMATION_V2, *POBJECT_TYPE_INFORMATION_V2;

    typedef struct _OBJECT_TYPES_INFORMATION
    {
        ULONG NumberOfTypes;
    } OBJECT_TYPES_INFORMATION, *POBJECT_TYPES_INFORMATION;

#define OBJECT_TYPES_FIRST_ENTRY(ObjectTypes)                                                                          \
    (POBJECT_TYPE_INFORMATION) RtlOffsetToPointer(ObjectTypes, ALIGN_UP(sizeof(OBJECT_TYPES_INFORMATION), ULONG_PTR))

#define OBJECT_TYPES_NEXT_ENTRY(ObjectType)                                                                            \
    (POBJECT_TYPE_INFORMATION) RtlOffsetToPointer(                                                                     \
        ObjectType,                                                                                                    \
        sizeof(OBJECT_TYPE_INFORMATION) + ALIGN_UP(ObjectType->TypeName.MaximumLength, ULONG_PTR))

    typedef struct _OBJECT_HANDLE_FLAG_INFORMATION
    {
        BOOLEAN Inherit;
        BOOLEAN ProtectFromClose;
    } OBJECT_HANDLE_FLAG_INFORMATION, *POBJECT_HANDLE_FLAG_INFORMATION;

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtClose(_In_ HANDLE Handle);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtDuplicateObject(
        _In_ HANDLE SourceProcessHandle,
        _In_ HANDLE SourceHandle,
        _In_opt_ HANDLE TargetProcessHandle,
        _Out_ PHANDLE TargetHandle,
        _In_ ACCESS_MASK DesiredAccess,
        _In_ ULONG HandleAttributes,
        _In_ ULONG Options);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtMakePermanentObject(_In_ HANDLE Handle);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtMakeTemporaryObject(_In_ HANDLE Handle);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtSetSecurityObject(
        _In_ HANDLE Handle,
        _In_ SECURITY_INFORMATION SecurityInformation,
        _In_ PSECURITY_DESCRIPTOR SecurityDescriptor);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtQuerySecurityObject(
        _In_ HANDLE Handle,
        _In_ SECURITY_INFORMATION SecurityInformation,
        _Out_writes_bytes_opt_(Length) PSECURITY_DESCRIPTOR SecurityDescriptor,
        _In_ ULONG Length,
        _Out_ PULONG LengthNeeded);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtCompareObjects(_In_ HANDLE FirstObjectHandle, _In_ HANDLE SecondObjectHandle);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtQueryObject(
        _In_opt_ HANDLE Handle,
        _In_ OBJECT_INFORMATION_CLASS ObjectInformationClass,
        _Out_writes_bytes_opt_(ObjectInformationLength) PVOID ObjectInformation,
        _In_ ULONG ObjectInformationLength,
        _Out_opt_ PULONG ReturnLength);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtSetInformationObject(
        _In_ HANDLE Handle,
        _In_ OBJECT_INFORMATION_CLASS ObjectInformationClass,
        _In_reads_bytes_(ObjectInformationLength) PVOID ObjectInformation,
        _In_ ULONG ObjectInformationLength);

    typedef enum _WAIT_TYPE
    {
        WaitAll,
        WaitAny,
        WaitNotification
    } WAIT_TYPE;

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtWaitForSingleObject(_In_ HANDLE Handle, _In_ BOOLEAN Alertable, _In_opt_ PLARGE_INTEGER Timeout);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtWaitForMultipleObjects(
        _In_ ULONG Count,
        _In_reads_(Count) HANDLE Handles[],
        _In_ WAIT_TYPE WaitType,
        _In_ BOOLEAN Alertable,
        _In_opt_ PLARGE_INTEGER Timeout);

    /************************************************************************************
     *
     * Directory Object API.
     *
     ************************************************************************************/

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtCreateDirectoryObject(
        _Out_ PHANDLE DirectoryHandle,
        _In_ ACCESS_MASK DesiredAccess,
        _In_ POBJECT_ATTRIBUTES ObjectAttributes);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtCreateDirectoryObjectEx(
        _Out_ PHANDLE DirectoryHandle,
        _In_ ACCESS_MASK DesiredAccess,
        _In_ POBJECT_ATTRIBUTES ObjectAttributes,
        _In_ HANDLE ShadowDirectoryHandle,
        _In_ ULONG Flags);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtOpenDirectoryObject(
        _Out_ PHANDLE DirectoryHandle,
        _In_ ACCESS_MASK DesiredAccess,
        _In_ POBJECT_ATTRIBUTES ObjectAttributes);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtQueryDirectoryObject(
        _In_ HANDLE DirectoryHandle,
        _Out_writes_bytes_opt_(Length) PVOID Buffer,
        _In_ ULONG Length,
        _In_ BOOLEAN ReturnSingleEntry,
        _In_ BOOLEAN RestartScan,
        _Inout_ PULONG Context,
        _Out_opt_ PULONG ReturnLength);

    /************************************************************************************
     *
     * Private Namespace API.
     *
     ************************************************************************************/

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtCreatePrivateNamespace(
        _Out_ PHANDLE NamespaceHandle,
        _In_ ACCESS_MASK DesiredAccess,
        _In_ POBJECT_ATTRIBUTES ObjectAttributes,
        _In_ PVOID BoundaryDescriptor);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtOpenPrivateNamespace(
        _Out_ PHANDLE NamespaceHandle,
        _In_ ACCESS_MASK DesiredAccess,
        _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
        _In_ PVOID BoundaryDescriptor);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtDeletePrivateNamespace(_In_ HANDLE NamespaceHandle);

    /************************************************************************************
     *
     * Symbolic Link API.
     *
     ************************************************************************************/

    typedef struct _OBJECT_SYMBOLIC_LINK_V1
    { // pre Win10 TH1
        LARGE_INTEGER CreationTime;
        UNICODE_STRING LinkTarget;
        ULONG DosDeviceDriveIndex;
    } OBJECT_SYMBOLIC_LINK_V1, *POBJECT_SYMBOLIC_LINK_V1;

    typedef struct _OBJECT_SYMBOLIC_LINK_V2
    { // Win10 TH1/TH2
        LARGE_INTEGER CreationTime;
        UNICODE_STRING LinkTarget;
        ULONG DosDeviceDriveIndex;
        ULONG Flags;
    } OBJECT_SYMBOLIC_LINK_V2, *POBJECT_SYMBOLIC_LINK_V2;

    typedef struct _OBJECT_SYMBOLIC_LINK_V3
    { // Win10 RS1
        LARGE_INTEGER CreationTime;
        UNICODE_STRING LinkTarget;
        ULONG DosDeviceDriveIndex;
        ULONG Flags;
        ULONG AccessMask;
    } OBJECT_SYMBOLIC_LINK_V3, *POBJECT_SYMBOLIC_LINK_V3;

    typedef struct _OBJECT_SYMBOLIC_LINK_V4
    { // Win10 RS2+
        LARGE_INTEGER CreationTime;
        union
        {
            UNICODE_STRING LinkTarget;
            struct
            {
                PVOID Callback;
                PVOID CallbackContext;
            };
        } u1;
        ULONG DosDeviceDriveIndex;
        ULONG Flags;
        ULONG AccessMask;
    } OBJECT_SYMBOLIC_LINK_V4, *POBJECT_SYMBOLIC_LINK_V4;

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtCreateSymbolicLinkObject(
        _Out_ PHANDLE LinkHandle,
        _In_ ACCESS_MASK DesiredAccess,
        _In_ POBJECT_ATTRIBUTES ObjectAttributes,
        _In_ PUNICODE_STRING LinkTarget);

    NTSYSAPI
    NTSTATUS
    WINAPI
    NtOpenSymbolicLinkObject(
        _Out_ PHANDLE LinkHandle,
        _In_ ACCESS_MASK DesiredAccess,
        _In_ POBJECT_ATTRIBUTES ObjectAttributes);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtQuerySymbolicLinkObject(
        _In_ HANDLE LinkHandle,
        _Inout_ PUNICODE_STRING LinkTarget,
        _Out_opt_ PULONG ReturnedLength);

    /************************************************************************************
     *
     * File API (+Driver&HotPatch).
     *
     ************************************************************************************/

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtCreateFile(
        _Out_ PHANDLE FileHandle,
        _In_ ACCESS_MASK DesiredAccess,
        _In_ POBJECT_ATTRIBUTES ObjectAttributes,
        _Out_ PIO_STATUS_BLOCK IoStatusBlock,
        _In_opt_ PLARGE_INTEGER AllocationSize,
        _In_ ULONG FileAttributes,
        _In_ ULONG ShareAccess,
        _In_ ULONG CreateDisposition,
        _In_ ULONG CreateOptions,
        _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,
        _In_ ULONG EaLength);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtCreateNamedPipeFile(
        _Out_ PHANDLE FileHandle,
        _In_ ULONG DesiredAccess,
        _In_ POBJECT_ATTRIBUTES ObjectAttributes,
        _Out_ PIO_STATUS_BLOCK IoStatusBlock,
        _In_ ULONG ShareAccess,
        _In_ ULONG CreateDisposition,
        _In_ ULONG CreateOptions,
        _In_ ULONG NamedPipeType,
        _In_ ULONG ReadMode,
        _In_ ULONG CompletionMode,
        _In_ ULONG MaximumInstances,
        _In_ ULONG InboundQuota,
        _In_ ULONG OutboundQuota,
        _In_opt_ PLARGE_INTEGER DefaultTimeout);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtCreateMailslotFile(
        _Out_ PHANDLE FileHandle,
        _In_ ULONG DesiredAccess,
        _In_ POBJECT_ATTRIBUTES ObjectAttributes,
        _Out_ PIO_STATUS_BLOCK IoStatusBlock,
        _In_ ULONG CreateOptions,
        _In_ ULONG MailslotQuota,
        _In_ ULONG MaximumMessageSize,
        _In_ PLARGE_INTEGER ReadTimeout);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtDeviceIoControlFile(
        _In_ HANDLE FileHandle,
        _In_opt_ HANDLE Event,
        _In_opt_ PIO_APC_ROUTINE ApcRoutine,
        _In_opt_ PVOID ApcContext,
        _Out_ PIO_STATUS_BLOCK IoStatusBlock,
        _In_ ULONG IoControlCode,
        _In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,
        _In_ ULONG InputBufferLength,
        _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,
        _In_ ULONG OutputBufferLength);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtFsControlFile(
        _In_ HANDLE FileHandle,
        _In_opt_ HANDLE Event,
        _In_opt_ PIO_APC_ROUTINE ApcRoutine,
        _In_opt_ PVOID ApcContext,
        _Out_ PIO_STATUS_BLOCK IoStatusBlock,
        _In_ ULONG FsControlCode,
        _In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,
        _In_ ULONG InputBufferLength,
        _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,
        _In_ ULONG OutputBufferLength);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtOpenFile(
        _Out_ PHANDLE FileHandle,
        _In_ ACCESS_MASK DesiredAccess,
        _In_ POBJECT_ATTRIBUTES ObjectAttributes,
        _Out_ PIO_STATUS_BLOCK IoStatusBlock,
        _In_ ULONG ShareAccess,
        _In_ ULONG OpenOptions);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtReadFile(
        _In_ HANDLE FileHandle,
        _In_opt_ HANDLE Event,
        _In_opt_ PIO_APC_ROUTINE ApcRoutine,
        _In_opt_ PVOID ApcContext,
        _Out_ PIO_STATUS_BLOCK IoStatusBlock,
        _Out_writes_bytes_(Length) PVOID Buffer,
        _In_ ULONG Length,
        _In_opt_ PLARGE_INTEGER ByteOffset,
        _In_opt_ PULONG Key);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtWriteFile(
        _In_ HANDLE FileHandle,
        _In_opt_ HANDLE Event,
        _In_opt_ PIO_APC_ROUTINE ApcRoutine,
        _In_opt_ PVOID ApcContext,
        _Out_ PIO_STATUS_BLOCK IoStatusBlock,
        _In_reads_bytes_(Length) PVOID Buffer,
        _In_ ULONG Length,
        _In_opt_ PLARGE_INTEGER ByteOffset,
        _In_opt_ PULONG Key);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtLockFile(
        _In_ HANDLE FileHandle,
        _In_opt_ HANDLE Event,
        _In_opt_ PIO_APC_ROUTINE ApcRoutine,
        _In_opt_ PVOID ApcContext,
        _Out_ PIO_STATUS_BLOCK IoStatusBlock,
        _In_ PLARGE_INTEGER ByteOffset,
        _In_ PLARGE_INTEGER Length,
        _In_ ULONG Key,
        _In_ BOOLEAN FailImmediately,
        _In_ BOOLEAN ExclusiveLock);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtUnlockFile(
        _In_ HANDLE FileHandle,
        _Out_ PIO_STATUS_BLOCK IoStatusBlock,
        _In_ PLARGE_INTEGER ByteOffset,
        _In_ PLARGE_INTEGER Length,
        _In_ ULONG Key);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtFlushBuffersFile(_In_ HANDLE FileHandle, _Out_ PIO_STATUS_BLOCK IoStatusBlock);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtSetInformationFile(
        _In_ HANDLE FileHandle,
        _Out_ PIO_STATUS_BLOCK IoStatusBlock,
        _In_ PVOID FileInformation,
        _In_ ULONG Length,
        _In_ FILE_INFORMATION_CLASS FileInformationClass);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtDeleteFile(_In_ POBJECT_ATTRIBUTES ObjectAttributes);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtQueryInformationFile(
        _In_ HANDLE FileHandle,
        _Out_ PIO_STATUS_BLOCK IoStatusBlock,
        _Out_writes_bytes_(Length) PVOID FileInformation,
        _In_ ULONG Length,
        _In_ FILE_INFORMATION_CLASS FileInformationClass);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtQueryFullAttributesFile(
        _In_ POBJECT_ATTRIBUTES ObjectAttributes,
        _Out_ PFILE_NETWORK_OPEN_INFORMATION FileInformation);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtQueryDirectoryFile(
        _In_ HANDLE FileHandle,
        _In_opt_ HANDLE Event,
        _In_opt_ PIO_APC_ROUTINE ApcRoutine,
        _In_opt_ PVOID ApcContext,
        _Out_ PIO_STATUS_BLOCK IoStatusBlock,
        _Out_writes_bytes_(Length) PVOID FileInformation,
        _In_ ULONG Length,
        _In_ FILE_INFORMATION_CLASS FileInformationClass,
        _In_ BOOLEAN ReturnSingleEntry,
        _In_opt_ PUNICODE_STRING FileName,
        _In_ BOOLEAN RestartScan);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtQueryEaFile(
        _In_ HANDLE FileHandle,
        _Out_ PIO_STATUS_BLOCK IoStatusBlock,
        _Out_writes_bytes_(Length) PVOID Buffer,
        _In_ ULONG Length,
        _In_ BOOLEAN ReturnSingleEntry,
        _In_reads_bytes_opt_(EaListLength) PVOID EaList,
        _In_ ULONG EaListLength,
        _In_opt_ PULONG EaIndex,
        _In_ BOOLEAN RestartScan);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtSetEaFile(
        _In_ HANDLE FileHandle,
        _Out_ PIO_STATUS_BLOCK IoStatusBlock,
        _In_bytecount_(Length) PVOID Buffer,
        _In_ ULONG Length);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtQueryVolumeInformationFile(
        _In_ HANDLE FileHandle,
        _Out_ PIO_STATUS_BLOCK IoStatusBlock,
        _Out_writes_bytes_(Length) PVOID FsInformation,
        _In_ ULONG Length,
        _In_ FS_INFORMATION_CLASS FsInformationClass);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtQueryQuotaInformationFile(
        _In_ HANDLE FileHandle,
        _Out_ PIO_STATUS_BLOCK IoStatusBlock,
        _Out_writes_bytes_(Length) PVOID Buffer,
        _In_ ULONG Length,
        _In_ BOOLEAN ReturnSingleEntry,
        _In_reads_bytes_opt_(SidListLength) PVOID SidList,
        _In_ ULONG SidListLength,
        _In_opt_ PSID StartSid,
        _In_ BOOLEAN RestartScan);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtSetQuotaInformationFile(
        _In_ HANDLE FileHandle,
        _Out_ PIO_STATUS_BLOCK IoStatusBlock,
        _In_reads_bytes_(Length) PVOID Buffer,
        _In_ ULONG Length);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtReadFileScatter(
        _In_ HANDLE FileHandle,
        _In_opt_ HANDLE Event,
        _In_opt_ PIO_APC_ROUTINE ApcRoutine,
        _In_opt_ PVOID ApcContext,
        _Out_ PIO_STATUS_BLOCK IoStatusBlock,
        _In_ PFILE_SEGMENT_ELEMENT SegmentArray,
        _In_ ULONG Length,
        _In_opt_ PLARGE_INTEGER ByteOffset,
        _In_opt_ PULONG Key);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtWriteFileGather(
        _In_ HANDLE FileHandle,
        _In_opt_ HANDLE Event,
        _In_opt_ PIO_APC_ROUTINE ApcRoutine,
        _In_opt_ PVOID ApcContext,
        _Out_ PIO_STATUS_BLOCK IoStatusBlock,
        _In_ PFILE_SEGMENT_ELEMENT SegmentArray,
        _In_ ULONG Length,
        _In_opt_ PLARGE_INTEGER ByteOffset,
        _In_opt_ PULONG Key);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtQueryDirectoryFile(
        _In_ HANDLE FileHandle,
        _In_opt_ HANDLE Event,
        _In_opt_ PIO_APC_ROUTINE ApcRoutine,
        _In_opt_ PVOID ApcContext,
        _Out_ PIO_STATUS_BLOCK IoStatusBlock,
        _Out_writes_bytes_(Length) PVOID FileInformation,
        _In_ ULONG Length,
        _In_ FILE_INFORMATION_CLASS FileInformationClass,
        _In_ BOOLEAN ReturnSingleEntry,
        _In_opt_ PUNICODE_STRING FileName,
        _In_ BOOLEAN RestartScan);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtNotifyChangeDirectoryFile(
        _In_ HANDLE FileHandle,
        _In_opt_ HANDLE Event,
        _In_opt_ PIO_APC_ROUTINE ApcRoutine,
        _In_opt_ PVOID ApcContext,
        _Out_ PIO_STATUS_BLOCK IoStatusBlock,
        _Out_writes_bytes_(Length) PVOID Buffer,
        _In_ ULONG Length,
        _In_ ULONG CompletionFilter,
        _In_ BOOLEAN WatchTree);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtLoadDriver(_In_ PUNICODE_STRING DriverServiceName);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtUnloadDriver(_In_ PUNICODE_STRING DriverServiceName);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtLoadHotPatch(_In_ PUNICODE_STRING HotPatchName, _Reserved_ ULONG LoadFlag);

    /************************************************************************************
     *
     * Section API (+MemoryPartitions).
     *
     ************************************************************************************/

#define MEM_EXECUTE_OPTION_DISABLE 0x1
#define MEM_EXECUTE_OPTION_ENABLE 0x2
#define MEM_EXECUTE_OPTION_DISABLE_THUNK_EMULATION 0x4
#define MEM_EXECUTE_OPTION_PERMANENT 0x8
#define MEM_EXECUTE_OPTION_EXECUTE_DISPATCH_ENABLE 0x10
#define MEM_EXECUTE_OPTION_IMAGE_DISPATCH_ENABLE 0x20
#define MEM_EXECUTE_OPTION_VALID_FLAGS 0x3f

    typedef enum _MEMORY_PARTITION_INFORMATION_CLASS
    {
        SystemMemoryPartitionInformation,
        SystemMemoryPartitionMoveMemory,
        SystemMemoryPartitionAddPagefile,
        SystemMemoryPartitionCombineMemory,
        SystemMemoryPartitionInitialAddMemory,
        SystemMemoryPartitionGetMemoryEvents,
        SystemMemoryPartitionMax
    } MEMORY_PARTITION_INFORMATION_CLASS;

    typedef struct _MEMORY_PARTITION_PAGE_RANGE
    {
        ULONG_PTR StartPage;
        ULONG_PTR NumberOfPages;
    } MEMORY_PARTITION_PAGE_RANGE, *PMEMORY_PARTITION_PAGE_RANGE;

    typedef struct _MEMORY_PARTITION_INITIAL_ADD_INFORMATION
    {
        ULONG Flags;
        ULONG NumberOfRanges;
        ULONG_PTR NumberOfPagesAdded;
        MEMORY_PARTITION_PAGE_RANGE PartitionRanges[1];
    } MEMORY_PARTITION_INITIAL_ADD_INFORMATION, *PMEMORY_PARTITION_INITIAL_ADD_INFORMATION;

    typedef struct _MEMORY_PARTITION_PAGE_COMBINE_INFORMATION
    {
        PVOID StopHandle;
        ULONG Flags;
        ULONG_PTR TotalNumberOfPages;
    } MEMORY_PARTITION_PAGE_COMBINE_INFORMATION, *PMEMORY_PARTITION_PAGE_COMBINE_INFORMATION;

    typedef struct _MEMORY_PARTITION_PAGEFILE_INFORMATION
    {
        UNICODE_STRING PageFileName;
        LARGE_INTEGER MinimumSize;
        LARGE_INTEGER MaximumSize;
        ULONG Flags;
    } MEMORY_PARTITION_PAGEFILE_INFORMATION, *PMEMORY_PARTITION_PAGEFILE_INFORMATION;

    typedef struct _MEMORY_PARTITION_TRANSFER_INFORMATION
    {
        ULONG_PTR NumberOfPages;
        ULONG NumaNode;
        ULONG Flags;
    } MEMORY_PARTITION_TRANSFER_INFORMATION, *PMEMORY_PARTITION_TRANSFER_INFORMATION;

    typedef struct _MEMORY_PARTITION_CONFIGURATION_INFORMATION
    {
        ULONG Flags;
        ULONG NumaNode;
        ULONG Channel;
        ULONG NumberOfNumaNodes;
        ULONG_PTR ResidentAvailablePages;
        ULONG_PTR CommittedPages;
        ULONG_PTR CommitLimit;
        ULONG_PTR PeakCommitment;
        ULONG_PTR TotalNumberOfPages;
        ULONG_PTR AvailablePages;
        ULONG_PTR ZeroPages;
        ULONG_PTR FreePages;
        ULONG_PTR StandbyPages;
    } MEMORY_PARTITION_CONFIGURATION_INFORMATION, *PMEMORY_PARTITION_CONFIGURATION_INFORMATION;

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtCreateSection(
        _Out_ PHANDLE SectionHandle,
        _In_ ACCESS_MASK DesiredAccess,
        _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
        _In_opt_ PLARGE_INTEGER MaximumSize,
        _In_ ULONG SectionPageProtection,
        _In_ ULONG AllocationAttributes,
        _In_opt_ HANDLE FileHandle);

    // taken from ph2
    NTSYSAPI
    NTSTATUS
    NTAPI
    NtCreateSectionEx(
        _Out_ PHANDLE SectionHandle,
        _In_ ACCESS_MASK DesiredAccess,
        _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
        _In_opt_ PLARGE_INTEGER MaximumSize,
        _In_ ULONG SectionPageProtection,
        _In_ ULONG AllocationAttributes,
        _In_opt_ HANDLE FileHandle,
        _In_ PMEM_EXTENDED_PARAMETER ExtendedParameters,
        _In_ ULONG ExtendedParameterCount);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtOpenSection(
        _Out_ PHANDLE SectionHandle,
        _In_ ACCESS_MASK DesiredAccess,
        _In_ POBJECT_ATTRIBUTES ObjectAttributes);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtMapViewOfSection(
        _In_ HANDLE SectionHandle,
        _In_ HANDLE ProcessHandle,
        _Inout_ _At_(
            *BaseAddress,
            _Readable_bytes_(*ViewSize) _Writable_bytes_(*ViewSize) _Post_readable_byte_size_(*ViewSize))
            PVOID* BaseAddress,
        _In_ ULONG_PTR ZeroBits,
        _In_ SIZE_T CommitSize,
        _Inout_opt_ PLARGE_INTEGER SectionOffset,
        _Inout_ PSIZE_T ViewSize,
        _In_ SECTION_INHERIT InheritDisposition,
        _In_ ULONG AllocationType,
        _In_ ULONG Win32Protect);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtUnmapViewOfSection(_In_ HANDLE ProcessHandle, _In_opt_ PVOID BaseAddress);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtUnmapViewOfSectionEx(_In_ HANDLE ProcessHandle, _In_opt_ PVOID BaseAddress, _In_ ULONG Flags);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtQuerySection(
        _In_ HANDLE SectionHandle,
        _In_ SECTION_INFORMATION_CLASS SectionInformationClass,
        _Out_writes_bytes_(SectionInformationLength) PVOID SectionInformation,
        _In_ SIZE_T SectionInformationLength,
        _Out_opt_ PSIZE_T ReturnLength);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtExtendSection(_In_ HANDLE SectionHandle, _Inout_ PLARGE_INTEGER NewSectionSize);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtMapUserPhysicalPages(
        _In_ PVOID VirtualAddress,
        _In_ ULONG_PTR NumberOfPages,
        _In_reads_opt_(NumberOfPages) PULONG_PTR UserPfnArray);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtMapUserPhysicalPagesScatter(
        _In_reads_(NumberOfPages) PVOID* VirtualAddresses,
        _In_ ULONG_PTR NumberOfPages,
        _In_reads_opt_(NumberOfPages) PULONG_PTR UserPfnArray);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtAllocateUserPhysicalPages(
        _In_ HANDLE ProcessHandle,
        _Inout_ PULONG_PTR NumberOfPages,
        _Out_writes_(*NumberOfPages) PULONG_PTR UserPfnArray);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtFreeUserPhysicalPages(
        _In_ HANDLE ProcessHandle,
        _Inout_ PULONG_PTR NumberOfPages,
        _In_reads_(*NumberOfPages) PULONG_PTR UserPfnArray);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtAreMappedFilesTheSame(_In_ PVOID File1MappedAsAnImage, _In_ PVOID File2MappedAsFile);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtOpenPartition(
        _Out_ PHANDLE PartitionHandle,
        _In_ ACCESS_MASK DesiredAccess,
        _In_ POBJECT_ATTRIBUTES ObjectAttributes);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtManagePartition(
        _In_ HANDLE TargetHandle,
        _In_opt_ HANDLE SourceHandle,
        _In_ MEMORY_PARTITION_INFORMATION_CLASS PartitionInformationClass,
        _In_ PVOID PartitionInformation,
        _In_ ULONG PartitionInformationLength);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtCreatePartition(
        _Out_ PHANDLE PartitionHandle,
        _In_ ACCESS_MASK DesiredAccess,
        _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
        _In_ ULONG PreferredNode);

    /************************************************************************************
     *
     * Token API.
     *
     ************************************************************************************/

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtAccessCheck(
        _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
        _In_ HANDLE ClientToken,
        _In_ ACCESS_MASK DesiredAccess,
        _In_ PGENERIC_MAPPING GenericMapping,
        _Out_writes_bytes_(*PrivilegeSetLength) PPRIVILEGE_SET PrivilegeSet,
        _Inout_ PULONG PrivilegeSetLength,
        _Out_ PACCESS_MASK GrantedAccess,
        _Out_ PNTSTATUS AccessStatus);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtAccessCheckByType(
        _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
        _In_opt_ PSID PrincipalSelfSid,
        _In_ HANDLE ClientToken,
        _In_ ACCESS_MASK DesiredAccess,
        _In_reads_(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
        _In_ ULONG ObjectTypeListLength,
        _In_ PGENERIC_MAPPING GenericMapping,
        _Out_writes_bytes_(*PrivilegeSetLength) PPRIVILEGE_SET PrivilegeSet,
        _Inout_ PULONG PrivilegeSetLength,
        _Out_ PACCESS_MASK GrantedAccess,
        _Out_ PNTSTATUS AccessStatus);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtAccessCheckByTypeResultList(
        _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
        _In_opt_ PSID PrincipalSelfSid,
        _In_ HANDLE ClientToken,
        _In_ ACCESS_MASK DesiredAccess,
        _In_reads_(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
        _In_ ULONG ObjectTypeListLength,
        _In_ PGENERIC_MAPPING GenericMapping,
        _Out_writes_bytes_(*PrivilegeSetLength) PPRIVILEGE_SET PrivilegeSet,
        _Inout_ PULONG PrivilegeSetLength,
        _Out_writes_(ObjectTypeListLength) PACCESS_MASK GrantedAccess,
        _Out_writes_(ObjectTypeListLength) PNTSTATUS AccessStatus);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtOpenObjectAuditAlarm(
        _In_ PUNICODE_STRING SubsystemName,
        _In_opt_ PVOID HandleId,
        _In_ PUNICODE_STRING ObjectTypeName,
        _In_ PUNICODE_STRING ObjectName,
        _In_opt_ PSECURITY_DESCRIPTOR SecurityDescriptor,
        _In_ HANDLE ClientToken,
        _In_ ACCESS_MASK DesiredAccess,
        _In_ ACCESS_MASK GrantedAccess,
        _In_opt_ PPRIVILEGE_SET Privileges,
        _In_ BOOLEAN ObjectCreation,
        _In_ BOOLEAN AccessGranted,
        _Out_ PBOOLEAN GenerateOnClose);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtCloseObjectAuditAlarm(_In_ PUNICODE_STRING SubsystemName, _In_opt_ PVOID HandleId, _In_ BOOLEAN GenerateOnClose);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtDeleteObjectAuditAlarm(_In_ PUNICODE_STRING SubsystemName, _In_opt_ PVOID HandleId, _In_ BOOLEAN GenerateOnClose);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtOpenProcessToken(_In_ HANDLE ProcessHandle, _In_ ACCESS_MASK DesiredAccess, _Out_ PHANDLE TokenHandle);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtOpenProcessTokenEx(
        _In_ HANDLE ProcessHandle,
        _In_ ACCESS_MASK DesiredAccess,
        _In_ ULONG HandleAttributes,
        _Out_ PHANDLE TokenHandle);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtDuplicateToken(
        _In_ HANDLE ExistingTokenHandle,
        _In_ ACCESS_MASK DesiredAccess,
        _In_ POBJECT_ATTRIBUTES ObjectAttributes,
        _In_ BOOLEAN EffectiveOnly,
        _In_ TOKEN_TYPE TokenType,
        _Out_ PHANDLE NewTokenHandle);

#define DISABLE_MAX_PRIVILEGE 0x1 // winnt
#define SANDBOX_INERT 0x2         // winnt
#define LUA_TOKEN 0x4
#define WRITE_RESTRICT 0x8

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtFilterToken(
        _In_ HANDLE ExistingTokenHandle,
        _In_ ULONG Flags,
        _In_opt_ PTOKEN_GROUPS SidsToDisable,
        _In_opt_ PTOKEN_PRIVILEGES PrivilegesToDelete,
        _In_opt_ PTOKEN_GROUPS RestrictedSids,
        _Out_ PHANDLE NewTokenHandle);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtImpersonateAnonymousToken(_In_ HANDLE ThreadHandle);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtQueryInformationToken(
        _In_ HANDLE TokenHandle,
        _In_ TOKEN_INFORMATION_CLASS TokenInformationClass,
        _Out_writes_bytes_(TokenInformationLength) PVOID TokenInformation,
        _In_ ULONG TokenInformationLength,
        _Out_ PULONG ReturnLength);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtSetInformationToken(
        _In_ HANDLE TokenHandle,
        _In_ TOKEN_INFORMATION_CLASS TokenInformationClass,
        _In_reads_bytes_(TokenInformationLength) PVOID TokenInformation,
        _In_ ULONG TokenInformationLength);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtOpenThreadToken(
        _In_ HANDLE ThreadHandle,
        _In_ ACCESS_MASK DesiredAccess,
        _In_ BOOLEAN OpenAsSelf,
        _Out_ PHANDLE TokenHandle);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtOpenThreadTokenEx(
        _In_ HANDLE ThreadHandle,
        _In_ ACCESS_MASK DesiredAccess,
        _In_ BOOLEAN OpenAsSelf,
        _In_ ULONG HandleAttributes,
        _Out_ PHANDLE TokenHandle);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtAdjustPrivilegesToken(
        _In_ HANDLE TokenHandle,
        _In_ BOOLEAN DisableAllPrivileges,
        _In_opt_ PTOKEN_PRIVILEGES NewState,
        _In_ ULONG BufferLength,
        _Out_writes_bytes_to_opt_(BufferLength, *ReturnLength) PTOKEN_PRIVILEGES PreviousState,
        _Out_ _When_(PreviousState == NULL, _Out_opt_) PULONG ReturnLength);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtAdjustGroupsToken(
        _In_ HANDLE TokenHandle,
        _In_ BOOLEAN ResetToDefault,
        _In_opt_ PTOKEN_GROUPS NewState,
        _In_opt_ ULONG BufferLength,
        _Out_writes_bytes_to_opt_(BufferLength, *ReturnLength) PTOKEN_GROUPS PreviousState,
        _Out_ PULONG ReturnLength);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtCompareTokens(_In_ HANDLE FirstTokenHandle, _In_ HANDLE SecondTokenHandle, _Out_ PBOOLEAN Equal);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtPrivilegeCheck(_In_ HANDLE ClientToken, _Inout_ PPRIVILEGE_SET RequiredPrivileges, _Out_ PBOOLEAN Result);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtCreateToken(
        _Out_ PHANDLE TokenHandle,
        _In_ ACCESS_MASK DesiredAccess,
        _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
        _In_ TOKEN_TYPE TokenType,
        _In_ PLUID AuthenticationId,
        _In_ PLARGE_INTEGER ExpirationTime,
        _In_ PTOKEN_USER User,
        _In_ PTOKEN_GROUPS Groups,
        _In_ PTOKEN_PRIVILEGES Privileges,
        _In_opt_ PTOKEN_OWNER Owner,
        _In_ PTOKEN_PRIMARY_GROUP PrimaryGroup,
        _In_opt_ PTOKEN_DEFAULT_DACL DefaultDacl,
        _In_ PTOKEN_SOURCE TokenSource);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtCreateTokenEx(
        _Out_ PHANDLE TokenHandle,
        _In_ ACCESS_MASK DesiredAccess,
        _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
        _In_ TOKEN_TYPE TokenType,
        _In_ PLUID AuthenticationId,
        _In_ PLARGE_INTEGER ExpirationTime,
        _In_ PTOKEN_USER User,
        _In_ PTOKEN_GROUPS Groups,
        _In_ PTOKEN_PRIVILEGES Privileges,
        _In_opt_ PVOID UserAttributes,   // points to TOKEN_SECURITY_ATTRIBUTES_INFORMATION
        _In_opt_ PVOID DeviceAttributes, // points to PTOKEN_SECURITY_ATTRIBUTES_INFORMATION
        _In_opt_ PTOKEN_GROUPS DeviceGroups,
        _In_opt_ PTOKEN_MANDATORY_POLICY TokenMandatoryPolicy,
        _In_opt_ PTOKEN_OWNER Owner,
        _In_ PTOKEN_PRIMARY_GROUP PrimaryGroup,
        _In_opt_ PTOKEN_DEFAULT_DACL DefaultDacl,
        _In_ PTOKEN_SOURCE TokenSource);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtCreateLowBoxToken(
        _Out_ PHANDLE TokenHandle,
        _In_ HANDLE ExistingTokenHandle,
        _In_ ACCESS_MASK DesiredAccess,
        _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
        _In_ PSID PackageSid,
        _In_ ULONG CapabilityCount,
        _In_reads_opt_(CapabilityCount) PSID_AND_ATTRIBUTES Capabilities,
        _In_ ULONG HandleCount,
        _In_reads_opt_(HandleCount) HANDLE* Handles);

    /************************************************************************************
     *
     * Registry API.
     *
     ************************************************************************************/

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtCreateKey(
        _Out_ PHANDLE KeyHandle,
        _In_ ACCESS_MASK DesiredAccess,
        _In_ POBJECT_ATTRIBUTES ObjectAttributes,
        _Reserved_ ULONG TitleIndex,
        _In_opt_ PUNICODE_STRING Class,
        _In_ ULONG CreateOptions,
        _Out_opt_ PULONG Disposition);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtCreateKeyTransacted(
        _Out_ PHANDLE KeyHandle,
        _In_ ACCESS_MASK DesiredAccess,
        _In_ POBJECT_ATTRIBUTES ObjectAttributes,
        _Reserved_ ULONG TitleIndex,
        _In_opt_ PUNICODE_STRING Class,
        _In_ ULONG CreateOptions,
        _In_ HANDLE TransactionHandle,
        _Out_opt_ PULONG Disposition);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtOpenKey(_Out_ PHANDLE KeyHandle, _In_ ACCESS_MASK DesiredAccess, _In_ POBJECT_ATTRIBUTES ObjectAttributes);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtOpenKeyEx(
        _Out_ PHANDLE KeyHandle,
        _In_ ACCESS_MASK DesiredAccess,
        _In_ POBJECT_ATTRIBUTES ObjectAttributes,
        _In_ ULONG OpenOptions);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtOpenKeyTransacted(
        _Out_ PHANDLE KeyHandle,
        _In_ ACCESS_MASK DesiredAccess,
        _In_ POBJECT_ATTRIBUTES ObjectAttributes,
        _In_ HANDLE TransactionHandle);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtOpenKeyTransactedEx(
        _Out_ PHANDLE KeyHandle,
        _In_ ACCESS_MASK DesiredAccess,
        _In_ POBJECT_ATTRIBUTES ObjectAttributes,
        _In_ ULONG OpenOptions,
        _In_ HANDLE TransactionHandle);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtQueryKey(
        _In_ HANDLE KeyHandle,
        _In_ KEY_INFORMATION_CLASS KeyInformationClass,
        _Out_writes_bytes_opt_(Length) PVOID KeyInformation,
        _In_ ULONG Length,
        _Out_ PULONG ResultLength);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtEnumerateKey(
        _In_ HANDLE KeyHandle,
        _In_ ULONG Index,
        _In_ KEY_INFORMATION_CLASS KeyInformationClass,
        _Out_writes_bytes_opt_(Length) PVOID KeyInformation,
        _In_ ULONG Length,
        _Out_ PULONG ResultLength);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtEnumerateValueKey(
        _In_ HANDLE KeyHandle,
        _In_ ULONG Index,
        _In_ KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
        _Out_writes_bytes_opt_(Length) PVOID KeyValueInformation,
        _In_ ULONG Length,
        _Out_ PULONG ResultLength);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtQueryValueKey(
        _In_ HANDLE KeyHandle,
        _In_ PUNICODE_STRING ValueName,
        _In_ KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
        _Out_writes_bytes_opt_(Length) PVOID KeyValueInformation,
        _In_ ULONG Length,
        _Out_ PULONG ResultLength);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtQueryMultipleValueKey(
        _In_ HANDLE KeyHandle,
        _Inout_updates_(EntryCount) PKEY_VALUE_ENTRY ValueEntries,
        _In_ ULONG EntryCount,
        _Out_writes_bytes_(*BufferLength) PVOID ValueBuffer,
        _Inout_ PULONG BufferLength,
        _Out_opt_ PULONG RequiredBufferLength);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtSetValueKey(
        _In_ HANDLE KeyHandle,
        _In_ PUNICODE_STRING ValueName,
        _In_opt_ ULONG TitleIndex,
        _In_ ULONG Type,
        _In_reads_bytes_opt_(DataSize) PVOID Data,
        _In_ ULONG DataSize);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtDeleteKey(_In_ HANDLE KeyHandle);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtDeleteValueKey(_In_ HANDLE KeyHandle, _In_ PUNICODE_STRING ValueName);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtRenameKey(_In_ HANDLE KeyHandle, _In_ PUNICODE_STRING NewName);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtSetInformationKey(
        _In_ HANDLE KeyHandle,
        _In_ KEY_SET_INFORMATION_CLASS KeySetInformationClass,
        _In_reads_bytes_(KeySetInformationLength) PVOID KeySetInformation,
        _In_ ULONG KeySetInformationLength);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtFlushKey(_In_ HANDLE KeyHandle);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtCompressKey(_In_ HANDLE Key);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtLoadKey(_In_ POBJECT_ATTRIBUTES TargetKey, _In_ POBJECT_ATTRIBUTES SourceFile);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtLoadKey2(_In_ POBJECT_ATTRIBUTES TargetKey, _In_ POBJECT_ATTRIBUTES SourceFile, _In_ ULONG Flags);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtLoadKeyEx(
        _In_ POBJECT_ATTRIBUTES TargetKey,
        _In_ POBJECT_ATTRIBUTES SourceFile,
        _In_ ULONG Flags,
        _In_opt_ HANDLE TrustClassKey,
        _In_opt_ HANDLE Event,
        _In_opt_ ACCESS_MASK DesiredAccess,
        _Out_opt_ PHANDLE RootHandle,
        _Out_opt_ PIO_STATUS_BLOCK IoStatus);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtSaveKey(_In_ HANDLE KeyHandle, _In_ HANDLE FileHandle);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtSaveKeyEx(_In_ HANDLE KeyHandle, _In_ HANDLE FileHandle, _In_ ULONG Format);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtUnloadKey(_In_ POBJECT_ATTRIBUTES TargetKey);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtUnloadKey2(_In_ POBJECT_ATTRIBUTES TargetKey, _In_ ULONG Flags);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtUnloadKeyEx(_In_ POBJECT_ATTRIBUTES TargetKey, _In_opt_ HANDLE Event);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtNotifyChangeKey(
        _In_ HANDLE KeyHandle,
        _In_opt_ HANDLE Event,
        _In_opt_ PIO_APC_ROUTINE ApcRoutine,
        _In_opt_ PVOID ApcContext,
        _Out_ PIO_STATUS_BLOCK IoStatusBlock,
        _In_ ULONG CompletionFilter,
        _In_ BOOLEAN WatchTree,
        _Out_writes_bytes_opt_(BufferSize) PVOID Buffer,
        _In_ ULONG BufferSize,
        _In_ BOOLEAN Asynchronous);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtLockRegistryKey(_In_ HANDLE KeyHandle);

    /************************************************************************************
     *
     * Job API.
     *
     ************************************************************************************/

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtAssignProcessToJobObject(_In_ HANDLE JobHandle, _In_ HANDLE ProcessHandle);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtCreateJobObject(
        _Out_ PHANDLE JobHandle,
        _In_ ACCESS_MASK DesiredAccess,
        _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtCreateJobSet(_In_ ULONG NumJob, _In_reads_(NumJob) PJOB_SET_ARRAY UserJobSet, _In_ ULONG Flags);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtIsProcessInJob(_In_ HANDLE ProcessHandle, _In_opt_ HANDLE JobHandle);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtOpenJobObject(_Out_ PHANDLE JobHandle, _In_ ACCESS_MASK DesiredAccess, _In_ POBJECT_ATTRIBUTES ObjectAttributes);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtQueryInformationJobObject(
        _In_opt_ HANDLE JobHandle,
        _In_ JOBOBJECTINFOCLASS JobObjectInformationClass,
        _Out_writes_bytes_(JobObjectInformationLength) PVOID JobObjectInformation,
        _In_ ULONG JobObjectInformationLength,
        _Out_opt_ PULONG ReturnLength);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtSetInformationJobObject(
        _In_ HANDLE JobHandle,
        _In_ JOBOBJECTINFOCLASS JobObjectInformationClass,
        _In_reads_bytes_(JobObjectInformationLength) PVOID JobObjectInformation,
        _In_ ULONG JobObjectInformationLength);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtTerminateJobObject(_In_ HANDLE JobHandle, _In_ NTSTATUS ExitStatus);

    /************************************************************************************
     *
     * Session API.
     *
     ************************************************************************************/

    // taken from ph2

    typedef enum _IO_SESSION_EVENT
    {
        IoSessionEventIgnore,
        IoSessionEventCreated,
        IoSessionEventTerminated,
        IoSessionEventConnected,
        IoSessionEventDisconnected,
        IoSessionEventLogon,
        IoSessionEventLogoff,
        IoSessionEventMax
    } IO_SESSION_EVENT;

    typedef enum _IO_SESSION_STATE
    {
        IoSessionStateCreated,
        IoSessionStateInitialized,
        IoSessionStateConnected,
        IoSessionStateDisconnected,
        IoSessionStateDisconnectedLoggedOn,
        IoSessionStateLoggedOn,
        IoSessionStateLoggedOff,
        IoSessionStateTerminated,
        IoSessionStateMax
    } IO_SESSION_STATE;

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtOpenSession(
        _Out_ PHANDLE SessionHandle,
        _In_ ACCESS_MASK DesiredAccess,
        _In_ POBJECT_ATTRIBUTES ObjectAttributes);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtNotifyChangeSession(
        _In_ HANDLE SessionHandle,
        _In_ ULONG ChangeSequenceNumber,
        _In_ PLARGE_INTEGER ChangeTimeStamp,
        _In_ IO_SESSION_EVENT Event,
        _In_ IO_SESSION_STATE NewState,
        _In_ IO_SESSION_STATE PreviousState,
        _In_reads_bytes_opt_(PayloadSize) PVOID Payload,
        _In_ ULONG PayloadSize);

    /************************************************************************************
     *
     * IO Completion API.
     *
     ************************************************************************************/

    typedef enum _IO_COMPLETION_INFORMATION_CLASS
    {
        IoCompletionBasicInformation
    } IO_COMPLETION_INFORMATION_CLASS;

    typedef struct _IO_COMPLETION_BASIC_INFORMATION
    {
        LONG Depth;
    } IO_COMPLETION_BASIC_INFORMATION, *PIO_COMPLETION_BASIC_INFORMATION;

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtCreateIoCompletion(
        _Out_ PHANDLE IoCompletionHandle,
        _In_ ACCESS_MASK DesiredAccess,
        _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
        _In_opt_ ULONG Count);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtOpenIoCompletion(
        _Out_ PHANDLE IoCompletionHandle,
        _In_ ACCESS_MASK DesiredAccess,
        _In_ POBJECT_ATTRIBUTES ObjectAttributes);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtQueryIoCompletion(
        _In_ HANDLE IoCompletionHandle,
        _In_ IO_COMPLETION_INFORMATION_CLASS IoCompletionInformationClass,
        _Out_writes_bytes_(IoCompletionInformationLength) PVOID IoCompletionInformation,
        _In_ ULONG IoCompletionInformationLength,
        _Out_opt_ PULONG ReturnLength);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtSetIoCompletion(
        _In_ HANDLE IoCompletionHandle,
        _In_opt_ PVOID KeyContext,
        _In_opt_ PVOID ApcContext,
        _In_ NTSTATUS IoStatus,
        _In_ ULONG_PTR IoStatusInformation);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtSetIoCompletionEx(
        _In_ HANDLE IoCompletionHandle,
        _In_ HANDLE IoCompletionPacketHandle,
        _In_opt_ PVOID KeyContext,
        _In_opt_ PVOID ApcContext,
        _In_ NTSTATUS IoStatus,
        _In_ ULONG_PTR IoStatusInformation);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtRemoveIoCompletion(
        _In_ HANDLE IoCompletionHandle,
        _Out_ PVOID* KeyContext,
        _Out_ PVOID* ApcContext,
        _Out_ PIO_STATUS_BLOCK IoStatusBlock,
        _In_opt_ PLARGE_INTEGER Timeout);

    /************************************************************************************
     *
     * Transactions API.
     *
     ************************************************************************************/

    // TmTx
    NTSYSAPI
    NTSTATUS
    NTAPI
    NtCreateTransaction(
        _Out_ PHANDLE TransactionHandle,
        _In_ ACCESS_MASK DesiredAccess,
        _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
        _In_opt_ LPGUID Uow,
        _In_opt_ HANDLE TmHandle,
        _In_opt_ ULONG CreateOptions,
        _In_opt_ ULONG IsolationLevel,
        _In_opt_ ULONG IsolationFlags,
        _In_opt_ PLARGE_INTEGER Timeout,
        _In_opt_ PUNICODE_STRING Description);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtOpenTransaction(
        _Out_ PHANDLE TransactionHandle,
        _In_ ACCESS_MASK DesiredAccess,
        _In_ POBJECT_ATTRIBUTES ObjectAttributes,
        _In_ LPGUID Uow,
        _In_opt_ HANDLE TmHandle);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtRollbackTransaction(_In_ HANDLE TransactionHandle, _In_ BOOLEAN Wait);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtCommitTransaction(_In_ HANDLE TransactionHandle, _In_ BOOLEAN Wait);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtFreezeTransactions(_In_ PLARGE_INTEGER FreezeTimeout, _In_ PLARGE_INTEGER ThawTimeout);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtThawTransactions(VOID);

    // TmRm
    NTSYSAPI
    NTSTATUS
    NTAPI
    NtCreateResourceManager(
        _Out_ PHANDLE ResourceManagerHandle,
        _In_ ACCESS_MASK DesiredAccess,
        _In_ HANDLE TmHandle,
        _In_opt_ LPGUID ResourceManagerGuid,
        _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
        _In_opt_ ULONG CreateOptions,
        _In_opt_ PUNICODE_STRING Description);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtOpenResourceManager(
        _Out_ PHANDLE ResourceManagerHandle,
        _In_ ACCESS_MASK DesiredAccess,
        _In_ HANDLE TmHandle,
        _In_opt_ LPGUID ResourceManagerGuid,
        _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes);

    // TmEn
    NTSYSAPI
    NTSTATUS
    NTAPI
    NtCreateEnlistment(
        _Out_ PHANDLE EnlistmentHandle,
        _In_ ACCESS_MASK DesiredAccess,
        _In_ HANDLE ResourceManagerHandle,
        _In_ HANDLE TransactionHandle,
        _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
        _In_opt_ ULONG CreateOptions,
        _In_ NOTIFICATION_MASK NotificationMask,
        _In_opt_ PVOID EnlistmentKey);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtOpenEnlistment(
        _Out_ PHANDLE EnlistmentHandle,
        _In_ ACCESS_MASK DesiredAccess,
        _In_ HANDLE ResourceManagerHandle,
        _In_ LPGUID EnlistmentGuid,
        _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes);

    // TmTm
    NTSYSAPI
    NTSTATUS
    NTAPI
    NtCreateTransactionManager(
        _Out_ PHANDLE TmHandle,
        _In_ ACCESS_MASK DesiredAccess,
        _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
        _In_opt_ PUNICODE_STRING LogFileName,
        _In_opt_ ULONG CreateOptions,
        _In_opt_ ULONG CommitStrength);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtOpenTransactionManager(
        _Out_ PHANDLE TmHandle,
        _In_ ACCESS_MASK DesiredAccess,
        _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
        _In_opt_ PUNICODE_STRING LogFileName,
        _In_opt_ LPGUID TmIdentity,
        _In_opt_ ULONG OpenOptions);

    /************************************************************************************
     *
     * Process and Thread API.
     *
     ************************************************************************************/

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtCreateUserProcess(
        _Out_ PHANDLE ProcessHandle,
        _Out_ PHANDLE ThreadHandle,
        _In_ ACCESS_MASK ProcessDesiredAccess,
        _In_ ACCESS_MASK ThreadDesiredAccess,
        _In_opt_ POBJECT_ATTRIBUTES ProcessObjectAttributes,
        _In_opt_ POBJECT_ATTRIBUTES ThreadObjectAttributes,
        _In_ ULONG ProcessFlags,
        _In_ ULONG ThreadFlags,
        _In_opt_ PVOID ProcessParameters,
        _Inout_ PPS_CREATE_INFO CreateInfo,
        _In_opt_ PPS_ATTRIBUTE_LIST AttributeList);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtOpenProcess(
        _Out_ PHANDLE ProcessHandle,
        _In_ ACCESS_MASK DesiredAccess,
        _In_ POBJECT_ATTRIBUTES ObjectAttributes,
        _In_opt_ PCLIENT_ID ClientId);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtTerminateProcess(_In_opt_ HANDLE ProcessHandle, _In_ NTSTATUS ExitStatus);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtSuspendProcess(_In_ HANDLE ProcessHandle);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtResumeProcess(_In_ HANDLE ProcessHandle);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtSuspendThread(_In_ HANDLE ThreadHandle, _Out_opt_ PULONG PreviousSuspendCount);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtResumeThread(_In_ HANDLE ThreadHandle, _Out_opt_ PULONG PreviousSuspendCount);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtOpenThread(
        _Out_ PHANDLE ThreadHandle,
        _In_ ACCESS_MASK DesiredAccess,
        _In_ POBJECT_ATTRIBUTES ObjectAttributes,
        _In_opt_ PCLIENT_ID ClientId);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtTerminateThread(_In_opt_ HANDLE ThreadHandle, _In_ NTSTATUS ExitStatus);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtImpersonateThread(
        _In_ HANDLE ServerThreadHandle,
        _In_ HANDLE ClientThreadHandle,
        _In_ PSECURITY_QUALITY_OF_SERVICE SecurityQos);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtSetContextThread(_In_ HANDLE ThreadHandle, _In_ PCONTEXT ThreadContext);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtGetContextThread(_In_ HANDLE ThreadHandle, _Inout_ PCONTEXT ThreadContext);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtQueryInformationThread(
        _In_ HANDLE ThreadHandle,
        _In_ THREADINFOCLASS ThreadInformationClass,
        _Out_writes_bytes_(ThreadInformationLength) PVOID ThreadInformation,
        _In_ ULONG ThreadInformationLength,
        _Out_opt_ PULONG ReturnLength);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtSetInformationThread(
        _In_ HANDLE ThreadHandle,
        _In_ THREADINFOCLASS ThreadInformationClass,
        _In_reads_bytes_(ThreadInformationLength) PVOID ThreadInformation,
        _In_ ULONG ThreadInformationLength);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtQueryInformationProcess(
        _In_ HANDLE ProcessHandle,
        _In_ PROCESSINFOCLASS ProcessInformationClass,
        _Out_writes_bytes_(ProcessInformationLength) PVOID ProcessInformation,
        _In_ ULONG ProcessInformationLength,
        _Out_opt_ PULONG ReturnLength);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtSetInformationProcess(
        _In_ HANDLE ProcessHandle,
        _In_ PROCESSINFOCLASS ProcessInformationClass,
        _In_reads_bytes_(ProcessInformationLength) PVOID ProcessInformation,
        _In_ ULONG ProcessInformationLength);

    typedef VOID (
        *PPS_APC_ROUTINE)(_In_opt_ PVOID ApcArgument1, _In_opt_ PVOID ApcArgument2, _In_opt_ PVOID ApcArgument3);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtQueueApcThread(
        _In_ HANDLE ThreadHandle,
        _In_ PPS_APC_ROUTINE ApcRoutine,
        _In_opt_ PVOID ApcArgument1,
        _In_opt_ PVOID ApcArgument2,
        _In_opt_ PVOID ApcArgument3);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtQueueApcThreadEx(
        _In_ HANDLE ThreadHandle,
        _In_opt_ HANDLE UserApcReserveHandle,
        _In_ PPS_APC_ROUTINE ApcRoutine,
        _In_opt_ PVOID ApcArgument1,
        _In_opt_ PVOID ApcArgument2,
        _In_opt_ PVOID ApcArgument3);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtYieldExecution(VOID);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtTestAlert(VOID);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtCreateProcessEx(
        _Out_ PHANDLE ProcessHandle,
        _In_ ACCESS_MASK DesiredAccess,
        _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
        _In_ HANDLE ParentProcess,
        _In_ ULONG Flags,
        _In_opt_ HANDLE SectionHandle,
        _In_opt_ HANDLE DebugPort,
        _In_opt_ HANDLE ExceptionPort,
        _In_ BOOLEAN InJob);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtCreateThreadEx(
        _Out_ PHANDLE ThreadHandle,
        _In_ ACCESS_MASK DesiredAccess,
        _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
        _In_ HANDLE ProcessHandle,
        _In_ PVOID StartRoutine,
        _In_opt_ PVOID Argument,
        _In_ ULONG CreateFlags, // THREAD_CREATE_FLAGS_*
        _In_opt_ ULONG_PTR ZeroBits,
        _In_opt_ SIZE_T StackSize,
        _In_opt_ SIZE_T MaximumStackSize,
        _In_opt_ PPS_ATTRIBUTE_LIST AttributeList);

    NTSYSAPI
    ULONG
    NTAPI
    NtGetCurrentProcessorNumber(VOID);

    /************************************************************************************
     *
     * License API.
     *
     ************************************************************************************/

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtQueryLicenseValue(
        _In_ PUNICODE_STRING ValueName,
        _Out_opt_ PULONG Type,
        _Out_writes_bytes_to_opt_(DataSize, *ResultDataSize) PVOID Data,
        _In_ ULONG DataSize,
        _Out_ PULONG ResultDataSize);

    /************************************************************************************
     *
     * Virtual Memory API.
     *
     ************************************************************************************/

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtAllocateVirtualMemory(
        _In_ HANDLE ProcessHandle,
        _Inout_ _At_(
            *BaseAddress,
            _Readable_bytes_(*RegionSize) _Writable_bytes_(*RegionSize) _Post_readable_byte_size_(*RegionSize))
            PVOID* BaseAddress,
        _In_ ULONG_PTR ZeroBits,
        _Inout_ PSIZE_T RegionSize,
        _In_ ULONG AllocationType,
        _In_ ULONG Protect);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtFreeVirtualMemory(
        _In_ HANDLE ProcessHandle,
        _Inout_ PVOID* BaseAddress,
        _Inout_ PSIZE_T RegionSize,
        _In_ ULONG FreeType);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtQueryVirtualMemory(
        _In_ HANDLE ProcessHandle,
        _In_opt_ PVOID BaseAddress,
        _In_ MEMORY_INFORMATION_CLASS MemoryInformationClass,
        _Out_writes_bytes_(MemoryInformationLength) PVOID MemoryInformation,
        _In_ SIZE_T MemoryInformationLength,
        _Out_opt_ PSIZE_T ReturnLength);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtSetInformationVirtualMemory(
        _In_ HANDLE ProcessHandle,
        _In_ VIRTUAL_MEMORY_INFORMATION_CLASS VmInformationClass,
        _In_ ULONG_PTR NumberOfEntries,
        _In_reads_(NumberOfEntries) PMEMORY_RANGE_ENTRY VirtualAddresses,
        _In_reads_bytes_(VmInformationLength) PVOID VmInformation,
        _In_ ULONG VmInformationLength);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtReadVirtualMemory(
        _In_ HANDLE ProcessHandle,
        _In_opt_ PVOID BaseAddress,
        _Out_writes_bytes_(BufferSize) PVOID Buffer,
        _In_ SIZE_T BufferSize,
        _Out_opt_ PSIZE_T NumberOfBytesRead);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtWriteVirtualMemory(
        _In_ HANDLE ProcessHandle,
        _In_opt_ PVOID BaseAddress,
        _In_reads_bytes_(BufferSize) PVOID Buffer,
        _In_ SIZE_T BufferSize,
        _Out_opt_ PSIZE_T NumberOfBytesWritten);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtProtectVirtualMemory(
        _In_ HANDLE ProcessHandle,
        _Inout_ PVOID* BaseAddress,
        _Inout_ PSIZE_T RegionSize,
        _In_ ULONG NewProtect,
        _Out_ PULONG OldProtect);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtLockVirtualMemory(
        _In_ HANDLE ProcessHandle,
        _Inout_ PVOID* BaseAddress,
        _Inout_ PSIZE_T RegionSize,
        _In_ ULONG MapType);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtUnlockVirtualMemory(
        _In_ HANDLE ProcessHandle,
        _Inout_ PVOID* BaseAddress,
        _Inout_ PSIZE_T RegionSize,
        _In_ ULONG MapType);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtFlushInstructionCache(_In_ HANDLE ProcessHandle, _In_opt_ PVOID BaseAddress, _In_ SIZE_T Length);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtCreatePagingFile(
        _In_ PUNICODE_STRING PageFileName,
        _In_ PLARGE_INTEGER MinimumSize,
        _In_ PLARGE_INTEGER MaximumSize,
        _In_ ULONG Priority);

    /************************************************************************************
     *
     * Port API.
     *
     ************************************************************************************/

    typedef struct _PORT_VIEW
    {
        ULONG Length;
        HANDLE SectionHandle;
        ULONG SectionOffset;
        SIZE_T ViewSize;
        PVOID ViewBase;
        PVOID ViewRemoteBase;
    } PORT_VIEW, *PPORT_VIEW;

    typedef struct _REMOTE_PORT_VIEW
    {
        ULONG Length;
        SIZE_T ViewSize;
        PVOID ViewBase;
    } REMOTE_PORT_VIEW, *PREMOTE_PORT_VIEW;

    typedef struct _PORT_MESSAGE
    {
        union
        {
            struct
            {
                CSHORT DataLength;
                CSHORT TotalLength;
            } s1;
            ULONG Length;
        } u1;
        union
        {
            struct
            {
                CSHORT Type;
                CSHORT DataInfoOffset;
            } s2;
            ULONG ZeroInit;
        } u2;
        union
        {
            CLIENT_ID ClientId;
            double DoNotUseThisField; // Force quadword alignment
        } u3;
        ULONG MessageId;
        union
        {
            ULONG ClientViewSize; // Only valid on LPC_CONNECTION_REQUEST message
            ULONG CallbackId;     // Only valid on LPC_REQUEST message
        } u4;
        UCHAR Reserved[8];
    } PORT_MESSAGE, *PPORT_MESSAGE;

    typedef struct _PORT_DATA_ENTRY
    {
        PVOID Base;
        ULONG Size;
    } PORT_DATA_ENTRY, *PPORT_DATA_ENTRY;

    typedef struct _PORT_DATA_INFORMATION
    {
        ULONG CountDataEntries;
        PORT_DATA_ENTRY DataEntries[1];
    } PORT_DATA_INFORMATION, *PPORT_DATA_INFORMATION;

#define LPC_REQUEST 1
#define LPC_REPLY 2
#define LPC_DATAGRAM 3
#define LPC_LOST_REPLY 4
#define LPC_PORT_CLOSED 5
#define LPC_CLIENT_DIED 6
#define LPC_EXCEPTION 7
#define LPC_DEBUG_EVENT 8
#define LPC_ERROR_EVENT 9
#define LPC_CONNECTION_REQUEST 10

#define PORT_VALID_OBJECT_ATTRIBUTES (OBJ_CASE_INSENSITIVE)
#define PORT_MAXIMUM_MESSAGE_LENGTH 256

    typedef struct _LPC_CLIENT_DIED_MSG
    {
        PORT_MESSAGE PortMsg;
        LARGE_INTEGER CreateTime;
    } LPC_CLIENT_DIED_MSG, *PLPC_CLIENT_DIED_MSG;

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtCreatePort(
        _Out_ PHANDLE PortHandle,
        _In_ POBJECT_ATTRIBUTES ObjectAttributes,
        _In_ ULONG MaxConnectionInfoLength,
        _In_ ULONG MaxMessageLength,
        _In_ ULONG MaxPoolUsage);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtCompleteConnectPort(_In_ HANDLE PortHandle);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtListenPort(_In_ HANDLE PortHandle, _Out_ PPORT_MESSAGE ConnectionRequest);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtReplyPort(_In_ HANDLE PortHandle, _In_ PPORT_MESSAGE ReplyMessage);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtReplyWaitReplyPort(_In_ HANDLE PortHandle, _Inout_ PPORT_MESSAGE ReplyMessage);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtRequestPort(_In_ HANDLE PortHandle, _In_ PPORT_MESSAGE RequestMessage);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtRequestWaitReplyPort(_In_ HANDLE PortHandle, _In_ PPORT_MESSAGE RequestMessage, _Out_ PPORT_MESSAGE ReplyMessage);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtClosePort(_In_ HANDLE PortHandle);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtReplyWaitReceivePort(
        _In_ HANDLE PortHandle,
        _Out_opt_ PVOID* PortContext,
        _In_opt_ PPORT_MESSAGE ReplyMessage,
        _Out_ PPORT_MESSAGE ReceiveMessage);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtWriteRequestData(
        _In_ HANDLE PortHandle,
        _In_ PPORT_MESSAGE Message,
        _In_ ULONG DataEntryIndex,
        _In_ PVOID Buffer,
        _In_ ULONG BufferSize,
        _Out_opt_ PULONG NumberOfBytesWritten);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtReadRequestData(
        _In_ HANDLE PortHandle,
        _In_ PPORT_MESSAGE Message,
        _In_ ULONG DataEntryIndex,
        _Out_ PVOID Buffer,
        _In_ ULONG BufferSize,
        _Out_opt_ PULONG NumberOfBytesRead);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtConnectPort(
        _Out_ PHANDLE PortHandle,
        _In_ PUNICODE_STRING PortName,
        _In_ PSECURITY_QUALITY_OF_SERVICE SecurityQos,
        _Inout_opt_ PPORT_VIEW ClientView,
        _Out_opt_ PREMOTE_PORT_VIEW ServerView,
        _Out_opt_ PULONG MaxMessageLength,
        _Inout_opt_ PVOID ConnectionInformation,
        _Inout_opt_ PULONG ConnectionInformationLength);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtAcceptConnectPort(
        _Out_ PHANDLE PortHandle,
        _In_opt_ PVOID PortContext,
        _In_ PPORT_MESSAGE ConnectionRequest,
        _In_ BOOLEAN AcceptConnection,
        _Inout_opt_ PPORT_VIEW ServerView,
        _Out_opt_ PREMOTE_PORT_VIEW ClientView);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtSecureConnectPort(
        _Out_ PHANDLE PortHandle,
        _In_ PUNICODE_STRING PortName,
        _In_ PSECURITY_QUALITY_OF_SERVICE SecurityQos,
        _Inout_opt_ PPORT_VIEW ClientView,
        _In_opt_ PSID RequiredServerSid,
        _Inout_opt_ PREMOTE_PORT_VIEW ServerView,
        _Out_opt_ PULONG MaxMessageLength,
        _Inout_opt_ PVOID ConnectionInformation,
        _Inout_opt_ PULONG ConnectionInformationLength);

    /************************************************************************************
     *
     * Boot Management API.
     *
     ************************************************************************************/

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtEnumerateBootEntries(_Out_writes_bytes_opt_(*BufferLength) PVOID Buffer, _Inout_ PULONG BufferLength);

    /************************************************************************************
     *
     * Reserve Objects API.
     *
     ************************************************************************************/

    typedef enum _MEMORY_RESERVE_TYPE
    {
        MemoryReserveUserApc,
        MemoryReserveIoCompletion,
        MemoryReserveTypeMax
    } MEMORY_RESERVE_TYPE;

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtAllocateReserveObject(
        _Out_ PHANDLE MemoryReserveHandle,
        _In_ POBJECT_ATTRIBUTES ObjectAttributes,
        _In_ MEMORY_RESERVE_TYPE Type);

    /************************************************************************************
     *
     * Debug API.
     *
     ************************************************************************************/

    //
    // Define the debug object thats used to attatch to processes that are being debugged.
    //
#define DEBUG_OBJECT_DELETE_PENDING (0x1) // Debug object is delete pending.
#define DEBUG_OBJECT_KILL_ON_CLOSE (0x2)  // Kill all debugged processes on close

    typedef struct _DEBUG_OBJECT
    {
        //
        // Event thats set when the EventList is populated.
        //
        KEVENT EventsPresent;
        //
        // Mutex to protect the structure
        //
        FAST_MUTEX Mutex;
        //
        // Queue of events waiting for debugger intervention
        //
        LIST_ENTRY EventList;
        //
        // Flags for the object
        //
        ULONG Flags;
    } DEBUG_OBJECT, *PDEBUG_OBJECT;

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtCreateDebugObject(
        _Out_ PHANDLE DebugObjectHandle,
        _In_ ACCESS_MASK DesiredAccess,
        _In_ POBJECT_ATTRIBUTES ObjectAttributes,
        _In_ ULONG Flags);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtDebugActiveProcess(_In_ HANDLE ProcessHandle, _In_ HANDLE DebugObjectHandle);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtRemoveProcessDebug(_In_ HANDLE ProcessHandle, _In_ HANDLE DebugObjectHandle);

    /************************************************************************************
     *
     * Profile API.
     *
     ************************************************************************************/

    typedef enum _KPROFILE_SOURCE
    {
        ProfileTime,
        ProfileAlignmentFixup,
        ProfileTotalIssues,
        ProfilePipelineDry,
        ProfileLoadInstructions,
        ProfilePipelineFrozen,
        ProfileBranchInstructions,
        ProfileTotalNonissues,
        ProfileDcacheMisses,
        ProfileIcacheMisses,
        ProfileCacheMisses,
        ProfileBranchMispredictions,
        ProfileStoreInstructions,
        ProfileFpInstructions,
        ProfileIntegerInstructions,
        Profile2Issue,
        Profile3Issue,
        Profile4Issue,
        ProfileSpecialInstructions,
        ProfileTotalCycles,
        ProfileIcacheIssues,
        ProfileDcacheAccesses,
        ProfileMemoryBarrierCycles,
        ProfileLoadLinkedIssues,
        ProfileMaximum
    } KPROFILE_SOURCE;

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtCreateProfile(
        _Out_ PHANDLE ProfileHandle,
        _In_opt_ HANDLE Process,
        _In_ PVOID ProfileBase,
        _In_ SIZE_T ProfileSize,
        _In_ ULONG BucketSize,
        _In_reads_bytes_(BufferSize) PULONG Buffer,
        _In_ ULONG BufferSize,
        _In_ KPROFILE_SOURCE ProfileSource,
        _In_ KAFFINITY Affinity);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtStartProfile(_In_ HANDLE ProfileHandle);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtStopProfile(_In_ HANDLE ProfileHandle);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtQueryIntervalProfile(_In_ KPROFILE_SOURCE ProfileSource, _Out_ PULONG Interval);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtSetIntervalProfile(_In_ ULONG Interval, _In_ KPROFILE_SOURCE Source);

    /************************************************************************************
     *
     * Worker Factory API.
     *
     ************************************************************************************/

    typedef enum _WORKERFACTORYINFOCLASS
    {
        WorkerFactoryTimeout,
        WorkerFactoryRetryTimeout,
        WorkerFactoryIdleTimeout,
        WorkerFactoryBindingCount,
        WorkerFactoryThreadMinimum,
        WorkerFactoryThreadMaximum,
        WorkerFactoryPaused,
        WorkerFactoryBasicInformation,
        WorkerFactoryAdjustThreadGoal,
        WorkerFactoryCallbackType,
        WorkerFactoryStackInformation,
        WorkerFactoryThreadBasePriority,
        WorkerFactoryTimeoutWaiters,
        WorkerFactoryFlags,
        WorkerFactoryThreadSoftMaximum,
        MaxWorkerFactoryInfoClass
    } WORKERFACTORYINFOCLASS, *PWORKERFACTORYINFOCLASS;

    typedef struct _WORKER_FACTORY_BASIC_INFORMATION
    {
        LARGE_INTEGER Timeout;
        LARGE_INTEGER RetryTimeout;
        LARGE_INTEGER IdleTimeout;
        BOOLEAN Paused;
        BOOLEAN TimerSet;
        BOOLEAN QueuedToExWorker;
        BOOLEAN MayCreate;
        BOOLEAN CreateInProgress;
        BOOLEAN InsertedIntoQueue;
        BOOLEAN Shutdown;
        ULONG BindingCount;
        ULONG ThreadMinimum;
        ULONG ThreadMaximum;
        ULONG PendingWorkerCount;
        ULONG WaitingWorkerCount;
        ULONG TotalWorkerCount;
        ULONG ReleaseCount;
        LONGLONG InfiniteWaitGoal;
        PVOID StartRoutine;
        PVOID StartParameter;
        HANDLE ProcessId;
        SIZE_T StackReserve;
        SIZE_T StackCommit;
        NTSTATUS LastThreadCreationStatus;
    } WORKER_FACTORY_BASIC_INFORMATION, *PWORKER_FACTORY_BASIC_INFORMATION;

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtCreateWorkerFactory(
        _Out_ PHANDLE WorkerFactoryHandleReturn,
        _In_ ACCESS_MASK DesiredAccess,
        _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
        _In_ HANDLE CompletionPortHandle,
        _In_ HANDLE WorkerProcessHandle,
        _In_ PVOID StartRoutine,
        _In_opt_ PVOID StartParameter,
        _In_opt_ ULONG MaxThreadCount,
        _In_opt_ SIZE_T StackReserve,
        _In_opt_ SIZE_T StackCommit);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtQueryInformationWorkerFactory(
        _In_ HANDLE WorkerFactoryHandle,
        _In_ WORKERFACTORYINFOCLASS WorkerFactoryInformationClass,
        _Out_writes_bytes_(WorkerFactoryInformationLength) PVOID WorkerFactoryInformation,
        _In_ ULONG WorkerFactoryInformationLength,
        _Out_opt_ PULONG ReturnLength);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtShutdownWorkerFactory(_In_ HANDLE WorkerFactoryHandle, _Inout_ volatile LONG* PendingWorkerCount);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtReleaseWorkerFactoryWorker(_In_ HANDLE WorkerFactoryHandle);

    /************************************************************************************
     *
     * Event Tracing API.
     *
     ************************************************************************************/

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtTraceEvent(_In_ HANDLE TraceHandle, _In_ ULONG Flags, _In_ ULONG FieldSize, _In_ PVOID Fields);

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtTraceControl(
        _In_ ULONG FunctionCode,
        _In_reads_bytes_opt_(InBufferLen) PVOID InBuffer,
        _In_ ULONG InBufferLen,
        _Out_writes_bytes_opt_(OutBufferLen) PVOID OutBuffer,
        _In_ ULONG OutBufferLen,
        _Out_ PULONG ReturnLength);

    /************************************************************************************
     *
     * Enclave API.
     *
     ************************************************************************************/

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtLoadEnclaveData(
        _In_ HANDLE ProcessHandle,
        _In_ PVOID BaseAddress,
        _In_reads_bytes_(BufferSize) PVOID Buffer,
        _In_ SIZE_T BufferSize,
        _In_ ULONG Protect,
        _In_reads_bytes_(PageInformationLength) PVOID PageInformation,
        _In_ ULONG PageInformationLength,
        _Out_opt_ PSIZE_T NumberOfBytesWritten,
        _Out_opt_ PULONG EnclaveError);

    /************************************************************************************
     *
     * Kernel Debugger API.
     *
     ************************************************************************************/

    typedef struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION
    {
        BOOLEAN KernelDebuggerEnabled;
        BOOLEAN KernelDebuggerNotPresent;
    } SYSTEM_KERNEL_DEBUGGER_INFORMATION, *PSYSTEM_KERNEL_DEBUGGER_INFORMATION;

    typedef struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX
    {
        BOOLEAN DebuggerAllowed;
        BOOLEAN DebuggerEnabled;
        BOOLEAN DebuggerPresent;
    } SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX, *PSYSTEM_KERNEL_DEBUGGER_INFORMATION_EX;

    typedef enum _SYSDBG_COMMAND
    {
        SysDbgQueryModuleInformation,
        SysDbgQueryTraceInformation,
        SysDbgSetTracepoint,
        SysDbgSetSpecialCall,
        SysDbgClearSpecialCalls,
        SysDbgQuerySpecialCalls,
        SysDbgBreakPoint,
        SysDbgQueryVersion,
        SysDbgReadVirtual,
        SysDbgWriteVirtual,
        SysDbgReadPhysical,
        SysDbgWritePhysical,
        SysDbgReadControlSpace,
        SysDbgWriteControlSpace,
        SysDbgReadIoSpace,
        SysDbgWriteIoSpace,
        SysDbgReadMsr,
        SysDbgWriteMsr,
        SysDbgReadBusData,
        SysDbgWriteBusData,
        SysDbgCheckLowMemory,
        SysDbgEnableKernelDebugger,
        SysDbgDisableKernelDebugger,
        SysDbgGetAutoKdEnable,
        SysDbgSetAutoKdEnable,
        SysDbgGetPrintBufferSize,
        SysDbgSetPrintBufferSize,
        SysDbgGetKdUmExceptionEnable,
        SysDbgSetKdUmExceptionEnable,
        SysDbgGetTriageDump,
        SysDbgGetKdBlockEnable,
        SysDbgSetKdBlockEnable,
        SysDbgRegisterForUmBreakInfo,
        SysDbgGetUmBreakPid,
        SysDbgClearUmBreakPid,
        SysDbgGetUmAttachPid,
        SysDbgClearUmAttachPid,
        SysDbgGetLiveKernelDump
    } SYSDBG_COMMAND, *PSYSDBG_COMMAND;

    typedef struct _SYSDBG_VIRTUAL
    {
        PVOID Address;
        PVOID Buffer;
        ULONG Request;
    } SYSDBG_VIRTUAL, *PSYSDBG_VIRTUAL;

    NTSYSAPI
    NTSTATUS
    NTAPI
    NtSystemDebugControl(
        _In_ SYSDBG_COMMAND Command,
        _Inout_updates_bytes_opt_(InputBufferLength) PVOID InputBuffer,
        _In_ ULONG InputBufferLength,
        _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,
        _In_ ULONG OutputBufferLength,
        _Out_opt_ PULONG ReturnLength);

    /************************************************************************************
     *
     * Application Verifier API and definitions.
     *
     ************************************************************************************/

#ifndef DLL_PROCESS_VERIFIER
#define DLL_PROCESS_VERIFIER 4
#endif

    typedef VOID(NTAPI* RTL_VERIFIER_DLL_LOAD_CALLBACK)(PWSTR DllName, PVOID DllBase, SIZE_T DllSize, PVOID Reserved);

    typedef VOID(NTAPI* RTL_VERIFIER_DLL_UNLOAD_CALLBACK)(PWSTR DllName, PVOID DllBase, SIZE_T DllSize, PVOID Reserved);

    typedef VOID(NTAPI* RTL_VERIFIER_NTDLLHEAPFREE_CALLBACK)(PVOID AllocationBase, SIZE_T AllocationSize);

    typedef struct _RTL_VERIFIER_THUNK_DESCRIPTOR
    {
        PCHAR ThunkName;
        PVOID ThunkOldAddress;
        PVOID ThunkNewAddress;
    } RTL_VERIFIER_THUNK_DESCRIPTOR, *PRTL_VERIFIER_THUNK_DESCRIPTOR;

    typedef struct _RTL_VERIFIER_DLL_DESCRIPTOR
    {
        PWCHAR DllName;
        DWORD DllFlags;
        PVOID DllAddress;
        PRTL_VERIFIER_THUNK_DESCRIPTOR DllThunks;
    } RTL_VERIFIER_DLL_DESCRIPTOR, *PRTL_VERIFIER_DLL_DESCRIPTOR;

    typedef struct _RTL_VERIFIER_PROVIDER_DESCRIPTOR
    {
        DWORD Length;
        PRTL_VERIFIER_DLL_DESCRIPTOR ProviderDlls;
        RTL_VERIFIER_DLL_LOAD_CALLBACK ProviderDllLoadCallback;
        RTL_VERIFIER_DLL_UNLOAD_CALLBACK ProviderDllUnloadCallback;
        PWSTR VerifierImage;
        DWORD VerifierFlags;
        DWORD VerifierDebug;
        PVOID RtlpGetStackTraceAddress;
        PVOID RtlpDebugPageHeapCreate;
        PVOID RtlpDebugPageHeapDestroy;
        RTL_VERIFIER_NTDLLHEAPFREE_CALLBACK ProviderNtdllHeapFreeCallback;
    } RTL_VERIFIER_PROVIDER_DESCRIPTOR, *PRTL_VERIFIER_PROVIDER_DESCRIPTOR;

    //
    // Application verifier standard flags.
    //
#define RTL_VRF_FLG_FULL_PAGE_HEAP 0x00000001
#define RTL_VRF_FLG_RESERVED_DONOTUSE 0x00000002
#define RTL_VRF_FLG_HANDLE_CHECKS 0x00000004
#define RTL_VRF_FLG_STACK_CHECKS 0x00000008
#define RTL_VRF_FLG_APPCOMPAT_CHECKS 0x00000010
#define RTL_VRF_FLG_TLS_CHECKS 0x00000020
#define RTL_VRF_FLG_DIRTY_STACKS 0x00000040
#define RTL_VRF_FLG_RPC_CHECKS 0x00000080
#define RTL_VRF_FLG_COM_CHECKS 0x00000100
#define RTL_VRF_FLG_DANGEROUS_APIS 0x00000200
#define RTL_VRF_FLG_RACE_CHECKS 0x00000400
#define RTL_VRF_FLG_DEADLOCK_CHECKS 0x00000800
#define RTL_VRF_FLG_FIRST_CHANCE_EXCEPTION_CHECKS 0x00001000
#define RTL_VRF_FLG_VIRTUAL_MEM_CHECKS 0x00002000
#define RTL_VRF_FLG_ENABLE_LOGGING 0x00004000
#define RTL_VRF_FLG_FAST_FILL_HEAP 0x00008000
#define RTL_VRF_FLG_VIRTUAL_SPACE_TRACKING 0x00010000
#define RTL_VRF_FLG_ENABLED_SYSTEM_WIDE 0x00020000
#define RTL_VRF_FLG_MISCELLANEOUS_CHECKS 0x00020000
#define RTL_VRF_FLG_LOCK_CHECKS 0x00040000

    NTSYSAPI
    VOID NTAPI
    RtlApplicationVerifierStop(
        _In_ ULONG_PTR Code,
        _In_ PSTR Message,
        _In_ ULONG_PTR Param1,
        _In_ PSTR Description1,
        _In_ ULONG_PTR Param2,
        _In_ PSTR Description2,
        _In_ ULONG_PTR Param3,
        _In_ PSTR Description3,
        _In_ ULONG_PTR Param4,
        _In_ PSTR Description4);

#ifndef VERIFIER_STOP
#define VERIFIER_STOP(Code, Msg, P1, S1, P2, S2, P3, S3, P4, S4)                                                       \
    {                                                                                                                  \
        RtlApplicationVerifierStop(                                                                                    \
            (Code),                                                                                                    \
            (Msg),                                                                                                     \
            (ULONG_PTR)(P1),                                                                                           \
            (S1),                                                                                                      \
            (ULONG_PTR)(P2),                                                                                           \
            (S2),                                                                                                      \
            (ULONG_PTR)(P3),                                                                                           \
            (S3),                                                                                                      \
            (ULONG_PTR)(P4),                                                                                           \
            (S4));                                                                                                     \
    }
#endif


    //
    // NTOS_RTL HEADER END
    //

#pragma warning(pop)


    //
    // Status code
    //
#pragma warning(push)
#pragma warning(disable : 4005) // macro redefinition
#include <ntstatus.h>
#pragma warning(pop)


#ifdef __cplusplus
}
#endif

```

`Broker/Headers/Resource.h`:

```h
#define IDR_CFB_DRIVER 101
#define CFB_DRIVER_DATAFILE 101

```

`Broker/Headers/ServiceManager.hpp`:

```hpp
#pragma once

#include <wil/resource.h>

#include <filesystem>
#include <mutex>
#include <optional>

#include "Common.hpp"
#include "ManagerBase.hpp"

namespace fs = std::filesystem;

namespace CFB::Broker
{

class Win32Service
{
    enum class ServiceState
    {
        Uninitialized,
        Initialized,
        Running,
        ShuttingDown,
        Shutdown
    };


public:
    ///
    /// @brief Construct a new Win32Service object
    ///
    Win32Service();

    ///
    /// @brief Destroy the Win32Service object
    ///
    ~Win32Service();

    ///
    /// @brief Run forever until told to stop
    ///
    void
    RunForever();

    ///
    /// @brief Stops the service, this method is invoked from the SCM
    ///
    /// @return true
    /// @return false
    ///
    bool
    Stop();

private:
    ///
    /// @brief
    ///
    /// @param lpServiceStatus
    /// @return true
    /// @return false
    ///
    bool
    ReportServiceStatus(LPSERVICE_STATUS lpServiceStatus);

    ///
    /// @brief Set the Status Handle object
    ///
    /// @param hServiceStatus
    /// @return true
    /// @return false
    ///
    bool
    InitializeRoutine();

    ///
    /// @brief Notification dispatcher
    ///
    /// @return true
    /// @return false
    ///
    bool Notify(ServiceState);

    ///
    /// @brief This mutex protects state changes
    ///
    std::mutex m_Mutex;

    ///
    /// @brief The manager current state
    ///
    ServiceState m_State;

    ///
    /// @brief Changed state notification event.
    ///
    HANDLE m_ServiceStateChangedEvent;

    ///
    /// @brief Handle to the service status
    ///
    SERVICE_STATUS_HANDLE m_StatusHandle;

    // SERVICE_STATUS m_ServiceStatus;

    usize m_StatusCheckPoint;
};

class ServiceManager : public ManagerBase
{

public:
    ///
    /// @brief Construct a new Service Manager:: Service Manager object
    ///
    ///
    ServiceManager();

    ///
    /// @brief Destroy the Service Manager:: Service Manager object
    ///
    ///
    ~ServiceManager();

    ///
    /// @brief
    ///
    void
    Run();

    ///
    /// @brief
    ///
    ///
    Result<bool>
    Setup();

    ///
    /// @brief Get the Manager naem
    ///
    /// @return std::string const
    ///
    std::string const
    Name();

    ///
    /// @brief
    ///
    /// @return std::optional<Win32Service>&
    ///
    std::shared_ptr<Win32Service>
    BackgroundService();

    ///
    /// @brief
    ///
    /// @return true
    /// @return false
    ///
    bool
    InstallBackgroundService();

    ///
    /// @brief
    ///
    /// @return true
    /// @return false
    ///
    bool
    RunAsBackgroundService();


private:
    ///
    /// @brief Extracts the IrpMonitor driver embedded in the PE resource section.
    ///
    /// @return `true` upon successful extraction of the driver from the resource of the driver
    /// @return `false` f any error occured.
    ///
    bool
    ExtractDriverFromResource();

    ///
    /// @brief Delete the driver extracted from the PE resources from the disk.
    ///
    /// @return `true` upon successful deletion of the driver from the disk.
    /// @return `false`
    ///
    bool
    DeleteDriverFromDisk();

    ///
    /// @brief Connects to the Windows Service Manager to create and start a service for the IrpMonitor driver.
    ///
    /// @return true if the service was successfully created, and the driver loaded
    /// @return false in any other case
    ///
    bool
    LoadDriver();

    ///
    /// @brief Unloads the driver and deletes the service from the Windows Service Manager.
    ///
    /// @return `true `if the driver was successfully unloaded
    /// @return `false` in any other case
    ///
    bool
    UnloadDriver();

    ///
    /// @brief The fs::path of the driver on disk
    ///
    fs::path m_DriverTempPath;

    ///
    /// @brief Unique pointer to the service control manager
    ///
    wil::unique_schandle m_hSCManager;

    ///
    /// @brief Unique pointer to the service manager
    ///
    wil::unique_schandle m_hService;

    ///
    /// @brief Background service (if set by globals)
    ///
    std::shared_ptr<Win32Service> m_BackgroundService;
};


} // namespace CFB::Broker

```

`Broker/Headers/States.hpp`:

```hpp
#pragma once

namespace CFB::Broker
{
enum class State : unsigned int
{
    Uninitialized         = 1,
    ServiceManagerReady   = 2,
    IrpManagerReady       = 3,
    ConnectorManagerReady = 4,
    AllManagerReady       = ConnectorManagerReady,
    Running               = 5,
    ConnectorManagerDone  = 6,
    IrpManagerDone        = 7,
    ServiceManagerDone    = 8,
    AllManagerDone        = ServiceManagerDone,
    Finished              = 9
};
} // namespace CFB::Broker


namespace CFB::Broker::Utils
{
#define CaseToString(x)                                                                                                \
    {                                                                                                                  \
    case (x):                                                                                                          \
        return #x;                                                                                                     \
    }

constexpr const char*
ToString(State x)
{
    switch ( x )
    {
        CaseToString(State::Uninitialized);
        CaseToString(State::ServiceManagerReady);
        CaseToString(State::IrpManagerReady);
        CaseToString(State::ConnectorManagerReady);
        CaseToString(State::Running);
        CaseToString(State::ConnectorManagerDone);
        CaseToString(State::IrpManagerDone);
        CaseToString(State::ServiceManagerDone);
        CaseToString(State::Finished);
    default:
        throw std::invalid_argument("Unimplemented item");
    }
}
#undef CaseAsString
} // namespace CFB::Broker::Utils

```

`Broker/Headers/pch.hpp`:

```hpp
#pragma once


#include <algorithm>
#include <array>
#include <format>
#include <memory>
#include <optional>
#include <string>
#include <variant>
#include <vector>

```

`Broker/Source/Broker.rc.in`:

```in
#include <Winver.h>

VS_VERSION_INFO     VERSIONINFO
FILEVERSION         @BROKER_VERSION_MAJOR@,@BROKER_VERSION_MINOR@,@BROKER_VERSION_PATCH@,0
PRODUCTVERSION      @CFB_VERSION_MAJOR@,@CFB_VERSION_MINOR@,@CFB_VERSION_PATCH@,0
FILEOS              VOS_NT_WINDOWS32
FILETYPE            VFT_APP
FILESUBTYPE         VFT2_UNKNOWN

BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904E4"
        BEGIN
            VALUE "CompanyName",        "@CFB_COMPANY_NAME@\0"
            VALUE "FileDescription",    "@PROJECT_DESCRIPTION@\0"
            VALUE "FileVersion",        "@BROKER_VERSION_MAJOR@,@BROKER_VERSION_MINOR@,@BROKER_VERSION_PATCH@,0\0"
            VALUE "LegalCopyright",     "(c) @CFB_CURRENT_YEAR@ @CFB_COMPANY_NAME@ Release Under @PROJECT_LICENSE@\0"
            VALUE "OriginalFilename",   "@PROJECT_NAME@.exe\0"
            VALUE "ProductName",        "@CMAKE_PROJECT_NAME@\0"
            VALUE "ProductVersion",     "@CFB_VERSION_MAJOR@,@CFB_VERSION_MINOR@,@CFB_VERSION_PATCH@,0\0"
            VALUE "Comments",           "@PROJECT_DESCRIPTION@\0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END


#include "Resource.h"

/////////////////////////////////////////////////////////////////////////////
//
// CFB_DRIVER
//

IDR_CFB_DRIVER         CFB_DRIVER_DATAFILE       "@CFB_BROKER_DRIVER_PATH@"



/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

IDI_ICON1               ICON                    "@CFB_BROKER_ICON_PATH@"


```

`Broker/Source/BrokerUtils.cpp`:

```cpp
#include "BrokerUtils.hpp"

#include <wil/resource.h>
#include <wil/token_helpers.h>

#include "Log.hpp"


namespace CFB::Broker::Utils
{

namespace Base64
{
static const std::string base64_chars =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    "abcdefghijklmnopqrstuvwxyz"
    "0123456789+/";


static inline bool
is_base64(unsigned char c)
{
    return (isalnum(c) || (c == '+') || (c == '/'));
}


std::string
Encode(std::vector<u8> const& bytes)
{
    return Encode(bytes.data(), bytes.size());
}


std::string
Encode(const u8* input_buffer, const usize input_buffer_len)
{
    std::string ret;
    int i = 0;
    int j = 0;
    unsigned char char_array_3[3];
    unsigned char char_array_4[4];
    usize len = input_buffer_len;

    while ( len-- )
    {
        char_array_3[i++] = *(input_buffer++);
        if ( i == 3 )
        {
            char_array_4[0] = (char_array_3[0] & 0xfc) >> 2;
            char_array_4[1] = ((char_array_3[0] & 0x03) << 4) + ((char_array_3[1] & 0xf0) >> 4);
            char_array_4[2] = ((char_array_3[1] & 0x0f) << 2) + ((char_array_3[2] & 0xc0) >> 6);
            char_array_4[3] = char_array_3[2] & 0x3f;

            for ( i = 0; (i < 4); i++ )
                ret += base64_chars[char_array_4[i]];
            i = 0;
        }
    }

    if ( i )
    {
        for ( j = i; j < 3; j++ )
            char_array_3[j] = '\0';

        char_array_4[0] = (char_array_3[0] & 0xfc) >> 2;
        char_array_4[1] = ((char_array_3[0] & 0x03) << 4) + ((char_array_3[1] & 0xf0) >> 4);
        char_array_4[2] = ((char_array_3[1] & 0x0f) << 2) + ((char_array_3[2] & 0xc0) >> 6);
        char_array_4[3] = char_array_3[2] & 0x3f;

        for ( j = 0; (j < i + 1); j++ )
            ret += base64_chars[char_array_4[j]];

        while ( (i++ < 3) )
            ret += '=';
    }

    return ret;
}


std::vector<u8>
Decode(std::string const& encoded_string)
{
    size_t in_len = encoded_string.size();
    int i         = 0;
    int j         = 0;
    int in_       = 0;
    unsigned char char_array_4[4], char_array_3[3];
    std::vector<u8> ret;

    while ( in_len-- && (encoded_string[in_] != '=') && is_base64(encoded_string[in_]) )
    {
        char_array_4[i++] = encoded_string[in_];
        in_++;
        if ( i == 4 )
        {
            for ( i = 0; i < 4; i++ )
                char_array_4[i] = base64_chars.find(char_array_4[i]) & 0xff;

            char_array_3[0] = (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4);
            char_array_3[1] = ((char_array_4[1] & 0xf) << 4) + ((char_array_4[2] & 0x3c) >> 2);
            char_array_3[2] = ((char_array_4[2] & 0x3) << 6) + char_array_4[3];

            for ( i = 0; (i < 3); i++ )
                ret.push_back(char_array_3[i]);
            i = 0;
        }
    }

    if ( i )
    {
        for ( j = i; j < 4; j++ )
            char_array_4[j] = 0;

        for ( j = 0; j < 4; j++ )
            char_array_4[j] = base64_chars.find(char_array_4[j]) & 0xff;

        char_array_3[0] = (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4);
        char_array_3[1] = ((char_array_4[1] & 0xf) << 4) + ((char_array_4[2] & 0x3c) >> 2);
        char_array_3[2] = ((char_array_4[2] & 0x3) << 6) + char_array_4[3];

        for ( j = 0; (j < i - 1); j++ )
            ret.push_back(char_array_3[j]);
    }

    return ret;
}
} // namespace Base64


Result<std::vector<std::pair<std::wstring, std::wstring>>>
EnumerateObjectDirectory(std::wstring const& Root)
{
    NTSTATUS Status = STATUS_SUCCESS;

    std::vector<std::pair<std::wstring, std::wstring>> ObjectList;

    wil::unique_handle hDirectory;
    ULONG ctx = 0;

    {
        HANDLE h;
        OBJECT_ATTRIBUTES oa;
        UNICODE_STRING name;

        ::RtlInitUnicodeString(&name, Root.c_str());
        InitializeObjectAttributes(&oa, &name, OBJ_CASE_INSENSITIVE, nullptr, nullptr);

        Status = ::NtOpenDirectoryObject(&h, DIRECTORY_QUERY | DIRECTORY_TRAVERSE, &oa);
        if ( !NT_SUCCESS(Status) )
        {
            err("NtOpenDirectoryObject()");
            return Err(ErrorCode::InsufficientPrivilegeError);
        }

        hDirectory = wil::unique_handle(h);
    }

    do
    {
        ULONG rlen = 0;

        Status = ::NtQueryDirectoryObject(hDirectory.get(), nullptr, 0, true, false, &ctx, &rlen);
        if ( Status == STATUS_NO_MORE_ENTRIES )
        {
            break;
        }

        if ( Status != STATUS_BUFFER_TOO_SMALL )
        {
            CFB::Log::ntperror("NtQueryDirectoryObject()", Status);
            return Err(ErrorCode::InsufficientPrivilegeError);
        }

        auto buffer = std::make_unique<u8[]>(rlen);
        if ( !buffer )
        {
            err("allocation failed");
            return Err(ErrorCode::InsufficientPrivilegeError);
        }

        auto pObjDirInfo = reinterpret_cast<POBJECT_DIRECTORY_INFORMATION>(buffer.get());

        Status = ::NtQueryDirectoryObject(hDirectory.get(), pObjDirInfo, rlen, true, false, &ctx, &rlen);
        if ( NT_SUCCESS(Status) )
        {
            for ( ULONG i = 0; i < ctx; i++ )
            {
                if ( !pObjDirInfo[i].Name.Buffer || !pObjDirInfo[i].TypeName.Buffer )
                    break;

                ObjectList.push_back(std::make_pair(
                    std::wstring(pObjDirInfo[i].Name.Buffer),
                    std::wstring(pObjDirInfo[i].TypeName.Buffer)));
            }
        }
    } while ( true );

    return Ok(ObjectList);
}


Result<bool>
AcquirePrivileges(std::vector<std::wstring_view> const& privilege_names)
{
    wil::unique_handle hToken;
    if ( FAILED(wil::open_current_access_token_nothrow(&hToken, TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES)) )
    {
        return Err(ErrorCode::InsufficientPrivilegeError);
    }

    const usize NbPrivileges            = privilege_names.size();
    const usize BufferSize              = sizeof(TOKEN_PRIVILEGES) + NbPrivileges * sizeof(LUID_AND_ATTRIBUTES);
    auto NewPrivileges                  = std::make_unique<TOKEN_PRIVILEGES[]>(BufferSize);
    usize i                             = 0;
    NewPrivileges.get()->PrivilegeCount = NbPrivileges;

    for ( auto const& privilege_name : privilege_names )
    {
        LUID Luid = {
            0,
        };

        if ( !::LookupPrivilegeValueW(nullptr, privilege_name.data(), &Luid) )
        {
            return Err(ErrorCode::LookupError);
        }

        NewPrivileges.get()->Privileges[i].Attributes = SE_PRIVILEGE_ENABLED;
        NewPrivileges.get()->Privileges[i].Luid       = Luid;
        i++;
    }

    if ( ::AdjustTokenPrivileges(
             hToken.get(),
             false,
             NewPrivileges.get(),
             BufferSize,
             (PTOKEN_PRIVILEGES) nullptr,
             (PDWORD) nullptr) != 0 )
    {
        return Ok(::GetLastError() != ERROR_NOT_ALL_ASSIGNED);
    }

    return Ok(true);
}

Result<bool>
HasPrivilege(std::wstring_view const& privilege_name)
{
    dbg("Checking for '%S'...", privilege_name.data());

    //
    // Make sure the privilege name exists
    //
    LUID Luid = {0};
    if ( !::LookupPrivilegeValueW(nullptr, privilege_name.data(), &Luid) )
    {
        CFB::Log::perror("LookupPrivilegeValue");
        return Err(ErrorCode::LookupError);
    }


    //
    // Get a query handle to the token
    //
    wil::unique_handle hToken;
    if ( FAILED(wil::open_current_access_token_nothrow(&hToken, TOKEN_QUERY)) )
    {
        return Err(ErrorCode::InsufficientPrivilegeError);
    }

    //
    // Query for the specific privilege
    bool bHasPriv = false;
    {
        LUID_AND_ATTRIBUTES PrivAttr = {0};
        PrivAttr.Luid                = Luid;
        PrivAttr.Attributes          = SE_PRIVILEGE_ENABLED | SE_PRIVILEGE_ENABLED_BY_DEFAULT;

        PRIVILEGE_SET PrivSet  = {0};
        PrivSet.PrivilegeCount = 1;
        PrivSet.Privilege[0]   = PrivAttr;

        if ( !::PrivilegeCheck(hToken.get(), &PrivSet, reinterpret_cast<LPBOOL>(&bHasPriv)) )
        {
            CFB::Log::perror("PrivilegeCheck()");
            return Err(ErrorCode::InsufficientPrivilegeError);
        }
    }

    return Ok(bHasPriv);
}


} // namespace CFB::Broker::Utils

```

`Broker/Source/ConnectorManager.cpp`:

```cpp
#define CFB_NS "[CFB::ConnectorManager::CallbackDispatcher]"

// clang-format off
#include "ConnectorManager.hpp"

#include "Context.hpp"
#include "Log.hpp"

#include "Connectors/Dummy.hpp" // for test
#include "Connectors/JsonQueue.hpp"
// clang-format on

namespace CFB::Broker
{

///
///@brief
///
static std::vector<std::shared_ptr<Connectors::ConnectorBase>> g_Connectors {};

///
///@brief
///
///@param Irp
///@return true
///@return false
///
bool
CallbackDispatcher(CFB::Comms::CapturedIrp const& Irp)
{
    const usize nbTotal = g_Connectors.size();
    dbg("[ConnectorManager::CallbackDispatcher] Dispatching IRP received at TS=%llu to %u connector%s",
        Irp.Header.TimeStamp,
        nbTotal,
        PLURAL_IF(nbTotal > 1),
        &g_Connectors);

    usize nbSuccess = 0;

    for ( auto& Connector : g_Connectors )
    {
        if ( Connector->IsEnabled() == false )
        {
            continue;
        }

        dbg("[ConnectorManager::CallbackDispatcher] Sending IRP to Connector:'%s'", Connector->Name().c_str());
        if ( Success(Connector->IrpCallback(Irp)) )
        {
            nbSuccess++;
        }
    }

    dbg("[ConnectorManager::CallbackDispatcher] %u/%u executed successfully", nbSuccess, nbTotal);
    return true;
}


std::string const
ConnectorManager::Name()
{
    return "ConnectorManager";
}


Result<bool>
ConnectorManager::Setup()
{
    //
    // Wait for the service to be ready
    //
    WaitForState(CFB::Broker::State::IrpManagerReady);

    //
    // Register the callback dispatcher
    //
    dbg("Register the connector dispatcher to the IRP manager");
    if ( Globals.IrpManager()->SetCallback(&CallbackDispatcher) )
    {
        info("Connector dispatcher successfully registered");

        //
        // Add new connector to that list
        //
        {
            auto conn = std::make_shared<Connectors::Dummy>();
            conn->Enable();
            g_Connectors.push_back(conn);
        }

        {
            auto conn = std::make_shared<Connectors::JsonQueue>();
            conn->Enable();
            g_Connectors.push_back(conn);
        }

        dbg("%u connector%s registered to %p", g_Connectors.size(), PLURAL_IF(g_Connectors.size() > 1), &g_Connectors);
    }
    else
    {
        info("Failed to register the connector dispatcher");
        return Err(ErrorCode::InitializationError);
    }

    //
    // Notify other threads that the Collector Manager is ready
    // This will also effectively start the collection by the IrpManager from the driver
    //
    SetState(CFB::Broker::State::ConnectorManagerReady);

    return Ok(true);
}


Result<std::shared_ptr<Connectors::ConnectorBase>>
ConnectorManager::GetConnectorByName(std::string_view const& ConnectorName)
{
    auto res = std::find_if(
        g_Connectors.cbegin(),
        g_Connectors.cend(),
        [&ConnectorName](auto const& Conn)
        {
            return Conn->Name() == ConnectorName;
        });

    if ( res == std::end(g_Connectors) )
    {
        return Err(ErrorCode::NotFound);
    }

    return Ok(*res);
}


void
ConnectorManager::Run()
{
    WaitForState(CFB::Broker::State::Running);

    //
    // Wait for termination event
    //
    ::WaitForSingleObject(m_hTerminationEvent.get(), INFINITE);
    dbg("TerminationEvent received");

    //
    // Propagate the notification to the other managers
    //
    SetState(CFB::Broker::State::ConnectorManagerDone);
}


} // namespace CFB::Broker

```

`Broker/Source/Connectors/Dummy.cpp`:

```cpp
#define CFB_NS "[CFB::Broker::Connectors::Dummy]"

#include "Connectors/Dummy.hpp"

#include <iostream>

#include "Log.hpp"
#include "Utils.hpp"

#define MAX_HEXDUMP_BYTES 256


namespace CFB::Broker::Connectors
{

Dummy::Dummy()
{
    dbg("Initializing connector '%s'", Name().c_str());
}

Dummy::~Dummy()
{
    dbg("Terminating connector '%s'", Name().c_str());
}

std::string const
Dummy::Name() const
{
    return "Dummy";
}

Result<u32>
Dummy::IrpCallback(CFB::Comms::CapturedIrp const& Irp)
{
    SYSTEMTIME SystemTime {};
    if ( ::FileTimeToSystemTime((FILETIME*)&Irp.Header.TimeStamp, &SystemTime) )
    {
        std::ostringstream info, details;
        info << "New IRP: ";
        info << SystemTime.wYear << "/";
        info << SystemTime.wMonth << "/";
        info << SystemTime.wDay << " ";
        info << SystemTime.wHour << ":";
        info << SystemTime.wMinute << ":";
        info << SystemTime.wSecond << ":";
        info << SystemTime.wMilliseconds << " UTC";
        info("%s", info.str().c_str());
    }

    std::ostringstream details;
    details << "Details:" << std::endl;
    details << "  - Driver: " << CFB::Utils::ToString(Irp.Header.DriverName) << std::endl;
    details << "  - Device: " << CFB::Utils::ToString(Irp.Header.DeviceName) << std::endl;
    details << "  - Process: " << CFB::Utils::ToString(Irp.Header.ProcessName) << " (PID:" << Irp.Header.Pid
            << ", TID:" << Irp.Header.Tid << ")" << std::endl;
    if ( Irp.Header.MajorFunction == 0xe || Irp.Header.MajorFunction == 0xf )
    {
        details << "  - IOCTL code: " << CFB::Utils::ToString(CFB::Comms::Ioctl {Irp.Header.IoctlCode}) << std::endl;
    }
    details << std::hex;
    details << "  - Major: " << CFB::Utils::IrpMajorToString((u32)Irp.Header.MajorFunction) << std::endl;
    details << "  - Minor: " << (u32)Irp.Header.MinorFunction << std::endl;
    details << "  - InLen: " << Irp.Header.InputBufferLength << std::endl;
    details << "  - OutLen: " << Irp.Header.OutputBufferLength << std::endl;
    details << "  - Status: " << Irp.Header.Status << std::endl;
    dbg("%s", details.str().c_str());
    if ( Irp.Header.Status )
    {
        CFB::Log::ntperror("  - NTSTATUS", Irp.Header.Status);
    }

    if ( Irp.Header.InputBufferLength )
    {
        CFB::Utils::Hexdump(
            (PVOID)Irp.InputBuffer.data(),
            MIN(Irp.InputBuffer.size(), MAX_HEXDUMP_BYTES),
            "InputBuffer");
    }

    if ( Irp.Header.OutputBufferLength )
    {
        CFB::Utils::Hexdump(
            (PVOID)Irp.OutputBuffer.data(),
            MIN(Irp.OutputBuffer.size(), MAX_HEXDUMP_BYTES),
            "Output Buffer");
    }

    return Ok(0);
}

} // namespace CFB::Broker::Connectors

```

`Broker/Source/Connectors/JsonQueue.cpp`:

```cpp
#include "Connectors/JsonQueue.hpp"

#include "Log.hpp"


namespace CFB::Broker::Connectors
{
JsonQueue::JsonQueue()
{
    dbg("Initializing connector '%s'", Name().c_str());
}

JsonQueue::~JsonQueue()
{
    dbg("Terminating connector '%s'", Name().c_str());
}

std::string const
JsonQueue::Name() const
{
    return "JsonQueue";
}

Result<u32>
JsonQueue::IrpCallback(CFB::Comms::CapturedIrp const& Irp)
{
    std::scoped_lock(m_Lock);
    m_Queue.push(std::make_unique<CFB::Comms::CapturedIrp>(Irp));
    return Ok(0);
}

std::unique_ptr<CFB::Comms::CapturedIrp>
JsonQueue::Pop()
{
    std::scoped_lock(m_Lock);
    if ( m_Queue.empty() )
    {
        return nullptr;
    }

    auto Irp = std::move(m_Queue.front());
    m_Queue.pop();

    return Irp;
}

} // namespace CFB::Broker::Connectors

```

`Broker/Source/Context.cpp`:

```cpp
#include "Context.hpp"

#include "Log.hpp"


GlobalContext::GlobalContext() :
    m_State(CFB::Broker::State::Uninitialized),
    m_Pid(::GetCurrentProcessId()),
    m_bIsShuttingDown(false)
{
    //
    // Get the broker executable absolute path
    //
    {
        std::wstring wsPath;
        wsPath.resize(MAX_PATH);
        ::GetModuleFileNameW(nullptr, wsPath.data(), MAX_PATH);
        m_BrokerPath = wsPath;
    }

    //
    // Create a termination event
    //
    {
        wil::unique_handle hEvent(::CreateEventW(nullptr, true, false, nullptr));
        if ( !hEvent )
        {
            CFB::Log::perror("CreateEventW(TerminationEvent)");
            throw std::runtime_error("GlobalContext()");
        }

        m_hTerminationEvent = std::move(hEvent);
    }

    //
    // Initialiazes the managers
    //
    m_ServiceManager   = std::make_shared<CFB::Broker::ServiceManager>();
    m_IrpManager       = std::make_shared<CFB::Broker::IrpManager>();
    m_ConnectorManager = std::make_shared<CFB::Broker::ConnectorManager>();
    m_DriverManager    = std::make_shared<CFB::Broker::DriverManager>();

    //
    // Start the individual threads
    //
    m_ServiceManagerThread = std::jthread(
        [this]()
        {
            if ( Success(m_ServiceManager->Setup()) )
            {
                m_ServiceManager->Run();
            }
        });

    m_IrpManagerThread = std::jthread(
        [this]()
        {
            if ( Success(m_IrpManager->Setup()) )
            {
                m_IrpManager->Run();
            }
        });

    m_ConnectorManagerThread = std::jthread(
        [this]()
        {
            if ( Success(m_ConnectorManager->Setup()) )
            {
                m_ConnectorManager->Run();
            }
        });

    m_DriverManagerThread = std::jthread(
        [this]()
        {
            if ( Success(m_DriverManager->Setup()) )
            {
                m_DriverManager->Run();
            }
        });
}


GlobalContext::~GlobalContext()
{
    info("Destroying global context.");

    m_ServiceManagerThread.join();
    m_IrpManagerThread.join();
    m_ConnectorManagerThread.join();
    m_DriverManagerThread.join();
}


CFB::Broker::State const
GlobalContext::State() const
{
    return m_State;
}


bool
GlobalContext::SetState(CFB::Broker::State NewState)
{
    bool res = true;

    {
        std::scoped_lock lock(m_StateMutex);

        if ( NewState == CFB::Broker::State::AllManagerReady )
        {
            NewState = CFB::Broker::State::Running;
            ok("All managers are ready!");
        }

        if ( NewState == CFB::Broker::State::AllManagerDone )
        {
            NewState = CFB::Broker::State::Finished;
            ok("All managers have finished!");
        }

        //
        // This shouldn't happen, so print a warning if it does for investigate
        //
        if ( NewState < m_State )
        {
            warn(
                "Suspicious state transition asked: Current: %s -> New: %s",
                CFB::Broker::Utils::ToString(NewState),
                CFB::Broker::Utils::ToString(m_State));
            res = false;
        }

        //
        // Apply the global state change
        //
        m_State = NewState;
    }

    //
    // Notify all managers
    //
    res &= m_ServiceManager->NotifyStateChange();
    res &= m_ConnectorManager->NotifyStateChange();
    res &= m_IrpManager->NotifyStateChange();
    res &= m_DriverManager->NotifyStateChange();

    return res;
}

u32 const
GlobalContext::Pid() const
{
    return m_Pid;
}


fs::path const&
GlobalContext::Path() const
{
    return m_BrokerPath;
}


std::shared_ptr<CFB::Broker::ServiceManager>
GlobalContext::ServiceManager() const
{
    return m_ServiceManager;
}


std::shared_ptr<CFB::Broker::DriverManager>
GlobalContext::DriverManager() const
{
    return m_DriverManager;
}


std::shared_ptr<CFB::Broker::IrpManager>
GlobalContext::IrpManager() const
{
    return m_IrpManager;
}

std::shared_ptr<CFB::Broker::ConnectorManager>
GlobalContext::ConnectorManager() const
{
    return m_ConnectorManager;
}


const HANDLE
GlobalContext::TerminationEvent() const
{
    return m_hTerminationEvent.get();
}


bool
GlobalContext::Stop()
{
    bool res = true;

    m_bIsShuttingDown = true;

    res &= m_ServiceManager->NotifyTermination();
    res &= m_ConnectorManager->NotifyTermination();
    res &= m_IrpManager->NotifyTermination();
    res &= m_DriverManager->NotifyTermination();
    res &= (::SetEvent(m_hTerminationEvent.get()) == TRUE);

    return res;
}

```

`Broker/Source/DriverManager.cpp`:

```cpp
#define CFB_NS "[CFB::Broker::DriverManager]"

// clang-format off
#include "DriverManager.hpp"

#include <codecvt>
#include <locale>

#include "BrokerUtils.hpp"
#include "Context.hpp"
#include "Error.hpp"
#include "IoctlCodes.hpp"
#include "Log.hpp"
#include "Messages.hpp"
#include "States.hpp"
#include "Utils.hpp"
#include "Comms.hpp"

#include "Connectors/JsonQueue.hpp"
// clang-format on

namespace CFB::Broker
{
DriverManager::DriverManager() : m_RequestNumber {0}
{
}

DriverManager::~DriverManager()
{
}


std::string const
DriverManager::Name()
{
    return "DriverManager";
}


void
DriverManager::Run()
{
    WaitForState(CFB::Broker::State::Running);

    m_Listener.RunForever();
}


Result<bool>
DriverManager::Setup()
{
    //
    // Wait for the service to be ready
    //
    WaitForState(CFB::Broker::State::ServiceManagerReady);

    //
    // Get a handle to the driver
    //
    {
        wil::unique_handle hDevice(::CreateFileW(
            CFB_USER_DEVICE_PATH,
            GENERIC_READ,
            FILE_SHARE_READ,
            nullptr,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            nullptr));
        if ( !hDevice )
        {
            CFB::Log::perror("DriverManager::CreateFileW()");
            return Err(ErrorCode::InitializationError);
        }

        dbg("Got handle %x to device %S", hDevice.get(), CFB_USER_DEVICE_PATH);
        m_hDevice = std::move(hDevice);
    }

    return Ok(true);
}


Result<json>
DriverManager::ExecuteCommand(json const& Request)
{
    std::lock_guard lock(m_ManagerLock);
    json Response;
    bool bSuccess    = false;
    DWORD nbReturned = 0;

    if ( Globals.State() <= CFB::Broker::State::ServiceManagerReady )
    {
        return Err(ErrorCode::DeviceNotInitialized);
    }

    auto RequestId      = Request.at("id").get<CFB::Comms::RequestId>();
    Response["success"] = false;

    InterlockedIncrement64((long long*)&m_RequestNumber);

    if ( RequestId != CFB::Comms::RequestId::GetPendingIrp )
        dbg("New request %s => ID=%llu", CFB::Utils::ToString(RequestId).c_str(), m_RequestNumber);

    switch ( RequestId )
    {
    case CFB::Comms::RequestId::HookDriver:
    {
        auto msg         = Request.get<CFB::Comms::DriverRequest>();
        auto data_in     = (LPVOID)msg.DriverName.c_str();
        auto data_in_len = msg.DriverName.size() * sizeof(wchar_t);
        Response["success"] =
            (TRUE == ::DeviceIoControl(
                         m_hDevice.get(),
                         static_cast<std::underlying_type<CFB::Comms::Ioctl>::type>(Comms::Ioctl::HookDriver),
                         data_in,
                         data_in_len,
                         nullptr,
                         0,
                         &nbReturned,
                         nullptr));
        break;
    }

    case CFB::Comms::RequestId::UnhookDriver:
    {
        auto msg         = Request.get<CFB::Comms::DriverRequest>();
        auto data_in     = (LPVOID)msg.DriverName.c_str();
        auto data_in_len = msg.DriverName.size() * sizeof(wchar_t);
        Response["success"] =
            (TRUE == ::DeviceIoControl(
                         m_hDevice.get(),
                         static_cast<std::underlying_type<CFB::Comms::Ioctl>::type>(Comms::Ioctl::UnhookDriver),
                         data_in,
                         data_in_len,
                         nullptr,
                         0,
                         &nbReturned,
                         nullptr));
        break;
    }

    case CFB::Comms::RequestId::GetNumberOfDrivers:
    {
        Response["success"] =
            (TRUE == ::DeviceIoControl(
                         m_hDevice.get(),
                         static_cast<std::underlying_type<CFB::Comms::Ioctl>::type>(Comms::Ioctl::GetNumberOfDrivers),
                         nullptr,
                         0,
                         nullptr,
                         0,
                         &nbReturned,
                         nullptr));
        Response["value"] = nbReturned;
        break;
    }

    case CFB::Comms::RequestId::EnableMonitoring:
    {
        auto msg         = Request.get<CFB::Comms::DriverRequest>();
        auto data_in     = (LPVOID)msg.DriverName.c_str();
        auto data_in_len = msg.DriverName.size() * sizeof(wchar_t);
        Response["success"] =
            (TRUE == ::DeviceIoControl(
                         m_hDevice.get(),
                         static_cast<std::underlying_type<CFB::Comms::Ioctl>::type>(Comms::Ioctl::EnableMonitoring),
                         data_in,
                         data_in_len,
                         nullptr,
                         0,
                         &nbReturned,
                         nullptr));
        break;
    }

    case CFB::Comms::RequestId::DisableMonitoring:
    {
        auto msg         = Request.get<CFB::Comms::DriverRequest>();
        auto data_in     = (LPVOID)msg.DriverName.c_str();
        auto data_in_len = msg.DriverName.size() * sizeof(wchar_t);
        Response["success"] =
            (TRUE == ::DeviceIoControl(
                         m_hDevice.get(),
                         static_cast<std::underlying_type<CFB::Comms::Ioctl>::type>(Comms::Ioctl::DisableMonitoring),
                         data_in,
                         data_in_len,
                         nullptr,
                         0,
                         &nbReturned,
                         nullptr));
        break;
    }

    case CFB::Comms::RequestId::GetDriverInfo:
    {
        Response["success"] = false;
        Response["reason"]  = "NotImplemented";
        break;
    }

    case CFB::Comms::RequestId::EnumerateDriverObject:
    {
        auto res = CFB::Broker::Utils::EnumerateObjectDirectory(L"\\Driver");
        if ( Success(res) )
        {
            Response["success"] = true;
            for ( auto const& entry : Value(res) )
            {
                std::wstring res = L"\\driver\\" + entry.first;
                Response["body"].push_back(CFB::Utils::ToString(res));
            }
        }
        else
        {
            Response["success"] = false;
        }
        break;
    }

    case CFB::Comms::RequestId::EnumerateDeviceObject:
    {
        auto res = CFB::Broker::Utils::EnumerateObjectDirectory(L"\\Device");
        if ( Success(res) )
        {
            Response["success"] = true;

            for ( auto const& entry : Value(res) )
            {
                std::wstring res = L"\\Device\\" + entry.first;
                Response["body"].push_back(CFB::Utils::ToString(res));
            }
        }
        else
        {
            Response["success"] = false;
        }
        break;
    }

    case CFB::Comms::RequestId::EnumerateMinifilterObject:
    {
        auto res = CFB::Broker::Utils::EnumerateObjectDirectory(L"\\FileSystem");
        if ( Success(res) )
        {
            Response["success"] = true;

            for ( auto const& entry : Value(res) )
            {
                std::wstring res = L"\\FileSystem\\" + entry.first;
                Response["body"].push_back(CFB::Utils::ToString(res));
            }
        }
        else
        {
            Response["success"] = false;
        }
        break;
    }

    case CFB::Comms::RequestId::GetPendingIrp:
    {
        auto msg = Request.get<CFB::Comms::DriverRequest>();
        if ( msg.NumberOfIrp == 0 )
        {
            Response["success"] = false;
            Response["reason"]  = "Invalid Parameter";
            break;
        }

        //
        //
        //
        auto res = Globals.ConnectorManager()->GetConnectorByName("JsonQueue");
        if ( Failed(res) )
        {
            Response["success"] = false;
            Response["reason"]  = "Cannot find connector";
            break;
        }

        auto const ConnBase = Value(res);
        auto const Conn     = reinterpret_cast<Connectors::JsonQueue*>(ConnBase.get());
        usize nb            = 0;
        while ( true )
        {
            std::unique_ptr<CFB::Comms::CapturedIrp> Irp = std::move(Conn->Pop());
            if ( !Irp )
            {
                break;
            }

            nb++;
            Response["body"].push_back(json(*Irp));
        }

        Response["success"]       = true;
        Response["number_of_irp"] = nb;
        break;
    }

    default:
        Response["success"] = false;
        Response["reason"]  = "Invalid Request ID";
        break;
    }

    // if ( RequestId != CFB::Comms::RequestId::GetPendingIrp )
    {
        info(
            "Request[%llu] %s => %s",
            m_RequestNumber,
            CFB::Utils::ToString(RequestId).c_str(),
            boolstr(Response["success"]));

        info("Request[%llu] => %s", m_RequestNumber, Response.dump().c_str());
    }

    return Ok(Response);
}


} // namespace CFB::Broker

```

`Broker/Source/DriverManagerListener.cpp`:

```cpp
#define CFB_NS "[CFB::Broker::DriverManager::TcpListener]"

// clang-format off
#include <winsock2.h>
#include <ws2tcpip.h>

#include <sstream>

#include "DriverManager.hpp"
#include "Context.hpp"
#include "Log.hpp"
#include "BrokerUtils.hpp"
// clang-format on

#define CFB_BROKER_TCP_LISTEN_HOST L"0.0.0.0"
#define CFB_BROKER_TCP_LISTEN_PORT 1337
#define CFB_BROKER_TCP_MAX_CONNECTIONS 16
#define CFB_BROKER_TCP_MAX_MESSAGE_SIZE 1024

static usize TotalClientCounter = 0;

namespace CFB::Broker
{

DriverManager::TcpListener::TcpListener() : m_ServerSocket(INVALID_SOCKET)
{
    WSADATA WsaData = {0};

    //
    // Start up the socket subsystem
    //
    {
        if ( ::WSAStartup(MAKEWORD(2, 2), &WsaData) )
        {
            CFB::Log::perror("DriverManager::TcpListener::WSAStartup()");
            throw std::runtime_error("TcpListener()");
        }

        if ( LOBYTE(WsaData.wVersion) != 2 || HIBYTE(WsaData.wVersion) != 2 )
        {
            err("WSA version check failed");
            throw std::runtime_error("TcpListener()");
        }
    }
}


DriverManager::TcpListener::~TcpListener()
{
    Terminate();
}


Result<bool>
DriverManager::TcpListener::Initialize()
{
    WSAPROTOCOL_INFOW info = {0};
    info.dwServiceFlags1 |= XP1_IFS_HANDLES;

    m_ServerSocket = ::WSASocketW(AF_INET, SOCK_STREAM, IPPROTO_TCP, nullptr, 0, WSA_FLAG_NO_HANDLE_INHERIT);
    if ( m_ServerSocket == INVALID_SOCKET )
    {
        CFB::Log::perror("WSASocket()");
        return Err(ErrorCode::SocketInitializationFailed);
    }

    return Ok(true);
}


Result<bool>
DriverManager::TcpListener::Listen()
{
    SOCKADDR_IN sa = {0};
    ::InetPtonW(AF_INET, CFB_BROKER_TCP_LISTEN_HOST, &sa.sin_addr.s_addr);

    sa.sin_family = AF_INET;
    sa.sin_port   = ::htons(CFB_BROKER_TCP_LISTEN_PORT);

    if ( ::bind(m_ServerSocket, (PSOCKADDR)&sa, sizeof(SOCKADDR_IN)) == SOCKET_ERROR )
    {
        CFB::Log::perror("TcpListener::Listen::bind()");
        Terminate();
        return Err(ErrorCode::SocketInitializationFailed);
    }

    if ( ::listen(m_ServerSocket, SOMAXCONN_HINT(CFB_BROKER_TCP_MAX_CONNECTIONS)) )
    {
        CFB::Log::perror("TcpListener::Listen::listen()");
        Terminate();
        return Err(ErrorCode::SocketInitializationFailed);
    }

    return Ok(true);
}


Result<bool>
DriverManager::TcpListener::Terminate()
{
    bool res = (::closesocket(m_ServerSocket) == 0);
    ::WSACleanup();
    return Ok(res);
}


bool
DriverManager::TcpListener::Reconnect()
{
    return Success(Terminate()) && Success(Initialize()) && Success(Listen());
}


int CALLBACK
ConditionAcceptFunc(
    LPWSABUF lpCallerId,
    LPWSABUF lpCallerData,
    LPQOS pQos,
    LPQOS lpGQOS,
    LPWSABUF lpCalleeId,
    LPWSABUF lpCalleeData,
    GROUP FAR* g,
    DWORD_PTR dwCallbackData)
{

    return CF_ACCEPT;
}


Result<std::shared_ptr<DriverManager::TcpClient>>
DriverManager::TcpListener::Accept()
{
    SOCKET ClientSocket        = INVALID_SOCKET;
    SOCKADDR_IN SockInfoClient = {0};
    INT dwSockInfoClientSize   = sizeof(SOCKADDR_IN);

    ClientSocket =
        ::WSAAccept(m_ServerSocket, (SOCKADDR*)&SockInfoClient, &dwSockInfoClientSize, ConditionAcceptFunc, 0);
    if ( ClientSocket == INVALID_SOCKET )
    {
        err("WSAAccept() failed with WSAGetLastError=%#x", ::WSAGetLastError());
        return Err(ErrorCode::SocketInitializationFailed);
    }

    char Ipv4AddressClient[16] = {0};
    ::InetNtopA(AF_INET, &SockInfoClient.sin_addr.s_addr, Ipv4AddressClient, _countof(Ipv4AddressClient));

    auto Client         = std::make_shared<TcpClient>();
    Client->m_Id        = ++TotalClientCounter;
    Client->m_Socket    = ClientSocket;
    Client->m_IpAddress = Ipv4AddressClient;
    Client->m_Port      = ::ntohs(SockInfoClient.sin_port);

    dbg("New TCP client %s:%d (hSocket=%#x)", Client->m_IpAddress.c_str(), Client->m_Port, Client->m_Socket);
    return Ok(Client);
}


Result<u32>
DriverManager::TcpClient::SendSynchronous(json const& js)
{
    if ( m_Socket == INVALID_SOCKET )
    {
        return Err(ErrorCode::UnexpectedStateError);
    }

    std::string data    = js.dump();
    DWORD dwNbSentBytes = 0, dwFlags = 0;
    WSABUF DataBuf = {0};
    DataBuf.len    = (DWORD)data.size();
    DataBuf.buf    = (char*)data.data();

    if ( ::WSASend(m_Socket, &DataBuf, 1, &dwNbSentBytes, dwFlags, nullptr, nullptr) == SOCKET_ERROR )
    {
        CFB::Log::perror("WSASend");
        return Err(ErrorCode::NetworkError);
    }

    return Ok(dwNbSentBytes);
}


Result<json>
DriverManager::TcpClient::ReceiveSynchronous()
{
    if ( m_Socket == INVALID_SOCKET )
    {
        return Err(ErrorCode::UnexpectedStateError);
    }

    auto ReceivedDataBuffer = std::make_unique<u8[]>(CFB_BROKER_TCP_MAX_MESSAGE_SIZE);
    RtlZeroMemory(ReceivedDataBuffer.get(), CFB_BROKER_TCP_MAX_MESSAGE_SIZE);
    DWORD dwNbRecvBytes = 0, dwFlags = 0;
    WSABUF DataBuf = {0};
    DataBuf.len    = CFB_BROKER_TCP_MAX_MESSAGE_SIZE;
    DataBuf.buf    = (char*)ReceivedDataBuffer.get();

    int recv_result = ::WSARecv(m_Socket, &DataBuf, 1, &dwNbRecvBytes, &dwFlags, NULL, NULL);
    if ( recv_result == SOCKET_ERROR )
    {
        //
        // check for overlapped data
        //
        if ( ::WSAGetLastError() != WSAEWOULDBLOCK )
        {
            CFB::Log::perror("WSARecv()");
            return Err(ErrorCode::NetworkError);
        }

        WSAOVERLAPPED Overlapped = {0};

        recv_result = ::WSARecv(m_Socket, &DataBuf, 1, &dwNbRecvBytes, &dwFlags, &Overlapped, NULL);
        if ( ::WSAGetLastError() != WSA_IO_PENDING )
        {
            CFB::Log::perror("ReceiveSynchronous::WSARecv(Pending)");
            return Err(ErrorCode::NetworkError);
        }

        //
        // we are in Overlapped I/O but the thread really needs the data from the client to proceed,
        // so just wait
        //
        while ( true )
        {
            dwFlags       = 0;
            DWORD dwIndex = ::WSAWaitForMultipleEvents(1, &Overlapped.hEvent, true, WSA_INFINITE, false);
            if ( dwIndex == WSA_WAIT_FAILED || !Overlapped.hEvent )
            {
                break;
            }
            ::WSAResetEvent(Overlapped.hEvent);
            ::WSAGetOverlappedResult(m_Socket, &Overlapped, &dwNbRecvBytes, false, &dwFlags);
            ZeroMemory(&Overlapped, sizeof(WSAOVERLAPPED));
            break;
        }
    }

    std::string s(ReceivedDataBuffer.get(), ReceivedDataBuffer.get() + dwNbRecvBytes);
    s.resize(dwNbRecvBytes);
    return json::parse(s);
}


u32
TcpClientRoutine(DriverManager::TcpClient& Client)
{
    DWORD dwRetCode = ERROR_SUCCESS;

    std::vector<HANDLE> handles;
    handles.push_back(Globals.TerminationEvent());

    //
    // Create the socket notification event for read, write and disconnection
    //
    wil::unique_handle hEvent(::WSACreateEvent());
    if ( !hEvent )
    {
        DWORD gle = ::WSAGetLastError();
        CFB::Log::perror("WSACreateEvent()");
        return SOCKET_ERROR;
    }

    if ( ::WSAEventSelect(Client.m_Socket, hEvent.get(), FD_READ | FD_WRITE | FD_CLOSE) == SOCKET_ERROR )
    {
        CFB::Log::perror("WSAEventSelect()");
        return SOCKET_ERROR;
    }

    handles.push_back(hEvent.get());

    while ( true )
    {
        DWORD dwIndex = ::WSAWaitForMultipleEvents((DWORD)handles.size(), handles.data(), false, INFINITE, false) -
                        WSA_WAIT_EVENT_0;

        if ( dwIndex < 0 || dwIndex >= handles.size() )
        {
            CFB::Log::perror("WSAWaitForMultipleEvents(TcpClient)");
            dwRetCode = ::WSAGetLastError();
            break;
        }

        //
        // reset the event
        //
        ::WSAResetEvent(handles.at(dwIndex));

        if ( dwIndex != 1 )
        {
            if ( dwIndex == 0 )
            {
                dbg("received termination event");
                Globals.Stop();
            }
            continue;
        }

        //
        // handle the data sent / recv
        //
        WSANETWORKEVENTS Events = {0};
        if ( ::WSAEnumNetworkEvents(Client.m_Socket, hEvent.get(), &Events) == SOCKET_ERROR )
        {
            err("WSAEnumNetworkEvents() failed with 0x%x", ::WSAGetLastError());
            continue;
        }

        if ( Events.lNetworkEvents & FD_CLOSE )
        {
            dwRetCode = ERROR_SUCCESS;
            break;
        }


        if ( (Events.lNetworkEvents & FD_READ) != FD_READ )
        {
            continue;
        }

        json Request, Response;

        Response["error_code"] = 0;

        //
        // 1. if here, process the requests
        //
        {
            try
            {
                auto res = Client.ReceiveSynchronous();

                if ( Failed(res) )
                {
                    warn("ReceiveSynchronous() failed with %x", Error(res).code);
                    continue;
                }

                Request = Value(res);
            }
            catch ( std::exception const& e )
            {
                err("EXCEPTION while reading request (bad JSON ?), dropping request: %s", e.what());
                Response["error_code"] = ErrorCode::InvalidInput;
            }
        }

        //
        // 2. let to the driver manager execute the command
        //
        if ( Response["error_code"] == 0 )
        {
            auto res = Globals.DriverManager()->ExecuteCommand(Request);
            if ( Failed(res) )
            {
                Response["error_code"] = Error(res).code;
            }
            else
            {
                Response["error_code"] = 0;
                Response["body"]       = Value(res);
            }
        }

        //
        // 3. send the response back
        //
        if ( Failed(Client.SendSynchronous(Response)) )
        {
            err("Failed to send response, leaving...");
            dwRetCode = ::GetLastError();
            break;
        }
    }

    return dwRetCode;
}


std::string
DriverManager::TcpListener::Name()
{
    return "DriverManager::TcpListener";
}


Result<u32>
DriverManager::TcpListener::RunForever()
{
    if ( Failed(Initialize()) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    if ( Failed(Listen()) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    DWORD retcode   = ERROR_SUCCESS;
    bool is_running = false;
    wil::unique_handle hNetworkEvent(::WSACreateEvent());
    if ( ::WSAEventSelect(m_ServerSocket, hNetworkEvent.get(), FD_ACCEPT) == SOCKET_ERROR )
    {
        CFB::Log::perror("DriverManager::TcpListener::RunForever::WSAEventSelect()");
        return ::WSAGetLastError();
    }

    is_running = true;

    while ( is_running )
    {
        //
        // Collect all events/handles to wait on
        //
        std::vector<HANDLE> Handles {Globals.TerminationEvent(), hNetworkEvent.get()};

        for ( auto const& cli : m_Clients )
        {
            Handles.push_back(cli->m_hThread.get());
        }

        std::stringstream ss;
        for ( auto const& h : Handles )
            ss << h << ", ";
        dbg("Waiting for events on %s", ss.str().c_str());

        //
        // Wait for an event either of termination, from the network or any client thread
        //
        DWORD ret = ::WSAWaitForMultipleEvents((DWORD)Handles.size(), Handles.data(), false, WSA_INFINITE, false);

        if ( ret == WSA_WAIT_FAILED || ret == WSA_WAIT_TIMEOUT )
        {
            CFB::Log::perror("DriverManager::TcpListener::RunForever::WSAWaitForMultipleEvents()");
            Globals.Stop();
            break;
        }

        DWORD dwIndex = ret - WSA_WAIT_EVENT_0;

        switch ( dwIndex )
        {
        case 0:
            dbg("[TcpListener] Global stop requested...");
            is_running = false;
            break;

        case 1:
        {
            ::WSAResetEvent(hNetworkEvent.get());

            WSANETWORKEVENTS Events = {0};
            ::WSAEnumNetworkEvents(m_ServerSocket, hNetworkEvent.get(), &Events);

            if ( Events.lNetworkEvents & FD_CLOSE )
            {
                //
                // if it's a TCP_CLOSE, find the client from the handle, and terminate it
                //
                const HANDLE hTarget    = Handles.at(dwIndex);
                auto FindClientByHandle = [&hTarget](auto const& cli) -> bool
                {
                    return cli->m_hThread.get() == hTarget;
                };

                auto erased = std::erase_if(m_Clients, FindClientByHandle);
                if ( erased != 1 )
                {
                    err("[TCP_CLOSE] Unexpected size for found client");
                }
                break;
            }

            if ( Events.lNetworkEvents & FD_ACCEPT )
            {
                //
                // it's a TCP_SYN, so accept the connection and spawn the thread handling the requests
                //
                std::shared_ptr<TcpClient> Client;
                {
                    auto res = Accept();
                    if ( Failed(res) )
                    {
                        break;
                    }

                    Client = Value(res);
                }

                //
                // start a thread to handle the new connection
                //
                {
                    DWORD dwThreadId;
                    wil::unique_handle hThread(::CreateThread(
                        nullptr,
                        0,
                        (LPTHREAD_START_ROUTINE)TcpClientRoutine,
                        Client.get(),
                        THREAD_CREATE_FLAGS_CREATE_SUSPENDED,
                        reinterpret_cast<LPDWORD>(&dwThreadId)));
                    if ( !hThread )
                    {
                        CFB::Log::perror("CreateThread(TcpClientRoutine)");
                        break;
                    }

                    Client->m_hThread  = std::move(hThread);
                    Client->m_ThreadId = dwThreadId;
                }


                ok("Adding TcpClient(\"%s:%d\", hThread=%#x) to client pool",
                   Client->m_IpAddress.c_str(),
                   Client->m_Port,
                   Client->m_hThread);

                ::ResumeThread(Client->m_hThread.get());
                m_Clients.push_back(Client);
                break;
            }

            err("RunForever::WSAEnumNetworkEvents(): unknown network event value %.08x", Events.lNetworkEvents);
            break;
        }

        default:
            //
            // if here, we've received the event of EOL from the client thread, so we clean up and continue looping
            //
            const HANDLE hThread = Handles.at(dwIndex);
            dbg("Handling event_index=%d, thread_handle=%p", dwIndex, hThread);

            //
            // Delete the entry in the client list
            //
            {
                auto FindClientByHandle = [&hThread](auto const& cli) -> bool
                {
                    return (cli->m_hThread.get() == hThread);
                };

                auto const erased = std::erase_if(m_Clients, FindClientByHandle);
                if ( erased != 1 )
                {
                    warn("Unexpected size for found client, erased_nb = %d", erased);
                }
            }
        }
    }

    return retcode;
}


DriverManager::TcpClient::~TcpClient()
{
    dbg("Terminating TcpClient(Id=%d, TID=%d)", m_Id, m_ThreadId);
    ::closesocket(m_Socket);
}


std::string
DriverManager::TcpClient::Name()
{
    return "DriverManager::TcpClient";
}


} // namespace CFB::Broker

```

`Broker/Source/IrpManager.cpp`:

```cpp
#define CFB_NS "[CFB::Broker::IrpManager]"

#include "IrpManager.hpp"

#include <chrono>
#include <thread>

#include "Context.hpp"
#include "IoctlCodes.hpp"
#include "Log.hpp"
#include "Messages.hpp"
#include "Utils.hpp"


using namespace std::literals::chrono_literals;


namespace CFB::Broker
{
IrpManager::IrpManager()
{
    //
    // Create the event shared with the driver to get new IRPs notifications
    //
    {
        wil::unique_handle hEvent(::CreateEventW(nullptr, true, false, nullptr));
        if ( !hEvent )
        {
            CFB::Log::perror("IrpManager::CreateEventW()");
            throw std::runtime_error("IrpManager()");
        }

        dbg("Got handle to event %x", hEvent.get());
        m_hNewIrpEvent = std::move(hEvent);
    }
}


IrpManager::~IrpManager()
{
}


std::string const
IrpManager::Name()
{
    return "IrpManager";
}


Result<bool>
IrpManager::Setup()
{
    //
    // Wait for the service to be ready
    //
    WaitForState(CFB::Broker::State::ServiceManagerReady);

    //
    // Get a handle to the driver
    //
    {
        wil::unique_handle hDevice(::CreateFileW(
            CFB_USER_DEVICE_PATH,
            GENERIC_READ,
            FILE_SHARE_READ,
            nullptr,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            nullptr));
        if ( !hDevice )
        {
            CFB::Log::perror("IrpManager::CreateFileW()");
            return Err(ErrorCode::InitializationError);
        }
        m_hDevice = std::move(hDevice);
    }
    dbg("Got handle %x to device %S", m_hDevice.get(), CFB_USER_DEVICE_PATH);

    //
    // Share the notification event with the driver
    //
    {
        DWORD dwNbBytesReturned;
        const HANDLE hTarget = m_hNewIrpEvent.get();

        if ( ::DeviceIoControl(
                 m_hDevice.get(),
                 static_cast<std::underlying_type<CFB::Comms::Ioctl>::type>(CFB::Comms::Ioctl::SetEventPointer),
                 (LPVOID)&hTarget,
                 sizeof(hTarget),
                 nullptr,
                 0,
                 &dwNbBytesReturned,
                 nullptr) == false )
        {
            CFB::Log::perror("DeviceIoControl()");
            return Err(ErrorCode::InitializationError);
        }
    }
    dbg("Event shared with driver");

    //
    // Notify other threads that the IRP Manager is ready
    //
    SetState(CFB::Broker::State::IrpManagerReady);

    return Ok(true);
}


void
IrpManager::Run()
{
    //
    // Wait for the collector manager to be ready so we can
    // start collecting IRPs
    //
    WaitForState(CFB::Broker::State::Running);

    info("Waiting for intercepted IRP...");

    //
    // The IRP Manager waits for either a termination event or a new IRP event
    //
    const HANDLE Handles[2] = {Globals.TerminationEvent(), m_hNewIrpEvent.get()};
    bool bDoLoop            = true;
    while ( bDoLoop )
    {
        DWORD dwWaitResult = ::WaitForMultipleObjects(_countof(Handles), Handles, false, INFINITE);
        switch ( dwWaitResult )
        {
        case WAIT_OBJECT_0 + 0:
        {
            dbg("Received termination event");
            bDoLoop = false;
            break;
        }
        case WAIT_OBJECT_0 + 1:
        {
            dbg("Received new IRP data event");

            for ( auto const& Irp : GetNextIrps() )
            {
                //
                // For each new IRP, pass it on to the ConnectorManager
                //
                if ( !m_CallbackDispatcher )
                {
                    warn("No connector callback dispatcher registered");
                    break;
                }

                m_CallbackDispatcher(Irp);
            }
            break;
        }
        default:
        {
            err("WaitForMultipleObjects() returned %x", dwWaitResult);
            bDoLoop = false;
            break;
        }
        }
    }

    //
    // Finish the IRP manager thread
    //
    SetState(CFB::Broker::State::IrpManagerDone);
}


std::vector<CFB::Comms::CapturedIrp>
IrpManager::GetNextIrps()
{
    std::vector<CFB::Comms::CapturedIrp> Irps {};
    std::unique_ptr<u8[]> RawData;
    DWORD dataLength = 1;

    //
    // Poll data matching length requirement
    //
    while ( true )
    {
        DWORD nbDataRead = 0;
        RawData          = std::make_unique<u8[]>(dataLength);
        bool bRes        = ::ReadFile(m_hDevice.get(), RawData.get(), dataLength, &nbDataRead, nullptr);
        if ( bRes )
        {
            dbg("%uB data fetched, %uB allocated", nbDataRead, dataLength);
            dataLength = nbDataRead;
            break;
        }

        if ( ::GetLastError() == ERROR_INSUFFICIENT_BUFFER )
        {
            dataLength *= 2;
            continue;
        }

        CFB::Log::perror("ReadFile() failed");
        ::ResetEvent(m_hNewIrpEvent.get());
        return {};
    }

    if ( dataLength < sizeof(CFB::Comms::CapturedIrpHeader) )
    {
        warn("Event was set but not enough data was fetched");
        ::ResetEvent(m_hNewIrpEvent.get());
        return {};
    }

    //
    // Parse it
    //
    {
        usize offset = 0;

        while ( offset < dataLength )
        {
            auto const Header = reinterpret_cast<CFB::Comms::CapturedIrpHeader*>(RawData.get() + offset);
            dbg("Parsing from offset %d", offset);

            if ( offset + sizeof(CFB::Comms::CapturedIrpHeader) > dataLength )
            {
                warn(
                    "Out-of-bound Header access: offset=%llu + sizeof(header)=%llu, dataLength=%llu ",
                    offset,
                    sizeof(CFB::Comms::CapturedIrpHeader),
                    dataLength);
                break;
            }

            CFB::Comms::CapturedIrp Irp {};
            Irp.Header.TimeStamp          = Header->TimeStamp;
            Irp.Header.Irql               = Header->Irql;
            Irp.Header.Type               = Header->Type;
            Irp.Header.MajorFunction      = Header->MajorFunction;
            Irp.Header.MinorFunction      = Header->MinorFunction;
            Irp.Header.IoctlCode          = Header->IoctlCode;
            Irp.Header.Pid                = Header->Pid;
            Irp.Header.Tid                = Header->Tid;
            Irp.Header.Status             = Header->Status;
            Irp.Header.InputBufferLength  = Header->InputBufferLength;
            Irp.Header.OutputBufferLength = Header->OutputBufferLength;
            ::memcpy(Irp.Header.DriverName, Header->DriverName, sizeof(Header->DriverName));
            ::memcpy(Irp.Header.DeviceName, Header->DeviceName, sizeof(Header->DeviceName));
            ::memcpy(Irp.Header.ProcessName, Header->ProcessName, sizeof(Header->ProcessName));
            offset += sizeof(CFB::Comms::CapturedIrpHeader);

            if ( offset + Irp.Header.InputBufferLength <= dataLength )
            {
                auto const InputBuffer = RawData.get() + offset;
                Irp.InputBuffer.resize(Irp.Header.InputBufferLength);
                ::memcpy(Irp.InputBuffer.data(), InputBuffer, Irp.Header.InputBufferLength);
                offset += Irp.Header.InputBufferLength;
            }

            if ( offset + Irp.Header.OutputBufferLength <= dataLength )
            {
                auto const OutputBuffer = RawData.get() + offset;
                Irp.OutputBuffer.resize(Irp.Header.OutputBufferLength);
                ::memcpy(Irp.OutputBuffer.data(), OutputBuffer, Irp.Header.OutputBufferLength);
                offset += Irp.Header.OutputBufferLength;
            }

            dbg("New IRP (DeviceName='%S', Type=%s, InputBufferLength=%u, OutputBufferLength=%u) pushed to queue",
                Irp.Header.DeviceName,
                CFB::Utils::IrpMajorToString(Irp.Header.MajorFunction),
                Irp.Header.InputBufferLength,
                Irp.Header.OutputBufferLength);

            Irps.push_back(std::move(Irp));
        }
    }

    dbg("%d IRPs pulled from driver", Irps.size());

    //
    // Reset the event
    //
    ::ResetEvent(m_hNewIrpEvent.get());

    return Irps;
}


bool
IrpManager::SetCallback(std::function<bool(CFB::Comms::CapturedIrp const&)> cb)
{
    std::scoped_lock(m_CallbackLock);
    m_CallbackDispatcher = cb;
    dbg("Callback %p added", cb);
    return true;
}
} // namespace CFB::Broker

```

`Broker/Source/Main.cpp`:

```cpp
#define NOMINMAX
#undef _UNICODE
#undef UNICODE

// clang-format off
#include <windows.h>

#include <iostream>
#include <string>
#include <vector>

#include <argparse/argparse.hpp>
#include <wil/resource.h>

#include "Broker.hpp"
#include "Common.hpp"
#include "BrokerUtils.hpp"
#include "Context.hpp"
#include "Log.hpp"
// clang-format on

using namespace ::std::literals;

struct GlobalContext Globals;


static bool
CtrlHandler(const DWORD dwCtrlType)
{
    switch ( dwCtrlType )
    {
    case CTRL_CLOSE_EVENT:
    case CTRL_C_EVENT:
        dbg("Received Ctrl-C event, stopping...");
        Globals.Stop();
        return true;

    default:
        break;
    }

    return false;
}


int
main(int argc, const char** argv)
{
    argparse::ArgumentParser program("Broker");

    const std::vector<std::string> valid_modes = {"run-standalone", "install-service", "run-as-service"};
    program.add_argument("mode")
        .remaining()
        .default_value(valid_modes.front())
        .action(
            [&valid_modes](const std::string& value)
            {
                if ( std::find(valid_modes.cbegin(), valid_modes.cend(), value) != valid_modes.cend() )
                {
                    return value;
                }
                return valid_modes.front();
            });

    try
    {
        program.parse_args(argc, argv);
    }
    catch ( const std::runtime_error& err )
    {
        std::cerr << err.what() << std::endl;
        std::cerr << program;
        std::exit(1);
    }

    if ( Failed(CFB::Broker::Utils::AcquirePrivileges({L"SeDebugPrivilege", L"SeLoadDriverPrivilege"})) )
    {
        err("Cannot required privileged, cannot continue");
        std::exit(-2);
    }


    auto const& mode = program.get<std::string>("mode");

    if ( mode == "run-standalone" )
    {
        info("Running in standalone...");
        ::SetConsoleCtrlHandler((PHANDLER_ROUTINE)CtrlHandler, true);
        ::WaitForSingleObject(Globals.TerminationEvent(), INFINITE);
    }

    else if ( mode == "install-service" )
    {
        Globals.ServiceManager()->InstallBackgroundService();
    }

    else if ( mode == "run-as-service" )
    {
        Globals.ServiceManager()->RunAsBackgroundService();
    }

    return 0;
}

```

`Broker/Source/ManagerBase.cpp`:

```cpp
#define CFB_NS "[CFB::Broker::ManagerBase]"

#include "ManagerBase.hpp"

#include <thread>

#include "Context.hpp"
#include "Log.hpp"

namespace CFB::Broker
{

ManagerBase::ManagerBase() : m_bIsShuttingDown(false)
{
    {
        wil::unique_handle hEvent(::CreateEventW(nullptr, true, false, nullptr));
        if ( !hEvent )
        {
            CFB::Log::perror("CreateEventW(StateChanged)");
            throw std::runtime_error("ManagerBase::CreateEvent() failed, cannot continue");
        }

        m_hChangedStateEvent = std::move(hEvent);
    }

    {
        wil::unique_handle hEvent(::CreateEventW(nullptr, true, false, nullptr));
        if ( !hEvent )
        {
            CFB::Log::perror("CreateEventW(TerminationEvent)");
            throw std::runtime_error("ManagerBase::CreateEvent() failed, cannot continue");
        }

        m_hTerminationEvent = std::move(hEvent);
    }
}


ManagerBase::~ManagerBase()
{
}


bool
ManagerBase::WaitForState(CFB::Broker::State WantedState)
{
    const HANDLE handles[] = {m_hChangedStateEvent.get(), m_hTerminationEvent.get()};

    while ( true )
    {
        const CFB::Broker::State CurrentState = Globals.State();

        //
        // if the wanted state current or already, leave
        //
        if ( CurrentState >= WantedState )
        {
            break;
        }

        info("Waiting for state '%s' (current '%s')", Utils::ToString(WantedState), Utils::ToString(CurrentState));

        //
        // Otherwise wait to be signaled
        //
        DWORD dwIndex = ::WaitForMultipleObjects(countof(handles), handles, false, 10'000);

        if ( dwIndex == WAIT_TIMEOUT )
        {
            continue;
        }

        if ( handles[dwIndex] == m_hTerminationEvent.get() )
        {
            break;
        }

        if ( handles[dwIndex] == m_hChangedStateEvent.get() )
        {
            m_bIsShuttingDown = true;
            break;
        }

        CFB::Log::perror("ManagerBase::WaitForState::WaitForSingleObject");
        return false;
    }

    return true;
}


bool
ManagerBase::SetState(CFB::Broker::State NewState)
{
    info("Notifying state change '%s' -> '%s'", Utils::ToString(Globals.State()), Utils::ToString(NewState));

    auto bRes = Globals.SetState(NewState);
    return bRes;
}


bool
ManagerBase::NotifyStateChange()
{
    auto bRes = ::SetEvent(m_hChangedStateEvent.get());
    if ( false == bRes )
    {
        CFB::Log::perror("ManagerBase::NotifyStateChange::SetEvent");
    }
    return bRes;
}

bool
ManagerBase::NotifyTermination()
{
    auto bRes = ::SetEvent(m_hTerminationEvent.get());
    if ( false == bRes )
    {
        CFB::Log::perror("ManagerBase::NotifyTermination::SetEvent");
    }
    return bRes;
}


} // namespace CFB::Broker

```

`Broker/Source/ServiceManager.cpp`:

```cpp
#define CFB_NS "[CFB::Broker::ServiceManager]"
#include "ServiceManager.hpp"

#include "Context.hpp"
#include "Log.hpp"
#include "Resource.h"


///
/// @brief
///
/// This class manages the IrpDumper driver stored in the PE resource section, and
/// defines all the functions to properly:
///
/// - extract the driver to disk
/// - create / delete the service
/// - load / unload the driver
/// - delete the PE file from disk
///
///
/// CFB can also be installed as a process service to facilitate automation, using sc.exe:
///     sc.exe create CFB_Broker binPath= "\path\to\Broker.exe --service" DisplayName= "Furious Beaver process service"
///
/// Then can be manipulated with the usual `sc start/stop`, and uninstalled with `sc delete`
///


namespace CFB::Broker
{
///
/// @brief Static handler that updates the service control manager's status information
///
/// @param dwCtrlCode
/// @return VOID
///
static VOID
ServiceCtrlHandler(const DWORD dwCtrlCode);

///
/// Static routine to initialize the own process service.
///
static VOID
ServiceMain(DWORD argc, LPWSTR* argv);


ServiceManager::ServiceManager() :
    m_BackgroundService(nullptr),
    m_DriverTempPath(fs::temp_directory_path() / CFB_DRIVER_BASENAME)
{
}


ServiceManager::~ServiceManager()
{
    if ( UnloadDriver() == false )
    {
        err("UnloadDriver() failed");
    }

    if ( DeleteDriverFromDisk() == false )
    {
        err("DeleteDriverFromDisk() failed");
    }
}

Result<bool>
ServiceManager::Setup()
{
    if ( ExtractDriverFromResource() == false )
    {
        err("ExtractDriverFromResource() failed");
        return Err(ErrorCode::InitializationError);
    }

    if ( LoadDriver() == false )
    {
        err("LoadDriver() failed");
        return Err(ErrorCode::InitializationError);
    }

    //
    // Notify other thread the driver service is ready
    //
    SetState(CFB::Broker::State::ServiceManagerReady);

    return Ok(true);
}


void
ServiceManager::Run()
{
    WaitForState(CFB::Broker::State::Running);

    //
    // Simply wait for the other managers to be done
    //
    WaitForState(CFB::Broker::State::IrpManagerDone);
}


std::string const
ServiceManager::Name()
{
    return "ServiceManager";
}


std::shared_ptr<Win32Service>
ServiceManager::BackgroundService()
{
    return m_BackgroundService;
}


bool
ServiceManager::ExtractDriverFromResource()
{
    dbg("Extracting driver from resources...");

    HRSRC DriverRsc = ::FindResourceW(nullptr, MAKEINTRESOURCEW(IDR_CFB_DRIVER), MAKEINTRESOURCEW(CFB_DRIVER_DATAFILE));
    if ( !DriverRsc )
    {
        CFB::Log::perror("FindResource()");
        return false;
    }

    DWORD dwDriverSize = ::SizeofResource(nullptr, DriverRsc);
    if ( !dwDriverSize )
    {
        CFB::Log::perror("SizeofResource()");
        return false;
    }

    HGLOBAL hgDriverRsc = ::LoadResource(nullptr, DriverRsc);
    if ( !hgDriverRsc )
    {
        CFB::Log::perror("LoadResource()");
        return false;
    }

    dbg("Dumping driver to '%S'", m_DriverTempPath.c_str());

    wil::unique_handle hDriverFile(::CreateFileW(
        m_DriverTempPath.c_str(),
        GENERIC_WRITE,
        0,
        nullptr,
        CREATE_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        nullptr));
    if ( !hDriverFile )
    {
        CFB::Log::perror("CreateFile()");
        return false;
    }

    DWORD dwWritten;
    if ( !::WriteFile(hDriverFile.get(), hgDriverRsc, dwDriverSize, &dwWritten, nullptr) )
    {
        CFB::Log::perror("WriteFile()");
        return false;
    }

    if ( dwWritten != dwDriverSize )
    {
        err("Incomplete driver file dump");
        return false;
    }

    dbg("Driver written in '%S'", m_DriverTempPath.c_str());
    return true;
}


bool
ServiceManager::DeleteDriverFromDisk()
{
    return m_DriverTempPath.remove_filename().has_filename() == false;
}


bool
ServiceManager::LoadDriver()
{
    dbg("Loading driver '%S'", m_DriverTempPath.c_str());

    //
    // Get a handle to the service control manager
    //
    {
        wil::unique_schandle hSCManager(::OpenSCManagerW(L"", SERVICES_ACTIVE_DATABASEW, SC_MANAGER_CREATE_SERVICE));
        if ( !hSCManager )
        {
            CFB::Log::perror("OpenSCManager()");
            return false;
        }

        m_hSCManager = std::move(hSCManager);
    }

    //
    // Get a handle to the service manager
    //
    {
        wil::unique_schandle hServiceCreate(::CreateServiceW(
            m_hSCManager.get(),
            CFB_BROKER_DRIVER_SERVICE_NAME,
            CFB_BROKER_DRIVER_SERVICE_DESCRIPTION,
            SERVICE_START | DELETE | SERVICE_STOP,
            SERVICE_KERNEL_DRIVER,
            SERVICE_DEMAND_START,
            SERVICE_ERROR_IGNORE,
            m_DriverTempPath.c_str(),
            nullptr,
            nullptr,
            nullptr,
            nullptr,
            nullptr));
        if ( !hServiceCreate )
        {
            if ( ::GetLastError() != ERROR_SERVICE_EXISTS )
            {
                //
                // Failure can mean the service already registered, if so just open it simply get a handle to it
                //
                CFB::Log::perror("CreateService()");
                return false;
            }
        }

        //
        // Try to open the service instead
        //
        wil::unique_schandle hServiceOpen(
            ::OpenServiceW(m_hSCManager.get(), CFB_BROKER_DRIVER_SERVICE_NAME, SERVICE_START | DELETE | SERVICE_STOP));
        {
            if ( !hServiceOpen )
            {
                CFB::Log::perror("OpenService()");
                return false;
            }
        }

        m_hService = std::move(hServiceOpen);
    }

    //
    // Start the service
    //
    dbg("Starting service '%S'", CFB_BROKER_DRIVER_SERVICE_NAME);

    if ( !::StartServiceW(m_hService.get(), 0, nullptr) )
    {
        CFB::Log::perror("StartService()");
        return false;
    }

    ok("Service '%S' started successfully.", CFB_BROKER_DRIVER_SERVICE_NAME);
    return true;
}


bool
ServiceManager::UnloadDriver()
{
    SERVICE_STATUS ServiceStatus = {0};

    dbg("Stopping service '%S'", CFB_BROKER_DRIVER_SERVICE_NAME);

    if ( !::ControlService(m_hService.get(), SERVICE_CONTROL_STOP, &ServiceStatus) )
    {
        CFB::Log::perror("ControlService()");
        return false;
    }

    dbg("Service '%S' stopped", CFB_BROKER_DRIVER_SERVICE_NAME);

    if ( !::DeleteService(m_hService.get()) )
    {
        CFB::Log::perror("DeleteService()");
        return false;
    }

    return true;
}


bool
ServiceManager::InstallBackgroundService()
{
    //
    // [1] Create the Win32 service
    //
    auto BrokerPath = Globals.Path();

    {
        const std::wstring BinaryPathName = L"\"" + BrokerPath.wstring() + L" service\"";

        wil::unique_handle hService(::CreateServiceW(
            m_hSCManager.get(),
            CFB_BROKER_WIN32_SERVICE_NAME,
            CFB_BROKER_WIN32_SERVICE_DESCRIPTION,
            SERVICE_ALL_ACCESS,
            SERVICE_WIN32_OWN_PROCESS,
            SERVICE_DEMAND_START,
            SERVICE_ERROR_NORMAL,
            BinaryPathName.c_str(),
            nullptr,
            nullptr,
            nullptr,
            nullptr,
            nullptr));
        if ( !hService )
        {
            CFB::Log::perror("CreateServiceW()");
            return false;
        }
    }

    return true;
}


bool
ServiceManager::RunAsBackgroundService()
{
    //
    // [1] Declare the win32 service mode to the global context
    //
    {
        try
        {
            m_BackgroundService = std::make_shared<Win32Service>();
        }
        catch ( ... )
        {
            return false;
        }
    }

    //
    // [2] Start the service through the SCM
    //
    {
        auto lpswServiceName = (LPWSTR)CFB_BROKER_WIN32_SERVICE_NAME;

        SERVICE_TABLE_ENTRYW ServiceTable[] = {
            {lpswServiceName, (LPSERVICE_MAIN_FUNCTIONW)ServiceMain},
            {nullptr, nullptr}};

        if ( !::StartServiceCtrlDispatcherW(ServiceTable) )
        {
            CFB::Log::perror("StartServiceCtrlDispatcherW()");
            return false;
        }
    }

    return true;
}


///////////////////////////////////////////////////////////////
///
/// Methods related to the Win32 service
///

Win32Service::Win32Service() : m_State(ServiceState::Uninitialized), m_StatusHandle(), m_StatusCheckPoint(0)
{
    dbg("Initializing background service");

    m_ServiceStateChangedEvent = ::CreateEventW(nullptr, true, false, nullptr);
    if ( !m_ServiceStateChangedEvent )
    {
        CFB::Log::perror("CreateEvent()");
        throw std::runtime_error("Win32Service() failed");
    }

    //
    // Register the controller, and get the service status handle
    //
    {
        SERVICE_STATUS_HANDLE hServiceStatus = ::RegisterServiceCtrlHandlerW(L"", ServiceCtrlHandler);
        if ( !hServiceStatus )
        {
            CFB::Log::perror("RegisterServiceCtrlHandler()");
            throw std::runtime_error("Win32Service() failed");
        }

        m_StatusHandle = hServiceStatus;
    }

    //
    // Set the service in a start pending state
    //
    {
        SERVICE_STATUS ServiceStatus            = {0};
        ServiceStatus.dwServiceType             = SERVICE_WIN32_OWN_PROCESS;
        ServiceStatus.dwControlsAccepted        = 0;
        ServiceStatus.dwCurrentState            = SERVICE_START_PENDING;
        ServiceStatus.dwWin32ExitCode           = 0;
        ServiceStatus.dwServiceSpecificExitCode = 0;
        ServiceStatus.dwCheckPoint              = 0;

        if ( ReportServiceStatus(&ServiceStatus) == false )
        {
            throw std::runtime_error("Win32Service() failed");
        }
    }

    //
    // Mark the service as running
    //
    {
        SERVICE_STATUS ServiceStatus     = {0};
        ServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;
        ServiceStatus.dwCurrentState     = SERVICE_RUNNING;
        ServiceStatus.dwWin32ExitCode    = 0;
        ServiceStatus.dwCheckPoint       = 0;

        if ( ReportServiceStatus(&ServiceStatus) == false )
        {
            throw std::runtime_error("Win32Service() failed");
        }
    }
}


Win32Service::~Win32Service()
{
    dbg("Terminating background service");
}


void
Win32Service::RunForever()
{
    //
    // Wait to be in a shutdown state
    //
    while ( true )
    {
        DWORD bRes = ::WaitForSingleObject(m_ServiceStateChangedEvent, INFINITE);
        if ( bRes == WAIT_OBJECT_0 )
        {
            auto lock = std::scoped_lock(m_Mutex);
            if ( m_State == ServiceState::ShuttingDown )
            {
                break;
            }
        }
    }

    //
    // Finish by notifying the manager
    //
    {
        SERVICE_STATUS ServiceStatus     = {0};
        ServiceStatus.dwControlsAccepted = 0;
        ServiceStatus.dwCurrentState     = SERVICE_STOPPED;
        ServiceStatus.dwWin32ExitCode    = 0;
        ServiceStatus.dwCheckPoint       = 3;

        if ( ReportServiceStatus(&ServiceStatus) == false )
        {
            CFB::Log::perror("SetServiceStatus() failed");
        }
    }
}


bool
Win32Service::Notify(ServiceState NewState)
{
    {
        auto lock = std::scoped_lock(m_Mutex);
        m_State   = NewState;
    }

    if ( false == ::SetEvent(m_ServiceStateChangedEvent) )
    {
        CFB::Log::perror("SetEvent()");
        return false;
    }

    return true;
}


bool
Win32Service::Stop()
{
    SERVICE_STATUS ServiceStatus     = {0};
    ServiceStatus.dwControlsAccepted = 0;
    ServiceStatus.dwCurrentState     = SERVICE_STOP_PENDING;
    ServiceStatus.dwWin32ExitCode    = 0;
    ServiceStatus.dwCheckPoint       = 4;

    if ( ReportServiceStatus(&ServiceStatus) == false )
    {
        CFB::Log::perror("SetServiceStatus()");
        return false;
    }

    return true;
}


bool
Win32Service::ReportServiceStatus(LPSERVICE_STATUS lpServiceStatus)
{
    if ( !::SetServiceStatus(m_StatusHandle, lpServiceStatus) )
    {
        CFB::Log::perror("SetServiceStatus()");
        return false;
    }

    ServiceState NewState;

    switch ( lpServiceStatus->dwCurrentState )
    {
    case SERVICE_START_PENDING:
        NewState = ServiceState::Initialized;
        break;

    case SERVICE_RUNNING:
        NewState = ServiceState::Running;
        break;

    case SERVICE_STOP_PENDING:
        NewState = ServiceState::ShuttingDown;
        break;

    default:
        err("Unknown state");
        return false;
    }

    if ( !Notify(NewState) )
    {
        return false;
    }

    return true;
}


bool
Win32Service::InitializeRoutine()
{
    //
    // Expect the state to be `Uninitialized`, otherwise just bail
    //
    if ( m_State != ServiceState::Uninitialized )
    {
        warn("Invalid state");
        return false;
    }


    return true;
}


static VOID
ServiceMain(DWORD argc, LPWSTR* argv)
{
    if ( Globals.ServiceManager() == nullptr )
    {
        return;
    }

    auto svc = Globals.ServiceManager()->BackgroundService();
    if ( svc == nullptr )
    {
        warn("Trying to execute the service handler when no service exists...");
        return;
    }

    svc->RunForever();

    dbg("%S background service ready, starting thread...", CFB_BROKER_WIN32_SERVICE_NAME);
    return;
}


static VOID
ServiceCtrlHandler(const DWORD dwCtrlCode)
{
    if ( Globals.ServiceManager() == nullptr )
    {
        return;
    }

    auto svc = Globals.ServiceManager()->BackgroundService();
    if ( svc == nullptr )
    {
        warn("Trying to execute the service handler when no service exists...");
        return;
    }

    switch ( dwCtrlCode )
    {
    case SERVICE_CONTROL_STOP:
        svc->Stop();
        break;

    case SERVICE_CONTROL_CONTINUE:
        warn("Unhandled control code: SERVICE_CONTROL_CONTINUE");
        break;

    case SERVICE_CONTROL_INTERROGATE:
        warn("Unhandled control code: SERVICE_CONTROL_INTERROGATE");
        break;

    case SERVICE_CONTROL_PAUSE:
        warn("Unhandled control code: SERVICE_CONTROL_PAUSE");
        break;

    case SERVICE_CONTROL_SHUTDOWN:
        warn("Unhandled control code: SERVICE_CONTROL_SHUTDOWN");
        break;

    default:
        break;
    }

    return;
}

} // namespace CFB::Broker

```

`Broker/Tests/CMakeLists.txt`:

```txt
message(STATUS "Configuring tests for 'Broker'")

enable_testing()

set(BROKER_HEADERS_DIR ${CFB_ROOT_DIR}/Broker/Headers)
set(BROKER_TEST_DIR ${CFB_ROOT_DIR}/Broker/Tests)

set(TEST_SET
)

foreach(TEST_FILE ${TEST_SET})
    set(FILEPATH "${BROKER_TEST_DIR}/${TEST_FILE}.cpp")
    set(TARGET_NAME Tests_Broker_${TEST_FILE})
    add_executable(${TARGET_NAME} WIN32 ${FILEPATH})
    list(APPEND ALL_BROKER_TESTS ${TARGET_NAME})
    add_dependencies(${TARGET_NAME} CFB::User::Broker)
    set_target_properties(${TARGET_NAME} PROPERTIES CXX_STANDARD 20)
    target_compile_features(${TARGET_NAME} PUBLIC cxx_std_20)
    target_include_directories(${TARGET_NAME} PUBLIC ${BROKER_HEADERS_DIR})
    target_compile_definitions(${TARGET_NAME} PRIVATE CATCH_CONFIG_NO_WINDOWS_SEH)
    target_compile_options(${TARGET_NAME} PRIVATE $<TARGET_PROPERTY:CFB::User::CommonLib,COMPILE_OPTIONS>)
    target_link_libraries(${TARGET_NAME} PRIVATE Catch2::Catch2 Catch2::Catch2WithMain)
    target_link_options(${TARGET_NAME} PRIVATE /SUBSYSTEM:Console $<TARGET_PROPERTY:CFB::User::CommonLib,LINK_OPTIONS>)
    add_test(NAME ${TARGET_NAME} COMMAND $<TARGET_FILE:${TARGET_NAME}>)
    install(TARGETS ${TARGET_NAME} DESTINATION Tests/Broker)
    install(FILES $<TARGET_PDB_FILE:${TARGET_NAME}> DESTINATION Tests/Broker OPTIONAL)
endforeach()

add_custom_target(
    Tests_Broker
    DEPENDS ${ALL_BROKER_TESTS}
    COMMAND ${CMAKE_CTEST_COMMAND} -R Tests_Broker
)

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.20)
set(CMAKE_CXX_STANDARD 20)

set(CMAKE_CXX_STANDARD_REQUIRED True)
set(CMAKE_CXX_EXTENSIONS OFF)
set(CMAKE_INTERPROCEDURAL_OPTIMIZATION TRUE)

project(
    CFB
    LANGUAGES CXX
    VERSION 0.2.0
    DESCRIPTION "Canadian Furious Beaver - IRP interceptor and replayer"
    HOMEPAGE_URL https://github.com/hugsy/cfb
)

set(PROJECT_AUTHOR hugsy)
set(PROJECT_LICENSE MIT)

set(CXX_STANDARD 20)

list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_LIST_DIR}/cmake")

set_property(GLOBAL PROPERTY USE_FOLDERS ON)

option(CFB_BUILD_GUI "Build GUI" ON)
option(CFB_BUILD_TOOLS "Build Tools" OFF)
option(CFB_BUILD_TESTS "Build Tests" OFF)

if(CMAKE_VERSION VERSION_GREATER_EQUAL "3.24.0")
    cmake_policy(SET CMP0135 NEW)
endif()

#
# Check the dependencies
#
message(STATUS "Locating Windows Driver Kit")
find_package(WDK REQUIRED)
find_package(PhNt REQUIRED)
find_package(WIL REQUIRED)
find_package(Json REQUIRED)
find_package(argparse REQUIRED)

if(CFB_BUILD_GUI)
    find_package(ImGUI REQUIRED)
endif(CFB_BUILD_GUI)

if(CFB_BUILD_TESTS)
    find_package(Catch2 REQUIRED)
endif(CFB_BUILD_TESTS)

set(CFB_ROOT_DIR ${CMAKE_CURRENT_LIST_DIR})

set(CFB_VERSION_MAJOR ${PROJECT_VERSION_MAJOR} CACHE INTERNAL "CFB_VERSION_MAJOR")
set(CFB_VERSION_MINOR ${PROJECT_VERSION_MINOR} CACHE INTERNAL "CFB_VERSION_MINOR")
set(CFB_VERSION_PATCH ${PROJECT_VERSION_PATCH} CACHE INTERNAL "CFB_VERSION_PATCH")
set(CFB_COMPANY_NAME "BlahCat Corp." CACHE INTERNAL "CFB_COMPANY_NAME")
string(TIMESTAMP CFB_CURRENT_YEAR "%Y")

#
# Build
#
add_subdirectory(${CFB_ROOT_DIR}/Common)
add_subdirectory(${CFB_ROOT_DIR}/Driver)
add_subdirectory(${CFB_ROOT_DIR}/Broker)

if(CFB_BUILD_GUI)
    add_subdirectory(${CFB_ROOT_DIR}/GUI)
endif(CFB_BUILD_GUI)

if(CFB_BUILD_TOOLS)
    add_subdirectory(${CFB_ROOT_DIR}/Driver/Client)
endif(CFB_BUILD_TOOLS)

if(CFB_BUILD_TESTS)
    include(CTest)
    add_subdirectory(${CFB_ROOT_DIR}/Common/Tests)
    add_subdirectory(${CFB_ROOT_DIR}/Broker/Tests)
    add_subdirectory(${CFB_ROOT_DIR}/GUI/Tests)
endif(CFB_BUILD_TESTS)

```

`Common/CMakeLists.txt`:

```txt
message(STATUS "Configuring 'CommonLib'")

set(COMMON_SOURCE_DIR ${CFB_ROOT_DIR}/Common/Source)
set(COMMON_HEADER_DIR ${CFB_ROOT_DIR}/Common/Headers)

set(
    COMMON_HEADER_FILES

    ${COMMON_HEADER_DIR}/CompileInfo.hpp

    ${COMMON_HEADER_DIR}/Common.hpp
    ${COMMON_HEADER_DIR}/Comms.hpp
    ${COMMON_HEADER_DIR}/IoctlCodes.hpp
    ${COMMON_HEADER_DIR}/Log.hpp
    ${COMMON_HEADER_DIR}/Messages.hpp
    ${COMMON_HEADER_DIR}/Utils.hpp
)

set(
    COMMON_SOURCE_FILES

    ${COMMON_SOURCE_DIR}/Comms.cpp
    ${COMMON_SOURCE_DIR}/Log.cpp
    ${COMMON_SOURCE_DIR}/Utils.cpp
)

#
# Create the compilation information file
#
configure_file(
    ${COMMON_HEADER_DIR}/CompileInfo.hpp.in
    ${COMMON_HEADER_DIR}/CompileInfo.hpp
    NEWLINE_STYLE WIN32
)

#
# Build CommonLib for driver
#
set(
    COMMON_DRIVER_SOURCE_FILES

    ${COMMON_SOURCE_FILES}
)

set(
    COMMON_DRIVER_HEADER_FILES

    ${COMMON_HEADER_FILES}
)

wdk_add_library(CommonLibDriver
    STATIC
    KMDF
    1.15

    ${COMMON_DRIVER_SOURCE_FILES}
    ${COMMON_DRIVER_HEADER_FILES}
)

add_library(CFB::Kernel::CommonLib ALIAS CommonLibDriver)

target_include_directories(CommonLibDriver PUBLIC ${COMMON_HEADER_DIR})
target_compile_definitions(CommonLibDriver PRIVATE CFB_KERNEL_DRIVER=1)

#
# Build CommonLib for user
#
set(
    COMMON_USER_SOURCE_FILES

    ${COMMON_SOURCE_FILES}
    ${COMMON_SOURCE_DIR}/Messages.cpp
)

set(
    COMMON_USER_HEADER_FILES

    ${COMMON_HEADER_FILES}
    ${COMMON_HEADER_DIR}/Messages.hpp
)

add_library(CommonLibUser
    STATIC

    ${COMMON_USER_SOURCE_FILES}
    ${COMMON_USER_HEADER_FILES}
)

add_library(CFB::User::CommonLib ALIAS CommonLibUser)

target_include_directories(CommonLibUser
    PUBLIC
    ${COMMON_HEADER_DIR}

    $<TARGET_PROPERTY:Deps::JSON,INTERFACE_INCLUDE_DIRECTORIES>
)

target_compile_options(CommonLibUser
    PUBLIC
    $<$<COMPILE_LANGUAGE:CXX>:/Zc:__cplusplus>
    $<$<NOT:$<STREQUAL:${CMAKE_GENERATOR_PLATFORM},arm64>>:$<$<CONFIG:Debug>:/fsanitize=address>>

    PRIVATE
    $<IF:$<CONFIG:Debug>,/WX /Gm- /permissive-,/WX /permissive>
)

target_compile_definitions(CommonLibUser
    PUBLIC
    $<$<NOT:$<STREQUAL:${CMAKE_GENERATOR_PLATFORM},arm64>>:$<$<CONFIG:Debug>:_DISABLE_VECTOR_ANNOTATION>>
    $<$<NOT:$<STREQUAL:${CMAKE_GENERATOR_PLATFORM},arm64>>:$<$<CONFIG:Debug>:_DISABLE_STRING_ANNOTATION>>

    PRIVATE
)

target_link_options(CommonLibUser
    PUBLIC
    $<$<NOT:$<STREQUAL:${CMAKE_GENERATOR_PLATFORM},arm64>>:$<$<CONFIG:Debug>:/InferAsanLibs>>

    PRIVATE
)

target_link_libraries(CommonLibUser PRIVATE kernel32.lib ntdll.lib)

```

`Common/Headers/Common.hpp`:

```hpp
#pragma once
// clang-format off
#ifdef CFB_KERNEL_DRIVER
#include <ntifs.h>
#include <ntddk.h>
#include <wdm.h>
#else
#include <windows.h>
#endif // CFB_KERNEL_DRIVER
// clang-format on

#define __STR(x) #x
#define STR(x) __STR(x)
#define __WIDE(x) L#x
#define WIDECHAR(x) __WIDE(x)
#define __WIDE2(x) L##x
#define WIDECHAR2(x) __WIDE2(x)
#define CONCAT(x, y) (x##y)

//
// Types
//

///
/// Static types
///
using u8  = UINT8;
using u16 = UINT16;
using u32 = UINT32;
using u64 = UINT64;

using i8  = INT8;
using i16 = INT16;
using i32 = INT32;
using i64 = INT64;

using usize = SIZE_T;
using uptr  = ULONG_PTR;

// clang-format off
#define CFB_DEVICE_NAME                   L"IrpMonitor"
#define CFB_DEVICE_PATH                   L"\\Device\\" CFB_DEVICE_NAME
#define CFB_DOS_DEVICE_PATH               L"\\??\\" CFB_DEVICE_NAME
#define CFB_USER_DEVICE_PATH              L"\\\\?\\GlobalRoot\\Device\\" CFB_DEVICE_NAME
#define CFB_DEVICE_TAG                    ' BFC'

#define CFB_DRIVER_MAX_PATH               256
#define CFB_DRIVER_BASENAME               CFB_DEVICE_NAME L".sys"

#define CFB_BROKER_DRIVER_SERVICE_NAME             CFB_DEVICE_NAME
#define CFB_BROKER_DRIVER_SERVICE_DESCRIPTION      L"IRP monitor driver for Canadian Furious Beaver broker"

#define CFB_BROKER_WIN32_SERVICE_NAME              L"CfbBrokerSvc"
#define CFB_BROKER_WIN32_SERVICE_DESCRIPTION       L"Service for having the CFB broker in background"

#ifndef countof
#define countof(arr) ((sizeof(arr)) / (sizeof(arr[0])))
#endif

#ifndef boolstr
#define boolstr(x)                  ( (x) ? "true" : "false")
#endif

#ifndef boolstrw
#define boolstrw(x)                 ( (x) ? L"true" : L"false")
#endif

#ifndef MIN
#define MIN(a,b) ( (a) < (b) ? (a) : (b))
#endif // MIN

#ifndef MAX
#define MAX(a,b) ( (a) < (b) ? (b) : (a))
#endif // MAX

#ifndef USHRT_MAX
#define USHRT_MAX ((1 << (sizeof(u16) * 8)) - 1)
#endif // USHRT_MAX

#ifndef PLURAL_IF
#define PLURAL_IF(x) ((x) ? "s" : "")
#endif // PLURAL_IF

#ifndef WPLURAL_IF
#define WPLURAL_IF(x) ((x) ? L"s" : L"")
#endif // WPLURAL_IF

// clang-format on

```

`Common/Headers/Comms.hpp`:

```hpp
#pragma once

#include "Common.hpp"

#ifndef CFB_KERNEL_DRIVER
// clang-format off
#include <nlohmann/json.hpp>
// clang-format on
#endif // CFB_KERNEL_DRIVER


namespace CFB::Comms
{
#pragma pack(push, 1)
struct CapturedIrpHeader
{
    u64 TimeStamp;
    wchar_t DriverName[CFB_DRIVER_MAX_PATH];
    wchar_t DeviceName[CFB_DRIVER_MAX_PATH];
    u8 Irql;
    u8 Type;
    u8 MajorFunction;
    u8 MinorFunction;
    u32 IoctlCode;
    u32 Pid;
    u32 Tid;
    NTSTATUS Status;
    wchar_t ProcessName[CFB_DRIVER_MAX_PATH];
    u32 InputBufferLength;
    u32 OutputBufferLength;
};
#pragma pack(pop)

#ifdef CFB_KERNEL_DRIVER
#else
struct CapturedIrp
{
    CapturedIrpHeader Header;
    std::vector<u8> InputBuffer;
    std::vector<u8> OutputBuffer;
};

void
to_json(nlohmann::json& j, CapturedIrpHeader const& h);

void
from_json(const nlohmann::json& j, CapturedIrpHeader& h);

void
to_json(nlohmann::json& j, CapturedIrp const& i);

void
from_json(const nlohmann::json& j, CapturedIrp& i);
#endif // CFB_KERNEL_DRIVER

} // namespace CFB::Comms

```

`Common/Headers/CompileInfo.hpp.in`:

```in
#pragma once

//
// Those values are auto-generated by CMakeLists.txt. Don't edit them here.
//


// clang-format off
#cmakedefine PROJECT_NAME                  "@CMAKE_PROJECT_NAME@"
#cmakedefine PROJECT_DESCRIPTION           "@CMAKE_PROJECT_DESCRIPTION@"
#cmakedefine PROJECT_AUTHOR                "@PROJECT_AUTHOR@"
#cmakedefine PROJECT_LICENSE               "@PROJECT_LICENSE@"
#cmakedefine PROJECT_HOMEPAGE_URL          "@CMAKE_PROJECT_HOMEPAGE_URL@"

#define DRIVER_VERSION_MAJOR          @DRIVER_VERSION_MAJOR@
#define DRIVER_VERSION_MINOR          @DRIVER_VERSION_MINOR@
#define DRIVER_VERSION_PATCH          @DRIVER_VERSION_PATCH@
#define DRIVER_VERSION                "@DRIVER_VERSION_MAJOR@.@DRIVER_VERSION_MINOR@.@DRIVER_VERSION_PATCH@"

#define BROKER_VERSION_MAJOR          @BROKER_VERSION_MAJOR@
#define BROKER_VERSION_MINOR          @BROKER_VERSION_MINOR@
#define BROKER_VERSION_PATCH          @BROKER_VERSION_PATCH@
#define BROKER_VERSION                "@BROKER_VERSION_MAJOR@.@BROKER_VERSION_MINOR@.@BROKER_VERSION_PATCH@"

#define GUI_VERSION_MAJOR          @GUI_VERSION_MAJOR@
#define GUI_VERSION_MINOR          @GUI_VERSION_MINOR@
#define GUI_VERSION_PATCH          @GUI_VERSION_PATCH@
#define GUI_VERSION                "@GUI_VERSION_MAJOR@.@GUI_VERSION_MINOR@.@GUI_VERSION_PATCH@"
// clang-format on

```

`Common/Headers/IoctlCodes.hpp`:

```hpp
#pragma once

#ifndef CTL_CODE
#define CTL_CODE(DeviceType, Function, Method, Access)                                                                 \
    (((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method))
#endif // CTL_CODE

#ifndef FILE_DEVICE_UNKNOWN
#define FILE_DEVICE_UNKNOWN 0x0022
#endif // FILE_DEVICE_UNKNOWN

#ifndef METHOD_BUFFERED
#define METHOD_BUFFERED 0
#endif // METHOD_BUFFERED

#ifndef FILE_ANY_ACCESS
#define FILE_ANY_ACCESS 0
#endif // FILE_ANY_ACCESS

namespace CFB::Comms
{

///
///@brief An enumeration class of the available IOCTL supported by the driver
///
enum class Ioctl : u32
{
    // clang-format off

    ///
    ///@brief ControlDriver - obsolete
    ///
    ControlDriver      = CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS),

    ///
    ///@brief HookDriver
    ///
    HookDriver         = CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS),

    ///
    ///@brief UnhookDriver
    ///
    UnhookDriver       = CTL_CODE(FILE_DEVICE_UNKNOWN, 0x802, METHOD_BUFFERED, FILE_ANY_ACCESS),

    ///
    ///@brief GetNumberOfDrivers
    ///
    GetNumberOfDrivers = CTL_CODE(FILE_DEVICE_UNKNOWN, 0x803, METHOD_BUFFERED, FILE_ANY_ACCESS),

    ///
    ///@brief GetNamesOfDrivers
    ///
    GetNamesOfDrivers  = CTL_CODE(FILE_DEVICE_UNKNOWN, 0x804, METHOD_BUFFERED, FILE_ANY_ACCESS),

    ///
    ///@brief GetDriverInfo
    ///
    GetDriverInfo      = CTL_CODE(FILE_DEVICE_UNKNOWN, 0x805, METHOD_BUFFERED, FILE_ANY_ACCESS),

    ///
    ///@brief SetEventPointer
    ///
    SetEventPointer    = CTL_CODE(FILE_DEVICE_UNKNOWN, 0x806, METHOD_BUFFERED, FILE_ANY_ACCESS),

    ///
    ///@brief EnableMonitoring
    ///
    EnableMonitoring   = CTL_CODE(FILE_DEVICE_UNKNOWN, 0x807, METHOD_BUFFERED, FILE_ANY_ACCESS),

    ///
    ///@brief DisableMonitoring
    ///
    DisableMonitoring  = CTL_CODE(FILE_DEVICE_UNKNOWN, 0x808, METHOD_BUFFERED, FILE_ANY_ACCESS),

    // clang-format on
};

} // namespace CFB::Comms

```

`Common/Headers/Log.hpp`:

```hpp
#pragma once

#include "Common.hpp"

namespace CFB::Log
{
#ifndef CFB_KERNEL_DRIVER
static inline const ULONG LogLevelDebug = 0;
static inline const ULONG LogLevelInfo  = 1;
#endif // CFB_KERNEL_DRIVER

void
Log(ULONG level, const char* fmtstr, ...);

#ifndef CFB_KERNEL_DRIVER
void
perror(const char* msg);

void
ntperror(const char* msg, const NTSTATUS Status);
#endif
}; // namespace CFB::Log

#ifndef CFB_NS
/// @brief Customizable log prefix
#define CFB_NS
#endif // !CFB_NS

#ifdef CFB_KERNEL_DRIVER

#ifdef _DEBUG
#define dbg(fmt, ...) CFB::Log::Log(DPFLTR_INFO_LEVEL, "[=] " CFB_NS " " fmt "\n", __VA_ARGS__)
#else
#define dbg(fmt, ...)
#endif // _DEBUG

#define ok(fmt, ...) CFB::Log::Log(DPFLTR_INFO_LEVEL, "[+] " CFB_NS " " fmt "\n", __VA_ARGS__)
#define info(fmt, ...) CFB::Log::Log(DPFLTR_TRACE_LEVEL, "[*] " CFB_NS " " fmt "\n", __VA_ARGS__)
#define warn(fmt, ...) CFB::Log::Log(DPFLTR_WARNING_LEVEL, "[!] " CFB_NS " " fmt "\n", __VA_ARGS__)
#define err(fmt, ...) CFB::Log::Log(DPFLTR_ERROR_LEVEL, "[-] " CFB_NS " " fmt "\n", __VA_ARGS__)
#define crit(fmt, ...) CFB::Log::Log(DPFLTR_ERROR_LEVEL, "[/!\\] " CFB_NS " " fmt "\n", __VA_ARGS__)

#define DML(cmd, title) "<?dml?> <exec cmd=\"" cmd "\">" cmd "</exec>"

#else // CFB_KERNEL_DRIVER

#ifdef _DEBUG
#define dbg(fmt, ...) CFB::Log::Log(CFB::Log::LogLevelDebug, "[=] " CFB_NS " " fmt "\n", __VA_ARGS__)
#else
#define dbg(fmt, ...)
#endif // _DEBUG

#define ok(fmt, ...) CFB::Log::Log(CFB::Log::LogLevelInfo, "[+] " CFB_NS " " fmt "\n", __VA_ARGS__)
#define info(fmt, ...) CFB::Log::Log(CFB::Log::LogLevelInfo, "[*] " CFB_NS " " fmt "\n", __VA_ARGS__)
#define warn(fmt, ...) CFB::Log::Log(CFB::Log::LogLevelInfo, "[!] " CFB_NS " " fmt "\n", __VA_ARGS__)
#define err(fmt, ...) CFB::Log::Log(CFB::Log::LogLevelInfo, "[-] " CFB_NS " " fmt "\n", __VA_ARGS__)
#define crit(fmt, ...) CFB::Log::Log(CFB::Log::LogLevelInfo, "[/!\\] " CFB_NS " " fmt "\n", __VA_ARGS__)

#endif // CFB_KERNEL_DRIVER

```

`Common/Headers/Messages.hpp`:

```hpp
#pragma once

///
/// This file defines the communication protocol and structures for Broker <-> Clients
///

#include "Common.hpp"

#ifdef CFB_KERNEL_DRIVER

#else
#include <nlohmann/json.hpp>
using json = nlohmann::json;

namespace CFB::Comms
{

enum class RequestId : uptr
{
    InvalidId = 0x00,

    // Command IDs for driver requests
    HookDriver         = 0x01,
    UnhookDriver       = 0x02,
    GetNumberOfDrivers = 0x03,
    GetNamesOfDrivers  = 0x04,
    GetDriverInfo      = 0x05,
    SetEventPointer    = 0x06,
    EnableMonitoring   = 0x07,
    DisableMonitoring  = 0x08,

    // Command IDs for Broker
    EnumerateDriverObject     = 0x11,
    EnumerateDeviceObject     = 0x12,
    GetPendingIrpNumber       = 0x13,
    GetPendingIrp             = 0x14,
    EnumerateMinifilterObject = 0x15,
};


struct DriverRequest
{
    ///
    /// @brief Mandatory request type id
    ///
    RequestId Id = RequestId::InvalidId;

    ///
    /// @brief Driver name as a wstring, used for
    /// - HookDriver
    /// - UnhookDriver
    /// - EnableMonitoring
    /// - DisableMonitoring
    ///
    std::wstring DriverName;

    ///
    ///@brief used for
    /// - GetPendingIrp
    ///
    u16 NumberOfIrp;
};


///
/// @brief DriverRequest -> JSON
///
/// @param dst
/// @param src
///
void
to_json(json& dst, const DriverRequest& src);

///
/// @brief JSON -> DriverRequest
///
/// @param src
/// @param dst
///
void
from_json(const json& src, DriverRequest& dst);

} // namespace CFB::Comms

#endif // CFB_KERNEL_DRIVER

```

`Common/Headers/Utils.hpp`:

```hpp
#pragma once

#include "Common.hpp"
#include "Comms.hpp"

#ifdef CFB_KERNEL_DRIVER
#define XPRINTF(...)                                                                                                   \
    {                                                                                                                  \
        ::DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, __VA_ARGS__);                                             \
    }

#else

#include <stdio.h>

#include <string>

#include "IoctlCodes.hpp"

#ifdef CFB_KERNEL_DRIVER
#else
#include "Messages.hpp"
#endif // CFB_KERNEL_DRIVER

#define XPRINTF(...)                                                                                                   \
    {                                                                                                                  \
        printf(__VA_ARGS__);                                                                                           \
    }
#endif // CFB_KERNEL_DRIVER

#define WIDEN2(x) L##x
#define WIDEN(x) WIDEN2(x)

namespace CFB::Utils
{
///
/// @brief Print out an hexdump-like version of the buffer.
///
/// @param data A pointer to the buffer to hexdump
/// @param size The size of the buffer
/// @param header If not null, an header to print before the hexdump
/// @param base Specifies the base address
///
void
Hexdump(const PVOID data, SIZE_T size, PCSTR header = nullptr, SIZE_T base = 0);

const char*
IrqlToString(u32 type);


const char*
IrpMajorToString(u32 type);

///
///@brief
///
///@param Type
///@return const char*
///
const char*
IrpTypeToString(u8 Type);


#ifdef CFB_KERNEL_DRIVER
#else
std::string
ToString(std::wstring const& input);

std::wstring
ToWideString(std::string const& input);

std::string
ToString(CFB::Comms::Ioctl code);

std::string
ToString(CFB::Comms::RequestId id);

std::string
ToString(CFB::Comms::CapturedIrp const& Irp);


#endif // CFB_KERNEL_DRIVER

namespace Memory
{
///
/// @brief
///
/// @param Value
/// @param Base
/// @return true
/// @return false
///
bool
IsAligned(uptr const Value, usize const Base);

///
///@brief Align a value to a base
///
///@param Value
///@param Base
///@return uptr
///
uptr
AlignValue(uptr const Value, usize const Base);
} // namespace Memory
} // namespace CFB::Utils

```

`Common/Source/Comms.cpp`:

```cpp
#pragma once

#include "Comms.hpp"

#include "Utils.hpp"

#ifndef CFB_KERNEL_DRIVER
// clang-format off
#include <codecvt>
#include <locale>
#include <sstream>

// clang-format on
#endif // CFB_KERNEL_DRIVER


namespace CFB::Comms
{
#ifdef CFB_KERNEL_DRIVER

#else
void
to_json(nlohmann::json& j, CapturedIrpHeader const& h)
{
    j["TimeStamp"]          = h.TimeStamp;
    j["DriverName"]         = CFB::Utils::ToString(h.DriverName);
    j["DeviceName"]         = CFB::Utils::ToString(h.DeviceName);
    j["Irql"]               = h.Irql;
    j["Type"]               = h.Type;
    j["MajorFunction"]      = h.MajorFunction;
    j["MinorFunction"]      = h.MinorFunction;
    j["IoctlCode"]          = h.IoctlCode;
    j["Pid"]                = h.Pid;
    j["Tid"]                = h.Tid;
    j["Status"]             = h.Status;
    j["ProcessName"]        = CFB::Utils::ToString(h.ProcessName);
    j["InputBufferLength"]  = h.InputBufferLength;
    j["OutputBufferLength"] = h.OutputBufferLength;
}

void
from_json(const nlohmann::json& j, CapturedIrpHeader& h)
{
    j.at("TimeStamp").get_to<u64>(h.TimeStamp);
    j.at("Irql").get_to(h.Irql);
    j.at("Type").get_to(h.Type);
    j.at("MajorFunction").get_to(h.MajorFunction);
    j.at("MinorFunction").get_to(h.MinorFunction);
    j.at("IoctlCode").get_to(h.IoctlCode);
    j.at("Pid").get_to(h.Pid);
    j.at("Tid").get_to(h.Tid);
    j.at("Status").get_to(h.Status);
    j.at("InputBufferLength").get_to<u32>(h.InputBufferLength);
    j.at("OutputBufferLength").get_to<u32>(h.OutputBufferLength);

    auto const& ProcessName = CFB::Utils::ToWideString(j.at("ProcessName").get<std::string>());
    auto const& DriverName  = CFB::Utils::ToWideString(j.at("DriverName").get<std::string>());
    auto const& DeviceName  = CFB::Utils::ToWideString(j.at("DeviceName").get<std::string>());
    ::memcpy(
        h.ProcessName,
        ProcessName.c_str(),
        MIN(ProcessName.size() * sizeof(wchar_t), sizeof(h.ProcessName) - sizeof(wchar_t)));
    ::memcpy(
        h.DeviceName,
        DeviceName.c_str(),
        MIN(DeviceName.size() * sizeof(wchar_t), sizeof(h.DeviceName) - sizeof(wchar_t)));
    ::memcpy(
        h.DriverName,
        DriverName.c_str(),
        MIN(DriverName.size() * sizeof(wchar_t), sizeof(h.DriverName) - sizeof(wchar_t)));
}

void
to_json(nlohmann::json& j, CapturedIrp const& i)
{
    j["Header"]       = i.Header;
    j["InputBuffer"]  = i.InputBuffer;
    j["OutputBuffer"] = i.OutputBuffer;
}

void
from_json(const nlohmann::json& j, CapturedIrp& i)
{
    j.at("Header").get_to(i.Header);
    j.at("InputBuffer").get_to(i.InputBuffer);
    j.at("OutputBuffer").get_to(i.OutputBuffer);

    assert(i.InputBuffer.size() == i.Header.InputBufferLength);
    assert(i.OutputBuffer.size() == i.Header.OutputBufferLength);
}
#endif // CFB_KERNEL_DRIVER

} // namespace CFB::Comms

```

`Common/Source/Log.cpp`:

```cpp
#include "Log.hpp"

#ifdef CFB_KERNEL_DRIVER
#include <ntstrsafe.h>

#else
#include <stdarg.h>
#include <stdio.h>

#include <iostream>
#endif // CFB_KERNEL_DRIVER

#define __WFILE__ WIDEN(__FILE__)
#define __WFUNCTION__ WIDEN(__FUNCTION__)


namespace CFB::Log
{
void
Log(ULONG level, const char* fmtstr, ...)
{
    va_list args;
    va_start(args, fmtstr);

#ifdef CFB_KERNEL_DRIVER
    //
    // Use `nt!Kd_IHVDRIVER_Mask` to control the level. Only log at PASSIVE & APC
    //
    if ( ::KeGetCurrentIrql() >= DISPATCH_LEVEL )
    {
        return;
    }

    ::vDbgPrintEx(DPFLTR_IHVDRIVER_ID, level, fmtstr, args);

#else
    std::string out;
    out.resize(1024);

    ::vsnprintf(out.data(), out.size(), fmtstr, args);

    if ( level == LogLevelDebug )
    {
        ::OutputDebugStringA(out.c_str());
    }
    else
    {
        out.resize(std::strlen(out.c_str()));
        std::cerr << out;
    }
#endif // CFB_KERNEL_DRIVER

    va_end(args);
}

#ifndef CFB_KERNEL_DRIVER

extern "C" void WINAPI
SetLastError(_In_ DWORD dwErrCode);

extern "C" ULONG WINAPI
RtlNtStatusToDosError(_In_ NTSTATUS Status);


//
// User specific logging functions
//

void
perror(const char* msg)
{
    const u32 sysMsgSz = 2048;
    auto sysMsg        = std::string();
    sysMsg.resize(sysMsgSz);
    const auto errcode = ::GetLastError();

    ::FormatMessageA(
        FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_MAX_WIDTH_MASK, // FORMAT_MESSAGE_FROM_HMODULE
        nullptr,
        errcode,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        sysMsg.data(),
        sysMsgSz,
        nullptr);

    const usize max_len = ::wcslen((wchar_t*)sysMsg.c_str());
    err("%s, errcode=0x%08x: %s", msg, errcode, sysMsg.c_str());
}

void
ntperror(const char* msg, const NTSTATUS Status)
{
    auto dwDosError = RtlNtStatusToDosError(Status);
    auto hResult    = HRESULT_FROM_WIN32(dwDosError);
    ::SetLastError(hResult);
    CFB::Log::perror(msg);
    return;
}
#endif
} // namespace CFB::Log

```

`Common/Source/Messages.cpp`:

```cpp
#include "Messages.hpp"

#ifndef CFB_KERNEL_DRIVER
#include <codecvt>
#include <locale>

#include "Utils.hpp"


namespace CFB::Comms
{
//
// JSON Converters
//
void
to_json(json& dst, const DriverRequest& src)
{
    dst["id"] = src.Id;
    switch ( src.Id )
    {
    case RequestId::HookDriver:
    case RequestId::UnhookDriver:
    case RequestId::EnableMonitoring:
    case RequestId::DisableMonitoring:
        dst["driver_name"] = CFB::Utils::ToString(src.DriverName);
        break;

    case RequestId::GetPendingIrp:
        dst["number_of_irp"] = src.NumberOfIrp;
        break;

    default:
        break;
    }
}

void
from_json(const json& js, DriverRequest& dst)
{
    dst.Id = js["id"];
    switch ( dst.Id )
    {
    case RequestId::HookDriver:
    case RequestId::UnhookDriver:
    case RequestId::EnableMonitoring:
    case RequestId::DisableMonitoring:
        dst.DriverName = CFB::Utils::ToWideString(js["driver_name"].get<std::string>());
        break;

    case RequestId::GetPendingIrp:
        dst.NumberOfIrp = js["number_of_irp"];
        break;

    default:
        break;
    }
}

} // namespace CFB::Comms
#endif // CFB_KERNEL_DRIVER

```

`Common/Source/Utils.cpp`:

```cpp
#include "Utils.hpp"

#ifdef CFB_KERNEL_DRIVER
#else
#include <algorithm>
#include <iostream>
#include <sstream>
#endif // CFB_KERNEL_DRIVER

namespace CFB::Utils
{
void
Hexdump(const PVOID data, SIZE_T size, PCSTR header, SIZE_T base)
{
    CHAR ascii[17] {};
    auto ptr = reinterpret_cast<u8*>(data);

    if ( header )
    {
        XPRINTF("%s\n", header);
    }

    for ( size_t i = 0; i < size; ++i )
    {
        u8 c = ptr[i];

        if ( !ascii[0] )
            XPRINTF("%08Ix   ", base + i);

        XPRINTF("%02X ", c);

        ascii[i % 16] = (0x20 <= c && c < 0x7f) ? (u8)c : '.';

        if ( (i + 1) % 8 == 0 || i + 1 == size )
        {
            XPRINTF(" ");
            if ( (i + 1) % 16 == 0 )
            {
                XPRINTF("|  %s \n", ascii);
                ::RtlSecureZeroMemory(ascii, sizeof(ascii));
            }
            else if ( i + 1 == size )
            {
                ascii[(i + 1) % 16] = '\0';
                if ( (i + 1) % 16 <= 8 )
                {
                    XPRINTF(" ");
                }
                for ( auto j = (i + 1) % 16; j < 16; ++j )
                {
                    XPRINTF("   ");
                }

                XPRINTF("|  %s \n", ascii);
            }
        }
    }

    return;
}

const char*
IrpMajorToString(u32 type)
{
    switch ( type )
    {
    case 0x00:
        return "IRP_MJ_CREATE";
    case 0x01:
        return "IRP_MJ_CREATE_NAMED_PIPE";
    case 0x02:
        return "IRP_MJ_CLOSE";
    case 0x03:
        return "IRP_MJ_READ";
    case 0x04:
        return "IRP_MJ_WRITE";
    case 0x05:
        return "IRP_MJ_QUERY_INFORMATION";
    case 0x06:
        return "IRP_MJ_SET_INFORMATION";
    case 0x07:
        return "IRP_MJ_QUERY_EA";
    case 0x08:
        return "IRP_MJ_SET_EA";
    case 0x09:
        return "IRP_MJ_FLUSH_BUFFERS";
    case 0x0a:
        return "IRP_MJ_QUERY_VOLUME_INFORMATION";
    case 0x0b:
        return "IRP_MJ_SET_VOLUME_INFORMATION";
    case 0x0c:
        return "IRP_MJ_DIRECTORY_CONTROL";
    case 0x0d:
        return "IRP_MJ_FILE_SYSTEM_CONTROL";
    case 0x0e:
        return "IRP_MJ_DEVICE_CONTROL";
    case 0x0f:
        return "IRP_MJ_INTERNAL_DEVICE_CONTROL";
    case 0x10:
        return "IRP_MJ_SHUTDOWN";
    case 0x11:
        return "IRP_MJ_LOCK_CONTROL";
    case 0x12:
        return "IRP_MJ_CLEANUP";
    case 0x13:
        return "IRP_MJ_CREATE_MAILSLOT";
    case 0x14:
        return "IRP_MJ_QUERY_SECURITY";
    case 0x15:
        return "IRP_MJ_SET_SECURITY";
    case 0x16:
        return "IRP_MJ_POWER";
    case 0x17:
        return "IRP_MJ_SYSTEM_CONTROL";
    case 0x18:
        return "IRP_MJ_DEVICE_CHANGE";
    case 0x19:
        return "IRP_MJ_QUERY_QUOTA";
    case 0x1a:
        return "IRP_MJ_SET_QUOTA";
    case 0x1b:
        return "IRP_MJ_PNP_POWER";
    }
    return "UnknownIrpType";
}

const char*
IrpTypeToString(u8 Type)
{
    switch ( Type )
    {
    case 0:
        return "IRP";
    case 1:
        return "FastIRP";
    }

    return "Unknown";
}

const char*
IrqlToString(u32 type)
{
    switch ( type )
    {
    case 0:
        return "PASSIVE_LEVEL";
    case 1:
        return "APC_LEVEL";
    case 2:
        return "DISPATCH_LEVEL";
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
        return "DEVICE_IRQL";
    case 13:
        return "CLOCK_LEVEL";
    case 14:
        return "POWER_LEVEL";
    case 15:
        return "HIGH_LEVEL";
    }
    return "Unknown";
}

#ifdef CFB_KERNEL_DRIVER
#else
std::string
ToString(std::wstring const& wide_string)
{
    int size_needed =
        ::WideCharToMultiByte(CP_UTF8, 0, wide_string.data(), (int)wide_string.size(), nullptr, 0, nullptr, nullptr);

    std::string str(size_needed, 0);

    if ( 0 == ::WideCharToMultiByte(
                  CP_UTF8,
                  0,
                  wide_string.data(),
                  (int)wide_string.size(),
                  str.data(),
                  (int)str.size(),
                  nullptr,
                  nullptr) )
    {
        str.clear();
    }
    return str;
}

std::wstring
ToWideString(std::string const& str)
{
    int size_needed = ::MultiByteToWideChar(CP_UTF8, 0, str.data(), (int)str.size(), nullptr, 0);

    std::wstring wstr(size_needed, 0);

    if ( 0 == ::MultiByteToWideChar(CP_UTF8, 0, str.data(), (int)str.size(), wstr.data(), (int)wstr.size()) )
    {
        wstr.clear();
    }
    return wstr;
}

std::string
ToString(CFB::Comms::Ioctl IoctlCode)
{
    u32 code           = (u32)IoctlCode;
    u32 DeviceType     = ((code >> 16) & 0x0000ffff);
    u32 AccessType     = ((code >> 14) & 0x00000003);
    u32 MethodType     = (code & 0x0000003);
    u32 FunctionNumber = ((code >> 2) & 0x0000fff);

    std::ostringstream oss;
    oss << "CTL_CODE(DeviceType=0x" << std::hex << DeviceType << ", Function=0x" << FunctionNumber;
    oss << ", Method=" << MethodType << ", Access=" << AccessType << ")";
    return oss.str();
}

std::string
ToString(CFB::Comms::RequestId id)
{
    using CFB::Comms::RequestId;
#define CaseToString(x)                                                                                                \
    {                                                                                                                  \
    case (x):                                                                                                          \
        return #x;                                                                                                     \
    }

    switch ( id )
    {
        CaseToString(RequestId::InvalidId);
        CaseToString(RequestId::HookDriver);
        CaseToString(RequestId::UnhookDriver);
        CaseToString(RequestId::GetNumberOfDrivers);
        CaseToString(RequestId::GetNamesOfDrivers);
        CaseToString(RequestId::GetDriverInfo);
        CaseToString(RequestId::SetEventPointer);
        CaseToString(RequestId::EnableMonitoring);
        CaseToString(RequestId::DisableMonitoring);
        CaseToString(RequestId::GetPendingIrp);
        CaseToString(RequestId::EnumerateDriverObject);
        CaseToString(RequestId::EnumerateDeviceObject);
    }
#undef CaseToString

    return "RequestId::Unknown";
}

std::string
ToString(CFB::Comms::CapturedIrp const& Irp)
{
    std::ostringstream oss;
    oss << Irp.Header.TimeStamp << " " << CFB::Utils::ToString(Irp.Header.DriverName) << " "
        << CFB::Utils::ToString(Irp.Header.DeviceName) << " " << Irp.Header.Irql << Irp.Header.Type << " "
        << Irp.Header.MajorFunction << " " << Irp.Header.MinorFunction << " "
        << CFB::Utils::IrpMajorToString(Irp.Header.MajorFunction) << " " << Irp.Header.IoctlCode << " "
        << Irp.Header.Pid << " " << Irp.Header.Tid << " " << CFB::Utils::ToString(Irp.Header.ProcessName) << " "
        << Irp.Header.Status << " " << Irp.Header.InputBufferLength << " " << Irp.Header.OutputBufferLength;
    return oss.str();
}
#endif // CFB_KERNEL_DRIVER

namespace Memory
{
bool
IsAligned(uptr const Value, usize const Base)
{
    return (Value & (Base - 1)) == 0;
}

uptr
AlignValue(uptr const Value, usize const Base)
{
    if ( IsAligned(Value, Base) )
    {
        return Value;
    }

    return (Value & ~(Base - 1)) + Base;
}
} // namespace Memory

} // namespace CFB::Utils

```

`Common/Tests/CMakeLists.txt`:

```txt
message(STATUS "Configuring tests for 'CommonLib'")

enable_testing()

set(COMMON_HEADERS_DIR ${CFB_ROOT_DIR}/Common/Headers)
set(COMMON_TEST_DIR ${CFB_ROOT_DIR}/Common/Tests)

set(TEST_SET
    Comms
    Utils
)

foreach(TEST_FILE ${TEST_SET})
    set(FILEPATH "${COMMON_TEST_DIR}/${TEST_FILE}.cpp")
    set(TARGET_NAME Tests_Common_${TEST_FILE})
    add_executable(${TARGET_NAME} WIN32 ${FILEPATH})
    list(APPEND ALL_COMMON_TESTS ${TARGET_NAME})
    add_dependencies(${TARGET_NAME} CFB::User::CommonLib)
    set_target_properties(${TARGET_NAME} PROPERTIES CXX_STANDARD 20)
    target_compile_features(${TARGET_NAME} PUBLIC cxx_std_20)
    target_include_directories(${TARGET_NAME} PUBLIC ${COMMON_HEADERS_DIR})
    target_compile_definitions(
        ${TARGET_NAME}
        PRIVATE
        CATCH_CONFIG_NO_WINDOWS_SEH
    )
    target_compile_options(${TARGET_NAME} PRIVATE $<TARGET_PROPERTY:CFB::User::CommonLib,COMPILE_OPTIONS>)
    target_link_libraries(${TARGET_NAME} PRIVATE Catch2::Catch2 Catch2::Catch2WithMain CFB::User::CommonLib)
    target_link_options(
        ${TARGET_NAME}
        PUBLIC
        /SUBSYSTEM:Console
        $<$<NOT:$<STREQUAL:${CMAKE_GENERATOR_PLATFORM},arm64>>:$<$<CONFIG:Debug>:/InferAsanLibs>>

        PRIVATE
        $<TARGET_PROPERTY:CFB::User::CommonLib,LINK_OPTIONS>)
    add_test(NAME ${TARGET_NAME} COMMAND $<TARGET_FILE:${TARGET_NAME}>)
    install(TARGETS ${TARGET_NAME} DESTINATION Tests/Common)
    install(FILES $<TARGET_PDB_FILE:${TARGET_NAME}> DESTINATION Tests/Common OPTIONAL)
endforeach()

add_custom_target(
    Tests_Common
    DEPENDS ${ALL_COMMON_TESTS}
    COMMAND ${CMAKE_CTEST_COMMAND} -R Tests_Common
)

```

`Common/Tests/Comms.cpp`:

```cpp
#define CATCH_CONFIG_MAIN
#define NS "CFB::Comms"

// clang-format off
#include <catch2/catch_test_macros.hpp>
#include <nlohmann/json.hpp>

#include "Comms.hpp"
// clang-format on

using json = nlohmann::json;
using namespace nlohmann::literals;

TEST_CASE("Common/Communication", NS)
{
    SECTION("IRP from JS")
    {
        json j1 = R"(
[
    {
        "Header":
        {
            "DeviceName":"\\Device\\HackSysExtremeVulnerableDriver",
            "DriverName":"\\driver\\HEVD",
            "InputBufferLength":0,
            "IoctlCode":0,
            "Irql":0,
            "MajorFunction":0,
            "MinorFunction":0,
            "OutputBufferLength":0,
            "Pid":6596,
            "ProcessName": "DriverClient.e",
            "Status":0,
            "Tid":8056,
            "TimeStamp":133194954083127683,
            "Type":0
        },
        "InputBuffer":[],
        "OutputBuffer":[]
    },
    {
        "Header":
        {
            "DeviceName":"\\Device\\HackSysExtremeVulnerableDriver",
            "DriverName":"\\driver\\HEVD",
            "InputBufferLength":32,
            "IoctlCode":2236419,
            "Irql":0,
            "MajorFunction":14,
            "MinorFunction":0,
            "OutputBufferLength":0,
            "Pid":6596,
            "ProcessName": "DriverClient.e",
            "Status":0,
            "Tid":8056,
            "TimeStamp":133194954083127682,
            "Type":0
        },
        "InputBuffer":[65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65],
        "OutputBuffer":[]
    }
]
)"_json;

        for ( auto const& x : j1 )
        {
            auto const& i = x.get<CFB::Comms::CapturedIrp>();
            CHECK(i.InputBuffer.size() == i.Header.InputBufferLength);
            CHECK(i.OutputBuffer.size() == i.Header.OutputBufferLength);
        }

        //
        // Too long device, driver or process name -> trimmed
        //
        json j2 = R"(
{
    "Header":
    {
        "DeviceName":"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
        "DriverName":"BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB",
        "InputBufferLength":0,
        "IoctlCode":0,
        "Irql":0,
        "MajorFunction":0,
        "MinorFunction":0,
        "OutputBufferLength":0,
        "Pid":6596,
        "ProcessName": "CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC",
        "Status":0,
        "Tid":8056,
        "TimeStamp":133194954083127683,
        "Type":0
    },
    "InputBuffer":[],
    "OutputBuffer":[]
}
    )"_json;

        auto const& i = j2.get<CFB::Comms::CapturedIrp>();
        CHECK(::wcslen(i.Header.DeviceName) == (CFB_DRIVER_MAX_PATH - 1));
        CHECK(::wcslen(i.Header.DriverName) == (CFB_DRIVER_MAX_PATH - 1));
        CHECK(::wcslen(i.Header.ProcessName) == (CFB_DRIVER_MAX_PATH - 1));
    }
}

```

`Common/Tests/Utils.cpp`:

```cpp
#define CATCH_CONFIG_MAIN

#include <catch2/catch_test_macros.hpp>
#define NS "CFB::Utils"

#include "Utils.hpp"

TEST_CASE("Strings", NS)
{
    SECTION("ToString(WideString)")
    {
        CHECK(CFB::Utils::ToString(L"FOOBAR") == "FOOBAR");
        CHECK(CFB::Utils::ToString(L"FOOBAR").size() == 6);
    }

    SECTION("ToWideString(String)")
    {
        CHECK(CFB::Utils::ToWideString("FOOBAR") == L"FOOBAR");
        CHECK(CFB::Utils::ToWideString("FOOBAR").size() == 6);
    }

    SECTION("IRP")
    {
        for ( int i = 0; i < 0x1c; i++ )
        {
            CHECK(std::string(CFB::Utils::IrpMajorToString(i)).starts_with("IRP_"));
        }

        CHECK(std::string(CFB::Utils::IrpMajorToString(0x4242)) == "UnknownIrpType");
    }
}

TEST_CASE("Memory", NS)
{
    CHECK(CFB::Utils::Memory::IsAligned(0x41414141, 0x10) == false);
    CHECK(CFB::Utils::Memory::IsAligned(0x41414140, 0x10) == true);

    CHECK(CFB::Utils::Memory::AlignValue(0x41414100, 0x100) == 0x41414100);
    for ( int i = 1; i < 0x100; i++ )
    {
        CHECK(CFB::Utils::Memory::AlignValue(0x41414100 + i, 0x100) == 0x41414200);
    }
}

```

`Docs/README.md`:

```md

<p align="center">
  <img src="https://user-images.githubusercontent.com/590234/185767386-46d86e9e-be54-480e-9d18-308b6e028fce.png" width="300px" alt="logo" />
</p>

<p align="center">
  <a href="https://github.com/hugsy/CFB/actions/workflows/build.yml"><img alt="Build main" src="https://github.com/hugsy/CFB/actions/workflows/build.yml/badge.svg?branch=main"/></a>
  <a href="https://github.com/hugsy/CFB/actions/workflows/build.yml"><img alt="Build dev" src="https://github.com/hugsy/CFB/actions/workflows/build.yml/badge.svg?branch=dev"/></a>
  <a href="https://discord.gg/ey49tNQg"><img alt="Discord" src="https://img.shields.io/badge/Discord-CFB-purple"></a>
</p>


## Idea

**Canadian Furious Beaver** is a distributed tool for capturing IRPs sent to any Windows driver. It operates in 2 parts:

1. the "Broker" combines both a user-land agent and a self-extractable driver (`IrpMonitor.sys`) that will install itself on the targeted system. After installing the driver, the broker will expose a TCP port listening (by default, on TCP/1337) and start collecting IRP from hooked drivers. The communication protocol was made to be simple by design (i.e. not secure) allowing any [3rd party tool](https://github.com/hugsy/cfb-cli) to dump the driver IRPs from the same Broker easily (via simple JSON messages).

2. the clients can connect to the broker, and will receive IRPs as a JSON message making it easy to view, or convert to another format.

## Why the name?

Because I had no idea for the name of this tool, so it was graciously generated by [a script of mine](https://github.com/hugsy/stuff/tree/master/random-word).


```

`Docs/_sidebar.md`:

```md
* CFB
    * [Overview](/)
    * [Concept](/concept.md)
    * [Setup](/setup.md)
    * [Usage](/usage.md)
    * [Debugging](/debugging.md)
    * [Fuzzing](/fuzzing-vm-setup.md)
    * [Crash Analysis](/crash-analysis.md)
    * [Gallery](/gallery.md)
    * [FAQ](/faq.md)

```

`Docs/concept.md`:

```md
# Concept

`IrpDumper.sys` is the driver part of the CFB Broker that will auto-extract and install when launched. The driver will be responsible for hooking the IRP Major Function table of
the driver that is requested to be hooked, via an IOCTL passed from the Broker.
Upon success, the IRP table of the driver will then be pointing to `IrpDumper.sys` interception routine, as we can easily see with a debugger or tools like [`WinObjEx64`](https://github.com/hfiref0x/WinObjEx64).

![img](https://i.imgur.com/dYqHE6q.png)

`IrpDumper.sys` in itself then acts a rootkit, proxy-ing all calls to the targeted driver(s). When a `DeviceIoControl` is sent to a hooked driver, `IrpDumper` will simply capture the data if any, and push a message to the user-land agent (`Broker`), and yield the execution back to the legitimate drivers, allowing the intended code to continue as expected.
The `Broker` stores all this data in user-land waiting for a event to ask for them.

```

`Docs/crash-analysis.md`:

```md
# Crash analysis

Found a crash?

* Validate the cause

```
kd> !analyze -v
kd> .load \path\to\msec.dll ; !exploitable
```

* IRPs are handled sequentially, therefore the crash has to be related to at least the last
 IRP sent. CFB will store the last IRP fuzzed in `IrpDumper!g_LastTestCase` in the following 
 format:
```
struct {
UINT32 SizeOfBuffer;
BYTE Buffer[SizeOfBuffer];
}
```

So you can easily dump the last IRP from WinDbg in 3 simple steps (which can easily automated in
a WinDbg JS script):

* First get the length, for example:

```
kd> dd poi(IrpDumper!g_LastTestCase) l1
ffffe088`f37ae000  00000218
```

The data length is 0x218 bytes.


* Then you can confirm by viewing those data
```
kd> db poi(IrpDumper!g_LastTestCase+4) l218
ffffe088`f37ae004  5c 00 44 00 6f 00 73 00-44 00 65 00 76 00 69 00  \.D.o.s.D.e.v.i.
ffffe088`f37ae014  63 00 65 00 73 00 5c 00-50 00 68 00 79 00 73 00  c.e.s.\.P.h.y.s.
[...]
```

* And finally store them on the debugger host.
```
kd> .writemem C:\Whatever.raw poi(IrpDumper!g_LastTestCase+4) l218
```

All the other info (like device name, ioctl number, etc.) can be retrieved from `analyze -v` above

```

`Docs/debugging.md`:

```md

# Debugging CFB

## The Driver


### Enumerate the hooked drivers

```
dx @$drivers=Debugger.Utility.Collections.FromListEntry( IrpMonitor!Globals->DriverManager.m_Entries.m_ListHead, "IrpMonitor!CFB::Driver::HookedDriver", "Next")
```

### Check if a driver is set for data capture

```
dx @$drivers.First().Enabled == true && @$drivers.First().State == 1
```

### Enumerate the captured IRPs

```
dx @$irps=Debugger.Utility.Collections.FromListEntry( IrpMonitor!Globals->IrpManager.m_Entries.m_ListHead, "IrpMonitor!CFB::Driver::CapturedIrp", "Next")
```

```

`Docs/faq.md`:

```md
# FAQ

## LoadDriver(0) error on start

Check that you're running in Debug mode, and have test signing enabled.



## Unable to load DLL 'Core.dll' (HRESULT: 0x8007007E)

Missing Visual C++ Redist. Runtime 14.0 (`vcruntime140.dll`)

Install x68 or x64 version from [here](https://docs.microsoft.com/en-us/cpp/windows/latest-supported-vc-redist?view=msvc-170)



## Where did you get those cool icons ?

Over there : http://freeiconshop.com/

```

`Docs/fuzzing-vm-setup.md`:

```md
*Note*: unless specified all commands should be run in an Admin Powershell prompt.

## Stop and disable useless services

```powershell
# disable some features
Set-MpPreference -DisableRealtimeMonitoring $true

# disable the services
$services = @("WinDefend", "WSearch", "WerSvc", "wuauserv", "TrustedInstaller", "TroubleShootingSvc")
$services+= @("DiagTrack", "DiagSvc", "diagnosticshub.standardcollector.service")

foreach($service in $services)
{
	Stop-Service -Name $service
	Set-Service -StartupType Disabled -Name $service
}
```

## Define the crash behavior

```powershell
$crash = Get-WmiObject Win32_OSRecoveryConfiguration -EnableAllPrivileges
$crash | Set-WmiInstance -Arguments @{ AutoReboot=$False }
# 0 = None
# 1 = Complete memory dump
# 2 = Kernel memory dump
# 3 = Small memory dump
$crash | Set-WmiInstance -Arguments @{ DebugInfoType=1  }
$crash | Set-WmiInstance -Arguments @{ OverwriteExistingDebugFile=$False }
New-Item -ItemType Directory c:\dumps
$crash | Set-WmiInstance -Arguments @{ DebugFilePath="c:\dumps" }
$crash | Set-WmiInstance -Arguments @{ WriteToSystemLog=$False }
```


## Make sure the target time is synchro

```powershell
Stop-Service -Name W32Time
Push-Location
Set-Location HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\DateTime\Servers
Set-ItemProperty . 0 "10.0.0.1"
Set-ItemProperty . "(Default)" "0"
Set-Location HKLM:\SYSTEM\CurrentControlSet\services\W32Time\Parameters
Set-ItemProperty . NtpServer "10.0.0.1"
Pop-Location
Start-Service -Name W32Time
```

## Blackhole some MS domains

```powershell
Invoke-WebRequest -Uri "https://raw.githubusercontent.com/hugsy/modern.ie-vagrant/master/scripts/DisableWin10Telemetry.ps1" -OutFile "c:\temp\DisableWin10Telemetry.ps1"
Set-ExecutionPolicy Bypass
&"c:\temp\DisableWin10Telemetry.ps1"
Remove-Item "c:\temp\DisableWin10Telemetry.ps1"
```

```

`Docs/gallery.md`:

```md
# Screenshots

## Boker

## ImGUI Client

## UWP Client

### Intercepted IRP view

![Intercepted IRP view](https://i.imgur.com/xMOIIhC.png)

### IRP details

![IRP Metadata](https://i.imgur.com/zmh2QAw.png)

![IRP InputBuffer](https://i.imgur.com/j0W9ljL.png)

### IRP replay

![IRP Replay](https://i.imgur.com/9Ybq27G.png)


```

`Docs/index.html`:

```html
<!--
https://docsify.js.org/
-->
<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta charset="UTF-8">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/docsify@4/themes/vue.css" />
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.css"/>
</head>
<body>
  <div id="app"></div>
  <script>
    window.$docsify = {
      loadSidebar: true,
      subMaxLevel: 2,
      
      progress: {
        position: "top",
        color: "var(--theme-color,#42b983)",
        height: "3px",
      }
    }
  </script>
  <script src="//cdn.jsdelivr.net/npm/docsify@4"></script>
  <script src="//cdn.jsdelivr.net/npm/prismjs@1/components/prism-cpp.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/docsify/lib/plugins/emoji.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/docsify-progress@latest/dist/progress.min.js"></script>
</body>
</html>

```

`Docs/setup.md`:

```md
# Build CFB

## Pre-Build

The easiest and fastest way to get started is simply to download the artifacts from the Github Actions build workflow. They can be found [here](https://github.com/hugsy/CFB/actions/workflows/build.yml).

## Build

Building CFB requires only [`cmake`](https://cmake.org), and the Windows [SDK](https://developer.microsoft.com/en-us/windows/downloads/windows-sdk/) and [WDK](https://learn.microsoft.com/en-us/windows-hardware/drivers/download-the-wdk). In a developer prompt:

### To compile
```powershell
cd \path\to\CFB.git
mkdir build
cmake -S . -B ./build -D CFB_BUILD_TOOLS:BOOL=ON -D CFB_BUILD_GUI:BOOL=ON -A $platform
cmake --build ./build --verbose --parallel $env:NUMBER_OF_PROCESSORS --config $config
```

Where `$platform` can be:
  - `x64`
  - `arm64`

`win32` may work to build the broker. However, ImGUI doesn't compile on 32-bit.

### To install 

After building:

```powershell
mkdir artifact
cmake --install ./build --config $config --prefix ./artifact --verbose
```

Where `$config` can be:
  - `RelWithDebInfo` (you probably want this one)
  - `Debug` for debugging (very verbose outputs) 

```

`Docs/usage.md`:

```md
# Usage

A Windows 7+ machine ([Windows 10 SDK VM](https://developer.microsoft.com/en-us/windows/downloads/virtual-machines) is recommended)

On this target machine, simply enable BCD test signing flag (in `cmd.exe` as Admin):

```
bcdedit.exe /set {whatever-profile} testsigning on
```

If using in Debug mode, `IrpDumper.sys` will provide a lot more valuable information as to what's being hooked (the price of performance). All those info can be visible via tools like `DebugView.exe` or a kernel debugger like WinDbg. In either case, you must enable kernel debug BCD flag (in `cmd.exe` as Admin):

```
bcdedit.exe /set {whatever-profile} debug on
```

It is also recommended to edit the KD verbosity level, via:
  - the registry for a permanent effect (`reg add "HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\Debug Print Filter" /v DEFAULT /t REG_DWORD /d 0xf`)
  - directly from WinDbg for only the current session (`ed nt!Kd_Default_Mask 0xf`)


If you plan on (re-)compiling any of the tools, you must install VS (2019 preferred). If using the Release binaries, you only need VS C++ Redist installed(x86 or x64 depending on your VM architecture).

Follow the indications in the `Docs/` folder to improve your setup.
```

`Driver/CMakeLists.txt`:

```txt
project(IrpMonitor
    LANGUAGES CXX
    VERSION 0.2.0
    DESCRIPTION "Driver part of CFB"
)

message(STATUS "Configuring '${PROJECT_NAME}'")

set(DRIVER_SOURCE_DIR ${CFB_ROOT_DIR}/Driver/Source)
set(DRIVER_HEADER_DIR ${CFB_ROOT_DIR}/Driver/Headers)

set(DRIVER_VERSION_MAJOR ${PROJECT_VERSION_MAJOR} CACHE INTERNAL "DRIVER_VERSION_MAJOR")
set(DRIVER_VERSION_MINOR ${PROJECT_VERSION_MINOR} CACHE INTERNAL "DRIVER_VERSION_MINOR")
set(DRIVER_VERSION_PATCH ${PROJECT_VERSION_PATCH} CACHE INTERNAL "DRIVER_VERSION_PATCH")

set(DRIVER_RC_FILE ${DRIVER_SOURCE_DIR}/Driver.rc)
set(DRIVER_RES_FILE ${DRIVER_SOURCE_DIR}/Driver.res)
set(CFB_CERT_CN "${CFB_COMPANY_NAME}")
set(CFB_CERT_STORE "PrivateCertStore")
set(CFB_DRIVER_INF_FILE "${DRIVER_SOURCE_DIR}/${PROJECT_NAME}.inf")

configure_file(${DRIVER_RC_FILE}.in ${DRIVER_RC_FILE} NEWLINE_STYLE WIN32 ESCAPE_QUOTES)

set(
    DRIVER_HEADER_FILES

    ${DRIVER_HEADER_DIR}/Context.hpp
    ${DRIVER_HEADER_DIR}/Native.hpp
    ${DRIVER_HEADER_DIR}/DriverUtils.hpp
    ${DRIVER_HEADER_DIR}/HookedDriverManager.hpp
    ${DRIVER_HEADER_DIR}/HookedDriver.hpp
    ${DRIVER_HEADER_DIR}/Callbacks.hpp
    ${DRIVER_HEADER_DIR}/CapturedIrpManager.hpp
    ${DRIVER_HEADER_DIR}/CapturedIrp.hpp
)

set(
    DRIVER_SOURCE_FILES

    ${DRIVER_SOURCE_DIR}/Entry.cpp
    ${DRIVER_SOURCE_DIR}/DriverUtils.cpp
    ${DRIVER_SOURCE_DIR}/HookedDriverManager.cpp
    ${DRIVER_SOURCE_DIR}/HookedDriver.cpp
    ${DRIVER_SOURCE_DIR}/Callbacks.cpp
    ${DRIVER_SOURCE_DIR}/CapturedIrpManager.cpp
    ${DRIVER_SOURCE_DIR}/CapturedIrp.cpp
)

wdk_add_driver(
    ${PROJECT_NAME}
    KMDF
    1.15

    ${DRIVER_HEADER_FILES}
    ${DRIVER_SOURCE_FILES}
)

add_executable(CFB::Kernel::Driver ALIAS ${PROJECT_NAME})

target_include_directories(${PROJECT_NAME} PRIVATE ${DRIVER_HEADER_DIR})
target_compile_definitions(${PROJECT_NAME} PRIVATE CFB_KERNEL_DRIVER=1)
target_link_options(${PROJECT_NAME} PUBLIC /integritycheck)
target_link_libraries(${PROJECT_NAME} CFB::Kernel::CommonLib ${DRIVER_RES_FILE})

#
# Custom command directives
#
add_custom_command(
    TARGET ${PROJECT_NAME} PRE_BUILD
    COMMAND
    rc /nologo /fo ${DRIVER_RES_FILE} /r ${DRIVER_RC_FILE}
    COMMENT
    "Compiling '${DRIVER_RES_FILE}' resource file"
)

add_custom_command(
    TARGET ${PROJECT_NAME} POST_BUILD
    COMMAND
    makecert.exe -r -pe -ss ${CFB_CERT_STORE} -n CN="${CFB_CERT_CN}" -eku 1.3.6.1.5.5.7.3.3 "$<TARGET_FILE_DIR:${PROJECT_NAME}>/BlahCatTest.cer"
    COMMAND
    signtool.exe sign /v /a /fd SHA256 /s ${CFB_CERT_STORE} /n "${CFB_CERT_CN}" $<TARGET_FILE:${PROJECT_NAME}>
    COMMAND
    certmgr.exe -del -c -n "${CFB_CERT_CN}" -s -r currentUser ${CFB_CERT_STORE}
    COMMAND
    "${CMAKE_COMMAND}" -E copy_if_different $<TARGET_FILE:${PROJECT_NAME}> "$ENV{TEMP}"
    COMMENT
    "Sign driver, copy to tempdir"
)

#
# Install directives
#
install(TARGETS ${PROJECT_NAME} DESTINATION Driver)
install(FILES $<TARGET_PDB_FILE:${PROJECT_NAME}> DESTINATION Driver OPTIONAL)
install(FILES ${CFB_DRIVER_INF_FILE} DESTINATION Driver OPTIONAL)
install(FILES "$<TARGET_FILE_DIR:${PROJECT_NAME}>/BlahCatTest.cer" DESTINATION Driver OPTIONAL)

```

`Driver/Client/CMakeLists.txt`:

```txt
set(DRIVER_CLIENT_SOURCE_DIR ${CFB_ROOT_DIR}/Driver/Client)

set(
    SOURCE_FILES

    ${DRIVER_CLIENT_SOURCE_DIR}/Main.cpp
)

add_executable(DriverClient WIN32)
add_executable(CFB::Tools::DriverClient ALIAS DriverClient)
target_sources(DriverClient PUBLIC ${SOURCE_FILES})
target_compile_features(DriverClient PRIVATE cxx_std_20)

add_dependencies(
    DriverClient
    CFB::Kernel::Driver
    CFB::User::CommonLib
)

if(DEBUG)
    target_compile_definitions(DriverClient PRIVATE _DEBUG=1 DEBUG=1)
endif(DEBUG)

target_include_directories(
    DriverClient
    PRIVATE
)

target_link_libraries(DriverClient
    PRIVATE
    CFB::User::CommonLib
    argparse::argparse
    WIL::WIL
)

target_compile_options(DriverClient
    PUBLIC
    $<$<COMPILE_LANGUAGE:CXX>:/Zc:__cplusplus>

    PRIVATE
    $<IF:$<CONFIG:Debug>,/WX /Gm- /permissive-,/WX /permissive>
    $<$<NOT:$<STREQUAL:${CMAKE_GENERATOR_PLATFORM},arm64>>:$<$<CONFIG:Debug>:/fsanitize=address>>
)

target_link_options(DriverClient
    PUBLIC
    /SUBSYSTEM:Console

    PRIVATE
    $<$<NOT:$<STREQUAL:${CMAKE_GENERATOR_PLATFORM},arm64>>:$<$<CONFIG:Debug>:/InferAsanLibs>>
)

install(TARGETS DriverClient DESTINATION Tools)
install(FILES $<TARGET_PDB_FILE:DriverClient> DESTINATION Tools OPTIONAL)

```

`Driver/Client/Main.cpp`:

```cpp
#define NOMINMAX
#undef _UNICODE
#undef UNICODE

// clang-format off
#include <algorithm>
#include <codecvt>
#include <iostream>

#include <stdexcept>
#include <string>
#include <utility>
#include <vector>

#include <argparse/argparse.hpp>
#include <wil/resource.h>
// clang-format on

#define CFB_NS "[CFB::Test::DriverClient]"

#include "Common.hpp"
#include "Comms.hpp"
#include "IoctlCodes.hpp"
#include "Log.hpp"
#include "Utils.hpp"


namespace Driver
{
bool
Hook(HANDLE hFile, std::string const& arg)
{
    DWORD nb                    = 0;
    std::wstring driver_name    = CFB::Utils::ToWideString(arg);
    const usize driver_name_len = std::min(driver_name.length() * 2, (usize)CFB_DRIVER_MAX_PATH);

    bool bSuccess = ::DeviceIoControl(
        hFile,
        static_cast<std::underlying_type<CFB::Comms::Ioctl>::type>(CFB::Comms::Ioctl::HookDriver),
        driver_name.data(),
        driver_name_len,
        nullptr,
        0,
        &nb,
        nullptr);
    info("HookDriver() returned %s", boolstr(bSuccess));

    if ( !bSuccess )
        return false;

    return true;
}

bool
Unhook(HANDLE hFile, std::string const& arg)
{
    DWORD nb                    = 0;
    std::wstring driver_name    = CFB::Utils::ToWideString(arg);
    const usize driver_name_len = std::min(driver_name.length() * 2, (usize)CFB_DRIVER_MAX_PATH);

    bool bSuccess = ::DeviceIoControl(
        hFile,
        static_cast<std::underlying_type<CFB::Comms::Ioctl>::type>(CFB::Comms::Ioctl::UnhookDriver),
        driver_name.data(),
        driver_name_len,
        nullptr,
        0,
        &nb,
        nullptr);
    info("UnhookDriver() returned %s", boolstr(bSuccess));

    if ( !bSuccess )
        return false;

    return true;
}


HANDLE
SetNotificationEvent(HANDLE hFile)
{
    DWORD nbBytesReturned = 0;
    HANDLE hEvent         = ::CreateEventA(nullptr, true, false, "CFB_IRP_EVENT");

    bool bSuccess = ::DeviceIoControl(
        hFile,
        static_cast<std::underlying_type<CFB::Comms::Ioctl>::type>(CFB::Comms::Ioctl::SetEventPointer),
        &hEvent,
        sizeof(HANDLE),
        nullptr,
        0,
        &nbBytesReturned,
        nullptr);
    info("SetEventPointer() returned %s", boolstr(bSuccess));

    return hEvent;
}


bool
GetNumberOfDrivers(HANDLE hFile)
{
    DWORD nbBytesReturned = 0;
    bool bSuccess         = ::DeviceIoControl(
        hFile,
        static_cast<std::underlying_type<CFB::Comms::Ioctl>::type>(CFB::Comms::Ioctl::GetNumberOfDrivers),
        nullptr,
        0,
        nullptr,
        0,
        &nbBytesReturned,
        nullptr);
    info("GetNumberOfDrivers() returned %s", boolstr(bSuccess));

    if ( bSuccess )
    {
        ok("There's currently %d driver%s hooked", nbBytesReturned, PLURAL_IF(nbBytesReturned > 1));
    }

    return bSuccess;
}

bool
ToggleMonitoring(HANDLE hFile, std::string const& arg, bool enable)
{
    std::wstring driver_name     = CFB::Utils::ToWideString(arg);
    const usize driver_name_len  = driver_name.length() * 2;
    const usize msglen           = std::min(driver_name_len, (usize)CFB_DRIVER_MAX_PATH);
    const CFB::Comms::Ioctl code = enable ? CFB::Comms::Ioctl::EnableMonitoring : CFB::Comms::Ioctl::DisableMonitoring;

    DWORD nbBytesReturned = 0;
    bool bSuccess         = ::DeviceIoControl(
        hFile,
        static_cast<std::underlying_type<CFB::Comms::Ioctl>::type>(code),
        driver_name.data(),
        msglen,
        nullptr,
        0,
        &nbBytesReturned,
        nullptr);
    info("ToggleMonitoring('%S', enable=%s) returned %s", driver_name.c_str(), boolstr(enable), boolstr(bSuccess));

    return bSuccess;
}


bool
SendData(std::string const& device_name, const u32 ioctl, std::vector<u8>& buffer_in)
{
    wil::unique_handle hFile(::CreateFileA(
        device_name.c_str(),
        GENERIC_WRITE | GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        nullptr,
        OPEN_EXISTING,
        0,
        nullptr));
    if ( !hFile )
    {
        err("CreateFileA(%s) failed", device_name.c_str());
        return false;
    }

    DWORD nbBytesReturned = 0;
    bool bSuccess         = ::DeviceIoControl(
        hFile.get(),
        ioctl,
        buffer_in.data(),
        buffer_in.size(),
        nullptr,
        0,
        &nbBytesReturned,
        nullptr);
    info("SendData('%s', %dB) returned %s", device_name.c_str(), buffer_in.size(), boolstr(bSuccess));

    return bSuccess;
}

std::optional<u32>
ReceiveData(HANDLE hFile)
{
    DWORD expectedDataLength = 1024;

    while ( true )
    {
        const DWORD dataLength = expectedDataLength;
        auto data              = std::make_unique<u8[]>(dataLength);
        bool bRes              = ::ReadFile(hFile, data.get(), dataLength, &expectedDataLength, nullptr);
        info("ReceiveData(data, %d) = %s", dataLength, boolstr(bRes));
        if ( bRes == false )
        {
            if ( ::GetLastError() == ERROR_INSUFFICIENT_BUFFER )
            {
                expectedDataLength = dataLength * 2;
                continue;
            }
            err("ReadFile() failed, GLE %#x", ::GetLastError());
            return std::nullopt;
        }

        CFB::Utils::Hexdump(data.get(), dataLength);
        return dataLength;
    }
}

} // namespace Driver

int
main(int argc, const char** argv)
{
    argparse::ArgumentParser program("DriverClient");

    const std::vector<std::string> valid_actions =
        {"hook", "unhook", "size", "monitor", "unmonitor", "send", "recv", "session"};

    program.add_argument("--action")
        .default_value(std::string("hook"))
        .action(
            [&valid_actions](const std::string& value)
            {
                if ( std::find(valid_actions.begin(), valid_actions.end(), value) != valid_actions.end() )
                {
                    return value;
                }
                throw std::runtime_error("invalid action");
            });

    program.add_argument("--driver").default_value(std::string("\\driver\\hevd"));
    program.add_argument("--device").default_value(std::string("\\\\.\\HackSysExtremeVulnerableDriver"));
    program.add_argument("--ioctl").scan<'i', int>().default_value(0x222003); // BUFFER_OVERFLOW_STACK

    try
    {
        program.parse_args(argc, argv);
    }
    catch ( const std::runtime_error& err )
    {
        std::cerr << err.what() << "\n" << program;
        std::exit(1);
    }

    const auto action      = program.get<std::string>("--action");
    const auto driver_name = program.get<std::string>("--driver");
    const auto device_name = program.get<std::string>("--device");
    const auto ioctl       = program.get<int>("--ioctl");

    wil::unique_handle hEvent;

    info("Getting a handle to '%S'", CFB_DEVICE_PATH);
    wil::unique_handle hFile(
        ::CreateFileW(CFB_USER_DEVICE_PATH, GENERIC_WRITE | GENERIC_READ, 0, nullptr, OPEN_EXISTING, 0, nullptr));
    if ( !hFile )
    {
        err("Failed to open '%S'", CFB_DEVICE_NAME);
        return -1;
    }

    ok("Got handle to '%S' as %p", CFB_DEVICE_PATH, hFile.get());

    if ( action == "hook" )
    {
        Driver::Hook(hFile.get(), driver_name);
    }
    else if ( action == "unhook" )
    {
        Driver::Unhook(hFile.get(), driver_name);
    }
    else if ( action == "size" )
    {
        Driver::GetNumberOfDrivers(hFile.get());
    }
    else if ( action == "monitor" )
    {
        Driver::ToggleMonitoring(hFile.get(), driver_name, true);
    }
    else if ( action == "unmonitor" )
    {
        Driver::ToggleMonitoring(hFile.get(), driver_name, false);
    }
    else if ( action == "send" )
    {
        const usize sz {0x100};
        auto buffer_in = std::vector<u8>(sz);
        ::memset(buffer_in.data(), 'A', sz);
        Driver::SendData(device_name, ioctl, buffer_in);
    }
    else if ( action == "recv" )
    {
        Driver::ReceiveData(hFile.get());
    }
    else if ( action == "session" )
    {
        Driver::Hook(hFile.get(), driver_name);

        Driver::GetNumberOfDrivers(hFile.get());

        hEvent = wil::unique_handle(Driver::SetNotificationEvent(hFile.get()));

        Driver::ToggleMonitoring(hFile.get(), driver_name, true);

        for ( int i = 0; i < 2; i++ )
        {
            const usize sz {0x100};
            auto buffer_in  = std::vector<u8>(sz);
            auto buffer_out = std::vector<u8>(sz);
            ::memset(buffer_in.data(), 'A', sz);

            Driver::SendData(device_name, ioctl, buffer_in);

            u32 Status = ::WaitForSingleObject(hEvent.get(), 1 * 1000);
            switch ( Status )
            {
            case WAIT_OBJECT_0:
                ok("New data event received");
                break;

            case WAIT_TIMEOUT:
                warn("WaitForSingleObject() timed out");
                continue;

            default:
                err("WaitForSingleObject() returned %#x", Status);
                i = 10000000;
                continue;
            }

            Driver::ReceiveData(hFile.get());
        }

        Driver::ToggleMonitoring(hFile.get(), driver_name, false);

        Driver::Unhook(hFile.get(), driver_name);
    }
    else
    {
        err("Unknown action %S", action.c_str());
    }

    return 0;
}

```

`Driver/Headers/Callbacks.hpp`:

```hpp
#pragma once


#include "Common.hpp"

namespace CFB::Driver::Callbacks
{
///
/// @brief This is the main interception routine: it will find the HookedDriver  associated to a DeviceObject. If
/// any is found, and capture mode is enabled the IRP data will be pushed to the queue of captured data.
///
/// @param DeviceObject
/// @param Irp
/// @return NTSTATUS
///
NTSTATUS
InterceptGenericRoutine(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp);

///
/// @brief
///
/// @param DeviceObject
/// @param Irp
/// @return NTSTATUS
///
NTSTATUS
InterceptedDeviceControlRoutine(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp);

///
/// @brief The ReadFile() interception routine wrapper.
///
/// @param DeviceObject
/// @param Irp
/// @return NTSTATUS STATUS_SUCCESS on success.
///
NTSTATUS
InterceptedReadRoutine(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp);

///
/// @brief The WriteFile() interception routine wrapper.
///
/// @param DeviceObject
/// @param Irp
/// @return NTSTATUS
///
NTSTATUS
InterceptedWriteRoutine(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp);

///
///@brief
///
///@param DeviceObject
///@param Type
///@param Buffer
///@param BufferLength
///@param IoControlCode
///@param Flags
///@param pIrpOut
///@return BOOLEAN
///
BOOLEAN
InterceptGenericFastIoRoutine(
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ UINT32 Type,
    _In_ PVOID Buffer,
    _In_ ULONG BufferLength,
    _In_ ULONG IoControlCode,
    _In_ UINT32 Flags,
    _Inout_ PVOID* pIrpOut);

///
/// @brief The `InterceptGenericFastIoDeviceControl()` interception routine wrapper.
///
/// @param FileObject
/// @param Wait
/// @param InputBuffer
/// @param InputBufferLength
/// @param OutputBuffer
/// @param OutputBufferLength
/// @param IoControlCode
/// @param IoStatus
/// @param DeviceObject
/// @return BOOLEAN
///
BOOLEAN
InterceptGenericFastIoDeviceControl(
    _In_ PFILE_OBJECT FileObject,
    _In_ BOOLEAN Wait,
    _In_opt_ PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_opt_ PVOID OutputBuffer,
    _In_ ULONG OutputBufferLength,
    _In_ ULONG IoControlCode,
    _Out_ PIO_STATUS_BLOCK IoStatus,
    _In_ PDEVICE_OBJECT DeviceObject);

///
/// @brief The `InterceptGenericFastIoRead()` interception routine wrapper.
///
/// @param FileObject
/// @param FileOffset
/// @param BufferLength
/// @param Wait
/// @param LockKey
/// @param Buffer
/// @param IoStatus
/// @param DeviceObject
///
/// @return BOOLEAN
///
BOOLEAN
InterceptGenericFastIoRead(
    _In_ PFILE_OBJECT FileObject,
    _In_ PLARGE_INTEGER FileOffset,
    _In_ ULONG Length,
    _In_ BOOLEAN Wait,
    _In_ ULONG LockKey,
    _Out_ PVOID Buffer,
    _Out_ PIO_STATUS_BLOCK IoStatus,
    _In_ PDEVICE_OBJECT DeviceObject);

///
/// @brief The InterceptGenericFastIoWrite() interception routine wrapper.
///
/// @param FileObject
/// @param FileOffset
/// @param Length
/// @param Wait
/// @param LockKey
/// @param Buffer
/// @param IoStatus
/// @param DeviceObject
///
/// @return BOOLEAN
///
BOOLEAN
InterceptGenericFastIoWrite(
    _In_ PFILE_OBJECT FileObject,
    _In_ PLARGE_INTEGER FileOffset,
    _In_ ULONG Length,
    _In_ BOOLEAN Wait,
    _In_ ULONG LockKey,
    _Out_ PVOID Buffer,
    _Out_ PIO_STATUS_BLOCK IoStatus,
    _In_ PDEVICE_OBJECT DeviceObject);
} // namespace CFB::Driver::Callbacks

```

`Driver/Headers/CapturedIrp.hpp`:

```hpp
#pragma once

// clang-format off
#include "Common.hpp"
#include "Comms.hpp"

#include "DriverUtils.hpp"
#include "HookedDriver.hpp"
// clang-format on

namespace Comms = CFB::Comms;
namespace Utils = CFB::Driver::Utils;

namespace CFB::Driver
{

///
///@brief `CapturedIrp` contains all the information stored from the IRP hijacking
///
class CapturedIrp
{
public:
    enum class IrpType : u8
    {
        Irp          = 0x00,
        FastIo_Ioctl = 0x80,
        FastIo_Read  = 0x81,
        FastIo_Write = 0x82,
    };

    enum class Flags : u32
    {
        UseOutputBuffer  = (1 << 0),
        UseInputBuffer   = (1 << 1),
        InitQueueMessage = (1 << 2),
    };


    ///
    ///@brief Construct a new Captured Irp object
    ///
    ///@param Type
    ///@param DeviceObject
    ///
    CapturedIrp(const IrpType Type, const PDEVICE_OBJECT DeviceObject);

    ///
    ///@brief Destroy the Captured Irp object
    ///
    ///
    ~CapturedIrp();

    ///
    ///@brief CapturedIrp memory allocator
    ///
    ///@param sz
    ///@return void*
    ///
    static void*
    operator new(usize sz)
    {
        void* Memory = ::ExAllocatePoolWithTag(NonPagedPoolNx, sz, CFB_DEVICE_TAG);
        if ( !Memory )
        {
            ::ExRaiseStatus(STATUS_NO_MEMORY);
        }
        dbg("Allocated CapturedIrp at %p", Memory);
        ::RtlSecureZeroMemory(Memory, sz);
        return Memory;
    }

    ///
    ///@brief CapturedIrp memory destructor
    ///
    ///@param Memory
    ///
    static void
    operator delete(void* Memory)
    {
        dbg("Deallocating CapturedIrp at %p", Memory);
        return ::ExFreePoolWithTag(Memory, CFB_DEVICE_TAG);
    }

    ///
    ///@brief Capture the meta-data and content of the IRP *before* passing it down to the legit driver
    ///
    ///@param Irp
    ///@return NTSTATUS
    ///
    NTSTATUS
    CapturePreCallData(_In_ PIRP Irp);

    ///
    ///@brief Capture the meta-data and content of the IRP *after* passing it down to the legit driver
    ///
    ///@param Irp
    ///@param ReturnedIoctlStatus
    ///@return NTSTATUS
    ///
    NTSTATUS
    CapturePostCallData(_In_ PIRP Irp, _In_ NTSTATUS ReturnedIoctlStatus);

    ///
    ///@brief Capture the meta-data and content of the Fast IRP *before* passing it down to the legit driver
    ///
    ///@param InputBuffer
    ///@param IoControlCode
    ///@return NTSTATUS
    ///
    NTSTATUS
    CapturePreCallFastIoData(_In_opt_ PVOID InputBuffer, _In_ ULONG IoControlCode);

    ///
    ///@brief Capture the meta-data and content of the Fast IRP *after* passing it down to the legit driver
    ///
    ///@param OutputBuffer
    ///@return NTSTATUS
    ///
    NTSTATUS
    CapturePostCallFastIoData(_Out_opt_ PVOID OutputBuffer);

    ///
    ///@brief Total size of captured data (i.e. sizeof(in) + sizeof(out)) including the header
    ///
    ///@return usize const
    ///
    usize const
    Size() const;

    ///
    ///@brief Total size of of captured data (i.e. sizeof(in) + sizeof(out))
    ///
    ///@return usize const
    ///
    usize const
    DataSize() const;

    ///
    ///@brief Size of of captured input data
    ///
    ///@return usize const
    ///
    usize const
    InputDataSize() const;

    ///
    ///@brief Size of of captured output data
    ///
    ///@return usize const
    ///
    usize const
    OutputDataSize() const;

    ///
    ///@brief Return a raw pointer to the hooked driver
    ///
    ///@return HookedDriver* const
    ///
    HookedDriver* const
    AssociatedDriver() const;

    ///
    ///@brief Entry to the next catpured IRP
    ///
    ///
    LIST_ENTRY Next;

    ///
    ///@brief Generate an exportable CapturedIrp header object
    ///
    ///@return Comms::CapturedIrpHeader
    ///
    Comms::CapturedIrpHeader
    ExportHeader() const;

    ///
    ///@brief Raw pointer to the captured input buffer
    ///
    ///@return u8*
    ///
    u8*
    InputBuffer() const;

    ///
    ///@brief Raw pointer to the captured output buffer
    ///
    ///@return u8*
    ///
    u8*
    OutputBuffer() const;

    ///
    ///@brief Indicates whether the CapturedIrp was successfully initialized
    ///
    ///@return true
    ///@return false
    ///
    bool
    IsValid() const;

private:
    bool m_Valid;
    LARGE_INTEGER m_TimeStamp;
    u8 m_Irql;
    IrpType m_Type;
    u8 m_MajorFunction;
    u8 m_MinorFunction;
    u32 m_IoctlCode;
    u32 m_Pid;
    u32 m_Tid;
    NTSTATUS m_Status;
    Utils::KAlloc<u8*> m_InputBuffer;
    Utils::KAlloc<u8*> m_OutputBuffer;
    PDEVICE_OBJECT m_DeviceObject;
    Utils::KUnicodeString m_DriverName;
    Utils::KUnicodeString m_DeviceName;
    Utils::KUnicodeString m_ProcessName;
    HookedDriver* m_Driver;
};

} // namespace CFB::Driver

```

`Driver/Headers/CapturedIrpManager.hpp`:

```hpp
#pragma once

#include "CapturedIrp.hpp"
#include "Common.hpp"
#include "DriverUtils.hpp"

namespace Utils = CFB::Driver::Utils;

namespace CFB::Driver
{
class CapturedIrpManager
{
public:
    ///
    /// @brief Construct a new Data Collector object
    ///
    CapturedIrpManager();

    ///
    /// @brief Destroy the Data Collector object
    ///
    ~CapturedIrpManager();

    ///
    /// @brief Get a reference to the linked list items stored in this container
    ///
    /// @return Utils::LinkedList<CapturedIrp>&
    ///
    Utils::LinkedList<CapturedIrp>&
    Items();

    ///
    /// @brief Set the Event object
    ///
    /// @param hEvent An Event handle
    ///
    /// @return NTSTATUS
    ///
    NTSTATUS
    SetEvent(const HANDLE hEvent);

    ///
    /// @brief Push data to the back of the queue
    ///
    /// @return true
    /// @return false
    ///
    bool
    Push(CapturedIrp* Item);

    ///
    /// @brief Pop the front of the queue
    ///
    /// @return true
    /// @return false
    ///
    CapturedIrp*
    Pop();

    ///
    /// @brief Flush the data in the container
    ///
    void
    Clear();

    ///
    /// @brief
    ///
    /// @return Utils::KCriticalRegion const&
    ///
    Utils::KCriticalRegion&
    CriticalRegion();

private:
    ///
    /// @brief Set when new data is pushed
    ///
    PKEVENT m_Event;

    ///
    /// @brief Item count
    ///
    usize m_Count;

    ///
    /// @brief
    ///
    Utils::LinkedList<CapturedIrp> m_Entries;

    ///
    /// @brief
    ///
    Utils::KFastMutex m_Mutex;

    ///
    /// @brief
    ///
    Utils::KCriticalRegion m_CriticalRegion;
};

} // namespace CFB::Driver

```

`Driver/Headers/Context.hpp`:

```hpp
#pragma once

// clang-format off
#include "Common.hpp"
#include "DriverUtils.hpp"
#include "Log.hpp"

#include "CapturedIrpManager.hpp"
#include "HookedDriverManager.hpp"
// clang-format on


#define CFB_MAX_HEXDUMP_BYTE 64

namespace Driver = CFB::Driver;
namespace Utils  = CFB::Driver::Utils;

struct GlobalContext
{
    ///
    /// @brief Any critical read/write operation to the global context structure must acquire this lock.
    ///
    Utils::KQueuedSpinLock ContextLock;

    ///
    /// @brief A pointer to the device object
    ///
    PDRIVER_OBJECT DriverObject;

    ///
    /// @brief A pointer to the device object
    ///
    PDEVICE_OBJECT DeviceObject;

    ///
    /// @brief A pointer to the EPROCESS of the broker. Not more than one handle to the
    /// device is allowed.
    ///
    PEPROCESS Owner;

    ///
    /// @brief Incremental session ID number.
    ///
    ULONG SessionId;

    ///
    /// @brief Manages the hooked drivers
    ///
    Driver::HookedDriverManager DriverManager;

    ///
    /// @brief Where all the intercepted IRPs are stored
    ///
    Driver::CapturedIrpManager IrpManager;


    GlobalContext() : DriverObject {nullptr}, DeviceObject {nullptr}, Owner {nullptr}, ContextLock {}, SessionId(-1)
    {
        dbg("Creating GlobalContext");
    }


    ~GlobalContext()
    {
        dbg("Destroying GlobalContext");
        DriverObject = nullptr;
        DeviceObject = nullptr;
        Owner        = nullptr;
    }

    static void*
    operator new(usize sz)
    {
        void* Memory = ::ExAllocatePoolWithTag(NonPagedPoolNx, sz, CFB_DEVICE_TAG);
        if ( Memory )
        {
            dbg("Allocated GlobalContext at %p", Memory);
            ::RtlSecureZeroMemory(Memory, sz);
        }
        return Memory;
    }

    static void
    operator delete(void* m)
    {
        dbg("Deallocating GlobalContext");
        ::ExFreePoolWithTag(m, CFB_DEVICE_TAG);
        m = nullptr;
        return;
    }
};

///
/// @brief Reference to the global driver context.
///
extern struct GlobalContext* Globals;

```

`Driver/Headers/DriverUtils.hpp`:

```hpp
#pragma once

#include "Common.hpp"
#include "Log.hpp"
#include "Utils.hpp"


void* __cdecl
operator new(size_t Size, POOL_TYPE PoolType = NonPagedPoolNx, ULONG PoolTag = CFB_DEVICE_TAG);

void __cdecl
operator delete(void* Memory, usize Size);

void* __cdecl
operator new[](size_t Size, POOL_TYPE PoolType);

void __cdecl
operator delete[](void* Memory, usize Size);

template<typename T>
T&
move(T& other)
{
    return static_cast<T&&>(other);
}

namespace CFB::Driver::Utils
{

//////
///@brief
///
///@param Level
///@return const char*
///
///
/// @param Level
/// @return const char*
///
const char*
ToString(KIRQL const Level);

///
/// @brief Typed class for locking/unlocking a specific type to a scope
///
/// @tparam T
///
template<typename T>
class ScopedLock
{
public:
    ScopedLock(T& lock) : _lock(lock)
    {
        _lock.Lock();
        dbg("ScopedLock(rsrc=%p)", &_lock);
    }

    ~ScopedLock()
    {
        _lock.Unlock();
        dbg("~ScopedLock(rsrc=%p)", &_lock);
    }

    ScopedLock(const ScopedLock&) = delete;

    ScopedLock(const ScopedLock&&) = delete;

    ScopedLock&
    operator=(const ScopedLock& other) = delete;

    ScopedLock&
    operator=(const ScopedLock&& other) = delete;

private:
    T& _lock;
};


///
/// @brief
///
///
class ScopedIrql
{
public:
    ScopedIrql(KIRQL level) : m_NewIrql(level)
    {
        KeRaiseIrql(m_NewIrql, &m_OldIrql);
        dbg("ScopedIrql(): IRQL %s -> %s", ToString(m_OldIrql), ToString(m_NewIrql));
    }

    ~ScopedIrql()
    {
        KeLowerIrql(m_OldIrql);
        dbg("~ScopedIrql(): IRQL %d <- %d", ToString(m_OldIrql), ToString(m_NewIrql));
    }

private:
    KIRQL m_OldIrql;
    KIRQL m_NewIrql;
};


///
/// @brief
///
/// @tparam T
/// @tparam D
///
template<typename T, typename D>
class ScopedWrapper
{
public:
    ScopedWrapper(T& f, D d) : _f(f), _d(d)
    {
    }

    ~ScopedWrapper()
    {
        _d();
    }

    T
    get() const
    {
        return _f;
    }

private:
    T& _f;
    D _d;
};


///
/// @brief Generic allocator in the kernel
///
/// @tparam T
///
template<typename T>
class KAlloc
{
public:
    KAlloc(const usize sz = 0, const u32 tag = CFB_DEVICE_TAG, POOL_TYPE type = NonPagedPoolNx) :
        m_PoolType(type),
        m_PoolTag(tag),
        m_Size(sz),
        m_Buffer(nullptr)
    {
        if ( sz )
        {
            allocate(CFB::Utils::Memory::AlignValue(sz, 0x10));
        }
    }

    ~KAlloc()
    {
        if ( valid() )
        {
            free();
        }
    }

    //
    // No copy/move constructor or copy assignment
    //
    KAlloc(const KAlloc&) = delete;
    KAlloc(KAlloc&&)      = delete;
    KAlloc&
    operator=(const KAlloc& other) noexcept = delete;

    //
    // Move assignment ok to allow:
    // KAlloc a;
    // [...]
    // a = KAlloc(...)
    //
    KAlloc&
    operator=(KAlloc&& other) noexcept
    {
        if ( this != &other )
        {
            // if allocated, free first
            free();

            m_Buffer  = other.m_Buffer;
            m_PoolTag = other.m_PoolTag;
            m_Size    = other.m_Size;

            other.m_Size    = 0;
            other.m_PoolTag = 0;
            other.m_Buffer  = nullptr;
        }
        return *this;
    }

    T
    operator[](usize idx)
    {
        return m_Buffer[idx];
    }

    const T&
    get() const
    {
        return m_Buffer;
    }

    const usize
    size() const
    {
        return m_Size;
    }

    bool
    valid() const
    {
        return m_Buffer != nullptr && m_Size > 0;
    }

    operator bool() const
    {
        return valid();
    }

    friend bool
    operator==(KAlloc const& lhs, KAlloc const& rhs)
    {
        if ( lhs.m_Size != rhs.m_Size || lhs.m_PoolTag != rhs.m_PoolTag )
        {
            return false;
        }

        return ::RtlCompareMemory((PVOID)lhs.m_Buffer, (PVOID)rhs.m_Buffer, lhs.m_Size);
    }

protected:
    virtual void
    allocate(const usize sz)
    {
        if ( sz > 0 )
        {
            auto p = ::ExAllocatePoolWithTag(m_PoolType, sz, m_PoolTag);
            if ( !p )
            {
                ::ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
            }

            m_Buffer = reinterpret_cast<T>(p);
            ::RtlSecureZeroMemory((PVOID)m_Buffer, sz);
        }
        dbg("KAlloc::allocate(%d) = %p", sz, m_Buffer);
    }

    virtual void
    free()
    {
        dbg("KAlloc::free(%p)", m_Buffer);
        if ( valid() )
        {
            ::RtlSecureZeroMemory((PUCHAR)m_Buffer, m_Size);
            ::ExFreePoolWithTag(m_Buffer, m_PoolTag);
            m_Buffer  = nullptr;
            m_PoolTag = 0;
            m_Size    = 0;
        }
    }

    T m_Buffer;
    usize m_Size;
    u32 m_PoolTag;
    POOL_TYPE m_PoolType;
};


class KUnicodeString
{
public:
    ///
    /// @brief Creates a managed KUnicodeString from a widechar buffer and length. The resulting buffer is guaranteed
    /// to be null-finished
    ///
    /// @param src pointer to the beginning of the string
    /// @param srcsz the number of bytes to use to store the unicode string
    /// @param type the pool type to store the buffer in
    ///
    KUnicodeString(const wchar_t* src, const u16 srcsz, const POOL_TYPE type = NonPagedPoolNx);

    ///
    ///@brief Construct a new KUnicodeString object from a pointer to a moved UNICODE_STRING pointer. Since
    /// KUnicodeString is owned, the pointer is a wrapper of the structure and should become the sole owner (handling
    /// deleting).
    ///
    ///@param src
    ///@param type
    ///
    KUnicodeString(PUNICODE_STRING&& src, const POOL_TYPE type = NonPagedPoolNx);

    ///
    ///@brief Construct a new KUnicodeString object from a reference to a UNICODE_STRING which is copied to become the
    /// managed object.
    ///
    ///@param src
    ///@param type
    ///
    KUnicodeString(PUNICODE_STRING const& src, const POOL_TYPE type = NonPagedPoolNx);


    ///
    ///@brief Copy constructor for KUnicodeString
    ///
    ///@param other
    ///
    KUnicodeString(const KUnicodeString& other);

    ///
    ///@brief Default constructor
    ///
    ///
    KUnicodeString() = default;

    ///
    ///@brief Destroy the KUnicodeString object
    ///
    ~KUnicodeString();


    KUnicodeString&
    operator=(const KUnicodeString& other) noexcept;


    KUnicodeString&
    operator=(KUnicodeString&& other) noexcept;

    ///
    ///@brief KUnicodeString comparison
    ///
    ///@param other
    ///@return true
    ///@return false
    ///
    bool
    operator==(KUnicodeString const& other);

    ///
    ///@brief String comparison to UNICODE_STRING pointer
    ///
    ///@param other
    ///@return true
    ///@return false
    ///
    bool
    operator==(PUNICODE_STRING const& other);

    ///
    ///@brief Get a direct pointer to the wchar_t* data
    ///
    ///@return const wchar_t*
    ///
    const wchar_t*
    data() const;

    ///
    ///@brief Get a pointer to the PUNICODE_STRING
    ///
    ///@return const PUNICODE_STRING
    ///
    const PUNICODE_STRING
    get() const;

    ///
    /// @brief Get the length of the buffer (i.e. number of bytes)
    ///
    /// @return const usize
    ///
    const usize
    size() const;

    ///
    /// @brief Get the maximum length of the buffer (i.e. number of bytes)
    ///
    /// @return const usize
    ///
    const usize
    capacity() const;

protected:
    UNICODE_STRING m_UnicodeString {};
    KAlloc<wchar_t*> m_StringBuffer {};
};


///
/// @brief Wrapper for KMUTEX
///
class KMutex
{
public:
    ///
    /// @brief
    ///
    KMutex();

    ///
    /// @brief
    ///
    ~KMutex();

    ///
    /// @brief
    ///
    void
    Lock();

    ///
    /// @brief
    ///
    void
    Unlock();

private:
    KMUTEX _mutex = {0};
};


///
/// @brief Wrapper for FAST_MUTEXes
///
///
class KFastMutex
{

public:
    ///
    /// @brief
    ///
    KFastMutex();

    ///
    /// @brief
    ///
    ~KFastMutex();

    ///
    /// @brief
    ///
    void
    Lock();

    ///
    /// @brief
    ///
    void
    Unlock();

private:
    FAST_MUTEX _mutex = {0};
};


///
/// @brief Wrapper for kernel critical region
///
///
class KCriticalRegion
{

public:
    ///
    /// @brief Construct a new KCriticalRegion object
    ///
    KCriticalRegion();

    ///
    /// @brief Destroy the KCriticalRegion object
    ///
    ~KCriticalRegion();

    ///
    /// @brief
    ///
    void
    Lock();

    ///
    /// @brief
    ///
    void
    Unlock();

private:
    ERESOURCE _mutex = {0};
};


///
/// @brief Wrapper for KSPIN_LOCK
///
class KSpinLock
{
public:
    ///
    /// @brief
    ///
    KSpinLock();

    ///
    /// @brief
    ///
    ~KSpinLock();

    ///
    /// @brief
    ///
    void
    Lock();

    ///
    /// @brief
    ///
    void
    Unlock();

private:
    KSPIN_LOCK _SpinLock = 0;
    KIRQL _OldIrql       = 0;
};


///
/// @brief Wrapper for queued KSPIN_LOCK
///
class KQueuedSpinLock
{
public:
    KQueuedSpinLock();

    ~KQueuedSpinLock();

    void
    Lock();

    void
    Unlock();

private:
    KSPIN_LOCK _SpinLock                = 0;
    KLOCK_QUEUE_HANDLE _LockQueueHandle = {0};
};


///
/// @brief Linked list class: to be able to be linked, `T` class must have a LIST_ENTRY member
/// named `Next`
///
/// @tparam T
///
template<typename T>
class LinkedList
{
public:
    LinkedList() : m_TotalEntry(0), m_Mutex()
    {
        ::InitializeListHead(&m_ListHead);
    };

    usize
    Size() const
    {
        return m_TotalEntry;
    }

    void
    PushBack(T* NewEntry)
    {
        ScopedLock lock(m_Mutex);
        ::InsertTailList(&m_ListHead, &NewEntry->Next);
        m_TotalEntry++;
    }

    void
    PushFront(T* NewEntry)
    {
        ScopedLock lock(m_Mutex);
        ::InsertHeadList(&m_ListHead, &NewEntry->Next);
        m_TotalEntry++;
    }

    void
    operator+=(T* NewEntry)
    {
        PushBack(NewEntry);
    }

    bool
    Remove(T* Entry)
    {
        ScopedLock lock(m_Mutex);
        bool bSuccess = ::RemoveEntryList(&Entry->Next);
        if ( bSuccess )
        {
            m_TotalEntry--;
        }
        return bSuccess;
    }

    void
    operator-=(T* Entry)
    {
        Remove(Entry);
    }

    T*
    PopFront()
    {
        ScopedLock lock(m_Mutex);
        if ( m_TotalEntry == 0 )
        {
            return nullptr;
        }
        auto LastEntry = ::RemoveHeadList(&m_ListHead);
        if ( LastEntry == &m_ListHead )
        {
            return nullptr;
        }
        auto LastItem = CONTAINING_RECORD(LastEntry, T, Next);
        m_TotalEntry--;
        return LastItem;
    }

    T*
    PopBack()
    {
        ScopedLock lock(m_Mutex);
        if ( Size() == 0 )
        {
            return nullptr;
        }
        auto LastEntry = ::RemoveTailList(&m_ListHead);
        if ( LastEntry == &m_ListHead )
        {
            return nullptr;
        }
        auto LastItem = CONTAINING_RECORD(LastEntry, T, Next);
        m_TotalEntry--;
        return LastItem;
    }

    template<typename N>
    T*
    Find(N condition)
    {
        ScopedLock lock(m_Mutex);
        if ( !::IsListEmpty(&m_ListHead) )
        {
            for ( PLIST_ENTRY Entry = m_ListHead.Flink; Entry != &m_ListHead; Entry = Entry->Flink )
            {
                auto CurrentItem = CONTAINING_RECORD(Entry, T, Next);
                if ( condition(CurrentItem) == true )
                {
                    return CurrentItem;
                }
            }
        }
        return nullptr;
    }

    template<typename L>
    bool
    ForEach(L lambda)
    {
        ScopedLock lock(m_Mutex);
        bool bSuccess = true;
        if ( !::IsListEmpty(&m_ListHead) )
        {
            for ( PLIST_ENTRY Entry = m_ListHead.Flink; Entry != &m_ListHead; Entry = Entry->Flink )
            {
                auto CurrentItem = CONTAINING_RECORD(Entry, T, Next);
                bSuccess &= lambda(CurrentItem);
            }
        }
        return bSuccess;
    }


private:
    KFastMutex m_Mutex;
    LIST_ENTRY m_ListHead;
    usize m_TotalEntry;
};


///
/// @brief Basic implementation of unique pointer for the kernel
///
/// @tparam T
///
template<typename T>
class UniquePointer
{
public:
    UniquePointer() : m_data(nullptr)
    {
    }

    explicit UniquePointer(T* data) : m_data(data)
    {
    }

    ~UniquePointer()
    {
        delete m_data;
    }

    UniquePointer(std::nullptr_t) : m_data(nullptr)
    {
    }

    UniquePointer&
    operator=(std::nullptr_t)
    {
        reset();
        return *this;
    }

    UniquePointer(UniquePointer&& moving) noexcept : m_data(nullptr)
    {
        moving.swap(*this);
    }

    UniquePointer&
    operator=(UniquePointer&& moving) noexcept
    {
        moving.swap(*this);
        return *this;
    }

    template<typename U>
    UniquePointer(UniquePointer<U>&& moving)
    {
        UniquePointer<T> tmp(moving.release());
        tmp.swap(*this);
    }

    template<typename U>
    UniquePointer&
    operator=(UniquePointer<U>&& moving)
    {
        UniquePointer<T> tmp(moving.release());
        tmp.swap(*this);
        return *this;
    }

    UniquePointer(UniquePointer const&) = delete;

    UniquePointer&
    operator=(UniquePointer const&) = delete;

    T*
    operator->() const
    {
        return m_data;
    }

    T&
    operator*() const
    {
        return *m_data;
    }

    T*
    get() const
    {
        return m_data;
    }

    explicit
    operator bool() const
    {
        return m_data;
    }

    T*
    release() noexcept
    {
        T* result = nullptr;
        swap(result, m_data);
        return result;
    }

    void
    swap(UniquePointer& src) noexcept
    {
        InterlockedExchangePointer((PVOID*)m_data, (PVOID)src.m_data);
    }

    void
    reset()
    {
        T* tmp = release();
        delete tmp;
    }

private:
    T* m_data;
};


template<typename T>
void
swap(UniquePointer<T>& lhs, UniquePointer<T>& rhs)
{
    lhs.swap(rhs);
}

///
/// @brief Basic implementation of smart pointer for the kernel
///
/// @tparam T
///
template<typename T>
class SharedPointer
{

public:
    SharedPointer(T* _ptr) : m_Count(nullptr), m_Pointer(_ptr)
    {
        m_Count = new int(1);
    }

    ~SharedPointer()
    {
        ScopedLock lock(m_Mutex);

        DecrementCounter();

        if ( count() == 0 )
        {
            delete m_Pointer;
            delete m_Count;
        }
    }

    SharedPointer(const SharedPointer<T>& other)
    {
        ScopedLock lock(m_Mutex);
        m_Pointer = other.m_Pointer;
        m_Count   = other.count();
        IncrementCounter();
    }

    SharedPointer<T>&
    operator=(const SharedPointer<T>& other)
    {
        ScopedLock lock(m_Mutex);
        m_Pointer = other.m_Pointer;
        m_Count   = other.m_Count;
        IncrementCounter();
        return *this;
    }

    usize
    count() const
    {
        ScopedLock lock(m_Mutex);
        return (m_Count != nullptr) ? *m_Count : 0;
    }

    T*
    get()
    {
        ScopedLock lock(m_Mutex);
        return m_Pointer;
    }

    T*
    operator*()
    {
        return get();
    }

    T*
    operator->()
    {
        return get();
    }

protected:
    void
    IncrementCounter()
    {
        InterlockedIncrement(&m_Count);
    }

    void
    DecrementCounter()
    {
        InterlockedDecrement(&m_Count);
    }

private:
    T* m_Pointer;
    usize* m_Count;
    KFastMutex m_Mutex;
};


} // namespace CFB::Driver::Utils

```

`Driver/Headers/HookedDriver.hpp`:

```hpp
#pragma once

#include "Callbacks.hpp"
#include "Common.hpp"
#include "DriverUtils.hpp"
#include "Log.hpp"

namespace Utils = CFB::Driver::Utils;


namespace CFB::Driver
{
class HookedDriver
{
public:
    enum class HookState
    {
        Invalid,
        Unhooked,
        Hooked
    };

    ///
    /// @brief The next HookedDriver entry (if any)
    ///
    LIST_ENTRY Next;

    ///
    /// @brief The absolute path of to the driver underneath
    ///
    Utils::KUnicodeString Path;

    ///
    /// @brief A pointer to the driver object. The object refcount has been incremented by the constructor.
    /// The destructor makes sure to release it.
    ///
    PDRIVER_OBJECT OriginalDriverObject;

    ///
    ///@brief Unique smart pointer to the native `DRIVER_OBJECT` associated to the current hooked driver object.
    ///
    Utils::UniquePointer<DRIVER_OBJECT> HookedDriverObject;

    ///
    ///@brief Construct a new Hooked Driver object
    ///
    ///@param UnicodePath the unicode name of the driver
    ///
    HookedDriver(Utils::KUnicodeString const& UnicodePath);

    ///
    ///@brief Destroy the Hooked Driver object
    ///
    ~HookedDriver();

    ///
    ///@brief HookedDriver memory allocator
    ///
    ///@param sz
    ///@return void*
    ///
    static void*
    operator new(const usize sz)
    {
        void* Memory = ::ExAllocatePoolWithTag(NonPagedPoolNx, sz, CFB_DEVICE_TAG);
        if ( Memory )
        {
            ::RtlSecureZeroMemory(Memory, sz);
            dbg("Allocated HookedDriver at %p", Memory);
        }
        return Memory;
    }

    ///
    ///@brief HookedDriver memory destructor
    ///
    ///@param Memory
    ///
    static void
    operator delete(void* Memory)
    {
        dbg("Deallocating HookedDriver at %p", Memory);
        return ::ExFreePoolWithTag(Memory, CFB_DEVICE_TAG);
    }

    ///
    ///@brief Is the current driver capturing IRP?
    ///
    ///@return true
    ///@return false
    ///
    bool
    CanCapture() const;

    ///
    ///@brief Enable the IRP capture mode for the driver
    ///
    ///@return true
    ///@return false
    ///
    bool
    EnableCapturing();

    ///
    ///@brief Disable the IRP capture mode for the driver
    ///
    ///@return true
    ///@return false
    ///
    bool
    DisableCapturing();

    ///
    ///@brief Get the number of IRP currently in the stack
    ///
    ///@return usize const
    ///
    usize const
    IrpCount() const;

    ///
    ///@brief Increment the stacked IRP count
    ///
    void
    IncrementIrpCount();

    ///
    ///@brief Alias to `IncrementIrpCount()`
    ///
    ///@return HookedDriver&
    ///
    HookedDriver&
    operator++();

    ///
    ///@brief Decrement the stacked IRP count
    ///
    void
    DecrementIrpCount();

    ///
    ///@brief Alias to `DecrementIrpCount()`
    ///
    ///@return HookedDriver&
    ///
    HookedDriver&
    operator--();

    void
    FlagAsInvalid();

private:
    ///
    /// @brief Swap the callbacks of the driver with the interception routines of IrpMonitor
    /// The code of those routines is located in `Driver/Callbacks.cpp`. The function will
    /// also set the object state as `Hooked`.
    ///
    void
    SwapCallbacks();

    ///
    /// @brief Restore the original callbacks and set the object state as `Unhooked`.
    ///
    void
    RestoreCallbacks();

    ///
    /// @brief If `true`, any IRP targetting the driver object underneath will be pushed to the queue of
    /// intercepted IRPs
    ///
    bool m_CapturingEnabled;

    ///
    /// @brief The total number of intercepted IRPs
    ///
    u64 m_InterceptedIrpsCount;

    ///
    /// @brief CallbackLock to guard callback access
    ///
    Utils::KQueuedSpinLock m_CallbackLock;

    ///
    /// @brief
    ///
    HookState m_State;
};
} // namespace CFB::Driver

```

`Driver/Headers/HookedDriverManager.hpp`:

```hpp
#pragma once

#include "Common.hpp"
#include "DriverUtils.hpp"
#include "HookedDriver.hpp"
#include "Log.hpp"

#define CFB_MAX_HOOKED_DRIVERS 32

namespace Utils = CFB::Driver::Utils;

namespace CFB::Driver
{
class HookedDriverManager
{
public:
    ///
    /// @brief Construct a new Hooked Driver Manager object
    ///
    HookedDriverManager();

    ///
    /// @brief Destroy the Hooked Driver Manager object
    ///
    ~HookedDriverManager();

    ///
    ///@brief HookedDriverManager memory allocator
    ///
    ///@param sz
    ///@return void*
    ///
    static void*
    operator new(usize sz)
    {
        void* Memory = ::ExAllocatePoolWithTag(NonPagedPoolNx, sz, CFB_DEVICE_TAG);
        if ( Memory )
        {
            dbg("Allocating HookedDriverManager at %p", Memory);
            ::RtlSecureZeroMemory(Memory, sz);
        }
        return Memory;
    }

    ///
    ///@brief HookedDriverManager memory destructor
    ///
    ///@param Memory
    ///
    static void
    operator delete(void* Memory)
    {
        dbg("Deallocating HookedDriverManager");
        return ::ExFreePoolWithTag(Memory, CFB_DEVICE_TAG);
    }

    ///
    /// @brief
    ///
    /// @param UnicodePath
    /// @return NTSTATUS
    ///
    NTSTATUS
    InsertDriver(Utils::KUnicodeString const& UnicodePath);

    ///
    /// @brief
    ///
    /// @param UnicodePath
    /// @return NTSTATUS
    ///
    NTSTATUS
    RemoveDriver(Utils::KUnicodeString const& UnicodePath);

    ///
    /// @brief
    ///
    /// @return NTSTATUS
    ///
    NTSTATUS
    RemoveAllDrivers();

    ///
    /// @brief Set the monitoring state for the driver given in argument. If `true`, monitoring will become active,
    /// effectively capturing all the IRPs to the driver. Setting to `false` disables the monitoring.
    ///
    /// @param UnicodePath Path to the driver (as a Unicode string)
    /// @param bEnable `true` to enable, `false` to disable
    /// @return NTSTATUS the error code returned from the function.
    ///
    NTSTATUS
    SetMonitoringState(const PUNICODE_STRING UnicodePath, bool bEnable);


    Utils::LinkedList<HookedDriver>&
    Items();

private:
    ///
    /// @brief A pointer to the head of hooked drivers
    ///
    Utils::LinkedList<HookedDriver> m_Entries;

    ///
    /// @brief A mutex to protect access to the critical resources
    ///
    Utils::KFastMutex m_Mutex;
};

} // namespace CFB::Driver

```

`Driver/Headers/Native.hpp`:

```hpp
#pragma once

#include "Common.hpp"

EXTERN_C_START

extern POBJECT_TYPE* IoDriverObjectType;
extern POBJECT_TYPE* IoDeviceObjectType;

extern NTSYSAPI NTSTATUS NTAPI
ObReferenceObjectByName(
    _In_ PUNICODE_STRING ObjectPath,
    _In_ ULONG Attributes,
    _In_opt_ PACCESS_STATE PassedAccessState,
    _In_opt_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_TYPE ObjectType,
    _In_ KPROCESSOR_MODE AccessMode,
    _Inout_opt_ PVOID ParseContext,
    _Out_ PVOID* ObjectPtr);

extern NTKERNELAPI PSTR
PsGetProcessImageFileName(_In_ PEPROCESS Process);

EXTERN_C_END

```

`Driver/Source/Callbacks.cpp`:

```cpp
#define CFB_NS "[CFB::Driver::Callbacks]"

#include "Callbacks.hpp"

#include "CapturedIrp.hpp"
#include "Context.hpp"
#include "HookedDriver.hpp"


namespace CFB::Driver::Callbacks
{


NTSTATUS
static inline CompleteRequest(_In_ PIRP Irp, _In_ NTSTATUS Status, _In_ ULONG_PTR Information)
{
    Irp->IoStatus.Status      = Status;
    Irp->IoStatus.Information = Information;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return Status;
}

NTSTATUS static ExecuteOriginalCallback(
    _In_ PDRIVER_OBJECT DriverObject,
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ PIRP Irp,
    _Out_ NTSTATUS* IoctlStatus)
{
    *IoctlStatus             = STATUS_UNSUCCESSFUL;
    PIO_STACK_LOCATION Stack = ::IoGetCurrentIrpStackLocation(Irp);

    __try
    {
        PDRIVER_DISPATCH OriginalIoctlDeviceControl = DriverObject->MajorFunction[Stack->MajorFunction];
        *IoctlStatus                                = OriginalIoctlDeviceControl(DeviceObject, Irp);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        NTSTATUS Status = GetExceptionCode();
        crit("Exception 0x%08x caught while executing original function", Status);
        return Status;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
InterceptGenericRoutine(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp)
{
    NTSTATUS Status          = STATUS_UNSUCCESSFUL;
    NTSTATUS IoctlStatus     = STATUS_UNSUCCESSFUL;
    PIO_STACK_LOCATION Stack = ::IoGetCurrentIrpStackLocation(Irp);

    //
    // Capture the IRP data if capturing mode is enabled for the current driver
    //
    auto CapturedIrp = new CFB::Driver::CapturedIrp(CFB::Driver::CapturedIrp::IrpType::Irp, DeviceObject);
    if ( !CapturedIrp->IsValid() )
    {
        //
        // There was an issue at the allocation or initialization of the CapturedIrp object. Fallback safely by calling
        // the original routine
        //
        delete CapturedIrp;
        warn("Failed to initialize CapturedIrp(), fallback");
        PDRIVER_DISPATCH OriginalIoctlDeviceControl = DeviceObject->DriverObject->MajorFunction[Stack->MajorFunction];
        return OriginalIoctlDeviceControl(DeviceObject, Irp);
    }

    auto const Driver = CapturedIrp->AssociatedDriver();

    //
    // Consequently, `Driver` here should never be null
    //
    NT_ASSERT(Driver != nullptr);


    dbg("Initialized CapturedIrp at %p", CapturedIrp);

    // TODO: replace with SharedPointer<CapturedIrp>

    if ( Driver->CanCapture() )
    {
        dbg("Capturing pre data of IRP to '%wZ'", Driver->Path.get());
        Status = CapturedIrp->CapturePreCallData(Irp);
        if ( !NT_SUCCESS(Status) )
        {
            warn("CapturedIrp(%p)->CapturePreCallData(IRP=%p) failed with Status = 0x%08X", CapturedIrp, Irp, Status);
            Driver->DisableCapturing();
        }
    }

    //
    // Call the original routine
    //
    Status = ExecuteOriginalCallback(Driver->OriginalDriverObject, DeviceObject, Irp, &IoctlStatus);
    if ( !NT_SUCCESS(Status) )
    {
        //
        // The status of `ExecuteOriginalCallback` indicates whether  an exception was hit. This can happen if the
        // driver was unloaded. If so disable the HookDriver object and mark it invalid to never touch the invalid
        // memory area again.
        //
        warn("ExecuteOriginalCallback() failed with Status = Status = 0x%08X", Status);
        Driver->DisableCapturing();
        Driver->FlagAsInvalid();
    }

    //
    // Collect the output from the call
    //
    if ( Driver->CanCapture() )
    {
        dbg("Capturing post data of IRP to '%wZ'", Driver->Path.get());
        Status = CapturedIrp->CapturePostCallData(Irp, IoctlStatus);
        if ( NT_SUCCESS(Status) )
        {
            if ( Globals->IrpManager.Push(CapturedIrp) )
            {
                //
                // If everything went fine, return the result
                //
                Driver->IncrementIrpCount();
                return IoctlStatus;
            }

            warn("Failed to push new IRP %p to the queue (Status = 0x%08X)", CapturedIrp, Status);
        }
        else
        {
            warn("CapturedIrp->CapturePostCallData(%p) failed with Status = 0x%08X", CapturedIrp, Status);
        }

        //
        // If here, there's been a problem, disable capturing
        //
        Driver->DisableCapturing();
    }

    delete CapturedIrp;

    return IoctlStatus;
}


NTSTATUS
InterceptedDeviceControlRoutine(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp)
{
    return InterceptGenericRoutine(DeviceObject, Irp);
}


NTSTATUS
InterceptedReadRoutine(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp)
{
    return InterceptGenericRoutine(DeviceObject, Irp);
}


NTSTATUS
InterceptedWriteRoutine(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp)
{
    return InterceptGenericRoutine(DeviceObject, Irp);
}


BOOLEAN
InterceptGenericFastIoDeviceControl(
    _In_ PFILE_OBJECT FileObject,
    _In_ BOOLEAN Wait,
    _In_opt_ PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_opt_ PVOID OutputBuffer,
    _In_ ULONG OutputBufferLength,
    _In_ ULONG IoControlCode,
    _Out_ PIO_STATUS_BLOCK IoStatus,
    _In_ PDEVICE_OBJECT DeviceObject)
{
    //
    // Prepare the object
    //
    auto CapturedFastIo = new CFB::Driver::CapturedIrp(CFB::Driver::CapturedIrp::IrpType::FastIo_Ioctl, DeviceObject);
    if ( !(CapturedFastIo && CapturedFastIo->IsValid()) )
    {
        //
        // Call the original routine
        //
        const PDRIVER_OBJECT Driver                               = FileObject->DeviceObject->DriverObject;
        const PFAST_IO_DEVICE_CONTROL OriginalFastIoDeviceControl = Driver->FastIoDispatch->FastIoDeviceControl;
        return OriginalFastIoDeviceControl(
            FileObject,
            Wait,
            InputBuffer,
            InputBufferLength,
            OutputBuffer,
            OutputBufferLength,
            IoControlCode,
            IoStatus,
            DeviceObject);
    }

    const auto Driver       = CapturedFastIo->AssociatedDriver();
    const bool bCaptureData = Driver->CanCapture();

    //
    // If capturing enabled, capture the input data
    //
    if ( bCaptureData )
    {
        CapturedFastIo->CapturePreCallFastIoData(InputBuffer, IoControlCode);
    }

    //
    // Execute the original callback
    //
    PFAST_IO_DEVICE_CONTROL OriginalFastIoDeviceControl =
        Driver->OriginalDriverObject->FastIoDispatch->FastIoDeviceControl;
    BOOLEAN bRes = OriginalFastIoDeviceControl(
        FileObject,
        Wait,
        InputBuffer,
        InputBufferLength,
        OutputBuffer,
        OutputBufferLength,
        IoControlCode,
        IoStatus,
        DeviceObject);

    //
    // If capturing enabled, capture the output data
    //
    if ( bCaptureData )
    {
        CapturedFastIo->CapturePostCallFastIoData(OutputBuffer);

        //
        // And push the IRP to the queue
        //
        Globals->IrpManager.Push(CapturedFastIo);
        Driver->IncrementIrpCount();
    }
    else
    {
        //
        // Otherwise just delete the allocation
        //
        delete CapturedFastIo;
    }

    return bRes;
}


BOOLEAN
InterceptGenericFastIoRead(
    _In_ PFILE_OBJECT FileObject,
    _In_ PLARGE_INTEGER FileOffset,
    _In_ ULONG BufferLength,
    _In_ BOOLEAN Wait,
    _In_ ULONG LockKey,
    _Out_ PVOID Buffer,
    _Out_ PIO_STATUS_BLOCK IoStatus,
    _In_ PDEVICE_OBJECT DeviceObject)
{
    //
    // Prepare the object
    //
    auto CapturedFastRead = new CFB::Driver::CapturedIrp(CFB::Driver::CapturedIrp::IrpType::FastIo_Ioctl, DeviceObject);
    if ( !(CapturedFastRead && CapturedFastRead->IsValid()) )
    {
        //
        // Call the original routine
        //
        const PDRIVER_OBJECT Driver            = FileObject->DeviceObject->DriverObject;
        const PFAST_IO_READ OriginalFastIoRead = Driver->FastIoDispatch->FastIoRead;
        return OriginalFastIoRead(FileObject, FileOffset, BufferLength, Wait, LockKey, Buffer, IoStatus, DeviceObject);
    }

    auto Driver             = CapturedFastRead->AssociatedDriver();
    const bool bCaptureData = Driver->CanCapture();

    dbg("Initialized CapturedFastRead at %p", CapturedFastRead);
    //
    // Execute the original callback
    //
    PFAST_IO_READ const OriginalFastIoRead = Driver->OriginalDriverObject->FastIoDispatch->FastIoRead;
    BOOLEAN bRes =
        OriginalFastIoRead(FileObject, FileOffset, BufferLength, Wait, LockKey, Buffer, IoStatus, DeviceObject);

    //
    // If capturing enabled, capture the output data
    //
    if ( bCaptureData )
    {
        CapturedFastRead->CapturePostCallFastIoData(Buffer);

        //
        // And push the IRP to the queue
        //
        Globals->IrpManager.Push(CapturedFastRead);
        Driver->IncrementIrpCount();
    }
    else
    {
        //
        // Otherwise just delete the allocation
        //
        delete CapturedFastRead;
    }

    return bRes;
}


BOOLEAN
InterceptGenericFastIoWrite(
    _In_ PFILE_OBJECT FileObject,
    _In_ PLARGE_INTEGER FileOffset,
    _In_ ULONG BufferLength,
    _In_ BOOLEAN Wait,
    _In_ ULONG LockKey,
    _Out_ PVOID Buffer,
    _Out_ PIO_STATUS_BLOCK IoStatus,
    _In_ PDEVICE_OBJECT DeviceObject)
{
    //
    // Prepare the object
    //
    auto CapturedFastWrite =
        new CFB::Driver::CapturedIrp(CFB::Driver::CapturedIrp::IrpType::FastIo_Ioctl, DeviceObject);
    if ( !(CapturedFastWrite && CapturedFastWrite->IsValid()) )
    {
        //
        // Call the original routine
        //
        const PDRIVER_OBJECT Driver             = FileObject->DeviceObject->DriverObject;
        const PFAST_IO_READ OriginalFastIoWrite = Driver->FastIoDispatch->FastIoWrite;
        return OriginalFastIoWrite(FileObject, FileOffset, BufferLength, Wait, LockKey, Buffer, IoStatus, DeviceObject);
    }

    auto Driver             = CapturedFastWrite->AssociatedDriver();
    const bool bCaptureData = Driver->CanCapture();

    dbg("Initialized CapturedFastWrite at %p", CapturedFastWrite);
    //
    // If capturing enabled, capture the input data
    //
    if ( bCaptureData )
    {
        CapturedFastWrite->CapturePreCallFastIoData(Buffer, 0);
    }

    //
    // Execute the original callback
    //
    PFAST_IO_READ const OriginalFastIoWrite = Driver->OriginalDriverObject->FastIoDispatch->FastIoWrite;
    BOOLEAN bRes =
        OriginalFastIoWrite(FileObject, FileOffset, BufferLength, Wait, LockKey, Buffer, IoStatus, DeviceObject);

    //
    // If capturing enabled, capture the output data
    //
    if ( bCaptureData )
    {
        //
        // And push the IRP to the queue
        //
        Globals->IrpManager.Push(CapturedFastWrite);
        Driver->IncrementIrpCount();
    }
    else
    {
        //
        // Otherwise just delete the allocation
        //
        delete CapturedFastWrite;
    }

    return bRes;
}
} // namespace CFB::Driver::Callbacks

```

`Driver/Source/CapturedIrp.cpp`:

```cpp
#define CFB_NS "[CFB::Driver::CapturedIrp]"

#include "CapturedIrp.hpp"

#include "Context.hpp"
#include "Native.hpp"
#include "Utils.hpp"

namespace CFB::Driver
{

CapturedIrp::CapturedIrp(const CapturedIrp::IrpType Type, PDEVICE_OBJECT DeviceObject) :
    m_Valid {false},
    m_Type {Type},
    m_Pid {::HandleToULong(::PsGetCurrentProcessId())},
    m_Tid {::HandleToULong(::PsGetCurrentThreadId())},
    m_Driver {nullptr},
    m_DeviceObject {nullptr},
    m_DriverName {},
    m_DeviceName {},
    m_ProcessName {},
    m_MajorFunction {0},
    m_MinorFunction {0},
    m_IoctlCode {0},
    m_InputBuffer {0},
    m_OutputBuffer {0},
    Next {}
{
    NT_ASSERT(DeviceObject);

    auto FilterByDeviceAddress = [&DeviceObject](const HookedDriver* h)
    {
        for ( PDEVICE_OBJECT CurrentDevice = h->OriginalDriverObject->DeviceObject; CurrentDevice;
              CurrentDevice                = CurrentDevice->NextDevice )
        {
            if ( CurrentDevice == DeviceObject )
            {
                return true;
            }
        }
        return false;
    };

    m_Driver = Globals->DriverManager.Items().Find(FilterByDeviceAddress);
    if ( m_Driver == nullptr )
    {
        //
        // This is really bad: if here the interception routine got called by a non-hooked driver
        // Could be a bad pointer restoration. Anyway, we log and fail for now.
        //
        err(""
            "Failed to find a HookedDriver object associated to the received IRP. "
            "This could indicates a corruption of the hooked driver list, you should probably reboot..."
            "");
        return;
    }

    m_DeviceObject = DeviceObject;

    KeQuerySystemTime(&m_TimeStamp);

    //
    // Set the Device name
    //
    {
        ULONG ReturnLength {};

        //
        // Query the exact size
        //
        NTSTATUS Status = ::ObQueryNameString(DeviceObject, nullptr, 0, &ReturnLength);
        if ( Status != STATUS_INFO_LENGTH_MISMATCH )
        {
            err("CapturedIrp() failed with %#08x", Status);
            return;
        }

        //
        // Get the value, store it in the member
        //
        auto DeviceNameInfo = Utils::KAlloc<POBJECT_NAME_INFORMATION>(sizeof(OBJECT_NAME_INFORMATION) + ReturnLength);
        Status = ::ObQueryNameString(DeviceObject, DeviceNameInfo.get(), DeviceNameInfo.size(), &ReturnLength);
        if ( !NT_SUCCESS(Status) )
        {
            err("CapturedIrp() failed with %#08x", Status);
            return;
        }

        m_DeviceName = Utils::KUnicodeString(&DeviceNameInfo.get()->Name);
    }

    //
    // Set the driver name
    //
    {
        m_DriverName = Utils::KUnicodeString(m_Driver->Path);
    }

    //
    // Set the process name
    //
    {
        PEPROCESS Process = nullptr;
        NTSTATUS Status   = ::PsLookupProcessByProcessId(UlongToHandle(m_Pid), &Process);
        if ( !NT_SUCCESS(Status) )
        {
            err("PsLookupProcessByProcessId() failed with Status=%#08x", Status);
            return;
        }

        PSTR lpProcessName = ::PsGetProcessImageFileName(Process);
        if ( !lpProcessName )
        {
            err("PsGetProcessImageFileName() failed with Status=%#08x", Status);
            return;
        }

        CANSI_STRING aStr {};
        Status = ::RtlInitAnsiStringEx(&aStr, lpProcessName);
        if ( !NT_SUCCESS(Status) )
        {
            err("RtlInitAnsiStringEx() failed with Status=%#08x", Status);
            return;
        }

        UNICODE_STRING uStr {};
        Status = ::RtlAnsiStringToUnicodeString(&uStr, &aStr, true);
        if ( !NT_SUCCESS(Status) )
        {
            err("RtlAnsiStringToUnicodeString() failed with Status=%#08x", Status);
            return;
        }

        m_ProcessName = Utils::KUnicodeString(&uStr);
    }


    //
    // Mark the object as valid
    //
    m_Valid = true;
}

CapturedIrp::~CapturedIrp()
{
    dbg("~CapturedIrp()");
}


NTSTATUS
CapturedIrp::CapturePreCallData(_In_ PIRP Irp)
{
    if ( !m_Valid )
    {
        warn("CapturedIRP was insufficiently initialized");
        return STATUS_UNSUCCESSFUL;
    }

    NTSTATUS Status                = STATUS_UNSUCCESSFUL;
    const ULONG Flags              = m_DeviceObject->Flags;
    const PIO_STACK_LOCATION Stack = ::IoGetCurrentIrpStackLocation(Irp);

    ULONG InputBufferLength  = 0;
    ULONG OutputBufferLength = 0;

    dbg("CapturePreCallData(%p)", Irp);

    m_MajorFunction    = Stack->MajorFunction;
    m_MinorFunction    = Stack->MinorFunction;
    const ULONG Method = METHOD_FROM_CTL_CODE(m_IoctlCode);

    //
    // Determine & allocate the input/output buffer sizes from the IRP for "normal" IOCTLs
    //
    switch ( m_MajorFunction )
    {
    case IRP_MJ_DEVICE_CONTROL:
    case IRP_MJ_INTERNAL_DEVICE_CONTROL:
        InputBufferLength  = Stack->Parameters.DeviceIoControl.InputBufferLength;
        OutputBufferLength = Stack->Parameters.DeviceIoControl.OutputBufferLength;
        m_IoctlCode        = Stack->Parameters.DeviceIoControl.IoControlCode;
        m_InputBuffer      = Utils::KAlloc<u8*>(InputBufferLength);
        m_OutputBuffer     = Utils::KAlloc<u8*>(OutputBufferLength);
        break;

    case IRP_MJ_WRITE:
        InputBufferLength = Stack->Parameters.Write.Length;
        m_InputBuffer     = Utils::KAlloc<u8*>(InputBufferLength);
        break;

    case IRP_MJ_READ:
        OutputBufferLength = Stack->Parameters.Read.Length;
        m_OutputBuffer     = Utils::KAlloc<u8*>(OutputBufferLength);
        break;

    default:
        return STATUS_SUCCESS;
    }

    //
    // Now, copy the input/output buffer content to the CapturedIrp object
    //
    PVOID Buffer       = m_InputBuffer.get();
    ULONG BufferLength = m_InputBuffer.size();

    // __try // TODO fix unwinding
    {
        Status = STATUS_SUCCESS;
        do
        {
            if ( (Stack->MajorFunction == IRP_MJ_DEVICE_CONTROL ||
                  Stack->MajorFunction == IRP_MJ_INTERNAL_DEVICE_CONTROL) &&
                 Method == METHOD_NEITHER )
            {
                if ( Stack->Parameters.DeviceIoControl.Type3InputBuffer >= (PVOID)(1 << 16) )
                    RtlCopyMemory(Buffer, Stack->Parameters.DeviceIoControl.Type3InputBuffer, BufferLength);
                else
                    Status = STATUS_INVALID_PARAMETER;
                break;
            }

            if ( Method == METHOD_BUFFERED )
            {
                if ( Irp->AssociatedIrp.SystemBuffer )
                    RtlCopyMemory(Buffer, Irp->AssociatedIrp.SystemBuffer, BufferLength);
                else
                    Status = STATUS_INVALID_PARAMETER_1;
                break;
            }

            if ( Method == METHOD_IN_DIRECT || Method == METHOD_OUT_DIRECT )
            {
                if ( !Irp->MdlAddress )
                {
                    Status = STATUS_INVALID_PARAMETER_2;
                    break;
                }

                PVOID pDataAddr = MmGetSystemAddressForMdlSafe(Irp->MdlAddress, NormalPagePriority);
                if ( !pDataAddr )
                {
                    Status = STATUS_INVALID_PARAMETER_3;
                    break;
                }

                RtlCopyMemory(Buffer, pDataAddr, BufferLength);
            }
        } while ( 0 );
    }
    // __except (EXCEPTION_EXECUTE_HANDLER)
    // {
    //     Status = GetExceptionCode();
    // }

    if ( !NT_SUCCESS(Status) )
    {
        err("CapturePreCallData() returned %#08x", Status);
    }
    // #ifdef _DEBUG
    else
    {
        dbg("Captured input data (%lu bytes):", m_InputBuffer.size());
        CFB::Utils::Hexdump(m_InputBuffer.get(), MIN(m_InputBuffer.size(), CFB_MAX_HEXDUMP_BYTE));
    }
    // #endif // _DEBUG

    return STATUS_SUCCESS;
}


NTSTATUS
CapturedIrp::CapturePostCallData(_In_ PIRP Irp, _In_ NTSTATUS ReturnedIoctlStatus)
{
    if ( !m_Valid )
    {
        warn("CapturedIRP was insufficiently initialized");
        return STATUS_UNSUCCESSFUL;
    }

    PVOID UserBuffer = nullptr;
    m_Status         = ReturnedIoctlStatus;

    //
    // If there's nothing to capture, leave now
    //
    if ( m_OutputBuffer.size() == 0 )
    {
        return STATUS_SUCCESS;
    }

    //
    // Check if the operation supports having output buffer
    //
    usize Count {m_OutputBuffer.size()}, Offset {0};
    switch ( m_MajorFunction )
    {
    case IRP_MJ_DEVICE_CONTROL:
    case IRP_MJ_INTERNAL_DEVICE_CONTROL:
        UserBuffer = Irp->UserBuffer;
        break;

    case IRP_MJ_READ:
        if ( Irp->MdlAddress )
        {
            UserBuffer = ::MmGetSystemAddressForMdlSafe(
                Irp->MdlAddress,
                NormalPagePriority | MdlMappingNoWrite | MdlMappingNoExecute);
            Count  = Irp->MdlAddress->ByteCount;
            Offset = Irp->MdlAddress->ByteOffset;
        }
        else
        {
            UserBuffer = Irp->UserBuffer;
        }
        break;

    default:
        return STATUS_SUCCESS;
    }

    //
    // Check if there's actual data to be copied
    //
    if ( UserBuffer == nullptr )
    {
        return STATUS_SUCCESS;
    }

    dbg("Copying %p <- %p (%luB)", m_OutputBuffer.get() + Offset, UserBuffer, Count);

    //
    // If here, just copy the buffer
    //
    ::memcpy(m_OutputBuffer.get() + Offset, UserBuffer, Count);

    // #ifdef _DEBUG
    dbg("Capturing output data:");
    CFB::Utils::Hexdump(m_OutputBuffer.get(), MIN(m_OutputBuffer.size(), CFB_MAX_HEXDUMP_BYTE));
    // #endif // _DEBUG

    return STATUS_SUCCESS;
}


NTSTATUS
CapturedIrp::CapturePreCallFastIoData(_In_ PVOID InputBuffer, _In_ ULONG IoControlCode)
{
    if ( !m_Valid )
    {
        warn("CapturedIRP was insufficiently initialized");
        return STATUS_ACCESS_DENIED;
    }

    m_IoctlCode = IoControlCode;
    ::memcpy(m_InputBuffer.get(), InputBuffer, m_InputBuffer.size());

    return STATUS_SUCCESS;
}


NTSTATUS
CapturedIrp::CapturePostCallFastIoData(_In_ PVOID OutputBuffer)
{
    if ( !m_Valid )
    {
        warn("CapturedIRP was insufficiently initialized");
        return STATUS_ACCESS_DENIED;
    }

    ::memcpy(m_OutputBuffer.get(), OutputBuffer, m_OutputBuffer.size());

    return STATUS_SUCCESS;
}

usize const
CapturedIrp::Size() const
{
    return sizeof(Comms::CapturedIrpHeader) + DataSize();
}

usize const
CapturedIrp::DataSize() const
{
    return InputDataSize() + OutputDataSize();
}


usize const
CapturedIrp::InputDataSize() const
{
    return m_InputBuffer.size();
}

u8*
CapturedIrp::InputBuffer() const
{
    return m_InputBuffer.get();
}

u8*
CapturedIrp::OutputBuffer() const
{
    return m_OutputBuffer.get();
}


usize const
CapturedIrp::OutputDataSize() const
{
    return m_OutputBuffer.size();
}

HookedDriver* const
CapturedIrp::AssociatedDriver() const
{
    return m_Driver;
}

Comms::CapturedIrpHeader
CapturedIrp::ExportHeader() const
{
    Comms::CapturedIrpHeader out {};
    out.TimeStamp          = (u64)(m_TimeStamp.QuadPart);
    out.Irql               = m_Irql;
    out.Type               = (u8)m_Type;
    out.MajorFunction      = m_MajorFunction;
    out.MinorFunction      = m_MinorFunction;
    out.IoctlCode          = m_IoctlCode;
    out.Pid                = m_Pid;
    out.Tid                = m_Tid;
    out.Status             = m_Status;
    out.InputBufferLength  = InputDataSize();
    out.OutputBufferLength = OutputDataSize();

    ::memcpy(out.DriverName, m_DriverName.data(), m_DriverName.size());
    ::memcpy(out.DeviceName, m_DeviceName.data(), m_DeviceName.size());
    ::memcpy(out.ProcessName, m_ProcessName.data(), m_ProcessName.size());

    return out;
}

bool
CapturedIrp::IsValid() const
{
    return m_Valid;
}

} // namespace CFB::Driver

```

`Driver/Source/CapturedIrpManager.cpp`:

```cpp
#include "CapturedIrpManager.hpp"
namespace CFB::Driver
{


CapturedIrpManager::CapturedIrpManager() : m_Event(nullptr), m_Count(0), m_Entries(), m_Mutex()
{
}

CapturedIrpManager::~CapturedIrpManager()
{
    Clear();

    if ( m_Event )
    {
        //
        // Free the Event object
        //
        ::KeResetEvent(m_Event);
        ObDereferenceObject(m_Event);
        m_Event = nullptr;
    }
}


Utils::LinkedList<CapturedIrp>&
CapturedIrpManager::Items()
{
    return m_Entries;
}

NTSTATUS
CapturedIrpManager::SetEvent(const HANDLE hEvent)
{
    NTSTATUS Status  = STATUS_UNSUCCESSFUL;
    PKEVENT NewEvent = nullptr;

    auto lock = Utils::ScopedLock(m_Mutex);

    //
    // Get a reference to the Event object
    //
    Status =
        ::ObReferenceObjectByHandle(hEvent, EVENT_ALL_ACCESS, *ExEventObjectType, UserMode, (PVOID*)&NewEvent, nullptr);
    if ( !NT_SUCCESS(Status) )
    {
        return Status;
    }

    //
    // If an event object was already assigned, replace it
    //
    if ( m_Event != nullptr )
    {
        ObDereferenceObject(m_Event);
        m_Event = nullptr;
    }

    m_Event = NewEvent;

    return Status;
}


bool
CapturedIrpManager::Push(CapturedIrp* Item)
{
    Utils::ScopedLock lock(m_Mutex);

    //
    // Push the item to the back of the queue
    //
    m_Entries.PushBack(Item);
    m_Count++;

    //
    // Set the event to notify the broker some data is ready
    //
    if ( m_Event )
    {
        ::KeSetEvent(m_Event, 2, false);
    }

    return true;
}


CapturedIrp*
CapturedIrpManager::Pop()
{
    Utils::ScopedLock lock(m_Mutex);

    //
    // Stored data are treated as a FIFO queue
    //
    CapturedIrp* Item = m_Entries.PopFront();
    if ( Item == nullptr )
    {
        return nullptr;
    }

    m_Count--;

    //
    // Unset the event is no data is ready
    //
    if ( m_Count == 0 && m_Event )
    {
        ::KeClearEvent(m_Event);
    }

    return Item;
}


void
CapturedIrpManager::Clear()
{
    do
    {
        auto Item = Pop();
        if ( !Item )
        {
            break;
        }
    } while ( true );
}


Utils::KCriticalRegion&
CapturedIrpManager::CriticalRegion()
{
    return m_CriticalRegion;
}


} // namespace CFB::Driver

```

`Driver/Source/Driver.rc.in`:

```in
#include <Winver.h>

VS_VERSION_INFO     VERSIONINFO
FILEVERSION         @DRIVER_VERSION_MAJOR@,@DRIVER_VERSION_MINOR@,@DRIVER_VERSION_PATCH@,0
PRODUCTVERSION      @CFB_VERSION_MAJOR@,@CFB_VERSION_MINOR@,@CFB_VERSION_PATCH@,0
FILEOS              VOS_NT_WINDOWS32
FILETYPE            VFT_DRV
FILESUBTYPE         VFT2_DRV_SYSTEM

BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904E4"
        BEGIN
            VALUE "CompanyName",        "@CFB_COMPANY_NAME@\0"
            VALUE "FileDescription",    "@PROJECT_DESCRIPTION@\0"
            VALUE "FileVersion",        "@DRIVER_VERSION_MAJOR@,@DRIVER_VERSION_MINOR@,@DRIVER_VERSION_PATCH@,0\0"
            VALUE "LegalCopyright",     "(c) @CFB_CURRENT_YEAR@ @CFB_COMPANY_NAME@ Release Under @PROJECT_LICENSE@\0"
            VALUE "OriginalFilename",   "@PROJECT_NAME@.sys\0"
            VALUE "ProductName",        "@CMAKE_PROJECT_NAME@\0"
            VALUE "ProductVersion",     "@CFB_VERSION_MAJOR@,@CFB_VERSION_MINOR@,@CFB_VERSION_PATCH@,0\0"
            VALUE "Comments",           "@PROJECT_DESCRIPTION@\0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END


```

`Driver/Source/DriverUtils.cpp`:

```cpp
#define CFB_NS "[CFB::Driver::Utils]"

#include "DriverUtils.hpp"


///
/// @brief Basic allocator/deallocator for the kernel
///
///
void* __cdecl
operator new(usize Size, POOL_TYPE PoolType, ULONG PoolTag)
{
    void* Memory = ::ExAllocatePoolWithTag(PoolType, Size, PoolTag);
    dbg("new(Size=%d, Type=%d, Tag=%x)=%p", Size, PoolType, PoolTag, Memory);
    return Memory;
}

void __cdecl
operator delete(void* Memory, usize Size)
{
    dbg("delete(Memory=%p, Size=%d)", Memory, Size);
    ::ExFreePoolWithTag(Memory, 0);
}

void* __cdecl
operator new[](size_t Size, POOL_TYPE PoolType)
{
    return operator new(Size, PoolType);
}

void __cdecl
operator delete[](void* Memory, usize Size)
{
    return operator delete(Memory, Size);
}


///
/// @brief This namespace contains the kernel specific utility functions and classes
///


namespace CFB::Driver::Utils
{

#pragma region Logging helper functions
const char*
ToString(KIRQL const Level)
{
    switch ( Level )
    {
    case PASSIVE_LEVEL:
        return "PASSIVE_LEVEL";
    case APC_LEVEL:
        return "APC_LEVEL";
    case DISPATCH_LEVEL:
        return "DISPATCH_LEVEL";
#ifdef CMCI_LEVEL
    case CMCI_LEVEL:
        return "CMCI_LEVEL";
#endif // CMCI_LEVEL
    case CLOCK_LEVEL:
        return "CLOCK_LEVEL";
    case POWER_LEVEL:
        return "POWER_LEVEL";
    case HIGH_LEVEL:
        return "HIGH_LEVEL";
    }
    return "INVALID_LEVEL";
}
#pragma endregion

#pragma region KUnicodeString

KUnicodeString::KUnicodeString(const wchar_t* src, const u16 srcsz, const POOL_TYPE type) :
    m_UnicodeString {},
    m_StringBuffer {KAlloc<wchar_t*>(sizeof(wchar_t) + srcsz, CFB_DEVICE_TAG, type)}
{
    m_UnicodeString.Buffer        = m_StringBuffer.get();
    m_UnicodeString.Length        = srcsz;
    m_UnicodeString.MaximumLength = srcsz + sizeof(wchar_t);

    ::memset(m_StringBuffer.get(), 0, capacity());
    ::memcpy(m_StringBuffer.get(), src, srcsz);

    dbg("KUnicodeString::KUnicodeString((wchar_t*)L'%wZ', length=%lluB, capacity=%lluB)",
        &m_UnicodeString,
        size(),
        capacity());
}

KUnicodeString::KUnicodeString(PUNICODE_STRING&& src, const POOL_TYPE type) : m_UnicodeString {*src}, m_StringBuffer {}
{
    dbg("KUnicodeString::KUnicodeString((&&)L'%wZ', length=%lluB, capacity=%lluB)",
        &m_UnicodeString,
        size(),
        capacity());
}


KUnicodeString::KUnicodeString(PUNICODE_STRING const& src, const POOL_TYPE type) :
    m_UnicodeString {},
    m_StringBuffer {KAlloc<wchar_t*>(src->MaximumLength, CFB_DEVICE_TAG, type)}
{
    ::memcpy(m_StringBuffer.get(), src->Buffer, MIN(src->Length, src->MaximumLength));
    m_UnicodeString.Buffer        = m_StringBuffer.get();
    m_UnicodeString.Length        = src->Length;
    m_UnicodeString.MaximumLength = src->MaximumLength;

    dbg("KUnicodeString::KUnicodeString((const&)L'%wZ', length=%lluB, capacity=%lluB)",
        &m_UnicodeString,
        size(),
        capacity());
}


KUnicodeString::~KUnicodeString()
{
    dbg("KUnicodeString::~KUnicodeString(%p)", m_UnicodeString);
}


KUnicodeString::KUnicodeString(const KUnicodeString& other)
{
    m_StringBuffer = KAlloc<wchar_t*>(other.capacity());
    ::memcpy(m_StringBuffer.get(), other.data(), other.size());

    m_UnicodeString.Buffer        = m_StringBuffer.get();
    m_UnicodeString.Length        = other.size();
    m_UnicodeString.MaximumLength = other.capacity();
}

KUnicodeString&
KUnicodeString::operator=(const KUnicodeString& other) noexcept
{
    if ( this != &other )
    {
        m_StringBuffer = KAlloc<wchar_t*>(other.capacity());
        ::memcpy(m_StringBuffer.get(), other.get(), other.size());

        m_UnicodeString.Buffer        = m_StringBuffer.get();
        m_UnicodeString.Length        = other.size();
        m_UnicodeString.MaximumLength = other.capacity();
    }
    return *this;
}


KUnicodeString&
KUnicodeString::operator=(KUnicodeString&& other) noexcept
{
    if ( this != &other )
    {
        m_StringBuffer = static_cast<KAlloc<wchar_t*>&&>(other.m_StringBuffer);
        ::memcpy(&m_UnicodeString, other.get(), sizeof(UNICODE_STRING));
        ::memset(&other.m_UnicodeString, 0, sizeof(UNICODE_STRING));
    }
    return *this;
}


bool
KUnicodeString::operator==(KUnicodeString const& other)
{
    return size() == other.size() && ::RtlCompareUnicodeString(get(), other.get(), true) == 0;
}


bool
KUnicodeString::operator==(PUNICODE_STRING const& other)
{
    return size() == other->Length && ::RtlCompareUnicodeString(get(), other, true) == 0;
}


const wchar_t*
KUnicodeString::data() const
{
    return m_UnicodeString.Buffer;
}


const PUNICODE_STRING
KUnicodeString::get() const
{
    return const_cast<PUNICODE_STRING>(&m_UnicodeString);
}


const usize
KUnicodeString::size() const
{
    return m_UnicodeString.Length;
}


const usize
KUnicodeString::capacity() const
{
    return m_UnicodeString.MaximumLength;
}

#pragma endregion KUnicodeString

#pragma region KMutex
KMutex::KMutex()
{
    ::KeInitializeMutex(&_mutex, 0);
}

KMutex::~KMutex()
{
}

void
KMutex::Lock()
{
    ::KeWaitForSingleObject(&_mutex, Executive, KernelMode, false, nullptr);
}

void
KMutex::Unlock()
{
    if ( !::KeReleaseMutex(&_mutex, true) )
        ::KeWaitForSingleObject(&_mutex, Executive, KernelMode, false, nullptr);
}
#pragma endregion

#pragma region KFastMutex
KFastMutex::KFastMutex()
{
    ::ExInitializeFastMutex(&_mutex);
}

KFastMutex::~KFastMutex()
{
}

void
KFastMutex::Lock()
{
    ::ExAcquireFastMutex(&_mutex);
}

void
KFastMutex::Unlock()
{
    ::ExReleaseFastMutex(&_mutex);
}

#pragma endregion

#pragma region KCriticalRegion


KCriticalRegion::KCriticalRegion()
{
    ::ExInitializeResourceLite(&_mutex);
}


KCriticalRegion::~KCriticalRegion()
{
    ::ExDeleteResourceLite(&_mutex);
}

void
KCriticalRegion::Lock()
{
    (void)::ExEnterCriticalRegionAndAcquireResourceExclusive(&_mutex);
}


void
KCriticalRegion::Unlock()
{
    ::ExReleaseResourceAndLeaveCriticalRegion(&_mutex);
}


#pragma endregion

#pragma region KSpinLock
KSpinLock::KSpinLock()
{
    KeInitializeSpinLock(&_SpinLock);
}

KSpinLock::~KSpinLock()
{
}

void
KSpinLock::Lock()
{
    KeAcquireSpinLock(&_SpinLock, &_OldIrql);
}

void
KSpinLock::Unlock()
{
    ::KeReleaseSpinLock(&_SpinLock, _OldIrql);
}
#pragma endregion

#pragma region KQueuedSpinLock
KQueuedSpinLock::KQueuedSpinLock()
{
    ::KeInitializeSpinLock(&_SpinLock);
}

KQueuedSpinLock::~KQueuedSpinLock()
{
}

void
KQueuedSpinLock::Lock()
{
    ::KeAcquireInStackQueuedSpinLock(&_SpinLock, &_LockQueueHandle);
}


void
KQueuedSpinLock::Unlock()
{
    ::KeReleaseInStackQueuedSpinLock(&_LockQueueHandle);
}
#pragma endregion


} // namespace CFB::Driver::Utils

```

`Driver/Source/Entry.cpp`:

```cpp
#define CFB_NS "[CFB::Driver::Main]"

#include "Common.hpp"
#include "Context.hpp"
#include "IoctlCodes.hpp"
#include "Utils.hpp"


struct GlobalContext* Globals = nullptr;


NTSTATUS
static inline CompleteRequest(_In_ PIRP Irp, _In_ NTSTATUS Status, _In_ ULONG_PTR Information)
{
    Irp->IoStatus.Status      = Status;
    Irp->IoStatus.Information = Information;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return Status;
}


EXTERN_C
NTSTATUS
IrpNotImplementedHandler(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp)
{
    UNREFERENCED_PARAMETER(DeviceObject);

    CompleteRequest(Irp, STATUS_NOT_IMPLEMENTED, 0);
    return STATUS_NOT_IMPLEMENTED;
}


EXTERN_C
void
DriverUnloadRoutine(_In_ PDRIVER_OBJECT DriverObject)
{
    dbg("Unloading '%S'...", CFB_DEVICE_NAME);
    UNICODE_STRING SymLink = RTL_CONSTANT_STRING(CFB_DOS_DEVICE_PATH);
    ::IoDeleteSymbolicLink(&SymLink);
    ::IoDeleteDevice(DriverObject->DeviceObject);
    ok("Device '%S' deleted", CFB_DEVICE_NAME);

    delete Globals;

    ok("Context cleaned up");
    return;
}

///
/// @brief Callback routine for obtaining a handle to the device. Getting a handle requires the SeDebug privilege
///
/// @param DeviceObject
/// @param Irp
///
/// @return NTSTATUS
///
NTSTATUS
_Function_class_(DRIVER_DISPATCH) DriverCreateRoutine(_In_ PDEVICE_OBJECT pObject, _In_ PIRP Irp)
{
    UNREFERENCED_PARAMETER(pObject);

    NTSTATUS Status                        = STATUS_UNSUCCESSFUL;
    PIO_STACK_LOCATION lpStack             = ::IoGetCurrentIrpStackLocation(Irp);
    PIO_SECURITY_CONTEXT lpSecurityContext = lpStack->Parameters.Create.SecurityContext;


    //
    // Ensure the calling process has SeDebugPrivilege
    //
    UCHAR ucPrivilegesBuffer[FIELD_OFFSET(PRIVILEGE_SET, Privilege) + 2 * sizeof(LUID_AND_ATTRIBUTES)] = {0};

    PPRIVILEGE_SET lpRequiredPrivileges              = reinterpret_cast<PPRIVILEGE_SET>(ucPrivilegesBuffer);
    lpRequiredPrivileges->PrivilegeCount             = 1;
    lpRequiredPrivileges->Control                    = PRIVILEGE_SET_ALL_NECESSARY;
    lpRequiredPrivileges->Privilege[0].Luid.LowPart  = SE_DEBUG_PRIVILEGE;
    lpRequiredPrivileges->Privilege[0].Luid.HighPart = 0;
    lpRequiredPrivileges->Privilege[0].Attributes    = 0;
    lpRequiredPrivileges->Privilege[1].Luid.LowPart  = SE_LOAD_DRIVER_PRIVILEGE;
    lpRequiredPrivileges->Privilege[1].Luid.HighPart = 0;
    lpRequiredPrivileges->Privilege[1].Attributes    = 0;

    if ( ::SePrivilegeCheck(
             lpRequiredPrivileges,
             &lpSecurityContext->AccessState->SubjectSecurityContext,
             Irp->RequestorMode) == false )
    {
        Status = STATUS_PRIVILEGE_NOT_HELD;
    }
    else
    {
        auto ScopedSpinLock       = CFB::Driver::Utils::ScopedLock(Globals->ContextLock);
        PEPROCESS pCallingProcess = ::IoGetCurrentProcess();

        if ( Globals->Owner == nullptr )
        {
            //
            // If there's no process owner, affect one and increment the handle counter
            //
            /// TODO: add some sort of authentication process
            Globals->Owner = pCallingProcess;
            Globals->SessionId++;
            ok("Locked device to EPROCESS=%p, starting session=%d...", Globals->Owner, Globals->SessionId);
            Status = STATUS_SUCCESS;
        }
        else if ( pCallingProcess == Globals->Owner )
        {
            //
            // If the CreateFile() originates from the owner process, increment the handle counter
            //
            Status = STATUS_SUCCESS;
        }
        else
        {
            //
            // In any other case, simply reject
            //
            Status = STATUS_DEVICE_ALREADY_ATTACHED;
        }
    }

    return CompleteRequest(Irp, Status, 0);
}


///
/// @brief Callback routine when closing a handle to the device
///
/// @param DeviceObject
/// @param Irp
///
/// @return NTSTATUS
///
NTSTATUS
_Function_class_(DRIVER_DISPATCH) DriverCloseRoutine(_In_ PDEVICE_OBJECT Device, _In_ PIRP Irp)
{
    UNREFERENCED_PARAMETER(Device);

    auto lock      = CFB::Driver::Utils::ScopedLock(Globals->ContextLock);
    Globals->Owner = nullptr;
    ok("Unlocked device...");
    return CompleteRequest(Irp, STATUS_SUCCESS, 0);
}


///
/// @brief Handle a IOCTL dipatcher for DeviceIoControl() from the broker
///
/// @param DeviceObject
/// @param Irp
///
/// @return NTSTATUS
///
NTSTATUS
_Function_class_(DRIVER_DISPATCH) DriverDeviceControlRoutine(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp)
{
    if ( DeviceObject != Globals->DeviceObject )
    {
        return CompleteRequest(Irp, STATUS_UNSUCCESSFUL, 0);
    }

    //
    // This should never happen as we checked the process when getting the handle, but still
    //
    if ( PsGetCurrentProcess() != Globals->Owner )
    {
        warn("Refusing access from EPROCESS %p (expected %p)", PsGetCurrentProcess(), Globals->Owner);
        return CompleteRequest(Irp, STATUS_ACCESS_DENIED, 0);
    }

    NTSTATUS Status                 = STATUS_SUCCESS;
    PIO_STACK_LOCATION CurrentStack = IoGetCurrentIrpStackLocation(Irp);
    NT_ASSERT(CurrentStack);

    const ULONG dwIoctlCode           = CurrentStack->Parameters.DeviceIoControl.IoControlCode;
    const CFB::Comms::Ioctl IoctlCode = CFB::Comms::Ioctl(dwIoctlCode);
    PVOID InputBuffer                 = Irp->AssociatedIrp.SystemBuffer;
    const ULONG InputBufferLen  = min(CurrentStack->Parameters.DeviceIoControl.InputBufferLength, CFB_DRIVER_MAX_PATH);
    PVOID OutputBuffer          = Irp->AssociatedIrp.SystemBuffer;
    const ULONG OutputBufferLen = CurrentStack->Parameters.DeviceIoControl.OutputBufferLength;
    ULONG dwDataWritten         = 0;

    dbg("Attempting to process IOCTL %#x (IRQL=%d, in=%luB, out=%luB)",
        IoctlCode,
        ::KeGetCurrentIrql(),
        InputBufferLen,
        OutputBufferLen);

    switch ( IoctlCode )
    {
    case CFB::Comms::Ioctl::HookDriver:
    {
        auto const DriverName = Utils::KUnicodeString(reinterpret_cast<wchar_t*>(InputBuffer), InputBufferLen);
        Status                = Globals->DriverManager.InsertDriver(DriverName);
        break;
    }

    case CFB::Comms::Ioctl::UnhookDriver:
    {
        auto const DriverName = Utils::KUnicodeString(reinterpret_cast<wchar_t*>(InputBuffer), InputBufferLen);
        Status                = Globals->DriverManager.RemoveDriver(DriverName);
        break;
    }

    case CFB::Comms::Ioctl::GetNumberOfDrivers:
    {
        dwDataWritten = Globals->DriverManager.Items().Size();
        Status        = STATUS_SUCCESS;
        break;
    }

    case CFB::Comms::Ioctl::EnableMonitoring:
    case CFB::Comms::Ioctl::DisableMonitoring:
    {
        auto DriverName = Utils::KUnicodeString(reinterpret_cast<wchar_t*>(InputBuffer), InputBufferLen);
        Status          = Globals->DriverManager.SetMonitoringState(
            DriverName.get(),
            (IoctlCode == CFB::Comms::Ioctl::EnableMonitoring));
        break;
    }

    case CFB::Comms::Ioctl::SetEventPointer:
    {
        const HANDLE hEvent = *((PHANDLE)InputBuffer);
        Status              = Globals->IrpManager.SetEvent(hEvent);
        break;
    }

    default:
        err("Received invalid IOCTL code 0x%08x", IoctlCode);
        Status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    dbg("Routine for IOCTL 0x%08x returned with Status=0x%x", IoctlCode, Status);
    if ( !NT_SUCCESS(Status) )
    {
        err("IOCTL %#x returned %#x", IoctlCode, Status);
        dwDataWritten = 0;
    }

    return CompleteRequest(Irp, Status, dwDataWritten);
}


///
/// @brief Handles ReadFile() request to the device: this will effectively read the hooked IRPs back to the broker.
/// If read buffer length is zero, it will return the expected size for the
/// buffer.
///
/// @param DeviceObject
/// @param Irp
///
/// @return NTSTATUS
///
NTSTATUS
_Function_class_(DRIVER_DISPATCH) DriverReadRoutine(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp)
{
    UNREFERENCED_PARAMETER(DeviceObject);

    PIO_STACK_LOCATION pStack = ::IoGetCurrentIrpStackLocation(Irp);
    if ( pStack == nullptr )
    {
        err("IoGetCurrentIrpStackLocation() failed (IRP %p)", Irp);
        return CompleteRequest(Irp, STATUS_INVALID_PARAMETER_1, 0);
    }

    const u32 RequestedBufferSize = pStack->Parameters.Read.Length;
    usize ExpectedBufferSize      = 0;
    usize DumpableIrpNumber       = 0;

    Globals->IrpManager.Items().ForEach(
        [&ExpectedBufferSize, &DumpableIrpNumber](CFB::Driver::CapturedIrp* Irp)
        {
            ExpectedBufferSize += Irp->Size();
            DumpableIrpNumber++;
            return true;
        });

    dbg("DriverReadRoutine(RequestedBufferSize = %uB , ExpectedBufferSize = %uB , CurrentIrpNumber = %u)",
        RequestedBufferSize,
        ExpectedBufferSize,
        DumpableIrpNumber);

    //
    // Otherwise, check RequestedBufferSize vs ExpectedBufferSize
    //
    if ( RequestedBufferSize < ExpectedBufferSize )
    {
        return CompleteRequest(Irp, STATUS_BUFFER_TOO_SMALL, ExpectedBufferSize);
    }

    NT_ASSERT(Irp->MdlAddress);
    PVOID Buffer = ::MmGetSystemAddressForMdlSafe(Irp->MdlAddress, NormalPagePriority);
    if ( Buffer == nullptr )
    {
        return CompleteRequest(Irp, STATUS_INSUFFICIENT_RESOURCES, 0);
    }

    //
    // Critical region for the IRP copy
    //
    {
        Utils::ScopedLock<Utils::KCriticalRegion>(Globals->IrpManager.CriticalRegion());
        const uptr BufferPointerBase = reinterpret_cast<uptr>(Buffer);
        const uptr BufferPointerHigh = BufferPointerBase + ExpectedBufferSize;
        uptr BufferPointer           = BufferPointerBase;

        for ( usize i = 0; i < DumpableIrpNumber; i++ )
        {
            dbg("Popping IRP %d/%d", i + 1, DumpableIrpNumber);

            //
            // Pop front the captured IRP
            //
            auto CurrentIrp = Globals->IrpManager.Pop();
            if ( CurrentIrp == nullptr )
            {
                err("Expected to find CapturedIrp %d/%d, but none was popped.", i, DumpableIrpNumber);
                return CompleteRequest(Irp, STATUS_BAD_DATA, 0);
            }

            //
            // Copy the header (always)
            //
            {
                const CFB::Comms::CapturedIrpHeader Header = CurrentIrp->ExportHeader();
                usize const DataSize                       = sizeof(CFB::Comms::CapturedIrpHeader);
                if ( BufferPointer + DataSize > BufferPointerHigh )
                {
                    return CompleteRequest(Irp, STATUS_BUFFER_OVERFLOW, 0);
                }

                RtlCopyMemory((PVOID)BufferPointer, &Header, DataSize);
                BufferPointer += DataSize;

                dbg("IRP %d/%d - Copied header: Process='%S', PID=%d, TID=%d",
                    i + 1,
                    DumpableIrpNumber,
                    Header.ProcessName,
                    Header.Pid,
                    Header.Tid);
            }

            //
            // Copy the IRP input buffer (if any)
            //
            {
                usize const DataSize = CurrentIrp->InputDataSize();
                if ( DataSize )
                {
                    if ( BufferPointer + DataSize > BufferPointerHigh )
                    {
                        return CompleteRequest(Irp, STATUS_BUFFER_OVERFLOW, 0);
                    }
                    RtlCopyMemory((PVOID)BufferPointer, CurrentIrp->InputBuffer(), DataSize);
                    BufferPointer += DataSize;
                }


                dbg("IRP %d/%d - Copied input buffer (%d bytes)",
                    i + 1,
                    DumpableIrpNumber,
                    CurrentIrp->InputDataSize());
                // #ifdef _DEBUG
                CFB::Utils::Hexdump(Buffer, MIN(CurrentIrp->InputDataSize(), CFB_MAX_HEXDUMP_BYTE));
                // #endif // _DEBUG
            }

            //
            // Copy the IRP output buffer (if any)
            //
            {
                usize const DataSize = CurrentIrp->OutputDataSize();
                if ( DataSize )
                {
                    if ( BufferPointer + DataSize > BufferPointerHigh )
                    {
                        return CompleteRequest(Irp, STATUS_BUFFER_OVERFLOW, 0);
                    }
                    RtlCopyMemory((PVOID)BufferPointer, CurrentIrp->OutputBuffer(), DataSize);
                    BufferPointer += DataSize;
                }

                dbg("IRP %d/%d - Copied output buffer (%d bytes)",
                    i + 1,
                    DumpableIrpNumber,
                    CurrentIrp->OutputDataSize());
                // #ifdef _DEBUG
                CFB::Utils::Hexdump(Buffer, MIN(CurrentIrp->OutputDataSize(), CFB_MAX_HEXDUMP_BYTE));
                // #endif // _DEBUG
            }

            dbg("IRP %d/%d returned to client", i + 1, DumpableIrpNumber);
        }
    }

    return CompleteRequest(Irp, STATUS_SUCCESS, ExpectedBufferSize);
}


///
/// @brief Handle cleanup
///
NTSTATUS
_Function_class_(DRIVER_DISPATCH) DriverCleanup(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp)
{
    UNREFERENCED_PARAMETER(DeviceObject);
    UNREFERENCED_PARAMETER(Irp);

    return CompleteRequest(Irp, STATUS_SUCCESS, 0);
}


///
/// @brief Driver entry function
///
EXTERN_C
NTSTATUS
DriverEntry(_In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath)
{
    UNREFERENCED_PARAMETER(RegistryPath);

    NTSTATUS Status             = STATUS_UNSUCCESSFUL;
    PDEVICE_OBJECT DeviceObject = nullptr;
    UNICODE_STRING Name         = RTL_CONSTANT_STRING(CFB_DEVICE_PATH);
    UNICODE_STRING SymLink      = RTL_CONSTANT_STRING(CFB_DOS_DEVICE_PATH);

    //
    // Make sure we clean everything correctly on function exit
    //
    auto CleanupOnFailure = CFB::Driver::Utils::ScopedWrapper(
        Status,
        [&Status]()
        {
            if ( !NT_SUCCESS(Status) )
            {
                warn("Failed to initialize driver, cleaning up...");
                if ( Globals )
                {
                    if ( Globals->DeviceObject )
                    {
                        ::IoDeleteDevice(Globals->DeviceObject);
                    }

                    delete Globals;
                    Globals = nullptr;
                }
            }
        });

    info("Initializing global context and device...");
    Globals = new GlobalContext();

    for ( auto i = 0; i < IRP_MJ_MAXIMUM_FUNCTION; i++ )
    {
        DriverObject->MajorFunction[i] = IrpNotImplementedHandler;
    }

    DriverObject->MajorFunction[IRP_MJ_CREATE]         = DriverCreateRoutine;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]          = DriverCloseRoutine;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = DriverDeviceControlRoutine;
    DriverObject->MajorFunction[IRP_MJ_READ]           = DriverReadRoutine;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP]        = DriverCleanup;
    DriverObject->DriverUnload                         = DriverUnloadRoutine;

    Status = ::IoCreateDevice(
        DriverObject,
        0,
        &Name,
        FILE_DEVICE_UNKNOWN,
        FILE_DEVICE_SECURE_OPEN,
        false, // ACL is managed by DriverCreateRoutine
        &DeviceObject);
    if ( !NT_SUCCESS(Status) )
    {
        err("Error creating device object (0x%08X)", Status);
        return Status;
    }

    ok("Device '%S' successfully created", CFB_DEVICE_NAME);

    Status = ::IoCreateSymbolicLink(&SymLink, &Name);
    if ( !NT_SUCCESS(Status) )
    {
        err("IoCreateSymbolicLink() failed: 0x%08X", Status);
        return Status;
    }

    ok("Symlink for '%S' created", CFB_DEVICE_NAME);

    DeviceObject->Flags |= DO_DIRECT_IO;
    DeviceObject->Flags &= (~DO_DEVICE_INITIALIZING);

    Globals->DeviceObject = DeviceObject;
    Globals->DriverObject = DriverObject;

    warn(
        "Device initialization for '%S' successful, use `%s` for debug logs",
        CFB_DEVICE_NAME,
        DML("ed nt !Kd_IHVDRIVER_Mask f", "ed nt !Kd_IHVDRIVER_Mask f"));

    return Status;
}

```

`Driver/Source/HookedDriver.cpp`:

```cpp
#define CFB_NS "[CFB::Driver::HookedDriver]"

#include "HookedDriver.hpp"

#include "Native.hpp"

namespace Callbacks = CFB::Driver::Callbacks;


namespace CFB::Driver
{
HookedDriver::HookedDriver(Utils::KUnicodeString const& UnicodePath) :
    Next {},
    OriginalDriverObject {nullptr},
    HookedDriverObject {new(NonPagedPoolNx) DRIVER_OBJECT},
    Path {UnicodePath},
    m_CapturingEnabled {false},
    m_State {HookState::Unhooked},
    m_InterceptedIrpsCount {0}
{
    dbg("Creating HookedDriver('%wZ')", Path.get());

    //
    // Find the driver from its name, link reference to the DRIVER_OBJECT to the lifetime of this HookedDriver
    //
    NTSTATUS Status = ::ObReferenceObjectByName(
        Path.get(),
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        nullptr,
        0,
        *IoDriverObjectType,
        KernelMode,
        nullptr,
        (PVOID*)&OriginalDriverObject);

    NT_ASSERT(NT_SUCCESS(Status));
    NT_ASSERT(OriginalDriverObject != nullptr);

    //
    // Create a copy DRIVER_OBJECT
    //
    ::memcpy(HookedDriverObject.get(), OriginalDriverObject, sizeof(DRIVER_OBJECT));

    //
    // Swap the IRP major function callbacks of the HookedDriver, avoiding to trigger PatchGuard
    //
    SwapCallbacks();

    NT_ASSERT(m_State == HookState::Hooked);
}


HookedDriver::~HookedDriver()
{
    dbg("Destroying HookedDriver '%wZ'", Path.get());

    DisableCapturing();
    RestoreCallbacks();

    ObDereferenceObject(OriginalDriverObject);
}


void
HookedDriver::SwapCallbacks()
{
    Utils::ScopedLock lock(m_CallbackLock);

    if ( m_State != HookState::Unhooked )
    {
        warn("Invalid state: expecting 'Unhooked'");
        return;
    }

    //
    // Hook all `IRP_MJ_*`
    //
    for ( u16 i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++ )
    {
        HookedDriverObject->MajorFunction[i] = (PDRIVER_DISPATCH)Callbacks::InterceptGenericRoutine;
    }

    //
    // Hook FastIo too
    //
    if ( OriginalDriverObject->FastIoDispatch )
    {
        HookedDriverObject->FastIoDispatch->FastIoDeviceControl =
            (PFAST_IO_DEVICE_CONTROL)Callbacks::InterceptGenericFastIoDeviceControl;
        HookedDriverObject->FastIoDispatch->FastIoRead  = (PFAST_IO_READ)Callbacks::InterceptGenericFastIoRead;
        HookedDriverObject->FastIoDispatch->FastIoWrite = (PFAST_IO_WRITE)Callbacks::InterceptGenericFastIoWrite;
    }

    //
    // This is where the hooking takes places: for each device object of the original driver, replace
    // the driver object pointer member making it point to the hooked version.
    //
    for ( PDEVICE_OBJECT DeviceObject = OriginalDriverObject->DeviceObject; DeviceObject != nullptr;
          DeviceObject                = DeviceObject->NextDevice )
    {
        if ( DeviceObject->DriverObject == OriginalDriverObject )
        {
            InterlockedExchangePointer((PVOID*)&DeviceObject->DriverObject, (PVOID)HookedDriverObject.get());
        }
    }

    //
    // Switch state flag to hooked
    //
    m_State = HookState::Hooked;
}


void
HookedDriver::RestoreCallbacks()
{
    Utils::ScopedLock lock(m_CallbackLock);

    if ( m_State != HookState::Hooked )
    {
        warn("Invalid state: expecting 'Hooked', got %#x", m_State);
        return;
    }

    //
    // Switch back state flag
    //
    m_State = HookState::Unhooked;

    //
    // For each device object, restore the original driver object pointer
    //
    for ( PDEVICE_OBJECT DeviceObject = OriginalDriverObject->DeviceObject; DeviceObject != nullptr;
          DeviceObject                = DeviceObject->NextDevice )
    {
        InterlockedExchangePointer((PVOID*)&DeviceObject->DriverObject, (PVOID)OriginalDriverObject);
    }
}


bool
HookedDriver::EnableCapturing()
{
    Utils::ScopedLock lock(m_CallbackLock);
    if ( m_State != HookState::Hooked )
    {
        return false;
    }
    if ( m_CapturingEnabled == false )
    {
        m_CapturingEnabled = true;
        dbg("Enabled IRP capturing for %wZ", Path.get());
    }
    return true;
}


bool
HookedDriver::DisableCapturing()
{
    Utils::ScopedLock lock(m_CallbackLock);
    m_CapturingEnabled = false;
    dbg("Disabled IRP capturing for %wZ", Path.get());
    return true;
}

void
HookedDriver::FlagAsInvalid()
{
    Utils::ScopedLock lock(m_CallbackLock);
    m_State = HookState::Invalid;
}


bool
HookedDriver::CanCapture() const
{
    return m_State == HookState::Hooked && m_CapturingEnabled == true;
}


usize const
HookedDriver::IrpCount() const
{
    return m_InterceptedIrpsCount;
}


void
HookedDriver::IncrementIrpCount()
{
    InterlockedIncrement64((PLONG64)&m_InterceptedIrpsCount);
}


void
HookedDriver::DecrementIrpCount()
{
    InterlockedDecrement64((PLONG64)&m_InterceptedIrpsCount);
}


HookedDriver&
HookedDriver::operator++()
{
    IncrementIrpCount();
    return *this;
}


HookedDriver&
HookedDriver::operator--()
{
    DecrementIrpCount();
    return *this;
}


} // namespace CFB::Driver

```

`Driver/Source/HookedDriverManager.cpp`:

```cpp
#define CFB_NS "[CFB::Driver::HookedDriverManager]"

#include "HookedDriverManager.hpp"

#include "Context.hpp"
#include "Native.hpp"


namespace Utils = CFB::Driver::Utils;

namespace CFB::Driver
{
HookedDriverManager::HookedDriverManager()
{
    dbg("Creating HookedDriverManager");
}

HookedDriverManager::~HookedDriverManager()
{
    dbg("Destroying HookedDriverManager");

    HookedDriverManager::RemoveAllDrivers();
}

NTSTATUS
HookedDriverManager::InsertDriver(Utils::KUnicodeString const& UnicodePath)
{
    NTSTATUS Status        = STATUS_UNSUCCESSFUL;
    PDRIVER_OBJECT pDriver = nullptr;

    dbg("HookedDriverManager::InsertDriver('%wZ')", UnicodePath.get());

    //
    // Resolve the given `Path` parameter as name for Driver Object
    //
    {
        Status = ::ObReferenceObjectByName(
            UnicodePath.get(),
            OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
            nullptr,
            0,
            *IoDriverObjectType,
            KernelMode,
            nullptr,
            (PVOID*)&pDriver);

        if ( !NT_SUCCESS(Status) )
        {
            return Status;
        }
    }


    dbg("HookedDriverManager::InsertDriver(): Found driver at %p", pDriver);

    //
    // On any failure, make sure to dereference the object
    //
    Utils::ScopedWrapper ScopedDriverObject(
        pDriver,
        [&pDriver]()
        {
            //
            // Always dereference of scope-leave. `HookedDriver` manages its own driver reference
            //
            dbg("HookedDriverManager::InsertDriver(): dereferencing object %p", pDriver);
            ObDereferenceObject(pDriver);
        });

    //
    // Refuse to hook IrpMonitor
    //
    if ( pDriver == Globals->DriverObject )
    {
        err("HookedDriverManager::InsertDriver(): refusing to hook %S", CFB_DRIVER_BASENAME);
        return STATUS_ACCESS_DENIED;
    }


    Utils::ScopedLock lock(m_Mutex);

    //
    // Check if the driver is already hooked
    //
    auto FromDriverAddress = [&ScopedDriverObject](const HookedDriver* h)
    {
        return h->OriginalDriverObject == ScopedDriverObject.get();
    };

    if ( m_Entries.Find(FromDriverAddress) != nullptr )
    {
        return STATUS_ALREADY_REGISTERED;
    }

    //
    // Check if there's space
    //
    if ( m_Entries.Size() >= CFB_MAX_HOOKED_DRIVERS )
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    dbg("HookedDriverManager::InsertDriver(): Driver '%wZ' (%p) is not hooked, hooking now...",
        UnicodePath.get(),
        ScopedDriverObject.get());

    //
    // Allocate the new HookedDriver, this will result in all the `IRP_MJ_*` of the driver being
    // redirected to IrpMonitor
    //
    auto NewHookedDriver = new HookedDriver(UnicodePath);

    //
    // Last, insert the driver to the linked list
    //
    m_Entries.PushBack(NewHookedDriver);

    dbg("Added '%wZ' to the hooked driver list, TotalEntries=%d", NewHookedDriver->Path.get(), m_Entries.Size());

    info("Driver '%wZ' is hooked", NewHookedDriver->Path.get());

    return STATUS_SUCCESS;
}

NTSTATUS
HookedDriverManager::RemoveDriver(Utils::KUnicodeString const& UnicodePath)
{
    Utils::ScopedLock lock(m_Mutex);

    const usize PathMaxLength = min(UnicodePath.size(), CFB_DRIVER_MAX_PATH);
    auto FromDriverPath       = [&UnicodePath, &PathMaxLength](HookedDriver* h)
    {
        return h->Path == UnicodePath;
    };

    auto MatchedDriver = m_Entries.Find(FromDriverPath);
    if ( MatchedDriver == nullptr )
    {
        return STATUS_NOT_FOUND;
    }

    dbg("Removing HookedDriver '%wZ' (%p) ...", MatchedDriver->Path.get(), MatchedDriver);

    m_Entries -= MatchedDriver;

    ObDereferenceObject(MatchedDriver->OriginalDriverObject);

    info("Driver '%wZ' is unhooked", MatchedDriver->Path.get());
    delete MatchedDriver;

    return STATUS_SUCCESS;
}

NTSTATUS
HookedDriverManager::RemoveAllDrivers()
{
    dbg("Removing all drivers");

    Utils::ScopedLock lock(m_Mutex);
    do
    {
        auto Entry = m_Entries.PopBack();
        if ( Entry == nullptr )
        {
            break;
        }
        delete Entry;
    } while ( true );

    return STATUS_SUCCESS;
}

NTSTATUS
HookedDriverManager::SetMonitoringState(const PUNICODE_STRING UnicodePath, bool bEnable)
{
    Utils::ScopedLock lock(m_Mutex);

    const usize PathMaxLength = min(UnicodePath->Length, CFB_DRIVER_MAX_PATH);
    auto FromDriverPath       = [&UnicodePath, &PathMaxLength](HookedDriver* h)
    {
        return h->Path == UnicodePath;
    };

    auto MatchedDriver = m_Entries.Find(FromDriverPath);
    if ( MatchedDriver == nullptr )
    {
        return STATUS_NOT_FOUND;
    }

    const bool OldState = MatchedDriver->CanCapture();
    (bEnable) ? MatchedDriver->EnableCapturing() : MatchedDriver->DisableCapturing();
    const bool DriverStateChanged = OldState != MatchedDriver->CanCapture();

    dbg("HookedDriverManager::SetMonitoringState('%wZ', %s): state %schanged, CanCapture=%s",
        MatchedDriver->Path.get(),
        boolstr(bEnable),
        (DriverStateChanged ? "" : "un"),
        boolstr(MatchedDriver->CanCapture()));

    info("IRPs to driver '%wZ' are %scaptured", MatchedDriver->Path.get(), MatchedDriver->CanCapture() ? "" : "not ");

    return STATUS_SUCCESS;
}

Utils::LinkedList<HookedDriver>&
HookedDriverManager::Items()
{
    return m_Entries;
}
} // namespace CFB::Driver

```

`Driver/Source/IrpMonitor.inf`:

```inf
;
; IrpMonitor.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=System
ClassGuid={4d36e97d-e325-11ce-bfc1-08002be10318}
Provider=%ManufacturerName%
DriverVer=01/01/1970
CatalogFile=Driver.cat
PnpLockdown=1

[DestinationDirs]
DefaultDestDir = 10           ; %SystemRoot%


[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
IrpMonitor.sys = 1,,


[DefaultInstall]
OptionDesc = %ServiceDesc%
CopyFiles  = IrpMonitor.DriverFiles

[IrpMonitor.DriverFiles]
IrpMonitor.sys,,,0x00000004        ; COPYFLG_NOVERSIONCHECK

[DefaultInstall.Services]
AddService = %ServiceName%,,IrpMonitor.ServiceInstall

[IrpMonitor.ServiceInstall]
DisplayName   = %ServiceName%
Description   = %ServiceDesc%
ServiceBinary = %10%\IrpMonitor.sys
ServiceType   = 1              ; SERVICE_KERNEL_DRIVER
StartType     = 3              ; SERVICE_AUTO_START ; SERVICE_DEMAND_START = 3
ErrorControl  = 1              ; SERVICE_ERROR_NORMAL

[Strings]
ManufacturerName = "BlahCat Corp"
DiskName = "IrpMonitor Installation Disk"
ServiceName = "IrpMonitor"
ServiceDesc = "IrpMonitor: hooks/unhooks arbitrary drivers on the system to capture the IRPs sent to those drivers."

```

`GUI/CMakeLists.txt`:

```txt
project(
    GUI
    LANGUAGES CXX
    VERSION 0.2.0
    DESCRIPTION "ImGui-based GUI for CFB"
    HOMEPAGE_URL https://github.com/hugsy/cfb
)

message(STATUS "Configuring '${PROJECT_NAME}'")

set(GUI_SOURCE_DIR ${CFB_ROOT_DIR}/GUI/Source)
set(GUI_HEADER_DIR ${CFB_ROOT_DIR}/GUI/Headers)

set(GUI_VERSION_MAJOR ${PROJECT_VERSION_MAJOR} CACHE INTERNAL "GUI_VERSION_MAJOR")
set(GUI_VERSION_MINOR ${PROJECT_VERSION_MINOR} CACHE INTERNAL "GUI_VERSION_MINOR")
set(GUI_VERSION_PATCH ${PROJECT_VERSION_PATCH} CACHE INTERNAL "GUI_VERSION_PATCH")

set(
    GUI_HEADER_FILES

    ${GUI_HEADER_DIR}/App.hpp
    ${GUI_HEADER_DIR}/GuiUtils.hpp
    ${GUI_HEADER_DIR}/Helpers.hpp
    ${GUI_HEADER_DIR}/Network.hpp
)

set(
    GUI_SOURCE_FILES

    ${GUI_SOURCE_DIR}/main.cpp
    ${GUI_SOURCE_DIR}/App.cpp
    ${GUI_SOURCE_DIR}/GuiUtils.cpp
    ${GUI_SOURCE_DIR}/Helpers.cpp
)

#
# Create the broker rc file
#
set(GUI_RC_FILE ${GUI_SOURCE_DIR}/GUI.rc)
set(GUI_RES_FILE ${GUI_SOURCE_DIR}/GUI.res)
cmake_path(SET CFB_GUI_ICON_PATH "${CFB_ROOT_DIR}/Assets/Images/logo/logo.ico")
configure_file(${GUI_RC_FILE}.in ${GUI_RC_FILE} NEWLINE_STYLE WIN32 ESCAPE_QUOTES)

#
# Build the GUI
#
add_executable(${PROJECT_NAME} ${GUI_SOURCE_FILES})
add_dependencies(${PROJECT_NAME} CFB::User::CommonLib)
add_executable(CFB::User::Gui ALIAS ${PROJECT_NAME})

#
# Compilation directives
#
target_include_directories(
    ${PROJECT_NAME}
    PUBLIC

    PRIVATE
    ${GUI_HEADER_DIR}
    $<TARGET_PROPERTY:Deps::ImGUI,INCLUDE_DIRECTORIES>
)

target_compile_definitions(${PROJECT_NAME} PUBLIC _UNICODE UNICODE ImTextureID=ImU64)

target_compile_options(
    ${PROJECT_NAME}
    PUBLIC
    $<$<COMPILE_LANGUAGE:CXX>:/Zc:__cplusplus>
    $<$<NOT:$<STREQUAL:${CMAKE_GENERATOR_PLATFORM},arm64>>:$<$<CONFIG:Debug>:/fsanitize=address>>

    PRIVATE
    $<IF:$<CONFIG:Debug>,/WX /Gm- /permissive-,/WX /permissive>
)

#
# Linking directives
#
target_link_options(
    ${PROJECT_NAME}
    PUBLIC
    /SUBSYSTEM:WINDOWS
    $<$<NOT:$<STREQUAL:${CMAKE_GENERATOR_PLATFORM},arm64>>:$<$<CONFIG:Debug>:/InferAsanLibs>>

    PRIVATE
)

target_link_libraries(
    ${PROJECT_NAME}

    PRIVATE
    ${GUI_RES_FILE}
    CFB::User::CommonLib
    Deps::ImGUI
    Deps::JSON
    Ws2_32.lib
    D3D12.lib
    DXGI.lib
)

#
# Compile the resource file
#
add_custom_command(
    TARGET ${PROJECT_NAME} PRE_BUILD
    COMMAND
    rc /nologo /fo ${GUI_RES_FILE} /r ${GUI_RC_FILE}
    COMMENT
    "Compiling '${GUI_RES_FILE}' resource file"
)

#
# Install directives
#
install(TARGETS ${PROJECT_NAME} DESTINATION Tools)
install(FILES $<TARGET_PDB_FILE:${PROJECT_NAME}> DESTINATION Tools OPTIONAL)

```

`GUI/Headers/Addons/icons_font_awesome_6.h`:

```h
// Generated by https://github.com/juliettef/IconFontCppHeaders script GenerateIconFontCppHeaders.py for languages C and C++
// from https://github.com/FortAwesome/Font-Awesome/raw/6.x/metadata/icons.yml
// for use with https://github.com/FortAwesome/Font-Awesome/blob/6.x/webfonts/fa-regular-400.ttf, https://github.com/FortAwesome/Font-Awesome/blob/6.x/webfonts/fa-solid-900.ttf
#pragma once

#define FONT_ICON_FILE_NAME_FAR "fa-regular-400.ttf"
#define FONT_ICON_FILE_NAME_FAS "fa-solid-900.ttf"

#define ICON_MIN_FA 0xe005
#define ICON_MAX_16_FA 0xf8ff
#define ICON_MAX_FA 0xf8ff
#define ICON_FA_0 "0"	// U+0030
#define ICON_FA_1 "1"	// U+0031
#define ICON_FA_2 "2"	// U+0032
#define ICON_FA_3 "3"	// U+0033
#define ICON_FA_4 "4"	// U+0034
#define ICON_FA_5 "5"	// U+0035
#define ICON_FA_6 "6"	// U+0036
#define ICON_FA_7 "7"	// U+0037
#define ICON_FA_8 "8"	// U+0038
#define ICON_FA_9 "9"	// U+0039
#define ICON_FA_A "A"	// U+0041
#define ICON_FA_ADDRESS_BOOK "\xef\x8a\xb9"	// U+f2b9
#define ICON_FA_ADDRESS_CARD "\xef\x8a\xbb"	// U+f2bb
#define ICON_FA_ALIGN_CENTER "\xef\x80\xb7"	// U+f037
#define ICON_FA_ALIGN_JUSTIFY "\xef\x80\xb9"	// U+f039
#define ICON_FA_ALIGN_LEFT "\xef\x80\xb6"	// U+f036
#define ICON_FA_ALIGN_RIGHT "\xef\x80\xb8"	// U+f038
#define ICON_FA_ANCHOR "\xef\x84\xbd"	// U+f13d
#define ICON_FA_ANCHOR_CIRCLE_CHECK "\xee\x92\xaa"	// U+e4aa
#define ICON_FA_ANCHOR_CIRCLE_EXCLAMATION "\xee\x92\xab"	// U+e4ab
#define ICON_FA_ANCHOR_CIRCLE_XMARK "\xee\x92\xac"	// U+e4ac
#define ICON_FA_ANCHOR_LOCK "\xee\x92\xad"	// U+e4ad
#define ICON_FA_ANGLE_DOWN "\xef\x84\x87"	// U+f107
#define ICON_FA_ANGLE_LEFT "\xef\x84\x84"	// U+f104
#define ICON_FA_ANGLE_RIGHT "\xef\x84\x85"	// U+f105
#define ICON_FA_ANGLE_UP "\xef\x84\x86"	// U+f106
#define ICON_FA_ANGLES_DOWN "\xef\x84\x83"	// U+f103
#define ICON_FA_ANGLES_LEFT "\xef\x84\x80"	// U+f100
#define ICON_FA_ANGLES_RIGHT "\xef\x84\x81"	// U+f101
#define ICON_FA_ANGLES_UP "\xef\x84\x82"	// U+f102
#define ICON_FA_ANKH "\xef\x99\x84"	// U+f644
#define ICON_FA_APPLE_WHOLE "\xef\x97\x91"	// U+f5d1
#define ICON_FA_ARCHWAY "\xef\x95\x97"	// U+f557
#define ICON_FA_ARROW_DOWN "\xef\x81\xa3"	// U+f063
#define ICON_FA_ARROW_DOWN_1_9 "\xef\x85\xa2"	// U+f162
#define ICON_FA_ARROW_DOWN_9_1 "\xef\xa2\x86"	// U+f886
#define ICON_FA_ARROW_DOWN_A_Z "\xef\x85\x9d"	// U+f15d
#define ICON_FA_ARROW_DOWN_LONG "\xef\x85\xb5"	// U+f175
#define ICON_FA_ARROW_DOWN_SHORT_WIDE "\xef\xa2\x84"	// U+f884
#define ICON_FA_ARROW_DOWN_UP_ACROSS_LINE "\xee\x92\xaf"	// U+e4af
#define ICON_FA_ARROW_DOWN_UP_LOCK "\xee\x92\xb0"	// U+e4b0
#define ICON_FA_ARROW_DOWN_WIDE_SHORT "\xef\x85\xa0"	// U+f160
#define ICON_FA_ARROW_DOWN_Z_A "\xef\xa2\x81"	// U+f881
#define ICON_FA_ARROW_LEFT "\xef\x81\xa0"	// U+f060
#define ICON_FA_ARROW_LEFT_LONG "\xef\x85\xb7"	// U+f177
#define ICON_FA_ARROW_POINTER "\xef\x89\x85"	// U+f245
#define ICON_FA_ARROW_RIGHT "\xef\x81\xa1"	// U+f061
#define ICON_FA_ARROW_RIGHT_ARROW_LEFT "\xef\x83\xac"	// U+f0ec
#define ICON_FA_ARROW_RIGHT_FROM_BRACKET "\xef\x82\x8b"	// U+f08b
#define ICON_FA_ARROW_RIGHT_LONG "\xef\x85\xb8"	// U+f178
#define ICON_FA_ARROW_RIGHT_TO_BRACKET "\xef\x82\x90"	// U+f090
#define ICON_FA_ARROW_RIGHT_TO_CITY "\xee\x92\xb3"	// U+e4b3
#define ICON_FA_ARROW_ROTATE_LEFT "\xef\x83\xa2"	// U+f0e2
#define ICON_FA_ARROW_ROTATE_RIGHT "\xef\x80\x9e"	// U+f01e
#define ICON_FA_ARROW_TREND_DOWN "\xee\x82\x97"	// U+e097
#define ICON_FA_ARROW_TREND_UP "\xee\x82\x98"	// U+e098
#define ICON_FA_ARROW_TURN_DOWN "\xef\x85\x89"	// U+f149
#define ICON_FA_ARROW_TURN_UP "\xef\x85\x88"	// U+f148
#define ICON_FA_ARROW_UP "\xef\x81\xa2"	// U+f062
#define ICON_FA_ARROW_UP_1_9 "\xef\x85\xa3"	// U+f163
#define ICON_FA_ARROW_UP_9_1 "\xef\xa2\x87"	// U+f887
#define ICON_FA_ARROW_UP_A_Z "\xef\x85\x9e"	// U+f15e
#define ICON_FA_ARROW_UP_FROM_BRACKET "\xee\x82\x9a"	// U+e09a
#define ICON_FA_ARROW_UP_FROM_GROUND_WATER "\xee\x92\xb5"	// U+e4b5
#define ICON_FA_ARROW_UP_FROM_WATER_PUMP "\xee\x92\xb6"	// U+e4b6
#define ICON_FA_ARROW_UP_LONG "\xef\x85\xb6"	// U+f176
#define ICON_FA_ARROW_UP_RIGHT_DOTS "\xee\x92\xb7"	// U+e4b7
#define ICON_FA_ARROW_UP_RIGHT_FROM_SQUARE "\xef\x82\x8e"	// U+f08e
#define ICON_FA_ARROW_UP_SHORT_WIDE "\xef\xa2\x85"	// U+f885
#define ICON_FA_ARROW_UP_WIDE_SHORT "\xef\x85\xa1"	// U+f161
#define ICON_FA_ARROW_UP_Z_A "\xef\xa2\x82"	// U+f882
#define ICON_FA_ARROWS_DOWN_TO_LINE "\xee\x92\xb8"	// U+e4b8
#define ICON_FA_ARROWS_DOWN_TO_PEOPLE "\xee\x92\xb9"	// U+e4b9
#define ICON_FA_ARROWS_LEFT_RIGHT "\xef\x81\xbe"	// U+f07e
#define ICON_FA_ARROWS_LEFT_RIGHT_TO_LINE "\xee\x92\xba"	// U+e4ba
#define ICON_FA_ARROWS_ROTATE "\xef\x80\xa1"	// U+f021
#define ICON_FA_ARROWS_SPIN "\xee\x92\xbb"	// U+e4bb
#define ICON_FA_ARROWS_SPLIT_UP_AND_LEFT "\xee\x92\xbc"	// U+e4bc
#define ICON_FA_ARROWS_TO_CIRCLE "\xee\x92\xbd"	// U+e4bd
#define ICON_FA_ARROWS_TO_DOT "\xee\x92\xbe"	// U+e4be
#define ICON_FA_ARROWS_TO_EYE "\xee\x92\xbf"	// U+e4bf
#define ICON_FA_ARROWS_TURN_RIGHT "\xee\x93\x80"	// U+e4c0
#define ICON_FA_ARROWS_TURN_TO_DOTS "\xee\x93\x81"	// U+e4c1
#define ICON_FA_ARROWS_UP_DOWN "\xef\x81\xbd"	// U+f07d
#define ICON_FA_ARROWS_UP_DOWN_LEFT_RIGHT "\xef\x81\x87"	// U+f047
#define ICON_FA_ARROWS_UP_TO_LINE "\xee\x93\x82"	// U+e4c2
#define ICON_FA_ASTERISK "*"	// U+002a
#define ICON_FA_AT "@"	// U+0040
#define ICON_FA_ATOM "\xef\x97\x92"	// U+f5d2
#define ICON_FA_AUDIO_DESCRIPTION "\xef\x8a\x9e"	// U+f29e
#define ICON_FA_AUSTRAL_SIGN "\xee\x82\xa9"	// U+e0a9
#define ICON_FA_AWARD "\xef\x95\x99"	// U+f559
#define ICON_FA_B "B"	// U+0042
#define ICON_FA_BABY "\xef\x9d\xbc"	// U+f77c
#define ICON_FA_BABY_CARRIAGE "\xef\x9d\xbd"	// U+f77d
#define ICON_FA_BACKWARD "\xef\x81\x8a"	// U+f04a
#define ICON_FA_BACKWARD_FAST "\xef\x81\x89"	// U+f049
#define ICON_FA_BACKWARD_STEP "\xef\x81\x88"	// U+f048
#define ICON_FA_BACON "\xef\x9f\xa5"	// U+f7e5
#define ICON_FA_BACTERIA "\xee\x81\x99"	// U+e059
#define ICON_FA_BACTERIUM "\xee\x81\x9a"	// U+e05a
#define ICON_FA_BAG_SHOPPING "\xef\x8a\x90"	// U+f290
#define ICON_FA_BAHAI "\xef\x99\xa6"	// U+f666
#define ICON_FA_BAHT_SIGN "\xee\x82\xac"	// U+e0ac
#define ICON_FA_BAN "\xef\x81\x9e"	// U+f05e
#define ICON_FA_BAN_SMOKING "\xef\x95\x8d"	// U+f54d
#define ICON_FA_BANDAGE "\xef\x91\xa2"	// U+f462
#define ICON_FA_BANGLADESHI_TAKA_SIGN "\xee\x8b\xa6"	// U+e2e6
#define ICON_FA_BARCODE "\xef\x80\xaa"	// U+f02a
#define ICON_FA_BARS "\xef\x83\x89"	// U+f0c9
#define ICON_FA_BARS_PROGRESS "\xef\xa0\xa8"	// U+f828
#define ICON_FA_BARS_STAGGERED "\xef\x95\x90"	// U+f550
#define ICON_FA_BASEBALL "\xef\x90\xb3"	// U+f433
#define ICON_FA_BASEBALL_BAT_BALL "\xef\x90\xb2"	// U+f432
#define ICON_FA_BASKET_SHOPPING "\xef\x8a\x91"	// U+f291
#define ICON_FA_BASKETBALL "\xef\x90\xb4"	// U+f434
#define ICON_FA_BATH "\xef\x8b\x8d"	// U+f2cd
#define ICON_FA_BATTERY_EMPTY "\xef\x89\x84"	// U+f244
#define ICON_FA_BATTERY_FULL "\xef\x89\x80"	// U+f240
#define ICON_FA_BATTERY_HALF "\xef\x89\x82"	// U+f242
#define ICON_FA_BATTERY_QUARTER "\xef\x89\x83"	// U+f243
#define ICON_FA_BATTERY_THREE_QUARTERS "\xef\x89\x81"	// U+f241
#define ICON_FA_BED "\xef\x88\xb6"	// U+f236
#define ICON_FA_BED_PULSE "\xef\x92\x87"	// U+f487
#define ICON_FA_BEER_MUG_EMPTY "\xef\x83\xbc"	// U+f0fc
#define ICON_FA_BELL "\xef\x83\xb3"	// U+f0f3
#define ICON_FA_BELL_CONCIERGE "\xef\x95\xa2"	// U+f562
#define ICON_FA_BELL_SLASH "\xef\x87\xb6"	// U+f1f6
#define ICON_FA_BEZIER_CURVE "\xef\x95\x9b"	// U+f55b
#define ICON_FA_BICYCLE "\xef\x88\x86"	// U+f206
#define ICON_FA_BINOCULARS "\xef\x87\xa5"	// U+f1e5
#define ICON_FA_BIOHAZARD "\xef\x9e\x80"	// U+f780
#define ICON_FA_BITCOIN_SIGN "\xee\x82\xb4"	// U+e0b4
#define ICON_FA_BLENDER "\xef\x94\x97"	// U+f517
#define ICON_FA_BLENDER_PHONE "\xef\x9a\xb6"	// U+f6b6
#define ICON_FA_BLOG "\xef\x9e\x81"	// U+f781
#define ICON_FA_BOLD "\xef\x80\xb2"	// U+f032
#define ICON_FA_BOLT "\xef\x83\xa7"	// U+f0e7
#define ICON_FA_BOLT_LIGHTNING "\xee\x82\xb7"	// U+e0b7
#define ICON_FA_BOMB "\xef\x87\xa2"	// U+f1e2
#define ICON_FA_BONE "\xef\x97\x97"	// U+f5d7
#define ICON_FA_BONG "\xef\x95\x9c"	// U+f55c
#define ICON_FA_BOOK "\xef\x80\xad"	// U+f02d
#define ICON_FA_BOOK_ATLAS "\xef\x95\x98"	// U+f558
#define ICON_FA_BOOK_BIBLE "\xef\x99\x87"	// U+f647
#define ICON_FA_BOOK_BOOKMARK "\xee\x82\xbb"	// U+e0bb
#define ICON_FA_BOOK_JOURNAL_WHILLS "\xef\x99\xaa"	// U+f66a
#define ICON_FA_BOOK_MEDICAL "\xef\x9f\xa6"	// U+f7e6
#define ICON_FA_BOOK_OPEN "\xef\x94\x98"	// U+f518
#define ICON_FA_BOOK_OPEN_READER "\xef\x97\x9a"	// U+f5da
#define ICON_FA_BOOK_QURAN "\xef\x9a\x87"	// U+f687
#define ICON_FA_BOOK_SKULL "\xef\x9a\xb7"	// U+f6b7
#define ICON_FA_BOOK_TANAKH "\xef\xa0\xa7"	// U+f827
#define ICON_FA_BOOKMARK "\xef\x80\xae"	// U+f02e
#define ICON_FA_BORDER_ALL "\xef\xa1\x8c"	// U+f84c
#define ICON_FA_BORDER_NONE "\xef\xa1\x90"	// U+f850
#define ICON_FA_BORDER_TOP_LEFT "\xef\xa1\x93"	// U+f853
#define ICON_FA_BORE_HOLE "\xee\x93\x83"	// U+e4c3
#define ICON_FA_BOTTLE_DROPLET "\xee\x93\x84"	// U+e4c4
#define ICON_FA_BOTTLE_WATER "\xee\x93\x85"	// U+e4c5
#define ICON_FA_BOWL_FOOD "\xee\x93\x86"	// U+e4c6
#define ICON_FA_BOWL_RICE "\xee\x8b\xab"	// U+e2eb
#define ICON_FA_BOWLING_BALL "\xef\x90\xb6"	// U+f436
#define ICON_FA_BOX "\xef\x91\xa6"	// U+f466
#define ICON_FA_BOX_ARCHIVE "\xef\x86\x87"	// U+f187
#define ICON_FA_BOX_OPEN "\xef\x92\x9e"	// U+f49e
#define ICON_FA_BOX_TISSUE "\xee\x81\x9b"	// U+e05b
#define ICON_FA_BOXES_PACKING "\xee\x93\x87"	// U+e4c7
#define ICON_FA_BOXES_STACKED "\xef\x91\xa8"	// U+f468
#define ICON_FA_BRAILLE "\xef\x8a\xa1"	// U+f2a1
#define ICON_FA_BRAIN "\xef\x97\x9c"	// U+f5dc
#define ICON_FA_BRAZILIAN_REAL_SIGN "\xee\x91\xac"	// U+e46c
#define ICON_FA_BREAD_SLICE "\xef\x9f\xac"	// U+f7ec
#define ICON_FA_BRIDGE "\xee\x93\x88"	// U+e4c8
#define ICON_FA_BRIDGE_CIRCLE_CHECK "\xee\x93\x89"	// U+e4c9
#define ICON_FA_BRIDGE_CIRCLE_EXCLAMATION "\xee\x93\x8a"	// U+e4ca
#define ICON_FA_BRIDGE_CIRCLE_XMARK "\xee\x93\x8b"	// U+e4cb
#define ICON_FA_BRIDGE_LOCK "\xee\x93\x8c"	// U+e4cc
#define ICON_FA_BRIDGE_WATER "\xee\x93\x8e"	// U+e4ce
#define ICON_FA_BRIEFCASE "\xef\x82\xb1"	// U+f0b1
#define ICON_FA_BRIEFCASE_MEDICAL "\xef\x91\xa9"	// U+f469
#define ICON_FA_BROOM "\xef\x94\x9a"	// U+f51a
#define ICON_FA_BROOM_BALL "\xef\x91\x98"	// U+f458
#define ICON_FA_BRUSH "\xef\x95\x9d"	// U+f55d
#define ICON_FA_BUCKET "\xee\x93\x8f"	// U+e4cf
#define ICON_FA_BUG "\xef\x86\x88"	// U+f188
#define ICON_FA_BUG_SLASH "\xee\x92\x90"	// U+e490
#define ICON_FA_BUGS "\xee\x93\x90"	// U+e4d0
#define ICON_FA_BUILDING "\xef\x86\xad"	// U+f1ad
#define ICON_FA_BUILDING_CIRCLE_ARROW_RIGHT "\xee\x93\x91"	// U+e4d1
#define ICON_FA_BUILDING_CIRCLE_CHECK "\xee\x93\x92"	// U+e4d2
#define ICON_FA_BUILDING_CIRCLE_EXCLAMATION "\xee\x93\x93"	// U+e4d3
#define ICON_FA_BUILDING_CIRCLE_XMARK "\xee\x93\x94"	// U+e4d4
#define ICON_FA_BUILDING_COLUMNS "\xef\x86\x9c"	// U+f19c
#define ICON_FA_BUILDING_FLAG "\xee\x93\x95"	// U+e4d5
#define ICON_FA_BUILDING_LOCK "\xee\x93\x96"	// U+e4d6
#define ICON_FA_BUILDING_NGO "\xee\x93\x97"	// U+e4d7
#define ICON_FA_BUILDING_SHIELD "\xee\x93\x98"	// U+e4d8
#define ICON_FA_BUILDING_UN "\xee\x93\x99"	// U+e4d9
#define ICON_FA_BUILDING_USER "\xee\x93\x9a"	// U+e4da
#define ICON_FA_BUILDING_WHEAT "\xee\x93\x9b"	// U+e4db
#define ICON_FA_BULLHORN "\xef\x82\xa1"	// U+f0a1
#define ICON_FA_BULLSEYE "\xef\x85\x80"	// U+f140
#define ICON_FA_BURGER "\xef\xa0\x85"	// U+f805
#define ICON_FA_BURST "\xee\x93\x9c"	// U+e4dc
#define ICON_FA_BUS "\xef\x88\x87"	// U+f207
#define ICON_FA_BUS_SIMPLE "\xef\x95\x9e"	// U+f55e
#define ICON_FA_BUSINESS_TIME "\xef\x99\x8a"	// U+f64a
#define ICON_FA_C "C"	// U+0043
#define ICON_FA_CABLE_CAR "\xef\x9f\x9a"	// U+f7da
#define ICON_FA_CAKE_CANDLES "\xef\x87\xbd"	// U+f1fd
#define ICON_FA_CALCULATOR "\xef\x87\xac"	// U+f1ec
#define ICON_FA_CALENDAR "\xef\x84\xb3"	// U+f133
#define ICON_FA_CALENDAR_CHECK "\xef\x89\xb4"	// U+f274
#define ICON_FA_CALENDAR_DAY "\xef\x9e\x83"	// U+f783
#define ICON_FA_CALENDAR_DAYS "\xef\x81\xb3"	// U+f073
#define ICON_FA_CALENDAR_MINUS "\xef\x89\xb2"	// U+f272
#define ICON_FA_CALENDAR_PLUS "\xef\x89\xb1"	// U+f271
#define ICON_FA_CALENDAR_WEEK "\xef\x9e\x84"	// U+f784
#define ICON_FA_CALENDAR_XMARK "\xef\x89\xb3"	// U+f273
#define ICON_FA_CAMERA "\xef\x80\xb0"	// U+f030
#define ICON_FA_CAMERA_RETRO "\xef\x82\x83"	// U+f083
#define ICON_FA_CAMERA_ROTATE "\xee\x83\x98"	// U+e0d8
#define ICON_FA_CAMPGROUND "\xef\x9a\xbb"	// U+f6bb
#define ICON_FA_CANDY_CANE "\xef\x9e\x86"	// U+f786
#define ICON_FA_CANNABIS "\xef\x95\x9f"	// U+f55f
#define ICON_FA_CAPSULES "\xef\x91\xab"	// U+f46b
#define ICON_FA_CAR "\xef\x86\xb9"	// U+f1b9
#define ICON_FA_CAR_BATTERY "\xef\x97\x9f"	// U+f5df
#define ICON_FA_CAR_BURST "\xef\x97\xa1"	// U+f5e1
#define ICON_FA_CAR_ON "\xee\x93\x9d"	// U+e4dd
#define ICON_FA_CAR_REAR "\xef\x97\x9e"	// U+f5de
#define ICON_FA_CAR_SIDE "\xef\x97\xa4"	// U+f5e4
#define ICON_FA_CAR_TUNNEL "\xee\x93\x9e"	// U+e4de
#define ICON_FA_CARAVAN "\xef\xa3\xbf"	// U+f8ff
#define ICON_FA_CARET_DOWN "\xef\x83\x97"	// U+f0d7
#define ICON_FA_CARET_LEFT "\xef\x83\x99"	// U+f0d9
#define ICON_FA_CARET_RIGHT "\xef\x83\x9a"	// U+f0da
#define ICON_FA_CARET_UP "\xef\x83\x98"	// U+f0d8
#define ICON_FA_CARROT "\xef\x9e\x87"	// U+f787
#define ICON_FA_CART_ARROW_DOWN "\xef\x88\x98"	// U+f218
#define ICON_FA_CART_FLATBED "\xef\x91\xb4"	// U+f474
#define ICON_FA_CART_FLATBED_SUITCASE "\xef\x96\x9d"	// U+f59d
#define ICON_FA_CART_PLUS "\xef\x88\x97"	// U+f217
#define ICON_FA_CART_SHOPPING "\xef\x81\xba"	// U+f07a
#define ICON_FA_CASH_REGISTER "\xef\x9e\x88"	// U+f788
#define ICON_FA_CAT "\xef\x9a\xbe"	// U+f6be
#define ICON_FA_CEDI_SIGN "\xee\x83\x9f"	// U+e0df
#define ICON_FA_CENT_SIGN "\xee\x8f\xb5"	// U+e3f5
#define ICON_FA_CERTIFICATE "\xef\x82\xa3"	// U+f0a3
#define ICON_FA_CHAIR "\xef\x9b\x80"	// U+f6c0
#define ICON_FA_CHALKBOARD "\xef\x94\x9b"	// U+f51b
#define ICON_FA_CHALKBOARD_USER "\xef\x94\x9c"	// U+f51c
#define ICON_FA_CHAMPAGNE_GLASSES "\xef\x9e\x9f"	// U+f79f
#define ICON_FA_CHARGING_STATION "\xef\x97\xa7"	// U+f5e7
#define ICON_FA_CHART_AREA "\xef\x87\xbe"	// U+f1fe
#define ICON_FA_CHART_BAR "\xef\x82\x80"	// U+f080
#define ICON_FA_CHART_COLUMN "\xee\x83\xa3"	// U+e0e3
#define ICON_FA_CHART_GANTT "\xee\x83\xa4"	// U+e0e4
#define ICON_FA_CHART_LINE "\xef\x88\x81"	// U+f201
#define ICON_FA_CHART_PIE "\xef\x88\x80"	// U+f200
#define ICON_FA_CHART_SIMPLE "\xee\x91\xb3"	// U+e473
#define ICON_FA_CHECK "\xef\x80\x8c"	// U+f00c
#define ICON_FA_CHECK_DOUBLE "\xef\x95\xa0"	// U+f560
#define ICON_FA_CHECK_TO_SLOT "\xef\x9d\xb2"	// U+f772
#define ICON_FA_CHEESE "\xef\x9f\xaf"	// U+f7ef
#define ICON_FA_CHESS "\xef\x90\xb9"	// U+f439
#define ICON_FA_CHESS_BISHOP "\xef\x90\xba"	// U+f43a
#define ICON_FA_CHESS_BOARD "\xef\x90\xbc"	// U+f43c
#define ICON_FA_CHESS_KING "\xef\x90\xbf"	// U+f43f
#define ICON_FA_CHESS_KNIGHT "\xef\x91\x81"	// U+f441
#define ICON_FA_CHESS_PAWN "\xef\x91\x83"	// U+f443
#define ICON_FA_CHESS_QUEEN "\xef\x91\x85"	// U+f445
#define ICON_FA_CHESS_ROOK "\xef\x91\x87"	// U+f447
#define ICON_FA_CHEVRON_DOWN "\xef\x81\xb8"	// U+f078
#define ICON_FA_CHEVRON_LEFT "\xef\x81\x93"	// U+f053
#define ICON_FA_CHEVRON_RIGHT "\xef\x81\x94"	// U+f054
#define ICON_FA_CHEVRON_UP "\xef\x81\xb7"	// U+f077
#define ICON_FA_CHILD "\xef\x86\xae"	// U+f1ae
#define ICON_FA_CHILD_COMBATANT "\xee\x93\xa0"	// U+e4e0
#define ICON_FA_CHILD_DRESS "\xee\x96\x9c"	// U+e59c
#define ICON_FA_CHILD_REACHING "\xee\x96\x9d"	// U+e59d
#define ICON_FA_CHILDREN "\xee\x93\xa1"	// U+e4e1
#define ICON_FA_CHURCH "\xef\x94\x9d"	// U+f51d
#define ICON_FA_CIRCLE "\xef\x84\x91"	// U+f111
#define ICON_FA_CIRCLE_ARROW_DOWN "\xef\x82\xab"	// U+f0ab
#define ICON_FA_CIRCLE_ARROW_LEFT "\xef\x82\xa8"	// U+f0a8
#define ICON_FA_CIRCLE_ARROW_RIGHT "\xef\x82\xa9"	// U+f0a9
#define ICON_FA_CIRCLE_ARROW_UP "\xef\x82\xaa"	// U+f0aa
#define ICON_FA_CIRCLE_CHECK "\xef\x81\x98"	// U+f058
#define ICON_FA_CIRCLE_CHEVRON_DOWN "\xef\x84\xba"	// U+f13a
#define ICON_FA_CIRCLE_CHEVRON_LEFT "\xef\x84\xb7"	// U+f137
#define ICON_FA_CIRCLE_CHEVRON_RIGHT "\xef\x84\xb8"	// U+f138
#define ICON_FA_CIRCLE_CHEVRON_UP "\xef\x84\xb9"	// U+f139
#define ICON_FA_CIRCLE_DOLLAR_TO_SLOT "\xef\x92\xb9"	// U+f4b9
#define ICON_FA_CIRCLE_DOT "\xef\x86\x92"	// U+f192
#define ICON_FA_CIRCLE_DOWN "\xef\x8d\x98"	// U+f358
#define ICON_FA_CIRCLE_EXCLAMATION "\xef\x81\xaa"	// U+f06a
#define ICON_FA_CIRCLE_H "\xef\x91\xbe"	// U+f47e
#define ICON_FA_CIRCLE_HALF_STROKE "\xef\x81\x82"	// U+f042
#define ICON_FA_CIRCLE_INFO "\xef\x81\x9a"	// U+f05a
#define ICON_FA_CIRCLE_LEFT "\xef\x8d\x99"	// U+f359
#define ICON_FA_CIRCLE_MINUS "\xef\x81\x96"	// U+f056
#define ICON_FA_CIRCLE_NODES "\xee\x93\xa2"	// U+e4e2
#define ICON_FA_CIRCLE_NOTCH "\xef\x87\x8e"	// U+f1ce
#define ICON_FA_CIRCLE_PAUSE "\xef\x8a\x8b"	// U+f28b
#define ICON_FA_CIRCLE_PLAY "\xef\x85\x84"	// U+f144
#define ICON_FA_CIRCLE_PLUS "\xef\x81\x95"	// U+f055
#define ICON_FA_CIRCLE_QUESTION "\xef\x81\x99"	// U+f059
#define ICON_FA_CIRCLE_RADIATION "\xef\x9e\xba"	// U+f7ba
#define ICON_FA_CIRCLE_RIGHT "\xef\x8d\x9a"	// U+f35a
#define ICON_FA_CIRCLE_STOP "\xef\x8a\x8d"	// U+f28d
#define ICON_FA_CIRCLE_UP "\xef\x8d\x9b"	// U+f35b
#define ICON_FA_CIRCLE_USER "\xef\x8a\xbd"	// U+f2bd
#define ICON_FA_CIRCLE_XMARK "\xef\x81\x97"	// U+f057
#define ICON_FA_CITY "\xef\x99\x8f"	// U+f64f
#define ICON_FA_CLAPPERBOARD "\xee\x84\xb1"	// U+e131
#define ICON_FA_CLIPBOARD "\xef\x8c\xa8"	// U+f328
#define ICON_FA_CLIPBOARD_CHECK "\xef\x91\xac"	// U+f46c
#define ICON_FA_CLIPBOARD_LIST "\xef\x91\xad"	// U+f46d
#define ICON_FA_CLIPBOARD_QUESTION "\xee\x93\xa3"	// U+e4e3
#define ICON_FA_CLIPBOARD_USER "\xef\x9f\xb3"	// U+f7f3
#define ICON_FA_CLOCK "\xef\x80\x97"	// U+f017
#define ICON_FA_CLOCK_ROTATE_LEFT "\xef\x87\x9a"	// U+f1da
#define ICON_FA_CLONE "\xef\x89\x8d"	// U+f24d
#define ICON_FA_CLOSED_CAPTIONING "\xef\x88\x8a"	// U+f20a
#define ICON_FA_CLOUD "\xef\x83\x82"	// U+f0c2
#define ICON_FA_CLOUD_ARROW_DOWN "\xef\x83\xad"	// U+f0ed
#define ICON_FA_CLOUD_ARROW_UP "\xef\x83\xae"	// U+f0ee
#define ICON_FA_CLOUD_BOLT "\xef\x9d\xac"	// U+f76c
#define ICON_FA_CLOUD_MEATBALL "\xef\x9c\xbb"	// U+f73b
#define ICON_FA_CLOUD_MOON "\xef\x9b\x83"	// U+f6c3
#define ICON_FA_CLOUD_MOON_RAIN "\xef\x9c\xbc"	// U+f73c
#define ICON_FA_CLOUD_RAIN "\xef\x9c\xbd"	// U+f73d
#define ICON_FA_CLOUD_SHOWERS_HEAVY "\xef\x9d\x80"	// U+f740
#define ICON_FA_CLOUD_SHOWERS_WATER "\xee\x93\xa4"	// U+e4e4
#define ICON_FA_CLOUD_SUN "\xef\x9b\x84"	// U+f6c4
#define ICON_FA_CLOUD_SUN_RAIN "\xef\x9d\x83"	// U+f743
#define ICON_FA_CLOVER "\xee\x84\xb9"	// U+e139
#define ICON_FA_CODE "\xef\x84\xa1"	// U+f121
#define ICON_FA_CODE_BRANCH "\xef\x84\xa6"	// U+f126
#define ICON_FA_CODE_COMMIT "\xef\x8e\x86"	// U+f386
#define ICON_FA_CODE_COMPARE "\xee\x84\xba"	// U+e13a
#define ICON_FA_CODE_FORK "\xee\x84\xbb"	// U+e13b
#define ICON_FA_CODE_MERGE "\xef\x8e\x87"	// U+f387
#define ICON_FA_CODE_PULL_REQUEST "\xee\x84\xbc"	// U+e13c
#define ICON_FA_COINS "\xef\x94\x9e"	// U+f51e
#define ICON_FA_COLON_SIGN "\xee\x85\x80"	// U+e140
#define ICON_FA_COMMENT "\xef\x81\xb5"	// U+f075
#define ICON_FA_COMMENT_DOLLAR "\xef\x99\x91"	// U+f651
#define ICON_FA_COMMENT_DOTS "\xef\x92\xad"	// U+f4ad
#define ICON_FA_COMMENT_MEDICAL "\xef\x9f\xb5"	// U+f7f5
#define ICON_FA_COMMENT_SLASH "\xef\x92\xb3"	// U+f4b3
#define ICON_FA_COMMENT_SMS "\xef\x9f\x8d"	// U+f7cd
#define ICON_FA_COMMENTS "\xef\x82\x86"	// U+f086
#define ICON_FA_COMMENTS_DOLLAR "\xef\x99\x93"	// U+f653
#define ICON_FA_COMPACT_DISC "\xef\x94\x9f"	// U+f51f
#define ICON_FA_COMPASS "\xef\x85\x8e"	// U+f14e
#define ICON_FA_COMPASS_DRAFTING "\xef\x95\xa8"	// U+f568
#define ICON_FA_COMPRESS "\xef\x81\xa6"	// U+f066
#define ICON_FA_COMPUTER "\xee\x93\xa5"	// U+e4e5
#define ICON_FA_COMPUTER_MOUSE "\xef\xa3\x8c"	// U+f8cc
#define ICON_FA_COOKIE "\xef\x95\xa3"	// U+f563
#define ICON_FA_COOKIE_BITE "\xef\x95\xa4"	// U+f564
#define ICON_FA_COPY "\xef\x83\x85"	// U+f0c5
#define ICON_FA_COPYRIGHT "\xef\x87\xb9"	// U+f1f9
#define ICON_FA_COUCH "\xef\x92\xb8"	// U+f4b8
#define ICON_FA_COW "\xef\x9b\x88"	// U+f6c8
#define ICON_FA_CREDIT_CARD "\xef\x82\x9d"	// U+f09d
#define ICON_FA_CROP "\xef\x84\xa5"	// U+f125
#define ICON_FA_CROP_SIMPLE "\xef\x95\xa5"	// U+f565
#define ICON_FA_CROSS "\xef\x99\x94"	// U+f654
#define ICON_FA_CROSSHAIRS "\xef\x81\x9b"	// U+f05b
#define ICON_FA_CROW "\xef\x94\xa0"	// U+f520
#define ICON_FA_CROWN "\xef\x94\xa1"	// U+f521
#define ICON_FA_CRUTCH "\xef\x9f\xb7"	// U+f7f7
#define ICON_FA_CRUZEIRO_SIGN "\xee\x85\x92"	// U+e152
#define ICON_FA_CUBE "\xef\x86\xb2"	// U+f1b2
#define ICON_FA_CUBES "\xef\x86\xb3"	// U+f1b3
#define ICON_FA_CUBES_STACKED "\xee\x93\xa6"	// U+e4e6
#define ICON_FA_D "D"	// U+0044
#define ICON_FA_DATABASE "\xef\x87\x80"	// U+f1c0
#define ICON_FA_DELETE_LEFT "\xef\x95\x9a"	// U+f55a
#define ICON_FA_DEMOCRAT "\xef\x9d\x87"	// U+f747
#define ICON_FA_DESKTOP "\xef\x8e\x90"	// U+f390
#define ICON_FA_DHARMACHAKRA "\xef\x99\x95"	// U+f655
#define ICON_FA_DIAGRAM_NEXT "\xee\x91\xb6"	// U+e476
#define ICON_FA_DIAGRAM_PREDECESSOR "\xee\x91\xb7"	// U+e477
#define ICON_FA_DIAGRAM_PROJECT "\xef\x95\x82"	// U+f542
#define ICON_FA_DIAGRAM_SUCCESSOR "\xee\x91\xba"	// U+e47a
#define ICON_FA_DIAMOND "\xef\x88\x99"	// U+f219
#define ICON_FA_DIAMOND_TURN_RIGHT "\xef\x97\xab"	// U+f5eb
#define ICON_FA_DICE "\xef\x94\xa2"	// U+f522
#define ICON_FA_DICE_D20 "\xef\x9b\x8f"	// U+f6cf
#define ICON_FA_DICE_D6 "\xef\x9b\x91"	// U+f6d1
#define ICON_FA_DICE_FIVE "\xef\x94\xa3"	// U+f523
#define ICON_FA_DICE_FOUR "\xef\x94\xa4"	// U+f524
#define ICON_FA_DICE_ONE "\xef\x94\xa5"	// U+f525
#define ICON_FA_DICE_SIX "\xef\x94\xa6"	// U+f526
#define ICON_FA_DICE_THREE "\xef\x94\xa7"	// U+f527
#define ICON_FA_DICE_TWO "\xef\x94\xa8"	// U+f528
#define ICON_FA_DISEASE "\xef\x9f\xba"	// U+f7fa
#define ICON_FA_DISPLAY "\xee\x85\xa3"	// U+e163
#define ICON_FA_DIVIDE "\xef\x94\xa9"	// U+f529
#define ICON_FA_DNA "\xef\x91\xb1"	// U+f471
#define ICON_FA_DOG "\xef\x9b\x93"	// U+f6d3
#define ICON_FA_DOLLAR_SIGN "$"	// U+0024
#define ICON_FA_DOLLY "\xef\x91\xb2"	// U+f472
#define ICON_FA_DONG_SIGN "\xee\x85\xa9"	// U+e169
#define ICON_FA_DOOR_CLOSED "\xef\x94\xaa"	// U+f52a
#define ICON_FA_DOOR_OPEN "\xef\x94\xab"	// U+f52b
#define ICON_FA_DOVE "\xef\x92\xba"	// U+f4ba
#define ICON_FA_DOWN_LEFT_AND_UP_RIGHT_TO_CENTER "\xef\x90\xa2"	// U+f422
#define ICON_FA_DOWN_LONG "\xef\x8c\x89"	// U+f309
#define ICON_FA_DOWNLOAD "\xef\x80\x99"	// U+f019
#define ICON_FA_DRAGON "\xef\x9b\x95"	// U+f6d5
#define ICON_FA_DRAW_POLYGON "\xef\x97\xae"	// U+f5ee
#define ICON_FA_DROPLET "\xef\x81\x83"	// U+f043
#define ICON_FA_DROPLET_SLASH "\xef\x97\x87"	// U+f5c7
#define ICON_FA_DRUM "\xef\x95\xa9"	// U+f569
#define ICON_FA_DRUM_STEELPAN "\xef\x95\xaa"	// U+f56a
#define ICON_FA_DRUMSTICK_BITE "\xef\x9b\x97"	// U+f6d7
#define ICON_FA_DUMBBELL "\xef\x91\x8b"	// U+f44b
#define ICON_FA_DUMPSTER "\xef\x9e\x93"	// U+f793
#define ICON_FA_DUMPSTER_FIRE "\xef\x9e\x94"	// U+f794
#define ICON_FA_DUNGEON "\xef\x9b\x99"	// U+f6d9
#define ICON_FA_E "E"	// U+0045
#define ICON_FA_EAR_DEAF "\xef\x8a\xa4"	// U+f2a4
#define ICON_FA_EAR_LISTEN "\xef\x8a\xa2"	// U+f2a2
#define ICON_FA_EARTH_AFRICA "\xef\x95\xbc"	// U+f57c
#define ICON_FA_EARTH_AMERICAS "\xef\x95\xbd"	// U+f57d
#define ICON_FA_EARTH_ASIA "\xef\x95\xbe"	// U+f57e
#define ICON_FA_EARTH_EUROPE "\xef\x9e\xa2"	// U+f7a2
#define ICON_FA_EARTH_OCEANIA "\xee\x91\xbb"	// U+e47b
#define ICON_FA_EGG "\xef\x9f\xbb"	// U+f7fb
#define ICON_FA_EJECT "\xef\x81\x92"	// U+f052
#define ICON_FA_ELEVATOR "\xee\x85\xad"	// U+e16d
#define ICON_FA_ELLIPSIS "\xef\x85\x81"	// U+f141
#define ICON_FA_ELLIPSIS_VERTICAL "\xef\x85\x82"	// U+f142
#define ICON_FA_ENVELOPE "\xef\x83\xa0"	// U+f0e0
#define ICON_FA_ENVELOPE_CIRCLE_CHECK "\xee\x93\xa8"	// U+e4e8
#define ICON_FA_ENVELOPE_OPEN "\xef\x8a\xb6"	// U+f2b6
#define ICON_FA_ENVELOPE_OPEN_TEXT "\xef\x99\x98"	// U+f658
#define ICON_FA_ENVELOPES_BULK "\xef\x99\xb4"	// U+f674
#define ICON_FA_EQUALS "="	// U+003d
#define ICON_FA_ERASER "\xef\x84\xad"	// U+f12d
#define ICON_FA_ETHERNET "\xef\x9e\x96"	// U+f796
#define ICON_FA_EURO_SIGN "\xef\x85\x93"	// U+f153
#define ICON_FA_EXCLAMATION "!"	// U+0021
#define ICON_FA_EXPAND "\xef\x81\xa5"	// U+f065
#define ICON_FA_EXPLOSION "\xee\x93\xa9"	// U+e4e9
#define ICON_FA_EYE "\xef\x81\xae"	// U+f06e
#define ICON_FA_EYE_DROPPER "\xef\x87\xbb"	// U+f1fb
#define ICON_FA_EYE_LOW_VISION "\xef\x8a\xa8"	// U+f2a8
#define ICON_FA_EYE_SLASH "\xef\x81\xb0"	// U+f070
#define ICON_FA_F "F"	// U+0046
#define ICON_FA_FACE_ANGRY "\xef\x95\x96"	// U+f556
#define ICON_FA_FACE_DIZZY "\xef\x95\xa7"	// U+f567
#define ICON_FA_FACE_FLUSHED "\xef\x95\xb9"	// U+f579
#define ICON_FA_FACE_FROWN "\xef\x84\x99"	// U+f119
#define ICON_FA_FACE_FROWN_OPEN "\xef\x95\xba"	// U+f57a
#define ICON_FA_FACE_GRIMACE "\xef\x95\xbf"	// U+f57f
#define ICON_FA_FACE_GRIN "\xef\x96\x80"	// U+f580
#define ICON_FA_FACE_GRIN_BEAM "\xef\x96\x82"	// U+f582
#define ICON_FA_FACE_GRIN_BEAM_SWEAT "\xef\x96\x83"	// U+f583
#define ICON_FA_FACE_GRIN_HEARTS "\xef\x96\x84"	// U+f584
#define ICON_FA_FACE_GRIN_SQUINT "\xef\x96\x85"	// U+f585
#define ICON_FA_FACE_GRIN_SQUINT_TEARS "\xef\x96\x86"	// U+f586
#define ICON_FA_FACE_GRIN_STARS "\xef\x96\x87"	// U+f587
#define ICON_FA_FACE_GRIN_TEARS "\xef\x96\x88"	// U+f588
#define ICON_FA_FACE_GRIN_TONGUE "\xef\x96\x89"	// U+f589
#define ICON_FA_FACE_GRIN_TONGUE_SQUINT "\xef\x96\x8a"	// U+f58a
#define ICON_FA_FACE_GRIN_TONGUE_WINK "\xef\x96\x8b"	// U+f58b
#define ICON_FA_FACE_GRIN_WIDE "\xef\x96\x81"	// U+f581
#define ICON_FA_FACE_GRIN_WINK "\xef\x96\x8c"	// U+f58c
#define ICON_FA_FACE_KISS "\xef\x96\x96"	// U+f596
#define ICON_FA_FACE_KISS_BEAM "\xef\x96\x97"	// U+f597
#define ICON_FA_FACE_KISS_WINK_HEART "\xef\x96\x98"	// U+f598
#define ICON_FA_FACE_LAUGH "\xef\x96\x99"	// U+f599
#define ICON_FA_FACE_LAUGH_BEAM "\xef\x96\x9a"	// U+f59a
#define ICON_FA_FACE_LAUGH_SQUINT "\xef\x96\x9b"	// U+f59b
#define ICON_FA_FACE_LAUGH_WINK "\xef\x96\x9c"	// U+f59c
#define ICON_FA_FACE_MEH "\xef\x84\x9a"	// U+f11a
#define ICON_FA_FACE_MEH_BLANK "\xef\x96\xa4"	// U+f5a4
#define ICON_FA_FACE_ROLLING_EYES "\xef\x96\xa5"	// U+f5a5
#define ICON_FA_FACE_SAD_CRY "\xef\x96\xb3"	// U+f5b3
#define ICON_FA_FACE_SAD_TEAR "\xef\x96\xb4"	// U+f5b4
#define ICON_FA_FACE_SMILE "\xef\x84\x98"	// U+f118
#define ICON_FA_FACE_SMILE_BEAM "\xef\x96\xb8"	// U+f5b8
#define ICON_FA_FACE_SMILE_WINK "\xef\x93\x9a"	// U+f4da
#define ICON_FA_FACE_SURPRISE "\xef\x97\x82"	// U+f5c2
#define ICON_FA_FACE_TIRED "\xef\x97\x88"	// U+f5c8
#define ICON_FA_FAN "\xef\xa1\xa3"	// U+f863
#define ICON_FA_FAUCET "\xee\x80\x85"	// U+e005
#define ICON_FA_FAUCET_DRIP "\xee\x80\x86"	// U+e006
#define ICON_FA_FAX "\xef\x86\xac"	// U+f1ac
#define ICON_FA_FEATHER "\xef\x94\xad"	// U+f52d
#define ICON_FA_FEATHER_POINTED "\xef\x95\xab"	// U+f56b
#define ICON_FA_FERRY "\xee\x93\xaa"	// U+e4ea
#define ICON_FA_FILE "\xef\x85\x9b"	// U+f15b
#define ICON_FA_FILE_ARROW_DOWN "\xef\x95\xad"	// U+f56d
#define ICON_FA_FILE_ARROW_UP "\xef\x95\xb4"	// U+f574
#define ICON_FA_FILE_AUDIO "\xef\x87\x87"	// U+f1c7
#define ICON_FA_FILE_CIRCLE_CHECK "\xee\x96\xa0"	// U+e5a0
#define ICON_FA_FILE_CIRCLE_EXCLAMATION "\xee\x93\xab"	// U+e4eb
#define ICON_FA_FILE_CIRCLE_MINUS "\xee\x93\xad"	// U+e4ed
#define ICON_FA_FILE_CIRCLE_PLUS "\xee\x92\x94"	// U+e494
#define ICON_FA_FILE_CIRCLE_QUESTION "\xee\x93\xaf"	// U+e4ef
#define ICON_FA_FILE_CIRCLE_XMARK "\xee\x96\xa1"	// U+e5a1
#define ICON_FA_FILE_CODE "\xef\x87\x89"	// U+f1c9
#define ICON_FA_FILE_CONTRACT "\xef\x95\xac"	// U+f56c
#define ICON_FA_FILE_CSV "\xef\x9b\x9d"	// U+f6dd
#define ICON_FA_FILE_EXCEL "\xef\x87\x83"	// U+f1c3
#define ICON_FA_FILE_EXPORT "\xef\x95\xae"	// U+f56e
#define ICON_FA_FILE_IMAGE "\xef\x87\x85"	// U+f1c5
#define ICON_FA_FILE_IMPORT "\xef\x95\xaf"	// U+f56f
#define ICON_FA_FILE_INVOICE "\xef\x95\xb0"	// U+f570
#define ICON_FA_FILE_INVOICE_DOLLAR "\xef\x95\xb1"	// U+f571
#define ICON_FA_FILE_LINES "\xef\x85\x9c"	// U+f15c
#define ICON_FA_FILE_MEDICAL "\xef\x91\xb7"	// U+f477
#define ICON_FA_FILE_PDF "\xef\x87\x81"	// U+f1c1
#define ICON_FA_FILE_PEN "\xef\x8c\x9c"	// U+f31c
#define ICON_FA_FILE_POWERPOINT "\xef\x87\x84"	// U+f1c4
#define ICON_FA_FILE_PRESCRIPTION "\xef\x95\xb2"	// U+f572
#define ICON_FA_FILE_SHIELD "\xee\x93\xb0"	// U+e4f0
#define ICON_FA_FILE_SIGNATURE "\xef\x95\xb3"	// U+f573
#define ICON_FA_FILE_VIDEO "\xef\x87\x88"	// U+f1c8
#define ICON_FA_FILE_WAVEFORM "\xef\x91\xb8"	// U+f478
#define ICON_FA_FILE_WORD "\xef\x87\x82"	// U+f1c2
#define ICON_FA_FILE_ZIPPER "\xef\x87\x86"	// U+f1c6
#define ICON_FA_FILL "\xef\x95\xb5"	// U+f575
#define ICON_FA_FILL_DRIP "\xef\x95\xb6"	// U+f576
#define ICON_FA_FILM "\xef\x80\x88"	// U+f008
#define ICON_FA_FILTER "\xef\x82\xb0"	// U+f0b0
#define ICON_FA_FILTER_CIRCLE_DOLLAR "\xef\x99\xa2"	// U+f662
#define ICON_FA_FILTER_CIRCLE_XMARK "\xee\x85\xbb"	// U+e17b
#define ICON_FA_FINGERPRINT "\xef\x95\xb7"	// U+f577
#define ICON_FA_FIRE "\xef\x81\xad"	// U+f06d
#define ICON_FA_FIRE_BURNER "\xee\x93\xb1"	// U+e4f1
#define ICON_FA_FIRE_EXTINGUISHER "\xef\x84\xb4"	// U+f134
#define ICON_FA_FIRE_FLAME_CURVED "\xef\x9f\xa4"	// U+f7e4
#define ICON_FA_FIRE_FLAME_SIMPLE "\xef\x91\xaa"	// U+f46a
#define ICON_FA_FISH "\xef\x95\xb8"	// U+f578
#define ICON_FA_FISH_FINS "\xee\x93\xb2"	// U+e4f2
#define ICON_FA_FLAG "\xef\x80\xa4"	// U+f024
#define ICON_FA_FLAG_CHECKERED "\xef\x84\x9e"	// U+f11e
#define ICON_FA_FLAG_USA "\xef\x9d\x8d"	// U+f74d
#define ICON_FA_FLASK "\xef\x83\x83"	// U+f0c3
#define ICON_FA_FLASK_VIAL "\xee\x93\xb3"	// U+e4f3
#define ICON_FA_FLOPPY_DISK "\xef\x83\x87"	// U+f0c7
#define ICON_FA_FLORIN_SIGN "\xee\x86\x84"	// U+e184
#define ICON_FA_FOLDER "\xef\x81\xbb"	// U+f07b
#define ICON_FA_FOLDER_CLOSED "\xee\x86\x85"	// U+e185
#define ICON_FA_FOLDER_MINUS "\xef\x99\x9d"	// U+f65d
#define ICON_FA_FOLDER_OPEN "\xef\x81\xbc"	// U+f07c
#define ICON_FA_FOLDER_PLUS "\xef\x99\x9e"	// U+f65e
#define ICON_FA_FOLDER_TREE "\xef\xa0\x82"	// U+f802
#define ICON_FA_FONT "\xef\x80\xb1"	// U+f031
#define ICON_FA_FONT_AWESOME "\xef\x8a\xb4"	// U+f2b4
#define ICON_FA_FOOTBALL "\xef\x91\x8e"	// U+f44e
#define ICON_FA_FORWARD "\xef\x81\x8e"	// U+f04e
#define ICON_FA_FORWARD_FAST "\xef\x81\x90"	// U+f050
#define ICON_FA_FORWARD_STEP "\xef\x81\x91"	// U+f051
#define ICON_FA_FRANC_SIGN "\xee\x86\x8f"	// U+e18f
#define ICON_FA_FROG "\xef\x94\xae"	// U+f52e
#define ICON_FA_FUTBOL "\xef\x87\xa3"	// U+f1e3
#define ICON_FA_G "G"	// U+0047
#define ICON_FA_GAMEPAD "\xef\x84\x9b"	// U+f11b
#define ICON_FA_GAS_PUMP "\xef\x94\xaf"	// U+f52f
#define ICON_FA_GAUGE "\xef\x98\xa4"	// U+f624
#define ICON_FA_GAUGE_HIGH "\xef\x98\xa5"	// U+f625
#define ICON_FA_GAUGE_SIMPLE "\xef\x98\xa9"	// U+f629
#define ICON_FA_GAUGE_SIMPLE_HIGH "\xef\x98\xaa"	// U+f62a
#define ICON_FA_GAVEL "\xef\x83\xa3"	// U+f0e3
#define ICON_FA_GEAR "\xef\x80\x93"	// U+f013
#define ICON_FA_GEARS "\xef\x82\x85"	// U+f085
#define ICON_FA_GEM "\xef\x8e\xa5"	// U+f3a5
#define ICON_FA_GENDERLESS "\xef\x88\xad"	// U+f22d
#define ICON_FA_GHOST "\xef\x9b\xa2"	// U+f6e2
#define ICON_FA_GIFT "\xef\x81\xab"	// U+f06b
#define ICON_FA_GIFTS "\xef\x9e\x9c"	// U+f79c
#define ICON_FA_GLASS_WATER "\xee\x93\xb4"	// U+e4f4
#define ICON_FA_GLASS_WATER_DROPLET "\xee\x93\xb5"	// U+e4f5
#define ICON_FA_GLASSES "\xef\x94\xb0"	// U+f530
#define ICON_FA_GLOBE "\xef\x82\xac"	// U+f0ac
#define ICON_FA_GOLF_BALL_TEE "\xef\x91\x90"	// U+f450
#define ICON_FA_GOPURAM "\xef\x99\xa4"	// U+f664
#define ICON_FA_GRADUATION_CAP "\xef\x86\x9d"	// U+f19d
#define ICON_FA_GREATER_THAN ">"	// U+003e
#define ICON_FA_GREATER_THAN_EQUAL "\xef\x94\xb2"	// U+f532
#define ICON_FA_GRIP "\xef\x96\x8d"	// U+f58d
#define ICON_FA_GRIP_LINES "\xef\x9e\xa4"	// U+f7a4
#define ICON_FA_GRIP_LINES_VERTICAL "\xef\x9e\xa5"	// U+f7a5
#define ICON_FA_GRIP_VERTICAL "\xef\x96\x8e"	// U+f58e
#define ICON_FA_GROUP_ARROWS_ROTATE "\xee\x93\xb6"	// U+e4f6
#define ICON_FA_GUARANI_SIGN "\xee\x86\x9a"	// U+e19a
#define ICON_FA_GUITAR "\xef\x9e\xa6"	// U+f7a6
#define ICON_FA_GUN "\xee\x86\x9b"	// U+e19b
#define ICON_FA_H "H"	// U+0048
#define ICON_FA_HAMMER "\xef\x9b\xa3"	// U+f6e3
#define ICON_FA_HAMSA "\xef\x99\xa5"	// U+f665
#define ICON_FA_HAND "\xef\x89\x96"	// U+f256
#define ICON_FA_HAND_BACK_FIST "\xef\x89\x95"	// U+f255
#define ICON_FA_HAND_DOTS "\xef\x91\xa1"	// U+f461
#define ICON_FA_HAND_FIST "\xef\x9b\x9e"	// U+f6de
#define ICON_FA_HAND_HOLDING "\xef\x92\xbd"	// U+f4bd
#define ICON_FA_HAND_HOLDING_DOLLAR "\xef\x93\x80"	// U+f4c0
#define ICON_FA_HAND_HOLDING_DROPLET "\xef\x93\x81"	// U+f4c1
#define ICON_FA_HAND_HOLDING_HAND "\xee\x93\xb7"	// U+e4f7
#define ICON_FA_HAND_HOLDING_HEART "\xef\x92\xbe"	// U+f4be
#define ICON_FA_HAND_HOLDING_MEDICAL "\xee\x81\x9c"	// U+e05c
#define ICON_FA_HAND_LIZARD "\xef\x89\x98"	// U+f258
#define ICON_FA_HAND_MIDDLE_FINGER "\xef\xa0\x86"	// U+f806
#define ICON_FA_HAND_PEACE "\xef\x89\x9b"	// U+f25b
#define ICON_FA_HAND_POINT_DOWN "\xef\x82\xa7"	// U+f0a7
#define ICON_FA_HAND_POINT_LEFT "\xef\x82\xa5"	// U+f0a5
#define ICON_FA_HAND_POINT_RIGHT "\xef\x82\xa4"	// U+f0a4
#define ICON_FA_HAND_POINT_UP "\xef\x82\xa6"	// U+f0a6
#define ICON_FA_HAND_POINTER "\xef\x89\x9a"	// U+f25a
#define ICON_FA_HAND_SCISSORS "\xef\x89\x97"	// U+f257
#define ICON_FA_HAND_SPARKLES "\xee\x81\x9d"	// U+e05d
#define ICON_FA_HAND_SPOCK "\xef\x89\x99"	// U+f259
#define ICON_FA_HANDCUFFS "\xee\x93\xb8"	// U+e4f8
#define ICON_FA_HANDS "\xef\x8a\xa7"	// U+f2a7
#define ICON_FA_HANDS_ASL_INTERPRETING "\xef\x8a\xa3"	// U+f2a3
#define ICON_FA_HANDS_BOUND "\xee\x93\xb9"	// U+e4f9
#define ICON_FA_HANDS_BUBBLES "\xee\x81\x9e"	// U+e05e
#define ICON_FA_HANDS_CLAPPING "\xee\x86\xa8"	// U+e1a8
#define ICON_FA_HANDS_HOLDING "\xef\x93\x82"	// U+f4c2
#define ICON_FA_HANDS_HOLDING_CHILD "\xee\x93\xba"	// U+e4fa
#define ICON_FA_HANDS_HOLDING_CIRCLE "\xee\x93\xbb"	// U+e4fb
#define ICON_FA_HANDS_PRAYING "\xef\x9a\x84"	// U+f684
#define ICON_FA_HANDSHAKE "\xef\x8a\xb5"	// U+f2b5
#define ICON_FA_HANDSHAKE_ANGLE "\xef\x93\x84"	// U+f4c4
#define ICON_FA_HANDSHAKE_SIMPLE "\xef\x93\x86"	// U+f4c6
#define ICON_FA_HANDSHAKE_SIMPLE_SLASH "\xee\x81\x9f"	// U+e05f
#define ICON_FA_HANDSHAKE_SLASH "\xee\x81\xa0"	// U+e060
#define ICON_FA_HANUKIAH "\xef\x9b\xa6"	// U+f6e6
#define ICON_FA_HARD_DRIVE "\xef\x82\xa0"	// U+f0a0
#define ICON_FA_HASHTAG "#"	// U+0023
#define ICON_FA_HAT_COWBOY "\xef\xa3\x80"	// U+f8c0
#define ICON_FA_HAT_COWBOY_SIDE "\xef\xa3\x81"	// U+f8c1
#define ICON_FA_HAT_WIZARD "\xef\x9b\xa8"	// U+f6e8
#define ICON_FA_HEAD_SIDE_COUGH "\xee\x81\xa1"	// U+e061
#define ICON_FA_HEAD_SIDE_COUGH_SLASH "\xee\x81\xa2"	// U+e062
#define ICON_FA_HEAD_SIDE_MASK "\xee\x81\xa3"	// U+e063
#define ICON_FA_HEAD_SIDE_VIRUS "\xee\x81\xa4"	// U+e064
#define ICON_FA_HEADING "\xef\x87\x9c"	// U+f1dc
#define ICON_FA_HEADPHONES "\xef\x80\xa5"	// U+f025
#define ICON_FA_HEADPHONES_SIMPLE "\xef\x96\x8f"	// U+f58f
#define ICON_FA_HEADSET "\xef\x96\x90"	// U+f590
#define ICON_FA_HEART "\xef\x80\x84"	// U+f004
#define ICON_FA_HEART_CIRCLE_BOLT "\xee\x93\xbc"	// U+e4fc
#define ICON_FA_HEART_CIRCLE_CHECK "\xee\x93\xbd"	// U+e4fd
#define ICON_FA_HEART_CIRCLE_EXCLAMATION "\xee\x93\xbe"	// U+e4fe
#define ICON_FA_HEART_CIRCLE_MINUS "\xee\x93\xbf"	// U+e4ff
#define ICON_FA_HEART_CIRCLE_PLUS "\xee\x94\x80"	// U+e500
#define ICON_FA_HEART_CIRCLE_XMARK "\xee\x94\x81"	// U+e501
#define ICON_FA_HEART_CRACK "\xef\x9e\xa9"	// U+f7a9
#define ICON_FA_HEART_PULSE "\xef\x88\x9e"	// U+f21e
#define ICON_FA_HELICOPTER "\xef\x94\xb3"	// U+f533
#define ICON_FA_HELICOPTER_SYMBOL "\xee\x94\x82"	// U+e502
#define ICON_FA_HELMET_SAFETY "\xef\xa0\x87"	// U+f807
#define ICON_FA_HELMET_UN "\xee\x94\x83"	// U+e503
#define ICON_FA_HIGHLIGHTER "\xef\x96\x91"	// U+f591
#define ICON_FA_HILL_AVALANCHE "\xee\x94\x87"	// U+e507
#define ICON_FA_HILL_ROCKSLIDE "\xee\x94\x88"	// U+e508
#define ICON_FA_HIPPO "\xef\x9b\xad"	// U+f6ed
#define ICON_FA_HOCKEY_PUCK "\xef\x91\x93"	// U+f453
#define ICON_FA_HOLLY_BERRY "\xef\x9e\xaa"	// U+f7aa
#define ICON_FA_HORSE "\xef\x9b\xb0"	// U+f6f0
#define ICON_FA_HORSE_HEAD "\xef\x9e\xab"	// U+f7ab
#define ICON_FA_HOSPITAL "\xef\x83\xb8"	// U+f0f8
#define ICON_FA_HOSPITAL_USER "\xef\xa0\x8d"	// U+f80d
#define ICON_FA_HOT_TUB_PERSON "\xef\x96\x93"	// U+f593
#define ICON_FA_HOTDOG "\xef\xa0\x8f"	// U+f80f
#define ICON_FA_HOTEL "\xef\x96\x94"	// U+f594
#define ICON_FA_HOURGLASS "\xef\x89\x94"	// U+f254
#define ICON_FA_HOURGLASS_END "\xef\x89\x93"	// U+f253
#define ICON_FA_HOURGLASS_HALF "\xef\x89\x92"	// U+f252
#define ICON_FA_HOURGLASS_START "\xef\x89\x91"	// U+f251
#define ICON_FA_HOUSE "\xef\x80\x95"	// U+f015
#define ICON_FA_HOUSE_CHIMNEY "\xee\x8e\xaf"	// U+e3af
#define ICON_FA_HOUSE_CHIMNEY_CRACK "\xef\x9b\xb1"	// U+f6f1
#define ICON_FA_HOUSE_CHIMNEY_MEDICAL "\xef\x9f\xb2"	// U+f7f2
#define ICON_FA_HOUSE_CHIMNEY_USER "\xee\x81\xa5"	// U+e065
#define ICON_FA_HOUSE_CHIMNEY_WINDOW "\xee\x80\x8d"	// U+e00d
#define ICON_FA_HOUSE_CIRCLE_CHECK "\xee\x94\x89"	// U+e509
#define ICON_FA_HOUSE_CIRCLE_EXCLAMATION "\xee\x94\x8a"	// U+e50a
#define ICON_FA_HOUSE_CIRCLE_XMARK "\xee\x94\x8b"	// U+e50b
#define ICON_FA_HOUSE_CRACK "\xee\x8e\xb1"	// U+e3b1
#define ICON_FA_HOUSE_FIRE "\xee\x94\x8c"	// U+e50c
#define ICON_FA_HOUSE_FLAG "\xee\x94\x8d"	// U+e50d
#define ICON_FA_HOUSE_FLOOD_WATER "\xee\x94\x8e"	// U+e50e
#define ICON_FA_HOUSE_FLOOD_WATER_CIRCLE_ARROW_RIGHT "\xee\x94\x8f"	// U+e50f
#define ICON_FA_HOUSE_LAPTOP "\xee\x81\xa6"	// U+e066
#define ICON_FA_HOUSE_LOCK "\xee\x94\x90"	// U+e510
#define ICON_FA_HOUSE_MEDICAL "\xee\x8e\xb2"	// U+e3b2
#define ICON_FA_HOUSE_MEDICAL_CIRCLE_CHECK "\xee\x94\x91"	// U+e511
#define ICON_FA_HOUSE_MEDICAL_CIRCLE_EXCLAMATION "\xee\x94\x92"	// U+e512
#define ICON_FA_HOUSE_MEDICAL_CIRCLE_XMARK "\xee\x94\x93"	// U+e513
#define ICON_FA_HOUSE_MEDICAL_FLAG "\xee\x94\x94"	// U+e514
#define ICON_FA_HOUSE_SIGNAL "\xee\x80\x92"	// U+e012
#define ICON_FA_HOUSE_TSUNAMI "\xee\x94\x95"	// U+e515
#define ICON_FA_HOUSE_USER "\xee\x86\xb0"	// U+e1b0
#define ICON_FA_HRYVNIA_SIGN "\xef\x9b\xb2"	// U+f6f2
#define ICON_FA_HURRICANE "\xef\x9d\x91"	// U+f751
#define ICON_FA_I "I"	// U+0049
#define ICON_FA_I_CURSOR "\xef\x89\x86"	// U+f246
#define ICON_FA_ICE_CREAM "\xef\xa0\x90"	// U+f810
#define ICON_FA_ICICLES "\xef\x9e\xad"	// U+f7ad
#define ICON_FA_ICONS "\xef\xa1\xad"	// U+f86d
#define ICON_FA_ID_BADGE "\xef\x8b\x81"	// U+f2c1
#define ICON_FA_ID_CARD "\xef\x8b\x82"	// U+f2c2
#define ICON_FA_ID_CARD_CLIP "\xef\x91\xbf"	// U+f47f
#define ICON_FA_IGLOO "\xef\x9e\xae"	// U+f7ae
#define ICON_FA_IMAGE "\xef\x80\xbe"	// U+f03e
#define ICON_FA_IMAGE_PORTRAIT "\xef\x8f\xa0"	// U+f3e0
#define ICON_FA_IMAGES "\xef\x8c\x82"	// U+f302
#define ICON_FA_INBOX "\xef\x80\x9c"	// U+f01c
#define ICON_FA_INDENT "\xef\x80\xbc"	// U+f03c
#define ICON_FA_INDIAN_RUPEE_SIGN "\xee\x86\xbc"	// U+e1bc
#define ICON_FA_INDUSTRY "\xef\x89\xb5"	// U+f275
#define ICON_FA_INFINITY "\xef\x94\xb4"	// U+f534
#define ICON_FA_INFO "\xef\x84\xa9"	// U+f129
#define ICON_FA_ITALIC "\xef\x80\xb3"	// U+f033
#define ICON_FA_J "J"	// U+004a
#define ICON_FA_JAR "\xee\x94\x96"	// U+e516
#define ICON_FA_JAR_WHEAT "\xee\x94\x97"	// U+e517
#define ICON_FA_JEDI "\xef\x99\xa9"	// U+f669
#define ICON_FA_JET_FIGHTER "\xef\x83\xbb"	// U+f0fb
#define ICON_FA_JET_FIGHTER_UP "\xee\x94\x98"	// U+e518
#define ICON_FA_JOINT "\xef\x96\x95"	// U+f595
#define ICON_FA_JUG_DETERGENT "\xee\x94\x99"	// U+e519
#define ICON_FA_K "K"	// U+004b
#define ICON_FA_KAABA "\xef\x99\xab"	// U+f66b
#define ICON_FA_KEY "\xef\x82\x84"	// U+f084
#define ICON_FA_KEYBOARD "\xef\x84\x9c"	// U+f11c
#define ICON_FA_KHANDA "\xef\x99\xad"	// U+f66d
#define ICON_FA_KIP_SIGN "\xee\x87\x84"	// U+e1c4
#define ICON_FA_KIT_MEDICAL "\xef\x91\xb9"	// U+f479
#define ICON_FA_KITCHEN_SET "\xee\x94\x9a"	// U+e51a
#define ICON_FA_KIWI_BIRD "\xef\x94\xb5"	// U+f535
#define ICON_FA_L "L"	// U+004c
#define ICON_FA_LAND_MINE_ON "\xee\x94\x9b"	// U+e51b
#define ICON_FA_LANDMARK "\xef\x99\xaf"	// U+f66f
#define ICON_FA_LANDMARK_DOME "\xef\x9d\x92"	// U+f752
#define ICON_FA_LANDMARK_FLAG "\xee\x94\x9c"	// U+e51c
#define ICON_FA_LANGUAGE "\xef\x86\xab"	// U+f1ab
#define ICON_FA_LAPTOP "\xef\x84\x89"	// U+f109
#define ICON_FA_LAPTOP_CODE "\xef\x97\xbc"	// U+f5fc
#define ICON_FA_LAPTOP_FILE "\xee\x94\x9d"	// U+e51d
#define ICON_FA_LAPTOP_MEDICAL "\xef\xa0\x92"	// U+f812
#define ICON_FA_LARI_SIGN "\xee\x87\x88"	// U+e1c8
#define ICON_FA_LAYER_GROUP "\xef\x97\xbd"	// U+f5fd
#define ICON_FA_LEAF "\xef\x81\xac"	// U+f06c
#define ICON_FA_LEFT_LONG "\xef\x8c\x8a"	// U+f30a
#define ICON_FA_LEFT_RIGHT "\xef\x8c\xb7"	// U+f337
#define ICON_FA_LEMON "\xef\x82\x94"	// U+f094
#define ICON_FA_LESS_THAN "<"	// U+003c
#define ICON_FA_LESS_THAN_EQUAL "\xef\x94\xb7"	// U+f537
#define ICON_FA_LIFE_RING "\xef\x87\x8d"	// U+f1cd
#define ICON_FA_LIGHTBULB "\xef\x83\xab"	// U+f0eb
#define ICON_FA_LINES_LEANING "\xee\x94\x9e"	// U+e51e
#define ICON_FA_LINK "\xef\x83\x81"	// U+f0c1
#define ICON_FA_LINK_SLASH "\xef\x84\xa7"	// U+f127
#define ICON_FA_LIRA_SIGN "\xef\x86\x95"	// U+f195
#define ICON_FA_LIST "\xef\x80\xba"	// U+f03a
#define ICON_FA_LIST_CHECK "\xef\x82\xae"	// U+f0ae
#define ICON_FA_LIST_OL "\xef\x83\x8b"	// U+f0cb
#define ICON_FA_LIST_UL "\xef\x83\x8a"	// U+f0ca
#define ICON_FA_LITECOIN_SIGN "\xee\x87\x93"	// U+e1d3
#define ICON_FA_LOCATION_ARROW "\xef\x84\xa4"	// U+f124
#define ICON_FA_LOCATION_CROSSHAIRS "\xef\x98\x81"	// U+f601
#define ICON_FA_LOCATION_DOT "\xef\x8f\x85"	// U+f3c5
#define ICON_FA_LOCATION_PIN "\xef\x81\x81"	// U+f041
#define ICON_FA_LOCATION_PIN_LOCK "\xee\x94\x9f"	// U+e51f
#define ICON_FA_LOCK "\xef\x80\xa3"	// U+f023
#define ICON_FA_LOCK_OPEN "\xef\x8f\x81"	// U+f3c1
#define ICON_FA_LOCUST "\xee\x94\xa0"	// U+e520
#define ICON_FA_LUNGS "\xef\x98\x84"	// U+f604
#define ICON_FA_LUNGS_VIRUS "\xee\x81\xa7"	// U+e067
#define ICON_FA_M "M"	// U+004d
#define ICON_FA_MAGNET "\xef\x81\xb6"	// U+f076
#define ICON_FA_MAGNIFYING_GLASS "\xef\x80\x82"	// U+f002
#define ICON_FA_MAGNIFYING_GLASS_ARROW_RIGHT "\xee\x94\xa1"	// U+e521
#define ICON_FA_MAGNIFYING_GLASS_CHART "\xee\x94\xa2"	// U+e522
#define ICON_FA_MAGNIFYING_GLASS_DOLLAR "\xef\x9a\x88"	// U+f688
#define ICON_FA_MAGNIFYING_GLASS_LOCATION "\xef\x9a\x89"	// U+f689
#define ICON_FA_MAGNIFYING_GLASS_MINUS "\xef\x80\x90"	// U+f010
#define ICON_FA_MAGNIFYING_GLASS_PLUS "\xef\x80\x8e"	// U+f00e
#define ICON_FA_MANAT_SIGN "\xee\x87\x95"	// U+e1d5
#define ICON_FA_MAP "\xef\x89\xb9"	// U+f279
#define ICON_FA_MAP_LOCATION "\xef\x96\x9f"	// U+f59f
#define ICON_FA_MAP_LOCATION_DOT "\xef\x96\xa0"	// U+f5a0
#define ICON_FA_MAP_PIN "\xef\x89\xb6"	// U+f276
#define ICON_FA_MARKER "\xef\x96\xa1"	// U+f5a1
#define ICON_FA_MARS "\xef\x88\xa2"	// U+f222
#define ICON_FA_MARS_AND_VENUS "\xef\x88\xa4"	// U+f224
#define ICON_FA_MARS_AND_VENUS_BURST "\xee\x94\xa3"	// U+e523
#define ICON_FA_MARS_DOUBLE "\xef\x88\xa7"	// U+f227
#define ICON_FA_MARS_STROKE "\xef\x88\xa9"	// U+f229
#define ICON_FA_MARS_STROKE_RIGHT "\xef\x88\xab"	// U+f22b
#define ICON_FA_MARS_STROKE_UP "\xef\x88\xaa"	// U+f22a
#define ICON_FA_MARTINI_GLASS "\xef\x95\xbb"	// U+f57b
#define ICON_FA_MARTINI_GLASS_CITRUS "\xef\x95\xa1"	// U+f561
#define ICON_FA_MARTINI_GLASS_EMPTY "\xef\x80\x80"	// U+f000
#define ICON_FA_MASK "\xef\x9b\xba"	// U+f6fa
#define ICON_FA_MASK_FACE "\xee\x87\x97"	// U+e1d7
#define ICON_FA_MASK_VENTILATOR "\xee\x94\xa4"	// U+e524
#define ICON_FA_MASKS_THEATER "\xef\x98\xb0"	// U+f630
#define ICON_FA_MATTRESS_PILLOW "\xee\x94\xa5"	// U+e525
#define ICON_FA_MAXIMIZE "\xef\x8c\x9e"	// U+f31e
#define ICON_FA_MEDAL "\xef\x96\xa2"	// U+f5a2
#define ICON_FA_MEMORY "\xef\x94\xb8"	// U+f538
#define ICON_FA_MENORAH "\xef\x99\xb6"	// U+f676
#define ICON_FA_MERCURY "\xef\x88\xa3"	// U+f223
#define ICON_FA_MESSAGE "\xef\x89\xba"	// U+f27a
#define ICON_FA_METEOR "\xef\x9d\x93"	// U+f753
#define ICON_FA_MICROCHIP "\xef\x8b\x9b"	// U+f2db
#define ICON_FA_MICROPHONE "\xef\x84\xb0"	// U+f130
#define ICON_FA_MICROPHONE_LINES "\xef\x8f\x89"	// U+f3c9
#define ICON_FA_MICROPHONE_LINES_SLASH "\xef\x94\xb9"	// U+f539
#define ICON_FA_MICROPHONE_SLASH "\xef\x84\xb1"	// U+f131
#define ICON_FA_MICROSCOPE "\xef\x98\x90"	// U+f610
#define ICON_FA_MILL_SIGN "\xee\x87\xad"	// U+e1ed
#define ICON_FA_MINIMIZE "\xef\x9e\x8c"	// U+f78c
#define ICON_FA_MINUS "\xef\x81\xa8"	// U+f068
#define ICON_FA_MITTEN "\xef\x9e\xb5"	// U+f7b5
#define ICON_FA_MOBILE "\xef\x8f\x8e"	// U+f3ce
#define ICON_FA_MOBILE_BUTTON "\xef\x84\x8b"	// U+f10b
#define ICON_FA_MOBILE_RETRO "\xee\x94\xa7"	// U+e527
#define ICON_FA_MOBILE_SCREEN "\xef\x8f\x8f"	// U+f3cf
#define ICON_FA_MOBILE_SCREEN_BUTTON "\xef\x8f\x8d"	// U+f3cd
#define ICON_FA_MONEY_BILL "\xef\x83\x96"	// U+f0d6
#define ICON_FA_MONEY_BILL_1 "\xef\x8f\x91"	// U+f3d1
#define ICON_FA_MONEY_BILL_1_WAVE "\xef\x94\xbb"	// U+f53b
#define ICON_FA_MONEY_BILL_TRANSFER "\xee\x94\xa8"	// U+e528
#define ICON_FA_MONEY_BILL_TREND_UP "\xee\x94\xa9"	// U+e529
#define ICON_FA_MONEY_BILL_WAVE "\xef\x94\xba"	// U+f53a
#define ICON_FA_MONEY_BILL_WHEAT "\xee\x94\xaa"	// U+e52a
#define ICON_FA_MONEY_BILLS "\xee\x87\xb3"	// U+e1f3
#define ICON_FA_MONEY_CHECK "\xef\x94\xbc"	// U+f53c
#define ICON_FA_MONEY_CHECK_DOLLAR "\xef\x94\xbd"	// U+f53d
#define ICON_FA_MONUMENT "\xef\x96\xa6"	// U+f5a6
#define ICON_FA_MOON "\xef\x86\x86"	// U+f186
#define ICON_FA_MORTAR_PESTLE "\xef\x96\xa7"	// U+f5a7
#define ICON_FA_MOSQUE "\xef\x99\xb8"	// U+f678
#define ICON_FA_MOSQUITO "\xee\x94\xab"	// U+e52b
#define ICON_FA_MOSQUITO_NET "\xee\x94\xac"	// U+e52c
#define ICON_FA_MOTORCYCLE "\xef\x88\x9c"	// U+f21c
#define ICON_FA_MOUND "\xee\x94\xad"	// U+e52d
#define ICON_FA_MOUNTAIN "\xef\x9b\xbc"	// U+f6fc
#define ICON_FA_MOUNTAIN_CITY "\xee\x94\xae"	// U+e52e
#define ICON_FA_MOUNTAIN_SUN "\xee\x94\xaf"	// U+e52f
#define ICON_FA_MUG_HOT "\xef\x9e\xb6"	// U+f7b6
#define ICON_FA_MUG_SAUCER "\xef\x83\xb4"	// U+f0f4
#define ICON_FA_MUSIC "\xef\x80\x81"	// U+f001
#define ICON_FA_N "N"	// U+004e
#define ICON_FA_NAIRA_SIGN "\xee\x87\xb6"	// U+e1f6
#define ICON_FA_NETWORK_WIRED "\xef\x9b\xbf"	// U+f6ff
#define ICON_FA_NEUTER "\xef\x88\xac"	// U+f22c
#define ICON_FA_NEWSPAPER "\xef\x87\xaa"	// U+f1ea
#define ICON_FA_NOT_EQUAL "\xef\x94\xbe"	// U+f53e
#define ICON_FA_NOTDEF "\xee\x87\xbe"	// U+e1fe
#define ICON_FA_NOTE_STICKY "\xef\x89\x89"	// U+f249
#define ICON_FA_NOTES_MEDICAL "\xef\x92\x81"	// U+f481
#define ICON_FA_O "O"	// U+004f
#define ICON_FA_OBJECT_GROUP "\xef\x89\x87"	// U+f247
#define ICON_FA_OBJECT_UNGROUP "\xef\x89\x88"	// U+f248
#define ICON_FA_OIL_CAN "\xef\x98\x93"	// U+f613
#define ICON_FA_OIL_WELL "\xee\x94\xb2"	// U+e532
#define ICON_FA_OM "\xef\x99\xb9"	// U+f679
#define ICON_FA_OTTER "\xef\x9c\x80"	// U+f700
#define ICON_FA_OUTDENT "\xef\x80\xbb"	// U+f03b
#define ICON_FA_P "P"	// U+0050
#define ICON_FA_PAGER "\xef\xa0\x95"	// U+f815
#define ICON_FA_PAINT_ROLLER "\xef\x96\xaa"	// U+f5aa
#define ICON_FA_PAINTBRUSH "\xef\x87\xbc"	// U+f1fc
#define ICON_FA_PALETTE "\xef\x94\xbf"	// U+f53f
#define ICON_FA_PALLET "\xef\x92\x82"	// U+f482
#define ICON_FA_PANORAMA "\xee\x88\x89"	// U+e209
#define ICON_FA_PAPER_PLANE "\xef\x87\x98"	// U+f1d8
#define ICON_FA_PAPERCLIP "\xef\x83\x86"	// U+f0c6
#define ICON_FA_PARACHUTE_BOX "\xef\x93\x8d"	// U+f4cd
#define ICON_FA_PARAGRAPH "\xef\x87\x9d"	// U+f1dd
#define ICON_FA_PASSPORT "\xef\x96\xab"	// U+f5ab
#define ICON_FA_PASTE "\xef\x83\xaa"	// U+f0ea
#define ICON_FA_PAUSE "\xef\x81\x8c"	// U+f04c
#define ICON_FA_PAW "\xef\x86\xb0"	// U+f1b0
#define ICON_FA_PEACE "\xef\x99\xbc"	// U+f67c
#define ICON_FA_PEN "\xef\x8c\x84"	// U+f304
#define ICON_FA_PEN_CLIP "\xef\x8c\x85"	// U+f305
#define ICON_FA_PEN_FANCY "\xef\x96\xac"	// U+f5ac
#define ICON_FA_PEN_NIB "\xef\x96\xad"	// U+f5ad
#define ICON_FA_PEN_RULER "\xef\x96\xae"	// U+f5ae
#define ICON_FA_PEN_TO_SQUARE "\xef\x81\x84"	// U+f044
#define ICON_FA_PENCIL "\xef\x8c\x83"	// U+f303
#define ICON_FA_PEOPLE_ARROWS "\xee\x81\xa8"	// U+e068
#define ICON_FA_PEOPLE_CARRY_BOX "\xef\x93\x8e"	// U+f4ce
#define ICON_FA_PEOPLE_GROUP "\xee\x94\xb3"	// U+e533
#define ICON_FA_PEOPLE_LINE "\xee\x94\xb4"	// U+e534
#define ICON_FA_PEOPLE_PULLING "\xee\x94\xb5"	// U+e535
#define ICON_FA_PEOPLE_ROBBERY "\xee\x94\xb6"	// U+e536
#define ICON_FA_PEOPLE_ROOF "\xee\x94\xb7"	// U+e537
#define ICON_FA_PEPPER_HOT "\xef\xa0\x96"	// U+f816
#define ICON_FA_PERCENT "%"	// U+0025
#define ICON_FA_PERSON "\xef\x86\x83"	// U+f183
#define ICON_FA_PERSON_ARROW_DOWN_TO_LINE "\xee\x94\xb8"	// U+e538
#define ICON_FA_PERSON_ARROW_UP_FROM_LINE "\xee\x94\xb9"	// U+e539
#define ICON_FA_PERSON_BIKING "\xef\xa1\x8a"	// U+f84a
#define ICON_FA_PERSON_BOOTH "\xef\x9d\x96"	// U+f756
#define ICON_FA_PERSON_BREASTFEEDING "\xee\x94\xba"	// U+e53a
#define ICON_FA_PERSON_BURST "\xee\x94\xbb"	// U+e53b
#define ICON_FA_PERSON_CANE "\xee\x94\xbc"	// U+e53c
#define ICON_FA_PERSON_CHALKBOARD "\xee\x94\xbd"	// U+e53d
#define ICON_FA_PERSON_CIRCLE_CHECK "\xee\x94\xbe"	// U+e53e
#define ICON_FA_PERSON_CIRCLE_EXCLAMATION "\xee\x94\xbf"	// U+e53f
#define ICON_FA_PERSON_CIRCLE_MINUS "\xee\x95\x80"	// U+e540
#define ICON_FA_PERSON_CIRCLE_PLUS "\xee\x95\x81"	// U+e541
#define ICON_FA_PERSON_CIRCLE_QUESTION "\xee\x95\x82"	// U+e542
#define ICON_FA_PERSON_CIRCLE_XMARK "\xee\x95\x83"	// U+e543
#define ICON_FA_PERSON_DIGGING "\xef\xa1\x9e"	// U+f85e
#define ICON_FA_PERSON_DOTS_FROM_LINE "\xef\x91\xb0"	// U+f470
#define ICON_FA_PERSON_DRESS "\xef\x86\x82"	// U+f182
#define ICON_FA_PERSON_DRESS_BURST "\xee\x95\x84"	// U+e544
#define ICON_FA_PERSON_DROWNING "\xee\x95\x85"	// U+e545
#define ICON_FA_PERSON_FALLING "\xee\x95\x86"	// U+e546
#define ICON_FA_PERSON_FALLING_BURST "\xee\x95\x87"	// U+e547
#define ICON_FA_PERSON_HALF_DRESS "\xee\x95\x88"	// U+e548
#define ICON_FA_PERSON_HARASSING "\xee\x95\x89"	// U+e549
#define ICON_FA_PERSON_HIKING "\xef\x9b\xac"	// U+f6ec
#define ICON_FA_PERSON_MILITARY_POINTING "\xee\x95\x8a"	// U+e54a
#define ICON_FA_PERSON_MILITARY_RIFLE "\xee\x95\x8b"	// U+e54b
#define ICON_FA_PERSON_MILITARY_TO_PERSON "\xee\x95\x8c"	// U+e54c
#define ICON_FA_PERSON_PRAYING "\xef\x9a\x83"	// U+f683
#define ICON_FA_PERSON_PREGNANT "\xee\x8c\x9e"	// U+e31e
#define ICON_FA_PERSON_RAYS "\xee\x95\x8d"	// U+e54d
#define ICON_FA_PERSON_RIFLE "\xee\x95\x8e"	// U+e54e
#define ICON_FA_PERSON_RUNNING "\xef\x9c\x8c"	// U+f70c
#define ICON_FA_PERSON_SHELTER "\xee\x95\x8f"	// U+e54f
#define ICON_FA_PERSON_SKATING "\xef\x9f\x85"	// U+f7c5
#define ICON_FA_PERSON_SKIING "\xef\x9f\x89"	// U+f7c9
#define ICON_FA_PERSON_SKIING_NORDIC "\xef\x9f\x8a"	// U+f7ca
#define ICON_FA_PERSON_SNOWBOARDING "\xef\x9f\x8e"	// U+f7ce
#define ICON_FA_PERSON_SWIMMING "\xef\x97\x84"	// U+f5c4
#define ICON_FA_PERSON_THROUGH_WINDOW "\xee\x96\xa9"	// U+e5a9
#define ICON_FA_PERSON_WALKING "\xef\x95\x94"	// U+f554
#define ICON_FA_PERSON_WALKING_ARROW_LOOP_LEFT "\xee\x95\x91"	// U+e551
#define ICON_FA_PERSON_WALKING_ARROW_RIGHT "\xee\x95\x92"	// U+e552
#define ICON_FA_PERSON_WALKING_DASHED_LINE_ARROW_RIGHT "\xee\x95\x93"	// U+e553
#define ICON_FA_PERSON_WALKING_LUGGAGE "\xee\x95\x94"	// U+e554
#define ICON_FA_PERSON_WALKING_WITH_CANE "\xef\x8a\x9d"	// U+f29d
#define ICON_FA_PESETA_SIGN "\xee\x88\xa1"	// U+e221
#define ICON_FA_PESO_SIGN "\xee\x88\xa2"	// U+e222
#define ICON_FA_PHONE "\xef\x82\x95"	// U+f095
#define ICON_FA_PHONE_FLIP "\xef\xa1\xb9"	// U+f879
#define ICON_FA_PHONE_SLASH "\xef\x8f\x9d"	// U+f3dd
#define ICON_FA_PHONE_VOLUME "\xef\x8a\xa0"	// U+f2a0
#define ICON_FA_PHOTO_FILM "\xef\xa1\xbc"	// U+f87c
#define ICON_FA_PIGGY_BANK "\xef\x93\x93"	// U+f4d3
#define ICON_FA_PILLS "\xef\x92\x84"	// U+f484
#define ICON_FA_PIZZA_SLICE "\xef\xa0\x98"	// U+f818
#define ICON_FA_PLACE_OF_WORSHIP "\xef\x99\xbf"	// U+f67f
#define ICON_FA_PLANE "\xef\x81\xb2"	// U+f072
#define ICON_FA_PLANE_ARRIVAL "\xef\x96\xaf"	// U+f5af
#define ICON_FA_PLANE_CIRCLE_CHECK "\xee\x95\x95"	// U+e555
#define ICON_FA_PLANE_CIRCLE_EXCLAMATION "\xee\x95\x96"	// U+e556
#define ICON_FA_PLANE_CIRCLE_XMARK "\xee\x95\x97"	// U+e557
#define ICON_FA_PLANE_DEPARTURE "\xef\x96\xb0"	// U+f5b0
#define ICON_FA_PLANE_LOCK "\xee\x95\x98"	// U+e558
#define ICON_FA_PLANE_SLASH "\xee\x81\xa9"	// U+e069
#define ICON_FA_PLANE_UP "\xee\x88\xad"	// U+e22d
#define ICON_FA_PLANT_WILT "\xee\x96\xaa"	// U+e5aa
#define ICON_FA_PLATE_WHEAT "\xee\x95\x9a"	// U+e55a
#define ICON_FA_PLAY "\xef\x81\x8b"	// U+f04b
#define ICON_FA_PLUG "\xef\x87\xa6"	// U+f1e6
#define ICON_FA_PLUG_CIRCLE_BOLT "\xee\x95\x9b"	// U+e55b
#define ICON_FA_PLUG_CIRCLE_CHECK "\xee\x95\x9c"	// U+e55c
#define ICON_FA_PLUG_CIRCLE_EXCLAMATION "\xee\x95\x9d"	// U+e55d
#define ICON_FA_PLUG_CIRCLE_MINUS "\xee\x95\x9e"	// U+e55e
#define ICON_FA_PLUG_CIRCLE_PLUS "\xee\x95\x9f"	// U+e55f
#define ICON_FA_PLUG_CIRCLE_XMARK "\xee\x95\xa0"	// U+e560
#define ICON_FA_PLUS "+"	// U+002b
#define ICON_FA_PLUS_MINUS "\xee\x90\xbc"	// U+e43c
#define ICON_FA_PODCAST "\xef\x8b\x8e"	// U+f2ce
#define ICON_FA_POO "\xef\x8b\xbe"	// U+f2fe
#define ICON_FA_POO_STORM "\xef\x9d\x9a"	// U+f75a
#define ICON_FA_POOP "\xef\x98\x99"	// U+f619
#define ICON_FA_POWER_OFF "\xef\x80\x91"	// U+f011
#define ICON_FA_PRESCRIPTION "\xef\x96\xb1"	// U+f5b1
#define ICON_FA_PRESCRIPTION_BOTTLE "\xef\x92\x85"	// U+f485
#define ICON_FA_PRESCRIPTION_BOTTLE_MEDICAL "\xef\x92\x86"	// U+f486
#define ICON_FA_PRINT "\xef\x80\xaf"	// U+f02f
#define ICON_FA_PUMP_MEDICAL "\xee\x81\xaa"	// U+e06a
#define ICON_FA_PUMP_SOAP "\xee\x81\xab"	// U+e06b
#define ICON_FA_PUZZLE_PIECE "\xef\x84\xae"	// U+f12e
#define ICON_FA_Q "Q"	// U+0051
#define ICON_FA_QRCODE "\xef\x80\xa9"	// U+f029
#define ICON_FA_QUESTION "?"	// U+003f
#define ICON_FA_QUOTE_LEFT "\xef\x84\x8d"	// U+f10d
#define ICON_FA_QUOTE_RIGHT "\xef\x84\x8e"	// U+f10e
#define ICON_FA_R "R"	// U+0052
#define ICON_FA_RADIATION "\xef\x9e\xb9"	// U+f7b9
#define ICON_FA_RADIO "\xef\xa3\x97"	// U+f8d7
#define ICON_FA_RAINBOW "\xef\x9d\x9b"	// U+f75b
#define ICON_FA_RANKING_STAR "\xee\x95\xa1"	// U+e561
#define ICON_FA_RECEIPT "\xef\x95\x83"	// U+f543
#define ICON_FA_RECORD_VINYL "\xef\xa3\x99"	// U+f8d9
#define ICON_FA_RECTANGLE_AD "\xef\x99\x81"	// U+f641
#define ICON_FA_RECTANGLE_LIST "\xef\x80\xa2"	// U+f022
#define ICON_FA_RECTANGLE_XMARK "\xef\x90\x90"	// U+f410
#define ICON_FA_RECYCLE "\xef\x86\xb8"	// U+f1b8
#define ICON_FA_REGISTERED "\xef\x89\x9d"	// U+f25d
#define ICON_FA_REPEAT "\xef\x8d\xa3"	// U+f363
#define ICON_FA_REPLY "\xef\x8f\xa5"	// U+f3e5
#define ICON_FA_REPLY_ALL "\xef\x84\xa2"	// U+f122
#define ICON_FA_REPUBLICAN "\xef\x9d\x9e"	// U+f75e
#define ICON_FA_RESTROOM "\xef\x9e\xbd"	// U+f7bd
#define ICON_FA_RETWEET "\xef\x81\xb9"	// U+f079
#define ICON_FA_RIBBON "\xef\x93\x96"	// U+f4d6
#define ICON_FA_RIGHT_FROM_BRACKET "\xef\x8b\xb5"	// U+f2f5
#define ICON_FA_RIGHT_LEFT "\xef\x8d\xa2"	// U+f362
#define ICON_FA_RIGHT_LONG "\xef\x8c\x8b"	// U+f30b
#define ICON_FA_RIGHT_TO_BRACKET "\xef\x8b\xb6"	// U+f2f6
#define ICON_FA_RING "\xef\x9c\x8b"	// U+f70b
#define ICON_FA_ROAD "\xef\x80\x98"	// U+f018
#define ICON_FA_ROAD_BARRIER "\xee\x95\xa2"	// U+e562
#define ICON_FA_ROAD_BRIDGE "\xee\x95\xa3"	// U+e563
#define ICON_FA_ROAD_CIRCLE_CHECK "\xee\x95\xa4"	// U+e564
#define ICON_FA_ROAD_CIRCLE_EXCLAMATION "\xee\x95\xa5"	// U+e565
#define ICON_FA_ROAD_CIRCLE_XMARK "\xee\x95\xa6"	// U+e566
#define ICON_FA_ROAD_LOCK "\xee\x95\xa7"	// U+e567
#define ICON_FA_ROAD_SPIKES "\xee\x95\xa8"	// U+e568
#define ICON_FA_ROBOT "\xef\x95\x84"	// U+f544
#define ICON_FA_ROCKET "\xef\x84\xb5"	// U+f135
#define ICON_FA_ROTATE "\xef\x8b\xb1"	// U+f2f1
#define ICON_FA_ROTATE_LEFT "\xef\x8b\xaa"	// U+f2ea
#define ICON_FA_ROTATE_RIGHT "\xef\x8b\xb9"	// U+f2f9
#define ICON_FA_ROUTE "\xef\x93\x97"	// U+f4d7
#define ICON_FA_RSS "\xef\x82\x9e"	// U+f09e
#define ICON_FA_RUBLE_SIGN "\xef\x85\x98"	// U+f158
#define ICON_FA_RUG "\xee\x95\xa9"	// U+e569
#define ICON_FA_RULER "\xef\x95\x85"	// U+f545
#define ICON_FA_RULER_COMBINED "\xef\x95\x86"	// U+f546
#define ICON_FA_RULER_HORIZONTAL "\xef\x95\x87"	// U+f547
#define ICON_FA_RULER_VERTICAL "\xef\x95\x88"	// U+f548
#define ICON_FA_RUPEE_SIGN "\xef\x85\x96"	// U+f156
#define ICON_FA_RUPIAH_SIGN "\xee\x88\xbd"	// U+e23d
#define ICON_FA_S "S"	// U+0053
#define ICON_FA_SACK_DOLLAR "\xef\xa0\x9d"	// U+f81d
#define ICON_FA_SACK_XMARK "\xee\x95\xaa"	// U+e56a
#define ICON_FA_SAILBOAT "\xee\x91\x85"	// U+e445
#define ICON_FA_SATELLITE "\xef\x9e\xbf"	// U+f7bf
#define ICON_FA_SATELLITE_DISH "\xef\x9f\x80"	// U+f7c0
#define ICON_FA_SCALE_BALANCED "\xef\x89\x8e"	// U+f24e
#define ICON_FA_SCALE_UNBALANCED "\xef\x94\x95"	// U+f515
#define ICON_FA_SCALE_UNBALANCED_FLIP "\xef\x94\x96"	// U+f516
#define ICON_FA_SCHOOL "\xef\x95\x89"	// U+f549
#define ICON_FA_SCHOOL_CIRCLE_CHECK "\xee\x95\xab"	// U+e56b
#define ICON_FA_SCHOOL_CIRCLE_EXCLAMATION "\xee\x95\xac"	// U+e56c
#define ICON_FA_SCHOOL_CIRCLE_XMARK "\xee\x95\xad"	// U+e56d
#define ICON_FA_SCHOOL_FLAG "\xee\x95\xae"	// U+e56e
#define ICON_FA_SCHOOL_LOCK "\xee\x95\xaf"	// U+e56f
#define ICON_FA_SCISSORS "\xef\x83\x84"	// U+f0c4
#define ICON_FA_SCREWDRIVER "\xef\x95\x8a"	// U+f54a
#define ICON_FA_SCREWDRIVER_WRENCH "\xef\x9f\x99"	// U+f7d9
#define ICON_FA_SCROLL "\xef\x9c\x8e"	// U+f70e
#define ICON_FA_SCROLL_TORAH "\xef\x9a\xa0"	// U+f6a0
#define ICON_FA_SD_CARD "\xef\x9f\x82"	// U+f7c2
#define ICON_FA_SECTION "\xee\x91\x87"	// U+e447
#define ICON_FA_SEEDLING "\xef\x93\x98"	// U+f4d8
#define ICON_FA_SERVER "\xef\x88\xb3"	// U+f233
#define ICON_FA_SHAPES "\xef\x98\x9f"	// U+f61f
#define ICON_FA_SHARE "\xef\x81\xa4"	// U+f064
#define ICON_FA_SHARE_FROM_SQUARE "\xef\x85\x8d"	// U+f14d
#define ICON_FA_SHARE_NODES "\xef\x87\xa0"	// U+f1e0
#define ICON_FA_SHEET_PLASTIC "\xee\x95\xb1"	// U+e571
#define ICON_FA_SHEKEL_SIGN "\xef\x88\x8b"	// U+f20b
#define ICON_FA_SHIELD "\xef\x84\xb2"	// U+f132
#define ICON_FA_SHIELD_CAT "\xee\x95\xb2"	// U+e572
#define ICON_FA_SHIELD_DOG "\xee\x95\xb3"	// U+e573
#define ICON_FA_SHIELD_HALVED "\xef\x8f\xad"	// U+f3ed
#define ICON_FA_SHIELD_HEART "\xee\x95\xb4"	// U+e574
#define ICON_FA_SHIELD_VIRUS "\xee\x81\xac"	// U+e06c
#define ICON_FA_SHIP "\xef\x88\x9a"	// U+f21a
#define ICON_FA_SHIRT "\xef\x95\x93"	// U+f553
#define ICON_FA_SHOE_PRINTS "\xef\x95\x8b"	// U+f54b
#define ICON_FA_SHOP "\xef\x95\x8f"	// U+f54f
#define ICON_FA_SHOP_LOCK "\xee\x92\xa5"	// U+e4a5
#define ICON_FA_SHOP_SLASH "\xee\x81\xb0"	// U+e070
#define ICON_FA_SHOWER "\xef\x8b\x8c"	// U+f2cc
#define ICON_FA_SHRIMP "\xee\x91\x88"	// U+e448
#define ICON_FA_SHUFFLE "\xef\x81\xb4"	// U+f074
#define ICON_FA_SHUTTLE_SPACE "\xef\x86\x97"	// U+f197
#define ICON_FA_SIGN_HANGING "\xef\x93\x99"	// U+f4d9
#define ICON_FA_SIGNAL "\xef\x80\x92"	// U+f012
#define ICON_FA_SIGNATURE "\xef\x96\xb7"	// U+f5b7
#define ICON_FA_SIGNS_POST "\xef\x89\xb7"	// U+f277
#define ICON_FA_SIM_CARD "\xef\x9f\x84"	// U+f7c4
#define ICON_FA_SINK "\xee\x81\xad"	// U+e06d
#define ICON_FA_SITEMAP "\xef\x83\xa8"	// U+f0e8
#define ICON_FA_SKULL "\xef\x95\x8c"	// U+f54c
#define ICON_FA_SKULL_CROSSBONES "\xef\x9c\x94"	// U+f714
#define ICON_FA_SLASH "\xef\x9c\x95"	// U+f715
#define ICON_FA_SLEIGH "\xef\x9f\x8c"	// U+f7cc
#define ICON_FA_SLIDERS "\xef\x87\x9e"	// U+f1de
#define ICON_FA_SMOG "\xef\x9d\x9f"	// U+f75f
#define ICON_FA_SMOKING "\xef\x92\x8d"	// U+f48d
#define ICON_FA_SNOWFLAKE "\xef\x8b\x9c"	// U+f2dc
#define ICON_FA_SNOWMAN "\xef\x9f\x90"	// U+f7d0
#define ICON_FA_SNOWPLOW "\xef\x9f\x92"	// U+f7d2
#define ICON_FA_SOAP "\xee\x81\xae"	// U+e06e
#define ICON_FA_SOCKS "\xef\x9a\x96"	// U+f696
#define ICON_FA_SOLAR_PANEL "\xef\x96\xba"	// U+f5ba
#define ICON_FA_SORT "\xef\x83\x9c"	// U+f0dc
#define ICON_FA_SORT_DOWN "\xef\x83\x9d"	// U+f0dd
#define ICON_FA_SORT_UP "\xef\x83\x9e"	// U+f0de
#define ICON_FA_SPA "\xef\x96\xbb"	// U+f5bb
#define ICON_FA_SPAGHETTI_MONSTER_FLYING "\xef\x99\xbb"	// U+f67b
#define ICON_FA_SPELL_CHECK "\xef\xa2\x91"	// U+f891
#define ICON_FA_SPIDER "\xef\x9c\x97"	// U+f717
#define ICON_FA_SPINNER "\xef\x84\x90"	// U+f110
#define ICON_FA_SPLOTCH "\xef\x96\xbc"	// U+f5bc
#define ICON_FA_SPOON "\xef\x8b\xa5"	// U+f2e5
#define ICON_FA_SPRAY_CAN "\xef\x96\xbd"	// U+f5bd
#define ICON_FA_SPRAY_CAN_SPARKLES "\xef\x97\x90"	// U+f5d0
#define ICON_FA_SQUARE "\xef\x83\x88"	// U+f0c8
#define ICON_FA_SQUARE_ARROW_UP_RIGHT "\xef\x85\x8c"	// U+f14c
#define ICON_FA_SQUARE_CARET_DOWN "\xef\x85\x90"	// U+f150
#define ICON_FA_SQUARE_CARET_LEFT "\xef\x86\x91"	// U+f191
#define ICON_FA_SQUARE_CARET_RIGHT "\xef\x85\x92"	// U+f152
#define ICON_FA_SQUARE_CARET_UP "\xef\x85\x91"	// U+f151
#define ICON_FA_SQUARE_CHECK "\xef\x85\x8a"	// U+f14a
#define ICON_FA_SQUARE_ENVELOPE "\xef\x86\x99"	// U+f199
#define ICON_FA_SQUARE_FULL "\xef\x91\x9c"	// U+f45c
#define ICON_FA_SQUARE_H "\xef\x83\xbd"	// U+f0fd
#define ICON_FA_SQUARE_MINUS "\xef\x85\x86"	// U+f146
#define ICON_FA_SQUARE_NFI "\xee\x95\xb6"	// U+e576
#define ICON_FA_SQUARE_PARKING "\xef\x95\x80"	// U+f540
#define ICON_FA_SQUARE_PEN "\xef\x85\x8b"	// U+f14b
#define ICON_FA_SQUARE_PERSON_CONFINED "\xee\x95\xb7"	// U+e577
#define ICON_FA_SQUARE_PHONE "\xef\x82\x98"	// U+f098
#define ICON_FA_SQUARE_PHONE_FLIP "\xef\xa1\xbb"	// U+f87b
#define ICON_FA_SQUARE_PLUS "\xef\x83\xbe"	// U+f0fe
#define ICON_FA_SQUARE_POLL_HORIZONTAL "\xef\x9a\x82"	// U+f682
#define ICON_FA_SQUARE_POLL_VERTICAL "\xef\x9a\x81"	// U+f681
#define ICON_FA_SQUARE_ROOT_VARIABLE "\xef\x9a\x98"	// U+f698
#define ICON_FA_SQUARE_RSS "\xef\x85\x83"	// U+f143
#define ICON_FA_SQUARE_SHARE_NODES "\xef\x87\xa1"	// U+f1e1
#define ICON_FA_SQUARE_UP_RIGHT "\xef\x8d\xa0"	// U+f360
#define ICON_FA_SQUARE_VIRUS "\xee\x95\xb8"	// U+e578
#define ICON_FA_SQUARE_XMARK "\xef\x8b\x93"	// U+f2d3
#define ICON_FA_STAFF_SNAKE "\xee\x95\xb9"	// U+e579
#define ICON_FA_STAIRS "\xee\x8a\x89"	// U+e289
#define ICON_FA_STAMP "\xef\x96\xbf"	// U+f5bf
#define ICON_FA_STAPLER "\xee\x96\xaf"	// U+e5af
#define ICON_FA_STAR "\xef\x80\x85"	// U+f005
#define ICON_FA_STAR_AND_CRESCENT "\xef\x9a\x99"	// U+f699
#define ICON_FA_STAR_HALF "\xef\x82\x89"	// U+f089
#define ICON_FA_STAR_HALF_STROKE "\xef\x97\x80"	// U+f5c0
#define ICON_FA_STAR_OF_DAVID "\xef\x9a\x9a"	// U+f69a
#define ICON_FA_STAR_OF_LIFE "\xef\x98\xa1"	// U+f621
#define ICON_FA_STERLING_SIGN "\xef\x85\x94"	// U+f154
#define ICON_FA_STETHOSCOPE "\xef\x83\xb1"	// U+f0f1
#define ICON_FA_STOP "\xef\x81\x8d"	// U+f04d
#define ICON_FA_STOPWATCH "\xef\x8b\xb2"	// U+f2f2
#define ICON_FA_STOPWATCH_20 "\xee\x81\xaf"	// U+e06f
#define ICON_FA_STORE "\xef\x95\x8e"	// U+f54e
#define ICON_FA_STORE_SLASH "\xee\x81\xb1"	// U+e071
#define ICON_FA_STREET_VIEW "\xef\x88\x9d"	// U+f21d
#define ICON_FA_STRIKETHROUGH "\xef\x83\x8c"	// U+f0cc
#define ICON_FA_STROOPWAFEL "\xef\x95\x91"	// U+f551
#define ICON_FA_SUBSCRIPT "\xef\x84\xac"	// U+f12c
#define ICON_FA_SUITCASE "\xef\x83\xb2"	// U+f0f2
#define ICON_FA_SUITCASE_MEDICAL "\xef\x83\xba"	// U+f0fa
#define ICON_FA_SUITCASE_ROLLING "\xef\x97\x81"	// U+f5c1
#define ICON_FA_SUN "\xef\x86\x85"	// U+f185
#define ICON_FA_SUN_PLANT_WILT "\xee\x95\xba"	// U+e57a
#define ICON_FA_SUPERSCRIPT "\xef\x84\xab"	// U+f12b
#define ICON_FA_SWATCHBOOK "\xef\x97\x83"	// U+f5c3
#define ICON_FA_SYNAGOGUE "\xef\x9a\x9b"	// U+f69b
#define ICON_FA_SYRINGE "\xef\x92\x8e"	// U+f48e
#define ICON_FA_T "T"	// U+0054
#define ICON_FA_TABLE "\xef\x83\x8e"	// U+f0ce
#define ICON_FA_TABLE_CELLS "\xef\x80\x8a"	// U+f00a
#define ICON_FA_TABLE_CELLS_LARGE "\xef\x80\x89"	// U+f009
#define ICON_FA_TABLE_COLUMNS "\xef\x83\x9b"	// U+f0db
#define ICON_FA_TABLE_LIST "\xef\x80\x8b"	// U+f00b
#define ICON_FA_TABLE_TENNIS_PADDLE_BALL "\xef\x91\x9d"	// U+f45d
#define ICON_FA_TABLET "\xef\x8f\xbb"	// U+f3fb
#define ICON_FA_TABLET_BUTTON "\xef\x84\x8a"	// U+f10a
#define ICON_FA_TABLET_SCREEN_BUTTON "\xef\x8f\xba"	// U+f3fa
#define ICON_FA_TABLETS "\xef\x92\x90"	// U+f490
#define ICON_FA_TACHOGRAPH_DIGITAL "\xef\x95\xa6"	// U+f566
#define ICON_FA_TAG "\xef\x80\xab"	// U+f02b
#define ICON_FA_TAGS "\xef\x80\xac"	// U+f02c
#define ICON_FA_TAPE "\xef\x93\x9b"	// U+f4db
#define ICON_FA_TARP "\xee\x95\xbb"	// U+e57b
#define ICON_FA_TARP_DROPLET "\xee\x95\xbc"	// U+e57c
#define ICON_FA_TAXI "\xef\x86\xba"	// U+f1ba
#define ICON_FA_TEETH "\xef\x98\xae"	// U+f62e
#define ICON_FA_TEETH_OPEN "\xef\x98\xaf"	// U+f62f
#define ICON_FA_TEMPERATURE_ARROW_DOWN "\xee\x80\xbf"	// U+e03f
#define ICON_FA_TEMPERATURE_ARROW_UP "\xee\x81\x80"	// U+e040
#define ICON_FA_TEMPERATURE_EMPTY "\xef\x8b\x8b"	// U+f2cb
#define ICON_FA_TEMPERATURE_FULL "\xef\x8b\x87"	// U+f2c7
#define ICON_FA_TEMPERATURE_HALF "\xef\x8b\x89"	// U+f2c9
#define ICON_FA_TEMPERATURE_HIGH "\xef\x9d\xa9"	// U+f769
#define ICON_FA_TEMPERATURE_LOW "\xef\x9d\xab"	// U+f76b
#define ICON_FA_TEMPERATURE_QUARTER "\xef\x8b\x8a"	// U+f2ca
#define ICON_FA_TEMPERATURE_THREE_QUARTERS "\xef\x8b\x88"	// U+f2c8
#define ICON_FA_TENGE_SIGN "\xef\x9f\x97"	// U+f7d7
#define ICON_FA_TENT "\xee\x95\xbd"	// U+e57d
#define ICON_FA_TENT_ARROW_DOWN_TO_LINE "\xee\x95\xbe"	// U+e57e
#define ICON_FA_TENT_ARROW_LEFT_RIGHT "\xee\x95\xbf"	// U+e57f
#define ICON_FA_TENT_ARROW_TURN_LEFT "\xee\x96\x80"	// U+e580
#define ICON_FA_TENT_ARROWS_DOWN "\xee\x96\x81"	// U+e581
#define ICON_FA_TENTS "\xee\x96\x82"	// U+e582
#define ICON_FA_TERMINAL "\xef\x84\xa0"	// U+f120
#define ICON_FA_TEXT_HEIGHT "\xef\x80\xb4"	// U+f034
#define ICON_FA_TEXT_SLASH "\xef\xa1\xbd"	// U+f87d
#define ICON_FA_TEXT_WIDTH "\xef\x80\xb5"	// U+f035
#define ICON_FA_THERMOMETER "\xef\x92\x91"	// U+f491
#define ICON_FA_THUMBS_DOWN "\xef\x85\xa5"	// U+f165
#define ICON_FA_THUMBS_UP "\xef\x85\xa4"	// U+f164
#define ICON_FA_THUMBTACK "\xef\x82\x8d"	// U+f08d
#define ICON_FA_TICKET "\xef\x85\x85"	// U+f145
#define ICON_FA_TICKET_SIMPLE "\xef\x8f\xbf"	// U+f3ff
#define ICON_FA_TIMELINE "\xee\x8a\x9c"	// U+e29c
#define ICON_FA_TOGGLE_OFF "\xef\x88\x84"	// U+f204
#define ICON_FA_TOGGLE_ON "\xef\x88\x85"	// U+f205
#define ICON_FA_TOILET "\xef\x9f\x98"	// U+f7d8
#define ICON_FA_TOILET_PAPER "\xef\x9c\x9e"	// U+f71e
#define ICON_FA_TOILET_PAPER_SLASH "\xee\x81\xb2"	// U+e072
#define ICON_FA_TOILET_PORTABLE "\xee\x96\x83"	// U+e583
#define ICON_FA_TOILETS_PORTABLE "\xee\x96\x84"	// U+e584
#define ICON_FA_TOOLBOX "\xef\x95\x92"	// U+f552
#define ICON_FA_TOOTH "\xef\x97\x89"	// U+f5c9
#define ICON_FA_TORII_GATE "\xef\x9a\xa1"	// U+f6a1
#define ICON_FA_TORNADO "\xef\x9d\xaf"	// U+f76f
#define ICON_FA_TOWER_BROADCAST "\xef\x94\x99"	// U+f519
#define ICON_FA_TOWER_CELL "\xee\x96\x85"	// U+e585
#define ICON_FA_TOWER_OBSERVATION "\xee\x96\x86"	// U+e586
#define ICON_FA_TRACTOR "\xef\x9c\xa2"	// U+f722
#define ICON_FA_TRADEMARK "\xef\x89\x9c"	// U+f25c
#define ICON_FA_TRAFFIC_LIGHT "\xef\x98\xb7"	// U+f637
#define ICON_FA_TRAILER "\xee\x81\x81"	// U+e041
#define ICON_FA_TRAIN "\xef\x88\xb8"	// U+f238
#define ICON_FA_TRAIN_SUBWAY "\xef\x88\xb9"	// U+f239
#define ICON_FA_TRAIN_TRAM "\xee\x96\xb4"	// U+e5b4
#define ICON_FA_TRANSGENDER "\xef\x88\xa5"	// U+f225
#define ICON_FA_TRASH "\xef\x87\xb8"	// U+f1f8
#define ICON_FA_TRASH_ARROW_UP "\xef\xa0\xa9"	// U+f829
#define ICON_FA_TRASH_CAN "\xef\x8b\xad"	// U+f2ed
#define ICON_FA_TRASH_CAN_ARROW_UP "\xef\xa0\xaa"	// U+f82a
#define ICON_FA_TREE "\xef\x86\xbb"	// U+f1bb
#define ICON_FA_TREE_CITY "\xee\x96\x87"	// U+e587
#define ICON_FA_TRIANGLE_EXCLAMATION "\xef\x81\xb1"	// U+f071
#define ICON_FA_TROPHY "\xef\x82\x91"	// U+f091
#define ICON_FA_TROWEL "\xee\x96\x89"	// U+e589
#define ICON_FA_TROWEL_BRICKS "\xee\x96\x8a"	// U+e58a
#define ICON_FA_TRUCK "\xef\x83\x91"	// U+f0d1
#define ICON_FA_TRUCK_ARROW_RIGHT "\xee\x96\x8b"	// U+e58b
#define ICON_FA_TRUCK_DROPLET "\xee\x96\x8c"	// U+e58c
#define ICON_FA_TRUCK_FAST "\xef\x92\x8b"	// U+f48b
#define ICON_FA_TRUCK_FIELD "\xee\x96\x8d"	// U+e58d
#define ICON_FA_TRUCK_FIELD_UN "\xee\x96\x8e"	// U+e58e
#define ICON_FA_TRUCK_FRONT "\xee\x8a\xb7"	// U+e2b7
#define ICON_FA_TRUCK_MEDICAL "\xef\x83\xb9"	// U+f0f9
#define ICON_FA_TRUCK_MONSTER "\xef\x98\xbb"	// U+f63b
#define ICON_FA_TRUCK_MOVING "\xef\x93\x9f"	// U+f4df
#define ICON_FA_TRUCK_PICKUP "\xef\x98\xbc"	// U+f63c
#define ICON_FA_TRUCK_PLANE "\xee\x96\x8f"	// U+e58f
#define ICON_FA_TRUCK_RAMP_BOX "\xef\x93\x9e"	// U+f4de
#define ICON_FA_TTY "\xef\x87\xa4"	// U+f1e4
#define ICON_FA_TURKISH_LIRA_SIGN "\xee\x8a\xbb"	// U+e2bb
#define ICON_FA_TURN_DOWN "\xef\x8e\xbe"	// U+f3be
#define ICON_FA_TURN_UP "\xef\x8e\xbf"	// U+f3bf
#define ICON_FA_TV "\xef\x89\xac"	// U+f26c
#define ICON_FA_U "U"	// U+0055
#define ICON_FA_UMBRELLA "\xef\x83\xa9"	// U+f0e9
#define ICON_FA_UMBRELLA_BEACH "\xef\x97\x8a"	// U+f5ca
#define ICON_FA_UNDERLINE "\xef\x83\x8d"	// U+f0cd
#define ICON_FA_UNIVERSAL_ACCESS "\xef\x8a\x9a"	// U+f29a
#define ICON_FA_UNLOCK "\xef\x82\x9c"	// U+f09c
#define ICON_FA_UNLOCK_KEYHOLE "\xef\x84\xbe"	// U+f13e
#define ICON_FA_UP_DOWN "\xef\x8c\xb8"	// U+f338
#define ICON_FA_UP_DOWN_LEFT_RIGHT "\xef\x82\xb2"	// U+f0b2
#define ICON_FA_UP_LONG "\xef\x8c\x8c"	// U+f30c
#define ICON_FA_UP_RIGHT_AND_DOWN_LEFT_FROM_CENTER "\xef\x90\xa4"	// U+f424
#define ICON_FA_UP_RIGHT_FROM_SQUARE "\xef\x8d\x9d"	// U+f35d
#define ICON_FA_UPLOAD "\xef\x82\x93"	// U+f093
#define ICON_FA_USER "\xef\x80\x87"	// U+f007
#define ICON_FA_USER_ASTRONAUT "\xef\x93\xbb"	// U+f4fb
#define ICON_FA_USER_CHECK "\xef\x93\xbc"	// U+f4fc
#define ICON_FA_USER_CLOCK "\xef\x93\xbd"	// U+f4fd
#define ICON_FA_USER_DOCTOR "\xef\x83\xb0"	// U+f0f0
#define ICON_FA_USER_GEAR "\xef\x93\xbe"	// U+f4fe
#define ICON_FA_USER_GRADUATE "\xef\x94\x81"	// U+f501
#define ICON_FA_USER_GROUP "\xef\x94\x80"	// U+f500
#define ICON_FA_USER_INJURED "\xef\x9c\xa8"	// U+f728
#define ICON_FA_USER_LARGE "\xef\x90\x86"	// U+f406
#define ICON_FA_USER_LARGE_SLASH "\xef\x93\xba"	// U+f4fa
#define ICON_FA_USER_LOCK "\xef\x94\x82"	// U+f502
#define ICON_FA_USER_MINUS "\xef\x94\x83"	// U+f503
#define ICON_FA_USER_NINJA "\xef\x94\x84"	// U+f504
#define ICON_FA_USER_NURSE "\xef\xa0\xaf"	// U+f82f
#define ICON_FA_USER_PEN "\xef\x93\xbf"	// U+f4ff
#define ICON_FA_USER_PLUS "\xef\x88\xb4"	// U+f234
#define ICON_FA_USER_SECRET "\xef\x88\x9b"	// U+f21b
#define ICON_FA_USER_SHIELD "\xef\x94\x85"	// U+f505
#define ICON_FA_USER_SLASH "\xef\x94\x86"	// U+f506
#define ICON_FA_USER_TAG "\xef\x94\x87"	// U+f507
#define ICON_FA_USER_TIE "\xef\x94\x88"	// U+f508
#define ICON_FA_USER_XMARK "\xef\x88\xb5"	// U+f235
#define ICON_FA_USERS "\xef\x83\x80"	// U+f0c0
#define ICON_FA_USERS_BETWEEN_LINES "\xee\x96\x91"	// U+e591
#define ICON_FA_USERS_GEAR "\xef\x94\x89"	// U+f509
#define ICON_FA_USERS_LINE "\xee\x96\x92"	// U+e592
#define ICON_FA_USERS_RAYS "\xee\x96\x93"	// U+e593
#define ICON_FA_USERS_RECTANGLE "\xee\x96\x94"	// U+e594
#define ICON_FA_USERS_SLASH "\xee\x81\xb3"	// U+e073
#define ICON_FA_USERS_VIEWFINDER "\xee\x96\x95"	// U+e595
#define ICON_FA_UTENSILS "\xef\x8b\xa7"	// U+f2e7
#define ICON_FA_V "V"	// U+0056
#define ICON_FA_VAN_SHUTTLE "\xef\x96\xb6"	// U+f5b6
#define ICON_FA_VAULT "\xee\x8b\x85"	// U+e2c5
#define ICON_FA_VECTOR_SQUARE "\xef\x97\x8b"	// U+f5cb
#define ICON_FA_VENUS "\xef\x88\xa1"	// U+f221
#define ICON_FA_VENUS_DOUBLE "\xef\x88\xa6"	// U+f226
#define ICON_FA_VENUS_MARS "\xef\x88\xa8"	// U+f228
#define ICON_FA_VEST "\xee\x82\x85"	// U+e085
#define ICON_FA_VEST_PATCHES "\xee\x82\x86"	// U+e086
#define ICON_FA_VIAL "\xef\x92\x92"	// U+f492
#define ICON_FA_VIAL_CIRCLE_CHECK "\xee\x96\x96"	// U+e596
#define ICON_FA_VIAL_VIRUS "\xee\x96\x97"	// U+e597
#define ICON_FA_VIALS "\xef\x92\x93"	// U+f493
#define ICON_FA_VIDEO "\xef\x80\xbd"	// U+f03d
#define ICON_FA_VIDEO_SLASH "\xef\x93\xa2"	// U+f4e2
#define ICON_FA_VIHARA "\xef\x9a\xa7"	// U+f6a7
#define ICON_FA_VIRUS "\xee\x81\xb4"	// U+e074
#define ICON_FA_VIRUS_COVID "\xee\x92\xa8"	// U+e4a8
#define ICON_FA_VIRUS_COVID_SLASH "\xee\x92\xa9"	// U+e4a9
#define ICON_FA_VIRUS_SLASH "\xee\x81\xb5"	// U+e075
#define ICON_FA_VIRUSES "\xee\x81\xb6"	// U+e076
#define ICON_FA_VOICEMAIL "\xef\xa2\x97"	// U+f897
#define ICON_FA_VOLCANO "\xef\x9d\xb0"	// U+f770
#define ICON_FA_VOLLEYBALL "\xef\x91\x9f"	// U+f45f
#define ICON_FA_VOLUME_HIGH "\xef\x80\xa8"	// U+f028
#define ICON_FA_VOLUME_LOW "\xef\x80\xa7"	// U+f027
#define ICON_FA_VOLUME_OFF "\xef\x80\xa6"	// U+f026
#define ICON_FA_VOLUME_XMARK "\xef\x9a\xa9"	// U+f6a9
#define ICON_FA_VR_CARDBOARD "\xef\x9c\xa9"	// U+f729
#define ICON_FA_W "W"	// U+0057
#define ICON_FA_WALKIE_TALKIE "\xef\xa3\xaf"	// U+f8ef
#define ICON_FA_WALLET "\xef\x95\x95"	// U+f555
#define ICON_FA_WAND_MAGIC "\xef\x83\x90"	// U+f0d0
#define ICON_FA_WAND_MAGIC_SPARKLES "\xee\x8b\x8a"	// U+e2ca
#define ICON_FA_WAND_SPARKLES "\xef\x9c\xab"	// U+f72b
#define ICON_FA_WAREHOUSE "\xef\x92\x94"	// U+f494
#define ICON_FA_WATER "\xef\x9d\xb3"	// U+f773
#define ICON_FA_WATER_LADDER "\xef\x97\x85"	// U+f5c5
#define ICON_FA_WAVE_SQUARE "\xef\xa0\xbe"	// U+f83e
#define ICON_FA_WEIGHT_HANGING "\xef\x97\x8d"	// U+f5cd
#define ICON_FA_WEIGHT_SCALE "\xef\x92\x96"	// U+f496
#define ICON_FA_WHEAT_AWN "\xee\x8b\x8d"	// U+e2cd
#define ICON_FA_WHEAT_AWN_CIRCLE_EXCLAMATION "\xee\x96\x98"	// U+e598
#define ICON_FA_WHEELCHAIR "\xef\x86\x93"	// U+f193
#define ICON_FA_WHEELCHAIR_MOVE "\xee\x8b\x8e"	// U+e2ce
#define ICON_FA_WHISKEY_GLASS "\xef\x9e\xa0"	// U+f7a0
#define ICON_FA_WIFI "\xef\x87\xab"	// U+f1eb
#define ICON_FA_WIND "\xef\x9c\xae"	// U+f72e
#define ICON_FA_WINDOW_MAXIMIZE "\xef\x8b\x90"	// U+f2d0
#define ICON_FA_WINDOW_MINIMIZE "\xef\x8b\x91"	// U+f2d1
#define ICON_FA_WINDOW_RESTORE "\xef\x8b\x92"	// U+f2d2
#define ICON_FA_WINE_BOTTLE "\xef\x9c\xaf"	// U+f72f
#define ICON_FA_WINE_GLASS "\xef\x93\xa3"	// U+f4e3
#define ICON_FA_WINE_GLASS_EMPTY "\xef\x97\x8e"	// U+f5ce
#define ICON_FA_WON_SIGN "\xef\x85\x99"	// U+f159
#define ICON_FA_WORM "\xee\x96\x99"	// U+e599
#define ICON_FA_WRENCH "\xef\x82\xad"	// U+f0ad
#define ICON_FA_X "X"	// U+0058
#define ICON_FA_X_RAY "\xef\x92\x97"	// U+f497
#define ICON_FA_XMARK "\xef\x80\x8d"	// U+f00d
#define ICON_FA_XMARKS_LINES "\xee\x96\x9a"	// U+e59a
#define ICON_FA_Y "Y"	// U+0059
#define ICON_FA_YEN_SIGN "\xef\x85\x97"	// U+f157
#define ICON_FA_YIN_YANG "\xef\x9a\xad"	// U+f6ad
#define ICON_FA_Z "Z"	// U+005a

```

`GUI/Headers/Addons/imgui_hexeditor.h`:

```h
// Mini memory editor for Dear ImGui (to embed in your game/tools)
// Get latest version at http://www.github.com/ocornut/imgui_club
//
// Right-click anywhere to access the Options menu!
// You can adjust the keyboard repeat delay/rate in ImGuiIO.
// The code assume a mono-space font for simplicity!
// If you don't use the default font, use ImGui::PushFont()/PopFont() to switch to a mono-space font before calling
// this.
//
// Usage:
//   // Create a window and draw memory editor inside it:
//   static MemoryEditor mem_edit_1;
//   static char data[0x10000];
//   size_t data_size = 0x10000;
//   mem_edit_1.DrawWindow("Memory Editor", data, data_size);
//
// Usage:
//   // If you already have a window, use DrawContents() instead:
//   static MemoryEditor mem_edit_2;
//   ImGui::Begin("MyWindow")
//   mem_edit_2.DrawContents(this, sizeof(*this), (size_t)this);
//   ImGui::End();
//
// Changelog:
// - v0.10: initial version
// - v0.23 (2017/08/17): added to github. fixed right-arrow triggering a byte write.
// - v0.24 (2018/06/02): changed DragInt("Rows" to use a %d data format (which is desirable since imgui 1.61).
// - v0.25 (2018/07/11): fixed wording: all occurrences of "Rows" renamed to "Columns".
// - v0.26 (2018/08/02): fixed clicking on hex region
// - v0.30 (2018/08/02): added data preview for common data types
// - v0.31 (2018/10/10): added OptUpperCaseHex option to select lower/upper casing display [@samhocevar]
// - v0.32 (2018/10/10): changed signatures to use void* instead of unsigned char*
// - v0.33 (2018/10/10): added OptShowOptions option to hide all the interactive option setting.
// - v0.34 (2019/05/07): binary preview now applies endianness setting [@nicolasnoble]
// - v0.35 (2020/01/29): using ImGuiDataType available since Dear ImGui 1.69.
// - v0.36 (2020/05/05): minor tweaks, minor refactor.
// - v0.40 (2020/10/04): fix misuse of ImGuiListClipper API, broke with Dear ImGui 1.79. made cursor position appears on
// left-side of edit box. option popup appears on mouse release. fix MSVC warnings where _CRT_SECURE_NO_WARNINGS wasn't
// working in recent versions.
// - v0.41 (2020/10/05): fix when using with keyboard/gamepad navigation enabled.
// - v0.42 (2020/10/14): fix for . character in ASCII view always being greyed out.
// - v0.43 (2021/03/12): added OptFooterExtraHeight to allow for custom drawing at the bottom of the editor [@leiradel]
// - v0.44 (2021/03/12): use ImGuiInputTextFlags_AlwaysOverwrite in 1.82 + fix hardcoded width.
// - v0.50 (2021/11/12): various fixes for recent dear imgui versions (fixed misuse of clipper, relying on
// SetKeyboardFocusHere() handling scrolling from 1.85). added default size.
//
// Todo/Bugs:
// - This is generally old/crappy code, it should work but isn't very good.. to be rewritten some day.
// - PageUp/PageDown are supported because we use _NoNav. This is a good test scenario for working out idioms of how to
// mix natural nav and our own...
// - Arrows are being sent to the InputText() about to disappear which for LeftArrow makes the text cursor appear at
// position 1 for one frame.
// - Using InputText() is awkward and maybe overkill here, consider implementing something custom.

#pragma once

#include <stdint.h> // uint8_t, etc.
#include <stdio.h>  // sprintf, scanf

#include "imgui.h"

#ifdef _MSC_VER
#define _PRISizeT "I"
#define ImSnprintf _snprintf
#else
#define _PRISizeT "z"
#define ImSnprintf snprintf
#endif

#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable : 4996) // warning C4996: 'sprintf': This function or variable may be unsafe.
#endif

struct MemoryEditor
{
    enum DataFormat
    {
        DataFormat_Bin = 0,
        DataFormat_Dec = 1,
        DataFormat_Hex = 2,
        DataFormat_COUNT
    };

    // Settings
    bool Open;               // = true   // set to false when DrawWindow() was closed. ignore if not using DrawWindow().
    bool ReadOnly;           // = false  // disable any editing.
    int Cols;                // = 16     // number of columns to display.
    bool OptShowOptions;     // = true   // display options button/context menu. when disabled, options will be locked
                             // unless you provide your own UI for them.
    bool OptShowDataPreview; // = false  // display a footer previewing the decimal/binary/hex/float representation of
                             // the currently selected bytes.
    bool OptShowHexII;       // = false  // display values in HexII representation instead of regular hexadecimal: hide
                             // null/zero bytes, ascii values as ".X".
    bool OptShowAscii;       // = true   // display ASCII representation on the right side.
    bool OptGreyOutZeroes;   // = true   // display null/zero bytes using the TextDisabled color.
    bool OptUpperCaseHex;    // = true   // display hexadecimal values as "FF" instead of "ff".
    int OptMidColsCount;     // = 8      // set to 0 to disable extra spacing between every mid-cols.
    int OptAddrDigitsCount;  // = 0      // number of addr digits to display (default calculated based on maximum
                             // displayed addr).
    float OptFooterExtraHeight; // = 0      // space to reserve at the bottom of the widget to add custom widgets
    ImU32 HighlightColor;       //          // background color of highlighted bytes.
    ImU8 (*ReadFn)(const ImU8* data, size_t off);      // = 0      // optional handler to read bytes.
    void (*WriteFn)(ImU8* data, size_t off, ImU8 d);   // = 0      // optional handler to write bytes.
    bool (*HighlightFn)(const ImU8* data, size_t off); //= 0      // optional handler to return Highlight property (to
                                                       // support non-contiguous highlighting).

    // [Internal State]
    bool ContentsWidthChanged;
    size_t DataPreviewAddr;
    size_t DataEditingAddr;
    bool DataEditingTakeFocus;
    char DataInputBuf[32];
    char AddrInputBuf[32];
    size_t GotoAddr;
    size_t HighlightMin, HighlightMax;
    int PreviewEndianess;
    ImGuiDataType PreviewDataType;

    MemoryEditor()
    {
        // Settings
        Open                 = true;
        ReadOnly             = false;
        Cols                 = 16;
        OptShowOptions       = true;
        OptShowDataPreview   = false;
        OptShowHexII         = false;
        OptShowAscii         = true;
        OptGreyOutZeroes     = true;
        OptUpperCaseHex      = true;
        OptMidColsCount      = 8;
        OptAddrDigitsCount   = 0;
        OptFooterExtraHeight = 0.0f;
        HighlightColor       = IM_COL32(255, 255, 255, 50);
        ReadFn               = NULL;
        WriteFn              = NULL;
        HighlightFn          = NULL;

        // State/Internals
        ContentsWidthChanged = false;
        DataPreviewAddr = DataEditingAddr = (size_t)-1;
        DataEditingTakeFocus              = false;
        memset(DataInputBuf, 0, sizeof(DataInputBuf));
        memset(AddrInputBuf, 0, sizeof(AddrInputBuf));
        GotoAddr     = (size_t)-1;
        HighlightMin = HighlightMax = (size_t)-1;
        PreviewEndianess            = 0;
        PreviewDataType             = ImGuiDataType_S32;
    }

    void
    GotoAddrAndHighlight(size_t addr_min, size_t addr_max)
    {
        GotoAddr     = addr_min;
        HighlightMin = addr_min;
        HighlightMax = addr_max;
    }

    struct Sizes
    {
        int AddrDigitsCount;
        float LineHeight;
        float GlyphWidth;
        float HexCellWidth;
        float SpacingBetweenMidCols;
        float PosHexStart;
        float PosHexEnd;
        float PosAsciiStart;
        float PosAsciiEnd;
        float WindowWidth;

        Sizes()
        {
            memset(this, 0, sizeof(*this));
        }
    };

    void
    CalcSizes(Sizes& s, size_t mem_size, size_t base_display_addr)
    {
        ImGuiStyle& style = ImGui::GetStyle();
        s.AddrDigitsCount = OptAddrDigitsCount;
        if ( s.AddrDigitsCount == 0 )
            for ( size_t n = base_display_addr + mem_size - 1; n > 0; n >>= 4 )
                s.AddrDigitsCount++;
        s.LineHeight   = ImGui::GetTextLineHeight();
        s.GlyphWidth   = ImGui::CalcTextSize("F").x + 1;    // We assume the font is mono-space
        s.HexCellWidth = (float)(int)(s.GlyphWidth * 2.5f); // "FF " we include trailing space in the width to easily
                                                            // catch clicks everywhere
        s.SpacingBetweenMidCols =
            (float)(int)(s.HexCellWidth * 0.25f); // Every OptMidColsCount columns we add a bit of extra spacing
        s.PosHexStart   = (s.AddrDigitsCount + 2) * s.GlyphWidth;
        s.PosHexEnd     = s.PosHexStart + (s.HexCellWidth * Cols);
        s.PosAsciiStart = s.PosAsciiEnd = s.PosHexEnd;
        if ( OptShowAscii )
        {
            s.PosAsciiStart = s.PosHexEnd + s.GlyphWidth * 1;
            if ( OptMidColsCount > 0 )
                s.PosAsciiStart += (float)((Cols + OptMidColsCount - 1) / OptMidColsCount) * s.SpacingBetweenMidCols;
            s.PosAsciiEnd = s.PosAsciiStart + Cols * s.GlyphWidth;
        }
        s.WindowWidth = s.PosAsciiEnd + style.ScrollbarSize + style.WindowPadding.x * 2 + s.GlyphWidth;
    }

    // Standalone Memory Editor window
    void
    DrawWindow(const char* title, void* mem_data, size_t mem_size, size_t base_display_addr = 0x0000)
    {
        Sizes s;
        CalcSizes(s, mem_size, base_display_addr);
        ImGui::SetNextWindowSize(ImVec2(s.WindowWidth, s.WindowWidth * 0.60f), ImGuiCond_FirstUseEver);
        ImGui::SetNextWindowSizeConstraints(ImVec2(0.0f, 0.0f), ImVec2(s.WindowWidth, FLT_MAX));

        Open = true;
        if ( ImGui::Begin(title, &Open, ImGuiWindowFlags_NoScrollbar) )
        {
            if ( ImGui::IsWindowHovered(ImGuiHoveredFlags_RootAndChildWindows) &&
                 ImGui::IsMouseReleased(ImGuiMouseButton_Right) )
                ImGui::OpenPopup("context");
            DrawContents(mem_data, mem_size, base_display_addr);
            if ( ContentsWidthChanged )
            {
                CalcSizes(s, mem_size, base_display_addr);
                ImGui::SetWindowSize(ImVec2(s.WindowWidth, ImGui::GetWindowSize().y));
            }
        }
        ImGui::End();
    }

    // Memory Editor contents only
    void
    DrawContents(void* mem_data_void, size_t mem_size, size_t base_display_addr = 0x0000)
    {
        if ( Cols < 1 )
            Cols = 1;

        ImU8* mem_data = (ImU8*)mem_data_void;
        Sizes s;
        CalcSizes(s, mem_size, base_display_addr);
        ImGuiStyle& style = ImGui::GetStyle();

        // We begin into our scrolling region with the 'ImGuiWindowFlags_NoMove' in order to prevent click from moving
        // the window. This is used as a facility since our main click detection code doesn't assign an ActiveId so the
        // click would normally be caught as a window-move.
        const float height_separator = style.ItemSpacing.y;
        float footer_height          = OptFooterExtraHeight;
        if ( OptShowOptions )
            footer_height += height_separator + ImGui::GetFrameHeightWithSpacing() * 1;
        if ( OptShowDataPreview )
            footer_height +=
                height_separator + ImGui::GetFrameHeightWithSpacing() * 1 + ImGui::GetTextLineHeightWithSpacing() * 3;
        ImGui::BeginChild(
            "##scrolling",
            ImVec2(0, -footer_height),
            false,
            ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoNav);
        ImDrawList* draw_list = ImGui::GetWindowDrawList();

        ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(0, 0));
        ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0, 0));

        // We are not really using the clipper API correctly here, because we rely on
        // visible_start_addr/visible_end_addr for our scrolling function.
        const int line_total_count = (int)((mem_size + Cols - 1) / Cols);
        ImGuiListClipper clipper;
        clipper.Begin(line_total_count, s.LineHeight);

        bool data_next = false;

        if ( ReadOnly || DataEditingAddr >= mem_size )
            DataEditingAddr = (size_t)-1;
        if ( DataPreviewAddr >= mem_size )
            DataPreviewAddr = (size_t)-1;

        size_t preview_data_type_size = OptShowDataPreview ? DataTypeGetSize(PreviewDataType) : 0;

        size_t data_editing_addr_next = (size_t)-1;
        if ( DataEditingAddr != (size_t)-1 )
        {
            // Move cursor but only apply on next frame so scrolling with be synchronized (because currently we can't
            // change the scrolling while the window is being rendered)
            if ( ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_UpArrow)) &&
                 (ptrdiff_t)DataEditingAddr >= (ptrdiff_t)Cols )
            {
                data_editing_addr_next = DataEditingAddr - Cols;
            }
            else if (
                ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_DownArrow)) &&
                (ptrdiff_t)DataEditingAddr < (ptrdiff_t)mem_size - Cols )
            {
                data_editing_addr_next = DataEditingAddr + Cols;
            }
            else if (
                ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_LeftArrow)) &&
                (ptrdiff_t)DataEditingAddr > (ptrdiff_t)0 )
            {
                data_editing_addr_next = DataEditingAddr - 1;
            }
            else if (
                ImGui::IsKeyPressed(ImGui::GetKeyIndex(ImGuiKey_RightArrow)) &&
                (ptrdiff_t)DataEditingAddr < (ptrdiff_t)mem_size - 1 )
            {
                data_editing_addr_next = DataEditingAddr + 1;
            }
        }

        // Draw vertical separator
        ImVec2 window_pos = ImGui::GetWindowPos();
        if ( OptShowAscii )
            draw_list->AddLine(
                ImVec2(window_pos.x + s.PosAsciiStart - s.GlyphWidth, window_pos.y),
                ImVec2(window_pos.x + s.PosAsciiStart - s.GlyphWidth, window_pos.y + 9999),
                ImGui::GetColorU32(ImGuiCol_Border));

        const ImU32 color_text     = ImGui::GetColorU32(ImGuiCol_Text);
        const ImU32 color_disabled = OptGreyOutZeroes ? ImGui::GetColorU32(ImGuiCol_TextDisabled) : color_text;

        const char* format_address    = OptUpperCaseHex ? "%0*" _PRISizeT "X: " : "%0*" _PRISizeT "x: ";
        const char* format_data       = OptUpperCaseHex ? "%0*" _PRISizeT "X" : "%0*" _PRISizeT "x";
        const char* format_byte       = OptUpperCaseHex ? "%02X" : "%02x";
        const char* format_byte_space = OptUpperCaseHex ? "%02X " : "%02x ";

        while ( clipper.Step() )
            for ( int line_i = clipper.DisplayStart; line_i < clipper.DisplayEnd;
                  line_i++ ) // display only visible lines
            {
                size_t addr = (size_t)(line_i * Cols);
                ImGui::Text(format_address, s.AddrDigitsCount, base_display_addr + addr);

                // Draw Hexadecimal
                for ( int n = 0; n < Cols && addr < mem_size; n++, addr++ )
                {
                    float byte_pos_x = s.PosHexStart + s.HexCellWidth * n;
                    if ( OptMidColsCount > 0 )
                        byte_pos_x += (float)(n / OptMidColsCount) * s.SpacingBetweenMidCols;
                    ImGui::SameLine(byte_pos_x);

                    // Draw highlight
                    bool is_highlight_from_user_range = (addr >= HighlightMin && addr < HighlightMax);
                    bool is_highlight_from_user_func  = (HighlightFn && HighlightFn(mem_data, addr));
                    bool is_highlight_from_preview =
                        (addr >= DataPreviewAddr && addr < DataPreviewAddr + preview_data_type_size);
                    if ( is_highlight_from_user_range || is_highlight_from_user_func || is_highlight_from_preview )
                    {
                        ImVec2 pos            = ImGui::GetCursorScreenPos();
                        float highlight_width = s.GlyphWidth * 2;
                        bool is_next_byte_highlighted =
                            (addr + 1 < mem_size) && ((HighlightMax != (size_t)-1 && addr + 1 < HighlightMax) ||
                                                      (HighlightFn && HighlightFn(mem_data, addr + 1)));
                        if ( is_next_byte_highlighted || (n + 1 == Cols) )
                        {
                            highlight_width = s.HexCellWidth;
                            if ( OptMidColsCount > 0 && n > 0 && (n + 1) < Cols && ((n + 1) % OptMidColsCount) == 0 )
                                highlight_width += s.SpacingBetweenMidCols;
                        }
                        draw_list->AddRectFilled(
                            pos,
                            ImVec2(pos.x + highlight_width, pos.y + s.LineHeight),
                            HighlightColor);
                    }

                    if ( DataEditingAddr == addr )
                    {
                        // Display text input on current byte
                        bool data_write = false;
                        ImGui::PushID((void*)addr);
                        if ( DataEditingTakeFocus )
                        {
                            ImGui::SetKeyboardFocusHere(0);
                            sprintf(AddrInputBuf, format_data, s.AddrDigitsCount, base_display_addr + addr);
                            sprintf(DataInputBuf, format_byte, ReadFn ? ReadFn(mem_data, addr) : mem_data[addr]);
                        }
                        struct UserData
                        {
                            static int
                            Callback(ImGuiInputTextCallbackData* data)
                            {
                                UserData* user_data = (UserData*)data->UserData;
                                if ( !data->HasSelection() )
                                    user_data->CursorPos = data->CursorPos;
                                if ( data->SelectionStart == 0 && data->SelectionEnd == data->BufTextLen )
                                {
                                    // When not editing a byte, always refresh its InputText content pulled from
                                    // underlying memory data (this is a bit tricky, since InputText technically "owns"
                                    // the master copy of the buffer we edit it in there)
                                    data->DeleteChars(0, data->BufTextLen);
                                    data->InsertChars(0, user_data->CurrentBufOverwrite);
                                    data->SelectionStart = 0;
                                    data->SelectionEnd   = 2;
                                    data->CursorPos      = 0;
                                }
                                return 0;
                            }
                            char CurrentBufOverwrite[3]; // Input
                            int CursorPos;               // Output
                        };
                        UserData user_data;
                        user_data.CursorPos = -1;
                        sprintf(
                            user_data.CurrentBufOverwrite,
                            format_byte,
                            ReadFn ? ReadFn(mem_data, addr) : mem_data[addr]);
                        ImGuiInputTextFlags flags =
                            ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_EnterReturnsTrue |
                            ImGuiInputTextFlags_AutoSelectAll | ImGuiInputTextFlags_NoHorizontalScroll |
                            ImGuiInputTextFlags_CallbackAlways;
#if IMGUI_VERSION_NUM >= 18104
                        flags |= ImGuiInputTextFlags_AlwaysOverwrite;
#else
                        flags |= ImGuiInputTextFlags_AlwaysInsertMode;
#endif
                        ImGui::SetNextItemWidth(s.GlyphWidth * 2);
                        if ( ImGui::InputText(
                                 "##data",
                                 DataInputBuf,
                                 IM_ARRAYSIZE(DataInputBuf),
                                 flags,
                                 UserData::Callback,
                                 &user_data) )
                            data_write = data_next = true;
                        else if ( !DataEditingTakeFocus && !ImGui::IsItemActive() )
                            DataEditingAddr = data_editing_addr_next = (size_t)-1;
                        DataEditingTakeFocus = false;
                        if ( user_data.CursorPos >= 2 )
                            data_write = data_next = true;
                        if ( data_editing_addr_next != (size_t)-1 )
                            data_write = data_next = false;
                        unsigned int data_input_value = 0;
                        if ( data_write && sscanf(DataInputBuf, "%X", &data_input_value) == 1 )
                        {
                            if ( WriteFn )
                                WriteFn(mem_data, addr, (ImU8)data_input_value);
                            else
                                mem_data[addr] = (ImU8)data_input_value;
                        }
                        ImGui::PopID();
                    }
                    else
                    {
                        // NB: The trailing space is not visible but ensure there's no gap that the mouse cannot click
                        // on.
                        ImU8 b = ReadFn ? ReadFn(mem_data, addr) : mem_data[addr];

                        if ( OptShowHexII )
                        {
                            if ( (b >= 32 && b < 128) )
                                ImGui::Text(".%c ", b);
                            else if ( b == 0xFF && OptGreyOutZeroes )
                                ImGui::TextDisabled("## ");
                            else if ( b == 0x00 )
                                ImGui::Text("   ");
                            else
                                ImGui::Text(format_byte_space, b);
                        }
                        else
                        {
                            if ( b == 0 && OptGreyOutZeroes )
                                ImGui::TextDisabled("00 ");
                            else
                                ImGui::Text(format_byte_space, b);
                        }
                        if ( !ReadOnly && ImGui::IsItemHovered() && ImGui::IsMouseClicked(0) )
                        {
                            DataEditingTakeFocus   = true;
                            data_editing_addr_next = addr;
                        }
                    }
                }

                if ( OptShowAscii )
                {
                    // Draw ASCII values
                    ImGui::SameLine(s.PosAsciiStart);
                    ImVec2 pos = ImGui::GetCursorScreenPos();
                    addr       = line_i * Cols;
                    ImGui::PushID(line_i);
                    if ( ImGui::InvisibleButton("ascii", ImVec2(s.PosAsciiEnd - s.PosAsciiStart, s.LineHeight)) )
                    {
                        DataEditingAddr = DataPreviewAddr =
                            addr + (size_t)((ImGui::GetIO().MousePos.x - pos.x) / s.GlyphWidth);
                        DataEditingTakeFocus = true;
                    }
                    ImGui::PopID();
                    for ( int n = 0; n < Cols && addr < mem_size; n++, addr++ )
                    {
                        if ( addr == DataEditingAddr )
                        {
                            draw_list->AddRectFilled(
                                pos,
                                ImVec2(pos.x + s.GlyphWidth, pos.y + s.LineHeight),
                                ImGui::GetColorU32(ImGuiCol_FrameBg));
                            draw_list->AddRectFilled(
                                pos,
                                ImVec2(pos.x + s.GlyphWidth, pos.y + s.LineHeight),
                                ImGui::GetColorU32(ImGuiCol_TextSelectedBg));
                        }
                        unsigned char c = ReadFn ? ReadFn(mem_data, addr) : mem_data[addr];
                        char display_c  = (c < 32 || c >= 128) ? '.' : c;
                        draw_list
                            ->AddText(pos, (display_c == c) ? color_text : color_disabled, &display_c, &display_c + 1);
                        pos.x += s.GlyphWidth;
                    }
                }
            }
        ImGui::PopStyleVar(2);
        ImGui::EndChild();

        // Notify the main window of our ideal child content size (FIXME: we are missing an API to get the contents size
        // from the child)
        ImGui::SetCursorPosX(s.WindowWidth);

        if ( data_next && DataEditingAddr + 1 < mem_size )
        {
            DataEditingAddr = DataPreviewAddr = DataEditingAddr + 1;
            DataEditingTakeFocus              = true;
        }
        else if ( data_editing_addr_next != (size_t)-1 )
        {
            DataEditingAddr = DataPreviewAddr = data_editing_addr_next;
            DataEditingTakeFocus              = true;
        }

        const bool lock_show_data_preview = OptShowDataPreview;
        if ( OptShowOptions )
        {
            ImGui::Separator();
            DrawOptionsLine(s, mem_data, mem_size, base_display_addr);
        }

        if ( lock_show_data_preview )
        {
            ImGui::Separator();
            DrawPreviewLine(s, mem_data, mem_size, base_display_addr);
        }
    }

    void
    DrawOptionsLine(const Sizes& s, void* mem_data, size_t mem_size, size_t base_display_addr)
    {
        IM_UNUSED(mem_data);
        ImGuiStyle& style        = ImGui::GetStyle();
        const char* format_range = OptUpperCaseHex ? "Range %0*" _PRISizeT "X..%0*" _PRISizeT "X" :
                                                     "Range %0*" _PRISizeT "x..%0*" _PRISizeT "x";

        // Options menu
        if ( ImGui::Button("Options") )
            ImGui::OpenPopup("context");
        if ( ImGui::BeginPopup("context") )
        {
            ImGui::SetNextItemWidth(s.GlyphWidth * 7 + style.FramePadding.x * 2.0f);
            if ( ImGui::DragInt("##cols", &Cols, 0.2f, 4, 32, "%d cols") )
            {
                ContentsWidthChanged = true;
                if ( Cols < 1 )
                    Cols = 1;
            }
            ImGui::Checkbox("Show Data Preview", &OptShowDataPreview);
            ImGui::Checkbox("Show HexII", &OptShowHexII);
            if ( ImGui::Checkbox("Show Ascii", &OptShowAscii) )
            {
                ContentsWidthChanged = true;
            }
            ImGui::Checkbox("Grey out zeroes", &OptGreyOutZeroes);
            ImGui::Checkbox("Uppercase Hex", &OptUpperCaseHex);

            ImGui::EndPopup();
        }

        ImGui::SameLine();
        ImGui::Text(
            format_range,
            s.AddrDigitsCount,
            base_display_addr,
            s.AddrDigitsCount,
            base_display_addr + mem_size - 1);
        ImGui::SameLine();
        ImGui::SetNextItemWidth((s.AddrDigitsCount + 1) * s.GlyphWidth + style.FramePadding.x * 2.0f);
        if ( ImGui::InputText(
                 "##addr",
                 AddrInputBuf,
                 IM_ARRAYSIZE(AddrInputBuf),
                 ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_EnterReturnsTrue) )
        {
            size_t goto_addr;
            if ( sscanf(AddrInputBuf, "%" _PRISizeT "X", &goto_addr) == 1 )
            {
                GotoAddr     = goto_addr - base_display_addr;
                HighlightMin = HighlightMax = (size_t)-1;
            }
        }

        if ( GotoAddr != (size_t)-1 )
        {
            if ( GotoAddr < mem_size )
            {
                ImGui::BeginChild("##scrolling");
                ImGui::SetScrollFromPosY(ImGui::GetCursorStartPos().y + (GotoAddr / Cols) * ImGui::GetTextLineHeight());
                ImGui::EndChild();
                DataEditingAddr = DataPreviewAddr = GotoAddr;
                DataEditingTakeFocus              = true;
            }
            GotoAddr = (size_t)-1;
        }
    }

    void
    DrawPreviewLine(const Sizes& s, void* mem_data_void, size_t mem_size, size_t base_display_addr)
    {
        IM_UNUSED(base_display_addr);
        ImU8* mem_data    = (ImU8*)mem_data_void;
        ImGuiStyle& style = ImGui::GetStyle();
        ImGui::AlignTextToFramePadding();
        ImGui::Text("Preview as:");
        ImGui::SameLine();
        ImGui::SetNextItemWidth((s.GlyphWidth * 10.0f) + style.FramePadding.x * 2.0f + style.ItemInnerSpacing.x);
        if ( ImGui::BeginCombo("##combo_type", DataTypeGetDesc(PreviewDataType), ImGuiComboFlags_HeightLargest) )
        {
            for ( int n = 0; n < ImGuiDataType_COUNT; n++ )
                if ( ImGui::Selectable(DataTypeGetDesc((ImGuiDataType)n), PreviewDataType == n) )
                    PreviewDataType = (ImGuiDataType)n;
            ImGui::EndCombo();
        }
        ImGui::SameLine();
        ImGui::SetNextItemWidth((s.GlyphWidth * 6.0f) + style.FramePadding.x * 2.0f + style.ItemInnerSpacing.x);
        ImGui::Combo("##combo_endianess", &PreviewEndianess, "LE\0BE\0\0");

        char buf[128]  = "";
        float x        = s.GlyphWidth * 6.0f;
        bool has_value = DataPreviewAddr != (size_t)-1;
        if ( has_value )
            DrawPreviewData(
                DataPreviewAddr,
                mem_data,
                mem_size,
                PreviewDataType,
                DataFormat_Dec,
                buf,
                (size_t)IM_ARRAYSIZE(buf));
        ImGui::Text("Dec");
        ImGui::SameLine(x);
        ImGui::TextUnformatted(has_value ? buf : "N/A");
        if ( has_value )
            DrawPreviewData(
                DataPreviewAddr,
                mem_data,
                mem_size,
                PreviewDataType,
                DataFormat_Hex,
                buf,
                (size_t)IM_ARRAYSIZE(buf));
        ImGui::Text("Hex");
        ImGui::SameLine(x);
        ImGui::TextUnformatted(has_value ? buf : "N/A");
        if ( has_value )
            DrawPreviewData(
                DataPreviewAddr,
                mem_data,
                mem_size,
                PreviewDataType,
                DataFormat_Bin,
                buf,
                (size_t)IM_ARRAYSIZE(buf));
        buf[IM_ARRAYSIZE(buf) - 1] = 0;
        ImGui::Text("Bin");
        ImGui::SameLine(x);
        ImGui::TextUnformatted(has_value ? buf : "N/A");
    }

    // Utilities for Data Preview
    const char*
    DataTypeGetDesc(ImGuiDataType data_type) const
    {
        const char* descs[] =
            {"Int8", "Uint8", "Int16", "Uint16", "Int32", "Uint32", "Int64", "Uint64", "Float", "Double"};
        IM_ASSERT(data_type >= 0 && data_type < ImGuiDataType_COUNT);
        return descs[data_type];
    }

    size_t
    DataTypeGetSize(ImGuiDataType data_type) const
    {
        const size_t sizes[] = {1, 1, 2, 2, 4, 4, 8, 8, sizeof(float), sizeof(double)};
        IM_ASSERT(data_type >= 0 && data_type < ImGuiDataType_COUNT);
        return sizes[data_type];
    }

    const char*
    DataFormatGetDesc(DataFormat data_format) const
    {
        const char* descs[] = {"Bin", "Dec", "Hex"};
        IM_ASSERT(data_format >= 0 && data_format < DataFormat_COUNT);
        return descs[data_format];
    }

    bool
    IsBigEndian() const
    {
        uint16_t x = 1;
        char c[2];
        memcpy(c, &x, 2);
        return c[0] != 0;
    }

    static void*
    EndianessCopyBigEndian(void* _dst, void* _src, size_t s, int is_little_endian)
    {
        if ( is_little_endian )
        {
            uint8_t* dst = (uint8_t*)_dst;
            uint8_t* src = (uint8_t*)_src + s - 1;
            for ( int i = 0, n = (int)s; i < n; ++i )
                memcpy(dst++, src--, 1);
            return _dst;
        }
        else
        {
            return memcpy(_dst, _src, s);
        }
    }

    static void*
    EndianessCopyLittleEndian(void* _dst, void* _src, size_t s, int is_little_endian)
    {
        if ( is_little_endian )
        {
            return memcpy(_dst, _src, s);
        }
        else
        {
            uint8_t* dst = (uint8_t*)_dst;
            uint8_t* src = (uint8_t*)_src + s - 1;
            for ( int i = 0, n = (int)s; i < n; ++i )
                memcpy(dst++, src--, 1);
            return _dst;
        }
    }

    void*
    EndianessCopy(void* dst, void* src, size_t size) const
    {
        static void* (*fp)(void*, void*, size_t, int) = NULL;
        if ( fp == NULL )
            fp = IsBigEndian() ? EndianessCopyBigEndian : EndianessCopyLittleEndian;
        return fp(dst, src, size, PreviewEndianess);
    }

    const char*
    FormatBinary(const uint8_t* buf, int width) const
    {
        IM_ASSERT(width <= 64);
        size_t out_n = 0;
        static char out_buf[64 + 8 + 1];
        int n = width / 8;
        for ( int j = n - 1; j >= 0; --j )
        {
            for ( int i = 0; i < 8; ++i )
                out_buf[out_n++] = (buf[j] & (1 << (7 - i))) ? '1' : '0';
            out_buf[out_n++] = ' ';
        }
        IM_ASSERT(out_n < IM_ARRAYSIZE(out_buf));
        out_buf[out_n] = 0;
        return out_buf;
    }

    // [Internal]
    void
    DrawPreviewData(
        size_t addr,
        const ImU8* mem_data,
        size_t mem_size,
        ImGuiDataType data_type,
        DataFormat data_format,
        char* out_buf,
        size_t out_buf_size) const
    {
        uint8_t buf[8];
        size_t elem_size = DataTypeGetSize(data_type);
        size_t size      = addr + elem_size > mem_size ? mem_size - addr : elem_size;
        if ( ReadFn )
            for ( int i = 0, n = (int)size; i < n; ++i )
                buf[i] = ReadFn(mem_data, addr + i);
        else
            memcpy(buf, mem_data + addr, size);

        if ( data_format == DataFormat_Bin )
        {
            uint8_t binbuf[8];
            EndianessCopy(binbuf, buf, size);
            ImSnprintf(out_buf, out_buf_size, "%s", FormatBinary(binbuf, (int)size * 8));
            return;
        }

        out_buf[0] = 0;
        switch ( data_type )
        {
        case ImGuiDataType_S8:
        {
            int8_t int8 = 0;
            EndianessCopy(&int8, buf, size);
            if ( data_format == DataFormat_Dec )
            {
                ImSnprintf(out_buf, out_buf_size, "%hhd", int8);
                return;
            }
            if ( data_format == DataFormat_Hex )
            {
                ImSnprintf(out_buf, out_buf_size, "0x%02x", int8 & 0xFF);
                return;
            }
            break;
        }
        case ImGuiDataType_U8:
        {
            uint8_t uint8 = 0;
            EndianessCopy(&uint8, buf, size);
            if ( data_format == DataFormat_Dec )
            {
                ImSnprintf(out_buf, out_buf_size, "%hhu", uint8);
                return;
            }
            if ( data_format == DataFormat_Hex )
            {
                ImSnprintf(out_buf, out_buf_size, "0x%02x", uint8 & 0XFF);
                return;
            }
            break;
        }
        case ImGuiDataType_S16:
        {
            int16_t int16 = 0;
            EndianessCopy(&int16, buf, size);
            if ( data_format == DataFormat_Dec )
            {
                ImSnprintf(out_buf, out_buf_size, "%hd", int16);
                return;
            }
            if ( data_format == DataFormat_Hex )
            {
                ImSnprintf(out_buf, out_buf_size, "0x%04x", int16 & 0xFFFF);
                return;
            }
            break;
        }
        case ImGuiDataType_U16:
        {
            uint16_t uint16 = 0;
            EndianessCopy(&uint16, buf, size);
            if ( data_format == DataFormat_Dec )
            {
                ImSnprintf(out_buf, out_buf_size, "%hu", uint16);
                return;
            }
            if ( data_format == DataFormat_Hex )
            {
                ImSnprintf(out_buf, out_buf_size, "0x%04x", uint16 & 0xFFFF);
                return;
            }
            break;
        }
        case ImGuiDataType_S32:
        {
            int32_t int32 = 0;
            EndianessCopy(&int32, buf, size);
            if ( data_format == DataFormat_Dec )
            {
                ImSnprintf(out_buf, out_buf_size, "%d", int32);
                return;
            }
            if ( data_format == DataFormat_Hex )
            {
                ImSnprintf(out_buf, out_buf_size, "0x%08x", int32);
                return;
            }
            break;
        }
        case ImGuiDataType_U32:
        {
            uint32_t uint32 = 0;
            EndianessCopy(&uint32, buf, size);
            if ( data_format == DataFormat_Dec )
            {
                ImSnprintf(out_buf, out_buf_size, "%u", uint32);
                return;
            }
            if ( data_format == DataFormat_Hex )
            {
                ImSnprintf(out_buf, out_buf_size, "0x%08x", uint32);
                return;
            }
            break;
        }
        case ImGuiDataType_S64:
        {
            int64_t int64 = 0;
            EndianessCopy(&int64, buf, size);
            if ( data_format == DataFormat_Dec )
            {
                ImSnprintf(out_buf, out_buf_size, "%lld", (long long)int64);
                return;
            }
            if ( data_format == DataFormat_Hex )
            {
                ImSnprintf(out_buf, out_buf_size, "0x%016llx", (long long)int64);
                return;
            }
            break;
        }
        case ImGuiDataType_U64:
        {
            uint64_t uint64 = 0;
            EndianessCopy(&uint64, buf, size);
            if ( data_format == DataFormat_Dec )
            {
                ImSnprintf(out_buf, out_buf_size, "%llu", (long long)uint64);
                return;
            }
            if ( data_format == DataFormat_Hex )
            {
                ImSnprintf(out_buf, out_buf_size, "0x%016llx", (long long)uint64);
                return;
            }
            break;
        }
        case ImGuiDataType_Float:
        {
            float float32 = 0.0f;
            EndianessCopy(&float32, buf, size);
            if ( data_format == DataFormat_Dec )
            {
                ImSnprintf(out_buf, out_buf_size, "%f", float32);
                return;
            }
            if ( data_format == DataFormat_Hex )
            {
                ImSnprintf(out_buf, out_buf_size, "%a", float32);
                return;
            }
            break;
        }
        case ImGuiDataType_Double:
        {
            double float64 = 0.0;
            EndianessCopy(&float64, buf, size);
            if ( data_format == DataFormat_Dec )
            {
                ImSnprintf(out_buf, out_buf_size, "%f", float64);
                return;
            }
            if ( data_format == DataFormat_Hex )
            {
                ImSnprintf(out_buf, out_buf_size, "%a", float64);
                return;
            }
            break;
        }
        case ImGuiDataType_COUNT:
            break;
        }             // Switch
        IM_ASSERT(0); // Shouldn't reach
    }
};

#undef _PRISizeT
#undef ImSnprintf

#ifdef _MSC_VER
#pragma warning(pop)
#endif

```

`GUI/Headers/App.hpp`:

```hpp
#pragma once

// clang-format off
#include "Common.hpp"
#include "Comms.hpp"
#include "Utils.hpp"
#include "Messages.hpp"
#include "Network.hpp"

#include <chrono>
#include <filesystem>
#include <mutex>
#include <string>
#include <thread>
#include <unordered_map>
#include <vector>

#include <nlohmann/json.hpp>
// clang-format on


using json = nlohmann::json;
using namespace std::literals::chrono_literals;

namespace CFB::GUI::App
{

class Context
{
public:
    Context() :
        Restart {false},
        KeepRunning {true},
        ShowSettingPopup {false},
        SelectedFontPath {"C:\\Windows\\Fonts\\SegoeUI.ttf"},
        FontSize {16.0f},
        Drivers {},
        Target {},
        RefreshingDrivers {false},
        CapturedIrps {}
    {
        Target.Host.reserve(1024);
        Target.Host.assign("192.168.57.24");
        Target.Port        = 1337;
        Target.IsConnected = false;

        m_IrpThread.detach();
    }

    ~Context()
    {
        if ( Target.IsConnected )
        {
            Target.Disconnect();
        }

        m_IrpThread.join();
    }

    bool Restart;
    bool KeepRunning;
    bool ShowSettingPopup;

    std::string SelectedFontPath;
    float FontSize;
    std::unordered_map<std::string, std::pair<bool, bool>> Drivers;
    std::vector<CFB::Comms::CapturedIrp> CapturedIrps;
    bool RefreshingDrivers;
    Target Target;
    std::mutex IrpLock;

    ///
    ///@brief
    ///
    ///@param JsonFile
    ///
    void
    LoadIrpsFromFile(std::filesystem::path const& JsonFile);

    ///
    ///@brief
    ///
    ///@param JsonFile
    ///
    void
    SaveIrpsToFile(std::filesystem::path const& JsonFile);

    ///
    ///@brief
    ///
    ///@return true
    ///@return false
    ///
    bool
    RefreshDriverList()
    {
        bool res = false;
        std::jthread thr {
            [this, &res]
            {
                Drivers.clear();
                RefreshingDrivers = true;
                res               = true;

                for ( auto id :
                      {CFB::Comms::RequestId::EnumerateDriverObject, CFB::Comms::RequestId::EnumerateMinifilterObject} )
                {
                    CFB::Comms::DriverRequest req;
                    req.Id = id;

                    auto rep = SendCommand(req);
                    if ( !rep || rep.value()["error_code"] != 0 )
                    {
                        res = false;
                        break;
                    }

                    auto const DriverList = rep.value()["body"]["body"];
                    for ( std::string const& DriverPath : DriverList )
                    {
                        if ( Drivers.find(DriverPath) == Drivers.end() )
                        {
                            Drivers[DriverPath] = {false, false};
                        }
                    }
                }
                RefreshingDrivers = false;
                return;
            }};
        thr.detach();
        return res;
    }

    bool
    EnableMonitoring(std::string const& DriverName)
    {
        if ( Drivers[DriverName].second )
        {
            return true;
        }

        CFB::Comms::DriverRequest req;
        req.Id         = CFB::Comms::RequestId::EnableMonitoring;
        req.DriverName = CFB::Utils::ToWideString(DriverName);
        auto rep       = SendCommand(req);
        if ( !rep || rep.value()["error_code"] != 0 )
        {
            return false;
        }

        if ( rep.value()["body"]["success"] == false )
        {
            return false;
        }

        Drivers[DriverName].second = true;
        return true;
    }

    bool
    DisableMonitoring(std::string const& DriverName)
    {
        if ( !Drivers[DriverName].second )
        {
            return true;
        }

        CFB::Comms::DriverRequest req;
        req.Id         = CFB::Comms::RequestId::DisableMonitoring;
        req.DriverName = CFB::Utils::ToWideString(DriverName);
        auto rep       = SendCommand(req);
        if ( !rep || rep.value()["error_code"] != 0 )
        {
            return false;
        }

        if ( !rep.value()["body"]["success"] )
        {
            return false;
        }
        Drivers[DriverName].second = false;
        return true;
    }

    bool
    EnableDriver(std::string const& DriverName)
    {
        if ( Drivers[DriverName].first )
        {
            return true;
        }

        bool res = false;
        CFB::Comms::DriverRequest req;
        req.Id         = CFB::Comms::RequestId::HookDriver;
        req.DriverName = CFB::Utils::ToWideString(DriverName);

        auto rep = SendCommand(req);
        if ( !rep || rep.value()["error_code"] != 0 )
        {
            res = false;
            return res;
        }

        res = rep.value()["body"]["success"] == true;
        if ( res )
        {
            Drivers[DriverName].first = true;
        }
        return res;
    }

    bool
    DisableDriver(std::string const& DriverName)
    {
        if ( !Drivers[DriverName].first )
        {
            return true;
        }

        bool res = false;
        CFB::Comms::DriverRequest req;
        req.Id         = CFB::Comms::RequestId::UnhookDriver;
        req.DriverName = CFB::Utils::ToWideString(DriverName);

        auto rep = SendCommand(req);
        if ( !rep || rep.value()["error_code"] != 0 )
        {
            res = false;
            return res;
        }

        res = rep.value()["body"]["success"] == true;
        if ( res )
        {
            Drivers[DriverName].first = false;
        }
        return res;
    }

private:
    std::optional<json>
    SendCommand(CFB::Comms::DriverRequest const& Command)
    {
        // Request
        {
            json req;
            CFB::Comms::to_json(req, Command);
            if ( !Target.Send(req.dump()) )
            {
                return std::nullopt;
            }
        }

        // Response
        {
            const usize BufferLength = 4096;
            std::string Buffer       = "";

            while ( true )
            {
                auto Chunk           = Target.Receive<std::string>(BufferLength);
                auto const ChunkSize = ::strlen(Chunk.c_str());
                Chunk.resize(ChunkSize);
                if ( ChunkSize == 0 )
                {
                    return std::nullopt;
                }

                Buffer += Chunk;

                if ( ChunkSize < BufferLength || Chunk[ChunkSize - 1] == '}' )
                {
                    break;
                }
            }

            const usize BufferSize = ::strlen(Buffer.c_str());
            if ( !BufferSize )
            {
                return std::nullopt;
            }

            try
            {
                Buffer.resize(BufferSize);
                return json::parse(Buffer);
            }
            catch ( const std::exception& e )
            {
                return std::nullopt;
            }
        }
    }

    std::jthread m_IrpThread = std::jthread(
        [this]()
        {
            // TODO better synchro with events
            while ( KeepRunning )
            {
                if ( Target.IsConnected )
                {
                    CFB::Comms::DriverRequest req;
                    req.Id          = CFB::Comms::RequestId::GetPendingIrp;
                    req.NumberOfIrp = 1;

                    auto rep = SendCommand(req);
                    if ( rep && rep.value()["error_code"] == 0 )
                    {
                        json body = rep.value()["body"];

                        if ( body["success"] == true && body["number_of_irp"] > 0 )
                        {
                            for ( auto const& entry : body["body"] )
                            {
                                CFB::Comms::CapturedIrp Irp = entry.get<CFB::Comms::CapturedIrp>();
                                std::scoped_lock lock(IrpLock);
                                CapturedIrps.push_back(std::move(Irp));
                            }
                        }
                    }
                }

                std::this_thread::sleep_for(1s);
            }
        });
};


///
///@brief Main function to render CFB
///
///
void
RenderUI();


///
///@brief
///
///
extern Context Globals;


} // namespace CFB::GUI::App

```

`GUI/Headers/GuiUtils.hpp`:

```hpp
#pragma once

#include <filesystem>
#include <optional>
#include <string_view>


namespace CFB::GUI::Utils
{

class FileManager
{
public:
    ///
    ///@brief
    ///
    ///@param Filter
    ///@return std::optional<std::filesystem::path>
    ///
    static std::optional<std::filesystem::path>
    OpenFile(std::string_view const& Filter);

    ///
    ///@brief
    ///
    ///@param Filter
    ///@return std::optional<std::filesystem::path>
    ///
    static std::optional<std::filesystem::path>
    SaveFile(std::string_view const& Filter);
};
} // namespace CFB::GUI::Utils

```

`GUI/Headers/Helpers.hpp`:

```hpp
#pragma once

#include <imgui.h>

namespace CFB::GUI::Helpers
{

///
///@brief From https://github.com/ocornut/imgui/issues/1537#issuecomment-355569554
///
///@param str_id
///@param v
///
bool
ToggleButton(const char* str_id, bool* v);


///
///@brief From https://github.com/ocornut/imgui/issues/1901#issue-335266223
///
///@param label
///@param value
///@param size_arg
///@param bg_col
///@param fg_col
///@return true
///@return false
///
bool
BufferingBar(const char* label, float value, const ImVec2& size_arg, const ImU32& bg_col, const ImU32& fg_col);


///
///@brief From https://github.com/ocornut/imgui/issues/1901#issue-335266223
///
///@param label
///@param radius
///@param thickness
///@param color
///@return true
///@return false
///
bool
Spinner(const char* label, float radius, int thickness, const ImU32& color);

} // namespace CFB::GUI::Helpers

```

`GUI/Headers/Network.hpp`:

```hpp
#pragma once
#define WIN32_LEAN_AND_MEAN

#pragma warning(push)
#pragma warning(disable : 4005) // Macro redefinitions
#include <winsock.h>
#pragma warning(pop)

#include "App.hpp"

namespace CFB::GUI::App
{


class Target
{
public:
    std::string Host {};
    u16 Port {};
    bool IsConnected {};

    bool
    Connect()
    {
        if ( IsConnected )
        {
            return true;
        }

        WSADATA WsaData {};
        if ( ::WSAStartup(MAKEWORD(2, 2), &WsaData) )
        {
            return false;
        }

        m_Socket = ::socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
        if ( m_Socket == INVALID_SOCKET )
        {
            ::WSACleanup();
            return false;
        }

        SOCKADDR_IN sa;
        sa.sin_addr.s_addr = ::inet_addr(Host.c_str());
        sa.sin_family      = AF_INET;
        sa.sin_port        = ::htons(Port);
        IsConnected        = ::connect(m_Socket, (PSOCKADDR)&sa, sizeof(SOCKADDR_IN)) != SOCKET_ERROR;

        return IsConnected;
    }

    bool
    Disconnect()
    {
        if ( !IsConnected )
        {
            return true;
        }

        IsConnected = (::closesocket(m_Socket) == 0) ? false : true;
        ::WSACleanup();
        return IsConnected;
    }

    template<typename T>
    bool
    Send(T const& Buffer)
    {
        if ( !IsConnected )
        {
            return false;
        }

        int iResult = send(m_Socket, (const char*)Buffer.data(), Buffer.size(), 0);
        if ( iResult == SOCKET_ERROR )
        {
            return false;
        }
        return true;
    }

    template<typename T>
    T
    Receive(usize BufferSize)
    {
        if ( !IsConnected )
        {
            return {};
        }

        T Buffer;
        Buffer.resize(BufferSize);
        int iResult = recv(m_Socket, (char*)Buffer.data(), BufferSize, 0);
        if ( iResult == SOCKET_ERROR )
        {
            return {};
        }

        return Buffer;
    }

private:
    SOCKET m_Socket;
};


} // namespace CFB::GUI::App

```

`GUI/Source/App.cpp`:

```cpp
#include "App.hpp"

#include <algorithm>
#include <array>
#include <codecvt>
#include <fstream>
#include <locale>
#include <optional>
#include <ranges>

#include "Addons/imgui_hexeditor.h"
#include "Comms.hpp"
#include "CompileInfo.hpp"
#include "GuiUtils.hpp"
#include "Helpers.hpp"
#include "Utils.hpp"
#include "imgui.h"

static bool* p_open                       = nullptr;
static bool opt_fullscreen                = true;
static bool opt_padding                   = false;
static ImGuiDockNodeFlags dockspace_flags = ImGuiDockNodeFlags_None;

namespace views = std::ranges::views;
using json      = nlohmann::json;

static std::unordered_map<std::string_view, bool> Windows = {
    {"SessionInfo", true},
    {"IrpTable", true},
    {"IrpFactory", false},
    {"IrpDetail", false},
    {"Settings", false},
    {"About", false},
};


namespace CFB::GUI::App
{

Context Globals;

void
Context::LoadIrpsFromFile(std::filesystem::path const& JsonFile)
{
    if ( !std::filesystem::exists(JsonFile) )
    {
        return;
    }

    std::ifstream ifs(JsonFile);
    json j       = json::parse(ifs);
    auto NewIrps = j.get<std::vector<CFB::Comms::CapturedIrp>>();
    std::copy(NewIrps.begin(), NewIrps.end(), std::back_inserter(CapturedIrps));
}

void
Context::SaveIrpsToFile(std::filesystem::path const& JsonFile)
{
    json j = Globals.CapturedIrps;
    std::ofstream file(JsonFile);
    file << j.dump();
}

void
RenderAboutWindow()
{
    if ( ImGui::Begin("About") )
    {
        if ( ImGui::BeginChild("About##Child1") )
        {
            ImGui::SetItemDefaultFocus();

            ImGui::Text("%s - %s", PROJECT_NAME, PROJECT_DESCRIPTION);
            ImGui::Text("Author - %s", PROJECT_AUTHOR);
            ImGui::Text("License - %s", PROJECT_LICENSE);
            ImGui::Text("URL - %s", PROJECT_HOMEPAGE_URL);

            ImGui::Separator();

            ImGui::Text("Versions");
            ImGui::BulletText("Driver: %s", DRIVER_VERSION);
            ImGui::BulletText("Broker: %s", BROKER_VERSION);
            ImGui::BulletText("Gui: %s", GUI_VERSION);

            ImGui::Separator();

            if ( ImGui::Button("OK") )
            {
                Windows["About"] = false;
            }

            ImGui::EndChild();
        }
        ImGui::End();
    }
}

void
RenderSettingsWindow()
{
    ImGui::Begin("Settings");

    if ( ImGui::BeginChild("Settings##Child1") )
    {
        ImGui::SetItemDefaultFocus();

        ImGui::InputText("CFB Broker Host", Globals.Target.Host.data(), Globals.Target.Host.capacity());
        ImGui::InputInt("CFB Broker Port", (int*)&Globals.Target.Port, 0, 0, ImGuiInputTextFlags_CharsDecimal);
        const std::array<const char*, 1> fonts = {
            Globals.SelectedFontPath.c_str(),
        };
        static int current_font_index = 0;
        ImGui::Combo("Font", &current_font_index, fonts.data(), fonts.size());

        ImGui::Separator();

        if ( ImGui::Button("OK") )
        {
            Windows["Settings"] = false;
        }

        ImGui::EndChild();
    }
    ImGui::End();
}

void
PrepareMenubar()
{
    if ( ImGui::BeginMenuBar() )
    {
        if ( ImGui::BeginMenu("File") )
        {
            if ( ImGui::MenuItem("Save IRPs to file") )
            {
                auto fpath = CFB::GUI::Utils::FileManager::SaveFile("JSON Files\0*.json\0\0");
                if ( fpath )
                {
                    Globals.SaveIrpsToFile(fpath.value());
                }
            }

            if ( ImGui::MenuItem("Load IRPs from file") )
            {
                auto fpath = CFB::GUI::Utils::FileManager::OpenFile("JSON Files\0*.json\0\0");
                if ( fpath )
                {
                    Globals.LoadIrpsFromFile(fpath.value());
                }
            }

            ImGui::Separator();

            if ( ImGui::MenuItem("Restart") )
            {
                Globals.KeepRunning = false;
                Globals.Restart     = true;
            }

            if ( ImGui::MenuItem("Quit") )
            {
                Globals.KeepRunning = false;
                Globals.Restart     = false;
            }

            ImGui::EndMenu();
        }

        if ( ImGui::BeginMenu("Window") )
        {
            for ( auto const& WindowName : std::views::keys(Windows) )
            {
                if ( ImGui::MenuItem(WindowName.data(), nullptr, Windows[WindowName]) )
                {
                    Windows[WindowName] ^= true;
                }
            }

            ImGui::EndMenu();
        }

        ImGui::EndMenuBar();
    }
}

// move to helpers
static inline void
InputHex(const char* label, void* value, int type)
{
    const static auto TEXT_WIDTH = ImGui::CalcTextSize("A").x;
    const float INPUT_HEX_WIDTH  = TEXT_WIDTH * 20;
    const char* fmt              = nullptr;
    switch ( type )
    {
    case ImGuiDataType_U8:
        fmt = "0x%02X";
        break;
    case ImGuiDataType_U16:
        fmt = "0x%04X";
        break;
    case ImGuiDataType_U32:
        fmt = "0x%08X";
        break;
    case ImGuiDataType_U64:
        fmt = "0x%16X";
        break;
    default:
        fmt = "0x%08X";
        break;
    }

    ImGui::PushItemWidth(INPUT_HEX_WIDTH);
    ImGui::InputScalar(
        label,
        type,
        value,
        nullptr,
        nullptr,
        fmt,
        ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_ReadOnly);
    ImGui::PopItemWidth();
}

static inline void
InputHexU8(const char* label, void* value)
{
    InputHex(label, value, ImGuiDataType_U8);
}

static inline void
InputHexU16(const char* label, void* value)
{
    InputHex(label, value, ImGuiDataType_U16);
}

static inline void
InputHexU32(const char* label, void* value)
{
    InputHex(label, value, ImGuiDataType_U32);
}

static inline void
InputHexU64(const char* label, void* value)
{
    InputHex(label, value, ImGuiDataType_U64);
}

void
PrepareDockSpace()
{
    // We are using the ImGuiWindowFlags_NoDocking flag to make the parent window not dockable into,
    // because it would be confusing to have two docking targets within each others.
    ImGuiWindowFlags window_flags = ImGuiWindowFlags_MenuBar | ImGuiWindowFlags_NoDocking;
    if ( opt_fullscreen )
    {
        const ImGuiViewport* viewport = ImGui::GetMainViewport();
        ImGui::SetNextWindowPos(viewport->WorkPos);
        ImGui::SetNextWindowSize(viewport->WorkSize);
        ImGui::SetNextWindowViewport(viewport->ID);
        ImGui::PushStyleVar(ImGuiStyleVar_WindowRounding, 0.0f);
        ImGui::PushStyleVar(ImGuiStyleVar_WindowBorderSize, 0.0f);
        window_flags |= ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoResize |
                        ImGuiWindowFlags_NoMove;
        window_flags |= ImGuiWindowFlags_NoBringToFrontOnFocus | ImGuiWindowFlags_NoNavFocus;
    }
    else
    {
        dockspace_flags &= ~ImGuiDockNodeFlags_PassthruCentralNode;
    }

    // When using ImGuiDockNodeFlags_PassthruCentralNode, DockSpace() will render our background
    // and handle the pass-thru hole, so we ask Begin() to not render a background.
    if ( dockspace_flags & ImGuiDockNodeFlags_PassthruCentralNode )
        window_flags |= ImGuiWindowFlags_NoBackground;

    // Important: note that we proceed even if Begin() returns false (aka window is collapsed).
    // This is because we want to keep our DockSpace() active. If a DockSpace() is inactive,
    // all active windows docked into it will lose their parent and become undocked.
    // We cannot preserve the docking relationship between an active window and an inactive docking, otherwise
    // any change of dockspace/settings would lead to windows being stuck in limbo and never being visible.
    if ( !opt_padding )
        ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0.0f, 0.0f));

    ImGui::Begin("DockSpace1", p_open, window_flags);
    if ( !opt_padding )
        ImGui::PopStyleVar();

    if ( opt_fullscreen )
        ImGui::PopStyleVar(2);

    // Submit the DockSpace
    ImGuiIO& io = ImGui::GetIO();
    if ( io.ConfigFlags & ImGuiConfigFlags_DockingEnable )
    {
        ImGuiID dockspace_id = ImGui::GetID("MyDockSpace");
        ImGui::DockSpace(dockspace_id, ImVec2(0.0f, 0.0f), dockspace_flags);
    }

    PrepareMenubar();

    ImGui::End();
}

void
RenderSessionInfoWindow()
{
    ImGui::Begin("SessionInfo");

    ImGui::Text("Viewing %llu IRPs", Globals.CapturedIrps.size());

    ImGui::Separator();

    ImGui::Text("Target: %s:%u", Globals.Target.Host.c_str(), Globals.Target.Port);
    ImGui::Text("Connected: %s", boolstr(Globals.Target.IsConnected));

    bool NewState = Globals.Target.IsConnected;
    CFB::GUI::Helpers::ToggleButton(Globals.Target.IsConnected ? "Disconnect" : "Connect", &NewState);
    if ( NewState != Globals.Target.IsConnected )
    {
        Globals.Target.IsConnected ? Globals.Target.Disconnect() : Globals.Target.Connect();
    }

    if ( Globals.Target.IsConnected )
    {
        ImGui::Text(
            "Hooked Drivers: %llu",
            std::count_if(
                Globals.Drivers.cbegin(),
                Globals.Drivers.cend(),
                [](std::pair<std::string, std::pair<bool, bool>> const& Entry)
                {
                    return Entry.second.first == true;
                }));
        ImGui::Text(
            "Monitored Drivers: %llu",
            std::count_if(
                Globals.Drivers.cbegin(),
                Globals.Drivers.cend(),
                [](std::pair<std::string, std::pair<bool, bool>> const& Entry)
                {
                    return Entry.second.second == true;
                }));
        ImGui::Text("Driver Found: %llu", Globals.Drivers.size());

        if ( Globals.RefreshingDrivers )
        {
            CFB::GUI::Helpers::Spinner("DriverRefresh##spinner", 7, 3, ImGui::GetColorU32(ImGuiCol_Button));
        }
        else if ( ImGui::Button("Refresh##RefreshDriver") )
        {
            Globals.RefreshDriverList();
        }

        static ImGuiTextFilter DriverFilter;
        DriverFilter.Draw();

        auto DriverView = Globals.Drivers | std::views::filter(
                                                [](auto const& Entry) -> bool
                                                {
                                                    return (DriverFilter.PassFilter(Entry.first.c_str()));
                                                });

        for ( auto& [Driver, Flags] : DriverView )
        {
            if ( ImGui::TreeNode(Driver.c_str()) )
            {
                bool DoHook = Flags.first;
                if ( ImGui::Checkbox("Is Hooked", &DoHook) )
                {
                    DoHook ? Globals.EnableDriver(Driver) : Globals.DisableDriver(Driver);
                }

                if ( DoHook )
                {
                    bool DoCapture = Flags.second;
                    if ( ImGui::Checkbox("Is Capturing", &DoCapture) )
                    {
                        DoCapture ? Globals.EnableMonitoring(Driver) : Globals.DisableMonitoring(Driver);
                    }
                }
                ImGui::TreePop();
            }
        }
    }

    ImGui::End();
}

void
RenderIrpFactoryWindow()
{
    ImGui::Begin("IrpFactory");

    static std::string DevicePath;
    DevicePath.resize(MAX_PATH);
    static i32 IoctlCode, InputBufferLength, OutputBufferLength, StatusCode;

    ImGui::InputText("Device Path", DevicePath.data(), DevicePath.size());
    ImGui::InputInt("IOCTL Code", &IoctlCode);

    ImGui::Separator();

    ImGui::InputInt("Input Buffer Length", &InputBufferLength);
    ImGui::InputInt("Output Buffer Length", &OutputBufferLength);
    ImGui::InputInt("Status Code", &StatusCode);

    ImGui::Separator();

    ImGui::Button("Send IRP");
    ImGui::SameLine();
    ImGui::Button("Clear");

    ImGui::End();
}

void
RenderIrpDetailWindow(CFB::Comms::CapturedIrp& Irp)
{
    const static auto TEXT_WIDTH = ImGui::CalcTextSize("A").x;
    const float INPUT_HEX_WIDTH  = TEXT_WIDTH * 20;

    static MemoryEditor InputBufferView, OutputBufferView;

    ImGui::Begin("IrpDetail");
    std::string DevicePath        = CFB::Utils::ToString(Irp.Header.DeviceName);
    std::string DriverPath        = CFB::Utils::ToString(Irp.Header.DriverName);
    std::string ProcessName       = CFB::Utils::ToString(Irp.Header.ProcessName);
    std::vector<u8>& InputBuffer  = Irp.InputBuffer;
    std::vector<u8>& OutputBuffer = Irp.OutputBuffer;

    ImGui::InputText("Driver Path", DriverPath.data(), DriverPath.size(), ImGuiInputTextFlags_ReadOnly);
    ImGui::InputText("Device Path", DevicePath.data(), DevicePath.size(), ImGuiInputTextFlags_ReadOnly);
    ImGui::InputText("Process Name", ProcessName.data(), ProcessName.size(), ImGuiInputTextFlags_ReadOnly);

    InputHexU32("IOCTL Code", (void*)&Irp.Header.IoctlCode);
    ImGui::SameLine();
    InputHexU32("Status Code", (void*)&Irp.Header.Status);

    ImGui::PushItemWidth(INPUT_HEX_WIDTH);
    ImGui::InputInt("PID", (int*)&Irp.Header.Pid, 0, 0, ImGuiInputTextFlags_ReadOnly);
    ImGui::SameLine();
    ImGui::InputInt("TID", (int*)&Irp.Header.Tid, 0, 0, ImGuiInputTextFlags_ReadOnly);
    ImGui::PopItemWidth();

    InputHexU8("Major Function", (void*)&Irp.Header.MajorFunction);
    ImGui::SameLine();
    InputHexU8("Minor Function", (void*)&Irp.Header.MinorFunction);

    InputHexU32("Input Buffer Length", (void*)&Irp.Header.InputBufferLength);
    ImGui::SameLine();
    InputHexU32("Output Buffer Length", (void*)&Irp.Header.OutputBufferLength);
    ImGui::End();

    if ( !InputBuffer.empty() )
    {
        InputBufferView.DrawWindow("Input Buffer Viewer", InputBuffer.data(), InputBuffer.size());
    }

    if ( !OutputBuffer.empty() )
    {
        OutputBufferView.DrawWindow("Output Buffer Viewer", OutputBuffer.data(), OutputBuffer.size());
    }
}

void
RenderIrpTableWindow()
{
    ImGui::Begin("IrpTable", nullptr, ImGuiWindowFlags_NoTitleBar);

    static ImGuiTextFilter filter;
    filter.Draw();

    ImGui::Separator();

    // const float TEXT_BASE_WIDTH  = ImGui::CalcTextSize("A").x;
    const float TEXT_BASE_HEIGHT = ImGui::GetTextLineHeightWithSpacing();
    const ImGuiTableFlags IrpTableFlags =
        ImGuiTableFlags_RowBg | ImGuiTableFlags_BordersOuter | ImGuiTableFlags_BordersV | ImGuiTableFlags_Resizable |
        ImGuiTableFlags_Reorderable | ImGuiTableFlags_Hideable | ImGuiTableFlags_Sortable | ImGuiTableFlags_SortMulti |
        ImGuiTableFlags_NoBordersInBodyUntilResize;

    auto const& Irps                                             = Globals.CapturedIrps;
    const usize ColumnNumber                                     = 14;
    const std::array<std::string_view, ColumnNumber> ColumnNames = {
        "TimeStamp",
        "Driver Name",
        "Device Name",
        "IRQ Level",
        "Type",
        "Major Function",
        "Minor Function",
        "IOCTL Code",
        "Pid",
        "Tid",
        "Process Name",
        "Status",
        "Input Length",
        "Output Length",
    };

    /*
    auto IrpsView = Irps | std::views::filter(
                               [](CFB::Comms::CapturedIrp const& Irp) -> bool
                               {
                                   auto const IrpAsString = CFB::Utils::ToString(Irp);
                                   return (filter.PassFilter(IrpAsString.c_str()));
                               });
    */
    std::vector<CFB::Comms::CapturedIrp> IrpsView;
    {
        std::scoped_lock lock(Globals.IrpLock);
        std::for_each(
            Irps.cbegin(),
            Irps.cend(),
            [&IrpsView](CFB::Comms::CapturedIrp const& Irp)
            {
                auto const IrpAsString = CFB::Utils::ToString(Irp);
                if ( filter.PassFilter(IrpAsString.c_str()) )
                {
                    IrpsView.push_back(Irp);
                }
            });
    }

    static std::optional<CFB::Comms::CapturedIrp> SelectedIrp = std::nullopt;

    if ( ImGui::BeginTable("IrpTable", ColumnNumber, IrpTableFlags, ImVec2(0.0f, TEXT_BASE_HEIGHT * 8)) )
    {
        //
        // Header row
        //
        ImGui::TableSetupScrollFreeze(0, 1);
        for ( auto const& HeaderLabel : ColumnNames )
        {
            int flags = ImGuiTableColumnFlags_WidthStretch;
            if ( HeaderLabel == "TimeStamp" )
            {
                flags |= ImGuiTableColumnFlags_DefaultSort;
            }
            ImGui::TableSetupColumn(HeaderLabel.data(), flags);
        }
        ImGui::TableSetupScrollFreeze(0, 1);
        ImGui::TableHeadersRow();

        //
        // Populate data
        //
        usize RowIndex = 0;
        for ( auto const& Irp : IrpsView )
        {
            bool selected = false;
            ImGui::TableNextRow();

            //
            // Populate row fields
            //
            ImGui::TableNextColumn();
            std::string label = std::to_string(Irp.Header.TimeStamp);
            label += "##" + std::to_string(RowIndex);
            ImGui::Selectable(label.c_str(), &selected, ImGuiSelectableFlags_SpanAllColumns);

            ImGui::TableNextColumn();
            ImGui::Text("%S", const_cast<wchar_t*>(Irp.Header.DriverName));

            ImGui::TableNextColumn();
            ImGui::Text("%S", const_cast<wchar_t*>(Irp.Header.DeviceName));

            ImGui::TableNextColumn();
            ImGui::Text("%s", CFB::Utils::IrqlToString(Irp.Header.Irql));

            ImGui::TableNextColumn();
            ImGui::Text("%s", CFB::Utils::IrpTypeToString(Irp.Header.Type));

            ImGui::TableNextColumn();
            ImGui::Text("%s", CFB::Utils::IrpMajorToString(Irp.Header.MajorFunction));

            ImGui::TableNextColumn();
            ImGui::Text("%u", Irp.Header.MinorFunction);

            ImGui::TableNextColumn();
            ImGui::Text("0x%08X", Irp.Header.IoctlCode);

            ImGui::TableNextColumn();
            ImGui::Text("%lu", Irp.Header.Pid);

            ImGui::TableNextColumn();
            ImGui::Text("%lu", Irp.Header.Tid);

            ImGui::TableNextColumn();
            ImGui::Text("%S", const_cast<wchar_t*>(Irp.Header.ProcessName));

            ImGui::TableNextColumn();
            ImGui::Text("0x%08X", Irp.Header.Status);

            ImGui::TableNextColumn();
            ImGui::Text("%lu", Irp.Header.InputBufferLength);

            ImGui::TableNextColumn();
            ImGui::Text("%lu", Irp.Header.OutputBufferLength);

            if ( selected )
            {
                SelectedIrp = Irp;
            }

            RowIndex++;
        }

        if ( SelectedIrp )
        {
            RenderIrpDetailWindow(SelectedIrp.value());
        }

        ImGui::EndTable();
    }
    ImGui::End();
} // namespace CFB::GUI::App

void
RenderUI()
{
    PrepareDockSpace();

    if ( Windows["SessionInfo"] )
    {
        RenderSessionInfoWindow();
    }

    if ( Windows["IrpTable"] )
    {
        RenderIrpTableWindow();
    }

    if ( Windows["IrpFactory"] )
    {
        RenderIrpFactoryWindow();
    }

    if ( Windows["Settings"] )
    {
        RenderSettingsWindow();
    }

    if ( Windows["About"] )
    {
        RenderAboutWindow();
    }
}

} // namespace CFB::GUI::App

```

`GUI/Source/GUI.rc.in`:

```in
#include <Winver.h>

VS_VERSION_INFO     VERSIONINFO
FILEVERSION         @GUI_VERSION_MAJOR@,@GUI_VERSION_MINOR@,@GUI_VERSION_PATCH@,0
PRODUCTVERSION      @CFB_VERSION_MAJOR@,@CFB_VERSION_MINOR@,@CFB_VERSION_PATCH@,0
FILEOS              VOS_NT_WINDOWS32
FILETYPE            VFT_APP
FILESUBTYPE         VFT2_UNKNOWN

BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904E4"
        BEGIN
            VALUE "CompanyName",        "@CFB_COMPANY_NAME@\0"
            VALUE "FileDescription",    "@PROJECT_DESCRIPTION@\0"
            VALUE "FileVersion",        "@GUI_VERSION_MAJOR@,@GUI_VERSION_MINOR@,@GUI_VERSION_PATCH@,0\0"
            VALUE "LegalCopyright",     "© @CFB_CURRENT_YEAR@ @CFB_COMPANY_NAME@ Release Under @PROJECT_LICENSE@\0"
            VALUE "OriginalFilename",   "@PROJECT_NAME@.exe\0"
            VALUE "ProductName",        "@CMAKE_PROJECT_NAME@\0"
            VALUE "ProductVersion",     "@CFB_VERSION_MAJOR@,@CFB_VERSION_MINOR@,@CFB_VERSION_PATCH@,0\0"
            VALUE "Comments",           "@PROJECT_DESCRIPTION@\0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

IDI_ICON1 ICON "@CFB_GUI_ICON_PATH@"

```

`GUI/Source/GuiUtils.cpp`:

```cpp
#include "GuiUtils.hpp"

#ifdef _WIN32
#include <windows.h>
#endif

#ifdef _WIN32
std::optional<std::filesystem::path>
OpenFileWindows(std::string_view const& Filter)
{
    std::string filestr;
    filestr.resize(MAX_PATH);

    OPENFILENAMEA ofn {};
    ofn.lStructSize  = sizeof(OPENFILENAME);
    ofn.hwndOwner    = ::GetActiveWindow();
    ofn.lpstrFile    = filestr.data();
    ofn.nMaxFile     = filestr.size();
    ofn.lpstrFilter  = Filter.data();
    ofn.nFilterIndex = 1;
    ofn.Flags        = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_NOCHANGEDIR;

    if ( ::GetOpenFileNameA(&ofn) != TRUE )
    {
        return std::nullopt;
    }
    filestr.resize(::strlen(ofn.lpstrFile));
    return std::filesystem::path(filestr);
}

std::optional<std::filesystem::path>
SaveFileWindows(std::string_view const& Filter)
{
    std::string filestr;
    filestr.resize(MAX_PATH);

    OPENFILENAMEA ofn {};
    ofn.lStructSize  = sizeof(OPENFILENAME);
    ofn.hwndOwner    = ::GetActiveWindow();
    ofn.lpstrFile    = filestr.data();
    ofn.nMaxFile     = filestr.size();
    ofn.lpstrFilter  = Filter.data();
    ofn.nFilterIndex = 1;
    ofn.Flags        = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_NOCHANGEDIR;
    if ( ::GetSaveFileNameA(&ofn) != TRUE )
    {
        return std::nullopt;
    }
    filestr.resize(::strlen(ofn.lpstrFile));
    return std::filesystem::path(filestr);
}
#endif // _WIN32

namespace CFB::GUI::Utils
{

std::optional<std::filesystem::path>
FileManager::OpenFile(std::string_view const& Filter)
{
#ifdef _WIN32
    return OpenFileWindows(Filter);
#else
    return std::nullopt;
#endif
}


std::optional<std::filesystem::path>
FileManager::SaveFile(std::string_view const& Filter)
{
#ifdef _WIN32
    return SaveFileWindows(Filter);
#else
    return std::nullopt;
#endif
}


} // namespace CFB::GUI::Utils

```

`GUI/Source/Helpers.cpp`:

```cpp
#include "Helpers.hpp"

#include <cmath>

#include "imgui_internal.h"

bool
CFB::GUI::Helpers::ToggleButton(const char* str_id, bool* v)
{
    bool item_is_clicked  = false;
    ImVec2 p              = ImGui::GetCursorScreenPos();
    ImDrawList* draw_list = ImGui::GetWindowDrawList();

    float height = ImGui::GetFrameHeight();
    float width  = height * 1.55f;
    float radius = height * 0.50f;

    ImGui::InvisibleButton(str_id, ImVec2(width, height));
    if ( ImGui::IsItemClicked() )
    {
        *v              = !*v;
        item_is_clicked = true;
    }

    float t = *v ? 1.0f : 0.0f;

    ImGuiContext& g  = *GImGui;
    float ANIM_SPEED = 0.08f;
    if ( g.LastActiveId == g.CurrentWindow->GetID(str_id) ) // && g.LastActiveIdTimer < ANIM_SPEED)
    {
        float t_anim = ImSaturate(g.LastActiveIdTimer / ANIM_SPEED);
        t            = *v ? (t_anim) : (1.0f - t_anim);
    }

    ImU32 col_bg;
    if ( ImGui::IsItemHovered() )
        col_bg = ImGui::GetColorU32(ImLerp(ImVec4(0.78f, 0.78f, 0.78f, 1.0f), ImVec4(0.64f, 0.83f, 0.34f, 1.0f), t));
    else
        col_bg = ImGui::GetColorU32(ImLerp(ImVec4(0.85f, 0.85f, 0.85f, 1.0f), ImVec4(0.56f, 0.83f, 0.26f, 1.0f), t));

    draw_list->AddRectFilled(p, ImVec2(p.x + width, p.y + height), col_bg, height * 0.5f);
    draw_list->AddCircleFilled(
        ImVec2(p.x + radius + t * (width - radius * 2.0f), p.y + radius),
        radius - 1.5f,
        IM_COL32(255, 255, 255, 255));

    return item_is_clicked;
}


bool
CFB::GUI::Helpers::BufferingBar(
    const char* label,
    float value,
    const ImVec2& size_arg,
    const ImU32& bg_col,
    const ImU32& fg_col)
{
    ImGuiWindow* window = ImGui::GetCurrentWindow();
    if ( window->SkipItems )
        return false;

    ImGuiContext& g         = *GImGui;
    const ImGuiStyle& style = g.Style;
    const ImGuiID id        = window->GetID(label);

    ImVec2 pos  = window->DC.CursorPos;
    ImVec2 size = size_arg;
    size.x -= style.FramePadding.x * 2;

    const ImRect bb(pos, ImVec2(pos.x + size.x, pos.y + size.y));
    ImGui::ItemSize(bb, style.FramePadding.y);
    if ( !ImGui::ItemAdd(bb, id) )
        return false;

    // Render
    const float circleStart = size.x * 0.7f;
    const float circleEnd   = size.x;
    const float circleWidth = circleEnd - circleStart;

    window->DrawList->AddRectFilled(bb.Min, ImVec2(pos.x + circleStart, bb.Max.y), bg_col);
    window->DrawList->AddRectFilled(bb.Min, ImVec2(pos.x + circleStart * value, bb.Max.y), fg_col);

    const float t     = g.Time;
    const float r     = size.y / 2;
    const float speed = 1.5f;

    const float a = speed * 0;
    const float b = speed * 0.333f;
    const float c = speed * 0.666f;

    const float o1 = (circleWidth + r) * (t + a - speed * (int)((t + a) / speed)) / speed;
    const float o2 = (circleWidth + r) * (t + b - speed * (int)((t + b) / speed)) / speed;
    const float o3 = (circleWidth + r) * (t + c - speed * (int)((t + c) / speed)) / speed;

    window->DrawList->AddCircleFilled(ImVec2(pos.x + circleEnd - o1, bb.Min.y + r), r, bg_col);
    window->DrawList->AddCircleFilled(ImVec2(pos.x + circleEnd - o2, bb.Min.y + r), r, bg_col);
    window->DrawList->AddCircleFilled(ImVec2(pos.x + circleEnd - o3, bb.Min.y + r), r, bg_col);

    return true;
}

bool
CFB::GUI::Helpers::Spinner(const char* label, float radius, int thickness, const ImU32& color)
{
    ImGuiWindow* window = ImGui::GetCurrentWindow();
    if ( window->SkipItems )
        return false;

    ImGuiContext& g         = *GImGui;
    const ImGuiStyle& style = g.Style;
    const ImGuiID id        = window->GetID(label);

    ImVec2 pos = window->DC.CursorPos;
    ImVec2 size((radius)*2, (radius + style.FramePadding.y) * 2);

    const ImRect bb(pos, ImVec2(pos.x + size.x, pos.y + size.y));
    ImGui::ItemSize(bb, style.FramePadding.y);
    if ( !ImGui::ItemAdd(bb, id) )
        return false;

    // Render
    window->DrawList->PathClear();

    int num_segments = 30;
    int start        = std::abs(ImSin(g.Time * 1.8f) * (num_segments - 5));

    const float a_min = IM_PI * 2.0f * ((float)start) / (float)num_segments;
    const float a_max = IM_PI * 2.0f * ((float)num_segments - 3) / (float)num_segments;

    const ImVec2 centre = ImVec2(pos.x + radius, pos.y + radius + style.FramePadding.y);

    for ( int i = 0; i < num_segments; i++ )
    {
        const float a = a_min + ((float)i / (float)num_segments) * (a_max - a_min);
        window->DrawList->PathLineTo(
            ImVec2(centre.x + ImCos(a + g.Time * 8) * radius, centre.y + ImSin(a + g.Time * 8) * radius));
    }

    window->DrawList->PathStroke(color, false, thickness);

    return true;
}

```

`GUI/Source/main.cpp`:

```cpp
// Dear ImGui: standalone example application for DirectX 12
// If you are new to Dear ImGui, read documentation from the docs/ folder + read the top of imgui.cpp.
// Read online: https://github.com/ocornut/imgui/tree/master/docs

// Important: to compile on 32-bit systems, the DirectX12 backend requires code to be compiled with '#define ImTextureID
// ImU64'. This is because we need ImTextureID to carry a 64-bit value and by default ImTextureID is defined as void*.
// This define is set in the example .vcxproj file and need to be replicated in your app or by adding it to your
// imconfig.h file.

#include <d3d12.h>
#include <dxgi1_4.h>
#include <tchar.h>

// clang-format off
#include <imgui.h>
#include <imgui_impl_dx12.h>
#include <imgui_impl_win32.h>

#include "CompileInfo.hpp"
#include "App.hpp"
// clang-format on


#ifdef _DEBUG
#define DX12_ENABLE_DEBUG_LAYER
#endif

#ifdef DX12_ENABLE_DEBUG_LAYER
#include <dxgidebug.h>
#pragma comment(lib, "dxguid.lib")
#endif

struct FrameContext
{
    ID3D12CommandAllocator* CommandAllocator;
    UINT64 FenceValue;
};

// Data
static int const NUM_FRAMES_IN_FLIGHT                    = 3;
static FrameContext g_frameContext[NUM_FRAMES_IN_FLIGHT] = {};
static UINT g_frameIndex                                 = 0;

static int const NUM_BACK_BUFFERS                                                 = 3;
static ID3D12Device* g_pd3dDevice                                                 = NULL;
static ID3D12DescriptorHeap* g_pd3dRtvDescHeap                                    = NULL;
static ID3D12DescriptorHeap* g_pd3dSrvDescHeap                                    = NULL;
static ID3D12CommandQueue* g_pd3dCommandQueue                                     = NULL;
static ID3D12GraphicsCommandList* g_pd3dCommandList                               = NULL;
static ID3D12Fence* g_fence                                                       = NULL;
static HANDLE g_fenceEvent                                                        = NULL;
static UINT64 g_fenceLastSignaledValue                                            = 0;
static IDXGISwapChain3* g_pSwapChain                                              = NULL;
static HANDLE g_hSwapChainWaitableObject                                          = NULL;
static ID3D12Resource* g_mainRenderTargetResource[NUM_BACK_BUFFERS]               = {};
static D3D12_CPU_DESCRIPTOR_HANDLE g_mainRenderTargetDescriptor[NUM_BACK_BUFFERS] = {};

// Forward declarations of helper functions
bool
CreateDeviceD3D(HWND hWnd);
void
CleanupDeviceD3D();
void
CreateRenderTarget();
void
CleanupRenderTarget();
void
WaitForLastSubmittedFrame();
FrameContext*
WaitForNextFrameResources();
LRESULT WINAPI
WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

const static wchar_t* g_ClassName   = WIDECHAR2(PROJECT_NAME);
const static wchar_t* g_WindowTitle = WIDECHAR2(PROJECT_NAME " (GUI version " GUI_VERSION ")");

int
RunImGuiApp()
{
    // Create application window
    ImGui_ImplWin32_EnableDpiAwareness();
    WNDCLASSEXW wc = {
        sizeof(wc),
        CS_CLASSDC,
        WndProc,
        0L,
        0L,
        GetModuleHandle(nullptr),
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        g_ClassName,
        nullptr};
    wc.hIcon   = ::LoadIconW(nullptr, L"IDI_ICON1");
    wc.hIconSm = ::LoadIconW(nullptr, L"IDI_ICON1");

    ::RegisterClassExW(&wc);
    HWND hwnd = ::CreateWindowW(
        wc.lpszClassName,
        g_WindowTitle,
        WS_OVERLAPPEDWINDOW,
        100,
        100,
        1280,
        800,
        nullptr,
        nullptr,
        wc.hInstance,
        nullptr);

    // Initialize Direct3D
    if ( !CreateDeviceD3D(hwnd) )
    {
        CleanupDeviceD3D();
        ::UnregisterClassW(wc.lpszClassName, wc.hInstance);
        return 1;
    }

    // Show the window
    ::ShowWindow(hwnd, SW_SHOWDEFAULT);
    ::UpdateWindow(hwnd);

    // Setup Dear ImGui context
    IMGUI_CHECKVERSION();
    ImGui::CreateContext();
    ImGuiIO& io = ImGui::GetIO();
    (void)io;
    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard; // Enable Keyboard Controls
    // io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad;      // Enable Gamepad Controls
    io.ConfigFlags |= ImGuiConfigFlags_DockingEnable; // Enable docking

    // Setup Dear ImGui style
    ImGui::StyleColorsDark();
    // ImGui::StyleColorsLight();

    // Setup Platform/Renderer backends
    ImGui_ImplWin32_Init(hwnd);
    ImGui_ImplDX12_Init(
        g_pd3dDevice,
        NUM_FRAMES_IN_FLIGHT,
        DXGI_FORMAT_R8G8B8A8_UNORM,
        g_pd3dSrvDescHeap,
        g_pd3dSrvDescHeap->GetCPUDescriptorHandleForHeapStart(),
        g_pd3dSrvDescHeap->GetGPUDescriptorHandleForHeapStart());

    // Load Fonts
    // - If no fonts are loaded, dear imgui will use the default font. You can also load multiple fonts and use
    // ImGui::PushFont()/PopFont() to select them.
    // - AddFontFromFileTTF() will return the ImFont* so you can store it if you need to select the font among multiple.
    // - If the file cannot be loaded, the function will return NULL. Please handle those errors in your application
    // (e.g. use an assertion, or display an error and quit).
    // - The fonts will be rasterized at a given size (w/ oversampling) and stored into a texture when calling
    // ImFontAtlas::Build()/GetTexDataAsXXXX(), which ImGui_ImplXXXX_NewFrame below will call.
    // - Use '#define IMGUI_ENABLE_FREETYPE' in your imconfig file to use Freetype for higher quality font rendering.
    // - Read 'docs/FONTS.md' for more instructions and details.
    // - Remember that in C/C++ if you want to include a backslash \ in a string literal you need to write a double
    // backslash \\ !
    // io.Fonts->AddFontDefault();
    // io.Fonts->AddFontFromFileTTF("../../misc/fonts/DroidSans.ttf", 16.0f);
    // io.Fonts->AddFontFromFileTTF("../../misc/fonts/Cousine-Regular.ttf", 15.0f);
    // ImFont* font = io.Fonts->AddFontFromFileTTF("c:\\Windows\\Fonts\\ArialUni.ttf", 18.0f, NULL,
    // io.Fonts->GetGlyphRangesJapanese()); IM_ASSERT(font != NULL);

    io.Fonts->AddFontFromFileTTF(CFB::GUI::App::Globals.SelectedFontPath.c_str(), CFB::GUI::App::Globals.FontSize);

    // Our state
    ImVec4 clear_color = ImVec4(0.45f, 0.55f, 0.60f, 1.00f);

    // Main loop

    while ( CFB::GUI::App::Globals.KeepRunning )
    {
        // Poll and handle messages (inputs, window resize, etc.)
        // See the WndProc() function below for our to dispatch events to the Win32 backend.
        MSG msg;
        while ( ::PeekMessageW(&msg, NULL, 0U, 0U, PM_REMOVE) )
        {
            ::TranslateMessage(&msg);
            ::DispatchMessageW(&msg);
            if ( msg.message == WM_QUIT )
            {
                CFB::GUI::App::Globals.KeepRunning = false;
            }
        }

        if ( !CFB::GUI::App::Globals.KeepRunning )
        {
            break;
        }

        // Start the Dear ImGui frame
        ImGui_ImplDX12_NewFrame();
        ImGui_ImplWin32_NewFrame();
        ImGui::NewFrame();

        // My code
        CFB::GUI::App::RenderUI();

        // Rendering
        ImGui::Render();

        FrameContext* frameCtx = WaitForNextFrameResources();
        UINT backBufferIdx     = g_pSwapChain->GetCurrentBackBufferIndex();
        frameCtx->CommandAllocator->Reset();

        D3D12_RESOURCE_BARRIER barrier = {};
        barrier.Type                   = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
        barrier.Flags                  = D3D12_RESOURCE_BARRIER_FLAG_NONE;
        barrier.Transition.pResource   = g_mainRenderTargetResource[backBufferIdx];
        barrier.Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;
        barrier.Transition.StateBefore = D3D12_RESOURCE_STATE_PRESENT;
        barrier.Transition.StateAfter  = D3D12_RESOURCE_STATE_RENDER_TARGET;
        g_pd3dCommandList->Reset(frameCtx->CommandAllocator, NULL);
        g_pd3dCommandList->ResourceBarrier(1, &barrier);

        // Render Dear ImGui graphics
        const float clear_color_with_alpha[4] = {
            clear_color.x * clear_color.w,
            clear_color.y * clear_color.w,
            clear_color.z * clear_color.w,
            clear_color.w};
        g_pd3dCommandList
            ->ClearRenderTargetView(g_mainRenderTargetDescriptor[backBufferIdx], clear_color_with_alpha, 0, NULL);
        g_pd3dCommandList->OMSetRenderTargets(1, &g_mainRenderTargetDescriptor[backBufferIdx], FALSE, NULL);
        g_pd3dCommandList->SetDescriptorHeaps(1, &g_pd3dSrvDescHeap);
        ImGui_ImplDX12_RenderDrawData(ImGui::GetDrawData(), g_pd3dCommandList);
        barrier.Transition.StateBefore = D3D12_RESOURCE_STATE_RENDER_TARGET;
        barrier.Transition.StateAfter  = D3D12_RESOURCE_STATE_PRESENT;
        g_pd3dCommandList->ResourceBarrier(1, &barrier);
        g_pd3dCommandList->Close();

        g_pd3dCommandQueue->ExecuteCommandLists(1, (ID3D12CommandList* const*)&g_pd3dCommandList);

        g_pSwapChain->Present(1, 0); // Present with vsync
        // g_pSwapChain->Present(0, 0); // Present without vsync

        UINT64 fenceValue = g_fenceLastSignaledValue + 1;
        g_pd3dCommandQueue->Signal(g_fence, fenceValue);
        g_fenceLastSignaledValue = fenceValue;
        frameCtx->FenceValue     = fenceValue;
    }

    WaitForLastSubmittedFrame();

    // Cleanup
    ImGui_ImplDX12_Shutdown();
    ImGui_ImplWin32_Shutdown();
    ImGui::DestroyContext();

    CleanupDeviceD3D();
    ::DestroyWindow(hwnd);
    ::UnregisterClassW(wc.lpszClassName, wc.hInstance);

    return 0;
}

extern CFB::GUI::App::Context CFB::GUI::App::Globals;

// Main code
int WINAPI
wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PWSTR pCmdLine, int nCmdShow)
{
    while ( true )
    {
        CFB::GUI::App::Globals.Restart = false;
        RunImGuiApp();
        if ( CFB::GUI::App::Globals.Restart == false )
        {
            break;
        }
    }
    return 0;
}

// Helper functions

bool
CreateDeviceD3D(HWND hWnd)
{
    // Setup swap chain
    DXGI_SWAP_CHAIN_DESC1 sd;
    {
        ZeroMemory(&sd, sizeof(sd));
        sd.BufferCount        = NUM_BACK_BUFFERS;
        sd.Width              = 0;
        sd.Height             = 0;
        sd.Format             = DXGI_FORMAT_R8G8B8A8_UNORM;
        sd.Flags              = DXGI_SWAP_CHAIN_FLAG_FRAME_LATENCY_WAITABLE_OBJECT;
        sd.BufferUsage        = DXGI_USAGE_RENDER_TARGET_OUTPUT;
        sd.SampleDesc.Count   = 1;
        sd.SampleDesc.Quality = 0;
        sd.SwapEffect         = DXGI_SWAP_EFFECT_FLIP_DISCARD;
        sd.AlphaMode          = DXGI_ALPHA_MODE_UNSPECIFIED;
        sd.Scaling            = DXGI_SCALING_STRETCH;
        sd.Stereo             = FALSE;
    }

    // [DEBUG] Enable debug interface
#ifdef DX12_ENABLE_DEBUG_LAYER
    ID3D12Debug* pdx12Debug = NULL;
    if ( SUCCEEDED(D3D12GetDebugInterface(IID_PPV_ARGS(&pdx12Debug))) )
        pdx12Debug->EnableDebugLayer();
#endif

    // Create device
    D3D_FEATURE_LEVEL featureLevel = D3D_FEATURE_LEVEL_11_0;
    if ( D3D12CreateDevice(NULL, featureLevel, IID_PPV_ARGS(&g_pd3dDevice)) != S_OK )
        return false;

        // [DEBUG] Setup debug interface to break on any warnings/errors
#ifdef DX12_ENABLE_DEBUG_LAYER
    if ( pdx12Debug != NULL )
    {
        ID3D12InfoQueue* pInfoQueue = NULL;
        g_pd3dDevice->QueryInterface(IID_PPV_ARGS(&pInfoQueue));
        pInfoQueue->SetBreakOnSeverity(D3D12_MESSAGE_SEVERITY_ERROR, true);
        pInfoQueue->SetBreakOnSeverity(D3D12_MESSAGE_SEVERITY_CORRUPTION, true);
        pInfoQueue->SetBreakOnSeverity(D3D12_MESSAGE_SEVERITY_WARNING, true);
        pInfoQueue->Release();
        pdx12Debug->Release();
    }
#endif

    {
        D3D12_DESCRIPTOR_HEAP_DESC desc = {};
        desc.Type                       = D3D12_DESCRIPTOR_HEAP_TYPE_RTV;
        desc.NumDescriptors             = NUM_BACK_BUFFERS;
        desc.Flags                      = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;
        desc.NodeMask                   = 1;
        if ( g_pd3dDevice->CreateDescriptorHeap(&desc, IID_PPV_ARGS(&g_pd3dRtvDescHeap)) != S_OK )
            return false;

        SIZE_T rtvDescriptorSize = g_pd3dDevice->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV);
        D3D12_CPU_DESCRIPTOR_HANDLE rtvHandle = g_pd3dRtvDescHeap->GetCPUDescriptorHandleForHeapStart();
        for ( UINT i = 0; i < NUM_BACK_BUFFERS; i++ )
        {
            g_mainRenderTargetDescriptor[i] = rtvHandle;
            rtvHandle.ptr += rtvDescriptorSize;
        }
    }

    {
        D3D12_DESCRIPTOR_HEAP_DESC desc = {};
        desc.Type                       = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
        desc.NumDescriptors             = 1;
        desc.Flags                      = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;
        if ( g_pd3dDevice->CreateDescriptorHeap(&desc, IID_PPV_ARGS(&g_pd3dSrvDescHeap)) != S_OK )
            return false;
    }

    {
        D3D12_COMMAND_QUEUE_DESC desc = {};
        desc.Type                     = D3D12_COMMAND_LIST_TYPE_DIRECT;
        desc.Flags                    = D3D12_COMMAND_QUEUE_FLAG_NONE;
        desc.NodeMask                 = 1;
        if ( g_pd3dDevice->CreateCommandQueue(&desc, IID_PPV_ARGS(&g_pd3dCommandQueue)) != S_OK )
            return false;
    }

    for ( UINT i = 0; i < NUM_FRAMES_IN_FLIGHT; i++ )
        if ( g_pd3dDevice->CreateCommandAllocator(
                 D3D12_COMMAND_LIST_TYPE_DIRECT,
                 IID_PPV_ARGS(&g_frameContext[i].CommandAllocator)) != S_OK )
            return false;

    if ( g_pd3dDevice->CreateCommandList(
             0,
             D3D12_COMMAND_LIST_TYPE_DIRECT,
             g_frameContext[0].CommandAllocator,
             NULL,
             IID_PPV_ARGS(&g_pd3dCommandList)) != S_OK ||
         g_pd3dCommandList->Close() != S_OK )
        return false;

    if ( g_pd3dDevice->CreateFence(0, D3D12_FENCE_FLAG_NONE, IID_PPV_ARGS(&g_fence)) != S_OK )
        return false;

    g_fenceEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if ( g_fenceEvent == NULL )
        return false;

    {
        IDXGIFactory4* dxgiFactory  = NULL;
        IDXGISwapChain1* swapChain1 = NULL;
        if ( CreateDXGIFactory1(IID_PPV_ARGS(&dxgiFactory)) != S_OK )
            return false;
        if ( dxgiFactory->CreateSwapChainForHwnd(g_pd3dCommandQueue, hWnd, &sd, NULL, NULL, &swapChain1) != S_OK )
            return false;
        if ( swapChain1->QueryInterface(IID_PPV_ARGS(&g_pSwapChain)) != S_OK )
            return false;
        swapChain1->Release();
        dxgiFactory->Release();
        g_pSwapChain->SetMaximumFrameLatency(NUM_BACK_BUFFERS);
        g_hSwapChainWaitableObject = g_pSwapChain->GetFrameLatencyWaitableObject();
    }

    CreateRenderTarget();
    return true;
}

void
CleanupDeviceD3D()
{
    CleanupRenderTarget();
    if ( g_pSwapChain )
    {
        g_pSwapChain->SetFullscreenState(false, NULL);
        g_pSwapChain->Release();
        g_pSwapChain = NULL;
    }
    if ( g_hSwapChainWaitableObject != NULL )
    {
        CloseHandle(g_hSwapChainWaitableObject);
    }
    for ( UINT i = 0; i < NUM_FRAMES_IN_FLIGHT; i++ )
        if ( g_frameContext[i].CommandAllocator )
        {
            g_frameContext[i].CommandAllocator->Release();
            g_frameContext[i].CommandAllocator = NULL;
        }
    if ( g_pd3dCommandQueue )
    {
        g_pd3dCommandQueue->Release();
        g_pd3dCommandQueue = NULL;
    }
    if ( g_pd3dCommandList )
    {
        g_pd3dCommandList->Release();
        g_pd3dCommandList = NULL;
    }
    if ( g_pd3dRtvDescHeap )
    {
        g_pd3dRtvDescHeap->Release();
        g_pd3dRtvDescHeap = NULL;
    }
    if ( g_pd3dSrvDescHeap )
    {
        g_pd3dSrvDescHeap->Release();
        g_pd3dSrvDescHeap = NULL;
    }
    if ( g_fence )
    {
        g_fence->Release();
        g_fence = NULL;
    }
    if ( g_fenceEvent )
    {
        CloseHandle(g_fenceEvent);
        g_fenceEvent = NULL;
    }
    if ( g_pd3dDevice )
    {
        g_pd3dDevice->Release();
        g_pd3dDevice = NULL;
    }

#ifdef DX12_ENABLE_DEBUG_LAYER
    IDXGIDebug1* pDebug = NULL;
    if ( SUCCEEDED(DXGIGetDebugInterface1(0, IID_PPV_ARGS(&pDebug))) )
    {
        pDebug->ReportLiveObjects(DXGI_DEBUG_ALL, DXGI_DEBUG_RLO_SUMMARY);
        pDebug->Release();
    }
#endif
}

void
CreateRenderTarget()
{
    for ( UINT i = 0; i < NUM_BACK_BUFFERS; i++ )
    {
        ID3D12Resource* pBackBuffer = NULL;
        g_pSwapChain->GetBuffer(i, IID_PPV_ARGS(&pBackBuffer));
        g_pd3dDevice->CreateRenderTargetView(pBackBuffer, NULL, g_mainRenderTargetDescriptor[i]);
        g_mainRenderTargetResource[i] = pBackBuffer;
    }
}

void
CleanupRenderTarget()
{
    WaitForLastSubmittedFrame();

    for ( UINT i = 0; i < NUM_BACK_BUFFERS; i++ )
        if ( g_mainRenderTargetResource[i] )
        {
            g_mainRenderTargetResource[i]->Release();
            g_mainRenderTargetResource[i] = NULL;
        }
}

void
WaitForLastSubmittedFrame()
{
    FrameContext* frameCtx = &g_frameContext[g_frameIndex % NUM_FRAMES_IN_FLIGHT];

    UINT64 fenceValue = frameCtx->FenceValue;
    if ( fenceValue == 0 )
        return; // No fence was signaled

    frameCtx->FenceValue = 0;
    if ( g_fence->GetCompletedValue() >= fenceValue )
        return;

    g_fence->SetEventOnCompletion(fenceValue, g_fenceEvent);
    WaitForSingleObject(g_fenceEvent, INFINITE);
}

FrameContext*
WaitForNextFrameResources()
{
    UINT nextFrameIndex = g_frameIndex + 1;
    g_frameIndex        = nextFrameIndex;

    HANDLE waitableObjects[] = {g_hSwapChainWaitableObject, NULL};
    DWORD numWaitableObjects = 1;

    FrameContext* frameCtx = &g_frameContext[nextFrameIndex % NUM_FRAMES_IN_FLIGHT];
    UINT64 fenceValue      = frameCtx->FenceValue;
    if ( fenceValue != 0 ) // means no fence was signaled
    {
        frameCtx->FenceValue = 0;
        g_fence->SetEventOnCompletion(fenceValue, g_fenceEvent);
        waitableObjects[1] = g_fenceEvent;
        numWaitableObjects = 2;
    }

    WaitForMultipleObjects(numWaitableObjects, waitableObjects, TRUE, INFINITE);

    return frameCtx;
}

// Forward declare message handler from imgui_impl_win32.cpp
extern IMGUI_IMPL_API LRESULT
ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

// Win32 message handler
// You can read the io.WantCaptureMouse, io.WantCaptureKeyboard flags to tell if dear imgui wants to use your inputs.
// - When io.WantCaptureMouse is true, do not dispatch mouse input data to your main application, or clear/overwrite
// your copy of the mouse data.
// - When io.WantCaptureKeyboard is true, do not dispatch keyboard input data to your main application, or
// clear/overwrite your copy of the keyboard data. Generally you may always pass all inputs to dear imgui, and hide them
// from your application based on those two flags.
LRESULT WINAPI
WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    if ( ImGui_ImplWin32_WndProcHandler(hWnd, msg, wParam, lParam) )
        return true;

    switch ( msg )
    {
    case WM_SIZE:
        if ( g_pd3dDevice != NULL && wParam != SIZE_MINIMIZED )
        {
            WaitForLastSubmittedFrame();
            CleanupRenderTarget();
            HRESULT result = g_pSwapChain->ResizeBuffers(
                0,
                (UINT)LOWORD(lParam),
                (UINT)HIWORD(lParam),
                DXGI_FORMAT_UNKNOWN,
                DXGI_SWAP_CHAIN_FLAG_FRAME_LATENCY_WAITABLE_OBJECT);
            assert(SUCCEEDED(result) && "Failed to resize swapchain.");
            CreateRenderTarget();
        }
        return 0;
    case WM_SYSCOMMAND:
        if ( (wParam & 0xfff0) == SC_KEYMENU ) // Disable ALT application menu
            return 0;
        break;
    case WM_DESTROY:
        ::PostQuitMessage(0);
        return 0;
    }
    return ::DefWindowProc(hWnd, msg, wParam, lParam);
}

```

`GUI/Tests/CMakeLists.txt`:

```txt
message(STATUS "Configuring tests for 'GUI'")

enable_testing()

set(GUI_HEADERS_DIR ${CFB_ROOT_DIR}/GUI/Headers)
set(GUI_TEST_DIR ${CFB_ROOT_DIR}/GUI/Tests)

list(APPEND TEST_SET
)

foreach(TEST_FILE ${TEST_SET})
    set(FILEPATH "${GUI_TEST_DIR}/${TEST_FILE}.cpp")
    set(TARGET_NAME Tests_Gui_${TEST_FILE})
    add_executable(${TARGET_NAME} WIN32 ${FILEPATH})
    list(APPEND ALL_GUI_TESTS ${TARGET_NAME})
    add_dependencies(${TARGET_NAME} CFB::User::Gui)
    set_target_properties(${TARGET_NAME} PROPERTIES CXX_STANDARD 20)
    target_compile_features(${TARGET_NAME} PUBLIC cxx_std_20)
    target_include_directories(${TARGET_NAME} PUBLIC ${GUI_HEADERS_DIR})
    target_compile_definitions(${TARGET_NAME} PRIVATE CATCH_CONFIG_NO_WINDOWS_SEH)
    target_compile_options(${TARGET_NAME} PRIVATE $<TARGET_PROPERTY:CFB::User::CommonLib,COMPILE_OPTIONS>)
    target_link_libraries(${TARGET_NAME} PRIVATE Catch2::Catch2 Catch2::Catch2WithMain imgui::imgui)
    target_link_options(${TARGET_NAME} PRIVATE /SUBSYSTEM:Console $<TARGET_PROPERTY:CFB::User::CommonLib,LINK_OPTIONS>)
    add_test(NAME ${TARGET_NAME} COMMAND $<TARGET_FILE:${TARGET_NAME}>)
    install(TARGETS ${TARGET_NAME} DESTINATION Tests/GUI)
    install(FILES $<TARGET_PDB_FILE:${TARGET_NAME}> DESTINATION Tests/GUI OPTIONAL)
endforeach()

add_custom_target(
    Tests_Gui
    DEPENDS ${ALL_GUI_TESTS}
    COMMAND ${CMAKE_CTEST_COMMAND} -R Tests_Gui
)

```

`README.md`:

```md

<p align="center">
  <img src="https://user-images.githubusercontent.com/590234/185767386-46d86e9e-be54-480e-9d18-308b6e028fce.png" width="300px" alt="logo" />
</p>

<p align="center">
  <a href="https://github.com/hugsy/CFB/actions/workflows/build.yml"><img alt="Build main" src="https://github.com/hugsy/CFB/actions/workflows/build.yml/badge.svg?branch=main"/></a>
  <a href="https://github.com/hugsy/CFB/actions/workflows/build.yml"><img alt="Build dev" src="https://github.com/hugsy/CFB/actions/workflows/build.yml/badge.svg?branch=dev"/></a>
  <a href="https://discord.gg/ey49tNQg"><img alt="Discord" src="https://img.shields.io/badge/Discord-CFB-purple"></a>
</p>

## What is it?

> [!CAUTION]
> CFB is meant for research and debug purposes, it should never be used on production systems. Also BSoD may happen. You've been warned.

**Canadian Furious Beaver** is a [`ProcMon`](https://learn.microsoft.com/en-us/sysinternals/downloads/procmon)-style tool designed only for capturing IRPs sent to any Windows driver. It operates in 2 parts:

1. the "Broker" combines both a user-land agent and a self-extractable driver (`IrpMonitor.sys`) that will install itself on the targeted system. After installing the driver, the broker will expose a TCP port listening (by default, on TCP/1337) and start collecting IRP from hooked drivers. The communication protocol was made to be simple by design (i.e. not secure) allowing any [3rd party tool](https://github.com/hugsy/cfb-cli) to dump the driver IRPs from the same Broker easily (via simple JSON messages).

2. the clients can connect to the broker, and will receive IRPs as a JSON message making it easy to view, or convert to another format.

![GUI](https://i.imgur.com/MUFYrL2.png)

![CLI](https://i.imgur.com/5MWjqLa.png)

3. IRPs (metadata, input/output buffers) can be stored to file on disk in the JSON format allowing for easy further scripting.

> [!WARNING]
> Although the CFB driver (`IrpMonitor.sys`) should not violate patchguard, it however is only self-signed and so requires [`TestSigning`](https://learn.microsoft.com/en-us/windows-hardware/drivers/install/the-testsigning-boot-configuration-option) enabled in the BCD

## Why the name?

Because I had no idea for the name of this tool, so it was graciously generated by [a script of mine](https://github.com/hugsy/stuff/tree/master/random-word).

## Kudos

 * `processhacker` for their [`phnt` header files](https://github.com/processhacker/phnt)
 * `nlohmann` for their [`json` library](https://github.com/nlohmann/json)

```

`cmake/FindArgparse.cmake`:

```cmake
include(FetchContent)

FetchContent_Declare(
    argparse
    URL https://github.com/p-ranav/argparse/archive/refs/tags/v3.0.zip
    URL_HASH MD5=a44c0401238e87239e31652b72fded20
)
FetchContent_MakeAvailable(argparse)
message(STATUS "Using ArgParse in '${argparse_SOURCE_DIR}'")

add_library(Deps_Argparse INTERFACE EXCLUDE_FROM_ALL)
target_compile_features(Deps_Argparse INTERFACE cxx_std_20)
target_include_directories(Deps_Argparse INTERFACE ${argparse_SOURCE_DIR}/include)
add_library(Deps::Argparse ALIAS Deps_Argparse)

```

`cmake/FindCatch2.cmake`:

```cmake
include(FetchContent)

FetchContent_Declare(
    Catch2
    URL https://github.com/catchorg/Catch2/archive/refs/tags/v3.4.0.zip
    URL_HASH MD5=c426e77d4ee0055410bc930182959ae5
)

FetchContent_MakeAvailable(Catch2)
message(STATUS "Using Catch2 in '${Catch2_SOURCE_DIR}'")
add_library(Deps::Catch2 ALIAS Catch2)

```

`cmake/FindImgui.cmake`:

```cmake
include(FetchContent)
FetchContent_Declare(
    imgui
    GIT_REPOSITORY https://github.com/ocornut/imgui.git
    GIT_TAG docking
)
FetchContent_MakeAvailable(imgui)
message(STATUS "Using ImGUI in '${imgui_SOURCE_DIR}'")
add_library(imgui
    STATIC
    ${imgui_SOURCE_DIR}/imgui.cpp
    ${imgui_SOURCE_DIR}/imgui_demo.cpp
    ${imgui_SOURCE_DIR}/imgui_draw.cpp
    ${imgui_SOURCE_DIR}/imgui_tables.cpp
    ${imgui_SOURCE_DIR}/imgui_widgets.cpp

    ${imgui_SOURCE_DIR}/backends/imgui_impl_win32.cpp
    ${imgui_SOURCE_DIR}/backends/imgui_impl_dx12.cpp
    ${imgui_SOURCE_DIR}/backends/imgui_impl_dx11.cpp

    # ${imgui_SOURCE_DIR}/backends/imgui_impl_dx10.cpp
    # ${imgui_SOURCE_DIR}/backends/imgui_impl_dx9.cpp
)
add_library(Deps::ImGUI ALIAS imgui)
target_include_directories(imgui
    PRIVATE
    ${imgui_SOURCE_DIR}
    ${imgui_SOURCE_DIR}/backends
)

```

`cmake/FindJson.cmake`:

```cmake
include(FetchContent)

FetchContent_Declare(
    nlohmann_json
    URL https://github.com/nlohmann/json/releases/download/v3.11.3/include.zip
    URL_HASH MD5=e2f46211f4cf5285412a63e8164d4ba6
)

FetchContent_MakeAvailable(nlohmann_json)
message(STATUS "Using Json in '${nlohmann_json_SOURCE_DIR}'")

add_library(nlohmann_json INTERFACE EXCLUDE_FROM_ALL)
target_include_directories(nlohmann_json INTERFACE ${nlohmann_json_SOURCE_DIR}/single_include)
add_library(Deps::JSON ALIAS nlohmann_json)

```

`cmake/FindPhNt.cmake`:

```cmake
include(FetchContent)

FetchContent_Declare(
    phnt
    GIT_REPOSITORY https://github.com/winsiderss/phnt.git
    GIT_TAG 7c1adb8a7391939dfd684f27a37e31f18d303944
)
FetchContent_MakeAvailable(phnt)
message(STATUS "Using PhNt in '${phnt_SOURCE_DIR}'")
add_library(Deps::PHNT ALIAS phnt)

```

`cmake/FindWdk.cmake`:

```cmake
# Redistribution and use is allowed under the OSI-approved 3-clause BSD license.
# Copyright (c) 2018 Sergey Podobry (sergey.podobry at gmail.com). All rights reserved.

# .rst:
# FindWDK
# ----------
#
# This module searches for the installed Windows Development Kit (WDK) and
# exposes commands for creating kernel drivers and kernel libraries.
#
# Output variables:
# - `WDK_FOUND` -- if false, do not try to use WDK
# - `WDK_ROOT` -- where WDK is installed
# - `WDK_VERSION` -- the version of the selected WDK
# - `WDK_WINVER` -- the WINVER used for kernel drivers and libraries
# (default value is `0x0601` and can be changed per target or globally)
#
# Example usage:
#
# find_package(WDK REQUIRED)
#
# wdk_add_library(KmdfCppLib STATIC KMDF 1.15
# KmdfCppLib.h
# KmdfCppLib.cpp
# )
# target_include_directories(KmdfCppLib INTERFACE .)
#
# wdk_add_driver(KmdfCppDriver KMDF 1.15
# Main.cpp
# )
# target_link_libraries(KmdfCppDriver KmdfCppLib)
#
cmake_minimum_required(VERSION 3.20)

if(DEFINED ENV{WDKContentRoot})
    file(GLOB WDK_NTDDK_FILES
        "$ENV{WDKContentRoot}/Include/*/km/ntddk.h"
    )
else()
    file(GLOB WDK_NTDDK_FILES
        "C:/Program Files*/Windows Kits/10/Include/*/km/ntddk.h"
    )
endif()

if(WDK_NTDDK_FILES)
    list(GET WDK_NTDDK_FILES -1 WDK_LATEST_NTDDK_FILE)
endif()

include(FindPackageHandleStandardArgs)
find_package_handle_standard_args(WDK REQUIRED_VARS WDK_LATEST_NTDDK_FILE)

if(NOT WDK_LATEST_NTDDK_FILE)
    return()
endif()

get_filename_component(WDK_ROOT ${WDK_LATEST_NTDDK_FILE} DIRECTORY)
get_filename_component(WDK_ROOT ${WDK_ROOT} DIRECTORY)
get_filename_component(WDK_VERSION ${WDK_ROOT} NAME)
get_filename_component(WDK_ROOT ${WDK_ROOT} DIRECTORY)
get_filename_component(WDK_ROOT ${WDK_ROOT} DIRECTORY)

message(STATUS "WDK_ROOT: " ${WDK_ROOT})
message(STATUS "WDK_VERSION: " ${WDK_VERSION})

set(WDK_WINVER "0x0601" CACHE STRING "Default WINVER for WDK targets")

set(WDK_ADDITIONAL_FLAGS_FILE "${CMAKE_CURRENT_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/wdkflags.h")
file(WRITE ${WDK_ADDITIONAL_FLAGS_FILE} "#pragma runtime_checks(\"suc\", off)")

set(WDK_COMPILE_FLAGS
    "/Zp8" # set struct alignment
    "/GF" # enable string pooling
    "/GR-" # disable RTTI
    "/Gz" # __stdcall by default
    "/kernel" # create kernel mode binary
    "/FIwarning.h" # disable warnings in WDK headers
    "/FI${WDK_ADDITIONAL_FLAGS_FILE}" # include file to disable RTC
)

set(WDK_COMPILE_DEFINITIONS "WINNT=1")
set(WDK_COMPILE_DEFINITIONS_DEBUG "MSC_NOOPT;DEPRECATE_DDK_FUNCTIONS=1;DBG=1")

if(CMAKE_GENERATOR_PLATFORM STREQUAL "win32")
    list(APPEND WDK_COMPILE_DEFINITIONS "_X86_=1;i386=1;STD_CALL")
    set(WDK_PLATFORM "x86")
elseif(CMAKE_GENERATOR_PLATFORM STREQUAL "x64")
    list(APPEND WDK_COMPILE_DEFINITIONS "_WIN64;_AMD64_;AMD64")
    set(WDK_PLATFORM "x64")
elseif(CMAKE_GENERATOR_PLATFORM STREQUAL "arm64")
    list(APPEND WDK_COMPILE_DEFINITIONS "_WIN64;_ARM64_;ARM64")
    set(WDK_COMPILE_FLAGS ${WDK_COMPILE_FLAGS} /GS-) # TODO: fixes missing symbol __security_pop_cookie, fix
    set(WDK_PLATFORM "arm64")
else()
    message(FATAL_ERROR "Unsupported architecture")
endif()

string(CONCAT WDK_LINK_FLAGS
    "/MANIFEST:NO " #
    "/DRIVER " #
    "/OPT:REF " #
    "/INCREMENTAL:NO " #
    "/OPT:ICF " #
    "/SUBSYSTEM:NATIVE " #
    "/MERGE:_TEXT=.text;_PAGE=PAGE " #
    "/NODEFAULTLIB " # do not link default CRT
    "/SECTION:INIT,d " #
    "/VERSION:10.0 " #
)

# Generate imported targets for WDK lib files
file(GLOB WDK_LIBRARIES "${WDK_ROOT}/Lib/${WDK_VERSION}/km/${WDK_PLATFORM}/*.lib")

foreach(LIBRARY IN LISTS WDK_LIBRARIES)
    get_filename_component(LIBRARY_NAME ${LIBRARY} NAME_WE)
    string(TOUPPER ${LIBRARY_NAME} LIBRARY_NAME)
    add_library(WDK::${LIBRARY_NAME} INTERFACE IMPORTED)
    set_property(TARGET WDK::${LIBRARY_NAME} PROPERTY INTERFACE_LINK_LIBRARIES ${LIBRARY})
endforeach(LIBRARY)

unset(WDK_LIBRARIES)

function(wdk_add_driver _target)
    cmake_parse_arguments(WDK "" "KMDF;WINVER" "" ${ARGN})

    add_executable(${_target} ${WDK_UNPARSED_ARGUMENTS})

    set_target_properties(${_target} PROPERTIES SUFFIX ".sys")
    set_target_properties(${_target} PROPERTIES COMPILE_OPTIONS "${WDK_COMPILE_FLAGS}")
    set_target_properties(${_target} PROPERTIES COMPILE_DEFINITIONS
        "${WDK_COMPILE_DEFINITIONS};$<$<CONFIG:Debug>:${WDK_COMPILE_DEFINITIONS_DEBUG}>;_WIN32_WINNT=${WDK_WINVER}"
    )
    set_target_properties(${_target} PROPERTIES LINK_FLAGS "${WDK_LINK_FLAGS}")

    target_include_directories(${_target} SYSTEM PRIVATE
        "${WDK_ROOT}/Include/${WDK_VERSION}/shared"
        "${WDK_ROOT}/Include/${WDK_VERSION}/km"
        "${WDK_ROOT}/Include/${WDK_VERSION}/km/crt"
    )

    target_link_libraries(${_target}
        WDK::NTOSKRNL
        WDK::HAL
        WDK::WMILIB

        $<$<STREQUAL:${CMAKE_GENERATOR_PLATFORM},arm64>:WDK::BUFFEROVERFLOWFASTFAILK>
        $<$<STREQUAL:${CMAKE_GENERATOR_PLATFORM},x64>:WDK::BUFFEROVERFLOWK>
        $<$<STREQUAL:${CMAKE_GENERATOR_PLATFORM},win32>:WDK::BUFFEROVERFLOWK WDK::MEMCMP>
    )

    if(DEFINED WDK_KMDF)
        target_include_directories(${_target} SYSTEM PRIVATE "${WDK_ROOT}/Include/wdf/kmdf/${WDK_KMDF}")
        target_link_libraries(${_target}
            "${WDK_ROOT}/Lib/wdf/kmdf/${WDK_PLATFORM}/${WDK_KMDF}/WdfDriverEntry.lib"
            "${WDK_ROOT}/Lib/wdf/kmdf/${WDK_PLATFORM}/${WDK_KMDF}/WdfLdr.lib"
        )

        if(CMAKE_SIZEOF_VOID_P EQUAL 4)
            set_property(TARGET ${_target} APPEND_STRING PROPERTY LINK_FLAGS "/ENTRY:FxDriverEntry@8")
        elseif(CMAKE_SIZEOF_VOID_P EQUAL 8)
            set_property(TARGET ${_target} APPEND_STRING PROPERTY LINK_FLAGS "/ENTRY:FxDriverEntry")
        endif()
    else()
        if(CMAKE_SIZEOF_VOID_P EQUAL 4)
            set_property(TARGET ${_target} APPEND_STRING PROPERTY LINK_FLAGS "/ENTRY:GsDriverEntry@8")
        elseif(CMAKE_SIZEOF_VOID_P EQUAL 8)
            set_property(TARGET ${_target} APPEND_STRING PROPERTY LINK_FLAGS "/ENTRY:GsDriverEntry")
        endif()
    endif()
endfunction()

function(wdk_add_library _target)
    cmake_parse_arguments(WDK "" "KMDF;WINVER" "" ${ARGN})

    add_library(${_target} ${WDK_UNPARSED_ARGUMENTS})

    set_target_properties(${_target} PROPERTIES COMPILE_OPTIONS "${WDK_COMPILE_FLAGS}")
    set_target_properties(${_target} PROPERTIES COMPILE_DEFINITIONS
        "${WDK_COMPILE_DEFINITIONS};$<$<CONFIG:Debug>:${WDK_COMPILE_DEFINITIONS_DEBUG};>_WIN32_WINNT=${WDK_WINVER}"
    )

    target_include_directories(${_target} SYSTEM PRIVATE
        "${WDK_ROOT}/Include/${WDK_VERSION}/shared"
        "${WDK_ROOT}/Include/${WDK_VERSION}/km"
        "${WDK_ROOT}/Include/${WDK_VERSION}/km/crt"
    )

    if(DEFINED WDK_KMDF)
        target_include_directories(${_target} SYSTEM PRIVATE "${WDK_ROOT}/Include/wdf/kmdf/${WDK_KMDF}")
    endif()
endfunction()

```

`cmake/FindWil.cmake`:

```cmake
include(FetchContent)
set(FAST_BUILD OFF)
set(WIL_BUILD_PACKAGING OFF)
set(WIL_BUILD_TESTS OFF)

FetchContent_Declare(
    WIL
    URL https://github.com/microsoft/wil/archive/refs/tags/v1.0.231028.1.zip
    URL_HASH MD5=48f04bde1b5d745ee2f6dedc9040fba7
)
FetchContent_MakeAvailable(WIL)
message(STATUS "Using WIL in '${WIL_SOURCE_DIR}'")

add_library(Deps_WIL INTERFACE EXCLUDE_FROM_ALL)
add_library(Deps::WIL ALIAS Deps_WIL)
target_include_directories(Deps_WIL INTERFACE ${WIL_SOURCE_DIR}/include)

```