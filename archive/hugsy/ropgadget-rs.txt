Project Path: arc_hugsy_ropgadget-rs_wd28yud0

Source Tree:

```txt
arc_hugsy_ropgadget-rs_wd28yud0
├── Cargo.toml
├── LICENSE
├── README.md
├── examples
│   └── rp-rs.rs
├── rustfmt.toml
├── src
│   ├── common.rs
│   ├── cpu
│   │   ├── arm.rs
│   │   ├── mod.rs
│   │   └── x86.rs
│   ├── engine.rs
│   ├── error.rs
│   ├── format
│   │   ├── elf.rs
│   │   ├── mach.rs
│   │   ├── mod.rs
│   │   └── pe.rs
│   ├── gadget.rs
│   ├── lib.rs
│   ├── section.rs
│   └── session.rs
└── tests
    └── bin
        ├── big-arm32.elf
        ├── big-arm32.pe
        ├── big-arm64.elf
        ├── big-arm64.pe
        ├── big-x64.elf
        ├── big-x64.pe
        ├── big-x86.elf
        ├── big-x86.pe
        ├── small-arm32.elf
        ├── small-arm32.pe
        ├── small-arm64.elf
        ├── small-arm64.pe
        ├── small-x64.elf
        ├── small-x64.macho
        ├── small-x64.pe
        ├── small-x86.elf
        ├── small-x86.macho
        └── small-x86.pe

```

`Cargo.toml`:

```toml
[package]
name = "ropgadget-rs"
version = "0.4.0"
authors = ["hugsy <hugsy@blah.cat>"]
edition = "2018"
description = "Another (bad) ROP gadget finder"
homepage = "https://github.com/hugsy/ropgadget-rs/"
repository = "https://github.com/hugsy/ropgadget-rs/"
readme = "README.md"
license = "MIT"
keywords = [
    "pwn",
    "ctf",
    "ropgadget",
    "rop",
    "x64",
    "x86",
    "arm",
    "arm64",
    "pe",
    "elf",
    "macho",
]
include = ["/Cargo.toml", "/LICENSE", "README.md", "/src/**", "/examples/**"]

[dependencies]
goblin = "0.8.0"
capstone = "0.12.0"
clap = { version = "4.0.29", features = ["derive"] }
colored = "2"
bitflags = "2.4.2"
log = { version = "0.4.11", features = ["std"] }

[lib]
crate-type = ["dylib", "rlib"]

[[example]]
name = "rp-rs"

```

`LICENSE`:

```
MIT License

Copyright (c) 2020 crazy rabbidz

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
<p align="center">
  <img src="https://i.imgur.com/zjcxyVf.png" alt="logo" width="250px"/>
</p>

# `ropgadget-rs`

<p align="center">
    <a href="https://discord.gg/hSbqxxBgRX"><img alt="Discord" src="https://img.shields.io/badge/Discord-BlahCats-yellow"></a>
    <a href="https://github.com/hugsy/ropgadget-rs/actions/workflows/build.yml"><img src="https://github.com/hugsy/ropgadget-rs/actions/workflows/build.yml/badge.svg?branch=main"/></a>
</p>


RopGadget-rs started as a weekend project to learn [Rust](https://www.rust-lang.org/). But as usual it also started from the need to get really fast & easily portable ropgadget finder capable of handling quickly any binary (especially very large ones such as mshtml, ntoskrnl, chrome, etc.).

> [!NOTE]
> This library is a side project to learn Rust. If you want better tools, see the ones mentioned at the bottom of the page. 

Currently supports:

|       |  ELF   |  PE   |    MachO  |
| :---: | :----: |:-----:|:---------:|
|  x86  |   ✅   |   ✅   |   ✅   |
|  x64  |   ✅   |   ✅   |   ✅   |
|  arm  |   ✅   |   ✅   |   ❌   |
| arm64 |   ✅   |   ✅   |   ❌   |


## `ropgadget-rs`

Since 0.4, RopGadget-Rs was re-designed to be built as a library so it can be integrated to other projects.
But a lightweight standalone binary that features all what the library offers, can also be built.

## Build

(Optionally) If you don't have `cargo`:

 - On Linux/MacOS
```bash
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

 - On Windows
```ps1
Invoke-WebRequest https://win.rustup.rs/x86_64 -UseBasicParsing -OutFile "rustup-init.exe"
Invoke-Expression rustup-init.exe
```

Then build:
```bash
git clone https://github.com/hugsy/ropgadget-rs
cd ropgadget-rs
cargo build --release --lib
```

You might also want to build the ropgadget-rs binary so it can be easily used from the command line:
```bash
cargo build --release --example rp-rs
```


And run:
```bash
cargo run -- --help
```


## Install

Via `cargo`

```bash
cargo install --bins --git https://github.com/hugsy/ropgadget-rs.git
```

## Performance

The tool performs decently but could largely be optimized (and will be, over time).
Here are some performance obtained on an old i5-4300M (build in `--release` mode) with 2 threads (default)

 * `ntoskrnl.exe` (Windows 10 RS6 - 10.0.19041.329) - 10,921,280 bytes

```console
>  ./ropgadget-rs.exe -o rop.txt -vv ./ntoskrnl-rs6.exe
[INFO] - Checking file './ntoskrnl-rs6.exe'
[INFO] - Creating new Session(file=./ntoskrnl-rs6.exe, Info(Arch=x86-64, OS=PE))
[INFO] - Looking for gadgets in 15 sections (with 2 threads)...'
[INFO] - Dumping 336787 gadgets to 'rop.txt'...
[INFO] - Done!
[INFO] - Execution: 336787 gadgets found in 13.5224138s
```

 * `msedge.dll` (Chromium Edge - 83.0.478.64) - 145,665,416 bytes

```console
> ./ropgadget-rs -o rop.txt -vv ./msedge.dll
[INFO] - Checking file './msedge.dll'
[INFO] - Creating new Session(file=./msedge.dll, Info(Arch=x86-64, OS=PE))
[INFO] - Looking for gadgets in 1 sections (with 2 threads)...'
[INFO] - Dumping 5713703 gadgets to 'rop.txt'...
[INFO] - Done!
[INFO] - Execution: 5713703 gadgets found in 132.2237842s
```

YMMV but most small files (like Unix binaries) will execute in way under 1 second.

```console
$ ./ropgadget-rs -vv -o /dev/null /bin/ls
[INFO] - Checking file '/bin/ls'
[INFO] - Creating new Session(file=/bin/ls, Info(Arch=x86-64, OS=ELF))
[INFO] - Looking for gadgets in 5 sections (with 2 threads)...'
[INFO] - Dumping 3544 gadgets to '/dev/null'...
[INFO] - Done!
[INFO] - Execution: 3544 gadgets found in 151.5587ms
```


## Better projects

Unless you're ok with experiencing my bugs, you should probably check out one of those projects:
 - [rp++](https://github.com/0vercl0k/rp)
 - [ropper](https://github.com/sashs/ropper)
 - [RopGadget](https://github.com/JonathanSalwan/ROPgadget)


```

`examples/rp-rs.rs`:

```rs
use std::path::PathBuf;

use clap::{ArgAction, Parser};
use log::{info, LevelFilter};

use ropgadget_rs::common::GenericResult;
use ropgadget_rs::cpu;

use ropgadget_rs::collect_all_gadgets;
use ropgadget_rs::gadget::InstructionGroup;
use ropgadget_rs::session::RopGadgetOutput;
use ropgadget_rs::session::{RopProfileStrategy, Session};

#[derive(Parser, Debug)]
#[command(author, version, about, long_about)] // Read from `Cargo.toml`
pub struct Args {
    /// The file to parse
    #[arg(value_name = "FILE")]
    filepath: PathBuf,

    /// The number of threads to use
    #[arg(short, long = "number-of-threads", default_value_t = 4)]
    thread_num: u8,

    /// Write gadget to file (optional, defaults to stdout)
    #[arg(short, long = "output-file", value_name = "OUTPUT")]
    output_file: Option<PathBuf>,

    /// The verbosity level
    #[arg(short, long = "verbose", action = clap::ArgAction::Count)]
    verbosity: u8,

    /// Unique gadgets
    #[arg(short, long, action = ArgAction::SetTrue)]
    unique: bool,

    /// Force the architecture to given value
    #[arg(long, value_enum)]
    architecture: Option<cpu::CpuType>,

    // /// Force the OS to given value
    // #[arg(long, value_enum, default_value_t = format::FileFormat::Auto)]
    // format: Option<format::FileFormat>,
    /// Specify an image base
    #[arg(short, long, default_value_t = 0)]
    image_base: u32,

    /// Disable colors on output. This option is forced on when writing to file.
    #[arg(long)]
    no_color: bool,

    /// The maximum number of instructions in a gadget
    #[arg(long, default_value_t = 6)]
    max_insn_per_gadget: u8,

    /// The maximum size of the gadget
    #[arg(long, default_value_t = 32)]
    max_size: u8,

    /// The type of gadgets to focus on (default - return only)
    #[arg(long, value_enum)]
    rop_types: Vec<InstructionGroup>,

    /// The profile type (default - fast)
    #[arg(long, value_enum, default_value_t = RopProfileStrategy::Fast)]
    profile_type: RopProfileStrategy,
}

fn main() -> GenericResult<()> {
    let args = Args::parse();

    let verbosity = match args.verbosity {
        4 => LevelFilter::Trace, // -vvvv
        3 => LevelFilter::Debug, // -vvv
        2 => LevelFilter::Info,  // -vv
        1 => LevelFilter::Warn,  // -v
        _ => LevelFilter::Error,
    };

    let _output = match args.output_file {
        None => RopGadgetOutput::Console,
        Some(fpath) => RopGadgetOutput::File(fpath),
    };

    let sess = Session::new(args.filepath)
        .nb_thread(args.thread_num.into())
        .output(_output)
        .unique_only(args.unique)
        .verbosity(verbosity)
        .use_color(!args.no_color);

    info!("Created session: {:?}", sess);
    match collect_all_gadgets(sess) {
        Ok(_) => Ok(()),
        Err(e) => Err(e),
    }
}

```

`src/common.rs`:

```rs
use crate::error::Error;

pub type GenericResult<T> = Result<T, Error>;

```

`src/cpu/arm.rs`:

```rs
use crate::cpu;

pub struct Arm;

impl cpu::Cpu for Arm {
    fn cpu_type(&self) -> cpu::CpuType {
        cpu::CpuType::ARM
    }

    fn ptrsize(&self) -> usize {
        4
        // TODO: thumb
    }

    fn ret_insns(&self) -> Vec<(Vec<u8>, Vec<u8>)> {
        vec![(
            vec![0xd6, 0x5f, 0x03, 0xc0].into_iter().rev().collect(),
            vec![0xff, 0xff, 0xff, 0xff].into_iter().rev().collect(),
        )]
    }

    fn call_insns(&self) -> Vec<(Vec<u8>, Vec<u8>)> {
        vec![
            (
                vec![0b1101_0001, 0b0010_1111, 0b1111_1111, 0b0001_0000]
                    .into_iter()
                    .rev()
                    .collect(),
                vec![0b1111_1111, 0b1111_1111, 0b1111_1111, 0b1111_0000]
                    .into_iter()
                    .rev()
                    .collect(),
            ), // 4.3 Branch and Exchange (BX)
        ]
    }

    fn jmp_insns(&self) -> Vec<(Vec<u8>, Vec<u8>)> {
        vec![]
    }

    fn insn_step(&self) -> usize {
        4
    }
}

impl std::fmt::Debug for Arm {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Arm").finish()
    }
}

pub struct Arm64;

impl cpu::Cpu for Arm64 {
    fn cpu_type(&self) -> cpu::CpuType {
        cpu::CpuType::ARM64
    }

    fn ptrsize(&self) -> usize {
        8
    }

    fn ret_insns(&self) -> Vec<(Vec<u8>, Vec<u8>)> {
        vec![
            (
                vec![0xd6, 0x5f, 0x03, 0xc0].into_iter().rev().collect(),
                vec![0xff, 0xff, 0xff, 0xff].into_iter().rev().collect(),
            ), // RET
        ]
    }

    fn call_insns(&self) -> Vec<(Vec<u8>, Vec<u8>)> {
        vec![
            // (vec![0x14], vec![0xff]),             // B LABEL
            // (vec![0x01, 0x14], vec![0xff, 0xff]), // BL LABEL
            // (vec![0xd4], vec![0xff]),             // B.cond
            // (vec![0xb4], vec![0xff]),             // CBZ // CBNZ
            (
                vec![0b1101_0110, 0b0011_1111, 0b0000_0000, 0b0000_0000]
                    .into_iter()
                    .rev()
                    .collect(),
                vec![0b1111_1111, 0b1111_1111, 0b1111_0000, 0b0001_1111]
                    .into_iter()
                    .rev()
                    .collect(),
            ), // C6.2.35 BLR
        ]
    }

    fn jmp_insns(&self) -> Vec<(Vec<u8>, Vec<u8>)> {
        vec![
            (
                vec![0b1101_0110, 0b0001_1111, 0b0000_0000, 0b0000_0000]
                    .into_iter()
                    .rev()
                    .collect(),
                vec![0b1111_1111, 0b1111_1111, 0b1111_0000, 0b0001_1111]
                    .into_iter()
                    .rev()
                    .collect(),
            ), // C6.2.37 BR
        ]
    }

    fn insn_step(&self) -> usize {
        4
    }
}

impl std::fmt::Debug for Arm64 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Arm64").finish()
    }
}

```

`src/cpu/mod.rs`:

```rs
pub mod arm;
pub mod x86;

use clap::ValueEnum;

#[derive(std::fmt::Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, ValueEnum)]
#[derive(Default)]
pub enum CpuType {
    #[default]
    Unknown,
    X86,
    X64,
    ARM,
    ARM64,
}

pub trait Cpu: Send + Sync + std::fmt::Debug {
    fn cpu_type(&self) -> CpuType;
    fn ptrsize(&self) -> usize;
    fn insn_step(&self) -> usize;

    //
    // for each instruction type, the format is Vector<opcode, mask>
    //

    fn ret_insns(&self) -> Vec<(Vec<u8>, Vec<u8>)>;
    fn call_insns(&self) -> Vec<(Vec<u8>, Vec<u8>)>;
    fn jmp_insns(&self) -> Vec<(Vec<u8>, Vec<u8>)>;

    fn name(&self) -> String {
        self.cpu_type().to_string()
    }
}

impl std::fmt::Display for CpuType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let val = match self {
            CpuType::X86 => "x86-32",
            CpuType::X64 => "x86-64",
            CpuType::ARM => "ARM",
            CpuType::ARM64 => "ARM64",
            CpuType::Unknown => "Unknown",
        };

        write!(f, "Arch={}", val)
    }
}



impl From<&goblin::elf::header::Header> for CpuType {
    fn from(value: &goblin::elf::header::Header) -> Self {
        match value.e_machine {
            goblin::elf::header::EM_386 => CpuType::X86,
            goblin::elf::header::EM_X86_64 => CpuType::X64,
            goblin::elf::header::EM_ARM => CpuType::ARM,
            goblin::elf::header::EM_AARCH64 => CpuType::ARM64,
            _ => panic!("ELF machine format is unsupported"),
        }
    }
}

impl From<&goblin::mach::header::Header> for CpuType {
    fn from(value: &goblin::mach::header::Header) -> Self {
        match value.cputype {
            goblin::mach::constants::cputype::CPU_TYPE_X86 => CpuType::X86,
            goblin::mach::constants::cputype::CPU_TYPE_X86_64 => CpuType::X64,
            goblin::mach::constants::cputype::CPU_TYPE_ARM => CpuType::ARM,
            goblin::mach::constants::cputype::CPU_TYPE_ARM64 => CpuType::ARM64,
            _ => panic!("MachO is corrupted"),
        }
    }
}

impl From<&goblin::pe::header::CoffHeader> for CpuType {
    fn from(obj: &goblin::pe::header::CoffHeader) -> Self {
        match obj.machine {
            goblin::pe::header::COFF_MACHINE_X86 => CpuType::X86,
            goblin::pe::header::COFF_MACHINE_X86_64 => CpuType::X64,
            goblin::pe::header::COFF_MACHINE_ARM => CpuType::ARM,
            goblin::pe::header::COFF_MACHINE_ARMNT => CpuType::ARM,
            goblin::pe::header::COFF_MACHINE_ARM64 => CpuType::ARM64,
            _ => panic!("Unsupported format"),
        }
    }
}

```

`src/cpu/x86.rs`:

```rs
use std::vec;

use crate::cpu;

pub struct X86;

impl cpu::Cpu for X86 {
    fn cpu_type(&self) -> cpu::CpuType {
        cpu::CpuType::X86
    }

    fn ptrsize(&self) -> usize {
        4
    }

    fn ret_insns(&self) -> Vec<(Vec<u8>, Vec<u8>)> {
        vec![
            (vec![0xc3], vec![0xff]),                         // ret
            (vec![0xcb], vec![0xff]),                         // retf
            (vec![0xc2, 0x00, 0x00], vec![0xff, 0x00, 0x00]), // ret imm16
            (vec![0xcf, 0x00, 0x00], vec![0xff, 0x00, 0x00]), // retf imm16
        ]
    }

    fn call_insns(&self) -> Vec<(Vec<u8>, Vec<u8>)> {
        vec![
            // (
            //     vec![0xe8, 0x00, 0x00, 0x00, 0x00],
            //     vec![0xff, 0x00, 0x00, 0x00, 0x00],
            // ), // CALL rel32
            (vec![0xff, 0xd0], vec![0xff, 0xf0]), // CALL REG32
            (vec![0xff, 0b0001_0000], vec![0xff, 0b1111_0000]), // CALL [REG32]
            (vec![0xff, 0b0101_0001, 0], vec![0xff, 0b1111_0000, 0]), // CALL [REG32+DISP8]
        ]
    }

    fn jmp_insns(&self) -> Vec<(Vec<u8>, Vec<u8>)> {
        vec![
            // (vec![0xe9, 0, 0, 0, 0], vec![0xff, 0, 0, 0, 0]), // JMP imm32
            (vec![0xFF, 0xe7], vec![0xff, 0xf8]), // JMP REG32
        ]
    }

    fn insn_step(&self) -> usize {
        1
    }
}

impl std::fmt::Debug for X86 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("X86").finish()
    }
}

pub struct X64;

impl cpu::Cpu for X64 {
    fn cpu_type(&self) -> cpu::CpuType {
        cpu::CpuType::X64
    }

    fn ptrsize(&self) -> usize {
        8
    }

    fn ret_insns(&self) -> Vec<(Vec<u8>, Vec<u8>)> {
        vec![
            (vec![0xc3], vec![0xff]),                         // RET
            (vec![0xcb], vec![0xff]),                         // RETF
            (vec![0xc2, 0x00, 0x00], vec![0xff, 0x00, 0x00]), // RET imm16
            (vec![0xcf, 0x00, 0x00], vec![0xff, 0x00, 0x00]), // RETF imm16
        ]
    }

    fn call_insns(&self) -> Vec<(Vec<u8>, Vec<u8>)> {
        vec![
            // (
            //     vec![0xe8, 0x00, 0x00, 0x00, 0x00],
            //     vec![0xff, 0x00, 0x00, 0x00, 0x00],
            // ), // CALL rel32
            (vec![0xff, 0xd0], vec![0xff, 0xf0]), // CALL REG64
            (vec![0x41, 0xff, 0xd0], vec![0xff, 0xff, 0xf0]), // CALL REX.W REG64
            (vec![0xff, 0b0001_0000], vec![0xff, 0b1111_0000]), // CALL [REG64]
            (vec![0x41, 0xff, 0b0001_0000], vec![0x41, 0xff, 0b1111_0000]), // CALL [REX.W REG64]
            (vec![0xff, 0b0101_0001, 0], vec![0xff, 0b1111_0000, 0]), // CALL [REG64+DISP8]
            (
                vec![0x41, 0xff, 0b0101_0001, 0],
                vec![0xff, 0xff, 0b1111_0000, 0],
            ), // CALL [REX.W REG64+DISP8]
        ]
    }

    fn jmp_insns(&self) -> Vec<(Vec<u8>, Vec<u8>)> {
        vec![
            (vec![0xff, 0xe0], vec![0xff, 0xf8]), // JMP REG64
            (vec![0x41, 0xff, 0xe0], vec![0xff, 0xff, 0xf8]), // JMP REX.W REG64
                                                  // (vec![0xeb, 0x00], vec![0xff, 0x00]),             // JMP imm8
                                                  // (vec![0xe9, 0, 0, 0, 0], vec![0xff, 0, 0, 0, 0]), // JMP imm32
        ]
    }

    fn insn_step(&self) -> usize {
        1
    }
}

impl std::fmt::Debug for X64 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("X64").finish()
    }
}

```

`src/engine.rs`:

```rs
use capstone::prelude::*;

use crate::cpu::{Cpu, CpuType};
use crate::gadget::{Instruction, InstructionGroup};

/**
 *
 * for now we just use capstone, but can be easily updated to other engines
 * in this case, change engine.rs -> engine/mod.rs and put the engines there
 *
 */

#[derive(Debug, Default)]
pub enum DisassemblyEngineType {
    #[default]
    Invalid,
    Capstone,
}

// impl Default for DisassemblyEngineType {
//     fn default() -> Self {
//         DisassemblyEngineType::Invalid
//     }
// }

//
// All disassembler must implement this trait
//
pub trait Disassembler {
    fn disassemble(&self, code: &Vec<u8>, address: u64) -> Option<Vec<Instruction>>;
    fn name(&self) -> String;
    fn id(&self) -> DisassemblyEngineType;
}

pub struct DisassemblyEngine {
    pub disassembler: Box<dyn Disassembler>,
}

impl DisassemblyEngine {
    ///
    ///
    ///
    pub fn new(engine_type: &DisassemblyEngineType, cpu: &dyn Cpu) -> Self {
        match engine_type {
            DisassemblyEngineType::Capstone => Self {
                disassembler: Box::new(CapstoneDisassembler::new(cpu)),
            },
            DisassemblyEngineType::Invalid => panic!(),
        }
    }
}

impl std::fmt::Display for DisassemblyEngine {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Engine({})", self.disassembler.name())
    }
}

///
/// Capstone disassembler implementation
///

// https://github.com/aquynh/capstone/blob/1b5014515d0d671048e2b43ce483d38d85a2bc83/bindings/python/capstone/__init__.py#L216
const INSN_GRP_JUMP: u8 = 0x01;
const INSN_GRP_CALL: u8 = 0x02;
const INSN_GRP_RET: u8 = 0x03;
const INSN_GRP_INT: u8 = 0x04;
const INSN_GRP_IRET: u8 = 0x05;
const INSN_GRP_PRIV: u8 = 0x06;

pub struct CapstoneDisassembler {
    cs: Capstone,
}

impl Disassembler for CapstoneDisassembler {
    fn disassemble(&self, code: &Vec<u8>, address: u64) -> Option<Vec<Instruction>> {
        self.cs_disassemble(code, address)
    }

    fn name(&self) -> String {
        // todo: add version strings
        let (major, minor) = Capstone::lib_version();
        format!("Capstone-Engine({}.{})", major, minor)
    }

    fn id(&self) -> DisassemblyEngineType {
        DisassemblyEngineType::Capstone
    }
}

impl std::fmt::Display for CapstoneDisassembler {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Disassembler({})", self.name())
    }
}

impl CapstoneDisassembler {
    fn new(cpu: &dyn Cpu) -> Self {
        let cs = match cpu.cpu_type() {
            CpuType::X86 => Capstone::new()
                .x86()
                .mode(arch::x86::ArchMode::Mode32)
                .syntax(arch::x86::ArchSyntax::Intel)
                .detail(true)
                .build()
                .expect("Failed to create Capstone object"),

            CpuType::X64 => Capstone::new()
                .x86()
                .mode(arch::x86::ArchMode::Mode64)
                .syntax(arch::x86::ArchSyntax::Intel)
                .detail(true)
                .build()
                .expect("Failed to create Capstone object"),

            CpuType::ARM => Capstone::new()
                .arm()
                .mode(arch::arm::ArchMode::Arm)
                .detail(true)
                .build()
                .expect("Failed to create Capstone object"),

            CpuType::ARM64 => Capstone::new()
                .arm64()
                .mode(arch::arm64::ArchMode::Arm)
                .detail(true)
                .build()
                .expect("Failed to create Capstone object"),

            CpuType::Unknown => panic!(),
        };

        Self { cs }
    }

    fn cs_disassemble(&self, code: &Vec<u8>, address: u64) -> Option<Vec<Instruction>> {
        let cs_insns = self
            .cs
            .disasm_all(code, address)
            .expect("Failed to disassemble");

        //
        // Any instruction?
        //
        if cs_insns.len() == 0 {
            return None;
        }

        //
        // Otherwise we're good to proceed
        //
        let mut insns: Vec<Instruction> = Vec::new();
        let mut candidates: Vec<Instruction> = Vec::new();

        for cs_insn in cs_insns.iter() {
            let detail: InsnDetail = self.cs.insn_detail(cs_insn).unwrap();

            let mut insn_group = InstructionGroup::Undefined;

            for cs_insn_group in detail.groups() {
                insn_group = match cs_insn_group.0 {
                    INSN_GRP_JUMP => InstructionGroup::Jump,
                    INSN_GRP_CALL => InstructionGroup::Call,
                    INSN_GRP_RET => InstructionGroup::Ret,
                    INSN_GRP_PRIV => InstructionGroup::Privileged,
                    INSN_GRP_INT => InstructionGroup::Int,
                    INSN_GRP_IRET => InstructionGroup::Iret,
                    _ => {
                        continue;
                    }
                };
            }

            let mnemonic = cs_insn.mnemonic().unwrap().to_string();

            let operands: Option<String> = cs_insn.op_str().map(|op| op.to_string());

            let insn = Instruction {
                raw: cs_insn.bytes().to_vec(),
                size: cs_insn.bytes().len(),
                mnemonic,
                operands,
                address: cs_insn.address(),
                group: insn_group,
            };

            candidates.push(insn);
        }

        //
        // at this point `candidates` holds a valid set of Instruction
        // must filter out the sequence that can't qualify for a rop sequence
        //
        for insn in candidates.into_iter().rev() {
            match insn.group {
                InstructionGroup::Jump => {
                    if !insns.is_empty() {
                        break;
                    }
                }
                InstructionGroup::Call => {
                    if !insns.is_empty() {
                        break;
                    }
                }
                InstructionGroup::Ret => {
                    if !insns.is_empty() {
                        break;
                    }
                }
                _ => {}
            };

            insns.insert(0, insn);
        }

        Some(insns)
    }
}

```

`src/error.rs`:

```rs
#[derive(Debug)]
pub enum Error {
    IoError(std::io::Error),
    ParsingError(goblin::error::Error),
    ThreadRuntimeError(std::boxed::Box<dyn std::any::Any + std::marker::Send>),
    InvalidFileError,
}

#[derive(Debug)]
pub struct GenericError {
    msg: String,
}

impl std::fmt::Display for GenericError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}'", self.msg)
    }
}

#[derive(Debug)]
pub struct GadgetBuildError {}

impl From<std::io::Error> for Error {
    fn from(error: std::io::Error) -> Self {
        Error::IoError(error)
    }
}

impl From<goblin::error::Error> for Error {
    fn from(error: goblin::error::Error) -> Self {
        Error::ParsingError(error)
    }
}

impl From<std::boxed::Box<dyn std::any::Any + std::marker::Send>> for Error {
    fn from(error: std::boxed::Box<dyn std::any::Any + std::marker::Send>) -> Self {
        Error::ThreadRuntimeError(error)
    }
}

#[derive(Debug)]
pub struct InvalidFormatError {
    format: String,
}

impl std::fmt::Display for InvalidFormatError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Unknown/unsupported format: {}'", self.format)
    }
}

```

`src/format/elf.rs`:

```rs
use colored::Colorize;
use goblin;
use log::debug;
use std::fs::File;
use std::io::{BufReader, Read, Seek, SeekFrom};
use std::path::PathBuf;

use crate::cpu;
use crate::section::Permission;
use crate::{format::FileFormat, section::Section};

use super::ExecutableFileFormat;

#[derive(Debug)]
pub struct Elf {
    path: PathBuf,
    sections: Vec<Section>,
    // cpu: Box<dyn cpu::Cpu>,
    cpu_type: cpu::CpuType,
    entry_point: u64,
}

impl Elf {
    pub fn new(path: PathBuf, obj: goblin::elf::Elf) -> Self {
        let filepath = path.to_str().unwrap();

        let mut executable_sections: Vec<Section> = Vec::new();
        debug!(
            "looking for executable sections in ELF: '{}'",
            filepath.bold()
        );

        let file = File::open(&path).unwrap();
        let mut reader = BufReader::new(file);

        for current_section in &obj.section_headers {
            // trace!("Testing section {:?}", s);

            // //
            // // disregard non executable section
            // //
            // if !s.is_executable() {
            //     continue;
            // }

            // debug!("Importing section {:?}", s);

            // let mut section = Section::from(s);
            // section.name = Some(String::from(&obj.shdr_strtab[s.sh_name]));

            let mut sect =
                Section::from(current_section).name(&obj.shdr_strtab[current_section.sh_name]);

            if !sect.permission.contains(Permission::EXECUTABLE) {
                continue;
            }

            if reader
                .seek(SeekFrom::Start(current_section.sh_addr))
                .is_err()
            {
                panic!("Invalid offset {}", current_section.sh_addr,)
            }

            match reader.read_exact(&mut sect.data) {
                Ok(_) => {}
                Err(e) => panic!(
                    "Failed to extract section '{}' (size={:#x}) at offset {:#x}: {:?}",
                    &sect.name.clone().unwrap_or_default(),
                    &sect.size(),
                    sect.start_address,
                    e
                ),
            };

            debug!("Adding {}", sect);
            executable_sections.push(sect);
        }

        // let cpu_type = match obj.header.e_machine {
        //     goblin::elf::header::EM_386 => cpu::CpuType::X86,
        //     goblin::elf::header::EM_X86_64 => cpu::CpuType::X64,
        //     goblin::elf::header::EM_ARM => cpu::CpuType::ARM,
        //     goblin::elf::header::EM_AARCH64 => cpu::CpuType::ARM64,
        //     _ => {
        //         panic!("ELF machine format is unsupported")
        //     }
        // };

        Self {
            path: path.clone(),
            sections: executable_sections,
            cpu_type: cpu::CpuType::from(&obj.header),
            entry_point: obj.entry,
        }
    }
}

impl ExecutableFileFormat for Elf {
    fn path(&self) -> &PathBuf {
        &self.path
    }

    fn format(&self) -> FileFormat {
        FileFormat::Elf
    }

    fn sections(&self) -> &Vec<Section> {
        &self.sections
    }

    // fn cpu(&self) -> &dyn cpu::Cpu {
    //     self.cpu.as_ref()
    // }

    fn cpu_type(&self) -> cpu::CpuType {
        self.cpu_type
    }

    fn entry_point(&self) -> u64 {
        self.entry_point
    }
}

```

`src/format/mach.rs`:

```rs
// use std::fs::File;
// use std::io::{BufReader, Read, Seek, SeekFrom};
use std::path::PathBuf;

use colored::Colorize;
use goblin;
use log::debug;

use crate::cpu;
use crate::{format::FileFormat, section::Permission, section::Section};

use super::ExecutableFileFormat;

pub struct Mach {
    path: PathBuf,
    sections: Vec<Section>,
    cpu_type: cpu::CpuType,
    entry_point: u64,
}
impl Mach {
    pub fn new(path: PathBuf, obj: goblin::mach::Mach) -> Self {
        let bin = match obj {
            goblin::mach::Mach::Binary(macho) => macho,
            goblin::mach::Mach::Fat(_) => todo!(),
        };

        let filepath = path.to_str().unwrap();

        let mut executable_sections: Vec<Section> = Vec::new();

        debug!(
            "looking for executables sections in MachO: '{}'",
            filepath.bold()
        );

        for current_segment in &bin.segments {
            // for current_section in current_segment.sections().iter() {
            // if s.flags & constants::S_ATTR_PURE_INSTRUCTIONS == 0
            //     || s.flags & constants::S_ATTR_SOME_INSTRUCTIONS == 0
            // {
            //     continue;
            // }

            // let section_name = match std::str::from_utf8(&s.segname) {
            //     Ok(v) => String::from(v).replace("\0", ""),
            //     Err(_) => "".to_string(),
            // };

            // let mut section = Section::new(s.vmaddr as u64, (s.vmaddr + s.vmsize - 1) as u64);

            // section.name = Some(section_name);

            // let perm = Permission::EXECUTABLE | Permission::READABLE; // todo: fix later
            // section.permission = perm;

            let section = Section::from(current_segment).data(current_segment.data.to_vec());

            if !section.permission.contains(Permission::EXECUTABLE) {
                continue;
            }

            // reader
            //     .seek(SeekFrom::Start(current_segment.fileoff as u64))
            //     .unwrap();
            // reader.read_exact(&mut section.data).unwrap();

            debug!("Adding {}", section);
            executable_sections.push(section);
            // }
        }

        // let cpu_type = match bin.header.cputype {
        //     constants::cputype::CPU_TYPE_X86 => cpu::CpuType::X86,
        //     constants::cputype::CPU_TYPE_X86_64 => cpu::CpuType::X64,
        //     constants::cputype::CPU_TYPE_ARM => cpu::CpuType::ARM,
        //     constants::cputype::CPU_TYPE_ARM64 => cpu::CpuType::ARM64,
        //     _ => {
        //         panic!("MachO is corrupted")
        //     }
        // };

        Self {
            path: path.clone(),
            sections: executable_sections,
            cpu_type: cpu::CpuType::from(&bin.header),
            entry_point: bin.entry,
        }
    }
}

impl ExecutableFileFormat for Mach {
    fn path(&self) -> &PathBuf {
        &self.path
    }

    fn format(&self) -> FileFormat {
        FileFormat::MachO
    }

    fn sections(&self) -> &Vec<Section> {
        &self.sections
    }

    // fn cpu(&self) -> &dyn cpu::Cpu {
    //     self.cpu.as_ref()
    // }

    fn cpu_type(&self) -> cpu::CpuType {
        self.cpu_type
    }

    fn entry_point(&self) -> u64 {
        self.entry_point
    }
}

```

`src/format/mod.rs`:

```rs
pub mod elf;
pub mod mach;
pub mod pe;

use std::{fs, path::PathBuf};

use crate::{common::GenericResult, cpu::CpuType, error::Error, section::Section};

use clap::ValueEnum;
use goblin::Object;

#[derive(std::fmt::Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, ValueEnum, Default)]
pub enum FileFormat {
    #[default]
    Auto,
    Pe,
    Elf,
    MachO,
    // todo: Raw,
}

impl std::fmt::Display for FileFormat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let val = match self {
            FileFormat::Pe => "PE",
            FileFormat::Elf => "ELF",
            FileFormat::MachO => "MachO",
            _ => panic!("Invalid FileFormat"),
        };

        write!(f, "BinaryFormat={}", val)
    }
}

/// Trait specific to executable files
pub trait ExecutableFileFormat: Send + Sync {
    fn path(&self) -> &PathBuf;

    fn format(&self) -> FileFormat;

    fn sections(&self) -> &Vec<Section>;

    // fn cpu(&self) -> &dyn cpu::Cpu;

    fn cpu_type(&self) -> CpuType;

    fn entry_point(&self) -> u64;
}

/// Attempt to determine the file
pub fn guess_file_format(file: &PathBuf) -> GenericResult<Box<dyn ExecutableFileFormat>> {
    if !file.as_path().exists() {
        return Err(Error::InvalidFileError);
    }

    let buffer = match fs::read(file.as_path()) {
        Ok(buf) => buf,
        Err(_) => return Err(Error::InvalidFileError),
    };

    let parsed = match Object::parse(&buffer) {
        Ok(e) => e,
        Err(_) => return Err(Error::InvalidFileError),
    };

    match parsed {
        Object::PE(obj) => Ok(Box::new(pe::Pe::new(file.to_path_buf(), obj))),
        Object::Elf(obj) => Ok(Box::new(elf::Elf::new(file.to_path_buf(), obj))),
        Object::Mach(obj) => Ok(Box::new(mach::Mach::new(file.to_path_buf(), obj))),
        Object::Archive(_) => Err(Error::InvalidFileError),
        Object::Unknown(_) => Err(Error::InvalidFileError),
        _ => Err(Error::InvalidFileError),
    }
}

```

`src/format/pe.rs`:

```rs
use std::fs::File;
use std::io::{BufReader, Read, Seek, SeekFrom};
use std::path::PathBuf;

use goblin;
use log::debug;

use crate::cpu::{self, CpuType};
// use crate::cpu;
use crate::{format::FileFormat, section::Permission, section::Section};

use super::ExecutableFileFormat;

#[derive(Debug)]
#[derive(Default)]
pub struct Pe {
    path: PathBuf,
    pub sections: Vec<Section>,
    // cpu: Box<dyn cpu::Cpu>,
    pub entry_point: u64,

    cpu_type: cpu::CpuType,
}



impl Pe {
    pub fn new(path: PathBuf, obj: goblin::pe::PE<'_>) -> Self {
        let mut executable_sections: Vec<Section> = Vec::new();
        let file = File::open(&path).unwrap();
        let mut reader = BufReader::new(file);

        for current_section in &obj.sections {
            // if s.characteristics & goblin::pe::section_table::IMAGE_SCN_MEM_EXECUTE == 0 {
            //     continue;
            // }

            // let section_name = match std::str::from_utf8(&s.name) {
            //     Ok(v) => String::from(v).replace("\0", ""),
            //     Err(_) => String::new(),
            // };

            // let mut section = Section::new(
            //     s.virtual_address as u64,
            //     (s.virtual_address + s.virtual_size - 1) as u64,
            // );

            // section.name = Some(section_name);

            // let mut perm = Permission::EXECUTABLE;
            // if s.characteristics & goblin::pe::section_table::IMAGE_SCN_MEM_READ != 0 {
            //     perm |= Permission::READABLE;
            // }

            // if s.characteristics & goblin::pe::section_table::IMAGE_SCN_MEM_WRITE != 0 {
            //     perm |= Permission::WRITABLE;
            // }

            // section.permission = perm;

            // let data = s.data();

            let mut section = Section::from(current_section);

            if !section.permission.contains(Permission::EXECUTABLE) {
                continue;
            }

            match reader.seek(SeekFrom::Start(current_section.pointer_to_raw_data as u64)) {
                Ok(_) => {}
                Err(e) => panic!("Corrupted PE: {:?}", e),
            };

            reader.read_exact(&mut section.data).unwrap();

            debug!("Adding {}", section);
            executable_sections.push(section);
        }

        Self {
            path: path.clone(),
            sections: executable_sections,
            // cpu,
            cpu_type: CpuType::from(&obj.header.coff_header),
            entry_point: obj.entry as u64,
            ..Default::default()
        }
    }
}

impl ExecutableFileFormat for Pe {
    fn path(&self) -> &PathBuf {
        &self.path
    }

    fn format(&self) -> FileFormat {
        FileFormat::Pe
    }

    fn sections(&self) -> &Vec<Section> {
        &self.sections
    }

    // fn cpu(&self) -> &dyn cpu::Cpu {
    //     self.cpu.as_ref()
    // }

    fn entry_point(&self) -> u64 {
        self.entry_point
    }

    fn cpu_type(&self) -> cpu::CpuType {
        self.cpu_type
    }
}

```

`src/gadget.rs`:

```rs
extern crate capstone;

use std::cmp::Ordering;
use std::{fmt, thread};
use std::{
    io::{Cursor, Read, Seek, SeekFrom},
    sync::Arc,
};

use colored::*;
use log::{debug, warn};

use crate::common::GenericResult;
use crate::cpu;
use crate::engine::Disassembler;
use crate::section::Section;
use crate::session::{RopProfileStrategy, Session};

use clap::ValueEnum;

#[derive(std::fmt::Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, ValueEnum)]
pub enum InstructionGroup {
    Undefined,
    Jump,
    Call,
    Ret,
    Int,
    Iret,
    Privileged,
}

impl std::fmt::Display for InstructionGroup {
    fn fmt(&self, f: &mut fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(self, f)
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct Instruction {
    pub size: usize,
    pub raw: Vec<u8>,
    pub address: u64,
    pub group: InstructionGroup,

    pub mnemonic: String,
    pub operands: Option<String>,
}

impl Instruction {
    pub fn text(&self, use_color: bool) -> String {
        let mnemo = match use_color {
            true => {
                format!("{}", self.mnemonic.cyan())
            }
            false => {
                self.mnemonic.to_string()
            }
        };

        let op = match &self.operands {
            Some(x) => {
                if use_color {
                    format!(" {}", x.bold())
                } else {
                    format!(" {}", x)
                }
            }
            None => "".to_string(),
        };

        format!("{}{}", mnemo, op)
    }
}

impl fmt::Display for Instruction {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "Instruction(addr=0x{:x}, size={}, text='{}', raw={:?}, group={:?})",
            self.address,
            self.size,
            self.text(false),
            self.raw,
            self.group
        )
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct Gadget {
    pub address: u64,
    pub insns: Vec<Instruction>,
    pub size: usize,  // sum() of sizeof(each_instruction)
    pub raw: Vec<u8>, // concat() of instruction.raw
}

impl fmt::Display for Gadget {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "Gadget(addr={:#x}, text='{}')",
            self.address,
            self.text(false)
        )
    }
}

impl Gadget {
    pub fn new(insns: Vec<Instruction>) -> Self {
        //
        // by nature, we should never be here if insns.len() is 0 (should at least have the
        // ret insn) so we assert() to be notified
        //
        if insns.is_empty() {
            std::panic::panic_any("GadgetBuildError");
        }

        let size = insns.iter().map(|x| x.size).sum();

        let raw = insns.iter().flat_map(|x| x.raw.clone()).collect();

        let address = insns.first().unwrap().address;

        Self {
            size,
            raw,
            address,
            insns,
        }
    }

    pub fn text(&self, use_color: bool) -> String {
        self.insns
            .iter()
            .map(|i| i.text(use_color).clone() + " ; ")
            .collect()
    }
}

fn collect_previous_instructions(
    session: &Arc<Session>,
    group: &Vec<(Vec<u8>, Vec<u8>)>,
    memory_chunk: &Vec<u8>,
) -> GenericResult<Vec<(usize, usize)>> {
    let mut res: Vec<(usize, usize)> = Vec::new();

    for (opcodes, mask) in group {
        let sz = opcodes.len();

        let mut v: Vec<(usize, usize)> = memory_chunk
            .windows(sz)
            .enumerate()
            .filter(|(_, y)| {
                y.iter()
                    .enumerate()
                    .map(|(i, z)| z & mask[i])
                    .cmp(opcodes.to_owned())
                    == Ordering::Equal
            })
            .map(|(x, _)| (x, sz))
            .collect();

        res.append(&mut v);

        match session.profile_type {
            RopProfileStrategy::Fast => {
                break;
            }
            _ => {}
        }
    }

    Ok(res)
}

pub fn get_all_valid_positions_and_length(
    session: &Arc<Session>,
    cpu: &Box<dyn cpu::Cpu>,
    section: &Section,
    cursor: usize,
) -> GenericResult<Vec<(usize, usize)>> {
    let data = &section.data[cursor..].to_vec();

    let mut groups = Vec::new();

    for gadget_type in &session.gadget_types {
        match gadget_type {
            InstructionGroup::Ret => {
                debug!("inserting ret positions and length...");
                groups.append(&mut cpu.ret_insns().clone());
            }
            InstructionGroup::Call => {
                debug!("inserting call positions and length...");
                groups.append(&mut cpu.call_insns().clone());
            }
            InstructionGroup::Jump => {
                debug!("inserting jump positions and length...");
                groups.append(&mut cpu.jmp_insns().clone());
            }
            InstructionGroup::Int => todo!(),
            InstructionGroup::Iret => todo!(),
            InstructionGroup::Privileged => todo!(),
            InstructionGroup::Undefined => todo!(),
        }
    }

    collect_previous_instructions(session, &groups, data)
}

///
/// from the section.data[pos], disassemble previous instructions
///
pub fn find_gadgets_from_position(
    session: Arc<Session>,
    engine: &dyn Disassembler,
    section: &Section,
    initial_position: usize,
    initial_len: usize,
    cpu: &Box<dyn cpu::Cpu>,
) -> GenericResult<Vec<Gadget>> {
    let max_invalid_size = match cpu.cpu_type() // todo: use session.max_gadget_length
    {
        cpu::CpuType::X86 => { 16 }
        cpu::CpuType::X64 => { 16 }
        cpu::CpuType::ARM64 => { 16 }
        cpu::CpuType::ARM => { 16 }
        cpu::CpuType::Unknown => panic!(),
    };

    let start_address = section.start_address;
    let s: usize = if initial_position < max_invalid_size {
        0
    } else {
        initial_position - max_invalid_size
    };
    let data = &section.data[s..initial_position + initial_len];
    let mut cur = Cursor::new(data);

    //
    // browse the section for the largest gadget
    //

    let mut sz: usize = initial_len;
    let mut nb_invalid = 0;
    let step = cpu.insn_step();
    let mut gadgets: Vec<Gadget> = Vec::new();

    loop {
        let mut candidate: Vec<u8> = vec![0; sz];

        //
        // ensure we're still within the boundaries of the cursor
        //
        if (sz - step) >= data.len() {
            break;
        }

        //
        // jump to the position in the file
        //
        let current_position = -((sz - step) as i64);

        cur.seek(SeekFrom::End(current_position - step as i64))?;
        if cur.read_exact(&mut candidate).is_err() {
            warn!("{:?} Cursor reached EOF", std::thread::current().id());
            break;
        }

        //
        // disassemble the code from given position
        //
        let addr = start_address + s as u64 + cur.position() - sz as u64;
        let insns = engine.disassemble(&candidate, addr as u64);

        //
        // transform the Vec<Instruction> into a valid gadget
        //
        match insns {
            Some(x) => {
                nb_invalid = 0;
                if !x.is_empty() {
                    let last_insn = x.last().unwrap();
                    if session.gadget_types.contains(&last_insn.group) {
                        let gadget = Gadget::new(x);
                        if gadgets.iter().all(|x| x.address != gadget.address) {
                            debug!(
                                "{:?}: pushing new gadget(address={:x}, sz={})",
                                thread::current().id(),
                                gadget.address,
                                gadget.raw.len()
                            );
                            gadgets.push(gadget);
                        }
                    }
                }
            }

            None => {
                nb_invalid += 1;
                if nb_invalid == max_invalid_size {
                    break;
                }
            }
        }

        sz += step;
    }

    Ok(gadgets)
}

```

`src/lib.rs`:

```rs
#[macro_use]
extern crate bitflags;

use colored::Colorize;
use gadget::Gadget;
use std::fs;
use std::io::Write as _;
use std::sync::Arc;

use log::{debug, error, info, warn};

pub mod common;
pub mod cpu;
pub mod engine;
pub mod error;
pub mod format;
pub mod gadget;
pub mod section;
pub mod session;

use crate::common::GenericResult;
use crate::session::Session;

pub fn collect_all_gadgets(sess: Session) -> GenericResult<Vec<Gadget>> {
    let info = &sess.info;
    let start_timestamp = std::time::Instant::now();
    let sections = info.format.sections();
    
    let use_color = sess.use_color;
    let unique_only = sess.unique_only;
    let chosen_output_format = sess.output.clone();
    let entrypoint_address = info.format.entry_point();
    let is_64b = info.is_64b();

    info!(
        "Looking for gadgets in {} executable section(s) (with {} threads)...'",
        sections.len(),
        sess.nb_thread,
    );

    //
    // use an arc for the session to share between threads
    //
    let arc = Arc::new(sess);
    match session::find_gadgets(arc.clone()) {
        Ok(_) => {
            dbg!("Done collecting gadgets");
        }
        Err(e) => {
            error!("An error occured while collecting gadgets: {:?}", e);
            return Err(e);
        }
    }

    let mut gadgets = arc.gadgets.lock().unwrap();

    //
    // if unique, filter out doublons
    //
    let total_gadgets_found: usize = gadgets.len();
    if unique_only {
        debug!(
            "Filtering {} gadgets for deplicates ...",
            total_gadgets_found
        );
        gadgets.sort_by_key(|a| a.text(false));
        gadgets.dedup_by(|a, b| a.text(false).eq_ignore_ascii_case(b.text(false).as_str()));
        info!(
            "{} duplicate gadgets removed",
            total_gadgets_found - gadgets.len()
        );
    }

    //
    // sort by address
    //
    gadgets.sort_by(|a, b| a.address.cmp(&b.address));

    //
    // Write to given output
    //
    match chosen_output_format {
        session::RopGadgetOutput::None => {
            warn!("No output specified");
        }

        session::RopGadgetOutput::Console => {
            info!("Dumping {} gadgets to stdout...", gadgets.len());

            for g in &*gadgets {
                let addr = match is_64b {
                    true => {
                        format!("0x{:016x}", g.address)
                    }
                    _ => {
                        format!("0x{:08x}", g.address)
                    }
                };

                if use_color {
                    println!("{} | {}", addr.red(), g.text(use_color));
                } else {
                    println!("{} | {}", addr, g.text(use_color));
                }
            }
        }

        session::RopGadgetOutput::File(filename) => {
            dbg!(
                "Dumping {} gadgets to '{}'...",
                gadgets.len(),
                filename.to_str().unwrap()
            );

            if use_color {
                warn!("Disabling colors when writing to file");
            }

            let mut file = fs::File::create(&filename)?;
            for gadget in &*gadgets {
                let addr = entrypoint_address + gadget.address;
                file.write_all((format!("{:#x} | {}\n", addr, gadget.text(false))).as_bytes())?;
            }

            info!(
                "Written {} gadgets to '{}'",
                gadgets.len(),
                filename.to_str().unwrap()
            );
        }
    }

    info!("Done!");

    if log::log_enabled!(log::Level::Info) {
        let end_timestamp = std::time::Instant::now();
        let elapsed = end_timestamp - start_timestamp;
        let execution_time = start_timestamp.elapsed().as_secs_f64();
        info!("Execution time => {:?}", execution_time);
        info!(
            "Execution: {} gadgets found in {:?}",
            total_gadgets_found, elapsed
        );
    }

    Ok(gadgets.clone())
}

#[cfg(test)]
mod tests {
    use crate::{collect_all_gadgets, gadget::Gadget, session::RopGadgetOutput, Session};
    use std::path::PathBuf;

    fn run_basic_test(sz: &str, arch: &str, fmt: &str) -> Vec<Gadget> {
        let input_fname = PathBuf::from(format!("tests/bin/{}-{}.{}", sz, arch, fmt));
        let s = Session::new(input_fname).output(RopGadgetOutput::None);
        match collect_all_gadgets(s) {
            Ok(gadgets) => gadgets,
            Err(e) => panic!("{:?}", e),
        }
    }

    mod pe {
        use super::super::*;
        const FMT: &str = "pe";

        #[test]
        fn x86() {
            for sz in ["small", "big"] {
                let res = tests::run_basic_test(sz, "x86", FMT);
                assert!(res.len() > 0);
            }
        }

        #[test]
        fn x64() {
            for sz in ["small", "big"] {
                let res = tests::run_basic_test(sz, "x64", FMT);
                assert!(res.len() > 0);
            }
        }

        // #[test]
        // fn arm32() {
        //     for sz in ["small", "big"] {
        //         let res = tests::run_basic_test(sz, "arm32", FMT);
        //         assert!(res.len() > 0);
        //     }
        // }
        #[test]
        fn arm64() {
            for sz in ["small", "big"] {
                let res = tests::run_basic_test(sz, "arm64", FMT);
                assert!(res.len() > 0);
            }
        }
    }

    mod elf {
        use super::super::*;
        const FMT: &str = "elf";

        #[test]
        fn x86() {
            for sz in ["small", "big"] {
                let res = tests::run_basic_test(sz, "x86", FMT);
                assert!(res.len() > 0);
            }
        }

        #[test]
        fn x64() {
            for sz in ["small", "big"] {
                let res = tests::run_basic_test(sz, "x64", FMT);
                assert!(res.len() > 0);
            }
        }

        // #[test]
        // fn arm32() {
        //     for sz in ["big", "small"] {
        //         let res = tests::run_basic_test(sz, "arm32", FMT);
        //         assert!(res.len() > 0);
        //     }
        // }
        #[test]
        fn arm64() {
            for sz in ["small", "big"] {
                let res = tests::run_basic_test(sz, "arm64", FMT);
                assert!(res.len() > 0);
            }
        }
    }

    mod macho {
        use super::super::*;
        const FMT: &str = "macho";

        #[test]
        fn x86() {
            for sz in vec!["small"] {
                let res = tests::run_basic_test(sz, "x86", FMT);
                assert!(res.len() > 0);
            }
        }

        #[test]
        fn x64() {
            for sz in vec!["small"] {
                let res = tests::run_basic_test(sz, "x64", FMT);
                assert!(res.len() > 0);
            }
        }
    }
}

```

`src/section.rs`:

```rs
use std::{borrow::Borrow, fmt};

bitflags! {
    #[derive(Debug)]
    pub struct Permission: u8
    {
        const NONE = 0;
        const READABLE = 1;
        const WRITABLE = 2;
        const EXECUTABLE = 4;
        const ALL = Self::READABLE.bits() | Self::WRITABLE.bits() | Self::EXECUTABLE.bits();
    }

}

impl Default for Permission {
    /// Return NONE as default
    fn default() -> Self {
        Permission::NONE
    }
}

#[derive(Debug)]
#[derive(Default)]
pub struct Section {
    pub start_address: u64,
    pub end_address: u64,
    pub name: Option<String>,
    pub permission: Permission,
    pub data: Vec<u8>,
}

impl fmt::Display for Section {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = self
            .name
            .as_ref()
            .unwrap_or(String::from("N/A").borrow())
            .clone();
        write!(
            f,
            "Section(name='{}', start={:#x}, sz={:#x}, permission={:?})",
            name,
            self.start_address,
            self.size(),
            self.permission
        )
    }
}

impl Section {
    pub fn new(start_address: u64, end_address: u64) -> Self {
        assert!(start_address < end_address);
        let sz = (end_address - start_address) as usize;
        Self {
            start_address,
            end_address,
            name: None,
            permission: Permission::NONE,
            data: vec![0; sz],
        }
    }

    pub fn size(&self) -> usize {
        (self.end_address - self.start_address) as usize
    }

    pub fn name(self, name: &str) -> Self {
        Self {
            name: Some(name.to_string()),
            ..self
        }
    }

    pub fn data(self, data: Vec<u8>) -> Self {
        Self { data, ..self }
    }
}



impl From<&goblin::elf::section_header::SectionHeader> for Section {
    fn from(value: &goblin::elf::section_header::SectionHeader) -> Self {
        let mut perm = Permission::NONE;

        if value.is_executable() {
            perm |= Permission::READABLE | Permission::EXECUTABLE;
        }

        if value.is_writable() {
            perm |= Permission::READABLE | Permission::WRITABLE;
        }

        let sz = value.sh_size as usize;

        Self {
            start_address: value.sh_addr,
            end_address: value.sh_addr + sz as u64,
            permission: perm,
            name: None,
            data: vec![0; sz],
        }
    }
}

impl From<&goblin::mach::segment::Segment<'_>> for Section {
    fn from(value: &goblin::mach::segment::Segment) -> Self {
        let mut perm = Permission::READABLE;

        if value.flags & goblin::mach::constants::S_ATTR_PURE_INSTRUCTIONS == 0
            || value.flags & goblin::mach::constants::S_ATTR_SOME_INSTRUCTIONS == 0
        {
            perm |= Permission::EXECUTABLE;
        }

        let section_name = match std::str::from_utf8(&value.segname) {
            Ok(v) => String::from(v).replace('\0', ""),
            Err(_) => "".to_string(),
        };

        let sz = value.vmsize as usize;

        Self {
            start_address: value.vmaddr,
            end_address: value.vmaddr + sz as u64,
            name: Some(section_name),
            permission: perm,
            data: vec![0; sz],
        }
    }
}

impl From<&goblin::pe::section_table::SectionTable> for Section {
    fn from(value: &goblin::pe::section_table::SectionTable) -> Self {
        let section_name = match std::str::from_utf8(&value.name) {
            Ok(v) => String::from(v).replace('\0', ""),
            Err(_) => String::new(),
        };

        let mut perm = Permission::NONE;
        if value.characteristics & goblin::pe::section_table::IMAGE_SCN_MEM_READ != 0 {
            perm |= Permission::READABLE;
        }

        if value.characteristics & goblin::pe::section_table::IMAGE_SCN_MEM_WRITE != 0 {
            perm |= Permission::WRITABLE;
        }

        if value.characteristics & goblin::pe::section_table::IMAGE_SCN_MEM_EXECUTE != 0 {
            perm |= Permission::EXECUTABLE;
        }

        let sz = value.virtual_size as usize;

        Self {
            start_address: value.virtual_address as u64,
            end_address: (value.virtual_address + value.virtual_size) as u64,
            name: Some(section_name),
            permission: perm,
            data: vec![0; sz],
        }
    }
}

```

`src/session.rs`:

```rs
use std::borrow::Borrow;
use std::path::PathBuf;
use std::sync::{Arc, Mutex};
use std::thread;

use clap::ValueEnum;
use colored::*;
use log::{debug, info, warn, Level, LevelFilter, Metadata, Record};

use crate::common::GenericResult;
use crate::cpu;
use crate::engine::{DisassemblyEngine, DisassemblyEngineType};
use crate::format::{self, guess_file_format};
use crate::gadget::{
    find_gadgets_from_position, get_all_valid_positions_and_length, Gadget, InstructionGroup,
};

#[derive(std::fmt::Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, ValueEnum, Default)]
pub enum RopProfileStrategy {
    #[default]
    /// Strategy Fast
    Fast,
    /// Strategy Complete
    Complete,
}

impl std::fmt::Display for RopProfileStrategy {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(self, f)
    }
}

pub struct ExecutableDetails {
    pub filepath: PathBuf,
    pub format: Box<dyn format::ExecutableFileFormat>,
    pub cpu: Box<dyn cpu::Cpu>,
}

impl std::fmt::Debug for ExecutableDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("ExecutableDetails")
            .field("filepath", &self.filepath)
            .field("format", &self.format.format().to_string())
            .field("cpu", &self.cpu.cpu_type().to_string())
            .finish()
    }
}

impl std::fmt::Display for ExecutableDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "Info({}, {}, Entry=0x{:x})",
            self.cpu.cpu_type(),
            self.format.format(),
            self.format.entry_point()
        )
    }
}

impl Default for ExecutableDetails {
    fn default() -> Self {
        ExecutableDetails {
            filepath: PathBuf::new(),
            cpu: Box::new(cpu::x86::X86 {}),
            format: Box::new(format::pe::Pe::default()),
        }
    }
}

impl ExecutableDetails {
    pub fn new(filepath: PathBuf) -> Self {
        let fpath = filepath.clone();
        let format = guess_file_format(&fpath).unwrap();

        let cpu: Box<dyn cpu::Cpu> = match format.cpu_type() {
            cpu::CpuType::X86 => Box::new(cpu::x86::X86 {}),
            cpu::CpuType::X64 => Box::new(cpu::x86::X64 {}),
            cpu::CpuType::ARM64 => Box::new(cpu::arm::Arm64 {}),
            cpu::CpuType::ARM => Box::new(cpu::arm::Arm {}),
            _ => panic!("CPU type is invalid"),
        };
        // let cpu = Box::new( Cpu::from(format.cpu_type()) );

        ExecutableDetails {
            filepath: fpath,
            cpu,
            format,
        }
    }

    pub fn is_64b(&self) -> bool {
        self.cpu.ptrsize() == 8
    }
}

#[derive(Debug, Clone, Default)]
pub enum RopGadgetOutput {
    #[default]
    None,
    Console,
    File(PathBuf),
}

struct RpLogger;

impl log::Log for RpLogger {
    fn enabled(&self, metadata: &Metadata) -> bool {
        metadata.level() <= Level::Trace
    }

    fn log(&self, record: &Record) {
        if self.enabled(record.metadata()) {
            let level = match record.level().to_string().as_str() {
                "ERROR" => "ERROR".red(),
                "WARN" => "WARN".magenta(),
                "INFO" => "INFO".green(),
                "DEBUG" => "DEBUG".cyan(),
                _ => "TRACE".bold(),
            };

            println!("[{}] - {}", level, record.args());
        }
    }

    fn flush(&self) {}
}

#[derive(Debug)]
pub struct Session {
    //
    // session required information
    //
    pub info: ExecutableDetails,
    pub nb_thread: u8,
    pub verbosity: LevelFilter,
    pub output: RopGadgetOutput,

    //
    // misc details about the executable file (filled by )
    //

    // pub file_format: format::FileFormat,

    //
    // the info need to build, store and show the ropgadgets
    //
    pub engine_type: DisassemblyEngineType,
    pub max_gadget_length: usize,
    pub gadgets: Mutex<Vec<Gadget>>,
    pub unique_only: bool,
    pub use_color: bool,
    pub gadget_types: Vec<InstructionGroup>,
    pub profile_type: RopProfileStrategy,
}

impl Session {
    pub fn new(filepath: PathBuf) -> Self {
        Session {
            info: ExecutableDetails::new(filepath),
            ..Default::default()
        }
    }

    pub fn nb_thread(self, nb_thread: u8) -> Self {
        Self { nb_thread, ..self }
    }

    pub fn output(self, new_output: RopGadgetOutput) -> Self {
        Self {
            output: new_output,
            ..self
        }
    }

    pub fn unique_only(self, unique_only: bool) -> Self {
        Self {
            unique_only,
            ..self
        }
    }

    pub fn use_color(self, use_color: bool) -> Self {
        Self { use_color, ..self }
    }

    pub fn verbosity(self, verbosity: LevelFilter) -> Self {
        Self { verbosity, ..self }
    }

    pub fn filepath(&self) -> &PathBuf {
        &self.info.filepath
    }
}

impl Default for Session {
    fn default() -> Self {
        Session {
            verbosity: LevelFilter::Off,
            nb_thread: 4,
            output: RopGadgetOutput::None,
            unique_only: true,
            use_color: true,
            max_gadget_length: 6,
            gadget_types: vec![InstructionGroup::Ret],
            profile_type: RopProfileStrategy::Fast,
            gadgets: Mutex::new(Vec::new()),
            engine_type: DisassemblyEngineType::Capstone,
            info: ExecutableDetails::default(),
        }
    }
}

// impl std::fmt::Debug for Session {
//     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
//         f.debug_struct("Session")
//             .field("path", &self.filepath())
//             .field("format", &self.info.format.format().to_string())
//             .field("cpu", &self.info.cpu.cpu_type().to_string())
//             .finish()
//     }
// }

impl std::fmt::Display for Session {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let gadget_types: Vec<String> = self.gadget_types.iter().map(|x| x.to_string()).collect();
        write!(
            f,
            "Session(File='{}', {}, Profile={}, GadgetTypes=[{}])",
            self.filepath().to_str().unwrap(),
            self.info,
            self.profile_type,
            gadget_types.join(", "),
        )
    }
}

///
/// This function manages the thread pool to look for gadget
///
pub fn find_gadgets(session: Arc<Session>) -> GenericResult<()> {
    let info = &session.info;
    let number_of_sections = info.format.sections().len();
    let nb_thread = session.nb_thread as usize;

    debug!("Using {nb_thread} threads over {number_of_sections} section(s) of executable code...");

    //
    // Multithread parsing of each section
    //
    for section_idx in 0..number_of_sections {
        if info.format.sections().get(section_idx).is_none() {
            continue;
        }

        let section = info.format.sections().get(section_idx).unwrap();
        let chunk_size = section.data.len() / nb_thread;

        //
        // Fill the thread pool
        //
        let mut threads: Vec<std::thread::JoinHandle<Vec<Gadget>>> = Vec::new();
        let mut pos = 0;
        let mut thread_pool_size = 0;
        let mut force_flush = false;

        loop {
            //
            // Empty the thread pool if necessary
            //
            if thread_pool_size == nb_thread || force_flush {
                for curthread in threads {
                    debug!("Joining {:?}...", curthread.thread().id());
                    let gadgets = curthread.join().unwrap();
                    {
                        let mut data = session.gadgets.lock().unwrap();
                        data.extend(gadgets);
                    }
                }

                threads = Vec::new();
                thread_pool_size = 0;

                if force_flush {
                    break;
                }
            }

            //
            // Is there still some data to parse?
            //
            if pos >= section.data.len() {
                force_flush = true;
                continue;
            }

            //
            // If so, spawn more workers
            //
            let rc_session = Arc::clone(&session);
            let thread = thread::spawn(move || thread_worker(rc_session, section_idx, pos));
            debug!(
                "Spawning {:?} (pos={} section_index={})...",
                thread.thread().id(),
                pos,
                section_idx
            );
            threads.push(thread);
            thread_pool_size += 1;
            pos += chunk_size;
        }
    }

    info!(
        "Total gadgets found => {}",
        session.gadgets.lock().unwrap().len()
    );
    Ok(())
}

///
/// Worker routine to search for gadgets
///
fn thread_worker(session: Arc<Session>, index: usize, cursor: usize) -> Vec<Gadget> {
    let cpu = session.info.cpu.as_ref();
    let engine = DisassemblyEngine::new(&session.engine_type, cpu);
    debug!(
        "{:?}: Initialized engine {} for {:?}",
        thread::current().id(),
        engine,
        cpu.cpu_type()
    );

    let mut gadgets: Vec<Gadget> = Vec::new();
    let sections = session.info.format.sections();
    if let Some(section) = sections.get(index) {
        let section_name = section
            .name
            .as_ref()
            .unwrap_or(String::from("N/A").borrow())
            .clone();

        debug!(
            "{:?}: Processing section '{}'",
            thread::current().id(),
            section_name
        );

        let cpu = &session.info.cpu;
        let disass = engine.disassembler.as_ref();

        for (pos, len) in
            get_all_valid_positions_and_length(&session, cpu, section, cursor).unwrap()
        {
            debug!(
                "{:?}: Processing Section {}[..{:x}+{:x}] (size={:x})",
                thread::current().id(),
                section_name,
                pos,
                len,
                section.size(),
            );

            let res = find_gadgets_from_position(session.clone(), disass, section, pos, len, cpu);
            if res.is_ok() {
                let mut gadget = res.unwrap();
                gadgets.append(&mut gadget);
            }
        }

        debug!(
            "{:?}: Finished processing section '{}'",
            thread::current().id(),
            section_name,
        );
    } else {
        warn!(
            "{:?}: No section at index {}, ending...",
            thread::current().id(),
            index,
        );
    }

    gadgets
}

```