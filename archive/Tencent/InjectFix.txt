Project Path: arc_Tencent_InjectFix_suf34rtr

Source Tree:

```txt
arc_Tencent_InjectFix_suf34rtr
├── Doc
│   ├── example.md
│   ├── example_en.md
│   ├── faq.md
│   ├── faq_en.md
│   ├── quick_start.md
│   ├── quick_start_en.md
│   ├── user_manual.md
│   └── user_manual_en.md
├── LICENSE
├── Pic
│   └── logo.png
├── README.md
├── README_en.md
└── Source
    ├── Misc
    │   └── LiveDotNet
    │       ├── Editor
    │       │   ├── LiveDotNet.cs
    │       │   ├── LiveDotNet.cs.meta
    │       │   ├── LiveDotNetConfig.cs
    │       │   └── LiveDotNetConfig.cs.meta
    │       ├── Editor.meta
    │       ├── PatchReceiver.cs
    │       ├── PatchReceiver.cs.meta
    │       ├── RotateCube.cs
    │       ├── RotateCube.cs.meta
    │       ├── RotateCube.unity
    │       ├── RotateCube.unity.meta
    │       ├── link.xml
    │       └── link.xml.meta
    ├── UnityProj
    │   ├── Assets
    │   │   ├── Helloworld
    │   │   │   ├── Calc.cs
    │   │   │   ├── Calc.cs.meta
    │   │   │   ├── Editor
    │   │   │   │   ├── HelloworldCfg.cs
    │   │   │   │   └── HelloworldCfg.cs.meta
    │   │   │   ├── Editor.meta
    │   │   │   ├── Helloworld.cs
    │   │   │   ├── Helloworld.cs.meta
    │   │   │   ├── Helloworld.unity
    │   │   │   └── Helloworld.unity.meta
    │   │   ├── Helloworld.meta
    │   │   ├── IFix
    │   │   │   ├── Editor
    │   │   │   │   ├── Configure.cs
    │   │   │   │   ├── Configure.cs.meta
    │   │   │   │   ├── ILFixEditor.cs
    │   │   │   │   └── ILFixEditor.cs.meta
    │   │   │   └── Editor.meta
    │   │   ├── IFix.meta
    │   │   ├── NewClass
    │   │   │   ├── Editor
    │   │   │   │   └── NewClassTestCfg.cs
    │   │   │   ├── NewClassTest.cs
    │   │   │   ├── NewClassTest.cs.meta
    │   │   │   ├── VMBehaviourScript.cs
    │   │   │   └── VMBehaviourScript.cs.meta
    │   │   ├── Plugins
    │   │   │   └── IFix.Core.dll.meta
    │   │   ├── Plugins.meta
    │   │   ├── Pro Standard Assets
    │   │   │   ├── AnotherClass.cs
    │   │   │   └── AnotherClass.cs.meta
    │   │   └── Pro Standard Assets.meta
    │   └── IFixToolKit
    │       ├── Mono.Cecil.Mdb.dll
    │       ├── Mono.Cecil.Pdb.dll
    │       └── Mono.Cecil.dll
    └── VSProj
        ├── ShuffleInstruction.cs
        ├── Src
        │   ├── Builder
        │   │   ├── FileVirtualMachineBuilder.cs
        │   │   └── SimpleVirtualMachineBuilder.cs
        │   ├── Core
        │   │   ├── AnonymousStorey.cs
        │   │   ├── DataDefine.cs
        │   │   ├── GenericDelegate.cs
        │   │   ├── Il2CppSetOptionAttribute.cs
        │   │   ├── Instruction.cs
        │   │   ├── ObjectClone.cs
        │   │   ├── ReflectionMethodInvoker.cs
        │   │   ├── StackOperation.cs
        │   │   ├── SwitchFlags.cs
        │   │   ├── Utils.cs
        │   │   ├── VirtualMachine.cs
        │   │   └── WrappersManager.cs
        │   ├── PerfTest
        │   │   └── PerfTest.cs
        │   ├── TestDLL
        │   │   ├── BaseTest.cs
        │   │   └── RedirectBaseTest.cs
        │   ├── Tools
        │   │   ├── CSFix.cs
        │   │   ├── CecilExtensions.cs
        │   │   ├── CodeTranslator.cs
        │   │   └── GenerateConfigure.cs
        │   ├── UnitTest
        │   │   └── VirtualMachineTest.cs
        │   └── Version.cs
        ├── ThirdParty
        │   ├── Mono.Cecil.Mdb.dll
        │   ├── Mono.Cecil.Pdb.dll
        │   ├── Mono.Cecil.dll
        │   └── nunit.framework.dll
        ├── build_for_unity.bat
        ├── build_for_unity.py
        ├── build_for_unity.sh
        ├── config.json
        ├── gen_proj.bat
        ├── premake5.exe
        ├── premake5.lua
        └── vs2013
            ├── IFix.Core.csproj
            ├── IFix.PerfTest.csproj
            ├── IFix.TestDLL.Redirect.csproj
            ├── IFix.TestDLL.csproj
            ├── IFix.UnitTest.csproj
            ├── IFix.csproj
            ├── IFix.sln
            ├── inject_redirect_dll
            ├── inject_redirect_dll.bat
            └── packages.config

```

`Doc/example.md`:

```md
以配套的Helloworld为例，编辑器下演示IFix的使用

### 一、准备工作

Helloworld位于IFix目录下

其中Calc.cs就是待修复的代码，Helloworld.cs是Calc.cs的测试。

运行一下Helloworld的场景，看下控制台的打印，可以看到Calc.cs是错误的。

### 二、配置

和xLua类似，你得配置下要预处理的代码，预处理过的代码才可能在运行时切换到补丁代码。

~~~csharp
[Configure]
public class HelloworldCfg
{
    [IFix]
    static IEnumerable<Type> hotfix
    {
        get
        {
            return new List<Type>()
            {
                typeof(IFix.Test.Calculator)
            };
        }
    }
}
~~~

说明下：

1、这配置必须放在Editor目录下（例子的配置位于Helloworld/Editor目录下）；
2、写配置的类需要打上Configure标签，属性必须打IFix标签并且声明为 **static** ；
3、属性返回一个IEnumerable\&lt;Type\&gt;即可，由于Helloworld只需要简单的返回个List，因为这是个getter，你可以用linq+反射很方便的把大量的类给配上，例如你要一次加入XXX命名空间下所有类，可以这样：

~~~csharp
[Configure]
public class HelloworldCfg
{
    [IFix]
    static IEnumerable<Type> hotfix
    {
        get
        {
            return (from type in Assembly.Load("Assembly-CSharp").GetTypes()
                    where type.Namespace == "XXXX"
                    select type).ToList();
        }
    }
}
~~~


### 三、流程说明

有两个步骤：Inject，Fix。

实际应用中，Inject只需在发包时做一次，这个步骤主要是对代码做一定的预处理，只有做了预处理的代码后续才能正常加载补丁。

Fix的过程是根据修改后的代码编译后的dll，生成补丁。

修改代码和Fix之间别执行Inject，否则iFix会认为这是个线上版本，拒绝生成补丁。鉴于这个限制，我们编辑器下体验流程上做一定的调整：先修改代码为正确逻辑，生成patch。然后回退代码，执行Inject模拟线上有问题的版本。

### 四、修复代码、生成patch

打开Calc.cs，修改为正确的逻辑，为将要生成patch的函数打上Patch标签（为了做对比，案例只为Add函数打Patch标签）

执行"InjectFix/Fix"菜单

看到process success打印表示已经处理成功。我们可以在项目根目录下找到Assembly-CSharp.patch.bytes文件，这就是补丁文件。

### 五、看看效果

回滚对Add为错误逻辑，执行"InjectFix/Inject"菜单（只有注入过的版本才能加载补丁）。然后运行，可以看到Add此时为错误逻辑，然后把Assembly-CSharp.patch.bytes拷贝到\Assets\IFix\Resources下，重新执行，可以看到已经修复到新逻辑。
```

`Doc/example_en.md`:

```md
Take the matching Helloworld as an example to demonstrate the use of IFix in the editor

### I. Preparation

Helloworld is located under the IFix directory

Calc.cs is the code to be fixed, while Helloworld.cs is the test for Calc.cs.

Run the Helloworld scene and check the print at the console. You can see that Calc.cs is incorrect.

### II. Configuration

Like xLua, you have to configure the code to be preprocessed first , so that the preprocessed code can switch to the patch code at runtime.

~~~csharp
[Configure]
public class HelloworldCfg
{
    [IFix]
    static IEnumerable<Type> hotfix
    {
        get
        {
            return new List<Type>()
            {
                typeof(IFix.Test.Calculator)
            };
        }
    }
}
~~~

Description:

1. The configuration must be placed under the Editor directory (the example configuration is located in the Helloworld/Editor directory);
2. The classes to be configured need to be labeled with a Configure tag, and the attribute must be labeled as IFix and declared as **static**;
3. It is enough for the attribute to return IEnumerable\&lt;Type\&gt, because Helloworld need only return a List; as it is a getter, you can use linq + reflection to easily configure a large number of classes; for example, to add all classes under the XXX namespace, the code is as following:

~~~csharp
[Configure]
public class HelloworldCfg
{
    [IFix]
    static IEnumerable<Type> hotfix
    {
        get
        {
            return (from type in Assembly.Load("Assembly-CSharp").GetTypes()
                    where type.Namespace == "XXXX"
                    select type).ToList();
        }
    }
}
~~~


### III. Process Description

There are two steps: Inject and Fix.

In practice, Inject is a one-time operation when sending the package. It is to pre-process the code, because only the code that has been pre-processed can load patches normally.

Fix is ​​the process to generate a patch based on the dll compiled from the modified code.

Do not execute Inject between the modified code and Fix, otherwise iFix will consider this to be an online version and refuse to generate a patch. In view of this limitation, we have made some adjustments in the experience flow in the editor: first modify the code to the correct logic and generate a patch. Then revert the code and execute Inject to simulate the problematic online version.

### IV. Fix the code and generate a patch

Open Calc.cs, modify it to the correct logic, and attach a Patch tag to the function that will generate the patch (for comparison, only the Add function is labeled with the Patch tag in the example case)

Execute the "InjectFix/Fix" menu

The process success print indicates that it has been processed successfully. We can find the Assembly-CSharp.patch.bytes file in the project root directory, which is the patch file.

### V. Check the result

Rollback Add to the wrong logic and execute the "InjectFix/Inject" menu (only the injected version can load the patch). Then run it, you can see Add is wrong logic now, then copy the Assembly-CSharp.patch.bytes to \Assets\IFix\Resources and re-execute. Now, you can see that it has been fixed to the new logic.
```

`Doc/faq.md`:

```md
## 执行Patch for android或者Patch for ios时，报“"please put template file for android/ios in IFixToolKit directory!”

解决这个错误需要制作一个编译模版文件放到IFixToolKit目录：

* 假如你制作的是android的模版，请执行一次普通的android构建，在构建的过程中，到“工程目录/Temp”目录把UnityTempFile打头的文件都拷贝出来，其中一个“UnityTempFile开头”的文件就是你刚刚打包命令行文件，可以根据文件时间或者文件里头的命令行参数（ios会有这么一行：-define:UNITY_IOS，android会有-define:UNITY_ANDROID，而且必须没有UNITY_EDITOR）找到它，拷贝到IFixToolKit目录，如果你在window获取的UnityTempFile，重命名为android.win.tpl，如果是mac下获取的，重命名为android.osx.tpl；（这步对于一个项目，如果你不升级unity版本，不更改条件编译宏，仅需做一次即可）
* ios的模版文件改名为ios.osx.tpl，如果你希望在window下制作ios补丁，复制一份改名为ios.win.tpl，打开这个文件，把链接的引擎dll，系统级dll的路径按window的unity安装目录修改。

## IL2CPP 出现报错`IL2CPP error for method 'System.Object IFix.Core.EvaluationStackOperation::ToObject(IFix.Core.Value*,IFix.Core.Value*,System.Object[],System.Type,IFix.Core.VirtualMachine,System.Boolean)'`

应该是自己手动编译`IFix.Core.dll`导致

修改iFix.Core源代码后，需要通过`build_for_unity.bat`脚本进行构建

## 生成 Patch 的时候遇到`Error: the new assembly must not be inject, please reimport the project!`报错

这个dll执行过注入，不能对注入过的dll生成patch，在Unit选工程根目录，右键选reimport

## 补丁制作的条件编译宏如何处理

如果是Unity2018.3版本及以上，由于Unity开放了C#编译接口，所以InjectFix在Unity2018.3版本直接支持Android和iOS的补丁生成，直接执行对应菜单即可。

但如果低于Unity2018.3版本，则要用比较麻烦的方式：按对应平台的编译参数把Assembly-CSharp.dll编译出来，然后调用IFix.Editor.IFixEditor.GenPatch去生成补丁。

Unity编译是在工程的Temp目录新建一个文件，把命令行参数放到那个文件，然后执行类似（目录根据自己的unity安装情况而定）如下命令进行编译：

~~~bash
"D:\Program Files\Unity201702\Editor\Data\MonoBleedingEdge\bin\mono.exe" "D:\Program Files\Unity201702\Editor\Data\MonoBleedingEdge\lib\mono\4.5\mcs.exe"  @Temp/UnityTempFile-55a959adddae39f4aaa18507dd165989
~~~

你可以尝试一次编辑器下的手机版本打包，然后到工程目录下的Temp目录把那个临时文件拷贝出来（编译完会自动删掉，所以要手快）。

这个文件大多数地方都不会变的，变的主要是C#文件列表，可以改为动态生成这个文件：C#文件列表根据当前项目生成，其它保持不变。然后用这个文件作为输入来编译。

```

`Doc/faq_en.md`:

```md
## When executing Patch for android or Patch for ios, you will get the report ""please put template file for android/ios in IFixToolKit directory!”

To fix this error, you need to create a compilation template file and put it in the IFixToolKit directory:

* If you are creating an android template, perform a normal android build. During the build process, copy the files that begin with UnityTempFile in the "Project Directory/Temp" directory, and one of such files is the command line file you have just packaged, which you can find according to the time of the file or the command line parameters in the file (the UNITY_IOS line for ios files and the -define:UNITY_ANDROID line for android files; this must be without UNITY_EDITOR). Copy it to the IFixToolKit directory. If you got the UnityTempFile under Windows, rename it to android.win.tpl, if it was obtained under mac, rename it to android.osx.tpl; (you only need to complete this step once for a project if you do not upgrade the unity version or change the conditional compilation macro)
* The ios template file is renamed to ios.osx.tpl. If you want to create an ios patch under Windows, copy the file and rename it to ios.win.tpl. Open this file, and modify the path of the linked engine dll and system-level dll to the unity installation directory in Windows.

## IL2CPP reports `IL2CPP error for method 'System.Object IFix.Core.EvaluationStackOperation::ToObject(IFix.Core.Value*,IFix.Core.Value*,System.Object[],System.Type,IFix.Core .VirtualMachine, System.Boolean)'`

It is probably caused by manual compilation of `IFix.Core.dll`

After modifying the iFix.Core source code, it needs to be built with the `build_for_unity.bat` script.

##When generating a patch, you get the report “Error: The new assembly must not be injected, please reimport the project!”

The dll that generates Patch cannot be injected

```

`Doc/quick_start.md`:

```md
## 快速入门

### 接入示例

判断有补丁就加载补丁

~~~csharp
var patchPath = "./Assets/IFix/Resources/Assembly-CSharp.ill.bytes";
if (File.Exists(patchPath))
{
    PatchManager.Load(new FileStream(patchPath, FileMode.Open));
}
~~~

### 配置

热补丁的实现依赖于提前做些静态代码插入，所以需要配置对哪些类预处理，配置了才能被修复。一般而言，只要不是性能要求很苛刻的类都可以加入。

iFix支持动态和静态列表方式，由于类型往往比较多，动态列表会方便些。下面是一个实例，配置XLua名字空间下除匿名类之外的所有类型。

~~~csharp
[Configure]
public class InterpertConfig {
    [IFix]
    static IEnumerable<Type> ToProcess
    {
        get
        {
            return (from type in Assembly.Load("Assembly-CSharp").GetTypes()
                    where type.Namespace == "XLua" && !type.Name.Contains("<")
                    select type);
        }
    }
}
~~~

__划下重点：__

* 配置类打上Configure标签
* 配置的属性打上IFix标签，而且必须是 __static__ 类型

动态配置除了不用一个个配，还可能有其它额外好处，比如上述配置，后续该名字空间下增删类，都不需要更改配置。

配置好后，打包手机版本会自动预处理，如果希望自动化打包，也可以手动调用IFix.Editor.IFixEditor.InjectAllAssemblys函数。

### 补丁制作

对需要打补丁的函数打上Patch标签

~~~csharp
[Patch]
public int Add(int a, int b)
{
    return a + b;
}
~~~

#### 如果要修复的函数不含条件编译宏

执行"InjectFix/Fix"菜单。

补丁制作成功后会放到工程目录下，文件名为“{Dll Name}.patch.bytes”（比如：“Assembly-CSharp.patch.bytes”），上传补丁到手机，加载就能看到效果。

#### 如果要修复的函数存在条件编译宏

比如这样的代码：

~~~csharp
[Patch]
public void Job(int a)
{
#if UNITY_EDITOR
    Foo();
#endif

#if !UNITY_EDITOR
    Bar();
#endif
}
~~~

如果还是直接在编辑器下直接生成补丁，将会比手机上运行多调用了个Foo，少调用了个Bar，这可能会导致各种问题：逻辑不对，调用了编辑器专用函数而导致找不到要调用的函数等等。

这种情况请按[FAQ](faq.md)的[《补丁制作的条件编译宏如何处理》](./faq.md#%E8%A1%A5%E4%B8%81%E5%88%B6%E4%BD%9C%E7%9A%84%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91%E5%AE%8F%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86)处理。

## 编辑器下体验iFix

上面的使用流程，补丁是要在手机上加载，如果你想在编辑器下快速体验一下iFix的热补丁能力，可以看下这个文档：[《编辑器下体验热补丁》](./example.md)


```

`Doc/quick_start_en.md`:

```md
## Quick Start

### Access example

Check the patch to load the patch

~~~csharp
var patchPath = "./Assets/IFix/Resources/Assembly-CSharp.ill.bytes";
if (File.Exists(patchPath))
{
    PatchManager.Load(new FileStream(patchPath, FileMode.Open));
}
~~~

### Configuration

The implementation of the hotfix relies on the static code insertion in advance, so you need to configure which classes to preprocess so that they can be fixed. In general, classes that are not extremely demanding in performance can all be added.

iFix supports both dynamic and static lists, and dynamic lists are more convenient because there are many different classes. The following is an example where all the classes except the anonymous class in the XLua namespace are configured.

~~~csharp
[Configure]
public class InterpertConfig {
    [IFix]
    static IEnumerable<Type> ToProcess
    {
        get
        {
            return (from type in Assembly.Load("Assembly-CSharp").GetTypes()
                    where type.Namespace == "XLua" && !type.Name.Contains("<")
                    select type);
        }
    }
}
~~~

__ Key notes: __

* Put a Configure tag on the class to be configured
* Put a IFix tag for the configure attribute, which must be of __static__ class

Dynamic configuration, in addition to not having to configure one by one, may have other additional benefits. Take the above case for example, subsequent class addition/deletion in the namespace will not require modification of the configuration.

Once configured, the mobile package version will automatically conduct pre-process. If you want to automate the packaging, you can also manually call the IFix.Editor.IFixEditor.InjectAllAssemblys function.

### Create a patch

Put a Patch tag on the function that needs to be patched

~~~csharp
[Patch]
public int Add(int a, int b)
{
    return a + b;
}
~~~

Execute the "InjectFix/Fix" menu.

After the patch is successfully created, it will be placed in the project directory with the file name “{Dll Name}.patch.bytes” (for example: “Assembly-CSharp.patch.bytes”). Upload the patch to the phone and load it to see the effect.

Note: If there is a conditional compilation macro for the function to be patched, such as the following code:

~~~csharp
[Patch]
public void Job(int a)
{
#if UNITY_EDITOR
    Foo();
#endif

#if !UNITY_EDITOR
    Bar();
#endif
}
~~~

If you still generate the patch directly in the editor, it will call one more Foo and one less Bar than on the phone, which may lead to various problems, such as wrong logic, or the editor-specific function is called so that the function to be called cannot be found and so on.

When this occurs, you can compile the Assembly-CSharp.dll according to the compile parameters of the platform, and then call IFix.Editor.IFixEditor.GenPatch to generate the patch.

Unity compilation is to create a new file in the project's Temp directory, put the command line parameters into the file, and then compile by executing a command similar (the directory is based on your own unity installation) to the following:

~~~bash
"D:\Program Files\Unity201702\Editor\Data\MonoBleedingEdge\bin\mono.exe" "D:\Program Files\Unity201702\Editor\Data\MonoBleedingEdge\lib\mono\4.5\mcs.exe"  @Temp/UnityTempFile-55a959adddae39f4aaa18507dd165989
~~~

You can try the phone version packaging in the editor, and then copy the temporary file in the Temp directory in the project directory (it will be deleted automatically after compilation, so you need to be fast).

This file will remain unchanged for the most part, with the only change being the C# file list, where it can be changed to be dynamically generated. So the C# file list is generated based on the current project, and the other parts remain unchanged. Then use this file as the input to compile.

##Explore iFix in the editor

In the above process, the patch is loaded on the phone, but if you want to quickly explore the hotfix capability of iFix in the editor, check this document: ["Explore Hotfix in The Editor"](./example_en.md)



```

`Doc/user_manual.md`:

```md
# IFix使用手册

### [IFix.Patch]

##### 用途         

​		在补丁阶段使用；原生代码修复。如果发现某个函数有错误，就可以使用该标签给函数打补丁，打上这个标签的函数，童鞋们就可以随意修改该函数。  

##### 用法

​		该标签只能用在方法上，直接在要修改的函数上面标注一下这个标签即可。

##### 举例

​		这个函数本来的意思是两个值相加，但现在写错了，所以可以给该函数打上[IFix.Patch]标签，然后修改就可以了

```c#
public int Add(int a,int b)
{
    return a*b;
}
```

```c#
[IFix.Patch]
public int Add(int a,int b)
{
    return a+b;
}
```

### [IFix.Interpret]

##### 用途         

​		在补丁阶段使用；新增代码。在补丁阶段，童鞋们还有新的需求，想新增个字段，函数或者类，可以用[IFix.Interpret]标签实现。  

##### 用法

​		该标签可以用在字段，属性，方法，类型上，直接在要新增的代码上面标注一下这个标签即可。

##### 举例

​		新增一个字段

```c#
public class Test
{
    [IFix.Interpret]
    public int intValue = 0;
}
```

​		新增一个属性

```c#
private string name;//这个name字段是原生的

public string Name
{
    [IFix.Interpret]
    set
    {
    	name = value;    
    }
    [IFix.Interpret]
    get
    {
        return name;
    }
}

[IFix.Interpret]
public string Id
{
    set;
    get;
}

```

​		新增一个函数

```c#
[IFix.Interpret]
public int Sub(int a,int b)
{
    return a-b;
}
```

​		新增一个类

```c#
[IFix.Interpret]
public class NewClass
{
    ...
}
```

### [IFix.CustomBridge]

##### 用途         

​		在注入阶段使用； 把一个虚拟机的类适配到原生interface或者把一个虚拟机的函数适配到原生delegate。 

​		什么时候需要用到呢？ 

- 修复代码赋值一个闭包到一个delegate变量；
- 修复代码的Unity协程用了yield return；
- 新增一个函数，赋值到一个delegate变量；
- 新增一个类，赋值到一个原生interface变量；
- 新增函数，用了yield return； 

##### 用法

​		该标签只能用在类上，在童鞋们程序的某个地方，写上一个静态类，里面有一个静态字段，值就是interface和delegate的类型集合
        
        ！！注意，该配置类不能放到Editor目录，且不能内嵌到另外一个类里头。

##### 举例

​		新增一个类，该类实现了一个接口

```c#
public interface ISubSystem
{
	bool running { get; }
    void Print();
}

[IFix.Interpret]
public class SubSystem : ISubSystem
{
    public bool running { get { return true; } }
    public void Print()
    {
        UnityEngine.Debug.Log("SubSystem1.Print");
    }
}
```

​		新增函数（或者修复代码[IFix.Patch]的Unity协程），用到了 yield return 

```c#
[IFix.Interpret]
public IEnumerator TestInterface()
{
    yield return new WaitForSeconds(1);
    UnityEngine.Debug.Log("wait one second");
}
```

​		新增函数（或者修复代码[IFix.Patch]），赋值到一个delegate变量

```c#
public class Test 
{
    public delegate int MyDelegate(int a, int b);
    
    [IFix.Interpret]
    public MyDelegate TestDelegate()
    {
        return (a,b) => a + b;
    }
}
```

```c#
[IFix.CustomBridge]
public static class AdditionalBridge
{
    static List<Type> bridge = new List<Type>()
    {
        typeof(ISubSystem),
        typeof(IEnumerator),
        typeof(Test.MyDelegate)
    };
}
```



### [Configure]

##### 用途         

​		在注入阶段使用；配置类，里面存储的是一些注入时需要注入或过滤的东西。

##### 用法

​		该标签只能用在类上，该类必须在Editor文件夹下  。

##### 举例

```c#
[Configure]
public class TestCfg
{
    
}
```

### [IFix]

##### 用途         

​         在注入阶段使用；用来存储所有你认为将来可能会需要修复的类的集合。该标签和[IFix.Patch]有关联，因为如果发现某个函数需要修复，直接打上[IFix.Patch]标签就可以了，但是前提是，这个需要修复的函数的类必须在[IFix]下。

##### 用法

​		该标签只能用在属性上，Configure类中的一个静态属性，get得到的是可能会需要修复的函数所有类的集合  

##### 举例

​		认为Test类里面的函数可能会出错，所以把它们放到[IFix]标签下，当Test类中的Add函数需要修复，直接打标签修改即可。

```c#
[Configure]
public class TestCfg
{
    [IFix]
    static IEnumerable<Type> hotfix
    {
        get
        {
            return new List<Type>()
            {
              	typeof(Test)
            };
        }
    }
}

public class Test
{
    [IFix.Patch]
    public int Add(int a,int b)
    {
        return a+b;
    }
}
```

### [Filter]

##### 用途         

​         在注入阶段使用；用来存储想要过滤的东西。在注入阶段，凡是在[IFix]标签下的属性里面的值，都会被注入适配代码，但是如果不想对某个函数进行注入，可以用该标签进行过滤。  

##### 用法

​		该标签只能用在方法上，Configure类中的一个静态方法。    

##### 举例

​		觉得Test类里的函数可能会需要修复，但是Test类里面的Div和Mult不可能有问题，可以把这两个函数过滤掉。

```c#
public class Test
{
    [IFix.Patch]
    public int Add(int a,int b)
    {
        return a+b;
    }
    public int Sub(int a,int b)
    {
        return a-b;
    }    
    public int Div(int a,int b)
    {
        return a/b;
    }
    public int Mult(int a,int b)
    {
        return a*b;
    }
}

[Configure]
public class TestCfg
{
    [IFix]
    static IEnumerable<Type> hotfix
    {
        get
        {
            return new List<Type>()
            {
              	typeof(Test)
            };
        }
    }
    [Filter]
    static bool Filter(System.Reflection.MethodInfo methodInfo)
    {
        return methodInfo.DeclaringType.FullName == "Test" 
            && (methodInfo.Name == "Div" || methodInfo.Name == "Mult");
    }
}

```



### 注意事项

- 如果觉得某个类的函数可能会需要修复，那么一定要把该类放到Editor目录下[Configure]类的[IFix]静态字段里；然后才可以对某个函数进行[IFix.Patch]。
- 涉及到interface和delegate，如果把一个虚拟机的类适配到原生interface或者把一个虚拟机的函数适配到原生delegate  ，一定要放到[IFix.CustomBridge]类的静态字段里。
- 打上[Configure]标签的类，必须放在Editor目录下。  
- [IFix]，[Filter]这些标签必须放在打上[Configure]标签的类里。
- 在[IFix.Patch]时，不支持修复泛型函数，不支持修复构造函数，不支持在原生类中新增字段。
- 在[IFix.Interpret]时，不支持新增类继承原生类，不支持新增类是泛型类。





### 总结

|        标签         | 使用阶段 |            用途            |                             用法                             |
| :-----------------: | :------: | :------------------------: | :----------------------------------------------------------: |
|    [IFix.Patch]     |   补丁   |          修复函数          |                        只能放在函数上                        |
|  [IFix.Interpret]   |   补丁   |    新增字段，属性，函数，类型    |                    放在字段，属性，函数，类型上                    |
| [IFix.CustomBridge] |   注入   |  interface和delegate桥接   | 只能放在单独写一个静态类上，存储虚拟机的类适配到原生interface或者虚拟机的函数适配到原生delegate，该类不能放Editor目录 |
|     [Configure]     |   注入   |           配置类           |          只能放在单独写一个存放在Editor目录下的类上          |
|       [IFix]        |   注入   | 可能需要修复函数的类的集合 |            只能放在[Configure]类的一个静态属性上             |
|      [Filter]       |   注入   |     不想发生注入的函数     |            只能放在[Configure]类的一个静态函数上             |


```

`Doc/user_manual_en.md`:

```md
# IFix Manual

### [IFix.Patch]

##### use

​		Used in the patch stage,native code fix. If you find an error in a function, you can use the label to patch the function, and the function with this label can modify the function at will.

##### usage

​		This label can only be used on functions, just mark this label directly on the function to be modified.

##### eg

​		This function originally meant to add two values, but now it is wrong, so you can label the function with [IFix.Patch] and modify it.

```c#
public int Add(int a,int b)
{
    return a*b;
}
```

```c#
[IFix.Patch]
public int Add(int a,int b)
{
    return a+b;
}
```

### [IFix.Interpret]

##### use

​		Used in the patch stage, add code. In the patch stage, people still have new requirements. If you want to add a function or class, you can use the [IFix.Interpret] label to implement it.

##### usage

​		This label can be used in  properties , functions, and classes. Just mark this label directly on the code to be added.

##### eg

​		Add a new property

```c#
private string name;//The name field is native

public string Name
{
    [IFix.Interpret]
    set
    {
    	name = value;    
    }
    [IFix.Interpret]
    get
    {
        return name;
    }
}
```

​		Add a new function 

```c#
[IFix.Interpret]
public int Sub(int a,int b)
{
    return a-b;
}
```

​		Add a new class

```c#
[IFix.Interpret]
public class NewClass
{
    ...
}
```

### [IFix.CustomBridge]

##### use

​		Used in the injection stage, adapt a virtual machine class to the native interface or adapt a virtual machine function to the native delegate.

​		 When do I need to use it?

- Fix the code to assign a closure to a delegate variable;
- The Unity coroutine that fixes the code uses yield return;
- Add a function and assign it to a delegate variable;
- Add a new class and assign it to a native interface variable;
- Added function, using yield return;

##### usage

​		This label can only be used on the class. Somewhere in people's program, write a static class with a static field and the value is the type collection of interface and delegate.

##### eg

​		Add a new class, which implements an interface.

```c#
public interface ISubSystem
{
	bool running { get; }
    void Print();
}

[IFix.Interpret]
public class SubSystem : ISubSystem
{
    public bool running { get { return true; } }
    public void Print()
    {
        UnityEngine.Debug.Log("SubSystem1.Print");
    }
}
```

​		Add a new function (or Unity coroutine with fixed code [IFix.Patch]), using yield return.

```c#
[IFix.Interpret]
public IEnumerator TestInterface()
{
    yield return new WaitForSeconds(1);
    UnityEngine.Debug.Log("wait one second");
}
```

​		Add a new function (or fix the code [IFix.Patch]) and assign it to a delegate variable.

```c#
public class Test 
{
    public delegate int MyDelegate(int a, int b);
    
    [IFix.Interpret]
    public MyDelegate TestDelegate()
    {
        return (a,b) => a + b;
    }
}
```

```c#
[IFix.CustomBridge]
public static class AdditionalBridge
{
    static List<Type> bridge = new List<Type>()
    {
        typeof(ISubSystem),
        typeof(IEnumerator),
        typeof(Test.MyDelegate)
    };
}
```

### [Configure]

##### use

​		Used in the injection stage, configuration class, which stores some things that need to be injected or filtered during injection.

##### usage

​		The label can only be used on the class, the class must be in the Editor folder.

##### eg

```c#
[Configure]
public class TestCfg
{
    
}
```

### [IFix]

##### use

​		Used in the injection stage, used to store a collection of all classes that you think may need to be fixed in the future. This label is related to [IFix.Patch], because if you find that a function needs to be fixed, just label the [IFix.Patch] label , but the premise is that the class of the function that needs to be fixed must be under [IFix].

##### usage

​		This label can only be used on properties, a static property in the Configure class, get is a collection of all classes of functions that may need to be fixed.

##### eg

​		I think the functions in the Test class may be wrong, so put them under the [IFix] label. When the Add function in the Test class needs to be fixed, just label it and modify it.

```c#
[Configure]
public class TestCfg
{
    [IFix]
    static IEnumerable<Type> hotfix
    {
        get
        {
            return new List<Type>()
            {
              	typeof(Test)
            };
        }
    }
}

public class Test
{
    [IFix.Patch]
    public int Add(int a,int b)
    {
        return a+b;
    }
}
```

### [Filter]

##### use

​		Used in the injection stage, used to store what you want to filter. In the injection stage, all values in the properties under the [IFix] label will be injected into the adaptation code, but if you don't want to inject a function, you can use this label to filter.

##### usage

​		This label can only be used on functions, a static function in the Configure class.

##### eg

​		I think the functions in the Test class may be wrong, so put them under the [IFix] label. When the Add function in the Test class needs to be fixed, just label it and modify it.

```c#
public class Test
{
    [IFix.Patch]
    public int Add(int a,int b)
    {
        return a+b;
    }
    public int Sub(int a,int b)
    {
        return a-b;
    }    
    public int Div(int a,int b)
    {
        return a/b;
    }
    public int Mult(int a,int b)
    {
        return a*b;
    }
}

[Configure]
public class TestCfg
{
    [IFix]
    static IEnumerable<Type> hotfix
    {
        get
        {
            return new List<Type>()
            {
              	typeof(Test)
            };
        }
    }
    [Filter]
    static bool Filter(System.Reflection.MethodInfo methodInfo)
    {
        return methodInfo.DeclaringType.FullName == "Test" 
            && (methodInfo.Name == "Div" || methodInfo.Name == "Mult");
    }
}
```

### Precautions

- If you think that a function of a certain class may need to be fixed, you must put the class in the [IFix] static field of the [Configure] class in the Editor directory, then you can perform [IFix.Patch] on a certain function.
- When it comes to interface and delegate, if you adapt a virtual machine class to a native interface or adapt a virtual machine function to a native delegate, you must put it in the static field of the [IFix.CustomBridge] class.
- The class marked with [Configure] must be placed in the Editor directory.
- [IFix], [Filter] These labels must be placed in the class marked with [Configure].
- In [IFix.Patch], it does not support fixing generic functions, repairing constructors, or adding fields to native classes.
- In [IFix.Interpret], new classes are not supported to inherit native classes, and new classes are not supported as generic classes.

### In conclusion

|        Label        | Use stage |                             Use                             |                            Usage                             |
| :-----------------: | :-------: | :---------------------------------------------------------: | :----------------------------------------------------------: |
|    [IFix.Patch]     |   patch   |                        Fix function                         |               Can only be placed on functions                |
|  [IFix.Interpret]   |   patch   |              New properties, functions, types               |               On properties, functions, types                |
| [IFix.CustomBridge] |  inject   |                interface and delegate bridge                | It can only be placed on a separate static class, the class of the storage virtual machine is adapted to the native interface or the function of the virtual machine is adapted to the native delegate |
|     [Configure]     |  inject   |                     Configuration class                     | Can only be placed on a class that is written separately and stored in the Editor directory |
|       [IFix]        |  inject   | The collection of classes that may need to fix the function | Can only be placed on a static property of the [Configure] class |
|      [Filter]       |  inject   |          Functions that do not want to be injected          | Can only be placed on a static function of the [Configure] class |


```

`LICENSE`:

```
Tencent is pleased to support the open source community by making InjectFix available.  

Copyright (C) 2019 Tencent.  All rights reserved.

InjectFix is licensed under the MIT License, except for the third-party components listed below which may be subject to thier corresponding license terms. 

A copy of the MIT License is included in this file.


Other dependency and license:

Open Source Software Licensed Under the MIT License:
--------------------------------------------------------------------
1. Cecil 0.9.6
Copyright (c) 2008 - 2015 Jb Evain Copyright (c) 2008 - 2011 Novell, Inc.



Terms of the MIT License:
---------------------------------------------------
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

```

`README.md`:

```md
![Logo](./Pic/logo.png)

[![license](http://img.shields.io/badge/license-MIT-blue.svg)](https://github.com/Tencent/InjectFix/blob/master/LICENSE)
[![PRs Welcome](https://img.shields.io/badge/PRs-welcome-blue.svg)](https://github.com/Tencent/InjectFix/pulls)
[![Build status](https://travis-ci.org/Tencent/InjectFix.svg?branch=master)](https://travis-ci.org/Tencent/InjectFix)

[(English Documents Available)](README_en.md)

## Unity代码逻辑热修复

可用于Unity业务的bug修复，支持Unity全系列，全平台。

## 几个亮点

* 直接在Unity工程上修改C#即可更新
* 老项目无需修改原有代码即可使用
* 每个游戏一份私有补丁格式，安全更有保障


## 安装

### 编译

* Window下打开源码包的Source\VSProj\build_for_unity.bat，UNITY_HOME变量的值修改为指向本机unity安装目录
* 运行build_for_unity.bat

### 复制

[这里](./Source/UnityProj/)对应的是一个Unity工程目录

* IFixToolKit拷贝到Unity项目的Assets同级目录
* Assets/IFix，Assets/Plugins拷贝到Unity项目的Assets下

## 文档

* [快速入门](./Doc/quick_start.md)
* [使用手册](./Doc/user_manual.md)
* [FAQ](./Doc/faq.md)

## 技术支持

请通过[issue](https://github.com/Tencent/InjectFix/issues)来咨询及反馈问题，便于后续跟踪及检索。


```

`README_en.md`:

```md
![Logo](./Pic/logo.png)

[![license](http://img.shields.io/badge/license-MIT-blue.svg)](https://github.com/Tencent/InjectFix/blob/master/LICENSE)
[![PRs Welcome](https://img.shields.io/badge/PRs-welcome-blue.svg)](https://github.com/Tencent/InjectFix/pulls)
[![Build status](https://travis-ci.org/Tencent/InjectFix.svg?branch=master)](https://travis-ci.org/Tencent/InjectFix)

## Unity code logic hotfix

Can be used for bug fixes in Unity, supporting Unity’s full range

## Highlights

* Modify C# directly on the Unity project to bug fixes
* No need to modify the original code of projects 
* A private patch format for each game for improved security


## Installation

### Compilation

* Open the "Source\VSProj\build_for_unity.bat" file in the source package in Windows, and change the value of the UNITY_HOME parameter to the local installation directory
* Run build_for_unity.bat

### Copy

[Here](./Source/UnityProj/) corresponds to a Unity project directory

* Copy IFixToolKit to a sibling directory of Assets in the Unity project
* Copy Assets/IFix and Assets/Plugins under Assets in the Unity project 

## Doc

* [Quick Start](./Doc/quick_start_en.md)
* [Manual](./Doc/user_manual_en.md)
* [FAQ](./Doc/faq_en.md)

```

`Source/Misc/LiveDotNet/Editor.meta`:

```meta
fileFormatVersion: 2
guid: c50b2a5186536344a94e8922677b9023
folderAsset: yes
timeCreated: 1545961569
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Source/Misc/LiveDotNet/Editor/LiveDotNet.cs`:

```cs
/*
 * Tencent is pleased to support the open source community by making InjectFix available.
 * Copyright (C) 2019 Tencent.  All rights reserved.
 * InjectFix is licensed under the MIT License, except for the third-party components listed in the file 'LICENSE' which may be subject to their corresponding license terms. 
 * This file is subject to the terms and conditions defined in file 'LICENSE', which is part of this source code package.
 */

using UnityEngine;
using UnityEditor;
using System.Net;
using System.Net.Sockets;
using System.IO;
using System;

namespace IFix.Editor
{
    //输入三个信息：
    //  1、平台（ios、android）
    //  2、手机的ip地址
    //  3、端口信息，端口信息要和PatchReceiver配置对应上
    public class LiveDotNet : EditorWindow
    {
        private int platformIndex = 0;
        private string strIp = "";
        private int port = 8080;
        private string[] platforms = new string[] { "ios", "android" };

        [MenuItem("InjectFix/LiveDotNet")]
        private static void OpenWindow()
        {
            LiveDotNet window = GetWindow<LiveDotNet>();
            window.titleContent = new GUIContent("LiveDotNet");
        }

        void OnGUI()
        {
            platformIndex = EditorGUILayout.Popup("Platform: ", platformIndex, platforms);
            strIp = EditorGUILayout.TextField("IP: ", strIp);
            port = EditorGUILayout.IntField("Port: ", port);
            if (GUILayout.Button("patch"))
                doPatch();
        }

        //1、IFixEditor.GenPlatformPatch会生成生成补丁文件
        //2、发送给手机
        void doPatch()
        {
            IFixEditor.Platform platform = platformIndex == 0 ? IFixEditor.Platform.ios : IFixEditor.Platform.android;
            string patchPath = "Temp/Assembly-CSharp.patch.bytes";
            IFixEditor.GenPlatformPatch(platform, "Temp/");

            IPAddress ip;
            if (!IPAddress.TryParse(strIp, out ip))
            {
                throw new FormatException("Invalid ip-adress");
            }

            IPEndPoint remoteEndPoint = new IPEndPoint(ip, port);
            doSend(File.ReadAllBytes(patchPath), remoteEndPoint);
            File.Delete(patchPath);
        }

        //1、对手机建立TCP链接
        //2、发送整个包
        //3、关闭链接
        void doSend(byte[] bytes, IPEndPoint remoteEndPoint)
        {
            try
            {
                Socket sender = new Socket(remoteEndPoint.Address.AddressFamily,
                    SocketType.Stream, ProtocolType.Tcp);

                try
                {
                    sender.Connect(remoteEndPoint);

                    Debug.Log(string.Format("Socket connected to {0}",
                        sender.RemoteEndPoint.ToString()));

                    int bytesSent = sender.Send(bytes);

                    Debug.Log(string.Format("bytesSent = {0}", bytesSent));

                    sender.Shutdown(SocketShutdown.Both);
                    sender.Close();

                }
                catch (ArgumentNullException ane)
                {
                    Debug.LogError(string.Format("ArgumentNullException : {0}", ane.ToString()));
                }
                catch (SocketException se)
                {
                    Debug.LogError(string.Format("SocketException : {0}", se.ToString()));
                }
                catch (Exception e)
                {
                    Debug.LogError(string.Format("Unexpected exception : {0}", e.ToString()));
                }

            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
        }
    }
}

```

`Source/Misc/LiveDotNet/Editor/LiveDotNet.cs.meta`:

```meta
fileFormatVersion: 2
guid: 758fef47c7c67eb46b7259518bbcddfb
timeCreated: 1546050711
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Source/Misc/LiveDotNet/Editor/LiveDotNetConfig.cs`:

```cs
/*
 * Tencent is pleased to support the open source community by making InjectFix available.
 * Copyright (C) 2019 Tencent.  All rights reserved.
 * InjectFix is licensed under the MIT License, except for the third-party components listed in the file 'LICENSE' which may be subject to their corresponding license terms. 
 * This file is subject to the terms and conditions defined in file 'LICENSE', which is part of this source code package.
 */

using System.Collections.Generic;
using IFix;
using System;

//1、配置类必须打[Configure]标签
//2、必须放Editor目录
[Configure]
public class LiveDotNetConfig
{
    [IFix]
    static IEnumerable<Type> hotfix
    {
        get
        {
            return new List<Type>()
            {
                //演示的类
                typeof(RotateCube)
            };
        }
    }
}

```

`Source/Misc/LiveDotNet/Editor/LiveDotNetConfig.cs.meta`:

```meta
fileFormatVersion: 2
guid: cd790a7b1a392b7419c3d553b9d5e9f9
timeCreated: 1545961612
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Source/Misc/LiveDotNet/PatchReceiver.cs`:

```cs
/*
 * Tencent is pleased to support the open source community by making InjectFix available.
 * Copyright (C) 2019 Tencent.  All rights reserved.
 * InjectFix is licensed under the MIT License, except for the third-party components listed in the file 'LICENSE' which may be subject to their corresponding license terms. 
 * This file is subject to the terms and conditions defined in file 'LICENSE', which is part of this source code package.
 */

//!!仅仅简单的开tcp，接收到数据没做校验就直接执行
//!!所以切记这个仅仅用于平时开发调试使用
//!!最终游戏发布包务必删除
#warning "Please remove PatchReceiver.cs from release package."

using UnityEngine;
using System;
using System.Net.Sockets;
using System.Threading;
using System.Net;
using System.IO;
using IFix.Core;

namespace IFix
{
    public class PatchReceiver : MonoBehaviour
    {
        //默认的补丁文件保存名
        const string PERSISTENT_FILE_NAME = "__LAST_RUN_SAVED_PATCH";

        //接收缓冲区的大小
        const int BUFFER_SIZE = 1024;

        Stream patch = null;

        //需要跟LiveDotNet.cs的端口配套
        public int Port = 8080;

        //这个设置为true的话，补丁文件会保存到文件，重启应用后仍然生效
        public bool Persistent = false;

        Socket listener = null;

        string lastRunSavePath;

        //1、监听
        //2、accpet到链接后，接收该链接所有数据
        //3、把数据作为补丁包加载
        void ReceivePatch()
        {
            byte[] bytes = new byte[BUFFER_SIZE];

            //监听所有地址
            IPAddress ipAddress = IPAddress.Parse("0.0.0.0");
            IPEndPoint localEndPoint = new IPEndPoint(ipAddress, Port);

            listener = new Socket(ipAddress.AddressFamily,
                SocketType.Stream, ProtocolType.Tcp);

            try
            {
                listener.Bind(localEndPoint);
                listener.Listen(10);

                while (true)
                {
                    Socket handler = listener.Accept();

                    MemoryStream ms = new MemoryStream();

                    while (true)
                    {
                        int bytesRec = handler.Receive(bytes);
                        if (bytesRec == 0)
                        {
                            break;
                        }
                        ms.Write(bytes, 0, bytesRec);
                    }

                    if (Persistent)
                    {
                        File.WriteAllBytes(lastRunSavePath, ms.GetBuffer());
                    }

                    ms.Position = 0;

                    Debug.Log("Patch Size: " + ms.Length);

                    lock (this)
                    {
                        patch = ms;
                    }

                    try
                    {
                        handler.Shutdown(SocketShutdown.Both);
                    }
                    catch { }
                    finally
                    {
                        handler.Close();
                    }
                }

            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
        }

        //如果设置了持久化，在Awake时加载上次保存的补丁文件
        void Awake()
        {
            lastRunSavePath = Application.persistentDataPath + Path.DirectorySeparatorChar + PERSISTENT_FILE_NAME;
            if (Persistent && File.Exists(lastRunSavePath))
            {
                using (var fs = File.Open(lastRunSavePath, FileMode.Open))
                {
                    PatchManager.Load(fs);
                }
            }
            DontDestroyOnLoad(gameObject);
            //启动线程来接收补丁，不卡主线程，两者通过patch变量来交接数据
            new Thread(ReceivePatch).Start();
        }

        void Update()
        {
            Stream ms = null;
            lock (this)
            {
                ms = patch;
                patch = null;
            }
            if (ms != null)
            {

                PatchManager.Load(ms);
            }
        }

        void OnDestroy()
        {
            listener.Close();
        }
    }
}

```

`Source/Misc/LiveDotNet/PatchReceiver.cs.meta`:

```meta
fileFormatVersion: 2
guid: e6095be9649380746b2eb095364ffdde
timeCreated: 1545893559
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Source/Misc/LiveDotNet/RotateCube.cs`:

```cs
/*
 * Tencent is pleased to support the open source community by making InjectFix available.
 * Copyright (C) 2019 Tencent.  All rights reserved.
 * InjectFix is licensed under the MIT License, except for the third-party components listed in the file 'LICENSE' which may be subject to their corresponding license terms. 
 * This file is subject to the terms and conditions defined in file 'LICENSE', which is part of this source code package.
 */

using UnityEngine;
using IFix;

//用来演示修改代码后，立即刷新到真机
public class RotateCube : MonoBehaviour
{
    public Light theLight;

    [Patch]
    void Update()
    {
        //旋转
        transform.Rotate(Vector3.up * Time.deltaTime * 20);
        //改变颜色
        theLight.color = new Color(Mathf.Sin(Time.time) / 2 + 0.5f, 0, 0, 1);
    }
}

```

`Source/Misc/LiveDotNet/RotateCube.cs.meta`:

```meta
fileFormatVersion: 2
guid: 651f6557eaed01a4181252f1f0d7d100
timeCreated: 1545961537
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Source/Misc/LiveDotNet/RotateCube.unity.meta`:

```meta
fileFormatVersion: 2
guid: ca158dcc718759c42844fd034fc73fc1
timeCreated: 1545961519
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Source/Misc/LiveDotNet/link.xml`:

```xml
<linker>
       <assembly fullname="mscorlib" preserve="all"/>
       <assembly fullname="System" preserve="all"/>
       <assembly fullname="UnityEngine" preserve="all"/>
       <assembly fullname="UnityEngine.UI" preserve="all"/>
</linker>

```

`Source/Misc/LiveDotNet/link.xml.meta`:

```meta
fileFormatVersion: 2
guid: 9edd4d6b3c4585c418b37f48e5d95d4a
timeCreated: 1546068283
licenseType: Pro
TextScriptImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Source/UnityProj/Assets/Helloworld.meta`:

```meta
fileFormatVersion: 2
guid: c002641eaeda46c4eac97f55b29e822e
folderAsset: yes
timeCreated: 1516951777
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Source/UnityProj/Assets/Helloworld/Calc.cs`:

```cs
/*
 * Tencent is pleased to support the open source community by making InjectFix available.
 * Copyright (C) 2019 Tencent.  All rights reserved.
 * InjectFix is licensed under the MIT License, except for the third-party components listed in the file 'LICENSE' which may be subject to their corresponding license terms. 
 * This file is subject to the terms and conditions defined in file 'LICENSE', which is part of this source code package.
 */

namespace IFix.Test
{
    //HelloworldCfg.cs里配置了这个类型
    public class Calculator
    {
        //修改成正确的逻辑后，打开如下注释，生成的补丁将修正该函数
        //[Patch]
        public int Add(int a, int b)
        {
            return a * b;
        }

        public int Sub(int a, int b)
        {
            return a / b;
        }

        public int Mult(int a, int b)
        {
            return a * b;
        }

        public int Div(int a, int b)
        {
            return a / b;
        }
    }
}

```

`Source/UnityProj/Assets/Helloworld/Calc.cs.meta`:

```meta
fileFormatVersion: 2
guid: 0eec1445d4a9ecd4fb343e891585ce26
timeCreated: 1516602092
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Source/UnityProj/Assets/Helloworld/Editor.meta`:

```meta
fileFormatVersion: 2
guid: a1505effa53b9494481b81b9880eb16a
folderAsset: yes
timeCreated: 1517218620
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Source/UnityProj/Assets/Helloworld/Editor/HelloworldCfg.cs`:

```cs
/*
 * Tencent is pleased to support the open source community by making InjectFix available.
 * Copyright (C) 2019 Tencent.  All rights reserved.
 * InjectFix is licensed under the MIT License, except for the third-party components listed in the file 'LICENSE' which may be subject to their corresponding license terms. 
 * This file is subject to the terms and conditions defined in file 'LICENSE', which is part of this source code package.
 */

using System.Collections.Generic;
using IFix;
using System;

//1、配置类必须打[Configure]标签
//2、必须放Editor目录
[Configure]
public class HelloworldCfg
{
    [IFix]
    static IEnumerable<Type> hotfix
    {
        get
        {
            return new List<Type>()
            {
                typeof(Helloworld),
                typeof(IFix.Test.Calculator),
                //AnotherClass在Pro Standard Assets下，会编译到Assembly-CSharp-firstpass.dll下，用来演示多dll的修复
                typeof(AnotherClass),
            };
        }
    }

    [IFix.Filter]
    static bool Filter(System.Reflection.MethodInfo methodInfo)
    {
        return methodInfo.DeclaringType.FullName == "IFix.Test.Calculator" 
            && (methodInfo.Name == "Div" || methodInfo.Name == "Mult");
    }
}

```

`Source/UnityProj/Assets/Helloworld/Editor/HelloworldCfg.cs.meta`:

```meta
fileFormatVersion: 2
guid: 70124019401950146a1351ba7fd5a81a
timeCreated: 1517218683
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Source/UnityProj/Assets/Helloworld/Helloworld.cs`:

```cs
/*
 * Tencent is pleased to support the open source community by making InjectFix available.
 * Copyright (C) 2019 Tencent.  All rights reserved.
 * InjectFix is licensed under the MIT License, except for the third-party components listed in the file 'LICENSE' which may be subject to their corresponding license terms. 
 * This file is subject to the terms and conditions defined in file 'LICENSE', which is part of this source code package.
 */

using UnityEngine;
using IFix.Core;
using System.IO;
using System.Diagnostics;

// 跑不同仔细看文档Doc/example.md
public class Helloworld : MonoBehaviour {

    // check and load patchs
    void Start () {
        VirtualMachine.Info = (s) => UnityEngine.Debug.Log(s);
        //try to load patch for Assembly-CSharp.dll
        var patch = Resources.Load<TextAsset>("Assembly-CSharp.patch");
        if (patch != null)
        {
            UnityEngine.Debug.Log("loading Assembly-CSharp.patch ...");
            var sw = Stopwatch.StartNew();
            PatchManager.Load(new MemoryStream(patch.bytes));
            UnityEngine.Debug.Log("patch Assembly-CSharp.patch, using " + sw.ElapsedMilliseconds + " ms");
        }
        //try to load patch for Assembly-CSharp-firstpass.dll
        patch = Resources.Load<TextAsset>("Assembly-CSharp-firstpass.patch");
        if (patch != null)
        {
            UnityEngine.Debug.Log("loading Assembly-CSharp-firstpass ...");
            var sw = Stopwatch.StartNew();
            PatchManager.Load(new MemoryStream(patch.bytes));
            UnityEngine.Debug.Log("patch Assembly-CSharp-firstpass, using " + sw.ElapsedMilliseconds + " ms");
        }

        test();
    }

    [IFix.Patch]
    void test()
    {
        var calc = new IFix.Test.Calculator();
        //test calc.Add
        UnityEngine.Debug.Log("10 + 9 = " + calc.Add(10, 9));
        //test calc.Sub
        UnityEngine.Debug.Log("10 - 2 = " + calc.Sub(10, 2));

        var anotherClass = new AnotherClass(1);
        //AnotherClass in Assembly-CSharp-firstpass.dll
        var ret = anotherClass.Call(i => i + 1);
        UnityEngine.Debug.Log("anotherClass.Call, ret = " + ret);

        //test for InjectFix/Fix(Android) InjectFix/Fix(IOS) Menu for unity 2018.3 or newer
#if UNITY_2018_3_OR_NEWER
#if UNITY_IOS
        UnityEngine.Debug.Log("UNITY_IOS");
#endif
#if UNITY_EDITOR
        UnityEngine.Debug.Log("UNITY_EDITOR");
#endif
#if UNITY_ANDROID
        UnityEngine.Debug.Log("UNITY_ANDROID");
#endif
#endif
    }
}

```

`Source/UnityProj/Assets/Helloworld/Helloworld.cs.meta`:

```meta
fileFormatVersion: 2
guid: 2cc296780118d7c4983e4a80bca00e8d
timeCreated: 1516951829
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Source/UnityProj/Assets/Helloworld/Helloworld.unity.meta`:

```meta
fileFormatVersion: 2
guid: d12492c44b614b3439d932e13ff2812d
timeCreated: 1516952192
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Source/UnityProj/Assets/IFix.meta`:

```meta
fileFormatVersion: 2
guid: bdf008844f9eb6548a94c2484e24978f
folderAsset: yes
timeCreated: 1515570214
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Source/UnityProj/Assets/IFix/Editor.meta`:

```meta
fileFormatVersion: 2
guid: 89d3afd1ac6383a4bb803e86127d5ed3
folderAsset: yes
timeCreated: 1514965388
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Source/UnityProj/Assets/IFix/Editor/Configure.cs`:

```cs
/*
 * Tencent is pleased to support the open source community by making InjectFix available.
 * Copyright (C) 2019 Tencent.  All rights reserved.
 * InjectFix is licensed under the MIT License, except for the third-party components listed in the file 'LICENSE' which may be subject to their corresponding license terms. 
 * This file is subject to the terms and conditions defined in file 'LICENSE', which is part of this source code package.
 */

using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Collections;
using System;

/************************************************************************************************
    *  配置
    *  1、IFix、Interpret、ReverseWrapper须放到一个打了Configure标签的类里；
    *  2、IFix、Interpret、ReverseWrapper均用打了相应标签的属性来表示；
    *  3、IFix、Interpret、ReverseWrapper配置须放到Editor目录下；
*************************************************************************************************/

namespace IFix
{
    //放置配置的
    [AttributeUsage(AttributeTargets.Class)]
    public class ConfigureAttribute : Attribute
    {

    }

    //默认执行原生代码，能切换到解析执行，必须放在标记了Configure的类里
    [AttributeUsage(AttributeTargets.Property)]
    public class IFixAttribute : Attribute
    {
    }

    //生成反向（解析调用原生）封装器，加速调用性能
    [AttributeUsage(AttributeTargets.Property)]
    public class ReverseWrapperAttribute : Attribute
    {
    }

    [AttributeUsage(AttributeTargets.Method)]
    public class FilterAttribute : Attribute
    {
    }

    public static class Configure
    {
        //
        public static Dictionary<string, List<KeyValuePair<object, int>>> GetConfigureByTags(List<string> tags)
        {
            var types = from assembly in AppDomain.CurrentDomain.GetAssemblies()
                        where !(assembly.ManifestModule is System.Reflection.Emit.ModuleBuilder)
                        from type in assembly.GetTypes()
                        where type.IsDefined(typeof(ConfigureAttribute), false)
                        select type;
            var tagsMap = tags.ToDictionary(t => t, t => new List<KeyValuePair<object, int>>());

            foreach(var type in types)
            {
                foreach (var prop in type.GetProperties(BindingFlags.Static | BindingFlags.Public
                    | BindingFlags.NonPublic | BindingFlags.DeclaredOnly))
                {
                    if (typeof(IEnumerable).IsAssignableFrom(prop.PropertyType))
                    {
                        foreach (var ca in prop.GetCustomAttributes(false))
                        {
                            int flag = 0;
                            var fp = ca.GetType().GetProperty("Flag");
                            if (fp != null)
                            {
                                flag = (int)fp.GetValue(ca, null);
                            }
                            List<KeyValuePair<object, int>> infos;
                            if (tagsMap.TryGetValue(ca.GetType().ToString(), out infos))
                            {
                                foreach (var applyTo in prop.GetValue(null, null) as IEnumerable)
                                {
                                    infos.Add(new KeyValuePair<object, int>(applyTo, flag));
                                }
                            }
                        }
                    }
                }
            }
            return tagsMap;
        }

        public static List<MethodInfo> GetFilters()
        {
            var types = from assembly in AppDomain.CurrentDomain.GetAssemblies()
                        where !(assembly.ManifestModule is System.Reflection.Emit.ModuleBuilder)
                        from type in assembly.GetTypes()
                        where type.IsDefined(typeof(ConfigureAttribute), false)
                        select type;

            List<MethodInfo> filters = new List<MethodInfo>();
            foreach (var type in types)
            {
                foreach (var method in type.GetMethods(BindingFlags.Static | BindingFlags.Public
                    | BindingFlags.NonPublic | BindingFlags.DeclaredOnly))
                {
                    if(method.IsDefined(typeof(IFix.FilterAttribute), false))
                    {
                        filters.Add(method);
                    }
                }
            }
            return filters;
        }

        public static IEnumerable<MethodInfo> GetTagMethods(Type tagType, string searchAssembly)
        {
            return (from assembly in AppDomain.CurrentDomain.GetAssemblies()
                    where !(assembly.ManifestModule is System.Reflection.Emit.ModuleBuilder)
                        && (assembly.GetName().Name == searchAssembly)
                    where assembly.CodeBase.IndexOf("ScriptAssemblies") != -1
                    from type in assembly.GetTypes()
                    from method in type.GetMethods(BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public
                        | BindingFlags.NonPublic)
                    where method.IsDefined(tagType, false)
                    select method);
        }

        public static IEnumerable<FieldInfo> GetTagFields(Type tagType, string searchAssembly)
        {
            return (from assembly in AppDomain.CurrentDomain.GetAssemblies()
                    where !(assembly.ManifestModule is System.Reflection.Emit.ModuleBuilder)
                        && (assembly.GetName().Name == searchAssembly)
                    where assembly.CodeBase.IndexOf("ScriptAssemblies") != -1
                    from type in assembly.GetTypes()
                    from field in type.GetFields(BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public
                        | BindingFlags.NonPublic)
                    where field.IsDefined(tagType, false)
                    select field);
        }

        public static IEnumerable<PropertyInfo> GetTagProperties(Type tagType, string searchAssembly)
        {
            return (from assembly in AppDomain.CurrentDomain.GetAssemblies()
                    where !(assembly.ManifestModule is System.Reflection.Emit.ModuleBuilder)
                        && (assembly.GetName().Name == searchAssembly)
                    where assembly.CodeBase.IndexOf("ScriptAssemblies") != -1
                    from type in assembly.GetTypes()
                    from property in type.GetProperties(BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public
                        | BindingFlags.NonPublic)
                    where property.IsDefined(tagType, false)
                    select property);
        }

        public static IEnumerable<Type> GetTagClasses(Type tagType, string searchAssembly)
        {
            return (from assembly in AppDomain.CurrentDomain.GetAssemblies()
                    where !(assembly.ManifestModule is System.Reflection.Emit.ModuleBuilder)
                        && (assembly.GetName().Name == searchAssembly)
                    where assembly.CodeBase.IndexOf("ScriptAssemblies") != -1
                    from type in assembly.GetTypes()
                    where type.IsDefined(tagType, false)
                    select type
                    );

        }
    }
}

```

`Source/UnityProj/Assets/IFix/Editor/Configure.cs.meta`:

```meta
fileFormatVersion: 2
guid: aca776d82af199a4b9018dcc5c8cceec
timeCreated: 1514363894
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Source/UnityProj/Assets/IFix/Editor/ILFixEditor.cs`:

```cs
/*
 * Tencent is pleased to support the open source community by making InjectFix available.
 * Copyright (C) 2019 Tencent.  All rights reserved.
 * InjectFix is licensed under the MIT License, except for the third-party components listed in the file 'LICENSE' which may be subject to their corresponding license terms. 
 * This file is subject to the terms and conditions defined in file 'LICENSE', which is part of this source code package.
 */

using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using System.IO;
using System;
using System.Linq;
using System.Diagnostics;
using System.Text.RegularExpressions;
using System.Text;
using System.Reflection;
#if UNITY_2018_3_OR_NEWER
using UnityEditor.Build.Player;
#endif

namespace IFix.Editor
{
    //版本选择窗口
    public class VersionSelector : EditorWindow
    {
        public string buttonText = "Patch";
        public string[] options = new string[] {};
        public int index = 0;
        public Action<int> callback = null;

        public static void Show(string[] options, Action<int> callback, string buttonText = "Patch")
        {
            VersionSelector window = GetWindow<VersionSelector>();
            window.options = options;
            window.callback = callback;
            window.buttonText = buttonText;
            window.Show();
        }

        void OnGUI()
        {
            index = EditorGUILayout.Popup("Please select a version: ", index, options);
            if (GUILayout.Button(buttonText))
                doPatch();
        }

        void doPatch()
        {
            if (callback != null)
            {
                callback(index);
            }
            Close();
        }
    }

    public class IFixEditor
    {
        //备份目录
        const string BACKUP_PATH = "./IFixDllBackup";
        //备份文件的时间戳生成格式
        const string TIMESTAMP_FORMAT = "yyyyMMddHHmmss";

        //注入的目标文件夹
        private static string targetAssembliesFolder = "";

        //system("mono ifix.exe [args]")
        public static void CallIFix(List<string> args)
        {
#if UNITY_EDITOR_OSX || UNITY_EDITOR_LINUX
            var mono_path = Path.Combine(Path.GetDirectoryName(typeof(UnityEngine.Debug).Module.FullyQualifiedName),
                "../MonoBleedingEdge/bin/mono");
            if(!File.Exists(mono_path))
            {
                mono_path = Path.Combine(Path.GetDirectoryName(typeof(UnityEngine.Debug).Module.FullyQualifiedName),
                    "../../MonoBleedingEdge/bin/mono");
            }
#elif UNITY_EDITOR_WIN
            var mono_path = Path.Combine(Path.GetDirectoryName(Process.GetCurrentProcess().MainModule.FileName),
                "Data/MonoBleedingEdge/bin/mono.exe");
#endif
            if (!File.Exists(mono_path))
            {
                UnityEngine.Debug.LogError("can not find mono!");
            }
            var inject_tool_path = "./IFixToolKit/IFix.exe";
            //"--runtime = v4.0.30319"
            if (!File.Exists(inject_tool_path))
            {
                UnityEngine.Debug.LogError("please install the ToolKit");
                return;
            }

            Process hotfix_injection = new Process();
            hotfix_injection.StartInfo.FileName = mono_path;
#if UNITY_5_6_OR_NEWER
            hotfix_injection.StartInfo.Arguments = "--debug --runtime=v4.0.30319 \"" + inject_tool_path + "\" \""
#else
            hotfix_injection.StartInfo.Arguments = "--debug \"" + inject_tool_path + "\" \""
#endif
                + string.Join("\" \"", args.ToArray()) + "\"";
            hotfix_injection.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;
            hotfix_injection.StartInfo.RedirectStandardOutput = true;
            hotfix_injection.StartInfo.UseShellExecute = false;
            hotfix_injection.StartInfo.CreateNoWindow = true;
            hotfix_injection.Start();

            //UnityEngine.Debug.Log(hotfix_injection.StartInfo.FileName);
            //UnityEngine.Debug.Log(hotfix_injection.StartInfo.Arguments);

            StringBuilder exceptionInfo = null;
            while(!hotfix_injection.StandardOutput.EndOfStream)
            {
                string line = hotfix_injection.StandardOutput.ReadLine();
                if (exceptionInfo != null)
                {
                    exceptionInfo.AppendLine(line);
                }
                else
                {
                    if (line.StartsWith("Warning:"))
                    {
                        UnityEngine.Debug.LogWarning(line);
                    }
                    else if (line.StartsWith("Error:"))
                    {
                        UnityEngine.Debug.LogError(line);
                    }
                    else if (line.StartsWith("Unhandled Exception:"))
                    {
                        exceptionInfo = new StringBuilder(line);
                    }
                    else
                    {
                        UnityEngine.Debug.Log(line);
                    }
                }
            }
            hotfix_injection.WaitForExit();
            if (exceptionInfo != null)
            {
                UnityEngine.Debug.LogError(exceptionInfo);
            }
        }

        [MenuItem("InjectFix/Inject", false, 1)]
        public static void InjectAssemblys()
        {
            if (EditorApplication.isCompiling || Application.isPlaying)
            {
                UnityEngine.Debug.LogError("compiling or playing");
                return;
            }
            EditorUtility.DisplayProgressBar("Inject", "injecting...", 0);
            try
            {
                InjectAllAssemblys();
            }
            catch(Exception e)
            {
                UnityEngine.Debug.LogError(e);
            }
            EditorUtility.ClearProgressBar();
#if UNITY_2019_3_OR_NEWER
            EditorUtility.RequestScriptReload();
#endif
        }

        public static bool AutoInject = true; //可以在外部禁用掉自动注入

        public static bool InjectOnce = false; //AutoInjectAssemblys只调用一次，可以防止自动化打包时，很多场景导致AutoInjectAssemblys被多次调用

        static bool injected = false;

        [UnityEditor.Callbacks.PostProcessScene]
        public static void AutoInjectAssemblys()
        {
            if (AutoInject && !injected)
            {
                InjectAllAssemblys();
                if (InjectOnce)
                {
                    injected = true;
                }
            }
        }

        //获取备份文件信息
        public static void GetBackupInfo(out string[] backups, out string[] timestamps)
        {
            string pattern = @"Assembly-CSharp-(\d{14})\.dll$";
            Regex r = new Regex(pattern);

            var allBackup = Directory.GetFiles(BACKUP_PATH).Where(path => r.Match(path).Success)
                .Select(path => path.Replace('\\', '/')).ToList();
            allBackup.Sort();

            backups = allBackup.Select(path => r.Match(path).Groups[1].Captures[0].Value).ToArray();
            timestamps = allBackup.Select(path => DateTime.ParseExact(r.Match(path).Groups[1].Captures[0].Value,
                TIMESTAMP_FORMAT, System.Globalization.CultureInfo.InvariantCulture)
                .ToString("yyyy-MM-dd hh:mm:ss tt")).ToArray();
        }

        //选择备份
        public static void SelectBackup(string buttonText, Action<string> cb)
        {
            string[] backups;
            string[] timestamps;
            GetBackupInfo(out backups, out timestamps);

            VersionSelector.Show(timestamps.ToArray(), index =>
            {
                cb(backups[index]);
            }, buttonText);
        }

        /// <summary>
        /// 对指定的程序集注入
        /// </summary>
        /// <param name="assembly">程序集路径</param>
        public static void InjectAssembly(string assembly)
        {
            var configure = Configure.GetConfigureByTags(new List<string>() {
                "IFix.IFixAttribute",
                "IFix.InterpretAttribute",
                "IFix.ReverseWrapperAttribute",
            });

            var filters = Configure.GetFilters();

            var processCfgPath = "./process_cfg";

            //该程序集是否有配置了些类，如果没有就跳过注入操作
            bool hasSomethingToDo = false;

            var blackList = new List<MethodInfo>();

            using (BinaryWriter writer = new BinaryWriter(new FileStream(processCfgPath, FileMode.Create,
                FileAccess.Write)))
            {
                writer.Write(configure.Count);

                foreach (var kv in configure)
                {
                    writer.Write(kv.Key);

                    var typeList = kv.Value.Where(item => item.Key is Type)
                        .Select(item => new KeyValuePair<Type, int>(item.Key as Type, item.Value))
                        .Where(item => item.Key.Assembly.GetName().Name == assembly)
                        .ToList();
                    writer.Write(typeList.Count);

                    if (typeList.Count > 0)
                    {
                        hasSomethingToDo = true;
                    }

                    foreach (var cfgItem in typeList)
                    {
                        writer.Write(GetCecilTypeName(cfgItem.Key));
                        writer.Write(cfgItem.Value);
                        if (filters.Count > 0 && kv.Key == "IFix.IFixAttribute")
                        {
                            foreach(var method in cfgItem.Key.GetMethods(BindingFlags.Instance 
                                | BindingFlags.Static | BindingFlags.Public 
                                | BindingFlags.NonPublic | BindingFlags.DeclaredOnly))
                            {
                                foreach(var filter in filters)
                                {
                                    if ((bool)filter.Invoke(null, new object[]
                                    {
                                        method
                                    }))
                                    {
                                        blackList.Add(method);
                                    }
                                }
                            }
                        }
                    }
                }

                writeMethods(writer, blackList);
            }

            if (hasSomethingToDo)
            {

                var core_path = "./Assets/Plugins/IFix.Core.dll";
                var assembly_path = string.Format("./Library/{0}/{1}.dll", targetAssembliesFolder, assembly);
                var patch_path = string.Format("./{0}.ill.bytes", assembly);
                List<string> args = new List<string>() { "-inject", core_path, assembly_path,
                    processCfgPath, patch_path, assembly_path };

                foreach (var path in
                    (from asm in AppDomain.CurrentDomain.GetAssemblies()
                        select Path.GetDirectoryName(asm.ManifestModule.FullyQualifiedName)).Distinct())
                {
                    try
                    {
                        //UnityEngine.Debug.Log("searchPath:" + path);
                        args.Add(path);
                    }
                    catch { }
                }

                CallIFix(args);
            }

            File.Delete(processCfgPath);
        }

        /// <summary>
        /// 对injectAssemblys里的程序集进行注入，然后备份
        /// </summary>
        public static void InjectAllAssemblys()
        {
            if (EditorApplication.isCompiling || Application.isPlaying)
            {
                return;
            }

            targetAssembliesFolder = GetScriptAssembliesFolder();

            foreach (var assembly in injectAssemblys)
            {
                InjectAssembly(assembly);
            }
            
            //doBackup(DateTime.Now.ToString(TIMESTAMP_FORMAT));

            AssetDatabase.Refresh();
        }

        private static string GetScriptAssembliesFolder()
        {
            var assembliesFolder = "PlayerScriptAssemblies";
            if (!Directory.Exists(string.Format("./Library/{0}/", assembliesFolder)))
            {
                assembliesFolder = "ScriptAssemblies";
            }
            return assembliesFolder;
        }

        //默认的注入及备份程序集
        //另外可以直接调用InjectAssembly对其它程序集进行注入。
        static string[] injectAssemblys = new string[]
        {
            "Assembly-CSharp",
            "Assembly-CSharp-firstpass"
        };

        /// <summary>
        /// 把注入后的程序集备份
        /// </summary>
        /// <param name="ts">时间戳</param>
        static void doBackup(string ts)
        {
            if (!Directory.Exists(BACKUP_PATH))
            {
                Directory.CreateDirectory(BACKUP_PATH);
            }

            var scriptAssembliesDir = string.Format("./Library/{0}/", targetAssembliesFolder);

            foreach (var assembly in injectAssemblys)
            {
                var dllFile = string.Format("{0}{1}.dll", scriptAssembliesDir, assembly);
                if (!File.Exists(dllFile))
                {
                    continue;
                }
                File.Copy(dllFile, string.Format("{0}/{1}-{2}.dll", BACKUP_PATH, assembly, ts), true);

                var mdbFile = string.Format("{0}{1}.dll.mdb", scriptAssembliesDir, assembly);
                if (File.Exists(mdbFile))
                {
                    File.Copy(mdbFile, string.Format("{0}/{1}-{2}.dll.mdb", BACKUP_PATH, assembly, ts), true);
                }

                var pdbFile = string.Format("{0}{1}.dll.pdb", scriptAssembliesDir, assembly);
                if (File.Exists(pdbFile))
                {
                    File.Copy(pdbFile, string.Format("{0}/{1}-{2}.dll.pdb", BACKUP_PATH, assembly, ts), true);
                }
            }
        }

        /// <summary>
        /// 恢复某个选定的备份
        /// </summary>
        /// <param name="ts">时间戳</param>
        static void doRestore(string ts)
        {
            var scriptAssembliesDir = string.Format("./Library/{0}/", targetAssembliesFolder);

            foreach (var assembly in injectAssemblys)
            {
                var dllFile = string.Format("{0}/{1}-{2}.dll", BACKUP_PATH, assembly, ts);
                if (!File.Exists(dllFile))
                {
                    continue;
                }
                File.Copy(dllFile, string.Format("{0}{1}.dll", scriptAssembliesDir, assembly), true);
                UnityEngine.Debug.Log("Revert to: " + dllFile);

                var mdbFile = string.Format("{0}/{1}-{2}.dll.mdb", BACKUP_PATH, assembly, ts);
                if (File.Exists(mdbFile))
                {
                    File.Copy(mdbFile, string.Format("{0}{1}.dll.mdb", scriptAssembliesDir, assembly), true);
                    UnityEngine.Debug.Log("Revert to: " + mdbFile);
                }

                var pdbFile = string.Format("{0}/{1}-{2}.dll.pdb", BACKUP_PATH, assembly, ts);
                if (File.Exists(pdbFile))
                {
                    File.Copy(pdbFile, string.Format("{0}{1}.dll.pdb", scriptAssembliesDir, assembly), true);
                    UnityEngine.Debug.Log("Revert to: " + pdbFile);
                }
            }
        }

        //cecil里的类名表示和.net标准并不一样，这里做些转换
        static string GetCecilTypeName(Type type)
        {
            if (type.IsByRef && type.GetElementType().IsGenericType)
            {
                return GetCecilTypeName(type.GetElementType()) + "&";
            }
            else if (type.IsGenericType)
            {
                if (type.IsGenericTypeDefinition)
                {
                    return type.ToString().Replace('+', '/').Replace('[', '<').Replace(']', '>');
                }
                else
                {
                    return Regex.Replace(type.ToString().Replace('+', '/'), @"(`\d).+", "$1")
                        + "<" + string.Join(",", type.GetGenericArguments().Select(t => GetCecilTypeName(t))
                        .ToArray()) + ">";
                }
            }
            else
            {
                return type.FullName.Replace('+', '/');
            }
        }

        //目前支持的平台编译
        public enum Platform
        {
            android,
            ios,
            standalone
        }

        //缓存：解析好的编译参数
        private static Dictionary<Platform, string> compileTemplates = new Dictionary<Platform, string>();

        //解析unity的编译参数
        private static string parseCompileTemplate(string path)
        {
            return string.Join("\n", File.ReadAllLines(path).Where(line => !line.StartsWith("Assets/")
                && !line.StartsWith("\"Assets/")
                && !line.StartsWith("'Assets/")
                && !line.StartsWith("-r:Assets/")
                && !line.StartsWith("-r:\"Assets/")
                && !line.StartsWith("-r:'Assets/")
                && !line.StartsWith("-out")
                ).ToArray());
        }

        //对路径预处理，然后添加到StringBuilder
        //规则：如果路径含空格，则加上双引号
        static void appendFile(StringBuilder sb, string path)
        {
            if (path.IndexOf(' ') > 0)
            {
                sb.Append('"');
                sb.Append(path);
                sb.Append('"');
                sb.AppendLine();
            }
            else
            {
                sb.AppendLine(path);
            }
        }

        //自动加入源码
        private static void appendDirectory(StringBuilder src, string dir)
        {
            foreach (var file in Directory.GetFiles(dir))
            {
                //排除调Editor下的东西
                if (file.IndexOf(Path.DirectorySeparatorChar + "Editor" + Path.DirectorySeparatorChar) > 0 )
                {
                    continue;
                }
                //排除Assembly-CSharp-firstpass
                if (file.Substring(file.Length - 3).ToLower() == ".cs")
                {
                    if (file.StartsWith("Assets" + Path.DirectorySeparatorChar + "Plugins") ||
                        file.StartsWith("Assets" + Path.DirectorySeparatorChar + "Standard Assets") ||
                        file.StartsWith("Assets" + Path.DirectorySeparatorChar + "Pro Standard Assets"))
                    {
                        continue;
                    }
                    appendFile(src, file);
                }
            }

            foreach(var subDir in Directory.GetDirectories(dir))
            {
                appendDirectory(src, subDir);
            }
        }

        //通过模板文件，获取编译参数
        private static string getCompileArguments(Platform platform, string output)
        {
            string compileTemplate;
            if (!compileTemplates.TryGetValue(platform, out compileTemplate))
            {
#if UNITY_EDITOR_WIN
                var hostPlatform = "win";
#elif UNITY_EDITOR_OSX
                var hostPlatform = "osx";
#else
                var hostPlatform = "linux";
#endif
                var path = "IFixToolKit/" + platform + "." + hostPlatform + ".tpl";
                if (!File.Exists(path))
                {
                    path = "IFixToolKit/" + platform + ".tpl";
                    if (!File.Exists(path))
                    {
                        throw new InvalidOperationException("please put template file for " + platform
                            + " in IFixToolKit directory!");
                    }
                }
                compileTemplate = parseCompileTemplate(path);
                compileTemplates.Add(platform, compileTemplate);
            }
            StringBuilder cmd = new StringBuilder();
            StringBuilder src = new StringBuilder();
            StringBuilder dll = new StringBuilder();

            appendDirectory(src, "Assets");
            var projectDir = Application.dataPath.Replace(Path.DirectorySeparatorChar, '/');
            foreach (var assembly in AppDomain.CurrentDomain.GetAssemblies())
            {
                try
                {
#if (UNITY_EDITOR || XLUA_GENERAL) && !NET_STANDARD_2_0
                    if (!(assembly.ManifestModule is System.Reflection.Emit.ModuleBuilder))
                    {
#endif
                        var assemblyPath = assembly.ManifestModule.FullyQualifiedName
                            .Replace(Path.DirectorySeparatorChar, '/');
                        if (assemblyPath.StartsWith(projectDir))
                        {
                            dll.Append("-r:");
                            appendFile(dll, assemblyPath.Replace(projectDir, "Assets"));
                        }
#if (UNITY_EDITOR || XLUA_GENERAL) && !NET_STANDARD_2_0
                    }
#endif
                } catch { }
            }

            cmd.AppendLine(compileTemplate);
            cmd.Append(dll.ToString());
            cmd.Append(src.ToString());
            cmd.AppendLine("-sdk:2");
            cmd.Append("-out:");
            appendFile(cmd, output);

            return cmd.ToString();
        }

        //1、解析编译参数（处理元文件之外的编译参数）
        //2、搜索工程的c#源码，加上编译参数编译
        //3、编译Assembly-CSharp.dll
        //TODO: 只支持Assembly-CSharp.dll，但较新版本Unity已经支持多dll拆分
        //TODO: 目前的做法挺繁琐的，需要用户去获取Unity的编译命令文件，更好的做法应该是直接
        public static void Compile(string compileArgFile)
        {
#if UNITY_EDITOR_OSX || UNITY_EDITOR_LINUX
            var monoPath = Path.Combine(Path.GetDirectoryName(typeof(UnityEngine.Debug).Module.FullyQualifiedName),
                "../MonoBleedingEdge/bin/mono");
            var mcsPath = Path.Combine(Path.GetDirectoryName(typeof(UnityEngine.Debug).Module.FullyQualifiedName),
                "../MonoBleedingEdge/lib/mono/4.5/mcs.exe");
            if(!File.Exists(monoPath))
            {
                monoPath = Path.Combine(Path.GetDirectoryName(typeof(UnityEngine.Debug).Module.FullyQualifiedName),
                    "../../MonoBleedingEdge/bin/mono");
                mcsPath = Path.Combine(Path.GetDirectoryName(typeof(UnityEngine.Debug).Module.FullyQualifiedName),
                    "../../MonoBleedingEdge/lib/mono/4.5/mcs.exe");
            }
#elif UNITY_EDITOR_WIN
            var monoPath = Path.Combine(Path.GetDirectoryName(Process.GetCurrentProcess().MainModule.FileName),
                "Data/MonoBleedingEdge/bin/mono.exe");
            var mcsPath = Path.Combine(Path.GetDirectoryName(Process.GetCurrentProcess().MainModule.FileName),
                "Data/MonoBleedingEdge/lib/mono/4.5/mcs.exe");
#endif
            if (!File.Exists(monoPath))
            {
                UnityEngine.Debug.LogError("can not find mono!");
            }

            Process compileProcess = new Process();
            compileProcess.StartInfo.FileName = monoPath;
            compileProcess.StartInfo.Arguments = "\"" + mcsPath + "\" " + "@" + compileArgFile;
            compileProcess.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;
            compileProcess.StartInfo.RedirectStandardOutput = true;
            compileProcess.StartInfo.RedirectStandardError = true;
            compileProcess.StartInfo.UseShellExecute = false;
            compileProcess.StartInfo.CreateNoWindow = true;
            compileProcess.Start();

            //UnityEngine.Debug.Log(hotfix_injection.StartInfo.FileName);
            //UnityEngine.Debug.Log(hotfix_injection.StartInfo.Arguments);

            while (!compileProcess.StandardError.EndOfStream)
            {
                UnityEngine.Debug.LogError(compileProcess.StandardError.ReadLine());
            }

            while (!compileProcess.StandardOutput.EndOfStream)
            {
                UnityEngine.Debug.Log(compileProcess.StandardOutput.ReadLine());
            }
            
            compileProcess.WaitForExit();
        }

        //生成特定平台的patch
        public static void GenPlatformPatch(Platform platform, string patchOutputDir,
            string corePath = "./Assets/Plugins/IFix.Core.dll")
        {
            var outputDir = "Temp/ifix";
            Directory.CreateDirectory("Temp");
            Directory.CreateDirectory(outputDir);
#if UNITY_2018_3_OR_NEWER
            ScriptCompilationSettings scriptCompilationSettings = new ScriptCompilationSettings();
            if (platform == Platform.android)
            {
                scriptCompilationSettings.group = BuildTargetGroup.Android;
                scriptCompilationSettings.target = BuildTarget.Android;
            }
            else if(platform == Platform.ios)
            {
                scriptCompilationSettings.group = BuildTargetGroup.iOS;
                scriptCompilationSettings.target = BuildTarget.iOS;
            }
            else
            {
                scriptCompilationSettings.group = BuildTargetGroup.Standalone;
                scriptCompilationSettings.target = BuildTarget.StandaloneWindows;
            }

            ScriptCompilationResult scriptCompilationResult = PlayerBuildInterface.CompilePlayerScripts(scriptCompilationSettings, outputDir);

            foreach (var assembly in injectAssemblys)
            {
                GenPatch(assembly, string.Format("{0}/{1}.dll", outputDir, assembly),
                    "./Assets/Plugins/IFix.Core.dll", string.Format("{0}{1}.patch.bytes", patchOutputDir, assembly));
            }
#else
            throw new NotImplementedException();
            //var compileArgFile = "Temp/ifix/unity_" + platform + "_compile_argument";
            //var tmpDllPath = "Temp/ifix/Assembly-CSharp.dll";
            //File.WriteAllText(compileArgFile, getCompileArguments(platform, tmpDllPath));
            //先编译dll到Temp目录下
            //Compile(compileArgFile);
            //对编译后的dll生成补丁
            //GenPatch("Assembly-CSharp", tmpDllPath, corePath, patchPath);

            //File.Delete(compileArgFile);
            //File.Delete(tmpDllPath);
            //File.Delete(tmpDllPath + ".mdb");
#endif
        }

        //把方法签名写入文件
        //由于目前不支持泛型函数的patch，所以函数签名为方法名+参数类型
        static void writeMethods(BinaryWriter writer, List<MethodInfo> methods)
        {
            var methodGroups = methods.GroupBy(m => m.DeclaringType).ToList();
            writer.Write(methodGroups.Count);
            foreach (var methodGroup in methodGroups)
            {
                writer.Write(GetCecilTypeName(methodGroup.Key));
                writer.Write(methodGroup.Count());
                foreach (var method in methodGroup)
                {
                    writer.Write(method.Name);
                    writer.Write(GetCecilTypeName(method.ReturnType));
                    writer.Write(method.GetParameters().Length);
                    foreach (var parameter in method.GetParameters())
                    {
                        writer.Write(parameter.IsOut);
                        writer.Write(GetCecilTypeName(parameter.ParameterType));
                    }
                }
            }
        }

        static void writeFields(BinaryWriter writer, List<FieldInfo> fields)
        {
            var fieldGroups = fields.GroupBy(m => m.DeclaringType).ToList();
            writer.Write(fieldGroups.Count);
            foreach (var fieldGroup in fieldGroups)
            {
                writer.Write(GetCecilTypeName(fieldGroup.Key));
                writer.Write(fieldGroup.Count());
                foreach (var field in fieldGroup)
                {
                    writer.Write(field.Name);
                    writer.Write(GetCecilTypeName(field.FieldType));
                }
            }
        }

        static void writeProperties(BinaryWriter writer, List<PropertyInfo> properties)
        {
            var PropertyGroups = properties.GroupBy(m => m.DeclaringType).ToList();
            writer.Write(PropertyGroups.Count);
            foreach (var PropertyGroup in PropertyGroups)
            {
                writer.Write(GetCecilTypeName(PropertyGroup.Key));
                writer.Write(PropertyGroup.Count());
                foreach (var Property in PropertyGroup)
                {
                    writer.Write(Property.Name);
                    writer.Write(GetCecilTypeName(Property.PropertyType));
                }
            }
        }

        static void writeClasses(BinaryWriter writer, List<Type> classes)
        {
            writer.Write(classes.Count);
            foreach (var classGroup in classes)
            {
                writer.Write(GetCecilTypeName(classGroup));
            }
        }

        static bool hasGenericParameter(Type type)
        {
            if (type.IsByRef || type.IsArray)
            {
                return hasGenericParameter(type.GetElementType());
            }
            if (type.IsGenericType)
            {
                foreach (var typeArg in type.GetGenericArguments())
                {
                    if (hasGenericParameter(typeArg))
                    {
                        return true;
                    }
                }
                return false;
            }
            return type.IsGenericParameter;
        }

        static bool hasGenericParameter(MethodBase method)
        {
            if (method.IsGenericMethodDefinition || method.IsGenericMethod) return true;
            if (!method.IsConstructor && hasGenericParameter((method as MethodInfo).ReturnType)) return true;

            foreach (var param in method.GetParameters())
            {
                if (hasGenericParameter(param.ParameterType))
                {
                    return true;
                }
            }
            return false;

        }

        /// <summary>
        /// 生成patch
        /// </summary>
        /// <param name="assembly">程序集名，用来过滤配置</param>
        /// <param name="assemblyCSharpPath">程序集路径</param>
        /// <param name="corePath">IFix.Core.dll所在路径</param>
        /// <param name="patchPath">生成的patch的保存路径</param>
        public static void GenPatch(string assembly, string assemblyCSharpPath
            = "./Library/ScriptAssemblies/Assembly-CSharp.dll", 
            string corePath = "./Assets/Plugins/IFix.Core.dll", string patchPath = "Assembly-CSharp.patch.bytes")
        {
            var patchMethods = Configure.GetTagMethods(typeof(PatchAttribute), assembly).ToList();
            var genericMethod = patchMethods.FirstOrDefault(m => hasGenericParameter(m));
            if (genericMethod != null)
            {
                throw new InvalidDataException("not support generic method: " + genericMethod);
            }

            if (patchMethods.Count == 0)
            {
                return;
            }

            var newMethods = Configure.GetTagMethods(typeof(InterpretAttribute), assembly).ToList();
            var newFields = Configure.GetTagFields(typeof(InterpretAttribute), assembly).ToList();
            var newProperties = Configure.GetTagProperties(typeof(InterpretAttribute), assembly).ToList();
            var newClasses = Configure.GetTagClasses(typeof(InterpretAttribute), assembly).ToList();
            genericMethod = newMethods.FirstOrDefault(m => hasGenericParameter(m));
            if (genericMethod != null)
            {
                throw new InvalidDataException("not support generic method: " + genericMethod);
            }

            var processCfgPath = "./process_cfg";

            using (BinaryWriter writer = new BinaryWriter(new FileStream(processCfgPath, FileMode.Create,
                FileAccess.Write)))
            {
                writeMethods(writer, patchMethods);
                writeMethods(writer, newMethods);
                writeFields(writer, newFields);
                writeProperties(writer, newProperties);
                writeClasses(writer, newClasses);
            }

            List<string> args = new List<string>() { "-patch", corePath, assemblyCSharpPath, "null",
                processCfgPath, patchPath };

            foreach (var path in
                (from asm in AppDomain.CurrentDomain.GetAssemblies()
                    select Path.GetDirectoryName(asm.ManifestModule.FullyQualifiedName)).Distinct())
            {
                try
                {
                    //UnityEngine.Debug.Log("searchPath:" + path);
                    args.Add(path);
                }
                catch { }
            }

            CallIFix(args);

            File.Delete(processCfgPath);

            AssetDatabase.Refresh();
        }

        [MenuItem("InjectFix/Fix", false, 2)]
        public static void Patch()
        {
            EditorUtility.DisplayProgressBar("Generate Patch for Edtior", "patching...", 0);
            try
            {
                foreach (var assembly in injectAssemblys)
                {
                    var assembly_path = string.Format("./Library/{0}/{1}.dll", GetScriptAssembliesFolder(), assembly);
                    GenPatch(assembly, assembly_path, "./Assets/Plugins/IFix.Core.dll",
                        string.Format("{0}.patch.bytes", assembly));
                }
            }
            catch (Exception e)
            {
                UnityEngine.Debug.LogError(e);
            }
            EditorUtility.ClearProgressBar();
        }

#if UNITY_2018_3_OR_NEWER
        [MenuItem("InjectFix/Fix(Android)", false, 3)]
        public static void CompileToAndroid()
        {
            EditorUtility.DisplayProgressBar("Generate Patch for Android", "patching...", 0);
            try
            {
                GenPlatformPatch(Platform.android, "");
            }
            catch(Exception e)
            {
                UnityEngine.Debug.LogError(e);
            }
            EditorUtility.ClearProgressBar();
        }

        [MenuItem("InjectFix/Fix(IOS)", false, 4)]
        public static void CompileToIOS()
        {
            EditorUtility.DisplayProgressBar("Generate Patch for IOS", "patching...", 0);
            try
            {
                GenPlatformPatch(Platform.ios, "");
            }
            catch(Exception e)
            {
                UnityEngine.Debug.LogError(e);
            }
            EditorUtility.ClearProgressBar();
        }
#endif
    }
}

```

`Source/UnityProj/Assets/IFix/Editor/ILFixEditor.cs.meta`:

```meta
fileFormatVersion: 2
guid: ea1d006806821c945ad3dfda116f04f7
timeCreated: 1514863799
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Source/UnityProj/Assets/NewClass/Editor/NewClassTestCfg.cs`:

```cs
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using IFix;
using System;

[Configure]
public class NewClassTestCfg {

	[IFix]
    static IEnumerable<Type> hotfix
    {
        get
        {
            return new List<Type>()
            {
                typeof(NewClassTest)
            };
        }
    }
}

```

`Source/UnityProj/Assets/NewClass/NewClassTest.cs`:

```cs
using System;
using System.Collections.Generic;
using UnityEngine;
using IFix.Core;
using System.IO;

//1、执行菜单“InjectFix/Fix”生成补丁；
//2、注释“NewBehaviourScript”，“SubSystem2”两个类，以及NewClassTest的Init函数里头new SubSystem2的那行语句；
//3、执行菜单“InjectFix/Inject”，模拟线上没有“NewBehaviourScript”，“SubSystem2”的版本；
//4、NewClassTest.cs拖到场景，运行看下效果，此时只加载SubSystem1；
//5、把生成的补丁拷贝到Resources下，再次运行看下效果；

public interface IMonoBehaviour
{
    void Start();//简单demo，只定义了Start方法，实际Awake，Update，OnDestroy。。。都类似

    void Update();
}

public interface ISubSystem
{
    bool running { get; }

    void Destroy();

    void Start();

    void Stop();
}

public class SubSystem1 : ISubSystem
{
    public bool running { get { return true; } }

    public void Start()
    {
        Debug.Log("SubSystem1.Start");
    }

    public void Stop()
    {
        Debug.Log("SubSystem1.Stop");
    }

    public void Destroy()
    {
        Debug.Log("SubSystem1.Destroy");
    }
}

//[IFix.Interpret]
public class NewBehaviourScript : IMonoBehaviour
{
    private int tick = 0;

    public void Start()
    {
        Debug.Log("NewBehaviourScript.Start");
    }

    public void Update()
    {
        if (tick++ % 60 == 0)
        {
            Debug.Log("NewBehaviourScript.Update");
        }
    }
}

//[IFix.Interpret]
public class SubSystem2 : ISubSystem
{
    public bool running { get { return true; } }

    public void Start()
    {
        Debug.Log("SubSystem2.Start, create GameObject and attach a NewBehaviourScript");
        var go = new GameObject("hehe");
        var behaviour = go.AddComponent(typeof(VMBehaviourScript)) as VMBehaviourScript;
        behaviour.VMMonoBehaviour = new NewBehaviourScript();
    }

    public void Stop()
    {
        Debug.Log("SubSystem2.Stop");
    }

    public void Destroy()
    {
        Debug.Log("SubSystem2.Destroy");
    }
}

public class NewClassTest : MonoBehaviour
{
    List<ISubSystem> subsystems = new List<ISubSystem>();

    void Awake()
    {
        var patch = Resources.Load<TextAsset>("Assembly-CSharp.patch");
        if (patch != null)
        {
            Debug.Log("loading Assembly-CSharp.patch ...");
            var sw = System.Diagnostics.Stopwatch.StartNew();
            PatchManager.Load(new MemoryStream(patch.bytes));
            Debug.Log("patch Assembly-CSharp.patch, using " + sw.ElapsedMilliseconds + " ms");
        }
        Init();
    }

    [IFix.Patch]
    private void Init()
    {
        subsystems.Add(new SubSystem1());
        subsystems.Add(new SubSystem2());
    }


    void Start()
    {
        foreach (var subSystem in subsystems)
        {
            subSystem.Start();
        }
    }

    void OnDestroy()
    {
        foreach (var subSystem in subsystems)
        {
            subSystem.Destroy();
        }
    }
}



[IFix.CustomBridge]
public static class AdditionalBridge
{
    static List<Type> bridge = new List<Type>()
    {
        typeof(ISubSystem),
        typeof(IMonoBehaviour)
    };
}
```

`Source/UnityProj/Assets/NewClass/NewClassTest.cs.meta`:

```meta
fileFormatVersion: 2
guid: 979878655427a4b4c835f28982c140ae
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Source/UnityProj/Assets/NewClass/VMBehaviourScript.cs`:

```cs
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class VMBehaviourScript : MonoBehaviour
{
    public IMonoBehaviour VMMonoBehaviour { get;set; }

    void Start()
    {
        if (VMMonoBehaviour != null)
        {
            VMMonoBehaviour.Start();
        }
    }

    // Update is called once per frame
    void Update()
    {
        if (VMMonoBehaviour != null)
        {
            VMMonoBehaviour.Update();
        }
    }
}

```

`Source/UnityProj/Assets/NewClass/VMBehaviourScript.cs.meta`:

```meta
fileFormatVersion: 2
guid: b02b35b5e1bd10f48b1cdcad58a741d5
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Source/UnityProj/Assets/Plugins.meta`:

```meta
fileFormatVersion: 2
guid: abb87f1363fe99d4eb0fbae15511b424
folderAsset: yes
timeCreated: 1514967159
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Source/UnityProj/Assets/Plugins/IFix.Core.dll.meta`:

```meta
fileFormatVersion: 2
guid: 7c6cf326f60d243479929e308c3123fb
PluginImporter:
  externalObjects: {}
  serializedVersion: 2
  iconMap: {}
  executionOrder: {}
  defineConstraints: []
  isPreloaded: 0
  isOverridable: 0
  isExplicitlyReferenced: 0
  validateReferences: 1
  platformData:
  - first:
      Any: 
    second:
      enabled: 1
      settings: {}
  - first:
      Editor: Editor
    second:
      enabled: 0
      settings:
        DefaultValueInitialized: true
  - first:
      Windows Store Apps: WindowsStoreApps
    second:
      enabled: 0
      settings:
        CPU: AnyCPU
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Source/UnityProj/Assets/Pro Standard Assets.meta`:

```meta
fileFormatVersion: 2
guid: b38a9df162ddbe244ab2ae3ffb102602
folderAsset: yes
timeCreated: 1547191258
licenseType: Pro
DefaultImporter:
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Source/UnityProj/Assets/Pro Standard Assets/AnotherClass.cs`:

```cs
/*
 * Tencent is pleased to support the open source community by making InjectFix available.
 * Copyright (C) 2019 Tencent.  All rights reserved.
 * InjectFix is licensed under the MIT License, except for the third-party components listed in the file 'LICENSE' which may be subject to their corresponding license terms. 
 * This file is subject to the terms and conditions defined in file 'LICENSE', which is part of this source code package.
 */

using System;
using UnityEngine;

//只是用来演示Assembly-CSharp-firstpass.dll的修复
//所以，该文件要放在Pro Standard Assets或者Plugins目录下
//逻辑很简单，没什么好说的
public class AnotherClass
{
    int pass;

    public AnotherClass(int init)
    {
        this.pass = init;
    }

    [IFix.Patch]
    public int Call(Func<int, int> func)
    {
        int sum = 0;
        for(int i =0; i < 2; i++)
        {
            sum += func(pass);
            Debug.Log(string.Format("i = {0}, sum = {1}", i, sum));
        }
        return sum;
    }

}

```

`Source/UnityProj/Assets/Pro Standard Assets/AnotherClass.cs.meta`:

```meta
fileFormatVersion: 2
guid: f6a1f7172c4f29c4ba54dcf12c71ca6c
timeCreated: 1547190305
licenseType: Pro
MonoImporter:
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant: 

```

`Source/VSProj/ShuffleInstruction.cs`:

```cs
/*
 * Tencent is pleased to support the open source community by making InjectFix available.
 * Copyright (C) 2019 Tencent.  All rights reserved.
 * InjectFix is licensed under the MIT License, except for the third-party components listed in the file 'LICENSE' which may be subject to their corresponding license terms. 
 * This file is subject to the terms and conditions defined in file 'LICENSE', which is part of this source code package.
 */

using System;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using System.Collections.Generic;
using System.Collections;
using System.Text;

namespace IFix
{
    public static class Program
    {
        private static string ConfuseKey = string.Empty;

        static string[] Shuffle(string[] codes)
        {
            Random r = string.IsNullOrEmpty(ConfuseKey) ? 
                        new Random(DateTime.Now.Millisecond) : new Random(ConfuseKey.GetHashCode() + 1);
            
            for (int i = codes.Length - 1; i >= 0; i--)
            {
                int cardIndex = r.Next(i);
                string temp = codes[cardIndex];
                codes[cardIndex] = codes[i];
                codes[i] = temp;

            }

            return codes;
        }

        static void Main(string[] args)
        {
            var des = args[1];

            if (args.Length >= 3)
                ConfuseKey = args[2];

            //已经生成了就不重新生成了
            if (File.Exists(des))
            {
                Console.WriteLine(des + " existed");
                return;
            }

            using (var output = new StreamWriter(
                new FileStream(args[1], FileMode.Create, FileAccess.Write), Encoding.UTF8))
            {
                string fileContent = File.ReadAllText(args[0], Encoding.Default);
                //假定指令定义是这样的
                //public enum Code
                //{
                //    Code1,
                //    Code2,
                //    ...
                //    CodeN,
                //}
                Regex regex = new Regex(
                    "(?<head>.*public\\s+enum\\s+Code\\s+{[^\\n]*\\n)(?<code>[^,}]+,[^\\n]*\\n)+(?<tail>\\s+}.+)",
                    RegexOptions.ExplicitCapture | RegexOptions.Singleline);
                Match match = regex.Match(fileContent);

                var head = (match.Groups["head"].Captures[0] as Capture).Value;
                output.Write(head);

                //打乱指令定义
                var codes = Shuffle(match.Groups["code"].Captures.Cast<Capture>()
                    .Select(capture => capture.Value).ToArray());

                foreach (var code in codes)
                {
                    //output.WriteLine("// -----------------code---------------");
                    output.Write(code);
                }

                //生成随机的magic code
                Random r = string.IsNullOrEmpty(ConfuseKey) ?
                            new Random(DateTime.Now.Millisecond) : new Random(ConfuseKey.GetHashCode());
                ulong magic = (uint)r.Next();
                magic = (magic << 32);
                magic = magic | ((uint)r.Next());

                var tail = (match.Groups["tail"].Captures[0] as Capture).Value;
                output.Write(Regex.Replace(tail,
                    @"(public\s+const\s+ulong\s+INSTRUCTION_FORMAT_MAGIC\s*=)(\s*\d+)(\s*;)",
                        "$1 " + magic + "$3"));
            }

            Console.WriteLine(des + " gen");
        }
    }
}
```

`Source/VSProj/Src/Builder/FileVirtualMachineBuilder.cs`:

```cs
/*
 * Tencent is pleased to support the open source community by making InjectFix available.
 * Copyright (C) 2019 Tencent.  All rights reserved.
 * InjectFix is licensed under the MIT License, except for the third-party components listed in the file 'LICENSE' which may be subject to their corresponding license terms. 
 * This file is subject to the terms and conditions defined in file 'LICENSE', which is part of this source code package.
 */

namespace IFix.Core
{
    using System.Collections.Generic;
    using System;
    using System.IO;
    using System.Reflection;
    using System.Linq;
    //using System.Text;

    public class IDTagAttribute : Attribute
    {
        public int ID;

        public IDTagAttribute(int id)
        {
            ID = id;
        }
    }

    public static class PatchManager
    {
        static Dictionary<Assembly, Action> removers = new Dictionary<Assembly, Action>();

        static public VirtualMachine Load(string filepath)
        {
            using (FileStream fs = File.Open(filepath, FileMode.Open))
            {
                return Load(fs);
            }
        }

        // #lizard forgives
        static MethodBase readMethod(BinaryReader reader, Type[] externTypes)
        {
            bool isGenericInstance = reader.ReadBoolean();
            BindingFlags flag = BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Static
                | BindingFlags.NonPublic | BindingFlags.Public;
            if (isGenericInstance)
            {
                Type declaringType = externTypes[reader.ReadInt32()];
                string methodName = reader.ReadString();
                //Console.WriteLine("load generic method: " + declaringType + " ?? " + methodName);
                int genericArgCount = reader.ReadInt32();
                //Console.WriteLine("genericArgCount:" + genericArgCount);
                Type[] genericArgs = new Type[genericArgCount];
                for (int j = 0; j < genericArgCount; j++)
                {
                    genericArgs[j] = externTypes[reader.ReadInt32()];
                    //Console.WriteLine(j + " ga:" + genericArgs[j]);
                }
                int paramCount = reader.ReadInt32();
                object[] paramMatchInfo = new object[paramCount];
                for (int j = 0; j < paramCount; j++)
                {
                    bool isGeneric = reader.ReadBoolean();
                    paramMatchInfo[j] = isGeneric ? (object)reader.ReadString() : externTypes[reader.ReadInt32()];
                }
                MethodInfo matchMethod = null;
                foreach (var method in declaringType.GetMethods(flag))
                {
                    var paramInfos = method.GetParameters();

                    Type[] genericArgInfos = null;
                    if (method.IsGenericMethodDefinition)
                    {
                        //UnityEngine.Debug.Log("get generic arg of "+ method);
                        genericArgInfos = method.GetGenericArguments();
                    }
                    bool paramMatch = paramInfos.Length == paramCount && method.Name == methodName;
                    if (paramMatch && genericArgCount > 0) // need a generic method
                    {
                        if (!method.IsGenericMethodDefinition || genericArgInfos.Length != genericArgCount)
                        {
                            paramMatch = false;
                        }
                    }
                    if (paramMatch)
                    {
                        for (int j = 0; j < paramCount; j++)
                        {
                            string strMatchInfo = paramMatchInfo[j] as string;
                            if (strMatchInfo != null)
                            {
                                if (!method.IsGenericMethodDefinition)
                                {
                                    paramMatch = false;
                                    break;
                                }
                                strMatchInfo = System.Text.RegularExpressions.Regex
                                    .Replace(strMatchInfo, @"!!\d+", m =>
                                        genericArgInfos[int.Parse(m.Value.Substring(2))].Name);
                                if (strMatchInfo != paramInfos[j].ParameterType.ToString())
                                {
                                    //Console.WriteLine("gp not match:" + strMatchInfo + " ??? "
                                    //    + paramInfos[j].ParameterType.ToString());
                                    paramMatch = false;
                                    break;
                                }
                            }
                            else
                            {
                                if ((paramMatchInfo[j] as Type) != paramInfos[j].ParameterType)
                                {
                                    //Console.WriteLine("pt not match:" + paramMatchInfo[j] + " ??? "
                                    //    + paramInfos[j].ParameterType);
                                    paramMatch = false;
                                    break;
                                }
                            }
                        }
                    }
                    if (paramMatch)
                    {
                        matchMethod = method;
                        break;
                    }
                }
                if (matchMethod == null)
                {
                    throw new Exception("can not load generic method [" + methodName + "] of " + declaringType);
                }
                return matchMethod.MakeGenericMethod(genericArgs);
            }
            else
            {
                Type declaringType = externTypes[reader.ReadInt32()];
                string methodName = reader.ReadString();
                int paramCount = reader.ReadInt32();
                //Console.WriteLine("load no generic method: " + declaringType + " ?? " + methodName + " pc "
                //    + paramCount);
                Type[] paramTypes = new Type[paramCount];
                for (int j = 0; j < paramCount; j++)
                {
                    paramTypes[j] = externTypes[reader.ReadInt32()];
                }
                bool isConstructor = methodName == ".ctor" || methodName == ".cctor";
                MethodBase externMethod = null;
                //StringBuilder sb = new StringBuilder();
                //sb.Append("method to find name: ");
                //sb.AppendLine(methodName);
                //for (int j = 0; j < paramCount; j++)
                //{
                //    sb.Append("p ");
                //    sb.Append(j);
                //    sb.Append(": ");
                //    sb.AppendLine(paramTypes[j].ToString());
                //}
                if (isConstructor)
                {
                    externMethod = declaringType.GetConstructor(BindingFlags.Public | (methodName == ".ctor" ?
                        BindingFlags.Instance : BindingFlags.Static) |
                        BindingFlags.NonPublic, null, paramTypes, null);
                    // : (MethodBase)(declaringType.GetMethod(methodName, paramTypes));
                }
                else
                {
                    foreach (var method in declaringType.GetMethods(flag))
                    {
                        if (method.Name == methodName && !method.IsGenericMethodDefinition
                            && method.GetParameters().Length == paramCount)
                        {
                            var methodParameterTypes = method.GetParameters().Select(p => p.ParameterType);
                            if (methodParameterTypes.SequenceEqual(paramTypes))
                            {
                                externMethod = method;
                                break;
                            }
                            //else
                            //{
                            //    var mptlist = methodParameterTypes.ToList();
                            //    for (int j = 0; j < mptlist.Count; j++)
                            //    {
                            //        sb.Append("not match p ");
                            //        sb.Append(j);
                            //        sb.Append(": ");
                            //        sb.AppendLine(mptlist[j].ToString());
                            //    }
                            //}
                        }
                    }
                }
                if (externMethod == null)
                {
                    throw new Exception("can not load method [" + methodName + "] of "
                        + declaringType/* + ", info:\r\n" + sb.ToString()*/);
                }
                return externMethod;
            }
        }

        static FieldInfo getRedirectField(MethodBase method)
        {
            var redirectTypeName = "IFix.RedirectTo." + method.DeclaringType.AssemblyQualifiedName;
            var redirectType = Type.GetType(redirectTypeName);
            if (redirectType == null)
            {
                throw new Exception("cat not find redirect type: " + redirectTypeName);
            }
            IDTagAttribute id = Attribute.GetCustomAttribute(method, typeof(IDTagAttribute), false) as IDTagAttribute;
            var redirectFieldName = string.Format("_rf_{0}{1}", method.Name, id == null ? 0 : id.ID);
            var redirectField = redirectType.GetField(redirectFieldName, BindingFlags.DeclaredOnly | BindingFlags.Static
                | BindingFlags.Public);
            if (redirectField == null)
            {
                throw new Exception(string.Format("cat not find redirect field: {0}, for {1}", redirectFieldName,
                    redirectType));
            }
            return redirectField;
        }

        static int getMapId(List<Type> idMapArray, MethodBase method)
        {
            IDTagAttribute id = Attribute.GetCustomAttribute(method, typeof(IDTagAttribute), false) as IDTagAttribute;
            int overrideId = id == null ? 0 : id.ID;
            var fieldName = string.Format("{0}-{1}{2}", method.DeclaringType.FullName.Replace('.', '-')
                .Replace('+', '-'), method.Name, overrideId);
            FieldInfo field = null;
            
            for (int i = 0; i < idMapArray.Count; i++)
            {
                field = idMapArray[i].GetField(fieldName);
                if (field != null) break;
            }
            if (field == null)
            {
                throw new Exception(string.Format("cat not find id field: {0}, for {1}", fieldName, method));
            }
            return (int)field.GetValue(null);
        }

        static int[] readSlotInfo(BinaryReader reader, Dictionary<MethodInfo, int> itfMethodToId, Type[] externTypes,
            int maxId)
        {
            int interfaceCount = reader.ReadInt32();

            if (interfaceCount == 0) return null;

            int[] slots = new int[maxId + 1];
            for (int j = 0; j < slots.Length; j++)
            {
                slots[j] = -1;
            }
            
            //VirtualMachine._Info(string.Format("-------{0}----------", interfaceCount));
            for (int i = 0; i < interfaceCount; i++)
            {
                var itfId = reader.ReadInt32();
                var itf = externTypes[itfId];
                //VirtualMachine._Info(itf.ToString());
                foreach (var method in itf.GetMethods(BindingFlags.DeclaredOnly | BindingFlags.Public
                    | BindingFlags.Instance))
                {
                    int methodId = reader.ReadInt32();
                    if (!itfMethodToId.ContainsKey(method))
                    {
                        throw new Exception("can not find slot for " + method + " of " + itf);
                    }
                    slots[itfMethodToId[method]] = methodId;
                    //VirtualMachine._Info(string.Format("<<< {0} [{1}]", method, methodId));
                }
            }
            return slots;
        }

        // #lizard forgives
        unsafe static public VirtualMachine Load(Stream stream, bool checkNew = true)
        {
            List<IntPtr> nativePointers = new List<IntPtr>();

            IntPtr nativePointer;
            Instruction** unmanagedCodes = null;
            Type[] externTypes;
            MethodBase[] externMethods;
            List<ExceptionHandler[]> exceptionHandlers = new List<ExceptionHandler[]>();
            Dictionary<int, NewFieldInfo> newFieldInfo = new Dictionary<int, NewFieldInfo>();
            string[] internStrings;
            FieldInfo[] fieldInfos;
            Type[] staticFieldTypes;
            int[] cctors;
            AnonymousStoreyInfo[] anonymousStoreyInfos;

            using (BinaryReader reader = new BinaryReader(stream))
            {
                var instructionMagic = reader.ReadUInt64();
                if (instructionMagic != Instruction.INSTRUCTION_FORMAT_MAGIC)
                {
                    throw new Exception("instruction magic not match, expect "
                        + Instruction.INSTRUCTION_FORMAT_MAGIC
                        + ", but got " + instructionMagic);
                }

                var interfaceBridgeTypeName = reader.ReadString();
                var interfaceBridgeType = Type.GetType(interfaceBridgeTypeName);
                if (interfaceBridgeType == null)
                {
                    throw new Exception("assembly may be not injected yet, cat find "
                        + interfaceBridgeTypeName);
                }

                //BindingFlags flag = BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Static
                //    | BindingFlags.NonPublic |BindingFlags.Public;
                int externTypeCount = reader.ReadInt32();
                externTypes = new Type[externTypeCount];
                for (int i = 0; i < externTypeCount; i++)
                {
                    var assemblyQualifiedName = reader.ReadString();
                    externTypes[i] = Type.GetType(assemblyQualifiedName);
                    if (externTypes[i] == null)
                    {
                        throw new Exception("can not load type [" + assemblyQualifiedName + "]");
                    }
                }

                int methodCount = reader.ReadInt32();

                nativePointer = System.Runtime.InteropServices.Marshal.AllocHGlobal(sizeof(Instruction*) * methodCount);
                unmanagedCodes = (Instruction**)nativePointer.ToPointer();
                nativePointers.Add(nativePointer);

                for (int j = 0; j < methodCount; j++)
                {
                    //Console.WriteLine("==================method" + j + "==================");
                    int codeSize = reader.ReadInt32();
                    nativePointer = System.Runtime.InteropServices.Marshal.AllocHGlobal(sizeof(Instruction) * codeSize);
                    var unmanagedCode = (Instruction*)nativePointer.ToPointer();
                    for (int i = 0; i < codeSize; i++)
                    {
                        unmanagedCode[i].Code = (Code)reader.ReadInt32();
                        unmanagedCode[i].Operand = reader.ReadInt32();
                        //Console.WriteLine(i + " Code=" + unmanagedCode[i].Code + " Operand="
                        //    + unmanagedCode[i].Operand);
                    }
                    unmanagedCodes[j] = unmanagedCode;
                    nativePointers.Add(nativePointer);
                    ExceptionHandler[] ehsOfMethod = new ExceptionHandler[reader.ReadInt32()];
                    for (int i = 0; i < ehsOfMethod.Length; i++)
                    {
                        ExceptionHandler ehOfMethod = new ExceptionHandler();
                        ehOfMethod.HandlerType = (ExceptionHandlerType)reader.ReadInt32();
                        ehOfMethod.CatchTypeId = reader.ReadInt32();
                        ehOfMethod.TryStart = reader.ReadInt32();
                        ehOfMethod.TryEnd = reader.ReadInt32();
                        ehOfMethod.HandlerStart = reader.ReadInt32();
                        ehOfMethod.HandlerEnd = reader.ReadInt32();
                        ehsOfMethod[i] = ehOfMethod;
                        if (ehOfMethod.HandlerType == ExceptionHandlerType.Catch)
                        {
                            ehOfMethod.CatchType = ehOfMethod.CatchTypeId == -1 ?
                                typeof(object) : externTypes[ehOfMethod.CatchTypeId];
                        }
                    }
                    exceptionHandlers.Add(ehsOfMethod);
                }

                int externMethodCount = reader.ReadInt32();
                externMethods = new MethodBase[externMethodCount];
                for (int i = 0; i < externMethodCount; i++)
                {
                    externMethods[i] = readMethod(reader, externTypes);
                }

                int internStringsCount = reader.ReadInt32();
                internStrings = new string[internStringsCount];
                for (int i = 0; i < internStringsCount; i++)
                {
                    internStrings[i] = reader.ReadString();
                }

                fieldInfos = new FieldInfo[reader.ReadInt32()];
                for (int i = 0; i < fieldInfos.Length; i++)
                {
                    var isNewField = reader.ReadBoolean();
                    var declaringType = externTypes[reader.ReadInt32()];
                    var fieldName = reader.ReadString();
                    
                    fieldInfos[i] = declaringType.GetField(fieldName, 
                        BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static);

                    if(!isNewField)
                    {
                        if(fieldInfos[i] == null)
                        {
                            throw new Exception("can not load field [" + fieldName + "] " + " of " + declaringType);
                        }
                    }
                    else
                    {
                        var fieldType = externTypes[reader.ReadInt32()];
                        var methodId = reader.ReadInt32();
                        
                        if(fieldInfos[i] == null)
                        {
                            newFieldInfo.Add(i, new NewFieldInfo{
                                Name = fieldName,
                                FieldType = fieldType,
                                DeclaringType = declaringType,
                                MethodId = methodId,
                            });
                        }
                        else
                        {
                            if(fieldInfos[i].FieldType != fieldType)
                            {
                                throw new Exception("can not change existing field [" + declaringType + "." + fieldName + "]'s type " + " from " + fieldInfos[i].FieldType + " to " + fieldType);
                            }
                            else
                            {
                                if(checkNew)
                                    throw new Exception(declaringType + "." + fieldName + " is expected to be a new field , but it already exists ");
                            }
                        }
                    }
                }

                staticFieldTypes = new Type[reader.ReadInt32()];
                cctors = new int[staticFieldTypes.Length];
                for (int i = 0; i < staticFieldTypes.Length; i++)
                {
                    staticFieldTypes[i] = externTypes[reader.ReadInt32()];
                    cctors[i] = reader.ReadInt32();
                }

                Dictionary<MethodInfo, int> itfMethodToId = new Dictionary<MethodInfo, int>();
                int maxId = 0;

                foreach (var itf in interfaceBridgeType.GetInterfaces())
                {
                    InterfaceMapping map = interfaceBridgeType.GetInterfaceMap(itf);
                    for (int i = 0; i < map.InterfaceMethods.Length; i++)
                    {
                        IDTagAttribute idTag = Attribute.GetCustomAttribute(map.TargetMethods[i],
                            typeof(IDTagAttribute), false) as IDTagAttribute;
                        MethodInfo im = map.InterfaceMethods[i];
                        if (idTag == null)
                        {
                            throw new Exception(string.Format("can not find id for {0}", im));
                        }
                        int id = idTag.ID;
                        //VirtualMachine._Info(string.Format("{0} [{1}]", im, id));
                        maxId = id > maxId ? id : maxId;
                        itfMethodToId.Add(im, id);
                    }
                }

                anonymousStoreyInfos = new AnonymousStoreyInfo[reader.ReadInt32()];
                for (int i = 0; i < anonymousStoreyInfos.Length; i++)
                {
                    int fieldNum = reader.ReadInt32();
                    int[] fieldTypes = new int[fieldNum];
                    for (int fieldIdx = 0; fieldIdx < fieldNum; ++fieldIdx)
                    {
                        fieldTypes[fieldIdx] = reader.ReadInt32();
                    }
                    int ctorId = reader.ReadInt32();
                    int ctorParamNum = reader.ReadInt32();
                    var slots = readSlotInfo(reader, itfMethodToId, externTypes, maxId);
                    
                    int virtualMethodNum = reader.ReadInt32();
                    int[] vTable = new int[virtualMethodNum];
                    for (int vm = 0 ;vm < virtualMethodNum; vm++)
                    {
                        vTable[vm] = reader.ReadInt32();
                    }
                    anonymousStoreyInfos[i] = new AnonymousStoreyInfo()
                    {
                        CtorId = ctorId,
                        FieldNum = fieldNum,
                        FieldTypes = fieldTypes,
                        CtorParamNum = ctorParamNum,
                        Slots = slots,
                        VTable = vTable
                    };
                }


                var virtualMachine = new VirtualMachine(unmanagedCodes, () =>
                {
                    for (int i = 0; i < nativePointers.Count; i++)
                    {
                        System.Runtime.InteropServices.Marshal.FreeHGlobal(nativePointers[i]);
                    }
                })
                {
                    ExternTypes = externTypes,
                    ExternMethods = externMethods,
                    ExceptionHandlers = exceptionHandlers.ToArray(),
                    InternStrings = internStrings,
                    FieldInfos = fieldInfos,
                    NewFieldInfos = newFieldInfo,
                    AnonymousStoreyInfos = anonymousStoreyInfos,
                    StaticFieldTypes = staticFieldTypes,
                    Cctors = cctors
                };

                var wrappersManagerImplName = reader.ReadString();
                WrappersManager wrapperManager = Activator.CreateInstance(Type.GetType(wrappersManagerImplName, true),
                    virtualMachine) as WrappersManager;
                if (wrapperManager == null)
                {
                    throw new Exception("can not create WrappersManager!");
                }
                virtualMachine.WrappersManager = wrapperManager;

                var assemblyStr = reader.ReadString();
                var idMapList = new List<Type>();
                for(int i = 0; i < 100; i++)
                {

                    var idMapType = Type.GetType("IFix.IDMAP" + i + assemblyStr, false);
                    if (idMapType == null) break;
                    idMapList.Add(idMapType);
                }

                lock (removers)
                {
                    var assembly = wrapperManager.GetType().Assembly;
                    Action remover;
                    if (removers.TryGetValue(assembly, out remover))
                    {
                        removers.Remove(assembly);
                        remover();
                    }

                    //int fixCount = reader.ReadInt32();
                    //FieldInfo[] toSet = new FieldInfo[fixCount];

                    //for (int i = 0; i < fixCount; i++)
                    //{
                    //    var fixMethod = readMethod(reader, externTypes);
                    //    var fixMethodIdx = reader.ReadInt32();
                    //    var redirectField = getRedirectField(fixMethod);
                    //    toSet[i] = redirectField;
                    //    var wrapper = wrapperManager.CreateWrapper(fixMethodIdx);
                    //    if (wrapper == null)
                    //    {
                    //        throw new Exception("create wrapper fail");
                    //    }
                    //    redirectField.SetValue(null, wrapper);
                    //}

                    //removers[assembly] = () =>
                    //{
                    //    for (int i = 0; i < fixCount; i++)
                    //    {
                    //        toSet[i].SetValue(null, null);
                    //    }
                    //};

                    int fixCount = reader.ReadInt32();
                    int[] methodIdArray = new int[fixCount];
                    int[] posArray = new int[fixCount];
                    int maxPos = -1;
                    for (int i = 0; i < fixCount; i++)
                    {
                        var fixMethod = readMethod(reader, externTypes);
                        var fixMethodId = reader.ReadInt32();
                        var pos = getMapId(idMapList, fixMethod);
                        methodIdArray[i] = fixMethodId;
                        posArray[i] = pos;
                        if (pos > maxPos)
                        {
                            maxPos = pos;
                        }
                    }
                    Array arr = wrapperManager.InitWrapperArray(maxPos + 1) as Array;
                    for (int i = 0; i < fixCount; i++)
                    {
                        var wrapper = wrapperManager.CreateWrapper(methodIdArray[i]);
                        if (wrapper == null)
                        {
                            throw new Exception("create wrapper fail");
                        }
                        arr.SetValue(wrapper, posArray[i]);
                    }
                    removers[assembly] = () =>
                    {
                        wrapperManager.InitWrapperArray(0);
                    };
                }

                if (checkNew)
                {
                    int newClassCount = reader.ReadInt32();
                    for (int i = 0; i < newClassCount; i++)
                    {
                        var newClassFullName = reader.ReadString();
                        var newClassName = Type.GetType(newClassFullName);
                        if (newClassName != null)
                        {
                            throw new Exception(newClassName + " class is expected to be a new class , but it already exists ");
                        }
                    }
                }

                return virtualMachine;
            }
        }

        public static void Unload(Assembly assembly)
        {
            lock (removers)
            {
                Action remover;
                if (removers.TryGetValue(assembly, out remover))
                {
                    removers.Remove(assembly);
                    remover();
                }
            }
        }
    }
}
```

`Source/VSProj/Src/Builder/SimpleVirtualMachineBuilder.cs`:

```cs
/*
 * Tencent is pleased to support the open source community by making InjectFix available.
 * Copyright (C) 2019 Tencent.  All rights reserved.
 * InjectFix is licensed under the MIT License, except for the third-party components listed in the file 'LICENSE' which may be subject to their corresponding license terms. 
 * This file is subject to the terms and conditions defined in file 'LICENSE', which is part of this source code package.
 */

namespace IFix.Core
{
    using System.Collections.Generic;
    using System;


    public class SimpleVirtualMachineBuilder
    {
        unsafe static public VirtualMachine CreateVirtualMachine(int loopCount)
        {
            Instruction[][] methods = new Instruction[][]
            {
                new Instruction[] //int add(int a, int b)
                {
                    new Instruction {Code = Code.StackSpace, Operand = 2 },
                    new Instruction {Code = Code.Ldarg, Operand = 0 },
                    new Instruction {Code = Code.Ldarg, Operand = 1 },
                    new Instruction {Code = Code.Add },
                    new Instruction {Code = Code.Ret , Operand = 1},
                },
                new Instruction[] // void test()
                {
                    new Instruction {Code = Code.StackSpace, Operand = (1 << 16) | 2}, // local | maxstack
                    //TODO: local init
                    new Instruction {Code = Code.Ldc_I4, Operand = 0 }, //1
                    new Instruction {Code = Code.Stloc, Operand = 0},   //2
                    new Instruction {Code = Code.Br, Operand =  9}, // 3

                    new Instruction {Code = Code.Ldc_I4, Operand = 1 }, //4
                    new Instruction {Code = Code.Ldc_I4, Operand = 2 }, //5
                    new Instruction {Code = Code.Call, Operand = (2 << 16) | 0}, //6
                    new Instruction {Code = Code.Pop }, //7

                    new Instruction {Code = Code.Ldloc, Operand = 0 }, //8
                    new Instruction {Code = Code.Ldc_I4, Operand = 1 }, //9
                    new Instruction {Code = Code.Add }, //10
                    new Instruction {Code = Code.Stloc, Operand = 0 }, //11

                    new Instruction {Code = Code.Ldloc, Operand = 0 }, // 12
                    new Instruction {Code = Code.Ldc_I4, Operand =  loopCount}, // 13
                    new Instruction {Code = Code.Blt, Operand = -10 }, //14

                    new Instruction {Code = Code.Ret, Operand = 0 }
                }
            };

            List<IntPtr> nativePointers = new List<IntPtr>();

            IntPtr nativePointer = System.Runtime.InteropServices.Marshal.AllocHGlobal(
                sizeof(Instruction*) * methods.Length);
            Instruction** unmanagedCodes = (Instruction**)nativePointer.ToPointer();
            nativePointers.Add(nativePointer);

            for (int i = 0; i < methods.Length; i++)
            {
                nativePointer = System.Runtime.InteropServices.Marshal.AllocHGlobal(
                    sizeof(Instruction) * methods[i].Length);
                unmanagedCodes[i] = (Instruction*)nativePointer.ToPointer();
                for (int j = 0; j < methods[i].Length; j++)
                {
                    unmanagedCodes[i][j] = methods[i][j];
                }
                nativePointers.Add(nativePointer);
            }

            return new VirtualMachine(unmanagedCodes, () =>
            {
                for (int i = 0; i < nativePointers.Count; i++)
                {
                    System.Runtime.InteropServices.Marshal.FreeHGlobal(nativePointers[i]);
                }
            });
        }
    }
}

```

`Source/VSProj/Src/Core/AnonymousStorey.cs`:

```cs
/*
 * Tencent is pleased to support the open source community by making InjectFix available.
 * Copyright (C) 2019 Tencent.  All rights reserved.
 * InjectFix is licensed under the MIT License, except for the third-party components listed in the file 'LICENSE' which may be subject to their corresponding license terms. 
 * This file is subject to the terms and conditions defined in file 'LICENSE', which is part of this source code package.
 */

using System.Reflection;
using System;

namespace IFix.Core
{
    //匿名类模拟
    public class AnonymousStorey
    {
        Value[] unmanagedFields;
        object[] managedFields;
        internal int typeId;
        protected VirtualMachine virtualMachine;
        int equalMethodId;
        int finalizeMethodId;
        int getHashCodeMethodId;
        int toStringMethodId;

        public AnonymousStorey(int fieldNum, int[] fieldTypes,int typeID, int[] vTable, VirtualMachine virtualMachine)
        {
            unmanagedFields = new Value[fieldNum];
            managedFields = new object[fieldNum];
            for (int i = 0; i < fieldTypes.Length; ++i)
            {
                if (fieldTypes[i] > 0)
                {
                    unmanagedFields[i].Type = ValueType.ValueType;
                    unmanagedFields[i].Value1 = i;
                    int id = fieldTypes[i] - 1;
                    managedFields[i] = Activator.CreateInstance(virtualMachine.ExternTypes[id]);
                }
                else if (fieldTypes[i] == -2)
                {
                    unmanagedFields[i].Type = ValueType.Object;
                    unmanagedFields[i].Value1 = i;
                }
            }
            typeId = typeID;
            this.virtualMachine = virtualMachine;
            equalMethodId = vTable[0];
            finalizeMethodId = vTable[1];
            getHashCodeMethodId = vTable[2];
            toStringMethodId = vTable[3];
        }

        unsafe internal void Ldfld(int fieldIndex, Value* evaluationStackBase, Value* evaluationStackPointer,
            object[] managedStack)
        {
            //VirtualMachine._Info("AnonymousStorey Ldfld fieldIndex:" + fieldIndex + ","
            //    + unmanagedFields[fieldIndex].Type + "," +  unmanagedFields[fieldIndex].Value1);
            *evaluationStackPointer = unmanagedFields[fieldIndex];
            if (unmanagedFields[fieldIndex].Type >= ValueType.Object)
            {
                evaluationStackPointer->Value1 = (int)(evaluationStackPointer - evaluationStackBase);
                managedStack[evaluationStackPointer->Value1] = managedFields[fieldIndex];
            }
        }

        unsafe internal void Stfld(int fieldIndex, Value* evaluationStackBase, Value* evaluationStackPointer,
            object[] managedStack)
        {
            //VirtualMachine._Info("AnonymousStorey Stfld fieldIndex:" + fieldIndex + ","
            //    + evaluationStackPointer->Type + "," + evaluationStackPointer->Value1);
            unmanagedFields[fieldIndex] = *evaluationStackPointer;
            if (evaluationStackPointer->Type >= ValueType.Object)
            {
                unmanagedFields[fieldIndex].Value1 = fieldIndex;
                managedFields[fieldIndex] = managedStack[evaluationStackPointer->Value1];
            }
        }

        unsafe internal object Get(int fieldIndex, Type type, VirtualMachine virtualMachine,
            bool valueTypeClone)
        {
            fixed(Value* b = &unmanagedFields[0])
            {
                var ret = EvaluationStackOperation.ToObject(b, b + fieldIndex, managedFields, type,
                    virtualMachine, valueTypeClone);
                //VirtualMachine._Info("AnonymousStorey.Get, field=" + fieldIndex + ", val=" + ret);
                return ret;
            }
        }

        unsafe internal void Set(int fieldIndex, object obj, Type type, VirtualMachine virtualMachine)
        {
            fixed (Value* b = &unmanagedFields[0])
            {
                //VirtualMachine._Info("AnonymousStorey.Set, field=" + fieldIndex + ", val=" + obj);
                EvaluationStackOperation.PushObject(b, b + fieldIndex, managedFields, obj, type);
            }
        }

        public bool ObjectEquals(object obj)
        {
            return base.Equals(obj);
        }

        public override bool Equals(object obj)
        {
            if(equalMethodId == -1)
                return ObjectEquals(obj);
            Call call = Call.Begin();
            call.PushObject(this);
            call.PushObject(obj);
            virtualMachine.Execute(equalMethodId, ref call, 2, 0);
            return call.GetBoolean(0);
        }

        public int ObjectGetHashCode()
        {
            return base.GetHashCode();
        }

        public override int GetHashCode()
        {
            if(getHashCodeMethodId == -1)
                return ObjectGetHashCode();
            Call call = Call.Begin();
            call.PushObject(this);
            virtualMachine.Execute(getHashCodeMethodId, ref call, 1, 0);
            return call.GetInt32(0);
        }

        public string ObjectToString()
        {
            return base.ToString();
        }

        public override string ToString()
        {
            if (toStringMethodId == -1)
                return ObjectToString();
            Call call = Call.Begin();
            call.PushObject(this);
            virtualMachine.Execute(toStringMethodId, ref call, 1, 0);
            return call.GetAsType<string>(0);
        }

        ~AnonymousStorey()
        {
            if (finalizeMethodId != -1)
            {
                Call call = Call.Begin();
                call.PushObject(this);
                virtualMachine.Execute(finalizeMethodId, ref call, 1, 0);
            }
        }
    }

    public class AnonymousStoreyInfo
    {
        public int FieldNum = 0;
        public int[] FieldTypes = null;
        public int CtorId = 0;
        public int CtorParamNum = 0;
        public int[] Slots = null;
        public int[] VTable = null;
    }
}
```

`Source/VSProj/Src/Core/DataDefine.cs`:

```cs
/*
 * Tencent is pleased to support the open source community by making InjectFix available.
 * Copyright (C) 2019 Tencent.  All rights reserved.
 * InjectFix is licensed under the MIT License, except for the third-party components listed in the file 'LICENSE' which may be subject to their corresponding license terms. 
 * This file is subject to the terms and conditions defined in file 'LICENSE', which is part of this source code package.
 */

namespace IFix.Core
{
    public enum ValueType
    {
        Integer,
        Long,
        Float,
        Double,
        StackReference,//Value = pointer, 
        StaticFieldReference,
        FieldReference,//Value1 = objIdx, Value2 = fieldIdx
        ChainFieldReference,
        Object,        //Value1 = objIdx
        ValueType,     //Value1 = objIdx
        ArrayReference,//Value1 = objIdx, Value2 = elemIdx
    }

    [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public struct Value
    {
        public ValueType Type;
        public int Value1;
        public int Value2;
    }
}
```

`Source/VSProj/Src/Core/GenericDelegate.cs`:

```cs
/*
 * Tencent is pleased to support the open source community by making InjectFix available.
 * Copyright (C) 2019 Tencent.  All rights reserved.
 * InjectFix is licensed under the MIT License, except for the third-party components listed in the file 'LICENSE' which may be subject to their corresponding license terms. 
 * This file is subject to the terms and conditions defined in file 'LICENSE', which is part of this source code package.
 */

using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

//ifix会分析闭包，针对闭包对应的delegate生成适配器
//但是有的情况是原来那个地方不是用闭包，修复时用了闭包，这时会报找不到适配器的错误。
//这种问题可以通过CustomBridage配置来避免，但是很多时候用户无法预知这种情况。
//这里就是为了减少这种情况的影响：参数个数不超过4个，且均为引用类型，
//无返回值或者返回值是引用类型，这里能够做到（通过泛型）自动生成适配器。

namespace IFix.Core
{
    internal class GenericDelegateFactory
    {
        //无返回值泛型方法
        static MethodInfo[] genericAction = null;
        //有返回值泛型方法
        static MethodInfo[] genericFunc = null;

        //泛型delegate适配器构造器的缓存
        static Dictionary<Type, Func<GenericDelegate, Delegate>> genericDelegateCreatorCache
            = new Dictionary<Type, Func<GenericDelegate, Delegate>>();

        //Prevent unity il2cpp code stripping
        static void PreventStripping(object obj)
        {
            if (obj != null)
            {
                var gd = new GenericDelegate(null, -1, null);
                gd.Action();
                gd.Action(obj);
                gd.Action(obj, obj);
                gd.Action(obj, obj, obj);
                gd.Action(obj, obj, obj, obj);

                gd.Func<object>();
                gd.Func<object, object>(obj);
                gd.Func<object, object, object>(obj, obj);
                gd.Func<object, object, object, object>(obj, obj, obj);
                gd.Func<object, object, object, object, object>(obj, obj, obj, obj);
            }
        }

        internal static Delegate Create(Type delegateType, VirtualMachine virtualMachine, int methodId, object anonObj)
        {
            Func<GenericDelegate, Delegate> genericDelegateCreator;
            if (!genericDelegateCreatorCache.TryGetValue(delegateType, out genericDelegateCreator))
            {
                //如果泛型方法数组未初始化
                if (genericAction == null)
                {
                    PreventStripping(null);
                    var methods = typeof(GenericDelegate).GetMethods(BindingFlags.Instance | BindingFlags.Public
                        | BindingFlags.DeclaredOnly);
                    genericAction = methods.Where(m => m.Name == "Action").OrderBy(m => m.GetParameters().Length)
                        .ToArray();
                    genericFunc = methods.Where(m => m.Name == "Func").OrderBy(m => m.GetParameters().Length).ToArray();
                }

                MethodInfo delegateMethod = delegateType.GetMethod("Invoke");

                var parameters = delegateMethod.GetParameters();
                if ((delegateMethod.ReturnType.IsValueType && delegateMethod.ReturnType != typeof(void)) 
                    || parameters.Length > 4
                    || parameters.Any(p => p.ParameterType.IsValueType || p.ParameterType.IsByRef)
                    )
                {
                    //如果不在支持的范围，则生成一个永远返回空的构造器
                    genericDelegateCreator = (x) => null;
                }
                else
                {
                    if (delegateMethod.ReturnType == typeof(void) && parameters.Length == 0)
                    {
                        //对无参无返回值特殊处理
                        var methodInfo = genericAction[0];
                        genericDelegateCreator = (o) => Delegate.CreateDelegate(delegateType, o, methodInfo);
                    }
                    else
                    {
                        //根据参数个数，返回值找到泛型实现
                        var typeArgs = parameters.Select(pinfo => pinfo.ParameterType);
                        MethodInfo genericMethodInfo = null;
                        if (delegateMethod.ReturnType == typeof(void))
                        {
                            genericMethodInfo = genericAction[parameters.Length];
                        }
                        else
                        {
                            genericMethodInfo = genericFunc[parameters.Length];
                            //如果是有返回值，需要加上返回值作为泛型实参
                            typeArgs = typeArgs.Concat(new Type[] { delegateMethod.ReturnType });
                        }
                        //实例化泛型方法
                        var methodInfo = genericMethodInfo.MakeGenericMethod(typeArgs.ToArray());
                        //构造器
                        genericDelegateCreator = (o) => Delegate.CreateDelegate(delegateType, o, methodInfo);
                    }
                }
                //缓存构造器，下次调用直接返回
                genericDelegateCreatorCache[delegateType] = genericDelegateCreator;
            }
            //创建delegate
            return genericDelegateCreator(new GenericDelegate(virtualMachine, methodId, anonObj));
        }
    }

    //泛型适配器
    internal class GenericDelegate
    {
        //指向的虚拟机对象
        VirtualMachine virtualMachine;

        //虚拟机方法id
        int methodId;

        //绑定的匿名对象
        object anonObj;

        //预计算，是否要把anonObj push的标志未
        bool pushSelf;

        //预计算，如果有anonObj参数个数则要+1
        int extraArgNum;

        internal GenericDelegate(VirtualMachine virtualMachine, int methodId, object anonObj)
        {
            this.virtualMachine = virtualMachine;
            this.methodId = methodId;
            this.anonObj = anonObj;
            pushSelf = anonObj != null;
            extraArgNum = pushSelf ? 1 : 0;
        }

        public void Action()
        {
            Call call = Call.Begin();
            if (pushSelf)
            {
                call.PushObject(anonObj);
            }
            virtualMachine.Execute(methodId, ref call, extraArgNum);
        }

        public void Action<T1>(T1 p1)
            where T1 : class
        {
            //创建call对象
            Call call = Call.Begin();
            if (pushSelf)
            {
                //如果有绑定的匿名对象，push
                call.PushObject(anonObj);
            }
            //push第一个参数
            call.PushObject(p1);
            //调用指定id的虚拟机方法
            virtualMachine.Execute(methodId, ref call, 1 + extraArgNum);
        }

        public void Action<T1, T2>(T1 p1, T2 p2) 
            where T1 : class
            where T2 : class
        {
            Call call = Call.Begin();
            if (pushSelf)
            {
                call.PushObject(anonObj);
            }
            call.PushObject(p1);
            call.PushObject(p2);
            virtualMachine.Execute(methodId, ref call, 2 + extraArgNum);
        }

        public void Action<T1, T2, T3>(T1 p1, T2 p2, T3 p3)
            where T1 : class
            where T2 : class
            where T3 : class
        {
            Call call = Call.Begin();
            if (pushSelf)
            {
                call.PushObject(anonObj);
            }
            call.PushObject(p1);
            call.PushObject(p2);
            call.PushObject(p3);
            virtualMachine.Execute(methodId, ref call, 3 + extraArgNum);
        }

        public void Action<T1, T2, T3, T4>(T1 p1, T2 p2, T3 p3, T4 p4)
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
        {
            Call call = Call.Begin();
            if (pushSelf)
            {
                call.PushObject(anonObj);
            }
            call.PushObject(p1);
            call.PushObject(p2);
            call.PushObject(p3);
            call.PushObject(p4);
            virtualMachine.Execute(methodId, ref call, 4 + extraArgNum);
        }

        public TResult Func<TResult>()
            where TResult : class
        {
            Call call = Call.Begin();
            if (pushSelf)
            {
                call.PushObject(anonObj);
            }
            virtualMachine.Execute(methodId, ref call, extraArgNum);
            return (TResult)call.GetObject();
        }

        public TResult Func<T1, TResult>(T1 p1)
            where T1 : class
            where TResult : class
        {
            Call call = Call.Begin();
            if (pushSelf)
            {
                call.PushObject(anonObj);
            }
            call.PushObject(p1);
            virtualMachine.Execute(methodId, ref call, 1 + extraArgNum);
            //从栈上获取结果
            return (TResult)call.GetObject();
        }

        public TResult Func<T1, T2, TResult>(T1 p1, T2 p2)
            where T1 : class
            where T2 : class
            where TResult : class
        {
            Call call = Call.Begin();
            if (pushSelf)
            {
                call.PushObject(anonObj);
            }
            call.PushObject(p1);
            call.PushObject(p2);
            virtualMachine.Execute(methodId, ref call, 2 + extraArgNum);
            return (TResult)call.GetObject();
        }

        public TResult Func<T1, T2, T3, TResult>(T1 p1, T2 p2, T3 p3)
            where T1 : class
            where T2 : class
            where T3 : class
            where TResult : class
        {
            Call call = Call.Begin();
            if (pushSelf)
            {
                call.PushObject(anonObj);
            }
            call.PushObject(p1);
            call.PushObject(p2);
            call.PushObject(p3);
            virtualMachine.Execute(methodId, ref call, 3 + extraArgNum);
            return (TResult)call.GetObject();
        }

        public TResult Func<T1, T2, T3, T4, TResult>(T1 p1, T2 p2, T3 p3, T4 p4)
            where T1 : class
            where T2 : class
            where T3 : class
            where T4 : class
            where TResult : class
        {
            Call call = Call.Begin();
            if (pushSelf)
            {
                call.PushObject(anonObj);
            }
            call.PushObject(p1);
            call.PushObject(p2);
            call.PushObject(p3);
            call.PushObject(p4);
            virtualMachine.Execute(methodId, ref call, 4 + extraArgNum);
            return (TResult)call.GetObject();
        }
    }
}

```

`Source/VSProj/Src/Core/Il2CppSetOptionAttribute.cs`:

```cs
/*
 * Tencent is pleased to support the open source community by making InjectFix available.
 * Copyright (C) 2019 Tencent.  All rights reserved.
 * InjectFix is licensed under the MIT License, except for the third-party components listed in the file 'LICENSE' which may be subject to their corresponding license terms. 
 * This file is subject to the terms and conditions defined in file 'LICENSE', which is part of this source code package.
 */

using System;

//用来配置il2cpp对代码的一些处理规则
namespace Unity.IL2CPP.CompilerServices
{
    internal enum Option
    {
        //是否做空检查
        NullChecks = 1,
        //是否做数组边界检查
        ArrayBoundsChecks = 2,
        //是否做除零检查
        DivideByZeroChecks = 3,
    }

    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Method
        | AttributeTargets.Property, Inherited = false, AllowMultiple = true)]
    internal class Il2CppSetOptionAttribute : Attribute
    {
        internal Option Option { get; private set; }
        internal object Value { get; private set; }

        internal Il2CppSetOptionAttribute(Option option, object value)
        {
            Option = option;
            Value = value;
        }
    }
}

```

`Source/VSProj/Src/Core/Instruction.cs`:

```cs
/*
 * Tencent is pleased to support the open source community by making InjectFix available.
 * Copyright (C) 2019 Tencent.  All rights reserved.
 * InjectFix is licensed under the MIT License, except for the third-party components listed in the file 'LICENSE' which may be subject to their corresponding license terms. 
 * This file is subject to the terms and conditions defined in file 'LICENSE', which is part of this source code package.
 */

namespace IFix.Core
{
    public enum Code
    {
        Nop,
        Break,
        Ldarg,
        Ldloc,
        Stloc,
        Ldarga,
        Starg,
        Ldloca,
        Ldnull,
        Ldc_I4,
        Ldc_I8,
        Ldc_R4,
        Ldc_R8,
        Dup,
        Pop,
        Jmp,
        Call,
        CallExtern,
        //Calli,
        Ret,
        Br,
        Brfalse,
        Brtrue,
        Beq,
        Bge,
        Bgt,
        Ble,
        Blt,
        Bne_Un,
        Bge_Un,
        Bgt_Un,
        Ble_Un,
        Blt_Un,
        Switch,
        Ldind_I1,
        Ldind_U1,
        Ldind_I2,
        Ldind_U2,
        Ldind_I4,
        Ldind_U4,
        Ldind_I8,
        Ldind_I,
        Ldind_R4,
        Ldind_R8,
        Ldind_Ref,
        Stind_Ref,
        Stind_I1,
        Stind_I2,
        Stind_I4,
        Stind_I8,
        Stind_R4,
        Stind_R8,
        Add,
        Sub,
        Mul,
        Div,
        Div_Un,
        Rem,
        Rem_Un,
        And,
        Or,
        Xor,
        Shl,
        Shr,
        Shr_Un,
        Neg,
        Not,
        Conv_I1,
        Conv_I2,
        Conv_I4,
        Conv_I8,
        Conv_R4,
        Conv_R8,
        Conv_U4,
        Conv_U8,
        Callvirt,
        Callvirtvirt,
        Ldvirtftn2,
        Cpobj,
        Ldobj,
        Ldstr,
        Newobj,
        Castclass,
        Isinst,
        Conv_R_Un,
        Unbox,
        Throw,
        Ldfld,
        Ldflda,
        Stfld,
        Ldsfld,
        Ldsflda,
        Stsfld,
        Stobj,
        Conv_Ovf_I1_Un,
        Conv_Ovf_I2_Un,
        Conv_Ovf_I4_Un,
        Conv_Ovf_I8_Un,
        Conv_Ovf_U1_Un,
        Conv_Ovf_U2_Un,
        Conv_Ovf_U4_Un,
        Conv_Ovf_U8_Un,
        Conv_Ovf_I_Un,
        Conv_Ovf_U_Un,
        Box,
        Newarr,
        Ldlen,
        Ldelema,
        Ldelem_I1,
        Ldelem_U1,
        Ldelem_I2,
        Ldelem_U2,
        Ldelem_I4,
        Ldelem_U4,
        Ldelem_I8,
        Ldelem_I,
        Ldelem_R4,
        Ldelem_R8,
        Ldelem_Ref,
        Stelem_I,
        Stelem_I1,
        Stelem_I2,
        Stelem_I4,
        Stelem_I8,
        Stelem_R4,
        Stelem_R8,
        Stelem_Ref,
        Ldelem_Any,
        Stelem_Any,
        Unbox_Any,
        Conv_Ovf_I1,
        Conv_Ovf_U1,
        Conv_Ovf_I2,
        Conv_Ovf_U2,
        Conv_Ovf_I4,
        Conv_Ovf_U4,
        Conv_Ovf_I8,
        Conv_Ovf_U8,
        Refanyval,
        Ckfinite,
        Mkrefany,
        Ldtoken,
        Ldtype, // custom
        Conv_U2,
        Conv_U1,
        Conv_I,
        Conv_Ovf_I,
        Conv_Ovf_U,
        Add_Ovf,
        Add_Ovf_Un,
        Mul_Ovf,
        Mul_Ovf_Un,
        Sub_Ovf,
        Sub_Ovf_Un,
        Endfinally,
        Leave,
        Stind_I,
        Conv_U,
        Arglist,
        Ceq,
        Cgt,
        Cgt_Un,
        Clt,
        Clt_Un,
        Ldftn,
        Newanon,
        Ldvirtftn,
        Localloc,
        Endfilter,
        Unaligned,
        Volatile,
        Tail,
        Initobj,
        Constrained,
        Cpblk,
        Initblk,
        No,
        Rethrow,
        Sizeof,
        Refanytype,
        Readonly,

        //Pseudo instruction
        StackSpace,
    }

    [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public struct Instruction
    {
        /// <summary>
        /// 指令MAGIC
        /// </summary>
        public const ulong INSTRUCTION_FORMAT_MAGIC = 317431043901;

        /// <summary>
        /// 当前指令
        /// </summary>
        public Code Code;

        /// <summary>
        /// 操作数
        /// </summary>
        public int Operand;
    }

    public enum ExceptionHandlerType
    {
        Catch = 0,
        Filter = 1,
        Finally = 2,
        Fault = 4
    }

    public sealed class ExceptionHandler
    {
        public System.Type CatchType;
        public int CatchTypeId;
        public int HandlerEnd;
        public int HandlerStart;
        public ExceptionHandlerType HandlerType;
        public int TryEnd;
        public int TryStart;
    }
}
```

`Source/VSProj/Src/Core/ObjectClone.cs`:

```cs
/*
 * Tencent is pleased to support the open source community by making InjectFix available.
 * Copyright (C) 2019 Tencent.  All rights reserved.
 * InjectFix is licensed under the MIT License, except for the third-party components listed in the file 'LICENSE' which may be subject to their corresponding license terms. 
 * This file is subject to the terms and conditions defined in file 'LICENSE', which is part of this source code package.
 */

namespace IFix.Core
{
    using System.Reflection;
    using System;
    using System.Linq.Expressions;

    public class ObjectClone
    {
        MethodInfo memberwiseClone;
        //Func<object> ptrToMemberwiseClone;
        //FieldInfo target;
        //Func<object, object> cloneFunc;
        public ObjectClone()
        {
            memberwiseClone = typeof(object).GetMethod("MemberwiseClone", BindingFlags.Instance
                | BindingFlags.NonPublic);
            //ptrToMemberwiseClone = new Func<object>(MemberwiseClone);
            //target = ptrToMemberwiseClone.GetType().GetField("_target", BindingFlags.Instance
            //    | BindingFlags.NonPublic);
            //var methodInfo = typeof(object).GetMethod("MemberwiseClone", BindingFlags.Instance
            //    | BindingFlags.NonPublic);
            //var p = Expression.Parameter(typeof(object), "obj");
            //var mce = Expression.Call(p, methodInfo);
            //cloneFunc = Expression.Lambda<Func<object, object>>(mce, p).Compile();//TODO: 需要用到jit么？
        }

        public object Clone(object obj)
        {
            return memberwiseClone.Invoke(obj, null);//1.79s
            //target.SetValue(ptrToMemberwiseClone, obj);
            //return ptrToMemberwiseClone();//1.17s
            //return ((Func<object>)Delegate.CreateDelegate(typeof(Func<object>), obj, memberwiseClone))();//3.05s
            //return cloneFunc(obj);//0.06s
        }
    }
}
```

`Source/VSProj/Src/Core/ReflectionMethodInvoker.cs`:

```cs
/*
 * Tencent is pleased to support the open source community by making InjectFix available.
 * Copyright (C) 2019 Tencent.  All rights reserved.
 * InjectFix is licensed under the MIT License, except for the third-party components listed in the file 'LICENSE' which may be subject to their corresponding license terms. 
 * This file is subject to the terms and conditions defined in file 'LICENSE', which is part of this source code package.
 */

using System.Reflection;
using System;

namespace IFix.Core
{
    internal class ReflectionMethodInvoker
    {
        int paramCount;

        bool hasThis;

        bool hasReturn;

        bool[] refFlags;

        bool[] outFlags;

        Type[] rawTypes;

        //object[] args;

        MethodBase method;

        ConstructorInfo ctor = null;

        Type returnType = null;

        bool isNullableHasValue = false;
        bool isNullableValue = false;

        public ReflectionMethodInvoker(MethodBase method)
        {
            var paramerInfos = method.GetParameters();
            paramCount = paramerInfos.Length;
            refFlags = new bool[paramCount];
            outFlags = new bool[paramCount];
            rawTypes = new Type[paramCount];
            //args = new object[paramCount];

            for (int i = 0; i < paramerInfos.Length; i++)
            {
                outFlags[i] = !paramerInfos[i].IsIn && paramerInfos[i].IsOut;
                if (paramerInfos[i].ParameterType.IsByRef)
                {
                    refFlags[i] = true;
                    rawTypes[i] = paramerInfos[i].ParameterType.GetElementType();
                }
                else
                {
                    refFlags[i] = false;
                    rawTypes[i] = paramerInfos[i].ParameterType;
                }
            }
            this.method = method;
            if (method.IsConstructor)
            {
                ctor = method as ConstructorInfo;
                returnType = method.DeclaringType;
                hasReturn = true;
            }
            else
            {
                returnType = (method as MethodInfo).ReturnType;
                hasReturn = returnType != typeof(void);
            }
            hasThis = !method.IsStatic;
            bool isNullableMethod = method.DeclaringType.IsGenericType
                && method.DeclaringType.GetGenericTypeDefinition() == typeof(Nullable<>);
            isNullableHasValue = isNullableMethod && method.Name == "get_HasValue";
            isNullableValue = isNullableMethod && method.Name == "get_Value";
        }

        // #lizard forgives
        public unsafe void Invoke(VirtualMachine virtualMachine, ref Call call, bool isInstantiate)
        {
            var managedStack = call.managedStack;
            var pushResult = false;
            var args = new object[paramCount];
            try
            {
                //virtualMachine._Info("method: " + method);
                Value* pArg = call.argumentBase;

                int paramStart = 0;

                if (hasThis && !isInstantiate)
                {
                    paramStart = 1;
                    pArg++;
                }

                for (int i = 0; i < paramCount; i++)
                {
                    if (!outFlags[i])
                    {
                        args[i] = EvaluationStackOperation.ToObject(call.evaluationStackBase, pArg, managedStack,
                            rawTypes[i], virtualMachine);
                    }
                    //if (pArg->Type >= ValueType.Object)
                    //{
                    //    managedStack[pArg->Value1] = null;
                    //}
                    //if (method.Name == "Invoke" && method.DeclaringType.Name == "MethodBase")
                    //{
                    //    VirtualMachine._Info(i + " pArg->Type:" + pArg->Type);
                    //    VirtualMachine._Info(i + " args[i]:" + args[i]);
                    //    if (args[i] != null)
                    //    {
                    //        VirtualMachine._Info(i + " args[i]:" + args[i].GetHashCode());
                    //    }
                    //    VirtualMachine._Info(i + " args[i].GetType:" + (args[i] == null ? 
                    //        "null" : args[i].GetType().ToString()));
                    //    if (i == 1 && args[i] is object[])
                    //    {
                    //        var objs = args[i] as object[];
                    //        for (int j = 0; j < objs.Length;j++)
                    //        {
                    //            VirtualMachine._Info("obj " + j + ": " + (objs[j] == null ? 
                    //            "null" : objs[j].GetType().ToString()));
                    //        }
                    //    }
                    //}
                    pArg++;
                }

                object ret;

                if (isInstantiate || (method.IsConstructor && method.DeclaringType.IsValueType))
                {
                    ret = ctor.Invoke(args);//TODO: Delegate创建用Delegate.CreateDelegate
                }
                else
                {
                    object instance = null;
                    if (hasThis)
                    {
                        instance = EvaluationStackOperation.ToObject(call.evaluationStackBase, call.argumentBase,
                            managedStack, method.DeclaringType, virtualMachine, false);
                    }
                    //Nullable仍然是值类型，只是新增了是否为null的标志位，仍然通过传地址的方式进行方法调用，
                    //但这在反射调用行不通，参数是object类型，boxing到object就是null，所以会触发
                    //“Non-static method requires a target”异常
                    //所以这只能特殊处理一下
                    if (isNullableHasValue)
                    {
                        ret = (instance != null);
                    }
                    else if (isNullableValue)
                    {
                        ret = instance;
                    }
                    else
                    {
                        if (method.IsStatic == false && instance == null)
                        {
                            throw new TargetException(string.Format("can not invoke method [{0}.{1}], Non-static method require instance but got null.", method.DeclaringType, method.Name));
                        }
                        else
                        {
                            ret = method.Invoke(instance, args);
                        }
                    }
                }

                for (int i = 0; i < paramCount; i++)
                {
                    if (refFlags[i])
                    {
                        call.UpdateReference(i + paramStart, args[i], virtualMachine, rawTypes[i]);
                    }
                }

                if (hasReturn || isInstantiate)
                {
                    if (method.IsConstructor && method.DeclaringType.IsValueType && !isInstantiate)
                    {
                        call.UpdateReference(0, ret, virtualMachine, method.DeclaringType);
                    }
                    else
                    {
                        call.PushObjectAsResult(ret, returnType);
                        pushResult = true;
                    }
                }
            }
            catch (TargetInvocationException e)
            {
                throw e.InnerException;
            }
            //catch (TargetException  e)
            //{
            //    //VirtualMachine._Info("exception method: " + method + ", in " + method.DeclaringType + ", msg:"
            //        + e.InnerException);
            //    //for (int i = 0; i < paramCount; i++)
            //    //{
            //    //    VirtualMachine._Info("arg " + i + " type: " + (args[i] == null ? "null" : args[i].GetType()
            //    //        .ToString()) + " value: " + args[i]);
            //    //}
            //    if (e.InnerException is System.ArgumentException && args.Length == 2 && args[1] is object[])
            //    {
            //        //VirtualMachine._Info("exception method: " + method + ", in " + method.DeclaringType
            //        //    + ", msg:" + e.InnerException);
            //        if (instance is MethodBase)
            //        {
            //            MethodBase mb = instance as MethodBase;
            //            VirtualMachine._Info("exception method: " + mb + ", in " + mb.DeclaringType);
            //        }
            //        args = args[1] as object[];
            //        for (int i = 0; i < args.Length; i++)
            //        {
            //            VirtualMachine._Info("arg " + i + " type: " + (args[i] == null ? 
            //            "null" : args[i].GetType().ToString()) + " value: " + args[i]);
            //        }
            //    }
            //    throw e;
            //}
            finally
            {
                //for (int i = 0; i < paramCount; i++)
                //{
                //    args[i] = null;
                //}
                Value* pArg = call.argumentBase;
                if (pushResult)
                {
                    pArg++;
                }
                for (int i = (pushResult ? 1 : 0); i < paramCount + ((hasThis && !isInstantiate) ? 1 : 0); i++)
                {
                    managedStack[pArg - call.evaluationStackBase] = null;
                    pArg++;
                }
            }
        }
    }
}

```

`Source/VSProj/Src/Core/StackOperation.cs`:

```cs
/*
 * Tencent is pleased to support the open source community by making InjectFix available.
 * Copyright (C) 2019 Tencent.  All rights reserved.
 * InjectFix is licensed under the MIT License, except for the third-party components listed in the file 'LICENSE' which may be subject to their corresponding license terms. 
 * This file is subject to the terms and conditions defined in file 'LICENSE', which is part of this source code package.
 */

namespace IFix.Core
{
    using System;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using System.Threading;
    using System.Collections.Generic;

    [StructLayout(LayoutKind.Sequential)]
    unsafe struct UnmanagedStack
    {
        public Value* Base;
        public Value* Top;
    }

    unsafe class ThreadStackInfo
    {
        public UnmanagedStack* UnmanagedStack;
        public object[] ManagedStack;

        IntPtr evaluationStackHandler;
        IntPtr unmanagedStackHandler;

        //int index;

        public ThreadStackInfo()
        {
            //index = idx;
            evaluationStackHandler = Marshal.AllocHGlobal(sizeof(Value) * VirtualMachine.MAX_EVALUATION_STACK_SIZE);
            unmanagedStackHandler = Marshal.AllocHGlobal(sizeof(UnmanagedStack));

            UnmanagedStack = (UnmanagedStack*)unmanagedStackHandler.ToPointer();
            UnmanagedStack->Base = UnmanagedStack->Top = (Value*)evaluationStackHandler.ToPointer();
            ManagedStack = new object[VirtualMachine.MAX_EVALUATION_STACK_SIZE];
        }

        //去掉析构，正常而言，静态变量不会析构，如果整个虚拟机释放的话，通过Marshal.AllocHGlobal分配的非托管
        //内存应该也会自动释放吧？
        //~ThreadStackInfo()
        //{
        //    //VirtualMachine._Info("~ThreadStackInfo");
        //    lock(stackListGuard)
        //    {
        //        stackList[index] = null;
        //    }
        //    UnmanagedStack = null;
        //    ManagedStack = null;
        //    Marshal.FreeHGlobal(evaluationStackHandler);
        //    Marshal.FreeHGlobal(unmanagedStackHandler);
        //}

        //本来ThreadStatic是很合适的方案，但据说Unity下的ThreadStatic会Crash，
        //Unity文档：https://docs.unity3d.com/Manual/Attributes.html
        //相关issue链接：https://issuetracker.unity3d.com/issues/
        //                 e-document-threadstatic-attribute-must-not-be-used-i-will-cause-crashes
        //issue内容：
        //This is a known limitation of the liveness check, as the we don't handle thread static or
        //context static variables as roots when performing the collection. 
        //The crash will happen in mono_unity_liveness_calculation_from_statics
        //[ThreadStatic]
        //internal static ThreadStackInfo Stack = null;

        static LocalDataStoreSlot localSlot = Thread.AllocateDataSlot();

        internal static ThreadStackInfo Stack
        {
            get
            {
                var stack = Thread.GetData(localSlot) as ThreadStackInfo;
                if (stack == null)
                {
                    VirtualMachine._Info("create thread stack");
                    stack = new ThreadStackInfo();
                    Thread.SetData(localSlot, stack);
                }
                return stack;
            }
        }
    }

    unsafe internal static class EvaluationStackOperation
    {
        internal static void UnboxPrimitive(Value* evaluationStackPointer, object obj, Type type)
        {
            if (obj.GetType().IsEnum)
            {
                obj = Convert.ChangeType(obj, type);
            }
            if (obj is int)
            {
                evaluationStackPointer->Type = ValueType.Integer;
                evaluationStackPointer->Value1 = (int)obj;
            }
            else if (obj is float)
            {
                evaluationStackPointer->Type = ValueType.Float;
                *(float*)(&evaluationStackPointer->Value1) = (float)obj;
            }
            else if (obj is bool)
            {
                evaluationStackPointer->Type = ValueType.Integer;
                evaluationStackPointer->Value1 = (bool)(obj) ? 1 : 0;
            }
            else if (obj is double)
            {
                evaluationStackPointer->Type = ValueType.Double;
                *(double*)(&evaluationStackPointer->Value1) = (double)obj;
            }
            else if (obj is long)
            {
                evaluationStackPointer->Type = ValueType.Long;
                *(long*)(&evaluationStackPointer->Value1) = (long)obj;
            }
            else if (obj is byte)
            {
                evaluationStackPointer->Type = ValueType.Integer;
                evaluationStackPointer->Value1 = (byte)obj;
            }
            else if (obj is uint)
            {
                evaluationStackPointer->Type = ValueType.Integer;
                evaluationStackPointer->Value1 = (int)(uint)obj;
            }
            else if (obj is ushort)
            {
                evaluationStackPointer->Type = ValueType.Integer;
                evaluationStackPointer->Value1 = (int)(ushort)obj;
            }
            else if (obj is short)
            {
                evaluationStackPointer->Type = ValueType.Integer;
                evaluationStackPointer->Value1 = (short)obj;
            }
            else if (obj is char)
            {
                evaluationStackPointer->Type = ValueType.Integer;
                evaluationStackPointer->Value1 = (int)(char)obj;
            }
            else if (obj is ulong)
            {
                evaluationStackPointer->Type = ValueType.Long;
                *(ulong*)(&evaluationStackPointer->Value1) = (ulong)obj;
            }
            else if (obj is sbyte)
            {
                evaluationStackPointer->Type = ValueType.Integer;
                evaluationStackPointer->Value1 = (sbyte)obj;
            }
            else if (obj is IntPtr)
            {
                evaluationStackPointer->Type = ValueType.Long;
                *(long*)(&evaluationStackPointer->Value1) = ((IntPtr)obj).ToInt64();
            }
            else if (obj is UIntPtr)
            {
                evaluationStackPointer->Type = ValueType.Long;
                *(ulong*)(&evaluationStackPointer->Value1) = ((UIntPtr)obj).ToUInt64();
            }
            else
                throw new NotImplementedException("Unbox a " + obj.GetType() + " to " + type);
        }

        internal static object mGet(bool isArray, object root, int layer, int[] fieldIdList, FieldInfo[] fieldInfos, Dictionary<int, NewFieldInfo> newFieldInfos)
        {
            //Console.WriteLine("mGet " + root);
            var fieldId = fieldIdList[layer];
            if (layer == 0)
            {
                if (isArray)
                {
                    return (root as Array).GetValue(fieldId);
                }
                else
                {
                    var fieldInfo = fieldInfos[fieldId];
                    
                    if(fieldInfo == null)
                    {
                        return newFieldInfos[fieldId].GetValue(root);
                    }

                    return fieldInfo.GetValue(root);
                }
            }
            else
            {
                var fieldInfo = fieldInfos[fieldId];

                if(fieldInfo == null)
                {
                    return newFieldInfos[fieldId].GetValue(mGet(isArray, root, layer - 1, fieldIdList, fieldInfos, newFieldInfos));
                }
                
                //VirtualMachine._Info("before --- " + fieldInfo);
                var ret =  fieldInfo.GetValue(mGet(isArray, root, layer - 1, fieldIdList, fieldInfos, newFieldInfos));
                //VirtualMachine._Info("after --- " + fieldInfo);
                return ret;
            }
        }

        internal static void mSet(bool isArray, object root, object val, int layer, int[] fieldIdList,
            FieldInfo[] fieldInfos, Dictionary<int, NewFieldInfo> newFieldInfos)
        {
            var fieldId = fieldIdList[layer];
            if (layer == 0)
            {
                if (isArray)
                {
                    (root as Array).SetValue(val, fieldId);
                }
                else
                {
                    var fieldInfo = fieldInfos[fieldId];

                    if(fieldInfo == null)
                    {
                        newFieldInfos[fieldId].SetValue(root, val);
                    }
                    else
                    {
                        //VirtualMachine._Info("set1 " + val.GetType() + " to " + fieldInfo + " of " + root.GetType()
                        //    + ", root.hc = " + root.GetHashCode());
                        fieldInfo.SetValue(root, val);
                    }
                }
            }
            else
            {
                var fieldInfo = fieldInfos[fieldId];
                //VirtualMachine._Info("before get " + fieldInfo);
                var parent = mGet(isArray, root, layer - 1, fieldIdList, fieldInfos, newFieldInfos);
                //VirtualMachine._Info("after get " + fieldInfo);
                //VirtualMachine._Info("before set " + fieldInfo);
                if(fieldInfo == null)
                {
                    newFieldInfos[fieldId].SetValue(parent, val);
                }
                else
                {
                    fieldInfo.SetValue(parent, val);
                }
                //VirtualMachine._Info("set2 " + val.GetType() + " to " + fieldInfo + " of " + parent.GetType());
                //VirtualMachine._Info("after set " + fieldInfo);
                mSet(isArray, root, parent, layer - 1, fieldIdList, fieldInfos, newFieldInfos);
            }
        }

        // #lizard forgives
        internal static unsafe object ToObject(Value* evaluationStackBase, Value* evaluationStackPointer,
            object[] managedStack, Type type, VirtualMachine virtualMachine, bool valueTypeClone = true)
        {
            //未初始化的local引用可能作为out参数反射调用
            //TODO: 验证值类型out参数，对应参数位置是否可以是null？
            switch (evaluationStackPointer->Type)
            {
                case ValueType.Integer:
                    {
                        int i = evaluationStackPointer->Value1;
                        if (type == typeof(int))
                            return i;
                        else if (type == typeof(bool))
                            return i == 1;
                        else if (type == typeof(sbyte))
                            return (sbyte)i;
                        else if (type == typeof(byte))
                            return (byte)i;
                        else if (type == typeof(char))
                            return (char)i;
                        else if (type == typeof(short))
                            return (short)i;
                        else if (type == typeof(ushort))
                            return (ushort)i;
                        else if (type == typeof(uint))
                            return (uint)i;
                        else if (type.IsEnum)
                        {
                            return Enum.ToObject(type, i);
                        }
                        else 
                            return null;
                    }
                case ValueType.Long:
                    {
                        long l = *(long*)&evaluationStackPointer->Value1;
                        if (type == typeof(long))
                        {
                            return l;
                        }
                        else if (type == typeof(ulong))
                        {
                            return (ulong)l;
                        }
                        else if (type == typeof(IntPtr))
                        {
                            return new IntPtr(l);
                        }
                        else if (type == typeof(UIntPtr))
                        {
                            return new UIntPtr((ulong)l);
                        }
                        else if (type.IsEnum)
                        {
                            return Enum.ToObject(type, l);
                        }
                        else
                        {
                            return null;
                        }
                    }
                case ValueType.Float:
                    {
                        if (type == typeof(float))
                        {
                            return *(float*)&evaluationStackPointer->Value1;
                        }
                        else
                        {
                            return null;
                        }
                    }
                case ValueType.Double:
                    {
                        if (type == typeof(double))
                        {
                            return *(double*)&evaluationStackPointer->Value1;
                        }
                        else
                        {
                            return null;
                        }
                    }
                case ValueType.Object:
                    return managedStack[evaluationStackPointer->Value1];
                case ValueType.ValueType:
                    if (valueTypeClone && managedStack[evaluationStackPointer->Value1] != null)
                    {
                        return virtualMachine.objectClone.Clone(managedStack[evaluationStackPointer->Value1]);
                    }
                    else
                    {
                        return managedStack[evaluationStackPointer->Value1];
                    }
                case ValueType.StackReference:
                    {
                        return ToObject(evaluationStackBase, (*(Value**)&evaluationStackPointer->Value1),
                            managedStack, type, virtualMachine, valueTypeClone);
                    }
                case ValueType.FieldReference:
                case ValueType.ChainFieldReference:
                    {
                        //VirtualMachine._Info("ToObject FieldReference:" + evaluationStackPointer->Value2
                        //    + "," + evaluationStackPointer->Value1);
                        if (evaluationStackPointer->Type == ValueType.ChainFieldReference)
                        {
                            var fieldAddr = managedStack[evaluationStackPointer - evaluationStackBase] as FieldAddr;
                            var fieldIdList = fieldAddr.FieldIdList;
                            return mGet(evaluationStackPointer->Value2 != -1,
                                fieldAddr.Object, fieldIdList.Length - 1,
                                fieldIdList, virtualMachine.fieldInfos, virtualMachine.newFieldInfos);
                        }
                        else
                        {
                            if (evaluationStackPointer->Value2 >= 0)
                            {
                                var fieldInfo = virtualMachine.fieldInfos[evaluationStackPointer->Value2];
                                var obj = managedStack[evaluationStackPointer->Value1];
                                if(fieldInfo == null)
                                {
                                    virtualMachine.newFieldInfos[evaluationStackPointer->Value2].CheckInit(virtualMachine, obj);
                                    return virtualMachine.newFieldInfos[evaluationStackPointer->Value2].GetValue(obj);
                                }
                                return fieldInfo.GetValue(obj);
                            }
                            else
                            {
                                var obj = managedStack[evaluationStackPointer->Value1] as AnonymousStorey;
                                return obj.Get(-(evaluationStackPointer->Value2 + 1), type,
                                    virtualMachine, valueTypeClone);
                            }
                        }
                    }
                case ValueType.ArrayReference:
                    var arr = managedStack[evaluationStackPointer->Value1] as Array;
                    return arr.GetValue(evaluationStackPointer->Value2);
                case ValueType.StaticFieldReference:
                    {
                        var fieldIndex = evaluationStackPointer->Value1;
                        if (fieldIndex >= 0)
                        {
                            var fieldInfo = virtualMachine.fieldInfos[fieldIndex];
                            if(fieldInfo == null)
                            {
                                virtualMachine.newFieldInfos[fieldIndex].CheckInit(virtualMachine, null);
                                
                                return virtualMachine.newFieldInfos[fieldIndex].GetValue(null);
                            }
                            return fieldInfo.GetValue(null);
                        }
                        else
                        {
                            fieldIndex = -(fieldIndex + 1);
                            return virtualMachine.staticFields[fieldIndex];
                        }
                    }
                default:
                    throw new NotImplementedException("get obj of " + evaluationStackPointer->Type);
            }
        }

        public static void PushObject(Value* evaluationStackBase, Value* evaluationStackPointer,
            object[] managedStack, object obj, Type type)
        {
            if (obj != null)
            {
                if (type.IsPrimitive)
                {
                    UnboxPrimitive(evaluationStackPointer, obj, type);
                    return;
                }
                else if (type.IsEnum)
                {
                    var underlyingType = Enum.GetUnderlyingType(type);
                    if (underlyingType == typeof(long) || underlyingType == typeof(ulong))
                    {
                        evaluationStackPointer->Type = ValueType.Long;
                        *(long*)(&evaluationStackPointer->Value1) = underlyingType == typeof(long) ? 
                            Convert.ToInt64(obj) : (long)Convert.ToUInt64(obj) ;
                    }
                    else
                    {
                        evaluationStackPointer->Type = ValueType.Integer;
                        evaluationStackPointer->Value1 = Convert.ToInt32(obj);
                    }
                    return;
                }
            }
            int pos = (int)(evaluationStackPointer - evaluationStackBase);
            evaluationStackPointer->Value1 = pos;
            managedStack[pos] = obj;

            evaluationStackPointer->Type = (obj != null && type.IsValueType) ?
                ValueType.ValueType : ValueType.Object;
        }

        public static void UpdateReference(Value* evaluationStackBase, Value* evaluationStackPointer,
            object[] managedStack, object obj, VirtualMachine virtualMachine, Type type) //反射专用
        {
            switch (evaluationStackPointer->Type)
            {
                case ValueType.StackReference:
                    var des = *(Value**)&evaluationStackPointer->Value1;
                    //VirtualMachine._Info("UpdateReference des->Type:" + des->Type + ", des->Value1:"
                    //    + des->Value1 + ", des:" + new IntPtr(des) + ", offset:" + (des - evaluationStackBase) );
                    PushObject(evaluationStackBase, des, managedStack, obj, type);
                    break;
                case ValueType.ArrayReference:
                    var arr = managedStack[evaluationStackPointer->Value1] as Array;
                    arr.SetValue(obj, evaluationStackPointer->Value2);
                    break;
                case ValueType.FieldReference:
                case ValueType.ChainFieldReference:
                    {
                        if (evaluationStackPointer->Type == ValueType.ChainFieldReference)
                        {
                            var fieldAddr = managedStack[evaluationStackPointer - evaluationStackBase] as FieldAddr;
                            var fieldIdList = fieldAddr.FieldIdList;
                            //for(int i = 0; i < fieldIdList.Length; i++)
                            //{
                            //    VirtualMachine._Info("fid " + i + ": " + fieldIdList[i] + ", "
                            //        + virtualMachine.fieldInfos[fieldIdList[i]]);
                            //}
                            mSet(evaluationStackPointer->Value2 != -1,
                                fieldAddr.Object, obj, fieldIdList.Length - 1,
                                fieldIdList, virtualMachine.fieldInfos, virtualMachine.newFieldInfos);
                        }
                        else
                        {
                            if (evaluationStackPointer->Value2 >= 0)
                            {


                                var fieldInfo = virtualMachine.fieldInfos[evaluationStackPointer->Value2];
                                if(fieldInfo == null)
                                {
                                    virtualMachine.newFieldInfos[evaluationStackPointer->Value2].SetValue(managedStack[evaluationStackPointer->Value1], obj);;
                                }
                                else
                                {
                                    //VirtualMachine._Info("update field: " + fieldInfo);
                                    //VirtualMachine._Info("update field of: " + fieldInfo.DeclaringType);
                                    //VirtualMachine._Info("update ref obj: "
                                    //    + managedStack[evaluationStackPointer->Value1]);
                                    //VirtualMachine._Info("update ref obj idx: " + evaluationStackPointer->Value1);
                                    fieldInfo.SetValue(managedStack[evaluationStackPointer->Value1], obj);
                                }
                            }
                            else
                            {
                                var anonymousStorey = managedStack[evaluationStackPointer->Value1]
                                    as AnonymousStorey;
                                anonymousStorey.Set(-(evaluationStackPointer->Value2 + 1), obj, type, virtualMachine);
                            }
                        }
                        break;
                    }
                case ValueType.StaticFieldReference://更新完毕，直接return
                    {
                        var fieldIndex = evaluationStackPointer->Value1;
                        if (fieldIndex >= 0)
                        {
                            var fieldInfo = virtualMachine.fieldInfos[evaluationStackPointer->Value1];
                            if(fieldInfo == null)
                            {
                                virtualMachine.newFieldInfos[evaluationStackPointer->Value1].SetValue(null, obj);;
                            }
                            else
                            {
                                fieldInfo.SetValue(null, obj);
                            }
                        }
                        else
                        {
                            fieldIndex = -(fieldIndex + 1);
                            virtualMachine.staticFields[fieldIndex] = obj;
                        }
                        break;
                    }
            }
        }
    }

    unsafe public struct Call
    {
        internal Value* argumentBase;

        internal Value* evaluationStackBase;

        internal object[] managedStack;

        internal Value* currentTop;//用于push状态

        internal Value** topWriteBack;

        public static Call Begin()
        {
            var stack = ThreadStackInfo.Stack;
            return new Call()
            {
                managedStack = stack.ManagedStack,
                currentTop = stack.UnmanagedStack->Top,
                argumentBase = stack.UnmanagedStack->Top,
                evaluationStackBase = stack.UnmanagedStack->Base,
                topWriteBack = &(stack.UnmanagedStack->Top)
            };
        }

        internal static Call BeginForStack(ThreadStackInfo stack)
        {
            return new Call()
            {
                managedStack = stack.ManagedStack,
                currentTop = stack.UnmanagedStack->Top,
                argumentBase = stack.UnmanagedStack->Top,
                evaluationStackBase = stack.UnmanagedStack->Base,
                topWriteBack = &(stack.UnmanagedStack->Top)
            };
        }

        public void PushBoolean(bool b)
        {
            currentTop->Value1 = b ? 1 : 0;
            currentTop->Type = ValueType.Integer;
            currentTop++;
        }

        public bool GetBoolean(int offset = 0)
        {
            return (argumentBase + offset)->Value1 == 0 ? false : true;
        }

        public void PushByte(byte b)
        {
            PushInt32(b);
        }

        public byte GetByte(int offset = 0)
        {
            return (byte)GetInt32(offset);
        }

        public void PushSByte(sbyte sb)
        {
            PushInt32(sb);
        }

        public sbyte GetSByte(int offset = 0)
        {
            return (sbyte)GetInt32(offset);
        }

        public void PushInt16(short s)
        {
            PushInt32(s);
        }

        public short GetInt16(int offset = 0)
        {
            return (short)GetInt32(offset);
        }

        public void PushChar(char c)
        {
            PushInt32(c);
        }

        public char GetChar(int offset = 0)
        {
            return (char)GetInt32(offset);
        }

        public void PushUInt16(ushort us)
        {
            PushInt32(us);
        }

        public ushort GetUInt16(int offset = 0)
        {
            return (ushort)GetInt32(offset);
        }

        public void PushInt32(int i)
        {
            currentTop->Value1 = i;
            currentTop->Type = ValueType.Integer;
            currentTop++;
        }

        public int GetInt32(int offset = 0)
        {
            return (argumentBase + offset)->Value1;
        }

        public void PushUInt32(uint ui)
        {
            PushInt32((int)ui);
        }

        public uint GetUInt32(int offset = 0)
        {
            return (uint)GetInt32(offset);
        }

        public void PushInt64(long i)
        {
            *(long*)&currentTop->Value1 = i;
            currentTop->Type = ValueType.Long;
            currentTop++;
        }

        public long GetInt64(int offset = 0)
        {
            return *((long*)&((argumentBase + offset)->Value1));
        }

        public void PushUInt64(ulong i)
        {
            PushInt64((long)i);
        }

        public ulong GetUInt64(int offset = 0)
        {
            return (ulong)GetInt64(offset);
        }

        public void PushSingle(float f)
        {
            *(float*)(&currentTop->Value1) = f;
            currentTop->Type = ValueType.Float;
            currentTop++;
        }

        public float GetSingle(int offset = 0)
        {
            return *((float*)&((argumentBase + offset)->Value1));
        }

        public void PushDouble(double d)
        {
            *(double*)(&currentTop->Value1) = d;
            currentTop->Type = ValueType.Double;
            currentTop++;
        }

        public double GetDouble(int offset = 0)
        {
            return *((double*)&((argumentBase + offset)->Value1));
        }

        public void PushIntPtr(IntPtr i)
        {
            PushInt64(i.ToInt64());
        }

        public IntPtr GetIntPtr(int offset = 0)
        {
            return new IntPtr(GetInt64(offset));
        }

        public void PushUIntPtr(UIntPtr i)
        {
            PushUInt64(i.ToUInt64());
        }

        public UIntPtr GetUIntPtr(int offset = 0)
        {
            return new UIntPtr(GetUInt64(offset));
        }

        public void PushObject(object o)
        {
            int pos = (int)(currentTop - evaluationStackBase);
            currentTop->Type = ValueType.Object;
            currentTop->Value1 = pos;
            managedStack[pos] = o;
            currentTop++;
        }

        public void PushValueType(object o)
        {
            int pos = (int)(currentTop - evaluationStackBase);
            currentTop->Type = ValueType.ValueType;
            currentTop->Value1 = pos;
            managedStack[pos] = o;
            currentTop++;
        }

        public object GetObject(int offset = 0)
        {
            var ptr = argumentBase + offset;
            object ret = managedStack[ptr->Value1];
            managedStack[ptr - evaluationStackBase] = null;
            return ret;
        }

        public T GetAsType<T>(int offset = 0)
        {
            //if (typeof(T).IsEnum)
            //{
            //    var obj = GetObject(offset);
            //    var ptr = argumentBase + offset;
            //    VirtualMachine._Info("ptr =" + new IntPtr(ptr) + ", offset=" + (ptr - evaluationStackBase)
            //        + ",ptr->Value1=" + ptr->Value1 + ",ptr->Type=" + ptr->Type);

            //    if (obj != null)
            //    {
            //        VirtualMachine._Info("obj = " + obj + ", type = " + obj.GetType());
            //    }
            //    else
            //    {
            //        VirtualMachine._Info("obj = null");
            //    }
            //    return (T)Enum.ToObject(typeof(T), obj);
            //}
            //else
            //{
            //    return (T)GetObject(offset);
            //}
            return (T)GetObject(offset);
        }

        public void PushObjectAsResult(object obj, Type type) //反射专用
        {
            EvaluationStackOperation.PushObject(evaluationStackBase, argumentBase, managedStack, obj, type);
            currentTop = argumentBase + 1;
        }

        public void PushRef(int offset)
        {
            //Console.WriteLine("PushRef:" + offset + " address:" + new IntPtr(argumentBase + offset));
            *(Value**)&currentTop->Value1 = argumentBase + offset;
            currentTop->Type = ValueType.StackReference;
            currentTop++;
        }

        public void UpdateReference(int offset, object obj, VirtualMachine virtualMachine, Type type) //反射专用
        {
            EvaluationStackOperation.UpdateReference(ThreadStackInfo.Stack.UnmanagedStack->Base,
                argumentBase + offset, managedStack, obj, virtualMachine, type);
        }

        public static void End(ref Call call)
        {
            //Top的维护
            //ThreadStackInfo.Stack.UnmanagedStack->Top = call.argumentBase;
        }
    }

}
```

`Source/VSProj/Src/Core/SwitchFlags.cs`:

```cs
/*
 * Tencent is pleased to support the open source community by making InjectFix available.
 * Copyright (C) 2019 Tencent.  All rights reserved.
 * InjectFix is licensed under the MIT License, except for the third-party components listed in the file 'LICENSE' which may be subject to their corresponding license terms. 
 * This file is subject to the terms and conditions defined in file 'LICENSE', which is part of this source code package.
 */

using System;

namespace IFix
{
    //切换到解析执行
    [AttributeUsage(AttributeTargets.Property | AttributeTargets.Method | AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Field)]
    public class InterpretAttribute : Attribute
    {
    }

    //直接在要做成补丁的方法上打标签
    [AttributeUsage(AttributeTargets.Method)]
    public class PatchAttribute : Attribute
    {
    }

    //可以手动指定要生成delegate（主要用于闭包）、interface（比如迭代器语法糖）的桥接
    [AttributeUsage(AttributeTargets.Class)]
    public class CustomBridgeAttribute : Attribute
    {

    }
}
```

`Source/VSProj/Src/Core/Utils.cs`:

```cs
/*
 * Tencent is pleased to support the open source community by making InjectFix available.
 * Copyright (C) 2019 Tencent.  All rights reserved.
 * InjectFix is licensed under the MIT License, except for the third-party components listed in the file 'LICENSE' which may be subject to their corresponding license terms. 
 * This file is subject to the terms and conditions defined in file 'LICENSE', which is part of this source code package.
 */

using System;
using System.Reflection;
using System.Collections.Generic;

namespace IFix.Core
{
    //虚拟机使用给工具类
    public static class Utils
    {
        /// <summary>
        /// 判断一个方法是否能赋值到一个delegate变量
        /// </summary>
        /// <param name="delegateMethod">delegate变量的类型里头的invoke方法</param>
        /// <param name="method">待赋值的方法</param>
        /// <returns>是否能赋值</returns>
        public static bool IsAssignable(MethodInfo delegateMethod, MethodInfo method)
        {
            if (delegateMethod == null || method == null)
            {
                return false;
            }
            if (delegateMethod.ReturnType != method.ReturnType)
            {
                return false;
            }
            ParameterInfo[] lhsParams = delegateMethod.GetParameters();
            ParameterInfo[] rhsParams = method.GetParameters();
            if (lhsParams.Length != rhsParams.Length)
            {
                return false;
            }

            for (int i = 0; i < lhsParams.Length; i++)
            {
                if (lhsParams[i].ParameterType != rhsParams[i].ParameterType
                    || lhsParams[i].IsOut != rhsParams[i].IsOut)
                {
                    return false;
                }
            }

            return true;
        }

        //适配器的缓存，如果不做缓存，每次都调用IsAssignable一个个的取匹配会非常慢
        static Dictionary<Type, MethodInfo> delegateAdptCache = new Dictionary<Type, MethodInfo>();

        /// <summary>
        /// 从一个wrapper对象里头，查找能够适配到特定delegate的方法
        /// </summary>
        /// <param name="obj">wrapper对象</param>
        /// <param name="delegateType">delegate类型</param>
        /// <param name="perfix">方法前缀，能够排除掉一些方法，比如构造函数</param>
        /// <returns></returns>
        public static Delegate TryAdapterToDelegate(object obj, Type delegateType, string perfix)
        {
            MethodInfo method;
            if (!delegateAdptCache.TryGetValue(delegateType, out method))
            {
                MethodInfo delegateMethod = delegateType.GetMethod("Invoke");
                var methods = obj.GetType().GetMethods(BindingFlags.Public | BindingFlags.Instance
                    | BindingFlags.DeclaredOnly);
                for (int i = 0; i < methods.Length; i++)
                {
                    if (methods[i].Name.StartsWith(perfix) && IsAssignable(delegateMethod, methods[i]))
                    {
                        method = methods[i];
                        delegateAdptCache[delegateType] = method;
                    }
                }
            }
            if (method == null)
            {
                return null;
            }
            else
            {
                return Delegate.CreateDelegate(delegateType, obj, method);
            }
        }
    }
}
```

`Source/VSProj/Src/Core/VirtualMachine.cs`:

```cs
/*
 * Tencent is pleased to support the open source community by making InjectFix available.
 * Copyright (C) 2019 Tencent.  All rights reserved.
 * InjectFix is licensed under the MIT License, except for the third-party components listed in the file 'LICENSE' which may be subject to their corresponding license terms. 
 * This file is subject to the terms and conditions defined in file 'LICENSE', which is part of this source code package.
 */

namespace IFix.Core
{
    using System;
    using Unity.IL2CPP.CompilerServices;
    using System.Collections.Generic;
    using System.Reflection;
    using System.IO;
    using System.Linq;

    class RuntimeException : Exception
    {
        public Exception Real { get;set;}
    }

    public delegate void ExternInvoker(VirtualMachine vm, ref Call call, bool isInstantiate);

    internal class FieldAddr
    {
        public object Object;
        public int[] FieldIdList;
    }

    public class Cleanner
    {
        private static bool start = false;

        public static void Start()
        {
            if(!start)
            {
                start = true;
                new Cleanner();        
            }
        }

        public static void Stop()
        {
            start = false;
        }

        ~Cleanner()
        {
            if(start)
            {
                NewFieldInfo.Sweep();
                Start();
            }
        }
    }
    
    public class NewFieldInfo
    {
        public string Name;
        public Type DeclaringType;
        public Type FieldType;
        public int MethodId;

        static readonly int staticObjectKey = 0;

        static readonly ThreadStackInfo stack = new ThreadStackInfo();

        static readonly Dictionary<int, Dictionary<string, object>> newFieldValues = new Dictionary<int, Dictionary<string, object>>();

        static readonly Dictionary<int, WeakReference> objList = new Dictionary<int, WeakReference>();

        private object SetDefaultValue(object obj)
        {
            if(FieldType.IsValueType)
            {
                var ret = Activator.CreateInstance(FieldType);
                SetValue(obj, ret);
                return ret; 
            }
            else
            {
                SetValue(obj, null);
                return null;
            }
        }

        public static void Sweep()
        {
            foreach (var item in objList.ToList())
            {
                if(!item.Value.IsAlive)
                {
                    newFieldValues.Remove(item.Key);
                    objList.Remove(item.Key);
                }
            }
        }

        public unsafe void CheckInit(VirtualMachine virtualMachine, object obj)
        {
            if( MethodId >= 0 && !HasInitialize(obj) )
            {
                Call call = Call.BeginForStack(stack);
                virtualMachine.Execute(MethodId, ref call, 0, 0);
                SetValue(obj, call.GetObject());
            }
        }

        public int ObjectToIndex(object obj)
        {
            if(obj == null)
            {
                return staticObjectKey;
            }

            return obj.GetHashCode();
        }

        public bool HasInitialize(object obj)
        {
            var index = ObjectToIndex(obj);

            if(!newFieldValues.ContainsKey(index))
            {
                return false;
            }

            Dictionary<string, object> fieldValues = null;
            newFieldValues.TryGetValue(index, out fieldValues);
            if(!fieldValues.ContainsKey(Name))
            {
                return false;
            }

            return true;
        }

        public object GetValue(object obj)
        {
            var index = ObjectToIndex(obj);

            Dictionary<string, object> fieldValues = null;
            newFieldValues.TryGetValue(index, out fieldValues);
            if(fieldValues != null)
            {
                object val = null;
                if(!fieldValues.TryGetValue(Name, out val))
                {
                    return SetDefaultValue(obj);
                }
                
                return val;
            }
            else
            {
                return SetDefaultValue(obj);
            }
        }

        public void SetValue(object obj, object value)
        {
            var index = ObjectToIndex(obj);

            if(!newFieldValues.ContainsKey(index))
            {
                newFieldValues.Add(index, new Dictionary<string, object>());

                if(obj != null)
                {
                    objList.Add(index, new WeakReference(obj));
                }
            }
            
            newFieldValues[index][Name] = value;

            // if(obj.GetType() != DeclaringType || (value != null && value.GetType() != FieldType))
            // {
            // }
        }        
    }

    unsafe public class VirtualMachine
    {
        Instruction tellUnity4IncludeInstructionFisrt;

        public const int MAX_EVALUATION_STACK_SIZE = 1024 * 10;

        internal ObjectClone objectClone = new ObjectClone();

        Instruction** unmanagedCodes;

        ExceptionHandler[][] exceptionHandlers;

        Action onDispose;

        ExternInvoker[] externInvokers;

        MethodBase[] externMethods;

        Type[] externTypes;

        string[] internStrings;

        internal FieldInfo[] fieldInfos;

        internal Dictionary<int, NewFieldInfo> newFieldInfos;

        AnonymousStoreyInfo[] anonymousStoreyInfos;

        Dictionary<Type, Dictionary<MethodInfo, MethodInfo>> overrideCache
            = new Dictionary<Type, Dictionary<MethodInfo, MethodInfo>>();

        internal Type[] staticFieldTypes;

        internal object[] staticFields;

        int[] cctors;

        WrappersManager wrappersManager;

        public ExceptionHandler[][] ExceptionHandlers
        {
            get
            {
                return exceptionHandlers;
            }
            set
            {
                exceptionHandlers = value;
            }
        }

        public Type[] ExternTypes
        {
            get
            {
                return externTypes;
            }
            set
            {
                externTypes = value;
            }
        }

        public MethodBase[] ExternMethods
        {
            get
            {
                return externMethods;
            }
            set
            {
                externMethods = value;
                externInvokers = new ExternInvoker[externMethods.Length]; 
            }
        }

        public string[] InternStrings
        {
            get
            {
                return internStrings;
            }
            set
            {
                internStrings = value;
            }
        }

        public FieldInfo[] FieldInfos
        {
            get
            {
                return fieldInfos;
            }
            set
            {
                fieldInfos = value;
            }
        }

        public Dictionary<int, NewFieldInfo> NewFieldInfos
        {
            get
            {
                return newFieldInfos;
            }
            set
            {
                newFieldInfos = value;
            }
        }

        public AnonymousStoreyInfo[] AnonymousStoreyInfos
        {
            get
            {
                return anonymousStoreyInfos;
            }
            set
            {
                anonymousStoreyInfos = value;
            }
        }

        public Type[] StaticFieldTypes
        {
            get
            {
                return staticFieldTypes;
            }
            set
            {
                staticFields = value != null ? new object[value.Length] : null;
                staticFieldTypes = value;
            }
        }

        public int[] Cctors
        {
            get
            {
                return cctors;
            }
            set
            {
                cctors = value;
            }
        }

        public WrappersManager WrappersManager
        {
            get
            {
                return wrappersManager;
            }
            set
            {
                wrappersManager = value;
            }
        }

        internal VirtualMachine(Instruction** unmanaged_codes, Action on_dispose)
        {
            unmanagedCodes = unmanaged_codes;
            onDispose = on_dispose;

            Cleanner.Start();
        }

        ~VirtualMachine()
        {
            onDispose();

            Cleanner.Stop();
            unmanagedCodes = null;
        }

        void checkCctorExecute(int fieldId, Value* argumentBase, object[] managedStack, Value* evaluationStackBase)
        {
            var cctorId = cctors[fieldId];
            //_Info("check " + fieldId + ", cctorId = " + cctorId);
            if (cctorId >= 0)
            {
                for(int i = 0; i < cctors.Length; i++)
                {
                    if (cctors[i] == cctorId)
                    {
                        //_Info("set " + i + " to -1");
                        cctors[i] = -1;
                    }
                }
                Execute(cctorId, argumentBase, managedStack, evaluationStackBase, 0);
            }
        }

        [Il2CppSetOption(Option.NullChecks, false)]
        [Il2CppSetOption(Option.ArrayBoundsChecks, false)]
        [Il2CppSetOption(Option.DivideByZeroChecks, false)]
        void store(Value* stackBase, Value* dst, Value* src, object[] managedStack)
        {
            *dst = *src;
            if (dst->Type >= ValueType.Object)
            {
                var obj = (dst->Type == ValueType.ValueType && managedStack[src->Value1] != null) //Nullable box后可能为空
                    ? objectClone.Clone(managedStack[src->Value1])
                    : managedStack[src->Value1];
                var dstPos = dst->Value1 = (int)(dst - stackBase);
                managedStack[dstPos] = obj;
            }
            else if (dst->Type == ValueType.ChainFieldReference)
            {
                managedStack[dst - stackBase] = managedStack[src - stackBase];
            }
        }

        [Il2CppSetOption(Option.NullChecks, false)]
        [Il2CppSetOption(Option.ArrayBoundsChecks, false)]
        [Il2CppSetOption(Option.DivideByZeroChecks, false)]
        void copy(Value* stackBase, Value* dst, Value* src, object[] managedStack)
        {
            *dst = *src;
            if (dst->Type == ValueType.ValueType)
            {
                object obj = null;
                if (managedStack[src->Value1] != null) //Nullable box后可能为空
                    obj = objectClone.Clone(managedStack[src->Value1]);
                var dstPos = dst->Value1 = (int)(dst - stackBase);
                managedStack[dstPos] = obj;
            }
            else if (dst->Type == ValueType.ChainFieldReference)
            {
                managedStack[dst - stackBase] = managedStack[src - stackBase];
            }
        }

        //[Il2CppSetOption(Option.NullChecks, false)]
        //[Il2CppSetOption(Option.ArrayBoundsChecks, false)]
        //[Il2CppSetOption(Option.DivideByZeroChecks, false)]
        public void Execute(int methodIndex, ref Call call, int argsCount, int refCount = 0)
        {
            Execute(unmanagedCodes[methodIndex], call.argumentBase + refCount, call.managedStack,
                call.evaluationStackBase, argsCount, methodIndex, refCount, call.topWriteBack);
        }


        //[Il2CppSetOption(Option.NullChecks, false)]
        //[Il2CppSetOption(Option.ArrayBoundsChecks, false)]
        //[Il2CppSetOption(Option.DivideByZeroChecks, false)]
        public Value* Execute(int methodIndex, Value* argumentBase, object[] managedStack,
            Value* evaluationStackBase, int argsCount)
        {
            return Execute(unmanagedCodes[methodIndex], argumentBase, managedStack, evaluationStackBase,
                argsCount, methodIndex);
        }

        void printStack(string title, Value* val)
        {
#if UNITY_5
            UnityEngine.Debug.Log(title + ", t=" + val->Type + ", v=" + val->Value1);
#else
            Console.WriteLine(title + ", t=" + val->Type + ", v=" + val->Value1);
#endif
        }

        //运行时本身的错误，业务的错误应该直接throw，坏处是未处理的系统异常会被业务逻辑catch，
        //但这个可以通过逐步完善解决如果是业务异常封装，那么类似checked()，反射调用业务代码，
        //都要先try-catch，然后封装。而且也无法区分反射调用带来的异常以及系统异常（都是unwrap）
        //因为反射有可能从新进入到解析器
        void throwRuntimeException(Exception e, bool bWrap)
        {
            if (bWrap)
            {
                var t = new RuntimeException();
                t.Real = e;
                throw t;
            }
            else
            {
                throw e;
            }
        }

        ExceptionHandler getExceptionHandler(int methodIndex, Type exceptionType, int pc)
        {
            var exceptionHandlersOfMethod = exceptionHandlers[methodIndex];
            for (int i = 0; i < exceptionHandlersOfMethod.Length; i++)
            {
                var exceptionHandler = exceptionHandlersOfMethod[i];
                //1 catch只能从先catch子类，再catch父类
                //2 排列顺序按Handle block来，外层处理的handle block肯定在内层的后面
                if (
                        (
                            exceptionHandler.HandlerType == ExceptionHandlerType.Finally 
                            || (exceptionHandler.HandlerType == ExceptionHandlerType.Catch
                            && exceptionHandler.CatchType.IsAssignableFrom(exceptionType))
                        ) //type match
                        && pc >= exceptionHandler.TryStart && pc < exceptionHandler.TryEnd
                    )
                {
                    return exceptionHandler;
                }
            }
            return null;
        }

        //Value* traceValue = null;

        void arrayGet(object obj, int idx, Value* val, object[] managedStack, Value* evaluationStackBase)
        {
            int[] intArr = obj as int[];
            if (intArr != null)
            {
                val->Type = ValueType.Integer;
                val->Value1 = intArr[idx];
                return;
            }
            float[] floatArr = obj as float[];
            if (floatArr != null)
            {
                val->Type = ValueType.Float;
                *(float*)&val->Value1 = floatArr[idx];
                return;
            }
            double[] doubleArr = obj as double[];
            if (doubleArr != null)
            {
                val->Type = ValueType.Double;
                *(double*)&val->Value1 = doubleArr[idx];
                return;
            }
            byte[] byteArr = obj as byte[];
            if (byteArr != null)
            {
                val->Type = ValueType.Integer;
                val->Value1 = byteArr[idx];
                return;
            }
            bool[] boolArr = obj as bool[];
            if (boolArr != null)
            {
                val->Type = ValueType.Integer;
                val->Value1 = boolArr[idx] ? 1 : 0;
                return;
            }
            long[] longArr = obj as long[];
            if (longArr != null)
            {
                val->Type = ValueType.Long;
                *(long*)&val->Value1 = longArr[idx];
                return;
            }
            ulong[] ulongArr = obj as ulong[];
            if (ulongArr != null)
            {
                val->Type = ValueType.Long;
                *(ulong*)&val->Value1 = ulongArr[idx];
                return;
            }
            sbyte[] sbyteArr = obj as sbyte[];
            if (sbyteArr != null)
            {
                val->Type = ValueType.Integer;
                val->Value1 = sbyteArr[idx];
                return;
            }
            short[] shortArr = obj as short[];
            if (shortArr != null)
            {
                val->Type = ValueType.Integer;
                val->Value1 = shortArr[idx];
                return;
            }
            ushort[] ushortArr = obj as ushort[];
            if (ushortArr != null)
            {
                val->Type = ValueType.Integer;
                val->Value1 = ushortArr[idx];
                return;
            }
            char[] charArr = obj as char[];
            if (charArr != null)
            {
                val->Type = ValueType.Integer;
                val->Value1 = charArr[idx];
                return;
            }
            uint[] uintArr = obj as uint[];
            if (uintArr != null)
            {
                val->Type = ValueType.Integer;
                val->Value1 = (int)uintArr[idx];
                return;
            }

            EvaluationStackOperation.PushObject(evaluationStackBase, val, managedStack,
                (obj as Array).GetValue(idx), obj.GetType().GetElementType());
        }

        void arraySet(object obj, int idx, Value* val, object[] managedStack, Value* evaluationStackBase)
        {
            int[] intArr = obj as int[];
            if (intArr != null)
            {
                intArr[idx] = val->Value1;
                return;
            }
            float[] floatArr = obj as float[];
            if (floatArr != null)
            {
                floatArr[idx] = *(float*)&val->Value1;
                return;
            }
            double[] doubleArr = obj as double[];
            if (doubleArr != null)
            {
                doubleArr[idx] = *(double*)&val->Value1;
                return;
            }
            byte[] byteArr = obj as byte[];
            if (byteArr != null)
            {
                byteArr[idx] = (byte)val->Value1;
                return;
            }
            bool[] boolArr = obj as bool[];
            if (boolArr != null)
            {
                boolArr[idx] = val->Value1 != 0;
                return;
            }
            long[] longArr = obj as long[];
            if (longArr != null)
            {
                longArr[idx] = *(long*)&val->Value1;
                return;
            }
            ulong[] ulongArr = obj as ulong[];
            if (ulongArr != null)
            {
                ulongArr[idx] = *(ulong*)&val->Value1;
                return;
            }
            sbyte[] sbyteArr = obj as sbyte[];
            if (sbyteArr != null)
            {
                sbyteArr[idx] = (sbyte)val->Value1;
                return;
            }
            short[] shortArr = obj as short[];
            if (shortArr != null)
            {
                shortArr[idx] = (short)val->Value1;
                return;
            }
            ushort[] ushortArr = obj as ushort[];
            if (ushortArr != null)
            {
                ushortArr[idx] = (ushort)val->Value1;
                return;
            }
            char[] charArr = obj as char[];
            if (charArr != null)
            {
                charArr[idx] = (char)val->Value1;
                return;
            }
            uint[] uintArr = obj as uint[];
            if (uintArr != null)
            {
                uintArr[idx] = (uint)val->Value1;
                return;
            }

            (obj as Array).SetValue(EvaluationStackOperation.ToObject(evaluationStackBase, val, managedStack,
                obj.GetType().GetElementType(), this), idx);
        }

        public static Action<string> Info = Console.WriteLine;

        public static void _Info(string a)
        {
            if (Info != null) Info(a);
        }

        //[Il2CppSetOption(Option.NullChecks, false)]
        //[Il2CppSetOption(Option.ArrayBoundsChecks, false)]
        //[Il2CppSetOption(Option.DivideByZeroChecks, false)]
        // #lizard forgives
        public Value* Execute(Instruction* pc, Value* argumentBase, object[] managedStack,
            Value* evaluationStackBase, int argsCount, int methodIndex,
            int refCount = 0, Value** topWriteBack = null)
        {
            if (pc->Code != Code.StackSpace) //TODO:删了pc会慢，但手机可能会快
            {
                throwRuntimeException(new InvalidProgramException("invalid code!"), topWriteBack == null);
            }

            int leavePoint = 0; //由于首指令是插入的StackSpace，所以leavePoint不可能等于0
            Exception throwExcepton = null; //use by rethrow
            Instruction* pcb = pc;

            int localsCount = (pc->Operand >> 16);
            int maxStack = (pc->Operand & 0xFFFF);
            //Console.WriteLine("localsCount:" + localsCount + ",maxStack:" + maxStack + ", argumentBase:"
            //    + (long)argumentBase);

            int argumentPos = (int)(argumentBase - evaluationStackBase);
            if (argumentPos + argsCount + localsCount + maxStack > MAX_EVALUATION_STACK_SIZE)
            {
                throwRuntimeException(new StackOverflowException(), topWriteBack == null);
            }

            Value* localBase = argumentBase + argsCount;
            Value* evaluationStackPointer = localBase + localsCount;
            //Debug.Log("loc:" + ((int)(code[0].TokenLong >> 32)));
            //Debug.Log("stackSize:" + stackSize + ", arg.length:" + (locs - args) + ", locs.length:"
            //    + (esp - locs) + ",es.length:" + (stackSize - (esp - stack)));

            pc++;

            //if (methodIndex == 7)
            //{
            //    traceValue = argumentBase + 1;
            //}

            while (true) //TODO: 常用指令应该放前面
            {
                try
                {
                    var code = pc->Code;
                    //if (methodIndex == 527 || methodIndex == 528)
                    //{
                    //    _Info("** Method Id = " + methodIndex + ", Start Code = " + code + ", Oprand = "
                    //        + pc->Operand + ", ESP = " + (evaluationStackPointer - localBase - localsCount)
                    //        + ", ABS = " + (evaluationStackPointer - evaluationStackBase));
                    //if (methodIndex == 84 && code == Code.Ldfld) throw new Exception("stop");
                    //}
                    //if (traceValue != null)
                    //{
                    //    _Info("before:" + traceValue->Type + "," + traceValue->Value1 + (traceValue->Type
                    //        == ValueType.Object ? ("," + managedStack[traceValue->Value1]) : ""));
                    //}
                    switch (code)
                    {
                        //Ldarg_0: 10.728% Ldarg_1: 4.4% Ldarg_2: 1.87% Ldarg_S:0.954%  Ldarg_3:0.93%
                        case Code.Ldarg:
                            {
                                //if (methodIndex == 197)
                                //{
                                //    var a = argumentBase + pc->Operand;
                                //    if (a->Type == ValueType.FieldReference)
                                //    {
                                //        var fieldInfo = fieldInfos[a->Value2];
                                //        _Info("field: " + fieldInfo.DeclaringType + "." + fieldInfo.Name);
                                //        _Info("a->Value1:" + a->Value1);
                                //        var obj = managedStack[a->Value1];
                                //        _Info("a.obj = " + (obj == null ? "null" : obj.ToString()));
                                //    }
                                //}
                                copy(evaluationStackBase, evaluationStackPointer, argumentBase + pc->Operand,
                                    managedStack);
                                //if (methodIndex == 197)
                                //{
                                //    var a = evaluationStackPointer;
                                //    if (a->Type == ValueType.FieldReference)
                                //    {
                                //        var fieldInfo = fieldInfos[a->Value2];
                                //        _Info("ep field: " + fieldInfo.DeclaringType + "." + fieldInfo.Name);
                                //        _Info("ep a->Value1:" + a->Value1);
                                //        var obj = managedStack[a->Value1];
                                //        _Info("ep a.obj = " + (obj == null ? "null" : obj.ToString()));
                                //    }
                                //}
                                evaluationStackPointer++;
                            }
                            break;
                        case Code.Call:// Call: 8.1233%
                            {
                                int narg = pc->Operand >> 16;
                                //Console.WriteLine("narg:" + narg);
                                //Console.WriteLine("before call ESP = " + (evaluationStackPointer - localBase
                                //    - localsCount) + ", ESPV=" + (long)evaluationStackPointer);
                                //printStack("a 1", evaluationStackPointer - 1 - 1);
                                //printStack("a 2", evaluationStackPointer - 1);
                                int methodIndexToCall = pc->Operand & 0xFFFF;
                                //if (methodIndex == 196 || methodIndex == 197 || methodIndex == 13)
                                //{
                                //    _Info("methodIndexToCall:" + methodIndexToCall);
                                //}
                                evaluationStackPointer = Execute(unmanagedCodes[methodIndexToCall],
                                    evaluationStackPointer - narg, managedStack, evaluationStackBase, narg,
                                    methodIndexToCall);
                                //Console.WriteLine("after call ESP = " + (evaluationStackPointer - localBase
                                //    - localsCount));
                                //printStack("ret", evaluationStackPointer - 1);
                            }
                            break;
                        case Code.Callvirt: //Callvirt: 5.156
                            {
                                int narg = pc->Operand >> 16;
                                var arg0 = evaluationStackPointer - narg;
                                if (arg0->Type != ValueType.Object)
                                {
                                    throwRuntimeException(new InvalidProgramException(arg0->Type.ToString()
                                        + " for Callvirt"), true);
                                }
                                if (managedStack[arg0->Value1] == null)
                                {
                                    throw new NullReferenceException("this is null");
                                }
                                //Console.WriteLine("narg:" + narg);
                                //Console.WriteLine("before call ESP = " + (evaluationStackPointer - localBase
                                //    - localsCount) + ", ESPV=" + (long)evaluationStackPointer);
                                //printStack("a 1", evaluationStackPointer - 1 - 1);
                                //printStack("a 2", evaluationStackPointer - 1);
                                int methodIndexToCall = pc->Operand & 0xFFFF;
                                //if (methodIndex == 203)
                                //{
                                //    _Info("methodIndexToCall:" + methodIndexToCall);
                                //}
                                evaluationStackPointer = Execute(unmanagedCodes[methodIndexToCall],
                                    evaluationStackPointer - narg, managedStack, evaluationStackBase,
                                    narg, methodIndexToCall);
                                //Console.WriteLine("after call ESP = " + (evaluationStackPointer - localBase
                                //    - localsCount));
                                //printStack("ret", evaluationStackPointer - 1);
                            }
                            break;

                        case Code.Callvirtvirt:
                            {
                                int narg = pc->Operand >> 16;
                                var arg0 = evaluationStackPointer - narg;
                                if (arg0->Type != ValueType.Object)
                                {
                                    throwRuntimeException(new InvalidProgramException(arg0->Type.ToString()
                                        + " for Callvirtvirt"), true);
                                }
                                if (managedStack[arg0->Value1] == null)
                                {
                                    throw new NullReferenceException("this is null");
                                }
                                var anonObj =  managedStack[arg0->Value1] as AnonymousStorey;
                                int[] vTable = anonymousStoreyInfos[anonObj.typeId].VTable;
                                int methodIndexToCall = vTable[pc->Operand & 0xFFFF];
                                evaluationStackPointer = Execute(unmanagedCodes[methodIndexToCall],
                                    evaluationStackPointer - narg, managedStack, evaluationStackBase,
                                    narg, methodIndexToCall);
                            }
                            break;

                        case Code.Ldvirtftn2:
                            {
                                int slot = pc->Operand & 0xFFFF;
                                var pm = evaluationStackPointer - 1;
                                var po = pm - 1;
                                var anonObj = managedStack[po->Value1] as AnonymousStorey;
                                pm->Value1 = anonymousStoreyInfos[anonObj.typeId].VTable[slot];
                                pm->Type = ValueType.Integer;
                            }
                            break;

                        case Code.CallExtern://部分来自Call部分来自Callvirt
                        case Code.Newobj: // 2.334642%
                            int methodId = pc->Operand & 0xFFFF;
                            if (code == Code.Newobj)
                            {
                                var method = externMethods[methodId];
                                if (method.DeclaringType.BaseType == typeof(MulticastDelegate)) // create delegate
                                {
                                    var pm = evaluationStackPointer - 1;
                                    var po = pm - 1;
                                    var o = managedStack[po->Value1];
                                    managedStack[po - evaluationStackBase] = null;
                                    Delegate del = null;
                                    if (pm->Type == ValueType.Integer)
                                    {
                                        //_Info("new closure!");
                                        del = wrappersManager.CreateDelegate(method.DeclaringType, pm->Value1, o);
                                        if (del == null)
                                        {
                                            del = GenericDelegateFactory.Create(method.DeclaringType, this,
                                                pm->Value1, o);
                                        }
                                        if (del == null)
                                        {
                                            throwRuntimeException(
                                                new InvalidProgramException("no closure wrapper for "
                                                + method.DeclaringType), true);
                                        }
                                    }
                                    //else if (pm->Type == ValueType.Float) // 
                                    //{
                                    //    del = GetGlobalWrappersManager().CreateDelegate(method.DeclaringType,
                                    //        pm->Value1, null);
                                    //    if (del == null)
                                    //    {
                                    //        throwRuntimeException(new InvalidProgramException(
                                    //            "no closure wrapper for " + method.DeclaringType), true);
                                    //    }
                                    //}
                                    else
                                    {
                                        var mi = managedStack[pm->Value1] as MethodInfo;
                                        managedStack[pm - evaluationStackBase] = null;
                                        del = Delegate.CreateDelegate(method.DeclaringType, o, mi);
                                    }
                                    po->Value1 = (int)(po - evaluationStackBase);
                                    managedStack[po->Value1] = del;
                                    evaluationStackPointer = pm;
                                    break;
                                }
                            }
                            int paramCount = pc->Operand >> 16;
                            var externInvokeFunc = externInvokers[methodId];
                            if (externInvokeFunc == null)
                            {
                                externInvokers[methodId] = externInvokeFunc
                                    = (new ReflectionMethodInvoker(externMethods[methodId])).Invoke;
                            }
                            //Info("call extern: " + externMethods[methodId]);
                            var top = evaluationStackPointer - paramCount;
                            //for(int kk = 0; kk < paramCount; kk++)
                            //{
                            //    string info = "arg " + kk + " " + (top + kk)->Type.ToString() + ": ";
                            //    if ((top + kk)->Type >= ValueType.Object)
                            //    {
                            //        var o = managedStack[(top + kk)->Value1];
                            //        info += "obj(" + (o == null ? "null" : o.GetHashCode().ToString()) + ")";
                            //    }
                            //    else
                            //    {
                            //        info += (top + kk)->Value1;
                            //    }
                            //    Info(info);
                            //}
                            Call call = new Call()
                            {
                                argumentBase = top,
                                currentTop = top,
                                managedStack = managedStack,
                                evaluationStackBase = evaluationStackBase
                            };
                            //调用外部前，需要保存当前top，以免外部从新进入内部时覆盖栈
                            ThreadStackInfo.Stack.UnmanagedStack->Top = evaluationStackPointer;
                            externInvokeFunc(this, ref call, code == Code.Newobj);
                            evaluationStackPointer = call.currentTop;
                            break;
                        //Ldloc_0:3.35279% Ldloc_S:2.624982% Ldloc_1:1.958552% Ldloc_2:1.278956% Ldloc_3:0.829925%
                        case Code.Ldloc:
                            {
                                //print("+++ldloc", locs + ins.Operand);
                                //if (methodIndex == 326)
                                //{
                                //    var a = localBase + pc->Operand;
                                //    _Info("l->Type:" + a->Type + ", l->Value1:" + a->Value1);
                                //    if (a->Type == ValueType.Object)
                                //    {
                                //        var obj = managedStack[a->Value1];
                                //        _Info("l.obj = " + (obj == null ? "null" : obj.GetType() + "(" 
                                //        + obj.GetHashCode() + ")"));
                                //    }
                                //}
                                copy(evaluationStackBase, evaluationStackPointer, localBase + pc->Operand, 
                                    managedStack);
                                //if (methodIndex == 326)
                                //{
                                //    var a = evaluationStackPointer;
                                //    _Info("e->Type:" + a->Type + ", e->Value1:" + a->Value1);
                                //    if (a->Type == ValueType.Object)
                                //    {
                                //        var obj = managedStack[a->Value1];
                                //        _Info("e.obj = " + (obj == null ? "null" : obj.GetType() + "(" 
                                //        + obj.GetHashCode() + ")"));
                                //    }
                                //}
                                evaluationStackPointer++;
                            }
                            break;
                        // Ldc_I4_0:3% Ldc_I4_1:2.254763% Ldc_I4_S:1.16403% Ldc_I4:0.8208519% Ldc_I4_2:0.58922%
                        // Ldc_I4_4:0.3086645% Ldc_I4_M1:0.2323434% Ldc_I4_8:0.1894684% Ldc_I4_3:0.1850208%
                        // Ldc_I4_5:0.1158159% Ldc_I4_7:0.08076869% Ldc_I4_6:0.07045022%
                        case Code.Ldc_I4:
                            {
                                //*((long*)(&evaluationStackPointer->Value1)) = pc->Operand;
                                evaluationStackPointer->Value1 = pc->Operand; //高位不清除
                                evaluationStackPointer->Type = ValueType.Integer;
                                evaluationStackPointer++;
                            }
                            break;
                        case Code.Ret:// 5.5% TODO: 分为带返回值和不带返回值
                            {
                                //TODO: 可优化? 检查到没都是基本类型后改指令
                                
                                if (topWriteBack != null)
                                {
                                    *topWriteBack = argumentBase - refCount;
                                }
                                throwExcepton = null;
                                if (pc->Operand != 0)
                                {
                                    *argumentBase = *(evaluationStackPointer - 1);
                                    if (argumentBase->Type == ValueType.Object
                                        || argumentBase->Type == ValueType.ValueType)
                                    {
                                        int resultPos = argumentBase->Value1;
                                        if (resultPos != argumentPos)
                                        {
                                            managedStack[argumentPos] = managedStack[resultPos];
                                            //managedStack[resultPos] = null;
                                        }
                                        argumentBase->Value1 = argumentPos;
                                    }
                                    for (int i = 0; i < evaluationStackPointer - evaluationStackBase - 1; i++)
                                    {
                                        managedStack[i + argumentPos + 1] = null;
                                    }

                                    return argumentBase + 1;
                                }
                                else
                                {
                                    for (int i = 0; i < evaluationStackPointer - evaluationStackBase; i++)
                                    {
                                        managedStack[i + argumentPos] = null;
                                    }
                                    return argumentBase;
                                }
                            }
                        //Stloc_0:1.717491% Stloc_S:1.316672% Stloc_1:1.020105% Stloc_2:0.6683876% Stloc_3:0.4547242%
                        case Code.Stloc:
                            {
                                evaluationStackPointer--;
                                //print("+++before stloc", locs + ins.Operand);
                                store(evaluationStackBase, localBase + pc->Operand, evaluationStackPointer,
                                    managedStack);
                                //print("+++after stloc", locs + ins.Operand);
                                managedStack[evaluationStackPointer - evaluationStackBase] = null;
                            }
                            break;
                        case Code.Ldfld: //5.017799%
                            {
                                var ptr = evaluationStackPointer - 1;
                                var fieldIndex = pc->Operand;
                                //_Info("Ldfld fieldIndex:" + fieldIndex);
                                if (fieldIndex >= 0)
                                {
                                    var fieldInfo = fieldInfos[fieldIndex];
                                    //_Info("Ldfld fieldInfo:" + fieldInfo);

                                    Type declaringType = null;
                                    Type fieldType = null;
                                    string fieldName = null;
                                    
                                    if(fieldInfo == null)
                                    {
                                        fieldName = newFieldInfos[fieldIndex].Name;
                                        fieldType = newFieldInfos[fieldIndex].FieldType;
                                        declaringType = newFieldInfos[fieldIndex].DeclaringType;
                                    }
                                    else
                                    {
                                        fieldName = fieldInfo.Name;
                                        fieldType = fieldInfo.FieldType;
                                        declaringType = fieldInfo.DeclaringType;
                                    }
                                    
                                    object obj = EvaluationStackOperation.ToObject(evaluationStackBase, ptr,
                                        managedStack, declaringType, this, false);
                                    
                                    if (obj == null)
                                    {
                                        throw new NullReferenceException(declaringType + "." + fieldName);
                                    }
                                    //_Info("Ldfld:" + fieldInfo + ",obj=" + obj.GetType());
                                    
                                    object fieldValue = null;
  
                                    if(fieldInfo == null)
                                    {
                                        newFieldInfos[fieldIndex].CheckInit(this, obj);
                                        
                                        fieldValue = newFieldInfos[fieldIndex].GetValue(obj);
                                    }
                                    else
                                    {
                                        fieldValue = fieldInfo.GetValue(obj);
                                    }

                                    //_Info("fieldValue:" + fieldValue);
                                    //throw new Exception("fieldValue=" + fieldValue);
                                    EvaluationStackOperation.PushObject(evaluationStackBase, ptr, managedStack,
                                        fieldValue, fieldType);
                                }
                                else
                                {
                                    fieldIndex = -(fieldIndex + 1);
                                    AnonymousStorey anonyObj = managedStack[ptr->Value1] as AnonymousStorey;
                                    anonyObj.Ldfld(fieldIndex, evaluationStackBase, ptr, managedStack);
                                }
                            }
                            break;
                        case Code.Ldstr://2.656827%
                            {
                                EvaluationStackOperation.PushObject(evaluationStackBase, evaluationStackPointer,
                                    managedStack, internStrings[pc->Operand], typeof(string));
                                evaluationStackPointer++;
                            }
                            break;
                        case Code.Brfalse://Brfalse_S:2.418613% Brfalse:0.106387%
                            {
                                bool transfer = false;
                                evaluationStackPointer--;
                                switch (evaluationStackPointer->Type)
                                {
                                    case ValueType.Integer:
                                        transfer = evaluationStackPointer->Value1 == 0;
                                        break;
                                    case ValueType.Long:
                                        transfer = *(long*)&evaluationStackPointer->Value1 == 0;
                                        break;
                                    case ValueType.Object:
                                    case ValueType.ValueType:
                                        transfer = managedStack[evaluationStackPointer->Value1] == null;
                                        break;
                                }
                                managedStack[evaluationStackPointer - evaluationStackBase] = null;
                                if (transfer)
                                {
                                    pc += pc->Operand;
                                    continue;
                                }
                            }
                            break;
                        case Code.Stfld://2.13361%
                            {
                                var ptr = evaluationStackPointer - 1 - 1;
                                var fieldIndex = pc->Operand;
                                if (fieldIndex >= 0)
                                {
                                    var fieldInfo = fieldInfos[pc->Operand];

                                    Type declaringType = null;
                                    Type fieldType = null;
                                    string fieldName = null;
                                    
                                    if(fieldInfo == null)
                                    {
                                        fieldName = newFieldInfos[fieldIndex].Name;
                                        fieldType = newFieldInfos[fieldIndex].FieldType;
                                        declaringType = newFieldInfos[fieldIndex].DeclaringType;
                                    }
                                    else
                                    {
                                        fieldName = fieldInfo.Name;
                                        fieldType = fieldInfo.FieldType;
                                        declaringType = fieldInfo.DeclaringType;
                                    }

                                    object obj = EvaluationStackOperation.ToObject(evaluationStackBase, ptr,
                                        managedStack, declaringType, this, false);

                                    if (obj == null)
                                    {
                                        throw new NullReferenceException(declaringType + "." + fieldName);
                                    }

                                    if(fieldInfo != null)
                                    {
                                        fieldInfo.SetValue(obj, EvaluationStackOperation.ToObject(evaluationStackBase,
                                            evaluationStackPointer - 1, managedStack, fieldType, this));
                                    }
                                    else
                                    {
                                        newFieldInfos[fieldIndex].SetValue(obj, EvaluationStackOperation.ToObject(evaluationStackBase,
                                            evaluationStackPointer - 1, managedStack, fieldType, this));
                                    }

                                    //如果field，array元素是值类型，需要重新update回去
                                    if ((ptr->Type == ValueType.FieldReference
                                        || ptr->Type == ValueType.ChainFieldReference
                                        || ptr->Type == ValueType.StaticFieldReference
                                        || ptr->Type == ValueType.ArrayReference) 
                                        && declaringType.IsValueType)
                                    {
                                        EvaluationStackOperation.UpdateReference(evaluationStackBase, ptr,
                                            managedStack, obj, this, declaringType);
                                    }
                                    managedStack[ptr - evaluationStackBase] = null;
                                    managedStack[evaluationStackPointer - 1 - evaluationStackBase] = null;
                                    evaluationStackPointer = ptr;
                                }
                                else
                                {
                                    fieldIndex = -(fieldIndex + 1);
                                    object obj = EvaluationStackOperation.ToObject(evaluationStackBase, ptr,
                                       managedStack, ptr->Type.GetType(), this, false);
                                    AnonymousStorey anonyObj = obj as AnonymousStorey;
                                    anonyObj.Stfld(fieldIndex, evaluationStackBase, evaluationStackPointer - 1, 
                                        managedStack);
                                    evaluationStackPointer = ptr;
                                }
                            }
                            break;
                        case Code.Brtrue://Brtrue_S:1.944675% Brtrue:0.07400832%
                            {
                                bool transfer = false;
                                evaluationStackPointer--;
                                switch (evaluationStackPointer->Type)
                                {
                                    case ValueType.Integer:
                                        transfer = evaluationStackPointer->Value1 != 0;
                                        break;
                                    case ValueType.Long:
                                        transfer = *(long*)&evaluationStackPointer->Value1 != 0;
                                        break;
                                    case ValueType.Object:
                                    case ValueType.ValueType:
                                        transfer = managedStack[evaluationStackPointer->Value1] != null;
                                        break;
                                }
                                managedStack[evaluationStackPointer - evaluationStackBase] = null;
                                if (transfer)
                                {
                                    pc += pc->Operand;
                                    continue;
                                }
                            }
                            break;
                        case Code.Add://1.356345%
                            {
                                Value* b = evaluationStackPointer - 1;
                                //大于1的立即数和指针运算在il2cpp（unity 5.4）有bug，都会按1算
                                Value* a = evaluationStackPointer - 1 - 1;
                                evaluationStackPointer = a;
                                switch (a->Type)//TODO: 通过修改指令优化掉
                                {
                                    case ValueType.Long:
                                        *((long*)&evaluationStackPointer->Value1)
                                            = *((long*)&a->Value1) + *((long*)&b->Value1);
                                        break;
                                    case ValueType.Integer:
                                        evaluationStackPointer->Value1 = a->Value1 + b->Value1;
                                        break;
                                    case ValueType.Float:
                                        *((float*)&evaluationStackPointer->Value1)
                                            = *((float*)&a->Value1) + *((float*)&b->Value1);
                                        break;
                                    case ValueType.Double:
                                        *((double*)&evaluationStackPointer->Value1)
                                            = *((double*)&a->Value1) + *((double*)&b->Value1);
                                        break;
                                    default:
                                        throwRuntimeException(new NotImplementedException(), true);
                                        break;
                                }
                                evaluationStackPointer++;
                            }
                            break;
                        case Code.Br://Br_S:1.162784% Br:0.2334108%
                            {
                                pc += pc->Operand;
                            }
                            continue;
                        case Code.Ldnull://1.203347%
                            {
                                var pos = (int)(evaluationStackPointer - evaluationStackBase);
                                managedStack[pos] = null;
                                evaluationStackPointer->Value1 = pos;
                                evaluationStackPointer->Type = ValueType.Object;
                                evaluationStackPointer++;
                            }
                            break;
                        case Code.Ldloca: //Ldloca_S:1.023663%
                            {
                                *(Value**)&evaluationStackPointer->Value1 = localBase + pc->Operand;
                                evaluationStackPointer->Type = ValueType.StackReference;
                                evaluationStackPointer++;
                            }
                            break;
                        case Code.Dup://0.9831008%
                            copy(evaluationStackBase, evaluationStackPointer, evaluationStackPointer - 1,
                                managedStack);
                            evaluationStackPointer++;
                            break;
                        case Code.Ldsfld: //0.7173114%
                            {
                                var fieldIndex = pc->Operand;
                                if (fieldIndex >= 0)
                                {
                                    var fieldInfo = fieldInfos[fieldIndex];
                                    Type fieldType = null;

                                    object fieldValue = null;

                                    if (fieldInfo == null)
                                    {
                                        newFieldInfos[fieldIndex].CheckInit(this, null);

                                        fieldType = newFieldInfos[fieldIndex].FieldType;
                                        fieldValue = newFieldInfos[fieldIndex].GetValue(null);
                                    }
                                    else
                                    {
                                        fieldType = fieldInfo.FieldType;
                                        fieldValue = fieldInfo.GetValue(null);
                                    }
                                    
                                    EvaluationStackOperation.PushObject(evaluationStackBase, evaluationStackPointer,
                                        managedStack, fieldValue, fieldType);
                                }
                                else
                                {
                                    fieldIndex = -(fieldIndex + 1);
                                    checkCctorExecute(fieldIndex, evaluationStackPointer, managedStack,
                                        evaluationStackBase);
                                    //_Info("load static field " + fieldIndex + " : " + staticFields[fieldIndex]);
                                    EvaluationStackOperation.PushObject(evaluationStackBase,
                                        evaluationStackPointer, managedStack,
                                        staticFields[fieldIndex], staticFieldTypes[fieldIndex]);
                                }
                                evaluationStackPointer++;
                            }
                            break;
                        case Code.Conv_I4: //0.5349591%
                            {
                                var ptr = evaluationStackPointer - 1;
                                int val = 0;
                                switch (ptr->Type)
                                {
                                    case ValueType.Long:
                                        val = (int)*(long*)&ptr->Value1;
                                        break;
                                    case ValueType.Float:
                                        val = (int)*(float*)&ptr->Value1;
                                        break;
                                    case ValueType.Double:
                                        val = (int)*(double*)&ptr->Value1;
                                        break;
                                    case ValueType.Integer:
                                        val = ptr->Value1;
                                        break;
                                }
                                ptr->Type = ValueType.Integer;
                                ptr->Value1 = val;
                            }
                            break;
                        case Code.Sub: //0.5299778%
                            {
                                Value* b = evaluationStackPointer - 1;
                                Value* a = evaluationStackPointer - 1 - 1;
                                evaluationStackPointer = a;
                                switch (a->Type)
                                {
                                    case ValueType.Long:
                                        *((long*)&evaluationStackPointer->Value1)
                                            = *((long*)&a->Value1) - *((long*)&b->Value1);
                                        break;
                                    case ValueType.Integer:
                                        evaluationStackPointer->Value1 = a->Value1 - b->Value1;
                                        break;
                                    case ValueType.Float:
                                        *((float*)&evaluationStackPointer->Value1)
                                            = *((float*)&a->Value1) - *((float*)&b->Value1);
                                        break;
                                    case ValueType.Double:
                                        *((double*)&evaluationStackPointer->Value1)
                                            = *((double*)&a->Value1) - *((double*)&b->Value1);
                                        break;
                                    default:
                                        throwRuntimeException(new NotImplementedException(), true);
                                        break;
                                }
                                evaluationStackPointer++;
                            }
                            break;
                        case Code.Ldlen: //0.5175245%
                            {
                                var ptr = evaluationStackPointer - 1;
                                Array arr = managedStack[ptr->Value1] as Array;
                                managedStack[ptr - evaluationStackBase] = null;
                                ptr->Type = ValueType.Integer;
                                ptr->Value1 = arr.Length;
                            }
                            break;
                        //TODO: 指令是否可以精简？比如if (a > b) 可以等同于if (b < a)
                        case Code.Blt: //Blt_S:0.4835447% Blt:0.04465406% 
                            {
                                var b = evaluationStackPointer - 1;
                                var a = evaluationStackPointer - 1 - 1;
                                evaluationStackPointer = a;
                                bool transfer = false;
                                switch (evaluationStackPointer->Type)
                                {
                                    case ValueType.Integer:
                                        transfer = a->Value1 < b->Value1;
                                        break;
                                    case ValueType.Long:
                                        transfer = *(long*)&a->Value1 < *(long*)&b->Value1;
                                        break;
                                    case ValueType.Float:
                                        transfer = *(float*)&a->Value1 < *(float*)&b->Value1;
                                        break;
                                    case ValueType.Double:
                                        transfer = *(double*)&a->Value1 < *(double*)&b->Value1;
                                        break;
                                }

                                if (transfer)
                                {
                                    pc += pc->Operand;
                                    continue;
                                }
                            }
                            break;
                        case Code.Stelem_Ref: //0.4734042%
                            {
                                var arrPtr = evaluationStackPointer - 1 - 1 - 1;
                                int idx = (evaluationStackPointer - 1 - 1)->Value1;
                                var valPtr = evaluationStackPointer - 1;
                                var arr = managedStack[arrPtr->Value1] as object[];
                                if (valPtr->Type != ValueType.Object)
                                {
                                    throw new ArrayTypeMismatchException();
                                }
                                arr[idx] = managedStack[valPtr->Value1];
                                managedStack[arrPtr - evaluationStackBase] = null; //清理，如果有的话
                                managedStack[valPtr - evaluationStackBase] = null;
                                evaluationStackPointer = arrPtr;
                            }
                            break;
                        case Code.Pop://0.4614846%
                            {
                                evaluationStackPointer--;
                                managedStack[evaluationStackPointer - evaluationStackBase] = null; ;
                            }
                            break;
                        case Code.Bne_Un://Bne_Un_S:0.4565032% Bne_Un:0.02793102%
                            {
                                var b = evaluationStackPointer - 1;
                                var a = evaluationStackPointer - 1 - 1;
                                evaluationStackPointer = a;
                                if (a->Type != b->Type
                                    || ((a->Type == ValueType.Object || a->Type == ValueType.ValueType) ?
                                    (managedStack[a->Value1] != managedStack[b->Value1]) :
                                    ((a->Value1 != b->Value1) || (a->Type != ValueType.Integer
                                    && a->Type != ValueType.Float && a->Value2 != b->Value2))))
                                {
                                    pc += pc->Operand;
                                    continue;
                                }
                            }
                            break;
                        case Code.Leave://Leave_S:0.4552579% Leave:0.03220074%
                            {
                                leavePoint = pc->Operand;
                            }
                            break;
                        case Code.Newarr: //0.4408476%
                            {
                                var type = externTypes[pc->Operand];
                                var ptr = evaluationStackPointer - 1;
                                int pos = (int)(ptr - evaluationStackBase);
                                managedStack[pos] = Array.CreateInstance(type, ptr->Value1);
                                ptr->Type = ValueType.Object;
                                ptr->Value1 = pos;
                            }
                            break;
                        case Code.And: //0.3967273%
                            {
                                var rhs = evaluationStackPointer - 1;
                                var lhs = evaluationStackPointer - 1 - 1;
                                switch (lhs->Type)
                                {
                                    case ValueType.Long:
                                        *((long*)&lhs->Value1) = *((long*)&lhs->Value1) & *((long*)&rhs->Value1);
                                        break;
                                    case ValueType.Integer:
                                        lhs->Value1 = lhs->Value1 & rhs->Value1;
                                        break;
                                    default:
                                        throw new InvalidProgramException("& for " + lhs->Type);
                                }
                                evaluationStackPointer = rhs;
                            }
                            break;
                        case Code.Volatile: //0.3912123%
                            break;
                        case Code.Castclass: //0.358122%
                            {
                                var ptr = evaluationStackPointer - 1;
                                var type = pc->Operand >= 0 ? externTypes[pc->Operand] : typeof(AnonymousStorey);
                                var obj = managedStack[ptr->Value1];
                                if (obj != null)
                                {
                                    bool canAssign = type.IsAssignableFrom(obj.GetType());
                                    if(!canAssign)
                                    {
                                        throw new InvalidCastException(type + " is not assignable from "
                                            + obj.GetType());
                                    }

                                    if(canAssign && pc->Operand < 0 && (obj is AnonymousStorey) && (obj as AnonymousStorey).typeId != -(pc->Operand+1) )
                                    {
                                        var fromInfo = anonymousStoreyInfos[(obj as AnonymousStorey).typeId];
                                        var targetInfo = anonymousStoreyInfos[-(pc->Operand+1)];
                                        
                                        if(fromInfo.Slots != null && targetInfo.Slots != null && fromInfo.Slots.Length == targetInfo.Slots.Length)
                                        {
                                            for(int i = 0; i < fromInfo.Slots.Length; ++i)
                                            {
                                                if(fromInfo.Slots[i] != targetInfo.Slots[i])
                                                {
                                                    canAssign = false;
                                                    break;
                                                }
                                            }
                                        }
                                        else
                                        {
                                            canAssign = false;
                                        }
                                        
                                        if(!canAssign)
                                        {
                                            throw new InvalidCastException("AnonymousStorey typeid different, " + (obj as AnonymousStorey).typeId + " <-> " + -(pc->Operand+1));
                                        }
                                    }
                                }
                            }
                            break;
                        case Code.Beq://Beq_S:0.3517174% Beq: 0.03700416%
                            {
                                var b = evaluationStackPointer - 1;
                                var a = evaluationStackPointer - 1 - 1;
                                evaluationStackPointer = a;
                                if (a->Type == b->Type && ((a->Type == ValueType.Object
                                    || a->Type == ValueType.ValueType) ?
                                    (managedStack[a->Value1] == managedStack[b->Value1]) :
                                    ((a->Value1 == b->Value1) && (a->Type == ValueType.Integer
                                    || a->Type == ValueType.Float || a->Value2 == b->Value2))))
                                {
                                    pc += pc->Operand;
                                    continue;
                                }
                            }
                            break;
                        case Code.Ldelem_Ref: //0.3449571%
                            {
                                var arrPtr = evaluationStackPointer - 1 - 1;
                                int idx = (evaluationStackPointer - 1)->Value1;
                                var arrPos = arrPtr - evaluationStackBase;
                                var arr = managedStack[arrPtr->Value1] as object[];
                                managedStack[arrPos] = arr[idx];
                                arrPtr->Value1 = (int)arrPos;
                                evaluationStackPointer = evaluationStackPointer - 1;
                            }
                            break;
                        case Code.Ldtype:// Ldtoken:0.3325037%
                            EvaluationStackOperation.PushObject(evaluationStackBase, evaluationStackPointer,
                                managedStack, externTypes[pc->Operand], typeof(Type));
                            evaluationStackPointer++;
                            break;
                        case Code.Box://0.3100877%
                            {
                                var ptr = evaluationStackPointer - 1;
                                if(pc->Operand >= 0)
                                {
                                    var type = externTypes[pc->Operand];
                                    var pos = (int)(ptr - evaluationStackBase);
                                    switch (ptr->Type)
                                    {
                                        case ValueType.ValueType:
                                        case ValueType.Object:
                                            break;
                                        case ValueType.Integer:
                                            if (type.IsEnum)
                                            {
                                                managedStack[pos] = Enum.ToObject(type, ptr->Value1);
                                            }
                                            else if (type == typeof(int))
                                            {
                                                managedStack[pos] = ptr->Value1;
                                            }
                                            else if (type == typeof(uint))
                                            {
                                                managedStack[pos] = (uint)ptr->Value1;
                                            }
                                            else
                                            {
                                                managedStack[pos] = Convert.ChangeType(ptr->Value1, type);
                                            }
                                            ptr->Value1 = pos;
                                            break;
                                        case ValueType.Long:
                                            if (type == typeof(long))
                                            {
                                                managedStack[pos] = *(long*)&ptr->Value1;
                                            }
                                            else if (type == typeof(ulong))
                                            {
                                                managedStack[pos] = *(ulong*)&ptr->Value1;
                                            }
                                            else if (type.IsEnum)
                                            {
                                                managedStack[pos] = Enum.ToObject(type, *(long*)&ptr->Value1);
                                            }
                                            else if (type == typeof(IntPtr))
                                            {
                                                managedStack[pos] = new IntPtr(*(long*)&ptr->Value1);
                                            }
                                            else if (type == typeof(UIntPtr))
                                            {
                                                managedStack[pos] = new UIntPtr(*(ulong*)&ptr->Value1);
                                            }
                                            else
                                            {
                                                managedStack[pos] = Convert.ChangeType(*(long*)&ptr->Value1, type);
                                            }
                                            ptr->Value1 = pos;
                                            break;
                                        case ValueType.Float:
                                            managedStack[pos] = *(float*)&ptr->Value1;
                                            ptr->Value1 = pos;
                                            break;
                                        case ValueType.Double:
                                            managedStack[pos] = *(double*)&ptr->Value1;
                                            ptr->Value1 = pos;
                                            break;
                                        default:
                                            throwRuntimeException(new InvalidProgramException("to box a " + ptr->Type),
                                                true);
                                            break;
                                    }
                                }
                                ptr->Type = ValueType.Object;
                            }
                            break;
                        case Code.Isinst://0.3074192%
                            {
                                var ptr = evaluationStackPointer - 1;
                                var type = pc->Operand >= 0 ? externTypes[pc->Operand] : typeof(AnonymousStorey);
                                var pos = (int)(ptr - evaluationStackBase);
                                var obj = managedStack[ptr->Value1];
                                ptr->Type = ValueType.Object;
                                ptr->Value1 = pos;
                                if (obj == null)
                                {
                                    managedStack[pos] = null;
                                }
                                else
                                {
                                    bool canAssign = type.IsAssignableFrom(obj.GetType());
                                    managedStack[pos] = canAssign
                                        ? obj : null;
                                    if (pc->Operand < 0 && canAssign)
                                    {
                                        if ((obj is AnonymousStorey) && (obj as AnonymousStorey).typeId != -(pc->Operand + 1))
                                        {
                                            var fromInfo = anonymousStoreyInfos[(obj as AnonymousStorey).typeId];
                                            var targetInfo = anonymousStoreyInfos[-(pc->Operand + 1)];

                                            if (fromInfo.Slots != null && targetInfo.Slots != null && fromInfo.Slots.Length == targetInfo.Slots.Length)
                                            {
                                                for (int i = 0; i < fromInfo.Slots.Length; ++i)
                                                {
                                                    if (fromInfo.Slots[i] != targetInfo.Slots[i])
                                                    {
                                                        canAssign = false;
                                                        break;
                                                    }
                                                }
                                            }
                                            else
                                            {
                                                canAssign = false;
                                            }

                                            if (!canAssign)
                                            {
                                                managedStack[pos] = null;
                                            }
                                        }
                                    }
                                }
                            }
                            break;
                        case Code.Bge: //Bge_S:0.2954996% Bge:0.005870852%
                            {
                                var b = evaluationStackPointer - 1;
                                var a = evaluationStackPointer - 1 - 1;
                                evaluationStackPointer = a;
                                bool transfer = false;
                                switch (evaluationStackPointer->Type)
                                {
                                    case ValueType.Integer:
                                        transfer = a->Value1 >= b->Value1;
                                        break;
                                    case ValueType.Long:
                                        transfer = *(long*)&a->Value1 >= *(long*)&b->Value1;
                                        break;
                                    case ValueType.Float:
                                        transfer = *(float*)&a->Value1 >= *(float*)&b->Value1;
                                        break;
                                    case ValueType.Double:
                                        transfer = *(double*)&a->Value1 >= *(double*)&b->Value1;
                                        break;
                                }

                                if (transfer)
                                {
                                    pc += pc->Operand;
                                    continue;
                                }

                            }
                            break;
                        case Code.Conv_I8: //0.2652557%
                            {
                                var obj = evaluationStackPointer - 1;
                                long val;
                                switch (obj->Type)
                                {
                                    case ValueType.Integer:
                                        val = obj->Value1;
                                        break;
                                    case ValueType.Long:
                                        pc++;
                                        continue;
                                    case ValueType.Float:
                                        val = (long)*(float*)&obj->Value1;
                                        break;
                                    case ValueType.Double:
                                        val = (long)*(double*)&obj->Value1;
                                        break;
                                    default:
                                        val = 0;
                                        throwRuntimeException(new NotImplementedException(), true);
                                        break;
                                }
                                obj->Type = ValueType.Long;
                                *(long*)(&obj->Value1) = val;
                            }
                            break;
                        case Code.Ble://Ble_S:0.2581396%  Ble:0.0152998%
                            {
                                var b = evaluationStackPointer - 1;
                                var a = evaluationStackPointer - 1 - 1;
                                evaluationStackPointer = a;
                                bool transfer = false;
                                switch (evaluationStackPointer->Type)
                                {
                                    case ValueType.Integer:
                                        transfer = a->Value1 <= b->Value1;
                                        break;
                                    case ValueType.Long:
                                        transfer = *(long*)&a->Value1 <= *(long*)&b->Value1;
                                        break;
                                    case ValueType.Float:
                                        transfer = *(float*)&a->Value1 <= *(float*)&b->Value1;
                                        break;
                                    case ValueType.Double:
                                        transfer = *(double*)&a->Value1 <= *(double*)&b->Value1;
                                        break;
                                    default:
                                        throwRuntimeException(new NotImplementedException("Blt for "
                                            + evaluationStackPointer->Type), true);
                                        break;
                                }

                                if (transfer)
                                {
                                    pc += pc->Operand;
                                    continue;
                                }
                            }
                            break;
                        case Code.Endfinally: //0.2513792%
                            {
                                if (leavePoint == 0)//有异常
                                {
                                    int exceptionPos = (int)(evaluationStackPointer - evaluationStackBase - 1);
                                    var exception = managedStack[(evaluationStackPointer - 1)->Value1]
                                        as Exception;
                                    managedStack[exceptionPos] = null;
                                    evaluationStackPointer--;
                                    throw exception;
                                }
                                else
                                {
                                    if (pc->Operand == -1) //最外层
                                    {
                                        pc = pcb + leavePoint;
                                        leavePoint = 0;
                                        continue;
                                    }
                                    else //不是最外层
                                    {
                                        var nextFinally = exceptionHandlers[methodIndex][pc->Operand];
                                        if (leavePoint >= nextFinally.TryStart && leavePoint < nextFinally.TryEnd)
                                        {
                                            pc = pcb + leavePoint;
                                            leavePoint = 0;
                                            continue;
                                        }
                                        else
                                        {
                                            pc = pcb + nextFinally.HandlerStart;
                                            continue;
                                        }
                                    }
                                }
                            }
                        case Code.Or: //0.2490664%
                            {
                                var rhs = evaluationStackPointer - 1;
                                var lhs = evaluationStackPointer - 1 - 1;
                                switch (lhs->Type)
                                {
                                    case ValueType.Long:
                                        *((long*)&lhs->Value1) = *((long*)&lhs->Value1) | *((long*)&rhs->Value1);
                                        break;
                                    case ValueType.Integer:
                                        lhs->Value1 = lhs->Value1 | rhs->Value1;
                                        break;
                                    default:
                                        throw new InvalidProgramException("| for " + lhs->Type);
                                }
                                evaluationStackPointer = rhs;
                            }
                            break;
                        case Code.Stsfld: //0.2488885%
                            {
                                var fieldIndex = pc->Operand;
                                if (fieldIndex >= 0)
                                {
                                    var fieldInfo = fieldInfos[fieldIndex];
                                    Type filedType = null;
                                    
                                    if (fieldInfo == null)
                                    {
                                        filedType = newFieldInfos[fieldIndex].FieldType;
                                    }
                                    else
                                    {
                                        filedType = fieldInfo.FieldType;
                                    }

                                    var value = EvaluationStackOperation.ToObject(evaluationStackBase,
                                        evaluationStackPointer - 1, managedStack, filedType, this);
                                    
                                    if (fieldInfo == null)
                                    {
                                        newFieldInfos[fieldIndex].SetValue(null, value);
                                    }
                                    else
                                    {
                                        fieldInfo.SetValue(null, value);
                                    }
                                }
                                else
                                {
                                    fieldIndex = -(fieldIndex + 1);
                                    checkCctorExecute(fieldIndex, evaluationStackPointer, managedStack,
                                        evaluationStackBase);
                                    staticFields[fieldIndex]
                                        = EvaluationStackOperation.ToObject(evaluationStackBase,
                                        evaluationStackPointer - 1, managedStack, staticFieldTypes[fieldIndex], this);
                                    //_Info("store static field " + fieldIndex + " : " + staticFields[fieldIndex]);
                                }
                                managedStack[evaluationStackPointer - 1 - evaluationStackBase] = null;
                                evaluationStackPointer--;
                            }
                            break;
                        case Code.Ldflda: //0.240527%
                            {
                                var fieldInfo = pc->Operand >= 0 ? fieldInfos[pc->Operand] : null;

                                Type declaringType = null;
                                Type fieldType = null;
                                var ptr = evaluationStackPointer - 1;

                                if(pc->Operand >= 0)
                                {
                                    if(fieldInfo == null)
                                    {
                                        fieldType = newFieldInfos[pc->Operand].FieldType;
                                        declaringType = newFieldInfos[pc->Operand].DeclaringType;
                                    }
                                    else
                                    {
                                        fieldType = fieldInfo.FieldType;
                                        declaringType = fieldInfo.DeclaringType;
                                    }
                                }
                                
                                //栈顶也是字段引用，而且该字段是值类型，需要update上层对象
                                if ((ptr->Type == ValueType.FieldReference
                                    || ptr->Type == ValueType.ChainFieldReference
                                    || ptr->Type == ValueType.ArrayReference) && pc->Operand >= 0
                                    && fieldType.IsValueType)
                                {
                                    // if (pc->Operand < 0)
                                    // {
                                    //     throwRuntimeException(new NotSupportedException(
                                    //         "chain ref for compiler generated object!"), true);
                                    // }
                                    //_Info("mult ref");
                                    //ptr->Value1：指向实际对象
                                    //ptr->Value2：-1表示第一个是FieldReference， -2表示是ArrayReference
                                    //managedStack[offset]：int[]，表示

                                    //多层引用managedStack[ptr - evaluationStackBase] == fieldIdList
                                    //多层引用,append
                                    if (ptr->Type == ValueType.ChainFieldReference)
                                    {
                                        var offset = ptr - evaluationStackBase;
                                        var fieldAddr = managedStack[offset] as FieldAddr;
                                        var fieldIdList = fieldAddr.FieldIdList;
                                        var newFieldIdList = new int[fieldIdList.Length + 1];
                                        Array.Copy(fieldIdList, newFieldIdList, fieldIdList.Length);
                                        newFieldIdList[fieldIdList.Length] = pc->Operand;
                                        managedStack[offset] = new FieldAddr()
                                        {
                                            Object = fieldAddr.Object,
                                            FieldIdList = newFieldIdList
                                        };
                                    }
                                    else
                                    {
                                        if (ptr->Value2 < 0)
                                        {
                                            throwRuntimeException(new NotSupportedException(
                                                "ref of compiler generated object field ref!"), true);
                                        }
                                        var offset = ptr - evaluationStackBase;
                                        var fieldAddr = new FieldAddr()
                                        {
                                            Object = managedStack[ptr->Value1],
                                            FieldIdList = new int[] { ptr->Value2, pc->Operand }
                                        };
                                        managedStack[offset] = fieldAddr;
                                        ptr->Value2 = ptr->Type == ValueType.FieldReference ? -1 : -2;
                                    }
                                    ptr->Type = ValueType.ChainFieldReference;
                                }
                                else
                                {
                                    object obj = EvaluationStackOperation.ToObject(evaluationStackBase, ptr,
                                        managedStack, pc->Operand < 0 ? typeof(AnonymousStorey)
                                        : declaringType, this, false);

                                    ptr->Type = ValueType.FieldReference;
                                    ptr->Value1 = (int)(ptr - evaluationStackBase);
                                    managedStack[ptr->Value1] = obj;
                                    ptr->Value2 = pc->Operand;
                                    //_Info("sigle ref type = " + obj.GetType() + ",hc=" + obj.GetHashCode()
                                    //    + ",v1=" + ptr->Value1 + ",v2=" + ptr->Value2);
                                }
                                //_Info("Ldflda fieldInfo:" + fieldInfo + ", dt:" + fieldInfo.DeclaringType 
                                //    + ", ptr->Value1:" + ptr->Value1 + ", obj info:" + (obj == null ? "null"
                                //    : obj.GetHashCode().ToString() + "/" + managedStack[ptr->Value1]
                                //        .GetHashCode().ToString())
                                //     + ", ref eq? " + ReferenceEquals(obj, managedStack[ptr->Value1]));
                            }
                            break;
                        case Code.Mul://0.2389259%
                            {
                                Value* b = evaluationStackPointer - 1;
                                Value* a = evaluationStackPointer - 1 - 1;
                                evaluationStackPointer = a;
                                switch (a->Type)
                                {
                                    case ValueType.Long:
                                        *((long*)&evaluationStackPointer->Value1)
                                            = (*((long*)&a->Value1)) * (*((long*)&b->Value1));
                                        break;
                                    case ValueType.Integer:
                                        evaluationStackPointer->Value1 = a->Value1 * b->Value1;
                                        break;
                                    case ValueType.Float:
                                        *((float*)&evaluationStackPointer->Value1)
                                            = (*((float*)&a->Value1)) * (*((float*)&b->Value1));
                                        break;
                                    case ValueType.Double:
                                        *((double*)&evaluationStackPointer->Value1)
                                            = (*((double*)&a->Value1)) * (*((double*)&b->Value1));
                                        break;
                                }
                                evaluationStackPointer++;
                            }
                            break;
                        //case Code.Conv_I: //0.2136634% Convert to native int, pushing native int on stack.
                        case Code.Ldarga: // Ldarga_S:0.2035229%
                            {
                                *(Value**)&evaluationStackPointer->Value1 = argumentBase + pc->Operand;
                                evaluationStackPointer->Type = ValueType.StackReference;
                                evaluationStackPointer++;
                            }
                            break;
                        case Code.Conv_U: //0.1764814% Convert to unsigned native int, pushing native int on stack.
                            {
                                var ptr = evaluationStackPointer - 1;
                                void* val;
                                switch (ptr->Type)
                                {
                                    case ValueType.Long:
                                        val = (void *)*(ulong*)&ptr->Value1;
                                        break;
                                    case ValueType.Integer:
                                        val = (void*)(uint)ptr->Value1;
                                        break;
                                    default:
                                        val = null;
                                        throwRuntimeException(new NotImplementedException("Conv_U for" + ptr->Type), true);
                                        break;
                                }
                                ptr->Type = ValueType.Long;
                                *(void **)&ptr->Value1 = val;
                            }
                            break;
                        case Code.Starg://Starg_S:0.1551328 %
                            {
                                evaluationStackPointer--;
                                store(evaluationStackBase, argumentBase + pc->Operand, evaluationStackPointer,
                                    managedStack);
                                managedStack[evaluationStackPointer - evaluationStackBase] = null; ;
                            }
                            break;
                        case Code.Ceq: //0.1549549%
                            {
                                var rhs = evaluationStackPointer - 1;
                                var lhs = rhs - 1;
                                bool eq = false;

                                if (lhs->Type == rhs->Type)
                                {
                                    if (lhs->Type == ValueType.Object || lhs->Type == ValueType.ValueType)
                                    {
                                        var lpos = (int)(lhs - evaluationStackBase);
                                        var rpos = (int)(rhs - evaluationStackBase);
                                        eq = ReferenceEquals(managedStack[lhs->Value1], managedStack[rhs->Value1]);
                                        managedStack[lpos] = null;
                                        managedStack[rpos] = null;
                                    }
                                    else
                                    {
                                        eq = lhs->Value1 == rhs->Value1;
                                        if (lhs->Type != ValueType.Integer && lhs->Type != ValueType.Float)
                                        {
                                            eq = eq && (lhs->Value2 == rhs->Value2);
                                        }
                                    }
                                }
                                else
                                {
                                    throwRuntimeException(new InvalidProgramException("Ceq for diff type"), true);
                                }
                                lhs->Type = ValueType.Integer;
                                lhs->Value1 = eq ? 1 : 0;
                                evaluationStackPointer = rhs;
                            }
                            break;
                        case Code.Shl: //0.1362749%
                            {
                                var ptr = evaluationStackPointer - 1 - 1;
                                int bits = (evaluationStackPointer - 1)->Value1;
                                switch(ptr->Type)
                                {
                                    case ValueType.Integer:
                                        ptr->Value1 = ptr->Value1 << bits;
                                        break;
                                    case ValueType.Long:
                                        *((long*)&ptr->Value1) = (*((long*)&ptr->Value1)) << bits;
                                        break;
                                    default:
                                        throw new InvalidProgramException("<< for " + ptr->Type);
                                }
                                evaluationStackPointer--;
                            }
                            break;
                        case Code.Conv_U1: //0.1239995%
                            {
                                var ptr = evaluationStackPointer - 1;
                                int val;
                                switch (ptr->Type)
                                {
                                    case ValueType.Long:
                                    case ValueType.Integer:
                                        val = (byte)ptr->Value1;
                                        break;
                                    case ValueType.Float:
                                        val = (byte)*(float*)&ptr->Value1;
                                        break;
                                    case ValueType.Double:
                                        val = (byte)*(double*)&ptr->Value1;
                                        break;
                                    default:
                                        throw new NotImplementedException();
                                }
                                ptr->Type = ValueType.Integer;
                                ptr->Value1 = val;
                            }
                            break;
                        case Code.Ldelema: //0.1124357%
                            {
                                var ptr = evaluationStackPointer - 1 - 1;
                                ptr->Type = ValueType.ArrayReference;
                                ptr->Value2 = (evaluationStackPointer - 1)->Value1;
                                evaluationStackPointer--;
                            }
                            break;
                        case Code.Stind_Ref://0.09482315%
                        case Code.Stind_I1://0.06333404%
                        case Code.Stind_I2://0.02793102%
                        case Code.Stind_I4://0.1106567%
                        case Code.Stind_I8://0.01352075%
                        case Code.Stind_R4: //0.001956951%
                        case Code.Stind_R8: //0.002668569%
                        case Code.Stind_I://0.01031847%
                        case Code.Stobj: // 0.02846474%
                            {
                                var ptr = evaluationStackPointer - 1 - 1;
                                var src = evaluationStackPointer - 1;
                                switch (ptr->Type)
                                {
                                    case ValueType.FieldReference:
                                    case ValueType.ChainFieldReference:
                                        {
                                            Type fieldType = null;
                                            if (ptr->Type == ValueType.ChainFieldReference)
                                            {
                                                var fieldAddr = managedStack[ptr - evaluationStackBase] as FieldAddr;
                                                var fieldIdList = fieldAddr.FieldIdList;

                                                if(fieldInfos[fieldIdList[fieldIdList.Length - 1]] == null)
                                                {
                                                    fieldType
                                                        = newFieldInfos[fieldIdList[fieldIdList.Length - 1]].FieldType;
                                                }
                                                else
                                                {
                                                    fieldType
                                                        = fieldInfos[fieldIdList[fieldIdList.Length - 1]].FieldType;
                                                }

                                            }
                                            else
                                            {
                                                if(fieldInfos[ptr->Value2] == null)
                                                {
                                                    fieldType = newFieldInfos[ptr->Value2].FieldType;
                                                }
                                                else
                                                {
                                                    fieldType = fieldInfos[ptr->Value2].FieldType;
                                                }
                                            }
                                            EvaluationStackOperation.UpdateReference(evaluationStackBase, ptr,
                                                managedStack, EvaluationStackOperation.ToObject(evaluationStackBase,
                                                src, managedStack, fieldType, this), this, fieldType);
                                            //managedStack[ptr->Value1] = null;
                                            if (src->Type >= ValueType.Object)
                                            {
                                                managedStack[src - evaluationStackBase] = null;
                                            }
                                            evaluationStackPointer = ptr;
                                        }
                                        break;
                                    case ValueType.ArrayReference:
                                        {
                                            var obj = managedStack[ptr->Value1];
                                            managedStack[ptr - evaluationStackBase] = null;
                                            int idx = ptr->Value2;
                                            arraySet(obj, idx, src, managedStack, evaluationStackBase);
                                            if (src->Type >= ValueType.Object)
                                            {
                                                managedStack[src - evaluationStackBase] = null;
                                            }
                                            evaluationStackPointer = ptr;
                                        }
                                        break;
                                    case ValueType.StaticFieldReference:
                                        {
                                            var fieldIndex = ptr->Value1;
                                            if (fieldIndex >= 0)
                                            {
                                                var fieldInfo = fieldInfos[fieldIndex];
                                                Type fieldType = null;

                                                if(fieldInfo == null)
                                                {
                                                    fieldType = newFieldInfos[fieldIndex].FieldType;
                                                }
                                                else
                                                {
                                                    fieldType = fieldInfo.FieldType;
                                                }
                                               
                                                var val = EvaluationStackOperation.ToObject(evaluationStackBase, src,
                                                        managedStack, fieldType, this);
                                               
                                                if(fieldInfo == null)
                                                {
                                                    newFieldInfos[fieldIndex].SetValue(null, val);
                                                }
                                                else
                                                {
                                                    fieldInfo.SetValue(null, val);
                                                }
                                            }
                                            else
                                            {
                                                fieldIndex = -(fieldIndex + 1);
                                                staticFields[fieldIndex]
                                                    = EvaluationStackOperation.ToObject(evaluationStackBase, src,
                                                    managedStack, staticFieldTypes[fieldIndex], this);
                                            }
                                            if (src->Type >= ValueType.Object)
                                            {
                                                managedStack[src - evaluationStackBase] = null;
                                            }
                                            evaluationStackPointer = ptr;
                                        }
                                        break;
                                    case ValueType.StackReference:
                                        {
                                            Value* des = *(Value**)&ptr->Value1;
                                            *des = *src;
                                            if (src->Type == ValueType.Object)
                                            {
                                                int offset = (int)(des - evaluationStackBase);
                                                des->Value1 = offset;
                                                managedStack[offset] = managedStack[src->Value1];
                                                managedStack[src - evaluationStackBase] = null;
                                            }
                                            else if (src->Type == ValueType.ValueType)
                                            {
                                                int offset = (int)(des - evaluationStackBase);
                                                des->Value1 = offset;
                                                managedStack[offset] = objectClone.Clone(managedStack[src->Value1]);
                                                managedStack[src - evaluationStackBase] = null;
                                            }
                                            //Console.WriteLine("store to stack address:" + new IntPtr(des) 
                                            //    + ",val type:" + src->Type + ",val1:" + src->Value1);
                                            evaluationStackPointer = ptr;
                                        }
                                        break;
                                    default:
                                        throwRuntimeException(new InvalidProgramException(code
                                            + " expect ref, but got " + ptr->Type + " value1:" + ptr->Value1 + " value2:" + ptr->Value2), true);
                                        break;
                                }
                            }
                            break;
                        case Code.Ldind_I1: //0.006226661%
                        case Code.Ldind_U1: //0.05870852%
                        case Code.Ldind_I2: //0.008717326%
                        case Code.Ldind_U2: //0.04536567%
                        case Code.Ldind_I4:  //0.106387%
                        case Code.Ldind_U4:  //0.04981329%
                        case Code.Ldind_I8:  //0.03042169%
                        case Code.Ldind_I: //0.02081484%
                        case Code.Ldind_R4: //0.007294089%
                        case Code.Ldind_R8:  //wrapper调用应先push值，然后参数取该值的地址
                        case Code.Ldind_Ref: //0.1070986% 操作符可以作为类型依据，不用走反射
                        case Code.Ldobj: //0.02348341%
                            {
                                Value* ptr = evaluationStackPointer - 1;
                                switch (ptr->Type)
                                {
                                    case ValueType.FieldReference:
                                        {
                                            var fieldIndex = ptr->Value2;
                                            if (fieldIndex >= 0)
                                            {
                                                Type fieldType = null;
                                                if(fieldInfos[fieldIndex] == null)
                                                {
                                                    fieldType = newFieldInfos[fieldIndex].FieldType;
                                                }
                                                else
                                                {
                                                    fieldType = fieldInfos[fieldIndex].FieldType;
                                                }

                                                //var fieldInfo = fieldInfos[ptr->Value2];
                                                var val = EvaluationStackOperation.ToObject(evaluationStackBase, ptr,
                                                    managedStack, fieldType, this, false);
                                                //_Info("val = " + val);
                                                EvaluationStackOperation.PushObject(evaluationStackBase, ptr,
                                                    managedStack, val, fieldType);
                                            }
                                            else
                                            {
                                                fieldIndex = -(fieldIndex + 1);
                                                AnonymousStorey anonyObj
                                                    = managedStack[ptr->Value1] as AnonymousStorey;
                                                anonyObj.Ldfld(fieldIndex, evaluationStackBase, ptr, managedStack);
                                            }
                                        }
                                        break;
                                    case ValueType.ChainFieldReference:
                                        {
                                            Type fieldType = null;

                                            var fieldAddr = managedStack[ptr - evaluationStackBase] as FieldAddr;
                                            var fieldIdList = fieldAddr.FieldIdList;
                                            if(fieldInfos[fieldIdList[fieldIdList.Length - 1]] == null)
                                            {
                                                fieldType = newFieldInfos[fieldIdList[fieldIdList.Length - 1]].FieldType;
                                            }
                                            else
                                            {
                                                fieldType = fieldInfos[fieldIdList[fieldIdList.Length - 1]].FieldType;
                                            }

                                            //var fieldInfo = fieldInfos[ptr->Value2];
                                            var val = EvaluationStackOperation.ToObject(evaluationStackBase, ptr,
                                                managedStack, fieldType, this, false);
                                            EvaluationStackOperation.PushObject(evaluationStackBase, ptr,
                                                managedStack, val, fieldType);
                                        }
                                        break;
                                    case ValueType.ArrayReference:
                                        {
                                            var obj = managedStack[ptr->Value1];
                                            managedStack[ptr - evaluationStackBase] = null;
                                            int idx = ptr->Value2;
                                            arrayGet(obj, idx, ptr, managedStack, evaluationStackBase);
                                        }
                                        break;
                                    case ValueType.StaticFieldReference:
                                        {
                                            var fieldIndex = ptr->Value1;
                                            if (fieldIndex >= 0)
                                            {
                                                var fieldInfo = fieldInfos[ptr->Value1];
                                                object value = null;
                                                Type fieldType = null;
                                                if(fieldInfo == null)
                                                {
                                                    newFieldInfos[fieldIndex].CheckInit(this, null);
                                                    
                                                    fieldType = newFieldInfos[fieldIndex].FieldType;
                                                    value = newFieldInfos[fieldIndex].GetValue(null);
                                                }
                                                else
                                                {
                                                    fieldType = fieldInfo.FieldType;
                                                    value = fieldInfo.GetValue(null);
                                                }
                                                
                                                EvaluationStackOperation.PushObject(evaluationStackBase, ptr,
                                                    managedStack, value, fieldType);
                                            }
                                            else
                                            {
                                                fieldIndex = -(fieldIndex + 1);
                                                EvaluationStackOperation.PushObject(evaluationStackBase, ptr,
                                                    managedStack, staticFields[fieldIndex],
                                                    staticFieldTypes[fieldIndex]);
                                            }
                                        }
                                        break;
                                    case ValueType.StackReference:
                                        {
                                            Value* src = *(Value**)&ptr->Value1;
                                            *ptr = *src;
                                            if (src->Type == ValueType.Object)
                                            {
                                                managedStack[ptr - evaluationStackBase] = managedStack[src->Value1];
                                                ptr->Value1 = (int)(ptr - evaluationStackBase);
                                            }
                                            else if (src->Type == ValueType.ValueType)
                                            {
                                                managedStack[ptr - evaluationStackBase]
                                                    = objectClone.Clone(managedStack[src->Value1]);
                                                ptr->Value1 = (int)(ptr - evaluationStackBase);
                                            }
                                        }
                                        break;
                                    default:
                                        throwRuntimeException(new InvalidProgramException(code
                                            + " expect ref, but got " + ptr->Type + " value1:" + ptr->Value1 + " value2:" + ptr->Value2), true);
                                        break;
                                }
                            }
                            break;
                        case Code.Bgt: //Bgt_S:0.1104788% Bgt:0.01103009%
                            {
                                var b = evaluationStackPointer - 1;
                                var a = evaluationStackPointer - 1 - 1;
                                evaluationStackPointer = a;
                                bool transfer = false;
                                switch (evaluationStackPointer->Type)
                                {
                                    case ValueType.Integer:
                                        transfer = a->Value1 > b->Value1;
                                        break;
                                    case ValueType.Long:
                                        transfer = *(long*)&a->Value1 > *(long*)&b->Value1;
                                        break;
                                    case ValueType.Float:
                                        transfer = *(float*)&a->Value1 > *(float*)&b->Value1;
                                        break;
                                    case ValueType.Double:
                                        transfer = *(double*)&a->Value1 > *(double*)&b->Value1;
                                        break;
                                    default:
                                        throw new InvalidProgramException("Bgt for " + evaluationStackPointer->Type);
                                }

                                if (transfer)
                                {
                                    pc += pc->Operand;
                                    continue;
                                }
                            }
                            break;
                        case Code.Initobj: //0.1085218%
                            {
                                var ptr = evaluationStackPointer - 1;
                                var type = externTypes[pc->Operand];
                                EvaluationStackOperation.UpdateReference(evaluationStackBase, ptr, managedStack,
                                    Activator.CreateInstance(type), this, type);
                                if (ptr->Type >= ValueType.Object)
                                {
                                    managedStack[ptr - evaluationStackBase] = null;
                                }
                                evaluationStackPointer = ptr;
                            }
                            break;
                        case Code.Shr_Un: //0.09589058%
                            {
                                var ptr = evaluationStackPointer - 1 - 1;
                                int bits = (evaluationStackPointer - 1)->Value1;
                                switch (ptr->Type)
                                {
                                    case ValueType.Integer:
                                        ptr->Value1 = (int)(((uint)ptr->Value1) >> bits);
                                        break;
                                    case ValueType.Long:
                                        *((ulong*)&ptr->Value1) = (*((ulong*)&ptr->Value1)) >> bits;
                                        break;
                                    default:
                                        throw new InvalidProgramException(">> for " + ptr->Type);
                                }
                                evaluationStackPointer--;
                            }
                            break;
                        case Code.Stelem_I1: //0.09019764%
                            {
                                var val = (evaluationStackPointer - 1)->Value1;
                                var idx = (evaluationStackPointer - 1 - 1)->Value1;
                                var ptr = evaluationStackPointer - 1 - 1 - 1;
                                var obj = managedStack[ptr->Value1];
                                managedStack[ptr - evaluationStackBase] = null;
                                evaluationStackPointer = ptr;
                                byte[] byteArr = obj as byte[];
                                if (byteArr != null)
                                {
                                    byteArr[idx] = (byte)val;
                                    break;
                                }
                                bool[] boolArr = obj as bool[];
                                if (boolArr != null)
                                {
                                    boolArr[idx] = val != 0;
                                    break;
                                }
                                sbyte[] sbyteArr = obj as sbyte[];
                                if (sbyteArr != null)
                                {
                                    sbyteArr[idx] = (sbyte)val;
                                }
                            }
                            break;
                        //为什么有Ldelem_U1而没有Stelem_U1？因为load后push到es后，会扩展到int32，同样是0xff，
                        //作为有符号或无符号扩展是不一样的，一句话，高位扩展要考虑符号位，截取低位不需要
                        case Code.Ldelem_U1: //0.08557212% 
                            {
                                var idx = (evaluationStackPointer - 1)->Value1;
                                var ptr = evaluationStackPointer - 1 - 1;
                                var obj = managedStack[ptr->Value1];
                                managedStack[ptr - evaluationStackBase] = null;
                                evaluationStackPointer--;
                                ptr->Type = ValueType.Integer;
                                byte[] byteArr = obj as byte[];
                                if (byteArr != null)
                                {
                                    ptr->Value1 = byteArr[idx];
                                    break;
                                }
                                bool[] boolArr = obj as bool[];
                                if (boolArr != null)
                                {
                                    ptr->Value1 = boolArr[idx] ? 1 : 0;
                                }
                            }
                            break;
                        //hacker: mscorlib，Unbox指令只有6条,均是这样形式的语句产生的：((SomeValueType)obj).field，
                        //所以Unbox按Unbox_Any处理，只要ldfld能处理即可
                        case Code.Unbox:
                        case Code.Unbox_Any://0.0848605%
                            {
                                var ptr = evaluationStackPointer - 1;
                                if(pc->Operand >= 0)
                                {
                                    var type = externTypes[pc->Operand];
                                    //var pos = (int)(ptr - evaluationStackBase);
                                    var obj = managedStack[ptr->Value1];
                                    if (ptr->Type == ValueType.Object)
                                    {
                                        if (type.IsValueType)
                                        {
                                            if (obj == null)
                                            {
                                                throw new NullReferenceException();
                                            }
                                            else if(type.IsPrimitive)
                                            {
                                                EvaluationStackOperation.UnboxPrimitive(ptr, obj, type);
                                            }
                                            else if(type.IsEnum)
                                            {
                                                EvaluationStackOperation.UnboxPrimitive(ptr, obj, Enum.GetUnderlyingType(type));
                                            }
                                            else
                                            {
                                                ptr->Type = ValueType.ValueType;
                                            }
                                        }
                                        //泛型函数是有可能Unbox_Any一个非值类型的
                                        else if (obj != null && !type.IsAssignableFrom(obj.GetType())) 
                                        {
                                            throw new InvalidCastException();
                                        }
                                    }
                                }
                            }
                            break;
                        case Code.Div: //0.0693828%
                            {
                                Value* b = evaluationStackPointer - 1;
                                Value* a = evaluationStackPointer - 1 - 1;
                                evaluationStackPointer = a;
                                switch (a->Type)
                                {
                                    case ValueType.Long:
                                        *((long*)&evaluationStackPointer->Value1)
                                            = (*((long*)&a->Value1)) / (*((long*)&b->Value1));
                                        break;
                                    case ValueType.Integer:
                                        evaluationStackPointer->Value1 = a->Value1 / b->Value1;
                                        break;
                                    case ValueType.Float:
                                        *((float*)&evaluationStackPointer->Value1)
                                            = (*((float*)&a->Value1)) / (*((float*)&b->Value1));
                                        break;
                                    case ValueType.Double:
                                        *((double*)&evaluationStackPointer->Value1)
                                            = (*((double*)&a->Value1)) / (*((double*)&b->Value1));
                                        break;
                                }
                                evaluationStackPointer++;
                            }
                            break;
                        case Code.Cgt_Un: //0.06724794%
                            {
                                Value* rhs = evaluationStackPointer - 1;
                                Value* lhs = rhs - 1;

                                bool res = false;
                                switch (lhs->Type)
                                {
                                    case ValueType.Integer:
                                        res = (uint)lhs->Value1 > (uint)rhs->Value1;
                                        break;
                                    case ValueType.Long:
                                        res = *(ulong*)&lhs->Value1 > *(ulong*)&rhs->Value1;
                                        break;
                                    case ValueType.Float:
                                        res = !(*(float*)&lhs->Value1 <= *(float*)&rhs->Value1);
                                        break;
                                    case ValueType.Double:
                                        res = !(*(double*)&lhs->Value1 <= *(double*)&rhs->Value1);
                                        break;
                                    case ValueType.Object:
                                    case ValueType.ValueType:
                                        res = managedStack[lhs->Value1] != null && managedStack[rhs->Value1] == null;
                                        break;
                                }
                                lhs->Type = ValueType.Integer;
                                lhs->Value1 = res ? 1 : 0;
                                evaluationStackPointer = rhs;
                            }
                            break;
                        case Code.Ldelem_I4: //0.05853061%
                            {
                                var idx = (evaluationStackPointer - 1)->Value1;
                                var ptr = evaluationStackPointer - 1 - 1;
                                var arr = managedStack[ptr->Value1] as int[];
                                managedStack[ptr - evaluationStackBase] = null;
                                evaluationStackPointer--;
                                ptr->Type = ValueType.Integer;
                                ptr->Value1 = arr[idx];
                            }
                            break;
                        case Code.Ldelem_Any: //0.05657366% 
                            {
                                var arrPtr = evaluationStackPointer - 1 - 1;
                                int idx = (evaluationStackPointer - 1)->Value1;
                                var arr = managedStack[arrPtr->Value1] as Array;
                                EvaluationStackOperation.PushObject(evaluationStackBase, arrPtr, managedStack,
                                        arr.GetValue(idx), arr.GetType().GetElementType());
                                evaluationStackPointer = evaluationStackPointer - 1;
                            }
                            break;
                        case Code.Ldc_R8: //0.05088072%
                            {
                                *(double*)&evaluationStackPointer->Value1 = *(double*)(pc + 1); 
                                evaluationStackPointer->Type = ValueType.Double;
                                evaluationStackPointer++;
                                pc++;
                            }
                            break;
                        case Code.Stelem_I4: //0.05052491%
                            {
                                var val = (evaluationStackPointer - 1)->Value1;
                                var idx = (evaluationStackPointer - 1 - 1)->Value1;
                                var ptr = evaluationStackPointer - 1 - 1 - 1;
                                var obj = managedStack[ptr->Value1];
                                managedStack[ptr - evaluationStackBase] = null;
                                evaluationStackPointer = ptr;
                                int[] intArr = obj as int[];
                                if (intArr != null)
                                {
                                    intArr[idx] = val;
                                    break;
                                }
                                uint[] uintArr = obj as uint[];
                                if (uintArr != null)
                                {
                                    uintArr[idx] = (uint)val;
                                }
                            }
                            break;
                        case Code.Conv_U8: //0.04839005%
                            {
                                var obj = evaluationStackPointer - 1;
                                ulong val;
                                switch (obj->Type)
                                {
                                    case ValueType.Integer:
                                        val = *(uint*)&obj->Value1;//Conv_U8的操作数肯定是uint
                                        break;
                                    case ValueType.Long:
                                        pc++;
                                        continue;
                                    case ValueType.Float:
                                        val = (ulong)*(float*)&obj->Value1;
                                        break;
                                    case ValueType.Double:
                                        val = (ulong)*(double*)&obj->Value1;
                                        break;
                                    default:
                                        val = 0;
                                        throwRuntimeException(new NotImplementedException(), true);
                                        break;
                                }
                                obj->Type = ValueType.Long;
                                *(ulong*)(&obj->Value1) = val;
                            }
                            break;
                        case Code.Rem: //0.04714472%
                            {
                                Value* rhs = evaluationStackPointer - 1;
                                Value* lhs = rhs - 1;

                                switch (lhs->Type)
                                {
                                    case ValueType.Integer:
                                        lhs->Value1 = lhs->Value1 % rhs->Value1;
                                        break;
                                    case ValueType.Long:
                                        *(long*)&lhs->Value1 = *(long*)&lhs->Value1 % *(long*)&rhs->Value1;
                                        break;
                                    case ValueType.Float:
                                        *(float*)&lhs->Value1 = *(float*)&lhs->Value1 % *(float*)&rhs->Value1;
                                        break;
                                    case ValueType.Double:
                                        *(double*)&lhs->Value1 = *(double*)&lhs->Value1 % *(double*)&rhs->Value1;
                                        break;
                                }

                                evaluationStackPointer = rhs;
                            }
                            break;
                        case Code.Constrained://0.04714472% 
                            {
                                var lastInstruction = pc - 1;
                                var type = externTypes[pc->Operand];
                                var ptr = evaluationStackPointer - 1 - lastInstruction->Operand;
                                var obj = EvaluationStackOperation.ToObject(evaluationStackBase, ptr, managedStack, type, this);
                                var pos = (int)(ptr - evaluationStackBase);
                                managedStack[pos] = obj;
                                ptr->Value1 = pos;
                                ptr->Type = ValueType.Object;
                            }
                            break;
                        case Code.Switch://0.04518777%
                            {
                                int val = (evaluationStackPointer - 1)->Value1;
                                if (val >= 0 && val < pc->Operand)
                                {
                                    int* jmpTable = (int*)(pc + 1);
                                    //Console.WriteLine("val:" + val + ", jmp to:" + jmpTable[val]);
                                    pc += jmpTable[val];
                                }
                                else
                                {
                                    pc += ((pc->Operand + 1) >> 1) + 1;
                                }
                                continue;
                            }
                        case Code.Ldc_I8: //0.04429825%
                            {
                                *(long*)&evaluationStackPointer->Value1 = *(long*)(pc + 1); 
                                evaluationStackPointer->Type = ValueType.Long;
                                evaluationStackPointer++;
                                pc++;
                            }
                            break;
                        //case Code.Sizeof: //0.04412034% 用于指针，不支持
                        case Code.Xor: //0.03842739%
                            {
                                var rhs = evaluationStackPointer - 1;
                                var lhs = rhs - 1;
                                switch (lhs->Type)
                                {
                                    case ValueType.Long:
                                        *((long*)&lhs->Value1) = *((long*)&lhs->Value1) ^ *((long*)&rhs->Value1);
                                        break;
                                    case ValueType.Integer:
                                        lhs->Value1 = lhs->Value1 ^ rhs->Value1;
                                        break;
                                }
                                evaluationStackPointer = rhs;
                            }
                            break;
                        case Code.Ldftn: //0.03682625%
                            {
                                evaluationStackPointer->Type = ValueType.Object;
                                evaluationStackPointer->Value1 = (int)(evaluationStackPointer - evaluationStackBase);
                                managedStack[evaluationStackPointer->Value1] = externMethods[pc->Operand];
                                evaluationStackPointer++;
                            }
                            break;
                        case Code.Newanon:
                            {

                                var anonymousStoreyInfo = anonymousStoreyInfos[pc->Operand];
                                //_Info(anonymousStoreyInfo.Slots == null ? "raw" : "object with interfaces");
                                var pn = anonymousStoreyInfo.CtorParamNum;
                                //_Info("param count:" + pn + ", ctor id:" + anonymousStoreyInfo.CtorId);
                                AnonymousStorey anonymousStorey = (anonymousStoreyInfo.Slots == null)
                                    ? new AnonymousStorey(anonymousStoreyInfo.FieldNum, anonymousStoreyInfo.FieldTypes, pc->Operand, anonymousStoreyInfo.VTable, this)
                                    : wrappersManager.CreateBridge(anonymousStoreyInfo.FieldNum, anonymousStoreyInfo.FieldTypes, pc->Operand, anonymousStoreyInfo.VTable,
                                    anonymousStoreyInfo.Slots, this);

                                var pos = evaluationStackPointer;
                                for (int p = 0; p < pn; p++)
                                {
                                    //var src = pos - 1;
                                    //_Info("src t:" + src->Type + ",v:" + src->Value1);
                                    copy(evaluationStackBase, pos, pos - 1, managedStack);
                                    if (pos->Type >= ValueType.Object && pos->Type != ValueType.ValueType)
                                    {
                                        var src = pos - 1;
                                        pos->Value1 = (int)(pos - evaluationStackBase);
                                        managedStack[pos->Value1] = managedStack[src->Value1];
                                    }
                                    //_Info("des t:" + pos->Type + ",v:" + pos->Value1);
                                    pos = pos - 1;
                                }
                                pos->Type = ValueType.Object;
                                pos->Value1 = (int)(pos - evaluationStackBase);
                                //for (int p = 0; p < pn + 1; p++)
                                //{
                                //    var dsp = pos + p;
                                    //_Info("p " + p + ":" + dsp->Type + ",v:" + dsp->Value1);
                                //}
                                managedStack[pos->Value1] = anonymousStorey;
                                Execute(unmanagedCodes[anonymousStoreyInfo.CtorId], pos, managedStack,
                                    evaluationStackBase, pn + 1, anonymousStoreyInfo.CtorId);
                                pos->Type = ValueType.Object;
                                pos->Value1 = (int)(pos - evaluationStackBase);
                                managedStack[pos->Value1] = anonymousStorey;
                                evaluationStackPointer = pos + 1;
                            }
                            break;
                        case Code.Stelem_Any: //0.03166702% 
                            {
                                var arrPtr = evaluationStackPointer - 1 - 1 - 1;
                                int idx = (evaluationStackPointer - 1 - 1)->Value1;
                                var valPtr = evaluationStackPointer - 1;
                                var arr = managedStack[arrPtr->Value1] as Array;
                                var val = EvaluationStackOperation.ToObject(evaluationStackBase, valPtr,
                                        managedStack, arr.GetType().GetElementType(), this, false);
                                arr.SetValue(val, idx);
                                managedStack[arrPtr - evaluationStackBase] = null; //清理，如果有的话
                                managedStack[valPtr - evaluationStackBase] = null;
                                evaluationStackPointer = arrPtr;
                            }
                            break;
                        case Code.Conv_U2: //0.02917635%
                            {
                                var obj = evaluationStackPointer - 1;
                                ushort val = 0;
                                switch (obj->Type)
                                {
                                    case ValueType.Long:
                                    case ValueType.Integer:
                                        val = (ushort)obj->Value1;
                                        break;
                                    case ValueType.Float:
                                        val = (ushort)*(float*)&obj->Value1;
                                        break;
                                    case ValueType.Double:
                                        val = (ushort)*(double*)&obj->Value1;
                                        break;
                                }
                                obj->Type = ValueType.Integer;
                                obj->Value1 = val;
                            }
                            break;
                        case Code.Ldsflda: //0.02632988%
                            {
                                if (pc->Operand < 0)
                                {
                                    var fieldIndex = -(pc->Operand + 1);
                                    checkCctorExecute(fieldIndex, evaluationStackPointer, managedStack,
                                        evaluationStackBase);
                                }
                                evaluationStackPointer->Type = ValueType.StaticFieldReference;
                                evaluationStackPointer->Value1 = pc->Operand;
                                evaluationStackPointer++;
                            }
                            break;
                        case Code.Stelem_I2: //0.02117065%
                            {
                                var val = (evaluationStackPointer - 1)->Value1;
                                var idx = (evaluationStackPointer - 1 - 1)->Value1;
                                var ptr = evaluationStackPointer - 1 - 1 - 1;
                                var obj = managedStack[ptr->Value1];
                                managedStack[ptr - evaluationStackBase] = null;
                                evaluationStackPointer = ptr;
                                short[] shortArr = obj as short[];
                                if (shortArr != null)
                                {
                                    shortArr[idx] = (short)val;
                                    break;
                                }
                                ushort[] ushortArr = obj as ushort[];
                                if (ushortArr != null)
                                {
                                    ushortArr[idx] = (ushort)val;
                                    break;
                                }
                                char[] charArr = obj as char[];
                                if (charArr != null)
                                {
                                    charArr[idx] = (char)val;
                                }
                            }
                            break;
                        case Code.Blt_Un: //0.02010322%
                            {
                                var b = evaluationStackPointer - 1;
                                var a = evaluationStackPointer - 1 - 1;
                                evaluationStackPointer = a;
                                bool transfer = false;
                                switch (evaluationStackPointer->Type)
                                {
                                    case ValueType.Integer:
                                        transfer = (uint)a->Value1 < (uint)b->Value1;
                                        break;
                                    case ValueType.Long:
                                        transfer = *(ulong*)&a->Value1 < *(ulong*)&b->Value1;
                                        break;
                                    case ValueType.Float:
                                        transfer = !(*(float*)&a->Value1 >= *(float*)&b->Value1);
                                        break;
                                    case ValueType.Double:
                                        transfer = !(*(double*)&a->Value1 >= *(double*)&b->Value1);
                                        break;
                                }

                                if (transfer)
                                {
                                    pc += pc->Operand;
                                    continue;
                                }
                            }
                            break;
                        case Code.Ble_Un: //Ble_Un_S:0.01725675% Ble_Un:0.0003558092%
                            {
                                var b = evaluationStackPointer - 1;
                                var a = evaluationStackPointer - 1 - 1;
                                evaluationStackPointer = a;
                                bool transfer = false;
                                switch (evaluationStackPointer->Type)
                                {
                                    case ValueType.Integer:
                                        transfer = (uint)a->Value1 <= (uint)b->Value1;
                                        break;
                                    case ValueType.Long:
                                        transfer = *(ulong*)&a->Value1 <= *(ulong*)&b->Value1;
                                        break;
                                    case ValueType.Float:
                                        transfer = !(*(float*)&a->Value1 > *(float*)&b->Value1);
                                        break;
                                    case ValueType.Double:
                                        transfer = !(*(double*)&a->Value1 > *(double*)&b->Value1);
                                        break;
                                }

                                if (transfer)
                                {
                                    pc += pc->Operand;
                                    continue;
                                }
                            }
                            break;
                        case Code.Ldelem_U2: //0.01690094%
                            {
                                var idx = (evaluationStackPointer - 1)->Value1;
                                var ptr = evaluationStackPointer - 1 - 1;
                                var obj = managedStack[ptr->Value1];
                                managedStack[ptr - evaluationStackBase] = null;
                                evaluationStackPointer--;
                                ptr->Type = ValueType.Integer;
                                ushort[] ushortArr = obj as ushort[];
                                if (ushortArr != null)
                                {
                                    ptr->Value1 = ushortArr[idx];
                                    break;
                                }
                                char[] charArr = obj as char[];
                                if (charArr != null)
                                {
                                    ptr->Value1 = charArr[idx];
                                }
                            }
                            break;
                        case Code.Conv_R8: //0.01654513%
                            {
                                var ptr = evaluationStackPointer - 1;
                                double val = 0;
                                switch (ptr->Type)
                                {
                                    case ValueType.Long:
                                        val = *(long*)&ptr->Value1;
                                        break;
                                    case ValueType.Float:
                                        val = *(float*)&ptr->Value1;
                                        break;
                                    case ValueType.Integer:
                                        val = ptr->Value1;
                                        break;
                                    case ValueType.Double:
                                        pc++;
                                        continue;
                                }
                                ptr->Type = ValueType.Double;
                                *(double*)&ptr->Value1 = val;
                            }
                            break;
                        case Code.Conv_I2: //0.0154777%
                            {
                                var ptr = evaluationStackPointer - 1;
                                int val = 0;
                                switch (ptr->Type)
                                {
                                    case ValueType.Long:
                                        val = (short)*(long*)&ptr->Value1;
                                        break;
                                    case ValueType.Float:
                                        val = (short)*(float*)&ptr->Value1;
                                        break;
                                    case ValueType.Double:
                                        val = (short)*(double*)&ptr->Value1;
                                        break;
                                    case ValueType.Integer:
                                        val = (short)ptr->Value1;
                                        break;
                                }
                                ptr->Type = ValueType.Integer;
                                ptr->Value1 = val;
                            }
                            break;
                        case Code.Bgt_Un: //0.01476608%
                            {
                                var b = evaluationStackPointer - 1;
                                var a = evaluationStackPointer - 1 - 1;
                                evaluationStackPointer = a;
                                bool transfer = false;
                                switch (evaluationStackPointer->Type)
                                {
                                    case ValueType.Integer:
                                        transfer = (uint)a->Value1 > (uint)b->Value1;
                                        break;
                                    case ValueType.Long:
                                        transfer = *(ulong*)&a->Value1 > *(ulong*)&b->Value1;
                                        break;
                                    case ValueType.Float:
                                        transfer = !(*(float*)&a->Value1 <= *(float*)&b->Value1);
                                        break;
                                    case ValueType.Double:
                                        transfer = !(*(double*)&a->Value1 <= *(double*)&b->Value1);
                                        break;
                                }

                                if (transfer)
                                {
                                    pc += pc->Operand;
                                    continue;
                                }
                            }
                            break;
                        case Code.Mul_Ovf_Un: //0.01458818%
                            {
                                Value* b = evaluationStackPointer - 1;
                                Value* a = evaluationStackPointer - 1 - 1;
                                evaluationStackPointer = a;
                                switch (a->Type)
                                {
                                    case ValueType.Long:
                                        *((ulong*)&evaluationStackPointer->Value1)
                                            = checked((*((ulong*)&a->Value1)) * (*((ulong*)&b->Value1)));
                                        break;
                                    case ValueType.Integer:
                                        evaluationStackPointer->Value1
                                            = (int)checked((uint)a->Value1 * (uint)b->Value1);
                                        break;
                                }
                                evaluationStackPointer++;
                            }
                            break;
                        //Localloc 0.01441027% no support
                        case Code.Bge_Un: //0.01405446%
                            {
                                var b = evaluationStackPointer - 1;
                                var a = evaluationStackPointer - 1 - 1;
                                evaluationStackPointer = a;
                                bool transfer = false;
                                switch (evaluationStackPointer->Type)
                                {
                                    case ValueType.Integer:
                                        transfer = (uint)a->Value1 >= (uint)b->Value1;
                                        break;
                                    case ValueType.Long:
                                        transfer = *(ulong*)&a->Value1 >= *(ulong*)&b->Value1;
                                        break;
                                    case ValueType.Float:
                                        transfer = !(*(float*)&a->Value1 < *(float*)&b->Value1);
                                        break;
                                    case ValueType.Double:
                                        transfer = !(*(double*)&a->Value1 < *(double*)&b->Value1);
                                        break;
                                }

                                if (transfer)
                                {
                                    pc += pc->Operand;
                                    continue;
                                }

                            }
                            break;
                        case Code.Clt: //0.01405446%
                            {
                                Value* rhs = evaluationStackPointer - 1;
                                Value* lhs = rhs - 1;
                                
                                bool res = false;
                                switch (lhs->Type)
                                {
                                    case ValueType.Integer:
                                        res = lhs->Value1 < rhs->Value1;
                                        break;
                                    case ValueType.Long:
                                        res = *(long*)&lhs->Value1 < *(long*)&rhs->Value1;
                                        break;
                                    case ValueType.Float:
                                        res = *(float*)&lhs->Value1 < *(float*)&rhs->Value1;
                                        break;
                                    case ValueType.Double:
                                        res = *(double*)&lhs->Value1 < *(double*)&rhs->Value1;
                                        break;
                                }
                                lhs->Type = ValueType.Integer;
                                lhs->Value1 = res ? 1 : 0;
                                evaluationStackPointer = rhs;
                            }
                            break;
                        case Code.Cgt: //0.01387656%
                            {
                                Value* rhs = evaluationStackPointer - 1;
                                Value* lhs = rhs - 1;

                                bool res = false;
                                switch (lhs->Type)
                                {
                                    case ValueType.Integer:
                                        res = lhs->Value1 > rhs->Value1;
                                        break;
                                    case ValueType.Long:
                                        res = *(long*)&lhs->Value1 > *(long*)&rhs->Value1;
                                        break;
                                    case ValueType.Float:
                                        res = *(float*)&lhs->Value1 > *(float*)&rhs->Value1;
                                        break;
                                    case ValueType.Double:
                                        res = *(double*)&lhs->Value1 > *(double*)&rhs->Value1;
                                        break;
                                }
                                lhs->Type = ValueType.Integer;
                                lhs->Value1 = res ? 1 : 0;
                                evaluationStackPointer = rhs;
                            }
                            break;
                        case Code.Neg: //0.009606848%
                            {
                                var ptr = evaluationStackPointer - 1;
                                switch (ptr->Type)
                                {
                                    case ValueType.Long:
                                        *((long*)&ptr->Value1) = -*((long*)&ptr->Value1);
                                        break;
                                    case ValueType.Integer:
                                        ptr->Value1 = -ptr->Value1;
                                        break;
                                    case ValueType.Float:
                                        *((float*)&ptr->Value1) = -*((float*)&ptr->Value1);
                                        break;
                                    case ValueType.Double:
                                        *((double*)&ptr->Value1) = -*((double*)&ptr->Value1);
                                        break;
                                }
                            }
                            break;
                        case Code.Not: //0.008717326%
                            {
                                var ptr = evaluationStackPointer - 1;
                                switch (ptr->Type)
                                {
                                    case ValueType.Long:
                                        *((long*)&ptr->Value1) = ~*((long*)&ptr->Value1);
                                        break;
                                    case ValueType.Integer:
                                        ptr->Value1 = ~ptr->Value1;
                                        break;
                                }
                            }
                            break;
                        case Code.Ldelem_I8: //0.008005707%
                            {
                                var idx = (evaluationStackPointer - 1)->Value1;
                                var ptr = evaluationStackPointer - 1 - 1;
                                var obj = managedStack[ptr->Value1];
                                managedStack[ptr - evaluationStackBase] = null;
                                evaluationStackPointer--;
                                ptr->Type = ValueType.Long;
                                long[] longArr = obj as long[];
                                if (longArr != null)
                                {
                                    *(long*)&ptr->Value1 = longArr[idx];
                                    break;
                                }
                                ulong[] ulongArr = obj as ulong[];
                                if (ulongArr != null)
                                {
                                    *(ulong*)&ptr->Value1 = ulongArr[idx];
                                }
                            }
                            break;
                        case Code.Ldc_R4: //0.006404566%
                            {
                                //*((long*)(&evaluationStackPointer->Value1)) = pc->Operand;
                                *(float*)&evaluationStackPointer->Value1 = *(float*)&pc->Operand; //高位不清除
                                evaluationStackPointer->Type = ValueType.Float;
                                evaluationStackPointer++;
                            }
                            break;
                        case Code.Add_Ovf: //0.006404566%
                        case Code.Add_Ovf_Un:
                            {
                                Value* b = evaluationStackPointer - 1;
                                //大于1的立即数和指针运算在il2cpp（unity 5.4）有bug，都会按1算
                                Value* a = evaluationStackPointer - 1 - 1; 
                                evaluationStackPointer = a;
                                switch (a->Type)
                                {
                                    case ValueType.Long:
                                        if (code == Code.Add_Ovf)
                                        {
                                            *((long*)&evaluationStackPointer->Value1)
                                                = checked(*((long*)&a->Value1) + *((long*)&b->Value1));
                                        }
                                        else
                                        {
                                            *((ulong*)&evaluationStackPointer->Value1)
                                                = checked(*((ulong*)&a->Value1) + *((ulong*)&b->Value1));
                                        }
                                        break;
                                    case ValueType.Integer:
                                        if (code == Code.Add_Ovf)
                                        {
                                            evaluationStackPointer->Value1 = checked(a->Value1 + b->Value1);
                                        }
                                        else
                                        {
                                            evaluationStackPointer->Value1
                                                = (int)checked((uint)a->Value1 + (uint)b->Value1);
                                        }
                                        break;
                                    case ValueType.Float:
                                        *((float*)&evaluationStackPointer->Value1)
                                            = checked(*((float*)&a->Value1) + *((float*)&b->Value1));
                                        break;
                                    case ValueType.Double:
                                        *((double*)&evaluationStackPointer->Value1)
                                            = checked(*((double*)&a->Value1) + *((double*)&b->Value1));
                                        break;
                                }
                                evaluationStackPointer++;
                            }
                            break;
                        case Code.Ldelem_U4: //0.006226661%
                            {
                                var idx = (evaluationStackPointer - 1)->Value1;
                                var ptr = evaluationStackPointer - 1 - 1;
                                var arr = managedStack[ptr->Value1] as uint[];
                                managedStack[ptr - evaluationStackBase] = null;
                                evaluationStackPointer--;
                                ptr->Type = ValueType.Integer;
                                ptr->Value1 = (int)arr[idx];
                            }
                            break;
                        case Code.Conv_U4: //0.006048756%
                            {
                                var ptr = evaluationStackPointer - 1;
                                uint val = 0;
                                switch (ptr->Type)
                                {
                                    case ValueType.Long:
                                        val = (uint)*(long*)&ptr->Value1;
                                        break;
                                    case ValueType.Float:
                                        val = (uint)*(float*)&ptr->Value1;
                                        break;
                                    case ValueType.Double:
                                        val = (uint)*(double*)&ptr->Value1;
                                        break;
                                    case ValueType.Integer:
                                        val = (uint)ptr->Value1;
                                        break;
                                }
                                ptr->Type = ValueType.Integer;
                                ptr->Value1 = (int)val;
                            }
                            break;
                        case Code.Stelem_I8: //0.004269711%
                            {
                                var val = *(long*)&(evaluationStackPointer - 1)->Value1;
                                var idx = (evaluationStackPointer - 1 - 1)->Value1;
                                var ptr = evaluationStackPointer - 1 - 1 - 1;
                                var obj = managedStack[ptr->Value1];
                                managedStack[ptr - evaluationStackBase] = null;
                                evaluationStackPointer = ptr;
                                long[] longArr = obj as long[];
                                if (longArr != null)
                                {
                                    longArr[idx] = val;
                                    break;
                                }
                                ulong[] ulongArr = obj as ulong[];
                                if (ulongArr != null)
                                {
                                    ulongArr[idx] = (ulong)val;
                                }
                            }
                            break;
                        case Code.Ldelem_I2: //0.004269711%
                            {
                                var idx = (evaluationStackPointer - 1)->Value1;
                                var ptr = evaluationStackPointer - 1 - 1;
                                var obj = managedStack[ptr->Value1];
                                managedStack[ptr - evaluationStackBase] = null;
                                evaluationStackPointer--;
                                ptr->Type = ValueType.Integer;
                                short[] shortArr = obj as short[];
                                if (shortArr != null)
                                {
                                    ptr->Value1 = shortArr[idx];
                                    break;
                                }
                                char[] charArr = obj as char[];
                                if (charArr != null)
                                {
                                    ptr->Value1 = charArr[idx];
                                }
                            }
                            break;
                        case Code.Conv_I1: //0.003913901%
                            {
                                var ptr = evaluationStackPointer - 1;
                                int val = 0;
                                switch (ptr->Type)
                                {
                                    case ValueType.Long:
                                    case ValueType.Integer:
                                        val = (sbyte)ptr->Value1;
                                        break;
                                    case ValueType.Float:
                                        val = (sbyte)*(float*)&ptr->Value1;
                                        break;
                                    case ValueType.Double:
                                        val = (sbyte)*(double*)&ptr->Value1;
                                        break;
                                }
                                ptr->Type = ValueType.Integer;
                                ptr->Value1 = val;
                            }
                            break;
                        case Code.Conv_R4: //0.003380188%
                            {
                                var ptr = evaluationStackPointer - 1;
                                float val = 0;
                                switch (ptr->Type)
                                {
                                    case ValueType.Long:
                                        val = *(long*)&ptr->Value1;
                                        break;
                                    case ValueType.Float:
                                        pc++;
                                        continue;
                                    case ValueType.Integer:
                                        val = ptr->Value1;
                                        break;
                                    case ValueType.Double:
                                        val = (float)*(double*)&ptr->Value1;
                                        break;
                                }
                                ptr->Type = ValueType.Float;
                                *(float*)&ptr->Value1 = val;
                            }
                            break;
                        case Code.Rem_Un: //0.003202283%
                            {
                                Value* rhs = evaluationStackPointer - 1;
                                Value* lhs = rhs - 1;

                                switch (lhs->Type)
                                {
                                    case ValueType.Integer:
                                        lhs->Value1 = (int)(((uint)lhs->Value1) % ((uint)rhs->Value1));
                                        break;
                                    case ValueType.Long:
                                        *(ulong*)&lhs->Value1 = *(ulong*)&lhs->Value1 % *(ulong*)&rhs->Value1;
                                        break;
                                }

                                evaluationStackPointer = rhs;
                            }
                            break;
                        case Code.Ldvirtftn: //0.003202283%
                            {
                                var ptr = evaluationStackPointer - 1;
                                var obj = managedStack[ptr->Value1];
                                var method = externMethods[pc->Operand];
                                if (obj.GetType() == method.DeclaringType)
                                {
                                    ptr->Type = ValueType.Object;
                                    ptr->Value1 = (int)(ptr - evaluationStackBase);
                                    managedStack[ptr->Value1] = externMethods[pc->Operand];
                                }
                                else
                                {
                                    //子类，.net实现Delegate.CreateDelegate会找到具体的override方法，
                                    //mono（至少unity5.2配套的mono）创建的delegate会指向父类方法
                                    var type = obj.GetType();
                                    var baseMethod = (method as MethodInfo).GetBaseDefinition();
                                    Dictionary<MethodInfo, MethodInfo> overrideMap;
                                    MethodInfo foundMethod = null;
                                    if (!overrideCache.TryGetValue(type, out overrideMap))
                                    {
                                        overrideMap = new Dictionary<MethodInfo, MethodInfo>();
                                        overrideCache[type] = overrideMap;
                                    }
                                    if (!overrideMap.TryGetValue(baseMethod, out foundMethod))
                                    {
                                        while (type != null)
                                        {
                                            var members = type.GetMember(baseMethod.Name, MemberTypes.Method,
                                                BindingFlags.Instance | BindingFlags.Public
                                                | BindingFlags.NonPublic);
                                            for (int i = 0; i < members.Length; i++)
                                            {
                                                var methodToCheck = members[i] as MethodInfo;
                                                if (methodToCheck.GetBaseDefinition() == baseMethod)
                                                {
                                                    foundMethod = methodToCheck;
                                                    break;
                                                }
                                            }
                                            if (foundMethod != null) break;
                                            type = type.BaseType;
                                        }
                                        overrideMap[baseMethod] = foundMethod;
                                    }

                                    ptr->Type = ValueType.Object;
                                    ptr->Value1 = (int)(ptr - evaluationStackBase);
                                    managedStack[ptr->Value1] = foundMethod;
                                }
                            }
                            break;
                        case Code.Div_Un: //0.00231276%
                            {
                                Value* b = evaluationStackPointer - 1;
                                Value* a = evaluationStackPointer - 1 - 1;
                                evaluationStackPointer = a;
                                switch (a->Type)
                                {
                                    case ValueType.Long:
                                        *((ulong*)&evaluationStackPointer->Value1)
                                            = (*((ulong*)&a->Value1)) / (*((ulong*)&b->Value1));
                                        break;
                                    case ValueType.Integer:
                                        evaluationStackPointer->Value1 = (int)((uint)a->Value1 / (uint)b->Value1);
                                        break;
                                }
                                evaluationStackPointer++;
                            }
                            break;
                        case Code.Mul_Ovf: //0.002134855%
                            {
                                Value* b = evaluationStackPointer - 1;
                                Value* a = evaluationStackPointer - 1 - 1;
                                evaluationStackPointer = a;
                                switch (a->Type)
                                {
                                    case ValueType.Long:
                                        *((long*)&evaluationStackPointer->Value1)
                                            = checked((*((long*)&a->Value1)) * (*((long*)&b->Value1)));
                                        break;
                                    case ValueType.Integer:
                                        evaluationStackPointer->Value1 = checked(a->Value1 * b->Value1);
                                        break;
                                    case ValueType.Float:
                                        *((float*)&evaluationStackPointer->Value1)
                                            = checked((*((float*)&a->Value1)) * (*((float*)&b->Value1)));
                                        break;
                                    case ValueType.Double:
                                        *((double*)&evaluationStackPointer->Value1)
                                            = checked((*((double*)&a->Value1)) * (*((double*)&b->Value1)));
                                        break;
                                }
                                evaluationStackPointer++;
                            }
                            break;
                        case Code.Clt_Un: //0.001956951%
                            {
                                Value* rhs = evaluationStackPointer - 1;
                                Value* lhs = rhs - 1;

                                bool res = false;
                                switch (lhs->Type)
                                {
                                    case ValueType.Integer:
                                        res = (uint)lhs->Value1 < (uint)rhs->Value1;
                                        break;
                                    case ValueType.Long:
                                        res = *(ulong*)&lhs->Value1 < *(ulong*)&rhs->Value1;
                                        break;
                                    case ValueType.Float:
                                        res = !(*(float*)&lhs->Value1 >= *(float*)&rhs->Value1);
                                        break;
                                    case ValueType.Double:
                                        res = !(*(double*)&lhs->Value1 >= *(double*)&rhs->Value1);
                                        break;
                                }
                                lhs->Type = ValueType.Integer;
                                lhs->Value1 = res ? 1 : 0;
                                evaluationStackPointer = rhs;
                            }
                            break;
                        case Code.Conv_R_Un: //0.001423237%
                            {
                                var ptr = evaluationStackPointer - 1;
                                switch (ptr->Type)
                                {
                                    case ValueType.Long:
                                        *(double*)&ptr->Value1 = *(ulong*)&ptr->Value1;
                                        break;
                                    case ValueType.Integer:
                                        *(double*)&ptr->Value1 = (uint)ptr->Value1;
                                        break;
                                }
                                ptr->Type = ValueType.Double;
                            }
                            break;
                        case Code.Stelem_I: //0.001245332% 
                            {
                                var val = *(long*)&(evaluationStackPointer - 1)->Value1;
                                var idx = (evaluationStackPointer - 1 - 1)->Value1;
                                var ptr = evaluationStackPointer - 1 - 1 - 1;
                                var obj = managedStack[ptr->Value1];
                                managedStack[ptr - evaluationStackBase] = null;
                                evaluationStackPointer = ptr;
                                IntPtr[] intPtrArr = obj as IntPtr[];
                                if (intPtrArr != null)
                                {
                                    intPtrArr[idx] = new IntPtr(val);
                                    break;
                                }
                                UIntPtr[] uintPtrArr = obj as UIntPtr[];
                                if (uintPtrArr != null)
                                {
                                    uintPtrArr[idx] = new UIntPtr((ulong)val);
                                }
                            }
                            break;
                        //case Code.Mkrefany: //0.001067428% __makeref关键字，先不支持
                        case Code.Stelem_R8: //0.000889523%
                            {
                                var val = *(double*)&(evaluationStackPointer - 1)->Value1;
                                var idx = (evaluationStackPointer - 1 - 1)->Value1;
                                var ptr = evaluationStackPointer - 1 - 1 - 1;
                                var arr = managedStack[ptr->Value1] as double[];
                                managedStack[ptr - evaluationStackBase] = null;
                                evaluationStackPointer = ptr;
                                arr[idx] = val;
                            }
                            break;
                        case Code.Ldelem_I: //0.000889523% 指针相关
                            {
                                var idx = (evaluationStackPointer - 1)->Value1;
                                var ptr = evaluationStackPointer - 1 - 1;
                                var obj = managedStack[ptr->Value1];
                                managedStack[ptr - evaluationStackBase] = null;
                                evaluationStackPointer--;
                                ptr->Type = ValueType.Long;
                                IntPtr[] intPtrArr = obj as IntPtr[];
                                if (intPtrArr != null)
                                {
                                    *(long*)(&ptr->Value1) = intPtrArr[idx].ToInt64();
                                    break;
                                }
                                UIntPtr[] uintPtrArr = obj as UIntPtr[];
                                if (uintPtrArr != null)
                                {
                                    *(ulong*)(&ptr->Value1) = uintPtrArr[idx].ToUInt64();
                                }
                            }
                            break;
                        case Code.Conv_Ovf_U8: //4
                        case Code.Conv_Ovf_U8_Un:
                            {
                                var ptr = evaluationStackPointer - 1;
                                ulong val;
                                switch (ptr->Type)
                                {
                                    case ValueType.Long:
                                        val = pc->Code == Code.Conv_Ovf_U8 ? checked((ulong)*(long*)&ptr->Value1) :
                                            checked(*(ulong*)&ptr->Value1);
                                        break;
                                    case ValueType.Integer:
                                        val = pc->Code == Code.Conv_Ovf_U8 ? checked((ulong)ptr->Value1) :
                                            checked((uint)ptr->Value1);
                                        break;
                                    case ValueType.Float:
                                        val = checked((ulong)*(float*)&ptr->Value1);
                                        break;
                                    case ValueType.Double:
                                        val = checked((ulong)*(double*)&ptr->Value1);
                                        break;
                                    default:
                                        throw new InvalidProgramException("Conv_Ovf_U8 for " + ptr->Type);
                                }
                                ptr->Type = ValueType.Long;
                                *(long*)&ptr->Value1 = (long)val;
                            }
                            break;
                        case Code.Conv_Ovf_I8:
                        case Code.Conv_Ovf_I8_Un:
                            {
                                var ptr = evaluationStackPointer - 1;
                                long val;
                                switch (ptr->Type)
                                {
                                    case ValueType.Long:
                                        val = pc->Code == Code.Conv_Ovf_I8 ? checked(*(long*)&ptr->Value1) :
                                            checked((long)*(ulong*)&ptr->Value1);
                                        break;
                                    case ValueType.Integer:
                                        val = pc->Code == Code.Conv_Ovf_I8 ? checked((long)ptr->Value1) :
                                            checked((uint)ptr->Value1);
                                        break;
                                    case ValueType.Float:
                                        val = checked((long)*(float*)&ptr->Value1);
                                        break;
                                    case ValueType.Double:
                                        val = checked((long)*(double*)&ptr->Value1);
                                        break;
                                    default:
                                        throw new InvalidProgramException("Conv_Ovf_I8 for " + ptr->Type);
                                }
                                ptr->Type = ValueType.Long;
                                *(long*)&ptr->Value1 = val;
                            }
                            break;
                        case Code.Conv_Ovf_I1: //3
                        case Code.Conv_Ovf_I1_Un:
                            {
                                var ptr = evaluationStackPointer - 1;
                                int val = 0;
                                switch (ptr->Type)
                                {
                                    case ValueType.Long:
                                    case ValueType.Integer:
                                        val = pc->Code == Code.Conv_Ovf_I1 ? checked((sbyte)ptr->Value1) :
                                            checked((sbyte)(uint)ptr->Value1);
                                        break;
                                    case ValueType.Float:
                                        val = checked((sbyte)*(float*)&ptr->Value1);
                                        break;
                                    case ValueType.Double:
                                        val = checked((sbyte)*(double*)&ptr->Value1);
                                        break;
                                }
                                ptr->Type = ValueType.Integer;
                                ptr->Value1 = val;
                            }
                            break;
                        // case Code.Refanytype: //关键字__reftype(this)，暂时不支持
                        case Code.Ldelem_R8:
                            {
                                var idx = (evaluationStackPointer - 1)->Value1;
                                var ptr = evaluationStackPointer - 1 - 1;
                                var arr = managedStack[ptr->Value1] as double[];
                                managedStack[ptr - evaluationStackBase] = null;
                                evaluationStackPointer--;
                                ptr->Type = ValueType.Double;
                                *(double*)&ptr->Value1 = arr[idx];
                            }
                            break;
                        case Code.Ldelem_R4:
                            {
                                var idx = (evaluationStackPointer - 1)->Value1;
                                var ptr = evaluationStackPointer - 1 - 1;
                                var arr = managedStack[ptr->Value1] as float[];
                                managedStack[ptr - evaluationStackBase] = null;
                                evaluationStackPointer--;
                                ptr->Type = ValueType.Float;
                                *(float*)&ptr->Value1 = arr[idx];
                            }
                            break;
                        case Code.Conv_Ovf_I4:
                        case Code.Conv_Ovf_I: // TODO: Conv_Ovf_I
                            {
                                var ptr = evaluationStackPointer - 1;
                                int val;
                                switch (ptr->Type)
                                {
                                    case ValueType.Long:
                                        val = checked((int)*(long*)&ptr->Value1);
                                        break;
                                    case ValueType.Float:
                                        val = checked((int)*(float*)&ptr->Value1);
                                        break;
                                    case ValueType.Double:
                                        val = checked((int)*(double*)&ptr->Value1);
                                        break;
                                    case ValueType.Integer:
                                        val = ptr->Value1;
                                        break;
                                    default:
                                        val = 0;
                                        throwRuntimeException(new NotImplementedException(), true);
                                        break;
                                }
                                ptr->Type = ValueType.Integer;
                                ptr->Value1 = val;
                            }
                            break;
                        case Code.Conv_Ovf_U2:
                        case Code.Conv_Ovf_U2_Un:
                            {
                                var ptr = evaluationStackPointer - 1;
                                int val = 0;
                                switch (ptr->Type)
                                {
                                    case ValueType.Long:
                                        val = pc->Code == Code.Conv_Ovf_U2 ? checked((ushort)*(long*)&ptr->Value1) :
                                            checked((ushort)*(ulong*)&ptr->Value1);
                                        break;
                                    case ValueType.Integer:
                                        val = pc->Code == Code.Conv_Ovf_U2 ? checked((ushort)ptr->Value1) :
                                            checked((ushort)(uint)ptr->Value1);
                                        break;
                                    case ValueType.Float:
                                        val = checked((ushort)*(float*)&ptr->Value1);
                                        break;
                                    case ValueType.Double:
                                        val = checked((ushort)*(double*)&ptr->Value1);
                                        break;
                                }
                                ptr->Type = ValueType.Integer;
                                ptr->Value1 = val;
                            }
                            break;
                        case Code.Conv_Ovf_U1:
                        case Code.Conv_Ovf_U1_Un:
                            {
                                var ptr = evaluationStackPointer - 1;
                                int val;
                                switch (ptr->Type)
                                {
                                    case ValueType.Long:
                                        val = pc->Code == Code.Conv_Ovf_U1 ? checked((byte)*(long*)&ptr->Value1) :
                                            checked((byte)*(ulong*)&ptr->Value1);
                                        break;
                                    case ValueType.Integer:
                                        val = pc->Code == Code.Conv_Ovf_U1 ? checked((byte)ptr->Value1) :
                                            checked((byte)(uint)ptr->Value1);
                                        break;
                                    case ValueType.Float:
                                        val = checked((byte)*(float*)&ptr->Value1);
                                        break;
                                    case ValueType.Double:
                                        val = checked((byte)*(double*)&ptr->Value1);
                                        break;
                                    default:
                                        throw new InvalidProgramException("Conv_Ovf_U1 for " + ptr->Type);
                                }
                                ptr->Type = ValueType.Integer;
                                ptr->Value1 = val;
                            }
                            break;
                        case Code.Conv_Ovf_U4:
                        case Code.Conv_Ovf_U4_Un:
                            {
                                var ptr = evaluationStackPointer - 1;
                                uint val = 0;
                                switch (ptr->Type)
                                {
                                    case ValueType.Long:
                                        val = pc->Code == Code.Conv_Ovf_U4 ? checked((uint)*(long*)&ptr->Value1) :
                                            checked((uint)*(ulong*)&ptr->Value1);
                                        break;
                                    case ValueType.Integer:
                                        val = checked((uint)ptr->Value1);
                                        break;
                                    case ValueType.Float:
                                        val = checked((uint)*(float*)&ptr->Value1);
                                        break;
                                    case ValueType.Double:
                                        val = checked((uint)*(double*)&ptr->Value1);
                                        break;
                                }
                                ptr->Type = ValueType.Integer;
                                ptr->Value1 = (int)val;
                            }
                            break;
                        case Code.Ldelem_I1:
                            {
                                var idx = (evaluationStackPointer - 1)->Value1;
                                var ptr = evaluationStackPointer - 1 - 1;
                                var obj = managedStack[ptr->Value1];
                                managedStack[ptr - evaluationStackBase] = null;
                                evaluationStackPointer--;
                                ptr->Type = ValueType.Integer;
                                sbyte[] sbyteArr = obj as sbyte[];
                                if (sbyteArr != null)
                                {
                                    ptr->Value1 = sbyteArr[idx];
                                    break;
                                }
                                bool[] boolArr = obj as bool[];
                                if (boolArr != null)
                                {
                                    ptr->Value1 = boolArr[idx] ? 1 : 0;
                                }
                            }
                            break;
                        case Code.Conv_Ovf_I_Un: // TODO:
                        case Code.Conv_Ovf_I4_Un:
                            {
                                var ptr = evaluationStackPointer - 1;
                                int val;
                                switch (ptr->Type)
                                {
                                    case ValueType.Long:
                                        val = checked((int)*(ulong*)&ptr->Value1);
                                        break;
                                    case ValueType.Float:
                                        val = checked((int)*(float*)&ptr->Value1);
                                        break;
                                    case ValueType.Double:
                                        val = checked((int)*(double*)&ptr->Value1);
                                        break;
                                    case ValueType.Integer:
                                        val = checked((int)*(uint*)&ptr->Value1);
                                        break;
                                    default:
                                        val = 0;
                                        throwRuntimeException(new NotImplementedException(), true);
                                        break;
                                }
                                ptr->Type = ValueType.Integer;
                                ptr->Value1 = val;
                            }
                            break;
                        case Code.Stelem_R4:
                            {
                                var val = *(float*)&(evaluationStackPointer - 1)->Value1;
                                var idx = (evaluationStackPointer - 1 - 1)->Value1;
                                var ptr = evaluationStackPointer - 1 - 1 - 1;
                                var arr = managedStack[ptr->Value1] as float[];
                                managedStack[ptr - evaluationStackBase] = null;
                                evaluationStackPointer = ptr;
                                arr[idx] = val;
                            }
                            break;
                        case Code.Conv_Ovf_I2:
                        case Code.Conv_Ovf_I2_Un:
                            {
                                var ptr = evaluationStackPointer - 1;
                                int val = 0;
                                switch (ptr->Type)
                                {
                                    case ValueType.Long:
                                    case ValueType.Integer:
                                        val = pc->Code == Code.Conv_Ovf_I2 ? checked((short)ptr->Value1) :
                                            checked((short)(uint)ptr->Value1);
                                        break;
                                    case ValueType.Float:
                                        val = checked((short)*(float*)&ptr->Value1);
                                        break;
                                    case ValueType.Double:
                                        val = checked((short)*(double*)&ptr->Value1);
                                        break;
                                }
                                ptr->Type = ValueType.Integer;
                                ptr->Value1 = val;
                            }
                            break;
                        //case Code.Conv_Ovf_U: //ptr->m_Size = (this.scratch - checked((UIntPtr)ptr->m_Ptr)) / 1;
                        case Code.Throw: //1.404557%，虽然静态占比大，但运行时执行的次数应该比较少
                            {
                                var exceptionPos = (evaluationStackPointer - evaluationStackBase - 1);
                                var exception = managedStack[(evaluationStackPointer - 1)->Value1] as Exception;
                                managedStack[exceptionPos] = null;
                                evaluationStackPointer--;
                                throw exception;
                            }
                        case Code.Shr: 
                            {
                                var ptr = evaluationStackPointer - 1 - 1;
                                int bits = (evaluationStackPointer - 1)->Value1;
                                switch (ptr->Type)
                                {
                                    case ValueType.Integer:
                                        ptr->Value1 = ptr->Value1 >> bits;
                                        break;
                                    case ValueType.Long:
                                        *((long*)&ptr->Value1) = (*((long*)&ptr->Value1)) >> bits;
                                        break;
                                    default:
                                        throw new InvalidProgramException(">> for " + ptr->Type);
                                }
                                evaluationStackPointer--;
                            }
                            break;
                        case Code.Ldtoken: //大多数都被ldtype替代了
                            {
                                var type = externTypes[pc->Operand];
                                EvaluationStackOperation.PushObject(evaluationStackBase, evaluationStackPointer,
                                    managedStack, type.TypeHandle, typeof(RuntimeTypeHandle));
                                evaluationStackPointer++;
                            }
                            break;
                        case Code.Rethrow:
                            throw throwExcepton;
                        case Code.Nop://0.0270415% but被过滤了
                            break;
                        default:
                            throwRuntimeException(new NotImplementedException(code.ToString() + " " + pc->Operand),
                                true);
                            break;

                    }

                    //if (methodIndex == 527 || methodIndex == 528)
                    //{
                    //    _Info("** End Code = " + pc->Code + ", Oprand = " + pc->Operand + ", ESP = " 
                    //        + (evaluationStackPointer - localBase - localsCount));
                    //}
                    //if (traceValue != null)
                    //{
                    //    _Info("after:" + traceValue->Type + "," + traceValue->Value1 + (traceValue->Type
                    //        == ValueType.Object ? ("," + managedStack[traceValue->Value1]) : ""));
                    //}
                    pc++;
                }
                catch(RuntimeException e)
                {
                    if (topWriteBack != null)
                    {
                        *topWriteBack = argumentBase - refCount;
                        throw e.Real;
                    }
                    else
                    {
                        throw e;
                    }
                }
                catch(Exception e)
                {
                    int ipc = (int)(pc - pcb);
                    ExceptionHandler eh = getExceptionHandler(methodIndex, e.GetType(), ipc);
                    if (eh != null)
                    {
                        //clear evaluation stack
                        Value* newEvaluationStackPointer = localBase + localsCount;
                        int topPos = (int)(evaluationStackPointer - evaluationStackBase);
                        int newPos = (int)(newEvaluationStackPointer - evaluationStackBase);
                        for (int i = newPos; i < topPos; i++)
                        {
                            managedStack[i] = null;
                        }

                        evaluationStackPointer = newEvaluationStackPointer;
                        evaluationStackPointer->Type = ValueType.Object;
                        evaluationStackPointer->Value1 = newPos;
                        managedStack[newPos] = e;
                        evaluationStackPointer++;

                        throwExcepton = e;

                        pc = pcb + eh.HandlerStart;
                    }
                    else
                    {
                        int topPos = (int)(evaluationStackPointer - evaluationStackBase);
                        int newPos = (int)(argumentBase - evaluationStackBase) - refCount;
                        for (int i = newPos; i < topPos; i++)
                        {
                            managedStack[i] = null;
                        }

                        if (topWriteBack != null)
                        {
                            *topWriteBack = argumentBase - refCount;
                        }

                        throwExcepton = null;
                        throw e;
                    }
                }
            }
        }

        public static void Sweep()
        {
            NewFieldInfo.Sweep();
        }

        public string Statistics()
        {
            var sb = new System.Text.StringBuilder();

            sb.AppendFormat("exceptionHandlers: {0}\n", exceptionHandlers == null ? 0 : exceptionHandlers.Length);
            sb.AppendFormat("externInvokers: {0}\n", externInvokers == null ? 0 : externInvokers.Length);
            sb.AppendFormat("externMethods: {0}\n", externMethods == null ? 0 : externMethods.Length);
            sb.AppendFormat("externTypes: {0}\n", externTypes == null ? 0 : externTypes.Length);
            sb.AppendFormat("internStrings: {0}\n", internStrings == null ? 0 : internStrings.Length);
            sb.AppendFormat("fieldInfos: {0}\n", fieldInfos == null ? 0 : fieldInfos.Length);
            sb.AppendFormat("anonymousStoreyInfos: {0}\n", anonymousStoreyInfos == null ? 0
                : anonymousStoreyInfos.Length);
            sb.AppendFormat("overrideCache: {0}\n", overrideCache == null ? 0 : overrideCache.Count);
            sb.AppendFormat("staticFieldTypes: {0}\n", staticFieldTypes == null ? 0 : staticFieldTypes.Length);
            sb.AppendFormat("staticFields: {0}\n", staticFields == null ? 0 : staticFields.Length);
            sb.AppendFormat("cctors: {0}\n", cctors == null ? 0 : cctors.Length);

            return sb.ToString();
        }

        [Obsolete("not support now!", true)]
        public static void SetGlobal(VirtualMachine virtualMachine, bool throwWhileExisted = false)
        {
            throw new NotSupportedException();
        }

        [Obsolete("use PatchManager.Load instead!")]
        public static void InitializeGlobal(Stream stream)
        {
            PatchManager.Load(stream);
        }

        [Obsolete("use PatchManager.Load instead!")]
        public static void ReplaceGlobal(Stream stream)
        {
            PatchManager.Load(stream);
        }

        [Obsolete("use PatchManager.Unload instead!")]
        public static void RemoveGlobal()
        {
            PatchManager.Unload(Assembly.GetCallingAssembly());
        }

        [Obsolete("not support now!", true)]
        public static VirtualMachine GetGlobal()
        {
            throw new NotSupportedException();
        }
    }
}

```

`Source/VSProj/Src/Core/WrappersManager.cs`:

```cs
/*
 * Tencent is pleased to support the open source community by making InjectFix available.
 * Copyright (C) 2019 Tencent.  All rights reserved.
 * InjectFix is licensed under the MIT License, except for the third-party components listed in the file 'LICENSE' which may be subject to their corresponding license terms. 
 * This file is subject to the terms and conditions defined in file 'LICENSE', which is part of this source code package.
 */

using System;

namespace IFix.Core
{
    //该接口由注入器自动实现
    public interface WrappersManager
    {
        //创建一个delegate，如果anon非空就是闭包
        Delegate CreateDelegate(Type type, int id, object anon);
        //创建一个interface桥接器
        AnonymousStorey CreateBridge(int fieldNum, int[] fieldTypes, int typeIndex, int[] vTable, int[] slots, VirtualMachine virtualMachine);
        //创建一个wrapper对象（会由补丁加载逻辑调用，创建后放入wrapper数组）
        object CreateWrapper(int id);
        //初始化wrapper数组
        object InitWrapperArray(int len);
    }
}

```

`Source/VSProj/Src/PerfTest/PerfTest.cs`:

```cs
/*
 * Tencent is pleased to support the open source community by making InjectFix available.
 * Copyright (C) 2019 Tencent.  All rights reserved.
 * InjectFix is licensed under the MIT License, except for the third-party components listed in the file 'LICENSE' which may be subject to their corresponding license terms. 
 * This file is subject to the terms and conditions defined in file 'LICENSE', which is part of this source code package.
 */

using IFix.Core;
using System;
using System.Collections.Generic;
using System.Diagnostics;

namespace IFix.Test
{
    public class PerfTest
    {
        //基准测试，空方法调用
        static void Base()
        {
            int LOOPS = 10000000;
            var virtualMachine = SimpleVirtualMachineBuilder.CreateVirtualMachine(LOOPS);

            for (int i = 0; i < 3; i++)
            {
                var sw = Stopwatch.StartNew();
                Call call = Call.Begin();
                virtualMachine.Execute(1, ref call, 0);
                Call.End(ref call);
                sw.Stop();
                Console.WriteLine("Base " + i + "  : " + (LOOPS / (int)sw.Elapsed.TotalMilliseconds * 1000) + "\r\n");
            }
        }

        //通过Call对象调用add方法，该方法逻辑如下，SimpleVirtualMachineBuilder通过硬编码指令获得
        //int add(int a, int b)
        //{
        //    return a + b;
        //}
        //原生方法通过这种方式调用虚拟机方法
        static void SafeCall()
        {
            int LOOPS = 10000000;
            var virtualMachine = SimpleVirtualMachineBuilder.CreateVirtualMachine(LOOPS);

            var sw = Stopwatch.StartNew();
            for (int i = 0; i < LOOPS; i++)
            {
                Call call = Call.Begin();
                call.PushInt32(4);
                call.PushInt32(6);
                virtualMachine.Execute(0, ref call, 2);
                Call.End(ref call);
                call.GetInt32();
            }
            Console.WriteLine("SafeCall " + "  : " + (LOOPS / (int)sw.Elapsed.TotalMilliseconds * 1000) + "\r\n");
        }

        //直接通过指针操作栈，调用add方法
        //虚拟机内部方法间调用是通过这种方式
        unsafe static void UnsafeCall()
        {
            IntPtr nativePointer = System.Runtime.InteropServices.Marshal.AllocHGlobal(sizeof(Value)
                * VirtualMachine.MAX_EVALUATION_STACK_SIZE);
            Value* evaluationStackPointer = (Value*)nativePointer.ToPointer();
            object[] managedStack = new object[VirtualMachine.MAX_EVALUATION_STACK_SIZE];

            int LOOPS = 10000000;
            var virtualMachine = SimpleVirtualMachineBuilder.CreateVirtualMachine(LOOPS);
            var sw = Stopwatch.StartNew();
            for (int i = 0; i < LOOPS; i++)
            {
                evaluationStackPointer->Value1 = 10;
                evaluationStackPointer->Type = IFix.Core.ValueType.Integer;

                (evaluationStackPointer + 1)->Value1 = 20;
                (evaluationStackPointer + 1)->Type = IFix.Core.ValueType.Integer;

                virtualMachine.Execute(0, evaluationStackPointer, managedStack, evaluationStackPointer, 2);
            }
            Console.WriteLine("UnsafeCall " + "  : " + (LOOPS / (int)sw.Elapsed.TotalMilliseconds * 1000) + "\r\n");

            System.Runtime.InteropServices.Marshal.FreeHGlobal(nativePointer);
        }

        public static void Main(string[] args)
        {
            Base();
            SafeCall();
            UnsafeCall();
            Console.Read();
        }
    }
}

```

`Source/VSProj/Src/TestDLL/BaseTest.cs`:

```cs
/*
 * Tencent is pleased to support the open source community by making InjectFix available.
 * Copyright (C) 2019 Tencent.  All rights reserved.
 * InjectFix is licensed under the MIT License, except for the third-party components listed in the file 'LICENSE' which may be subject to their corresponding license terms. 
 * This file is subject to the terms and conditions defined in file 'LICENSE', which is part of this source code package.
 */

using System;
using System.Collections.Generic;
using System.Linq.Expressions;

namespace IFix.Test
{
    public delegate int TestDelegate(int a, out float b, ref long c, Action cb);

    public interface TestInterface
    {
        int Foo();
        void Bar(double a);
    }

    [CustomBridge]
    public static class AdditionalBridge
    {
        static List<Type> bridge = new List<Type>()
        {
            typeof(TestDelegate),
            typeof(IEnumerator<long>),
            typeof(IEnumerable<double>),
            typeof(TestInterface),
            typeof(Action<int, float, double, char>),
        };
    }

    public class RefTypeCounter
    {
        int i = 0;

        public void Inc()
        {
            i++;
        }

        public int Val
        {
            get
            {
                return i;
            }
        }
    }

    public struct ValueTypeCounter
    {
        public int i;

        public ValueTypeCounter(int v)
        {
            i = v;
        }

        public void Inc()
        {
            i++;
        }

        public int Val
        {
            get
            {
                return i;
            }
        }

        public override string ToString()
        {
            return "ValueTypeCounter { " + i + " }";
        }

        public int CompareTo(object o)
        {
            if (!(o is ValueTypeCounter))
            {
                throw new ArgumentException();
            }

            int v = ((ValueTypeCounter)o).i;
            if (i > v)
            {
                return 1;
            }
            if (i < v)
            {
                return -1;
            }
            return 0;
        }
    }

    public struct W1
    {
        public ValueTypeCounter F;
    }

    public struct W2
    {
        public W1 F;
    }

    public struct W3
    {
        public W2 F;
    }

    public class ValueTypeCounterContainer
    {
        public ValueTypeCounter c;

        public void Init(int a)
        {
            c = new ValueTypeCounter();
            c.i = a;
        }
    }

    public class GenericClass<T>
    {
        public string F<T1, T2>(T1 a)
        {
            return "1";
        }

        public string F<T1, T2>(T1 a, T b)
        {
            return "2";
        }

        public string F<T>(T a)
        {
            return "3";
        }

        public string F<T1>(T a)
        {
            return "4";
        }

        public string F<T1>(List<T1> a)
        {
            return "5";
        }

        public string F(List<T> a)
        {
            return "6";
        }

        //TODO: 泛型+引用及数组

        //TODO: 泛型实参同时含函数泛型参数及类泛型参数

        //TODO: 由于目前泛型函数不解析执行，所以泛型实参在泛型函数间传递不用考虑，但后续如果要支持泛型函数的解析执行的话，要加入这点的考虑

        //public void F<T4>(List<T4> a)
        //{
        //
        //}

        public string F(T a)
        {
            return "7";
        }

        public string F()
        {
            return "8";
        }

        public class InnerClass
        {
            public string F(T a)
            {
                return "9";
            }
        }

        public string F(T[] a)
        {
            return "0";
        }

        public string F<T1>(T1[] a)
        {
            return "a";
        }

        public string F(T[,] a)
        {
            return "b";
        }

        public string F<T1>(T1[,] a)
        {
            return "c";
        }

        public string F(ref T a)
        {
            return "d";
        }

        public string F<T1>(ref T1 a)
        {
            return "e";
        }

        public string F(ref T[] a)
        {
            return "f";
        }

        public string F<T1>(ref T1[] a)
        {
            return "g";
        }
    }

    public class AnonymousClass
    {
        public void Repeat(Action action, int n)
        {
            for (int i = 0; i < n; i++)
            {
                action();
            }
        }

        protected int f = 0;

        static int sf = 0;

        public void CallRepeat(int n, out int local, out int field, out int staticField)
        {
            int i = 0;
            Repeat(() =>
            {
                i++;
                f++;
                sf++;
            }, n);
            local = i;
            field = f;
            staticField = sf;
        }

        void fadd2()
        {
            f += 2;
            sf += 2;
        }

        public void CallRepeat(int n, out int field, out int staticField)
        {
            Repeat(fadd2, n);
            field = f;
            staticField = sf;
        }

        public void Lessthan(List<int> list, int upper)
        {
            list.RemoveAll(x => x > upper);
        }

        public void Lessthan5(List<int> list)
        {
            list.RemoveAll(x => x > 5);
        }

        public void LessthanField(List<int> list)
        {
            list.RemoveAll(x => x > f);
        }

        public virtual void FAdd()
        {
            f += 3;
        }

        public void CallRepeat(int n, out int field)
        {
            Repeat(FAdd, n);
            field = f;
        }

        //public Expression<Func<int, bool>> GenExpression()
        //{
        //    Expression<Func<int, bool>> exprTree = num => num < 5;
        //    return exprTree;
        //}

        public System.Collections.IEnumerator Generator()
        {
            yield return 1;
            for (int i = 1; i < 10; i++)
            {
                yield return i;
            }
            yield return f;
        }

        public IEnumerator<int> Generator(int n)
        {
            yield return 1;
            for (int i = 1; i < n; i++)
            {
                yield return i;
            }
            yield return f;
        }

        public System.Collections.IEnumerable GetEnumerable()
        {
            yield return 1;
            for (int i = 1; i < 10; i++)
            {
                yield return i;
            }
            yield return f;
        }
    }

    public class BaseClass
    {
        public virtual int Foo()
        {
            Console.WriteLine("BaseClass.Foo");
            return 0;
        }
    }

    public interface ItfWithRefParam
    {
        int WithRefParam(ref int a, out int b);
    }

    public class DrivenClass : BaseClass, ItfWithRefParam
    {
        public override int Foo()
        {
            Console.WriteLine("DrivenClass.Foo");
            return 1;
        }

        public int WithRefParam(ref int a, out int b)
        {
            a *= 2;
            b = a + 1;
            return a;
        }
    }

    public interface Calc
    {
        int Add(int a, int b);
        int Scale { get; set; }
    }

    public class SimpleCalc : Calc
    {
        public SimpleCalc()
        {
            Scale = 1;
        }

        public int Add(int a, int b)
        {
            return (a + b) * Scale;
        }

        public int Scale { get; set; }
    }

    public static class BaseTest
    {
        static int add(int a, int b)
        {
            return a + b;
        }

        public static long Base(int loop)
        {
            //System.Console.WriteLine(loop);
            long sum = 0;
            for (int i = 0; i < 3; i++)
            {
                sum += add(i, i + 1);
                switch(loop)
                {
                    case 0:
                        sum += 1;
                        break;
                    case 1:
                        sum += 2;
                        break;
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    //case 7:
                        sum -= 1;
                        break;
                    default:
                        sum -= 2;
                        break;
                }
            }
            return sum;
        }

        public static long Ref(ref int a, int b, ref long c, long d, out int e)
        {
            a += b;
            c += d;
            e = a + b;
            return a + b + c + d + e;
        }

        static void Swap(ref object l, ref object r)
        {
            object t = l;
            l = r;
            r = t;
        }

        public static void Ref(ref object l, ref object r)
        {
            Swap(ref l, ref r);
        }

        public static void Ref(ref ValueTypeCounter l, ref ValueTypeCounter r)
        {
            ValueTypeCounter t = l;
            l = r;
            r = t;
        }

        //1、leave的目标不一定紧跟finally block，可以是任何地方
        //2、leave要找到最内层的finally跳转
        //3、endfinally有两种情况，如果是leave跳过来，则跳到leave的目标，如果不是，则重新抛异常
        //4、为了减少注入代码注入侧不try-catch，由解析器清栈，包括引用参数，所以要传入引用参数的个数
        //5、正常leave不应该有查找finally的操作，否则非常慢
        //6、一个finally block里头的leave指令，可以有不同的目标地址，比如：try{}catch{goto}
        //7、leave如果在一个finally block内，而目标地址在finally的try block之外，那么这个finally block在跳转前执行，
        //   如果有多个这样的finally，则从内到外执行（抛异常其实也可以理解为跳出了finally）
        public static void ExceptionBase(ref int p)
        {
            while (p != 100)
            {
                try
                {
                    //Console.WriteLine("in while");
                    if (p < 0)
                    {
                        throw new ArgumentException();
                    }
                    else
                    {
                        p--;
                        break;
                    }
                }
                finally
                {
                    p--;
                }
            }
            try
            {
                try
                {
                    if (p < 0)
                    {
                        throw new InvalidOperationException();
                    }
                    p++;
                }
                finally
                {
                    p += 2;
                }
            }
            finally
            {
                p += 2;
            }
        }

        public static void Rethrow()
        {
            try
            {
                throw new InvalidOperationException();
            }
            catch(InvalidOperationException e)
            {
                throw;
            }
        }

        public static void LeavePoint(int p, ref int n1, ref int f1, ref int f2)
        {
            L1:
            if (p == -1)
            {
                goto L3;
            }
            try
            {
                try
                {
                    if (p == 0)
                    {
                        p = -1;
                        goto L1;
                    }
                    else if(p == 1)
                    {
                        goto L2;
                    }
                    else if (p == 2)
                    {
                        goto L3;
                    }
                }
                finally
                {
                    f1++;
                }
                L2:
                n1++;
            }
            finally
            {
                f2++;
            }
            L3:
            return;
        }

        public static void TryCatchFinally(bool bThrow, ref bool t, ref bool c, ref bool f, ref bool e)
        {
            try
            {
                if (bThrow)
                {
                    throw new Exception();
                }
                Console.WriteLine("t");
                t = true;
            }
            catch
            {
                Console.WriteLine("c");
                c = true;
            }
            finally
            {
                Console.WriteLine("f");
                f = true;
            }
            Console.WriteLine("e");
            e = true;
        }

        public static void CatchByNextLevel(out bool f1, out bool f2, out bool f3)
        {
            f1 = f2 = f3 = false;
            try
            {
                try
                {
                    throw new Exception();
                }
                finally
                {
                    f1 = true;
                }
            }
            catch
            {
                f2 = true;
            }
            finally
            {
                f3 = true;
            }
        }

        static void CallInc(ValueTypeCounter counter)
        {
            counter.Inc();
        }

        static void CallInc(RefTypeCounter counter)
        {
            counter.Inc();
        }

        public static void PassByValue(ref ValueTypeCounter c1, RefTypeCounter c2)
        {
            c1.Inc();
            c2.Inc();
            CallInc(c1);
            CallInc(c2);
        }

        public static void VirtualFunc(out int r1, out int r2)
        {
            BaseClass o1 = new BaseClass();
            BaseClass o2 = new DrivenClass();
            r1 = o1.Foo();
            r2 = o2.Foo();
        }

        public static int InterfaceTest(int a, int b, int scale)
        {
            Calc calc = new SimpleCalc();
            calc.Scale = scale;
            return calc.Add(a, b);
        }

        public static int ItfWithRefParam(ref int a, out int b)
        {
            ItfWithRefParam o = new DrivenClass();
            return o.WithRefParam(ref a, out b);
        }

        public static string VirtualFuncOfStruct(ValueTypeCounter vtc)
        {
            return vtc.ToString() + ",hashcode:" + vtc.GetHashCode();
        }

        public static Type GetIntType()
        {
            return typeof(int);
        }

        public static string GenericOverload()
        {
            GenericClass<int> a = new GenericClass<int>();
            System.Text.StringBuilder sb = new System.Text.StringBuilder();
            sb.Append(a.F());
            sb.Append(a.F(1));
            sb.Append(a.F<float>(1));
            sb.Append(a.F<float>(new List<float>()));
            sb.Append(a.F<int, double>(1));
            sb.Append(a.F(new List<int>()));
            sb.Append(a.F<int, double>(1, 1));
            GenericClass<int>.InnerClass b = new GenericClass<int>.InnerClass();
            sb.Append(b.F(1));
            sb.Append(a.F<byte>((byte)1));
            int[] p1 = null;
            sb.Append(a.F(p1));
            float[] p2 = null;
            sb.Append(a.F(p2));
            int[,] p3 = null;
            sb.Append(a.F(p3));
            float[,] p4 = null;
            sb.Append(a.F(p4));
            int p5 = 1;
            byte p6 = 1;
            sb.Append(a.F(ref p5));
            sb.Append(a.F(ref p6));
            sb.Append(a.F(ref p1));
            sb.Append(a.F(ref p2));
            return sb.ToString();
        }

        public static int SField = 1;

        public static int StaticFieldBase()
        {
            return SField++;
        }

        public static byte[] Conv_Ovf_I(long l)
        {
            return new byte[l];
        }

        public static int Conv_I4(float i)
        {
            return (int)i;
        }

        public static int Conv_I4(double i)
        {
            return (int)i;
        }

        public static int Conv_I4(long i)
        {
            return (int)i;
        }

        public static int Conv_Ovf_I4_Un(uint i)
        {
            return checked((int)i);
        }

        public static int Conv_Ovf_I4(long i)
        {
            return checked((int)i);
        }

        public static int Ldlen(int[] arr)
        {
            return arr.Length;
        }

        public static int[] Newarr(int len)
        {
            return new int[len];
        }

        public static RefTypeCounter Castclass(object o)
        {
            return (RefTypeCounter)o;
        }

        public static RefTypeCounter Isinst(object o)
        {
            return o as RefTypeCounter;
        }

        public static object ArrayGet(object[] arr, int idx)
        {
            return arr[idx];
        }

        public static void ArraySet(object[] arr, int idx, object val)
        {
            arr[idx] = val;
        }

        public static void ArraySet(object[] arr, int idx)
        {
            arr[idx] = 1;
        }

        public static bool ArrayGet(bool[] arr, int idx)
        {
            return arr[idx];
        }

        public static void ArraySet(bool[] arr, int idx, bool val)
        {
            arr[idx] = val;
        }

        public static byte ArrayGet(byte[] arr, int idx)
        {
            return arr[idx];
        }

        public static void ArraySet(byte[] arr, int idx, byte val)
        {
            arr[idx] = val;
        }

        public static sbyte ArrayGet(sbyte[] arr, int idx)
        {
            return arr[idx];
        }

        public static void ArraySet(sbyte[] arr, int idx, sbyte val)
        {
            arr[idx] = val;
        }

        public static int ArrayGet(int[] arr, int idx)
        {
            return arr[idx];
        }

        public static void ArraySet(int[] arr, int idx, int val)
        {
            arr[idx] = val;
        }

        public static uint ArrayGet(uint[] arr, int idx)
        {
            return arr[idx];
        }

        public static void ArraySet(uint[] arr, int idx, uint val)
        {
            arr[idx] = val;
        }

        public static float ArrayGet(float[] arr, int idx)
        {
            return arr[idx];
        }

        public static void ArraySet(float[] arr, int idx, float val)
        {
            arr[idx] = val;
        }

        public static double ArrayGet(double[] arr, int idx)
        {
            return arr[idx];
        }

        public static void ArraySet(double[] arr, int idx, double val)
        {
            arr[idx] = val;
        }

        public static char ArrayGet(char[] arr, int idx)
        {
            return arr[idx];
        }

        public static void ArraySet(char[] arr, int idx, char val)
        {
            arr[idx] = val;
        }

        public static short ArrayGet(short[] arr, int idx)
        {
            return arr[idx];
        }

        public static void ArraySet(short[] arr, int idx, short val)
        {
            arr[idx] = val;
        }

        public static ushort ArrayGet(ushort[] arr, int idx)
        {
            return arr[idx];
        }

        public static void ArraySet(ushort[] arr, int idx, ushort val)
        {
            arr[idx] = val;
        }

        public static IntPtr ArrayGet(IntPtr[] arr, int idx)
        {
            return arr[idx];
        }

        public static void ArraySet(IntPtr[] arr, int idx, IntPtr val)
        {
            arr[idx] = val;
        }

        public static UIntPtr ArrayGet(UIntPtr[] arr, int idx)
        {
            return arr[idx];
        }

        public static void ArraySet(UIntPtr[] arr, int idx, UIntPtr val)
        {
            arr[idx] = val;
        }

        public static int ArrayGet(int[] arr, uint idx)
        {
            return arr[idx];
        }

        public static void ArraySet(int[] arr, uint idx, int val)
        {
            arr[idx] = val;
        }

        public static int And(int a, int b)
        {
            return a & b;
        }

        public static long And(long a, long b)
        {
            return a & b;
        }

        public static int Or(int a, int b)
        {
            return a | b;
        }

        public static long Or(long a, long b)
        {
            return a | b;
        }

        static void intref(ref int a)
        {
            a += 10;
        }

        public static int Ldflda(ref ValueTypeCounter c)
        {
            intref(ref c.i);
            return c.i;
        }

        public static int Ldflda(ref ValueTypeCounterContainer cc)
        {
            return Ldflda(ref cc.c);
        }

        public static int Ldflda(ref W1 p)
        {
            return Ldflda(ref p.F);
        }

        public static int Ldflda(ref W2 p)
        {
            return Ldflda(ref p.F);
        }

        public static int Ldflda(ref W3 p)
        {
            return Ldflda(ref p.F);
        }

        public static int Ldflda_m(ref W3 p)
        {
            return p.F.F.F.i;
        }

        public static bool Ceq(int a, int b)
        {
            return a == b;
        }

        public static bool Ceq(double a, double b)
        {
            return a == b;
        }

        public static int Shl(int a, int bits)
        {
            return a << bits;
        }

        public static long Shl(long a, int bits)
        {
            return a << bits;
        }

        public static int Shr(int a, int bits)
        {
            return a >> bits;
        }

        public static long Shr(long a, int bits)
        {
            return a >> bits;
        }

        public static uint Shr_Un(uint a, int bits)
        {
            return a >> bits;
        }

        public static ulong Shr_Un(ulong a, int bits)
        {
            return a >> bits;
        }

        public static byte Conv_U1(int a)
        {
            return (byte)a;
        }

        public static byte Conv_Ovf_U1(int a)
        {
            return checked((byte)a);
        }

        public static byte Conv_Ovf_U1_Un(uint a)
        {
            return checked((byte)a);
        }

        public static void Ldelema(int[] arr, int idx)
        {
            intref(ref arr[idx]);
        }

        public static int Bgt(int a, int b)
        {
            if (a > b)
            {
                goto R1;
            }
            else if (a < b)
            {
                goto RM1;
            }
            else
            {
                goto R0;
            }
            R1:
            return 1;
            RM1:
            return -1;
            R0:
            return 0;
        }

        public static int Initobj(int a)
        {
            ValueTypeCounter c1 = new ValueTypeCounter();
            c1.Inc();
            ValueTypeCounter c2 = new ValueTypeCounter(a);
            ValueTypeCounterContainer cc = new ValueTypeCounterContainer();
            cc.Init(a);
            return c1.Val + c2.Val + cc.c.Val;
        }

        public static int si = 0;

        public static int Ldsflda()
        {
            intref(ref si);
            return si;
        }

        public static int Div(int a, int b)
        {
            return a / b;
        }

        public static float Div(float a, float b)
        {
            return a / b;
        }

        public static double Div(double a, double b)
        {
            return a / b;
        }

        public static long Div(long a, long b)
        {
            return a / b;
        }

        public static bool Cgt_Un(uint a, uint b)
        {
            return a > b;
        }

        public static bool NaNFloat(int op, float a, float b)
        {
            switch(op)
            {
                case 0:
                    return a < b;//clt
                case 1:
                    return a > b;//cgt
                case 2:
                    return a <= b;//cgt.un + ceq 0
                case 3:
                    return a >= b;//clt.un + ceq 0
                //case 5:
                //    return a == b;//ceq
                //case 6:
                //    return a != b;//ceq + ceq
            }
            throw new ArgumentException();
        }

        public static int Rem(int a, int b)
        {
            return a % b;
        }

        public static float Rem(float a, float b)
        {
            return a % b;
        }

        public static uint Rem(uint a, uint b)
        {
            return a % b;
        }

        public static double Ldc_R8()
        {
            return 3.1415;
        }

        public static double Ldc_I8()
        {
            return 9223372036854775808;
        }

        public static ulong Conv_U8(float a)
        {
            return (ulong)a;
        }

        public static long Conv_I8(float a)
        {
            return (long)a;
        }

        public static ulong Conv_Ovf_U8(long a)
        {
            return checked((ulong)a);
        }
        public static ulong Conv_Ovf_U8(float a)
        {
            return checked((ulong)a);
        }

        public static long Conv_Ovf_I8(ulong a)
        {
            return checked((long)a);
        }
        public static long Conv_Ovf_I8(float a)
        {
            return checked((long)a);
        }
        public static int Xor(int a, int b)
        {
            return a ^ b;
        }
        public static long Xor(long a, long b)
        {
            return a ^ b;
        }

        public static double Conv_R_Un(uint a)
        {
            return a;
        }

        public static float Conv_R_Un(ulong a)
        {
            return a;
        }

        public static int Mul_Ovf(int a, int b)
        {
            return checked(a * b);
        }

        public static uint Mul_Ovf_Un(uint a, uint b)
        {
            return checked(a * b);
        }

        public static int Add_Ovf(int a, int b)
        {
            return checked(a + b);
        }

        public static uint Add_Ovf_Un(uint a, uint b)
        {
            return checked(a + b);
        }

        public static uint Div_Un(uint a, uint b)
        {
            return a / b;
        }

        public static int Neg(int a)
        {
            return -a;
        }

        public static long Neg(long a)
        {
            return -a;
        }

        public static float Neg(float a)
        {
            return -a;
        }

        public static double Neg(double a)
        {
            return -a;
        }

        public static int Not(int a)
        {
            return ~a;
        }

        public static long Not(long a)
        {
            return ~a;
        }

        public static int Blt_Un(float a, float b)
        {
            if (a >= b)
            {
                return 11;
            }
            else
            {
                return 22;
            }
        }

        public static int Bgt_Un(float a, float b)
        {
            if (a <= b)
            {
                return 11;
            }
            else
            {
                return 22;
            }
        }

        /*public interface Itf
        {
            void Foo();
        }

        public struct MyStrunct : Itf
        {
            public int A;

            public void Foo()
            {
                Console.WriteLine("MyStrunct.Foo:" + A--);
            }

            public override string ToString() { return ""; }
        }

        class MyClass : Itf
        {
            public void Foo()
            {
                Console.WriteLine("MyClass.Foo");
            }
        }

        static void CallFoo(Itf itf)
        {
            itf.Foo();
        }

        public static void ConstrainedInstruction(bool a, int b)
        {
            MyClass e = new MyClass();
            e.ToString();
            DateTime dt = new DateTime();
            dt.ToString();
            MyStrunct ms = new MyStrunct() { A = 10 };
            ms.ToString();
            Console.WriteLine("a:" + a);
            Console.WriteLine("b:" + b);
            a.ToString();
            b.ToString();
            object[] args = new object[0];
            var m = typeof(Itf).GetMethod("Foo");
            m.Invoke(e, args);

            ms.Foo();
            Console.WriteLine("ms.A:" + ms.A);
            m.Invoke(ms, args);
            Console.WriteLine("ms.A:" + ms.A);
            CallFoo(ms);
            Console.WriteLine("ms.A:" + ms.A);

            object o = ms;
            Console.WriteLine("before o.A:" + ((MyStrunct)o).A);
            m.Invoke(o, args);
            Console.WriteLine("after o.A:" + ((MyStrunct)o).A);

            Itf itf = ms;
            itf.Foo();
        }*/

        /*public static void ExceptionBase(int p)
        {
            BEGIN:

            try
            {
                try
                {
                    if (p > 5)
                    {
                        Console.WriteLine("p=" + p);
                        p--;
                        throw new InvalidOperationException();
                    }
                    Console.WriteLine("leave1...");
                }
                catch (InvalidOperationException)
                {
                    goto BEGIN;
                }
                catch (InvalidProgramException)
                {

                }
                finally
                {
                    Console.WriteLine("finally1");
                    p--;
                }
                Console.WriteLine("leave2...");
            }
            finally
            {
                Console.WriteLine("finally2");
            }
        }*/

        /*public static void ExceptionBase(int p)
        {
            try
            {
                if (p == 1)
                {
                    throw new InvalidCastException();
                }
                else if (p == 2)
                {
                    throw new InvalidOperationException();
                }
                else if (p == 3)
                {
                    throw new InvalidProgramException();
                }
                else
                {
                    throw new Exception();
                }
            }
            catch(InvalidCastException e)
            {
                Console.WriteLine(e.StackTrace);
            }
            catch(InvalidOperationException e)
            {
                Console.WriteLine(e.StackTrace);
            }
            catch(InvalidProgramException e)
            {

            }
            finally
            {
                Console.WriteLine(1);
            }
        }*/
    }
}
```

`Source/VSProj/Src/TestDLL/RedirectBaseTest.cs`:

```cs
/*
 * Tencent is pleased to support the open source community by making InjectFix available.
 * Copyright (C) 2019 Tencent.  All rights reserved.
 * InjectFix is licensed under the MIT License, except for the third-party components listed in the file 'LICENSE' which may be subject to their corresponding license terms. 
 * This file is subject to the terms and conditions defined in file 'LICENSE', which is part of this source code package.
 */

using System;
using System.Collections.Generic;
using System.Linq.Expressions;

namespace IFix.Test.Redirect
{
    public delegate int TestDelegate(int a, out float b, ref long c, Action cb);

    public interface TestInterface
    {
        int Foo();
        void Bar(double a);
    }

    [CustomBridge]
    public static class AdditionalBridge
    {
        static List<Type> bridge = new List<Type>()
        {
            typeof(TestDelegate),
            typeof(IEnumerator<long>),
            typeof(IEnumerable<double>),
            typeof(TestInterface),
            typeof(Action<int, float, double, char>),
        };
    }

    public class RefTypeCounter
    {
        int i = 0;

        public void Inc()
        {
            i++;
        }

        public int Val
        {
            get
            {
                return i;
            }
        }
    }

    public struct ValueTypeCounter
    {
        public int i;

        public ValueTypeCounter(int v)
        {
            i = v;
        }

        public void Inc()
        {
            i++;
        }

        public int Val
        {
            get
            {
                return i;
            }
        }

        public override string ToString()
        {
            return "ValueTypeCounter { " + i + " }";
        }

        public int CompareTo(object o)
        {
            if (!(o is ValueTypeCounter))
            {
                throw new ArgumentException();
            }

            int v = ((ValueTypeCounter)o).i;
            if (i > v)
            {
                return 1;
            }
            if (i < v)
            {
                return -1;
            }
            return 0;
        }
    }

    public struct W1
    {
        public ValueTypeCounter F;
    }

    public struct W2
    {
        public W1 F;
    }

    public struct W3
    {
        public W2 F;
    }

    public class ValueTypeCounterContainer
    {
        public ValueTypeCounter c;

        public void Init(int a)
        {
            c = new ValueTypeCounter();
            c.i = a;
        }
    }

    public class GenericClass<T>
    {
        public string F<T1, T2>(T1 a)
        {
            return "1";
        }

        public string F<T1, T2>(T1 a, T b)
        {
            return "2";
        }

        public string F<T>(T a)
        {
            return "3";
        }

        public string F<T1>(T a)
        {
            return "4";
        }

        public string F<T1>(List<T1> a)
        {
            return "5";
        }

        public string F(List<T> a)
        {
            return "6";
        }

        //TODO: 泛型+引用及数组

        //TODO: 泛型实参同时含函数泛型参数及类泛型参数

        //TODO: 由于目前泛型函数不解析执行，所以泛型实参在泛型函数间传递不用考虑，但后续如果要支持泛型函数的解析执行的话，要加入这点的考虑

        //public void F<T4>(List<T4> a)
        //{
        //
        //}

        public string F(T a)
        {
            return "7";
        }

        public string F()
        {
            return "8";
        }

        public class InnerClass
        {
            public string F(T a)
            {
                return "9";
            }
        }

        public string F(T[] a)
        {
            return "0";
        }

        public string F<T1>(T1[] a)
        {
            return "a";
        }

        public string F(T[,] a)
        {
            return "b";
        }

        public string F<T1>(T1[,] a)
        {
            return "c";
        }

        public string F(ref T a)
        {
            return "d";
        }

        public string F<T1>(ref T1 a)
        {
            return "e";
        }

        public string F(ref T[] a)
        {
            return "f";
        }

        public string F<T1>(ref T1[] a)
        {
            return "g";
        }
    }

    public class AnonymousClass
    {
        public void Repeat(Action action, int n)
        {
            for (int i = 0; i < n; i++)
            {
                action();
            }
        }

        protected int f = 0;

        static int sf = 0;

        public void CallRepeat(int n, out int local, out int field, out int staticField)
        {
            int i = 0;
            Repeat(() =>
            {
                i++;
                f++;
                sf++;
            }, n);
            local = i;
            field = f;
            staticField = sf;
        }

        void fadd2()
        {
            f += 2;
            sf += 2;
        }

        public void CallRepeat(int n, out int field, out int staticField)
        {
            Repeat(fadd2, n);
            field = f;
            staticField = sf;
        }

        public void Lessthan(List<int> list, int upper)
        {
            list.RemoveAll(x => x > upper);
        }

        public void Lessthan5(List<int> list)
        {
            list.RemoveAll(x => x > 5);
        }

        public void LessthanField(List<int> list)
        {
            list.RemoveAll(x => x > f);
        }

        public virtual void FAdd()
        {
            f += 3;
        }

        public void CallRepeat(int n, out int field)
        {
            Repeat(FAdd, n);
            field = f;
        }

        //public Expression<Func<int, bool>> GenExpression()
        //{
        //    Expression<Func<int, bool>> exprTree = num => num < 5;
        //    return exprTree;
        //}

        public System.Collections.IEnumerator Generator()
        {
            yield return 1;
            for (int i = 1; i < 10; i++)
            {
                yield return i;
            }
            yield return f;
        }

        public IEnumerator<int> Generator(int n)
        {
            yield return 1;
            for (int i = 1; i < n; i++)
            {
                yield return i;
            }
            yield return f;
        }

        public System.Collections.IEnumerable GetEnumerable()
        {
            yield return 1;
            for (int i = 1; i < 10; i++)
            {
                yield return i;
            }
            yield return f;
        }
    }

    public class BaseClass
    {
        public virtual int Foo()
        {
            Console.WriteLine("BaseClass.Foo");
            return 0;
        }
    }

    public interface ItfWithRefParam
    {
        int WithRefParam(ref int a, out int b);
    }

    public class DrivenClass : BaseClass, ItfWithRefParam
    {
        public override int Foo()
        {
            Console.WriteLine("DrivenClass.Foo");
            return 1;
        }

        public int WithRefParam(ref int a, out int b)
        {
            a *= 2;
            b = a + 1;
            return a;
        }
    }

    public interface Calc
    {
        int Add(int a, int b);
        int Scale { get; set; }
    }

    public class SimpleCalc : Calc
    {
        public SimpleCalc()
        {
            Scale = 1;
        }

        public int Add(int a, int b)
        {
            return (a + b) * Scale;
        }

        public int Scale { get; set; }
    }

    public static class BaseTest
    {
        static int add(int a, int b)
        {
            return a + b;
        }

        public static long Base(int loop)
        {
            //System.Console.WriteLine(loop);
            long sum = 0;
            for (int i = 0; i < 3; i++)
            {
                sum += add(i, i + 1);
                switch(loop)
                {
                    case 0:
                        sum += 1;
                        break;
                    case 1:
                        sum += 2;
                        break;
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    //case 7:
                        sum -= 1;
                        break;
                    default:
                        sum -= 2;
                        break;
                }
            }
            return sum;
        }

        public static long Ref(ref int a, int b, ref long c, long d, out int e)
        {
            a += b;
            c += d;
            e = a + b;
            return a + b + c + d + e;
        }

        static void Swap(ref object l, ref object r)
        {
            object t = l;
            l = r;
            r = t;
        }

        public static void Ref(ref object l, ref object r)
        {
            Swap(ref l, ref r);
        }

        public static void Ref(ref ValueTypeCounter l, ref ValueTypeCounter r)
        {
            ValueTypeCounter t = l;
            l = r;
            r = t;
        }

        //1、leave的目标不一定紧跟finally block，可以是任何地方
        //2、leave要找到最内层的finally跳转
        //3、endfinally有两种情况，如果是leave跳过来，则跳到leave的目标，如果不是，则重新抛异常
        //4、为了减少注入代码注入侧不try-catch，由解析器清栈，包括引用参数，所以要传入引用参数的个数
        //5、正常leave不应该有查找finally的操作，否则非常慢
        //6、一个finally block里头的leave指令，可以有不同的目标地址，比如：try{}catch{goto}
        //7、leave如果在一个finally block内，而目标地址在finally的try block之外，那么这个finally block在跳转前执行，
        //   如果有多个这样的finally，则从内到外执行（抛异常其实也可以理解为跳出了finally）
        public static void ExceptionBase(ref int p)
        {
            while (p != 100)
            {
                try
                {
                    //Console.WriteLine("in while");
                    if (p < 0)
                    {
                        throw new ArgumentException();
                    }
                    else
                    {
                        p--;
                        break;
                    }
                }
                finally
                {
                    p--;
                }
            }
            try
            {
                try
                {
                    if (p < 0)
                    {
                        throw new InvalidOperationException();
                    }
                    p++;
                }
                finally
                {
                    p += 2;
                }
            }
            finally
            {
                p += 2;
            }
        }

        public static void Rethrow()
        {
            try
            {
                throw new InvalidOperationException();
            }
            catch(InvalidOperationException e)
            {
                throw;
            }
        }

        public static void LeavePoint(int p, ref int n1, ref int f1, ref int f2)
        {
            L1:
            if (p == -1)
            {
                goto L3;
            }
            try
            {
                try
                {
                    if (p == 0)
                    {
                        p = -1;
                        goto L1;
                    }
                    else if(p == 1)
                    {
                        goto L2;
                    }
                    else if (p == 2)
                    {
                        goto L3;
                    }
                }
                finally
                {
                    f1++;
                }
                L2:
                n1++;
            }
            finally
            {
                f2++;
            }
            L3:
            return;
        }

        public static void TryCatchFinally(bool bThrow, ref bool t, ref bool c, ref bool f, ref bool e)
        {
            try
            {
                if (bThrow)
                {
                    throw new Exception();
                }
                Console.WriteLine("t");
                t = true;
            }
            catch
            {
                Console.WriteLine("c");
                c = true;
            }
            finally
            {
                Console.WriteLine("f");
                f = true;
            }
            Console.WriteLine("e");
            e = true;
        }

        public static void CatchByNextLevel(out bool f1, out bool f2, out bool f3)
        {
            f1 = f2 = f3 = false;
            try
            {
                try
                {
                    throw new Exception();
                }
                finally
                {
                    f1 = true;
                }
            }
            catch
            {
                f2 = true;
            }
            finally
            {
                f3 = true;
            }
        }

        static void CallInc(ValueTypeCounter counter)
        {
            counter.Inc();
        }

        static void CallInc(RefTypeCounter counter)
        {
            counter.Inc();
        }

        public static void PassByValue(ref ValueTypeCounter c1, RefTypeCounter c2)
        {
            c1.Inc();
            c2.Inc();
            CallInc(c1);
            CallInc(c2);
        }

        public static void VirtualFunc(out int r1, out int r2)
        {
            BaseClass o1 = new BaseClass();
            BaseClass o2 = new DrivenClass();
            r1 = o1.Foo();
            r2 = o2.Foo();
        }

        public static int InterfaceTest(int a, int b, int scale)
        {
            Calc calc = new SimpleCalc();
            calc.Scale = scale;
            return calc.Add(a, b);
        }

        public static int ItfWithRefParam(ref int a, out int b)
        {
            ItfWithRefParam o = new DrivenClass();
            return o.WithRefParam(ref a, out b);
        }

        public static string VirtualFuncOfStruct(ValueTypeCounter vtc)
        {
            return vtc.ToString() + ",hashcode:" + vtc.GetHashCode();
        }

        public static Type GetIntType()
        {
            return typeof(int);
        }

        public static string GenericOverload()
        {
            GenericClass<int> a = new GenericClass<int>();
            System.Text.StringBuilder sb = new System.Text.StringBuilder();
            sb.Append(a.F());
            sb.Append(a.F(1));
            sb.Append(a.F<float>(1));
            sb.Append(a.F<float>(new List<float>()));
            sb.Append(a.F<int, double>(1));
            sb.Append(a.F(new List<int>()));
            sb.Append(a.F<int, double>(1, 1));
            GenericClass<int>.InnerClass b = new GenericClass<int>.InnerClass();
            sb.Append(b.F(1));
            sb.Append(a.F<byte>((byte)1));
            int[] p1 = null;
            sb.Append(a.F(p1));
            float[] p2 = null;
            sb.Append(a.F(p2));
            int[,] p3 = null;
            sb.Append(a.F(p3));
            float[,] p4 = null;
            sb.Append(a.F(p4));
            int p5 = 1;
            byte p6 = 1;
            sb.Append(a.F(ref p5));
            sb.Append(a.F(ref p6));
            sb.Append(a.F(ref p1));
            sb.Append(a.F(ref p2));
            return sb.ToString();
        }

        public static int SField = 1;

        public static int StaticFieldBase()
        {
            return SField++;
        }

        public static byte[] Conv_Ovf_I(long l)
        {
            return new byte[l];
        }

        public static int Conv_I4(float i)
        {
            return (int)i;
        }

        public static int Conv_I4(double i)
        {
            return (int)i;
        }

        public static int Conv_I4(long i)
        {
            return (int)i;
        }

        public static int Conv_Ovf_I4_Un(uint i)
        {
            return checked((int)i);
        }

        public static int Conv_Ovf_I4(long i)
        {
            return checked((int)i);
        }

        public static int Ldlen(int[] arr)
        {
            return arr.Length;
        }

        public static int[] Newarr(int len)
        {
            return new int[len];
        }

        public static RefTypeCounter Castclass(object o)
        {
            return (RefTypeCounter)o;
        }

        public static RefTypeCounter Isinst(object o)
        {
            return o as RefTypeCounter;
        }

        public static object ArrayGet(object[] arr, int idx)
        {
            return arr[idx];
        }

        public static void ArraySet(object[] arr, int idx, object val)
        {
            arr[idx] = val;
        }

        public static void ArraySet(object[] arr, int idx)
        {
            arr[idx] = 1;
        }

        public static bool ArrayGet(bool[] arr, int idx)
        {
            return arr[idx];
        }

        public static void ArraySet(bool[] arr, int idx, bool val)
        {
            arr[idx] = val;
        }

        public static byte ArrayGet(byte[] arr, int idx)
        {
            return arr[idx];
        }

        public static void ArraySet(byte[] arr, int idx, byte val)
        {
            arr[idx] = val;
        }

        public static sbyte ArrayGet(sbyte[] arr, int idx)
        {
            return arr[idx];
        }

        public static void ArraySet(sbyte[] arr, int idx, sbyte val)
        {
            arr[idx] = val;
        }

        public static int ArrayGet(int[] arr, int idx)
        {
            return arr[idx];
        }

        public static void ArraySet(int[] arr, int idx, int val)
        {
            arr[idx] = val;
        }

        public static uint ArrayGet(uint[] arr, int idx)
        {
            return arr[idx];
        }

        public static void ArraySet(uint[] arr, int idx, uint val)
        {
            arr[idx] = val;
        }

        public static float ArrayGet(float[] arr, int idx)
        {
            return arr[idx];
        }

        public static void ArraySet(float[] arr, int idx, float val)
        {
            arr[idx] = val;
        }

        public static double ArrayGet(double[] arr, int idx)
        {
            return arr[idx];
        }

        public static void ArraySet(double[] arr, int idx, double val)
        {
            arr[idx] = val;
        }

        public static char ArrayGet(char[] arr, int idx)
        {
            return arr[idx];
        }

        public static void ArraySet(char[] arr, int idx, char val)
        {
            arr[idx] = val;
        }

        public static short ArrayGet(short[] arr, int idx)
        {
            return arr[idx];
        }

        public static void ArraySet(short[] arr, int idx, short val)
        {
            arr[idx] = val;
        }

        public static ushort ArrayGet(ushort[] arr, int idx)
        {
            return arr[idx];
        }

        public static void ArraySet(ushort[] arr, int idx, ushort val)
        {
            arr[idx] = val;
        }

        public static IntPtr ArrayGet(IntPtr[] arr, int idx)
        {
            return arr[idx];
        }

        public static void ArraySet(IntPtr[] arr, int idx, IntPtr val)
        {
            arr[idx] = val;
        }

        public static UIntPtr ArrayGet(UIntPtr[] arr, int idx)
        {
            return arr[idx];
        }

        public static void ArraySet(UIntPtr[] arr, int idx, UIntPtr val)
        {
            arr[idx] = val;
        }

        public static int ArrayGet(int[] arr, uint idx)
        {
            return arr[idx];
        }

        public static void ArraySet(int[] arr, uint idx, int val)
        {
            arr[idx] = val;
        }

        public static int And(int a, int b)
        {
            return a & b;
        }

        public static long And(long a, long b)
        {
            return a & b;
        }

        public static int Or(int a, int b)
        {
            return a | b;
        }

        public static long Or(long a, long b)
        {
            return a | b;
        }

        static void intref(ref int a)
        {
            a += 10;
        }

        public static int Ldflda(ref ValueTypeCounter c)
        {
            intref(ref c.i);
            return c.i;
        }

        public static int Ldflda(ref ValueTypeCounterContainer cc)
        {
            return Ldflda(ref cc.c);
        }

        public static int Ldflda(ref W1 p)
        {
            return Ldflda(ref p.F);
        }

        public static int Ldflda(ref W2 p)
        {
            return Ldflda(ref p.F);
        }

        public static int Ldflda(ref W3 p)
        {
            return Ldflda(ref p.F);
        }

        public static int Ldflda_m(ref W3 p)
        {
            return p.F.F.F.i;
        }

        public static bool Ceq(int a, int b)
        {
            return a == b;
        }

        public static bool Ceq(double a, double b)
        {
            return a == b;
        }

        public static int Shl(int a, int bits)
        {
            return a << bits;
        }

        public static long Shl(long a, int bits)
        {
            return a << bits;
        }

        public static int Shr(int a, int bits)
        {
            return a >> bits;
        }

        public static long Shr(long a, int bits)
        {
            return a >> bits;
        }

        public static uint Shr_Un(uint a, int bits)
        {
            return a >> bits;
        }

        public static ulong Shr_Un(ulong a, int bits)
        {
            return a >> bits;
        }

        public static byte Conv_U1(int a)
        {
            return (byte)a;
        }

        public static byte Conv_Ovf_U1(int a)
        {
            return checked((byte)a);
        }

        public static byte Conv_Ovf_U1_Un(uint a)
        {
            return checked((byte)a);
        }

        public static void Ldelema(int[] arr, int idx)
        {
            intref(ref arr[idx]);
        }

        public static int Bgt(int a, int b)
        {
            if (a > b)
            {
                goto R1;
            }
            else if (a < b)
            {
                goto RM1;
            }
            else
            {
                goto R0;
            }
            R1:
            return 1;
            RM1:
            return -1;
            R0:
            return 0;
        }

        public static int Initobj(int a)
        {
            ValueTypeCounter c1 = new ValueTypeCounter();
            c1.Inc();
            ValueTypeCounter c2 = new ValueTypeCounter(a);
            ValueTypeCounterContainer cc = new ValueTypeCounterContainer();
            cc.Init(a);
            return c1.Val + c2.Val + cc.c.Val;
        }

        public static int si = 0;

        public static int Ldsflda()
        {
            intref(ref si);
            return si;
        }

        public static int Div(int a, int b)
        {
            return a / b;
        }

        public static float Div(float a, float b)
        {
            return a / b;
        }

        public static double Div(double a, double b)
        {
            return a / b;
        }

        public static long Div(long a, long b)
        {
            return a / b;
        }

        public static bool Cgt_Un(uint a, uint b)
        {
            return a > b;
        }

        public static bool NaNFloat(int op, float a, float b)
        {
            switch(op)
            {
                case 0:
                    return a < b;//clt
                case 1:
                    return a > b;//cgt
                case 2:
                    return a <= b;//cgt.un + ceq 0
                case 3:
                    return a >= b;//clt.un + ceq 0
                //case 5:
                //    return a == b;//ceq
                //case 6:
                //    return a != b;//ceq + ceq
            }
            throw new ArgumentException();
        }

        public static int Rem(int a, int b)
        {
            return a % b;
        }

        public static float Rem(float a, float b)
        {
            return a % b;
        }

        public static uint Rem(uint a, uint b)
        {
            return a % b;
        }

        public static double Ldc_R8()
        {
            return 3.1415;
        }

        public static double Ldc_I8()
        {
            return 9223372036854775808;
        }

        public static ulong Conv_U8(float a)
        {
            return (ulong)a;
        }

        public static long Conv_I8(float a)
        {
            return (long)a;
        }

        public static ulong Conv_Ovf_U8(long a)
        {
            return checked((ulong)a);
        }
        public static ulong Conv_Ovf_U8(float a)
        {
            return checked((ulong)a);
        }

        public static long Conv_Ovf_I8(ulong a)
        {
            return checked((long)a);
        }
        public static long Conv_Ovf_I8(float a)
        {
            return checked((long)a);
        }
        public static int Xor(int a, int b)
        {
            return a ^ b;
        }
        public static long Xor(long a, long b)
        {
            return a ^ b;
        }

        public static double Conv_R_Un(uint a)
        {
            return a;
        }

        public static float Conv_R_Un(ulong a)
        {
            return a;
        }

        public static int Mul_Ovf(int a, int b)
        {
            return checked(a * b);
        }

        public static uint Mul_Ovf_Un(uint a, uint b)
        {
            return checked(a * b);
        }

        public static int Add_Ovf(int a, int b)
        {
            return checked(a + b);
        }

        public static uint Add_Ovf_Un(uint a, uint b)
        {
            return checked(a + b);
        }

        public static uint Div_Un(uint a, uint b)
        {
            return a / b;
        }

        public static int Neg(int a)
        {
            return -a;
        }

        public static long Neg(long a)
        {
            return -a;
        }

        public static float Neg(float a)
        {
            return -a;
        }

        public static double Neg(double a)
        {
            return -a;
        }

        public static int Not(int a)
        {
            return ~a;
        }

        public static long Not(long a)
        {
            return ~a;
        }

        public static int Blt_Un(float a, float b)
        {
            if (a >= b)
            {
                return 11;
            }
            else
            {
                return 22;
            }
        }

        public static int Bgt_Un(float a, float b)
        {
            if (a <= b)
            {
                return 11;
            }
            else
            {
                return 22;
            }
        }

        /*public interface Itf
        {
            void Foo();
        }

        public struct MyStrunct : Itf
        {
            public int A;

            public void Foo()
            {
                Console.WriteLine("MyStrunct.Foo:" + A--);
            }

            public override string ToString() { return ""; }
        }

        class MyClass : Itf
        {
            public void Foo()
            {
                Console.WriteLine("MyClass.Foo");
            }
        }

        static void CallFoo(Itf itf)
        {
            itf.Foo();
        }

        public static void ConstrainedInstruction(bool a, int b)
        {
            MyClass e = new MyClass();
            e.ToString();
            DateTime dt = new DateTime();
            dt.ToString();
            MyStrunct ms = new MyStrunct() { A = 10 };
            ms.ToString();
            Console.WriteLine("a:" + a);
            Console.WriteLine("b:" + b);
            a.ToString();
            b.ToString();
            object[] args = new object[0];
            var m = typeof(Itf).GetMethod("Foo");
            m.Invoke(e, args);

            ms.Foo();
            Console.WriteLine("ms.A:" + ms.A);
            m.Invoke(ms, args);
            Console.WriteLine("ms.A:" + ms.A);
            CallFoo(ms);
            Console.WriteLine("ms.A:" + ms.A);

            object o = ms;
            Console.WriteLine("before o.A:" + ((MyStrunct)o).A);
            m.Invoke(o, args);
            Console.WriteLine("after o.A:" + ((MyStrunct)o).A);

            Itf itf = ms;
            itf.Foo();
        }*/

        /*public static void ExceptionBase(int p)
        {
            BEGIN:

            try
            {
                try
                {
                    if (p > 5)
                    {
                        Console.WriteLine("p=" + p);
                        p--;
                        throw new InvalidOperationException();
                    }
                    Console.WriteLine("leave1...");
                }
                catch (InvalidOperationException)
                {
                    goto BEGIN;
                }
                catch (InvalidProgramException)
                {

                }
                finally
                {
                    Console.WriteLine("finally1");
                    p--;
                }
                Console.WriteLine("leave2...");
            }
            finally
            {
                Console.WriteLine("finally2");
            }
        }*/

        /*public static void ExceptionBase(int p)
        {
            try
            {
                if (p == 1)
                {
                    throw new InvalidCastException();
                }
                else if (p == 2)
                {
                    throw new InvalidOperationException();
                }
                else if (p == 3)
                {
                    throw new InvalidProgramException();
                }
                else
                {
                    throw new Exception();
                }
            }
            catch(InvalidCastException e)
            {
                Console.WriteLine(e.StackTrace);
            }
            catch(InvalidOperationException e)
            {
                Console.WriteLine(e.StackTrace);
            }
            catch(InvalidProgramException e)
            {

            }
            finally
            {
                Console.WriteLine(1);
            }
        }*/
    }
}
```

`Source/VSProj/Src/Tools/CSFix.cs`:

```cs
/*
 * Tencent is pleased to support the open source community by making InjectFix available.
 * Copyright (C) 2019 Tencent.  All rights reserved.
 * InjectFix is licensed under the MIT License, except for the third-party components listed in the file 'LICENSE' which may be subject to their corresponding license terms. 
 * This file is subject to the terms and conditions defined in file 'LICENSE', which is part of this source code package.
 */

using System;
using System.IO;
using Mono.Cecil;
using System.Linq;

namespace IFix
{
    public static class Program
    {
        static void usage()
        {
            Console.WriteLine("Usage:");
            Console.WriteLine("IFix -inject core_assmbly_path assmbly_path config_path patch_file_output_path"
                + " injected_assmbly_output_path [search_path1, search_path2 ...]");
            Console.WriteLine("IFix -inherit_inject core_assmbly_path assmbly_path config_path "
                + "patch_file_output_path injected_assmbly_output_path inherit_assmbly_path "
                + "[search_path1, search_path2 ...]");
            Console.WriteLine("IFix -patch core_assmbly_path assmbly_path injected_assmbly_path"
                + " config_path patch_file_output_path [search_path1, search_path2 ...]");
        }

        static bool argsValid(string[] args)
        {
            return (args.Length >= 6 && args[0] == "-inject") || (args.Length >= 6 && args[0] == "-patch")
                || (args.Length >= 7 && args[0] == "-inherit_inject");
        }

        // #lizard forgives
        static void Main(string[] args)
        {
            if (!argsValid(args))
            {
                usage();
                return;
            }
            ProcessMode mode = args[0] == "-patch" ?  ProcessMode.Patch : ProcessMode.Inject;

            CodeTranslator tranlater = new CodeTranslator();
            AssemblyDefinition assembly = null;
            AssemblyDefinition ilfixAassembly = null;
            AssemblyDefinition oldAssembly = null;
            string dllName = null;
            try
            {
                var assmeblyPath = args[2];
                bool readSymbols = true;
                try
                {
                    //尝试读取符号
                    assembly = AssemblyDefinition.ReadAssembly(assmeblyPath,
                        new ReaderParameters { ReadSymbols = true });
                }
                catch
                {
                    //如果读取不到符号则不读
                    Console.WriteLine("Warning: read " + assmeblyPath + " with symbol fail");
                    //写入的时候用这个标志
                    readSymbols = false;
                    assembly = AssemblyDefinition.ReadAssembly(assmeblyPath,
                        new ReaderParameters { ReadSymbols = false });
                }

                var resolver = assembly.MainModule.AssemblyResolver as BaseAssemblyResolver;
                bool isInheritInject = args[0] == "-inherit_inject";
                int searchPathStart = isInheritInject ? 7 : 6;

                //往resolver加入程序集搜索路径
                foreach (var path in args.Skip(searchPathStart))
                {
                    try
                    {
                        //Console.WriteLine("searchPath:" + path);
                        resolver.AddSearchDirectory(path);
                    } catch { }
                }

                ilfixAassembly = AssemblyDefinition.ReadAssembly(args[1]);
                dllName = Path.GetFileName(args[2]);
                GenerateConfigure configure = null;

                if (mode == ProcessMode.Inject)
                {
                    //对测试用例特殊处理：测试用例默认全解析执行
                    configure = args[3] == "no_cfg" ?
                        GenerateConfigure.Empty() : GenerateConfigure.FromFile(args[3]);

                    if (isInheritInject)
                    {
                        throw new Exception("Do Not Support already!");
                    }

                    //注入逻辑
                    //TODO: tranlater的名字不太合适
                    if (tranlater.Process(assembly, ilfixAassembly, configure, mode)
                        == CodeTranslator.ProcessResult.Processed)
                    {
                        Console.WriteLine(dllName + " process yet!");
                        return;
                    }

                    tranlater.Serialize(args[4]);

                    assembly.Write(args[5], new WriterParameters { WriteSymbols = readSymbols });
                    //ilfixAassembly.Write(args[2], new WriterParameters { WriteSymbols = true });
                }
                else
                {
                    //补丁生成流程
                    configure = new PatchGenerateConfigure(assembly, args[4]);

                    if (tranlater.Process(assembly, ilfixAassembly, configure, mode)
                        == CodeTranslator.ProcessResult.Processed)
                    {
                        //发现程序集已经被注入，主要是防止已经注入的函数包含的注入逻辑会导致死循环
                        Console.WriteLine("Error: the new assembly must not be inject, please reimport the project!");
                        return;
                    }

                    tranlater.Serialize(args[5]);
                    Console.WriteLine("output: " + args[5]);
                }
            }
            catch(Exception e)
            {
                Console.WriteLine("Unhandled Exception:\r\n" + e);
                return;
            }
            finally
            {
                //清理符号读取器
                //如果不清理，在window下会锁定文件
                if (assembly != null && assembly.MainModule.SymbolReader != null)
                {
                    assembly.MainModule.SymbolReader.Dispose();
                }

                if (ilfixAassembly != null && ilfixAassembly.MainModule.SymbolReader != null)
                {
                    ilfixAassembly.MainModule.SymbolReader.Dispose();
                }

                if (oldAssembly != null && oldAssembly.MainModule.SymbolReader != null)
                {
                    oldAssembly.MainModule.SymbolReader.Dispose();
                }
            }
            Console.WriteLine(dllName + " process success");
        }
    }
}
```

`Source/VSProj/Src/Tools/CecilExtensions.cs`:

```cs
/*
 * Tencent is pleased to support the open source community by making InjectFix available.
 * Copyright (C) 2019 Tencent.  All rights reserved.
 * InjectFix is licensed under the MIT License, except for the third-party components listed in the file 'LICENSE' which may be subject to their corresponding license terms. 
 * This file is subject to the terms and conditions defined in file 'LICENSE', which is part of this source code package.
 */

using Mono.Cecil;
using System.Reflection;
using System.Text;
using System;
using Mono.Cecil.Cil;
using System.Collections.Generic;
using System.Linq;

namespace IFix
{
    static internal class CecilExtensions
    {
        /// <summary>
        /// 以contextType为上下文，查找泛型参数对应的实参
        /// </summary>
        /// <param name="gp">泛型参数</param>
        /// <param name="contextType">上下文类型</param>
        /// <returns></returns>
        public static TypeReference ResolveGenericArgument(this GenericParameter gp, TypeReference contextType)
        {
            if (contextType.IsGenericInstance)
            {
                var genericIns = ((GenericInstanceType)contextType);
                var genericTypeRef = genericIns.ElementType;
                var genericTypeDef = genericTypeRef.Resolve();
                for (int i = 0; i < genericTypeRef.GenericParameters.Count; i++)
                {
                    if (genericTypeRef.GenericParameters[i] == gp)
                    {
                        return genericIns.GenericArguments[i];
                    }
                    if (genericTypeDef != null && genericTypeDef.GenericParameters[i] == gp)
                    {
                        return genericIns.GenericArguments[i];
                    }
                }
            }

            if (contextType.IsNested)
            {
                return gp.ResolveGenericArgument(contextType.DeclaringType);
            }
            else
            {
                return null;
            }
        }

        /// <summary>
        /// 以contextMethod为上下文，查找泛型参数对应的实参
        /// </summary>
        /// <param name="gp">泛型参数</param>
        /// <param name="contextMethod">上下文函数</param>
        /// <returns></returns>
        public static TypeReference ResolveGenericArgument(this GenericParameter gp, MethodReference contextMethod)
        {
            if (contextMethod.IsGenericInstance)
            {
                var genericIns = contextMethod as GenericInstanceMethod;
                return genericIns.GenericArguments[gp.Position];
            }
            return null;
        }

        /// <summary>
        /// 填充泛型参数，如果直接TypeReference取FullName的话，泛型参数（比如名字为T）不会实例化（仍然为T），
        /// 这样在补丁查找泛型方法时会有问题
        /// </summary>
        /// <param name="type"></param>
        /// <param name="contextMethod"></param>
        /// <param name="contextType"></param>
        /// <returns></returns>
        public static TypeReference FillGenericArgument(this TypeReference type, MethodReference contextMethod,
            TypeReference contextType)
        {
            if (type.IsGenericParameter)
            {
                var gp = type as GenericParameter;
                if (gp.Type == GenericParameterType.Type)
                {
                    return gp.ResolveGenericArgument(contextType);
                }
                else
                {
                    return gp.ResolveGenericArgument(contextMethod);
                }
            }
            else if (type.IsGenericInstance && type.IsGeneric())
            {
                var genericIns = ((GenericInstanceType)type);
                var module = contextType == null ? contextMethod.Module : contextType.Module;
                var newGenericIns = new GenericInstanceType(TryImport(type.Resolve(), module));
                foreach (var arg in genericIns.GenericArguments)
                {
                    newGenericIns.GenericArguments.Add(arg.FillGenericArgument(contextMethod, contextType));
                }
                return newGenericIns;
            }
            else
            {
                return type;
            }
        }

        static void getFullNameWithoutGenericParameter(TypeReference typeReference, StringBuilder sb)
        {
            if (typeReference.IsNested)
            {
                getFullNameWithoutGenericParameter(typeReference.DeclaringType, sb);
                sb.Append("+");
                sb.Append(typeReference.Name);
            }
            else
            {
                if (!string.IsNullOrEmpty(typeReference.Namespace))
                {
                    sb.Append(typeReference.Namespace);
                    sb.Append(".");
                }
                sb.Append(typeReference.Name);
            }
        }

        static string getAssemblyFullName(TypeReference typeReference)
        {
            return (typeReference.Scope is AssemblyNameReference) ? (typeReference.Scope as AssemblyNameReference)
                .FullName : typeReference.Module.Assembly.FullName;
        }

        static string getAssemblyName(TypeReference typeReference)
        {
            return (typeReference.Scope is AssemblyNameReference) ? (typeReference.Scope as AssemblyNameReference)
                .Name : typeReference.Module.Assembly.Name.Name;
        }

        /// <summary>
        /// 忽略程序集版本号来对比两个类型是否指向同样的类型
        /// </summary>
        /// <param name="left">参数1</param>
        /// <param name="right">参数2</param>
        /// <returns></returns>
        public static bool AreEqualIgnoreAssemblyVersion(this TypeReference left, TypeReference right)
        {
            return left.FullName == right.FullName && getAssemblyName(left) == getAssemblyName(right);
        }

        static TypeReference getElementType(TypeReference type, TypeReference contextType)
        {
            if (type.IsByReference)
            {
                return getElementType((type as ByReferenceType).ElementType, contextType);
            }
            if (type.IsArray)
            {
                return getElementType((type as ArrayType).ElementType, contextType);
            }
            if (type.IsGenericParameter)
            {
                return (type as GenericParameter).ResolveGenericArgument(contextType);
            }
            else
            {
                return type;
            }
        }

        /// <summary>
        /// 获取一个类型的AssemblyQualifiedName
        /// </summary>
        /// <param name="typeReference">要获取AssemblyQualifiedName的type</param>
        /// <param name="contextType">上下文类型，往往是其外层类</param>
        /// <param name="skipAssemblyQualified">忽略程序集名</param>
        /// <param name="skipAssemblyQualifiedOnce">用于泛型类型的递归时，忽略程序集，因为泛型类型是填写完泛型参数后，再填写程序集</param>
        /// <returns></returns>
        public static string GetAssemblyQualifiedName(this TypeReference typeReference,
            TypeReference contextType = null, bool skipAssemblyQualified = false,
            bool skipAssemblyQualifiedOnce = false)
        {
            if (typeReference.IsGenericParameter)
            {
                if ((typeReference as GenericParameter).Type == GenericParameterType.Method)
                {
                    return typeReference.Name;
                }
                else
                {
                    if (contextType == null)
                    {
                        throw new System.ArgumentException("no context type for " + typeReference);
                    }
                    return (typeReference as GenericParameter).ResolveGenericArgument(contextType)
                        .GetAssemblyQualifiedName(contextType, skipAssemblyQualified, skipAssemblyQualifiedOnce);
                }
            }

            TypeReference assemblyType = getElementType(typeReference, contextType);
            if (assemblyType == null)
            {
                assemblyType = typeReference;
            }

            StringBuilder sb = new StringBuilder();
            if (typeReference.IsArray)
            {
                var arrayType = typeReference as ArrayType;
                sb.Append(arrayType.ElementType.GetAssemblyQualifiedName(contextType, skipAssemblyQualified, true));
                sb.Append('[');
                sb.Append(',', arrayType.Rank - 1);
                sb.Append(']');
            }
            else if (typeReference.IsByReference)
            {
                var refType = typeReference as ByReferenceType;
                sb.Append(refType.ElementType.GetAssemblyQualifiedName(contextType, skipAssemblyQualified, true));
                sb.Append('&');
            }
            else
            {
                getFullNameWithoutGenericParameter(typeReference, sb);

                if (typeReference.IsGenericInstance)
                {
                    bool isFirst = true;
                    var genericInstance = ((GenericInstanceType)typeReference);
                    sb.Append("[");
                    for (int i = 0; i < genericInstance.GenericArguments.Count; i++)
                    {
                        var genericArg = genericInstance.GenericArguments[i];
                        if (!isFirst)
                        {
                            sb.Append(",");
                        }
                        else
                        {
                            isFirst = false;
                        }
                        var strGenericArg = genericArg.GetAssemblyQualifiedName(contextType, skipAssemblyQualified);

                        if (skipAssemblyQualified || (genericArg.IsGenericParameter
                            && (genericArg as GenericParameter).Type == GenericParameterType.Method))
                        {
                            sb.Append(strGenericArg);
                        }
                        else
                        {
                            sb.Append(string.Format("[{0}]", strGenericArg));
                        }
                    }
                    sb.Append("]");
                }
            }
            return (skipAssemblyQualified | skipAssemblyQualifiedOnce) ?
                sb.ToString() : Assembly.CreateQualifiedName(getAssemblyFullName(assemblyType), sb.ToString());
        }

        /// <summary>
        /// 判断一个类型是否是delegate
        /// </summary>
        /// <param name="typeDefinition">要判断的类型</param>
        /// <returns></returns>
        public static bool IsDelegate(this TypeDefinition typeDefinition)
        {
            if (typeDefinition.BaseType == null)
            {
                return false;
            }
            return typeDefinition.BaseType.FullName == "System.MulticastDelegate";
        }

        /// <summary>
        /// 判断一个类型是不是泛型
        /// </summary>
        /// <param name="type">要判断的类型</param>
        /// <returns></returns>
        public static bool IsGeneric(this TypeReference type)
        {
            if (type.HasGenericParameters || type.IsGenericParameter)
            {
                return true;
            }
            if (type.IsByReference)
            {
                return ((ByReferenceType)type).ElementType.IsGeneric();
            }
            if (type.IsArray)
            {
                return ((ArrayType)type).ElementType.IsGeneric();
            }
            if (type.IsGenericInstance)
            {
                foreach (var typeArg in ((GenericInstanceType)type).GenericArguments)
                {
                    if (typeArg.IsGeneric())
                    {
                        return true;
                    }
                }
            }
            return false;
        }

        /// <summary>
        /// 判断一个类型的泛型实参是否有来自函数的泛型实参
        /// </summary>
        /// <param name="type">要判断的类型</param>
        /// <returns></returns>
        public static bool HasGenericArgumentFromMethod(this TypeReference type)
        {
            if (type.IsGenericParameter)
            {
                return (type as GenericParameter).Type == GenericParameterType.Method;
            }

            if (type.IsByReference)
            {
                return ((ByReferenceType)type).ElementType.HasGenericArgumentFromMethod();
            }
            if (type.IsArray)
            {
                return ((ArrayType)type).ElementType.HasGenericArgumentFromMethod();
            }
            if (type.IsGenericInstance)
            {
                foreach (var typeArg in ((GenericInstanceType)type).GenericArguments)
                {
                    if (typeArg.HasGenericArgumentFromMethod())
                    {
                        return true;
                    }
                }
            }
            return false;
        }

        /// <summary>
        /// 判断一个方法是不是泛型
        /// </summary>
        /// <param name="method">要判断的方法</param>
        /// <returns></returns>
        public static bool IsGeneric(this MethodReference method)
        {
            if (method.HasGenericParameters) return true;
            //if (method.ReturnType.IsGeneric()) return true;
            //foreach (var paramInfo in method.Parameters)
            //{
            //    if (paramInfo.ParameterType.IsGeneric()) return true;
            //}
            if (method.IsGenericInstance)
            {
                foreach (var typeArg in ((GenericInstanceMethod)method).GenericArguments)
                {
                    if (typeArg.IsGeneric())
                    {
                        return true;
                    }
                }
            }
            return false;
        }

        /// <summary>
        /// 判断一个字段的类型是不是泛型
        /// </summary>
        /// <param name="field">要判断字段</param>
        /// <returns></returns>
        public static bool IsGeneric(this FieldReference field)
        {
            return field.FieldType.IsGeneric();
        }

        /// <summary>
        /// 判断两个类型是不是同一个
        /// </summary>
        /// <param name="left">类型1</param>
        /// <param name="right">类型2</param>
        /// <returns></returns>
        public static bool IsSameType(this TypeReference left, TypeReference right)
        {
            return left.FullName == right.FullName
                && left.Module.Assembly.FullName == right.Module.Assembly.FullName
                && left.Module.FullyQualifiedName == right.Module.FullyQualifiedName;
        }

        /// <summary>
        /// 判断两个类型的名字是否相同
        /// </summary>
        /// <param name="left">类型1</param>
        /// <param name="right">类型2</param>
        /// <returns></returns>
        public static bool IsSameName(this TypeReference left, TypeReference right)
        {
            return left.FullName == right.FullName;
        }

        /// <summary>
        /// 判断两个方法，如果仅判断其参数类型及返回值类型的名字，是否相等
        /// </summary>
        /// <param name="left">方法1</param>
        /// <param name="right">方法2</param>
        /// <returns></returns>
        public static bool IsTheSame(this MethodReference left, MethodReference right)
        {
            if (left.Parameters.Count != right.Parameters.Count
                        || left.Name != right.Name
                        || !left.ReturnType.IsSameName(right.ReturnType)
                        || !left.DeclaringType.IsSameName(right.DeclaringType)
                        || left.HasThis != right.HasThis
                        || left.GenericParameters.Count != right.GenericParameters.Count)
            {
                return false;
            }

            for (int i = 0; i < left.Parameters.Count; i++)
            {
                if (left.Parameters[i].Attributes != right.Parameters[i].Attributes
                    || !left.Parameters[i].ParameterType.IsSameName(right.Parameters[i].ParameterType))
                {
                    return false;
                }
            }

            for (int i = 0; i < left.GenericParameters.Count; i++)
            {
                if (left.GenericParameters[i].IsSameName(right.GenericParameters[i]))
                {
                    return false;
                }
            }

            return true;
        }

        /// <summary>
        /// 判断一个方法是否是析构函数
        /// </summary>
        /// <param name="method">方法</param>
        /// <returns></returns>
        public static bool IsFinalizer(this MethodDefinition method)
        {
            return method.Name == "Finalize" && method.IsVirtual && method.Parameters.Count == 0
                && method.ReturnType != null && method.ReturnType.FullName == "System.Void";
        }

        /// <summary>
        /// 尝试导入一个类型
        /// </summary>
        /// <param name="toImport">要导入的类型</param>
        /// <param name="module">导入到哪个module</param>
        /// <returns></returns>
        // #lizard forgives
        public static TypeReference TryImport(this TypeReference toImport, ModuleDefinition module)
        {
            if (toImport == null) return null;
            if (toImport.Namespace == "System")
            {
                if (toImport.Name == "Boolean")
                {
                    return module.TypeSystem.Boolean; //用内置类型，否则通过getMap获取不到
                }
                else if (toImport.Name == "Byte")
                {
                    return module.TypeSystem.Byte;
                }
                else if (toImport.Name == "SByte")
                {
                    return module.TypeSystem.SByte;
                }
                else if (toImport.Name == "Int16")
                {
                    return module.TypeSystem.Int16;
                }
                else if (toImport.Name == "Char")
                {
                    return module.TypeSystem.Char;
                }
                else if (toImport.Name == "UInt16")
                {
                    return module.TypeSystem.UInt16;
                }
                else if (toImport.Name == "Int32")
                {
                    return module.TypeSystem.Int32;
                }
                else if (toImport.Name == "UInt32")
                {
                    return module.TypeSystem.UInt32;
                }
                else if (toImport.Name == "Int64")
                {
                    return module.TypeSystem.Int64;
                }
                else if (toImport.Name == "UInt64")
                {
                    return module.TypeSystem.UInt64;
                }
                else if (toImport.Name == "Single")
                {
                    return module.TypeSystem.Single;
                }
                else if (toImport.Name == "Double")
                {
                    return module.TypeSystem.Double;
                }
                else if (toImport.Name == "IntPtr")
                {
                    return module.TypeSystem.IntPtr;
                }
                else if (toImport.Name == "UIntPtr")
                {
                    return module.TypeSystem.UIntPtr;
                }
            }
            if (toImport.IsGenericParameter) return toImport;
            if (toImport.IsGenericInstance)
            {
                var genericIns = toImport as GenericInstanceType;
                var newGenericIns = new GenericInstanceType(TryImport(toImport.Resolve(), module));
                foreach (var ga in genericIns.GenericArguments)
                {
                    newGenericIns.GenericArguments.Add(TryImport(ga, module));
                }
                return newGenericIns;
            }
            if (module.Assembly.FullName == toImport.Module.Assembly.FullName
                && module.FullyQualifiedName == toImport.Module.FullyQualifiedName)
            {
                return toImport;
            }
            else
            {
                return module.ImportReference(toImport);
            }
        }

        /// <summary>
        /// 尝试导入一个方法
        /// </summary>
        /// <param name="toImport"></param>
        /// <param name="module"></param>
        /// <returns></returns>
        public static MethodReference TryImport(this MethodReference toImport, ModuleDefinition module)
        {
            if (toImport == null) return null;
            if (module.Assembly.FullName == toImport.Module.Assembly.FullName
                && module.FullyQualifiedName == toImport.Module.FullyQualifiedName)
            {
                return toImport;
            }
            else
            {
                return module.ImportReference(toImport);
            }
        }

        /// <summary>
        /// 生成一个泛型引用
        /// </summary>
        /// <param name="method"></param>
        /// <param name="declaringType"></param>
        /// <returns></returns>
        public static MethodReference MakeGeneric(this MethodDefinition method, TypeReference declaringType)
        {
            var reference = new MethodReference(method.Name, TryImport(method.ReturnType, declaringType.Module),
                declaringType)
            {
                HasThis = method.HasThis,
                ExplicitThis = method.ExplicitThis,
                CallingConvention = method.CallingConvention
            };
            foreach (var parameter in method.Parameters)
            {
                reference.Parameters.Add(new ParameterDefinition(TryImport(parameter.ParameterType,
                    declaringType.Module)));
            }
            foreach (var generic_parameter in method.GenericParameters)
                reference.GenericParameters.Add(new GenericParameter(generic_parameter.Name, reference));
            return reference;
        }

        static bool isMatch(TypeReference left, TypeReference right, TypeReference context, bool isDefinition)
        {
            if (left.IsGenericParameter)
            {
                var gp = left as GenericParameter;
                var genericInstance = ((GenericInstanceType)context);
                var genericDefinition = isDefinition ? genericInstance.Resolve() : genericInstance.ElementType;
                for (int i = 0; i < genericDefinition.GenericParameters.Count; i++)
                {
                    if (genericDefinition.GenericParameters[i] == gp)
                    {
                        left = genericInstance.GenericArguments[i];
                    }
                }
            }
            if (left.FullName == right.FullName)
            {
                return true;
            }
            if (left.IsGenericInstance && right.IsGenericInstance)
            {
                return GetAssemblyQualifiedName(left, context, true) == GetAssemblyQualifiedName(right, context, true);
            }
            else
            {
                return false;
            }
        }

        static string stripName(string name)
        {
            var dot = name.LastIndexOf('.');
            if (dot >= 0)
            {
                return name.Substring(dot + 1);
            }
            else
            {
                return name;
            }
        }

        public static bool IsMatch(this MethodReference left, MethodDefinition right, TypeReference context)
        {
            if (left.Parameters.Count != right.Parameters.Count || stripName(left.Name) != stripName(right.Name))
            {
                return false;
            }

            if (!isMatch(left.ReturnType, right.ReturnType, context, left is MethodDefinition))
            {
                return false;
            }
            bool paramMatch = true;
            for (int i = 0; i < left.Parameters.Count; i++)
            {
                if (!isMatch(left.Parameters[i].ParameterType, right.Parameters[i].ParameterType, context,
                    left is MethodDefinition))
                {
                    paramMatch = false;
                    break;
                }
            }
            return paramMatch;
        }

        /// <summary>
        /// 两个方法签名是否相同
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="checkDefineEqual"></param>
        /// <returns></returns>
        public static bool AreSignaturesEqual(MethodReference left, MethodReference right,
            bool checkDefineEqual = false)
        {
            if (left == right) return true;
            if (left.HasThis != right.HasThis || left.Parameters.Count != right.Parameters.Count
                || left.Name != right.Name
                || left.GenericParameters.Count != right.GenericParameters.Count)
            {
                return false;
            }

            if (checkDefineEqual && left.Resolve().ToString() != right.Resolve().ToString())
            {
                return false;
            }

            if (left.ReturnType.FillGenericArgument(left, left.DeclaringType).FullName
                != right.ReturnType.FillGenericArgument(right, right.DeclaringType).FullName)
            {
                return false;
            }

            for (int i = 0; i < left.Parameters.Count; i++)
            {
                if (left.Parameters[i].ParameterType.FillGenericArgument(left, left.DeclaringType).FullName !=
                    right.Parameters[i].ParameterType.FillGenericArgument(right, right.DeclaringType).FullName)
                {
                    return false;
                }
            }

            return true;
        }

        public static bool CheckImplemention(this MethodReference itfMethod, MethodDefinition impl)
        {
            //一个类可能有多个同签名方法，这时应该通过Overrides来检查
            if (impl.Overrides.Count > 0)
            {
                foreach (var o in impl.Overrides)
                {
                    if (AreSignaturesEqual(itfMethod, o, true))
                    {
                        return true;
                    }
                }
                return false;
            }
            else
            {
                return AreSignaturesEqual(itfMethod, impl);
            }
        }

        public static MethodReference FindMatch(this TypeReference itf, MethodDefinition method)
        {
            var itfDef = itf.Resolve();

            MethodDefinition found = null;

            foreach (var itfMethod in itfDef.Methods)
            {
                if (IsMatch(itfMethod, method, itf))
                {
                    found = itfMethod;
                    break;
                }
            }

            return ((found != null && itf.IsGenericInstance) ? 
                found.MakeGeneric(itf) : TryImport(found, itf.Module));
        }

        static int getLDCOperand(Instruction instrunction)
        {
            switch (instrunction.OpCode.Code)
            {
                case Code.Ldc_I4_0:
                    return 0;
                case Code.Ldc_I4_1:
                    return 1;
                case Code.Ldc_I4_2:
                    return 2;
                case Code.Ldc_I4_3:
                    return 3;
                case Code.Ldc_I4_4:
                    return 4;
                case Code.Ldc_I4_5:
                    return 5;
                case Code.Ldc_I4_6:
                    return 6;
                case Code.Ldc_I4_7:
                    return 7;
                case Code.Ldc_I4_8:
                    return 8;
                case Code.Ldc_I4_M1:
                    return -1;
                case Code.Ldc_I4_S:
                    return (byte)instrunction.Operand;
                case Code.Ldc_I4:
                    return (int)instrunction.Operand;
                default:
                    throw new Exception("no a ldc_i4 instrunction");
            }
        }

        public enum InjectType
        {
            Redirect,
            Switch,
            None
        }

        public static void AnalysisMethod(MethodDefinition method, out InjectType injectType, out int id,
            out int firstInstruction)
        {
            firstInstruction = 0;

            if (method.Body == null || method.Body.Instructions == null) goto NotInjectYet;

            var instructions = method.Body.Instructions;

            if (instructions.Count > 2 && instructions[1].OpCode.Code == Code.Call)
            {
                var callMethod = instructions[1].Operand as MethodReference;
                if (callMethod.DeclaringType.FullName == "IFix.Core.SwitchFlag" && callMethod.Name == "Get")
                {
                    injectType = InjectType.Switch;
                }
                else if (callMethod.DeclaringType.FullName == "IFix.WrappersManagerImpl" && callMethod.Name == "Get")
                {
                    injectType = InjectType.Redirect;
                }
                else
                {
                    goto NotInjectYet;
                }
                id = getLDCOperand(instructions[0]);
                for (int i = 0; i < instructions.Count; i++)
                {
                    if (instructions[i].OpCode.Code == Code.Ret)
                    {
                        firstInstruction = i + 1;
                        break;
                    }
                }
                return;
            }

            NotInjectYet:
            injectType = InjectType.None;
            id = -1;
        }

        //如果method是注入函数，返回其注入类型，id，以及对应的新函数
        public static void AnalysisMethod(Dictionary<string, Dictionary<string, List<MethodDefinition>>> searchData,
            MethodDefinition method, out InjectType injectType, out int id, out MethodDefinition foundMethod)
        {
            int firstInstruction;
            AnalysisMethod(method, out injectType, out id, out firstInstruction);
            foundMethod = null;
            if (id >= 0)
            {
                Dictionary<string, List<MethodDefinition>> methodsOfType;
                List<MethodDefinition> overloads;
                if (searchData.TryGetValue(method.DeclaringType.FullName, out methodsOfType)
                    && methodsOfType.TryGetValue(method.Name, out overloads))
                {
                    foreach (var overload in overloads)
                    {
                        if (overload.IsTheSame(method))
                        {
                            foundMethod = overload;
                            break;
                        }
                    }
                }
            }
        }

        static void addTypeAndNestType(List<TypeDefinition> result, TypeDefinition type)
        {
            result.Add(type);
            foreach (var nt in type.NestedTypes)
            {
                addTypeAndNestType(result, nt);
            }
        }

        /// <summary>
        /// 获取一个程序集里头所有类型，包括其内嵌类型
        /// </summary>
        /// <param name="assembly"></param>
        /// <returns></returns>
        public static List<TypeDefinition> GetAllType(this AssemblyDefinition assembly)
        {
            List<TypeDefinition> result = new List<TypeDefinition>();

            foreach (var type in (from module in assembly.Modules from type in module.Types select type))
            {
                addTypeAndNestType(result, type);
            }

            return result;
        }
    }
}
```

`Source/VSProj/Src/Tools/CodeTranslator.cs`:

```cs
/*
 * Tencent is pleased to support the open source community by making InjectFix available.
 * Copyright (C) 2019 Tencent.  All rights reserved.
 * InjectFix is licensed under the MIT License, except for the third-party components listed in the file 'LICENSE' which may be subject to their corresponding license terms. 
 * This file is subject to the terms and conditions defined in file 'LICENSE', which is part of this source code package.
 */

using System;
using System.Linq;
using System.Collections.Generic;
using System.IO;
using Mono.Cecil;
using Mono.Cecil.Cil;

namespace IFix
{
    enum ProcessMode
    {
        Inject,
        Patch
    }

    class CodeTranslator
    {
        private Dictionary<int, List<Core.Instruction>> codes = new Dictionary<int, List<Core.Instruction>>();
        private HashSet<int> codeMustWriteToPatch = new HashSet<int>();
        private Dictionary<MethodReference, int> methodToId = new Dictionary<MethodReference, int>();
        private Dictionary<int, Core.ExceptionHandler[]> methodIdToExceptionHandler =
            new Dictionary<int, Core.ExceptionHandler[]>();

        private List<TypeReference> externTypes = new List<TypeReference>();
        private List<TypeReference> contextTypeOfExternType = new List<TypeReference>();
        private Dictionary<TypeReference, int> externTypeToId = new Dictionary<TypeReference, int>();
        private Dictionary<string, TypeReference> nameToExternType = new Dictionary<string, TypeReference>();
        private List<MethodReference> externMethods = new List<MethodReference>();
        private Dictionary<MethodReference, int> externMethodToId = new Dictionary<MethodReference, int>();

        private List<string> internStrings = new List<string>();
        private Dictionary<string, int> internStringsToId = new Dictionary<string, int>();

        private List<FieldReference> fields = new List<FieldReference>();
        private List<FieldDefinition> fieldsStoreInVirtualMachine = new List<FieldDefinition>();
        private Dictionary<FieldReference, int> fieldToId = new Dictionary<FieldReference, int>();

        private Dictionary<MethodReference, int> virtualMethodToIndex = new Dictionary<MethodReference, int>();
        const string Wrap_Perfix = "__Gen_Wrap_";

        int nextAllocId = 0;

        bool isCompilerGenerated(TypeReference type)
        {
            if (type.IsGenericInstance)
            {
                return isCompilerGenerated((type as GenericInstanceType).ElementType);
            }
            var td = type as TypeDefinition;
            if (td != null && td.IsNested)
            {
                if (isCompilerGenerated(td.DeclaringType))
                {
                    return true;
                }
            }
            return td != null && !td.IsInterface && td
                .CustomAttributes
                .Any(ca => ca.AttributeType.FullName == "System.Runtime.CompilerServices.CompilerGeneratedAttribute");
        }

        bool isCompilerGenerated(MethodReference method)
        {
            if (method.IsGenericInstance)
            {
                return isCompilerGenerated((method as GenericInstanceMethod).ElementMethod);
            }
            var md = method as MethodDefinition;
            return md != null && md.CustomAttributes.Any(ca => ca.AttributeType.FullName 
            == "System.Runtime.CompilerServices.CompilerGeneratedAttribute");
        }

        bool isCompilerGenerated(FieldReference field)
        {
            var fd = field as FieldDefinition;
            return fd != null && fd.CustomAttributes.Any(ca => ca.AttributeType.FullName 
            == "System.Runtime.CompilerServices.CompilerGeneratedAttribute");
        }

        bool isCompilerGeneratedPlainObject(TypeReference type)
        {
            var td = type as TypeDefinition;

            return td != null
                && !td.IsInterface
                //&& td.Interfaces.Count == 0
                && isCompilerGenerated(type)
                && td.BaseType.IsSameType(objType);
        }

        bool isCustomClassPlainObject(TypeReference type)
        {
            var td = type as TypeDefinition;
            return td != null
                && !td.IsInterface
                && isNewClass(td)
                && (td.BaseType.IsSameType(objType) || isCustomClassPlainObject(td.BaseType as TypeReference));
        }

        bool isCompilerGeneratedByNotPlainObject(TypeReference type)
        {
            var td = type as TypeDefinition;

            return (type.IsGenericInstance || (td != null
                && !td.IsInterface
                //&& (!td.BaseType.IsSameType(objType) || td.Interfaces.Count != 0)))
                && !td.BaseType.IsSameType(objType)))
                && isCompilerGenerated(type);
        }

        Dictionary<TypeDefinition, HashSet<FieldDefinition>> typeToSpecialGeneratedFields 
            = new Dictionary<TypeDefinition, HashSet<FieldDefinition>>();

        Dictionary<TypeDefinition, int> typeToCctor = new Dictionary<TypeDefinition, int>();
        Dictionary<FieldDefinition, int> newFieldToCtor = new Dictionary<FieldDefinition, int>();

        /// <summary>
        /// 获取简写属性（例如public int a{get;set;}），事件等所生成的字段
        /// </summary>
        /// <param name="type"></param>
        /// <returns></returns>
        HashSet<FieldDefinition> getSpecialGeneratedFields(TypeDefinition type)
        {
            HashSet<FieldDefinition> ret;
            if (!typeToSpecialGeneratedFields.TryGetValue(type, out ret))
            {
                ret = new HashSet<FieldDefinition>();
                typeToSpecialGeneratedFields[type] = ret;
                if (!typeToCctor.ContainsKey(type))
                {
                    typeToCctor[type] = -1;
                    var cctor = type.Methods.FirstOrDefault(m => m.Name == ".cctor");
                    if (cctor != null)
                    {
                        var cctorInfo = getMethodId(cctor, null,false, false, InjectType.Redirect);
                        typeToCctor[type] = cctorInfo.Type == CallType.Internal ? cctorInfo.Id : -2;
                    }
                }
                
                foreach (var field in ( from method in type.Methods
                                        where method.IsSpecialName && method.Body != null 
                                            && method.Body.Instructions != null
                                        from instruction in method.Body.Instructions
                                        where instruction.OpCode.Code == Code.Ldsfld
                                            || instruction.OpCode.Code == Code.Stsfld
                                            || instruction.OpCode.Code == Code.Ldsflda
                                        where isCompilerGenerated(instruction.Operand as FieldReference)
                                        select (instruction.Operand as FieldReference).Resolve()).Distinct())
                {
                    ret.Add(field);
                }
            }
            return ret;
        }

        //再补丁新增一个对原生方法的引用
        int addExternType(TypeReference type, TypeReference contextType = null)
        {
            if (type.IsRequiredModifier) return addExternType((type as RequiredModifierType).ElementType, contextType);
            if (type.IsGenericParameter || type.HasGenericArgumentFromMethod())
            {
                var genericTypeInfo = "{None}";
                try {
                    var genericType = (GenericParameter)type;
                    var owner = (TypeDefinition)genericType.Owner;
                    genericTypeInfo = string.Format("{{Owner: {0}, Scope: {1}}}", owner.FullName, genericType.Scope.Name);
                } catch { }
                throw new InvalidProgramException("try to use a generic type definition: " + type + ", generic type info: " + genericTypeInfo);
            }
            if (externTypeToId.ContainsKey(type))
            {
                return externTypeToId[type];
            }
            if (isNewClass(type as TypeDefinition))
            {
                throw new Exception(type + " is new class, cannot be treated as extern type");
            }
            if (isCompilerGenerated(type))
            {
                throw new Exception(type + " is CompilerGenerated");
            }
            TypeReference theSameNameType;
            var typeName = type.GetAssemblyQualifiedName(contextType);
            if (nameToExternType.TryGetValue(typeName, out theSameNameType))
            {
                var ret = addExternType(theSameNameType, contextType);
                externTypeToId.Add(type, ret);
                return ret;
            }
            nameToExternType.Add(typeName, type);
            externTypeToId.Add(type, externTypes.Count);
            externTypes.Add(type);
            contextTypeOfExternType.Add(contextType);
            return externTypes.Count - 1;
        }

        //假如是注入模式，而且该函数配置是IFix的话，不需要真的为其访问的资源分配id
        //TODO: 更理想的做法是剥离一个分析代码流程，仅分析要生产哪些适配器，反向适配器，反剪裁配置
        bool doNoAdd(MethodDefinition caller)
        {
            InjectType injectType;
            return mode == ProcessMode.Inject && caller != null && methodToInjectType.TryGetValue(caller,
                out injectType) && injectType == InjectType.Switch;
        }

        //原生字段
        int addRefField(FieldReference field, MethodDefinition caller)
        {
            if (doNoAdd(caller))
            {
                return int.MaxValue;
            }

            int id;
            if (!fieldToId.TryGetValue(field, out id))
            {
                id = fields.Count;
                fieldToId.Add(field, id);
                fields.Add(field);
                addExternType(field.DeclaringType);
            }
            return id;
        }

        //虚拟机存储字段
        int addStoreField(FieldDefinition field, MethodDefinition caller)
        {
            if (doNoAdd(caller))
            {
                return int.MaxValue;
            }

            int id;
            if (!fieldToId.TryGetValue(field, out id))
            {
                id = -(fieldsStoreInVirtualMachine.Count + 1);
                fieldToId.Add(field, id);
                fieldsStoreInVirtualMachine.Add(field);
                addExternType((isCompilerGenerated(field.FieldType) || isNewClass(field.FieldType as TypeDefinition)) ? objType : field.FieldType);
            }
            return id;
        }

        //新增一个字符串字面值
        int addInternString(string str, MethodDefinition caller)
        {
            if (doNoAdd(caller))
            {
                return int.MaxValue;
            }

            int id;
            if (!internStringsToId.TryGetValue(str, out id))
            {
                id = internStrings.Count;
                internStrings.Add(str);
                internStringsToId.Add(str, id);
            }
            return id;
        }

        //原生方法的引用
        int addExternMethod(MethodReference callee, MethodDefinition caller)
        {
            if (doNoAdd(caller))
            {
                return ushort.MaxValue;
            }

            if (callee.Name == "AwaitUnsafeOnCompleted")
            {
                
                if (!awaitUnsafeOnCompletedMethods.Any(m => ((GenericInstanceMethod)callee).GenericArguments[0] == ((GenericInstanceMethod)m).GenericArguments[0]))
                {
                    awaitUnsafeOnCompletedMethods.Add(callee);
                }
            }

            if (externMethodToId.ContainsKey(callee))
            {
                return externMethodToId[callee];
            }

            if (callee.IsGeneric())
            {
                throw new InvalidProgramException("try to call a generic method definition: " + callee 
                    + ", caller is:" + caller);
            }

            if (isCompilerGenerated(callee) && !(callee as MethodDefinition).IsSpecialName)
            {
                throw new Exception(callee + " is CompilerGenerated");
            }

            if (callee.IsGenericInstance)
            {
                foreach (var typeArg in ((GenericInstanceMethod)callee).GenericArguments)
                {
                    if (!isCompilerGenerated(typeArg))
                    {
                        addExternType(typeArg);
                    }
                   
                }
            }

            if (callee.ReturnType.IsGenericParameter)
            {
                var resolveType = (callee.ReturnType as GenericParameter).ResolveGenericArgument(callee.DeclaringType);
                if (resolveType != null)
                {
                    addExternType(resolveType);
                }
            }
            else if (!callee.ReturnType.HasGenericArgumentFromMethod())
            {
                addExternType(callee.ReturnType, callee.DeclaringType);
            }
            addExternType(callee.DeclaringType);
            foreach (var p in callee.Parameters)
            {
                if (p.ParameterType.IsGenericParameter)
                {
                    var resolveType = (p.ParameterType as GenericParameter).ResolveGenericArgument(
                        callee.DeclaringType);
                    if (resolveType != null)
                    {
                        addExternType(resolveType);
                    }
                }
                else if (!p.ParameterType.HasGenericArgumentFromMethod())
                {
                    addExternType(p.ParameterType, callee.DeclaringType);
                }
            }

            int methodId = externMethods.Count;
            if (methodId > ushort.MaxValue)
            {
                throw new OverflowException("too many extern methods");
            }
            externMethodToId[callee] = methodId;
            externMethods.Add(callee);
            return methodId;
        }

        HashSet<MethodDefinition> antiLoop = new HashSet<MethodDefinition>();
        Dictionary<MethodDefinition, bool> cacheCheckResult = new Dictionary<MethodDefinition, bool>();
        bool checkILAndGetOffset(MethodDefinition method,
            Mono.Collections.Generic.Collection<Instruction> instructions)
        {
            if (cacheCheckResult.ContainsKey(method)) return cacheCheckResult[method];
            if (antiLoop.Contains(method)) return true;
            antiLoop.Add(method);
            int p;
            bool ret = checkILAndGetOffset(method, instructions, null, out p);
            cacheCheckResult[method] = ret;
            return ret;
        }

        /// <summary>
        /// 判断一个名字是否是一个合法id
        /// </summary>
        /// <param name="text"></param>
        /// <returns></returns>
        public static bool IsVaildIdentifierName(string text)
        {
            if (string.IsNullOrEmpty(text))
                return false;
            if (!char.IsLetter(text[0]) && text[0] != '_')
                return false;
            for (int ix = 1; ix < text.Length; ++ix)
                if (!char.IsLetterOrDigit(text[ix]) && text[ix] != '_')
                    return false;
            return true;
        }

        public bool isRefBySpecialMethodNoCache(FieldDefinition field)
        {
            foreach(var instructions in field.DeclaringType.Methods
                .Where(m => m.IsSpecialName && m.Body != null && m.Body.Instructions != null)
                .Select(m => m.Body.Instructions))
            {
                if (instructions.Any(i => i.Operand == field))
                {
                    return true;
                }
            }
            return false;
        }

        Dictionary<FieldDefinition, bool> isRefBySpecialMethodCache = new Dictionary<FieldDefinition, bool>();

        public bool isRefBySpecialMethod(FieldDefinition field)
        {
            bool ret;
            if (!isRefBySpecialMethodCache.TryGetValue(field, out ret))
            {
                ret = isRefBySpecialMethodNoCache(field);
                isRefBySpecialMethodCache.Add(field, ret);
            }
            return ret;
        }

        // #lizard forgives
        bool checkILAndGetOffset(MethodDefinition method,
            Mono.Collections.Generic.Collection<Instruction> instructions,
            Dictionary<Instruction, int> ilOffset, out int stopPos)
        {
            int offset = 0;
            stopPos = 0;
            for (int i = 0; i < instructions.Count; i++)
            {
                if (ilOffset != null)
                {
                    ilOffset.Add(instructions[i], offset + 1);
                }
                stopPos = i;
                //Console.WriteLine(i + " instruction:" + instructions[i].OpCode + " offset:" + offset);
                switch (instructions[i].OpCode.Code)
                {
                    case Code.Nop://先忽略
                        break;
                    case Code.Constrained:
                        {
                            TypeReference tr = instructions[i].Operand as TypeReference;
                            if (tr != null && !tr.IsGeneric())
                            {
                                offset += 2;
                                break;
                            }
                            else
                            {
                                return false;
                            }
                        }
                    case Code.Ldc_I8:
                    case Code.Ldc_R8:
                    case Code.Leave:
                    case Code.Leave_S:
                        offset += 2;
                        break;
                    case Code.Switch:
                        Instruction[] jmpTargets = instructions[i].Operand as Instruction[];
                        offset += ((jmpTargets.Length + 1) >> 1) + 1;
                        break;
                    case Code.Castclass:
                    case Code.Initobj:
                    case Code.Newarr:
                    case Code.Stobj:
                    case Code.Box:
                    case Code.Isinst:
                    case Code.Unbox_Any:
                    case Code.Unbox:
                    case Code.Ldobj:
                    case Code.Ldtoken:
                        {
                            TypeReference tr = instructions[i].Operand as TypeReference;
                            if (tr != null && !tr.IsGeneric())
                            {
                                offset += 1;
                                break;
                            }
                            else
                            {
                                return false;
                            }
                        }
                    case Code.Stfld:
                    case Code.Ldfld:
                    case Code.Ldflda:
                        {
                            FieldReference fr = instructions[i].Operand as FieldReference;
                            //如果是生成的字段，而且不是Getter/Setter/Adder/Remover
                            if (isCompilerGenerated(fr) && !method.IsSpecialName) 
                            {
                                if (!IsVaildIdentifierName(fr.Name)//不是合法名字，就肯定是随机变量
                                    //如果是合法名字，但不被任何SpecialName方法引用，也归为随机变量
                                    || !isRefBySpecialMethod(fr as FieldDefinition))

                                {
                                    return false;
                                }
                            }


                            if (fr != null/* && !fr.IsGeneric()*/)
                            {
                                offset += 1;
                                break;
                            }
                            else
                            {
                                return false;
                            }
                        }
                    case Code.Stsfld:
                    case Code.Ldsfld:
                    case Code.Ldsflda:
                        {
                            FieldReference fr = instructions[i].Operand as FieldReference;
                            //如果访问了生成的静态字段，而且不能存到虚拟机，不是Getter/Setter/Adder/Remover
                            //if ((isCompilerGenerated(fr) || isCompilerGenerated(fr.DeclaringType)) 
                            //    && !isFieldStoreInVitualMachine(fr) && !method.IsSpecialName)
                            //{
                            //    return false;
                            //}
                            if (fr != null/* && !fr.IsGeneric()*/)
                            {
                                offset += 1;
                                break;
                            }
                            else
                            {
                                return false;
                            }
                        }
                    case Code.Newobj:
                    case Code.Callvirt:
                    case Code.Call:
                    case Code.Ldftn:
                    case Code.Ldvirtftn:
                        {
                            //LINQ通常是ldftn，要验证ldftn所加载的函数是否含非法指令（不支持，或者引用了个生成字段，
                            //或者一个生成NotPlainObject）
                            MethodReference mr = instructions[i].Operand as MethodReference;
                            if (mr != null && !mr.IsGeneric()
                                && !isCompilerGeneratedByNotPlainObject(mr.DeclaringType))
                            {
                                if (isCompilerGenerated(mr)
                                    || (/*instructions[i].OpCode.Code != Code.Newobj && */
                                    isCompilerGeneratedPlainObject(mr.DeclaringType))
                                    || isCustomClassPlainObject(mr.DeclaringType))
                                {
                                    var md = mr as MethodDefinition;
                                    if (md == null)//闭包中调用一个泛型，在unity2018的.net 3.5设置下，编译器是先生成一个泛型的闭包实现，然后实例化，很奇怪的做法，老版本unity，新unity的.net 4.0设置都不会这样，先返回false，不支持这种编译器
                                    {
                                        return false;
                                    }
                                    if (md.Body != null && !checkILAndGetOffset(md, md.Body.Instructions))
                                    {
                                        //Console.WriteLine("check " + md + " fail il = " + md.Body.Instructions[p]
                                        //    + ",caller=" + method);
                                        return false;
                                    }
                                    //编译器生成类要检查所有实现方法
                                    if (instructions[i].OpCode.Code == Code.Newobj 
                                        && (isCompilerGeneratedPlainObject(mr.DeclaringType) || isCustomClassPlainObject(mr.DeclaringType)))
                                    {
                                        foreach (var m in mr.DeclaringType.Resolve().Methods
                                            .Where(m => !m.IsConstructor))
                                        {
                                            if (m.Body != null && !checkILAndGetOffset(m, m.Body.Instructions))
                                            {
                                                //Console.WriteLine("check " + md + " fail il = " 
                                                //   + md.Body.Instructions[p] + ",caller=" + method);
                                                return false;
                                            }
                                        }
                                    }
                                }
                                offset += 1;
                                break;
                            }
                            else
                            {
                                return false;
                            }
                        }
                    case Code.Conv_I: //Convert to native int, pushing native int on stack.
                    //case Code.Conv_U: //Convert to unsigned native int, pushing native int on stack.
                    case Code.Conv_Ovf_U:
                    case Code.Conv_Ovf_U_Un:
                    case Code.Calli: // not support op
                    case Code.Cpobj:
                    case Code.Refanyval:
                    case Code.Ckfinite:
                    case Code.Mkrefany:
                    case Code.Arglist:
                    case Code.Localloc:
                    case Code.Endfilter:
                    case Code.Unaligned:
                    case Code.Tail:
                    case Code.Cpblk:
                    case Code.Initblk:
                    case Code.No:
                    case Code.Sizeof: // support?
                    case Code.Refanytype:
                    case Code.Readonly:
                        return false;
                    default:
                        offset += 1;
                        break;
                }
            }
            return true;
        }

        void processMethod(MethodDefinition method)
        {
            getMethodId(method, null,true);
        }

        Core.ExceptionHandler findExceptionHandler(Core.ExceptionHandler[] ehs, Core.ExceptionHandlerType type,
            int offset)
        {
            int dummy;
            return findExceptionHandler(ehs, type, offset, out dummy);
        }

        /// <summary>
        /// 查找一个指令异常时的异常处理块
        /// </summary>
        /// <param name="ehs">当前函数的所有异常处理块</param>
        /// <param name="type">异常类型</param>
        /// <param name="offset">指令偏移</param>
        /// <param name="idx">异常处理块的索引</param>
        /// <returns></returns>
        Core.ExceptionHandler findExceptionHandler(Core.ExceptionHandler[] ehs, Core.ExceptionHandlerType type,
            int offset, out int idx)
        {
            Core.ExceptionHandler ret = null;
            idx = -1;
            for (int i = 0; i < ehs.Length; i++)
            {
                var eh = ehs[i];
                if (eh.HandlerType == type && eh.TryStart <= offset && eh.TryEnd > offset)
                {
                    if (ret == null || ((eh.TryEnd - eh.TryStart) < (ret.TryEnd - ret.TryStart)))
                    {
                        ret = eh;
                        idx = i;
                    }
                }
            }
            return ret;
        }

        MethodDefinition findOverride(TypeDefinition type, MethodReference vmethod, bool allowAbstractMethod = false)
        {
            foreach (var method in type.Methods)
            {
                if (method.IsVirtual && (allowAbstractMethod || !method.IsAbstract) && isTheSameDeclare(method, vmethod))
                {
                    return method;
                }
            }
            return null;
        }

        bool isTheSameDeclare(MethodReference m1, MethodReference m2)
        {
            if (m1.Name == m2.Name && m1.ReturnType.IsSameName(m2.ReturnType)
                && m1.Parameters.Count == m2.Parameters.Count)
            {
                bool isParamsMatch = true;
                for (int i = 0; i < m1.Parameters.Count; i++)
                {
                    if (m1.Parameters[i].Attributes != m2.Parameters[i].Attributes
                        || !m1.Parameters[i].ParameterType.IsSameName(m2.Parameters[i].ParameterType))
                    {
                        isParamsMatch = false;
                        break;
                    }
                }
                return isParamsMatch;
            }
            return false;
        }

        MethodReference _findBase(TypeReference type, MethodDefinition method)
        {
            TypeDefinition td = type.Resolve();
            if (td == null)
            {
                return null;
            }

            var m = findOverride(td, method);
            if (m != null)
            {
                if (type.IsGenericInstance)
                {
                    return m.MakeGeneric(method.DeclaringType);
                }
                else
                {
                    return m.TryImport(method.DeclaringType.Module);
                }
            }
            return _findBase(td.BaseType, method);
        }

        MethodReference _findInitDefineVirtualMethod(TypeReference type, MethodDefinition method)
        {
            TypeDefinition td = type.Resolve();
            if (td == null)
            {
                return null;
            }
            MethodReference baseM = null;
            if (td.BaseType != null && isNewClass(td.BaseType as TypeDefinition))
            {
                baseM = _findInitDefineVirtualMethod(td.BaseType, method);
            }
            if (baseM != null)
            {
                return baseM;
            }

            var m = findOverride(td, method, true);
            if (m != null)
            {
                if (type.IsGenericInstance)
                {
                    return m.MakeGeneric(method.DeclaringType);
                }
                else
                {
                    return m.TryImport(method.DeclaringType.Module);
                }
            }
            return null;
        }

        MethodReference findInitDefineVirtualMethod(TypeDefinition type, MethodDefinition method)
        {
            if (method.IsVirtual) 
            {
                foreach (var objVirtualMethod in ObjectVirtualMethodDefinitionList)
                {
                    if (isTheSameDeclare(objVirtualMethod,method))
                    {
                        return objVirtualMethod;
                    }
                }
                if (method.IsNewSlot)
                {
                    return method;
                }
                return _findInitDefineVirtualMethod(type.BaseType, method);
            }
            return null;
        }

        MethodReference findBase(TypeDefinition type, MethodDefinition method)
        {
            if (method.IsVirtual && !method.IsNewSlot) //表明override
            {
                try
                {
                    //TODO: 如果后续支持泛型解析，需要考虑这块的实现，xlua目前泛型直接不支持base调用
                    return _findBase(type.BaseType, method);
                }
                catch { }
            }
            return null;
        }

        const string BASE_RPOXY_PERFIX = "<>iFixBaseProxy_";

        Dictionary<MethodReference, Dictionary<TypeDefinition, MethodReference>> baseProxys = new Dictionary<MethodReference, Dictionary<TypeDefinition, MethodReference>>();

        //方案2
        //var method = typeof(object).GetMethod("ToString");
        //var ftn = method.MethodHandle.GetFunctionPointer();
        //var func = (Func<string>)Activator.CreateInstance(typeof(Func<string>), obj, ftn);
        MethodReference tryAddBaseProxy(TypeDefinition type, MethodDefinition method)
        {
            var mbase = findBase(type, method);
            if (mbase != null)
            {
                if (!isNewClass(type))
                {
                    var proxyMethod = new MethodDefinition(BASE_RPOXY_PERFIX + method.Name, MethodAttributes.Public,
                                       method.ReturnType);
                    for (int i = 0; i < method.Parameters.Count; i++)
                    {
                        proxyMethod.Parameters.Add(new ParameterDefinition("P" + i, method.Parameters[i].IsOut
                            ? ParameterAttributes.Out : ParameterAttributes.None, method.Parameters[i].ParameterType));
                    }
                    var instructions = proxyMethod.Body.Instructions;
                    var ilProcessor = proxyMethod.Body.GetILProcessor();
                    int paramCount = method.Parameters.Count + 1;
                    for (int i = 0; i < paramCount; i++)
                    {
                        emitLdarg(instructions, ilProcessor, i);
                        if (i == 0 && type.IsValueType)
                        {
                            instructions.Add(Instruction.Create(OpCodes.Ldobj, type));
                            instructions.Add(Instruction.Create(OpCodes.Box, type));
                        }
                    }
                    instructions.Add(Instruction.Create(OpCodes.Call, mbase));
                    instructions.Add(Instruction.Create(OpCodes.Ret));
                    type.Methods.Add(proxyMethod);

                    Dictionary<TypeDefinition, MethodReference> typeToProxy;
                    if (!baseProxys.TryGetValue(mbase, out typeToProxy))
                    {
                        typeToProxy = new Dictionary<TypeDefinition, MethodReference>();
                        baseProxys.Add(mbase, typeToProxy);
                    }
                    typeToProxy.Add(type, proxyMethod);
                    return proxyMethod;
                }
                else if(isNewClass(type) && !isNewClass(type.BaseType as TypeDefinition))
                {
                    return objectVirtualMethodReferenceList.FirstOrDefault( m => m.Name == ("Object" + method.Name));
                }
            }
            return null;
        }

        MethodReference findProxy(TypeDefinition type, MethodReference methodToCall)
        {
            Dictionary<TypeDefinition, MethodReference> typeToProxy;
            if (baseProxys.TryGetValue(methodToCall, out typeToProxy))
            {
                TypeDefinition ptype = type;
                while (ptype != null)
                {
                    if (typeToProxy.ContainsKey(ptype))
                    {
                        return typeToProxy[ptype];
                    }
                    ptype = ptype.DeclaringType;
                }
            }
            return null;
            
        }

        enum CallType
        {
            Extern,
            Internal,
            InteralVirtual,
            Invalid
        }

        struct MethodIdInfo
        {
            public int Id;
            public CallType Type;
        }

        enum InjectType
        {
            Redirect,
            Switch
        }

        bool isFieldStoreInVitualMachine(FieldReference field)
        {
            var fieldDef = field.Resolve();
            if (fieldDef == null)
            {
                return false;
            }
            if (!fieldDef.IsStatic)
            {
                return false;
            }

            if ((!isCompilerGenerated(field) && !isCompilerGenerated(field.DeclaringType)) || !isNewClass(field.DeclaringType as TypeDefinition))
            {
                return false;
            }

            if (field.FieldType.Resolve().IsDelegate())
            {
                return true;
            }

            //TODO: switch(str)

            return false;
        }

        bool isNewMethod(MethodDefinition method)
        {
            return configure.IsNewMethod(method);
        }

        bool isNewClass(TypeDefinition type)
        {
            return configure.IsNewClass(type);
        }

        bool isNewField(FieldDefinition field)
        {
            return configure.isNewField(field);
        }

        Dictionary<MethodDefinition, int> interpretMethods = new Dictionary<MethodDefinition, int>();
        void addInterpretMethod(MethodDefinition method, int methodId)
        {
            if (method.IsGenericInstance || method.HasGenericParameters)
            {
                throw new NotSupportedException("generic method definition");
            }
            addExternType(method.ReturnType, method.DeclaringType);
            addExternType(method.DeclaringType);
            foreach(var pinfo in method.Parameters)
            {
                addExternType(pinfo.ParameterType, method.DeclaringType);
            }
            interpretMethods.Add(method, methodId);
        }

        bool isFieldAccessInject(MethodDefinition method, int methodId)
        {
            return false;
        }

        //字段注入方式处理逻辑
        //目前用不上，但后续支持泛型修复需要用到
        void fieldAccessInject(InjectType injectType, MethodDefinition method, int methodId)
        {
            var redirectBridge = getRedirectField(method);
            var body = method.Body;
            var msIls = body.Instructions;
            var ilProcessor = body.GetILProcessor();

            var redirectTo = getWrapperMethod(wrapperType, anonObjOfWrapper, method, false, false);
            Instruction insertPoint;
            if (injectType == InjectType.Redirect)
            {
                msIls.Clear();
                body.ExceptionHandlers.Clear();
                body.Variables.Clear();

                msIls.Add(Instruction.Create(OpCodes.Ret));
                insertPoint = msIls[0];
                ilProcessor.InsertBefore(insertPoint, ilProcessor.Create(OpCodes.Ldsfld, redirectBridge));
            }
            else
            {
                ilProcessor.InsertBefore(msIls[0], Instruction.Create(OpCodes.Ret));
                insertPoint = msIls[0];
                var redirectBridgeTmp = new VariableDefinition(wrapperType);
                method.Body.Variables.Add(redirectBridgeTmp);
                ilProcessor.InsertBefore(insertPoint, ilProcessor.Create(OpCodes.Ldsfld, redirectBridge));
                ilProcessor.InsertBefore(insertPoint, ilProcessor.Create(OpCodes.Stloc, redirectBridgeTmp));
                ilProcessor.InsertBefore(insertPoint, ilProcessor.Create(OpCodes.Ldloc, redirectBridgeTmp));
                ilProcessor.InsertBefore(insertPoint, ilProcessor.Create(OpCodes.Brfalse, insertPoint.Next));
                ilProcessor.InsertBefore(insertPoint, ilProcessor.Create(OpCodes.Ldloc, redirectBridgeTmp));
            }

            int argPos = 0;

            if (method.HasThis)
            {
                ilProcessor.InsertBefore(insertPoint, createLdarg(ilProcessor, 0));
                argPos = 1;
            }

            for (int i = 0; i < method.Parameters.Count; i++)
            {
                ilProcessor.InsertBefore(insertPoint, createLdarg(ilProcessor, argPos++));
                var ptype = method.Parameters[i].ParameterType;
                if (wrapperParamerterType(ptype) != ptype && ptype.IsValueType)
                {
                    ilProcessor.InsertBefore(insertPoint, Instruction.Create(OpCodes.Box, ptype));
                }
            }
            ilProcessor.InsertBefore(insertPoint, Instruction.Create(OpCodes.Callvirt, redirectTo));
        }

        //id注入方式处理逻辑
        void idAccessInject(InjectType injectType, MethodDefinition method, int methodId)
        {
            addRedirectIdInfo(method, methodId);
            var body = method.Body;
            var msIls = body.Instructions;
            var ilProcessor = body.GetILProcessor();

            var redirectTo = getWrapperMethod(wrapperType, anonObjOfWrapper, method, false, false);
            Instruction insertPoint;
            if (injectType == InjectType.Redirect)
            {
                msIls.Clear();
                body.ExceptionHandlers.Clear();
                body.Variables.Clear();

                msIls.Add(Instruction.Create(OpCodes.Ret));
                insertPoint = msIls[0];
            }
            else
            {
                ilProcessor.InsertBefore(msIls[0], Instruction.Create(OpCodes.Ret));
                insertPoint = msIls[0];
                ilProcessor.InsertBefore(insertPoint, createLdcI4(methodId));
                ilProcessor.InsertBefore(insertPoint, ilProcessor.Create(OpCodes.Call, isPatched));
                ilProcessor.InsertBefore(insertPoint, ilProcessor.Create(OpCodes.Brfalse, insertPoint.Next));
            }

            ilProcessor.InsertBefore(insertPoint, createLdcI4(methodId));
            ilProcessor.InsertBefore(insertPoint, Instruction.Create(OpCodes.Call, getPatch));

            int argPos = 0;

            if (method.HasThis)
            {
                ilProcessor.InsertBefore(insertPoint, createLdarg(ilProcessor, 0));
                argPos = 1;
            }

            for (int i = 0; i < method.Parameters.Count; i++)
            {
                ilProcessor.InsertBefore(insertPoint, createLdarg(ilProcessor, argPos++));
                var ptype = method.Parameters[i].ParameterType;
                if (wrapperParamerterType(ptype) != ptype && ptype.IsValueType)
                {
                    ilProcessor.InsertBefore(insertPoint, Instruction.Create(OpCodes.Box, ptype));
                }
            }
            ilProcessor.InsertBefore(insertPoint, Instruction.Create(OpCodes.Callvirt, redirectTo));
        }

        void injectMethod(MethodDefinition method, int methodId)
        {
            InjectType injectType;
            if (methodToInjectType.TryGetValue(method, out injectType))
            {
                if (mode == ProcessMode.Patch || injectType == InjectType.Redirect)
                {
                    addInterpretMethod(method, methodId);
                }
                if (isFieldAccessInject(method, methodId))
                {
                    fieldAccessInject(injectType, method, methodId);
                }
                else
                {
                    idAccessInject(injectType, method, methodId);
                }
            }
        }

        int allocMethodId(MethodDefinition method)
        {
            int methodId = nextAllocId++;

            methodToId.Add(method, methodId);

            if (mode == ProcessMode.Patch && methodId > ushort.MaxValue)
            {
                throw new OverflowException("too many internal methods");
            }
            return methodId;
        }

        /// <summary>
        /// 获取一个函数的id
        /// 该函数会触发指令序列生成
        /// </summary>
        /// <param name="callee">被调用函数</param>
        /// <param name="caller">调用者</param>
        /// <param name="directCallVirtual">是个虚函数，会生成指令序列，
        /// 但是调用通过反射来调用</param>
        /// <param name="callerInjectType">调用者的注入类型</param>
        /// <returns>负数表示需要反射访问原生，0或正数是指令数组下标</returns>
        // #lizard forgives
        unsafe MethodIdInfo getMethodId(MethodReference callee, MethodDefinition caller, bool isCallvirt,
            bool directCallVirtual = false, InjectType callerInjectType = InjectType.Switch)
        {
            //Console.WriteLine("callee:" + callee + ", caller:" + caller);
            MethodDefinition method = callee as MethodDefinition;

            if (!directCallVirtual && externMethodToId.ContainsKey(callee))
            {
                return new MethodIdInfo()
                {
                    Id = addExternMethod(callee, caller),
                    Type = CallType.Extern
                };
            }
            if (method != null)
            {
                if (method.IsAbstract && isCallvirt)
                {
                    if (isCompilerGeneratedPlainObject(method.DeclaringType) || isCustomClassPlainObject(method.DeclaringType))
                    {
                        return new MethodIdInfo()
                        {
                            Id = virtualMethodInVTableIndex(method),
                            Type = CallType.InteralVirtual
                        };
                    }
                }

            }
            if (methodToId.ContainsKey(callee))
            {
                if (isCallvirt && isNewClass(callee.DeclaringType as TypeDefinition))
                {
                    getVirtualMethodForType(method.DeclaringType);
                    if (virtualMethodToIndex.ContainsKey(callee))
                    {
                        return new MethodIdInfo()
                        {
                            Id = virtualMethodToIndex[callee],
                            Type = CallType.InteralVirtual
                        };
                    }
                }
                return new MethodIdInfo()
                {
                    Id = methodToId[callee],
                    Type = CallType.Internal
                };
            }

            //如果是dll之外的方法，或者是构造函数，析构函数，作为虚拟机之外（extern）的方法
            if (method == null || (method.IsConstructor && !(isCompilerGeneratedPlainObject(method.DeclaringType) || isCustomClassPlainObject(method.DeclaringType)))
                || method.IsFinalizer()
                || method.IsAbstract || method.IsPInvokeImpl || method.Body == null
                || method.DeclaringType.IsInterface
                || (!methodToInjectType.ContainsKey(method) && !(isCompilerGenerated(method.DeclaringType) || isNewClass(method.DeclaringType))
                && !isCompilerGenerated(method) && !(mode == ProcessMode.Patch && isNewMethod(method))))
            {
                //Console.WriteLine("do no tranlater:" + callee + "," + callee.GetType());

                return new MethodIdInfo()
                {
                    Id = addExternMethod(callee, caller),
                    Type = CallType.Extern
                };
            }

            if (method.Parameters.Any(p => p.ParameterType.IsPointer) || method.ReturnType.IsPointer)
            {
                Console.WriteLine("Warning: unsafe method, " + method + " in " + method.DeclaringType);

                return new MethodIdInfo()
                {
                    Id = addExternMethod(callee, caller),
                    Type = CallType.Extern
                };
            }

            if (method.IsGeneric())//暂时不支持解析泛型
            {
                return new MethodIdInfo() { Id = 0, Type = CallType.Invalid };
            }
           
            tryAddBaseProxy(method.DeclaringType, method);
            var body = method.Body;
            var msIls = body.Instructions;
            var ilOffset = new Dictionary<Instruction, int>();

            //Console.WriteLine("process method id:" + codes.Count);

            //if (mode == ProcessMode.Patch || !methodToInjectType.ContainsKey(method)
            //    || methodToInjectType[method] == InjectType.Redirect)
            {
                int stopPos;
                //包含不支持指令的方法，作为虚拟机之外（extern）的方法
                if (!checkILAndGetOffset(method, msIls, ilOffset, out stopPos))
                {
                    InjectType it;
                    if (methodToInjectType.TryGetValue(method, out it))
                    {
                        if (mode == ProcessMode.Patch || it == InjectType.Redirect)
                        {
                            // 打patch发现不支持指令应该报错
                            throw new InvalidDataException("not support il[" + msIls[stopPos] + "] in " + method
                                + ", caller is " + caller);
                        }
                        else
                        {
                            Console.WriteLine("Warning: not support il[" + msIls[stopPos] + "] in " + method
                                + (caller == null ? "" : (", caller is " + caller)));
                            injectMethod(method, allocMethodId(method));
                        }
                    }
                    else
                    {
                        Console.WriteLine("Info: not support il[" + msIls[stopPos] + "] in " + method
                            + (caller == null ? "" : (", caller is " + caller)));
                    }

                    return new MethodIdInfo()
                    {
                        Id = addExternMethod(callee, caller),
                        Type = CallType.Extern
                    };
                }
            }

            int methodId = allocMethodId(method);

            InjectType injectType;
            InjectType injectTypePassToNext;
            if (!methodToInjectType.TryGetValue(method, out injectTypePassToNext))
            {
                injectTypePassToNext = callerInjectType;
            }
            //if (!methodToInjectType.TryGetValue(method, out injectType)
            //    || injectType == InjectType.Redirect || mode == ProcessMode.Patch)
            try
            {
                var code = new List<Core.Instruction>();
                codes.Add(methodId, code);
                if (!codeMustWriteToPatch.Contains(methodId) && 
                    (
                        mode == ProcessMode.Patch  || //patch阶段无论哪种类型都要写入补丁
                        (methodToInjectType.TryGetValue(method, out injectType)
                            && injectType == InjectType.Redirect) || //注入阶段，重定向类型需要写入补丁
                        (callerInjectType == InjectType.Redirect) //被重定向类型函数调用，也需要写入补丁
                    ))
                {
                    codeMustWriteToPatch.Add(methodId);
                }

                code.Add(new Core.Instruction { Code = Core.Code.StackSpace, Operand = (body.Variables.Count << 16)
                    | body.MaxStackSize }); // local | maxstack

                int offsetAdd = 0;

                foreach(var variable in body.Variables)
                {
                    if (variable.VariableType.IsValueType && !variable.VariableType.IsPrimitive)
                    {
                        if (isCompilerGenerated(variable.VariableType))
                        {
                            code.Add(new Core.Instruction
                            {
                                Code = Core.Code.Newanon,
                                Operand = addAnonymousCtor(null, variable.VariableType)
                            });
                            code.Add(new Core.Instruction
                            {
                                Code = Core.Code.Stloc,
                                Operand = variable.Index
                            });
                        }
                        else
                        {
                            code.Add(new Core.Instruction
                            {
                                Code = Core.Code.Ldloca,
                                Operand = variable.Index,
                            });
                            code.Add(new Core.Instruction
                            {
                                Code = Core.Code.Initobj,
                                Operand = addExternType(variable.VariableType)
                            });
                        }
                        offsetAdd += 2;
                    }
                }

                if (offsetAdd > 0)
                {
                    var ilNewOffset = new Dictionary<Instruction, int>();
                    foreach (var kv in ilOffset)
                    {
                        ilNewOffset[kv.Key] = kv.Value + offsetAdd;
                    }
                    ilOffset = ilNewOffset;
                }

                Core.ExceptionHandler[] exceptionHandlers = new Core.ExceptionHandler[body.ExceptionHandlers.Count];

                for (int i = 0; i < body.ExceptionHandlers.Count; i++)
                {
                    var exceptionHandler = body.ExceptionHandlers[i];
                    if (exceptionHandler.HandlerType == ExceptionHandlerType.Fault 
                        && exceptionHandler.HandlerType == ExceptionHandlerType.Filter)
                    {
                        throw new NotImplementedException(exceptionHandler.HandlerType.ToString() + " no support!");
                    }
                    exceptionHandlers[i] = new Core.ExceptionHandler()
                    {
                        HandlerType = (Core.ExceptionHandlerType)(int)exceptionHandler.HandlerType,
                        CatchTypeId = exceptionHandler.CatchType == null ? -1 
                            : addExternType(exceptionHandler.CatchType),
                        TryStart = ilOffset[exceptionHandler.TryStart],
                        TryEnd = ilOffset[exceptionHandler.TryEnd],
                        HandlerStart = ilOffset[exceptionHandler.HandlerStart],
                        HandlerEnd = exceptionHandler.HandlerEnd == null ? -1 : ilOffset[exceptionHandler.HandlerEnd]
                    };
                    //Console.WriteLine("---------------" + i + "---------------");
                    //Console.WriteLine("HandlerType:" + exceptionHandlers[i].HandlerType);
                    //Console.WriteLine("CatchTypeId:" + exceptionHandlers[i].CatchTypeId);
                    //Console.WriteLine("TryStart:" + exceptionHandlers[i].TryStart);
                    //Console.WriteLine("TryEnd:" + exceptionHandlers[i].TryEnd);
                    //Console.WriteLine("HandlerStart:" + exceptionHandlers[i].HandlerStart);
                    //Console.WriteLine("HandlerEnd:" + exceptionHandlers[i].HandlerEnd);
                }

                methodIdToExceptionHandler.Add(methodId, exceptionHandlers);

                bool typeofDetected = false;

                Core.Instruction operand = new Core.Instruction();
                for (int i = 0; i < msIls.Count; i++)
                {
                    var msIl = msIls[i];
                    //Console.WriteLine("msIl:" + msIl.OpCode.Code + ", idx:" + code.Count);

                    string strCode = msIls[i].OpCode.Code.ToString();
                    if (strCode.EndsWith("_S"))
                    {
                        strCode = strCode.Substring(0, strCode.Length - 2);
                    }
                    switch (msIl.OpCode.Code)
                    {
                        case Code.Nop:
                            break;
                        //case Code.Conv_U8:
                        //case Code.Conv_I8:
                        //case Code.Conv_Ovf_I8:
                        //case Code.Conv_Ovf_I8_Un:
                        //case Code.Conv_Ovf_U8:
                        //case Code.Conv_Ovf_U8_Un: // 指令合并
                        //    code.Add(new Core.Instruction
                        //    {
                        //        Code = Core.Code.Conv_I8,
                        //        Operand = 0
                        //    });
                        //    break;
                        case Code.Leave:
                        case Code.Leave_S:
                            var exceptionHandler = findExceptionHandler(exceptionHandlers,
                                Core.ExceptionHandlerType.Finally, ilOffset[msIl]);
                            int leaveTo = ilOffset[msIl.Operand as Instruction];
                            if (exceptionHandler == null
                                || (exceptionHandler.TryStart <= leaveTo
                                && exceptionHandler.TryEnd > leaveTo)) // 退化成Br
                            {
                                code.Add(new Core.Instruction
                                {
                                    Code = Core.Code.Br,
                                    Operand = leaveTo - ilOffset[msIl]
                                });
                                code.Add(new Core.Instruction //补指令
                                {
                                    Code = Core.Code.Nop,
                                    Operand = 0
                                });
                            }
                            else
                            {
                                code.Add(new Core.Instruction
                                {
                                    Code = Core.Code.Leave,
                                    Operand = leaveTo
                                });
                                code.Add(new Core.Instruction
                                {
                                    Code = Core.Code.Br,
                                    Operand = exceptionHandler.HandlerStart - (ilOffset[msIl] + 1)
                                });
                            }
                            break;
                        case Code.Endfinally:
                            {
                                int nextIdx;
                                int os = ilOffset[msIl];
                                //int idx = -1;
                                //for (int j = 0; j < exceptionHandlers.Length; j++)
                                //{
                                //    if (exceptionHandlers[j].HandlerEnd == os + 1)
                                //    {
                                //        idx = j;
                                //    }
                                //}
                                //if (idx == -1)
                                //{
                                //    throw new InvalidProgramException("can not find finally block!");
                                //}
                                findExceptionHandler(exceptionHandlers, Core.ExceptionHandlerType.Finally, os,
                                    out nextIdx);
                                code.Add(new Core.Instruction
                                {
                                    Code = Core.Code.Endfinally,
                                    Operand = nextIdx // -1表示最外层
                                });
                            }
                            break;
                        case Code.Br:
                        case Code.Br_S:
                        case Code.Brtrue:
                        case Code.Brtrue_S:
                        case Code.Brfalse:
                        case Code.Brfalse_S:
                        case Code.Beq:
                        case Code.Beq_S:
                        case Code.Bne_Un:
                        case Code.Bne_Un_S:
                        case Code.Bge:
                        case Code.Bge_S:
                        case Code.Bge_Un:
                        case Code.Bge_Un_S:
                        case Code.Bgt:
                        case Code.Bgt_S:
                        case Code.Bgt_Un:
                        case Code.Bgt_Un_S:
                        case Code.Ble:
                        case Code.Ble_S:
                        case Code.Ble_Un:
                        case Code.Ble_Un_S:
                        case Code.Blt:
                        case Code.Blt_S:
                        case Code.Blt_Un:
                        case Code.Blt_Un_S:
                            strCode = msIls[i].OpCode.Code.ToString();
                            if (strCode.EndsWith("_S"))
                            {
                                strCode = strCode.Substring(0, strCode.Length - 2);
                            }
                            code.Add(new Core.Instruction
                            {
                                Code = (Core.Code)Enum.Parse(typeof(Core.Code), strCode),
                                Operand = ilOffset[msIl.Operand as Instruction] - ilOffset[msIl]
                            });
                            //if (msIl.OpCode.Code == Code.Br_S || msIl.OpCode.Code == Code.Br)
                            //{
                            //    Console.WriteLine("il:" + msIl + ",jump to:" + msIl.Operand);
                            //    Console.WriteLine("il pos:" + ilOffset[msIl] + ",jump to pos:" 
                            //        + ilOffset[msIl.Operand as Instruction]);
                            //}
                            break;
                        case Code.Ldc_I8:
                            code.Add(new Core.Instruction
                            {
                                Code = Core.Code.Ldc_I8,
                                Operand = 0
                            });

                            *((long*)&operand) = (long)msIl.Operand;
                            code.Add(operand);
                            break;
                        case Code.Ldc_R8:
                            code.Add(new Core.Instruction
                            {
                                Code = Core.Code.Ldc_R8,
                                Operand = 0
                            });

                            *((double*)&operand) = (double)msIl.Operand;
                            code.Add(operand);
                            break;
                        case Code.Ldc_I4:
                        case Code.Ldc_I4_S:
                            code.Add(new Core.Instruction
                            {
                                Code = Core.Code.Ldc_I4,
                                Operand = Convert.ToInt32(msIl.Operand)
                            });
                            break;
                        case Code.Ldc_R4:
                            {
                                float val = (float)msIl.Operand;
                                code.Add(new Core.Instruction
                                {
                                    Code = Core.Code.Ldc_R4,
                                    Operand = *(int*)&val
                                });
                            }
                            break;
                        case Code.Stloc:
                        case Code.Stloc_S:
                        case Code.Ldloc:
                        case Code.Ldloc_S:
                        case Code.Ldloca:
                        case Code.Ldloca_S:
                            code.Add(new Core.Instruction
                            {
                                Code = (Core.Code)Enum.Parse(typeof(Core.Code), strCode),
                                Operand = (msIl.Operand as VariableDefinition).Index
                            });
                            break;
                        case Code.Ldarg_S:
                        case Code.Ldarg:
                        case Code.Ldarga:
                        case Code.Ldarga_S:
                        case Code.Starg:
                        case Code.Starg_S:
                            code.Add(new Core.Instruction
                            {
                                Code = (Core.Code)Enum.Parse(typeof(Core.Code), strCode),
                                Operand = (msIl.Operand as ParameterDefinition).Index + (method.IsStatic ? 0 : 1)
                            });
                            break;
                        case Code.Ldarg_0:
                        case Code.Ldarg_1:
                        case Code.Ldarg_2:
                        case Code.Ldarg_3:
                            code.Add(new Core.Instruction
                            {
                                Code = Core.Code.Ldarg,
                                Operand = int.Parse(strCode.Substring(strCode.Length - 1)),
                            });
                            break;
                        case Code.Ldloc_0:
                        case Code.Ldloc_1:
                        case Code.Ldloc_2:
                        case Code.Ldloc_3:
                            code.Add(new Core.Instruction
                            {
                                Code = Core.Code.Ldloc,
                                Operand = int.Parse(strCode.Substring(strCode.Length - 1)),
                            });
                            break;
                        case Code.Stloc_0:
                        case Code.Stloc_1:
                        case Code.Stloc_2:
                        case Code.Stloc_3:
                            code.Add(new Core.Instruction
                            {
                                Code = Core.Code.Stloc,
                                Operand = int.Parse(strCode.Substring(strCode.Length - 1)),
                            });
                            break;
                        case Code.Ldc_I4_0:
                        case Code.Ldc_I4_1:
                        case Code.Ldc_I4_2:
                        case Code.Ldc_I4_3:
                        case Code.Ldc_I4_4:
                        case Code.Ldc_I4_5:
                        case Code.Ldc_I4_6:
                        case Code.Ldc_I4_7:
                        case Code.Ldc_I4_8:
                            code.Add(new Core.Instruction
                            {
                                Code = Core.Code.Ldc_I4,
                                Operand = int.Parse(strCode.Substring(strCode.Length - 1)),
                            });
                            break;
                        case Code.Ldc_I4_M1:
                            code.Add(new Core.Instruction
                            {
                                Code = Core.Code.Ldc_I4,
                                Operand = -1,
                            });
                            break;
                        case Code.Ret:
                            code.Add(new Core.Instruction
                            {
                                Code = Core.Code.Ret,
                                Operand = callee.ReturnType.ToString() == "System.Void" ? 0 : 1,
                            });
                            break;
                        case Code.Newobj:
                        case Code.Callvirt:
                        case Code.Call:
                            {
                                if (typeofDetected)
                                {
                                    typeofDetected = false;
                                    code.Add(new Core.Instruction
                                    {
                                        Code = Core.Code.Nop,
                                        Operand = 0,
                                    });
                                    break;
                                }
                                var methodToCall = msIl.Operand as MethodReference;
                                if (methodToCall.ReturnType.IsByReference)
                                {
                                    Console.WriteLine("Warning: method returning ByRef type is not supported. caller={0} callee={1}", 
                                        method.FullName,
                                        methodToCall.FullName);
                                }
                                if (msIl.OpCode.Code == Code.Newobj && (isCompilerGeneratedPlainObject(
                                    methodToCall.DeclaringType) || isCustomClassPlainObject(methodToCall.DeclaringType)))
                                {
                                    TypeDefinition td = methodToCall.DeclaringType as TypeDefinition;
                                    var anonymousCtorInfo = getMethodId(methodToCall, method, false, false,
                                        injectTypePassToNext);
                                    if (anonymousCtorInfo.Type != CallType.Internal)
                                    {
                                        throw new InvalidProgramException("Newobj for " + td);
                                    }
                                    //Console.WriteLine("")
                                    code.Add(new Core.Instruction
                                    {
                                        Code = Core.Code.Newanon,
                                        Operand = addAnonymousCtor(methodToCall as MethodDefinition)
                                    });
                                    break;
                                }

                                MethodDefinition or = null;
                                var lastInstruction = code.Last();
                                if (lastInstruction.Code == Core.Code.Constrained)
                                {
                                    var constrainedType = externTypes[lastInstruction.Operand];
                                    var hasOverrideMethod = false;
                                    if (constrainedType.IsValueType && constrainedType is TypeDefinition)
                                    {
                                        or = findOverride(constrainedType as TypeDefinition, methodToCall);
                                        if (or != null)
                                        {
                                            methodToCall = or;
                                            code[code.Count - 1] = new Core.Instruction
                                            {
                                                Code = Core.Code.Nop,
                                                Operand = 0,
                                            };
                                            hasOverrideMethod = true;
                                        }
                                    }
                                    if (constrainedType.IsValueType && !hasOverrideMethod)
                                    {
                                        code[code.Count - 2] = new Core.Instruction
                                        {
                                            Code = Core.Code.Nop,
                                            Operand = methodToCall.Parameters.Count,
                                        };
                                    }
                                    //code.RemoveAt(code.Count - 1);
                                }
                                int paramCount = (methodToCall.Parameters.Count + (msIl.OpCode.Code != Code.Newobj 
                                    && methodToCall.HasThis ? 1 : 0));
                                var methodIdInfo = getMethodId(methodToCall, method, msIl.OpCode.Code == Code.Callvirt, or != null || directCallVirtual,
                                    injectTypePassToNext);

                                if (msIl.OpCode.Code == Code.Call && baseProxys.ContainsKey(methodToCall))
                                {
                                    var baseProxy = findProxy(method.DeclaringType, methodToCall);
                                    if (baseProxy == null) throw new Exception("can not find the proxy for " + methodToCall + ", in " + method.DeclaringType);
                                    code.Add(new Core.Instruction
                                    {
                                        Code = Core.Code.CallExtern,
                                        Operand = (paramCount << 16) | addExternMethod(baseProxy, method)
                                    });
                                }
                                else if (methodIdInfo.Type == CallType.Internal)
                                {
                                    code.Add(new Core.Instruction
                                    {
                                        Code = (or != null) ? Core.Code.Call :
                                            (Core.Code)Enum.Parse(typeof(Core.Code), strCode),
                                        Operand = (paramCount << 16) | methodIdInfo.Id
                                    });
                                    if (msIl.OpCode.Code == Code.Newobj)
                                    {
                                        throw new InvalidProgramException("Newobj's Operand is not a constructor?");
                                    }
                                }
                                else if (methodIdInfo.Type == CallType.Extern)
                                {
                                    code.Add(new Core.Instruction
                                    {
                                        Code = msIl.OpCode.Code == Code.Newobj ? Core.Code.Newobj :
                                            Core.Code.CallExtern,
                                        Operand = (paramCount << 16) | methodIdInfo.Id
                                    });
                                }
                                else if (methodIdInfo.Type == CallType.InteralVirtual)
                                {
                                    if ((methodToCall as MethodDefinition).IsVirtual)
                                    {
                                        int idx = -1;
                                        if(!virtualMethodToIndex.TryGetValue(methodToCall,out idx))
                                        {
                                            idx = virtualMethodInVTableIndex(methodToCall as MethodDefinition);
                                        }
                                        code.Add(new Core.Instruction
                                        {
                                            Code = Core.Code.Callvirtvirt,
                                            Operand = (paramCount << 16) | idx
                                        });
                                    }
                                    else
                                    {
                                        code.Add(new Core.Instruction
                                        {
                                            Code = (or != null) ? Core.Code.Call :
                                            (Core.Code)Enum.Parse(typeof(Core.Code), strCode),
                                            Operand = (paramCount << 16) | methodToId[method]
                                        });
                                        if (msIl.OpCode.Code == Code.Newobj)
                                        {
                                            throw new InvalidProgramException("Newobj's Operand is not a constructor?");
                                        }
                                    }
                                }
                                else
                                {
                                    throw new InvalidProgramException("call a generic method definition");
                                }
                            }
                            break;
                        case Code.Ldftn:
                        case Code.Ldvirtftn:
                            {
                                var methodToCall = msIl.Operand as MethodReference;
                                var methodIdInfo = getMethodId(methodToCall, method, msIl.OpCode.Code == Code.Ldvirtftn, false, injectTypePassToNext);
                                if (methodIdInfo.Type == CallType.Internal
                                    && (isCompilerGeneratedPlainObject(methodToCall.DeclaringType) || isCustomClassPlainObject(methodToCall.DeclaringType))) // closure
                                {
                                    if ((methodToCall as MethodDefinition).IsVirtual)
                                    {
                                        int methodIndex = -1;
                                        if (!virtualMethodToIndex.TryGetValue(methodToCall,out methodIndex))
                                        {
                                            methodIndex = virtualMethodInVTableIndex(methodToCall as MethodDefinition);
                                        }
                                        code.Add(new Core.Instruction
                                        {
                                            Code = Core.Code.Ldvirtftn2,
                                            Operand = methodIndex
                                        });
                                        break;

                                    }
                                    //Console.WriteLine("closure: " + methodToCall);
                                    getWrapperMethod(wrapperType, anonObjOfWrapper, methodToCall as MethodDefinition,
                                        true, true);
                                    code.Add(new Core.Instruction
                                    {
                                        Code = Core.Code.Ldc_I4,
                                        Operand = methodIdInfo.Id
                                    });
                                    break;
                                }
                                //TODO： 如果生成代码做了delegate的cache怎么办呢？
                                else if (methodIdInfo.Type == CallType.Internal
                                    && (isCompilerGenerated(methodToCall as MethodDefinition)
                                    || isNewMethod(methodToCall as MethodDefinition)) )
                                {
                                    //Console.WriteLine("loadftn for static: " + methodToCall);
                                    getWrapperMethod(wrapperType, anonObjOfWrapper, methodToCall as MethodDefinition,
                                        !(methodToCall as MethodDefinition).IsStatic, true);
                                    code.Add(new Core.Instruction
                                    {
                                        Code = Core.Code.Ldc_I4,
                                        Operand = methodIdInfo.Id
                                    });
                                    break;
                                }
                                else //TODO：如果闭包含不支持的指令怎么办？
                                {
                                    code.Add(new Core.Instruction
                                    {
                                        Code = (Core.Code)Enum.Parse(typeof(Core.Code), strCode),
                                        Operand = addExternMethod(methodToCall, method)
                                    });
                                    break;
                                }
                                //throw new NotImplementedException(msIl.OpCode.Code.ToString() + ":" + msIl.Operand);
                            }
                        //break;
                        case Code.Constrained:
                            code.Add(new Core.Instruction
                            {
                                Code = Core.Code.Nop,
                                Operand = 0,
                            });
                            if ((msIl.Operand as TypeReference).IsValueType)
                            {
                                code.Add(new Core.Instruction
                                {
                                    Code = Core.Code.Constrained,
                                    Operand = addExternType(msIl.Operand as TypeReference)
                                });
                            }
                            else
                            {
                                code.Add(new Core.Instruction
                                {
                                    Code = Core.Code.Ldind_Ref,
                                    Operand = 0
                                });
                            }
                            break;
                        case Code.Box:
                        case Code.Unbox_Any:
                        case Code.Unbox:
                        case Code.Castclass:
                        case Code.Isinst:
                            code.Add(new Core.Instruction
                            {
                                Code = (Core.Code)Enum.Parse(typeof(Core.Code), strCode),
                                Operand = isNewClass(msIl.Operand as TypeDefinition) ? 
                                    -addAnonymousCtor(null, msIl.Operand as TypeReference) - 1
                                    : addExternType(msIl.Operand as TypeReference)
                            });
                            break;
                        case Code.Newarr:
                        case Code.Ldelema:
                        case Code.Initobj:
                        case Code.Ldobj:
                        case Code.Stobj:
                            code.Add(new Core.Instruction
                            {
                                Code = (Core.Code)Enum.Parse(typeof(Core.Code), strCode),
                                Operand = addExternType(msIl.Operand as TypeReference)
                            });
                            break;
                        case Code.Stfld:
                        case Code.Ldfld:
                        case Code.Ldflda:
                            {
                                var field = msIl.Operand as FieldReference;
                                if (isCompilerGenerated(field.DeclaringType) || isCompilerGeneratedPlainObject(field.DeclaringType) || isCustomClassPlainObject(field.DeclaringType))
                                {
                                    var declaringType = field.DeclaringType as TypeDefinition;
                                    int baseFieldCount = 0;
                                    var temp = declaringType;
                                    while (temp.BaseType != null && isNewClass(temp.BaseType as TypeDefinition))
                                    {
                                        baseFieldCount += (temp.BaseType as TypeDefinition).Fields.Count;
                                        temp = temp.BaseType as TypeDefinition;
                                    }
                                    code.Add(new Core.Instruction
                                    {
                                        Code = (Core.Code)Enum.Parse(typeof(Core.Code), strCode),
                                        Operand = -(declaringType.Fields.IndexOf(field as FieldDefinition) + baseFieldCount + 1)
                                    });
                                    //Console.WriteLine("anon obj field:" + field + ",idx:" +
                                    //    declaringType.Fields.IndexOf(field as FieldDefinition));
                                }
                                else
                                {
                                    code.Add(new Core.Instruction
                                    {
                                        Code = (Core.Code)Enum.Parse(typeof(Core.Code), strCode),
                                        Operand = addRefField(field, method)
                                    });
                                }
                            }
                            break;
                        case Code.Stsfld:
                        case Code.Ldsfld:
                        case Code.Ldsflda:
                            var fr = msIl.Operand as FieldReference;
                            var fd = fr.Resolve();
                            bool storeInVitualMachine = (isCompilerGenerated(fr)
                                || isCompilerGenerated(fr.DeclaringType) || isNewClass(fr.DeclaringType as TypeDefinition)) &&
                                !getSpecialGeneratedFields(fr.DeclaringType.Resolve()).Contains(fd)
                                && typeToCctor[fd.DeclaringType] > -2;
                            if (!storeInVitualMachine && isCompilerGenerated(fr) && fd.Name.IndexOf("$cache") >= 0
                                && fd.FieldType.Resolve().IsDelegate())
                            {
                                storeInVitualMachine = true;
                            }
                            code.Add(new Core.Instruction
                            {
                                Code = (Core.Code)Enum.Parse(typeof(Core.Code), strCode),
                                Operand = storeInVitualMachine ? addStoreField(fd, method)
                                    : addRefField(msIl.Operand as FieldReference, method)
                            });
                            break;
                        case Code.Ldstr:
                            code.Add(new Core.Instruction
                            {
                                Code = Core.Code.Ldstr,
                                Operand = addInternString(msIls[i].Operand as string, method)
                            });
                            break;
                        case Code.Ldtoken:
                            if (msIls[i].Next != null && msIls[i].Next.OpCode.Code == Code.Call)
                            {
                                var m = msIls[i].Next.Operand as MethodReference;
                                if (m.Name == "GetTypeFromHandle" && m.DeclaringType.IsSameType(
                                    assembly.MainModule.ImportReference(typeof(Type))))
                                {
                                    code.Add(new Core.Instruction
                                    {
                                        Code = Core.Code.Ldtype,
                                        Operand = addExternType(msIls[i].Operand as TypeReference)
                                    });
                                    typeofDetected = true;
                                    break;
                                }
                            }
                            code.Add(new Core.Instruction
                            {
                                Code = Core.Code.Ldtoken,
                                Operand = addExternType(msIls[i].Operand as TypeReference)
                            });
                            break;
                        case Code.Switch:
                            Instruction[] jmpTargets = msIls[i].Operand as Instruction[];
                            code.Add(new Core.Instruction
                            {
                                Code = Core.Code.Switch,
                                Operand = jmpTargets.Length
                            });
                            //Console.WriteLine("jmpTargets.Length:" + jmpTargets.Length);
                            for (int j = 0; j < jmpTargets.Length; j++)
                            {
                                int diffOffset = ilOffset[jmpTargets[j]] - ilOffset[msIl];
                                //Console.WriteLine("jmp " + j + " :" + diffOffset);
                                if ((j % 2) == 0)
                                {
                                    *((int*)&operand) = diffOffset;
                                }
                                else
                                {
                                    *(((int*)&operand) + 1) = diffOffset;
                                    //Console.WriteLine("two jump table");
                                    code.Add(operand);
                                }
                            }
                            if ((jmpTargets.Length % 2) == 1)
                            {
                                *(((int*)&operand) + 1) = 0;
                                //Console.WriteLine("two jump table--");
                                code.Add(operand);
                            }
                            break;
                        default:
                            code.Add(new Core.Instruction
                            {
                                Code = (Core.Code)Enum.Parse(typeof(Core.Code), strCode),
                                Operand = 0
                            });
                            break;

                    }
                }

                if (mode == ProcessMode.Patch && methodToInjectType.TryGetValue(method, out injectType)
                    && injectType == InjectType.Switch)
                {
                    addInterpretMethod(method, methodId);
                    Console.WriteLine("patched: " + method);
                }
            }
            catch(Exception e)
            {
                if (mode == ProcessMode.Inject)
                {
                    Console.WriteLine("Warning: process " + method + " il throw " + e);
                }
                else
                {
                    throw e;
                }
            }

            //Console.WriteLine("process finish:" + method);
            if (mode == ProcessMode.Inject)
            {
                injectMethod(method, methodId);
            }

            if (!directCallVirtual && method.IsVirtual && isCallvirt)
            {
                if (isNewClass(method.DeclaringType))
                {
                    return new MethodIdInfo()
                    {
                        Id = virtualMethodInVTableIndex(method),
                        Type = CallType.InteralVirtual
                    };
                }
                else
                {
                    return new MethodIdInfo()
                    {
                        Id = addExternMethod(callee, caller),
                        Type = CallType.Extern
                    };
                }
            }
            else
            {
                return new MethodIdInfo()
                {
                    Id = methodId,
                    Type = CallType.Internal
                };
            }
        }

        public enum ProcessResult
        {
            OK,
            Processed
        }

        AssemblyDefinition assembly;

        private TypeReference objType;
        private TypeReference voidType;
        private TypeDefinition wrapperType;
        private TypeDefinition idMapType;
        private TypeReference enumType;
        private List<TypeDefinition> idMapList;
        private TypeDefinition itfBridgeType;
        private int bridgeMethodId;
        private TypeReference anonymousStoreyTypeRef;
        private MethodReference anonymousStoreyCtorRef;

        private FieldDefinition virualMachineFieldOfWrapper;
        private FieldReference virualMachineFieldOfBridge;
        private FieldDefinition methodIdFieldOfWrapper;
        private FieldDefinition anonObjOfWrapper;
        private FieldDefinition wrapperArray;
        private MethodDefinition ctorOfWrapper;
        private MethodDefinition getPatch;
        private MethodDefinition isPatched;
        private MethodDefinition createDelegate;

        private TypeReference Call_Ref;
        private MethodReference Call_Begin_Ref;
        private MethodReference Call_PushRef_Ref;
        private MethodReference Call_GetAsType_Ref;

        private TypeReference VirtualMachineType;
        private TypeReference WrappersManagerType;
        private TypeDefinition wrapperMgrImpl;
        private MethodDefinition ctorOfWrapperMgrImpl;
        private MethodReference VirtualMachine_Execute_Ref;

        private MethodReference Utils_TryAdapterToDelegate_Ref;

        private MethodReference idTagCtor_Ref;

        private List<MethodDefinition> wrapperMethods;

        private Dictionary<TypeReference, MethodReference> pushMap =
            new Dictionary<TypeReference, MethodReference>();

        private Dictionary<TypeReference, MethodReference> getMap =
            new Dictionary<TypeReference, MethodReference>();

        private Dictionary<string, TypeReference> nameToTypeReference =
            new Dictionary<string, TypeReference>();

        private MethodReference Call_PushValueType_Ref;
        TypeReference wrapperParamerterType(TypeReference type)
        {
            if (type.IsByReference)
            {
                return type;
            }
            if (type.IsValueType)
            {
                return type;
            }
            return objType;
        }

        TypeReference getRawType(TypeReference type)
        {
            return type.IsByReference ? ((ByReferenceType)type).ElementType : type;
        }

        private List<MethodDefinition> anonymousTypeInfos = new List<MethodDefinition>();
        private Dictionary<MethodDefinition, int> anonymousTypeToId = new Dictionary<MethodDefinition, int>();

        int addAnonymousCtor(MethodDefinition ctor, TypeReference variableType = null)
        {
            int id;
            var ctorOrMethod = ctor != null ? ctor : (variableType as TypeDefinition).Methods[0];
            if (anonymousTypeToId.TryGetValue(ctorOrMethod, out id))
            {
                return id;
            }
            var typeDefinition = ctor != null ? (ctor.DeclaringType as TypeDefinition) : (variableType as TypeDefinition);
            addInterfacesOfTypeToBridge(typeDefinition);
            var methods = typeDefinition.Methods.Where(m => !m.IsConstructor).ToList();
            if(variableType != null || ctor.DeclaringType.Fields.Count > 0)
            {
                for (int field = 0; field < typeDefinition.Fields.Count; field++)
                {
                    if (typeDefinition.Fields[field].FieldType.IsValueType)
                    {
                        if (!isCompilerGenerated(typeDefinition.Fields[field].FieldType))
                        {
                            if (!externTypes.Contains(typeDefinition.Fields[field].FieldType))
                            {
                                addExternType(typeDefinition.Fields[field].FieldType);
                            }
                        }
                    }
                }
            }

            foreach (var method in methods)
            {
                getMethodId(method, null,true, true, InjectType.Redirect);
            }
            id = anonymousTypeInfos.Count;
            var methodDefinition = ctor != null ? ctor : methods[0];
            anonymousTypeInfos.Add(methodDefinition);
            anonymousTypeToId[methodDefinition] = id;
            return id;
        }

        Dictionary<MethodReference, int> interfaceSlot = new Dictionary<MethodReference, int>();
        Dictionary<MethodDefinition, MethodReference> implementMap
            = new Dictionary<MethodDefinition, MethodReference>();

        List<TypeReference> bridgeInterfaces = new List<TypeReference>();
        void bridgeImplement(TypeReference itf)
        {
            if (bridgeInterfaces.Any(item => item.AreEqualIgnoreAssemblyVersion(itf))) return;
            addExternType(itf);
            bridgeInterfaces.Add(itf);
            itfBridgeType.Interfaces.Add(new InterfaceImplementation(itf));
        }

        /// <summary>
        /// 桥接器实现一个类的所有接口，一般来说是个匿名类
        /// </summary>
        /// <param name="anonType">要实现桥接的匿名类</param>
        void addInterfacesOfTypeToBridge(TypeDefinition anonType)
        {
            if (anonType.Interfaces.Count == 0)
            {
                return;
            }
            List<TypeReference> toImplement = new List<TypeReference>();
            //Console.WriteLine("begin type:" + anonType);
            foreach (var method in anonType.Methods.Where(m => !m.IsConstructor))
            {
                MethodReference matchItfMethod = null;
                //Console.WriteLine("method:" + method);
                if (method.Overrides.Count == 1)
                {
                    matchItfMethod = method.Overrides[0];
                    implementMap[method] = matchItfMethod;
                    if (itfBridgeType.Interfaces.Any(ii => ii.InterfaceType.IsSameType(matchItfMethod.DeclaringType)))
                    {
                        continue;
                    }
                }
                else if (method.IsPublic)
                {
                    //var m = MetadataResolver.GetMethod(or.DeclaringType.Resolve().Methods, method);
                    foreach(var itf in anonType.Interfaces.Select(ii => ii.InterfaceType))
                    {
                        matchItfMethod = itf.FindMatch(method);
                        if (matchItfMethod != null) break;
                    }
                    
                    //implementMap[method] = matchItfMethod;
                    if (matchItfMethod == null || itfBridgeType.Interfaces.Any(ii => ii.InterfaceType.IsSameType(matchItfMethod.DeclaringType)))
                    {
                        continue;
                    }
                }
                else //Enumerator 语法糖里头再有个闭包语法糖，会在类那生成一个非私有，非公有的函数
                {
                    continue;
                }

                if (matchItfMethod != null)
                {
                    toImplement.Add(matchItfMethod.DeclaringType);
                    //Console.WriteLine("add slot " + matchItfMethod + ",m=" + method);
                    interfaceSlot.Add(matchItfMethod, bridgeMethodId);
                    var impl = getWrapperMethod(itfBridgeType, null, method, false, true, true, bridgeMethodId);
                    addIDTag(impl, bridgeMethodId++);
                    impl.Overrides.Add(matchItfMethod);
                }

            }

            //Console.WriteLine("end type:" + anonType);

            foreach (var itf in toImplement.Distinct())
            {
                bridgeImplement(itf);
            }
            //foreach (var itf in anonType.Interfaces.Select(ii => ii.InterfaceType))
            //{
            //    if (itfBridgeType.Interfaces.Any(ii => ii.InterfaceType.IsSameType(itf)))
            //    {
            //        continue;
            //    }
            //    foreach(var method in itf.Resolve().Methods)
            //    {
            //        interfaceSlot.Add(method, bridgeMethodId);
            //        var impl = getWrapperMethod(itfBridgeType, null, method, false, true, true, bridgeMethodId++);
            //        impl.Overrides.Add(method);
            //    }
            //}
        }

        void addInterfaceToBridge(TypeReference itf)
        {
            var itfDef = itf.Resolve();
            if (!itfDef.IsInterface
                || itf.HasGenericParameters
                || itfBridgeType.Interfaces.Any(ii => ii.InterfaceType.FullName == itf.FullName)
                || itfDef.Methods.Any(m => m.HasGenericParameters))
            {
                return;
            }
            foreach(var method in itfDef.Methods)
            {
                var methodToImpl = itf.IsGenericInstance ? method.MakeGeneric(itf) : method.TryImport(itf.Module);
                interfaceSlot.Add(methodToImpl, bridgeMethodId);
                var impl = getWrapperMethod(itfBridgeType, null, methodToImpl, false, true, true, bridgeMethodId);
                addIDTag(impl, bridgeMethodId++);
                impl.Overrides.Add(methodToImpl);
            }
            bridgeImplement(itf);
            foreach (var ii in itfDef.Interfaces)
            {
                addInterfaceToBridge(ii.InterfaceType.FillGenericArgument(null, itf).TryImport(itf.Module));
            }
        }

        void EmitRefAwaitUnsafeOnCompletedMethod()
        {
            MethodDefinition targetMethod = new MethodDefinition("RefAwaitUnsafeOnCompleteMethod",
                Mono.Cecil.MethodAttributes.Public, assembly.MainModule.TypeSystem.Void);
            var instructions = targetMethod.Body.Instructions;
            var localBridge = new VariableDefinition(itfBridgeType);
            targetMethod.Body.Variables.Add(localBridge);
            for (int j = 0;j < awaitUnsafeOnCompletedMethods.Count;j++)
            {
                var localTaskAwaiter = new VariableDefinition(((GenericInstanceMethod)awaitUnsafeOnCompletedMethods[j]).GenericArguments[0]);
                targetMethod.Body.Variables.Add(localTaskAwaiter);
                var localAsync = new VariableDefinition(awaitUnsafeOnCompletedMethods[j].DeclaringType);
                targetMethod.Body.Variables.Add(localAsync);
                instructions.Add(Instruction.Create(OpCodes.Ldloca_S, localAsync));
                instructions.Add(Instruction.Create(OpCodes.Ldloca_S, localTaskAwaiter));
                instructions.Add(Instruction.Create(OpCodes.Ldloca_S, localBridge));
                instructions.Add(Instruction.Create(OpCodes.Call, makeGenericMethod(awaitUnsafeOnCompletedMethods[j].GetElementMethod(), ((GenericInstanceMethod)awaitUnsafeOnCompletedMethods[j]).GenericArguments[0], itfBridgeType)));
            }
            instructions.Add(Instruction.Create(OpCodes.Ret));
            itfBridgeType.Methods.Add(targetMethod);
        }

        private void EmitAsyncBuilderStartMethod(IEnumerable<TypeDefinition> allTypes)
        {
            var builders        = new List<TypeReference>();
            var genericBuilders = new List<TypeReference>();

            // 找到所有异步方法的builder
            foreach(var typeDefinition in allTypes)
            {
                foreach(var nestedType in typeDefinition.NestedTypes)
                {
                    try
                    {
                        var isStateMachine =
                            nestedType.Interfaces.Any(e => e.InterfaceType.Name == "IAsyncStateMachine");

                        if(!isStateMachine)
                            continue;

                        var builder     = nestedType.Fields.First(e => e.Name.EndsWith("builder"));
                        var builderType = builder.FieldType;

                        if(builderType.ContainsGenericParameter)
                            continue;

                        if(!builderType.IsValueType)
                            continue;

                        if(builderType.IsGenericInstance)
                        {
                            if(genericBuilders.Any(e => ((GenericInstanceType) e).GenericArguments[0]
                                                     == ((GenericInstanceType) builderType).GenericArguments[0]))
                                continue;

                            genericBuilders.Add(builderType);
                        }
                        else
                        {
                            if(builders.Contains(builderType))
                                continue;

                            builders.Add(builderType);
                        }
                    }
                    catch (Exception e)
                    {
                        Console.WriteLine("Warning: get builder in " + typeDefinition + " throw: " + e);
                    }
                }
            }

            // 生成Start函数引用
            builders.AddRange(genericBuilders);

            var targetMethod = new MethodDefinition("RefAsyncBuilderStartMethod", MethodAttributes.Public,
                assembly.MainModule.TypeSystem.Void);
            var instructions = targetMethod.Body.Instructions;
            var localBridge  = new VariableDefinition(itfBridgeType);
            targetMethod.Body.Variables.Add(localBridge);

            foreach(var builder in builders)
            {
                var start = new MethodReference("Start", voidType, builder)
                            {
                                HasThis = true, CallingConvention = MethodCallingConvention.Generic
                            };
                var genericParameter = new GenericParameter("!!0", start);
                start.GenericParameters.Add(genericParameter);
                var byReferenceType = new ByReferenceType(genericParameter);
                start.Parameters.Add(new ParameterDefinition(byReferenceType));

                var localBuilder = new VariableDefinition(builder);
                targetMethod.Body.Variables.Add(localBuilder);

                instructions.Add(Instruction.Create(OpCodes.Ldloca_S, localBuilder));
                instructions.Add(Instruction.Create(OpCodes.Ldloca_S, localBridge));
                instructions.Add(Instruction.Create(OpCodes.Call, makeGenericMethod(start, itfBridgeType)));
            }

            instructions.Add(Instruction.Create(OpCodes.Ret));
            itfBridgeType.Methods.Add(targetMethod);
        }


        /// <summary>
        /// 获取一个方法的适配器
        /// </summary>
        /// <param name="type">方法适配器的放置类</param>
        /// <param name="anonObj">适配器所绑定的匿名对象</param>
        /// <param name="method">要适配的方法</param>
        /// <param name="isClosure">是不是闭包</param>
        /// <param name="noBaselize">是否向基类收敛（如果是delegate适配器，就不能收敛）</param>
        /// <param name="isInterfaceBridge">是否是接口桥接器</param>
        /// <param name="mid">方法id</param>
        /// <returns></returns>
        // #lizard forgives
        MethodDefinition getWrapperMethod(TypeDefinition type, FieldDefinition anonObj, MethodReference method,
            bool isClosure, bool noBaselize, bool isInterfaceBridge = false, int mid = -1)
        {
            MethodDefinition md = method as MethodDefinition;
            if(md == null)
            {
                md = method.Resolve();
            }
            //原始参数类型
            List<TypeReference> parameterTypes = new List<TypeReference>();
            //适配器参数类型，不是强制noBaselize的话，引用类型，复杂非引用值类型，均转为object
            List<TypeReference> wrapperParameterTypes = new List<TypeReference>();
            List<bool> isOut = new List<bool>();
            List<bool> isIn = new List<bool>();
            //List<ParameterAttributes> paramAttrs = new List<ParameterAttributes>();
            if (!md.IsStatic && !isClosure && !isInterfaceBridge) //匿名类闭包的this是自动传，不需要显式参数
            {
                isOut.Add(false);
                isIn.Add(false);
                //paramAttrs.Add(Mono.Cecil.ParameterAttributes.None);
                if (method.DeclaringType.IsValueType)
                {
                    var dt = new ByReferenceType(method.DeclaringType);
                    parameterTypes.Add(dt);
                    wrapperParameterTypes.Add(dt);
                }
                else
                {
                    parameterTypes.Add(method.DeclaringType);
                    wrapperParameterTypes.Add(noBaselize ? method.DeclaringType
                        : wrapperParamerterType(method.DeclaringType));
                }
            }

            for (int i = 0; i < method.Parameters.Count; i++)
            {
                isOut.Add(method.Parameters[i].IsOut);
                isIn.Add(method.Parameters[i].IsIn);
                //paramAttrs.Add(method.Parameters[i].Attributes);
                var paramType = method.Parameters[i].ParameterType;
                if (paramType.IsGenericParameter)
                {
                    paramType = (paramType as GenericParameter).ResolveGenericArgument(method.DeclaringType);
                }
                if (paramType.IsRequiredModifier)
                {
                    paramType = (paramType as RequiredModifierType).ElementType;
                }
                parameterTypes.Add(paramType);
                wrapperParameterTypes.Add(noBaselize ? paramType : wrapperParamerterType(paramType));
            }

            var returnType = method.ReturnType.FillGenericArgument(method, method.DeclaringType);

            MethodDefinition wrapperMethod;

            if (isInterfaceBridge)
            {
                var attributes = md.Attributes;
                var methodName = method.Name;
                if (attributes != 0 && ((attributes & MethodAttributes.Abstract) == MethodAttributes.Abstract))
                {
                    attributes = attributes & (~MethodAttributes.Abstract) & (~MethodAttributes.Public)
                        | MethodAttributes.Private;
                    methodName = System.Text.RegularExpressions.Regex.Replace(method.DeclaringType.FullName,
                        @"`\d+", "") + "." + methodName;
                }
                wrapperMethod = new MethodDefinition(methodName, attributes,
                    returnType.TryImport(assembly.MainModule));
            }
            else
            {
                List<MethodDefinition> cacheToCheck = wrapperMethods;
                for (int i = 0; i < cacheToCheck.Count; i++)
                {
                    wrapperMethod = cacheToCheck[i];
                    if (wrapperMethod.Parameters.Count != wrapperParameterTypes.Count
                        || !wrapperMethod.ReturnType.IsSameType(returnType))
                    {
                        continue;
                    }
                    bool paramMatch = true;
                    for (int j = 0; j < wrapperParameterTypes.Count; j++)
                    {
                        if (!wrapperParameterTypes[j].IsSameType(wrapperMethod.Parameters[j].ParameterType)
                            || isOut[j] != wrapperMethod.Parameters[j].IsOut || isIn[j] != wrapperMethod.Parameters[j].IsIn)
                        {
                            paramMatch = false;
                            break;
                        }
                    }
                    if (!paramMatch)
                    {
                        continue;
                    }
                    return wrapperMethod;
                }
                wrapperMethod = new MethodDefinition(Wrap_Perfix + cacheToCheck.Count,
                    Mono.Cecil.MethodAttributes.Public, returnType.TryImport(assembly.MainModule));
                cacheToCheck.Add(wrapperMethod);
            }
            var instructions = wrapperMethod.Body.Instructions;

            int refCount = 0;
            int[] refPos = new int[parameterTypes.Count];

            for (int i = 0; i < parameterTypes.Count; i++)
            {
                refPos[i] = (parameterTypes[i].IsByReference) ? refCount++ : -1;
                var parameterAttributes = ParameterAttributes.None;
                if (isOut[i]) parameterAttributes |= ParameterAttributes.Out;
                if (isIn[i]) parameterAttributes |= ParameterAttributes.In;
                wrapperMethod.Parameters.Add(new ParameterDefinition("P" + i, parameterAttributes, wrapperParameterTypes[i].TryImport(assembly.MainModule)));
            }

            var ilProcessor = wrapperMethod.Body.GetILProcessor();

            VariableDefinition call = new VariableDefinition(Call_Ref);
            wrapperMethod.Body.Variables.Add(call);

            instructions.Add(Instruction.Create(OpCodes.Call, Call_Begin_Ref));
            instructions.Add(Instruction.Create(OpCodes.Stloc, call));

            if (refCount > 0)
            {
                for (int i = 0; i < parameterTypes.Count; i++)
                {
                    if (parameterTypes[i].IsByReference)
                    {
                        var paramRawType = tryGetUnderlyingType(getRawType(parameterTypes[i]));
                        if (isOut[i]) // push default
                        {
                            instructions.Add(Instruction.Create(OpCodes.Ldloca_S, call));
                            MethodReference push;
                            var wpt = wrapperParamerterType(paramRawType);
                            wpt = (wpt.IsValueType && !wpt.IsPrimitive) ? objType : wpt;
                            if (pushMap.TryGetValue(wpt, out push))
                            {
                                if (wpt == assembly.MainModule.TypeSystem.Object)
                                {
                                    instructions.Add(Instruction.Create(OpCodes.Ldnull));
                                }
                                else
                                {
                                    instructions.Add(Instruction.Create(OpCodes.Ldc_I4_0));
                                }
                                if (wpt == assembly.MainModule.TypeSystem.Int64
                                    || wpt == assembly.MainModule.TypeSystem.UInt64
                                    || wpt == assembly.MainModule.TypeSystem.IntPtr
                                    || wpt == assembly.MainModule.TypeSystem.UIntPtr)
                                {
                                    instructions.Add(Instruction.Create(OpCodes.Conv_I8));
                                    push = pushMap[assembly.MainModule.TypeSystem.Int64];
                                }
                                else if (wpt == assembly.MainModule.TypeSystem.Single)
                                {
                                    instructions.Add(Instruction.Create(OpCodes.Conv_R4));
                                }
                                else if (wpt == assembly.MainModule.TypeSystem.Double)
                                {
                                    instructions.Add(Instruction.Create(OpCodes.Conv_R8));
                                }
                                else if (wpt == assembly.MainModule.TypeSystem.Object)
                                {
                                    if(paramRawType.IsValueType)
                                    {
                                        push = Call_PushValueType_Ref;
                                    }
                                }
                                else
                                {
                                    push = pushMap[assembly.MainModule.TypeSystem.Int32];
                                }
                            }
                            else
                            {
                                throw new NotImplementedException("no push for " + paramRawType + " at " + method);
                            }
                            instructions.Add(Instruction.Create(OpCodes.Callvirt, push));
                        }
                        else
                        {
                            instructions.Add(Instruction.Create(OpCodes.Ldloca_S, call));
                            emitLdarg(instructions, ilProcessor, i + 1);
                            emitLoadRef(instructions, paramRawType);
                            MethodReference push;
                            if (pushMap.TryGetValue(tryGetUnderlyingType(paramRawType), out push))
                            {
                                instructions.Add(Instruction.Create(OpCodes.Callvirt, push));
                            }
                            else
                            {
                                if (paramRawType.IsValueType)
                                {
                                    instructions.Add(Instruction.Create(OpCodes.Callvirt, Call_PushValueType_Ref));
                                }
                                else
                                {
                                    instructions.Add(Instruction.Create(OpCodes.Callvirt,
                                        pushMap[assembly.MainModule.TypeSystem.Object]));
                                }
                            }
                        }
                    }
                }
            }

            if (isInterfaceBridge)
            {
                instructions.Add(Instruction.Create(OpCodes.Ldloca_S, call));
                instructions.Add(Instruction.Create(OpCodes.Ldarg_0));
                instructions.Add(Instruction.Create(OpCodes.Callvirt, pushMap[assembly.MainModule.TypeSystem.Object]));
            }
            else
            {
                instructions.Add(Instruction.Create(OpCodes.Ldarg_0));
                instructions.Add(Instruction.Create(OpCodes.Ldfld, anonObj));

                var nop = Instruction.Create(OpCodes.Nop);
                instructions.Add(Instruction.Create(OpCodes.Brfalse_S, nop));

                instructions.Add(Instruction.Create(OpCodes.Ldloca_S, call));
                instructions.Add(Instruction.Create(OpCodes.Ldarg_0));
                instructions.Add(Instruction.Create(OpCodes.Ldfld, anonObj));
                instructions.Add(Instruction.Create(OpCodes.Callvirt, pushMap[assembly.MainModule.TypeSystem.Object]));
                instructions.Add(nop);
            }

            for (int i = 0; i < parameterTypes.Count; i++)
            {
                instructions.Add(Instruction.Create(OpCodes.Ldloca_S, call));

                if (parameterTypes[i].IsByReference)
                {
                    emitLdcI4(instructions, refPos[i]);
                    instructions.Add(Instruction.Create(OpCodes.Callvirt, Call_PushRef_Ref));
                }
                else
                {
                    emitLdarg(instructions, ilProcessor, i + 1);
                    var paramRawType = getRawType(wrapperParameterTypes[i]);
                    MethodReference push;
                    if (pushMap.TryGetValue(tryGetUnderlyingType(paramRawType), out push))
                    {
                        instructions.Add(Instruction.Create(OpCodes.Callvirt, push));
                    }
                    else
                    {
                        if (paramRawType.IsValueType)
                        {
                            instructions.Add(Instruction.Create(OpCodes.Box, paramRawType));
                            //Console.WriteLine("Call_PushValueType_Ref for " + method.Name + ", pidx:" + i
                            //    + ", ptype:" + parameterTypes[i] + ", paramRawType:" + paramRawType + ",wrap:"
                            //    + wrapperMethod.Name);
                            instructions.Add(Instruction.Create(OpCodes.Callvirt, Call_PushValueType_Ref));
                        }
                        else
                        {
                            instructions.Add(Instruction.Create(OpCodes.Callvirt,
                                pushMap[assembly.MainModule.TypeSystem.Object]));
                        }
                    }
                }
            }

            instructions.Add(Instruction.Create(OpCodes.Ldarg_0));
            instructions.Add(Instruction.Create(OpCodes.Ldfld, isInterfaceBridge ?
                virualMachineFieldOfBridge : virualMachineFieldOfWrapper));
            if (isInterfaceBridge)
            {
                var methodId = new FieldDefinition(METHODIDPERFIX + mid, FieldAttributes.Private,
                    assembly.MainModule.TypeSystem.Int32);
                type.Fields.Add(methodId);
                instructions.Add(Instruction.Create(OpCodes.Ldarg_0));
                instructions.Add(Instruction.Create(OpCodes.Ldfld, methodId));
            }
            else
            {
                instructions.Add(Instruction.Create(OpCodes.Ldarg_0));
                instructions.Add(Instruction.Create(OpCodes.Ldfld, methodIdFieldOfWrapper));
            }
            instructions.Add(Instruction.Create(OpCodes.Ldloca_S, call));

            var ldci4_ref_count = createLdcI4(refCount);
            if (isInterfaceBridge)
            {
                emitLdcI4(instructions, parameterTypes.Count + 1);
            }
            else
            {
                instructions.Add(Instruction.Create(OpCodes.Ldarg_0));
                instructions.Add(Instruction.Create(OpCodes.Ldfld, anonObj));
                var ldci4_param_count = createLdcI4(parameterTypes.Count + 1);
                instructions.Add(Instruction.Create(OpCodes.Brtrue_S, ldci4_param_count));
                emitLdcI4(instructions, parameterTypes.Count);
                instructions.Add(Instruction.Create(OpCodes.Br_S, ldci4_ref_count));
                instructions.Add(ldci4_param_count);
            }
            instructions.Add(ldci4_ref_count);
            
            instructions.Add(Instruction.Create(OpCodes.Callvirt, VirtualMachine_Execute_Ref));

            if (refCount > 0)
            {

                // Ref param
                for (int i = 0; i < parameterTypes.Count; i++)
                {
                    if (parameterTypes[i].IsByReference && ! isIn[i])
                    {
                        emitLdarg(instructions, ilProcessor, i + 1);
                        var paramRawType = tryGetUnderlyingType(getRawType(parameterTypes[i]));
                        instructions.Add(Instruction.Create(OpCodes.Ldloca_S, call));

                        emitLdcI4(instructions, refPos[i]);
                        if (paramRawType.IsPrimitive && getMap.ContainsKey(paramRawType.Resolve()))
                        {
                            instructions.Add(Instruction.Create(OpCodes.Callvirt, getMap[paramRawType.Resolve()]));
                        }
                        else
                        {
                            instructions.Add(Instruction.Create(OpCodes.Callvirt,
                                makeGenericMethod(Call_GetAsType_Ref, paramRawType)));
                        }
                        emitStoreRef(instructions, paramRawType);
                    }
                }
            }

            if (!returnType.IsSameType(voidType))
            {
                instructions.Add(Instruction.Create(OpCodes.Ldloca_S, call));
                MethodReference get;
                emitLdcI4(instructions, refCount);
                var returnRawType = tryGetUnderlyingType(returnType);
                if (returnRawType.IsPrimitive && getMap.TryGetValue(returnRawType.Resolve(), out get))
                {
                    instructions.Add(Instruction.Create(OpCodes.Callvirt, get));
                }
                else
                {
                    instructions.Add(Instruction.Create(OpCodes.Callvirt,
                        makeGenericMethod(Call_GetAsType_Ref, returnType)));
                }
            }

            instructions.Add(Instruction.Create(OpCodes.Ret));

            type.Methods.Add(wrapperMethod);

            return wrapperMethod;
        }

        void emitLdcI4(Mono.Collections.Generic.Collection<Instruction> instructions, int i)
        {
            instructions.Add(createLdcI4(i));
            
        }

        Instruction createLdcI4(int i)
        {
            if (i < ldc4s.Length && i >= 0)
            {
                return Instruction.Create(ldc4s[i]);
            }
            else if (i == -1)
            {
                return Instruction.Create(OpCodes.Ldc_I4_M1);
            }
            else
            {
                return Instruction.Create(OpCodes.Ldc_I4, i);
            }
        }

        void emitLdarg(Mono.Collections.Generic.Collection<Instruction> instructions, ILProcessor ilProcessor, int i)
        {
            instructions.Add(createLdarg(ilProcessor, i));
        }

        Instruction createLdarg(ILProcessor ilProcessor, int i)
        {
            if (i < ldargs.Length)
            {
                return Instruction.Create(ldargs[i]);
            }
            else if (i < 256)
            {
                return ilProcessor.Create(OpCodes.Ldarg_S, (byte)i);
            }
            else
            {
                return ilProcessor.Create(OpCodes.Ldarg, (short)i);
            }
        }

        TypeReference tryGetUnderlyingType(TypeReference type)
        {
            try
            {
                if (type.IsArray) return type;
                TypeDefinition typeDefinition = type.Resolve();
                if (typeDefinition.IsEnum)
                {
                    var fields = typeDefinition.Fields;
                    for (int i = 0; i < fields.Count; i++)
                    {
                        if (!fields[i].IsStatic)
                            return nameToTypeReference[fields[i].FieldType.FullName];
                    }
                }
            }
            catch { }
            return type;
        }

        //不能直接栈上表示的值类型，都boxing
        void emitLoadRef(Mono.Collections.Generic.Collection<Instruction> instructions, TypeReference type)
        {
            var underlyingTypetype = tryGetUnderlyingType(type);
            OpCode op;
            if (ldinds.TryGetValue(underlyingTypetype, out op))
            {
                instructions.Add(Instruction.Create(op));
                //if (type == assembly.MainModule.TypeSystem.IntPtr
                //    || type == assembly.MainModule.TypeSystem.UIntPtr)
                //{
                //    instructions.Add(Instruction.Create(OpCodes.Box, type));
                //}
            }
            else
            {
                if (type.IsValueType)
                {
                    instructions.Add(Instruction.Create(OpCodes.Ldobj, type));
                    instructions.Add(Instruction.Create(OpCodes.Box, type));
                }
                else
                {
                    instructions.Add(Instruction.Create(OpCodes.Ldind_Ref));
                }
            }
        }

        void emitStoreRef(Mono.Collections.Generic.Collection<Instruction> instructions, TypeReference type)
        {
            var underlyingTypetype = tryGetUnderlyingType(type);
            OpCode op;
            if (stinds.TryGetValue(underlyingTypetype, out op))
            {
                instructions.Add(Instruction.Create(op));
            }
            else
            {
                if (type.IsValueType)
                {
                    instructions.Add(Instruction.Create(OpCodes.Stobj, type));
                }
                else
                {
                    instructions.Add(Instruction.Create(OpCodes.Stind_Ref));
                }
            }
        }

        private OpCode[] ldargs = new OpCode[] { OpCodes.Ldarg_0, OpCodes.Ldarg_1, OpCodes.Ldarg_2, OpCodes.Ldarg_3 };
        private OpCode[] ldc4s = new OpCode[] { OpCodes.Ldc_I4_0, OpCodes.Ldc_I4_1, OpCodes.Ldc_I4_2,
            OpCodes.Ldc_I4_3,OpCodes.Ldc_I4_4, OpCodes.Ldc_I4_5, OpCodes.Ldc_I4_6, OpCodes.Ldc_I4_7 };
        private Dictionary<TypeReference, OpCode> ldinds = null;
        private Dictionary<TypeReference, OpCode> stinds = null;
        private List<MethodDefinition> ObjectVirtualMethodDefinitionList = null;
        private List<MethodReference> objectVirtualMethodReferenceList = null;

        void init(AssemblyDefinition assembly, AssemblyDefinition ilfixAassembly)
        {
            this.assembly = assembly;
            objType = assembly.MainModule.TypeSystem.Object;
            List<string> supportedMethods = new List<string>() { "Equals", "Finalize","GetHashCode", "ToString"};
            ObjectVirtualMethodDefinitionList = (from method in objType.Resolve().Methods where method.IsVirtual && supportedMethods.Contains(method.Name) select method).ToList();
            if (ObjectVirtualMethodDefinitionList.Count != 4)
            {
                throw new InvalidProgramException();
            }
            ObjectVirtualMethodDefinitionList.OrderBy(t => t.FullName);
            for (int methodIdx = 0; methodIdx < ObjectVirtualMethodDefinitionList.Count; methodIdx++)
            {
                virtualMethodToIndex.Add(ObjectVirtualMethodDefinitionList[methodIdx], methodIdx);
            }
            voidType = assembly.MainModule.TypeSystem.Void;

            wrapperType = new TypeDefinition("IFix", DYNAMICWRAPPER, Mono.Cecil.TypeAttributes.Class
                | Mono.Cecil.TypeAttributes.Public, objType);
            assembly.MainModule.Types.Add(wrapperType);

            TypeDefinition VirtualMachine;
            VirtualMachine = ilfixAassembly.MainModule.Types.Single(t => t.Name == "VirtualMachine");
            VirtualMachineType = assembly.MainModule.ImportReference(VirtualMachine);
            WrappersManagerType = assembly.MainModule.ImportReference(
                ilfixAassembly.MainModule.Types.Single(t => t.Name == "WrappersManager"));

            virualMachineFieldOfWrapper = new FieldDefinition("virtualMachine", Mono.Cecil.FieldAttributes.Private,
                    VirtualMachineType);
            wrapperType.Fields.Add(virualMachineFieldOfWrapper);
            methodIdFieldOfWrapper = new FieldDefinition("methodId", Mono.Cecil.FieldAttributes.Private,
                    assembly.MainModule.TypeSystem.Int32);
            wrapperType.Fields.Add(methodIdFieldOfWrapper);
            anonObjOfWrapper = new FieldDefinition("anonObj", Mono.Cecil.FieldAttributes.Private,
                    objType);
            wrapperType.Fields.Add(anonObjOfWrapper);
            wrapperArray = new FieldDefinition("wrapperArray", Mono.Cecil.FieldAttributes.Public
                | Mono.Cecil.FieldAttributes.Static,
                new ArrayType(wrapperType));
            wrapperType.Fields.Add(wrapperArray);

            idTagCtor_Ref = assembly.MainModule.ImportReference(
                ilfixAassembly.MainModule.Types.Single(t => t.Name == "IDTagAttribute")
                .Methods.Single(m => m.Name == ".ctor" && m.Parameters.Count == 1));

            var objEmptyConstructor = assembly.MainModule.ImportReference(objType.Resolve().Methods.
                Single(m => m.Name == ".ctor" && m.Parameters.Count == 0));
            var methodAttributes = MethodAttributes.Public
                | MethodAttributes.HideBySig
                | MethodAttributes.SpecialName
                | MethodAttributes.RTSpecialName;
            ctorOfWrapper = new MethodDefinition(".ctor", methodAttributes, voidType);
            ctorOfWrapper.Parameters.Add(new ParameterDefinition("virtualMachine",
                Mono.Cecil.ParameterAttributes.None, VirtualMachineType));
            ctorOfWrapper.Parameters.Add(new ParameterDefinition("methodId",
                Mono.Cecil.ParameterAttributes.None, assembly.MainModule.TypeSystem.Int32));
            ctorOfWrapper.Parameters.Add(new ParameterDefinition("anonObj",
                Mono.Cecil.ParameterAttributes.None, objType));
            var instructions = ctorOfWrapper.Body.Instructions;
            instructions.Add(Instruction.Create(OpCodes.Ldarg_0));
            instructions.Add(Instruction.Create(OpCodes.Call, objEmptyConstructor));
            instructions.Add(Instruction.Create(OpCodes.Ldarg_0));
            instructions.Add(Instruction.Create(OpCodes.Ldarg_1));
            instructions.Add(Instruction.Create(OpCodes.Stfld, virualMachineFieldOfWrapper));
            instructions.Add(Instruction.Create(OpCodes.Ldarg_0));
            instructions.Add(Instruction.Create(OpCodes.Ldarg_2));
            instructions.Add(Instruction.Create(OpCodes.Stfld, methodIdFieldOfWrapper));
            instructions.Add(Instruction.Create(OpCodes.Ldarg_0));
            instructions.Add(Instruction.Create(OpCodes.Ldarg_3));
            instructions.Add(Instruction.Create(OpCodes.Stfld, anonObjOfWrapper));
            instructions.Add(Instruction.Create(OpCodes.Ret));
            wrapperType.Methods.Add(ctorOfWrapper);

            //begin init itfBridgeType
            bridgeMethodId = 0;
            var anonymousStoreyType = ilfixAassembly.MainModule.Types.Single(t => t.Name == "AnonymousStorey");
            anonymousStoreyTypeRef = assembly.MainModule.ImportReference(anonymousStoreyType);
            anonymousStoreyCtorRef = assembly.MainModule.ImportReference(
                anonymousStoreyType.Methods.Single(m => m.Name == ".ctor" && m.Parameters.Count == 5));

            objectVirtualMethodReferenceList = anonymousStoreyType.Methods.Where(m => m.Name.StartsWith("Object")).
                Select(m => assembly.MainModule.ImportReference(m)).ToList();

            itfBridgeType = new TypeDefinition("IFix", INTERFACEBRIDGE, TypeAttributes.Class | TypeAttributes.Public,
                    anonymousStoreyTypeRef);
            virualMachineFieldOfBridge = assembly.MainModule.ImportReference(anonymousStoreyType.Fields.Single(f => f.Name == "virtualMachine"));
            assembly.MainModule.Types.Add(itfBridgeType);
            addExternType(itfBridgeType);

            //end init itfBridgeType

            //begin init idMapper
            enumType = assembly.MainModule.ImportReference(typeof(System.Enum));
            idMapList = new List<TypeDefinition>();
            idMapType = null;
            //end init idMapper

            wrapperMethods = new List<MethodDefinition>();

            TypeDefinition Call;
            Call = ilfixAassembly.MainModule.Types.Single(t => t.Name == "Call");
            Call_Ref = assembly.MainModule.ImportReference(Call);
            Call_Begin_Ref = importMethodReference(Call, "Begin");
            Call_PushRef_Ref = importMethodReference(Call, "PushRef");
            Call_PushValueType_Ref = importMethodReference(Call, "PushValueType");
            Call_GetAsType_Ref = importMethodReference(Call, "GetAsType");

            VirtualMachine_Execute_Ref = assembly.MainModule.ImportReference(
                VirtualMachine.Methods.Single(m => m.Name == "Execute" && m.Parameters.Count == 4));

            Utils_TryAdapterToDelegate_Ref = assembly.MainModule.ImportReference(
                ilfixAassembly.MainModule.Types.Single(t => t.FullName == "IFix.Core.Utils")
                .Methods.Single(m => m.Name == "TryAdapterToDelegate"));

            ldinds = new Dictionary<TypeReference, OpCode>()
            {
                {assembly.MainModule.TypeSystem.Boolean, OpCodes.Ldind_U1 },
                {assembly.MainModule.TypeSystem.Byte, OpCodes.Ldind_U1 },
                {assembly.MainModule.TypeSystem.SByte, OpCodes.Ldind_I1 },
                {assembly.MainModule.TypeSystem.Int16, OpCodes.Ldind_I2 },
                {assembly.MainModule.TypeSystem.Char, OpCodes.Ldind_U2 },
                {assembly.MainModule.TypeSystem.UInt16, OpCodes.Ldind_U2 },
                {assembly.MainModule.TypeSystem.Int32, OpCodes.Ldind_I4 },
                {assembly.MainModule.TypeSystem.UInt32, OpCodes.Ldind_U4 },
                {assembly.MainModule.TypeSystem.Int64, OpCodes.Ldind_I8 },
                {assembly.MainModule.TypeSystem.UInt64, OpCodes.Ldind_I8 },
                {assembly.MainModule.TypeSystem.Single, OpCodes.Ldind_R4 },
                {assembly.MainModule.TypeSystem.Double, OpCodes.Ldind_R8 },
                {assembly.MainModule.TypeSystem.IntPtr, OpCodes.Ldind_I },
                {assembly.MainModule.TypeSystem.UIntPtr, OpCodes.Ldind_I },
            };

            stinds = new Dictionary<TypeReference, OpCode>()
            {
                {assembly.MainModule.TypeSystem.Boolean, OpCodes.Stind_I1 },
                {assembly.MainModule.TypeSystem.Byte, OpCodes.Stind_I1 },
                {assembly.MainModule.TypeSystem.SByte, OpCodes.Stind_I1 },
                {assembly.MainModule.TypeSystem.Int16, OpCodes.Stind_I2 },
                {assembly.MainModule.TypeSystem.Char, OpCodes.Stind_I2 },
                {assembly.MainModule.TypeSystem.UInt16, OpCodes.Stind_I2 },
                {assembly.MainModule.TypeSystem.Int32, OpCodes.Stind_I4 },
                {assembly.MainModule.TypeSystem.UInt32, OpCodes.Stind_I4 },
                {assembly.MainModule.TypeSystem.Int64, OpCodes.Stind_I8 },
                {assembly.MainModule.TypeSystem.UInt64, OpCodes.Stind_I8 },
                {assembly.MainModule.TypeSystem.Single, OpCodes.Stind_R4 },
                {assembly.MainModule.TypeSystem.Double, OpCodes.Stind_R8 },
                {assembly.MainModule.TypeSystem.IntPtr, OpCodes.Stind_I },
                {assembly.MainModule.TypeSystem.UIntPtr, OpCodes.Stind_I },
            };

            initStackOp(Call, assembly.MainModule.TypeSystem.Boolean);
            initStackOp(Call, assembly.MainModule.TypeSystem.Byte);
            initStackOp(Call, assembly.MainModule.TypeSystem.SByte);
            initStackOp(Call, assembly.MainModule.TypeSystem.Int16);
            initStackOp(Call, assembly.MainModule.TypeSystem.UInt16);
            initStackOp(Call, assembly.MainModule.TypeSystem.Char);
            initStackOp(Call, assembly.MainModule.TypeSystem.Int32);
            initStackOp(Call, assembly.MainModule.TypeSystem.UInt32);
            initStackOp(Call, assembly.MainModule.TypeSystem.Int64);
            initStackOp(Call, assembly.MainModule.TypeSystem.UInt64);
            initStackOp(Call, assembly.MainModule.TypeSystem.Single);
            initStackOp(Call, assembly.MainModule.TypeSystem.Double);
            initStackOp(Call, assembly.MainModule.TypeSystem.Object);
            initStackOp(Call, assembly.MainModule.TypeSystem.IntPtr);
            initStackOp(Call, assembly.MainModule.TypeSystem.UIntPtr);
        }

        const int MAX_ID_MAP_FIELD_COUNT = 32760;

        void idMapTypeCheck()
        {
            if (idMapType == null || idMapType.Fields.Count >= MAX_ID_MAP_FIELD_COUNT)
            {
                if (idMapType != null)
                {
                    idMapList.Add(idMapType);
                }
                idMapType = new TypeDefinition("IFix", "IDMAP" + idMapList.Count, TypeAttributes.Public | TypeAttributes.Sealed,
                        enumType);
                assembly.MainModule.Types.Add(idMapType);
                idMapType.Fields.Add(new FieldDefinition("value__", FieldAttributes.Public | FieldAttributes.SpecialName
                    | FieldAttributes.RTSpecialName, assembly.MainModule.TypeSystem.Int32));
            }
        }

        void initStackOp(TypeDefinition call, TypeReference type)
        {
            pushMap[type] = importMethodReference(call, "Push" + type.Name);
            getMap[type.Resolve()] = importMethodReference(call, "Get" + type.Name);
            nameToTypeReference[type.FullName] = type;
        }

        void emitCCtor()
        {
            var staticConstructorAttributes =
                    MethodAttributes.Private |
                    MethodAttributes.HideBySig |
                    MethodAttributes.Static |
                    MethodAttributes.SpecialName |
                    MethodAttributes.RTSpecialName;

            MethodDefinition cctor = new MethodDefinition(".cctor", staticConstructorAttributes, voidType);
            wrapperType.Methods.Add(cctor);
            //wrapperType.IsBeforeFieldInit = true;
            var instructions = cctor.Body.Instructions;
            instructions.Add(Instruction.Create(OpCodes.Ldc_I4, 0));
            instructions.Add(Instruction.Create(OpCodes.Newarr, wrapperType));
            instructions.Add(Instruction.Create(OpCodes.Stsfld, wrapperArray));
            instructions.Add(Instruction.Create(OpCodes.Ret));
        }

        void emitWrapperManager()
        {
            wrapperMgrImpl = new TypeDefinition("IFix", "WrappersManagerImpl", Mono.Cecil.TypeAttributes.Class
                | Mono.Cecil.TypeAttributes.Public,
                    objType);
            wrapperMgrImpl.Interfaces.Add(new InterfaceImplementation(WrappersManagerType));

            var virualMachineFieldOfWrapperMgr = new FieldDefinition("virtualMachine", FieldAttributes.Private,
                    VirtualMachineType);
            wrapperMgrImpl.Fields.Add(virualMachineFieldOfWrapperMgr);

            var objEmptyConstructor = assembly.MainModule.ImportReference(objType.Resolve().Methods.
                Single(m => m.Name == ".ctor" && m.Parameters.Count == 0));
            var methodAttributes = MethodAttributes.Public
                | MethodAttributes.HideBySig
                | MethodAttributes.SpecialName
                | MethodAttributes.RTSpecialName;
            ctorOfWrapperMgrImpl = new MethodDefinition(".ctor", methodAttributes, voidType);
            ctorOfWrapperMgrImpl.Parameters.Add(new ParameterDefinition("virtualMachine",
                Mono.Cecil.ParameterAttributes.None, VirtualMachineType));
            wrapperMgrImpl.Methods.Add(ctorOfWrapperMgrImpl);
            var instructions = ctorOfWrapperMgrImpl.Body.Instructions;
            instructions.Add(Instruction.Create(OpCodes.Ldarg_0));
            instructions.Add(Instruction.Create(OpCodes.Call, objEmptyConstructor));
            instructions.Add(Instruction.Create(OpCodes.Ldarg_0));
            instructions.Add(Instruction.Create(OpCodes.Ldarg_1));
            instructions.Add(Instruction.Create(OpCodes.Stfld, virualMachineFieldOfWrapperMgr));
            instructions.Add(Instruction.Create(OpCodes.Ret));

            getPatch = new MethodDefinition("GetPatch", MethodAttributes.Public | MethodAttributes.Static, wrapperType);
            wrapperMgrImpl.Methods.Add(getPatch);
            getPatch.Parameters.Add(new ParameterDefinition("id", Mono.Cecil.ParameterAttributes.None,
                assembly.MainModule.TypeSystem.Int32));
            instructions = getPatch.Body.Instructions;
            instructions.Add(Instruction.Create(OpCodes.Ldsfld, wrapperArray));
            instructions.Add(Instruction.Create(OpCodes.Ldarg_0));
            instructions.Add(Instruction.Create(OpCodes.Ldelem_Ref));
            instructions.Add(Instruction.Create(OpCodes.Ret));

            isPatched = new MethodDefinition("IsPatched", MethodAttributes.Public | MethodAttributes.Static,
                assembly.MainModule.TypeSystem.Boolean);
            wrapperMgrImpl.Methods.Add(isPatched);
            isPatched.Parameters.Add(new ParameterDefinition("id", Mono.Cecil.ParameterAttributes.None,
                assembly.MainModule.TypeSystem.Int32));
            instructions = isPatched.Body.Instructions;
            instructions.Add(Instruction.Create(OpCodes.Ldarg_0));
            instructions.Add(Instruction.Create(OpCodes.Ldsfld, wrapperArray));
            instructions.Add(Instruction.Create(OpCodes.Ldlen));
            instructions.Add(Instruction.Create(OpCodes.Conv_I4));

            var bp0 = Instruction.Create(OpCodes.Ldc_I4_0);
            var bp1 = Instruction.Create(OpCodes.Ret);

            instructions.Add(Instruction.Create(OpCodes.Bge, bp0));
            instructions.Add(Instruction.Create(OpCodes.Ldsfld, wrapperArray));
            instructions.Add(Instruction.Create(OpCodes.Ldarg_0));
            instructions.Add(Instruction.Create(OpCodes.Ldelem_Ref));
            instructions.Add(Instruction.Create(OpCodes.Ldnull));
            instructions.Add(Instruction.Create(OpCodes.Ceq));
            instructions.Add(Instruction.Create(OpCodes.Ldc_I4_0));
            instructions.Add(Instruction.Create(OpCodes.Ceq));
            instructions.Add(Instruction.Create(OpCodes.Br_S, bp1));
            instructions.Add(bp0);
            instructions.Add(bp1);

            //CreateDelegate
            createDelegate = new MethodDefinition("CreateDelegate", MethodAttributes.Public
                | MethodAttributes.HideBySig
                | MethodAttributes.NewSlot
                | MethodAttributes.Virtual
                | MethodAttributes.Final, assembly.MainModule.ImportReference(typeof(Delegate)));
            wrapperMgrImpl.Methods.Add(createDelegate);
            createDelegate.Parameters.Add(new ParameterDefinition("type", ParameterAttributes.None,
                assembly.MainModule.ImportReference(typeof(Type))));
            createDelegate.Parameters.Add(new ParameterDefinition("id", ParameterAttributes.None,
                assembly.MainModule.TypeSystem.Int32));
            createDelegate.Parameters.Add(new ParameterDefinition("anon", ParameterAttributes.None, objType));

            VariableDefinition lcw = new VariableDefinition(wrapperType);
            createDelegate.Body.Variables.Add(lcw);

            instructions = createDelegate.Body.Instructions;

            //instructions.Add(Instruction.Create(OpCodes.Call, VirtualMachine_GetGlobal_Ref));
            instructions.Add(Instruction.Create(OpCodes.Ldarg_0));
            instructions.Add(Instruction.Create(OpCodes.Ldfld, virualMachineFieldOfWrapperMgr));
            instructions.Add(Instruction.Create(OpCodes.Ldarg_2));
            instructions.Add(Instruction.Create(OpCodes.Ldarg_3));
            instructions.Add(Instruction.Create(OpCodes.Newobj, ctorOfWrapper));
            instructions.Add(Instruction.Create(OpCodes.Stloc, lcw));

            //instructions.Add(Instruction.Create(OpCodes.Ldnull));
            instructions.Add(Instruction.Create(OpCodes.Ldloc, lcw));
            instructions.Add(Instruction.Create(OpCodes.Ldarg_1));
            instructions.Add(Instruction.Create(OpCodes.Ldstr, Wrap_Perfix));
            instructions.Add(Instruction.Create(OpCodes.Call, Utils_TryAdapterToDelegate_Ref));
            instructions.Add(Instruction.Create(OpCodes.Ret));

            //CreateWrapper
            var createWrapper = new MethodDefinition("CreateWrapper", MethodAttributes.Public
                | MethodAttributes.HideBySig
                | MethodAttributes.NewSlot
                | MethodAttributes.Virtual
                | MethodAttributes.Final, assembly.MainModule.TypeSystem.Object);
            wrapperMgrImpl.Methods.Add(createWrapper);
            createWrapper.Parameters.Add(new ParameterDefinition("id", ParameterAttributes.None,
                assembly.MainModule.TypeSystem.Int32));

            instructions = createWrapper.Body.Instructions;
            //instructions.Add(Instruction.Create(OpCodes.Call, VirtualMachine_GetGlobal_Ref));
            instructions.Add(Instruction.Create(OpCodes.Ldarg_0));
            instructions.Add(Instruction.Create(OpCodes.Ldfld, virualMachineFieldOfWrapperMgr));
            instructions.Add(Instruction.Create(OpCodes.Ldarg_1));
            instructions.Add(Instruction.Create(OpCodes.Ldnull));
            instructions.Add(Instruction.Create(OpCodes.Newobj, ctorOfWrapper));
            instructions.Add(Instruction.Create(OpCodes.Ret));

            assembly.MainModule.Types.Add(wrapperMgrImpl);

            var initWrapperArray = new MethodDefinition("InitWrapperArray", MethodAttributes.Public
                | MethodAttributes.HideBySig
                | MethodAttributes.NewSlot
                | MethodAttributes.Virtual
                | MethodAttributes.Final, assembly.MainModule.TypeSystem.Object);
            wrapperMgrImpl.Methods.Add(initWrapperArray);
            initWrapperArray.Parameters.Add(new ParameterDefinition("len", ParameterAttributes.None,
                assembly.MainModule.TypeSystem.Int32));
            instructions = initWrapperArray.Body.Instructions;
            instructions.Add(Instruction.Create(OpCodes.Ldarg_1));
            instructions.Add(Instruction.Create(OpCodes.Newarr, wrapperType));
            instructions.Add(Instruction.Create(OpCodes.Stsfld, wrapperArray));
            instructions.Add(Instruction.Create(OpCodes.Ldsfld, wrapperArray));
            instructions.Add(Instruction.Create(OpCodes.Ret));

        }

        //void makeCloneFast(AssemblyDefinition ilfixAassembly)
        //{
        //    var clone = ilfixAassembly.MainModule.Types.Single(t => t.Name == "ObjectClone").Methods.
        //        Single(m => m.Name == "Clone");
        //    var instructions = clone.Body.Instructions;
        //    instructions.Clear();
        //    var memberwiseClone = ilfixAassembly.MainModule.ImportReference(
        //        ilfixAassembly.MainModule.TypeSystem.Object.Resolve().Methods
        //        .Single(m => m.Name == "MemberwiseClone"));
        //    instructions.Add(Instruction.Create(OpCodes.Ldarg_1));
        //    instructions.Add(Instruction.Create(OpCodes.Call, memberwiseClone));
        //    instructions.Add(Instruction.Create(OpCodes.Ret));
        //}

        private MethodReference importMethodReference(TypeDefinition type, string name)
        {
            return assembly.MainModule.ImportReference(type.Methods.Single(m => m.Name == name));
        }

        static MethodReference makeGenericMethod(MethodReference self, params TypeReference[] arguments)
        {
            if (self.GenericParameters.Count != arguments.Length)
                throw new ArgumentException();

            var instance = new GenericInstanceMethod(self);
            foreach (var argument in arguments)
                instance.GenericArguments.Add(argument);

            return instance;
        }

        const string DYNAMICWRAPPER = "ILFixDynamicMethodWrapper";

        const string INTERFACEBRIDGE = "ILFixInterfaceBridge";

        const string METHODIDPERFIX = "methodId_";

        const string REDIRECT_NAMESPACE = "IFix.RedirectTo";

        Dictionary<TypeDefinition, TypeDefinition> redirectTypeMap = new Dictionary<TypeDefinition, TypeDefinition>();
        Dictionary<MethodDefinition, FieldDefinition> redirectMemberMap
            = new Dictionary<MethodDefinition, FieldDefinition>();
        Dictionary<MethodDefinition, FieldDefinition> redirectIdMap
            = new Dictionary<MethodDefinition, FieldDefinition>();

        TypeDefinition getRedirectType(TypeDefinition type)
        {
            TypeDefinition redirectType;
            if (!redirectTypeMap.TryGetValue(type, out redirectType))
            {
                bool isNestedType = type.DeclaringType != null;
                string ns = "";
                TypeAttributes typeAttributes = TypeAttributes.Class | TypeAttributes.Public
                    | TypeAttributes.Abstract | TypeAttributes.Sealed | TypeAttributes.BeforeFieldInit;
                if (!isNestedType)
                {
                    ns = string.IsNullOrEmpty(type.Namespace) ? REDIRECT_NAMESPACE
                        : string.Format("{0}.{1}", REDIRECT_NAMESPACE, type.Namespace);
                }
                else
                {
                    typeAttributes = TypeAttributes.Class | TypeAttributes.NestedPublic | TypeAttributes.Abstract
                        | TypeAttributes.Sealed | TypeAttributes.BeforeFieldInit;
                }
                redirectType = new TypeDefinition(ns, type.Name, typeAttributes, objType);
                redirectTypeMap.Add(type, redirectType);

                if (type.DeclaringType != null)
                {
                    var redirectParentType = getRedirectType(type.DeclaringType);
                    redirectParentType.NestedTypes.Add(redirectType);
                }
                else
                {
                    assembly.MainModule.Types.Add(redirectType);
                }
            }
            return redirectType;
        }

        void addRedirectIdInfo(MethodDefinition method, int id)
        {
            if (redirectIdMap.ContainsKey(method))
            {
                throw new Exception("try inject method twice: " + method);
            }
            idMapTypeCheck();
            var redirectIdField = new FieldDefinition("tmp_r_field_" + redirectIdMap.Count, FieldAttributes.Public
                | FieldAttributes.Static | FieldAttributes.Literal | FieldAttributes.HasDefault, idMapType);
            idMapType.Fields.Add(redirectIdField);
            redirectIdField.Constant = id;
            redirectIdMap.Add(method, redirectIdField);
        }

        //先加字段，建立关联关系
        FieldDefinition getRedirectField(MethodDefinition method)
        {
            if (redirectMemberMap.ContainsKey(method))
            {
                throw new Exception("try inject method twice: " + method);
            }

            var redirectType = getRedirectType(method.DeclaringType);

            var redirectField = new FieldDefinition("tmp_r_field_" + redirectMemberMap.Count, FieldAttributes.Public
                | FieldAttributes.Static, wrapperType);
            redirectType.Fields.Add(redirectField);
            redirectMemberMap.Add(method, redirectField);
            return redirectField;
        }

        void addIDTag(MethodDefinition method, int id)
        {
            var newAttr = new CustomAttribute(idTagCtor_Ref)
            {
                ConstructorArguments =
                {
                    new CustomAttributeArgument(assembly.MainModule.TypeSystem.Int32, id)
                }
            };
            method.CustomAttributes.Add(newAttr);
        }

        string getIdInfoName(MethodDefinition method, int id)
        {
            return string.Format("{0}-{1}{2}", method.DeclaringType.FullName.Replace('.', '-')
                .Replace('/', '-'), method.Name, id);
        }

        void redirectFieldRename()
        {
            foreach(var infosOfType in redirectMemberMap.GroupBy(kv => kv.Key.DeclaringType))
            {
                foreach(var methodGroup in infosOfType.GroupBy(kv => kv.Key.Name))
                {
                    var methodName = methodGroup.Key;
                    int id = 0;
                    foreach(var kv in methodGroup)
                    {
                        kv.Value.Name = "_rf_" + methodName + (id++);
                    }
                    if (id > 1) //有重载
                    {
                        id = 0;
                        foreach(var kv in methodGroup)
                        {
                            addIDTag(kv.Key, id++);
                        }
                    }
                }
            }

            HashSet<string> duplicateCheck = new HashSet<string>();
            foreach (var infosOfType in redirectIdMap.GroupBy(kv => kv.Key.DeclaringType))
            {
                foreach (var methodGroup in infosOfType.GroupBy(kv => kv.Key.Name))
                {
                    int id = 0;
                    foreach (var kv in methodGroup)
                    {
                        kv.Value.Name = getIdInfoName(kv.Key, id++);
                        if (duplicateCheck.Contains(kv.Value.Name))
                        {
                            throw new Exception("duplicate id map info:" + kv.Value.Name);
                        }
                        duplicateCheck.Add(kv.Value.Name);
                    }
                    if (id > 1) //有重载
                    {
                        id = 0;
                        foreach (var kv in methodGroup)
                        {
                            addIDTag(kv.Key, id++);
                        }
                    }
                }
            }
            idMapList.Add(idMapType);
            idMapType = null;
        }

        //1、构造函数及析构函数不转，不支持的指令不转，转的函数留下函数定义，所以支持反射
        //2、不转的函数通过反射调用，已转函数调用已转函数在虚拟机内部完成
        //3、已转函数可以支持直接重定向并删除原实现（减包场景），以及保留原实现增加切换代码（修bug场景）
        //4、已转函数需要生成wrap
        //5、TODO：虚函数用base如何处理？私有函数是否需要保留入口？简单函数（比如getter/setter）是否要转？
        //6、应该为基本值类型生成出入栈函数，防止过大GC
        //7、Callvirt分析其是否真的是虚函数，虚函数反射调用，非虚并且动态方法直接调用
        //8、泛型等同多了一个Type[]参数
        //工具输入一个dll，输出dll+dif
        Dictionary<MethodDefinition, InjectType> methodToInjectType = new Dictionary<MethodDefinition, InjectType>();
        bool hasRedirect = false;
        ProcessMode mode;
        GenerateConfigure configure;
        List<MethodReference> awaitUnsafeOnCompletedMethods = new List<MethodReference>();

        public ProcessResult Process(AssemblyDefinition assembly, AssemblyDefinition ilfixAassembly,
            GenerateConfigure configure, ProcessMode mode)
        {
            if (assembly.MainModule.Types.Any(t => t.Name == DYNAMICWRAPPER))
            {
                return ProcessResult.Processed;
            }

            this.mode = mode;
            this.configure = configure;
            nextAllocId = 0;

            init(assembly, ilfixAassembly);

            emitWrapperManager();
            //makeCloneFast(ilfixAassembly);

            var allTypes = (from type in assembly.GetAllType()
                            where type.Namespace != "IFix" && !type.IsGeneric() && !(isCompilerGenerated(type) || isNewClass(type))
                            select type).ToList();

            foreach (var method in (
                from type in allTypes
                where !(isCompilerGenerated(type) || isNewClass(type)) && !type.HasGenericParameters
                from method in type.Methods
                where !method.IsConstructor && !isCompilerGenerated(method) && !method.HasGenericParameters && !method.ReturnType.IsRequiredModifier
                select method))
            {
                int flag;
                if (configure.TryGetConfigure("IFix.InterpretAttribute", method, out flag))
                {
                    methodToInjectType[method] = InjectType.Redirect;
                    hasRedirect = true;
                }
                else if(configure.TryGetConfigure("IFix.IFixAttribute", method, out flag))
                {
                    methodToInjectType[method] = InjectType.Switch;
                }
            }

            foreach (var cls in (
                from type in allTypes
                where type.IsClass select type))
            {
                foreach (var field in cls.Fields)
                {
                    if(isNewField(field))
                    {
                        var ctor =
                            (from method in cls.Methods
                            where method.IsConstructor && (field.IsStatic ? method.Name == ".cctor" : method.Name == ".ctor")
                            select method).FirstOrDefault();

                        if(ctor != null)
                        {
                            var ret = new Mono.Collections.Generic.Collection<Instruction>();
                            foreach (var instruction in ctor.Body.Instructions)
                            {
                                
                                var code = instruction.OpCode.Code;

                                if((code == Code.Stsfld || code == Code.Stfld) && (instruction.Operand as FieldDefinition) == field)
                                {
                                    emitFieldCtor(field, ret);
                                    break;
                                }
                                else
                                {
                                    ret.Add(instruction);
                                }

                                if(field.IsStatic)
                                {
                                    if(code == Code.Stsfld)
                                    {
                                        ret.Clear();
                                    }
                                }
                                else
                                {
                                    if(code == Code.Stfld)
                                    {
                                        ret.Clear();
                                    }
                                }                                
                            } 
                        }
                    }
                } 
            }

            
            foreach(var kv in methodToInjectType)
            {
                processMethod(kv.Key);
            }

            genCodeForCustomBridge();

            emitCCtor();

            postProcessInterfaceBridge();

            if (mode == ProcessMode.Inject)
            {
                redirectFieldRename();
                if (awaitUnsafeOnCompletedMethods.Count != 0)
                {
                    EmitRefAwaitUnsafeOnCompletedMethod();
                }
                
                EmitAsyncBuilderStartMethod(allTypes);
            } 

            return ProcessResult.OK;
        }

        void emitFieldCtor(FieldDefinition field, Mono.Collections.Generic.Collection<Instruction> insertInstructions)
        {
            var staticConstructorAttributes =
                    MethodAttributes.Private |
                    MethodAttributes.Static |
                    MethodAttributes.HideBySig |
                    MethodAttributes.SpecialName |
                    MethodAttributes.RTSpecialName;

            MethodDefinition fieldDefaultValue = new MethodDefinition("<>__ctor_" + field.Name, staticConstructorAttributes, assembly.MainModule.TypeSystem.Object);

            var instructions = fieldDefaultValue.Body.Instructions;

            foreach (var instruction in insertInstructions)
            {
                if(!instruction.OpCode.Code.ToString().Contains("Ldarg"))
                {
                    instructions.Add(instruction);
                }
            }

            if(field.FieldType.IsValueType)
            {
                instructions.Add(Instruction.Create(OpCodes.Box, field.FieldType));
            }

            instructions.Add(Instruction.Create(OpCodes.Ret));

            field.DeclaringType.Methods.Add(fieldDefaultValue);

            configure.AddNewMethod(fieldDefaultValue);

            methodToInjectType[fieldDefaultValue] = InjectType.Redirect;
            hasRedirect = true;

            if (!newFieldToCtor.ContainsKey(field))
            {
                var cctorInfo = getMethodId(fieldDefaultValue, null,false, false, InjectType.Redirect);
                newFieldToCtor[field] = cctorInfo.Id;
            }
        }


        void postProcessInterfaceBridge()
        {
            //foreach(var g in itfBridgeType.Methods.GroupBy(m => m.Name).Select(g => g.ToList()))
            //{
            //    if (g.Count > 1)
            //    {

            //    }
            //}

            //为getter setter增加对应的property
            foreach (var m in itfBridgeType.Methods)
            {
                if (m.IsSpecialName && !m.IsConstructor)
                {
                    var name = m.Name;
                    int dotPos = name.LastIndexOf('.');
                    if (dotPos > 0)
                    {
                        name = name.Substring(dotPos + 1);
                    }

                    if (!name.StartsWith("get_") && !name.StartsWith("set_"))
                    {
                        continue;
                    }

                    var propName = name.Substring(4);
                    if (dotPos > 0)
                    {
                        propName = m.Name.Substring(0, dotPos + 1) + propName;
                    }
                    var prop = itfBridgeType.Properties.SingleOrDefault(p => p.Name == propName);
                    if (prop == null)
                    {
                        if (name.StartsWith("get_"))
                        {
                            prop = new PropertyDefinition(propName, PropertyAttributes.None, m.ReturnType);
                        }
                        else
                        {
                            prop = new PropertyDefinition(propName, PropertyAttributes.None,
                                m.Parameters[0].ParameterType);
                        }
                        itfBridgeType.Properties.Add(prop);
                    }
                    if (name.StartsWith("get_"))
                    {
                        prop.GetMethod = m;
                    }
                    else
                    {
                        prop.SetMethod = m;
                    }
                }
            }

            //bridge的构造函数
            var methodIdFields = itfBridgeType.Fields.Where(f => f.Name.StartsWith(METHODIDPERFIX)).ToList();
            int methodIdPerfixLen = METHODIDPERFIX.Length;
            methodIdFields.Sort((l, r) => int.Parse(l.Name.Substring(methodIdPerfixLen))
                - int.Parse(r.Name.Substring(methodIdPerfixLen)));
            var ctorOfItfBridgeType = new MethodDefinition(".ctor", MethodAttributes.Public
                | MethodAttributes.HideBySig
                | MethodAttributes.SpecialName
                | MethodAttributes.RTSpecialName, voidType);
            ctorOfItfBridgeType.Parameters.Add(new ParameterDefinition("fieldNum",
                Mono.Cecil.ParameterAttributes.None, assembly.MainModule.TypeSystem.Int32));
            ctorOfItfBridgeType.Parameters.Add(new ParameterDefinition("fieldTypes",
                Mono.Cecil.ParameterAttributes.None, new ArrayType(assembly.MainModule.TypeSystem.Int32)));
            ctorOfItfBridgeType.Parameters.Add(new ParameterDefinition("typeIndex",
                Mono.Cecil.ParameterAttributes.None, assembly.MainModule.TypeSystem.Int32));
            ctorOfItfBridgeType.Parameters.Add(new ParameterDefinition("vTable",
                Mono.Cecil.ParameterAttributes.None, new ArrayType(assembly.MainModule.TypeSystem.Int32)));
            ctorOfItfBridgeType.Parameters.Add(new ParameterDefinition("methodIdArray",
                Mono.Cecil.ParameterAttributes.None, new ArrayType(assembly.MainModule.TypeSystem.Int32)));
            ctorOfItfBridgeType.Parameters.Add(new ParameterDefinition("virtualMachine",
                Mono.Cecil.ParameterAttributes.None, VirtualMachineType));
            var instructions = ctorOfItfBridgeType.Body.Instructions;
            instructions.Add(Instruction.Create(OpCodes.Ldarg_0));
            instructions.Add(Instruction.Create(OpCodes.Ldarg_1));
            instructions.Add(Instruction.Create(OpCodes.Ldarg_2));
            instructions.Add(Instruction.Create(OpCodes.Ldarg_3));
            instructions.Add(createLdarg(ctorOfItfBridgeType.Body.GetILProcessor(), 4));
            instructions.Add(createLdarg(ctorOfItfBridgeType.Body.GetILProcessor(), 6));
            var callBaseCtor = Instruction.Create(OpCodes.Call, anonymousStoreyCtorRef);
            instructions.Add(callBaseCtor);

            for (int i = 0; i < methodIdFields.Count; i++)
            {
                instructions.Add(Instruction.Create(OpCodes.Ldarg_0));
                instructions.Add(createLdarg(ctorOfItfBridgeType.Body.GetILProcessor(), 5));
                emitLdcI4(instructions, i);
                instructions.Add(Instruction.Create(OpCodes.Ldelem_I4));
                instructions.Add(Instruction.Create(OpCodes.Stfld, methodIdFields[i]));
            }

            instructions.Add(Instruction.Create(OpCodes.Ret));

            var insertPoint = callBaseCtor.Next;
            var processor = ctorOfItfBridgeType.Body.GetILProcessor();
            processor.InsertBefore(insertPoint, createLdarg(ctorOfItfBridgeType.Body.GetILProcessor(), 5));
            processor.InsertBefore(insertPoint, Instruction.Create(OpCodes.Ldlen));
            processor.InsertBefore(insertPoint, Instruction.Create(OpCodes.Conv_I4));
            processor.InsertBefore(insertPoint, createLdcI4(methodIdFields.Count));
            processor.InsertBefore(insertPoint, Instruction.Create(OpCodes.Beq_S, insertPoint));
            processor.InsertBefore(insertPoint, Instruction.Create(OpCodes.Ldstr, "invalid length of methodId array"));
            processor.InsertBefore(insertPoint, Instruction.Create(OpCodes.Newobj,
                assembly.MainModule.ImportReference(typeof(Exception)
                    .GetConstructor(new Type[] { typeof(string) }))));
            processor.InsertBefore(insertPoint, Instruction.Create(OpCodes.Throw));

            itfBridgeType.Methods.Add(ctorOfItfBridgeType);

            //在WrappersManagerImpl增加创建接口
            var createBridge = new MethodDefinition("CreateBridge", MethodAttributes.Public
                | MethodAttributes.HideBySig
                | MethodAttributes.NewSlot
                | MethodAttributes.Virtual
                | MethodAttributes.Final, anonymousStoreyTypeRef);
            createBridge.Parameters.Add(new ParameterDefinition("fieldNum", Mono.Cecil.ParameterAttributes.None,
                assembly.MainModule.TypeSystem.Int32));
            createBridge.Parameters.Add(new ParameterDefinition("fieldTypes", Mono.Cecil.ParameterAttributes.None,
                new ArrayType(assembly.MainModule.TypeSystem.Int32)));
            createBridge.Parameters.Add(new ParameterDefinition("typeIndex", Mono.Cecil.ParameterAttributes.None,
                assembly.MainModule.TypeSystem.Int32));
            createBridge.Parameters.Add(new ParameterDefinition("vTable", Mono.Cecil.ParameterAttributes.None,
                new ArrayType(assembly.MainModule.TypeSystem.Int32)));
            createBridge.Parameters.Add(new ParameterDefinition("slots", Mono.Cecil.ParameterAttributes.None,
                new ArrayType(assembly.MainModule.TypeSystem.Int32)));
            createBridge.Parameters.Add(new ParameterDefinition("virtualMachine", Mono.Cecil.ParameterAttributes.None,
                VirtualMachineType));
            instructions = createBridge.Body.Instructions;
            instructions.Add(Instruction.Create(OpCodes.Ldarg_1));
            instructions.Add(Instruction.Create(OpCodes.Ldarg_2));
            instructions.Add(Instruction.Create(OpCodes.Ldarg_3));
            instructions.Add(createLdarg(createBridge.Body.GetILProcessor(), 4));
            instructions.Add(createLdarg(createBridge.Body.GetILProcessor(), 5));
            instructions.Add(createLdarg(createBridge.Body.GetILProcessor(), 6));
            instructions.Add(Instruction.Create(OpCodes.Newobj, ctorOfItfBridgeType));
            instructions.Add(Instruction.Create(OpCodes.Ret));

            wrapperMgrImpl.Methods.Add(createBridge);
            
        }

        void genCodeForCustomBridge()
        {
            var customBirdgeTypes = (
                from module in assembly.Modules
                from type in module.Types
                where type.CustomAttributes.Any(ca => ca.AttributeType.FullName == "IFix.CustomBridgeAttribute")
                from method in type.Methods
                where method.IsConstructor && method.Name == ".cctor" && method.Body != null
                    && method.Body.Instructions != null
                from instruction in method.Body.Instructions
                where instruction.OpCode.Code == Code.Ldtoken && instruction.Operand is TypeReference
                select instruction.Operand as TypeReference);
            foreach(var t in customBirdgeTypes)
            {
                var td = t.Resolve();
                if(td.IsDelegate())
                {
                    var invoke = td.Methods.Single(m => m.Name == "Invoke");
                    if (t.IsGenericInstance)
                    {
                        getWrapperMethod(wrapperType, anonObjOfWrapper, invoke.MakeGeneric(t), true, true);
                    }
                    else
                    {
                        getWrapperMethod(wrapperType, anonObjOfWrapper, invoke.TryImport(t.Module), true, true);
                    }
                }
                else if (td.IsInterface)
                {
                    addInterfaceToBridge(t);
                }
            }
        }

        void writeMethod(BinaryWriter writer, MethodReference method)
        {
            writer.Write(method.IsGenericInstance);
            if (method.IsGenericInstance)
            {
                //Console.WriteLine("GenericInstance:" + externMethod);
                writer.Write(externTypeToId[method.DeclaringType]);
                writer.Write(method.Name);
                var typeArgs = ((GenericInstanceMethod)method).GenericArguments;
                writer.Write(typeArgs.Count);
                for (int typeArg = 0;typeArg < typeArgs.Count;typeArg++)
                {
                    if (isCompilerGenerated(typeArgs[typeArg]))
                    {
                        typeArgs[typeArg] = itfBridgeType;
                    }
                    writer.Write(externTypeToId[typeArgs[typeArg]]);
                }
                writer.Write(method.Parameters.Count);
                //var genericParameters = ((GenericInstanceMethod)externMethod).ElementMethod.GenericParameters;
                //Console.WriteLine(">>>" + ((GenericInstanceMethod)externMethod).GetElementMethod());
                //Console.WriteLine(((GenericInstanceMethod)externMethod).ElementMethod.HasGenericParameters);
                //foreach (var gp in genericParameters)
                //{
                //    Console.WriteLine("gp:" + gp + ",gpdm:" + gp.Type);
                //}
                foreach (var p in method.Parameters)
                {
                    bool paramIsGeneric = p.ParameterType.HasGenericArgumentFromMethod();
                    writer.Write(paramIsGeneric);
                    if (paramIsGeneric)
                    {
                        //
                        //if (System.Text.RegularExpressions.Regex.IsMatch(p.ParameterType.FullName, @"!!\d+"))
                        //{

                        //}
                        //if (p.ParameterType.IsGenericParameter)
                        //{
                        //    bool isGP = false;
                        //    for(int k =0; k < genericDefinition.GenericParameters.Count; k++)
                        //    {
                        //        if (p.ParameterType == genericDefinition.GenericParameters[k])
                        //        {
                        //            isGP = true;
                        //            break;
                        //        }
                        //    }
                        //    if (!isGP)
                        //    {
                        //        var paramType = findGenericArg(externMethod.DeclaringType, p.ParameterType.Name);
                        //        if (paramType == null)
                        //        {
                        //            throw new InvalidProgramException("can not resolve method:" + externMethod);
                        //        }

                        //    }
                        //}
                        //Console.WriteLine("p.ParameterType:" + p.ParameterType.FullName + ",isg:"
                        //    + p.ParameterType.IsGenericInstance);
                        if (p.ParameterType.IsGenericParameter)
                        {
                            writer.Write(p.ParameterType.Name);
                        }
                        else
                        {
                            writer.Write(p.ParameterType.GetAssemblyQualifiedName(method.DeclaringType, true));
                        }
                    }
                    else
                    {
                        if (p.ParameterType.IsGenericParameter)
                        {
                            writer.Write(externTypeToId[(p.ParameterType as GenericParameter)
                                .ResolveGenericArgument(method.DeclaringType)]);
                        }
                        else
                        {
                            writer.Write(externTypeToId[p.ParameterType]);
                        }
                    }
                }
            }
            else
            {
                //Console.WriteLine("not GenericInstance:" + externMethod);
                if (!externTypeToId.ContainsKey(method.DeclaringType))
                {
                    throw new Exception("externTypeToId do not exist key: " + method.DeclaringType
                        + ", while process method: " + method);
                }
                writer.Write(externTypeToId[method.DeclaringType]);
                writer.Write(method.Name);
                writer.Write(method.Parameters.Count);
                foreach (var p in method.Parameters)
                {
                    var paramType = p.ParameterType;
                    if (paramType.IsGenericParameter)
                    {
                        paramType = (paramType as GenericParameter).ResolveGenericArgument(method.DeclaringType);
                    }
                    if (paramType.IsRequiredModifier)
                    {
                        paramType = (paramType as RequiredModifierType).ElementType;
                    }
                    if (!externTypeToId.ContainsKey(paramType))
                    {
                        throw new Exception("externTypeToId do not exist key: " + paramType
                            + ", while process parameter of method: " + method);
                    }
                    //Console.WriteLine("paramType: " + paramType);
                    //Console.WriteLine("externTypeToId[paramType] : " + externTypeToId[paramType]);
                    //Console.WriteLine("externTypes[externTypeToId[paramType]] : "
                    //    + externTypes[externTypeToId[paramType]]);
                    writer.Write(externTypeToId[paramType]);
                }
            }
        }

        void writeSlotInfo(BinaryWriter writer, TypeDefinition type)
        {
            writer.Write(type.Interfaces.Count);
            //Console.WriteLine(string.Format("-------{0}----------", type.Interfaces.Count));
            foreach(var ii in type.Interfaces)
            {
                var itf = bridgeInterfaces.Find(t => t.AreEqualIgnoreAssemblyVersion(ii.InterfaceType));
                //Console.WriteLine(itf.ToString());
                var itfDef = itf.Resolve();
                writer.Write(externTypeToId[itf]); // interface
                foreach (var method in itfDef.Methods)
                {
                    var itfMethod = itf.IsGenericInstance ? method.MakeGeneric(itf) : method.TryImport(itf.Module);
                    var implMethod = type.Methods.SingleOrDefault(m => itfMethod.CheckImplemention(m));
                    if (implMethod == null)
                    {
                        //Console.WriteLine(string.Format("check {0} in {1}", itfMethod, type));
                        //foreach(var cm in type.Methods)
                        //{
                        //    Console.WriteLine(string.Format("{0} {1}", cm, itfMethod.CheckImplemention(cm)));
                        //}
                        throw new Exception(string.Format("can not find method {0} of {1}", itfMethod, itf));
                    }
                    //Console.WriteLine(string.Format(">>>{0} [{1}]", itfMethod, methodToId[implMethod]));
                    writer.Write(methodToId[implMethod]);
                }
            }
        }

        public void Serialize(string filename)
        {
            if (!hasRedirect && mode == ProcessMode.Inject)
            {
                return;
            }

            using (FileStream output = new FileStream(filename, FileMode.Create, FileAccess.Write))
            {
                Serialize(output);
            }
        }

        //TODO: 预分析，生成link.xml之类的文件
        public void Serialize(Stream output)
        {
            using (BinaryWriter writer = new BinaryWriter(output))
            {
                writer.Write(IFix.Core.Instruction.INSTRUCTION_FORMAT_MAGIC);
                writer.Write(itfBridgeType.GetAssemblyQualifiedName());

                // add field type
                for (int i = 0; i < fields.Count; i++)
                {
                    var fieldType = fields[i].FieldType;
                    if (fieldType.IsGenericParameter)
                    {
                        var resolveType = ((GenericParameter)fieldType).ResolveGenericArgument(fields[i].DeclaringType);
                        if (resolveType != null)
                        {
                            addExternType(resolveType);
                            continue;
                        }
                    }

                    if (isCompilerGenerated(fieldType) || isNewClass(fieldType as TypeDefinition))
                    {
                        fieldType = objType;
                    }
                    addExternType(fieldType);
                }

                //---------------extern type---------------
                writer.Write(externTypes.Count);
                for (int i = 0; i < externTypes.Count; i++)
                {
                    //Console.WriteLine("externTypes[" + i + "]: " + externTypes[i] + ", is ref:"
                    //    + externTypes[i].IsByReference + ",aqn:" + externTypes[i]
                    //    .GetAssemblyQualifiedName(contextTypeOfExternType[i]));
                    writer.Write(externTypes[i].GetAssemblyQualifiedName(contextTypeOfExternType[i]));
                }
                //Console.WriteLine("serialize code...");
                //---------------code---------------
                writer.Write(nextAllocId);
                //int realCodeNumber = 0;
                for (int i = 0; i < nextAllocId; i++)
                {
                    List<Core.Instruction> code;
                    if (codes.TryGetValue(i, out code) && codeMustWriteToPatch.Contains(i))
                    {
                        //realCodeNumber++;
                        writer.Write(code.Count);
                        //Console.WriteLine("methodid=" + i + ",instruction.cout=" + codes[i].Count);
                        for (int j = 0; j < code.Count; j++)
                        {
                            writer.Write((int)code[j].Code);
                            writer.Write(code[j].Operand);
                            //Console.WriteLine(j + " :code = " + codes[i][j].Code + ", operand="
                            //    + codes[i][j].Operand);
                        }
                        var exhs = methodIdToExceptionHandler[i];
                        writer.Write(exhs.Length);
                        for (int j = 0; j < exhs.Length; j++)
                        {
                            writer.Write((int)exhs[j].HandlerType);
                            writer.Write(exhs[j].CatchTypeId);
                            writer.Write(exhs[j].TryStart);
                            writer.Write(exhs[j].TryEnd);
                            writer.Write(exhs[j].HandlerStart);
                            writer.Write(exhs[j].HandlerEnd);
                        }
                    }
                    else
                    {
                        //Console.WriteLine("no code for methodId:" + i);
                        writer.Write(0);
                        writer.Write(0);
                    }
                }
                //Console.WriteLine("nextAllocId:" + nextAllocId + ", realCodeNumber:" + realCodeNumber);
                //Console.WriteLine("serialize extern method...");
                //---------------extern method signture---------------
                writer.Write(externMethods.Count);
                for (int i = 0; i < externMethods.Count; i++)
                {
                    writeMethod(writer, externMethods[i]);
                }
                //Console.WriteLine("serialize string...");
                writer.Write(internStrings.Count);
                for (int i = 0; i < internStrings.Count; i++)
                {
                    writer.Write(internStrings[i]);
                }
                //Console.WriteLine("serialize field...");
                writer.Write(fields.Count);
                for (int i = 0; i < fields.Count; i++)
                {
                    bool newField = isNewField(fields[i] as FieldDefinition);
                    writer.Write(newField);
                    writer.Write(addExternType(fields[i].DeclaringType));
                    writer.Write(fields[i].Name);

                    if(newField)
                    {
                        var fieldType = fields[i].FieldType;
                        if (isCompilerGenerated(fieldType) || isNewClass(fieldType as TypeDefinition))
                        {
                            fieldType = objType;
                        }
                        writer.Write(addExternType(fieldType));
                        if(newFieldToCtor.ContainsKey(fields[i] as FieldDefinition))
                        {
                            writer.Write(newFieldToCtor[fields[i] as FieldDefinition]);
                        }
                        else
                        {
                            writer.Write(-1);
                        }
                    }
                }

                writer.Write(fieldsStoreInVirtualMachine.Count);
                for (int i = 0; i < fieldsStoreInVirtualMachine.Count; i++)
                {
                    var fieldType = fieldsStoreInVirtualMachine[i].FieldType;
                    if (isCompilerGenerated(fieldType) || isNewClass(fieldType as TypeDefinition))
                    {
                        fieldType = objType;
                    }
                    writer.Write(addExternType(fieldType));
                    //字段静态构造函数
                    writer.Write(typeToCctor[fieldsStoreInVirtualMachine[i].DeclaringType]);
                }

                //Console.WriteLine("serialize anonymous type...");
                writer.Write(anonymousTypeInfos.Count);
                for(int i = 0; i < anonymousTypeInfos.Count; i++)
                {
                    //Console.WriteLine("anonymous type: " + anonymousTypeInfos[i]);
                    var anonymousType = anonymousTypeInfos[i].DeclaringType as TypeDefinition;
                    List<FieldDefinition> anonymousTypeFields = new List<FieldDefinition>();
                    if (isNewClass(anonymousTypeInfos[i].DeclaringType as TypeDefinition))
                    {
                        var temp = anonymousType;
                        while (temp != null && isNewClass(temp as TypeDefinition))
                        {
                            if (temp.Fields != null)
                            {
                                foreach (var fi in temp.Fields)
                                {
                                    anonymousTypeFields.Add(fi);
                                }
                            }
                            temp = temp.BaseType as TypeDefinition;
                        }
                    }
                    else
                    {
                        anonymousTypeFields.AddRange(anonymousTypeInfos[i].DeclaringType.Fields);
                    }
                    writer.Write(anonymousTypeFields.Count);

                    for (int field = 0; field < anonymousTypeFields.Count; field++)
                    {
                        if (anonymousTypeFields[field].FieldType.IsPrimitive)
                        {
                            writer.Write(0);
                        }
                        else if (anonymousTypeFields[field].FieldType.IsValueType)
                        {
                            writer.Write(externTypeToId[anonymousTypeFields[field].FieldType] + 1);
                        }
                        else
                        {
                            writer.Write(-2);
                        }
                    }
                    writer.Write(methodToId[anonymousTypeInfos[i]]);
                    writer.Write(anonymousTypeInfos[i].Parameters.Count);
                    writeSlotInfo(writer, anonymousType);
                    List<MethodDefinition> vT = getVirtualMethodForType(anonymousType);
                    writer.Write(vT.Count);
                    int[] vTables = new int[vT.Count];
                    for (int s = 0; s < vTables.Length; s++)
                    {
                        vTables[s] = -1;
                    }
                    writeVTable(anonymousType,vTables,vT);

                    for (int k = 0; k < vTables.Length; k++)
                    {
                        writer.Write(vTables[k]);
                    }
                }

                writer.Write(wrapperMgrImpl.GetAssemblyQualifiedName());

                TypeDefinition idMap0 = null;
                if (idMapList.Count == 0)
                {
                    if (idMapType == null)
                    {
                        idMapTypeCheck();
                    }
                    idMap0 = idMapType;
                    idMapType = null;
                }
                else
                {
                    idMap0 = idMapList[0];
                }
                var idMap0Name = idMap0.GetAssemblyQualifiedName();
                writer.Write(idMap0Name.Substring("IFix.IDMAP0".Length));

                writer.Write(interpretMethods.Count);
                //Console.WriteLine("interpretMethods.Count:" + interpretMethods.Count);
                //int idx = 0;
                foreach (var kv in interpretMethods)
                {
                    //Console.WriteLine((idx++) +" method:" + kv.Key + ", id:" + kv.Value);
                    writeMethod(writer, kv.Key);
                    writer.Write(kv.Value);
                }
                var newClassTypes = (from type in assembly.GetAllType()
                                where type.Namespace != "IFix" && !type.IsGeneric() && isNewClass(type)
                                select type);

                var newClassList = newClassTypes.ToList();
                writer.Write(newClassList.Count);
                foreach (var n in newClassList)
                {
                    var str = n.GetAssemblyQualifiedName();
                    writer.Write(str);
                }
            }            

            //var allTypes = (from module in assembly.Modules
            //                from type in module.Types
            //                where type.IsGeneric()
            //                select type).SelectMany(type => new TypeDefinition[] { type }.Concat(type.NestedTypes));

            //foreach (var method in (
            //    from type in allTypes
            //    from method in type.Methods
            //    where method.HasGenericParameters
            //    select method))
            //{
            //    Console.WriteLine("hgp:" + method + ",type:" + method.GetType());
            //}
        }
        Dictionary<TypeDefinition, List<MethodDefinition>> InternalTypeToVirtualMethods = new Dictionary<TypeDefinition, List<MethodDefinition>>();
        public List<MethodDefinition> getVirtualMethodForType(TypeDefinition type)
        {
            List<MethodDefinition> virtualMethods;
            if (InternalTypeToVirtualMethods.TryGetValue(type, out virtualMethods))
            {
                return virtualMethods;
            }

            if (type.BaseType != null && isNewClass(type.BaseType as TypeDefinition))
            {
                virtualMethods = new List<MethodDefinition>(getVirtualMethodForType(type.BaseType as TypeDefinition));
            }
            else
            {
                virtualMethods = new List<MethodDefinition>(ObjectVirtualMethodDefinitionList);
            }
            int index = virtualMethods.Count;
            foreach (var method in type.Methods)
            {
                if (method.IsVirtual && method.IsNewSlot)
                {
                    virtualMethods.Add(method);
                }
            }

            InternalTypeToVirtualMethods.Add(type, virtualMethods);
            foreach (var vmethod in virtualMethods)
            {
                if (!virtualMethodToIndex.ContainsKey(vmethod))
                {
                    virtualMethodToIndex.Add(vmethod, index++);
                }
            }
            return virtualMethods;
        }

        public int virtualMethodInVTableIndex(MethodDefinition method)
        {
            var list = getVirtualMethodForType(method.DeclaringType);
            var baseMethod = findInitDefineVirtualMethod(method.DeclaringType as TypeDefinition, method);
            return list.FindIndex(li => li == baseMethod || li == method);
        }

        public void writeVTable(TypeDefinition type,int[] vTables,List<MethodDefinition> vT)
        {
            if (type.BaseType != null && isNewClass(type.BaseType as TypeDefinition))
            {
                writeVTable(type.BaseType as TypeDefinition, vTables,vT);
            }
            foreach (var an in (from method in type.Methods
                                where method.IsVirtual
                                where !method.IsAbstract
                                select method))
            {
                int index = 0;
                if (!virtualMethodToIndex.TryGetValue(an,out index))
                {
                    index = virtualMethodInVTableIndex(an);
                }
                if (!methodToId.ContainsKey(an))
                {
                    vTables[index] = getMethodId(an, null, false).Id;
                }
                else
                    vTables[index] = methodToId[an];
            }
            
        }
    }

}
```

`Source/VSProj/Src/Tools/GenerateConfigure.cs`:

```cs
/*
 * Tencent is pleased to support the open source community by making InjectFix available.
 * Copyright (C) 2019 Tencent.  All rights reserved.
 * InjectFix is licensed under the MIT License, except for the third-party components listed in the file 'LICENSE' which may be subject to their corresponding license terms. 
 * This file is subject to the terms and conditions defined in file 'LICENSE', which is part of this source code package.
 */

using System.Collections.Generic;
using System.IO;
using Mono.Cecil;
using Mono.Cecil.Cil;
using System;
using System.Linq;

namespace IFix
{
    public abstract class GenerateConfigure
    {
        public static GenerateConfigure Empty()
        {
            return new EmptyGenerateConfigure();
        }

        //仅仅简单的从文件加载类名而已
        public static GenerateConfigure FromFile(string filename)
        {
            DefaultGenerateConfigure generateConfigure = new DefaultGenerateConfigure();

            using (BinaryReader reader = new BinaryReader(File.Open(filename, FileMode.Open)))
            {
                int configureNum = reader.ReadInt32();
                for (int i = 0; i < configureNum; i++)
                {
                    string configureName = reader.ReadString();
                    Dictionary<string, int> configure = new Dictionary<string, int>();
                    int cfgItemCount = reader.ReadInt32();
                    for (int j = 0; j < cfgItemCount; j++)
                    {
                        string typeName = reader.ReadString();
                        int flag = reader.ReadInt32();
                        configure[typeName] = flag;
                    }
                    generateConfigure.configures[configureName] = configure;
                }
                generateConfigure.blackListMethodInfo = readMatchInfo(reader);
            }

            return generateConfigure;
        }

        /// <summary>
        /// 如果一个方法打了指定的标签，返回其配置的标志位
        /// </summary>
        /// <param name="tag">标签</param>
        /// <param name="method">要查询的方法</param>
        /// <param name="flag">输出参数，用户配置的标志位</param>
        /// <returns></returns>
        public abstract bool TryGetConfigure(string tag, MethodReference method, out int flag);

        /// <summary>
        /// 判断一个方法是否是新增方法
        /// </summary>
        /// <param name="method">要查询的方法</param>
        /// <returns></returns>
        public abstract bool IsNewMethod(MethodReference method);

        public abstract bool IsNewClass(TypeReference type);

        public abstract bool isNewField(FieldReference field);

        public abstract void AddNewMethod(MethodReference method);

        public abstract void AddNewClass(TypeReference type);

        public abstract void AddNewField(FieldReference field);

        //参数类型信息
        internal class ParameterMatchInfo
        {
            public bool IsOut;
            public string ParameterType;
        }

        //方法签名信息
        internal class MethodMatchInfo
        {
            public string Name;
            public string ReturnType;
            public ParameterMatchInfo[] Parameters;
        }

        internal class FieldMatchInfo
        {
            public string Name;
            public string FieldType;
        }

        internal class PropertyMatchInfo
        {
            public string Name;
            public string PropertyType;
        }

        //判断一个方法是否能够在matchInfo里头能查询到
        internal static bool isMatch(Dictionary<string, MethodMatchInfo[]> matchInfo, MethodReference method)
        {
            MethodMatchInfo[] mmis;
            if (matchInfo.TryGetValue(method.DeclaringType.FullName, out mmis))
            {
                foreach (var mmi in mmis)
                {
                    if (mmi.Name == method.Name && mmi.ReturnType == method.ReturnType.FullName
                        && mmi.Parameters.Length == method.Parameters.Count)
                    {
                        bool paramMatch = true;
                        for (int i = 0; i < mmi.Parameters.Length; i++)
                        {
                            var paramType = method.Parameters[i].ParameterType;
                            if (paramType.IsRequiredModifier)
                            {
                                paramType = (paramType as RequiredModifierType).ElementType;
                            }
                            if (mmi.Parameters[i].IsOut != method.Parameters[i].IsOut
                                || mmi.Parameters[i].ParameterType != paramType.FullName)
                            {
                                paramMatch = false;
                                break;
                            }
                        }
                        if (paramMatch) return true;
                    }
                }
            }
            return false;
        }

        internal static bool isMatchForField(Dictionary<string, FieldMatchInfo[]> matchInfo, FieldReference field)
        {
            FieldMatchInfo[] mmis;
            if (matchInfo.TryGetValue(field.DeclaringType.FullName, out mmis))
            {
                foreach (var mmi in mmis)
                {
                    if (mmi.Name == field.Name && mmi.FieldType == field.FieldType.FullName)
                    {
                        return true;
                    }
                }
            }
            return false;
        }

        internal static bool isMatchForProperty(Dictionary<string, PropertyMatchInfo[]> matchInfo, PropertyReference property)
        {
            PropertyMatchInfo[] mmis;
            if (matchInfo.TryGetValue(property.DeclaringType.FullName, out mmis))
            {
                foreach (var mmi in mmis)
                {
                    if (mmi.Name == property.Name && mmi.PropertyType == property.PropertyType.FullName)
                    {
                        return true;
                    }
                }
            }
            return false;
        }

        internal static bool isMatchForClass(HashSet<string> matchInfo, TypeReference type)
        {
            if (matchInfo.Contains(type.ToString()))
            {
                return true;
            }
            return false;
        }

        //读取方法信息，主要是方法的签名信息，名字+参数类型+返回值类型
        internal static Dictionary<string, MethodMatchInfo[]> readMatchInfo(BinaryReader reader)
        {
            Dictionary<string, MethodMatchInfo[]> matchInfo = new Dictionary<string, MethodMatchInfo[]>();

            int typeCount = reader.ReadInt32();
            for (int k = 0; k < typeCount; k++)
            {
                string typeName = reader.ReadString();
                int methodCount = reader.ReadInt32();
                MethodMatchInfo[] methodMatchInfos = new MethodMatchInfo[methodCount];
                for (int i = 0; i < methodCount; i++)
                {
                    MethodMatchInfo mmi = new MethodMatchInfo();
                    mmi.Name = reader.ReadString();
                    mmi.ReturnType = reader.ReadString();
                    int parameterCount = reader.ReadInt32();
                    mmi.Parameters = new ParameterMatchInfo[parameterCount];
                    for (int p = 0; p < parameterCount; p++)
                    {
                        mmi.Parameters[p] = new ParameterMatchInfo();
                        mmi.Parameters[p].IsOut = reader.ReadBoolean();
                        mmi.Parameters[p].ParameterType = reader.ReadString();
                    }
                    methodMatchInfos[i] = mmi;
                }
                matchInfo[typeName] = methodMatchInfos;
            }

            return matchInfo;
        }

        internal static Dictionary<string, FieldMatchInfo[]> readFieldInfo(BinaryReader reader)
        {
            Dictionary<string, FieldMatchInfo[]> matchInfo = new Dictionary<string, FieldMatchInfo[]>();

            int typeCount = reader.ReadInt32();
            for (int k = 0; k < typeCount; k++)
            {
                string typeName = reader.ReadString();
                int methodCount = reader.ReadInt32();
                FieldMatchInfo[] fieldMatchInfos = new FieldMatchInfo[methodCount];
                for (int i = 0; i < methodCount; i++)
                {
                    FieldMatchInfo fmi = new FieldMatchInfo();
                    fmi.Name = reader.ReadString();
                    fmi.FieldType = reader.ReadString();
                    fieldMatchInfos[i] = fmi;
                }
                matchInfo[typeName] = fieldMatchInfos;
            }

            return matchInfo;
        }

        internal static Dictionary<string, PropertyMatchInfo[]> readPropertyInfo(BinaryReader reader)
        {
            Dictionary<string, PropertyMatchInfo[]> matchInfo = new Dictionary<string, PropertyMatchInfo[]>();

            int typeCount = reader.ReadInt32();
            for (int k = 0; k < typeCount; k++)
            {
                string typeName = reader.ReadString();
                int methodCount = reader.ReadInt32();
                PropertyMatchInfo[] propertyMatchInfos = new PropertyMatchInfo[methodCount];
                for (int i = 0; i < methodCount; i++)
                {
                    PropertyMatchInfo pmi = new PropertyMatchInfo();
                    pmi.Name = reader.ReadString();
                    pmi.PropertyType = reader.ReadString();
                    propertyMatchInfos[i] = pmi;
                }
                matchInfo[typeName] = propertyMatchInfos;
            }

            return matchInfo;
        }

        internal static HashSet<string> readMatchInfoForClass(BinaryReader reader)
        {
            HashSet<string> setMatchInfoForClass = new HashSet<string>();
            int typeCount = reader.ReadInt32();
            for (int k = 0; k < typeCount; k++)
            {
                string className = reader.ReadString();
                setMatchInfoForClass.Add(className);
            }
            return setMatchInfoForClass;
        }
    }

    //内部测试专用
    public class EmptyGenerateConfigure : GenerateConfigure
    {
        public override bool TryGetConfigure(string tag, MethodReference method, out int flag)
        {
            flag = 0;
            return true;
        }

        public override bool IsNewMethod(MethodReference method)
        {
            return false;
        }
        public override bool IsNewClass(TypeReference type)
        {
            return false;
        }

        public override bool isNewField(FieldReference field)
        {
            return false;
        }

        public override void AddNewMethod(MethodReference method)
        {

        }

        public override void AddNewClass(TypeReference type)
        {

        }

        public override void AddNewField(FieldReference field)
        {

        }
    }

    //注入配置使用
    public class DefaultGenerateConfigure : GenerateConfigure
    {
        internal Dictionary<string, Dictionary<string, int>> configures
            = new Dictionary<string, Dictionary<string, int>>();

        internal Dictionary<string, MethodMatchInfo[]> blackListMethodInfo = null;

        public override bool TryGetConfigure(string tag, MethodReference method, out int flag)
        {
            Dictionary<string, int> configure;
            flag = 0;
            if(tag == "IFix.IFixAttribute" && blackListMethodInfo != null)
            {
                if(isMatch(blackListMethodInfo, method))
                {
                    return false;
                }
            }
            return (configures.TryGetValue(tag, out configure)
                && configure.TryGetValue(method.DeclaringType.FullName, out flag));
        }

        public override bool IsNewMethod(MethodReference method)
        {
            return false;
        }
        public override bool IsNewClass(TypeReference type)
        {
            return false;
        }
        public override bool isNewField(FieldReference field)
        {
            return false;
        }
        public override void AddNewMethod(MethodReference method)
        {
            
        }
        public override void AddNewClass(TypeReference type)
        {

        }
        public override void AddNewField(FieldReference field)
        {

        }
    }

    //patch配置使用
    public class PatchGenerateConfigure : GenerateConfigure
    {
        public override bool TryGetConfigure(string tag, MethodReference method, out int flag)
        {
            flag = 0;
            if (tag == "IFix.InterpretAttribute")
            {
                return redirectMethods.Contains(method);
            }
            else if (tag == "IFix.IFixAttribute")
            {
                return switchMethods.Contains(method);
            }
            return false;
        }

        public override bool IsNewMethod(MethodReference method)
        {
            return newMethods.Contains(method);
        }

        public override bool IsNewClass(TypeReference type)
        {
            return newClasses.Contains(type);
        }

        public override bool isNewField(FieldReference field)
        {
            return newFields.Contains(field);
        }

        public override void AddNewMethod(MethodReference method)
        {
            newMethods.Add(method);
        }

        public override void AddNewClass(TypeReference type)
        {
            newClasses.Add(type);
        }

        public override void AddNewField(FieldReference field)
        {
            newFields.Add(field);
        }

        //暂时不支持redirect类型的方法
        HashSet<MethodReference> redirectMethods = new HashSet<MethodReference>();
        HashSet<MethodReference> switchMethods = new HashSet<MethodReference>();
        HashSet<MethodReference> newMethods = new HashSet<MethodReference>();
        HashSet<TypeReference> newClasses = new HashSet<TypeReference>();
        HashSet<FieldReference> newFields = new HashSet<FieldReference>();
        MethodDefinition findMatchMethod(Dictionary<string, Dictionary<string, List<MethodDefinition>>> searchData,
            MethodDefinition method)
        {
            Dictionary<string, List<MethodDefinition>> methodsOfType;
            List<MethodDefinition> overloads;
            if (searchData.TryGetValue(method.DeclaringType.FullName, out methodsOfType)
                && methodsOfType.TryGetValue(method.Name, out overloads))
            {
                foreach (var overload in overloads)
                {
                    if (overload.IsTheSame(method))
                    {
                        return overload;
                    }
                }
            }
            return null;
        }

        private static bool isCompilerGenerated(FieldReference field)
        {
            var fd = field as FieldDefinition;
            return fd != null && fd.CustomAttributes.Any(ca => ca.AttributeType.FullName 
            == "System.Runtime.CompilerServices.CompilerGeneratedAttribute");
        }

        //读取配置信息（要patch的方法列表，新增方法列表）
        public PatchGenerateConfigure(AssemblyDefinition newAssembly, string cfgPath)
        {
            Dictionary<string, MethodMatchInfo[]> patchMethodInfo = null;
            Dictionary<string, MethodMatchInfo[]> newMethodInfo = null;
            Dictionary<string, FieldMatchInfo[]> newFieldsInfo = null;
            Dictionary<string, PropertyMatchInfo[]> newPropertiesInfo = null;
            HashSet<string> newClassInfo = null;

            using (BinaryReader reader = new BinaryReader(File.Open(cfgPath, FileMode.Open)))
            {
                patchMethodInfo = readMatchInfo(reader);
                newMethodInfo = readMatchInfo(reader);
                newFieldsInfo = readFieldInfo(reader);
                newPropertiesInfo = readPropertyInfo(reader);
                newClassInfo = readMatchInfoForClass(reader);
            }

            foreach (var method in (from type in newAssembly.GetAllType() from method in type.Methods select method ))
            {
                if (isMatch(patchMethodInfo, method))
                {
                    switchMethods.Add(method);
                }
                if (isMatch(newMethodInfo, method))
                {
                    AddNewMethod(method);
                }
            }
            foreach (var clas in newAssembly.GetAllType())
            {
                if (isMatchForClass(newClassInfo, clas))
                {
                    AddNewClass(clas);
                }
            }
            foreach (var property in (from type in newAssembly.GetAllType() from property in type.Properties select property))
            {
                if (isMatchForProperty(newPropertiesInfo, property))
                {
                    AddNewMethod(property.SetMethod);
                    AddNewMethod(property.GetMethod);

                    var methods = new List<MethodDefinition>{property.GetMethod, property.SetMethod};
                    
                    var defination = newAssembly.MainModule.GetType(property.DeclaringType.FullName);
                    foreach (var field in ( from method in methods
                        where method != null && method.IsSpecialName && method.Body != null 
                            && method.Body.Instructions != null
                        from instruction in method.Body.Instructions
                        where instruction.OpCode.Code == Mono.Cecil.Cil.Code.Ldsfld
                            || instruction.OpCode.Code == Mono.Cecil.Cil.Code.Stsfld
                            || instruction.OpCode.Code == Mono.Cecil.Cil.Code.Ldsflda
                            || instruction.OpCode.Code == Mono.Cecil.Cil.Code.Ldfld
                            || instruction.OpCode.Code == Mono.Cecil.Cil.Code.Stfld
                            || instruction.OpCode.Code == Mono.Cecil.Cil.Code.Ldflda
                        where isCompilerGenerated(instruction.Operand as Mono.Cecil.FieldReference)
                        select (instruction.Operand as Mono.Cecil.FieldReference).Resolve()).Distinct())
                    {
                        var backingField = property.DeclaringType.Fields.FirstOrDefault(f => f.FullName == field.FullName);
                        if(backingField != null)
                        {
                            AddNewField(backingField);
                        }
                    }
                }
            }
            foreach (var field in (from type in newAssembly.GetAllType() from field in type.Fields select field ))
            {
                if (isMatchForField(newFieldsInfo, field))
                {
                    AddNewField(field);
                }
            }
        }
    }
}
```

`Source/VSProj/Src/UnitTest/VirtualMachineTest.cs`:

```cs
/*
 * Tencent is pleased to support the open source community by making InjectFix available.
 * Copyright (C) 2019 Tencent.  All rights reserved.
 * InjectFix is licensed under the MIT License, except for the third-party components listed in the file 'LICENSE' which may be subject to their corresponding license terms. 
 * This file is subject to the terms and conditions defined in file 'LICENSE', which is part of this source code package.
 */

using NUnit.Framework;
using IFix.Core;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;

namespace IFix.Test
{
    [TestFixture]
    unsafe public class VirtualMachineTest
    {
        [OneTimeSetUpAttribute]
        public static void Init()
        {
            /*if (!Directory.Exists("../Data"))
            {
                Directory.CreateDirectory("../Data");
            }
            Process ilfix = new Process();
            ilfix.StartInfo.FileName = "../Bin/IFix.exe";
            ilfix.StartInfo.Arguments = "../Lib/IFix.TestDLL.dll ../Data/ ../Lib/IFix.Core.dll";
            ilfix.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;
            ilfix.StartInfo.RedirectStandardOutput = true;
            ilfix.StartInfo.UseShellExecute = false;
            ilfix.StartInfo.CreateNoWindow = true;
            ilfix.Start();
            ilfix.WaitForExit();*/
            //Console.WriteLine(typeof(int[]).MakeByRefType().AssemblyQualifiedName);
            using (FileStream fs = File.Open("../Data/IFix.TestDLL.Redirect.dif", FileMode.Open))
            {
                PatchManager.Load(fs);
            }
        }

        [Test]
        public void SimpleTest()
        {
            var virtualMachine = SimpleVirtualMachineBuilder.CreateVirtualMachine(1);
            Call call = Call.Begin();
            call.PushInt32(4);
            call.PushInt32(6);
            virtualMachine.Execute(0, ref call, 2);
            Call.End(ref call);
            Assert.AreEqual(10, call.GetInt32());
        }

        [Test]
        public void FileVMBuildBaseTest()
        {
            /*var virtualMachine = FileVirtualMachineBuilder.CreateVirtualMachine("../Data/IFix.TestDLL.dif");
            for (int i = 0; i < 10; i++)
            {
                Call call = Call.Begin();
                call.PushInteger(i);
                virtualMachine.Execute(1, ref call, 1);
                Call.End(ref call);
                Assert.AreEqual(BaseTest.Base(i), call.GetResultAsLong());
            }*/
            for (int i = 0; i < 10; i++)
            {
                Assert.AreEqual(BaseTest.Base(i), Redirect.BaseTest.Base(i));
            }
        }

        [Test]
        public void RefBase()
        {
            //几个典型基础值类型的引用类型测试
            int a1 = 2;
            long b1 = 5;
            int c1 = 1;
            long r1 = BaseTest.Ref(ref a1, a1, ref b1, b1, out c1);

            int a2 = 2;
            long b2 = 5;
            int c2 = 1;
            long r2 = Redirect.BaseTest.Ref(ref a2, a2, ref b2, b2, out c2);

            Assert.AreEqual(a1, a2);
            Assert.AreEqual(b1, b2);
            Assert.AreEqual(c1, c2);
            Assert.AreEqual(r1, r2);

            //对象的引用测试
            object o1 = new object();
            object o2 = new object();

            object p1 = o1;
            object p2 = o2;
            Redirect.BaseTest.Ref(ref p1, ref p2);
            Assert.True(ReferenceEquals(o1, p2));
            Assert.True(ReferenceEquals(o2, p1));

            //结构体的引用测试
            Redirect.ValueTypeCounter v1 = new Redirect.ValueTypeCounter(1);
            Redirect.ValueTypeCounter v2 = new Redirect.ValueTypeCounter(2);

            Redirect.BaseTest.Ref(ref v1, ref v2);
            Assert.AreEqual(1, v2.Val);
            Assert.AreEqual(2, v1.Val);

            for (int i = 0; i < VirtualMachine.MAX_EVALUATION_STACK_SIZE; i++)
            {
                int a = 2;
                long b = 5;
                int c = 1;
                Redirect.BaseTest.Ref(ref a, a, ref b, b, out c);
            }
        }

        [Test]
        public void ExceptionBase()
        {
            //BaseTest.ExceptionBase(1);
            //BaseTest.ExceptionBase(-1);
            //之所以要进行MAX_EVALUATION_STACK_SIZE次测试，是测试有漏清理栈对象
            for (int j = 2; j < VirtualMachine.MAX_EVALUATION_STACK_SIZE + 2; j++)
            {
                int tmp1 = j;
                BaseTest.ExceptionBase(ref tmp1);
                int tmp2 = j;
                //Console.WriteLine("before:" + tmp2);
                Redirect.BaseTest.ExceptionBase(ref tmp2);
                //Console.WriteLine("after:" + tmp2);
                Assert.AreEqual(tmp1, tmp2);
            }

            //基础异常流程测试
            int i1 = -1, i2 = -1;
            Assert.That(() => BaseTest.ExceptionBase(ref i1), Throws.ArgumentException);
            Assert.That(() => Redirect.BaseTest.ExceptionBase(ref i2), Throws.ArgumentException);
            //Console.WriteLine(i2);

            i1 = 0;
            i2 = 0;
            Assert.That(() => BaseTest.ExceptionBase(ref i1), Throws.InvalidOperationException);
            Assert.That(() => Redirect.BaseTest.ExceptionBase(ref i2), Throws.InvalidOperationException);
            //Console.WriteLine(i);

            //BaseTest.ExceptionBase(10);
            Assert.Throws<InvalidOperationException>(() => BaseTest.Rethrow());
            Assert.Throws<InvalidOperationException>(() => Redirect.BaseTest.Rethrow());
        }

        //各种异常跳出点的测试
        [Test]
        public void LeavePoint()
        {
            int a1 = 0, b1 = 0, c1 = 0, a2 = 0, b2 = 0, c2 = 0;

            BaseTest.LeavePoint(0, ref a1, ref b1, ref c1);
            Redirect.BaseTest.LeavePoint(0, ref a2, ref b2, ref c2);
            Assert.AreEqual(a1, a2);
            Assert.AreEqual(b1, b2);
            Assert.AreEqual(c1, c2);

            a1 = 0; b1 = 0; c1 = 0; a2 = 0; b2 = 0; c2 = 0;
            BaseTest.LeavePoint(1, ref a1, ref b1, ref c1);
            Redirect.BaseTest.LeavePoint(1, ref a2, ref b2, ref c2);
            Assert.AreEqual(a1, a2);
            Assert.AreEqual(b1, b2);
            Assert.AreEqual(c1, c2);

            a1 = 0; b1 = 0; c1 = 0; a2 = 0; b2 = 0; c2 = 0;
            BaseTest.LeavePoint(2, ref a1, ref b1, ref c1);
            Redirect.BaseTest.LeavePoint(2, ref a2, ref b2, ref c2);
            Assert.AreEqual(a1, a2);
            Assert.AreEqual(b1, b2);
            Assert.AreEqual(c1, c2);

            a1 = 0; b1 = 0; c1 = 0; a2 = 0; b2 = 0; c2 = 0;
            BaseTest.LeavePoint(3, ref a1, ref b1, ref c1);
            Redirect.BaseTest.LeavePoint(3, ref a2, ref b2, ref c2);
            Assert.AreEqual(a1, a2);
            Assert.AreEqual(b1, b2);
            Assert.AreEqual(c1, c2);
        }

        //finally逻辑的测试
        [Test]
        public void TryCatchFinally()
        {
            bool t1, t2;
            bool c1, c2;
            bool f1, f2;
            bool e1, e2;

            t1 = c1 = f1 = e1 = false;
            t2 = c2 = f2 = e2 = false;
            BaseTest.TryCatchFinally(false, ref t1, ref c1, ref f1, ref e1);
            Redirect.BaseTest.TryCatchFinally(false, ref t2, ref c2, ref f2, ref e2);
            Assert.AreEqual(t1, t2);
            Assert.AreEqual(c1, c2);
            Assert.AreEqual(f1, f2);
            Assert.AreEqual(e1, e2);

            t1 = c1 = f1 = e1 = false;
            t2 = c2 = f2 = e2 = false;
            BaseTest.TryCatchFinally(true, ref t1, ref c1, ref f1, ref e1);
            Redirect.BaseTest.TryCatchFinally(true, ref t2, ref c2, ref f2, ref e2);
            Assert.AreEqual(t1, t2);
            Assert.AreEqual(c1, c2);
            Assert.AreEqual(f1, f2);
            Assert.AreEqual(e1, e2);

            //BaseTest.ConstrainedInstruction(true, 1);
        }

        //try-catch嵌套测试
        [Test]
        public void CatchByNextLevel()
        {
            bool a1, a2, a3;
            bool b1, b2, b3;
            BaseTest.CatchByNextLevel(out a1, out a2, out a3);
            Redirect.BaseTest.CatchByNextLevel(out b1, out b2, out b3);
            Assert.AreEqual(a1, b1);
            Assert.AreEqual(a2, b2);
            Assert.AreEqual(a3, b3);
        }

        //public class ShallowCloneTest
        //{
        //    public int Foo;
        //    public long Bar;

            //    public ShallowCloneTest Clone()
            //    {
            //        return (ShallowCloneTest)base.MemberwiseClone();
            //    }
            //}

        //class基础测试
        [Test]
        public void ClassBase()
        {
            Redirect.RefTypeCounter rtc = new Redirect.RefTypeCounter();
            int c = rtc.Val;
            rtc.Inc();//TODO: 反射访问字段非常慢
            Assert.AreEqual(rtc.Val, c + 1);
            //var MemberwiseClone = typeof(object).GetMethod("MemberwiseClone",
            //    System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic);
            //object vt = new ValueTypeCounter();
            ////ShallowCloneTest t1 = new ShallowCloneTest() { Bar = 1, Foo = 2 };
            //Stopwatch sw = Stopwatch.StartNew();
            ////Console.Write("m:" + MemberwiseClone);
            //var objClone = new ObjectClone();
            //for (int i = 0; i < 1000000; ++i)
            //{
            //    //var cloned = t1.Clone();
            //    //MemberwiseClone.Invoke(t1, null);
            //    //MemberwiseClone.Invoke(vt, null);
            //    //var cloned = ObjectCloner.Clone(t1);
            //    var cloned = objClone.Clone(vt);
            //}
            //Console.WriteLine("Took {0:0.00}s", sw.Elapsed.TotalSeconds);
        }

        //结构体基础测试
        [Test]
        public void StructBase()
        {
            Redirect.ValueTypeCounter vtc = new Redirect.ValueTypeCounter();
            int c = vtc.Val;
            vtc.Inc();
            Assert.AreEqual(vtc.Val, c + 1);
        }

        //参数值传递测试
        [Test]
        public void PassByValue()
        {
            Redirect.ValueTypeCounter c1 = new Redirect.ValueTypeCounter();
            Redirect.RefTypeCounter c2 = new Redirect.RefTypeCounter();
            Redirect.BaseTest.PassByValue(ref c1, c2);
            //Console.WriteLine("c1.v:" + c1.Val + ",c2.v:" + c2.Val);
            Assert.AreEqual(2, c2.Val);
            Assert.AreEqual(1, c1.Val);
        }

        //虚函数测试
        [Test]
        public void VirtualFunc()
        {
            int r1, r2;
            Redirect.BaseTest.VirtualFunc(out r1, out r2);
            Assert.AreEqual(0, r1);
            Assert.AreEqual(1, r2);
            Redirect.BaseClass o1 = new Redirect.BaseClass();
            Redirect.BaseClass o2 = new Redirect.DrivenClass();
            Assert.AreEqual(0, o1.Foo());
            Assert.AreEqual(1, o2.Foo());
        }

        //接口测试
        [Test]
        public void InterfaceTest()
        {
            Assert.AreEqual(30, Redirect.BaseTest.InterfaceTest(1, 2, 10));
        }

        //结构体虚函数测试
        [Test]
        public void VirtualFuncOfStruct()
        {
            Redirect.ValueTypeCounter c1 = new Redirect.ValueTypeCounter();
            c1.Inc();
            c1.Inc();
            Assert.AreEqual("ValueTypeCounter { 2 }", c1.ToString());

            Assert.AreEqual(c1.ToString() + ",hashcode:" + c1.GetHashCode(), Redirect.BaseTest.VirtualFuncOfStruct(c1));
        }

        //带ref参数的interface测试
        [Test]
        public void ItfWithRefParam()
        {
            int a = 10;
            int b;
            int ret = Redirect.BaseTest.ItfWithRefParam(ref a, out b);
            //Console.WriteLine("a:" + a + ",b:" + b + ",ret:" + ret);
            Assert.AreEqual(20, a);
            Assert.AreEqual(21, b);
            Assert.AreEqual(20, ret);
        }

        //ldtoken指令的测试
        [Test]
        public void LdTokenBase()
        {
            Assert.AreEqual(typeof(int), Redirect.BaseTest.GetIntType());
        }

        //unbox指令测试
        [Test]
        public void UnboxBase()
        {
            Redirect.ValueTypeCounter c1 = new Redirect.ValueTypeCounter();
            Redirect.ValueTypeCounter c2 = new Redirect.ValueTypeCounter();
            c1.Inc();
            Assert.AreEqual(1, c1.CompareTo(c2));
            c2.Inc();
            Assert.AreEqual(0, c1.CompareTo(c2));
            c2.Inc();
            Assert.AreEqual(-1, c1.CompareTo(c2));

            Assert.That(() => c1.CompareTo(1), Throws.ArgumentException);
        }

        //泛型签名测试
        [Test]
        public void GenericOverload()
        {
            Assert.AreEqual(BaseTest.GenericOverload(), Redirect.BaseTest.GenericOverload());
            //Console.WriteLine(Redirect.BaseTest.GenericOverload());
        }

        //静态字段测试
        [Test]
        public void StaticFieldBase()
        {
            for (int i = 0; i < 10; i++)
            {
                Assert.AreEqual(BaseTest.StaticFieldBase(), Redirect.BaseTest.StaticFieldBase());
            }
        }

        //ConvI4指令
        [Test]
        public void ConvI4Base()
        {
            Assert.AreEqual(BaseTest.Conv_I4((float)uint.MaxValue),
                Redirect.BaseTest.Conv_I4((float)uint.MaxValue));
            Assert.AreEqual(BaseTest.Conv_I4((double)uint.MaxValue),
                Redirect.BaseTest.Conv_I4((double)uint.MaxValue));
            Assert.AreEqual(BaseTest.Conv_I4(long.MaxValue),
                Redirect.BaseTest.Conv_I4(long.MaxValue));
            Assert.Throws<OverflowException>(() => Redirect.BaseTest.Conv_Ovf_I4_Un(uint.MaxValue));
            Assert.Throws<OverflowException>(() => Redirect.BaseTest.Conv_Ovf_I4(long.MaxValue));
        }

        //LdLen指令
        [Test]
        public void LdLen()
        {
            for (int i = 0; i < 10; i++)
            {
                Assert.AreEqual(i, Redirect.BaseTest.Ldlen(new int[i]));
            }
        }

        //Newarr指令
        [Test]
        public void Newarr()
        {
            for (int i = 0; i < 10; i++)
            {
                Assert.AreEqual(i, Redirect.BaseTest.Newarr(i).Length);
            }
        }

        //Isinst，Castclass指令
        [Test]
        public void Cast()
        {
            Redirect.BaseClass bc = new Redirect.BaseClass();
            Assert.AreEqual(null, Redirect.BaseTest.Isinst(bc));
            Assert.Throws<InvalidCastException>(() => Redirect.BaseTest.Castclass(bc));
        }

        //数组测试
        [Test]
        public void Array()
        {
            object[] objArr = new object[2];
            Redirect.BaseTest.ArraySet(objArr, 0);
            var now = DateTime.Now;
            Redirect.BaseTest.ArraySet(objArr, 1, now);
            Assert.AreEqual(1, objArr[0]);
            Assert.AreEqual(now, objArr[1]);
            Assert.AreEqual(1, Redirect.BaseTest.ArrayGet(objArr, 0));
            Assert.AreEqual(now, Redirect.BaseTest.ArrayGet(objArr, 1));
            Assert.Throws<NullReferenceException>(() => Redirect.BaseTest.ArraySet(null, 1));
            Assert.Throws<IndexOutOfRangeException>(() => Redirect.BaseTest.ArraySet(objArr, -1));
            Assert.Throws<IndexOutOfRangeException>(() => Redirect.BaseTest.ArraySet(objArr, 2));
            byte[] byteArr = new byte[2] { 1, 2 };
            Assert.AreEqual(1, Redirect.BaseTest.ArrayGet(byteArr, 0));
            Assert.AreEqual(2, Redirect.BaseTest.ArrayGet(byteArr, 1));
            Redirect.BaseTest.ArraySet(byteArr, 0, 10);
            Assert.AreEqual(10, byteArr[0]);
            Assert.AreEqual(2, byteArr[1]);
            Redirect.BaseTest.ArraySet(byteArr, 1, 20);
            Assert.AreEqual(10, byteArr[0]);
            Assert.AreEqual(20, byteArr[1]);

            int[] intArr = new int[2] { 1, 2 };
            Assert.AreEqual(1, Redirect.BaseTest.ArrayGet(intArr, 0));
            Assert.AreEqual(2, Redirect.BaseTest.ArrayGet(intArr, 1));
            Redirect.BaseTest.ArraySet(intArr, 0, 10);
            Assert.AreEqual(10, intArr[0]);
            Assert.AreEqual(2, intArr[1]);
            Redirect.BaseTest.ArraySet(intArr, 1, 20);
            Assert.AreEqual(10, intArr[0]);
            Assert.AreEqual(20, intArr[1]);

            intArr = new int[2] { 1, 2 };
            Assert.AreEqual(1, Redirect.BaseTest.ArrayGet(intArr, (uint)0));
            Assert.AreEqual(2, Redirect.BaseTest.ArrayGet(intArr, (uint)1));
            Redirect.BaseTest.ArraySet(intArr, (uint)0, 10);
            Assert.AreEqual(10, intArr[0]);
            Assert.AreEqual(2, intArr[1]);

            uint[] uintArr = new uint[2] { 1, 2 };
            Assert.AreEqual(1, Redirect.BaseTest.ArrayGet(uintArr, 0));
            Assert.AreEqual(2, Redirect.BaseTest.ArrayGet(uintArr, 1));
            Redirect.BaseTest.ArraySet(uintArr, 0, 10);
            Assert.AreEqual(10, uintArr[0]);
            Assert.AreEqual(2, uintArr[1]);
            Redirect.BaseTest.ArraySet(uintArr, 1, 20);
            Assert.AreEqual(10, uintArr[0]);
            Assert.AreEqual(20, uintArr[1]);

            float[] floatArr = new float[2] { 1, 2 };
            Assert.AreEqual(1, Redirect.BaseTest.ArrayGet(floatArr, 0));
            Assert.AreEqual(2, Redirect.BaseTest.ArrayGet(floatArr, 1));
            Redirect.BaseTest.ArraySet(floatArr, 0, 10);
            Assert.AreEqual(10, floatArr[0]);
            Assert.AreEqual(2, floatArr[1]);
            Redirect.BaseTest.ArraySet(floatArr, 1, 20);
            Assert.AreEqual(10, floatArr[0]);
            Assert.AreEqual(20, floatArr[1]);

            double[] doubleArr = new double[2] { 1, 2 };
            Assert.AreEqual(1, Redirect.BaseTest.ArrayGet(doubleArr, 0));
            Assert.AreEqual(2, Redirect.BaseTest.ArrayGet(doubleArr, 1));
            Redirect.BaseTest.ArraySet(doubleArr, 0, 10);
            Assert.AreEqual(10, doubleArr[0]);
            Assert.AreEqual(2, doubleArr[1]);
            Redirect.BaseTest.ArraySet(doubleArr, 1, 20);
            Assert.AreEqual(10, doubleArr[0]);
            Assert.AreEqual(20, doubleArr[1]);

            short[] shortArr = new short[2] { 1, 2 };
            Assert.AreEqual(1, Redirect.BaseTest.ArrayGet(shortArr, 0));
            Assert.AreEqual(2, Redirect.BaseTest.ArrayGet(shortArr, 1));
            Redirect.BaseTest.ArraySet(shortArr, 0, 10);
            Assert.AreEqual(10, shortArr[0]);
            Assert.AreEqual(2, shortArr[1]);
            Redirect.BaseTest.ArraySet(shortArr, 1, 20);
            Assert.AreEqual(10, shortArr[0]);
            Assert.AreEqual(20, shortArr[1]);

            ushort[] ushortArr = new ushort[2] { 1, 2 };
            Assert.AreEqual(1, Redirect.BaseTest.ArrayGet(ushortArr, 0));
            Assert.AreEqual(2, Redirect.BaseTest.ArrayGet(ushortArr, 1));
            Redirect.BaseTest.ArraySet(ushortArr, 0, 10);
            Assert.AreEqual(10, ushortArr[0]);
            Assert.AreEqual(2, ushortArr[1]);
            Redirect.BaseTest.ArraySet(ushortArr, 1, 20);
            Assert.AreEqual(10, ushortArr[0]);
            Assert.AreEqual(20, ushortArr[1]);

            char[] charArr = new char[2] { 'a', 'b' };
            Assert.AreEqual('a', Redirect.BaseTest.ArrayGet(charArr, 0));
            Assert.AreEqual('b', Redirect.BaseTest.ArrayGet(charArr, 1));
            Redirect.BaseTest.ArraySet(charArr, 0, 'c');
            Assert.AreEqual('c', charArr[0]);
            Assert.AreEqual('b', charArr[1]);
            Redirect.BaseTest.ArraySet(charArr, 1, 'd');
            Assert.AreEqual('c', charArr[0]);
            Assert.AreEqual('d', charArr[1]);

            IntPtr[] intPtrArr = new IntPtr[] { new IntPtr(int.MaxValue), new IntPtr(int.MinValue) };
            Assert.AreEqual((long)int.MaxValue, Redirect.BaseTest.ArrayGet(intPtrArr, 0).ToInt64());
            Assert.AreEqual((long)int.MinValue, Redirect.BaseTest.ArrayGet(intPtrArr, 1).ToInt64());
            Redirect.BaseTest.ArraySet(intPtrArr, 0, new IntPtr(1));
            Assert.AreEqual((long)1, Redirect.BaseTest.ArrayGet(intPtrArr, 0).ToInt64());
            Assert.AreEqual((long)int.MinValue, Redirect.BaseTest.ArrayGet(intPtrArr, 1).ToInt64());
            Redirect.BaseTest.ArraySet(intPtrArr, 1, new IntPtr(2));
            Assert.AreEqual((long)1, Redirect.BaseTest.ArrayGet(intPtrArr, 0).ToInt64());
            Assert.AreEqual((long)2, Redirect.BaseTest.ArrayGet(intPtrArr, 1).ToInt64());

            UIntPtr[] uintPtrArr = new UIntPtr[] { new UIntPtr(int.MaxValue), new UIntPtr(0) };
            Assert.AreEqual((ulong)int.MaxValue, Redirect.BaseTest.ArrayGet(uintPtrArr, 0).ToUInt64());
            Assert.AreEqual((ulong)0, Redirect.BaseTest.ArrayGet(uintPtrArr, 1).ToUInt64());
            Redirect.BaseTest.ArraySet(uintPtrArr, 0, new UIntPtr(1));
            Assert.AreEqual((ulong)1, Redirect.BaseTest.ArrayGet(uintPtrArr, 0).ToUInt64());
            Assert.AreEqual((ulong)0, Redirect.BaseTest.ArrayGet(uintPtrArr, 1).ToUInt64());
            Redirect.BaseTest.ArraySet(uintPtrArr, 1, new UIntPtr(2));
            Assert.AreEqual((ulong)1, Redirect.BaseTest.ArrayGet(uintPtrArr, 0).ToUInt64());
            Assert.AreEqual((ulong)2, Redirect.BaseTest.ArrayGet(uintPtrArr, 1).ToUInt64());
        }

        //逻辑操作符
        [Test]
        public void LogicalOperator()
        {
            int a = 321312, b = 954932;
            Assert.AreEqual(a & b, Redirect.BaseTest.And(a, b));
            Assert.AreEqual(a | b, Redirect.BaseTest.Or(a, b));
            long c = 415661, d = 5415513;
            Assert.AreEqual(c & d, Redirect.BaseTest.And(c, d));
            Assert.AreEqual(c | d, Redirect.BaseTest.Or(c, d));
        }

        //Ldflda指令
        [Test]
        public void Ldflda()
        {
            Redirect.ValueTypeCounter c = new Redirect.ValueTypeCounter();
            Redirect.BaseTest.Ldflda(ref c);
            Assert.AreEqual(10, c.Val);
            Redirect.BaseTest.Ldflda(ref c);
            c.Inc();
            Assert.AreEqual(21, c.Val);

            c = new Redirect.ValueTypeCounter();
            Redirect.ValueTypeCounterContainer cc = new Redirect.ValueTypeCounterContainer();
            cc.c = c;
            Redirect.BaseTest.Ldflda(ref cc);
            Assert.AreEqual(10, cc.c.i);
            Redirect.BaseTest.Ldflda(ref cc);
            cc.c.Inc();
            Assert.AreEqual(21, cc.c.Val);

            Redirect.W1 w1 = new Redirect.W1()
            {
                F = new Redirect.ValueTypeCounter()
            };

            Redirect.W2 w2 = new Redirect.W2()
            {
                F = w1
            };

            Redirect.W3 w3 = new Redirect.W3()
            {
                F = w2
            };

            Redirect.BaseTest.Ldflda(ref w1);
            Assert.AreEqual(10, w1.F.i);

            Redirect.BaseTest.Ldflda(ref w2);
            Assert.AreEqual(10, w2.F.F.i);

            Redirect.BaseTest.Ldflda(ref w3);
            Assert.AreEqual(10, w3.F.F.F.i);

            Assert.AreEqual(10, Redirect.BaseTest.Ldflda_m(ref w3));
        }

        //Conv_Ovf_I指令
        [Test]
        public void Conv_Ovf_I()
        {
            int i = 10;
            Assert.AreEqual(i, Redirect.BaseTest.Conv_Ovf_I(i).Length);
        }

        //Ceq指令
        [Test]
        public void Ceq()
        {
            Assert.True(Redirect.BaseTest.Ceq(1, 1));
            Assert.False(Redirect.BaseTest.Ceq(321, 1));
            Assert.True(Redirect.BaseTest.Ceq((double)1, 1));
            Assert.False(Redirect.BaseTest.Ceq((double)321, 1));
        }

        //位操作符
        [Test]
        public void BitsOp()
        {
            int a = 321312;
            int bits = 5;
            long b = a;
            uint ua = uint.MaxValue;
            ulong ub = ulong.MaxValue;
            Assert.AreEqual(a << bits, Redirect.BaseTest.Shl(a, bits));
            Assert.AreEqual(b << bits, Redirect.BaseTest.Shl(b, bits));
            Assert.AreEqual(a >> bits, Redirect.BaseTest.Shr(a, bits));
            Assert.AreEqual(b >> bits, Redirect.BaseTest.Shr(b, bits));
            Assert.AreEqual(ua >> bits, Redirect.BaseTest.Shr_Un(ua, bits));
            Assert.AreEqual(ub >> bits, Redirect.BaseTest.Shr_Un(ub, bits));
            long c = 321421;
            Assert.AreEqual(a ^ bits, Redirect.BaseTest.Xor(a, bits));
            Assert.AreEqual(b ^ c, Redirect.BaseTest.Xor(b, c));

            Assert.AreEqual(~a, Redirect.BaseTest.Not(a));
            Assert.AreEqual(~b, Redirect.BaseTest.Not(b));
        }

        //Conv_U1指令
        [Test]
        public void Conv_U1()
        {
            int a = 1024;
            Assert.AreEqual(0, Redirect.BaseTest.Conv_U1(a));
            Assert.Throws<OverflowException>(() => Redirect.BaseTest.Conv_Ovf_U1(a));
            Assert.Throws<OverflowException>(() => Redirect.BaseTest.Conv_Ovf_U1_Un((uint)a));
        }

        [Test]
        public void Ldelema()
        {
            int[] arr = new int[] { 1, 2 };
            Redirect.BaseTest.Ldelema(arr, 0);
            Assert.AreEqual(11, arr[0]);
            Assert.AreEqual(2, arr[1]);
            Redirect.BaseTest.Ldelema(arr, 1);
            Assert.AreEqual(11, arr[0]);
            Assert.AreEqual(12, arr[1]);
        }

        [Test]
        public void Bgt()
        {
            Assert.AreEqual(1, Redirect.BaseTest.Bgt(3, 2));
            Assert.AreEqual(-1, Redirect.BaseTest.Bgt(2, 3));
            Assert.AreEqual(0, Redirect.BaseTest.Bgt(3, 3));
        }

        [Test]
        public void Ldsflda()
        {
            Assert.AreEqual(10, Redirect.BaseTest.Ldsflda());
            Assert.AreEqual(20, Redirect.BaseTest.Ldsflda());
        }

        [Test]
        public void Initobj()
        {
            Assert.AreEqual(BaseTest.Initobj(42), Redirect.BaseTest.Initobj(42));
        }

        //数学运算测试，checked关键字测试
        [Test]
        public void Arithmetic()
        {
            int a0 = 1, b0 = 2;
            long a1 = 324, b1 = 4314;
            float a2 = 321.41f, b2 = 31254.99f;
            double a3 = 321321.314312f, b3 = 3214321.31255;
            Assert.AreEqual(a0 / b0, Redirect.BaseTest.Div(a0, b0));
            Assert.AreEqual(a1 / b1, Redirect.BaseTest.Div(a1, b1));
            Assert.AreEqual(a2 / b2, Redirect.BaseTest.Div(a2, b2));
            Assert.AreEqual(a3 / b3, Redirect.BaseTest.Div(a3, b3));

            Assert.Throws<OverflowException>(() => Redirect.BaseTest.Mul_Ovf(int.MaxValue, 2));
            Assert.Throws<OverflowException>(() => Redirect.BaseTest.Mul_Ovf_Un(uint.MaxValue, 2));
            Assert.Throws<OverflowException>(() => Redirect.BaseTest.Add_Ovf(int.MaxValue, 1));
            Assert.Throws<OverflowException>(() => Redirect.BaseTest.Add_Ovf_Un(uint.MaxValue, 1));

            Assert.AreEqual(1 / uint.MaxValue, Redirect.BaseTest.Div_Un(1, uint.MaxValue));

            Assert.AreEqual(-a0, Redirect.BaseTest.Neg(a0));
            Assert.AreEqual(-a1, Redirect.BaseTest.Neg(a1));
            Assert.AreEqual(-a2, Redirect.BaseTest.Neg(a2));
            Assert.AreEqual(-a3, Redirect.BaseTest.Neg(a3));
        }

        //Nan运算
        [Test]
        public void NaNFloat()
        {
            for (int i = 0; i < 4; i++)
            {
                Console.WriteLine("nan nan " + i);
                Assert.AreEqual(BaseTest.NaNFloat(i, float.NaN, float.NaN),
                    Redirect.BaseTest.NaNFloat(i, float.NaN, float.NaN));
            }

            for (int i = 0; i < 4; i++)
            {
                Console.WriteLine("1 nan " + i);
                Assert.AreEqual(BaseTest.NaNFloat(i, 1, float.NaN), Redirect.BaseTest.NaNFloat(i, 1, float.NaN));
            }

            for (int i = 0; i < 4; i++)
            {
                Console.WriteLine("nan 1 " + i);
                Assert.AreEqual(BaseTest.NaNFloat(i, float.NaN, 1), Redirect.BaseTest.NaNFloat(i, float.NaN, 1));
            }
        }

        [Test]
        public void Rem()
        {
            Assert.AreEqual(BaseTest.Rem(32, 7), Redirect.BaseTest.Rem(32, 7));
            Assert.AreEqual(BaseTest.Rem(32.1f, 7), Redirect.BaseTest.Rem(32.1f, 7));

            Assert.AreEqual(BaseTest.Rem(uint.MaxValue, 7), Redirect.BaseTest.Rem(uint.MaxValue, 7));
        }

        [Test]
        public void Ldc_R8()
        {
            Assert.AreEqual(BaseTest.Ldc_R8(), Redirect.BaseTest.Ldc_R8());
        }

        [Test]
        public void Ldc_I8()
        {
            Assert.AreEqual(BaseTest.Ldc_I8(), Redirect.BaseTest.Ldc_I8());
        }

        //64位测试
        [Test]
        public void Int64()
        {
            float a = ulong.MaxValue;
            Assert.AreEqual(BaseTest.Conv_I8(a), Redirect.BaseTest.Conv_I8(a));
            Assert.AreEqual(BaseTest.Conv_U8(a), Redirect.BaseTest.Conv_U8(a));
            Assert.Throws<OverflowException>(()=>Redirect.BaseTest.Conv_Ovf_U8(-1));
            Assert.Throws<OverflowException>(() => Redirect.BaseTest.Conv_Ovf_U8(a * 2));
            Assert.Throws<OverflowException>(() => Redirect.BaseTest.Conv_Ovf_I8(ulong.MaxValue));
            Assert.Throws<OverflowException>(() => Redirect.BaseTest.Conv_Ovf_I8(a * 2));
        }

        class AnonymousClass2 : Redirect.AnonymousClass
        {
            public override void FAdd()
            {
                f += 5;
            }
        }

        int sum_of_enumerator(System.Collections.IEnumerator enumerator)
        {
            int sum = 0;
            while (enumerator.MoveNext())
            {
                object c = enumerator.Current;
                if (c is int)
                {
                    sum += (int)c;
                }
            }
            return sum;
        }

        int sum_of_enumerator(IEnumerator<int> enumerator)
        {
            int sum = 0;
            while (enumerator.MoveNext())
            {
                sum += enumerator.Current;
            }
            return sum;
        }

        [Test]
        public void Closure()
        {
            Redirect.AnonymousClass anony = new Redirect.AnonymousClass();
            int local = 0, field = 0, staticField = 0;
            anony.CallRepeat(10, out local, out field, out staticField);
            //Console.WriteLine("local:" + local + ",field:" + field + ",static field:" + staticField);
            Assert.AreEqual(10, local);
            Assert.AreEqual(10, field);
            Assert.AreEqual(10, staticField);
            anony.CallRepeat(6, out local, out field, out staticField);
            Assert.AreEqual(6, local);
            Assert.AreEqual(16, field);
            Assert.AreEqual(16, staticField);

            anony.CallRepeat(2, out field, out staticField);
            Assert.AreEqual(20, field);
            Assert.AreEqual(20, staticField);

            anony.CallRepeat(1, out field);
            Assert.AreEqual(23, field);

            List<int> list = new List<int> { 43, 5, 7, 8, 9, 2, 200 };
            anony.Lessthan(list, 40);
            Assert.AreEqual(5, list.Count);
            anony.Lessthan(list, 5);
            Assert.AreEqual(2, list.Count);
            anony.Lessthan(list, 1);
            Assert.AreEqual(0, list.Count);

            List<int> list2 = new List<int> { 43, 5, 7, 8, 9, 2, 200 };
            anony.LessthanField(list2);
            Assert.AreEqual(5, list2.Count);
            anony.Lessthan5(list2);
            Assert.AreEqual(2, list2.Count);

            AnonymousClass2 anony2 = new AnonymousClass2();
            anony2.CallRepeat(3, out field);
            Assert.AreEqual(15, field);

            Redirect.AnonymousClass a = new Redirect.AnonymousClass();
            AnonymousClass b = new AnonymousClass();
            Assert.AreEqual(sum_of_enumerator(a.Generator()), sum_of_enumerator(b.Generator()));
            for (int i = 0; i < 10; i++)
            {
                Assert.AreEqual(sum_of_enumerator(a.Generator(i)), sum_of_enumerator(b.Generator(i)));
            }

            Assert.AreEqual(sum_of_enumerator(a.GetEnumerable().GetEnumerator()),
                sum_of_enumerator(b.GetEnumerable().GetEnumerator()));
        }

        [Test]
        public static void Conv_R_Un()
        {
            Assert.AreEqual(BaseTest.Conv_R_Un(uint.MaxValue), Redirect.BaseTest.Conv_R_Un(uint.MaxValue));
            Assert.AreEqual(BaseTest.Conv_R_Un(ulong.MaxValue), Redirect.BaseTest.Conv_R_Un(ulong.MaxValue));
        }

        [Test]
        public static void NaNFloatBranch()
        {
            Assert.AreEqual(BaseTest.Blt_Un(float.NaN, float.NaN), Redirect.BaseTest.Blt_Un(float.NaN, float.NaN));
            Assert.AreEqual(BaseTest.Blt_Un(1, float.NaN), Redirect.BaseTest.Blt_Un(1, float.NaN));
            Assert.AreEqual(BaseTest.Blt_Un(float.NaN, 1), Redirect.BaseTest.Blt_Un(float.NaN, 1));
            Assert.AreEqual(BaseTest.Bgt_Un(float.NaN, float.NaN), Redirect.BaseTest.Bgt_Un(float.NaN, float.NaN));
            Assert.AreEqual(BaseTest.Bgt_Un(1, float.NaN), Redirect.BaseTest.Bgt_Un(1, float.NaN));
            Assert.AreEqual(BaseTest.Bgt_Un(float.NaN, 1), Redirect.BaseTest.Bgt_Un(float.NaN, 1));
        }

        //TODO: Conv_U2 Ble_Un Conv_R8 Conv_R4 Bge_Un Conv_I2 Conv_Ovf_I2 Conv_Ovf_I2_Un
        //Conv_U4 Conv_Ovf_U4 Conv_Ovf_U4_Un
        //Conv_I1 Conv_Ovf_I1 Conv_Ovf_I1_Un
    }
}
```

`Source/VSProj/Src/Version.cs`:

```cs
/*
 * Tencent is pleased to support the open source community by making InjectFix available.
 * Copyright (C) 2019 Tencent.  All rights reserved.
 * InjectFix is licensed under the MIT License, except for the third-party components listed in the file 'LICENSE' which may be subject to their corresponding license terms. 
 * This file is subject to the terms and conditions defined in file 'LICENSE', which is part of this source code package.
 */

namespace IFix
{
    public class Version
    {
        public const string FILE_FORMAT = "0.0.6";//文件格式版本号
    }
}
```

`Source/VSProj/build_for_unity.bat`:

```bat
@set UNITY_HOME=D:\Program Files\Unity523f1
if exist "%UNITY_HOME%\Editor\Data\Mono\bin\gmcs" (
    @set GMCS="%UNITY_HOME%\Editor\Data\Mono\bin\gmcs"
) else (
    @set GMCS="%UNITY_HOME%\Editor\Data\MonoBleedingEdge\bin\mcs.bat"
)
@set MONO="%UNITY_HOME%\Editor\Data\MonoBleedingEdge\bin\mono"
@set DLL_OUTPUT=..\UnityProj\Assets\Plugins\IFix.Core.dll
@set TOOL_KIT_PATH=..\UnityProj\IFixToolKit
call %GMCS% ShuffleInstruction.cs -out:.\ShuffleInstruction.exe
%MONO% ShuffleInstruction.exe Src\Core\Instruction.cs Instruction.cs
call %GMCS% -define:UNITY_IPHONE -unsafe -target:library -out:%DLL_OUTPUT% Src\Builder\*.cs Src\Version.cs Instruction.cs ^
Src\Core\AnonymousStorey.cs ^
Src\Core\DataDefine.cs ^
Src\Core\GenericDelegate.cs ^
Src\Core\Il2CppSetOptionAttribute.cs ^
Src\Core\ObjectClone.cs ^
Src\Core\ReflectionMethodInvoker.cs ^
Src\Core\StackOperation.cs ^
Src\Core\SwitchFlags.cs ^
Src\Core\Utils.cs ^
Src\Core\VirtualMachine.cs ^
Src\Core\WrappersManager.cs
md %TOOL_KIT_PATH%
copy /Y ThirdParty\Mono.Cecil* %TOOL_KIT_PATH%
call %GMCS% -define:UNITY_IPHONE -unsafe -reference:ThirdParty\Mono.Cecil.dll,ThirdParty\Mono.Cecil.Mdb.dll,ThirdParty\Mono.Cecil.Pdb.dll -out:%TOOL_KIT_PATH%\IFix.exe -debug Instruction.cs Src\Tools\*.cs Src\Version.cs
pause

```

`Source/VSProj/build_for_unity.py`:

```py
#!/usr/bin/env python3
# -*- coding:utf-8 -*-

import json
import os
import platform
from shutil import copyfile


def parse_global_config():
    with open('config.json', 'r') as f:
        content = f.read()
        global_config = json.loads(content)

        if 'windows' in platform.platform().lower():
            global_config['gmcs'] = os.path.join(
                global_config['UnityHome'], 'Editor/Data/Mono/bin/gmcs')
            global_config['mono'] = os.path.join(
                global_config['UnityHome'], 'Editor/Data/MonoBleedingEdge/bin/mono')
        else:
            global_config['gmcs'] = os.path.join(
                global_config['UnityHome'], 'Contents/Mono/bin/gmcs')
            global_config['mono'] = os.path.join(
                global_config['UnityHome'], 'Contents/MonoBleedingEdge/bin/mono')

        return global_config


def main():
    global_config = parse_global_config()

    # 编译 ShuffleInstruction
    os.system(
        "%s ShuffleInstruction.cs -out:./ShuffleInstruction.exe" % (global_config['gmcs']))

    # 生成混淆后的 Instruction.cs
    os.system(
        "%s ShuffleInstruction.exe Src/Core/Instruction.cs Instruction.cs %s" % (global_config['mono'], global_config['ConfuseKey']))

    # 构建 Dll
    cmd_dll = "%s -define:UNITY_IPHONE -unsafe -target:library -out:%s Src/Builder/*.cs Src/Version.cs Instruction.cs \
    Src/Core/AnonymousStorey.cs \
    Src/Core/DataDefine.cs \
    Src/Core/GenericDelegate.cs \
    Src/Core/Il2CppSetOptionAttribute.cs \
    Src/Core/ObjectClone.cs \
    Src/Core/ReflectionMethodInvoker.cs \
    Src/Core/StackOperation.cs \
    Src/Core/SwitchFlags.cs \
    Src/Core/Utils.cs \
    Src/Core/VirtualMachine.cs \
    Src/Core/WrappersManager.cs" % (global_config['gmcs'], global_config['DllOutput'])
    os.system(cmd_dll)

    # 构建 Toolkit
    if not os.path.exists(global_config['ToolKitOutput']):
        os.mkdir(global_config['ToolKitOutput'])

    cecil_files = os.listdir('ThirdParty')
    for file in cecil_files:
        if 'Mono.Cecil' in file:
            copyfile(os.path.join('ThirdParty', file), os.path.join(
                global_config['ToolKitOutput'], file))

    cmd_tool = "%s -define:UNITY_IPHONE -unsafe -reference:ThirdParty/Mono.Cecil.dll,ThirdParty/Mono.Cecil.Mdb.dll,ThirdParty/Mono.Cecil.Pdb.dll -out:%s/IFix.exe -debug Instruction.cs Src/Tools/*.cs Src/Version.cs" % (global_config['gmcs'], global_config['ToolKitOutput'])

    os.system(cmd_tool)


if __name__ == '__main__':
    main()

```

`Source/VSProj/build_for_unity.sh`:

```sh
#!/usr/bin/env sh
UNITY_HOME="/Applications/Unity2017/Unity.app"
GMCS="$UNITY_HOME/Contents/Mono/bin/gmcs"
if [ ! -d $GMCS ]; then
    GMCS="$UNITY_HOME/Contents/MonoBleedingEdge/bin/mcs"
fi
MONO="$UNITY_HOME/Contents/MonoBleedingEdge/bin/mono"
DLL_OUTPUT="../UnityProj/Assets/Plugins/IFix.Core.dll"
TOOL_KIT_PATH="../UnityProj/IFixToolKit"

$GMCS ShuffleInstruction.cs -out:./ShuffleInstruction.exe
$MONO ShuffleInstruction.exe Src/Core/Instruction.cs Instruction.cs
$GMCS -define:UNITY_IPHONE -unsafe -target:library -out:$DLL_OUTPUT Src/Builder/*.cs Src/Version.cs Instruction.cs \
Src/Core/AnonymousStorey.cs \
Src/Core/DataDefine.cs \
Src/Core/GenericDelegate.cs \
Src/Core/Il2CppSetOptionAttribute.cs \
Src/Core/ObjectClone.cs \
Src/Core/ReflectionMethodInvoker.cs \
Src/Core/StackOperation.cs \
Src/Core/SwitchFlags.cs \
Src/Core/Utils.cs \
Src/Core/VirtualMachine.cs \
Src/Core/WrappersManager.cs

if [ ! -d $TOOL_KIT_PATH ]; then
    mkdir $TOOL_KIT_PATH
fi

cp -f ThirdParty/Mono.Cecil* $TOOL_KIT_PATH
$GMCS -define:UNITY_IPHONE -unsafe -reference:ThirdParty/Mono.Cecil.dll,ThirdParty/Mono.Cecil.Mdb.dll,ThirdParty/Mono.Cecil.Pdb.dll -out:$TOOL_KIT_PATH/IFix.exe -debug Instruction.cs Src/Tools/*.cs Src/Version.cs

```

`Source/VSProj/config.json`:

```json
{
    "UnityHome": "/Applications/Unity2017/Unity.app",
    "DllOutput": "../UnityProj/Assets/Plugins/IFix.Core.dll",
    "ToolKitOutput": "../UnityProj/IFixToolKit",
    "ConfuseKey": ""
}
```

`Source/VSProj/gen_proj.bat`:

```bat
:: Do premake

premake5.exe vs2013

pause


```

`Source/VSProj/premake5.lua`:

```lua

solution "IFix"
    configurations {
        "Debug", "Release"
    }

    location ("./" .. (_ACTION or ""))
    debugdir (".")
    debugargs {  }

    platforms { "Any CPU" }

configuration "Debug"
    symbols "On"
    defines { "_DEBUG", "DEBUG", "TRACE" }
configuration "Release"
    flags { "Optimize" }
configuration "vs*"
    defines { "" }

project "IFix.Core"
language "C#"
kind "SharedLib"
framework "3.5"
targetdir "./Lib"

files
{
    "Src/Core/*.cs",
    "Src/Builder/SimpleVirtualMachineBuilder.cs",
    "Src/Builder/FileVirtualMachineBuilder.cs",
    "Src/Version.cs",
}

defines
{
	"UNITY_IPHONE",
}

links
{
    "System",
    "System.Core",
}

configuration { "Debug*" }
    defines { "DEBUG" }
    symbols "On"
    clr "Unsafe"
 
configuration { "Release*" }
    flags   { "Optimize" }
    clr "Unsafe"
    
project "IFix"
language "C#"
kind "ConsoleApp"
framework "3.5"
targetdir "./Bin"

files
{
    "Src/Core/Instruction.cs",
    "Src/Tools/*.cs",
    "Src/Version.cs",
}

defines
{
	
}

links
{
    "System",
    "System.Core",
    "ThirdParty/Mono.Cecil.dll",
    "ThirdParty/Mono.Cecil.Mdb.dll",
    "ThirdParty/Mono.Cecil.Pdb.dll",
}

configuration { "Debug*" }
    defines { "DEBUG" }
    symbols "On"
    clr "Unsafe"
 
configuration { "Release*" }
    flags   { "Optimize" }
    clr "Unsafe"

project "IFix.TestDLL"
language "C#"
kind "SharedLib"
framework "3.5"
targetdir "./Lib"

files
{
    "Src/TestDLL/BaseTest.cs",
}

defines
{
}

links
{
    "System",
    "System.Core",
    "IFix.Core",
}

project "IFix.TestDLL.Redirect"
language "C#"
kind "SharedLib"
framework "3.5"
targetdir "./Lib"

files
{
    "Src/TestDLL/RedirectBaseTest.cs",
}

defines
{
}

links
{
    "System",
    "System.Core",
    "IFix.Core",
}

project "IFix.UnitTest"
language "C#"
kind "SharedLib"
framework "3.5"
targetdir "./Lib"

dependson { "IFix.Core", "IFix.TestDLL", "IFix.TestDLL.Redirect", "IFix" }

files
{
    "Src/UnitTest/*.cs",
}

defines
{
	
}

links
{
    "System",
    "System.Core",
    "IFix.Core",
    "IFix.TestDLL",
    "Data/IFix.TestDLL.Redirect.dll",
}

configuration { "Debug*" }
    defines { "DEBUG" }
    symbols "On"
    clr "Unsafe"
    prebuildcommands
    { 
        "$(SolutionDir)/inject_redirect_dll",
    }
 
configuration { "Release*" }
    flags   { "Optimize" }
    clr "Unsafe"
    prebuildcommands
    { 
        "$(SolutionDir)/inject_redirect_dll",
    }

project "IFix.PerfTest"
language "C#"
kind "ConsoleApp"
framework "3.5"
targetdir "./Bin"

files
{
    "Src/PerfTest/*.cs",
}

defines
{
	
}

links
{
    "System",
    "System.Core",
    "IFix.Core",
}

configuration { "Debug*" }
    defines { "DEBUG" }
    symbols "On"
    clr "Unsafe"
 
configuration { "Release*" }
    flags   { "Optimize" }
    clr "Unsafe"
```

`Source/VSProj/vs2013/IFix.Core.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="12.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{ECFB8D71-5866-42E8-A1A4-F38D0D4E203D}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>IFix.Core</RootNamespace>
    <AssemblyName>IFix.Core</AssemblyName>
    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>..\Lib\</OutputPath>
    <BaseIntermediateOutputPath>obj\Any CPU\Debug\IFix.Core\</BaseIntermediateOutputPath>
    <IntermediateOutputPath>$(BaseIntermediateOutputPath)</IntermediateOutputPath>
    <DefineConstants>_DEBUG;TRACE;;UNITY_IPHONE;DEBUG</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>..\Lib\</OutputPath>
    <BaseIntermediateOutputPath>obj\Any CPU\Release\IFix.Core\</BaseIntermediateOutputPath>
    <IntermediateOutputPath>$(BaseIntermediateOutputPath)</IntermediateOutputPath>
    <DefineConstants>;UNITY_IPHONE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Core" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="..\Src\Builder\FileVirtualMachineBuilder.cs">
      <Link>Src\Builder\FileVirtualMachineBuilder.cs</Link>
    </Compile>
    <Compile Include="..\Src\Builder\SimpleVirtualMachineBuilder.cs">
      <Link>Src\Builder\SimpleVirtualMachineBuilder.cs</Link>
    </Compile>
    <Compile Include="..\Src\Core\AnonymousStorey.cs">
      <Link>Src\Core\AnonymousStorey.cs</Link>
    </Compile>
    <Compile Include="..\Src\Core\DataDefine.cs">
      <Link>Src\Core\DataDefine.cs</Link>
    </Compile>
    <Compile Include="..\Src\Core\GenericDelegate.cs">
      <Link>Src\Core\GenericDelegate.cs</Link>
    </Compile>
    <Compile Include="..\Src\Core\Il2CppSetOptionAttribute.cs">
      <Link>Src\Core\Il2CppSetOptionAttribute.cs</Link>
    </Compile>
    <Compile Include="..\Src\Core\Instruction.cs">
      <Link>Src\Core\Instruction.cs</Link>
    </Compile>
    <Compile Include="..\Src\Core\ObjectClone.cs">
      <Link>Src\Core\ObjectClone.cs</Link>
    </Compile>
    <Compile Include="..\Src\Core\ReflectionMethodInvoker.cs">
      <Link>Src\Core\ReflectionMethodInvoker.cs</Link>
    </Compile>
    <Compile Include="..\Src\Core\StackOperation.cs">
      <Link>Src\Core\StackOperation.cs</Link>
    </Compile>
    <Compile Include="..\Src\Core\SwitchFlags.cs">
      <Link>Src\Core\SwitchFlags.cs</Link>
    </Compile>
    <Compile Include="..\Src\Core\Utils.cs">
      <Link>Src\Core\Utils.cs</Link>
    </Compile>
    <Compile Include="..\Src\Core\VirtualMachine.cs">
      <Link>Src\Core\VirtualMachine.cs</Link>
    </Compile>
    <Compile Include="..\Src\Core\WrappersManager.cs">
      <Link>Src\Core\WrappersManager.cs</Link>
    </Compile>
    <Compile Include="..\Src\Version.cs">
      <Link>Src\Version.cs</Link>
    </Compile>
  </ItemGroup>
  <ItemGroup>
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>
```

`Source/VSProj/vs2013/IFix.PerfTest.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="12.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{1067953C-7C27-1173-4562-5AF0B1E1554F}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>IFix.PerfTest</RootNamespace>
    <AssemblyName>IFix.PerfTest</AssemblyName>
    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>..\Bin\</OutputPath>
    <BaseIntermediateOutputPath>obj\Any CPU\Debug\IFix.PerfTest\</BaseIntermediateOutputPath>
    <IntermediateOutputPath>$(BaseIntermediateOutputPath)</IntermediateOutputPath>
    <DefineConstants>_DEBUG;TRACE;;DEBUG</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>..\Bin\</OutputPath>
    <BaseIntermediateOutputPath>obj\Any CPU\Release\IFix.PerfTest\</BaseIntermediateOutputPath>
    <IntermediateOutputPath>$(BaseIntermediateOutputPath)</IntermediateOutputPath>
    <DefineConstants></DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Core" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="..\Src\PerfTest\PerfTest.cs">
      <Link>Src\PerfTest\PerfTest.cs</Link>
    </Compile>
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="IFix.Core.csproj">
      <Project>{ECFB8D71-5866-42E8-A1A4-F38D0D4E203D}</Project>
      <Name>IFix.Core</Name>
    </ProjectReference>
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>
```

`Source/VSProj/vs2013/IFix.TestDLL.Redirect.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="12.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{9F93F48D-0B00-B088-D4F3-47E6401FD2F0}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>IFix.TestDLL.Redirect</RootNamespace>
    <AssemblyName>IFix.TestDLL.Redirect</AssemblyName>
    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>..\Lib\</OutputPath>
    <BaseIntermediateOutputPath>obj\Any CPU\Debug\IFix.TestDLL.Redirect\</BaseIntermediateOutputPath>
    <IntermediateOutputPath>$(BaseIntermediateOutputPath)</IntermediateOutputPath>
    <DefineConstants>_DEBUG;DEBUG;TRACE;</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>..\Lib\</OutputPath>
    <BaseIntermediateOutputPath>obj\Any CPU\Release\IFix.TestDLL.Redirect\</BaseIntermediateOutputPath>
    <IntermediateOutputPath>$(BaseIntermediateOutputPath)</IntermediateOutputPath>
    <DefineConstants></DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Core" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="..\Src\TestDLL\RedirectBaseTest.cs">
      <Link>Src\TestDLL\RedirectBaseTest.cs</Link>
    </Compile>
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="IFix.Core.csproj">
      <Project>{ECFB8D71-5866-42E8-A1A4-F38D0D4E203D}</Project>
      <Name>IFix.Core</Name>
    </ProjectReference>
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>
```

`Source/VSProj/vs2013/IFix.TestDLL.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="12.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{7F74F7B1-6BD7-8656-145D-BF0C009F52D9}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>IFix.TestDLL</RootNamespace>
    <AssemblyName>IFix.TestDLL</AssemblyName>
    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>..\Lib\</OutputPath>
    <BaseIntermediateOutputPath>obj\Any CPU\Debug\IFix.TestDLL\</BaseIntermediateOutputPath>
    <IntermediateOutputPath>$(BaseIntermediateOutputPath)</IntermediateOutputPath>
    <DefineConstants>_DEBUG;DEBUG;TRACE;</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>..\Lib\</OutputPath>
    <BaseIntermediateOutputPath>obj\Any CPU\Release\IFix.TestDLL\</BaseIntermediateOutputPath>
    <IntermediateOutputPath>$(BaseIntermediateOutputPath)</IntermediateOutputPath>
    <DefineConstants></DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Core" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="..\Src\TestDLL\BaseTest.cs">
      <Link>Src\TestDLL\BaseTest.cs</Link>
    </Compile>
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="IFix.Core.csproj">
      <Project>{ECFB8D71-5866-42E8-A1A4-F38D0D4E203D}</Project>
      <Name>IFix.Core</Name>
    </ProjectReference>
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>
```

`Source/VSProj/vs2013/IFix.UnitTest.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="12.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="packages\NUnit.3.12.0\build\NUnit.props" Condition="Exists('packages\NUnit.3.12.0\build\NUnit.props')" />
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{A39BA97A-0F5C-25B1-D896-6E2E44166A8D}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>IFix.UnitTest</RootNamespace>
    <AssemblyName>IFix.UnitTest</AssemblyName>
    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <NuGetPackageImportStamp>
    </NuGetPackageImportStamp>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>..\Lib\</OutputPath>
    <BaseIntermediateOutputPath>obj\Any CPU\Debug\IFix.UnitTest\</BaseIntermediateOutputPath>
    <IntermediateOutputPath>$(BaseIntermediateOutputPath)</IntermediateOutputPath>
    <DefineConstants>_DEBUG;TRACE;;DEBUG</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>..\Lib\</OutputPath>
    <BaseIntermediateOutputPath>obj\Any CPU\Release\IFix.UnitTest\</BaseIntermediateOutputPath>
    <IntermediateOutputPath>$(BaseIntermediateOutputPath)</IntermediateOutputPath>
    <DefineConstants>
    </DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="nunit.framework, Version=3.12.0.0, Culture=neutral, PublicKeyToken=2638cd05610744eb, processorArchitecture=MSIL">
      <HintPath>packages\NUnit.3.12.0\lib\net35\nunit.framework.dll</HintPath>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="IFix.TestDLL.Redirect">
      <HintPath>..\Data\IFix.TestDLL.Redirect.dll</HintPath>
    </Reference>
  </ItemGroup>
  <ItemGroup>
    <Compile Include="..\Src\UnitTest\VirtualMachineTest.cs">
      <Link>Src\UnitTest\VirtualMachineTest.cs</Link>
    </Compile>
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="IFix.Core.csproj">
      <Project>{ECFB8D71-5866-42E8-A1A4-F38D0D4E203D}</Project>
      <Name>IFix.Core</Name>
    </ProjectReference>
    <ProjectReference Include="IFix.TestDLL.csproj">
      <Project>{7F74F7B1-6BD7-8656-145D-BF0C009F52D9}</Project>
      <Name>IFix.TestDLL</Name>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup>
    <None Include="packages.config" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
  <PropertyGroup>
    <PreBuildEvent>$(SolutionDir)/inject_redirect_dll</PreBuildEvent>
  </PropertyGroup>
  <Target Name="EnsureNuGetPackageBuildImports" BeforeTargets="PrepareForBuild">
    <PropertyGroup>
      <ErrorText>这台计算机上缺少此项目引用的 NuGet 程序包。使用“NuGet 程序包还原”可下载这些程序包。有关更多信息，请参见 http://go.microsoft.com/fwlink/?LinkID=322105。缺少的文件是 {0}。</ErrorText>
    </PropertyGroup>
    <Error Condition="!Exists('packages\NUnit.3.12.0\build\NUnit.props')" Text="$([System.String]::Format('$(ErrorText)', 'packages\NUnit.3.12.0\build\NUnit.props'))" />
  </Target>
</Project>
```

`Source/VSProj/vs2013/IFix.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="12.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{F54E867C-E185-870D-8A72-6D107688030F}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>IFix</RootNamespace>
    <AssemblyName>IFix</AssemblyName>
    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>..\Bin\</OutputPath>
    <BaseIntermediateOutputPath>obj\Any CPU\Debug\IFix\</BaseIntermediateOutputPath>
    <IntermediateOutputPath>$(BaseIntermediateOutputPath)</IntermediateOutputPath>
    <DefineConstants>_DEBUG;TRACE;;DEBUG</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>..\Bin\</OutputPath>
    <BaseIntermediateOutputPath>obj\Any CPU\Release\IFix\</BaseIntermediateOutputPath>
    <IntermediateOutputPath>$(BaseIntermediateOutputPath)</IntermediateOutputPath>
    <DefineConstants></DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="Mono.Cecil">
      <HintPath>..\ThirdParty\Mono.Cecil.dll</HintPath>
    </Reference>
    <Reference Include="Mono.Cecil.Mdb">
      <HintPath>..\ThirdParty\Mono.Cecil.Mdb.dll</HintPath>
    </Reference>
    <Reference Include="Mono.Cecil.Pdb">
      <HintPath>..\ThirdParty\Mono.Cecil.Pdb.dll</HintPath>
    </Reference>
  </ItemGroup>
  <ItemGroup>
    <Compile Include="..\Src\Core\Instruction.cs">
      <Link>Src\Core\Instruction.cs</Link>
    </Compile>
    <Compile Include="..\Src\Tools\CSFix.cs">
      <Link>Src\Tools\CSFix.cs</Link>
    </Compile>
    <Compile Include="..\Src\Tools\CecilExtensions.cs">
      <Link>Src\Tools\CecilExtensions.cs</Link>
    </Compile>
    <Compile Include="..\Src\Tools\CodeTranslator.cs">
      <Link>Src\Tools\CodeTranslator.cs</Link>
    </Compile>
    <Compile Include="..\Src\Tools\GenerateConfigure.cs">
      <Link>Src\Tools\GenerateConfigure.cs</Link>
    </Compile>
    <Compile Include="..\Src\Version.cs">
      <Link>Src\Version.cs</Link>
    </Compile>
  </ItemGroup>
  <ItemGroup>
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>
```

`Source/VSProj/vs2013/IFix.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 2013
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "IFix.Core", "IFix.Core.csproj", "{ECFB8D71-5866-42E8-A1A4-F38D0D4E203D}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "IFix", "IFix.csproj", "{F54E867C-E185-870D-8A72-6D107688030F}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "IFix.TestDLL", "IFix.TestDLL.csproj", "{7F74F7B1-6BD7-8656-145D-BF0C009F52D9}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "IFix.TestDLL.Redirect", "IFix.TestDLL.Redirect.csproj", "{9F93F48D-0B00-B088-D4F3-47E6401FD2F0}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "IFix.UnitTest", "IFix.UnitTest.csproj", "{A39BA97A-0F5C-25B1-D896-6E2E44166A8D}"
	ProjectSection(ProjectDependencies) = postProject
		{ECFB8D71-5866-42E8-A1A4-F38D0D4E203D} = {ECFB8D71-5866-42E8-A1A4-F38D0D4E203D}
		{7F74F7B1-6BD7-8656-145D-BF0C009F52D9} = {7F74F7B1-6BD7-8656-145D-BF0C009F52D9}
		{9F93F48D-0B00-B088-D4F3-47E6401FD2F0} = {9F93F48D-0B00-B088-D4F3-47E6401FD2F0}
		{F54E867C-E185-870D-8A72-6D107688030F} = {F54E867C-E185-870D-8A72-6D107688030F}
	EndProjectSection
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "IFix.PerfTest", "IFix.PerfTest.csproj", "{1067953C-7C27-1173-4562-5AF0B1E1554F}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{ECFB8D71-5866-42E8-A1A4-F38D0D4E203D}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{ECFB8D71-5866-42E8-A1A4-F38D0D4E203D}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{ECFB8D71-5866-42E8-A1A4-F38D0D4E203D}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{ECFB8D71-5866-42E8-A1A4-F38D0D4E203D}.Release|Any CPU.Build.0 = Release|Any CPU
		{F54E867C-E185-870D-8A72-6D107688030F}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{F54E867C-E185-870D-8A72-6D107688030F}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{F54E867C-E185-870D-8A72-6D107688030F}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{F54E867C-E185-870D-8A72-6D107688030F}.Release|Any CPU.Build.0 = Release|Any CPU
		{7F74F7B1-6BD7-8656-145D-BF0C009F52D9}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{7F74F7B1-6BD7-8656-145D-BF0C009F52D9}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{7F74F7B1-6BD7-8656-145D-BF0C009F52D9}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{7F74F7B1-6BD7-8656-145D-BF0C009F52D9}.Release|Any CPU.Build.0 = Release|Any CPU
		{9F93F48D-0B00-B088-D4F3-47E6401FD2F0}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{9F93F48D-0B00-B088-D4F3-47E6401FD2F0}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{9F93F48D-0B00-B088-D4F3-47E6401FD2F0}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{9F93F48D-0B00-B088-D4F3-47E6401FD2F0}.Release|Any CPU.Build.0 = Release|Any CPU
		{A39BA97A-0F5C-25B1-D896-6E2E44166A8D}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{A39BA97A-0F5C-25B1-D896-6E2E44166A8D}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{A39BA97A-0F5C-25B1-D896-6E2E44166A8D}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{A39BA97A-0F5C-25B1-D896-6E2E44166A8D}.Release|Any CPU.Build.0 = Release|Any CPU
		{1067953C-7C27-1173-4562-5AF0B1E1554F}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{1067953C-7C27-1173-4562-5AF0B1E1554F}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{1067953C-7C27-1173-4562-5AF0B1E1554F}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{1067953C-7C27-1173-4562-5AF0B1E1554F}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`Source/VSProj/vs2013/inject_redirect_dll`:

```
#!/bin/bash
mkdir ../Data
mono ../Bin/IFix.exe -inject ../Lib/IFix.Core.dll ../Lib/IFix.TestDLL.Redirect.dll no_cfg ../Data/IFix.TestDLL.Redirect.dif ../Data/IFix.TestDLL.Redirect.dll

```

`Source/VSProj/vs2013/inject_redirect_dll.bat`:

```bat
mkdir ..\Data
..\Bin\IFix.exe -inject ..\Lib\IFix.Core.dll ..\Lib\IFix.TestDLL.Redirect.dll no_cfg ..\Data\IFix.TestDLL.Redirect.dif ..\Data\IFix.TestDLL.Redirect.dll
```

`Source/VSProj/vs2013/packages.config`:

```config
<?xml version="1.0" encoding="utf-8"?>
<packages>
  <package id="NUnit" version="3.12.0" targetFramework="net35" />
</packages>
```