Project Path: arc_donaldwuid_unreal_source_explained_838wdwtj

Source Tree:

```txt
arc_donaldwuid_unreal_source_explained_838wdwtj
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ assets
‚îÇ   ‚îú‚îÄ‚îÄ actionrpg_dsym.png
‚îÇ   ‚îú‚îÄ‚îÄ apple_id.png
‚îÇ   ‚îú‚îÄ‚îÄ provision_profile.png
‚îÇ   ‚îú‚îÄ‚îÄ xcode_scheme.png
‚îÇ   ‚îî‚îÄ‚îÄ xcode_settings.png
‚îú‚îÄ‚îÄ draft
‚îÇ   ‚îî‚îÄ‚îÄ search_keywords
‚îú‚îÄ‚îÄ main
‚îÇ   ‚îú‚îÄ‚îÄ assets
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Class_reflection_data_allocation.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ EnqueueUniqueRenderCommand.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ FDynamicRHI.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ FEngineLoop_Tick_Overview.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ FMallocBinned_lock.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ FRHICommandList_Commands.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ FTaskGraphImplementation_ctor.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Heap_allocation.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ IRHICommandContext.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ LightmapResourceClusterBuffer.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ LightmapResourceClusterInMetal.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PLATFORM_RHITHREAD_DEFAULT_BYPASS.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PThreadRunnableThread_SetThreadPriority.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ SetThreadPriority.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TEnqueueUniqueRenderCommandType_DoTask.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ anythread_1_queue.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ asynctask_start.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ blueprints_callstack.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ blueprints_demo.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cdo_archetype.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ engine_init.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ fqueuedthread_creation.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ game_task_graph.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ game_thread_process_until_idle.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ general_game_loop.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ general_thread_pool.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mdp_AddMeshBatch_BuildMeshDrawCommands.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mdp_GetDynamicMeshElements.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mdp_GetShaderBindings.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mdp_TMobileBasePassXSPolicyParamType.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mdp_cache_code_paths.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mdp_drawstaticelements.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mesh_drawing_pipeline_journey.jpg
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mmap_alloc.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ namethread_2_queues.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ process_memory_layout.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ render_texture_allocation.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ render_thread_creation.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ rendering_commit_resource_table.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ rendering_filluniformbuffer.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ rendering_inherit_both_from_dynamicrhi_rhicommandcontext.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ rendering_material_editor.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ rendering_material_instance.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ rendering_metal_allocation.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ rendering_mtlpp_allocate_memory.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ rendering_set_resources_from_table.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ rendering_set_texture_from_resource_table.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ rendering_uniformbuffer_allocation.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ rendering_uniformbuffer_created3d11.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ renderthread_2_queues.png
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ threads_overview.jpg
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ unreal_rendering_modules.png
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ unreal_task_graph.png
‚îÇ   ‚îú‚îÄ‚îÄ drawing
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cdo_archetype.gv
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ game_task_graph.gv
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ rendering_modules.gv
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ unreal_rendering_flow.gv
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ unreal_rendering_flow.svg
‚îÇ   ‚îú‚îÄ‚îÄ gameplay.md
‚îÇ   ‚îú‚îÄ‚îÄ initialization.md
‚îÇ   ‚îú‚îÄ‚îÄ loop.md
‚îÇ   ‚îú‚îÄ‚îÄ main.md
‚îÇ   ‚îú‚îÄ‚îÄ memory.md
‚îÇ   ‚îú‚îÄ‚îÄ rendering.md
‚îÇ   ‚îú‚îÄ‚îÄ rendering_parallel.md
‚îÇ   ‚îú‚îÄ‚îÄ rendering_resource.md
‚îÇ   ‚îú‚îÄ‚îÄ scripting.md
‚îÇ   ‚îî‚îÄ‚îÄ thread.md
‚îî‚îÄ‚îÄ profile
    ‚îú‚îÄ‚îÄ iPadPro10_5_ActionRPG_TimeAllocation_Deferred_GPUScene_VeryShort.trace.zip
    ‚îú‚îÄ‚îÄ iPadPro10_5_ActionRPG_TimeAllocation_Deferred_GPUScene_Wait_VeryShort.trace.zip
    ‚îú‚îÄ‚îÄ iPadPro10_5_ActionRPG_TimeAllocation_Deferred_VeryShort.trace.zip
    ‚îî‚îÄ‚îÄ iPadPro10_5_ActionRPG_TimeAllocation_Deferred_Wait_VeryShort.trace.zip

```

`README.md`:

```md
# [WIP] Unreal Source Explained

Unreal Source Explained (USE) is an Unreal source code analysis, **based on profilers**.

## TOC

USE is just several markdown files, see the following Table of Contents,

1. [Overview](main/main.md)
1. [Initialization](main/initialization.md)
1. [Loop](main/loop.md)
1. [Memory Management](main/memory.md)
1. [Thread Management](main/thread.md)
1. [Blueprint Visual Scripting](main/scripting.md)
1. [Rendering](main/rendering.md)
    - [Rendering Resources](main/rendering_resource.md)
    - [Parallel Rendering](main/rendering_parallel.md)
1. [Gameplay](main/gameplay.md)



## About

USE's goals are:
- look inside the Unreal engine source;
- insight convering all submodules (loop, memory, render, animation, physics, ...)
- overview then detailed;
- quantitative analysis;
- accurate explanation;
- for now, focus on Unreal running on mobile devices (iOS, Android);
- in English;

USE is based on:
- Unreal 4.23~4.27 source code;
- XCode 11 and its Instrument, in order to capture more details, such as graphic memory allocations;
- the [*ActionRPG*](https://www.unrealengine.com/marketplace/en-US/slug/action-rpg) demo, this is a mobile demo that can run on mobile devices, it's public that everyone can access, and it's not-too-simple with enough engine feature applied, such as blueprints, game ability system, etc.;
- running on iOS devices with:
    - CPU cores >= 3 to observe Unreal's multi-thread characteristic,
    - Metal Graphic API enabled

USE is working in progress, I will add contents persitently, usually when 
- I'm curious about some pieces of code,
- or my work demands it.

Therefore, in order to get more code explained, or to improve the explaination quality, **you are always welcomed to fork, add content and make pull-request!**

## Why Profilers?

Why analyze source code by profilers? Why not use debuggers or just read plain source codes by IDEs' source context-aware tool? In fact, I do. I use various tools to help me to read and understand Unreal codes. But they all have different pros and cons:

||Profiler<br>(running game in device with XCode Instruments)| Debugger<br>(running Unreal Editor with Visual Studio) | Source Context-aware Searching |
|--|--|--|--|
| Call stack | üëçüëçüëç | üëçüëçüëç | ‚ùå
| Big Data<br>(analyize by data mining) | üëçüëçüëç | ‚ùå | ‚ùå
| Variable value | ‚ùå | üëçüëçüëç | ‚ùå
| Branching | ‚ùå | üëçüëçüëç | ‚ùå
| Run on actual device | üëçüëçüëç |  ‚ùå | ‚ùå
| More accurate<br>(Less guess) | üëçüëçüëç | üëçüëç|‚ùå
| Cover all cases | üëç | ‚ùå | üëçüëçüëç
| Cover all threads | üëçüëçüëç | üëç | ‚ùå
| Easy to setup | ‚ùå | üëç | üëçüëçüëç
| Easy to analyze after setup | üëçüëçüëç | üëç | ‚ùå
| Overall | üëç√ó19, ‚ùå√ó3 | üëç√ó14, ‚ùå√ó3 | üëç√ó6, ‚ùå√ó8

We can see profiler has more thumbs up than the other two in terms of code analysis, hence USE is a profiler-first source analysis. However, remember to use them all and use them wisely.

## Profiling Guide

I've upload some instrument files in the *profile* folder, you can use it as a quick overview. **XCode 11** is required to open these files.   
There are two files in it, both of them are captured in iPadPro 10.5(2017), and contain the Time Profiler and the Allocation.   
The file with "Wait" in the filename is captured with Time Profiler's *Record Waiting Thread* option turned on, this is useful to observe the thread off-cpu waiting time.  
The file with "GPUScene" in the filename is captured with UE 4.23's new mobile feature *mesh drawing pipeline* enabled.    
To reduce the file size, this profile files only capture a very short amount of time, therefore, for a longer and better profile file, you are suggested to build and profile the ActionRPG game on your own.


## Build Guide

Install Unreal Editor in your mac, either install it in Epic Game Launcher, or build it from source.


In order to debug your shaders in the GPU debuggers, you should modify these in **YourEngine/Config/ConsoleVariables.ini**, or add them in **YourGameProj/Config/DefaultEngine.ini**.


```ini
; Uncomment to get detailed logs on shader compiles and the opportunity to retry on errors
;r.ShaderDevelopmentMode=1

; Uncomment when running with a graphical debugger (but not when profiling)
;r.Shaders.Optimize=0
; This one enables shader code symbols
r.Shaders.KeepDebugInfo=1
```


For GPU Scene, it's disabled by default in mobile, you can enable it by setting `r.Mobile.SupportGPUScene=1` in your project's DefaultEngine.ini.

You should have valid [apple developer account](https://developer.apple.com), then create a iOS Development **Provision Profile**, which records these 3 important things: 

- **App ID** pattern, (can have wild card, e.g., com.ios.*), 
- **Certificates**, which is **Development Certification** in this case,
- **Devices** which includs your mac.

![](assets/apple_id.png)

From your apple developer account website, please download and import your Development Certification and Provision Profile into your mac. You can manage certifications in **Keychain Access** app, and manage provisions profile in **/Users/{whoami}/Library/MobileDevice/Provisioning Profiles**.

Then in Unreal, choose them in project settings iOS panel (**Edit > Project Settings > Platforms > iOS**), shown in the image below. Make sure provision profile and certification match.

![](assets/provision_profile.png)


In order to show debug symbols in instruments, you need to enable **Build > Generate dSYM file** in iOS project panel.


Package your game by **File > Package Project**, this may take a long time. Unreal will use XCode to build the game into **YourGameProj/Binaries/IOS/**. Note the dSYM file is also generated.

![](assets/actionrpg_dsym.png)

We still need XCode to sign and deploy the game into the device. Use **File > Refresh XCode Project** to generate XCode project file. Open it in XCode. You should change the **Run** and **Profile** Scheme to **Development**, so XCode will load the debug symbol.
![](assets/xcode_scheme.png)



Make sure the generated XCode project also records correct Provision Profiles.

![](assets/xcode_settings.png)


That's it! You can run the game or profiling it!

```

`draft/search_keywords`:

```
## Render

addmeshbatch
meshbatch::f
getdynamicmeshelementS
drawstaticelements
drawmesh
getshaderbindings
getelementshaderbindings
singleshaderbindings::
shader::setparameter
getdynamicmeshelement
setdrawlistcontext
fshaderresource::serialize
addtexture
lightmap
getlightmap
metaluniformbuffer
metaluniformbuffer::updateiab
FMaterial
referencedtexture
precomputedlightvolume
FillUniformBuffer
beginrenderingviewfamily
FMaterialRenderProxy::EvaluateUniformExpressions
createuniform
schedulerender
addreflectioncapture

evaluateuniformexpression
commitresourcetable
computerelevance

mtlpp::Device::NewTexture
mtlpp::Device::NewBuffer
mtlpp::CommandBuffer::RenderCommandEncoder
mtlpp::Device::NewRenderPipelineState
mtlpp::BlitCommandEncoder::Copy
FMetalViewport::GetDrawable(EMetalViewportAccessFlag)
CreateIndexBuffer

SetShaderTexture
SetShaderBuffer
FMetalStateCache::CommitRenderResources

getsingleshaderbindings

dispatchpasssetup
```

`main/drawing/cdo_archetype.gv`:

```gv
digraph {
    rankdir="DT";

    {
        {
            rank = same; 
            cdo[label=<ClassDefault Object<BR/>
        <FONT SIZE="10"><B>"CDO"</B></FONT>>, shape=box, group=g1]; 
            ao[label="Archetype Object", shape=box, group=g1];
            obj[label="Object instance", shape=box]; 
        }
        {
            rank = same;
            uasset[label="uasset file", shape=box3d, group=g2];
            "constructor code"[shape=signature, group=g2]
            superCDO[label="SuperClass CDO", shape=box, group=g2]
        }
        {
            rankdir = "LR";
            template[label="Template object", shape=box, group=g3]
            inFlag[label="InFlags", group=g3]
        }
        newObject[label=<new object <BR/>
        <FONT POINT-SIZE="10">can also be an <B>Archetype object</B> or a <B>CDO</B></FONT>>, shape=box]
    }
    {
        uasset->ao [label="deserialize"]
        uasset->cdo [style=dashed label="deserialize\n(if any)"]
        "constructor code"->cdo [label="initialize"]
        superCDO->cdo[label="copy properties to\n(if any)", style=dashed]
        obj->template
        cdo->template
        ao->template
        
        template->newObject [label="copy properties to"]
        inFlag->newObject [label="set flags to"]
    }
}



```

`main/drawing/game_task_graph.gv`:

```gv
digraph {
    rankdir="LR";

    FrameStart, Update, Skinning, UIRebuild, Sound, Render, FrameEnd
    {
        FrameStart -> Update
        Update -> Skinning
        Update -> UIRebuild
        Update -> Sound

        Skinning -> Render
        UIRebuild -> Render

        Sound -> FrameEnd
        Render -> FrameEnd
    }
}
```

`main/drawing/rendering_modules.gv`:

```gv
digraph {
    rankdir="BT"
    RenderCore[shape=box3d];
    Engine[shape=box3d];
    Renderer[shape=box3d];
    {
        Renderer -> RenderCore
        Renderer -> Engine
        Engine -> RenderCore
    }
}
```

`main/drawing/unreal_rendering_flow.gv`:

```gv
digraph {

    labelloc="t";
    fontsize  = 60 // Make title stand out by giving a large font size
    label="Unreal Rendering Flow";

    rankdir="TD";

    
    subgraph cluster_01 { 
        label = "Legend";
        fontsize  = 30

        subgraph cluster_01 {
            label="threads";

            Game_Thread[label="Game Thread", shape=box, style="filled"]
            Render_thread[label="Render thread", shape=box, style="filled", color=lightblue]
            Task_thread[label="Task thread", shape=box, style="filled", color=orange]
            {
                rank = same;
                edge[style=invis];
                Game_Thread -> Render_thread -> Task_thread
                rankdir = LR;
            }
        }

        subgraph cluster_02 {
            label="importance"

            important[label=<Important functions<br/>filled box>, shape=box, style="filled"]
            trivial[label=<Trivial functions<br/>outlined box>, shape=box]
            {
                rank = same;
                edge[style=invis];
                important -> trivial
                rankdir = LR;
            }
        }


        subgraph cluster_03 {
            label="invoke"
            empty1[label="", shape=box]
            empty2[label="", shape=box]
            empty1 -> empty2[label="direct call"]

            empty5[label="", shape=box]
            empty6[label="", shape=box, color=lightblue]
            empty5 -> empty6[label="indirect call" style=dashed]
            
            empty3[label="", shape=box]
            empty4[label="", shape=box, color=lightblue]
            empty3 -> empty4[label=<dispatch into other thread> color="black:invis:black" penwidth=1]
            {
                rank = same;
                edge[style=invis];
                empty1 -> empty5 -> empty3
                rankdir = LR;
            }
        }
        


        {
            edge[style=invis];
            node[style=invis]
            
            row1 -> row2 -> row3;
            row1 -> important;
            row2 -> Game_Thread
            row3 -> empty1
        }

    }

    FEngineLoop_Tick[label="FEngineLoop::Tick()", shape=box, style="filled"]

    UWorld_Tick[label="UWorld::Tick()", shape=box]

    UGameEngine_Tick[label="UGameEngine::Tick()", shape=box, style="filled"]
    UGameEngine_RedrawViewports[label="UGameEngine::RedrawViewports()", shape=box, style="filled"]

    FSlateApplication_Tick[label="FSlateApplication::Tick()", shape=box, style="filled"]
    FSlateRHIRenderer_DrawWindows[label="FSlateRHIRenderer::DrawWindows()", shape=box, style="filled"]

    FSlateRHIRenderer_DrawWindow_RenderThread[label="FSlateRHIRenderer::DrawWindow_RenderThread()", shape=box, style="filled", color="lightblue"]

    FRHICommandList_EndDrawingViewport[label="FRHICommandList::EndDrawingViewport()", shape=box, style="filled", color="lightblue"]

    FMetalViewport_Present[label="FMetalViewport::Present()", shape=box, style="filled", color="lightblue"]

    FViewport_Draw[label="FViewport::Draw()", shape=box, style="filled"]
    FSceneViewport_EnqueueBeginRenderFrame[label="FSceneViewport::EnqueueBeginRenderFrame()", shape=box]
    UGameViewportClient_Draw[label="UGameViewportClient::Draw()", shape=box, style="filled"]
    FSceneViewport_EnqueueEndRenderFrame[label="FSceneViewport::EnqueueEndRenderFrame()", shape=box]

    UWorld_UpdateLevelStreaming[label="UWorld::UpdateLevelStreaming()", shape=box]
    FRendererModule_BeginRenderingViewFamily[label="FRendererModule::BeginRenderingViewFamily()", shape=box, style="filled"]
    ABaseHud_PostRender[label="ABaseHud::PostRender()", shape=box]

    UWorld_SendAllEndOfFrameUpdates[label=<UWorld::SendAllEndOfFrameUpdates<br/><font POINT-SIZE="9">guarantee all render proxies are up to date before kicking off this frame</font>>, shape=box]
    FSceneRenderer_CreateSceneRenderer[label=<FSceneRenderer::CreateSceneRenderer()<br/><font POINT-SIZE="11">which creates FMobileSceneRenderer of this frame</font>>, shape=box, style="filled"]
    EnequeueRenderCommand_DrawScene[label=<EnequeueUniqueRenderCommand_DrawScene()>, shape=box, style="filled"]
    DeleteSceneRenderer[label=<FSceneRenderer::DelayWaitForTasks...DeleteSceneRenderer<br/><font POINT-SIZE="11">which deletes mobile scene render of this frame</font>>, shape=box]

    FMobileSceneRenderer_Render[label=<<font POINT-SIZE="11">RenderViewFamily_RenderThread()<br/></font>FMobileSceneRenderer::Render()<br/><b><font color="red">for all views, render all the mobile techniques</font></b>>, shape=box, style="filled" color=lightblue]

    FScene_UpdateAllPrimitiveSceneInfos[label=<FScene::UpdateAllPrimitiveSceneInfos<br/><font POINT-SIZE="11">For each STATIC primitive, cache its Draw Commands</font>>, shape=box, style="filled" color=lightblue]

    FMobileSceneRenderer_InitViews[label=<FMobileSceneRenderer::InitViews()<br/><font POINT-SIZE="11">For each view<br/>find visible primitives<br/>build DYNAMIC draw commands</font>>, shape=box, style="filled" color=lightblue]


    
    FSceneRenderer_ComputeViewVisibility[label=<FSceneRenderer::ComputeViewVisibility()>, shape=box, style="filled" color=lightblue]

    FSceneRenderer_SetupMeshPass[label=<FSceneRenderer::SetupMeshPass()>, shape=box, style="filled" color=lightblue]


    FMobileSceneRenderer_SetupMobileBasePassAfterShadowInit[label=<FMobileSceneRenderer::SetupMobileBasePassAfterShadowInit()>, shape=box, style="filled" color=lightblue]

    FMeshDrawCommandPassSetupTask_AnyThreadTask_OtherPass[label=<FMeshDrawCommandPassSetupTask::AnyThreadTask()<br/>for PassType=CSMShadowDepth, TranslucencyStandard, TranslucencyAll, ...<br/><b><font color="red">generate dynamic commands, sort-and-merge FULL draw commands</font></b>>, shape=box, style="filled" color=orange]

    FMeshDrawCommandPassSetupTask_AnyThreadTask_BasePass[label=<FMeshDrawCommandPassSetupTask::AnyThreadTask()<br/>for PassType=BasePass<br/><b><font color="red">generate dynamic commands, sort-and-merge FULL draw commands</font></b>>, shape=box, style="filled" color=orange]

    FSceneRenderer_RenderShadowDepthMaps[label=<RenderShadowDepthMaps()>, shape=box, style="filled", color=lightblue fontsize=9]
    
    FMobileSceneRenderer_RenderPrePass[label=<RenderPrePass()>, shape=box, color=lightblue fontsize=9]

    FMobileSceneRenderer_RenderAmbientOcclusion[label=<RenderAmbientOcclusion()>, shape=box, color=lightblue fontsize=9]

    FMobileSceneRenderer_RenderForward[label=<FMobileSceneRenderer::RenderForward()>, shape=box, style="filled" color=lightblue]

    FPostProcessing_ProcessES2[label=<FPostProcessing::ProcessES2()<br/><font POINT-SIZE="11">for each view</font>>, shape=box, color=lightblue fontsize=9]

    FMobileSceneRenderer_RenderMobileBasePass[label=<FMobileSceneRenderer::RenderMobileBasePass()>, shape=box, style="filled" color=lightblue]

    FMobileSceneRenderer_RenderTranslucency[label=<FMobileSceneRenderer::RenderTranslucency()>, shape=box, color=lightblue]


    FPrimitiveSceneInfo_AddToScene[label=<FPrimitiveSceneInfo::AddToScene()<br/><font POINT-SIZE="11">AddStaticMeshes(), CacheMeshDrawCommands()</font>>, shape=box, style="filled" color=lightblue]

    FParallelMeshDrawCommandPass_DispatchPassSetup_BasePass[label=<FParallelMeshDrawCommandPass::DispatchPassSetup()>, shape=box, style="filled" color=lightblue]
    FParallelMeshDrawCommandPass_DispatchPassSetup_OtherPass[label=<FParallelMeshDrawCommandPass::DispatchPassSetup()>, shape=box, style="filled" color=lightblue]
    FParallelMeshDrawCommandPass_DispatchDraw[label=<FParallelMeshDrawCommandPass::DispatchDraw()> shape=box, style="filled" color=lightblue]
    FParallelMeshDrawCommandPass_DispatchDraw_RenderThread_WillTaskThread[label=<FParallelMeshDrawCommandPass::DispatchDraw()> shape=box, style="filled" color=lightblue]
    SubmitMeshDrawCommandsRange_RenderThread[label=<SubmitMeshDrawCommandsRange<br/><b><font color="red">submits a SUBSET of previously sorted-and-merged FULL mesh draw commands</font></b>>, shape=box, style="filled" color=lightblue]
    SubmitMeshDrawCommandsRange_TaskThread[label=<SubmitMeshDrawCommandsRange<br/><b><font color="red">submits a SUBSET of previously sorted-and-merged FULL mesh draw commands</font></b>>, shape=box, style="filled" color=orange]

    FDrawVisibleMeshCommandsAnyThreadTask[label=<FDrawVisibleMeshCommandsAnyThreadTask::DoTask()>, shape=box, style="filled" color=orange]


    FMobileBasePassMeshProcessor_AddMeshBatch[label=<FMobileBasePassMeshProcessor::AddMeshBatch()>, shape=box, style="filled" color=lightblue]
    FMobileBasePassMeshProcessor_Process[label=<FMobileBasePassMeshProcessor::Process()>, shape=box, style="filled" color=lightblue]
    FMeshPassProcessor_BuildMeshDrawCommands[label=<FMeshPassProcessor::BuildMeshDrawCommands()>, shape=box, style="filled" color=lightblue]
    FMeshMaterialShader_GetElementShaderBindings[label=<FMeshMaterialShader::GetElementShaderBindings()>, shape=box, color=lightblue]
    FMeshDrawCommand_SetShaders[label=<FMeshDrawCommand::SetShaders()>, shape=box, color=lightblue]

    FMobileBasePassMeshProcessor_AddMeshBatch_TaskThread[label=<FMobileBasePassMeshProcessor::AddMeshBatch()>, shape=box, style="filled" color=orange]
    FMobileBasePassMeshProcessor_Process_TaskThread[label=<FMobileBasePassMeshProcessor::Process()>, shape=box, style="filled" color=orange]
    FMeshPassProcessor_BuildMeshDrawCommands_TaskThread[label=<FMeshPassProcessor::BuildMeshDrawCommands()>, shape=box, style="filled" color=orange]
    FMeshMaterialShader_GetElementShaderBindings_TaskThread[label=<FMeshMaterialShader::GetElementShaderBindings()>, shape=box, color=orange]
    FMeshDrawCommand_SetShaders_TaskThread[label=<FMeshDrawCommand::SetShaders()>, shape=box, color=orange]


    FMeshDrawCommand_SubmitDraw_RenderThread[label=<FMeshDrawCommand::SubmitDraw()>, shape=box, color=lightblue, style="filled"]
    FMeshDrawCommand_SubmitDraw_TaskThread[label=<FMeshDrawCommand::SubmitDraw()>, shape=box, color=orange, style="filled"]
    FMeshDrawCommand_SubmitDraw_TaskThread_Subsequent[label=<FMeshDrawCommand::SubmitDraw()<br/>subsequent calls>, shape=box, color=orange, style="invis"]

    FRHICommandList_SetGraphicsPipelineState[label=<FRHICommandList::SetGraphicsPipelineState()>, shape=box, color=lightblue]
    FRHICommandList_SetStreamSource[label=<FRHICommandList::SetStreamSource()>, shape=box, color=lightblue]
    FRHICommandList_DrawIndexedPrimitive[label=<FRHICommandList::DrawIndexedPrimitive()>, shape=box, color=lightblue]


    FMetalStateCache_CommitResourceTable[label=<FMetalStateCache::CommitResourceTable()>, shape=box, color=lightblue]

    FMetalCommandEncoder_SetShaderBuffer[label=<FMetalCommandEncoder::SetShaderBuffer()>, shape=box, color=lightblue]
    FMetalCommandEncoder_SetShaderTexture[label=<FMetalCommandEncoder::SetShaderTexture()>, shape=box, color=lightblue]




    {
        FEngineLoop_Tick -> UGameEngine_Tick
        FEngineLoop_Tick -> FSlateApplication_Tick
        FSlateApplication_Tick -> FSlateRHIRenderer_DrawWindows[style=dashed]
        FSlateRHIRenderer_DrawWindows -> FSlateRHIRenderer_DrawWindow_RenderThread[label="Game thread dispatches to Render thread" color="black:invis:black" penwidth=1]
        FSlateRHIRenderer_DrawWindow_RenderThread -> FRHICommandList_EndDrawingViewport
        FRHICommandList_EndDrawingViewport -> FMetalViewport_Present

        UGameEngine_Tick -> UWorld_Tick
        UGameEngine_Tick -> UGameEngine_RedrawViewports
        {
            rank = same;
            // Here you enforce the desired order with "invisible" edges and arrowheads
            edge[style=invis];
            UWorld_Tick -> UGameEngine_RedrawViewports
            rankdir = LR;
        }

        UGameEngine_RedrawViewports -> FViewport_Draw

        FViewport_Draw -> FSceneViewport_EnqueueBeginRenderFrame
        FViewport_Draw -> UGameViewportClient_Draw
        FViewport_Draw -> FSceneViewport_EnqueueEndRenderFrame
        {
            rank = same;
            // Here you enforce the desired order with "invisible" edges and arrowheads
            edge[style=invis];
            FSceneViewport_EnqueueBeginRenderFrame -> UGameViewportClient_Draw -> FSceneViewport_EnqueueEndRenderFrame
            rankdir = LR;
        }

        UGameViewportClient_Draw -> UWorld_UpdateLevelStreaming
        UGameViewportClient_Draw -> FRendererModule_BeginRenderingViewFamily
        UGameViewportClient_Draw -> ABaseHud_PostRender
        {
            rank = same;
            // Here you enforce the desired order with "invisible" edges and arrowheads
            edge[style=invis];
            UWorld_UpdateLevelStreaming -> FRendererModule_BeginRenderingViewFamily -> ABaseHud_PostRender
        }

        FRendererModule_BeginRenderingViewFamily -> FSceneRenderer_CreateSceneRenderer
        FRendererModule_BeginRenderingViewFamily -> UWorld_SendAllEndOfFrameUpdates
        FRendererModule_BeginRenderingViewFamily -> EnequeueRenderCommand_DrawScene
        FRendererModule_BeginRenderingViewFamily -> DeleteSceneRenderer
        {
            rank = same;
            // Here you enforce the desired order with "invisible" edges and arrowheads
            edge[style=invis];
            FSceneRenderer_CreateSceneRenderer -> UWorld_SendAllEndOfFrameUpdates -> EnequeueRenderCommand_DrawScene -> DeleteSceneRenderer
            rankdir = LR;
        }

        EnequeueRenderCommand_DrawScene -> FMobileSceneRenderer_Render [label="Game thread dispatches to Render thread" color="black:invis:black" penwidth=1]

        EnequeueRenderCommand_DrawScene -> FSlateRHIRenderer_DrawWindow_RenderThread[style=invis]

        FMobileSceneRenderer_Render -> FScene_UpdateAllPrimitiveSceneInfos
        FMobileSceneRenderer_Render -> FMobileSceneRenderer_InitViews
        FMobileSceneRenderer_Render -> FSceneRenderer_RenderShadowDepthMaps
        FMobileSceneRenderer_Render -> FMobileSceneRenderer_RenderPrePass
        FMobileSceneRenderer_Render -> FMobileSceneRenderer_RenderAmbientOcclusion
        FMobileSceneRenderer_Render -> FMobileSceneRenderer_RenderForward
        FMobileSceneRenderer_Render -> FPostProcessing_ProcessES2
        {
            rank = same;
            // Here you enforce the desired order with "invisible" edges and arrowheads
            edge[style=invis];
            FScene_UpdateAllPrimitiveSceneInfos -> FMobileSceneRenderer_InitViews -> FSceneRenderer_RenderShadowDepthMaps -> FMobileSceneRenderer_RenderPrePass -> FMobileSceneRenderer_RenderAmbientOcclusion -> FMobileSceneRenderer_RenderForward -> FPostProcessing_ProcessES2
            rankdir = LR;
        }

        FScene_UpdateAllPrimitiveSceneInfos -> FPrimitiveSceneInfo_AddToScene

        FPrimitiveSceneInfo_AddToScene -> FMobileBasePassMeshProcessor_AddMeshBatch

        FMobileBasePassMeshProcessor_AddMeshBatch -> FMobileBasePassMeshProcessor_Process -> FMeshPassProcessor_BuildMeshDrawCommands

        FMeshPassProcessor_BuildMeshDrawCommands -> FMeshMaterialShader_GetElementShaderBindings
        FMeshPassProcessor_BuildMeshDrawCommands -> FMeshDrawCommand_SetShaders
        {
            rank = same;
            // Here you enforce the desired order with "invisible" edges and arrowheads
            edge[style=invis];
            FMeshMaterialShader_GetElementShaderBindings -> FMeshDrawCommand_SetShaders
            rankdir = LR;
        }

        FMobileSceneRenderer_InitViews -> FSceneRenderer_ComputeViewVisibility
        FMobileSceneRenderer_InitViews -> FMobileSceneRenderer_SetupMobileBasePassAfterShadowInit
        {
            rank = same;
            // Here you enforce the desired order with "invisible" edges and arrowheads
            edge[style=invis];
            FSceneRenderer_ComputeViewVisibility -> FMobileSceneRenderer_SetupMobileBasePassAfterShadowInit
            rankdir = LR;
        }

        FSceneRenderer_ComputeViewVisibility -> FSceneRenderer_SetupMeshPass [label=<For each view>]
        FSceneRenderer_SetupMeshPass -> FParallelMeshDrawCommandPass_DispatchPassSetup_OtherPass
        FParallelMeshDrawCommandPass_DispatchPassSetup_OtherPass -> FMeshDrawCommandPassSetupTask_AnyThreadTask_OtherPass [label=<For each render pass, except base pass,<br/>Render thread dispatches to Task thread> color="black:invis:black:invis:black:invis:black" penwidth=1]
        FMobileSceneRenderer_SetupMobileBasePassAfterShadowInit -> FParallelMeshDrawCommandPass_DispatchPassSetup_BasePass [label=<For each view>]
        FParallelMeshDrawCommandPass_DispatchPassSetup_BasePass -> FMeshDrawCommandPassSetupTask_AnyThreadTask_BasePass [label=<For base pass<br/>Render thread dispatches to Task thread> color="black:invis:black" penwidth=1]
        {
            rank = same;
            // Here you enforce the desired order with "invisible" edges and arrowheads
            edge[style=invis];
            FMeshDrawCommandPassSetupTask_AnyThreadTask_OtherPass -> FMeshDrawCommandPassSetupTask_AnyThreadTask_BasePass
            rankdir = LR;
        }


        FMeshDrawCommandPassSetupTask_AnyThreadTask_BasePass -> FMobileBasePassMeshProcessor_AddMeshBatch_TaskThread
        FMeshDrawCommandPassSetupTask_AnyThreadTask_OtherPass -> FMobileBasePassMeshProcessor_AddMeshBatch_TaskThread

        FMobileBasePassMeshProcessor_AddMeshBatch_TaskThread -> FMobileBasePassMeshProcessor_Process_TaskThread -> FMeshPassProcessor_BuildMeshDrawCommands_TaskThread

        FMeshPassProcessor_BuildMeshDrawCommands_TaskThread -> FMeshMaterialShader_GetElementShaderBindings_TaskThread
        FMeshPassProcessor_BuildMeshDrawCommands_TaskThread -> FMeshDrawCommand_SetShaders_TaskThread
        
        {
            rank = same;
            edge[style=invis];
            FMobileBasePassMeshProcessor_AddMeshBatch -> FMobileBasePassMeshProcessor_AddMeshBatch_TaskThread
            rankdir = LR;
        }


        FMobileSceneRenderer_RenderForward -> FMobileSceneRenderer_RenderMobileBasePass
        FMobileSceneRenderer_RenderForward -> FMobileSceneRenderer_RenderTranslucency
        {
            rank = same;
            // Here you enforce the desired order with "invisible" edges and arrowheads
            edge[style=invis];
            FMobileSceneRenderer_RenderMobileBasePass -> FMobileSceneRenderer_RenderTranslucency
            rankdir = LR;
        }

        FMobileSceneRenderer_RenderMobileBasePass -> FParallelMeshDrawCommandPass_DispatchDraw

        FSceneRenderer_RenderShadowDepthMaps -> FParallelMeshDrawCommandPass_DispatchDraw_RenderThread_WillTaskThread [style=dashed]
        FMobileSceneRenderer_RenderPrePass -> FParallelMeshDrawCommandPass_DispatchDraw
        FMobileSceneRenderer_RenderAmbientOcclusion -> FParallelMeshDrawCommandPass_DispatchDraw
        {
            rank = same;
            edge[style=invis];
            FParallelMeshDrawCommandPass_DispatchDraw_RenderThread_WillTaskThread -> FParallelMeshDrawCommandPass_DispatchDraw
            rankdir = LR;
        }

        FParallelMeshDrawCommandPass_DispatchDraw -> SubmitMeshDrawCommandsRange_RenderThread
        FParallelMeshDrawCommandPass_DispatchDraw_RenderThread_WillTaskThread -> FDrawVisibleMeshCommandsAnyThreadTask [label="Render thread dispatches to Task thread" color="black:invis:black" penwidth=1]
        FDrawVisibleMeshCommandsAnyThreadTask -> SubmitMeshDrawCommandsRange_TaskThread
        {
            rank = same;
            edge[style=invis];
            SubmitMeshDrawCommandsRange_TaskThread -> SubmitMeshDrawCommandsRange_RenderThread
            rankdir = LR;
        }

        SubmitMeshDrawCommandsRange_RenderThread -> FMeshDrawCommand_SubmitDraw_RenderThread
        SubmitMeshDrawCommandsRange_TaskThread -> FMeshDrawCommand_SubmitDraw_TaskThread
        FMeshDrawCommand_SubmitDraw_TaskThread -> FMeshDrawCommand_SubmitDraw_TaskThread_Subsequent [style=dashed]

        FMeshDrawCommand_SubmitDraw_RenderThread -> FRHICommandList_SetGraphicsPipelineState
        FMeshDrawCommand_SubmitDraw_RenderThread -> FRHICommandList_SetStreamSource
        FMeshDrawCommand_SubmitDraw_RenderThread -> FRHICommandList_DrawIndexedPrimitive
        {
            rank = same;
            // Here you enforce the desired order with "invisible" edges and arrowheads
            edge[style=invis];
            FRHICommandList_SetGraphicsPipelineState -> FRHICommandList_SetStreamSource -> FRHICommandList_DrawIndexedPrimitive
            rankdir = LR;
        }

        FRHICommandList_DrawIndexedPrimitive -> FMetalStateCache_CommitResourceTable [style=dashed]
        FMetalStateCache_CommitResourceTable -> FMetalCommandEncoder_SetShaderBuffer
        FMetalStateCache_CommitResourceTable -> FMetalCommandEncoder_SetShaderTexture
    }

    
}
```

`main/drawing/unreal_rendering_flow.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.38.0 (20140413.2041)
 -->
<!-- Title: %3 Pages: 1 -->
<svg width="2818pt" height="1613pt"
 viewBox="0.00 0.00 2818.00 1613.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 1609)">
<title>%3</title>
<polygon fill="white" stroke="none" points="-4,4 -4,-1609 2814,-1609 2814,4 -4,4"/>
<text text-anchor="middle" x="1405" y="-1553" font-family="Times New Roman,serif" font-size="60.00">Unreal Rendering Flow</text>
<g id="clust1" class="cluster"><title>cluster_01</title>
<polygon fill="none" stroke="black" points="816,-997 816,-1523 1260,-1523 1260,-997 816,-997"/>
<text text-anchor="middle" x="1038" y="-1495" font-family="Times New Roman,serif" font-size="30.00">Legend</text>
</g>
<g id="clust6" class="cluster"><title>cluster_03</title>
<polygon fill="none" stroke="black" points="910,-1005 910,-1185 1252,-1185 1252,-1005 910,-1005"/>
<text text-anchor="middle" x="1081" y="-1157" font-family="Times New Roman,serif" font-size="30.00">invoke</text>
</g>
<g id="clust2" class="cluster"><title>cluster_01</title>
<polygon fill="none" stroke="black" points="824,-1204 824,-1297 1184,-1297 1184,-1204 824,-1204"/>
<text text-anchor="middle" x="1004" y="-1269" font-family="Times New Roman,serif" font-size="30.00">threads</text>
</g>
<g id="clust4" class="cluster"><title>cluster_02</title>
<polygon fill="none" stroke="black" points="842,-1316 842,-1411 1129,-1411 1129,-1316 842,-1316"/>
<text text-anchor="middle" x="985.5" y="-1383" font-family="Times New Roman,serif" font-size="30.00">importance</text>
</g>
<!-- Game_Thread -->
<g id="node1" class="node"><title>Game_Thread</title>
<polygon fill="lightgrey" stroke="black" points="925.5,-1248 832.5,-1248 832.5,-1212 925.5,-1212 925.5,-1248"/>
<text text-anchor="middle" x="879" y="-1226.3" font-family="Times New Roman,serif" font-size="14.00">Game Thread</text>
</g>
<!-- Render_thread -->
<g id="node2" class="node"><title>Render_thread</title>
<polygon fill="lightblue" stroke="lightblue" points="1056.5,-1248 961.5,-1248 961.5,-1212 1056.5,-1212 1056.5,-1248"/>
<text text-anchor="middle" x="1009" y="-1226.3" font-family="Times New Roman,serif" font-size="14.00">Render thread</text>
</g>
<!-- Game_Thread&#45;&gt;Render_thread -->
<!-- Task_thread -->
<g id="node3" class="node"><title>Task_thread</title>
<polygon fill="orange" stroke="orange" points="1175.5,-1248 1092.5,-1248 1092.5,-1212 1175.5,-1212 1175.5,-1248"/>
<text text-anchor="middle" x="1134" y="-1226.3" font-family="Times New Roman,serif" font-size="14.00">Task thread</text>
</g>
<!-- Render_thread&#45;&gt;Task_thread -->
<!-- important -->
<g id="node4" class="node"><title>important</title>
<polygon fill="lightgrey" stroke="black" points="977.5,-1362 850.5,-1362 850.5,-1324 977.5,-1324 977.5,-1362"/>
<text text-anchor="start" x="858.5" y="-1346.8" font-family="Times New Roman,serif" font-size="14.00">Important functions</text>
<text text-anchor="start" x="887.5" y="-1331.8" font-family="Times New Roman,serif" font-size="14.00">filled box</text>
</g>
<!-- trivial -->
<g id="node5" class="node"><title>trivial</title>
<polygon fill="none" stroke="black" points="1120.5,-1362 1013.5,-1362 1013.5,-1324 1120.5,-1324 1120.5,-1362"/>
<text text-anchor="start" x="1021.5" y="-1346.8" font-family="Times New Roman,serif" font-size="14.00">Trivial functions</text>
<text text-anchor="start" x="1032" y="-1331.8" font-family="Times New Roman,serif" font-size="14.00">outlined box</text>
</g>
<!-- important&#45;&gt;trivial -->
<!-- empty1 -->
<g id="node6" class="node"><title>empty1</title>
<polygon fill="none" stroke="black" points="972,-1136 918,-1136 918,-1100 972,-1100 972,-1136"/>
</g>
<!-- empty2 -->
<g id="node7" class="node"><title>empty2</title>
<polygon fill="none" stroke="black" points="972,-1049 918,-1049 918,-1013 972,-1013 972,-1049"/>
</g>
<!-- empty1&#45;&gt;empty2 -->
<g id="edge4" class="edge"><title>empty1&#45;&gt;empty2</title>
<path fill="none" stroke="black" d="M939.945,-1099.93C937.677,-1090.29 935.758,-1078.01 937,-1067 937.287,-1064.45 937.689,-1061.82 938.16,-1059.2"/>
<polygon fill="black" stroke="black" points="941.606,-1059.82 940.233,-1049.31 934.755,-1058.38 941.606,-1059.82"/>
<text text-anchor="middle" x="964.5" y="-1070.8" font-family="Times New Roman,serif" font-size="14.00">direct call</text>
</g>
<!-- empty5 -->
<g id="node8" class="node"><title>empty5</title>
<polygon fill="none" stroke="black" points="1062,-1136 1008,-1136 1008,-1100 1062,-1100 1062,-1136"/>
</g>
<!-- empty1&#45;&gt;empty5 -->
<!-- empty6 -->
<g id="node9" class="node"><title>empty6</title>
<polygon fill="none" stroke="lightblue" points="1044,-1049 990,-1049 990,-1013 1044,-1013 1044,-1049"/>
</g>
<!-- empty5&#45;&gt;empty6 -->
<g id="edge5" class="edge"><title>empty5&#45;&gt;empty6</title>
<path fill="none" stroke="black" stroke-dasharray="5,2" d="M1022.93,-1099.97C1019.7,-1094.49 1016.65,-1088.22 1015,-1082 1013.09,-1074.81 1012.68,-1066.83 1012.98,-1059.4"/>
<polygon fill="black" stroke="black" points="1016.48,-1059.65 1013.8,-1049.4 1009.5,-1059.08 1016.48,-1059.65"/>
<text text-anchor="middle" x="1047" y="-1070.8" font-family="Times New Roman,serif" font-size="14.00">indirect call</text>
</g>
<!-- empty3 -->
<g id="node10" class="node"><title>empty3</title>
<polygon fill="none" stroke="black" points="1152,-1136 1098,-1136 1098,-1100 1152,-1100 1152,-1136"/>
</g>
<!-- empty5&#45;&gt;empty3 -->
<!-- empty4 -->
<g id="node11" class="node"><title>empty4</title>
<polygon fill="none" stroke="lightblue" points="1128,-1049 1074,-1049 1074,-1013 1128,-1013 1128,-1049"/>
</g>
<!-- empty3&#45;&gt;empty4 -->
<g id="edge6" class="edge"><title>empty3&#45;&gt;empty4</title>
<path fill="none" stroke="black" d="M1118.22,-1100.34C1114.9,-1088.59 1110.44,-1072.78 1106.65,-1059.39"/>
<path fill="none" stroke="none" d="M1120.14,-1099.8C1116.83,-1088.05 1112.36,-1072.24 1108.58,-1058.84"/>
<path fill="none" stroke="black" d="M1122.07,-1099.26C1118.75,-1087.5 1114.29,-1071.69 1110.5,-1058.3"/>
<polygon fill="black" stroke="black" points="1111.94,-1057.85 1105.85,-1049.18 1105.2,-1059.75 1111.94,-1057.85"/>
<text text-anchor="start" x="1115" y="-1070.8" font-family="Times New Roman,serif" font-size="14.00">dispatch into other thread</text>
</g>
<!-- row1 -->
<!-- row1&#45;&gt;important -->
<!-- row2 -->
<!-- row1&#45;&gt;row2 -->
<!-- row2&#45;&gt;Game_Thread -->
<!-- row3 -->
<!-- row2&#45;&gt;row3 -->
<!-- row3&#45;&gt;empty1 -->
<!-- FEngineLoop_Tick -->
<g id="node15" class="node"><title>FEngineLoop_Tick</title>
<polygon fill="lightgrey" stroke="black" points="1859,-1474 1725,-1474 1725,-1438 1859,-1438 1859,-1474"/>
<text text-anchor="middle" x="1792" y="-1452.3" font-family="Times New Roman,serif" font-size="14.00">FEngineLoop::Tick()</text>
</g>
<!-- UGameEngine_Tick -->
<g id="node17" class="node"><title>UGameEngine_Tick</title>
<polygon fill="lightgrey" stroke="black" points="1778.5,-1361 1641.5,-1361 1641.5,-1325 1778.5,-1325 1778.5,-1361"/>
<text text-anchor="middle" x="1710" y="-1339.3" font-family="Times New Roman,serif" font-size="14.00">UGameEngine::Tick()</text>
</g>
<!-- FEngineLoop_Tick&#45;&gt;UGameEngine_Tick -->
<g id="edge14" class="edge"><title>FEngineLoop_Tick&#45;&gt;UGameEngine_Tick</title>
<path fill="none" stroke="black" d="M1779.19,-1437.66C1765.65,-1419.33 1744.16,-1390.24 1728.72,-1369.34"/>
<polygon fill="black" stroke="black" points="1731.48,-1367.19 1722.72,-1361.22 1725.85,-1371.34 1731.48,-1367.19"/>
</g>
<!-- FSlateApplication_Tick -->
<g id="node19" class="node"><title>FSlateApplication_Tick</title>
<polygon fill="lightgrey" stroke="black" points="2085.5,-1361 1928.5,-1361 1928.5,-1325 2085.5,-1325 2085.5,-1361"/>
<text text-anchor="middle" x="2007" y="-1339.3" font-family="Times New Roman,serif" font-size="14.00">FSlateApplication::Tick()</text>
</g>
<!-- FEngineLoop_Tick&#45;&gt;FSlateApplication_Tick -->
<g id="edge15" class="edge"><title>FEngineLoop_Tick&#45;&gt;FSlateApplication_Tick</title>
<path fill="none" stroke="black" d="M1825.12,-1437.9C1862.68,-1418.51 1924.01,-1386.85 1964.93,-1365.72"/>
<polygon fill="black" stroke="black" points="1966.56,-1368.82 1973.84,-1361.12 1963.35,-1362.6 1966.56,-1368.82"/>
</g>
<!-- UWorld_Tick -->
<g id="node16" class="node"><title>UWorld_Tick</title>
<polygon fill="none" stroke="black" points="1567.5,-1248 1464.5,-1248 1464.5,-1212 1567.5,-1212 1567.5,-1248"/>
<text text-anchor="middle" x="1516" y="-1226.3" font-family="Times New Roman,serif" font-size="14.00">UWorld::Tick()</text>
</g>
<!-- UGameEngine_RedrawViewports -->
<g id="node18" class="node"><title>UGameEngine_RedrawViewports</title>
<polygon fill="lightgrey" stroke="black" points="1816.5,-1248 1603.5,-1248 1603.5,-1212 1816.5,-1212 1816.5,-1248"/>
<text text-anchor="middle" x="1710" y="-1226.3" font-family="Times New Roman,serif" font-size="14.00">UGameEngine::RedrawViewports()</text>
</g>
<!-- UWorld_Tick&#45;&gt;UGameEngine_RedrawViewports -->
<!-- UGameEngine_Tick&#45;&gt;UWorld_Tick -->
<g id="edge20" class="edge"><title>UGameEngine_Tick&#45;&gt;UWorld_Tick</title>
<path fill="none" stroke="black" d="M1655.13,-1324.96C1635.2,-1317.69 1612.94,-1308.26 1594,-1297 1574.44,-1285.38 1554.9,-1268.84 1540.27,-1255.22"/>
<polygon fill="black" stroke="black" points="1542.34,-1252.36 1532.68,-1248.01 1537.52,-1257.43 1542.34,-1252.36"/>
</g>
<!-- UGameEngine_Tick&#45;&gt;UGameEngine_RedrawViewports -->
<g id="edge21" class="edge"><title>UGameEngine_Tick&#45;&gt;UGameEngine_RedrawViewports</title>
<path fill="none" stroke="black" d="M1710,-1324.66C1710,-1306.9 1710,-1279.04 1710,-1258.32"/>
<polygon fill="black" stroke="black" points="1713.5,-1258.22 1710,-1248.22 1706.5,-1258.22 1713.5,-1258.22"/>
</g>
<!-- FViewport_Draw -->
<g id="node24" class="node"><title>FViewport_Draw</title>
<polygon fill="lightgrey" stroke="black" points="1750,-1136 1628,-1136 1628,-1100 1750,-1100 1750,-1136"/>
<text text-anchor="middle" x="1689" y="-1114.3" font-family="Times New Roman,serif" font-size="14.00">FViewport::Draw()</text>
</g>
<!-- UGameEngine_RedrawViewports&#45;&gt;FViewport_Draw -->
<g id="edge23" class="edge"><title>UGameEngine_RedrawViewports&#45;&gt;FViewport_Draw</title>
<path fill="none" stroke="black" d="M1706.72,-1211.81C1703.36,-1194.21 1698.09,-1166.61 1694.17,-1146.07"/>
<polygon fill="black" stroke="black" points="1697.57,-1145.23 1692.26,-1136.07 1690.7,-1146.55 1697.57,-1145.23"/>
</g>
<!-- FSlateRHIRenderer_DrawWindows -->
<g id="node20" class="node"><title>FSlateRHIRenderer_DrawWindows</title>
<polygon fill="lightgrey" stroke="black" points="2257,-1248 2031,-1248 2031,-1212 2257,-1212 2257,-1248"/>
<text text-anchor="middle" x="2144" y="-1226.3" font-family="Times New Roman,serif" font-size="14.00">FSlateRHIRenderer::DrawWindows()</text>
</g>
<!-- FSlateApplication_Tick&#45;&gt;FSlateRHIRenderer_DrawWindows -->
<g id="edge16" class="edge"><title>FSlateApplication_Tick&#45;&gt;FSlateRHIRenderer_DrawWindows</title>
<path fill="none" stroke="black" stroke-dasharray="5,2" d="M2028.11,-1324.9C2051.27,-1306.13 2088.61,-1275.88 2114.63,-1254.8"/>
<polygon fill="black" stroke="black" points="2117.08,-1257.32 2122.64,-1248.3 2112.67,-1251.88 2117.08,-1257.32"/>
</g>
<!-- FSlateRHIRenderer_DrawWindow_RenderThread -->
<g id="node21" class="node"><title>FSlateRHIRenderer_DrawWindow_RenderThread</title>
<polygon fill="lightblue" stroke="lightblue" points="2331,-790.5 2023,-790.5 2023,-754.5 2331,-754.5 2331,-790.5"/>
<text text-anchor="middle" x="2177" y="-768.8" font-family="Times New Roman,serif" font-size="14.00">FSlateRHIRenderer::DrawWindow_RenderThread()</text>
</g>
<!-- FSlateRHIRenderer_DrawWindows&#45;&gt;FSlateRHIRenderer_DrawWindow_RenderThread -->
<g id="edge17" class="edge"><title>FSlateRHIRenderer_DrawWindows&#45;&gt;FSlateRHIRenderer_DrawWindow_RenderThread</title>
<path fill="none" stroke="black" d="M2150.68,-1211.11C2160.41,-1189.99 2175.14,-1152.37 2175,-1119 2175,-1119 2175,-1119 2175,-864 2175,-842.691 2175,-818.561 2175,-800.579"/>
<path fill="none" stroke="none" d="M2152.5,-1211.95C2162.28,-1190.72 2177,-1153.09 2177,-1119 2177,-1119 2177,-1119 2177,-864 2177,-842.691 2177,-818.561 2177,-800.579"/>
<path fill="none" stroke="black" d="M2154.31,-1212.79C2164.14,-1191.45 2178.86,-1153.82 2179,-1119 2179,-1119 2179,-1119 2179,-864 2179,-842.691 2179,-818.561 2179,-800.579"/>
<polygon fill="black" stroke="black" points="2180.5,-800.513 2177,-790.513 2173.5,-800.513 2180.5,-800.513"/>
<text text-anchor="middle" x="2293" y="-977.8" font-family="Times New Roman,serif" font-size="14.00">Game thread dispatches to Render thread</text>
</g>
<!-- FRHICommandList_EndDrawingViewport -->
<g id="node22" class="node"><title>FRHICommandList_EndDrawingViewport</title>
<polygon fill="lightblue" stroke="lightblue" points="2508,-702.5 2244,-702.5 2244,-666.5 2508,-666.5 2508,-702.5"/>
<text text-anchor="middle" x="2376" y="-680.8" font-family="Times New Roman,serif" font-size="14.00">FRHICommandList::EndDrawingViewport()</text>
</g>
<!-- FSlateRHIRenderer_DrawWindow_RenderThread&#45;&gt;FRHICommandList_EndDrawingViewport -->
<g id="edge18" class="edge"><title>FSlateRHIRenderer_DrawWindow_RenderThread&#45;&gt;FRHICommandList_EndDrawingViewport</title>
<path fill="none" stroke="black" d="M2216.79,-754.303C2248.62,-740.548 2293.39,-721.203 2327.34,-706.527"/>
<polygon fill="black" stroke="black" points="2328.83,-709.7 2336.62,-702.52 2326.05,-703.274 2328.83,-709.7"/>
</g>
<!-- FMetalViewport_Present -->
<g id="node23" class="node"><title>FMetalViewport_Present</title>
<polygon fill="lightblue" stroke="lightblue" points="2497,-620 2333,-620 2333,-584 2497,-584 2497,-620"/>
<text text-anchor="middle" x="2415" y="-598.3" font-family="Times New Roman,serif" font-size="14.00">FMetalViewport::Present()</text>
</g>
<!-- FRHICommandList_EndDrawingViewport&#45;&gt;FMetalViewport_Present -->
<g id="edge19" class="edge"><title>FRHICommandList_EndDrawingViewport&#45;&gt;FMetalViewport_Present</title>
<path fill="none" stroke="black" d="M2384.27,-666.428C2389.49,-655.649 2396.35,-641.505 2402.25,-629.309"/>
<polygon fill="black" stroke="black" points="2405.53,-630.573 2406.74,-620.047 2399.23,-627.521 2405.53,-630.573"/>
</g>
<!-- FSceneViewport_EnqueueBeginRenderFrame -->
<g id="node25" class="node"><title>FSceneViewport_EnqueueBeginRenderFrame</title>
<polygon fill="none" stroke="black" points="1549.5,-1049 1268.5,-1049 1268.5,-1013 1549.5,-1013 1549.5,-1049"/>
<text text-anchor="middle" x="1409" y="-1027.3" font-family="Times New Roman,serif" font-size="14.00">FSceneViewport::EnqueueBeginRenderFrame()</text>
</g>
<!-- FViewport_Draw&#45;&gt;FSceneViewport_EnqueueBeginRenderFrame -->
<g id="edge24" class="edge"><title>FViewport_Draw&#45;&gt;FSceneViewport_EnqueueBeginRenderFrame</title>
<path fill="none" stroke="black" d="M1632.67,-1099.9C1587.11,-1086.07 1522.86,-1066.56 1474.9,-1052.01"/>
<polygon fill="black" stroke="black" points="1475.82,-1048.63 1465.24,-1049.07 1473.79,-1055.33 1475.82,-1048.63"/>
</g>
<!-- UGameViewportClient_Draw -->
<g id="node26" class="node"><title>UGameViewportClient_Draw</title>
<polygon fill="lightgrey" stroke="black" points="1773,-1049 1585,-1049 1585,-1013 1773,-1013 1773,-1049"/>
<text text-anchor="middle" x="1679" y="-1027.3" font-family="Times New Roman,serif" font-size="14.00">UGameViewportClient::Draw()</text>
</g>
<!-- FViewport_Draw&#45;&gt;UGameViewportClient_Draw -->
<g id="edge25" class="edge"><title>FViewport_Draw&#45;&gt;UGameViewportClient_Draw</title>
<path fill="none" stroke="black" d="M1686.98,-1099.8C1685.61,-1088.16 1683.77,-1072.55 1682.2,-1059.24"/>
<polygon fill="black" stroke="black" points="1685.67,-1058.7 1681.02,-1049.18 1678.71,-1059.52 1685.67,-1058.7"/>
</g>
<!-- FSceneViewport_EnqueueEndRenderFrame -->
<g id="node27" class="node"><title>FSceneViewport_EnqueueEndRenderFrame</title>
<polygon fill="none" stroke="black" points="2081,-1049 1809,-1049 1809,-1013 2081,-1013 2081,-1049"/>
<text text-anchor="middle" x="1945" y="-1027.3" font-family="Times New Roman,serif" font-size="14.00">FSceneViewport::EnqueueEndRenderFrame()</text>
</g>
<!-- FViewport_Draw&#45;&gt;FSceneViewport_EnqueueEndRenderFrame -->
<g id="edge26" class="edge"><title>FViewport_Draw&#45;&gt;FSceneViewport_EnqueueEndRenderFrame</title>
<path fill="none" stroke="black" d="M1740.5,-1099.9C1781.9,-1086.15 1840.17,-1066.81 1883.92,-1052.28"/>
<polygon fill="black" stroke="black" points="1885.2,-1055.54 1893.58,-1049.07 1882.99,-1048.9 1885.2,-1055.54"/>
</g>
<!-- FSceneViewport_EnqueueBeginRenderFrame&#45;&gt;UGameViewportClient_Draw -->
<!-- UGameViewportClient_Draw&#45;&gt;FSceneViewport_EnqueueEndRenderFrame -->
<!-- UWorld_UpdateLevelStreaming -->
<g id="node28" class="node"><title>UWorld_UpdateLevelStreaming</title>
<polygon fill="none" stroke="black" points="1430.5,-956 1227.5,-956 1227.5,-920 1430.5,-920 1430.5,-956"/>
<text text-anchor="middle" x="1329" y="-934.3" font-family="Times New Roman,serif" font-size="14.00">UWorld::UpdateLevelStreaming()</text>
</g>
<!-- UGameViewportClient_Draw&#45;&gt;UWorld_UpdateLevelStreaming -->
<g id="edge29" class="edge"><title>UGameViewportClient_Draw&#45;&gt;UWorld_UpdateLevelStreaming</title>
<path fill="none" stroke="black" d="M1617.5,-1013C1598.45,-1007.79 1577.37,-1002.09 1558,-997 1508.03,-983.86 1451.79,-969.608 1407.55,-958.519"/>
<polygon fill="black" stroke="black" points="1408.28,-955.093 1397.73,-956.06 1406.58,-961.884 1408.28,-955.093"/>
</g>
<!-- FRendererModule_BeginRenderingViewFamily -->
<g id="node29" class="node"><title>FRendererModule_BeginRenderingViewFamily</title>
<polygon fill="lightgrey" stroke="black" points="1754,-956 1466,-956 1466,-920 1754,-920 1754,-956"/>
<text text-anchor="middle" x="1610" y="-934.3" font-family="Times New Roman,serif" font-size="14.00">FRendererModule::BeginRenderingViewFamily()</text>
</g>
<!-- UGameViewportClient_Draw&#45;&gt;FRendererModule_BeginRenderingViewFamily -->
<g id="edge30" class="edge"><title>UGameViewportClient_Draw&#45;&gt;FRendererModule_BeginRenderingViewFamily</title>
<path fill="none" stroke="black" d="M1666.02,-1012.88C1655.61,-999.156 1640.85,-979.69 1629.1,-964.185"/>
<polygon fill="black" stroke="black" points="1631.75,-961.893 1622.92,-956.04 1626.17,-966.123 1631.75,-961.893"/>
</g>
<!-- ABaseHud_PostRender -->
<g id="node30" class="node"><title>ABaseHud_PostRender</title>
<polygon fill="none" stroke="black" points="1948,-956 1790,-956 1790,-920 1948,-920 1948,-956"/>
<text text-anchor="middle" x="1869" y="-934.3" font-family="Times New Roman,serif" font-size="14.00">ABaseHud::PostRender()</text>
</g>
<!-- UGameViewportClient_Draw&#45;&gt;ABaseHud_PostRender -->
<g id="edge31" class="edge"><title>UGameViewportClient_Draw&#45;&gt;ABaseHud_PostRender</title>
<path fill="none" stroke="black" d="M1714.74,-1012.88C1745.79,-998.012 1790.9,-976.406 1824.33,-960.396"/>
<polygon fill="black" stroke="black" points="1825.92,-963.516 1833.42,-956.04 1822.89,-957.203 1825.92,-963.516"/>
</g>
<!-- UWorld_UpdateLevelStreaming&#45;&gt;FRendererModule_BeginRenderingViewFamily -->
<!-- FRendererModule_BeginRenderingViewFamily&#45;&gt;ABaseHud_PostRender -->
<!-- UWorld_SendAllEndOfFrameUpdates -->
<g id="node31" class="node"><title>UWorld_SendAllEndOfFrameUpdates</title>
<polygon fill="none" stroke="black" points="1429.5,-883 1160.5,-883 1160.5,-847 1429.5,-847 1429.5,-883"/>
<text text-anchor="start" x="1187" y="-866.3" font-family="Times New Roman,serif" font-size="14.00">UWorld::SendAllEndOfFrameUpdates</text>
<text text-anchor="start" x="1168.5" y="-856.3" font-family="Times New Roman,serif" font-size="9.00">guarantee all render proxies are up to date before kicking off this frame</text>
</g>
<!-- FRendererModule_BeginRenderingViewFamily&#45;&gt;UWorld_SendAllEndOfFrameUpdates -->
<g id="edge35" class="edge"><title>FRendererModule_BeginRenderingViewFamily&#45;&gt;UWorld_SendAllEndOfFrameUpdates</title>
<path fill="none" stroke="black" d="M1534.55,-919.994C1488.15,-909.535 1428.56,-896.105 1380.43,-885.256"/>
<polygon fill="black" stroke="black" points="1381.18,-881.836 1370.65,-883.052 1379.64,-888.665 1381.18,-881.836"/>
</g>
<!-- FSceneRenderer_CreateSceneRenderer -->
<g id="node32" class="node"><title>FSceneRenderer_CreateSceneRenderer</title>
<polygon fill="lightgrey" stroke="black" points="1124.5,-883 879.5,-883 879.5,-847 1124.5,-847 1124.5,-883"/>
<text text-anchor="start" x="887.5" y="-867.3" font-family="Times New Roman,serif" font-size="14.00">FSceneRenderer::CreateSceneRenderer()</text>
<text text-anchor="start" x="887.5" y="-855.7" font-family="Times New Roman,serif" font-size="11.00">which creates FMobileSceneRenderer of this frame</text>
</g>
<!-- FRendererModule_BeginRenderingViewFamily&#45;&gt;FSceneRenderer_CreateSceneRenderer -->
<g id="edge34" class="edge"><title>FRendererModule_BeginRenderingViewFamily&#45;&gt;FSceneRenderer_CreateSceneRenderer</title>
<path fill="none" stroke="black" d="M1465.91,-920.174C1365.42,-908.439 1232.34,-892.898 1134.49,-881.472"/>
<polygon fill="black" stroke="black" points="1134.87,-877.993 1124.53,-880.309 1134.06,-884.946 1134.87,-877.993"/>
</g>
<!-- EnequeueRenderCommand_DrawScene -->
<g id="node33" class="node"><title>EnequeueRenderCommand_DrawScene</title>
<polygon fill="lightgrey" stroke="black" points="1755,-883 1465,-883 1465,-847 1755,-847 1755,-883"/>
<text text-anchor="start" x="1473" y="-861.3" font-family="Times New Roman,serif" font-size="14.00">EnequeueUniqueRenderCommand_DrawScene()</text>
</g>
<!-- FRendererModule_BeginRenderingViewFamily&#45;&gt;EnequeueRenderCommand_DrawScene -->
<g id="edge36" class="edge"><title>FRendererModule_BeginRenderingViewFamily&#45;&gt;EnequeueRenderCommand_DrawScene</title>
<path fill="none" stroke="black" d="M1610,-919.813C1610,-911.789 1610,-902.047 1610,-893.069"/>
<polygon fill="black" stroke="black" points="1613.5,-893.029 1610,-883.029 1606.5,-893.029 1613.5,-893.029"/>
</g>
<!-- DeleteSceneRenderer -->
<g id="node34" class="node"><title>DeleteSceneRenderer</title>
<polygon fill="none" stroke="black" points="2149,-883 1791,-883 1791,-847 2149,-847 2149,-883"/>
<text text-anchor="start" x="1799" y="-867.3" font-family="Times New Roman,serif" font-size="14.00">FSceneRenderer::DelayWaitForTasks...DeleteSceneRenderer</text>
<text text-anchor="start" x="1864.5" y="-855.7" font-family="Times New Roman,serif" font-size="11.00">which deletes mobile scene render of this frame</text>
</g>
<!-- FRendererModule_BeginRenderingViewFamily&#45;&gt;DeleteSceneRenderer -->
<g id="edge37" class="edge"><title>FRendererModule_BeginRenderingViewFamily&#45;&gt;DeleteSceneRenderer</title>
<path fill="none" stroke="black" d="M1696.23,-919.994C1749.59,-909.469 1818.21,-895.937 1873.4,-885.052"/>
<polygon fill="black" stroke="black" points="1874.41,-888.421 1883.54,-883.052 1873.05,-881.553 1874.41,-888.421"/>
</g>
<!-- UWorld_SendAllEndOfFrameUpdates&#45;&gt;EnequeueRenderCommand_DrawScene -->
<!-- FSceneRenderer_CreateSceneRenderer&#45;&gt;UWorld_SendAllEndOfFrameUpdates -->
<!-- EnequeueRenderCommand_DrawScene&#45;&gt;FSlateRHIRenderer_DrawWindow_RenderThread -->
<!-- EnequeueRenderCommand_DrawScene&#45;&gt;DeleteSceneRenderer -->
<!-- FMobileSceneRenderer_Render -->
<g id="node35" class="node"><title>FMobileSceneRenderer_Render</title>
<polygon fill="lightblue" stroke="lightblue" points="1729.5,-796 1436.5,-796 1436.5,-749 1729.5,-749 1729.5,-796"/>
<text text-anchor="start" x="1501.5" y="-784.2" font-family="Times New Roman,serif" font-size="11.00">RenderViewFamily_RenderThread()</text>
<text text-anchor="start" x="1489" y="-770.8" font-family="Times New Roman,serif" font-size="14.00">FMobileSceneRenderer::Render()</text>
<text text-anchor="start" x="1444.5" y="-756.8" font-family="Times New Roman,serif" font-weight="bold" font-size="14.00" fill="red">for all views, render all the mobile techniques</text>
</g>
<!-- EnequeueRenderCommand_DrawScene&#45;&gt;FMobileSceneRenderer_Render -->
<g id="edge41" class="edge"><title>EnequeueRenderCommand_DrawScene&#45;&gt;FMobileSceneRenderer_Render</title>
<path fill="none" stroke="black" d="M1603,-847.549C1599.56,-836.013 1594.91,-820.401 1590.77,-806.534"/>
<path fill="none" stroke="none" d="M1604.92,-846.978C1601.48,-835.441 1596.82,-819.829 1592.68,-805.962"/>
<path fill="none" stroke="black" d="M1606.84,-846.406C1603.4,-834.869 1598.74,-819.257 1594.6,-805.39"/>
<polygon fill="black" stroke="black" points="1596,-804.839 1589.79,-796.257 1589.29,-806.84 1596,-804.839"/>
<text text-anchor="middle" x="1715" y="-817.8" font-family="Times New Roman,serif" font-size="14.00">Game thread dispatches to Render thread</text>
</g>
<!-- FScene_UpdateAllPrimitiveSceneInfos -->
<g id="node36" class="node"><title>FScene_UpdateAllPrimitiveSceneInfos</title>
<polygon fill="lightblue" stroke="lightblue" points="1045.5,-702.5 782.5,-702.5 782.5,-666.5 1045.5,-666.5 1045.5,-702.5"/>
<text text-anchor="start" x="805.5" y="-686.8" font-family="Times New Roman,serif" font-size="14.00">FScene::UpdateAllPrimitiveSceneInfos</text>
<text text-anchor="start" x="790.5" y="-675.2" font-family="Times New Roman,serif" font-size="11.00">For each STATIC primitive, cache its Draw Commands</text>
</g>
<!-- FMobileSceneRenderer_Render&#45;&gt;FScene_UpdateAllPrimitiveSceneInfos -->
<g id="edge43" class="edge"><title>FMobileSceneRenderer_Render&#45;&gt;FScene_UpdateAllPrimitiveSceneInfos</title>
<path fill="none" stroke="black" d="M1436.27,-756.393C1333.99,-745.379 1194.47,-729.39 1072,-712 1055.43,-709.647 1037.91,-706.935 1020.82,-704.164"/>
<polygon fill="black" stroke="black" points="1021.24,-700.687 1010.81,-702.528 1020.11,-707.595 1021.24,-700.687"/>
</g>
<!-- FMobileSceneRenderer_InitViews -->
<g id="node37" class="node"><title>FMobileSceneRenderer_InitViews</title>
<polygon fill="lightblue" stroke="lightblue" points="1297,-712 1081,-712 1081,-657 1297,-657 1297,-712"/>
<text text-anchor="start" x="1089" y="-697.8" font-family="Times New Roman,serif" font-size="14.00">FMobileSceneRenderer::InitViews()</text>
<text text-anchor="start" x="1157" y="-686.2" font-family="Times New Roman,serif" font-size="11.00">For each view</text>
<text text-anchor="start" x="1143" y="-675.2" font-family="Times New Roman,serif" font-size="11.00">find visible primitives</text>
<text text-anchor="start" x="1112" y="-664.2" font-family="Times New Roman,serif" font-size="11.00">build DYNAMIC draw commands</text>
</g>
<!-- FMobileSceneRenderer_Render&#45;&gt;FMobileSceneRenderer_InitViews -->
<g id="edge44" class="edge"><title>FMobileSceneRenderer_Render&#45;&gt;FMobileSceneRenderer_InitViews</title>
<path fill="none" stroke="black" d="M1479.74,-748.961C1426.72,-737.388 1361.89,-723.237 1306.91,-711.237"/>
<polygon fill="black" stroke="black" points="1307.64,-707.813 1297.12,-709.1 1306.14,-714.652 1307.64,-707.813"/>
</g>
<!-- FSceneRenderer_RenderShadowDepthMaps -->
<g id="node43" class="node"><title>FSceneRenderer_RenderShadowDepthMaps</title>
<polygon fill="lightblue" stroke="lightblue" points="1470,-702.5 1348,-702.5 1348,-666.5 1470,-666.5 1470,-702.5"/>
<text text-anchor="start" x="1356" y="-682.3" font-family="Times New Roman,serif" font-size="9.00">RenderShadowDepthMaps()</text>
</g>
<!-- FMobileSceneRenderer_Render&#45;&gt;FSceneRenderer_RenderShadowDepthMaps -->
<g id="edge45" class="edge"><title>FMobileSceneRenderer_Render&#45;&gt;FSceneRenderer_RenderShadowDepthMaps</title>
<path fill="none" stroke="black" d="M1537.28,-748.905C1511.1,-735.962 1478.42,-719.809 1452.59,-707.047"/>
<polygon fill="black" stroke="black" points="1453.93,-703.803 1443.42,-702.51 1450.83,-710.079 1453.93,-703.803"/>
</g>
<!-- FMobileSceneRenderer_RenderPrePass -->
<g id="node44" class="node"><title>FMobileSceneRenderer_RenderPrePass</title>
<polygon fill="none" stroke="lightblue" points="1582.5,-702.5 1505.5,-702.5 1505.5,-666.5 1582.5,-666.5 1582.5,-702.5"/>
<text text-anchor="start" x="1513.5" y="-682.3" font-family="Times New Roman,serif" font-size="9.00">RenderPrePass()</text>
</g>
<!-- FMobileSceneRenderer_Render&#45;&gt;FMobileSceneRenderer_RenderPrePass -->
<g id="edge46" class="edge"><title>FMobileSceneRenderer_Render&#45;&gt;FMobileSceneRenderer_RenderPrePass</title>
<path fill="none" stroke="black" d="M1572.75,-748.905C1567.6,-737.552 1561.34,-723.728 1555.97,-711.89"/>
<polygon fill="black" stroke="black" points="1559.03,-710.172 1551.71,-702.51 1552.66,-713.063 1559.03,-710.172"/>
</g>
<!-- FMobileSceneRenderer_RenderAmbientOcclusion -->
<g id="node45" class="node"><title>FMobileSceneRenderer_RenderAmbientOcclusion</title>
<polygon fill="none" stroke="lightblue" points="1734,-702.5 1618,-702.5 1618,-666.5 1734,-666.5 1734,-702.5"/>
<text text-anchor="start" x="1626" y="-682.3" font-family="Times New Roman,serif" font-size="9.00">RenderAmbientOcclusion()</text>
</g>
<!-- FMobileSceneRenderer_Render&#45;&gt;FMobileSceneRenderer_RenderAmbientOcclusion -->
<g id="edge47" class="edge"><title>FMobileSceneRenderer_Render&#45;&gt;FMobileSceneRenderer_RenderAmbientOcclusion</title>
<path fill="none" stroke="black" d="M1607.43,-748.905C1620.57,-736.757 1636.77,-721.781 1650.12,-709.434"/>
<polygon fill="black" stroke="black" points="1652.64,-711.869 1657.61,-702.51 1647.89,-706.73 1652.64,-711.869"/>
</g>
<!-- FMobileSceneRenderer_RenderForward -->
<g id="node46" class="node"><title>FMobileSceneRenderer_RenderForward</title>
<polygon fill="lightblue" stroke="lightblue" points="2022,-702.5 1770,-702.5 1770,-666.5 2022,-666.5 2022,-702.5"/>
<text text-anchor="start" x="1778" y="-680.8" font-family="Times New Roman,serif" font-size="14.00">FMobileSceneRenderer::RenderForward()</text>
</g>
<!-- FMobileSceneRenderer_Render&#45;&gt;FMobileSceneRenderer_RenderForward -->
<g id="edge48" class="edge"><title>FMobileSceneRenderer_Render&#45;&gt;FMobileSceneRenderer_RenderForward</title>
<path fill="none" stroke="black" d="M1665.24,-748.905C1714.61,-735.338 1776.83,-718.243 1824.21,-705.224"/>
<polygon fill="black" stroke="black" points="1825.38,-708.535 1834.09,-702.51 1823.52,-701.785 1825.38,-708.535"/>
</g>
<!-- FPostProcessing_ProcessES2 -->
<g id="node47" class="node"><title>FPostProcessing_ProcessES2</title>
<polygon fill="none" stroke="lightblue" points="2186.5,-702.5 2057.5,-702.5 2057.5,-666.5 2186.5,-666.5 2186.5,-702.5"/>
<text text-anchor="start" x="2065.5" y="-688.3" font-family="Times New Roman,serif" font-size="9.00">FPostProcessing::ProcessES2()</text>
<text text-anchor="start" x="2091.5" y="-677.7" font-family="Times New Roman,serif" font-size="11.00">for each view</text>
</g>
<!-- FMobileSceneRenderer_Render&#45;&gt;FPostProcessing_ProcessES2 -->
<g id="edge49" class="edge"><title>FMobileSceneRenderer_Render&#45;&gt;FPostProcessing_ProcessES2</title>
<path fill="none" stroke="black" d="M1729.72,-757.677C1817.66,-747.991 1931.39,-732.993 2031,-712 2039.99,-710.106 2049.38,-707.778 2058.58,-705.296"/>
<polygon fill="black" stroke="black" points="2059.75,-708.603 2068.45,-702.555 2057.88,-701.858 2059.75,-708.603"/>
</g>
<!-- FScene_UpdateAllPrimitiveSceneInfos&#45;&gt;FMobileSceneRenderer_InitViews -->
<!-- FPrimitiveSceneInfo_AddToScene -->
<g id="node50" class="node"><title>FPrimitiveSceneInfo_AddToScene</title>
<polygon fill="lightblue" stroke="lightblue" points="615.5,-620 372.5,-620 372.5,-584 615.5,-584 615.5,-620"/>
<text text-anchor="start" x="391.5" y="-604.3" font-family="Times New Roman,serif" font-size="14.00">FPrimitiveSceneInfo::AddToScene()</text>
<text text-anchor="start" x="380.5" y="-592.7" font-family="Times New Roman,serif" font-size="11.00">AddStaticMeshes(), CacheMeshDrawCommands()</text>
</g>
<!-- FScene_UpdateAllPrimitiveSceneInfos&#45;&gt;FPrimitiveSceneInfo_AddToScene -->
<g id="edge56" class="edge"><title>FScene_UpdateAllPrimitiveSceneInfos&#45;&gt;FPrimitiveSceneInfo_AddToScene</title>
<path fill="none" stroke="black" d="M825.186,-666.477C757.269,-653.46 663.642,-635.515 593.261,-622.025"/>
<polygon fill="black" stroke="black" points="593.531,-618.513 583.051,-620.068 592.213,-625.388 593.531,-618.513"/>
</g>
<!-- FSceneRenderer_ComputeViewVisibility -->
<g id="node38" class="node"><title>FSceneRenderer_ComputeViewVisibility</title>
<polygon fill="lightblue" stroke="lightblue" points="952,-620 698,-620 698,-584 952,-584 952,-620"/>
<text text-anchor="start" x="706" y="-598.3" font-family="Times New Roman,serif" font-size="14.00">FSceneRenderer::ComputeViewVisibility()</text>
</g>
<!-- FMobileSceneRenderer_InitViews&#45;&gt;FSceneRenderer_ComputeViewVisibility -->
<g id="edge63" class="edge"><title>FMobileSceneRenderer_InitViews&#45;&gt;FSceneRenderer_ComputeViewVisibility</title>
<path fill="none" stroke="black" d="M1080.77,-659.565C1026.84,-647.638 962.51,-633.411 911.856,-622.208"/>
<polygon fill="black" stroke="black" points="912.434,-618.752 901.914,-620.01 910.923,-625.587 912.434,-618.752"/>
</g>
<!-- FMobileSceneRenderer_SetupMobileBasePassAfterShadowInit -->
<g id="node40" class="node"><title>FMobileSceneRenderer_SetupMobileBasePassAfterShadowInit</title>
<polygon fill="lightblue" stroke="lightblue" points="1368,-620 988,-620 988,-584 1368,-584 1368,-620"/>
<text text-anchor="start" x="996" y="-598.3" font-family="Times New Roman,serif" font-size="14.00">FMobileSceneRenderer::SetupMobileBasePassAfterShadowInit()</text>
</g>
<!-- FMobileSceneRenderer_InitViews&#45;&gt;FMobileSceneRenderer_SetupMobileBasePassAfterShadowInit -->
<g id="edge64" class="edge"><title>FMobileSceneRenderer_InitViews&#45;&gt;FMobileSceneRenderer_SetupMobileBasePassAfterShadowInit</title>
<path fill="none" stroke="black" d="M1185.34,-656.695C1184.16,-648.11 1182.87,-638.604 1181.69,-630.006"/>
<polygon fill="black" stroke="black" points="1185.16,-629.524 1180.34,-620.09 1178.22,-630.472 1185.16,-629.524"/>
</g>
<!-- FMobileSceneRenderer_InitViews&#45;&gt;FSceneRenderer_RenderShadowDepthMaps -->
<!-- FSceneRenderer_SetupMeshPass -->
<g id="node39" class="node"><title>FSceneRenderer_SetupMeshPass</title>
<polygon fill="lightblue" stroke="lightblue" points="859,-533 645,-533 645,-497 859,-497 859,-533"/>
<text text-anchor="start" x="653" y="-511.3" font-family="Times New Roman,serif" font-size="14.00">FSceneRenderer::SetupMeshPass()</text>
</g>
<!-- FSceneRenderer_ComputeViewVisibility&#45;&gt;FSceneRenderer_SetupMeshPass -->
<g id="edge66" class="edge"><title>FSceneRenderer_ComputeViewVisibility&#45;&gt;FSceneRenderer_SetupMeshPass</title>
<path fill="none" stroke="black" d="M810.227,-583.799C799.64,-571.471 785.218,-554.679 773.376,-540.89"/>
<polygon fill="black" stroke="black" points="775.921,-538.481 766.751,-533.175 770.611,-543.042 775.921,-538.481"/>
<text text-anchor="start" x="793" y="-554.8" font-family="Times New Roman,serif" font-size="14.00">For each view</text>
</g>
<!-- FSceneRenderer_ComputeViewVisibility&#45;&gt;FMobileSceneRenderer_SetupMobileBasePassAfterShadowInit -->
<!-- FParallelMeshDrawCommandPass_DispatchPassSetup_OtherPass -->
<g id="node52" class="node"><title>FParallelMeshDrawCommandPass_DispatchPassSetup_OtherPass</title>
<polygon fill="lightblue" stroke="lightblue" points="867.5,-446 534.5,-446 534.5,-410 867.5,-410 867.5,-446"/>
<text text-anchor="start" x="542.5" y="-424.3" font-family="Times New Roman,serif" font-size="14.00">FParallelMeshDrawCommandPass::DispatchPassSetup()</text>
</g>
<!-- FSceneRenderer_SetupMeshPass&#45;&gt;FParallelMeshDrawCommandPass_DispatchPassSetup_OtherPass -->
<g id="edge67" class="edge"><title>FSceneRenderer_SetupMeshPass&#45;&gt;FParallelMeshDrawCommandPass_DispatchPassSetup_OtherPass</title>
<path fill="none" stroke="black" d="M741.679,-496.799C734.49,-484.817 724.77,-468.617 716.634,-455.057"/>
<polygon fill="black" stroke="black" points="719.451,-452.95 711.305,-446.175 713.449,-456.551 719.451,-452.95"/>
</g>
<!-- FParallelMeshDrawCommandPass_DispatchPassSetup_BasePass -->
<g id="node51" class="node"><title>FParallelMeshDrawCommandPass_DispatchPassSetup_BasePass</title>
<polygon fill="lightblue" stroke="lightblue" points="1340.5,-533 1007.5,-533 1007.5,-497 1340.5,-497 1340.5,-533"/>
<text text-anchor="start" x="1015.5" y="-511.3" font-family="Times New Roman,serif" font-size="14.00">FParallelMeshDrawCommandPass::DispatchPassSetup()</text>
</g>
<!-- FMobileSceneRenderer_SetupMobileBasePassAfterShadowInit&#45;&gt;FParallelMeshDrawCommandPass_DispatchPassSetup_BasePass -->
<g id="edge69" class="edge"><title>FMobileSceneRenderer_SetupMobileBasePassAfterShadowInit&#45;&gt;FParallelMeshDrawCommandPass_DispatchPassSetup_BasePass</title>
<path fill="none" stroke="black" d="M1177.19,-583.799C1176.64,-572.163 1175.91,-556.548 1175.28,-543.237"/>
<polygon fill="black" stroke="black" points="1178.77,-543 1174.81,-533.175 1171.78,-543.329 1178.77,-543"/>
<text text-anchor="start" x="1177" y="-554.8" font-family="Times New Roman,serif" font-size="14.00">For each view</text>
</g>
<!-- FMeshDrawCommandPassSetupTask_AnyThreadTask_OtherPass -->
<g id="node41" class="node"><title>FMeshDrawCommandPassSetupTask_AnyThreadTask_OtherPass</title>
<polygon fill="orange" stroke="orange" points="918,-344 458,-344 458,-294 918,-294 918,-344"/>
<text text-anchor="start" x="528" y="-329.8" font-family="Times New Roman,serif" font-size="14.00">FMeshDrawCommandPassSetupTask::AnyThreadTask()</text>
<text text-anchor="start" x="466" y="-315.8" font-family="Times New Roman,serif" font-size="14.00">for PassType=CSMShadowDepth, TranslucencyStandard, TranslucencyAll, ...</text>
<text text-anchor="start" x="476" y="-301.8" font-family="Times New Roman,serif" font-weight="bold" font-size="14.00" fill="red">generate dynamic commands, sort&#45;and&#45;merge FULL draw commands</text>
</g>
<!-- FMeshDrawCommandPassSetupTask_AnyThreadTask_BasePass -->
<g id="node42" class="node"><title>FMeshDrawCommandPassSetupTask_AnyThreadTask_BasePass</title>
<polygon fill="orange" stroke="orange" points="1394,-344 954,-344 954,-294 1394,-294 1394,-344"/>
<text text-anchor="start" x="1014" y="-329.8" font-family="Times New Roman,serif" font-size="14.00">FMeshDrawCommandPassSetupTask::AnyThreadTask()</text>
<text text-anchor="start" x="1105" y="-315.8" font-family="Times New Roman,serif" font-size="14.00">for PassType=BasePass</text>
<text text-anchor="start" x="962" y="-301.8" font-family="Times New Roman,serif" font-weight="bold" font-size="14.00" fill="red">generate dynamic commands, sort&#45;and&#45;merge FULL draw commands</text>
</g>
<!-- FMeshDrawCommandPassSetupTask_AnyThreadTask_OtherPass&#45;&gt;FMeshDrawCommandPassSetupTask_AnyThreadTask_BasePass -->
<!-- FMobileBasePassMeshProcessor_AddMeshBatch_TaskThread -->
<g id="node63" class="node"><title>FMobileBasePassMeshProcessor_AddMeshBatch_TaskThread</title>
<polygon fill="orange" stroke="orange" points="928,-257 620,-257 620,-221 928,-221 928,-257"/>
<text text-anchor="start" x="628" y="-235.3" font-family="Times New Roman,serif" font-size="14.00">FMobileBasePassMeshProcessor::AddMeshBatch()</text>
</g>
<!-- FMeshDrawCommandPassSetupTask_AnyThreadTask_OtherPass&#45;&gt;FMobileBasePassMeshProcessor_AddMeshBatch_TaskThread -->
<g id="edge73" class="edge"><title>FMeshDrawCommandPassSetupTask_AnyThreadTask_OtherPass&#45;&gt;FMobileBasePassMeshProcessor_AddMeshBatch_TaskThread</title>
<path fill="none" stroke="black" d="M714.74,-293.748C725.191,-284.268 737.146,-273.426 747.568,-263.973"/>
<polygon fill="black" stroke="black" points="750.133,-266.372 755.188,-257.062 745.43,-261.187 750.133,-266.372"/>
</g>
<!-- FMeshDrawCommandPassSetupTask_AnyThreadTask_BasePass&#45;&gt;FMobileBasePassMeshProcessor_AddMeshBatch_TaskThread -->
<g id="edge72" class="edge"><title>FMeshDrawCommandPassSetupTask_AnyThreadTask_BasePass&#45;&gt;FMobileBasePassMeshProcessor_AddMeshBatch_TaskThread</title>
<path fill="none" stroke="black" d="M1050.72,-293.961C993.024,-282.71 925.284,-269.5 871.268,-258.967"/>
<polygon fill="black" stroke="black" points="871.832,-255.511 861.347,-257.033 870.492,-262.382 871.832,-255.511"/>
</g>
<!-- FSceneRenderer_RenderShadowDepthMaps&#45;&gt;FMobileSceneRenderer_RenderPrePass -->
<!-- FParallelMeshDrawCommandPass_DispatchDraw_RenderThread_WillTaskThread -->
<g id="node54" class="node"><title>FParallelMeshDrawCommandPass_DispatchDraw_RenderThread_WillTaskThread</title>
<polygon fill="lightblue" stroke="lightblue" points="1663.5,-533 1358.5,-533 1358.5,-497 1663.5,-497 1663.5,-533"/>
<text text-anchor="start" x="1366.5" y="-511.3" font-family="Times New Roman,serif" font-size="14.00">FParallelMeshDrawCommandPass::DispatchDraw()</text>
</g>
<!-- FSceneRenderer_RenderShadowDepthMaps&#45;&gt;FParallelMeshDrawCommandPass_DispatchDraw_RenderThread_WillTaskThread -->
<g id="edge83" class="edge"><title>FSceneRenderer_RenderShadowDepthMaps&#45;&gt;FParallelMeshDrawCommandPass_DispatchDraw_RenderThread_WillTaskThread</title>
<path fill="none" stroke="black" stroke-dasharray="5,2" d="M1419.53,-666.205C1437.47,-636.741 1474.07,-576.651 1495.12,-542.071"/>
<polygon fill="black" stroke="black" points="1498.16,-543.813 1500.37,-533.451 1492.18,-540.172 1498.16,-543.813"/>
</g>
<!-- FMobileSceneRenderer_RenderPrePass&#45;&gt;FMobileSceneRenderer_RenderAmbientOcclusion -->
<!-- FParallelMeshDrawCommandPass_DispatchDraw -->
<g id="node53" class="node"><title>FParallelMeshDrawCommandPass_DispatchDraw</title>
<polygon fill="lightblue" stroke="lightblue" points="2004.5,-533 1699.5,-533 1699.5,-497 2004.5,-497 2004.5,-533"/>
<text text-anchor="start" x="1707.5" y="-511.3" font-family="Times New Roman,serif" font-size="14.00">FParallelMeshDrawCommandPass::DispatchDraw()</text>
</g>
<!-- FMobileSceneRenderer_RenderPrePass&#45;&gt;FParallelMeshDrawCommandPass_DispatchDraw -->
<g id="edge84" class="edge"><title>FMobileSceneRenderer_RenderPrePass&#45;&gt;FParallelMeshDrawCommandPass_DispatchDraw</title>
<path fill="none" stroke="black" d="M1560.32,-666.468C1588.41,-638.163 1648.89,-581.54 1711,-551 1723.02,-545.089 1736.12,-540.124 1749.34,-535.968"/>
<polygon fill="black" stroke="black" points="1750.39,-539.305 1758.97,-533.082 1748.39,-532.6 1750.39,-539.305"/>
</g>
<!-- FMobileSceneRenderer_RenderAmbientOcclusion&#45;&gt;FMobileSceneRenderer_RenderForward -->
<!-- FMobileSceneRenderer_RenderAmbientOcclusion&#45;&gt;FParallelMeshDrawCommandPass_DispatchDraw -->
<g id="edge85" class="edge"><title>FMobileSceneRenderer_RenderAmbientOcclusion&#45;&gt;FParallelMeshDrawCommandPass_DispatchDraw</title>
<path fill="none" stroke="black" d="M1674.7,-666.393C1673.99,-644.837 1675.98,-607.745 1695,-584 1712.7,-561.907 1738.97,-546.84 1764.99,-536.629"/>
<polygon fill="black" stroke="black" points="1766.39,-539.843 1774.55,-533.082 1763.96,-533.28 1766.39,-539.843"/>
</g>
<!-- FMobileSceneRenderer_RenderForward&#45;&gt;FPostProcessing_ProcessES2 -->
<!-- FMobileSceneRenderer_RenderMobileBasePass -->
<g id="node48" class="node"><title>FMobileSceneRenderer_RenderMobileBasePass</title>
<polygon fill="lightblue" stroke="lightblue" points="2000,-620 1704,-620 1704,-584 2000,-584 2000,-620"/>
<text text-anchor="start" x="1712" y="-598.3" font-family="Times New Roman,serif" font-size="14.00">FMobileSceneRenderer::RenderMobileBasePass()</text>
</g>
<!-- FMobileSceneRenderer_RenderForward&#45;&gt;FMobileSceneRenderer_RenderMobileBasePass -->
<g id="edge79" class="edge"><title>FMobileSceneRenderer_RenderForward&#45;&gt;FMobileSceneRenderer_RenderMobileBasePass</title>
<path fill="none" stroke="black" d="M1886.67,-666.428C1880.72,-655.542 1872.89,-641.224 1866.18,-628.947"/>
<polygon fill="black" stroke="black" points="1869.19,-627.143 1861.32,-620.047 1863.04,-630.501 1869.19,-627.143"/>
</g>
<!-- FMobileSceneRenderer_RenderTranslucency -->
<g id="node49" class="node"><title>FMobileSceneRenderer_RenderTranslucency</title>
<polygon fill="none" stroke="lightblue" points="2314.5,-620 2035.5,-620 2035.5,-584 2314.5,-584 2314.5,-620"/>
<text text-anchor="start" x="2043.5" y="-598.3" font-family="Times New Roman,serif" font-size="14.00">FMobileSceneRenderer::RenderTranslucency()</text>
</g>
<!-- FMobileSceneRenderer_RenderForward&#45;&gt;FMobileSceneRenderer_RenderTranslucency -->
<g id="edge80" class="edge"><title>FMobileSceneRenderer_RenderForward&#45;&gt;FMobileSceneRenderer_RenderTranslucency</title>
<path fill="none" stroke="black" d="M1955.17,-666.428C1999.37,-653.674 2059.9,-636.21 2106.25,-622.836"/>
<polygon fill="black" stroke="black" points="2107.28,-626.182 2115.92,-620.047 2105.34,-619.457 2107.28,-626.182"/>
</g>
<!-- FMobileSceneRenderer_RenderMobileBasePass&#45;&gt;FMobileSceneRenderer_RenderTranslucency -->
<!-- FMobileSceneRenderer_RenderMobileBasePass&#45;&gt;FParallelMeshDrawCommandPass_DispatchDraw -->
<g id="edge82" class="edge"><title>FMobileSceneRenderer_RenderMobileBasePass&#45;&gt;FParallelMeshDrawCommandPass_DispatchDraw</title>
<path fill="none" stroke="black" d="M1852,-583.799C1852,-572.163 1852,-556.548 1852,-543.237"/>
<polygon fill="black" stroke="black" points="1855.5,-543.175 1852,-533.175 1848.5,-543.175 1855.5,-543.175"/>
</g>
<!-- FMobileBasePassMeshProcessor_AddMeshBatch -->
<g id="node58" class="node"><title>FMobileBasePassMeshProcessor_AddMeshBatch</title>
<polygon fill="lightblue" stroke="lightblue" points="584,-257 276,-257 276,-221 584,-221 584,-257"/>
<text text-anchor="start" x="284" y="-235.3" font-family="Times New Roman,serif" font-size="14.00">FMobileBasePassMeshProcessor::AddMeshBatch()</text>
</g>
<!-- FPrimitiveSceneInfo_AddToScene&#45;&gt;FMobileBasePassMeshProcessor_AddMeshBatch -->
<g id="edge57" class="edge"><title>FPrimitiveSceneInfo_AddToScene&#45;&gt;FMobileBasePassMeshProcessor_AddMeshBatch</title>
<path fill="none" stroke="black" d="M470.532,-583.909C452.267,-568.454 430,-543.893 430,-516 430,-516 430,-516 430,-318 430,-301.11 430,-282.163 430,-267.172"/>
<polygon fill="black" stroke="black" points="433.5,-267.042 430,-257.042 426.5,-267.042 433.5,-267.042"/>
</g>
<!-- FParallelMeshDrawCommandPass_DispatchPassSetup_BasePass&#45;&gt;FMeshDrawCommandPassSetupTask_AnyThreadTask_BasePass -->
<g id="edge70" class="edge"><title>FParallelMeshDrawCommandPass_DispatchPassSetup_BasePass&#45;&gt;FMeshDrawCommandPassSetupTask_AnyThreadTask_BasePass</title>
<path fill="none" stroke="black" d="M1172,-496.784C1172,-464.879 1172,-396.026 1172,-354.288"/>
<path fill="none" stroke="none" d="M1174,-496.784C1174,-464.879 1174,-396.026 1174,-354.288"/>
<path fill="none" stroke="black" d="M1176,-496.784C1176,-464.879 1176,-396.026 1176,-354.288"/>
<polygon fill="black" stroke="black" points="1177.5,-354.047 1174,-344.047 1170.5,-354.047 1177.5,-354.047"/>
<text text-anchor="start" x="1248" y="-431.8" font-family="Times New Roman,serif" font-size="14.00">For base pass</text>
<text text-anchor="start" x="1174" y="-416.8" font-family="Times New Roman,serif" font-size="14.00">Render thread dispatches to Task thread</text>
</g>
<!-- FParallelMeshDrawCommandPass_DispatchPassSetup_OtherPass&#45;&gt;FMeshDrawCommandPassSetupTask_AnyThreadTask_OtherPass -->
<g id="edge68" class="edge"><title>FParallelMeshDrawCommandPass_DispatchPassSetup_OtherPass&#45;&gt;FMeshDrawCommandPassSetupTask_AnyThreadTask_OtherPass</title>
<path fill="none" stroke="black" d="M692.955,-410.532C691.147,-395.648 688.476,-373.665 686.229,-355.174"/>
<path fill="none" stroke="none" d="M694.941,-410.291C693.132,-395.407 690.461,-373.424 688.215,-354.933"/>
<path fill="none" stroke="black" d="M696.926,-410.05C695.118,-395.166 692.447,-373.182 690.2,-354.691"/>
<path fill="none" stroke="none" d="M698.911,-409.809C697.103,-394.924 694.432,-372.941 692.186,-354.45"/>
<path fill="none" stroke="black" d="M700.897,-409.567C699.088,-394.683 696.418,-372.7 694.171,-354.209"/>
<path fill="none" stroke="none" d="M702.882,-409.326C701.074,-394.442 698.403,-372.459 696.156,-353.968"/>
<path fill="none" stroke="black" d="M704.868,-409.085C703.059,-394.201 700.388,-372.218 698.142,-353.727"/>
<polygon fill="black" stroke="black" points="695.636,-353.831 690.955,-344.326 688.687,-354.675 695.636,-353.831"/>
<text text-anchor="start" x="698" y="-380.8" font-family="Times New Roman,serif" font-size="14.00">For each render pass, except base pass,</text>
<text text-anchor="start" x="697" y="-365.8" font-family="Times New Roman,serif" font-size="14.00">Render thread dispatches to Task thread</text>
</g>
<!-- SubmitMeshDrawCommandsRange_RenderThread -->
<g id="node55" class="node"><title>SubmitMeshDrawCommandsRange_RenderThread</title>
<polygon fill="lightblue" stroke="lightblue" points="2478.5,-337 1963.5,-337 1963.5,-301 2478.5,-301 2478.5,-337"/>
<text text-anchor="start" x="2120.5" y="-322.8" font-family="Times New Roman,serif" font-size="14.00">SubmitMeshDrawCommandsRange</text>
<text text-anchor="start" x="1971.5" y="-308.8" font-family="Times New Roman,serif" font-weight="bold" font-size="14.00" fill="red">submits a SUBSET of previously sorted&#45;and&#45;merged FULL mesh draw commands</text>
</g>
<!-- FParallelMeshDrawCommandPass_DispatchDraw&#45;&gt;SubmitMeshDrawCommandsRange_RenderThread -->
<g id="edge87" class="edge"><title>FParallelMeshDrawCommandPass_DispatchDraw&#45;&gt;SubmitMeshDrawCommandsRange_RenderThread</title>
<path fill="none" stroke="black" d="M1884.42,-496.954C1951.46,-461.708 2105.25,-380.857 2179.45,-341.846"/>
<polygon fill="black" stroke="black" points="2181.3,-344.828 2188.52,-337.077 2178.04,-338.632 2181.3,-344.828"/>
</g>
<!-- FParallelMeshDrawCommandPass_DispatchDraw_RenderThread_WillTaskThread&#45;&gt;FParallelMeshDrawCommandPass_DispatchDraw -->
<!-- FDrawVisibleMeshCommandsAnyThreadTask -->
<g id="node57" class="node"><title>FDrawVisibleMeshCommandsAnyThreadTask</title>
<polygon fill="orange" stroke="orange" points="1798.5,-446 1459.5,-446 1459.5,-410 1798.5,-410 1798.5,-446"/>
<text text-anchor="start" x="1467.5" y="-424.3" font-family="Times New Roman,serif" font-size="14.00">FDrawVisibleMeshCommandsAnyThreadTask::DoTask()</text>
</g>
<!-- FParallelMeshDrawCommandPass_DispatchDraw_RenderThread_WillTaskThread&#45;&gt;FDrawVisibleMeshCommandsAnyThreadTask -->
<g id="edge88" class="edge"><title>FParallelMeshDrawCommandPass_DispatchDraw_RenderThread_WillTaskThread&#45;&gt;FDrawVisibleMeshCommandsAnyThreadTask</title>
<path fill="none" stroke="black" d="M1533.71,-495.176C1551.54,-482.33 1576.11,-464.635 1595.67,-450.544"/>
<path fill="none" stroke="none" d="M1534.88,-496.799C1552.71,-483.953 1577.28,-466.258 1596.84,-452.167"/>
<path fill="none" stroke="black" d="M1536.05,-498.422C1553.88,-485.576 1578.45,-467.881 1598.01,-453.79"/>
<polygon fill="black" stroke="black" points="1599.09,-454.86 1605.16,-446.175 1595,-449.18 1599.09,-454.86"/>
<text text-anchor="middle" x="1691.5" y="-467.8" font-family="Times New Roman,serif" font-size="14.00">Render thread dispatches to Task thread</text>
</g>
<!-- FMeshDrawCommand_SubmitDraw_RenderThread -->
<g id="node68" class="node"><title>FMeshDrawCommand_SubmitDraw_RenderThread</title>
<polygon fill="lightblue" stroke="lightblue" points="2351.5,-257 2122.5,-257 2122.5,-221 2351.5,-221 2351.5,-257"/>
<text text-anchor="start" x="2130.5" y="-235.3" font-family="Times New Roman,serif" font-size="14.00">FMeshDrawCommand::SubmitDraw()</text>
</g>
<!-- SubmitMeshDrawCommandsRange_RenderThread&#45;&gt;FMeshDrawCommand_SubmitDraw_RenderThread -->
<g id="edge91" class="edge"><title>SubmitMeshDrawCommandsRange_RenderThread&#45;&gt;FMeshDrawCommand_SubmitDraw_RenderThread</title>
<path fill="none" stroke="black" d="M2224.55,-300.689C2226.56,-290.894 2229.12,-278.422 2231.39,-267.335"/>
<polygon fill="black" stroke="black" points="2234.88,-267.762 2233.46,-257.262 2228.02,-266.355 2234.88,-267.762"/>
</g>
<!-- SubmitMeshDrawCommandsRange_TaskThread -->
<g id="node56" class="node"><title>SubmitMeshDrawCommandsRange_TaskThread</title>
<polygon fill="orange" stroke="orange" points="1927.5,-337 1412.5,-337 1412.5,-301 1927.5,-301 1927.5,-337"/>
<text text-anchor="start" x="1569.5" y="-322.8" font-family="Times New Roman,serif" font-size="14.00">SubmitMeshDrawCommandsRange</text>
<text text-anchor="start" x="1420.5" y="-308.8" font-family="Times New Roman,serif" font-weight="bold" font-size="14.00" fill="red">submits a SUBSET of previously sorted&#45;and&#45;merged FULL mesh draw commands</text>
</g>
<!-- SubmitMeshDrawCommandsRange_TaskThread&#45;&gt;SubmitMeshDrawCommandsRange_RenderThread -->
<!-- FMeshDrawCommand_SubmitDraw_TaskThread -->
<g id="node69" class="node"><title>FMeshDrawCommand_SubmitDraw_TaskThread</title>
<polygon fill="orange" stroke="orange" points="1780.5,-257 1551.5,-257 1551.5,-221 1780.5,-221 1780.5,-257"/>
<text text-anchor="start" x="1559.5" y="-235.3" font-family="Times New Roman,serif" font-size="14.00">FMeshDrawCommand::SubmitDraw()</text>
</g>
<!-- SubmitMeshDrawCommandsRange_TaskThread&#45;&gt;FMeshDrawCommand_SubmitDraw_TaskThread -->
<g id="edge92" class="edge"><title>SubmitMeshDrawCommandsRange_TaskThread&#45;&gt;FMeshDrawCommand_SubmitDraw_TaskThread</title>
<path fill="none" stroke="black" d="M1669.11,-300.689C1668.61,-290.894 1667.97,-278.422 1667.4,-267.335"/>
<polygon fill="black" stroke="black" points="1670.89,-267.07 1666.89,-257.262 1663.9,-267.428 1670.89,-267.07"/>
</g>
<!-- FDrawVisibleMeshCommandsAnyThreadTask&#45;&gt;SubmitMeshDrawCommandsRange_TaskThread -->
<g id="edge89" class="edge"><title>FDrawVisibleMeshCommandsAnyThreadTask&#45;&gt;SubmitMeshDrawCommandsRange_TaskThread</title>
<path fill="none" stroke="black" d="M1635.59,-409.809C1642.13,-392.727 1652.26,-366.296 1659.84,-346.523"/>
<polygon fill="black" stroke="black" points="1663.12,-347.739 1663.43,-337.149 1656.58,-345.234 1663.12,-347.739"/>
</g>
<!-- FMobileBasePassMeshProcessor_Process -->
<g id="node59" class="node"><title>FMobileBasePassMeshProcessor_Process</title>
<polygon fill="lightblue" stroke="lightblue" points="562.5,-183 297.5,-183 297.5,-147 562.5,-147 562.5,-183"/>
<text text-anchor="start" x="305.5" y="-161.3" font-family="Times New Roman,serif" font-size="14.00">FMobileBasePassMeshProcessor::Process()</text>
</g>
<!-- FMobileBasePassMeshProcessor_AddMeshBatch&#45;&gt;FMobileBasePassMeshProcessor_Process -->
<g id="edge58" class="edge"><title>FMobileBasePassMeshProcessor_AddMeshBatch&#45;&gt;FMobileBasePassMeshProcessor_Process</title>
<path fill="none" stroke="black" d="M430,-220.937C430,-212.807 430,-202.876 430,-193.705"/>
<polygon fill="black" stroke="black" points="433.5,-193.441 430,-183.441 426.5,-193.441 433.5,-193.441"/>
</g>
<!-- FMobileBasePassMeshProcessor_AddMeshBatch&#45;&gt;FMobileBasePassMeshProcessor_AddMeshBatch_TaskThread -->
<!-- FMeshPassProcessor_BuildMeshDrawCommands -->
<g id="node60" class="node"><title>FMeshPassProcessor_BuildMeshDrawCommands</title>
<polygon fill="lightblue" stroke="lightblue" points="584,-109 276,-109 276,-73 584,-73 584,-109"/>
<text text-anchor="start" x="284" y="-87.3" font-family="Times New Roman,serif" font-size="14.00">FMeshPassProcessor::BuildMeshDrawCommands()</text>
</g>
<!-- FMobileBasePassMeshProcessor_Process&#45;&gt;FMeshPassProcessor_BuildMeshDrawCommands -->
<g id="edge59" class="edge"><title>FMobileBasePassMeshProcessor_Process&#45;&gt;FMeshPassProcessor_BuildMeshDrawCommands</title>
<path fill="none" stroke="black" d="M430,-146.937C430,-138.807 430,-128.876 430,-119.705"/>
<polygon fill="black" stroke="black" points="433.5,-119.441 430,-109.441 426.5,-119.441 433.5,-119.441"/>
</g>
<!-- FMeshMaterialShader_GetElementShaderBindings -->
<g id="node61" class="node"><title>FMeshMaterialShader_GetElementShaderBindings</title>
<polygon fill="none" stroke="lightblue" points="306,-36 0,-36 0,-0 306,-0 306,-36"/>
<text text-anchor="start" x="8" y="-14.3" font-family="Times New Roman,serif" font-size="14.00">FMeshMaterialShader::GetElementShaderBindings()</text>
</g>
<!-- FMeshPassProcessor_BuildMeshDrawCommands&#45;&gt;FMeshMaterialShader_GetElementShaderBindings -->
<g id="edge60" class="edge"><title>FMeshPassProcessor_BuildMeshDrawCommands&#45;&gt;FMeshMaterialShader_GetElementShaderBindings</title>
<path fill="none" stroke="black" d="M363.652,-72.9937C323.348,-62.6632 271.734,-49.4337 229.685,-38.6557"/>
<polygon fill="black" stroke="black" points="230.323,-35.2062 219.767,-36.1136 228.585,-41.987 230.323,-35.2062"/>
</g>
<!-- FMeshDrawCommand_SetShaders -->
<g id="node62" class="node"><title>FMeshDrawCommand_SetShaders</title>
<polygon fill="none" stroke="lightblue" points="564,-36 342,-36 342,-0 564,-0 564,-36"/>
<text text-anchor="start" x="350" y="-14.3" font-family="Times New Roman,serif" font-size="14.00">FMeshDrawCommand::SetShaders()</text>
</g>
<!-- FMeshPassProcessor_BuildMeshDrawCommands&#45;&gt;FMeshDrawCommand_SetShaders -->
<g id="edge61" class="edge"><title>FMeshPassProcessor_BuildMeshDrawCommands&#45;&gt;FMeshDrawCommand_SetShaders</title>
<path fill="none" stroke="black" d="M435.568,-72.8129C438.195,-64.7023 441.391,-54.8355 444.326,-45.7766"/>
<polygon fill="black" stroke="black" points="447.731,-46.6208 447.484,-36.0288 441.072,-44.4635 447.731,-46.6208"/>
</g>
<!-- FMeshMaterialShader_GetElementShaderBindings&#45;&gt;FMeshDrawCommand_SetShaders -->
<!-- FMobileBasePassMeshProcessor_Process_TaskThread -->
<g id="node64" class="node"><title>FMobileBasePassMeshProcessor_Process_TaskThread</title>
<polygon fill="orange" stroke="orange" points="906.5,-183 641.5,-183 641.5,-147 906.5,-147 906.5,-183"/>
<text text-anchor="start" x="649.5" y="-161.3" font-family="Times New Roman,serif" font-size="14.00">FMobileBasePassMeshProcessor::Process()</text>
</g>
<!-- FMobileBasePassMeshProcessor_AddMeshBatch_TaskThread&#45;&gt;FMobileBasePassMeshProcessor_Process_TaskThread -->
<g id="edge74" class="edge"><title>FMobileBasePassMeshProcessor_AddMeshBatch_TaskThread&#45;&gt;FMobileBasePassMeshProcessor_Process_TaskThread</title>
<path fill="none" stroke="black" d="M774,-220.937C774,-212.807 774,-202.876 774,-193.705"/>
<polygon fill="black" stroke="black" points="777.5,-193.441 774,-183.441 770.5,-193.441 777.5,-193.441"/>
</g>
<!-- FMeshPassProcessor_BuildMeshDrawCommands_TaskThread -->
<g id="node65" class="node"><title>FMeshPassProcessor_BuildMeshDrawCommands_TaskThread</title>
<polygon fill="orange" stroke="orange" points="928,-109 620,-109 620,-73 928,-73 928,-109"/>
<text text-anchor="start" x="628" y="-87.3" font-family="Times New Roman,serif" font-size="14.00">FMeshPassProcessor::BuildMeshDrawCommands()</text>
</g>
<!-- FMobileBasePassMeshProcessor_Process_TaskThread&#45;&gt;FMeshPassProcessor_BuildMeshDrawCommands_TaskThread -->
<g id="edge75" class="edge"><title>FMobileBasePassMeshProcessor_Process_TaskThread&#45;&gt;FMeshPassProcessor_BuildMeshDrawCommands_TaskThread</title>
<path fill="none" stroke="black" d="M774,-146.937C774,-138.807 774,-128.876 774,-119.705"/>
<polygon fill="black" stroke="black" points="777.5,-119.441 774,-109.441 770.5,-119.441 777.5,-119.441"/>
</g>
<!-- FMeshMaterialShader_GetElementShaderBindings_TaskThread -->
<g id="node66" class="node"><title>FMeshMaterialShader_GetElementShaderBindings_TaskThread</title>
<polygon fill="none" stroke="orange" points="896,-36 590,-36 590,-0 896,-0 896,-36"/>
<text text-anchor="start" x="598" y="-14.3" font-family="Times New Roman,serif" font-size="14.00">FMeshMaterialShader::GetElementShaderBindings()</text>
</g>
<!-- FMeshPassProcessor_BuildMeshDrawCommands_TaskThread&#45;&gt;FMeshMaterialShader_GetElementShaderBindings_TaskThread -->
<g id="edge76" class="edge"><title>FMeshPassProcessor_BuildMeshDrawCommands_TaskThread&#45;&gt;FMeshMaterialShader_GetElementShaderBindings_TaskThread</title>
<path fill="none" stroke="black" d="M766.496,-72.8129C762.916,-64.6151 758.554,-54.6231 754.564,-45.4847"/>
<polygon fill="black" stroke="black" points="757.644,-43.7929 750.435,-36.0288 751.229,-46.5939 757.644,-43.7929"/>
</g>
<!-- FMeshDrawCommand_SetShaders_TaskThread -->
<g id="node67" class="node"><title>FMeshDrawCommand_SetShaders_TaskThread</title>
<polygon fill="none" stroke="orange" points="1136,-36 914,-36 914,-0 1136,-0 1136,-36"/>
<text text-anchor="start" x="922" y="-14.3" font-family="Times New Roman,serif" font-size="14.00">FMeshDrawCommand::SetShaders()</text>
</g>
<!-- FMeshPassProcessor_BuildMeshDrawCommands_TaskThread&#45;&gt;FMeshDrawCommand_SetShaders_TaskThread -->
<g id="edge77" class="edge"><title>FMeshPassProcessor_BuildMeshDrawCommands_TaskThread&#45;&gt;FMeshDrawCommand_SetShaders_TaskThread</title>
<path fill="none" stroke="black" d="M834.121,-72.9937C870.333,-62.7503 916.622,-49.6568 954.546,-38.9291"/>
<polygon fill="black" stroke="black" points="955.83,-42.2034 964.5,-36.1136 953.925,-35.4677 955.83,-42.2034"/>
</g>
<!-- FRHICommandList_SetGraphicsPipelineState -->
<g id="node71" class="node"><title>FRHICommandList_SetGraphicsPipelineState</title>
<polygon fill="none" stroke="lightblue" points="2082,-183 1798,-183 1798,-147 2082,-147 2082,-183"/>
<text text-anchor="start" x="1806" y="-161.3" font-family="Times New Roman,serif" font-size="14.00">FRHICommandList::SetGraphicsPipelineState()</text>
</g>
<!-- FMeshDrawCommand_SubmitDraw_RenderThread&#45;&gt;FRHICommandList_SetGraphicsPipelineState -->
<g id="edge94" class="edge"><title>FMeshDrawCommand_SubmitDraw_RenderThread&#45;&gt;FRHICommandList_SetGraphicsPipelineState</title>
<path fill="none" stroke="black" d="M2166.62,-220.937C2122.59,-210.264 2065.75,-196.485 2020.02,-185.398"/>
<polygon fill="black" stroke="black" points="2020.68,-181.957 2010.14,-183.003 2019.03,-188.76 2020.68,-181.957"/>
</g>
<!-- FRHICommandList_SetStreamSource -->
<g id="node72" class="node"><title>FRHICommandList_SetStreamSource</title>
<polygon fill="none" stroke="lightblue" points="2358,-183 2118,-183 2118,-147 2358,-147 2358,-183"/>
<text text-anchor="start" x="2126" y="-161.3" font-family="Times New Roman,serif" font-size="14.00">FRHICommandList::SetStreamSource()</text>
</g>
<!-- FMeshDrawCommand_SubmitDraw_RenderThread&#45;&gt;FRHICommandList_SetStreamSource -->
<g id="edge95" class="edge"><title>FMeshDrawCommand_SubmitDraw_RenderThread&#45;&gt;FRHICommandList_SetStreamSource</title>
<path fill="none" stroke="black" d="M2237.24,-220.937C2237.35,-212.807 2237.49,-202.876 2237.62,-193.705"/>
<polygon fill="black" stroke="black" points="2241.12,-193.488 2237.76,-183.441 2234.12,-193.391 2241.12,-193.488"/>
</g>
<!-- FRHICommandList_DrawIndexedPrimitive -->
<g id="node73" class="node"><title>FRHICommandList_DrawIndexedPrimitive</title>
<polygon fill="none" stroke="lightblue" points="2660.5,-183 2393.5,-183 2393.5,-147 2660.5,-147 2660.5,-183"/>
<text text-anchor="start" x="2401.5" y="-161.3" font-family="Times New Roman,serif" font-size="14.00">FRHICommandList::DrawIndexedPrimitive()</text>
</g>
<!-- FMeshDrawCommand_SubmitDraw_RenderThread&#45;&gt;FRHICommandList_DrawIndexedPrimitive -->
<g id="edge96" class="edge"><title>FMeshDrawCommand_SubmitDraw_RenderThread&#45;&gt;FRHICommandList_DrawIndexedPrimitive</title>
<path fill="none" stroke="black" d="M2305.73,-220.937C2348.63,-210.286 2403.98,-196.543 2448.59,-185.468"/>
<polygon fill="black" stroke="black" points="2449.65,-188.809 2458.52,-183.003 2447.97,-182.016 2449.65,-188.809"/>
</g>
<!-- FMeshDrawCommand_SubmitDraw_TaskThread_Subsequent -->
<!-- FMeshDrawCommand_SubmitDraw_TaskThread&#45;&gt;FMeshDrawCommand_SubmitDraw_TaskThread_Subsequent -->
<g id="edge93" class="edge"><title>FMeshDrawCommand_SubmitDraw_TaskThread&#45;&gt;FMeshDrawCommand_SubmitDraw_TaskThread_Subsequent</title>
<path fill="none" stroke="black" stroke-dasharray="5,2" d="M1665.76,-220.937C1665.65,-212.987 1665.52,-203.313 1665.39,-194.313"/>
<polygon fill="black" stroke="black" points="1668.89,-194.15 1665.25,-184.199 1661.89,-194.247 1668.89,-194.15"/>
</g>
<!-- FRHICommandList_SetGraphicsPipelineState&#45;&gt;FRHICommandList_SetStreamSource -->
<!-- FRHICommandList_SetStreamSource&#45;&gt;FRHICommandList_DrawIndexedPrimitive -->
<!-- FMetalStateCache_CommitResourceTable -->
<g id="node74" class="node"><title>FMetalStateCache_CommitResourceTable</title>
<polygon fill="none" stroke="lightblue" points="2658.5,-109 2395.5,-109 2395.5,-73 2658.5,-73 2658.5,-109"/>
<text text-anchor="start" x="2403.5" y="-87.3" font-family="Times New Roman,serif" font-size="14.00">FMetalStateCache::CommitResourceTable()</text>
</g>
<!-- FRHICommandList_DrawIndexedPrimitive&#45;&gt;FMetalStateCache_CommitResourceTable -->
<g id="edge99" class="edge"><title>FRHICommandList_DrawIndexedPrimitive&#45;&gt;FMetalStateCache_CommitResourceTable</title>
<path fill="none" stroke="black" stroke-dasharray="5,2" d="M2527,-146.937C2527,-138.807 2527,-128.876 2527,-119.705"/>
<polygon fill="black" stroke="black" points="2530.5,-119.441 2527,-109.441 2523.5,-119.441 2530.5,-119.441"/>
</g>
<!-- FMetalCommandEncoder_SetShaderBuffer -->
<g id="node75" class="node"><title>FMetalCommandEncoder_SetShaderBuffer</title>
<polygon fill="none" stroke="lightblue" points="2515.5,-36 2246.5,-36 2246.5,-0 2515.5,-0 2515.5,-36"/>
<text text-anchor="start" x="2254.5" y="-14.3" font-family="Times New Roman,serif" font-size="14.00">FMetalCommandEncoder::SetShaderBuffer()</text>
</g>
<!-- FMetalStateCache_CommitResourceTable&#45;&gt;FMetalCommandEncoder_SetShaderBuffer -->
<g id="edge100" class="edge"><title>FMetalStateCache_CommitResourceTable&#45;&gt;FMetalCommandEncoder_SetShaderBuffer</title>
<path fill="none" stroke="black" d="M2492.03,-72.9937C2472.04,-63.2734 2446.78,-50.9866 2425.4,-40.5903"/>
<polygon fill="black" stroke="black" points="2426.71,-37.3394 2416.19,-36.1136 2423.65,-43.6345 2426.71,-37.3394"/>
</g>
<!-- FMetalCommandEncoder_SetShaderTexture -->
<g id="node76" class="node"><title>FMetalCommandEncoder_SetShaderTexture</title>
<polygon fill="none" stroke="lightblue" points="2810,-36 2534,-36 2534,-0 2810,-0 2810,-36"/>
<text text-anchor="start" x="2542" y="-14.3" font-family="Times New Roman,serif" font-size="14.00">FMetalCommandEncoder::SetShaderTexture()</text>
</g>
<!-- FMetalStateCache_CommitResourceTable&#45;&gt;FMetalCommandEncoder_SetShaderTexture -->
<g id="edge101" class="edge"><title>FMetalStateCache_CommitResourceTable&#45;&gt;FMetalCommandEncoder_SetShaderTexture</title>
<path fill="none" stroke="black" d="M2561.73,-72.9937C2581.58,-63.2734 2606.68,-50.9866 2627.91,-40.5903"/>
<polygon fill="black" stroke="black" points="2629.61,-43.6547 2637.05,-36.1136 2626.53,-37.3679 2629.61,-43.6547"/>
</g>
</g>
</svg>

```

`main/gameplay.md`:

```md


# [WIP] Unreal Source Explained

Unreal Source Explained (USE) is an Unreal source code analysis, based on profilers.  
For full Table of Contents and more infomation, see the [repo](https://github.com/donaldwuid/unreal_source_explained) in github.



# Gameplay

```

`main/initialization.md`:

```md


# [WIP] Unreal Source Explained

Unreal Source Explained (USE) is an Unreal source code analysis, based on profilers.  
For full Table of Contents and more infomation, see the [repo](https://github.com/donaldwuid/unreal_source_explained) in github.


# Initialization

<!-- TODO: Change this to life-cycle and include both Initialization and Finalization -->

##  Engine Initialization Overview
![](assets/engine_init.png)

As you can see in the image above, Unreal is initialized by two main steps: `FEngineLoop::PreInit()`([link](https://github.com/EpicGames/UnrealEngine/blob/42cbf957ad0e713dec57a5828f72d116c8083011/Engine/Source/Runtime/Launch/Private/LaunchEngineLoop.cpp#L993)) and `FEngineLoop::Init()`([link](https://github.com/EpicGames/UnrealEngine/blob/42cbf957ad0e713dec57a5828f72d116c8083011/Engine/Source/Runtime/Launch/Private/LaunchEngineLoop.cpp#L3410)). They are called in `FAppEntry::Init()`([link](https://github.com/EpicGames/UnrealEngine/blob/395c9713d5b5eee9daf8b7077bcac311c85a63a1/Engine/Source/Runtime/Launch/Private/IOS/LaunchIOS.cpp#L372)) in iOS, and `AndroidMain()`([link](https://github.com/EpicGames/UnrealEngine/blob/8951e6117b483a89befe98ac2102caad2ce26cab/Engine/Source/Runtime/Launch/Private/Android/LaunchAndroid.cpp#L445)) in Android.

You may think `PreInit()` is the low-level initializaiton and `Init()` is the high-level.

Note in Unreal there are two ways to manage submodules: [*Module*](https://docs.unrealengine.com/en-US/Programming/BuildTools/UnrealBuildTool/ModuleFiles/index.html) and [*Plugins*](https://docs.unrealengine.com/en-US/Programming/Plugins/index.html). Module conatains only code, while Plugin can contain assets and/or Modules.

To name a few things get initialized in `PreInit()`, in order:
- load core module([link](https://github.com/EpicGames/UnrealEngine/blob/42cbf957ad0e713dec57a5828f72d116c8083011/Engine/Source/Runtime/Launch/Private/LaunchEngineLoop.cpp#L1719)): `LoadCoreModules()`([link](https://github.com/EpicGames/UnrealEngine/blob/42cbf957ad0e713dec57a5828f72d116c8083011/Engine/Source/Runtime/Launch/Private/LaunchEngineLoop.cpp#L3122)) for "CoreUObject";
- fundamental modules([link](https://github.com/EpicGames/UnrealEngine/blob/42cbf957ad0e713dec57a5828f72d116c8083011/Engine/Source/Runtime/Launch/Private/LaunchEngineLoop.cpp#L1838)): `LoadPreInitModules()`([link](https://github.com/EpicGames/UnrealEngine/blob/42cbf957ad0e713dec57a5828f72d116c8083011/Engine/Source/Runtime/Launch/Private/LaunchEngineLoop.cpp#L3136)) for "Engine", "Renderer", "AnimGraphRuntime", "Landscape", "RenderCore";
- "application-like" modules([link](https://github.com/EpicGames/UnrealEngine/blob/42cbf957ad0e713dec57a5828f72d116c8083011/Engine/Source/Runtime/Launch/Private/LaunchEngineLoop.cpp#L1861)): `FEngineLoop::AppInit()`([link](https://github.com/EpicGames/UnrealEngine/blob/42cbf957ad0e713dec57a5828f72d116c8083011/Engine/Source/Runtime/Launch/Private/LaunchEngineLoop.cpp#L4635))
	- localization([link](https://github.com/EpicGames/UnrealEngine/blob/42cbf957ad0e713dec57a5828f72d116c8083011/Engine/Source/Runtime/Launch/Private/LaunchEngineLoop.cpp#L4639)): `BeginInitTextLocalization()`([link](https://github.com/EpicGames/UnrealEngine/blob/068ca68f0b37e2c65bf02254c713fd604d4fc211/Engine/Source/Runtime/Core/Private/Internationalization/TextLocalizationManager.cpp#L293))
	- plugins ([link](https://github.com/EpicGames/UnrealEngine/blob/42cbf957ad0e713dec57a5828f72d116c8083011/Engine/Source/Runtime/Launch/Private/LaunchEngineLoop.cpp#L4778)): `FPluginManager::LoadModulesForEnabledPlugins()` ([link](https://github.com/EpicGames/UnrealEngine/blob/c33049fcbde20fb59e44dfc32b25dc610561314c/Engine/Source/Runtime/Projects/Private/PluginManager.cpp#L985));
	- configs ([link](https://github.com/EpicGames/UnrealEngine/blob/42cbf957ad0e713dec57a5828f72d116c8083011/Engine/Source/Runtime/Launch/Private/LaunchEngineLoop.cpp#L4772)): `FConfigCacheIni::InitializeConfigSystem()`([link](https://github.com/EpicGames/UnrealEngine/blob/73fe4c86de84d8e4d98861f5f3793b1dedbc5190/Engine/Source/Runtime/Core/Private/Misc/ConfigCacheIni.cpp#L3409))
- scalability([link](https://github.com/EpicGames/UnrealEngine/blob/42cbf957ad0e713dec57a5828f72d116c8083011/Engine/Source/Runtime/Launch/Private/LaunchEngineLoop.cpp#L1922)): `InitScalabilitySystem()`([link](https://github.com/EpicGames/UnrealEngine/blob/cbfcbbb93b3d40c36067a9e962b01e2e35149ead/Engine/Source/Runtime/Engine/Private/Scalability.cpp#L337)). *[Scalability](https://docs.unrealengine.com/en-US/Engine/Performance/Scalability/ScalabilityReference/index.html)* adjusts the quality of various features in order to maintain the best performance for your game on different platforms and hardware;
- game physics([link](https://github.com/EpicGames/UnrealEngine/blob/42cbf957ad0e713dec57a5828f72d116c8083011/Engine/Source/Runtime/Launch/Private/LaunchEngineLoop.cpp#L2081)): `InitGamePhys()`([link](https://github.com/EpicGames/UnrealEngine/blob/f9b3324b32be95b1fd37235e7b7f2fbb502db285/Engine/Source/Runtime/Engine/Private/PhysicsEngine/PhysLevel.cpp#L274))
- slate application([link](https://github.com/EpicGames/UnrealEngine/blob/42cbf957ad0e713dec57a5828f72d116c8083011/Engine/Source/Runtime/Launch/Private/LaunchEngineLoop.cpp#L2181)): `FSlateApplication::Create()`([link](https://github.com/EpicGames/UnrealEngine/blob/fd945f737de41823c384f819fd0c0f39444288e4/Engine/Source/Runtime/Slate/Private/Framework/Application/SlateApplication.cpp#L911))
- RHI([link](https://github.com/EpicGames/UnrealEngine/blob/42cbf957ad0e713dec57a5828f72d116c8083011/Engine/Source/Runtime/Launch/Private/LaunchEngineLoop.cpp#L2222)): `RHIInit()`([link](https://github.com/EpicGames/UnrealEngine/blob/b8a9b7a193fa1942002ef3d78520d318dd324ed1/Engine/Source/Runtime/RHI/Private/DynamicRHI.cpp#L192))
- global shaders resources([link](https://github.com/EpicGames/UnrealEngine/blob/42cbf957ad0e713dec57a5828f72d116c8083011/Engine/Source/Runtime/Launch/Private/LaunchEngineLoop.cpp#L2291)): `CompileGlobalShaderMap()`([link](https://github.com/EpicGames/UnrealEngine/blob/c8686161530e05e1013572a4c34ccb52ba197057/Engine/Source/Runtime/Engine/Private/ShaderCompiler/ShaderCompiler.cpp#L4327))
- render thread ([link](https://github.com/EpicGames/UnrealEngine/blob/42cbf957ad0e713dec57a5828f72d116c8083011/Engine/Source/Runtime/Launch/Private/LaunchEngineLoop.cpp#L2339)): `StartRenderingThread()`([link](https://github.com/EpicGames/UnrealEngine/blob/b4a54829162aa07a28846da2e91147912a7b67d8/Engine/Source/Runtime/RenderCore/Private/RenderingThread.cpp#L658));
- most `UObject`s' reflection data([link](https://github.com/EpicGames/UnrealEngine/blob/42cbf957ad0e713dec57a5828f72d116c8083011/Engine/Source/Runtime/Launch/Private/LaunchEngineLoop.cpp#L2557)): `ProcessNewlyLoadedUObjects()`([link](https://github.com/EpicGames/UnrealEngine/blob/b4a54829162aa07a28846da2e91147912a7b67d8/Engine/Source/Runtime/CoreUObject/Private/UObject/UObjectBase.cpp#L983));
- start-up modules: ([link](https://github.com/EpicGames/UnrealEngine/blob/42cbf957ad0e713dec57a5828f72d116c8083011/Engine/Source/Runtime/Launch/Private/LaunchEngineLoop.cpp#L2614)): `LoadStartupCoreModules()`([link](https://github.com/EpicGames/UnrealEngine/blob/42cbf957ad0e713dec57a5828f72d116c8083011/Engine/Source/Runtime/Launch/Private/LaunchEngineLoop.cpp#L3185)): "Core", "Networking", "Messaging", "Slate", "UMG";
- load task graph module([link](https://github.com/EpicGames/UnrealEngine/blob/42cbf957ad0e713dec57a5828f72d116c8083011/Engine/Source/Runtime/Launch/Private/LaunchEngineLoop.cpp#L3078));
- engine and game localizaiton([link](https://github.com/EpicGames/UnrealEngine/blob/42cbf957ad0e713dec57a5828f72d116c8083011/Engine/Source/Runtime/Launch/Private/LaunchEngineLoop.cpp#L3093));

and `Init()` initializes these in order:
- Create the high-level game engine objects([link](https://github.com/EpicGames/UnrealEngine/blob/42cbf957ad0e713dec57a5828f72d116c8083011/Engine/Source/Runtime/Launch/Private/LaunchEngineLoop.cpp#L3481)): `UGameEngine::Init()`([link](https://github.com/EpicGames/UnrealEngine/blob/2f53e5141feb2eaaf521f9193b07bd6103d69230/Engine/Source/Runtime/Engine/Private/GameEngine.cpp#L1012))
	- `UEngine::Init()`([link](https://github.com/EpicGames/UnrealEngine/blob/7256ed00bd50ce4c8d099e9e8495d37b0e5130e5/Engine/Source/Runtime/Engine/Private/UnrealEngine.cpp#L1338)), `UEngine` is abstract base class of `UGameEngine` and `UEdtiorEngine`, and is responsible for management of systems critical to editor or game systems.;
	- `UGameUserSettings::LoadSettings()`([link](https://github.com/EpicGames/UnrealEngine/blob/d803c718c982800f1baf27cd141028b4b48ae95b/Engine/Source/Runtime/Engine/Private/GameUserSettings.cpp#L509));
	- `UGameInstance`([link](https://github.com/EpicGames/UnrealEngine/blob/c33049fcbde20fb59e44dfc32b25dc610561314c/Engine/Source/Runtime/Engine/Classes/Engine/GameInstance.h#L119)), `UGameInstance` is high-level manager object for an instance of the running game
		- create `UWorld` in `UGameInstance::InitializeStandalone()`([link](https://github.com/EpicGames/UnrealEngine/blob/252049ac8a00469d7d2044469fe23d931d6aabea/Engine/Source/Runtime/Engine/Private/GameInstance.cpp#L146)), `UWorld` is the top level object representing a map or a sandbox in which Actors and Components will exist and be rendered;
	- `UGameViewportClient` ([link](https://github.com/EpicGames/UnrealEngine/blob/786a4c405633f103fccfaf501e7813f8a7424c68/Engine/Source/Runtime/Engine/Classes/Engine/GameViewportClient.h#L53))
		- create localplayer for the viewport([link](https://github.com/EpicGames/UnrealEngine/blob/2f53e5141feb2eaaf521f9193b07bd6103d69230/Engine/Source/Runtime/Engine/Private/GameEngine.cpp#L1094)): `UGameViewportClient::SetupInitialLocalPlayer()`([link](https://github.com/EpicGames/UnrealEngine/blob/7256ed00bd50ce4c8d099e9e8495d37b0e5130e5/Engine/Source/Runtime/Engine/Private/GameViewportClient.cpp#L2019))
- and start the high level game engine([link](https://github.com/EpicGames/UnrealEngine/blob/42cbf957ad0e713dec57a5828f72d116c8083011/Engine/Source/Runtime/Launch/Private/LaunchEngineLoop.cpp#L3521)): `UGameEngine::Start()`([link](https://github.com/EpicGames/UnrealEngine/blob/2f53e5141feb2eaaf521f9193b07bd6103d69230/Engine/Source/Runtime/Engine/Private/GameEngine.cpp#L1119))



## UObject Initialization

## Archetype and CDO

To manage `UObject`s, Unreal uses `UObjectBase::ObjectFlags`([link](https://github.com/EpicGames/UnrealEngine/blob/bf95c2cbc703123e08ab54e3ceccdd47e48d224a/Engine/Source/Runtime/CoreUObject/Public/UObject/UObjectBase.h#L239)) to record a `UObject` instance's states.

A `UObject` instance is called *Archetype* object if it has `RF_ArchetypeObject` flag, and it's called *Class Default Object (CDO)* if it has `RF_ClassDefaultObject`.


Unreal eventually calls `StaticConstructObject_Internal()`([link](https://github.com/EpicGames/UnrealEngine/blob/bf95c2cbc703123e08ab54e3ceccdd47e48d224a/Engine/Source/Runtime/CoreUObject/Public/UObject/UObjectGlobals.h#L281)) to create every `UObject` instance, no matter it's via user's `NewObject<T>()` call ([link](https://github.com/EpicGames/UnrealEngine/blob/bf95c2cbc703123e08ab54e3ceccdd47e48d224a/Engine/Source/Runtime/CoreUObject/Public/UObject/UObjectGlobals.h#L1238)) or via Unreal's internal call. Here the most important 3 parameters of `StaticConstructObject_Internal()` are its 
- `UClass* Class`: The class of the object to create. The return value of `Class->GetDefaultObject()` is indeed the CDO;
- `UObject* Template`: If specified, the property values from this object will be copied to the new object, and the new object's ObjectArchetype value will be set to this object. If nullptr, the class default object is used instead.
- `EObjectFlags	InFlags`: The ObjectFlags to assign to the new object.

Parameter `Template` has higher priority than the CDO to copy its property value to the new object([link](https://github.com/EpicGames/UnrealEngine/blob/bf95c2cbc703123e08ab54e3ceccdd47e48d224a/Engine/Source/Runtime/CoreUObject/Private/UObject/UObjectGlobals.cpp#L2717)).

```c++
FObjectInitializer::~FObjectInitializer()
{
	//...
	UObject* Defaults = ObjectArchetype ? ObjectArchetype : BaseClass->GetDefaultObject(false);
	InitProperties(Obj, BaseClass, Defaults, bCopyTransientsFromClassDefaults);
	//...
}
```


The new object's flag is set by the `InFlags` argument. **Usually** it doesn't have `RF_ArchetypeObject` nor `RF_ClassDefaultObject` flag, therefore, the new object is just a normal instance.   
However that's not the case when the new object is a new Archetype object or a new CDO.

So what's archetype and CDO anyway, what's their similarity and difference?

![](assets/cdo_archetype.png)

As the above image shows, either an Archetype object, a CDO, or any `UObject` instance can be a **template object** to copy its properties' values into a new object.   

Any `UObject` instance can be a template object, with or without `RF_ArchetypeObject` or `RF_ClassDefaultObject` flag.

Archetype object iteself is initialized from **asset data** (e.g. uasset) in the disk. Its `RF_ArchetypeObject` flag is set when loading the asset in `FLinkerLoad::CreateExport()`([link](https://github.com/EpicGames/UnrealEngine/blob/bc6b9211003ae9e975689bf2b33718f832483a71/Engine/Source/Runtime/CoreUObject/Private/UObject/LinkerLoad.cpp#L4288)):

```c++
UObject* FLinkerLoad::CreateExport( int32 Index )
{
	FObjectExport& Export = ExportMap[ Index ];
	...
	// RF_ArchetypeObject and other flags
	EObjectFlags ObjectLoadFlags = Export.ObjectFlags;
	...
	Export.Object = StaticConstructObject_Internal
	(
		LoadClass,
		ThisParent,
		NewName,
		ObjectLoadFlags,
		EInternalObjectFlags::None,
		Template
	);
}
```

CDO itself is initialized by 
- its **constructor code**, 
- its **Superclass's CDO** if it has `SuperClass`([link](https://github.com/EpicGames/UnrealEngine/blob/749698e58259778b9488e040d2af58e49973d45e/Engine/Source/Runtime/CoreUObject/Private/UObject/Class.cpp#L3020)), 
- and also, by its asset data if it has linked asset in `UClass::SerializeDefaultObject()`([link](https://github.com/EpicGames/UnrealEngine/blob/749698e58259778b9488e040d2af58e49973d45e/Engine/Source/Runtime/CoreUObject/Private/UObject/Class.cpp#L3889)).

CDOs have both the `RF_ClassDefaultObject` **and** `RF_ArchetypeObject` flags, they are set and explained when creating the CDO ([link](https://github.com/EpicGames/UnrealEngine/blob/bf95c2cbc703123e08ab54e3ceccdd47e48d224a/Engine/Source/Runtime/CoreUObject/Private/UObject/Class.cpp#L3073)):
```c++
UObject* UClass::CreateDefaultObject()
{
	...
	// RF_ArchetypeObject flag is often redundant to RF_ClassDefaultObject, but we need to tag
	// the CDO as RF_ArchetypeObject in order to propagate that flag to any default sub objects.
	ClassDefaultObject = StaticAllocateObject(this, GetOuter(), NAME_None, EObjectFlags(RF_Public|RF_ClassDefaultObject|RF_ArchetypeObject));
	...
}
```
For the same reason, all *Default Subobject*s have both `RF_DefaultSubObject` and `RF_ArchetypeObject` flags.

## AActor and UComponent initialization


## Class reflection data
Most (near all) `Z_Construct_UClass_XXX()` fuctions are called only in the initialization stage via `ProcessNewlyLoadedUObjects()`([link](https://github.com/EpicGames/UnrealEngine/blob/b4a54829162aa07a28846da2e91147912a7b67d8/Engine/Source/Runtime/CoreUObject/Private/UObject/UObjectBase.cpp#L983)).
![](assets/Class_reflection_data_allocation.png)

`Z_Construct_UClass_XXX()` are functions that construct the Unreal intrinsic "class reflection data". These functions' code are generated by macro in `IMPLEMENT_INTRINSIC_CLASS`([link](https://github.com/EpicGames/UnrealEngine/blob/0f9ad9685896e0581d0fe963034b1cb82b1a4e3b/Engine/Source/Runtime/CoreUObject/Public/UObject/ObjectMacros.h#L1604)):

```C++
#define IMPLEMENT_INTRINSIC_CLASS(TClass, TRequiredAPI, TSuperClass, TSuperRequiredAPI, TPackage, InitCode) \
	IMPLEMENT_CLASS(TClass, 0) \
	TRequiredAPI UClass* Z_Construct_UClass_##TClass(); \
	struct Z_Construct_UClass_##TClass##_Statics \
	{ \
		static UClass* Construct() \
		{ \
			extern TSuperRequiredAPI UClass* Z_Construct_UClass_##TSuperClass(); \
			UClass* SuperClass = Z_Construct_UClass_##TSuperClass(); \
			UClass* Class = TClass::StaticClass(); \
			UObjectForceRegistration(Class); \
			check(Class->GetSuperClass() == SuperClass); \
			InitCode \
			Class->StaticLink(); \
			return Class; \
		} \
	}; \
	UClass* Z_Construct_UClass_##TClass() \
	{ \
		static UClass* Class = NULL; \
		if (!Class) \
		{ \
			Class = Z_Construct_UClass_##TClass##_Statics::Construct();\
		} \
		check(Class->GetClass()); \
		return Class; \
	} \

    ...
```
```

`main/loop.md`:

```md

# [WIP] Unreal Source Explained

Unreal Source Explained (USE) is an Unreal source code analysis, based on profilers.  
For full Table of Contents and more infomation, see the [repo](https://github.com/donaldwuid/unreal_source_explained) in github.



# Loop



Every game is running frame by frame. Inside one frame, several submodules are called sequentially. This routine is known as *Game Loop*.

![](assets/general_game_loop.png)



Inside `FEngineLoop::Tick()`([link](https://github.com/EpicGames/UnrealEngine/blob/42cbf957ad0e713dec57a5828f72d116c8083011/Engine/Source/Runtime/Launch/Private/LaunchEngineLoop.cpp#L4012)), there are many hardcoded submodules' ticks get called sequetially. This following image is the tick overview, however, it's sorted by the CPU Time, not the calling order.
![](assets/FEngineLoop_Tick_Overview.png)

Calling order is important, it's one of the reasons that lead to one-frame-off bugs.

The general rule is: if status<sub>a</sub> is depended by status<sub>b</sub>, then status<sub>a</sub> should gets updated earlier than status<sub>b</sub> inside one frame.  
This seems to be easy, but if there are lots of status, and the dependecies are complicated, it needs lots of effort to achieve correct status update order.   
But luckily, lots status dependecy don't care correct update order at all because their one-frame-off usually dont't result in visually noticeable motion. For other crucial status (e.g., camera, character), they still demands correct update order.

So, here is some important call extractions from `FEngineLoop::Tick()`, sorted by the calling order:
- broadcast the frame begin event([link](https://github.com/EpicGames/UnrealEngine/blob/42cbf957ad0e713dec57a5828f72d116c8083011/Engine/Source/Runtime/Launch/Private/LaunchEngineLoop.cpp#L4083)): `FCoreDelegates::OnBeginFrame`([link](https://github.com/EpicGames/UnrealEngine/blob/5a8595da4c1427e70707158a8173b4ac774faa8e/Engine/Source/Runtime/Core/Private/Misc/CoreDelegates.cpp#L83));
- update the time stamp, max tick rate of this frame([link](https://github.com/EpicGames/UnrealEngine/blob/42cbf957ad0e713dec57a5828f72d116c8083011/Engine/Source/Runtime/Launch/Private/LaunchEngineLoop.cpp#L4101)): `UEngine::UpdateTimeAndHandleMaxTickRate()`([link](https://github.com/EpicGames/UnrealEngine/blob/7256ed00bd50ce4c8d099e9e8495d37b0e5130e5/Engine/Source/Runtime/Engine/Private/UnrealEngine.cpp#L1862))
- get the input data from the OS([link](https://github.com/EpicGames/UnrealEngine/blob/42cbf957ad0e713dec57a5828f72d116c8083011/Engine/Source/Runtime/Launch/Private/LaunchEngineLoop.cpp#L4230)) : `FIOSApplication::PollGameDeviceState()`([link](https://github.com/EpicGames/UnrealEngine/blob/a00dbfadf5baa73b564eecd774305226e4d031b1/Engine/Source/Runtime/ApplicationCore/Private/IOS/IOSApplication.cpp#L73));
- **update the world of objects!**([link](https://github.com/EpicGames/UnrealEngine/blob/42cbf957ad0e713dec57a5828f72d116c8083011/Engine/Source/Runtime/Launch/Private/LaunchEngineLoop.cpp#L4251)): `UGameEngine::Tick()`([link](https://github.com/EpicGames/UnrealEngine/blob/2f53e5141feb2eaaf521f9193b07bd6103d69230/Engine/Source/Runtime/Engine/Private/GameEngine.cpp#L1539)), this is the **most important call** among others;
- process slate operations accumulated in the world ticks([link](https://github.com/EpicGames/UnrealEngine/blob/42cbf957ad0e713dec57a5828f72d116c8083011/Engine/Source/Runtime/Launch/Private/LaunchEngineLoop.cpp#L4354)): `FEngineLoop::ProcessLocalPlayerSlateOperations()`([link](https://github.com/EpicGames/UnrealEngine/blob/42cbf957ad0e713dec57a5828f72d116c8083011/Engine/Source/Runtime/Launch/Private/LaunchEngineLoop.cpp#L3733));
- rearrange and paint the UI([link](https://github.com/EpicGames/UnrealEngine/blob/42cbf957ad0e713dec57a5828f72d116c8083011/Engine/Source/Runtime/Launch/Private/LaunchEngineLoop.cpp#L4357)): `FSlateApplication::Tick()`([link](https://github.com/EpicGames/UnrealEngine/blob/fd945f737de41823c384f819fd0c0f39444288e4/Engine/Source/Runtime/Slate/Private/Framework/Application/SlateApplication.cpp#L1689));
- custom registered tick is called([link](https://github.com/EpicGames/UnrealEngine/blob/42cbf957ad0e713dec57a5828f72d116c8083011/Engine/Source/Runtime/Launch/Private/LaunchEngineLoop.cpp#L4456)): `FTicker::Tick()`([link](https://github.com/EpicGames/UnrealEngine/blob/cbfcbbb93b3d40c36067a9e962b01e2e35149ead/Engine/Source/Runtime/Core/Private/Containers/Ticker.cpp#L56))
- broadcast the frame end event([link](https://github.com/EpicGames/UnrealEngine/blob/42cbf957ad0e713dec57a5828f72d116c8083011/Engine/Source/Runtime/Launch/Private/LaunchEngineLoop.cpp#L4470)): `FCoreDelegates::OnEndFrame`([link](https://github.com/EpicGames/UnrealEngine/blob/5a8595da4c1427e70707158a8173b4ac774faa8e/Engine/Source/Runtime/Core/Private/Misc/CoreDelegates.cpp#L84))


```

`main/main.md`:

```md

# [WIP] Unreal Source Explained

Unreal Source Explained (USE) is an Unreal source code analysis, based on profilers.  
For full Table of Contents and more infomation, see the [repo](https://github.com/donaldwuid/unreal_source_explained) in github.

# Thread Overview

Unreal has these several important threads:
- Game thread
- Main thread
- Task Threads
	- Render thread (maybe with the additional RHI thread)
	- File I/O threads
	- Mipmap streaming calculations
	- etc.

This following image is the *threads overview* in the profiler. Threads are sorted by their CPU Time, which usually infer their importance.
![](assets/threads_overview.jpg)

We'll briefly discuss some important threads below.

## Game Thread
> see "`[IOSAppDelegate MainAppThread:]`" in the above thread overview image.

Game thread's main mission is running `FEngineLoop`([link](https://github.com/EpicGames/UnrealEngine/blob/33e9eedc27e80b9e67c1d1a2667672ed23c7531b/Engine/Source/Runtime/Launch/Public/LaunchEngineLoop.h#L21)), including its initialization `PreInit()`([link](https://github.com/EpicGames/UnrealEngine/blob/42cbf957ad0e713dec57a5828f72d116c8083011/Engine/Source/Runtime/Launch/Private/LaunchEngineLoop.cpp#L1158)) and tick `Tick()`([link](https://github.com/EpicGames/UnrealEngine/blob/42cbf957ad0e713dec57a5828f72d116c8083011/Engine/Source/Runtime/Launch/Private/LaunchEngineLoop.cpp#L4012)).  
Every game is running frame by frame. Inside one frame, several submodules are called sequentially. This routine is known as *Game Loop*.  
`FEngineLoop` is Unreal's game loop. Each time `FEngineLoop::Tick()` is called, that means one new frame has just begun.

Note that in Unreal, game thread's name is `[IOSAppDelegate MainAppThread:]`, it's Unreal's "main thread", do not confuse with the process's main thread.

## Main Thread
> see "`Main Thread`" in the above thread overview image.

This thread is the iOS process's main thread, it's the first thread that gets created and the entry point gets called.  
In Unreal, Main thread doesn't carry out heavy jobs, it just handles some native iOS messages, such as touch event.

## Task Threads
Unreal has several ways to assign tasks to threads, these threads are called *Task Threads*. This task threads management will be discussed in future chapters.  
These following threads are implemented as task threads.
### Render Threads
> see "`FRenderingThread::Run()`" in the above thread overview image.

Render thread calls `FRenderingThread::Run()`([link](https://github.com/EpicGames/UnrealEngine/blob/b4a54829162aa07a28846da2e91147912a7b67d8/Engine/Source/Runtime/RenderCore/Private/RenderingThread.cpp#L458)), and takes charge of all the rendering tasks, such as updating pritimitives' transform, updating particle systems, drawing slate ui elements, etc. These rendering tasks usually update and prepare rendering data for the GPU to run.

Render thread and the game thread are usually the heaviest 2 threads in most games. You can see the render thread is actually the heaviest thread in this profiling.

Render thread is created in `FEngineLoop::PreInit()`([link](https://github.com/EpicGames/UnrealEngine/blob/42cbf957ad0e713dec57a5828f72d116c8083011/Engine/Source/Runtime/Launch/Private/LaunchEngineLoop.cpp#L2339)). You can observe the thread creation in the Allocation profiler, because each thread creation comes along with some amount of thread stack memory allocation.
![](assets/render_thread_creation.png)
Note the thread creation call stack is reversed, the caller is under the callee.

Notice that sometimes you can see there seems to be another thread running `FRenderingThread::Run()` in the Time Profiler, this is because render thread will be recreated during viewport resizes([link](https://github.com/EpicGames/UnrealEngine/blob/b4a54829162aa07a28846da2e91147912a7b67d8/Engine/Source/Runtime/RenderCore/Private/RenderingThread.cpp#L171)), and the Time Profiler captures both the destroyed and recreated render threads. There is only one render thread at any given time.

#### RHI Thread
What's more, Unreal can be [Parallel Rendering](https://docs.unrealengine.com/en-US/Programming/Rendering/ParallelRendering/index.html) with the RHI (Render Hardware Interface) thread, which translates the render thread's render commands into specific device GPU commands. This RHI thread may improve performance in some platform.   
However, in iOS the RHI thread is disabled, because `GRHISupportsRHIThread`([link](https://github.com/EpicGames/UnrealEngine/blob/697a6f07ef518d03ef3611efdafc2e9a89b0fc3c/Engine/Source/Runtime/Apple/MetalRHI/Private/MetalRHI.cpp#L395)) and `bSupportsRHIThread`([link](https://github.com/EpicGames/UnrealEngine/blob/697a6f07ef518d03ef3611efdafc2e9a89b0fc3c/Engine/Source/Runtime/Apple/MetalRHI/Private/MetalRHI.cpp#L226)) is disabled. Unreal has this comment([link](https://github.com/EpicGames/UnrealEngine/blob/bcc5bcf128a758f0de72c4e460a16423a200d915/Engine/Source/Runtime/Apple/MetalRHI/Public/MetalResources.h#L15)):
```c++
/** Parallel execution is available on Mac but not iOS for the moment - it needs to be tested because it isn't cost-free */
```
You might modify the source code to enable the RHI thread in mobile devices with proper device capability test.

### File I/O Threads
> see "`FAsyncTask<FGenericReadRequestWorker>::DoThreadedWork()`" in the above thread overview image.



```

`main/memory.md`:

```md

# [WIP] Unreal Source Explained

Unreal Source Explained (USE) is an Unreal source code analysis, based on profilers.  
For full Table of Contents and more infomation, see the [repo](https://github.com/donaldwuid/unreal_source_explained) in github.


# Memory Management

## Some Basics

### Process Virtual Memory Segments
![](assets/process_memory_layout.png)  

As the above overview shows, a process has several important memory segments, from higher virtual address to lower:
- Stack;
- "Data Segment" (not strictly speaking, which includes these following child segments)
	- *Program break*, `brk()` manipulates this to increase or decrease the Heap;
	- Heap;
	- **Uninitialized Data Segment**, or **.bss**, uninitialized static variables, filled with zeros;
		- e.g., `static char * NotInitChar;`
	- **Initialized Data Segement**, or **.data**, or just (the well-known strictly) **Data Segment**, initialized static variables by the programmer;
		- e.g., `static char * InitedChar = "Hello";`
- **Text Segment**, holds the code data and other readonly data;

### Native Memory APIs

C++ operator `new` and `delete` use C `malloc()` and `free()` to allocate or release memory.

`malloc()` uses `brk()` for small size allocations and `mmap()` for larger size allocations.

`brk()` was POSIX API but now it's not. `mmap()` is POSIX API.  
`brk()` moves the program break (see the picture above), hence increase or decrease the heap size.  
`mmap()` maps a file for access and lazy load the actual content into the virtual memory. When an anonymous file is mapped (by `MAP_ANONYMOUS` flag or `"/dev/zero"` file) , it's similar to memory allocation.

## `FMemory` and `FMallocBinned`
Most heap memory is allocated via `FMallocBinned::Malloc()`([link](https://github.com/EpicGames/UnrealEngine/blob/517200ac3453d54b233c228a24e5060bc0439065/Engine/Source/Runtime/Core/Private/HAL/MallocBinned.cpp#L916)), which is called by `FMemory::Malloc()`([link](https://github.com/EpicGames/UnrealEngine/blob/bf95c2cbc703123e08ab54e3ceccdd47e48d224a/Engine/Source/Runtime/Core/Public/HAL/FMemory.inl#L27)) and the like.
![](assets/Heap_allocation.png)

`FMallocBinned` is commentted as *"Optimized virtual memory allocator"*, it's actually implemented as [*Memory Pool*](https://en.wikipedia.org/wiki/Memory_pool), where objects with specific size (8B, 16B, ..., 32KB)([link](https://github.com/EpicGames/UnrealEngine/blob/517200ac3453d54b233c228a24e5060bc0439065/Engine/Source/Runtime/Core/Private/HAL/MallocBinned.cpp#L866)) is allocated from corresponding pool([link](https://github.com/EpicGames/UnrealEngine/blob/517200ac3453d54b233c228a24e5060bc0439065/Engine/Source/Runtime/Core/Private/HAL/MallocBinned.cpp#L969)). This can help to reduce memory fragmentation to some degree.  
Allocation is thread-safe and locked for the specific pool.([link](https://github.com/EpicGames/UnrealEngine/blob/517200ac3453d54b233c228a24e5060bc0439065/Engine/Source/Runtime/Core/Private/HAL/MallocBinned.cpp#L974))
![](assets/FMallocBinned_lock.png)

Actually, most of the memory is allocated via `mmap()`, rather than `malloc()`.
![](assets/mmap_alloc.png)

Allocating via `mmap()`/`munmap()` gives the engine developer more freedom to customize memory management, because they are lower and simpler system calls than `malloc()`/`free()`. Another reason is, `malloc()` and `free()` in some platform, may only reduce the [*Resident set size (RSS)*](https://en.wikipedia.org/wiki/Resident_set_size), but the *Virtual set size (VSS)* may not decrease even if `free()` is correctly called.


As the following code snippet shows, 
- very small size (224B in iOS): they are allocated via `SmallOSAlloc()`([link](https://github.com/EpicGames/UnrealEngine/blob/bf95c2cbc703123e08ab54e3ceccdd47e48d224a/Engine/Source/Runtime/Core/Private/HAL/MallocBinned.cpp#L944)), which eventually calls `malloc()`;
-  medium size smaller than the binned size: they are allocated via the pool, the pool is allocated via `AllocatePoolMemory()`([link](https://github.com/EpicGames/UnrealEngine/blob/bf95c2cbc703123e08ab54e3ceccdd47e48d224a/Engine/Source/Runtime/Core/Private/HAL/MallocBinned.cpp#L983)), which calls `OSAlloc()` and eventually calls `mmap()`;
- very large size beyond the binned size: they are allocated by `OSAlloc()`, which is also eventually allocated by `mmap()`;

```c++
void* FMallocBinned::Malloc(SIZE_T Size, uint32 Alignment)
{
	...
	bool bUsePools = true;
	if (Size <= Private::SMALL_BLOCK_POOL_SIZE) // 224B in iOS
	{
		...
		// SmallOSAlloc() calls malloc()
		Free = (FFreeMem*)Private::SmallOSAlloc(*this, AlignedSize, ActualPoolSize);
		...
	}
	if (bUsePools)
	{
	if( Size < BinnedSizeLimit)
	{
		// Allocate from pool.
		...
		if( !Pool )
		{
			// AllocatePoolMemory() calls mmap() eventually
			Pool = Private::AllocatePoolMemory(*this, Table, Private::BINNED_ALLOC_POOL_SIZE/*PageSize*/, Size);
		}
		Free = Private::AllocateBlockFromPool(*this, Table, Pool, Alignment);
	}
	else if ( ((Size >= BinnedSizeLimit && Size <= PagePoolTable[0].BlockSize) ||
		(Size > PageSize && Size <= PagePoolTable[1].BlockSize)))
	{
		// Bucket in a pool of 3*PageSize or 6*PageSize
		...
		if( !Pool )
		{
			// AllocatePoolMemory() calls mmap() eventually
			Pool = Private::AllocatePoolMemory(*this, Table, PageCount*PageSize, BinnedSizeLimit+BinType);
		}

		Free = Private::AllocateBlockFromPool(*this, Table, Pool, Alignment);
	}
	else
	{
		// Use OS for large allocations.
		...
		// OSAlloc() calls mmap()
		Free = (FFreeMem*)Private::OSAlloc(*this, AlignedSize, ActualPoolSize);
		...
	}
	}

	MEM_TIME(MemTime += FPlatformTime::Seconds());
	return Free;
}
```

## Global override new operator
Engines (e.g. Unity) usually use [*Global overloaded new operator*](https://www.geeksforgeeks.org/overloading-new-delete-operator-c/) to hook the `new` opeartor and make its own custom memory management.  
Unreal also overloads the global `operator new()`([link](https://github.com/EpicGames/UnrealEngine/blob/b4a54829162aa07a28846da2e91147912a7b67d8/Engine/Source/Runtime/Core/Public/Modules/Boilerplate/ModuleBoilerplate.h#L29)), which uses `FMemory::Malloc()` to allocate and manage memory.
```c++
#define REPLACEMENT_OPERATOR_NEW_AND_DELETE \
	void* operator new  ( size_t Size ) { return FMemory::Malloc( Size ); } \
	void* operator new[]( size_t Size ) { return FMemory::Malloc( Size ); } \
	...\
	void operator delete  ( void* Ptr ) { FMemory::Free( Ptr ); } \
	void operator delete[]( void* Ptr ) { FMemory::Free( Ptr ); } \
	...\
```
```

`main/rendering.md`:

```md

# [WIP] Unreal Source Explained

Unreal Source Explained (USE) is an Unreal source code analysis, based on profilers.  
For full Table of Contents and more infomation, see the [repo](https://github.com/donaldwuid/unreal_source_explained) in github.




# Rendering

## Prepare

In order to debug your shaders in the GPU debuggers, you should modify Engine/Config/ConsoleVariables.ini:

```ini
; Uncomment to get detailed logs on shader compiles and the opportunity to retry on errors
r.ShaderDevelopmentMode=1

; Uncomment when running with a graphical debugger (but not when profiling)
r.Shaders.Optimize=0
r.Shaders.KeepDebugInfo=1
```

For GPU Scene, it's disabled by default in mobile, you can enable it by setting `r.Mobile.SupportGPUScene=1` in your project's DefaultEngine.ini.

## Basics


Like Blueprint, *Material Editor* is also a node-based visual scripiting envrironment, for creating *Material Shader*.

![](assets/rendering_material_editor.png)

Each node is an *Expression*, you can use various kinds of expressions (e.g., Texture Sample, Add, etc.) to write your own shader logic. Exprssions eventually flow into the *Result Node* (e.g., M_Char_Barbrous above) via *Pin*s (e.g., Base Color, Metallic). Material shader can promote variables into *Parameter*s.

*Material Instance* is subclass of Material Shader. It's data oriented and only specify the input argument of parent material shader. Changes made to material shader will cause shader recompilation, while changes of material instance won't.
![](assets/rendering_material_instance.png)

## Modules

Unreal duplicates most rendering-related things into 2 threads, the game thread and the rendering thread.

Most rendering codes are in 3 modules, Engine, Renderer and RenderCore. During C++ linking, 

- Renderer depends on Engine and RenderCore,([link](https://github.com/EpicGames/UnrealEngine/blob/c33049fcbde20fb59e44dfc32b25dc610561314c/Engine/Source/Runtime/Renderer/Renderer.Build.cs#L19))
- Engine only depends on RenderCore,([link](https://github.com/EpicGames/UnrealEngine/blob/f9b3324b32be95b1fd37235e7b7f2fbb502db285/Engine/Source/Runtime/Engine/Engine.Build.cs#L73))
- RenderCore doesn't depend on other two.

![](assets/unreal_rendering_modules.png)

Following is some important rendering-related classes, you can summarize it by these patterns:

- `U**` are all in game thread,
	- all of their codes are in Engine module,
- `F**` are all in rendering thread,
	- however, `F**Proxy`, `FMaterial` and `FSceneView`'s codes are all in Engine module, they are literaly the **one-way data bridge** from GameThread to RenderingThread
	- others' codes are in Renderer or RenderCore module.


| Game Thread | Rendering Thread| Rendering Thread|
|--|--|--|
| **Engine Module** | **Engine Module** | **Renderer Module** |
||
|**World (Scene):**|
|`UWorld`||`FScene`|
|`ULevel`||
|`USceneComponent`||
||
|**Primitive:**
|`UPrimitiveComponent`|`FPrimitiveSceneProxy`|`FPrimitiveSceneInfo`|
||`F**SceneProxy`,<br>inehrited from `FPrimitiveSceneProxy`,<br> has `FVertexyFactory` and `UMaterialInterface`
||
|**View:**
||`FSceneViewFamily`<br>- has multiple `FSceneView`<br>- transient and create every frame|`FViewInfo`<br>inherited from `FSceneView`
|`ULocalPlayer`||`FSceneViewState`|
||
|**Light:** 
|`ULightComponent`|`FLightSceneProxy`|`FLightSceneInfo`|
||
|**Material and Shader:** 
|`UMaterialInterface`,<br>derived class: `UMaterial` and `UMaterialInstance` |`FMaterial`,<br>derived class: `FMaterialResource` and `FMaterialRenderProxy`|
|||`FShaderType`,<br>derived class: `FMaterialShaderType`|
|||`FShader`,<br>derived class: `FMaterialShader`|
||
|**Renderer:**
|||`FSceneRenderer`,<br>- transient and create every frame<br>- derived class: `FMobileSceneRenderer`|

Unreal uses [mtlpp](https://github.com/naleksiev/mtlpp), a C++ Metal wrapper, to glue its RHI codes and Metal APIs together.

## New Mesh Drawing Pipeline

For better support of massive primitives, GPU driven pipeline and ray-tracing, Epic has refactored and introduce a new [Mesh Drawing Pipeline](https://docs.unrealengine.com/en-US/Programming/Rendering/MeshDrawingPipeline/index.html)(MDP) in 4.22. And Epic gave a [talk](https://www.youtube.com/watch?v=UJ6f1pm_sdU) about it.

The new pipeline is summarized by Epic as:
![](assets/mesh_drawing_pipeline_journey.jpg)

Compared to the old *immediate mode* pipeline, the new MDP is kinda *retain mode*. It adds new `FMeshDrawCommand` to cache the draw commands, then merge and sort them. `FMeshPassProcessor` replaces the old *Drawing Policy* to generate commands.

The new MDP is all about caching. Here is its 3 different caching code paths,
![](assets/mdp_cache_code_paths.png)

## Unreal Rendering Flow

Here is my conclusion about Unreal Rendering Flow:

![](drawing/unreal_rendering_flow.svg)

Which in summary is,

- on game thread, `FRendererModule::BeginRenderingViewFamily()` dispatches `FMobileSceneRenderer_Render()` to the render thread,
- `FMobileSceneRenderer::Render()` is the **"main" function** for all kinds of rendering techniques,
- In `FScene::UpdateAllPrimitiveSceneInfos()`, completely static prmitives are cache both `FMeshBatch` and `FMeshDrawCommand`, once they are `AddToScene()`ed.
- `FMobileSceneRenderer::InitViews()` computes visibility, and for static primitive whose vertex factory depends on the view, can only cahce its `FMeshBatch`, and generating `FMeshDrawCommand` in `InitViews()`
  - `InitViews()` also kicks off `FMeshDrawCommandPassSetupTask::AnyThreadTask()` to task thread to **sort-and-merge ALL** mesh draw commands, of this frame.
- later on, different rendering techiniques, `FMobileSceneRenderer::RenderMobileBasePass()` or `FMobileSceneRenderer::RenderTranslucency()` submit a sub-range draw command based on the **sorted-and-merged** mesh draw commands.
- At last, the frame buffer is presented on `FRHICommandList::EndDrawingViewport()`.


### Primitive Scene Proxy

`FPrimitiveSceneProxy`([link](https://github.com/EpicGames/UnrealEngine/blob/9cb729729cf2130ed4ccb2a71eae8818916f4892/Engine/Source/Runtime/Engine/Public/PrimitiveSceneProxy.h#L126)) is just the rendering thread counterpart of `UPrimitiveComponent`. Both of them is intended to be subclassed to support different primitive types, for example,

|`UPrimitiveComponent`|`FPrimitiveSceneProxy`|
|--|--|
|`UStaticMeshComponent`|`FStaticMeshSceneProxy`
|`USkeletalMeshComponent`|`FSkeletalMeshSceneProxy`|
|`UHierarchicalInstancedStaticMeshComponent`|`FHierarchicalStaticMeshSceneProxy`|
|`ULandscapeComponent`|`FLandscapeComponentSceneProxy`|
|...|...|

### Mesh Batch

1 `UStaticMesh` has several LODs (`FStaticMeshLODResources`, `InStaticMesh->RenderData->LODResources[InLODIndex]`).

1 LOD has several *Draw Section*s (`FStaticMeshSection`, `InStaticMesh->RenderData->LODResources[InLODIndex].Sections[InSectionIndex]`).
1 Draw Section usually generates 1 drawcall, which specify drawing which triangles with which material index.
```c++
struct FStaticMeshSection {
	/** The index of the material with which to render this section. */
	int32 MaterialIndex;

	/** Range of vertices and indices used when rendering this section. */
	uint32 FirstIndex;
	uint32 NumTriangles;
	uint32 MinVertexIndex;
	uint32 MaxVertexIndex;
	...
}
```

In `FStaticMeshSceneProxy::GetMeshElement()`, 1 Draw Section's actual rendering data is extracted into 1 corresponding 1 *Mesh Batch* (`FMeshBatch`) and mesh batch's 1 *Mesh Batch Element* (`FMeshBatchElement`).

1  `FMeshBatch` cantains all infomations about **all passes‚Äò information** of one primitive, including the vertex buffer (in vertex factory) and material, etc.
It has an array of `FMeshBatchElement`, **whose length is usually 1**. Each element describes **one pass' information**, such as instancing count, uniform buffer, index buffer, and first index into the index buffer.

```c++
/**
 * A batch of mesh elements, all with the same material and vertex buffer
 */
struct FMeshBatch
{
	TArray<FMeshBatchElement,TInlineAllocator<1> > Elements;
	...
	uint32 ReverseCulling : 1;
	uint32 bDisableBackfaceCulling : 1;
	/** 
	 * Pass feature relevance flags.
	 */
	uint32 CastShadow		: 1;	// Whether it can be used in shadow renderpasses.
	uint32 bUseForMaterial	: 1;	// Whether it can be used in renderpasses requiring material outputs.
	uint32 bUseForDepthPass : 1;	// Whether it can be used in depth pass.
	uint32 bUseAsOccluder	: 1;	// Hint whether this mesh is a good occluder.
	...

	/** Vertex factory for rendering, required. */
	const FVertexFactory* VertexFactory;

	/** Material proxy for rendering, required. */
	const FMaterialRenderProxy* MaterialRenderProxy;
	...
};
```

For static mesh batches, they are stored in their primitive, see the ownership chain (root at the top)

- `FPrimitiveSceneInfo* FPrimitiveSceneProxy::PrimitiveSceneInfo`
- `TArray<FStaticMeshBatch> FPrimitiveSceneInfo::StaticMeshes`

and they are collected once they are added to the scene, and cached,
![](assets/mdp_drawstaticelements.png)

For dynamic mesh batches, `FMeshElementCollector FSceneRenderer::MeshCollector`([link](https://github.com/EpicGames/UnrealEngine/blob/c1edbcc5f2d8d198b9bbbde906426a3733d8f134/Engine/Source/Runtime/Renderer/Private/SceneRendering.h#L1412)) stores an array of `FMeshBatch`.  
During each frame in `InitView()`, `FSceneRenderer` calls `FPrimitiveSceneProxy::GetDynamicMeshElements()` to generate the dynamic `FMeshBatch` ,
![](assets/mdp_GetDynamicMeshElements.png)


### Mesh Draw Command

`FMeshDrawCommand`([link](https://github.com/EpicGames/UnrealEngine/blob/017efe88c610f06521a7f48b21e930c73e4f79ea/Engine/Source/Runtime/Renderer/Public/MeshPassProcessor.h#L442)) describes a mesh's **one pass** draw call, captured between Mesh Batch (and Mesh Batch Element for IB, etc.) and the RHI. It just contains the only data needed to draw.

```c++
class FMeshDrawCommand
{
public:
	/** Resource bindings */
	FMeshDrawShaderBindings ShaderBindings;
	FVertexInputStreamArray VertexStreams;
	FRHIIndexBuffer* IndexBuffer;

	/** PSO */
	FGraphicsMinimalPipelineStateId CachedPipelineId;

	/** Draw command parameters */
	uint32 FirstIndex;
	uint32 NumPrimitives;
	uint32 NumInstances;
	...
}
```


Mesh draw commands are generated by these following calls,
![](assets/mdp_AddMeshBatch_BuildMeshDrawCommands.png)

Calltree always end up in `FMeshPassProcessor::BuildMeshDrawCommands()`[(link)](https://github.com/EpicGames/UnrealEngine/blob/d6c5e89118c7ae95e6dd12a9faaac5ef6b174e9e/Engine/Source/Runtime/Renderer/Public/MeshPassProcessor.inl#L118), where all `FMeshDrawCommand` are created and extracted from `FMeshBatch` and `FMeshBatchElement`, like the following POI code snippet,

```c++
template<typename PassShadersType, typename ShaderElementDataType>
void FMeshPassProcessor::BuildMeshDrawCommands(
	const FMeshBatch& RESTRICT MeshBatch,
	uint64 BatchElementMask,
	const FPrimitiveSceneProxy* RESTRICT PrimitiveSceneProxy,
	const FMaterialRenderProxy& RESTRICT MaterialRenderProxy,
	const FMaterial& RESTRICT MaterialResource,
	PassShadersType PassShaders,
	const ShaderElementDataType& ShaderElementData, ...)
{
	const FVertexFactory* RESTRICT VertexFactory = MeshBatch.VertexFactory;
	const FPrimitiveSceneInfo* RESTRICT PrimitiveSceneInfo = PrimitiveSceneProxy ? PrimitiveSceneProxy->GetPrimitiveSceneInfo() : nullptr;

	FMeshDrawCommand SharedMeshDrawCommand;

	// POI: almost all shaders, resources are from FMeshBatch::MaterialRenderProxy.
	FGraphicsMinimalPipelineStateInitializer PipelineState;
	PipelineState.PrimitiveType = (EPrimitiveType)MeshBatch.Type;
	PipelineState.ImmutableSamplerState = MaterialRenderProxy.ImmutableSamplerState;
	EVertexInputStreamType InputStreamType = EVertexInputStreamType::Default;
	if ((MeshPassFeatures & EMeshPassFeatures::PositionOnly) != EMeshPassFeatures::Default)				InputStreamType = EVertexInputStreamType::PositionOnly;
	if ((MeshPassFeatures & EMeshPassFeatures::PositionAndNormalOnly) != EMeshPassFeatures::Default)	InputStreamType = EVertexInputStreamType::PositionAndNormalOnly;
	FRHIVertexDeclaration* VertexDeclaration = VertexFactory->GetDeclaration(InputStreamType);
	SharedMeshDrawCommand.SetShaders(VertexDeclaration, PassShaders.GetUntypedShaders(), PipelineState);
	PipelineState.RasterizerState = GetStaticRasterizerState<true>(MeshFillMode, MeshCullMode);
	PipelineState.BlendState = DrawRenderState.GetBlendState();

	VertexFactory->GetStreams(FeatureLevel, InputStreamType, SharedMeshDrawCommand.VertexStreams);
	SharedMeshDrawCommand.PrimitiveIdStreamIndex = VertexFactory->GetPrimitiveIdStreamIndex(InputStreamType);

	int32 DataOffset = 0;
	if (PassShaders.VertexShader.IsValid()) {
		FMeshDrawSingleShaderBindings ShaderBindings = SharedMeshDrawCommand.ShaderBindings.GetSingleShaderBindings(SF_Vertex, DataOffset);
		PassShaders.VertexShader->GetShaderBindings(Scene, FeatureLevel, PrimitiveSceneProxy, MaterialRenderProxy, MaterialResource, DrawRenderState, ShaderElementData, ShaderBindings);
	}
	if (PassShaders.PixelShader.IsValid()) {
		FMeshDrawSingleShaderBindings ShaderBindings = SharedMeshDrawCommand.ShaderBindings.GetSingleShaderBindings(SF_Pixel, DataOffset);
		PassShaders.PixelShader->GetShaderBindings(Scene, FeatureLevel, PrimitiveSceneProxy, MaterialRenderProxy, MaterialResource, DrawRenderState, ShaderElementData, ShaderBindings);
	}

	// POI: generates MeshDrawCommand for each BatchElement
	const int32 NumElements = MeshBatch.Elements.Num();
	for (int32 BatchElementIndex = 0; BatchElementIndex < NumElements; BatchElementIndex++) {
		if ((1ull << BatchElementIndex) & BatchElementMask) {
			const FMeshBatchElement& BatchElement = MeshBatch.Elements[BatchElementIndex];
			FMeshDrawCommand& MeshDrawCommand = DrawListContext->AddCommand(SharedMeshDrawCommand, NumElements);

			DataOffset = 0;
			if (PassShaders.VertexShader.IsValid()) {
				FMeshDrawSingleShaderBindings VertexShaderBindings = MeshDrawCommand.ShaderBindings.GetSingleShaderBindings(SF_Vertex, DataOffset);
				FMeshMaterialShader::GetElementShaderBindings(PassShaders.VertexShader, Scene, ViewIfDynamicMeshCommand, VertexFactory, InputStreamType, FeatureLevel, PrimitiveSceneProxy, MeshBatch, BatchElement, ShaderElementData, VertexShaderBindings, MeshDrawCommand.VertexStreams);
			}
			if (PassShaders.PixelShader.IsValid()) {
				FMeshDrawSingleShaderBindings PixelShaderBindings = MeshDrawCommand.ShaderBindings.GetSingleShaderBindings(SF_Pixel, DataOffset);
				FMeshMaterialShader::GetElementShaderBindings(PassShaders.PixelShader, Scene, ViewIfDynamicMeshCommand, VertexFactory, EVertexInputStreamType::Default, FeatureLevel, PrimitiveSceneProxy, MeshBatch, BatchElement, ShaderElementData, PixelShaderBindings, MeshDrawCommand.VertexStreams);
			}

			int32 DrawPrimitiveId;
			int32 ScenePrimitiveId;
			GetDrawCommandPrimitiveId(PrimitiveSceneInfo, BatchElement, DrawPrimitiveId, ScenePrimitiveId);

			// POI: Initialize MeshDrawCommand from this BatchElement (IB, Offset, NumPrimitives)
			DrawListContext->FinalizeCommand(MeshBatch, BatchElementIndex, DrawPrimitiveId, ScenePrimitiveId, MeshFillMode, MeshCullMode, SortKey, PipelineState, &ShadersForDebugging, MeshDrawCommand);
		}
	}
}
```

For Static draw commands, they are initiated from `FScene::AddPrimitive()`, which of cause, right after the primitive is added to the scene. They are stored in `FScene`, see the ownership chain (root at the top),

- Scene: `FScene* FSceneRenderer::Scene`
- `FCachedPassMeshDrawList FScene::CachedDrawLists[EMeshPass::Num];`
- Static mesh draw commands: `TSparseArray<FMeshDrawCommand> FCachedPassMeshDrawList::MeshDrawCommands`

For static mesh whose vertex factory is view-dependant (shadow, etc.), their mesh draw commands are stored in `FViewInfo`, so these draw commands are generated in `FMobileSceneRenderer::InitViews()` or `FSceneRenderer::ComputeViewVisibility()`, and both of them go to `GenerateMobileBasePassDynamicMeshDrawCommands()`. Dynamic draw commands are stored in the `FViewInfo`, see the ownership chain (root at the top),

- View, `TArray<FViewInfo> FSceneRenderer::Views`
- `TStaticArray<FParallelMeshDrawCommandPass, EMeshPass::Num> FViewInfo::ParallelMeshDrawCommandPasses`
- `FMeshDrawCommandPassSetupTaskContext FParallelMeshDrawCommandPass::TaskContext`,
- Dynamic draw commands: `FDynamicMeshDrawCommandStorage FMeshDrawCommandPassSetupTaskContext::MeshDrawCommandStorage`
- `TChunkedArray<FMeshDrawCommand> FDynamicMeshDrawCommandStorage::MeshDrawCommands`


After that, both static and dynamic draw commands share the same remaining code path from `FMobileBasePassMeshProcessor::AddMeshBatch()` to `FMeshPassProcessor::BuildMeshDrawCommands<..>()`.

And in `FMeshDrawCommandPassSetupTask::AnyThreadTask()`, it finally handles movable mesh's mesh draw command.


TODO: `FMobileSceneRenderer::Render()`???
```

`main/rendering_parallel.md`:

```md

# [WIP] Unreal Source Explained

Unreal Source Explained (USE) is an Unreal source code analysis, based on profilers.  
For full Table of Contents and more infomation, see the [repo](https://github.com/donaldwuid/unreal_source_explained) in github.



# Parallel Rendering

## Render Commands

We usually create and enqueue a render command like this:
```c++
void DestroyRenderResource(FRenderResource* RenderResource) {
    ENQUEUE_RENDER_COMMAND(DestroySceneViewStateRenderResource)(
        [RenderResource](FRHICommandList&) {
            RenderResource->ReleaseResource();
            delete RenderResource;
        });
}
```



`ENQUEUE_RENDER_COMMAND`([link](https://github.com/EpicGames/UnrealEngine/blob/d3866ecfb425d911abd0d110ce43698606a255bf/Engine/Source/Runtime/RenderCore/Public/RenderingThread.h#L262)) creates a named (for easier debug) struct and calls `EnqueueUniqueRenderCommand()` with the lambda, hence, the above codes expand to these:

```c++
void DestroyRenderResource(FRenderResource* RenderResource) {
    struct DestroySceneViewStateRenderResourceName { 
        static const char* CStr() { return "DestroySceneViewStateRenderResource"; } 
        static const TCHAR* TStr() { return TEXT("DestroySceneViewStateRenderResource"); } 
    };
    
    // POI begin
    EnqueueUniqueRenderCommand<DestroySceneViewStateRenderResourceName>(
			[RenderResource](FRHICommandList&) {
				RenderResource->ReleaseResource();
				delete RenderResource;
			});
    // POI end
}
```

`EnqueueUniqueRenderCommand()`([link](https://github.com/EpicGames/UnrealEngine/blob/d3866ecfb425d911abd0d110ce43698606a255bf/Engine/Source/Runtime/RenderCore/Public/RenderingThread.h#L233)) will execute the lambda if it's in rendering thread. If not, it will use `TGraphTask<>` template to create a taskgraph's task to execute the lambda.

```c++

template<typename TSTR, typename LAMBDA>
FORCEINLINE_DEBUGGABLE void EnqueueUniqueRenderCommand(LAMBDA&& Lambda) {
	//QUICK_SCOPE_CYCLE_COUNTER(STAT_EnqueueUniqueRenderCommand);
	typedef TEnqueueUniqueRenderCommandType<TSTR, LAMBDA> EURCType;

	if (IsInRenderingThread()) {
		FRHICommandListImmediate& RHICmdList = GetImmediateCommandList_ForRenderCommand();
		Lambda(RHICmdList);
	}
	else {
		if (ShouldExecuteOnRenderThread()) {
			CheckNotBlockedOnRenderThread();
            // POI
		    TGraphTask<EURCType>::CreateTask().ConstructAndDispatchWhenReady(Forward<LAMBDA>(Lambda));
		}
		else { ... }
	}
}
```

Below is the time profiler filtered by `void EnqueueUniqueRenderCommand()` and only shows call tree whose samples count is more than 300 samples, which indicates their importance. We can know there are serveral threads, including game thread, are making lots of call to equeue render commands, e.g., `FScene::UpdatePrimitiveTransform()`, `FSkeletalMeshObjectGPUSkin::Update()`, `FSceneViewport::EnqueueBeginRenderFrame()`,

![](assets/EnqueueUniqueRenderCommand.png)

Recall from the [Thread Management](thread.md)'s Task Grpah chapter that, TaskGrpah is a multi-threaded task graph framework. With `TGraphTask<EURCType>::CreateTask().ConstructAndDispatchWhenReady()` called, it create `TGraphTask` instance who holds an instance of `FRenderCommand`, and dispatch this `TGraphTask` instance into the queue. Then in rendering thread, the task is dequeued and its `DoTask()` is called, hence, the user's lambda is executed.

```c++
template<typename TSTR, typename LAMBDA>
class TEnqueueUniqueRenderCommandType : public FRenderCommand {
public:
	TEnqueueUniqueRenderCommandType(LAMBDA&& InLambda) : Lambda(Forward<LAMBDA>(InLambda)) {}

    // POI begin
	void DoTask(ENamedThreads::Type CurrentThread, const FGraphEventRef& MyCompletionGraphEvent) {
		TRACE_CPUPROFILER_EVENT_SCOPE_ON_CHANNEL_STR(TSTR::TStr(), RenderCommandsChannel);
		FRHICommandListImmediate& RHICmdList = GetImmediateCommandList_ForRenderCommand();
		Lambda(RHICmdList);
	}
    // POI end
private:
	LAMBDA Lambda;
};
```

Each named thread has 2 queues for executing tasks. Take the rendering thread for example, the main queue (QueueIndex = 0) are those render task from game thread, these **main** tasks are of type `TEnqueueUniqueRenderCommandType`, which inherit from `FRenderCommand`. Because **main** render tasks are root tasks created from game thread to render thread, they are running in rendering thread (because their `GetDesiredThread()` return `RenderThread`). For better performance, they don't use task dependencies (their `GetSubsequentsMode()` returns `ESubsequentsMode::FireAndForget`). The local queue (QueueIndex = 1) handles rendering thread's internal sub-tasks, they are driven by task graph's prequisition dependencies (they are processed each time a `FTaskGraphInterface::Get().WaitUntilTaskCompletes()` is called, see image below). 



![](assets/renderthread_2_queues.png)


Below is time profiler showing some call tree filtered by `TGraphTask<TEnqueueUniqueRenderCommandType` with great overhead (again, which indicating their importance). We can know they are all executing in the rendering thread, such as `FRenderModule::BeginRenderingViewFamily()`, `FEngineLoop::Tick()::EndFrameName`.
![](assets/TEnqueueUniqueRenderCommandType_DoTask.png)


### Summary

User enqueues render commands into task graph's task queue. In rendering thread, render commands are dequeued and executed.

## RHI Commands

*RHI* stands for Render Haredware Interface, it's an abstraction of graphic APIs, so the rendering commands only depends RHI interfaces, rather not different platforms' GPU APIs.


Even if the game is starting up on a given platform (Windows/Android/iOS), it may still have to deceide which GPU API to be enabled (DirectX/OpenGL/Vulkan/Metal). `FDynamicRHI` is this API abstraction, and `FMetalDynamicRHI`, `FVulkanDynamicRHI`, etc. inherits from it. `FDynamicRHI* GDynamicRHI` is the global instance and initialized in `RHIInit()`([link](https://github.com/EpicGames/UnrealEngine/blob/070f4e2830c3f2ea51ac616c87599d08805fd1a1/Engine/Source/Runtime/RHI/Private/DynamicRHI.cpp#L223)), during `FEngineLoop::PreInitPreStartupScreen()`([link](https://github.com/EpicGames/UnrealEngine/blob/baf160a5a125a3ca2fd48f33d0312670a511f78d/Engine/Source/Runtime/Launch/Private/LaunchEngineLoop.cpp#L2599)), 

```c++
void RHIInit(bool bHasEditorToken) {
	if (!GDynamicRHI) {
		if (!FApp::CanEverRender()) {
			InitNullRHI();
		}
		else {
            // POI begins
			GDynamicRHI = PlatformCreateDynamicRHI();
            GDynamicRHI->Init();
            // POI ends
                ...
            }
        }
    }
}
```

Different platform has its own `PlatformCreateDynamicRHI()` implementation and returns corresponding `FDynamicRHI` instance.

`IRHICommandContext` is similar to `FDynamicRHI`, it's also an abstraction of GPU APIs hence inherited class `FVulkanCommandListContext`, `FMetalRHICommandContext`. But the context mainly handles things that can be paralelly encoded, such as those "draw" things. `FDynamicRHI` mainly handle the "resource" things.
Note that, their methods all begin with `RHI`, such as `FDynamicRHI::RHICreateUniformBuffer()`, `IRHICommandContext::RHIDrawIndexedPrimitive()`.

| `FDynamicRHI` | `IRHICommandContext` |
|--|--|
| mainly "resource" RHI commands | mainly "draw" RHI commands |
|![](assets/FDynamicRHI.png)|![](assets/IRHICommandContext.png)|

In older APIs, OpenGL and DirectX11, their dynamic RHI implements both the `FDynamicRHI` and `IRHICommandContext`
![](assets/rendering_inherit_both_from_dynamicrhi_rhicommandcontext.png)

Remember that each render command accepts an `FRHICommandList` instance argument, take the following render command ([link](https://github.com/EpicGames/UnrealEngine/blob/3808ee307e4bd2292a1e4b2c9868d9cfeaf38397/Engine/Source/Editor/UnrealEd/Private/FeedbackContextEditor.cpp#L378)) for example, it generates *RHI command* via direct call of `RHICmdList`'s member methods,
```c++

static void TickSlate(TSharedPtr<SWindow> SlowTaskWindow) {
    ...
    if (GIsRHIInitialized) {
        // POI
        ENQUEUE_RENDER_COMMAND(BeginFrameCmd)([](FRHICommandListImmediate& RHICmdList) { RHICmdList.BeginFrame(); });
    }

    // Tick Slate application
    FSlateApplication::Get().Tick();

    // End frame so frame fence number gets incremented
    if (GIsRHIInitialized) {
        // POI
        ENQUEUE_RENDER_COMMAND(EndFrameCmd)([](FRHICommandListImmediate& RHICmdList) { RHICmdList.EndFrame(); });
    }
    ...
}
```


However, most render command create new *RHI Command*s indirectly via further function calls, see the profiling call tree below, which is filtered by `FRHICommandList::` and high sample counts. We can know that those important RHI commands are created in all kinds of render commands in the rendering thread.


![](assets/FRHICommandList_Commands.png)


Take the most important command, `FRHICommandList::DrawIndexedPrimitive()`([link](https://github.com/EpicGames/UnrealEngine/blob/f08c1daafc7712356057b74ebe9f772678a9a00b/Engine/Source/Runtime/RHI/Public/RHICommandList.h#L3177)) for example,
```c++
void FRHICommandList::DrawIndexedPrimitive(FRHIIndexBuffer* IndexBuffer, int32 BaseVertexIndex, ...) {
    if (Bypass()) {
        // POI
        GetContext().RHIDrawIndexedPrimitive(IndexBuffer, BaseVertexIndex, ...);
        return;
    }
    // POI
    ALLOC_COMMAND(FRHICommandDrawIndexedPrimitive)(IndexBuffer, BaseVertexIndex, ...);
}
```

It says, if current run is bypassing the RHI command, then RHI command list will calls its *RHI Context* to execute the RHI call directly. Otherwise, RHI command list will allocate the RHI command instance and queue them up. 
By default, `Bypass()`([link](https://github.com/EpicGames/UnrealEngine/blob/f08c1daafc7712356057b74ebe9f772678a9a00b/Engine/Source/Runtime/RHI/Public/RHICommandList.h#L5058)) always returns true in iOS, that may due to iPhone's great single core house power. And it returns false in Android (for v4.27), which may have many cores available and suit for having a dedicated RHI thread to handles RHI commands.

![](assets/PLATFORM_RHITHREAD_DEFAULT_BYPASS.png)



So, let's have a look at `FRHICommandList`'s base class `FRHICommandListBase`: 
```c++
class RHI_API FRHICommandListBase : public FNoncopyable {
    ...
    // POI begins (context)
public:
	bool Bypass() const;
    
	void SetContext(IRHICommandContext* InContext) {
		Context = InContext;
        ...
	}
	FORCEINLINE IRHICommandContext& GetContext() { return *Context; }

private:
	IRHICommandContext* Context;
    // POI ends (context)

    // POI begins (rhi command queue)
public:
	FORCEINLINE_DEBUGGABLE void* AllocCommand(int32 AllocSize, int32 Alignment) {
		FRHICommandBase* Result = (FRHICommandBase*) MemManager.Alloc(AllocSize, Alignment);
		++NumCommands;
		*CommandLink = Result;
		CommandLink = &Result->Next;
		return Result;
	}

private:
	FRHICommandBase* Root;
	FRHICommandBase** CommandLink;
	uint32 NumCommands;
    // POI ends (rhi command queue)

    ...
};
```

`FRHICommandListBase` has mainly two items: a context and a command queue. And it stores a list of instances whose type inherits from `FRHICommandBase`, with the `Root` as the list tail and `CommandLink` the head.

There is one global command list `GRHICommandList`([link](https://github.com/EpicGames/UnrealEngine/blob/cdafed081955f371a0070ca2961b572ea87c06b9/Engine/Source/Runtime/RHI/Private/RHICommandList.cpp#L149)), it's feed into the render command argument via static function `FRHICommandListExecutor::GetImmediateCommandList()`([link](https://github.com/EpicGames/UnrealEngine/blob/93329d46d07d11635e41039065ad7396c67f5ebc/Engine/Source/Runtime/RenderCore/Private/RenderingThread.cpp#L1308)).

So, what is *Immediate Command List*? `FRHICommandList` wraps `IRHICommandContext` and provide "draw" methods. `FRHICommandListImmediate` inherits from `FRHICommandList` and providing additional `FDynamicRHI` methods about "resource". Hence is this following comparision table,
| RHI Command List | RHI | Meaning |
|--|--|--|
| `FRHICommandList` | `IRHICommandContext` | "draw" methods
| `FRHICommandListImmediate` | `IRHICommandContext` + `FDynamicRHI` | "draw" + "resource" methods



Note that, RHI Command list's member method names don't contain *RHI*, e.g., `FRHICommandListImmediate::CreateUniformBuffer()`, `FRHICommandList::DrawIndexedPrimitive()`.

### Summary
Render commands generate RHI commands. RHI commands may be executed in the rendering thread, or are queued up in the RHI command list and get executed in a dedicated RHI thread. RHI command list uses dyanmic RHI and RHI command context to run the actual GPU driver APIs.
```

`main/rendering_resource.md`:

```md


# [WIP] Unreal Source Explained

Unreal Source Explained (USE) is an Unreal source code analysis, based on profilers.  
For full Table of Contents and more infomation, see the [repo](https://github.com/donaldwuid/unreal_source_explained) in github.




# Rendering Resources

## Resources Creation


To observe resource creation, the best view for us is the Allocation profiler. Below is the memory allocation summary of `IOAccelResourceCreate()`, which is the entrance of Metal's resource allocations. We can see that GPU memory is allocated for various kinds of resources, e.g., textures, encoders, (vertex and index) buffers and shaders, etc.

![](assets/rendering_mtlpp_allocate_memory.png)
> Unreal uses [mtlpp](https://github.com/naleksiev/mtlpp), a C++ Metal wrapper, to glue its RHI codes and Metal APIs together, we can see almost all `IOAccelResourceCreate()` is called indirectly from `mtlpp`.

We can dig deeper and summerize by this following table.,

| Resource Allocation | Reference Variable | Engine API | RHI API<br>High Level | RHI API<br>Low Level | Wrapper API<br>(mtlpp) |Graphic API (Metal)
|--|--|--|--|--|--|--|
| Texture | `UTexture::TextureReference`([link](https://github.com/EpicGames/UnrealEngine/blob/070f44a07a30e84aa4fd2512873153adca166645/Engine/Source/Runtime/Engine/Classes/Engine/Texture.h#L840)) |`FTexture2DResource::InitRHI()`([link](https://github.com/EpicGames/UnrealEngine/blob/1c7a59e6d0464716a81d699e869de34cf0af9dfc/Engine/Source/Runtime/Engine/Public/TextureResource.h#L195)), etc.|`CreateTexture2D()`([link](https://github.com/EpicGames/UnrealEngine/blob/7a2cc9763c8cf1766337f4bae385ced20d49abad/Engine/Source/Runtime/RHI/Public/RHICommandList.h#L4192))| `FDynamicRHI::RHICreateTexture2D()`'s implementation([link](https://github.com/EpicGames/UnrealEngine/blob/3b09b8309ae4c80c2a29b4e83aa2258baf829320/Engine/Source/Runtime/RHI/Public/DynamicRHI.h#L717))|`mtlpp::Device::NewTexture()`|`MTLIOAccelTexture initWithDevice]`
| Vertex Buffer | `FVertexBuffer::VertexBufferRHI`([link](https://github.com/EpicGames/UnrealEngine/blob/3b4ff4c5771927f73ea309e1d15257587c36acf4/Engine/Source/Runtime/RenderCore/Public/RenderResource.h#L498)) | `FPositionVertexBuffer::InitRHI()`([link](https://github.com/EpicGames/UnrealEngine/blob/532dc5287ff9aff943f034e88117d5fc26bbc720/Engine/Source/Runtime/Engine/Private/PositionVertexBuffer.cpp#L247)),<br>`FColorVertexBuffer::InitRHI()`([link](https://github.com/EpicGames/UnrealEngine/blob/532dc5287ff9aff943f034e88117d5fc26bbc720/Engine/Source/Runtime/Engine/Private/Rendering/ColorVertexBuffer.cpp#L446)),<br>`FStaticMeshVertexBuffer::InitRHI()`([link](https://github.com/EpicGames/UnrealEngine/blob/532dc5287ff9aff943f034e88117d5fc26bbc720/Engine/Source/Runtime/Engine/Private/Rendering/StaticMeshVertexBuffer.cpp#L364)),<br>etc.|`RHICreateVertexBuffer()`([link](https://github.com/EpicGames/UnrealEngine/blob/7a2cc9763c8cf1766337f4bae385ced20d49abad/Engine/Source/Runtime/RHI/Public/RHICommandList.h#L5084))| `FDynamicRHI::RHICreateVertexBuffer()`'s implmentation([link](https://github.com/EpicGames/UnrealEngine/blob/3b09b8309ae4c80c2a29b4e83aa2258baf829320/Engine/Source/Runtime/RHI/Public/DynamicRHI.h#L551))|`mtlpp::Device::NewBuffer()`| `[MTLIOAccelBuffer initWithDevice]`
| Index Buffer | `FIndexBuffer::IndexBufferRHI`([link](https://github.com/EpicGames/UnrealEngine/blob/3b4ff4c5771927f73ea309e1d15257587c36acf4/Engine/Source/Runtime/RenderCore/Public/RenderResource.h#L570)) | `FRawStaticIndexBuffer::InitRHI()`<br>`FParticleIndexBuffer::InitRHI()`,<br>etc.|`RHICreateIndexBuffer()`([link](https://github.com/EpicGames/UnrealEngine/blob/7a2cc9763c8cf1766337f4bae385ced20d49abad/Engine/Source/Runtime/RHI/Public/RHICommandList.h#L5084))| `FDynamicRHI::RHICreateIndexBuffer()`'s implmentation([link](https://github.com/EpicGames/UnrealEngine/blob/3b09b8309ae4c80c2a29b4e83aa2258baf829320/Engine/Source/Runtime/RHI/Public/DynamicRHI.h#L532))|same as above | same as above 
| Uniform Buffer | `FPrimitiveSceneProxy::UniformBuffer`([link](https://github.com/EpicGames/UnrealEngine/blob/39c685b761f485bd861a2dc3988336c1e0540b45/Engine/Source/Runtime/Engine/Public/PrimitiveSceneProxy.h#L1079))<br>`FMaterialRenderProxy::UniformExpressionCache[]`([link](https://github.com/EpicGames/UnrealEngine/blob/534dd2cadda59f8d31f3dd8b80d5cd89f084a4f8/Engine/Source/Runtime/Engine/Public/MaterialShared.h#L1920)),<br>etc. | `FPrimitiveSceneProxy::UpdateUniformBuffer()`([link](https://github.com/EpicGames/UnrealEngine/blob/2a4b8997a44763a5417d82556dffcb6db2a0f2ec/Engine/Source/Runtime/Engine/Private/PrimitiveSceneProxy.cpp#L339))<br>`FMaterialRenderProxy::EvaluateUniformExpressions()`([link](https://github.com/EpicGames/UnrealEngine/blob/5ddcfbc323500f0fdb93a2d1c06cd5cbfb813ca5/Engine/Source/Runtime/Engine/Private/Materials/MaterialShared.cpp#L2387))<br>`TUniformBufferRef<TBufferStruct>::CreateUniformBufferImmediate()`([link](https://github.com/EpicGames/UnrealEngine/blob/410c720ac7c70747a68b46cf93fdc2b762206c42/Engine/Source/Runtime/RenderCore/Public/UniformBuffer.h#L22)),<br>etc.|`CreateUniformBuffer()`([link](https://github.com/EpicGames/UnrealEngine/blob/7a2cc9763c8cf1766337f4bae385ced20d49abad/Engine/Source/Runtime/RHI/Public/RHICommandList.h#L4020))| `FDynamicRHI::RHICreateUniformBuffer()`'s implmentation([link](https://github.com/EpicGames/UnrealEngine/blob/3b09b8309ae4c80c2a29b4e83aa2258baf829320/Engine/Source/Runtime/RHI/Public/DynamicRHI.h#L527))| same as above | same as above 
| Shader | `GGraphicsPipelineCache`([link](https://github.com/EpicGames/UnrealEngine/blob/aa9705149bf144a3d016174ab3ac46b5205ca4f1/Engine/Source/Runtime/RHI/Private/PipelineStateCache.cpp#L601)) |`FMeshDrawCommand::SubmitDraw()`([link](https://github.com/EpicGames/UnrealEngine/blob/54f8b2537d8743c2ccd0daea780dc6694ad38213/Engine/Source/Runtime/Renderer/Private/MeshPassProcessor.cpp#L1150)), etc.|`SetGraphicsPipelineState()`([link](https://github.com/EpicGames/UnrealEngine/blob/aa9705149bf144a3d016174ab3ac46b5205ca4f1/Engine/Source/Runtime/RHI/Private/PipelineStateCache.cpp#L303))|`FDynamicRHI::RHICreateGraphicsPipelineState()`([link](https://github.com/EpicGames/UnrealEngine/blob/3b09b8309ae4c80c2a29b4e83aa2258baf829320/Engine/Source/Runtime/RHI/Public/DynamicRHI.h#L499))|`mtlpp::Device::NewRenderPipelineState()`| `[MTLCompiler compileFunctionInternal]`
| RenderPass | `GRHICommandList`([link](https://github.com/EpicGames/UnrealEngine/blob/7d15cb2de6bc13add5af776a26ce6d3bb729aa41/Engine/Source/Runtime/RHI/Private/RHICommandList.cpp#L145)) |`FMobileSceneRenderer::Render()`([link](https://github.com/EpicGames/UnrealEngine/blob/a3f1a9134b3163561b1e7557fcfea7235ac2d9a3/Engine/Source/Runtime/Renderer/Private/MobileShadingRenderer.cpp#L610)), etc.|`BeginRenderPass()`([link](https://github.com/EpicGames/UnrealEngine√ç/blob/7a2cc9763c8cf1766337f4bae385ced20d49abad/Engine/Source/Runtime/RHI/Public/RHICommandList.h#L3468))|`IRHICommandContext::RHIBeginRenderPass()`'s implementation([link](https://github.com/EpicGames/UnrealEngine/blob/3b29852588abe7944213ab0480db6c80435f29ea/Engine/Source/Runtime/RHI/Public/RHIContext.h#L613))|`mtlpp::CommandBuffer::RenderCommandEncoder()`| `MTLIOAccelCommandBufferStorageAllocResourceAtIndex`

All resources are allocated insdie render thread. Vertex buffer, index buffer, and textures are allocated from various `InitRHI()`s since they all implement `FRenderResource::InitRHI()`([link](https://github.com/EpicGames/UnrealEngine/blob/3b4ff4c5771927f73ea309e1d15257587c36acf4/Engine/Source/Runtime/RenderCore/Public/RenderResource.h#L94)) abstract method.

For your information, below is the full call stack for various allocaiton,
![](assets/rendering_metal_allocation.png)




<!--
Rendering resources are allocated in render thread. 80% of memory are allocated from `FRenderAssetUpdate::ScheduleRenderTask()`, while other 20% are spread among different `InitRHI()`s
-->

## Resources and Uniform Buffer

So far, we know Unreal allocates various resources and use `FRenderResource`'s derived implementation to hold the resource reference. But, how does it pass resources from the material shader into the GPU?

Recall in the [Rendering Basics](rendering.md) chapter that Unreal's material has lots of expressions, such as texture sample node. So the key question is, how does one expression relate to the resource?

In `FUniformExpressionSet::FillUniformBuffer()`([link](https://github.com/EpicGames/UnrealEngine/blob/940eb3a4a629936395b5b5ef078792d8679f0cbf/Engine/Source/Runtime/Engine/Private/Materials/MaterialUniformExpressions.cpp#L435)), expressions' value is extracted and fill into `TempBuffer`.

```c++
void FUniformExpressionSet::FillUniformBuffer(const FMaterialRenderContext& MaterialRenderContext, uint8* TempBuffer, ...) const {
	...
	void* BufferCursor = TempBuffer;
	...
	// Dump vector expression into the buffer.
	for(int32 VectorIndex = 0;VectorIndex < UniformVectorExpressions.Num();++VectorIndex) {
		FLinearColor VectorValue(0, 0, 0, 0);
		UniformVectorExpressions[VectorIndex]->GetNumberValue(MaterialRenderContext, VectorValue);

		FLinearColor* DestAddress = (FLinearColor*)BufferCursor;
		*DestAddress = VectorValue;
		BufferCursor = DestAddress + 1;
	}
	// Cache 2D texture uniform expressions.
	for(int32 ExpressionIndex = 0;ExpressionIndex < Uniform2DTextureExpressions.Num();ExpressionIndex++) {
		const UTexture* Value;
		Uniform2DTextureExpressions[ExpressionIndex]->GetTextureValue(MaterialRenderContext,MaterialRenderContext.Material,Value);
		void** ResourceTableTexturePtr = (void**)((uint8*)BufferCursor + 0 * SHADER_PARAMETER_POINTER_ALIGNMENT);
		void** ResourceTableSamplerPtr = (void**)((uint8*)BufferCursor + 1 * SHADER_PARAMETER_POINTER_ALIGNMENT);
		BufferCursor = ((uint8*)BufferCursor) + (SHADER_PARAMETER_POINTER_ALIGNMENT * 2);
		...
		*ResourceTableTexturePtr = Value->TextureReference.TextureReferenceRHI;
		FSamplerStateRHIRef* SamplerSource = &Value->Resource->SamplerStateRHI;
		*ResourceTableSamplerPtr = *SamplerSource;
	}
	...
}
```

Where dose `TempBuffer` come from? From the call stack below, we can find out.

![](assets/rendering_filluniformbuffer.png)

Expressions' value is recoreded in `FMaterialRenderProxy::UniformExpressionCache[]`([link](https://github.com/EpicGames/UnrealEngine/blob/534dd2cadda59f8d31f3dd8b80d5cd89f084a4f8/Engine/Source/Runtime/Engine/Public/MaterialShared.h#L1920)). That makes sense, because `FMaterialRenderProxy` is the render proxy of a material.

```c++
/**
 * A material render proxy used by the renderer.
 */
class ENGINE_VTABLE FMaterialRenderProxy : public FRenderResource {
public:
	/** Cached uniform expressions. */
	mutable FUniformExpressionCache UniformExpressionCache[ERHIFeatureLevel::Num];
	/** Cached external texture immutable samplers */
	mutable FImmutableSamplerState ImmutableSamplerState;


	/**
	 * Evaluates uniform expressions and stores them in OutUniformExpressionCache.
	 * @param OutUniformExpressionCache - The uniform expression cache to build.
	 * @param MaterialRenderContext - The context for which to cache expressions.
	 */
	void ENGINE_API EvaluateUniformExpressions(FUniformExpressionCache& OutUniformExpressionCache, const FMaterialRenderContext& Context, class FRHICommandList* CommandListIfLocalMode = nullptr) const;

	virtual bool GetVectorValue(const FMaterialParameterInfo& ParameterInfo, FLinearColor* OutValue, const FMaterialRenderContext& Context) const = 0;
	virtual bool GetScalarValue(const FMaterialParameterInfo& ParameterInfo, float* OutValue, const FMaterialRenderContext& Context) const = 0;
	virtual bool GetTextureValue(const FMaterialParameterInfo& ParameterInfo,const UTexture** OutValue, const FMaterialRenderContext& Context) const = 0;

	// FRenderResource interface.
	ENGINE_API virtual void InitDynamicRHI() override;
	ENGINE_API virtual void ReleaseDynamicRHI() override;
	ENGINE_API virtual void ReleaseResource() override;
	...
private:
	/** 
	 * Tracks all material render proxies in all scenes, can only be accessed on the rendering thread.
	 * This is used to propagate new shader maps to materials being used for rendering.
	 */
	ENGINE_API static TSet<FMaterialRenderProxy*> MaterialRenderProxyMap;
	...
};
```

`FUniformExpressionCache` wraps a `FUniformBufferRHIRef`, which essentially is a reference to `FUniformBufferRHI`([link](https://github.com/EpicGames/UnrealEngine/blob/f1d65a58e687e4b9e0f71d7c661d9460c517e8f7/Engine/Source/Runtime/RHI/Public/RHIResources.h#L363)). 

So, the key question is, what is a uniform buffer?

Unreal uses *Uniform Buffer* to represent *Constant Buffer* and *Resource Table* in RHI. Different graphic API implements `FUniformBufferRHI` to create the actual constant buffer and resource table.

From `UniformExpressionSet::FillUniformBuffer()` above, we know it fills binary streams into the content of `FUniformBufferRHI`. It fills color as value into the binary stream as `FLinearColor`, and it fills texture as pointer `void*` with `TextureReferenceRHI`. Note all `FXXXRHIRef` is of type `TRefCountPtr<XXX>`, and `TRefCountPtr` is just a plain object with only one (RHI object) pointer([link]((https://github.com/EpicGames/UnrealEngine/blob/aa9705149bf144a3d016174ab3ac46b5205ca4f1/Engine/Source/Runtime/Core/Public/Templates/RefCounting.h#L301))) and no virtual methods hence no vtable, hence this pointer is copied into the binary stream . See also [C++ Object Model](http://lifegoo.pluskid.org/upload/doc/object_models/C++%20Object%20Model.pdf) for the C++ memory layout details.

> Which also means, if we need to modify `TRefCountPtr` (What?!), we must keep its memory layout's first word is always this RHI pointer, do not add virtual functions or new data member before this pointer

After the uniform binary stream content is filled, the content is pass to the RHI to create a new, or update an existed, uniform buffer([link](https://github.com/EpicGames/UnrealEngine/blob/5ddcfbc323500f0fdb93a2d1c06cd5cbfb813ca5/Engine/Source/Runtime/Engine/Private/Materials/MaterialShared.cpp#L2383)).

```c++
void FMaterialRenderProxy::EvaluateUniformExpressions(FUniformExpressionCache& OutUniformExpressionCache, const FMaterialRenderContext& Context, ...) const
{
	...
	const FRHIUniformBufferLayout& UniformBufferLayout = UniformExpressionSet.GetUniformBufferLayout();
	FMemMark Mark(FMemStack::Get());
	uint8* TempBuffer = FMemStack::Get().PushBytes(UniformBufferLayout.ConstantBufferSize, SHADER_PARAMETER_STRUCT_ALIGNMENT);

	UniformExpressionSet.FillUniformBuffer(Context, OutUniformExpressionCache, TempBuffer, UniformBufferLayout.ConstantBufferSize);
	
	...

		if (IsValidRef(OutUniformExpressionCache.UniformBuffer)) {
			RHIUpdateUniformBuffer(OutUniformExpressionCache.UniformBuffer, TempBuffer);
		}
		else {
			OutUniformExpressionCache.UniformBuffer = RHICreateUniformBuffer(TempBuffer, UniformBufferLayout, UniformBuffer_MultiFrame);
		}
	...
	OutUniformExpressionCache.bUpToDate = true;
}
```

Note when creating, content binary stream's layout format is also pass to RHI to deserialize the uniform buffer.

Different graphic API has different implementation of `FRHIUniformBuffer`, and holds the actual GPU buffer. 
```c++
class FRHIUniformBuffer : public FRHIResource {
	...
	/** Layout of the uniform buffer. */
	const FRHIUniformBufferLayout* Layout;
	uint32 LayoutConstantBufferSize;
};
```


`FD3D11UniformBuffer`([link](https://github.com/EpicGames/UnrealEngine/blob/bbb956438811f8c7004e9d03eec17e8d83bf7ddb/Engine/Source/Runtime/Windows/D3D11RHI/Public/D3D11Resources.h#L676))'s `Resource` holds the actual D3D11 buffer pointer:
```c++
/** Uniform buffer resource class. */
class FD3D11UniformBuffer : public FRHIUniformBuffer {
public:
	/** The D3D11 constant buffer resource */
	TRefCountPtr<ID3D11Buffer> Resource;
	...
	/** Resource table containing RHI references. */
	TArray<TRefCountPtr<FRHIResource> > ResourceTable;
	...
private:
	class FD3D11DynamicRHI* D3D11RHI;
};
```

`FMetalUniformBuffer`([link](https://github.com/EpicGames/UnrealEngine/blob/ecdba1fc606e95e54cc776a7ee9ae66bed353604/Engine/Source/Runtime/Apple/MetalRHI/Public/MetalResources.h#L1064))'s `Buffer` hold the actual Metal buffer reference which stores the contant value.
```c++
class FMetalRHIBuffer;
class FMetalUniformBuffer : public FRHIUniformBuffer, public FMetalRHIBuffer {
	...
	/** Resource table containing RHI references. */
	TArray<TRefCountPtr<FRHIResource> > ResourceTable;
};

class FMetalRHIBuffer {
	...
	// balsa buffer memory
	FMetalBuffer Buffer;
	// A temporary shared/CPU accessible buffer for upload/download
	FMetalBuffer CPUBuffer;
	/** Buffer for small buffers < 4Kb to avoid heap fragmentation. */
	FMetalBufferData* Data;
	// Initial buffer size.
	uint32 Size;
	...
};
```

In Direct3D, it's created via `FD3D11DynamicRHI::RHICreateUniformBuffer()`([link](https://github.com/EpicGames/UnrealEngine/blob/e99c0b858e283af77f7ca78e249fd6376da0e33d/Engine/Source/Runtime/Windows/D3D11RHI/Private/D3D11UniformBuffer.cpp#L174)),
![](assets/rendering_uniformbuffer_created3d11.png)

In iOS, `FMetalUniformBuffer::FMetalUniformBuffer()`([link](https://github.com/EpicGames/UnrealEngine/blob/f1d65a58e687e4b9e0f71d7c661d9460c517e8f7/Engine/Source/Runtime/Apple/MetalRHI/Private/MetalUniformBuffer.cpp#L177)) allocates about 120MB memory, which is huge.
![](assets/rendering_uniformbuffer_allocation.png)

To sum up, again, Unreal uses uniform buffer to reference the constant values buffer and the `FRHIResource` table. The constant value buffer is allocated in the GPU memory. The `ResourceTable` is an `TArray<FRHIResource>` allocated in the heap to store used pointer to the various `FRHIResource` objects, such as `FRHITexture2D`('s actual implementation, e.g. `FMetalTexture2D`).


## Shader Resource Bindings

Now, we've known how various resources are allocated, and how they are recorded in the uniform buffer. The next question is, how does the uniform buffer is chosen, and bind the resource to the GPU. Who does the job to pass the actual resource argument to the shader?

The mechanism *Shader (Resource) binding* binds a shader's resources to the shader.

Shader bindings are stored in `FMeshDrawCommand`, see the ownership chain below,

Shader binding data:

- `FMeshDrawShaderBindings FMeshDrawCommand::ShaderBindings`
- `FData FMeshDrawShaderBindings::Data`([link](https://github.com/EpicGames/UnrealEngine/blob/2336049575bc9eb9ea553045df9b57b75c549a8f/Engine/Source/Runtime/Renderer/Public/MeshPassProcessor.h#L761))

Shader binding layout:

- `FMeshDrawShaderBindings FMeshDrawCommand::ShaderBindings`
- `TArray<FMeshDrawShaderBindingsLayout> FMeshDrawShaderBindings::ShaderLayouts`([link](https://github.com/EpicGames/UnrealEngine/blob/2336049575bc9eb9ea553045df9b57b75c549a8f/Engine/Source/Runtime/Renderer/Public/MeshPassProcessor.h#L745))
- `class FMeshDrawSingleShaderBindings : public FMeshDrawShaderBindingsLayout`
- `const FShaderParameterMapInfo& FMeshDrawShaderBindingsLayout::ParameterMapInfo`

During building the mesh draw commands, `FMeshPassProcessor::BuildMeshDrawCommands<..>()` pulls the shader binding data from the shader, as follows,
![](assets/mdp_GetShaderBindings.png)

`FShaderParameterMapInfo`([link](https://github.com/EpicGames/UnrealEngine/blob/f1d65a58e687e4b9e0f71d7c661d9460c517e8f7/Engine/Source/Runtime/RenderCore/Public/Shader.h#L246)) describes the layout of shader's parameters. It contains parameters' base index and size, of various resources (e.g., Uniform Buffers, Texture Samplers, SRVs and loose parameter buffers). It's generated by shader compilation and reflection, it's serialized into `FShaderResource::ParameterMapInfo` during the game start up or the new level streamed in.

```c++
class FShaderParameterInfo
{
public:
	uint16 BaseIndex;
	uint16 Size;
	...
};
class FShaderParameterMapInfo
{
public:
	TArray<FShaderParameterInfo> UniformBuffers;
	TArray<FShaderParameterInfo> TextureSamplers;
	TArray<FShaderParameterInfo> SRVs;
	TArray<FShaderLooseParameterBufferInfo> LooseParameterBuffers;
	...
};
```

`FMeshDrawShaderBindingsLayout`([link](FMeshDrawShaderBindingsLayout)) references one `FShaderParameterMapInfo` and provides some additional layout accessors.   

```c++
/** Stores the number of each resource type that will need to be bound to a single shader, computed during shader reflection. */
class FMeshDrawShaderBindingsLayout
{
public:
	const FShaderParameterMapInfo& ParameterMapInfo;
	...
protected:
	inline uint32 GetUniformBufferOffset() const { return 0; }
	inline uint32 GetSamplerOffset() const
	{
		return ParameterMapInfo.UniformBuffers.Num() * sizeof(FRHIUniformBuffer*);
	}
	...
	friend class FMeshDrawShaderBindings;
};
```

`FMeshDrawSingleShaderBindings`([link](https://github.com/EpicGames/UnrealEngine/blob/f1d65a58e687e4b9e0f71d7c661d9460c517e8f7/Engine/Source/Runtime/Renderer/Public/MeshDrawShaderBindings.h#L93)) inherits from `FMeshDrawShaderBindingsLayout`, and does the actual resource binding according to the layout. Its `Data` is a pointer to the `FMeshDrawShaderBindings::Data`([link](https://github.com/EpicGames/UnrealEngine/blob/2336049575bc9eb9ea553045df9b57b75c549a8f/Engine/Source/Runtime/Renderer/Public/MeshPassProcessor.h#L761)), which is a binary stream recording shader resources' references. And its binding methods accept *Shader Resource Parameter* and the resource (value or pointer) and do the actual binding.

```c++
class FMeshDrawSingleShaderBindings : public FMeshDrawShaderBindingsLayout
{
private:
	uint8* Data;

public:
	template<typename UniformBufferStructType>
	void Add(const TShaderUniformBufferParameter<UniformBufferStructType>& Parameter, const TUniformBufferRef<UniformBufferStructType>& Value)
	{
		...
		// writes value to `Data` with correct offset
		WriteBindingUniformBuffer(Value.GetReference(), Parameter.GetBaseIndex());
	}
	...
	void AddTexture(
		FShaderResourceParameter TextureParameter,
		FShaderResourceParameter SamplerParameter,
		FRHISamplerState* SamplerStateRHI,
		FRHITexture* TextureRHI)
	{
		...
		// writes value to `Data` with correct offset
		WriteBindingTexture(TextureRHI, TextureParameter.GetBaseIndex());
		...
		WriteBindingSampler(SamplerStateRHI, SamplerParameter.GetBaseIndex());
	}
	...
};
```

Take the binding method `FMeshDrawSingleShaderBindings::WriteBindingUniformBuffer()`([link](https://github.com/EpicGames/UnrealEngine/blob/e96c209a4caf4de232dffe4c222197a6c7f461dc/Engine/Source/Runtime/Renderer/Public/MeshDrawShaderBindings.h#L287)) for example, it accept the input uniform buffer pointer, and the input parameter's `BaseIndex`, and find the array index in `ParameterMapInfo.UniformBuffers` for corresponding `BaseIndex`. If found, the uniform buffer pointer value is assigned to `Data`.

```c++
inline void WriteBindingUniformBuffer(FRHIUniformBuffer* Value, uint32 BaseIndex)
{
	int32 FoundIndex = -1;

	for (int32 SearchIndex = 0; SearchIndex < ParameterMapInfo.UniformBuffers.Num(); SearchIndex++)
	{
		FShaderParameterInfo Parameter = ParameterMapInfo.UniformBuffers[SearchIndex];

		if (Parameter.BaseIndex == BaseIndex)
		{
			FoundIndex = SearchIndex;
			break;
		}
	}

	// USE: If found the index, the value is written into `Data` with correct index.
	if (FoundIndex >= 0)
	{
		GetUniformBufferStart()[FoundIndex] = Value;
	}
}
```
So, the next 2 key questions are, the begninning and the termination of this shader resource flow:

1. the beginning: how does shader parameter layout (`FShaderParameterMapInfo`) is generated,
1. the termination: how does the shader binding data (`FMeshDrawShaderBindings::Data`, which records constant data and resource referneces) go to GPU.

For the second question, we can know from below image that, in Metal, the `Data` goes into Metal via the following stack, including `FMetalStateCache::CommitResourceTable()` and Metal's enocder set resource APIs.

![](assets/rendering_commit_resource_table.png)
![](assets/rendering_set_texture_from_resource_table.png)

![](assets/rendering_set_resources_from_table.png)


But since `BuildMeshDrawCommands<>()`([link](https://github.com/EpicGames/UnrealEngine/blob/697a6f07ef518d03ef3611efdafc2e9a89b0fc3c/Engine/Source/Runtime/Renderer/Public/MeshPassProcessor.inl#L10)) is the only place that do the shader bindings, how can it handles various different bindings? In fact, it's a template method, the template argument make it possible to handle it, see the snippet below,

```c++
template<typename PassShadersType, typename ShaderElementDataType>
void FMeshPassProcessor::BuildMeshDrawCommands(..., PassShadersType PassShaders, const ShaderElementDataType& ShaderElementData)
{
	...
	if (PassShaders.VertexShader)
	{
		FMeshDrawSingleShaderBindings ShaderBindings = SharedMeshDrawCommand.ShaderBindings.GetSingleShaderBindings(SF_Vertex);
		PassShaders.VertexShader->GetShaderBindings(..., ShaderElementData, ShaderBindings);
	}
	if (PassShaders.PixelShader) { ... }
	...

	const int32 NumElements = MeshBatch.Elements.Num();

	for (int32 BatchElementIndex = 0; BatchElementIndex < NumElements; BatchElementIndex++)
	{
		if ((1ull << BatchElementIndex) & BatchElementMask)
		{
			const FMeshBatchElement& BatchElement = MeshBatch.Elements[BatchElementIndex];
			FMeshDrawCommand& MeshDrawCommand = DrawListContext->AddCommand(SharedMeshDrawCommand);

			if (PassShaders.VertexShader)
			{
				FMeshDrawSingleShaderBindings VertexShaderBindings = MeshDrawCommand.ShaderBindings.GetSingleShaderBindings(SF_Vertex);
				PassShaders.VertexShader->GetElementShaderBindings(..., ShaderElementData, VertexShaderBindings);
			}
			if (PassShaders.PixelShader) { ... }
			...
		}
	}
}
```

Based on the input template argument `PassShadersType` and `ShaderElementDataType`, `BuildMeshDrawCommands<>()` can handle different passes and diffrent shader bindings, by calling the template's. 

Take `TMobileBasePassPSPolicyParamType<FUniformLightMapPolicy>::GetShaderBindings()`([link](https://github.com/EpicGames/UnrealEngine/blob/049c0e99ee7f4ff84404a17ad4b53daa85173daa/Engine/Source/Runtime/Renderer/Private/MobileBasePass.cpp#L433)) for example, which is the most common pixel shader parameter which handles lightmap,

```c++
void FUniformLightMapPolicy::GetPixelShaderBindings(
	const FPrimitiveSceneProxy* PrimitiveSceneProxy,
	const ElementDataType& ShaderElementData,
	const PixelParametersType* PixelShaderParameters,
	FMeshDrawSingleShaderBindings& ShaderBindings)
{
	FRHIUniformBuffer* PrecomputedLightingBuffer = nullptr;
	FRHIUniformBuffer* LightmapResourceClusterBuffer = nullptr;
	FRHIUniformBuffer* IndirectLightingCacheBuffer = nullptr;

	SetupLCIUniformBuffers(PrimitiveSceneProxy, ShaderElementData, PrecomputedLightingBuffer, LightmapResourceClusterBuffer, IndirectLightingCacheBuffer);

	ShaderBindings.Add(PixelShaderParameters->PrecomputedLightingBufferParameter, PrecomputedLightingBuffer);
	ShaderBindings.Add(PixelShaderParameters->IndirectLightingCacheParameter, IndirectLightingCacheBuffer);
	ShaderBindings.Add(PixelShaderParameters->LightmapResourceCluster, LightmapResourceClusterBuffer);
}
```

![](assets/mdp_TMobileBasePassXSPolicyParamType.png)

Its `ShaderElementData` is of type `const TMobileBasePassShaderElementData<FUniformLightMapPolicy>&`, therefore, it can handles custom shader bindings about lightmaps, i.e., it calls `FUniformLightMapPolicy::GetPixelShaderBindings()` with `ShaderElementData.LightMapPolicyElementData`.  


Note that the lightmap shader resources is recored in a "uniform buffer", which records resource "handle"s, not the resource data, see the image below,

![](assets/LightmapResourceClusterBuffer.png)

After the uniform buffer pointer is collected, `FUniformLightMapPolicy::GetPixelShaderBindings()` add them into the shader binding with *Shader Parameter* as the key.

The actual lightmap shader parameter is decaled as below([link](https://github.com/EpicGames/UnrealEngine/blob/948dcc11a7aec7a3d4a5a75ce96d56cbdcb45390/Engine/Source/Runtime/Engine/Public/SceneManagement.h#L666)),
```c++
BEGIN_GLOBAL_SHADER_PARAMETER_STRUCT(FLightmapResourceClusterShaderParameters,ENGINE_API)
	SHADER_PARAMETER_TEXTURE(Texture2D, LightMapTexture)
	SHADER_PARAMETER_TEXTURE(Texture2D, SkyOcclusionTexture) 
	SHADER_PARAMETER_SAMPLER(SamplerState, LightMapSampler) 
	SHADER_PARAMETER_SAMPLER(SamplerState, SkyOcclusionSampler) 
	...
END_GLOBAL_SHADER_PARAMETER_STRUCT()
```

That's the boilerplate to declare shader parameters in c++, see macro `BEGIN_SHADER_PARAMETER_STRUCT`([link](https://github.com/EpicGames/UnrealEngine/blob/f1d65a58e687e4b9e0f71d7c661d9460c517e8f7/Engine/Source/Runtime/RenderCore/Public/ShaderParameterMacros.h#L764)) and `BEGIN_GLOBAL_SHADER_PARAMETER_STRUCT`([link](https://github.com/EpicGames/UnrealEngine/blob/f1d65a58e687e4b9e0f71d7c661d9460c517e8f7/Engine/Source/Runtime/RenderCore/Public/ShaderParameterMacros.h#L782)) for more details.




In the end, these parameters are translated into the actual shader parameter, based on the actual graphic API, e.g., Metal in iOS:
![](assets/LightmapResourceClusterInMetal.png)

```

`main/scripting.md`:

```md

# [WIP] Unreal Source Explained

Unreal Source Explained (USE) is an Unreal source code analysis, based on profilers.  
For full Table of Contents and more infomation, see the [repo](https://github.com/donaldwuid/unreal_source_explained) in github.



# Blueprints Visual Scripting

*[Blueprints](https://docs.unrealengine.com/en-US/Engine/Blueprints/Overview/index.html)* is Unreal's visual scripting, it is usually used to write some high-level logic, such as gameplay, UI, etc.


Blueprints is [*event driven*](https://en.wikipedia.org/wiki/Event-driven_programming), and they usually look like this:
![](assets/blueprints_demo.png)
The above image is the a ActionRPG's **BP_PlayerController** blueprints event graphs.  
There are two red titled nodes, which are the events node: **InputAction Pause** and **InputAction Inventory**. Event nodes are the start porint of a graph, hence, there are two graphs in the image. The top graph is handling the logic when the pause event triggers, and the bottom graph is handling the inventory.

Like Java and C# having their [*process virtual machine*](https://en.wikipedia.org/wiki/Virtual_machine#Process_virtual_machines) (or just *virtual machine*, VM), Blueprints is also running on a Unreal implemented virtual machine.   
And the following image is the native call stacks of all blueprints of ActionRPG, including the above **BP_PlayerController**:
![](assets/blueprints_callstack.png)
Important calls are highlighted. You may observe:
- they all start from `UObject::ProcessEvent()`, and end with `FFrame::StepXX()`;
- `FFrame` appears as the parameter all the way along the call stacks;

`FFrame`([link](https://github.com/EpicGames/UnrealEngine/blob/bf95c2cbc703123e08ab54e3ceccdd47e48d224a/Engine/Source/Runtime/CoreUObject/Public/UObject/Stack.h#L83)) is the most important class for the blueprints VM. It should have a better name **FCallStackFrame** to emphasize its relationship with VM and [*call stack frame*](https://en.wikipedia.org/wiki/Call_stack#Structure): each stack frame corresponds to a call to a subroutine wich has not yet termined with a return.   
Anyway, don't confuse that `FFrame` has nothing to do with rendering frame.  

Here is the key fields and methods of `FFrame`, each of its field is additionally commented:

```c++
//
// Information about script execution at one stack level.
//
struct FFrame : public FOutputDevice
{	
public:
	// Variables.
	// the function that is executing
	UFunction* Node;
	// the object that is executing ("this")
	UObject* Object;
	uint8* Code;
	uint8* Locals;

	/** Previous frame on the stack */
	FFrame* PreviousFrame;

	/** contains information on any out parameters */
	FOutParmRec* OutParms;

	/** Currently executed native function */
	UFunction* CurrentNativeFunction;

	...

public:

	// Constructors.
	FFrame( UObject* InObject, UFunction* InNode, void* InLocals, FFrame* InPreviousFrame = NULL, UField* InPropertyChainForCompiledIn = NULL );
	...

	// Functions.
	COREUOBJECT_API void Step( UObject* Context, RESULT_DECL );

	...
};
```

A `FFrame` holds the `UObject* Object` as the object that is executing, `UFunction* Node` and uses the `FFrame* PreviousFrame` to link to the previous stack frame.

There is actually no a concrete stack container of `FFrame` in runtime. The only two places where create the new `FFrame` are `UObject::ProcessEvent()`([link](https://github.com/EpicGames/UnrealEngine/blob/bf95c2cbc703123e08ab54e3ceccdd47e48d224a/Engine/Source/Runtime/CoreUObject/Private/UObject/ScriptCore.cpp#L1855)) and `ProcessScriptFunction()`([link](https://github.com/EpicGames/UnrealEngine/blob/bf95c2cbc703123e08ab54e3ceccdd47e48d224a/Engine/Source/Runtime/CoreUObject/Private/UObject/ScriptCore.cpp#L715)):

```c++
/*-----------------------------
	Virtual Machine
-----------------------------*/

/** Called by VM to execute a UFunction with a filled in UStruct of parameters */
void UObject::ProcessEvent( UFunction* Function, void* Parms )
{
	...

	uint8* Frame = NULL;
	...
	const bool bUsePersistentFrame = (NULL != Frame);
	if (!bUsePersistentFrame)
	{
		Frame = (uint8*)FMemory_Alloca(Function->PropertiesSize);
		// zero the local property memory
		FMemory::Memzero(Frame + Function->ParmsSize, Function->PropertiesSize - Function->ParmsSize);
	}

	// initialize the parameter properties
	FMemory::Memcpy(Frame, Parms, Function->ParmsSize);

	// Create a new local execution stack.
	FFrame NewStack(this, Function, Frame, NULL, Function->Children);

	...

	// Call native function or UObject::ProcessInternal.
	Function->Invoke(this, NewStack, ReturnValueAddress);
	
	...
}
```

```c++

// Helper function to set up a script function, and then execute it using ExecFtor.
// ...
template<typename Exec>
void ProcessScriptFunction(UObject* Context, UFunction* Function, FFrame& Stack, RESULT_DECL, Exec ExecFtor)
{
	...
	FFrame NewStack(Context, Function, nullptr, &Stack, Function->Children);
	
	...

	if( Function->Script.Num() > 0)
	{
		// Execute the code.
		ExecFtor( Context, NewStack, RESULT_PARAM );
	}
	...
}

```
```

`main/thread.md`:

```md

# [WIP] Unreal Source Explained

Unreal Source Explained (USE) is an Unreal source code analysis, based on profilers.  
For full Table of Contents and more infomation, see the [repo](https://github.com/donaldwuid/unreal_source_explained) in github.



# Thread Management

## RunnableThread and Runnable


`FRunnableThread`([link](https://github.com/EpicGames/UnrealEngine/blob/bf95c2cbc703123e08ab54e3ceccdd47e48d224a/Engine/Source/Runtime/Core/Public/HAL/RunnableThread.h#L19)) is a cross platfrom abstract "native thread" interface in Unreal. It has different implementaion in different OS, for example, `FRunnableThreadWin`([link](https://github.com/EpicGames/UnrealEngine/blob/bf95c2cbc703123e08ab54e3ceccdd47e48d224a/Engine/Source/Runtime/Core/Private/Windows/WindowsRunnableThread.h#L22)) in Windows, `FRunnableThreadPThread`([link](https://github.com/EpicGames/UnrealEngine/blob/bf95c2cbc703123e08ab54e3ceccdd47e48d224a/Engine/Source/Runtime/Core/Private/HAL/PThreadRunnableThread.h#L23)) in [POSIX-compliant](https://en.wikipedia.org/wiki/POSIX) OS, i.e., iOS and Android.

`FRunnable`([link](https://github.com/EpicGames/UnrealEngine/blob/bf95c2cbc703123e08ab54e3ceccdd47e48d224a/Engine/Source/Runtime/Core/Public/HAL/Runnable.h#L19))'s inherited class represets the actual running workload, e.g., `FRenderingThread`([link](https://github.com/EpicGames/UnrealEngine/blob/bf95c2cbc703123e08ab54e3ceccdd47e48d224a/Engine/Source/Runtime/RenderCore/Private/RenderingThread.cpp#L394)).

Each `FRunnableThread` runs **one** `FRunnable`.

Take the POSIX `FRunnableThreadPThread` for example, static function `_ThreadProc()`([link](https://github.com/EpicGames/UnrealEngine/blob/bf95c2cbc703123e08ab54e3ceccdd47e48d224a/Engine/Source/Runtime/Core/Private/HAL/PThreadRunnableThread.h#L161)) is the thread entry point and it calls every `FRunnableThreadPThread::Run()`, as follows.
```c++
/**
* The thread entry point. Simply forwards the call on to the right
* thread main function
*/
static void *STDCALL _ThreadProc(void *pThis) {
	FRunnableThreadPThread* ThisThread = (FRunnableThreadPThread*)pThis;
	...
	// run the thread!
	ThisThread->PreRun();
	ThisThread->Run();
	ThisThread->PostRun();

	pthread_exit(NULL);
	return NULL;
}
```


then, `FRunnableThreadPThread::Run()` calls `FRunnable::Run()`([link](https://github.com/EpicGames/UnrealEngine/blob/bf95c2cbc703123e08ab54e3ceccdd47e48d224a/Engine/Source/Runtime/Core/Private/HAL/PThreadRunnableThread.cpp#L25)).

RunnableThread and Runnable is the low-level thread management in Unreal. The following Async Task and Task Graph depend on Runnable.

### Thread priority and affinity

Priority determines **how** threads are scheduled amoung each other, you first? or he first.
Affinity determines **where** threads are running, the performant big core? or the power-efficent little core.

Thread's priority is usually set when they are created, as follow,

![](assets/SetThreadPriority.png)


at the bottom, priority is set by `FRunnableThreadPThread::SetThreadPriority()`[(link)](https://github.com/EpicGames/UnrealEngine/blob/4.27/Engine/Source/Runtime/Core/Private/HAL/PThreadRunnableThread.h#L63) and it calls UNIX `pthread_setschedparam()` [(link)](https://developer.apple.com/library/archive/documentation/Darwin/Conceptual/KernelProgramming/scheduler/scheduler.html). It translate Unreal's `NewPriority` to platform's actual priority integer, then override current schedule parameter's `sched_priority`. And change the policy to `SCHED_RR` which means [*Round Robin*](https://en.wikipedia.org/wiki/Round-robin_scheduling) and each thread executes in equal time-interval and yield to next thread. Next thread is determined by the priority.

![](assets/PThreadRunnableThread_SetThreadPriority.png)

> But is `SCHED_RR` a good default policy for all threads? Maybe we should try `SCHED_OTHER` as default policy, and only set those more-realtime-like threads to be  `SCHED_RR`, such as main thread, render thread (and RHI thread if enabled).


Though Unreal implements thread affinity APIs, it doesn't call them by default and use default thread affinity. You can call them manually.

Android can use `FAndroidPlatformProcess::SetThreadAffinityMask()`[(link)](https://github.com/EpicGames/UnrealEngine/blob/4.27/Engine/Source/Runtime/Core/Private/Android/AndroidPlatformProcess.cpp#L80) to pin thread to a specific CPU core, it internally calls `__NR_sched_setaffinity`.

Though in iOS it also provides `FIOSPlatformProcess::SetThreadAffinityMask()`[(link)](https://github.com/EpicGames/UnrealEngine/blob/4.27/Engine/Source/Runtime/Core/Private/IOS/IOSPlatformProcess.cpp#L109), but note that macOS and iOS doens't support explicit thread to processor binding. They can only use [thread_policy_set()](https://developer.apple.com/library/archive/releasenotes/Performance/RN-AffinityAPI/index.html) to separate threads into different *affinity set*, i.e., threads with different should run on diffrent logical processors. Threads with default affinity are freely scheduled by system and tends to run on idle processors.
## Queued Thread and Async Task
Queued Thread and Async Task is Unreal's [*thread pool*](https://en.wikipedia.org/wiki/Thread_pool) implementation. All kinds of tasks are scheduled among a pool of threads.  
![](assets/general_thread_pool.png)

`FQueuedThreadPoolBase`([link](https://github.com/EpicGames/UnrealEngine/blob/bf95c2cbc703123e08ab54e3ceccdd47e48d224a/Engine/Source/Runtime/Core/Private/HAL/ThreadingBase.cpp#L599)) manages this task queue and thread queue, as follow,
```c++
/**
 * Implementation of a queued thread pool.
 */
class FQueuedThreadPoolBase : public FQueuedThreadPool {
protected:
	/** The work queue to pull from. */
	TArray<IQueuedWork*> QueuedWork;
	/** The thread pool to dole work out to. */
	TArray<FQueuedThread*> QueuedThreads;
	/** All threads in the pool. */
	TArray<FQueuedThread*> AllThreads;
	...
};
```

There are 4 threads pools([link](https://github.com/EpicGames/UnrealEngine/blob/bf95c2cbc703123e08ab54e3ceccdd47e48d224a/Engine/Source/Runtime/Core/Private/HAL/ThreadingBase.cpp#L19)) in maximum, but the most important is the `GThreadPool`, which is the default thread pool for most tasks.

`FQueuedThread`([link](https://github.com/EpicGames/UnrealEngine/blob/bf95c2cbc703123e08ab54e3ceccdd47e48d224a/Engine/Source/Runtime/Core/Private/HAL/ThreadingBase.cpp#L462)) inherits from `FRunnable`, it represents the task worker thread. Its `Run()` waits for its `DoWorkEvent`, if signaled, it runs its current `QueuedWork` by calling `IQueuedWork::DoThreadedWork()`, as follow,

```c++
class FQueuedThread : public FRunnable {
protected:
	/** The event that tells the thread there is work to do. */
	FEvent* DoWorkEvent;
	/** The work this thread is doing. */
	IQueuedWork* volatile QueuedWork;
	/** The pool this thread belongs to. */
	class FQueuedThreadPool* OwningThreadPool;
	/** My Thread  */
	FRunnableThread* Thread;

	virtual uint32 Run() override {
		while (!TimeToDie.Load(EMemoryOrder::Relaxed)) {
			// We need to wait for shorter amount of time
			bool bContinueWaiting = true;
			while( bContinueWaiting ) {
				// Wait for some work to do
				bContinueWaiting = !DoWorkEvent->Wait( 10 );
			}

			IQueuedWork* LocalQueuedWork = QueuedWork;
			QueuedWork = nullptr;
			FPlatformMisc::MemoryBarrier();
			while (LocalQueuedWork) {
				// Tell the object to do the work
				LocalQueuedWork->DoThreadedWork();
				// Let the object cleanup before we remove our ref to it
				LocalQueuedWork = OwningThreadPool->ReturnToPoolOrGetNextJob(this);
			} 
		}
		return 0;
	}
	...
	void DoWork(IQueuedWork* InQueuedWork) {
		// Tell the thread the work to be done
		QueuedWork = InQueuedWork;
		FPlatformMisc::MemoryBarrier();
		// Tell the thread to wake up and do its job
		DoWorkEvent->Trigger();
	}
};
```

`FEngineLoop::PreInit()`([link](https://github.com/EpicGames/UnrealEngine/blob/bf95c2cbc703123e08ab54e3ceccdd47e48d224a/Engine/Source/Runtime/Launch/Private/LaunchEngineLoop.cpp#L1804)) calls `FQueuedThreadPoolBase::Create()`([link](https://github.com/EpicGames/UnrealEngine/blob/bf95c2cbc703123e08ab54e3ceccdd47e48d224a/Engine/Source/Runtime/Core/Private/HAL/ThreadingBase.cpp#L655)) to creates `FQueuedThread`s. 
![](assets/fqueuedthread_creation.png)

`IQueuedWork`([link](https://github.com/EpicGames/UnrealEngine/blob/bf95c2cbc703123e08ab54e3ceccdd47e48d224a/Engine/Source/Runtime/Core/Public/Misc/IQueuedWork.h#L16)) is the task interface, it can't be any simpler:
```c++
class IQueuedWork {
public:
	virtual void DoThreadedWork() = 0;
	virtual void Abandon() = 0;

public:
	virtual ~IQueuedWork() { }
};
```

<!--
`FQueuedThreadPoolBase` schedules each `IQueuedWork` into a `FQueuedThread`, each time the schedule start one work, it binds the work and thread into the `FQueuedThread`.
-->

`IQueuedWork`'s most important implementation is `FAsyncTask`([link](https://github.com/EpicGames/UnrealEngine/blob/bf95c2cbc703123e08ab54e3ceccdd47e48d224a/Engine/Source/Runtime/Core/Public/Async/AsyncWork.h#L207)).  
`FAsyncTask` is a template class, you can create your own async task class as the sample code in `FAsyncTask`'s comment([link](https://github.com/EpicGames/UnrealEngine/blob/bf95c2cbc703123e08ab54e3ceccdd47e48d224a/Engine/Source/Runtime/Core/Public/Async/AsyncWork.h#L156)). Various specific tasks start their work as the following.
![](assets/asynctask_start.png)


## Task Graph
Parallel programming is hard, multithreaded programming in fine granularity is even harder, because you may spend lots of time to take care of locking, waiting, race condition in every detailed level. 

Task Graph is a parallel programming with coarse granularity, and it handles dependency among async tasks. A simplified task graph of a game may be depicted as follow:

![](assets/game_task_graph.png)

We can divide the whole game into several big tasks, tasks in parallel can shared read some data but never shared write, tasks with dependency must finish in order. 


You can create your own task as the demo code in `TGraphTask`'s comment([link](https://github.com/EpicGames/UnrealEngine/blob/bf95c2cbc703123e08ab54e3ceccdd47e48d224a/Engine/Source/Runtime/Core/Public/Async/TaskGraphInterfaces.h#L698)). Keep in mind that the task argument can not be references, but pointer is OK.  
The following image is the call stacks filtered by "TGraphTask", you may notice the both the render thread and the game thread use the task graph to accomplish many important tasks, even include the world ticking.
![](assets/unreal_task_graph.png)



`FTaskGraphImplementation`([link](https://github.com/EpicGames/UnrealEngine/blob/bf95c2cbc703123e08ab54e3ceccdd47e48d224a/Engine/Source/Runtime/Core/Private/Async/TaskGraph.cpp#L1124)) is the most important manager of Task Graph, it manages an array of `FWorkerThread`s,
```c++
/**
*	FTaskGraphImplementation
*	Implementation of the centralized part of the task graph system.
*	These parts of the system have no knowledge of the dependency graph, they exclusively work on tasks.
**/
class FTaskGraphImplementation : public FTaskGraphInterface {
	...
	/** Per thread data. **/
	FWorkerThread		WorkerThreads[MAX_THREADS];
	/** Number of threads actually in use. **/
	int32				NumThreads;
	/** Number of named threads actually in use. **/
	int32				NumNamedThreads;
	/** Number of tasks thread sets for priority **/
	int32				NumTaskThreadSets;
	/** Number of tasks threads per priority set **/
	int32				NumTaskThreadsPerSet;
	...
}
```

`FWorkerThread`([link](https://github.com/EpicGames/UnrealEngine/blob/bf95c2cbc703123e08ab54e3ceccdd47e48d224a/Engine/Source/Runtime/Core/Private/Async/TaskGraph.cpp#L1100)) is a wrapper of the running thread and the task.
```c++
struct FWorkerThread {
	/** The actual FTaskThread that manager this task **/
	FTaskThreadBase*	TaskGraphWorker;
	/** For internal threads, the is non-NULL and holds the information about the runable thread that was created. **/
	FRunnableThread*	RunnableThread;
	/** For external threads, this determines if they have been "attached" yet. Attachment is mostly setting up TLS for this individual thread. **/
	bool				bAttached;
	...
};
```

`FTaskThreadBase`([link](https://github.com/EpicGames/UnrealEngine/blob/bf95c2cbc703123e08ab54e3ceccdd47e48d224a/Engine/Source/Runtime/Core/Private/Async/TaskGraph.cpp#L396)) implements `FRunnable`, and it has only two inherited class: 
- `FNamedTaskThread`([link](https://github.com/EpicGames/UnrealEngine/blob/bf95c2cbc703123e08ab54e3ceccdd47e48d224a/Engine/Source/Runtime/Core/Private/Async/TaskGraph.cpp#L570)), named task thread runs the engine built-in tasks, there are 5 named thread([link](https://github.com/EpicGames/UnrealEngine/blob/bf95c2cbc703123e08ab54e3ceccdd47e48d224a/Engine/Source/Runtime/Core/Public/Async/TaskGraphInterfaces.h#L51)): `StatsThread`, `RHIThread`, `AudioThread`, `GameThread` and `ActualRenderingThread`.
- `FTaskThreadAnyThread`([link](https://github.com/EpicGames/UnrealEngine/blob/bf95c2cbc703123e08ab54e3ceccdd47e48d224a/Engine/Source/Runtime/Core/Private/Async/TaskGraph.cpp#L838)), unnamed task thread runs the user defined tasks.

They both have its own internal `FThreadTaskQueue` implementation and queue instance as data member. And `FTaskGraphImplementation::QueueTask()` schedues tasks into the corresponding task queues.

```c++
virtual void QueueTask(FBaseGraphTask* Task, ENamedThreads::Type ThreadToExecuteOn, ENamedThreads::Type InCurrentThreadIfKnown = ENamedThreads::AnyThread) final override {
	...
	ENamedThreads::Type CurrentThreadIfKnown;
	if (ENamedThreads::GetThreadIndex(InCurrentThreadIfKnown) == ENamedThreads::AnyThread) {
		CurrentThreadIfKnown = GetCurrentThread();
	}
	else {
		CurrentThreadIfKnown = ENamedThreads::GetThreadIndex(InCurrentThreadIfKnown);
		checkThreadGraph(CurrentThreadIfKnown == ENamedThreads::GetThreadIndex(GetCurrentThread()));
	}
	{
		int32 QueueToExecuteOn = ENamedThreads::GetQueueIndex(ThreadToExecuteOn);
		ThreadToExecuteOn = ENamedThreads::GetThreadIndex(ThreadToExecuteOn);
		FTaskThreadBase* Target = &Thread(ThreadToExecuteOn);
		// POI begin
		if (ThreadToExecuteOn == ENamedThreads::GetThreadIndex(CurrentThreadIfKnown)) {
			Target->EnqueueFromThisThread(QueueToExecuteOn, Task);
		}
		else {
			Target->EnqueueFromOtherThread(QueueToExecuteOn, Task);
		}
		// POI end
	}
}
```

Named task thread are created in various places. But the unnamed task threads are created inside the constructor([link](https://github.com/EpicGames/UnrealEngine/blob/bf95c2cbc703123e08ab54e3ceccdd47e48d224a/Engine/Source/Runtime/Core/Private/Async/TaskGraph.cpp#L1200)) of `FTaskGraphImplementation`, we can observe this by the thread creation([link](https://github.com/EpicGames/UnrealEngine/blob/bf95c2cbc703123e08ab54e3ceccdd47e48d224a/Engine/Source/Runtime/Core/Private/Async/TaskGraph.cpp#L1253)):

![](assets/FTaskGraphImplementation_ctor.png)

Named thread cannot handle infinite recusive tasks depth, they can only handle 2 layers of tasks: they have 2 queues to executes tasks.
![](assets/namethread_2_queues.png)

The first one is Main Queue (QueueIndex=0), and the second one is Local Queue (QueueIndex=1). Main Queue's tasks are automatically pull out and execute until the queue is empty.

![](assets/game_thread_process_until_idle.png)

Local Queue handles intenral tasks and they won't be automatically executed, they must be manually trigged by calling `ProcessThreadUntilIdle()` or by `WaitUntilTasksComplete()` (which internally call `ProcessThreadUntilIdle()`)

 See [Parallel Rendering](main/rendering_parallel.md) for rendering thread Main Queue / Local Queue analysis.


Any thread has only 1 task queue and it can handle recursive tasks simply by events dependencies.

![](assets/anythread_1_queue.png)
```