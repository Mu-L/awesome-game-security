Project Path: arc_fuqiuluo_android-wuwa_5nyrwrwq

Source Tree:

```txt
arc_fuqiuluo_android-wuwa_5nyrwrwq
├── Makefile
├── README.md
├── docs
│   ├── FindDriver.md
│   ├── LR_REDIRECT.md
│   └── sdk
│       ├── README.md
│       ├── example.cpp
│       ├── wuwa.hpp
│       └── wuwa.rs
├── envsetup.sh
├── scripts
│   └── build-ddk.sh
└── src
    ├── core
    │   ├── wuwa.c
    │   └── wuwa_common.h
    ├── hook
    │   ├── wuwa_safe_signal.c
    │   └── wuwa_safe_signal.h
    ├── inlinehook
    │   ├── hijack_arm64.c
    │   └── hijack_arm64.h
    ├── ioctl
    │   ├── wuwa_ioctl.c
    │   └── wuwa_ioctl.h
    ├── mm
    │   ├── wuwa_bindproc.c
    │   ├── wuwa_bindproc.h
    │   ├── wuwa_page_walk.c
    │   ├── wuwa_page_walk.h
    │   ├── wuwa_proc_dmabuf.c
    │   └── wuwa_proc_dmabuf.h
    ├── net
    │   ├── wuwa_protocol.c
    │   ├── wuwa_protocol.h
    │   ├── wuwa_sock.c
    │   └── wuwa_sock.h
    ├── proc
    │   ├── wuwa_proc.c
    │   └── wuwa_proc.h
    └── utils
        ├── karray_list.c
        ├── karray_list.h
        ├── wuwa_kallsyms.h
        ├── wuwa_utils.c
        └── wuwa_utils.h

```

`Makefile`:

```
obj-m := android-wuwa.o

android-wuwa-y := \
    src/core/wuwa.o \
    src/net/wuwa_sock.o \
    src/net/wuwa_protocol.o \
    src/utils/wuwa_utils.o \
    src/ioctl/wuwa_ioctl.o \
    src/mm/wuwa_page_walk.o \
    src/mm/wuwa_proc_dmabuf.o \
    src/hook/wuwa_safe_signal.o \
    src/proc/wuwa_proc.o \
    src/inlinehook/hijack_arm64.o \
    src/utils/karray_list.o \
    src/mm/wuwa_bindproc.o

src := $(if $(filter /%,$(src)),$(src),$(srctree)/$(src))

KDIR := $(KDIR)
MDIR := $(realpath $(dir $(abspath $(lastword $(MAKEFILE_LIST)))))

$(info -- KDIR: $(KDIR))
$(info -- MDIR: $(MDIR))
$(info -- WUWA_SRC_DIR: $(src))
$(info -- WUWA_OBJ_DIR: $(obj))

ccflags-y += -I$(src)/src/core -I$(src)/src/net -I$(src)/src/ioctl -I$(src)/src/mm
ccflags-y += -I$(src)/src/inlinehook -I$(src)/src/hook -I$(src)/src/proc -I$(src)/src/utils

ccflags-y += -Wno-implicit-function-declaration -Wno-strict-prototypes -Wno-int-conversion -Wno-gcc-compat
ccflags-y += -Wno-declaration-after-statement -Wno-unused-function -Wno-unused-variable

# 编译时启用 隐藏模块功能
#ccflags-y += -DHIDE_SELF_MODULE
# 编译时启用 PTE_MAPPING 功能
#ccflags-y += -DBUILD_PTE_MAPPING
# 编译时启用 HIDE_SIGNAL 功能
#ccflags-y += -DBUILD_HIDE_SIGNAL
#ccflags-y += -DPTE_WALK
ccflags-y += -DBUILD_NO_CFI
# 如果 Android 12 5.10 内核出现 page_pinner_inited 导出失败 需要先禁用DMA buffer 创建作为临时处理方案
# 默认禁用 DMA buffer 功能，如需启用请注释下面这行
ccflags-y += -DWUWA_DISABLE_DMABUF

all:
	make -C $(KDIR) M=$(MDIR) modules

clean:
	make -C $(KDIR) M=$(MDIR) clean
    
compdb:
	python3 $(MDIR)/.vscode/generate_compdb.py -O $(KDIR) $(MDIR)

.PHONY: all clean

```

`README.md`:

```md
[![Ask DeepWiki](https://deepwiki.com/badge.svg)](https://deepwiki.com/fuqiuluo/android-wuwa)

> Join OICQ Group: 943577597
> 
> 
> 
> Kernel Driver Development Kit: [Ylarod/ddk](https://github.com/Ylarod/ddk)

# Features

## Kernel Protection Bypass
- [x] **CFI Bypass** - Automatically patch kernel CFI check functions to disable Control Flow Integrity protection
- [x] **Kprobe Blacklist Disable** - Clear kprobe blacklist to allow hooking protected kernel functions (kernel 6.1+)

## Address Translation
- [x] **Virtual Address Translation** - Software page table walking for virtual to physical address translation
- [x] **Hardware Address Translation** - Using ARM64 AT instruction for faster and more accurate translation
- [x] **PTE Direct Mapping** - Create mappings directly in page tables bypassing VMA, supports stealth mode
- [x] **Page Table Walk** - Traverse complete process page tables and dump to dmesg

## Memory Access
- [x] **Physical Memory R/W** - Direct access via phys_to_virt, up to 50MB per operation
- [x] **ioremap R/W** - Support multiple memory types (Normal/Device/Write-Through, etc.)

## Process Management
- [x] **Find Process** - Locate process PID by name
- [x] **Liveness Check** - Check if process is alive
- [x] **Privilege Escalation** - Elevate current process to root
- [x] **Get Module Base** - Query module load address in target process
- [ ] **Hide Process** - Set process invisible flag
- [x] **Hide Module** - Hide kernel module from system

## Advanced Features
- [x] **DMA Buffer Export** - Export process memory as dma-buf fd for zero-copy sharing
- [x] **Page Info Query** - Retrieve page flags/refcount/mapcount information
- [x] **Debug Info** - Get kernel structures like TTBR0/task_struct/mm_struct/pgd
- [x] **Custom Protocol Family** - Socket-based userspace communication interface
- [ ] **Remote Thread Creation** - Create new thread in target process (not implemented yet)

# Build Instructions

## Option 1: Use DDK (Recommended)

[DDK (Kernel Driver Development Kit)](https://github.com/Ylarod/ddk) provides a containerized build environment with pre-configured kernel sources.

### Prerequisites

- Docker installed and running
- DDK tool installed

### Install DDK

```bash
sudo curl -fsSL https://raw.githubusercontent.com/Ylarod/ddk/main/scripts/ddk -o /usr/local/bin/ddk
sudo chmod +x /usr/local/bin/ddk
```

### Build with DDK

The build script supports multiple commands and options (supports Chinese/English based on system locale):

**Commands:**
```bash
./scripts/build-ddk.sh build [target]    # Build kernel module
./scripts/build-ddk.sh clean [target]    # Clean build artifacts
./scripts/build-ddk.sh compdb [target]   # Generate compile_commands.json for IDE
./scripts/build-ddk.sh list              # List installed DDK images
```

**Build Examples:**
```bash
# Build with default target (android12-5.10)
./scripts/build-ddk.sh build

# Build for specific target
./scripts/build-ddk.sh build android14-6.1

# Build with stripped debug symbols (smaller file size)
./scripts/build-ddk.sh build -t android14-6.1 --strip

# Clean build artifacts
./scripts/build-ddk.sh clean android12-5.10

# Generate compile_commands.json for IDE support
./scripts/build-ddk.sh compdb
```

Available targets: Check [DDK Container Versions](https://github.com/Ylarod/ddk/pkgs/container/ddk/versions)

**Note**: On some systems, Docker requires root privileges. If you encounter permission errors, run the script with `sudo`.

## Option 2: Download from CI

Pre-built kernel modules are available from GitHub Actions CI builds:

1. Go to [Actions tab](../../actions)
2. Select the latest successful workflow run
3. Download the build artifact for your kernel version

## Option 3: Manual Build

If you have your own Android kernel source tree:

```bash
# Set kernel source path
export KERNEL_SRC=/path/to/android/kernel/source

# Build the module
make

# Clean build artifacts
make clean
```

**Note**: Manual builds are only tested on kernel 6.1. No guarantees on other versions.

# How to Connect to the WuWa Driver

[Click me](docs/FindDriver.md) for the connection guide.

# Thanks

- [Diamorphine](https://github.com/m0nad/Diamorphine)
- [kernel-inline-hook-framework](https://github.com/WeiJiLab/kernel-inline-hook-framework)

```

`docs/FindDriver.md`:

```md
# How to Connect to the WuWa Driver

## Introduction

The WuWa driver is a custom kernel driver that provides low-level memory access and process manipulation capabilities. This guide explains how to establish a connection to the driver from userspace applications.

## Connection Mechanism

The WuWa driver uses a socket-based communication protocol. Unlike traditional character device drivers (`/dev/xxx`), it hijacks a network address family to provide a communication channel.

## Automatic Discovery

The recommended way to connect is using the automatic discovery algorithm:

### Algorithm Overview

1. **Iterate through candidate address families**
    - The driver is registered under one of several uncommon network protocol families
    - Common candidates include: Decnet, NetBeui, Security, Key, Ash, Econet, RDS, SNA, Irda, Pppox, Wanpipe, LLC, CAN, TIPC, Bluetooth, IUCV, RxRpc, ISDN, Phonet, IEEE802154, Caif, Alg, and Vsock

2. **Probe each family with a two-step test**
   ```
   Step 1: Try creating a SOCK_SEQPACKET socket
   Step 2: If ENOKEY error received, try SOCK_RAW socket
   ```

3. **Recognition signal**
    - When the correct family is probed with SOCK_SEQPACKET, the driver returns `-ENOKEY` (errno 126)
    - This unique error code serves as an identification marker
    - A subsequent SOCK_RAW socket creation on the same family will succeed

### Example Code (Rust)

```rust
use nix::sys::socket::{socket, AddressFamily, SockFlag, SockType};
use nix::errno::Errno;

fn connect_to_wuwa() -> Result<OwnedFd, Error> {
    let families = [
        AddressFamily::Decnet,
        AddressFamily::NetBeui,
        // ... (other families)
        AddressFamily::Vsock,
    ];

    for af in families.iter() {
        // Step 1: Probe with SeqPacket
        match socket(*af, SockType::SeqPacket, SockFlag::empty(), None) {
            Ok(_) => continue,  // Not our driver
            Err(Errno::ENOKEY) => {
                // Found it! Try Raw socket
                if let Ok(fd) = socket(*af, SockType::Raw, SockFlag::empty(), None) {
                    return Ok(fd);
                }
            }
            Err(_) => continue,  // Try next family
        }
    }
    
    Err(Error::DriverNotFound)
}
```

### Example Code (C)

```c
#include <sys/socket.h>
#include <errno.h>

int connect_to_wuwa() {
    int families[] = {
        AF_DECnet, AF_NETBEUI, AF_SECURITY, 
        AF_KEY, AF_NETLINK, /* ... */
    };
    
    for (int i = 0; i < sizeof(families)/sizeof(int); i++) {
        int fd = socket(families[i], SOCK_SEQPACKET, 0);
        
        if (fd >= 0) {
            close(fd);
            continue;
        }
        
        if (errno == ENOKEY) {
            // Found the driver!
            fd = socket(families[i], SOCK_RAW, 0);
            if (fd >= 0) {
                return fd;
            }
        }
    }
    
    return -1;  // Driver not found
}
```

## Using the Connection

Once connected, the socket file descriptor is used to issue ioctl commands:

```rust
let sock_fd = connect_to_wuwa()?;

// Issue ioctl commands
ioctl(sock_fd, WUWA_IOCTL_FIND_PROCESS, &mut cmd);
```

## Requirements

- Root privileges (or CAP_NET_RAW capability)
- WuWa kernel module loaded
- Linux kernel with the hijacked protocol family available

## Troubleshooting

**Connection fails**: Ensure the kernel module is loaded with `lsmod | grep wuwa`

**Permission denied**: Run with root privileges or grant CAP_NET_RAW capability

**ENOKEY not returned**: The driver may be using a different address family. Check kernel logs for hints.

## Security Notice

This driver provides direct memory access capabilities and should only be used in controlled environments with proper authorization.
```

`docs/LR_REDIRECT.md`:

```md

# Sample

```c++
#define LUCKY_LUO 0xfaceb00c

unsigned char* shellcode = (unsigned char*)0x100000;
STP_PRE_IMM(shellcode, fp, lr, sp, -16);
STP_PRE_IMM(shellcode, x0, x1, sp, -16);
STP_PRE_IMM(shellcode, x2, x3, sp, -16);
MOV_IMM(shellcode, x2, LUCKY_LUO);
MOV_IMM(shellcode, x3, 0x10002c); // real LR address
STP_PRE_IMM(shellcode, x2, x3, sp, -16);
MOV_IMM(shellcode, lr, LUCKY_LUO);
BR_REG(shellcode, x1);
ADD_IMM(shellcode, sp, sp, 16);
LDP_POST_IMM(shellcode, x2, x3, sp, 16);
LDP_POST_IMM(shellcode, x0, x1, sp, 16);
LDP_POST_IMM(shellcode, fp, lr, sp, 16);
MOV_IMM(shellcode, x1, 42);
STR_PRE_IMM(shellcode, x1, x0, 0);
RET(shellcode);
```
```

`docs/sdk/README.md`:

```md
# WuWa SDK

Userspace SDKs for the WuWa kernel driver.

## Files

- **wuwa.rs** - Rust SDK with full type safety
- **wuwa.hpp** - Single-header C++ SDK (header-only)
- **example.cpp** - C++ usage example

## C++ SDK (wuwa.hpp)

Single-header library. Just `#include "wuwa.hpp"` and you're ready.

### Requirements

- C++17 or later
- Linux headers (for ioctl definitions)
- Root privileges or CAP_NET_RAW capability

### Quick Start

```cpp
#include "wuwa.hpp"

int main() {
    wuwa::WuWaDriver driver;

    // Connect to driver
    if (!driver.connect()) {
        return -1;
    }

    // Find process
    auto pid = driver.find_process("target_app");
    if (!pid) return -1;

    // Get module base
    auto base = driver.get_module_base(*pid, "libnative.so", 0x4);
    if (!base) return -1;

    // Read memory
    uint32_t value = *driver.read<uint32_t>(*pid, *base + 0x1000);

    // Write memory
    driver.write(*pid, *base + 0x1000, value + 1);

    return 0;
}
```

### Compile Example

```bash
# Desktop build
g++ -std=c++17 -o example example.cpp

# Android NDK build
$NDK/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android33-clang++ \
    -std=c++17 -static-libstdc++ -o example example.cpp
```

### API Reference

#### Connection

- `bool connect()` - Discover and connect to WuWa driver

#### Address Translation

- `std::optional<uint64_t> addr_translate(pid_t, uintptr_t)` - Software VA->PA walk
- `std::optional<uint64_t> at_s1e0r(pid_t, uintptr_t)` - Hardware AT instruction (faster)

#### Memory Access

- `std::optional<T> read<T>(pid_t, uintptr_t)` - Type-safe read
- `bool write<T>(pid_t, uintptr_t, const T&)` - Type-safe write
- `read_physical_memory()` - Raw read with buffer
- `write_physical_memory()` - Raw write with buffer
- `read_physical_memory_ioremap()` - Read via ioremap with memory type control
- `write_physical_memory_ioremap()` - Write via ioremap with memory type control

#### Process Management

- `std::optional<pid_t> find_process(string)` - Find PID by name
- `std::optional<bool> is_process_alive(pid_t)` - Check process liveness
- `bool hide_process(pid_t, bool)` - Hide/unhide from system
- `bool give_root()` - Escalate current process to uid=0

#### Module/Memory Info

- `std::optional<uintptr_t> get_module_base(pid_t, string, int)` - Get library base
- `std::optional<KernelPage> get_page_info(pid_t, uintptr_t)` - Query page metadata
- `std::optional<WuwaDebugInfoCmd> get_debug_info(pid_t)` - TTBR0/pgd/mm_struct

#### Advanced Features

- `std::optional<int> create_dma_buf(pid_t, uintptr_t, size_t)` - Export memory as dma-buf fd
- `bool pte_mapping(pid_t, uintptr_t, size_t, bool)` - Direct PTE manipulation
- `bool page_table_walk(pid_t)` - Dump page tables to dmesg
- `std::optional<BindProc> bind_process(pid_t)` - Bind process for efficient access
- `bool copy_process(...)` - Clone process with custom entry point

#### BindProc Class

Efficient handle for repeated memory access to a single process via ioctl interface:

```cpp
auto bindproc = driver.bind_process(pid);

// Set memory type (optional)
bindproc->set_memory_type(wuwa::WMT_NORMAL);

// Read operations use cached ioremap pages internally (via ioctl)
auto val = bindproc->read<uint32_t>(addr);
if (val) {
    std::cout << "Read: 0x" << std::hex << *val << std::endl;
}

// Raw buffer read (max 64KB per call)
char buf[256];
ssize_t bytes = bindproc->read(addr, buf, sizeof(buf));

// Write operations
uint32_t new_val = 0x12345678;
bindproc->write(addr, new_val);

// Raw buffer write
bindproc->write(addr, buf, sizeof(buf));
```

**BindProc IOCTLs**:
- `WUWA_BP_IOCTL_SET_MEMORY_PROT` - Set memory type (WMT_*)
- `WUWA_BP_IOCTL_READ_MEMORY` - Read from target process
- `WUWA_BP_IOCTL_WRITE_MEMORY` - Write to target process

**Memory Types** (WuwaMemoryType enum):
- `WMT_NORMAL` - Normal cached memory (default)
- `WMT_NORMAL_NC` - Non-cacheable
- `WMT_NORMAL_WT` - Write-through cache
- `WMT_DEVICE_nGnRnE` - Device memory (strictest ordering)
- `WMT_DEVICE_nGnRE` - Device memory
- `WMT_DEVICE_GRE` - Device memory (relaxed ordering)

Limits: 64KB per operation, 16 pages max per call.

#### Unreal Engine Helpers

- `std::optional<string> read_fstring(pid_t, uintptr_t)` - Read FString
- `std::optional<string> read_fstring_limit(pid_t, uintptr_t, size_t)` - Read with limit

## Rust SDK (wuwa.rs)

Full-featured SDK with Result types and proper error handling.

### Quick Start

```rust
use wuwa::WuWaDriver;

fn main() -> Result<(), anyhow::Error> {
    let driver = WuWaDriver::new()?;

    let pid = driver.find_process("target_app")?;
    let base = driver.get_module_base(pid, "lib.so", 0x4)?;

    let value: u32 = driver.read(pid, base + 0x1000)?;
    driver.write(pid, base + 0x1000, &(value + 1))?;

    Ok(())
}
```

## Driver Discovery

Both SDKs use the same discovery algorithm:

1. Probe uncommon protocol families (AF_DECnet, AF_NETBEUI, etc.) with SOCK_SEQPACKET
2. Driver responds with `-ENOKEY` when found
3. Create SOCK_RAW socket on identified family
4. Issue ioctl commands on the socket fd

This stealth technique avoids traditional `/dev/*` character devices.

## Safety Notes

These SDKs provide direct physical memory access and kernel manipulation. Use responsibly:

- Requires root or CAP_NET_RAW
- Incorrect use can crash the kernel
- For defensive security research only
- Test on non-production devices first

## License

Same as the kernel module (see main README).

```

`docs/sdk/example.cpp`:

```cpp
/**
 * WuWa SDK usage example
 *
 * Compile: g++ -std=c++17 -o example example.cpp
 * Run: sudo ./example
 */

#include "wuwa.hpp"
#include <iostream>
#include <iomanip>

int main() {
    wuwa::WuWaDriver driver;

    // Connect to driver
    if (!driver.connect()) {
        std::cerr << "Failed to connect to WuWa driver. Are you root?" << std::endl;
        return 1;
    }
    std::cout << "Connected to WuWa driver" << std::endl;

    // Find target process
    const char* target_name = "com.kurogame.wutheringwaves";
    auto pid_opt = driver.find_process(target_name);
    if (!pid_opt) {
        std::cerr << "Process not found: " << target_name << std::endl;
        return 1;
    }
    pid_t pid = *pid_opt;
    std::cout << "Found process: " << target_name << " (PID: " << pid << ")" << std::endl;

    // Check if alive
    auto alive = driver.is_process_alive(pid);
    std::cout << "Process alive: " << (alive && *alive ? "yes" : "no") << std::endl;

    // Get module base
    auto base = driver.get_module_base(pid, "libUE4.so", 0x4); // VM_EXEC
    if (!base) {
        std::cerr << "Failed to get module base" << std::endl;
        return 1;
    }
    std::cout << "libUE4.so base: 0x" << std::hex << *base << std::dec << std::endl;

    // Read memory example
    uint32_t value;
    auto addr = *base + 0x1000;
    auto result = driver.read_physical_memory(pid, addr, &value, sizeof(value));
    if (result) {
        std::cout << "Read from 0x" << std::hex << addr << ": 0x"
                  << value << std::dec << std::endl;
    }

    // Type-safe read
    auto val_opt = driver.read<uint32_t>(pid, addr);
    if (val_opt) {
        std::cout << "Type-safe read: 0x" << std::hex << *val_opt << std::dec << std::endl;
    }

    // Write memory example
    uint32_t new_value = 0x12345678;
    if (driver.write(pid, addr, new_value)) {
        std::cout << "Wrote 0x" << std::hex << new_value << " to 0x"
                  << addr << std::dec << std::endl;
    }

    // VA -> PA translation
    auto phy_addr = driver.at_s1e0r(pid, addr);
    if (phy_addr) {
        std::cout << "Physical address of 0x" << std::hex << addr
                  << ": 0x" << *phy_addr << std::dec << std::endl;
    }

    // Get debug info
    auto debug = driver.get_debug_info(pid);
    if (debug) {
        std::cout << "\nDebug info:" << std::endl;
        std::cout << "  TTBR0_EL1: 0x" << std::hex << debug->ttbr0_el1 << std::endl;
        std::cout << "  task_struct: 0x" << debug->task_struct << std::endl;
        std::cout << "  mm_struct: 0x" << debug->mm_struct << std::endl;
        std::cout << "  pgd_addr: 0x" << debug->pgd_addr << std::dec << std::endl;
    }

    // Page info
    auto page = driver.get_page_info(pid, addr);
    if (page) {
        std::cout << "\nPage info for 0x" << std::hex << addr << ":" << std::endl;
        std::cout << "  flags: 0x" << page->flags << std::endl;
        std::cout << "  refcount: " << std::dec << page->refcount << std::endl;
        std::cout << "  phy_addr: 0x" << std::hex << page->phy_addr << std::dec << std::endl;
    }

    // DMA-BUF example (zero-copy memory sharing)
    auto dma_fd = driver.create_dma_buf(pid, addr, 4096);
    if (dma_fd) {
        std::cout << "\nCreated DMA-BUF fd: " << *dma_fd << std::endl;
        // Can now mmap() this fd for zero-copy access
        close(*dma_fd);
    }

    // BindProc example (efficient sequential access via ioctl)
    std::cout << "\n=== BindProc Example ===" << std::endl;
    auto bindproc = driver.bind_process(pid);
    if (bindproc && bindproc->is_valid()) {
        std::cout << "Bound to process " << pid << std::endl;

        // Set memory type (optional, defaults to WMT_NORMAL)
        bindproc->set_memory_type(wuwa::WMT_NORMAL);

        // Efficient read - uses cached ioremap pages internally via ioctl
        auto val1 = bindproc->read<uint32_t>(*base + 0x1000);
        auto val2 = bindproc->read<uint32_t>(*base + 0x1008);
        auto val3 = bindproc->read<uint32_t>(*base + 0x1010);

        if (val1 && val2 && val3) {
            std::cout << "Read via BindProc:" << std::endl;
            std::cout << "  0x" << std::hex << (*base + 0x1000) << ": 0x" << *val1 << std::endl;
            std::cout << "  0x" << (*base + 0x1008) << ": 0x" << *val2 << std::endl;
            std::cout << "  0x" << (*base + 0x1010) << ": 0x" << *val3 << std::dec << std::endl;
        }

        // Raw buffer read
        char buffer[256];
        ssize_t bytes = bindproc->read(*base + 0x2000, buffer, sizeof(buffer));
        if (bytes > 0) {
            std::cout << "Read " << bytes << " bytes from 0x"
                      << std::hex << (*base + 0x2000) << std::dec << std::endl;
        }

        // Write example
        uint32_t new_val = 0xdeadbeef;
        if (bindproc->write(*base + 0x3000, new_val)) {
            std::cout << "Wrote 0x" << std::hex << new_val
                      << " to 0x" << (*base + 0x3000) << std::dec << std::endl;
        }

        // BindProc automatically closes fd on destruction
    }

    // Escalate to root (if not already root)
    if (getuid() != 0) {
        if (driver.give_root()) {
            std::cout << "\nEscalated to root: uid=" << getuid()
                      << " gid=" << getgid() << std::endl;
        }
    }

    return 0;
}

```

`docs/sdk/wuwa.hpp`:

```hpp
/**
 * WuWa kernel driver SDK for ARM64 Android 6.1+
 *
 * Single-header library. Provides userspace bindings to WuWa kernel module
 * via hijacked socket protocol family.
 *
 * Discovery:
 *   1. Probe uncommon AF_* families with SOCK_SEQPACKET
 *   2. Driver responds with -ENOKEY
 *   3. Create SOCK_RAW socket on identified family
 *   4. Issue ioctl commands on the socket fd
 *
 * Usage:
 *   #include "wuwa.hpp"
 *
 *   wuwa::WuWaDriver driver;
 *   if (!driver.connect()) return -1;
 *
 *   auto pid = driver.find_process("target_app");
 *   auto base = driver.get_module_base(*pid, "lib.so", 0x4);
 *   uint32_t val = *driver.read<uint32_t>(*pid, *base + 0x1000);
 *
 * Safety:
 *   Direct physical memory access and kernel-level process manipulation.
 *   Requires root or CAP_NET_RAW. For defensive security research only.
 */

#pragma once

#include <sys/socket.h>
#include <sys/ioctl.h>
#include <linux/if_alg.h>
#include <unistd.h>
#include <cstdint>
#include <cstring>
#include <string>
#include <optional>
#include <vector>
#include <algorithm>

namespace wuwa {

// Forward declarations for ioctl macros
struct WuwaAddrTranslateCmd;
struct WuwaDebugInfoCmd;
struct WuwaAtS1e0rCmd;
struct WuwaPageInfoCmd;
struct WuwaDmaBufCreateCmd;
struct WuwaPteMappingCmd;
struct WuwaPageTableWalkCmd;
struct WuwaCopyProcessCmd;
struct WuwaReadPhysicalMemoryCmd;
struct WuwaGetModuleBaseCmd;
struct WuwaFindProcCmd;
struct WuwaWritePhysicalMemoryCmd;
struct WuwaIsProcAliveCmd;
struct WuwaHideProcCmd;
struct WuwaGiveRootCmd;
struct WuwaReadPhysicalMemoryIoremapCmd;
struct WuwaWritePhysicalMemoryIoremapCmd;
struct WuwaBindProcCmd;
struct WuwaListProcessesCmd;
struct WuwaGetProcInfoCmd;

// IOCTL command definitions (magic number 'W')
// Must use actual struct types for correct command number calculation
#define WUWA_IOCTL_ADDR_TRANSLATE _IOWR('W', 1, WuwaAddrTranslateCmd)
#define WUWA_IOCTL_DEBUG_INFO _IOR('W', 2, WuwaDebugInfoCmd)
#define WUWA_IOCTL_AT_S1E0R _IOWR('W', 3, WuwaAtS1e0rCmd)
#define WUWA_IOCTL_PAGE_INFO _IOWR('W', 4, WuwaPageInfoCmd)
#define WUWA_IOCTL_DMA_BUF_CREATE _IOWR('W', 5, WuwaDmaBufCreateCmd)
#define WUWA_IOCTL_PTE_MAPPING _IOWR('W', 6, WuwaPteMappingCmd)
#define WUWA_IOCTL_PAGE_TABLE_WALK _IOWR('W', 7, WuwaPageTableWalkCmd)
#define WUWA_IOCTL_COPY_PROCESS _IOWR('W', 8, WuwaCopyProcessCmd)
#define WUWA_IOCTL_READ_MEMORY _IOWR('W', 9, WuwaReadPhysicalMemoryCmd)
#define WUWA_IOCTL_GET_MODULE_BASE _IOWR('W', 10, WuwaGetModuleBaseCmd)
#define WUWA_IOCTL_FIND_PROCESS _IOWR('W', 11, WuwaFindProcCmd)
#define WUWA_IOCTL_WRITE_MEMORY _IOWR('W', 12, WuwaWritePhysicalMemoryCmd)
#define WUWA_IOCTL_IS_PROCESS_ALIVE _IOWR('W', 13, WuwaIsProcAliveCmd)
#define WUWA_IOCTL_HIDE_PROCESS _IOWR('W', 14, WuwaHideProcCmd)
#define WUWA_IOCTL_GIVE_ROOT _IOWR('W', 15, WuwaGiveRootCmd)
#define WUWA_IOCTL_READ_MEMORY_IOREMAP _IOWR('W', 16, WuwaReadPhysicalMemoryIoremapCmd)
#define WUWA_IOCTL_WRITE_MEMORY_IOREMAP _IOWR('W', 17, WuwaWritePhysicalMemoryIoremapCmd)
#define WUWA_IOCTL_BIND_PROC _IOWR('W', 18, WuwaBindProcCmd)
#define WUWA_IOCTL_LIST_PROCESSES _IOWR('W', 19, WuwaListProcessesCmd)
#define WUWA_IOCTL_GET_PROC_INFO _IOWR('W', 20, WuwaGetProcInfoCmd)

// Command structures matching kernel definitions

struct WuwaAddrTranslateCmd {
    uint64_t phy_addr;
    pid_t pid;
    uintptr_t va;
};

struct WuwaDebugInfoCmd {
    uint64_t ttbr0_el1;
    uint64_t task_struct;
    uint64_t mm_struct;
    uint64_t pgd_addr;
    uint64_t pgd_phys_addr;
    uint64_t mm_asid;
    uint32_t mm_right;
};

struct WuwaAtS1e0rCmd {
    uint64_t phy_addr;
    pid_t pid;
    uintptr_t va;
};

union PageUnion {
    int32_t mapcount;
    uint32_t page_type;
};

struct KernelPage {
    uint64_t flags;
    PageUnion union_field;
    int32_t refcount;
    uint64_t phy_addr;
};

struct WuwaPageInfoCmd {
    pid_t pid;
    uintptr_t va;
    KernelPage page;
};

struct WuwaDmaBufCreateCmd {
    pid_t pid;
    uintptr_t va;
    size_t size;
    int fd;
};

struct WuwaPteMappingCmd {
    pid_t pid;
    uintptr_t start_addr;
    size_t num_pages;
    int hide;
};

struct WuwaPageTableWalkCmd {
    pid_t pid;
    uint64_t total_pte_count;       // Total number of PTEs
    uint64_t present_pte_count;     // Number of present (mapped) PTEs
    uint64_t pmd_huge_count;        // Number of PMD huge pages (2MB pages)
    uint64_t pud_huge_count;        // Number of PUD huge pages (1GB pages)
};

struct WuwaCopyProcessCmd {
    pid_t pid;
    void* fn_ptr;
    void* child_stack;
    size_t child_stack_size;
    uint64_t flags;
    void* arg;
    int* child_tid;
};

struct WuwaReadPhysicalMemoryCmd {
    pid_t pid;
    uintptr_t src_va;
    uintptr_t dst_va;
    size_t size;
    uintptr_t phy_addr;
};

struct WuwaWritePhysicalMemoryCmd {
    pid_t pid;
    uintptr_t src_va;
    uintptr_t dst_va;
    size_t size;
    uintptr_t phy_addr;
};

struct WuwaGetModuleBaseCmd {
    pid_t pid;
    char name[256];
    uintptr_t base;
    int vm_flag;
};

struct WuwaFindProcCmd {
    pid_t pid;
    char name[256];
};

struct WuwaIsProcAliveCmd {
    pid_t pid;
    int alive;
};

struct WuwaHideProcCmd {
    pid_t pid;
    int hide;
};

struct WuwaGiveRootCmd {
    int result;
};

struct WuwaReadPhysicalMemoryIoremapCmd {
    pid_t pid;
    uintptr_t src_va;
    uintptr_t dst_va;
    size_t size;
    uintptr_t phy_addr;
    int prot;
};

struct WuwaWritePhysicalMemoryIoremapCmd {
    pid_t pid;
    uintptr_t src_va;
    uintptr_t dst_va;
    size_t size;
    uintptr_t phy_addr;
    int prot;
};

struct WuwaBindProcCmd {
    pid_t pid;
    int fd;
};

struct WuwaListProcessesCmd {
    uint8_t* bitmap;
    size_t bitmap_size;
    size_t process_count;
};

struct WuwaGetProcInfoCmd {
    pid_t pid;
    pid_t tgid;
    char name[256];
    uid_t uid;
    pid_t ppid;
    int prio;
};

/**
 * Process information with memory usage statistics
 *
 * Combines basic process information with page table statistics to provide
 * a complete view of process memory usage.
 */
struct ProcessInfoWithMemory {
    WuwaGetProcInfoCmd info;        // Basic process information
    uint64_t memory_size;            // Total memory size in bytes
    uint64_t present_pte_count;      // Number of present (mapped) base pages
    uint64_t pmd_huge_count;         // Number of PMD huge pages
    uint64_t pud_huge_count;         // Number of PUD huge pages

    /**
     * Calculate total memory size from page statistics
     *
     * Note: Huge page sizes depend on base page size:
     * - 4KB base:  PMD=2MB,   PUD=1GB
     * - 16KB base: PMD=32MB,  PUD may not be supported
     * - 64KB base: PMD=512MB, PUD may not be supported
     *
     * This function assumes standard ARM64 configuration with 4KB base pages.
     * For accurate results on systems with different page sizes, huge page
     * sizes should be obtained from /proc or kernel configuration.
     */
    static uint64_t calculate_memory_size(uint64_t present_pte, uint64_t pmd_huge, uint64_t pud_huge) {
        const long page_size = getpagesize();  // Get system base page size

        // Calculate huge page sizes based on base page size
        // These are standard ratios for ARM64 with 4KB pages
        uint64_t pmd_size;
        uint64_t pud_size;

        if (page_size == 4096) {
            // 4KB base page
            pmd_size = 2ULL * 1024 * 1024;      // 2MB
            pud_size = 1024ULL * 1024 * 1024;   // 1GB
        } else if (page_size == 16384) {
            // 16KB base page
            pmd_size = 32ULL * 1024 * 1024;     // 32MB
            pud_size = 0;                        // Usually not supported
        } else if (page_size == 65536) {
            // 64KB base page
            pmd_size = 512ULL * 1024 * 1024;    // 512MB
            pud_size = 0;                        // Usually not supported
        } else {
            // Unknown page size, assume 4KB standard
            pmd_size = 2ULL * 1024 * 1024;
            pud_size = 1024ULL * 1024 * 1024;
        }

        return (present_pte * page_size) + (pmd_huge * pmd_size) + (pud_huge * pud_size);
    }
};

// Memory type constants for ioremap operations
enum WuwaMemoryType {
    WMT_NORMAL = 0,          // Normal cached memory
    WMT_NORMAL_TAGGED = 1,   // Normal with MTE tags
    WMT_NORMAL_NC = 2,       // Non-cacheable
    WMT_NORMAL_WT = 3,       // Write-through
    WMT_DEVICE_nGnRnE = 4,   // Device memory, no gather/reorder/early-ack
    WMT_DEVICE_nGnRE = 5,    // Device memory, no gather/reorder
    WMT_DEVICE_GRE = 6,      // Device memory, gather/reorder/early-ack
    WMT_NORMAL_iNC_oWB = 7   // Inner non-cacheable, outer write-back
};

// BindProc command structures
struct BpReadMemoryCmd {
    uintptr_t src_va;  // Virtual address to read from
    uintptr_t dst_va;  // Virtual address to write to (userspace buffer)
    size_t size;
};

struct BpWriteMemoryCmd {
    uintptr_t src_va;  // Virtual address to read from (userspace buffer)
    uintptr_t dst_va;  // Virtual address to write to
    size_t size;
};

// BindProc ioctl commands
#define WUWA_BP_IOCTL_SET_MEMORY_PROT _IOWR('B', 1, int)
#define WUWA_BP_IOCTL_READ_MEMORY _IOWR('B', 2, BpReadMemoryCmd)
#define WUWA_BP_IOCTL_WRITE_MEMORY _IOWR('B', 3, BpWriteMemoryCmd)

/**
 * Bound process handle for efficient memory access
 *
 * Wraps a file descriptor returned by bind_process(). Provides:
 * - Efficient reads via cached ioremap pages
 * - Configurable memory type (cached/device/etc)
 * - RAII fd management
 */
class BindProc {
public:
    BindProc() : fd_(-1) {}

    explicit BindProc(int fd) : fd_(fd) {}

    ~BindProc() {
        if (fd_ >= 0) {
            close(fd_);
        }
    }

    // Non-copyable
    BindProc(const BindProc&) = delete;
    BindProc& operator=(const BindProc&) = delete;

    // Movable
    BindProc(BindProc&& other) noexcept : fd_(other.fd_) {
        other.fd_ = -1;
    }

    BindProc& operator=(BindProc&& other) noexcept {
        if (this != &other) {
            if (fd_ >= 0) {
                close(fd_);
            }
            fd_ = other.fd_;
            other.fd_ = -1;
        }
        return *this;
    }

    bool is_valid() const { return fd_ >= 0; }

    /**
     * Read from target process virtual address
     * Uses kernel-side ioremap with page caching for efficiency
     *
     * @param va Virtual address in target process
     * @param buf Destination buffer
     * @param size Number of bytes to read (max 64KB)
     * @return Number of bytes read, or -1 on error
     */
    ssize_t read(uintptr_t va, void* buf, size_t size) {
        if (fd_ < 0) return -1;

        BpReadMemoryCmd cmd = {
            va,
            reinterpret_cast<uintptr_t>(buf),
            size
        };

        int ret = ioctl(fd_, WUWA_BP_IOCTL_READ_MEMORY, &cmd);
        return ret < 0 ? -1 : ret;
    }

    /**
     * Write to target process virtual address
     *
     * @param va Virtual address in target process
     * @param buf Source buffer
     * @param size Number of bytes to write (max 64KB)
     * @return Number of bytes written, or -1 on error
     */
    ssize_t write(uintptr_t va, const void* buf, size_t size) {
        if (fd_ < 0) return -1;

        BpWriteMemoryCmd cmd = {
            reinterpret_cast<uintptr_t>(buf),
            va,
            size
        };

        int ret = ioctl(fd_, WUWA_BP_IOCTL_WRITE_MEMORY, &cmd);
        return ret < 0 ? -1 : ret;
    }

    /**
     * Type-safe read from target process
     */
    template<typename T>
    std::optional<T> read(uintptr_t va) {
        T buffer;
        ssize_t ret = read(va, &buffer, sizeof(T));
        if (ret != sizeof(T)) {
            return std::nullopt;
        }
        return buffer;
    }

    /**
     * Type-safe write to target process
     */
    template<typename T>
    bool write(uintptr_t va, const T& value) {
        ssize_t ret = write(va, &value, sizeof(T));
        return ret == sizeof(T);
    }

    /**
     * Set memory type for future ioremap operations
     *
     * @param mem_type One of WMT_* constants
     * @return true on success
     */
    bool set_memory_type(WuwaMemoryType mem_type) {
        if (fd_ < 0) return false;

        int prot = static_cast<int>(mem_type);
        return ioctl(fd_, WUWA_BP_IOCTL_SET_MEMORY_PROT, &prot) >= 0;
    }

    /**
     * Get underlying file descriptor (for advanced use)
     */
    int raw_fd() const { return fd_; }

private:
    int fd_;
};

/**
 * WuWa driver connection handle with RAII socket management
 */
class WuWaDriver {
public:
    WuWaDriver() : sock_fd_(-1) {}

    ~WuWaDriver() {
        if (sock_fd_ >= 0) {
            close(sock_fd_);
        }
    }

    // Non-copyable
    WuWaDriver(const WuWaDriver&) = delete;
    WuWaDriver& operator=(const WuWaDriver&) = delete;

    // Movable
    WuWaDriver(WuWaDriver&& other) noexcept : sock_fd_(other.sock_fd_) {
        other.sock_fd_ = -1;
    }

    WuWaDriver& operator=(WuWaDriver&& other) noexcept {
        if (this != &other) {
            if (sock_fd_ >= 0) {
                close(sock_fd_);
            }
            sock_fd_ = other.sock_fd_;
            other.sock_fd_ = -1;
        }
        return *this;
    }

    /**
     * Discover and connect to WuWa driver. Requires root or CAP_NET_RAW.
     */
    bool connect() {
        constexpr int families[] = {
            AF_DECnet, AF_NETBEUI, AF_SECURITY, AF_KEY, AF_NETLINK,
            AF_PACKET, AF_ASH, AF_ECONET, AF_ATMSVC, AF_RDS,
            AF_SNA, AF_IRDA, AF_PPPOX, AF_WANPIPE, AF_LLC,
            AF_CAN, AF_TIPC, AF_BLUETOOTH, AF_IUCV, AF_RXRPC,
            AF_ISDN, AF_PHONET, AF_IEEE802154, AF_CAIF, AF_ALG, AF_VSOCK
        };

        for (int af : families) {
            int probe_fd = socket(af, SOCK_SEQPACKET, 0);
            if (probe_fd >= 0) {
                close(probe_fd);
                continue;
            }

            if (errno == ENOKEY) {
                sock_fd_ = socket(af, SOCK_RAW, 0);
                if (sock_fd_ >= 0) {
                    return true;
                }
            }
        }
        return false;
    }

    bool is_connected() const { return sock_fd_ >= 0; }

    /**
     * Software page table walk: VA -> PA translation
     */
    std::optional<uint64_t> addr_translate(pid_t pid, uintptr_t va) {
        WuwaAddrTranslateCmd cmd = {0, pid, va};
        if (!do_ioctl(WUWA_IOCTL_ADDR_TRANSLATE, &cmd)) {
            return std::nullopt;
        }
        return cmd.phy_addr;
    }

    /**
     * Get process debug info (TTBR0, task_struct, mm_struct, pgd)
     */
    std::optional<WuwaDebugInfoCmd> get_debug_info(pid_t pid) {
        WuwaDebugInfoCmd cmd = {};
        if (!do_ioctl(WUWA_IOCTL_DEBUG_INFO, &cmd)) {
            return std::nullopt;
        }
        return cmd;
    }

    /**
     * Hardware AT S1E0R instruction: VA -> PA (faster than software walk)
     */
    std::optional<uint64_t> at_s1e0r(pid_t pid, uintptr_t va) {
        WuwaAtS1e0rCmd cmd = {0, pid, va};
        if (!do_ioctl(WUWA_IOCTL_AT_S1E0R, &cmd)) {
            return std::nullopt;
        }
        return cmd.phy_addr;
    }

    /**
     * Query page flags, refcount, mapcount at VA
     */
    std::optional<KernelPage> get_page_info(pid_t pid, uintptr_t va) {
        WuwaPageInfoCmd cmd = {pid, va, {}};
        if (!do_ioctl(WUWA_IOCTL_PAGE_INFO, &cmd)) {
            return std::nullopt;
        }
        return cmd.page;
    }

    /**
     * Export process memory region as dma-buf fd for zero-copy sharing
     */
    std::optional<int> create_dma_buf(pid_t pid, uintptr_t va, size_t size) {
        WuwaDmaBufCreateCmd cmd = {pid, va, size, -1};
        if (!do_ioctl(WUWA_IOCTL_DMA_BUF_CREATE, &cmd)) {
            return std::nullopt;
        }
        return cmd.fd;
    }

    /**
     * Direct PTE manipulation (hide/unhide pages)
     */
    bool pte_mapping(pid_t pid, uintptr_t start_addr, size_t num_pages, bool hide) {
        WuwaPteMappingCmd cmd = {pid, start_addr, num_pages, hide ? 1 : 0};
        return do_ioctl(WUWA_IOCTL_PTE_MAPPING, &cmd);
    }

    /**
     * Walk page tables and collect statistics
     *
     * Traverses the page tables for the target process and collects statistics
     * about page table entries including total PTEs, present PTEs, and huge pages.
     *
     * @param pid Target process ID
     * @return WuwaPageTableWalkCmd with statistics on success, nullopt on failure
     */
    std::optional<WuwaPageTableWalkCmd> page_table_walk(pid_t pid) {
        WuwaPageTableWalkCmd cmd = {pid, 0, 0, 0, 0};
        if (!do_ioctl(WUWA_IOCTL_PAGE_TABLE_WALK, &cmd)) {
            return std::nullopt;
        }
        return cmd;
    }

    /**
     * Read physical memory via phys_to_virt (max 50MB per call)
     */
    std::optional<uintptr_t> read_physical_memory(pid_t pid, uintptr_t src_va,
                                                   void* dst_buf, size_t size) {
        WuwaReadPhysicalMemoryCmd cmd = {
            pid, src_va, reinterpret_cast<uintptr_t>(dst_buf), size, 0
        };
        if (!do_ioctl(WUWA_IOCTL_READ_MEMORY, &cmd)) {
            return std::nullopt;
        }
        return cmd.phy_addr;
    }

    /**
     * Write physical memory via phys_to_virt (max 50MB per call)
     */
    std::optional<uintptr_t> write_physical_memory(pid_t pid, const void* src_buf,
                                                    uintptr_t dst_va, size_t size) {
        WuwaWritePhysicalMemoryCmd cmd = {
            pid, reinterpret_cast<uintptr_t>(src_buf), dst_va, size, 0
        };
        if (!do_ioctl(WUWA_IOCTL_WRITE_MEMORY, &cmd)) {
            return std::nullopt;
        }
        return cmd.phy_addr;
    }

    /**
     * Type-safe read of arbitrary struct from target process
     */
    template<typename T>
    std::optional<T> read(pid_t pid, uintptr_t addr) {
        T buffer;
        auto result = read_physical_memory(pid, addr, &buffer, sizeof(T));
        if (!result) return std::nullopt;
        return buffer;
    }

    /**
     * Type-safe write of arbitrary struct to target process
     */
    template<typename T>
    bool write(pid_t pid, uintptr_t addr, const T& value) {
        auto result = write_physical_memory(pid, &value, addr, sizeof(T));
        return result.has_value();
    }

    /**
     * Read Unreal Engine FString from target process
     */
    std::optional<std::string> read_fstring(pid_t pid, uintptr_t addr) {
        auto len_opt = read<uint32_t>(pid, addr + 8);
        if (!len_opt || *len_opt == 0) {
            return std::string();
        }

        auto ptr_opt = read<uintptr_t>(pid, addr);
        if (!ptr_opt) return std::nullopt;

        std::string result;
        if (!read_to_utf8(pid, *ptr_opt, result, *len_opt - 1)) {
            return std::nullopt;
        }
        return result;
    }

    /**
     * Read FString with length limit
     */
    std::optional<std::string> read_fstring_limit(pid_t pid, uintptr_t addr, size_t max_len) {
        auto len_opt = read<uint32_t>(pid, addr + 8);
        if (!len_opt || *len_opt == 0) {
            return std::string();
        }

        if (*len_opt > max_len) {
            return std::nullopt;
        }

        auto ptr_opt = read<uintptr_t>(pid, addr);
        if (!ptr_opt) return std::nullopt;

        std::string result;
        if (!read_to_utf8(pid, *ptr_opt, result, *len_opt - 1)) {
            return std::nullopt;
        }
        return result;
    }

    /**
     * Get module/library base address in target process
     * @param vm_flag VM flags to filter (e.g., 0x4 for VM_EXEC)
     */
    std::optional<uintptr_t> get_module_base(pid_t pid, const std::string& name, int vm_flag) {
        WuwaGetModuleBaseCmd cmd = {pid, {}, 0, vm_flag};
        size_t copy_len = std::min(name.size(), sizeof(cmd.name) - 1);
        memcpy(cmd.name, name.c_str(), copy_len);
        cmd.name[copy_len] = '\0';

        if (!do_ioctl(WUWA_IOCTL_GET_MODULE_BASE, &cmd)) {
            return std::nullopt;
        }
        return cmd.base;
    }

    /**
     * Find process by name, returns PID
     */
    std::optional<pid_t> find_process(const std::string& name) {
        WuwaFindProcCmd cmd = {0, {}};
        size_t copy_len = std::min(name.size(), sizeof(cmd.name) - 1);
        memcpy(cmd.name, name.c_str(), copy_len);
        cmd.name[copy_len] = '\0';

        if (!do_ioctl(WUWA_IOCTL_FIND_PROCESS, &cmd)) {
            return std::nullopt;
        }
        if (cmd.pid == 0) {
            return std::nullopt;
        }
        return cmd.pid;
    }

    /**
     * Check if process is alive
     */
    std::optional<bool> is_process_alive(pid_t pid) {
        WuwaIsProcAliveCmd cmd = {pid, 0};
        if (!do_ioctl(WUWA_IOCTL_IS_PROCESS_ALIVE, &cmd)) {
            return std::nullopt;
        }
        return cmd.alive != 0;
    }

    /**
     * Hide/unhide process from system visibility
     */
    bool hide_process(pid_t pid, bool hide) {
        WuwaHideProcCmd cmd = {pid, hide ? 1 : 0};
        return do_ioctl(WUWA_IOCTL_HIDE_PROCESS, &cmd);
    }

    /**
     * Escalate current process to root (uid=0, gid=0)
     */
    bool give_root() {
        WuwaGiveRootCmd cmd = {0};
        if (!do_ioctl(WUWA_IOCTL_GIVE_ROOT, &cmd)) {
            return false;
        }
        return cmd.result >= 0;
    }

    /**
     * Read physical memory via ioremap with memory attribute control
     * @param prot Memory type (use MT_* constants from kernel)
     */
    std::optional<uintptr_t> read_physical_memory_ioremap(pid_t pid, uintptr_t src_va,
                                                           void* dst_buf, size_t size, int prot) {
        WuwaReadPhysicalMemoryIoremapCmd cmd = {
            pid, src_va, reinterpret_cast<uintptr_t>(dst_buf), size, 0, prot
        };
        if (!do_ioctl(WUWA_IOCTL_READ_MEMORY_IOREMAP, &cmd)) {
            return std::nullopt;
        }
        return cmd.phy_addr;
    }

    /**
     * Write physical memory via ioremap with memory attribute control
     * @param prot Memory type (use MT_* constants from kernel)
     */
    std::optional<uintptr_t> write_physical_memory_ioremap(pid_t pid, const void* src_buf,
                                                            uintptr_t dst_va, size_t size, int prot) {
        WuwaWritePhysicalMemoryIoremapCmd cmd = {
            pid, reinterpret_cast<uintptr_t>(src_buf), dst_va, size, 0, prot
        };
        if (!do_ioctl(WUWA_IOCTL_WRITE_MEMORY_IOREMAP, &cmd)) {
            return std::nullopt;
        }
        return cmd.phy_addr;
    }

    /**
     * Bind process for efficient memory access
     *
     * Returns a BindProc handle that uses kernel-side ioremap with page caching.
     * More efficient than repeated read_physical_memory() calls for sequential access.
     *
     * @param pid Target process ID
     * @return BindProc object on success, nullopt on failure
     */
    std::optional<BindProc> bind_process(pid_t pid) {
        WuwaBindProcCmd cmd = {pid, -1};
        if (!do_ioctl(WUWA_IOCTL_BIND_PROC, &cmd)) {
            return std::nullopt;
        }
        return BindProc(cmd.fd);
    }

    /**
     * Copy process with custom function pointer and stack
     */
    bool copy_process(pid_t pid, void* fn_ptr, void* child_stack,
                     size_t child_stack_size, uint64_t flags, void* arg) {
        WuwaCopyProcessCmd cmd = {
            pid, fn_ptr, child_stack, child_stack_size, flags, arg, nullptr
        };
        return do_ioctl(WUWA_IOCTL_COPY_PROCESS, &cmd);
    }

    /**
     * List all processes in the system using bitmap
     *
     * Returns a vector of PIDs for all running processes. Uses an efficient
     * bitmap representation (8KB) to retrieve process list from kernel.
     *
     * @return Vector of PIDs on success, empty vector on failure
     */
    std::vector<pid_t> list_processes() {
        constexpr size_t BITMAP_SIZE = 8192;  // Support PID 0-65535
        std::vector<uint8_t> bitmap(BITMAP_SIZE, 0);

        WuwaListProcessesCmd cmd = {
            bitmap.data(),
            BITMAP_SIZE,
            0
        };

        if (!do_ioctl(WUWA_IOCTL_LIST_PROCESSES, &cmd)) {
            return {};
        }

        // Parse bitmap and extract PIDs
        std::vector<pid_t> pids;
        pids.reserve(cmd.process_count);

        for (size_t pid = 0; pid < BITMAP_SIZE * 8; ++pid) {
            size_t byte_idx = pid / 8;
            size_t bit_idx = pid % 8;

            if (bitmap[byte_idx] & (1 << bit_idx)) {
                pids.push_back(static_cast<pid_t>(pid));
            }
        }

        return pids;
    }

    /**
     * Get detailed process information by PID
     *
     * Retrieves process information including name, TGID, UID, PPID, and priority.
     *
     * @param pid Process ID to query
     * @return WuwaGetProcInfoCmd struct on success, nullopt on failure
     */
    std::optional<WuwaGetProcInfoCmd> get_process_info(pid_t pid) {
        WuwaGetProcInfoCmd cmd = {};
        cmd.pid = pid;

        if (!do_ioctl(WUWA_IOCTL_GET_PROC_INFO, &cmd)) {
            return std::nullopt;
        }

        return cmd;
    }

    /**
     * List all processes with detailed information
     *
     * This is an improved version that retrieves both PIDs and detailed information
     * in a single call. Automatically filters out processes with empty names.
     * Results are sorted by priority (lower priority value = higher priority = appears first).
     *
     * @return Vector of process information structs sorted by priority, empty vector on failure
     */
    std::vector<WuwaGetProcInfoCmd> list_processes_with_info() {
        std::vector<WuwaGetProcInfoCmd> result;

        // Get all PIDs using bitmap
        auto pids = list_processes();
        if (pids.empty()) {
            return result;
        }

        // Reserve space for efficiency
        result.reserve(pids.size());

        // Fetch detailed info for each PID
        for (pid_t pid : pids) {
            auto info = get_process_info(pid);
            if (info) {
                // Skip processes with empty names
                if (info->name[0] != '\0') {
                    result.push_back(*info);
                }
            }
        }

        // Sort by priority (lower value = higher priority)
        std::sort(result.begin(), result.end(),
                  [](const WuwaGetProcInfoCmd& a, const WuwaGetProcInfoCmd& b) {
                      return a.prio < b.prio;
                  });

        return result;
    }
private:
    int sock_fd_;

    bool do_ioctl(unsigned long cmd, void* arg) {
        return ioctl(sock_fd_, cmd, arg) >= 0;
    }

    /**
     * Convert UTF-16 in target process to UTF-8
     */
    bool read_to_utf8(pid_t pid, uintptr_t ptr, std::string& out, size_t length) {
        std::vector<uint8_t> buf;
        uintptr_t current = ptr;

        for (size_t i = 0; i < length; i++) {
            auto char_opt = read<uint16_t>(pid, current);
            if (!char_opt) return false;

            uint16_t c = *char_opt;
            if (c <= 0x007F) {
                buf.push_back(static_cast<uint8_t>(c));
            } else if (c <= 0x07FF) {
                buf.push_back(static_cast<uint8_t>((c >> 6) | 0xC0));
                buf.push_back(static_cast<uint8_t>((c & 0x3F) | 0x80));
            } else {
                buf.push_back(static_cast<uint8_t>((c >> 12) | 0xE0));
                buf.push_back(static_cast<uint8_t>(((c >> 6) & 0x3F) | 0x80));
                buf.push_back(static_cast<uint8_t>((c & 0x3F) | 0x80));
            }
            current += sizeof(uint16_t);
        }

        out.assign(buf.begin(), buf.end());
        return true;
    }
};

} // namespace wuwa
```

`docs/sdk/wuwa.rs`:

```rs
//! WuWa kernel driver SDK for ARM64 Android 6.1+
//!
//! Provides userspace bindings to the WuWa kernel module via hijacked socket protocol family.
//!
//! # Discovery
//!
//! The driver registers as a custom socket protocol family. Discovery algorithm:
//! 1. Probe uncommon AF_* families with SOCK_SEQPACKET
//! 2. Driver responds with -ENOKEY
//! 3. Create SOCK_RAW socket on identified family
//! 4. Issue ioctl commands on the socket fd
//!
//! # Usage
//!
//! ```no_run
//! let driver = WuWaDriver::new()?;
//! let pid = driver.find_process("target_app")?;
//! let base = driver.get_module_base(pid, "lib.so", 0x4)?;
//! let val: u32 = driver.read(pid, base + 0x1000)?;
//! ```
//!
//! # Safety
//!
//! This SDK provides direct physical memory access and kernel-level process manipulation.
//! Requires root or CAP_NET_RAW. For defensive security research only.

use std::ffi::c_void;
use std::os::fd::{AsFd, AsRawFd, OwnedFd};
use anyhow::anyhow;
use std::mem::{MaybeUninit, size_of};
use std::ptr::NonNull;
use log::{debug, error, info, log_enabled, Level};
use nix::errno::Errno;
use nix::{libc, NixPath};
use nix::libc::{c_int, free, getsockopt, ioctl, malloc, mmap, size_t, sockaddr_in, socklen_t, pid_t, _IOWR, _IOR, Ioctl};
use nix::sys::socket::{socket, AddressFamily, SockFlag, SockType};

// IOCTL command definitions (magic number 'W')
const WUWA_IOCTL_ADDR_TRANSLATE: Ioctl = _IOWR::<WuwaAddrTranslateCmd>(b'W' as u32, 1);
const WUWA_IOCTL_DEBUG_INFO: Ioctl = _IOR::<WuwaDebugInfoCmd>(b'W' as u32, 2);
const WUWA_IOCTL_AT_S1E0R: Ioctl = _IOWR::<WuwaAtS1e0rCmd>(b'W' as u32, 3);
const WUWA_IOCTL_PAGE_INFO: Ioctl = _IOWR::<WuwaPageInfoCmd>(b'W' as u32, 4);
const WUWA_IOCTL_DMA_BUF_CREATE: Ioctl = _IOWR::<WuwaDmaBufCreateCmd>(b'W' as u32, 5);
const WUWA_IOCTL_PTE_MAPPING: Ioctl = _IOWR::<WuwaPteMappingCmd>(b'W' as u32, 6);
const WUWA_IOCTL_PAGE_TABLE_WALK: Ioctl = _IOWR::<WuwaPageTableWalkCmd>(b'W' as u32, 7);
const WUWA_IOCTL_COPY_PROCESS: Ioctl = _IOWR::<WuwaCopyProcessCmd>(b'W' as u32, 8);
const WUWA_IOCTL_READ_MEMORY: Ioctl = _IOWR::<WuwaReadPhysicalMemoryCmd>(b'W' as u32, 9);
const WUWA_IOCTL_GET_MODULE_BASE: Ioctl = _IOWR::<WuwaGetModuleBaseCmd>(b'W' as u32, 10);
const WUWA_IOCTL_FIND_PROCESS: Ioctl = _IOWR::<WuwaFindProcCmd>(b'W' as u32, 11);
const WUWA_IOCTL_WRITE_MEMORY: Ioctl = _IOWR::<WuwaWritePhysicalMemoryCmd>(b'W' as u32, 12);
const WUWA_IOCTL_IS_PROCESS_ALIVE: Ioctl = _IOWR::<WuwaIsProcAliveCmd>(b'W' as u32, 13);
const WUWA_IOCTL_HIDE_PROCESS: Ioctl = _IOWR::<WuwaHideProcCmd>(b'W' as u32, 14);
const WUWA_IOCTL_GIVE_ROOT: Ioctl = _IOWR::<WuwaGiveRootCmd>(b'W' as u32, 15);
const WUWA_IOCTL_READ_MEMORY_IOREMAP: Ioctl = _IOWR::<WuwaReadPhysicalMemoryIoremapCmd>(b'W' as u32, 16);
const WUWA_IOCTL_WRITE_MEMORY_IOREMAP: Ioctl = _IOWR::<WuwaWritePhysicalMemoryIoremapCmd>(b'W' as u32, 17);
const WUWA_IOCTL_BIND_PROC: Ioctl = _IOWR::<WuwaBindProcCmd>(b'W' as u32, 18);

// Command structures matching kernel definitions

#[repr(C)]
pub struct WuwaAddrTranslateCmd {
    pub phy_addr: u64,
    pub pid: pid_t,
    pub va: usize,
}

#[repr(C)]
pub struct WuwaDebugInfoCmd {
    pub ttbr0_el1: u64,
    pub task_struct: u64,
    pub mm_struct: u64,
    pub pgd_addr: u64,
    pub pgd_phys_addr: u64,
    pub mm_asid: u64,
    pub mm_right: u32,
}

#[repr(C)]
pub struct WuwaAtS1e0rCmd {
    pub phy_addr: u64,
    pub pid: pid_t,
    pub va: usize,
}

#[repr(C)]
pub union PageUnion {
    pub mapcount: i32,
    pub page_type: u32,
}

#[repr(C)]
pub struct KernelPage {
    pub flags: u64,
    pub union_field: PageUnion,
    pub refcount: i32,
    pub phy_addr: u64,
}

#[repr(C)]
pub struct WuwaPageInfoCmd {
    pub pid: pid_t,
    pub va: usize,
    pub page: KernelPage,
}

#[repr(C)]
pub struct WuwaDmaBufCreateCmd {
    pub pid: pid_t,
    pub va: usize,
    pub size: size_t,
    pub fd: c_int,
}

#[repr(C)]
pub struct WuwaPteMappingCmd {
    pub pid: pid_t,
    pub start_addr: usize,
    pub num_pages: size_t,
    pub hide: c_int,
}

#[repr(C)]
pub struct WuwaPageTableWalkCmd {
    pub pid: pid_t,
}

#[repr(C)]
pub struct WuwaCopyProcessCmd {
    pub pid: pid_t,
    pub fn_ptr: *mut c_void,
    pub child_stack: *mut c_void,
    pub child_stack_size: size_t,
    pub flags: u64,
    pub arg: *mut c_void,
    pub child_tid: *mut c_int,
}

#[repr(C)]
pub struct WuwaReadPhysicalMemoryCmd {
    pub pid: pid_t,
    pub src_va: usize,
    pub dst_va: usize,
    pub size: size_t,
    pub phy_addr: usize,
}

#[repr(C)]
pub struct WuwaWritePhysicalMemoryCmd {
    pub pid: pid_t,
    pub src_va: usize,
    pub dst_va: usize,
    pub size: size_t,
    pub phy_addr: usize,
}

#[repr(C)]
pub struct WuwaGetModuleBaseCmd {
    pub pid: pid_t,
    pub name: [u8; 256],
    pub base: usize,
    pub vm_flag: c_int,
}

#[repr(C)]
pub struct WuwaFindProcCmd {
    pub pid: pid_t,
    pub name: [u8; 256],
}

#[repr(C)]
pub struct WuwaIsProcAliveCmd {
    pub pid: pid_t,
    pub alive: i32,
}

#[repr(C)]
pub struct WuwaHideProcCmd {
    pub pid: pid_t,
    pub hide: i32,
}

#[repr(C)]
pub struct WuwaGiveRootCmd {
    pub result: i32,
}

#[repr(C)]
pub struct WuwaReadPhysicalMemoryIoremapCmd {
    pub pid: pid_t,
    pub src_va: usize,
    pub dst_va: usize,
    pub size: size_t,
    pub phy_addr: usize,
    pub prot: c_int,
}

#[repr(C)]
pub struct WuwaWritePhysicalMemoryIoremapCmd {
    pub pid: pid_t,
    pub src_va: usize,
    pub dst_va: usize,
    pub size: size_t,
    pub phy_addr: usize,
    pub prot: c_int,
}

#[repr(C)]
pub struct WuwaBindProcCmd {
    pub pid: pid_t,
    pub fd: c_int,
}

/// WuWa driver connection handle
pub struct WuWaDriver {
    sock: OwnedFd,
}

impl WuWaDriver {
    /// Discover driver by probing address families
    fn driver_id() -> Result<OwnedFd, anyhow::Error> {
        let address_families = [
            AddressFamily::Decnet,
            AddressFamily::NetBeui,
            AddressFamily::Security,
            AddressFamily::Key,
            AddressFamily::Netlink,
            AddressFamily::Packet,
            AddressFamily::Ash,
            AddressFamily::Econet,
            AddressFamily::AtmSvc,
            AddressFamily::Rds,
            AddressFamily::Sna,
            AddressFamily::Irda,
            AddressFamily::Pppox,
            AddressFamily::Wanpipe,
            AddressFamily::Llc,
            AddressFamily::Can,
            AddressFamily::Tipc,
            AddressFamily::Bluetooth,
            AddressFamily::Iucv,
            AddressFamily::RxRpc,
            AddressFamily::Isdn,
            AddressFamily::Phonet,
            AddressFamily::Ieee802154,
            AddressFamily::Caif,
            AddressFamily::Alg,
            AddressFamily::Vsock,
        ];

        for af in address_families.iter() {
            match socket(
                *af,
                SockType::SeqPacket,
                SockFlag::empty(),
                None,
            ) {
                Ok(_) => {
                    continue
                }
                Err(Errno::ENOKEY) => {
                    match socket(
                        *af,
                        SockType::Raw,
                        SockFlag::empty(),
                        None,
                    ) {
                        Ok(fd) => {
                            if log_enabled!(Level::Debug) {
                                debug!("WuWa driver found on {:?}", af);
                            }
                            return Ok(fd);
                        }
                        Err(_) => continue,
                    }
                }
                Err(_) => continue,
            }
        }
        Err(anyhow!("WuWa driver not found"))
    }

    /// Connect to WuWa driver. Requires root or CAP_NET_RAW.
    pub fn new() -> Result<Self, anyhow::Error> {
        let sock = Self::driver_id()?;
        Ok(Self { sock })
    }

    /// Software page table walk: VA -> PA translation
    pub fn addr_translate(&self, pid: pid_t, va: usize) -> Result<u64, anyhow::Error> {
        let mut cmd = WuwaAddrTranslateCmd {
            phy_addr: 0,
            pid,
            va,
        };

        unsafe {
            let result = ioctl(self.sock.as_raw_fd(), WUWA_IOCTL_ADDR_TRANSLATE, &mut cmd as *mut _ as *mut c_void);
            if result < 0 {
                return Err(anyhow!("VA->PA translation failed"));
            }
        }

        Ok(cmd.phy_addr)
    }

    /// Get process debug info (TTBR0, task_struct, mm_struct, pgd)
    pub fn get_debug_info(&self, pid: pid_t) -> Result<WuwaDebugInfoCmd, anyhow::Error> {
        let mut cmd = WuwaDebugInfoCmd {
            ttbr0_el1: 0,
            task_struct: 0,
            mm_struct: 0,
            pgd_addr: 0,
            pgd_phys_addr: 0,
            mm_asid: 0,
            mm_right: 0,
        };

        unsafe {
            let result = ioctl(self.sock.as_raw_fd(), WUWA_IOCTL_DEBUG_INFO, &mut cmd as *mut _ as *mut c_void);
            if result < 0 {
                return Err(anyhow!("Failed to get debug info"));
            }
        }

        Ok(cmd)
    }

    /// Hardware AT S1E0R instruction: VA -> PA (faster than software walk)
    pub fn at_s1e0r(&self, pid: pid_t, va: usize) -> Result<u64, anyhow::Error> {
        let mut cmd = WuwaAtS1e0rCmd {
            phy_addr: 0,
            pid,
            va,
        };

        unsafe {
            let result = ioctl(self.sock.as_raw_fd(), WUWA_IOCTL_AT_S1E0R, &mut cmd as *mut _ as *mut c_void);
            if result < 0 {
                return Err(anyhow!("AT S1E0R failed"));
            }
        }

        Ok(cmd.phy_addr)
    }

    /// Query page flags, refcount, mapcount at VA
    pub fn get_page_info(&self, pid: pid_t, va: usize) -> Result<KernelPage, anyhow::Error> {
        let mut cmd = WuwaPageInfoCmd {
            pid,
            va,
            page: KernelPage {
                flags: 0,
                union_field: PageUnion { mapcount: 0 },
                refcount: 0,
                phy_addr: 0,
            },
        };

        unsafe {
            let result = ioctl(self.sock.as_raw_fd(), WUWA_IOCTL_PAGE_INFO, &mut cmd as *mut _ as *mut c_void);
            if result < 0 {
                return Err(anyhow!("Failed to get page info"));
            }
        }

        Ok(cmd.page)
    }

    /// Export process memory region as dma-buf fd for zero-copy sharing
    pub fn create_dma_buf(&self, pid: pid_t, va: usize, size: size_t) -> Result<c_int, anyhow::Error> {
        let mut cmd = WuwaDmaBufCreateCmd {
            pid,
            va,
            size,
            fd: -1,
        };

        unsafe {
            let result = ioctl(self.sock.as_raw_fd(), WUWA_IOCTL_DMA_BUF_CREATE, &mut cmd as *mut _ as *mut c_void);
            if result < 0 {
                return Err(anyhow!("DMA-BUF creation failed"));
            }
        }

        Ok(cmd.fd)
    }

    /// Direct PTE manipulation (hide/unhide pages)
    pub fn pte_mapping(&self, pid: pid_t, start_addr: usize, num_pages: size_t, hide: bool) -> Result<(), anyhow::Error> {
        let mut cmd = WuwaPteMappingCmd {
            pid,
            start_addr,
            num_pages,
            hide: if hide { 1 } else { 0 },
        };

        unsafe {
            let result = ioctl(self.sock.as_raw_fd(), WUWA_IOCTL_PTE_MAPPING, &mut cmd as *mut _ as *mut c_void);
            if result < 0 {
                return Err(anyhow!("PTE mapping failed"));
            }
        }

        Ok(())
    }

    /// Dump complete page table to dmesg
    pub fn page_table_walk(&self, pid: pid_t) -> Result<(), anyhow::Error> {
        let mut cmd = WuwaPageTableWalkCmd { pid };

        unsafe {
            let result = ioctl(self.sock.as_raw_fd(), WUWA_IOCTL_PAGE_TABLE_WALK, &mut cmd as *mut _ as *mut c_void);
            if result < 0 {
                return Err(anyhow!("Page table walk failed"));
            }
        }

        Ok(())
    }

    /// Read physical memory via phys_to_virt (max 50MB per call)
    pub fn read_physical_memory(&self, pid: pid_t, src_va: usize, dst_va: usize, size: size_t) -> Result<usize, anyhow::Error> {
        let mut cmd = WuwaReadPhysicalMemoryCmd {
            pid,
            src_va,
            dst_va,
            size,
            phy_addr: 0,
        };

        unsafe {
            let result = ioctl(self.sock.as_raw_fd(), WUWA_IOCTL_READ_MEMORY, &mut cmd as *mut _ as *mut c_void);
            if result < 0 {
                return Err(anyhow!("Physical memory read failed: va=0x{:x} size={}", src_va, size));
            }
        }

        Ok(cmd.phy_addr)
    }

    /// Write physical memory via phys_to_virt (max 50MB per call)
    pub fn write_physical_memory(&self, pid: pid_t, src_va: usize, dst_va: usize, size: size_t) -> Result<usize, anyhow::Error> {
        let mut cmd = WuwaWritePhysicalMemoryCmd {
            pid,
            src_va,
            dst_va,
            size,
            phy_addr: 0,
        };

        unsafe {
            let result = ioctl(self.sock.as_raw_fd(), WUWA_IOCTL_WRITE_MEMORY, &mut cmd as *mut _ as *mut c_void);
            if result < 0 {
                return Err(anyhow!("Physical memory write failed: va=0x{:x} size={}", src_va, size));
            }
        }

        Ok(cmd.phy_addr)
    }

    /// Type-safe read of arbitrary struct from target process
    pub fn read<T: Sized>(&self, pid: pid_t, src_va: usize) -> Result<T, anyhow::Error> {
        let mut buffer: MaybeUninit<T> = MaybeUninit::uninit();
        let buffer_ptr = buffer.as_mut_ptr() as usize;
        let size = size_of::<T>();

        self.read_physical_memory(pid, src_va, buffer_ptr, size)?;

        unsafe {
            Ok(buffer.assume_init())
        }
    }

    /// Type-safe write of arbitrary struct to target process
    pub fn write<T: Sized>(&self, pid: pid_t, dst_va: usize, value: &T) -> Result<(), anyhow::Error> {
        let value_ptr = value as *const T as usize;
        let size = size_of::<T>();

        self.write_physical_memory(pid, value_ptr, dst_va, size)?;

        Ok(())
    }

    /// Read Unreal Engine FString from target process
    pub fn read_fstring(&self, pid: pid_t, addr: usize) -> Result<String, anyhow::Error> {
        let len = self.read::<u32>(pid, addr + 8)? as usize;
        if len == 0 {
            return Ok("".to_string());
        }
        let player_name_private = self.read::<usize>(pid, addr)?;
        let mut player_name = vec![];
        unsafe { self.read_to_utf8(pid, player_name_private as *const u16, &mut player_name, len - 1)?; }
        String::from_utf8(player_name).map_err(|e| anyhow!("FString decode failed: {:?}", e))
    }

    /// Read FString with length limit
    pub fn read_fstring_limit(&self, pid: pid_t, addr: usize, max_len: usize) -> Result<String, anyhow::Error> {
        let len = self.read::<u32>(pid, addr + 8)? as usize;
        if len == 0 {
            return Ok("".to_string());
        }

        if len > max_len {
            return Err(anyhow!("FString length {} exceeds limit {}", len, max_len));
        }

        let player_name_private = self.read::<usize>(pid, addr)?;
        let mut player_name = vec![];
        unsafe { self.read_to_utf8(pid, player_name_private as *const u16, &mut player_name, len - 1)?; }
        String::from_utf8(player_name).map_err(|e| anyhow!("FString decode failed: {:?}", e))
    }

    /// Convert UTF-16 in target process to UTF-8 in local buffer
    pub unsafe fn read_to_utf8(&self, pid: pid_t, ptr: *const u16, buf: &mut Vec<u8>, length: usize) -> Result<(), anyhow::Error> {
        let mut temp_utf16 = ptr;
        let end = ptr.add(length);

        while temp_utf16 < end {
            let utf16_char = self.read::<u16>(pid, temp_utf16 as usize)?;

            if utf16_char <= 0x007F {
                buf.push(utf16_char as u8);
            } else if utf16_char <= 0x07FF {
                buf.push(((utf16_char >> 6) | 0xC0) as u8);
                buf.push(((utf16_char & 0x3F) | 0x80) as u8);
            } else {
                buf.push(((utf16_char >> 12) | 0xE0) as u8);
                buf.push(((utf16_char >> 6 & 0x3F) | 0x80) as u8);
                buf.push(((utf16_char & 0x3F) | 0x80) as u8);
            }

            temp_utf16 = temp_utf16.add(1);
        }
        Ok(())
    }

    /// Get module/library base address in target process
    ///
    /// # Arguments
    /// * `vm_flag` - VM flags to filter (e.g., 0x4 for VM_EXEC)
    pub fn get_module_base(&self, pid: pid_t, name: &str, vm_flag: c_int) -> Result<usize, anyhow::Error> {
        let mut cmd = WuwaGetModuleBaseCmd {
            pid,
            name: [0; 256],
            base: 0,
            vm_flag,
        };

        let name_bytes = name.as_bytes();
        let copy_len = std::cmp::min(name_bytes.len(), 255);
        cmd.name[..copy_len].copy_from_slice(&name_bytes[..copy_len]);

        unsafe {
            let result = ioctl(self.sock.as_raw_fd(), WUWA_IOCTL_GET_MODULE_BASE, &mut cmd as *mut _ as *mut c_void);
            if result < 0 {
                return Err(anyhow!("Module base query failed"));
            }
        }

        Ok(cmd.base)
    }

    /// Find process by name, returns PID
    pub fn find_process(&self, name: &str) -> Result<pid_t, anyhow::Error> {
        let mut cmd = WuwaFindProcCmd {
            pid: 0,
            name: [0; 256],
        };

        let name_bytes = name.as_bytes();
        let copy_len = std::cmp::min(name_bytes.len(), 255);
        cmd.name[..copy_len].copy_from_slice(&name_bytes[..copy_len]);

        unsafe {
            let result = ioctl(self.sock.as_raw_fd(), WUWA_IOCTL_FIND_PROCESS, &mut cmd as *mut _ as *mut c_void);
            if result < 0 {
                return Err(anyhow!("Process search failed"));
            }
        }

        if cmd.pid == 0 {
            return Err(anyhow!("Process not found"));
        }

        Ok(cmd.pid)
    }

    /// Check if process is alive
    pub fn is_process_alive(&self, pid: pid_t) -> Result<bool, anyhow::Error> {
        let mut cmd = WuwaIsProcAliveCmd {
            pid,
            alive: 0,
        };

        unsafe {
            let result = ioctl(self.sock.as_raw_fd(), WUWA_IOCTL_IS_PROCESS_ALIVE, &mut cmd as *mut _ as *mut c_void);
            if result < 0 {
                return Err(anyhow!("Process liveness check failed"));
            }
        }

        Ok(cmd.alive != 0)
    }

    /// Hide/unhide process from system visibility
    pub fn hide_process(&self, pid: pid_t, hide: bool) -> Result<(), anyhow::Error> {
        let mut cmd = WuwaHideProcCmd {
            pid,
            hide: if hide { 1 } else { 0 },
        };

        unsafe {
            let result = ioctl(self.sock.as_raw_fd(), WUWA_IOCTL_HIDE_PROCESS, &mut cmd as *mut _ as *mut c_void);
            if result < 0 {
                return Err(anyhow!("Process hide/unhide failed"));
            }
        }

        Ok(())
    }

    /// Escalate current process to root (uid=0, gid=0)
    pub fn give_root(&self) -> Result<(), anyhow::Error> {
        let mut cmd = WuwaGiveRootCmd {
            result: 0,
        };

        unsafe {
            let result = ioctl(self.sock.as_raw_fd(), WUWA_IOCTL_GIVE_ROOT, &mut cmd as *mut _ as *mut c_void);
            if result < 0 {
                return Err(anyhow!("Root escalation failed"));
            }
        }

        if cmd.result < 0 {
            return Err(anyhow!("Root escalation rejected: error {}", cmd.result));
        }

        Ok(())
    }

    /// Read physical memory via ioremap with memory attribute control
    ///
    /// # Arguments
    /// * `prot` - Memory type (use MT_* constants from kernel)
    pub fn read_physical_memory_ioremap(&self, pid: pid_t, src_va: usize, dst_va: usize, size: size_t, prot: c_int) -> Result<usize, anyhow::Error> {
        let mut cmd = WuwaReadPhysicalMemoryIoremapCmd {
            pid,
            src_va,
            dst_va,
            size,
            phy_addr: 0,
            prot,
        };

        unsafe {
            let result = ioctl(self.sock.as_raw_fd(), WUWA_IOCTL_READ_MEMORY_IOREMAP, &mut cmd as *mut _ as *mut c_void);
            if result < 0 {
                return Err(anyhow!("ioremap read failed: va=0x{:x} size={}", src_va, size));
            }
        }

        Ok(cmd.phy_addr)
    }

    /// Write physical memory via ioremap with memory attribute control
    ///
    /// # Arguments
    /// * `prot` - Memory type (use MT_* constants from kernel)
    pub fn write_physical_memory_ioremap(&self, pid: pid_t, src_va: usize, dst_va: usize, size: size_t, prot: c_int) -> Result<usize, anyhow::Error> {
        let mut cmd = WuwaWritePhysicalMemoryIoremapCmd {
            pid,
            src_va,
            dst_va,
            size,
            phy_addr: 0,
            prot,
        };

        unsafe {
            let result = ioctl(self.sock.as_raw_fd(), WUWA_IOCTL_WRITE_MEMORY_IOREMAP, &mut cmd as *mut _ as *mut c_void);
            if result < 0 {
                return Err(anyhow!("ioremap write failed: va=0x{:x} size={}", src_va, size));
            }
        }

        Ok(cmd.phy_addr)
    }

    /// Bind process, returns anonymous file descriptor
    pub fn bind_process(&self, pid: pid_t) -> Result<c_int, anyhow::Error> {
        let mut cmd = WuwaBindProcCmd {
            pid,
            fd: -1,
        };

        unsafe {
            let result = ioctl(self.sock.as_raw_fd(), WUWA_IOCTL_BIND_PROC, &mut cmd as *mut _ as *mut c_void);
            if result < 0 {
                return Err(anyhow!("Process bind failed"));
            }
        }

        Ok(cmd.fd)
    }

    /// Copy process with custom function pointer and stack
    pub fn copy_process(&self, pid: pid_t, fn_ptr: *mut c_void, child_stack: *mut c_void, child_stack_size: size_t, flags: u64, arg: *mut c_void) -> Result<c_int, anyhow::Error> {
        let mut cmd = WuwaCopyProcessCmd {
            pid,
            fn_ptr,
            child_stack,
            child_stack_size,
            flags,
            arg,
            child_tid: std::ptr::null_mut(),
        };

        unsafe {
            let result = ioctl(self.sock.as_raw_fd(), WUWA_IOCTL_COPY_PROCESS, &mut cmd as *mut _ as *mut c_void);
            if result < 0 {
                return Err(anyhow!("Process copy failed"));
            }
        }

        Ok(0)
    }
}

```

`envsetup.sh`:

```sh
export DDK_ROOT=/opt/ddk

export KERNEL_SRC=$DDK_ROOT/kdir/android12-5.10
export CLANG_PATH=$DDK_ROOT/clang/clang-r416183b/bin

# export KERNEL_SRC=$DDK_ROOT/kdir/android13-5.15
# export CLANG_PATH=$DDK_ROOT/clang/clang-r450784e/bin

# export KERNEL_SRC=$DDK_ROOT/kdir/android14-6.1
# export CLANG_PATH=$DDK_ROOT/clang/clang-r487747c/bin

# export CLANG_PATH=/home/ylarod/Android/Sdk/ndk/25.2.9519653/toolchains/llvm/prebuilt/linux-x86_64/bin
export PATH=$CLANG_PATH:$PATH
export CROSS_COMPILE=aarch64-linux-gnu-
export ARCH=arm64
export LLVM=1
export LLVM_IAS=1

```

`scripts/build-ddk.sh`:

```sh
#!/bin/bash

# DDK Build Script for android-wuwa kernel module
# This script uses Ylarod/ddk to build the kernel module in a containerized environment

set -e

# Default values
DEFAULT_TARGET="android12-5.10"
MODULE_NAME="android-wuwa"

# Detect system language
if [[ "$LANG" =~ ^zh ]]; then
    LANG_MODE="zh"
else
    LANG_MODE="en"
fi

# Color output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Print colored message
print_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

print_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

print_success() {
    echo -e "${CYAN}[SUCCESS]${NC} $1"
}

# Localized messages
msg() {
    local key="$1"
    case "$key" in
        "usage_header")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "使用方法"
            else
                echo "Usage"
            fi
            ;;
        "description")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "使用 DDK 构建、清理和配置 android-wuwa 内核模块"
            else
                echo "Build, clean, and configure android-wuwa kernel module using DDK"
            fi
            ;;
        "commands")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "命令"
            else
                echo "Commands"
            fi
            ;;
        "build_desc")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "构建内核模块"
            else
                echo "Build kernel module"
            fi
            ;;
        "clean_desc")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "清理构建产物"
            else
                echo "Clean build artifacts"
            fi
            ;;
        "compdb_desc")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "生成 compile_commands.json（用于 IDE 支持）"
            else
                echo "Generate compile_commands.json (for IDE support)"
            fi
            ;;
        "config_desc")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "配置编译选项开关"
            else
                echo "Configure build feature flags"
            fi
            ;;
        "list_desc")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "列出已安装的 DDK 镜像"
            else
                echo "List installed DDK images"
            fi
            ;;
        "options")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "选项"
            else
                echo "Options"
            fi
            ;;
        "target_opt")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "DDK 目标（默认：android12-5.10）"
            else
                echo "DDK target (default: android12-5.10)"
            fi
            ;;
        "strip_opt")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "裁剪调试符号以减小文件大小"
            else
                echo "Strip debug symbols to reduce file size"
            fi
            ;;
        "examples")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "示例"
            else
                echo "Examples"
            fi
            ;;
        "ddk_not_installed")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "ddk 未安装！"
            else
                echo "ddk is not installed!"
            fi
            ;;
        "install_ddk")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "请先安装 ddk："
            else
                echo "Please install ddk first:"
            fi
            ;;
        "more_info")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "更多信息，请访问："
            else
                echo "For more information, visit:"
            fi
            ;;
        "docker_not_installed")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "Docker 未安装！"
            else
                echo "Docker is not installed!"
            fi
            ;;
        "docker_required")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "DDK 需要 Docker 才能运行。请先安装 Docker："
            else
                echo "DDK requires Docker to run. Please install Docker first:"
            fi
            ;;
        "docker_permission_error")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "无法访问 Docker 守护进程！"
            else
                echo "Cannot access Docker daemon!"
            fi
            ;;
        "docker_needs_root")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "Docker 在此系统上需要 root 权限。"
            else
                echo "Docker requires root privileges on this system."
            fi
            ;;
        "solutions")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "解决方案："
            else
                echo "Solutions:"
            fi
            ;;
        "run_with_sudo")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "使用 sudo 运行此脚本："
            else
                echo "Run this script with sudo:"
            fi
            ;;
        "add_to_docker_group")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "将您的用户添加到 docker 组（需要注销/登录）："
            else
                echo "Add your user to the docker group (requires logout/login):"
            fi
            ;;
        "build_config")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "构建配置："
            else
                echo "Build Configuration:"
            fi
            ;;
        "target")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "目标"
            else
                echo "Target"
            fi
            ;;
        "module")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "模块"
            else
                echo "Module"
            fi
            ;;
        "strip")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "裁剪"
            else
                echo "Strip"
            fi
            ;;
        "checking_image")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "检查 DDK 镜像："
            else
                echo "Checking DDK image for target:"
            fi
            ;;
        "installed_images")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "已安装的镜像："
            else
                echo "Installed images:"
            fi
            ;;
        "no_images")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "无已安装的镜像"
            else
                echo "No installed images"
            fi
            ;;
        "image_not_found")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "镜像未在本地找到，正在从仓库拉取..."
            else
                echo "Image not found locally, pulling from registry..."
            fi
            ;;
        "pull_failed")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "拉取镜像失败："
            else
                echo "Failed to pull image for target:"
            fi
            ;;
        "check_target")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "请检查目标是否存在："
            else
                echo "Please check if the target exists:"
            fi
            ;;
        "cleaning")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "清理之前的构建产物..."
            else
                echo "Cleaning previous build artifacts..."
            fi
            ;;
        "clean_complete")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "清理完成！"
            else
                echo "Clean completed!"
            fi
            ;;
        "building")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "正在构建内核模块..."
            else
                echo "Building kernel module..."
            fi
            ;;
        "build_success")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "构建成功！"
            else
                echo "Build successful!"
            fi
            ;;
        "output")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "输出"
            else
                echo "Output"
            fi
            ;;
        "module_size")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "模块大小"
            else
                echo "Module size"
            fi
            ;;
        "stripping")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "正在裁剪调试符号..."
            else
                echo "Stripping debug symbols..."
            fi
            ;;
        "size_after_strip")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "裁剪后大小"
            else
                echo "Size after stripping"
            fi
            ;;
        "module_info")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "模块信息："
            else
                echo "Module information:"
            fi
            ;;
        "module_not_found")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "模块文件未找到，但构建报告成功"
            else
                echo "Module file not found, but build reported success"
            fi
            ;;
        "build_failed")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "构建失败！"
            else
                echo "Build failed!"
            fi
            ;;
        "common_issues")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "常见问题："
            else
                echo "Common issues:"
            fi
            ;;
        "issue_1")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "不兼容的内核目标 - 检查可用目标"
            else
                echo "Incompatible kernel target - check available targets"
            fi
            ;;
        "issue_2")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "Makefile 中缺少依赖"
            else
                echo "Missing dependencies in Makefile"
            fi
            ;;
        "issue_3")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "源代码中的语法错误"
            else
                echo "Syntax errors in source code"
            fi
            ;;
        "check_log")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "检查上面的构建日志以获取详细信息。"
            else
                echo "Check the build log above for details."
            fi
            ;;
        "generating_compdb")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "正在生成 compile_commands.json..."
            else
                echo "Generating compile_commands.json..."
            fi
            ;;
        "compdb_success")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "compile_commands.json 生成成功！"
            else
                echo "compile_commands.json generated successfully!"
            fi
            ;;
        "compdb_failed")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "生成 compile_commands.json 失败！"
            else
                echo "Failed to generate compile_commands.json!"
            fi
            ;;
        "config_title")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "配置编译选项"
            else
                echo "Configure Build Features"
            fi
            ;;
        "current_config")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "当前配置："
            else
                echo "Current configuration:"
            fi
            ;;
        "enable")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "启用"
            else
                echo "Enabled"
            fi
            ;;
        "disable")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "禁用"
            else
                echo "Disabled"
            fi
            ;;
        "toggle_prompt")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "输入编号切换开关，输入 's' 保存并退出，输入 'q' 不保存退出："
            else
                echo "Enter number to toggle, 's' to save and exit, 'q' to quit without saving:"
            fi
            ;;
        "invalid_choice")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "无效的选择"
            else
                echo "Invalid choice"
            fi
            ;;
        "config_saved")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "配置已保存！"
            else
                echo "Configuration saved!"
            fi
            ;;
        "config_cancelled")
            if [[ "$LANG_MODE" == "zh" ]]; then
                echo "配置取消，未保存更改。"
            else
                echo "Configuration cancelled, no changes saved."
            fi
            ;;
    esac
}

# Check if ddk is installed
check_ddk_installed() {
    if ! command -v ddk &> /dev/null; then
        print_error "$(msg "ddk_not_installed")"
        echo ""
        echo "$(msg "install_ddk")"
        echo "  sudo curl -fsSL https://raw.githubusercontent.com/Ylarod/ddk/main/scripts/ddk -o /usr/local/bin/ddk"
        echo "  sudo chmod +x /usr/local/bin/ddk"
        echo ""
        echo "$(msg "more_info") https://github.com/Ylarod/ddk"
        exit 1
    fi
}

# Check docker permissions
check_docker_permission() {
    if ! command -v docker &> /dev/null; then
        print_error "$(msg "docker_not_installed")"
        echo ""
        echo "$(msg "docker_required")"
        echo "  https://docs.docker.com/engine/install/"
        exit 1
    fi

    # Try to run docker without sudo
    if ! docker info &> /dev/null; then
        print_error "$(msg "docker_permission_error")"
        echo ""
        echo "$(msg "docker_needs_root")"
        echo ""
        echo "$(msg "solutions")"
        echo "  1. $(msg "run_with_sudo")"
        echo "     sudo $0 $*"
        echo ""
        echo "  2. $(msg "add_to_docker_group")"
        echo "     sudo usermod -aG docker \$USER"
        echo "     newgrp docker"
        echo ""
        exit 1
    fi
}

# Display usage
usage() {
    cat << EOF
$(msg "usage_header"): $0 <command> [options]

$(msg "description")

$(msg "commands"):
  build [target]    $(msg "build_desc")
  clean [target]    $(msg "clean_desc")
  compdb [target]   $(msg "compdb_desc")
  config            $(msg "config_desc")
  list              $(msg "list_desc")

$(msg "options"):
  -t, --target      $(msg "target_opt")
  -s, --strip       $(msg "strip_opt")
  -h, --help        Show this help message

$(msg "examples"):
  $0 build                          # Build with default target
  $0 build android14-6.1            # Build for specific target
  $0 build -t android14-6.1 --strip # Build and strip debug symbols
  $0 clean android12-5.10           # Clean specific target
  $0 compdb                         # Generate compile_commands.json
  $0 config                         # Configure build features
  $0 list                           # List installed DDK images

Available targets: https://github.com/Ylarod/ddk/pkgs/container/ddk/versions

EOF
}

# Strip ko file
strip_module() {
    local module_file="$1"

    if [ ! -f "$module_file" ]; then
        print_error "$(msg "module_not_found")"
        return 1
    fi

    print_info "$(msg "stripping")"
    local size_before=$(du -h "$module_file" | cut -f1)

    # Get absolute path for docker volume mount
    local abs_path=$(realpath "$module_file")
    local dir_path=$(dirname "$abs_path")
    local file_name=$(basename "$abs_path")

    # Get the DDK image name
    local image_name="ghcr.io/ylarod/ddk:$TARGET"

    # Check if image exists
    if ! docker images --format "{{.Repository}}:{{.Tag}}" | grep -q "$image_name"; then
        # Fallback to host strip if available
        if command -v llvm-strip &> /dev/null; then
            llvm-strip -d "$module_file"
        elif command -v strip &> /dev/null; then
            strip -d "$module_file"
        else
            print_warn "strip/llvm-strip not found, skipping..."
            return 0
        fi
    else
        # Use docker run to execute strip in container
        docker run --rm -v "$dir_path:/work" "$image_name" llvm-strip -d "/work/$file_name" 2>/dev/null || \
        docker run --rm -v "$dir_path:/work" "$image_name" strip -d "/work/$file_name" 2>/dev/null || {
            # Fallback to host strip
            if command -v llvm-strip &> /dev/null; then
                llvm-strip -d "$module_file"
            elif command -v strip &> /dev/null; then
                strip -d "$module_file"
            else
                print_warn "strip/llvm-strip not found, skipping..."
                return 0
            fi
        }
    fi

    local size_after=$(du -h "$module_file" | cut -f1)
    print_success "$(msg "size_after_strip"): $size_before -> $size_after"
}

# Build module
cmd_build() {
    local TARGET="$DEFAULT_TARGET"
    local STRIP_MODULE=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -t|--target)
                TARGET="$2"
                shift 2
                ;;
            -s|--strip)
                STRIP_MODULE=true
                shift
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            *)
                TARGET="$1"
                shift
                ;;
        esac
    done

    print_info "DDK Build Script for android-wuwa"
    echo ""

    # Check prerequisites
    check_ddk_installed
    check_docker_permission

    # Display build configuration
    print_info "$(msg "build_config")"
    echo "  $(msg "target"): $TARGET"
    echo "  $(msg "module"): $MODULE_NAME.ko"
    echo "  $(msg "strip"): $([ "$STRIP_MODULE" = true ] && echo "$(msg "enable")" || echo "$(msg "disable")")"
    echo ""

    # Pull image if needed
    print_info "$(msg "checking_image") $TARGET"
    if ! ddk list 2>/dev/null | grep -q "$TARGET"; then
        print_warn "$(msg "image_not_found")"
        ddk pull "$TARGET" || {
            print_error "$(msg "pull_failed") $TARGET"
            echo ""
            echo "$(msg "check_target")"
            echo "  https://github.com/Ylarod/ddk/pkgs/container/ddk/versions"
            exit 1
        }
    fi

    # Clean previous build
    print_info "$(msg "cleaning")"
    ddk clean --target "$TARGET" 2>/dev/null || true

    # Build the module
    print_info "$(msg "building")"
    echo ""

    if ddk build --target "$TARGET"; then
        echo ""
        print_success "$(msg "build_success")"
        print_info "$(msg "output"): $MODULE_NAME.ko"
        echo ""

        # Check if the module was built
        if [ -f "$MODULE_NAME.ko" ]; then
            MODULE_SIZE=$(du -h "$MODULE_NAME.ko" | cut -f1)
            print_info "$(msg "module_size"): $MODULE_SIZE"

            # Strip if requested
            if [ "$STRIP_MODULE" = true ]; then
                strip_module "$MODULE_NAME.ko"
            fi

            # Display module info
            if command -v modinfo &> /dev/null; then
                echo ""
                print_info "$(msg "module_info")"
                modinfo "$MODULE_NAME.ko" 2>/dev/null || true
            fi
        else
            print_warn "$(msg "module_not_found")"
        fi
        echo ""
    else
        echo ""
        print_error "$(msg "build_failed")"
        echo ""
        echo "$(msg "common_issues")"
        echo "  1. $(msg "issue_1")"
        echo "  2. $(msg "issue_2")"
        echo "  3. $(msg "issue_3")"
        echo ""
        echo "$(msg "check_log")"
        exit 1
    fi
}

# Clean build artifacts
cmd_clean() {
    local TARGET="${1:-$DEFAULT_TARGET}"

    check_ddk_installed
    check_docker_permission

    print_info "$(msg "cleaning")"
    echo "  $(msg "target"): $TARGET"
    echo ""

    ddk clean --target "$TARGET"

    print_success "$(msg "clean_complete")"
}

# Generate compile_commands.json
cmd_compdb() {
    local TARGET="${1:-$DEFAULT_TARGET}"

    check_ddk_installed
    check_docker_permission

    print_info "$(msg "generating_compdb")"
    echo "  $(msg "target"): $TARGET"
    echo ""

    # Get the DDK image name
    local image_name="ghcr.io/ylarod/ddk:$TARGET"

    # Check if image exists, pull if needed
    if ! docker images --format "{{.Repository}}:{{.Tag}}" | grep -q "$image_name"; then
        print_warn "$(msg "image_not_found")"
        ddk pull "$TARGET" || {
            print_error "$(msg "pull_failed") $TARGET"
            exit 1
        }
    fi

    # Get current directory
    local current_dir=$(pwd)

    # Run make compdb in container
    if docker run --rm -v "$current_dir:/build" -w /build "$image_name" make compdb KDIR=\$KERNEL_SRC; then
        print_success "$(msg "compdb_success")"
    else
        print_error "$(msg "compdb_failed")"
        exit 1
    fi
}

# List installed images
cmd_list() {
    check_ddk_installed
    check_docker_permission

    print_info "$(msg "installed_images")"
    echo ""

    if ddk list 2>/dev/null; then
        echo ""
    else
        echo "  $(msg "no_images")"
        echo ""
    fi
}

# Main entry point
main() {
    if [ $# -eq 0 ]; then
        usage
        exit 0
    fi

    local command="$1"
    shift

    case "$command" in
        build)
            cmd_build "$@"
            ;;
        clean)
            cmd_clean "$@"
            ;;
        compdb)
            cmd_compdb "$@"
            ;;
        list)
            cmd_list "$@"
            ;;
        -h|--help|help)
            usage
            exit 0
            ;;
        *)
            print_error "Unknown command: $command"
            echo ""
            usage
            exit 1
            ;;
    esac
}

# Run main function
main "$@"

```

`src/core/wuwa.c`:

```c
#include <asm/tlbflush.h>
#include <asm/unistd.h>
#include <linux/fs.h>
#include <linux/init.h>
#include <linux/init_task.h>
#include <linux/kernel.h>
#include <linux/kprobes.h>
#include <linux/list.h>
#include <linux/module.h>
#include <linux/syscalls.h>
#include <linux/types.h>
#include "wuwa_common.h"
#include "wuwa_kallsyms.h"
#include "wuwa_protocol.h"
#include "wuwa_safe_signal.h"
#include "wuwa_sock.h"
#include "wuwa_utils.h"
#include "hijack_arm64.h"

static int __init wuwa_init(void) {
    int ret;
    wuwa_info("helo!\n");

#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0))
    ret = disable_kprobe_blacklist();
    if (ret) {
        wuwa_err("disable_kprobe_blacklist failed: %d\n", ret);
        return ret;
    }
#endif

    ret = init_arch();
    if (ret) {
        wuwa_err("init_arch failed: %d\n", ret);
        return ret;
    }

    ret = wuwa_proto_init();
    if (ret) {
        wuwa_err("wuwa_socket_init failed: %d\n", ret);
        goto out;
    }

#if defined(BUILD_HIDE_SIGNAL)
    ret = wuwa_safe_signal_init();
    if (ret) {
        wuwa_err("wuwa_safe_signal_init failed: %d\n", ret);
        goto clean_sig;
    }
#endif


#if defined(HIDE_SELF_MODULE)
    hide_module();
#endif

#if defined(BUILD_NO_CFI)
    wuwa_info("NO_CFI is enabled, patched: %d\n", cfi_bypass());
#endif

    return 0;

#if defined(BUILD_HIDE_SIGNAL)
clean_d0:
    wuwa_safe_signal_cleanup();

clean_sig:
    wuwa_proto_cleanup();
#endif


out:
    return ret;
}

static void __exit wuwa_exit(void) {
    wuwa_info("bye!\n");
    wuwa_proto_cleanup();
#if defined(BUILD_HIDE_SIGNAL)
    wuwa_safe_signal_cleanup();
#endif
}

module_init(wuwa_init);
module_exit(wuwa_exit);

MODULE_AUTHOR("fuqiuluo");
MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("https://github.com/fuqiuluo/android-wuwa");
MODULE_VERSION("1.0.5");

MODULE_IMPORT_NS(DMA_BUF);

```

`src/core/wuwa_common.h`:

```h
#ifndef WUWA_COMMON_H
#define WUWA_COMMON_H

#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/net.h>
#include <net/sock.h>
#include "wuwa_utils.h"

#define WUWA_LOG_PREFIX "[wuwa] "
#define wuwa_info(fmt, ...) pr_info(WUWA_LOG_PREFIX fmt, ##__VA_ARGS__)
#define wuwa_warn(fmt, ...) pr_warn(WUWA_LOG_PREFIX fmt, ##__VA_ARGS__)
#define wuwa_err(fmt, ...) pr_err(WUWA_LOG_PREFIX fmt, ##__VA_ARGS__)
#define wuwa_debug(fmt, ...) pr_debug(WUWA_LOG_PREFIX fmt, ##__VA_ARGS__)

#define ovo_info(fmt, ...) pr_info(WUWA_LOG_PREFIX "%s: " fmt, __func__, ##__VA_ARGS__)

#define ovo_warn(fmt, ...) pr_warn(WUWA_LOG_PREFIX "%s: " fmt, __func__, ##__VA_ARGS__)

#define ovo_err(fmt, ...) pr_err(WUWA_LOG_PREFIX "%s: " fmt, __func__, ##__VA_ARGS__)

#define ovo_debug(fmt, ...) pr_debug(WUWA_LOG_PREFIX "%s: " fmt, __func__, ##__VA_ARGS__)

#define LUCKY_LUO 0x00000000faceb00c

#define CONFIG_COMPARE_TASK 0
#define CONFIG_COMPARE_PT_REGS 0

#define CONFIG_COPY_PROCESS 0
/*
 * !!!Poor performance!!!
 */
#define CONFIG_REDIRECT_VIA_ABORT 0

/*
 * !!!!Poor performance!!!
 * The LR address redirection is achieved by using the Linux signal processor mechanism.
 *  > is unsafe and has competition risks.
 *  > is only used for learning and verification that
 *     it can be injected into the executable memory and executed normally without any trace.
 */
#define CONFIG_REDIRECT_VIA_SIGNAL 0

#define CMD_MAX_BYTES (50 * 1024 * 1024)
#define CMD_MAX_PAGES (CMD_MAX_BYTES / PAGE_SIZE)

struct wuwa_sock {
    struct sock sk;

    int version;

    pid_t session;

    struct karray_list* used_pages;
};

#endif /* WUWA_COMMON_H */

```

`src/hook/wuwa_safe_signal.c`:

```c
#include "wuwa_safe_signal.h"
#include <asm/ucontext.h>
#include <linux/kprobes.h>
#include <linux/ptrace.h>
#include <linux/signal_types.h>
#include <linux/stddef.h>
#include <linux/vmalloc.h>
#include "wuwa_common.h"
#include "wuwa_utils.h"

struct unsafe_region_area {
    u64 addr;
    u32 nums_page;
    uid_t uid;
    pid_t session_pid;
} __aligned(sizeof(u64));

static struct karray_list* unsafe_region_areas = NULL;
static DEFINE_RWLOCK(unsafe_region_areas_lock);

static bool is_safe_prof_signal(struct ksignal* ksig, struct pt_regs* regs) {
    u64 lr = regs->regs[30];
    u64 pc = regs->pc;

    if (!unsafe_region_areas->data) {
        wuwa_err("unsafe region areas list is empty\n");
        return true;
    }

    read_lock(&unsafe_region_areas_lock);

    for (int i = 0; i < unsafe_region_areas->size; ++i) {
        struct unsafe_region_area* area = unsafe_region_areas->data[i];
        if (!area) {
            continue;
        }
        if (area->uid != current_uid().val) {
            continue;
        }
        u64 start = area->addr;
        u64 end = start + area->nums_page * PAGE_SIZE;
        if (pc >= start && pc < end) {
            // The PC is within a safe region
            wuwa_info("PC=0x%llx is in a unsafe region for pid %d\n", pc, current->pid);
            read_unlock(&unsafe_region_areas_lock);
            return false;
        }

        if (lr >= start && lr < end) {
            // The LR is within a safe region
            wuwa_info("LR=0x%llx is in a unsafe region for pid %d\n", lr, current->pid);
            read_unlock(&unsafe_region_areas_lock);
            return false;
        }
    }

    read_unlock(&unsafe_region_areas_lock);

    return true;
}

struct setup_rt_frame_data {
    int unsafe;
    int usig;
    struct ksignal* ksig;
    sigset_t* set;
    struct pt_regs* regs;
    struct pt_regs old_regs;
};

/*
 * Do a signal return; undo the signal stack. These are aligned to 128-bit.
 */
struct rt_sigframe {
    struct siginfo info;
    struct ucontext uc;
};

struct user_access_state {
    u64 por_el0;
};

// static int setup_rt_frame(int usig, struct ksignal *ksig, sigset_t *set, struct pt_regs *regs)
// kernel 6.1 static int setup_rt_frame(int usig, struct ksignal *ksig, sigset_t *set, struct pt_regs *regs)
static int setup_rt_frame_entry(struct kretprobe_instance* ri, struct pt_regs* regs) {
    int usig = (int)regs->regs[0];
    struct ksignal* ksig = (struct ksignal*)regs->regs[1];
    sigset_t* set = (sigset_t*)regs->regs[2];
    struct pt_regs* user_regs = (struct pt_regs*)regs->regs[3];

    struct setup_rt_frame_data* d = (struct setup_rt_frame_data*)ri->data;
    d->unsafe = 0;
    d->usig = usig;
    d->ksig = ksig;
    d->set = set;
    d->regs = user_regs;

    if (usig < 0 || usig >= _NSIG) {
        wuwa_err("Invalid signal number: %d\n", usig);
        return 0;
    }
    if (!ksig || !set) {
        wuwa_err("Invalid ksignal or sigset_t pointer\n");
        return 0;
    }

    if (usig == SIGPROF && !is_safe_prof_signal(ksig, user_regs)) {
        d->unsafe = 1;
        regs_set_return_value(regs, 1);
        regs->pc = regs->regs[30];
        return 1;
    }
    return 0;
}

struct rp_data_get_signal {
    struct ksignal* ksig_ptr; /* get_signal()'s first argument */
};

// bool get_signal(struct ksignal *ksig)
static int get_signal_entry_handler(struct kretprobe_instance* ri, struct pt_regs* regs) {
    struct rp_data_get_signal* data = (struct rp_data_get_signal*)ri->data;
    struct ksignal* ksig;

    ksig = (struct ksignal*)regs->regs[0];
    data->ksig_ptr = ksig;


    return 0;
}

static int get_signal_ret_handler(struct kretprobe_instance* ri, struct pt_regs* regs) {
    struct rp_data_get_signal* data;
    struct ksignal* ksig;
    unsigned long retval;

    if (!ri || !regs)
        return 0;

    data = (struct rp_data_get_signal*)ri->data;
    if (unlikely(!data || !data->ksig_ptr))
        return 0;

    ksig = data->ksig_ptr;
    retval = regs_return_value(regs);

    return 0;
}

static struct kretprobe krpget_signal = {
    .kp.symbol_name = "get_signal",
    .entry_handler = get_signal_entry_handler,
    .handler = get_signal_ret_handler,
    .data_size = sizeof(struct rp_data_get_signal),
    .maxactive = 20,
};

int wuwa_safe_signal_init(void) {
    int ret, maxactive;

    maxactive = num_possible_cpus() * 2;
    if (maxactive < 20) {
        maxactive = 20; // Ensure a minimum number of active probes
    }
    krpget_signal.maxactive = maxactive;

    ret = register_kretprobe(&krpget_signal);
    if (ret) {
        wuwa_err("register_kretprobe failed, returned %d\n", ret);
        goto out;
    }

    unsafe_region_areas = arraylist_create(ARRAYLIST_DEFAULT_CAPACITY);
    if (!unsafe_region_areas) {
        wuwa_err("failed to create unsafe region areas list\n");
        ret = -ENOMEM;
        goto out_krpget_signal;
    }

    return 0;

out_krpget_signal:
    unregister_kretprobe(&krpget_signal);
out:
    return ret;
}

void wuwa_safe_signal_cleanup(void) {
    unregister_kretprobe(&krpget_signal);

    write_lock(&unsafe_region_areas_lock);
    if (unsafe_region_areas) {
        if (!unsafe_region_areas->data) {
            write_unlock(&unsafe_region_areas_lock);
            wuwa_err("unsafe region areas list is empty\n");
            goto next;
        }

        for (int i = 0; i < unsafe_region_areas->size; ++i) {
            void* element = unsafe_region_areas->data[i];
            if (element)
                kvfree(element);
        }

    next:
        arraylist_destroy(unsafe_region_areas);
        unsafe_region_areas = NULL;
    }
    write_unlock(&unsafe_region_areas_lock);
}

int wuwa_add_unsafe_region(pid_t session, uid_t uid, uintptr_t start, size_t num_page) {
    write_lock(&unsafe_region_areas_lock);

    if (!unsafe_region_areas) {
        write_unlock(&unsafe_region_areas_lock);
        return -ENOMEM;
    }

    struct unsafe_region_area* area = kvzalloc(sizeof(*area), GFP_KERNEL);
    if (!area) {
        wuwa_err("failed to allocate memory for unsafe region area\n");
        write_unlock(&unsafe_region_areas_lock);
        return -ENOMEM;
    }
    area->addr = start;
    area->nums_page = num_page;
    area->uid = uid;
    area->session_pid = session;

    if (arraylist_add(unsafe_region_areas, area)) {
        write_unlock(&unsafe_region_areas_lock);
        wuwa_err("failed to add unsafe region area\n");
        return -ENOMEM;
    }

    wuwa_info("unsafe region area added for pid %d, start=0x%lx, num_page=%zu\n", session, start, num_page);
    write_unlock(&unsafe_region_areas_lock);
    return 0;
}

int wuwa_del_unsafe_region(pid_t pid) {
    write_lock(&unsafe_region_areas_lock);

    if (!unsafe_region_areas) {
        write_unlock(&unsafe_region_areas_lock);
        return -ENOMEM;
    }

    if (!unsafe_region_areas->data) {
        write_unlock(&unsafe_region_areas_lock);
        wuwa_err("unsafe region areas list is empty\n");
        return -ENOENT;
    }

    for (int i = 0; i < unsafe_region_areas->size; ++i) {
        struct unsafe_region_area* area = unsafe_region_areas->data[i];
        if (area && area->session_pid == pid) {
            void* removed = arraylist_remove(unsafe_region_areas, i);
            if (removed) {
                kvfree(removed);
            } else {
                wuwa_err("failed to remove unsafe region area for pid %d\n", pid);
            }
        }
    }

    write_unlock(&unsafe_region_areas_lock);
    return 0;
}

```

`src/hook/wuwa_safe_signal.h`:

```h
#ifndef WUWA_SAFE_SIGNAL_H
#define WUWA_SAFE_SIGNAL_H

#include "wuwa_common.h"

int wuwa_safe_signal_init(void);
void wuwa_safe_signal_cleanup(void);

int wuwa_add_unsafe_region(pid_t session, uid_t uid, uintptr_t start, size_t num_page);
int wuwa_del_unsafe_region(pid_t pid);

#endif // WUWA_SAFE_SIGNAL_H

```

`src/inlinehook/hijack_arm64.c`:

```c
#include "hijack_arm64.h"

#include "wuwa_common.h"
#include "wuwa_utils.h"

int (*aarch64_insn_write_ptr)(void *, u32) = NULL;
void (*flush_icache_range_ptr)(unsigned long, unsigned long) = NULL;

int init_arch(void) {
    aarch64_insn_write_ptr = (void *)kallsyms_lookup_name_ex("aarch64_insn_write");
    flush_icache_range_ptr = (void *)kallsyms_lookup_name_ex("caches_clean_inval_pou");
    if (!flush_icache_range_ptr) {
        flush_icache_range_ptr = (void *)kallsyms_lookup_name_ex("__flush_icache_range");
    }
    return !(aarch64_insn_write_ptr && flush_icache_range_ptr);
}

__nocfi int hook_write_range(void *target, void *source, int size)
{
    int ret = 0, i;

    for (i = 0; i < size; i = i + INSTRUCTION_SIZE) {
        ret = aarch64_insn_write_ptr(target + i, *(u32 *)(source + i));
        if (ret) {
            goto out;
        }
    }
    flush_icache_range_ptr((unsigned long)target, (unsigned long)target + size);

    out:
        return ret;
}

static bool check_instruction_can_hijack(uint32_t instruction)
{
	bool ret = true;

	//todo: we want to fix these instructions
	switch(instruction & 0x9f000000u) {
	case 0x10000000u:  //adr  
	case 0x90000000u:  //adrp
		ret = false;
		goto out;
	}
	switch(instruction & 0xfc000000u) {
	case 0x14000000u:  //b  
	case 0x94000000u:  //bl
		ret = false;
		goto out;
	}
	switch(instruction & 0xff000000u) {
	case 0x54000000u:  //b.c  
		ret = false;
		goto out;
	}    
	switch(instruction & 0x7e000000u) {
	case 0x34000000u:  //cbz cbnz
	case 0x36000000u:  //tbz tbnz
		ret = false;
		goto out;
	}
	switch(instruction & 0xbf000000u) {
	case 0x18000000u:  //ldr
		ret = false;
		goto out;
	}
	switch(instruction & 0x3f000000u) {
	case 0x1c000000u:  //ldrv
		ret = false;
		goto out;
	}
	switch(instruction & 0xff000000u) {
	case 0x98000000u:  //ldrsw
		ret = false;
		goto out;
	}

out:
	if (!ret) {
		wuwa_warn("instruction %x cannot be hijacked!\n", instruction);
	}
	return ret;
}

bool check_target_can_hijack(void *target)
{
	int offset = 0;
	for (; offset < HOOK_TARGET_OFFSET + HIJACK_SIZE; offset += INSTRUCTION_SIZE) {
		if (!check_instruction_can_hijack(*(uint32_t *)((char *)target + offset)))
			return false;
	}
	return true;
}
```

`src/inlinehook/hijack_arm64.h`:

```h
#ifndef ANDROID_WUWA_HIJACK_ARM64_H
#define ANDROID_WUWA_HIJACK_ARM64_H

#define INSTRUCTION_SIZE (4)
#define HIJACK_INST_NUM (6)
#define HIJACK_SIZE (INSTRUCTION_SIZE * HIJACK_INST_NUM)
#define HOOK_TARGET_OFFSET (0)

int init_arch(void);

__nocfi int hook_write_range(void *target, void *source, int size);

#endif // ANDROID_WUWA_HIJACK_ARM64_H

```

`src/ioctl/wuwa_ioctl.c`:

```c
#include "wuwa_ioctl.h"

#include <asm-generic/errno-base.h>

#include "wuwa_page_walk.h"
#include "wuwa_sock.h"
#include "wuwa_utils.h"
#include "wuwa_proc_dmabuf.h"

#include <asm/pgtable-prot.h>
#include <asm/pgtable-types.h>
#include <asm/pgtable.h>
#include <linux/kernel.h>
#include <linux/mm.h>
#include <linux/module.h>
#include <linux/slab.h>

#include "wuwa_proc.h"
#include "wuwa_safe_signal.h"

int do_vaddr_translate(struct socket* sock, void* arg) {
    struct wuwa_addr_translate_cmd cmd;
    int ret;

    if (copy_from_user(&cmd, arg, sizeof(cmd))) {
        return -EFAULT;
    }

    ret = translate_process_vaddr(cmd.pid, cmd.va, &cmd.phy_addr);
    if (ret < 0) {
        return ret;
    }

    if (copy_to_user(arg, &cmd, sizeof(cmd))) {
        return -EFAULT;
    }
    return 0;
}

int do_debug_info(struct socket* sock, void* arg) {
    struct wuwa_debug_info_cmd debug_info_cmd;

    debug_info_cmd.ttbr0_el1 = read_sysreg_s(SYS_TTBR0_EL1);
    debug_info_cmd.task_struct = (u64)current;
    debug_info_cmd.mm_struct = (u64)current->mm;
    debug_info_cmd.pgd_addr = (u64)current->mm->pgd;
    debug_info_cmd.pgd_phys_addr = virt_to_phys(current->mm->pgd);
    debug_info_cmd.mm_asid = ASID(current->mm);
    debug_info_cmd.mm_right = ((uint64_t)(ASID(current->mm)) << 48 | virt_to_phys(current->mm->pgd) | (uint64_t)1) ==
        debug_info_cmd.ttbr0_el1;

    if (copy_to_user(arg, &debug_info_cmd, sizeof(debug_info_cmd))) {
        return -EFAULT;
    }

    return 0;
}

int do_at_s1e0r(struct socket* sock, void* arg) {
    struct wuwa_at_s1e0r_cmd cmd;
    if (copy_from_user(&cmd, arg, sizeof(cmd))) {
        return -EFAULT;
    }

    struct pid* pid_struct = find_get_pid(cmd.pid);
    if (!pid_struct) {
        wuwa_warn("failed to find pid_struct: %d\n", cmd.pid);
        return -ESRCH;
    }

    struct task_struct* task = get_pid_task(pid_struct, PIDTYPE_PID);
    put_pid(pid_struct);
    if (!task) {
        wuwa_warn("failed to get task: %d\n", cmd.pid);
        return -ESRCH;
    }

    struct mm_struct* mm = get_task_mm(task);
    put_task_struct(task);
    if (!mm) {
        wuwa_warn("failed to get mm: %d\n", cmd.pid);
        put_task_struct(task);
        return -ESRCH;
    }

    u64 original_ttbr0 = read_sysreg_s(SYS_TTBR0_EL1);
    u64 new_ttbr0 = (uint64_t)(ASID(mm)) << 48 | virt_to_phys(mm->pgd) | (uint64_t)1;
    dsb(ish);
    asm volatile("msr ttbr0_el1, %0" ::"r"(new_ttbr0));
    dsb(ish);
    isb();

    asm volatile("at s1e0r, %0" ::"r"(cmd.va));
    isb();
    uintptr_t pa = read_sysreg_s(SYS_PAR_EL1);
    cmd.phy_addr = pa;
    mmput(mm);

    dsb(ish);
    asm volatile("msr ttbr0_el1, %0" ::"r"(original_ttbr0));
    dsb(ish);
    isb();

    if (cmd.phy_addr == 0) {
        return -EFAULT;
    }

    if (copy_to_user(arg, &cmd, sizeof(cmd))) {
        return -EFAULT;
    }
    return 0;
}

int do_get_page_info(struct socket* sock, void* arg) {
    struct wuwa_page_info_cmd cmd;
    if (copy_from_user(&cmd, arg, sizeof(cmd))) {
        return -EFAULT;
    }

    struct pid* pid_struct = find_get_pid(cmd.pid);
    if (!pid_struct) {
        wuwa_warn("failed to find pid_struct: %d\n", cmd.pid);
        return -ESRCH;
    }

    struct task_struct* task = get_pid_task(pid_struct, PIDTYPE_PID);
    put_pid(pid_struct);
    if (!task) {
        wuwa_warn("failed to get task: %d\n", cmd.pid);
        return -ESRCH;
    }

    struct mm_struct* mm = get_task_mm(task);
    put_task_struct(task);
    if (!mm) {
        wuwa_warn("failed to get mm: %d\n", cmd.pid);
        put_task_struct(task);
        return -ESRCH;
    }

    struct page* page_struct = vaddr_to_page(mm, cmd.va);
    if (!page_struct) {
        wuwa_warn("failed to get page for va: %lx\n", cmd.va);
        mmput(mm);
        return -EFAULT;
    }

    uintptr_t phy_addr = page_to_phys(page_struct);
    cmd.page.phy_addr = phy_addr;
    cmd.page.flags = page_struct->flags;
    cmd.page._mapcount = page_struct->_mapcount;
    cmd.page._refcount = page_struct->_refcount;

    if (copy_to_user(arg, &cmd, sizeof(cmd))) {
        return -EFAULT;
    }

    return 0;
}

int do_pte_mapping(struct socket* sock, void* arg) {
#if defined(BUILD_PTE_MAPPING)
    // 这里需要注意 android kenel 6.6.66找不到 pte_mkwrite
    struct wuwa_sock* ws = (struct wuwa_sock*)sock->sk;
    struct wuwa_pte_mapping_cmd cmd;
    if (copy_from_user(&cmd, arg, sizeof(cmd))) {
        return -EFAULT;
    }

    if (cmd.start_addr < 0 || cmd.start_addr >= TASK_SIZE_64) {
        wuwa_warn("invalid start address: 0x%lx\n", cmd.start_addr);
        return -EINVAL;
    }

    if (cmd.num_pages <= 0 || cmd.num_pages > (TASK_SIZE_64 - cmd.start_addr) / PAGE_SIZE) {
        wuwa_warn("invalid number of pages: %zu\n", cmd.num_pages);
        return -EINVAL;
    }

    pgd_t* pgd;
    p4d_t* p4d;
    pud_t* pud;
    pmd_t* pmd;
    pte_t* pte;
    struct page* page = NULL;
    int ret = 0;

    struct pid* pid_struct = find_get_pid(cmd.pid);
    if (!pid_struct) {
        wuwa_warn("failed to find pid_struct: %d\n", cmd.pid);
        return -ESRCH;
    }

    struct task_struct* task = get_pid_task(pid_struct, PIDTYPE_PID);
    put_pid(pid_struct);
    if (!task) {
        wuwa_warn("failed to get task: %d\n", cmd.pid);
        return -ESRCH;
    }

    struct mm_struct* mm = get_task_mm(task);
    put_task_struct(task);
    if (!mm) {
        wuwa_warn("failed to get mm: %d\n", cmd.pid);
        return -ESRCH;
    }

    static int (*my__pmd_alloc)(struct mm_struct* mm, pud_t* pud, unsigned long address) = NULL;
    my__pmd_alloc = (int (*)(struct mm_struct*, pud_t*, unsigned long))kallsyms_lookup_name_ex("__pmd_alloc");
    static int (*my__pte_alloc)(struct mm_struct* mm, pmd_t* pmd) = NULL;
    my__pte_alloc = (int (*)(struct mm_struct*, pmd_t*))kallsyms_lookup_name_ex("__pte_alloc");

    if (my__pmd_alloc == NULL || my__pte_alloc == NULL) {
        wuwa_err("failed to find __pmd_alloc or __pte_alloc symbols\n");
        ret = -ENOENT;
        goto out_mm;
    }

#define my_pte_alloc(mm, pmd) (unlikely(pmd_none(*(pmd))) && my__pte_alloc(mm, pmd))
#define my_pte_alloc_map(mm, pmd, address) (my_pte_alloc(mm, pmd) ? NULL : pte_offset_map(pmd, address))

    unsigned long addr = cmd.start_addr;
    size_t i;
    struct page** page_arr = kmalloc_array(cmd.num_pages, sizeof(struct page*), GFP_KERNEL);
    if (!page_arr) {
        wuwa_err("failed to allocate page array\n");
        ret = -ENOMEM;
        goto out_mm;
    }

    for (i = 0; i < cmd.num_pages; i++) {
        pgd = pgd_offset(mm, addr);
        if (pgd_none(*pgd) || pgd_bad(*pgd)) {
            ret = -EINVAL;
            wuwa_err("bad pgd for 0x%lx\n", addr);
            goto rollback;
        }

        p4d = p4d_alloc(mm, pgd, addr);
        if (!p4d) {
            ret = -ENOMEM;
            goto rollback;
        }

        pud = pud_alloc(mm, p4d, addr);
        if (!pud) {
            ret = -ENOMEM;
            goto rollback;
        }

        if (unlikely(pud_none(*pud))) {
            if (my__pmd_alloc(mm, pud, addr)) {
                wuwa_err("failed to allocate pmd\n");
                ret = -ENOMEM;
                goto rollback;
            }
        }

        pmd = pmd_offset(pud, addr);
        if (!pmd) {
            wuwa_err("failed to get pmd\n");
            ret = -ENOMEM;
            goto rollback;
        }

        pte = my_pte_alloc_map(mm, pmd, addr);
        if (!pte) {
            ret = -ENOMEM;
            wuwa_err("failed to allocate pte for address 0x%lx\n", addr);
            goto rollback;
        }
        if (!pte_none(*pte)) {
            ret = -EEXIST;
            wuwa_err("pte already exists for address 0x%lx\n", addr);
            pte_unmap(pte);
            goto rollback;
        }

        page = alloc_page(GFP_USER | __GFP_ZERO);
        if (!page) {
            ret = -ENOMEM;
            wuwa_err("failed to allocate page %zu\n", i);
            pte_unmap(pte);
            goto rollback;
        }
        page_arr[i] = page;

        pte_t new_pte = mk_pte(page, PAGE_SHARED_EXEC);
        new_pte = pte_mkwrite(pte_mkdirty(pte_mkyoung(new_pte)));
        set_pte(pte, new_pte);
        pte_unmap(pte);

        wuwa_info("mapped page %zu at address 0x%lx\n", i, addr);
        addr += PAGE_SIZE;
    }

    flush_tlb_all();

    mmput(mm);

    for (int i = 0; i < cmd.num_pages; ++i) {
        struct page* p = page_arr[i];

        if (!p) {
            wuwa_err("page %d is NULL\n", i);
            continue;
        }

        if (!ws->used_pages) {
            wuwa_err("used_pages array not initialized\n");
            break;
        }

        arraylist_add(ws->used_pages, p);
    }
    kfree(page_arr);

    if (cmd.hide) {
        wuwa_add_unsafe_region(ws->session, task->cred->uid.val, cmd.start_addr, cmd.num_pages);
    }

    wuwa_info("successfully mapped page at address 0x%lx for pid %d\n", cmd.start_addr, cmd.pid);
    return 0;

rollback:
    while (i--)
        __free_page(page_arr[i]);
out_mm:
    mmput(mm);
    return ret;
#else
    return -EINVAL;
#endif
}

int do_page_table_walk(struct socket* sock, void* arg) {
    struct wuwa_page_table_walk_cmd cmd;
    struct page_walk_stats stats;

    if (copy_from_user(&cmd, arg, sizeof(cmd))) {
        return -EFAULT;
    }

    struct task_struct* task = get_target_task(cmd.pid);
    if (!task) {
        return -ESRCH;
    }

    struct mm_struct* mm = get_task_mm(task);
    if (!mm) {
        put_task_struct(task);
        return -ESRCH;
    }

    // Traverse page tables and collect statistics
    traverse_page_tables(mm, &stats);

    // Copy statistics to command structure
    cmd.total_pte_count = stats.total_pte_count;
    cmd.present_pte_count = stats.present_pte_count;
    cmd.pmd_huge_count = stats.pmd_huge_count;
    cmd.pud_huge_count = stats.pud_huge_count;

    mmput(mm);
    put_task_struct(task);

    // Copy result back to userspace
    if (copy_to_user(arg, &cmd, sizeof(cmd))) {
        return -EFAULT;
    }

    wuwa_info("page table walk for pid %d: total_pte=%llu, present_pte=%llu, pmd_huge=%llu, pud_huge=%llu\n",
              cmd.pid, cmd.total_pte_count, cmd.present_pte_count, cmd.pmd_huge_count, cmd.pud_huge_count);

    return 0;
}

// static void (*wake_up_new_task)(struct task_struct *tsk) = NULL;
// if (!wake_up_new_task) {
//     wake_up_new_task = (void (*)(struct task_struct *))kallsyms_lookup_name_ex("wake_up_new_task");
// }
//
// wake_up_new_task(p);
// static __latent_entropy struct task_struct *(*copy_process)(
//             struct pid *pid,
//             int trace,
//             int node,
//             struct kernel_clone_args *args) = NULL;
// if (copy_process == NULL) {
//     copy_process = (typeof(copy_process))kallsyms_lookup_name_ex("copy_process");
// }
//
// if (!copy_process) {
//     ovo_warn("copy_process symbol not found\n");
//     return -ENOENT;
// }
// __latent_entropy struct task_struct *copy_process(
//                     struct pid *pid,
//                     int trace,
//                     int node,
//                     struct kernel_clone_args *args)
int do_copy_process(struct socket* sock, void* arg) {
    int ret = 0;
    struct wuwa_copy_process_cmd cmd;
    struct pid* pid;
    struct task_struct* task /*, *p*/;

    if (copy_from_user(&cmd, arg, sizeof(cmd))) {
        return -EFAULT;
    }

    if (!cmd.fn || !cmd.child_stack) {
        wuwa_err("invalid function pointer or child stack\n");
        return -EINVAL;
    }


    pid = find_get_pid(cmd.pid);
    if (!pid) {
        wuwa_warn("failed to find pid_struct: %d\n", cmd.pid);
        return -ESRCH;
    }

    task = get_pid_task(pid, PIDTYPE_PID);
    put_pid(pid);
    if (!task) {
        wuwa_warn("failed to get task: %d\n", cmd.pid);
        return -ESRCH;
    }

    ret = -1;
    // cproc源码无了，这里取消
    // ret = create_remote_thread(task, &p, cmd.child_tid, NULL, cmd.flags);
    put_task_struct(task);
    if (ret) {
        wuwa_err("failed to create remote thread: %d\n", ret);
        goto prepare_fault;
    }

    return 0;

prepare_fault:
    return ret;
}

#if !defined(ARCH_HAS_VALID_PHYS_ADDR_RANGE) || defined(MODULE)
static inline int memk_valid_phys_addr_range(uintptr_t addr, size_t size) { return addr + size <= __pa(high_memory); }
#define IS_VALID_PHYS_ADDR_RANGE(x, y) memk_valid_phys_addr_range(x, y)
#else
#define IS_VALID_PHYS_ADDR_RANGE(x, y) valid_phys_addr_range(x, y)
#endif

int do_read_physical_memory(struct socket* sock, void __user* arg) {
    struct wuwa_read_physical_memory_cmd cmd;
    uintptr_t pa;
    void* mapped;
    int ret;

    if (copy_from_user(&cmd, arg, sizeof(cmd))) {
        return -EFAULT;
    }

    ret = translate_process_vaddr(cmd.pid, cmd.src_va, (uintptr_t*)&cmd.phy_addr);
    if (ret < 0) {
        return ret;
    }

    if (copy_to_user(arg, &cmd, sizeof(cmd))) {
        return -EFAULT;
    }

    pa = cmd.phy_addr;
    if (!pa || !pfn_valid(__phys_to_pfn(pa)) || !IS_VALID_PHYS_ADDR_RANGE(pa, cmd.size)) {
        return -EFAULT;
    }

    mapped = phys_to_virt(pa);
    if (!mapped) {
        return -ENOMEM;
    }

    if (copy_to_user((void*)cmd.dst_va, mapped, cmd.size)) {
        return -EACCES;
    }

    return 0;
}

int do_get_module_base(struct socket* sock, void __user* arg) {
    struct wuwa_get_module_base_cmd cmd;
    if (copy_from_user(&cmd, arg, sizeof(cmd))) {
        return -EFAULT;
    }

    uintptr_t base = get_module_base(cmd.pid, cmd.name, cmd.vm_flag);
    if (base == 0) {
        return -ENAVAIL;
    }

    cmd.base = base;
    if (copy_to_user(arg, &cmd, sizeof(cmd))) {
        return -EFAULT;
    }

    return 0;
}

int do_find_process(struct socket* sock, void* arg) {
    struct wuwa_find_proc_cmd cmd;
    if (copy_from_user(&cmd, arg, sizeof(cmd))) {
        return -EFAULT;
    }

    cmd.pid = find_process_by_name(cmd.name);
    if (cmd.pid == 0) {
        return -ENAVAIL;
    }

    if (copy_to_user(arg, &cmd, sizeof(cmd))) {
        return -EFAULT;
    }

    return 0;
}

int do_write_physical_memory(struct socket* sock, void __user* arg) {
    struct wuwa_write_physical_memory_cmd cmd;
    uintptr_t pa;
    void* mapped;
    int ret;

    if (copy_from_user(&cmd, arg, sizeof(cmd))) {
        return -EFAULT;
    }

    ret = translate_process_vaddr(cmd.pid, cmd.dst_va, (uintptr_t*)&cmd.phy_addr);
    if (ret < 0) {
        return ret;
    }

    if (copy_to_user(arg, &cmd, sizeof(cmd))) {
        return -EFAULT;
    }

    pa = cmd.phy_addr;
    if (!pa || !pfn_valid(__phys_to_pfn(pa)) || !IS_VALID_PHYS_ADDR_RANGE(pa, cmd.size)) {
        return -EFAULT;
    }

    mapped = phys_to_virt(pa);
    if (!mapped) {
        return -ENOMEM;
    }

    if (copy_from_user(mapped, (void*)cmd.src_va, cmd.size)) {
        return -EACCES;
    }

    return 0;
}

int do_is_process_alive(struct socket* sock, void* arg) {
    struct wuwa_is_proc_alive_cmd cmd;
    if (copy_from_user(&cmd, arg, sizeof(cmd))) {
        return -EFAULT;
    }

    cmd.alive = is_pid_alive(cmd.pid);

    if (copy_to_user(arg, &cmd, sizeof(cmd))) {
        return -EFAULT;
    }

    return 0;
}

int do_hide_process(struct socket* sock, void* arg) {
    struct task_struct* task;
    struct wuwa_hide_proc_cmd cmd;
    if (copy_from_user(&cmd, arg, sizeof(cmd))) {
        return -EFAULT;
    }

    if ((task = find_task_by_vpid(cmd.pid)) == NULL)
        return -ESRCH;
    task->flags ^= PF_INVISIBLE;

    // todo: hook getdents64

    return -EINVAL;
}

int do_give_root(struct socket* sock, void* arg) {
    struct wuwa_give_root_cmd cmd;
    if (copy_from_user(&cmd, arg, sizeof(cmd))) {
        return -EFAULT;
    }

    cmd.result = give_root();

    if (copy_to_user(arg, &cmd, sizeof(cmd))) {
        return -EFAULT;
    }

    return 0;
}

int do_read_physical_memory_ioremap(struct socket* sock, void* arg) {
    struct wuwa_read_physical_memory_ioremap_cmd cmd;
    pgprot_t prot;
    uintptr_t pa;
    void* mapped;
    int ret;

    if (copy_from_user(&cmd, arg, sizeof(cmd))) {
        return -EFAULT;
    }

    // Validate size
    if (cmd.size == 0 || cmd.size > PAGE_SIZE) {
        return -EFAULT;
    }

    // Validate and convert memory type
    if (cmd.prot < WMT_NORMAL || cmd.prot > WMT_NORMAL_iNC_oWB) {
        return -EINVAL;
    }

    ret = convert_wmt_to_pgprot(cmd.prot, &prot);
    if (ret < 0) {
        return ret;
    }

    // Translate virtual address to physical
    ret = translate_process_vaddr(cmd.pid, cmd.src_va, &cmd.phy_addr);
    if (ret < 0) {
        return ret;
    }

    // Return physical address to userspace
    if (copy_to_user(arg, &cmd, sizeof(cmd))) {
        return -EFAULT;
    }

    // Map and read physical memory
    pa = cmd.phy_addr;
    if (!pa || !pfn_valid(__phys_to_pfn(pa))) {
        return -EFAULT;
    }

    mapped = wuwa_ioremap_prot(pa, cmd.size, prot);
    if (!mapped) {
        wuwa_err("failed to ioremap physical address 0x%lx\n", pa);
        return -ENOMEM;
    }

    ret = copy_to_user((void*)cmd.dst_va, mapped, cmd.size);
    iounmap(mapped);

    return ret ? -EACCES : 0;
}

int do_write_physical_memory_ioremap(struct socket* sock, void* arg) {
    struct wuwa_write_physical_memory_ioremap_cmd cmd;
    pgprot_t prot;
    uintptr_t pa;
    void* mapped;
    int ret;

    if (copy_from_user(&cmd, arg, sizeof(cmd))) {
        return -EFAULT;
    }

    // Validate size
    if (cmd.size == 0 || cmd.size > PAGE_SIZE) {
        return -EFAULT;
    }

    // Validate and convert memory type
    if (cmd.prot < WMT_NORMAL || cmd.prot > WMT_NORMAL_iNC_oWB) {
        return -EINVAL;
    }

    ret = convert_wmt_to_pgprot(cmd.prot, &prot);
    if (ret < 0) {
        return ret;
    }

    // Translate virtual address to physical
    ret = translate_process_vaddr(cmd.pid, cmd.src_va, &cmd.phy_addr);
    if (ret < 0) {
        return ret;
    }

    // Return physical address to userspace
    if (copy_to_user(arg, &cmd, sizeof(cmd))) {
        return -EFAULT;
    }

    // Map and read physical memory
    pa = cmd.phy_addr;
    if (!pa || !pfn_valid(__phys_to_pfn(pa))) {
        return -EFAULT;
    }

    mapped = wuwa_ioremap_prot(pa, cmd.size, prot);
    if (!mapped) {
        wuwa_err("failed to ioremap physical address 0x%lx\n", pa);
        return -ENOMEM;
    }

    ret = copy_from_user(mapped, (void*)cmd.dst_va, cmd.size);
    iounmap(mapped);

    return ret ? -EACCES : 0;
}

int do_list_processes(struct socket* sock, void __user* arg) {
    struct wuwa_list_processes_cmd cmd;
    struct task_struct* task;
    u8* kernel_bitmap;
    size_t process_count = 0;
    int ret = 0;

    // Copy command from userspace
    if (copy_from_user(&cmd, arg, sizeof(cmd))) {
        return -EFAULT;
    }

    // Validate bitmap size (must be at least 8192 bytes for PID 0-65535)
    if (cmd.bitmap_size < 8192) {
        wuwa_warn("bitmap size too small: %zu (minimum 8192)\n", cmd.bitmap_size);
        return -EINVAL;
    }

    // Allocate kernel bitmap buffer
    kernel_bitmap = kzalloc(cmd.bitmap_size, GFP_KERNEL);
    if (!kernel_bitmap) {
        wuwa_err("failed to allocate kernel bitmap\n");
        return -ENOMEM;
    }

    // Iterate through all processes and set corresponding bits
    rcu_read_lock();
    for_each_process(task) {
        pid_t pid = task->pid;
        
        // Check if PID is within bitmap range
        if (pid >= 0 && pid < (cmd.bitmap_size * 8)) {
            size_t byte_index = pid / 8;
            size_t bit_index = pid % 8;
            
            // Set the bit
            kernel_bitmap[byte_index] |= (1 << bit_index);
            process_count++;
        }
    }
    rcu_read_unlock();

    // Copy bitmap to userspace
    if (copy_to_user(cmd.bitmap, kernel_bitmap, cmd.bitmap_size)) {
        ret = -EFAULT;
        goto out_free;
    }

    // Update process count and copy back to userspace
    cmd.process_count = process_count;
    if (copy_to_user(arg, &cmd, sizeof(cmd))) {
        ret = -EFAULT;
        goto out_free;
    }

    wuwa_info("listed %zu processes in bitmap\n", process_count);

out_free:
    kfree(kernel_bitmap);
    return ret;
}

int do_get_process_info(struct socket* sock, void __user* arg) {
    struct wuwa_get_proc_info_cmd cmd;
    struct pid* pid_struct;
    struct task_struct* task;
    char cmdline[256];
    int ret = 0;

    // Copy command from userspace
    if (copy_from_user(&cmd, arg, sizeof(cmd))) {
        return -EFAULT;
    }

    // Find process by PID
    pid_struct = find_get_pid(cmd.pid);
    if (!pid_struct) {
        wuwa_warn("failed to find pid_struct: %d\n", cmd.pid);
        return -ESRCH;
    }

    task = get_pid_task(pid_struct, PIDTYPE_PID);
    put_pid(pid_struct);
    if (!task) {
        wuwa_warn("failed to get task: %d\n", cmd.pid);
        return -ESRCH;
    }

    // Extract basic process information
    cmd.tgid = task->tgid;
    cmd.uid = task->cred->uid.val;
    cmd.ppid = task->real_parent ? task->real_parent->pid : 0;
    cmd.prio = task->prio;

    // Try to get full command line
    cmdline[0] = '\0';

#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0)
    static int (*my_get_cmdline)(struct task_struct* task, char* buffer, int buflen) = NULL;
    if (my_get_cmdline == NULL) {
        my_get_cmdline = (void*)kallsyms_lookup_name_ex("get_cmdline");
    }

    if (my_get_cmdline != NULL && task->mm != NULL) {
        ret = my_get_cmdline(task, cmdline, sizeof(cmdline));
    } else {
        ret = -1;
    }
#else
    // Use fallback for older kernels
    if (task->mm != NULL) {
        struct mm_struct* mm = get_task_mm(task);
        if (mm) {
            unsigned long arg_start, arg_end;
            unsigned int len;

            spin_lock(&mm->arg_lock);
            arg_start = mm->arg_start;
            arg_end = mm->arg_end;
            spin_unlock(&mm->arg_lock);

            len = arg_end - arg_start;
            if (len > sizeof(cmdline) - 1)
                len = sizeof(cmdline) - 1;

            ret = access_process_vm(task, arg_start, cmdline, len, FOLL_FORCE);
            mmput(mm);
        } else {
            ret = -1;
        }
    } else {
        ret = -1;
    }
#endif

    // Fallback to task->comm if cmdline retrieval failed
    if (ret < 0 || cmdline[0] == '\0') {
        strncpy(cmd.name, task->comm, sizeof(cmd.name) - 1);
    } else {
        // Extract program name (first part before space)
        char* space = strchr(cmdline, ' ');
        if (space) *space = '\0';

        // Extract filename from path
        char* slash = strrchr(cmdline, '/');
        char* prog_name = slash ? (slash + 1) : cmdline;

        strncpy(cmd.name, prog_name, sizeof(cmd.name) - 1);
    }
    cmd.name[sizeof(cmd.name) - 1] = '\0';

    put_task_struct(task);

    // Copy result back to userspace
    if (copy_to_user(arg, &cmd, sizeof(cmd))) {
        return -EFAULT;
    }

    wuwa_info("retrieved info for process %d: tgid=%d, name=%s, uid=%d, ppid=%d, prio=%d\n",
              cmd.pid, cmd.tgid, cmd.name, cmd.uid, cmd.ppid, cmd.prio);

    return 0;
}
```

`src/ioctl/wuwa_ioctl.h`:

```h
#ifndef WUWA_IOCTL_H
#define WUWA_IOCTL_H

#include "wuwa_common.h"
#include "wuwa_bindproc.h"

struct wuwa_addr_translate_cmd {
    uintptr_t phy_addr; /* Output: Physical address after translation */
    pid_t pid; /* Input: Process ID owning the virtual address */
    uintptr_t va; /* Input: Virtual address to translate */
};

struct wuwa_debug_info_cmd {
    u64 ttbr0_el1; /* Translation Table Base Register 0 */
    u64 task_struct;
    u64 mm_struct; /* Memory Management Structure */
    u64 pgd_addr; /* Page Global Directory address */
    u64 pgd_phys_addr;
    u64 mm_asid; /* Address Space ID */
    u32 mm_right;
};

struct wuwa_at_s1e0r_cmd {
    uintptr_t phy_addr;
    pid_t pid;
    uintptr_t va;
};

struct kernel_page {
    unsigned long flags; /* Atomic flags, some possibly */
    union { /* This union is 4 bytes in size. */
        /*
         * If the page can be mapped to userspace, encodes the number
         * of times this page is referenced by a page table.
         */
        atomic_t _mapcount;

        /*
         * If the page is neither PageSlab nor mappable to userspace,
         * the value stored here may help determine what this page
         * is used for.  See page-flags.h for a list of page types
         * which are currently stored here.
         */
        unsigned int page_type;
    };

    /* Usage count. *DO NOT USE DIRECTLY*. See page_ref.h */
    atomic_t _refcount;

    uintptr_t phy_addr;
};

struct wuwa_page_info_cmd {
    pid_t pid;
    uintptr_t va;

    struct kernel_page page; /* Output: Page information */
};

#ifndef WUWA_DISABLE_DMABUF
struct wuwa_dma_buf_create_cmd {
    pid_t pid;
    uintptr_t va;
    size_t size;
    int fd;
};
#endif

struct wuwa_pte_mapping_cmd {
    pid_t pid;
    uintptr_t start_addr;
    size_t num_pages;
    int hide; /* Hide the page if true */
};

struct wuwa_page_table_walk_cmd {
    pid_t pid; /* Input: Process ID */
    u64 total_pte_count; /* Output: Total number of PTEs (Page Table Entries) */
    u64 present_pte_count; /* Output: Number of present (mapped) PTEs */
    u64 pmd_huge_count; /* Output: Number of PMD huge pages (2MB pages) */
    u64 pud_huge_count; /* Output: Number of PUD huge pages (1GB pages) */
};

struct wuwa_copy_process_cmd {
    pid_t pid;
    int (*__user fn)(void*);
    void* __user child_stack;
    size_t child_stack_size;
    u64 flags;
    void* __user arg;

    int __user* child_tid;
};

struct wuwa_read_physical_memory_cmd {
    pid_t pid; /* Input: Process ID owning the virtual address */
    uintptr_t src_va; /* Input: Virtual address to access */
    uintptr_t dst_va; /* Input: Virtual address to write */
    size_t size; /* Input: Size of memory to read */
    uintptr_t phy_addr; /* Output: Physical address of the source virtual address */
};

struct wuwa_write_physical_memory_cmd {
    pid_t pid; /* Input: Process ID owning the virtual address */
    uintptr_t src_va; /* Input: Virtual address to access */
    uintptr_t dst_va; /* Input: Virtual address to write */
    size_t size; /* Input: Size of memory to read */
    uintptr_t phy_addr; /* Output: Physical address of the source virtual address */
};

struct wuwa_get_module_base_cmd {
    pid_t pid; /* Input: Process ID */
    char name[256]; /* Input: Module name */
    uintptr_t base; /* Output: Base address of the module */
    int vm_flag; /* Input: VM flag to filter (e.g., VM_EXEC) */
};

struct wuwa_find_proc_cmd {
    pid_t pid; /* Output: Process ID */
    char name[256]; /* Input: Process name */
};

struct wuwa_is_proc_alive_cmd {
    pid_t pid; /* Output: Process ID */
    int alive; /* Output: 1 if alive, 0 if not */
};

struct wuwa_hide_proc_cmd {
    pid_t pid; /* Input: Process ID */
    int hide; /* Input: 1 to hide, 0 to unhide */
};

struct wuwa_give_root_cmd {
    int result; /* Output: 0 on success, negative error code on failure */
};

struct wuwa_read_physical_memory_ioremap_cmd {
    pid_t pid; /* Input: Process ID owning the virtual address */
    uintptr_t src_va; /* Input: Virtual address to access */
    uintptr_t dst_va; /* Input: Virtual address to write */
    size_t size; /* Input: Size of memory to read */
    uintptr_t phy_addr; /* Output: Physical address of the source virtual address */
    int prot; /* Input: Memory protection type (use MT_*) */
};

struct wuwa_write_physical_memory_ioremap_cmd {
    pid_t pid; /* Input: Process ID owning the virtual address */
    uintptr_t src_va; /* Input: Virtual address to access */
    uintptr_t dst_va; /* Input: Virtual address to write */
    size_t size; /* Input: Size of memory to read */
    uintptr_t phy_addr; /* Output: Physical address of the source virtual address */
    int prot; /* Input: Memory protection type (use MT_*) */
};

struct wuwa_bind_proc_cmd {
    pid_t pid; /* Input: Process ID owning the virtual address */
    int fd; /* Output: Anno File Descriptor */
};

struct wuwa_list_processes_cmd {
    u8* __user bitmap; /* Input: User-space bitmap buffer (at least 8192 bytes for PID 0-65535) */
    size_t bitmap_size; /* Input: Size of bitmap in bytes (must be at least 8192) */
    size_t process_count; /* Output: Total number of processes (number of set bits) */
};

struct wuwa_get_proc_info_cmd {
    pid_t pid; /* Input: Process ID to query */
    pid_t tgid; /* Output: Thread group ID (process group leader) */
    char name[256]; /* Output: Process name (comm) */
    uid_t uid; /* Output: User ID */
    pid_t ppid; /* Output: Parent process ID */
    int prio; /* Output: Process priority */
};

/* IOCTL command for virtual to physical address translation */
#define WUWA_IOCTL_ADDR_TRANSLATE _IOWR('W', 1, struct wuwa_addr_translate_cmd)
/* IOCTL command for debugging information */
#define WUWA_IOCTL_DEBUG_INFO _IOR('W', 2, struct wuwa_debug_info_cmd)
/* * IOCTL command for va to phys translation */
#define WUWA_IOCTL_AT_S1E0R _IOWR('W', 3, struct wuwa_at_s1e0r_cmd)
/* IOCTL command for getting page information at a specific virtual address */
#define WUWA_IOCTL_PAGE_INFO _IOWR('W', 4, struct wuwa_page_info_cmd)
#ifndef WUWA_DISABLE_DMABUF
/* IOCTL command for creating a DMA buffer at a specific virtual address */
#define WUWA_IOCTL_DMA_BUF_CREATE _IOWR('W', 5, struct wuwa_dma_buf_create_cmd)
#endif
/* IOCTL command for getting PTE mapping information */
#define WUWA_IOCTL_PTE_MAPPING _IOWR('W', 6, struct wuwa_pte_mapping_cmd)
/* IOCTL command for page table walk */
#define WUWA_IOCTL_PAGE_TABLE_WALK _IOWR('W', 7, struct wuwa_page_table_walk_cmd)
/* IOCTL command for copying a process */
#define WUWA_IOCTL_COPY_PROCESS _IOWR('W', 8, struct wuwa_copy_process_cmd)
/* IOCTL command for reading physical memory */
#define WUWA_IOCTL_READ_MEMORY _IOWR('W', 9, struct wuwa_read_physical_memory_cmd)
/* IOCTL command for getting module base address */
#define WUWA_IOCTL_GET_MODULE_BASE _IOWR('W', 10, struct wuwa_get_module_base_cmd)
/* IOCTL command for finding a process by name */
#define WUWA_IOCTL_FIND_PROCESS _IOWR('W', 11, struct wuwa_find_proc_cmd)
/* IOCTL command for writing physical memory */
#define WUWA_IOCTL_WRITE_MEMORY _IOWR('W', 12, struct wuwa_write_physical_memory_cmd)
/* IOCTL command for checking if a process is alive */
#define WUWA_IOCTL_IS_PROCESS_ALIVE _IOWR('W', 13, struct wuwa_is_proc_alive_cmd)
/* IOCTL command for hiding/unhiding a process */
#define WUWA_IOCTL_HIDE_PROCESS _IOWR('W', 14, struct wuwa_hide_proc_cmd)
/* IOCTL command for giving root privileges to the current process */
#define WUWA_IOCTL_GIVE_ROOT _IOWR('W', 15, struct wuwa_give_root_cmd)
/* IOCTL command for reading physical memory using ioremap */
#define WUWA_IOCTL_READ_MEMORY_IOREMAP _IOWR('W', 16, struct wuwa_read_physical_memory_ioremap_cmd)
/* IOCTL command for writing physical memory using ioremap */
#define WUWA_IOCTL_WRITE_MEMORY_IOREMAP _IOWR('W', 17, struct wuwa_write_physical_memory_ioremap_cmd)
/* IOCTL command for binding a process to an Anno file descriptor */
#define WUWA_IOCTL_BIND_PROC _IOWR('W', 18, struct wuwa_bind_proc_cmd)
/* IOCTL command for listing all processes as a bitmap */
#define WUWA_IOCTL_LIST_PROCESSES _IOWR('W', 19, struct wuwa_list_processes_cmd)
/* IOCTL command for getting process information by PID */
#define WUWA_IOCTL_GET_PROC_INFO _IOWR('W', 20, struct wuwa_get_proc_info_cmd)

int do_vaddr_translate(struct socket* sock, void __user* arg);
int do_debug_info(struct socket* sock, void __user* arg);
int do_at_s1e0r(struct socket* sock, void __user* arg);
int do_get_page_info(struct socket* sock, void __user* arg);
#ifndef WUWA_DISABLE_DMABUF
int do_create_proc_dma_buf(struct socket* sock, void __user* arg);
#endif
int do_pte_mapping(struct socket* sock, void __user* arg);
int do_page_table_walk(struct socket* sock, void __user* arg);
int do_copy_process(struct socket* sock, void __user* arg);
int do_read_physical_memory(struct socket* sock, void __user* arg);
int do_get_module_base(struct socket* sock, void __user* arg);
int do_find_process(struct socket* sock, void __user* arg);
int do_write_physical_memory(struct socket* sock, void __user* arg);
int do_is_process_alive(struct socket* sock, void __user* arg);
int do_hide_process(struct socket* sock, void __user* arg);
int do_give_root(struct socket* sock, void __user* arg);
int do_read_physical_memory_ioremap(struct socket* sock, void __user* arg);
int do_write_physical_memory_ioremap(struct socket* sock, void __user* arg);
int do_list_processes(struct socket* sock, void __user* arg);
int do_get_process_info(struct socket* sock, void __user* arg);

typedef int (*ioctl_handler_t)(struct socket* sock, void __user* arg);

static const struct ioctl_cmd_map {
    unsigned int cmd;
    ioctl_handler_t handler;
} ioctl_handlers[] = {
    {.cmd = WUWA_IOCTL_ADDR_TRANSLATE, .handler = do_vaddr_translate},
    {.cmd = WUWA_IOCTL_DEBUG_INFO, .handler = do_debug_info},
    {.cmd = WUWA_IOCTL_AT_S1E0R, .handler = do_at_s1e0r}, /* Reusing the same handler for AT VA */
    {.cmd = WUWA_IOCTL_PAGE_INFO, .handler = do_get_page_info},
#ifndef WUWA_DISABLE_DMABUF
    {.cmd = WUWA_IOCTL_DMA_BUF_CREATE, .handler = do_create_proc_dma_buf},
#endif
    {.cmd = WUWA_IOCTL_PTE_MAPPING, .handler = do_pte_mapping},
    {.cmd = WUWA_IOCTL_PAGE_TABLE_WALK, .handler = do_page_table_walk},
    {.cmd = WUWA_IOCTL_COPY_PROCESS, .handler = do_copy_process},
    {.cmd = WUWA_IOCTL_READ_MEMORY, .handler = do_read_physical_memory},
    {.cmd = WUWA_IOCTL_GET_MODULE_BASE, .handler = do_get_module_base},
    {.cmd = WUWA_IOCTL_FIND_PROCESS, .handler = do_find_process},
    {.cmd = WUWA_IOCTL_WRITE_MEMORY, .handler = do_write_physical_memory},
    {.cmd = WUWA_IOCTL_IS_PROCESS_ALIVE, .handler = do_is_process_alive},
    {.cmd = WUWA_IOCTL_HIDE_PROCESS, .handler = do_hide_process},
    {.cmd = WUWA_IOCTL_GIVE_ROOT, .handler = do_give_root},
    {.cmd = WUWA_IOCTL_READ_MEMORY_IOREMAP, .handler = do_read_physical_memory_ioremap},
    {.cmd = WUWA_IOCTL_WRITE_MEMORY_IOREMAP, .handler = do_write_physical_memory_ioremap},
    {.cmd = WUWA_IOCTL_BIND_PROC, .handler = do_bind_proc},
    {.cmd = WUWA_IOCTL_LIST_PROCESSES, .handler = do_list_processes},
    {.cmd = WUWA_IOCTL_GET_PROC_INFO, .handler = do_get_process_info},
    {.cmd = 0, .handler = NULL} /* Sentinel to mark end of array */
};

#endif // WUWA_IOCTL_H

```

`src/mm/wuwa_bindproc.c`:

```c
#include "wuwa_bindproc.h"
#include <linux/kernel.h>
#include <linux/mm.h>
#include <linux/module.h>
#include <linux/mutex.h>
#include <linux/scatterlist.h>
#include <linux/slab.h>
#include <linux/version.h>
#include "asm-generic/errno-base.h"
#include "karray_list.h"
#include "linux/anon_inodes.h"
#include "linux/compiler_types.h"
#include "linux/sched/task.h"
#include "linux/types.h"
#include "wuwa_common.h"
#include "wuwa_ioctl.h"
#include "wuwa_page_walk.h"
#include "wuwa_utils.h"

struct wuwa_mapped_page_info {
    uintptr_t phys_addr; /* Physical page address (page-aligned) */
    void* mapped_ptr; /* Kernel virtual address from ioremap */
};

struct wuwa_bindproc_private {
    pid_t pid;
    pgprot_t prot; /* Memory protection type (use WMT_*) */
    struct karray_list* mapped_pages; /* of struct wuwa_mapped_page_info * */
    struct mutex lock; /* Protects mapped_pages access */
};

/* Helper: Find cached mapping for physical page */
static void* find_cached_mapping(struct wuwa_bindproc_private* priv, uintptr_t phys_page) {
    size_t i;
    for (i = 0; i < priv->mapped_pages->size; i++) {
        struct wuwa_mapped_page_info* info = arraylist_get(priv->mapped_pages, i);
        if (info && info->phys_addr == phys_page) {
            return info->mapped_ptr;
        }
    }
    return NULL;
}

/* Helper: Add new mapping to cache */
static int add_cached_mapping(struct wuwa_bindproc_private* priv, uintptr_t phys_page, void* mapped) {
    struct wuwa_mapped_page_info* info = kmalloc(sizeof(*info), GFP_KERNEL);
    if (!info) {
        return -ENOMEM;
    }
    info->phys_addr = phys_page;
    info->mapped_ptr = mapped;

    if (arraylist_add(priv->mapped_pages, info) < 0) {
        kfree(info);
        return -ENOMEM;
    }
    return 0;
}

static ssize_t bindproc_read(struct file* f, char __user* dest_va, size_t size, loff_t* src_va) { return -EINVAL; }

static ssize_t bindproc_write(struct file* f, const char __user* data, size_t size, loff_t* offset) { return -EINVAL; }

struct bp_read_memory_cmd {
    uintptr_t src_va; /* Input: Virtual address to read from */
    uintptr_t dst_va; /* Input: Virtual address to write to */
    size_t size; /* Input: Size of memory to read */
};

struct bp_write_memory_cmd {
    uintptr_t src_va; /* Input: Virtual address to read from */
    uintptr_t dst_va; /* Input: Virtual address to write to */
    size_t size; /* Input: Size of memory to write */
};

#define WUWA_BP_IOCTL_SET_MEMORY_PROT _IOWR('B', 1, int) /* arg: int (WMT_*) */
#define WUWA_BP_IOCTL_READ_MEMORY _IOWR('B', 2, struct bp_read_memory_cmd)
#define WUWA_BP_IOCTL_WRITE_MEMORY _IOWR('B', 3, struct bp_write_memory_cmd)

static long bindproc_ioctl(struct file* f, unsigned int cmd, unsigned long arg) {
    struct wuwa_bindproc_private* private_data = f->private_data;
    int ret = 0;
    if (!private_data) {
        return -EINVAL;
    }

    switch (cmd) {
    case WUWA_BP_IOCTL_SET_MEMORY_PROT:
        {
            int prot;
            pgprot_t new_prot;

            if (copy_from_user(&prot, (int __user*)arg, sizeof(prot))) {
                return -EFAULT;
            }

            if (prot < WMT_NORMAL || prot > WMT_DEVICE_nGnRnE) {
                return -EINVAL;
            }

            if (convert_wmt_to_pgprot(prot, &new_prot) < 0) {
                return -EINVAL;
            }

            if(pgprot_val(new_prot) != pgprot_val(private_data->prot)) {
                /* Clear existing mappings if protection changes */
                size_t i;

                mutex_lock(&private_data->lock);

                for (i = 0; i < private_data->mapped_pages->size; i++) {
                    struct wuwa_mapped_page_info* info = arraylist_get(private_data->mapped_pages, i);
                    if (info) {
                        if (info->mapped_ptr) {
                            iounmap(info->mapped_ptr);
                        }
                        kfree(info);
                    }
                }
                arraylist_clear(private_data->mapped_pages);

                mutex_unlock(&private_data->lock);
            }

            wuwa_info("set memory prot to %d for pid %d\n", prot, private_data->pid);
            return ret;
        }
    case WUWA_BP_IOCTL_READ_MEMORY:
        {
            struct bp_read_memory_cmd cmd;
            if (copy_from_user(&cmd, (struct bp_read_memory_cmd __user*)arg, sizeof(cmd))) {
                return -EFAULT;
            }
            if (cmd.size == 0 || cmd.size > 0x10000) {
                return -EINVAL;
            }
            if (!cmd.src_va || !cmd.dst_va) {
                return -EINVAL;
            }

            uintptr_t va, pa;
            uintptr_t offset, page_start;
            void* mapped;
            size_t bytes_to_read, total_read = 0;

            // Validate size: allow reads up to reasonable limit
            if (cmd.size == 0 || cmd.size > (PAGE_SIZE * 16)) {
                wuwa_err("invalid read size: %zu\n", cmd.size);
                return -EINVAL;
            }

            va = cmd.src_va;
            //wuwa_info("bindproc_read: pid=%d, va=0x%lx, size=%zu\n", private_data->pid, va, cmd.size);

            while (total_read < cmd.size) {
                /* Translate current virtual address to physical */
                ret = translate_process_vaddr(private_data->pid, va + total_read, &pa);
                if (ret < 0) {
                    wuwa_err("failed to translate VA 0x%lx: %d\n", va + total_read, ret);
                    goto out;
                }

                /* Calculate page-aligned address and offset */
                offset = pa & ~PAGE_MASK;
                page_start = pa & PAGE_MASK;

                /* Determine how many bytes we can read from this page */
                bytes_to_read = min_t(size_t, cmd.size - total_read, PAGE_SIZE - offset);

                //wuwa_info("Reading %zu bytes from VA 0x%lx (PA 0x%lx)\n", bytes_to_read, va + total_read, pa);
                //wuwa_info("  Page start: 0x%lx, Offset: 0x%lx\n", page_start, offset);

                /* Check cache for existing mapping */
                mapped = find_cached_mapping(private_data, page_start);
                if (!mapped) {
                    /* Not cached, create new mapping */
                    mapped = wuwa_ioremap_prot(page_start, PAGE_SIZE, private_data->prot);
                    if (!mapped) {
                        wuwa_err("failed to ioremap physical address 0x%lx\n", page_start);
                        ret = -ENOMEM;
                        goto out;
                    }

                    /* Add to cache */
                    ret = add_cached_mapping(private_data, page_start, mapped);
                    if (ret < 0) {
                        wuwa_err("failed to cache mapping for PA 0x%lx\n", page_start);
                        iounmap(mapped);
                        goto out;
                    }
                }

                /* Copy data to userspace */
                ret = copy_to_user(cmd.dst_va + total_read, mapped + offset, bytes_to_read);
                if (ret != 0) {
                    wuwa_err("copy_to_user failed: %d bytes not copied\n", ret);
                    ret = -EFAULT;
                    goto out;
                }

                total_read += bytes_to_read;
            }

            ret = total_read;

        out:
            return ret;
        }
    case WUWA_BP_IOCTL_WRITE_MEMORY:
        {
            struct bp_write_memory_cmd cmd;
            if (copy_from_user(&cmd, (struct bp_write_memory_cmd __user*)arg, sizeof(cmd))) {
                return -EFAULT;
            }
            if (cmd.size == 0 || cmd.size > 0x10000) {
                return -EINVAL;
            }
            if (!cmd.src_va || !cmd.dst_va) {
                return -EINVAL;
            }

            uintptr_t va, pa;
            uintptr_t offset, page_start;
            void* mapped;
            size_t bytes_to_write, total_written = 0;

            // Validate size: allow writes up to reasonable limit
            if (cmd.size == 0 || cmd.size > (PAGE_SIZE * 16)) {
                wuwa_err("invalid write size: %zu\n", cmd.size);
                return -EINVAL;
            }

            va = cmd.dst_va;

            while (total_written < cmd.size) {
                /* Translate current virtual address to physical */
                ret = translate_process_vaddr(private_data->pid, va + total_written, &pa);
                if (ret < 0) {
                    wuwa_err("failed to translate VA 0x%lx: %d\n", va + total_written, ret);
                    goto out_write;
                }

                /* Calculate page-aligned address and offset */
                offset = pa & ~PAGE_MASK;
                page_start = pa & PAGE_MASK;

                /* Determine how many bytes we can write to this page */
                bytes_to_write = min_t(size_t, cmd.size - total_written, PAGE_SIZE - offset);

                /* Check cache for existing mapping */
                mapped = find_cached_mapping(private_data, page_start);
                if (!mapped) {
                    /* Not cached, create new mapping */
                    mapped = wuwa_ioremap_prot(page_start, PAGE_SIZE, private_data->prot);
                    if (!mapped) {
                        wuwa_err("failed to ioremap physical address 0x%lx\n", page_start);
                        ret = -ENOMEM;
                        goto out_write;
                    }

                    /* Add to cache */
                    ret = add_cached_mapping(private_data, page_start, mapped);
                    if (ret < 0) {
                        wuwa_err("failed to cache mapping for PA 0x%lx\n", page_start);
                        iounmap(mapped);
                        goto out_write;
                    }
                }

                /* Copy data from userspace to target process memory */
                ret = copy_from_user(mapped + offset, (void __user*)(cmd.src_va + total_written), bytes_to_write);
                if (ret != 0) {
                    wuwa_err("copy_from_user failed: %d bytes not copied\n", ret);
                    ret = -EFAULT;
                    goto out_write;
                }

                total_written += bytes_to_write;
            }

            ret = total_written;

        out_write:
            return ret;
        }
    default:
        wuwa_err("unknown ioctl cmd: 0x%x\n", cmd);
        return -ENOTTY;
    }

    return -EINVAL;
}

static int bindproc_mmap(struct file* f, struct vm_area_struct* vma) { return -EINVAL; }

static int bindproc_release(struct inode* inode, struct file* f) {
    struct wuwa_bindproc_private* private_data = f->private_data;
    if (private_data) {
        size_t i;

        mutex_lock(&private_data->lock);

        /* Unmap all cached pages */
        for (i = 0; i < private_data->mapped_pages->size; i++) {
            struct wuwa_mapped_page_info* info = arraylist_get(private_data->mapped_pages, i);
            if (info) {
                if (info->mapped_ptr) {
                    iounmap(info->mapped_ptr);
                }
                kfree(info);
            }
        }

        arraylist_destroy(private_data->mapped_pages);

        mutex_unlock(&private_data->lock);
        mutex_destroy(&private_data->lock);

        kfree(private_data);
        f->private_data = NULL;
    }
    return 0;
}

loff_t bindproc_llseek(struct file* file, loff_t offset, int whence) {
    switch (whence) {
    case SEEK_SET:
        if (offset < 0)
            return -EINVAL;
        file->f_pos = offset;
        break;
    case SEEK_CUR:
        if (file->f_pos + offset < 0)
            return -EINVAL;
        file->f_pos += offset;
        break;
    case SEEK_END:
        return -EINVAL; /* Not supported */
    default:
        return -EINVAL;
    }
    return file->f_pos;
}

static const struct file_operations bindproc_fops = {
    .owner = THIS_MODULE,
    .release = bindproc_release,
    .read = bindproc_read,
    .write = bindproc_write,
    .unlocked_ioctl = bindproc_ioctl,
    .mmap = bindproc_mmap,
    .llseek = bindproc_llseek,
};


int do_bind_proc(struct socket* sock, void __user* arg) {
    struct wuwa_bind_proc_cmd cmd;
    struct wuwa_bindproc_private* private_data = NULL;
    struct file* filp = NULL;
    int fd = -1;
    int ret = 0;

    /* Copy command from userspace */
    if (copy_from_user(&cmd, arg, sizeof(cmd))) {
        return -EFAULT;
    }

    /* Validate PID */
    if (cmd.pid <= 0) {
        wuwa_err("invalid pid: %d\n", cmd.pid);
        return -EINVAL;
    }

    /* Verify target process exists */
    struct task_struct* task = get_target_task(cmd.pid);
    if (!task) {
        wuwa_err("failed to find task for pid: %d\n", cmd.pid);
        return -ESRCH;
    }
    put_task_struct(task);

    /* Allocate private data structure */
    private_data = kmalloc(sizeof(*private_data), GFP_KERNEL);
    if (!private_data) {
        wuwa_err("failed to allocate memory for private_data\n");
        return -ENOMEM;
    }

    private_data->pid = cmd.pid;
    mutex_init(&private_data->lock);
    private_data->prot = __pgprot(PROT_NORMAL); /* Default to normal memory */

    private_data->mapped_pages = arraylist_create(16);
    if (!private_data->mapped_pages) {
        wuwa_err("failed to create mapped_pages arraylist\n");
        ret = -ENOMEM;
        goto err_free_private;
    }

    /* Allocate file descriptor */
    fd = get_unused_fd_flags(O_RDWR | O_CLOEXEC);
    if (fd < 0) {
        wuwa_err("failed to get unused fd: %d\n", fd);
        ret = fd;
        goto err_free_private;
    }

    /* Create anonymous inode file */
    filp = anon_inode_getfile("[wuwa_bindproc]", &bindproc_fops, private_data, O_RDWR | O_CLOEXEC);
    if (IS_ERR(filp)) {
        wuwa_err("failed to create anon inode file: %ld\n", PTR_ERR(filp));
        ret = PTR_ERR(filp);
        goto err_put_fd;
    }

    /* Copy result back to userspace before installing fd */
    cmd.fd = fd;
    if (copy_to_user(arg, &cmd, sizeof(cmd))) {
        wuwa_err("failed to copy cmd back to user\n");
        ret = -EFAULT;
        goto err_fput;
    }

    /* Install fd only after successful copy_to_user */
    fd_install(fd, filp);

    return 0;

err_fput:
    /* File not yet installed, safe to fput (releases private_data via bindproc_release) */
    fput(filp);
    /* Fall through to put_unused_fd */
err_put_fd:
    put_unused_fd(fd);
    return ret;

err_free_private:
    /* Only reached if file creation failed */
    mutex_destroy(&private_data->lock);
    kfree(private_data);
    return ret;
}
```

`src/mm/wuwa_bindproc.h`:

```h
#ifndef WUWA_BINDPROC_H
#define WUWA_BINDPROC_H

#include <linux/socket.h>

int do_bind_proc(struct socket* sock, void __user* arg);

#endif // WUWA_BINDPROC_H
```

`src/mm/wuwa_page_walk.c`:

```c
#include "wuwa_page_walk.h"
#include <asm/pgtable.h>
#include <linux/hugetlb.h>
#include <linux/mm.h>
#include <linux/proc_fs.h>
#include <linux/sched/mm.h>
#include <linux/sched/signal.h>
#include <linux/seq_file.h>
#include <linux/uaccess.h>
#include "wuwa_common.h"

#include "wuwa_utils.h"

// Function to merge and print contiguous memory regions
static void print_merged_region(unsigned long* start, unsigned long* end) {
    if (*start != -1UL) {
        // [start, end) is the format used by /proc/pid/maps
        wuwa_info("Found region: 0x%lx - 0x%lx\n", *start, *end + 1);
    }
    *start = -1UL;
    *end = -1UL;
}

// Walk the Page Table Entries (PTEs)
static void walk_pte_level(pmd_t* pmd, unsigned long addr, unsigned long end, unsigned long* region_start,
                           unsigned long* region_end, struct page_walk_stats* stats) {
#if defined(PTE_WALK)
    pte_t *ptep, pte;
    unsigned long current_addr;
    unsigned long pte_end;

    pte_end = (addr + PMD_SIZE) & PMD_MASK;
    if (end < pte_end)
        pte_end = end;

    ptep = pte_offset_kernel(pmd, addr);
    ptep = NULL;
    if (!ptep) {
        return;
    }

    for (current_addr = addr; current_addr < pte_end; current_addr += PAGE_SIZE) {
        pte = *ptep;
        if (stats) {
            stats->total_pte_count++;
        }
        if (pte_present(pte)) {
            if (stats) {
                stats->present_pte_count++;
            }
            // Found a mapped page
            if (*region_start != -1UL && current_addr != *region_end + PAGE_SIZE) {
                print_merged_region(region_start, region_end);
            }

            if (*region_start == -1UL) {
                *region_start = current_addr;
            }
            *region_end = current_addr;
        } else {
            // Gap detected, print the last region if it exists
            print_merged_region(region_start, region_end);
        }
        ptep++;
    }

    pte_unmap(ptep - ((pte_end - addr) >> PAGE_SHIFT));
#else
    wuwa_err("PTE walk not supported on this architecture.\n");
#endif
}

// Walk the Page Middle Directories (PMDs)
static void walk_pmd_level(pud_t* pud, unsigned long addr, unsigned long end, unsigned long* region_start,
                           unsigned long* region_end, struct page_walk_stats* stats) {
    pmd_t* pmd;
    unsigned long next;

    pmd = pmd_offset(pud, addr);

    do {
        next = pmd_addr_end(addr, end);
        if (pmd_present(*pmd) && !pmd_none(*pmd)) {
            if (pmd_huge(*pmd)) {
                if (stats) {
                    stats->pmd_huge_count++;
                }
                if (*region_start != -1UL && addr != *region_end + PAGE_SIZE) {
                    print_merged_region(region_start, region_end);
                }
                if (*region_start == -1UL) {
                    *region_start = addr;
                }
                *region_end = next - PAGE_SIZE;
            } else {
                walk_pte_level(pmd, addr, next, region_start, region_end, stats);
            }
        } else {
            print_merged_region(region_start, region_end);
        }
        addr = next;
        pmd++;
    } while (addr < end);
}

// Walk the Page Upper Directories (PUDs)
static void walk_pud_level(p4d_t* p4d, unsigned long addr, unsigned long end, unsigned long* region_start,
                           unsigned long* region_end, struct page_walk_stats* stats) {
    pud_t* pud;
    unsigned long next;

    pud = pud_offset(p4d, addr);

    do {
        next = pud_addr_end(addr, end);
        if (pud_present(*pud) && !pud_none(*pud)) {
            if (pud_huge(*pud)) {
                if (stats) {
                    stats->pud_huge_count++;
                }
                if (*region_start != -1UL && addr != *region_end + PAGE_SIZE) {
                    print_merged_region(region_start, region_end);
                }
                if (*region_start == -1UL) {
                    *region_start = addr;
                }
                *region_end = next - PAGE_SIZE;
            } else {
                walk_pmd_level(pud, addr, next, region_start, region_end, stats);
            }
        } else {
            print_merged_region(region_start, region_end);
        }
        addr = next;
        pud++;
    } while (addr < end);
}

// Walk the Page 4th-level Directories (P4Ds)
static void walk_p4d_level(pgd_t* pgd, unsigned long addr, unsigned long end, unsigned long* region_start,
                           unsigned long* region_end, struct page_walk_stats* stats) {
    p4d_t* p4d;
    unsigned long next;

    p4d = p4d_offset(pgd, addr);

    do {
        next = p4d_addr_end(addr, end);
        if (p4d_present(*p4d) && !p4d_none(*p4d)) {
            walk_pud_level(p4d, addr, next, region_start, region_end, stats);
        } else {
            print_merged_region(region_start, region_end);
        }
        addr = next;
        p4d++;
    } while (addr < end);
}

void traverse_page_tables(struct mm_struct* mm, struct page_walk_stats* stats) {
    unsigned long addr = 0;
    unsigned long region_start = -1UL, region_end = -1UL;
    pgd_t* pgd;
    unsigned long next;

    if (!mm) {
        return;
    }

    // Initialize stats if provided
    if (stats) {
        stats->total_pte_count = 0;
        stats->present_pte_count = 0;
        stats->pmd_huge_count = 0;
        stats->pud_huge_count = 0;
    }

    MM_READ_LOCK(mm);

    pgd = mm->pgd;

    do {
        next = pgd_addr_end(addr, TASK_SIZE);
        if (pgd_present(*pgd) && !pgd_none(*pgd)) {
            walk_p4d_level(pgd, addr, next, &region_start, &region_end, stats);
        } else {
            print_merged_region(&region_start, &region_end);
        }
        addr = next;
        pgd++;
    } while (addr < TASK_SIZE && addr != 0);

    print_merged_region(&region_start, &region_end);

    MM_READ_UNLOCK(mm);
}

```

`src/mm/wuwa_page_walk.h`:

```h
#ifndef WUWA_PAGE_WALK_H
#define WUWA_PAGE_WALK_H

#include <linux/mm_types.h>

struct page_walk_stats {
    u64 total_pte_count;
    u64 present_pte_count;
    u64 pmd_huge_count;
    u64 pud_huge_count;
};

void traverse_page_tables(struct mm_struct* mm, struct page_walk_stats* stats);

#endif // WUWA_PAGE_WALK_H

```

`src/mm/wuwa_proc_dmabuf.c`:

```c
#include "wuwa_proc_dmabuf.h"

#ifndef WUWA_DISABLE_DMABUF

#include <linux/dma-buf.h>
#include <linux/kernel.h>
#include <linux/mm.h>
#include <linux/module.h>
#include <linux/scatterlist.h>
#include <linux/slab.h>
#include <linux/version.h>

#include "wuwa_common.h"
#include "wuwa_ioctl.h"
#include "wuwa_page_walk.h"
#include "wuwa_utils.h"

struct wuwa_dmabuf_private {
    struct sg_table* sgt;
};

/**
 * wuwa_dmabuf_map_dma_buf - Map DMA buffer for device access
 * @attachment: DMA buffer attachment
 * @dir: DMA data direction
 *
 * Returns the scatter-gather table stored in the private data.
 * This is a simple implementation that just returns the pre-existing sg_table.
 *
 * Return: Pointer to sg_table
 */
static struct sg_table* wuwa_dmabuf_map_dma_buf(struct dma_buf_attachment* attachment, enum dma_data_direction dir) {
    struct wuwa_dmabuf_private* priv = attachment->dmabuf->priv;
    return priv->sgt;
}

/**
 * wuwa_dmabuf_unmap_dma_buf - Unmap DMA buffer after device access
 * @attachment: DMA buffer attachment
 * @sgt: Scatter-gather table
 * @dir: DMA data direction
 *
 * No-op implementation as we don't need to do any cleanup on unmap.
 */
static void wuwa_dmabuf_unmap_dma_buf(struct dma_buf_attachment* attachment, struct sg_table* sgt,
                                      enum dma_data_direction dir) {}

/**
 * wuwa_dmabuf_release - Release DMA buffer resources
 * @dmabuf: DMA buffer to release
 *
 * Frees all resources associated with the DMA buffer:
 * - Decrements page reference counts
 * - Frees scatter-gather table
 * - Frees private data structure
 */
static void wuwa_dmabuf_release(struct dma_buf* dmabuf) {
    struct wuwa_dmabuf_private* priv = dmabuf->priv;
    if (!priv) {
        return;
    }

    wuwa_info("releasing dmabuf private data\n");
    if (priv->sgt) {
        struct scatterlist* sg;
        int i;

        for_each_sg(priv->sgt->sgl, sg, priv->sgt->nents, i) {
            struct page* page = sg_page(sg);
            if (page) {
                put_page(page);
            }
        }

        sg_free_table(priv->sgt);
        kfree(priv->sgt);
    }

    kfree(priv);
}

/**
 * wuwa_dmabuf_begin_cpu_access - Begin CPU access to DMA buffer
 * @dmabuf: DMA buffer
 * @dir: DMA data direction
 *
 * Called before CPU accesses the buffer. Currently a no-op.
 *
 * Return: 0 on success
 */
static int wuwa_dmabuf_begin_cpu_access(struct dma_buf* dmabuf, enum dma_data_direction dir) { return 0; }

/**
 * wuwa_dmabuf_end_cpu_access - End CPU access to DMA buffer
 * @dmabuf: DMA buffer
 * @dir: DMA data direction
 *
 * Called after CPU finishes accessing the buffer. Currently a no-op.
 *
 * Return: 0 on success
 */
static int wuwa_dmabuf_end_cpu_access(struct dma_buf* dmabuf, enum dma_data_direction dir) { return 0; }

/**
 * wuwa_dmabuf_mmap - Map DMA buffer into userspace
 * @dmabuf: DMA buffer
 * @vma: Virtual memory area to map into
 *
 * Maps the physical page backing this DMA buffer into userspace.
 * Only supports single-page buffers (enforced by check).
 *
 * The VMA is configured with:
 * - VM_DONTEXPAND: Prevents the VMA from being extended
 * - VM_DONTDUMP: Excludes the VMA from core dumps
 *
 * Note: Cache coherency settings are not modified. If uncached access
 * is needed, uncomment the pgprot_noncached() line, but be aware this
 * may cause cache/memory consistency issues.
 *
 * Return: 0 on success, negative error code on failure
 */
static int wuwa_dmabuf_mmap(struct dma_buf* dmabuf, struct vm_area_struct* vma) {
    struct wuwa_dmabuf_private* priv = dmabuf->priv;
    struct page* page;
    unsigned long pfn;

    // make sure there is only one page
    if (priv->sgt->nents != 1) {
        wuwa_err("invalid number of sg entries: %d\n", priv->sgt->nents);
        return -EINVAL;
    }

    page = sg_page(priv->sgt->sgl);
    if (!page) {
        wuwa_err("failed to get page from sg_table\n");
        return -EINVAL;
    }

    pfn = page_to_pfn(page);
#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 19, 0))
    vma->vm_flags |= VM_DONTEXPAND | VM_DONTDUMP;
#else
    vm_flags_set(vma, vma->vm_flags | VM_DONTEXPAND | VM_DONTDUMP);
#endif
    // vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
    // Turning this on will cause the cache and main memory to be out of sync

    wuwa_debug("remapping PFN %lx to vma start %lx\n", pfn, vma->vm_start);
    return remap_pfn_range(vma, vma->vm_start, pfn, vma->vm_end - vma->vm_start, vma->vm_page_prot);
}

/**
 * DMA buffer operations structure
 *
 * Defines the set of callbacks for DMA buffer operations.
 * These callbacks are invoked by the kernel's dma-buf framework
 * when processes interact with the exported buffer.
 */
static const struct dma_buf_ops wuwa_dmabuf_ops = {
    .map_dma_buf = wuwa_dmabuf_map_dma_buf,
    .unmap_dma_buf = wuwa_dmabuf_unmap_dma_buf,
    .release = wuwa_dmabuf_release,
    .begin_cpu_access = wuwa_dmabuf_begin_cpu_access,
    .end_cpu_access = wuwa_dmabuf_end_cpu_access,
    .mmap = wuwa_dmabuf_mmap,
};

/**
 * do_create_proc_dma_buf - Create a DMA buffer from a process virtual address
 * @sock: Socket for session management
 * @arg: User-space pointer to wuwa_dma_buf_create_cmd
 *
 * Creates a DMA buffer from a process's virtual address. The workflow:
 * 1. Copy command structure from userspace
 * 2. Find the target process and get its mm_struct
 * 3. Translate virtual address to physical page
 * 4. Increment page reference count
 * 5. Create scatter-gather table from the page
 * 6. Allocate and initialize private data structure
 * 7. Export as dma-buf with proper flags
 * 8. Create file descriptor for the dma-buf
 * 9. Return FD to userspace
 *
 * The resulting file descriptor can be shared with other processes or
 * hardware devices for zero-copy memory access.
 *
 * Return: 0 on success, negative error code on failure
 */
int do_create_proc_dma_buf(struct socket* sock, void* arg) {
    struct wuwa_dma_buf_create_cmd cmd;
    struct sg_table* sgt;
    struct wuwa_dmabuf_private* priv;
    DEFINE_DMA_BUF_EXPORT_INFO(exp_info);

    if (copy_from_user(&cmd, arg, sizeof(cmd))) {
        return -EFAULT;
    }

    struct pid* pid_struct = find_get_pid(cmd.pid);
    if (!pid_struct) {
        wuwa_warn("failed to find pid_struct: %d\n", cmd.pid);
        return -ESRCH;
    }

    struct task_struct* task = get_pid_task(pid_struct, PIDTYPE_PID);
    put_pid(pid_struct);
    if (!task) {
        wuwa_warn("failed to get task: %d\n", cmd.pid);
        return -ESRCH;
    }

    struct mm_struct* mm = get_task_mm(task);
    put_task_struct(task);
    if (!mm) {
        wuwa_warn("failed to get mm: %d\n", cmd.pid);
        put_task_struct(task);
        return -ESRCH;
    }

    struct page* page_struct = vaddr_to_page(mm, cmd.va);
    mmput(mm);
    if (!page_struct) {
        return -EFAULT;
    }

    get_page(page_struct);

    sgt = kmalloc(sizeof(*sgt), GFP_KERNEL);
    if (!sgt) {
        return -ENOMEM;
    }

    if (sg_alloc_table_from_pages(sgt, &page_struct, 1, 0, cmd.size, GFP_KERNEL)) {
        kfree(sgt);
        return -ENOMEM;
    }

    priv = kmalloc(sizeof(*priv), GFP_KERNEL);
    if (!priv) {
        sg_free_table(sgt);
        kfree(sgt);
        return -ENOMEM;
    }
    priv->sgt = sgt;

    exp_info.ops = &wuwa_dmabuf_ops;
    exp_info.size = cmd.size;
    exp_info.flags = O_CLOEXEC | O_RDWR;
    exp_info.priv = priv;
    exp_info.owner = THIS_MODULE;

    struct dma_buf* dmabuf = dma_buf_export(&exp_info);
    if (IS_ERR(dmabuf)) {
        sg_free_table(sgt);
        kfree(sgt);
        kfree(priv);
        return PTR_ERR(dmabuf);
    }

    cmd.fd = dma_buf_fd(dmabuf, O_CLOEXEC | O_RDWR);
    if (cmd.fd < 0) {
        dma_buf_put(dmabuf);
        return cmd.fd;
    }

    if (copy_to_user(arg, &cmd, sizeof(cmd))) {
        dma_buf_put(dmabuf);
        return -EFAULT;
    }

    return 0;
}

#endif /* WUWA_DISABLE_DMABUF */

```

`src/mm/wuwa_proc_dmabuf.h`:

```h
#ifndef WUWA_PROC_DMABUF_H
#define WUWA_PROC_DMABUF_H

#include <linux/socket.h>

#ifndef WUWA_DISABLE_DMABUF
/**
 * do_create_proc_dma_buf - Create a DMA buffer from a process virtual address
 * @sock: Socket for session management
 * @arg: User-space pointer to wuwa_dma_buf_create_cmd
 *
 * This function creates a DMA buffer (dma-buf) from a process's virtual address,
 * allowing zero-copy memory sharing. The function:
 * 1. Translates the virtual address to a physical page
 * 2. Creates a scatter-gather table from the page
 * 3. Exports the page as a dma-buf file descriptor
 *
 * The resulting file descriptor can be used to map the memory into other processes
 * or hardware devices without copying data.
 *
 * Return: 0 on success, negative error code on failure
 */
int do_create_proc_dma_buf(struct socket* sock, void* arg);
#endif /* WUWA_DISABLE_DMABUF */

#endif /* WUWA_PROC_DMABUF_H */

```

`src/net/wuwa_protocol.c`:

```c
#include "wuwa_protocol.h"

#include <asm-generic/errno.h>

#include "wuwa_common.h"

#include <net/sock.h>

#include "wuwa_ioctl.h"
#include "wuwa_sock.h"

static int free_family = AF_DECnet;

struct proto wuwa_proto = {
    .name = "NFC_LLCP",
    .owner = THIS_MODULE,
    .obj_size = sizeof(struct wuwa_sock),
};

static int register_free_family(void) {
    int err = 0, i = 0;

    for (i = 0; i < ARRAY_SIZE(ioctl_handlers); i++) {
        wuwa_info("registered ioctl command: %u\n", ioctl_handlers[i].cmd);
    }

    for (int family = free_family; family < NPROTO; family++) {
        wuwa_family_ops.family = family;
        err = sock_register(&wuwa_family_ops);
        if (err)
            continue;
        free_family = family;
        wuwa_proto_ops.family = free_family;
        wuwa_info("find free proto_family: %d\n", wuwa_proto_ops.family);
        return 0;
    }

    wuwa_err("can't find any free proto_family!\n");
    return err;
}

int wuwa_proto_init(void) {
    int err = proto_register(&wuwa_proto, 1);
    if (err)
        goto out;

    err = register_free_family();
    if (err)
        goto out_proto;

    return 0;

    sock_unregister(free_family);
out_proto:
    proto_unregister(&wuwa_proto);
out:
    return err;
}

void wuwa_proto_cleanup(void) {
    sock_unregister(free_family);
    proto_unregister(&wuwa_proto);
}

static int wuwa_sock_create(struct net* net, struct socket* sock, int protocol, int kern) {
    if (!capable(CAP_NET_BIND_SERVICE)) {
        return -EACCES;
    }

    uid_t caller_uid = *(uid_t*)&current_cred()->uid;
    if (caller_uid != 0) {
        wuwa_warn("only root can create wuwa socket!\n");
        return -EAFNOSUPPORT;
    }

    if (sock->type != SOCK_RAW) {
        wuwa_warn("socket must be SOCK_RAW!\n");
        return -ENOKEY;
    }

    sock->state = SS_UNCONNECTED;
    struct sock* sk = sk_alloc(net, PF_INET, GFP_KERNEL, &wuwa_proto, kern);
    if (!sk) {
        wuwa_warn("sk_alloc failed!\n");
        return -ENOBUFS;
    }

    wuwa_family_ops.family = free_family;
    sock->ops = &wuwa_proto_ops;
    sock_init_data(sock, sk);

    struct wuwa_sock* ws = (struct wuwa_sock*)sk;
    ws->version = 1;
    ws->session = current->pid;
    ws->used_pages = arraylist_create(4);

    return 0;
}

struct net_proto_family wuwa_family_ops = {
    .family = PF_DECnet,
    .create = wuwa_sock_create,
    .owner = THIS_MODULE,
};

```

`src/net/wuwa_protocol.h`:

```h
#ifndef WUWA_PROTOCOL_H
#define WUWA_PROTOCOL_H

#include "wuwa_common.h"

int wuwa_proto_init(void);
void wuwa_proto_cleanup(void);

extern struct proto wuwa_proto;
extern struct net_proto_family wuwa_family_ops;

#endif /* WUWA_PROTOCOL_H */

```

`src/net/wuwa_sock.c`:

```c
#include "wuwa_sock.h"
#include <asm/pgalloc.h>
#include <asm/pgtable-hwdef.h>
#include "wuwa_ioctl.h"
#include "wuwa_protocol.h"
#include "wuwa_utils.h"

#include "wuwa_safe_signal.h"

static int wuwa_release(struct socket* sock) {
    wuwa_info("release wuwa sock\n");

    struct sock* sk = sock->sk;
    if (!sk) {
        return 0;
    }

    struct wuwa_sock* ws = (struct wuwa_sock*)sk;
    ws->version = 0;

    if (ws->session) {
        wuwa_del_unsafe_region(ws->session);
        ws->session = 0;
    }

    if (ws->used_pages) {
        for (int i = 0; i < ws->used_pages->size; ++i) {
            struct page* page = (typeof(page))arraylist_get(ws->used_pages, i);
            if (page) {
                __free_page(page);
            }
        }
        wuwa_info("free %lu used pages\n", ws->used_pages->size);
        arraylist_destroy(ws->used_pages);
    }

    sock_orphan(sk);
    sock_put(sk);
    return 0;
}

static int wuwa_ioctl(struct socket* sock, unsigned int cmd, unsigned long arg) {
    void __user* argp = (void __user*)arg;

    int i;
    for (i = 0; i < ARRAY_SIZE(ioctl_handlers); i++) {
        if (cmd == ioctl_handlers[i].cmd) {
            if (ioctl_handlers[i].handler == NULL) {
                continue;
            }
            return ioctl_handlers[i].handler(sock, argp);
        }
    }

    wuwa_warn("unsupported ioctl command: %u\n", cmd);
    return -ENOTTY;
}

static __poll_t wuwa_poll(struct file* file, struct socket* sock, struct poll_table_struct* wait) { return 0; }

static int wuwa_setsockopt(struct socket* sock, int level, int optname, sockptr_t optval, unsigned int optlen) {
#if defined(BUILD_HIDE_SIGNAL)
    if (optname == SOCK_OPT_SET_MODULE_VISIBLE) {
        if (optval.user != NULL) {
            show_module();
        } else {
            hide_module();
        }
        return 0;
    }
#endif

    return -ENOPROTOOPT;
}

static int wuwa_getsockopt(struct socket* sock, int level, int optname, char __user* optval, int __user* optlen) {
    return 0;
}

static int wuwa_bind(struct socket* sock, struct sockaddr* saddr, int len) { return -EOPNOTSUPP; }

static int wuwa_connect(struct socket* sock, struct sockaddr* saddr, int len, int flags) { return -EOPNOTSUPP; }

// int (*)(struct socket *, struct sockaddr *, int)' with an expression of type 'int (struct socket *, struct  sockaddr *, int *, int)
#if  defined(MAGIC_WUWA_GETNAME)
static int wuwa_getname(struct socket* sock, struct sockaddr* saddr, int* len, int peer) { return -EOPNOTSUPP; }
#else
static int wuwa_getname(struct socket* sock, struct sockaddr* saddr, int peer) { return -EOPNOTSUPP; }
#endif

static int wuwa_recvmsg(struct socket* sock, struct msghdr* m, size_t len, int flags) { return -EOPNOTSUPP; }

static int wuwa_sendmsg(struct socket* sock, struct msghdr* m, size_t len) { return -EOPNOTSUPP; }

static int wuwa_socketpair(struct socket *sock1, struct socket *sock2)
{
	return -EOPNOTSUPP;
}

#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 12, 0))
static int wuwa_accept(struct socket *sock, struct socket *newsock,
		   struct proto_accept_arg *arg)
{
	return -EOPNOTSUPP;
}
#else
static int wuwa_accept(struct socket *sock, struct socket *newsock, int flags,
		   bool kern)
{
	return -EOPNOTSUPP;
}
#endif

static int wuwa_listen(struct socket *sock, int backlog)
{
	return -EOPNOTSUPP;
}

static int wuwa_shutdown(struct socket *sock, int how)
{
	return -EOPNOTSUPP;
}

static int wuwa_mmap(struct file *file, struct socket *sock, struct vm_area_struct *vma)
{
	/* Mirror missing mmap method error code */
	return -ENODEV;
}

struct proto_ops wuwa_proto_ops = {
    .family = PF_DECnet,
    .owner = THIS_MODULE,
    .release = wuwa_release,
    .bind = wuwa_bind,
    .connect = wuwa_connect,
    .socketpair = wuwa_socketpair,
    .accept = wuwa_accept,
    .getname = wuwa_getname,
    .poll = wuwa_poll,
    .ioctl = wuwa_ioctl,
    .listen = wuwa_listen,
    .shutdown = wuwa_shutdown,
    .setsockopt = wuwa_setsockopt,
    .getsockopt = wuwa_getsockopt,
    .sendmsg = wuwa_sendmsg,
    .recvmsg = wuwa_recvmsg,
    .mmap = wuwa_mmap,
};

```

`src/net/wuwa_sock.h`:

```h
#ifndef WUWA_SOCK_H
#define WUWA_SOCK_H

#include <linux/init.h>
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/net.h>
#include <linux/skbuff.h>
#include <linux/socket.h>
#include <net/sock.h>

struct wuwa_sock;

extern struct proto_ops wuwa_proto_ops;

#define SOCK_OPT_SET_MODULE_VISIBLE 100

#endif // WUWA_SOCK_H

```

`src/proc/wuwa_proc.c`:

```c
#include "wuwa_proc.h"

int is_invisible(pid_t pid) {
    struct task_struct* task;
    if (!pid)
        return 0;
    task = find_task_by_vpid(pid);
    if (!task)
        return 0;
    if (task->flags & PF_INVISIBLE)
        return 1;
    return 0;
}

```

`src/proc/wuwa_proc.h`:

```h
#ifndef ANDROID_WUWA_WUWA_PROC_H
#define ANDROID_WUWA_WUWA_PROC_H

#include <linux/mm.h>
#include <linux/mm_types.h>
#include <linux/types.h>
#include <linux/version.h>
#include "wuwa_common.h"
#include <linux/sched.h>

#define PF_INVISIBLE 0x10000000

int is_invisible(pid_t pid);

#endif // ANDROID_WUWA_WUWA_PROC_H

```

`src/utils/karray_list.c`:

```c
#include "karray_list.h"

#include <linux/errno.h>
#include <linux/hugetlb.h>
#include <linux/interrupt.h>
#include <linux/mm.h>
#include <linux/pgtable.h>
#include <linux/printk.h>
#include <linux/proc_fs.h>
#include <linux/slab.h>
#include <linux/string.h>
#include <linux/vmalloc.h>

struct karray_list* arraylist_create(size_t initial_capacity) {
    struct karray_list* list = kmalloc(sizeof(*list), GFP_KERNEL);
    if (!list)
        return NULL;

    if (initial_capacity < ARRAYLIST_DEFAULT_CAPACITY)
        initial_capacity = ARRAYLIST_DEFAULT_CAPACITY;

    list->data = kmalloc_array(initial_capacity, sizeof(void*), GFP_KERNEL);
    if (!list->data) {
        kfree(list);
        return NULL;
    }

    list->size = 0;
    list->capacity = initial_capacity;
    return list;
}

static int ensure_capacity(struct karray_list* list, size_t min_capacity) {
    if (min_capacity <= list->capacity)
        return 0;

    size_t new_capacity = list->capacity + (list->capacity >> 1);
    if (new_capacity < min_capacity)
        new_capacity = min_capacity;

    void** new_data = krealloc_array(list->data, new_capacity, sizeof(void*), GFP_KERNEL);
    if (!new_data)
        return -ENOMEM;

    list->data = new_data;
    list->capacity = new_capacity;
    return 0;
}

int arraylist_add(struct karray_list* list, void* element) {
    int ret = 0;

    if (ensure_capacity(list, list->size + 1)) {
        ret = -ENOMEM;
        goto out;
    }

    list->data[list->size++] = element;

    out:
        return ret;
}

void* arraylist_get(struct karray_list* list, size_t index) {
    void* element = NULL;

    if (index < list->size)
        element = list->data[index];
    return element;
}

void* arraylist_remove(struct karray_list* list, size_t index) {
    void* element = NULL;

    if (index >= list->size)
        goto out;

    element = list->data[index];
    memmove(&list->data[index], &list->data[index + 1], (list->size - index - 1) * sizeof(void*));
    list->size--;

    out:
        return element;
}

void arraylist_clear(struct karray_list* list) {
    list->size = 0;
}

void arraylist_destroy(struct karray_list* list) {
    if (list->data)
        kfree(list->data);
    kfree(list);
}
```

`src/utils/karray_list.h`:

```h
#ifndef ANDROID_WUWA_KARRAY_LIST_H
#define ANDROID_WUWA_KARRAY_LIST_H

#include <linux/mm.h>
#include <linux/mm_types.h>
#include <linux/types.h>
#include <linux/version.h>

#define ARRAYLIST_DEFAULT_CAPACITY 16

struct karray_list {
    void** data;
    size_t size;
    size_t capacity;
};

struct karray_list* arraylist_create(size_t initial_capacity);
void arraylist_destroy(struct karray_list* list);
void* arraylist_remove(struct karray_list* list, size_t index);
void* arraylist_get(struct karray_list* list, size_t index);
int arraylist_add(struct karray_list* list, void* element);
void arraylist_clear(struct karray_list* list);

#endif // ANDROID_WUWA_KARRAY_LIST_H

```

`src/utils/wuwa_kallsyms.h`:

```h
#ifndef WUWA_KALLSYMS_H
#define WUWA_KALLSYMS_H

#include <linux/errno.h>
#include <linux/kernel.h>
#include <linux/sched.h>
#include "wuwa_common.h"
#include "wuwa_utils.h"

#define DECLARE_KSYM_RAW(name)                                                                                         \
    static void* _wuwa_sym_##name __section(".data");                                                                  \
    static void* __maybe_unused get_##name(void) { return _wuwa_sym_##name; }                                          \
    static int __maybe_unused ksym_find_##name(void) {                                                                 \
        _wuwa_sym_##name = (void*)kallsyms_lookup_name_ex(#name);                                                         \
        if (!_wuwa_sym_##name) {                                                                                       \
            ovo_err("Failed to find symbol: %s\n", #name);                                                             \
            return -ENOENT;                                                                                            \
        }                                                                                                              \
        return 0;                                                                                                      \
    }

#define DECLARE_KSYM_FUN(name, ret, args)                                                                              \
    static ret(*wuwa_##name) args = NULL;                                                                              \
    static int __maybe_unused ksym_find_##name(void) {                                                                 \
        if (wuwa_##name) {                                                                                             \
            return 0;                                                                                                  \
        }                                                                                                              \
        wuwa_##name = (typeof(wuwa_##name))kallsyms_lookup_name_ex(#name);                                                \
        if (!wuwa_##name) {                                                                                            \
            ovo_err("Failed to find symbol: %s\n", #name);                                                             \
            return -ENOENT;                                                                                            \
        }                                                                                                              \
        return 0;                                                                                                      \
    }

#endif // WUWA_KALLSYMS_H

```

`src/utils/wuwa_utils.c`:

```c
#include "wuwa_utils.h"

#include <linux/hugetlb.h>
#include <linux/interrupt.h>
#include <linux/mm.h>
#include <linux/pgtable.h>
#include <linux/printk.h>
#include <linux/proc_fs.h>
#include <linux/vmalloc.h>

#include "hijack_arm64.h"
#include "linux/pid.h"

#ifdef CONFIG_CFI_CLANG
#define NO_CFI __nocfi
#else
#define NO_CFI
#endif

static int wuwa_flip_open(const char* filename, int flags, umode_t mode, struct file** f) {
#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 10, 0))
    *f = filp_open(filename, flags, mode);
    return *f == NULL ? -2 : 0;
#else
    static struct file* (*reserve_flip_open)(const char* filename, int flags, umode_t mode) = NULL;

    if (reserve_flip_open == NULL) {
        reserve_flip_open =
            (struct file * (*)(const char* filename, int flags, umode_t mode)) kallsyms_lookup_name_ex("filp_open");
        if (reserve_flip_open == NULL) {
            return -1;
        }
    }

    *f = reserve_flip_open(filename, flags, mode);
    return *f == NULL ? -2 : 0;
#endif
}

static int wuwa_flip_close(struct file** f, fl_owner_t id) {
#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 10, 0))
    filp_close(*f, id);
    return 0;
#else
    static struct file* (*reserve_flip_close)(struct file** f, fl_owner_t id) = NULL;

    if (reserve_flip_close == NULL) {
        reserve_flip_close = (struct file * (*)(struct file * *f, fl_owner_t id)) kallsyms_lookup_name_ex("filp_close");
        if (reserve_flip_close == NULL) {
            return -1;
        }
    }

    reserve_flip_close(f, id);
    return 0;
#endif
}

bool is_file_exist(const char* filename) {
    struct file* fp;

    if (wuwa_flip_open(filename, O_RDONLY, 0, &fp) == 0) {
        if (!IS_ERR(fp)) {
            wuwa_flip_close(&fp, NULL);
            return true;
        }
        return false;
    }

    //    // int kern_path(const char *name, unsigned int flags, struct path *path)
    //    struct path path;
    //    if (kern_path(filename, LOOKUP_FOLLOW, &path) == 0) {
    //        return true;
    //    }

    return false;
}


pte_t* page_from_virt_user(struct mm_struct* mm, uintptr_t va) {
    pgd_t* pgd;
    p4d_t* p4d;
    pud_t* pud;
    pmd_t* pmd;
    pte_t* ptep = NULL;

    MM_READ_LOCK(mm);

    pgd = pgd_offset(mm, va);
    if (pgd_none(*pgd) || pgd_bad(*pgd)) {
        wuwa_warn("PGD entry for address 0x%lx not found or bad\n", va);
        goto out;
    }

    p4d = p4d_offset(pgd, va);
    if (p4d_none(*p4d) || p4d_bad(*p4d)) {
        wuwa_warn("P4D entry for address 0x%lx not found or bad\n", va);
        goto out;
    }

    pud = pud_offset(p4d, va);
    if (pud_none(*pud) || pud_bad(*pud)) {
        wuwa_warn("PUD entry for address 0x%lx not found or bad\n", va);
        goto out;
    }

    if (pud_leaf(*pud)) {
        wuwa_debug("Address 0x%lx maps to a PUD-level huge page (leaf), no PTE exists\n", va);
        goto out;
    }

    pmd = pmd_offset(pud, va);
    if (pmd_none(*pmd) || pmd_bad(*pmd)) {
        wuwa_warn("PMD entry for address 0x%lx not found or bad\n", va);
        goto out;
    }

    if (pmd_leaf(*pmd)) {
        wuwa_debug("Address 0x%lx maps to a PMD-level huge page (leaf), no PTE exists\n", va);
        goto out;
    }

    ptep = pte_offset_kernel(pmd, va);
    if (!ptep) {
        wuwa_warn("Failed to map PTE for address 0x%lx\n", va);
        goto out;
    }
out:
    MM_READ_UNLOCK(mm);

    return ptep;
}

uintptr_t vaddr_to_phy_addr(struct mm_struct* mm, uintptr_t va) {
    if (!mm) {
        wuwa_warn("mm_struct is NULL, cannot perform translation\n");
        return 0;
    }

    pte_t* ptep = page_from_virt_user(mm, va);
    if (!ptep) {
        wuwa_err("failed to get PTE for virtual address 0x%lx\n", va);
        return 0;
    }

    if (!pte_present(*ptep)) {
        wuwa_err("PTE not present for virtual address 0x%lx\n", va);
        return 0;
    }

    uintptr_t page_addr = pte_pfn(*ptep) << PAGE_SHIFT;

    return page_addr + (va & (PAGE_SIZE - 1));
}

typedef unsigned long (*kallsyms_lookup_name_t)(const char *name);

static unsigned long NO_CFI call_kln(kallsyms_lookup_name_t f, const char *n) {
    return f(n);
}

unsigned long kallsyms_lookup_name_ex(const char* name) {
#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 7, 0)
    static kallsyms_lookup_name_t lookup_name = NULL;
    if (lookup_name == NULL) {
        struct kprobe kp = {.symbol_name = "kallsyms_lookup_name"};

        if (register_kprobe(&kp) < 0) {
            return 0;
        }

        lookup_name = (kallsyms_lookup_name_t)kp.addr;
        unregister_kprobe(&kp);

        if (lookup_name == NULL) {
            wuwa_err("kallsyms_lookup_name not found\n");
            return 0;
        }
        wuwa_info("kallsyms_lookup_name_ex found at %p\n", lookup_name);
    }

    return call_kln(lookup_name, name);
#else
    return kallsyms_lookup_name(name);
#endif
}

struct task_struct* get_target_task(pid_t pid) {
    struct pid* pid_struct = find_get_pid(pid);
    if (!pid_struct) {
        return NULL;
    }

    struct task_struct* task = get_pid_task(pid_struct, PIDTYPE_PID);
    put_pid(pid_struct);
    if (!task) {
        return NULL;
    }

    return task;
}

int disable_kprobe_blacklist(void) {
    struct kprobe_blacklist_entry* ent;
    struct list_head* kprobe_blacklist = (struct list_head*)kallsyms_lookup_name_ex("kprobe_blacklist");
    if (!kprobe_blacklist) {
        wuwa_err("kprobe_blacklist not found\n");
        return -ENOENT;
    }

    int count = 0;
    list_for_each_entry(ent, kprobe_blacklist, list) {
        if (!ent || ent->start_addr == 0 || ent->end_addr == 0) {
            continue;
        }
        count++;
        ent->start_addr = 0;
        ent->end_addr = 0;
    }

    wuwa_info("Disabled %d kprobe blacklist entries\n", count);

    return 0;
}

void compare_pt_regs(struct pt_regs* regs1, struct pt_regs* regs2) {
#if CONFIG_COMPARE_PT_REGS == 1
    wuwa_info("==> Comparing pt_regs:\n");

    for (int i = 0; i < 31; ++i) {
        if (regs1->regs[i] != regs2->regs[i]) {
            wuwa_info("reg[%d] changed from %llx to %llx\n", i, regs1->regs[i], regs2->regs[i]);
        }
    }

    if (regs1->sp != regs2->sp) {
        wuwa_info("sp changed from %llx to %llx\n", regs1->sp, regs2->sp);
    }

    if (regs1->pc != regs2->pc) {
        wuwa_info("pc changed from %llx to %llx\n", regs1->pc, regs2->pc);
    }

    if (regs1->pstate != regs2->pstate) {
        wuwa_info("pstate changed from %llx to %llx\n", regs1->pstate, regs2->pstate);
    }

    if (regs1->sdei_ttbr1 != regs2->sdei_ttbr1) {
        wuwa_info("sdei_ttbr1 changed from %llx to %llx\n", regs1->sdei_ttbr1, regs2->sdei_ttbr1);
    }

    if (regs1->pmr_save != regs2->pmr_save) {
        wuwa_info("pmr_save changed from %llx to %llx\n", regs1->pmr_save, regs2->pmr_save);
    }

    if (regs1->stackframe[0] != regs2->stackframe[0] || regs1->stackframe[1] != regs2->stackframe[1]) {
        wuwa_info("stackframe changed from [%llx, %llx] to [%llx, %llx]\n", regs1->stackframe[0], regs1->stackframe[1],
                 regs2->stackframe[0], regs2->stackframe[1]);
    }
#endif
}

void compare_task_struct(struct task_struct* task1, struct task_struct* task2) {
#if CONFIG_COMPARE_TASK == 1
    wuwa_info("==> Comparing task_struct:\n");
#ifdef CONFIG_THREAD_INFO_IN_TASK
    if (task1->thread_info.flags != task2->thread_info.flags) {
        wuwa_info("thread_info.flags changed from %lx to %lx\n", task1->thread_info.flags, task2->thread_info.flags);
    }

    if (task1->thread_info.cpu != task2->thread_info.cpu) {
        wuwa_info("thread_info.cpu changed from %d to %d\n", task1->thread_info.cpu, task2->thread_info.cpu);
    }
#endif

    if (task1->__state != task2->__state) {
        wuwa_info("__state changed from %u to %u\n", task1->__state, task2->__state);
    }

    if (task1->stack != task2->stack) {
        wuwa_info("stack pointer changed from %p to %p\n", task1->stack, task2->stack);
    }

    if (task1->flags != task2->flags) {
        wuwa_info("flags changed from %u to %u\n", task1->flags, task2->flags);
    }

    if (task1->ptrace != task2->ptrace) {
        wuwa_info("ptrace changed from %u to %u\n", task1->ptrace, task2->ptrace);
    }

    if (task1->pid != task2->pid) {
        wuwa_info("pid changed from %d to %d\n", task1->pid, task2->pid);
    }

    if (task1->tgid != task2->tgid) {
        wuwa_info("tgid changed from %d to %d\n", task1->tgid, task2->tgid);
    }
#endif
}

#define W_PHYS_PFN(x) ((unsigned long)((x) >> PAGE_SHIFT))
#define wuwa_phys_to_pfn(paddr) W_PHYS_PFN(paddr)

struct page* vaddr_to_page(struct mm_struct* mm, uintptr_t va) {
#if !defined(pfn_to_page)
#error "vaddr_to_page failed: pfn_to_page not found"
#endif
    return pfn_to_page(wuwa_phys_to_pfn(vaddr_to_phy_addr(mm, va)));
}

int translate_process_vaddr(pid_t pid, uintptr_t vaddr, uintptr_t* paddr_out) {
    struct pid* pid_struct;
    struct task_struct* task;
    struct mm_struct* mm;
    uintptr_t paddr;

    pid_struct = find_get_pid(pid);
    if (!pid_struct) {
        wuwa_warn("failed to find pid_struct: %d\n", pid);
        return -ESRCH;
    }

    task = get_pid_task(pid_struct, PIDTYPE_PID);
    put_pid(pid_struct);
    if (!task) {
        wuwa_warn("failed to get task: %d\n", pid);
        return -ESRCH;
    }

    mm = get_task_mm(task);
    if (!mm) {
        wuwa_warn("failed to get mm: %d\n", pid);
        put_task_struct(task);
        return -ESRCH;
    }

    paddr = vaddr_to_phy_addr(mm, vaddr);
    
    mmput(mm);
    put_task_struct(task);

    if (paddr == 0) {
        return -EFAULT;
    }

    *paddr_out = paddr;
    return 0;
}

uintptr_t get_module_base(pid_t pid, char* name, int vm_flag) {
    struct pid* pid_struct;
    struct task_struct* task;
    struct mm_struct* mm;
    struct vm_area_struct* vma;
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0))
    struct vma_iterator vmi;
#endif
    uintptr_t result;
    struct dentry* dentry;
    size_t name_len, dname_len;

    result = 0;

    name_len = strlen(name);
    if (name_len == 0) {
        wuwa_err("module name is empty\n");
        return 0;
    }

    pid_struct = find_get_pid(pid);
    if (!pid_struct) {
        wuwa_err("failed to find pid_struct\n");
        return 0;
    }

    task = get_pid_task(pid_struct, PIDTYPE_PID);
    put_pid(pid_struct);
    if (!task) {
        wuwa_err("failed to get task from pid_struct\n");
        return 0;
    }

    mm = get_task_mm(task);
    put_task_struct(task);
    if (!mm) {
        wuwa_err("failed to get mm from task\n");
        return 0;
    }

    MM_READ_LOCK(mm)

#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0))
    vma_iter_init(&vmi, mm, 0);
    for_each_vma(vmi, vma)
#else
    for (vma = mm->mmap; vma; vma = vma->vm_next)
#endif
    {
        if (vma->vm_file) {
            if (vm_flag && !(vma->vm_flags & vm_flag)) {
                continue;
            }
            dentry = vma->vm_file->f_path.dentry;
            dname_len = dentry->d_name.len;
            if (!memcmp(dentry->d_name.name, name, min(name_len, dname_len))) {
                result = vma->vm_start;
                goto ret;
            }
        }
    }

ret:
    MM_READ_UNLOCK(mm)

    mmput(mm);
    return result;
}

int is_pid_alive(pid_t pid) {
    struct pid* pid_struct;
    struct task_struct* task;

    pid_struct = find_get_pid(pid);
    if (!pid_struct)
        return false;

    task = pid_task(pid_struct, PIDTYPE_PID);
    if (!task)
        return false;

    return pid_alive(task);
}

#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0)
pid_t find_process_by_name(const char* name) {
    struct task_struct* task;
    char cmdline[256];
    char* prog_name;
    size_t name_len;
    int ret;

    name_len = strlen(name);
    if (name_len == 0) {
        pr_err("process name is empty\n");
        return -2;
    }

    static int (*my_get_cmdline)(struct task_struct* task, char* buffer, int buflen) = NULL;
    if (my_get_cmdline == NULL) {
        my_get_cmdline = (void*)kallsyms_lookup_name_ex("get_cmdline");
    }

    rcu_read_lock();
    for_each_process(task) {
        if (task->mm == NULL) {
            continue;
        }

        cmdline[0] = '\0';
        if (my_get_cmdline != NULL) {
            ret = my_get_cmdline(task, cmdline, sizeof(cmdline));
        } else {
            ret = -1;
        }

        if (ret < 0) {
            // 回退到task->comm，确保完全匹配
            if (strlen(task->comm) == name_len && strncmp(task->comm, name, name_len) == 0) {
                rcu_read_unlock();
                return task->pid;
            }
        } else {
            // 提取程序名（第一个空格之前的部分）
            prog_name = cmdline;
            char* space = strchr(cmdline, ' ');
            if (space) {
                *space = '\0';
            }

            // 提取路径中的文件名部分
            char* slash = strrchr(prog_name, '/');
            if (slash) {
                prog_name = slash + 1;
            }

            if (strlen(prog_name) == name_len && strncmp(prog_name, name, name_len) == 0) {
                rcu_read_unlock();
                return task->pid;
            }
        }
    }
    rcu_read_unlock();
    return 0;
}

#else
int get_cmdline_ex(struct task_struct* task, char* buffer, int buflen) {
    int res = 0;
    unsigned int len;
    struct mm_struct* mm = get_task_mm(task);
    unsigned long arg_start, arg_end, env_start, env_end;
    if (!mm)
        goto out;
    if (!mm->arg_end)
        goto out_mm; /* Shh! No looking before we're done */

    spin_lock(&mm->arg_lock);
    arg_start = mm->arg_start;
    arg_end = mm->arg_end;
    env_start = mm->env_start;
    env_end = mm->env_end;
    spin_unlock(&mm->arg_lock);

    len = arg_end - arg_start;

    if (len > buflen)
        len = buflen;

    res = access_process_vm(task, arg_start, buffer, len, FOLL_FORCE);

    /*
     * If the nul at the end of args has been overwritten, then
     * assume application is using setproctitle(3).
     */
    if (res > 0 && buffer[res - 1] != '\0' && len < buflen) {
        len = strnlen(buffer, res);
        if (len < res) {
            res = len;
        } else {
            len = env_end - env_start;
            if (len > buflen - res)
                len = buflen - res;
            res += access_process_vm(task, env_start, buffer + res, len, FOLL_FORCE);
            res = strnlen(buffer, res);
        }
    }
out_mm:
    mmput(mm);
out:
    return res;
}

pid_t find_process_by_name(const char* name) {
    struct task_struct* task;
    char cmdline[256];
    char* prog_name;
    size_t name_len;
    int ret;

    name_len = strlen(name);
    if (name_len == 0) {
        pr_err("process name is empty\n");
        return -2;
    }

    rcu_read_lock();
    for_each_process(task) {
        if (task->mm == NULL) {
            continue;
        }

        cmdline[0] = '\0';
        ret = get_cmdline_ex(task, cmdline, sizeof(cmdline));

        if (ret < 0) {
            // 回退到task->comm，确保完全匹配
            if (strlen(task->comm) == name_len && strncmp(task->comm, name, name_len) == 0) {
                rcu_read_unlock();
                return task->pid;
            }
        } else {
            // 提取程序名（第一个空格之前的部分）
            prog_name = cmdline;
            char* space = strchr(cmdline, ' ');
            if (space) {
                *space = '\0';
            }

            // 提取路径中的文件名部分
            char* slash = strrchr(prog_name, '/');
            if (slash) {
                prog_name = slash + 1;
            }

            if (strlen(prog_name) == name_len && strncmp(prog_name, name, name_len) == 0) {
                rcu_read_unlock();
                return task->pid;
            }
        }
    }
    rcu_read_unlock();
    return 0;
}
#endif

static struct list_head* module_previous;
static struct list_head* module_kobj_previous;
static short module_hidden = 0;

void show_module(void) {
    // list_add(&THIS_MODULE->list, module_previous);
    // kobject_add(&THIS_MODULE->mkobj.kobj, THIS_MODULE->mkobj.kobj.parent, "%s", THIS_MODULE->name);
    // list_add(&THIS_MODULE->mkobj.kobj.entry, module_kobj_previous);
    module_hidden = 0;
}

void hide_module(void) {
#if defined(HIDE_SELF_MODULE)
    if (is_file_exist("/proc/sched_debug")) {
        remove_proc_entry("sched_debug", NULL);
    }

    if (is_file_exist("/proc/uevents_records")) {
        remove_proc_entry("uevents_records", NULL);
    }

#ifdef MODULE
    // module_previous = THIS_MODULE->list.prev;
    // module_kobj_previous = THIS_MODULE->mkobj.kobj.entry.prev;
    //
    list_del(&THIS_MODULE->list); // lsmod,/proc/modules
    kobject_del(&THIS_MODULE->mkobj.kobj); // /sys/modules
    list_del(&THIS_MODULE->mkobj.kobj.entry); // kobj struct list_head entry
    module_hidden = 1;
#endif

    // protocol disguise! A lie
    memcpy(THIS_MODULE->name, "nfc\0", 4);
    // remove_proc_entry("protocols", net->proc_net);
#endif
}

int give_root(void) {
#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 29)
    current->uid = current->gid = 0;
    current->euid = current->egid = 0;
    current->suid = current->sgid = 0;
    current->fsuid = current->fsgid = 0;
#else
    struct cred* newcreds;
    static struct cred* (*my_prepare_creds)(void) = NULL;
    static int (*my_commit_creds)(struct cred*) = NULL;
    if (my_prepare_creds == NULL) {
        my_prepare_creds = (void*)kallsyms_lookup_name_ex("prepare_creds");
        my_commit_creds = (void*)kallsyms_lookup_name_ex("commit_creds");
        if (my_prepare_creds == NULL || my_commit_creds == NULL) {
            return -1;
        }
    }
    newcreds = my_prepare_creds();
    if (newcreds == NULL)
        return -2;
#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 5, 0) && defined(CONFIG_UIDGID_STRICT_TYPE_CHECKS) ||                      \
    LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
    newcreds->uid.val = newcreds->gid.val = 0;
    newcreds->euid.val = newcreds->egid.val = 0;
    newcreds->suid.val = newcreds->sgid.val = 0;
    newcreds->fsuid.val = newcreds->fsgid.val = 0;
#else
    newcreds->uid = newcreds->gid = 0;
    newcreds->euid = newcreds->egid = 0;
    newcreds->suid = newcreds->sgid = 0;
    newcreds->fsuid = newcreds->fsgid = 0;
#endif
    my_commit_creds(newcreds);
#endif
    return 0;
}

void __iomem* wuwa_ioremap_prot(uintptr_t phys_addr, size_t size, pgprot_t prot) {
    unsigned long offset, vaddr;
    uintptr_t last_addr;
    struct vm_struct* area;
    int err;

    offset = phys_addr & ~PAGE_MASK;
    /*
     * Page align the mapping address and size, taking account of any
     * offset.
     */
    phys_addr &= PAGE_MASK;
    size = PAGE_ALIGN(size + offset);

    /*
     * Don't allow wraparound, zero size or outside PHYS_MASK.
     */
    last_addr = phys_addr + size - 1;
    if (!size || last_addr < phys_addr || last_addr & ~PHYS_MASK)
        return NULL;

    static int (*my_ioremap_page_range)(unsigned long addr, unsigned long end,
               uintptr_t phys_addr, pgprot_t prot) = NULL;
    static void (*my_free_vm_area)(struct vm_struct *area) = NULL;
    if (my_ioremap_page_range == NULL || my_free_vm_area == NULL) {
        my_ioremap_page_range = (int (*)(unsigned long addr, unsigned long end,
                   uintptr_t phys_addr, pgprot_t prot))kallsyms_lookup_name_ex("ioremap_page_range");
        my_free_vm_area = (void (*)(struct vm_struct *area))kallsyms_lookup_name_ex("free_vm_area");
        if (my_ioremap_page_range == NULL || my_free_vm_area == NULL) {
            wuwa_err("cannot find ioremap_page_range or free_vm_area\n");
            return NULL;
        }
    }

#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 6, 0)
    static struct vm_struct *(*my__get_vm_area_caller)(unsigned long size,
                    unsigned long flags,
                    unsigned long start, unsigned long end,
                    const void *caller) = NULL;
    if (my__get_vm_area_caller == NULL) {
        my__get_vm_area_caller = (struct vm_struct * (*)(unsigned long, unsigned long, unsigned long, unsigned long, const void *))kallsyms_lookup_name_ex("__get_vm_area_caller");
        if (my__get_vm_area_caller == NULL) {
            wuwa_err("cannot find __get_vm_area_caller\n");
            return NULL;
        }
    }
    area = my__get_vm_area_caller(size, VM_IOREMAP, VMALLOC_START, VMALLOC_END, __builtin_return_address(0));
#elif LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0)
    static struct vm_struct* (*my_get_vm_area_caller)(unsigned long, unsigned long, const void*) = NULL;
    if (my_get_vm_area_caller == NULL) {
        my_get_vm_area_caller =
            (struct vm_struct * (*)(unsigned long, unsigned long, const void*))kallsyms_lookup_name_ex("get_vm_area_caller");
        if (my_get_vm_area_caller == NULL) {
            wuwa_err("cannot find get_vm_area_caller\n");
            return NULL;
        }
    }
    area = my_get_vm_area_caller(size, VM_IOREMAP, __builtin_return_address(0));
#endif

    if (!area)
        return NULL;
    vaddr = (unsigned long)area->addr;
    area->phys_addr = phys_addr;

    err = my_ioremap_page_range(vaddr, vaddr + size, phys_addr, prot);
    if (err) {
        my_free_vm_area(area);
        return NULL;
    }

    return (void __iomem*)(vaddr + offset);
}

int cfi_bypass(void) {
    int ret = 0;
    unsigned int RET = 0xD65F03C0; // ret指令 (aarch64)
    unsigned int MOV_X0_1 = 0xD2800020; // mov x0, #1 20 00 80 D2

    unsigned long f__cfi_slowpath = kallsyms_lookup_name_ex("__cfi_slowpath");
    if (f__cfi_slowpath) {
        unsigned int* p = (unsigned int*)f__cfi_slowpath;
        if(*p != RET) {
            hook_write_range(p, &RET, INSTRUCTION_SIZE);
            ret++;
            wuwa_err("patch __cfi_slowpath successed\n");
        } else {
            wuwa_info("__cfi_slowpath already patched\n");
        }
    }

    unsigned long f__cfi_slowpath_diag = kallsyms_lookup_name_ex("__cfi_slowpath_diag");
    if (f__cfi_slowpath_diag) {
        unsigned int* p = (unsigned int*)f__cfi_slowpath_diag;
        if(*p != RET) {
            hook_write_range(p, &RET, INSTRUCTION_SIZE);
            ret++;
            wuwa_err("patch __cfi_slowpath_diag successed\n");
        } else {
            wuwa_info("__cfi_slowpath_diag already patched\n");
        }
    }

    unsigned long f_cfi_slowpath = kallsyms_lookup_name_ex("_cfi_slowpath");
    if (f_cfi_slowpath) {
        unsigned int* p = (unsigned int*)f_cfi_slowpath;
        if(*p != RET) {
            hook_write_range(p, &RET, INSTRUCTION_SIZE);
            ret++;
            wuwa_err("patch _cfi_slowpath successed\n");
        } else {
            wuwa_info("_cfi_slowpath already patched\n");
        }
    }

    unsigned long f__cfi_check_fail = kallsyms_lookup_name_ex("__cfi_check_fail");
    if (f__cfi_check_fail) {
        unsigned int* p = (unsigned int*)f__cfi_check_fail;
        if(*p != RET) {
            hook_write_range(p, &RET, INSTRUCTION_SIZE);
            ret++;
            wuwa_err("patch __cfi_check_fail successed\n");
        } else {
            wuwa_info("__cfi_check_fail already patched\n");
        }
    }

    unsigned long f__ubsan_handle_cfi_check_fail_abort = kallsyms_lookup_name_ex("__ubsan_handle_cfi_check_fail_abort");
    if (f__ubsan_handle_cfi_check_fail_abort) {
        unsigned int* p = (unsigned int*)f__ubsan_handle_cfi_check_fail_abort;
        if(*p != RET) {
            hook_write_range(p, &RET, INSTRUCTION_SIZE);
            ret++;
            wuwa_err("patch __ubsan_handle_cfi_check_fail_abort successed\n");
        } else {
            wuwa_info("__ubsan_handle_cfi_check_fail_abort already patched\n");
        }
    }

    unsigned long f__ubsan_handle_cfi_check_fail = kallsyms_lookup_name_ex("__ubsan_handle_cfi_check_fail");
    if (f__ubsan_handle_cfi_check_fail) {
        unsigned int* p = (unsigned int*)f__ubsan_handle_cfi_check_fail;
        if(*p != RET) {
            hook_write_range(p, &RET, INSTRUCTION_SIZE);
            ret++;
            wuwa_err("patch __ubsan_handle_cfi_check_fail successed\n");
        } else {
            wuwa_info("__ubsan_handle_cfi_check_fail already patched\n");
        }
    }

    unsigned long freport_cfi_failure = kallsyms_lookup_name_ex("report_cfi_failure");
    if (freport_cfi_failure) {
        unsigned int* p = (unsigned int*)freport_cfi_failure;
        if(*p != MOV_X0_1) {
            hook_write_range(p, &MOV_X0_1, INSTRUCTION_SIZE);
            hook_write_range(p + 1, &RET, INSTRUCTION_SIZE);
            ret++;
        } else {
            wuwa_info("report_cfi_failure already patched\n");
        }
    }

    return ret;
}

/**
 * convert_wmt_to_pgprot - Convert WMT memory type to pgprot_t
 * @wmt_type: WMT memory type constant (WMT_NORMAL, WMT_DEVICE_*, etc.)
 * @prot_out: Output pgprot_t value
 *
 * Return: 0 on success, negative error code on failure
 */
int convert_wmt_to_pgprot(int wmt_type, pgprot_t* prot_out) {
    switch (wmt_type) {
        case WMT_NORMAL:
            *prot_out = __pgprot(PROT_NORMAL);
            return 0;

        case WMT_NORMAL_TAGGED:
#if defined(PROT_NORMAL_TAGGED)
            *prot_out = __pgprot(PROT_NORMAL_TAGGED);
            return 0;
#else
            wuwa_warn("PROT_NORMAL_TAGGED not defined on this kernel\n");
            return -EINVAL;
#endif

        case WMT_NORMAL_NC:
#if defined(PROT_NORMAL_NC)
            *prot_out = __pgprot(PROT_NORMAL_NC);
            return 0;
#else
            wuwa_warn("PROT_NORMAL_NC not defined on this kernel\n");
            return -EINVAL;
#endif

        case WMT_NORMAL_WT:
#if defined(PROT_NORMAL_WT)
            *prot_out = __pgprot(PROT_NORMAL_WT);
            return 0;
#else
            wuwa_warn("PROT_NORMAL_WT not defined on this kernel\n");
            return -EINVAL;
#endif

        case WMT_DEVICE_nGnRnE:
#if defined(PROT_DEVICE_nGnRnE)
            *prot_out = __pgprot(PROT_DEVICE_nGnRnE);
            return 0;
#else
            wuwa_warn("PROT_DEVICE_nGnRnE not defined on this kernel\n");
            return -EINVAL;
#endif

        case WMT_DEVICE_nGnRE:
#if defined(PROT_DEVICE_nGnRE)
            *prot_out = __pgprot(PROT_DEVICE_nGnRE);
            return 0;
#else
            wuwa_warn("PROT_DEVICE_nGnRE not defined on this kernel\n");
            return -EINVAL;
#endif

        default:
            wuwa_warn("invalid prot: %d\n", wmt_type);
            return -EINVAL;
    }
}
```

`src/utils/wuwa_utils.h`:

```h
#ifndef WUWA_UTILS_H
#define WUWA_UTILS_H

#include <linux/mm.h>
#include <linux/mm_types.h>
#include <linux/types.h>
#include <linux/version.h>
#include "wuwa_common.h"
#include "karray_list.h"

#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 8, 0))
#include <linux/mmap_lock.h>
#define MM_READ_LOCK(mm) mmap_read_lock(mm);
#define MM_READ_UNLOCK(mm) mmap_read_unlock(mm);
#define MM_WRITE_LOCK(mm) mmap_write_lock(mm);
#define MM_WRITE_UNLOCK(mm) mmap_write_unlock(mm);
#else
#include <linux/rwsem.h>
#define MM_READ_LOCK(mm) down_read(&(mm)->mmap_sem);
#define MM_READ_UNLOCK(mm) up_read(&(mm)->mmap_sem);
#define MM_WRITE_LOCK(mm) down_write(&(mm)->mmap_sem);
#define MM_WRITE_UNLOCK(mm) up_write(&(mm)->mmap_sem);
#endif

#define WMT_NORMAL 0
#define WMT_NORMAL_TAGGED 1
#define WMT_NORMAL_NC 2
#define WMT_NORMAL_WT 3
#define WMT_DEVICE_nGnRnE 4
#define WMT_DEVICE_nGnRE 5
#define WMT_DEVICE_GRE 6
#define WMT_NORMAL_iNC_oWB 7

bool is_file_exist(const char* filename);

pte_t* page_from_virt_user(struct mm_struct* mm, uintptr_t va);

uintptr_t vaddr_to_phy_addr(struct mm_struct* mm, uintptr_t va);

struct page* vaddr_to_page(struct mm_struct* mm, uintptr_t va);

int translate_process_vaddr(pid_t pid, uintptr_t vaddr, uintptr_t* paddr_out);

unsigned long kallsyms_lookup_name_ex(const char* symbol_name);

struct task_struct* get_target_task(pid_t pid);

int disable_kprobe_blacklist(void);

void compare_pt_regs(struct pt_regs* regs1, struct pt_regs* regs2);
void compare_task_struct(struct task_struct* task1, struct task_struct* task2);

static __always_inline void set_current(struct task_struct* tsk) {
    unsigned long tmp = (unsigned long)tsk;

    asm volatile("msr sp_el0, %0" : : "r"(tmp) : "memory");
}

uintptr_t get_module_base(pid_t pid, char* name, int vm_flag);

int is_pid_alive(pid_t pid);

pid_t find_process_by_name(const char* name);

void show_module(void);
void hide_module(void);

int give_root(void);

int cfi_bypass(void);

void __iomem* wuwa_ioremap_prot(uintptr_t phys_addr, size_t size, pgprot_t prot);

int convert_wmt_to_pgprot(int wmt_type, pgprot_t* prot_out);

#endif // WUWA_UTILS_H

```