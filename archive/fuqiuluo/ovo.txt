Project Path: arc_fuqiuluo_ovo_ql83goye

Source Tree:

```txt
arc_fuqiuluo_ovo_ql83goye
├── LICENSE
├── README.md
├── action.yml
├── client-sdk
│   ├── hak.rs
│   ├── hakutaku.cpp
│   └── hakutaku.h
├── ovo
│   ├── Makefile
│   ├── addr_pfn_map.c
│   ├── addr_pfn_map.h
│   ├── core.c
│   ├── kkit.c
│   ├── kkit.h
│   ├── memory.c
│   ├── memory.h
│   ├── mmuhack.c
│   ├── mmuhack.h
│   ├── peekaboo.c
│   ├── peekaboo.h
│   ├── server.c
│   ├── server.h
│   ├── touch.c
│   ├── touch.h
│   ├── vma.c
│   └── vma.h
└── samples
    └── jni
        ├── Android.mk
        ├── Application.mk
        ├── hakutaku.cpp
        ├── hakutaku.h
        └── test_memory.cpp

```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.

```

`README.md`:

```md
# OvO

A kernel driver module designed to provide portable hacking operations!

Rootkit operation of some kernel modules is provided for the kernel of android-aarch64, this is a learning project of mine, and some mistakes may be corrected in the future.

> QQ交流群：943577597

## Inter-communication ~~(supports multiple users)~~
By implementing a custom network protocol family, user space communication can be achieved both synchronously and asynchronously without relying on character devices or netlinks:
- No filesystem operations required
- Low overhead implementation without using kprobes for system call interception
- Uses stable kernel interfaces for improved maintainability

## Features

### Module Base Address Acquisition (`memory.h->get_module_base`)
Provides an alternative method to get module base addresses without reading `/proc/self/maps`, which may be monitored by anti-cheat software.

### Process Memory Operations

#### Virtual to Physical Address Translation (`memory.h->vaddr_to_phy_addr`)
Converts virtual addresses (VA) to physical addresses (PA) by:
- Traversing page table hierarchy (PGD -> P4D -> PUD -> PMD -> PTE)
- Handling page table folding and huge pages
- Computing final physical address using page frame number and offset

#### Memory Read/Write Operations
Two implementations available:
- `memory.h->rw_process_memory`: Custom implementation using page table traversal and physical address mapping
- `memory.h->access_process_vm_by_pid`: Utilizes kernel's built-in `access_process_vm` function for direct process memory access

### Root Privilege Escalation (`kkit.h->mark_pid_root`) (Deprecated)
A stealthy approach to elevate process privileges by:
- Locating target process's `task_struct`
- Creating new credentials with root uid/gid (0)
- Directly modifying process credential pointer instead of using `commit_creds()`
- Avoiding root uid visibility in ps command output

### Fast Cross-Process Memory Remapping (`process_vaddr_to_pfn`, `remap_process_memory`)
An efficient approach for cross-process memory access by:
- Converting source process virtual address to physical page frame number (PFN)
- Directly remapping memory through page table manipulation
- Bypassing traditional system calls and memory copy operations
- Achieving 3ms per 100M operations vs 80ms/100k ops with traditional methods

Performance highlights:
- Direct page table access without syscalls
- 100M memory operations: ~3ms
- Traditional approach (ioremap): 80ms for 100k operations
- ~26,000x performance improvement over conventional methods

### Touch Event Simulation
Implements comprehensive touch event simulation through IOCTL interface with following capabilities:
- Touch event handling (`ovo_ioctl`):
    - Down events (`CMD_TOUCH_CLICK_DOWN`): Simulates finger press with pressure and position data
    - Up events (`CMD_TOUCH_CLICK_UP`): Handles touch release
    - Move events (`CMD_TOUCH_MOVE`): Processes continuous touch movement
- Event features:
    - Multi-touch support through slot management
    - Precise position control (X, Y coordinates)
    - Pressure simulation
    - Event pooling with overflow protection
- Implementation details:
    - Uses spinlock for thread-safe event handling
    - Implements proper error handling and user-space data validation
    - Efficient event caching through `input_event_cache`
    - Supports MT protocol for touch reporting

# CI Support
- [android-kernel-build-action](https://github.com/feicong/android-kernel-build-action/tree/main)

```

`action.yml`:

```yml
name: 'GKI Kernel Module Build Action'
description: 'An action to build Android GKI kernel modules.'

branding:
  icon: 'activity'
  color: 'blue'

inputs:
  tag:
    description: 'Specify the Android kernel version and tag to build for (e.g., android14-5.15-2024-05).'
    default: 'android14-5.15-2024-05'
    required: true
  simple-tag:
    description: 'Simple Android kernel version and tag to build for (e.g., android14-5.15).'
    default: 'android14-5.15'
    required: true
  version:
    description: 'Kernel version. (e.g., 163)'
    required: true
  arch:
    description: 'Specify the architecture to build for (e.g., aarch64 or x86_64).'
    required: true
    default: 'aarch64'
  module-path:
    description: 'Specify the name of the kernel module artifact.'
    required: true
  module-name:
    description: 'Specify the name of the kernel module.'
    required: true
  fast_build:
    description: 'Enable LTO build?'
    required: true

runs:
  using: "composite"
  steps:
    - name: Download LKM Source Code
      uses: actions/download-artifact@v4
      with:
        name: ${{ inputs.module-path }}
        path: ${{ inputs.module-name }}

    - name: Validate Input
      shell: bash
      run: |
        VALID_TAGS=("android12-5.10" "android13-5.10" "android13-5.15" "android14-5.15" "android14-6.1" "android15-6.6" "android16-6.12")
        if [[ ! " ${VALID_TAGS[@]} " =~ " ${{ inputs.simple-tag }} " ]]; then
          echo "Invalid tag specified: ${{ inputs.simple-tag }}. Must be one of: ${VALID_TAGS[@]}"
          exit 1
        fi
        if [ ! -d "${{ inputs.module-name }}" ]; then
          echo "Invalid module-name: Directory ${{ inputs.module-name }} does not exist."
          exit 2
        fi
        tree -f .
        if [ ! -f "${{ inputs.module-name }}/Makefile" ]; then
          echo "${{ inputs.module-name }}/Makefile does not exist."
          exit 3
        fi
        if [ ! -f "${{ inputs.module-name }}/${{ inputs.module-name }}.c" ]; then
          echo "Warning: ${{inputs.module-name}}/${{inputs.module-name}}.c does not exist."
        fi

    - name: Install Build Tools
      uses: awalsh128/cache-apt-pkgs-action@latest
      with:
        packages: binutils git ccache automake flex lzop bison gperf build-essential zip curl zlib1g-dev libxml2-utils bzip2 libbz2-dev libbz2-1.0 libghc-bzlib-dev squashfs-tools pngcrush schedtool dpkg-dev liblz4-tool make optipng maven libssl-dev pwgen libswitch-perl policycoreutils minicom libxml-sax-base-perl libxml-simple-perl bc libx11-dev libgl1-mesa-dev xsltproc unzip device-tree-compiler python3 libelf-dev binutils-aarch64-linux-gnu gcc gzip
        version: 1.0

    - name: Setup Android Kernel Source Code
      shell: bash
      run: |
        sudo apt-get install -y repo
        mkdir android-kernel
        df -h android-kernel
        cd android-kernel
        repo init --depth=1 --u https://android.googlesource.com/kernel/manifest -b common-${{ inputs.tag }} --repo-rev=v2.16
        REMOTE_BRANCH=$(git ls-remote https://android.googlesource.com/kernel/common ${{ inputs.tag }})
        if grep -q deprecated <<< $REMOTE_BRANCH; then
          echo "Warning: Found deprecated branch: ${{ inputs.tag }}"
        fi
        repo --version
        repo sync -c -j$(nproc) --no-tags
        df -h

    - name: Setup CCache
      uses: actions/cache@v4
      with:
        path: ~/.ccache-${{ inputs.tag }}
        key: gki-kernel-${{ inputs.tag }}-cache
        max-size: 2G

    - name: Setup Kernel Module
      shell: bash
      run: |
        tree -f ${{ inputs.module-name }}

        echo "[+] Kernel Module setup"
        GKI_ROOT=$GITHUB_WORKSPACE/android-kernel
        echo "[+] GKI_ROOT: $GKI_ROOT"
        echo "[+] Copy driver to $GKI_ROOT/common/drivers"
        mv ${{ inputs.module-name }} $GKI_ROOT/common/drivers/${{ inputs.module-name }}
        
        echo "[+] Add driver to Makefile"
        DRIVER_MAKEFILE=$GKI_ROOT/common/drivers/Makefile
        DRIVER_KCONFIG=$GKI_ROOT/common/drivers/Kconfig
        grep -q "${{ inputs.module-name }}" "$DRIVER_MAKEFILE" || printf "\nobj-m += ${{ inputs.module-name }}/\n" >> "$DRIVER_MAKEFILE"
        if [ -f $GITHUB_WORKSPACE/${{ inputs.module-name }}/Kconfig ]; then
          grep -q "${{ inputs.module-name }}" "$DRIVER_KCONFIG" || sed -i "/endmenu/i\\source \"drivers/${{ inputs.module-name }}/Kconfig\"" "$DRIVER_KCONFIG"
        fi
        # Ensure module Makefile exists
        if [ ! -f $GKI_ROOT/common/drivers/${{ inputs.module-name }}/Makefile ]; then
          echo "obj-m += ${{ inputs.module-name }}.o" > $GKI_ROOT/common/drivers/${{ inputs.module-name }}/Makefile
        fi

    - name: Setup for LKM
      shell: bash
      working-directory: android-kernel
      run: |
        pip install ast-grep-cli
        sudo apt-get install llvm-15 -y
        
        ast-grep -U -p '$$$ check_exports($$$) {$$$}' -r '' common/scripts/mod/modpost.c
        ast-grep -U -p 'check_exports($$$);' -r '' common/scripts/mod/modpost.c
        
        if [[ "${{ inputs.simple-tag }}" == "android14-5.15" ]]; then
          if [ "${{ inputs.arch }}" = "aarch64" ]; then
            ast-grep -U -p 'static bool module_imports_namespace($$$ARGS) { return $AAA; }' -r 'static __attribute__((unused)) bool module_imports_namespace($$$ARGS) { return $AAA; }' common/scripts/mod/modpost.c
            ast-grep -U -p 'static void check_for_gpl_usage($$$ARGS) { switch($A) {$$$B} }' -r 'static __attribute__((unused)) void check_for_gpl_usage($$$ARGS) { switch($A) {$$$B} }' common/scripts/mod/modpost.c
          fi
        fi
        
        if [ -f common/android/gki_aarch64_modules ]; then
          echo "drivers/${{ inputs.module-name }}/${{ inputs.module-name }}.ko" >> common/android/gki_aarch64_modules
        fi

        # bazel build, android14-5.15, android14-6.1 use bazel
        if [ ! -f build/build.sh ]; then
          sed -i 's/needs unknown symbol/Dont abort when unknown symbol/g' build/kernel/*.sh || echo "No unknown symbol scripts found"
          if [ -f common/modules.bzl ]; then
            sed -i "s/_COMMON_GKI_MODULES_LIST = \[/_COMMON_GKI_MODULES_LIST = \[ \"drivers\/${{ inputs.module-name }}\/${{ inputs.module-name }}.ko\",/g" common/modules.bzl
          fi
        else
          TARGET_FILE="build/kernel/build.sh"
          if [ ! -f "$TARGET_FILE" ]; then
            TARGET_FILE="build/build.sh"
          fi
          sed -i 's/needs unknown symbol/Dont abort when unknown symbol/g' $TARGET_FILE || echo "No unknown symbol in $TARGET_FILE"
          sed -i 's/if ! diff -u "\${KERNEL_DIR}\/\${MODULES_ORDER}" "\${OUT_DIR}\/modules\.order"; then/if false; then/g' $TARGET_FILE
          sed -i 's@\${ROOT_DIR}/build/abi/compare_to_symbol_list@echo@g' $TARGET_FILE
          sed -i 's/needs unknown symbol/Dont abort when unknown symbol/g' build/kernel/*.sh || echo "No unknown symbol scripts found"
        fi

    - name: Make working directory clean to avoid dirty
      shell: bash
      working-directory: android-kernel
      run: |
        repo status
        rm common/android/abi_gki_protected_exports_* || echo "No protected exports!"
        git config --global user.email "bot@github.actions.org"
        git config --global user.name "github.actions"
        cd common/ && git add -A && git commit -a -m "Add Kernel Module"
        repo status

    - name: LTO Build Kernel
      if: inputs.fast_build == 'true'
      shell: bash
      working-directory: android-kernel
      run: |
        
        if [[ "${{ inputs.simple-tag }}" == "android16-6.12" ]]; then
          if [ "${{ inputs.arch }}" = "aarch64" ]; then
            tools/bazel run --disk_cache=/home/runner/.cache/bazel --config=fast --lto=thin //common:kernel_aarch64_dist
          elif [ "${{ inputs.arch }}" = "x86_64" ]; then
            tools/bazel run --disk_cache=/home/runner/.cache/bazel --config=fast --lto=thin //common:kernel_x86_64_dist
          fi
        else
          if [ "${{ inputs.arch }}" = "aarch64" ]; then
            if [ -e build/build.sh ]; then
              LTO=thin BUILD_CONFIG=common/build.config.gki.aarch64 build/build.sh CC="/usr/bin/ccache clang"
            else
              tools/bazel run --disk_cache=/home/runner/.cache/bazel --config=fast --config=stamp --lto=thin //common:kernel_aarch64_dist -- --dist_dir=dist
            fi
          elif [ "${{ inputs.arch }}" = "x86_64" ]; then
            if [ -e build/build.sh ]; then
              LTO=thin BUILD_CONFIG=common/build.config.gki.x86_64 build/build.sh CC="/usr/bin/ccache clang"
            else
              tools/bazel run --disk_cache=/home/runner/.cache/bazel --config=fast --config=stamp --lto=thin //common:kernel_x86_64_dist -- --dist_dir=dist
            fi
          fi
        fi

    - name: Dev Build Kernel
      if: inputs.fast_build == 'false'
      shell: bash
      working-directory: android-kernel
      run: |
        if [[ "${{ inputs.simple-tag }}" == "android14-5.15" ]]; then
          tools/bazel run //common:db845c_abi_update_symbol_list
          tools/bazel run //common:kernel_aarch64_abi_update
          tools/bazel run //common:kernel_aarch64_abi_update -- --commit
        fi
        if [[ "${{ inputs.simple-tag }}" == "android16-6.12" ]]; then
          if [ "${{ inputs.arch }}" = "aarch64" ]; then
            tools/bazel run --disk_cache=/home/runner/.cache/bazel --config=fast --config=stamp --lto=none //common:kernel_aarch64_dist
          elif [ "${{ inputs.arch }}" = "x86_64" ]; then
            tools/bazel run --disk_cache=/home/runner/.cache/bazel --config=fast --config=stamp --lto=none //common:kernel_x86_64_dist
          fi
        else
          if [ "${{ inputs.arch }}" = "aarch64" ]; then
            if [ -e build/build.sh ]; then
              LTO=none BUILD_CONFIG=common/build.config.gki.aarch64 build/build.sh CC="/usr/bin/ccache clang"
            else
              tools/bazel run --disk_cache=/home/runner/.cache/bazel --config=fast --config=stamp --lto=none //common:kernel_aarch64_dist -- --dist_dir=dist
            fi
          elif [ "${{ inputs.arch }}" = "x86_64" ]; then
            if [ -e build/build.sh ]; then
              LTO=none BUILD_CONFIG=common/build.config.gki.x86_64 build/build.sh CC="/usr/bin/ccache clang"
            else
              tools/bazel run --disk_cache=/home/runner/.cache/bazel --config=fast --config=stamp --lto=none //common:kernel_x86_64_dist -- --dist_dir=dist
            fi
          fi
        fi

    - name: Prepare Artifacts
      shell: bash
      run: |
        if [[ "${{ inputs.simple-tag }}" == "android16-6.12" ]]; then
          if [ "${{ inputs.arch }}" = "aarch64" ]; then
            OUTDIR=android-kernel/out/kernel_aarch64/dist
          elif [ "${{ inputs.arch }}" = "x86_64" ]; then
            OUTDIR=android-kernel/out/kernel_x86_64/dist
          fi
        else
          OUTDIR=android-kernel/out/${{ inputs.simple-tag }}/dist
          if [ ! -e $OUTDIR ]; then
            OUTDIR=android-kernel/dist
          fi
        fi
        mkdir output
        ls -al $OUTDIR/
        cp $OUTDIR/*Image* ./output/
        cp $OUTDIR/${{ inputs.module-name }}.ko ./output/${{ inputs.simple-tag }}_${{ inputs.module-name }}.ko

    - name: Upload Kernel Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: Image-with-Modules-${{ inputs.version }}-${{ inputs.arch }}
        path: ./output/*
```

`client-sdk/hak.rs`:

```rs
use std::ffi::c_void;
use std::os::fd::{AsFd, AsRawFd, OwnedFd};
use anyhow::anyhow;
use std::mem::MaybeUninit;
use nix::errno::Errno;
use nix::{libc, NixPath};
use nix::libc::{c_int, free, getsockopt, ioctl, malloc, mmap, sockaddr_in, socklen_t};
use nix::sys::socket::{socket, AddressFamily, SockFlag, SockType};

pub struct Driver {
    sock: OwnedFd,
    verbose: bool,
}

fn driver_id() -> Result<OwnedFd, anyhow::Error> {
    let address_families = [
        AddressFamily::Decnet,
        AddressFamily::NetBeui,
        AddressFamily::Security,
        AddressFamily::Key,
        AddressFamily::Netlink,
        AddressFamily::Packet,
        AddressFamily::Ash,
        AddressFamily::Econet,
        AddressFamily::AtmSvc,
        AddressFamily::Rds,
        AddressFamily::Sna,
        AddressFamily::Irda,
        AddressFamily::Pppox,
        AddressFamily::Wanpipe,
        AddressFamily::Llc,
        AddressFamily::Can,
        AddressFamily::Tipc,
        AddressFamily::Bluetooth,
        AddressFamily::Iucv,
        AddressFamily::RxRpc,
        AddressFamily::Isdn,
        AddressFamily::Phonet,
        AddressFamily::Ieee802154,
        AddressFamily::Caif,
        AddressFamily::Alg,
        AddressFamily::Vsock,
    ];

    for af in address_families.iter() {
        match socket(
            *af,
            SockType::SeqPacket,
            SockFlag::empty(),
            None,
        ) {
            Ok(_) => {
                continue
            }
            Err(Errno::ENOKEY) => {
                match socket(
                    *af,
                    SockType::Raw,
                    SockFlag::empty(),
                    None,
                ) {
                    Ok(fd) => {
                        return Ok(fd);
                    }
                    Err(_) => continue,
                }
            }
            Err(_) => continue,
        }
    }
    Err(anyhow!("无法找到OVO协议族"))
}

#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum DriverFunctionRequest {
    GetProcessPid = 0,
    IsProcessAlivePid = 1,
    AttachProcess = 2,
    GetProcessModuleBase = 3,
    ReadProcessMemoryIoremap = 4,
    WriteProcessMemoryIoremap = 5,
    AccessProcessVm = 6,
    ReadProcessMemory = 7,
    WriteProcessMemory = 8,
    RemapMemory = 9,
}

#[repr(i32)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum DriverIoctlRequest {
    TouchClickUp = 1001,
    TouchClickDown = 1000,
    TouchSwipeStart = 1002,
    TouchSwipeMove = 1003,
    TouchSwipeEnd = 1004,
    TouchSwipeSoon = 1005,
    TouchMove = 1006,
}

#[repr(C)]
#[derive(Debug, Clone, Copy)]
struct OvOTouchBase {
    pub slot: c_int,
    pub x: c_int,
    pub y: c_int,
    pub pressure: c_int,
}

#[repr(C)]
#[derive(Debug, Clone, Copy)]
struct OvOTouchSoon {
    pub start: OvOTouchBase,
    pub end: OvOTouchBase,
}

impl Driver {
    pub fn new() -> Result<Self, anyhow::Error> {
        let sock = driver_id()?;
        let verbose = std::env::var("RUST_VERBOSE").unwrap_or_else(|_| "0".to_string()) == "1";
        Ok(Self {
            sock,
            verbose,
        })
    }

    pub fn verbose(&self) -> bool {
        self.verbose
    }

    pub fn get_process_pid(&self, package: &str) -> Result<i32, anyhow::Error> {
        unsafe {
            let mut data = malloc(package.len() + 1);
            std::ptr::copy_nonoverlapping(package.as_ptr(), data as *mut u8, package.len());
            let mut len: socklen_t = (package.len() + 1) as socklen_t;
            if getsockopt(
                self.sock.as_raw_fd(),
                len as i32,
                DriverFunctionRequest::GetProcessPid as i32,
                data,
                &mut len
            ) < 0 && Errno::last_raw() != 2033 {
                free(data);
                return Err(anyhow!("get process pid failed: {:?}", Errno::last()));
            }
            let pid = *(data as *const i32);
            free(data);
            Ok(pid)
        }
    }

    pub fn is_process_alive_pid(&self, pid: i32) -> bool {
        unsafe {
            let mut len: socklen_t = 0;
            if getsockopt(
                self.sock.as_raw_fd(),
                pid,
                DriverFunctionRequest::IsProcessAlivePid as i32,
                std::ptr::null_mut(),
                &mut len
            ) < 0 && Errno::last_raw() != 2033 {
                eprintln!("is process alive failed: {:?}", Errno::last());
                return false
            }
            len == 1
        }
    }

    pub fn attach_process(&self, pid: i32) -> bool {
        unsafe {
            let mut len: socklen_t = 0;
            if getsockopt(
                self.sock.as_raw_fd(),
                pid,
                DriverFunctionRequest::AttachProcess as i32,
                std::ptr::null_mut(),
                &mut len
            ) < 0 && Errno::last_raw() != 2033 {
                println!("attach process failed: {:?}", Errno::last());
                return false
            }
            true
        }
    }

    pub fn get_process_module_base(&self, module: &str, vm_flag: i32) -> Result<u64, anyhow::Error> {
        unsafe {
            let mut len: socklen_t = (module.len() + 1) as socklen_t;
            if len < 8 {
                len = 8
            }
            let mut data = malloc(len as usize);
            std::ptr::copy_nonoverlapping(module.as_ptr(), data as *mut u8, module.len());
            let mut len: socklen_t = (module.len() + 1) as socklen_t;
            if getsockopt(
                self.sock.as_raw_fd(),
                vm_flag,
                DriverFunctionRequest::GetProcessModuleBase as i32,
                data,
                &mut len
            ) < 0 && Errno::last_raw() != 2033 {
                free(data);
                return Err(anyhow!("get process module base failed: {:?}", Errno::last()));
            }
            let base = *(data as *const u64);
            free(data);
            Ok(base)
        }
    }

    pub fn read_process_memory_ioremap(&self, addr: u64, buffer: &mut [u8]) -> Result<usize, anyhow::Error> {
        if buffer.len() < 2 {
            return Err(anyhow!("invalid buffer size: {}", buffer.len()));
        }
        unsafe {
            let dest = buffer.as_mut_ptr() as *mut socklen_t;
            let ret = getsockopt(
                self.sock.as_raw_fd(),
                buffer.len() as i32,
                DriverFunctionRequest::ReadProcessMemoryIoremap as i32,
                addr as *mut c_void,
                dest
            );
            // if self.verbose {
            //     println!("read_process_memory_ioremap(0x{:X}, {}) -> {}, data: {:?}", addr, buffer.len(), ret, buffer);
            // }
            if ret < 0 && Errno::last_raw() != 2033 {
                return Err(anyhow!("read process memory ioremap failed: {:?}", Errno::last()));
            }
            Ok(buffer.len())
        }
    }

    pub fn read_vec(&self, addr: u64, size: usize) -> Result<Vec<u8>, anyhow::Error> {
        let mut ret = Vec::new();
        ret.resize(size, 0);
        self.read_process_memory_ioremap(addr, ret.as_mut_slice())?;
        Ok(ret)
    }

    pub fn read<T: Sized + Copy>(&self, addr: u64) -> Result<T, anyhow::Error> {
        if addr <= 0x1000 {
            return Err(anyhow!("invalid address: 0x{:X}", addr));
        }
        if size_of::<T>() == 0 {
            return Err(anyhow!("invalid size: {}", size_of::<T>()));
        }
        let vec = self.read_vec(addr, size_of::<T>())?;
        //println!("vec: {:?}, {}", vec, size_of::<T>());
        unsafe { Ok(*(vec.as_ptr() as *const T)) }
    }

    pub fn read_f32_vector(&self, addr: u64, size: usize) -> Result<Vec<f32>, anyhow::Error> {
        let mut ret = Vec::new();
        ret.resize(size, 0.0);
        self.read_process_memory_ioremap(addr, unsafe { std::slice::from_raw_parts_mut(ret.as_mut_ptr() as *mut u8, size_of::<f32>() * size) })?;
        Ok(ret)
    }

    /**
     * In some devices, an error may be triggered from BPF_CGROUP_RUN-REG_GETSOCKOPT when use read_via_uninit.
     * Although the memory has been successfully read, it still needs to return a errno to you!
     */
    pub fn read_via_uninit<T: Sized + Copy>(&self, addr: u64) -> Result<T, anyhow::Error> {
        let data = unsafe {
            let mut data = MaybeUninit::<T>::uninit();
            self.read_process_memory_ioremap(addr, std::slice::from_raw_parts_mut(data.as_mut_ptr() as *mut u8, size_of::<T>()))?;
            data.assume_init()
        };
        Ok(data)
    }

    /// 读取UE4的FString
    pub fn read_fstring(&self, addr: u64) -> Result<String, anyhow::Error> {
        let len = self.read::<u32>(addr + 8)? as usize;
        if len == 0 {
            return Ok("".to_string());
        }
        let player_name_private = self.read::<u64>(addr)?;
        let mut player_name = vec![];
        unsafe { self.read_to_utf8(player_name_private as *const u16, &mut player_name, len - 1)?; }
        String::from_utf8(player_name).map_err(|e| anyhow!("read fstring failed: {:?}", e))
    }

    pub unsafe fn read_to_utf8(&self, ptr: *const u16, buf: &mut Vec<u8>, length: usize) -> Result<(), anyhow::Error> {
        let mut temp_utf16 = ptr;
        let end = ptr.add(length);

        while temp_utf16 < end {
            let utf16_char = self.read::<u16>(temp_utf16 as u64)?;

            if utf16_char <= 0x007F {
                buf.push(utf16_char as u8);
            } else if utf16_char <= 0x07FF {
                buf.push(((utf16_char >> 6) | 0xC0) as u8);
                buf.push(((utf16_char & 0x3F) | 0x80) as u8);
            } else {
                buf.push(((utf16_char >> 12) | 0xE0) as u8);
                buf.push(((utf16_char >> 6 & 0x3F) | 0x80) as u8);
                buf.push(((utf16_char & 0x3F) | 0x80) as u8);
            }

            temp_utf16 = temp_utf16.add(1);
        }
        Ok(())
    }

    pub unsafe fn get_utf8(&self, buf: *mut u8, str: usize) -> Result<(), anyhow::Error> {
        let mut buf16 = [0u16; 16];
        self.read_process_memory_ioremap(str as u64, std::slice::from_raw_parts_mut(buf16.as_mut_ptr() as *mut u8, 28))?;

        let mut temp_utf16 = buf16.as_ptr();
        let mut temp_utf8 = buf;
        let utf8_end = temp_utf8.add(32);

        while temp_utf16 < buf16.as_ptr().add(28) {
            let utf16_char = *temp_utf16;

            if utf16_char <= 0x007F && temp_utf8.add(1) < utf8_end {
                *temp_utf8 = utf16_char as u8;
                temp_utf8 = temp_utf8.add(1);
            } else if utf16_char >= 0x0080 && utf16_char <= 0x07FF && temp_utf8.add(2) < utf8_end {
                *temp_utf8 = ((utf16_char >> 6) | 0xC0) as u8;
                *temp_utf8.add(1) = ((utf16_char & 0x3F) | 0x80) as u8;
                temp_utf8 = temp_utf8.add(2);
            } else if utf16_char >= 0x0800 && utf16_char <= 0xFFFF && temp_utf8.add(3) < utf8_end {
                *temp_utf8 = ((utf16_char >> 12) | 0xE0) as u8;
                *temp_utf8.add(1) = (((utf16_char >> 6) & 0x3F) | 0x80) as u8;
                *temp_utf8.add(2) = ((utf16_char & 0x3F) | 0x80) as u8;
                temp_utf8 = temp_utf8.add(3);
            } else {
                break;
            }
            temp_utf16 = temp_utf16.add(1);
        }
        Ok(())
    }

    pub fn write_process_memory_ioremap(&self, addr: u64, buffer: &[u8]) -> Result<usize, anyhow::Error> {
        unsafe {
            let dest = buffer.as_ptr() as *mut socklen_t;
            if getsockopt(
                self.sock.as_raw_fd(),
                buffer.len() as i32,
                DriverFunctionRequest::WriteProcessMemoryIoremap as i32,
                addr as *mut c_void,
                dest
            ) < 0 && Errno::last_raw() != 2033 {
                return Err(anyhow!("write process memory ioremap failed: {:?}", Errno::last()));
            }
            Ok(buffer.len())
        }
    }

    pub fn write_f32(&self, addr: u64, value: f32) -> Result<usize, anyhow::Error> {
        let mut buffer = Vec::new();
        buffer.resize(size_of::<f32>(), 0);
        unsafe {
            std::ptr::copy_nonoverlapping(&value as *const f32 as *const u8, buffer.as_mut_ptr(), size_of::<f32>());
        }
        self.write_process_memory_ioremap(addr, buffer.as_slice())
    }

    pub fn write_f32_vector(&self, addr: u64, value: &[f32]) -> Result<usize, anyhow::Error> {
        let mut buffer = Vec::new();
        buffer.resize(size_of::<f32>() * value.len(), 0);
        unsafe {
            std::ptr::copy_nonoverlapping(value.as_ptr() as *const u8, buffer.as_mut_ptr(), size_of::<f32>() * value.len());
        }
        self.write_process_memory_ioremap(addr, buffer.as_slice())
    }

    pub fn access_process_vm(&self, from: i32, from_addr: u64, to: i32, to_addr: u64, len: usize) -> Result<usize, anyhow::Error> {
        struct ReqAccessProcessVm {
            from: i32,
            from_addr: u64,
            to: i32,
            to_addr: u64,
            size: usize,
        }

        unsafe {
            let mut data_len: socklen_t = size_of::<ReqAccessProcessVm>() as socklen_t;
            let data = ReqAccessProcessVm {
                from,
                from_addr,
                to,
                to_addr,
                size: len,
            };
            if getsockopt(
                self.sock.as_raw_fd(),
                len as i32,
                DriverFunctionRequest::WriteProcessMemoryIoremap as i32,
                &data as *const ReqAccessProcessVm as *mut c_void,
                &mut data_len
            ) < 0 && Errno::last_raw() != 2033 {
                return Err(anyhow!("write process memory ioremap failed: {:?}", Errno::last()));
            }
            Ok(len)
        }
    }

    pub fn read_process_memory(&self, addr: u64, buffer: &mut [u8]) -> Result<usize, anyhow::Error> {
        unsafe {
            let dest = buffer.as_mut_ptr() as *mut socklen_t;
            if getsockopt(
                self.sock.as_raw_fd(),
                buffer.len() as i32,
                DriverFunctionRequest::ReadProcessMemory as i32,
                addr as *mut c_void,
                dest
            ) < 0 && Errno::last_raw() != 2033 {
                return Err(anyhow!("read process memory failed: {:?}", Errno::last()));
            }
            Ok(buffer.len())
        }
    }

    pub fn write_process_memory(&self, addr: u64, buffer: &[u8]) -> Result<usize, anyhow::Error> {
        unsafe {
            let dest = buffer.as_ptr() as *mut socklen_t;
            if getsockopt(
                self.sock.as_raw_fd(),
                buffer.len() as i32,
                DriverFunctionRequest::WriteProcessMemory as i32,
                addr as *mut c_void,
                dest
            ) < 0 && Errno::last_raw() != 2033 {
                return Err(anyhow!("write process memory failed: {:?}", Errno::last()));
            }
            Ok(buffer.len())
        }
    }

    pub unsafe fn remap_memory(&self, addr: u64, size: usize) -> Result<*mut c_void, anyhow::Error> {
         if getsockopt(
            self.sock.as_raw_fd(),
            size as i32,
            DriverFunctionRequest::RemapMemory as i32,
            addr as *mut c_void,
            addr as *mut socklen_t
        ) < 0 && Errno::last_raw() != 2033 {
            return Err(anyhow!("remap memory failed: {:?}", Errno::last()));
        }
        let buf = mmap(
            std::ptr::null_mut(),
            size,
            libc::PROT_READ | libc::PROT_WRITE,
            libc::MAP_PRIVATE | libc::MAP_ANONYMOUS,
            self.sock.as_raw_fd(),
            0,
        );
        if buf == libc::MAP_FAILED {
            return Err(anyhow!("remap memory failed: {:?}", Errno::last()));
        }
        Ok(buf)
    }

    pub fn touch_down(&self, slot: i32, x: i32, y: i32, pressure: i32) -> Result<(), anyhow::Error> {
        let click = OvOTouchBase {
            slot,
            x,
            y,
            pressure,
        };
        unsafe {
            if ioctl(
                self.sock.as_raw_fd(),
                DriverIoctlRequest::TouchClickDown as i32,
                &click as *const OvOTouchBase
            ) < 0 && Errno::last_raw() != 2033 {
                return Err(anyhow!("touch click down failed: {:?}", Errno::last()));
            }
        }
        Ok(())
    }

    pub fn touch_up(&self, slot: i32) -> Result<(), anyhow::Error> {
        let click = OvOTouchBase {
            slot,
            x: 0,
            y: 0,
            pressure: 0,
        };
        unsafe {
            if ioctl(
                self.sock.as_raw_fd(),
                DriverIoctlRequest::TouchClickUp as i32,
                &click as *const OvOTouchBase
            ) < 0 && Errno::last_raw() != 2033 {
                return Err(anyhow!("touch click up failed: {:?}", Errno::last()));
            }
        }
        Ok(())
    }

    pub fn long_click(&self, slot: i32, x: i32, y: i32, pressure: i32, duration: u64) -> Result<(), anyhow::Error> {
        unsafe {
            self.touch_down(slot, x, y, pressure)?;
            std::thread::sleep(std::time::Duration::from_millis(duration));
            self.touch_up(slot)?;
        }
        Ok(())
    }

    pub fn touch_move(&self, slot: i32, x: i32, y: i32, pressure: i32) -> Result<(), anyhow::Error> {
        let click = OvOTouchBase {
            slot,
            x,
            y,
            pressure,
        };
        unsafe {
            if ioctl(
                self.sock.as_raw_fd(),
                DriverIoctlRequest::TouchMove as i32,
                &click as *const OvOTouchBase
            ) < 0 && Errno::last_raw() != 2033 {
                return Err(anyhow!("touch_move failed: {:?}", Errno::last()));
            }
        }
        Ok(())
    }

    // pub fn swipe_start(&self, slot: i32, x: u32, y: u32, pressure: i32) -> Result<(), anyhow::Error> {
    //     unsafe {
    //         let click = OvOTouchBase {
    //             slot,
    //             x,
    //             y,
    //             pressure,
    //         };
    //         if ioctl(
    //             self.sock.as_raw_fd(),
    //             DriverIoctlRequest::TouchSwipeStart as i32,
    //             &click as *const OvOTouchBase
    //         ) < 0 && Errno::last_raw() != 2033 {
    //             return Err(anyhow!("swipe_start failed: {:?}", Errno::last()));
    //         }
    //     }
    //     Ok(())
    // }
    //
    // pub fn swipe_move(&self, slot: i32, x: u32, y: u32) -> Result<(), anyhow::Error> {
    //     unsafe {
    //         let click = OvOTouchBase {
    //             slot,
    //             x,
    //             y,
    //             pressure: 0,
    //         };
    //         if ioctl(
    //             self.sock.as_raw_fd(),
    //             DriverIoctlRequest::TouchSwipeMove as i32,
    //             &click as *const OvOTouchBase
    //         ) < 0 && Errno::last_raw() != 2033 {
    //             return Err(anyhow!("swipe_move failed: {:?}", Errno::last()));
    //         }
    //     }
    //     Ok(())
    // }
    //
    // pub fn swipe_end(&self, slot: i32) -> Result<(), anyhow::Error> {
    //     unsafe {
    //         let click = OvOTouchBase {
    //             slot,
    //             x: 0,
    //             y: 0,
    //             pressure: 0,
    //         };
    //         if ioctl(
    //             self.sock.as_raw_fd(),
    //             DriverIoctlRequest::TouchSwipeEnd as i32,
    //             &click as *const OvOTouchBase
    //         ) < 0 && Errno::last_raw() != 2033 {
    //             return Err(anyhow!("swipe_end failed: {:?}", Errno::last()));
    //         }
    //     }
    //     Ok(())
    // }
    //
    // pub fn swipe_soon(&self, slot: i32, x1: u32, y1: u32, x2: u32, y2: u32) -> Result<(), anyhow::Error> {
    //     unsafe {
    //         let click = OvOTouchSoon {
    //             start: OvOTouchBase {
    //                 slot,
    //                 x: x1,
    //                 y: y1,
    //                 pressure: 30,
    //             },
    //             end: OvOTouchBase {
    //                 slot,
    //                 x: x2,
    //                 y: y2,
    //                 pressure: 30,
    //             },
    //         };
    //         if ioctl(
    //             self.sock.as_raw_fd(),
    //             DriverIoctlRequest::TouchSwipeSoon as i32,
    //             &click as *const OvOTouchSoon
    //         ) < 0 && Errno::last_raw() != 2033 {
    //             return Err(anyhow!("swipe_soon failed: {:?}", Errno::last()));
    //         }
    //     }
    //     Ok(())
    // }
}

impl Drop for Driver {
    fn drop(&mut self) {
    }
}
```

`client-sdk/hakutaku.cpp`:

```cpp
#include "hakutaku.h"
#include <string>
#include <istream>
#include <iostream>
#include <sstream>
#include <cctype>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <linux/input.h>
#include <sys/mman.h>
#include <netdb.h>

struct req_access_process_vm {
    pid_t from;
    void __user* from_addr;
    pid_t to;
    void __user* to_addr;
    size_t size;
};

template <size_t N>
auto read_proc_file(pid_t pid, const char *name, char *dest) -> void {
    std::string file_path = "/proc/" + std::to_string(pid) + "/" + name;
    FILE* _fp = fopen(file_path.c_str(), "r");
    if (_fp != nullptr) {
        std::fgets(dest, N, _fp);
        std::fclose(_fp);
    } else {
        dest[0] = '\0';
    }
}

auto hak::get_process_list() -> std::vector<proc_stat> {
    std::vector<hak::proc_stat> list;
    auto *proc_dir = opendir("/proc");
    if (proc_dir == nullptr) {
        return {};
    }
    struct dirent* pid_file;
    char stat[256];
    while ((pid_file = readdir(proc_dir)) != nullptr) {
        if (pid_file->d_type != DT_DIR || ((std::isdigit(pid_file->d_name[0])) == 0)) {
            continue;
        }
        hak::proc_stat my_stat;
        pid_t pid = std::stoi(pid_file->d_name);
        read_proc_file<sizeof(stat)>(pid, "stat", stat);
        std::istringstream iss((std::string(stat)));
        iss >> my_stat.pid;
        iss >> my_stat.comm;
        iss >> my_stat.state;
        iss >> my_stat.ppid;
        if (my_stat.state == 'R' || my_stat.state == 'S' || my_stat.state == 'D') {
            list.push_back(my_stat);
        }
    }
    closedir(proc_dir);
    return std::move(list);
}

auto hak::get_pid_list() -> std::vector<pid_t> {
    std::vector<pid_t> list;
    auto *proc_dir = opendir("/proc");
    if (proc_dir == nullptr) {
        return {};
    }
    struct dirent* pid_file;
    char stat[256];
    while ((pid_file = readdir(proc_dir)) != nullptr) {
        if (pid_file->d_type != DT_DIR || ((std::isdigit(pid_file->d_name[0])) == 0)) {
            continue;
        }
        pid_t pid = std::stoi(pid_file->d_name);
        read_proc_file<sizeof(stat)>(pid, "stat", stat);
        std::istringstream iss((std::string(stat)));
        std::string token;
        for (int i = 0; i < 3; ++i) {
            iss >> token;
        }
        if (token == "R" || token == "S" || token == "D") {
            list.emplace_back(pid);
        }
    }
    closedir(proc_dir);
    return std::move(list);
}

auto hak::find_process(std::string_view package) -> pid_t {
    auto *proc_dir = opendir("/proc");
    if (proc_dir == nullptr) {
        return 0;
    }
    struct dirent* pid_file;
    char cmd_line[128];
    while ((pid_file = readdir(proc_dir)) != nullptr) {
        if (pid_file->d_type != DT_DIR || ((std::isdigit(pid_file->d_name[0])) == 0)) {
            continue;
        }
        pid_t pid = std::stoi(pid_file->d_name);
        read_proc_file<sizeof(cmd_line)>(pid, "cmdline", cmd_line);
        if (package == cmd_line) {
            pid_t p = std::stoi(pid_file->d_name);
            closedir(proc_dir);
            return p;
        }
    }
    closedir(proc_dir);
    return 0;
}

auto hak::get_module_base(pid_t pid, std::string_view module) -> uintptr_t {
    FILE *fp = nullptr;
    char *pch = nullptr;
    char filename[32];
    char line[512];
    uint64_t addr = 0;

    if (pid != -100)
        snprintf(filename, sizeof(filename), "/proc/%d/maps", pid);
    else
        snprintf(filename, sizeof(filename), "/proc/self/maps");

    if ( (fp = fopen(filename, "r")) == nullptr ){
        printf("open %s failed!\n", filename);
        return 0;
    }

    while ( fgets(line, sizeof(line), fp) ){
        if ( strstr(line, module.data()) ){
            pch = strtok(line, "-");
            addr = strtoull(pch, nullptr, 16);
            break;
        }
    }

    fclose(fp);
    return addr;
}

auto hak::driver::find_driver_id() -> int {
    int sock;
    for (int i = AF_DECnet; i < AF_MAX; ++i) {
        sock = socket(i, SOCK_SEQPACKET, 0);
        if (sock < 0) {
            if (errno == ENOKEY) {
                sock = socket(i, SOCK_RAW, 0);
                if (sock > 0) {
                    break;
                }
            } else {
                continue;
            }
        }
    }

    if (sock < 0) {
        return -1;
    } else {
        close(sock);
    }
    return sock;
}

bool hak::driver::active() const {
    return sock > 0;
}

bool hak::driver::is_verbose() const {
    return verbose;
}

hak::driver::driver() {
    for (int i = AF_DECnet; i < AF_MAX; ++i) {
        sock = socket(i, SOCK_SEQPACKET, 0);
        if (sock < 0) {
            if (errno == ENOKEY) {
                sock = socket(i, SOCK_RAW, 0);
                if (sock > 0) {
                    return;
                }
            } else {
                continue;
            }
        }
    }
    verbose = true;
}

hak::driver::~driver() {
    if (active()) {
        close(sock);
    }
}

pid_t hak::driver::get_process_pid(std::string_view package) {
    pid_t pid = 0;
    void* data = new char[package.size() + 1];
    socklen_t len = package.size() + 1;
    std::copy(package.begin(), package.end(), static_cast<char*>(data));
    if(getsockopt(sock, len, (int) GET_PROCESS_PID, data, &len) < 0 && errno != 2033) {
        std::cout << "get pid by driver failed: " << strerror(errno) << std::endl;
        goto out;
    }
    pid = *(pid_t*) data;

    out:
    delete[] ((char*) data);
    return pid;
}
//pid_t hak::driver::get_process_pid(const std::string &package) const {
//    pid_t pid = 0;
//    void* data = new char[package.size() + 1];
//    socklen_t len = package.size() + 1;
//    std::copy(package.begin(), package.end(), static_cast<char*>(data));
//    if(getsockopt(sock, len, (int) GET_PROCESS_PID, data, &len) < 0) {
//        std::cout << "get pid by driver failed: " << strerror(errno) << std::endl;
//        goto out;
//    }
//    pid = *(pid_t*) data;
//
//    out:
//    delete[] ((char*) data);
//    return pid;
//}

bool hak::driver::is_process_alive_pid(pid_t pid) const {
    socklen_t alive = 0;
    if(getsockopt(sock, pid, (int) IS_PROCESS_ALIVE_PID, NULL, &alive) < 0 && errno != 2033) {
        std::cout << "is_process_alive_pid failed: " << strerror(errno) << std::endl;
        return false;
    }
    return alive == 1;
}

int hak::driver::attach_process_pid(pid_t pid) const {
    socklen_t len = 0;
    if(getsockopt(sock, pid, (int) ATTACH_PROCESS, nullptr, &len) < 0 && errno != 2033) {
        std::cout << "attach process failed: " << strerror(errno) << std::endl;
        return -1;
    }
    return 0;
}

uintptr_t hak::driver::get_process_module_base(const std::string& module, int vm_flag) const {
    uintptr_t addr = 0;
    socklen_t len = module.size() + 1;
    if (len < 8) {
        len = 8;
    }
    char* data = new char[len];
    std::copy(module.begin(), module.end(), static_cast<char*>(data));
    if(getsockopt(sock, vm_flag, (int) GET_PROCESS_MODULE_BASE, data, &len) < 0 && errno != 2033) {
        std::cout << "get module base failed: " << strerror(errno) << std::endl;
        goto out;
    }
    addr = *(uintptr_t*) data;

    out:
    delete[] data;
    return addr;
}

// 读写10w次 70ms
size_t hak::driver::read_process_memory_ioremap(uintptr_t addr, void *buffer, size_t size) const {
    if(getsockopt(sock, size, (int) READ_PROCESS_MEMORY_IOREMAP, (void*) addr, (socklen_t*) buffer) < 0 && errno != 2033) {
        std::cout << "read process memory failed: " << strerror(errno) << std::endl;
        return 0;
    }
    return size;
}

size_t hak::driver::write_process_memory_ioremap(uintptr_t addr, void *buffer, size_t size) const {
    if(getsockopt(sock, size, (int) WRITE_PROCESS_MEMORY_IOREMAP, (void*) addr, (socklen_t*) buffer) < 0 && errno != 2033) {
        std::cout << "write process memory failed: " << strerror(errno) << std::endl;
        return 0;
    }
    return size;
}

// 读写10w次 220ms
int hak::driver::access_process_vm(pid_t from, uintptr_t from_addr, pid_t to, uintptr_t to_addr, size_t len) {
    req_access_process_vm req{};
    req.from = from;
    req.from_addr = (void*) from_addr;
    req.to = to;
    req.to_addr = (void*) to_addr;
    req.size = len;
    socklen_t data_len = sizeof(req);
    if(getsockopt(sock, len, (int) ACCESS_PROCESS_VM, &req, &data_len) < 0 && errno != 2033) {
        std::cout << "access process vm failed: " << strerror(errno) << std::endl;
        return -1;
    }
    return len;
}

size_t hak::driver::read_process_memory(uintptr_t addr, void *buffer, size_t size) const {
    if(getsockopt(sock, size, (int) READ_PROCESS_MEMORY, (void*) addr, (socklen_t*) buffer) < 0 && errno != 2033) {
        std::cout << "read process memory failed: " << strerror(errno) << std::endl;
        return 0;
    }
    return size;
}

size_t hak::driver::write_process_memory(uintptr_t addr, void *buffer, size_t size) const {
    if(getsockopt(sock, size, (int) WRITE_PROCESS_MEMORY, (void*) addr, (socklen_t*) buffer) < 0 && errno != 2033) {
        std::cout << "write process memory failed: " << strerror(errno) << std::endl;
        return 0;
    }
    return size;
}

int hak::driver::remap_memory(uintptr_t addr, size_t size, void **buffer) const {
    if(getsockopt(sock, size, (int) REMAP_MEMORY, (void*) addr, (socklen_t*) addr) < 0 && errno != 2033) {
        std::cout << "remap memory failed: " << strerror(errno) << std::endl;
        return -1;
    }

    auto* buf = mmap(nullptr, size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, sock, 0);
    if (buf == MAP_FAILED) {
        std::cout << "mmap failed: " << strerror(errno) << std::endl;
        return -1;
    }

    *buffer = buf;
    return 0;
}



```

`client-sdk/hakutaku.h`:

```h
#ifndef HAKUTAKU_H
#define HAKUTAKU_H

#include <sys/uio.h>
#include <filesystem>
#include <dirent.h>
#include <string>
#include <vector>
#include <list>

#define VM_READ		0x00000001	/* currently active flags */
#define VM_WRITE	0x00000002
#define VM_EXEC		0x00000004
#define VM_SHARED	0x00000008
//
//class VoidPtrWrapper {
//public:
//    VoidPtrWrapper() : ptr_(nullptr) {}
//    uintptr_t get_void_ptr_rs() const { return (uintptr_t)ptr_; }
//    void* get_void_ptr() const { return ptr_; }
//    void set_void_ptr(uintptr_t ptr) { ptr_ = (void*) ptr; }
//private:
//    void* ptr_;
//};
//
//std::shared_ptr<VoidPtrWrapper> create_void_ptr() {
//    return std::make_shared<VoidPtrWrapper>();
//}

namespace hak {
    // Process State
    struct proc_stat {
        pid_t pid;
        std::string comm;
        char state;
        pid_t ppid;
    };

    // Get process list
    auto get_process_list() -> std::vector<proc_stat>;

    // Get pid list
    auto get_pid_list() -> std::vector<pid_t>;

    /**
     * Read proc file
     * @param package
     * @return pid_t
     */
    auto find_process(std::string_view package) -> pid_t;

    // get module base
    auto get_module_base(pid_t pid, std::string_view module) -> uintptr_t;

    enum DRIVER_FUNCTION_REQUEST: int {
        GET_PROCESS_PID = 0,
        IS_PROCESS_ALIVE_PID = 1,
        ATTACH_PROCESS = 2,
        GET_PROCESS_MODULE_BASE = 3,
        READ_PROCESS_MEMORY_IOREMAP = 4,
        WRITE_PROCESS_MEMORY_IOREMAP = 5,
        ACCESS_PROCESS_VM = 6,
        READ_PROCESS_MEMORY = 7,
        WRITE_PROCESS_MEMORY = 8,
        REMAP_MEMORY = 9,
    };

    class driver {
    public:
        bool verbose; // Only for debug!!!!!

        driver();

        ~driver();

        bool active() const;

        bool is_verbose() const;

        /**
         * 获取进程PID
         * @param package
         * @return pid_t
         */
        pid_t get_process_pid(std::string_view package);
        //int32_t get_process_pid(const std::string& package) const;

        bool is_process_alive_pid(pid_t pid) const;

        /**
         * 无需附加进程读写进程内存 (缺页不会终止)
         * @param from
         * @param from_addr
         * @param to
         * @param to_addr
         * @param len
         * @return 读取的数据长度
         *
         * @note ESRCH 无效的PID
         * @note ENOMEM 内核内存不足
         * @note EIO 无效的地址/读取失败
         */
        int access_process_vm(pid_t from, uintptr_t from_addr, pid_t to, uintptr_t to_addr, size_t len);

        int attach_process_pid(pid_t pid) const;

        /**
         * 获取进程模块基址
         * @param module
         * @param vm_flag  VM_READ, VM_WRITE, VM_EXEC, VM_SHARED
         * @return
         */
        uintptr_t get_process_module_base(const std::string &module, int vm_flag) const;

        /**
         * 读写进程内存通过ioremap
         * @param addr
         * @param buffer
         * @param size
         * @return 读取的数据长度
         *
         * @note EFAULT 无效的目标地址/缺页
         * @note ESRCH 目标进程死亡
         * @note EACCES `buffer` 地址不合法
         */
        size_t read_process_memory_ioremap(uintptr_t addr, void* buffer, size_t size) const;
        size_t write_process_memory_ioremap(uintptr_t addr, void* buffer, size_t size) const;

        size_t read_process_memory(uintptr_t addr, void* buffer, size_t size) const;
        size_t write_process_memory(uintptr_t addr, void* buffer, size_t size) const;

        /**
         * 重新映射内存
         * @param addr
         * @param size
         * @param buffer
         * @return
         *
         * @warning 如果输入的地址对应的物理地址没有对齐会自动对齐以获取正确的pfn, 即向下对齐(丢弃低位)！
         * @warning（请确保输入的地址是对齐的）
         */
        int remap_memory(uintptr_t addr, size_t size, void** buffer) const;
    public:

    private:
        int sock;

        static auto find_driver_id() -> int;
    };
}

#endif //HAKUTAKU_H

```

`ovo/Makefile`:

```
MODULE = ovo

obj-m :=$(MODULE).o
$(MODULE)-objs += core.o
$(MODULE)-objs += mmuhack.o
$(MODULE)-objs += kkit.o
$(MODULE)-objs += peekaboo.o
$(MODULE)-objs += memory.o
$(MODULE)-objs += server.o
$(MODULE)-objs += touch.o
$(MODULE)-objs += vma.o
$(MODULE)-objs += addr_pfn_map.o

EXTRA_CFLAGS += -DHIDE_SELF_MODULE=0	# 是否在模块表中移除自己
EXTRA_CFLAGS += -DBUILD_REMAP=1	# 是否编译内存重映射API（不稳定）
EXTRA_CFLAGS += -DENABLE_REMAP2=0 # 是否使用新的REMAP接口（vmf_insert_pfn）
EXTRA_CFLAGS += -DINJECT_SYSCALLS=0	# 是否注入SYSCALL开启更多功能
EXTRA_CFLAGS += -DBIG_PAGE

EXTRA_CFLAGS += -O2                # 优化等级2
EXTRA_CFLAGS += -fvisibility=hidden  # 隐藏符号
EXTRA_CFLAGS += -fomit-frame-pointer # 省略帧指针
# EXTRA_CFLAGS += -g0 去除调试信息
EXTRA_CFLAGS += -fno-pic -fvisibility=hidden
EXTRA_CFLAGS += -fno-stack-protector

# ARM架构优化
EXTRA_CFLAGS += -march=armv8-a     # 适用于ARMv8架构
EXTRA_CFLAGS += -mtune=cortex-a53  # 针对Cortex-A53优化
#EXTRA_CFLAGS += -mfpu=neon-fp-armv8  # 使用NEON和VFP单元
#EXTRA_CFLAGS += -mfloat-abi=hard   # 硬件浮点

all:
	make -C $(KDIR) EXTRA_CFLAGS="$(EXTRA_CFLAGS)" M=$(PWD) modules

clean:
	make -C $(KDIR) M=$(PWD) clean
```

`ovo/addr_pfn_map.c`:

```c
//
// Created by fuqiuluo on 25-2-16.
//
#include "addr_pfn_map.h"

static const struct rhashtable_params addr_pfn_params = {
	.key_offset = offsetof(struct addr_pfn_map, addr),
	.head_offset = offsetof(struct addr_pfn_map, node),
	.key_len = sizeof(unsigned long),
	.automatic_shrinking = true,
};

static struct rhashtable addr_pfn_table;

int init_addr_pfn_map(void)
{
	return rhashtable_init(&addr_pfn_table, &addr_pfn_params);
}

int insert_addr_pfn(unsigned long addr, unsigned long pfn)
{
	struct addr_pfn_map *map;

	map = kzalloc(sizeof(*map), GFP_KERNEL);
	if (!map)
		return -ENOMEM;

	map->addr = addr;
	map->pfn = pfn;

	if (rhashtable_insert_fast(&addr_pfn_table, &map->node, addr_pfn_params) < 0) {
		kfree(map);
		return -EEXIST;
	}
	return 0;
}

unsigned long lookup_pfn(unsigned long addr)
{
	struct addr_pfn_map *map;

	map = rhashtable_lookup_fast(&addr_pfn_table, &addr, addr_pfn_params);
	return map ? map->pfn : 0;
}

int remove_addr_pfn(unsigned long addr)
{
	struct addr_pfn_map *map;

	map = rhashtable_lookup_fast(&addr_pfn_table, &addr, addr_pfn_params);
	if (map) {
		rhashtable_remove_fast(&addr_pfn_table, &map->node, addr_pfn_params);
		kfree(map);
		return 0;
	}
	return -ENOENT;
}

// void clear_addr_pfn_map(void)
// {
// 	destroy_addr_pfn_map();
// 	init_addr_pfn_map();
// }

void destroy_addr_pfn_map(void)
{
	rhashtable_destroy(&addr_pfn_table);
}

```

`ovo/addr_pfn_map.h`:

```h
//
// Created by fuqiuluo on 25-2-16.
//

#ifndef ADDR_PFN_MAP_H
#define ADDR_PFN_MAP_H

#include <linux/rhashtable.h>
#include <linux/slab.h>

struct addr_pfn_map {
    unsigned long addr;
    unsigned long pfn;
    struct rhash_head node;
};

int init_addr_pfn_map(void);

int insert_addr_pfn(unsigned long addr, unsigned long pfn);

unsigned long lookup_pfn(unsigned long addr);

int remove_addr_pfn(unsigned long addr);

void destroy_addr_pfn_map(void);
#endif //ADDR_PFN_MAP_H

```

`ovo/core.c`:

```c
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/syscalls.h>
#include <linux/string.h>
#include <linux/kprobes.h>
#include <linux/kallsyms.h>
#include <asm/unistd.h>
#include <linux/highuid.h>
#include <asm/tlbflush.h>
#include <asm/pgtable.h>
#include <linux/tty.h>
#include <linux/unistd.h>
#include <linux/proc_fs.h>
#include <linux/seq_file.h>
#include <linux/list.h>
#include <linux/pid.h>
#include <linux/rculist.h>
#include <linux/sched.h>
#include <linux/types.h>
#include <linux/uaccess.h>
#include <linux/pid_namespace.h>
#include <linux/slab.h>
#include <linux/init_task.h>
#include <linux/kobject.h>
#include <linux/sysfs.h>
#include <linux/fs.h>
#include <linux/device.h>
#include <linux/cdev.h>
#include <linux/random.h>

#include "kkit.h"
#include "peekaboo.h"
#include "server.h"
#include "touch.h"
#include "addr_pfn_map.h"

static int __init ovo_init(void) {
    int ret;

    cuteBabyPleaseDontCry();
    ret = 0;

    ret = init_server();
	if(ret) {
		return ret;
	}

	ret = init_input_dev();

	if (!ret) {
		init_addr_pfn_map();
	}

    return ret;
}

static void __exit ovo_exit(void) {
    exit_server();
	exit_input_dev();
	destroy_addr_pfn_map();
    pr_info("[ovo] goodbye!\n");
}

module_init(ovo_init);
module_exit(ovo_exit);

#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0))
MODULE_IMPORT_NS(VFS_internal_I_am_really_a_filesystem_and_am_NOT_a_driver);
#endif

MODULE_AUTHOR("fuqiuluo");
MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("https://github.com/fuqiuluo/ovo");
MODULE_VERSION("1.0.0");
```

`ovo/kkit.c`:

```c
//
// Created by fuqiuluo on 25-1-22.
//
#include <linux/kprobes.h>
#include "kkit.h"

int ovo_flip_open(const char *filename, int flags, umode_t mode, struct file **f) {
#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 10, 0))
    *f = filp_open(filename, flags, mode);
    return *f == NULL ? -2 : 0;
#else
    static struct file* (*reserve_flip_open)(const char *filename, int flags, umode_t mode) = NULL;

    if (reserve_flip_open == NULL) {
        reserve_flip_open = (struct file* (*)(const char *filename, int flags, umode_t mode))ovo_kallsyms_lookup_name("filp_open");
        if (reserve_flip_open == NULL) {
            return -1;
        }
    }

    *f = reserve_flip_open(filename, flags, mode);
    return *f == NULL ? -2 : 0;
#endif
}

int ovo_flip_close(struct file **f, fl_owner_t id) {
#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 10, 0))
    filp_close(*f, id);
    return 0;
#else
    static struct file* (*reserve_flip_close)(struct file **f, fl_owner_t id) = NULL;

    if (reserve_flip_close == NULL) {
        reserve_flip_close = (struct file* (*)(struct file **f, fl_owner_t id))ovo_kallsyms_lookup_name("filp_close");
        if (reserve_flip_close == NULL) {
            return -1;
        }
    }

    reserve_flip_close(f, id);
    return 0;
#endif
}

bool is_file_exist(const char *filename) {
    struct file* fp;

    if(ovo_flip_open(filename, O_RDONLY, 0, &fp) == 0) {
        if (!IS_ERR(fp)) {
            ovo_flip_close(&fp, NULL);
            return true;
        }
        return false;
    }

//    // int kern_path(const char *name, unsigned int flags, struct path *path)
//    struct path path;
//    if (kern_path(filename, LOOKUP_FOLLOW, &path) == 0) {
//        return true;
//    }

    return false;
}

unsigned long ovo_kallsyms_lookup_name(const char *symbol_name) {
#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 7, 0)
    typedef unsigned long (*kallsyms_lookup_name_t)(const char *name);

    static kallsyms_lookup_name_t lookup_name = NULL;
    if (lookup_name == NULL) {
        struct kprobe kp = {
                .symbol_name = "kallsyms_lookup_name"
        };

        if(register_kprobe(&kp) < 0) {
            return 0;
        }

        // 高版本一些地址符号不再导出，需要通过kallsyms_lookup_name获取
        // 但是kallsyms_lookup_name也是一个不导出的内核符号，需要通过kprobe获取
        lookup_name = (kallsyms_lookup_name_t) kp.addr;
        unregister_kprobe(&kp);
    }
    return lookup_name(symbol_name);
#else
    return kallsyms_lookup_name(symbol_name);
#endif
}

unsigned long *ovo_find_syscall_table(void) {
    unsigned long *syscall_table;
    syscall_table = (unsigned long*)ovo_kallsyms_lookup_name("sys_call_table");
    return syscall_table;
}

int mark_pid_root(pid_t pid) {
    static struct cred* (*my_prepare_creds)(void) = NULL;

    struct pid * pid_struct;
    struct task_struct *task;
    kuid_t kuid;
    kgid_t kgid;
    struct cred *new_cred;

    kuid = KUIDT_INIT(0);
    kgid = KGIDT_INIT(0);

    pid_struct = find_get_pid(pid);

    task = pid_task(pid_struct, PIDTYPE_PID);
    if (task == NULL){
        printk(KERN_ERR "[ovo] Failed to get current task info.\n");
        return -1;
    }

    if (my_prepare_creds == NULL) {
        my_prepare_creds = (void *) ovo_kallsyms_lookup_name("prepare_creds");
        if (my_prepare_creds == NULL) {
            printk(KERN_ERR "[ovo] Failed to find prepare_creds\n");
            return -1;
        }
    }

    new_cred = my_prepare_creds();
    if (new_cred == NULL) {
        printk(KERN_ERR "[ovo] Failed to prepare new credentials\n");
        return -ENOMEM;
    }
    new_cred->uid = kuid;
    new_cred->gid = kgid;
    new_cred->euid = kuid;
    new_cred->egid = kgid;

    // Dirty creds assignment so "ps" doesn't show the root uid!
    // If one uses commit_creds(new_cred), not only this would only affect
    // the current calling task but would also display the new uid (more visible).
    // rcu_assign_pointer is taken from the commit_creds source code (kernel/cred.c)
    rcu_assign_pointer(task->cred, new_cred);
    return 0;
}

int is_pid_alive(pid_t pid) {
    struct pid * pid_struct;
    struct task_struct *task;

    pid_struct = find_get_pid(pid);
    if (!pid_struct)
        return false;

    task = pid_task(pid_struct, PIDTYPE_PID);
    if (!task)
        return false;

    return pid_alive(task);
}

static int (*my_get_cmdline)(struct task_struct *task, char *buffer, int buflen) = NULL;

static void foreach_process(void (*callback)(struct ovo_task_struct *)) {
    struct task_struct *task;
    struct ovo_task_struct ovo_task;
    int ret = 0;

    if (my_get_cmdline == NULL) {
        my_get_cmdline = (void *) ovo_kallsyms_lookup_name("get_cmdline");
    }

    rcu_read_lock();
    for_each_process(task) {
        if (task->mm == NULL) {
            continue;
        }

        ovo_task = (struct ovo_task_struct) {
                .task = task,
                .cmdline_len = 0
        };

        memset(ovo_task.cmdline, 0, 256);
        if (my_get_cmdline != NULL) {
            ret = my_get_cmdline(task, ovo_task.cmdline, 256);
            if (ret < 0) {
                continue;
            }
            ovo_task.cmdline_len = ret;
        }

        callback(&ovo_task);
    }
    rcu_read_unlock();
}

pid_t find_process_by_name(const char *name) {
    struct task_struct *task;
    char cmdline[256];
	size_t name_len;
    int ret;

	name_len = strlen(name);
	if (name_len == 0) {
		pr_err("[ovo] process name is empty\n");
		return -2;
	}

    if (my_get_cmdline == NULL) {
        my_get_cmdline = (void *) ovo_kallsyms_lookup_name("get_cmdline");
		// It can be NULL, because there is a fix below if get_cmdline is NULL
    }

	// code from https://github.com/torvalds/linux/blob/master/kernel/sched/debug.c#L797
    rcu_read_lock();
    for_each_process(task) {
        if (task->mm == NULL) {
            continue;
        }

        cmdline[0] = '\0';
        if (my_get_cmdline != NULL) {
            ret = my_get_cmdline(task, cmdline, sizeof(cmdline));
        } else {
            ret = -1;
        }

        if (ret < 0) {
            // Fallback to task->comm
            pr_warn("[ovo] Failed to get cmdline for pid %d\n", task->pid);
            if (strncmp(task->comm, name, min(strlen(task->comm), name_len)) == 0) {
                rcu_read_unlock();
                return task->pid;
            }
        } else {
            if (strncmp(cmdline, name, min(name_len, strlen(cmdline))) == 0) {
                rcu_read_unlock();
                return task->pid;
            }
        }
    }

    rcu_read_unlock();
    return 0;
}

#if INJECT_SYSCALLS == 1
int hide_process(pid_t pid) {
    // TODO("没有必要实现这个东西")
    return 0;
}
#endif

```

`ovo/kkit.h`:

```h
//
// Created by fuqiuluo on 25-1-22.
//
#pragma GCC diagnostic ignored "-Wunused-function"

#ifndef OVO_KKIT_H
#define OVO_KKIT_H

#include <linux/fs.h>
#include <linux/namei.h>
#include <linux/version.h>

/// Kernel operation

unsigned long ovo_kallsyms_lookup_name(const char* symbol_name);

unsigned long * ovo_find_syscall_table(void);

/// ====================

/// File operation

int ovo_flip_open(const char *filename, int flags, umode_t mode, struct file **f);

int ovo_flip_close(struct file **f, fl_owner_t id);

bool is_file_exist(const char *filename);

/// ====================

/// Process operation

struct ovo_task_struct {
    struct task_struct *task;
    char cmdline[256];
    int cmdline_len;
};

int is_pid_alive(pid_t pid);

int mark_pid_root(pid_t pid);

static void foreach_process(void (*callback)(struct ovo_task_struct *));

pid_t find_process_by_name(const char *name);

#if INJECT_SYSCALLS == 1
int hide_process(pid_t pid);
#endif

/// ====================

#endif //OVO_KKIT_H

```

`ovo/memory.c`:

```c
//
// Created by fuqiuluo on 25-1-22.
//
#include "memory.h"

#include <linux/tty.h>
#include <linux/io.h>
#include <linux/mm.h>
#include <linux/memory.h>
#include <linux/slab.h>
#include <linux/uaccess.h>
#include <linux/version.h>
#include <asm/page.h>
#include <linux/pgtable.h>
#include <linux/vmalloc.h>
#include <linux/mman.h>

uintptr_t get_module_base(pid_t pid, char *name, int vm_flag) {
    struct pid *pid_struct;
    struct task_struct *task;
    struct mm_struct *mm;
    struct vm_area_struct *vma;
#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0))
    struct vma_iterator vmi;
#endif
    uintptr_t result;
	struct dentry *dentry;
	size_t name_len, dname_len;

    result = 0;

	name_len = strlen(name);
	if (name_len == 0) {
		pr_err("[ovo] module name is empty\n");
		return 0;
	}

    pid_struct = find_get_pid(pid);
    if (!pid_struct) {
		pr_err("[ovo] failed to find pid_struct\n");
        return 0;
    }

    task = get_pid_task(pid_struct, PIDTYPE_PID);
    put_pid(pid_struct);
    if (!task) {
		pr_err("[ovo] failed to get task from pid_struct\n");
        return 0;
    }

    mm = get_task_mm(task);
    put_task_struct(task);
    if (!mm) {
		pr_err("[ovo] failed to get mm from task\n");
        return 0;
    }

    MM_READ_LOCK(mm)

#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0))
    vma_iter_init(&vmi, mm, 0);
    for_each_vma(vmi, vma)
#else
        for (vma = mm->mmap; vma; vma = vma->vm_next)
#endif
    {
        if (vma->vm_file) {
			if (vm_flag && !(vma->vm_flags & vm_flag)) {
				continue;
			}
			dentry = vma->vm_file->f_path.dentry;
			dname_len = dentry->d_name.len;
			if (!memcmp(dentry->d_name.name, name, min(name_len, dname_len))) {
				result = vma->vm_start;
				goto ret;
			}
        }
    }

    ret:
    MM_READ_UNLOCK(mm)

    mmput(mm);
    return result;
}

uintptr_t get_module_base_bss(pid_t pid, char *name, int vm_flag) {
	// TODO
	return 0;
}

phys_addr_t vaddr_to_phy_addr(struct mm_struct *mm, uintptr_t va) {
    pte_t *ptep;
    phys_addr_t page_addr;
    uintptr_t page_offset;

#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0) && defined(OVO_0X202501232139)
    spinlock_t *ptlp;
#endif

    if (!mm) return 0;

#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0) && defined(OVO_0X202501232139)
    follow_pte(mm, va, &pte, &ptlp); // not export!
#else
    ptep = page_from_virt_user(mm, va);
#endif
	if (!ptep) {
		pr_err("[ovo] failed to get ptep from 0x%lx\n", va);
		return 0;
	}

    if (!pte_present(*ptep)) {
		pr_err("[ovo] pte not present\n");
        return 0;
    }

    page_offset = va & (PAGE_SIZE - 1);
#if defined(__pte_to_phys)
    page_addr = (phys_addr_t) __pte_to_phys(*ptep);
#elif defined(pte_pfn)
    page_addr = (phys_addr_t) (pte_pfn(*pte) << PAGE_SHIFT);
#else
#error unsupported kernel version：__pte_to_phys or pte_pfn
#endif

#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0) && defined(OVO_0X202501232139)
    pte_unmap_unlock(pte, ptlp);
#endif

    if (page_addr == 0) { // why?
		pr_err("[ovo] page_addr is 0\n");
        return 0;
    }

    return page_addr + page_offset;
}

static int pid_vaddr_to_phy(pid_t global_pid, void *addr, phys_addr_t* pa) {
	struct task_struct *task;
	struct mm_struct *mm;
	struct pid *pid_struct;

	pid_struct = find_get_pid(global_pid);
	if (!pid_struct) {
		pr_err("[ovo] failed to find pid_struct: %s\n", __func__);
		return -ESRCH;
	}

	task = get_pid_task(pid_struct, PIDTYPE_PID);
	put_pid(pid_struct);
	if(!task) {
		pr_err("[ovo] failed to get task from pid_struct: %s\n", __func__);
		return -ESRCH;
	}

	mm = get_task_mm(task);
	if (!mm) {
		pr_err("[ovo] failed to get mm from task: %s\n", __func__);
		return -ESRCH;
	}

	MM_READ_LOCK(mm)
	*pa = vaddr_to_phy_addr(mm, (uintptr_t)addr);
	MM_READ_UNLOCK(mm)
	mmput(mm);
	put_task_struct(task);

	if(*pa == 0) {
		return -EFAULT;
	}

	return 0;
}

int read_process_memory_ioremap(pid_t pid, void __user*addr, void __user*dest, size_t size) {
    phys_addr_t phy_addr;
    int ret;
    void* mapped;

	if (!addr) {
		pr_err("[ovo] addr is null: %s\n", __func__);
		return -EINVAL;
	}

	if (!access_ok(dest, size)) {
		pr_err("[ovo] access_ok failed: %s\n", __func__);
		return -EACCES;
	}

    ret = pid_vaddr_to_phy(pid, addr, &phy_addr);
	if (ret) {
		pr_err("[ovo] pid_vaddr_to_phy failed: %s\n", __func__);
		return ret;
	}

	if (!pfn_valid(__phys_to_pfn(phy_addr))) {
		pr_err("[ovo] pfn_valid failed: %s\n", __func__);
		return -EFAULT;
	}

	if (!IS_VALID_PHYS_ADDR_RANGE(phy_addr, size)) {
		pr_err("[ovo] IS_VALID_PHYS_ADDR_RANGE failed: %s, ptr = %p, size = %zu\n", __func__, (void *)phy_addr, size);
		return -EFAULT;
	}

    if (phy_addr){
        mapped = ioremap_cache(phy_addr, size);
		if (!mapped) {
			ret = -ENOMEM;
		} else if (copy_to_user(dest, mapped, size)) {
            ret = -EACCES;
        } else {
			ret = 0;
		}
        if (mapped) {
            iounmap(mapped);
        }
    } else {
		pr_err("[ovo] phy_addr is 0, %p, %s\n", (void *)phy_addr, __func__);
		ret = -EFAULT;
	}

	//pr_info("[ovo] read_process_memory_ioremap: %s, ret = %d\n", __func__, ret);
    return ret;
}

int write_process_memory_ioremap(pid_t pid, void __user*addr, void __user*src, size_t size) {
    phys_addr_t pa;
    int ret;
    void* mapped;

	if (!addr) {
		pr_err("[ovo] addr is null: %s\n", __func__);
		return -EINVAL;
	}

	if (!access_ok(src, size)) {
		return -EACCES;
	}

	ret = pid_vaddr_to_phy(pid, addr, &pa);
	if (ret) {
		pr_err("[ovo] pid_vaddr_to_phy failed: %s\n", __func__);
		return ret;
	}

    if (pa && pfn_valid(__phys_to_pfn(pa)) && IS_VALID_PHYS_ADDR_RANGE(pa, size)){
        // why not use kmap_atomic?
        // '/proc/vmstat' -> nr_isolated_anon & nr_isolated_file
        // There is a quantity limit, it will panic when used up!
        mapped = ioremap_cache(pa, size);
		if (!mapped) {
			ret = -ENOMEM;
		} else if (copy_from_user(mapped, src, size)) {
			ret = -EACCES;
		} else {
			ret = 0;
		}
        if (mapped) {
            iounmap(mapped);
        }
    }

    return ret;
}

int access_process_vm_by_pid(pid_t from, void __user*from_addr, pid_t to, void __user*to_addr, size_t size) {
    char __kernel *buf;
    int ret;
	struct task_struct *task;
	struct pid *pid_struct;

	pid_struct = find_get_pid(from);
	if (!pid_struct) {
		pr_err("[ovo] failed to find pid_struct(from): %s\n", __func__);
		return -ESRCH;
	}

	task = get_pid_task(pid_struct, PIDTYPE_PID);
	put_pid(pid_struct);
	if(!task) {
		pr_err("[ovo] failed to get task from pid_struct(from): %s\n", __func__);
		return -ESRCH;
	}

    buf = vmalloc(size);
    if (!buf) return -ENOMEM;

    ret = access_process_vm(task, (unsigned long) from_addr, buf, (int) size, 0);
    if (ret != size) {
        vfree(buf);
		put_task_struct(task);
        return -EIO;
    }
	put_task_struct(task);

	pid_struct = find_get_pid(to);
	if (!pid_struct) {
		pr_err("[ovo] failed to find pid_struct(to): %s\n", __func__);
		vfree(buf);
		return -ESRCH;
	}

	task = get_pid_task(pid_struct, PIDTYPE_PID);
	put_pid(pid_struct);
	if(!task) {
		pr_err("[ovo] failed to get task from pid_struct(to): %s\n", __func__);
		vfree(buf);
		return -ESRCH;
	}

    ret = access_process_vm(task, (unsigned long) to_addr, buf, (int) size, FOLL_WRITE);
    if (ret != size) {
        vfree(buf);
		put_task_struct(task);
        return -EIO;
    }

    vfree(buf);
	put_task_struct(task);
    return 0;
}

int read_process_memory(pid_t pid, void *addr, void *dest, size_t size) {
	phys_addr_t pa;
	int ret;
	void* mapped;

	if (!addr) {
		pr_err("[ovo] addr is null: %s\n", __func__);
		return -EINVAL;
	}

	if (!access_ok(dest, size)) {
		pr_err("[ovo] access_ok failed: %s\n", __func__);
		return -EACCES;
	}

	ret = pid_vaddr_to_phy(pid, addr, &pa);
	if (ret) {
		pr_err("[ovo] pid_vaddr_to_phy failed: %s\n", __func__);
		return ret;
	}

	if (pa && pfn_valid(__phys_to_pfn(pa)) && IS_VALID_PHYS_ADDR_RANGE(pa, size)){
		mapped = phys_to_virt(pa);
		if (!mapped) {
			ret = -ENOMEM;
		} else if (copy_to_user(dest, mapped, size)) {
			ret = -EACCES;
		} else {
			ret = 0;
		}
	}

	return ret;
}

int write_process_memory(pid_t pid, void *addr, void *src, size_t size) {
	phys_addr_t pa;
	int ret;
	void* mapped;

	if (!addr) {
		pr_err("[ovo] addr is null: %s\n", __func__);
		return -EINVAL;
	}

	if (!access_ok(src, size)) {
		return -EACCES;
	}

	ret = pid_vaddr_to_phy(pid, addr, &pa);
	if (ret) {
		pr_err("[ovo] pid_vaddr_to_phy failed: %s\n", __func__);
		return ret;
	}

	if (pa && pfn_valid(__phys_to_pfn(pa)) && IS_VALID_PHYS_ADDR_RANGE(pa, size)){
		mapped = phys_to_virt(pa);
		if (!mapped) {
			ret = -ENOMEM;
		} else if (copy_from_user(mapped, src, size)) {
			ret = -EACCES;
		} else {
			ret = 0;
		}
	}
	return ret;
}
```

`ovo/memory.h`:

```h
//
// Created by fuqiuluo on 25-1-22.
//

#ifndef OVO_MEMORY_H
#define OVO_MEMORY_H

#include <linux/sched.h>
#include <linux/mm.h>
#include <linux/version.h>

#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 11, 0)
#include <linux/sched/mm.h>
#include <linux/sched/task.h>
#endif

#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 8, 0))
#include <linux/mmap_lock.h>
#define MM_READ_LOCK(mm) mmap_read_lock(mm);
#define MM_READ_UNLOCK(mm) mmap_read_unlock(mm);
#else
#include <linux/rwsem.h>
#define MM_READ_LOCK(mm) down_read(&(mm)->mmap_sem);
#define MM_READ_UNLOCK(mm) up_read(&(mm)->mmap_sem);
#endif

#include "mmuhack.h"
#include "kkit.h"

#ifdef CONFIG_CMA
//#warning CMA is enabled!
#endif

#if !defined(ARCH_HAS_VALID_PHYS_ADDR_RANGE) || defined(MODULE)
static inline int memk_valid_phys_addr_range(phys_addr_t addr, size_t size)
{
	return addr + size <= __pa(high_memory);
}
#define IS_VALID_PHYS_ADDR_RANGE(x,y) memk_valid_phys_addr_range(x,y)
#else
#define IS_VALID_PHYS_ADDR_RANGE(x,y) valid_phys_addr_range(x,y)
#endif

#if !defined(min)
#define min(x, y) ({        \
typeof(x) _min1 = (x);  \
typeof(y) _min2 = (y);  \
(void) (&_min1 == &_min2); /* 类型检查 */ \
_min1 < _min2 ? _min1 : _min2; })
#endif

uintptr_t get_module_base(pid_t pid, char *name, int vm_flag);
uintptr_t get_module_base_bss(pid_t pid, char *name, int vm_flag);

phys_addr_t vaddr_to_phy_addr(struct mm_struct *mm, uintptr_t va);

// 读写进程内存
// 依赖于current，只能在进程上下文中调用
// 使用ioremap_cache去映射物理地址，然后copy_to_user
int read_process_memory_ioremap(pid_t pid, void __user* addr, void __user* dest, size_t size);
int write_process_memory_ioremap(pid_t pid, void __user* addr, void __user* src, size_t size);

// 读取进程内存（一定不能是设备内存）
// 通过直接映射区映射到内核虚拟地址空间
int read_process_memory(pid_t pid, void __user* addr, void __user* dest, size_t size);
int write_process_memory(pid_t pid, void __user* addr, void __user* src, size_t size);

// 读写进程内存
// 不依赖于current，可以在任何上下文中调用
// 使用access_process_vm去读写进程内存
int access_process_vm_by_pid(pid_t from, void __user* from_addr, pid_t to, void __user* to_addr, size_t size);

#endif //OVO_MEMORY_H

```

`ovo/mmuhack.c`:

```c
#include "mmuhack.h"
#include <linux/kallsyms.h>
#include <asm/tlbflush.h>
#include <asm/uaccess.h>
#include <asm/pgtable.h>
#include "kkit.h"
#include <linux/ftrace.h>
#include <asm/unistd.h>
#include <linux/unistd.h>
#include <linux/mm.h> // For PAGE_SIZE
#include <linux/version.h>
#include <linux/moduleloader.h>
#include <linux/stop_machine.h>

#if defined(CONFIG_ARM64) || defined(CONFIG_AARCH64)
#include <linux/pgtable.h>
#endif

static struct mm_struct *init_mm_ptr = NULL;

pte_t *page_from_virt_kernel(unsigned long addr) {
    pgd_t * pgd;
#if __PAGETABLE_P4D_FOLDED == 1
    p4d_t *p4d;
#endif
    pud_t *pudp, pud;
    pmd_t *pmdp, pmd;
    pte_t *ptep;

    if (addr & PAGE_SIZE - 1) {
        addr = addr + PAGE_SIZE & ~(PAGE_SIZE - 1);
    }

    if (!init_mm_ptr) {
        init_mm_ptr = (struct mm_struct *) ovo_kallsyms_lookup_name("init_mm");
    }

    pgd = pgd_offset(init_mm_ptr, addr);
    if (pgd_none(*pgd) || pgd_bad(*pgd)) {
        return NULL;
    }
    // return if pgd is entry is here

#if __PAGETABLE_P4D_FOLDED == 1
    p4d = p4d_offset(pgd, addr);
    if (p4d_none(*p4d) || p4d_bad(*p4d)) {
        return 0;
    }

    pudp = pud_offset(p4d, addr);
#else
    pudp = pud_offset(pgd, addr);
#endif
    pud = READ_ONCE(*pudp);
    if (pud_none(pud) || pud_bad(pud)) {
        return NULL;
    }

#if defined(pud_leaf)
    if (pud_leaf(pud))
        return (pte_t *)pudp;
#endif

    pmdp = pmd_offset(pudp, addr);
    pmd = READ_ONCE(*pmdp);
    if (pmd_none(pmd) || pmd_bad(pmd)) {
        return NULL;
    }

#if defined(pmd_leaf)
    if (pmd_leaf(pmd))
        return (pte_t *)pmdp;
#endif

    ptep = pte_offset_kernel(pmdp, addr);
    if (!ptep) {
        return NULL;
    }

    //pr_debug("[ovo] page_from_virt succes, virt (0x%lx), ptep @ %lx", (uintptr_t) addr, (uintptr_t) ptep);
    return ptep;
}

#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0) && defined(OVO_0X202501232117)
pte_t *page_from_virt_user(struct mm_struct *mm, unsigned long addr) {
    pte_t *pte;
    spinlock_t *ptlp;

    if (!mm) return NULL;

    follow_pte(mm, addr, &pte, &ptlp);

    //pte_unmap_unlock(pte, ptlp);

     //if (ptlp)
     //   spin_unlock(ptlp);
#error "OVO_0X202501232117"
    return pte;
}
#else
pte_t *page_from_virt_user(struct mm_struct *mm, unsigned long addr) {
    pgd_t * pgd;
#if __PAGETABLE_P4D_FOLDED == 1
    p4d_t *p4d;
#endif
    pud_t *pudp, pud;
    pmd_t *pmdp, pmd;
    pte_t *ptep;

    pgd = pgd_offset(mm, addr);
    if (pgd_none(*pgd) || pgd_bad(*pgd)) {
        return NULL;
    }
    // return if pgd is entry is here

#if __PAGETABLE_P4D_FOLDED == 1
    p4d = p4d_offset(pgd, addr);
    if (p4d_none(*p4d) || p4d_bad(*p4d)) {
        return 0;
    }

    pudp = pud_offset(p4d, addr);
#else
    pudp = pud_offset(pgd, addr);
#endif
    pud = READ_ONCE(*pudp);
    if (pud_none(pud) || pud_bad(pud)) {
        return NULL;
    }

#if defined(pud_leaf) && defined(BIG_PAGE)
    // 处理 PUD 级大页，直接操作 pud_val
    if (pud_leaf(pud)) {
        ptep = (pte_t *) pudp;
        goto ret;
    }
#endif

    pmdp = pmd_offset(pudp, addr);
    pmd = READ_ONCE(*pmdp);
    if (pmd_none(pmd) || pmd_bad(pmd)) {
        return NULL;
    }

#if defined(pmd_leaf) && defined(BIG_PAGE)
    if (pmd_leaf(pmd)) {
        ptep = (pte_t *) pmdp;
        goto ret;
    }
#endif

    ptep = pte_offset_kernel(pmdp, addr);
    if (!ptep) {
        return NULL;
    }

    ret:
    return ptep;
}
#endif

#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 19, 0)
static inline int my_set_pte_at(struct mm_struct *mm,
                                 uintptr_t __always_unused addr,
                                 pte_t *ptep, pte_t pte)
{
    typedef void (*f__sync_icache_dcache)(pte_t pteval);
    typedef void (*f_mte_sync_tags)(pte_t pte, unsigned int nr_pages);

    static f__sync_icache_dcache __sync_icache_dcache = NULL;
    static f_mte_sync_tags mte_sync_tags = NULL;

    if (__sync_icache_dcache == NULL) {
        __sync_icache_dcache = (f__sync_icache_dcache) ovo_kallsyms_lookup_name("__sync_icache_dcache");
    }

#if !defined(PTE_UXN)
#define PTE_UXN			(_AT(pteval_t, 1) << 54)	/* User XN */
#endif

#if !defined(pte_user_exec)
#define pte_user_exec(pte)	(!(pte_val(pte) & PTE_UXN))
#endif

	if (__sync_icache_dcache == NULL) {
		pr_warn("[ovo] symbol `__sync_icache_dcache` not found\n");
	} else {
		if (pte_present(pte) && pte_user_exec(pte) && !pte_special(pte))
                __sync_icache_dcache(pte);
	}

    /*
     * If the PTE would provide user space access to the tags associated
     * with it then ensure that the MTE tags are synchronised.  Although
     * pte_access_permitted() returns false for exec only mappings, they
     * don't expose tags (instruction fetches don't check tags).
     */
#if !defined(pte_tagged)
    #define pte_tagged(pte)		((pte_val(pte) & PTE_ATTRINDX_MASK) == \
    PTE_ATTRINDX(MT_NORMAL_TAGGED))
#endif

    if (system_supports_mte() && pte_access_permitted(pte, false) &&
        !pte_special(pte) && pte_tagged(pte)) {
        if (mte_sync_tags == NULL) {
            mte_sync_tags = (f_mte_sync_tags) ovo_kallsyms_lookup_name("mte_sync_tags");
        }
        if (mte_sync_tags == NULL) {
            pr_err("[ovo] symbol `mte_sync_tags` not found\n");
            return -2;
        }
        mte_sync_tags(pte, 1);
    }

#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
    __check_safe_pte_update(mm, ptep, pte);
    __set_pte(ptep, pte);
#else
    __check_racy_pte_update(mm, ptep, pte);
    set_pte(ptep, pte);
#endif
    return 0;
}
#endif


int protect_rodata_memory(unsigned nr) {
    pte_t pte;
    pte_t* ptep;
    uintptr_t addr;

    addr = (uintptr_t) ((uintptr_t) ovo_find_syscall_table() + nr & PAGE_MASK);
    ptep = page_from_virt_kernel(addr);

    if (!pte_valid(READ_ONCE(*ptep))) { // arm64
        printk(KERN_INFO "[ovo] failed to get ptep from 0x%lx\n", addr);
        return -2;
    }
    pte = READ_ONCE(*ptep);
    pte = pte_wrprotect(pte);
#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 19, 0)
    if(my_set_pte_at(init_mm_ptr, addr, ptep, pte) != 0) {
        return -1;
    }
#else
    set_pte_at(init_mm_ptr, addr, ptep, pte);
#endif

    //flush_icache_range(addr, addr + PAGE_SIZE);
    //__clean_dcache_area_pou(data_addr, sizeof(data));
    __flush_tlb_kernel_pgtable(addr); // arm64
    return 0;
}

int unprotect_rodata_memory(unsigned nr) {
    pte_t pte;
    pte_t* ptep;
    uintptr_t addr;

    addr = (uintptr_t) ((uintptr_t) ovo_find_syscall_table() + nr & PAGE_MASK);
    ptep = page_from_virt_kernel(addr);

    if (!pte_valid(READ_ONCE(*ptep))) {
        printk(KERN_INFO "[ovo] failed to get ptep from 0x%lx\n", addr);
        return -2;
    }
    pte = READ_ONCE(*ptep);

    // 如果pte_mkwrite_novma无法使用，换成下面这两行
    // pte = set_pte_bit(pte, __pgprot(PTE_WRITE));
    // pte = clear_pte_bit(pte, __pgprot(PTE_RDONLY));

#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 6, 0)
    pte = pte_mkwrite_novma(pte);
#else
    pte = pte_mkwrite(pte);
#endif

#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 19, 0)
    if(my_set_pte_at(init_mm_ptr, addr, ptep, pte) != 0) {
        return -1;
    }
#else
    set_pte_at(init_mm_ptr, addr, ptep, pte);
#endif
    __flush_tlb_kernel_pgtable(addr);
    return 0;
}


```

`ovo/mmuhack.h`:

```h
//
// Created by fuqiuluo on 25-1-22.
//

#ifndef OVO_MMUHACK_H
#define OVO_MMUHACK_H

#include <asm/pgtable.h>

pte_t *page_from_virt_kernel(unsigned long addr);

pte_t *page_from_virt_user(struct mm_struct * mm, unsigned long addr);

int protect_rodata_memory(unsigned nr);

int unprotect_rodata_memory(unsigned nr);

#endif //OVO_MMUHACK_H

```

`ovo/peekaboo.c`:

```c
//
// Created by fuqiuluo on 25-1-22.
//
#include "peekaboo.h"
#include <asm/tlbflush.h>
#include <asm/pgtable.h>
#include <linux/tty.h>
#include <linux/unistd.h>
#include <linux/proc_fs.h>
#include <linux/seq_file.h>
#include <linux/list.h>
#include <linux/pid.h>
#include <linux/rculist.h>
#include <linux/sched.h>
#include <linux/types.h>
#include <linux/uaccess.h>
#include <linux/pid_namespace.h>
#include <linux/slab.h>
#include <linux/init_task.h>
#include <linux/kobject.h>
#include <linux/sysfs.h>

#include "kkit.h"

void cuteBabyPleaseDontCry(void) {
    if (is_file_exist("/proc/sched_debug")) {
        remove_proc_entry("sched_debug", NULL);
    }

    if (is_file_exist("/proc/uevents_records")) {
        remove_proc_entry("uevents_records", NULL);
    }

#ifdef MODULE
    #if HIDE_SELF_MODULE == 1
    list_del(&THIS_MODULE->list); //lsmod,/proc/modules
    kobject_del(&THIS_MODULE->mkobj.kobj); // /sys/modules
    list_del(&THIS_MODULE->mkobj.kobj.entry); // kobj struct list_head entry
    #endif
#endif

#if HIDE_SELF_MODULE == 1
    // protocol disguise! A lie
    memcpy(THIS_MODULE->name, "nfc\0", 4);
    //remove_proc_entry("protocols", net->proc_net);
#endif
}

```

`ovo/peekaboo.h`:

```h
//
// Created by fuqiuluo on 25-1-22.
//

#ifndef OVO_PEEKABOO_H
#define OVO_PEEKABOO_H

void cuteBabyPleaseDontCry(void);

#endif //OVO_PEEKABOO_H

```

`ovo/server.c`:

```c
//
// Created by fuqiuluo on 25-2-3.
//
#pragma GCC diagnostic ignored "-Wdeclaration-after-statement"

#include "server.h"
#include <linux/init.h>
#include <linux/sched/mm.h>
#include <linux/sched/signal.h>
#include <linux/sched/task.h>
#include <linux/socket.h>
#include <linux/file.h>
#include <linux/uaccess.h>
#include <linux/net.h>
#include <linux/netdevice.h>
#include <linux/rculist.h>
#include <linux/vmalloc.h>
#include <net/busy_poll.h>
#include "kkit.h"
#include "memory.h"
#include "touch.h"
#include "vma.h"
#include "addr_pfn_map.h"

static int ovo_release(struct socket *sock) {
	struct sock *sk = sock->sk;

	if (!sk) {
		return 0;
	}

	struct ovo_sock *os = (struct ovo_sock *) ((char *) sock->sk + sizeof(struct sock));

	for (int i = 0; i < os->cached_count; i++) {
		if (os->cached_kernel_pages[i]) {
			free_page(os->cached_kernel_pages[i]);
		}
	}

	sock_orphan(sk);
	sock_put(sk);

	//pr_info("[ovo] OVO socket released!\n");
	return 0;
}

static __poll_t ovo_poll(struct file *file, struct socket *sock,
						 struct poll_table_struct *wait) {
	return 0;
}

static int ovo_setsockopt(struct socket *sock, int level, int optname,
						  sockptr_t optval, unsigned int optlen)
{
	switch (optname) {
		default:
			break;
	}

	return -ENOPROTOOPT;
}

__always_inline int ovo_get_process_pid(int len, char __user *process_name_user) {
	int err;
	pid_t pid;
	char* process_name;

	process_name = kmalloc(len, GFP_KERNEL);
	if (!process_name) {
		return -ENOMEM;
	}

	if (copy_from_user(process_name, process_name_user, len)) {
		err = -EFAULT;
		goto out_proc_name;
	}

	pid = find_process_by_name(process_name);
	if (pid < 0) {
		err = -ESRCH;
		goto out_proc_name;
	}

	err = put_user((int) pid, (pid_t*) process_name_user);
	if (err)
		goto out_proc_name;

	out_proc_name:
	kfree(process_name);
	return err;
}

__always_inline int ovo_get_process_module_base(int len, pid_t pid, char __user *module_name_user, int flag) {
	int err;
	char* module_name;

	module_name = kmalloc(len, GFP_KERNEL);
	if (!module_name) {
		return -ENOMEM;
	}

	if (copy_from_user(module_name, module_name_user, len)) {
		err = -EFAULT;
		goto out_module_name;
	}

	uintptr_t base = get_module_base(pid, module_name, flag);
	if (base == 0) {
		err = -ENAVAIL;
		goto out_module_name;
	}

	err = put_user((uintptr_t) base, (uintptr_t*) module_name_user);
	if (err)
		goto out_module_name;

	out_module_name:
	kfree(module_name);
	return err;
}

/*
 * Don't worry about why the varname here is wrong,
 * in fact, this operation is similar to using ContentProvider to interact with Xposed module in Android,
 * and that thing is also wrong!
 */
static int ovo_getsockopt(struct socket *sock, int level, int optname,
						  char __user *optval, int __user *optlen)
{
	struct sock* sk;
	struct ovo_sock* os;
	int len, alive, ret;
	unsigned long pfn;

	sk = sock->sk;
	if (!sk)
		return -EINVAL;
	os = ((struct ovo_sock*)((char *) sock->sk + sizeof(struct sock)));

	pr_debug("[ovo] getsockopt: %d\n", optname);
	switch (optname) {
		case REQ_GET_PROCESS_PID: {
			ret = ovo_get_process_pid(level, optval);
			if (ret) {
				pr_err("[ovo] ovo_get_process_pid failed: %d\n", ret);
			}
			break;
		}
		case REQ_IS_PROCESS_PID_ALIVE: {
			alive = is_pid_alive(level);
			if (put_user(alive, optlen)) {
				return -EAGAIN;
			}
			ret = 0;
			break;
		}
		case REQ_ATTACH_PROCESS: {
			if(is_pid_alive(level) == 0) {
				return -ESRCH;
			}
			os->pid = level;
			pr_info("[ovo] attached process: %d\n", level);
			ret = 0;
			break;
		}
		case REQ_ACCESS_PROCESS_VM: {
			if (get_user(len, optlen))
				return -EFAULT;

			if (len < sizeof(struct req_access_process_vm))
				return -EINVAL;

			struct req_access_process_vm req;
			if (copy_from_user(&req, optval, sizeof(struct req_access_process_vm)))
				return -EFAULT;

			ret = access_process_vm_by_pid(req.from, req.from_addr, req.to, req.to_addr, req.size);
			break;
		}
		default:
			ret = 114514;
			break;
	}

	if (ret <= 0) {
		// If negative values are not returned,
		// some checks will be triggered? but why?
		// It will change the return value of the function! I return 0, but it will return -1!?
		if(ret == 0) {
			return -2033;
		} else {
			return ret;
		}
	}

	// The following need to attach to a process!
	// u should check whether the attached process is legitimate
	if (os->pid <= 0 || is_pid_alive(os->pid) == 0) {
		return -ESRCH;
	}

	switch (optname) {
		case REQ_GET_PROCESS_MODULE_BASE: {
			if (get_user(len, optlen))
				return -EFAULT;

			if (len < 0)
				return -EINVAL;

			ret = ovo_get_process_module_base(len, os->pid, optval, level);
			break;
		}
		case REQ_READ_PROCESS_MEMORY_IOREMAP: {
			if((ret = read_process_memory_ioremap(os->pid, (void *) optval, (void *) optlen, level))) {
				pr_debug("[ovo] read_process_memory_ioremap failed: %d\n", ret);
			}
			break;
		}
		case REQ_WRITE_PROCESS_MEMORY_IOREMAP: {
			ret = write_process_memory_ioremap(os->pid, (void *) optval, (void *) optlen, level);
			break;
		}
		case REQ_READ_PROCESS_MEMORY: {
			ret = read_process_memory(os->pid, (void *) optval, (void *) optlen, level);
			break;
		}
		case REQ_WRITE_PROCESS_MEMORY: {
			ret = write_process_memory(os->pid, (void *) optval, (void *) optlen, level);
			break;
		}
		case REMAP_MEMORY: {
			if (atomic_cmpxchg(&os->remap_in_progress, 0, 1) != 0)
				return -EBUSY;

			ret = process_vaddr_to_pfn(os->pid, optval, &pfn, level);
			if (!ret) {
				os->pfn = pfn;
			} else {
				atomic_set(&os->remap_in_progress, 0);
				os->pfn = 0;
			}

			break;
		}
		default:
			ret = 114514;
			break;
	}

	if (ret <= 0) {
		if(ret == 0) {
			return -2033;
		} else {
			return ret;
		}
	}

	return -EOPNOTSUPP;
}

int ovo_mmap(struct file *file, struct socket *sock,
				 struct vm_area_struct *vma) {
	int ret;
	struct ovo_sock *os;

	if (!sock->sk) {
		return -EINVAL;
	}
	os = (struct ovo_sock*)((char *) sock->sk + sizeof(struct sock));

	atomic_set(&os->remap_in_progress, 0);

	if (os->pid <= 0 || is_pid_alive(os->pid) == 0) {
		return -ESRCH;
	}

	if (!os->pfn) {
		return -EFAULT;
	}

	if (system_supports_mte()) {
		vm_flags_set(vma, VM_MTE);
	}
	vma->vm_page_prot = vm_get_page_prot(vma->vm_flags);
	//vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);

	ret = remap_process_memory(vma, os->pfn, vma->vm_end - vma->vm_start);
	if (!ret) {
		pr_err("[ovo] remap_process_memory failed: %d\n", ret);
	}
	return ret;
}

int ovo_ioctl(struct socket * sock, unsigned int cmd, unsigned long arg) {
	struct event_pool* pool;
	unsigned long flags;

	pool = get_event_pool();
	if (pool == NULL) {
		return -ECOMM;
	}

	struct touch_event_base __user* event_user = (struct touch_event_base __user*) arg;
	struct touch_event_base event;

	if(!event_user) {
		return -EBADR;
	}

	if (copy_from_user(&event, event_user, sizeof(struct touch_event_base))) {
		return -EACCES;
	}

	if (cmd == CMD_TOUCH_CLICK_DOWN) {
		spin_lock_irqsave(&pool->event_lock, flags);

		if (pool->size >= MAX_EVENTS) {
			pr_warn("[ovo] event pool is full!\n");
			pool->size = 0;
		}

		input_event_cache(EV_ABS, ABS_MT_SLOT, event.slot, 0);
		int id = input_mt_report_slot_state_with_id_cache(MT_TOOL_FINGER, 1, event.slot, 0);
		input_event_cache(EV_ABS, ABS_MT_POSITION_X, event.x, 0);
		input_event_cache(EV_ABS, ABS_MT_POSITION_Y, event.y, 0);
		input_event_cache(EV_ABS, ABS_MT_PRESSURE, event.pressure, 0);
		input_event_cache(EV_ABS, ABS_MT_TOUCH_MAJOR, event.pressure, 0);
		input_event_cache(EV_ABS, ABS_MT_TOUCH_MINOR, event.pressure, 0);

		event.pressure = id;
		if (copy_to_user(event_user, &event, sizeof(struct touch_event_base))) {
			pr_err("[ovo] copy_to_user failed: %s\n", __func__);
			return -EACCES;
		}

		spin_unlock_irqrestore(&pool->event_lock, flags);
		return -2033;
	}
	if (cmd == CMD_TOUCH_CLICK_UP) {
		spin_lock_irqsave(&pool->event_lock, flags);

		if (pool->size >= MAX_EVENTS) {
			pr_warn("[ovo] event pool is full!\n");
			pool->size = 0;
		}

		input_event_cache(EV_ABS, ABS_MT_SLOT, event.slot, 0);
		input_mt_report_slot_state_cache(MT_TOOL_FINGER, 0, 0);

		spin_unlock_irqrestore(&pool->event_lock, flags);
		return -2033;
	}
	if (cmd == CMD_TOUCH_MOVE) {
		spin_lock_irqsave(&pool->event_lock, flags);

		if (pool->size >= MAX_EVENTS) {
			pr_warn("[ovo] event pool is full!\n");
			pool->size = 0;
		}

		input_event_cache(EV_ABS, ABS_MT_SLOT, event.slot, 0);
		input_event_cache(EV_ABS, ABS_MT_POSITION_X, event.x, 0);
		input_event_cache(EV_ABS, ABS_MT_POSITION_Y, event.y, 0);
		input_event_cache(EV_SYN, SYN_MT_REPORT, 0, 0);

		spin_unlock_irqrestore(&pool->event_lock, flags);
		return -2033;
	}

	if (cmd == CMD_COPY_PROCESS) {
		if (!sock->sk) {
			return -EINVAL;
		}
		const struct ovo_sock *os = (struct ovo_sock *) ((char *) sock->sk + sizeof(struct sock));
		if (os->pid == 0) {
			return -ESRCH;
		}

		struct copy_process_args args;
		if (copy_from_user(&args, (struct copy_process_args __user*) arg, sizeof(struct copy_process_args))) {
			return -EACCES;
		}

		struct kernel_clone_args clone_args = {0};
		clone_args.flags = CLONE_VM | CLONE_THREAD | CLONE_SIGHAND | CLONE_FILES;  // 共享地址空间等资源
		clone_args.stack = 0;
		clone_args.stack_size = 0;
		clone_args.fn = args.fn;
		clone_args.fn_arg = args.arg;
		clone_args.tls = 0;
		clone_args.exit_signal = 0;

		struct pid *pid_struct = find_get_pid(os->pid);
		int node = numa_node_id();

		static struct task_struct *(*my_copy_process)(struct pid *pid, int trace, int node,
				 struct kernel_clone_args *args) = NULL;
		if (my_copy_process == NULL) {
			my_copy_process = (void*) ovo_kallsyms_lookup_name("copy_process");
		}

		if (my_copy_process == NULL) {
			pr_err("[ovo] copy_process not found!\n");
			return -EFAULT;
		}

		struct task_struct *new_task = my_copy_process(pid_struct, 0, node, &clone_args);
		put_pid(pid_struct);

		if (!new_task) {
			pr_err("[ovo] copy_process failed!\n");
			return -EFAULT;
		}

		return -2033;
	}

	if (cmd == CMD_PROCESS_MALLOC) {
		if (!sock->sk) {
			return -EINVAL;
		}

		struct ovo_sock *os = (struct ovo_sock *) ((char *) sock->sk + sizeof(struct sock));
		if (os->pid == 0) {
			return -ESRCH;
		}

		int writable = 0;
		if (get_user(writable, (int*) arg)) {
			return -EACCES;
		}

		if (os->cached_count >= MAX_CACHE_KERNEL_ADDRESS_COUNT) {
			pr_err("[ovo] cached_addr_array is full!\n");
			return -ENOMEM;
		}

		if (atomic_cmpxchg(&os->remap_in_progress, 0, 1) != 0)
			return -EBUSY;

		struct pid *pid_struct = find_get_pid(os->pid);
		if (!pid_struct) {
			pr_err("[ovo] failed to find pid_struct: %s\n", __func__);
			return -ESRCH;
		}

		struct task_struct *task = get_pid_task(pid_struct, PIDTYPE_PID);
		put_pid(pid_struct);
		if(!task) {
			pr_err("[ovo] failed to get task from pid_struct: %s\n", __func__);
			return -ESRCH;
		}

		struct mm_struct *mm = get_task_mm(task);
		put_task_struct(task);
		if (!mm) {
			pr_err("[ovo] failed to get mm from task: %s\n", __func__);
			return -ESRCH;
		}

		MM_READ_LOCK(mm)
		unsigned long addr = 0;
		get_unmapped_area_mm(mm, &addr, PAGE_SIZE);

		if (addr == 0) {
			MM_READ_UNLOCK(mm)
			mmput(mm);
			atomic_set(&os->remap_in_progress, 0);
			pr_err("[ovo] get_unmapped_area_mm failed: %s\n", __func__);
			return -ENOMEM;
		}

		if (alloc_process_special_memory_mm(mm, addr, PAGE_SIZE, writable)) {
			MM_READ_UNLOCK(mm)
			mmput(mm);
			atomic_set(&os->remap_in_progress, 0);
			pr_err("[ovo] alloc_process_special_memory_mm failed: %s\n", __func__);
			return -ENOMEM;
		}

		MM_READ_UNLOCK(mm)
		mmput(mm);

		unsigned long kaddr = get_zeroed_page(GFP_KERNEL);
		if (!kaddr) {
			pr_err("[ovo] kmalloc failed!: %s\n", __func__);
			atomic_set(&os->remap_in_progress, 0);
			return -ENOMEM;
		}

		if (put_user(addr, (unsigned long __user*) arg)
			|| put_user((unsigned long) PAGE_SIZE, (unsigned long __user*) (arg + sizeof(unsigned long)))) {
			free_page(kaddr);
			atomic_set(&os->remap_in_progress, 0);
			return -EACCES;
		}

		unsigned long pfn = __phys_to_pfn(__virt_to_phys(kaddr));
		if (insert_addr_pfn(addr, pfn) < 0) {
			free_page(kaddr);
			atomic_set(&os->remap_in_progress, 0);
			return -EEXIST;
		}

		os->cached_kernel_pages[os->cached_count++] = kaddr;
		os->pfn = pfn;

		pr_info("[ovo] malloced kernel address: 0x%lx, pfn: 0x%lx, magic: 0x%lx\n", kaddr, pfn, *(unsigned long*) kaddr);
		return -2033;
	}

	if (cmd == CMD_HIDE_VMA) {
		if (!sock->sk) {
			return -EINVAL;
		}

		struct ovo_sock *os = (struct ovo_sock *) ((char *) sock->sk + sizeof(struct sock));
		if (os->pid == 0) {
			return -ESRCH;
		}

		struct hide_vma_args args;
		if (copy_from_user(&args, (struct hide_vma_args __user*) arg, sizeof(struct hide_vma_args))) {
			pr_err("[ovo] copy_from_user failed: %s\n", __func__);
			return -EACCES;
		}

		struct vm_area_struct *vma = find_vma_pid(os->pid, args.ptr);
		if (!vma) {
			return -ESRCH;
		}

		if (args.mode == HIDE_X) {
			vm_flags_clear(vma, VM_EXEC);
		} else {
			pr_warn("[ovo] hide mode not supported!\n");
			return -ENOSYS;
		}

		return -2033;
	}

	return -ENOTTY;
}

int ovo_sendmsg(struct socket *sock, struct msghdr *m,
                size_t total_len
) {
	return 0;
}

static struct proto ovo_proto = {
	.name = "NFC_LLCP",
	.owner = THIS_MODULE,
	.obj_size = sizeof(struct sock) + sizeof(struct ovo_sock),
};

static struct proto_ops ovo_proto_ops = {
	.family = PF_DECnet,
	.owner = THIS_MODULE,
	.release = ovo_release,
	.bind = sock_no_bind,
	.connect = sock_no_connect,
	.socketpair = sock_no_socketpair,
	.accept = sock_no_accept,
	.getname = sock_no_getname,
	.poll		= ovo_poll,
	.ioctl		= ovo_ioctl,
	.listen		= sock_no_listen,
	.shutdown	= sock_no_shutdown,
	.setsockopt	= ovo_setsockopt,
	.getsockopt	= ovo_getsockopt,
	.sendmsg	= ovo_sendmsg,
	.recvmsg	= sock_no_recvmsg,
	.mmap		= ovo_mmap
};

static int free_family = AF_DECnet;

static int ovo_create(struct net *net, struct socket *sock, int protocol,
					  int kern)
{
	uid_t caller_uid;
	struct sock *sk;
	struct ovo_sock *os;

	caller_uid = *((uid_t*) &current_cred()->uid);
	if (caller_uid != 0) {
		pr_warn("[ovo] Only root can create OVO socket!\n");
		return -EAFNOSUPPORT;
	}

	if (sock->type != SOCK_RAW) {
		//pr_warn("[ovo] a OVO socker must be SOCK_RAW!\n");
		return -ENOKEY;
	}

	sock->state = SS_UNCONNECTED;

	sk = sk_alloc(net, PF_INET, GFP_KERNEL, &ovo_proto, kern);
	if (!sk) {
		pr_warn("[ovo] sk_alloc failed!\n");
		return -ENOBUFS;
	}

	os = (struct ovo_sock*)((char *) sk + sizeof(struct sock));

	ovo_proto_ops.family = free_family;
	sock->ops = &ovo_proto_ops;
	sock_init_data(sock, sk);

	// Initialize the ovo_sock
	os->pid = 0;
	os->pfn = 0;
	atomic_set(&os->remap_in_progress, 0);
	os->cached_count = 0;

	return 0;
}

static struct net_proto_family ovo_family_ops = {
	.family = PF_DECnet,
	.create = ovo_create,
	.owner	= THIS_MODULE,
};

static int register_free_family(void) {
	int family;
	int err;
	for(family = free_family; family < NPROTO; family++) {
		ovo_family_ops.family = family;
		err = sock_register(&ovo_family_ops);
		if (err)
			continue;
		else {
			free_family = family;
			pr_info("[ovo] Find free proto_family: %d\n", free_family);
			return 0;
		}
	}

	pr_err("[ovo] Can't find any free proto_family!\n");
	return err;
}

int init_server(void) {
	int err;

	err = proto_register(&ovo_proto, 1);
	if (err)
		goto out;

	err = register_free_family();
	if (err)
		goto out_proto;

	return 0;

	sock_unregister(free_family);
	out_proto:
	proto_unregister(&ovo_proto);
	out:
	return err;
}

void exit_server(void) {
	sock_unregister(free_family);
	proto_unregister(&ovo_proto);
}
```

`ovo/server.h`:

```h
//
// Created by fuqiuluo on 25-2-3.
//

#ifndef OVO_SERVER_H
#define OVO_SERVER_H

#include <linux/completion.h>
#include <linux/bpf.h>
#include <linux/workqueue.h>
#include <linux/mutex.h>
#include <linux/spinlock.h>
#include <linux/mm.h>
#include <net/sock.h>
#include "vma.h"

#define MAX_CACHE_KERNEL_ADDRESS_COUNT 16

#define REQ_GET_PROCESS_PID 0
#define REQ_IS_PROCESS_PID_ALIVE 1
#define REQ_ATTACH_PROCESS	2
#define REQ_GET_PROCESS_MODULE_BASE	3
#define REQ_READ_PROCESS_MEMORY_IOREMAP	4
#define REQ_WRITE_PROCESS_MEMORY_IOREMAP 5
#define REQ_ACCESS_PROCESS_VM	6
#define REQ_READ_PROCESS_MEMORY	7
#define REQ_WRITE_PROCESS_MEMORY 8
#define REMAP_MEMORY 9

#define CMD_TOUCH_CLICK_DOWN 1000
#define CMD_TOUCH_CLICK_UP 1001
#define CMD_TOUCH_MOVE 1006
#define CMD_COPY_PROCESS 1007
#define CMD_PROCESS_MALLOC 1008
#define CMD_HIDE_VMA 1009

struct req_access_process_vm {
	pid_t from;
	void __user* from_addr;
	pid_t to;
	void __user* to_addr;
	size_t size;
};

struct touch_event_base {
	int slot;
	int x;
	int y;
	int pressure;
};

struct copy_process_args {
	void* fn;
	void* arg;
};

struct hide_vma_args {
	unsigned long ptr;
	enum hide_mode: int {
		HIDE_X =	0,
		HIDE_NAME = 1, // TODO
		HIDE_ADDR = 2, // TODO
	} mode;
};

// Note:an ovo_sock can only be mmap once
struct ovo_sock {
	pid_t pid;

	atomic_t remap_in_progress;
	unsigned long pfn;

	unsigned long cached_kernel_pages[MAX_CACHE_KERNEL_ADDRESS_COUNT];
	size_t cached_count;
};

int init_server(void);

void exit_server(void);

#endif //OVO_SERVER_H

```

`ovo/touch.c`:

```c
//
// Created by fuqiuluo on 25-2-9.
//
#pragma GCC diagnostic ignored "-Wdeclaration-after-statement"

#include "touch.h"
#include <linux/mutex.h>
#include <linux/input/mt.h>
#include <linux/kprobes.h>
#include <linux/version.h>
#include <linux/input-event-codes.h>
#include "kkit.h"

static inline int is_event_supported(unsigned int code,
									 unsigned long *bm, unsigned int max)
{
	return code <= max && test_bit(code, bm);
}

int get_last_driver_slot(struct input_dev* dev) {
	int slot;
	int new_slot;
	struct input_mt *mt;
	int is_new_slot;

	if(!dev) {
		pr_err("[ovo] wtf? dev is null\n");
		return -114;
	}

	is_new_slot = 0;
	mt = dev->mt;
	if (mt)
		new_slot = mt->slot;
	else
		new_slot = -999;

	if (dev->absinfo != NULL)
		slot = dev->absinfo[ABS_MT_SLOT].value;
	else
		slot = -999;

	if(new_slot == -999 && slot == -999) {
		return -114;
	}

	if(slot == -999) {
		return new_slot;
	}

	if(new_slot == -999) {
		return slot;
	}

	is_new_slot = new_slot != slot;
	return is_new_slot ? new_slot : slot;
}

static void (*my_input_handle_event)(struct input_dev *dev,
							   unsigned int type, unsigned int code, int value) = NULL;

int input_event_no_lock(struct input_dev *dev,
				 unsigned int type, unsigned int code, int value)
{
	if(my_input_handle_event == NULL) {
		my_input_handle_event = (void (*)(struct input_dev *, unsigned int, unsigned int, int))ovo_kallsyms_lookup_name("input_handle_event");
	}

	if (!my_input_handle_event) {
		pr_err("[ovo] Holy fuck!Failed to find input_handle_event\n");
		return -1;
	}

	if (is_event_supported(type, dev->evbit, EV_MAX)) {
		my_input_handle_event(dev, type, code, value);
	}

	return 0;
}

struct input_dev* find_touch_device(void) {
	static struct input_dev* CACHE = NULL;

	if (CACHE != NULL) {
		return CACHE;
	}

	struct input_dev *dev;
	struct list_head *input_dev_list;
	struct mutex *input_mutex;

	input_dev_list = (struct list_head *)ovo_kallsyms_lookup_name("input_dev_list");
	input_mutex = (struct mutex *)ovo_kallsyms_lookup_name("input_mutex");
	if (!input_dev_list || !input_mutex) {
		printk(KERN_ERR "Failed to find symbols!\n");
		return NULL;
	}

	// /*
	// * input_mutex protects access to both input_dev_list and input_handler_list.
	// * This also causes input_[un]register_device and input_[un]register_handler
	// * be mutually exclusive which simplifies locking in drivers implementing
	// * input handlers.
	// */
	//static DEFINE_MUTEX(input_mutex);
	mutex_lock(input_mutex);

	list_for_each_entry(dev, input_dev_list, node) {
		if (test_bit(EV_ABS, dev->evbit) &&
			(test_bit(ABS_MT_POSITION_X, dev->absbit) || test_bit(ABS_X, dev->absbit))) {\
            pr_info("[ovo] Name: %s, Bus: %d Vendor: %d Product: %d Version: %d\n",
					dev->name,
					dev->id.bustype, dev->id.vendor,
					dev->id.product, dev->id.version);
			mutex_unlock(input_mutex);
			CACHE = dev;
			return dev;
		}
	}

	mutex_unlock(input_mutex);
	return NULL;
}

static struct event_pool *pool = NULL;

struct event_pool * get_event_pool(void) {
	return pool;
}

int input_event_cache(unsigned int type, unsigned int code, int value, int lock) {
	if (!my_input_handle_event) {
		pr_err("[ovo] Failed to find input_handle_event\n");
		return -EINVAL;
	}

	unsigned long flags;
	if (lock)
		spin_lock_irqsave(&pool->event_lock, flags);
	if (pool->size >= MAX_EVENTS) {
		if (lock)
			spin_unlock_irqrestore(&pool->event_lock, flags);
		return -EFAULT;
	}
	struct ovo_touch_event* event = &pool->events[pool->size++];
	event->type = type;
	event->code = code;
	event->value = value;
	if (lock)
		spin_unlock_irqrestore(&pool->event_lock, flags);

	return 0;
}

int input_mt_report_slot_state_cache(unsigned int tool_type, bool active, int lock)
{
	if (!active) {
		input_event_cache(EV_ABS, ABS_MT_TRACKING_ID, -1, lock);
		return 0;
	}

	struct input_dev* dev = find_touch_device();
	struct input_mt *mt = dev->mt;
	struct input_mt_slot *slot;
	int id;

	if (!mt)
		return -1;

	if (mt->slot < 0 || mt->slot > mt->num_slots) {
		return -1;
	}
	slot = &mt->slots[mt->slot];

	id = input_mt_get_value(slot, ABS_MT_TRACKING_ID);
	if (id < 0)
		id = input_mt_new_trkid(mt);

	input_event_cache(EV_ABS, ABS_MT_TRACKING_ID, id, lock);
	input_event_cache(EV_ABS, ABS_MT_TOOL_TYPE, tool_type, lock);

	return id;
}

bool input_mt_report_slot_state_with_id_cache(unsigned int tool_type, bool active, int id, int lock)
{
	if (!active) {
		input_event_cache(EV_ABS, ABS_MT_TRACKING_ID, -1, lock);
		return false;
	}

	input_event_cache(EV_ABS, ABS_MT_TRACKING_ID, id, lock);
	input_event_cache(EV_ABS, ABS_MT_TOOL_TYPE, tool_type, lock);

	return true;
}

static void handle_cache_events(struct input_dev* dev) {
	struct input_mt *mt = dev->mt;
	struct input_mt_slot *slot;
	unsigned long flags, flags2;
	int id;

	if (!mt)
		return;

	if (mt->slot < 0 || mt->slot > mt->num_slots) {
		return;
	}
	slot = &mt->slots[mt->slot];

	spin_lock_irqsave(&pool->event_lock, flags2);
	if (pool->size == 0) {
		spin_unlock_irqrestore(&pool->event_lock, flags2);
		return;
	}
	spin_lock_irqsave(&dev->event_lock, flags);

	for (int i = 0; i < pool->size; ++i) {
		struct ovo_touch_event event = pool->events[i];

		if (event.type == EV_ABS &&
			event.code == ABS_MT_TRACKING_ID &&
			event.value == -114514) {
			id = input_mt_get_value(slot, ABS_MT_TRACKING_ID);
			if (id < 0)
				id = input_mt_new_trkid(mt);
			event.value = id;
		}

		input_event_no_lock(dev, event.type, event.code, event.value);
	}
	spin_unlock_irqrestore(&dev->event_lock, flags);
	pool->size = 0;
	spin_unlock_irqrestore(&pool->event_lock, flags2);
}

static int input_handle_event_handler_pre(struct kprobe *p,
										  struct pt_regs *regs)
{
	unsigned int type = (unsigned int)regs->regs[1];
//	unsigned int code = (unsigned int)regs->regs[2];
//	int value = (int)regs->regs[3];

	struct input_dev* dev = (struct input_dev*)regs->regs[0];
	if(!dev) {
		return 0;
	}

//	if (type == EV_ABS) {
//		pr_info("[ovo] input_event(%u, %u, %d)", type, code, value);
//	}

	if (type != EV_SYN) {
		return 0;
	}

	handle_cache_events(dev);
	return 0;
}

static struct kprobe input_event_kp = {
	.symbol_name = "input_event",
	.pre_handler = input_handle_event_handler_pre,
};

static int input_handle_event_handler2_pre(struct kprobe *p,
										  struct pt_regs *regs)
{
	unsigned int type = (unsigned int)regs->regs[1];
//	unsigned int code = (unsigned int)regs->regs[2];
//	int value = (int)regs->regs[3];

	struct input_handle* handle = (struct input_handle*)regs->regs[0];
	if(!handle) {
		return 0;
	}

//	if (type == EV_ABS) {
//		pr_info("[ovo] input_inject_event(%u, %u, %d)", type, code, value);
//	}

	if (type != EV_SYN) {
		return 0;
	}

	handle_cache_events(handle->dev);
	return 0;
}

static struct kprobe input_inject_event_kp = {
	.symbol_name = "input_inject_event",
	.pre_handler = input_handle_event_handler2_pre,
};

/*
// void input_mt_sync_frame(struct input_dev *dev)
static int input_mt_sync_frame_pre(struct kprobe *p, struct pt_regs *regs) {
	struct input_dev* dev = (struct input_dev*)regs->regs[0];
	if(!dev) {
		return 0;
	}

	//handle_cache_events(dev);
	return 0;
}

static struct kprobe input_mt_sync_frame_kp = {
	.symbol_name = "input_mt_sync_frame",
	.pre_handler = input_mt_sync_frame_pre,
};
*/

int init_input_dev(void) {
	int ret;
	ret = register_kprobe(&input_event_kp);
	pr_info("[ovo] input_event_kp: %d\n", ret);
	if (ret) {
		return ret;
	}
	
	ret = register_kprobe(&input_inject_event_kp);
	pr_info("[ovo] input_inject_event_kp: %d\n", ret);
	if (ret) {
		unregister_kprobe(&input_event_kp);
		return ret;
	}
/*	
	ret = register_kprobe(&input_mt_sync_frame_kp);
	if(ret) {
		unregister_kprobe(&input_event_kp);
		unregister_kprobe(&input_inject_event_kp);
		return ret;
	}
*/

	if(my_input_handle_event == NULL) {
		my_input_handle_event = (void (*)(struct input_dev *, unsigned int, unsigned int, int))ovo_kallsyms_lookup_name("input_handle_event");
	}

	if (!my_input_handle_event) {
		pr_err("[ovo] failed to find my_input_handle_event\n");
		return -1;
	}

	pool = kvmalloc(sizeof(struct event_pool), GFP_KERNEL);
	if (!pool) {
		unregister_kprobe(&input_event_kp);
		unregister_kprobe(&input_inject_event_kp);
//		unregister_kprobe(&input_mt_sync_frame_kp);
		return -ENOMEM;
	}
	pool->size = 0;
	spin_lock_init(&pool->event_lock);

	return ret;
}

void exit_input_dev(void) {
	unregister_kprobe(&input_event_kp);
	unregister_kprobe(&input_inject_event_kp);
//	unregister_kprobe(&input_mt_sync_frame_kp);
	if (pool)
		kfree(pool);
}
```

`ovo/touch.h`:

```h
//
// Created by fuqiuluo on 25-2-9.
//

#ifndef OVO_TOUCH_H
#define OVO_TOUCH_H

#include <linux/input.h>

struct ovo_touch_event {
	unsigned int type;
	unsigned int code;
	int value;
};

#define MAX_EVENTS 1024
#define RING_MASK (MAX_EVENTS - 1)

struct event_pool {
	struct ovo_touch_event events[MAX_EVENTS];
	unsigned long size;
	spinlock_t event_lock;
};

int init_input_dev(void);

void exit_input_dev(void);

struct input_dev* find_touch_device(void);

struct event_pool * get_event_pool(void);

int get_last_driver_slot(struct input_dev* dev);

int input_event_no_lock(struct input_dev *dev,
						unsigned int type, unsigned int code, int value);

int input_event_cache(unsigned int type, unsigned int code, int value, int lock);

int input_mt_report_slot_state_cache(unsigned int tool_type, bool active, int lock);
bool input_mt_report_slot_state_with_id_cache(unsigned int tool_type, bool active, int id, int lock);

#endif //OVO_TOUCH_H

```

`ovo/vma.c`:

```c
//
// Created by fuqiuluo on 25-2-16.
//
#include "vma.h"
#include <linux/tty.h>
#include <linux/io.h>
#include <linux/mm.h>
#include <linux/memory.h>
#include <linux/slab.h>
#include <linux/uaccess.h>
#include <linux/version.h>
#include <asm/page.h>
#include <linux/vmalloc.h>
#include <linux/mman.h>
#include "addr_pfn_map.h"

#if BUILD_REMAP == 1
static int (*my_remap_pfn_range)(struct vm_area_struct *, unsigned long addr,
					unsigned long pfn, unsigned long size, pgprot_t) = NULL;

int process_vaddr_to_pfn(pid_t from, void __user* from_addr, unsigned long* pfn, size_t size) {
	phys_addr_t pa;
	struct task_struct *task;
	struct mm_struct *mm;
	struct pid *pid_struct;

	if(!pfn) {
		return -EINVAL;
	}

	pid_struct = find_get_pid(from);
	if (!pid_struct) {
		pr_err("[ovo] failed to find pid_struct: %s\n", __func__);
		return -ESRCH;
	}

	task = get_pid_task(pid_struct, PIDTYPE_PID);
	put_pid(pid_struct);
	if(!task) {
		pr_err("[ovo] failed to get task from pid_struct: %s\n", __func__);
		return -ESRCH;
	}

	mm = get_task_mm(task);
	if (!mm) {
		pr_err("[ovo] failed to get mm from task: %s\n", __func__);
		return -ESRCH;
	}

	MM_READ_LOCK(mm)
	pa = vaddr_to_phy_addr(mm, (uintptr_t)from_addr);
	MM_READ_UNLOCK(mm)
	mmput(mm);
	put_task_struct(task);

	if(pa == 0) {
		return -EFAULT;
	}

	if (!pa) return -EFAULT;

	*pfn = __phys_to_pfn(pa);
	if (pfn_valid(*pfn) && IS_VALID_PHYS_ADDR_RANGE(pa, size)) {
		return 0;
	}

	return -EFAULT;
}

int remap_process_memory(struct vm_area_struct *vma, unsigned long pfn, size_t size) {
	int ret;

	if (!vma) {
		return -EFAULT;
	}

	// vm_fault_t vmf_insert_pfn_prot(struct vm_area_struct *vma, unsigned long addr,
	//unsigned long pfn, pgprot_t pgprot
	//)

#if ENABLE_REMAP2 == 1
	ret = vmf_insert_pfn(vma, vma->vm_start, pfn);
	if (ret) {
		return -EAGAIN;
	}
#endif

	if (!my_remap_pfn_range) {
		my_remap_pfn_range = (void *) ovo_kallsyms_lookup_name("remap_pfn_range");
		if (!my_remap_pfn_range) {
			pr_err("[ovo] failed to find io_remap_pfn_range: %s\n", __func__);
			return -ENOSYS;
		}
	}

	ret = my_remap_pfn_range(vma, vma->vm_start, pfn, size, vma->vm_page_prot);

	if (ret) return -EAGAIN;

	return 0;
}
#endif

#if (LINUX_VERSION_CODE > KERNEL_VERSION(6, 12, 0))
static inline int vma_iter_area_lowest(struct vma_iterator *vmi, unsigned long min,
					   unsigned long max, unsigned long size)
{
	return mas_empty_area(&vmi->mas, min, max - 1, size);
}

static inline void vma_iter_reset(struct vma_iterator *vmi)
{
	mas_reset(&vmi->mas);
}

#if defined(CONFIG_ARM64_GCS)
/*
 * arm64's Guarded Control Stack implements similar functionality and
 * has similar constraints to shadow stacks.
 */
# define VM_SHADOW_STACK	VM_HIGH_ARCH_6
#endif

#ifndef VM_SHADOW_STACK
# define VM_SHADOW_STACK	VM_NONE
#endif

#define VM_STARTGAP_FLAGS_BAK (VM_GROWSDOWN | VM_SHADOW_STACK)

unsigned long unmapped_area_mm(struct mm_struct *mm, size_t length)
{
	unsigned long gap;
	unsigned long low_limit, high_limit;
	struct vm_area_struct *tmp;

	VMA_ITERATOR(vmi, mm, 0);

	low_limit = mm->mmap_base;
	if (low_limit < 0)
		low_limit = 0;
	high_limit = TASK_SIZE;

	retry:
		if (vma_iter_area_lowest(&vmi, low_limit, high_limit, length))
			return -ENOMEM;

	/*
	 * Adjust for the gap first so it doesn't interfere with the
	 * later alignment. The first step is the minimum needed to
	 * fulill the start gap, the next steps is the minimum to align
	 * that. It is the minimum needed to fulill both.
	 */
	gap = vma_iter_addr(&vmi);
	tmp = vma_next(&vmi);
	if (tmp && (tmp->vm_flags & VM_STARTGAP_FLAGS_BAK)) { /* Avoid prev check if possible */
		if (vm_start_gap(tmp) < gap + length - 1) {
			low_limit = tmp->vm_end;
			vma_iter_reset(&vmi);
			goto retry;
		}
	} else {
		tmp = vma_prev(&vmi);
		if (tmp && vm_end_gap(tmp) > gap) {
			low_limit = vm_end_gap(tmp);
			vma_iter_reset(&vmi);
			goto retry;
		}
	}

	return gap;
}
#else
unsigned long unmapped_area_mm(struct mm_struct *mm, size_t len) {
	unsigned long (*get_area)(struct file *, unsigned long,
				  unsigned long, unsigned long, unsigned long);

	unsigned long addr;
	/* Careful about overflows.. */
	if (len > TASK_SIZE)
		return -ENOMEM;

	get_area = mm->get_unmapped_area;
	addr = get_area(NULL, 0, len, 0, 0);
	if (IS_ERR_VALUE(addr))
		return addr;

	if (addr > TASK_SIZE - len)
		return -ENOMEM;
	if (offset_in_page(addr))
		return -EINVAL;

	return addr;
}
#endif

int get_unmapped_area_pid(pid_t pid, unsigned long* addr, size_t size) {
	struct task_struct *task;
	struct mm_struct *mm;
	struct pid *pid_struct;

	if(!pid) {
		return -ESRCH;
	}

	pid_struct = find_get_pid(pid);
	if (!pid_struct) {
		pr_err("[ovo] failed to find pid_struct: %s\n", __func__);
		return -ESRCH;
	}

	task = get_pid_task(pid_struct, PIDTYPE_PID);
	put_pid(pid_struct);
	if(!task) {
		pr_err("[ovo] failed to get task from pid_struct: %s\n", __func__);
		return -ESRCH;
	}

	mm = get_task_mm(task);
	put_task_struct(task);
	if (!mm) {
		pr_err("[ovo] failed to get mm from task: %s\n", __func__);
		return -ESRCH;
	}

	MM_READ_LOCK(mm)
	*addr = unmapped_area_mm(mm, size);
	MM_READ_UNLOCK(mm)
	mmput(mm);

	return 0;
}

int get_unmapped_area_mm(struct mm_struct* mm, unsigned long* addr, size_t size) {
	*addr = unmapped_area_mm(mm, size);
	return 0;
}

static int ovo_mremap(const struct vm_special_mapping *sm,
			 struct vm_area_struct *new_vma) {
	return 0;
}

static vm_fault_t ovo_fault(const struct vm_special_mapping *sm,
				struct vm_area_struct *vma,
				struct vm_fault *vmf) {

	unsigned long pfn;

	pfn = lookup_pfn(vma->vm_start);
	if (!pfn) {
		pr_err("[ovo] failed to find pfn: addr = 0x%lx\n", vma->vm_start);
		return VM_FAULT_SIGBUS;
	}

	vmf->page = pfn_to_page(pfn);
	get_page(vmf->page);

	return 0;
}

static struct vm_special_mapping aarch64_ovo_map __ro_after_init = {
	.name	= "",
	.mremap = ovo_mremap,
	.fault = ovo_fault
};

int alloc_process_special_memory(pid_t pid, unsigned long addr, size_t size, int writable) {
	int ret;
	struct task_struct *task;
	struct mm_struct *mm;
	struct pid *pid_struct;

	if (!pid || !size || !addr) {
		return -EINVAL;
	}

	pid_struct = find_get_pid(pid);
	if (!pid_struct) {
		pr_err("[ovo] failed to find pid_struct: %s\n", __func__);
		return -ESRCH;
	}

	task = get_pid_task(pid_struct, PIDTYPE_PID);
	put_pid(pid_struct);
	if(!task) {
		pr_err("[ovo] failed to get task from pid_struct: %s\n", __func__);
		return -ESRCH;
	}

	mm = get_task_mm(task);
	put_task_struct(task);
	if (!mm) {
		pr_err("[ovo] failed to get mm from task: %s\n", __func__);
		return -ESRCH;
	}

	MM_READ_LOCK(mm)
	ret = alloc_process_special_memory_mm(mm, addr, size, writable);
	MM_READ_UNLOCK(mm)
	mmput(mm);

	return ret;
}

int alloc_process_special_memory_mm(struct mm_struct* mm, unsigned long addr, size_t size, int writable) {
	static struct vm_area_struct *(*my_install_special_mapping)(struct mm_struct *mm,
				   unsigned long addr, unsigned long len,
				   unsigned long flags,
				   const struct vm_special_mapping *spec) = NULL;
	unsigned long flags;
	struct vm_area_struct * ret;

	if (addr & (PAGE_SIZE - 1)) {
		return -EINVAL;
	}

	if (my_install_special_mapping == NULL) {
		my_install_special_mapping = (void*) ovo_kallsyms_lookup_name("_install_special_mapping");
		if (!my_install_special_mapping) {
			pr_err("[ovo] failed to find install_special_mapping: %s\n", __func__);
			return -ENOSYS;
		}
	}

	flags = VM_READ | VM_SHARED | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC;
	if (writable) {
		flags |= VM_WRITE;
	} else {
		flags |= VM_EXEC;
	}
	ret = my_install_special_mapping(mm, addr, size, flags, &aarch64_ovo_map);

	return ret != NULL ? 0 : -ENOMEM;
}

struct vm_area_struct * find_vma_pid(pid_t pid, unsigned long addr) {
	struct task_struct *task;
	struct mm_struct *mm;
	struct pid *pid_struct;
	struct vm_area_struct *vma;

	if(!pid) {
		return NULL;
	}

	pid_struct = find_get_pid(pid);
	if (!pid_struct) {
		pr_err("[ovo] failed to find pid_struct: %s\n", __func__);
		return NULL;
	}

	task = get_pid_task(pid_struct, PIDTYPE_PID);
	put_pid(pid_struct);
	if(!task) {
		pr_err("[ovo] failed to get task from pid_struct: %s\n", __func__);
		return NULL;
	}

	mm = get_task_mm(task);
	if (!mm) {
		pr_err("[ovo] failed to get mm from task: %s\n", __func__);
		return NULL;
	}

	vma = find_vma(mm, addr);

	mmput(mm);
	put_task_struct(task);

	return vma;
}

```

`ovo/vma.h`:

```h
//
// Created by fuqiuluo on 25-2-16.
//

#ifndef VMA_H
#define VMA_H

#include <linux/sched.h>
#include <linux/mm.h>
#include <linux/version.h>
#include "memory.h"

#if BUILD_REMAP == 1
int process_vaddr_to_pfn(pid_t from, void __user* from_addr, unsigned long* pfn, size_t size);

// 内存重映射
int remap_process_memory(struct vm_area_struct *vma, unsigned long pfn, size_t size);
#endif

int get_unmapped_area_pid(pid_t pid, unsigned long* addr, size_t size);
int get_unmapped_area_mm(struct mm_struct* mm, unsigned long* addr, size_t size);
int alloc_process_special_memory(pid_t pid, unsigned long addr, size_t size, int writable);
int alloc_process_special_memory_mm(struct mm_struct* mm, unsigned long addr, size_t size, int writable);
struct vm_area_struct* find_vma_pid(pid_t pid, unsigned long addr);

#endif //VMA_H

```

`samples/jni/Android.mk`:

```mk
LOCAL_PATH := $(call my-dir)


include $(CLEAR_VARS)
LOCAL_MODULE := test_memory

LOCAL_CFLAGS := -fvisibility=hidden -w
LOCAL_CPPFLAGS := -std=c++17
LOCAL_CPPFLAGS += -fvisibility=hidden

LOCAL_SRC_FILES := test_memory.cpp
LOCAL_SRC_FILES += hakutaku.cpp

LOCAL_LDLIBS := -llog -landroid
include $(BUILD_EXECUTABLE)

```

`samples/jni/Application.mk`:

```mk
APP_ABI := arm64-v8a
APP_PLATFORM := android-21
APP_STL := c++_static
#APP_STL := c++_shared
APP_OPTIM := release





```

`samples/jni/hakutaku.cpp`:

```cpp
#include "hakutaku.h"
#include <string>
#include <istream>
#include <iostream>
#include <sstream>
#include <cctype>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <linux/input.h>
#include <sys/mman.h>
#include <netdb.h>


struct req_access_process_vm {
    pid_t from;
    void __user* from_addr;
    pid_t to;
    void __user* to_addr;
    size_t size;
};

template <size_t N>
auto read_proc_file(pid_t pid, const char *name, char *dest) -> void {
    std::string file_path = "/proc/" + std::to_string(pid) + "/" + name;
    FILE* _fp = fopen(file_path.c_str(), "r");
    if (_fp != nullptr) {
        std::fgets(dest, N, _fp);
        std::fclose(_fp);
    } else {
        dest[0] = '\0';
    }
}

auto hak::get_process_list() -> std::vector<proc_stat> {
    std::vector<hak::proc_stat> list;
    auto *proc_dir = opendir("/proc");
    if (proc_dir == nullptr) {
        return {};
    }
    struct dirent* pid_file;
    char stat[256];
    while ((pid_file = readdir(proc_dir)) != nullptr) {
        if (pid_file->d_type != DT_DIR || ((std::isdigit(pid_file->d_name[0])) == 0)) {
            continue;
        }
        hak::proc_stat my_stat;
        pid_t pid = std::stoi(pid_file->d_name);
        read_proc_file<sizeof(stat)>(pid, "stat", stat);
        std::istringstream iss((std::string(stat)));
        iss >> my_stat.pid;
        iss >> my_stat.comm;
        iss >> my_stat.state;
        iss >> my_stat.ppid;
        if (my_stat.state == 'R' || my_stat.state == 'S' || my_stat.state == 'D') {
            list.push_back(my_stat);
        }
    }
    closedir(proc_dir);
    return std::move(list);
}

auto hak::get_pid_list() -> std::vector<pid_t> {
    std::vector<pid_t> list;
    auto *proc_dir = opendir("/proc");
    if (proc_dir == nullptr) {
        return {};
    }
    struct dirent* pid_file;
    char stat[256];
    while ((pid_file = readdir(proc_dir)) != nullptr) {
        if (pid_file->d_type != DT_DIR || ((std::isdigit(pid_file->d_name[0])) == 0)) {
            continue;
        }
        pid_t pid = std::stoi(pid_file->d_name);
        read_proc_file<sizeof(stat)>(pid, "stat", stat);
        std::istringstream iss((std::string(stat)));
        std::string token;
        for (int i = 0; i < 3; ++i) {
            iss >> token;
        }
        if (token == "R" || token == "S" || token == "D") {
            list.emplace_back(pid);
        }
    }
    closedir(proc_dir);
    return std::move(list);
}

auto hak::find_process(std::string_view package) -> pid_t {
    auto *proc_dir = opendir("/proc");
    if (proc_dir == nullptr) {
        return 0;
    }
    struct dirent* pid_file;
    char cmd_line[128];
    while ((pid_file = readdir(proc_dir)) != nullptr) {
        if (pid_file->d_type != DT_DIR || ((std::isdigit(pid_file->d_name[0])) == 0)) {
            continue;
        }
        pid_t pid = std::stoi(pid_file->d_name);
        read_proc_file<sizeof(cmd_line)>(pid, "cmdline", cmd_line);
        if (package == cmd_line) {
            pid_t p = std::stoi(pid_file->d_name);
            closedir(proc_dir);
            return p;
        }
    }
    closedir(proc_dir);
    return 0;
}

auto hak::get_module_base(pid_t pid, std::string_view module) -> uintptr_t {
    FILE *fp = nullptr;
    char *pch = nullptr;
    char filename[32];
    char line[512];
    uint64_t addr = 0;

    if (pid != -100)
        snprintf(filename, sizeof(filename), "/proc/%d/maps", pid);
    else
        snprintf(filename, sizeof(filename), "/proc/self/maps");

    if ( (fp = fopen(filename, "r")) == nullptr ){
        printf("open %s failed!\n", filename);
        return 0;
    }

    while ( fgets(line, sizeof(line), fp) ){
        if ( strstr(line, module.data()) ){
            pch = strtok(line, "-");
            addr = strtoull(pch, nullptr, 16);
            break;
        }
    }

    fclose(fp);
    return addr;
}

auto hak::driver::find_driver_id() -> int {
    int sock;
    for (int i = AF_DECnet; i < AF_MAX; ++i) {
        sock = socket(i, SOCK_SEQPACKET, 0);
        if (sock < 0) {
            if (errno == ENOKEY) {
                sock = socket(i, SOCK_RAW, 0);
                if (sock > 0) {
                    break;
                }
            } else {
                continue;
            }
        }
    }

    if (sock < 0) {
        return -1;
    } else {
        close(sock);
    }
    return sock;
}

bool hak::driver::active() const {
    return sock > 0;
}

bool hak::driver::is_verbose() const {
    return verbose;
}

hak::driver::driver() {
    for (int i = AF_DECnet; i < AF_MAX; ++i) {
        sock = socket(i, SOCK_SEQPACKET, 0);
        if (sock < 0) {
            if (errno == ENOKEY) {
                sock = socket(i, SOCK_RAW, 0);
                if (sock > 0) {
                    return;
                }
            } else {
                continue;
            }
        }
    }
    verbose = true;
}

hak::driver::~driver() {
    if (active()) {
        close(sock);
    }
}

pid_t hak::driver::get_process_pid(std::string_view package) {
    pid_t pid = 0;
    void* data = new char[package.size() + 1];
    socklen_t len = package.size() + 1;
    std::copy(package.begin(), package.end(), static_cast<char*>(data));
    if(getsockopt(sock, len, (int) GET_PROCESS_PID, data, &len) < 0 && errno != 2033) {
        std::cout << "get pid by driver failed: " << strerror(errno) << std::endl;
        goto out;
    }
    pid = *(pid_t*) data;

    out:
    delete[] ((char*) data);
    return pid;
}
//pid_t hak::driver::get_process_pid(const std::string &package) const {
//    pid_t pid = 0;
//    void* data = new char[package.size() + 1];
//    socklen_t len = package.size() + 1;
//    std::copy(package.begin(), package.end(), static_cast<char*>(data));
//    if(getsockopt(sock, len, (int) GET_PROCESS_PID, data, &len) < 0) {
//        std::cout << "get pid by driver failed: " << strerror(errno) << std::endl;
//        goto out;
//    }
//    pid = *(pid_t*) data;
//
//    out:
//    delete[] ((char*) data);
//    return pid;
//}

bool hak::driver::is_process_alive_pid(pid_t pid) const {
    socklen_t alive = 0;
    if(getsockopt(sock, pid, (int) IS_PROCESS_ALIVE_PID, NULL, &alive) < 0 && errno != 2033) {
        std::cout << "is_process_alive_pid failed: " << strerror(errno) << std::endl;
        return false;
    }
    return alive == 1;
}

int hak::driver::attach_process_pid(pid_t pid) const {
    socklen_t len = 0;
    if(getsockopt(sock, pid, (int) ATTACH_PROCESS, nullptr, &len) < 0 && errno != 2033) {
        std::cout << "attach process failed: " << strerror(errno) << std::endl;
        return -1;
    }
    return 0;
}

uintptr_t hak::driver::get_process_module_base(const std::string& module, int vm_flag) const {
    uintptr_t addr = 0;
    socklen_t len = module.size() + 1;
    if (len < 8) {
        len = 8;
    }
    char* data = new char[len];
    std::copy(module.begin(), module.end(), static_cast<char*>(data));
    if(getsockopt(sock, vm_flag, (int) GET_PROCESS_MODULE_BASE, data, &len) < 0 && errno != 2033) {
        std::cout << "get module base failed: " << strerror(errno) << std::endl;
        goto out;
    }
    addr = *(uintptr_t*) data;

    out:
    delete[] data;
    return addr;
}

// 读写10w次 70ms
size_t hak::driver::read_process_memory_ioremap(uintptr_t addr, void *buffer, size_t size) const {
    if(getsockopt(sock, size, (int) READ_PROCESS_MEMORY_IOREMAP, (void*) addr, (socklen_t*) buffer) < 0 && errno != 2033) {
        std::cout << "read process memory failed: " << strerror(errno) << std::endl;
        return 0;
    }
    return size;
}

size_t hak::driver::write_process_memory_ioremap(uintptr_t addr, void *buffer, size_t size) const {
    if(getsockopt(sock, size, (int) WRITE_PROCESS_MEMORY_IOREMAP, (void*) addr, (socklen_t*) buffer) < 0 && errno != 2033) {
        std::cout << "write process memory failed: " << strerror(errno) << std::endl;
        return 0;
    }
    return size;
}

// 读写10w次 220ms
int hak::driver::access_process_vm(pid_t from, uintptr_t from_addr, pid_t to, uintptr_t to_addr, size_t len) {
    req_access_process_vm req{};
    req.from = from;
    req.from_addr = (void*) from_addr;
    req.to = to;
    req.to_addr = (void*) to_addr;
    req.size = len;
    socklen_t data_len = sizeof(req);
    if(getsockopt(sock, len, (int) ACCESS_PROCESS_VM, &req, &data_len) < 0 && errno != 2033) {
        std::cout << "access process vm failed: " << strerror(errno) << std::endl;
        return -1;
    }
    return len;
}

size_t hak::driver::read_process_memory(uintptr_t addr, void *buffer, size_t size) const {
    if(getsockopt(sock, size, (int) READ_PROCESS_MEMORY, (void*) addr, (socklen_t*) buffer) < 0 && errno != 2033) {
        std::cout << "read process memory failed: " << strerror(errno) << std::endl;
        return 0;
    }
    return size;
}

size_t hak::driver::write_process_memory(uintptr_t addr, void *buffer, size_t size) const {
    if(getsockopt(sock, size, (int) WRITE_PROCESS_MEMORY, (void*) addr, (socklen_t*) buffer) < 0 && errno != 2033) {
        std::cout << "write process memory failed: " << strerror(errno) << std::endl;
        return 0;
    }
    return size;
}

int hak::driver::remap_memory(uintptr_t addr, size_t size, void **buffer) const {
    if(getsockopt(sock, size, (int) REMAP_MEMORY, (void*) addr, (socklen_t*) addr) < 0 && errno != 2033) {
        std::cout << "remap memory failed: " << strerror(errno) << std::endl;
        return -1;
    }

    auto* buf = mmap(nullptr, size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, sock, 0);
    if (buf == MAP_FAILED) {
        std::cout << "mmap failed: " << strerror(errno) << std::endl;
        return -1;
    }

    *buffer = buf;
    return 0;
}



```

`samples/jni/hakutaku.h`:

```h
#ifndef HAKUTAKU_H
#define HAKUTAKU_H

#include <sys/uio.h>
#include <filesystem>
#include <dirent.h>
#include <string>
#include <vector>
#include <list>
#include <assert.h>

#define VM_READ		0x00000001	/* currently active flags */
#define VM_WRITE	0x00000002
#define VM_EXEC		0x00000004
#define VM_SHARED	0x00000008
//
//class VoidPtrWrapper {
//public:
//    VoidPtrWrapper() : ptr_(nullptr) {}
//    uintptr_t get_void_ptr_rs() const { return (uintptr_t)ptr_; }
//    void* get_void_ptr() const { return ptr_; }
//    void set_void_ptr(uintptr_t ptr) { ptr_ = (void*) ptr; }
//private:
//    void* ptr_;
//};
//
//std::shared_ptr<VoidPtrWrapper> create_void_ptr() {
//    return std::make_shared<VoidPtrWrapper>();
//}

namespace hak {
    // Process State
    struct proc_stat {
        pid_t pid;
        std::string comm;
        char state;
        pid_t ppid;
    };

    // Get process list
    auto get_process_list() -> std::vector<proc_stat>;

    // Get pid list
    auto get_pid_list() -> std::vector<pid_t>;

    /**
     * Read proc file
     * @param package
     * @return pid_t
     */
    auto find_process(std::string_view package) -> pid_t;

    // get module base
    auto get_module_base(pid_t pid, std::string_view module) -> uintptr_t;

    enum DRIVER_FUNCTION_REQUEST: int {
        GET_PROCESS_PID = 0,
        IS_PROCESS_ALIVE_PID = 1,
        ATTACH_PROCESS = 2,
        GET_PROCESS_MODULE_BASE = 3,
        READ_PROCESS_MEMORY_IOREMAP = 4,
        WRITE_PROCESS_MEMORY_IOREMAP = 5,
        ACCESS_PROCESS_VM = 6,
        READ_PROCESS_MEMORY = 7,
        WRITE_PROCESS_MEMORY = 8,
        REMAP_MEMORY = 9,
    };

    class driver {
    public:
        bool verbose; // Only for debug!!!!!

        driver();

        ~driver();

        bool active() const;

        bool is_verbose() const;

        /**
         * 获取进程PID
         * @param package
         * @return pid_t
         */
        pid_t get_process_pid(std::string_view package);
        //int32_t get_process_pid(const std::string& package) const;

        bool is_process_alive_pid(pid_t pid) const;

        /**
         * 无需附加进程读写进程内存 (缺页不会终止)
         * @param from
         * @param from_addr
         * @param to
         * @param to_addr
         * @param len
         * @return 读取的数据长度
         *
         * @note ESRCH 无效的PID
         * @note ENOMEM 内核内存不足
         * @note EIO 无效的地址/读取失败
         */
        int access_process_vm(pid_t from, uintptr_t from_addr, pid_t to, uintptr_t to_addr, size_t len);

        int attach_process_pid(pid_t pid) const;

        /**
         * 获取进程模块基址
         * @param module
         * @param vm_flag  VM_READ, VM_WRITE, VM_EXEC, VM_SHARED
         * @return
         */
        uintptr_t get_process_module_base(const std::string &module, int vm_flag) const;

        /**
         * 读写进程内存通过ioremap
         * @param addr
         * @param buffer
         * @param size
         * @return 读取的数据长度
         *
         * @note EFAULT 无效的目标地址/缺页
         * @note ESRCH 目标进程死亡
         * @note EACCES `buffer` 地址不合法
         */
        size_t read_process_memory_ioremap(uintptr_t addr, void* buffer, size_t size) const;
        size_t write_process_memory_ioremap(uintptr_t addr, void* buffer, size_t size) const;

        size_t read_process_memory(uintptr_t addr, void* buffer, size_t size) const;
        size_t write_process_memory(uintptr_t addr, void* buffer, size_t size) const;

        /**
         * 重新映射内存
         * @param addr
         * @param size
         * @param buffer
         * @return
         *
         * @warning 如果输入的地址对应的物理地址没有对齐会自动对齐以获取正确的pfn, 即向下对齐(丢弃低位)！
         * @warning（请确保输入的地址是对齐的）
         */
        int remap_memory(uintptr_t addr, size_t size, void** buffer) const;
    public:

    private:
        int sock;

        static auto find_driver_id() -> int;
    };
}

#endif //HAKUTAKU_H

```

`samples/jni/test_memory.cpp`:

```cpp
#include "hakutaku.h"
#include <iostream>
#include <sys/mman.h>

static hak::driver driver;

int main() {
	auto pid = driver.get_process_pid("com.tencent.mobileqq");
	if (pid == 0) {
		std::cerr << "请先启动QQ: errno = " << errno << std::endl;
		return -1;
	} else {
		std::cout << "QQ进程PID: " << pid << std::endl;
	}
	auto alive = driver.is_process_alive_pid(pid);
	if (alive) {
		std::cout << "QQ进程存活\n";
	} else {
		std::cerr << "QQ进程已退出: errno = " << errno << std::endl;
		return -1;
	}

	if (driver.attach_process_pid(pid) < 0) {
		std::cerr << "附加进程失败: errno = " << errno << std::endl;
		return -1;
	} else {
		std::cout << "附加进程成功\n";
	}

	auto base = driver.get_process_module_base("libzplan_service.so", VM_EXEC);
	if (base == 0) {
		std::cerr << "获取模块基址失败: errno = " << errno << std::endl;
		return -1;
	} else {
		std::cout << "libzplan_service.so基址: " << std::hex << base << std::endl;
	}

	driver.attach_process_pid(getpid()); // detach from process

	{
		auto *a = new int(1008611);
		auto *b = new int(1001011);

		driver.read_process_memory_ioremap((uintptr_t) a, b, sizeof(int));
		assert(*b == 1008611);
		*b = 114514;
		driver.write_process_memory_ioremap((uintptr_t) a, b, sizeof(int));
		assert(*a == 114514);

		delete a;
		delete b;
	}

	{
		auto *a = new int(1008611);
		auto *b = new int(1001011);

		driver.access_process_vm(getpid(), (uintptr_t) a, getpid(), (uintptr_t) b, sizeof(int));
		assert(*b == 1008611);
		*b = 114514;
		driver.access_process_vm(getpid(), (uintptr_t) b, getpid(), (uintptr_t) a, sizeof(int));
		assert(*a == 114514);

		delete a;
		delete b;
	}

/*    {
        char tmp[0x1000];
        void *data = mmap(nullptr, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
        if (data == MAP_FAILED) {
            std::cerr << "mmap failed: " << strerror(errno) << std::endl;
            return -1;
        }
        if(driver.read_process_memory_ioremap((uintptr_t) data, tmp, 0x1000) > 0) {
            std::cout << "read_process_memory_ioremap success: " << std::hex << (int) tmp[0] << std::endl;
        }
        unsigned char vec[0x1000];
        if (mincore(data, 0x1000, vec) < 0) {
            std::cerr << "mincore failed: " << strerror(errno) << std::endl;
            return -1;
        } else {
            std::cout << "mincore success: " << std::hex << (int) vec[0] << std::endl;
        }
        munmap(data, 0x1000);
    }*/

/*    {
        char tmp[0x1000];
        void *data = mmap(nullptr, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
        if (data == MAP_FAILED) {
            std::cerr << "mmap failed: " << strerror(errno) << std::endl;
            return -1;
        }
        if (driver.access_process_vm(getpid(), (uintptr_t) data, getpid(), (uintptr_t) tmp, 0x1000) > 0) {
            std::cout << "access_process_vm success: " << std::hex << (int) tmp[0] << std::endl;
        }
        unsigned char vec[0x1000];
        if (mincore(data, 0x1000, vec) < 0) {
            std::cerr << "mincore failed: " << strerror(errno) << std::endl;
            return -1;
        } else {
            std::cout << "mincore success: " << std::hex << (int) vec[0] << std::endl;
        }
        munmap(data, 0x1000);
    }

    {
        char tmp[0x1000];
        void *data = mmap(nullptr, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
        if (data == MAP_FAILED) {
            std::cerr << "mmap failed: " << strerror(errno) << std::endl;
            return -1;
        }
        if (driver.read_process_memory((uintptr_t) data, tmp, 0x1000) > 0) {
            std::cout << "read_process_memory success: " << std::hex << (int) tmp[0] << std::endl;
        }
        unsigned char vec[0x1000];
        if (mincore(data, 0x1000, vec) < 0) {
            std::cerr << "mincore failed: " << strerror(errno) << std::endl;
            return -1;
        } else {
            std::cout << "mincore success: " << std::hex << (int) vec[0] << std::endl;
        }
        munmap(data, 0x1000);
    }*/

	{
		auto *a = new int(1008611);
		auto *b = new int(1001011);
		auto start = std::chrono::high_resolution_clock::now();
		for (int i = 0; i < 100000; ++i) {
			*a = 1008611;
			driver.read_process_memory_ioremap((uintptr_t) a, b, sizeof(int));
			assert(*b == 1008611);
			*b = 114514;
			driver.write_process_memory_ioremap((uintptr_t) a, b, sizeof(int));
			assert(*a == 114514);
		}
		auto end = std::chrono::high_resolution_clock::now();
		std::cout << std::dec << "read_process_memory_ioremap Time: " << std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count()
				  << "ms\n";
		delete a;
		delete b;
	}

	{
		int *a = (int*) new int(1008611);
		auto start = std::chrono::high_resolution_clock::now();
		int* b = nullptr;
		if(driver.remap_memory((uintptr_t) a, 4, (void**) &b)) {
			std::cerr << "remap_memory failed: " << strerror(errno) << std::endl;
			return -1;
		}
		//std::cout << "remap_memory success: " << std::hex << (uintptr_t) b << std::dec << std::endl;
		for (int i = 0; i < 100000000; ++i) {
			*a = i;
			assert(*b == i);
			*b = i+999;
			assert(*a == i + 999);
		}
		std::cout << "a = " << *a << ", b = " << *b << std::endl;
		auto end = std::chrono::high_resolution_clock::now();
		std::cout << "remap_memory Time: " << std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count() << "ms\n";
		munmap(a, 0x1000);
	}
	return 0;
}
```