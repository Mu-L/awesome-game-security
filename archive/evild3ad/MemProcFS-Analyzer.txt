Project Path: arc_evild3ad_MemProcFS-Analyzer_l5157ft3

Source Tree:

```txt
arc_evild3ad_MemProcFS-Analyzer_l5157ft3
├── CHANGELOG.md
├── LICENSE
├── MemProcFS-Analyzer.ps1
├── README.md
├── Screenshots
│   ├── 01.png
│   ├── 02.png
│   ├── 03.png
│   ├── 04.png
│   ├── 05.png
│   ├── 06.png
│   ├── 07.png
│   ├── 08.png
│   ├── 09.png
│   ├── 10.png
│   ├── 11.png
│   ├── 12.png
│   ├── 13.png
│   ├── 14.png
│   ├── 15.png
│   ├── 16.png
│   ├── 17.png
│   ├── 18.png
│   ├── 19.png
│   ├── 20.png
│   ├── 21.png
│   ├── 22.png
│   ├── 23.png
│   ├── 24.png
│   ├── 25.png
│   ├── Discord.png
│   └── Wiki
│       ├── Elasticsearch
│       │   ├── Configure-Elastic.png
│       │   ├── Dashboards.png
│       │   ├── ELK-Import.png
│       │   ├── Starting-Elasticsearch.png
│       │   ├── Starting-Kibana.png
│       │   └── mp_timeline.png
│       ├── LNK
│       │   ├── LNK.yar.png
│       │   └── Main.png
│       ├── ProcessTree
│       │   ├── 01.jpg
│       │   ├── 02.jpg
│       │   ├── 03.jpg
│       │   ├── 04.jpg
│       │   ├── 05.jpg
│       │   └── 06.png
│       └── UserAssist
│           ├── Analyzing-UserAssist-Artifacts.png
│           ├── UserAssist-Plugin.png
│           └── UserAssist-Stats.png
├── Scripts
│   ├── 1768
│   │   ├── 1768.json
│   │   └── 1768.py
│   ├── Get-ProcessTree
│   │   └── Get-ProcessTree.ps1
│   ├── Measure-DamerauLevenshteinDistance
│   │   └── Measure-DamerauLevenshteinDistance.cs
│   └── ProcessesAndModules-Extended_Info.ps1
├── Tools
│   ├── 7-Zip
│   │   └── 7za.exe
│   └── RECmd_BatchFiles
│       ├── AdobeRecentFiles.reb
│       ├── BAM.reb
│       ├── LastVisitedPidlMRU.reb
│       ├── MUICache.reb
│       ├── OpenSavePidlMRU.reb
│       ├── RecentDocs.reb
│       ├── RegistryASEPs.reb
│       ├── SysCache.reb
│       ├── TerminalServerClient.reb
│       ├── TrustedDocuments.reb
│       └── UserAssist.reb
└── Updater.ps1

```

`CHANGELOG.md`:

```md
# Changelog  

All changes to MemProcFS-Analyzer will be documented in this file.  

## [1.2.0] - 2025-06-24
### Added
- EZTools (.NET 9)
- DFIR RECmd Batch File v2.11 (2025-03-31)
- 423 YARA Custom Rules
- FS_Process_Console
- FS_SysInfo_Network: DNS Information
- Digital Signature

## Fixed
- Minor fixes and improvements

## Changed
- CHANGELOG.md

## [1.1.0] - 2024-09-02
### Added
- Updater.ps1
- FS_Sys_Sysinfo
- FS_Forensic_Prefetch
- 376 YARA Custom Rules
- Offline Mode
- MemProcFS.log
- Microsoft Protection Logs (MPLogs)
- ProcessesAndModules-Extended_Info.ps1 (Collect-MemoryDump)

## Fixed
- Minor fixes and improvements

## [1.0.0] - 2023-11-22
### Added
- Improved Hunting for Suspicious Scheduled Tasks
- 318 YARA Custom Rules
- Get-YaraCustomRules
- Kroll RECmd Batch File v1.22 (2023-06-20)
- Checkbox Forensic Timeline (CSV)
- Checkbox Forensic Timeline (XLSX)
- FindEvil: AV_DETECT

## Fixed
- Minor fixes and improvements

## [0.9.0] - 2023-15-25
### Added
- FS_Forensic_Yara (YARA Custom Rules)
- FS_Forensic_Files (incl. ClamAV)
- Checking for suspicious processes with double file extensions
- Checking for Command and Scripting Interpreters
- Recent Folder Artifacts
- Hunting Suspicious Image Mounts
- OpenSaveMRU (OpenSavePidlMRU)
- LastVisitedMRU (LastVisitedPidlMRU)
- Terminal Server Client (RDP)
- Kroll RECmd Batch File v1.21 (2023-03-04)
- Improved Microsoft Defender AntiVirus Handling
- Improved Drive Letter (Mount Point) Handling

## Fixed
- Minor fixes and improvements

## [0.8.0] - 2023-01-23
### Added
- MUICache
- Windows Background Activity Moderator (BAM)
- Check if it's a Domain Controller
- Check if it's a Microsoft Exchange Server
- Checking for processes spawned from suspicious folder locations
- Checking for suspicious processes without any command-line arguments
- Checking for suspicious process lineage
- Checking for processes with suspicious command-line arguments
- Parent Name (proc.csv, Processes.xlsx, and RunningandExited.xlsx)
- Listing of MiniDumps
- Status Bar (User Interface)

## Fixed
- Minor fixes and improvements

## [0.7.0] - 2022-11-21
### Added
- User Interface
- Pagefile Support
- Zircolite - A standalone SIGMA-based detection tool for EVTX
- Event Log Overview
- Checking for Processes w/ Unusual User Context
- Process Tree: Properties View
- Searching for Cobalt Strike Beacons Configuration(s) w/ 1768.py (needs to be installed manually, disabled by default)
- Simple Prefetch View (based on Forensic Timeline)

## Fixed
- Minor fixes and improvements

## [0.6.0] - 2022-10-10
### Added
- Process Tree (TreeView)
- Unusual Number of Process Instances
- Process Path Masquerading
- Process Name Masquerading (Damerau Levenshtein Distance)
- Suspicious Port Numbers

## Fixed
- Minor fixes and improvements

## [0.5.0] - 2022-09-06
### Added
- BitLocker Plugin
- Kroll RECmd Batch File v1.20 (2022-06-01)
- FS_Forensic_CSV + XLSX
- FS_SysInfo_Users
- Windows Shortcut Files (LNK)
- Process Modules (Metadata)
- Number of Sub-Processes (proc.csv, Processes.xlsx, and RunningandExited.xlsx)
- Colorized Running and Exited Processes (RunningandExited.xlsx)

## Fixed
- Minor fixes and improvements

## [0.4.0] - 2022-07-27
### Added
- Web Browser History
- Forensic Timeline (CSV, XLSX)
- JSON to CSV and XLSX output (including Handles)
- Collecting output of pypykatz and regsecrets (MemProcFS Plugins)
- RecentDocs
- Office Trusted Documents
- Adobe RecentDocs
- Startup Folders

## Fixed
- Minor fixes and improvements

## [0.3.0] - 2021-06-17
### Added
- OS Fingerprinting
- Registry Explorer/RECmd
- UserAssist
- Syscache
- ShellBags Explorer/SBECmd
- Registry ASEPs (Auto-Start Extensibility Points)

## Fixed
- Minor fixes and improvements

## [0.2.0] - 2021-05-26
### Added
- IPinfo CLI
- Collecting Registry Hives
- AmcacheParser
- AppCompatCacheParser (ShimCache)
- PowerShell module 'ImportExcel'
- Collection of PE_INJECT (PW: infected)
- Hunting for suspicious Services
- Hunting for suspicious Scheduled Tasks

## Fixed
- Minor fixes and improvements

## [0.1.0] - 2021-05-15
### Added
- Initial Release

```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.

```

`MemProcFS-Analyzer.ps1`:

```ps1
# MemProcFS-Analyzer v1.2.0
#
# @author:    Martin Willing
# @copyright: Copyright (c) 2021-2025 Martin Willing. All rights reserved. Licensed under the MIT license.
# @contact:   Any feedback or suggestions are always welcome and much appreciated - mwilling@lethal-forensics.com
# @url:       https://lethal-forensics.com/
# @date:      2025-06-24
#
#
# ██╗     ███████╗████████╗██╗  ██╗ █████╗ ██╗      ███████╗ ██████╗ ██████╗ ███████╗███╗   ██╗███████╗██╗ ██████╗███████╗
# ██║     ██╔════╝╚══██╔══╝██║  ██║██╔══██╗██║      ██╔════╝██╔═══██╗██╔══██╗██╔════╝████╗  ██║██╔════╝██║██╔════╝██╔════╝
# ██║     █████╗     ██║   ███████║███████║██║█████╗█████╗  ██║   ██║██████╔╝█████╗  ██╔██╗ ██║███████╗██║██║     ███████╗
# ██║     ██╔══╝     ██║   ██╔══██║██╔══██║██║╚════╝██╔══╝  ██║   ██║██╔══██╗██╔══╝  ██║╚██╗██║╚════██║██║██║     ╚════██║
# ███████╗███████╗   ██║   ██║  ██║██║  ██║███████╗ ██║     ╚██████╔╝██║  ██║███████╗██║ ╚████║███████║██║╚██████╗███████║
# ╚══════╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚══════╝ ╚═╝      ╚═════╝ ╚═╝  ╚═╝╚══════╝╚═╝  ╚═══╝╚══════╝╚═╝ ╚═════╝╚══════╝
#
#
# Dependencies:
# 7-Zip 24.09 Standalone Console (2024-11-29)
# https://www.7-zip.org/download.html --> 7za.exe (x64)
#
# AmcacheParser v1.5.2.0 (.NET 9)
# https://ericzimmerman.github.io/
#
# AppCompatCacheParser v1.5.1.0 (.NET 9)
# https://ericzimmerman.github.io/
#
# ClamAV - Download --> Windows --> clamav-1.4.3.win.x64.msi (2025-06-17)
# https://www.clamav.net/downloads
# https://docs.clamav.net/manual/Usage/Configuration.html#windows --> First Time Set-Up
# https://blog.clamav.net/
#
# Dokany File System Library v2.3.0.1000 (2025-04-19)
# https://github.com/dokan-dev/dokany/releases/latest --> DokanSetup.exe
#
# Elasticsearch 9.0.2 (2025-06-03)
# https://www.elastic.co/downloads/elasticsearch
#
# entropy v1.1 (2023-07-28)
# https://github.com/merces/entropy
#
# EvtxECmd v1.5.2.0 (.NET 9)
# https://ericzimmerman.github.io/
#
# ImportExcel v7.8.10 (2024-10-21)
# https://github.com/dfinke/ImportExcel
#
# IPinfo CLI 3.3.1 (2024-03-01)
# https://github.com/ipinfo/cli
#
# jq v1.8.0 (2025-06-01)
# https://github.com/stedolan/jq
#
# Kibana 9.0.2 (2025-06-03)
# https://www.elastic.co/downloads/kibana
#
# lnk_parser v0.4.1 (2025-01-02)
# https://github.com/AbdulRhmanAlfaifi/lnk_parser
#
# MemProcFS v5.15.0 - The Memory Process File System (2025-06-22)
# https://github.com/ufrisk/MemProcFS
#
# RECmd v2.1.0.0 (.NET 9)
# https://ericzimmerman.github.io/
# https://github.com/EricZimmerman/RECmd/blob/master/BatchExamples/DFIRBatch.md
#
# SBECmd v2.1.0.0 (.NET 9)
# https://ericzimmerman.github.io/
#
# xsv v0.13.0 (2018-05-12)
# https://github.com/BurntSushi/xsv
#
# YARA v4.5.4 (2025-05-27)
# https://virustotal.github.io/yara/
#
# Zircolite v2.40.0 (2025-04-06)
# https://github.com/wagga40/Zircolite
#
#
# Tested on Windows 10 Pro (x64) Version 22H2 (10.0.19045.5965) and PowerShell 5.1 (5.1.19041.5965)
#
#
#############################################################################################################################################################################################
#############################################################################################################################################################################################

<#
.SYNOPSIS
  MemProcFS-Analyzer v1.2.0 - Automated Forensic Analysis of Windows Memory Dumps for DFIR

.DESCRIPTION
  MemProcFS-Analyzer.ps1 is a PowerShell script utilized to simplify the usage of MemProcFS and to assist with the memory analysis workflow.

.EXAMPLE
  PS> .\MemProcFS-Analyzer.ps1

.NOTES
  Author - Martin Willing

.LINK
  https://github.com/LETHAL-FORENSICS/MemProcFS-Analyzer
#>

#############################################################################################################################################################################################
#############################################################################################################################################################################################

#region Declarations

# Declarations

# Script Root
if ($PSVersionTable.PSVersion.Major -gt 2)
{
    # PowerShell 3+
    $script:SCRIPT_DIR = $PSScriptRoot
}
else
{
    # PowerShell 2
    $script:SCRIPT_DIR = Split-Path -Parent $MyInvocation.MyCommand.Definition
}

# Analysis date (ISO 8601)
$script:Date = [datetime]::Now.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss") # YYYY-MM-DDThh:mm:ss
$script:Timestamp = $Date -replace ":", "" # YYYY-MM-DDThhmmss

# Version
$Version = "v1.2.0"

# Tools

# 7-Zip
$script:7za = "$SCRIPT_DIR\Tools\7-Zip\7za.exe"

# AmcacheParser
$script:AmcacheParser = "$SCRIPT_DIR\Tools\AmcacheParser\AmcacheParser.exe"

# AppCompatCacheParser
$script:AppCompatCacheParser = "$SCRIPT_DIR\Tools\AppCompatCacheParser\AppCompatCacheParser.exe"

# ClamAV
$script:freshclam = "C:\Program Files\ClamAV\freshclam.exe"
$script:clamscan = "C:\Program Files\ClamAV\clamscan.exe"
$script:clamd = "C:\Program Files\ClamAV\clamd.exe"
$script:clamdscan = "C:\Program Files\ClamAV\clamdscan.exe"

# Elasticsearch
$script:Elasticsearch = "$SCRIPT_DIR\Tools\Elasticsearch\bin\elasticsearch.bat"

# entropy
$script:entropy = "$SCRIPT_DIR\Tools\entropy\entropy.exe"

# EvtxECmd
$script:EvtxECmd = "$SCRIPT_DIR\Tools\EvtxECmd\EvtxECmd.exe"

# IPinfo CLI
$script:IPinfo = "$SCRIPT_DIR\Tools\IPinfo\ipinfo.exe"

# IPinfo CLI - Access Token
$Token = "access_token" # Please insert your Access Token here (Default: access_token)

# jq
$script:jq = "$SCRIPT_DIR\Tools\jq\jq-win64.exe"

# Kibana
$script:Kibana = "$SCRIPT_DIR\Tools\Kibana\bin\kibana.bat"

# lnk_parser
$script:lnk_parser = "$SCRIPT_DIR\Tools\lnk_parser\lnk_parser_x86_64.exe"

# MemProcFS
$script:MemProcFS = "$SCRIPT_DIR\Tools\MemProcFS\MemProcFS.exe"

# RECmd
$script:RECmd = "$SCRIPT_DIR\Tools\RECmd\RECmd.exe"

# SBECmd
$script:SBECmd = "$SCRIPT_DIR\Tools\SBECmd\SBECmd.exe"

# xsv
$script:xsv = "$SCRIPT_DIR\Tools\xsv\xsv.exe"

# YARA
$script:yara64 = "$SCRIPT_DIR\Tools\YARA\yara64.exe"

# Zircolite
$script:zircolite = "$SCRIPT_DIR\Tools\Zircolite\zircolite.exe"

# Archive Password
$script:PASSWORD = "MemProcFS"

# MemProcFS Logfile
New-Item "$SCRIPT_DIR\Logs" -ItemType Directory -Force | Out-Null
$script:MemProcFSLogfile = "$SCRIPT_DIR\Logs\MemProcFS.log"

# Process Whitelist (Forensic Mode)
# https://github.com/ufrisk/MemProcFS/wiki/_CommandLine#-forensic-process-skip
$script:ForensicProcessWhitelist = "cyserver.exe,MsMpEng.exe,tlaworker.exe"

# MsMpEng.exe   = Microsoft Defender
# cyserver.exe  = Palo Alto Cortex XDR
# tlaworker.exe = Palo Alto Cortex XDR

#endregion Declarations

#############################################################################################################################################################################################
#############################################################################################################################################################################################

#region Initialisations

# Set Progress Preference to Silently Continue
$OriginalProgressPreference = $Global:ProgressPreference
$Global:ProgressPreference = 'SilentlyContinue'

#endregion Initialisations

#############################################################################################################################################################################################
#############################################################################################################################################################################################

#region Header

Function Header {

# Windows Title
$script:DefaultWindowsTitle = $Host.UI.RawUI.WindowTitle
$Host.UI.RawUI.WindowTitle = "MemProcFS-Analyzer $Version - Automated Forensic Analysis of Windows Memory Dumps for DFIR"

# Check if MemProcFS.exe exists
if (!(Test-Path "$($MemProcFS)"))
{
    Write-Host "[Error] MemProcFS.exe NOT found." -ForegroundColor Red
    Write-Host "        Note: Please run 'Updater.ps1' to install MemProcFS-Analyzer (incl. all dependencies)." -ForegroundColor Red
    $Host.UI.RawUI.WindowTitle = "$DefaultWindowsTitle"
    Exit
}

# Check if the PowerShell script is being run with admin rights
if (!([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator))
{
    Write-Host "[Error] This PowerShell script must be run with admin rights." -ForegroundColor Red
    $Host.UI.RawUI.WindowTitle = "$DefaultWindowsTitle"
    Exit
}

# Check IPinfo CLI Access Token 
if ("$Token" -eq "access_token")
{
    Write-Host "[Error] No IPinfo CLI Access Token provided. Please add your personal access token in Line 159." -ForegroundColor Red
    $Host.UI.RawUI.WindowTitle = "$DefaultWindowsTitle"
    Exit
}

# Requirements

# Dokany File System Library
$Dokany = "$env:SystemDrive\Windows\System32\dokan2.dll"
if (!(Test-Path "$($Dokany)"))
{
    Write-Host "[Error] Dokany File System Library NOT found." -ForegroundColor Red
    Write-Host "        Please download/install the latest release of Dokany File System Library manually:" -ForegroundColor Red
    Write-Host "        https://github.com/dokan-dev/dokany/releases/latest (DokanSetup.exe)" -ForegroundColor Red
    $Host.UI.RawUI.WindowTitle = "$DefaultWindowsTitle"
    Exit
}

# EZTools
if (Get-Command -CommandType Application dotnet -ErrorAction SilentlyContinue)
{
    # TargetFramework (.NET 9)
    if (!(dotnet --list-runtimes | Select-String -Pattern "^Microsoft\.WindowsDesktop\.App 9" -Quiet))
    {
        Write-Host "[Error] Please download/install at least .NET 9.0 or newer manually:" -ForegroundColor Red
        Write-Host "        https://dotnet.microsoft.com/en-us/download/dotnet/9.0 (Recommended: .NET Desktop Runtime)" -ForegroundColor Red
        $Host.UI.RawUI.WindowTitle = "$DefaultWindowsTitle"
        Exit
    }
}
else
{
    Write-Host "[Error] Please download/install at least .NET 9.0 or newer manually:" -ForegroundColor Red
    Write-Host "        https://dotnet.microsoft.com/en-us/download/dotnet/9.0 (Recommended: .NET Desktop Runtime)" -ForegroundColor Red
    $Host.UI.RawUI.WindowTitle = "$DefaultWindowsTitle"
    Exit
}

# Function Get-FileSize
Function script:Get-FileSize {
    Param ([long]$Size)
    If ($Size -gt 1TB) {[string]::Format("{0:0.00} TB", $Size / 1TB)}
    ElseIf ($Size -gt 1GB) {[string]::Format("{0:0.00} GB", $Size / 1GB)}
    ElseIf ($Size -gt 1MB) {[string]::Format("{0:0.00} MB", $Size / 1MB)}
    ElseIf ($Size -gt 1KB) {[string]::Format("{0:0.00} KB", $Size / 1KB)}
    ElseIf ($Size -gt 0) {[string]::Format("{0:0.00} Bytes", $Size)}
    Else {""}
}

# Add the required MessageBox class (Windows PowerShell)
Add-Type -AssemblyName System.Windows.Forms

#############################################################################################################################################################################################

# User Interface

Function Show-UserInterface
{
    # Import Assemblies
    [void][reflection.assembly]::Load('System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
    [void][reflection.assembly]::Load('System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
    [void][reflection.assembly]::Load('System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')

    # Form Objects
    [System.Windows.Forms.Application]::EnableVisualStyles()
    $FormMemProcFSAnalyzer = New-Object 'System.Windows.Forms.Form'
    $Checkbox1 = New-Object 'System.Windows.Forms.CheckBox'
    $Checkbox2 = New-Object 'System.Windows.Forms.CheckBox'
    $Checkbox3 = New-Object 'System.Windows.Forms.CheckBox'
    $Checkbox4 = New-Object 'System.Windows.Forms.CheckBox'
    $CheckboxOfflineMode = New-Object 'System.Windows.Forms.CheckBox'
    $StatusBar = New-Object 'System.Windows.Forms.StatusBar'
    $StatusBarPanel1 = New-Object 'System.Windows.Forms.StatusBarPanel'
    $LabelMemoryDump = New-Object 'System.Windows.Forms.Label'
    $LabelPageFile = New-Object 'System.Windows.Forms.Label'
    $ButtonBrowse1 = New-Object 'System.Windows.Forms.Button'
    $ButtonBrowse2 = New-Object 'System.Windows.Forms.Button'
    $TextBoxFile1 = New-Object 'System.Windows.Forms.TextBox'
    $TextBoxFile2 = New-Object 'System.Windows.Forms.TextBox'
    $OpenFileDialog1 = New-Object 'System.Windows.Forms.OpenFileDialog'
    $OpenFileDialog2 = New-Object 'System.Windows.Forms.OpenFileDialog'
    $ButtonStart = New-Object 'System.Windows.Forms.Button'
    $ButtonExit = New-Object 'System.Windows.Forms.Button'
    $LinkLabel = New-Object 'System.Windows.Forms.LinkLabel'
    $ToolTip1 = New-Object 'System.Windows.Forms.ToolTip'
    $MenuStrip1 = New-Object 'System.Windows.Forms.MenuStrip'
    $FileToolStripMenuItem = New-Object 'System.Windows.Forms.ToolStripMenuItem'
    $CheckForUpdatesToolStripMenuItem = New-Object 'System.Windows.Forms.ToolStripMenuItem'
    $ExitToolStripMenuItem = New-Object 'System.Windows.Forms.ToolStripMenuItem'
    $HelpToolStripMenuItem = New-Object 'System.Windows.Forms.ToolStripMenuItem'
    $WikiToolStripMenuItem = New-Object 'System.Windows.Forms.ToolStripMenuItem'
    $MemProcFSToolStripMenuItem = New-Object 'System.Windows.Forms.ToolStripMenuItem'
    $MemProcFSWikiToolStripMenuItem = New-Object 'System.Windows.Forms.ToolStripMenuItem'
    $AboutToolStripMenuItem = New-Object 'System.Windows.Forms.ToolStripMenuItem'
    $GitHubToolStripMenuItem = New-Object 'System.Windows.Forms.ToolStripMenuItem'
    $InitialFormWindowState = New-Object 'System.Windows.Forms.FormWindowState'

    # Events
    $ButtonBrowseMemory_Click={
	
        if($OpenFileDialog1.ShowDialog() -eq 'OK')
        {
            $TextBoxFile1.Text = $OpenFileDialog1.FileName
            $ButtonStart.Enabled =$true
            $StatusBar.Text = "Ready"
        }
    }

    $ButtonBrowsePagefile_Click={
	
        if($OpenFileDialog2.ShowDialog() -eq 'OK')
        {
            $TextBoxFile2.Text = $OpenFileDialog2.FileName
        }
    }

    $LinkLabel_LinkClicked=[System.Windows.Forms.LinkLabelLinkClickedEventHandler]{
        Start-Process "https://github.com/LETHAL-FORENSICS/MemProcFS-Analyzer"
    }

    $ButtonExit_Click={
		$FormMemProcFSAnalyzer.Close()
	}

    $ExitToolStripMenuItem_Click={
		$FormMemProcFSAnalyzer.Close()
	}

    $CheckForUpdatesToolStripMenuItem_Click={

        $CurrentVersion = "1.2.0"

        $StatusBar.Text = "Checking latest release on GitHub ..."

        # Check for latest release on GitHub
        $Repository = "LETHAL-FORENSICS/MemProcFS-Analyzer"
        $Releases = "https://api.github.com/repos/$Repository/releases"
        [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
        if (Test-Connection -ComputerName 8.8.8.8 -Count 1 -Quiet -ErrorAction SilentlyContinue)
		{
            $Response = (Invoke-WebRequest -Uri $Releases -UseBasicParsing -TimeoutSec 30 | ConvertFrom-Json)[0]
            $Tag = $Response.tag_name
            $LatestRelease = $Tag.Substring(1)

            # Outdated
            if ($CurrentVersion -lt $LatestRelease)
            {
                $MessageBody = "Latest Release: MemProcFS-Analyzer v$LatestRelease`n`nNote: You will be automatically redirected."
                $MessageTitle = "MemProcFS-Analyzer v$CurrentVersion - Update available"
                $ButtonType = "OKCancel"
                $MessageIcon = "Warning"
                $StatusBar.Text = "Latest Version: MemProcFS-Analyzer v$LatestRelease"
                $Result = [System.Windows.Forms.MessageBox]::Show($MessageBody, $MessageTitle, $ButtonType, $MessageIcon)

                if ($Result -eq "OK")
                {
                    Start-Process "https://github.com/LETHAL-FORENSICS/MemProcFS-Analyzer/releases/latest"
                }
            }
            
            # Up-To-Date
            if ($CurrentVersion -eq $LatestRelease)
            {
                $MessageBody = "MemProcFS-Analyzer v$CurrentVersion`nCopyright (c) 2021-2025 Martin Willing`n`nYou are using the latest version of MemProcFS-Analyzer."
                $MessageTitle = "MemProcFS-Analyzer"
                $ButtonType = "OK"
                $MessageIcon = "Info"
                $StatusBar.Text = "Latest Version: MemProcFS-Analyzer v$LatestRelease"
                [System.Windows.Forms.MessageBox]::Show($MessageBody, $MessageTitle, $ButtonType, $MessageIcon)
            }

            # Beta-Tester
            if ($CurrentVersion -gt $LatestRelease)
            {
                $MessageBody = "MemProcFS-Analyzer v$CurrentVersion`nCopyright (c) 2021-2025 Martin Willing`n`nHello Beta-Tester. Happy Testing! ;-)"
                $MessageTitle = "MemProcFS-Analyzer"
                $ButtonType = "OK"
                $MessageIcon = "Info"
                $StatusBar.Text = "Latest Version: MemProcFS-Analyzer v$LatestRelease"
                [System.Windows.Forms.MessageBox]::Show($MessageBody, $MessageTitle, $ButtonType, $MessageIcon)

                if(Test-Path $TextBoxFile1.Text)
                {
                    $StatusBar.Text = "Ready"
                }
                else
                {
                    $StatusBar.Text = ""
                }
            }
        }
        else
        {
            $StatusBar.Text = "Session Timeout"
        }
    }
	
	$GitHubToolStripMenuItem_Click = {
		Start-Process "https://github.com/LETHAL-FORENSICS/MemProcFS-Analyzer"
	}
	
	$WikiToolStripMenuItem_Click={
		Start-Process "https://github.com/LETHAL-FORENSICS/MemProcFS-Analyzer/wiki"
	}

    $MemProcFSToolStripMenuItem_Click = {
		Start-Process "https://github.com/ufrisk/MemProcFS"
	}

    $MemProcFSWikiToolStripMenuItem_Click = {
		Start-Process "https://github.com/ufrisk/MemProcFS/wiki"
	}

    $AboutToolStripMenuItem_Click = {
        $MessageBody = "MemProcFS-Analyzer $Version`nCopyright (c) 2021-2025 Martin Willing"
        $MessageTitle = "MemProcFS-Analyzer"
        $ButtonType = "OK"
        $MessageIcon = "Info"
        [System.Windows.Forms.MessageBox]::Show($MessageBody, $MessageTitle, $ButtonType, $MessageIcon)
	}

    $Checkbox1_CheckedChanged =
    {
        if($Checkbox1.Checked -eq $true)
	    {
            # Custom YARA Rules - Enabled
            $script:YaraRules = "$SCRIPT_DIR\yara\index.yar"
        }
        
        if($Checkbox1.Checked -eq $false)
        {
            # Custom YARA Rules - Disabled
            $script:YaraRules = $null
        }
    }

    $Checkbox2_CheckedChanged =
    {
        if($Checkbox2.Checked -eq $true)
	    {
            # ClamAV Scan - Enabled
            $script:ClamAV = "Enabled"
        }
        
        if($Checkbox2.Checked -eq $false)
        {
            # ClamAV Scan - Disabled
            $script:ClamAV = $null
        }
    }

    $Checkbox3_CheckedChanged =
    {
        if($Checkbox3.Checked -eq $true)
	    {
            # Forensic Timeline (CSV) - Enabled
            $script:ForensicTimelineCSV = "Enabled"
        }
        
        if($Checkbox3.Checked -eq $false)
        {
            # Forensic Timeline (CSV) - Disabled
            $script:ForensicTimelineCSV = $null
        }
    }

    $Checkbox4_CheckedChanged =
    {
        if($Checkbox4.Checked -eq $true)
	    {
            # Forensic Timeline (XLSX) - Enabled
            $script:ForensicTimelineXLSX = "Enabled"
        }
        
        if($Checkbox4.Checked -eq $false)
        {
            # Forensic Timeline (XLSX) - Disabled
            $script:ForensicTimelineXLSX = $null
        }
    }

    $CheckboxOfflineMode_CheckedChanged =
    {
        if($CheckboxOfflineMode.Checked -eq $true)
	    {
            # Offline Mode - Enabled
            $script:OfflineMode = "Enabled"
        }

        if($CheckboxOfflineMode.Checked -eq $false)
        {
            # Offline Mode - Disabled
            $script:OfflineMode = $null
        }
    }

    $Form_StateCorrection_Load =
    {
        $FormMemProcFSAnalyzer.WindowState = $InitialFormWindowState
    }

    $Form_StoreValues_Closing =
    {
        $script:MemoryDump = $TextBoxFile1.Text
        $script:Pagefile = $TextBoxFile2.Text
    }

    $Form_Cleanup_FormClosed =
    {
        try
        {
            $Checkbox1.remove_CheckedChanged($Checkbox1_CheckedChanged)
            $Checkbox2.remove_CheckedChanged($Checkbox2_CheckedChanged)
            $Checkbox3.remove_CheckedChanged($Checkbox3_CheckedChanged)
            $Checkbox4.remove_CheckedChanged($Checkbox4_CheckedChanged)
            $CheckboxOfflineMode.remove_CheckedChanged($CheckboxOfflineMode_CheckedChanged)
            $ButtonBrowse1.remove_Click($ButtonBrowseMemory_Click)
            $ButtonBrowse2.remove_Click($ButtonBrowsePagefile_Click)
            $ButtonStart.remove_MouseClick($ButtonStart_Click)
            $ButtonExit.remove_MouseClick($ButtonExit_Click)
            $LinkLabel.remove_LinkClicked($LinkLabel_LinkClicked)
            $FormMemProcFSAnalyzer.remove_Load($FormMemProcFSAnalyzer_Load)
            $CheckForUpdatesToolStripMenuItem.remove_Click($checkForUpdatesToolStripMenuItem_Click)
            $ExitToolStripMenuItem.remove_Click($exitToolStripMenuItem_Click)
            $WikiToolStripMenuItem.remove_Click($wikiToolStripMenuItem_Click)
            $MemProcFSToolStripMenuItem.remove_Click($MemProcFSToolStripMenuItem_Click)
            $MemProcFSWikiToolStripMenuItem.remove_Click($MemProcFSWikiToolStripMenuItem_Click)
            $AboutToolStripMenuItem.remove_Click($AboutToolStripMenuItem_Click)
            $GitHubToolStripMenuItem.remove_Click($GitHubToolStripMenuItem_Click)
            $FormMemProcFSAnalyzer.remove_Load($Form_StateCorrection_Load)
            $FormMemProcFSAnalyzer.remove_Closing($Form_StoreValues_Closing)
            $FormMemProcFSAnalyzer.remove_FormClosed($Form_Cleanup_FormClosed)
        }
        catch { Out-Null }
    }

    # Form Code
    $FormMemProcFSAnalyzer.SuspendLayout()
    $MenuStrip1.SuspendLayout()

    # FormMemProcFSAnalyzer
    $FormMemProcFSAnalyzer.Controls.Add($Checkbox1)
    $FormMemProcFSAnalyzer.Controls.Add($Checkbox2)
    $FormMemProcFSAnalyzer.Controls.Add($Checkbox3)
    $FormMemProcFSAnalyzer.Controls.Add($Checkbox4)
    $FormMemProcFSAnalyzer.Controls.Add($CheckboxOfflineMode)
    $FormMemProcFSAnalyzer.Controls.Add($StatusBar)
    $FormMemProcFSAnalyzer.Controls.Add($LabelMemoryDump)
    $FormMemProcFSAnalyzer.Controls.Add($LabelPageFile)
    $FormMemProcFSAnalyzer.Controls.Add($ButtonBrowse1)
	$FormMemProcFSAnalyzer.Controls.Add($ButtonBrowse2)
    $FormMemProcFSAnalyzer.Controls.Add($TextBoxFile1)
    $FormMemProcFSAnalyzer.Controls.Add($TextBoxFile2)
    $FormMemProcFSAnalyzer.Controls.Add($ButtonStart)
    $FormMemProcFSAnalyzer.Controls.Add($ButtonExit)
    $FormMemProcFSAnalyzer.Controls.Add($LinkLabel)
    $FormMemProcFSAnalyzer.Controls.Add($MenuStrip1)
    $FormMemProcFSAnalyzer.AutoScaleDimensions = New-Object System.Drawing.SizeF(6, 13)
    $FormMemProcFSAnalyzer.AutoScaleMode = 'Font'
    $FormMemProcFSAnalyzer.ClientSize = New-Object System.Drawing.Size(626, 262)
	$FormMemProcFSAnalyzer.FormBorderStyle = 'FixedDialog'
    $FormMemProcFSAnalyzer.MainMenuStrip = $Menustrip1
    $FormMemProcFSAnalyzer.MaximizeBox = $False
    $FormMemProcFSAnalyzer.MinimizeBox = $False
    $FormMemProcFSAnalyzer.Name = 'FormMemProcFSAnalyzer'
    $FormMemProcFSAnalyzer.StartPosition = 'CenterScreen'
    $FormMemProcFSAnalyzer.Text = "MemProcFS-Analyzer $Version - Automated Forensic Analysis of Windows Memory Dumps for DFIR"
    $FormMemProcFSAnalyzer.TopLevel = $True
    $FormMemProcFSAnalyzer.TopMost = $True
    $FormMemProcFSAnalyzer.Add_Shown({$FormMemProcFSAnalyzer.Activate()})

    # Checkbox1
    $Checkbox1.Location = New-Object System.Drawing.Point(96, 131)
	$Checkbox1.Name = 'Checkbox1'
	$Checkbox1.Size = New-Object System.Drawing.Size(172, 24)
	$Checkbox1.TabIndex = 9
	$Checkbox1.Text = 'Enable Custom YARA rules'
	$Checkbox1.UseVisualStyleBackColor = $True
    $Checkbox1.add_CheckedChanged($Checkbox1_CheckedChanged)

    # Checkbox2
    $Checkbox2.Location = New-Object System.Drawing.Point(96, 151)
	$Checkbox2.Name = 'Checkbox2'
	$Checkbox2.Size = New-Object System.Drawing.Size(155, 24)
	$Checkbox2.TabIndex = 10
	$Checkbox2.Text = 'Enable ClamAV Scan'
	$Checkbox2.UseVisualStyleBackColor = $True
	$Checkbox2.add_CheckedChanged($Checkbox2_CheckedChanged)

    # Checkbox3
    $Checkbox3.Location = New-Object System.Drawing.Point(270, 131)
	$Checkbox3.Name = 'Checkbox3'
	$Checkbox3.Size = New-Object System.Drawing.Size(200, 24)
    $Checkbox3.TabIndex = 11
    $Checkbox3.Text = 'Enable Forensic Timeline (CSV)'
    $Checkbox3.UseVisualStyleBackColor = $True
    $Checkbox3.add_CheckedChanged($Checkbox3_CheckedChanged)

    # Checkbox4
    $Checkbox4.Location = New-Object System.Drawing.Point(270, 151)
	$Checkbox4.Name = 'Checkbox4'
    $Checkbox4.Size = New-Object System.Drawing.Size(200, 24)
	$Checkbox4.TabIndex = 12
    $Checkbox4.Text = 'Enable Forensic Timeline (XLSX)'
	$Checkbox4.UseVisualStyleBackColor = $True
    $Checkbox4.add_CheckedChanged($Checkbox4_CheckedChanged)

    # CheckBoxOfflineMode
    $CheckboxOfflineMode.Location = New-Object System.Drawing.Point(339, 200)
    $CheckboxOfflineMode.Name = 'CheckboxOfflineMode'
    $CheckboxOfflineMode.Size = New-Object System.Drawing.Size(92, 24)
    $CheckboxOfflineMode.TabIndex = 13
    $CheckboxOfflineMode.Text = 'Offline Mode'
    $CheckboxOfflineMode.UseVisualStyleBackColor = $True
    $CheckboxOfflineMode.add_CheckedChanged($CheckboxOfflineMode_CheckedChanged)
    $ToolTip1.SetToolTip($CheckboxOfflineMode, 'Offline Mode')
    
    # Status Bar
    $StatusBar.Location = New-Object System.Drawing.Point(0, 240)
    $StatusBar.Name = 'StatusBar'
    [void]$StatusBar.Panels.Add($StatusBarPanel1)
    $StatusBar.Size = New-Object System.Drawing.Size(626, 22)
    $StatusBar.SizingGrip = $False
    $StatusBar.TabIndex = 0

    # LabelMemoryDump
    $LabelMemoryDump.AutoSize = $True
    $LabelMemoryDump.Location = New-Object System.Drawing.Point(12, 38)
    $LabelMemoryDump.Name = 'LabelMemoryDump'
    $LabelMemoryDump.Size = New-Object System.Drawing.Size(78, 13)
    $LabelMemoryDump.TabIndex = 4
    $LabelMemoryDump.Text = 'Memory Dump:'

    # LabelPageFile
    $LabelPageFile.AutoSize = $True
    $LabelPageFile.Location = New-Object System.Drawing.Point(36, 87)
    $LabelPageFile.Name = 'LabelPageFile'
    $LabelPageFile.Size = New-Object System.Drawing.Size(54, 13)
    $LabelPageFile.TabIndex = 3
    $LabelPageFile.Text = 'Page File:'

    # ButtonBrowse1
    $ButtonBrowse1.Location = New-Object System.Drawing.Point(539, 33)
    $ButtonBrowse1.Name = 'ButtonBrowse1'
    $ButtonBrowse1.Size = New-Object System.Drawing.Size(75, 23)
    $ButtonBrowse1.TabIndex = 0
    $ButtonBrowse1.Text = 'Browse'
    $ButtonBrowse1.UseVisualStyleBackColor = $True
    $ButtonBrowse1.add_Click($ButtonBrowseMemory_Click)
    $ToolTip1.SetToolTip($ButtonBrowse1, 'Select your Raw Physical Memory Dump')

    # ButtonBrowse2
    $ButtonBrowse2.Location = New-Object System.Drawing.Point(539, 84)
    $ButtonBrowse2.Name = 'ButtonBrowse2'
    $ButtonBrowse2.Size = New-Object System.Drawing.Size(75, 23)
    $ButtonBrowse2.TabIndex = 1
    $ButtonBrowse2.Text = 'Browse'
    $ButtonBrowse2.UseVisualStyleBackColor = $True
    $ButtonBrowse2.add_Click($ButtonBrowsePagefile_Click)
    $ToolTip1.SetToolTip($ButtonBrowse2, 'Select your pagefile.sys (Optional)')

    # TextBoxFile1
    $TextBoxFile1.AccessibleRole = 'None'
    $TextBoxFile1.AutoCompleteMode = 'SuggestAppend'
    $TextBoxFile1.AutoCompleteSource = 'FileSystem'
    $TextBoxFile1.BackColor = [System.Drawing.SystemColors]::Window 
    $TextBoxFile1.Cursor = 'Default'
    $TextBoxFile1.ForeColor = [System.Drawing.SystemColors]::WindowText 
    $TextBoxFile1.Location = New-Object System.Drawing.Point(96, 35)
    $TextBoxFile1.Name = 'TextBoxFile'
    $TextBoxFile1.ReadOnly = $True
    $TextBoxFile1.ShortcutsEnabled = $False
    $TextBoxFile1.Size = New-Object System.Drawing.Size(437, 20)
    $TextBoxFile1.TabIndex = 4
    $TextBoxFile1.TabStop = $False
    $TextBoxFile1.Text = 'Select your Raw Physical Memory Dump'
    $ToolTip1.SetToolTip($TextBoxFile1, 'Select your Raw Physical Memory Dump')

    # TextBoxFile2
    $TextBoxFile2.AccessibleRole = 'None'
    $TextBoxFile2.AutoCompleteMode = 'SuggestAppend'
    $TextBoxFile2.AutoCompleteSource = 'FileSystem'
    $TextBoxFile2.BackColor = [System.Drawing.SystemColors]::Window 
    $TextBoxFile2.Cursor = 'Default'
    $TextBoxFile2.ForeColor = [System.Drawing.SystemColors]::WindowText 
    $TextBoxFile2.Location = New-Object System.Drawing.Point(96, 84)
    $TextBoxFile2.Name = 'TextBoxFile2'
    $TextBoxFile2.ReadOnly = $True
    $TextBoxFile2.Size = New-Object System.Drawing.Size(437, 20)
    $TextBoxFile2.TabIndex = 5
    $TextBoxFile2.TabStop = $False
    $TextBoxFile2.Text = 'Select your pagefile.sys (Optional)'
    $ToolTip1.SetToolTip($TextBoxFile2, 'Select your pagefile.sys (Optional)')

    # OpenFileDialog1
    $OpenFileDialog1.Filter = 'Memory Dump Files (*.001;*.bin;*.dmp;*.img;*.mem;*.raw;*.vmem)|*.001;*.bin;*.dmp;*.img;*.mem;*.raw;*.vmem|All Files (*.*)|*.*'
    $OpenFileDialog1.InitialDirectory = "::{20D04FE0-3AEA-1069-A2D8-08002B30309D}" # MyComputer
    $OpenFileDialog1.ReadOnlyChecked = $True
    $OpenFileDialog1.Title = "MemProcFS-Analyzer $Version - Select your Raw Physical Memory Dump"

    # OpenFileDialog2
    $OpenFileDialog2.Filter = 'Page Files (*.sys)|*.sys|All Files (*.*)|*.*'
    $OpenFileDialog2.ReadOnlyChecked = $True
    $OpenFileDialog2.Title = "MemProcFS-Analyzer $Version - Select your pagefile.sys (Optional)"

    # ButtonStart
    $ButtonStart.DialogResult = 'OK'
    $ButtonStart.Enabled = $False
    $ButtonStart.Location = New-Object System.Drawing.Point(446, 202)
    $ButtonStart.Name = 'ButtonStart'
    $ButtonStart.Size = New-Object System.Drawing.Size(75, 23)
    $ButtonStart.TabIndex = 2
    $ButtonStart.Text = 'Start'
    $ButtonStart.UseCompatibleTextRendering = $True
    $ButtonStart.UseVisualStyleBackColor = $True
    $ButtonStart.Add_Click($ButtonStart_Click)
    $ToolTip1.SetToolTip($ButtonStart, 'Start')

    # ButtonExit
    $ButtonExit.DialogResult = 'Cancel'
    $ButtonExit.Location = New-Object System.Drawing.Point(539, 202)
    $ButtonExit.Name = 'ButtonExit'
    $ButtonExit.Size = New-Object System.Drawing.Size(75, 23)
    $ButtonExit.TabIndex = 3
    $ButtonExit.Text = 'Exit'
    $ButtonExit.UseCompatibleTextRendering = $True
    $ButtonExit.UseVisualStyleBackColor = $True
    $ButtonExit.Add_MouseClick($ButtonExit_Click)
    $ToolTip1.SetToolTip($ButtonExit, 'Exit')

    # LinkLabel
    $LinkLabel.Location = New-Object System.Drawing.Point(12, 204)
    $LinkLabel.Name = 'LinkLabel'
    $LinkLabel.Size = New-Object System.Drawing.Size(269, 23)
    $LinkLabel.TabIndex = 7
    $LinkLabel.TabStop = $True
    $LinkLabel.Text = 'https://github.com/evild3ad/MemProcFS-Analyzer'
    $LinkLabel.Add_LinkClicked($linklabel_LinkClicked)

    # MenuStrip1
    [void]$MenuStrip1.Items.Add($FileToolStripMenuItem)
    [void]$MenuStrip1.Items.Add($HelpToolStripMenuItem)
    $MenuStrip1.Location = New-Object System.Drawing.Point(0, 0)
    $MenuStrip1.Name = 'MenuStrip1'
    $MenuStrip1.Size = New-Object System.Drawing.Size(626, 24)
    $MenuStrip1.TabIndex = 8
    $MenuStrip1.Text = 'MenuStrip1'

    # FileToolStripMenuItem
    [void]$fileToolStripMenuItem.DropDownItems.Add($CheckForUpdatesToolStripMenuItem)
    [void]$FileToolStripMenuItem.DropDownItems.Add($ExitToolStripMenuItem)
    $FileToolStripMenuItem.Name = 'FileToolStripMenuItem'
    $FileToolStripMenuItem.Size = New-Object System.Drawing.Size(37, 20)
    $FileToolStripMenuItem.Text = 'File'

    # HelpToolStripMenuItem
    [void]$HelpToolStripMenuItem.DropDownItems.Add($GitHubToolStripMenuItem)
    [void]$HelpToolStripMenuItem.DropDownItems.Add($WikiToolStripMenuItem)
    [void]$HelpToolStripMenuItem.DropDownItems.Add($MemProcFSToolStripMenuItem)
    [void]$HelpToolStripMenuItem.DropDownItems.Add($MemProcFSWikiToolStripMenuItem)
    [void]$HelpToolStripMenuItem.DropDownItems.Add($AboutToolStripMenuItem)
    $HelpToolStripMenuItem.Name = 'HelpToolStripMenuItem'
    $HelpToolStripMenuItem.Size = New-Object System.Drawing.Size(44, 20)
    $HelpToolStripMenuItem.Text = 'Help'

    # CheckForUpdatesToolStripMenuItem
	$CheckForUpdatesToolStripMenuItem.Name = 'CheckForUpdatesToolStripMenuItem'
    $CheckForUpdatesToolStripMenuItem.Size = New-Object System.Drawing.Size(180, 22)
    $CheckForUpdatesToolStripMenuItem.Text = 'Check for Updates...'
    $CheckForUpdatesToolStripMenuItem.ToolTipText = 'Check for Updates...'
    $CheckForUpdatesToolStripMenuItem.add_Click($CheckForUpdatesToolStripMenuItem_Click)

    # ExitToolStripMenuItem
    $ExitToolStripMenuItem.Name = 'ExitToolStripMenuItem'
    $ExitToolStripMenuItem.Size = New-Object System.Drawing.Size(180, 22)
    $ExitToolStripMenuItem.Text = 'Exit'
    $ExitToolStripMenuItem.ToolTipText = 'Exit'
    $ExitToolStripMenuItem.Add_Click($ExitToolStripMenuItem_Click)

    # GitHubToolStripMenuItem
    $GitHubToolStripMenuItem.Name = 'GitHubToolStripMenuItem'
    $GitHubToolStripMenuItem.Size = New-Object System.Drawing.Size(152, 22)
    $GitHubToolStripMenuItem.Text = 'GitHub'
    $GitHubToolStripMenuItem.ToolTipText = 'GitHub'
    $GitHubToolStripMenuItem.Add_Click($GitHubToolStripMenuItem_Click)

    # WikiToolStripMenuItem
    $WikiToolStripMenuItem.Name = 'WikiToolStripMenuItem'
    $WikiToolStripMenuItem.Size = New-Object System.Drawing.Size(152, 22)
    $WikiToolStripMenuItem.Text = 'GitHub Wiki'
    $WikiToolStripMenuItem.ToolTipText = 'GitHub Wiki'
    $WikiToolStripMenuItem.Add_Click($WikiToolStripMenuItem_Click)

    # MemProcFSToolStripMenuItem
    $MemProcFSToolStripMenuItem.Name = 'MemProcFSToolStripMenuItem'
    $MemProcFSToolStripMenuItem.Size = New-Object System.Drawing.Size(152, 22)
    $MemProcFSToolStripMenuItem.Text = 'MemProcFS'
    $MemProcFSToolStripMenuItem.ToolTipText = 'MemProcFS - The Memory Process File System'
    $MemProcFSToolStripMenuItem.Add_Click($MemProcFSToolStripMenuItem_Click)

    # MemProcFSWikiToolStripMenuItem
    $MemProcFSWikiToolStripMenuItem.Name = 'MemProcFSWikiToolStripMenuItem'
    $MemProcFSWikiToolStripMenuItem.Size = New-Object System.Drawing.Size(152, 22)
    $MemProcFSWikiToolStripMenuItem.Text = 'MemProcFS Wiki'
    $MemProcFSWikiToolStripMenuItem.ToolTipText = 'MemProcFS Wiki'
    $MemProcFSWikiToolStripMenuItem.Add_Click($MemProcFSWikiToolStripMenuItem_Click)

    # AboutToolStripMenuItem
    $AboutToolStripMenuItem.Name = 'AboutToolStripMenuItem'
    $AboutToolStripMenuItem.Size = New-Object System.Drawing.Size(152, 22)
    $AboutToolStripMenuItem.Text = 'About'
    $AboutToolStripMenuItem.ToolTipText = 'About'
    $AboutToolStripMenuItem.Add_Click($AboutToolStripMenuItem_Click)

    $MenuStrip1.ResumeLayout()
    $FormMemProcFSAnalyzer.ResumeLayout()

    # Save the initial state of the form
    $InitialFormWindowState = $FormMemProcFSAnalyzer.WindowState
    $FormMemProcFSAnalyzer.Add_Load($Form_StateCorrection_Load)
    $FormMemProcFSAnalyzer.Add_FormClosed($Form_Cleanup_FormClosed)
    $FormMemProcFSAnalyzer.Add_Closing($Form_StoreValues_Closing)
    return $FormMemProcFSAnalyzer.ShowDialog((New-Object System.Windows.Forms.Form -Property @{TopMost = $true}))
}

$Result = Show-UserInterface

if($Result -eq "OK")
{
    if ($Pagefile -eq "Select your pagefile.sys (Optional)")
    {
        $script:Pagefile = $null
    }
}
else
{
    $Host.UI.RawUI.WindowTitle = "$DefaultWindowsTitle"
    Exit
}

#############################################################################################################################################################################################

# FileName
$script:FileName = $MemoryDump.Split('\')[-1] | ForEach-Object{($_ -replace "\..*","")}

# Output Directory
$script:OUTPUT_FOLDER = "$SCRIPT_DIR\$Timestamp-$FileName"

# Drive Letter (Mount Point)
[char[]]$Taken = (Get-PSDrive -Name [A-Z]).Name
$script:DriveLetter = ([char[]]([int][char]"D" .. [int][char]"Z")).Where({ $_ -notin $Taken }, "First")[0] + ":"
if (!$script:DriveLetter)
{
    Write-Host "[Error] No Drive Letter available." -ForegroundColor Red
    $Host.UI.RawUI.WindowTitle = "$DefaultWindowsTitle"
    Exit
}

# Create a record of your PowerShell session to a text file
Start-Transcript -Path "$SCRIPT_DIR\$Timestamp-$FileName.txt"

# Get Start Times
$script:StartTime_Processing = (Get-Date)
$script:StartTime_Analysis = (Get-Date)

# Logo
$Logo = @"
██╗     ███████╗████████╗██╗  ██╗ █████╗ ██╗      ███████╗ ██████╗ ██████╗ ███████╗███╗   ██╗███████╗██╗ ██████╗███████╗
██║     ██╔════╝╚══██╔══╝██║  ██║██╔══██╗██║      ██╔════╝██╔═══██╗██╔══██╗██╔════╝████╗  ██║██╔════╝██║██╔════╝██╔════╝
██║     █████╗     ██║   ███████║███████║██║█████╗█████╗  ██║   ██║██████╔╝█████╗  ██╔██╗ ██║███████╗██║██║     ███████╗
██║     ██╔══╝     ██║   ██╔══██║██╔══██║██║╚════╝██╔══╝  ██║   ██║██╔══██╗██╔══╝  ██║╚██╗██║╚════██║██║██║     ╚════██║
███████╗███████╗   ██║   ██║  ██║██║  ██║███████╗ ██║     ╚██████╔╝██║  ██║███████╗██║ ╚████║███████║██║╚██████╗███████║
╚══════╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚══════╝ ╚═╝      ╚═════╝ ╚═╝  ╚═╝╚══════╝╚═╝  ╚═══╝╚══════╝╚═╝ ╚═════╝╚══════╝
"@

Write-Host ""
Write-Host "$Logo"

# Header
Write-Output ""
Write-Output "MemProcFS-Analyzer $Version - Automated Forensic Analysis of Windows Memory Dumps for DFIR"
Write-Output "(c) 2021-2025 Martin Willing at Lethal-Forensics (https://lethal-forensics.com/)"
Write-Output ""

# Analysis date (ISO 8601)
$AnalysisDate = $Date -replace "T", " " # YYYY-MM-DD hh:mm:ss
Write-Output "Analysis date: $AnalysisDate UTC"
Write-Output ""

}

#endregion Header

#############################################################################################################################################################################################
#############################################################################################################################################################################################

#region Elasticsearch

Function Elasticsearch {

# Launch Elasticsearch (PowerShell.exe)
Write-Output "[Info]  Starting Elasticsearch ... "
$Elasticsearch_Process = Start-Process powershell.exe "& $Elasticsearch" -WindowStyle Minimized -PassThru
$Elasticsearch_Id = $Elasticsearch_Process.Id
$script:Elasticsearch_Termination = Get-Process | Where-Object {$_.Id -eq $Elasticsearch_Id}
$ProgressPreference = 'SilentlyContinue'
do {
  Start-Sleep 3
  $ProgressPreference = 'SilentlyContinue'
} until( Test-NetConnection 127.0.0.1 -Port 9200 -InformationLevel Quiet -ErrorAction SilentlyContinue -WarningAction SilentlyContinue)

# Launch Kibana (PowerShell.exe)
Write-Output "[Info]  Starting Kibana ... "
$Kibana_Process = Start-Process powershell.exe "& $Kibana" -WindowStyle Minimized -PassThru
$Kibana_Id = $Kibana_Process.Id
$script:Kibana_Termination = Get-Process | Where-Object {$_.Id -eq $Kibana_Id}
$ProgressPreference = 'SilentlyContinue'
do {
  Start-Sleep 3
  $ProgressPreference = 'SilentlyContinue'
} until(Test-NetConnection localhost -Port 5601 -InformationLevel Quiet -ErrorAction SilentlyContinue -WarningAction SilentlyContinue)

Start-Sleep 2

}

#endregion Elasticsearch

#############################################################################################################################################################################################
#############################################################################################################################################################################################

#region MemProcFS

Function MemProcFS {

# MemProcFS
# https://github.com/ufrisk/MemProcFS

# Remove existing MemProcFS Logfile
if (Test-Path "$($MemProcFSLogfile)")
{
    Remove-Item -Path "$MemProcFSLogfile" -Force
}

# Mount the physical memory dump file with a corresponding Pagefile and enable forensic mode
if (Test-Path "$($MemProcFS)")
{
    if (Test-Path "$($MemoryDump)")
    {
        if ($Pagefile)
        {
            if (Test-Path "$($Pagefile)")
            {
                Write-Output "[Info]  Mounting the Physical Memory Dump file with a corresponding Pagefile as $DriveLetter ..."

                $MemorySize = Get-FileSize((Get-Item "$MemoryDump").Length)
                Write-Output "[Info]  Physical Memory Dump File Size: $MemorySize"

                $PagefileSize = Get-FileSize((Get-Item -Force "$Pagefile").Length)
                Write-Output "[Info]  Pagefile Size: $PagefileSize"
                New-Item "$OUTPUT_FOLDER" -ItemType Directory -Force | Out-Null
                $Mount = $DriveLetter -replace ":", ""
                $StartTime_MemProcFS = (Get-Date)

                # Check if a Custom Yara rule or Yara index file was provided
                if ($null -eq $YaraRules)
                {
                    # Offline Mode
                    if ($OfflineMode -eq "Enabled")
                    {
                        Write-Output "[Info]  MemProcFS Forensic Analysis initiated [Offline-Mode] ..."
                    }
                    else
                    {
                        Write-Output "[Info]  MemProcFS Forensic Analysis initiated ..."
                    }

                    Write-Output "[Info]  Processing $MemoryDump incl. Pagefile [approx. 10-45 min] ..."
                    Start-Process -FilePath "$MemProcFS" -ArgumentList "-mount $Mount -device `"$MemoryDump`" -pagefile0 `"$Pagefile`" -disable-python -forensic 4 -loglevel forensic:5 -v -logfile `"$MemProcFSLogfile`""
                }
                else
                {
                    if ((Test-Path "$YaraRules") -And ((Get-Item "$YaraRules").length -gt 0kb))
                    {
                        # Check if Process Skiplist is inactive
                        if ($null -eq $ForensicProcessWhitelist)
                        {
                            # Offline Mode
                            if ($OfflineMode -eq "Enabled")
                            {
                                Write-Output "[Info]  MemProcFS Forensic Analysis initiated [Offline-Mode] ..."
                            }
                            else
                            {
                                Write-Output "[Info]  MemProcFS Forensic Analysis initiated ..."
                            }

                            $Count_YaraRules = (Get-Content -Path $YaraRules | Select-String -Pattern "^include" | Measure-Object).Count
                            Write-Output "[Info]  YARA scan initialized with $Count_YaraRules rules ..."
                            Write-Output "[Info]  Processing $MemoryDump incl. Pagefile [approx. 10-45 min] ..."
                            Start-Process -FilePath "$MemProcFS" -ArgumentList "-mount $Mount -device `"$MemoryDump`" -pagefile0 `"$Pagefile`" -disable-python -disable-yara-builtin -forensic-yara-rules `"$YaraRules`" -forensic 4 -loglevel forensic:5 -v -logfile `"$MemProcFSLogfile`""
                        }
                        else
                        {
                            $Count_YaraRules = (Get-Content -Path $YaraRules | Select-String -Pattern "^include" | Measure-Object).Count
                            $Count_ProcessSkip = ($ForensicProcessWhitelist.Split(",") | Where-Object {$_.Trim() -ne "" }).Count

                            # Offline Mode
                            if ($OfflineMode -eq "Enabled")
                            {
                                Write-Output "[Info]  MemProcFS Forensic Analysis initiated [Offline-Mode] ..."
                            }
                            else
                            {
                                Write-Output "[Info]  MemProcFS Forensic Analysis initiated ..."
                            }

                            Write-Output "[Info]  YARA scan initialized with $Count_YaraRules rules ($Count_ProcessSkip Process Names will be skipped) ..."
                            Write-Output "[Info]  Processing $MemoryDump incl. Pagefile [approx. 10-45 min] ..."
                            Start-Process -FilePath "$MemProcFS" -ArgumentList "-mount $Mount -device `"$MemoryDump`" -pagefile0 `"$Pagefile`" -disable-python -disable-yara-builtin -forensic-yara-rules `"$YaraRules`" -forensic 4 -loglevel forensic:5 -forensic-process-skip `"$ForensicProcessWhitelist`""
                        }
                    }
                }

                # Check if successfully mounted
                while (!(Test-Path "$($DriveLetter)"))
                {
                    Start-Sleep -Seconds 2
                }

                # Check forensic mode processing
                while (!(Select-String -Pattern "100" -Path "$DriveLetter\forensic\progress_percent.txt" -Quiet))
                {
                    Start-Sleep -Seconds 2
                }

                $EndTime_MemProcFS = (Get-Date)
                $Time_MemProcFS = ($EndTime_MemProcFS-$StartTime_MemProcFS)
                ('MemProcFS Processing duration: {0} h {1} min {2} sec' -f $Time_MemProcFS.Hours, $Time_MemProcFS.Minutes, $Time_MemProcFS.Seconds) >> "$OUTPUT_FOLDER\Stats.txt"
            }
        }
    }

    # Mount the physical memory dump file and enable forensic mode
    if ((Test-Path "$($MemoryDump)") -and (!("$($Pagefile)")))
    {
        Write-Output "[Info]  Mounting the Physical Memory Dump file as $DriveLetter ..."
        $MemorySize = Get-FileSize((Get-Item "$MemoryDump").Length)
        Write-Output "[Info]  Physical Memory Dump File Size: $MemorySize"
        New-Item "$OUTPUT_FOLDER" -ItemType Directory -Force | Out-Null
        $Mount = $DriveLetter -replace ":", ""
        $StartTime_MemProcFS = (Get-Date)
        
        # Check if a Custom Yara rule or Yara index file was provided
        if ($null -eq $YaraRules)
        {
            # Offline Mode
            if ($OfflineMode -eq "Enabled")
            {
                Write-Output "[Info]  MemProcFS Forensic Analysis initiated [Offline-Mode] ..."
            }
            else
            {
                Write-Output "[Info]  MemProcFS Forensic Analysis initiated ..."
            }

            Write-Output "[Info]  Processing $MemoryDump [approx. 1-10 min] ..."
            Start-Process -FilePath "$MemProcFS" -ArgumentList "-mount $Mount -device `"$MemoryDump`" -disable-python -forensic 4 -loglevel forensic:5 -v -logfile `"$MemProcFSLogfile`" -forensic-process-skip `"$ForensicProcessWhitelist`""
        }
        else
        {
            if ((Test-Path "$YaraRules") -And ((Get-Item "$YaraRules").length -gt 0kb))
            {
                # Check if Process Skiplist is inactive
                if ($null -eq $ForensicProcessWhitelist)
                {
                    # Offline Mode
                    if ($OfflineMode -eq "Enabled")
                    {
                        Write-Output "[Info]  MemProcFS Forensic Analysis initiated [Offline-Mode] ..."
                    }
                    else
                    {
                        Write-Output "[Info]  MemProcFS Forensic Analysis initiated ..."
                    }

                    $Count_YaraRules = (Get-Content -Path $YaraRules | Select-String -Pattern "^include" | Measure-Object).Count
                    Write-Output "[Info]  YARA scan initialized with $Count_YaraRules rules ..."
                    Write-Output "[Info]  Processing $MemoryDump [approx. 1-10 min] ..."
                    Start-Process -FilePath "$MemProcFS" -ArgumentList "-mount $Mount -device `"$MemoryDump`" -disable-python -disable-yara-builtin -forensic-yara-rules `"$YaraRules`" -forensic 4 -loglevel forensic:5 -v -logfile `"$MemProcFSLogfile`""
                }
                else
                {
                    # Offline Mode
                    if ($OfflineMode -eq "Enabled")
                    {
                        Write-Output "[Info]  MemProcFS Forensic Analysis initiated [Offline-Mode] ..."
                    }
                    else
                    {
                        Write-Output "[Info]  MemProcFS Forensic Analysis initiated ..."
                    }

                    $Count_YaraRules = (Get-Content -Path $YaraRules | Select-String -Pattern "^include" | Measure-Object).Count
                    $Count_ProcessSkip = ($ForensicProcessWhitelist.Split(",") | Where-Object {$_.Trim() -ne "" }).Count
                    Write-Output "[Info]  YARA scan initialized with $Count_YaraRules rules ($Count_ProcessSkip Process Names will be skipped) ..."
                    Write-Output "[Info]  Processing $MemoryDump [approx. 1-10 min] ..."
                    Start-Process -FilePath "$MemProcFS" -ArgumentList "-mount $Mount -device `"$MemoryDump`" -disable-python -disable-yara-builtin -forensic-yara-rules `"$YaraRules`" -forensic 4 -loglevel forensic:5 -v -logfile `"$MemProcFSLogfile`" -forensic-process-skip `"$ForensicProcessWhitelist`""
                }
            }
        }

        # Check if successfully mounted
        while (!(Test-Path "$($DriveLetter)"))
        {
            Start-Sleep -Seconds 2
        }

        # Check forensic mode processing
        while (!(Select-String -Pattern "100" -Path "$DriveLetter\forensic\progress_percent.txt" -Quiet))
        {
            Start-Sleep -Seconds 2
        }

        $EndTime_MemProcFS = (Get-Date)
        $Time_MemProcFS = ($EndTime_MemProcFS-$StartTime_MemProcFS)
        ('MemProcFS Processing duration: {0} h {1} min {2} sec' -f $Time_MemProcFS.Hours, $Time_MemProcFS.Minutes, $Time_MemProcFS.Seconds) >> "$OUTPUT_FOLDER\Stats.txt"
    }

    # Check if Mount Point exists
    if (Test-Path "$DriveLetter\forensic\*")
    {
        # CurrentControlSet
        $RegistryValue = "$DriveLetter\registry\HKLM\SYSTEM\Select\Current.txt"

        if (Test-Path "$($RegistryValue)")
        {
            $CurrentControlSet = Get-Content "$RegistryValue" | Select-Object -Skip 2 | ForEach-Object {$_ -replace "^0+", ""}
        }

        # ComputerName
        $RegistryValue = "$DriveLetter\registry\HKLM\SYSTEM\ControlSet00$CurrentControlSet\Control\ComputerName\ComputerName\ComputerName.txt"

        if (Test-Path "$($RegistryValue)")
        {
            $ComputerName = Get-Content "$RegistryValue" | Select-Object -Skip 2
            Write-Output "[Info]  Host Name: $ComputerName"
        }

        # ProductName
        if (Test-Path "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProductName.txt")
        {
            $ProductName = Get-Content "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProductName.txt" | Select-Object -Skip 2
        }

        # OSArchitecture
        if (Test-Path "$DriveLetter\registry\HKLM\SYSTEM\ControlSet00$CurrentControlSet\Control\Session Manager\Environment\PROCESSOR_ARCHITECTURE.txt")
        {
            $PROCESSOR_ARCHITECTURE = Get-Content "$DriveLetter\registry\HKLM\SYSTEM\ControlSet00$CurrentControlSet\Control\Session Manager\Environment\PROCESSOR_ARCHITECTURE.txt" | Select-Object -Skip 2

            # AMD64 (x64)
            if ($PROCESSOR_ARCHITECTURE -match "AMD64")
            {
                $OSArchitecture = "x64"
            }

            # x86
            if ($PROCESSOR_ARCHITECTURE -match "x86")
            {
                $OSArchitecture = "x86"
            }

            # ARM64
            if ($PROCESSOR_ARCHITECTURE -match "ARM64")
            {
                $OSArchitecture = "ARM64"
            }
        }
        else
        {
            Write-Output "[Info]  Processor Architecture: UNKNOWN"
        }

        # CSDVersion
        if (Test-Path "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\CSDVersion.txt")
        {
            $OSVersion = (Get-Content "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\CSDVersion.txt" | Select-Object -Skip 2) -creplace '(?s)^.*Service Pack ', ''
        }

        # Windows 10
        if ($ProductName -like "*Windows 10*")
        {
            # Major
            $CurrentMajorVersionNumber = Get-Content "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\CurrentMajorVersionNumber.txt" | Select-Object -Skip 2
            $Major = [Convert]::ToInt64("$CurrentMajorVersionNumber",16)

            # Minor
            $CurrentMinorVersionNumber = Get-Content "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\CurrentMinorVersionNumber.txt" | Select-Object -Skip 2
            $Minor = [Convert]::ToInt64("$CurrentMinorVersionNumber",16)
        }
        else 
        {
            # CurrentVersion
            if (Test-Path "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\CurrentVersion.txt")
            {
                $CurrentVersion = Get-Content "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\CurrentVersion.txt" | Select-Object -Skip 2

                # Major
                $Major = $CurrentVersion.split('.')[0]

                # Minor
                $Minor = $CurrentVersion.split('.')[1]
            }
            else
            {
                Write-Host "[Error] $DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\CurrentVersion.txt does NOT exist." -ForegroundColor Red
            }
        }

        # Windows 10, Windows 11, Windows Server 2016, Windows Server 2019, and Windows Server 2022
        if (($ProductName -like "*Windows 10*") -Or ($ProductName -like "*Windows Server 2016*") -Or ($ProductName -like "*Windows Server 2019*") -Or ($ProductName -like "*Windows Server 2022*"))
        {
            # DisplayVersion
            if (Test-Path "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\DisplayVersion.txt")
            {
                $DisplayVersion = Get-Content "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\DisplayVersion.txt" | Select-Object -Skip 2
            }

            # ReleaseID
            $ReleaseID = Get-Content "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ReleaseId.txt" | Select-Object -Skip 2
    
            # CurrentBuildNumber
            if (Test-Path "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\CurrentBuildNumber.txt")
            {
                [int]$CurrentBuildNumber = Get-Content "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\CurrentBuildNumber.txt" | Select-Object -Skip 2
            }
            else
            {
                Write-Host "[Error] $DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\CurrentBuildNumber.txt does NOT exist." -ForegroundColor Red
            }

            # UBR
            if (Test-Path "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\UBR.txt")
            {
                $Hex = Get-Content "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\UBR.txt" | Select-Object -Skip 2
                $UBR = [uint32]"0x$Hex"
            }

            # Windows 11 (CurrentBuildNumber + Update Build Revision)
            # Windows 11 Build 21996 --> First Developer Preview
            # Windows 11 Build 22000 --> First Public Preview
            if ($CurrentBuildNumber -ge "21996")
            {
                $ProductName = $ProductName | ForEach-Object{($_ -replace "10","11")}
                $Hex = Get-Content "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\UBR.txt" | Select-Object -Skip 2
                $UBR = [uint32]"0x$Hex"
                Write-Output "[Info]  OS: $ProductName ($OSArchitecture), Version: $DisplayVersion ($Major.$Minor.$CurrentBuildNumber.$UBR)"
            }
            else
            {
                if ($DisplayVersion)
                {
                    Write-Output "[Info]  OS: $ProductName ($OSArchitecture), Version: $ReleaseID / $DisplayVersion ($Major.$Minor.$CurrentBuildNumber.$UBR)"
                }
                else
                {
                    Write-Output "[Info]  OS: $ProductName ($OSArchitecture), Version: $ReleaseID ($Major.$Minor.$CurrentBuildNumber.$UBR)"
                }
            }
        }
        else
        {
            # CurrentBuildNumber
            $CurrentBuildNumber = Get-Content "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\CurrentBuildNumber.txt" | Select-Object -Skip 2

            # Revision Number
            if (Test-Path "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\BuildLabEx.txt")
            {
                # BuildLabEx
                $BuildLabEx = Get-Content "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\BuildLabEx.txt" | Select-Object -Skip 2
                $RevisionNumber = $BuildLabEx.split('.')[1]
            }
            else
            {
                if (Test-Path "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\BuildLab.txt")
                {
                    # BuildLab
                    $BuildLab = Get-Content "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\BuildLab.txt" | Select-Object -Skip 2
                    $RevisionNumber = $BuildLab.split('-')[1]
                }
            }

            if (Test-Path "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\CSDVersion.txt")
            {
                Write-Output "[Info]  OS: $ProductName ($OSArchitecture), Service Pack $OSVersion ($Major.$Minor.$CurrentBuildNumber.$RevisionNumber)"
            }
            else
            {
                Write-Output "[Info]  OS: $ProductName ($OSArchitecture), Version: $Major.$Minor (Build: $CurrentBuildNumber.$RevisionNumber)"
            }
        }

        # InstallDate (ISO 8601)
        $RegistryValue = "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\InstallDate.txt"

        if (Test-Path "$($RegistryValue)")
        {
            $HexadecimalBigEndian = Get-Content "$RegistryValue" | Select-Object -Skip 2
            $UnixSeconds = [Convert]::ToInt64("$HexadecimalBigEndian",16)
            $InstallDate = ((Get-Date 01.01.1970).AddSeconds($UnixSeconds)).ToString("yyyy-MM-dd HH:mm:ss")
            Write-Output "[Info]  InstallDate: $InstallDate UTC"
        }

        # RegisteredOrganization
        $RegisteredOrganization = Get-Content "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\RegisteredOrganization.txt" -ErrorAction SilentlyContinue | Select-Object -Skip 2
        if ($null -ne $RegisteredOrganization)
        {
            Write-Output "[Info]  RegisteredOrganization: $RegisteredOrganization"
        } 
        else 
        {
            Write-Output "[Info]  RegisteredOrganization: --"
        }

        # RegisteredOwner
        if (Test-Path "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\RegisteredOwner.txt")
        {
            $RegisteredOwner = Get-Content "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\RegisteredOwner.txt" | Select-Object -Skip 2
            if ($null -ne $RegisteredOwner)
            {
                Write-Output "[Info]  RegisteredOwner: $RegisteredOwner"
            }
            else
            {
                Write-Output "[Info]  RegisteredOwner: --"
            }
        }
        else
        {
            Write-Host "[Error] $DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\RegisteredOwner.txt does NOT exist." -ForegroundColor Red
        }

        # Check if it's a Domain Controller (Active Directory)
        # HKLM\System\ControlSet00$CurrentControlSet\Services\ADWS (Active Directory Domain Services)
        # HKLM\System\ControlSet00$CurrentControlSet\Services\NTDS (Windows NT Directory Services)
        if  (Test-Path "$DriveLetter\registry\HKLM\SYSTEM\ControlSet00$CurrentControlSet\services")
        {
            if ((Get-ChildItem -Path "$DriveLetter\registry\HKLM\SYSTEM\ControlSet00$CurrentControlSet\services" | Select-Object -ExpandProperty FullName | Select-String -Pattern "\\ADWS" -Quiet) -And (Get-ChildItem -Path "$DriveLetter\registry\HKLM\SYSTEM\ControlSet00$CurrentControlSet\services" | Select-Object -ExpandProperty FullName | Select-String -Pattern "\\NTDS" -Quiet))
            {
                # ProductType
                # WinNT - Windows Client / Windows NT Workstation
                # LanmanNT – Domain Controller
                # ServerNT – Member Server / ServerNT - Windows NT Server Standalone
                if (Get-Content -Path "$DriveLetter\registry\HKLM\SYSTEM\ControlSet00$CurrentControlSet\Control\ProductOptions\ProductType.txt" | Select-Object -Skip 2 | Select-String -Pattern "LanmanNT" -Quiet)
                {
                    $ProductType = Get-Content -Path "$DriveLetter\registry\HKLM\SYSTEM\ControlSet00$CurrentControlSet\Control\ProductOptions\ProductType.txt" | Select-Object -Skip 2
                    Write-Output "[Info]  Product Type: Domain Controller ($ProductType)"
                }

                # ProductSuite
                $ProductSuite = Get-Content -Path "$DriveLetter\registry\HKLM\SYSTEM\ControlSet00$CurrentControlSet\Control\ProductOptions\ProductSuite.txt" | Select-Object -Skip 2
                if ($ProductSuite)
                {
                    Write-Output "[Info]  Product Suite: $ProductSuite"
                }
            }
        }

        # Check if it's a Microsoft Exchange Server
        if (Get-ChildItem -Path "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall" -ErrorAction SilentlyContinue | Select-Object FullName | Select-String -Pattern "Microsoft Exchange*" -Quiet)
        {
            $SubDirectory = (Get-ChildItem -Path "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall" | Select-Object FullName).FullName | Select-String -Pattern "Microsoft Exchange*" | ForEach-Object{($_ -split "\\")[-1]}
            $DisplayName = Get-Content "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\$SubDirectory\DisplayName.txt" | Select-Object -Skip 2
            $DisplayVersion = Get-Content "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\$SubDirectory\DisplayVersion.txt" | Select-Object -Skip 2
            $InstallLocation = Get-Content "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\$SubDirectory\InstallLocation.txt" | Select-Object -Skip 2
            Write-Output "[Info]  $DisplayName ($DisplayVersion)"
            Write-Output "[Info]  Install Location: $InstallLocation"
        }

        # Timezone Information
        if (Test-Path "$DriveLetter\registry\HKLM\SYSTEM\ControlSet00$CurrentControlSet\Control\TimeZoneInformation")
        {
            if (Test-Path "$DriveLetter\registry\HKLM\SYSTEM\ControlSet00$CurrentControlSet\Control\TimeZoneInformation\TimeZoneKeyName.txt")
            {
                $TimeZoneKeyName = Get-Content "$DriveLetter\registry\HKLM\SYSTEM\ControlSet00$CurrentControlSet\Control\TimeZoneInformation\TimeZoneKeyName.txt" | Select-Object -Skip 2 | ForEach-Object{($_ -replace "\.\..*$","")}
            }
            else
            {
                if (Test-Path "$DriveLetter\registry\HKLM\SYSTEM\ControlSet00$CurrentControlSet\Control\TimeZoneInformation\StandardName.txt")
                {
                    $TimeZoneKeyName = Get-Content "$DriveLetter\registry\HKLM\SYSTEM\ControlSet00$CurrentControlSet\Control\TimeZoneInformation\StandardName.txt" | Select-Object -Skip 2 | ForEach-Object{($_ -replace "\.\..*$","")}
                }
            }

            $LastWriteTime = Get-Content "$DriveLetter\registry\HKLM\SYSTEM\ControlSet00$CurrentControlSet\Control\TimeZoneInformation\(_Key_).txt" | Select-Object -Skip 3
            $ActiveTimeBias = Get-Content "$DriveLetter\registry\HKLM\SYSTEM\ControlSet00$CurrentControlSet\Control\TimeZoneInformation\ActiveTimeBias.txt" | Select-Object -Skip 2
            $UTC = '{0:d2}' -f -([int]"0x$ActiveTimeBias" / 60)

            if ($UTC -like "*-*" )
            {
                Write-Output "[Info]  Timezone Information: $TimeZoneKeyName (UTC$UTC`:00)"
                Write-Output "[Info]  Last Written Time: $LastWriteTime"
            }
            else
            {
                Write-Output "[Info]  Timezone Information: $TimeZoneKeyName (UTC+$UTC`:00)"
                Write-Output "[Info]  Last Written Time: $LastWriteTime"
            }
        }
        else
        {
            Write-Host "[Error] TimeZoneInformation Registry Subkey does NOT exist." -ForegroundColor Red
        }

        # LastLoggedOnUser
        $RegistryValue = "$DriveLetter\registry\HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Authentication\LogonUI\LastLoggedOnUser.txt"

        if (Test-Path "$($RegistryValue)")
        {
            $LastLoggedOnUser = (Get-Content "$RegistryValue" | Select-Object -Skip 2) -creplace '(?s)^.*\\', ''
            Write-Output "[Info]  Last Logged On User: $LastLoggedOnUser"
        }

        # Last Boot Up Time (ISO 8601)
        if (Test-Path "$DriveLetter\sys\time-boot.txt")
        {
            $LastBoot = Get-Content -Path "$DriveLetter\sys\time-boot.txt"
            Write-Output "[Info]  Last Boot: $LastBoot"
        }

        # Memory Acquisition Time (ISO 8601)
        if (Test-Path "$DriveLetter\sys\time-current.txt")
        {
            $Current = Get-Content -Path "$DriveLetter\sys\time-current.txt"
            Write-Output "[Info]  Memory Acquisition Time: $Current"
        }

        # Collecting Evidence Files
        Write-Output "[Info]  Collecting Evidence Files ..."

        # FS_Sys_Sysinfo
        # https://github.com/ufrisk/MemProcFS/wiki/FS_Sys_Sysinfo
        if (Test-Path "$DriveLetter\sys\sysinfo\sysinfo.txt")
        {
            New-Item "$OUTPUT_FOLDER\sys\sysinfo" -ItemType Directory -Force | Out-Null
            Copy-Item -Path "$DriveLetter\sys\sysinfo\sysinfo.txt" -Destination "$OUTPUT_FOLDER\sys\sysinfo\sysinfo.txt"
        }

        # FS_FindEvil
        # https://github.com/ufrisk/MemProcFS/wiki/FS_FindEvil
        #
        # Indicators of Evil
        # AV_DETECT      AV_DETECT reports malware detected by the anti-virus residing on the analyzed system.
        # PE_INJECT      PE_INJECT locates malware by scanning for valid .DLLs and .EXEs with executable pages in their page tables located in a private (non-image) virtual address descriptor.
        # PEB_MASQ       PEB_MASQ will flag PEB Masquerading attempts. If PEB_MASQ is detected please investigate further in /sys/proc/proc-v.txt
        # PEB_BAD_LDR    BAD_PEB_LDR will flag if no in-process modules are enumerated from the PEB/LDR_DATA structures.
        # PROC_BAD_DTB   PROC_BAD_DTB will flag active processes with an invalid DirectoryTableBase (DTB) in the kernel _EPROCESS object.
        # PROC_NOLINK    PROC_NOLINK will flag if the process does not exist in the kernel _EPROCESS linked list.
        # PROC_PARENT    PROC_PARENT will flag if a well known process has a bad parent process.
        # PROC_USER      PROC_USER may trigger if well known processes are executing as a strange user. Example cmd.exe as SYSTEM.
        # PROC_DEBUG     PROC_DEBUG flag non-SYSTEM processes with the SeDebugPrivilege.
        # THREAD         THREAD flag various thread related issues.
        # PE_NOLINK      PE_NOLINK locates malware in image virtual address descriptors which is not linked from the in-process PEB/Ldr lists.
        # PE_PATCHED     PE_PATCHED locates malware in image virtual address descriptors which executable pages (in the page tables) differs from kernel prototype memory.
        # DRIVER_PATH    DRIVER_PATH flag kernel drivers that are loaded from a non-standard path. DRIVER_PATH also flag if no corresponding module could be located.
        # PRIVATE_RWX    PRIVATE_RWX locates malware with read/write/execute (RWX) pages in the page table which belongs to a private memory virtual address descriptor.
        # NOIMAGE_RWX    NOIMAGE_RWX locates malware with read/write/execute (RWX) pages in the page table which does not belong to image (module) virtual address descriptors.
        # PRIVATE_RX     PRIVATE_RX locates malware with read/execute (RX) pages in the page table which belongs to a private memory virtual address descriptor.
        # NOIMAGE_RX     NOIMAGE_RX locates malware with read/execute (RX) pages in the page table which does not belong to image (module) virtual address descriptors.

        # FS_FindEvil
        if (Test-Path "$DriveLetter\forensic\findevil\findevil.txt")
        {
            New-Item "$OUTPUT_FOLDER\forensic\findevil" -ItemType Directory -Force | Out-Null
            Copy-Item -Path "$DriveLetter\forensic\findevil\findevil.txt" -Destination "$OUTPUT_FOLDER\forensic\findevil\findevil.txt"

            # CSV
            if (Test-Path "$DriveLetter\forensic\json\general.json")
            {
                $Data = Get-Content "$DriveLetter\forensic\json\general.json" | ConvertFrom-Json | Where-Object { $_.type -eq "evil" }

                $Data | Foreach-Object {

                $proc = $_ | Select-Object -ExpandProperty proc -ErrorAction SilentlyContinue
                $procid = $_ | Select-Object -ExpandProperty pid -ErrorAction SilentlyContinue

                # Microsoft Defender AntiVirus Alerts

                $addr = $_ | Select-Object -ExpandProperty addr -ErrorAction SilentlyContinue
                if ($addr)
                {
                    $Address = $addr.PadLeft(16,"0")
                }
                else
                {
                    $Address = "0000000000000000"
                }

                $desc = $_ | Select-Object -ExpandProperty desc
                $desc2 = $_ | Select-Object -ExpandProperty desc2

                New-Object -TypeName PSObject -Property @{
                    "Process Name" = $proc
	                "PID" = $procid
	                "Address" = $Address
	                "Type" = $desc
                    "Description" = $desc2
                    }
                } | Select-Object "Process Name","PID","Type","Address","Description" | Export-Csv -Path "$OUTPUT_FOLDER\forensic\findevil\findevil.csv" -Delimiter "`t" -NoTypeInformation
            }

            # XLSX
            if (Get-Module -ListAvailable -Name ImportExcel)
            {
                if (Test-Path "$OUTPUT_FOLDER\forensic\findevil\findevil.csv")
                {
                    if([int](& $xsv count -d "`t" "$OUTPUT_FOLDER\forensic\findevil\findevil.csv") -gt 0)
                    {
                        $IMPORT = Import-Csv "$OUTPUT_FOLDER\forensic\findevil\findevil.csv" -Delimiter "`t"
                        $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\forensic\findevil\findevil.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "FindEvil" -CellStyleSB {
                        param($WorkSheet)
                        # BackgroundColor and FontColor for specific cells of TopRow
                        $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                        Set-Format -Address $WorkSheet.Cells["A1:E1"] -BackgroundColor $BackgroundColor -FontColor White
                        # HorizontalAlignment "Center" of columns B-D
                        $WorkSheet.Cells["B:D"].Style.HorizontalAlignment="Center"
                        }
                    }
                }
            }
        }

        # Find Evil
        if (Test-Path "$OUTPUT_FOLDER\forensic\findevil\findevil.csv")
        {
            # AV_DETECT (Microsoft Defender AntiVirus)
            $Data = Import-Csv "$OUTPUT_FOLDER\forensic\findevil\findevil.csv" -Delimiter "`t" | Where-Object { $_.Type -like "*AV_DETECT*" }
            $Count = ($Data | Measure-Object).Count
            if ($Count -gt 0)
            {
                Write-Host "[Alert] AV_DETECT found ($Count)" -ForegroundColor Red
            }
            
            # PE_INJECT (Injected Modules)
            $Data = Import-Csv "$OUTPUT_FOLDER\forensic\findevil\findevil.csv" -Delimiter "`t" | Where-Object { $_.Type -like "*PE_INJECT*" }
            $Count = ($Data | Measure-Object).Count
            if ($Count -gt 0)
            {
                New-Item "$OUTPUT_FOLDER\forensic\findevil\PE_INJECT" -ItemType Directory -Force | Out-Null
                ($Data | Select-Object PID,"Process Name",Type,Address,Description | Format-Table -HideTableHeaders | Out-String).Trim() | Out-File "$OUTPUT_FOLDER\forensic\findevil\PE_INJECT\PE_INJECT.txt"
                Write-Host "[Alert] PE_INJECT found ($Count)" -ForegroundColor Red
                (Get-Content "$OUTPUT_FOLDER\forensic\findevil\PE_INJECT\PE_INJECT.txt") -replace "^", "        "  | Write-Host -ForegroundColor Red
            }

            # Collecting PE_INJECT (Injected Modules)
            if (Test-Path "$($7za)")
            {
                if (Test-Path "$OUTPUT_FOLDER\forensic\findevil\PE_INJECT\PE_INJECT.txt")
                {
                    $PE_INJECTS = Get-Content "$OUTPUT_FOLDER\forensic\findevil\PE_INJECT\PE_INJECT.txt"
                    ForEach( $PE_INJECT in $PE_INJECTS )
                    {
                        $ProcessID = $PE_INJECT | ForEach-Object{($_ -split "\s+")[0]}
                        $InjectedModuleList = (Get-ChildItem -Recurse -Force "$DriveLetter\pid\$ProcessID\files\modules\*" | Where-Object {($_.FullName -match "_INJECTED*")} | Foreach-Object FullName)

                        ForEach( $InjectedModule in $InjectedModuleList )
                        {
                            $INFECTED = "infected"
                            $ArchiveName = $InjectedModule | ForEach-Object{($_ -split "\\")[-1]} | ForEach-Object{($_ -split "_INJECTED-")[-1]}
                            & $7za a -mx5 -mhe "-p$INFECTED" -t7z "$OUTPUT_FOLDER\forensic\findevil\PE_INJECT\$ProcessID-$ArchiveName.7z" "$InjectedModule" > $null 2>&1
                        }
                    }
                }
            }

            # PEB_MASQ (PEB Masquerading)
            $Data = Import-Csv "$OUTPUT_FOLDER\forensic\findevil\findevil.csv" -Delimiter "`t" | Where-Object { $_.Type -like "*PEB_MASQ*" }
            $Count = ($Data | Measure-Object).Count
            if ($Count -gt 0)
            {
                New-Item "$OUTPUT_FOLDER\forensic\findevil\PEB_MASQ" -ItemType Directory -Force | Out-Null
                ($Data | Select-Object PID,"Process Name",Type,Address,Description | Format-Table -HideTableHeaders | Out-String).Trim() | Out-File "$OUTPUT_FOLDER\forensic\findevil\PEB_MASQ\PEB_MASQ.txt"
                Write-Host "[Alert] PEB_MASQ found ($Count)" -ForegroundColor Red
                (Get-Content "$OUTPUT_FOLDER\forensic\findevil\PEB_MASQ\PEB_MASQ.txt") -replace "^", "        "  | Write-Host -ForegroundColor Red
            }
        }
        else
        {
            Write-Output "[Info]  Your Operating System is NOT supported by FindEvil."
            Write-Output "        Note: FindEvil is only available on 64-bit Windows 11, 10 and 8.1."
        }

        # Check if YARA Index was succesfully initialized
        # https://github.com/VirusTotal/yara/blob/master/libyara/include/yara/error.h
        if (Test-Path "$MemProcFSLogfile")
        {
            if (Get-Content -Path "$MemProcFSLogfile" | Select-String -Pattern "yr_initialize\(\) failed with error code 3" -Quiet)
            {
                Write-Host "[Error] YARA Index was NOT successfully initialized: Error Code 3" -ForegroundColor Red
            }
        }
        
        # FS_Forensic_Yara
        # https://github.com/ufrisk/MemProcFS/wiki/FS_Forensic_Yara
        if (Test-Path "$DriveLetter\forensic\yara\*.txt")
        {
            New-Item "$OUTPUT_FOLDER\forensic\yara" -ItemType Directory -Force | Out-Null
            Copy-Item "$DriveLetter\forensic\yara\*.txt" -Destination "$OUTPUT_FOLDER\forensic\yara"

            # Match Count
            if (!($null -eq $YaraRules))
            {
                if (Test-Path "$DriveLetter\forensic\yara\match-count.txt")
                {
                    [int]$Total = Get-Content -Path "$DriveLetter\forensic\yara\match-count.txt"
                    if ($Total -gt 0)
                    {
                        Write-Host "[Alert] $Total YARA rule matches" -ForegroundColor Red
                
                        # Result
                        if (Test-Path "$DriveLetter\forensic\yara\result.txt")
                        {
                            (Get-Content -Path "$DriveLetter\forensic\yara\result.txt" | Select-String -Pattern "threat_name" | Sort-Object -Unique | ForEach-Object{($_ -split "threat_name:")[1]}).Trim() | Out-File "$OUTPUT_FOLDER\forensic\yara\threat_name.txt"
                            (Get-Content -Path "$DriveLetter\forensic\yara\result.txt" | Select-String -Pattern "threat_name" | ForEach-Object{($_ -split "threat_name:")[1]}).Trim() | Sort-Object | Out-File "$OUTPUT_FOLDER\forensic\yara\threat_name_all.txt"
                            
                            $Threats = Get-Content "$OUTPUT_FOLDER\forensic\yara\threat_name.txt"

                            foreach ($ThreatName in $Threats)
                            {
                                $Count = (Get-Content "$OUTPUT_FOLDER\forensic\yara\threat_name_all.txt" | Select-String -Pattern "$ThreatName" | Measure-Object).Count
                                Write-Host "        $ThreatName ($Count)" -ForegroundColor Red
                            }
                        }
                    }
                    else
                    {
                        Write-Output "[Info]  0 YARA rule matches"
                    }
                }
            }
        }

        Function Get-MPLogs {

        # Microsoft Protection Logs
        if ((Test-Path "$DriveLetter\forensic\files\ROOT\ProgramData\Microsoft\Windows Defender\Support\*MPLog-*.log") -or (Test-Path "$DriveLetter\forensic\files\ROOT\ProgramData\Microsoft\Windows Defender\Support\*MPDetection-*.log"))
        {
            # Step #1 - Collecting MPLogs (MPLogs-[8 digits]-[6 digits].log --> MPLogs-[date]-[time].log)
            Write-Output "[Info]  Collecting Microsoft Protection Logs (MPLogs) ..."
            New-Item "$OUTPUT_FOLDER\MPLogs\Dirty" -ItemType Directory -Force | Out-Null

            # MPLogs
            if (Test-Path "$DriveLetter\forensic\files\ROOT\ProgramData\Microsoft\Windows Defender\Support\*MPLog-*.log")
            {
                Copy-Item "$DriveLetter\forensic\files\ROOT\ProgramData\Microsoft\Windows Defender\Support\*MPLog-*.log" -Destination "$OUTPUT_FOLDER\MPLogs\Dirty"
                
                # Count
                $Count = (Get-ChildItem -Path "$OUTPUT_FOLDER\MPLogs\Dirty" -Filter "*MPLog-*.log" | Measure-Object).Count
                Write-Output "[Info]  $Count MPLog(s) found"
            }

            # MPDetection
            if (Test-Path "$DriveLetter\forensic\files\ROOT\ProgramData\Microsoft\Windows Defender\Support\*MPDetection-*.log")
            {
                Copy-Item "$DriveLetter\forensic\files\ROOT\ProgramData\Microsoft\Windows Defender\Support\*MPDetection-*.log" -Destination "$OUTPUT_FOLDER\MPLogs\Dirty"
            }

            # Step #2 - Removing Null Bytes

            # MPLogs
            if (Test-Path "$OUTPUT_FOLDER\MPLogs\Dirty\*MPLog-*.log")
            {
                Write-Output "[Info]  Recovery of Microsoft Protection Logs (MPLogs) initiated ..."
                New-Item "$OUTPUT_FOLDER\MPLogs\Clean" -ItemType Directory -Force | Out-Null

                $MPLogs = (Get-ChildItem "$OUTPUT_FOLDER\MPLogs\Dirty" -Filter "*MPLog-*.log" -File -Force -ErrorAction SilentlyContinue).FullName

                ForEach( $MPLog in $MPLogs )
                {
                    $FileName = $MPLog.Split('\')[-1]
                    Get-Content "$MPLog" -Encoding Byte | Where-Object {$_ -ne 0x00} | Set-Content "$OUTPUT_FOLDER\MPLogs\Clean\$FileName" -Encoding Byte
                }
            }

            # MPDetection
            if (Test-Path "$OUTPUT_FOLDER\MPLogs\Dirty\*MPDetection-*.log")
            {
                New-Item "$OUTPUT_FOLDER\MPLogs\Clean" -ItemType Directory -Force | Out-Null

                $MPDetectionLogs = (Get-ChildItem "$OUTPUT_FOLDER\MPLogs\Dirty" -Filter "*MPDetection-*.log" -File -Force -ErrorAction SilentlyContinue).FullName

                ForEach( $MPDetectionLog in $MPDetectionLogs )
                {
                    $FileName = $MPDetectionLog.Split('\')[-1]
                    Get-Content "$MPDetectionLog" -Encoding Byte | Where-Object {$_ -ne 0x00} | Set-Content "$OUTPUT_FOLDER\MPLogs\Clean\$FileName" -Encoding Byte
                }
            }

            # Step #3 - CSV
            # https://gist.github.com/Qazeer/5ad40f6e98362520290d13f3015f79ec
            if (Test-Path "$OUTPUT_FOLDER\MPLogs\Clean\*MPLog-*.log")
            {
                Write-Output "[Info]  Converting Microsoft Protection Logs (MPLogs) to CSV ..."
                New-Item "$OUTPUT_FOLDER\MPLogs\CSV" -ItemType Directory -Force | Out-Null

                $MPLogs = (Get-ChildItem "$OUTPUT_FOLDER\MPLogs\Clean" -Filter "*MPLog-*.log" -File -Force -ErrorAction SilentlyContinue).FullName

                ForEach( $MPLog in $MPLogs )
                {
                    $BaseName = ($MPLog.Split('\')[-1]).split('.')[0]
                    $LogFile = Get-Item -Path $MPLog
                    $LogData = $LogFile | Get-Content -Encoding UTF8 -Raw
                    $LogOutput = New-Object System.Collections.ArrayList
                    $LogEntries = $LogData -split "(?m)^(?=\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z)"

                    Foreach ($LogEntry in $LogEntries)
                    {
                        if ($null -eq $LogEntry -or "" -eq $LogEntry.Trim()) { continue }

                        $LogExtract = $LogEntry | Select-String -Pattern "^(?<Timestamp>\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.*?)\s(?<Provider>\[.*?]|\S+?:)?\s?(?<Message>(?s).*)$"

                        if ($LogExtract.Matches.Count -eq 0) {
                            continue
                        }

                        $Timestamp = $LogExtract.Matches[0].Groups['Timestamp'].Value
                        $Category  = $LogExtract.Matches[0].Groups['Category'].Value
                        $Message   = $LogExtract.Matches[0].Groups['Message'].Value.Trim()

                        $null = $Provider -match '^\[?(?<ProviderExtracted>.*?)]?:?$'
                        $Category = if ($Matches.Contains("ProviderExtracted")) { $Matches["ProviderExtracted"] }

                        $null = $LogOutput.Add([PSCustomObject] @{
                            Timestamp = $Timestamp
                            Category  = $Category
                            Message   = $Message
                        })
                    }

                    $LogOutput | Export-Csv -NoTypeInformation "$OUTPUT_FOLDER\MPLogs\CSV\$BaseName.csv"
                }
            }

            # Step #4 - XLSX
            if (Test-Path "$OUTPUT_FOLDER\MPLogs\CSV\*MPLog-*.csv")
            {
                Write-Output "[Info]  Creating Excel SpreadSheets(s) ..."
                New-Item "$OUTPUT_FOLDER\MPLogs\XLSX" -ItemType Directory -Force | Out-Null

                $MPLogs = (Get-ChildItem "$OUTPUT_FOLDER\MPLogs\CSV" -Filter "*MPLog-*.csv" -File -Force -ErrorAction SilentlyContinue).FullName
                
                ForEach( $MPLog in $MPLogs )
                {
                    if([int](& $xsv count "$MPLog") -gt 0)
                    {
                        $BaseName = ($MPLog.Split('\')[-1]).split('.')[0]
                        $Import = Import-Csv "$MPLog" -Delimiter "," | Select-Object @{Name="Timestamp";Expression={([DateTime]::Parse($_.Timestamp).ToString("yyyy-MM-dd HH:mm:ss"))}},Provider,Message | Sort-Object { $_.Timestamp -as [datetime] } -Descending
                        $Import | Export-Excel -Path "$OUTPUT_FOLDER\MPLogs\XLSX\$BaseName.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "MPLogs" -CellStyleSB {
                        param($WorkSheet)
                        # BackgroundColor and FontColor for specific cells of TopRow
                        $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                        Set-Format -Address $WorkSheet.Cells["A1:C1"] -BackgroundColor $BackgroundColor -FontColor White
                        # HorizontalAlignment "Center" of columns A-B
                        $WorkSheet.Cells["A:B"].Style.HorizontalAlignment="Center"
                        }
                    }
                }
            }
        }

        }

        Get-MPLogs

        # FS_Process_Console
        # https://github.com/ufrisk/MemProcFS/wiki/FS_Process_Console
        if (Test-Path "$DriveLetter\name\conhost.exe-*\console\console.txt")
        {
            $Console = Get-ChildItem -Path "$DriveLetter\name\conhost.exe-*\console\console.txt"
            $Count = ($Console | Measure-Object).Count

            Write-Output "[Info]  $Count Console Information File(s) found"
            New-Item "$OUTPUT_FOLDER\forensic\console" -ItemType Directory -Force | Out-Null

            $Files = ($Console).FullName
            ForEach($File in $Files)
            {
                $Suffix = $File | ForEach-Object{($_ -split "-")[1]} | ForEach-Object{($_ -split "\\")[0]}
                Copy-Item -Path "$File" -Destination "$OUTPUT_FOLDER\forensic\console\console-$Suffix.txt"
            }
        }

        # FS_Forensic_Files
        # https://github.com/ufrisk/MemProcFS/wiki/FS_Forensic_Files
        if (Test-Path "$DriveLetter\forensic\files\files.txt")
        {
            New-Item "$OUTPUT_FOLDER\forensic\files" -ItemType Directory -Force | Out-Null
            Copy-Item -Path "$DriveLetter\forensic\files\files.txt" -Destination "$OUTPUT_FOLDER\forensic\files\files.txt"
        }

        # FS_Forensic_CSV
        # https://github.com/ufrisk/MemProcFS/wiki/FS_Forensic_CSV
        if (Test-Path "$DriveLetter\forensic\csv\*.csv")
        {
            New-Item "$OUTPUT_FOLDER\forensic\csv" -ItemType Directory -Force | Out-Null
            Copy-Item "$DriveLetter\forensic\csv\*.csv" -Destination "$OUTPUT_FOLDER\forensic\csv"
        }

        # FS_Forensic_XLSX
        if (Test-Path "$OUTPUT_FOLDER\forensic\csv\*.csv")
        {
            New-Item "$OUTPUT_FOLDER\forensic\xlsx" -ItemType Directory -Force | Out-Null

            # devices.csv --> Device Drivers
            if (Test-Path "$OUTPUT_FOLDER\forensic\csv\devices.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\forensic\csv\devices.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\forensic\csv\devices.csv" -Delimiter ","
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\forensic\xlsx\devices.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Device Drivers" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:H1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Left" of column A
                    $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Left"
                    # HorizontalAlignment "Center" of columns B-E and G
                    $WorkSheet.Cells["B:E"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["G:G"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # drivers.csv --> Kernel Drivers
            if (Test-Path "$OUTPUT_FOLDER\forensic\csv\drivers.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\forensic\csv\drivers.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\forensic\csv\drivers.csv" -Delimiter ","
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\forensic\xlsx\drivers.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Kernel Drivers" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:H1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Left" of column A
                    $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Left"
                    # HorizontalAlignment "Center" of columns B-E
                    $WorkSheet.Cells["B:E"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # files.csv --> Recoverable Files
            if (Test-Path "$OUTPUT_FOLDER\forensic\csv\files.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\forensic\csv\files.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\forensic\csv\files.csv" -Delimiter ","
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\forensic\xlsx\files.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Files" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:E1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-C
                    $WorkSheet.Cells["A:C"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # findevil.csv --> Indicators of Evil
            if (Test-Path "$OUTPUT_FOLDER\forensic\csv\findevil.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\forensic\csv\findevil.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\forensic\csv\findevil.csv" -Delimiter "," | Sort-Object PID
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\forensic\xlsx\findevil.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "FindEvil" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:E1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-D
                    $WorkSheet.Cells["A:D"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # handles.csv --> Handles related to all processes
            if (Test-Path "$OUTPUT_FOLDER\forensic\csv\handles.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\forensic\csv\handles.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\forensic\csv\handles.csv" -Delimiter ","
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\forensic\xlsx\handles.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Handles" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:I1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-H
                    $WorkSheet.Cells["A:H"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # modules.csv --> Loaded Modules Information
            if (Test-Path "$OUTPUT_FOLDER\forensic\csv\modules.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\forensic\csv\modules.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\forensic\csv\modules.csv" -Delimiter ","
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\forensic\xlsx\modules.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Modules" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:X1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-J and M-W
                    $WorkSheet.Cells["A:J"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["M:W"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # net.csv --> Network Connection Information
            if (Test-Path "$OUTPUT_FOLDER\forensic\csv\net.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\forensic\csv\net.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\forensic\csv\net.csv" -Delimiter ","
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\forensic\xlsx\net.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Network" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:K1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-J
                    $WorkSheet.Cells["A:J"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # netdns.csv --> DNS Information
            if (Test-Path "$OUTPUT_FOLDER\forensic\csv\netdns.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\forensic\csv\netdns.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\forensic\csv\netdns.csv" -Delimiter ","
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\forensic\xlsx\netdns.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "DNS" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:F1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-D
                    $WorkSheet.Cells["A:D"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # prefetch.csv --> Prefetch Information
            if (Test-Path "$OUTPUT_FOLDER\forensic\csv\prefetch.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\forensic\csv\prefetch.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\forensic\csv\prefetch.csv" -Delimiter ","
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\forensic\xlsx\prefetch.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Prefetch" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns B-C and E-M
                    $WorkSheet.Cells["B:C"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["E:M"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # process.csv --> Process Information
            if (Test-Path "$OUTPUT_FOLDER\forensic\csv\process.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\forensic\csv\process.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\forensic\csv\process.csv" -Delimiter ","
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\forensic\xlsx\process.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Processes" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:R1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-C and F-O
                    $WorkSheet.Cells["A:C"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["F:O"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # services.csv --> Services (user mode and kernel drivers)
            if (Test-Path "$OUTPUT_FOLDER\forensic\csv\services.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\forensic\csv\services.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\forensic\csv\services.csv" -Delimiter "," | Sort-Object PID
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\forensic\xlsx\services.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Services" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:L1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-B and E-J
                    $WorkSheet.Cells["A:B"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["E:J"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # tasks.csv --> Scheduled Tasks
            if (Test-Path "$OUTPUT_FOLDER\forensic\csv\tasks.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\forensic\csv\tasks.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\forensic\csv\tasks.csv" -Delimiter "," | Sort-Object { $_.TimeCreate -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\forensic\xlsx\tasks.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Tasks" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:K1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A, D-E and H-K
                    $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["D:E"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:K"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # threads.csv --> Information about all threads on the system
            if (Test-Path "$OUTPUT_FOLDER\forensic\csv\threads.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\forensic\csv\threads.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\forensic\csv\threads.csv" -Delimiter "," | Sort-Object PID # or CreateTime???
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\forensic\xlsx\threads.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Threads" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:V1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-V
                    $WorkSheet.Cells["A:V"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # timeline_all.csv --> \forensic\timeline\timeline-reverse.csv

            # timeline_kernelobject.csv --> Kernel Object Manager Objects
            if (Test-Path "$OUTPUT_FOLDER\forensic\csv\timeline_kernelobject.csv")
            {
                if((Get-Item "$OUTPUT_FOLDER\forensic\csv\timeline_kernelobject.csv").length -gt 0kb)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\forensic\csv\timeline_kernelobject.csv" -Delimiter "," | Select-Object Time, Type, Action, PID, Value32, Value64, Text | Sort-Object { $_.Time -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\forensic\xlsx\timeline_kernelobject.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "timeline_kernelobject" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:G1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # timeline_net.csv --> Network Timeline
            if (Test-Path "$OUTPUT_FOLDER\forensic\csv\timeline_net.csv")
            {
                if((Get-Item "$OUTPUT_FOLDER\forensic\csv\timeline_net.csv").length -gt 0kb)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\forensic\csv\timeline_net.csv" -Delimiter "," | Select-Object Time, Type, Action, PID, Value32, Value64, Text | Sort-Object { $_.Time -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\forensic\xlsx\timeline_net.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "timeline_net" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:G1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # timeline_ntfs.csv --> \forensic\timeline\timeline-reverse.csv

            # timeline_prefetch.csv --> Prefetch Timeline
            if (Test-Path "$OUTPUT_FOLDER\forensic\csv\timeline_prefetch.csv")
            {
                if((Get-Item "$OUTPUT_FOLDER\forensic\csv\timeline_prefetch.csv").length -gt 0kb)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\forensic\csv\timeline_prefetch.csv" -Delimiter "," | Select-Object Time, Type, Action, PID, Value32, Value64, Text | Sort-Object { $_.Time -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\forensic\xlsx\timeline_prefetch.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "timeline_prefetch" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:G1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # timeline_process.csv --> Process Timeline
            if (Test-Path "$OUTPUT_FOLDER\forensic\csv\timeline_process.csv")
            {
                if((Get-Item "$OUTPUT_FOLDER\forensic\csv\timeline_process.csv").length -gt 0kb)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\forensic\csv\timeline_process.csv" -Delimiter "," | Select-Object Time, Type, Action, PID, Value32, Value64, Text | Sort-Object { $_.Time -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\forensic\xlsx\timeline_process.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "timeline_process" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:G1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # timeline_registry.csv --> Registry Timeline
            if (Test-Path "$OUTPUT_FOLDER\forensic\csv\timeline_registry.csv")
            {
                if((Get-Item "$OUTPUT_FOLDER\forensic\csv\timeline_registry.csv").length -gt 0kb)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\forensic\csv\timeline_registry.csv" -Delimiter "," | Select-Object Time, Type, Action, PID, Value32, Value64, Text | Sort-Object { $_.Time -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\forensic\xlsx\timeline_registry.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "timeline_registry" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:G1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # timeline_task.csv --> Scheduled Tasks Timeline
            if (Test-Path "$OUTPUT_FOLDER\forensic\csv\timeline_task.csv")
            {
                if((Get-Item "$OUTPUT_FOLDER\forensic\csv\timeline_task.csv").length -gt 0kb)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\forensic\csv\timeline_task.csv" -Delimiter "," | Select-Object Time, Type, Action, PID, Value32, Value64, Text | Sort-Object { $_.Time -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\forensic\xlsx\timeline_task.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "timeline_task" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:G1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # timeline_thread.csv --> Threading Timeline
            if (Test-Path "$OUTPUT_FOLDER\forensic\csv\timeline_thread.csv")
            {
                if((Get-Item "$OUTPUT_FOLDER\forensic\csv\timeline_thread.csv").length -gt 0kb)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\forensic\csv\timeline_thread.csv" -Delimiter "," | Select-Object Time, Type, Action, PID, Value32, Value64, Text | Sort-Object { $_.Time -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\forensic\xlsx\timeline_thread.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "timeline_thread" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:G1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # timeline_web --> Web Timeline
            if (Test-Path "$OUTPUT_FOLDER\forensic\csv\timeline_web.csv")
            {
                if((Get-Item "$OUTPUT_FOLDER\forensic\csv\timeline_web.csv").length -gt 46)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\forensic\csv\timeline_web.csv" -Delimiter "," | Sort-Object { $_.Time -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\forensic\xlsx\timeline_web.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "timeline_web" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:G1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # unloaded_modules.csv --> Unloaded Modules Information
            if (Test-Path "$OUTPUT_FOLDER\forensic\csv\unloaded_modules.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\forensic\csv\unloaded_modules.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\forensic\csv\unloaded_modules.csv" -Delimiter "," | Sort-Object PID
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\forensic\xlsx\unloaded_modules.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "unloaded_modules" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:H1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A and C-H
                    $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["C:H"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # yara.csv --> Summary forensic yara scan results
            if (Test-Path "$OUTPUT_FOLDER\forensic\csv\yara.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\forensic\csv\yara.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\forensic\csv\yara.csv" -Delimiter "," | Sort-Object { $_.Time -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\forensic\xlsx\yara.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "YARA" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:Y1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-B, D-J, L-O, Q, S, U, W and Y
                    $WorkSheet.Cells["A:B"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["D:J"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:O"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["Q:Q"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["S:S"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["U:U"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["W:W"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["Y:Y"].Style.HorizontalAlignment="Center"
                    }
                }
            }
        }

        # FS_Forensic_JSON
        # https://github.com/ufrisk/MemProcFS/wiki/FS_Forensic_JSON
        if (Test-Path "$DriveLetter\forensic\json\*.json")
        {
            New-Item "$OUTPUT_FOLDER\forensic\json" -ItemType Directory -Force | Out-Null
            Copy-Item "$DriveLetter\forensic\json\*.json" -Destination "$OUTPUT_FOLDER\forensic\json"
        }

        # FS_Forensic_Ntfs
        # https://github.com/ufrisk/MemProcFS/wiki/FS_Forensic_Ntfs
        if (Test-Path "$DriveLetter\forensic\ntfs\ntfs_files.txt")
        {
            New-Item "$OUTPUT_FOLDER\forensic\ntfs" -ItemType Directory -Force | Out-Null
            Copy-Item -Path "$DriveLetter\forensic\ntfs\ntfs_files.txt" -Destination "$OUTPUT_FOLDER\forensic\ntfs\ntfs_files.txt"
        }

        # FS_Forensic_Timeline
        # https://github.com/ufrisk/MemProcFS/wiki/FS_Forensic_Timeline
        if (Test-Path "$DriveLetter\forensic\timeline\*.txt")
        {
            New-Item "$OUTPUT_FOLDER\forensic\timeline" -ItemType Directory -Force | Out-Null
            Copy-Item "$DriveLetter\forensic\timeline\*.txt" -Destination "$OUTPUT_FOLDER\forensic\timeline"
        }

        # FS_SysInfo
        # https://github.com/ufrisk/MemProcFS/wiki/FS_SysInfo
        if (Test-Path "$DriveLetter\sys\*.txt")
        {
            New-Item "$OUTPUT_FOLDER\sys" -ItemType Directory -Force | Out-Null
            Copy-Item "$DriveLetter\sys\*.txt" -Destination "$OUTPUT_FOLDER\sys"
        }

        # FS_SysInfo_Users
        # https://github.com/ufrisk/MemProcFS/wiki/FS_SysInfo_Users
        if (Test-Path "$DriveLetter\sys\users\*.txt")
        {
            New-Item "$OUTPUT_FOLDER\sys\users" -ItemType Directory -Force | Out-Null
            Copy-Item "$DriveLetter\sys\users\*.txt" -Destination "$OUTPUT_FOLDER\sys\users"
        }

        # FS_SysInfo_Certificates
        # https://github.com/ufrisk/MemProcFS/wiki/FS_SysInfo_Certificates
        if (Test-Path "$DriveLetter\sys\certificates\certificates.txt")
        {
            New-Item "$OUTPUT_FOLDER\sys\certificates" -ItemType Directory -Force | Out-Null
            Copy-Item -Path "$DriveLetter\sys\certificates\certificates.txt" -Destination "$OUTPUT_FOLDER\sys\certificates\certificates.txt"

            # SHA1
            Get-Content "$OUTPUT_FOLDER\sys\certificates\certificates.txt" | Select-String -Pattern "[A-Za-z0-9]{32}" -AllMatches | ForEach-Object { $_.Matches } | ForEach-Object { $_.Value } | Sort-Object -Unique | Out-File "$OUTPUT_FOLDER\sys\certificates\SHA1.txt"

            # Count
            $Total = (Get-Content "$OUTPUT_FOLDER\sys\certificates\certificates.txt" | Measure-Object).Count
            $Count = (Get-Content "$OUTPUT_FOLDER\sys\certificates\SHA1.txt" | Measure-Object).Count
            Write-Output "[Info]  $Count Certificates found ($Total)"

            # CSV
            if (Test-Path "$DriveLetter\forensic\json\general.json")
            {
                $Data = Get-Content "$DriveLetter\forensic\json\general.json" | ConvertFrom-Json | Where-Object { $_.type -eq "certificate" }

                $Data | Foreach-Object {

                $desc = $_ | Select-Object -ExpandProperty desc
                $store = $_ | Select-Object -ExpandProperty desc2 | Select-Object @{Name="store"; Expression={ForEach-Object{($_ -split "store:")[1]} | ForEach-Object{($_ -split "thumbprint:")[0]} | ForEach-Object{($_ -replace "[\[\]]","")}}}
                $thumbprint = $_ | Select-Object -ExpandProperty desc2 | Select-Object @{Name="thumbprint"; Expression={ForEach-Object{($_ -split "thumbprint:")[1]} | ForEach-Object{($_ -split "issuer:")[0]} | ForEach-Object{($_ -replace "[\[\]]","")}}}
                $issuer  = $_ | Select-Object -ExpandProperty desc2 | Select-Object @{Name="issuer"; Expression={ForEach-Object{($_ -split "issuer:")[1]} | ForEach-Object{($_ -replace "[\[\]]","")}}}

                New-Object -TypeName PSObject -Property @{
	                "Description" = $desc
	                "Store" = $store.store
	                "Thumbprint (SHA1)" = $thumbprint.thumbprint
	                "Issuer" = $issuer.issuer
                    }
                } | Select-Object "Description","Store","Thumbprint (SHA1)","Issuer" | Export-Csv -Path "$OUTPUT_FOLDER\sys\certificates\certificates.csv" -Delimiter "`t" -NoTypeInformation
            }

            # XLSX
            if (Get-Module -ListAvailable -Name ImportExcel)
            {
                if (Test-Path "$OUTPUT_FOLDER\sys\certificates\certificates.csv")
                {
                    if([int](& $xsv count -d "`t" "$OUTPUT_FOLDER\sys\certificates\certificates.csv") -gt 0)
                    {
                        $IMPORT = Import-Csv "$OUTPUT_FOLDER\sys\certificates\certificates.csv" -Delimiter "`t"
                        $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\sys\certificates\certificates.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Certificates" -CellStyleSB {
                        param($WorkSheet)
                        # BackgroundColor and FontColor for specific cells of TopRow
                        $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                        Set-Format -Address $WorkSheet.Cells["A1:D1"] -BackgroundColor $BackgroundColor -FontColor White
                        # HorizontalAlignment "Center" of columns B-C
                        $WorkSheet.Cells["B:C"].Style.HorizontalAlignment="Center"
                        }
                    }
                }
            }
        }

        # FS_Sys_Drivers
        # https://github.com/ufrisk/MemProcFS/wiki/FS_Sys_Drivers
        if (Test-Path "$DriveLetter\sys\drivers\*.txt")
        {
            New-Item "$OUTPUT_FOLDER\sys\drivers" -ItemType Directory -Force | Out-Null
            Copy-Item "$DriveLetter\sys\drivers\*.txt" -Destination "$OUTPUT_FOLDER\sys\drivers"

            # CSV
            if (Test-Path "$DriveLetter\forensic\json\general.json")
            {
                $Data = Get-Content "$DriveLetter\forensic\json\general.json" | ConvertFrom-Json | Where-Object { $_.type -eq "driver" }

                $Data | Foreach-Object {

                $obj = $_ | Select-Object -ExpandProperty obj
                $desc = $_ | Select-Object -ExpandProperty desc
                $size = $_ | Select-Object -ExpandProperty size -ErrorAction SilentlyContinue
                $addr = $_ | Select-Object -ExpandProperty addr -ErrorAction SilentlyContinue
                $addr2 = $_ | Select-Object -ExpandProperty addr2 -ErrorAction SilentlyContinue
                $svc = $_ | Select-Object -ExpandProperty desc2 | Select-Object @{Name="svc"; Expression={ForEach-Object{($_ -split "svc:")[1]} | ForEach-Object{($_ -split "path:")[0]} | ForEach-Object{($_ -replace "[\[\]]","")}}}
                $path = $_ | Select-Object -ExpandProperty desc2 | Select-Object @{Name="path"; Expression={ForEach-Object{($_ -split "path:")[1]} | ForEach-Object{($_ -replace "[\[\]]","")}}}

                New-Object -TypeName PSObject -Property @{
                    "Object Address" = $obj
                    "Driver" = $desc
                    "Size" = $size
                    "Start" = $addr
                    "End" = $addr2
                    "Service Key" = $svc.svc
                    "Driver Name" = $path.path
                    }
                } | Select-Object "Object Address","Driver","Size","Start","End","Service Key","Driver Name" | Export-Csv -Path "$OUTPUT_FOLDER\sys\drivers\drivers.csv" -Delimiter "`t" -NoTypeInformation
            }

            # XLSX
            if (Get-Module -ListAvailable -Name ImportExcel)
            {
                if (Test-Path "$OUTPUT_FOLDER\sys\drivers\drivers.csv")
                {
                    if([int](& $xsv count -d "`t" "$OUTPUT_FOLDER\sys\drivers\drivers.csv") -gt 0)
                    {
                        $IMPORT = Import-Csv "$OUTPUT_FOLDER\sys\drivers\drivers.csv" -Delimiter "`t"
                        $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\sys\drivers\drivers.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Drivers" -CellStyleSB {
                        param($WorkSheet)
                        # BackgroundColor and FontColor for specific cells of TopRow
                        $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                        Set-Format -Address $WorkSheet.Cells["A1:G1"] -BackgroundColor $BackgroundColor -FontColor White
                        # HorizontalAlignment "Center" of columns A, D-E
                        $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                        $WorkSheet.Cells["D:E"].Style.HorizontalAlignment="Center"
                        # HorizontalAlignment "Right" of column C
                        $WorkSheet.Cells["C:C"].Style.HorizontalAlignment="Right"
                        # HorizontalAlignment "Center" of header of column C
                        $WorkSheet.Cells["C1:C1"].Style.HorizontalAlignment="Center"
                        }
                    }
                }
            }
        }

        # FS_SysInfo_Network
        # https://github.com/ufrisk/MemProcFS/wiki/FS_SysInfo_Network
        if (Test-Path "$DriveLetter\sys\net\*.txt")
        {
            New-Item "$OUTPUT_FOLDER\sys\net" -ItemType Directory -Force | Out-Null

            # netstat.txt
            if (Test-Path "$DriveLetter\sys\net\netstat.txt")
            { 
                Copy-Item "$DriveLetter\sys\net\netstat.txt" -Destination "$OUTPUT_FOLDER\sys\net\netstat.txt"

                # CSV
                if (Test-Path "$DriveLetter\forensic\json\general.json")
                {
                    New-Item "$OUTPUT_FOLDER\sys\net\CSV" -ItemType Directory -Force | Out-Null
                    
                    $Data = Get-Content "$DriveLetter\forensic\json\general.json" | ConvertFrom-Json | Where-Object { $_.type -eq "net" }

                    $Data | Foreach-Object {

                    $proc = $_ | Select-Object -ExpandProperty proc -ErrorAction SilentlyContinue
                    $procid = $_ | Select-Object -ExpandProperty pid -ErrorAction SilentlyContinue
                    $obj = $_ | Select-Object -ExpandProperty obj
                    $desc = $_ | Select-Object -ExpandProperty desc
                    $time = $_ | Select-Object -ExpandProperty desc2 | Select-Object @{Name="time"; Expression={ForEach-Object{($_ -split "time:")[1]} | ForEach-Object{($_ -split "path:")[0]} | ForEach-Object{($_ -replace "[\[\]]","")}}}
                    $path = $_ | Select-Object -ExpandProperty desc2 | Select-Object @{Name="path"; Expression={ForEach-Object{($_ -split "path:")[1]} | ForEach-Object{($_ -replace "[\[\]]","")}}}
                    
                    New-Object -TypeName PSObject -Property @{
                        "Process" = $proc
                        "PID" = $procid
                        "Protocol" = $desc | ForEach-Object{($_ -split "\s+")[0]}
                        "State" = $desc | ForEach-Object{($_ -split "\s+")[1]}
                        "Source" = $desc | ForEach-Object{($_ -split "\s+")[2]}
                        "Destination" = $desc | ForEach-Object{($_ -split "\s+")[3]}
                        "Time" = $time.time
                        "Object Address" = $obj
                        "Process Path" = $path.path
                        }
                    } | Select-Object "Process","PID","Protocol","State","Source","Destination","Time","Object Address","Process Path" | Export-Csv -Path "$OUTPUT_FOLDER\sys\net\CSV\net.csv" -Delimiter "`t" -NoTypeInformation
                }

                # Custom CSV
                if (Test-Path "$DriveLetter\forensic\json\general.json")
                {
                    New-Item "$OUTPUT_FOLDER\sys\net\CSV" -ItemType Directory -Force | Out-Null
                    
                    $Data = Get-Content "$DriveLetter\forensic\json\general.json" | ConvertFrom-Json | Where-Object { $_.type -eq "net" }

                    $Data | Foreach-Object {

                    $proc = $_ | Select-Object -ExpandProperty proc -ErrorAction SilentlyContinue
                    $procid = $_ | Select-Object -ExpandProperty pid -ErrorAction SilentlyContinue
                    $obj = $_ | Select-Object -ExpandProperty obj
                    $desc = $_ | Select-Object -ExpandProperty desc
                    $time = $_ | Select-Object -ExpandProperty desc2 | Select-Object @{Name="time"; Expression={ForEach-Object{($_ -split "time:")[1]} | ForEach-Object{($_ -split "path:")[0]} | ForEach-Object{($_ -replace "[\[\]]","")}}}
                    $path = $_ | Select-Object -ExpandProperty desc2 | Select-Object @{Name="path"; Expression={ForEach-Object{($_ -split "path:")[1]} | ForEach-Object{($_ -replace "[\[\]]","")}}}
                    
                    New-Object -TypeName PSObject -Property @{
                        "Process" = $proc
                        "PID" = $procid
                        "Protocol" = $desc | ForEach-Object{($_ -split "\s+")[0]}
                        "State" = $desc | ForEach-Object{($_ -split "\s+")[1]}
                        "Source" = ($desc | ForEach-Object{($_ -split "\s+")[2]} | Select-Object @{Name="Source"; Expression={ ForEach-Object{($_ -replace ":\d+$","")}}}).Source
                        "SrcPort" = ($desc | ForEach-Object{($_ -split "\s+")[2]} | Select-Object @{Name="SrcPort"; Expression={ ForEach-Object{($_ -split ":")[-1]} | ForEach-Object{($_ -replace "\*\*\*","")}}}).SrcPort
                        "Destination" = ($desc | ForEach-Object{($_ -split "\s+")[3]} | Select-Object @{Name="Destination"; Expression={ ForEach-Object{($_ -replace ":\d+$","")}}}).Destination
                        "DstPort" = ($desc | ForEach-Object{($_ -split "\s+")[3]} | Select-Object @{Name="DstPort"; Expression={ ForEach-Object{($_ -split ":")[-1]} | ForEach-Object{($_ -replace "\*\*\*","")}}}).DstPort
                        "Time" = $time.time
                        "Object Address" = $obj
                        "Process Path" = $path.path
                        }
                    } | Select-Object "Process","PID","Protocol","State","Source","SrcPort","Destination","DstPort","Time","Object Address","Process Path" | Export-Csv -Path "$OUTPUT_FOLDER\sys\net\CSV\net-custom.csv" -Delimiter "`t" -NoTypeInformation
                }

                # XLSX
                if (Get-Module -ListAvailable -Name ImportExcel)
                {
                    if (Test-Path "$OUTPUT_FOLDER\sys\net\CSV\net.csv")
                    {
                        if([int](& $xsv count -d "`t" "$OUTPUT_FOLDER\sys\net\CSV\net.csv") -gt 0)
                        {
                            New-Item "$OUTPUT_FOLDER\sys\net\XLSX" -ItemType Directory -Force | Out-Null
                            $IMPORT = Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net.csv" -Delimiter "`t"
                            $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\sys\net\XLSX\net.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Network" -CellStyleSB {
                            param($WorkSheet)
                            # BackgroundColor and FontColor for specific cells of TopRow
                            $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                            Set-Format -Address $WorkSheet.Cells["A1:I1"] -BackgroundColor $BackgroundColor -FontColor White
                            # HorizontalAlignment "Center" of columns B-H
                            $WorkSheet.Cells["B:H"].Style.HorizontalAlignment="Center"
                            }
                        }
                    }
                }

                # Custom XLSX
                if (Get-Module -ListAvailable -Name ImportExcel)
                {
                    if (Test-Path "$OUTPUT_FOLDER\sys\net\CSV\net-custom.csv")
                    {
                        if([int](& $xsv count -d "`t" "$OUTPUT_FOLDER\sys\net\CSV\net-custom.csv") -gt 0)
                        {
                            New-Item "$OUTPUT_FOLDER\sys\net\XLSX" -ItemType Directory -Force | Out-Null
                            $IMPORT = Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net-custom.csv" -Delimiter "`t"
                            $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\sys\net\XLSX\net-custom.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Network" -CellStyleSB {
                            param($WorkSheet)
                            # BackgroundColor and FontColor for specific cells of TopRow
                            $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                            Set-Format -Address $WorkSheet.Cells["A1:K1"] -BackgroundColor $BackgroundColor -FontColor White
                            # HorizontalAlignment "Center" of columns B-J
                            $WorkSheet.Cells["B:J"].Style.HorizontalAlignment="Center"
                            }
                        }
                    }
                }

                # IPv4
                # https://ipinfo.io/bogon
                New-Item "$OUTPUT_FOLDER\sys\net\IPv4" -ItemType Directory -Force | Out-Null
                $IPv4 = "(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)"
                $Private = "^(192\.168|10\.|172\.1[6789]\.|172\.2[0-9]\.|172\.3[01]\.)"
                $Special = "^(0\.0\.0\.0|127\.0\.0\.1|169\.254\.|224\.0\.0)"
                Get-Content "$OUTPUT_FOLDER\sys\net\netstat.txt" | Select-String -Pattern $IPv4 -AllMatches | ForEach-Object { $_.Matches } | ForEach-Object { $_.Value } | Sort-Object -Unique -Property { [System.Version]$_ } | Out-File "$OUTPUT_FOLDER\sys\net\IPv4\IPv4-All.txt"
                Get-Content "$OUTPUT_FOLDER\sys\net\netstat.txt" | Select-String -Pattern $IPv4 -AllMatches | ForEach-Object { $_.Matches } | ForEach-Object { $_.Value } | Sort-Object -Unique -Property { [System.Version]$_ } | Where-Object {$_ -notmatch $Private} | Where-Object {$_ -notmatch $Special} | Out-File "$OUTPUT_FOLDER\sys\net\IPv4\IPv4.txt"

                # Count
                $Total = (Get-Content "$OUTPUT_FOLDER\sys\net\IPv4\IPv4-All.txt" | Measure-Object).Count
                $Count = (Get-Content "$OUTPUT_FOLDER\sys\net\IPv4\IPv4.txt" | Measure-Object).Count
                Write-Output "[Info]  $Count IPv4 addresses found ($Total)"

                # IPv6
                # https://ipinfo.io/bogon
                New-Item "$OUTPUT_FOLDER\sys\net\IPv6" -ItemType Directory -Force | Out-Null
                $IPv6 = ":(?::[a-f\d]{1,4}){0,5}(?:(?::[a-f\d]{1,4}){1,2}|:(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})\.){3}(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})))|[a-f\d]{1,4}:(?:[a-f\d]{1,4}:(?:[a-f\d]{1,4}:(?:[a-f\d]{1,4}:(?:[a-f\d]{1,4}:(?:[a-f\d]{1,4}:(?:[a-f\d]{1,4}:(?:[a-f\d]{1,4}|:)|(?::(?:[a-f\d]{1,4})?|(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})\.){3}(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))))|:(?:(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})\.){3}(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|[a-f\d]{1,4}(?::[a-f\d]{1,4})?|))|(?::(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})\.){3}(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|:[a-f\d]{1,4}(?::(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})\.){3}(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[a-f\d]{1,4}){0,2})|:))|(?:(?::[a-f\d]{1,4}){0,2}(?::(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})\.){3}(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[a-f\d]{1,4}){1,2})|:))|(?:(?::[a-f\d]{1,4}){0,3}(?::(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})\.){3}(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[a-f\d]{1,4}){1,2})|:))|(?:(?::[a-f\d]{1,4}){0,4}(?::(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})\.){3}(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[a-f\d]{1,4}){1,2})|:))"
                $Bogon = "^(::1|::ffff:0:0|100::|2001:10::|2001:db8::|fc00::|fe80::|fec0::|ff00::)"
                Get-Content "$OUTPUT_FOLDER\sys\net\netstat.txt" | Select-String -Pattern $IPv6 -AllMatches | ForEach-Object { $_.Matches } | ForEach-Object { $_.Value } | Sort-Object -Unique | Out-File "$OUTPUT_FOLDER\sys\net\IPv6\IPv6-All.txt"
                Get-Content "$OUTPUT_FOLDER\sys\net\netstat.txt" | ForEach-Object{($_ -split "\s+")[5]} | Select-String -Pattern $IPv6 -AllMatches | ForEach-Object { $_.Matches } | ForEach-Object { $_.Value } | Sort-Object -Unique | Where-Object {$_ -notmatch $Bogon} | Out-File "$OUTPUT_FOLDER\sys\net\IPv6\IPv6.txt"

                # Count
                $Total = (Get-Content "$OUTPUT_FOLDER\sys\net\IPv6\IPv6-All.txt" | Measure-Object).Count
                $Count = (Get-Content "$OUTPUT_FOLDER\sys\net\IPv6\IPv6.txt" | Measure-Object).Count
                Write-Output "[Info]  $Count IPv6 addresses found ($Total)"

                # IP.txt
                Write-Output "IPAddress" | Out-File "$OUTPUT_FOLDER\sys\net\IP.txt" # Header

                # IPv4.txt
                if (Test-Path "$OUTPUT_FOLDER\sys\net\IPv4\IPv4.txt")
                {
                    if ((Get-Item "$OUTPUT_FOLDER\sys\net\IPv4\IPv4.txt").Length -gt 0kb)
                    {
                        Get-Content -Path "$OUTPUT_FOLDER\sys\net\IPv4\IPv4.txt" | Out-File "$OUTPUT_FOLDER\sys\net\IP.txt" -Append
                    }
                }

                # IPv6.txt
                if (Test-Path "$OUTPUT_FOLDER\sys\net\IPv6\IPv6.txt")
                {
                    if ((Get-Item "$OUTPUT_FOLDER\sys\net\IPv6\IPv6.txt").Length -gt 0kb)
                    {
                        Get-Content -Path "$OUTPUT_FOLDER\sys\net\IPv6\IPv6.txt" | Out-File "$OUTPUT_FOLDER\sys\net\IP.txt" -Append
                    }
                }

                # IPinfo CLI (50000 requests per month)
                if (Test-Path "$($IPinfo)")
                {
                    if (Test-Path "$OUTPUT_FOLDER\sys\net\IP.txt")
                    {
                        if ((Get-Item "$OUTPUT_FOLDER\sys\net\IP.txt").Length -gt 0kb)
                        {
                            # Offline Mode
                            if ($OfflineMode -eq "Enabled")
                            {
                                Write-Output "[Info]  IP Data Enrichment w/ IPinfo.io will be skipped [Offline-Mode] ..."
                            }
                            else
                            {
                                # Internet Connectivity Check (Vista+)
                                $NetworkListManager = [Activator]::CreateInstance([Type]::GetTypeFromCLSID([Guid]‘{DCB00C01-570F-4A9B-8D69-199FDBA5723B}’)).IsConnectedToInternet

                                if (!($NetworkListManager -eq "True"))
                                {
                                    Write-Host "[Error] Your computer is NOT connected to the Internet. IP addresses cannot be checked via IPinfo API." -ForegroundColor Red
                                }
                                else
                                {
                                    # Check if IPinfo.io is reachable
                                    if (!(Test-Connection -ComputerName ipinfo.io -Count 1 -Quiet))
                                    {
                                        Write-Host "[Error] ipinfo.io is NOT reachable. IP addresses cannot be checked via IPinfo API." -ForegroundColor Red
                                    }
                                    else
                                    {
                                        # Map IPs
                                        # https://ipinfo.io/map
                                        New-Item "$OUTPUT_FOLDER\sys\net\IPinfo" -ItemType Directory -Force | Out-Null
                                        Get-Content "$OUTPUT_FOLDER\sys\net\IP.txt" | & $IPinfo map | Out-File "$OUTPUT_FOLDER\sys\net\IPinfo\Map.txt"

                                        # Access Token
                                        # https://ipinfo.io/signup?ref=cli
                                        if (!("$IPInfoToken" -eq "access_token"))
                                        {
                                            # Summarize IPs
                                            # https://ipinfo.io/summarize-ips

                                            # TXT --> lists VPNs
                                            Get-Content "$OUTPUT_FOLDER\sys\net\IP.txt" | & $IPinfo summarize -t $IPInfoToken | Out-File "$OUTPUT_FOLDER\sys\net\IPinfo\Summary.txt"

                                            # CSV
                                            Get-Content "$OUTPUT_FOLDER\sys\net\IP.txt" | & $IPinfo --csv -t $IPInfoToken | Out-File "$OUTPUT_FOLDER\sys\net\IPinfo\IPinfo.csv"

                                            # Custom CSV (Free)
                                            if (Test-Path "$OUTPUT_FOLDER\sys\net\IPinfo\IPinfo.csv")
                                            {
                                                if([int](& $xsv count "$OUTPUT_FOLDER\sys\net\IPinfo\IPinfo.csv") -gt 0)
                                                {
                                                    $IPinfoRecords = Import-Csv "$OUTPUT_FOLDER\sys\net\IPinfo\IPinfo.csv" -Delimiter "," -Encoding UTF8
                                
                                                    $CustomCsv = @()

                                                    ForEach($IPinfoRecord in $IPinfoRecords)
                                                    {
                                                        $Line = [PSCustomObject]@{
                                                            "IP"           = $IPinfoRecord.ip
                                                            "City"         = $IPinfoRecord.city
                                                            "Region"       = $IPinfoRecord.region
                                                            "Country"      = $IPinfoRecord.country
                                                            "Country Name" = $IPinfoRecord.country_name
                                                            "EU"           = $IPinfoRecord.isEU
                                                            "Location"     = $IPinfoRecord.loc
                                                            "ASN"          = $IPinfoRecord | Select-Object -ExpandProperty org | ForEach-Object{($_ -split "\s+")[0]}
                                                            "OrgName"      = $IPinfoRecord | Select-Object -ExpandProperty org | ForEach-Object {$_ -replace "^AS[0-9]+ "}
                                                            "Postal Code"  = $IPinfoRecord.postal
                                                            "Timezone"     = $IPinfoRecord.timezone
                                                        }

                                                        $CustomCsv += $Line
                                                    }

                                                    $CustomCsv | Sort-Object {$_.IP -as [Version]} | Export-Csv -Path "$OUTPUT_FOLDER\sys\net\IPinfo\IPinfo-Custom.csv" -NoTypeInformation -Encoding UTF8
                                                }
                                            }

                                            # Custom XLSX (Free)
                                            if (Get-Module -ListAvailable -Name ImportExcel)
                                            {
                                                if (Test-Path "$OUTPUT_FOLDER\sys\net\IPinfo\IPinfo-Custom.csv")
                                                {
                                                    if([int](& $xsv count "$OUTPUT_FOLDER\sys\net\IPinfo\IPinfo-Custom.csv") -gt 0)
                                                    {
                                                        $IMPORT = Import-Csv "$OUTPUT_FOLDER\sys\net\IPinfo\IPinfo-Custom.csv" -Delimiter "," | Sort-Object {$_.IP -as [Version]}
                                                        $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\sys\net\IPinfo\IPinfo-Custom.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -IncludePivotTable -PivotTableName "PivotTable" -PivotRows "Country Name" -PivotData @{"IP"="Count"} -WorkSheetname "IPinfo (Free)" -CellStyleSB {
                                                        param($WorkSheet)
                                                        # BackgroundColor and FontColor for specific cells of TopRow
                                                        $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                                                        Set-Format -Address $WorkSheet.Cells["A1:K1"] -BackgroundColor $BackgroundColor -FontColor White
                                                        # HorizontalAlignment "Center" of columns A-K
                                                        $WorkSheet.Cells["A:K"].Style.HorizontalAlignment="Center"
                                                        }
                                                    }
                                                }
                                            }

                                            # XLSX (Free)
                                            if (Get-Module -ListAvailable -Name ImportExcel)
                                            {
                                                if (Test-Path "$OUTPUT_FOLDER\sys\net\IPinfo\IPinfo.csv")
                                                {
                                                    if([int](& $xsv count "$OUTPUT_FOLDER\sys\net\IPinfo\IPinfo.csv") -gt 0)
                                                    {
                                                        $IMPORT = Import-Csv "$OUTPUT_FOLDER\sys\net\IPinfo\IPinfo.csv" -Delimiter "," -Encoding UTF8 | Select-Object ip,city,region,country,country_name,isEU,loc,org,postal,timezone | Sort-Object {$_.ip -as [Version]}
                                                        $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\sys\net\IPinfo\IPinfo.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "IPinfo" -CellStyleSB {
                                                        param($WorkSheet)
                                                        # BackgroundColor and FontColor for specific cells of TopRow
                                                        $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                                                        Set-Format -Address $WorkSheet.Cells["A1:J1"] -BackgroundColor $BackgroundColor -FontColor White
                                                        # HorizontalAlignment "Center" of columns A-J
                                                        $WorkSheet.Cells["A:J"].Style.HorizontalAlignment="Center"
                                                        }
                                                    }
                                                }
                                            }

                                            # Create HashTable and import 'IPinfo-Custom.csv'
                                            $script:HashTable = @{}
                                            if (Test-Path "$OUTPUT_FOLDER\sys\net\IPinfo\IPinfo-Custom.csv")
                                            {
                                                if([int](& $xsv count "$OUTPUT_FOLDER\sys\net\IPinfo\IPinfo-Custom.csv") -gt 0)
                                                {
                                                    Import-Csv "$OUTPUT_FOLDER\sys\net\IPinfo\IPinfo-Custom.csv" -Delimiter "," -Encoding UTF8 | ForEach-Object { $HashTable[$_.IP] = $_.City,$_.Region,$_.Country,$_."Country Name",$_.EU,$_.Location,$_.ASN,$_.OrgName,$_."Postal Code",$_.Timezone }

                                                    # Count Ingested Properties
                                                    $Count = $HashTable.Count
                                                    Write-Output "[Info]  Initializing 'IPinfo-Custom.csv' Lookup Table ($Count) ..."
                                                }
                                            }

                                            # IP Data Enrichment w/ IPinfo.io
                                            if (Test-Path "$OUTPUT_FOLDER\sys\net\CSV\net-custom.csv")
                                            {
                                                if([int](& $xsv count "$OUTPUT_FOLDER\sys\net\CSV\net-custom.csv") -gt 0)
                                                {
                                                    $Records = Import-Csv -Path "$OUTPUT_FOLDER\sys\net\CSV\net-custom.csv" -Delimiter "`t" -Encoding UTF8

                                                    # CSV
                                                    $Results = @()
                                                    ForEach($Record in $Records)
                                                    {
                                                        $Source = $Record.Source | & $IPinfo grepip -o
                                                        $Destination = $Record.Destination | & $IPinfo grepip -o

                                                        # Check if HashTable contains Source IP
                                                        if($HashTable.ContainsKey("$Source"))
                                                        {
                                                            $SrcCountryName = $HashTable["$Source"][3]
                                                            $SrcASN         = $HashTable["$Source"][6]
                                                            $SrcOrgName     = $HashTable["$Source"][7]
                                                        }
                                                        else
                                                        {
                                                            $SrcCountryName = ""
                                                            $SrcASN         = ""
                                                            $SrcOrgName     = ""
                                                        }

                                                        # Check if HashTable contains Destination IP
                                                        if($HashTable.ContainsKey("$Destination"))
                                                        {
                                                            $DstCountryName = $HashTable["$Destination"][3]
                                                            $DstASN         = $HashTable["$Destination"][6]
                                                            $DstOrgName     = $HashTable["$Destination"][7]
                                                        }
                                                        else
                                                        {
                                                            $DstCountryName = ""
                                                            $DstASN         = ""
                                                            $DstOrgName     = ""
                                                        }
                                                        
                                                        $Line = [PSCustomObject]@{
                                                            "Process"        = $Record.Process
                                                            "PID"            = $Record.PID
                                                            "Protocol"       = $Record.Protocol
                                                            "State"          = $Record.State
                                                            "Src IP"         = $Record.Source
                                                            "Src Port"       = $Record.SrcPort
                                                            "Src Country"    = $SrcCountryName
                                                            "Src ASN"        = $SrcASN
                                                            "Src OrgName"    = $SrcOrgName
                                                            "Dst IP"         = $Record.Destination
                                                            "Dst Port"       = $Record.DstPort
                                                            "Dst Country"    = $DstCountryName
                                                            "Dst ASN"        = $DstASN
                                                            "Dst OrgName"    = $DstOrgName
                                                            "Time"           = $Record.Time
                                                            "Object Address" = $Record."Object Address"
                                                            "Process Path"   = $Record."Process Path"
                                                        }

                                                        $Results += $Line
                                                    }

                                                    $Results | Export-Csv -Path "$OUTPUT_FOLDER\sys\net\CSV\net-enriched.csv" -NoTypeInformation -Encoding UTF8
                                                }
                                            }

                                            # XLSX
                                            if (Get-Module -ListAvailable -Name ImportExcel)
                                            {
                                                if (Test-Path "$OUTPUT_FOLDER\sys\net\CSV\net-enriched.csv")
                                                {
                                                    if([int](& $xsv count "$OUTPUT_FOLDER\sys\net\CSV\net-enriched.csv") -gt 0)
                                                    {
                                                        $IMPORT = Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net-enriched.csv" -Delimiter "," | Sort-Object { $_.CreationDate -as [datetime] } -Descending
                                                        $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\sys\net\XLSX\net-enriched.xlsx" -NoHyperLinkConversion * -NoNumberConversion * -FreezePane 2,5 -BoldTopRow -AutoSize -AutoFilter -IncludePivotTable -PivotTableName "PivotTable" -WorkSheetname "IP Data Enrichment" -CellStyleSB {
                                                        param($WorkSheet)
                                                        # BackgroundColor and FontColor for specific cells of TopRow
                                                        $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                                                        Set-Format -Address $WorkSheet.Cells["A1:Q1"] -BackgroundColor $BackgroundColor -FontColor White
                                                        # HorizontalAlignment "Center" of columns A-Q
                                                        $WorkSheet.Cells["A:Q"].Style.HorizontalAlignment="Center"
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                else
                {
                    Write-Output "[Info]  ipinfo.exe NOT found."
                }
            }

            # netstat-v.txt
            if (Test-Path "$DriveLetter\sys\net\netstat-v.txt")
            {
                Copy-Item "$DriveLetter\sys\net\netstat-v.txt" -Destination "$OUTPUT_FOLDER\sys\net\netstat-v.txt"
            }

            # State
            if ((Test-Path "$OUTPUT_FOLDER\sys\net\CSV\net.csv") -And ([int](& $xsv count -d "`t" "$OUTPUT_FOLDER\sys\net\CSV\net.csv") -gt 0))
            {
                $CLOSED      = (Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net.csv" -Delimiter "`t" | Where-Object { $_.State -eq "CLOSED" }).Count
                $CLOSING     = (Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net.csv" -Delimiter "`t" | Where-Object { $_.State -eq "CLOSING" }).Count
                $CLOSE_WAIT  = (Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net.csv" -Delimiter "`t" | Where-Object { $_.State -eq "CLOSE_WAIT" }).Count
                $ESTABLISHED = (Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net.csv" -Delimiter "`t" | Where-Object { $_.State -eq "ESTABLISHED" }).Count
                $FIN_WAIT_1  = (Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net.csv" -Delimiter "`t" | Where-Object { $_.State -eq "FIN_WAIT_1" }).Count
                $FIN_WAIT_2  = (Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net.csv" -Delimiter "`t" | Where-Object { $_.State -eq "FIN_WAIT_2" }).Count
                $LAST_ACK    = (Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net.csv" -Delimiter "`t" | Where-Object { $_.State -eq "LAST_ACK" }).Count
                $LISTENING   = (Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net.csv" -Delimiter "`t" | Where-Object { $_.State -eq "LISTENING" }).Count
                $SYN_RCVD    = (Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net.csv" -Delimiter "`t" | Where-Object { $_.State -eq "SYN_RCVD" }).Count
                $SYN_SENT    = (Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net.csv" -Delimiter "`t" | Where-Object { $_.State -eq "SYN_SENT" }).Count
                $TIME_WAIT   = (Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net.csv" -Delimiter "`t" | Where-Object { $_.State -eq "TIME_WAIT" }).Count

                Write-Output "CLOSED      : $CLOSED" | Out-File "$OUTPUT_FOLDER\sys\net\State.txt" -Append
                Write-Output "CLOSING     : $CLOSING" | Out-File "$OUTPUT_FOLDER\sys\net\State.txt" -Append
                Write-Output "CLOSE_WAIT  : $CLOSE_WAIT" | Out-File "$OUTPUT_FOLDER\sys\net\State.txt" -Append
                Write-Output "ESTABLISHED : $ESTABLISHED" | Out-File "$OUTPUT_FOLDER\sys\net\State.txt" -Append
                Write-Output "FIN_WAIT_1  : $FIN_WAIT_1" | Out-File "$OUTPUT_FOLDER\sys\net\State.txt" -Append
                Write-Output "FIN_WAIT_2  : $FIN_WAIT_2" | Out-File "$OUTPUT_FOLDER\sys\net\Stats.txt" -Append
                Write-Output "LAST_ACK    : $LAST_ACK" | Out-File "$OUTPUT_FOLDER\sys\net\State.txt" -Append
                Write-Output "LISTENING   : $LISTENING" | Out-File "$OUTPUT_FOLDER\sys\net\State.txt" -Append
                Write-Output "SYN_RCVD    : $SYN_RCVD" | Out-File "$OUTPUT_FOLDER\sys\net\State.txt" -Append
                Write-Output "SYN_SENT    : $SYN_SENT" | Out-File "$OUTPUT_FOLDER\sys\net\State.txt" -Append
                Write-Output "TIME_WAIT   : $TIME_WAIT" | Out-File "$OUTPUT_FOLDER\sys\net\State.txt" -Append
            }

            # Stats
            if ((Test-Path "$OUTPUT_FOLDER\sys\net\State.txt") -And ((Get-Item "$OUTPUT_FOLDER\sys\net\State.txt").length -gt 0kb))
            {
                $Stats = Get-Content "$OUTPUT_FOLDER\sys\net\State.txt" | ForEach-Object{($_ -replace ":","")} | ConvertFrom-String -PropertyNames State, Count | Sort-Object Count -Descending
                ($Stats | Out-String).Trim() | Out-File "$OUTPUT_FOLDER\sys\net\Stats.txt"
            }

            # CLOSED        Closed. The socket is not being used.
            # CLOSING       Closed, then remote shutdown; awaiting acknowledgment.
            # CLOSE_WAIT    Remote shutdown; waiting for the socket to close.
            # ESTABLISHED   Connection has been established.
            # FIN_WAIT_1    Socket closed; shutting down connection.
            # FIN_WAIT_2    Socket closed; waiting for shutdown from remote.
            # LAST_ACK      Remote shutdown, then closed; awaiting acknowledgment.
            # LISTENING     Listening for incoming connections.
            # SYN_RCVD      Active/initiate synchronization received and the connection under way.
            # SYN_SENT      Actively trying to establish connection.
            # TIME_WAIT     Wait after close for remote shutdown retransmission.
                
            # Suspicious Port Numbers

            # Source

            # TCP on Source Port 3262 --> This rule detects events that may indicate use of encrypted traffic on TCP port 3262 (F-Response)
            $Import = Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net.csv" -Delimiter "`t" | Where-Object { $_.Protocol -like "TCP*" } | Where-Object { $_.Source -like "*:3262" } | Sort-Object { $_.Time -as [datetime] }
            $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)
            if ($Count -gt 0)
            {
                Write-Output "[Info]  TCP on Source Port 3262 detected - May indicates use of encrypted traffic by F-Response ($Count)"
                New-Item "$OUTPUT_FOLDER\sys\net\Detections" -ItemType Directory -Force | Out-Null
                $Import | Out-File "$OUTPUT_FOLDER\sys\net\Detections\TCP-on-Source-Port-3262.txt"
            }

            # TCP on Source Port 3389 --> This rule detects events that may indicate incoming Remote Desktop Protocol (RDP) activity on TCP port 3389 - Incoming
            # Note: proc.xlsx --> CommandLine: C:\Windows\System32\svchost.exe -k termsvc
            $Import = Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net.csv" -Delimiter "`t" | Where-Object { $_.Source -match ":3389$" } | Where-Object { $_.Process -eq "svchost.exe" } | Sort-Object { $_.Time -as [datetime] }
            $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)
            if ($Count -gt 0)
            {
                Write-Host "[Alert] TCP on Source Port 3389 detected - May indicates incoming Remote Desktop Protocol (RDP) activity ($Count)" -ForegroundColor Red
                New-Item "$OUTPUT_FOLDER\sys\net\Detections" -ItemType Directory -Force | Out-Null
                $Import | Out-File "$OUTPUT_FOLDER\sys\net\Detections\TCP-on-Source-Port-3389.txt"
            }

            # TCP on Source Port 4444 --> This rule detects events that may indicate a Meterpreter session (Reverse Shell)
            $Import = Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net.csv" -Delimiter "`t" | Where-Object { $_.Protocol -like "TCP*" } | Where-Object { $_.State -eq "LISTENING" } | Where-Object { $_.Source -match ":4444$" } | Sort-Object { $_.Time -as [datetime] }
            $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)
            if ($Count -gt 0)
            {
                Write-Host "[Alert] TCP on Source Port 4444 detected - May indicates use of Meterpreter Reverse Shell ($Count)" -ForegroundColor Red
                New-Item "$OUTPUT_FOLDER\sys\net\Detections" -ItemType Directory -Force | Out-Null
                $Import | Out-File "$OUTPUT_FOLDER\sys\net\Detections\TCP-on-Source-Port-4444.txt"
            }

            # TCP on Source Port 4899 --> This rule detects events that may indicate incoming Radmin-Server (Remote Desktop) activity on TCP port 4899 - Incoming (rserver3.exe)
            # Note: Radmin by Famatech Corp. (e.g. Advanced IP Scanner)
            # https://www.radmin.com/
            $Import = Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net.csv" -Delimiter "`t" | Where-Object { $_.Source -match ":4899$" }
            $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)
            if ($Count -gt 0)
            {
                Write-Host "[Alert] TCP on Source Port 4899 detected - May indicates incoming Radmin-Server (Remote Desktop) activity ($Count)" -ForegroundColor Red
                New-Item "$OUTPUT_FOLDER\sys\net\Detections" -ItemType Directory -Force | Out-Null
                $Import | Out-File "$OUTPUT_FOLDER\sys\net\Detections\TCP-on-Source-Port-4899.txt"
            }

            # Destination

            # TCP on Destination Port 20 --> This rule detects events that may indicate outgoing File Transfer Protocol (FTP) activity over port 20
            $Import = Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net.csv" -Delimiter "`t" | Where-Object { $_.Protocol -like "TCP*" } | Where-Object { $_.Destination -match ":20$" } | Sort-Object { $_.Time -as [datetime] }
            $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)
            if ($Count -gt 0)
            {
                Write-Host "[Alert] TCP on Destination Port 20 detected - May indicates outgoing File Transfer Protocol (FTP) activity ($Count)" -ForegroundColor Red
                New-Item "$OUTPUT_FOLDER\sys\net\Detections" -ItemType Directory -Force | Out-Null
                $Import | Out-File "$OUTPUT_FOLDER\sys\net\Detections\TCP-on-Destination-Port-20.txt"
            }

            # TCP on Destination Port 21 --> This rule detects events that may indicate outgoing File Transfer Protocol (FTP) activity over port 21
            $Import = Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net.csv" -Delimiter "`t" | Where-Object { $_.Protocol -like "TCP*" } | Where-Object { $_.Destination -match ":21$" } | Sort-Object { $_.Time -as [datetime] }
            $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)
            if ($Count -gt 0)
            {
                Write-Host "[Alert] TCP on Destination Port 21 detected - May indicates outgoing File Transfer Protocol (FTP) activity ($Count)" -ForegroundColor Red
                New-Item "$OUTPUT_FOLDER\sys\net\Detections" -ItemType Directory -Force | Out-Null
                $Import | Out-File "$OUTPUT_FOLDER\sys\net\Detections\TCP-on-Destination-Port-21.txt"
            }

            # TCP on Destination Port 3389 --> This rule detects events that may indicate outgoing Remote Desktop Protocol (RDP) activity on TCP port 3389 - Outgoing
            $Import = Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net.csv" -Delimiter "`t" | Where-Object { $_.Protocol -like "TCP*" } | Where-Object { $_.Destination -match ":3389$" } | Sort-Object { $_.Time -as [datetime] }
            $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)

            if ($Count -gt 0)
            {
                Write-Host "[Alert] TCP on Destination Port 3389 detected - May indicates outgoing Remote Desktop Protocol (RDP) activity ($Count)" -ForegroundColor Red
                New-Item "$OUTPUT_FOLDER\sys\net\Detections" -ItemType Directory -Force | Out-Null
                $Import | Out-File "$OUTPUT_FOLDER\sys\net\Detections\TCP-on-Destination-Port-3389.txt"
            }

            # TCP on Destination Port 4899 --> This rule detects events that may indicate outgoing Radmin Viewer (Remote Desktop) activity on TCP port 4899 - Outgoing (Radmin.exe)
            # Note: Radmin by Famatech Corp. (e.g. Advanced IP Scanner)
            # https://www.radmin.com/
            $Import = Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net.csv" -Delimiter "`t" | Where-Object { $_.Protocol -like "TCP*" } | Where-Object { $_.Destination -match ":4899$" } | Sort-Object { $_.Time -as [datetime] }
            $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)
            if ($Count -gt 0)
            {
                Write-Host "[Alert] TCP on Destination Port 4899 detected - May indicates outgoing Radmin-Viewer (Remote Desktop) activity ($Count)" -ForegroundColor Red
                New-Item "$OUTPUT_FOLDER\sys\net\Detections" -ItemType Directory -Force | Out-Null
                $Import | Out-File "$OUTPUT_FOLDER\sys\net\Detections\TCP-on-Destination-Port-4899.txt"
            }

            # TCP on Destination Port 17301 --> This rule detects events that may indicate outgoing Radmin-VPN (RvControlSvc.exe) activity on TCP port 17301 - Outgoing
            # Note: Radmin VPN by Famatech Corp. (e.g. Advanced IP Scanner)
            # https://www.radmin-vpn.com/
            $Import = Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net.csv" -Delimiter "`t" | Where-Object { $_.Protocol -like "TCP*" } | Where-Object { $_.Destination -match ":17301$" } | Sort-Object { $_.Time -as [datetime] }
            $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)
            if ($Count -gt 0)
            {
                Write-Host "[Alert] TCP on Destination Port 17301 detected - May indicates outgoing Radmin-VPN activity ($Count)" -ForegroundColor Red
                New-Item "$OUTPUT_FOLDER\sys\net\Detections" -ItemType Directory -Force | Out-Null
                $Import | Out-File "$OUTPUT_FOLDER\sys\net\Detections\TCP-on-Destination-Port-17301.txt"
            }

            # TCP on Destination Port 8080 --> This rule detects events that may indicate Command-and-Control (C2) activity over port 8080
            $Import = Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net.csv" -Delimiter "`t" | Where-Object { $_.Protocol -like "TCP*" } | Where-Object { $_.Destination -match ":8080$" } | Sort-Object { $_.Time -as [datetime] }
            $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)
            if ($Count -gt 0)
            {
                Write-Host "[Alert] TCP on Destination Port 8080 detected - May indicates Command-and-Control (C2) activity ($Count)" -ForegroundColor Red
                New-Item "$OUTPUT_FOLDER\sys\net\Detections" -ItemType Directory -Force | Out-Null
                $Import | Out-File "$OUTPUT_FOLDER\sys\net\Detections\TCP-on-Destination-Port-8080.txt"
            }

            # TCP on Destination Port 8081 --> This rule detects events that may indicate Command-and-Control (C2) activity over port 8081
            $Import = Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net.csv" -Delimiter "`t" | Where-Object { $_.Protocol -like "TCP*" } | Where-Object { $_.Destination -match ":8081$" } | Sort-Object { $_.Time -as [datetime] }
            $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)
            if ($Count -gt 0)
            {
                Write-Host "[Alert] TCP on Destination Port 8081 detected - May indicates Command-and-Control (C2) activity ($Count)" -ForegroundColor Red
                New-Item "$OUTPUT_FOLDER\sys\net\Detections" -ItemType Directory -Force | Out-Null
                $Import | Out-File "$OUTPUT_FOLDER\sys\net\Detections\TCP-on-Destination-Port-8081.txt"
            }

            # TCP on Destination Port 9001 --> This rule detects events that may indicate use of Tor client on TCP port 9001
            $Import = Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net.csv" -Delimiter "`t" | Where-Object { $_.Protocol -like "TCP*" } | Where-Object { $_.Destination -match ":9001$" } | Sort-Object { $_.Time -as [datetime] }
            $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)
            if ($Count -gt 0)
            {
                Write-Host "[Alert] TCP on Destination Port 9001 detected - May indicates Tor activity ($Count)" -ForegroundColor Red
                New-Item "$OUTPUT_FOLDER\sys\net\Detections" -ItemType Directory -Force | Out-Null
                $Import | Out-File "$OUTPUT_FOLDER\sys\net\Detections\TCP-on-Destination-Port-9001.txt"
            }

            # TCP on Destination Port 9030 --> This rule detects events that may indicate Tor activity on TCP port 9030
            $Import = Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net.csv" -Delimiter "`t" | Where-Object { $_.Protocol -like "TCP*" } | Where-Object { $_.Destination -match ":9030$" } | Sort-Object { $_.Time -as [datetime] }
            $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)
            if ($Count -gt 0)
            {
                Write-Host "[Alert] TCP on Destination Port 9030 detected - May indicates Tor activity ($Count)" -ForegroundColor Red
                New-Item "$OUTPUT_FOLDER\sys\net\Detections" -ItemType Directory -Force | Out-Null
                $Import | Out-File "$OUTPUT_FOLDER\sys\net\Detections\TCP-on-Destination-Port-9030.txt"
            }

            # TCP on Destination Port 9150 --> This rule detects events that may indicate use of Tor client on TCP port 9150
            $Import = Import-Csv "$OUTPUT_FOLDER\sys\net\CSV\net.csv" -Delimiter "`t" | Where-Object { $_.Protocol -like "TCP*" } | Where-Object { $_.Destination -eq "127.0.0.1:9150" } | Sort-Object { $_.Time -as [datetime] }
            $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)
            if ($Count -gt 0)
            {
                Write-Host "[Alert] TCP on Destination Port 9150 detected - May indicates Tor activity ($Count)" -ForegroundColor Red
                New-Item "$OUTPUT_FOLDER\sys\net\Detections" -ItemType Directory -Force | Out-Null
                $Import | Out-File "$OUTPUT_FOLDER\sys\net\Detections\TCP-on-Destination-Port-9150.txt"
            }
        }

        # FS_SysInfo_Network - DNS
        # https://github.com/ufrisk/MemProcFS/wiki/FS_SysInfo_Network
        if (Test-Path "$DriveLetter\sys\net\dns\*.txt")
        {
            New-Item "$OUTPUT_FOLDER\sys\net\dns" -ItemType Directory -Force | Out-Null

            # dns.txt
            if (Test-Path "$DriveLetter\sys\net\dns\dns.txt")
            { 
                Copy-Item "$DriveLetter\sys\net\dns\dns.txt" -Destination "$OUTPUT_FOLDER\sys\net\dns\dns.txt"
            }

            # readme.txt
            if (Test-Path "$DriveLetter\sys\net\dns\readme.txt")
            { 
                Copy-Item "$DriveLetter\sys\net\dns\readme.txt" -Destination "$OUTPUT_FOLDER\sys\net\dns\readme.txt"
            }
        }

        # FS_SysInfo_Process
        # https://github.com/ufrisk/MemProcFS/wiki/FS_SysInfo_Process
        if (Test-Path "$DriveLetter\sys\proc\*.txt")
        {
            New-Item "$OUTPUT_FOLDER\sys\proc\TXT" -ItemType Directory -Force | Out-Null
            Add-Content -Path "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" -Encoding utf8 -Value (Get-Content -Path "$DriveLetter\sys\proc\proc.txt")
            Add-Content -Path "$OUTPUT_FOLDER\sys\proc\TXT\proc-v.txt" -Encoding utf8 -Value (Get-Content -Path "$DriveLetter\sys\proc\proc-v.txt")

            # Count Processes
            $Count = (Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Measure-Object).Count -2
            Write-Output "[Info]  Processing $Count Processes ..."

            # Flags
            # 32 - Process is 32-bit on 64-bit Windows.
            # E  - Process is NOT found in EPROCESS list (memory corruption, drift or unlink)
            # T  - Process is terminated
            # U  - Process is user-account (non-system user)
            # *  - Process is outside standard paths.

            # CSV
            if (Test-Path "$DriveLetter\forensic\json\general.json")
            {
                New-Item "$OUTPUT_FOLDER\sys\proc\CSV" -ItemType Directory -Force | Out-Null

                $Data = Get-Content "$DriveLetter\forensic\json\general.json" | ConvertFrom-Json | Where-Object { $_.type -eq "process" }

                $Data | Foreach-Object {

                $proc = $_ | Select-Object -ExpandProperty proc

                # Replace empty "Process Name" fields
                if ($proc -eq "")
                {
                    $proc = "<unknown>"        
                }

                $procid = $_ | Select-Object -ExpandProperty pid
                $obj = $_ | Select-Object -ExpandProperty obj
                $parentid = $_ | Select-Object -ExpandProperty num -ErrorAction SilentlyContinue
                $parentproc = $Data | Where-Object { $_.pid -eq "$parentid" } | Select-Object -ExpandProperty proc
                $hex = $_ | Select-Object -ExpandProperty hex -ErrorAction SilentlyContinue
                $hex2 = $_ | Select-Object -ExpandProperty hex2 -ErrorAction SilentlyContinue
                $desc = $_ | Select-Object -ExpandProperty desc
                $flags = $_ | Select-Object -ExpandProperty desc2 | Select-Object @{Name="flags"; Expression={ForEach-Object{($_ -split "flags:")[1]} | ForEach-Object{($_ -split "user:")[0]} | ForEach-Object{($_ -replace "[\[\]]","")}}}
                $user = $_ | Select-Object -ExpandProperty desc2 | Select-Object @{Name="user"; Expression={ForEach-Object{($_ -split "user:")[1]} | ForEach-Object{($_ -split "upath:")[0]} | ForEach-Object{($_ -replace "[\[\]]","")}}}
                $upath = $_ | Select-Object -ExpandProperty desc2 | Select-Object @{Name="upath"; Expression={ForEach-Object{($_ -split "upath:")[1]} | ForEach-Object{($_ -split "cmd:")[0]} | ForEach-Object{($_ -replace "[\[\]]","")}}}
                $cmd = $_ | Select-Object -ExpandProperty desc2 | Select-Object @{Name="cmd"; Expression={ForEach-Object{($_ -split "cmd:")[1]} | ForEach-Object{($_ -split "createtime:")[0]} | ForEach-Object{($_ -replace "[\[\]]","")}}}
                $createtime = $_ | Select-Object -ExpandProperty desc2 | Select-Object @{Name="createtime"; Expression={ForEach-Object{($_ -split "createtime:")[1]} | ForEach-Object{($_ -split "integrity:")[0]} | ForEach-Object{($_ -split "exittime:")[0]} | ForEach-Object{($_ -replace "[\[\]]","")}}}
                $exittime = $_ | Select-Object -ExpandProperty desc2 | Select-Object @{Name="exittime"; Expression={ForEach-Object{($_ -split "exittime:")[1]} | ForEach-Object{($_ -split "integrity:")[0]} | ForEach-Object{($_ -replace "[\[\]]","")}}}
                $integrity = $_ | Select-Object -ExpandProperty desc2 | Select-Object @{Name="integrity"; Expression={ForEach-Object{($_ -split "integrity:")[1]} | ForEach-Object{($_ -replace "[\[\]]","")}}}
                $SubProcesses = ($Data | Where-Object { $_.num -eq $procid } | Measure-Object).Count

                New-Object -TypeName PSObject -Property @{
                    "Create Time" = $createtime.createtime
	                "Process Name" = $proc
	                "PID" = $procid
	                "obj " = $obj
                    "Parent Name" = $parentproc
	                "PPID" = $parentid
                    "hex" = $hex
                    "hex2" = $hex2
                    "Device Path" = $desc
                    "Flags" = $flags.flags
                    "User" = $user.user
                    "File Path" = $upath.upath
                    "CommandLine" = $cmd.cmd
                    "Integrity" = $integrity.integrity
                    "Exit Time" = $exittime.exittime
                    "Sub-Processes" = $SubProcesses
                    }
                } | Select-Object "Create Time","Process Name","PID","Parent Name","PPID","Sub-Processes","Device Path","Flags","User","File Path","CommandLine","Integrity","Exit Time" | Export-Csv -Path "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv" -Delimiter "`t" -NoTypeInformation
            }

            # XLSX

            # Default
            if (Get-Module -ListAvailable -Name ImportExcel)
            {
                if (Test-Path "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv")
                {
                    if([int](& $xsv count -d "`t" "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv") -gt 0)
                    {
                        New-Item "$OUTPUT_FOLDER\sys\proc\XLSX" -ItemType Directory -Force | Out-Null
                        $IMPORT = Import-Csv "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv" -Delimiter "`t" | Sort-Object { $_."Create Time" -as [datetime] } -Descending
                        $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\XLSX\Processes.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Processes" -CellStyleSB {
                        param($WorkSheet)
                        # BackgroundColor and FontColor for specific cells of TopRow
                        $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                        Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                        # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                        $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                        $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                        $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                        }
                    }
                }
            }
            
            # Process Tree (TreeView)
            if (Test-Path "$SCRIPT_DIR\Scripts\Get-ProcessTree\Get-ProcessTree.ps1")
            {
                if (Test-Path "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv")
                {
                    if([int](& $xsv count -d "`t" "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv") -gt 0)
                    {
                        Write-Output "[Info]  Launching Process Tree (TreeView) ... "
                        Unblock-File -Path "$SCRIPT_DIR\Scripts\Get-ProcessTree\Get-ProcessTree.ps1"
                        Start-Process -FilePath "powershell" -NoNewWindow -ArgumentList "-NoProfile", "-File", "$SCRIPT_DIR\Scripts\Get-ProcessTree\Get-ProcessTree.ps1", "-CSVPath", "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv"
                        Start-Sleep -Seconds 3
                        $Host.UI.RawUI.WindowTitle = "MemProcFS-Analyzer $Version - Automated Forensic Analysis of Windows Memory Dumps for DFIR"
                    }
                }
            }

            # Running and Exited Processes
            if (Get-Module -ListAvailable -Name ImportExcel)
            {
                if (Test-Path "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv")
                {
                    if([int](& $xsv count -d "`t" "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv") -gt 0)
                    {
                        New-Item "$OUTPUT_FOLDER\sys\proc\XLSX" -ItemType Directory -Force | Out-Null
                        $IMPORT = Import-Csv "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv" -Delimiter "`t" | Sort-Object { $_."Create Time" -as [datetime] }
                        $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\XLSX\RunningAndExited.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Processes" -CellStyleSB {
                        param($WorkSheet)
                        # BackgroundColor and FontColor for specific cells of TopRow
                        $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                        Set-Format -Address $WorkSheet.Cells["A1:L1"] -BackgroundColor $BackgroundColor -FontColor White
                        # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                        $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                        $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                        $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"

                        # Exited Processes
                        $ExitedColor = [System.Drawing.Color]::FromArgb(255,0,0) # Red
                        Add-ConditionalFormatting -Address $WorkSheet.Dimension.Address -WorkSheet $WorkSheet -RuleType 'Expression' '=NOT(OR($M1="", $M1="Exit Time"))' -BackgroundColor $ExitedColor

                        # Running Processes
                        $RunningColor = [System.Drawing.Color]::FromArgb(0,176,80) # Green
                        Add-ConditionalFormatting -Address $WorkSheet.Dimension.Address -WorkSheet $WorkSheet -RuleType 'Expression' '=($M1="")' -BackgroundColor $RunningColor
                        }
                    }
                }
            }

            # Unusual Parent-Child Relationships

            # 01. Unusual Parent-Child Relationship (csrss.exe)
            $Pid_smss = (Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "smss.exe" | ForEach-Object{($_ -split "\s+")[2]}) -join "|"
            $Pid_svchost = (Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "svchost.exe" | ForEach-Object{($_ -split "\s+")[2]}) -join "|"
            $Count = (Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "csrss.exe" | Where-Object{($_ -notmatch "$Pid_smss|$Pid_svchost")} | Measure-Object).Count
            if ($Count -gt 0)
            {
                Write-Host "[Alert] Unusual Parent-Child Relationship found: csrss.exe ($Count)" -ForegroundColor Red
                New-Item "$OUTPUT_FOLDER\sys\proc\Unusual_Parent-Child_Relationships" -ItemType Directory -Force | Out-Null
                Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "csrss.exe" | Where-Object{($_ -notmatch "$Pid_smss|$Pid_svchost")} | Out-File "$OUTPUT_FOLDER\sys\proc\Unusual_Parent-Child_Relationships\csrss.exe.txt"
            }

            # 02. Unusual Parent-Child Relationship (LogonUI.exe)
            $Pid_wininit = Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "wininit.exe" | ForEach-Object{($_ -split "\s+")[2]}
            $Pid_winlogon = Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "winlogon.exe" | ForEach-Object{($_ -split "\s+")[2]}
            $Count = (Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "LogonUI.exe" | Where-Object{($_ -notmatch "$Pid_wininit|$Pid_winlogon")} | Measure-Object).Count
            if ($Count -gt 0)
            {
                Write-Host "[Alert] Unusual Parent-Child Relationship found: LogonUI.exe ($Count)" -ForegroundColor Red
                New-Item "$OUTPUT_FOLDER\sys\proc\Unusual_Parent-Child_Relationships" -ItemType Directory -Force | Out-Null
                Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "LogonUI.exe" | Where-Object{($_ -notmatch "$Pid_wininit|$Pid_winlogon")} | Out-File "$OUTPUT_FOLDER\sys\proc\Unusual_Parent-Child_Relationships\LogonUI.exe.txt"
            }

            # 03. Unusual Parent-Child Relationship (lsass.exe)
            $Pid_wininit = Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "wininit.exe" | ForEach-Object{($_ -split "\s+")[2]}
            $Count = (Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "lsass.exe" | Where-Object{($_ -notmatch $Pid_wininit)} | Measure-Object).Count
            if ($Count -gt 0)
            {
                Write-Host "[Alert] Unusual Parent-Child Relationship found: lsass.exe ($Count)" -ForegroundColor Red
                New-Item "$OUTPUT_FOLDER\sys\proc\Unusual_Parent-Child_Relationships" -ItemType Directory -Force | Out-Null
                Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "lsass.exe" | Where-Object{($_ -notmatch "$Pid_wininit")} | Out-File "$OUTPUT_FOLDER\sys\proc\Unusual_Parent-Child_Relationships\lsass.exe.txt"
            }

            # 04. Unusual Parent-Child Relationship (services.exe)
            $Pid_wininit = Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "wininit.exe" | ForEach-Object{($_ -split "\s+")[2]}
            $Count = (Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "services.exe" | Where-Object{($_ -notmatch $Pid_wininit)} | Measure-Object).Count
            if ($Count -gt 0)
            {
                Write-Host "[Alert] Unusual Parent-Child Relationship found: services.exe ($Count)" -ForegroundColor Red
                New-Item "$OUTPUT_FOLDER\sys\proc\Unusual_Parent-Child_Relationships" -ItemType Directory -Force | Out-Null
                Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "services.exe" | Where-Object{($_ -notmatch "$Pid_wininit")} | Out-File "$OUTPUT_FOLDER\sys\proc\Unusual_Parent-Child_Relationships\services.exe.txt"
            }

            # 05. Unusual Parent-Child Relationship (smss.exe)
            $Pid_System = Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "System " -CaseSensitive | ForEach-Object{($_ -split "\s+")[2]}
            $Pid_smss = (Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "smss.exe" | ForEach-Object{($_ -split "\s+")[2]}) -join "|"
            $Count = (Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "smss.exe" | Where-Object{($_ -notmatch "$Pid_System|$Pid_smss")} | Measure-Object).Count
            if ($Count -gt 0)
            {
                Write-Host "[Alert] Unusual Parent-Child Relationship found: smss.exe ($Count)" -ForegroundColor Red
                New-Item "$OUTPUT_FOLDER\sys\proc\Unusual_Parent-Child_Relationships" -ItemType Directory -Force | Out-Null
                Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "smss.exe" | Where-Object{($_ -notmatch "$Pid_System|$Pid_smss")} | Out-File "$OUTPUT_FOLDER\sys\proc\Unusual_Parent-Child_Relationships\smss.exe.txt"
            }

            # 06. Unusual Parent-Child Relationship (spoolsv.exe)
            $Pid_services = Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "services.exe" | ForEach-Object{($_ -split "\s+")[2]}
            $Count = (Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "spoolsv.exe" | Where-Object{($_ -notmatch $Pid_services)} | Measure-Object).Count
            if ($Count -gt 0)
            {
                Write-Host "[Alert] Unusual Parent-Child Relationship found: spoolsv.exe ($Count)" -ForegroundColor Red
                New-Item "$OUTPUT_FOLDER\sys\proc\Unusual_Parent-Child_Relationships" -ItemType Directory -Force | Out-Null
                Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "spoolsv.exe" | Where-Object{($_ -notmatch "$Pid_services")} | Out-File "$OUTPUT_FOLDER\sys\proc\Unusual_Parent-Child_Relationships\spoolsv.exe.txt"
            }

            # 07. Unusual Parent-Child Relationship (svchost.exe)
            $Pid_services = Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "services.exe" | ForEach-Object{($_ -split "\s+")[2]}
            $Pid_MsMpEng = Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "MsMpEng.exe" | ForEach-Object{($_ -split "\s+")[2]}
            $Count = (Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "svchost.exe" | Where-Object{($_ -notmatch "$Pid_services|$Pid_MsMpEng")} | Measure-Object).Count
            if ($Count -gt 0)
            {
                Write-Host "[Alert] Unusual Parent-Child Relationship found: svchost.exe ($Count)" -ForegroundColor Red
                New-Item "$OUTPUT_FOLDER\sys\proc\Unusual_Parent-Child_Relationships" -ItemType Directory -Force | Out-Null
                Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "svchost.exe" | Where-Object{($_ -notmatch "$Pid_services|$Pid_MsMpEng")} | Out-File "$OUTPUT_FOLDER\sys\proc\Unusual_Parent-Child_Relationships\svchost.exe.txt"
            }

            # 08. Unusual Parent-Child Relationship (taskhost.exe)
            $Pid_services = Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "services.exe" | ForEach-Object{($_ -split "\s+")[2]}
            $Pid_svchost = (Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "svchost.exe" | ForEach-Object{($_ -split "\s+")[2]}) -join "|"
            $Count = (Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "taskhost.exe" | Where-Object{($_ -notmatch "$Pid_services|$Pid_svchost")} | Measure-Object).Count
            if ($Count -gt 0)
            {
                Write-Host "[Alert] Unusual Parent-Child Relationship found: taskhost.exe ($Count)" -ForegroundColor Red
                New-Item "$OUTPUT_FOLDER\sys\proc\Unusual_Parent-Child_Relationships" -ItemType Directory -Force | Out-Null
                Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "taskhost.exe" | Where-Object{($_ -notmatch "$Pid_services|$Pid_svchost")} | Out-File "$OUTPUT_FOLDER\sys\proc\Unusual_Parent-Child_Relationships\taskhost.exe.txt"
            }

            # 09. Unusual Parent-Child Relationship (taskhostw.exe)
            $Pid_services = Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "services.exe" | ForEach-Object{($_ -split "\s+")[2]}
            $Pid_svchost = (Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "svchost.exe" | ForEach-Object{($_ -split "\s+")[2]}) -join "|"
            $Count = (Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "taskhostw.exe" | Where-Object{($_ -notmatch "$Pid_services|$Pid_svchost")} | Measure-Object).Count
            if ($Count -gt 0)
            {
                Write-Host "[Alert] Unusual Parent-Child Relationship found: taskhostw.exe ($Count)" -ForegroundColor Red
                New-Item "$OUTPUT_FOLDER\sys\proc\Unusual_Parent-Child_Relationships" -ItemType Directory -Force | Out-Null
                Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "taskhostw.exe" | Where-Object{($_ -notmatch "$Pid_services|$Pid_svchost")} | Out-File "$OUTPUT_FOLDER\sys\proc\Unusual_Parent-Child_Relationships\taskhostw.exe.txt"
            }

            # 10. Unusual Parent-Child Relationship (userinit.exe)
            $Pid_dwm = Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "dwm.exe" | ForEach-Object{($_ -split "\s+")[2]}
            $Pid_winlogon = Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "winlogon.exe" | ForEach-Object{($_ -split "\s+")[2]}
            $Count = (Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "userinit.exe" | Where-Object{($_ -notmatch "$Pid_dwm|$Pid_winlogon")} | Measure-Object).Count
            if ($Count -gt 0)
            {
                Write-Host "[Alert] Unusual Parent-Child Relationship found: userinit.exe ($Count)" -ForegroundColor Red
                New-Item "$OUTPUT_FOLDER\sys\proc\Unusual_Parent-Child_Relationships" -ItemType Directory -Force | Out-Null
                Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "userinit.exe" | Where-Object{($_ -notmatch "$Pid_dwm|$Pid_winlogon")} | Out-File "$OUTPUT_FOLDER\sys\proc\Unusual_Parent-Child_Relationships\userinit.exe.txt"
            }

            # 11. Unusual Parent-Child Relationship (wininit.exe)
            $Pid_smss = (Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "smss.exe" | ForEach-Object{($_ -split "\s+")[2]}) -join "|"
            $Count = (Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "wininit.exe" | Where-Object{($_ -notmatch $Pid_smss)} | Measure-Object).Count
            if ($Count -gt 0)
            {
                Write-Host "[Alert] Unusual Parent-Child Relationship found: wininit.exe ($Count)" -ForegroundColor Red
                New-Item "$OUTPUT_FOLDER\sys\proc\Unusual_Parent-Child_Relationships" -ItemType Directory -Force | Out-Null
                Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "wininit.exe" | Where-Object{($_ -notmatch "$Pid_smss")} | Out-File "$OUTPUT_FOLDER\sys\proc\Unusual_Parent-Child_Relationships\wininit.exe.txt"
            }

            # 12. Unusual Parent-Child Relationship (winlogon.exe)
            $Pid_smss = (Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "smss.exe" | ForEach-Object{($_ -split "\s+")[2]}) -join "|"
            $Count = (Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "winlogon.exe" | Where-Object{($_ -notmatch $Pid_smss)} | Measure-Object).Count
            if ($Count -gt 0)
            {
                Write-Host "[Alert] Unusual Parent-Child Relationship found: winlogon.exe ($Count)" -ForegroundColor Red
                New-Item "$OUTPUT_FOLDER\sys\proc\Unusual_Parent-Child_Relationships" -ItemType Directory -Force | Out-Null
                Get-Content "$OUTPUT_FOLDER\sys\proc\TXT\proc.txt" | Select-String -Pattern "winlogon.exe" | Where-Object{($_ -notmatch "$Pid_smss")} | Out-File "$OUTPUT_FOLDER\sys\proc\Unusual_Parent-Child_Relationships\winlogon.exe.txt"
            }

            # Unusual Number of Process Instances
            if (Test-Path "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv")
            {
                if([int](& $xsv count -d "`t" "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv") -gt 0)
                {
                    $RunningProcs = Import-Csv "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv" -Delimiter "`t" | Where-Object { $_."Exit Time" -eq "" }

                    # Unusual Number of Process Instances (lsaiso.exe)
                    $Count = ($RunningProcs | Where-Object { $_."Process Name" -eq "lsaiso.exe" } | Measure-Object).Count
                    if ($Count -ne 0 -and $Count -ne 1)
                    {
                        Write-Host "[Alert] Unusual Number of Process Instances found: lsaiso.exe ($Count)" -ForegroundColor Red
                        New-Item "$OUTPUT_FOLDER\sys\proc\Unusual_Number-of-Process-Instances" -ItemType Directory -Force | Out-Null
                        $RunningProcs | Where-Object { $_."Process Name" -eq "lsaiso.exe" } | Out-File "$OUTPUT_FOLDER\sys\proc\Unusual_Number-of-Process-Instances\lsaiso.exe.txt"
                    }

                    # Unusual Number of Process Instances (lsass.exe)
                    $Count = ($RunningProcs | Where-Object { $_."Process Name" -eq "lsass.exe" } | Measure-Object).Count
                    if ($Count -ne 1)
                    {
                        Write-Host "[Alert] Unusual Number of Process Instances found: lsass.exe ($Count)" -ForegroundColor Red
                        New-Item "$OUTPUT_FOLDER\sys\proc\Unusual_Number-of-Process-Instances" -ItemType Directory -Force | Out-Null
                        $RunningProcs | Where-Object { $_."Process Name" -eq "lsass.exe" } | Out-File "$OUTPUT_FOLDER\sys\proc\Unusual_Number-of-Process-Instances\lsass.exe.txt"
                    }

                    # Unusual Number Process of Instances (lsm.exe)
                    $Count = ($RunningProcs | Where-Object { $_."Process Name" -eq "lsm.exe" } | Measure-Object).Count
                    if ($Count -ne 0 -and $Count -ne 1)
                    {
                        Write-Host "[Alert] Unusual Number of Process Instances found: lsm.exe ($Count)" -ForegroundColor Red
                        New-Item "$OUTPUT_FOLDER\sys\proc\Unusual_Number-of-Process-Instances" -ItemType Directory -Force | Out-Null
                        $RunningProcs | Where-Object { $_."Process Name" -eq "lsm.exe" } | Out-File "$OUTPUT_FOLDER\sys\proc\Unusual_Number-of-Process-Instances\lsm.exe.txt"
                    }

                    # Unusual Number Process of Instances (Memory Compression)
                    $Count = ($RunningProcs | Where-Object { $_."Process Name" -eq "MemCompression" } | Measure-Object).Count
                    if ($Count -ne 0 -and $Count -ne 1)
                    {
                        Write-Host "[Alert] Unusual Number of Process Instances found: MemCompression ($Count)" -ForegroundColor Red
                        New-Item "$OUTPUT_FOLDER\sys\proc\Unusual_Number-of-Process-Instances" -ItemType Directory -Force | Out-Null
                        $RunningProcs | Where-Object { $_."Process Name" -eq "MemCompression" } | Out-File "$OUTPUT_FOLDER\sys\proc\Unusual_Number-of-Process-Instances\MemCompression.txt"
                    }

                    # Unusual Number Process of Instances (Registry)
                    $Count = ($RunningProcs | Where-Object { $_."Process Name" -eq "Registry" } | Measure-Object).Count
                    if ($Count -ne 0 -and $Count -ne 1)
                    {
                        Write-Host "[Alert] Unusual Number of Process Instances found: Registry ($Count)" -ForegroundColor Red
                        New-Item "$OUTPUT_FOLDER\sys\proc\Unusual_Number-of-Process-Instances" -ItemType Directory -Force | Out-Null
                        $RunningProcs | Where-Object { $_."Process Name" -eq "Registry" } | Out-File "$OUTPUT_FOLDER\sys\proc\Unusual_Number-of-Process-Instances\Registry.txt"
                    }

                    # Unusual Number of Process Instances (services.exe)
                    $Count = ($RunningProcs | Where-Object { $_."Process Name" -eq "services.exe" } | Measure-Object).Count
                    if ($Count -ne 1)
                    {
                        Write-Host "[Alert] Unusual Number of Process Instances found: services.exe ($Count)" -ForegroundColor Red
                        New-Item "$OUTPUT_FOLDER\sys\proc\Unusual_Number-of-Process-Instances" -ItemType Directory -Force | Out-Null
                        $RunningProcs | Where-Object { $_."Process Name" -eq "services.exe" } | Out-File "$OUTPUT_FOLDER\sys\proc\Unusual_Number-of-Process-Instances\services.exe.txt"
                    }

                    # Unusual Number of Process Instances (System)
                    $Count = ($RunningProcs | Where-Object { $_."Process Name" -eq "System" } | Measure-Object).Count
                    if ($Count -ne 1)
                    {
                        Write-Host "[Alert] Unusual Number of Process Instances found: System ($Count)" -ForegroundColor Red
                        New-Item "$OUTPUT_FOLDER\sys\proc\Unusual_Number-of-Process-Instances" -ItemType Directory -Force | Out-Null
                        $RunningProcs | Where-Object { $_."Process Name" -eq "System" } | Out-File "$OUTPUT_FOLDER\sys\proc\Unusual_Number-of-Process-Instances\System.txt"
                    }

                    # Unusual Number of Process Instances (wininit.exe)
                    $Count = ($RunningProcs | Where-Object { $_."Process Name" -eq "wininit.exe" } | Measure-Object).Count
                    if ($Count -ne 1)
                    {
                        Write-Host "[Alert] Unusual Number of Process Instances found: wininit.exe ($Count)" -ForegroundColor Red
                        New-Item "$OUTPUT_FOLDER\sys\proc\Unusual_Number-of-Process-Instances" -ItemType Directory -Force | Out-Null
                        $RunningProcs | Where-Object { $_."Process Name" -eq "wininit.exe" } | Out-File "$OUTPUT_FOLDER\sys\proc\Unusual_Number-of-Process-Instances\wininit.exe.txt"
                    }
                }
            }
        }

        # Process Masquerading
        # https://attack.mitre.org/techniques/T1036/
        # https://car.mitre.org/analytics/CAR-2021-04-001/
        if (Test-Path "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv")
        {
            if([int](& $xsv count -d "`t" "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv") -gt 0)
            {
                # Process Path Masquerading - Looks for mismatches between process names and their image paths
                # https://attack.mitre.org/techniques/T1036/005/
                Write-Output "[Info]  Checking for Process Path Masquerading ..."

                # Masquerading Client/Server Runtime Subsystem (csrss.exe)
                $Import = Import-Csv "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv" -Delimiter "`t" | Where-Object { $_."Process Name" -eq "csrss.exe" -and $_."Device Path" -notmatch "\\Windows\\System32\\csrss\.exe" }
                $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Process Masquerading as Client/Server Runtime Subsystem (csrss.exe) detected (Count: $Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Process-Masquerading" -ItemType Directory -Force | Out-Null
                    $Import | Out-File "$OUTPUT_FOLDER\sys\proc\Process-Masquerading\csrss.exe.txt"
                }

                # Masquerading Windows Explorer (explorer.exe)
                $Import = Import-Csv "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv" -Delimiter "`t" | Where-Object { $_."Process Name" -eq "explorer.exe" -and $_."Device Path" -notmatch "\\Windows\\explorer\.exe" }
                $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Process Masquerading as Windows Explorer (explorer.exe) detected (Count: $Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Process-Masquerading" -ItemType Directory -Force | Out-Null
                    $Import | Out-File "$OUTPUT_FOLDER\sys\proc\Process-Masquerading\explorer.exe.txt"
                }

                # Masquerading Local Security Authority Server Service (lsass.exe)
                $Import = Import-Csv "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv" -Delimiter "`t" | Where-Object { $_."Process Name" -eq "lsass.exe" -and $_."Device Path" -notmatch "\\Windows\\System32\\lsass\.exe" }
                $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Process Masquerading as Local Security Authority Server Service (lsass.exe) detected (Count: $Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Process-Masquerading" -ItemType Directory -Force | Out-Null
                    $Import | Out-File "$OUTPUT_FOLDER\sys\proc\Process-Masquerading\lsass.exe.txt"
                }

                # Masquerading Local Session Manager Service (lsm.exe)
                $Import = Import-Csv "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv" -Delimiter "`t" | Where-Object { $_."Process Name" -eq "lsm.exe" -and $_."Device Path" -notmatch "\\Windows\\System32\\lsm\.exe" }
                $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Process Masquerading as Local Session Manager Service (lsm.exe) detected (Count: $Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Process-Masquerading" -ItemType Directory -Force | Out-Null
                    $Import | Out-File "$OUTPUT_FOLDER\sys\proc\Process-Masquerading\lsm.exe.txt"
                }

                # Masquerading Windows Services Control Manager (services.exe)
                $Import = Import-Csv "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv" -Delimiter "`t" | Where-Object { $_."Process Name" -eq "services.exe" -and $_."Device Path" -notmatch "\\Windows\\System32\\services\.exe" }
                $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Process Masquerading as Windows Services Control Manager (services.exe) detected (Count: $Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Process-Masquerading" -ItemType Directory -Force | Out-Null
                    $Import | Out-File "$OUTPUT_FOLDER\sys\proc\Process-Masquerading\services.exe.txt"
                }

                # Masquerading Windows Session Manager Subsystem (smss.exe)
                $Import = Import-Csv "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv" -Delimiter "`t" | Where-Object { $_."Process Name" -eq "smss.exe" -and $_."Device Path" -notmatch "\\Windows\\System32\\smss\.exe" }
                $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Process Masquerading as Windows Session Manager Subsystem (smss.exe) detected (Count: $Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Process-Masquerading" -ItemType Directory -Force | Out-Null
                    $Import | Out-File "$OUTPUT_FOLDER\sys\proc\Process-Masquerading\smss.exe.txt"
                }

                # Masquerading Windows Service Host (svchost.exe)
                $Import = Import-Csv "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv" -Delimiter "`t" | Where-Object { $_."Process Name" -eq "svchost.exe" -and ($_."Device Path" -notmatch "\\Windows\\System32\\svchost\.exe" -and $_."Device Path" -notmatch "\\Windows\\SysWOW64\\svchost\.exe") }
                $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Process Masquerading as Windows Service Host (svchost.exe) detected (Count: $Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Process-Masquerading" -ItemType Directory -Force | Out-Null
                    $Import | Out-File "$OUTPUT_FOLDER\sys\proc\Process-Masquerading\svchost.exe.txt"
                }

                # Masquerading Host Process for Windows Tasks (taskhost.exe)
                $Import = Import-Csv "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv" -Delimiter "`t" | Where-Object { $_."Process Name" -eq "taskhost.exe" -and $_."Device Path" -notmatch "\\Windows\\System32\\taskhost\.exe" }
                $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Process Masquerading as Host Process for Windows Tasks (taskhost.exe) detected (Count: $Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Process-Masquerading" -ItemType Directory -Force | Out-Null
                    $Import | Out-File "$OUTPUT_FOLDER\sys\proc\Process-Masquerading\taskhost.exe.txt"
                }

                # Masquerading Host Process for Windows Tasks (taskhostw.exe)
                $Import = Import-Csv "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv" -Delimiter "`t" | Where-Object { $_."Process Name" -eq "taskhostw.exe" -and $_."Device Path" -notmatch "\\Windows\\System32\\taskhostw\.exe" }
                $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Process Masquerading as Host Process for Windows Tasks (taskhostw.exe) detected (Count: $Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Process-Masquerading" -ItemType Directory -Force | Out-Null
                    $Import | Out-File "$OUTPUT_FOLDER\sys\proc\Process-Masquerading\taskhostw.exe.txt"
                }

                # Masquerading Windows Start-Up Application (wininit.exe)
                $Import = Import-Csv "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv" -Delimiter "`t" | Where-Object { $_."Process Name" -eq "wininit.exe" -and $_."Device Path" -notmatch "\\Windows\\System32\\wininit\.exe" }
                $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Process Masquerading as Windows Start-Up Application (wininit.exe) detected (Count: $Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Process-Masquerading" -ItemType Directory -Force | Out-Null
                    $Import | Out-File "$OUTPUT_FOLDER\sys\proc\Process-Masquerading\wininit.exe.txt"
                }

                # Masquerading Windows Logon (winlogon.exe)
                $Import = Import-Csv "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv" -Delimiter "`t" | Where-Object { $_."Process Name" -eq "winlogon.exe" -and $_."Device Path" -notmatch "\\Windows\\System32\\winlogon\.exe" }
                $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Process Masquerading as Windows Logon (winlogon.exe) detected (Count: $Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Process-Masquerading" -ItemType Directory -Force | Out-Null
                    $Import | Out-File "$OUTPUT_FOLDER\sys\proc\Process-Masquerading\winlogon.exe.txt"
                }

                # Process Name Masquerading - Measures the edit distance between used Process Name and Original Windows Process Name (Damerau–Levenshtein Distance)
                # https://en.wikipedia.org/wiki/Damerau-Levenshtein_distance
                Write-Output "[Info]  Checking Damerau–Levenshtein Distance of common System Processes ..."
                
                if (Test-Path "$SCRIPT_DIR\Scripts\Measure-DamerauLevenshteinDistance\Measure-DamerauLevenshteinDistance.cs")
                {
                    Add-Type -Path "$SCRIPT_DIR\Scripts\Measure-DamerauLevenshteinDistance\Measure-DamerauLevenshteinDistance.cs" | Out-Null

                    $ProcessList = (Import-Csv "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv" -Delimiter "`t" | Where-Object { $_."Process Name" -ne "" } | Select-Object PID | Sort-Object @{Expression={$_.PID -as [int]}}).PID

                    ForEach( $ProcessID in $ProcessList )
                    {
                        $ProcessName = (Import-Csv "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv" -Delimiter "`t" | Where-Object { $_."PID" -eq "$ProcessID" } | Select-Object "Process Name")."Process Name"

                        # Masquerading Client/Server Runtime Subsystem (csrss.exe)
                        [int]$Distance = [LevenshteinDistance]::Measure("csrss.exe", "$ProcessName")

                        if ($Distance -eq "1")
                        {
                            Write-Host "[Alert] Process Name Masquerading detected: csrss.exe (Process Name: $ProcessName PID: $ProcessId)" -ForegroundColor Red
                        }

                        # Masquerading COM Surrogate (dllhost.exe) --> Microsoft Component Object Model (COM)
                        [int]$Distance = [LevenshteinDistance]::Measure("dllhost.exe", "$ProcessName")

                        if ($Distance -eq "1")
                        {
                            Write-Host "[Alert] Process Name Masquerading detected: dllhost.exe (Process Name: $ProcessName PID: $ProcessId)" -ForegroundColor Red
                        }

                        # Masquerading Windows Explorer (explorer.exe)
                        [int]$Distance = [LevenshteinDistance]::Measure("explorer.exe", "$ProcessName")

                        if ($Distance -eq "1")
                        {
                            Write-Host "[Alert] Process Name Masquerading detected: explorer.exe (Process Name: $ProcessName PID: $ProcessId)" -ForegroundColor Red
                        }

                        # Masquerading Internet Explorer (iexplore.exe)
                        [int]$Distance = [LevenshteinDistance]::Measure("iexplore.exe", "$ProcessName")

                        if ($Distance -eq "1")
                        {
                            Write-Host "[Alert] Process Name Masquerading detected: iexplore.exe (Process Name: $ProcessName PID: $ProcessId)" -ForegroundColor Red
                        }

                        # Masquerading Local Security Authority Server Service (lsass.exe)
                        [int]$Distance = [LevenshteinDistance]::Measure("lsass.exe", "$ProcessName")

                        if ($Distance -eq "1")
                        {
                            Write-Host "[Alert] Process Name Masquerading detected: lsass.exe (Process Name: $ProcessName PID: $ProcessId)" -ForegroundColor Red
                        }

                        # Masquerading Shell Infrastructure Host (sihost.exe)
                        [int]$Distance = [LevenshteinDistance]::Measure("sihost.exe", "$ProcessName")

                        if ($Distance -eq "1")
                        {
                            Write-Host "[Alert] Process Name Masquerading detected: sihost.exe (Process Name: $ProcessName PID: $ProcessId)" -ForegroundColor Red
                        }

                        # Masquerading Windows Session Manager Subsystem (smss.exe)
                        [int]$Distance = [LevenshteinDistance]::Measure("smss.exe", "$ProcessName")

                        if ($Distance -eq "1")
                        {
                            Write-Host "[Alert] Process Name Masquerading detected: smss.exe (Process Name: $ProcessName PID: $ProcessId)" -ForegroundColor Red
                        }

                        # Masquerading Windows Service Host (svchost.exe)
                        [int]$Distance = [LevenshteinDistance]::Measure("svchost.exe", "$ProcessName")

                        if ($Distance -eq "1")
                        {
                            Write-Host "[Alert] Process Name Masquerading detected: svchost.exe (Process Name: $ProcessName PID: $ProcessId)" -ForegroundColor Red
                        }

                        # Masquerading Windows Logon (winlogon.exe)
                        [int]$Distance = [LevenshteinDistance]::Measure("winlogon.exe", "$ProcessName")

                        if ($Distance -eq "1")
                        {
                            Write-Host "[Alert] Process Name Masquerading detected: winlogon.exe (Process Name: $ProcessName PID: $ProcessId)" -ForegroundColor Red
                        }
                    }
                }
                else
                {
                    Write-Host "[Error] Measure-DamerauLevenshteinDistance.cs NOT found." -ForegroundColor Red
                }
            }
        }

#############################################################################################################################################################################################
        
        Function Get-ProcessesWithUnusualUserContext {

        # Processes w/ Unusual User Context
        if (Test-Path "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv")
        {
            if([int](& $xsv count -d "`t" "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv") -gt 0)
            {
                Write-Output "[Info]  Checking for Processes w/ Unusual User Context ..."

                # Windows Service Host (svchost.exe)
                $Import = Import-Csv "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv" -Delimiter "`t" | Where-Object { $_."Process Name" -eq "svchost.exe" } | Where-Object { $_.User -notmatch "SYSTEM|LOCAL SERVICE|NETWORK SERVICE" }
                $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Suspicious Windows Service Host (svchost.exe) detected: Running under unusual user context (Count: $Count)" -ForegroundColor Yellow
                    New-Item "$OUTPUT_FOLDER\sys\proc\Unusual_User-Context" -ItemType Directory -Force | Out-Null
                    $Import | Out-File "$OUTPUT_FOLDER\sys\proc\Unusual_User-Context\svchost.exe.txt"
                }

                # svchost.exe is supposed to run in Session 0 under one of 3 users: SYSTEM, LOCAL SERVICE or NETWORK SERVICE.
                # If svchost.exe is ran by SYSTEM, NETWORK SERVICE or LOCAL SERVICE, then it should be legitmate, but if it is ran under an user account, 
                # then you need to investigate if the svchost.exe file is from another location than "C:\Windows\System32".
            }
        }

        }

        Get-ProcessesWithUnusualUserContext

#############################################################################################################################################################################################
        
        Function Get-ProcessesFromSuspiciousFolders {

        # Checking for processes spawned from suspicious folder locations
        if (Test-Path "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv")
        {
            if([int](& $xsv count -d "`t" "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv") -gt 0)
            {
                Write-Output "[Info]  Checking for Processes Spawned From Suspicious Folder Locations ..."

                $Import = Import-Csv "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv" -Delimiter "`t" | Where-Object { $_."Device Path" -ne "" } | Sort-Object @{Expression={$_.PID -as [int]}}

                # Desktop (incl. subdirectories) - The onscreen work area provided by Microsoft Windows that represents the kinds of objects one might find on top of a physical desk
                $Data = $Import | Where-Object { $_."Device Path" -match "\\Users\\.*\\Desktop\\" }
                $Count = [string]::Format('{0:N0}',($Data | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Process spawned from a suspicious folder location: C:\Users\*\Desktop\* ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Suspicious-Folder-Locations" -ItemType Directory -Force | Out-Null
                    $Data | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Suspicious-Folder-Locations\Desktop.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Desktop" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["G2:G$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # Downloads (incl. subdirectories) - Default location to save all downloaded content
                $Data = $Import | Where-Object { $_."Device Path" -match "\\Users\\.*\\Downloads\\" }
                $Count = [string]::Format('{0:N0}',($Data | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Process spawned from a suspicious folder location: C:\Users\*\Downloads\* ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Suspicious-Folder-Locations" -ItemType Directory -Force | Out-Null
                    $Data | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Suspicious-Folder-Locations\Downloads.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Downloads" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["G2:G$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # Documents (incl. subdirectories) - Default location for all user created documents
                $Data = $Import | Where-Object { $_."Device Path" -match "\\Users\\.*\\Documents\\" }
                $Count = [string]::Format('{0:N0}',($Data | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Process spawned from a suspicious folder location: C:\Users\*\Documents\* ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Suspicious-Folder-Locations" -ItemType Directory -Force | Out-Null
                    $Data | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Suspicious-Folder-Locations\Documents.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Documents" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["G2:G$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # PUBLIC (incl. subdirectories) - The Public folder is located in "%SystemDrive%\Users\Public", in all Windows versions. All user accounts registered in Windows have access to it. That's why it is named Public. Any file and folder found in "C:\Users\Public" is completely accessible to all users.
                $Data = $Import | Where-Object { $_."Device Path" -match "\\Users\\Public\\" }
                $Count = [string]::Format('{0:N0}',($Data | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Process spawned from a suspicious folder location: C:\Users\Public\* ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Suspicious-Folder-Locations" -ItemType Directory -Force | Out-Null
                    $Data | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Suspicious-Folder-Locations\PUBLIC.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "PUBLIC" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["G2:G$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # Temp (incl. subdirectories) - Temporary Files created by the User (when running any software)
                $Data = $Import | Where-Object { $_."Device Path" -match "\\Users\\.*\\AppData\\Local\\Temp\\" }
                $Count = [string]::Format('{0:N0}',($Data | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Process spawned from a suspicious folder location: C:\Users\*\AppData\Local\Temp\* ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Suspicious-Folder-Locations" -ItemType Directory -Force | Out-Null
                    $Data | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Suspicious-Folder-Locations\TEMP.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "TEMP" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["G2:G$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # Temp - Root Directory (incl. subdirectories)
                $Data = $Import | Where-Object { $_."Device Path" -match "\\Device\\HarddiskVolume[0-9]\\Temp\\" }
                $Count = [string]::Format('{0:N0}',($Data | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Process spawned from a suspicious folder location: C:\Temp\* ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Suspicious-Folder-Locations" -ItemType Directory -Force | Out-Null
                    $Data | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Suspicious-Folder-Locations\Temp-Root.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Temp" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["G2:G$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # ALLUSERSPROFILE (incl. subdirectories)
                $Data = $Import | Where-Object { $_."Device Path" -match "\\Device\\HarddiskVolume[0-9]\\ProgramData\\" } | Where-Object { $_."Device Path" -notmatch "\\Microsoft\\Windows Defender\\Platform\\.*\\[MsMpEng.exe|MpCopyAccelerator.exe]" }
                $Count = [string]::Format('{0:N0}',($Data | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Process spawned from a suspicious folder location: C:\ProgramData\* ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Suspicious-Folder-Locations" -ItemType Directory -Force | Out-Null
                    $Data | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Suspicious-Folder-Locations\ALLUSERSPROFILE.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "ALLUSERSPROFILE" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["G2:G$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # SystemDrive (Root Directory) --> [A-Za-z0-9_]*
                $Data = $Import | Where-Object { $_."Device Path" -match "\\Device\\HarddiskVolume[0-9]\\\w+$" }
                $Count = [string]::Format('{0:N0}',($Data | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Process spawned from a suspicious folder location: C:\* ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Suspicious-Folder-Locations" -ItemType Directory -Force | Out-Null
                    $Data | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Suspicious-Folder-Locations\SystemDrive.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "SystemDrive" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["G2:G$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # LOCALAPPDATA (incl. subdirectories) - Default location of temporary files of applications (Vista+)
                $Data = $Import | Where-Object { $_."Device Path" -match "\\Device\\HarddiskVolume[0-9]\\Users\\*\\AppData\\Local\\" }
                $Count = [string]::Format('{0:N0}',($Data | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Process spawned from a suspicious folder location: C:\Users\*\AppData\Local\* ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Suspicious-Folder-Locations" -ItemType Directory -Force | Out-Null
                    $Data | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Suspicious-Folder-Locations\LOCALAPPDATA.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "LOCALAPPDATA" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["G2:G$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # LocalLow (incl. subdirectories) - like LOCALAPPDATA, but with a lower integrity level
                $Data = $Import | Where-Object { $_."Device Path" -match "\\Device\\HarddiskVolume[0-9]\\Users\\*\\AppData\\LocalLow\\" }
                $Count = [string]::Format('{0:N0}',($Data | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Process spawned from a suspicious folder location: C:\Users\*\AppData\LocalLow\* ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Suspicious-Folder-Locations" -ItemType Directory -Force | Out-Null
                    $Data | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Suspicious-Folder-Locations\LocalLow.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "LocalLow" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["G2:G$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # APPDATA (incl. subdirectories) - Default location for user application data and binaries
                $Data = $Import | Where-Object { $_."Device Path" -match "\\Device\\HarddiskVolume[0-9]\\Users\\*\\AppData\\Roaming\\" }
                $Count = [string]::Format('{0:N0}',($Data | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Process spawned from a suspicious folder location: C:\Users\*\AppData\Roaming\* ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Suspicious-Folder-Locations" -ItemType Directory -Force | Out-Null
                    $Data | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Suspicious-Folder-Locations\APPDATA.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "APPDATA" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["G2:G$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }
            }
        }

        }

        Get-ProcessesFromSuspiciousFolders

#############################################################################################################################################################################################
        
        # Checking for suspicious process lineage
        # https://d3fend.mitre.org/technique/d3f:ProcessLineageAnalysis/

        if (Test-Path "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv")
        {
            if([int](& $xsv count -d "`t" "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv") -gt 0)
            {
                $Import = Import-Csv "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv" -Delimiter "`t" | Sort-Object @{Expression={$_.PID -as [int]}}

                Write-Output "[Info]  Checking for Suspicious Process Lineage ..."

                # Checking for suspicious parent processes

                # System Binary Proxy Execution: rundll32.exe
                # https://attack.mitre.org/techniques/T1218/011/

                # rundll32.exe spawns conhost.exe
                # Note: With the introduction of Windows Terminal in May 2020, conhost.exe can act as an execution proxy. Attackers may abuse this feature to execute malicious files and evade detection.
                $Data = $Import | Where-Object { $_."Process Name" -eq "conhost.exe" } | Where-Object { $_."Parent Name" -eq "rundll32.exe" }
                $Count = [string]::Format('{0:N0}',($Data | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Windows Console Host (conhost.exe) spawned by suspicious parent process: rundll32.exe ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Suspicious-Parent-Processes" -ItemType Directory -Force | Out-Null
                    $Data | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Suspicious-Parent-Processes\rundll32.exe_spawns_conhost.exe.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "conhost.exe" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["D2:D$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # svchost.exe spawns cmd.exe
                $Data = $Import | Where-Object { $_."Process Name" -eq "cmd.exe" } | Where-Object { $_."Parent Name" -eq "svchost.exe" }
                $Count = [string]::Format('{0:N0}',($Data | Measure-Object).Count)
  
                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Windows Command Shell (cmd.exe) spawned by suspicious parent process: svchost.exe ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Suspicious-Parent-Processes" -ItemType Directory -Force | Out-Null
                    $Data | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Suspicious-Parent-Processes\svchost.exe_spawns_cmd.exe.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "cmd.exe" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["D2:D$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # Checking for suspicious child processes

                # WINWORD.EXE spawns cmd.exe
                $Data = $Import | Where-Object { $_."Process Name" -eq "cmd.exe" } | Where-Object { $_."Parent Name" -eq "WINWORD.EXE" }
                $Count = [string]::Format('{0:N0}',($Data | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Suspicious Child Process of Microsoft Word detected: cmd.exe ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Suspicious-Child-Processes" -ItemType Directory -Force | Out-Null
                    $Data | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Suspicious-Child-Processes\winword.exe_spawns_cmd.exe.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "cmd.exe" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["D2:D$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # WINWORD.EXE spawns powershell.exe
                $Data = $Import | Where-Object { $_."Process Name" -eq "powershell.exe" } | Where-Object { $_."Parent Name" -eq "WINWORD.EXE" }
                $Count = [string]::Format('{0:N0}',($Data | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Suspicious Child Process of Microsoft Word detected: powershell.exe ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Suspicious-Child-Processes" -ItemType Directory -Force | Out-Null
                    $Data | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Suspicious-Child-Processes\winword.exe_spawns_powershell.exe.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "powershell.exe" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["D2:D$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # WINWORD.EXE spawns mshta.exe
                $Data = $Import | Where-Object { $_."Process Name" -eq "mshta.exe" } | Where-Object { $_."Parent Name" -eq "WINWORD.EXE" }
                $Count = [string]::Format('{0:N0}',($Data | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Suspicious Child Process of Microsoft Word detected: mshta.exe ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Suspicious-Child-Processes" -ItemType Directory -Force | Out-Null
                    $Data | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Suspicious-Child-Processes\winword.exe_spawns_mshta.exe.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "mshta.exe" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["D2:D$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # WINWORD.EXE spawns regsvr32.exe
                $Data = $Import | Where-Object { $_."Process Name" -eq "regsvr32.exe" } | Where-Object { $_."Parent Name" -eq "WINWORD.EXE" }
                $Count = [string]::Format('{0:N0}',($Data | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Suspicious Child Process of Microsoft Word detected: regsvr32.exe ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Suspicious-Child-Processes" -ItemType Directory -Force | Out-Null
                    $Data | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Suspicious-Child-Processes\winword.exe_spawns_regsvr32.exe.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "regsvr32.exe" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["D2:D$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }
            }
        }

#############################################################################################################################################################################################

        Function Get-ProcessesWithSuspiciousCommandLineArguments {

        # Checking for processes with suspicious command-line arguments
        if (Test-Path "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv")
        {
            if([int](& $xsv count -d "`t" "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv") -gt 0)
            {
                $Import = Import-Csv "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv" -Delimiter "`t" | Sort-Object @{Expression={$_.PID -as [int]}}

                Write-Output "[Info]  Checking for Processes with Suspicious Command Line Arguments ..."

                # powershell.exe
                $powershell = $Import | Where-Object { $_."Process Name" -eq "powershell.exe" } 

                # Encoded Command (indicates the following chunk of text is a base64 encoded command)
                # https://attack.mitre.org/techniques/T1027/
                $EncodedCommand = $powershell | Where-Object {($_.CommandLine -match "-EncodedCommand") -or ($_.CommandLine -match "-Enc") -or ($_.CommandLine -match "-en ") -or ($_.CommandLine -match "-e ")} | Sort-Object { $_."Create Time" -as [datetime] } -Descending
                $Count = [string]::Format('{0:N0}',($EncodedCommand | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Suspicious PowerShell Parameter detected: Encoded Command ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Processes-With-Suspicious-CommandLine-Arguments\powershell.exe" -ItemType Directory -Force | Out-Null
                    $EncodedCommand | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Processes-With-Suspicious-CommandLine-Arguments\powershell.exe\Encoded-Command.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Encoded Command" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["K2:K$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # Base64 Encoding
                # https://attack.mitre.org/techniques/T1027/
                $Base64Encoding = $powershell | Where-Object {($_.CommandLine -match "base64")} | Sort-Object { $_."Create Time" -as [datetime] } -Descending
                $Count = [string]::Format('{0:N0}',($Base64Encoding | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Suspicious PowerShell Parameter detected: Base64 Encoding ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Processes-With-Suspicious-CommandLine-Arguments\powershell.exe" -ItemType Directory -Force | Out-Null
                    $Base64Encoding | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Processes-With-Suspicious-CommandLine-Arguments\powershell.exe\Base64-Encoding.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Base64 Encoding" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["K2:K$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # WindowStyle Hidden (indicates that the PowerShell session window should be started in a hidden manner)
                # https://attack.mitre.org/techniques/T1564/003/
                $WindowStyleHidden = $powershell | Where-Object {($_.CommandLine -match "-WindowStyle Hidden") -or ($_.CommandLine -match "-W Hidden")} | Sort-Object { $_."Create Time" -as [datetime] } -Descending
                $Count = [string]::Format('{0:N0}',($WindowStyleHidden | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Suspicious PowerShell Parameter detected: WindowStyle Hidden ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Processes-With-Suspicious-CommandLine-Arguments\powershell.exe" -ItemType Directory -Force | Out-Null
                    $WindowStyleHidden | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Processes-With-Suspicious-CommandLine-Arguments\powershell.exe\WindowStyle-Hidden.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "WindowStyle Hidden" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["K2:K$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # Execution Policy Bypass (disables the execution policy for the current PowerShell session)
                # https://attack.mitre.org/techniques/T1059/001/
                $ExecutionPolicyBypass = $powershell | Where-Object {($_.CommandLine -match "-ExecutionPolicy Bypass") -or ($_.CommandLine -match "-Exec Bypass") -or ($_.CommandLine -match "-EP ByPass")} | Sort-Object { $_."Create Time" -as [datetime] } -Descending
                $Count = [string]::Format('{0:N0}',($ExecutionPolicyBypass | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Suspicious PowerShell Parameter detected: Execution Policy Bypass ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Processes-With-Suspicious-CommandLine-Arguments\powershell.exe" -ItemType Directory -Force | Out-Null
                    $ExecutionPolicyBypass | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Processes-With-Suspicious-CommandLine-Arguments\powershell.exe\Execution-Policy-Bypass.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Execution Policy Bypass" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["K2:K$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # Profile Bypass (indicates that the current user’s profile setup script should not be executed when the PowerShell engine starts)
                $ProfileBypass = $powershell | Where-Object {($_.CommandLine -match "-NoProfile") -or ($_.CommandLine -match "-nop ")} | Sort-Object { $_."Create Time" -as [datetime] } -Descending
                $Count = [string]::Format('{0:N0}',($ProfileBypass | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Suspicious PowerShell Parameter detected: Profile Bypass ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Processes-With-Suspicious-CommandLine-Arguments\powershell.exe" -ItemType Directory -Force | Out-Null
                    $ProfileBypass | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Processes-With-Suspicious-CommandLine-Arguments\powershell.exe\Profile-Bypass.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Profile Bypass" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["K2:K$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # NonInteractive Mode (meaning an interactive prompt to the user will not be presented)
                $NonInteractive = $powershell | Where-Object {($_.CommandLine -match "-NonInteractive") -or ($_.CommandLine -match "-NonI")} | Sort-Object { $_."Create Time" -as [datetime] } -Descending
                $Count = [string]::Format('{0:N0}',($NonInteractive | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Suspicious PowerShell Parameter detected: NonInteractive Mode ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Processes-With-Suspicious-CommandLine-Arguments\powershell.exe" -ItemType Directory -Force | Out-Null
                    $NonInteractive | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Processes-With-Suspicious-CommandLine-Arguments\powershell.exe\NonInteractive-Mode.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "NonInteractive" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["K2:K$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # Download (remotely download and execute arbitrary code and binaries)
                # https://attack.mitre.org/techniques/T1059/001/
                $Download = $powershell | Where-Object {($_.CommandLine -match "invoke-webrequest") -or ($_.CommandLine -match "iwr") -or ($_.CommandLine -match "http") -or ($_.CommandLine -match "DownloadString") -or ($_.CommandLine -match "WebClient") -or ($_.CommandLine -match "downloadfile") -or ($_.CommandLine -match "wget") -or ($_.CommandLine -match "cURL")} | Sort-Object { $_."Create Time" -as [datetime] } -Descending
                $Count = [string]::Format('{0:N0}',($Download | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Suspicious PowerShell Parameter detected: Remote Download ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Processes-With-Suspicious-CommandLine-Arguments\powershell.exe" -ItemType Directory -Force | Out-Null
                    $Download | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Processes-With-Suspicious-CommandLine-Arguments\powershell.exe\Download-and-Execution.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Download" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["K2:K$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # Invoke-Expression (executes the command provided on the local machine)
                # https://attack.mitre.org/techniques/T1059/001/
                $Invoke = $powershell | Where-Object {($_.CommandLine -match "Invoke-Expression") -or ($_.CommandLine -match "IEX")} | Sort-Object { $_."Create Time" -as [datetime] } -Descending
                $Count = [string]::Format('{0:N0}',($Invoke | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Suspicious PowerShell Parameter detected: Invoke-Expression ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Processes-With-Suspicious-CommandLine-Arguments\powershell.exe" -ItemType Directory -Force | Out-Null
                    $Invoke | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Processes-With-Suspicious-CommandLine-Arguments\powershell.exe\Invoke-Expression.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Invoke-Expression" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["K2:K$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # Start-Process
                # https://attack.mitre.org/techniques/T1059/001/
                $Execute = $powershell | Where-Object {($_.CommandLine -match "Start-Process")} | Sort-Object { $_."Create Time" -as [datetime] } -Descending
                $Count = [string]::Format('{0:N0}',($Execute | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Suspicious PowerShell Parameter detected: Start-Process ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Processes-With-Suspicious-CommandLine-Arguments\powershell.exe" -ItemType Directory -Force | Out-Null
                    $Execute | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Processes-With-Suspicious-CommandLine-Arguments\powershell.exe\Start-Process.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Start-Process" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["K2:K$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # cmd.exe
                $cmd = $Import | Where-Object { $_."Process Name" -eq "cmd.exe" } 

                # CommandLine Flags
                # https://attack.mitre.org/techniques/T1059/003/
                $CommandLineFlags = $cmd | Where-Object {($_.CommandLine -match "/c") -or ($_.CommandLine -match "/q") -or ($_.CommandLine -match "/k")} | Sort-Object { $_."Create Time" -as [datetime] } -Descending
                $Count = [string]::Format('{0:N0}',($CommandLineFlags | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Suspicious Windows Command Shell Parameter detected: CommandLine Flags ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Processes-With-Suspicious-CommandLine-Arguments\cmd.exe" -ItemType Directory -Force | Out-Null
                    $CommandLineFlags | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Processes-With-Suspicious-CommandLine-Arguments\cmd.exe\CommandLine-Flags.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "CommandLine Flags" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,255,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(0,0,0)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["K2:K$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # /c = The /c parameter is used to terminate the shell after command completion.
                # /q = The /q parameter is used to turn echo off.
                # /k = The /k parameter is used to run a command and then remain open (e.g. whoami).

                # Windows Command Shell + Execution of Batch Script
                # https://attack.mitre.org/techniques/T1059/003/
                $CommandShellBatchScript = $cmd | Where-Object {(($_.CommandLine -match "/c") -or ($_.CommandLine -match "/q") -or ($_.CommandLine -match "/k")) -and (($_.CommandLine -match "\.bat") -or ($_.CommandLine -match "\.cmd"))} | Sort-Object { $_."Create Time" -as [datetime] } -Descending
                $Count = [string]::Format('{0:N0}',($CommandShellBatchScript | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Suspicious Windows Command Shell Parameter detected: Execution of Batch Script ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Processes-With-Suspicious-CommandLine-Arguments\cmd.exe" -ItemType Directory -Force | Out-Null
                    $CommandShellBatchScript | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Processes-With-Suspicious-CommandLine-Arguments\cmd.exe\Execution-of-Batch-Script.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Batch Script" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["K2:K$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # mshta.exe
                $mshta = $Import | Where-Object { $_."Process Name" -eq "mshta.exe" }
                
                # Suspicious Execution
                # https://attack.mitre.org/techniques/T1059/007/
                # https://attack.mitre.org/techniques/T1218/005/
                $MshtaExecution = $mshta | Where-Object {(($_.CommandLine -match "\.hta") -or ($_.CommandLine -match "\.htm") -or ($_.CommandLine -match "http") -or ($_.CommandLine -match "javascript") -or ($_.CommandLine -match "vbscript"))} | Sort-Object { $_."Create Time" -as [datetime] } -Descending
                $Count = [string]::Format('{0:N0}',($MshtaExecution | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Suspicious Microsoft HTML Application Host Parameter detected: Execution of HTA File (and Javascript or VBScript) ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Processes-With-Suspicious-CommandLine-Arguments\mshta.exe" -ItemType Directory -Force | Out-Null
                    $MshtaExecution | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Processes-With-Suspicious-CommandLine-Arguments\mshta.exe\Suspicious-Execution.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Suspicious Execution" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["K2:K$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }  
            }
        }

        }

        Get-ProcessesWithSuspiciousCommandLineArguments

#############################################################################################################################################################################################
        
        Function Get-SuspiciousProcessesWithoutCommandLineArguments {

        # Checking for suspicious processes without any command-line arguments
        if (Test-Path "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv")
        {
            if([int](& $xsv count -d "`t" "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv") -gt 0)
            {
                Write-Output "[Info]  Checking for Suspicious Processes without any Command Line Arguments ..."

                $Import = Import-Csv "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv" -Delimiter "`t" | Sort-Object @{Expression={$_.PID -as [int]}}

                # Process Injection
                # https://attack.mitre.org/techniques/T1055/

                # svchost.exe
                $Data = $Import | Where-Object { $_."Process Name" -eq "svchost.exe" } | Where-Object { $_."CommandLine" -eq " " }
                $Count = [string]::Format('{0:N0}',($Data | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Suspicious Windows Service Host (svchost.exe) detected: No CommandLine value available ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Suspicious-Processes-Without-CommandLine-Arguments" -ItemType Directory -Force | Out-Null
                    $Data | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Suspicious-Processes-Without-CommandLine-Arguments\T1055_svchost.exe.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "svchost.exe" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["K2:K$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # System Binary Proxy Execution
                # https://attack.mitre.org/techniques/T1218/011/

                # rundll32.exe
                $Data = $Import | Where-Object { $_."Process Name" -eq "rundll32.exe" } | Where-Object { $_."CommandLine" -eq " " }
                $Count = [string]::Format('{0:N0}',($Data | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Suspicious System Binary Proxy Execution (rundll32.exe) detected: No CommandLine value available ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Suspicious-Processes-Without-CommandLine-Arguments" -ItemType Directory -Force | Out-Null
                    $Data | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Suspicious-Processes-Without-CommandLine-Arguments\T1218.011_rundll32.exe.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "rundll32.exe" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["K2:K$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }
            }
        }

        }

        Get-SuspiciousProcessesWithoutCommandLineArguments

#############################################################################################################################################################################################

        Function Get-DoubleFileExtensions {

        # Double File Extension (Masquerading)
        # https://attack.mitre.org/techniques/T1036/007/
        # Note: This simple search looks for processes launched from files that have double extensions in the file name.
        if (Test-Path "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv")
        {
            if([int](& $xsv count -d "`t" "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv") -gt 0)
            {
                Write-Output "[Info]  Checking for Processes with Suspicious Double File Extension ..."

                # Whitelist
                $Whitelist = "(Microsoft.Photos.exe|WinStore.App.exe)"

                $Processes = Import-Csv "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv" -Delimiter "`t" | Where-Object {$_."Process Name" -notmatch "$Whitelist"}

                foreach ($Process in $Processes)
                {
                    $ProcessName = $Process | Select-Object -ExpandProperty "Process Name"

                    $DotCount = ($ProcessName.ToCharArray() | Where-Object {$_ -eq "."} | Measure-Object).Count
                    if($DotCount -gt 1)
                    {
                        Write-Host "[Alert] Suspicious Double File Extension detected: $ProcessName [T1036.007]" -ForegroundColor Red
                        New-Item "$OUTPUT_FOLDER\sys\proc\Suspicious-Double-File-Extension" -ItemType Directory -Force | Out-Null
                        $Process | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Suspicious-Double-File-Extension\Double-File-Extension_$ProcessName.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Double File Extension" -CellStyleSB {
                        param($WorkSheet)
                        # BackgroundColor and FontColor for specific cells of TopRow
                        $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                        Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                        # HorizontalAlignment "Center" of columns A-F, H-I and L-M
                        $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                        $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                        $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                        # BackgroundColor and FontColor for specific cells
                        $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                        $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                        $LastRow = $WorkSheet.Dimension.End.Row
                        Set-Format -Address $WorkSheet.Cells["B2:B$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                        }
                    }
                }
            }
        }

        }

        Get-DoubleFileExtensions

#############################################################################################################################################################################################

        Function Get-CommandAndScriptingInterpreters {

        # Command and Scripting Interpreters
        # https://attack.mitre.org/techniques/T1059/
        # Note: This simple search looks for process names of Command and Scripting Interpreters. Adversaries abuse command and script interpreters to execute commands, scripts or binaries.
        if (Test-Path "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv")
        {
            if([int](& $xsv count -d "`t" "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv") -gt 0)
            {
                Write-Output "[Info]  Checking for Command and Scripting Interpreters ..."

                $Import = Import-Csv "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv" -Delimiter "`t" | Sort-Object @{Expression={$_.PID -as [int]}}

                # cmd.exe
                $Data = $Import | Where-Object { $_."Process Name" -eq "cmd.exe" }
                $Count = [string]::Format('{0:N0}',($Data | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Command and Scripting Interpreter detected: cmd.exe ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Command-and-Scripting-Interpreter" -ItemType Directory -Force | Out-Null
                    $Data | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Command-and-Scripting-Interpreter\cmd.exe.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "cmd.exe" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["B2:B$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # cscript.exe
                $Data = $Import | Where-Object { $_."Process Name" -eq "cscript.exe" }
                $Count = [string]::Format('{0:N0}',($Data | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Command and Scripting Interpreter detected: cscript.exe ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Command-and-Scripting-Interpreter" -ItemType Directory -Force | Out-Null
                    $Data | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Command-and-Scripting-Interpreter\cscript.exe.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "cscript.exe" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["B2:B$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # mshta.exe
                $Data = $Import | Where-Object { $_."Process Name" -eq "mshta.exe" }
                $Count = [string]::Format('{0:N0}',($Data | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Command and Scripting Interpreter detected: mshta.exe ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Command-and-Scripting-Interpreter" -ItemType Directory -Force | Out-Null
                    $Data | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Command-and-Scripting-Interpreter\mshta.exe.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "mshta.exe" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["B2:B$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # powershell.exe
                $Data = $Import | Where-Object { $_."Process Name" -eq "powershell.exe" }
                $Count = [string]::Format('{0:N0}',($Data | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Command and Scripting Interpreter detected: powershell.exe ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Command-and-Scripting-Interpreter" -ItemType Directory -Force | Out-Null
                    $Data | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Command-and-Scripting-Interpreter\powershell.exe.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "powershell.exe" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["B2:B$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # pwsh.exe
                $Data = $Import | Where-Object { $_."Process Name" -eq "pwsh.exe" }
                $Count = [string]::Format('{0:N0}',($Data | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Command and Scripting Interpreter detected: pwsh.exe ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Command-and-Scripting-Interpreter" -ItemType Directory -Force | Out-Null
                    $Data | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Command-and-Scripting-Interpreter\pwsh.exe.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "pwsh.exe" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["B2:B$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # python.exe
                $Data = $Import | Where-Object { $_."Process Name" -eq "python.exe" }
                $Count = [string]::Format('{0:N0}',($Data | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Command and Scripting Interpreter detected: python.exe ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Command-and-Scripting-Interpreter" -ItemType Directory -Force | Out-Null
                    $Data | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Command-and-Scripting-Interpreter\python.exe.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "python.exe" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["B2:B$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }

                # wscript.exe
                $Data = $Import | Where-Object { $_."Process Name" -eq "wscript.exe" }
                $Count = [string]::Format('{0:N0}',($Data | Measure-Object).Count)

                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Command and Scripting Interpreter detected: wscript.exe ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\proc\Command-and-Scripting-Interpreter" -ItemType Directory -Force | Out-Null
                    $Data | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\Command-and-Scripting-Interpreter\wscript.exe.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "wscript.exe" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["H:I"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:M"].Style.HorizontalAlignment="Center"
                    # BackgroundColor and FontColor for specific cells
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
                    $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
                    $LastRow = $WorkSheet.Dimension.End.Row
                    Set-Format -Address $WorkSheet.Cells["B2:B$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
                    }
                }
            }
        }
        
        }

        Get-CommandAndScriptingInterpreters

#############################################################################################################################################################################################

        Function Get-MiniDumps {
        
        # MiniDumps
        if (Test-Path "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv")
        {
            if([int](& $xsv count -d "`t" "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv") -gt 0)
            {
                New-Item "$OUTPUT_FOLDER\sys\proc\MiniDumps" -ItemType Directory -Force | Out-Null
                $ProcessList = Import-Csv "$OUTPUT_FOLDER\sys\proc\CSV\proc.csv" -Delimiter "`t" | Where-Object { $_."Process Name" -ne "" } | Select-Object "Process Name", PID | Sort-Object @{Expression={$_.PID -as [int]}}

                # TXT
                ForEach( $Process in $ProcessList )
                {
                    $ProcessID = ($Process | Select-Object PID).PID
                    $FilePath  = "$DriveLetter\pid\$ProcessID\minidump\minidump.dmp"
                    $FilePath | Out-File "$OUTPUT_FOLDER\sys\proc\MiniDumps\MiniDumps.txt" -Append
                }

                # CSV
                $ProcessList | Foreach-Object {
                    
                    $ProcessName = $_ | Select-Object -ExpandProperty "Process Name"
                    $ProcessID   = $_ | Select-Object -ExpandProperty PID
                    $FilePath    = "$DriveLetter\pid\$ProcessID\minidump\minidump.dmp"
                    $FileInfo    = Get-Item "$FilePath" -Force -ErrorAction SilentlyContinue
                    $Length      = $FileInfo.Length

                    if ($Length -eq "0")
                    {
                        $FileSize = "0"
                    }
                    else
                    {
                        $FileSize = Get-FileSize($Length)
                    }

                    New-Object -TypeName PSObject -Property @{
                        "ProcessName" = $ProcessName
                        "PID"         = $ProcessID
                        "FilePath"    = $FilePath
                        "Bytes"       = $Length
                        "FileSize"    = $FileSize
                        }
                } | Select-Object "ProcessName","PID","FilePath","Bytes","FileSize" | Export-Csv -Path "$OUTPUT_FOLDER\sys\proc\MiniDumps\MiniDumps.csv" -Delimiter "," -NoTypeInformation

                # XLSX
                if (Get-Module -ListAvailable -Name ImportExcel)
                {
                    if (Test-Path "$OUTPUT_FOLDER\sys\proc\MiniDumps\MiniDumps.csv")
                    {
                        if([int](& $xsv count "$OUTPUT_FOLDER\sys\proc\MiniDumps\MiniDumps.csv") -gt 0)
                        {
                            $IMPORT = Import-Csv "$OUTPUT_FOLDER\sys\proc\MiniDumps\MiniDumps.csv" -Delimiter ","
                            $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\sys\proc\MiniDumps\MiniDumps.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "MiniDumps" -CellStyleSB {
                            param($WorkSheet)
                            # BackgroundColor and FontColor for specific cells of TopRow
                            $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                            Set-Format -Address $WorkSheet.Cells["A1:E1"] -BackgroundColor $BackgroundColor -FontColor White
                            # HorizontalAlignment "Center" of column B
                            $WorkSheet.Cells["B:B"].Style.HorizontalAlignment="Center"
                            # HorizontalAlignment "Right" of columns D-E
                            $WorkSheet.Cells["D:E"].Style.HorizontalAlignment="Right"
                            # HorizontalAlignment "Center" of header of columns D-E
                            $WorkSheet.Cells["D1:E1"].Style.HorizontalAlignment="Center"
                            }
                        }
                    }
                }
            }
        }
        
        }

        Get-MiniDumps

#############################################################################################################################################################################################

        # FS_SysInfo_Services
        # https://github.com/ufrisk/MemProcFS/wiki/FS_SysInfo_Services
        if (Test-Path "$DriveLetter\sys\services\services.txt")
        {
            New-Item "$OUTPUT_FOLDER\sys\services" -ItemType Directory -Force | Out-Null

            # All Services
            Add-Content -Path "$OUTPUT_FOLDER\sys\services\services.txt" -Encoding utf8 -Value (Get-Content -Path "$DriveLetter\sys\services\services.txt")

            # Running Services
            Write-Output "   #    PID Start Type   State      Type Type    Obj Address  Name / Display Name                                              User                         Image Path                                          Object Name / Command Line   " | Out-File "$OUTPUT_FOLDER\sys\services\services-running.txt"
            Write-Output "----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------" | Out-File "$OUTPUT_FOLDER\sys\services\services-running.txt" -Append
            Get-Content "$OUTPUT_FOLDER\sys\services\services.txt" | Select-String -Pattern "RUNNING" -CaseSensitive | Add-Content "$OUTPUT_FOLDER\sys\services\services-running.txt" -Encoding utf8

            # Stopped Services
            Write-Output "   #    PID Start Type   State      Type Type    Obj Address  Name / Display Name                                              User                         Image Path                                          Object Name / Command Line   " | Out-File "$OUTPUT_FOLDER\sys\services\services-stopped.txt"
            Write-Output "----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------" | Out-File "$OUTPUT_FOLDER\sys\services\services-stopped.txt" -Append
            Get-Content "$OUTPUT_FOLDER\sys\services\services.txt" | Select-String -Pattern "STOPPED" -CaseSensitive | Add-Content "$OUTPUT_FOLDER\sys\services\services-stopped.txt" -Encoding utf8

            # Count Services
            $Total = (Get-Content "$OUTPUT_FOLDER\sys\services\services.txt" | Measure-Object).Count -2
            $Running = (Get-Content "$OUTPUT_FOLDER\sys\services\services-running.txt" | Measure-Object).Count
            Write-Output "[Info]  Processing $Total Services (Running Services: $Running) ..."

            # CSV
            if (Test-Path "$DriveLetter\forensic\json\general.json")
            {
                $Data = Get-Content "$DriveLetter\forensic\json\general.json" | ConvertFrom-Json | Where-Object { $_.type -eq "service" }

                $Data | Foreach-Object {

                $procid = $_ | Select-Object -ExpandProperty pid -ErrorAction SilentlyContinue
                $obj = $_ | Select-Object -ExpandProperty obj
                $desc = $_ | Select-Object -ExpandProperty desc
                $start = $_ | Select-Object -ExpandProperty desc2 | Select-Object @{Name="start"; Expression={ForEach-Object{($_ -split "start:")[1]} | ForEach-Object{($_ -split "state:")[0]} | ForEach-Object{($_ -replace "[\[\]]","")}}}
                $state = $_ | Select-Object -ExpandProperty desc2 | Select-Object @{Name="state"; Expression={ForEach-Object{($_ -split "state:")[1]} | ForEach-Object{($_ -split "type:")[0]} | ForEach-Object{($_ -replace "[\[\]]","")}}}
                $type = $_ | Select-Object -ExpandProperty desc2 | Select-Object @{Name="type"; Expression={ForEach-Object{($_ -split "type:")[1]} | ForEach-Object{($_ -split "user:")[0]} | ForEach-Object{($_ -replace "[\[\]]","")}}}
                $user = $_ | Select-Object -ExpandProperty desc2 | Select-Object @{Name="user"; Expression={ForEach-Object{($_ -split "user:")[1]} | ForEach-Object{($_ -split "image:")[0]} | ForEach-Object{($_ -replace "[\[\]]","")}}}
                $image = $_ | Select-Object -ExpandProperty desc2 | Select-Object @{Name="image"; Expression={ForEach-Object{($_ -split "image:")[1]} | ForEach-Object{($_ -split "path:")[0]} | ForEach-Object{($_ -replace "[\[\]]","")}}}
                $path = $_ | Select-Object -ExpandProperty desc2 | Select-Object @{Name="path"; Expression={ForEach-Object{($_ -split "path:")[1]} | ForEach-Object{($_ -replace "[\[\]]","")}}}

                New-Object -TypeName PSObject -Property @{
                    "PID" = $procid
                    "Start Type" = $start.start
                    "State" = $state.state
                    "Type" = $type.type
	                "Object Address" = $obj
	                "Name / Display Name" = $desc
                    "User" = $user.user
                    "Image Path" = $image.image
                    "Object Name / Command Line" = $path.path
                    }
                } | Select-Object "PID","Start Type","State","Type","Object Address","Name / Display Name","User","Image Path","Object Name / Command Line" | Export-Csv -Path "$OUTPUT_FOLDER\sys\services\services.csv" -Delimiter "`t" -NoTypeInformation
            }

            # XLSX
            if (Get-Module -ListAvailable -Name ImportExcel)
            {
                if (Test-Path "$OUTPUT_FOLDER\sys\services\services.csv")
                {
                    if([int](& $xsv count -d "`t" "$OUTPUT_FOLDER\sys\services\services.csv") -gt 0)
                    {
                        $IMPORT = Import-Csv "$OUTPUT_FOLDER\sys\services\services.csv" -Delimiter "`t"
                        $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\sys\services\services.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Services" -CellStyleSB {
                        param($WorkSheet)
                        # BackgroundColor and FontColor for specific cells of TopRow
                        $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                        Set-Format -Address $WorkSheet.Cells["A1:I1"] -BackgroundColor $BackgroundColor -FontColor White
                        # HorizontalAlignment "Center" of columns A-E and G
                        $WorkSheet.Cells["A:E"].Style.HorizontalAlignment="Center"
                        $WorkSheet.Cells["G:G"].Style.HorizontalAlignment="Center"
                        }
                    }
                }
            }
            
            # Service running from a suspicious folder location: C:\Users\*\AppData\Local\Temp\*
            $Count = (Get-Content "$OUTPUT_FOLDER\sys\services\services.txt" | Select-String -Pattern "[A-Z]{1}:\\Users\\.*\\AppData\\Local\\Temp\\" | Measure-Object).Count
            if ($Count -gt 0)
            {
                Write-Host "[Alert] Service running from a suspicious folder location: C:\Users\*\AppData\Local\Temp\* ($Count)" -ForegroundColor Red
                New-Item "$OUTPUT_FOLDER\sys\services\Suspicious-Services" -ItemType Directory -Force | Out-Null
                (Get-Content "$OUTPUT_FOLDER\sys\services\services.txt" | Select-String -Pattern "[A-Z]{1}:\\Users\\.*\\AppData\\Local\\Temp\\" | Out-String).Trim() | Set-Content "$OUTPUT_FOLDER\sys\services\Suspicious-Services\AppData-Local-Temp.txt" -Encoding utf8
            }
        }

#############################################################################################################################################################################################

        # FS_SysInfo_ScheduledTasks
        # https://github.com/ufrisk/MemProcFS/wiki/FS_SysInfo_ScheduledTasks
        # Note: A scheduled task can be used by an adversary to establish persistence, move laterally, and/or escalate privileges.
        if (Test-Path "$DriveLetter\sys\tasks\tasks.txt")
        {
            # tasks.txt
            New-Item "$OUTPUT_FOLDER\sys\tasks" -ItemType Directory -Force | Out-Null
            Add-Content -Path "$OUTPUT_FOLDER\sys\tasks\tasks.txt" -Encoding UTF8 -Value (Get-Content -Path "$DriveLetter\sys\tasks\tasks.txt")
            
            # by-guid
            Copy-Item -Path "$DriveLetter\sys\tasks\by-guid" -Destination "$OUTPUT_FOLDER\sys\tasks" -Recurse

            # by-name
            Copy-Item -Path "$DriveLetter\sys\tasks\by-name" -Destination "$OUTPUT_FOLDER\sys\tasks" -Recurse

            # Count Scheduled Tasks
            if (Test-Path "$DriveLetter\forensic\csv\tasks.csv")
            {
                [int]$Count = & $xsv count "$DriveLetter\forensic\csv\tasks.csv"
                Write-Output "[Info]  Processing $Count ScheduledTasks ..."
            }

            # Threat Hunting: Scheduled Tasks
            # https://attack.mitre.org/techniques/T1053/

            if (Test-Path "$DriveLetter\forensic\csv\tasks.csv")
            {
                $Tasks = Import-Csv -Path "$DriveLetter\forensic\csv\tasks.csv" -Delimiter "," -Encoding UTF8

                # a) Task Scheduler running from a suspicious folder location (False Positives: MEDIUM)

                # Task Scheduler running from a suspicious folder location: C:\Users\*
                $Import = $Tasks | Where-Object { $_.CommandLine -match "[A-Z]{1}:\\Users\\*" }
                $Count = ($Import | Measure-Object).Count
                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Task Scheduler running from a suspicious folder location: C:\Users\* ($Count)" -ForegroundColor Yellow
                    New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Location\CSV" -ItemType Directory -Force | Out-Null
                    $Import | Export-Csv -Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Location\CSV\Users.csv" -NoTypeInformation -Encoding UTF8

                    # XLSX
                    if (Get-Module -ListAvailable -Name ImportExcel)
                    {
                        if (Test-Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Location\CSV\Users.csv")
                        {
                            if([int](& $xsv count -d "," "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Location\CSV\Users.csv") -gt 0)
                            {
                                New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Location\XLSX" -ItemType Directory -Force | Out-Null
                                $Import = Import-Csv "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Location\CSV\Users.csv" -Delimiter ","
                                $Import | Export-Excel -Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Location\XLSX\Users.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Users" -CellStyleSB {
                                param($WorkSheet)
                                # BackgroundColor and FontColor for specific cells of TopRow
                                $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                                Set-Format -Address $WorkSheet.Cells["A1:K1"] -BackgroundColor $BackgroundColor -FontColor White
                                # HorizontalAlignment "Center" of columns A, D-E and H-K
                                $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["D:E"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["H:K"].Style.HorizontalAlignment="Center"
                                # ConditionalFormatting
                                Add-ConditionalFormatting -Address $WorkSheet.Cells["F:F"] -WorkSheet $WorkSheet -RuleType 'Expression' 'NOT(ISERROR(FIND("\Users\",$F1)))' -BackgroundColor Yellow
                                }
                            }
                        }
                    }
                }

                # Task Scheduler running from a suspicious folder location: C:\ProgramData\*
                $Import = $Tasks | Where-Object { $_.CommandLine -match "[A-Z]{1}:\\ProgramData\\*" }
                $Count = ($Import | Measure-Object).Count
                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Task Scheduler running from a suspicious folder location: C:\ProgramData\* ($Count)" -ForegroundColor Yellow
                    New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Location\CSV" -ItemType Directory -Force | Out-Null
                    $Import | Export-Csv -Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Location\CSV\ProgramData.csv" -NoTypeInformation -Encoding UTF8

                    # XLSX
                    if (Get-Module -ListAvailable -Name ImportExcel)
                    {
                        if (Test-Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Location\CSV\ProgramData.csv")
                        {
                            if([int](& $xsv count -d "," "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Location\CSV\ProgramData.csv") -gt 0)
                            {
                                New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Location\XLSX" -ItemType Directory -Force | Out-Null
                                $Import = Import-Csv "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Location\CSV\ProgramData.csv" -Delimiter ","
                                $Import | Export-Excel -Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Location\XLSX\ProgramData.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "ProgramData" -CellStyleSB {
                                param($WorkSheet)
                                # BackgroundColor and FontColor for specific cells of TopRow
                                $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                                Set-Format -Address $WorkSheet.Cells["A1:K1"] -BackgroundColor $BackgroundColor -FontColor White
                                # HorizontalAlignment "Center" of columns A, D-E and H-K
                                $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["D:E"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["H:K"].Style.HorizontalAlignment="Center"
                                # ConditionalFormatting
                                Add-ConditionalFormatting -Address $WorkSheet.Cells["F:F"] -WorkSheet $WorkSheet -RuleType 'Expression' 'NOT(ISERROR(FIND("\ProgramData\",$F1)))' -BackgroundColor Yellow
                                }
                            }
                        }
                    }
                }

                # Task Scheduler running from a suspicious folder location: C:\Windows\Temp\*
                $Import = $Tasks | Where-Object { $_.CommandLine -match "[A-Z]{1}:\\Windows\\Temp\\" }
                $Count = ($Import | Measure-Object).Count
                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Task Scheduler running from a suspicious folder location: C:\Windows\Temp\* ($Count)" -ForegroundColor Yellow
                    New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Location\CSV" -ItemType Directory -Force | Out-Null
                    $Import | Export-Csv -Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Location\CSV\Temp.csv" -NoTypeInformation -Encoding UTF8

                    # XLSX
                    if (Get-Module -ListAvailable -Name ImportExcel)
                    {
                        if (Test-Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Location\CSV\Temp.csv")
                        {
                            if([int](& $xsv count -d "," "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Location\CSV\Temp.csv") -gt 0)
                            {
                                New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Location\XLSX" -ItemType Directory -Force | Out-Null
                                $Import = Import-Csv "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Location\CSV\Temp.csv" -Delimiter ","
                                $Import | Export-Excel -Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Location\XLSX\Temp.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Temp" -CellStyleSB {
                                param($WorkSheet)
                                # BackgroundColor and FontColor for specific cells of TopRow
                                $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                                Set-Format -Address $WorkSheet.Cells["A1:K1"] -BackgroundColor $BackgroundColor -FontColor White
                                # HorizontalAlignment "Center" of columns A, D-E and H-K
                                $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["D:E"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["H:K"].Style.HorizontalAlignment="Center"
                                # ConditionalFormatting
                                Add-ConditionalFormatting -Address $WorkSheet.Cells["F:F"] -WorkSheet $WorkSheet -RuleType 'Expression' 'NOT(ISERROR(FIND("\Windows\Temp\",$F1)))' -BackgroundColor Yellow
                                }
                            }
                        }
                    }
                }

                # Task Scheduler running from a suspicious folder location: C:\TMP\*
                $Import = $Tasks | Where-Object { $_.CommandLine -match "[A-Z]{1}:\\TMP\\" }
                $Count = ($Import | Measure-Object).Count
                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Task Scheduler running from a suspicious folder location: C:\TMP\* ($Count)" -ForegroundColor Yellow
                    New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Location\CSV" -ItemType Directory -Force | Out-Null
                    $Import | Export-Csv -Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Location\CSV\TMP.csv" -NoTypeInformation -Encoding UTF8

                    # XLSX
                    if (Get-Module -ListAvailable -Name ImportExcel)
                    {
                        if (Test-Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Location\CSV\TMP.csv")
                        {
                            if([int](& $xsv count -d "," "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Location\CSV\TMP.csv") -gt 0)
                            {
                                New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Location\XLSX" -ItemType Directory -Force | Out-Null
                                $Import = Import-Csv "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Location\CSV\TMP.csv" -Delimiter ","
                                $Import | Export-Excel -Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Location\XLSX\TMP.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "TMP" -CellStyleSB {
                                param($WorkSheet)
                                # BackgroundColor and FontColor for specific cells of TopRow
                                $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                                Set-Format -Address $WorkSheet.Cells["A1:K1"] -BackgroundColor $BackgroundColor -FontColor White
                                # HorizontalAlignment "Center" of columns A, D-E and H-K
                                $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["D:E"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["H:K"].Style.HorizontalAlignment="Center"
                                # ConditionalFormatting
                                Add-ConditionalFormatting -Address $WorkSheet.Cells["F:F"] -WorkSheet $WorkSheet -RuleType 'Expression' 'NOT(ISERROR(FIND("\TMP\",$F1)))' -BackgroundColor Yellow
                                }
                            }
                        }
                    }
                }

                # b) Task Scheduler running using suspicious Scripting Utilities (False Positives: MEDIUM)

                # CommandLine

                # Task Scheduler running using suspicious Scripting Utility: certutil.exe
                $Import = $Tasks | Where-Object { $_.CommandLine -match "certutil.exe" }
                $Count = ($Import | Measure-Object).Count
                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Task Scheduler running using suspicious Scripting Utility: certutil.exe ($Count)" -ForegroundColor Yellow
                    New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\CSV" -ItemType Directory -Force | Out-Null
                    $Import | Export-Csv -Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\CSV\certutil.csv" -NoTypeInformation -Encoding UTF8

                    # XLSX
                    if (Get-Module -ListAvailable -Name ImportExcel)
                    {
                        if (Test-Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\CSV\certutil.csv")
                        {
                            if([int](& $xsv count -d "," "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\CSV\certutil.csv") -gt 0)
                            {
                                New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\XLSX" -ItemType Directory -Force | Out-Null
                                $Import = Import-Csv "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\CSV\certutil.csv" -Delimiter ","
                                $Import | Export-Excel -Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\XLSX\certutil.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "certutil.exe" -CellStyleSB {
                                param($WorkSheet)
                                # BackgroundColor and FontColor for specific cells of TopRow
                                $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                                Set-Format -Address $WorkSheet.Cells["A1:K1"] -BackgroundColor $BackgroundColor -FontColor White
                                # HorizontalAlignment "Center" of columns A, D-E and H-K
                                $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["D:E"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["H:K"].Style.HorizontalAlignment="Center"
                                # ConditionalFormatting
                                Add-ConditionalFormatting -Address $WorkSheet.Cells["F:F"] -WorkSheet $WorkSheet -RuleType 'Expression' 'NOT(ISERROR(FIND("certutil",$F1)))' -BackgroundColor Yellow
                                }
                            }
                        }
                    }
                }

                # Task Scheduler running using suspicious Scripting Utility: cmd.exe
                $Import = $Tasks | Where-Object { $_.CommandLine -notmatch "dsregcmd.exe" } | Where-Object { $_.CommandLine -match "cmd.exe" }
                $Count = ($Import | Measure-Object).Count
                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Task Scheduler running using suspicious Scripting Utility: cmd.exe ($Count)" -ForegroundColor Yellow
                    New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\CSV" -ItemType Directory -Force | Out-Null
                    $Import | Export-Csv -Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\CSV\cmd.csv" -NoTypeInformation -Encoding UTF8

                    # XLSX
                    if (Get-Module -ListAvailable -Name ImportExcel)
                    {
                        if (Test-Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\CSV\cmd.csv")
                        {
                            if([int](& $xsv count -d "," "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\CSV\cmd.csv") -gt 0)
                            {
                                New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\XLSX" -ItemType Directory -Force | Out-Null
                                $Import = Import-Csv "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\CSV\cmd.csv" -Delimiter ","
                                $Import | Export-Excel -Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\XLSX\cmd.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "cmd.exe" -CellStyleSB {
                                param($WorkSheet)
                                # BackgroundColor and FontColor for specific cells of TopRow
                                $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                                Set-Format -Address $WorkSheet.Cells["A1:K1"] -BackgroundColor $BackgroundColor -FontColor White
                                # HorizontalAlignment "Center" of columns A, D-E and H-K
                                $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["D:E"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["H:K"].Style.HorizontalAlignment="Center"
                                # ConditionalFormatting
                                Add-ConditionalFormatting -Address $WorkSheet.Cells["F:F"] -WorkSheet $WorkSheet -RuleType 'Expression' 'NOT(ISERROR(FIND("cmd.exe",$F1)))' -BackgroundColor Yellow
                                }
                            }
                        }
                    }
                }

                # Task Scheduler running using suspicious Scripting Utility: csript.exe
                $Import = $Tasks | Where-Object { $_.CommandLine -match "csript.exe" }
                $Count = ($Import | Measure-Object).Count
                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Task Scheduler running using suspicious Scripting Utility: csript.exe ($Count)" -ForegroundColor Yellow
                    New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\CSV" -ItemType Directory -Force | Out-Null
                    $Import | Export-Csv -Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\CSV\csript.csv" -NoTypeInformation -Encoding UTF8

                    # XLSX
                    if (Get-Module -ListAvailable -Name ImportExcel)
                    {
                        if (Test-Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\CSV\csript.csv")
                        {
                            if([int](& $xsv count -d "," "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\CSV\csript.csv") -gt 0)
                            {
                                New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\XLSX" -ItemType Directory -Force | Out-Null
                                $Import = Import-Csv "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\CSV\csript.csv" -Delimiter ","
                                $Import | Export-Excel -Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\XLSX\csript.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "csript.exe" -CellStyleSB {
                                param($WorkSheet)
                                # BackgroundColor and FontColor for specific cells of TopRow
                                $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                                Set-Format -Address $WorkSheet.Cells["A1:K1"] -BackgroundColor $BackgroundColor -FontColor White
                                # HorizontalAlignment "Center" of columns A, D-E and H-K
                                $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["D:E"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["H:K"].Style.HorizontalAlignment="Center"
                                # ConditionalFormatting
                                Add-ConditionalFormatting -Address $WorkSheet.Cells["F:F"] -WorkSheet $WorkSheet -RuleType 'Expression' 'NOT(ISERROR(FIND("csript.exe",$F1)))' -BackgroundColor Yellow
                                }
                            }
                        }
                    }
                }

                # Task Scheduler running using suspicious Scripting Utility: mshta.exe
                $Import = $Tasks | Where-Object { $_.CommandLine -match "mshta.exe" }
                $Count = ($Import | Measure-Object).Count
                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Task Scheduler running using suspicious Scripting Utility: mshta.exe ($Count)" -ForegroundColor Yellow
                    New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\CSV" -ItemType Directory -Force | Out-Null
                    $Import | Export-Csv -Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\CSV\mshta.csv" -NoTypeInformation -Encoding UTF8

                    # XLSX
                    if (Get-Module -ListAvailable -Name ImportExcel)
                    {
                        if (Test-Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\CSV\mshta.csv")
                        {
                            if([int](& $xsv count -d "," "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\CSV\mshta.csv") -gt 0)
                            {
                                New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\XLSX" -ItemType Directory -Force | Out-Null
                                $Import = Import-Csv "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\CSV\mshta.csv" -Delimiter ","
                                $Import | Export-Excel -Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\XLSX\mshta.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "mshta.exe" -CellStyleSB {
                                param($WorkSheet)
                                # BackgroundColor and FontColor for specific cells of TopRow
                                $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                                Set-Format -Address $WorkSheet.Cells["A1:K1"] -BackgroundColor $BackgroundColor -FontColor White
                                # HorizontalAlignment "Center" of columns A, D-E and H-K
                                $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["D:E"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["H:K"].Style.HorizontalAlignment="Center"
                                # ConditionalFormatting
                                Add-ConditionalFormatting -Address $WorkSheet.Cells["F:F"] -WorkSheet $WorkSheet -RuleType 'Expression' 'NOT(ISERROR(FIND("mshta.exe",$F1)))' -BackgroundColor Yellow
                                }
                            }
                        }
                    }
                }

                # Task Scheduler running using suspicious Scripting Utility: msiexec.exe
                $Import = $Tasks | Where-Object { $_.CommandLine -match "msiexec.exe" }
                $Count = ($Import | Measure-Object).Count
                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Task Scheduler running using suspicious Scripting Utility: msiexec.exe ($Count)" -ForegroundColor Yellow
                    New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\CSV" -ItemType Directory -Force | Out-Null
                    $Import | Export-Csv -Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\CSV\msiexec.csv" -NoTypeInformation -Encoding UTF8

                    # XLSX
                    if (Get-Module -ListAvailable -Name ImportExcel)
                    {
                        if (Test-Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\CSV\msiexec.csv")
                        {
                            if([int](& $xsv count -d "," "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\CSV\msiexec.csv") -gt 0)
                            {
                                New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\XLSX" -ItemType Directory -Force | Out-Null
                                $Import = Import-Csv "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\CSV\msiexec.csv" -Delimiter ","
                                $Import | Export-Excel -Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\XLSX\msiexec.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "msiexec.exe" -CellStyleSB {
                                param($WorkSheet)
                                # BackgroundColor and FontColor for specific cells of TopRow
                                $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                                Set-Format -Address $WorkSheet.Cells["A1:K1"] -BackgroundColor $BackgroundColor -FontColor White
                                # HorizontalAlignment "Center" of columns A, D-E and H-K
                                $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["D:E"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["H:K"].Style.HorizontalAlignment="Center"
                                # ConditionalFormatting
                                Add-ConditionalFormatting -Address $WorkSheet.Cells["F:F"] -WorkSheet $WorkSheet -RuleType 'Expression' 'NOT(ISERROR(FIND("msiexec",$F1)))' -BackgroundColor Yellow
                                }
                            }
                        }
                    }
                }

                # Task Scheduler running using suspicious Scripting Utility: powershell.exe
                $Import = $Tasks | Where-Object { $_.CommandLine -match "powershell.exe" }
                $Count = ($Import | Measure-Object).Count
                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Task Scheduler running using suspicious Scripting Utility: powershell.exe ($Count)" -ForegroundColor Yellow
                    New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\CSV" -ItemType Directory -Force | Out-Null
                    $Import | Export-Csv -Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\CSV\powershell.csv" -NoTypeInformation -Encoding UTF8

                    # XLSX
                    if (Get-Module -ListAvailable -Name ImportExcel)
                    {
                        if (Test-Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\CSV\powershell.csv")
                        {
                            if([int](& $xsv count -d "," "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\CSV\powershell.csv") -gt 0)
                            {
                                New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\XLSX" -ItemType Directory -Force | Out-Null
                                $Import = Import-Csv "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\CSV\powershell.csv" -Delimiter ","
                                $Import | Export-Excel -Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\XLSX\powershell.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "powershell.exe" -CellStyleSB {
                                param($WorkSheet)
                                # BackgroundColor and FontColor for specific cells of TopRow
                                $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                                Set-Format -Address $WorkSheet.Cells["A1:K1"] -BackgroundColor $BackgroundColor -FontColor White
                                # HorizontalAlignment "Center" of columns A, D-E and H-K
                                $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["D:E"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["H:K"].Style.HorizontalAlignment="Center"
                                # ConditionalFormatting
                                Add-ConditionalFormatting -Address $WorkSheet.Cells["F:F"] -WorkSheet $WorkSheet -RuleType 'Expression' 'NOT(ISERROR(FIND("powershell.exe",$F1)))' -BackgroundColor Yellow
                                }
                            }
                        }
                    }
                }

                # Task Scheduler running using suspicious Scripting Utility: regsvr32.exe
                $Import = $Tasks | Where-Object { $_.CommandLine -match "regsvr32.exe" }
                $Count = ($Import | Measure-Object).Count
                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Task Scheduler running using suspicious Scripting Utility: regsvr32.exe ($Count)" -ForegroundColor Yellow
                    New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\CSV" -ItemType Directory -Force | Out-Null
                    $Import | Export-Csv -Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\CSV\regsvr32.csv" -NoTypeInformation -Encoding UTF8

                    # XLSX
                    if (Get-Module -ListAvailable -Name ImportExcel)
                    {
                        if (Test-Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\CSV\regsvr32.csv")
                        {
                            if([int](& $xsv count -d "," "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\CSV\regsvr32.csv") -gt 0)
                            {
                                New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\XLSX" -ItemType Directory -Force | Out-Null
                                $Import = Import-Csv "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\CSV\regsvr32.csv" -Delimiter ","
                                $Import | Export-Excel -Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\XLSX\regsvr32.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "regsvr32.exe" -CellStyleSB {
                                param($WorkSheet)
                                # BackgroundColor and FontColor for specific cells of TopRow
                                $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                                Set-Format -Address $WorkSheet.Cells["A1:K1"] -BackgroundColor $BackgroundColor -FontColor White
                                # HorizontalAlignment "Center" of columns A, D-E and H-K
                                $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["D:E"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["H:K"].Style.HorizontalAlignment="Center"
                                # ConditionalFormatting
                                Add-ConditionalFormatting -Address $WorkSheet.Cells["F:F"] -WorkSheet $WorkSheet -RuleType 'Expression' 'NOT(ISERROR(FIND("regsvr32.exe",$F1)))' -BackgroundColor Yellow
                                }
                            }
                        }
                    }
                }

                # Task Scheduler running using suspicious Scripting Utility: rundll32.exe
                $Import = $Tasks | Where-Object { $_.CommandLine -match "rundll32.exe" }
                $Count = ($Import | Measure-Object).Count
                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Task Scheduler running using suspicious Scripting Utility: rundll32.exe ($Count)" -ForegroundColor Yellow
                    New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\CSV" -ItemType Directory -Force | Out-Null
                    $Import | Export-Csv -Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\CSV\rundll32.csv" -NoTypeInformation -Encoding UTF8

                    # XLSX
                    if (Get-Module -ListAvailable -Name ImportExcel)
                    {
                        if (Test-Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\CSV\rundll32.csv")
                        {
                            if([int](& $xsv count -d "," "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\CSV\rundll32.csv") -gt 0)
                            {
                                New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\XLSX" -ItemType Directory -Force | Out-Null
                                $Import = Import-Csv "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\CSV\rundll32.csv" -Delimiter ","
                                $Import | Export-Excel -Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\XLSX\rundll32.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "rundll32.exe" -CellStyleSB {
                                param($WorkSheet)
                                # BackgroundColor and FontColor for specific cells of TopRow
                                $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                                Set-Format -Address $WorkSheet.Cells["A1:K1"] -BackgroundColor $BackgroundColor -FontColor White
                                # HorizontalAlignment "Center" of columns A, D-E and H-K
                                $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["D:E"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["H:K"].Style.HorizontalAlignment="Center"
                                # ConditionalFormatting
                                Add-ConditionalFormatting -Address $WorkSheet.Cells["F:F"] -WorkSheet $WorkSheet -RuleType 'Expression' 'NOT(ISERROR(FIND("rundll32.exe",$F1)))' -BackgroundColor Yellow
                                }
                            }
                        }
                    }
                }

                # Task Scheduler running using suspicious Scripting Utility: wmic.exe
                $Import = $Tasks | Where-Object { $_.CommandLine -match "wmic.exe" }
                $Count = ($Import | Measure-Object).Count
                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Task Scheduler running using suspicious Scripting Utility: wmic.exe ($Count)" -ForegroundColor Yellow
                    New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\CSV" -ItemType Directory -Force | Out-Null
                    $Import | Export-Csv -Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\CSV\wmic.csv" -NoTypeInformation -Encoding UTF8

                    # XLSX
                    if (Get-Module -ListAvailable -Name ImportExcel)
                    {
                        if (Test-Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\CSV\wmic.csv")
                        {
                            if([int](& $xsv count -d "," "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\CSV\wmic.csv") -gt 0)
                            {
                                New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\XLSX" -ItemType Directory -Force | Out-Null
                                $Import = Import-Csv "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\CSV\wmic.csv" -Delimiter ","
                                $Import | Export-Excel -Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\XLSX\wmic.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "wmic.exe" -CellStyleSB {
                                param($WorkSheet)
                                # BackgroundColor and FontColor for specific cells of TopRow
                                $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                                Set-Format -Address $WorkSheet.Cells["A1:K1"] -BackgroundColor $BackgroundColor -FontColor White
                                # HorizontalAlignment "Center" of columns A, D-E and H-K
                                $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["D:E"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["H:K"].Style.HorizontalAlignment="Center"
                                # ConditionalFormatting
                                Add-ConditionalFormatting -Address $WorkSheet.Cells["F:F"] -WorkSheet $WorkSheet -RuleType 'Expression' 'NOT(ISERROR(FIND("wmic.exe",$F1)))' -BackgroundColor Yellow
                                }
                            }
                        }
                    }
                }

                # Task Scheduler running using suspicious Scripting Utility: wscript.exe
                $Import = $Tasks | Where-Object { $_.CommandLine -match "wscript.exe" }
                $Count = ($Import | Measure-Object).Count
                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Task Scheduler running using suspicious Scripting Utility: wscript.exe ($Count)" -ForegroundColor Yellow
                    New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\CSV" -ItemType Directory -Force | Out-Null
                    $Import | Export-Csv -Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\CSV\wscript.csv" -NoTypeInformation -Encoding UTF8

                    # XLSX
                    if (Get-Module -ListAvailable -Name ImportExcel)
                    {
                        if (Test-Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\CSV\wscript.csv")
                        {
                            if([int](& $xsv count -d "," "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\CSV\wscript.csv") -gt 0)
                            {
                                New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\XLSX" -ItemType Directory -Force | Out-Null
                                $Import = Import-Csv "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\CSV\wscript.csv" -Delimiter ","
                                $Import | Export-Excel -Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Scripting-Utilities\XLSX\wscript.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "wscript.exe" -CellStyleSB {
                                param($WorkSheet)
                                # BackgroundColor and FontColor for specific cells of TopRow
                                $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                                Set-Format -Address $WorkSheet.Cells["A1:K1"] -BackgroundColor $BackgroundColor -FontColor White
                                # HorizontalAlignment "Center" of columns A, D-E and H-K
                                $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["D:E"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["H:K"].Style.HorizontalAlignment="Center"
                                # ConditionalFormatting
                                Add-ConditionalFormatting -Address $WorkSheet.Cells["F:F"] -WorkSheet $WorkSheet -RuleType 'Expression' 'NOT(ISERROR(FIND("wscript.exe",$F1)))' -BackgroundColor Yellow
                                }
                            }
                        }
                    }
                }

                # Parameters

                # Task Scheduler running malicious command line argument: bitsadmin
                $Import = $Tasks | Where-Object { $_.Parameters -match "bitsadmin" }
                $Count = ($Import | Measure-Object).Count
                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Task Scheduler running malicious command line argument: bitsadmin ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\CSV" -ItemType Directory -Force | Out-Null
                    $Import | Export-Csv -Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\CSV\bitsadmin.csv" -NoTypeInformation -Encoding UTF8

                    # XLSX
                    if (Get-Module -ListAvailable -Name ImportExcel)
                    {
                        if (Test-Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\CSV\bitsadmin.csv")
                        {
                            if([int](& $xsv count -d "," "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\CSV\bitsadmin.csv") -gt 0)
                            {
                                New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\XLSX" -ItemType Directory -Force | Out-Null
                                $Import = Import-Csv "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\CSV\bitsadmin.csv" -Delimiter ","
                                $Import | Export-Excel -Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\XLSX\bitsadmin.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "bitsadmin" -CellStyleSB {
                                param($WorkSheet)
                                # BackgroundColor and FontColor for specific cells of TopRow
                                $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                                Set-Format -Address $WorkSheet.Cells["A1:K1"] -BackgroundColor $BackgroundColor -FontColor White
                                # HorizontalAlignment "Center" of columns A, D-E and H-K
                                $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["D:E"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["H:K"].Style.HorizontalAlignment="Center"
                                # ConditionalFormatting
                                Add-ConditionalFormatting -Address $WorkSheet.Cells["G:G"] -WorkSheet $WorkSheet -RuleType 'Expression' 'NOT(ISERROR(FIND("bitsadmin",$G1)))' -BackgroundColor Yellow
                                }
                            }
                        }
                    }
                }

                # Task Scheduler running malicious command line argument: sekurlsa::LogonPasswords --> OS Credential Dumping: LSASS Memory [T1003.001] --> Mimikatz
                $Import = $Tasks | Where-Object { $_.Parameters -match "sekurlsa::LogonPasswords" }
                $Count = ($Import | Measure-Object).Count
                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Task Scheduler running malicious command line argument: sekurlsa::LogonPasswords ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\CSV" -ItemType Directory -Force | Out-Null
                    $Import | Export-Csv -Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\CSV\sekurlsa_LogonPasswords.csv" -NoTypeInformation -Encoding UTF8

                    # XLSX
                    if (Get-Module -ListAvailable -Name ImportExcel)
                    {
                        if (Test-Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\CSV\sekurlsa_LogonPasswords.csv")
                        {
                            if([int](& $xsv count -d "," "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\CSV\sekurlsa_LogonPasswords.csv") -gt 0)
                            {
                                New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\XLSX" -ItemType Directory -Force | Out-Null
                                $Import = Import-Csv "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\CSV\sekurlsa_LogonPasswords.csv" -Delimiter ","
                                $Import | Export-Excel -Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\XLSX\sekurlsa_LogonPasswords.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Mimikatz" -CellStyleSB {
                                param($WorkSheet)
                                # BackgroundColor and FontColor for specific cells of TopRow
                                $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                                Set-Format -Address $WorkSheet.Cells["A1:K1"] -BackgroundColor $BackgroundColor -FontColor White
                                # HorizontalAlignment "Center" of columns A, D-E and H-K
                                $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["D:E"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["H:K"].Style.HorizontalAlignment="Center"
                                # ConditionalFormatting
                                Add-ConditionalFormatting -Address $WorkSheet.Cells["G:G"] -WorkSheet $WorkSheet -RuleType 'Expression' 'NOT(ISERROR(FIND("sekurlsa::LogonPasswords",$G1)))' -BackgroundColor Yellow
                                }
                            }
                        }
                    }
                }

                # Task Scheduler running suspicious command line argument: -WindowStyle Hidden
                $Import = $Tasks | Where-Object { $_.Parameters -match "-WindowStyle Hidden" }
                $Count = ($Import | Measure-Object).Count
                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Task Scheduler running suspicious command line argument: -WindowStyle Hidden ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\CSV" -ItemType Directory -Force | Out-Null
                    $Import | Export-Csv -Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\CSV\WindowStyle_Hidden.csv" -NoTypeInformation -Encoding UTF8

                    # XLSX
                    if (Get-Module -ListAvailable -Name ImportExcel)
                    {
                        if (Test-Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\CSV\WindowStyle_Hidden.csv")
                        {
                            if([int](& $xsv count -d "," "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\CSV\WindowStyle_Hidden.csv") -gt 0)
                            {
                                New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\XLSX" -ItemType Directory -Force | Out-Null
                                $Import = Import-Csv "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\CSV\WindowStyle_Hidden.csv" -Delimiter ","
                                $Import | Export-Excel -Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\XLSX\WindowStyle_Hidden.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "-WindowStyle Hidden" -CellStyleSB {
                                param($WorkSheet)
                                # BackgroundColor and FontColor for specific cells of TopRow
                                $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                                Set-Format -Address $WorkSheet.Cells["A1:K1"] -BackgroundColor $BackgroundColor -FontColor White
                                # HorizontalAlignment "Center" of columns A, D-E and H-K
                                $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["D:E"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["H:K"].Style.HorizontalAlignment="Center"
                                # ConditionalFormatting
                                Add-ConditionalFormatting -Address $WorkSheet.Cells["G:G"] -WorkSheet $WorkSheet -RuleType 'Expression' 'NOT(ISERROR(FIND("-WindowStyle Hidden",$G1)))' -BackgroundColor Yellow
                                }
                            }
                        }
                    }
                }

                # Task Scheduler running suspicious command line argument: -nop
                $Import = $Tasks | Where-Object { $_.Parameters -match "-nop" }
                $Count = ($Import | Measure-Object).Count
                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Task Scheduler running suspicious command line argument: -nop ($Count)" -ForegroundColor Yellow
                    New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\CSV" -ItemType Directory -Force | Out-Null
                    $Import | Export-Csv -Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\CSV\nop.csv" -NoTypeInformation -Encoding UTF8

                    # XLSX
                    if (Get-Module -ListAvailable -Name ImportExcel)
                    {
                        if (Test-Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\CSV\nop.csv")
                        {
                            if([int](& $xsv count -d "," "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\CSV\nop.csv") -gt 0)
                            {
                                New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\XLSX" -ItemType Directory -Force | Out-Null
                                $Import = Import-Csv "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\CSV\nop.csv" -Delimiter ","
                                $Import | Export-Excel -Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\XLSX\nop.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "-nop" -CellStyleSB {
                                param($WorkSheet)
                                # BackgroundColor and FontColor for specific cells of TopRow
                                $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                                Set-Format -Address $WorkSheet.Cells["A1:K1"] -BackgroundColor $BackgroundColor -FontColor White
                                # HorizontalAlignment "Center" of columns A, D-E and H-K
                                $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["D:E"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["H:K"].Style.HorizontalAlignment="Center"
                                # ConditionalFormatting
                                Add-ConditionalFormatting -Address $WorkSheet.Cells["G:G"] -WorkSheet $WorkSheet -RuleType 'Expression' 'NOT(ISERROR(FIND("-nop",$G1)))' -BackgroundColor Red
                                }
                            }
                        }
                    }
                }

                # Task Scheduler running suspicious command line argument: /s --> Remote Scheduled Task
                $Import = $Tasks | Where-Object { $_.Parameters -match " /s " }
                $Count = ($Import | Measure-Object).Count
                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Task Scheduler running suspicious command line argument which indicates a Remote Scheduled Task: /s ($Count)" -ForegroundColor Yellow
                    New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\CSV" -ItemType Directory -Force | Out-Null
                    $Import | Export-Csv -Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\CSV\Remote-Scheduled-Task.csv" -NoTypeInformation -Encoding UTF8

                    # XLSX
                    if (Get-Module -ListAvailable -Name ImportExcel)
                    {
                        if (Test-Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\CSV\Remote-Scheduled-Task.csv")
                        {
                            if([int](& $xsv count -d "," "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\CSV\Remote-Scheduled-Task.csv") -gt 0)
                            {
                                New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\XLSX" -ItemType Directory -Force | Out-Null
                                $Import = Import-Csv "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\CSV\Remote-Scheduled-Task.csv" -Delimiter ","
                                $Import | Export-Excel -Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\XLSX\Remote-Scheduled-Task.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Remote Scheduled Task" -CellStyleSB {
                                param($WorkSheet)
                                # BackgroundColor and FontColor for specific cells of TopRow
                                $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                                Set-Format -Address $WorkSheet.Cells["A1:K1"] -BackgroundColor $BackgroundColor -FontColor White
                                # HorizontalAlignment "Center" of columns A, D-E and H-K
                                $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["D:E"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["H:K"].Style.HorizontalAlignment="Center"
                                # ConditionalFormatting
                                Add-ConditionalFormatting -Address $WorkSheet.Cells["G:G"] -WorkSheet $WorkSheet -RuleType 'Expression' 'NOT(ISERROR(FIND("/s",$G1)))' -BackgroundColor Red
                                }
                            }
                        }
                    }
                }

                # c) Scheduled tasks with suspicious network connections (False Positives: MEDIUM)

                # Task Scheduler running suspicious command line argument: IPv4 address
                $IPv4_Pattern = ".*((?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).*"
                $Import = $Tasks | Where-Object {($_.Parameters -match "$IPv4_Pattern")}
                $Count = ($Import | Measure-Object).Count
                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Task Scheduler running suspicious command line argument: IPv4 address ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\CSV" -ItemType Directory -Force | Out-Null
                    $Import | Export-Csv -Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\CSV\IPv4.csv" -NoTypeInformation -Encoding UTF8

                    # XLSX
                    if (Get-Module -ListAvailable -Name ImportExcel)
                    {
                        if (Test-Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\CSV\IPv4.csv")
                        {
                            if([int](& $xsv count -d "," "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\CSV\IPv4.csv") -gt 0)
                            {
                                New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\XLSX" -ItemType Directory -Force | Out-Null
                                $Import = Import-Csv "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\CSV\IPv4.csv" -Delimiter ","
                                $Import | Export-Excel -Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\XLSX\IPv4.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "IPv4" -CellStyleSB {
                                param($WorkSheet)
                                # BackgroundColor and FontColor for specific cells of TopRow
                                $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                                Set-Format -Address $WorkSheet.Cells["A1:K1"] -BackgroundColor $BackgroundColor -FontColor White
                                # HorizontalAlignment "Center" of columns A, D-E and H-K
                                $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["D:E"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["H:K"].Style.HorizontalAlignment="Center"
                                # ConditionalFormatting
                                Add-ConditionalFormatting -Address $WorkSheet.Cells["G:G"] -WorkSheet $WorkSheet -RuleType 'Expression' 'NOT(ISERROR(FIND(".",$G1)))' -BackgroundColor Yellow
                                }
                            }
                        }
                    }
                }

                # Task Scheduler running suspicious command line argument: IPv6 address
                $IPv6_Pattern = ".*:(?::[a-f\d]{1,4}){0,5}(?:(?::[a-f\d]{1,4}){1,2}|:(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})\.){3}(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})))|[a-f\d]{1,4}:(?:[a-f\d]{1,4}:(?:[a-f\d]{1,4}:(?:[a-f\d]{1,4}:(?:[a-f\d]{1,4}:(?:[a-f\d]{1,4}:(?:[a-f\d]{1,4}:(?:[a-f\d]{1,4}|:)|(?::(?:[a-f\d]{1,4})?|(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})\.){3}(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))))|:(?:(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})\.){3}(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|[a-f\d]{1,4}(?::[a-f\d]{1,4})?|))|(?::(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})\.){3}(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|:[a-f\d]{1,4}(?::(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})\.){3}(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[a-f\d]{1,4}){0,2})|:))|(?:(?::[a-f\d]{1,4}){0,2}(?::(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})\.){3}(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[a-f\d]{1,4}){1,2})|:))|(?:(?::[a-f\d]{1,4}){0,3}(?::(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})\.){3}(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[a-f\d]{1,4}){1,2})|:))|(?:(?::[a-f\d]{1,4}){0,4}(?::(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})\.){3}(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[a-f\d]{1,4}){1,2})|:)).*"
                $Import = $Tasks | Where-Object { $_.Parameters -notmatch "sekurlsa::LogonPasswords" } | Where-Object {($_.Parameters -match "$IPv6_Pattern")}
                $Count = ($Import | Measure-Object).Count
                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Task Scheduler running suspicious command line argument: IPv6 address ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\CSV" -ItemType Directory -Force | Out-Null
                    $Import | Export-Csv -Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\CSV\IPv6.csv" -NoTypeInformation -Encoding UTF8

                    # XLSX
                    if (Get-Module -ListAvailable -Name ImportExcel)
                    {
                        if (Test-Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\CSV\IPv6.csv")
                        {
                            if([int](& $xsv count -d "," "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\CSV\IPv6.csv") -gt 0)
                            {
                                New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\XLSX" -ItemType Directory -Force | Out-Null
                                $Import = Import-Csv "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\CSV\IPv6.csv" -Delimiter ","
                                $Import | Export-Excel -Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\XLSX\IPv6.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "IPv6" -CellStyleSB {
                                param($WorkSheet)
                                # BackgroundColor and FontColor for specific cells of TopRow
                                $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                                Set-Format -Address $WorkSheet.Cells["A1:K1"] -BackgroundColor $BackgroundColor -FontColor White
                                # HorizontalAlignment "Center" of columns A, D-E and H-K
                                $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["D:E"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["H:K"].Style.HorizontalAlignment="Center"
                                # ConditionalFormatting
                                Add-ConditionalFormatting -Address $WorkSheet.Cells["G:G"] -WorkSheet $WorkSheet -RuleType 'Expression' 'NOT(ISERROR(FIND(".",$G1)))' -BackgroundColor Yellow
                                }
                            }
                        }
                    }
                }

                # Task Scheduler running suspicious command line argument: http://
                $Import = $Tasks | Where-Object {($_.Parameters -match "http://")}
                $Count = ($Import | Measure-Object).Count
                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Task Scheduler running suspicious command line argument: http:// ($Count)" -ForegroundColor Yellow
                    New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\CSV" -ItemType Directory -Force | Out-Null
                    $Import | Export-Csv -Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\CSV\http.csv" -NoTypeInformation -Encoding UTF8

                    # XLSX
                    if (Get-Module -ListAvailable -Name ImportExcel)
                    {
                        if (Test-Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\CSV\http.csv")
                        {
                            if([int](& $xsv count -d "," "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\CSV\http.csv") -gt 0)
                            {
                                New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\XLSX" -ItemType Directory -Force | Out-Null
                                $Import = Import-Csv "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\CSV\http.csv" -Delimiter ","
                                $Import | Export-Excel -Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\XLSX\http.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "http" -CellStyleSB {
                                param($WorkSheet)
                                # BackgroundColor and FontColor for specific cells of TopRow
                                $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                                Set-Format -Address $WorkSheet.Cells["A1:K1"] -BackgroundColor $BackgroundColor -FontColor White
                                # HorizontalAlignment "Center" of columns A, D-E and H-K
                                $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["D:E"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["H:K"].Style.HorizontalAlignment="Center"
                                # ConditionalFormatting
                                Add-ConditionalFormatting -Address $WorkSheet.Cells["G:G"] -WorkSheet $WorkSheet -RuleType 'Expression' 'NOT(ISERROR(FIND("http://",$G1)))' -BackgroundColor Yellow
                                }
                            }
                        }
                    }
                }

                # Task Scheduler running suspicious command line argument: https://
                $Import = $Tasks | Where-Object {($_.Parameters -match "https://")}
                $Count = ($Import | Measure-Object).Count
                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Task Scheduler running suspicious command line argument: https:// ($Count)" -ForegroundColor Yellow
                    New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\CSV" -ItemType Directory -Force | Out-Null
                    $Import | Export-Csv -Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\CSV\https.csv" -NoTypeInformation -Encoding UTF8

                    # XLSX
                    if (Get-Module -ListAvailable -Name ImportExcel)
                    {
                        if (Test-Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\CSV\https.csv")
                        {
                            if([int](& $xsv count -d "," "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\CSV\https.csv") -gt 0)
                            {
                                New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\XLSX" -ItemType Directory -Force | Out-Null
                                $Import = Import-Csv "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\CSV\https.csv" -Delimiter ","
                                $Import | Export-Excel -Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\XLSX\https.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "https" -CellStyleSB {
                                param($WorkSheet)
                                # BackgroundColor and FontColor for specific cells of TopRow
                                $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                                Set-Format -Address $WorkSheet.Cells["A1:K1"] -BackgroundColor $BackgroundColor -FontColor White
                                # HorizontalAlignment "Center" of columns A, D-E and H-K
                                $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["D:E"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["H:K"].Style.HorizontalAlignment="Center"
                                # ConditionalFormatting
                                Add-ConditionalFormatting -Address $WorkSheet.Cells["G:G"] -WorkSheet $WorkSheet -RuleType 'Expression' 'NOT(ISERROR(FIND("https://",$G1)))' -BackgroundColor Yellow
                                }
                            }
                        }
                    }
                }

                # d) Custom (False Positives: LOW)

                # Task Scheduler running from a suspicious folder location and executes an EXE: 'C:\Users\*\AppData\Roaming\*' + EXE
                $Import = $Tasks | Where-Object {($_.CommandLine -match "[A-Z]{1}:\\Users\\.*\\AppData\\Roaming\\")} | Where-Object {($_.CommandLine -match "\.exe")}
                $Count = ($Import | Measure-Object).Count
                if ($Count -gt 0)
                {
                    Write-Host "[Alert] Task Scheduler running from a suspicious folder location and executes an EXE: 'C:\Users\*\AppData\Roaming\*' + EXE ($Count)" -ForegroundColor Red
                    New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Location\CSV" -ItemType Directory -Force | Out-Null
                    $Import | Export-Csv -Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Location\CSV\APPDATA-EXE.csv" -NoTypeInformation -Encoding UTF8

                    # XLSX
                    if (Get-Module -ListAvailable -Name ImportExcel)
                    {
                        if (Test-Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\CSV\APPDATA-EXE.csv")
                        {
                            if([int](& $xsv count -d "," "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\CSV\APPDATA-EXE.csv") -gt 0)
                            {
                                New-Item "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\XLSX" -ItemType Directory -Force | Out-Null
                                $Import = Import-Csv "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\CSV\APPDATA-EXE.csv" -Delimiter ","
                                $Import | Export-Excel -Path "$OUTPUT_FOLDER\sys\tasks\Suspicious-Tasks\Parameters\XLSX\APPDATA-EXE.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "APPDATA-EXE" -CellStyleSB {
                                param($WorkSheet)
                                # BackgroundColor and FontColor for specific cells of TopRow
                                $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                                Set-Format -Address $WorkSheet.Cells["A1:K1"] -BackgroundColor $BackgroundColor -FontColor White
                                # HorizontalAlignment "Center" of columns A, D-E and H-K
                                $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["D:E"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["H:K"].Style.HorizontalAlignment="Center"
                                # ConditionalFormatting
                                Add-ConditionalFormatting -Address $WorkSheet.Cells["G:G"] -WorkSheet $WorkSheet -RuleType 'Expression' 'NOT(ISERROR(FIND(".exe",$G1)))' -BackgroundColor Yellow
                                }
                            }
                        }
                    }
                }
            }
        }

#############################################################################################################################################################################################

        # FS_Process_Handles
        # https://github.com/ufrisk/MemProcFS/wiki/FS_Process_Handles
        New-Item "$OUTPUT_FOLDER\sys\handles" -ItemType Directory -Force | Out-Null
        
        # CSV
        if (Test-Path "$DriveLetter\forensic\json\general.json")
        {
            $Data = Get-Content "$DriveLetter\forensic\json\general.json" | ConvertFrom-Json | Where-Object { $_.type -eq "handle" }

            $Data | Foreach-Object {

                $proc = $_ | Select-Object -ExpandProperty proc
                $procid = $_ | Select-Object -ExpandProperty pid
                $handle = $_ | Select-Object -ExpandProperty hex
                $obj = $_ | Select-Object -ExpandProperty obj
                $access = $_ | Select-Object -ExpandProperty hex2 -ErrorAction SilentlyContinue
                $type = $_ | Select-Object -ExpandProperty desc
                $desc = $_ | Select-Object -ExpandProperty desc2
            
                New-Object -TypeName PSObject -Property @{
                "Process" = $proc
                "PID" = $procid
                "Handle" = $handle
                "Object Address" = $obj
                "Access" = $access
                "Type" = $type
                "Details" = $desc
                }

            } | Select-Object "Process","PID","Handle","Object Address","Access","Type","Details" | Export-Csv -Path "$OUTPUT_FOLDER\sys\handles\handles.csv" -Delimiter "`t" -NoTypeInformation
        }

        # XLSX
        if (Get-Module -ListAvailable -Name ImportExcel)
        {
            if (Test-Path "$OUTPUT_FOLDER\sys\handles\handles.csv")
            {
                if([int](& $xsv count -d "`t" "$OUTPUT_FOLDER\sys\handles\handles.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\sys\handles\handles.csv" -Delimiter "`t"
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\sys\handles\handles.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Handles" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:G1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns B-F
                    $WorkSheet.Cells["B:F"].Style.HorizontalAlignment="Center"
                    }
                }
            }
        }

#############################################################################################################################################################################################

        # FS_Web (Web Browser History: Google Chrome, Microsoft Edge and Firefox)
        # https://github.com/ufrisk/MemProcFS/wiki/FS_Web
        if (Test-Path "$DriveLetter\forensic\web\web.txt")
        {
            New-Item "$OUTPUT_FOLDER\forensic\web" -ItemType Directory -Force | Out-Null
            Copy-Item -Path "$DriveLetter\forensic\web\web.txt" -Destination "$OUTPUT_FOLDER\forensic\web\web-draft.txt"
            Add-Content -Path "$OUTPUT_FOLDER\forensic\web\web.txt" -Encoding UTF8 -Value (Get-Content -Path "$OUTPUT_FOLDER\forensic\web\web-draft.txt")
            Remove-Item -Path "$OUTPUT_FOLDER\forensic\web\web-draft.txt" -Force

            # Count URL (w/ thousands separators)
            $Count = (Get-Content "$OUTPUT_FOLDER\forensic\web\web.txt" | Measure-Object).Count -2
            $URL = '{0:N0}' -f $Count
            Write-Output "[Info]  Processing Web History Information (Records: $URL) ..."

            if ($Count -gt 0)
            {
                # CSV
                if (Test-Path "$DriveLetter\forensic\json\general.json")
                {
                    $Data = Get-Content "$DriveLetter\forensic\json\general.json" | ConvertFrom-Json | Where-Object { $_.type -eq "web" }

                    $Data | Foreach-Object {

                        $index     = $_ | Select-Object -ExpandProperty i
                        $proc      = $_ | Select-Object -ExpandProperty proc
                        $procid    = $_ | Select-Object -ExpandProperty pid
                        $url       = $_ | Select-Object -ExpandProperty desc
                        $type      = $_ | Select-Object -ExpandProperty desc2 | Select-Object @{Name="type"; Expression={ForEach-Object{($_ -split "type:")[1]} | ForEach-Object{($_ -split "time:")[0]} | ForEach-Object{($_ -replace "[\[\]]","")}}}
                        $time      = $_ | Select-Object -ExpandProperty desc2 | Select-Object @{Name="time"; Expression={ForEach-Object{($_ -split "time:")[1]} | ForEach-Object{($_ -split "info:")[0]} | ForEach-Object{($_ -replace "[\[\]]","")}}}
                        $info      = $_ | Select-Object -ExpandProperty desc2 | Select-Object @{Name="info"; Expression={ForEach-Object{($_ -split "info:")[1]} | ForEach-Object{($_ -split "info:")[0]} | ForEach-Object{($_ -replace "[\[\]]","")}}}

                        New-Object -TypeName PSObject -Property @{
                        "Index"        = $index
                        "Process Name" = $proc
                        "PID"          = $procid
                        "URL"          = $url
                        "Type"         = $type.type
                        "Timestamp"    = $time.time
                        "Info"         = $info.info
                        }

                    } | Select-Object "Index","Timestamp","Process Name","PID","Type","URL","Info" | Export-Csv -Path "$OUTPUT_FOLDER\forensic\web\web.csv" -Delimiter "," -NoTypeInformation -Encoding UTF8
                }

                # XLSX
                if (Get-Module -ListAvailable -Name ImportExcel)
                {
                    if (Test-Path "$OUTPUT_FOLDER\forensic\web\web.csv")
                    {
                        if([int](& $xsv count "$OUTPUT_FOLDER\forensic\web\web.csv") -gt 0)
                        {
                            $IMPORT = Import-Csv "$OUTPUT_FOLDER\forensic\web\web.csv" -Delimiter ","
                            $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\forensic\web\web.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Web History" -CellStyleSB {
                            param($WorkSheet)
                            # BackgroundColor and FontColor for specific cells of TopRow
                            $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                            Set-Format -Address $WorkSheet.Cells["A1:G1"] -BackgroundColor $BackgroundColor -FontColor White
                            # HorizontalAlignment "Center" of columns A-E
                            $WorkSheet.Cells["A:E"].Style.HorizontalAlignment="Center"
                            }
                        }
                    }
                }
            }
        }

#############################################################################################################################################################################################

        # FS_BitLocker
        # https://github.com/ufrisk/MemProcFS/wiki/FS_BitLocker
        if (Test-Path "$DriveLetter\misc\bitlocker\*.fvek")
        {
            # Collection
            New-Item "$OUTPUT_FOLDER\misc\bitlocker" -ItemType Directory -Force | Out-Null
            Copy-Item -Path "$DriveLetter\misc\bitlocker\*" -Destination "$OUTPUT_FOLDER\misc\bitlocker"

            # Count BitLocker Full Volume Encryption Key(s)
            $Count = (Get-ChildItem -Path "$OUTPUT_FOLDER\misc\bitlocker" -Filter "*.fvek" | Measure-Object).Count
            Write-Output "[Info]  $Count BitLocker Full Volume Encryption Key(s) found"
        }

#############################################################################################################################################################################################
        
        # Forensic Timeline
        # https://github.com/ufrisk/MemProcFS/wiki/FS_Forensic_Timeline

        Function Get-ForensicTimelineCSV {

        if (Test-Path "$OUTPUT_FOLDER\forensic\json\timeline.json")
        {
            Write-Output "[Info]  Creating Forensic Timeline [time-consuming task] ... "

            # Get Start Time
            $script:StartTime_CSVCreation = (Get-Date)

            # CSV --> Timeline Explorer (TLE)
            New-Item "$OUTPUT_FOLDER\forensic\timeline\CSV" -ItemType Directory -Force | Out-Null
            Get-Content "$DriveLetter\forensic\json\timeline.json" | ConvertFrom-Json | Export-Csv -Path "$OUTPUT_FOLDER\forensic\timeline\CSV\timeline.csv" -Delimiter "," -NoTypeInformation -Encoding UTF8

            # File Size (CSV)
            if (Test-Path "$OUTPUT_FOLDER\forensic\timeline\CSV\timeline.csv")
            {
                $Size = Get-FileSize((Get-Item "$OUTPUT_FOLDER\forensic\timeline\CSV\timeline.csv").Length)
                Write-Output "[Info]  File Size (CSV): $Size"
            }

            # Count rows of CSV (w/ thousands separators)
            [int]$Count = & $xsv count "$OUTPUT_FOLDER\forensic\timeline\CSV\timeline.csv"
            $Rows = '{0:N0}' -f $Count
            Write-Output "[Info]  Total Lines (CSV): $Rows"

            # Get End Time
            $EndTime_CSVCreation = (Get-Date)

            # Duration CSV Creation
            $Time_CSVCreation = ($EndTime_CSVCreation-$StartTime_CSVCreation)
            ('Duration CSV Creation:         {0} h {1} min {2} sec' -f $Time_CSVCreation.Hours, $Time_CSVCreation.Minutes, $Time_CSVCreation.Seconds) >> "$OUTPUT_FOLDER\Stats.txt"
        }

        }

        # Checkbox
        if ($ForensicTimelineCSV -eq "Enabled")
        {
            Get-ForensicTimelineCSV
        }

        Function Get-ForensicTimelineXLSX {

        # CSV
        if (!(Test-Path "$OUTPUT_FOLDER\forensic\timeline\CSV\timeline.csv"))
        {
            if (Test-Path "$OUTPUT_FOLDER\forensic\json\timeline.json")
            {
                Write-Output "[Info]  Creating Forensic Timeline [time-consuming task] ... "

                # Get Start Time
                $script:StartTime_CSVCreation = (Get-Date)

                # CSV --> Timeline Explorer (TLE)
                New-Item "$OUTPUT_FOLDER\forensic\timeline\CSV" -ItemType Directory -Force | Out-Null
                Get-Content "$DriveLetter\forensic\json\timeline.json" | ConvertFrom-Json | Export-Csv -Path "$OUTPUT_FOLDER\forensic\timeline\CSV\timeline.csv" -Delimiter "," -NoTypeInformation -Encoding UTF8

                # File Size (CSV)
                if (Test-Path "$OUTPUT_FOLDER\forensic\timeline\CSV\timeline.csv")
                {
                    $Size = Get-FileSize((Get-Item "$OUTPUT_FOLDER\forensic\timeline\CSV\timeline.csv").Length)
                    Write-Output "[Info]  File Size (CSV): $Size"
                }

                # Count rows of CSV (w/ thousands separators)
                [int]$Count = & $xsv count "$OUTPUT_FOLDER\forensic\timeline\CSV\timeline.csv"
                $Rows = '{0:N0}' -f $Count
                Write-Output "[Info]  Total Lines (CSV): $Rows"

                # Get End Time
                $EndTime_CSVCreation = (Get-Date)

                # Duration CSV Creation
                $Time_CSVCreation = ($EndTime_CSVCreation-$StartTime_CSVCreation)
                ('Duration CSV Creation:         {0} h {1} min {2} sec' -f $Time_CSVCreation.Hours, $Time_CSVCreation.Minutes, $Time_CSVCreation.Seconds) >> "$OUTPUT_FOLDER\Stats.txt"
            }
        }

        # XLSX
        if (Get-Module -ListAvailable -Name ImportExcel) 
        {
            if (Test-Path "$OUTPUT_FOLDER\forensic\timeline\CSV\timeline.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\forensic\timeline\CSV\timeline.csv") -gt 0)
                {
                    New-Item "$OUTPUT_FOLDER\forensic\timeline\XLSX" -ItemType Directory -Force | Out-Null

                    [int]$Count = & $xsv count "$OUTPUT_FOLDER\forensic\timeline\CSV\timeline.csv"

                    # Get Start Time
                    $script:StartTime_XLSXCreation = (Get-Date)

                    if ($Count -gt "1048576")
                    {
                        Write-Output "[Info]  ImportExcel: timeline.csv will be splitted [time-consuming task] ..."
                        & $xsv sort -R -s "date" "$OUTPUT_FOLDER\forensic\timeline\CSV\timeline.csv" --delimiter "," -o "$OUTPUT_FOLDER\forensic\timeline\CSV\timeline-reverse.csv"
                        & $xsv split -s 1000000 "$OUTPUT_FOLDER\forensic\timeline\CSV" --filename "timeline-{}.csv" --delimiter "," "$OUTPUT_FOLDER\forensic\timeline\CSV\timeline-reverse.csv"

                        [array]$Files = (Get-ChildItem -Path "$OUTPUT_FOLDER\forensic\timeline\CSV" | Where-Object {$_.Name -match "timeline-[0-9].*\.csv"}).FullName

                        ForEach( $File in $Files )
                        {
                            $FileName = $File | ForEach-Object{($_ -split "\\")[-1]} | ForEach-Object{($_ -split "\.")[0]}
                            $IMPORT = Import-Csv "$File" -Delimiter "," | Select-Object @{Name='Timestamp [UTC]';Expression={([datetime]$_.date).ToUniversalTime().ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='Type';Expression={$_.type}},@{Name='Action';Expression={$_.action}},@{Name='PID';Expression={$_.pid}},@{Name='Number';Expression={$_.num}},@{Name='Description';Expression={$_.desc}} | Sort-Object { $_."Timestamp [UTC]" -as [datetime] } -Descending
                            $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\forensic\timeline\XLSX\$FileName.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Timeline" -CellStyleSB {
                            param($WorkSheet)
                            # BackgroundColor and FontColor for specific cells of TopRow
                            $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                            Set-Format -Address $WorkSheet.Cells["A1:F1"] -BackgroundColor $BackgroundColor -FontColor White
                            # HorizontalAlignment "Center" of columns A-E
                            $WorkSheet.Cells["A:E"].Style.HorizontalAlignment="Center"
                            }
                        }
                    }
                    else
                    {
                        $IMPORT = Import-Csv "$OUTPUT_FOLDER\forensic\timeline\CSV\timeline.csv" -Delimiter "," | Select-Object @{Name='Timestamp [UTC]';Expression={([datetime]$_.date).ToUniversalTime().ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='Type';Expression={$_.type}},@{Name='Action';Expression={$_.action}},@{Name='PID';Expression={$_.pid}},@{Name='Number';Expression={$_.num}},@{Name='Description';Expression={$_.desc}} | Sort-Object { $_."Timestamp [UTC]" -as [datetime] } -Descending
                        $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\forensic\timeline\XLSX\timeline.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Timeline" -CellStyleSB {
                        param($WorkSheet)
                        # BackgroundColor and FontColor for specific cells of TopRow
                        $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                        Set-Format -Address $WorkSheet.Cells["A1:F1"] -BackgroundColor $BackgroundColor -FontColor White
                        # HorizontalAlignment "Center" of columns A-E
                        $WorkSheet.Cells["A:E"].Style.HorizontalAlignment="Center"
                        }
                    }

                    # Get End Time
                    $EndTime_XLSXCreation = (Get-Date)

                    # Duration XLSX Creation
                    $Time_XLSXCreation = ($EndTime_XLSXCreation-$StartTime_XLSXCreation)
                    ('Duration XLSX Creation:        {0} h {1} min {2} sec' -f $Time_XLSXCreation.Hours, $Time_XLSXCreation.Minutes, $Time_XLSXCreation.Seconds) >> "$OUTPUT_FOLDER\Stats.txt"
                }
            }
        }

        }

        # Checkbox
        if ($ForensicTimelineXLSX -eq "Enabled")
        {
            Get-ForensicTimelineXLSX
        }

#############################################################################################################################################################################################
        
        Function Get-Prefetch {

        # FS_Forensic_Prefetch
        # https://github.com/ufrisk/MemProcFS/wiki/FS_Forensic_Prefetch
        if (Test-Path "$DriveLetter\forensic\prefetch\*.pf")
        {
            # Collection
            New-Item "$OUTPUT_FOLDER\forensic\prefetch" -ItemType Directory -Force | Out-Null
            Copy-Item -Path "$DriveLetter\forensic\prefetch\*" -Destination "$OUTPUT_FOLDER\forensic\prefetch"

            # Count recovered Prefetch File(s)
            if (Test-Path "$OUTPUT_FOLDER\forensic\prefetch\00-prefetch-summary.txt")
            {
                [int]$Count = (Get-Content -Path "$OUTPUT_FOLDER\forensic\prefetch\00-prefetch-summary.txt" | Select-String -Pattern "\.pf" | Measure-Object).Count -2
                $Files = '{0:N0}' -f $Count
                Write-Output "[Info]  $Files Prefetch File(s) recovered"
            }
        }

        # Prefetch Files
        if (Test-Path "$OUTPUT_FOLDER\forensic\timeline\CSV\timeline.csv") 
        {
            Write-Output "[Info]  Extracting Prefetch File Information from Forensic Timeline ..."
            New-Item "$OUTPUT_FOLDER\Prefetch" -ItemType Directory -Force | Out-Null

            # CSV
            Import-Csv "$OUTPUT_FOLDER\forensic\timeline\CSV\timeline.csv" -Delimiter "," | Where-Object { $_.desc -match "\.pf$" } | Export-Csv "$OUTPUT_FOLDER\Prefetch\Prefetch.csv" -NoTypeInformation -Encoding UTF8

            # File Size (CSV)
            if (Test-Path "$OUTPUT_FOLDER\Prefetch\Prefetch.csv")
            {
                $Size = Get-FileSize((Get-Item "$OUTPUT_FOLDER\Prefetch\Prefetch.csv").Length)
                Write-Output "[Info]  File Size (CSV): $Size"
            }

            # Count rows of CSV (w/ thousands separators)
            [int]$Count = & $xsv count "$OUTPUT_FOLDER\Prefetch\Prefetch.csv"
            $Rows = '{0:N0}' -f $Count
            Write-Output "[Info]  Total Lines (CSV): $Rows"

            # MOD - Last Write Time
            # CRE - Creation Time
            # RD  - Last Access Time

            # XLSX
            if (Get-Module -ListAvailable -Name ImportExcel) 
            {
                if (Test-Path "$OUTPUT_FOLDER\Prefetch\Prefetch.csv")
                {
                    if([int](& $xsv count "$OUTPUT_FOLDER\Prefetch\Prefetch.csv") -gt 0)
                    {
                        $IMPORT = Import-Csv "$OUTPUT_FOLDER\Prefetch\Prefetch.csv" -Delimiter "," | Select-Object @{Name='Timestamp [UTC]';Expression={([datetime]$_.date).ToUniversalTime().ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='Name';Expression={$_.desc | ForEach-Object{($_ -split "\\")[-1]} }},@{Name='Type';Expression={$_.type}},@{Name='Action';Expression={$_.action}},@{Name='File Path';Expression={$_.desc}} | Sort-Object { $_."Timestamp [UTC]" -as [datetime] } -Descending
                        $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Prefetch\Prefetch.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Prefetch" -CellStyleSB {
                        param($WorkSheet)
                        # BackgroundColor and FontColor for specific cells of TopRow
                        $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                        Set-Format -Address $WorkSheet.Cells["A1:E1"] -BackgroundColor $BackgroundColor -FontColor White
                        # HorizontalAlignment "Center" of columns A and C-D
                        $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                        $WorkSheet.Cells["C:D"].Style.HorizontalAlignment="Center"
                        }
                    }
                }
            }
        }

        }

        Get-Prefetch

#############################################################################################################################################################################################

        Function Get-RecentFiles {
        
        # Recent Folder Artifacts
        if (Test-Path "$OUTPUT_FOLDER\forensic\timeline\CSV\timeline.csv")
        {
            Write-Output "[Info]  Extracting Recent Folder Artifacts from Forensic Timeline ..."
            New-Item "$OUTPUT_FOLDER\RecentFiles" -ItemType Directory -Force | Out-Null

            # TXT (FS_Forensic_Ntfs)
            if (Test-Path "$DriveLetter\forensic\ntfs\_\Users\*\AppData\Roaming\Microsoft\Windows\Recent\*.lnk")
            {
                Get-ChildItem -Path "$DriveLetter\forensic\ntfs\_\Users\*\AppData\Roaming\Microsoft\Windows\Recent\*.lnk" | Select-Object -ExpandProperty FullName | Out-File "$OUTPUT_FOLDER\RecentFiles\RecentFiles.txt"
            }

            # CSV
            Import-Csv "$OUTPUT_FOLDER\forensic\timeline\CSV\timeline.csv" -Delimiter "," | Where-Object { $_.desc -match "\\AppData\\Roaming\\Microsoft\\Windows\\Recent\\.*\.lnk" } | Export-Csv "$OUTPUT_FOLDER\RecentFiles\RecentFiles.csv" -NoTypeInformation -Encoding UTF8

            # File Size (CSV)
            if (Test-Path "$OUTPUT_FOLDER\RecentFiles\RecentFiles.csv")
            {
                $Size = Get-FileSize((Get-Item "$OUTPUT_FOLDER\RecentFiles\RecentFiles.csv").Length)
                Write-Output "[Info]  File Size (CSV): $Size"
            }

            # Count rows of CSV (w/ thousands separators)
            [int]$Count = & $xsv count "$OUTPUT_FOLDER\RecentFiles\RecentFiles.csv"
            $Rows = '{0:N0}' -f $Count
            Write-Output "[Info]  Total Lines (CSV): $Rows"

            # MOD - Last Write Time
            # CRE - Creation Time
            # RD  - Last Access Time

            # XLSX
            if (Get-Module -ListAvailable -Name ImportExcel) 
            {
                if (Test-Path "$OUTPUT_FOLDER\RecentFiles\RecentFiles.csv")
                {
                    if([int](& $xsv count "$OUTPUT_FOLDER\RecentFiles\RecentFiles.csv") -gt 0)
                    {
                        $IMPORT = Import-Csv "$OUTPUT_FOLDER\RecentFiles\RecentFiles.csv" -Delimiter "," -Encoding UTF8 | Select-Object @{Name='Timestamp [UTC]';Expression={([datetime]$_.date).ToUniversalTime().ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='Name';Expression={$_.desc | ForEach-Object{($_ -split "\\")[-1]}}},@{Name='Type';Expression={$_.type}},@{Name='Action';Expression={$_.action}},@{Name='File Path';Expression={$_.desc}},@{Name='Bytes';Expression={$_.num}} | Sort-Object { $_."Timestamp [UTC]" -as [datetime] } -Descending
                        $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\RecentFiles\RecentFiles.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "RecentFiles" -CellStyleSB {
                        param($WorkSheet)
                        # BackgroundColor and FontColor for specific cells of TopRow
                        $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                        Set-Format -Address $WorkSheet.Cells["A1:G1"] -BackgroundColor $BackgroundColor -FontColor White
                        # HorizontalAlignment "Center" of columns A, C-D and F
                        $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                        $WorkSheet.Cells["C:D"].Style.HorizontalAlignment="Center"
                        $WorkSheet.Cells["F:F"].Style.HorizontalAlignment="Center"
                        }
                    }
                }
            }

            # JumpList Artifacts
            New-Item "$OUTPUT_FOLDER\JumpLists" -ItemType Directory -Force | Out-Null

            # TXT (FS_Forensic_Ntfs)
            if (Test-Path "$DriveLetter\forensic\ntfs\_\Users\*\AppData\Roaming\Microsoft\Windows\Recent\*.lnk")
            {
                Get-ChildItem -Path "$DriveLetter\forensic\ntfs\_\Users\*\AppData\Roaming\Microsoft\Windows\Recent\*Destinations\*" -File | Select-Object -ExpandProperty FullName | Where-Object { $_ -notmatch "`$_INFO" } | Out-File "$OUTPUT_FOLDER\JumpLists\JumpLists.txt"
            }

            # CSV
            Import-Csv "$OUTPUT_FOLDER\forensic\timeline\CSV\timeline.csv" -Delimiter "," | Where-Object { $_.desc -match "\\Microsoft\\Windows\\Recent\\(AutomaticDestinations|CustomDestinations)\\" } | Export-Csv "$OUTPUT_FOLDER\JumpLists\JumpLists.csv" -NoTypeInformation -Encoding UTF8

            # XLSX
            if (Get-Module -ListAvailable -Name ImportExcel) 
            {
                if (Test-Path "$OUTPUT_FOLDER\JumpLists\JumpLists.csv")
                {
                    if([int](& $xsv count "$OUTPUT_FOLDER\JumpLists\JumpLists.csv") -gt 0)
                    {
                        $IMPORT = Import-Csv "$OUTPUT_FOLDER\JumpLists\JumpLists.csv" -Delimiter "," | Select-Object @{Name='Timestamp [UTC]';Expression={([datetime]$_.date).ToUniversalTime().ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='Name';Expression={$_.desc | ForEach-Object{($_ -split "\\")[-1]} }},@{Name='Type';Expression={$_.type}},@{Name='Action';Expression={$_.action}},@{Name='File Path';Expression={$_.desc}},@{Name='Bytes';Expression={$_.num}} | Sort-Object { $_."Timestamp [UTC]" -as [datetime] } -Descending
                        $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\JumpLists\JumpLists.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "JumpLists" -CellStyleSB {
                        param($WorkSheet)
                        # BackgroundColor and FontColor for specific cells of TopRow
                        $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                        Set-Format -Address $WorkSheet.Cells["A1:G1"] -BackgroundColor $BackgroundColor -FontColor White
                        # HorizontalAlignment "Center" of columns A, C-D and F
                        $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                        $WorkSheet.Cells["C:D"].Style.HorizontalAlignment="Center"
                        $WorkSheet.Cells["F:F"].Style.HorizontalAlignment="Center"
                        }
                    }
                }
            }
        }

        }

        Get-RecentFiles

#############################################################################################################################################################################################
        
        Function Get-EventLogs {

        # Windows XML Event Log (EVTX)
        if (Test-Path "$DriveLetter\name\svchost.exe-*\files\handles\*.evtx") 
        {
            Write-Output "[Info]  Collecting Windows Event Logs (EVTX) ... "
            New-Item "$OUTPUT_FOLDER\EventLogs\EventLogs" -ItemType Directory -Force | Out-Null
            Get-ChildItem -Recurse -Force "$DriveLetter\name\svchost.exe-*\files\handles\*.evtx" | Foreach-Object FullName | Out-File "$OUTPUT_FOLDER\EventLogs\EventLog-List.txt"
            Copy-Item -Recurse -Force "$DriveLetter\name\svchost.exe-*\files\handles\*.evtx" "$OUTPUT_FOLDER\EventLogs\EventLogs" 2>&1 | Out-Null

            # Rename Event Logs
            (Get-ChildItem "$OUTPUT_FOLDER\EventLogs\EventLogs") | Rename-Item -NewName { $_.Name.Substring(17) }

            # Count EVTX Files
            $Count = (Get-ChildItem -Path "$OUTPUT_FOLDER\EventLogs\EventLogs" -Filter "*.evtx" | Measure-Object).Count
            $InputSize = Get-FileSize((Get-ChildItem -Path "$OUTPUT_FOLDER\EventLogs\EventLogs" -Filter "*.evtx" | Measure-Object Length -Sum).Sum)
            Write-Output "[Info]  Processing $Count EVTX Files ($InputSize) ..."
        }

        }

        Get-EventLogs

#############################################################################################################################################################################################

        # EvtxECmd

        Function Update-EvtxECmd {

        # Internet Connectivity Check (Vista+)
        $NetworkListManager = [Activator]::CreateInstance([Type]::GetTypeFromCLSID([Guid]‘{DCB00C01-570F-4A9B-8D69-199FDBA5723B}’)).IsConnectedToInternet

        if (!($NetworkListManager -eq "True"))
        {
            Write-Host "[Error] Your computer is NOT connected to the Internet. Event Log Maps cannot be updated." -ForegroundColor Red
        }
        else
        {
            # Check if GitHub is reachable
            if (!(Test-NetConnection -ComputerName github.com -Port 443).TcpTestSucceeded)
            {
                Write-Host "[Error] github.com is NOT reachable. Event Log Maps cannot be updated." -ForegroundColor Red
            }
            else
            {
                Write-Output "[Info]  Updating Event Log Maps ... "

                # Flush
                if (Test-Path "$SCRIPT_DIR\Tools\EvtxECmd\Maps")
                {
                    Get-ChildItem -Path "$SCRIPT_DIR\Tools\EvtxECmd\Maps" -Recurse | Remove-Item -Force -Recurse
                }

                # Sync for EvtxECmd Maps with GitHub
                if (Test-Path "$($EvtxECmd)")
                {
                    & $EvtxECmd --sync > "$SCRIPT_DIR\Tools\EvtxECmd\Maps.log" 2> $null
                }
                else
                {
                    Write-Host "[Error] EvtxECmd.exe NOT found." -ForegroundColor Red
                }
            }
        }

        }

        # Offline Mode
        if ($OfflineMode -eq "Enabled")
        {
            Write-Output "[Info]  Updating Event Log Maps will be skipped [Offline-Mode] ..."
        }
        else
        {
            Update-EvtxECmd
        }

        Function Invoke-EvtxECmd {

        # EvtxECmd --> Timeline Explorer
        if (Test-Path "$($EvtxECmd)")
        {
            $Count = (Get-ChildItem "$SCRIPT_DIR\Tools\EvtxECmd\Maps\*" -Include *.map | Measure-Object).Count
            Write-Output "[Info]  $Count Event Log Maps will be initiated by EvtxECmd ..."

            if (Test-Path "$OUTPUT_FOLDER\EventLogs\EventLogs\*.evtx") 
            {
                New-Item "$OUTPUT_FOLDER\EventLogs\EvtxECmd" -ItemType Directory -Force | Out-Null
                & $EvtxECmd -d "$OUTPUT_FOLDER\EventLogs\EventLogs" --csv "$OUTPUT_FOLDER\EventLogs\EvtxECmd" --csvf "EventLogs.csv" > "$OUTPUT_FOLDER\EventLogs\EvtxECmd\EvtxECmd.log" 2> $null

                # File Size (CSV)
                if (Test-Path "$OUTPUT_FOLDER\EventLogs\EvtxECmd\EventLogs.csv")
                {
                    $Size = Get-FileSize((Get-Item "$OUTPUT_FOLDER\EventLogs\EvtxECmd\EventLogs.csv").Length)
                    Write-Output "[Info]  File Size (CSV): $Size"
                }

                # Windows Title (Default)
                $Host.UI.RawUI.WindowTitle = "MemProcFS-Analyzer $Version - Automated Forensic Analysis of Windows Memory Dumps for DFIR"
            }
        }
        else
        {
            Write-Host "[Error] EvtxECmd.exe NOT found." -ForegroundColor Red
        }

        }

        Invoke-EvtxECmd

#############################################################################################################################################################################################

        Function Update-ZircoliteRules {

        # Zircolite
        if (Test-Path "$($Zircolite)")
        {
            # Offline Mode
            if ($OfflineMode -eq "Enabled")
            {
                Write-Output "[Info]  Updating SIGMA Rulesets will be skipped [Offline-Mode] ..."
            }
            else
            {
                # Update
                Write-Output "[Info]  Updating SIGMA Rulesets ..."
                $MyLocation = $pwd
                Set-Location "$SCRIPT_DIR\Tools\Zircolite"
                & $Zircolite --update-rules 2>&1 | Out-File "$SCRIPT_DIR\Tools\Zircolite\Update-draft.log"
                Set-Location "$MyLocation"

                # No newer rulesets found
                if (Test-Path "$SCRIPT_DIR\Tools\Zircolite\Update-draft.log")
                {
                    if (Get-Content "$SCRIPT_DIR\Tools\Zircolite\Update-draft.log" | Select-String -Pattern "No newer rulesets found" -Quiet)
                    {
                        Write-Output "[Info]  No newer rulesets found"
                    }
                }

                # Updated
                if (Test-Path "$SCRIPT_DIR\Tools\Zircolite\Update-draft.log")
                {
                    if (Get-Content "$SCRIPT_DIR\Tools\Zircolite\Update-draft.log" | Select-String -Pattern "Updated :" -Quiet)
                    {
                        Write-Output "[Info]  SIGMA Rulesets updated."
                    }
                }

                # Remove ANSI Control Characters
                if (Test-Path "$SCRIPT_DIR\Tools\Zircolite\Update-draft.log")
                {
                    Get-Content "$SCRIPT_DIR\Tools\Zircolite\Update-draft.log" | ForEach-Object { $_ -replace "\x1b\[[0-9;]*m" } | Out-File "$SCRIPT_DIR\Tools\Zircolite\Update.log"
                    Remove-Item "$SCRIPT_DIR\Tools\Zircolite\Update-draft.log"
                }

                # Remove empty lines and add line breaks where needed
                $Clean = Get-Content "$SCRIPT_DIR\Tools\Zircolite\Update.log" | ForEach-Object{($_ -replace "^   ","")} | Where-Object {$_.Trim()} | ForEach-Object {($_ -replace "Finished in", "`nFinished in")} | ForEach-Object {($_ -replace "Sysmon Linux =-", "Sysmon Linux =-`n")}
                @("") + ($Clean) | Set-Content "$SCRIPT_DIR\Tools\Zircolite\Update.log"

                # Cleaning up
                if (Test-Path "$SCRIPT_DIR\Tools\Zircolite\Update.log")
                {
                    $Filter = @("^zircolite\.exe","MemProcFS-Analyzer-v.*\.ps1","^\+","\+ CategoryInfo          : NotSpecified:","\+ FullyQualifiedErrorId : NativeCommandError","^tmp-rules-")
                    $Clean = Get-Content "$SCRIPT_DIR\Tools\Zircolite\Update.log" | Select-String -Pattern $Filter -NotMatch 
                    $Clean | Set-Content "$SCRIPT_DIR\Tools\Zircolite\Update.log"
                }

                # zircolite.log
                if (Test-Path "$SCRIPT_DIR\Tools\Zircolite\zircolite.log")
                {
                    Remove-Item -Path "$SCRIPT_DIR\Tools\Zircolite\zircolite.log" -Force
                }
            }
        }

        }

        Update-ZircoliteRules

#############################################################################################################################################################################################

        Function Invoke-Zircolite {

        # Zircolite
        if (Test-Path "$($Zircolite)")
        {
            if (Test-Path "$OUTPUT_FOLDER\EventLogs\EventLogs\*.evtx") 
            {
                Write-Output "[Info]  Processing Windows Event Logs w/ Zircolite ... "
                New-Item "$OUTPUT_FOLDER\EventLogs\Zircolite" -ItemType Directory -Force | Out-Null

                $StartTime_Zircolite = (Get-Date)

                # Check if InputSize is greater than 500 MB
                $Bytes = ((Get-ChildItem -Path "$OUTPUT_FOLDER\EventLogs\EventLogs" -Filter "*.evtx" | Measure-Object Length -Sum).Sum)

                if ($Bytes -gt 524288000)
                {
                    # JSON
                    New-Item "$OUTPUT_FOLDER\EventLogs" -ItemType Directory -Force | Out-Null
                    $ScanPath = "$OUTPUT_FOLDER\EventLogs\EventLogs"
                    $Ruleset = "rules\rules_windows_generic_full.json"
                    $TempDir = "$OUTPUT_FOLDER\EventLogs\JSONL"
                    $MyLocation = $pwd
                    Set-Location "$SCRIPT_DIR\Tools\Zircolite"
                    & $Zircolite --evtx $ScanPath --ruleset $Ruleset --noexternal --tmpdir $TempDir --keeptmp 2>&1 | Out-File "$OUTPUT_FOLDER\EventLogs\Zircolite\Zircolite-draft.txt"
                    Set-Location "$MyLocation"
                }
                else
                {
                    $MyLocation = $pwd
                    Set-Location "$SCRIPT_DIR\Tools\Zircolite"

                    # JSON + Mini-GUI
                    Write-Output "[Info]  Creating JSON output and ZircoGui package ..."
                    New-Item "$OUTPUT_FOLDER\EventLogs" -ItemType Directory -Force | Out-Null
                    $ScanPath = "$OUTPUT_FOLDER\EventLogs\EventLogs"
                    $Ruleset = "rules\rules_windows_generic_full.json"
                    $TempDir = "$OUTPUT_FOLDER\EventLogs\JSONL"
                    & $Zircolite --evtx $ScanPath --ruleset $Ruleset --noexternal --package --tmpdir $TempDir --keeptmp 2>&1 | Out-File "$OUTPUT_FOLDER\EventLogs\Zircolite\Zircolite-draft.txt"

                    # Remove ANSI Control Characters
                    if (Test-Path "$OUTPUT_FOLDER\EventLogs\Zircolite\Zircolite-draft.txt")
                    {
                        Get-Content "$OUTPUT_FOLDER\EventLogs\Zircolite\Zircolite-draft.txt" | ForEach-Object { $_ -replace "\x1b\[[0-9;]*m" } | Out-File "$OUTPUT_FOLDER\EventLogs\Zircolite\Zircolite.txt"
                        Remove-Item "$OUTPUT_FOLDER\EventLogs\Zircolite\Zircolite-draft.txt"
                    }

                    # Remove empty lines and add line breaks where needed
                    if (Test-Path "$OUTPUT_FOLDER\EventLogs\Zircolite\Zircolite.txt")
                    {
                        $Clean = Get-Content "$OUTPUT_FOLDER\EventLogs\Zircolite\Zircolite.txt" | Where-Object {$_.Trim()} | ForEach-Object {($_ -replace "Finished in", "`nFinished in")} | ForEach-Object {($_ -replace "Sysmon Linux =-", "Sysmon Linux =-`n")}
                        @("") + ($Clean) | Set-Content "$OUTPUT_FOLDER\EventLogs\Zircolite\Zircolite.txt"
                    }

                    # Cleaning up
                    if (Test-Path "$OUTPUT_FOLDER\EventLogs\Zircolite\Zircolite.txt")
                    {
                        $Filter = @("^zircolite_win10\.exe","MemProcFS-Analyzer-v.*\.ps1","^\+","\+ CategoryInfo          : NotSpecified:","\+ FullyQualifiedErrorId : NativeCommandError","%\|","^tmp-rules-")
                        $Clean = Get-Content "$OUTPUT_FOLDER\EventLogs\Zircolite\Zircolite.txt" | Select-String -Pattern $Filter -NotMatch 
                        $Clean | Set-Content "$OUTPUT_FOLDER\EventLogs\Zircolite\Zircolite.txt"
                    }

                    # Executed Ruleset
                    Start-Sleep 3
                    if (Test-Path "$pwd\zircolite.log")
                    {
                        [int]$Count = Get-Content "$pwd\zircolite.log" | Select-String -Pattern "Executing ruleset" | Select-Object -First 1 | ForEach-Object{($_ -split "\s+")[-2]}
                        $Rules = '{0:N0}' -f $Count
                        Write-Output "[Info]  Executed ruleset - $Rules rules"
                    }

                    # zircolite.log
                    if (Test-Path "$pwd\zircolite.log")
                    {
                        Remove-Item -Path "$pwd\zircolite.log" -Force
                    }

                    # JSON
                    if (Test-Path "$pwd\detected_events.json")
                    {
                        New-Item "$OUTPUT_FOLDER\EventLogs\Zircolite\JSON" -ItemType Directory -Force | Out-Null
                        Move-Item -Path "$pwd\detected_events.json" -Destination "$OUTPUT_FOLDER\EventLogs\Zircolite\JSON\detected_events.json"
                    }

                    # File Size (JSON)
                    if (Test-Path "$OUTPUT_FOLDER\EventLogs\Zircolite\JSON\detected_events.json")
                    {
                        $Size = Get-FileSize((Get-Item "$OUTPUT_FOLDER\EventLogs\Zircolite\JSON\detected_events.json").Length)
                        Write-Output "[Info]  File Size (JSON): $Size"
                    }

                    # ZircoGui
                    if (Test-Path "$pwd\zircogui-output-*.zip")
                    {
                        New-Item "$OUTPUT_FOLDER\EventLogs\Zircolite\Package" -ItemType Directory -Force | Out-Null
                        New-Item "$OUTPUT_FOLDER\EventLogs\Zircolite\Mini-GUI" -ItemType Directory -Force | Out-Null
                        Move-Item -Path "$pwd\zircogui-output-*.zip" -Destination "$OUTPUT_FOLDER\EventLogs\Zircolite\Package"

                        # Unzip ZircoGui Package
                        if (Test-Path "$OUTPUT_FOLDER\EventLogs\Zircolite\Package\zircogui-output-*.zip")
                        {
                            Expand-Archive "$OUTPUT_FOLDER\EventLogs\Zircolite\Package\zircogui-output-*.zip" -DestinationPath "$OUTPUT_FOLDER\EventLogs\Zircolite\Mini-GUI"
                        }

                        # Open ZircoGui
                        if (Test-Path "$OUTPUT_FOLDER\EventLogs\Zircolite\Mini-GUI\index.html")
                        {
                            # Check if Google Chrome is installed
                            if (Test-Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\chrome.exe")
                            {
                                # Open ZircoGui w/ Google Chrome
                                $Chrome = ((Get-Item (Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\chrome.exe")."(Default)").VersionInfo).FileName
                                Start-Process -FilePath $Chrome -ArgumentList "--start-fullscreen $OUTPUT_FOLDER\EventLogs\Zircolite\Mini-GUI\index.html"
                            }
                            else
                            {
                                # Open ZircoGui in your Default Browser
                                Start-Process "$OUTPUT_FOLDER\EventLogs\Zircolite\Mini-GUI\index.html"
                            }
                        }
                    }

                    Set-Location "$MyLocation"

                    # Stats
                    if (Test-Path "$OUTPUT_FOLDER\EventLogs\Zircolite\Zircolite.txt")
                    {
                        if (Get-Content "$OUTPUT_FOLDER\EventLogs\Zircolite\Zircolite.txt" | Select-String -Pattern "    - " -Quiet)
                        {
                            # Count triggered Sigma Rules
                            $Rules = (Get-Content "$OUTPUT_FOLDER\EventLogs\Zircolite\Zircolite.txt" | Select-String -Pattern "    - " | Measure-Object).Count

                            if ($Rules -gt 0)
                            {
                                # Count Events (w/ thousands separators)
                                [int]$Count = (Get-Content "$OUTPUT_FOLDER\EventLogs\Zircolite\Zircolite.txt" | Select-String -Pattern "    - " | ForEach-Object{($_ -split "\s+")[-2]} | Measure-Object -Sum).Sum
                                $Events = '{0:N0}' -f $Count

                                Write-Host "[Alert] $Rules Detection(s) found ($Events events)" -ForegroundColor Red

                                # Sort A-Z
                                Get-Content "$OUTPUT_FOLDER\EventLogs\Zircolite\Zircolite.txt" | Select-String -Pattern "    - " | ForEach-Object{($_ -replace "    - ","")} | Sort-Object | Out-File "$OUTPUT_FOLDER\EventLogs\Zircolite\Detections.txt"

                                # SIGMA Rule Level (critical, high, medium, low)

                                # Critical
                                $Critical = Get-Content "$OUTPUT_FOLDER\EventLogs\Zircolite\Zircolite.txt" | Select-String -Pattern "    - " | Select-String -Pattern "\[critical\]" | ForEach-Object{($_ -replace "    - ","        ")} | Sort-Object
                                $CriticalAlerts = ($Critical | Measure-Object).Count
                                if ($CriticalAlerts -gt 0)
                                { 
                                    $Critical.Trim() | Out-File "$OUTPUT_FOLDER\EventLogs\Zircolite\Detections-Critical.txt" 
                                }

                                # High
                                $High = Get-Content "$OUTPUT_FOLDER\EventLogs\Zircolite\Zircolite.txt" | Select-String -Pattern "    - " | Select-String -Pattern "\[high\]" | ForEach-Object{($_ -replace "    - ","        ")} | Sort-Object
                                $HighAlerts = ($High | Measure-Object).Count
                                if ($HighAlerts -gt 0)
                                { 
                                    $High.Trim() | Out-File "$OUTPUT_FOLDER\EventLogs\Zircolite\Detections-High.txt"
                                }

                                # Medium
                                $Medium = Get-Content "$OUTPUT_FOLDER\EventLogs\Zircolite\Zircolite.txt" | Select-String -Pattern "    - " | Select-String -Pattern "\[medium\]" | ForEach-Object{($_ -replace "    - ","        ")} | Sort-Object
                                $MediumAlerts = ($Medium | Measure-Object).Count
                                if ($MediumAlerts -gt 0)
                                { 
                                    $Medium.Trim() | Out-File "$OUTPUT_FOLDER\EventLogs\Zircolite\Detections-Medium.txt"
                                }

                                # Low
                                $Low = Get-Content "$OUTPUT_FOLDER\EventLogs\Zircolite\Zircolite.txt" | Select-String -Pattern "    - " | Select-String -Pattern "\[low\]" | ForEach-Object{($_ -replace "    - ","        ")} | Sort-Object
                                $LowAlerts = ($Low | Measure-Object).Count
                                if ($LowAlerts -gt 0)
                                { 
                                    $Low.Trim() | Out-File "$OUTPUT_FOLDER\EventLogs\Zircolite\Detections-Low.txt"
                                }
                            
                                # Informational
                                $Informational = Get-Content "$OUTPUT_FOLDER\EventLogs\Zircolite\Zircolite.txt" | Select-String -Pattern "    - " | Select-String -Pattern "\[informational\]" | ForEach-Object{($_ -replace "    - ","        ")} | Sort-Object
                                $InformationalAlerts = ($Informational | Measure-Object).Count
                                if ($InformationalAlerts -gt 0)
                                { 
                                    $Informational.Trim() | Out-File "$OUTPUT_FOLDER\EventLogs\Zircolite\Detections-Informational.txt"
                                }
                
                                # Unknown
                                $Unknown = Get-Content "$OUTPUT_FOLDER\EventLogs\Zircolite\Zircolite.txt" | Select-String -Pattern "    - " | Select-String -Pattern "\[unknown\]" | ForEach-Object{($_ -replace "    - ","        ")} | Sort-Object
                                $UnknownAlerts = ($Unknown | Measure-Object).Count
                                if ($UnknownAlerts -gt 0)
                                { 
                                    $Unknown.Trim() | Out-File "$OUTPUT_FOLDER\EventLogs\Zircolite\Detections-Unknown.txt"
                                }

                                # Stats (Alerts by Sigma Rules Level)
                                Write-Output "$Rules Alerts ($Events events)" | Out-File "$OUTPUT_FOLDER\EventLogs\Zircolite\Stats.txt"
                                Write-Output "" | Out-File "$OUTPUT_FOLDER\EventLogs\Zircolite\Stats.txt" -Append
                                Write-Output "Alerts by Sigma Rule Level" | Out-File "$OUTPUT_FOLDER\EventLogs\Zircolite\Stats.txt" -Append
                                Write-Output "Critical: $CriticalAlerts" | Out-File "$OUTPUT_FOLDER\EventLogs\Zircolite\Stats.txt" -Append
                                Write-Output "High:     $HighAlerts" | Out-File "$OUTPUT_FOLDER\EventLogs\Zircolite\Stats.txt" -Append
                                Write-Output "Medium:   $MediumAlerts" | Out-File "$OUTPUT_FOLDER\EventLogs\Zircolite\Stats.txt" -Append
                                Write-Output "Low:      $LowAlerts" | Out-File "$OUTPUT_FOLDER\EventLogs\Zircolite\Stats.txt" -Append
                                Write-Output "Info:     $InformationalAlerts" | Out-File "$OUTPUT_FOLDER\EventLogs\Zircolite\Stats.txt" -Append
                                Write-Output "Unknown:  $UnknownAlerts" | Out-File "$OUTPUT_FOLDER\EventLogs\Zircolite\Stats.txt" -Append
                
                                $Critical | Write-Host -ForegroundColor Red
                                $High | Write-Host -ForegroundColor Yellow
                                $Medium | Write-Host -ForegroundColor DarkCyan
                                $Low | Write-Host -ForegroundColor DarkGreen
                                $Informational | Write-Host -ForegroundColor Gray
                            }
                        }
                        else
                        {
                            Write-Host "[Info]  0 Detections found"
                        }
                    }
                }
            }
        }
        else
        {
            Write-Host "[Error] zircolite.exe NOT found." -ForegroundColor Red
        }

        # Results
        if (Test-Path "$OUTPUT_FOLDER\EventLogs\Zircolite\JSON\detected_events.json")
        {
            if((Get-Item "$OUTPUT_FOLDER\EventLogs\Zircolite\JSON\detected_events.json").length -gt 1kb)
            {
                # Import JSON Data
                $Data = Get-Content "$OUTPUT_FOLDER\EventLogs\Zircolite\JSON\detected_events.json" | ConvertFrom-Json

                # Alerts by Sigma Rules Level
                $Events = ($Data | Select-Object count | Measure-Object Count -Sum).Sum
                $Critical = ($Data | Where-Object { $_.rule_level -eq "critical" } | Select-Object count | Measure-Object Count -Sum).Sum
                $High = ($Data | Where-Object { $_.rule_level -eq "high" } | Select-Object count | Measure-Object Count -Sum).Sum
                $Medium = ($Data | Where-Object { $_.rule_level -eq "medium" } | Select-Object count | Measure-Object Count -Sum).Sum
                $Low = ($Data | Where-Object { $_.rule_level -eq "low" } | Select-Object count | Measure-Object Count -Sum).Sum
                $Informational = ($Data | Where-Object { $_.rule_level -eq "informational" } | Select-Object count | Measure-Object Count -Sum).Sum
                $Unknown = ($Data | Where-Object { $_.rule_level -eq "unknown" } | Select-Object count | Measure-Object Count -Sum).Sum

                # Array
                $Array = @()

                # Critical
                if ($Critical)
                {
                    $Array += @{Level = "Critical"; Description = "Highly relevant event that indicates an incident. Critical events should be reviewed immediately."; Count = "$Critical"}
                }
                else
                {
                    $Array += @{Level = "Critical"; Description = "Highly relevant event that indicates an incident. Critical events should be reviewed immediately."; Count = "0"}
                }

                # High
                if ($High)
                {
                    $Array += @{Level = "High"; Description = "Relevant event that should trigger an internal alert and requires a prompt review."; Count = "$High"}
                }
                else
                {
                    $Array += @{Level = "High"; Description = "Relevant event that should trigger an internal alert and requires a prompt review."; Count = "0"}
                }

                # Medium
                if ($Medium)
                {
                    $Array += @{Level = "Medium"; Description = "Relevant event that should be reviewed manually on a more frequent basis."; Count = "$Medium"}
                }
                else
                {
                    $Array += @{Level = "Medium"; Description = "Relevant event that should be reviewed manually on a more frequent basis."; Count = "0"}
                }

                # Low
                if ($Low)
                {
                    $Array += @{Level = "Low"; Description = "Notable event but rarely an incident. Low rated events can be relevant in high numbers or combination with others. Immediate reaction shouldn't be necessary, but a regular review is recommended."; Count = "$Low"}
                }
                else
                {
                    $Array += @{Level = "Low"; Description = "Notable event but rarely an incident. Low rated events can be relevant in high numbers or combination with others. Immediate reaction shouldn't be necessary, but a regular review is recommended."; Count = "0"}
                }

                # Informational
                if ($Informational)
                {
                    $Array += @{Level = "Informational"; Description = "Rule is intended for enrichment of events, e.g. by tagging them. No case or alerting should be triggered by such rules because it is expected that a huge amount of events will match these rules."; Count = "$Informational"}
                }
                else
                {
                    $Array += @{Level = "Informational"; Description = "Rule is intended for enrichment of events, e.g. by tagging them. No case or alerting should be triggered by such rules because it is expected that a huge amount of events will match these rules."; Count = "0"}
                }

                # Unknown
                if ($Unknown)
                {
                    $Array += @{Level = "Unknown"; Description = "Unknown"; Count = "$Unknown"}
                }
                else
                {
                    $Array += @{Level = "Unknown"; Description = "Unknown"; Count = "0"}
                }

                # CSV
                $Array | ForEach-Object { New-Object PSObject -Property $_ } |  Export-Csv "$OUTPUT_FOLDER\EventLogs\Zircolite\Alerts-by-Sigma-Rule-Level.csv" -NoTypeInformation

                # XLSX
                if (Get-Module -ListAvailable -Name ImportExcel)
                {
                    if (Test-Path "$OUTPUT_FOLDER\EventLogs\Zircolite\Alerts-by-Sigma-Rule-Level.csv")
                    {
                        if([int](& $xsv count "$OUTPUT_FOLDER\EventLogs\Zircolite\Alerts-by-Sigma-Rule-Level.csv") -gt 0)
                        {
                            $IMPORT = Import-Csv "$OUTPUT_FOLDER\EventLogs\Zircolite\Alerts-by-Sigma-Rule-Level.csv" -Delimiter "," | Sort-Object { $_.FileKeyLastWriteTimestamp -as [datetime] } -Descending
                            $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\EventLogs\Zircolite\Alerts-by-Sigma-Rule-Level.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "SIGMA Rule Level" -CellStyleSB {
                            param($WorkSheet)
                            # BackgroundColor and FontColor for specific cells of TopRow
                            $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                            Set-Format -Address $WorkSheet.Cells["A1:C1"] -BackgroundColor $BackgroundColor -FontColor White
                            # HorizontalAlignment "Center" of columns A and C
                            $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                            $WorkSheet.Cells["C:C"].Style.HorizontalAlignment="Center"
                            }
                        }
                    }
                }

                # Alerts by MITRE ATT&CK Tactics
                # https://attack.mitre.org/tactics/enterprise/

                # Array
                $Array = @()

                # Reconnaissance - The adversary is trying to gather information they can use to plan future operations [TA0043]
                $Reconnaissance = ($Data | Where-Object { $_.tags -like "attack.reconnaissance" } | Select-Object count | Measure-Object Count -Sum).Sum
                if ($Reconnaissance)
                {
                    $Array += @{ID = "TA0043"; Name = "Reconnaissance"; Description = "The adversary is trying to gather information they can use to plan future operations."; Count = "$Reconnaissance"}
                }
                else
                {
                    $Array += @{ID = "TA0043"; Name = "Reconnaissance"; Description = "The adversary is trying to gather information they can use to plan future operations."; Count = "0"}
                }

                # Resource Development - The adversary is trying to establish resources they can use to support operations [TA0042]
                $ResourceDevelopment = ($Data | Where-Object { $_.tags -like "attack.resource_development" } | Select-Object count | Measure-Object Count -Sum).Sum
                if ($ResourceDevelopment)
                {
                    $Array += @{ID = "TA0042"; Name = "Resource Development"; Description = "The adversary is trying to establish resources they can use to support operations."; Count = "$ResourceDevelopment"}
                }
                else
                {
                    $Array += @{ID = "TA0042"; Name = "Resource Development"; Description = "The adversary is trying to establish resources they can use to support operations."; Count = "0"}
                }

                # Initial Access - The adversary is trying to get into your network [TA0001]
                $InitialAccess = ($Data | Where-Object { $_.tags -like "attack.initial_access" } | Select-Object count | Measure-Object Count -Sum).Sum
                if ($InitialAccess)
                {
                    $Array += @{ID = "TA0001"; Name = "Initial Access"; Description = "The adversary is trying to get into your network."; Count = "$InitialAccess"}
                }
                else
                {
                    $Array += @{ID = "TA0001"; Name = "Initial Access"; Description = "The adversary is trying to get into your network."; Count = "0"}
                }

                # Execution - The adversary is trying to run malicious code [TA0002]
                $Execution = ($Data | Where-Object { $_.tags -like "attack.execution" } | Select-Object count | Measure-Object Count -Sum).Sum
                if ($Execution)
                {
                    $Array += @{ID = "TA0002"; Name = "Execution"; Description = "The adversary is trying to run malicious code."; Count = "$Execution"}
                }
                else
                {
                    $Array += @{ID = "TA0002"; Name = "Execution"; Description = "The adversary is trying to run malicious code."; Count = "0"}
                }

                # Persistence - The adversary is trying to maintain their foothold [TA0003]
                $Persistence = ($Data | Where-Object { $_.tags -like "attack.persistence" } | Select-Object count | Measure-Object Count -Sum).Sum
                if ($Persistence)
                {
                    $Array += @{ID = "TA0003"; Name = "Persistence"; Description = "The adversary is trying to maintain their foothold."; Count = "$Persistence"}
                }
                else
                {
                    $Array += @{ID = "TA0003"; Name = "Persistence"; Description = "The adversary is trying to maintain their foothold."; Count = "0"}
                }

                # Privilege Escalation - The adversary is trying to gain higher-level permissions [TA0004]
                $PrivilegeEscalation = ($Data | Where-Object { $_.tags -like "attack.privilege_escalation" } | Select-Object count | Measure-Object Count -Sum).Sum
                if ($PrivilegeEscalation)
                {
                    $Array += @{ID = "TA0004"; Name = "Privilege Escalation"; Description = "The adversary is trying to gain higher-level permissions."; Count = "$PrivilegeEscalation"}
                }
                else
                {
                    $Array += @{ID = "TA0004"; Name = "Privilege Escalation"; Description = "The adversary is trying to gain higher-level permissions."; Count = "0"}
                }

                # Defense Evasion - The adversary is trying to avoid being detected [TA0005]
                $DefenseEvasion = ($Data | Where-Object { $_.tags -like "attack.defense_evasion" } | Select-Object count | Measure-Object Count -Sum).Sum
                if ($DefenseEvasion)
                {
                    $Array += @{ID = "TA0005"; Name = "Defense Evasion"; Description = "The adversary is trying to avoid being detected."; Count = "$DefenseEvasion"}
                }
                else
                {
                    $Array += @{ID = "TA0005"; Name = "Defense Evasion"; Description = "The adversary is trying to avoid being detected."; Count = "0"}
                }

                # Credential Access - The adversary is trying to steal account names and passwords [TA0006]
                $CredentialAccess = ($Data | Where-Object { $_.tags -like "attack.credential_access" } | Select-Object count | Measure-Object Count -Sum).Sum
                if ($CredentialAccess)
                {
                    $Array += @{ID = "TA0006"; Name = "Credential Access"; Description = "The adversary is trying to steal account names and passwords."; Count = "$CredentialAccess"}
                }
                else
                {
                    $Array += @{ID = "TA0006"; Name = "Credential Access"; Description = "The adversary is trying to steal account names and passwords."; Count = "0"}
                }

                # Discovery - The adversary is trying to figure out your environment [TA0007]
                $Discovery = ($Data | Where-Object { $_.tags -like "attack.discovery" } | Select-Object count | Measure-Object Count -Sum).Sum
                if ($Discovery)
                {
                    $Array += @{ID = "TA0007"; Name = "Discovery"; Description = "The adversary is trying to figure out your environment."; Count = "$Discovery"}
                }
                else
                {
                    $Array += @{ID = "TA0007"; Name = "Discovery"; Description = "The adversary is trying to figure out your environment."; Count = "0"}
                }

                # Lateral Movement - The adversary is trying to move through your environment [TA0008]
                $LateralMovement = ($Data | Where-Object { $_.tags -like "attack.lateral_movement" } | Select-Object count | Measure-Object Count -Sum).Sum
                if ($LateralMovement)
                {
                    $Array += @{ID = "TA0008"; Name = "Lateral Movement"; Description = "The adversary is trying to move through your environment."; Count = "$LateralMovement"}
                }
                else
                {
                    $Array += @{ID = "TA0008"; Name = "Lateral Movement"; Description = "The adversary is trying to move through your environment."; Count = "0"}
                }

                # Collection - The adversary is trying to gather data of interest to their goal [TA0009]
                $Collection = ($Data | Where-Object { $_.tags -like "attack.collection" } | Select-Object count | Measure-Object Count -Sum).Sum
                if ($Collection)
                {
                    $Array += @{ID = "TA0009"; Name = "Collection"; Description = "The adversary is trying to gather data of interest to their goal."; Count = "$Collection"}
                }
                else
                {
                    $Array += @{ID = "TA0009"; Name = "Collection"; Description = "The adversary is trying to gather data of interest to their goal."; Count = "0"}
                }

                # Command and Control - The adversary is trying to communicate with compromised systems to control them [TA0011]
                $CommandAndControl = ($Data | Where-Object { $_.tags -like "attack.commandandcontrol" } | Select-Object count | Measure-Object Count -Sum).Sum
                if ($CommandAndControl)
                {
                    $Array += @{ID = "TA0011"; Name = "Command and Control"; Description = "The adversary is trying to communicate with compromised systems to control them."; Count = "$CommandAndControl"}
                }
                else
                {
                    $Array += @{ID = "TA0011"; Name = "Command and Control"; Description = "The adversary is trying to communicate with compromised systems to control them."; Count = "0"}
                }

                # Exfiltration - The adversary is trying to steal data [TA0010]
                $Exfiltration = ($Data | Where-Object { $_.tags -like "attack.exfiltration" } | Select-Object count | Measure-Object Count -Sum).Sum
                if ($Exfiltration)
                {
                    $Array += @{ID = "TA0010"; Name = "Exfiltration"; Description = "The adversary is trying to steal data."; Count = "$Exfiltration"}
                }
                else
                {
                    $Array += @{ID = "TA0010"; Name = "Exfiltration"; Description = "The adversary is trying to steal data."; Count = "0"}
                }

                # Impact - The adversary is trying to manipulate, interrupt, or destroy your systems and data [TA0040]
                $Impact = ($Data | Where-Object { $_.tags -like "attack.impact" } | Select-Object count | Measure-Object Count -Sum).Sum
                if ($Impact)
                {
                    $Array += @{ID = "TA0040"; Name = "Impact"; Description = "The adversary is trying to manipulate, interrupt, or destroy your systems and data."; Count = "$Impact"}
                }
                else
                {
                    $Array += @{ID = "TA0040"; Name = "Impact"; Description = "The adversary is trying to manipulate, interrupt, or destroy your systems and data."; Count = "0"}
                }

                # Uncategorized
                $Uncategorized = ($Data | Where-Object { $_.tags -like "attack.uncategorized" } | Select-Object count | Measure-Object Count -Sum).Sum
                if ($Uncategorized)
                {
                    $Array += @{ID = "Uncategorized"; Name = "Uncategorized"; Description = "Uncategorized"; Count = "$Uncategorized"}
                }
                else
                {
                    $Array += @{ID = "Uncategorized"; Name = "Uncategorized"; Description = "Uncategorized"; Count = "0"}
                }

                # CSV
                $Array | ForEach-Object { New-Object PSObject -Property $_ } |  Export-Csv "$OUTPUT_FOLDER\EventLogs\Zircolite\Alerts-by-Tactics.csv" -NoTypeInformation

                # XLSX
                if (Get-Module -ListAvailable -Name ImportExcel)
                {
                    if (Test-Path "$OUTPUT_FOLDER\EventLogs\Zircolite\Alerts-by-Tactics.csv")
                    {
                        if([int](& $xsv count "$OUTPUT_FOLDER\EventLogs\Zircolite\Alerts-by-Tactics.csv") -gt 0)
                        {
                            $IMPORT = Import-Csv "$OUTPUT_FOLDER\EventLogs\Zircolite\Alerts-by-Tactics.csv" -Delimiter "," | Sort-Object { $_.FileKeyLastWriteTimestamp -as [datetime] } -Descending
                            $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\EventLogs\Zircolite\Alerts-by-Tactics.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "MITRE ATT&CK Tactics" -CellStyleSB {
                            param($WorkSheet)
                            # BackgroundColor and FontColor for specific cells of TopRow
                            $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                            Set-Format -Address $WorkSheet.Cells["A1:D1"] -BackgroundColor $BackgroundColor -FontColor White
                            # HorizontalAlignment "Center" of column D
                            $WorkSheet.Cells["D:D"].Style.HorizontalAlignment="Center"
                            }
                        }
                    }
                }

                # Alerts by Channel

                # CSV
                ($Data | Select-Object matches).matches | Group-Object Channel | Select-Object Name, Count | Sort-Object Name | Export-Csv "$OUTPUT_FOLDER\EventLogs\Zircolite\Alerts-by-Channel.csv" -NoTypeInformation

                # XLSX
                if (Get-Module -ListAvailable -Name ImportExcel)
                {
                    if (Test-Path "$OUTPUT_FOLDER\EventLogs\Zircolite\Alerts-by-Channel.csv")
                    {
                        if([int](& $xsv count "$OUTPUT_FOLDER\EventLogs\Zircolite\Alerts-by-Channel.csv") -gt 0)
                        {
                            $IMPORT = Import-Csv "$OUTPUT_FOLDER\EventLogs\Zircolite\Alerts-by-Channel.csv" -Delimiter ","
                            $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\EventLogs\Zircolite\Alerts-by-Channel.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Alerts by Channel" -CellStyleSB {
                            param($WorkSheet)
                            # BackgroundColor and FontColor for specific cells of TopRow
                            $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                            Set-Format -Address $WorkSheet.Cells["A1:B1"] -BackgroundColor $BackgroundColor -FontColor White
                            # HorizontalAlignment "Center" of column B
                            $WorkSheet.Cells["B:B"].Style.HorizontalAlignment="Center"
                            }
                        }
                    }
                }
            }

        $EndTime_Zircolite = (Get-Date)
        $Time_Zircolite = ($EndTime_Zircolite-$StartTime_Zircolite)
        ('Zircolite Processing duration: {0} h {1} min {2} sec' -f $Time_Zircolite.Hours, $Time_Zircolite.Minutes, $Time_Zircolite.Seconds) >> "$OUTPUT_FOLDER\Stats.txt"

        }

        }

        Invoke-Zircolite

#############################################################################################################################################################################################

        Function Get-EventLogOverview {

        # Event Log Overview
        if (Test-Path "$OUTPUT_FOLDER\EventLogs\JSONL\*.json")
        {
            Write-Output "[Info]  Parsing Event Record Information from JSON Files ..."
            $EventLogs = (Get-ChildItem -Path "$OUTPUT_FOLDER\EventLogs\JSONL" -Filter "*.json").FullName

            $StartTime_EventLogOverview = (Get-Date)

            $EventArray = @()
            ForEach($EventLog in $EventLogs)
            {
                $LogName = $EventLog | ForEach-Object{($_ -split "\\")[-1]} | ForEach-Object{($_ -split "\.evtx-")[0]}
                [int64]$LogSize = (Get-Item -Path $EventLog).Length
                $Row = New-Object PSObject
                $Row | Add-Member -Name Name -MemberType NoteProperty -Value ("$LogName" + ".evtx")
                $Row | Add-Member -Name RecordCount -MemberType NoteProperty -Value ((& $jq -c '.Event.System.EventID' $EventLog | Measure-Object).Count)
                if ($LogSize -ne "0")
                {
                    $Row | Add-Member -Name "Oldest [UTC]" -MemberType NoteProperty -Value (& $jq -r '.Event.System.TimeCreated | .[]?.SystemTime' $EventLog | Sort-Object | Select-Object -First 1 | ForEach-Object{($_ -replace "T"," ")} | ForEach-Object{($_ -split "\.")[0]})
                    $Row | Add-Member -Name "Newest [UTC]" -MemberType NoteProperty -Value (& $jq -r '.Event.System.TimeCreated | .[]?.SystemTime' $EventLog | Sort-Object | Select-Object -Last 1 | ForEach-Object{($_ -replace "T"," ")} | ForEach-Object{($_ -split "\.")[0]})
                    $Row | Add-Member -Name Bytes -MemberType NoteProperty -Value ((Get-Item -Path $EventLog).Length)
                    $Row | Add-Member -Name FileSize -MemberType NoteProperty -Value (Get-FileSize (Get-Item -Path $EventLog).Length)
                }
                else
                {
                    $Row | Add-Member -Name Bytes -MemberType NoteProperty -Value ("0")
                    $Row | Add-Member -Name FileSize -MemberType NoteProperty -Value ("0")
                }
                $Row | Add-Member -Name FilePath -MemberType NoteProperty -Value ($EventLog)
                $EventArray  += $Row
            }

            # EventLogOverview.csv
            $EventArray | Export-Csv "$OUTPUT_FOLDER\EventLogs\EventLogOverview.csv" -NoTypeInformation

            # EventLogOverview.xlsx
            if (Get-Module -ListAvailable -Name ImportExcel) 
            {
                if (Test-Path "$OUTPUT_FOLDER\EventLogs\EventLogOverview.csv")
                {
                    if([int](& $xsv count "$OUTPUT_FOLDER\EventLogs\EventLogOverview.csv") -gt 0)
                    {
                        $IMPORT = Import-Csv "$OUTPUT_FOLDER\EventLogs\EventLogOverview.csv" -Delimiter ","
                        $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\EventLogs\EventLogOverview.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "EventLogOverview" -CellStyleSB {
                        param($WorkSheet)
                        # BackgroundColor and FontColor for specific cells of TopRow
                        $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                        Set-Format -Address $WorkSheet.Cells["A1:G1"] -BackgroundColor $BackgroundColor -FontColor White
                        # HorizontalAlignment "Center" of columns B-D
                        $WorkSheet.Cells["B:D"].Style.HorizontalAlignment="Center"
                        # HorizontalAlignment "Right" of columns E-F
                        $WorkSheet.Cells["E:F"].Style.HorizontalAlignment="Right"
                        # HorizontalAlignment "Center" of header of columns E-F
                        $WorkSheet.Cells["E1:F1"].Style.HorizontalAlignment="Center"
                        }
                    }
                }
            }

        $EndTime_EventLogOverview = (Get-Date)
        $Time_EventLogOverview = ($EndTime_EventLogOverview-$StartTime_EventLogOverview)
        ('EventLogOverview duration:     {0} h {1} min {2} sec' -f $Time_EventLogOverview.Hours, $Time_EventLogOverview.Minutes, $Time_EventLogOverview.Seconds) >> "$OUTPUT_FOLDER\Stats.txt"

        }

        }

        Get-EventLogOverview

#############################################################################################################################################################################################

        Function Get-Timesketch {

        # Timesketch
        if (Test-Path "$($Zircolite)")
        {
            Write-Output "[Info]  Creating Timesketch output ..."
            New-Item "$OUTPUT_FOLDER\EventLogs\Zircolite\Timesketch" -ItemType Directory -Force | Out-Null

            $script:MyLocation = $pwd
            Set-Location "$SCRIPT_DIR\Tools\Zircolite"

            $StartTime_Timesketch = (Get-Date)

            # Zircolite
            $Ruleset = "rules\rules_windows_generic_full.json"
            $Template = "templates\exportForTimesketch.tmpl"
            $TemplateOutput = "$OUTPUT_FOLDER\EventLogs\Zircolite\Timesketch\Timesketch_MemProcFS-Analyzer.csv"
            $OutFile = "$OUTPUT_FOLDER\EventLogs\Zircolite\Timesketch\detected_events.json"
            $LogFile = "$OUTPUT_FOLDER\EventLogs\Zircolite\Timesketch\zircolite.log"

            # Check if JSONL Files already exist
            if (Test-Path "$OUTPUT_FOLDER\EventLogs\JSONL\*.json")
            {
                # JSONL
                $ScanPath = "$OUTPUT_FOLDER\EventLogs\JSONL"
                & $Zircolite --evtx $ScanPath --ruleset $Ruleset --jsononly --template $Template --templateOutput $TemplateOutput --outfile $OutFile --logfile $LogFile 2>&1 | Out-File "$OUTPUT_FOLDER\EventLogs\Zircolite\Timesketch\Zircolite-draft.txt"
            }
            else
            {
                # EVTX
                $ScanPath = "$OUTPUT_FOLDER\EventLogs\EventLogs"
                & $Zircolite --evtx $ScanPath --ruleset $Ruleset --noexternal --template $Template --templateOutput $TemplateOutput --outfile $OutFile --logfile $LogFile 2>&1 | Out-File "$OUTPUT_FOLDER\EventLogs\Zircolite\Timesketch\Zircolite-draft.txt"
            }
            
            Set-Location "$MyLocation"

            # zircolite.log
            if (Test-Path "$OUTPUT_FOLDER\EventLogs\Zircolite\Timesketch\zircolite.log")
            {
                Remove-Item -Path "$OUTPUT_FOLDER\EventLogs\Zircolite\Timesketch\zircolite.log" -Force
            }

            # Remove ANSI Control Characters
            if (Test-Path "$OUTPUT_FOLDER\EventLogs\Zircolite\Timesketch\Zircolite-draft.txt")
            {
                Get-Content "$OUTPUT_FOLDER\EventLogs\Zircolite\Timesketch\Zircolite-draft.txt" | ForEach-Object { $_ -replace "\x1b\[[0-9;]*m" } | Out-File "$OUTPUT_FOLDER\EventLogs\Zircolite\Timesketch\Zircolite.txt"
                Remove-Item "$OUTPUT_FOLDER\EventLogs\Zircolite\Timesketch\Zircolite-draft.txt"
            }

            # Cleaning up
            if (Test-Path "$OUTPUT_FOLDER\EventLogs\Zircolite\Timesketch\Zircolite.txt")
            {
                $Filter = @("^zircolite_win10\.exe","MemProcFS-Analyzer-v0.*\.ps1","^\+","\+ CategoryInfo          : NotSpecified:","\+ FullyQualifiedErrorId : NativeCommandError","%\|")
                $Clean = Get-Content "$OUTPUT_FOLDER\EventLogs\Zircolite\Timesketch\Zircolite.txt" | Select-String -Pattern $Filter -NotMatch 
                $Clean | Set-Content "$OUTPUT_FOLDER\EventLogs\Zircolite\Timesketch\Zircolite.txt"
            }

            # Remove empty lines and add line breaks where needed
            if (Test-Path "$OUTPUT_FOLDER\EventLogs\Zircolite\Timesketch\Zircolite.txt")
            {
                $Clean = Get-Content "$OUTPUT_FOLDER\EventLogs\Zircolite\Timesketch\Zircolite.txt" | Where-Object {$_.Trim()} | ForEach-Object {($_ -replace "Finished in", "`nFinished in")} | ForEach-Object {($_ -replace "Sysmon Linux =-", "Sysmon Linux =-`n")}
                @("") + ($Clean) | Set-Content "$OUTPUT_FOLDER\EventLogs\Zircolite\Timesketch\Zircolite.txt"
            }

            # File Size (CSV)
            if (Test-Path "$OUTPUT_FOLDER\EventLogs\Zircolite\Timesketch\Timesketch_MemProcFS-Analyzer.csv")
            {
                $FileSize = Get-FileSize((Get-Item "$OUTPUT_FOLDER\EventLogs\Zircolite\Timesketch\Timesketch_MemProcFS-Analyzer.csv").Length)
                Write-Output "[Info]  File Size (CSV): $FileSize"
            }

            $EndTime_Timesketch = (Get-Date)
            $Time_Timesketch = ($EndTime_Timesketch-$StartTime_Timesketch)
            ('Timesketch Output duration:    {0} h {1} min {2} sec' -f $Time_Timesketch.Hours, $Time_Timesketch.Minutes, $Time_Timesketch.Seconds) >> "$OUTPUT_FOLDER\Stats.txt"
        }
        else
        {
            Write-Host "[Error] zircolite_win10.exe NOT found." -ForegroundColor Red
        }

        }

        #Get-Timesketch

#############################################################################################################################################################################################
        
        Function Get-RegistryHives {

        # Registry Hives
        if (Test-Path "$DriveLetter\registry\hive_files\*.reghive") 
        {
            Write-Output "[Info]  Collecting Registry Hives ... "
            New-Item "$OUTPUT_FOLDER\Registry\Registry" -ItemType Directory -Force 2>&1 | Out-Null
            Get-ChildItem "$DriveLetter\registry\hive_files\*.reghive" -Exclude "*ActivationStoredat*","*settingsdat*" | Foreach-Object FullName | Out-File "$OUTPUT_FOLDER\Registry\Hives.txt"
            Copy-Item "$DriveLetter\registry\hive_files\*.reghive" -Exclude "*ActivationStoredat*","*settingsdat*" "$OUTPUT_FOLDER\Registry\Registry" 2>&1 | Out-Null
        }

        # Count Registry Hives
        $Count = (Get-ChildItem -Path "$OUTPUT_FOLDER\Registry\Registry" | Measure-Object).Count
        $InputSize = Get-FileSize((Get-ChildItem -Path "$OUTPUT_FOLDER\Registry\Registry" | Measure-Object Length -Sum).Sum)
        Write-Output "[Info]  $Count Registry Hives ($InputSize) found"

        }

        Get-RegistryHives

#############################################################################################################################################################################################
        
        Function Get-Amcache {

        # AmcacheParser
        if (Test-Path "$OUTPUT_FOLDER\Registry\Registry\*Amcache*.reghive") 
        {
            if (Test-Path "$($AmcacheParser)")
            {
                Write-Output "[Info]  Analyzing Amcache Hive ... "

                # Collecting Amcache.hve
                New-Item "$OUTPUT_FOLDER\Amcache\Amcache" -ItemType Directory -Force 2>&1 | Out-Null
                Copy-Item "$DriveLetter\registry\hive_files\0x*Amcachehve-*.reghive" "$OUTPUT_FOLDER\Amcache\Amcache\Amcache.hve"
                
                # CSV
                New-Item "$OUTPUT_FOLDER\Amcache\CSV" -ItemType Directory -Force | Out-Null
                $AmcacheHive = "$OUTPUT_FOLDER\Amcache\Amcache\Amcache.hve"
                & $AmcacheParser -f "$AmcacheHive" -i --csv "$OUTPUT_FOLDER\Amcache\CSV" --csvf AmcacheParser.csv > "$OUTPUT_FOLDER\Amcache\AmcacheParser.log" 2> $null

                # Stats
                if (Test-Path "$OUTPUT_FOLDER\Amcache\AmcacheParser.log")
                {
                    $Total = Get-Content "$OUTPUT_FOLDER\Amcache\AmcacheParser.log" | Select-String -Pattern "unassociated file entries"
                    if ($Total) 
                    { 
                        Write-Output "[Info]  $Total"
                    }
                    else
                    {
                        Write-Output "[Info]  Amcache Hive seems to be partially corrupt."
                    }
                }

                # XLSX
                # Note: The output of Windows 10 and Win 7 looks different --> optimized for Windows 10 only
                if (Get-Module -ListAvailable -Name ImportExcel)
                {
                    # AssociatedFileEntries
                    if (Test-Path "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_AssociatedFileEntries.csv")
                    {
                        if([int](& $xsv count "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_AssociatedFileEntries.csv") -gt 0)
                        {
                            New-Item "$OUTPUT_FOLDER\Amcache\XLSX" -ItemType Directory -Force | Out-Null
                            $IMPORT = Import-Csv "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_AssociatedFileEntries.csv" -Delimiter "," | Sort-Object { $_.FileKeyLastWriteTimestamp -as [datetime] } -Descending
                            $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Amcache\XLSX\AmcacheParser_AssociatedFileEntries.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "AssociatedFileEntries" -CellStyleSB {
                            param($WorkSheet)
                            # BackgroundColor and FontColor for specific cells of TopRow
                            $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                            Set-Format -Address $WorkSheet.Cells["A1:U1"] -BackgroundColor $BackgroundColor -FontColor White
                            # HorizontalAlignment "Center" of columns A-E and G-U
                            $WorkSheet.Cells["A:E"].Style.HorizontalAlignment="Center"
                            $WorkSheet.Cells["G:U"].Style.HorizontalAlignment="Center"
                            # HorizontalAlignment "Center" of header of column F
                            $WorkSheet.Cells["F1:F1"].Style.HorizontalAlignment="Center"
                            }
                        }
                    }

                    # DeviceContainers
                    if (Test-Path "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_DeviceContainers.csv")
                    {
                        if([int](& $xsv count "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_DeviceContainers.csv") -gt 0)
                        {
                            New-Item "$OUTPUT_FOLDER\Amcache\XLSX" -ItemType Directory -Force | Out-Null
                            $IMPORT = Import-Csv "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_DeviceContainers.csv" -Delimiter ","
                            $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Amcache\XLSX\AmcacheParser_DeviceContainers.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "DeviceContainers" -CellStyleSB {
                            param($WorkSheet)
                            # BackgroundColor and FontColor for specific cells of TopRow
                            $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                            Set-Format -Address $WorkSheet.Cells["A1:Q1"] -BackgroundColor $BackgroundColor -FontColor White
                            # HorizontalAlignment "Center" of columns B-Q
                            $WorkSheet.Cells["B:Q"].Style.HorizontalAlignment="Center"
                            }
                        }
                    }

                    # DevicePnps
                    if (Test-Path "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_DevicePnps.csv")
                    {
                        if([int](& $xsv count "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_DevicePnps.csv") -gt 0)
                        {
                            New-Item "$OUTPUT_FOLDER\Amcache\XLSX" -ItemType Directory -Force | Out-Null
                            $IMPORT = Import-Csv "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_DevicePnps.csv" -Delimiter ","
                            $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Amcache\XLSX\AmcacheParser_DevicePnps.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "DevicePnps" -CellStyleSB {
                            param($WorkSheet)
                            # BackgroundColor and FontColor for specific cells of TopRow
                            $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                            Set-Format -Address $WorkSheet.Cells["A1:Y1"] -BackgroundColor $BackgroundColor -FontColor White
                            # HorizontalAlignment "Center" of columns B-E and G-Y
                            $WorkSheet.Cells["B:E"].Style.HorizontalAlignment="Center"
                            $WorkSheet.Cells["G:Y"].Style.HorizontalAlignment="Center"
                            }
                        }
                    }

                    # DriveBinaries
                    if (Test-Path "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_DriveBinaries.csv")
                    {
                        if([int](& $xsv count "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_DriveBinaries.csv") -gt 0)
                        {
                            New-Item "$OUTPUT_FOLDER\Amcache\XLSX" -ItemType Directory -Force | Out-Null
                            $IMPORT = Import-Csv "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_DriveBinaries.csv" -Delimiter ","
                            $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Amcache\XLSX\AmcacheParser_DriveBinaries.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "DriveBinaries" -CellStyleSB {
                            param($WorkSheet)
                            # BackgroundColor and FontColor for specific cells of TopRow
                            $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                            Set-Format -Address $WorkSheet.Cells["A1:T1"] -BackgroundColor $BackgroundColor -FontColor White
                            # HorizontalAlignment "Center" of columns B-T
                            $WorkSheet.Cells["B:T"].Style.HorizontalAlignment="Center"
                            }
                        }
                    }

                    # DriverPackages
                    if (Test-Path "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_DriverPackages.csv")
                    {
                        if([int](& $xsv count "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_DriverPackages.csv") -gt 0)
                        {
                            New-Item "$OUTPUT_FOLDER\Amcache\XLSX" -ItemType Directory -Force | Out-Null
                            $IMPORT = Import-Csv "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_DriverPackages.csv" -Delimiter ","
                            $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Amcache\XLSX\AmcacheParser_DriverPackages.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "DriverPackages" -CellStyleSB {
                            param($WorkSheet)
                            # BackgroundColor and FontColor for specific cells of TopRow
                            $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                            Set-Format -Address $WorkSheet.Cells["A1:L1"] -BackgroundColor $BackgroundColor -FontColor White
                            # HorizontalAlignment "Center" of columns B-D and -L
                            $WorkSheet.Cells["B:D"].Style.HorizontalAlignment="Center"
                            $WorkSheet.Cells["F:L"].Style.HorizontalAlignment="Center"
                            # HorizontalAlignment "Center" of header of column E
                            $WorkSheet.Cells["E1:E1"].Style.HorizontalAlignment="Center"
                            }
                        }
                    }

                    # ProgramEntries
                    if (Test-Path "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_ProgramEntries.csv")
                    {
                        if([int](& $xsv count "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_ProgramEntries.csv") -gt 0)
                        {
                            New-Item "$OUTPUT_FOLDER\Amcache\XLSX" -ItemType Directory -Force | Out-Null
                            $IMPORT = Import-Csv "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_ProgramEntries.csv" -Delimiter ","
                            $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Amcache\XLSX\AmcacheParser_ProgramEntries.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "ProgramEntries" -CellStyleSB {
                            param($WorkSheet)
                            # BackgroundColor and FontColor for specific cells of TopRow
                            $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                            Set-Format -Address $WorkSheet.Cells["A1:Z1"] -BackgroundColor $BackgroundColor -FontColor White
                            # HorizontalAlignment "Center" of columns A-J, L-N, P-S, V-X and Z
                            $WorkSheet.Cells["A:J"].Style.HorizontalAlignment="Center"
                            $WorkSheet.Cells["L:N"].Style.HorizontalAlignment="Center"
                            $WorkSheet.Cells["P:S"].Style.HorizontalAlignment="Center"
                            $WorkSheet.Cells["V:X"].Style.HorizontalAlignment="Center"
                            $WorkSheet.Cells["Z:Z"].Style.HorizontalAlignment="Center"
                            }
                        }
                    }

                    # ShortCuts
                    if (Test-Path "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_ShortCuts.csv")
                    {
                        if([int](& $xsv count "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_ShortCuts.csv") -gt 0)
                        {
                            New-Item "$OUTPUT_FOLDER\Amcache\XLSX" -ItemType Directory -Force | Out-Null
                            $IMPORT = Import-Csv "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_ShortCuts.csv" -Delimiter ","
                            $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Amcache\XLSX\AmcacheParser_ShortCuts.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "ShortCuts" -CellStyleSB {
                            param($WorkSheet)
                            # BackgroundColor and FontColor for specific cells of TopRow
                            $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                            Set-Format -Address $WorkSheet.Cells["A1:C1"] -BackgroundColor $BackgroundColor -FontColor White
                            # HorizontalAlignment "Center" of columns A and C
                            $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                            $WorkSheet.Cells["C:C"].Style.HorizontalAlignment="Center"
                            }
                        }
                    }

                    # UnassociatedFileEntries
                    if (Test-Path "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_UnassociatedFileEntries.csv")
                    {
                        if([int](& $xsv count "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_UnassociatedFileEntries.csv") -gt 0)
                        {
                            New-Item "$OUTPUT_FOLDER\Amcache\XLSX" -ItemType Directory -Force | Out-Null
                            $IMPORT = Import-Csv "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_UnassociatedFileEntries.csv" -Delimiter "," -Encoding UTF8 | Sort-Object { $_.FileKeyLastWriteTimestamp -as [datetime] } -Descending
                            $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Amcache\XLSX\AmcacheParser_UnassociatedFileEntries.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "UnassociatedFileEntries" -CellStyleSB {
                            param($WorkSheet)
                            # BackgroundColor and FontColor for specific cells of TopRow
                            $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                            Set-Format -Address $WorkSheet.Cells["A1:U1"] -BackgroundColor $BackgroundColor -FontColor White
                            # HorizontalAlignment "Center" of columns A-E and G-T
                            $WorkSheet.Cells["A:E"].Style.HorizontalAlignment="Center"
                            $WorkSheet.Cells["G:T"].Style.HorizontalAlignment="Center"
                            # HorizontalAlignment "Center" of header of column F
                            $WorkSheet.Cells["F1:F1"].Style.HorizontalAlignment="Center"
                            }
                        }
                    }
                }
                else
                {
                    Write-Output "[Info]  PowerShell module 'ImportExcel' NOT found."
                }

                # Amcache Scan --> Check SHA1 File Hashes on VirusTotal
                if ((Test-Path "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_UnassociatedFileEntries.csv") -And ([int](& $xsv count "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_UnassociatedFileEntries.csv") -gt 0))
                {
                    New-Item "$OUTPUT_FOLDER\Amcache\SHA1" -ItemType Directory -Force | Out-Null
                    Import-Csv "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_UnassociatedFileEntries.csv" -Delimiter "," | Select-Object -Property Name, ProductName, ApplicationName, FullPath, SHA1 | Sort-Object -Property SHA1 -Unique | Export-Csv "$OUTPUT_FOLDER\Amcache\SHA1\SHA1-draft.csv" -Delimiter "," -NoTypeInformation
                    Import-Csv "$OUTPUT_FOLDER\Amcache\CSV\AmcacheParser_AssociatedFileEntries.csv" -Delimiter "," | Select-Object -Property Name, ProductName, ApplicationName, FullPath, SHA1 | Sort-Object -Property SHA1 -Unique | Export-Csv "$OUTPUT_FOLDER\Amcache\SHA1\SHA1-draft.csv" -Delimiter "," -NoTypeInformation -Append
                    Import-Csv "$OUTPUT_FOLDER\Amcache\SHA1\SHA1-draft.csv" -Delimiter "," | Where-Object {$_.SHA1 -ne ""} | Sort-Object -Property SHA1 -Unique | Export-Csv "$OUTPUT_FOLDER\Amcache\SHA1\SHA1.csv" -Delimiter "," -NoTypeInformation
                    (Import-Csv "$OUTPUT_FOLDER\Amcache\SHA1\SHA1-draft.csv" -Delimiter "," | Where-Object {$_.SHA1 -ne ""} | Sort-Object -Property SHA1 -Unique).SHA1 | Out-File "$OUTPUT_FOLDER\Amcache\SHA1\SHA1.txt" -Encoding ascii
                    Remove-Item "$OUTPUT_FOLDER\Amcache\SHA1\SHA1-draft.csv"

                    # XLSX
                    if (Get-Module -ListAvailable -Name ImportExcel)
                    {
                        if (Test-Path "$OUTPUT_FOLDER\Amcache\SHA1\SHA1.csv")
                        {
                            if([int](& $xsv count "$OUTPUT_FOLDER\Amcache\SHA1\SHA1.csv") -gt 0)
                            {
                                $IMPORT = Import-Csv "$OUTPUT_FOLDER\Amcache\SHA1\SHA1.csv" -Delimiter ","
                                $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Amcache\SHA1\SHA1.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "SHA1" -CellStyleSB {
                                param($WorkSheet)
                                # BackgroundColor and FontColor for specific cells of TopRow
                                $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                                Set-Format -Address $WorkSheet.Cells["A1:E1"] -BackgroundColor $BackgroundColor -FontColor White
                                # HorizontalAlignment "Center" of column E
                                $WorkSheet.Cells["E:E"].Style.HorizontalAlignment="Center"
                                }
                            }
                        }
                    }
                
                    # Count SHA1 File Hashes
                    $Count = [string]::Format('{0:N0}',(Get-Content "$OUTPUT_FOLDER\Amcache\SHA1\SHA1.txt" | Measure-Object).Count)
                    Write-Output "[Info]  $Count SHA1 hash value(s) of executables found"
                }
            }
        }

        }

        Get-Amcache

#############################################################################################################################################################################################
        
        Function Get-ShimCache {

        # AppCompatCacheParser (ShimCache)
        if (Test-Path "$OUTPUT_FOLDER\Registry\Registry\*SYSTEM*.reghive") 
        {
            if (Test-Path "$($AppCompatCacheParser)")
            {
                Write-Output "[Info]  Analyzing Application Compatibility Cache aka ShimCache ... "

                # CSV
                New-Item "$OUTPUT_FOLDER\Registry\ShimCache\CSV" -ItemType Directory -Force | Out-Null
                $SYSTEM = (Get-ChildItem "$OUTPUT_FOLDER\Registry\Registry" | Foreach-Object FullName | Select-String -Pattern "SYSTEM" -CaseSensitive | Out-String).Trim()
                & $AppCompatCacheParser -f "$SYSTEM" --csv "$OUTPUT_FOLDER\Registry\ShimCache\CSV" --csvf AppCompatCacheParser.csv -t > "$OUTPUT_FOLDER\Registry\ShimCache\AppCompatCacheParser.log" 2> $null

                # Stats
                if (Test-Path "$OUTPUT_FOLDER\Registry\ShimCache\AppCompatCacheParser.log")
                {
                    $Total = Get-Content "$OUTPUT_FOLDER\Registry\ShimCache\AppCompatCacheParser.log" | Select-String -Pattern "cache entries"
                    if ($Total)
                    {
                        Write-Output "[Info]  $Total"
                    }
                    else
                    {
                        Write-Output "[Info]  SYSTEM Hive seems to be partially corrupt."
                    }
                }

                # XLSX
                if (Get-Module -ListAvailable -Name ImportExcel)
                {
                    if (Test-Path "$OUTPUT_FOLDER\Registry\ShimCache\CSV\AppCompatCacheParser.csv")
                    {
                        if([int](& $xsv count "$OUTPUT_FOLDER\Registry\ShimCache\CSV\AppCompatCacheParser.csv") -gt 0)
                        {
                            New-Item "$OUTPUT_FOLDER\Registry\ShimCache\XLSX" -ItemType Directory -Force | Out-Null
                            $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\ShimCache\CSV\AppCompatCacheParser.csv" -Delimiter "," | Sort-Object { $_.LastModifiedTimeUTC -as [datetime] } -Descending
                            $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\ShimCache\XLSX\AppCompatCacheParser.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "ShimCache" -CellStyleSB {
                            param($WorkSheet)
                            # BackgroundColor and FontColor for specific cells of TopRow
                            $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                            Set-Format -Address $WorkSheet.Cells["A1:G1"] -BackgroundColor $BackgroundColor -FontColor White
                            # HorizontalAlignment "Center" of columns A-B and D-F
                            $WorkSheet.Cells["A:B"].Style.HorizontalAlignment="Center"
                            $WorkSheet.Cells["D:F"].Style.HorizontalAlignment="Center"
                            }
                        }
                    }
                }
            }
            else
            {
                Write-Host "[Error] AppCompatCacheParser.exe NOT found." -ForegroundColor Red
            }
        }

        }

        Get-ShimCache

#############################################################################################################################################################################################

        # Syscache

        Function Get-Syscache {

        # Check if Syscache hive exists
        if (Test-Path "$OUTPUT_FOLDER\Registry\Registry\*Syscachehve*.reghive") 
        {
            # Check if RECmd.exe exists
            if (Test-Path "$($RECmd)")
            {
                Write-Output "[Info]  Analyzing Syscache Hive ... "

                # CSV
                New-Item "$OUTPUT_FOLDER\Syscache\CSV" -ItemType Directory -Force | Out-Null
                $Syscachehve = (Get-ChildItem "$OUTPUT_FOLDER\Registry\Registry" | Where-Object {($_.FullName -match "Syscachehve")} | Foreach-Object FullName)
                & $RECmd -f "$Syscachehve" --bn "$SCRIPT_DIR\Tools\RECmd_BatchFiles\SysCache.reb" --csv "$OUTPUT_FOLDER\Syscache\CSV" --csvf "Syscache.csv" > "$OUTPUT_FOLDER\Syscache\Syscache.log" 2> $null

                # Stats
                if (Test-Path "$OUTPUT_FOLDER\Syscache\Syscache.log")
                {
                    $Total = Get-Content "$OUTPUT_FOLDER\Syscache\Syscache.log" | Select-String -Pattern "key/value pairs"
                    Write-Output "[Info]  $Total"
                }

                # SHA1 --> Check SHA1 hashes on VirusTotal
                if ((Test-Path "$OUTPUT_FOLDER\Syscache\CSV\Syscache.csv") -And ([int](& $xsv count "$OUTPUT_FOLDER\Syscache\CSV\Syscache.csv") -gt 0))
                {
                    (Import-Csv "$OUTPUT_FOLDER\Syscache\CSV\Syscache.csv" | Select-Object -Property "ValueData2" | Sort-Object -Property "ValueData2" -Unique).ValueData2 | ForEach-Object{($_ -split "SHA-1: ")[1]} | Select-Object -Skip 1 | Out-File "$OUTPUT_FOLDER\Syscache\SHA1.txt" -Encoding ascii

                    # Count SHA1 hashes
                    $Count = [string]::Format('{0:N0}',(Get-Content "$OUTPUT_FOLDER\Syscache\SHA1.txt" | Measure-Object).Count)
                    Write-Output "[Info]  $Count SHA1 hash value(s) of executables found"
                }

                # XLSX

                # Syscache.csv
                if (Test-Path "$OUTPUT_FOLDER\Syscache\CSV\Syscache.csv")
                {
                    if([int](& $xsv count "$OUTPUT_FOLDER\Syscache\CSV\Syscache.csv") -gt 0)
                    {
                        New-Item "$OUTPUT_FOLDER\Syscache\XLSX" -ItemType Directory -Force | Out-Null
                        $IMPORT = Import-Csv "$OUTPUT_FOLDER\Syscache\CSV\Syscache.csv" -Delimiter "," | Sort-Object { $_.LastWriteTimestamp -as [datetime] } -Descending
                        $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Syscache\XLSX\Syscache.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "SysCache" -CellStyleSB {
                        param($WorkSheet)
                        # BackgroundColor and FontColor for specific cells of TopRow
                        $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                        Set-Format -Address $WorkSheet.Cells["A1:O1"] -BackgroundColor $BackgroundColor -FontColor White
                        # HorizontalAlignment "Center" of columns B-N
                        $WorkSheet.Cells["B:N"].Style.HorizontalAlignment="Center"
                        }
                    }
                }

                # Syscache_SyscacheObjectTable.csv
                if (Test-Path "$OUTPUT_FOLDER\Syscache\CSV\*\Syscache_SyscacheObjectTable.csv")
                {
                    $FilePath = Get-ChildItem -Path "$OUTPUT_FOLDER\Syscache\CSV\*\Syscache_SyscacheObjectTable.csv" | ForEach-Object FullName
                    if([int](& $xsv count "$FilePath") -gt 0)
                    {
                        New-Item "$OUTPUT_FOLDER\Syscache\XLSX" -ItemType Directory -Force | Out-Null
                        $IMPORT = Import-Csv "$OUTPUT_FOLDER\Syscache\CSV\*\Syscache_SyscacheObjectTable.csv" -Delimiter "," | Sort-Object { $_.LastWriteTime -as [datetime] } -Descending
                        $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Syscache\XLSX\Syscache_SyscacheObjectTable.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "SysCache (Plugin)" -CellStyleSB {
                        param($WorkSheet)
                        # BackgroundColor and FontColor for specific cells of TopRow
                        $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                        Set-Format -Address $WorkSheet.Cells["A1:L1"] -BackgroundColor $BackgroundColor -FontColor White
                        # HorizontalAlignment "Center" of columns B-L
                        $WorkSheet.Cells["B:L"].Style.HorizontalAlignment="Center"
                        $WorkSheet.Cells["D:L"].Style.HorizontalAlignment="Center"
                        }
                    }
                }
            }
            else
            {
                Write-Host "[Error] RECmd.exe NOT found." -ForegroundColor Red
            }
        }
        else
        {
            Write-Host "[Info]  Syscache.hve not found."
        }

        }

        Get-Syscache

#############################################################################################################################################################################################

        # UserAssist

        Function Get-UserAssist {

        # Check if RECmd.exe exists
        if (Test-Path "$($RECmd)")
        {
            # Check if batch processing file exists
            if (Test-Path "$SCRIPT_DIR\Tools\RECmd_BatchFiles\UserAssist.reb")
            {
                # Check if Registry Plugin exists
                if (Test-Path "$SCRIPT_DIR\Tools\RECmd\Plugins\RegistryPlugin.UserAssist.dll")
                {
                    # Analyzing UserAssist Artifacts
                    Write-Output "[Info]  Analyzing UserAssist Artifacts ..."
                    New-Item "$OUTPUT_FOLDER\Registry\UserAssist\CSV" -ItemType Directory -Force | Out-Null
                    New-Item "$OUTPUT_FOLDER\Registry\UserAssist\XLSX" -ItemType Directory -Force | Out-Null

                    $FilePathList = (Get-ChildItem "$OUTPUT_FOLDER\Registry\Registry" | Where-Object {($_.FullName -match "ntuserdat")} | Foreach-Object FullName)

                    ForEach( $FilePath in $FilePathList )
                    {
                        $FileName = $FilePath | ForEach-Object{($_ -split "\\")[-1]} | ForEach-Object{($_ -split "\.")[0]}
                        $SID = $FileName | ForEach-Object{($_ -split "_")[1]}

                        # Check if UserAssist key exists
                        if (Test-Path "$DriveLetter\registry\by-hive\$FileName\ROOT\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\UserAssist")
                        {
                            # CSV
                            & $RECmd -f "$FilePath" --bn "$SCRIPT_DIR\Tools\RECmd_BatchFiles\UserAssist.reb" --csv "$OUTPUT_FOLDER\Registry\UserAssist\CSV" --csvf "$SID-UserAssist.csv" > "$OUTPUT_FOLDER\Registry\UserAssist\$SID-UserAssist.log" 2> $null

                            if (Test-Path "$OUTPUT_FOLDER\Registry\UserAssist\CSV\*\$SID-UserAssist_UserAssist.csv")
                            {
                                Move-Item -Path "$OUTPUT_FOLDER\Registry\UserAssist\CSV\*\$SID-UserAssist_UserAssist.csv" -Destination "$OUTPUT_FOLDER\Registry\UserAssist\CSV\$SID-UserAssist_PluginDetailFile.csv"
                                Get-ChildItem -Path "$OUTPUT_FOLDER\Registry\UserAssist\CSV\*" -Directory | ForEach-Object FullName | Remove-Item -Force -Recurse
                            }

                            # Stats
                            if (Test-Path "$OUTPUT_FOLDER\Registry\UserAssist\$SID-UserAssist.log")
                            {
                                # Check for parsing error
                                if (!(Get-Content -Path "$OUTPUT_FOLDER\Registry\UserAssist\$SID-UserAssist.log" | Select-String -Pattern "parse error" -Quiet))
                                {
                                    # Check if key/value pairs were found
                                    if (!(Get-Content -Path "$OUTPUT_FOLDER\Registry\UserAssist\$SID-UserAssist.log" | Select-String -Pattern "Found 0 key/value pairs across 1 file" -Quiet))
                                    {
                                        # Count
                                        $Total = Get-Content "$OUTPUT_FOLDER\Registry\UserAssist\$SID-UserAssist.log" | Select-String -Pattern "key/value pairs"
                                        Write-Output "[Info]  $Total ($SID)"

                                        # Array
                                        $Array = @()

                                        # Total Entries
                                        $TotalEntries = (Import-Csv "$OUTPUT_FOLDER\Registry\UserAssist\CSV\$SID-UserAssist.csv" -Delimiter "," | Measure-Object).Count
                                        $Array += @{"UserAssist Entries Description" = "Total Entries"; Count = "$TotalEntries"}

                                        # Toral Entries w/ Run Count
                                        $TotalRunCount = (Import-Csv "$OUTPUT_FOLDER\Registry\UserAssist\CSV\$SID-UserAssist.csv" -Delimiter "," | Where-Object { $_.ValueData3 -match "Run count:" } | Measure-Object).Count
                                        $Array += @{"UserAssist Entries Description" = "Total Entries with Run Count"; Count = "$TotalRunCount"}

                                        # Entries with "Run count: 0"
                                        $RunCount0 = (Import-Csv "$OUTPUT_FOLDER\Registry\UserAssist\CSV\$SID-UserAssist.csv" -Delimiter "," | Where-Object { $_.ValueData3 -match "Run count: 0" } | Measure-Object).Count
                                        $Array += @{"UserAssist Entries Description" = "Entries with Run Count 0"; Count = "$RunCount0"}

                                        # Entries with "Last executed" field populated
                                        $LastExecutedPopulated = (Import-Csv "$OUTPUT_FOLDER\Registry\UserAssist\CSV\$SID-UserAssist.csv" -Delimiter "," | Where-Object { $_.ValueData2 -match "Last executed: 2" } | Measure-Object).Count
                                        $Array += @{"UserAssist Entries Description" = "Entries with 'Last executed' field populated"; Count = "$LastExecutedPopulated"}

                                        # Entries with "Last executed" field not populated
                                        $LastExecutedEmpty = (Import-Csv "$OUTPUT_FOLDER\Registry\UserAssist\CSV\$SID-UserAssist.csv" -Delimiter "," | Where-Object { $_.ValueData2 -match "Last executed: $" } | Measure-Object).Count
                                        $Array += @{"UserAssist Entries Description" = "Entries with 'Last executed' field not populated"; Count = "$LastExecutedEmpty"}

                                        # Executable File Execution (GUID)
                                        $ExecutableFileExecution = (Import-Csv "$OUTPUT_FOLDER\Registry\UserAssist\CSV\$SID-UserAssist.csv" -Delimiter "," | Where-Object { $_.KeyPath -match "{CEBFF5CD-ACE2-4F4F-9178-9926F41749EA}\\Count" } | Measure-Object).Count
                                        $Array += @{"UserAssist Entries Description" = "Executable File Execution"; Count = "$ExecutableFileExecution"}

                                        # Shortcut File Execution (GUID)
                                        $ShortcutFileExecution = (Import-Csv "$OUTPUT_FOLDER\Registry\UserAssist\CSV\$SID-UserAssist.csv" -Delimiter "," | Where-Object { $_.KeyPath -match "{F4E57C4B-2036-45F0-A9AB-443BCFE33D9F}\\Count" } | Measure-Object).Count
                                        $Array += @{"UserAssist Entries Description" = "Shortcut File Execution"; Count = "$ShortcutFileExecution"}
                                        
                                        # CSV
                                        $Array | ForEach-Object { New-Object PSObject -Property $_ } |  Export-Csv "$OUTPUT_FOLDER\Registry\UserAssist\CSV\$SID-UserAssist-Stats.csv" -NoTypeInformation
                                    }
                                    else
                                    {
                                        Write-Host "[Info]  Found 0 key/value pairs across 1 file ($SID)"
                                    }
                                }
                            }

                            # XLSX
                            if (Test-Path "$OUTPUT_FOLDER\Registry\UserAssist\CSV\$SID-UserAssist.csv")
                            {
                                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\UserAssist\CSV\$SID-UserAssist.csv") -gt 0)
                                {
                                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\UserAssist\CSV\$SID-UserAssist.csv" -Delimiter "," | Sort-Object { $_.LastWriteTimestamp -as [datetime] } -Descending
                                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\UserAssist\XLSX\$SID-UserAssist.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "UserAssist" -CellStyleSB {
                                    param($WorkSheet)
                                    # BackgroundColor and FontColor for specific cells of TopRow
                                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                                    Set-Format -Address $WorkSheet.Cells["A1:O1"] -BackgroundColor $BackgroundColor -FontColor White
                                    # HorizontalAlignment "Center" of columns B-D, G and J-N
                                    $WorkSheet.Cells["B:D"].Style.HorizontalAlignment="Center"
                                    $WorkSheet.Cells["G:G"].Style.HorizontalAlignment="Center"
                                    $WorkSheet.Cells["J:N"].Style.HorizontalAlignment="Center"
                                    }
                                }
                            }

                            # XLSX (PluginDetailFile)
                            if (Test-Path "$OUTPUT_FOLDER\Registry\UserAssist\CSV\$SID-UserAssist_PluginDetailFile.csv")
                            {
                                if((Get-Item "$OUTPUT_FOLDER\Registry\UserAssist\CSV\$SID-UserAssist_PluginDetailFile.csv").length -gt 0kb)
                                {
                                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\UserAssist\CSV\$SID-UserAssist_PluginDetailFile.csv" -Delimiter "," | Sort-Object { $_.LastExecuted -as [datetime] } -Descending
                                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\UserAssist\XLSX\$SID-UserAssist_PluginDetailFile.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "UserAssist (Plugin)" -CellStyleSB {
                                    param($WorkSheet)
                                    # BackgroundColor and FontColor for specific cells of TopRow
                                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                                    Set-Format -Address $WorkSheet.Cells["A1:G1"] -BackgroundColor $BackgroundColor -FontColor White
                                    # HorizontalAlignment "Center" of columns D-G
                                    $WorkSheet.Cells["D:G"].Style.HorizontalAlignment="Center"
                                    }
                                }
                            }

                            # XLSX (Stats)
                            if (Test-Path "$OUTPUT_FOLDER\Registry\UserAssist\CSV\$SID-UserAssist-Stats.csv")
                            {
                                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\UserAssist\CSV\$SID-UserAssist-Stats.csv") -gt 0)
                                {
                                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\UserAssist\CSV\$SID-UserAssist-Stats.csv" -Delimiter ","
                                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\UserAssist\XLSX\$SID-UserAssist-Stats.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "UserAssist (Stats)" -CellStyleSB {
                                    param($WorkSheet)
                                    # BackgroundColor and FontColor for specific cells of TopRow
                                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                                    Set-Format -Address $WorkSheet.Cells["A1:B1"] -BackgroundColor $BackgroundColor -FontColor White
                                    # HorizontalAlignment "Center" of column B
                                    $WorkSheet.Cells["B:B"].Style.HorizontalAlignment="Center"
                                    }
                                }
                            }
                        }
                    }
                }
                else
                {
                    Write-Host "[Error] RegistryPlugin.UserAssist.dll NOT found." -ForegroundColor Red
                }
            }
            else
            {
                Write-Host "[Error] UserAssist.reb NOT found." -ForegroundColor Red
            }
        }
        else
        {
            Write-Host "[Error] RECmd.exe NOT found." -ForegroundColor Red
        }

        }

        Get-UserAssist

#############################################################################################################################################################################################

        # Windows Background Activity Moderator (BAM)
        
        Function Get-BAM {

        # Check if RECmd.exe exists
        if (Test-Path "$($RECmd)")
        {
            # Check if batch processing file exists
            if (Test-Path "$SCRIPT_DIR\Tools\RECmd_BatchFiles\BAM.reb")
            {
                # Check if Background Activity Moderator Driver exists
                if (Test-Path "$DriveLetter\sys\services\services.txt")
                {
                    if (Get-Content "$DriveLetter\sys\services\services.txt" | Select-String -Pattern "Background Activity Moderator Driver" -Quiet)
                    {
                        # Analyzing Windows Background Activity Moderator (BAM) Artifacts
                        Write-Output "[Info]  Analyzing Windows Background Activity Moderator (BAM) Artifacts ... "
                        New-Item "$OUTPUT_FOLDER\Registry\BAM\CSV" -ItemType Directory -Force | Out-Null
                        New-Item "$OUTPUT_FOLDER\Registry\BAM\XLSX" -ItemType Directory -Force | Out-Null

                        # CSV
                        $SYSTEM = (Get-ChildItem "$OUTPUT_FOLDER\Registry\Registry" | ForEach-Object Name | Select-String -Pattern "SYSTEM" -CaseSensitive | Out-String).Trim()
                        & $RECmd -f "$OUTPUT_FOLDER\Registry\Registry\$SYSTEM" --bn "$SCRIPT_DIR\Tools\RECmd_BatchFiles\BAM.reb" --csv "$OUTPUT_FOLDER\Registry\BAM\CSV" --csvf "BAM.csv" 2>&1 | Out-File "$OUTPUT_FOLDER\Registry\BAM\BAM.log"

                        if (Test-Path "$OUTPUT_FOLDER\Registry\BAM\CSV\*\BAM_BamDam.csv")
                        {
                            Move-Item -Path "$OUTPUT_FOLDER\Registry\BAM\CSV\*\BAM_BamDam.csv" -Destination "$OUTPUT_FOLDER\Registry\BAM\CSV\BAM_PluginDetailFile.csv"
                            Get-ChildItem -Path "$OUTPUT_FOLDER\Registry\BAM\CSV\*" -Directory | ForEach-Object FullName | Remove-Item -Force -Recurse
                        }

                        # Stats
                        if (Test-Path "$OUTPUT_FOLDER\Registry\BAM\BAM.log")
                        {
                            # Check if key/value pairs were found
                            if (!(Get-Content -Path "$OUTPUT_FOLDER\Registry\BAM\BAM.log" | Select-String -Pattern "Found 0 key/value pairs across 1 file" -Quiet))
                            {
                                # Count
                                $Count = Get-Content "$OUTPUT_FOLDER\Registry\BAM\BAM.log" | Select-String -Pattern "key/value pairs"
                                Write-Output "[Info]  $Count"
                            }
                            else
                            {
                                Write-Output "[Info]  Found 0 key/value pairs across 1 file"
                            }
                        }

                        # XLSX
                        if (Test-Path "$OUTPUT_FOLDER\Registry\BAM\CSV\BAM.csv")
                        {
                            if([int](& $xsv count "$OUTPUT_FOLDER\Registry\BAM\CSV\BAM.csv") -gt 0)
                            {
                                $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\BAM\CSV\BAM.csv" -Delimiter ","
                                $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\BAM\XLSX\BAM.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "BAM" -CellStyleSB {
                                param($WorkSheet)
                                # BackgroundColor and FontColor for specific cells of TopRow
                                $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                                Set-Format -Address $WorkSheet.Cells["A1:O1"] -BackgroundColor $BackgroundColor -FontColor White
                                # HorizontalAlignment "Center" of columns B-D, G and I-N
                                $WorkSheet.Cells["B:D"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["G:G"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["I:N"].Style.HorizontalAlignment="Center"
                                }
                            }
                        }

                        # XLSX (PluginDetailFile)
                        if (Test-Path "$OUTPUT_FOLDER\Registry\BAM\CSV\BAM_PluginDetailFile.csv")
                        {
                            if((Get-Item "$OUTPUT_FOLDER\Registry\BAM\CSV\BAM_PluginDetailFile.csv").length -gt 0kb)
                            {
                                $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\BAM\CSV\BAM_PluginDetailFile.csv" -Delimiter "," | Sort-Object { $_.ExecutionTime -as [datetime] } -Descending
                                $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\BAM\XLSX\BAM_PluginDetailFile.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "BAM (Plugin)" -CellStyleSB {
                                param($WorkSheet)
                                # BackgroundColor and FontColor for specific cells of TopRow
                                $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                                Set-Format -Address $WorkSheet.Cells["A1:D1"] -BackgroundColor $BackgroundColor -FontColor White
                                # HorizontalAlignment "Center" of column C
                                $WorkSheet.Cells["C:C"].Style.HorizontalAlignment="Center"
                                }
                            }
                        }
                    }
                }
            }
        }

        }

        Get-BAM

#############################################################################################################################################################################################

        # MUICache (Multi-Lingual User Interface)

        Function Get-MUICache {

        # Check if RECmd.exe exists
        if (Test-Path "$($RECmd)")
        {
            # Check if batch processing file exists
            if (Test-Path "$SCRIPT_DIR\Tools\RECmd_BatchFiles\MUICache.reb")
            {
                # Analyzing MUICache Artifacts
                Write-Output "[Info]  Analyzing MUICache Artifacts ... "
                New-Item "$OUTPUT_FOLDER\Registry\MUICache\CSV" -ItemType Directory -Force | Out-Null
                New-Item "$OUTPUT_FOLDER\Registry\MUICache\XLSX" -ItemType Directory -Force | Out-Null

                $FilePathList = (Get-ChildItem "$OUTPUT_FOLDER\Registry\Registry" | Where-Object {($_.FullName -match "UsrClassdat")} | Foreach-Object FullName)

                ForEach( $FilePath in $FilePathList )
                {
                    $FileName = $FilePath | ForEach-Object{($_ -split "\\")[-1]} | ForEach-Object{($_ -split "\.")[0]}
                    $SID = $FileName | ForEach-Object{($_ -split "_")[1]}

                    # Check if MUICache key exists (Vista+)
                    if (Test-Path "$DriveLetter\registry\by-hive\$FileName\ROOT\Local Settings\Software\Microsoft\Windows\Shell\MuiCache")
                    {
                        # CSV
                        & $RECmd -f "$FilePath" --bn "$SCRIPT_DIR\Tools\RECmd_BatchFiles\MUICache.reb" --csv "$OUTPUT_FOLDER\Registry\MUICache\CSV" --csvf "$SID-MUICache.csv" > "$OUTPUT_FOLDER\Registry\MUICache\$SID-MUICache.log" 2> $null

                        # Stats
                        if (Test-Path "$OUTPUT_FOLDER\Registry\MUICache\$SID-MUICache.log")
                        {
                            # Check if key/value pairs were found
                            if (!(Get-Content -Path "$OUTPUT_FOLDER\Registry\MUICache\$SID-MUICache.log" | Select-String -Pattern "Found 0 key/value pairs across 1 file" -Quiet))
                            {
                                # Count
                                $Total = Get-Content "$OUTPUT_FOLDER\Registry\MUICache\$SID-MUICache.log" | Select-String -Pattern "key/value pairs"
                                Write-Output "[Info]  $Total ($SID)"
                            }
                        }

                        # XLSX
                        if (Test-Path "$OUTPUT_FOLDER\Registry\MUICache\CSV\$SID-MUICache.csv")
                        {
                            if([int](& $xsv count "$OUTPUT_FOLDER\Registry\MUICache\CSV\$SID-MUICache.csv") -gt 0)
                            {
                                $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\MUICache\CSV\$SID-MUICache.csv" -Delimiter ","
                                $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\MUICache\XLSX\$SID-MUICache.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "MUICache" -CellStyleSB {
                                param($WorkSheet)
                                # BackgroundColor and FontColor for specific cells of TopRow
                                $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                                Set-Format -Address $WorkSheet.Cells["A1:O1"] -BackgroundColor $BackgroundColor -FontColor White
                                # HorizontalAlignment "Center" of columns B-D, G and I-O
                                $WorkSheet.Cells["B:D"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["G:G"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["I:O"].Style.HorizontalAlignment="Center"
                                }
                            }
                        }

                        # Custom CSV
                        if (Test-Path "$OUTPUT_FOLDER\Registry\MUICache\CSV\$SID-MUICache.csv")
                        {
                            if([int](& $xsv count "$OUTPUT_FOLDER\Registry\MUICache\CSV\$SID-MUICache.csv") -gt 0)
                            {
                                $Import = Import-Csv "$OUTPUT_FOLDER\Registry\MUICache\CSV\$SID-MUICache.csv" -Delimiter "," | Where-Object { $_.ValueType -eq "RegSz" }

                                $Counter=0

                                $Import | Foreach-Object {

                                    $Counter++

                                    if ($_.ValueName -like "*ApplicationCompany*")
                                    {
                                        $FileName = $_ | Select-Object -ExpandProperty ValueName | ForEach-Object{($_ -split "\\")[-1]} | ForEach-Object { $_ -replace "\.ApplicationCompany$" }
                                        $FilePath = $_ | Select-Object -ExpandProperty ValueName | Split-Path 
                                        $ApplicationCompany = $_ | Select-Object -ExpandProperty ValueData
                                        $HivePath = $_ | Select-Object -ExpandProperty HivePath
                                        $LastWriteTimestamp = $_ | Select-Object -ExpandProperty LastWriteTimestamp
                                    }

                                    if ($_.ValueName -like "*FriendlyAppName*")
                                    {
                                        $FriendlyAppName = $_ | Select-Object -ExpandProperty ValueData
                                    }

                                    if($Counter -eq 2)
                                    {  
                                        New-Object -TypeName PSObject -Property @{

                                            "FileName"          = $FileName
                                            "FilePath"          = $FilePath
                                            "ApplicationCompany" = $ApplicationCompany # Company Name
                                            "FriendlyAppName"    = $FriendlyAppName # File Description
                                            "HivePath"          = $HivePath
                                            "LastWriteTimestamp" = $LastWriteTimestamp
                                            "SID"                = $SID
                                            "UserName"           = Get-Content "$OUTPUT_FOLDER\sys\users\users.txt" | Select-String -Pattern "$SID" | ForEach-Object{($_ -split "\s+")[1]}
                                            }

                                        $Counter=0
                                    }

                                } | Select-Object "FileName","FilePath","ApplicationCompany","FriendlyAppName","UserName","SID","HivePath","LastWriteTimestamp" | Export-Csv -Path "$OUTPUT_FOLDER\Registry\MUICache\CSV\$SID-MUICache_Custom.csv" -Delimiter "," -NoTypeInformation -Encoding UTF8   
                            }
                        }

                        # Stats
                        if (Test-Path "$OUTPUT_FOLDER\Registry\MUICache\CSV\$SID-MUICache_Custom.csv")
                        {
                            # Count
                            $Unique = (Import-Csv -Path "$OUTPUT_FOLDER\Registry\MUICache\CSV\$SID-MUICache_Custom.csv" | Select-Object "File Name" | Sort-Object { [string]$_."File Name" } -Unique | Measure-Object).Count
                            $Total = & $xsv count "$OUTPUT_FOLDER\Registry\MUICache\CSV\$SID-MUICache_Custom.csv"
                            Write-Output "[Info]  $Unique GUI-based executable(s) found ($Total)"
                        }

                        # XLSX
                        if (Test-Path "$OUTPUT_FOLDER\Registry\MUICache\CSV\$SID-MUICache_Custom.csv")
                        {
                            if([int](& $xsv count "$OUTPUT_FOLDER\Registry\MUICache\CSV\$SID-MUICache_Custom.csv") -gt 0)
                            {
                                $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\MUICache\CSV\$SID-MUICache_Custom.csv" -Delimiter "," -Encoding UTF8
                                $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\MUICache\XLSX\$SID-MUICache_Custom.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "MUICache" -CellStyleSB {
                                param($WorkSheet)
                                # BackgroundColor and FontColor for specific cells of TopRow
                                $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                                Set-Format -Address $WorkSheet.Cells["A1:H1"] -BackgroundColor $BackgroundColor -FontColor White
                                # HorizontalAlignment "Center" of columns C, E-F and H
                                $WorkSheet.Cells["C:C"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["E:F"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["H:H"].Style.HorizontalAlignment="Center"
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                Write-Host "[Error] MUICache.reb NOT found." -ForegroundColor Red
            }
        }
        else
        {
            Write-Host "[Error] RECmd.exe NOT found." -ForegroundColor Red
        }

        }

        Get-MUICache

#############################################################################################################################################################################################

        # MRU Opened-Saved Files (OpenSavePidlMRU)

        # Files that are accessed by a Windows (Vista+) application using the common Open File or Save File dialog found at:
        # NTUSER.DAT\Software\Microsoft\Windows\CurrentVersion\Explorer\ComDlg32\OpenSavePidlMRU

        Function Get-OpenSaveMRU {
        
        # Check if RECmd.exe exists
        if (Test-Path "$($RECmd)")
        {
            # Check if batch processing file exists
            if (Test-Path "$SCRIPT_DIR\Tools\RECmd_BatchFiles\OpenSavePidlMRU.reb")
            {
                # Analyzing OpenSaveMRU Artifacts (OpenSavePidlMRU)
                Write-Output "[Info]  Analyzing OpenSaveMRU Artifacts ... "
                New-Item "$OUTPUT_FOLDER\Registry\OpenSaveMRU\CSV" -ItemType Directory -Force | Out-Null
                New-Item "$OUTPUT_FOLDER\Registry\OpenSaveMRU\XLSX" -ItemType Directory -Force | Out-Null

                $FilePathList = (Get-ChildItem "$OUTPUT_FOLDER\Registry\Registry" | Where-Object {($_.FullName -match "ntuserdat")} | Foreach-Object FullName)

                ForEach( $FilePath in $FilePathList )
                {
                    $FileName = $FilePath | ForEach-Object{($_ -split "\\")[-1]} | ForEach-Object{($_ -split "\.")[0]}
                    $SID = $FileName | ForEach-Object{($_ -split "_")[1]}

                    # Check if OpenSavePidlMRU key exists
                    if (Test-Path "$DriveLetter\registry\by-hive\$FileName\ROOT\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\ComDlg32\OpenSavePidlMRU")
                    {
                        # CSV
                        & $RECmd -f "$FilePath" --bn "$SCRIPT_DIR\Tools\RECmd_BatchFiles\OpenSavePidlMRU.reb" --csv "$OUTPUT_FOLDER\Registry\OpenSaveMRU\CSV" --csvf "$SID-OpenSavePidlMRU.csv" > "$OUTPUT_FOLDER\Registry\OpenSaveMRU\$SID-OpenSavePidlMRU.log" 2> $null

                        # RegistryPlugin.OpenSavePidlMRU.dll
                        if (Test-Path "$OUTPUT_FOLDER\Registry\OpenSaveMRU\CSV\*\$SID-OpenSavePidlMRU_OpenSavePidlMRU.csv")
                        {
                            Move-Item -Path "$OUTPUT_FOLDER\Registry\OpenSaveMRU\CSV\*\$SID-OpenSavePidlMRU_OpenSavePidlMRU.csv" -Destination "$OUTPUT_FOLDER\Registry\OpenSaveMRU\CSV\$SID-OpenSavePidlMRU_PluginDetailFile.csv"
                            Get-ChildItem -Path "$OUTPUT_FOLDER\Registry\OpenSaveMRU\CSV\*" -Directory | ForEach-Object FullName | Remove-Item -Force -Recurse
                        }

                        # Stats
                        if (Test-Path "$OUTPUT_FOLDER\Registry\OpenSaveMRU\$SID-OpenSavePidlMRU.log")
                        {
                            # Check if key/value pairs were found
                            if (!(Get-Content -Path "$OUTPUT_FOLDER\Registry\OpenSaveMRU\$SID-OpenSavePidlMRU.log" | Select-String -Pattern "Found 0 key/value pairs across 1 file" -Quiet))
                            {
                                # Count
                                $Total = Get-Content "$OUTPUT_FOLDER\Registry\OpenSaveMRU\$SID-OpenSavePidlMRU.log" | Select-String -Pattern "key/value pairs"
                                Write-Output "[Info]  $Total ($SID)"
                            }
                        }

                        # XLSX

                        # OpenSavePidlMRU.csv
                        if (Test-Path "$OUTPUT_FOLDER\Registry\OpenSaveMRU\CSV\$SID-OpenSavePidlMRU.csv")
                        {
                            if([int](& $xsv count "$OUTPUT_FOLDER\Registry\OpenSaveMRU\CSV\$SID-OpenSavePidlMRU.csv") -gt 0)
                            {
                                $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\OpenSaveMRU\CSV\$SID-OpenSavePidlMRU.csv" -Delimiter "," -Encoding UTF8
                                $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\OpenSaveMRU\XLSX\$SID-OpenSavePidlMRU.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "OpenSavePidlMRU" -CellStyleSB {
                                param($WorkSheet)
                                # BackgroundColor and FontColor for specific cells of TopRow
                                $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                                Set-Format -Address $WorkSheet.Cells["A1:O1"] -BackgroundColor $BackgroundColor -FontColor White
                                # HorizontalAlignment "Center" of columns B-F, I and K-N
                                $WorkSheet.Cells["B:F"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["I:I"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["K:N"].Style.HorizontalAlignment="Center"
                                }
                            }
                        }

                        # OpenSavePidlMRU_PluginDetailFile.csv
                        if (Test-Path "$OUTPUT_FOLDER\Registry\OpenSaveMRU\CSV\$SID-OpenSavePidlMRU_PluginDetailFile.csv")
                        {
                            if([int](& $xsv count "$OUTPUT_FOLDER\Registry\OpenSaveMRU\CSV\$SID-OpenSavePidlMRU_PluginDetailFile.csv") -gt 0)
                            {
                                $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\OpenSaveMRU\CSV\$SID-OpenSavePidlMRU_PluginDetailFile.csv" -Delimiter "," -Encoding UTF8
                                $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\OpenSaveMRU\XLSX\$SID-OpenSavePidlMRU_PluginDetailFile.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "OpenSavePidlMRU (Plugin)" -CellStyleSB {
                                param($WorkSheet)
                                # BackgroundColor and FontColor for specific cells of TopRow
                                $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                                Set-Format -Address $WorkSheet.Cells["A1:H1"] -BackgroundColor $BackgroundColor -FontColor White
                                # HorizontalAlignment "Center" of columns A, C-E and G
                                $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["C:E"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["G:G"].Style.HorizontalAlignment="Center"
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                Write-Host "[Error] OpenSavePidlMRU.reb NOT found." -ForegroundColor Red
            }
        }
        else
        {
            Write-Host "[Error] RECmd.exe NOT found." -ForegroundColor Red
        }
        
        }

        Get-OpenSaveMRU

        # LastVisitedPidlMRU

        # Tracks the specific executable used by an application to open the files documented in OpenSavePidlMRU found at:
        # NTUSER.DAT\Software\Microsoft\Windows\CurrentVersion\Explorer\ComDlg32\LastVisitedPidlMRU

        Function Get-LastVisitedMRU {
        
        # Check if RECmd.exe exists
        if (Test-Path "$($RECmd)")
        {
            # Check if batch processing file exists
            if (Test-Path "$SCRIPT_DIR\Tools\RECmd_BatchFiles\LastVisitedPidlMRU.reb")
            {
                # Analyzing LastVisitedMRU Artifacts (LastVisitedPidlMRU)
                Write-Output "[Info]  Analyzing LastVisitedMRU Artifacts ... "
                New-Item "$OUTPUT_FOLDER\Registry\LastVisitedMRU\CSV" -ItemType Directory -Force | Out-Null
                New-Item "$OUTPUT_FOLDER\Registry\LastVisitedMRU\XLSX" -ItemType Directory -Force | Out-Null

                $FilePathList = (Get-ChildItem "$OUTPUT_FOLDER\Registry\Registry" | Where-Object {($_.FullName -match "ntuserdat")} | Foreach-Object FullName)

                ForEach( $FilePath in $FilePathList )
                {
                    $FileName = $FilePath | ForEach-Object{($_ -split "\\")[-1]} | ForEach-Object{($_ -split "\.")[0]}
                    $SID = $FileName | ForEach-Object{($_ -split "_")[1]}

                    # Check if LastVisitedPidlMRU key exists
                    if (Test-Path "$DriveLetter\registry\by-hive\$FileName\ROOT\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\ComDlg32\LastVisitedPidlMRU")
                    {
                        # CSV
                        & $RECmd -f "$FilePath" --bn "$SCRIPT_DIR\Tools\RECmd_BatchFiles\LastVisitedPidlMRU.reb" --csv "$OUTPUT_FOLDER\Registry\LastVisitedMRU\CSV" --csvf "$SID-LastVisitedPidlMRU.csv" > "$OUTPUT_FOLDER\Registry\LastVisitedMRU\$SID-LastVisitedPidlMRU.log" 2> $null
                        
                        # RegistryPlugin.LastVisitedPidlMRU.dll
                        if (Test-Path "$OUTPUT_FOLDER\Registry\LastVisitedMRU\CSV\*\$SID-LastVisitedPidlMRU_LastVisitedPidlMRU.csv")
                        {
                            Move-Item -Path "$OUTPUT_FOLDER\Registry\LastVisitedMRU\CSV\*\$SID-LastVisitedPidlMRU_LastVisitedPidlMRU.csv" -Destination "$OUTPUT_FOLDER\Registry\LastVisitedMRU\CSV\$SID-LastVisitedPidlMRU_PluginDetailFile.csv"
                            Get-ChildItem -Path "$OUTPUT_FOLDER\Registry\LastVisitedMRU\CSV\*" -Directory | ForEach-Object FullName | Remove-Item -Force -Recurse
                        }

                        # Stats
                        if (Test-Path "$OUTPUT_FOLDER\Registry\LastVisitedMRU\$SID-LastVisitedPidlMRU.log")
                        {
                            # Check if key/value pairs were found
                            if (!(Get-Content -Path "$OUTPUT_FOLDER\Registry\LastVisitedMRU\$SID-LastVisitedPidlMRU.log" | Select-String -Pattern "Found 0 key/value pairs across 1 file" -Quiet))
                            {
                                # Count
                                $Total = Get-Content "$OUTPUT_FOLDER\Registry\LastVisitedMRU\$SID-LastVisitedPidlMRU.log" | Select-String -Pattern "key/value pairs"
                                Write-Output "[Info]  $Total ($SID)"
                            }
                        }

                        # XLSX

                        # LastVisitedPidlMRU.csv
                        if (Test-Path "$OUTPUT_FOLDER\Registry\LastVisitedMRU\CSV\$SID-LastVisitedPidlMRU.csv")
                        {
                            if([int](& $xsv count "$OUTPUT_FOLDER\Registry\LastVisitedMRU\CSV\$SID-LastVisitedPidlMRU.csv") -gt 0)
                            {
                                $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\LastVisitedMRU\CSV\$SID-LastVisitedPidlMRU.csv" -Delimiter "," -Encoding UTF8
                                $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\LastVisitedMRU\XLSX\$SID-LastVisitedPidlMRU.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "LastVisitedPidlMRU" -CellStyleSB {
                                param($WorkSheet)
                                # BackgroundColor and FontColor for specific cells of TopRow
                                $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                                Set-Format -Address $WorkSheet.Cells["A1:O1"] -BackgroundColor $BackgroundColor -FontColor White
                                # HorizontalAlignment "Center" of columns B-G, I and K-N
                                $WorkSheet.Cells["B:G"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["I:I"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["K:N"].Style.HorizontalAlignment="Center"
                                }
                            }
                        }

                        # LastVisitedPidlMRU_PluginDetailFile.csv
                        if (Test-Path "$OUTPUT_FOLDER\Registry\LastVisitedMRU\CSV\$SID-LastVisitedPidlMRU_PluginDetailFile.csv")
                        {
                            if([int](& $xsv count "$OUTPUT_FOLDER\Registry\LastVisitedMRU\CSV\$SID-LastVisitedPidlMRU_PluginDetailFile.csv") -gt 0)
                            {
                                $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\LastVisitedMRU\CSV\$SID-LastVisitedPidlMRU_PluginDetailFile.csv" -Delimiter "," -Encoding UTF8
                                $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\LastVisitedMRU\XLSX\$SID-LastVisitedPidlMRU_PluginDetailFile.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "LastVisitedPidlMRU (Plugin)" -CellStyleSB {
                                param($WorkSheet)
                                # BackgroundColor and FontColor for specific cells of TopRow
                                $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                                Set-Format -Address $WorkSheet.Cells["A1:H1"] -BackgroundColor $BackgroundColor -FontColor White
                                # HorizontalAlignment "Center" of columns A, C-E and G
                                $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["C:E"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["G:G"].Style.HorizontalAlignment="Center"
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                Write-Host "[Error] LastVisitedPidlMRU.reb NOT found." -ForegroundColor Red
            }
        }
        else
        {
            Write-Host "[Error] RECmd.exe NOT found." -ForegroundColor Red
        }

        }

        Get-LastVisitedMRU

#############################################################################################################################################################################################
        
        Function Get-TerminalServerClient {
        
        # Check if RECmd.exe exists
        if (Test-Path "$($RECmd)")
        {
            # Check if batch processing file exists
            if (Test-Path "$SCRIPT_DIR\Tools\RECmd_BatchFiles\TerminalServerClient.reb")
            {
                # Analyzing Terminal Server Client (RDP)
                $FilePathList = (Get-ChildItem "$OUTPUT_FOLDER\Registry\Registry" | Where-Object {($_.FullName -match "ntuserdat")} | Foreach-Object FullName)

                ForEach( $FilePath in $FilePathList )
                {
                    $FileName = $FilePath | ForEach-Object{($_ -split "\\")[-1]} | ForEach-Object{($_ -split "\.")[0]}
                    $SID = $FileName | ForEach-Object{($_ -split "_")[1]}

                    # Check if LastVisitedPidlMRU key exists
                    if (Test-Path "$DriveLetter\registry\by-hive\$FileName\ROOT\SOFTWARE\Microsoft\Terminal Server Client")
                    {
                        # CSV
                        New-Item "$OUTPUT_FOLDER\Registry\TerminalServerClient\CSV" -ItemType Directory -Force | Out-Null
                        New-Item "$OUTPUT_FOLDER\Registry\TerminalServerClient\XLSX" -ItemType Directory -Force | Out-Null
                        & $RECmd -f "$FilePath" --bn "$SCRIPT_DIR\Tools\RECmd_BatchFiles\TerminalServerClient.reb" --csv "$OUTPUT_FOLDER\Registry\TerminalServerClient\CSV" --csvf "$SID-TerminalServerClient.csv" > "$OUTPUT_FOLDER\Registry\TerminalServerClient\$SID-TerminalServerClient.log" 2> $null
                        
                        # RegistryPlugin.TerminalServerClient.dll
                        if (Test-Path "$OUTPUT_FOLDER\Registry\TerminalServerClient\CSV\*\$SID-TerminalServerClient_TerminalServerClient.csv")
                        {
                            Move-Item -Path "$OUTPUT_FOLDER\Registry\TerminalServerClient\CSV\*\$SID-TerminalServerClient_TerminalServerClient.csv" -Destination "$OUTPUT_FOLDER\Registry\TerminalServerClient\CSV\$SID-TerminalServerClient_TerminalServerClient.csv"
                            Get-ChildItem -Path "$OUTPUT_FOLDER\Registry\TerminalServerClient\CSV\*" -Directory | ForEach-Object FullName | Remove-Item -Force -Recurse
                        }

                        # Stats
                        if (Test-Path "$OUTPUT_FOLDER\Registry\TerminalServerClient\$SID-TerminalServerClient.log")
                        {
                            # Check if key/value pairs were found
                            if (!(Get-Content -Path "$OUTPUT_FOLDER\Registry\TerminalServerClient\$SID-TerminalServerClient.log" | Select-String -Pattern "Found 0 key/value pairs across 1 file" -Quiet))
                            {
                                # Count
                                $Total = Get-Content "$OUTPUT_FOLDER\Registry\TerminalServerClient\$SID-TerminalServerClient.log" | Select-String -Pattern "key/value pair"
                                Write-Output "[Info]  $Total ($SID)"
                            }
                        }

                        # XLSX

                        # TerminalServerClient.csv
                        if (Test-Path "$OUTPUT_FOLDER\Registry\TerminalServerClient\CSV\$SID-TerminalServerClient.csv")
                        {
                            if([int](& $xsv count "$OUTPUT_FOLDER\Registry\TerminalServerClient\CSV\$SID-TerminalServerClient.csv") -gt 0)
                            {
                                $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\TerminalServerClient\CSV\$SID-TerminalServerClient.csv" -Delimiter "," -Encoding UTF8
                                $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\TerminalServerClient\XLSX\$SID-TerminalServerClient.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "TerminalServerClient" -CellStyleSB {
                                param($WorkSheet)
                                # BackgroundColor and FontColor for specific cells of TopRow
                                $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                                Set-Format -Address $WorkSheet.Cells["A1:O1"] -BackgroundColor $BackgroundColor -FontColor White
                                # HorizontalAlignment "Center" of columns B-D, F-J and L-N
                                $WorkSheet.Cells["B:D"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["F:J"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["L:N"].Style.HorizontalAlignment="Center"
                                }
                            }
                        }

                        # TerminalServerClient_PluginDetailFile.csv
                        if (Test-Path "$OUTPUT_FOLDER\Registry\LastVisitedMRU\CSV\$SID-TerminalServerClient_PluginDetailFile.csv")
                        {
                            if([int](& $xsv count "$OUTPUT_FOLDER\Registry\LastVisitedMRU\CSV\$SID-TerminalServerClient_PluginDetailFile.csv") -gt 0)
                            {
                                $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\LastVisitedMRU\CSV\$SID-TerminalServerClient_PluginDetailFile.csv" -Delimiter "," -Encoding UTF8
                                $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\LastVisitedMRU\XLSX\$SID-TerminalServerClient_PluginDetailFile.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "TerminalServerClient (Plugin)" -CellStyleSB {
                                param($WorkSheet)
                                # BackgroundColor and FontColor for specific cells of TopRow
                                $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                                Set-Format -Address $WorkSheet.Cells["A1:F1"] -BackgroundColor $BackgroundColor -FontColor White
                                # HorizontalAlignment "Center" of columns A, C-F
                                $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                                $WorkSheet.Cells["C:F"].Style.HorizontalAlignment="Center"
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                Write-Host "[Error] TerminalServerClient.reb NOT found." -ForegroundColor Red
            }
        }
        else
        {
            Write-Host "[Error] RECmd.exe NOT found." -ForegroundColor Red
        }

        }

        Get-TerminalServerClient

        # RegistryPlugin.TerminalServerClient.dll

        # Displays the IP addresses/hostnames of devices this system has connected to (Outbound RDP)
        # Default subkey stores previous RDP connection entries the user has connected to.
        # UsernameHint value stores the username used on remote machine during RDP session.

#############################################################################################################################################################################################

        # SBECCmd

        Function Get-ShellBags {

        # Check ShellBags Location
        if ((Test-Path "$OUTPUT_FOLDER\Registry\Registry\*ntuserdat*") -or (Test-Path "$OUTPUT_FOLDER\Registry\Registry\*UsrClassdat*"))
        {
            if (Test-Path "$($SBECmd)")
            {
                Write-Output "[Info]  Analyzing ShellBags Artifacts ... "
                New-Item "$OUTPUT_FOLDER\Registry\ShellBags\CSV" -ItemType Directory -Force | Out-Null
                New-Item "$OUTPUT_FOLDER\Registry\ShellBags\XLSX" -ItemType Directory -Force | Out-Null

                # ShellBags are stored in both NTUSER.DAT and USRCLASS.DAT
                $FilePathList = (Get-ChildItem "$OUTPUT_FOLDER\Registry\Registry" | Where-Object {($_.FullName -match "ntuserdat|UsrClassdat")} | Foreach-Object FullName)

                # Rename Registry Hives temporarily...SBECCmd requires .dat file extension
                Get-ChildItem "$OUTPUT_FOLDER\Registry\Registry" | Where-Object {($_.FullName -match "ntuserdat|UsrClassdat")} | Rename-Item -NewName {$_.Name -replace "\.reghive$",".dat"}

                # CSV
                & $SBECmd -d "$OUTPUT_FOLDER\Registry\Registry" --csv "$OUTPUT_FOLDER\Registry\ShellBags\CSV" --csvf "SBECmd.csv" > "$OUTPUT_FOLDER\Registry\ShellBags\SBECmd.log" 2> $null
                
                # Rename Registry Hives
                Get-ChildItem "$OUTPUT_FOLDER\Registry\Registry" | Where-Object {($_.FullName -match "ntuserdat|UsrClassdat")} | Rename-Item -NewName {$_.Name -replace "\.dat$",".reghive"}

                # Stats
                if (Get-Content "$OUTPUT_FOLDER\Registry\ShellBags\SBECmd.log" | Select-String -Pattern "^Total ShellBags found:" -Quiet)
                {
                    # Error
                    if (Get-Content "$OUTPUT_FOLDER\Registry\ShellBags\SBECmd.log" | Select-String -Pattern "Error processing hbin" -Quiet)
                    {
                        Write-Output "[Info]  ShellBags Artifacts seem to be partially corrupt."
                    }

                    # Total
                    $Total = (Get-Content "$OUTPUT_FOLDER\Registry\ShellBags\SBECmd.log" | Select-String -Pattern "Total ShellBags found:" | Select-Object -Last 1 | Out-String).Trim()
                    Write-Output "[Info]  $Total"
                }

                # XLSX
                $FilePathList = (Get-ChildItem "$OUTPUT_FOLDER\Registry\ShellBags\CSV" | Where-Object {($_.Extension -eq ".csv")} | Foreach-Object FullName)

                ForEach( $FilePath in $FilePathList )
                {
                    $FileName = $FilePath | ForEach-Object{($_ -split "-USER_")[1]} | ForEach-Object{($_ -split "\.csv")[0]}

                    if (Test-Path "$($FilePath)")
                    {
                        if([int](& $xsv count "$FilePath") -gt 0)
                        {
                            New-Item "$OUTPUT_FOLDER\Registry\ShellBags\XLSX" -ItemType Directory -Force | Out-Null
                            $IMPORT = Import-Csv "$FilePath" -Delimiter ","
                            $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\ShellBags\XLSX\$FileName.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "ShellBags" -CellStyleSB {
                            param($WorkSheet)
                            # BackgroundColor and FontColor for specific cells of TopRow
                            $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                            Set-Format -Address $WorkSheet.Cells["A1:S1"] -BackgroundColor $BackgroundColor -FontColor White
                            # HorizontalAlignment "Center" of columns B-D, F and H-S
                            $WorkSheet.Cells["B:D"].Style.HorizontalAlignment="Center"
                            $WorkSheet.Cells["F:F"].Style.HorizontalAlignment="Center"
                            $WorkSheet.Cells["H:S"].Style.HorizontalAlignment="Center"
                            }
                        }
                    }
                }
            }
            else
            {
                Write-Host "[Error] SBECCmd.exe NOT found." -ForegroundColor Red
            }
        }

        }

        Get-ShellBags

#############################################################################################################################################################################################

        # Registry ASEPs (Auto-Start Extensibility Points)
        if (Test-Path "$OUTPUT_FOLDER\Registry\Registry\*.reghive") 
        {
            if (Test-Path "$($RECmd)")
            {
                # Check if batch processing file exists
                if (Test-Path "$SCRIPT_DIR\Tools\RECmd_BatchFiles\RegistryASEPs.reb")
                {
                    Write-Output "[Info]  Extracting Auto-Start Extensibility Points (ASEPs) ... "

                    # CSV
                    New-Item "$OUTPUT_FOLDER\Registry\RegistryASEPs\CSV" -ItemType Directory -Force | Out-Null
                    Get-ChildItem "$OUTPUT_FOLDER\Registry\Registry" | Where-Object {($_.FullName -match "ntuse")} | Rename-Item -NewName {$_.Name -replace "\.reghive$","ntuser.dat"}
                    Get-ChildItem "$OUTPUT_FOLDER\Registry\Registry" | Where-Object {($_.FullName -match "UsrClas")} | Rename-Item -NewName {$_.Name -replace "\.reghive$","UsrClass.dat"}
                    & $RECmd -d "$OUTPUT_FOLDER\Registry\Registry" --bn "$SCRIPT_DIR\Tools\RECmd_BatchFiles\RegistryASEPs.reb" --csv "$OUTPUT_FOLDER\Registry\RegistryASEPs\CSV" --csvf "RegistryASEPs.csv" > "$OUTPUT_FOLDER\Registry\RegistryASEPs\RegistryASEPs.log" 2> $null
                    Get-ChildItem "$OUTPUT_FOLDER\Registry\Registry" | Where-Object {($_.FullName -match "ntuse")} | Rename-Item -NewName {$_.Name -replace "ntuser\.dat$",".reghive"}
                    Get-ChildItem "$OUTPUT_FOLDER\Registry\Registry" | Where-Object {($_.FullName -match "UsrClas")} | Rename-Item -NewName {$_.Name -replace "UsrClass\.dat$",".reghive"}

                    # Stats
                    if (Test-Path "$OUTPUT_FOLDER\Registry\RegistryASEPs\RegistryASEPs.log")
                    {
                        [string]$Total = (Get-Content "$OUTPUT_FOLDER\Registry\RegistryASEPs\RegistryASEPs.log" | Select-String -Pattern "key/value pairs" | Out-String).Trim()
                        Write-Output "[Info]  $Total"
                    }

                    # XSLX
                    New-Item "$OUTPUT_FOLDER\Registry\RegistryASEPs\XLSX" -ItemType Directory -Force | Out-Null
                    if (Test-Path "$OUTPUT_FOLDER\Registry\RegistryASEPs\CSV\RegistryASEPs.csv")
                    {
                        if([int](& $xsv count "$OUTPUT_FOLDER\Registry\RegistryASEPs\CSV\RegistryASEPs.csv") -gt 0)
                        {
                            $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\RegistryASEPs\CSV\RegistryASEPs.csv" -Delimiter ","
                            $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\RegistryASEPs\XLSX\RegistryASEPs.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "RegistryASEPs" -CellStyleSB {
                            param($WorkSheet)
                            # BackgroundColor and FontColor for specific cells of TopRow
                            $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                            Set-Format -Address $WorkSheet.Cells["A1:O1"] -BackgroundColor $BackgroundColor -FontColor White
                            # HorizontalAlignment "Center" of columns B-D, G and L-O
                            $WorkSheet.Cells["B:D"].Style.HorizontalAlignment="Center"
                            $WorkSheet.Cells["G:G"].Style.HorizontalAlignment="Center"
                            $WorkSheet.Cells["L:O"].Style.HorizontalAlignment="Center"
                            }
                        }
                    }
                }
                else
                {
                    Write-Host "[Error] RegistryASEPs.reb NOT found." -ForegroundColor Red
                }
            }
            else
            {
                Write-Host "[Error] RECmd.exe NOT found." -ForegroundColor Red
            }
        }

        # Startup Folders
        if (Test-Path "$DriveLetter\forensic\timeline\timeline_ntfs.txt")
        {
            New-Item "$OUTPUT_FOLDER\Persistence" -ItemType Directory -Force | Out-Null
            $StartupFolders = (Get-Content "$DriveLetter\forensic\timeline\timeline_ntfs.txt" | Select-String -Pattern "\\Start Menu\\Programs\\Startup\\" | Where-Object {$_ -notmatch "desktop.ini"} | Out-String).Trim()
            $StartupFolders | Out-File "$OUTPUT_FOLDER\Persistence\Startup-Folders.txt"
        }

        # SQLite Database
        if (Test-Path "$DriveLetter\forensic\database.txt")
        {
            # Collecting SQLite Database
            $DatabasePath = (Get-Content "$DriveLetter\forensic\database.txt" | Select-String -Pattern "vmm.sqlite3" | Out-String).Trim()
            Write-Output "[Info]  SQLite Database: $DatabasePath"
            Write-Output "[Info]  Collecting SQLite Database ..."
            New-Item "$OUTPUT_FOLDER\database" -ItemType Directory -Force | Out-Null
            Copy-Item -Path "$DatabasePath" -Destination "$OUTPUT_FOLDER\database\vmm.sqlite3"

            # File Size (SQLite3)
            if (Test-Path "$OUTPUT_FOLDER\database\vmm.sqlite3")
            {
                $Size = Get-FileSize((Get-Item "$OUTPUT_FOLDER\database\vmm.sqlite3").Length)
                Write-Output "[Info]  File Size (SQLite3): $Size"
            }
        }

        # MemProcFS Plugins
        # https://github.com/ufrisk/MemProcFS-plugins

        # pypykatz
        # https://github.com/skelsec/pypykatz
        if (Test-Path "$DriveLetter\py\secrets\*")
        {
            Write-Output "[Info]  Collecting pypykatz ... "
            New-Item "$OUTPUT_FOLDER\MemProcFS-Plugins\pypykatz" -ItemType Directory -Force | Out-Null
            Copy-Item -Recurse -Force "$DriveLetter\py\secrets\*" "$OUTPUT_FOLDER\MemProcFS-Plugins\pypykatz" 2>&1 | Out-Null
        }

        # regsecrets
        # https://github.com/skelsec/pypykatz
        if (Test-Path "$DriveLetter\py\regsecrets\*")
        {
            Write-Output "[Info]  Collecting regsecrets ... "
            New-Item "$OUTPUT_FOLDER\MemProcFS-Plugins\regsecrets" -ItemType Directory -Force | Out-Null
            Copy-Item -Recurse -Force "$DriveLetter\py\regsecrets\*" "$OUTPUT_FOLDER\MemProcFS-Plugins\regsecrets" 2>&1 | Out-Null
        }
    }
    else
    {
        Write-Host "[Error] Forensic Directory doesn't exist." -ForegroundColor Red
    }
}
else
{
    Write-Host "[Error] MemProcFS.exe NOT found." -ForegroundColor Red
    Stop-Transcript
    $Host.UI.RawUI.WindowTitle = "$DefaultWindowsTitle"
    Exit
}

}

#endregion MemProcFS

#############################################################################################################################################################################################
#############################################################################################################################################################################################

#region ELKImport

Function ELKImport {

# Elastic-Import
if (Test-Path "$DriveLetter\forensic\json\elastic_import.ps1")
{
    # Copy elastic_import.ps1 to a trusted location (to avoid security warning)
    Copy-Item -Path "$DriveLetter\forensic\json\elastic_import.ps1" -Destination "$SCRIPT_DIR\elastic_import.ps1"

    # ELK Import
    Write-Output "[Info]  Importing JSON data to Elasticsearch [approx. 1-5 min] ... "
    $Elastic_Import = "$SCRIPT_DIR\elastic_import.ps1"
    $Argument = $DriveLetter.TrimEnd(":")
    Start-Process -FilePath "powershell" -Verb RunAs -Wait -ArgumentList "-File $Elastic_Import", "$Argument"

    # Cleaning up
    if (Test-Path "$($Elastic_Import)")
    {
        Remove-Item "$Elastic_Import" -Force
    }

    try 
    {
        # Open Kibana w/ Google Chrome
        $Chrome = ((Get-Item (Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\chrome.exe")."(Default)").VersionInfo).FileName
        Start-Process -FilePath $Chrome -ArgumentList "http://localhost:5601"
    }
    catch 
    {
        # Open Kibana in your Default Browser
        Start-Process "http://localhost:5601"
    }
}

}

#endregion ELKImport

#############################################################################################################################################################################################
#############################################################################################################################################################################################

#region MicrosoftDefender

Function MicrosoftDefender {

# Turning Microsoft Defender AntiVirus off (Real-Time Protection)
# Note: Tamper Protection must be disabled.
if ((Get-MpComputerStatus).RealTimeProtectionEnabled)
{
    # Real-Time Protection Activation Status
    $DisableRealtimeMonitoring = ((Get-MpPreference | Select-Object DisableRealtimeMonitoring).DisableRealtimeMonitoring | Out-String).Trim()
    if ($DisableRealtimeMonitoring -eq "False")
    {
        # Disable Real-Time Protection
        Write-Output "[Info]  Microsoft Defender (Real-Time Protection) will be disabled temporarily ..."
        try { Set-MpPreference -DisableRealtimeMonitoring $true }
        catch [Microsoft.Management.Infrastructure.CimException] { Write-Host $Error[0].Exception.InnerException.Message }
        catch { }
        Start-Sleep 10
    }
}

}

#endregion MicrosoftDefender

#############################################################################################################################################################################################
#############################################################################################################################################################################################

#region ClamAVUpdate

Function ClamAVUpdate {

# ClamAVUpdate

# freshclam.conf
if (!(Test-Path "C:\Program Files\ClamAV\freshclam.conf"))
{
    Write-Host "[Error] freshclam.conf is missing." -ForegroundColor Red
    Write-Host "        https://docs.clamav.net/manual/Usage/Configuration.html#windows --> First Time Set-Up" -ForegroundColor Red
    Stop-Transcript
    $Host.UI.RawUI.WindowTitle = "$DefaultWindowsTitle"
    Exit
}

# clamd.conf
if (!(Test-Path "C:\Program Files\ClamAV\clamd.conf"))
{
    Write-Host "[Error] clamd.conf is missing." -ForegroundColor Red
    Write-Host "        https://docs.clamav.net/manual/Usage/Configuration.html#windows --> First Time Set-Up" -ForegroundColor Red
    Stop-Transcript
    $Host.UI.RawUI.WindowTitle = "$DefaultWindowsTitle"
    Exit
}

# Update
if (Test-Path "$($freshclam)")
{
    if ($null -eq $OfflineMode)
    {  
        # Internet Connectivity Check (Vista+)
        $NetworkListManager = [Activator]::CreateInstance([Type]::GetTypeFromCLSID([Guid]‘{DCB00C01-570F-4A9B-8D69-199FDBA5723B}’)).IsConnectedToInternet

        if (!($NetworkListManager -eq "True"))
        {
            Write-Host "[Error] Your computer is NOT connected to the Internet. ClamAV cannot check for any updates." -ForegroundColor Red
        }
        else
        {
            # Check if clamav.net is reachable
            if (!(Test-Connection -ComputerName clamav.net -Count 1 -Quiet))
            {
                Write-Host "[Error] clamav.net is NOT reachable. ClamAV cannot check for any updates." -ForegroundColor Red
            }
            else
            {
                Write-Output "[Info]  Checking for ClamAV Updates ..."
                New-Item "$OUTPUT_FOLDER\ClamAV" -ItemType Directory -Force | Out-Null
                & $freshclam > "$OUTPUT_FOLDER\ClamAV\Update.txt" 2> "$OUTPUT_FOLDER\ClamAV\Warning.txt"

                # Update ClamAV Engine
                if (Select-String -Pattern "WARNING: Your ClamAV installation is OUTDATED!" -Path "$OUTPUT_FOLDER\ClamAV\Warning.txt" -Quiet)
                {
                    Write-Host "[Info]  WARNING: Your ClamAV installation is OUTDATED!" -ForegroundColor Red

                    if (Select-String -Pattern "Recommended version:" -Path "$OUTPUT_FOLDER\ClamAV\Warning.txt" -Quiet)
                    {
                        $WARNING = Get-Content "$OUTPUT_FOLDER\ClamAV\Warning.txt" | Select-String -Pattern "Recommended version:"
                        Write-Host "[Info]  $WARNING" -ForegroundColor Red
                    }
                }

                # Update Signature Databases
                $Count = (Get-Content "$OUTPUT_FOLDER\ClamAV\Update.txt" | Select-String -Pattern "is up to date" | Measure-Object).Count
                if ($Count -match "3")
                {
                    Write-Output "[Info]  All ClamAV Virus Databases (CVD) are up-to-date."
                }
                else
                {
                    Write-Output "[Info]  Updating ClamAV Virus Databases (CVD) ... "
                }
            }
        }
    }
    else
    {
        Write-Output "[Info]  ClamAV Updates will be skipped [Offline-Mode] ..."
    }
}
else
{
    Write-Host "[Error] freshclam.exe NOT found." -ForegroundColor Red
}

# Engine Version
if (Test-Path "$($clamscan)")
{
    $Version = & $clamscan -V
    $EngineVersion = $Version.Split('/')[0]
    $Patch = $Version.Split('/')[1]
    Write-Output "[Info]  Engine Version: $EngineVersion (#$Patch)"
    New-Item "$OUTPUT_FOLDER\ClamAV" -ItemType Directory -Force | Out-Null
    $Version | Out-File "$OUTPUT_FOLDER\ClamAV\Version.txt"
}
else
{
    Write-Host "[Error] clamscan.exe NOT found." -ForegroundColor Red
}

}

#endregion ClamAVUpdate

#############################################################################################################################################################################################
#############################################################################################################################################################################################

#region ClamAV

Function ClamAV {

# ClamAV

# Custom Scan
# Note: By default ClamAV will not scan files larger than 100MB.
$ScanPath1 = "$DriveLetter\name"
$ScanPath2 = "$DriveLetter\forensic\files"

# Start ClamAV Daemon
if (Test-Path "$($clamd)")
{
    if (Test-Path "$($clamdscan)")
    {
        Write-Output "[Info]  Starting ClamAV Daemon ..."
        Start-Process powershell.exe -FilePath "$clamd" -WindowStyle Minimized
        $ProgressPreference = 'SilentlyContinue'
        do {
          Start-Sleep -Seconds 5
        } until (Test-NetConnection 127.0.0.1 -Port 3310 -InformationLevel Quiet -WarningAction SilentlyContinue )
        Write-Output "[Info]  ClamAV Daemon is running ... "

        # Get Start Time
        $StartTime_ClamAV = (Get-Date)

        # ClamAV Daemon Scan (Multi-Threaded)
        Write-Output "[Info]  Custom scan w/ ClamAV is running [time-consuming task] ..."
        New-Item "$OUTPUT_FOLDER\ClamAV" -ItemType Directory -Force | Out-Null
        $LogFile = "$OUTPUT_FOLDER\ClamAV\LogFile.txt"
        Start-Process -FilePath "$clamdscan" -ArgumentList "$ScanPath1 $ScanPath2 --quiet --multiscan --log=$LogFile" -WindowStyle Minimized -Wait
        Stop-Process -Name "clamdscan" -ErrorAction SilentlyContinue
        Stop-Process -Name "clamd" -ErrorAction SilentlyContinue

        # Get End Time
        $EndTime_ClamAV = (Get-Date)

        # Scan Duration
        $Time_ClamAV = ($EndTime_ClamAV-$StartTime_ClamAV)
        ('ClamAV Scan duration:          {0} h {1} min {2} sec' -f $Time_ClamAV.Hours, $Time_ClamAV.Minutes, $Time_ClamAV.Seconds) >> "$OUTPUT_FOLDER\Stats.txt"

        # ClamAV Detection(s)

        # FOUND (Infected Files)
        New-Item "$OUTPUT_FOLDER\ClamAV\Infected" -ItemType Directory -Force | Out-Null
        $InfectedFilesCount = (Get-Content $LogFile | Select-String -Pattern "FOUND" -CaseSensitive | Select-String -Pattern "Heuristics.Encrypted.* FOUND" -NotMatch | Measure-Object).Count
        $InfectedFilesMatches = Get-Content $LogFile | Select-String -Pattern "FOUND" -CaseSensitive | Select-String -Pattern "Heuristics.Encrypted.* FOUND" -NotMatch
        if ($InfectedFilesCount -eq "0")
        {
            Write-Host "[Info]  0 infected file(s) found" -ForegroundColor Green
        }
        else
        {
            ($InfectedFilesMatches | Out-String).Trim() | Out-File "$OUTPUT_FOLDER\ClamAV\Infected\InfectedFiles.txt"

            # Whitelist
            # MsMpEng.exe   = Microsoft Defender
            # cyserver.exe  = Palo Alto Cortex XDR
            # tlaworker.exe = Palo Alto Cortex XDR
            $Whitelist = "(cyserver.exe|MsMpEng.exe|tlaworker.exe)"
            Get-Content "$OUTPUT_FOLDER\ClamAV\Infected\InfectedFiles.txt" | Where-Object {$_ -notmatch "$Whitelist"} | Out-File "$OUTPUT_FOLDER\ClamAV\Infected\InfectedFiles-filtered.txt"
            $FilteredCount = (Get-Content "$OUTPUT_FOLDER\ClamAV\Infected\InfectedFiles-filtered.txt" | Measure-Object).Count
            Write-Host "[Alert] $FilteredCount infected file(s) found ($InfectedFilesCount)" -ForegroundColor Red
        }

        # Collect Infected Files
        if (Test-Path "$OUTPUT_FOLDER\ClamAV\Infected\InfectedFiles-filtered.txt")
        {
            $InfectedFiles = Get-Content "$OUTPUT_FOLDER\ClamAV\Infected\InfectedFiles-filtered.txt" | ForEach-Object{($_ -split ": ")[0]}
            New-Item "$OUTPUT_FOLDER\ClamAV\Infected\Infected" -ItemType Directory -Force | Out-Null

            ForEach( $InfectedFile in $InfectedFiles )
            {
                $ProcessID = $InfectedFile | ForEach-Object{($_ -split "\\")[2]} | ForEach-Object{($_ -split "-")[-1]}
                $INFECTED = "infected"
                $ArchiveName = $InfectedFile | ForEach-Object{($_ -split "\\")[-1]} | ForEach-Object{($_ -split "_INJECTED-")[-1]}
                & $7za a -mx5 -mhe "-p$INFECTED" -t7z "$OUTPUT_FOLDER\ClamAV\Infected\Infected\$ProcessID-$ArchiveName.7z" "$InfectedFile" > $null 2>&1
            }
        }

        # Stop ClamAV Daemon
        Stop-Process -Name "clamd" -ErrorAction SilentlyContinue
    }
    else
    {
        Write-Host "[Error] clamdscan.exe NOT found." -ForegroundColor Red
    }
}
else
{
    Write-Host "[Error] clamd.exe NOT found." -ForegroundColor Red
}

}

#endregion ClamAV

#############################################################################################################################################################################################
#############################################################################################################################################################################################

#region Documents

Function Documents {

# RecentDocs
if (Test-Path "$OUTPUT_FOLDER\Registry\Registry\*.reghive") 
{
    if (Test-Path "$($RECmd)")
    {
        # Check if batch processing file exists
        if (Test-Path "$SCRIPT_DIR\Tools\RECmd_BatchFiles\RecentDocs.reb")
        {
            # Check if Registry Plugin exists
            if (Test-Path "$SCRIPT_DIR\Tools\RECmd\Plugins\RegistryPlugin.RecentDocs.dll")
            {
                # Analyzing RecentDocs Artifacts
                Write-Output "[Info]  Analyzing RecentDocs Artifacts ... "
                New-Item "$OUTPUT_FOLDER\Registry\RecentDocs\CSV" -ItemType Directory -Force | Out-Null
                New-Item "$OUTPUT_FOLDER\Registry\RecentDocs\XLSX" -ItemType Directory -Force | Out-Null

                # CSV
                $FilePathList = (Get-ChildItem "$OUTPUT_FOLDER\Registry\Registry" | Where-Object {($_.FullName -match "ntuserdat")} | Foreach-Object FullName)

                ForEach( $FilePath in $FilePathList )
                {
                    $FileName = $FilePath | ForEach-Object{($_ -split "\\")[-1]} | ForEach-Object{($_ -split "\.reghive$")[0]}
                    $SID = $FileName | ForEach-Object{($_ -split "_")[1]}

                    # Check if RecentDocs key exists
                    if (Test-Path "$DriveLetter\registry\by-hive\$FileName\ROOT\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\RecentDocs")
                    {
                        & $RECmd -f "$FilePath" --bn "$SCRIPT_DIR\Tools\RECmd_BatchFiles\RecentDocs.reb" --csv "$OUTPUT_FOLDER\Registry\RecentDocs\CSV" --csvf "$SID-RecentDocs.csv" > "$OUTPUT_FOLDER\Registry\RecentDocs\$SID-RecentDocs.log" 2> $null
                    }

                    # Stats
                    if (Test-Path "$OUTPUT_FOLDER\Registry\RecentDocs\$SID-RecentDocs.log")
                    {
                        # Check for parsing error
                        if (!(Get-Content -Path "$OUTPUT_FOLDER\Registry\RecentDocs\$SID-RecentDocs.log" | Select-String -Pattern "parse error" -Quiet))
                        {
                            # Check if key/value pairs were found
                            if (!(Get-Content -Path "$OUTPUT_FOLDER\Registry\RecentDocs\$SID-RecentDocs.log" | Select-String -Pattern "Found 0 key/value pairs across 1 file" -Quiet))
                            {
                                $Total = Get-Content "$OUTPUT_FOLDER\Registry\RecentDocs\$SID-RecentDocs.log" | Select-String -Pattern "key/value pairs"
                                Write-Host "[Info]  $Total ($SID)"
                            }
                            else
                            {
                                if ($SID)
                                {
                                    Write-Output "[Info]  Found 0 key/value pairs across 1 file ($SID)"
                                }
                                else
                                {
                                    Write-Output "[Info]  Found 0 key/value pairs across 1 file"
                                }
                            }
                        }
                    }
                    
                    # XLSX
                    if (Test-Path "$OUTPUT_FOLDER\Registry\RecentDocs\CSV\$SID-RecentDocs.csv")
                    {
                        if([int](& $xsv count "$OUTPUT_FOLDER\Registry\RecentDocs\CSV\$SID-RecentDocs.csv") -gt 0)
                        {
                            $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\RecentDocs\CSV\$SID-RecentDocs.csv" -Delimiter "," | Sort-Object { $_.LastWriteTimestamp -as [datetime] } -Descending
                            $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\RecentDocs\XLSX\$SID-RecentDocs.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "RecentDocs" -CellStyleSB {
                            param($WorkSheet)
                            # BackgroundColor and FontColor for specific cells of TopRow
                            $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                            Set-Format -Address $WorkSheet.Cells["A1:O1"] -BackgroundColor $BackgroundColor -FontColor White
                            # HorizontalAlignment "Center" of columns B, D, F-G and J-N
                            $WorkSheet.Cells["B:B"].Style.HorizontalAlignment="Center"
                            $WorkSheet.Cells["D:D"].Style.HorizontalAlignment="Center"
                            $WorkSheet.Cells["F:G"].Style.HorizontalAlignment="Center"
                            $WorkSheet.Cells["J:N"].Style.HorizontalAlignment="Center"
                            }
                        }
                    }

                    # RecentDocs_RecentDocs.csv
                    if (Test-Path "$OUTPUT_FOLDER\Registry\RecentDocs\CSV\*\$SID-RecentDocs_RecentDocs.csv")
                    {
                        if((Get-Item "$OUTPUT_FOLDER\Registry\RecentDocs\CSV\*\$SID-RecentDocs_RecentDocs.csv").length -gt 0kb)
                        {
                            New-Item "$OUTPUT_FOLDER\Registry\RecentDocs\XLSX" -ItemType Directory -Force | Out-Null
                            $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\RecentDocs\CSV\*\$SID-RecentDocs_RecentDocs.csv" -Delimiter ","
                            $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\RecentDocs\XLSX\$SID-RecentDocs_RecentDocs.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "RecentDocs (Plugin)" -CellStyleSB {
                            param($WorkSheet)
                            # BackgroundColor and FontColor for specific cells of TopRow
                            $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                            Set-Format -Address $WorkSheet.Cells["A1:I1"] -BackgroundColor $BackgroundColor -FontColor White
                            # HorizontalAlignment "Center" of columns A, C-D and G-I
                            $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                            $WorkSheet.Cells["C:D"].Style.HorizontalAlignment="Center"
                            $WorkSheet.Cells["G:I"].Style.HorizontalAlignment="Center"
                            }
                        }
                    }
                }
            }
            else
            {
                Write-Host "[Error] RegistryPlugin.RecentDocs.dll NOT found." -ForegroundColor Red
            }
        }
        else
        {
            Write-Host "[Error] RecentDocs.reb NOT found." -ForegroundColor Red
        }
    }
    else
    {
        Write-Host "[Error] RECmd.exe NOT found." -ForegroundColor Red
    }
}

# Office Trusted Documents
if (Test-Path "$OUTPUT_FOLDER\Registry\Registry\*.reghive") 
{
    if (Test-Path "$($RECmd)")
    {
        # Check if batch processing file exists
        if (Test-Path "$SCRIPT_DIR\Tools\RECmd_BatchFiles\TrustedDocuments.reb")
        {
            # Check if Registry Plugin exists
            if (Test-Path "$SCRIPT_DIR\Tools\RECmd\Plugins\RegistryPlugin.TrustedDocuments.dll")
            {
                # Analyzing Trusted Documents Artifacts
                Write-Output "[Info]  Analyzing Trusted Documents Artifacts ... "
                New-Item "$OUTPUT_FOLDER\Registry\TrustedDocuments\CSV" -ItemType Directory -Force | Out-Null
                New-Item "$OUTPUT_FOLDER\Registry\TrustedDocuments\XLSX" -ItemType Directory -Force | Out-Null

                # CSV
                $FilePathList = (Get-ChildItem "$OUTPUT_FOLDER\Registry\Registry" | Where-Object {($_.FullName -match "ntuserdat")} | Foreach-Object FullName)

                ForEach( $FilePath in $FilePathList )
                {
                    $FileName = $FilePath | ForEach-Object{($_ -split "\\")[-1]} | ForEach-Object{($_ -split "\.reghive$")[0]}
                    $SID = $FileName | ForEach-Object{($_ -split "_")[1]}

                    # Check if TrustedDocuments key exists
                    if (Test-Path "$DriveLetter\registry\by-hive\$FileName\ROOT\SOFTWARE\Microsoft\Office\*\*\Security\Trusted Documents\TrustRecords")
                    {
                        & $RECmd -f "$FilePath" --bn "$SCRIPT_DIR\Tools\RECmd_BatchFiles\TrustedDocuments.reb" --csv "$OUTPUT_FOLDER\Registry\TrustedDocuments\CSV" --csvf "$SID-TrustedDocuments.csv" > "$OUTPUT_FOLDER\Registry\TrustedDocuments\$SID-TrustedDocuments.log" 2> $null
                    }

                    # Stats
                    if (Test-Path "$OUTPUT_FOLDER\Registry\TrustedDocuments\$SID-TrustedDocuments.log")
                    {
                        $Total = Get-Content "$OUTPUT_FOLDER\Registry\TrustedDocuments\$SID-TrustedDocuments.log" | Select-String -Pattern "key/value pair"
                        Write-Host "[Info]  $Total ($SID)"
                    }
                    else
                    {
                        if ($SID)
                        {
                            Write-Output "[Info]  Found 0 key/value pairs across 1 file ($SID)"
                        }
                        else
                        {
                            Write-Output "[Info]  Found 0 key/value pairs across 1 file"
                        }
                    }

                    # XLSX
                    if (Test-Path "$OUTPUT_FOLDER\Registry\TrustedDocuments\CSV\$SID-TrustedDocuments.csv")
                    {
                        if([int](& $xsv count "$OUTPUT_FOLDER\Registry\TrustedDocuments\CSV\$SID-TrustedDocuments.csv") -gt 0)
                        {
                            $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\TrustedDocuments\CSV\$SID-TrustedDocuments.csv" -Delimiter "," | Sort-Object { $_.LastWriteTimestamp -as [datetime] } -Descending
                            $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\TrustedDocuments\XLSX\$SID-TrustedDocuments.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "TrustedDocuments" -CellStyleSB {
                            param($WorkSheet)
                            # BackgroundColor and FontColor for specific cells of TopRow
                            $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                            Set-Format -Address $WorkSheet.Cells["A1:O1"] -BackgroundColor $BackgroundColor -FontColor White
                            # HorizontalAlignment "Center" of columns B, D, F-G and J-N
                            $WorkSheet.Cells["B:B"].Style.HorizontalAlignment="Center"
                            $WorkSheet.Cells["D:D"].Style.HorizontalAlignment="Center"
                            $WorkSheet.Cells["F:G"].Style.HorizontalAlignment="Center"
                            $WorkSheet.Cells["J:N"].Style.HorizontalAlignment="Center"
                            }
                        }
                    }

                    # TrustedDocuments_TrustedDocuments.csv
                    if (Test-Path "$OUTPUT_FOLDER\Registry\TrustedDocuments\CSV\*\$SID-TrustedDocuments_TrustedDocuments.csv")
                    {
                        $FilePath = Get-ChildItem -Path "$OUTPUT_FOLDER\Registry\TrustedDocuments\CSV\*\$SID-TrustedDocuments_TrustedDocuments.csv" | Foreach-Object FullName
                        if([int](& $xsv count "$FilePath") -gt 0)
                        {
                            New-Item "$OUTPUT_FOLDER\Registry\TrustedDocuments\XLSX" -ItemType Directory -Force | Out-Null
                            $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\TrustedDocuments\CSV\*\$SID-TrustedDocuments_TrustedDocuments.csv" -Delimiter "," | Sort-Object { $_.Timestamp -as [datetime] } -Descending
                            $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\TrustedDocuments\XLSX\$SID-TrustedDocuments_TrustedDocuments.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "TrustedDocuments (Plugin)" -CellStyleSB {
                            param($WorkSheet)
                            # BackgroundColor and FontColor for specific cells of TopRow
                            $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                            Set-Format -Address $WorkSheet.Cells["A1:F1"] -BackgroundColor $BackgroundColor -FontColor White
                            # HorizontalAlignment "Center" of columns A, C, and F
                            $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                            $WorkSheet.Cells["C:C"].Style.HorizontalAlignment="Center"
                            $WorkSheet.Cells["F:F"].Style.HorizontalAlignment="Center"
                            }
                        }
                    }
                }
            }
            else
            {
                Write-Host "[Error] RegistryPlugin.TrustedDocuments.dll NOT found." -ForegroundColor Red
            }
        }
        else
        {
            Write-Host "[Error] TrustedDocuments.reb NOT found." -ForegroundColor Red
        }
    }
    else
    {
        Write-Host "[Error] RECmd.exe NOT found." -ForegroundColor Red
    }
}

}

#endregion Documents

#############################################################################################################################################################################################
#############################################################################################################################################################################################

#region DFIR_Batch

Function DFIRBatch {

# DFIR RECmd Batch File v2.11 (2025-03-31)
# https://github.com/EricZimmerman/RECmd/blob/master/BatchExamples/DFIRBatch.md
# https://github.com/EricZimmerman/RECmd/blob/master/BatchExamples/DFIRBatch.reb
# https://github.com/AndrewRathbun
if (Test-Path "$OUTPUT_FOLDER\Registry\Registry\*.reghive") 
{
    if (Test-Path "$($RECmd)")
    {
        # Check if batch processing file exists
        if (Test-Path "$SCRIPT_DIR\Tools\RECmd\BatchExamples\DFIRBatch.reb")
        {
            # Sync for RECmd Batch Files
            Write-Output "[Info]  Updating RECmd Batch Files ... "
            & $RECmd --sync > "$SCRIPT_DIR\Tools\RECmd\Sync.log" 2> $null

            # No new batch files available
            if (Test-Path "$SCRIPT_DIR\Tools\RECmd\Sync.log")
            {
                if (Get-Content "$SCRIPT_DIR\Tools\RECmd\Sync.log" | Select-String -Pattern "No new batch files available" -Quiet)
                {
                    Write-Output "[Info]  No new RECmd Batch Files available."
                }
            }

            # Updates found!
            if (Test-Path "$SCRIPT_DIR\Tools\RECmd\Sync.log")
            {
                if (Get-Content "$SCRIPT_DIR\Tools\RECmd\Sync.log" | Select-String -Pattern "Updates found!" -Quiet)
                {
                    Write-Output "[Info]  RECmd Batch Files updated."
                }
            }

            # Analyzing Registry Hives w/ RECmd (DFIR Batch)
            Write-Output "[Info]  Analyzing Registry Hives w/ RECmd (DFIR Batch) ... "
            New-Item "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV" -ItemType Directory -Force | Out-Null

            # CSV
            Get-ChildItem "$OUTPUT_FOLDER\Registry\Registry" | Where-Object {($_.FullName -match "ntuse")} | Rename-Item -NewName {$_.Name -replace "\.reghive$","ntuser.dat"}
            Get-ChildItem "$OUTPUT_FOLDER\Registry\Registry" | Where-Object {($_.FullName -match "UsrClas")} | Rename-Item -NewName {$_.Name -replace "\.reghive$","UsrClass.dat"}
            Get-ChildItem "$OUTPUT_FOLDER\Registry\Registry" | Rename-Item -NewName {$_.Name -replace "\.reghive$",""}
            & $RECmd -d "$OUTPUT_FOLDER\Registry\Registry" --bn "$SCRIPT_DIR\Tools\RECmd\BatchExamples\DFIRBatch.reb" --csv "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV" --csvf "DFIR.csv" > "$OUTPUT_FOLDER\Registry\DFIRBatch\DFIR_Batch.log" 2> $null
            Get-ChildItem "$OUTPUT_FOLDER\Registry\Registry" | Where-Object {($_.FullName -match "ntuse")} | Rename-Item -NewName {$_.Name -replace "ntuser\.dat$",".reghive"}
            Get-ChildItem "$OUTPUT_FOLDER\Registry\Registry" | Where-Object {($_.FullName -match "UsrClas")} | Rename-Item -NewName {$_.Name -replace "UsrClass\.dat$",".reghive"}
            Get-ChildItem "$OUTPUT_FOLDER\Registry\Registry" | Where-Object {($_.FullName -notmatch "\.reghive$")} | Rename-Item -NewName { $PSItem.Name + ".reghive" }

            # Rename PluginDetailFiles Directory
            $Directory = (Get-ChildItem "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV" -Directory | Select-Object FullName).FullName
            if ($Directory)
            {
                if (Test-Path "$($Directory)")
                {
                    Rename-Item -Path "$Directory" -NewName "PluginDetailFiles" -Force
                }
            }

            # Stats
            if (Test-Path "$OUTPUT_FOLDER\Registry\DFIRBatch\DFIR_Batch.log")
            {
                $Total = Get-Content "$OUTPUT_FOLDER\Registry\DFIRBatch\DFIR_Batch.log" | Select-String -Pattern "key/value pair"
                Write-Host "[Info]  $Total"
            }

            # XLSX

            # DFIR.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\DFIR.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\DFIR.csv") -gt 0)
                {
                    New-Item "$OUTPUT_FOLDER\Registry\DFIRBatch\XLSX" -ItemType Directory -Force | Out-Null
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\DFIR.csv" -Delimiter "," | Sort-Object { $_.LastWriteTimestamp -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\DFIRBatch\XLSX\DFIR.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "DFIR_Batch" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:O1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns B-D, G and L-N
                    $WorkSheet.Cells["B:D"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["G:G"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:N"].Style.HorizontalAlignment="Center"
                    # HorizontalAlignment "Left" of columns H-J
                    $WorkSheet.Cells["H:J"].Style.HorizontalAlignment="Left"
                    }
                }
            }

            # PluginDetailFiles
            New-Item "$OUTPUT_FOLDER\Registry\DFIRBatch\XLSX\PluginDetailFiles" -ItemType Directory -Force | Out-Null

            # DFIR_Adobe.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_Adobe.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_Adobe.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_Adobe.csv" -Delimiter "," | Sort-Object { $_.LastOpened -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\DFIRBatch\XLSX\PluginDetailFiles\DFIR_Adobe.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "DFIR_Adobe" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:J1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A, C-D, F and I-J
                    $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["C:D"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["F:F"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["I:J"].Style.HorizontalAlignment="Center"
                    # HorizontalAlignment "Right" of column H
                    $WorkSheet.Cells["H:H"].Style.HorizontalAlignment="Right"
                    # HorizontalAlignment "Center" of header of column H
                    $WorkSheet.Cells["H1:H1"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # DFIR_AppCompat.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_AppCompat.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_AppCompat.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_AppCompat.csv" -Delimiter "," | Sort-Object { $_.LastOpened -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\DFIRBatch\XLSX\PluginDetailFiles\DFIR_AppCompat.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "DFIR_AppCompat" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:E1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A and D-E
                    $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["D:E"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # DFIR_AppCompatFlags2.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_AppCompatFlags2.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_AppCompatFlags2.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_AppCompatFlags2.csv" -Delimiter ","
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\DFIRBatch\XLSX\PluginDetailFiles\DFIR_AppCompatFlags2.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "DFIR_AppCompatFlags2" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:C1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of column C
                    $WorkSheet.Cells["C:C"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # DFIR_AppPaths.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_AppPaths.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_AppPaths.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_AppPaths.csv" -Delimiter "," | Sort-Object { $_.Timestamp -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\DFIRBatch\XLSX\PluginDetailFiles\DFIR_AppPaths.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "DFIR_AppPaths" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:F1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A nd D
                    $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["D:D"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # DFIR_BamDam.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_BamDam.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_BamDam.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_BamDam.csv" -Delimiter "," | Sort-Object { $_.ExecutionTime -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\DFIRBatch\XLSX\PluginDetailFiles\DFIR_BamDam.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "DFIR_BamDam" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:D1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of column C
                    $WorkSheet.Cells["C:C"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # DFIR_CIDSizeMRU.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_CIDSizeMRU.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_CIDSizeMRU.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_CIDSizeMRU.csv" -Delimiter ","
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\DFIRBatch\XLSX\PluginDetailFiles\DFIR_CIDSizeMRU.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "DFIR_CIDSizeMRU" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:E1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns C-E
                    $WorkSheet.Cells["C:E"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # DFIR_DeviceClasses.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_DeviceClasses.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_DeviceClasses.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_DeviceClasses.csv" -Delimiter "," | Sort-Object { $_.Timestamp -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\DFIRBatch\XLSX\PluginDetailFiles\DFIR_DeviceClasses.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "DFIR_DeviceClasses" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:G1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A and C-G
                    $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["C:G"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # DFIR_ETW.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_ETW.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_ETW.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_ETW.csv" -Delimiter ","
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\DFIRBatch\XLSX\PluginDetailFiles\DFIR_ETW.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "DFIR_ETW" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:G1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A, C-D and F-G
                    $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["C:D"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["F:G"].Style.HorizontalAlignment="Center"
                    }
                }
            }            

            # DFIR_FileExts.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_FileExts.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_FileExts.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_FileExts.csv" -Delimiter ","
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\DFIRBatch\XLSX\PluginDetailFiles\DFIR_FileExts.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "DFIR_FileExts" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:F1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A and D-F
                    $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["D:F"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # DFIR_FirewallRules.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_FirewallRules.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_FirewallRules.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_FirewallRules.csv" -Delimiter "," | Sort-Object { $_.OpenedOn -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\DFIRBatch\XLSX\PluginDetailFiles\DFIR_FirewallRules.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "DFIR_FirewallRules" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:K1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A and C-H
                    $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["C:H"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # DFIR_FirstFolder.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_FirstFolder.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_FirstFolder.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_FirstFolder.csv" -Delimiter "," | Sort-Object { $_.OpenedOn -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\DFIRBatch\XLSX\PluginDetailFiles\DFIR_FirstFolder.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "DFIR_FirstFolder" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:F1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns C-F
                    $WorkSheet.Cells["C:F"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # DFIR_JumplistData.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_JumplistData.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_JumplistData.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_JumplistData.csv" -Delimiter "," | Sort-Object { $_.ExecutedOn -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\DFIRBatch\XLSX\PluginDetailFiles\DFIR_JumplistData.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "DFIR_JumplistData" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:D1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of column C
                    $WorkSheet.Cells["C:C"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # DFIR_KnownNetworks.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_KnownNetworks.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_KnownNetworks.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_KnownNetworks.csv" -Delimiter "," | Sort-Object { $_.LastConnectedLOCAL -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\DFIRBatch\XLSX\PluginDetailFiles\DFIR_KnownNetworks.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "DFIR_KnownNetworks" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:K1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A and C-K
                    $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["C:K"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # DFIR_LastVisitedPidlMRU.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_LastVisitedPidlMRU.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_LastVisitedPidlMRU.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_LastVisitedPidlMRU.csv" -Delimiter "," | Sort-Object { $_.OpenedOn -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\DFIRBatch\XLSX\PluginDetailFiles\DFIR_LastVisitedPidlMRU.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "DFIR_LastVisitedPidlMRU" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:H1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A, C-E and G
                    $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["C:E"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["G:G"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # DFIR_MountedDevices.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_MountedDevices.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_MountedDevices.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_MountedDevices.csv" -Delimiter "," | Sort-Object { $_.OpenedOn -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\DFIRBatch\XLSX\PluginDetailFiles\DFIR_MountedDevices.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "DFIR_MountedDevices" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:D1"] -BackgroundColor $BackgroundColor -FontColor White
                    }
                }
            }

            # DFIR_NetworkAdapters.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_NetworkAdapters.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_NetworkAdapters.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_NetworkAdapters.csv" -Delimiter "," | Sort-Object { $_.Timestamp -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\DFIRBatch\XLSX\PluginDetailFiles\DFIR_NetworkAdapters.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "DFIR_NetworkAdapters" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:H1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A and D-G
                    $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["D:G"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # DFIR_NetworkSetup2.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_NetworkSetup2.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_NetworkSetup2.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_NetworkSetup2.csv" -Delimiter "," | Sort-Object { $_.Timestamp -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\DFIRBatch\XLSX\PluginDetailFiles\DFIR_NetworkSetup2.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "DFIR_NetworkSetup2" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:H1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns C-H
                    $WorkSheet.Cells["C:H"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # DFIR_OpenSavePidlMRU.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_OpenSavePidlMRU.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_OpenSavePidlMRU.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_OpenSavePidlMRU.csv" -Delimiter "," | Sort-Object { $_.Timestamp -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\DFIRBatch\XLSX\PluginDetailFiles\DFIR_OpenSavePidlMRU.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "DFIR_OpenSavePidlMRU" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:H1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A, C-E and G
                    $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["C:E"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["G:G"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # DFIR_Products.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_Products.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_Products.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_Products.csv" -Delimiter "," | Sort-Object { $_.Timestamp -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\DFIRBatch\XLSX\PluginDetailFiles\DFIR_Products.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "DFIR_Products" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:K1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A and D-H 
                    $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["D:H"].Style.HorizontalAlignment="Center"

                    }
                }
            }

            # DFIR_ProfileList.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_ProfileList.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_ProfileList.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_ProfileList.csv" -Delimiter ","
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\DFIRBatch\XLSX\PluginDetailFiles\DFIR_ProfileList.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "DFIR_ProfileList" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:E1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A and D
                    $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["D:D"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # DFIR_RADAR.csv
                   if (Test-Path "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_RADAR.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_RADAR.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_RADAR.csv" -Delimiter ","
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\DFIRBatch\XLSX\PluginDetailFiles\DFIR_RADAR.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "DFIR_RADAR" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:E1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A and C-E
                    $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["C:E"].Style.HorizontalAlignment="Center"
                    }
                }
            }     

            # DFIR_RecentDocs.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_RecentDocs.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_RecentDocs.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_RecentDocs.csv" -Delimiter "," | Sort-Object { $_.OpenedOn -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\DFIRBatch\XLSX\PluginDetailFiles\DFIR_RecentDocs.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "DFIR_RecentDocs" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:I1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A, C-D and F-I
                    $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["C:D"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["F:I"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # DFIR_RunMRU.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_RunMRU.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_RunMRU.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_RunMRU.csv" -Delimiter "," | Sort-Object { $_.OpenedOn -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\DFIRBatch\XLSX\PluginDetailFiles\DFIR_RunMRU.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "DFIR_RunMRU" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:f1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A and C-F
                    $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["C:F"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # DFIR_SAMBuiltin.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_SAMBuiltin.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_SAMBuiltin.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_SAMBuiltin.csv" -Delimiter "," | Sort-Object { $_.OpenedOn -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\DFIRBatch\XLSX\PluginDetailFiles\DFIR_SAMBuiltin.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "DFIR_SAMBuiltin" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:E1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A and D-E
                    $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["D:E"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # DFIR_SCSI.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_SCSI.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_SCSI.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_SCSI.csv" -Delimiter "," | Sort-Object { $_.OpenedOn -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\DFIRBatch\XLSX\PluginDetailFiles\DFIR_SCSI.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "DFIR_SCSI" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A and C-M
                    $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["C:M"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # DFIR_Services.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_Services.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_Services.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_Services.csv" -Delimiter "," | Sort-Object { $_.OpenedOn -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\DFIRBatch\XLSX\PluginDetailFiles\DFIR_Services.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "DFIR_Services" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns B, D and F-J
                    $WorkSheet.Cells["B:B"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["D:D"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["F:J"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # DFIR_Taskband.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_Taskband.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_Taskband.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_Taskband.csv" -Delimiter ","
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\DFIRBatch\XLSX\PluginDetailFiles\DFIR_Taskband.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "DFIR_Taskband" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:E1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns D-E
                    $WorkSheet.Cells["D:E"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # DFIR_TaskCache.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_TaskCache.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_TaskCache.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_TaskCache.csv" -Delimiter "," | Sort-Object { $_.CreatedOn -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\DFIRBatch\XLSX\PluginDetailFiles\DFIR_TaskCache.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "DFIR_TaskCache" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A-D and F-J
                    $WorkSheet.Cells["A:D"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["F:J"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # DFIR_TimeZoneInfo.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_TimeZoneInfo.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_TimeZoneInfo.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_TimeZoneInfo.csv" -Delimiter ","
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\DFIRBatch\XLSX\PluginDetailFiles\DFIR_TimeZoneInfo.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "DFIR_TimeZoneInfo" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:E1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of column D
                    $WorkSheet.Cells["D:D"].Style.HorizontalAlignment="Center"
                    # HorizontalAlignment "Left" of columnc C and E
                    $WorkSheet.Cells["C:C"].Style.HorizontalAlignment="Left"
                    $WorkSheet.Cells["E:E"].Style.HorizontalAlignment="Left"
                    }
                }
            }

            # DFIR_TrustedDocuments.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_TrustedDocuments.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_TrustedDocuments.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_TrustedDocuments.csv" -Delimiter ","
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\DFIRBatch\XLSX\PluginDetailFiles\DFIR_TrustedDocuments.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "DFIR_TrustedDocuments" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:F1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A, C and F
                    $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["C:C"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["F:F"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # DFIR_TypedURLs.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_TypedURLs.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_TypedURLs.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_TypedURLs.csv" -Delimiter "," | Sort-Object { $_.Timestamp -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\DFIRBatch\XLSX\PluginDetailFiles\DFIR_TypedURLs.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "DFIR_TypedURLs" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:E1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A and D-E
                    $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["D:E"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # DFIR_UnInstall.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_UnInstall.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_UnInstall.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_UnInstall.csv" -Delimiter "," | Sort-Object { $_.Timestamp -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\DFIRBatch\XLSX\PluginDetailFiles\DFIR_UnInstall.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "DFIR_UnInstall" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:K1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A, D and F-H
                    $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["D:D"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["F:H"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # DFIR_USB.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_USB.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_USB.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_USB.csv" -Delimiter "," | Sort-Object { $_.Timestamp -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\DFIRBatch\XLSX\PluginDetailFiles\DFIR_USB.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "DFIR_USB" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:J1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A and C-J
                    $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["C:J"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # DFIR_USBSTOR.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_USBSTOR.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_USBSTOR.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_USBSTOR.csv" -Delimiter "," | Sort-Object { $_.Timestamp -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\DFIRBatch\XLSX\PluginDetailFiles\DFIR_USBSTOR.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "DFIR_USBSTOR" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:M1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A and C-M
                    $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["C:M"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # DFIR_UserAccounts.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_UserAccounts.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_UserAccounts.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_UserAccounts.csv" -Delimiter "," | Sort-Object { $_.Timestamp -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\DFIRBatch\XLSX\PluginDetailFiles\DFIR_UserAccounts.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "DFIR_UserAccounts" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:AE1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A, C-O and Q-AE
                    $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["C:O"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["Q:AE"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # DFIR_UserAssist.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_UserAssist.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_UserAssist.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_UserAssist.csv" -Delimiter "," | Sort-Object { $_.LastExecuted -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\DFIRBatch\XLSX\PluginDetailFiles\DFIR_UserAssist.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "DFIR_UserAssist" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:G1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns D-G
                    $WorkSheet.Cells["D:G"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # DFIR_VolumeInfoCache.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_VolumeInfoCache.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_VolumeInfoCache.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_VolumeInfoCache.csv" -Delimiter "," | Sort-Object { $_.Timestamp -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\DFIRBatch\XLSX\PluginDetailFiles\DFIR_VolumeInfoCache.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "DFIR_VolumeInfoCache" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:F1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A and C-F
                    $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["C:F"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # DFIR_WindowsApp.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_WindowsApp.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_WindowsApp.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_WindowsApp.csv" -Delimiter "," | Sort-Object { $_.Timestamp -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\DFIRBatch\XLSX\PluginDetailFiles\DFIR_WindowsApp.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "DFIR_WindowsApp" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:F1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns D-E
                    $WorkSheet.Cells["D:E"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # DFIR_WindowsPortableDevices.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_WindowsPortableDevices.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_WindowsPortableDevices.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_WindowsPortableDevices.csv" -Delimiter "," | Sort-Object { $_.Timestamp -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\DFIRBatch\XLSX\PluginDetailFiles\DFIR_WindowsPortableDevices.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "DFIR_WindowsPortableDevices" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:G1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A and C-G
                    $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["C:G"].Style.HorizontalAlignment="Center"
                    }
                }
            }

            # DFIR_WordWheelQuery.csv
            if (Test-Path "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_WordWheelQuery.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_WordWheelQuery.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\Registry\DFIRBatch\CSV\PluginDetailFiles\DFIR_WordWheelQuery.csv" -Delimiter "," | Sort-Object { $_.LastWriteTimestamp -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\Registry\DFIRBatch\XLSX\PluginDetailFiles\DFIR_WordWheelQuery.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "DFIR_WordWheelQuery" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:F1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns A and C-F
                    $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["C:F"].Style.HorizontalAlignment="Center"
                    }
                }
            }
        }
        else
        {
            Write-Host "[Error] DFIRBatch.reb NOT found." -ForegroundColor Red
        }
    }
    else
    {
        Write-Host "[Error] RECmd.exe NOT found." -ForegroundColor Red
    }
}

}

#endregion DFIR_Batch

#############################################################################################################################################################################################
#############################################################################################################################################################################################

#region LNK

Function LNK {

# Check if YARA exists
if (Test-Path "$($yara64)")
{
    # Get Start Time
    $StartTime_YARA = (Get-Date)

    # Simple YARA Scanner
    Write-Output "[Info]  Scanning for Windows Shortcut Files (LNK) w/ YARA [time-consuming task] ... "
    New-Item "$OUTPUT_FOLDER\LNK" -ItemType Directory -Force | Out-Null
    $LNKRule = "$SCRIPT_DIR\yara\evild3ad\LNK.yar"
    & $yara64 -p 4 -r -f -w -N "$LNKRule" "$DriveLetter\forensic\ntfs" > "$OUTPUT_FOLDER\LNK\stdout.txt" 2> $null

    # -N   do not follow symlinks when scanning
    # -p   use the specified NUMBER of threads to scan a directory
    # -r   recursive search directories (follows symlinks)
    # -f   fast matching mode
    # -w   disable warnings

    # Get End Time
    $EndTime_YARA = (Get-Date)

    # Scan Duration
    $Time_YARA = ($EndTime_YARA-$StartTime_YARA)
    '[Info]  YARA scan duration: {0:hh} h {0:mm} min {0:ss} sec' -f ($Time_YARA)
    
    ('YARA Scan duration:            {0} h {1} min {2} sec' -f $Time_YARA.Hours, $Time_YARA.Minutes, $Time_YARA.Seconds) >> "$OUTPUT_FOLDER\Stats.txt"

    # Stats
    if ((Test-Path "$OUTPUT_FOLDER\LNK\stdout.txt") -And ((Get-Item "$OUTPUT_FOLDER\LNK\stdout.txt").length -gt 0kb))
    {
        Get-Content "$OUTPUT_FOLDER\LNK\stdout.txt" | ForEach-Object{($_ -split "LNK ")[-1]} > "$OUTPUT_FOLDER\LNK\LNK-Files.txt"
        Remove-Item "$OUTPUT_FOLDER\LNK\stdout.txt" -Force
        $Count = [string]::Format('{0:N0}',(Get-Content "$OUTPUT_FOLDER\LNK\LNK-Files.txt" | Measure-Object –Line).Lines)
        Write-Host "[Info]  $Count SHLLINK artifacts found"
    }

    # lnk_parser
    if (Test-Path "$($lnk_parser)")
    {
        if (Test-Path "$($entropy)")
        {
            Write-Output "[Info]  Parsing SHLLINK artifacts (LNK) w/ lnk_parser ... "
            New-Item "$OUTPUT_FOLDER\LNK\lnk_parser\CSV" -ItemType Directory -Force | Out-Null
            $LNK_LIST = Get-Content "$OUTPUT_FOLDER\LNK\LNK-Files.txt"

            # Add CSV Header
            Write-Output '"target_full_path","target_modification_time","target_access_time","target_creation_time","target_size","target_hostname","lnk_full_path","lnk_modification_time","lnk_access_time","lnk_creation_time"' | Out-File "$OUTPUT_FOLDER\LNK\lnk_parser\CSV\lnk_parser.csv"

            ForEach( $LNK_FILE in $LNK_LIST )
            {
                & $lnk_parser -p $LNK_FILE --output-format csv --no-headers | Out-File "$OUTPUT_FOLDER\LNK\lnk_parser\CSV\lnk_parser.csv" -Append
            }

            # Custom CSV (for Hunting Malicious LNK Files)
            $LNK_LIST | Foreach-Object {

                $File = $_
                $MD5 = Get-FileHash "$File" -Algorithm MD5 -ErrorAction SilentlyContinue
                $SHA1 = Get-FileHash "$File" -Algorithm SHA1 -ErrorAction SilentlyContinue
                $SHA256 = Get-FileHash "$File" -Algorithm SHA256 -ErrorAction SilentlyContinue
                $FileInfo = Get-Item -Force "$File" -ErrorAction SilentlyContinue
                $LNK_PARSER_JSON = (& $lnk_parser -p $File --output-format json | ConvertFrom-Json)
                $full_path = $LNK_PARSER_JSON | Select-Object @{Name="full_path"; Expression={$_.lnk_file_metadata.full_path}}
                $lnk_modification_time = $LNK_PARSER_JSON | Select-Object @{Name="lnk_modification_time"; Expression={$_.lnk_file_metadata.mtime}}
                $lnk_access_time = $LNK_PARSER_JSON | Select-Object @{Name="lnk_access_time"; Expression={$_.lnk_file_metadata.atime}}
                $lnk_creation_time = $LNK_PARSER_JSON | Select-Object @{Name="lnk_creation_time"; Expression={$_.lnk_file_metadata.ctime}}
                $LocalBasePath = $LNK_PARSER_JSON | Select-Object @{Name="local_base_path"; Expression={$_.link_info.local_base_path}}
                $HotKey = $LNK_PARSER_JSON | Select-Object @{Name="hot_key"; Expression={$_.shell_link_header.hot_key}}
                $FileEntropy = & $entropy "$File" | ForEach-Object{($_ -split "\s+")[0]}

                New-Object -TypeName PSObject -Property @{
                    "LNK Full Path" = $full_path.full_path
                    "LNK Modification Time" = $lnk_modification_time.lnk_modification_time
                    "LNK Access Time" = $lnk_access_time.lnk_access_time
                    "LNK Creation Time" = $lnk_creation_time.lnk_creation_time
                    "Target Full Path" = $LNK_PARSER_JSON.target_full_path
                    "Working Directory" = $LNK_PARSER_JSON.working_dir
                    "Arguments" = $LNK_PARSER_JSON.command_line_arguments
                    "Relative Path" = $LNK_PARSER_JSON.relative_path
                    "Icon Location" = $LNK_PARSER_JSON.icon_location
                    "Local Base Path" = $LocalBasePath.local_base_path
                    "Shortcut Key" = $HotKey.hot_key
                    "LNK Size" = $FileInfo.Length
                    MD5 = $MD5.Hash
                    SHA1 = $SHA1.Hash
                    SHA256 = $SHA256.Hash
                    Entropy = $FileEntropy
                }
            } | Select-Object "LNK Full Path","LNK Modification Time","LNK Access Time","LNK Creation Time","Target Full Path","Working Directory","Arguments","Relative Path","Icon Location","Local Base Path","Shortcut Key","LNK Size","MD5","SHA1","SHA256","Entropy" | ConvertTo-Csv -NoTypeInformation -Delimiter "," | Out-File "$OUTPUT_FOLDER\LNK\lnk_parser\CSV\lnk_parser-hunt.csv"

            # XLSX

            # Check if PowerShell module 'ImportExcel' exists
            if (Get-Module -ListAvailable -Name ImportExcel) 
            {
                # lnk_parser.csv
                if (Test-Path "$OUTPUT_FOLDER\LNK\lnk_parser\CSV\lnk_parser.csv")
                {
                    if([int](& $xsv count "$OUTPUT_FOLDER\LNK\lnk_parser\CSV\lnk_parser.csv") -gt 0)
                    {
                        New-Item "$OUTPUT_FOLDER\LNK\lnk_parser\XLSX" -ItemType Directory -Force | Out-Null
                        $IMPORT = Import-Csv "$OUTPUT_FOLDER\LNK\lnk_parser\CSV\lnk_parser.csv" -Delimiter "," | Select-Object "target_full_path",@{Name='target_modification_time';Expression={([datetime]$_."target_modification_time").ToUniversalTime().ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='target_access_time';Expression={([datetime]$_."target_access_time").ToUniversalTime().ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='target_creation_time';Expression={([datetime]$_."target_creation_time").ToUniversalTime().ToString("yyyy-MM-dd HH:mm:ss")}},target_size,target_hostname,lnk_full_path,@{Name='lnk_modification_time';Expression={([datetime]$_."lnk_modification_time").ToUniversalTime().ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='lnk_access_time';Expression={([datetime]$_."lnk_access_time").ToUniversalTime().ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='lnk_creation_time';Expression={([datetime]$_."lnk_creation_time").ToUniversalTime().ToString("yyyy-MM-dd HH:mm:ss")}}
                        $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\LNK\lnk_parser\XLSX\lnk_parser.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "lnk_parser" -CellStyleSB {
                        param($WorkSheet)
                        # BackgroundColor and FontColor for specific cells of TopRow
                        $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                        Set-Format -Address $WorkSheet.Cells["A1:J1"] -BackgroundColor $BackgroundColor -FontColor White
                        # HorizontalAlignment "Center" of columns B-D, F and H-J
                        $WorkSheet.Cells["B:D"].Style.HorizontalAlignment="Center"
                        $WorkSheet.Cells["F:F"].Style.HorizontalAlignment="Center"
                        $WorkSheet.Cells["H:J"].Style.HorizontalAlignment="Center"
                        # HorizontalAlignment "Center" of header of column E
                        $WorkSheet.Cells["E1:E1"].Style.HorizontalAlignment="Center"
                        }
                    }
                }

                # lnk_parser-hunt.csv
                # https://attack.mitre.org/techniques/T1547/009/
                if (Test-Path "$OUTPUT_FOLDER\LNK\lnk_parser\CSV\lnk_parser-hunt.csv")
                {
                    if([int](& $xsv count "$OUTPUT_FOLDER\LNK\lnk_parser\CSV\lnk_parser-hunt.csv") -gt 0)
                    {
                        New-Item "$OUTPUT_FOLDER\LNK\lnk_parser\XLSX" -ItemType Directory -Force | Out-Null
                        $IMPORT = Import-Csv "$OUTPUT_FOLDER\LNK\lnk_parser\CSV\lnk_parser-hunt.csv" -Delimiter "," | Select-Object "LNK Full Path",@{Name='LNK Modification Time';Expression={([datetime]$_."LNK Modification Time").ToUniversalTime().ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Access Time';Expression={([datetime]$_."LNK Access Time").ToUniversalTime().ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Creation Time';Expression={([datetime]$_."LNK Creation Time").ToUniversalTime().ToString("yyyy-MM-dd HH:mm:ss")}},"Target Full Path","Working Directory","Arguments","Relative Path","Icon Location","Local Base Path","Shortcut Key","LNK Size","MD5","SHA1","SHA256","Entropy" | Sort-Object { $_."LNK Creation Time" -as [datetime] } -Descending
                        $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\LNK\lnk_parser\XLSX\lnk_parser-hunt.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "lnk_parser-hunt" -CellStyleSB {
                        param($WorkSheet)
                        # BackgroundColor and FontColor for specific cells of TopRow
                        $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                        Set-Format -Address $WorkSheet.Cells["A1:P1"] -BackgroundColor $BackgroundColor -FontColor White
                        # HorizontalAlignment "Center" of columns B-D, K and L-P
                        $WorkSheet.Cells["B:D"].Style.HorizontalAlignment="Center"
                        $WorkSheet.Cells["K:K"].Style.HorizontalAlignment="Center"
                        $WorkSheet.Cells["L:P"].Style.HorizontalAlignment="Center"
                        }
                    }
                }
            }
        }
        else
        {
            Write-Host "[Error] entropy.exe NOT found." -ForegroundColor Red
        }
    }
    else
    {
        Write-Host "[Error] lnk_parser_x86_64.exe NOT found." -ForegroundColor Red
    }
}
else
{
    Write-Host "[Error] yara64.exe NOT found." -ForegroundColor Red
}

}

Function LNK_Hunt {

# Hunting Malicious LNK Files
# https://attack.mitre.org/techniques/T1547/009/
if (Test-Path "$OUTPUT_FOLDER\LNK\lnk_parser\CSV\lnk_parser-hunt.csv")
{
    if([int](& $xsv count "$OUTPUT_FOLDER\LNK\lnk_parser\CSV\lnk_parser-hunt.csv") -gt 0)
    {
        New-Item "$OUTPUT_FOLDER\LNK\Hunt\CSV" -ItemType Directory -Force | Out-Null
        New-Item "$OUTPUT_FOLDER\LNK\Hunt\XLSX" -ItemType Directory -Force | Out-Null

        # Target Full Path (lnk_parser)

        # Target Full Path: C:\Google\AutoIt3.exe
        $Import = Import-Csv "$OUTPUT_FOLDER\LNK\lnk_parser\CSV\lnk_parser-hunt.csv" -Delimiter "," | Where-Object {($_."Target Full Path" -match "C:\\Google\\AutoIt3\.exe")} | Sort-Object { $_.lnk_modification_time -as [datetime] } -Descending
        $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)

        if ($Count -gt 0)
        {
            Write-Host "[Alert] Suspicious LNK File(s) using AutoIt3.exe detected [Target Full Path] (Count: $Count)" -ForegroundColor Red
            New-Item "$OUTPUT_FOLDER\LNK\Hunt\XLSX\TargetFullPath" -ItemType Directory -Force | Out-Null

            # CSV
            $Import | Export-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-AutoIt3.exe.csv" -NoTypeInformation

            # XLSX
            if (Test-Path "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-AutoIt3.exe.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-AutoIt3.exe.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-AutoIt3.exe.csv" -Delimiter "," | Select-Object "LNK Full Path",@{Name='LNK Modification Time';Expression={([datetime]$_."LNK Modification Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Access Time';Expression={([datetime]$_."LNK Access Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Creation Time';Expression={([datetime]$_."LNK Creation Time").ToString("yyyy-MM-dd HH:mm:ss")}},"Target Full Path","Working Directory","Arguments","Relative Path","Icon Location","Local Base Path","Shortcut Key","LNK Size","MD5","SHA1","SHA256","Entropy" | Sort-Object { $_."LNK Creation Time" -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\LNK\Hunt\XLSX\TargetFullPath\TargetFullPath-AutoIt3.exe.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "AutoIt3.exe" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:P1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns B-D, K and L-P
                    $WorkSheet.Cells["B:D"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["K:K"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:P"].Style.HorizontalAlignment="Center"
                    }
                }
            }
        }
 
        # Target Full Path: C:\Windows\System32\cmd.exe
        $Import = Import-Csv "$OUTPUT_FOLDER\LNK\lnk_parser\CSV\lnk_parser-hunt.csv" -Delimiter "," | Where-Object {($_."Target Full Path" -match "C:\\Windows\\System32\\cmd\.exe")} | Sort-Object { $_.lnk_modification_time -as [datetime] } -Descending
        $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)

        if ($Count -gt 0)
        {
            Write-Host "[Alert] Suspicious LNK File(s) using cmd.exe detected [Target Full Path] (Count: $Count)" -ForegroundColor Red
            New-Item "$OUTPUT_FOLDER\LNK\Hunt\XLSX\TargetFullPath" -ItemType Directory -Force | Out-Null

            # CSV
            $Import | Export-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-cmd.exe.csv" -NoTypeInformation

            # XLSX
            if (Test-Path "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-cmd.exe.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-cmd.exe.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-cmd.exe.csv" -Delimiter "," | Select-Object "LNK Full Path",@{Name='LNK Modification Time';Expression={([datetime]$_."LNK Modification Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Access Time';Expression={([datetime]$_."LNK Access Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Creation Time';Expression={([datetime]$_."LNK Creation Time").ToString("yyyy-MM-dd HH:mm:ss")}},"Target Full Path","Working Directory","Arguments","Relative Path","Icon Location","Local Base Path","Shortcut Key","LNK Size","MD5","SHA1","SHA256","Entropy" | Sort-Object { $_."LNK Creation Time" -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\LNK\Hunt\XLSX\TargetFullPath\TargetFullPath-cmd.exe.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "cmd.exe" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:P1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns B-D, K and L-P
                    $WorkSheet.Cells["B:D"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["K:K"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:P"].Style.HorizontalAlignment="Center"
                    }
                }
            }
        }

        # Target FUll Path: C:\Windows\System32\mshta.exe
        $Import = Import-Csv "$OUTPUT_FOLDER\LNK\lnk_parser\CSV\lnk_parser-hunt.csv" -Delimiter "," | Where-Object {($_."Target Full Path" -match "C:\\Windows\\System32\\mshta\.exe")} | Sort-Object { $_.lnk_modification_time -as [datetime] } -Descending
        $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)

        if ($Count -gt 0)
        {
            Write-Host "[Alert] Suspicious LNK File(s) using mshta.exe detected [Target Full Path] (Count: $Count)" -ForegroundColor Red
            New-Item "$OUTPUT_FOLDER\LNK\Hunt\XLSX\TargetFullPath" -ItemType Directory -Force | Out-Null

            # CSV
            $Import | Export-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-mshta.exe.csv" -NoTypeInformation

            # XLSX
            if (Test-Path "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-mshta.exe.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-mshta.exe.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-mshta.exe.csv" -Delimiter "," | Select-Object "LNK Full Path",@{Name='LNK Modification Time';Expression={([datetime]$_."LNK Modification Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Access Time';Expression={([datetime]$_."LNK Access Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Creation Time';Expression={([datetime]$_."LNK Creation Time").ToString("yyyy-MM-dd HH:mm:ss")}},"Target Full Path","Working Directory","Arguments","Relative Path","Icon Location","Local Base Path","Shortcut Key","LNK Size","MD5","SHA1","SHA256","Entropy" | Sort-Object { $_."LNK Creation Time" -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\LNK\Hunt\XLSX\TargetFullPath\TargetFullPath-mshta.exe.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "mshta.exe" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:P1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns B-D, K and L-P
                    $WorkSheet.Cells["B:D"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["K:K"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:P"].Style.HorizontalAlignment="Center"
                    }
                }
            }
        }

        # Target Full Path: C:\Windows\System32\msiexec.exe
        $Import = Import-Csv "$OUTPUT_FOLDER\LNK\lnk_parser\CSV\lnk_parser-hunt.csv" -Delimiter "," | Where-Object {($_."Target Full Path" -match "C:\\Windows\\System32\\msiexec\.exe")} | Sort-Object { $_.lnk_modification_time -as [datetime] } -Descending
        $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)
        
        if ($Count -gt 0)
        {
            Write-Host "[Alert] Suspicious LNK File(s) using msiexec.exe detected [Target Full Path] (Count: $Count)" -ForegroundColor Red
            New-Item "$OUTPUT_FOLDER\LNK\Hunt\XLSX\TargetFullPath" -ItemType Directory -Force | Out-Null

            # CSV
            $Import | Export-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-msiexec.exe.csv" -NoTypeInformation

            # XLSX
            if (Test-Path "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-msiexec.exe.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-msiexec.exe.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-msiexec.exe.csv" -Delimiter "," | Select-Object "LNK Full Path",@{Name='LNK Modification Time';Expression={([datetime]$_."LNK Modification Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Access Time';Expression={([datetime]$_."LNK Access Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Creation Time';Expression={([datetime]$_."LNK Creation Time").ToString("yyyy-MM-dd HH:mm:ss")}},"Target Full Path","Working Directory","Arguments","Relative Path","Icon Location","Local Base Path","Shortcut Key","LNK Size","MD5","SHA1","SHA256","Entropy" | Sort-Object { $_."LNK Creation Time" -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\LNK\Hunt\XLSX\TargetFullPath\TargetFullPath-msiexec.exe.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "msiexec.exe" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:P1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns B-D, K and L-P
                    $WorkSheet.Cells["B:D"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["K:K"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:P"].Style.HorizontalAlignment="Center"
                    }
                }
            }
        }

        # Target Full Path: C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe
        $Import = Import-Csv "$OUTPUT_FOLDER\LNK\lnk_parser\CSV\lnk_parser-hunt.csv" -Delimiter "," | Where-Object {($_."Target Full Path" -match "C:\\Windows\\System32\\WindowsPowerShell\\v1\.0\\powershell\.exe")} | Sort-Object { $_.lnk_modification_time -as [datetime] } -Descending
        $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)

        if ($Count -gt 0)
        {
            Write-Host "[Alert] Suspicious LNK File(s) using powershell.exe detected [Target Full Path] (Count: $Count)" -ForegroundColor Red
            New-Item "$OUTPUT_FOLDER\LNK\Hunt\XLSX\TargetFullPath" -ItemType Directory -Force | Out-Null

            # CSV
            $Import | Export-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-powershell.exe.csv" -NoTypeInformation

            # XLSX
            if (Test-Path "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-powershell.exe.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-powershell.exe.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-powershell.exe.csv" -Delimiter "," | Select-Object "LNK Full Path",@{Name='LNK Modification Time';Expression={([datetime]$_."LNK Modification Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Access Time';Expression={([datetime]$_."LNK Access Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Creation Time';Expression={([datetime]$_."LNK Creation Time").ToString("yyyy-MM-dd HH:mm:ss")}},"Target Full Path","Working Directory","Arguments","Relative Path","Icon Location","Local Base Path","Shortcut Key","LNK Size","MD5","SHA1","SHA256","Entropy" | Sort-Object { $_."LNK Creation Time" -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\LNK\Hunt\XLSX\TargetFullPath\TargetFullPath-powershell.exe.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "powershell.exe" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:P1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns B-D, K and L-P
                    $WorkSheet.Cells["B:D"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["K:K"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:P"].Style.HorizontalAlignment="Center"
                    }
                }
            }
        }

        # Target Full Path: C:\Windows\System32\rundll32.exe
        $Import = Import-Csv "$OUTPUT_FOLDER\LNK\lnk_parser\CSV\lnk_parser-hunt.csv" -Delimiter "," | Where-Object {($_."Target Full Path" -match "C:\\Windows\\System32\\rundll32\.exe")} | Sort-Object { $_.lnk_modification_time -as [datetime] } -Descending
        $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)

        if ($Count -gt 0)
        {
            Write-Host "[Alert] Suspicious LNK File(s) using rundll32.exe detected [Target Full Path] (Count: $Count)" -ForegroundColor Red
            New-Item "$OUTPUT_FOLDER\LNK\Hunt\XLSX\TargetFullPath" -ItemType Directory -Force | Out-Null

            # CSV
            $Import | Export-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-rundll32.exe.csv" -NoTypeInformation

            # XLSX
            if (Test-Path "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-rundll32.exe.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-rundll32.exe.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-rundll32.exe.csv" -Delimiter "," | Select-Object "LNK Full Path",@{Name='LNK Modification Time';Expression={([datetime]$_."LNK Modification Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Access Time';Expression={([datetime]$_."LNK Access Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Creation Time';Expression={([datetime]$_."LNK Creation Time").ToString("yyyy-MM-dd HH:mm:ss")}},"Target Full Path","Working Directory","Arguments","Relative Path","Icon Location","Local Base Path","Shortcut Key","LNK Size","MD5","SHA1","SHA256","Entropy" | Sort-Object { $_."LNK Creation Time" -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\LNK\Hunt\XLSX\TargetFullPath\TargetFullPath-rundll32.exe.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "rundll32.exe" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:P1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns B-D, K and L-P
                    $WorkSheet.Cells["B:D"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["K:K"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:P"].Style.HorizontalAlignment="Center"
                    }
                }
            }
        }

        # Target Full Path: C:\Windows\System32\schtasks.exe
        $Import = Import-Csv "$OUTPUT_FOLDER\LNK\lnk_parser\CSV\lnk_parser-hunt.csv" -Delimiter "," | Where-Object {($_."Target Full Path" -match "C:\\Windows\\System32\\schtasks\.exe")} | Sort-Object { $_.lnk_modification_time -as [datetime] } -Descending
        $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)

        if ($Count -gt 0)
        {
            Write-Host "[Alert] Suspicious LNK File(s) using schtasks.exe detected [Target Full Path] (Count: $Count)" -ForegroundColor Red
            New-Item "$OUTPUT_FOLDER\LNK\Hunt\XLSX\TargetFullPath" -ItemType Directory -Force | Out-Null

            # CSV
            $Import | Export-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-schtasks.exe.csv" -NoTypeInformation

            # XLSX
            if (Test-Path "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-schtasks.exe.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-schtasks.exe.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-schtasks.exe.csv" -Delimiter "," | Select-Object "LNK Full Path",@{Name='LNK Modification Time';Expression={([datetime]$_."LNK Modification Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Access Time';Expression={([datetime]$_."LNK Access Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Creation Time';Expression={([datetime]$_."LNK Creation Time").ToString("yyyy-MM-dd HH:mm:ss")}},"Target Full Path","Working Directory","Arguments","Relative Path","Icon Location","Local Base Path","Shortcut Key","LNK Size","MD5","SHA1","SHA256","Entropy" | Sort-Object { $_."LNK Creation Time" -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\LNK\Hunt\XLSX\TargetFullPath\TargetFullPath-schtasks.exe.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "schtasks.exe" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:P1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns B-D, K and L-P
                    $WorkSheet.Cells["B:D"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["K:K"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:P"].Style.HorizontalAlignment="Center"
                    }
                }
            }
        }

        # Target Full Path: C:\Windows\System32\wscript.exe
        $Import = Import-Csv "$OUTPUT_FOLDER\LNK\lnk_parser\CSV\lnk_parser-hunt.csv" -Delimiter "," | Where-Object {($_."Target Full Path" -match "C:\\Windows\\System32\\wscript\.exe")} | Sort-Object { $_.lnk_modification_time -as [datetime] } -Descending
        $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)

        if ($Count -gt 0)
        {
            Write-Host "[Alert] Suspicious LNK File(s) using wscript.exe detected [Target Full Path] (Count: $Count)" -ForegroundColor Red
            New-Item "$OUTPUT_FOLDER\LNK\Hunt\XLSX\TargetFullPath" -ItemType Directory -Force | Out-Null

            # CSV
            $Import | Export-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-wscript.exe.csv" -NoTypeInformation

            # XLSX
            if (Test-Path "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-wscript.exe.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-wscript.exe.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\TargetFullPath-wscript.exe.csv" -Delimiter "," | Select-Object "LNK Full Path",@{Name='LNK Modification Time';Expression={([datetime]$_."LNK Modification Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Access Time';Expression={([datetime]$_."LNK Access Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Creation Time';Expression={([datetime]$_."LNK Creation Time").ToString("yyyy-MM-dd HH:mm:ss")}},"Target Full Path","Working Directory","Arguments","Relative Path","Icon Location","Local Base Path","Shortcut Key","LNK Size","MD5","SHA1","SHA256","Entropy" | Sort-Object { $_."LNK Creation Time" -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\LNK\Hunt\XLSX\TargetFullPath\TargetFullPath-wscript.exe.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "wscript.exe" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:P1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns B-D, K and L-P
                    $WorkSheet.Cells["B:D"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["K:K"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:P"].Style.HorizontalAlignment="Center"
                    }
                }
            }
        }

        # Arguments

        # Long Argument (more than 50 characters)
        $Import = Import-Csv "$OUTPUT_FOLDER\LNK\lnk_parser\CSV\lnk_parser-hunt.csv" -Delimiter "," | Where-Object {(($_."Arguments").Length -gt "50")} | Sort-Object { $_.lnk_modification_time -as [datetime] } -Descending
        $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)

        if ($Count -gt 0)
        {
            Write-Host "[Alert] Suspicious LNK File(s) w/ Long Argument detected [Arguments] (Count: $Count)" -ForegroundColor Red
            New-Item "$OUTPUT_FOLDER\LNK\Hunt\XLSX\Arguments" -ItemType Directory -Force | Out-Null

            # CSV
            $Import | Export-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\Arguments-Long-Argument.csv" -NoTypeInformation

            # XLSX
            if (Test-Path "$OUTPUT_FOLDER\LNK\Hunt\CSV\Arguments-Long-Argument.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\LNK\Hunt\CSV\Arguments-Long-Argument.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\Arguments-Long-Argument.csv" -Delimiter "," | Select-Object "LNK Full Path",@{Name='LNK Modification Time';Expression={([datetime]$_."LNK Modification Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Access Time';Expression={([datetime]$_."LNK Access Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Creation Time';Expression={([datetime]$_."LNK Creation Time").ToString("yyyy-MM-dd HH:mm:ss")}},"Target Full Path","Working Directory","Arguments","Relative Path","Icon Location","Local Base Path","Shortcut Key","LNK Size","MD5","SHA1","SHA256","Entropy" | Sort-Object { $_."LNK Creation Time" -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\LNK\Hunt\XLSX\Arguments\Arguments-Long-Argument.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Long Argument" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:P1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns B-D, K and L-P
                    $WorkSheet.Cells["B:D"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["K:K"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:P"].Style.HorizontalAlignment="Center"
                    }
                }
            }
        }

        # Long Whitespace (more than 3 characters)
        $Import = Import-Csv "$OUTPUT_FOLDER\LNK\lnk_parser\CSV\lnk_parser-hunt.csv" -Delimiter "," | Where-Object {($_."Arguments" -match "\s{3,}")} | Sort-Object { $_.lnk_modification_time -as [datetime] } -Descending
        $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)

        if ($Count -gt 0)
        {
            Write-Host "[Alert] Suspicious LNK File(s) w/ Long Whitespace detected [Arguments] (Count: $Count)" -ForegroundColor Red
            New-Item "$OUTPUT_FOLDER\LNK\Hunt\XLSX\Arguments" -ItemType Directory -Force | Out-Null

            # CSV
            $Import | Export-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\Arguments-Long-Whitespace.csv" -NoTypeInformation

            # XLSX
            if (Test-Path "$OUTPUT_FOLDER\LNK\Hunt\CSV\Arguments-Long-Whitespace.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\LNK\Hunt\CSV\Arguments-Long-Whitespace.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\Arguments-Long-Whitespace.csv" -Delimiter "," | Select-Object "LNK Full Path",@{Name='LNK Modification Time';Expression={([datetime]$_."LNK Modification Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Access Time';Expression={([datetime]$_."LNK Access Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Creation Time';Expression={([datetime]$_."LNK Creation Time").ToString("yyyy-MM-dd HH:mm:ss")}},"Target Full Path","Working Directory","Arguments","Relative Path","Icon Location","Local Base Path","Shortcut Key","LNK Size","MD5","SHA1","SHA256","Entropy" | Sort-Object { $_."LNK Creation Time" -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\LNK\Hunt\XLSX\Arguments\Arguments-Long-Whitespace.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Long Whitespace" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:P1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns B-D, K and L-P
                    $WorkSheet.Cells["B:D"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["K:K"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:P"].Style.HorizontalAlignment="Center"
                    }
                }
            }
        }

        # Windows shortcut file (LNK) contains suspicious strings: http://
        $Import = Import-Csv "$OUTPUT_FOLDER\LNK\lnk_parser\CSV\lnk_parser-hunt.csv" -Delimiter "," | Where-Object {($_."Arguments" -match "http://")} | Sort-Object { $_.lnk_modification_time -as [datetime] } -Descending
        $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)

        if ($Count -gt 0)
        {
            Write-Host "[Alert] Windows shortcut file (LNK) contains suspicious strings: http:// [Arguments] (Count: $Count)" -ForegroundColor Red
            New-Item "$OUTPUT_FOLDER\LNK\Hunt\XLSX\Arguments" -ItemType Directory -Force | Out-Null

            # CSV
            $Import | Export-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\Arguments-Suspicious-Strings-CommandLine-http.csv" -NoTypeInformation

            # XLSX
            if (Test-Path "$OUTPUT_FOLDER\LNK\Hunt\CSV\Arguments-Suspicious-Strings-CommandLine-http.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\LNK\Hunt\CSV\Arguments-Suspicious-Strings-CommandLine-http.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\Arguments-Suspicious-Strings-CommandLine-http.csv" -Delimiter "," | Select-Object "LNK Full Path",@{Name='LNK Modification Time';Expression={([datetime]$_."LNK Modification Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Access Time';Expression={([datetime]$_."LNK Access Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Creation Time';Expression={([datetime]$_."LNK Creation Time").ToString("yyyy-MM-dd HH:mm:ss")}},"Target Full Path","Working Directory","Arguments","Relative Path","Icon Location","Local Base Path","Shortcut Key","LNK Size","MD5","SHA1","SHA256","Entropy" | Sort-Object { $_."LNK Creation Time" -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\LNK\Hunt\XLSX\Arguments\Arguments-Suspicious-Strings-CommandLine-http.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "http" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:P1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns B-D, K and L-P
                    $WorkSheet.Cells["B:D"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["K:K"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:P"].Style.HorizontalAlignment="Center"
                    }
                }
            }
        }

        # Windows shortcut file (LNK) contains suspicious strings: https://
        $Import = Import-Csv "$OUTPUT_FOLDER\LNK\lnk_parser\CSV\lnk_parser-hunt.csv" -Delimiter "," | Where-Object {($_."Arguments" -match "https://")} | Sort-Object { $_.lnk_modification_time -as [datetime] } -Descending
        $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)

        if ($Count -gt 0)
        {
            Write-Host "[Alert] Windows shortcut file (LNK) contains suspicious strings: https:// [Arguments] (Count: $Count)" -ForegroundColor Red
            New-Item "$OUTPUT_FOLDER\LNK\Hunt\XLSX\Arguments" -ItemType Directory -Force | Out-Null

            # CSV
            $Import | Export-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\Arguments-Suspicious-Strings-CommandLine-https.csv" -NoTypeInformation

            # XLSX
            if (Test-Path "$OUTPUT_FOLDER\LNK\Hunt\CSV\Arguments-Suspicious-Strings-CommandLine-https.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\LNK\Hunt\CSV\Arguments-Suspicious-Strings-CommandLine-https.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\Arguments-Suspicious-Strings-CommandLine-https.csv" -Delimiter "," | Select-Object "LNK Full Path",@{Name='LNK Modification Time';Expression={([datetime]$_."LNK Modification Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Access Time';Expression={([datetime]$_."LNK Access Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Creation Time';Expression={([datetime]$_."LNK Creation Time").ToString("yyyy-MM-dd HH:mm:ss")}},"Target Full Path","Working Directory","Arguments","Relative Path","Icon Location","Local Base Path","Shortcut Key","LNK Size","MD5","SHA1","SHA256","Entropy" | Sort-Object { $_."LNK Creation Time" -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\LNK\Hunt\XLSX\Arguments\Arguments-Suspicious-Strings-CommandLine-https.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "https" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:P1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns B-D, K and L-P
                    $WorkSheet.Cells["B:D"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["K:K"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:P"].Style.HorizontalAlignment="Center"
                    }
                }
            }
        }

        # Relative Path

        # Long Relative Path
        $Import = Import-Csv "$OUTPUT_FOLDER\LNK\lnk_parser\CSV\lnk_parser-hunt.csv" -Delimiter "," | Where-Object {($_."Relative Path" -match "\.\.\\\.\.\\\.\.\\\.\.\\\.\.\\")} | Sort-Object { $_.lnk_modification_time -as [datetime] } -Descending
        $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)

        if ($Count -gt 0)
        {
            Write-Host "[Alert] Suspicious LNK File(s) w/ Long Relative Path detected [Arguments] (Count: $Count)" -ForegroundColor Red
            New-Item "$OUTPUT_FOLDER\LNK\Hunt\XLSX\RelativePath" -ItemType Directory -Force | Out-Null

            # CSV
            $Import | Export-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\RelativePath-Long-Relative-Path.csv" -NoTypeInformation

            # XLSX
            if (Test-Path "$OUTPUT_FOLDER\LNK\Hunt\CSV\RelativePath-Long-Relative-Path.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\LNK\Hunt\CSV\RelativePath-Long-Relative-Path.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\RelativePath-Long-Relative-Path.csv" -Delimiter "," | Select-Object "LNK Full Path",@{Name='LNK Modification Time';Expression={([datetime]$_."LNK Modification Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Access Time';Expression={([datetime]$_."LNK Access Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Creation Time';Expression={([datetime]$_."LNK Creation Time").ToString("yyyy-MM-dd HH:mm:ss")}},"Target Full Path","Working Directory","Arguments","Relative Path","Icon Location","Local Base Path","Shortcut Key","LNK Size","MD5","SHA1","SHA256","Entropy" | Sort-Object { $_."LNK Creation Time" -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\LNK\Hunt\XLSX\RelativePath\RelativePath-Long-Relative-Path.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Long Relative Path" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:P1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns B-D, K and L-P
                    $WorkSheet.Cells["B:D"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["K:K"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:P"].Style.HorizontalAlignment="Center"
                    }
                }
            }
        }

        # Misc

        # Suspicious LNK Size
        $Import = Import-Csv "$OUTPUT_FOLDER\LNK\lnk_parser\CSV\lnk_parser-hunt.csv" -Delimiter "," | Where-Object {([int]$_."LNK Size" -gt "1000")} | Sort-Object { $_.lnk_modification_time -as [datetime] } -Descending
        $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)

        if ($Count -gt 0)
        {
            Write-Host "[Alert] Suspicious LNK File Size detected [Arguments] (Count: $Count)" -ForegroundColor Red
            New-Item "$OUTPUT_FOLDER\LNK\Hunt\XLSX\Misc" -ItemType Directory -Force | Out-Null

            # CSV
            $Import | Export-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\Misc-Suspicious-LNK-Size.csv" -NoTypeInformation

            # XLSX
            if (Test-Path "$OUTPUT_FOLDER\LNK\Hunt\CSV\Misc-Suspicious-LNK-Size.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\LNK\Hunt\CSV\Misc-Suspicious-LNK-Size.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\Misc-Suspicious-LNK-Size.csv" -Delimiter "," | Select-Object "LNK Full Path",@{Name='LNK Modification Time';Expression={([datetime]$_."LNK Modification Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Access Time';Expression={([datetime]$_."LNK Access Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Creation Time';Expression={([datetime]$_."LNK Creation Time").ToString("yyyy-MM-dd HH:mm:ss")}},"Target Full Path","Working Directory","Arguments","Relative Path","Icon Location","Local Base Path","Shortcut Key","LNK Size","MD5","SHA1","SHA256","Entropy" | Sort-Object { $_."LNK Creation Time" -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\LNK\Hunt\XLSX\Misc\Misc-Suspicious-LNK-Size.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Suspicious LNK Size" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:P1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns B-D, K and L-P
                    $WorkSheet.Cells["B:D"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["K:K"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:P"].Style.HorizontalAlignment="Center"
                    }
                }
            }
        }

        # Suspicious High Entropy (equal or higher than 6.5)
        $Import = Import-Csv "$OUTPUT_FOLDER\LNK\lnk_parser\CSV\lnk_parser-hunt.csv" -Delimiter "," | Where-Object {([int]$_."Entropy" -ge "6.5")} | Sort-Object { $_.lnk_modification_time -as [datetime] } -Descending
        $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)

        if ($Count -gt 0)
        {
            Write-Host "[Alert] Suspicious LNK File(s) w/ High Entropy detected [Arguments] (Count: $Count)" -ForegroundColor Red
            New-Item "$OUTPUT_FOLDER\LNK\Hunt\XLSX\Misc" -ItemType Directory -Force | Out-Null

            # CSV
            $Import | Export-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\Misc-Suspicious-High-Entropy.csv" -NoTypeInformation

            # XLSX
            if (Test-Path "$OUTPUT_FOLDER\LNK\Hunt\CSV\Misc-Suspicious-High-Entropy.csv")
            {
                if([int](& $xsv count "$OUTPUT_FOLDER\LNK\Hunt\CSV\Misc-Suspicious-High-Entropy.csv") -gt 0)
                {
                    $IMPORT = Import-Csv "$OUTPUT_FOLDER\LNK\Hunt\CSV\Misc-Suspicious-High-Entropy.csv" -Delimiter "," | Select-Object "LNK Full Path",@{Name='LNK Modification Time';Expression={([datetime]$_."LNK Modification Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Access Time';Expression={([datetime]$_."LNK Access Time").ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='LNK Creation Time';Expression={([datetime]$_."LNK Creation Time").ToString("yyyy-MM-dd HH:mm:ss")}},"Target Full Path","Working Directory","Arguments","Relative Path","Icon Location","Local Base Path","Shortcut Key","LNK Size","MD5","SHA1","SHA256","Entropy" | Sort-Object { $_."LNK Creation Time" -as [datetime] } -Descending
                    $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\LNK\Hunt\XLSX\Misc\Misc-Suspicious-High-Entropy.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "High Entropy" -CellStyleSB {
                    param($WorkSheet)
                    # BackgroundColor and FontColor for specific cells of TopRow
                    $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                    Set-Format -Address $WorkSheet.Cells["A1:P1"] -BackgroundColor $BackgroundColor -FontColor White
                    # HorizontalAlignment "Center" of columns B-D, K and L-P
                    $WorkSheet.Cells["B:D"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["K:K"].Style.HorizontalAlignment="Center"
                    $WorkSheet.Cells["L:P"].Style.HorizontalAlignment="Center"
                    }
                }
            }
        }
    }
}

}

#endregion LNK

#############################################################################################################################################################################################
#############################################################################################################################################################################################

#region ImageMount

# VHDMP (VHD Miniport Driver by Microsoft Corporation)

# VHD and VHDX Files
# Windows 7 and newer systems include the ability to manually mount VHD files. Starting with Windows 8, a user can mount a VHD by simply double-clicking on the file. 
# Once mounted, a VHD disk image appears to Windows as a normal hard disk that's physically connected to the system. 
# VHDX (Virtual Hard Disk v2) images are functionally equivalent to VHD images, but they include more modern features, such as support for larger sizes and disk resizing.

# Mark of the Web (MOTW)
# MOTW was introduced in Windows XP SP2 and allowed Windows to tag files on the local file system with information about the Internet Explorer security zone from which the files originated. 
# This MOTW feature has evolved to handle more and more file types and scenarios. 
# The recurring theme is that files that came from the Internet (e.g., a web page or an email) may be dangerous, and therefore should be treated with more caution.
# For example, starting with Microsoft Office 2010, documents tagged with an MOTW that indicated that they came from the Internet are opened in Microsoft Office Protected View. 
# Documents in Protected View are restricted in what they can do, thus reducing the attack surface of potentially dangerous documents. 

# Starting with Windows 10, Windows Defender SmartScreen restricts the execution of certain file types if they originated from the Internet.

# Files contained within a VHD or VHDX container do not retain the MOTW of the container file!!!

# ISO and IMG Files
# Just like VHD and VHDX files, the contents of ISO or IMG files do not carry the MOTW of the containing file. 
# And just like VHD and VHDX files, starting with Windows 8, ISO and IMG files can be opened with a double click.

# Following Microsoft's decision to block macros by default on MS Office applications, threat actors are increasingly using container files such as ISO files to distribute malware.

Function ImageMount {

# VHDMP (Event Logs for VHD's)
if (Test-Path "$OUTPUT_FOLDER\EventLogs\EventLogs\Microsoft-Windows-VHDMP-Operational.evtx")
{
    Write-Output "[Info]  Analyzing Event Logs for Image Mount Indicators ... "
    New-Item "$OUTPUT_FOLDER\EventLogs\VHDMP" -ItemType Directory -Force | Out-Null
    Copy-Item "$OUTPUT_FOLDER\EventLogs\EventLogs\Microsoft-Windows-VHDMP-Operational.evtx" "$OUTPUT_FOLDER\EventLogs\VHDMP" 2>&1 | Out-Null

    # EvtxECmd
    if (Test-Path "$($EvtxECmd)")
    {
        if (Test-Path "$OUTPUT_FOLDER\EventLogs\VHDMP\Microsoft-Windows-VHDMP-Operational.evtx")
        {
            # EvtxECmd.csv
            New-Item "$OUTPUT_FOLDER\EventLogs\VHDMP\CSV" -ItemType Directory -Force | Out-Null
            & $EvtxECmd -f "$OUTPUT_FOLDER\EventLogs\VHDMP\Microsoft-Windows-VHDMP-Operational.evtx" --csv "$OUTPUT_FOLDER\EventLogs\VHDMP\CSV" --csvf "EvtxECmd.csv" > "$OUTPUT_FOLDER\EventLogs\VHDMP\EvtxECmd.log" 2> $null

            # Windows Title (Default)
            $Host.UI.RawUI.WindowTitle = "MemProcFS-Analyzer $Version - Automated Forensic Analysis of Windows Memory Dumps for DFIR"

            # Stats
            if (Get-Content "$OUTPUT_FOLDER\EventLogs\VHDMP\EvtxECmd.log" | Select-String -Pattern "^Total event log records found:" -Quiet)
            {
                # Error
                if (Get-Content "$OUTPUT_FOLDER\EventLogs\VHDMP\EvtxECmd.log" | Select-String -Pattern "Error processing record" -Quiet)
                {
                    Write-Output "[Info]  Microsoft-Windows-VHDMP-Operational.evtx seems to be partially corrupt."
                }

                # Total
                $Total = (Get-Content "$OUTPUT_FOLDER\EventLogs\VHDMP\EvtxECmd.log" | Select-String -Pattern "Total event log records found:" | ForEach-Object{($_ -split "\s+")[-1]} | Out-String).Trim()
                Write-Output "[Info]  Total Event Log Records found: $Total"
            }

            # ImageMount Hunt
            if (Test-Path "$OUTPUT_FOLDER\EventLogs\VHDMP\CSV\EvtxECmd.csv")
            {
                if ([int](& $xsv count "$OUTPUT_FOLDER\EventLogs\VHDMP\CSV\EvtxECmd.csv") -gt 0)
                {
                    $Import = Import-Csv "$OUTPUT_FOLDER\EventLogs\VHDMP\CSV\EvtxECmd.csv" -Delimiter "," | Select-Object RecordNumber, @{Name='TimeCreated [UTC]';Expression={([datetime]$_.TimeCreated).ToString("yyyy-MM-dd HH:mm:ss")}}, EventId, Level, Channel, MapDescription, @{Name='EventData';Expression={$_.PayloadData1}},@{Name='Name';Expression={$_.PayloadData2 | ForEach-Object{($_ -split "\\")[-1]}}},@{Name='FilePath';Expression={$_.PayloadData2 | ForEach-Object{($_ -split ": ")[-1]}}}, Computer, UserId

                    # Event ID 1 - Contains entries of Image Files that has come online (surfaced)
                    $Data = $Import | Where-Object { $_."EventId" -eq "1" }
                    $EID1 = [string]::Format('{0:N0}',($Data | Measure-Object).Count)

                    if ($EID1 -gt 0)
                    {
                        Write-Host "[Alert] Image Mount Entries found: Event ID 1 - Mount ($Count)" -ForegroundColor Red
                    }

                    # Event ID 2 - Contains entries of Image Files that has been removed (unsurfaced)
                    $Data = $Import | Where-Object { $_."EventId" -eq "2" }
                    $EID2 = [string]::Format('{0:N0}',($Data | Measure-Object).Count)

                    if ($EID2 -gt 0)
                    {
                        Write-Host "[Alert] Image Mount Entries found: Event ID 2 - Unmount ($Count)" -ForegroundColor Red
                    }

                    # ImageMount Hunt Summary

                    # CSV
                    if (($EID1 -gt 0) -or ($EID2 -gt 0))
                    { 
                        $Import | Where-Object { $_."EventId" -eq "1" -or $_."EventId" -eq "2" } | Export-Csv "$OUTPUT_FOLDER\EventLogs\VHDMP\CSV\ImageMount.csv" -NoTypeInformation
                    }

                    # XLSX
                    if (Test-Path "$OUTPUT_FOLDER\EventLogs\VHDMP\CSV\ImageMount.csv")
                    {
                        if([int](& $xsv count "$OUTPUT_FOLDER\EventLogs\VHDMP\CSV\ImageMount.csv") -gt 0)
                        {
                            $IMPORT = Import-Csv "$OUTPUT_FOLDER\EventLogs\VHDMP\CSV\ImageMount.csv" -Delimiter "," | Sort-Object { $_."TimeCreated [UTC]" -as [datetime] } -Descending
                            New-Item "$OUTPUT_FOLDER\EventLogs\VHDMP\XLSX" -ItemType Directory -Force | Out-Null
                            $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\EventLogs\VHDMP\XLSX\ImageMount.xlsx" -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "ImageMount" -CellStyleSB {
                            param($WorkSheet)
                            # BackgroundColor and FontColor for specific cells of TopRow
                            $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
                            Set-Format -Address $WorkSheet.Cells["A1:K1"] -BackgroundColor $BackgroundColor -FontColor White
                            # HorizontalAlignment "Center" of columns A-F and J-K
                            $WorkSheet.Cells["A:F"].Style.HorizontalAlignment="Center"
                            $WorkSheet.Cells["J:K"].Style.HorizontalAlignment="Center"
                            }
                        }
                    }
                }
            }
        }
    }
}

#############################################################################################################################################################################################

# Recent Files
if (Test-Path "$OUTPUT_FOLDER\RecentFiles\RecentFiles.csv")
{
    if ([int](& $xsv count -d "`t" "$OUTPUT_FOLDER\RecentFiles\RecentFiles.csv") -gt 0)
    {
        Write-Output "[Info]  Analyzing Recent Folder Artifacts for Image Mount Indicators ... "

        $Import = Import-Csv "$OUTPUT_FOLDER\RecentFiles\RecentFiles.csv" -Delimiter "," | Select-Object @{Name='Timestamp [UTC]';Expression={([datetime]$_.date).ToUniversalTime().ToString("yyyy-MM-dd HH:mm:ss")}},@{Name='Name';Expression={$_.desc | ForEach-Object{($_ -split "\\")[-1]}}},@{Name='Type';Expression={$_.type}},@{Name='Action';Expression={$_.action}},@{Name='File Path';Expression={$_.desc}},@{Name='Bytes';Expression={$_.num}} | Sort-Object { $_."Timestamp [UTC]" -as [datetime] } -Descending

        # IMG Files
        $Data = $Import | Where-Object { $_."FilePath" -match "\\Users\\.*\.img\.lnk" }
        $Count = [string]::Format('{0:N0}',($Data | Measure-Object).Count)

        if ($Count -gt 0)
        {
            Write-Host "[Alert] Image Mount Indicator detected: .img.lnk ($Count)" -ForegroundColor Red
            New-Item "$OUTPUT_FOLDER\RecentFiles\Image-Mount-Indicators" -ItemType Directory -Force | Out-Null
            $Data | Export-Excel -Path "$OUTPUT_FOLDER\RecentFiles\Image-Mount-Indicators\IMG.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname ".img" -CellStyleSB {
            param($WorkSheet)
            # BackgroundColor and FontColor for specific cells of TopRow
            $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
            Set-Format -Address $WorkSheet.Cells["A1:F1"] -BackgroundColor $BackgroundColor -FontColor White
            # HorizontalAlignment "Center" of columns A, C-D and F
            $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
            $WorkSheet.Cells["C:D"].Style.HorizontalAlignment="Center"
            $WorkSheet.Cells["F:F"].Style.HorizontalAlignment="Center"
            # BackgroundColor and FontColor for specific cells
            $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
            $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
            $LastRow = $WorkSheet.Dimension.End.Row
            Set-Format -Address $WorkSheet.Cells["E2:E$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
            }
        }

        # ISO Files
        $Data = $Import | Where-Object { $_."File Path" -match "\\Users\\.*\.iso\.lnk" }
        $Count = [string]::Format('{0:N0}',($Data | Measure-Object).Count)

        if ($Count -gt 0)
        {
            Write-Host "[Alert] Image Mount Indicator detected: .iso.lnk ($Count)" -ForegroundColor Red
            New-Item "$OUTPUT_FOLDER\RecentFiles\Image-Mount-Indicators" -ItemType Directory -Force | Out-Null
            $Data | Export-Excel -Path "$OUTPUT_FOLDER\RecentFiles\Image-Mount-Indicators\ISO.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname ".iso" -CellStyleSB {
            param($WorkSheet)
            # BackgroundColor and FontColor for specific cells of TopRow
            $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
            Set-Format -Address $WorkSheet.Cells["A1:F1"] -BackgroundColor $BackgroundColor -FontColor White
            # HorizontalAlignment "Center" of columns A, C-D and F
            $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
            $WorkSheet.Cells["C:D"].Style.HorizontalAlignment="Center"
            $WorkSheet.Cells["F:F"].Style.HorizontalAlignment="Center"
            # BackgroundColor and FontColor for specific cells
            $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
            $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
            $LastRow = $WorkSheet.Dimension.End.Row
            Set-Format -Address $WorkSheet.Cells["E2:E$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
            }
        }

        # VHD Files
        $Data = $Import | Where-Object { $_."File Path" -match "\\Users\\.*\.vhd\.lnk" }
        $Count = [string]::Format('{0:N0}',($Data | Measure-Object).Count)

        if ($Count -gt 0)
        {
            Write-Host "[Alert] Image Mount Indicator detected: .vhd.lnk ($Count)" -ForegroundColor Red
            New-Item "$OUTPUT_FOLDER\RecentFiles\Image-Mount-Indicators" -ItemType Directory -Force | Out-Null
            $Data | Export-Excel -Path "$OUTPUT_FOLDER\RecentFiles\Image-Mount-Indicators\VHD.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname ".vhd" -CellStyleSB {
            param($WorkSheet)
            # BackgroundColor and FontColor for specific cells of TopRow
            $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
            Set-Format -Address $WorkSheet.Cells["A1:F1"] -BackgroundColor $BackgroundColor -FontColor White
            # HorizontalAlignment "Center" of columns A, C-D and F
            $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
            $WorkSheet.Cells["C:D"].Style.HorizontalAlignment="Center"
            $WorkSheet.Cells["F:F"].Style.HorizontalAlignment="Center"
            # BackgroundColor and FontColor for specific cells
            $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
            $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
            $LastRow = $WorkSheet.Dimension.End.Row
            Set-Format -Address $WorkSheet.Cells["E2:E$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
            }
        }

        # VHDX Files
        $Data = $Import | Where-Object { $_."File Path" -match "\\Users\\.*\.vhdx\.lnk" }
        $Count = [string]::Format('{0:N0}',($Data | Measure-Object).Count)

        if ($Count -gt 0)
        {
            Write-Host "[Alert] Image Mount Indicator detected: .vhdx.lnk ($Count)" -ForegroundColor Yellow
            New-Item "$OUTPUT_FOLDER\RecentFiles\Image-Mount-Indicators" -ItemType Directory -Force | Out-Null
            $Data | Export-Excel -Path "$OUTPUT_FOLDER\RecentFiles\Image-Mount-Indicators\VHDX.xlsx" -FreezePane 2,6 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname ".vhdx" -CellStyleSB {
            param($WorkSheet)
            # BackgroundColor and FontColor for specific cells of TopRow
            $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
            Set-Format -Address $WorkSheet.Cells["A1:F1"] -BackgroundColor $BackgroundColor -FontColor White
            # HorizontalAlignment "Center" of columns A, C-D and F
            $WorkSheet.Cells["A:A"].Style.HorizontalAlignment="Center"
            $WorkSheet.Cells["C:D"].Style.HorizontalAlignment="Center"
            $WorkSheet.Cells["F:F"].Style.HorizontalAlignment="Center"
            # BackgroundColor and FontColor for specific cells
            $BackgroundColor = [System.Drawing.Color]::FromArgb(255,0,0)
            $FontColor = [System.Drawing.Color]::FromArgb(255,255,255)
            $LastRow = $WorkSheet.Dimension.End.Row
            Set-Format -Address $WorkSheet.Cells["E2:E$LastRow"] -BackgroundColor $BackgroundColor -FontColor $FontColor -Bold
            }
        }
    }
}

}

#endregion ImageMount

#############################################################################################################################################################################################
#############################################################################################################################################################################################

#region Modules

# Status: Experimental
# The recovered files are often partial. Often the metadata isn't yet read into memory (it's read on-demand on first use from disk) or paged out. File hashes are more or less useless since you'll never recover the whole file from memory.
# But it seems that in some cases it's working better than expected and helps you to find evil.

# https://github.com/ufrisk/MemProcFS/wiki/FS_Process_Modules

Function Modules {

# Get Start Time
$StartTime_Modules = (Get-Date)

# Modules
Write-Host "[Info]  Analyzing Reconstructed Process Modules ... "
New-Item "$OUTPUT_FOLDER\sys\modules\CSV" -ItemType Directory -Force | Out-Null

if (!(Test-Path "$($entropy)"))
{
    Write-Host "[Error] entropy.exe NOT found." -ForegroundColor Red
}

$Modules = Get-ChildItem -Path "$DriveLetter\pid\*\modules\*.exe\pefile.dll" | ForEach-Object { $_.FullName }
$Modules | Out-File "$OUTPUT_FOLDER\sys\modules\Modules-List.txt"

$Modules | Foreach-Object {

    $File = $_
    $FileInfo = Get-Item -Force "$File" -ErrorAction SilentlyContinue
    $Length = $FileInfo.Length

    if ($Length -ne "0")
    {
        $MD5 = Get-FileHash "$File" -Algorithm MD5 -ErrorAction SilentlyContinue
        $SHA1 = Get-FileHash "$File" -Algorithm SHA1 -ErrorAction SilentlyContinue
        $SHA256 = Get-FileHash "$File" -Algorithm SHA256 -ErrorAction SilentlyContinue
    }
    else
    {
        $MD5 = ""
        $SHA1 = ""
        $SHA256 = ""
    }

    $ProcessId = $File | ForEach-Object{($_ -split "\\")[2]}
    $FullPath = $File.Replace("pefile.dll", "fullname.txt")
    $ImagePath = Get-Content -Path $FullPath
    $FileName = Split-Path $ImagePath -Leaf
    $InternalName = $FileInfo.VersionInfo.InternalName
    $OriginalFileName = $FileInfo.VersionInfo.OriginalFileName
    $FileDescription = $FileInfo.VersionInfo.FileDescription
    $CompanyName = $FileInfo.VersionInfo.CompanyName
    $FileVersion = $FileInfo.VersionInfo.FileVersion
    $Language = $FileInfo.VersionInfo.Language
    $ProductName = $FileInfo.VersionInfo.ProductName

    if (Test-Path "$($entropy)")
    {
        $FileEntropy = & $entropy "$File" | ForEach-Object{($_ -split "\s+")[0]}
    }
    else
    {
        $FileEntropy = ""
    }

    $LastAccessTimeUtc = $FileInfo.LastAccessTimeUtc

    # CSV
    New-Object -TypeName PSObject -Property @{
        "File Name"         = $FileName
        "PID"               = $ProcessId
        "Internal Name"     = $InternalName
        "Original FileName" = $OriginalFileName
        "File Description"  = $FileDescription
        "Image Path"        = $ImagePath
        "File Version"      = $FileVersion
        "Company Name"      = $CompanyName
        "Product Name"      = $ProductName
        "Language"          = $Language
        "Bytes"             = $Length
        "File Size"         = Get-FileSize($Length)
        "File Path"         = $File
        "MD5"               = $MD5.Hash
        "SHA1"              = $SHA1.Hash
        "SHA256"            = $SHA256.Hash
        "Entropy"           = $FileEntropy
        "Last Access Time"  = $LastAccessTimeUtc
    }
} | Select-Object "File Name","PID","Internal Name","Original FileName","File Description","Image Path","File Version","Company Name","Product Name","Language","Bytes","File Size","File Path","Entropy","Last Access Time","MD5","SHA1","SHA256" | ConvertTo-Csv -NoTypeInformation -Delimiter "," | Out-File "$OUTPUT_FOLDER\sys\modules\CSV\modules-untouched.csv" -Encoding UTF8

# Whitelist
if (Test-Path "$OUTPUT_FOLDER\sys\modules\CSV\modules-untouched.csv")
{
    if([int](& $xsv count "$OUTPUT_FOLDER\sys\modules\CSV\modules-untouched.csv") -gt 0)
    {
        # Exclude 0-Byte Files
        $Data = Get-Content "$OUTPUT_FOLDER\sys\modules\CSV\modules-untouched.csv" | ConvertFrom-Csv
        $Data | Where-Object {$_."Image Path" -notmatch  "\\SystemRoot\\system32\\ntoskrnl\.exe"} | Where-Object {$_."Bytes" -notmatch  "^0"} | Export-Csv "$OUTPUT_FOLDER\sys\modules\CSV\modules.csv" -NoTypeInformation -Encoding UTF8

        # Count
        [int]$Total = & $xsv count "$OUTPUT_FOLDER\sys\modules\CSV\modules-untouched.csv"
        [int]$Cleaned = & $xsv count "$OUTPUT_FOLDER\sys\modules\CSV\modules.csv"
        Write-Output "[Info]  $Cleaned Reconstructed Process Modules found ($Total)"
    }
    else
    {
        Write-Output "[Info]  No Reconstructed Process Modules found"
    }
}

# Check if PowerShell module 'ImportExcel' exists
if (Get-Module -ListAvailable -Name ImportExcel) 
{
    # XLSX
    if (Test-Path "$OUTPUT_FOLDER\sys\modules\CSV\modules.csv")
    {
        if((Get-Item "$OUTPUT_FOLDER\sys\modules\CSV\modules.csv").length -gt 0kb)
        {
            New-Item "$OUTPUT_FOLDER\sys\modules\XLSX" -ItemType Directory -Force | Out-Null
            $IMPORT = Import-Csv "$OUTPUT_FOLDER\sys\modules\CSV\modules.csv" -Delimiter ","
            $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\sys\modules\XLSX\modules.xlsx" -NoNumberConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Modules" -CellStyleSB {
            param($WorkSheet)
            # BackgroundColor and FontColor for specific cells of TopRow
            $BackgroundColor = [System.Drawing.Color]::FromArgb(50,60,220)
            Set-Format -Address $WorkSheet.Cells["A1:R1"] -BackgroundColor $BackgroundColor -FontColor White
            # HorizontalAlignment "Center" of columns A-B, G-J and N-R
            $WorkSheet.Cells["A:B"].Style.HorizontalAlignment="Center"
            $WorkSheet.Cells["G:J"].Style.HorizontalAlignment="Center"
            $WorkSheet.Cells["N:R"].Style.HorizontalAlignment="Center"
            # HorizontalAlignment "Right" of columns K-L
            $WorkSheet.Cells["K:L"].Style.HorizontalAlignment="Right"
            # HorizontalAlignment "Center" of header of columns K-L
            $WorkSheet.Cells["K1:L1"].Style.HorizontalAlignment="Center"

            # Threat Hunting

            # Fields are missing / empty (W/ Rule Priority)

            # "Internal Name" and "Original FileName" and "File Description" and "Company Name" --> Red
            $HighColor = [System.Drawing.Color]::FromArgb(255,0,0)
            Add-ConditionalFormatting -Address $WorkSheet.Dimension.Address -WorkSheet $WorkSheet -RuleType 'Expression' '=AND($C1="",$D1="",$E1="",$H1="")' -BackgroundColor $HighColor
            $Import = Import-Csv "$OUTPUT_FOLDER\sys\modules\CSV\modules.csv" -Delimiter "," | Where-Object {(($_."Internal Name" -eq "") -and ($_."Original FileName" -eq "") -and ($_."File Description" -eq "") -and ($_."Company Name" -eq ""))}
            $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)
            if ($Count -gt 0)
            {
                Write-Host "[Alert] Missing Internal Name, Original FileName, File Description, and Company Name detected [Modules] (Count: $Count)" -ForegroundColor Red
            }

            # "File Description" or "Company Name": Empty --> Orange
            $MediumColor = [System.Drawing.Color]::FromArgb(255,192,0)
            Add-ConditionalFormatting -Address $WorkSheet.Dimension.Address -WorkSheet $WorkSheet -RuleType 'Expression' '=OR($E1="",$H1="")' -BackgroundColor $MediumColor
            $Import = Import-Csv "$OUTPUT_FOLDER\sys\modules\CSV\modules.csv" -Delimiter "," | Where-Object {(($_."File Description" -eq "") -or ($_."Company Name" -eq ""))}
            $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)
            if ($Count -gt 0)
            {
                Write-Host "[Alert] Missing File Description and/or Company Name detected [Modules] (Count: $Count)" -ForegroundColor Yellow
            }

            # "Internal Name" or "Original FileName": Empty --> Yellow
            $LowColor = [System.Drawing.Color]::FromArgb(255,255,0)
            Add-ConditionalFormatting -Address $WorkSheet.Dimension.Address -WorkSheet $WorkSheet -RuleType 'Expression' '=OR($C1="",$D1="")' -BackgroundColor $LowColor
            $Import = Import-Csv "$OUTPUT_FOLDER\sys\modules\CSV\modules.csv" -Delimiter "," | Where-Object {(($_."Internal Name" -eq "") -or ($_."Original FileName" -eq ""))}
            $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)
            if ($Count -gt 0)
            {
                Write-Host "[Alert] Missing Internal Name and/or Original FileName detected [Modules] (Count: $Count)" -ForegroundColor Yellow
            }

            # Mismatch on Original FileName
            $LowColor = [System.Drawing.Color]::FromArgb(255,255,0)
            $LastRow = $WorkSheet.Dimension.End.Row
            Add-ConditionalFormatting -Address $WorkSheet.Cells["D2:D$LastRow"] -WorkSheet $WorkSheet -RuleType 'Expression' -ConditionValue '=$A2<>$D2' -BackgroundColor $LowColor
            $Import = Import-Csv "$OUTPUT_FOLDER\sys\modules\CSV\modules.csv" -Delimiter "," | Where-Object {($_."File Name" -notlike $_."Original FileName")}
            $Count = [string]::Format('{0:N0}',($Import | Measure-Object).Count)
            if ($Count -gt 0)
            {
                Write-Host "[Alert] Mismatch on Original FileName detected [Modules] (Count: $Count)" -ForegroundColor Yellow
            }

            }
        }
    }
}

# Get End Time
$EndTime_Modules = (Get-Date)

# Processing Duration
$Time_Modules = ($EndTime_Modules-$StartTime_Modules)
('Modules Analysis duration:     {0} h {1} min {2} sec' -f $Time_Modules.Hours, $Time_Modules.Minutes, $Time_Modules.Seconds) >> "$OUTPUT_FOLDER\Stats.txt"

}

#endregion Modules

#############################################################################################################################################################################################
#############################################################################################################################################################################################

#region CobaltStrike

Function Invoke-1768 {

# 1768.py v.0.0.23 (2025-03-07)
# https://blog.didierstevens.com/?s=1768.py
# https://github.com/DidierStevens/DidierStevensSuite/blob/master/1768.py
if ((Test-Path "$SCRIPT_DIR\Scripts\1768\1768.py") -and (Test-Path "$SCRIPT_DIR\Scripts\1768\1768.json"))
{
    # Current version
    New-Item "$OUTPUT_FOLDER\CobaltStrike\1768" -ItemType Directory -Force | Out-Null
    python "$SCRIPT_DIR\Scripts\1768\1768.py" --version > "$OUTPUT_FOLDER\CobaltStrike\1768\Version.txt" 2> $null

    # Get Start Time
    $StartTime_1768 = (Get-Date)

    # Searching for Cobalt Strike Beacons Configuration(s) w/ 1768.py
    Write-Output "[Info]  Searching for Cobalt Strike Beacons Configuration(s) w/ 1768.py ..."
    python "$SCRIPT_DIR\Scripts\1768\1768.py" -S $MemoryDump -o "$OUTPUT_FOLDER\CobaltStrike\1768\1768.txt" 2> $null

    # Get End Time
    $EndTime_1768 = (Get-Date)

    # Scan Duration
    $Time_1768 = ($EndTime_1768-$StartTime_1768)
    ('1768 Scan duration:            {0} h {1} min {2} sec' -f $Time_1768.Hours, $Time_1768.Minutes, $Time_1768.Seconds) >> "$OUTPUT_FOLDER\Stats.txt"

    if (Test-Path "$OUTPUT_FOLDER\CobaltStrike\1768\1768.txt")
    {
        if (Get-Content -Path "$OUTPUT_FOLDER\CobaltStrike\1768\1768.txt" | Select-String -Pattern "Sanity check Cobalt Strike config: OK" -Quiet)
        {
            Write-Host "[Alert] Cobalt Strike Beacons Configuration found" -ForegroundColor Red
        }
    }
}

}

#endregion CobaltStrike

#############################################################################################################################################################################################
#############################################################################################################################################################################################

#region SecureArchive

Function SecureArchive {

# Get End Time
$EndTime_Processing = (Get-Date)

# Total Processing Duration
$Time_Processing = ($EndTime_Processing-$StartTime_Processing)
('Total Processing duration:     {0} h {1} min {2} sec' -f $Time_Processing.Hours, $Time_Processing.Minutes, $Time_Processing.Seconds) >> "$OUTPUT_FOLDER\Stats.txt"

# Creating Secure Archive
if (Test-Path "$($7za)") 
{
    if (Test-Path "$($OUTPUT_FOLDER)") 
    {
        Write-Output "[Info]  Preparing Secure Archive Container ... "
        & $7za a -mx5 -mhe "-p$PASSWORD" -t7z "$OUTPUT_FOLDER.7z" "$OUTPUT_FOLDER\*" > $null 2>&1
    }

    # Archive Size
    $Length = (Get-Item -Path "$OUTPUT_FOLDER.7z").Length
    $Size = Get-FileSize($Length)
    Write-Output "[Info]  Archive Size: $Size"

    # Cleaning up
    if (Test-Path "$($OUTPUT_FOLDER)")
    {
        Get-ChildItem -Path "$OUTPUT_FOLDER" -Recurse | Remove-Item -Force -Recurse
        Remove-Item "$OUTPUT_FOLDER" -Force
    }
}
else
{
    Write-Host "[Error] 7za.exe NOT found." -ForegroundColor Red
}

}

#endregion SecureArchive

#############################################################################################################################################################################################
#############################################################################################################################################################################################

#region Footer

Function Footer {

# Shutting Down (Unmount)
if (Get-Process -Name "MemProcFS" -ErrorAction SilentlyContinue)
{
    # MessageBox UI
    $Form = New-Object System.Windows.Forms.Form
    $Form.TopMost = $true
    $MessageBody = "Happy Hunting!`n`nMemProcFS - The Memory Process File System by Ulf Frisk`nhttps://github.com/ufrisk/MemProcFS`n`nPress OK to shutdown virtual file system (Unmount)`n`nNote: Elasticsearch will also be stopped."
    $MessageTitle = "MemProcFS-Analyzer.ps1 (https://lethal-forensics.com/)"
    $ButtonType = "OK"
    $MessageIcon = "Info"
    $Result = [System.Windows.Forms.MessageBox]::Show($Form, $MessageBody, $MessageTitle, $ButtonType, $MessageIcon)

    if ($Result -eq "OK" ) 
    {
        Write-Output "[Info]  Shutting Down (Unmount) ..."
        Start-Sleep -Seconds 1

        # MemProcFS
        [void][System.Reflection.Assembly]::LoadWithPartialName("'Microsoft.VisualBasic")
        [void][System.Reflection.Assembly]::LoadWithPartialName("'System.Windows.Forms")
        $Process = Get-Process | Where-Object {$_.Name -eq "MemProcFS"}
        [Microsoft.VisualBasic.Interaction]::AppActivate($Process.Id)
        [System.Windows.Forms.SendKeys]::SendWait("^{c}")

        # Kibana
        if ($Kibana_Termination)
        {
            $Kibana_Termination.CloseMainWindow() > $null
        }

        # Elasticsearch
        if ($Elasticsearch_Termination)
        {
            $Elasticsearch_Termination.CloseMainWindow() > $null
        }

        # Wait for MemProcFS to shut down properly before exiting MemProcFS-Analyzer
        while(@(Get-Process | Where-Object {$_.Name -eq "MemProcFS"}).Count -gt 0) {
            Start-Sleep -Milliseconds 100
        }

        Start-Sleep -Seconds 1
    }
}

# Get End Time
$EndTime_Analysis = (Get-Date)

# Overall Analysis Duration
Write-Output ""
Write-Output "FINISHED!"
$Time_Analysis = ($EndTime_Analysis-$StartTime_Analysis)
$ElapsedTime_Analysis = ('Overall analysis duration: {0} h {1} min {2} sec' -f $Time_Analysis.Hours, $Time_Analysis.Minutes, $Time_Analysis.Seconds)
Write-Output "$ElapsedTime_Analysis"

# Stop logging
Write-Output ""
Stop-Transcript

# Remove Variables

# ClamAV
if (!($null -eq $ClamAV))
{
    Remove-Variable -Name "ClamAV" -Scope Script
}

# ForensicTimelineCSV
if (!($null -eq $ForensicTimelineCSV))
{
    Remove-Variable -Name "ForensicTimelineCSV" -Scope Script
}

# ForensicTimelineXLSX
if (!($null -eq $ForensicTimelineXLSX))
{
    Remove-Variable -Name "ForensicTimelineXLSX" -Scope Script
}

# OfflineMode
if (!($null -eq $OfflineMode))
{
    Remove-Variable -Name "OfflineMode" -Scope Script
}

# YaraRules
if (!($null -eq $YaraRules))
{
    Remove-Variable -Name "YaraRules" -Scope Script
}

# Reset Progress Preference
$Global:ProgressPreference = $OriginalProgressPreference

# Set Windows Title back to default
$Host.UI.RawUI.WindowTitle = "$DefaultWindowsTitle"

}

#endregion Footer

#############################################################################################################################################################################################
#############################################################################################################################################################################################

#region Main

# Main
Header
#Elasticsearch
MicrosoftDefender
MemProcFS
#ELKImport

if ($ClamAV -eq "Enabled")
{
    ClamAVUpdate
    ClamAV
}

Documents
DFIRBatch
#LNK
#LNK_Hunt
ImageMount
Modules
#Invoke-1768
SecureArchive
Footer

#endregion Main

```

`README.md`:

```md
<p align="center"><a href="https://github.com/PowerShell/PowerShell"><img src="https://img.shields.io/badge/Language-Powershell-blue" style="text-align:center;display:block;"></a> <a href="https://github.com/LETHAL-FORENSICS/MemProcFS-Analyzer/wiki"><img src="https://img.shields.io/badge/Wiki-Documentation-blue" style="text-align:center;display:block;"></a> <a href="https://github.com/LETHAL-FORENSICS/MemProcFS-Analyzer/releases/latest"><img src="https://img.shields.io/github/v/release/LETHAL-FORENSICS/MemProcFS-Analyzer?label=Release" style="text-align:center;display:block;"></a> <img src="https://img.shields.io/badge/Maintenance%20Level-Actively%20Developed-brightgreen" style="text-align:center;display:block;"></a> <img src="https://img.shields.io/badge/Digital%20Signature-Valid-brightgreen" style="text-align:center;display:block;"></a> <a href="https://x.com/LETHAL_DFIR"><img src="https://img.shields.io/twitter/follow/LETHAL_DFIR?style=social" style="text-align:center;display:block;"></a></p>

# MemProcFS-Analyzer
MemProcFS-Analyzer.ps1 is a PowerShell script utilized to simplify the usage of MemProcFS and to optimize your memory analysis workflow.

MemProcFS - The Memory Process File System by [Ulf Frisk](https://x.com/ulffrisk)  
https://github.com/ufrisk/MemProcFS  

Features:
* Fast and easy memory analysis!
* You can mount a memory snapshot (Raw Physical Memory Dump or Microsoft Crash Dump) like a disk image and handle the memory compression feature on Windows
* Auto-Install of MemProcFS, AmcacheParser, AppCompatCacheParser, Elasticsearch, entropy, EvtxECmd, ImportExcel, IPinfo CLI, jq, Kibana, lnk_parser, RECmd, SBECmd, xsv, YARA, and Zircolite  
* Auto-Update of MemProcFS, AmcacheParser, AppCompatCacheParser, Elasticsearch, entropy, EvtxECmd (incl. Maps), ImportExcel, IPinfo CLI, jq, Kibana, lnk_parser, RECmd, SBECmd, xsv, YARA, and Zircolite   
* Update-Info when there's a new version of ClamAV or a new Dokany File System Library Bundle available  
* Pagefile Support
* OS Fingerprinting  
* Scan w/ Custom YARA rules (incl. 423 rules by e.g. [Chronicle](https://github.com/chronicle/GCTI/tree/main/YARA) and [Elastic Security](https://github.com/elastic/protections-artifacts))  
* Multi-Threaded scan w/ ClamAV for Windows  
* Collection of infected files detected by ClamAV for further analysis (PW: infected)
* Collection of injected modules detected by MemProcFS PE_INJECT for further analysis (PW: infected)
* Extracting IPv4/IPv6  
* IP2ASN Mapping and GeoIP w/ [IPinfo CLI](https://github.com/ipinfo/cli) &#8594; Get your token for free at [https://ipinfo.io/signup](https://ipinfo.io/signup)  
* Checking for Suspicious Port Numbers
* [Process Tree](https://github.com/LETHAL-FORENSICS/MemProcFS-Analyzer/wiki/Process-Tree) (TreeView) including complete Process Call Chain (Special thanks to [Dominik Schmidt](https://github.com/DaFuqs))
* Checking Processes for Unusual Parent-Child Relationships and Number of Instances  
* Checking Processes for Unusual User Context
* Checking for Process Path Masquerading and Process Name Masquerading (Damerau Levenshtein Distance)
* Web Browser History (Google Chrome, Microsoft Edge and Firefox) 
* Extracting Windows Event Log Files and processing w/ EvtxECmd &#8594; Timeline Explorer ([EZTools](https://ericzimmerman.github.io/) by Eric Zimmerman) 
* Event Log Overview  
* Processing Windows Event Logs w/ [Zircolite](https://github.com/wagga40/Zircolite) - A standalone SIGMA-based detection tool for EVTX
* Analyzing extracted Amcache.hve w/ Amcacheparser ([EZTools](https://ericzimmerman.github.io/) by Eric Zimmerman)  
* Analyzing Application Compatibility Cache aka ShimCache w/ AppCompatcacheParser ([EZTools](https://ericzimmerman.github.io/) by Eric Zimmerman)  
* Analyzing Syscache w/ RECmd ([EZTools](https://ericzimmerman.github.io/) by Eric Zimmerman)  
* Analyzing UserAssist Artifacts w/ RECmd ([EZTools](https://ericzimmerman.github.io/) by Eric Zimmerman)  
* Analyzing ShellBags Artifacts w/ RECmd ([EZTools](https://ericzimmerman.github.io/) by Eric Zimmerman)  
* Simple Prefetch View (based on Forensic Timeline)  
* Analyzing Auto-Start Extensibility Points (ASEPs) w/ RECmd ([EZTools](https://ericzimmerman.github.io/) by Eric Zimmerman)  
* Analyzing RecentDocs, Office Trusted Document w/ RECmd ([EZTools](https://ericzimmerman.github.io/) by Eric Zimmerman)  
* Analyzing Registry w/ DFIR RECmd Batch File ([DFIR Batch File](https://github.com/EricZimmerman/RECmd/blob/master/BatchExamples/DFIRBatch.md) by Andrew Rathbun)  
* Analyzing Metadata of Recovered Process Modules (experimental)  
* Extracting Windows Shortcut Files (LNK)  
* Hunting Malicious Windows Shortcut Files (LNK)
* Integration of PowerShell module [ImportExcel](https://github.com/dfinke/ImportExcel) by Doug Finke
* CSV output data for analysis w/ Timeline Explorer (e.g. timeline-reverse.csv, findevil.csv, web.csv)  
* Collecting Evidence Files (Secure Archive Container &#8594; PW: MemProcFS)  
* and much more

## Download 
Download the latest version of **MemProcFS-Analyzer** from the [Releases](https://github.com/LETHAL-FORENSICS/MemProcFS-Analyzer/releases) section.  

## Usage  
Launch Windows PowerShell (or Windows PowerShell ISE or Visual Studio Code w/ PSVersion: 5.1) as Administrator and open/run MemProcFS-Analyzer.ps1. 

![File-Browser](https://github.com/LETHAL-FORENSICS/MemProcFS-Analyzer/blob/0780ec4a5fc62219e12791456f5f1e38d5b10b1a/Screenshots/01.png)  
**Fig 1:** Select your Memory Snapshot and select your pagefile.sys (Optional)

![Auto-Install](https://github.com/LETHAL-FORENSICS/MemProcFS-Analyzer/blob/0780ec4a5fc62219e12791456f5f1e38d5b10b1a/Screenshots/02.png)  
**Fig 2:** MemProcFS-Analyzer auto-installs dependencies (First Run)

![Microsoft-Internet-Symbol-Store](https://github.com/LETHAL-FORENSICS/MemProcFS-Analyzer/blob/0780ec4a5fc62219e12791456f5f1e38d5b10b1a/Screenshots/03.png)  
**Fig 3:** Accept Terms of Use (First Run)  

![MemProcFS](https://github.com/LETHAL-FORENSICS/MemProcFS-Analyzer/blob/0780ec4a5fc62219e12791456f5f1e38d5b10b1a/Screenshots/04.png)  
**Fig 4:** If you find MemProcFS useful, please become a sponsor at: https://github.com/sponsors/ufrisk  

![Mounted](https://github.com/LETHAL-FORENSICS/MemProcFS-Analyzer/blob/0bb85b553644a29675e4116133e7346b080d07a2/Screenshots/05.png)  
**Fig 5:** You can investigate the mounted memory dump by exploring drive letter

![Auto-Update](https://github.com/LETHAL-FORENSICS/MemProcFS-Analyzer/blob/0780ec4a5fc62219e12791456f5f1e38d5b10b1a/Screenshots/06.png)  
**Fig 6:** MemProcFS-Analyzer checks for updates (Second Run) 

Note: It's recommended to uncomment/disable the "Updater" function after installation. Check out the "Main" in the bottom of the script.

![FindEvil](https://github.com/LETHAL-FORENSICS/MemProcFS-Analyzer/blob/0780ec4a5fc62219e12791456f5f1e38d5b10b1a/Screenshots/07.png)  
**Fig 7:** FindEvil feature and additional analytics

![Processes](https://github.com/LETHAL-FORENSICS/MemProcFS-Analyzer/blob/0bb85b553644a29675e4116133e7346b080d07a2/Screenshots/08.png)  
**Fig 8:** Processes

![RunningAndExited](https://github.com/LETHAL-FORENSICS/MemProcFS-Analyzer/blob/8af0a369fab704daa9bb8b59be69f4d6a885d33f/Screenshots/09.png)  
**Fig 9:** Running and Exited Processes

![ProcessTree](https://github.com/LETHAL-FORENSICS/MemProcFS-Analyzer/blob/0bb85b553644a29675e4116133e7346b080d07a2/Screenshots/10.png)  
**Fig 10:** Process Tree (GUI)

![ProcessTreeSearch](https://github.com/LETHAL-FORENSICS/MemProcFS-Analyzer/blob/0bb85b553644a29675e4116133e7346b080d07a2/Screenshots/11.png)  
**Fig 11:** Checking Process Tree (to find anomalies)

![ProcessTreeAlerts](https://github.com/LETHAL-FORENSICS/MemProcFS-Analyzer/blob/0bb85b553644a29675e4116133e7346b080d07a2/Screenshots/12.png)  
**Fig 12:** Process Tree: Alert Messages w/ Process Call Chain

![PropertiesView](https://github.com/LETHAL-FORENSICS/MemProcFS-Analyzer/blob/0bb85b553644a29675e4116133e7346b080d07a2/Screenshots/13.png)  
**Fig 13:** Process Tree: Properties View &#8594; Double-Click on a process or alert message

![IPinfo](https://github.com/LETHAL-FORENSICS/MemProcFS-Analyzer/blob/0bb85b553644a29675e4116133e7346b080d07a2/Screenshots/14.png)  
**Fig 14:** GeoIP w/ IPinfo.io

![MapReport](https://github.com/LETHAL-FORENSICS/MemProcFS-Analyzer/blob/0bb85b553644a29675e4116133e7346b080d07a2/Screenshots/15.png)  
**Fig 15:** Map IPs w/ IPinfo.io

![EVTX](https://github.com/LETHAL-FORENSICS/MemProcFS-Analyzer/blob/0bb85b553644a29675e4116133e7346b080d07a2/Screenshots/16.png)  
**Fig 16:** Processing Windows Event Logs (EVTX)

![Zircolite](https://github.com/LETHAL-FORENSICS/MemProcFS-Analyzer/blob/0bb85b553644a29675e4116133e7346b080d07a2/Screenshots/17.png)  
**Fig 17:** Zircolite - A standalone SIGMA-based detection tool for EVTX (Mini-GUI)

![Amcache](https://github.com/LETHAL-FORENSICS/MemProcFS-Analyzer/blob/0bb85b553644a29675e4116133e7346b080d07a2/Screenshots/18.png)  
**Fig 18:** Processing extracted Amcache.hve &#8594; XLSX  

![ShimCache](https://github.com/LETHAL-FORENSICS/MemProcFS-Analyzer/blob/0bb85b553644a29675e4116133e7346b080d07a2/Screenshots/19.png)  
**Fig 19:** Processing ShimCache &#8594; XLSX  

![Timeline-Explorer](https://github.com/LETHAL-FORENSICS/MemProcFS-Analyzer/blob/0bb85b553644a29675e4116133e7346b080d07a2/Screenshots/20.png)  
**Fig 20:** Analyze CSV output w/ Timeline Explorer (TLE)

![ELK-Import](https://github.com/LETHAL-FORENSICS/MemProcFS-Analyzer/blob/0bb85b553644a29675e4116133e7346b080d07a2/Screenshots/21.png)  
**Fig 21:** ELK Import

![ELK-Timeline](https://github.com/LETHAL-FORENSICS/MemProcFS-Analyzer/blob/0bb85b553644a29675e4116133e7346b080d07a2/Screenshots/22.png)  
**Fig 22:** Happy ELK Hunting!

![Secure-Archive-Container](https://github.com/LETHAL-FORENSICS/MemProcFS-Analyzer/blob/0780ec4a5fc62219e12791456f5f1e38d5b10b1a/Screenshots/23.png)  
**Fig 23:** Multi-Threaded ClamAV Scan to help you finding evil! ;-)

![Message-Box](https://github.com/LETHAL-FORENSICS/MemProcFS-Analyzer/blob/0bb85b553644a29675e4116133e7346b080d07a2/Screenshots/24.png)  
**Fig 24:** Press **OK** to shutdown MemProcFS and Elastisearch/Kibana

![Output](https://github.com/LETHAL-FORENSICS/MemProcFS-Analyzer/blob/0bb85b553644a29675e4116133e7346b080d07a2/Screenshots/25.png)  
**Fig 25:** Secure Archive Container (PW: MemProcFS)  

## Introduction MemProcFS and Memory Forensics  
Check out [Super Easy Memory Forensics](https://www.slideshare.net/IIJ_PR/super-easy-memory-forensics) by [Hiroshi Suzuki](https://twitter.com/herosi_t) and [Hisao Nashiwa](https://twitter.com/unk0unk0).

## Prerequisites 
1. Download and install the latest Dokany Library Bundle &#8594; DokanSetup.exe  
https://github.com/dokan-dev/dokany/releases/latest  

2. Download and install the latest .NET 9 Desktop Runtime (Requirement for [EZTools](https://ericzimmerman.github.io/))  
https://dotnet.microsoft.com/en-us/download/dotnet/9.0   

3. Download and install the latest Windows package of ClamAV.  
https://www.clamav.net/downloads#otherversions 

4. First Time Set-Up of ClamAV  
Launch Windows PowerShell console as Administrator.  
`cd "C:\Program Files\ClamAV"`  
`copy .\conf_examples\freshclam.conf.sample .\freshclam.conf`  
`copy .\conf_examples\clamd.conf.sample .\clamd.conf`  
`write.exe .\freshclam.conf`  &#8594; Comment or remove the line that says "Example".  
`write.exe .\clamd.conf` &#8594; Comment or remove the line that says "Example".  
https://docs.clamav.net/manual/Usage/Configuration.html#windows  

5. Optimize ClamAV scan speed performance (30% faster)    
Open "C:\Program Files\ClamAV\clamd.conf" with your text editor and search for: "Don't scan files and directories matching regex"  
`ExcludePath "\\heaps\\"`  
`ExcludePath "\\handles\\"`  
`ExcludePath "\\memmap\\vad-v\\"`  
`ExcludePath "\\sys\\pool\\"`  

6. Create your free IPinfo account [approx. 1-2 min]  
https://ipinfo.io/signup?ref=cli  
Open "MemProcFS-Analyzer.ps1" with your text editor, search for "Please insert your Access Token here" and copy/paste your access token.

7. Install the NuGet package provider for PowerShell  
Check if NuGet is available in the package providers by running the following command:  
`Get-PackageProvider -ListAvailable`  
If NuGet is not installed on your system yet, you have to install it.  
`Install-PackageProvider -Name NuGet -Force`  

8. Make sure to comment/uncomment (selectively enable or disable) the functions you want to play with (Elasticsearch and ELKImport are disabled by default). Check out the "Main" in the bottom of the script.  

9. Launch the Automated Installer/Updater for MemProcFS-Analyzer  
`.\Updater.ps1`  

10.  Done! :smiley:   

Notes: 
- Turn off your antivirus protection temporarily or better exclude your MemProcFS-Analyzer directory from scanning (e.g. Zircolite).  
- [Elasticsearch Tips](https://github.com/LETHAL-FORENSICS/MemProcFS-Analyzer/wiki/Elasticsearch)

## Dependencies
7-Zip 25.00 Standalone Console (2025-07-05)  
https://www.7-zip.org/download.html  

AmcacheParser v1.5.2.0 (.NET 9)  
https://ericzimmerman.github.io/  

AppCompatCacheParser v1.5.1.0 (.NET 9)  
https://ericzimmerman.github.io/  

ClamAV - Download --> Windows --> clamav-1.5.1.win.x64.msi (2025-10-15)  
https://www.clamav.net/downloads    

Dokany File System Library v2.3.1.1000 (2025-09-28)  
https://github.com/dokan-dev/dokany/releases/latest &#8594; DokanSetup.exe  

Elasticsearch 9.1.5 (2025-10-06)  
https://www.elastic.co/downloads/elasticsearch  

entropy v1.1 (2023-07-28)  
https://github.com/merces/entropy  

EvtxECmd v1.5.2.0 (.NET 9)  
https://ericzimmerman.github.io/  

ImportExcel v7.8.10 (2024-10-21)   
https://github.com/dfinke/ImportExcel  

IPinfo CLI 3.3.1 (2024-03-01)    
https://github.com/ipinfo/cli  

jq v1.8.1 (2025-07-01)  
https://github.com/stedolan/jq  

Kibana 9.1.5 (2025-10-06)   
https://www.elastic.co/downloads/kibana  

llnk_parser v0.4.1 (2025-01-02)  
https://github.com/AbdulRhmanAlfaifi/lnk_parser  

MemProcFS v5.16.4 - The Memory Process File System (2025-10-21)    
https://github.com/ufrisk/MemProcFS  

RECmd v2.1.0.0 (.NET 9)  
https://ericzimmerman.github.io/  

SBECmd v2.1.0.0 (.NET 9)  
https://ericzimmerman.github.io/  

xsv v0.13.0 (2018-05-12)  
https://github.com/BurntSushi/xsv  

YARA v4.5.4 (2025-05-27)  
https://virustotal.github.io/yara/  

Zircolite v2.40.0 (2025-04-06)  
https://github.com/wagga40/Zircolite  

## Links
[MemProcFS](https://github.com/ufrisk/MemProcFS)  
[Demo of MemProcFS with Elasticsearch](https://www.youtube.com/watch?v=JcIlowlrvyI)  
[Sponsor MemProcFS Project](https://github.com/sponsors/ufrisk)  
[MemProcFS-Plugins](https://github.com/ufrisk/MemProcFS-Plugins)  

```

`Scripts/1768/1768.json`:

```json
{
    "dLookupValues": {
                         "LASTUPDATE": "2025/03/05",
                         "URL": "https://www.cobaltstrike.com/help-authorization-files",
                         "37": {
                                  "0": "trial or pirated? - Stats uniques -> ips/hostnames: 810 publickeys: 488",
                                  "1": "Finspy - Stats uniques -> ips/hostnames: 32 publickeys: 22",
                                  "100000": "Stats uniques -> ips/hostnames: 151 publickeys: 123",
                                  "100000000": "Stats uniques -> ips/hostnames: 2 publickeys: 2",
                                  "1011266395": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
                                  "1049482653": "Stats uniques -> ips/hostnames: 4 publickeys: 4",
                                  "1061821957": "Stats uniques -> ips/hostnames: 4 publickeys: 1",
                                  "1083092832": "Stats uniques -> ips/hostnames: 2 publickeys: 2",
                                  "1116519211": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
                                  "1132913209": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
                                  "1158277545": "Stats uniques -> ips/hostnames: 3 publickeys: 2",
                                  "1200302529": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
                                  "1225345476": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
                                  "12345": "Stats uniques -> ips/hostnames: 18 publickeys: 17",
                                  "123456789": "Stats uniques -> ips/hostnames: 2 publickeys: 2",
                                  "1234567890": "Stats uniques -> ips/hostnames: 318 publickeys: 254",
                                  "124184377": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
                                  "1262867465": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
                                  "1272670358": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
                                  "1293635912": "Stats uniques -> ips/hostnames: 3 publickeys: 1",
                                  "1293900656": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
                                  "1303352523": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
                                  "1330515036": "Stats uniques -> ips/hostnames: 2 publickeys: 2",
                                  "1335920331": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
                                  "1357776117": "Stats uniques -> ips/hostnames: 20 publickeys: 19",
                                  "1359593325": "TrickBot/SmokeLoader/Nobelium/APT29 - Stats uniques -> ips/hostnames: 252 publickeys: 180",
                                  "1360912112": "Stats uniques -> ips/hostnames: 3 publickeys: 3",
                                  "1393887967": "Stats uniques -> ips/hostnames: 3 publickeys: 1",
                                  "1405263916": "Stats uniques -> ips/hostnames: 4 publickeys: 2",
                                  "144392904": "Stats uniques -> ips/hostnames: 3 publickeys: 3",
                                  "1444589874": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
                                  "145064000": "Stats uniques -> ips/hostnames: 5 publickeys: 3",
                                  "1453642741": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
                                  "1473793097": "Stats uniques -> ips/hostnames: 2 publickeys: 2",
                                  "1485646134": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
                                  "153163702": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
                                  "1548680553": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
                                  "1580103814": "APT27/Qbot/IcedID/DarkSide/Conti/Hancitor/WizardSpider - Stats uniques -> ips/hostnames: 85 publickeys: 39",
                                  "1580103824": "Stats uniques -> ips/hostnames: 328 publickeys: 157",
                                  "1590258876": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
                                  "1616449647": "Stats uniques -> ips/hostnames: 3 publickeys: 2",
                                  "1628610335": "Stats uniques -> ips/hostnames: 2 publickeys: 2",
                                  "1654965272": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
                                  "1670873463": "Stats uniques -> ips/hostnames: 5 publickeys: 5",
                                  "16777216": "Ryuk - Stats uniques -> ips/hostnames: 19 publickeys: 19",
                                  "1711276032": "Stats uniques -> ips/hostnames: 22 publickeys: 19",
                                  "172432245": "Stats uniques -> ips/hostnames: 3 publickeys: 1",
                                  "1747585830": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
                                  "1755231": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
                                  "1759199920": "Stats uniques -> ips/hostnames: 5 publickeys: 1",
                                  "1807886020": "Stats uniques -> ips/hostnames: 3 publickeys: 1",
                                  "1833641615": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
                                  "1857223080": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
                                  "1873433027": "TA511/Hancitor - Stats uniques -> ips/hostnames: 36 publickeys: 29",
                                  "1880445158": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
                                  "1895490765": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
                                  "1905905741": "Stats uniques -> ips/hostnames: 5 publickeys: 1",
                                  "1914732777": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
                                  "1946802187": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
                                  "2002705334": "Stats uniques -> ips/hostnames: 3 publickeys: 1",
                                  "2026810553": "Stats uniques -> ips/hostnames: 3 publickeys: 3",
                                  "206546002": "Stats uniques -> ips/hostnames: 81 publickeys: 33",
                                  "2072955520": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
                                  "2091175951": "Stats uniques -> ips/hostnames: 2 publickeys: 2",
                                  "2093052102": "Stats uniques -> ips/hostnames: 5 publickeys: 1",
                                  "2130772225": "Stats uniques -> ips/hostnames: 3 publickeys: 3",
                                  "245750012": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
                                  "281013626": "Stats uniques -> ips/hostnames: 3 publickeys: 1",
                                  "289336829": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
                                  "294598720": "Stats uniques -> ips/hostnames: 3 publickeys: 1",
                                  "305419776": "Stats uniques -> ips/hostnames: 63 publickeys: 20",
                                  "305419896": "Ryuk/TrickBot/Maze/EvilCorp/Pyxie/APT41 - Stats uniques -> ips/hostnames: 340 publickeys: 200",
                                  "3203391215": "Stats uniques -> ips/hostnames: 2 publickeys: 2",
                                  "3324337203": "Stats uniques -> ips/hostnames: 2 publickeys: 2",
                                  "356779728": "Stats uniques -> ips/hostnames: 4 publickeys: 1",
                                  "388888888": "Stats uniques -> ips/hostnames: 8 publickeys: 7",
                                  "391144938": "Stats uniques -> ips/hostnames: 183 publickeys: 155",
                                  "396590767": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
                                  "401466503": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
                                  "426352781": "Stats uniques -> ips/hostnames: 343 publickeys: 264",
                                  "437577603": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
                                  "472168751": "Stats uniques -> ips/hostnames: 3 publickeys: 1",
                                  "475294171": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
                                  "491167506": "Stats uniques -> ips/hostnames: 3 publickeys: 3",
                                  "508419252": "Stats uniques -> ips/hostnames: 3 publickeys: 1",
                                  "527324335": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
                                  "540231004": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
                                  "555758901": "Stats uniques -> ips/hostnames: 3 publickeys: 2",
                                  "558468349": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
                                  "563527380": "Stats uniques -> ips/hostnames: 4 publickeys: 4",
                                  "571338205": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
                                  "574247": "Stats uniques -> ips/hostnames: 2 publickeys: 2",
                                  "579328998": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
                                  "582298219": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
                                  "587247372": "Stats uniques -> ips/hostnames: 33 publickeys: 26",
                                  "6": "Stats uniques -> ips/hostnames: 26 publickeys: 23",
                                  "600047618": "Stats uniques -> ips/hostnames: 4 publickeys: 1",
                                  "637809541": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
                                  "666": "Stats uniques -> ips/hostnames: 3 publickeys: 3",
                                  "666104495": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
                                  "666666": "Stats uniques -> ips/hostnames: 27 publickeys: 25",
                                  "666666666": "Stats uniques -> ips/hostnames: 78 publickeys: 48",
                                  "667778797": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
                                  "668694132": "Stats uniques -> ips/hostnames: 8 publickeys: 8",
                                  "672512560": "Stats uniques -> ips/hostnames: 3 publickeys: 1",
                                  "674054486": "Stats uniques -> ips/hostnames: 63 publickeys: 49",
                                  "678358251": "Stats uniques -> ips/hostnames: 14 publickeys: 14",
                                  "680943040": "Stats uniques -> ips/hostnames: 3 publickeys: 1",
                                  "688983459": "Stats uniques -> ips/hostnames: 3 publickeys: 1",
                                  "697620223": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
                                  "707557615": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
                                  "708858010": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
                                  "751173766": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
                                  "768314204": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
                                  "775423106": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
                                  "77771151": "Stats uniques -> ips/hostnames: 5 publickeys: 1",
                                  "785920802": "Stats uniques -> ips/hostnames: 10 publickeys: 7",
                                  "804449981": "Stats uniques -> ips/hostnames: 3 publickeys: 1",
                                  "806236289": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
                                  "856409489": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
                                  "863200806": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
                                  "8848": "Stats uniques -> ips/hostnames: 12 publickeys: 12",
                                  "894274846": "Stats uniques -> ips/hostnames: 3 publickeys: 1",
                                  "921421590": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
                                  "9527": "Stats uniques -> ips/hostnames: 2 publickeys: 1",
                                  "96906161": "Stats uniques -> ips/hostnames: 4 publickeys: 1",
                                  "987654321": "Stats uniques -> ips/hostnames: 781 publickeys: 707",
                                  "452436291": "REvil/Sodin/Sodinokibi - No stats",
                                  "3": "Cobalt Group - No stats",
                                  "849087011": "SolarStorm - No stats",
                                  "892810033": "Teardrop/SolarStorm - No stats"
                               },
                         "7": {
                                  "30819f300d06092a864886f70d010101050003818d003081890281810080fa8dc59ec39b73d49523c640c1cdfabbb0f0b15e943f2429c0c360862c938fb474523a0116f2ea71877f24218fc85cd959017cd0f987ec443a731a4d29a7a8fe1312d2edace8a736515d120c8f7b5e0008b7403ee3511435367f223c474ec2c0913c1dede6c1124b5089dc2aec3ef37ce24009a590ef4b8398f52e75c1f2ed020301000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000": {"normal": "Has known private key", "verbose": "30820275020100300d06092a864886f70d01010105000482025f3082025b0201000281810080fa8dc59ec39b73d49523c640c1cdfabbb0f0b15e943f2429c0c360862c938fb474523a0116f2ea71877f24218fc85cd959017cd0f987ec443a731a4d29a7a8fe1312d2edace8a736515d120c8f7b5e0008b7403ee3511435367f223c474ec2c0913c1dede6c1124b5089dc2aec3ef37ce24009a590ef4b8398f52e75c1f2ed02030100010281800d789de81f1df515930584b8073976c7126577ae3edfa2fca6f3c0344baf4a363f35cb04cdea54b2d1eac207c70d9a72c02cc0b005af9a57be0490d3156e1d59ac7837c74987a296671f4264781050d39ccc16f5f5024699fe6f3aad9b77e874117e213b369ef6c58c43a4423585db42eb022251914f3110b52532620fe82dad024100f6c00bf6a8e14566029cfdfef39a77c50511056f235a0dc71b46c5d5b17b6494c290496a3d76635d5ae21f615bc5e04e2a2a2001957fec6b3ce88c0ca9a36aaf02410085d04e59788f32150b4039fc0140fa06a66181cb463cdec2d573111e8904fd4aadffa63e8f2f2063c7e212bef5981c1ed2ff6f1163a04662d483067658ceb32302403b44035b9a528935a83906f4be9402626b061c95061bb2257992b51fcf8240b54e4a13a815dd229ea09ea144e42311ee14488be9757c054ff8902e5b383f8cf702407fcd78d74926f2bd58968a0adf23b0e8a30623d2028e666f8d2fae1d0cdec010106947dd1e21f37c794eb97abad4019f8b043d8f4d28a9b100a8f78616c1ac2302403e247b8970b1e457b2c82759d3427a24edfa7d309a4a619ebfcab16cb2593a67564fe7c4d68b73958f856831e9fe1d4ba2ec4281234a2a903b4b07a50084b3d5"},
                                  "30819f300d06092a864886f70d010101050003818d003081890281810084a5630da30447225f084704e282f6bea8bbb0a7043c30d0a85a0ab530d500ab7eb4e76eb6625ff6d65aae874aec7d2e5d2328fec7facabbec4d7d95e90276e6067f35aff4eb50285dcfd9a507a72c7d2e1e759ad171e55cf1b54a65584fd6dff42cd225b75ce08a1eac05b73b8a908e83a5d4784059d41434be80a37909255b020301000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000": {"normal": "Has known private key", "verbose": "30820275020100300d06092a864886f70d01010105000482025f3082025b0201000281810084a5630da30447225f084704e282f6bea8bbb0a7043c30d0a85a0ab530d500ab7eb4e76eb6625ff6d65aae874aec7d2e5d2328fec7facabbec4d7d95e90276e6067f35aff4eb50285dcfd9a507a72c7d2e1e759ad171e55cf1b54a65584fd6dff42cd225b75ce08a1eac05b73b8a908e83a5d4784059d41434be80a37909255b02030100010281805ee3fd874cde0b914010a8d58ac10b88fb2641ca4912520d82d1df251d88d310dbf4c837004c41c05039d0eec21f89b1b83925e395e60850054cae11a6fdf755abed6e9075ffecb741a2b08e111b330e4f0531432c7645e1901d203ee48659d5695ceb3491bd060db77909524f6137fc703ffc38bb770b6726990eba5aa89c71024100e0983b76c4750d60e3a6b03e011514eba3a102f32a0d415463e7f96ebc6465d687abe2f13da3494f2b3cb0e56f32100f871320d11fb6885f652e5c72bbf684a30241009731b07dff8a44f22cf4db024016ce65783bb132432075d6dd420d5e7099db11747c25e1fdb04f2786805075d1c3d72bbdd344b88adc3b67eadbc4225bf5afe902403d472bca3ed5d4fd9f7f464cd48cc4f579e29f646b0fccc852ade32f64755c17c9528b8bd88e699d1125f0f9d879e749e547c1c76d08a772a7af9b87ae63175302404dbc07711094679457d6e04f4ce22ce5f0a648197e77cefe54ade42fbd16ed9210e0cf9d5c906c71f6ee3bf0079478298e24743da96f47bfcaf988e2dd82f9190240010485538c262473c0220bdf626974992fc8936be653e02433cd288e87ca0d707ce5feccdded153b9db8933dc2551048611885cb276dfbafe92421df2245664b"},
                                  "30819f300d06092a864886f70d010101050003818d003081890281810093fad989ca301e1c35ea388ed3e0f8d103d7a021ee7dfc75d7084c7bcdf6a799fb4f0f8f008202f7b2c529632bf63572d2dc5029b7857790c5d2006d480100679c29bbfef2a021ad88fb6a0e26d3cd5bd7f6ddd620390cd4748f95ca11b86b641973a1a9b6cde3fa10987911a9ff4a57e4af084f810d40cef98ceb8956e6eb23020301000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000": {"normal": "Has known private key", "verbose": "30820276020100300d06092a864886f70d0101010500048202603082025c0201000281810093fad989ca301e1c35ea388ed3e0f8d103d7a021ee7dfc75d7084c7bcdf6a799fb4f0f8f008202f7b2c529632bf63572d2dc5029b7857790c5d2006d480100679c29bbfef2a021ad88fb6a0e26d3cd5bd7f6ddd620390cd4748f95ca11b86b641973a1a9b6cde3fa10987911a9ff4a57e4af084f810d40cef98ceb8956e6eb23020301000102818043b630fc5fcc0cbb13e08ce8ae02ef5794ce81b385119907c2d1454e113ca00c517627c463931a108578ba2b6ade4a2eb455a348b3751af4dfcfebea155c7ff633aadced7fb5e0a06d1e1b9bfdd0e619e2eb2913510b195f76f87eea9211b9ca52c6f6ae9fe97e46df01b7c795b69552f684a9e63e08549bdaadbdfc40e0df81024100eb1ecc1f525fc2784e7a7dfe9f247d2a4128afdce4d2234567c95f53cc4572e93eed600fad25e6cf41e718792abcbd25b24c4b901085a0a3db1260cc7e458353024100a11f02a6bb4d1b196243620e03f028baeb69a6a0bd354f6e7882244505dd68728d116d4bda6550b8c795d4c0ace55f644ab39803d629d5e14ca1bcad7d614ef1024069ed681d3c69741deb8d78323cd49da769cfc0db8e23b64c50a402d4a81529de37c18e23c1e86f8234b8bee7e7ff3c603d61ee312ba0686d2a07afa0b1caf38d02401fa036a5039edef2dc96dd6862dd81212f944d60bfc2f7147813138b78db3ce53f4b6c68b735abe2994a8fb84237c3c1abe814aeac1b0a206f2a501ebdbd9c01024100c09a42f14aca7b3ee139f78eaa24b77e173c23ec3aa1a9c2d081c12455f69d1e703ee8c70e834e5545dceb5b5917d2678b102da29873d28e8b16fe6e70cc153b"},
                                  "30819f300d06092a864886f70d010101050003818d0030818902818100a0c19b6be56991586a976ba6f176a4035268fe5d4faf038ccad9becd7f3ab8ab2d78df8e7cb9fc5789d38c8e848b54fdc1ab226059a99dd0a618ed8b776c39856d66ac862edff8e61d5a90cd8b177902f70638ecd085284467fd14cfc086fe073df6cc32b2c9f1b3460183d1e46b85a1d2e7f13bcf4a480a6e2de80b1398b5fd020301000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000": {"normal": "Has known private key", "verbose": "30820278020100300d06092a864886f70d0101010500048202623082025e02010002818100a0c19b6be56991586a976ba6f176a4035268fe5d4faf038ccad9becd7f3ab8ab2d78df8e7cb9fc5789d38c8e848b54fdc1ab226059a99dd0a618ed8b776c39856d66ac862edff8e61d5a90cd8b177902f70638ecd085284467fd14cfc086fe073df6cc32b2c9f1b3460183d1e46b85a1d2e7f13bcf4a480a6e2de80b1398b5fd020301000102818100878691942605990e745691e05d834b04adee6c3b989910a21ac5f5f0e3494b34ad12514e9be264561c9127d762f0e0474a860f66315129062571b09a3aa517dc09e2f06d9880e04590ea3aa9dd556778238b64b5512b4f7f6ff752c18f77c24f2002da73a0c15b5d0b2f2a2ad5a3c5538fbe881511dbad711d864a23033e6401024100ce7bf0fe9d175383ebd8a43bda2abacf7f9d0cad5cff56c29447c6ae83094a9b819daf7398d9ee924bc25d8cb503503af8ce739833641d93a73fcf34680c0cfd024100c74e6ebe0c9f4ed0d1d099e77821c71cf9d1eecf707af590bfbfa722248657db2ae3213f77fdb2e060497e86faf9030441eb7440f0e535c2db8f8b77aca41d010240791c69766e5dc8369097397d81b19e7126c0cf36c05d645e2ceb0cb63f55abd51a698b079a97f93f0600b32e5cdddca93a569da6a03e10bb1256730aa21caf610241009a5019e23ff7a09881bb174e666f10b158a3b8591867bb760560a85101229b27703f4760d2d0b50c90c0969c7ff908e2e4ff1e95a16e767f966bbfba3b0b1e01024100b24befa0618f4dd1c6a1ecd3fe2e153276749cef1fb3e13772a9a8bb117e46abb2fa19d707361f81ece7a413648f0032722992a83e909c8a9896458cb3534718"},
                                  "30819f300d06092a864886f70d010101050003818d0030818902818100a2e105c86c51aa20f5acde04b49423b30951600b0741533cd4e31fb0e24cf86b88c4b0e6596663d2425dcfd37dfe743146b06396b2bad828e9461c03cb052b71e5bb7cb17d2afc459007870a5d445ee3dadb5d267a197451e79fd4159347128e9de84da54bb32981042cf637fae69bf71f48046c0f63f49f95cb9af96d7aa611020301000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000": {"normal": "Has known private key", "verbose": "30820276020100300d06092a864886f70d0101010500048202603082025c02010002818100a2e105c86c51aa20f5acde04b49423b30951600b0741533cd4e31fb0e24cf86b88c4b0e6596663d2425dcfd37dfe743146b06396b2bad828e9461c03cb052b71e5bb7cb17d2afc459007870a5d445ee3dadb5d267a197451e79fd4159347128e9de84da54bb32981042cf637fae69bf71f48046c0f63f49f95cb9af96d7aa61102030100010281802559ff0e803096182adeb2a75795e53de8741dd74999a471fdcbfbf77f5df1560fae33770fa7585ade574f128c012f3a21a0cfa5be64f4af2517abd2fedab7a46f6d183d2b99400c0cc6edfaf848a0aa47bd7d37d15ad30d09896a1ae66a8a7f36a9c2bad29ff176ea059da23d296edfe1294c88d8c393c62ad1a0a3c3a472b1024100e9b2948230a1788bdaeb0d782694d10a50b1e63b123f696b13ad31b23560386b19cf498d9137ea394534042fd7791706919d27a333c19d18acc2baedb6b42af5024100b26c49989f0ef67e5d6c02705cf34c5293131539d1b8f4c6f6feda86a6dde4d2b48ac71162c75a36889bd84bd9d90065149f67671447f80193c010affb85152d024100a5bb54a083766fb3d71bece07194062f678cd236c039223ca2a6a7e0b703b6df155db0cee9d69a8fe4e8ffb321ff28fa2a9825fd127e5337a5852fe5d7352c6502403e9001ee663794ef124b013fed17d2b751a2eb5a6ed36fe1245290c58e55581b19fb5f7a152cd9d12d6d981660b8da8e97009dfd62fb2957443ba09e548f81b1024006a17a330302d8142084c6c28dce3c6b252af8b8291443d3be98c60ce7d2a2c45ffb5228201875f345b5bd1fc621f90ae63804908afc2b2a503a74ea27a5c5aa"},
                                  "30819f300d06092a864886f70d010101050003818d0030818902818100a70991d69d816a601ffa80976473830f0d3b41276d2790401ddedb18e2d3cab3c315e3222325be42b65adb2878f33f5a03ff5010b23e842a510c1482ad6a42f1e7e5726eb31813e7437640ed7879955f401e172c34d3517241596dd41f8e48d3d1b1c288e6c8752ff65dc27acccba4ba9cd6d0e4de6196cea4da480d3b99d0ed020301000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000": {"normal": "Has known private key", "verbose": "30820276020100300d06092a864886f70d0101010500048202603082025c02010002818100a70991d69d816a601ffa80976473830f0d3b41276d2790401ddedb18e2d3cab3c315e3222325be42b65adb2878f33f5a03ff5010b23e842a510c1482ad6a42f1e7e5726eb31813e7437640ed7879955f401e172c34d3517241596dd41f8e48d3d1b1c288e6c8752ff65dc27acccba4ba9cd6d0e4de6196cea4da480d3b99d0ed02030100010281807f61a2dfe1b9619ff0831e31559f6960bf1c62f1682275b50f9275cf229b94c7458c996bdd15d96412a072e50867a7f6437a1e5abd3343a2e9afa6ac8906b2097c61cf5b2bd95418bfc05b2a24405f1a18be182745e9e8669f8c97aa32ef0a13c2245ea7bb3556ea719963ccc01f1e19ec9e90204d5a3466e3b43b094e3d0999024100f56507e3fe143670ddce758e67687958f1747c4e92b7073dfb87d6a3c99634ca1f9e48f28adf26a17f53f931cd949d094f1087d883524435b62ec6aa17ca30db024100ae419e625e48545440bfc30a3ec134a3c961684578a27b265488a9f922a5e1a41c25a506065d3e4a11ed0095933531f4c29c548c64ec374a48e0995220a22bd7024039b361e19832c4825185645af1b1bd26cecfa7130aa882c96e458890c6abcd09e1d96429b3c1b8e1ac80e04d779b8439561ffaf14c1fa1ee47424470665ba295024026250310b166cfdee99590924b8e6b8176f1b5ab8f6eb1da8022b26270ed32e983a7d1e9f1b6b38def429c2021eb41163d0b8f8e740129513f86bac9398f865d024100cd1ce32d491348455d3ecd6462b7ed583d04ce74a8802142d36bb87e8e67ff86fb6d6b5a33ff183d987bf9ad787f5f0b468f74b3d210f10bd0266b504306e47c"},
                                  "30819f300d06092a864886f70d010101050003818d0030818902818100a738cde75f1fbb1c18646c377e03016b162b12ba72bdf7dc36b4cd2e4e9bae12205a95c26170bf908105ad7fa4bbccfa798632261bed9870f975f20794e1fe499523d71f08a56cae0315bfde3d6c8a16386b03b7a6551aa1336d50325a3500db27d78ad8fd13b6a73b9fb7c3fb4d7a088e323f07618656ecd83595fa5f823613020301000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000": {"normal": "Has known private key", "verbose": "30820276020100300d06092a864886f70d0101010500048202603082025c02010002818100a738cde75f1fbb1c18646c377e03016b162b12ba72bdf7dc36b4cd2e4e9bae12205a95c26170bf908105ad7fa4bbccfa798632261bed9870f975f20794e1fe499523d71f08a56cae0315bfde3d6c8a16386b03b7a6551aa1336d50325a3500db27d78ad8fd13b6a73b9fb7c3fb4d7a088e323f07618656ecd83595fa5f823613020301000102818059eb70c54ee078341665c1cf61426a7bd412db62491b1ff259b48574b62e7ebf1e88b7692c0e7de44d8ce90bef60514c0b16ff5680c415aa026acaf80ab62f8f30698c7132530ddd46a44b7777387037312e49c59dc5a00e20967435f74cac6703a201ec3431b86008e0d973fa775799bc7b8863037270a33829c081e6cbaa11024100e25d4778e0d1e1e5cb65be3836f5d64af06d054ec6e3b03f78f6bde89ef2d9e4b932b735fc264a5c7a3d2a7c66d00187c3dca51c3ef758fdfde70564c1c2e8e9024100bd1d5576d0e8569d711d5aca42fd808c1f7085c5ced215180360adabd6c553414fdf4ccd9b91d6995c35886636cb14e6f453bff341f56cbae67218c17077099b0240620f127514bf16e29af7da2d33f1cf00eba1ee98afa3d6a7c858eaefa85b7f748b9da2ac2a2cd42db76e63c73c2a835f32c3946ae603f47322d83f07e4bff07102402d2e19e1e5ecebec773ea51717440af6eef7e9eda50889a3900303dabed7ab9939e4c62b84d425a9c3dec2347138b948a7ec6e3a4672c4c42e13ea1824af3bab024100bd154581c5d399c838f476b75482886fcdf194d8419d6564a8dc8b9c074e044359519e3bf6868fc3b4a5f8dd120f5e53813db9fb83fa3ca1fc404ea1c02fe0e5"},
                                  "30819f300d06092a864886f70d010101050003818d0030818902818100a8b144135b042b57a1ca2048f5e0c624b98352933d53ca67003f97e8c3639898674b74a4de9406e05f85678a2ac13b653e7ab4fadf94e771d97ba2ee0dbe5876be50255f00404e094aecbc3ed3b286ac81f9b26a1e26df2c0363d4859e63d4c178d00e3228785f87e48623e64baa0624b88f8c969fd0be4f0e009edc107de509020301000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000": {"normal": "Has known private key", "verbose": "30820276020100300d06092a864886f70d0101010500048202603082025c02010002818100a8b144135b042b57a1ca2048f5e0c624b98352933d53ca67003f97e8c3639898674b74a4de9406e05f85678a2ac13b653e7ab4fadf94e771d97ba2ee0dbe5876be50255f00404e094aecbc3ed3b286ac81f9b26a1e26df2c0363d4859e63d4c178d00e3228785f87e48623e64baa0624b88f8c969fd0be4f0e009edc107de50902030100010281806090f9334b4adbb4d27cee7655aa5242fb9f5d49c4358f0bdf6c87fd4abc5cc2017f844a4ccfd80fe11e70e2fb0e9a7d9e8287cf84e5ac87d3c39ec53f40d34a578e4d83754c27cf1dfb128f3f6be73f2a62118a46d0558c9023129196320c27689f1f5d805f622b78ba72aa8777f249c7e9db10301f37d0728cc3672b515931024100e077b061144d5b1ec755d409edfa45fdd313d57da203c3b9c111dc526993efc20f7b33ee7671fadaba6324fb6315184817b6b386dc6b92cd442381a4c94d88fb024100c063ca70c9885ab25b1f91cd5396866d6fdd82e00935109aa4e98c306abfe23423e02a9de14440f47e77188a7ce9cdff2b353f9f5036d9c9b8d9c553907ff2cb024100c4e71938bf8770041ad5e64fe38ae474d9011008c9e345811fa4dc410ace33c666b02b88e62bebe28d17c56c23a97088650ce684c9bc2fa5923d174f872a559b02407835a207291566be2c8ba4396c32105a8edc146b51b573637d09648bd8177f0a5f2430dca7255384b1044f3430ea91c90f415d3879115cb15b2bceccf0ebd153024051dc4bc183d0828850189fb54a62b6f49c1c781cfbe4963356c7703c5825ba322eba5e2e1368b62ab414393d371c8f5df6b8966b621aed933fc469ff4ef3517d"},
                                  "30819f300d06092a864886f70d010101050003818d0030818902818100b22ee1f895f1d872618c1090316c5f5be9488c11056503b8c77fc2969850fe63f6fcd32708e8a5e49095c04526d73a509a46c4351640ce94598a4005d9b0af3b454e0b572002f524f88c34b5d3fbe2ec6508b7dbd6528b340d7fa6bf9a4529635e97845e0329b343b3e6d290665cc3fe852ac135524e7c0a08ab6830a0b01057020301000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000": {"normal": "Has known private key", "verbose": "30820277020100300d06092a864886f70d0101010500048202613082025d02010002818100b22ee1f895f1d872618c1090316c5f5be9488c11056503b8c77fc2969850fe63f6fcd32708e8a5e49095c04526d73a509a46c4351640ce94598a4005d9b0af3b454e0b572002f524f88c34b5d3fbe2ec6508b7dbd6528b340d7fa6bf9a4529635e97845e0329b343b3e6d290665cc3fe852ac135524e7c0a08ab6830a0b01057020301000102818100a664f3af21cf9c528c57b16c064b6eedb4f7839dad8cfca1c4e3c142c2f0f7ef404a2fa14747830be41d8454cf85b4366b2be4b4b2984891eee01513a18bc6c6a1c6d21895cc26039f6acbcaa985d2aa08cf5b2155bebf0f4305f960f0d2b123ac6827d932170b7651a26f618ec72b0fd246e9c8ff9528fa95533a3b168b74e9024100e6b53acbc441cbc411b8815c9d959971356e8088477519524e0bf3d77d6d8b71e86d765b72042acb0e590ee1c7ffddaa9c63ed69592e615067c89c72247ac925024100c5b78e39f3553142982f9b730ebc230a641ae2302bc2218e8c82da19e6bdddf0cd756f340c161aa6a11bbbb59ec3fe3aa7cccdf30b5ff9bb2dd6d4919a6b50cb024100e0888b439bab498c768eb26018026c0711308da9949a33ddb595ce68f06ab7e751858f466a8e01b4042fcadb1512418375978f8d133d9f7a68b7870353dba87d024002ec60dcf87d14fa6017ac1bba670bb9969b5326d52ecca237efa35be8ae7bfe987b1906d2faecaff407ddf1a4844f58fcac298b636aaadd9aa2e787b399cc9b02406a5e97f4947b15e3b7feb6160b85228686d0099f3e99938dfd9535b09951b97d35bb6870789ae31f67794be4e2f7919d104e0610346ee7f174580e0da81cf3db"},
                                  "30819f300d06092a864886f70d010101050003818d00308189028181009e74b364b72cadae5c942c0bce6e32aeb5b808bd83887e8842c966b9e4ec43407fcf622be9f0d7f9e67d1853d63a2f82ff8ab0e80e172625b82835e0dc2bb23cf4f466a790cecd1155004c8ab05f8005421e8283372bd79cd0134243fb744f70d66e67ee79597dbb019786d825454bfa61620a2398a1048f47705722e206b19b020301000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000": {"normal": "Has known private key", "verbose": "30820277020100300d06092a864886f70d0101010500048202613082025d020100028181009e74b364b72cadae5c942c0bce6e32aeb5b808bd83887e8842c966b9e4ec43407fcf622be9f0d7f9e67d1853d63a2f82ff8ab0e80e172625b82835e0dc2bb23cf4f466a790cecd1155004c8ab05f8005421e8283372bd79cd0134243fb744f70d66e67ee79597dbb019786d825454bfa61620a2398a1048f47705722e206b19b020301000102818022ae58354b0234615d51f0f2049489f34342ac670e4ae9a6d9374b8c945641c1f43767bd44ceb9f6b043e0f7388433b1f04c62bbe7999977d7feb50c2a2446364900b77ff478242a75e17c82ed14eb012e18bb27cc2eb2597138f90ed19f67a7ef84a84402a1f70a7b8025a973111cb943467c0b256814143e5f46ca02896441024100d3af83fee62d4a3fe92824a2507ec602e70785ffb2d8db4eca5e38c550b5e67814dbf252750efdbab5e625d775d4aa29f8cd3e6ef08818418bbbd91f591e40ad024100bfa08a1ff528b5be40a7b62d97d971831f16d23dfeff338ea3013d53a4a2d4c7cc575a78454a785ac56f651d5ede25699bd7c54068eea2691a4dbe3d9f1edc670240013f2d65d8f13758bd04d1826b3af3eb9c74bce34ea85c52507ad196c7ecea5896b6dcec8367fd329653aeb1602e4a7a48cedca9469d66972c3d84ffdc448359024100b39a937b4a7b828433f33d03d4ac200126756c4e611eee42c532d738fb3906b7d1251a8d595c681ba3ab3999629e51707f79a7ce2bcb667b9e04b9c6e5c9b6070241009eeeb0c3a299a2a997dcc20452dd8f6e402b7f3b56062371c40a9f89eeee9dd060ed5b4ff82961381de2a8efeb086b0b22f4b38654aaa3983b9be4cb18398d73"}
                              }
                     }
}

```

`Scripts/1768/1768.py`:

```py
#!/usr/bin/env python

from __future__ import print_function

__description__ = 'Analyze Cobalt Strike beacons'
__author__ = 'Didier Stevens'
__version__ = '0.0.23'
__date__ = '2025/03/05'

"""
Source code put in the public domain by Didier Stevens, no Copyright
https://DidierStevens.com
Use at your own risk

History:
  2019/05/15: start
  2019/05/18: continue
  2019/05/25: continue
  2019/12/06: continue
  2019/12/07: continue
  2019/12/17: continue
  2020/02/03: 0.0.2 some changes for CS4: xor key is '.' in stead of 'i'
  2020/10/11: 0.0.3 Python 3 fixes
  2020/10/17: improve parsing
  2020/10/18: updated some config identifiers: found https://github.com/JPCERTCC/aa-tools https://github.com/sysopfb/malware_decoders/tree/master/cs_beacon https://github.com/Sentinel-One/CobaltStrikeParser
  2020/10/21: Python 3 fix in cBinaryFile
  2020/10/28: refactoring
  2020/10/29: man
  2020/11/04: added xor chain decoding
  2020/11/07: 0.0.4 updated shellcode analysis
  2020/11/12: updated shellcode analysis
  2020/11/16: added option -l
  2020/11/17: continue
  2020/11/29: added rule_shellcode_00_end
  2021/02/13: 0.0.5 updated shellcode analysis (+ Python 3 fix); added XORChain analysis for PE sections; remove duplicate configs when dumping raw
  2021/03/06: added option -c
  2021/03/25: 0.0.6 fix for provided sample
  2021/04/06: fix
  2021/04/28: added option -J
  2021/04/30: CS version guessing
  2021/05/02: fix
  2021/05/15: continue JSON output
  2021/06/14: updated man with 1768.json info
  2021/10/10: 0.0.8 1768.json improvements
  2021/10/17: 0.0.9 added malleable instructions decoding
  2021/11/01: refactoring instructions decoding
  2021/11/05: 0.0.10 cOutput replacements
  2021/11/07: added FinalTests
  2021/11/14: added DNS fields
  2021/11/17: added missing field names (ebook FINDING BEACONS IN THE DARK)
  2021/12/12: 0.0.11 added 1768b.json support
  2022/02/22: 0.0.12 added private key to 1768.json (provided by alexzorila); fix json output; pyzipper support
  2022/04/15: 0.0.13 added option -H and IdentifyShellcode
  2022/04/16: continue IdentifyShellcode
  2022/05/20: 0.0.14 skipping 0x20 bytes
  2022/07/31: 0.0.15 update class cAPIOptions
  2022/08/17: added option --sanitycheck; refactored FinalTests
  2022/08/20: 0.0.16 added output instructions to JSON output
  2022/08/30: 0.0.17 added option -x
  2023/04/02: updated man page
  2023/04/03: 0.0.18 cleanup debugging
  2023/04/27: 0.0.19 added LSFIF
  2023/10/06: 0.0.20 updated APIAnalyze
  2023/10/15: added runtime config parsing
  2024/01/18: 0.0.21 FindAlternativeRuntimeConfig1
  2024/01/21: fix jsonoutput bug for missing config; added option experimental
  2024/11/29: 0.0.22 bug fix oMinidumpFile.memory_info
  2025/03/05: 0.0.23 version bump for 1768.json

Todo:

"""

import optparse
import sys
import os
import binascii
import random
import gzip
import collections
import glob
import textwrap
import re
import struct
import string
import math
import fnmatch
import json
import time
import hashlib
try:
    from minidump.minidumpfile import MinidumpFile
    from minidump.streams import MemoryInfoListStream
except ImportError:
    pass
try:
    import pyzipper as zipfile
except ImportError:
    import zipfile
if sys.version_info[0] >= 3:
    from io import BytesIO as DataIO
else:
    from cStringIO import StringIO as DataIO
if sys.version_info[0] >= 3:
    from io import StringIO
else:
    from cStringIO import StringIO
try:
    import pefile
    import peutils
except ImportError:
    print('Missing pefile and/or peutils Python module, please check if it is installed.')
    sys.exit()

def PrintManual():
    manual = r'''
Manual:

1768 Kelvin is the melting point of the metal cobalt.

This tool decrypts and dumps the configuration of Cobalt Strike Windows beacons (PE files), shellcode and memory dumps.

Use option -x to try all 256 xor keys for the configuration (not only 0x2e and 0x69).

Option -s (--select) can be used to select a particular configuration item (by decimal of hexadecimal number) for more information. For the moment, this option displays the complete item's data (hexadecimal in cleartext, encoded with 'i' (0x69) and encoded with '.' (0x2e). These hexadecimal values  can be used to create detection rules, like YARA rules.

Option -l (--licenseid) is used to generate YARA rules to detect a beacon or shellcode with the given license ID. The id can be provided as an integer or an hexadecimal value (prefixed by 0x).
More than one license id can be provided: separate them by commas (,).
Each license id can be previded by a name for the license is (use : as a separator).
Example : 1768.py -l ATP_1:12345678,pentester_2:87654321

Option -c (--csv) is used to output the config parameters in CSV format.

Option -J (--jsonoutput) is used to output the config parameters in JSON format.

Use option -H to display the hashes of the analyzed file.

Option -S (--sanitycheck) performs a sanity check on the extracted configuration, and ignores the extracted configuration when it does not pass a sanity check.
The sanity check checks for the presence of config values 1 and 7, and check if their values are plausible:
1 -> known payload type
7 -> public key starts with 308

Option -V (--verbose) produces more output:
- verbosity for config values (like the private key for leaked keys)
- hex/ascii dump of found signatures

When a signature is found, the longest ASCII string in front of the signature (256 bytes span) is included, like this:
Sleep mask 64-bit 4.2 deobfuscation routine found: 0x122f12d31 (LSFIF: b'!#ALF:Y2V:Elastic/HKTL_CobaltStrike_Beacon_4_2_Decrypt')
LSFIF is abbreviation Longest String Found In Front.

Use option -e (--experimental) to enable experimental features.

A JSON file with name 1768.json placed in the same directory as 1768.py will be used to enhance fields with information, like the license-id field.

It reads one or more files or stdin. This tool is very versatile when it comes to handling files, later full details will be provided.

This Python script was first developed with Python 2.7 and tested with Python 2.7 and 3.7, now it is developed with Python 3.9 and tested with Python 3.9.

As stated at the beginning of this manual, this tool is very versatile when it comes to handling files. This will be explained now.

This tool reads files in binary mode. It can read files from disk, from standard input (stdin) and from "generated" files via the command line.
It can also partially read files (this is done with the cut operator).

If no file arguments are provided to this tool, it will read data from standard input (stdin). This way, this tool can be used in a piped chain of commands, like this:

oledump.py -s 4 -d sample.doc.vir | tool.py

When one or more file arguments are provided to this tool, it will read the files and process the content.
How the files are read, depends on the type of file arguments that are provided. File arguments that start with character @ or # have special meaning, and will be explained later.

If a file argument does not start with @ or #, it is considered to be a file on disk and the content will be read from disk.
If the file is not a compressed file, the binary content of the file is read from disk for processing.
Compressed files are solely recognized based on their extension: .zip and .gz.
It uses built-in Python module zipfile, unless module pyzipper is installed. Module pyzipper adds AES support, and can be installed with pip (Python 3 only).
If a file argument with extension .gz is provided, the tool will decompress the gzip file in memory and process the decompressed content. No checks are made to ensure that the file with extension .gz is an actual gzip compressed file.
If a file argument with extension .zip is provided and it contains a single file, the tool will extract the file from the ZIP file in memory and process the decompressed content. No checks are made to ensure that the file with extension .zip is an actual ZIP compressed file.
Password protected ZIP files can be processed too. The tool uses password 'infected' (without quotes) as default password. A different password can be provided using option --password.

Example:

tool.py sample.zip

To prevent the tool from decompressing .zip or .gz files, but to process the compressed file itself, use option --noextraction.

File arguments that start with character @ ("here files"), are read as text files that contain file arguments (one per line) to be processed.
For example, we take a text file with filename list.txt and following content:

sample-1.bin
sample-5.bin
sample-7.bin

When using this file (list.txt) in the following command:

tool.py @list.txt

the tool will process the following files: sample-1.bin, sample-5.bin and sample-7.bin.
A single @ character as filename is a here file read from stdin.

Wildcards are supported too. The classic *, ? and [] wildcard characters are supported. For example, use the following command to process all .exe and .dll files in the Windows directory:

tool.py C:\Windows\*.exe C:\Windows\*.dll

To prevent the tool from processing file arguments with wildcard characters or special initial characters (@ and #) differently, but to process them as normal files, use option --literalfilenames.

The content of folders can be processed too: use option --recursedir and provide folder names as argument. Wildcards and here files (for folder names) can be used too.

File arguments that start with character # have special meaning. These are not processed as actual files on disk (except when option --literalfilenames is used), but as file arguments that specify how to "generate" the file content.

File arguments that start with #, #h#, #b# or #e# are used to "generate" the file content.
Arguments that start with #c# are not file arguments, but cut operators (explained later).
Arguments that start with #f# are not file arguments, but flags (explained later).

Generating the file content with a # file argument means that the file content is not read from disk, but generated in memory based on the characteristics provided via the file argument.

When a file argument starts with # (and not with #h#, #b#, #e# or #c#), all characters that follow the # character specify the content of the generated file.
For example, file argument #ABCDE specifies a file containing exactly 5 bytes: ASCII characters A, B, C, D and E.
Thus the following command:

tool.py #ABCDE

will make the tool process data with binary content ABCDE. #ABCDE is not an actual file written on disk, but it is a notational convention to provide data via the command line.

Since this notation can not be used to specify all possible byte values, hexadecimal encoding (#h#) and BASE64 encoding (#b#) notation is supported too.
For example, #h#4142434445 is an hexadecimal notation that generates data ABCDE. Hexadecimal notation allows the generation of non-printable characters for example, like NULL bytes: #h#00
File argument #b#QUJDREU= is another example, this time BASE64 notation, that generates data ABCDE.

File arguments that start with #e# are a notational convention to use expressions to generate data. An expression is a single function/string or the concatenation of several functions/strings (using character + as concatenation operator).
Strings can be characters enclosed by single quotes ('example') or hexadecimal strings prefixed by 0x (0xBEEF).
4 functions are available: random, loremipsum, repeat and chr.

Function random takes exactly one argument: an integer (with value 1 or more). Integers can be specified using decimal notation or hexadecimal notation (prefix 0x).
The random function generates a sequence of bytes with a random value (between 0 and 255), the argument specifies how many bytes need to be generated. Remark that the random number generator that is used is just the Python random number generator, not a cryptographic random number generator.

Example:

tool.py #e#random(100)

will make the tool process data consisting of a sequence of 100 random bytes.

Function loremipsum takes exactly one argument: an integer (with value 1 or more).
The loremipsum function generates "lorem ipsum" text (fake latin), the argument specifies the number of sentences to generate.

Example: #e#loremipsum(2) generates this text:
Ipsum commodo proin pulvinar hac vel nunc dignissim neque eget odio erat magna lorem urna cursus fusce facilisis porttitor congue eleifend taciti. Turpis duis suscipit facilisi tristique dictum praesent natoque sem mi egestas venenatis per dui sit sodales est condimentum habitasse ipsum phasellus non bibendum hendrerit.

Function chr takes one argument or two arguments.
chr with one argument takes an integer between 0 and 255, and generates a single byte with the value specified by the integer.
chr with two arguments takes two integers between 0 and 255, and generates a byte sequence with the values specified by the integers.
For example #e#chr(0x41,0x45) generates data ABCDE.

Function repeat takes two arguments: an integer (with value 1 or more) and a byte sequence. This byte sequence can be a quoted string of characters (single quotes), like 'ABCDE' or an hexadecimal string prefixed with 0x, like 0x4142434445.
The repeat function will create a sequence of bytes consisting of the provided byte sequence (the second argument) repeated as many times as specified by the first argument.
For example, #e#repeat(3, 'AB') generates byte sequence ABABAB.

When more than one function needs to be used, the byte sequences generated by the functions can be concatenated with the + operator.
For example, #e#repeat(10,0xFF)+random(100) will generate a byte sequence of 10 FF bytes followed by 100 random bytes.

The cut argument (or cut operator) allows for the partial selection of the content of a file. This argument starts with #c# followed by a "cut-expression". Use this expression to "cut out" part of the content.
The cut-argument must be put in front of a file argument, like in this example:

tool.py #c#0:100l data.bin

With these arguments, tool.py will only process the first 100 bytes (0:100l) of file data.bin.

A cut argument is applied to all file arguments that follow it. Example:

tool.py #c#0:100l data-1.bin data-2.bin

With these arguments, tool.py will only process the first 100 bytes (0:100l) of file data-1.bin and the first 100 bytes file data-2.bin.

More than one cut argument can be used, like in this example:

tool.py #c#0:100l data-1.bin #c#0:200l data-2.bin

With these arguments, tool.py will only process the first 100 bytes (0:100l) of file data-1.bin and the first 200 bytes (0:200l) of file data-2.bin.

A cut-expression is composed of 2 terms separated by a colon (:), like this:
termA:termB
termA and termB can be:
- nothing (an empty string)
- a positive decimal number; example: 10
- an hexadecimal number (to be preceded by 0x); example: 0x10
- a case sensitive ASCII string to search for (surrounded by square brackets and single quotes); example: ['MZ']
- a case sensitive UNICODE string to search for (surrounded by square brackets and single quotes prefixed with u); example: [u'User']
- an hexadecimal string to search for (surrounded by square brackets); example: [d0cf11e0]
If termA is nothing, then the cut section of bytes starts with the byte at position 0.
If termA is a number, then the cut section of bytes starts with the byte at the position given by the number (first byte has index 0).
If termA is a string to search for, then the cut section of bytes starts with the byte at the position where the string is first found. If the string is not found, the cut is empty (0 bytes).
If termB is nothing, then the cut section of bytes ends with the last byte.
If termB is a number, then the cut section of bytes ends with the byte at the position given by the number (first byte has index 0).
When termB is a number, it can have suffix letter l. This indicates that the number is a length (number of bytes), and not a position.
termB can also be a negative number (decimal or hexademical): in that case the position is counted from the end of the file. For example, :-5 selects the complete file except the last 5 bytes.
If termB is a string to search for, then the cut section of bytes ends with the last byte at the position where the string is first found. If the string is not found, the cut is empty (0 bytes).
No checks are made to assure that the position specified by termA is lower than the position specified by termB. This is left up to the user.
Search string expressions (ASCII, UNICODE and hexadecimal) can be followed by an instance (a number equal to 1 or greater) to indicate which instance needs to be taken. For example, ['ABC']2 will search for the second instance of string 'ABC'. If this instance is not found, then nothing is selected.
Search string expressions (ASCII, UNICODE and hexadecimal) can be followed by an offset (+ or - a number) to add (or substract) an offset to the found instance. This number can be a decimal or hexadecimal (prefix 0x) value. For example, ['ABC']+3 will search for the first instance of string 'ABC' and then select the bytes after ABC (+ 3).
Finally, search string expressions (ASCII, UNICODE and hexadecimal) can be followed by an instance and an offset.
Examples:
This cut-expression can be used to dump the first 256 bytes of a PE file located inside the file content: ['MZ']:0x100l
This cut-expression can be used to dump the OLE file located inside the file content: [d0cf11e0]:

A flag argument starts with #f# and is passed on for all files that are provided after the flag argument. It can be used to change the behavior of the tool for certain files.
Example:

tool.py data-1.bin #f#-l data-2.bin

data-2.bin will be processed differently (using flag option -l) than file data-1.bin.

With option --jsoninput, the tool will parse the output produced by another tool using option --jsonoutput.
Example:
zipdump.py --jsonoutput Book1.xlsm | file-magic.py --jsoninput
[Content_Types].xml XML 1.0 document, ASCII text, with very long lines, with CRLF line terminators
_rels/.rels XML 1.0 document, ASCII text, with very long lines, with CRLF line terminators
xl/_rels/workbook.xml.rels  XML 1.0 document, ASCII text, with very long lines, with CRLF line terminators
xl/workbook.xml XML 1.0 document, ASCII text, with very long lines, with CRLF line terminators
xl/drawings/drawing1.xml  XML 1.0 document, ASCII text, with very long lines, with CRLF line terminators
xl/worksheets/_rels/sheet1.xml.rels XML 1.0 document, ASCII text, with very long lines, with CRLF line terminators
xl/theme/theme1.xml XML 1.0 document, UTF-8 Unicode text, with very long lines, with CRLF line terminators
xl/styles.xml XML 1.0 document, ASCII text, with very long lines, with CRLF line terminators
xl/worksheets/sheet1.xml  XML 1.0 document, ASCII text, with very long lines, with CRLF line terminators
xl/vbaProject.bin Composite Document File V2 Document, Cannot read section info
xl/drawings/vmlDrawing1.vml ASCII text, with CRLF line terminators
docProps/app.xml  XML 1.0 document, ASCII text, with very long lines, with CRLF line terminators
xl/ctrlProps/ctrlProp1.xml  XML 1.0 document, ASCII text, with CRLF line terminators
docProps/core.xml XML 1.0 document, ASCII text, with very long lines, with CRLF line terminators

In this example, zipdump is used to produce JSON data with the content of each file contained inside file Book1.xlsm (a ZIP container), which is then consumed by file-magic.py to identify (libmagic) the type of each file.

With option --ignoreprocessingerrors, the tool will continue processing the next file when an error occurs while processing the current file. Files that can not be opened will always be skipped to move to the next file.

Option --logfile direct the tool to create a logfile, and option --logcomment can be used to add a comment to the log file. The log file will contain metadata and a list of processed files, it does not contain processing results.
It is best to use this option when option --ignoreprocessingerrors is used, to have a record of file processing errors.

The lines are written to standard output, except when option -o is used. When option -o is used, the lines are written to the filename specified by option -o.
Filenames used with option -o starting with # have special meaning.
#c#example.txt will write output both to the console (stdout) and file example.txt.
#g# will write output to a file with a filename generated by the tool like this: toolname-date-time.txt.
#g#KEYWORD will write output to a file with a filename generated by the tool like this: toolname-KEYWORD-date-time.txt.
Use #p#filename to display execution progress.
To process several files while creating seperate output files for each input file, use -o #s#%f%.result *.
This will create output files with the name of the inputfile and extension .result.
There are several variables available when creating separate output files:
 %f% is the full filename (with directory if present)
 %b% is the base name: the filename without directory
 %d% is the directory
 %r% is the root: the filename without extension
 %ru% is the root made unique by appending a counter (if necessary)
 %e% is the extension
#h# is like the head command: only the first 10 lines will be outputed.
#t# is like the tail command: only the last 10 lines will be outputed.
Most options can be combined, like #ps# for example.
#l# is used for literal filenames: if the output filename has to start with # (#example.txt for example), use filename #l##example.txt for example.

'''
    for line in manual.split('\n'):
        print(textwrap.fill(line, 79))

DEFAULT_SEPARATOR = ','
QUOTE = '"'

START_CONFIG = b'\x00\x01\x00\x01\x00\x02'
START_CONFIG_I = b'ihihik'
START_CONFIG_DOT = b'././.,'

ERROR_NO_CONFIG = 'Error: config not found'
ERROR_SANITY_CHECK = 'Error: config does not pass sanity check'

def PrintError(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)

#Convert 2 Bytes If Python 3
def C2BIP3(string):
    if sys.version_info[0] > 2:
        return bytes([ord(x) for x in string])
    else:
        return string

#Convert 2 String If Python 3
def C2SIP3(bytes):
    if sys.version_info[0] > 2:
        return ''.join([chr(byte) for byte in bytes])
    else:
        return bytes

#Convert 2 Integer If Python 2
def C2IIP2(data):
    if sys.version_info[0] > 2:
        return data
    else:
        return ord(data)

def P23Ord(value):
    if type(value) == int:
        return value
    else:
        return ord(value)

# CIC: Call If Callable
def CIC(expression):
    if callable(expression):
        return expression()
    else:
        return expression

# IFF: IF Function
def IFF(expression, valueTrue, valueFalse):
    if expression:
        return CIC(valueTrue)
    else:
        return CIC(valueFalse)

#-BEGINCODE cBinaryFile------------------------------------------------------------------------------
#import random
#import binascii
#import zipfile
#import gzip
#import sys
#if sys.version_info[0] >= 3:
#    from io import BytesIO as DataIO
#else:
#    from cStringIO import StringIO as DataIO

def LoremIpsumSentence(minimum, maximum):
    words = ['lorem', 'ipsum', 'dolor', 'sit', 'amet', 'consectetur', 'adipiscing', 'elit', 'etiam', 'tortor', 'metus', 'cursus', 'sed', 'sollicitudin', 'ac', 'sagittis', 'eget', 'massa', 'praesent', 'sem', 'fermentum', 'dignissim', 'in', 'vel', 'augue', 'scelerisque', 'auctor', 'libero', 'nam', 'a', 'gravida', 'odio', 'duis', 'vestibulum', 'vulputate', 'quam', 'nec', 'cras', 'nibh', 'feugiat', 'ut', 'vitae', 'ornare', 'justo', 'orci', 'varius', 'natoque', 'penatibus', 'et', 'magnis', 'dis', 'parturient', 'montes', 'nascetur', 'ridiculus', 'mus', 'curabitur', 'nisl', 'egestas', 'urna', 'iaculis', 'lectus', 'maecenas', 'ultrices', 'velit', 'eu', 'porta', 'hac', 'habitasse', 'platea', 'dictumst', 'integer', 'id', 'commodo', 'mauris', 'interdum', 'malesuada', 'fames', 'ante', 'primis', 'faucibus', 'accumsan', 'pharetra', 'aliquam', 'nunc', 'at', 'est', 'non', 'leo', 'nulla', 'sodales', 'porttitor', 'facilisis', 'aenean', 'condimentum', 'rutrum', 'facilisi', 'tincidunt', 'laoreet', 'ultricies', 'neque', 'diam', 'euismod', 'consequat', 'tempor', 'elementum', 'lobortis', 'erat', 'ligula', 'risus', 'donec', 'phasellus', 'quisque', 'vivamus', 'pellentesque', 'tristique', 'venenatis', 'purus', 'mi', 'dictum', 'posuere', 'fringilla', 'quis', 'magna', 'pretium', 'felis', 'pulvinar', 'lacinia', 'proin', 'viverra', 'lacus', 'suscipit', 'aliquet', 'dui', 'molestie', 'dapibus', 'mollis', 'suspendisse', 'sapien', 'blandit', 'morbi', 'tellus', 'enim', 'maximus', 'semper', 'arcu', 'bibendum', 'convallis', 'hendrerit', 'imperdiet', 'finibus', 'fusce', 'congue', 'ullamcorper', 'placerat', 'nullam', 'eros', 'habitant', 'senectus', 'netus', 'turpis', 'luctus', 'volutpat', 'rhoncus', 'mattis', 'nisi', 'ex', 'tempus', 'eleifend', 'vehicula', 'class', 'aptent', 'taciti', 'sociosqu', 'ad', 'litora', 'torquent', 'per', 'conubia', 'nostra', 'inceptos', 'himenaeos']
    sample = random.sample(words, random.randint(minimum, maximum))
    sample[0] = sample[0].capitalize()
    return ' '.join(sample) + '.'

def LoremIpsum(sentences):
    return ' '.join([LoremIpsumSentence(15, 30) for i in range(sentences)])

STATE_START = 0
STATE_IDENTIFIER = 1
STATE_STRING = 2
STATE_SPECIAL_CHAR = 3
STATE_ERROR = 4

FUNCTIONNAME_REPEAT = 'repeat'
FUNCTIONNAME_RANDOM = 'random'
FUNCTIONNAME_CHR = 'chr'
FUNCTIONNAME_LOREMIPSUM = 'loremipsum'

def Tokenize(expression):
    result = []
    token = ''
    state = STATE_START
    while expression != '':
        char = expression[0]
        expression = expression[1:]
        if char == "'":
            if state == STATE_START:
                state = STATE_STRING
            elif state == STATE_IDENTIFIER:
                result.append([STATE_IDENTIFIER, token])
                state = STATE_STRING
                token = ''
            elif state == STATE_STRING:
                result.append([STATE_STRING, token])
                state = STATE_START
                token = ''
        elif char >= '0' and char <= '9' or char.lower() >= 'a' and char.lower() <= 'z':
            if state == STATE_START:
                token = char
                state = STATE_IDENTIFIER
            else:
                token += char
        elif char == ' ':
            if state == STATE_IDENTIFIER:
                result.append([STATE_IDENTIFIER, token])
                token = ''
                state = STATE_START
            elif state == STATE_STRING:
                token += char
        else:
            if state == STATE_IDENTIFIER:
                result.append([STATE_IDENTIFIER, token])
                token = ''
                state = STATE_START
                result.append([STATE_SPECIAL_CHAR, char])
            elif state == STATE_STRING:
                token += char
            else:
                result.append([STATE_SPECIAL_CHAR, char])
                token = ''
    if state == STATE_IDENTIFIER:
        result.append([state, token])
    elif state == STATE_STRING:
        result = [[STATE_ERROR, 'Error: string not closed', token]]
    return result

def ParseFunction(tokens):
    if len(tokens) == 0:
        print('Parsing error')
        return None, tokens
    if tokens[0][0] == STATE_STRING or tokens[0][0] == STATE_IDENTIFIER and tokens[0][1].startswith('0x'):
        return [[FUNCTIONNAME_REPEAT, [[STATE_IDENTIFIER, '1'], tokens[0]]], tokens[1:]]
    if tokens[0][0] != STATE_IDENTIFIER:
        print('Parsing error')
        return None, tokens
    function = tokens[0][1]
    tokens = tokens[1:]
    if len(tokens) == 0:
        print('Parsing error')
        return None, tokens
    if tokens[0][0] != STATE_SPECIAL_CHAR or tokens[0][1] != '(':
        print('Parsing error')
        return None, tokens
    tokens = tokens[1:]
    if len(tokens) == 0:
        print('Parsing error')
        return None, tokens
    arguments = []
    while True:
        if tokens[0][0] != STATE_IDENTIFIER and tokens[0][0] != STATE_STRING:
            print('Parsing error')
            return None, tokens
        arguments.append(tokens[0])
        tokens = tokens[1:]
        if len(tokens) == 0:
            print('Parsing error')
            return None, tokens
        if tokens[0][0] != STATE_SPECIAL_CHAR or (tokens[0][1] != ',' and tokens[0][1] != ')'):
            print('Parsing error')
            return None, tokens
        if tokens[0][0] == STATE_SPECIAL_CHAR and tokens[0][1] == ')':
            tokens = tokens[1:]
            break
        tokens = tokens[1:]
        if len(tokens) == 0:
            print('Parsing error')
            return None, tokens
    return [[function, arguments], tokens]

def Parse(expression):
    tokens = Tokenize(expression)
    if len(tokens) == 0:
        print('Parsing error')
        return None
    if tokens[0][0] == STATE_ERROR:
        print(tokens[0][1])
        print(tokens[0][2])
        print(expression)
        return None
    functioncalls = []
    while True:
        functioncall, tokens = ParseFunction(tokens)
        if functioncall == None:
            return None
        functioncalls.append(functioncall)
        if len(tokens) == 0:
            return functioncalls
        if tokens[0][0] != STATE_SPECIAL_CHAR or tokens[0][1] != '+':
            print('Parsing error')
            return None
        tokens = tokens[1:]

def InterpretInteger(token):
    if token[0] != STATE_IDENTIFIER:
        return None
    try:
        return int(token[1])
    except:
        return None

def Hex2Bytes(hexadecimal):
    if len(hexadecimal) % 2 == 1:
        hexadecimal = '0' + hexadecimal
    try:
        return binascii.a2b_hex(hexadecimal)
    except:
        return None

def InterpretHexInteger(token):
    if token[0] != STATE_IDENTIFIER:
        return None
    if not token[1].startswith('0x'):
        return None
    bytes = Hex2Bytes(token[1][2:])
    if bytes == None:
        return None
    integer = 0
    for byte in bytes:
        integer = integer * 0x100 + C2IIP2(byte)
    return integer

def InterpretNumber(token):
    number = InterpretInteger(token)
    if number == None:
        return InterpretHexInteger(token)
    else:
        return number

def InterpretBytes(token):
    if token[0] == STATE_STRING:
        return token[1]
    if token[0] != STATE_IDENTIFIER:
        return None
    if not token[1].startswith('0x'):
        return None
    return Hex2Bytes(token[1][2:])

def CheckFunction(functionname, arguments, countarguments, maxcountarguments=None):
    if maxcountarguments == None:
        if countarguments == 0 and len(arguments) != 0:
            print('Error: function %s takes no arguments, %d are given' % (functionname, len(arguments)))
            return True
        if countarguments == 1 and len(arguments) != 1:
            print('Error: function %s takes 1 argument, %d are given' % (functionname, len(arguments)))
            return True
        if countarguments != len(arguments):
            print('Error: function %s takes %d arguments, %d are given' % (functionname, countarguments, len(arguments)))
            return True
    else:
        if len(arguments) < countarguments or len(arguments) > maxcountarguments:
            print('Error: function %s takes between %d and %d arguments, %d are given' % (functionname, countarguments, maxcountarguments, len(arguments)))
            return True
    return False

def CheckNumber(argument, minimum=None, maximum=None):
    number = InterpretNumber(argument)
    if number == None:
        print('Error: argument should be a number: %s' % argument[1])
        return None
    if minimum != None and number < minimum:
        print('Error: argument should be minimum %d: %d' % (minimum, number))
        return None
    if maximum != None and number > maximum:
        print('Error: argument should be maximum %d: %d' % (maximum, number))
        return None
    return number

def Interpret(expression):
    functioncalls = Parse(expression)
    if functioncalls == None:
        return None
    decoded = ''
    for functioncall in functioncalls:
        functionname, arguments = functioncall
        if functionname == FUNCTIONNAME_REPEAT:
            if CheckFunction(functionname, arguments, 2):
                return None
            number = CheckNumber(arguments[0], minimum=1)
            if number == None:
                return None
            bytes = InterpretBytes(arguments[1])
            if bytes == None:
                print('Error: argument should be a byte sequence: %s' % arguments[1][1])
                return None
            decoded += number * bytes
        elif functionname == FUNCTIONNAME_RANDOM:
            if CheckFunction(functionname, arguments, 1):
                return None
            number = CheckNumber(arguments[0], minimum=1)
            if number == None:
                return None
            decoded += ''.join([chr(random.randint(0, 255)) for x in range(number)])
        elif functionname == FUNCTIONNAME_LOREMIPSUM:
            if CheckFunction(functionname, arguments, 1):
                return None
            number = CheckNumber(arguments[0], minimum=1)
            if number == None:
                return None
            decoded += LoremIpsum(number)
        elif functionname == FUNCTIONNAME_CHR:
            if CheckFunction(functionname, arguments, 1, 2):
                return None
            number = CheckNumber(arguments[0], minimum=1, maximum=255)
            if number == None:
                return None
            if len(arguments) == 1:
                decoded += chr(number)
            else:
                number2 = CheckNumber(arguments[1], minimum=1, maximum=255)
                if number2 == None:
                    return None
                if number < number2:
                    decoded += ''.join([chr(n) for n in range(number, number2 + 1)])
                else:
                    decoded += ''.join([chr(n) for n in range(number, number2 - 1, -1)])
        else:
            print('Error: unknown function: %s' % functionname)
            return None
    return decoded

FCH_FILENAME = 0
FCH_DATA = 1
FCH_ERROR = 2

def FilenameCheckHash(filename, literalfilename):
    if literalfilename:
        return FCH_FILENAME, filename
    elif filename.startswith('#h#'):
        result = Hex2Bytes(filename[3:])
        if result == None:
            return FCH_ERROR, 'hexadecimal'
        else:
            return FCH_DATA, result
    elif filename.startswith('#b#'):
        try:
            return FCH_DATA, binascii.a2b_base64(filename[3:])
        except:
            return FCH_ERROR, 'base64'
    elif filename.startswith('#e#'):
        result = Interpret(filename[3:])
        if result == None:
            return FCH_ERROR, 'expression'
        else:
            return FCH_DATA, result
    elif filename.startswith('#'):
        return FCH_DATA, C2BIP3(filename[1:])
    else:
        return FCH_FILENAME, filename

def AnalyzeFileError(filename):
    PrintError('Error opening file %s' % filename)
    PrintError(sys.exc_info()[1])
    try:
        if not os.path.exists(filename):
            PrintError('The file does not exist')
        elif os.path.isdir(filename):
            PrintError('The file is a directory')
        elif not os.path.isfile(filename):
            PrintError('The file is not a regular file')
    except:
        pass

def CreateZipFileObject(arg1, arg2):
    if 'AESZipFile' in dir(zipfile):
        return zipfile.AESZipFile(arg1, arg2)
    else:
        return zipfile.ZipFile(arg1, arg2)

class cBinaryFile:
    def __init__(self, filename, zippassword='infected', noextraction=False, literalfilename=False):
        self.filename = filename
        self.zippassword = zippassword
        self.noextraction = noextraction
        self.literalfilename = literalfilename
        self.oZipfile = None
        self.extracted = False
        self.fIn = None

        fch, data = FilenameCheckHash(self.filename, self.literalfilename)
        if fch == FCH_ERROR:
            line = 'Error %s parsing filename: %s' % (data, self.filename)
            raise Exception(line)

        try:
            if self.filename == '':
                if sys.platform == 'win32':
                    import msvcrt
                    msvcrt.setmode(sys.stdin.fileno(), os.O_BINARY)
                self.fIn = sys.stdin
            elif fch == FCH_DATA:
                self.fIn = DataIO(data)
            elif not self.noextraction and self.filename.lower().endswith('.zip'):
                self.oZipfile = CreateZipFileObject(self.filename, 'r')
                if len(self.oZipfile.infolist()) == 1:
                    self.fIn = self.oZipfile.open(self.oZipfile.infolist()[0], 'r', self.zippassword)
                    self.extracted = True
                else:
                    self.oZipfile.close()
                    self.oZipfile = None
                    self.fIn = open(self.filename, 'rb')
            elif not self.noextraction and self.filename.lower().endswith('.gz'):
                self.fIn = gzip.GzipFile(self.filename, 'rb')
                self.extracted = True
            else:
                self.fIn = open(self.filename, 'rb')
        except:
            AnalyzeFileError(self.filename)
            raise

    def close(self):
        if self.fIn != sys.stdin and self.fIn != None:
            self.fIn.close()
        if self.oZipfile != None:
            self.oZipfile.close()

    def read(self, size=None):
        try:
            fRead = self.fIn.buffer
        except:
            fRead = self.fIn
        if size == None:
            return fRead.read()
        else:
            return fRead.read(size)

    def Data(self):
        data = self.read()
        self.close()
        return data

#-ENDCODE cBinaryFile--------------------------------------------------------------------------------

def File2Strings(filename):
    try:
        if filename == '':
            f = sys.stdin
        else:
            f = open(filename, 'r')
    except:
        return None
    try:
        return map(lambda line:line.rstrip('\n'), f.readlines())
    except:
        return None
    finally:
        if f != sys.stdin:
            f.close()

def File2String(filename):
    try:
        f = open(filename, 'rb')
    except:
        return None
    try:
        return f.read()
    except:
        return None
    finally:
        f.close()

def ProcessAt(argument):
    if argument.startswith('@'):
        strings = File2Strings(argument[1:])
        if strings == None:
            raise Exception('Error reading %s' % argument)
        else:
            return strings
    else:
        return [argument]

def Glob(filename):
    filenames = glob.glob(filename)
    if len(filenames) == 0:
        return [filename]
    else:
        return filenames

class cExpandFilenameArguments():
    def __init__(self, filenames, literalfilenames=False, recursedir=False, checkfilenames=False, expressionprefix=None, flagprefix=None):
        self.containsUnixShellStyleWildcards = False
        self.warning = False
        self.message = ''
        self.filenameexpressionsflags = []
        self.expressionprefix = expressionprefix
        self.flagprefix = flagprefix
        self.literalfilenames = literalfilenames

        expression = ''
        flag = ''
        if len(filenames) == 0:
            self.filenameexpressionsflags = [['', '', '']]
        elif literalfilenames:
            self.filenameexpressionsflags = [[filename, '', ''] for filename in filenames]
        elif recursedir:
            for dirwildcard in filenames:
                if expressionprefix != None and dirwildcard.startswith(expressionprefix):
                    expression = dirwildcard[len(expressionprefix):]
                elif flagprefix != None and dirwildcard.startswith(flagprefix):
                    flag = dirwildcard[len(flagprefix):]
                else:
                    if dirwildcard.startswith('@'):
                        for filename in ProcessAt(dirwildcard):
                            self.filenameexpressionsflags.append([filename, expression, flag])
                    elif os.path.isfile(dirwildcard):
                        self.filenameexpressionsflags.append([dirwildcard, expression, flag])
                    else:
                        if os.path.isdir(dirwildcard):
                            dirname = dirwildcard
                            basename = '*'
                        else:
                            dirname, basename = os.path.split(dirwildcard)
                            if dirname == '':
                                dirname = '.'
                        for path, dirs, files in os.walk(dirname):
                            for filename in fnmatch.filter(files, basename):
                                self.filenameexpressionsflags.append([os.path.join(path, filename), expression, flag])
        else:
            for filename in list(collections.OrderedDict.fromkeys(sum(map(self.Glob, sum(map(ProcessAt, filenames), [])), []))):
                if expressionprefix != None and filename.startswith(expressionprefix):
                    expression = filename[len(expressionprefix):]
                elif flagprefix != None and filename.startswith(flagprefix):
                    flag = filename[len(flagprefix):]
                else:
                    self.filenameexpressionsflags.append([filename, expression, flag])
            self.warning = self.containsUnixShellStyleWildcards and len(self.filenameexpressionsflags) == 0
            if self.warning:
                self.message = "Your filename argument(s) contain Unix shell-style wildcards, but no files were matched.\nCheck your wildcard patterns or use option literalfilenames if you don't want wildcard pattern matching."
                return
        if self.filenameexpressionsflags == [] and (expression != '' or flag != ''):
            self.filenameexpressionsflags = [['', expression, flag]]
        if checkfilenames:
            self.CheckIfFilesAreValid()

    def Glob(self, filename):
        if not ('?' in filename or '*' in filename or ('[' in filename and ']' in filename)):
            return [filename]
        self.containsUnixShellStyleWildcards = True
        return glob.glob(filename)

    def CheckIfFilesAreValid(self):
        valid = []
        doesnotexist = []
        isnotafile = []
        for filename, expression, flag in self.filenameexpressionsflags:
            hashfile = False
            try:
                hashfile = FilenameCheckHash(filename, self.literalfilenames)[0] == FCH_DATA
            except:
                pass
            if filename == '' or hashfile:
                valid.append([filename, expression, flag])
            elif not os.path.exists(filename):
                doesnotexist.append(filename)
            elif not os.path.isfile(filename):
                isnotafile.append(filename)
            else:
                valid.append([filename, expression, flag])
        self.filenameexpressionsflags = valid
        if len(doesnotexist) > 0:
            self.warning = True
            self.message += 'The following files do not exist and will be skipped: ' + ' '.join(doesnotexist) + '\n'
        if len(isnotafile) > 0:
            self.warning = True
            self.message += 'The following files are not regular files and will be skipped: ' + ' '.join(isnotafile) + '\n'

    def Filenames(self):
        if self.expressionprefix == None:
            return [filename for filename, expression, flag in self.filenameexpressionsflags]
        else:
            return self.filenameexpressionsflags

def CheckJSON(stringJSON):
    try:
        object = json.loads(stringJSON)
    except:
        print('Error parsing JSON')
        print(sys.exc_info()[1])
        return None
    if not isinstance(object, dict):
        print('Error JSON is not a dictionary')
        return None
    if not 'version' in object:
        print('Error JSON dictionary has no version')
        return None
    if object['version'] != 2:
        print('Error JSON dictionary has wrong version')
        return None
    if not 'id' in object:
        print('Error JSON dictionary has no id')
        return None
    if object['id'] != 'didierstevens.com':
        print('Error JSON dictionary has wrong id')
        return None
    if not 'type' in object:
        print('Error JSON dictionary has no type')
        return None
    if object['type'] != 'content':
        print('Error JSON dictionary has wrong type')
        return None
    if not 'fields' in object:
        print('Error JSON dictionary has no fields')
        return None
    if not 'name' in object['fields']:
        print('Error JSON dictionary has no name field')
        return None
    if not 'content' in object['fields']:
        print('Error JSON dictionary has no content field')
        return None
    if not 'items' in object:
        print('Error JSON dictionary has no items')
        return None
    for item in object['items']:
        item['content'] = binascii.a2b_base64(item['content'])
    return object['items']

CUTTERM_NOTHING = 0
CUTTERM_POSITION = 1
CUTTERM_FIND = 2
CUTTERM_LENGTH = 3

def Replace(string, dReplacements):
    if string in dReplacements:
        return dReplacements[string]
    else:
        return string

def ParseInteger(argument):
    sign = 1
    if argument.startswith('+'):
        argument = argument[1:]
    elif argument.startswith('-'):
        argument = argument[1:]
        sign = -1
    if argument.startswith('0x'):
        return sign * int(argument[2:], 16)
    else:
        return sign * int(argument)

def ParseCutTerm(argument):
    if argument == '':
        return CUTTERM_NOTHING, None, ''
    oMatch = re.match(r'\-?0x([0-9a-f]+)', argument, re.I)
    if oMatch == None:
        oMatch = re.match(r'\-?(\d+)', argument)
    else:
        value = int(oMatch.group(1), 16)
        if argument.startswith('-'):
            value = -value
        return CUTTERM_POSITION, value, argument[len(oMatch.group(0)):]
    if oMatch == None:
        oMatch = re.match(r'\[([0-9a-f]+)\](\d+)?([+-](?:0x[0-9a-f]+|\d+))?', argument, re.I)
    else:
        value = int(oMatch.group(1))
        if argument.startswith('-'):
            value = -value
        return CUTTERM_POSITION, value, argument[len(oMatch.group(0)):]
    if oMatch == None:
        oMatch = re.match(r"\[u?\'(.+?)\'\](\d+)?([+-](?:0x[0-9a-f]+|\d+))?", argument)
    else:
        if len(oMatch.group(1)) % 2 == 1:
            raise Exception("Uneven length hexadecimal string")
        else:
            return CUTTERM_FIND, (binascii.a2b_hex(oMatch.group(1)), int(Replace(oMatch.group(2), {None: '1'})), ParseInteger(Replace(oMatch.group(3), {None: '0'}))), argument[len(oMatch.group(0)):]
    if oMatch == None:
        return None, None, argument
    else:
        if argument.startswith("[u'"):
            # convert ascii to unicode 16 byte sequence
            searchtext = oMatch.group(1).decode('unicode_escape').encode('utf16')[2:]
        else:
            searchtext = oMatch.group(1)
        return CUTTERM_FIND, (searchtext, int(Replace(oMatch.group(2), {None: '1'})), ParseInteger(Replace(oMatch.group(3), {None: '0'}))), argument[len(oMatch.group(0)):]

def ParseCutArgument(argument):
    type, value, remainder = ParseCutTerm(argument.strip())
    if type == CUTTERM_NOTHING:
        return CUTTERM_NOTHING, None, CUTTERM_NOTHING, None
    elif type == None:
        if remainder.startswith(':'):
            typeLeft = CUTTERM_NOTHING
            valueLeft = None
            remainder = remainder[1:]
        else:
            return None, None, None, None
    else:
        typeLeft = type
        valueLeft = value
        if typeLeft == CUTTERM_POSITION and valueLeft < 0:
            return None, None, None, None
        if typeLeft == CUTTERM_FIND and valueLeft[1] == 0:
            return None, None, None, None
        if remainder.startswith(':'):
            remainder = remainder[1:]
        else:
            return None, None, None, None
    type, value, remainder = ParseCutTerm(remainder)
    if type == CUTTERM_POSITION and remainder == 'l':
        return typeLeft, valueLeft, CUTTERM_LENGTH, value
    elif type == None or remainder != '':
        return None, None, None, None
    elif type == CUTTERM_FIND and value[1] == 0:
        return None, None, None, None
    else:
        return typeLeft, valueLeft, type, value

def Find(data, value, nth, startposition=-1):
    position = startposition
    while nth > 0:
        position = data.find(value, position + 1)
        if position == -1:
            return -1
        nth -= 1
    return position

def CutData(stream, cutArgument):
    if cutArgument == '':
        return [stream, None, None]

    typeLeft, valueLeft, typeRight, valueRight = ParseCutArgument(cutArgument)

    if typeLeft == None:
        return [stream, None, None]

    if typeLeft == CUTTERM_NOTHING:
        positionBegin = 0
    elif typeLeft == CUTTERM_POSITION:
        positionBegin = valueLeft
    elif typeLeft == CUTTERM_FIND:
        positionBegin = Find(stream, valueLeft[0], valueLeft[1])
        if positionBegin == -1:
            return ['', None, None]
        positionBegin += valueLeft[2]
    else:
        raise Exception("Unknown value typeLeft")

    if typeRight == CUTTERM_NOTHING:
        positionEnd = len(stream)
    elif typeRight == CUTTERM_POSITION and valueRight < 0:
        positionEnd = len(stream) + valueRight
    elif typeRight == CUTTERM_POSITION:
        positionEnd = valueRight + 1
    elif typeRight == CUTTERM_LENGTH:
        positionEnd = positionBegin + valueRight
    elif typeRight == CUTTERM_FIND:
        positionEnd = Find(stream, valueRight[0], valueRight[1], positionBegin)
        if positionEnd == -1:
            return ['', None, None]
        else:
            positionEnd += len(valueRight[0])
        positionEnd += valueRight[2]
    else:
        raise Exception("Unknown value typeRight")

    return [stream[positionBegin:positionEnd], positionBegin, positionEnd]

#-BEGINCODE cDump------------------------------------------------------------------------------------
#import binascii
#import sys
#if sys.version_info[0] >= 3:
#    from io import StringIO
#else:
#    from cStringIO import StringIO

class cDump():
    def __init__(self, data, prefix='', offset=0, dumplinelength=16):
        self.data = data
        self.prefix = prefix
        self.offset = offset
        self.dumplinelength = dumplinelength

    def HexDump(self):
        oDumpStream = self.cDumpStream(self.prefix)
        hexDump = ''
        for i, b in enumerate(self.data):
            if i % self.dumplinelength == 0 and hexDump != '':
                oDumpStream.Addline(hexDump)
                hexDump = ''
            hexDump += IFF(hexDump == '', '', ' ') + '%02X' % self.C2IIP2(b)
        oDumpStream.Addline(hexDump)
        return oDumpStream.Content()

    def CombineHexAscii(self, hexDump, asciiDump):
        if hexDump == '':
            return ''
        countSpaces = 3 * (self.dumplinelength - len(asciiDump))
        if len(asciiDump) <= self.dumplinelength / 2:
            countSpaces += 1
        return hexDump + '  ' + (' ' * countSpaces) + asciiDump

    def HexAsciiDump(self, rle=False):
        oDumpStream = self.cDumpStream(self.prefix)
        position = ''
        hexDump = ''
        asciiDump = ''
        previousLine = None
        countRLE = 0
        for i, b in enumerate(self.data):
            b = self.C2IIP2(b)
            if i % self.dumplinelength == 0:
                if hexDump != '':
                    line = self.CombineHexAscii(hexDump, asciiDump)
                    if not rle or line != previousLine:
                        if countRLE > 0:
                            oDumpStream.Addline('* %d 0x%02x' % (countRLE, countRLE * self.dumplinelength))
                        oDumpStream.Addline(position + line)
                        countRLE = 0
                    else:
                        countRLE += 1
                    previousLine = line
                position = '%08X:' % (i + self.offset)
                hexDump = ''
                asciiDump = ''
            if i % self.dumplinelength == self.dumplinelength / 2:
                hexDump += ' '
            hexDump += ' %02X' % b
            asciiDump += IFF(b >= 32 and b < 128, chr(b), '.')
        if countRLE > 0:
            oDumpStream.Addline('* %d 0x%02x' % (countRLE, countRLE * self.dumplinelength))
        oDumpStream.Addline(self.CombineHexAscii(position + hexDump, asciiDump))
        return oDumpStream.Content()

    def Base64Dump(self, nowhitespace=False):
        encoded = binascii.b2a_base64(self.data)
        if nowhitespace:
            return encoded
        encoded = encoded.strip()
        oDumpStream = self.cDumpStream(self.prefix)
        length = 64
        for i in range(0, len(encoded), length):
            oDumpStream.Addline(encoded[0+i:length+i])
        return oDumpStream.Content()

    class cDumpStream():
        def __init__(self, prefix=''):
            self.oStringIO = StringIO()
            self.prefix = prefix

        def Addline(self, line):
            if line != '':
                self.oStringIO.write(self.prefix + line + '\n')

        def Content(self):
            return self.oStringIO.getvalue()

    @staticmethod
    def C2IIP2(data):
        if sys.version_info[0] > 2:
            return data
        else:
            return ord(data)
#-ENDCODE cDump--------------------------------------------------------------------------------------

def IfWIN32SetBinary(io):
    if sys.platform == 'win32':
        import msvcrt
        msvcrt.setmode(io.fileno(), os.O_BINARY)

#Fix for http://bugs.python.org/issue11395
def StdoutWriteChunked(data):
    if sys.version_info[0] > 2:
        sys.stdout.buffer.write(data)
    else:
        while data != '':
            sys.stdout.write(data[0:10000])
            try:
                sys.stdout.flush()
            except IOError:
                return
            data = data[10000:]

class cVariables():
    def __init__(self, variablesstring='', separator=DEFAULT_SEPARATOR):
        self.dVariables = {}
        if variablesstring == '':
            return
        for variable in variablesstring.split(separator):
            name, value = VariableNameValue(variable)
            self.dVariables[name] = value

    def SetVariable(self, name, value):
        self.dVariables[name] = value

    def Instantiate(self, astring):
        for key, value in self.dVariables.items():
            astring = astring.replace('%' + key + '%', value)
        return astring

class cOutput():
    def __init__(self, filenameOption=None):
        self.starttime = time.time()
        self.filenameOption = filenameOption
        self.separateFiles = False
        self.progress = False
        self.console = False
        self.head = False
        self.headCounter = 0
        self.tail = False
        self.tailQueue = []
        self.fOut = None
        self.rootFilenames = {}
        if self.filenameOption:
            if self.ParseHash(self.filenameOption):
                if not self.separateFiles and self.filename != '':
                    self.fOut = open(self.filename, 'w')
            elif self.filenameOption != '':
                self.fOut = open(self.filenameOption, 'w')

        self.dReplacements = {}

    def Replace(self, line):
        for key, value in self.dReplacements.items():
            line = line.replace(key, value)
        return line

    def ParseHash(self, option):
        if option.startswith('#'):
            position = self.filenameOption.find('#', 1)
            if position > 1:
                switches = self.filenameOption[1:position]
                self.filename = self.filenameOption[position + 1:]
                for switch in switches:
                    if switch == 's':
                        self.separateFiles = True
                    elif switch == 'p':
                        self.progress = True
                    elif switch == 'c':
                        self.console = True
                    elif switch == 'l':
                        pass
                    elif switch == 'g':
                        if self.filename != '':
                            extra = self.filename + '-'
                        else:
                            extra = ''
                        self.filename = '%s-%s%s.txt' % (os.path.splitext(os.path.basename(sys.argv[0]))[0], extra, self.FormatTime())
                    elif switch == 'h':
                        self.head = True
                    elif switch == 't':
                        self.tail = True
                    else:
                        return False
                return True
        return False

    @staticmethod
    def FormatTime(epoch=None):
        if epoch == None:
            epoch = time.time()
        return '%04d%02d%02d-%02d%02d%02d' % time.localtime(epoch)[0:6]

    def RootUnique(self, root):
        if not root in self.rootFilenames:
            self.rootFilenames[root] = None
            return root
        iter = 1
        while True:
            newroot = '%s_%04d' % (root, iter)
            if not newroot in self.rootFilenames:
                self.rootFilenames[newroot] = None
                return newroot
            iter += 1

    def LineSub(self, line, eol):
        line = self.Replace(line)
        if self.fOut == None or self.console:
            try:
                print(line, end=eol)
            except UnicodeEncodeError:
                encoding = sys.stdout.encoding
                print(line.encode(encoding, errors='backslashreplace').decode(encoding), end=eol)
#            sys.stdout.flush()
        if self.fOut != None:
            self.fOut.write(line + '\n')
            self.fOut.flush()

    def Line(self, line, eol='\n'):
        if self.head:
            if self.headCounter < 10:
                self.LineSub(line, eol)
            elif self.tail:
                self.tailQueue = self.tailQueue[-9:] + [[line, eol]]
            self.headCounter += 1
        elif self.tail:
            self.tailQueue = self.tailQueue[-9:] + [[line, eol]]
        else:
            self.LineSub(line, eol)

    def LineTimestamped(self, line):
        self.Line('%s: %s' % (self.FormatTime(), line))

    def Filename(self, filename, index, total):
        self.separateFilename = filename
        if self.progress:
            if index == 0:
                eta = ''
            else:
                seconds = int(float((time.time() - self.starttime) / float(index)) * float(total - index))
                eta = 'estimation %d seconds left, finished %s ' % (seconds, self.FormatTime(time.time() + seconds))
            PrintError('%d/%d %s%s' % (index + 1, total, eta, self.separateFilename))
        if self.separateFiles and self.filename != '':
            oFilenameVariables = cVariables()
            oFilenameVariables.SetVariable('f', self.separateFilename)
            basename = os.path.basename(self.separateFilename)
            oFilenameVariables.SetVariable('b', basename)
            oFilenameVariables.SetVariable('d', os.path.dirname(self.separateFilename))
            root, extension = os.path.splitext(basename)
            oFilenameVariables.SetVariable('r', root)
            oFilenameVariables.SetVariable('ru', self.RootUnique(root))
            oFilenameVariables.SetVariable('e', extension)

            self.Close()
            self.fOut = open(oFilenameVariables.Instantiate(self.filename), 'w')

    def Close(self):
        if self.head and self.tail and len(self.tailQueue) > 0:
            self.LineSub('...', '\n')

        for line, eol in self.tailQueue:
            self.LineSub(line, eol)

        self.headCounter = 0
        self.tailQueue = []

        if self.fOut != None:
            self.fOut.close()
            self.fOut = None

def ToString(value):
    if isinstance(value, str):
        return value
    else:
        return str(value)

def Quote(value, separator, quote):
    value = ToString(value)
    if len(value) > 1 and value[0] == quote and value[-1] == quote:
        return value
    if separator in value or value == '':
        return quote + value + quote
    else:
        return value

def MakeCSVLine(row, separator=',', quote='"'):
    return separator.join([Quote(value, separator, quote) for value in row])

class cLogfile():
    def __init__(self, keyword, comment):
        self.starttime = time.time()
        self.errors = 0
        if keyword == '':
            self.oOutput = None
        else:
            self.oOutput = cOutput('%s-%s-%s.log' % (os.path.splitext(os.path.basename(sys.argv[0]))[0], keyword, self.FormatTime()))
        self.Line('Start')
        self.Line('UTC', '%04d%02d%02d-%02d%02d%02d' % time.gmtime(time.time())[0:6])
        self.Line('Comment', comment)
        self.Line('Args', repr(sys.argv))
        self.Line('Version', __version__)
        self.Line('Python', repr(sys.version_info))
        self.Line('Platform', sys.platform)
        self.Line('CWD', repr(os.getcwd()))

    @staticmethod
    def FormatTime(epoch=None):
        if epoch == None:
            epoch = time.time()
        return '%04d%02d%02d-%02d%02d%02d' % time.localtime(epoch)[0:6]

    def Line(self, *line):
        if self.oOutput != None:
            self.oOutput.Line(MakeCSVLine((self.FormatTime(), ) + line, DEFAULT_SEPARATOR, QUOTE))

    def LineError(self, *line):
        self.Line('Error', *line)
        self.errors += 1

    def Close(self):
        if self.oOutput != None:
            self.Line('Finish', '%d error(s)' % self.errors, '%d second(s)' % (time.time() - self.starttime))
            self.oOutput.Close()

def CalculateByteStatistics(dPrevalence=None, data=None):
    averageConsecutiveByteDifference = None
    if dPrevalence == None:
        dPrevalence = {iter: 0 for iter in range(0x100)}
        sumDifferences = 0.0
        previous = None
        if len(data) > 1:
            for byte in data:
                byte = C2IIP2(byte)
                dPrevalence[byte] += 1
                if previous != None:
                    sumDifferences += abs(byte - previous)
                previous = byte
            averageConsecutiveByteDifference = sumDifferences /float(len(data)-1)
    sumValues = sum(dPrevalence.values())
    countNullByte = dPrevalence[0]
    countControlBytes = 0
    countWhitespaceBytes = 0
    countUniqueBytes = 0
    for iter in range(1, 0x21):
        if chr(iter) in string.whitespace:
            countWhitespaceBytes += dPrevalence[iter]
        else:
            countControlBytes += dPrevalence[iter]
    countControlBytes += dPrevalence[0x7F]
    countPrintableBytes = 0
    for iter in range(0x21, 0x7F):
        countPrintableBytes += dPrevalence[iter]
    countHighBytes = 0
    for iter in range(0x80, 0x100):
        countHighBytes += dPrevalence[iter]
    countHexadecimalBytes = 0
    countBASE64Bytes = 0
    for iter in range(0x30, 0x3A):
        countHexadecimalBytes += dPrevalence[iter]
        countBASE64Bytes += dPrevalence[iter]
    for iter in range(0x41, 0x47):
        countHexadecimalBytes += dPrevalence[iter]
    for iter in range(0x61, 0x67):
        countHexadecimalBytes += dPrevalence[iter]
    for iter in range(0x41, 0x5B):
        countBASE64Bytes += dPrevalence[iter]
    for iter in range(0x61, 0x7B):
        countBASE64Bytes += dPrevalence[iter]
    countBASE64Bytes += dPrevalence[ord('+')] + dPrevalence[ord('/')] + dPrevalence[ord('=')]
    entropy = 0.0
    for iter in range(0x100):
        if dPrevalence[iter] > 0:
            prevalence = float(dPrevalence[iter]) / float(sumValues)
            entropy += - prevalence * math.log(prevalence, 2)
            countUniqueBytes += 1
    return sumValues, entropy, countUniqueBytes, countNullByte, countControlBytes, countWhitespaceBytes, countPrintableBytes, countHighBytes, countHexadecimalBytes, countBASE64Bytes, averageConsecutiveByteDifference

def GetChunk(position, data):
    return [data[:position], data[position:]]

def InstantiateCOutput(options):
    filenameOption = None
    if options.output != '':
        filenameOption = options.output
    return cOutput(filenameOption)

class UnpackErrorNotEnoughData(Exception):

    pass

def Unpack(format, data):
    size = struct.calcsize(format)
    if len(data) < size:
        raise UnpackErrorNotEnoughData()
    result = list(struct.unpack(format, data[:size]))
    result.append(data[size:])
    return result

def Represent(data):
    if sum([ord(c) for c in data]) == 0:
        return '(NULL ...)'
    else:
        return repr(data.rstrip('\x00'))

def PrefixIfNeeded(string, prefix=' '):
    if string == '':
        return string
    else:
        return prefix + string

def Xor(data, key):
    data = C2SIP3(data)
    key = C2SIP3(key)
    return C2BIP3(''.join(chr(ord(data[i]) ^ ord(key[i % len(key)])) for i in range(len(data))))

def FindAll(data, sub, offset=0):
    result = []
    start = 0
    while True:
        position = data.find(sub, start)
        if position == -1:
            return result
        result.append(position + offset)
        start = position + 1

def FindAllList(data, searches):
    result = []
    for element in searches:
        result.extend(FindAll(data, element))
    return sorted(list(set(result)))

def DecodeSectionnameIfNeeded(name):
    if len(name) == 0 or name.startswith('.'):
        return name
    xorkey = ord(name[0]) ^ ord('.')
    newname = ''.join([chr(ord(c) ^ xorkey) for c in name]).rstrip('\x00')
    return newname

def GetDataSection(data):
    sectionnames = []
    try:
        oPE = pefile.PE(data=data)
    except Exception as e:
        return e.value, None
    for section in oPE.sections:
        if sys.version_info[0] >= 3:
            sectionname = ''.join(filter(lambda c:c != '\0', str(section.Name.decode('unicode_escape'))))
        else:
            sectionname = ''.join(filter(lambda c:c != '\0', section.Name))
        sectionnames.append(repr(sectionname))
        if DecodeSectionnameIfNeeded(sectionname) == '.data':
            return None, section.get_data()
    return '.data section not found: ' + ' '.join(sectionnames), None

def GetXorChainSection(data):
    try:
        oPE = pefile.PE(data=data)
    except Exception as e:
        return None, e.value
    for section in oPE.sections:
        extracted, messages = TryXORChainDecoding(section.get_data())
        if messages != []:
            return extracted, messages
    return None, None

def StatisticalSearch(payloadsectiondata, key):
    start = None
    end = None
    position = 0
    while len(payloadsectiondata) > 8:
        block, payloadsectiondata = GetChunk(8, payloadsectiondata)
        if sum([IFF(c == key, 1, 0) for c in block]) > 2:
            if start == None:
                start = position
                end = position + 7
            else:
                end = position + 7
        position += 8
    return start, end

def Bytes2IPv4(data):
    return '%d.%d.%d.%d' % (P23Ord(data[0]), P23Ord(data[1]), P23Ord(data[2]), P23Ord(data[3]))

def FindAF_INET_PORT(operand):
    if P23Ord(operand[0]) != 2:
        return ''
    if P23Ord(operand[1]) != 0:
        return ''
    return '%d' % struct.unpack('>H', operand[2:4])[0]

def IdentifyShellcode(shellcode):
    if hashlib.sha256(shellcode[:346]).hexdigest() == '946af5a23e5403ea1caccb2e0988ec1526b375a3e919189f16491eeabc3e7d8c':
        return 'CS psexec psh x86 shellcode, opens named pipe'
    elif hashlib.sha256(shellcode[:191]).hexdigest() == '02fd615831f5cc22d83ad681d33159d232afc3b18b69f647f1726280e2d7e3f3':
        return 'CS reverse http x86 shellcode'
    elif hashlib.sha256(shellcode[:271]).hexdigest() == 'bf413ba9b63b6777c4765581bf42c1fdb119f1ed22836cfaa80e616e2a3bf795':
        return 'CS reverse http x64 shellcode'
    elif hashlib.sha256(shellcode[:196]).hexdigest() == '52230666746fa8c9ec635083b05943d02bfe516fc45ea9c87eef300b9cd064e8':
        return 'CS reverse https x86 shellcode'
    elif hashlib.sha256(shellcode[:274]).hexdigest() == 'acffe4f9fd8f82044772627a4174f14abf873a8e783c31353bf094118f3c1706':
        return 'CS reverse https x64 shellcode'
    elif hashlib.sha256(shellcode[:330]).hexdigest() == 'a82872e2d839cd2ee1b0c2324b83f2686284ebe3eef5e9fb0c9e97db8d86cbf4':
        return 'CS DNS x86 shellcode'
    return ''

def AnalyzeShellcode(shellcode, oOutput):
    dInstructions = {b'\x68': 'push', b'\xB8': 'mov eax'}
    dJSONData = GetJSONData()
    dLookupValues = dJSONData.get('dLookupValues', {})

    identification = IdentifyShellcode(shellcode)
    if identification != '':
        oOutput.Line('Identification: %s' % identification)
    position = shellcode.rfind(b'\xFF\xFF')
    if position != -1:
        parameters = shellcode[position+2:]
        position00 = parameters.find(b'\x00')
        remainder = b''
        if position00 != -1:
            remainder = parameters[position00 + 1:]
            parameters = parameters[:position00]
        oOutput.Line('Parameter: %d %s' % (position, repr(parameters)))
        if len(remainder) == 4:
            licenseid = struct.unpack('>I',remainder)[0]
            info = 'license-id: %d %d' % (position + position00 + 1, licenseid)
            info += LookupValue("37", '%d' % licenseid, dLookupValues)
            oOutput.Line(info)
    for pushPosition in FindAllList(shellcode, dInstructions.keys()):
        if pushPosition + 5 <= len(shellcode):
            if position == -1:
                operand = shellcode[pushPosition + 1:pushPosition + 5]
                oOutput.Line('%-10s: %5d %10d %5s %-16s %s' % (dInstructions[shellcode[pushPosition:pushPosition+1]], pushPosition, struct.unpack('<I', operand)[0], FindAF_INET_PORT(operand), Bytes2IPv4(operand), repr(shellcode[pushPosition:pushPosition + 5])))
            elif shellcode[pushPosition + 3:pushPosition + 5] == b'\x00\x00':
                oOutput.Line('%-10s: %5d %10d %s' % (dInstructions[shellcode[pushPosition:pushPosition+1]], pushPosition, struct.unpack('<H', shellcode[pushPosition + 1:pushPosition + 3])[0], repr(shellcode[pushPosition:pushPosition + 5])))

    for str in ExtractStringsASCII(shellcode):
        if len(str) == 5 and str.startswith(b'/') or str.startswith(b'User-Agent: ') or str.startswith(b'Mozilla/'):
            positions = FindAll(shellcode, str)
            oOutput.Line('String: %s %s' % (','.join(['%d' % position for position in positions]),str))

REGEX_STANDARD = b'[\x09\x20-\x7E]'

def ExtractStringsASCII(data):
    regex = REGEX_STANDARD + b'{%d,}'
    return re.findall(regex % 1, data)

def LookupConfigValue(id, value):
    dConfigValues = {
        0x0001: {
            0: 'windows-beacon_http-reverse_http',
            1: 'windows-beacon_dns-reverse_http',
            2: 'windows-beacon_smb-bind_pipz',
            4: 'windows-beacon_tcp-reverse_tcp',
            8: 'windows-beacon_https-reverse_https',
            16: 'windows-beacon_tcp-bind_tcp',
            32: 'to be determined',
        },
        0x0023: {
            1: 'no proxy',
            2: 'IE settings',
            4: 'hardcoded proxy',
        },
        0x002b: {
            0x01: 'PAGE_NOACCESS',
            0x02: 'PAGE_READONLY',
            0x04: 'PAGE_READWRITE',
            0x08: 'PAGE_WRITECOPY',
            0x10: 'PAGE_EXECUTE',
            0x20: 'PAGE_EXECUTE_READ',
            0x40: 'PAGE_EXECUTE_READWRITE',
            0x80: 'PAGE_EXECUTE_WRITECOPY',
        },
    }
    return PrefixIfNeeded(dConfigValues[id].get(value, ''))

def ConvertIntToIPv4(value):
    return ' %d.%d.%d.%d' % (C2IIP2(value[0]), C2IIP2(value[1]), C2IIP2(value[2]), C2IIP2(value[3]))

def ToHexadecimal(value):
    if isinstance(value, int):
        return '%x' % value
    else:
        return binascii.b2a_hex(value).decode()

def LookupValue(number, value, dInfo, verbose=False):
    lookup = ''
    if number in dInfo:
        lookup = dInfo[number].get(value, '')
    if isinstance(lookup, dict):
        message = lookup['normal']
        if verbose:
            message += ' (%s)' % lookup['verbose']
        lookup = message
    return PrefixIfNeeded(lookup)

def InterpretValue(info, number, value, dConfigValueInterpreter):
    interpreted = ''
    if number in dConfigValueInterpreter:
        interpreted = dConfigValueInterpreter[number](value)
    return info + interpreted

def GetScriptPath():
    if getattr(sys, 'frozen', False):
        return os.path.dirname(sys.executable)
    else:
        return os.path.dirname(sys.argv[0])

def DetermineCSVersionFromConfig(dJSON):
    maximumID = max(map(int, dJSON.keys()))
    if maximumID < 55:
        return ('3', maximumID)
    elif maximumID == 55:
        return ('4.0', maximumID)
    elif maximumID > 55 and maximumID < 58:
        return ('4.1', maximumID)
    elif maximumID == 58:
        return ('4.2', maximumID)
    elif maximumID == 70:
        return ('4.3', maximumID)
    else:
        return ('4.4', maximumID)

def SanityCheckExtractedConfig(dJSON):
    if not 1 in dJSON:
        return False
    if not 7 in dJSON:
        return False
    if LookupConfigValue(1, dJSON[1]['rawvalue']) == '':
        return False
    if not isinstance(dJSON[7]['rawvalue'], str):
        return False
    if not dJSON[7]['rawvalue'].startswith('308'):
        return False
    return True

def GetJSONData():
    filename = os.path.join(GetScriptPath(), '1768b.json')
    if os.path.isfile(filename):
        return json.load(open(filename, 'r'))
    filename = os.path.join(GetScriptPath(), '1768.json')
    if os.path.isfile(filename):
        return json.load(open(filename, 'r'))
    return {}

class cStruct(object):
    def __init__(self, data):
        self.data = data
        self.originaldata = data

    def Unpack(self, format):
        formatsize = struct.calcsize(format)
        if len(self.data) < formatsize:
            raise Exception('Not enough data')
        tounpack = self.data[:formatsize]
        self.data = self.data[formatsize:]
        result = struct.unpack(format, tounpack)
        if len(result) == 1:
            return result[0]
        else:
            return result

    def Truncate(self, length):
        self.data = self.data[:length]

    def GetBytes(self, length=None):
        if length == None:
            length = len(self.data)
        result = self.data[:length]
        self.data = self.data[length:]
        return result

    def GetString(self, format):
        stringLength = self.Unpack(format)
        return self.GetBytes(stringLength)

    def Length(self):
        return len(self.data)

# https://www.usualsuspect.re/article/cobalt-strikes-malleable-c2-under-the-hood
INSTRUCTION_TYPE_MALLEABLE_C2 = 1
INSTRUCTION_TYPE_GET = 2
INSTRUCTION_TYPE_POST = 3

INSTRUCTION_NONE = 0
INSTRUCTION_APPEND = 1
INSTRUCTION_PREPEND = 2
INSTRUCTION_BASE64 = 3
INSTRUCTION_PRINT = 4
INSTRUCTION_PARAMETER = 5
INSTRUCTION_HEADER = 6
INSTRUCTION_BUILD = 7
INSTRUCTION_NETBIOS = 8
INSTRUCTION_CONST_PARAMETER = 9
INSTRUCTION_CONST_HEADER = 10
INSTRUCTION_NETBIOSU = 11
INSTRUCTION_URI_APPEND = 12
INSTRUCTION_BASE64URL = 13
INSTRUCTION_STRREP = 14
INSTRUCTION_MASK = 15
INSTRUCTION_CONST_HOST_HEADER = 16

def DecodeInstructions(value, instructionsType):
    oStruct = cStruct(value)
    instructions = []
    opcodes = []
    buildFlag = False
    while oStruct.Length() >= 4:
        opcode = oStruct.Unpack('>I')
        if buildFlag and opcode in [0, 6, 7, 10, 16]:
            instructions.append('Build End')
            opcodes.append(['7', 'End'])
            buildFlag = False
        if opcode == INSTRUCTION_NONE:
            break
        if opcode == INSTRUCTION_APPEND:
            if instructionsType == INSTRUCTION_TYPE_MALLEABLE_C2:
                operand = oStruct.Unpack('>I')
                instructions.append('Remove %d bytes from end' % operand)
                opcodes.append([str(opcode), str(operand)])
            else:
                operand = oStruct.GetString('>I').decode('latin')
                instructions.append('Append %s' % operand)
                opcodes.append([str(opcode), operand])
        elif opcode == INSTRUCTION_PREPEND:
            if instructionsType == INSTRUCTION_TYPE_MALLEABLE_C2:
                operand = oStruct.Unpack('>I')
                instructions.append('Remove %d bytes from begin' % operand)
                opcodes.append([str(opcode), str(operand)])
            else:
                operand = oStruct.GetString('>I').decode('latin')
                instructions.append('Prepend %s' % operand)
                opcodes.append([str(opcode), operand])
        elif opcode == INSTRUCTION_BASE64:
            instructions.append('BASE64')
            opcodes.append([str(opcode)])
        elif opcode == INSTRUCTION_PRINT:
            instructions.append('Print')
            opcodes.append([str(opcode)])
        elif opcode == INSTRUCTION_PARAMETER:
            operand = oStruct.GetString('>I').decode('latin')
            instructions.append('Parameter %s' % operand)
            opcodes.append([str(opcode), operand])
        elif opcode == INSTRUCTION_HEADER:
            operand = oStruct.GetString('>I').decode('latin')
            instructions.append('Header %s' % operand)
            opcodes.append([str(opcode), operand])
        elif opcode == INSTRUCTION_BUILD:
            buildFlag = True
            operand = oStruct.Unpack('>I')
            if instructionsType == INSTRUCTION_TYPE_POST:
                if operand == 0:
                    operand = 'SessionId'
                else:
                    operand = 'Output'
            else:
                operand = 'Metadata'
            instructions.append('Build %s' % operand)
            opcodes.append([str(opcode), operand])
        elif opcode == INSTRUCTION_NETBIOS:
            instructions.append('NETBIOS lowercase')
            opcodes.append([str(opcode)])
        elif opcode == INSTRUCTION_CONST_PARAMETER:
            operand = oStruct.GetString('>I').decode('latin')
            instructions.append('Const_parameter %s' % operand)
            opcodes.append([str(opcode), operand])
        elif opcode == INSTRUCTION_CONST_HEADER:
            operand = oStruct.GetString('>I').decode('latin')
            instructions.append('Const_header %s' % operand)
            opcodes.append([str(opcode), operand])
        elif opcode == INSTRUCTION_NETBIOSU:
            instructions.append('NETBIOS uppercase')
            opcodes.append([str(opcode)])
        elif opcode == INSTRUCTION_URI_APPEND:
            instructions.append('Uri_append')
            opcodes.append([str(opcode)])
        elif opcode == INSTRUCTION_BASE64URL:
            instructions.append('BASE64 URL')
            opcodes.append([str(opcode)])
        elif opcode == INSTRUCTION_STRREP:
            operand1 = oStruct.GetString('>I').decode('latin')
            operand2 = oStruct.GetString('>I').decode('latin')
            instructions.append('STRREP %s %s' % (operand1, operand2))
            opcodes.append([str(opcode), operand1, operand2])
        elif opcode == INSTRUCTION_MASK:
            instructions.append('XOR with 4-byte random key')
            opcodes.append([str(opcode)])
        elif opcode == INSTRUCTION_CONST_HOST_HEADER:
            operand = oStruct.GetString('>I').decode('latin')
            instructions.append('Const_host_header %s' % operand)
            opcodes.append([str(opcode), operand])
        else:
            instructions.append('Unknown instruction: 0x%02x' % opcode)
            opcodes.append([str(opcode)])

    result = []
    buildFlag = False
    for instruction in instructions:
        if instruction == 'Build End':
            result.append(build)
        elif instruction.startswith('Build '):
            build = [instruction]
            buildFlag= True
        elif buildFlag:
            build.append(instruction)
        else:
            result.append(instruction)
    instructions = result

    result = []
    buildFlag = False
    for opcode in opcodes:
        if opcode == ['7', 'End']:
            result.append(build)
        elif opcode[0] == '7':
            build = [opcode]
            buildFlag= True
        elif buildFlag:
            build.append(opcode)
        else:
            result.append(opcode)
    opcodes = result

    if instructionsType == INSTRUCTION_TYPE_MALLEABLE_C2:
        instructions = [['Transform Input'] + instructions]
        opcodes = [[['7', 'Input']] + opcodes]
    return [instructions, opcodes]

def DecodeMalleableC2Instructions(parameter):
    instructions, opcodes = DecodeInstructions(parameter, INSTRUCTION_TYPE_MALLEABLE_C2)
    buildOpcodes = ','.join([item for opcode in opcodes for item in opcode])
    return 'Instructions: ' + ','.join(instructions) + ' [7,Input,' + buildOpcodes + ']'

def AnalyzeEmbeddedPEFileSub(payloadsectiondata, options):
    result = []

    if options.xorkeys:
        for xorKey in range(256):
            xorKeyBytes = bytes([xorKey])
            startConfigXored = Xor(START_CONFIG, xorKeyBytes)
            for position in FindAll(payloadsectiondata, startConfigXored):
                result, dJSON = AnalyzeEmbeddedPEFileSub2(Xor(payloadsectiondata[position:position+0x10000], xorKeyBytes), result, options)
                if result != [ERROR_SANITY_CHECK]:
                    return result, dJSON
        return [result, {}]

    xorKey = b'i'
    config, startconfig, endconfig = CutData(Xor(payloadsectiondata, xorKey), '[000100010002]:')
    if len(config) == 0:
        xorKey = b'.'
        config, startconfig, endconfig = CutData(Xor(payloadsectiondata, xorKey), '[000100010002]:')
    if len(config) == 0:
        xorKey = b'i'
        startconfig, endconfig = StatisticalSearch(payloadsectiondata, xorKey)
        if startconfig == None:
            xorKey = b'.'
            startconfig, endconfig = StatisticalSearch(payloadsectiondata, xorKey)
        if startconfig == None:
            result.append(ERROR_NO_CONFIG)
            return [result, {}]
        else:
            result.append('Config found (statistical): xorkey %s 0x%08x 0x%08x' % (xorKey, startconfig, endconfig))
            result.append(cDump(Xor(payloadsectiondata[startconfig:endconfig + 1], xorKey)).HexAsciiDump(rle=True))
            return [result, {}]
#                result.append('Config found: 0x%08x 0x%08x %s' % (startconfig, endconfig, ' '.join(['0x%08x' % position for position in FindAll(payloadsectiondata, '\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF')])))
#                result.append('Config found: 0x%08x 0x%08x %s' % (startconfig, endconfig, ' '.join(['0x%08x' % position for position in FindAll(payloadsectiondata, '\x90\x01\x00\x00')])))
    result.append('Config found: xorkey %s 0x%08x 0x%08x' % (xorKey, startconfig, endconfig))
    data = config

    return AnalyzeEmbeddedPEFileSub2(data, result, options)

dConfigIdentifiers = {
    0x0001: 'payload type',
    0x0002: 'port',
    0x0003: 'sleeptime',
    0x0004: 'maxgetsize', #
    0x0005: 'jitter',
    0x0006: 'maxdns',
    0x0007: 'publickey',
    0x0008: 'server,get-uri',
    0x0009: 'useragent',
    0x000a: 'post-uri',
    0x000b: 'Malleable_C2_Instructions', #
    0x000c: 'http_get_header',
    0x000d: 'http_post_header',
    0x000e: 'SpawnTo', #
    0x000f: 'pipename',
    0x0010: 'killdate_year', #
    0x0011: 'killdate_month', #
    0x0012: 'killdate_day', #
    0x0013: 'DNS_Idle', #
    0x0014: 'DNS_Sleep', #
    0x0015: 'SSH_HOST', #
    0x0016: 'SSH_PORT', #
    0x0017: 'SSH_USER-NAME', #
    0x0018: 'SSH_PASSWORD', #
    0x0019: 'SSH_PUBKEY', #
    0x001a: 'get-verb',
    0x001b: 'post-verb',
    0x001c: 'HttpPostChunk', #
    0x001d: 'spawnto_x86',
    0x001e: 'spawnto_x64',
    0x001f: 'CryptoScheme', #
    0x0020: 'proxy',
    0x0021: 'proxy_username',
    0x0022: 'proxy_password',
    0x0023: 'proxy_type',
    0x0024: 'deprecated', #
    0x0025: 'license-id',
    0x0026: 'bStageCleanup', #
    0x0027: 'bCFGCaution', #
    0x0028: 'killdate',
    0x0029: 'textSectionEnd', #
    0x002a: 'ObfuscateSectionsInfo', #
    0x002b: 'process-inject-start-rwx',
    0x002c: 'process-inject-use-rwx',
    0x002d: 'process-inject-min_alloc',
    0x002e: 'process-inject-transform-x86',
    0x002f: 'process-inject-transform-x64',
    0x0030: 'DEPRECATED_PROCINJ_ALLOWED',
    0x0031: 'BIND_HOST',
    0x0032: 'UsesCookies',
    0x0033: 'process-inject-execute',
    0x0034: 'process-inject-allocation-method',
    0x0035: 'process-inject-stub',
    0x0036: 'HostHeader',
    0x0037: 'EXIT_FUNK',
    0x0038: 'SSH_BANNER',
    0x0039: 'SMB_FRAME_HEADER',
    0x003a: 'TCP_FRAME_HEADER',
    0x003b: 'HEADERS_TO_REMOVE',
    0x003c: 'DNS_beacon',
    0x003d: 'DNS_A',
    0x003e: 'DNS_AAAA',
    0x003f: 'DNS_TXT',
    0x0040: 'DNS_metadata',
    0x0041: 'DNS_output',
    0x0042: 'DNS_resolver',
    0x0043: 'DNS_STRATEGY',
    0x0044: 'DNS_STRATEGY_ROTATE_SECONDS',
    0x0045: 'DNS_STRATEGY_FAIL_X',
    0x0046: 'DNS_STRATEGY_FAIL_SECONDS',
    0x0047: 'MAX_RETRY_STRATEGY_ATTEMPTS',
    0x0048: 'MAX_RETRY_STRATEGY_INCREASE',
    0x0049: 'MAX_RETRY_STRATEGY_DURATION',
}
dConfigValueInterpreter = {
    0x0001: lambda value: LookupConfigValue(0x0001, value),
    0x0007: ToHexadecimal,
    0x000b: DecodeMalleableC2Instructions,
    0x0013: ConvertIntToIPv4,
    0x0023: lambda value: LookupConfigValue(0x0023, value),
    0x002b: lambda value: LookupConfigValue(0x002b, value),
    0x002c: lambda value: LookupConfigValue(0x002b, value),
}

def AnalyzeEmbeddedPEFileSub2(data, result, options):
    dJSON = {}

    dJSONData = GetJSONData()
    dLookupValues = dJSONData.get('dLookupValues', {})

    while len(data) >= 2:
        formatNumber = '>H'
        formatTypeLength = '>HH'
        ntlBytes = data[0:struct.calcsize(formatNumber) + struct.calcsize(formatTypeLength)]
        try:
            number, data = Unpack(formatNumber, data)
        except UnpackErrorNotEnoughData:
            break
        if number == 0:
            result.append('0x%04x' % number)
            break
        try:
            type, length, data = Unpack(formatTypeLength, data)
        except UnpackErrorNotEnoughData:
            break
        parameter, data = GetChunk(length, data)
        info = ''
        rawvalue = None
        if type == 1 and length == 2:
            identifier = struct.unpack('>H', parameter)[0]
            rawvalue = identifier
            info = InterpretValue('%d' % identifier, number, identifier, dConfigValueInterpreter)
        elif type == 2 and length == 4:
            if number in [0x44, 0x45, 0x46]:
                rawvalue = struct.unpack('>i', parameter)[0]
            else:
                rawvalue = struct.unpack('>I', parameter)[0]
            value = '%d' % rawvalue
            info = InterpretValue(value, number, parameter[0:4], dConfigValueInterpreter)
            info += LookupValue(str(number), value, dLookupValues, options.verbose)
        elif type == 3 and not number in [0x0b, 0x0c, 0x0d]:
            info = InterpretValue('', number, parameter, dConfigValueInterpreter)
            rawvalue = binascii.b2a_hex(parameter).decode()
            if info == '':
                info = Represent(C2SIP3(parameter))
            info += LookupValue(str(number), rawvalue, dLookupValues, options.verbose)

        resultNumber = '0x%04x' % number
        resultType = '0x%04x' % type
        resultLength = '0x%04x' % length
        resultID = dConfigIdentifiers.get(number, '')
        dJSON[number] = {'id': resultID, 'type': resultType, 'info': info, 'rawvalue': rawvalue}
        if options.csv:
            result.append(MakeCSVLine((resultNumber, resultID, resultType, resultLength, info)))
        else:
            resultID = ('%-' + str(max([len(value) for value in dConfigIdentifiers.values()])) + 's') % resultID
            result.append('%s %s %s %s%s' % (resultNumber, resultID, resultType, resultLength, PrefixIfNeeded(info)))
        if type == 3 and number in [0x0b, 0x0c, 0x0d]:
            instructions, opcodes = DecodeInstructions(parameter, {0x0b: INSTRUCTION_TYPE_MALLEABLE_C2, 0x0c: INSTRUCTION_TYPE_GET, 0x0d: INSTRUCTION_TYPE_POST}[number])
            for index, instruction in enumerate(instructions):
                if isinstance(instruction, str):
                    if options.csv:
                        result.append(MakeCSVLine(('', '', '', '', instruction)))
                    else:
                        result.append('  %s' % instruction)
                else:
                    buildOpcodes = ','.join([':'.join(opcode) for opcode in opcodes[index]])
                    if number in dJSON:
                        if dJSON[number]['info'] == '':
                            dJSON[number]['info'] = buildOpcodes
                        else:
                            dJSON[number]['info'] += ';' + buildOpcodes
                    else:
                        dJSON[number] = {'id': resultID, 'type': resultType, 'info': buildOpcodes, 'rawvalue': binascii.b2a_hex(parameter).decode()}
                    if options.csv:
                        result.append(MakeCSVLine(('', '', '', '', '%s:[%s]' % (instruction[0], buildOpcodes))))
                    else:
                        result.append('  %s: [%s]' % (instruction[0], buildOpcodes))
                    for buildStep in instruction[1:]:
                        if options.csv:
                            result.append(MakeCSVLine(('', '', '', '', buildStep)))
                        else:
                            result.append('   %s' % buildStep)
#            for string in ExtractStringsASCII(parameter):
#                if options.csv:
#                    result.append(MakeCSVLine(('', '', '', '', string.decode('utf8', 'surrogateescape')), ',', '"'))
#                else:
#                    result.append('  %s' % string.decode('utf8', 'surrogateescape'))

        if options.select != '':
            select = ParseInteger(options.select)
            if number == select:
                result.append(' Decoded:     %s' % ToHexadecimal(ntlBytes + parameter))
                result.append(" 'i'-encoded: %s" % ToHexadecimal(Xor(ntlBytes + parameter, b'i')))
                result.append(" '.'-encoded: %s" % ToHexadecimal(Xor(ntlBytes + parameter, b'.')))
    result.append('Guessing Cobalt Strike version: %s (max 0x%04x)' % DetermineCSVersionFromConfig(dJSON))
    sanityCheck = SanityCheckExtractedConfig(dJSON)
    result.append('Sanity check Cobalt Strike config: %s' % ('OK' if sanityCheck else 'NOK'))
    if options.sanitycheck and not sanityCheck:
        return [[ERROR_SANITY_CHECK], {}]
    return [result, dJSON]

def AnalyzeEmbeddedPEFile(payloadsectiondata, oOutput, options):
    result, dJSON = AnalyzeEmbeddedPEFileSub(payloadsectiondata, options)
    oOutput.JSON(dJSON)
    for line in result:
        oOutput.Line(line)

def DetectPEFile(data):
    if len(data) < 40:
        return False
    if data[0:2] != b'MZ':
        return False
    offsetbytes = data[0x3C:0x3C + 4]
    if len(offsetbytes) != 4:
        return False
    offset = struct.unpack('<I', offsetbytes)[0]
    if data[offset:offset + 2] != b'PE':
        return False
    return True

def StripLeadingNOPs(data):
    return data.lstrip(b'\x90')

def XORChainSlow(iKey, encodedData):
    decodedData = b''
    xorkey = iKey
    while len(encodedData) >= 4:
        encoded = struct.unpack('<I', encodedData[0:4])[0]
        decodedData += struct.pack('<I', encoded ^ xorkey)
        xorkey = encoded
        encodedData = encodedData[4:]
    return decodedData

def XORChainFast(iKey, encodedData):
    oDATA = DataIO()
    xorkey = iKey
    index = 0
    format = '<I'
    formatLength = struct.calcsize(format)
    while True:
        bytesInteger = encodedData[index:index + formatLength]
        if len(bytesInteger) != formatLength:
            break
        encoded = struct.unpack(format, bytesInteger)[0]
        oDATA.write(struct.pack(format, encoded ^ xorkey))
        xorkey = encoded
        index += formatLength
    return oDATA.getvalue()

def XORChain(iKey, encodedData):
    fast = XORChainFast(iKey, encodedData)
    return fast
    slow = XORChainSlow(iKey, encodedData)
    if slow != fast:
        raise Exception('slow != fast')
    return fast

def TryXORChainDecoding(data):
    if len(data) < 0x100:
        return data, []
    formatstring = '<II'
    formatLength = struct.calcsize(formatstring)
    startLength = 16
    for iIter in range(1, 0x1000):
        bytesValues = data[iIter:iIter + formatLength + startLength]
        if len(bytesValues) != formatLength + startLength:
            return data, []
        xorKey, xorEncodedLength = struct.unpack(formatstring, bytesValues[:formatLength])
        decodedLength = xorKey ^ xorEncodedLength
        decodedStart = XORChain(xorKey, bytesValues[formatLength:])
        if StripLeadingNOPs(decodedStart)[0:2] == b'MZ':
            decodedData = StripLeadingNOPs(XORChain(xorKey, data[iIter + formatLength:iIter + formatLength + decodedLength]))
            if DetectPEFile(decodedData):
                return decodedData, ['xorkey(chain): 0x%08x' % xorKey, 'length: 0x%08x' % decodedLength]
        if b'MZRE' in decodedStart or b'MZAR' in decodedStart:
            decodedData = XORChain(xorKey, data[iIter + formatLength:iIter + formatLength + decodedLength])
            if START_CONFIG_I in decodedData or START_CONFIG_DOT in decodedData:
                return decodedData, ['xorkey(chain): 0x%08x' % xorKey, 'length: 0x%08x' % decodedLength]

    return data, []

def TryExtractDecode(data):
    if DetectPEFile(data):
        return data, []
    extracted = StripLeadingNOPs(data)
    if DetectPEFile(extracted):
        return extracted, ['leading NOPs: 0x%04x' % (len(data) - len(extracted))]
    extracted, messages = TryXORChainDecoding(data)
    if DetectPEFile(extracted):
        return extracted, messages
    if START_CONFIG_I in extracted or START_CONFIG_DOT in extracted:
        return extracted, messages
    return data, []

def TestShellcodeHeuristic(data):
    return b'hwini' in data[:0x1000] or b'hws2_' in data[:0x1000] or (data[0:1] == b'\xFC' and len(data) < 0x1000)

def FinalTests(data, options, oOutput):
    dSignatures = {
        # https://www.elastic.co/blog/detecting-cobalt-strike-with-memory-signatures
        'Sleep mask 64-bit 4.2 deobfuscation routine': b'\x4C\x8B\x53\x08\x45\x8B\x0A\x45\x8B\x5A\x04\x4D\x8D\x52\x08\x45\x85\xC9\x75\x05\x45\x85\xDB\x74\x33\x45\x3B\xCB\x73\xE6\x49\x8B\xF9\x4C\x8B\x03',
        'Sleep mask 32-bit 4.2 deobfuscation routine': b'\x8B\x46\x04\x8B\x08\x8B\x50\x04\x83\xC0\x08\x89\x55\x08\x89\x45\x0C\x85\xC9\x75\x04\x85\xD2\x74\x23\x3B\xCA\x73\xE6\x8B\x06\x8D\x3C\x08\x33\xD2',

        'Public key config entry': b'\x00\x07\x00\x03\x01\x00\x30\x81\x9F\x30\x0D\x06\x09\x2A\x86\x48\x86\xF7\x0D\x01\x01\x01\x05\x00\x03\x81\x8D\x00\x30\x81\x89\x02\x81',
        'Public key header': b'\x30\x81\x9F\x30\x0D\x06\x09\x2A\x86\x48\x86\xF7\x0D\x01\x01\x01\x05\x00\x03\x81\x8D\x00\x30\x81\x89\x02\x81',
    }

    for name, signature in dSignatures.items():
        xorKeys = [b'\x00']
        if name.startswith('Public key'):
            xorKeys = [b'\x00', b'\x2e', b'\x69']
            if options.xorkeys:
                xorKeys = [bytes([iter]) for iter in range(256)]
        for xorKey in xorKeys:
            signatureXored = Xor(signature, xorKey)
            for position in FindAll(data, signatureXored):
                stringsInFront = sorted(ExtractStringsASCII(data[position-0x100:position]), key=len, reverse=True)
                if len(stringsInFront) > 0:
                    longestString = ' (LSFIF: %s)' % stringsInFront[0]
                else:
                    longestString = ''
                oOutput.Line('%s found: 0x%08x%s%s' % (name, position, IFF(xorKey == b'\x00', '', ' (xorKey 0x%02x)' % xorKey[0]), longestString))
                if options.verbose:
                    oOutput.Line(cDump(data[position-0x100:position], '  ', position-0x100).HexAsciiDump(rle=True), eol='')
                    oOutput.Line('  ... signature ...')
                    oOutput.Line(cDump(data[position+len(signatureXored):position+len(signatureXored)+0x100], '  ', position+len(signatureXored)).HexAsciiDump(rle=True), eol='')

#a# this is a kludge, to fix later when I have time
def ProcessBinaryFileSub(sectiondata, data, oOutput, options):
    payloadType, payloadSize, intxorkey, id2, sectiondata = Unpack('<IIII', sectiondata)
    oOutput.Line('payloadType: 0x%08x' % payloadType)
    oOutput.Line('payloadSize: 0x%08x' % payloadSize)
    oOutput.Line('intxorkey: 0x%08x' % intxorkey)
    oOutput.Line('id2: 0x%08x' % id2)
    payload = Xor(sectiondata[:payloadSize], struct.pack('<I', intxorkey))
    if payloadSize > len(sectiondata):
        oOutput.Line('Error: payload size too large: 0x%08x' % payloadSize)
        oOutput.Line('.data section size: 0x%08x' % len(sectiondata))
        return False
    error, payloadsectiondata = GetDataSection(payload)
    if error != None:
        positionMZ = payload.find(b'MZ')
        if positionMZ != 0:
            if START_CONFIG_I in sectiondata or START_CONFIG_DOT in sectiondata or options.xorkeys:
                AnalyzeEmbeddedPEFile(data, oOutput, options)
            elif TestShellcodeHeuristic(payload):
                if IdentifyShellcode(payload) == '':
                    oOutput.Line('Probably found shellcode:')
                else:
                    oOutput.Line('Found shellcode:')
                AnalyzeShellcode(payload, oOutput)
                oOutput.Line(cDump(payload).HexAsciiDump(rle=False))
            elif positionMZ >= 0 and positionMZ < 0x20:
                oOutput.Line('MZ header found position %d' % positionMZ)
                AnalyzeEmbeddedPEFile(payload[positionMZ:], oOutput, options)
            elif len(payload) == 0:
                return False
            else:
                oOutput.Line('MZ header not found, truncated dump:')
                oOutput.Line(cDump(payload[:0x1000]).HexAsciiDump(rle=True))
                return False
        else:
            oOutput.Line('Error: embedded PE file error: %s' % error)
            return False
    else:
        AnalyzeEmbeddedPEFile(payloadsectiondata, oOutput, options)
    FinalTests(payload, options, oOutput)
    return True

def Truncate(data, truncate=b'\x00'):
    position = data.find(truncate)
    if position == -1:
        return data
    else:
        return data[:position]

def PackIntegers(formats, integer):
    result = []
    for format in formats:
        try:
            bytesInteger = struct.pack(format, integer)
        except struct.error:
            pass
        else:
            result.append(bytesInteger)
    return result

def FindGenericArrayPointingToStrings(listData, publickey, oOutput):
    selectedStrings = []
    for baseAddress, data in listData:
        addressesPublicKey = FindAll(data, publickey, baseAddress)
        if len(addressesPublicKey) > 0:
            for addressPublicKey in addressesPublicKey:
                for bytesInteger in PackIntegers(['<I', '<Q'], addressPublicKey):
                    for addressPointer in FindAll(data, bytesInteger, baseAddress):
                        selectedStrings.append([addressPointer, addressPublicKey, publickey])
            for extractedString in set(ExtractStringsASCII(data)):
                if len(extractedString) > 4:
                    for addressExtractedString in FindAll(data, extractedString + b'\x00', baseAddress):
                        for bytesInteger in PackIntegers(['<I', '<Q'], addressExtractedString):
                            for addressPointer in FindAll(data, bytesInteger, baseAddress):
                                selectedStrings.append([addressPointer, addressExtractedString, extractedString])
    previousAddressPointer = 0
    foundPublicKey = False
    for addressPointer, addressExtractedString, extractedString in sorted(selectedStrings):
        if addressPointer != previousAddressPointer:
            if not foundPublicKey and extractedString == publickey:
                foundPublicKey = True
                oOutput.Line('0x%012x 0x%06x 0x%06x %s' % (addressPointer, addressPointer - previousAddressPointer, addressExtractedString, extractedString))
                oOutput.Line('Experimental: runtime array with string pointers found:')
            if foundPublicKey:
                oOutput.Line('0x%012x 0x%06x 0x%06x %s' % (addressPointer, addressPointer - previousAddressPointer, addressExtractedString, extractedString))
            previousAddressPointer = addressPointer

def FindAlternativeRuntimeConfig1(listData, oOutput):
    dTypeFormats = {10: True, 26: True, 27: True, 29: True, 30: True, 36: True, 108: True, 109: True}
    for formatRecordBits, formatRecord in {'32-bit': '<BHII', '64-bit': '<BHIQ'}.items():
        runtimeHeader = struct.pack(formatRecord, 0, 0, 0, 0) * 9 + struct.pack(formatRecord[:-1], 9, 0, 0)
        for baseAddress, data in listData:
            positionsruntimeHeader = FindAll(data, runtimeHeader)
            for positionruntimeHeader in positionsruntimeHeader:
                oStruct = cStruct(data[positionruntimeHeader+len(runtimeHeader):])
                if oStruct.GetBytes(8) and oStruct.Unpack(formatRecord)[0:3] == (9, 0, 0) and oStruct.Unpack(formatRecord)[0:3] == (9, 0, 0):
                    oOutput.Line('Experimental: "alternative" runtime config %s %s found at %d (baseAddress 0x%016x):' % (formatRecordBits, formatRecord, positionruntimeHeader, baseAddress))
                    oStruct = cStruct(data[positionruntimeHeader:])
                    for iter in range(1, 128):
                        var1, var2, var3, var4 = oStruct.Unpack(formatRecord)
                        if [var1, var2, var3, var4] == [0, 0, 0, 0]:
                            continue
                        if var1 == 9:
                            var4 = data[var4-baseAddress:var4-baseAddress+256]
                            if iter in dTypeFormats:
                                var4 = Truncate(var4)
                        oOutput.Line(' %3d %-30s %d %d %d %s' % (iter, dConfigIdentifiers.get(iter - 100 if iter > 100 else iter, ''), var1, var2, var3, var4))


# cfr blog post Hendrik Eckardt
def RuntimeAnalysis(datamdmp, dConfigs, oOutput, options):
    listData = []
    oMinidumpFile = MinidumpFile.parse_bytes(datamdmp)
    oget_buffered_reader = oMinidumpFile.get_reader().get_buffered_reader()
    if oMinidumpFile.memory_info != None:
        for info in oMinidumpFile.memory_info.infos:
#            print(info.Protect, info.BaseAddress, info.RegionSize, info.Type)
            try:
                oget_buffered_reader.move(info.BaseAddress)
            except Exception as e:
                if e.args[0].endswith(' is not in process memory space'):
#                    print('Error: %s' % e.args[0])
                    continue
                else:
                    raise e
            try:
                bytesSegment = oget_buffered_reader.read(info.RegionSize)
                listData.append([['segment', info], bytesSegment])
            except OverflowError:
#                print('OverflowError') #a# handle overflow
                pass
            except Exception as e:
                if e.args[0] == 'Would read over segment boundaries!':
#                    print('Error: %s' % e.args[0])
                    pass
                else:
                    raise e
    listData = sorted(listData, reverse=True, key=lambda item: len(item[1]))
    listData = [[dataInfo[1].BaseAddress, data] for dataInfo, data in listData]
    publickey = b'\x30\x81\x9F\x30\x0D\x06\x09\x2A\x86\x48\x86\xF7\x0D\x01\x01\x01\x05\x00\x03\x81\x8D\x00\x30\x81\x89\x02\x81'
    for baseAddress, data in listData:
        positionsPublickey = FindAll(data, publickey)
        if len(positionsPublickey) > 0:
            for positionPublickey in positionsPublickey:
                addressPublickey = baseAddress + positionPublickey
                for packformatBits, packformat in {'32-bit': '<II', '64-bit': '<QQ'}.items():
                    packformatSize = struct.calcsize(packformat)
                    try:
                        bytesAddressPublickey = struct.pack(packformat, 3, addressPublickey)
                    except struct.error:
                        continue
                    for positionPublickeyEntry in FindAll(data, bytesAddressPublickey):
                        positionRuntimeConfig = positionPublickeyEntry - 7 * packformatSize
                        oOutput.Line('Runtime config %s found: 0x%08x' % (packformatBits, addressPublickey))
                        oStruct = cStruct(data[positionRuntimeConfig:])
                        abConfig = b''
                        for counter in range(128):
                            entrytype, entrydata = oStruct.Unpack(packformat)
                            if entrytype == 0:
                                pass
                            elif entrytype == 3:
                                configItem = data[entrydata - baseAddress:]
                                if counter in [0x07, 0x0b, 0x0c, 0x0d]:
                                    configItem = configItem[:0x100]
                                else:
                                    configItem = configItem[:configItem.find(b'\x00')]
#                                print('%04x %08x -> %s' % (counter, entrytype, configItem))
                                abConfig += struct.pack('>HHH', counter, entrytype, 0x100)
                                abConfig += configItem + b'\x00' * (0x100 - len(configItem))
                            elif entrytype == 1:
#                                print('%04x %08x -> %d' % (counter, entrytype, entrydata))
                                abConfig += struct.pack('>HHH', counter, entrytype, 2)
                                abConfig += struct.pack('>H', entrydata)
                            elif entrytype == 2:
#                                print('%04x %08x -> %d' % (counter, entrytype, entrydata))
                                abConfig += struct.pack('>HHH', counter, entrytype, 4)
                                abConfig += struct.pack('>I', entrydata)
                            else:
                                break
                        abConfig += struct.pack('>HHH', 0, 0, 0)
                        result, dJSON = AnalyzeEmbeddedPEFileSub2(abConfig, [], options)
                        configSha256 = hashlib.sha256(''.join(result).encode()).hexdigest()
                        if not configSha256 in dConfigs:
                            dConfigs[configSha256] = True
                            if result != [ERROR_SANITY_CHECK]:
                                oOutput.JSON(dJSON)
                                for line in result:
                                    oOutput.Line(line)

    if options.experimental:
        FindAlternativeRuntimeConfig1(listData, oOutput)
        FindGenericArrayPointingToStrings(listData, publickey, oOutput)

def FindAlternativeStoredConfig1(data, oOutput):
    header = b'\x00\x65\x00\x07\x00\x02\x00'
    for key in range(0x100):
        headerXored = bytes([b ^ key for b in header])
        for position in FindAll(data, headerXored):
            oOutput.Line('Experimental: "alternative" stored config found %s XOR 0x%02x position 0x%08x:' % (header, key, position))
            oStruct = cStruct(bytes([b ^ key for b in data[position:position+0x1000]]))
            while oStruct.Length() > 0:
                var1, var2, var3 = oStruct.Unpack('>HHH')
                if var1 == 0:
                    break
                if var3 == 2:
                    value = oStruct.Unpack('>H')
                elif var3 == 4:
                    value = oStruct.Unpack('>I')
                else:
                    value = oStruct.GetBytes(var3).rstrip(b'\x00')
                if var1 > 100:
                    identifier = var1 - 100
                else:
                    identifier = var1
                oOutput.Line('%3d %-40s %d %3d %s' % (var1, dConfigIdentifiers.get(identifier, ''), var2, var3, value))

def ProcessBinaryFile(filename, content, cutexpression, flag, oOutput, oLogfile, options):
    if content == None:
        try:
            oBinaryFile = cBinaryFile(filename, C2BIP3(options.password), options.noextraction, options.literalfilenames)
        except:
            oLogfile.LineError('Opening file %s %s' % (filename, repr(sys.exc_info()[1])))
            return
        oLogfile.Line('Success', 'Opening file %s' % filename)
        try:
            data = oBinaryFile.read()
        except:
            oLogfile.LineError('Reading file %s %s' % (filename, repr(sys.exc_info()[1])))
            return
        data = CutData(data, cutexpression)[0]
        oBinaryFile.close()
        oOutput.Line('File: %s%s' % (filename, IFF(oBinaryFile.extracted, ' (extracted)', '')))
    else:
        data = content
        oOutput.Line('File: %s' % (filename))

    if options.hash:
        oOutput.Line('MD5   : %s' % hashlib.md5(data).hexdigest())
        oOutput.Line('SHA1  : %s' % hashlib.sha1(data).hexdigest())
        oOutput.Line('SHA256: %s' % hashlib.sha256(data).hexdigest())
    try:
        # ----- Put your data processing code here -----
        data, messages = TryExtractDecode(data)
        for message in messages:
            oOutput.Line(message)
        if data[0:2] == b'MZ' and not options.raw:
            extracted, messages = GetXorChainSection(data)
            if extracted != None:
                resultChain, dJSON = AnalyzeEmbeddedPEFileSub(extracted, options)
                if resultChain != [ERROR_NO_CONFIG]:
                    oOutput.JSON(dJSON)
                    for message in messages:
                        oOutput.Line(message)
                    for message in resultChain:
                        oOutput.Line(message)
                    FinalTests(extracted, options, oOutput)
                else:
                    extracted = None
            if extracted == None:
                error, sectiondata = GetDataSection(data)
                if error != None:
                    oOutput.Line('Error: PE file error: %s' % error)
                elif len(sectiondata) < 16:
                    oOutput.Line('Error: section .data too small: %d' % len(sectiondata))
                elif ProcessBinaryFileSub(sectiondata, data, oOutput, options):
                    pass
                else:
                    bytesToSkip = 0x20
                    oOutput.Line('Skipping %d bytes' % bytesToSkip)
                    ProcessBinaryFileSub(sectiondata[bytesToSkip:], data, oOutput, options)
            FinalTests(data, options, oOutput)
        elif TestShellcodeHeuristic(data):
            if IdentifyShellcode(data) == '':
                oOutput.Line('Probably found shellcode:')
            else:
                oOutput.Line('Found shellcode:')
            AnalyzeShellcode(data, oOutput)
            oOutput.Line(cDump(data).HexAsciiDump(rle=False))
            FinalTests(data, options, oOutput)
        else:
            dConfigs = {}
            if options.xorkeys:
                xorKeys = range(256)
            else:
                xorKeys = [0x2E, 0x69]
            for xorKey in xorKeys:
                xorKeyBytes = bytes([xorKey])
                startConfigXored = Xor(START_CONFIG, xorKeyBytes)
                for position in FindAll(data, startConfigXored):
                    result, dJSON = AnalyzeEmbeddedPEFileSub2(Xor(data[position:position+0x10000], xorKeyBytes), [], options)
                    configSha256 = hashlib.sha256(''.join(result).encode()).hexdigest()
                    if not configSha256 in dConfigs:
                        dConfigs[configSha256] = True
                        if result != [ERROR_SANITY_CHECK]:
                            oOutput.JSON(dJSON)
                            oOutput.Line('xorkey %s %02x' % (xorKeyBytes, xorKey))
                            for line in result:
                                oOutput.Line(line)
            if data[:4] == b'MDMP':
                try:
                    MinidumpFile
                except NameError:
                    print('minidump module is required for runtime config analysis: pip install minidump')
                else:
                    RuntimeAnalysis(data, dConfigs, oOutput, options)
            FinalTests(data, options, oOutput)

        if options.experimental:
            FindAlternativeStoredConfig1(data, oOutput)
        # ----------------------------------------------
    except:
        oLogfile.LineError('Processing file %s %s' % (filename, repr(sys.exc_info()[1])))
        if not options.ignoreprocessingerrors:
            raise

def FormatTime(epoch=None):
    if epoch == None:
        epoch = time.time()
    return '%04d%02d%02d-%02d%02d%02d' % time.localtime(epoch)[0:6]

def SpaceEvery2Characters(string):
    result = []
    while string != '':
        result.append(string[0:2])
        string = string[2:]
    return ' '.join(result)

def ProcessLicenseIDs(oOutput, oLogfile, options):
    rule_config = '''rule cs_%s_licenseid {
  meta:
    license_name = "%s"
    license_id = "%d"
    info = "rule generated by 1768.py on %s"
  strings:
    $a = { %s }
  condition:
    $a
}
'''

    rule_config_i = '''rule cs_%s_licenseid_i {
  meta:
    license_name = "%s"
    license_id = "%d"
    info = "rule generated by 1768.py on %s"
  strings:
    $a = { %s }
  condition:
    $a
}
'''

    rule_config_dot = '''rule cs_%s_licenseid_dot {
  meta:
    license_name = "%s"
    license_id = "%d"
    info = "rule generated by 1768.py on %s"
  strings:
    $a = { %s }
  condition:
    $a
}
'''

    rule_shellcode = '''rule cs_%s_licenseid_shellcode {
  meta:
    license_name = "%s"
    license_id = "%d"
    info = "rule generated by 1768.py on %s"
  strings:
    $a = { %s }
  condition:
    $a and filesize < 10000
}
'''

    rule_shellcode_00 = '''rule cs_%s_licenseid_shellcode_00 {
  meta:
    license_name = "%s"
    license_id = "%d"
    info = "rule generated by 1768.py on %s"
  strings:
    $a = { %s }
  condition:
    $a and filesize < 10000
}
'''

    rule_shellcode_00_end = '''rule cs_%s_licenseid_shellcode_00_end {
  meta:
    license_name = "%s"
    license_id = "%d"
    info = "rule generated by 1768.py on %s"
  strings:
    $a = { %s }
  condition:
    $a and filesize < 10000 and $a at (filesize - 5)
}
'''

    for licenseid in options.licenseids.split(','):
        result = licenseid.split(':', 1)
        if len(result) == 1:
            idInteger = ParseInteger(licenseid)
            bytes = struct.pack('>I', idInteger)
            idName = binascii.b2a_hex(bytes).decode()
        else:
            idInteger = ParseInteger(result[1])
            bytes = struct.pack('>I', idInteger)
            idName = result[0]
        prefix = b'\x00\x25\x00\x02\x00\x04'
        oOutput.Line(rule_config % (idName, idName, idInteger, FormatTime(), SpaceEvery2Characters(binascii.b2a_hex(prefix + bytes).decode())))
        oOutput.Line(rule_config_i % (idName, idName, idInteger, FormatTime(), SpaceEvery2Characters(binascii.b2a_hex(Xor(prefix + bytes, b'i')).decode())))
        oOutput.Line(rule_config_dot % (idName, idName, idInteger, FormatTime(), SpaceEvery2Characters(binascii.b2a_hex(Xor(prefix + bytes, b'.')).decode())))
        oOutput.Line(rule_shellcode % (idName, idName, idInteger, FormatTime(), SpaceEvery2Characters(binascii.b2a_hex(bytes).decode())))
        oOutput.Line(rule_shellcode_00 % (idName, idName, idInteger, FormatTime(), SpaceEvery2Characters(binascii.b2a_hex(b'\x00' + bytes).decode())))
        oOutput.Line(rule_shellcode_00_end % (idName, idName, idInteger, FormatTime(), SpaceEvery2Characters(binascii.b2a_hex(b'\x00' + bytes).decode())))

class cOutputJSON(object):
    def __init__(self, oOutput, options):
        self.oOutput = oOutput
        self.options = options
        self.messages = []
        self.filename = ''
        self.JSONs = []

    def JSON(self, dJSON):
        self.JSONs.append(dJSON)

    def Line(self, line, eol='\n'):
        if self.options.jsonoutput:
            self.messages.append(line)
        else:
            self.oOutput.Line(line, eol)

    def Filename(self, filename, index, total):
        self.oOutput.Filename(filename, index, total)
        self.filename = filename

class cAPIOptions(object):
    def __init__(self):
        self.csv = False
        self.select = ''
        self.ignoreprocessingerrors = False
        self.raw = False
        self.verbose = False
        self.hash = False
        self.sanitycheck = False
        self.xorkeys = False

class cAPIOutput(object):
    def __init__(self):
        self.messages = []
        self.JSONs = []

    def JSON(self, dJSON):
        self.JSONs.append(dJSON)

    def Line(self, line):
        self.messages.append(line)

    def LineError(self, line):
        pass

def APIAnalyze(data, raw=False):
    oOutput = cAPIOutput()
    oOptions = cAPIOptions()
    if raw:
        oOptions.raw = True
    ProcessBinaryFile('', data, ':', '', oOutput, cAPIOutput(), oOptions)
    return oOutput.JSONs

def ProcessBinaryFiles(filenames, oLogfile, options):
    oOutput = cOutputJSON(InstantiateCOutput(options), options)
    index = 0
    if options.jsoninput:
        items = CheckJSON(sys.stdin.read())
        if items == None:
            return
        for item in items:
            oOutput.Filename(item['name'], index, len(items))
            index += 1
            ProcessBinaryFile(item['name'], item['content'], '', '', oOutput, oLogfile, options)
            if options.jsonoutput:
                if oOutput.JSONs == []:
                    dJsonData = {}
                else:
                    dJsonData = oOutput.JSONs[0]
                oOutput.oOutput.Line(json.dumps({'filename': oOutput.filename, 'messages': oOutput.messages, 'config': dJsonData}))
    elif options.licenseids != '':
        ProcessLicenseIDs(oOutput, oLogfile, options)
    else:
        for filename, cutexpression, flag in filenames:
            oOutput.Filename(filename, index, len(filenames))
            index += 1
            ProcessBinaryFile(filename, None, cutexpression, flag, oOutput, oLogfile, options)
            if options.jsonoutput:
                if oOutput.JSONs == []:
                    dJsonData = {}
                else:
                    dJsonData = oOutput.JSONs[0]
                oOutput.oOutput.Line(json.dumps({'filename': oOutput.filename, 'messages': oOutput.messages, 'config': dJsonData}))

def Main():
    moredesc = '''

Source code put in the public domain by Didier Stevens, no Copyright
Use at your own risk
https://DidierStevens.com'''

    oParser = optparse.OptionParser(usage='usage: %prog [options] [[@]file|cut-expression|flag-expression ...]\n' + __description__ + moredesc, version='%prog ' + __version__, epilog='This tool also accepts flag arguments (#f#), read the man page (-m) for more info.')
    oParser.add_option('-m', '--man', action='store_true', default=False, help='Print manual')
    oParser.add_option('-r', '--raw', action='store_true', default=False, help='Search through the file as a binary file, do not parse as a PE file')
    oParser.add_option('-s', '--select', default='', help='Field to select')
    oParser.add_option('-S', '--sanitycheck', action='store_true', default=False, help='Exclude configs that do not pass sanity check')
    oParser.add_option('-o', '--output', type=str, default='', help='Output to file (# supported)')
    oParser.add_option('-l', '--licenseids', default='', help='License ID(s)/Watermark(s) to generate YARA rules for')
    oParser.add_option('-c', '--csv', action='store_true', default=False, help='Output config in CSV format')
    oParser.add_option('-p', '--password', default='infected', help='The ZIP password to be used (default infected)')
    oParser.add_option('-n', '--noextraction', action='store_true', default=False, help='Do not extract from archive file')
    oParser.add_option('-H', '--hash', action='store_true', default=False, help='Include hashes of file content')
    oParser.add_option('-x', '--xorkeys', action='store_true', default=False, help='Try all single byte XOR keys (not only 0x69 and 0x2e)')
    oParser.add_option('--literalfilenames', action='store_true', default=False, help='Do not interpret filenames')
    oParser.add_option('--recursedir', action='store_true', default=False, help='Recurse directories (wildcards and here files (@...) allowed)')
    oParser.add_option('--checkfilenames', action='store_true', default=False, help='Perform check if files exist prior to file processing')
    oParser.add_option('-j', '--jsoninput', action='store_true', default=False, help='Consume JSON from stdin')
    oParser.add_option('-J', '--jsonoutput', action='store_true', default=False, help='Output JSON')
    oParser.add_option('-V', '--verbose', action='store_true', default=False, help='Verbose output')
    oParser.add_option('-e', '--experimental', action='store_true', default=False, help='Enabe experimental features')
    oParser.add_option('--logfile', type=str, default='', help='Create logfile with given keyword')
    oParser.add_option('--logcomment', type=str, default='', help='A string with comments to be included in the log file')
    oParser.add_option('--ignoreprocessingerrors', action='store_true', default=False, help='Ignore errors during file processing')
    (options, args) = oParser.parse_args()

    if options.man:
        oParser.print_help()
        PrintManual()
        return

    if len(args) != 0 and options.jsoninput:
        print('Error: option -j can not be used with files')
        return

    oLogfile = cLogfile(options.logfile, options.logcomment)
    oExpandFilenameArguments = cExpandFilenameArguments(args, options.literalfilenames, options.recursedir, options.checkfilenames, '#c#', '#f#')
    oLogfile.Line('FilesCount', str(len(oExpandFilenameArguments.Filenames())))
    oLogfile.Line('Files', repr(oExpandFilenameArguments.Filenames()))
    if oExpandFilenameArguments.warning:
        PrintError('\nWarning:')
        PrintError(oExpandFilenameArguments.message)
        oLogfile.Line('Warning', repr(oExpandFilenameArguments.message))

    starttime = time.time()
    ProcessBinaryFiles(oExpandFilenameArguments.Filenames(), oLogfile, options)
    if options.verbose:
        print('Duration: %f' % (time.time() - starttime))

    if oLogfile.errors > 0:
        PrintError('Number of errors: %d' % oLogfile.errors)
    oLogfile.Close()

if __name__ == '__main__':
    Main()

```

`Scripts/Get-ProcessTree/Get-ProcessTree.ps1`:

```ps1
<#
.SYNOPSIS
    Shows a process history tree with data extracted from a MemProcFS-Analyzer process overview CSV
.EXAMPLE
    PS> Get-ProcessTree.ps1 -CSVPath "~\Desktop\proc.csv"
    Shows the process tree using data from the given CSV
.AUTHOR
	Dominik Schmidt @ https://github.com/DaFuqs
.VERSION
    1.5
.VERSION_HISTORY
    1.5: - Load PresentationCore if env does not load it automatically
    1.4: - Nodes to not expand / subtract on double click anymore. This action is already used for opening the properties window
    1.3: - Use a compiled version of DamerauLevenshteinDistance for increased performance
         - Orphaned processes get that listed in the "Suspicious" tag
         - New Switch Param: NoSuspiciousChecks: for when you just want a quick process tree without automatic checks for suspicious entries
         - Right click menu for the popup process properties window to copy selected/all values
    1.2: - Fixed hang when pid<=>parent PPIDs result in a ppid loop (like when PIDs have been reused). Findings will be reported
         - 4 new process masquerading checks:
             - processes with unusual parents
             - processes in unusual paths
             - processes with an unusual number of instances
             - similarly named processes to known-good ones
    1.1: - Double Clicking an Entry brings up a property view
         - Suspicious Entries get colored red and list their suspicion hits in their tooltip + properties view
    1.0: Public release
#>

[CmdletBinding()]

Param (
    # Path to the input CSV file
    [Parameter(Mandatory=$false, ValueFromPipeline=$true)]
	[ValidateScript({try { Test-Path -Path $_ -PathType Leaf } catch { throw "No file at `"$_`"" }})] # test if there is a file at given location
    [string] $CSVPath = ".\proc.csv",
    
    # Process names of script interpreters
    # Will be matched 1:1
    [Parameter(Mandatory=$false)]
    $ScriptInterpreters = @("powershell.exe", "cmd.exe", "wscript.exe", "cscript.exe", "python.exe"),

    [Parameter(Mandatory=$false)]
    $LateralMovementPrograms =  @("*psexec*", "mstsc.exe", "putty.exe", "winscp.exe", "scp.exe"),

    # https://attack.mitre.org/techniques/T1218/
    [Parameter(Mandatory=$false)]
    $SuspiciousPrograms =  @("*certutil.exe", "ping.exe", "msconfig.exe", "nslookup.exe", "ipconfig.exe", "systeminfo.exe", "nltest.exe", "net.exe", "chcp.exe", "bitsadmin.exe", "WSreset.exe", "mshta.exe", 
    "regsvr32.exe", "rundll32.exe", "mavinject.exe", "sc.exe", "tasklist.exe", 
    "msbuild.exe" # https://attack.mitre.org/techniques/T1127/001/
    "adfind.exe" # https://attack.mitre.org/techniques/T1087/002/
    ),

    # 
    [Parameter(Mandatory=$false)]
    $SuspiciousParameters = @(
        [Tuple]::Create("powershell.exe", "-Enc")
        [Tuple]::Create("powershell.exe", "Webclient")
        [Tuple]::Create("powershell.exe", "Hidden")  # T1564.003
        [Tuple]::Create("powershell.exe", "Bypass")
        [Tuple]::Create("wscript.exe", "PubPrn") # https://attack.mitre.org/techniques/T1216/001/
        [Tuple]::Create("cscript.exe", "PubPrn") # https://attack.mitre.org/techniques/T1216/001
    ),

    #  [T1036.007]
    $DoubleFileExtensions,

    # Names of folders where process launch should be noted as suspicious
    # Will be matched via -like (use * as wildcard at start and end)
    [Parameter(Mandatory=$false)]
    $SuspiciousFolders =  @("*\appdata\*", "*\temp\*"),

    # Parent Process Name => File Path
    # Process names will be matched 1:1
    # File Paths will be matched via -like (use * as wildcard at start and end)
    [Parameter(Mandatory=$false)]
    $UnusualRelationships = @(
        [Tuple]::Create("Excel.exe", "*.exe")
        [Tuple]::Create("Word.exe", "*.exe")
        [Tuple]::Create("Outlook.exe", "*.exe")
        [Tuple]::Create("MSEdge.exe", "*.exe")
        [Tuple]::Create("Chrome.exe", "*.exe")
        [Tuple]::Create("Firefox.exe", "*.exe")
        [Tuple]::Create("Schtasks.exe", "powershell.exe")
        [Tuple]::Create("Schtasks.exe", "cmd.exe")
        [Tuple]::Create("Schtasks.exe", "C:\Users\*")
        [Tuple]::Create("Schtasks.exe", "C:\ProgramData\*")
        [Tuple]::Create("Schtasks.exe", "rundll32.exe")
        [Tuple]::Create("userinit.exe", "*exp*")
        [Tuple]::Create("powershell.exe", "*")
        [Tuple]::Create("WMIPrvSE.exe", "*")
        [Tuple]::Create("rundll32.exe", "C:\Users\*")
    ),

    # Known windows processes and their usual parents
    [Parameter(Mandatory=$false)]
    $ExpectedRelationships = @{
        "csrss.exe" = @("smss.exe", "svchost.exe")
        "LogonUI.exe" = @("wininit.exe", "winlogon.exe")
        "lsass.exe" = @("wininit.exe")
        "services.exe" = @("wininit.exe")
        "smss.exe" = @("System", "smss.exe")
        "spoolsv.exe" = @("services.exe")
        "svchost.exe" = @("services.exe", "MsMpEng.exe", "svchost.exe")
        "taskhost.exe" = @("services.exe", "svchost.exe")
        "taskhostw.exe" = @("services.exe", "svchost.exe")
        "userinit.exe" = @("dwm.exe", "winlogon.exe")
        "wininit.exe" = @("smss.exe")
        "winlogon.exe" = @("smss.exe")
    },

    # They will be matched using regex
    [Parameter(Mandatory=$false)]
    $ExpectedProcessPaths = @{
        "csrss.exe" = "\\Windows\\System32\\csrss\.exe"
        "explorer.exe" = "\\Windows\\explorer\.exe"
        "lsass.exe" = "\\Windows\\System32\\lsass\.exe"
        "lsm.exe" = "\\Windows\\System32\\lsm\.exe"
        "services.exe" = "\\Windows\\System32\\services\.exe"
        "smss.exe" = "\\Windows\\System32\\smss\.exe"
        "svchost.exe" = "\\Windows\\(System32)?(SysWOW64)?\\svchost\.exe"
        "taskhost.exe" = "\\Windows\\System32\\taskhost\.exe"
        "taskhostw.exe" = "\\Windows\\System32\\taskhostw\.exe"
        "wininit.exe" = "\\Windows\\System32\\wininit\.exe"
        "winlogon.exe" = "\\Windows\\System32\\winlogon\.exe"
    },

    [Parameter(Mandatory=$false)]
    $ExpectedProcessInstanceCounts = @{
        "lsaiso.exe" = 1
        "lsass.exe" = 1
        "lsm.exe" = 1
        "services.exe" = 1
        "wininit.exe" = 1
    },

    [Parameter(Mandatory=$false)]
    $ProcessesToSearchSimilarNames = @("csrss.exe", "dllhost.exe", "explorer.exe", "iexplore.exe", "lsass.exe", "sihost.exe", "smss.exe", "svchost.exe", "winlogon.exe"),

    # Directly display not only process names, but also PIDs
    [Parameter(Mandatory=$false)]
    [switch] $VisualPIDs = $true,
    
    # Skips all checks of suspicous entries, making the GUI display much faster
    [Parameter(Mandatory=$false)]
    [switch] $NoSuspiciousChecks
)

[void][System.Reflection.Assembly]::LoadWithPartialName("System.Windows")
[void][System.Reflection.Assembly]::LoadWithPartialName("System.Windows.Forms")
[void][System.Reflection.Assembly]::LoadWithPartialName("System.Drawing")
[void][System.Reflection.Assembly]::LoadWithPartialName("PresentationFramework")
[void][System.Reflection.Assembly]::LoadWithPartialName("PresentationCore")


# querying the entries of the csv file
$csvEntries = @(Import-CSV -Path $CSVPath -Delimiter "`t")


####################################
#region    DOTNET-SHENANIGANS      #
####################################


try {
    [LevenshteinDistance]::new() -as [Type] | Out-Null
} catch {
    Add-Type -Path (Join-Path $PSScriptRoot -ChildPath "..\Measure-DamerauLevenshteinDistance\Measure-DamerauLevenshteinDistance.cs") | Out-Null
}


# Fuse of
# https://docs.microsoft.com/en-us/dotnet/api/system.windows.forms.treeview.treeviewnodesorter
# https://www.dotnetperls.com/alphanumeric-sorting
try {
    [TreeNodeAlphanumComparator] -as [Type] | Out-Null
} catch {
    Add-Type @"
using System;
using System.Collections;
using System.Windows.Forms;
public class TreeNodeAlphanumComparator : IComparer {
    public int Compare(object x, object y) {
        TreeNode tx = x as TreeNode;
        TreeNode ty = y as TreeNode;
        if (tx == null) {
            return 0;
        }
        if (ty == null) {
            return 0;
        }
        string s1 = tx.Text;
        if (s1 == null) {
            return 0;
        }
        string s2 = ty.Text;
        if (s2 == null) {
            return 0;
        }
        
        int len1 = s1.Length;
        int len2 = s2.Length;
        int marker1 = 0;
        int marker2 = 0;
        
        // Walk through two the strings with two markers.
        while (marker1 < len1 && marker2 < len2) {
            char ch1 = s1[marker1];
            char ch2 = s2[marker2];
            
            // Some buffers we can build up characters in for each chunk.
            char[] space1 = new char[len1];
            int loc1 = 0;
            char[] space2 = new char[len2];
            int loc2 = 0;
            
            // Walk through all following characters that are digits or
            // characters in BOTH strings starting at the appropriate marker.
            // Collect char arrays.
            do {
                space1[loc1++] = ch1;
                marker1++;
                
                if (marker1 < len1) {
                    ch1 = s1[marker1];
                } else {
                    break;
                }
            } while (char.IsDigit(ch1) == char.IsDigit(space1[0]));
            
            do {
                space2[loc2++] = ch2;
                marker2++;
                
                if (marker2 < len2) {
                    ch2 = s2[marker2];
                } else {
                    break;
                }
            } while (char.IsDigit(ch2) == char.IsDigit(space2[0]));
            
            // If we have collected numbers, compare them numerically.
            // Otherwise, if we have strings, compare them alphabetically.
            string str1 = new string(space1);
            string str2 = new string(space2);
            
            int result;
            
            if (char.IsDigit(space1[0]) && char.IsDigit(space2[0])) {
                int thisNumericChunk = int.Parse(str1);
                int thatNumericChunk = int.Parse(str2);
                result = thisNumericChunk.CompareTo(thatNumericChunk);
            } else {
                result = str1.CompareTo(str2);
            }
            
            if (result != 0) {
                return result;
            }
        }
        return len1 - len2;
    }
}
"@ -ReferencedAssemblies System.Windows.Forms | Out-Null
}

####################################
#endregion DOTNET-SHENANIGANS      #
####################################


####################################
#region    HELPER FUNCTIONS        #
####################################

# huge thanks to
# https://nasbench.medium.com/demystifying-the-svchost-exe-process-and-its-command-line-options-508e9114e747
# for the great writeup!
function Get-SVCHostData($k, $s) {
    $values = @((Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Svchost\").$k)
    if($s) {
        if($values -contains($s)) {
            return "[$s]"
        } else {
            return "[???]"
        }
    }
    return "[" + ($values -join ", ") + "]"
}

function Is-Match($Text, $SearchText, $SearchMode) {
    if($searchMode -eq 0) { # plaintext
        if($text -and $Text.toLower().Contains($SearchText.toLower())) {
            return $true
        }
    } elseif($searchMode -eq 1) { # extended
        if($Text -like $SearchText) {
            return $true
        }
    } else { # regex
        if($Text -match $SearchText) {
            return $true
        }
    }
    $false
}

function Show-EntryWindow($entry) {
    # create form for displaying the folder tree
    $entryForm = New-Object System.Windows.Forms.Form
    $entryForm.Text = $entry."Process Name" + ": " + $entry.PID + " - Properties"
    $entryForm.Size = New-Object System.Drawing.Size(500, 395)
    $entryForm.Icon = $icon

    $alternateCellStyle = New-Object System.Windows.Forms.DataGridViewCellStyle
    $alternateCellStyle.BackColor = [System.Drawing.SystemColors]::ControlLight
    
    $script:dataGridView = New-Object System.Windows.Forms.DataGridView
    $dataGridView.Name = "EntryPropertiesGridView"
    $dataGridView.AllowUserToAddRows = $false
    $dataGridView.AllowUserToDeleteRows = $false
    $dataGridView.AllowUserToOrderColumns = $false
    $dataGridView.AllowUserToResizeRows = $false
    $dataGridView.ColumnHeadersHeightSizeMode = [System.Windows.Forms.DataGridViewColumnHeadersHeightSizeMode]::DisableResizing
    $dataGridView.RowHeadersVisible = $false
    $dataGridView.ReadOnly = $true
    $dataGridView.ColumnCount = 2
    $dataGridView.Columns[0].Name = "Property"
    $dataGridView.Columns[0].AutoSizeMode = [System.Windows.Forms.DataGridViewAutoSizeColumnMode]::AllCells
    $dataGridView.Columns[1].Name = "Value"
    $dataGridView.Columns[1].AutoSizeMode = [System.Windows.Forms.DataGridViewAutoSizeColumnMode]::Fill
    $dataGridView.AlternatingRowsDefaultCellStyle = $alternateCellStyle
    $dataGridView.SelectionMode = [System.Windows.Forms.DataGridViewSelectionMode]::FullRowSelect
    $dataGridView.Dock = [System.Windows.Forms.DockStyle]::Fill

    $contextMenuStrip = New-Object System.Windows.Forms.ContextMenuStrip
    $contextMenuStrip.Items.Add("Copy highlighted rows").add_Click({
        $sb = New-Object System.Text.StringBuilder
        foreach($row in $dataGridView.SelectedRows) {
            $sb.AppendLine($row.Cells[0].Value + " " + $row.Cells[1].Value)
        }
        [System.Windows.Forms.Clipboard]::SetText($sb.ToString())
    })
    $contextMenuStrip.Items.Add("Copy all rows").add_Click({
        $sb = New-Object System.Text.StringBuilder
        foreach($row in $dataGridView.Rows) {
            $sb.AppendLine($row.Cells[0].Value + " " + $row.Cells[1].Value)
        }
        [System.Windows.Forms.Clipboard]::SetText($sb.ToString())
    })
    $dataGridView.ContextMenuStrip = $contextMenuStrip

    foreach($property in $entry.psobject.Properties) {
        $dataGridView.Rows.Add($property.Name + ":", $property.Value)
    }

    $entryForm.BackColor = [System.Drawing.SystemColors]::ControlLight
    $entryForm.Controls.Add($dataGridView)
    $entryForm.Show()
}

function Note-Suspicious($Node, $Description) {
    if($Node.Tag.Suspicious) {
        $Node.Tag.Suspicious = $Node.Tag.Suspicious + ", " + $Description
    } else {
        $Node.Tag.Suspicious = $Description
    }
    $Node.ForeColor = [System.Drawing.Color]::Red
    $Node.ToolTipText = ($Node.Tag | Out-String).Trim() -replace " *:", ":"
}

function Set-Suspicious($Node, $ParentID, $Description, $ShortId) {
    Note-Suspicious -Node $node -Description $Description
    New-Node -ID $($Node.Tag.PID + "_" + $ShortId) -Text $process."Call Chain" -Tooltip $node.ToolTipText -Parent $ParentID -Tag $Node.Tag
}

####################################
#endregion HELPER FUNCTIONS        #
####################################


####################################
#region    GUI                     #
####################################

# create form for displaying the folder tree
$Form = New-Object System.Windows.Forms.Form
$Form.Text = "MemProcFS-Analyzer - Process Tree"
$Form.Size = New-Object System.Drawing.Size(800, 600)

# the icon (base 64 encoded png, converted and set as icon)
$base64Icon = "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QAAAAAAAD5Q7t/AAAACXBIWXMAAABgAAAAYADwa0LPAAAAxElEQVRIx+3TsWoCQRCA4Y8kNkklnCRVEB/gGh/ZB8gTCJo6zYGtiJ0vYH0pMsJiItzpRBt/WLid5f6Znd3lzq15TPY94wM7bLKLfcESLVZ4uEQ2xiykx/JNrP+i7TAOLGK+xGsXed8E45C12HeRn8M71iHfYpIpL3eyyK78KtT4xFsRG8VuphkJ5n5636CK0URsnpGgFDZH39Wpn/pcUxjiq1j7U37Jc37CoJgPIpbCWS3qw78fch2istoqYnVWm+7k8A1FT08gOQfCGwAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAyMi0wOS0wNVQxMjoyMTozMSswMDowMOTTZSwAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMjItMDktMDVUMTI6MjE6MzErMDA6MDCVjt2QAAAAAElFTkSuQmCC"
$bitmap = New-Object System.Windows.Media.Imaging.BitmapImage
$bitmap.BeginInit()
$bitmap.StreamSource = [System.IO.MemoryStream][System.Convert]::FromBase64String($base64Icon)
$bitmap.EndInit()
$bitmap.Freeze()
$image = [System.Drawing.Bitmap][System.Drawing.Image]::FromStream($bitmap.StreamSource)
$icon = [System.Drawing.Icon]::FromHandle($image.GetHicon())
$Form.Icon = $icon

# the main tree
$TreeView = New-Object System.Windows.Forms.TreeView
$TreeView.Dock = [System.Windows.Forms.DockStyle]::Fill
$TreeView.TreeViewNodeSorter = New-Object -TypeName TreeNodeAlphanumComparator
$TreeView.ShowNodeToolTips = $true
$Form.Controls.Add($TreeView)

# top "search" strip
$MenuStrip = New-Object System.Windows.Forms.MenuStrip
$MenuStrip.ShowItemToolTips = $true
$MenuStrip.Dock = [System.Windows.Forms.DockStyle]::Top

$ExpandButton = New-Object System.Windows.Forms.ToolStripButton
$ExpandButton.Text = "+"
$ExpandButton.ToolTipText = "Expand All"
$ExpandButton.Add_Click({
    $TreeView.ExpandAll()
})

$CollapseButton = New-Object System.Windows.Forms.ToolStripButton
$CollapseButton.Text = "-"
$CollapseButton.ToolTipText = "Collapse All"
$CollapseButton.Add_Click({
    $TreeView.CollapseAll()
})
$ButtonSeparator = New-Object System.Windows.Forms.ToolStripSeparator

# Search
$SearchTextStrip = New-Object System.Windows.Forms.ToolStripStatusLabel
$SearchTextStrip.Text = "Search:"

$SearchBox = New-Object System.Windows.Forms.ToolStripTextBox
$SearchBox.Size = New-Object System.Drawing.Size(250, $SearchBox.Size.Height)
$SearchBox.Add_TextChanged({
    Search-Nodes
})

$SearchTextStrip2 = New-Object System.Windows.Forms.ToolStripStatusLabel
$SearchTextStrip2.Text = "Mode:"

$SearchModeDropDownButton = New-Object System.Windows.Forms.ToolStripDropDownButton
$SearchModeDropDown = New-Object System.Windows.Forms.ToolStripDropDown
[void] $SearchModeDropDown.Items.Add("Plaintext")
[void] $SearchModeDropDown.Items.Add("Extended")
[void] $SearchModeDropDown.Items.Add("RegEx")
$SearchModeDropDownButton.Text = $SearchModeDropDown.Items[0]
$SearchModeDropDownButton.DropDown = $SearchModeDropDown

$SearchModeDropDown.Add_ItemClicked({
    $SearchModeDropDownButton.Text = $_.ClickedItem.Text
    Search-Nodes
})

$SearchTextStrip3 = New-Object System.Windows.Forms.ToolStripStatusLabel
$SearchTextStrip3.Text = "Filter:"

$SearchLocationDropDownButton = New-Object System.Windows.Forms.ToolStripDropDownButton
$SearchLocationDropDown = New-Object System.Windows.Forms.ToolStripDropDown
[void] $SearchLocationDropDown.Items.Add("Everywhere")
[void] $SearchLocationDropDown.Items.Add("Call Chain")
$blacklistedSearchEntries = @("Sub-Processes")
foreach($property in $csvEntries[0].PSObject.Properties | Sort-Object) {
    if($property.Name -notin $blacklistedSearchEntries) {
        [void] $SearchLocationDropDown.Items.Add($property.Name)
    }
}
$SearchLocationDropDownButton.Text = $SearchLocationDropDown.Items[0]
$SearchLocationDropDownButton.DropDown = $SearchLocationDropDown

$SearchLocationDropDown.Add_ItemClicked({
    $SearchLocationDropDownButton.Text = $_.ClickedItem.Text
    Search-Nodes
})

# Dispay Mode Selection
$DisplayModeSeparator = New-Object System.Windows.Forms.ToolStripSeparator
$DisplayModeTextStrip = New-Object System.Windows.Forms.ToolStripStatusLabel
$DisplayModeTextStrip.Text = "Display Mode:"

$DisplayModeDropDown = New-Object System.Windows.Forms.ToolStripDropDown
[void] $DisplayModeDropDown.Items.Add("PID: Name")
[void] $DisplayModeDropDown.Items.Add("Name")

$DisplayModeDropDownButton = New-Object System.Windows.Forms.ToolStripDropDownButton
if($VisualPIDs) {
    $DisplayModeDropDownButton.Text = $DisplayModeDropDown.Items[0]
} else {
    $DisplayModeDropDownButton.Text = $DisplayModeDropDown.Items[1]
}
$DisplayModeDropDownButton.DropDown = $DisplayModeDropDown

$DisplayModeDropDown.Add_ItemClicked({
    $newValue = $_.ClickedItem.Text
    $currentValue = $DisplayModeDropDownButton.Text
    if($newValue -ne $currentValue) {
        $DisplayModeDropDownButton.Text = $newValue
        if($newValue -eq "PID: Name") {
            $VisualPIDs = $true
        } else {
            $VisualPIDs = $false
        }

        Fill-GUIData
    }
})

$MenuStrip.Items.AddRange($ExpandButton)
$MenuStrip.Items.AddRange($CollapseButton)
$MenuStrip.Items.AddRange($ButtonSeparator)

$MenuStrip.Items.AddRange($SearchTextStrip)
$MenuStrip.Items.AddRange($SearchBox)
$MenuStrip.Items.AddRange($SearchTextStrip2)
$MenuStrip.Items.AddRange($SearchModeDropDownButton)
$MenuStrip.Items.AddRange($SearchTextStrip3)
$MenuStrip.Items.AddRange($SearchLocationDropDownButton)

$MenuStrip.Items.AddRange($DisplayModeSeparator)
$MenuStrip.Items.AddRange($DisplayModeTextStrip)
$MenuStrip.Items.AddRange($DisplayModeDropDownButton)
$Form.Controls.Add($MenuStrip)

# bottom "statistics" strip
$StatusStrip = New-Object System.Windows.Forms.StatusStrip
$StatusStrip.Dock = [System.Windows.Forms.DockStyle]::Bottom
$StatusStrip.LayoutStyle = [System.Windows.Forms.ToolStripLayoutStyle]::HorizontalStackWithOverflow

# text block that lists the count of found elements in the bottom strip
$ElementCountLabel = New-Object System.Windows.Forms.ToolStripStatusLabel

$OSStartLabel = New-Object System.Windows.Forms.ToolStripStatusLabel
$OSStartLabel.Alignment = [System.Windows.Forms.ToolStripItemAlignment]::Right
$OSStartLabel.BorderStyle = [System.Windows.Forms.Border3DStyle]::Raised

$StatusStrip.Items.AddRange($ElementCountLabel)
$StatusStrip.Items.AddRange($OSStartLabel)
$Form.Controls.Add($StatusStrip)

####################################
#endregion GUI                     #
####################################


####################################
#region    DISPLAY                 #
####################################

$script:dataInitialised = $false

function Search-Nodes {
    $expandSet = [System.Collections.Generic.HashSet[System.Windows.Forms.TreeNode]]@()

    # iterate through all nodes in the treeview
    # and expand / collapse them according to the search
    $searchText = $SearchBox.Text
    $clear = $searchtext -eq ""
    $searchLocation = $SearchLocationDropDownButton.Text

    # Map search mode to an int (faster than string compare every time)
    # ideally use an enum here, but that's a newer PS feature
    [int] $searchMode = 0
    switch ($SearchModeDropDownButton.Text) {
        'PlainText' { $searchMode = 0}
        'Extended' { $searchMode = 1 }
        Default { # regex
            $searchMode = 2
            try {
                [regex] $searchText
            } catch {
                # current serach text is not valid regex
                return
            }
        }
    }

    $TreeView.BeginUpdate() # do not redraw the tree view everytime a property changes
   
    $queue = New-Object System.Collections.Queue
    foreach($node in $TreeView.Nodes) {
        $queue.Enqueue($node)
    }

    while($queue.Count -gt 0) {
        $node = $queue.Dequeue()
        foreach($childNode in $node.Nodes) {
            $queue.Enqueue($childNode)
        }

        $node.Collapse()
        $node.BackColor = [System.Drawing.Color]::Transparent

        if(!$clear) {
            $element = $node.Tag
            $match = $false
            if($null -eq $element) {
                # node without element. Never matches
            } if($searchLocation -eq "Everywhere") {
                foreach($property in $element.PSObject.Properties) {
                    if($property.Name -eq "Call Chain") {
                        continue
                    }
                    if(Is-Match -Text $property.Value -SearchText $searchText -SearchMode $searchMode) {
                        $match = $true
                        break
                    }
                }
            } else {
                $match = Is-Match -Text $element.$searchLocation -SearchText $searchText -SearchMode $searchMode
            }

            if($match) {
                $node.BackColor = [System.Drawing.Color]::Yellow

                # note this node and all of it's parents to expand later
                $currentNode = $node
                do {
                    $expandSet.Add($currentNode)
                    $currentNode = $currentNode.Parent
                } while ($null -ne $currentNode)
            }
        }
    }

    foreach($expandEntry in $expandSet) {
        $expandEntry.expand()
    }
    $TreeView.EndUpdate()
}

function New-Node($ID, $Text, $Tooltip, $Parent, $Tag, [switch] $AddToMap) {
    $newNode = New-Object System.Windows.Forms.TreeNode
    $newNode.Name = $ID
    $newNode.Text = if($Text) { $Text } else { "<unknown>" }
    $newNode.ToolTipText = $Tooltip
    if($AddToMap) {
        $nodesMap[$ID] = $newNode
    }
    if($Tag) {
        $newNode.Tag = $Tag
    }
    if($Parent) {
        [void] $nodesMap[$Parent].Nodes.Add($newNode)
    } else {
        [void] $TreeView.Nodes.Add($newNode)
    }
}

function Set-Nodes($Root, $Depth, $Collapsed) {
    $TreeView.BeginUpdate() # do not redraw the tree view everytime a property changes
    $queue = New-Object System.Collections.Queue
    $queue.Enqueue([Tuple]::Create($Root, 0))

    while($queue.Count -gt 0) {
        $entry = $queue.Dequeue()
        $node = $entry.Item1
        $currentDepth = $entry.Item2

        if($currentDepth -lt $Depth) {
            foreach($childNode in $node.Nodes) {
                $queue.Enqueue([Tuple]::Create($childNode, $currentDepth + 1))
            }
        }

        if($collapsed) {
            $node.Collapse()
        } else {
            $node.Expand()
        }
   }
   $TreeView.EndUpdate()
}

<#
    In the tree view, we want nodes that are double clicked on, to show a properties view popup.
    Since by default, tree nodes have an event mapped to double click already (namely expanding / collapsing the node),
    we have to check if it's a double click in BeforeExpand() and BeforeCollapse() and cancel this default behavior
    so it does not interfere with the opening of our new properties window
    The user is still able to nagigate the tree via keyboard, or as usual, by using the +/- buttons on each node
#>
$script:CancelNodeExpanding = $false

function Fill-GUIData {
    $TreeView.BeginUpdate()
    $TreeView.Nodes.Clear()
    $TreeView.Add_KeyDown({
        # Ctrl+C override
        # If there is a better event handler please enlighten me
        # it makes the annoying "warning" sound, for whatever reason
        if($_.Control -and $_.KeyCode -eq "C") {
            $node = $TreeView.SelectedNode
            if($node -and $node.TooltipText) {
                [System.Windows.Forms.Clipboard]::SetDataObject($node.TooltipText)
            }
        }
    })
    $TreeView.Add_MouseDown({
        $script:CancelNodeExpanding = $_.Clicks -gt 1
    })
    $TreeView.Add_BeforeExpand({
        $_.Cancel = $script:CancelNodeExpanding
    })
    $TreeView.Add_BeforeCollapse({
        $_.Cancel = $script:CancelNodeExpanding
    })
    
    $TreeView.Add_NodeMouseDoubleClick({
        if($_.Node.Tag) {
            if(-not $_.Node.IsExpanded) {
                $_.Node.Expand()
            } else {
                $_.Node.Collapse();
            }

            Show-EntryWindow($_.Node.Tag)
            return $false
        }
    })
    $nodesMap = @{}
    
    $TotalProcesses = ($csvEntries).Count
    $RunningProcesses = ($csvEntries | Where-Object { $_."Exit Time" -eq "" }).Count
    $ExitedProcesses = ($csvEntries | Where-Object { $_."Exit Time" -ne "" }).Count
    $ElementCountLabel.Text = "Total Processes: $TotalProcesses | Running Processes: $RunningProcesses | Exited Processes: $ExitedProcesses"

    # a list of dedicated (root) nodes for special case handling
    $orphanID = $((New-Guid).Guid)
    New-Node -ID $orphanID -Text "Orphan Processes" -Tooltip "Processes where parent processes could not be found anymore" -AddToMap

    $notableID = $((New-Guid).Guid)
    New-Node -ID $notableID -Text "Alert Messages" -Tooltip "Common low hanging fruits" -AddToMap

    # LP_Windows Processes Suspicious Parent Directory Detected
    # Trigger Condition: Suspicious parent processes of Windows processes are detected.
    # ATT&CK Category: Defense Evasion
    # ATT&CK Tag: Masquerading
    $unusualRelationShipsID = $((New-Guid).Guid)
    New-Node -ID $unusualRelationShipsID -Text "Suspicious Parent-Child Relationships [T1036]" -Tooltip "Processes called from an unusual parent process" -Parent $notableID -AddToMap

    $scriptInterpretersID = $((New-Guid).Guid)
    New-Node -ID $scriptInterpretersID -Text "Command and Scripting Interpreters [T1059]" -Tooltip "CMD, Python, VB, Powershell, you name it" -Parent $notableID -AddToMap

    $suspiciousFoldersID = $((New-Guid).Guid)
    New-Node -ID $suspiciousFoldersID -Text "Suspicious Process File Path [T1543]" -Tooltip "Process Execution from an Unusual Directory" -Parent $notableID -AddToMap

    $lateralMovementProgramsID = $((New-Guid).Guid)
    New-Node -ID $lateralMovementProgramsID -Text "Lateral Movement Tools [TA0008]" -Tooltip "Process Execution from an Unusual Directory" -Parent $notableID -AddToMap

    $suspiciousProgramsID = $((New-Guid).Guid)
    New-Node -ID $suspiciousProgramsID -Text "Suspicious Program Execution [T1218, T1127.001, T1087.002]" -Tooltip "All kinds of suspicious Programs, usually used for Discovery, Privilege Escalation to Proxy Execution" -Parent $notableID -AddToMap

    $doubleFileExtensionsID = $((New-Guid).Guid)
    New-Node -ID $doubleFileExtensionsID -Text "Double File Extensions [T1036.007]" -Tooltip "Processes spawned from execuables using a double file extension, most often in a way to deceive users to execute malicious payloads, like 'invoice.doc.exe'" -Parent $notableID -AddToMap

    $suspiciousParametersID = $((New-Guid).Guid)
    New-Node -ID $suspiciousParametersID -Text "Suspicious Command Line Parameters" -Tooltip "Command Line Parameters that are oftentimes used my malware" -Parent $notableID -AddToMap

    $expectedRelationshipDiscrepancyID = $((New-Guid).Guid)
    New-Node -ID $expectedRelationshipDiscrepancyID -Text "Processes with different Parent than usual [T1036.005]" -Tooltip "The process loading chain of system processes is mostly fixed, like lsass.exe always getting started via wininit.exe. Are there discrepancies, chances are they got started for means of process injection, or by giving a malicious payload the same name as a known good process, but in a different path." -Parent $notableID -AddToMap
    
    $expectedProcessPathDiscrepancyID = $((New-Guid).Guid)
    New-Node -ID $expectedProcessPathDiscrepancyID -Text "Known Process Names in different Path [T1036.005]" -Tooltip "System processes have a dedicated path where their executables are stored (such as in %windir%). If a process with a well known name runs in a different folder, chances are it is malicious and the name was chosen to fly under the radar" -Parent $notableID -AddToMap
    
    $expectedProcessInstanceDiscrepancyID = $((New-Guid).Guid)
    New-Node -ID $expectedProcessInstanceDiscrepancyID -Text "Process instance count mismatch [T1036.005]" -Tooltip "Lots of system processes have a fixed number of instances runnung simultaneously - most often 1. If there are more, chances are they got started for means of process injection, or by giving a malicious payload the same name as a known good process, but in a different path." -Parent $notableID -AddToMap
    
    $ProcessNameMasqueradingID = $((New-Guid).Guid)
    New-Node -ID $ProcessNameMasqueradingID -Text "Process Name Masquerading [T1036.005]" -Tooltip "Attackers name their payloads similar to known system processes to avoid detection. Something like 'lsaas.exe' closely resembles the legitimate 'lsass.exe' on first glance." -Parent $notableID -AddToMap

    $runningInUNCNetworkPathID = $((New-Guid).Guid)
    New-Node -ID $runningInUNCNetworkPathID -Text "Processes running from UNC Network Paths" -Tooltip "Processes running in UNC paths can hint to remote execution through file shares without having to copy malicious files to the local system" -Parent $notableID -AddToMap

    # create nodes, but not attach them yet. It will make parent search possible.
    foreach ($csvEntry in $csvEntries) {
        # Add a "Suspicious" attribute
        Add-Member -InputObject $csvEntry -MemberType NoteProperty -Name "Suspicious" -Value ""

        $newNode = New-Object System.Windows.Forms.TreeNode
        if($VisualPIDs) {
            $newNode.Text = $(if($csvEntry.PID) { $csvEntry.PID } else { "???" }) + ": " + $(if($csvEntry."Process Name") { $csvEntry."Process Name" } else { "<unknown>" })
        } else {
            $newNode.Text = if($csvEntry."Process Name") { $csvEntry."Process Name" } else { "<unknown>" }
        }

        # custom handling for svchost.exe
        # add command line parameters to displayed node
        if($csvEntry."Process Name" -eq "svchost.exe") {
            $newText = $newNode.Text
            $svcHostS = $null
            $svcHostK = $null
            if($csvEntry.CommandLine -match "-s (\w+)") {
                $svcHostS = $Matches[0] -replace "-s ", ""
            }
            if($csvEntry.CommandLine -match "-k (\w+)") {
                $svcHostK = $Matches[0] -replace "-k ", ""
            }
            if($svcHostK) {
                $newNode.Text = $newText + " " + (Get-SVCHostData -K $svcHostK -S $svcHostS)
            }
        }

        $newNode.Name = $csvEntry.PID
        $newNode.Tag = $csvEntry
        $newNode.ToolTipText = ($csvEntry | Out-String).Trim() -replace " *:", ":"
        $nodesMap[$csvEntry.PID] = $newNode
    }

    # iterate all nodes and attach each node to its parent
    foreach ($entry in $nodesMap.GetEnumerator()) {
        # skip nodes without tag (root tags)
        if($null -eq $entry.Value.Tag) {
            continue
        }
    
        $currPID = $entry.Key
        $currNode = $entry.Value
        $currProcess = $entry.Value.Tag
    
        # PID 4 is the known PID of the system process
        # this is where the system started up. Note startup time in the entry
        # this entry will be used as root, therefore it does not need
        # to get attached to an other element
        if ($currProcess.PID -eq 4) {
            $OSStartLabel.Text = "Windows Start: " + $currProcess."Create Time"
            [void] $TreeView.Nodes.Add($nodesMap[$currPID])
            continue
        }

        # entries who PPID does not exist get attached to the ORPHANS node instead
        $parentNode = $nodesMap[$currProcess.PPID]
        if ($null -eq $parentNode) {
            $parentNode = $orphanNode
            $currProcess.Suspicious = "Orphaned"
        }
    
        # attach this node to the element with matching PID => PPID
        $cyclicalPIDRelationship = $false
        $cyclicalParent = $false
        $PIDTreeList = New-Object System.Collections.ArrayList

        $checkProcess = $currProcess
        $checkNode = $currNode
        $orphanNode = $nodesMap[$orphanID]
        Write-Verbose "Starting with $($checkProcess.PID)"
        while($checkProcess) {
            if($checkNode.Parent -eq $orphanNode) {
                Write-Verbose ".......PID $($checkProcess.PID) is already known having a cyclical PID relationship. Aborting."
                $cyclicalParent = $true
                break
            }
            [void] $PIDTreeList.Add($checkProcess.PID)
            $checkNode = $nodesMap[$checkProcess.PPID]
            $checkProcess = $checkNode.Tag
            Write-Verbose "...checking $($checkProcess.PID) (Tree: $($PIDTreeList))"
            if($PIDTreeList.Contains($checkProcess.PID)) {
                Write-Verbose "......cyclical pid<=>ppid relationship found: PID $($checkProcess.PID)"
                $cyclicalPIDRelationship = $true
                break
            }
        }

        if($cyclicalPIDRelationship) {
            if(-not $orphanNode.Nodes.Contains($checkNode)) {
                Note-Suspicious -Node $checkNode -Description "Cyclical PID Relationship (Process with PID $($checkProcess.PPID) is a child process of this)"
                [void] $orphanNode.Nodes.Add($checkNode)
            }
        }

        if($cyclicalParent -and $checkProcess -eq $currProcess) {
            Write-Verbose "NOT ADDING $($currProcess.PID) to node with PID $($nodesMap[$currProcess.PPID].Tag.PID) - currently already: $($nodesMap[$currProcess.PPID].Nodes.Tag.PID)"
        } else {
            Write-Verbose "Adding $($currProcess.PID) to node with PID $($nodesMap[$currProcess.PPID].Tag.PID) - currently already: $($nodesMap[$currProcess.PPID].Nodes.Tag.PID)"
            [void] $parentNode.Nodes.Add($currNode)
        }
    }

    # one last iteration: add a full path property to all nodes
    foreach ($node in @($nodesMap.Values)) {
        $process = $node.Tag
        if($null -ne $process) {        
            # Add a "Call Chain" attribute
            $processTree = $node.Text
            $currentNode = $node
            while($null -ne $currentNode.Parent -and $null -ne $currentNode.Parent.Tag) {
                $parentNode = $currentNode.Parent
                [string]$processTree = $parentNode.Tag.'Process Name' + " → " + $processTree
                $currentNode = $parentNode
            }

            if($script:dataInitialised) {
                $process."Call Chain" = $processTree
            } else {
                Add-Member -InputObject $process -MemberType NoteProperty -Name "Call Chain" -Value $processTree
            }

            $node.ToolTipText = ($process | Out-String).Trim() -replace " *:", ":"
        }

        if(-not $NoSuspiciousChecks) {
            # enumerate each process and search if they match any notable criteria
            # script interpreters
            if($null -ne $process.'Process Name') {
                # script interpreters
                if ($process.'Process Name' -in $scriptInterpreters) {
                    Set-Suspicious -Node $node -ParentID $scriptInterpretersID -Description "Script Interpreter" -ShortId "in"
                }

                # lateral movement programs
                if($process.'Process Name' -in $LateralMovementPrograms) {
                    Set-Suspicious -Node $node -ParentID $lateralMovementProgramsID -Description "Lateral Movement Program" -ShortId "lm"
                }

                # suspicious programs
                if($process.'Process Name' -in $SuspiciousPrograms) {
                    Set-Suspicious -Node $node -ParentID $suspiciousProgramsID -Description "Suspicious Program" -ShortId "sp"
                }

                # double file extensions
                if($process.'Process Name') {
                    $dotCount = ($process.'Process Name'.ToCharArray() | Where-Object {$_ -eq '.'} | Measure-Object).Count
                    if($dotCount -gt 1) {
                        Set-Suspicious -Node $node -ParentID $doubleFileExtensionsID -Description "Double File Extension" -ShortId "dfe"
                    }
                }

                # suspicious parameters
                if($process.CommandLine) {
                    foreach($suspiciousParameter in $SuspiciousParameters) {
                        if($process.'Process Name' -like $suspiciousParameter.Item1 -and $process.CommandLine -like $suspiciousParameter.Item2) {
                            Set-Suspicious -Node $node -ParentID $suspiciousParametersID -Description "Suspicious Command Line Parameters" -ShortId "sparam"
                        }
                    }
                }

                # known good processes but with unusual parent
                if($ExpectedRelationships.ContainsKey($process.'Process Name')) {
                    $acceptableParents = $ExpectedRelationships[$process.'Process Name']
                    $parentProcessNode = $nodesMap[$process.PPID]
                    if($null -ne $parentProcessNode -and $null -ne $parentProcessNode.Tag) {
                        if($parentProcessNode.Tag.'Process Name' -notin $acceptableParents) {
                            Set-Suspicious -Node $node -ParentID $expectedRelationshipDiscrepancyID -Description $("Parent process mismatch. Should match one of: " + $acceptableParents -join ", ") -ShortId "accp"
                        }
                    }
                }

                # check the number of running instances with the same process name.
                # does the found count match the expected count?
                if($ExpectedProcessInstanceCounts.ContainsKey($process.'Process Name')) {
                    $expectedInstances = $ExpectedProcessInstanceCounts[$process.'Process Name']
                    [int] $runningInstances = 0 # the upcoming loop also counts this instance, so we start at 0 instead of 1
                    foreach($mapNode in $nodesMap.Values) {
                        if($null -ne $mapNode.Tag -and $process.'Process Name' -eq $mapNode.Tag.'Process Name') {
                            $runningInstances++
                        }
                    }
                    if($expectedInstances -ne $runningInstances) {
                        Set-Suspicious -Node $node -ParentID $expectedProcessInstanceDiscrepancyID -Description $("Found " + $runningInstances + " running instances instead of the expected " + $expectedInstances) -ShortId "eicm"
                    }
                }

                # check if this process name is typed very similar than known good ones
                foreach($similarName in $ProcessesToSearchSimilarNames) {
                    [int] $distance = [LevenshteinDistance]::Measure($process.'Process Name', $similarName)
                    if($distance -eq 1) {
                        Set-Suspicious -Node $node -ParentID $ProcessNameMasqueradingID -Description $("Name " + $process.'Process Name' + " is very similar to known " + $similarName) -ShortId "pnm"
                    }
                }
            }

            if($null -ne $process.'File Path') {
                # unusual file locations
                foreach($suspiciousFolder in $suspiciousFolders) {
                    if($process.'File Path' -like $suspiciousFolder) {
                        Set-Suspicious -Node $node -ParentID $suspiciousFoldersID -Description "Running in Suspicious Folder" -ShortId "sf"
                        break
                    }
                }
        
                # unusual parent <=> child relationship
                if($node.Tag.PID -and $nodesMap.ContainsKey($node.Tag.PID)) {
                    $parentNode = $nodesMap[$node.Tag.PID]
                    if($null -ne $parentNode -and $null -ne $parentNode.Tag -and $null -ne $parentNode.Tag.'Process Name') {
                        $parentProcess = $parent.Tag
                        foreach($unusualRelationShip in $unusualRelationShips) {
                            if($parentProcess.'Process Name' -like $unusualRelationShip.Item1 -and $process.'File Path' -like $unusualRelationShip.Item2) {
                                Set-Suspicious -Node $node -ParentID $unusualRelationShipsID -Description "Unusual Parent<=>Child Relationship" -ShortId "ur"
                                break
                            }
                        }
                    }
                }

                # known good programs, but in unusual path
                if($null -ne $process.'Process Name' -and $ExpectedProcessPaths.ContainsKey($process.'Process Name')) {
                    $knownPath = $ExpectedProcessPaths[$process.'Process Name']
                    if($process.'Device Path' -notmatch $knownPath) {
                        Set-Suspicious -Node $node -ParentID $expectedProcessPathDiscrepancyID -Description $("Process Path mismatch. Should match: '" + $knownPath + "'") -ShortId "kppm"
                    }
                }

                # running in unc path
                if($process.'File Path'.StartsWith("\\")) {
                    Set-Suspicious -Node $node -ParentID $runningInUNCNetworkPathID -Description $("Running in UNC network path") -ShortId "unc"
                }

            }
        }

    }

    $TreeView.Sort()

    $systemNode = $nodesMap["4"]
    if($systemNode) {
        Set-Nodes -Root $systemNode -Depth 3 -Collapsed $false
    }

    $TreeView.EndUpdate()

    $script:dataInitialised = $true
}


####################################
#endregion DISPLAY                 #
####################################

Fill-GUIData

$Form.Add_Shown( { $Form.Activate() })
[system.windows.forms.application]::run($Form)

# SIG # Begin signature block
# MIIrywYJKoZIhvcNAQcCoIIrvDCCK7gCAQExCzAJBgUrDgMCGgUAMGkGCisGAQQB
# gjcCAQSgWzBZMDQGCisGAQQBgjcCAR4wJgIDAQAABBAfzDtgWUsITrck0sYpfvNR
# AgEAAgEAAgEAAgEAAgEAMCEwCQYFKw4DAhoFAAQUUCu8zWVKXUIA1uCCB+zhICIq
# ZZOggiUEMIIFbzCCBFegAwIBAgIQSPyTtGBVlI02p8mKidaUFjANBgkqhkiG9w0B
# AQwFADB7MQswCQYDVQQGEwJHQjEbMBkGA1UECAwSR3JlYXRlciBNYW5jaGVzdGVy
# MRAwDgYDVQQHDAdTYWxmb3JkMRowGAYDVQQKDBFDb21vZG8gQ0EgTGltaXRlZDEh
# MB8GA1UEAwwYQUFBIENlcnRpZmljYXRlIFNlcnZpY2VzMB4XDTIxMDUyNTAwMDAw
# MFoXDTI4MTIzMTIzNTk1OVowVjELMAkGA1UEBhMCR0IxGDAWBgNVBAoTD1NlY3Rp
# Z28gTGltaXRlZDEtMCsGA1UEAxMkU2VjdGlnbyBQdWJsaWMgQ29kZSBTaWduaW5n
# IFJvb3QgUjQ2MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAjeeUEiIE
# JHQu/xYjApKKtq42haxH1CORKz7cfeIxoFFvrISR41KKteKW3tCHYySJiv/vEpM7
# fbu2ir29BX8nm2tl06UMabG8STma8W1uquSggyfamg0rUOlLW7O4ZDakfko9qXGr
# YbNzszwLDO/bM1flvjQ345cbXf0fEj2CA3bm+z9m0pQxafptszSswXp43JJQ8mTH
# qi0Eq8Nq6uAvp6fcbtfo/9ohq0C/ue4NnsbZnpnvxt4fqQx2sycgoda6/YDnAdLv
# 64IplXCN/7sVz/7RDzaiLk8ykHRGa0c1E3cFM09jLrgt4b9lpwRrGNhx+swI8m2J
# mRCxrds+LOSqGLDGBwF1Z95t6WNjHjZ/aYm+qkU+blpfj6Fby50whjDoA7NAxg0P
# OM1nqFOI+rgwZfpvx+cdsYN0aT6sxGg7seZnM5q2COCABUhA7vaCZEao9XOwBpXy
# bGWfv1VbHJxXGsd4RnxwqpQbghesh+m2yQ6BHEDWFhcp/FycGCvqRfXvvdVnTyhe
# Be6QTHrnxvTQ/PrNPjJGEyA2igTqt6oHRpwNkzoJZplYXCmjuQymMDg80EY2NXyc
# uu7D1fkKdvp+BRtAypI16dV60bV/AK6pkKrFfwGcELEW/MxuGNxvYv6mUKe4e7id
# FT/+IAx1yCJaE5UZkADpGtXChvHjjuxf9OUCAwEAAaOCARIwggEOMB8GA1UdIwQY
# MBaAFKARCiM+lvEH7OKvKe+CpX/QMKS0MB0GA1UdDgQWBBQy65Ka/zWWSC8oQEJw
# IDaRXBeF5jAOBgNVHQ8BAf8EBAMCAYYwDwYDVR0TAQH/BAUwAwEB/zATBgNVHSUE
# DDAKBggrBgEFBQcDAzAbBgNVHSAEFDASMAYGBFUdIAAwCAYGZ4EMAQQBMEMGA1Ud
# HwQ8MDowOKA2oDSGMmh0dHA6Ly9jcmwuY29tb2RvY2EuY29tL0FBQUNlcnRpZmlj
# YXRlU2VydmljZXMuY3JsMDQGCCsGAQUFBwEBBCgwJjAkBggrBgEFBQcwAYYYaHR0
# cDovL29jc3AuY29tb2RvY2EuY29tMA0GCSqGSIb3DQEBDAUAA4IBAQASv6Hvi3Sa
# mES4aUa1qyQKDKSKZ7g6gb9Fin1SB6iNH04hhTmja14tIIa/ELiueTtTzbT72ES+
# BtlcY2fUQBaHRIZyKtYyFfUSg8L54V0RQGf2QidyxSPiAjgaTCDi2wH3zUZPJqJ8
# ZsBRNraJAlTH/Fj7bADu/pimLpWhDFMpH2/YGaZPnvesCepdgsaLr4CnvYFIUoQx
# 2jLsFeSmTD1sOXPUC4U5IOCFGmjhp0g4qdE2JXfBjRkWxYhMZn0vY86Y6GnfrDyo
# XZ3JHFuu2PMvdM+4fvbXg50RlmKarkUT2n/cR/vfw1Kf5gZV6Z2M8jpiUbzsJA8p
# 1FiAhORFe1rYMIIGFDCCA/ygAwIBAgIQeiOu2lNplg+RyD5c9MfjPzANBgkqhkiG
# 9w0BAQwFADBXMQswCQYDVQQGEwJHQjEYMBYGA1UEChMPU2VjdGlnbyBMaW1pdGVk
# MS4wLAYDVQQDEyVTZWN0aWdvIFB1YmxpYyBUaW1lIFN0YW1waW5nIFJvb3QgUjQ2
# MB4XDTIxMDMyMjAwMDAwMFoXDTM2MDMyMTIzNTk1OVowVTELMAkGA1UEBhMCR0Ix
# GDAWBgNVBAoTD1NlY3RpZ28gTGltaXRlZDEsMCoGA1UEAxMjU2VjdGlnbyBQdWJs
# aWMgVGltZSBTdGFtcGluZyBDQSBSMzYwggGiMA0GCSqGSIb3DQEBAQUAA4IBjwAw
# ggGKAoIBgQDNmNhDQatugivs9jN+JjTkiYzT7yISgFQ+7yavjA6Bg+OiIjPm/N/t
# 3nC7wYUrUlY3mFyI32t2o6Ft3EtxJXCc5MmZQZ8AxCbh5c6WzeJDB9qkQVa46xiY
# Epc81KnBkAWgsaXnLURoYZzksHIzzCNxtIXnb9njZholGw9djnjkTdAA83abEOHQ
# 4ujOGIaBhPXG2NdV8TNgFWZ9BojlAvflxNMCOwkCnzlH4oCw5+4v1nssWeN1y4+R
# laOywwRMUi54fr2vFsU5QPrgb6tSjvEUh1EC4M29YGy/SIYM8ZpHadmVjbi3Pl8h
# JiTWw9jiCKv31pcAaeijS9fc6R7DgyyLIGflmdQMwrNRxCulVq8ZpysiSYNi79tw
# 5RHWZUEhnRfs/hsp/fwkXsynu1jcsUX+HuG8FLa2BNheUPtOcgw+vHJcJ8HnJCrc
# UWhdFczf8O+pDiyGhVYX+bDDP3GhGS7TmKmGnbZ9N+MpEhWmbiAVPbgkqykSkzyY
# Vr15OApZYK8CAwEAAaOCAVwwggFYMB8GA1UdIwQYMBaAFPZ3at0//QET/xahbIIC
# L9AKPRQlMB0GA1UdDgQWBBRfWO1MMXqiYUKNUoC6s2GXGaIymzAOBgNVHQ8BAf8E
# BAMCAYYwEgYDVR0TAQH/BAgwBgEB/wIBADATBgNVHSUEDDAKBggrBgEFBQcDCDAR
# BgNVHSAECjAIMAYGBFUdIAAwTAYDVR0fBEUwQzBBoD+gPYY7aHR0cDovL2NybC5z
# ZWN0aWdvLmNvbS9TZWN0aWdvUHVibGljVGltZVN0YW1waW5nUm9vdFI0Ni5jcmww
# fAYIKwYBBQUHAQEEcDBuMEcGCCsGAQUFBzAChjtodHRwOi8vY3J0LnNlY3RpZ28u
# Y29tL1NlY3RpZ29QdWJsaWNUaW1lU3RhbXBpbmdSb290UjQ2LnA3YzAjBggrBgEF
# BQcwAYYXaHR0cDovL29jc3Auc2VjdGlnby5jb20wDQYJKoZIhvcNAQEMBQADggIB
# ABLXeyCtDjVYDJ6BHSVY/UwtZ3Svx2ImIfZVVGnGoUaGdltoX4hDskBMZx5NY5L6
# SCcwDMZhHOmbyMhyOVJDwm1yrKYqGDHWzpwVkFJ+996jKKAXyIIaUf5JVKjccev3
# w16mNIUlNTkpJEor7edVJZiRJVCAmWAaHcw9zP0hY3gj+fWp8MbOocI9Zn78xvm9
# XKGBp6rEs9sEiq/pwzvg2/KjXE2yWUQIkms6+yslCRqNXPjEnBnxuUB1fm6bPAV+
# Tsr/Qrd+mOCJemo06ldon4pJFbQd0TQVIMLv5koklInHvyaf6vATJP4DfPtKzSBP
# kKlOtyaFTAjD2Nu+di5hErEVVaMqSVbfPzd6kNXOhYm23EWm6N2s2ZHCHVhlUgHa
# C4ACMRCgXjYfQEDtYEK54dUwPJXV7icz0rgCzs9VI29DwsjVZFpO4ZIVR33LwXyP
# DbYFkLqYmgHjR3tKVkhh9qKV2WCmBuC27pIOx6TYvyqiYbntinmpOqh/QPAnhDge
# xKG9GX/n1PggkGi9HCapZp8fRwg8RftwS21Ln61euBG0yONM6noD2XQPrFwpm3Gc
# uqJMf0o8LLrFkSLRQNwxPDDkWXhW+gZswbaiie5fd/W2ygcto78XCSPfFWveUOSZ
# 5SqK95tBO8aTHmEa4lpJVD7HrTEn9jb1EGvxOb1cnn0CMIIGGjCCBAKgAwIBAgIQ
# Yh1tDFIBnjuQeRUgiSEcCjANBgkqhkiG9w0BAQwFADBWMQswCQYDVQQGEwJHQjEY
# MBYGA1UEChMPU2VjdGlnbyBMaW1pdGVkMS0wKwYDVQQDEyRTZWN0aWdvIFB1Ymxp
# YyBDb2RlIFNpZ25pbmcgUm9vdCBSNDYwHhcNMjEwMzIyMDAwMDAwWhcNMzYwMzIx
# MjM1OTU5WjBUMQswCQYDVQQGEwJHQjEYMBYGA1UEChMPU2VjdGlnbyBMaW1pdGVk
# MSswKQYDVQQDEyJTZWN0aWdvIFB1YmxpYyBDb2RlIFNpZ25pbmcgQ0EgUjM2MIIB
# ojANBgkqhkiG9w0BAQEFAAOCAY8AMIIBigKCAYEAmyudU/o1P45gBkNqwM/1f/bI
# U1MYyM7TbH78WAeVF3llMwsRHgBGRmxDeEDIArCS2VCoVk4Y/8j6stIkmYV5Gej4
# NgNjVQ4BYoDjGMwdjioXan1hlaGFt4Wk9vT0k2oWJMJjL9G//N523hAm4jF4UjrW
# 2pvv9+hdPX8tbbAfI3v0VdJiJPFy/7XwiunD7mBxNtecM6ytIdUlh08T2z7mJEXZ
# D9OWcJkZk5wDuf2q52PN43jc4T9OkoXZ0arWZVeffvMr/iiIROSCzKoDmWABDRzV
# /UiQ5vqsaeFaqQdzFf4ed8peNWh1OaZXnYvZQgWx/SXiJDRSAolRzZEZquE6cbcH
# 747FHncs/Kzcn0Ccv2jrOW+LPmnOyB+tAfiWu01TPhCr9VrkxsHC5qFNxaThTG5j
# 4/Kc+ODD2dX/fmBECELcvzUHf9shoFvrn35XGf2RPaNTO2uSZ6n9otv7jElspkfK
# 9qEATHZcodp+R4q2OIypxR//YEb3fkDn3UayWW9bAgMBAAGjggFkMIIBYDAfBgNV
# HSMEGDAWgBQy65Ka/zWWSC8oQEJwIDaRXBeF5jAdBgNVHQ4EFgQUDyrLIIcouOxv
# SK4rVKYpqhekzQwwDgYDVR0PAQH/BAQDAgGGMBIGA1UdEwEB/wQIMAYBAf8CAQAw
# EwYDVR0lBAwwCgYIKwYBBQUHAwMwGwYDVR0gBBQwEjAGBgRVHSAAMAgGBmeBDAEE
# ATBLBgNVHR8ERDBCMECgPqA8hjpodHRwOi8vY3JsLnNlY3RpZ28uY29tL1NlY3Rp
# Z29QdWJsaWNDb2RlU2lnbmluZ1Jvb3RSNDYuY3JsMHsGCCsGAQUFBwEBBG8wbTBG
# BggrBgEFBQcwAoY6aHR0cDovL2NydC5zZWN0aWdvLmNvbS9TZWN0aWdvUHVibGlj
# Q29kZVNpZ25pbmdSb290UjQ2LnA3YzAjBggrBgEFBQcwAYYXaHR0cDovL29jc3Au
# c2VjdGlnby5jb20wDQYJKoZIhvcNAQEMBQADggIBAAb/guF3YzZue6EVIJsT/wT+
# mHVEYcNWlXHRkT+FoetAQLHI1uBy/YXKZDk8+Y1LoNqHrp22AKMGxQtgCivnDHFy
# AQ9GXTmlk7MjcgQbDCx6mn7yIawsppWkvfPkKaAQsiqaT9DnMWBHVNIabGqgQSGT
# rQWo43MOfsPynhbz2Hyxf5XWKZpRvr3dMapandPfYgoZ8iDL2OR3sYztgJrbG6VZ
# 9DoTXFm1g0Rf97Aaen1l4c+w3DC+IkwFkvjFV3jS49ZSc4lShKK6BrPTJYs4NG1D
# GzmpToTnwoqZ8fAmi2XlZnuchC4NPSZaPATHvNIzt+z1PHo35D/f7j2pO1S8BCys
# QDHCbM5Mnomnq5aYcKCsdbh0czchOm8bkinLrYrKpii+Tk7pwL7TjRKLXkomm5D1
# Umds++pip8wH2cQpf93at3VDcOK4N7EwoIJB0kak6pSzEu4I64U6gZs7tS/dGNSl
# jf2OSSnRr7KWzq03zl8l75jy+hOds9TWSenLbjBQUGR96cFr6lEUfAIEHVC1L68Y
# 1GGxx4/eRI82ut83axHMViw1+sVpbPxg51Tbnio1lB93079WPFnYaOvfGAA0e0zc
# fF/M9gXr+korwQTh2Prqooq2bYNMvUoUKD85gnJ+t0smrWrb8dee2CvYZXD5laGt
# aAxOfy/VKNmwuWuAh9kcMIIGYjCCBMqgAwIBAgIRAKQpO24e3denNAiHrXpOtyQw
# DQYJKoZIhvcNAQEMBQAwVTELMAkGA1UEBhMCR0IxGDAWBgNVBAoTD1NlY3RpZ28g
# TGltaXRlZDEsMCoGA1UEAxMjU2VjdGlnbyBQdWJsaWMgVGltZSBTdGFtcGluZyBD
# QSBSMzYwHhcNMjUwMzI3MDAwMDAwWhcNMzYwMzIxMjM1OTU5WjByMQswCQYDVQQG
# EwJHQjEXMBUGA1UECBMOV2VzdCBZb3Jrc2hpcmUxGDAWBgNVBAoTD1NlY3RpZ28g
# TGltaXRlZDEwMC4GA1UEAxMnU2VjdGlnbyBQdWJsaWMgVGltZSBTdGFtcGluZyBT
# aWduZXIgUjM2MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA04SV9G6k
# U3jyPRBLeBIHPNyUgVNnYayfsGOyYEXrn3+SkDYTLs1crcw/ol2swE1TzB2aR/5J
# IjKNf75QBha2Ddj+4NEPKDxHEd4dEn7RTWMcTIfm492TW22I8LfH+A7Ehz0/safc
# 6BbsNBzjHTt7FngNfhfJoYOrkugSaT8F0IzUh6VUwoHdYDpiln9dh0n0m545d5A5
# tJD92iFAIbKHQWGbCQNYplqpAFasHBn77OqW37P9BhOASdmjp3IijYiFdcA0WQIe
# 60vzvrk0HG+iVcwVZjz+t5OcXGTcxqOAzk1frDNZ1aw8nFhGEvG0ktJQknnJZE3D
# 40GofV7O8WzgaAnZmoUn4PCpvH36vD4XaAF2CjiPsJWiY/j2xLsJuqx3JtuI4akH
# 0MmGzlBUylhXvdNVXcjAuIEcEQKtOBR9lU4wXQpISrbOT8ux+96GzBq8TdbhoFcm
# YaOBZKlwPP7pOp5Mzx/UMhyBA93PQhiCdPfIVOCINsUY4U23p4KJ3F1HqP3H6Slw
# 3lHACnLilGETXRg5X/Fp8G8qlG5Y+M49ZEGUp2bneRLZoyHTyynHvFISpefhBCV0
# KdRZHPcuSL5OAGWnBjAlRtHvsMBrI3AAA0Tu1oGvPa/4yeeiAyu+9y3SLC98gDVb
# ySnXnkujjhIh+oaatsk/oyf5R2vcxHahajMCAwEAAaOCAY4wggGKMB8GA1UdIwQY
# MBaAFF9Y7UwxeqJhQo1SgLqzYZcZojKbMB0GA1UdDgQWBBSIYYyhKjdkgShgoZsx
# 0Iz9LALOTzAOBgNVHQ8BAf8EBAMCBsAwDAYDVR0TAQH/BAIwADAWBgNVHSUBAf8E
# DDAKBggrBgEFBQcDCDBKBgNVHSAEQzBBMDUGDCsGAQQBsjEBAgEDCDAlMCMGCCsG
# AQUFBwIBFhdodHRwczovL3NlY3RpZ28uY29tL0NQUzAIBgZngQwBBAIwSgYDVR0f
# BEMwQTA/oD2gO4Y5aHR0cDovL2NybC5zZWN0aWdvLmNvbS9TZWN0aWdvUHVibGlj
# VGltZVN0YW1waW5nQ0FSMzYuY3JsMHoGCCsGAQUFBwEBBG4wbDBFBggrBgEFBQcw
# AoY5aHR0cDovL2NydC5zZWN0aWdvLmNvbS9TZWN0aWdvUHVibGljVGltZVN0YW1w
# aW5nQ0FSMzYuY3J0MCMGCCsGAQUFBzABhhdodHRwOi8vb2NzcC5zZWN0aWdvLmNv
# bTANBgkqhkiG9w0BAQwFAAOCAYEAAoE+pIZyUSH5ZakuPVKK4eWbzEsTRJOEjbIu
# 6r7vmzXXLpJx4FyGmcqnFZoa1dzx3JrUCrdG5b//LfAxOGy9Ph9JtrYChJaVHrus
# Dh9NgYwiGDOhyyJ2zRy3+kdqhwtUlLCdNjFjakTSE+hkC9F5ty1uxOoQ2ZkfI5WM
# 4WXA3ZHcNHB4V42zi7Jk3ktEnkSdViVxM6rduXW0jmmiu71ZpBFZDh7Kdens+PQX
# PgMqvzodgQJEkxaION5XRCoBxAwWwiMm2thPDuZTzWp/gUFzi7izCmEt4pE3Kf0M
# Ot3ccgwn4Kl2FIcQaV55nkjv1gODcHcD9+ZVjYZoyKTVWb4VqMQy/j8Q3aaYd/jO
# Q66Fhk3NWbg2tYl5jhQCuIsE55Vg4N0DUbEWvXJxtxQQaVR5xzhEI+BjJKzh3TQ0
# 26JxHhr2fuJ0mV68AluFr9qshgwS5SpN5FFtaSEnAwqZv3IS+mlG50rK7W3qXbWw
# i4hmpylUfygtYLEdLQukNEX1jiOKMIIGazCCBNOgAwIBAgIRAIxBnpO/K86siAYo
# O3YZvTwwDQYJKoZIhvcNAQEMBQAwVDELMAkGA1UEBhMCR0IxGDAWBgNVBAoTD1Nl
# Y3RpZ28gTGltaXRlZDErMCkGA1UEAxMiU2VjdGlnbyBQdWJsaWMgQ29kZSBTaWdu
# aW5nIENBIFIzNjAeFw0yNDExMTQwMDAwMDBaFw0yNzExMTQyMzU5NTlaMFcxCzAJ
# BgNVBAYTAkRFMRYwFAYDVQQIDA1OaWVkZXJzYWNoc2VuMRcwFQYDVQQKDA5NYXJ0
# aW4gV2lsbGluZzEXMBUGA1UEAwwOTWFydGluIFdpbGxpbmcwggIiMA0GCSqGSIb3
# DQEBAQUAA4ICDwAwggIKAoICAQDRn27mnIzB6dsJFLMexQQNRd8aMv73DTla68G6
# Q8u+V2TY1JQ/Z4j2oCI9ATW3K3P7NAPdlE0QmtdjC0F/74jsfil/i8LwxuyT034w
# abViZKUcodmKsEFhM9am8W5kUgLuC5FIK4wNOq5TfzYdHTyJu1eR2XuSDoMp0wg4
# 5mOuFNBbYB8DVBtHxobvWq4eCs3lUxX07wR3Qr2Utb92w8eU2vKr2Ss9xIh/YvM4
# UxgBpO1I6O+W2tAB5mmynIgoCfX7mu6iD3A+AhpQ9Gv209G83y8FPrFJIWU77TTe
# hErbPjZ074xXwrlEkhnGUCk1w+KiNtZHaSn0X+vnhqJ7otBxQZQAESlhWXpDKCun
# nnVnVgwvVWtccAhxZO95eif6Vss/UhCaBZ26szlneGtFeTClI4+k3mqfWuodtXjH
# c8ohAclWp7XVywliwhCFEsAcFkpkCyivey0sqEfrwiMnRy1elH1S37XcQaav5+bt
# 4KxtIXuOVEx3vM9MHdlraW0y1on5E8i4tagdI45TH0LU080ubc2MKqq6ZXtplTu1
# wdF2Cgy3hfSSLkJscRWApvpvOO6Vtc4jTG/AO6iqN5M6Swd+g40XtsxBD/gSk9kM
# qkgJ1pD1Gp5gkHnP1veut+YgJ9xWcRDJI7vcis9qsXwtVybeOCh56rTQvC/Tf6BJ
# tiieEQIDAQABo4IBszCCAa8wHwYDVR0jBBgwFoAUDyrLIIcouOxvSK4rVKYpqhek
# zQwwHQYDVR0OBBYEFIxyZAmEHl7uAfEwbB4nzI8MCCLbMA4GA1UdDwEB/wQEAwIH
# gDAMBgNVHRMBAf8EAjAAMBMGA1UdJQQMMAoGCCsGAQUFBwMDMEoGA1UdIARDMEEw
# NQYMKwYBBAGyMQECAQMCMCUwIwYIKwYBBQUHAgEWF2h0dHBzOi8vc2VjdGlnby5j
# b20vQ1BTMAgGBmeBDAEEATBJBgNVHR8EQjBAMD6gPKA6hjhodHRwOi8vY3JsLnNl
# Y3RpZ28uY29tL1NlY3RpZ29QdWJsaWNDb2RlU2lnbmluZ0NBUjM2LmNybDB5Bggr
# BgEFBQcBAQRtMGswRAYIKwYBBQUHMAKGOGh0dHA6Ly9jcnQuc2VjdGlnby5jb20v
# U2VjdGlnb1B1YmxpY0NvZGVTaWduaW5nQ0FSMzYuY3J0MCMGCCsGAQUFBzABhhdo
# dHRwOi8vb2NzcC5zZWN0aWdvLmNvbTAoBgNVHREEITAfgR1td2lsbGluZ0BsZXRo
# YWwtZm9yZW5zaWNzLmNvbTANBgkqhkiG9w0BAQwFAAOCAYEAZ0dBMMwluWGb+MD1
# rGWaPtaXrNZnlZqOZxgbdrMLBKAQr0QGcILCVIZ4SZYaevT5yMR6jFGSAjgaFtnk
# 8ZpbtGwig/ed/C/D1Ne8SZyffdtALns/5CHxMnU8ks7ut7dsR6zFD4/bmljuoUoi
# 55W6/XU/1pr+tqRaZGJvjSKJQCN9MhFAvXSpPPqRsj27ze1+KYIBF1/L0BW0HS0d
# 9ZhGSUoEwqMDLpQf2eqJFyyyzWt21VVhLF6mgZ1dE5tCLZY7ERzx6/h5N7F0w361
# oigizMbCMdST29XOc5mB8q6Cye7OmEfM2jByRWa+cd4RycsN2p2wHRukpq48iX+t
# PVKmHwNKf+upuKPDQAeV4J7gUCtevIsOtoyiC2+amimu81o424Dl+NsAyCLz0SXv
# NAhVvtU73H61gtoPa/SWouem2S+bzp7oGvGPop/9mh4CXki6LVeDH3hDM8hZsJg/
# EToIWiDozTc2yWqwV4Ozyd4x5Ix8lckXMgWuyWcxmLK1RmKpMIIGgjCCBGqgAwIB
# AgIQNsKwvXwbOuejs902y8l1aDANBgkqhkiG9w0BAQwFADCBiDELMAkGA1UEBhMC
# VVMxEzARBgNVBAgTCk5ldyBKZXJzZXkxFDASBgNVBAcTC0plcnNleSBDaXR5MR4w
# HAYDVQQKExVUaGUgVVNFUlRSVVNUIE5ldHdvcmsxLjAsBgNVBAMTJVVTRVJUcnVz
# dCBSU0EgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwHhcNMjEwMzIyMDAwMDAwWhcN
# MzgwMTE4MjM1OTU5WjBXMQswCQYDVQQGEwJHQjEYMBYGA1UEChMPU2VjdGlnbyBM
# aW1pdGVkMS4wLAYDVQQDEyVTZWN0aWdvIFB1YmxpYyBUaW1lIFN0YW1waW5nIFJv
# b3QgUjQ2MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAiJ3YuUVnnR3d
# 6LkmgZpUVMB8SQWbzFoVD9mUEES0QUCBdxSZqdTkdizICFNeINCSJS+lV1ipnW5i
# hkQyC0cRLWXUJzodqpnMRs46npiJPHrfLBOifjfhpdXJ2aHHsPHggGsCi7uE0awq
# KggE/LkYw3sqaBia67h/3awoqNvGqiFRJ+OTWYmUCO2GAXsePHi+/JUNAax3kpqs
# tbl3vcTdOGhtKShvZIvjwulRH87rbukNyHGWX5tNK/WABKf+Gnoi4cmisS7oSimg
# HUI0Wn/4elNd40BFdSZ1EwpuddZ+Wr7+Dfo0lcHflm/FDDrOJ3rWqauUP8hsokDo
# I7D/yUVI9DAE/WK3Jl3C4LKwIpn1mNzMyptRwsXKrop06m7NUNHdlTDEMovXAIDG
# AvYynPt5lutv8lZeI5w3MOlCybAZDpK3Dy1MKo+6aEtE9vtiTMzz/o2dYfdP0KWZ
# wZIXbYsTIlg1YIetCpi5s14qiXOpRsKqFKqav9R1R5vj3NgevsAsvxsAnI8Oa5s2
# oy25qhsoBIGo/zi6GpxFj+mOdh35Xn91y72J4RGOJEoqzEIbW3q0b2iPuWLA911c
# RxgY5SJYubvjay3nSMbBPPFsyl6mY4/WYucmyS9lo3l7jk27MAe145GWxK4O3m3g
# EFEIkv7kRmefDR7Oe2T1HxAnICQvr9sCAwEAAaOCARYwggESMB8GA1UdIwQYMBaA
# FFN5v1qqK0rPVIDh2JvAnfKyA2bLMB0GA1UdDgQWBBT2d2rdP/0BE/8WoWyCAi/Q
# Cj0UJTAOBgNVHQ8BAf8EBAMCAYYwDwYDVR0TAQH/BAUwAwEB/zATBgNVHSUEDDAK
# BggrBgEFBQcDCDARBgNVHSAECjAIMAYGBFUdIAAwUAYDVR0fBEkwRzBFoEOgQYY/
# aHR0cDovL2NybC51c2VydHJ1c3QuY29tL1VTRVJUcnVzdFJTQUNlcnRpZmljYXRp
# b25BdXRob3JpdHkuY3JsMDUGCCsGAQUFBwEBBCkwJzAlBggrBgEFBQcwAYYZaHR0
# cDovL29jc3AudXNlcnRydXN0LmNvbTANBgkqhkiG9w0BAQwFAAOCAgEADr5lQe1o
# RLjlocXUEYfktzsljOt+2sgXke3Y8UPEooU5y39rAARaAdAxUeiX1ktLJ3+lgxto
# LQhn5cFb3GF2SSZRX8ptQ6IvuD3wz/LNHKpQ5nX8hjsDLRhsyeIiJsms9yAWnvdY
# OdEMq1W61KE9JlBkB20XBee6JaXx4UBErc+YuoSb1SxVf7nkNtUjPfcxuFtrQdRM
# Ri/fInV/AobE8Gw/8yBMQKKaHt5eia8ybT8Y/Ffa6HAJyz9gvEOcF1VWXG8OMeM7
# Vy7Bs6mSIkYeYtddU1ux1dQLbEGur18ut97wgGwDiGinCwKPyFO7ApcmVJOtlw9F
# VJxw/mL1TbyBns4zOgkaXFnnfzg4qbSvnrwyj1NiurMp4pmAWjR+Pb/SIduPnmFz
# bSN/G8reZCL4fvGlvPFk4Uab/JVCSmj59+/mB2Gn6G/UYOy8k60mKcmaAZsEVkhO
# Fuoj4we8CYyaR9vd9PGZKSinaZIkvVjbH/3nlLb0a7SBIkiRzfPfS9T+JesylbHa
# 1LtRV9U/7m0q7Ma2CQ/t392ioOssXW7oKLdOmMBl14suVFBmbzrt5V5cQPnwtd3U
# OTpS9oCG+ZZheiIvPgkDmA8FzPsnfXW5qHELB43ET7HHFHeRPRYrMBKjkb8/IN7P
# o0d0hQoF4TeMM+zYAJzoKQnVKOLg8pZVPT8xggYxMIIGLQIBATBpMFQxCzAJBgNV
# BAYTAkdCMRgwFgYDVQQKEw9TZWN0aWdvIExpbWl0ZWQxKzApBgNVBAMTIlNlY3Rp
# Z28gUHVibGljIENvZGUgU2lnbmluZyBDQSBSMzYCEQCMQZ6TvyvOrIgGKDt2Gb08
# MAkGBSsOAwIaBQCgeDAYBgorBgEEAYI3AgEMMQowCKACgAChAoAAMBkGCSqGSIb3
# DQEJAzEMBgorBgEEAYI3AgEEMBwGCisGAQQBgjcCAQsxDjAMBgorBgEEAYI3AgEV
# MCMGCSqGSIb3DQEJBDEWBBST3S9uZfOSRTGoGSJ0Eip8E5X1eTANBgkqhkiG9w0B
# AQEFAASCAgB4VUwJg/VBiXJXBEY2kQfrbiivCG26nU0P2cgtobXNiMOSFMnarWtE
# JF2Kwq60yguIuGUmsTgTHQewyFDZNNoltK5pmRJpGssMMDo18t9excWsk0ZI5W9f
# pLP4zw+f1ycNEl2xMMn/E+tlb3eKdYWDe+2qGeChAZVBQ67uJZdFTWv3TjvddWU+
# Q3qNT8jRUK7cxys7gBdsKvze2oOwr7KXHDjvuHajA2vYPfqNf9HEGGYQwOj0IkOU
# ct47pfSRsqEX3h0fkqkmSYc+ctZd0kiy0NCIzexKQlVY/5BDeKEFaX7vUhy+NDYZ
# 3I4nClecTcLNPFMXDWqrcsxSHLKKzkmiIiDIn0Es88M20puRZDkdBHPG36mspZSW
# /B2gUQ1k26k8p+MaBQz2UFhEAlAkWgz2gZnMKp7f7Rup3yv74tT7BLcQS90CM4Mj
# ckFEntEd7z/rsSYNRIojnfUVPPFTmHEb+cwkNnW64qJFcyAJGzRyTVPEG7mjc5Vc
# +m6WEGTaCZtnWh76lku4lauQ4d3umqkS0mY7T/QpyBIPfVQVXkJ01O6Zx59RFapd
# jV2nYBPCnUVxcuprtUJPCQAyyUb/pHp0EcXg0Ct4T6cj1tY8r8sA42tWsgUmL8/T
# om4W08VCs7kxgHOqq4QdeD0rROgfVKepHwB7poHMTJIKLWGjDWIrmqGCAyMwggMf
# BgkqhkiG9w0BCQYxggMQMIIDDAIBATBqMFUxCzAJBgNVBAYTAkdCMRgwFgYDVQQK
# Ew9TZWN0aWdvIExpbWl0ZWQxLDAqBgNVBAMTI1NlY3RpZ28gUHVibGljIFRpbWUg
# U3RhbXBpbmcgQ0EgUjM2AhEApCk7bh7d16c0CIetek63JDANBglghkgBZQMEAgIF
# AKB5MBgGCSqGSIb3DQEJAzELBgkqhkiG9w0BBwEwHAYJKoZIhvcNAQkFMQ8XDTI1
# MDcyNTE2MzEyNVowPwYJKoZIhvcNAQkEMTIEMLSbd0iElA5i9dna4ivC2MAEOyYq
# JPRFqyWLfx+gugCxLAc1Q6w95w50KB36Y6J2iTANBgkqhkiG9w0BAQEFAASCAgA6
# ids57O2v/GGWcrH2Fsor1VljQZYZlyYz/tfTYKiq5MFdeIge9kAMMw13U6on+Mym
# 7uNHUgEuhDyr2bU3HQR6hIJaT26mUKbh4I7V2BYM0XxnqyTAsR0cG4pYHjLS+BMi
# hFdjk4gB6fOFiP65Vycr6AoufIf6FF4cJFcuQG8cgICM+f1021sX6gc8hj7tqFI3
# 0LhylBaO+NOJ8A9zrkI+FUj2qXnrrq4vMeIVWXy4FrEMGutSKoAkvcUwf4cRZlhs
# Th5JjHskEtUIo207158VwNKSsdT5yrS9aR6iYjXywyZQJjoTBxhEI+s8sHSXYU4J
# fMsbD5C7pZ0VyUWukvu/AmghwvD5XVGk2CmuepDCO73byqkgArF17STfFfwZAXCR
# T/D4sZG0nZIX7w+to1dhuXlkuh2TfsAyt218f4r4aTSEeL1zCZblE5+g8bkTY92O
# rWda3rWGLcHvKtFT5rcbaQgWTCP7E9KBL7gL6LwCxfr1O2/ZpVwHoZ29+REK4mHL
# ldFMqO46m20PFOZQ8ChEhiAD4lnA1+6YNuSWLqqCNEgH8PATuXVXFR2HWokzexIe
# J9YFiGiubW+978BdBYr8/I53fQdGqf4sOF98NLOSfLPxmR3m5i/lGWN5o/BRgvz/
# BbDBMf3L1rVOcsB+5ucd+xtgwqAqRpyB77tQAR7XTA==
# SIG # End signature block

```

`Scripts/Measure-DamerauLevenshteinDistance/Measure-DamerauLevenshteinDistance.cs`:

```cs
using System;
using System.Linq;

// Original by Jared Atkinson (@jaredcatkinson)
// ported to C# by https://github.com/DaFuqs
public class LevenshteinDistance {

	public static int Measure(string original, string modified) {
		if (original == modified) {
			return 0;
        }

		int lorig = original.Length;
		int ldiff = modified.Length;
		if (lorig == 0 || ldiff == 0) {
			return lorig == 0 ? ldiff : lorig;
        }

		var matrix = new int[lorig + 1, ldiff + 1];

		for (int i = 1; i <= lorig; i++) {
			matrix[i, 0] = i;
			for (int j = 1; j <= ldiff; j++) {
				int cost = modified[j - 1] == original[i - 1] ? 0 : 1;
				if (i == 1)
					matrix[0, j] = j;

				int[] vals = new int[] {
					matrix[i - 1, j    ] + 1,
					matrix[i    , j - 1] + 1,
					matrix[i - 1, j - 1] + cost
				};
				matrix[i,j] = vals.Min();
				if (i > 1 && j > 1 && original[i - 1] == modified[j - 2] && original[i - 2] == modified[j - 1])
					matrix[i,j] = Math.Min (matrix[i,j], matrix[i - 2, j - 2] + cost);
			}
		}
		return matrix[lorig, ldiff];
	}
}
```

`Scripts/ProcessesAndModules-Extended_Info.ps1`:

```ps1
# ProcessesAndModules-Extended_Info v0.2
#
# @author:    Martin Willing
# @copyright: Copyright (c) 2025 Martin Willing. All rights reserved.
# @contact:   Any feedback or suggestions are always welcome and much appreciated - mwilling@lethal-forensics.com
# @url:       https://lethal-forensics.com/
# @date:      2025-06-24
#
#
# ██╗     ███████╗████████╗██╗  ██╗ █████╗ ██╗      ███████╗ ██████╗ ██████╗ ███████╗███╗   ██╗███████╗██╗ ██████╗███████╗
# ██║     ██╔════╝╚══██╔══╝██║  ██║██╔══██╗██║      ██╔════╝██╔═══██╗██╔══██╗██╔════╝████╗  ██║██╔════╝██║██╔════╝██╔════╝
# ██║     █████╗     ██║   ███████║███████║██║█████╗█████╗  ██║   ██║██████╔╝█████╗  ██╔██╗ ██║███████╗██║██║     ███████╗
# ██║     ██╔══╝     ██║   ██╔══██║██╔══██║██║╚════╝██╔══╝  ██║   ██║██╔══██╗██╔══╝  ██║╚██╗██║╚════██║██║██║     ╚════██║
# ███████╗███████╗   ██║   ██║  ██║██║  ██║███████╗ ██║     ╚██████╔╝██║  ██║███████╗██║ ╚████║███████║██║╚██████╗███████║
# ╚══════╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚══════╝ ╚═╝      ╚═════╝ ╚═╝  ╚═╝╚══════╝╚═╝  ╚═══╝╚══════╝╚═╝ ╚═════╝╚══════╝
#
#
# Dependencies:
#
# ImportExcel v7.8.10 (2024-10-21)
# https://github.com/dfinke/ImportExcel
#
#
#############################################################################################################################################################################################
#############################################################################################################################################################################################

<#
.SYNOPSIS
  ProcessesAndModules-Extended_Info v0.2 - Automated Processing of 'ProcessesAndModules-Extended_Info.tsv' (MAGNET Response)

.DESCRIPTION
  ProcessesAndModules-Extended_Info.ps1 is a simple PowerShell script utilized to beautify the extended information about running processes and loaded modules collected by MAGNET Response.

  Enable 'Capture Running Processes - Extended Info'
  This option collects more data about running processes (and loaded modules in memory), saving hash values and metadata from identified files which can be used to enable post-collection lookups/enrichment in another tool.

  Collect-MemoryDump.ps1 --> \Pagefile\Pagefile\Processes\ProcessesAndModules-Extended_Info.tsv

  https://github.com/LETHAL-FORENSICS/Collect-MemoryDump

.EXAMPLE
  PS> .\ProcessesAndModules-Extended_Info.ps1

.NOTES
  Author - Martin Willing

.LINK
  https://lethal-forensics.com/
#>

#############################################################################################################################################################################################
#############################################################################################################################################################################################

#region Declarations

# Declarations

# Script Root
if ($PSVersionTable.PSVersion.Major -gt 2)
{
    # PowerShell 3+
    $SCRIPT_DIR = $PSScriptRoot
}
else
{
    # PowerShell 2
    $SCRIPT_DIR = Split-Path -Parent $MyInvocation.MyCommand.Definition
}

# Colors
Add-Type -AssemblyName System.Drawing
$BackgroundColor   = [System.Drawing.Color]::FromArgb(50,60,220) # Lethal Blue
$FontColor         = [System.Drawing.Color]::FromArgb(255,255,255) # White
$MaliciousColor    = [System.Drawing.Color]::FromArgb(255,0,0) # Red
$SuspiciousColor   = [System.Drawing.Color]::FromArgb(255,192,0) # Orange
$UnsignedColor     = [System.Drawing.Color]::FromArgb(255,204,206) # Pink
$FileNotFoundColor = [System.Drawing.Color]::FromArgb(255,255,0) # Yellow

# Output Directory
$OUTPUT_FOLDER = "$env:USERPROFILE\Desktop\ProcessesAndModules"

#endregion Declarations

#############################################################################################################################################################################################
#############################################################################################################################################################################################

#region Header

# Windows Title
$DefaultWindowsTitle = $Host.UI.RawUI.WindowTitle
$Host.UI.RawUI.WindowTitle = "ProcessesAndModules-Extended_Info v0.2 - Automated Processing of Extended Info about Running Processes and Loaded Modules collected by MAGNET Response"

# Check if the PowerShell script is being run with admin rights
if (!([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator))
{
    Write-Host "[Error] This PowerShell script must be run with admin rights." -ForegroundColor Red
    Exit
}

# Check if PowerShell module 'ImportExcel' is installed
if (!(Get-Module -ListAvailable -Name ImportExcel))
{
    Write-Host "[Error] Please install 'ImportExcel' PowerShell module." -ForegroundColor Red
    Write-Host "[Info]  Check out: https://github.com/dfinke/ImportExcel"
    Exit
}

# Flush Output Directory
if (Test-Path "$OUTPUT_FOLDER")
{
    Get-ChildItem -Path "$OUTPUT_FOLDER" -Force -Recurse -ErrorAction SilentlyContinue | Remove-Item -Force -Recurse
    New-Item "$OUTPUT_FOLDER" -ItemType Directory -Force | Out-Null
}
else 
{
    New-Item "$OUTPUT_FOLDER" -ItemType Directory -Force | Out-Null
}

# Function Get-FileSize
Function Get-FileSize()
{
    Param ([long]$Length)
    If ($Length -gt 1TB) {[string]::Format("{0:0.00} TB", $Length / 1TB)}
    ElseIf ($Length -gt 1GB) {[string]::Format("{0:0.00} GB", $Length / 1GB)}
    ElseIf ($Length -gt 1MB) {[string]::Format("{0:0.00} MB", $Length / 1MB)}
    ElseIf ($Length -gt 1KB) {[string]::Format("{0:0.00} KB", $Length / 1KB)}
    ElseIf ($Length -gt 0) {[string]::Format("{0:0.00} Bytes", $Length)}
    Else {""}
}

# Select Log File
Function Get-LogFile($InitialDirectory)
{ 
    [System.Reflection.Assembly]::LoadWithPartialName("System.Windows.Forms") | Out-Null
    $OpenFileDialog = New-Object System.Windows.Forms.OpenFileDialog
    $OpenFileDialog.InitialDirectory = $InitialDirectory
    $OpenFileDialog.Filter = "ProcessesAndModules-Extended_Info.tsv|ProcessesAndModules-Extended_Info.tsv|All Files (*.*)|*.*"
    $OpenFileDialog.ShowDialog()
    $OpenFileDialog.Filename
    $OpenFileDialog.ShowHelp = $true
    $OpenFileDialog.Multiselect = $false
}

$Result = Get-LogFile

if($Result -eq "OK")
{
    $script:LogFile = $Result[1]
}
else
{
    $Host.UI.RawUI.WindowTitle = "$DefaultWindowsTitle"
    Exit
}

# Get Start Time
$startTime = (Get-Date)

# Logo
$Logo = @"
██╗     ███████╗████████╗██╗  ██╗ █████╗ ██╗      ███████╗ ██████╗ ██████╗ ███████╗███╗   ██╗███████╗██╗ ██████╗███████╗
██║     ██╔════╝╚══██╔══╝██║  ██║██╔══██╗██║      ██╔════╝██╔═══██╗██╔══██╗██╔════╝████╗  ██║██╔════╝██║██╔════╝██╔════╝
██║     █████╗     ██║   ███████║███████║██║█████╗█████╗  ██║   ██║██████╔╝█████╗  ██╔██╗ ██║███████╗██║██║     ███████╗
██║     ██╔══╝     ██║   ██╔══██║██╔══██║██║╚════╝██╔══╝  ██║   ██║██╔══██╗██╔══╝  ██║╚██╗██║╚════██║██║██║     ╚════██║
███████╗███████╗   ██║   ██║  ██║██║  ██║███████╗ ██║     ╚██████╔╝██║  ██║███████╗██║ ╚████║███████║██║╚██████╗███████║
╚══════╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚══════╝ ╚═╝      ╚═════╝ ╚═╝  ╚═╝╚══════╝╚═╝  ╚═══╝╚══════╝╚═╝ ╚═════╝╚══════╝
"@

Write-Output ""
Write-Output "$Logo"
Write-Output ""

# Header
Write-Output "ProcessesAndModules-Extended_Info v0.2 - Automated Processing of Extended Info about Running Processes and Loaded Modules collected by MAGNET Response"
Write-Output "(c) 2025 Martin Willing at Lethal-Forensics (https://lethal-forensics.com/)"
Write-Output ""

# Analysis date (ISO 8601)
$AnalysisDate = [datetime]::Now.ToUniversalTime().ToString("yyyy-MM-dd HH:mm:ss")
Write-Output "Analysis date: $AnalysisDate UTC"
Write-Output ""

#endregion Header

#############################################################################################################################################################################################

#region Analysis

# Input-Check
if (!(Test-Path "$LogFile"))
{
    Write-Host "[Error] $LogFile does not exist." -ForegroundColor Red
    Write-Host ""
    Stop-Transcript
    $Host.UI.RawUI.WindowTitle = "$DefaultWindowsTitle"
    Exit
}

# Check File Extension
$Extension = [IO.Path]::GetExtension($LogFile)
if (!($Extension -eq ".tsv" ))
{
    Write-Host "[Error] No TSV File provided." -ForegroundColor Red
    Stop-Transcript
    $Host.UI.RawUI.WindowTitle = "$DefaultWindowsTitle"
    Exit
}

# Input Size
$InputSize = Get-FileSize((Get-Item "$LogFile").Length)
Write-Output "[Info]  Total Input Size: $InputSize"

# Count rows of TSV (w/ thousands separators)
$Count = 0
switch -File "$LogFile" { default { ++$Count } }
$Rows = '{0:N0}' -f $Count
Write-Output "[Info]  Total Lines: $Rows"

# Processing ProcessesAndModules-Extended_Info.tsv
Write-Output "[Info]  Processing ProcessesAndModules-Extended_Info.tsv ..."

# XLSX
if (Get-Module -ListAvailable -Name ImportExcel)
{
    if (Test-Path "$LogFile")
    {
        if(!([String]::IsNullOrWhiteSpace((Get-Content "$LogFile"))))
        {
            $IMPORT = Import-Csv -Path "$LogFile" -Delimiter "`t" -Encoding UTF8 | Select-Object "File Path","Digital Signature",Entropy,"Company Name","Product Name",Description,Comments,Version,"Found On Disk",MD5,SHA1,"Location of Saved File in ZIP"
            $IMPORT | Export-Excel -Path "$OUTPUT_FOLDER\ProcessesAndModules-Extended_Info.xlsx" -NoNumberConversion * -NoHyperLinkConversion * -FreezePane 2,4 -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Running Processes" -CellStyleSB {
            param($WorkSheet)

            # BackgroundColor and FontColor for specific cells of TopRow
            Set-Format -Address $WorkSheet.Cells["A1:L1"] -BackgroundColor $BackgroundColor -FontColor $FontColor

            # HorizontalAlignment "Center" of columns B-E and H-K
            $WorkSheet.Cells["B:E"].Style.HorizontalAlignment="Center"
            $WorkSheet.Cells["H:K"].Style.HorizontalAlignment="Center"

            # Digital Signature: No Valid Signature Found --> Font: Red
            Add-ConditionalFormatting -Address $WorkSheet.Cells["B:B"] -WorkSheet $WorkSheet -RuleType 'Expression' 'NOT(ISERROR(FIND("No Valid Signature Found",$B1)))' -FontColor $MaliciousColor

            # Entropy >= 7.7
            # Note: Entropy is a measure of randomness. For binary data 0,0 is not-random and 8,0 is perfectly random.
            $Cells = "C:C"
            Add-ConditionalFormatting -Address $WorkSheet.Cells["$Cells"] -WorkSheet $WorkSheet -RuleType 'Expression' 'NOT(ISERROR(FIND("8,0",$C1)))' -BackgroundColor $MaliciousColor
            Add-ConditionalFormatting -Address $WorkSheet.Cells["$Cells"] -WorkSheet $WorkSheet -RuleType 'Expression' 'NOT(ISERROR(FIND("7,9",$C1)))' -BackgroundColor $MaliciousColor
            Add-ConditionalFormatting -Address $WorkSheet.Cells["$Cells"] -WorkSheet $WorkSheet -RuleType 'Expression' 'NOT(ISERROR(FIND("7,8",$C1)))' -BackgroundColor $MaliciousColor
            Add-ConditionalFormatting -Address $WorkSheet.Cells["$Cells"] -WorkSheet $WorkSheet -RuleType 'Expression' 'NOT(ISERROR(FIND("7,7",$C1)))' -BackgroundColor $MaliciousColor
            Add-ConditionalFormatting -Address $WorkSheet.Cells["$Cells"] -WorkSheet $WorkSheet -RuleType 'Expression' 'NOT(ISERROR(FIND("7,6",$C1)))' -BackgroundColor $SuspiciousColor
            Add-ConditionalFormatting -Address $WorkSheet.Cells["$Cells"] -WorkSheet $WorkSheet -RuleType 'Expression' 'NOT(ISERROR(FIND("7,5",$C1)))' -BackgroundColor $SuspiciousColor
            Add-ConditionalFormatting -Address $WorkSheet.Cells["$Cells"] -WorkSheet $WorkSheet -RuleType 'Expression' 'NOT(ISERROR(FIND("7,4",$C1)))' -BackgroundColor $SuspiciousColor
            Add-ConditionalFormatting -Address $WorkSheet.Cells["$Cells"] -WorkSheet $WorkSheet -RuleType 'Expression' 'NOT(ISERROR(FIND("7,3",$C1)))' -BackgroundColor $SuspiciousColor

            # Digital Signature: No Valid Signature Found --> Pink
            Add-ConditionalFormatting -Address $WorkSheet.Dimension.Address -WorkSheet $WorkSheet -RuleType 'Expression' 'NOT(ISERROR(FIND("No Valid Signature Found",$B1)))' -BackgroundColor $UnsignedColor

            # Image Path: File not found --> Yellow
            Add-ConditionalFormatting -Address $WorkSheet.Dimension.Address -WorkSheet $WorkSheet -RuleType 'Expression' 'NOT(ISERROR(FIND("No",$I1)))' -BackgroundColor $FileNotFoundColor

            }
        }
    }
}
else
{
    Write-Host "[Error] PowerShell module 'ImportExcel' NOT found." -ForegroundColor Red
}

# File Size (XLSX)
if (Test-Path "$OUTPUT_FOLDER\ProcessesAndModules-Extended_Info.xlsx")
{
    $Size = Get-FileSize((Get-Item "$OUTPUT_FOLDER\ProcessesAndModules-Extended_Info.xlsx").Length)
    Write-Output "[Info]  File Size (XLSX): $Size"
}

# Stats
New-Item "$OUTPUT_FOLDER\Stats" -ItemType Directory -Force | Out-Null

# Company Name (Stats)
$Total = (Import-Csv -Path "$LogFile" -Delimiter "`t" | Where-Object { $_."Found On Disk" -eq "Yes" } | Measure-Object).Count
$Import = Import-Csv -Path "$LogFile" -Delimiter "`t" -Encoding UTF8 | Where-Object { $_."Found On Disk" -eq "Yes" }  | Group-Object "Company Name" | Select-Object @{Name='Company Name'; Expression={if($_.Name){$_.Name}else{'N/A'}}},Count,@{Name='PercentUse'; Expression={"{0:p2}" -f ($_.Count / $Total)}} | Sort-Object Count -Descending
$Import | Export-Excel -Path "$OUTPUT_FOLDER\Stats\CompanyName.xlsx" -NoHyperLinkConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Company Name" -CellStyleSB {
param($WorkSheet)
# BackgroundColor and FontColor for specific cells of TopRow
Set-Format -Address $WorkSheet.Cells["A1:C1"] -BackgroundColor $BackgroundColor -FontColor $FontColor
# HorizontalAlignment "Center" of column B-C
$WorkSheet.Cells["B:C"].Style.HorizontalAlignment="Center"
}

# Digital Signature (Stats)
$Total = (Import-Csv -Path "$LogFile" -Delimiter "`t" | Where-Object { $_."Found On Disk" -eq "Yes" } | Measure-Object).Count
$Import = Import-Csv -Path "$LogFile" -Delimiter "`t" -Encoding UTF8 | Where-Object { $_."Found On Disk" -eq "Yes" }  | Group-Object "Digital Signature" | Select-Object @{Name='Digital Signature'; Expression={if($_.Name){$_.Name}else{'N/A'}}},Count,@{Name='PercentUse'; Expression={"{0:p2}" -f ($_.Count / $Total)}} | Sort-Object Count -Descending
$Import | Export-Excel -Path "$OUTPUT_FOLDER\Stats\DigitalSignature.xlsx" -NoHyperLinkConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Digital Signature" -CellStyleSB {
param($WorkSheet)
# BackgroundColor and FontColor for specific cells of TopRow
Set-Format -Address $WorkSheet.Cells["A1:C1"] -BackgroundColor $BackgroundColor -FontColor $FontColor
# HorizontalAlignment "Center" of column B-C
$WorkSheet.Cells["B:C"].Style.HorizontalAlignment="Center"
}

# File Path (Stats)
$Total = (Import-Csv -Path "$LogFile" -Delimiter "`t" | Measure-Object).Count
$FilePath = Import-Csv -Path "$LogFile" -Delimiter "`t" -Encoding UTF8 | Select-Object -ExpandProperty "File Path" | Split-Path -Parent
$FilePath | Out-File "$OUTPUT_FOLDER\Stats\FilePath.txt" -Encoding UTF8
$Import = Get-Content "$OUTPUT_FOLDER\Stats\FilePath.txt" | Group-Object | Select-Object @{Name='FilePath'; Expression={$_.Name}},Count,@{Name='PercentUse'; Expression={"{0:p2}" -f ($_.Count / $Total)}} | Sort-Object Count -Descending
$Import | Export-Excel -Path "$OUTPUT_FOLDER\Stats\FilePath.xlsx" -NoHyperLinkConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "File Path" -CellStyleSB {
param($WorkSheet)
# BackgroundColor and FontColor for specific cells of TopRow
Set-Format -Address $WorkSheet.Cells["A1:C1"] -BackgroundColor $BackgroundColor -FontColor $FontColor
# HorizontalAlignment "Center" of column B-C
$WorkSheet.Cells["B:C"].Style.HorizontalAlignment="Center"
# ConditionalFormatting - File Path (No Regex supported)
Add-ConditionalFormatting -Address $WorkSheet.Cells["A:A"] -WorkSheet $WorkSheet -RuleType 'Expression' 'NOT(ISERROR(FIND("C:\Temp",$A1)))' -BackgroundColor Red # %SystemDrive%\Temp
Add-ConditionalFormatting -Address $WorkSheet.Cells["A:A"] -WorkSheet $WorkSheet -RuleType 'Expression' 'NOT(ISERROR(FIND("C:\Users\Public",$A1)))' -BackgroundColor Red # %SystemDrive%\Users\Public
Add-ConditionalFormatting -Address $WorkSheet.Cells["A:A"] -WorkSheet $WorkSheet -RuleType 'Expression' 'NOT(ISERROR(FIND("C:\Windows\Temp",$A1)))' -BackgroundColor Red # %SystemDrive%\Windows\Temp
}

# Cleaning Up
if (Test-Path "$OUTPUT_FOLDER\Stats\FilePath.txt")
{
    Remove-Item "$OUTPUT_FOLDER\Stats\FilePath.txt" -Force
}

# Found On Disk (Stats)
$Total = (Import-Csv -Path "$LogFile" -Delimiter "`t" | Measure-Object).Count
$Import = Import-Csv -Path "$LogFile" -Delimiter "`t" -Encoding UTF8 | Group-Object "Found On Disk" | Select-Object @{Name='Found On Disk'; Expression={if($_.Name){$_.Name}else{'N/A'}}},Count,@{Name='PercentUse'; Expression={"{0:p2}" -f ($_.Count / $Total)}} | Sort-Object Count -Descending
$Import | Export-Excel -Path "$OUTPUT_FOLDER\Stats\FoundOnDisk.xlsx" -NoHyperLinkConversion * -FreezeTopRow -BoldTopRow -AutoSize -AutoFilter -WorkSheetname "Found On Disk" -CellStyleSB {
param($WorkSheet)
# BackgroundColor and FontColor for specific cells of TopRow
Set-Format -Address $WorkSheet.Cells["A1:C1"] -BackgroundColor $BackgroundColor -FontColor $FontColor
# HorizontalAlignment "Center" of column A-C
$WorkSheet.Cells["A:C"].Style.HorizontalAlignment="Center"
}

# Total Number of Files
$Count = (Import-Csv -Path "$LogFile" -Delimiter "`t" | Select-Object "File Path" | Measure-Object).Count
$Total = '{0:N0}' -f $Count
Write-Output "[Info]  $Total File(s) found"

# Digital Signature --> No Valid Signature Found
$Count = (Import-Csv -Path "$LogFile" -Delimiter "`t" | Select-Object "Digital Signature" | Select-String -Pattern "No Valid Signature Found" | Measure-Object).Count
$Unsigned = '{0:N0}' -f $Count
Write-Output "[Info]  $Unsigned Unsigned File(s) found"

# Image Path --> Found On Disk
$FileNotFound = (Import-Csv -Path "$LogFile" -Delimiter "`t" | Where-Object { $_."Found On Disk" -eq "No" } | Measure-Object).Count
Write-Output "[Info]  $FileNotFound File(s) NOT found on disk"

# No Description
$MissingDescription = (Import-Csv -Path "$LogFile" -Delimiter "`t" | Where-Object { $_.Description -eq "" } | Measure-Object).Count
Write-Output "[Info]  $MissingDescription suspicious images with no 'Description' found"

# No Publisher
$MissingPublisher = (Import-Csv -Path "$LogFile" -Delimiter "`t" | Where-Object { $_."Company Name" -eq "" } | Measure-Object).Count
Write-Output "[Info]  $MissingPublisher suspicious images with no 'Company Name' found"

# No Description and no Publisher
$MissingDescriptionAndPublisher = (Import-Csv -Path "$LogFile" -Delimiter "`t" | Where-Object { $_.Description -eq "" -and $_."Company Name" -eq "" } | Measure-Object).Count
Write-Output "[Info]  $MissingDescriptionAndPublisher suspicious images with no 'Description' and no 'Company Name' found"

# Entropy >= 7.7
$MaliciousEntropy = (Import-Csv -Path "$LogFile" -Delimiter "`t" | Where-Object { $_.Entropy -ge "7,7" } | Measure-Object).Count
Write-Host "[Info]  $MaliciousEntropy suspicious images with an 'Entropy >= 7.7' found" -ForegroundColor Red

# Entropy >= 7.3
$SuspiciousEntropy = (Import-Csv -Path "$LogFile" -Delimiter "`t" | Where-Object { $_.Entropy -ge "7,3" -and $_.Entropy -lt "7,7" } | Measure-Object).Count
Write-Host "[Info]  $SuspiciousEntropy suspicious images with an 'Entropy >= 7.3' found" -ForegroundColor Yellow

#endregion Analysis

#############################################################################################################################################################################################
#############################################################################################################################################################################################

#region Footer

# Get End Time
$endTime = (Get-Date)

# Echo Time elapsed
Write-Output ""
Write-Output "FINISHED!"

$Time = ($endTime-$startTime)
$ElapsedTime = ('Overall analysis duration: {0} h {1} min {2} sec' -f $Time.Hours, $Time.Minutes, $Time.Seconds)
Write-Output "$ElapsedTime"

# Reset Windows Title
$Host.UI.RawUI.WindowTitle = "$DefaultWindowsTitle"

#endregion Footer

#############################################################################################################################################################################################
#############################################################################################################################################################################################

# Colors
# Pink   - this means that no publisher information was found, or if code verification is on, means that the digital signature either doesn't exist or doesn't match, or there is no publisher information.
# Yellow - the entry is there, but the file it points to doesn't exist anymore.

# SIG # Begin signature block
# MIIrywYJKoZIhvcNAQcCoIIrvDCCK7gCAQExCzAJBgUrDgMCGgUAMGkGCisGAQQB
# gjcCAQSgWzBZMDQGCisGAQQBgjcCAR4wJgIDAQAABBAfzDtgWUsITrck0sYpfvNR
# AgEAAgEAAgEAAgEAAgEAMCEwCQYFKw4DAhoFAAQUbXgcM6ogTOA2NJ6TB3OPmqBN
# 1wiggiUEMIIFbzCCBFegAwIBAgIQSPyTtGBVlI02p8mKidaUFjANBgkqhkiG9w0B
# AQwFADB7MQswCQYDVQQGEwJHQjEbMBkGA1UECAwSR3JlYXRlciBNYW5jaGVzdGVy
# MRAwDgYDVQQHDAdTYWxmb3JkMRowGAYDVQQKDBFDb21vZG8gQ0EgTGltaXRlZDEh
# MB8GA1UEAwwYQUFBIENlcnRpZmljYXRlIFNlcnZpY2VzMB4XDTIxMDUyNTAwMDAw
# MFoXDTI4MTIzMTIzNTk1OVowVjELMAkGA1UEBhMCR0IxGDAWBgNVBAoTD1NlY3Rp
# Z28gTGltaXRlZDEtMCsGA1UEAxMkU2VjdGlnbyBQdWJsaWMgQ29kZSBTaWduaW5n
# IFJvb3QgUjQ2MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAjeeUEiIE
# JHQu/xYjApKKtq42haxH1CORKz7cfeIxoFFvrISR41KKteKW3tCHYySJiv/vEpM7
# fbu2ir29BX8nm2tl06UMabG8STma8W1uquSggyfamg0rUOlLW7O4ZDakfko9qXGr
# YbNzszwLDO/bM1flvjQ345cbXf0fEj2CA3bm+z9m0pQxafptszSswXp43JJQ8mTH
# qi0Eq8Nq6uAvp6fcbtfo/9ohq0C/ue4NnsbZnpnvxt4fqQx2sycgoda6/YDnAdLv
# 64IplXCN/7sVz/7RDzaiLk8ykHRGa0c1E3cFM09jLrgt4b9lpwRrGNhx+swI8m2J
# mRCxrds+LOSqGLDGBwF1Z95t6WNjHjZ/aYm+qkU+blpfj6Fby50whjDoA7NAxg0P
# OM1nqFOI+rgwZfpvx+cdsYN0aT6sxGg7seZnM5q2COCABUhA7vaCZEao9XOwBpXy
# bGWfv1VbHJxXGsd4RnxwqpQbghesh+m2yQ6BHEDWFhcp/FycGCvqRfXvvdVnTyhe
# Be6QTHrnxvTQ/PrNPjJGEyA2igTqt6oHRpwNkzoJZplYXCmjuQymMDg80EY2NXyc
# uu7D1fkKdvp+BRtAypI16dV60bV/AK6pkKrFfwGcELEW/MxuGNxvYv6mUKe4e7id
# FT/+IAx1yCJaE5UZkADpGtXChvHjjuxf9OUCAwEAAaOCARIwggEOMB8GA1UdIwQY
# MBaAFKARCiM+lvEH7OKvKe+CpX/QMKS0MB0GA1UdDgQWBBQy65Ka/zWWSC8oQEJw
# IDaRXBeF5jAOBgNVHQ8BAf8EBAMCAYYwDwYDVR0TAQH/BAUwAwEB/zATBgNVHSUE
# DDAKBggrBgEFBQcDAzAbBgNVHSAEFDASMAYGBFUdIAAwCAYGZ4EMAQQBMEMGA1Ud
# HwQ8MDowOKA2oDSGMmh0dHA6Ly9jcmwuY29tb2RvY2EuY29tL0FBQUNlcnRpZmlj
# YXRlU2VydmljZXMuY3JsMDQGCCsGAQUFBwEBBCgwJjAkBggrBgEFBQcwAYYYaHR0
# cDovL29jc3AuY29tb2RvY2EuY29tMA0GCSqGSIb3DQEBDAUAA4IBAQASv6Hvi3Sa
# mES4aUa1qyQKDKSKZ7g6gb9Fin1SB6iNH04hhTmja14tIIa/ELiueTtTzbT72ES+
# BtlcY2fUQBaHRIZyKtYyFfUSg8L54V0RQGf2QidyxSPiAjgaTCDi2wH3zUZPJqJ8
# ZsBRNraJAlTH/Fj7bADu/pimLpWhDFMpH2/YGaZPnvesCepdgsaLr4CnvYFIUoQx
# 2jLsFeSmTD1sOXPUC4U5IOCFGmjhp0g4qdE2JXfBjRkWxYhMZn0vY86Y6GnfrDyo
# XZ3JHFuu2PMvdM+4fvbXg50RlmKarkUT2n/cR/vfw1Kf5gZV6Z2M8jpiUbzsJA8p
# 1FiAhORFe1rYMIIGFDCCA/ygAwIBAgIQeiOu2lNplg+RyD5c9MfjPzANBgkqhkiG
# 9w0BAQwFADBXMQswCQYDVQQGEwJHQjEYMBYGA1UEChMPU2VjdGlnbyBMaW1pdGVk
# MS4wLAYDVQQDEyVTZWN0aWdvIFB1YmxpYyBUaW1lIFN0YW1waW5nIFJvb3QgUjQ2
# MB4XDTIxMDMyMjAwMDAwMFoXDTM2MDMyMTIzNTk1OVowVTELMAkGA1UEBhMCR0Ix
# GDAWBgNVBAoTD1NlY3RpZ28gTGltaXRlZDEsMCoGA1UEAxMjU2VjdGlnbyBQdWJs
# aWMgVGltZSBTdGFtcGluZyBDQSBSMzYwggGiMA0GCSqGSIb3DQEBAQUAA4IBjwAw
# ggGKAoIBgQDNmNhDQatugivs9jN+JjTkiYzT7yISgFQ+7yavjA6Bg+OiIjPm/N/t
# 3nC7wYUrUlY3mFyI32t2o6Ft3EtxJXCc5MmZQZ8AxCbh5c6WzeJDB9qkQVa46xiY
# Epc81KnBkAWgsaXnLURoYZzksHIzzCNxtIXnb9njZholGw9djnjkTdAA83abEOHQ
# 4ujOGIaBhPXG2NdV8TNgFWZ9BojlAvflxNMCOwkCnzlH4oCw5+4v1nssWeN1y4+R
# laOywwRMUi54fr2vFsU5QPrgb6tSjvEUh1EC4M29YGy/SIYM8ZpHadmVjbi3Pl8h
# JiTWw9jiCKv31pcAaeijS9fc6R7DgyyLIGflmdQMwrNRxCulVq8ZpysiSYNi79tw
# 5RHWZUEhnRfs/hsp/fwkXsynu1jcsUX+HuG8FLa2BNheUPtOcgw+vHJcJ8HnJCrc
# UWhdFczf8O+pDiyGhVYX+bDDP3GhGS7TmKmGnbZ9N+MpEhWmbiAVPbgkqykSkzyY
# Vr15OApZYK8CAwEAAaOCAVwwggFYMB8GA1UdIwQYMBaAFPZ3at0//QET/xahbIIC
# L9AKPRQlMB0GA1UdDgQWBBRfWO1MMXqiYUKNUoC6s2GXGaIymzAOBgNVHQ8BAf8E
# BAMCAYYwEgYDVR0TAQH/BAgwBgEB/wIBADATBgNVHSUEDDAKBggrBgEFBQcDCDAR
# BgNVHSAECjAIMAYGBFUdIAAwTAYDVR0fBEUwQzBBoD+gPYY7aHR0cDovL2NybC5z
# ZWN0aWdvLmNvbS9TZWN0aWdvUHVibGljVGltZVN0YW1waW5nUm9vdFI0Ni5jcmww
# fAYIKwYBBQUHAQEEcDBuMEcGCCsGAQUFBzAChjtodHRwOi8vY3J0LnNlY3RpZ28u
# Y29tL1NlY3RpZ29QdWJsaWNUaW1lU3RhbXBpbmdSb290UjQ2LnA3YzAjBggrBgEF
# BQcwAYYXaHR0cDovL29jc3Auc2VjdGlnby5jb20wDQYJKoZIhvcNAQEMBQADggIB
# ABLXeyCtDjVYDJ6BHSVY/UwtZ3Svx2ImIfZVVGnGoUaGdltoX4hDskBMZx5NY5L6
# SCcwDMZhHOmbyMhyOVJDwm1yrKYqGDHWzpwVkFJ+996jKKAXyIIaUf5JVKjccev3
# w16mNIUlNTkpJEor7edVJZiRJVCAmWAaHcw9zP0hY3gj+fWp8MbOocI9Zn78xvm9
# XKGBp6rEs9sEiq/pwzvg2/KjXE2yWUQIkms6+yslCRqNXPjEnBnxuUB1fm6bPAV+
# Tsr/Qrd+mOCJemo06ldon4pJFbQd0TQVIMLv5koklInHvyaf6vATJP4DfPtKzSBP
# kKlOtyaFTAjD2Nu+di5hErEVVaMqSVbfPzd6kNXOhYm23EWm6N2s2ZHCHVhlUgHa
# C4ACMRCgXjYfQEDtYEK54dUwPJXV7icz0rgCzs9VI29DwsjVZFpO4ZIVR33LwXyP
# DbYFkLqYmgHjR3tKVkhh9qKV2WCmBuC27pIOx6TYvyqiYbntinmpOqh/QPAnhDge
# xKG9GX/n1PggkGi9HCapZp8fRwg8RftwS21Ln61euBG0yONM6noD2XQPrFwpm3Gc
# uqJMf0o8LLrFkSLRQNwxPDDkWXhW+gZswbaiie5fd/W2ygcto78XCSPfFWveUOSZ
# 5SqK95tBO8aTHmEa4lpJVD7HrTEn9jb1EGvxOb1cnn0CMIIGGjCCBAKgAwIBAgIQ
# Yh1tDFIBnjuQeRUgiSEcCjANBgkqhkiG9w0BAQwFADBWMQswCQYDVQQGEwJHQjEY
# MBYGA1UEChMPU2VjdGlnbyBMaW1pdGVkMS0wKwYDVQQDEyRTZWN0aWdvIFB1Ymxp
# YyBDb2RlIFNpZ25pbmcgUm9vdCBSNDYwHhcNMjEwMzIyMDAwMDAwWhcNMzYwMzIx
# MjM1OTU5WjBUMQswCQYDVQQGEwJHQjEYMBYGA1UEChMPU2VjdGlnbyBMaW1pdGVk
# MSswKQYDVQQDEyJTZWN0aWdvIFB1YmxpYyBDb2RlIFNpZ25pbmcgQ0EgUjM2MIIB
# ojANBgkqhkiG9w0BAQEFAAOCAY8AMIIBigKCAYEAmyudU/o1P45gBkNqwM/1f/bI
# U1MYyM7TbH78WAeVF3llMwsRHgBGRmxDeEDIArCS2VCoVk4Y/8j6stIkmYV5Gej4
# NgNjVQ4BYoDjGMwdjioXan1hlaGFt4Wk9vT0k2oWJMJjL9G//N523hAm4jF4UjrW
# 2pvv9+hdPX8tbbAfI3v0VdJiJPFy/7XwiunD7mBxNtecM6ytIdUlh08T2z7mJEXZ
# D9OWcJkZk5wDuf2q52PN43jc4T9OkoXZ0arWZVeffvMr/iiIROSCzKoDmWABDRzV
# /UiQ5vqsaeFaqQdzFf4ed8peNWh1OaZXnYvZQgWx/SXiJDRSAolRzZEZquE6cbcH
# 747FHncs/Kzcn0Ccv2jrOW+LPmnOyB+tAfiWu01TPhCr9VrkxsHC5qFNxaThTG5j
# 4/Kc+ODD2dX/fmBECELcvzUHf9shoFvrn35XGf2RPaNTO2uSZ6n9otv7jElspkfK
# 9qEATHZcodp+R4q2OIypxR//YEb3fkDn3UayWW9bAgMBAAGjggFkMIIBYDAfBgNV
# HSMEGDAWgBQy65Ka/zWWSC8oQEJwIDaRXBeF5jAdBgNVHQ4EFgQUDyrLIIcouOxv
# SK4rVKYpqhekzQwwDgYDVR0PAQH/BAQDAgGGMBIGA1UdEwEB/wQIMAYBAf8CAQAw
# EwYDVR0lBAwwCgYIKwYBBQUHAwMwGwYDVR0gBBQwEjAGBgRVHSAAMAgGBmeBDAEE
# ATBLBgNVHR8ERDBCMECgPqA8hjpodHRwOi8vY3JsLnNlY3RpZ28uY29tL1NlY3Rp
# Z29QdWJsaWNDb2RlU2lnbmluZ1Jvb3RSNDYuY3JsMHsGCCsGAQUFBwEBBG8wbTBG
# BggrBgEFBQcwAoY6aHR0cDovL2NydC5zZWN0aWdvLmNvbS9TZWN0aWdvUHVibGlj
# Q29kZVNpZ25pbmdSb290UjQ2LnA3YzAjBggrBgEFBQcwAYYXaHR0cDovL29jc3Au
# c2VjdGlnby5jb20wDQYJKoZIhvcNAQEMBQADggIBAAb/guF3YzZue6EVIJsT/wT+
# mHVEYcNWlXHRkT+FoetAQLHI1uBy/YXKZDk8+Y1LoNqHrp22AKMGxQtgCivnDHFy
# AQ9GXTmlk7MjcgQbDCx6mn7yIawsppWkvfPkKaAQsiqaT9DnMWBHVNIabGqgQSGT
# rQWo43MOfsPynhbz2Hyxf5XWKZpRvr3dMapandPfYgoZ8iDL2OR3sYztgJrbG6VZ
# 9DoTXFm1g0Rf97Aaen1l4c+w3DC+IkwFkvjFV3jS49ZSc4lShKK6BrPTJYs4NG1D
# GzmpToTnwoqZ8fAmi2XlZnuchC4NPSZaPATHvNIzt+z1PHo35D/f7j2pO1S8BCys
# QDHCbM5Mnomnq5aYcKCsdbh0czchOm8bkinLrYrKpii+Tk7pwL7TjRKLXkomm5D1
# Umds++pip8wH2cQpf93at3VDcOK4N7EwoIJB0kak6pSzEu4I64U6gZs7tS/dGNSl
# jf2OSSnRr7KWzq03zl8l75jy+hOds9TWSenLbjBQUGR96cFr6lEUfAIEHVC1L68Y
# 1GGxx4/eRI82ut83axHMViw1+sVpbPxg51Tbnio1lB93079WPFnYaOvfGAA0e0zc
# fF/M9gXr+korwQTh2Prqooq2bYNMvUoUKD85gnJ+t0smrWrb8dee2CvYZXD5laGt
# aAxOfy/VKNmwuWuAh9kcMIIGYjCCBMqgAwIBAgIRAKQpO24e3denNAiHrXpOtyQw
# DQYJKoZIhvcNAQEMBQAwVTELMAkGA1UEBhMCR0IxGDAWBgNVBAoTD1NlY3RpZ28g
# TGltaXRlZDEsMCoGA1UEAxMjU2VjdGlnbyBQdWJsaWMgVGltZSBTdGFtcGluZyBD
# QSBSMzYwHhcNMjUwMzI3MDAwMDAwWhcNMzYwMzIxMjM1OTU5WjByMQswCQYDVQQG
# EwJHQjEXMBUGA1UECBMOV2VzdCBZb3Jrc2hpcmUxGDAWBgNVBAoTD1NlY3RpZ28g
# TGltaXRlZDEwMC4GA1UEAxMnU2VjdGlnbyBQdWJsaWMgVGltZSBTdGFtcGluZyBT
# aWduZXIgUjM2MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA04SV9G6k
# U3jyPRBLeBIHPNyUgVNnYayfsGOyYEXrn3+SkDYTLs1crcw/ol2swE1TzB2aR/5J
# IjKNf75QBha2Ddj+4NEPKDxHEd4dEn7RTWMcTIfm492TW22I8LfH+A7Ehz0/safc
# 6BbsNBzjHTt7FngNfhfJoYOrkugSaT8F0IzUh6VUwoHdYDpiln9dh0n0m545d5A5
# tJD92iFAIbKHQWGbCQNYplqpAFasHBn77OqW37P9BhOASdmjp3IijYiFdcA0WQIe
# 60vzvrk0HG+iVcwVZjz+t5OcXGTcxqOAzk1frDNZ1aw8nFhGEvG0ktJQknnJZE3D
# 40GofV7O8WzgaAnZmoUn4PCpvH36vD4XaAF2CjiPsJWiY/j2xLsJuqx3JtuI4akH
# 0MmGzlBUylhXvdNVXcjAuIEcEQKtOBR9lU4wXQpISrbOT8ux+96GzBq8TdbhoFcm
# YaOBZKlwPP7pOp5Mzx/UMhyBA93PQhiCdPfIVOCINsUY4U23p4KJ3F1HqP3H6Slw
# 3lHACnLilGETXRg5X/Fp8G8qlG5Y+M49ZEGUp2bneRLZoyHTyynHvFISpefhBCV0
# KdRZHPcuSL5OAGWnBjAlRtHvsMBrI3AAA0Tu1oGvPa/4yeeiAyu+9y3SLC98gDVb
# ySnXnkujjhIh+oaatsk/oyf5R2vcxHahajMCAwEAAaOCAY4wggGKMB8GA1UdIwQY
# MBaAFF9Y7UwxeqJhQo1SgLqzYZcZojKbMB0GA1UdDgQWBBSIYYyhKjdkgShgoZsx
# 0Iz9LALOTzAOBgNVHQ8BAf8EBAMCBsAwDAYDVR0TAQH/BAIwADAWBgNVHSUBAf8E
# DDAKBggrBgEFBQcDCDBKBgNVHSAEQzBBMDUGDCsGAQQBsjEBAgEDCDAlMCMGCCsG
# AQUFBwIBFhdodHRwczovL3NlY3RpZ28uY29tL0NQUzAIBgZngQwBBAIwSgYDVR0f
# BEMwQTA/oD2gO4Y5aHR0cDovL2NybC5zZWN0aWdvLmNvbS9TZWN0aWdvUHVibGlj
# VGltZVN0YW1waW5nQ0FSMzYuY3JsMHoGCCsGAQUFBwEBBG4wbDBFBggrBgEFBQcw
# AoY5aHR0cDovL2NydC5zZWN0aWdvLmNvbS9TZWN0aWdvUHVibGljVGltZVN0YW1w
# aW5nQ0FSMzYuY3J0MCMGCCsGAQUFBzABhhdodHRwOi8vb2NzcC5zZWN0aWdvLmNv
# bTANBgkqhkiG9w0BAQwFAAOCAYEAAoE+pIZyUSH5ZakuPVKK4eWbzEsTRJOEjbIu
# 6r7vmzXXLpJx4FyGmcqnFZoa1dzx3JrUCrdG5b//LfAxOGy9Ph9JtrYChJaVHrus
# Dh9NgYwiGDOhyyJ2zRy3+kdqhwtUlLCdNjFjakTSE+hkC9F5ty1uxOoQ2ZkfI5WM
# 4WXA3ZHcNHB4V42zi7Jk3ktEnkSdViVxM6rduXW0jmmiu71ZpBFZDh7Kdens+PQX
# PgMqvzodgQJEkxaION5XRCoBxAwWwiMm2thPDuZTzWp/gUFzi7izCmEt4pE3Kf0M
# Ot3ccgwn4Kl2FIcQaV55nkjv1gODcHcD9+ZVjYZoyKTVWb4VqMQy/j8Q3aaYd/jO
# Q66Fhk3NWbg2tYl5jhQCuIsE55Vg4N0DUbEWvXJxtxQQaVR5xzhEI+BjJKzh3TQ0
# 26JxHhr2fuJ0mV68AluFr9qshgwS5SpN5FFtaSEnAwqZv3IS+mlG50rK7W3qXbWw
# i4hmpylUfygtYLEdLQukNEX1jiOKMIIGazCCBNOgAwIBAgIRAIxBnpO/K86siAYo
# O3YZvTwwDQYJKoZIhvcNAQEMBQAwVDELMAkGA1UEBhMCR0IxGDAWBgNVBAoTD1Nl
# Y3RpZ28gTGltaXRlZDErMCkGA1UEAxMiU2VjdGlnbyBQdWJsaWMgQ29kZSBTaWdu
# aW5nIENBIFIzNjAeFw0yNDExMTQwMDAwMDBaFw0yNzExMTQyMzU5NTlaMFcxCzAJ
# BgNVBAYTAkRFMRYwFAYDVQQIDA1OaWVkZXJzYWNoc2VuMRcwFQYDVQQKDA5NYXJ0
# aW4gV2lsbGluZzEXMBUGA1UEAwwOTWFydGluIFdpbGxpbmcwggIiMA0GCSqGSIb3
# DQEBAQUAA4ICDwAwggIKAoICAQDRn27mnIzB6dsJFLMexQQNRd8aMv73DTla68G6
# Q8u+V2TY1JQ/Z4j2oCI9ATW3K3P7NAPdlE0QmtdjC0F/74jsfil/i8LwxuyT034w
# abViZKUcodmKsEFhM9am8W5kUgLuC5FIK4wNOq5TfzYdHTyJu1eR2XuSDoMp0wg4
# 5mOuFNBbYB8DVBtHxobvWq4eCs3lUxX07wR3Qr2Utb92w8eU2vKr2Ss9xIh/YvM4
# UxgBpO1I6O+W2tAB5mmynIgoCfX7mu6iD3A+AhpQ9Gv209G83y8FPrFJIWU77TTe
# hErbPjZ074xXwrlEkhnGUCk1w+KiNtZHaSn0X+vnhqJ7otBxQZQAESlhWXpDKCun
# nnVnVgwvVWtccAhxZO95eif6Vss/UhCaBZ26szlneGtFeTClI4+k3mqfWuodtXjH
# c8ohAclWp7XVywliwhCFEsAcFkpkCyivey0sqEfrwiMnRy1elH1S37XcQaav5+bt
# 4KxtIXuOVEx3vM9MHdlraW0y1on5E8i4tagdI45TH0LU080ubc2MKqq6ZXtplTu1
# wdF2Cgy3hfSSLkJscRWApvpvOO6Vtc4jTG/AO6iqN5M6Swd+g40XtsxBD/gSk9kM
# qkgJ1pD1Gp5gkHnP1veut+YgJ9xWcRDJI7vcis9qsXwtVybeOCh56rTQvC/Tf6BJ
# tiieEQIDAQABo4IBszCCAa8wHwYDVR0jBBgwFoAUDyrLIIcouOxvSK4rVKYpqhek
# zQwwHQYDVR0OBBYEFIxyZAmEHl7uAfEwbB4nzI8MCCLbMA4GA1UdDwEB/wQEAwIH
# gDAMBgNVHRMBAf8EAjAAMBMGA1UdJQQMMAoGCCsGAQUFBwMDMEoGA1UdIARDMEEw
# NQYMKwYBBAGyMQECAQMCMCUwIwYIKwYBBQUHAgEWF2h0dHBzOi8vc2VjdGlnby5j
# b20vQ1BTMAgGBmeBDAEEATBJBgNVHR8EQjBAMD6gPKA6hjhodHRwOi8vY3JsLnNl
# Y3RpZ28uY29tL1NlY3RpZ29QdWJsaWNDb2RlU2lnbmluZ0NBUjM2LmNybDB5Bggr
# BgEFBQcBAQRtMGswRAYIKwYBBQUHMAKGOGh0dHA6Ly9jcnQuc2VjdGlnby5jb20v
# U2VjdGlnb1B1YmxpY0NvZGVTaWduaW5nQ0FSMzYuY3J0MCMGCCsGAQUFBzABhhdo
# dHRwOi8vb2NzcC5zZWN0aWdvLmNvbTAoBgNVHREEITAfgR1td2lsbGluZ0BsZXRo
# YWwtZm9yZW5zaWNzLmNvbTANBgkqhkiG9w0BAQwFAAOCAYEAZ0dBMMwluWGb+MD1
# rGWaPtaXrNZnlZqOZxgbdrMLBKAQr0QGcILCVIZ4SZYaevT5yMR6jFGSAjgaFtnk
# 8ZpbtGwig/ed/C/D1Ne8SZyffdtALns/5CHxMnU8ks7ut7dsR6zFD4/bmljuoUoi
# 55W6/XU/1pr+tqRaZGJvjSKJQCN9MhFAvXSpPPqRsj27ze1+KYIBF1/L0BW0HS0d
# 9ZhGSUoEwqMDLpQf2eqJFyyyzWt21VVhLF6mgZ1dE5tCLZY7ERzx6/h5N7F0w361
# oigizMbCMdST29XOc5mB8q6Cye7OmEfM2jByRWa+cd4RycsN2p2wHRukpq48iX+t
# PVKmHwNKf+upuKPDQAeV4J7gUCtevIsOtoyiC2+amimu81o424Dl+NsAyCLz0SXv
# NAhVvtU73H61gtoPa/SWouem2S+bzp7oGvGPop/9mh4CXki6LVeDH3hDM8hZsJg/
# EToIWiDozTc2yWqwV4Ozyd4x5Ix8lckXMgWuyWcxmLK1RmKpMIIGgjCCBGqgAwIB
# AgIQNsKwvXwbOuejs902y8l1aDANBgkqhkiG9w0BAQwFADCBiDELMAkGA1UEBhMC
# VVMxEzARBgNVBAgTCk5ldyBKZXJzZXkxFDASBgNVBAcTC0plcnNleSBDaXR5MR4w
# HAYDVQQKExVUaGUgVVNFUlRSVVNUIE5ldHdvcmsxLjAsBgNVBAMTJVVTRVJUcnVz
# dCBSU0EgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwHhcNMjEwMzIyMDAwMDAwWhcN
# MzgwMTE4MjM1OTU5WjBXMQswCQYDVQQGEwJHQjEYMBYGA1UEChMPU2VjdGlnbyBM
# aW1pdGVkMS4wLAYDVQQDEyVTZWN0aWdvIFB1YmxpYyBUaW1lIFN0YW1waW5nIFJv
# b3QgUjQ2MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAiJ3YuUVnnR3d
# 6LkmgZpUVMB8SQWbzFoVD9mUEES0QUCBdxSZqdTkdizICFNeINCSJS+lV1ipnW5i
# hkQyC0cRLWXUJzodqpnMRs46npiJPHrfLBOifjfhpdXJ2aHHsPHggGsCi7uE0awq
# KggE/LkYw3sqaBia67h/3awoqNvGqiFRJ+OTWYmUCO2GAXsePHi+/JUNAax3kpqs
# tbl3vcTdOGhtKShvZIvjwulRH87rbukNyHGWX5tNK/WABKf+Gnoi4cmisS7oSimg
# HUI0Wn/4elNd40BFdSZ1EwpuddZ+Wr7+Dfo0lcHflm/FDDrOJ3rWqauUP8hsokDo
# I7D/yUVI9DAE/WK3Jl3C4LKwIpn1mNzMyptRwsXKrop06m7NUNHdlTDEMovXAIDG
# AvYynPt5lutv8lZeI5w3MOlCybAZDpK3Dy1MKo+6aEtE9vtiTMzz/o2dYfdP0KWZ
# wZIXbYsTIlg1YIetCpi5s14qiXOpRsKqFKqav9R1R5vj3NgevsAsvxsAnI8Oa5s2
# oy25qhsoBIGo/zi6GpxFj+mOdh35Xn91y72J4RGOJEoqzEIbW3q0b2iPuWLA911c
# RxgY5SJYubvjay3nSMbBPPFsyl6mY4/WYucmyS9lo3l7jk27MAe145GWxK4O3m3g
# EFEIkv7kRmefDR7Oe2T1HxAnICQvr9sCAwEAAaOCARYwggESMB8GA1UdIwQYMBaA
# FFN5v1qqK0rPVIDh2JvAnfKyA2bLMB0GA1UdDgQWBBT2d2rdP/0BE/8WoWyCAi/Q
# Cj0UJTAOBgNVHQ8BAf8EBAMCAYYwDwYDVR0TAQH/BAUwAwEB/zATBgNVHSUEDDAK
# BggrBgEFBQcDCDARBgNVHSAECjAIMAYGBFUdIAAwUAYDVR0fBEkwRzBFoEOgQYY/
# aHR0cDovL2NybC51c2VydHJ1c3QuY29tL1VTRVJUcnVzdFJTQUNlcnRpZmljYXRp
# b25BdXRob3JpdHkuY3JsMDUGCCsGAQUFBwEBBCkwJzAlBggrBgEFBQcwAYYZaHR0
# cDovL29jc3AudXNlcnRydXN0LmNvbTANBgkqhkiG9w0BAQwFAAOCAgEADr5lQe1o
# RLjlocXUEYfktzsljOt+2sgXke3Y8UPEooU5y39rAARaAdAxUeiX1ktLJ3+lgxto
# LQhn5cFb3GF2SSZRX8ptQ6IvuD3wz/LNHKpQ5nX8hjsDLRhsyeIiJsms9yAWnvdY
# OdEMq1W61KE9JlBkB20XBee6JaXx4UBErc+YuoSb1SxVf7nkNtUjPfcxuFtrQdRM
# Ri/fInV/AobE8Gw/8yBMQKKaHt5eia8ybT8Y/Ffa6HAJyz9gvEOcF1VWXG8OMeM7
# Vy7Bs6mSIkYeYtddU1ux1dQLbEGur18ut97wgGwDiGinCwKPyFO7ApcmVJOtlw9F
# VJxw/mL1TbyBns4zOgkaXFnnfzg4qbSvnrwyj1NiurMp4pmAWjR+Pb/SIduPnmFz
# bSN/G8reZCL4fvGlvPFk4Uab/JVCSmj59+/mB2Gn6G/UYOy8k60mKcmaAZsEVkhO
# Fuoj4we8CYyaR9vd9PGZKSinaZIkvVjbH/3nlLb0a7SBIkiRzfPfS9T+JesylbHa
# 1LtRV9U/7m0q7Ma2CQ/t392ioOssXW7oKLdOmMBl14suVFBmbzrt5V5cQPnwtd3U
# OTpS9oCG+ZZheiIvPgkDmA8FzPsnfXW5qHELB43ET7HHFHeRPRYrMBKjkb8/IN7P
# o0d0hQoF4TeMM+zYAJzoKQnVKOLg8pZVPT8xggYxMIIGLQIBATBpMFQxCzAJBgNV
# BAYTAkdCMRgwFgYDVQQKEw9TZWN0aWdvIExpbWl0ZWQxKzApBgNVBAMTIlNlY3Rp
# Z28gUHVibGljIENvZGUgU2lnbmluZyBDQSBSMzYCEQCMQZ6TvyvOrIgGKDt2Gb08
# MAkGBSsOAwIaBQCgeDAYBgorBgEEAYI3AgEMMQowCKACgAChAoAAMBkGCSqGSIb3
# DQEJAzEMBgorBgEEAYI3AgEEMBwGCisGAQQBgjcCAQsxDjAMBgorBgEEAYI3AgEV
# MCMGCSqGSIb3DQEJBDEWBBSOk2rT5AVmoXYhpDmBnaZ47+AmLzANBgkqhkiG9w0B
# AQEFAASCAgBtx77RTkMAJOnQhFI11zpgtt6XHyWMLZGre2ZuxCE4H3y2siixX0Dx
# 2KkAE3aj6A9YEwxFUHus3+DLvGwI7265waG/YHbBXYWfK/G6eWogl4ixQ1/SBJBZ
# CGyzpcGPAFE6ujUwI/h46vGmKBn+yGaNV53owUwMswoJHNcC6H4Kjk7LfD6hQZ2M
# dXzWQLPqLe/ZC4GBZ0LQE6/H/Zm957lAPRWp0DqIXGQXYmnr1NndeuwdaRKc0WKq
# 4zyDZ+vuLuoWsS50kvf0K741v25lnH1GtzunbznfA8U/qZ3yl7rq2oi6z52OpFQJ
# hlDZyb2EaOu3gtnXMspgfpZt767UMDmQZZh4fMkkD4qmX1+do1R9ahup+L/j5uAC
# yeUcNfq+ga5I3bnnIoC2tNIAZXxYYmp86pKoKwh/sF4i+OAaDO+FITUGuKVVtDb6
# zckU2yQDywIoci6eox0P6tIQjq3pWl048WS/NUGdRKSNbf1HmMguAKOO2FBmSglN
# FIYmlSb8x2a7kns/Ermo/e1ZwI4poKUHmKKD5O7gHwTsdCIMI2AOq20wrCD3504a
# OvaHfO5SgJwm35TCg1EXvd3+Bh09dmANZj+PJBe+IwU0A5oLP5GtQFaNRAlFibxY
# GbfuBHDbUerXVTnj6Zi37AEJDAgBSdrXqDs6zUzKAQucagJGvhHIOKGCAyMwggMf
# BgkqhkiG9w0BCQYxggMQMIIDDAIBATBqMFUxCzAJBgNVBAYTAkdCMRgwFgYDVQQK
# Ew9TZWN0aWdvIExpbWl0ZWQxLDAqBgNVBAMTI1NlY3RpZ28gUHVibGljIFRpbWUg
# U3RhbXBpbmcgQ0EgUjM2AhEApCk7bh7d16c0CIetek63JDANBglghkgBZQMEAgIF
# AKB5MBgGCSqGSIb3DQEJAzELBgkqhkiG9w0BBwEwHAYJKoZIhvcNAQkFMQ8XDTI1
# MDYyNDA0NTUwN1owPwYJKoZIhvcNAQkEMTIEMKCShb27aBzKPoEQ2DrvsEa6Igsu
# JYLqMDozG0uCPaE8N8KTLDE9jN3NtffMq2G6YjANBgkqhkiG9w0BAQEFAASCAgA4
# IkAT2v+boXT0BWwMZOk1aPFIVsC5MkVsTsuznN1NjDm22spMEO1m0fiLZTdLF4iy
# jgg3pWTpf01XZiXNaDOVxoYnW3AOqEHrzsp0VGLXFaDbPFDBAVLBL7nADQXqOgEF
# heR50n8LqkHCvOOFH6VYi2VOG7k3kr6vVbtnaInyU0VqhwZd4g8xUEFoh7xcLxwJ
# p5zxFPkW2V3+tJh5AlVOm+5VSUbmVjgMKse5TQqcZGbUif8Xjcmd5thzYNMK/TJT
# gqP4GL3BoL8UdiIv1HbA/E0eO5NLzdNyn6YU6s3SuZ3YkqG2Wqwmht/I/6tP62G5
# 6cAe7/Z/f1PzMDBvz3OUswd42hzKAOgMHGPQCk5a/RS8loPwptwin3rsh8wg+WQ1
# VhOzufrXPUhYf/qWJDJbFej64TcmVAYEUgVcXuelauZt+Tys13U6pcKUnd9QgG6B
# 3wBMx4YdTooOn19HXUkE7sPL/6xZs62RcHjg6FS0Jdi7mDJDS9xlPmRWdpA8PlJK
# mbolUBD5QKoeRzwp9bnKfTSyAaUFigbxemcqEanXxREXvgjRlOMs1p1YbgklYW/7
# +WIvpo9qWGG1f4yc1vMPxZnpbswJXdP39o5DL+2TA3PHT+0sxxD76RgwxV8Muqf+
# i1VY4ME9hPTlZQzYU2y7xRI+9kVGltTvFhO4/DhoTw==
# SIG # End signature block

```

`Tools/RECmd_BatchFiles/AdobeRecentFiles.reb`:

```reb
Description: Adobe RecentFiles - RECmd batch file
Author: Martin Willing
Version: 1
Id: ab13eb5f-11db-5cdc-c3df-88ec86dc18
Keys:
    -
        Description: Historical information of files accessed by Adobe Reader.
        HiveType: NTUSER
        Category: User Activity
        KeyPath: Software\Adobe\Acrobat Reader\DC\AVGeneral\cRecentFolders\*
        Recursive: false
```

`Tools/RECmd_BatchFiles/BAM.reb`:

```reb
Description: BAM/DAM - RECmd batch file
Author: Martin Willing
Version: 1
Id: ab13eb6f-31db-5cdc-83df-88ec86dc17
Keys:
    -
        Description: Windows Background Activity Moderator (BAM)
        HiveType: SYSTEM
        Category: Program Execution
        KeyPath: ControlSet*\Services\bam\State\UserSettings\*
        Recursive: false
    -
        Description: Windows Background Activity Moderator (BAM)
        HiveType: SYSTEM
        Category: Program Execution
        KeyPath: ControlSet*\Services\bam\UserSettings\*
        Recursive: false
    -
        Description: Windows Desktop Activity Moderator (DAM)
        HiveType: SYSTEM
        Category: Program Execution
        KeyPath: ControlSet*\Services\dam\State\UserSettings\*
        Recursive: false
    -
        Description: Windows Desktop Activity Moderator (DAM)
        HiveType: SYSTEM
        Category: Program Execution
        KeyPath: ControlSet*\Services\dam\UserSettings\*
        Recursive: false
```

`Tools/RECmd_BatchFiles/LastVisitedPidlMRU.reb`:

```reb
Description: LastVisitedMRU - RECmd batch file
Author: Martin Willing
Version: 1
Id: ab16eb5f-31db-5cdc-83df-88ec83d61b
Keys:
    -
        Description: LastVisitedPidlMRU
        HiveType: NTUSER
        Category: User Activity
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Explorer\ComDlg32\LastVisitedPidlMRU
        Recursive: false
        Comment: "Tracks the specific executable used by an application to open the files documented in OpenSavePidlMRU"
```

`Tools/RECmd_BatchFiles/MUICache.reb`:

```reb
Description: MUICache - RECmd batch file
Author: Martin Willing
Version: 1
Id: ab13d65f-31db-5cdc-83df-88ec83dc17
Keys:
    -
        Description: MuiCache (Vista+)
        HiveType: UsrClass
        Category: Program Execution
        KeyPath: Local Settings\Software\Microsoft\Windows\Shell\MuiCache
        Recursive: false

    -
        Description: MuiCache (2000/XP/2003)
        HiveType: UsrClass
        Category: Program Execution
        KeyPath: Software\Microsoft\Windows\ShellNoRoam\MUICache
        Recursive: false
```

`Tools/RECmd_BatchFiles/OpenSavePidlMRU.reb`:

```reb
Description: OpenSaveMRU - RECmd batch file
Author: Martin Willing
Version: 1
Id: ab13eb5f-31db-5cdc-83df-88ec83d617
Keys:
    -
        Description: OpenSavePidlMRU
        HiveType: NTUSER
        Category: User Activity
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Explorer\ComDlg32\OpenSavePidlMRU
        Recursive: false
        Comment: "Tracks files that have been opened or saved within a Windows shell dialog box"
```

`Tools/RECmd_BatchFiles/RecentDocs.reb`:

```reb
Description: RecentDocs - RECmd batch file
Author: Martin Willing
Version: 1
Id: ab13eb5f-31db-5cdc-83df-88ec86dc18
Keys:
    -
        Description: Registry Key that will track the last files and folders opened and is used to populate data in "Recent" menus of the Start menu. 
        HiveType: NTUSER
        Category: User Activity
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Explorer\RecentDocs
        Recursive: true
```

`Tools/RECmd_BatchFiles/RegistryASEPs.reb`:

```reb
Description: Registry ASEPs
Author: Troy Larson
Version: 1
Id: d6b50e3a-291c-4d8a-afbc-4dd05d252742
Keys:
    -
        Description: Select ControlSet
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: Select
        Recursive: false
        Comment:
    -
        Description: ServiceControlManagerExtension
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Control
        ValueName: ServiceControlManagerExtension
        Recursive: false
        Comment:
    -
        Description: BootVerificationProgram
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Control\BootVerificationProgram
        ValueName: Imagepath
        Recursive: false
        Comment:
    -
        Description: LSA Authentication Packages
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Control\LSA
        ValueName: Authentication Packages
        Recursive: false
        Comment: 
    -
        Description: LSA Notification Packages
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Control\LSA
        ValueName: Notification Packages
        Recursive: false
        Comment: 
    -
        Description: LSA Security Packages
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Control\LSA
        ValueName: Security Packages
        Recursive: false
        Comment: 
    -
        Description: LSA OsConfig
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Control\LSA\OsConfig
        ValueName: Security Packages
        Recursive: false
        Comment: 
    -
        Description: NetworkProvider Order
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: \ControlSet*\Control\NetworkProvider\*
        ValueName: ProviderOrder
        Recursive: true
        Comment: 
    -
        Description: Print Driver
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Control\Print\Monitors\*
        ValueName: Driver
        Recursive: true
        Comment: 
    -
        Description: Print Providers
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Control\Print\Providers\*
        ValueName: Name
        Recursive: true
        Comment: 
    -
        Description: SafeBoot
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: \ControlSet*\Control\SafeBoot
        ValueName: AlternateShell
        Recursive: false
        Comment: 
    -
        Description: SafeBoot Minimal
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Control\SafeBoot\Minimal\*
        ValueName: (default)
        Recursive: true
        Comment: 
    -
        Description: SafeBoot Network
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Control\SafeBoot\Network\*
        ValueName: (default)
        Recursive: true
        Comment: 
    -
        Description: SecurityProviders
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Control\SecurityProviders
        ValueName: SecurityProviders
        Recursive: false
        Comment: 
    -
        Description: Session Manager BootExecute
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Control\Session Manager
        ValueName: BootExecute
        Recursive: false
        Comment: 
    -
        Description: Session Manager BootShell
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Control\Session Manager
        ValueName: BootShell
        Recursive: false
        Comment: 
    -
        Description: Session Manager Execute
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Control\Session Manager
        ValueName: Execute
        Recursive: false
        Comment: 
    -
        Description: Session Manager InitialCommand
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Control\Session Manager
        ValueName: InitialCommand
        Recursive: false
        Comment: 
    -
        Description: Session Manager InitialCommand
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Control\Session Manager
        ValueName: "*InitialCommand"
        Recursive: false
        Comment: 
    -
        Description: Session Manager PendingFileRenameOperations
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Control\Session Manager
        ValueName: PendingFileRenameOperations
        Recursive: false
        Comment: 
    -
        Description: Session Manager PendingFileRenameOperations*
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Control\Session Manager
        ValueName: PendingFileRenameOperations*
        Recursive: false
        Comment: 
    -
        Description: Session Manager SETUPEXECUTE
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Control\Session Manager
        ValueName: SetUpExecute
        Recursive: false
        Comment: 
    -
        Description: Session Manager KnownDLLs
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Control\Session Manager\KnownDLLs
        Recursive: false
        Comment: 
    -
        Description: Session Manager SubSystems
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Control\Session Manager\SubSystems
        Recursive: false
        Comment: 
    -
        Description: Terminal Server StartupPrograms
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Control\Terminal Server\Wds\rdpwd
        ValueName: StartupPrograms
        Recursive: false
        Comment: 
    -
        Description: Terminal Server WinStations RDP-Tcp
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: \ControlSet*\Control\Terminal Server\WinStations\RDP-Tcp\TSMMRemotingAllowedApps
        Recursive: false
        Comment: 
    -
        Description: WOW KnownDLLs
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Control\WOW
        ValueName: KnownDLLs
        Recursive: false
        Comment: 
    -
        Description: Services AutoRun
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\*
        ValueName: AutoRun
        Recursive: true
        Comment: 
    -
        Description: Services BootFlags
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\*
        ValueName: BootFlags
        Recursive: true
        Comment: 
    -
        Description: Services DelayedAutoStart
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\*
        ValueName: DelayedAutoStart
        Recursive: true
        Comment: 
    -
        Description: Services DependOnService
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\*
        ValueName: DependOnService
        Recursive: true
        Comment: 
    -
        Description: Services Description
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\*
        ValueName: Description
        Recursive: true
        Comment: 
    -
        Description: Services DisplayName
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\*
        ValueName: DisplayName
        Recursive: true
        Comment: 
    -
        Description: Services ErrorControl
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\*
        ValueName: ErrorControl
        Recursive: true
        Comment: 
    -
        Description: Services Group
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\*
        ValueName: Group
        Recursive: true
        Comment: 
    -
        Description: Services ImagePath
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\*
        ValueName: ImagePath
        Recursive: true
        Comment: 
    -
        Description: Services Library
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\*
        ValueName: Library
        Recursive: true
        Comment: 
    -
        Description: Services ObjectName
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\*
        ValueName: ObjectName
        Recursive: true
        Comment: 
    -
        Description: Services ProviderPath
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\*
        ValueName: ProviderPath
        Recursive: true
        Comment: 
    -
        Description: Services ProxyDllFile
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\*
        ValueName: ProxyDllFile
        Recursive: true
        Comment: 
    -
        Description: Services RequiredPrivileges
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\*
        ValueName: RequiredPrivileges
        Recursive: true
        Comment: 
    -
        Description: Services ServiceDll
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\*
        ValueName: ServiceDll
        Recursive: true
        Comment: 
    -
        Description: Services ServiceMain
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\*
        ValueName: ServiceMain
        Recursive: true
        Comment: 
    -
        Description: Services ServiceSidType
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\*
        ValueName: ServiceSidType
        Recursive: true
        Comment: 
    -
        Description: Services Start
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\*
        ValueName: Start
        Recursive: true
        Comment: 
    -
        Description: Services Type
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\*
        ValueName: Type
        Recursive: true
        Comment: 
    -
        Description: WinSock2 AppId_Catalog AppFullPath
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\WinSock2\Parameters\AppId_Catalog\*
        ValueName: AppFullPath
        Recursive: false
        Comment: 
    -
        Description: WinSock2 AppId_Catalog AppArgs
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\WinSock2\Parameters\AppId_Catalog\*
        ValueName: AppArgs
        Recursive: false
        Comment: 
    -
        Description: WinSock2 NameSpace_Catalog5 DisplayString
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\WinSock2\Parameters\NameSpace_Catalog5\Catalog_Entries\*
        ValueName: DisplayString
        Recursive: false
        Comment: 
    -
        Description: WinSock2 NameSpace_Catalog5 Enabled
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\WinSock2\Parameters\NameSpace_Catalog5\Catalog_Entries\*
        ValueName: Enabled
        Recursive: false
        Comment: 
    -
        Description: WinSock2 NameSpace_Catalog5 LibraryPath
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\WinSock2\Parameters\NameSpace_Catalog5\Catalog_Entries\*
        ValueName: LibraryPath
        Recursive: false
        Comment: 
    -
        Description: WinSock2 NameSpace_Catalog5 64 DisplayString
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\WinSock2\Parameters\NameSpace_Catalog5\Catalog_Entries64\*
        ValueName: DisplayString
        Recursive: false
        Comment: 
    -
        Description: WinSock2 NameSpace_Catalog5 64 Enabled
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\WinSock2\Parameters\NameSpace_Catalog5\Catalog_Entries64\*
        ValueName: Enabled
        Recursive: false
        Comment: 
    -
        Description: WinSock2 NameSpace_Catalog5 64 LibraryPath
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\WinSock2\Parameters\NameSpace_Catalog5\Catalog_Entries64\*
        ValueName: LibraryPath
        Recursive: false
        Comment: 
    -
        Description: WinSock2 Protocol_Catalog9 ProtocolName
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\WinSock2\Parameters\Protocol_Catalog9\Catalog_Entries\*
        ValueName: ProtocolName
        Recursive: false
        Comment: 
    -
        Description: WinSock2 Protocol_Catalog9 64 ProtocolName
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: ControlSet*\Services\WinSock2\Parameters\Protocol_Catalog9\Catalog_Entries64\*
        ValueName: ProtocolName
        Recursive: false
        Comment: 
    -
        Description: Setup
        HiveType: SYSTEM
        Category: ASEP
        KeyPath: Setup
        ValueName: CmdLine
        Recursive: false
        Comment: 
    -
        Description: .cmd
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\.cmd
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: .cmd PersistentHandler
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\.cmd\PersistentHandler
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: .exe
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\.exe
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: .exe PersistentHandler
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\.exe\PersistentHandler
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: shell Open Command
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\*\shell
        ValueName: DelegateExecute
        Recursive: true
        Comment:
    -
        Description: shell Runas command
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\*\shell
        ValueName: IsolatedCommand
        Recursive: true
        Comment: 
    -
        Description: ShellEx ColumnHandlers
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\*\ShellEx\ColumnHandlers
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: ShellEx ContextMenuHandlers
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\*\ShellEx\ContextMenuHandlers
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: shellex ContextMenuHandlers InstallFont
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\*\shellex\ContextMenuHandlers\InstallFont
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: shellex ContextMenuHandlers Open With
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\*\shellex\ContextMenuHandlers\Open With
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: shellex ContextMenuHandlers Open With EncryptionMenu
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\*\shellex\ContextMenuHandlers\Open With EncryptionMenu
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: ShellEx ContextMenuHandlers OpenContainingFolderMenu
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\*\ShellEx\ContextMenuHandlers\OpenContainingFolderMenu
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: shellex ContextMenuHandlers PlayTo
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\*\shellex\ContextMenuHandlers\PlayTo
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: ShellEx CopyHookHandlers
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\*\ShellEx\CopyHookHandlers
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: ShellEx DragDropHandlers
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\*\ShellEx\DragDropHandlers
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: ShellEx ExtShellFolderViews
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\*\ShellEx\ExtShellFolderViews
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: ShellEX IconHandler
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\*\ShellEX\IconHandler
        Recursive: false
        Comment: 
    -
        Description: ShellEx PropertySheetHandlers
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\*\ShellEx\PropertySheetHandlers
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: CLSID InprocServer32
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\CLSID\*\InprocServer32
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: CLSID InprocServer32
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\CLSID\*\InprocServer32
        ValueName: Assembly
        Recursive: false
        Comment: 
    -
        Description: CLSID Instance CLSID
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\CLSID\*\Instance
        ValueName: CLSID
        Recursive: true
        Comment: 
    -
        Description: CLSID Instance FriendlyName
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\CLSID\*\Instance
        ValueName: FriendlyName
        Recursive: true
        Comment: 
    -
        Description: CLSID LocalServer32
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\CLSID\*\LocalServer32
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: CLSID LocalServer32
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\CLSID\*\LocalServer32
        ValueName: Assembly
        Recursive: false
        Comment: 
    -
        Description: CLSID PersistentHandler
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\CLSID\*\PersistentHandler
        Recursive: false
        Comment: 
    -
        Description: CLSID TypeLib
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\CLSID\*\TypeLib
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: cmdfile shell open command
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\cmdfile\shell\open\command
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Directory background shellex ContextMenuHandlers
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Directory\background\shellex\ContextMenuHandlers\*
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Directory shellex CopyHookHandlers
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Directory\shellex\CopyHookHandlers\*
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Directory shellex DragDropHandlers
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Directory\shellex\DragDropHandlers\*
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Directory shellex PropertySheetHandlers
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Directory\shellex\PropertySheetHandlers\*
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Drive shellex ContextMenuHandlers
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Drive\shellex\ContextMenuHandlers\*
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Exefile Shell Open Command
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Exefile\Shell\Open\Command
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Classes Filter
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Filter
        Recursive: true
        Comment: 
    -
        Description: Folder shellex ContextMenuHandlers
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Folder\shellex\ContextMenuHandlers\*
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Folder shellex DragDropHandlers
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Folder\shellex\DragDropHandlers\*
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Folder shellex PropertySheetHandlers
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Folder\shellex\PropertySheetHandlers\*
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: htmlfile shell open command
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\htmlfile\shell\open\command
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Interface ProxyStubClsid32
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Interface\*\ProxyStubClsid32
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Interface TypeLib
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Interface\*\TypeLib
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Protocols Filter
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Protocols\Filter\*
        ValueName: CLSID
        Recursive: false
        Comment: 
    -
        Description: Protocols Handler
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Protocols\Handler\*
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Protocols Handler
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Protocols\Handler\*
        ValueName: CLSID
        Recursive: false
        Comment: 
    -
        Description: Protocols Name-Space Handler
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Protocols\Name-Space Handler\*
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Protocols Name-Space Handler
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Protocols\Name-Space Handler\*
        ValueName: CLSID
        Recursive: false
        Comment: 
    -
        Description: SystemFileAssociations ShellEx ContextMenuHandlers ShellImagePreview
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\SystemFileAssociations\*\ShellEx\ContextMenuHandlers\ShellImagePreview
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: TypeLib win32
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\TypeLib\*\*\*\win32
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: TypeLib win64
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\TypeLib\*\*\*\win64
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432 shell Open Command
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Wow6432Node\*\shell
        ValueName: DelegateExecute
        Recursive: true
        Comment:
    -
        Description: Wow6432 shell Runas command
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Wow6432Node\*\shell
        ValueName: IsolatedCommand
        Recursive: true
        Comment: 
    -
        Description: Wow6432 ShellEx ColumnHandlers
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\Wow6432Node\*\ShellEx\ColumnHandlers
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432 ShellEx ContextMenuHandlers
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\Wow6432Node\*\ShellEx\ContextMenuHandlers
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432 shellex ContextMenuHandlers InstallFont
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Wow6432Node\*\shellex\ContextMenuHandlers\InstallFont
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432 shellex ContextMenuHandlers Open With
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Wow6432Node\*\shellex\ContextMenuHandlers\Open With
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432 shellex ContextMenuHandlers Open With EncryptionMenu
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Wow6432Node\*\shellex\ContextMenuHandlers\Open With EncryptionMenu
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432 ShellEx ContextMenuHandlers OpenContainingFolderMenu
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Wow6432Node\*\ShellEx\ContextMenuHandlers\OpenContainingFolderMenu
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432 shellex ContextMenuHandlers PlayTo
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Wow6432Node\*\shellex\ContextMenuHandlers\PlayTo
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432 ShellEx CopyHookHandlers
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\Wow6432Node\*\ShellEx\CopyHookHandlers
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432 ShellEx DragDropHandlers
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\Wow6432Node\*\ShellEx\DragDropHandlers
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432 ShellEx ExtShellFolderViews
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\Wow6432Node\*\ShellEx\ExtShellFolderViews
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432 ShellEX IconHandler
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Wow6432Node\*\ShellEX\IconHandler
        Recursive: false
        Comment: 
    -
        Description: Wow6432 ShellEx PropertySheetHandlers
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\Wow6432Node\*\ShellEx\PropertySheetHandlers
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432 CLSID InprocServer32
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\Wow6432Node\CLSID\*\InprocServer32
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432 CLSID InprocServer32
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\Wow6432Node\CLSID\*\InprocServer32
        ValueName: Assembly
        Recursive: false
        Comment: 
    -
        Description: Wow6432 CLSID Instance CLSID
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\Wow6432Node\CLSID\*\Instance
        ValueName: CLSID
        Recursive: true
        Comment: 
    -
        Description: Wow6432 CLSID Instance FriendlyName
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\Wow6432Node\CLSID\*\Instance
        ValueName: FriendlyName
        Recursive: true
        Comment: 
    -
        Description: Wow6432 CLSID LocalServer32
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\Wow6432Node\CLSID\*\LocalServer32
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432 CLSID LocalServer32
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\Wow6432Node\CLSID\*\LocalServer32
        ValueName: Assembly
        Recursive: false
        Comment: 
    -
        Description: Wow6432 CLSID PersistentHandler
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\Wow6432Node\CLSID\*\PersistentHandler
        Recursive: false
        Comment: 
    -
        Description: Wow6432 CLSID TypeLib
        HiveType: Software
        Category: ASEP
        KeyPath: Classes\Wow6432Node\CLSID\*\TypeLib
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Directory background shellex ContextMenuHandlers
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Wow6432Node\Directory\background\shellex\ContextMenuHandlers\*
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Directory shellex CopyHookHandlers
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Wow6432Node\Directory\shellex\CopyHookHandlers\*
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Directory shellex DragDropHandlers
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Wow6432Node\Directory\shellex\DragDropHandlers\*
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Directory shellex PropertySheetHandlers
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Wow6432Node\Directory\shellex\PropertySheetHandlers\*
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Drive shellex ContextMenuHandlers
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Wow6432Node\Drive\shellex\ContextMenuHandlers\*
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Classes Filter
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Wow6432Node\Filter
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Folder shellex ContextMenuHandlers
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Wow6432Node\Folder\shellex\ContextMenuHandlers\*
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Folder shellex DragDropHandlers
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Wow6432Node\Folder\shellex\DragDropHandlers\*
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Folder shellex PropertySheetHandlers
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Wow6432Node\Folder\shellex\PropertySheetHandlers\*
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Interface ProxyStubClsid32
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Wow6432Node\Interface\*\ProxyStubClsid32
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Interface TypeLib
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Wow6432Node\Interface\*\TypeLib
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432 TypeLib win32
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Wow6432Node\TypeLib\*\*\*\win32
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432 TypeLib win64
        HiveType: Software
        Category: ASEP Classes
        KeyPath: Classes\Wow6432Node\TypeLib\*\*\*\win64
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: StartMenuInternet shell open command
        HiveType: Software
        Category: ASEP
        KeyPath: Clients\StartMenuInternet\*\shell\open\command
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: StartMenuInternet shell naom command
        HiveType: Software
        Category: ASEP
        KeyPath: Clients\StartMenuInternet\*\shell\naom\command
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: StartMenuInternet Shell RunAs Command
        HiveType: Software
        Category: ASEP
        KeyPath: Clients\StartMenuInternet\*\Shell\RunAs\Command
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Chrome Extensions
        HiveType: Software
        Category: ASEP
        KeyPath: Google\Chrome\Extensions
        Recursive: true
        Comment: 
    -
        Description: Google Update
        HiveType: Software
        Category: ASEP
        KeyPath: Google\Update
        ValueName: path
        Recursive: false
        Comment: 
    -
        Description: .NETFramework
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\.NETFramework
        ValueName: DbgManagedDebugger
        Recursive: false
        Comment: 
    -
        Description: Active Setup Installed Components
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Active Setup\Installed Components\*
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Active Setup Installed Components
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Active Setup\Installed Components\*
        ValueName: LocalizedName
        Recursive: false
        Comment: 
    -
        Description: Active Setup Installed Components
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Active Setup\Installed Components\*
        ValueName: ShellComponent
        Recursive: false
        Comment: 
    -
        Description: Active Setup Installed Components
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Active Setup\Installed Components\*
        ValueName: StubPath
        Recursive: false
        Comment: 
    -
        Description: Command Processor
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Command Processor
        ValueName: autorun
        Recursive: false
        Comment: 
    -
        Description: Cryptography Offload
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Cryptography\Offload
        ValueName: ExpoOffload
        Recursive: true
        Comment: 
    -
        Description: Ctf LangBarAddin
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Ctf\LangBarAddin
        ValueName: Filepath
        Recursive: true
        Comment: 
    -
        Description: Internet Explorer Approved Extensions
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Internet Explorer\Approved Extensions
        Recursive: true
        Comment: 
    -
        Description: Internet Explorer Explorer Bars
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Internet Explorer\Explorer Bars\*
        Recursive: true
        Comment: 
    -
        Description: Internet Explorer Extension Validation
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Internet Explorer\Extension Validation
        Recursive: true
        Comment: 
    -
        Description: Internet Explorer Extensions
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Internet Explorer\Extensions
        ValueName: ClsidExtension
        Recursive: true
        Comment: 
    -
        Description: Internet Explorer Low Rights DragDrop
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Internet Explorer\Low Rights\DragDrop
        ValueName: AppName
        Recursive: true
        Comment: 
    -
        Description: Internet Explorer Low Rights DragDrop
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Internet Explorer\Low Rights\DragDrop
        ValueName: AppPath
        Recursive: true
        Comment: 
    -
        Description: Internet Explorer Low Rights ElevationPolicy
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Internet Explorer\Low Rights\ElevationPolicy
        ValueName: AppName
        Recursive: true
        Comment: 
    -
        Description: Internet Explorer Low Rights ElevationPolicy
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Internet Explorer\Low Rights\ElevationPolicy
        ValueName: AppPath
        Recursive: true
        Comment: 
    -
        Description: Internet Explorer Low Rights ElevationPolicy
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Internet Explorer\Low Rights\ElevationPolicy
        ValueName: CLSID
        Recursive: true
        Comment: 
    -
        Description: Internet Explorer Plugins Extension
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Internet Explorer\Plugins\Extension
        Recursive: true
        Comment: 
    -
        Description: Internet Explorer Toolbar
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Internet Explorer\Toolbar
        Recursive: false
        Comment: 
    -
        Description: Internet Explorer Toolbar ShellBrowser
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Internet Explorer\Toolbar\ShellBrowser
        Recursive: false
        Comment: 
    -
        Description: Internet Explorer Toolbar WebBrowser
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Internet Explorer\Toolbar\WebBrowser
        Recursive: false
        Comment: 
    -
        Description: Internet Explorer URLSearchHooks
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Internet Explorer\URLSearchHooks
        Recursive: false
        Comment: 
    -
        Description: Office Addins
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Office\*\Addins
        ValueName: Description
        Recursive: true
        Comment: 
    -
        Description: Office Addins
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Office\*\Addins
        ValueName: FriendlyName
        Recursive: true
        Comment: 
    -
        Description: Office Addins
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Office\*\Addins
        ValueName: LoadBehavior
        Recursive: true
        Comment: 
    -
        Description: Authentication Credential Provider Filters
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\Authentication\Credential Provider Filters
        ValueName: (default)
        Recursive: true
        Comment: 
    -
        Description: Authentication Credential Providers
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\Authentication\Credential Providers
        ValueName: (default)
        Recursive: true
        Comment: 
    -
        Description: Authentication PLAP Providers
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\Authentication\PLAP Providers
        ValueName: (default)
        Recursive: true
        Comment: 
    -
        Description: Explorer Browser Helper Objects
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\Explorer\Browser Helper Objects
        Recursive: true
        Comment: 
    -
        Description: Explorer FindExtensions
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\Explorer\FindExtensions
        ValueName: (default)
        Recursive: true
        Comment: 
    -
        Description: Explorer FindExtensions Static
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\Explorer\FindExtensions\Static
        Recursive: true
        Comment: 
    -
        Description: Explorer SharedTaskScheduler
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\Explorer\SharedTaskScheduler
        Recursive: false
        Comment: 
    -
        Description: Explorer ShellExecuteHooks
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\Explorer\ShellExecuteHooks
        Recursive: true
        Comment: 
    -
        Description: Explorer ShellIconOverlayIdentifiers
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\Explorer\ShellIconOverlayIdentifiers
        ValueName: (default)
        Recursive: true
        Comment: 
    -
        Description: Explorer ShellServiceObjects
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\Explorer\ShellServiceObjects
        ValueName: autostart
        Recursive: true
        Comment: 
    -
        Description: Ext PreApproved
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\Ext\PreApproved
        ValueName: (default)
        Recursive: true
        Comment: 
    -
        Description: Group Policy Scripts Shutdown
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\Group Policy\Scripts\Shutdown
        Recursive: true
        Comment: 
    -
        Description: Group Policy Scripts Startup
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\Group Policy\Scripts\Startup
        Recursive: true
        Comment: 
    -
        Description: Internet Settings
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\Internet Settings
        ValueName: AutoConfigURL
        Recursive: false
        Comment: 
    -
        Description: Explorer Run
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\Policies\Explorer\Run
        Recursive: false
        Comment: 
    -
        Description: Policies System
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\Policies\System
        ValueName: Shell
        Recursive: false
        Comment: 
    -
        Description: Policies System
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\Policies\System
        ValueName: UIHost
        Recursive: false
        Comment: 
    -
        Description: Policies System
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\Policies\System
        ValueName: Userinit
        Recursive: false
        Comment: 
    -
        Description: Run
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\Run
        Recursive: false
        Comment: 
    -
        Description: RunOnce
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\Runonce
        Recursive: false
        Comment: 
    -
        Description: RunOnce Setup
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\Runonce\Setup
        Recursive: false
        Comment: 
    -
        Description: RunOnceEx
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\RunOnceEx
        Recursive: false
        Comment: 
    -
        Description: RunServices
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\RunServices
        Recursive: false
        Comment: 
    -
        Description: RunServicesOnce
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\RunServicesOnce
        Recursive: false
        Comment: 
    -
        Description: SharedDLLs
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\Shareddlls
        Recursive: false
        Comment: 
    -
        Description: Shell Extensions Approved
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\Shell Extensions\Approved
        Recursive: false
        Comment: 
    -
        Description: ShellServiceObjectDelayLoad
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\ShellServiceObjectDelayLoad
        Recursive: false
        Comment: 
    -
        Description: Installed SDB
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\Uninstall\*.sdb
        ValueName: InstallDate
        Recursive: true
        Comment: 
    -
        Description: Installed SDB
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows\CurrentVersion\Uninstall\*.sdb
        ValueName: DisplayName
        Recursive: true
        Comment: 
    -
        Description: AeDebug
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\AeDebug
        ValueName: auto
        Recursive: true
        Comment: 
    -
        Description: AeDebug
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\AeDebug
        ValueName: Debugger
        Recursive: true
        Comment: 
    -
        Description: AeDebug
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\AeDebug
        ValueName: UserDebuggerHotKey
        Recursive: true
        Comment: 
    -
        Description: AppCompatFlags Custom
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\AppCompatFlags\Custom
        Recursive: true
        Comment: 
    -
        Description: AppCompatFlags InstalledSDB
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\AppCompatFlags\InstalledSDB
        ValueName: DatabaseDescription
        Recursive: true
        Comment: 
    -
        Description: AppCompatFlags InstalledSDB
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\AppCompatFlags\InstalledSDB
        ValueName: DatabaseInstallTimeStamp
        Recursive: true
        Comment: 
    -
        Description: AppCompatFlags InstalledSDB
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\AppCompatFlags\InstalledSDB
        ValueName: DatabasePath
        Recursive: true
        Comment: 
    -
        Description: AppCompatFlags InstalledSDB
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\AppCompatFlags\InstalledSDB
        ValueName: DatabaseType
        Recursive: true
        Comment: 
    -
        Description: AppCompatFlags Layers
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\Current Version\AppCompatFlags\Layers
        Recursive: false
        Comment: 
    -
        Description: Drivers
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Drivers
        Recursive: false
        Comment: 
    -
        Description: Drivers32
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Drivers32
        Recursive: false
        Comment: 
    -
        Description: Font Drivers 
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Font Drivers
        Recursive: true
        Comment: 
    -
        Description: Image File Execution Options
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Image File Execution Options
        ValueName: GlobalFlag
        Recursive: true
        Comment: 
    -
        Description: Image File Execution Options
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Image File Execution Options
        ValueName: Debugger
        Recursive: true
        Comment: 
    -
        Description: Schedule TaskCache Boot
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Boot
        Recursive: true
        Comment: 
    -
        Description: Schedule TaskCache Logon
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Logon
        Recursive: true
        Comment: 
    -
        Description: Schedule TaskCache Maintenance
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Maintenance
        Recursive: true
        Comment: 
    -
        Description: Schedule TaskCache Plain
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Plain
        Recursive: true
        Comment: 
    -
        Description: Schedule TaskCache Tasks
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks
        ValueName: Actions
        Recursive: true
        Comment: 
    -
        Description: Schedule TaskCache Tasks
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks
        ValueName: Author
        Recursive: true
        Comment: 
    -
        Description: Schedule TaskCache Tasks
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks
        ValueName: Description
        Recursive: true
        Comment: 
    -
        Description: Schedule TaskCache Tasks
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks
        ValueName: DynamicInfo
        Recursive: true
        Comment: 
    -
        Description: Schedule TaskCache Tasks
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks
        ValueName: Hash
        Recursive: true
        Comment: 
    -
        Description: Schedule TaskCache Tasks
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks
        ValueName: Path
        Recursive: true
        Comment: 
    -
        Description: Schedule TaskCache Tasks
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks
        ValueName: Schema
        Recursive: true
        Comment: 
    -
        Description: Schedule TaskCache Tasks
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks
        ValueName: SecurityDescriptor
        Recursive: true
        Comment: 
    -
        Description: Schedule TaskCache Tasks
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks
        ValueName: Source
        Recursive: true
        Comment: 
    -
        Description: Schedule TaskCache Tasks
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks
        ValueName: Triggers
        Recursive: true
        Comment: 
    -
        Description: Schedule TaskCache Tasks
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks
        ValueName: URI
        Recursive: true
        Comment: 
    -
        Description: Schedule TaskCache Tasks
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks
        ValueName: Version
        Recursive: true
        Comment: 
    -
        Description: Schedule TaskCache Tree
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tree
        ValueName: Id
        Recursive: true
        Comment: 
    -
        Description: SilentProcessExit
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\SilentProcessExit
        ValueName: ReportingMode
        Recursive: true
        Comment: 
    -
        Description: SilentProcessExit
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\SilentProcessExit
        ValueName: MonitorProcess
        Recursive: true
        Comment: 
    -
        Description: Microsoft Windows NT SvcHost
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\SvcHost
        Recursive: true
        Comment: 
    -
        Description: Microsoft Windows NT Terminal Server Run
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Terminal Server\install\Software\Microsoft\Windows\CurrentVersion\Run
        Recursive: false
        Comment: 
    -
        Description: Microsoft Windows NT Terminal Server Runonce
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Terminal Server\install\Software\Microsoft\Windows\CurrentVersion\Runonce
        Recursive: false
        Comment: 
    -
        Description: Microsoft Windows NT Terminal Server Runonceex
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Terminal Server\install\Software\Microsoft\Windows\CurrentVersion\Runonceex
        Recursive: false
        Comment: 
    -
        Description: Microsoft Windows NT OsImagesFolder
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Virtualization\LayerRootLocations
        Recursive: true
        Comment: Looking for OsImagesFolder.
    -
        Description: Windows NT CV Windows AppInitDlls
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Windows
        ValueName: AppInit_Dlls
        Recursive: false
        Comment: 
    -
        Description: Windows NT CV Windows IconServiceLib
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Windows
        ValueName: IconServiceLib
        Recursive: false
        Comment: 
    -
        Description: Windows NT CV Windows Load
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Windows
        ValueName: Load
        Recursive: false
        Comment: 
    -
        Description: Windows NT CV Windows RequireSignedAppInit_DLLs
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Windows
        ValueName: RequireSignedAppInit_DLLs
        Recursive: false
        Comment: 
    -
        Description: Windows NT CV Windows Run
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Windows
        ValueName: Run
        Recursive: false
        Comment: 
    -
        Description: Winlogon GinaDLL
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Winlogon
        ValueName: Ginadll
        Recursive: false
        Comment: 
    -
        Description: Winlogon Userinit
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Winlogon
        ValueName: Userinit
        Recursive: false
        Comment: 
    -
        Description: Winlogon VMApplet
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Winlogon
        ValueName: VMApplet
        Recursive: false
        Comment: 
    -
        Description: Winlogon AppSetup
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Winlogon
        ValueName: AppSetup
        Recursive: false
        Comment: 
    -
        Description: Winlogon Shell
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Winlogon
        ValueName: Shell
        Recursive: false
        Comment: 
    -
        Description: Winlogon System
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Winlogon
        ValueName: System
        Recursive: false
        Comment: 
    -
        Description: Winlogon Taskman
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Winlogon
        ValueName: Taskman
        Recursive: false
        Comment: 
    -
        Description: Winlogon UIHost
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Winlogon
        ValueName: UIHost
        Recursive: false
        Comment: 
    -
        Description: Winlogon AlternateShells AvailableShells
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Winlogon\AlternateShells\AvailableShells
        Recursive: false
        Comment: 
    -
        Description: Winlogon GPExtensions
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Winlogon\GPExtensions
        ValueName: (default)
        Recursive: true
        Comment: 
    -
        Description: Winlogon GPExtensions
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Winlogon\GPExtensions
        ValueName: DisplayName
        Recursive: true
        Comment: 
    -
        Description: Winlogon GPExtensions
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Winlogon\GPExtensions
        ValueName: dllname
        Recursive: true
        Comment: 
    -
        Description: Winlogon Notify
        HiveType: Software
        Category: ASEP
        KeyPath: Microsoft\Windows NT\CurrentVersion\Winlogon\Notify
        ValueName: dllname
        Recursive: true
        Comment: 
    -
        Description: MozillaPlugins
        HiveType: Software
        Category: ASEP
        KeyPath: MozillaPlugins\*
        ValueName: path
        Recursive: false
        Comment: 
    -
        Description: Policies Scripts Logoff
        HiveType: Software
        Category: ASEP
        KeyPath: Policies\Microsoft\Windows\System\Scripts\Logoff
        ValueName: Script
        Recursive: true
        Comment: 
    -
        Description: Policies Scripts Logon
        HiveType: Software
        Category: ASEP
        KeyPath: Policies\Microsoft\Windows\System\Scripts\Logon
        ValueName: Script
        Recursive: true
        Comment: 
    -
        Description: Policies Scripts Shutdown
        HiveType: Software
        Category: ASEP
        KeyPath: Policies\Microsoft\Windows\System\Scripts\Shutdown
        ValueName: Script
        Recursive: true
        Comment: 
    -
        Description: Policies Scripts Startup
        HiveType: Software
        Category: ASEP
        KeyPath: Policies\Microsoft\Windows\System\Scripts\Startup
        ValueName: Script
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Google Update
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Google\Update
        ValueName: path
        Recursive: false
        Comment: 
    -
        Description: WOW6432 .NETFramework
        HiveType: Software
        Category: ASEP
        KeyPath: WOW6432Node\Microsoft\.NETFramework
        ValueName: DbgManagedDebugger
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Active Setup Installed Components
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Active Setup\Installed Components\*
        ValueName: (default)
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Active Setup Installed Components
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Active Setup\Installed Components\*
        ValueName: ShellComponent
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Active Setup Installed Components
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Active Setup\Installed Components\*
        ValueName: StubPath
        Recursive: true
        Comment: 
    -
        Description: WOW6432 Command Processor Autorun
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Command Processor
        ValueName: Autorun
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Ctf LangBarAddin
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Ctf\LangBarAddin
        ValueName: Filepath
        Recursive: true
        Comment: 
    -
        Description: Wow6432 IE Approved Extensions
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Internet Explorer\Approved Extensions
        Recursive: true
        Comment: 
    -
        Description: Wow6432 IE Explorer Bars
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Internet Explorer\Explorer Bars\*
        Recursive: true
        Comment: 
    -
        Description: Wow6432 IE Extension Validation
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Internet Explorer\Extension Validation
        Recursive: true
        Comment: 
    -
        Description: Wow6432 IE Extensions
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Internet Explorer\Extensions
        ValueName: ClsidExtension
        Recursive: true
        Comment: 
    -
        Description: Wow6432 IE Low Rights DragDrop
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Internet Explorer\Low Rights\DragDrop
        ValueName: AppName
        Recursive: true
        Comment: 
    -
        Description: Wow6432 IE Low Rights DragDrop
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Internet Explorer\Low Rights\DragDrop
        ValueName: AppPath
        Recursive: true
        Comment: 
    -
        Description: Wow6432 IE Low Rights ElevationPolicy AppName
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Internet Explorer\Low Rights\ElevationPolicy
        ValueName: AppName
        Recursive: true
        Comment: 
    -
        Description: Wow6432 IE Low Rights ElevationPolicy AppPath
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Internet Explorer\Low Rights\ElevationPolicy
        ValueName: AppPath
        Recursive: true
        Comment: 
    -
        Description: Wow6432 IE Low Rights ElevationPolicy CLSID
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Internet Explorer\Low Rights\ElevationPolicy
        ValueName: CLSID
        Recursive: true
        Comment: 
    -
        Description: Wow6432 IE Plugins Extension
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Internet Explorer\Plugins\Extension
        Recursive: true
        Comment: 
    -
        Description: Wow6432 IE Toolbar
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Internet Explorer\Toolbar
        Recursive: false
        Comment: 
    -
        Description: Wow6432 IE Toolbar ShellBrowser
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Internet Explorer\Toolbar\ShellBrowser
        Recursive: false
        Comment: 
    -
        Description: Wow6432 IE Toolbar WebBrowser
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Internet Explorer\Toolbar\WebBrowser
        Recursive: false
        Comment: 
    -
        Description: Wow6432 IE URLSearchHooks
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Internet Explorer\URLSearchHooks
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Office Addins
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Office\*\Addins
        ValueName: Description
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Office Addins
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Office\*\Addins
        ValueName: FriendlyName
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Office Addins
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Office\*\Addins
        ValueName: LoadBehavior
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Authentication Credential Provider Filters
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows\CurrentVersion\Authentication\Credential Provider Filters
        ValueName: (default)
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Authentication Credential Providers
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows\CurrentVersion\Authentication\Credential Providers
        ValueName: (default)
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Authentication PLAP Providers
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows\CurrentVersion\Authentication\PLAP Providers
        ValueName: (default)
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Explorer Browser Helper Objects
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows\CurrentVersion\Explorer\Browser Helper Objects
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Explorer FindExtensions
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows\CurrentVersion\Explorer\FindExtensions
        ValueName: (default)
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Explorer FindExtensions Static
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows\CurrentVersion\Explorer\FindExtensions\Static
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Explorer SharedTaskScheduler
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows\CurrentVersion\Explorer\SharedTaskScheduler
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Explorer ShellExecuteHooks
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows\CurrentVersion\Explorer\ShellExecuteHooks
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Explorer ShellIconOverlayIdentifiers
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows\CurrentVersion\Explorer\ShellIconOverlayIdentifiers
        ValueName: (default)
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Explorer ShellServiceObjects
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows\CurrentVersion\Explorer\ShellServiceObjects
        ValueName: autostart
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Ext PreApproved
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows\CurrentVersion\Ext\PreApproved
        ValueName: (default)
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Internet Settings
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows\CurrentVersion\Internet Settings
        ValueName: AutoConfigURL
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Run
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows\CurrentVersion\Run
        Recursive: false
        Comment: 
    -
        Description: Wow6432 RunOnce
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows\CurrentVersion\Runonce
        Recursive: false
        Comment: 
    -
        Description: Wow6432 RunOnce Setup
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows\CurrentVersion\Runonce\Setup
        Recursive: false
        Comment: 
    -
        Description: Wow6432 RunOnceEx
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows\CurrentVersion\RunOnceEx
        Recursive: false
        Comment: 
    -
        Description: Wow6432 RunServices
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows\CurrentVersion\RunServices
        Recursive: false
        Comment: 
    -
        Description: Wow6432 RunServicesOnce
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows\CurrentVersion\RunServicesOnce
        Recursive: false
        Comment: 
    -
        Description: Wow6432 SharedDLLs
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows\CurrentVersion\Shareddlls
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Shell Extensions Approved
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows\CurrentVersion\Shell Extensions\Approved
        Recursive: false
        Comment: 
    -
        Description: Wow6432 ShellServiceObjectDelayLoad
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows\CurrentVersion\ShellServiceObjectDelayLoad
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Installed SDB
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*.sdb
        ValueName: InstallDate
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Installed SDB
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*.sdb
        ValueName: DisplayName
        Recursive: true
        Comment: 
    -
        Description: Wow6432 AeDebug
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\AeDebug
        ValueName: auto
        Recursive: true
        Comment: 
    -
        Description: Wow6432 AeDebug
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\AeDebug
        ValueName: Debugger
        Recursive: true
        Comment: 
    -
        Description: Wow6432 AeDebug
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\AeDebug
        ValueName: UserDebuggerHotKey
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Microsoft\Windows NT\CurrentVersion\AppCompatFlags\Custom
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\Custom
        Recursive: true
        Comment: 
    -
        Description: Wow6432 AppCompatFlags InstalledSDB
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\InstalledSDB
        ValueName: DatabaseDescription
        Recursive: true
        Comment: 
    -
        Description: Wow6432 AppCompatFlags InstalledSDB
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\InstalledSDB
        ValueName: DatabaseInstallTimeStamp
        Recursive: true
        Comment: 
    -
        Description: Wow6432 AppCompatFlags InstalledSDB
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\InstalledSDB
        ValueName: DatabasePath
        Recursive: true
        Comment: 
    -
        Description: Wow6432 AppCompatFlags InstalledSDB
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\InstalledSDB
        ValueName: DatabaseType
        Recursive: true
        Comment: 
    -
        Description: Wow6432 AppCompatFlags Layers
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\Current Version\AppCompatFlags\Layers
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Drivers
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Drivers
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Drivers32
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Drivers32
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Font Drivers 
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Font Drivers
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Image File Execution Options
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Image File Execution Options
        ValueName: GlobalFlag
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Image File Execution Options
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Image File Execution Options
        ValueName: Debugger
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Schedule TaskCache Boot
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Boot
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Schedule TaskCache Logon
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Logon
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Schedule TaskCache Maintenance
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Maintenance
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Schedule TaskCache Plain
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Plain
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Schedule TaskCache Tasks
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks
        ValueName: Actions
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Schedule TaskCache Tasks
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks
        ValueName: Author
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Schedule TaskCache Tasks
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks
        ValueName: Description
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Schedule TaskCache Tasks
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks
        ValueName: DynamicInfo
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Schedule TaskCache Tasks
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks
        ValueName: Hash
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Schedule TaskCache Tasks
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks
        ValueName: Path
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Schedule TaskCache Tasks
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks
        ValueName: Schema
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Schedule TaskCache Tasks
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks
        ValueName: SecurityDescriptor
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Schedule TaskCache Tasks
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks
        ValueName: Source
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Schedule TaskCache Tasks
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks
        ValueName: Triggers
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Schedule TaskCache Tasks
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks
        ValueName: URI
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Schedule TaskCache Tasks
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks
        ValueName: Version
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Schedule TaskCache Tree
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tree
        ValueName: Id
        Recursive: true
        Comment: 
    -
        Description: Wow6432 SilentProcessExit
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\SilentProcessExit
        ValueName: ReportingMode
        Recursive: true
        Comment: 
    -
        Description: Wow6432 SilentProcessExit
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\SilentProcessExit
        ValueName: MonitorProcess
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Microsoft Windows NT SvcHost
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\SvcHost
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Microsoft Windows NT Terminal Server Run
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Terminal Server\install\Software\Microsoft\Windows\CurrentVersion\Run
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Microsoft Windows NT Terminal Server Runonce
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Terminal Server\install\Software\Microsoft\Windows\CurrentVersion\Runonce
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Microsoft Windows NT Terminal Server Runonceex
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Terminal Server\install\Software\Microsoft\Windows\CurrentVersion\Runonceex
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Microsoft Windows NT OsImagesFolder
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Virtualization\LayerRootLocations
        Recursive: true
        Comment: Looking for OsImagesFolder.
    -
        Description: Wow6432 Microsoft Windows NT CurrentVersion Windows
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Windows
        ValueName: AppInit_Dlls
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Windows NT CV Windows IconServiceLib
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Windows
        ValueName: IconServiceLib
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Windows NT CV Windows Load
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Windows
        ValueName: Load
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Windows NT CV Windows RequireSignedAppInit_DLLs
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Windows
        ValueName: RequireSignedAppInit_DLLs
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Windows NT CV Windows Run
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Windows
        ValueName: Run
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Winlogon GinaDLL
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Winlogon
        ValueName: Ginadll
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Winlogon Userinit
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Winlogon
        ValueName: Userinit
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Winlogon VMApplet
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Winlogon
        ValueName: VMApplet
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Winlogon AppSetup
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Winlogon
        ValueName: AppSetup
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Winlogon Shell
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Winlogon
        ValueName: Shell
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Winlogon System
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Winlogon
        ValueName: System
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Winlogon Taskman
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Winlogon
        ValueName: Taskman
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Winlogon UIHost
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Winlogon
        ValueName: UIHost
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Winlogon AlternateShells AvailableShells
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Winlogon\AlternateShells\AvailableShells
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Winlogon GPExtensions
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Winlogon\GPExtensions
        ValueName: (default)
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Winlogon GPExtensions
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Winlogon\GPExtensions
        ValueName: DisplayName
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Winlogon GPExtensions
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Winlogon\GPExtensions
        ValueName: dllname
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Winlogon Notify
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\Microsoft\Windows NT\CurrentVersion\Winlogon\Notify
        ValueName: dllname
        Recursive: true
        Comment: 
    -
        Description: Wow6432 MozillaPlugins
        HiveType: Software
        Category: ASEP
        KeyPath: Wow6432Node\MozillaPlugins\*
        ValueName: path
        Recursive: false
        Comment: 
    -
        Description: Desktop Wallpaper
        HiveType: ntuser
        Category: ASEP
        KeyPath: Control Panel\DeskTop
        ValueName: ConvertedWallpaper
        Recursive: false
        Comment: 
    -
        Description: Desktop Wallpaper
        HiveType: ntuser
        Category: ASEP
        KeyPath: Control Panel\DeskTop
        ValueName: OriginalWallpaper
        Recursive: false
        Comment: 
    -
        Description: Desktop Wallpaper
        HiveType: ntuser
        Category: ASEP
        KeyPath: Control Panel\DeskTop
        ValueName: WallPaper
        Recursive: false
        Comment: 
    -
        Description: Desktop Screensaver
        HiveType: ntuser
        Category: ASEP
        KeyPath: Control Panel\DeskTop
        ValueName: scrnsave.exe
        Recursive: false
        Comment: 
    -
        Description: Environment Logon Script
        HiveType: ntuser
        Category: ASEP
        KeyPath: Environment
        ValueName: UserInitMprLogonScript
        Recursive: false
        Comment: 
    -
        Description: Chrome Extensions
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Google\Chrome\Extensions
        ValueName: path
        Recursive: true
        Comment: 
    -
        Description: Active Setup
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Active Setup\Installed Components
        Recursive: true
        Comment: 
    -
        Description: Command Processor
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Command Processor
        ValueName: autorun
        Recursive: false
        Comment: 
    -
        Description: Ctf LangBarAddin
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Ctf
        ValueName: LangBarAddin
        Recursive: false
        Comment: 
    -
        Description: IE Approved Extensions
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Internet Explorer\Approved Extensions
        Recursive: false
        Comment: 
    -
        Description: IE DeskTop Components
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Internet Explorer\DeskTop\Components
        Recursive: true
        Comment: 
    -
        Description: IE BackupWallpaper
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Internet Explorer\Desktop\General
        ValueName: BackupWallpaper
        Recursive: false
        Comment: 
    -
        Description: IE wallpapersource
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Internet Explorer\Desktop\General
        ValueName: wallpapersource
        Recursive: false
        Comment: 
    -
        Description: IE Explorer Bars
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Internet Explorer\Explorer Bars
        Recursive: true
        Comment: 
    -
        Description: IE Extension Validation
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Internet Explorer\Extension Validation
        Recursive: true
        Comment: 
    -
        Description: IE Extensions
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Internet Explorer\Extensions
        Recursive: true
        Comment: 
    -
        Description: IE MenuExt
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Internet Explorer\MenuExt
        ValueName: (default)
        Recursive: true
        Comment: 
    -
        Description: IE Toolbar ShellBrowser
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Internet Explorer\Toolbar\ShellBrowser
        Recursive: false
        Comment: 
    -
        Description: IE Toolbar WebBrowser
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Internet Explorer\Toolbar\WebBrowser
        Recursive: false
        Comment: 
    -
        Description: IE URLSearchHooks
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Internet Explorer\URLSearchHooks
        Recursive: false
        Comment: 
    -
        Description: Office Addins
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Office\*\Addins
        Recursive: false
        Comment: 
    -
        Description: Office Addins
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Office\*\Addins\*
        Recursive: false
        Comment: 
    -
        Description: Explorer Browser Helper Objects
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Explorer\Browser Helper Objects
        Recursive: true
        Comment: 
    -
        Description: Explorer SharedTaskScheduler
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Explorer\SharedTaskScheduler
        Recursive: true
        Comment: 
    -
        Description: Explorer ShellIconOverlayIdentifiers
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Explorer\ShellIconOverlayIdentifiers
        Recursive: true
        Comment: 
    -
        Description: Explorer ShellServiceObjects
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Explorer\ShellServiceObjects
        Recursive: true
        Comment: 
    -
        Description: Ext Settings
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Ext\Settings
        Recursive: true
        Comment: 
    -
        Description: Ext Stats
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Ext\Stats
        Recursive: true
        Comment: 
    -
        Description: Group Policy Scripts Logoff
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Group Policy\Scripts\Logoff\*
        ValueName: DisplayName
        Recursive: true
        Comment: 
    -
        Description: Group Policy Scripts Logoff
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Group Policy\Scripts\Logoff\*
        ValueName: ExecTime
        Recursive: true
        Comment: 
    -
        Description: Group Policy Scripts Logoff
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Group Policy\Scripts\Logoff\*
        ValueName: FileSysPath
        Recursive: true
        Comment: 
    -
        Description: Group Policy Scripts Logoff
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Group Policy\Scripts\Logoff\*
        ValueName: GPO-ID
        Recursive: true
        Comment: 
    -
        Description: Group Policy Scripts Logoff
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Group Policy\Scripts\Logoff\*
        ValueName: IsPowershell
        Recursive: true
        Comment: 
    -
        Description: Group Policy Scripts Logoff
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Group Policy\Scripts\Logoff\*
        ValueName: Parameters
        Recursive: true
        Comment: 
    -
        Description: Group Policy Scripts Logoff
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Group Policy\Scripts\Logoff\*
        ValueName: PSScriptOrder
        Recursive: true
        Comment: 
    -
        Description: Group Policy Scripts Logoff
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Group Policy\Scripts\Logoff\*
        ValueName: Script
        Recursive: true
        Comment: 
    -
        Description: Group Policy Scripts Logoff
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Group Policy\Scripts\Logoff\*
        ValueName: SOM-ID
        Recursive: true
        Comment: 
    -
        Description: Group Policy Scripts Logon
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Group Policy\Scripts\Logon\*
        ValueName: DisplayName
        Recursive: true
        Comment: 
    -
        Description: Group Policy Scripts Logon
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Group Policy\Scripts\Logon\*
        ValueName: ExecTime
        Recursive: true
        Comment: 
    -
        Description: Group Policy Scripts Logon
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Group Policy\Scripts\Logon\*
        ValueName: FileSysPath
        Recursive: true
        Comment: 
    -
        Description: Group Policy Scripts Logon
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Group Policy\Scripts\Logon\*
        ValueName: GPO-ID
        Recursive: true
        Comment: 
    -
        Description: Group Policy Scripts Logon
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Group Policy\Scripts\Logon*
        ValueName: IsPowershell
        Recursive: true
        Comment: 
    -
        Description: Group Policy Scripts Logon
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Group Policy\Scripts\Logon\*
        ValueName: Parameters
        Recursive: true
        Comment: 
    -
        Description: Group Policy Scripts Logon
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Group Policy\Scripts\Logon\*
        ValueName: PSScriptOrder
        Recursive: true
        Comment: 
    -
        Description: Group Policy Scripts Logon
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Group Policy\Scripts\Logon\*
        ValueName: Script
        Recursive: true
        Comment: 
    -
        Description: Group Policy Scripts Logon
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Group Policy\Scripts\Logon\*
        ValueName: SOM-ID
        Recursive: true
        Comment: 
    -
        Description: Internet Settings AutoConfigProxy
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Internet Settings
        ValueName: AutoConfigProxy
        Recursive: false
        Comment: 
    -
        Description: Internet Settings AutoConfigURL
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Internet Settings
        ValueName: AutoConfigURL
        Recursive: false
        Comment: 
    -
        Description: Policies Explorer NoDriveTypeAutoRun
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Policies\Explorer
        ValueName: NoDriveTypeAutoRun
        Recursive: false
        Comment: 
    -
        Description: Policies Explorer Run
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run
        Recursive: false
        Comment: 
    -
        Description: Policies System Shell
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Policies\System
        ValueName: Shell
        Recursive: false
        Comment: 
    -
        Description: Policies System
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Policies\System
        ValueName: UserInit
        Recursive: false
        Comment: 
    -
        Description: Run
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Run
        Recursive: false
        Comment: 
    -
        Description: RunOnce
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\RunOnce
        Recursive: false
        Comment: 
    -
        Description: RunOnceEx
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\RunOnceEx
        Recursive: false
        Comment: 
    -
        Description: RunServices
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\RunServices
        Recursive: false
        Comment: 
    -
        Description: RunServicesOnce
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\RunServicesOnce
        Recursive: false
        Comment: 
    -
        Description: Shell Extensions Approved
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Shell Extensions\Approved
        Recursive: true
        Comment: 
    -
        Description: ShellServiceObjectDelayLoad
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows\CurrentVersion\ShellServiceObjectDelayLoad
        Recursive: true
        Comment: 
    -
        Description: Drivers
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows NT\CurrentVersion\drivers
        Recursive: false
        Comment: 
    -
        Description: Drivers32
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows NT\CurrentVersion\drivers32
        Recursive: false
        Comment: 
    -
        Description: Terminal Server Run
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows NT\CurrentVersion\Terminal Server\Install\Software\Microsoft\Windows\CurrentVersion\Run
        Recursive: false
        Comment: 
    -
        Description: Terminal Server RunOnce
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows NT\CurrentVersion\Terminal Server\Install\Software\Microsoft\Windows\CurrentVersion\RunOnce
        Recursive: false
        Comment: 
    -
        Description: Terminal Server RunOnceEx
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows NT\CurrentVersion\Terminal Server\Install\Software\Microsoft\Windows\CurrentVersion\RunOnceEx
        Recursive: false
        Comment: 
    -
        Description: Load
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows NT\CurrentVersion\Windows
        ValueName: Load
        Recursive: false
        Comment: 
    -
        Description: Run
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows NT\CurrentVersion\Windows
        ValueName: Run
        Recursive: false
        Comment: 
    -
        Description: Winlogon Shell
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows NT\CurrentVersion\Winlogon
        ValueName: Shell
        Recursive: false
        Comment: 
    -
        Description: Winlogon Userinit
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows NT\CurrentVersion\Winlogon
        ValueName: userinit
        Recursive: false
        Comment: 
    -
        Description: Winlogon VMapplet
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Microsoft\Windows NT\CurrentVersion\Winlogon
        ValueName: VMapplet
        Recursive: false
        Comment: 
    -
        Description: Mozilla Components, Extensions, & Plugins
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Mozilla\*\Components
        Recursive: true
        Comment: 
    -
        Description: Mozilla Components, Extensions, & Plugins
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Mozilla\*\Extensions\Components
        Recursive: true
        Comment: 
    -
        Description: Mozilla Components, Extensions, & Plugins
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Mozilla\*\Extensions\Plugins
        Recursive: true
        Comment: 
    -
        Description: Mozilla Components, Extensions, & Plugins
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Mozilla\*\Plugins
        Recursive: true
        Comment: 
    -
        Description: Mozilla Components, Extensions, & Plugins
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\MozillaPlugins
        Recursive: true
        Comment: 
    -
        Description: Policies Desktop Screensaver
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Policies\Microsoft\Windows\Control Panel\Desktop
        ValueName: Scrnsave.exe
        Recursive: false
        Comment: 
    -
        Description: Policies Logoff Script
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Policies\Microsoft\Windows\System\Scripts\Logoff
        ValueName: Script
        Recursive: true
        Comment: 
    -
        Description: Policies Logon Script
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Policies\Microsoft\Windows\System\Scripts\Logon
        ValueName: Script
        Recursive: true
        Comment: 
    -
        Description: Domain Profile Authorized Applications
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Policies\Microsoft\WindowsFirewall\DomainProfile\AuthorizedApplications
        Recursive: true
        Comment: 
    -
        Description: Standard Profile Authorized Applications
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Policies\Microsoft\WindowsFirewall\StandardProfile\AuthorizedApplications
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Active Setup
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Wow6432Node\Microsoft\Active Setup\Installed Components
        Recursive: true
        Comment: 
    -
        Description: Wow6432 Command Processor
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Wow6432Node\Microsoft\Command Processor
        ValueName: autorun
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Internet Explorer Explorer Bars
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Wow6432Node\Microsoft\Internet Explorer\Explorer Bars
        Recursive: false
        Comment: 
    -
        Description: Wow6432 Internet Explorer Extension
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Wow6432Node\Microsoft\Internet Explorer\Extension
        Recursive: false
        Comment: 
    -
        Description: WOW6432Node Office Addins
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Wow6432Node\Microsoft\Office\*\Addins
        Recursive: false
        Comment: 
    -
        Description: WOW6432Node Office Addins
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Wow6432Node\Microsoft\Office\*\Addins\*
        Recursive: false
        Comment: 
    -
        Description: WOW6432Node Drivers32
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Wow6432Node\Microsoft\Windows NT\CurrentVersion\Drivers32
        Recursive: true
        Comment: 
    -
        Description: WOW6432Node Run
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Run
        Recursive: false
        Comment: 
    -
        Description: WOW6432Node RunOnce
        HiveType: ntuser
        Category: ASEP
        KeyPath: Software\Wow6432Node\Microsoft\Windows\CurrentVersion\RunOnce
        Recursive: false
        Comment: 
    -
        Description: .cmd
        HiveType: usrclass
        Category: ASEP
        KeyPath: .cmd
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: .cmd PersistentHandler
        HiveType: usrclass
        Category: ASEP
        KeyPath: .cmd\PersistentHandler
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: .exe
        HiveType: usrclass
        Category: ASEP
        KeyPath: .exe
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: .exe PersistentHandler
        HiveType: usrclass
        Category: ASEP
        KeyPath: .exe\PersistentHandler
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: cmdfile
        HiveType: usrclass
        Category: ASEP
        KeyPath: cmdfile
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: exefile
        HiveType: usrclass
        Category: ASEP
        KeyPath: exefile
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Htmlfile Open
        HiveType: usrclass
        Category: ASEP
        KeyPath: Htmlfile\Shell\Open\Command
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: ShellEx ColumnHandlers
        HiveType: usrclass
        Category: ASEP
        KeyPath: '*\ShellEx\ColumnHandlers'
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: ShellEx ContextMenuHandlers
        HiveType: usrclass
        Category: ASEP
        KeyPath: '*\ShellEx\ContextMenuHandlers'
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: ShellEx CopyHookHandlers
        HiveType: usrclass
        Category: ASEP
        KeyPath: '*\ShellEx\CopyHookHandlers'
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: ShellEx DragDropHandlers
        HiveType: usrclass
        Category: ASEP
        KeyPath: '*\ShellEx\DragDropHandlers'
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: ShellEx ExtShellFolderViews
        HiveType: usrclass
        Category: ASEP
        KeyPath: '*\ShellEx\ExtShellFolderViews'
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: ShellEx PropertySheetHandlers
        HiveType: usrclass
        Category: ASEP
        KeyPath: '*\ShellEx\PropertySheetHandlers'
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Directory Background ContextMenuHandlers
        HiveType: usrclass
        Category: ASEP
        KeyPath: Directory\Background\ShellEx\ContextMenuHandlers
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: CLSID InprocServer32
        HiveType: usrclass
        Category: ASEP
        KeyPath: CLSID\*\InprocServer32
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: CLSID InprocServer32
        HiveType: usrclass
        Category: ASEP
        KeyPath: CLSID\*\InprocServer32
        ValueName: Assembly
        Recursive: false
        Comment: 
    -
        Description: CLSID LocalServer32
        HiveType: USRCLASS
        Category: ASEP
        KeyPath: CLSID\*\LocalServer32
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: CLSID LocalServer32
        HiveType: USRCLASS
        Category: ASEP
        KeyPath: CLSID\*\LocalServer32
        ValueName: Assembly
        Recursive: false
        Comment: 
    -
        Description: CLSID PersistentHandler
        HiveType: USRCLASS
        Category: ASEP
        KeyPath: CLSID\*\PersistentHandler
        Recursive: false
        Comment: 
    -
        Description: CLSID TypeLib
        HiveType: USRCLASS
        Category: ASEP
        KeyPath: CLSID\*\TypeLib
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: CLSID Instance CLSID
        HiveType: USRCLASS
        Category: ASEP
        KeyPath: CLSID\*\Instance
        ValueName: CLSID
        Recursive: true
        Comment: 
    -
        Description: CLSID Instance FriendlyName
        HiveType: USRCLASS
        Category: ASEP
        KeyPath: CLSID\*\Instance
        ValueName: FriendlyName
        Recursive: true
        Comment: 
    -
        Description: Interface ProxyStubClsid32
        HiveType: USRCLASS
        Category: ASEP
        KeyPath: Interface\*\ProxyStubClsid32
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Protocols CLSID
        HiveType: USRCLASS
        Category: ASEP
        KeyPath: Protocols\Filter\*
        ValueName: CLSID
        Recursive: false
        Comment: 
    -
        Description: Protocols Handler
        HiveType: USRCLASS
        Category: ASEP
        KeyPath: Protocols\Handler\*
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Protocols Handler CLSID
        HiveType: USRCLASS
        Category: ASEP
        KeyPath: Protocols\Handler\*
        ValueName: CLSID
        Recursive: false
        Comment: 
    -
        Description: Protocols Name-Space Handler
        HiveType: USRCLASS
        Category: ASEP
        KeyPath: Protocols\Name-Space Handler\*
        ValueName: (default)
        Recursive: true
        Comment: 
    -
        Description: ProtocolsName-Space Handler CLSID
        HiveType: USRCLASS
        Category: ASEP
        KeyPath: Protocols\Name-Space Handler\*
        ValueName: CLSID
        Recursive: true
        Comment: 
    -
        Description: TypeLib
        HiveType: USRCLASS
        Category: ASEP
        KeyPath: TypeLib\*\*
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: TypeLib Win32
        HiveType: USRCLASS
        Category: ASEP
        KeyPath: TypeLib\*\*\*\win32
        ValueName: (default)
        Recursive: true
        Comment: 
    -
        Description: TypeLib Win64
        HiveType: USRCLASS
        Category: ASEP
        KeyPath: TypeLib{*\*\*\win64
        ValueName: (default)
        Recursive: true
        Comment: 
    -
        Description: Wow6432Node CLSID InprocServer32
        HiveType: USRCLASS
        Category: ASEP
        KeyPath: Wow6432Node\CLSID\*\InprocServer32
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432Node CLSID InprocServer32
        HiveType: USRCLASS
        Category: ASEP
        KeyPath: Wow6432Node\CLSID\*\InprocServer32
        ValueName: Assembly
        Recursive: false
        Comment: 
    -
        Description: Wow6432Node CLSID LocalServer32
        HiveType: USRCLASS
        Category: ASEP
        KeyPath: Wow6432Node\CLSID\*\LocalServer32
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432Node CLSID LocalServer32
        HiveType: USRCLASS
        Category: ASEP
        KeyPath: Wow6432Node\CLSID\*\LocalServer32
        ValueName: Assembly
        Recursive: false
        Comment: 
    -
        Description: Wow6432Node CLSID PersistentHandler
        HiveType: USRCLASS
        Category: ASEP
        KeyPath: Wow6432Node\CLSID\*\PersistentHandler
        Recursive: false
        Comment: 
    -
        Description: Wow6432Node CLSID TypeLib
        HiveType: USRCLASS
        Category: ASEP
        KeyPath: Wow6432Node\CLSID\*\TypeLib
        ValueName: (default)
        Recursive: false
        Comment: 
    -
        Description: Wow6432Node CLSID Instance CLSID
        HiveType: USRCLASS
        Category: ASEP
        KeyPath: Wow6432Node\CLSID\*\Instance
        ValueName: CLSID
        Recursive: true
        Comment: 
    -
        Description: Wow6432Node CLSID Instance FriendlyName
        HiveType: USRCLASS
        Category: ASEP
        KeyPath: Wow6432Node\CLSID\*\Instance
        ValueName: FriendlyName
        Recursive: true
        Comment: 
    -
        Description: Wow6432Node Interface ProxyStubClsid32
        HiveType: USRCLASS
        Category: ASEP
        KeyPath: Wow6432Node\Interface\*\ProxyStubClsid32
        ValueName: (default)
        Recursive: false
        Comment: 

```

`Tools/RECmd_BatchFiles/SysCache.reb`:

```reb
Description: SYSCACHE
Author: Eric Zimmerman
Version: 1
Id: ab14eb5f-31db-5cdc-83df-88ec83dc7a
Keys:
    -
        Description: SYSCACHE
        HiveType: Syscache
        Category: Execution
        KeyPath: DefaultObjectStore\ObjectTable
        Recursive: true
        Comment: SYSCACHE

```

`Tools/RECmd_BatchFiles/TerminalServerClient.reb`:

```reb
Description: TerminalServerClient - RECmd batch file
Author: Martin Willing
Version: 1
Id: ab17eb5f-31db-5cdc-83df-87ec83b61b
Keys:
    -
        Description: TerminalServerClient
        HiveType: NTUSER
        Category: User Activity
        KeyPath: Software\Microsoft\Terminal Server Client
        Recursive: false
        Comment: "Displays the IP addresses/hostnames of devices this system has connected to (Outbound RDP)"
```

`Tools/RECmd_BatchFiles/TrustedDocuments.reb`:

```reb
Description: TrustedDocuments - RECmd batch file
Author: Martin Willing
Version: 1
Id: ab13eb5f-31db-5cdc-83df-81ec83dc15
Keys:
    -
        Description: This registry key contains a list of Microsoft Office document file locations for which a user has explicitly enabled editing and macros.
        HiveType: NTUSER
        Category: Office Documents
        KeyPath: Software\Microsoft\Office\*\*\Security\Trusted Documents\TrustRecords
        Recursive: true
```

`Tools/RECmd_BatchFiles/UserAssist.reb`:

```reb
Description: UserAssist - RECmd batch file
Author: Martin Willing
Version: 1
Id: ab13eb5f-31db-5cdc-83df-88ec83dc17
Keys:
    -
        Description: GUI-based programs launched from the desktop are tracked in the launcher on a Windows system.
        HiveType: NTUSER
        Category: Program Execution
        KeyPath: Software\Microsoft\Windows\CurrentVersion\Explorer\UserAssist
        Recursive: true
```

`Updater.ps1`:

```ps1
# MemProcFS-Analyzer Updater v0.4
#
# @author:    Martin Willing
# @copyright: Copyright (c) 2025 Martin Willing. All rights reserved. Licensed under the MIT license.
# @contact:   Any feedback or suggestions are always welcome and much appreciated - mwilling@lethal-forensics.com
# @url:       https://lethal-forensics.com/
# @date:      2025-07-23
#
#
# ██╗     ███████╗████████╗██╗  ██╗ █████╗ ██╗      ███████╗ ██████╗ ██████╗ ███████╗███╗   ██╗███████╗██╗ ██████╗███████╗
# ██║     ██╔════╝╚══██╔══╝██║  ██║██╔══██╗██║      ██╔════╝██╔═══██╗██╔══██╗██╔════╝████╗  ██║██╔════╝██║██╔════╝██╔════╝
# ██║     █████╗     ██║   ███████║███████║██║█████╗█████╗  ██║   ██║██████╔╝█████╗  ██╔██╗ ██║███████╗██║██║     ███████╗
# ██║     ██╔══╝     ██║   ██╔══██║██╔══██║██║╚════╝██╔══╝  ██║   ██║██╔══██╗██╔══╝  ██║╚██╗██║╚════██║██║██║     ╚════██║
# ███████╗███████╗   ██║   ██║  ██║██║  ██║███████╗ ██║     ╚██████╔╝██║  ██║███████╗██║ ╚████║███████║██║╚██████╗███████║
# ╚══════╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚══════╝ ╚═╝      ╚═════╝ ╚═╝  ╚═╝╚══════╝╚═╝  ╚═══╝╚══════╝╚═╝ ╚═════╝╚══════╝
#
#
# Changelog:
# Version 0.1
# Release Date: 2024-09-02
# Initial Release
#
# Version 0.2
# Release Date: 2024-09-15
# Added: Sync for RECmd Batch Files
# Added: Check if the download of the packaged Zircolite binary was successful. Note: Some AV may not like the packaged binaries.
#
# Version 0.3
# Release Date: 2024-10-29
# Added: ClamAV Update
#
# Version 0.4
# Release Date: 2025-06-22
# Added: EZTools (.NET 9)
# Fixed: Minor fixes and improvements
#
#
# Tested on Windows 10 Pro (x64) Version 22H2 (10.0.19045.5965) and PowerShell 5.1 (5.1.19041.5965)
# Tested on Windows 10 Pro (x64) Version 22H2 (10.0.19045.5965) and PowerShell 7.5.1
#
#
#############################################################################################################################################################################################
#############################################################################################################################################################################################

<#
.SYNOPSIS
  MemProcFS-Analyzer Updater v0.4 - Automated Installer/Updater for MemProcFS-Analyzer

.DESCRIPTION
  Updater.ps1 is a PowerShell script utilized to automate the installation and the update process of MemProcFS-Analyzer (incl. all dependencies).

  https://github.com/evild3ad/MemProcFS-Analyzer

.EXAMPLE
  PS> .\Updater.ps1

.NOTES
  Author - Martin Willing

.LINK
  https://lethal-forensics.com/
#>

#############################################################################################################################################################################################
#############################################################################################################################################################################################

#region Initialisations

# Set Progress Preference to Silently Continue
$OriginalProgressPreference = $Global:ProgressPreference
$Global:ProgressPreference = 'SilentlyContinue'

#endregion Initialisations

#############################################################################################################################################################################################
#############################################################################################################################################################################################

#region Declarations

# Declarations

# Script Root
if ($PSVersionTable.PSVersion.Major -gt 2)
{
    # PowerShell 3+
    $script:SCRIPT_DIR = $PSScriptRoot
}
else
{
    # PowerShell 2
    $script:SCRIPT_DIR = Split-Path -Parent $MyInvocation.MyCommand.Definition
}

# Tools

# 7-Zip
$script:7za = "$SCRIPT_DIR\Tools\7-Zip\7za.exe"

# AmcacheParser
$script:AmcacheParser = "$SCRIPT_DIR\Tools\AmcacheParser\AmcacheParser.exe"

# AppCompatCacheParser
$script:AppCompatCacheParser = "$SCRIPT_DIR\Tools\AppCompatCacheParser\AppCompatCacheParser.exe"

# ClamAV
$script:freshclam = "C:\Program Files\ClamAV\freshclam.exe"
$script:clamscan = "C:\Program Files\ClamAV\clamscan.exe"
$script:clamd = "C:\Program Files\ClamAV\clamd.exe"
$script:clamdscan = "C:\Program Files\ClamAV\clamdscan.exe"

# Elasticsearch
$script:Elasticsearch = "$SCRIPT_DIR\Tools\Elasticsearch\bin\elasticsearch.bat"

# entropy
$script:entropy = "$SCRIPT_DIR\Tools\entropy\entropy.exe"

# EvtxECmd
$script:EvtxECmd = "$SCRIPT_DIR\Tools\EvtxECmd\EvtxECmd.exe"

# IPinfo CLI
$script:IPinfo = "$SCRIPT_DIR\Tools\IPinfo\ipinfo.exe"

# jq
$script:jq = "$SCRIPT_DIR\Tools\jq\jq-win64.exe"

# Kibana
$script:Kibana = "$SCRIPT_DIR\Tools\Kibana\bin\kibana.bat"

# lnk_parser
$script:lnk_parser = "$SCRIPT_DIR\Tools\lnk_parser\lnk_parser.exe"

# MemProcFS
$script:MemProcFS = "$SCRIPT_DIR\Tools\MemProcFS\MemProcFS.exe"

# RECmd
$script:RECmd = "$SCRIPT_DIR\Tools\RECmd\RECmd.exe"

# SBECmd
$script:SBECmd = "$SCRIPT_DIR\Tools\SBECmd\SBECmd.exe"

# xsv
$script:xsv = "$SCRIPT_DIR\Tools\xsv\xsv.exe"

# YARA
$script:yara64 = "$SCRIPT_DIR\Tools\YARA\yara64.exe"

# Zircolite
$script:zircolite = "$SCRIPT_DIR\Tools\Zircolite\zircolite.exe"

#endregion Declarations

#############################################################################################################################################################################################
#############################################################################################################################################################################################

#region Header

# Windows Title
$DefaultWindowsTitle = $Host.UI.RawUI.WindowTitle
$Host.UI.RawUI.WindowTitle = "MemProcFS-Analyzer Updater v0.4 - Automated Installer/Updater for MemProcFS-Analyzer"

# Check if the PowerShell script is being run with admin rights
if (!([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator))
{
    Write-Host "[Error] This PowerShell script must be run with admin rights." -ForegroundColor Red
    Exit
}

# Create a record of your PowerShell session to a text file
Start-Transcript -Path "$SCRIPT_DIR\Logs\Updater.txt"

# Get Start Time
$startTime = (Get-Date)

# Logo
$Logo = @"
██╗     ███████╗████████╗██╗  ██╗ █████╗ ██╗      ███████╗ ██████╗ ██████╗ ███████╗███╗   ██╗███████╗██╗ ██████╗███████╗
██║     ██╔════╝╚══██╔══╝██║  ██║██╔══██╗██║      ██╔════╝██╔═══██╗██╔══██╗██╔════╝████╗  ██║██╔════╝██║██╔════╝██╔════╝
██║     █████╗     ██║   ███████║███████║██║█████╗█████╗  ██║   ██║██████╔╝█████╗  ██╔██╗ ██║███████╗██║██║     ███████╗
██║     ██╔══╝     ██║   ██╔══██║██╔══██║██║╚════╝██╔══╝  ██║   ██║██╔══██╗██╔══╝  ██║╚██╗██║╚════██║██║██║     ╚════██║
███████╗███████╗   ██║   ██║  ██║██║  ██║███████╗ ██║     ╚██████╔╝██║  ██║███████╗██║ ╚████║███████║██║╚██████╗███████║
╚══════╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚══════╝ ╚═╝      ╚═════╝ ╚═╝  ╚═╝╚══════╝╚═╝  ╚═══╝╚══════╝╚═╝ ╚═════╝╚══════╝
"@

Write-Output ""
Write-Output "$Logo"
Write-Output ""

# Header
Write-Output "MemProcFS-Analyzer Updater v0.4 - Automated Installer/Updater for MemProcFS-Analyzer"
Write-Output "(c) 2025 Martin Willing at Lethal-Forensics (https://lethal-forensics.com/)"
Write-Output ""

# Update date (ISO 8601)
$script:UpdateDate = [datetime]::Now.ToUniversalTime().ToString("yyyy-MM-dd HH:mm:ss")
Write-Output "Update date: $UpdateDate UTC"
Write-Output ""

#endregion Header

#############################################################################################################################################################################################
#############################################################################################################################################################################################

#region Updater

Function Updater {

Function InternetConnectivityCheck {

# Internet Connectivity Check (Vista+)
$NetworkListManager = [Activator]::CreateInstance([Type]::GetTypeFromCLSID([Guid]‘{DCB00C01-570F-4A9B-8D69-199FDBA5723B}’)).IsConnectedToInternet

# Offline
if (!($NetworkListManager -eq "True"))
{
    Write-Host "[Error] Your computer is NOT connected to the Internet." -ForegroundColor Red
    $Host.UI.RawUI.WindowTitle = "$DefaultWindowsTitle"
    Exit
}

# Online
if ($NetworkListManager -eq "True")
{
    # Check if GitHub is reachable
    if (!(Test-NetConnection -ComputerName github.com -Port 443).TcpTestSucceeded)
    {
        Write-Host "[Error] github.com is NOT reachable. Please check your network connection and try again." -ForegroundColor Red
        $Host.UI.RawUI.WindowTitle = "$DefaultWindowsTitle"
        Exit
    }

    # Check if ericzimmermanstools.com is reachable
    if (!(Test-NetConnection -ComputerName ericzimmermanstools.com -Port 443).TcpTestSucceeded)
    {
        Write-Host "[Error] ericzimmermanstools.com is NOT reachable. Please check your network connection and try again." -ForegroundColor Red
        $Host.UI.RawUI.WindowTitle = "$DefaultWindowsTitle"
        Exit
    }
}

}

#############################################################################################################################################################################################

Function Get-MemProcFS {

# Check Current Version of MemProcFS
if (Test-Path "$($MemProcFS)")
{
    $CurrentVersion = & $MemProcFS -version | ForEach-Object{($_ -split "MemProcFS v")[1]}
    Write-Output "[Info]  Current Version: MemProcFS v$CurrentVersion"
    Start-Sleep 1
}
else
{
    Write-Output "[Info]  MemProcFS NOT found."
    $CurrentVersion = ""
}

# Determining latest release on GitHub
$Repository = "ufrisk/MemProcFS"
$Releases = "https://api.github.com/repos/$Repository/releases"
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$Response = (Invoke-WebRequest -Uri $Releases -UseBasicParsing | ConvertFrom-Json)[0]
$Download = ($Response.assets | Select-Object -ExpandProperty browser_download_url | Select-String -Pattern "win_x64" | Where-Object {$_ -notmatch "-latest"} | Out-String).Trim()
$FileName = $Download | ForEach-Object{($_ -split "/")[-1]}
$Version = $FileName | ForEach-Object{($_ -split "_")[4]} | ForEach-Object{($_ -split "-")[0]} | ForEach-Object{($_ -replace "v","")}
$ReleaseDate = ($FileName | ForEach-Object{($_ -split "-")[-1]} | ForEach-Object{($_ -replace "\.zip")}).Insert(4,"-").Insert(7,"-")

if ($CurrentVersion)
{
    Write-Output "[Info]  Latest Release:  MemProcFS v$Version ($ReleaseDate)"
}
else
{
    Write-Output "[Info]  Latest Release: MemProcFS v$Version ($ReleaseDate)"
}

# Check if MemProcFS needs to be downloaded/updated
if ($CurrentVersion -ne $Version -Or $null -eq $CurrentVersion)
{
    # Download latest release from GitHub
    Write-Output "[Info]  Dowloading Latest Release ..."
    $Zip = "MemProcFS.zip"
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
    Invoke-WebRequest -Uri $Download -OutFile "$SCRIPT_DIR\$Zip"

    if (Test-Path "$SCRIPT_DIR\$Zip")
    {
        # Unpacking Archive File
        Write-Output "[Info]  Extracting Files ..."
        Expand-Archive -Path "$SCRIPT_DIR\$Zip" -DestinationPath "$SCRIPT_DIR\Tools\MemProcFS" -Force

        # Remove Downloaded Archive
        Start-Sleep 5
        Remove-Item "$SCRIPT_DIR\$Zip" -Force
    } 
}
else
{
    Write-Host "[Info]  You are running the most recent version of MemProcFS." -ForegroundColor Green
}

}

#############################################################################################################################################################################################

Function Get-YaraCustomRules {

# Check Current Version of YARA Custom Rules
if (Test-Path "$SCRIPT_DIR\yara\*")
{
    if (Test-Path "$SCRIPT_DIR\yara\README.md")
    {
        $Content = Get-Content "$SCRIPT_DIR\yara\README.md" | Select-String -Pattern "Last updated:"
        $Pattern = "[0-9]{4}-[0-9]{2}-[0-9]{2}"
        $CurrentVersion = [regex]::Matches($Content, $Pattern).Value
        Write-Output "[Info]  Current Version of YARA Custom Rules: $CurrentVersion"
    }
    else
    {
        Write-Output "[Info]  README.md NOT found."
    }
}
else
{
    Write-Output "[Info]  YARA Custom Rules NOT found."
    $CurrentVersion = ""
}

# Determining latest update on GitHub
$WebRequest = Invoke-WebRequest -Uri "https://raw.githubusercontent.com/evild3ad/yara/main/README.md"
$Content = $WebRequest.Content.Split([Environment]::NewLine) | Select-String -Pattern "Last updated:"
$Pattern = "[0-9]{4}-[0-9]{2}-[0-9]{2}"
$LatestUpdate = [regex]::Matches($Content, $Pattern).Value
Write-Output "[Info]  Latest Update: $LatestUpdate"

# Check if YARA Custom Rules need to be downloaded/updated
if ($CurrentVersion -lt $LatestUpdate -Or $null -eq $CurrentVersion)
{
    # Download latest YARA Custom Rules from GitHub
    Write-Output "[Info]  Downloading YARA Custom Rules ..."
    Invoke-WebRequest "https://github.com/evild3ad/yara/archive/refs/heads/main.zip" -OutFile "$SCRIPT_DIR\yara.zip"

    if (Test-Path "$SCRIPT_DIR\yara.zip")
    {
        # Delete Directory Content and Remove Directory
        if (Test-Path "$SCRIPT_DIR\yara")
        {
            Get-ChildItem -Path "$SCRIPT_DIR\yara" -Recurse | Remove-Item -Force -Recurse
            Remove-Item "$SCRIPT_DIR\yara" -Force
        }

        # Unpacking Archive File
        Write-Output "[Info]  Extracting Files ..."
        Expand-Archive -Path "$SCRIPT_DIR\yara.zip" -DestinationPath "$SCRIPT_DIR" -Force

        # Rename Unpacked Directory
        Start-Sleep 10
        Rename-Item "$SCRIPT_DIR\yara-main" "$SCRIPT_DIR\yara" -Force

        # Remove Downloaded Archive
        Start-Sleep 5
        Remove-Item "$SCRIPT_DIR\yara.zip" -Force
    }
}
else
{
    Write-Host "[Info]  You are running the most recent YARA Custom Rules." -ForegroundColor Green
}

}

#############################################################################################################################################################################################

Function Get-Dokany {

# Check Current Version of Dokany File System Library
$Dokany = "$env:SystemDrive\Windows\System32\dokan2.dll"
if (Test-Path "$($Dokany)")
{
    $CurrentVersion = [System.Diagnostics.FileVersionInfo]::GetVersionInfo($Dokany).FileVersion
    $LastWriteTime = ((Get-Item $Dokany).LastWriteTime).ToString("yyyy-MM-dd")
    Write-Output "[Info]  Current Version: Dokany File System Library v$CurrentVersion ($LastWriteTime)"
}
else
{
    Write-Output "[Info]  Dokany File System Library NOT found."
    $CurrentVersion = ""
}

# Determining latest release of DokanSetup.exe on GitHub
# Note: Needs possibly a restart of the computer.
$Repository = "dokan-dev/dokany"
$Releases = "https://api.github.com/repos/$Repository/releases"
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$Response = (Invoke-WebRequest -Uri $Releases -UseBasicParsing | ConvertFrom-Json)[0]
$Tag = $Response.tag_name
$Published = $Response.published_at
if ($Published -is [String])
{
    $ReleaseDate = $Published.split('T')[0] # Windows PowerShell
}
else
{
    $ReleaseDate = $Published # PowerShell 7
}

if ($CurrentVersion)
{
    Write-Output "[Info]  Latest Release:  Dokany File System Library $Tag ($ReleaseDate)"
}
else
{
    Write-Output "[Info]  Latest Release: Dokany File System Library $Tag ($ReleaseDate)"
}

# Check if Dokany File System Library needs to be downloaded/updated
$LatestRelease = $Tag.Substring(1)
if ($CurrentVersion -ne $LatestRelease -Or $null -eq $CurrentVersion)
{
    Write-Host "[Error] Please download/install the latest release of Dokany File System Library manually:" -ForegroundColor Red
    Write-Host "        https://github.com/dokan-dev/dokany/releases/latest (DokanSetup.exe)" -ForegroundColor Red
}
else
{
    Write-Host "[Info]  You are running the most recent version of Dokany File System Library." -ForegroundColor Green
}

}

#############################################################################################################################################################################################

Function ClamAVUpdate {

# ClamAVUpdate

# freshclam.conf
if (!(Test-Path "C:\Program Files\ClamAV\freshclam.conf"))
{
    Write-Host "[Error] freshclam.conf is missing." -ForegroundColor Red
    Write-Host "        https://docs.clamav.net/manual/Usage/Configuration.html#windows --> First Time Set-Up" -ForegroundColor Red
}

# clamd.conf
if (!(Test-Path "C:\Program Files\ClamAV\clamd.conf"))
{
    Write-Host "[Error] clamd.conf is missing." -ForegroundColor Red
    Write-Host "        https://docs.clamav.net/manual/Usage/Configuration.html#windows --> First Time Set-Up" -ForegroundColor Red
}

# Update
if (Test-Path "$($freshclam)")
{
    # Internet Connectivity Check (Vista+)
    $NetworkListManager = [Activator]::CreateInstance([Type]::GetTypeFromCLSID([Guid]‘{DCB00C01-570F-4A9B-8D69-199FDBA5723B}’)).IsConnectedToInternet

    if (!($NetworkListManager -eq "True"))
    {
        Write-Host "[Error] Your computer is NOT connected to the Internet. ClamAV cannot check for any updates." -ForegroundColor Red
    }
    else
    {
        # Check if clamav.net is reachable
        if (!(Test-Connection -ComputerName clamav.net -Count 1 -Quiet))
        {
            Write-Host "[Error] clamav.net is NOT reachable. ClamAV cannot check for any updates." -ForegroundColor Red
        }
        else
        {
            Write-Output "[Info]  Checking for ClamAV Updates ..."
            New-Item "$SCRIPT_DIR\Tools\ClamAV" -ItemType Directory -Force | Out-Null
            & $freshclam > "$SCRIPT_DIR\Tools\ClamAV\Update.txt" 2> "$SCRIPT_DIR\Tools\ClamAV\Warning.txt"

            # Update ClamAV Engine
            if (Select-String -Pattern "WARNING: Your ClamAV installation is OUTDATED!" -Path "$SCRIPT_DIR\Tools\ClamAV\Warning.txt" -Quiet)
            {
                Write-Host "[Info]  WARNING: Your ClamAV installation is OUTDATED!" -ForegroundColor Red

                if (Select-String -Pattern "Recommended version:" -Path "$SCRIPT_DIR\Tools\ClamAV\Warning.txt" -Quiet)
                {
                    $WARNING = Get-Content "$SCRIPT_DIR\Tools\ClamAV\Warning.txt" | Select-String -Pattern "Recommended version:"
                    Write-Host "[Info]  $WARNING" -ForegroundColor Red
                }
            }

            # Update Signature Databases
            $Count = (Get-Content "$SCRIPT_DIR\Tools\ClamAV\Update.txt" | Select-String -Pattern "is up to date" | Measure-Object).Count
            if ($Count -match "3")
            {
                Write-Output "[Info]  All ClamAV Virus Databases (CVD) are up-to-date."
            }
            else
            {
                Write-Output "[Info]  Updating ClamAV Virus Databases (CVD) ... "
            }
        }
    }
}
else
{
    Write-Host "[Error] freshclam.exe NOT found." -ForegroundColor Red
}

# Engine Version
if (Test-Path "$($clamscan)")
{
    $Version = & $clamscan -V
    $EngineVersion = $Version.Split('/')[0]
    $Patch = $Version.Split('/')[1]
    Write-Output "[Info]  Engine Version: $EngineVersion (#$Patch)"
}
else
{
    Write-Host "[Error] clamscan.exe NOT found." -ForegroundColor Red
}

}

#############################################################################################################################################################################################

Function Get-Elasticsearch {

# Elasticsearch
# https://github.com/elastic/elasticsearch

# Check Current Version of Elasticsearch
if (Test-Path "$($Elasticsearch)")
{
    $CurrentVersion = & $Elasticsearch --version | ForEach-Object{($_ -split "\s+")[1]} | ForEach-Object{($_ -replace ",","")}
    Write-Output "[Info]  Current Version: Elasticsearch v$CurrentVersion"
    Start-Sleep 1
}
else
{
    Write-Output "[Info]  Elasticsearch NOT found."
    $CurrentVersion = ""
}

# Determining latest release of Elasticsearch on GitHub
$Repository = "elastic/elasticsearch"
$Releases = "https://api.github.com/repos/$Repository/releases"
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$Response = (Invoke-WebRequest -Uri $Releases -UseBasicParsing | ConvertFrom-Json)
$Versions = $Response.tag_name | Where-Object{($_ -notmatch "-rc")} | Where-Object{($_ -notmatch "-beta")} | ForEach-Object{($_ -replace "v","")}
$Latest = ($Versions | ForEach-Object{[System.Version]$_ } | Sort-Object -Descending | Select-Object -First 1).ToString()
$Item = $Response | Where-Object{($_.tag_name -eq "v$Latest")}
$Tag = $Item.tag_name
$Published = $Item.published_at
if ($Published -is [String])
{
    $ReleaseDate = $Published.split('T')[0] # Windows PowerShell
}
else
{
    $ReleaseDate = $Published # PowerShell 7
}

if ($CurrentVersion)
{
    Write-Output "[Info]  Latest Release:  Elasticsearch $Tag ($ReleaseDate)"
}
else
{
    Write-Output "[Info]  Latest Release: Elasticsearch $Tag ($ReleaseDate)"
}

# Check if Elasticsearch needs to be downloaded/updated
$LatestRelease = $Tag.Substring(1)
if ($CurrentVersion -ne $LatestRelease -Or $null -eq $CurrentVersion)
{
    # Download latest release from elastic.co
    Write-Output "[Info]  Dowloading Latest Release ..."
    $Download = "https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-$LatestRelease-windows-x86_64.zip"
    $Zip = "Elasticsearch.zip"
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
    Invoke-WebRequest -Uri $Download -OutFile "$SCRIPT_DIR\Tools\$Zip"

    if (Test-Path "$SCRIPT_DIR\Tools\$Zip")
    {
        # Delete Directory Content and Remove Directory
        if (Test-Path "$SCRIPT_DIR\Tools\Elasticsearch")
        {
            Get-ChildItem -Path "$SCRIPT_DIR\Tools\Elasticsearch" -Recurse | Remove-Item -Force -Recurse
            Remove-Item "$SCRIPT_DIR\Tools\Elasticsearch" -Force
        }

        # Unpacking Archive File
        Write-Output "[Info]  Extracting Files ..."
        Expand-Archive -Path "$SCRIPT_DIR\Tools\$Zip" -DestinationPath "$SCRIPT_DIR\Tools" -Force

        # Rename Unpacked Directory
        Start-Sleep 10
        Rename-Item "$SCRIPT_DIR\Tools\elasticsearch-$LatestRelease" "$SCRIPT_DIR\Tools\Elasticsearch" -Force

        # Remove Downloaded Archive
        Start-Sleep 5
        Remove-Item "$SCRIPT_DIR\Tools\$Zip" -Force
    } 
}
else
{
    Write-Host "[Info]  You are running the most recent version of Elasticsearch." -ForegroundColor Green
}

}

#############################################################################################################################################################################################

Function Get-Kibana {

# Kibana
# https://github.com/elastic/kibana

# Check Current Version of Kibana
if (Test-Path "$($Kibana)")
{
    $CurrentVersion = & $Kibana --version | Select-Object -Last 1
    Write-Output "[Info]  Current Version: Kibana v$CurrentVersion"
    Start-Sleep 1
}
else
{
    Write-Output "[Info]  Kibana NOT found."
    $CurrentVersion = ""
}

# Determining latest release of Kibana on GitHub
$Repository = "elastic/kibana"
$Releases = "https://api.github.com/repos/$Repository/releases"
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$Response = (Invoke-WebRequest -Uri $Releases -UseBasicParsing | ConvertFrom-Json)
$Versions = $Response.tag_name | Where-Object{($_ -notmatch "-rc")} | Where-Object{($_ -notmatch "-beta")} | ForEach-Object{($_ -replace "v","")}
$Latest = ($Versions | ForEach-Object{[System.Version]$_ } | Sort-Object -Descending | Select-Object -First 1).ToString()
$Item = $Response | Where-Object{($_.tag_name -eq "v$Latest")}
$Tag = $Item.tag_name
$Published = $Item.published_at
if ($Published -is [String])
{
    $ReleaseDate = $Published.split('T')[0] # Windows PowerShell
}
else
{
    $ReleaseDate = $Published # PowerShell 7
}

if ($CurrentVersion)
{
    Write-Output "[Info]  Latest Release:  Kibana $Tag ($ReleaseDate)"
}
else
{
    Write-Output "[Info]  Latest Release: Kibana $Tag ($ReleaseDate)"
}

# Check if Kibana needs to be downloaded/updated
$LatestRelease = $Tag.Substring(1)
if ($CurrentVersion -ne $LatestRelease -Or $null -eq $CurrentVersion)
{
    # Download latest release from elastic.co
    Write-Output "[Info]  Dowloading Latest Release ..."
    $Download = "https://artifacts.elastic.co/downloads/kibana/kibana-$LatestRelease-windows-x86_64.zip"
    $Zip = "Kibana.zip"
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
    Invoke-WebRequest -Uri $Download -OutFile "$SCRIPT_DIR\Tools\$Zip"

    if (Test-Path "$SCRIPT_DIR\Tools\$Zip")
    {
        # Delete Directory Content and Remove Directory
        if (Test-Path "$SCRIPT_DIR\Tools\Kibana")
        {
            Get-ChildItem -Path "$SCRIPT_DIR\Tools\Kibana" -Recurse | Remove-Item -Force -Recurse
            Remove-Item "$SCRIPT_DIR\Tools\Kibana" -Force
        }

        # Unpacking Archive File
        Write-Output "[Info]  Extracting Files ..."
        if (Test-Path "$($7za)")
        {
            $DestinationPath = "$SCRIPT_DIR\Tools"
            & $7za x "$SCRIPT_DIR\Tools\$Zip" "-o$DestinationPath" > $null 2>&1
        }
        else
        {
            Write-Host "[Error] 7za.exe NOT found." -ForegroundColor Red
            Stop-Transcript
            $Host.UI.RawUI.WindowTitle = "$DefaultWindowsTitle"
            Exit
        }

        # Rename Unpacked Directory
        Start-Sleep 10
        Rename-Item "$SCRIPT_DIR\Tools\kibana-$LatestRelease" "$SCRIPT_DIR\Tools\Kibana" -Force

        # Remove Downloaded Archive
        Start-Sleep 5
        Remove-Item "$SCRIPT_DIR\Tools\$Zip" -Force
    } 
}
else
{
    Write-Host "[Info]  You are running the most recent version of Kibana." -ForegroundColor Green
}

}

#############################################################################################################################################################################################

Function Get-AmcacheParser {

# AmcacheParser (.NET 9)
# https://ericzimmerman.github.io

# Check Current Version and ETag of AmcacheParser
if (Test-Path "$($AmcacheParser)")
{
    # Current Version
    $CurrentVersion = [System.Diagnostics.FileVersionInfo]::GetVersionInfo($AmcacheParser).FileVersion
    Write-Output "[Info]  Current Version: AmcacheParser v$CurrentVersion"

    # ETag
    if (Test-Path "$SCRIPT_DIR\Tools\AmcacheParser\ETag.txt")
    {
        $CurrentETag = Get-Content "$SCRIPT_DIR\Tools\AmcacheParser\ETag.txt"
    }
    else
    {
        $CurrentETag = ""
    }

    # Determining latest release of AmcacheParser
    $ProgressPreference = 'SilentlyContinue'
    $URL = "https://download.ericzimmermanstools.com/net9/AmcacheParser.zip"
    $Headers = (Invoke-WebRequest -Uri $URL -UseBasicParsing -Method Head).Headers
    $LatestETag = ($Headers["ETag"]).Replace('"','')
}
else
{
    Write-Output "[Info]  AmcacheParser NOT found."
    $CurrentETag = ""
}

if ($null -eq $CurrentETag -or $CurrentETag -ne $LatestETag)
{
    # Download latest release from ericzimmermanstools.com
    Write-Output "[Info]  Dowloading Latest Release ..."
    $ProgressPreference = 'SilentlyContinue'
    $URL = "https://download.ericzimmermanstools.com/net9/AmcacheParser.zip"
    $Zip = "AmcacheParser.zip"
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
    Invoke-WebRequest -Uri $URL -OutFile "$SCRIPT_DIR\Tools\$Zip"

    if (Test-Path "$SCRIPT_DIR\Tools\$Zip")
    {
        # Delete Directory Content and Remove Directory
        if (Test-Path "$SCRIPT_DIR\Tools\AmcacheParser")
        {
            Get-ChildItem -Path "$SCRIPT_DIR\Tools\AmcacheParser" -Recurse | Remove-Item -Force -Recurse
            Remove-Item "$SCRIPT_DIR\Tools\AmcacheParser" -Force
        }

        # Unpacking Archive File
        Write-Output "[Info]  Extracting Files ..."
        Expand-Archive -Path "$SCRIPT_DIR\Tools\$Zip" -DestinationPath "$SCRIPT_DIR\Tools\AmcacheParser" -Force

        # Latest ETag of AmcacheParser.zip
        $LatestETag | Out-File "$SCRIPT_DIR\Tools\AmcacheParser\ETag.txt"

        # Remove Downloaded Archive
        Remove-Item "$SCRIPT_DIR\Tools\$Zip" -Force
    }
}
else
{
    Write-Host "[Info]  You are running the most recent version of AmcacheParser." -ForegroundColor Green
}

}

#############################################################################################################################################################################################

Function Get-AppCompatCacheParser {

# AppCompatCacheParser (.NET 9)
# https://ericzimmerman.github.io

# Check Current Version and ETag of AppCompatCacheParser
if (Test-Path "$($AppCompatCacheParser)")
{
    # Current Version
    $CurrentVersion = [System.Diagnostics.FileVersionInfo]::GetVersionInfo($AppCompatCacheParser).FileVersion
    Write-Output "[Info]  Current Version: AppCompatCacheParser v$CurrentVersion"

    # ETag
    if (Test-Path "$SCRIPT_DIR\Tools\AppCompatCacheParser\ETag.txt")
    {
        $CurrentETag = Get-Content "$SCRIPT_DIR\Tools\AppCompatCacheParser\ETag.txt"
    }
    else
    {
        $CurrentETag = ""
    }

    # Determining latest release of AppCompatCacheParser
    $ProgressPreference = 'SilentlyContinue'
    $URL = "https://download.ericzimmermanstools.com/net9/AppCompatCacheParser.zip"
    $Headers = (Invoke-WebRequest -Uri $URL -UseBasicParsing -Method Head).Headers
    $LatestETag = ($Headers["ETag"]).Replace('"','')
}
else
{
    Write-Output "[Info]  AppCompatCacheParser NOT found."
    $CurrentETag = ""
}

if ($null -eq $CurrentETag -or $CurrentETag -ne $LatestETag)
{
    # Download latest release from ericzimmermanstools.com
    Write-Output "[Info]  Dowloading Latest Release ..."
    $ProgressPreference = 'SilentlyContinue'
    $URL = "https://download.ericzimmermanstools.com/net9/AppCompatCacheParser.zip"
    $Zip = "AppCompatCacheParser.zip"
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
    Invoke-WebRequest -Uri $URL -OutFile "$SCRIPT_DIR\Tools\$Zip"

    if (Test-Path "$SCRIPT_DIR\Tools\$Zip")
    {
        # Delete Directory Content and Remove Directory
        if (Test-Path "$SCRIPT_DIR\Tools\AppCompatCacheParser")
        {
            Get-ChildItem -Path "$SCRIPT_DIR\Tools\AppCompatCacheParser" -Recurse | Remove-Item -Force -Recurse
            Remove-Item "$SCRIPT_DIR\Tools\AppCompatCacheParser" -Force
        }

        # Unpacking Archive File
        Write-Output "[Info]  Extracting Files ..."
        Expand-Archive -Path "$SCRIPT_DIR\Tools\$Zip" -DestinationPath "$SCRIPT_DIR\Tools\AppCompatCacheParser" -Force

        # Latest ETag of AppCompatCacheParser.zip
        $LatestETag | Out-File "$SCRIPT_DIR\Tools\AppCompatCacheParser\ETag.txt"

        # Remove Downloaded Archive
        Remove-Item "$SCRIPT_DIR\Tools\$Zip" -Force
    }
}
else
{
    Write-Host "[Info]  You are running the most recent version of AppCompatCacheParser." -ForegroundColor Green
}

}

#############################################################################################################################################################################################

Function Get-Entropy {

# entropy
# https://github.com/merces/entropy

# Check Current Version of entropy.exe
if (Test-Path "$($entropy)")
{
    # Current Version
    if (Test-Path "$SCRIPT_DIR\Tools\entropy\Version.txt")
    {
        $CurrentVersion = Get-Content "$SCRIPT_DIR\Tools\entropy\Version.txt"
        $LastWriteTime = ((Get-Item $entropy).LastWriteTime).ToString("yyyy-MM-dd")
        Write-Output "[Info]  Current Version: entropy v$CurrentVersion ($LastWriteTime)"
    }
    else
    {
        $CurrentVersion = ""
    }
}
else
{
    Write-Output "[Info]  entropy.exe NOT found."
    $CurrentVersion = ""
}

# Determining latest release on GitHub
$Repository = "merces/entropy"
$Latest = "https://api.github.com/repos/$Repository/releases/latest"
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$Response = (Invoke-WebRequest -Uri $Latest -UseBasicParsing | ConvertFrom-Json)[0]
$Tag = $Response.tag_name
$Published = $Response.published_at
$Download = ($Response.assets | Select-Object -ExpandProperty browser_download_url | Select-String -Pattern "-win64" | Out-String).Trim()
if ($Published -is [String])
{
    $ReleaseDate = $Published.split('T')[0] # Windows PowerShell
}
else
{
    $ReleaseDate = $Published # PowerShell 7
}
$LatestRelease = $Tag.Substring(1)

if ($CurrentVersion)
{
    Write-Output "[Info]  Latest Release:  entropy $Tag ($ReleaseDate)"
}
else
{
    Write-Output "[Info]  Latest Release: entropy $Tag ($ReleaseDate)"
}

# Check if entropy.exe needs to be downloaded/updated
if ($CurrentVersion -ne $LatestRelease -Or $null -eq $CurrentVersion)
{
    Write-Output "[Info]  Dowloading Latest Release ..."
    $Zip = "entropy.zip"
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
    Invoke-WebRequest -Uri $Download -OutFile "$SCRIPT_DIR\$Zip"

    if (Test-Path "$SCRIPT_DIR\$Zip")
    {
        # Delete Directory Content and Remove Directory
        if (Test-Path "$SCRIPT_DIR\Tools\entropy")
        {
            Get-ChildItem -Path "$SCRIPT_DIR\Tools\entropy" -Recurse | Remove-Item -Force -Recurse
            Remove-Item "$SCRIPT_DIR\Tools\entropy" -Force
        }

        # Unpacking Archive File
        Write-Output "[Info]  Extracting Files ..."
        Expand-Archive -Path "$SCRIPT_DIR\$Zip" -DestinationPath "$SCRIPT_DIR\Tools" -Force

        # Version
        Write-Output "$LatestRelease" | Out-File "$SCRIPT_DIR\Tools\entropy\Version.txt"

        # Remove Downloaded Archive
        Start-Sleep 5
        Remove-Item "$SCRIPT_DIR\$Zip" -Force
    }
}
else
{
    Write-Host "[Info]  You are running the most recent version of entropy." -ForegroundColor Green
}

}

#############################################################################################################################################################################################

Function Get-EvtxECmd {

# EvtxECmd (.NET 9)
# https://ericzimmerman.github.io

# Check Current Version and ETag of EvtxECmd
if (Test-Path "$($EvtxECmd)")
{
    # Current Version
    $CurrentVersion = [System.Diagnostics.FileVersionInfo]::GetVersionInfo($EvtxECmd).FileVersion
    Write-Output "[Info]  Current Version: EvtxECmd v$CurrentVersion"

    # ETag
    if (Test-Path "$SCRIPT_DIR\Tools\EvtxECmd\ETag.txt")
    {
        $CurrentETag = Get-Content "$SCRIPT_DIR\Tools\EvtxECmd\ETag.txt"
    }
    else
    {
        $CurrentETag = ""
    }

    # Determining latest release of EvtxECmd
    $ProgressPreference = 'SilentlyContinue'
    $URL = "https://download.ericzimmermanstools.com/net9/EvtxECmd.zip"
    $Headers = (Invoke-WebRequest -Uri $URL -UseBasicParsing -Method Head).Headers
    $LatestETag = ($Headers["ETag"]).Replace('"','')
}
else
{
    Write-Output "[Info]  EvtxECmd NOT found."
    $CurrentETag = ""
}

if ($null -eq $CurrentETag -or $CurrentETag -ne $LatestETag)
{
    # Download latest release from ericzimmermanstools.com
    Write-Output "[Info]  Dowloading Latest Release ..."
    $ProgressPreference = 'SilentlyContinue'
    $URL = "https://download.ericzimmermanstools.com/net9/EvtxECmd.zip"
    $Zip = "EvtxECmd.zip"
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
    Invoke-WebRequest -Uri $URL -OutFile "$SCRIPT_DIR\Tools\$Zip"

    if (Test-Path "$SCRIPT_DIR\Tools\$Zip")
    {
        # Delete Directory Content and Remove Directory
        if (Test-Path "$SCRIPT_DIR\Tools\EvtxECmd")
        {
            Get-ChildItem -Path "$SCRIPT_DIR\Tools\EvtxECmd" -Recurse | Remove-Item -Force -Recurse
            Remove-Item "$SCRIPT_DIR\Tools\EvtxECmd" -Force
        }

        # Unpacking Archive File
        Write-Output "[Info]  Extracting Files ..."
        Expand-Archive -Path "$SCRIPT_DIR\Tools\$Zip" -DestinationPath "$SCRIPT_DIR\Tools" -Force

        # Latest ETag of EvtxECmd.zip
        $LatestETag | Out-File "$SCRIPT_DIR\Tools\EvtxECmd\ETag.txt"

        # Remove Downloaded Archive
        Remove-Item "$SCRIPT_DIR\Tools\$Zip" -Force
    }
}
else
{
    Write-Host "[Info]  You are running the most recent version of EvtxECmd." -ForegroundColor Green
}

# Updating Event Log Maps
Write-Output "[Info]  Updating Event Log Maps ... "

# Flush Event Log Maps Directory
if (Test-Path "$SCRIPT_DIR\Tools\EvtxECmd\Maps")
{
    Get-ChildItem -Path "$SCRIPT_DIR\Tools\EvtxECmd\Maps" -Recurse | Remove-Item -Force -Recurse
}

# Sync for EvtxECmd Maps
if (Test-Path "$($EvtxECmd)")
{
    & $EvtxECmd --sync > "$SCRIPT_DIR\Tools\EvtxECmd\Maps.log" 2> $null

    # Updates found!
    if (Test-Path "$SCRIPT_DIR\Tools\EvtxECmd\Maps.log")
    {
        if (Get-Content "$SCRIPT_DIR\Tools\EvtxECmd\Maps.log" | Select-String -Pattern "Updates found!" -Quiet)
        {
            Write-Output "[Info]  Event Log Maps updated."
        }
    }
}
else
{
    Write-Host "[Error] EvtxECmd.exe NOT found." -ForegroundColor Red
}

}

#############################################################################################################################################################################################

Function Get-ImportExcel {

# ImportExcel
# https://github.com/dfinke/ImportExcel

# Check if PowerShell module 'ImportExcel' exists
if (Get-Module -ListAvailable -Name ImportExcel) 
{
    # Check if multiple versions of PowerShell module 'ImportExcel' exist
    $Modules = (Get-Module -ListAvailable -Name ImportExcel | Measure-Object).Count

    if ($Modules -eq "1")
    {
        # Check Current Version
        $CurrentVersion = (Get-Module -ListAvailable -Name ImportExcel).Version.ToString()
        Write-Output "[Info]  Current Version: ImportExcel v$CurrentVersion"
    }
    else
    {
        Write-Host "[Info]  Multiple installed versions of PowerShell module 'ImportExcel' found. Uninstalling ..."
        Uninstall-Module -Name ImportExcel -AllVersions -ErrorAction SilentlyContinue
        $CurrentVersion = $null
    }
}
else
{
    Write-Output "[Info]  PowerShell module 'ImportExcel' NOT found."
    $CurrentVersion = $null
}

# Determining latest release on GitHub
$Repository = "dfinke/ImportExcel"
$Releases = "https://api.github.com/repos/$Repository/releases"
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$Response = (Invoke-WebRequest -Uri $Releases -UseBasicParsing | ConvertFrom-Json)[0]
$Tag = $Response.tag_name
$Published = $Response.published_at
if ($Published -is [String])
{
    $ReleaseDate = $Published.split('T')[0] # Windows PowerShell
}
else
{
    $ReleaseDate = $Published # PowerShell 7
}
$LatestRelease = $Tag.Substring(1)

if ($CurrentVersion)
{
    Write-Output "[Info]  Latest Release:  ImportExcel $Tag ($ReleaseDate)"
}
else
{
    Write-Output "[Info]  Latest Release: ImportExcel $Tag ($ReleaseDate)"
}

# Check if ImportExcel needs to be installed
if ($null -eq $CurrentVersion)
{
    Write-Output "[Info]  Installing ImportExcel v$LatestRelease ..."
    Install-Module -Name ImportExcel -Scope CurrentUser -Repository PSGallery -Force
    $CurrentVersion = (Get-Module -ListAvailable -Name ImportExcel).Version.ToString()
}

# Check if ImportExcel needs to be updated
if ($CurrentVersion -ne $LatestRelease)
{
    # Update PowerShell module 'ImportExcel'
    try
    {
        Write-Output "[Info]  Updating PowerShell module 'ImportExcel' ..."
        Uninstall-Module -Name ImportExcel -AllVersions -ErrorAction SilentlyContinue
        Install-Module -Name ImportExcel -Scope CurrentUser -Repository PSGallery -Force
    }
    catch
    {
        Write-Output "PowerShell module 'ImportExcel' is in use. Please close PowerShell session, and run MemProcFS-Analyzer.ps1 again."
    }
}
else
{
    Write-Host "[Info]  You are running the most recent version of ImportExcel." -ForegroundColor Green
}

}

#############################################################################################################################################################################################

Function Get-IPinfo {

# IPinfo CLI
# https://github.com/ipinfo/cli

# Check Current Version of IPinfo CLI
if (Test-Path "$($IPinfo)")
{
    $CurrentVersion = & $IPinfo version
    $LastWriteTime = ((Get-Item $IPinfo).LastWriteTime).ToString("yyyy-MM-dd")
    Write-Output "[Info]  Current Version: IPinfo CLI v$CurrentVersion ($LastWriteTime)"
}
else
{
    Write-Output "[Info]  IPinfo CLI NOT found."
    $CurrentVersion = ""
}

# Determining latest release on GitHub
$Repository = "ipinfo/cli"
$Releases = "https://api.github.com/repos/$Repository/releases"
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$Response = (Invoke-WebRequest -Uri $Releases -UseBasicParsing | ConvertFrom-Json)

$Asset=0
while($true) {
  $Check = $Response[$Asset].assets | Select-Object @{Name="browser_download_orl"; Expression={$_.browser_download_url}} | Select-String -Pattern "ipinfo_" -Quiet
  if ($Check -eq "True" )
  {
    Break
  }
  else
  {
    $Asset++
  }
}

$TagName = $Response[$Asset].tag_name
$Tag = $TagName.Split("-")[1] 
$Published = $Response[$Asset].published_at
$Download = ($Response[$Asset].assets | Select-Object -ExpandProperty browser_download_url | Select-String -Pattern "windows_amd64" | Out-String).Trim()
if ($Published -is [String])
{
    $ReleaseDate = $Published.split('T')[0] # Windows PowerShell
}
else
{
    $ReleaseDate = $Published # PowerShell 7
}

if ($CurrentVersion)
{
    Write-Output "[Info]  Latest Release:  IPinfo CLI v$Tag ($ReleaseDate)"
}
else
{
    Write-Output "[Info]  Latest Release: IPinfo CLI v$Tag ($ReleaseDate)"
}

# Check if IPinfo CLI needs to be downloaded/updated
if ($CurrentVersion -ne $Tag -Or $null -eq $CurrentVersion)
{
    # Download latest release from GitHub
    Write-Output "[Info]  Dowloading Latest Release ..."
    $Zip = "IPinfo.zip"
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
    Invoke-WebRequest -Uri $Download -OutFile "$SCRIPT_DIR\$Zip"

    if (Test-Path "$SCRIPT_DIR\$Zip")
    {
        # Delete Directory Content and Remove Directory
        if (Test-Path "$SCRIPT_DIR\Tools\IPinfo")
        {
            Get-ChildItem -Path "$SCRIPT_DIR\Tools\IPinfo" -Recurse | Remove-Item -Force -Recurse
            Remove-Item "$SCRIPT_DIR\Tools\IPinfo" -Force
        }

        # Unpacking Archive File
        Write-Output "[Info]  Extracting Files ..."
        Expand-Archive -Path "$SCRIPT_DIR\$Zip" -DestinationPath "$SCRIPT_DIR\Tools\IPinfo" -Force

        # Remove Downloaded Archive
        Start-Sleep 5
        Remove-Item "$SCRIPT_DIR\$Zip" -Force

        # Rename Executable
        if (Test-Path "$SCRIPT_DIR\Tools\IPinfo\ipinfo_*")
        {
            Get-ChildItem -Path "$SCRIPT_DIR\Tools\IPinfo\ipinfo_*.exe" | Rename-Item -NewName {"ipinfo.exe"}
        }
    } 
}
else
{
    Write-Host "[Info]  You are running the most recent version of IPinfo CLI." -ForegroundColor Green
}

}

#############################################################################################################################################################################################

Function Get-jq {

# jq - Command-line JSON processor
# https://github.com/stedolan/jq

# Check Current Version of jq
if (Test-Path "$($jq)")
{
    $CurrentVersion = & $jq --version | ForEach-Object{($_ -split "-")[1]}
    Write-Output "[Info]  Current Version: jq v$CurrentVersion"
}
else
{
    Write-Output "[Info]  jq-win64.exe NOT found."
    $CurrentVersion = ""
}

# Determining latest stable release on GitHub
$Repository = "stedolan/jq"
$Latest = "https://api.github.com/repos/$Repository/releases/latest"
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$Response = (Invoke-WebRequest -Uri $Latest -UseBasicParsing | ConvertFrom-Json)[0]
$Tag = $Response.tag_name | ForEach-Object{($_ -split "-")[1]}
$Published = $Response.published_at
$Download = ($Response.assets | Select-Object -ExpandProperty browser_download_url | Select-String -Pattern "jq-win64.exe" | Out-String).Trim()
if ($Published -is [String])
{
    $ReleaseDate = $Published.split('T')[0] # Windows PowerShell
}
else
{
    $ReleaseDate = $Published # PowerShell 7
}

if ($CurrentVersion)
{
    Write-Output "[Info]  Latest Release:  jq v$Tag ($ReleaseDate)"
}
else
{
    Write-Output "[Info]  Latest Release: jq v$Tag ($ReleaseDate)"
}

# Check if jq needs to be downloaded/updated
if ($CurrentVersion -ne $Tag -Or $null -eq $CurrentVersion)
{
    if (Test-Path "$SCRIPT_DIR\Tools\jq\jq-win64.exe")
    {
        Get-ChildItem -Path "$SCRIPT_DIR\Tools\jq" -Recurse | Remove-Item -Force -Recurse
    }
    else
    {
        New-Item "$SCRIPT_DIR\Tools\jq" -ItemType Directory -Force | Out-Null
    }

    # Download latest release from GitHub
    Write-Output "[Info]  Dowloading Latest Release ..."
    $EXE = "jq-win64.exe"
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
    Invoke-WebRequest -Uri $Download -OutFile "$SCRIPT_DIR\Tools\jq\$EXE"
}
else
{
    Write-Host "[Info]  You are running the most recent version of jq." -ForegroundColor Green
}

}

#############################################################################################################################################################################################

Function Get-lnk_parser {

# lnk_parser
# https://github.com/AbdulRhmanAlfaifi/lnk_parser

# Check Current Version of lnk_parser
if (Test-Path "$($lnk_parser)")
{
    $CurrentVersion = & $lnk_parser --version | ForEach-Object{($_ -split "\s+")[1]}
    $LastWriteTime = ((Get-Item $lnk_parser).LastWriteTime).ToString("yyyy-MM-dd")
    Write-Output "[Info]  Current Version: lnk_parser v$CurrentVersion ($LastWriteTime)"
}
else
{
    Write-Output "[Info]  lnk_parser.exe NOT found."
    $CurrentVersion = ""
}

# Determining latest release on GitHub
$Repository = "AbdulRhmanAlfaifi/lnk_parser"
$Latest = "https://api.github.com/repos/$Repository/releases/latest"
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$Response = (Invoke-WebRequest -Uri $Latest -UseBasicParsing | ConvertFrom-Json)[0]
$Tag = $Response.tag_name
$Published = $Response.published_at
$Download = ($Response.assets | Select-Object -ExpandProperty browser_download_url | Select-String -Pattern "lnk_parser_.*\.exe" | Out-String).Trim()
if ($Published -is [String])
{
    $ReleaseDate = $Published.split('T')[0] # Windows PowerShell
}
else
{
    $ReleaseDate = $Published # PowerShell 7
}

if ($CurrentVersion)
{
    Write-Output "[Info]  Latest Release:  lnk_parser $Tag ($ReleaseDate)"
}
else
{
    Write-Output "[Info]  Latest Release: lnk_parser $Tag ($ReleaseDate)"
}

# Check if lnk_parser needs to be downloaded/updated
$LatestRelease = $Tag.Substring(1)
if ($CurrentVersion -ne $LatestRelease -Or $null -eq $CurrentVersion)
{
    if (Test-Path "$SCRIPT_DIR\Tools\lnk_parser\lnk_parser.exe")
    {
        Get-ChildItem -Path "$SCRIPT_DIR\Tools\lnk_parser" -Recurse | Remove-Item -Force -Recurse
    }
    else
    {
        New-Item "$SCRIPT_DIR\Tools\lnk_parser" -ItemType Directory -Force | Out-Null
    }
    
    # Download latest release from GitHub
    Write-Output "[Info]  Dowloading Latest Release ..."
    $EXE = "lnk_parser.exe"
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
    Invoke-WebRequest -Uri $Download -OutFile "$SCRIPT_DIR\Tools\lnk_parser\$EXE"
}
else
{
    Write-Host "[Info]  You are running the most recent version of lnk_parser." -ForegroundColor Green
}

}

#############################################################################################################################################################################################

Function Get-RECmd {

# RECmd (.NET 9)
# https://ericzimmerman.github.io

# Check Current Version and ETag of RECmd
if (Test-Path "$($RECmd)")
{
    # Current Version
    $CurrentVersion = [System.Diagnostics.FileVersionInfo]::GetVersionInfo($RECmd).FileVersion
    Write-Output "[Info]  Current Version: RECmd v$CurrentVersion"

    # SHA1
    if (Test-Path "$SCRIPT_DIR\Tools\RECmd\ETag.txt")
    {
        $CurrentETag = Get-Content "$SCRIPT_DIR\Tools\RECmd\ETag.txt"
    }
    else
    {
        $CurrentETag = ""
    }

    # Determining latest release of RECmd
    $ProgressPreference = 'SilentlyContinue'
    $URL = "https://download.ericzimmermanstools.com/net9/RECmd.zip"
    $Headers = (Invoke-WebRequest -Uri $URL -UseBasicParsing -Method Head).Headers
    $LatestETag = ($Headers["ETag"]).Replace('"','')
}
else
{
    Write-Output "[Info]  RECmd.exe NOT found."
    $CurrentETag = ""
}

if ($null -eq $CurrentETag -or $CurrentETag -ne $LatestETag)
{
    # Download latest release from ericzimmermanstools.com
    Write-Output "[Info]  Dowloading Latest Release ..."
    $ProgressPreference = 'SilentlyContinue'
    $URL = "https://download.ericzimmermanstools.com/net9/RECmd.zip"
    $Zip = "RECmd.zip"
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
    Invoke-WebRequest -Uri $URL -OutFile "$SCRIPT_DIR\Tools\$Zip"

    if (Test-Path "$SCRIPT_DIR\Tools\$Zip")
    {
        # Delete Directory Content and Remove Directory
        if (Test-Path "$SCRIPT_DIR\Tools\RECmd")
        {
            Get-ChildItem -Path "$SCRIPT_DIR\Tools\RECmd" -Recurse | Remove-Item -Force -Recurse
            Remove-Item "$SCRIPT_DIR\Tools\RECmd" -Force
        }

        # Unpacking Archive File
        Write-Output "[Info]  Extracting Files ..."
        Expand-Archive -Path "$SCRIPT_DIR\Tools\$Zip" -DestinationPath "$SCRIPT_DIR\Tools" -Force

        # Latest ETag of RECmd.zip
        $LatestETag | Out-File "$SCRIPT_DIR\Tools\RECmd\ETag.txt"

        # Remove Downloaded Archive
        Remove-Item "$SCRIPT_DIR\Tools\$Zip" -Force
    }
}
else
{
    Write-Host "[Info]  You are running the most recent version of RECmd." -ForegroundColor Green
}

# Sync for RECmd Batch Files
if (Test-Path "$($RECmd)")
{
    Write-Output "[Info]  Updating RECmd Batch Files ... "
    & $RECmd --sync > "$SCRIPT_DIR\Tools\RECmd\Sync.log" 2> $null

    # No new batch files available
    if (Test-Path "$SCRIPT_DIR\Tools\RECmd\Sync.log")
    {
        if (Get-Content "$SCRIPT_DIR\Tools\RECmd\Sync.log" | Select-String -Pattern "No new batch files available" -Quiet)
        {
            Write-Output "[Info]  No new RECmd Batch Files available."
        }
    }

    # Updates found!
    if (Test-Path "$SCRIPT_DIR\Tools\RECmd\Sync.log")
    {
        if (Get-Content "$SCRIPT_DIR\Tools\RECmd\Sync.log" | Select-String -Pattern "Updates found!" -Quiet)
        {
            Write-Output "[Info]  RECmd Batch Files updated."
        }
    }
}
else
{
    Write-Output "[Info]  RECmd.exe NOT found."
}

}

#############################################################################################################################################################################################

Function Get-SBECmd {

# SBECmd (.NET 9)
# https://ericzimmerman.github.io

# Check Current Version and ETag of SBECmd
if (Test-Path "$($SBECmd)")
{
    # Current Version
    $CurrentVersion = [System.Diagnostics.FileVersionInfo]::GetVersionInfo($SBECmd).FileVersion
    Write-Output "[Info]  Current Version: SBECmd v$CurrentVersion"

    # ETag
    if (Test-Path "$SCRIPT_DIR\Tools\SBECmd\ETag.txt")
    {
        $CurrentETag = Get-Content "$SCRIPT_DIR\Tools\SBECmd\ETag.txt"
    }
    else
    {
        $CurrentETag = ""
    }

    # Determining latest release of SBECmd
    $ProgressPreference = 'SilentlyContinue'
    $URL = "https://download.ericzimmermanstools.com/net9/SBECmd.zip"
    $Headers = (Invoke-WebRequest -Uri $URL -UseBasicParsing -Method Head).Headers
    $LatestETag = ($Headers["ETag"]).Replace('"','')
}
else
{
    Write-Output "[Info]  SBECmd NOT found."
    $CurrentETag = ""
}

if ($null -eq $CurrentETag -or $CurrentETag -ne $LatestETag)
{
    # Download latest release from ericzimmermanstools.com
    Write-Output "[Info]  Dowloading Latest Release ..."
    $ProgressPreference = 'SilentlyContinue'
    $URL = "https://download.ericzimmermanstools.com/net9/SBECmd.zip"
    $Zip = "SBECmd.zip"
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
    Invoke-WebRequest -Uri $URL -OutFile "$SCRIPT_DIR\Tools\$Zip"

    if (Test-Path "$SCRIPT_DIR\Tools\$Zip")
    {
        # Delete Directory Content and Remove Directory
        if (Test-Path "$SCRIPT_DIR\Tools\SBECmd")
        {
            Get-ChildItem -Path "$SCRIPT_DIR\Tools\SBECmd" -Recurse | Remove-Item -Force -Recurse
            Remove-Item "$SCRIPT_DIR\Tools\SBECmd" -Force
        }

        # Unpacking Archive File
        Write-Output "[Info]  Extracting Files ..."
        Expand-Archive -Path "$SCRIPT_DIR\Tools\$Zip" -DestinationPath "$SCRIPT_DIR\Tools\SBECmd" -Force

        # Latest ETag of SBECmd.zip
        $LatestETag | Out-File "$SCRIPT_DIR\Tools\SBECmd\ETag.txt"

        # Remove Downloaded Archive
        Remove-Item "$SCRIPT_DIR\Tools\$Zip" -Force
    }
}
else
{
    Write-Host "[Info]  You are running the most recent version of SBECmd." -ForegroundColor Green
}

}

#############################################################################################################################################################################################

Function Get-XSV {

# xsv
# https://github.com/BurntSushi/xsv

# Check Current Version of xsv
if (Test-Path "$($xsv)")
{
    $CurrentVersion = & $xsv --version
    $LastWriteTime = ((Get-Item $xsv).LastWriteTime).ToString("yyyy-MM-dd")
    Write-Output "[Info]  Current Version: xsv v$CurrentVersion ($LastWriteTime)"
}
else
{
    Write-Output "[Info]  xsv.exe NOT found."
    $CurrentVersion = ""
}

# Determining latest release on GitHub
$Repository = "BurntSushi/xsv"
$Releases = "https://api.github.com/repos/$Repository/releases/latest"
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$Response = (Invoke-WebRequest -Uri $Releases -UseBasicParsing | ConvertFrom-Json)
$Tag = $Response.tag_name
$Published = $Response.published_at
$Download = ($Response.assets | Select-Object -ExpandProperty browser_download_url | Select-String -Pattern "-x86_64-pc-windows-msvc" | Out-String).Trim()
if ($Published -is [String])
{
    $ReleaseDate = $Published.split('T')[0] # Windows PowerShell
}
else
{
    $ReleaseDate = $Published # PowerShell 7
}
if ($CurrentVersion)
{
    Write-Output "[Info]  Latest Release:  xsv v$Tag ($ReleaseDate)"
}
else
{
    Write-Output "[Info]  Latest Release: xsv v$Tag ($ReleaseDate)"
}

# Check if xsv needs to be downloaded/updated
if ($CurrentVersion -ne $Tag -Or $null -eq $CurrentVersion)
{
    # Download latest release from GitHub
    Write-Output "[Info]  Dowloading Latest Release ..."
    $Zip = "xsv.zip"
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
    Invoke-WebRequest -Uri $Download -OutFile "$SCRIPT_DIR\$Zip"

    if (Test-Path "$SCRIPT_DIR\$Zip")
    {
        # Delete Directory Content and Remove Directory
        if (Test-Path "$SCRIPT_DIR\Tools\xsv")
        {
            Get-ChildItem -Path "$SCRIPT_DIR\Tools\xsv" -Recurse | Remove-Item -Force -Recurse
            Remove-Item "$SCRIPT_DIR\Tools\xsv" -Force
        }

        # Unpacking Archive File
        Write-Output "[Info]  Extracting Files ..."
        Expand-Archive -Path "$SCRIPT_DIR\$Zip" -DestinationPath "$SCRIPT_DIR\Tools\xsv" -Force

        # Remove Downloaded Archive
        Start-Sleep 5
        Remove-Item "$SCRIPT_DIR\$Zip" -Force
    }
}
else
{
    Write-Host "[Info]  You are running the most recent version of xsv." -ForegroundColor Green
}

}

#############################################################################################################################################################################################

Function Get-Yara {

# YARA
# https://github.com/VirusTotal/yara

# Check Current Version of YARA
if (Test-Path "$($yara64)")
{
    $CurrentVersion = & $yara64 --version
    $LastWriteTime = ((Get-Item $yara64).LastWriteTime).ToString("yyyy-MM-dd")
    Write-Output "[Info]  Current Version: YARA v$CurrentVersion ($LastWriteTime)"
}
else
{
    Write-Output "[Info]  yara64.exe NOT found."
    $CurrentVersion = ""
}

# Determining latest release on GitHub
$Repository = "VirusTotal/yara"
$Latest = "https://api.github.com/repos/$Repository/releases/latest"
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$Response = (Invoke-WebRequest -Uri $Latest -UseBasicParsing | ConvertFrom-Json)[0]
$Tag = $Response.tag_name
$Published = $Response.published_at
$Download = ($Response.assets | Select-Object -ExpandProperty browser_download_url | Select-String -Pattern "-win64" | Out-String).Trim()
if ($Published -is [String])
{
    $ReleaseDate = $Published.split('T')[0] # Windows PowerShell
}
else
{
    $ReleaseDate = $Published # PowerShell 7
}

if ($CurrentVersion)
{
    Write-Output "[Info]  Latest Release:  YARA $Tag ($ReleaseDate)"
}
else
{
    Write-Output "[Info]  Latest Release: YARA $Tag ($ReleaseDate)"
}

# Check if YARA needs to be downloaded/updated
$LatestRelease = $Tag.Substring(1)
if ($CurrentVersion -ne $LatestRelease -Or $null -eq $CurrentVersion)
{
    # Download latest release from GitHub
    Write-Output "[Info]  Dowloading Latest Release ..."
    $Zip = "yara64.zip"
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
    Invoke-WebRequest -Uri $Download -OutFile "$SCRIPT_DIR\$Zip"

    if (Test-Path "$SCRIPT_DIR\$Zip")
    {
        # Delete Directory Content and Remove Directory
        if (Test-Path "$SCRIPT_DIR\Tools\YARA")
        {
            Get-ChildItem -Path "$SCRIPT_DIR\Tools\YARA" -Recurse | Remove-Item -Force -Recurse
            Remove-Item "$SCRIPT_DIR\Tools\YARA" -Force
        }

        # Unpacking Archive File
        Write-Output "[Info]  Extracting Files ..."
        Expand-Archive -Path "$SCRIPT_DIR\$Zip" -DestinationPath "$SCRIPT_DIR\Tools\YARA" -Force

        # Remove Downloaded Archive
        Start-Sleep 5
        Remove-Item "$SCRIPT_DIR\$Zip" -Force
    }
}
else
{
    Write-Host "[Info]  You are running the most recent version of YARA." -ForegroundColor Green
}

}

#############################################################################################################################################################################################

Function Get-Zircolite {

# Check Current Version of Zircolite
if (Test-Path "$($Zircolite)")
{
    $MyLocation = $pwd
    Set-Location "$SCRIPT_DIR\Tools\Zircolite"
    $CurrentVersion = (& $Zircolite --version 2>&1 | Select-String -Pattern "Zircolite -" | ForEach-Object{($_ -split "\s+")[-1]}).Substring(1)
    Set-Location "$MyLocation"
    Write-Output "[Info]  Current Version: Zircolite v$CurrentVersion"

    # zircolite.log
    if (Test-Path "$SCRIPT_DIR\Tools\Zircolite\zircolite.log")
    {
        Remove-Item -Path "$SCRIPT_DIR\Tools\Zircolite\zircolite.log" -Force
    }
}
else
{
    Write-Output "[Info]  Zircolite NOT found."
    $CurrentVersion = ""
}

# Determining latest stable release on GitHub
$Repository = "https://api.github.com/repos/wagga40/Zircolite/releases"
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

$Release=0
while($false) {
    $Release++
    $Check = (Invoke-WebRequest -Uri $Repository -UseBasicParsing | ConvertFrom-Json)[$Release].prerelease
    if ($Check -eq "False" )
    {
        $Release
        Break
    }
}
    
$Response = (Invoke-WebRequest -Uri $Repository -UseBasicParsing | ConvertFrom-Json)[$Release]
$Tag = $Response.tag_name
$Published = $Response.published_at
if ($Published -is [String])
{
    $LatestRelease = $Published.split('T')[0] # Windows PowerShell
}
else
{
    $LatestRelease = $Published # PowerShell 7
}
$Download = ($Response.assets | Select-Object -ExpandProperty browser_download_url | Select-String -Pattern "zircolite_win_x64" | Out-String).Trim()

if ($CurrentVersion)
{
    Write-Output "[Info]  Latest Release:  Zircolite v$Tag ($LatestRelease)"
}
else
{
    Write-Output "[Info]  Latest Release: Zircolite v$Tag ($LatestRelease)"
}

# Check if Zircolite needs to be updated
if ($CurrentVersion -ne $Tag -Or $null -eq $CurrentVersion)
{
    # Download latest release from GitHub
    Write-Output "[Info]  Dowloading Latest Release ..."
    $7Zip = "Zircolite.7z"
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
    Invoke-WebRequest -Uri $Download -OutFile "$SCRIPT_DIR\Tools\$7Zip"

    if (Test-Path "$SCRIPT_DIR\Tools\$7Zip")
    {
        # Unblock Archive File
        Unblock-File -Path "$SCRIPT_DIR\Tools\$7Zip"

        # Delete Directory Content and Remove Directory
        if (Test-Path "$SCRIPT_DIR\Tools\Zircolite")
        {
            Get-ChildItem -Path "$SCRIPT_DIR\Tools\Zircolite" -Recurse | Remove-Item -Force -Recurse
            Remove-Item "$SCRIPT_DIR\Tools\Zircolite" -Force
        }

        # Unpacking Archive File
        if (Test-Path "$($7za)")
        {
            Write-Output "[Info]  Extracting Files ..."
            & $7za x "$SCRIPT_DIR\Tools\$7Zip" "-o$SCRIPT_DIR\Tools" 2>&1 | Out-Null
        }
        else
        {
            Write-Output "[Info]  7-Zip is NOT installed."
        }

        # Rename Unpacked Directory
        Start-Sleep 5
        if (Test-Path "$SCRIPT_DIR\Tools\zircolite_win")
        {
            Rename-Item "$SCRIPT_DIR\Tools\zircolite_win" "$SCRIPT_DIR\Tools\Zircolite" -Force
        }
        else
        {
            Write-Host "[Error] It seems that the packaged Zircolite binary was blocked by your AV!" -ForegroundColor Red
        }

        # Rename Binary
        if (Test-Path "$SCRIPT_DIR\Tools\Zircolite\zircolite_*")
        {
            Get-ChildItem -Path "$SCRIPT_DIR\Tools\Zircolite\zircolite_*.exe" | Rename-Item -NewName {"zircolite.exe"}
        }

        # Remove Downloaded Archive
        Start-Sleep 5
        Remove-Item "$SCRIPT_DIR\Tools\$7Zip" -Force
    }
}
else
{
    Write-Host "[Info]  You are running the most recent version of Zircolite." -ForegroundColor Green
}

# Update SIGMA Rulesets
if (Test-Path "$($Zircolite)")
{
    Write-Output "[Info]  Updating SIGMA Rulesets ..."
    $MyLocation = $pwd
    Set-Location "$SCRIPT_DIR\Tools\Zircolite"
    & $Zircolite --update-rules 2>&1 | Out-File "$SCRIPT_DIR\Tools\Zircolite\Update-draft.log"
    Set-Location "$MyLocation"

    # No newer rulesets found
    if (Test-Path "$SCRIPT_DIR\Tools\Zircolite\Update-draft.log")
    {
        if (Get-Content "$SCRIPT_DIR\Tools\Zircolite\Update-draft.log" | Select-String -Pattern "No newer rulesets found" -Quiet)
        {
            Write-Output "[Info]  No newer rulesets found"
        }
    }

    # Updated
    if (Test-Path "$SCRIPT_DIR\Tools\Zircolite\Update-draft.log")
    {
        if (Get-Content "$SCRIPT_DIR\Tools\Zircolite\Update-draft.log" | Select-String -Pattern "Updated :" -Quiet)
        {
            Write-Output "[Info]  SIGMA Rulesets updated."
        }
    }

    # Remove ANSI Control Characters
    if (Test-Path "$SCRIPT_DIR\Tools\Zircolite\Update-draft.log")
    {
        Get-Content "$SCRIPT_DIR\Tools\Zircolite\Update-draft.log" | ForEach-Object { $_ -replace "\x1b\[[0-9;]*m" } | Out-File "$SCRIPT_DIR\Tools\Zircolite\Update.log"
        Remove-Item "$SCRIPT_DIR\Tools\Zircolite\Update-draft.log"
    }

    # Remove empty lines and add line breaks where needed
    $Clean = Get-Content "$SCRIPT_DIR\Tools\Zircolite\Update.log" | ForEach-Object{($_ -replace "^   ","")} | Where-Object {$_.Trim()} | ForEach-Object {($_ -replace "Finished in", "`nFinished in")} | ForEach-Object {($_ -replace "Sysmon Linux =-", "Sysmon Linux =-`n")}
    @("") + ($Clean) | Set-Content "$SCRIPT_DIR\Tools\Zircolite\Update.log"

    # Cleaning up
    if (Test-Path "$SCRIPT_DIR\Tools\Zircolite\Update.log")
    {
        $Filter = @("^zircolite\.exe","MemProcFS-Analyzer-v.*\.ps1","^\+","\+ CategoryInfo          : NotSpecified:","\+ FullyQualifiedErrorId : NativeCommandError","^tmp-rules-")
        $Clean = Get-Content "$SCRIPT_DIR\Tools\Zircolite\Update.log" | Select-String -Pattern $Filter -NotMatch 
        $Clean | Set-Content "$SCRIPT_DIR\Tools\Zircolite\Update.log"
    }

    # zircolite.log
    if (Test-Path "$SCRIPT_DIR\Tools\Zircolite\zircolite.log")
    {
        Remove-Item -Path "$SCRIPT_DIR\Tools\Zircolite\zircolite.log" -Force
    }
}
else
{
    Write-Host "[Error] zircolite.exe NOT found." -ForegroundColor Red
}

}

#############################################################################################################################################################################################

# Installer/Updater
InternetConnectivityCheck
Get-MemProcFS
Get-YaraCustomRules
Get-Dokany
ClamAVUpdate
Get-Elasticsearch
Get-Kibana
Get-AmcacheParser
Get-AppCompatCacheParser
Get-Entropy
Get-EvtxECmd
Get-ImportExcel
Get-IPinfo
Get-jq
Get-lnk_parser
Get-RECmd
Get-SBECmd
Get-XSV
Get-Yara
Get-Zircolite

}

Updater

#endregion Updater

#############################################################################################################################################################################################
#############################################################################################################################################################################################

#region Footer

# Get End Time
$endTime = (Get-Date)

# Echo Time elapsed
Write-Output ""
Write-Output "FINISHED!"

$Time = ($endTime-$startTime)
$ElapsedTime = ('Overall update duration: {0} h {1} min {2} sec' -f $Time.Hours, $Time.Minutes, $Time.Seconds)
Write-Output "$ElapsedTime"

# Stop logging
Write-Host ""
Stop-Transcript
Start-Sleep 1

# Reset Progress Preference
$Global:ProgressPreference = $OriginalProgressPreference

# Reset Windows Title
$Host.UI.RawUI.WindowTitle = "$DefaultWindowsTitle"

#endregion Footer

#############################################################################################################################################################################################
#############################################################################################################################################################################################

# SIG # Begin signature block
# MIIrywYJKoZIhvcNAQcCoIIrvDCCK7gCAQExCzAJBgUrDgMCGgUAMGkGCisGAQQB
# gjcCAQSgWzBZMDQGCisGAQQBgjcCAR4wJgIDAQAABBAfzDtgWUsITrck0sYpfvNR
# AgEAAgEAAgEAAgEAAgEAMCEwCQYFKw4DAhoFAAQUxodKpd5oEjvb7ykDqYxCpmsv
# 8fSggiUEMIIFbzCCBFegAwIBAgIQSPyTtGBVlI02p8mKidaUFjANBgkqhkiG9w0B
# AQwFADB7MQswCQYDVQQGEwJHQjEbMBkGA1UECAwSR3JlYXRlciBNYW5jaGVzdGVy
# MRAwDgYDVQQHDAdTYWxmb3JkMRowGAYDVQQKDBFDb21vZG8gQ0EgTGltaXRlZDEh
# MB8GA1UEAwwYQUFBIENlcnRpZmljYXRlIFNlcnZpY2VzMB4XDTIxMDUyNTAwMDAw
# MFoXDTI4MTIzMTIzNTk1OVowVjELMAkGA1UEBhMCR0IxGDAWBgNVBAoTD1NlY3Rp
# Z28gTGltaXRlZDEtMCsGA1UEAxMkU2VjdGlnbyBQdWJsaWMgQ29kZSBTaWduaW5n
# IFJvb3QgUjQ2MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAjeeUEiIE
# JHQu/xYjApKKtq42haxH1CORKz7cfeIxoFFvrISR41KKteKW3tCHYySJiv/vEpM7
# fbu2ir29BX8nm2tl06UMabG8STma8W1uquSggyfamg0rUOlLW7O4ZDakfko9qXGr
# YbNzszwLDO/bM1flvjQ345cbXf0fEj2CA3bm+z9m0pQxafptszSswXp43JJQ8mTH
# qi0Eq8Nq6uAvp6fcbtfo/9ohq0C/ue4NnsbZnpnvxt4fqQx2sycgoda6/YDnAdLv
# 64IplXCN/7sVz/7RDzaiLk8ykHRGa0c1E3cFM09jLrgt4b9lpwRrGNhx+swI8m2J
# mRCxrds+LOSqGLDGBwF1Z95t6WNjHjZ/aYm+qkU+blpfj6Fby50whjDoA7NAxg0P
# OM1nqFOI+rgwZfpvx+cdsYN0aT6sxGg7seZnM5q2COCABUhA7vaCZEao9XOwBpXy
# bGWfv1VbHJxXGsd4RnxwqpQbghesh+m2yQ6BHEDWFhcp/FycGCvqRfXvvdVnTyhe
# Be6QTHrnxvTQ/PrNPjJGEyA2igTqt6oHRpwNkzoJZplYXCmjuQymMDg80EY2NXyc
# uu7D1fkKdvp+BRtAypI16dV60bV/AK6pkKrFfwGcELEW/MxuGNxvYv6mUKe4e7id
# FT/+IAx1yCJaE5UZkADpGtXChvHjjuxf9OUCAwEAAaOCARIwggEOMB8GA1UdIwQY
# MBaAFKARCiM+lvEH7OKvKe+CpX/QMKS0MB0GA1UdDgQWBBQy65Ka/zWWSC8oQEJw
# IDaRXBeF5jAOBgNVHQ8BAf8EBAMCAYYwDwYDVR0TAQH/BAUwAwEB/zATBgNVHSUE
# DDAKBggrBgEFBQcDAzAbBgNVHSAEFDASMAYGBFUdIAAwCAYGZ4EMAQQBMEMGA1Ud
# HwQ8MDowOKA2oDSGMmh0dHA6Ly9jcmwuY29tb2RvY2EuY29tL0FBQUNlcnRpZmlj
# YXRlU2VydmljZXMuY3JsMDQGCCsGAQUFBwEBBCgwJjAkBggrBgEFBQcwAYYYaHR0
# cDovL29jc3AuY29tb2RvY2EuY29tMA0GCSqGSIb3DQEBDAUAA4IBAQASv6Hvi3Sa
# mES4aUa1qyQKDKSKZ7g6gb9Fin1SB6iNH04hhTmja14tIIa/ELiueTtTzbT72ES+
# BtlcY2fUQBaHRIZyKtYyFfUSg8L54V0RQGf2QidyxSPiAjgaTCDi2wH3zUZPJqJ8
# ZsBRNraJAlTH/Fj7bADu/pimLpWhDFMpH2/YGaZPnvesCepdgsaLr4CnvYFIUoQx
# 2jLsFeSmTD1sOXPUC4U5IOCFGmjhp0g4qdE2JXfBjRkWxYhMZn0vY86Y6GnfrDyo
# XZ3JHFuu2PMvdM+4fvbXg50RlmKarkUT2n/cR/vfw1Kf5gZV6Z2M8jpiUbzsJA8p
# 1FiAhORFe1rYMIIGFDCCA/ygAwIBAgIQeiOu2lNplg+RyD5c9MfjPzANBgkqhkiG
# 9w0BAQwFADBXMQswCQYDVQQGEwJHQjEYMBYGA1UEChMPU2VjdGlnbyBMaW1pdGVk
# MS4wLAYDVQQDEyVTZWN0aWdvIFB1YmxpYyBUaW1lIFN0YW1waW5nIFJvb3QgUjQ2
# MB4XDTIxMDMyMjAwMDAwMFoXDTM2MDMyMTIzNTk1OVowVTELMAkGA1UEBhMCR0Ix
# GDAWBgNVBAoTD1NlY3RpZ28gTGltaXRlZDEsMCoGA1UEAxMjU2VjdGlnbyBQdWJs
# aWMgVGltZSBTdGFtcGluZyBDQSBSMzYwggGiMA0GCSqGSIb3DQEBAQUAA4IBjwAw
# ggGKAoIBgQDNmNhDQatugivs9jN+JjTkiYzT7yISgFQ+7yavjA6Bg+OiIjPm/N/t
# 3nC7wYUrUlY3mFyI32t2o6Ft3EtxJXCc5MmZQZ8AxCbh5c6WzeJDB9qkQVa46xiY
# Epc81KnBkAWgsaXnLURoYZzksHIzzCNxtIXnb9njZholGw9djnjkTdAA83abEOHQ
# 4ujOGIaBhPXG2NdV8TNgFWZ9BojlAvflxNMCOwkCnzlH4oCw5+4v1nssWeN1y4+R
# laOywwRMUi54fr2vFsU5QPrgb6tSjvEUh1EC4M29YGy/SIYM8ZpHadmVjbi3Pl8h
# JiTWw9jiCKv31pcAaeijS9fc6R7DgyyLIGflmdQMwrNRxCulVq8ZpysiSYNi79tw
# 5RHWZUEhnRfs/hsp/fwkXsynu1jcsUX+HuG8FLa2BNheUPtOcgw+vHJcJ8HnJCrc
# UWhdFczf8O+pDiyGhVYX+bDDP3GhGS7TmKmGnbZ9N+MpEhWmbiAVPbgkqykSkzyY
# Vr15OApZYK8CAwEAAaOCAVwwggFYMB8GA1UdIwQYMBaAFPZ3at0//QET/xahbIIC
# L9AKPRQlMB0GA1UdDgQWBBRfWO1MMXqiYUKNUoC6s2GXGaIymzAOBgNVHQ8BAf8E
# BAMCAYYwEgYDVR0TAQH/BAgwBgEB/wIBADATBgNVHSUEDDAKBggrBgEFBQcDCDAR
# BgNVHSAECjAIMAYGBFUdIAAwTAYDVR0fBEUwQzBBoD+gPYY7aHR0cDovL2NybC5z
# ZWN0aWdvLmNvbS9TZWN0aWdvUHVibGljVGltZVN0YW1waW5nUm9vdFI0Ni5jcmww
# fAYIKwYBBQUHAQEEcDBuMEcGCCsGAQUFBzAChjtodHRwOi8vY3J0LnNlY3RpZ28u
# Y29tL1NlY3RpZ29QdWJsaWNUaW1lU3RhbXBpbmdSb290UjQ2LnA3YzAjBggrBgEF
# BQcwAYYXaHR0cDovL29jc3Auc2VjdGlnby5jb20wDQYJKoZIhvcNAQEMBQADggIB
# ABLXeyCtDjVYDJ6BHSVY/UwtZ3Svx2ImIfZVVGnGoUaGdltoX4hDskBMZx5NY5L6
# SCcwDMZhHOmbyMhyOVJDwm1yrKYqGDHWzpwVkFJ+996jKKAXyIIaUf5JVKjccev3
# w16mNIUlNTkpJEor7edVJZiRJVCAmWAaHcw9zP0hY3gj+fWp8MbOocI9Zn78xvm9
# XKGBp6rEs9sEiq/pwzvg2/KjXE2yWUQIkms6+yslCRqNXPjEnBnxuUB1fm6bPAV+
# Tsr/Qrd+mOCJemo06ldon4pJFbQd0TQVIMLv5koklInHvyaf6vATJP4DfPtKzSBP
# kKlOtyaFTAjD2Nu+di5hErEVVaMqSVbfPzd6kNXOhYm23EWm6N2s2ZHCHVhlUgHa
# C4ACMRCgXjYfQEDtYEK54dUwPJXV7icz0rgCzs9VI29DwsjVZFpO4ZIVR33LwXyP
# DbYFkLqYmgHjR3tKVkhh9qKV2WCmBuC27pIOx6TYvyqiYbntinmpOqh/QPAnhDge
# xKG9GX/n1PggkGi9HCapZp8fRwg8RftwS21Ln61euBG0yONM6noD2XQPrFwpm3Gc
# uqJMf0o8LLrFkSLRQNwxPDDkWXhW+gZswbaiie5fd/W2ygcto78XCSPfFWveUOSZ
# 5SqK95tBO8aTHmEa4lpJVD7HrTEn9jb1EGvxOb1cnn0CMIIGGjCCBAKgAwIBAgIQ
# Yh1tDFIBnjuQeRUgiSEcCjANBgkqhkiG9w0BAQwFADBWMQswCQYDVQQGEwJHQjEY
# MBYGA1UEChMPU2VjdGlnbyBMaW1pdGVkMS0wKwYDVQQDEyRTZWN0aWdvIFB1Ymxp
# YyBDb2RlIFNpZ25pbmcgUm9vdCBSNDYwHhcNMjEwMzIyMDAwMDAwWhcNMzYwMzIx
# MjM1OTU5WjBUMQswCQYDVQQGEwJHQjEYMBYGA1UEChMPU2VjdGlnbyBMaW1pdGVk
# MSswKQYDVQQDEyJTZWN0aWdvIFB1YmxpYyBDb2RlIFNpZ25pbmcgQ0EgUjM2MIIB
# ojANBgkqhkiG9w0BAQEFAAOCAY8AMIIBigKCAYEAmyudU/o1P45gBkNqwM/1f/bI
# U1MYyM7TbH78WAeVF3llMwsRHgBGRmxDeEDIArCS2VCoVk4Y/8j6stIkmYV5Gej4
# NgNjVQ4BYoDjGMwdjioXan1hlaGFt4Wk9vT0k2oWJMJjL9G//N523hAm4jF4UjrW
# 2pvv9+hdPX8tbbAfI3v0VdJiJPFy/7XwiunD7mBxNtecM6ytIdUlh08T2z7mJEXZ
# D9OWcJkZk5wDuf2q52PN43jc4T9OkoXZ0arWZVeffvMr/iiIROSCzKoDmWABDRzV
# /UiQ5vqsaeFaqQdzFf4ed8peNWh1OaZXnYvZQgWx/SXiJDRSAolRzZEZquE6cbcH
# 747FHncs/Kzcn0Ccv2jrOW+LPmnOyB+tAfiWu01TPhCr9VrkxsHC5qFNxaThTG5j
# 4/Kc+ODD2dX/fmBECELcvzUHf9shoFvrn35XGf2RPaNTO2uSZ6n9otv7jElspkfK
# 9qEATHZcodp+R4q2OIypxR//YEb3fkDn3UayWW9bAgMBAAGjggFkMIIBYDAfBgNV
# HSMEGDAWgBQy65Ka/zWWSC8oQEJwIDaRXBeF5jAdBgNVHQ4EFgQUDyrLIIcouOxv
# SK4rVKYpqhekzQwwDgYDVR0PAQH/BAQDAgGGMBIGA1UdEwEB/wQIMAYBAf8CAQAw
# EwYDVR0lBAwwCgYIKwYBBQUHAwMwGwYDVR0gBBQwEjAGBgRVHSAAMAgGBmeBDAEE
# ATBLBgNVHR8ERDBCMECgPqA8hjpodHRwOi8vY3JsLnNlY3RpZ28uY29tL1NlY3Rp
# Z29QdWJsaWNDb2RlU2lnbmluZ1Jvb3RSNDYuY3JsMHsGCCsGAQUFBwEBBG8wbTBG
# BggrBgEFBQcwAoY6aHR0cDovL2NydC5zZWN0aWdvLmNvbS9TZWN0aWdvUHVibGlj
# Q29kZVNpZ25pbmdSb290UjQ2LnA3YzAjBggrBgEFBQcwAYYXaHR0cDovL29jc3Au
# c2VjdGlnby5jb20wDQYJKoZIhvcNAQEMBQADggIBAAb/guF3YzZue6EVIJsT/wT+
# mHVEYcNWlXHRkT+FoetAQLHI1uBy/YXKZDk8+Y1LoNqHrp22AKMGxQtgCivnDHFy
# AQ9GXTmlk7MjcgQbDCx6mn7yIawsppWkvfPkKaAQsiqaT9DnMWBHVNIabGqgQSGT
# rQWo43MOfsPynhbz2Hyxf5XWKZpRvr3dMapandPfYgoZ8iDL2OR3sYztgJrbG6VZ
# 9DoTXFm1g0Rf97Aaen1l4c+w3DC+IkwFkvjFV3jS49ZSc4lShKK6BrPTJYs4NG1D
# GzmpToTnwoqZ8fAmi2XlZnuchC4NPSZaPATHvNIzt+z1PHo35D/f7j2pO1S8BCys
# QDHCbM5Mnomnq5aYcKCsdbh0czchOm8bkinLrYrKpii+Tk7pwL7TjRKLXkomm5D1
# Umds++pip8wH2cQpf93at3VDcOK4N7EwoIJB0kak6pSzEu4I64U6gZs7tS/dGNSl
# jf2OSSnRr7KWzq03zl8l75jy+hOds9TWSenLbjBQUGR96cFr6lEUfAIEHVC1L68Y
# 1GGxx4/eRI82ut83axHMViw1+sVpbPxg51Tbnio1lB93079WPFnYaOvfGAA0e0zc
# fF/M9gXr+korwQTh2Prqooq2bYNMvUoUKD85gnJ+t0smrWrb8dee2CvYZXD5laGt
# aAxOfy/VKNmwuWuAh9kcMIIGYjCCBMqgAwIBAgIRAKQpO24e3denNAiHrXpOtyQw
# DQYJKoZIhvcNAQEMBQAwVTELMAkGA1UEBhMCR0IxGDAWBgNVBAoTD1NlY3RpZ28g
# TGltaXRlZDEsMCoGA1UEAxMjU2VjdGlnbyBQdWJsaWMgVGltZSBTdGFtcGluZyBD
# QSBSMzYwHhcNMjUwMzI3MDAwMDAwWhcNMzYwMzIxMjM1OTU5WjByMQswCQYDVQQG
# EwJHQjEXMBUGA1UECBMOV2VzdCBZb3Jrc2hpcmUxGDAWBgNVBAoTD1NlY3RpZ28g
# TGltaXRlZDEwMC4GA1UEAxMnU2VjdGlnbyBQdWJsaWMgVGltZSBTdGFtcGluZyBT
# aWduZXIgUjM2MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA04SV9G6k
# U3jyPRBLeBIHPNyUgVNnYayfsGOyYEXrn3+SkDYTLs1crcw/ol2swE1TzB2aR/5J
# IjKNf75QBha2Ddj+4NEPKDxHEd4dEn7RTWMcTIfm492TW22I8LfH+A7Ehz0/safc
# 6BbsNBzjHTt7FngNfhfJoYOrkugSaT8F0IzUh6VUwoHdYDpiln9dh0n0m545d5A5
# tJD92iFAIbKHQWGbCQNYplqpAFasHBn77OqW37P9BhOASdmjp3IijYiFdcA0WQIe
# 60vzvrk0HG+iVcwVZjz+t5OcXGTcxqOAzk1frDNZ1aw8nFhGEvG0ktJQknnJZE3D
# 40GofV7O8WzgaAnZmoUn4PCpvH36vD4XaAF2CjiPsJWiY/j2xLsJuqx3JtuI4akH
# 0MmGzlBUylhXvdNVXcjAuIEcEQKtOBR9lU4wXQpISrbOT8ux+96GzBq8TdbhoFcm
# YaOBZKlwPP7pOp5Mzx/UMhyBA93PQhiCdPfIVOCINsUY4U23p4KJ3F1HqP3H6Slw
# 3lHACnLilGETXRg5X/Fp8G8qlG5Y+M49ZEGUp2bneRLZoyHTyynHvFISpefhBCV0
# KdRZHPcuSL5OAGWnBjAlRtHvsMBrI3AAA0Tu1oGvPa/4yeeiAyu+9y3SLC98gDVb
# ySnXnkujjhIh+oaatsk/oyf5R2vcxHahajMCAwEAAaOCAY4wggGKMB8GA1UdIwQY
# MBaAFF9Y7UwxeqJhQo1SgLqzYZcZojKbMB0GA1UdDgQWBBSIYYyhKjdkgShgoZsx
# 0Iz9LALOTzAOBgNVHQ8BAf8EBAMCBsAwDAYDVR0TAQH/BAIwADAWBgNVHSUBAf8E
# DDAKBggrBgEFBQcDCDBKBgNVHSAEQzBBMDUGDCsGAQQBsjEBAgEDCDAlMCMGCCsG
# AQUFBwIBFhdodHRwczovL3NlY3RpZ28uY29tL0NQUzAIBgZngQwBBAIwSgYDVR0f
# BEMwQTA/oD2gO4Y5aHR0cDovL2NybC5zZWN0aWdvLmNvbS9TZWN0aWdvUHVibGlj
# VGltZVN0YW1waW5nQ0FSMzYuY3JsMHoGCCsGAQUFBwEBBG4wbDBFBggrBgEFBQcw
# AoY5aHR0cDovL2NydC5zZWN0aWdvLmNvbS9TZWN0aWdvUHVibGljVGltZVN0YW1w
# aW5nQ0FSMzYuY3J0MCMGCCsGAQUFBzABhhdodHRwOi8vb2NzcC5zZWN0aWdvLmNv
# bTANBgkqhkiG9w0BAQwFAAOCAYEAAoE+pIZyUSH5ZakuPVKK4eWbzEsTRJOEjbIu
# 6r7vmzXXLpJx4FyGmcqnFZoa1dzx3JrUCrdG5b//LfAxOGy9Ph9JtrYChJaVHrus
# Dh9NgYwiGDOhyyJ2zRy3+kdqhwtUlLCdNjFjakTSE+hkC9F5ty1uxOoQ2ZkfI5WM
# 4WXA3ZHcNHB4V42zi7Jk3ktEnkSdViVxM6rduXW0jmmiu71ZpBFZDh7Kdens+PQX
# PgMqvzodgQJEkxaION5XRCoBxAwWwiMm2thPDuZTzWp/gUFzi7izCmEt4pE3Kf0M
# Ot3ccgwn4Kl2FIcQaV55nkjv1gODcHcD9+ZVjYZoyKTVWb4VqMQy/j8Q3aaYd/jO
# Q66Fhk3NWbg2tYl5jhQCuIsE55Vg4N0DUbEWvXJxtxQQaVR5xzhEI+BjJKzh3TQ0
# 26JxHhr2fuJ0mV68AluFr9qshgwS5SpN5FFtaSEnAwqZv3IS+mlG50rK7W3qXbWw
# i4hmpylUfygtYLEdLQukNEX1jiOKMIIGazCCBNOgAwIBAgIRAIxBnpO/K86siAYo
# O3YZvTwwDQYJKoZIhvcNAQEMBQAwVDELMAkGA1UEBhMCR0IxGDAWBgNVBAoTD1Nl
# Y3RpZ28gTGltaXRlZDErMCkGA1UEAxMiU2VjdGlnbyBQdWJsaWMgQ29kZSBTaWdu
# aW5nIENBIFIzNjAeFw0yNDExMTQwMDAwMDBaFw0yNzExMTQyMzU5NTlaMFcxCzAJ
# BgNVBAYTAkRFMRYwFAYDVQQIDA1OaWVkZXJzYWNoc2VuMRcwFQYDVQQKDA5NYXJ0
# aW4gV2lsbGluZzEXMBUGA1UEAwwOTWFydGluIFdpbGxpbmcwggIiMA0GCSqGSIb3
# DQEBAQUAA4ICDwAwggIKAoICAQDRn27mnIzB6dsJFLMexQQNRd8aMv73DTla68G6
# Q8u+V2TY1JQ/Z4j2oCI9ATW3K3P7NAPdlE0QmtdjC0F/74jsfil/i8LwxuyT034w
# abViZKUcodmKsEFhM9am8W5kUgLuC5FIK4wNOq5TfzYdHTyJu1eR2XuSDoMp0wg4
# 5mOuFNBbYB8DVBtHxobvWq4eCs3lUxX07wR3Qr2Utb92w8eU2vKr2Ss9xIh/YvM4
# UxgBpO1I6O+W2tAB5mmynIgoCfX7mu6iD3A+AhpQ9Gv209G83y8FPrFJIWU77TTe
# hErbPjZ074xXwrlEkhnGUCk1w+KiNtZHaSn0X+vnhqJ7otBxQZQAESlhWXpDKCun
# nnVnVgwvVWtccAhxZO95eif6Vss/UhCaBZ26szlneGtFeTClI4+k3mqfWuodtXjH
# c8ohAclWp7XVywliwhCFEsAcFkpkCyivey0sqEfrwiMnRy1elH1S37XcQaav5+bt
# 4KxtIXuOVEx3vM9MHdlraW0y1on5E8i4tagdI45TH0LU080ubc2MKqq6ZXtplTu1
# wdF2Cgy3hfSSLkJscRWApvpvOO6Vtc4jTG/AO6iqN5M6Swd+g40XtsxBD/gSk9kM
# qkgJ1pD1Gp5gkHnP1veut+YgJ9xWcRDJI7vcis9qsXwtVybeOCh56rTQvC/Tf6BJ
# tiieEQIDAQABo4IBszCCAa8wHwYDVR0jBBgwFoAUDyrLIIcouOxvSK4rVKYpqhek
# zQwwHQYDVR0OBBYEFIxyZAmEHl7uAfEwbB4nzI8MCCLbMA4GA1UdDwEB/wQEAwIH
# gDAMBgNVHRMBAf8EAjAAMBMGA1UdJQQMMAoGCCsGAQUFBwMDMEoGA1UdIARDMEEw
# NQYMKwYBBAGyMQECAQMCMCUwIwYIKwYBBQUHAgEWF2h0dHBzOi8vc2VjdGlnby5j
# b20vQ1BTMAgGBmeBDAEEATBJBgNVHR8EQjBAMD6gPKA6hjhodHRwOi8vY3JsLnNl
# Y3RpZ28uY29tL1NlY3RpZ29QdWJsaWNDb2RlU2lnbmluZ0NBUjM2LmNybDB5Bggr
# BgEFBQcBAQRtMGswRAYIKwYBBQUHMAKGOGh0dHA6Ly9jcnQuc2VjdGlnby5jb20v
# U2VjdGlnb1B1YmxpY0NvZGVTaWduaW5nQ0FSMzYuY3J0MCMGCCsGAQUFBzABhhdo
# dHRwOi8vb2NzcC5zZWN0aWdvLmNvbTAoBgNVHREEITAfgR1td2lsbGluZ0BsZXRo
# YWwtZm9yZW5zaWNzLmNvbTANBgkqhkiG9w0BAQwFAAOCAYEAZ0dBMMwluWGb+MD1
# rGWaPtaXrNZnlZqOZxgbdrMLBKAQr0QGcILCVIZ4SZYaevT5yMR6jFGSAjgaFtnk
# 8ZpbtGwig/ed/C/D1Ne8SZyffdtALns/5CHxMnU8ks7ut7dsR6zFD4/bmljuoUoi
# 55W6/XU/1pr+tqRaZGJvjSKJQCN9MhFAvXSpPPqRsj27ze1+KYIBF1/L0BW0HS0d
# 9ZhGSUoEwqMDLpQf2eqJFyyyzWt21VVhLF6mgZ1dE5tCLZY7ERzx6/h5N7F0w361
# oigizMbCMdST29XOc5mB8q6Cye7OmEfM2jByRWa+cd4RycsN2p2wHRukpq48iX+t
# PVKmHwNKf+upuKPDQAeV4J7gUCtevIsOtoyiC2+amimu81o424Dl+NsAyCLz0SXv
# NAhVvtU73H61gtoPa/SWouem2S+bzp7oGvGPop/9mh4CXki6LVeDH3hDM8hZsJg/
# EToIWiDozTc2yWqwV4Ozyd4x5Ix8lckXMgWuyWcxmLK1RmKpMIIGgjCCBGqgAwIB
# AgIQNsKwvXwbOuejs902y8l1aDANBgkqhkiG9w0BAQwFADCBiDELMAkGA1UEBhMC
# VVMxEzARBgNVBAgTCk5ldyBKZXJzZXkxFDASBgNVBAcTC0plcnNleSBDaXR5MR4w
# HAYDVQQKExVUaGUgVVNFUlRSVVNUIE5ldHdvcmsxLjAsBgNVBAMTJVVTRVJUcnVz
# dCBSU0EgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwHhcNMjEwMzIyMDAwMDAwWhcN
# MzgwMTE4MjM1OTU5WjBXMQswCQYDVQQGEwJHQjEYMBYGA1UEChMPU2VjdGlnbyBM
# aW1pdGVkMS4wLAYDVQQDEyVTZWN0aWdvIFB1YmxpYyBUaW1lIFN0YW1waW5nIFJv
# b3QgUjQ2MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAiJ3YuUVnnR3d
# 6LkmgZpUVMB8SQWbzFoVD9mUEES0QUCBdxSZqdTkdizICFNeINCSJS+lV1ipnW5i
# hkQyC0cRLWXUJzodqpnMRs46npiJPHrfLBOifjfhpdXJ2aHHsPHggGsCi7uE0awq
# KggE/LkYw3sqaBia67h/3awoqNvGqiFRJ+OTWYmUCO2GAXsePHi+/JUNAax3kpqs
# tbl3vcTdOGhtKShvZIvjwulRH87rbukNyHGWX5tNK/WABKf+Gnoi4cmisS7oSimg
# HUI0Wn/4elNd40BFdSZ1EwpuddZ+Wr7+Dfo0lcHflm/FDDrOJ3rWqauUP8hsokDo
# I7D/yUVI9DAE/WK3Jl3C4LKwIpn1mNzMyptRwsXKrop06m7NUNHdlTDEMovXAIDG
# AvYynPt5lutv8lZeI5w3MOlCybAZDpK3Dy1MKo+6aEtE9vtiTMzz/o2dYfdP0KWZ
# wZIXbYsTIlg1YIetCpi5s14qiXOpRsKqFKqav9R1R5vj3NgevsAsvxsAnI8Oa5s2
# oy25qhsoBIGo/zi6GpxFj+mOdh35Xn91y72J4RGOJEoqzEIbW3q0b2iPuWLA911c
# RxgY5SJYubvjay3nSMbBPPFsyl6mY4/WYucmyS9lo3l7jk27MAe145GWxK4O3m3g
# EFEIkv7kRmefDR7Oe2T1HxAnICQvr9sCAwEAAaOCARYwggESMB8GA1UdIwQYMBaA
# FFN5v1qqK0rPVIDh2JvAnfKyA2bLMB0GA1UdDgQWBBT2d2rdP/0BE/8WoWyCAi/Q
# Cj0UJTAOBgNVHQ8BAf8EBAMCAYYwDwYDVR0TAQH/BAUwAwEB/zATBgNVHSUEDDAK
# BggrBgEFBQcDCDARBgNVHSAECjAIMAYGBFUdIAAwUAYDVR0fBEkwRzBFoEOgQYY/
# aHR0cDovL2NybC51c2VydHJ1c3QuY29tL1VTRVJUcnVzdFJTQUNlcnRpZmljYXRp
# b25BdXRob3JpdHkuY3JsMDUGCCsGAQUFBwEBBCkwJzAlBggrBgEFBQcwAYYZaHR0
# cDovL29jc3AudXNlcnRydXN0LmNvbTANBgkqhkiG9w0BAQwFAAOCAgEADr5lQe1o
# RLjlocXUEYfktzsljOt+2sgXke3Y8UPEooU5y39rAARaAdAxUeiX1ktLJ3+lgxto
# LQhn5cFb3GF2SSZRX8ptQ6IvuD3wz/LNHKpQ5nX8hjsDLRhsyeIiJsms9yAWnvdY
# OdEMq1W61KE9JlBkB20XBee6JaXx4UBErc+YuoSb1SxVf7nkNtUjPfcxuFtrQdRM
# Ri/fInV/AobE8Gw/8yBMQKKaHt5eia8ybT8Y/Ffa6HAJyz9gvEOcF1VWXG8OMeM7
# Vy7Bs6mSIkYeYtddU1ux1dQLbEGur18ut97wgGwDiGinCwKPyFO7ApcmVJOtlw9F
# VJxw/mL1TbyBns4zOgkaXFnnfzg4qbSvnrwyj1NiurMp4pmAWjR+Pb/SIduPnmFz
# bSN/G8reZCL4fvGlvPFk4Uab/JVCSmj59+/mB2Gn6G/UYOy8k60mKcmaAZsEVkhO
# Fuoj4we8CYyaR9vd9PGZKSinaZIkvVjbH/3nlLb0a7SBIkiRzfPfS9T+JesylbHa
# 1LtRV9U/7m0q7Ma2CQ/t392ioOssXW7oKLdOmMBl14suVFBmbzrt5V5cQPnwtd3U
# OTpS9oCG+ZZheiIvPgkDmA8FzPsnfXW5qHELB43ET7HHFHeRPRYrMBKjkb8/IN7P
# o0d0hQoF4TeMM+zYAJzoKQnVKOLg8pZVPT8xggYxMIIGLQIBATBpMFQxCzAJBgNV
# BAYTAkdCMRgwFgYDVQQKEw9TZWN0aWdvIExpbWl0ZWQxKzApBgNVBAMTIlNlY3Rp
# Z28gUHVibGljIENvZGUgU2lnbmluZyBDQSBSMzYCEQCMQZ6TvyvOrIgGKDt2Gb08
# MAkGBSsOAwIaBQCgeDAYBgorBgEEAYI3AgEMMQowCKACgAChAoAAMBkGCSqGSIb3
# DQEJAzEMBgorBgEEAYI3AgEEMBwGCisGAQQBgjcCAQsxDjAMBgorBgEEAYI3AgEV
# MCMGCSqGSIb3DQEJBDEWBBSMGHHTKTyKs+ahDTUsD/w/9djypzANBgkqhkiG9w0B
# AQEFAASCAgBv7TdJ19+4iZg7d6LfyzRWAWzVqJW2VagBvTay0Fiu+B/cq94Zvjva
# aR07gaeb2wl68FIXoVve4CEGEKxuzUBrX4KCI8PYj/guzR6qHoKEovX6sD7np3+R
# BLbPvvQS9gz7rTauHVoqdGNCQRfiCmXUmRBvBZeAZ4ck0px4DhVdSllMKcQaiBlw
# ayYzIfzDuh6MB+0680DK8bZLqGbOwj29ihrTRQcKkfGh1Ug4JO2LUxNNTsRNrR92
# SymDnVhXtJxKCtyX/yz4Osuub487NnijRDMdvNN4ry4xGIZLN1qkCAzuhk4NwQzZ
# PXkN+gwvVXeOuiLP833uD1cbt8IxT6xp6dmrn9mIeT6Rkj1H0XXS1caCLiz3y7nN
# nuPaZnUg1Y30czvrr9KaauswRKMZovub9YHs+gIgwzr9aAWk5yxzk83mFGYUAWBN
# wkBTkdUiacDZn4gTkHEhg6fyTb0/wrlNWB88EuqOQL5VhtFYQNYbux2532zEVDzx
# RQf91ThlwpjB69D1naf8oVGoNT+GjKwLTS/PTD0Hisu4uysb0ZmNb7flPcOtYaaX
# 9oi/rETUbnFoXgRPa1HPUzATjEYreeG/9paAu9mMLJHDaJaPGzAFDWlwtXE+DrCL
# Qp77orjcdY+rivNYv5hFduVCbuoWo2sGJ0m6B5WjAJd0/hCmBjoT4aGCAyMwggMf
# BgkqhkiG9w0BCQYxggMQMIIDDAIBATBqMFUxCzAJBgNVBAYTAkdCMRgwFgYDVQQK
# Ew9TZWN0aWdvIExpbWl0ZWQxLDAqBgNVBAMTI1NlY3RpZ28gUHVibGljIFRpbWUg
# U3RhbXBpbmcgQ0EgUjM2AhEApCk7bh7d16c0CIetek63JDANBglghkgBZQMEAgIF
# AKB5MBgGCSqGSIb3DQEJAzELBgkqhkiG9w0BBwEwHAYJKoZIhvcNAQkFMQ8XDTI1
# MDcyMzA0NTUwOVowPwYJKoZIhvcNAQkEMTIEMPHZCu9/ThkriWx/4E0sEJADtgJK
# tJP9aRheIHpbRB68SJ6xliGSs33qTt8u+Yi6kTANBgkqhkiG9w0BAQEFAASCAgAI
# 9AnPiT2sdqEtXZryl6LsW9fT/QxD7ovaSGlScX3BFiwfUET1ovrFM1sfNOIS1Kso
# 5QA1e4kli49Iyc9HlsbWeG5mI+gG4q4KTz5tEFgIaa6G1+SuInTUqY/N3vWynbUE
# KCfrvibH6Z76aagpZA+esYqs/1pHM/f+6q0B7JpRlFyqxddnaiSiQ2p653XqmFXa
# pg5Pg4XVZDV1A3L2BcOHFQfL7wlIhhr0BApx+e5z2GW/QBhXJmB4Zp3zMoh4cxut
# onNH8gZ2lcu/qOwE4iz869WjUI5GTc+IeP9tA8Iq17Nf4F1gTKiNHCGLl582GBoU
# cx4IwY72SV4QHq7Hda+5MRSQx80JgmvM4AaNSGvkXRncJ8Hl2KPXZyCjIMFuhYHD
# Z7AqiTEqgQQekY4UyaEQGbHSKGl6JvkYPxGEM3DEadvHeGIan8W6Zl3g8hVQX/k+
# pPmyXpxmHak84HIQ9Vmkx3qXdRRJDWDxQv97OymkkI7I6QiSc/vYzm1KvWI6g/T7
# 1Lk98LLwBxcsLNuqPL2WZNjmA4viQ4FSGLvNUUHmvE4z2Rbjr7wZ8vqvaHgES71Y
# p97LKZl9ggkl7T+yLG3LTEqxgb9LGHw4R/vWxrwG24dF2yDNuQWJRdqsvc2YHGgu
# 6s24ln6T9EKawecM56zzYtK/3aFq3tqUF17mCvw9ig==
# SIG # End signature block

```