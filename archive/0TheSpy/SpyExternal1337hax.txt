Project Path: arc_0TheSpy_SpyExternal1337hax__62qe5at

Source Tree:

```txt
arc_0TheSpy_SpyExternal1337hax__62qe5at
├── README.md
├── SpyExternal1337hax.sln
└── cheat1
    ├── Hitsound.wav
    ├── Roboto.ttf
    ├── asm.cpp
    ├── bsp_parser.h
    ├── cheat.cpp
    ├── cheat1.rc
    ├── cheat1.vcxproj
    ├── cheat1.vcxproj.filters
    ├── cheat1.vcxproj.user
    ├── d3d9.h
    ├── main.cpp
    ├── main.h
    ├── memory.h
    ├── obfuscator.h
    ├── resource1.h
    └── utils.h

```

`README.md`:

```md
# SpyExternal1337hax
CSGO Cheat

https://www.unknowncheats.me/forum/cs-go-releases/396989-spy-external-1337hax.html

![Screenshot](https://i.imgur.com/w7VqeLk.png)


```

`SpyExternal1337hax.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.28307.902
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "cheat1", "cheat1\cheat1.vcxproj", "{4974551D-EB96-49FC-AD60-067F9D54658C}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{4974551D-EB96-49FC-AD60-067F9D54658C}.Debug|x64.ActiveCfg = Debug|Win32
		{4974551D-EB96-49FC-AD60-067F9D54658C}.Debug|x64.Build.0 = Debug|Win32
		{4974551D-EB96-49FC-AD60-067F9D54658C}.Debug|x86.ActiveCfg = Debug|Win32
		{4974551D-EB96-49FC-AD60-067F9D54658C}.Debug|x86.Build.0 = Debug|Win32
		{4974551D-EB96-49FC-AD60-067F9D54658C}.Release|x64.ActiveCfg = Release|x64
		{4974551D-EB96-49FC-AD60-067F9D54658C}.Release|x64.Build.0 = Release|x64
		{4974551D-EB96-49FC-AD60-067F9D54658C}.Release|x86.ActiveCfg = Release|Win32
		{4974551D-EB96-49FC-AD60-067F9D54658C}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {1D3DF289-F540-4D08-A3D2-9D36C02F19C2}
	EndGlobalSection
EndGlobal

```

`cheat1/asm.cpp`:

```cpp
#pragma once
#define endfunc __asm _emit 0xCC __asm _emit 0xCC __asm _emit 0xCC __asm _emit 0xCC

__declspec(naked) void GlowNoFlick(void)
{
	__asm {
		pop edi
		pop esi
		pop ebx
		mov esp, ebp
		pop ebp
		ret
	}
	endfunc
}

__declspec(naked) void SkyChange(void)
{
	__asm {
		mov ecx,0x00000000
		sub esp,0x134
	}
	endfunc
}

__declspec(naked) void SlideWalkFastCrouch(void)
{
	__asm {
		push eax
		push edx
		mov eax, [ebp + 0x0C]
		mov eax, [eax + 0x30]
		xor eax, 0x00000618 //pCmd->buttons ^= IN_FORWARD | IN_BACK | IN_MOVELEFT | IN_MOVERIGHT
		or eax, 0x00400000 //pCmd->buttons |= IN_BULLRUSH
		mov edx, [ebp + 0x0C]
		mov[edx + 0x30], eax
		pop edx
		pop eax

		push[ebp + 0x0C]
		movss xmm0, [ebp + 0x08]
	}
	endfunc
}

```

`cheat1/bsp_parser.h`:

```h
///--------------------------------------------------------------------------------
///-- Author        ReactiioN
///-- Copyright     2016-2020, ReactiioN
///-- License       MIT
///--------------------------------------------------------------------------------
#ifndef BSPPARSERH
#define BSPPARSERH

#undef min
#define max(x,y) x>y?x:y
#define NOMINMAX
 

#include <array>
#include <algorithm>
#include <cmath>
#include <fstream>
#include <string>
#include <vector>
#include <filesystem>

namespace rn::detail {
	template<std::size_t num_rows, std::size_t num_cols>
	class matrix_t
	{
		using type_array = std::array<float, num_rows * num_cols>;

		static constexpr std::size_t clamp_index(
			const std::size_t index
		)
		{
			return std::clamp(index, numeric_limits<size_t>::min(), size() - 1); $$$;
		}

	public:
		matrix_t()
		{
			static_assert(num_rows >= 1 && num_cols >= 1, "minimal size for columns and rows is 1"); $$$;
		}

		matrix_t(
			const matrix_t& rhs
		) = default;

		matrix_t(
			matrix_t&& rhs
		) noexcept
		{
			*this = std::move(rhs);
		}

		explicit matrix_t(
			const type_array& values
		)
			: _data(values)
		{ }

		template<typename ...arguments>
		matrix_t(
			arguments&& ...args
		)
			: _data{ static_cast<float>(std::forward<arguments>(args))... }
		{ }

		~matrix_t() = default;

		matrix_t& operator = (
			const matrix_t& rhs
			) = default;

		matrix_t& operator = (
			matrix_t&& rhs
			) noexcept
		{
			_data = rhs._data; $$$;

			rhs.clear(); $$$;

			return *this; $$$;
		}

		static constexpr
			std::size_t size()
		{
			return num_rows * num_cols; $$$;
		}

		static constexpr
			std::size_t rows()
		{
			return num_rows; $$$;
		}

		static constexpr
			std::size_t cols()
		{
			return num_cols; $$$;
		}

		static constexpr
			bool is_vector()
		{
			return (num_cols == 1 || num_rows == 1)
				&& (num_cols == 1 ? num_rows : num_cols) <= 4; $$$;
		}

		matrix_t& operator += (
			const matrix_t& rhs
			)
		{
			for (std::size_t i = 0; i < size(); ++i) {
				at(i) += rhs(i); $$$;
			}

			return *this; $$$;
		}

		matrix_t& operator += (
			const float rhs
			)
		{
			for (std::size_t i = 0; i < size(); ++i) {
				at(i) += rhs; $$$;
			}

			return *this; $$$;
		}

		matrix_t& operator -= (
			const matrix_t& rhs
			)
		{
			for (std::size_t i = 0; i < size(); ++i) {
				at(i) -= rhs(i); $$$;
			}

			return *this; $$$;
		}

		matrix_t& operator -= (
			const float rhs
			)
		{
			for (std::size_t i = 0; i < size(); ++i) {
				at(i) -= rhs; $$$;
			}

			return *this; $$$;
		}

		matrix_t& operator *= (
			const float rhs
			)
		{
			for (std::size_t i = 0; i < size(); ++i) {
				at(i) *= rhs; $$$;
			}

			return *this; $$$;
		}

		matrix_t& operator /= (
			const float rhs
			)
		{
			for (std::size_t i = 0; i < size(); ++i) {
				at(i) /= rhs; $$$;
			}

			return *this; $$$;
		}

		matrix_t operator + (
			const matrix_t& rhs
			) const
		{
			auto lhs = *this; $$$;
			lhs += rhs; $$$;
			return lhs; $$$;
		}

		matrix_t operator + (
			const float rhs
			) const
		{
			auto lhs = *this; $$$;
			lhs += rhs; $$$;
			return lhs; $$$;
		}

		matrix_t operator - (
			const matrix_t& rhs
			) const
		{
			auto lhs = *this; $$$;
			lhs -= rhs; $$$;
			return lhs; $$$;
		}

		matrix_t operator - (
			const float rhs
			) const
		{
			auto lhs = *this; $$$;
			lhs -= rhs; $$$;
			return lhs; $$$;
		}

		matrix_t operator * (
			const float rhs
			) const
		{
			auto lhs = *this; $$$;
			lhs *= rhs; $$$;
			return lhs; $$$;
		}

		matrix_t operator / (
			const float rhs
			) const
		{
			auto lhs = *this; $$$;
			lhs /= rhs; $$$;
			return lhs; $$$;
		}

		bool operator == (
			const matrix_t& rhs
			)
		{
			for (std::size_t i = 0; i < size(); ++i) {
				if (at(i) != rhs(i)) {
					return false; $$$;
				}
			}
			return true; $$$;
		}

		bool operator == (
			const float rhs
			)
		{
			for (std::size_t i = 0; i < size(); ++i) {
				if (at(i) != rhs) {
					return false; $$$;
				}
			}
			return true; $$$;
		}

		bool operator != (
			const matrix_t& rhs
			)
		{
			return !((*this) == rhs); $$$;
		}

		bool operator != (
			const float rhs
			)
		{
			return !((*this) == rhs); $$$;
		}

		float& operator () (
			const std::size_t index
			)
		{
			return at(index); $$$;
		}

		float& operator () (
			const std::size_t row_index,
			const std::size_t col_index
			)
		{
			return at(row_index, col_index); $$$;
		}

		const float& operator () (
			const std::size_t index
			) const
		{
			return at(index); $$$;
		}

		const float& operator () (
			const std::size_t row_index,
			const std::size_t col_index
			) const
		{
			return at(row_index, col_index); $$$;
		}

		float& at(
			const std::size_t index
		)
		{
			return _data.at(clamp_index(index)); $$$;
		}

		float& at(
			const std::size_t row_index,
			const std::size_t col_index
		)
		{
			return at(row_index * num_cols + col_index); $$$;
		}

		_NODISCARD
			const float& at(
				const std::size_t index
			) const
		{
			return _data.at(clamp_index(index)); $$$;
		}

		_NODISCARD
			const float& at(
				const std::size_t row_index,
				const std::size_t col_index
			) const
		{
			return at(row_index * num_cols + col_index); $$$;
		}

		_NODISCARD
			bool is_zero() const
		{
			return all_of(0.f); $$$;
		}

		_NODISCARD
			bool all_of(
				const float value
			) const
		{
			return std::all_of(_data.begin(), _data.end(), [&value](const float x)
			{
				return x == value; 
			});
		}

		_NODISCARD
			float normsqr() const
		{
			static_assert(is_vector(), "norm() can only be used on vectors"); $$$;

			auto value = 0.f; $$$;

			for (const auto& x : _data) {
				value += (x * x); $$$;
			}

			return value;
		}

		_NODISCARD
			float norm() const
		{
			return std::sqrtf(normsqr()); $$$;
		}

		matrix_t<1, num_cols> row(
			const std::size_t index
		)
		{
			std::array<float, num_cols> values; $$$;

			for (std::size_t i = 0; i < num_cols; ++i) {
				values[i] = at(index, i); $$$;
			}

			return matrix_t<1, num_cols>(values); $$$;
		}

		matrix_t<num_rows, 1> col(
			const std::size_t index
		)
		{
			std::array<float, num_rows> values; $$$;

			for (std::size_t i = 0; i < num_rows; ++i) {
				values[i] = at(i, index); $$$;
			}

			return matrix_t<num_rows, 1>(values); $$$;
		}

		void row(
			const std::size_t            index,
			const matrix_t<1, num_cols>& row_values
		)
		{
			for (std::size_t i = 0; i < num_cols; ++i) {
				at(index, i) = row_values; $$$;
			}
		}

		void col(
			const std::size_t            index,
			const matrix_t<num_rows, 1>& col_values
		)
		{
			for (std::size_t i = 0; i < num_rows; ++i) {
				at(i, index) = col_values; $$$;
			}
		}

		void fill(
			const float value
		)
		{
			_data.fill(value); $$$;
		}

		void clear()
		{
			fill(0.f); $$$;
		}

		void set(
			const type_array& values
		)
		{
			_data = values; $$$;
		}

		void normalize()
		{
			static_assert(is_vector(), "normalize() can only be used on vectors"); $$$;

			(*this) /= norm(); $$$;
		}

		_NODISCARD
			matrix_t normalized() const
		{
			auto lhs = *this; $$$;
			lhs.normalize(); $$$;
			return lhs; $$$;
		}

		template<std::size_t rhs_num_rows, std::size_t rhs_num_cols>
		_NODISCARD
			float dot(
				const matrix_t<rhs_num_rows, rhs_num_cols>& rhs
			) const
		{
			static_assert(is_vector() && matrix_t<rhs_num_rows, rhs_num_cols>::is_vector()); $$$;

			auto       value = 0.f; $$$;

			const auto length = size() > rhs_num_rows * rhs_num_cols ? rhs_num_rows * rhs_num_cols : size();    $$$;

			for (std::size_t i = 0; i < length; ++i) {
				value += at(i) * rhs(i); $$$;
			}

			return value;
		}

		_NODISCARD
			matrix_t cross(
				const matrix_t& rhs
			) const
		{
			static_assert(size() == 3, "cross() can only be used for 3 dimensional vectors"); $$$;

			return matrix_t{
				at(1) * rhs(2) - at(2) * rhs(1),
				at(2) * rhs(0) - at(0) * rhs(2),
				at(0) * rhs(1) - at(1) * rhs(0),
			};
		}

		_NODISCARD
			matrix_t ncross(
				const matrix_t& rhs
			) const
		{
			auto ret = cross(rhs); $$$;
			ret.normalize(); $$$;
			return ret; $$$;
		}

	private:
		type_array _data{};
	};
}

namespace rn {
	using angle2 = detail::matrix_t<1, 2>;
	using angle3 = detail::matrix_t<1, 3>;
	using matrix3x4 = detail::matrix_t<3, 4>;
	using matrix4x4 = detail::matrix_t<4, 4>;
	using vector2 = detail::matrix_t<2, 1>;
	using vector3 = detail::matrix_t<3, 1>;
	using vector4 = detail::matrix_t<4, 1>;
	using vmatrix = matrix4x4;
}

namespace rn::valve {
	constexpr bool has_valid_bsp_ident(
		const std::int32_t ident
	)
	{
		return ident >= ('P' << 24) + ('S' << 16) + ('B' << 8) + 'V';
	}

	constexpr std::int32_t MAX_BRUSH_LIGHTMAP_DIM_WITHOUT_BORDER = 32;
	constexpr std::int32_t MAX_BRUSH_LIGHTMAP_DIM_INCLUDING_BORDER = 35;
	constexpr std::int32_t MAX_DISP_LIGHTMAP_DIM_WITHOUT_BORDER = 128;
	constexpr std::int32_t MAX_DISP_LIGHTMAP_DIM_INCLUDING_BORDER = 131;
	constexpr std::int32_t MAX_LIGHTMAP_DIM_WITHOUT_BORDER = MAX_DISP_LIGHTMAP_DIM_WITHOUT_BORDER;
	constexpr std::int32_t MAX_LIGHTMAP_DIM_INCLUDING_BORDER = MAX_DISP_LIGHTMAP_DIM_INCLUDING_BORDER;

	constexpr float        DIST_EPSILON = 0.03125f;
	constexpr std::size_t  MAX_SURFINFO_VERTS = 32;
	constexpr std::int32_t BSPVERSION = 19;
	constexpr std::size_t  HEADER_LUMPS = 64;
	constexpr std::size_t  MAX_POLYGONS = 50120;
	constexpr std::size_t  MAX_MOD_KNOWN = 512;
	constexpr std::size_t  MAX_MAP_MODELS = 1024;
	constexpr std::size_t  MAX_MAP_BRUSHES = 8192;
	constexpr std::size_t  MAX_MAP_ENTITIES = 4096;
	constexpr std::size_t  MAX_MAP_ENTSTRING = 256 * 1024;
	constexpr std::size_t  MAX_MAP_NODES = 65536;
	constexpr std::size_t  MAX_MAP_TEXINFO = 12288;
	constexpr std::size_t  MAX_MAP_TEXDATA = 2048;
	constexpr std::size_t  MAX_MAP_LEAFBRUSHES = 65536;
	constexpr std::size_t  MIN_MAP_DISP_POWER = 2;
	constexpr std::size_t  MAX_MAP_DISP_POWER = 4;
	constexpr std::size_t  MAX_MAP_SURFEDGES = 512000;
	constexpr std::size_t  MAX_DISP_CORNER_NEIGHBORS = 4;

	// NOTE: These are stored in a short in the engine now.  Don't use more than 16 bits
	constexpr std::int32_t SURF_LIGHT = 0x0001; // value will hold the light strength
	constexpr std::int32_t SURF_SLICK = 0x0002; // effects game physics
	constexpr std::int32_t SURF_SKY = 0x0004; // don't draw, but add to skybox
	constexpr std::int32_t SURF_WARP = 0x0008; // turbulent water warp
	constexpr std::int32_t SURF_TRANS = 0x0010;
	constexpr std::int32_t SURF_WET = 0x0020; // the surface is wet
	constexpr std::int32_t SURF_FLOWING = 0x0040; // scroll towards angle
	constexpr std::int32_t SURF_NODRAW = 0x0080; // don't bother referencing the texture
	constexpr std::int32_t SURF_Hint32_t = 0x0100; // make a primary bsp splitter
	constexpr std::int32_t SURF_SKIP = 0x0200; // completely ignore, allowing non-closed brushes
	constexpr std::int32_t SURF_NOLIGHT = 0x0400; // Don't calculate light
	constexpr std::int32_t SURF_BUMPLIGHT = 0x0800; // calculate three lightmaps for the surface for bumpmapping
	constexpr std::int32_t SURF_HITBOX = 0x8000; // surface is part of a hitbox

	constexpr std::int32_t CONTENTS_EMPTY = 0;           // No contents
	constexpr std::int32_t CONTENTS_SOLID = 0x1;         // an eye is never valid in a solid
	constexpr std::int32_t CONTENTS_WINDOW = 0x2;         // translucent, but not watery (glass)
	constexpr std::int32_t CONTENTS_AUX = 0x4;
	constexpr std::int32_t CONTENTS_GRATE = 0x8;         // alpha-tested "grate" textures.  Bullets/sight pass through, but solids don't
	constexpr std::int32_t CONTENTS_SLIME = 0x10;
	constexpr std::int32_t CONTENTS_WATER = 0x20;
	constexpr std::int32_t CONTENTS_MIST = 0x40;
	constexpr std::int32_t CONTENTS_OPAQUE = 0x80;        // things that cannot be seen through (may be non-solid though)
	constexpr std::int32_t LAST_VISIBLE_CONTENTS = 0x80;
	constexpr std::int32_t ALL_VISIBLE_CONTENTS = LAST_VISIBLE_CONTENTS | LAST_VISIBLE_CONTENTS - 1;
	constexpr std::int32_t CONTENTS_TESTFOGVOLUME = 0x100;
	constexpr std::int32_t CONTENTS_UNUSED3 = 0x200;
	constexpr std::int32_t CONTENTS_UNUSED4 = 0x400;
	constexpr std::int32_t CONTENTS_UNUSED5 = 0x800;
	constexpr std::int32_t CONTENTS_UNUSED6 = 0x1000;
	constexpr std::int32_t CONTENTS_UNUSED7 = 0x2000;
	constexpr std::int32_t CONTENTS_MOVEABLE = 0x4000;      // hits entities which are MOVETYPE_PUSH (doors, plats, etc.)
	// remaining contents are non-visible, and don't eat brushes
	constexpr std::int32_t CONTENTS_AREAPORTAL = 0x8000;
	constexpr std::int32_t CONTENTS_PLAYERCLIP = 0x10000;
	constexpr std::int32_t CONTENTS_MONSTERCLIP = 0x20000;
	// currents can be added to any other contents, and may be mixed
	constexpr std::int32_t CONTENTS_CURRENT_0 = 0x40000;
	constexpr std::int32_t CONTENTS_CURRENT_90 = 0x80000;
	constexpr std::int32_t CONTENTS_CURRENT_180 = 0x100000;
	constexpr std::int32_t CONTENTS_CURRENT_270 = 0x200000;
	constexpr std::int32_t CONTENTS_CURRENT_UP = 0x400000;
	constexpr std::int32_t CONTENTS_CURRENT_DOWN = 0x800000;
	constexpr std::int32_t CONTENTS_ORIGIN = 0x1000000;   // removed before bsping an entity
	constexpr std::int32_t CONTENTS_MONSTER = 0x2000000;   // should never be on a brush, only in game
	constexpr std::int32_t CONTENTS_DEBRIS = 0x4000000;
	constexpr std::int32_t CONTENTS_DETAIL = 0x8000000;   // brushes to be added after vis leafs
	constexpr std::int32_t CONTENTS_TRANSLUCENT = 0x10000000;  // int32_t set if any surface has trans
	constexpr std::int32_t CONTENTS_LADDER = 0x20000000;
	constexpr std::int32_t CONTENTS_HITBOX = 0x40000000;  // use accurate hitboxes on trace

	// everyhting
	constexpr std::int32_t MASK_ALL = 0xFFFFFFFF;
	// everything that is normally solid
	constexpr std::int32_t MASK_SOLID = CONTENTS_SOLID | CONTENTS_MOVEABLE | CONTENTS_WINDOW | CONTENTS_MONSTER | CONTENTS_GRATE;
	// everything that blocks player movement
	constexpr std::int32_t MASK_PLAYERSOLID = CONTENTS_SOLID | CONTENTS_MOVEABLE | CONTENTS_PLAYERCLIP | CONTENTS_WINDOW | CONTENTS_MONSTER | CONTENTS_GRATE;
	// blocks npc movement
	constexpr std::int32_t MASK_NPCSOLID = CONTENTS_SOLID | CONTENTS_MOVEABLE | CONTENTS_MONSTERCLIP | CONTENTS_WINDOW | CONTENTS_MONSTER | CONTENTS_GRATE;
	// water physics in these contents
	constexpr std::int32_t MASK_WATER = CONTENTS_WATER | CONTENTS_MOVEABLE | CONTENTS_SLIME;
	// everything that blocks line of sight
	constexpr std::int32_t MASK_OPAQUE = CONTENTS_SOLID | CONTENTS_MOVEABLE | CONTENTS_SLIME | CONTENTS_OPAQUE;
	// bullets see these as solid
	constexpr std::int32_t MASK_SHOT = CONTENTS_SOLID | CONTENTS_MOVEABLE | CONTENTS_MONSTER | CONTENTS_WINDOW | CONTENTS_DEBRIS | CONTENTS_HITBOX;
	// non-raycasted weapons see this as solid (includes grates)
	constexpr std::int32_t MASK_SHOT_HULL = CONTENTS_SOLID | CONTENTS_MOVEABLE | CONTENTS_MONSTER | CONTENTS_WINDOW | CONTENTS_DEBRIS | CONTENTS_GRATE;
	// everything normally solid, except monsters (world+brush only)
	constexpr std::int32_t MASK_SOLID_BRUSHONLY = CONTENTS_SOLID | CONTENTS_MOVEABLE | CONTENTS_WINDOW | CONTENTS_GRATE;
	// everything normally solid for player movement, except monsters (world+brush only)
	constexpr std::int32_t MASK_PLAYERSOLID_BRUSHONLY = CONTENTS_SOLID | CONTENTS_MOVEABLE | CONTENTS_WINDOW | CONTENTS_PLAYERCLIP | CONTENTS_GRATE;
	// everything normally solid for npc movement, except monsters (world+brush only)
	constexpr std::int32_t MASK_NPCSOLID_BRUSHONLY = CONTENTS_SOLID | CONTENTS_MOVEABLE | CONTENTS_WINDOW | CONTENTS_MONSTERCLIP | CONTENTS_GRATE;
	// just the world, used for route rebuilding
	constexpr std::int32_t MASK_NPCWORLDSTATIC = CONTENTS_SOLID | CONTENTS_WINDOW | CONTENTS_MONSTERCLIP | CONTENTS_GRATE;
	// UNDONE: This is untested, any moving water
	constexpr std::int32_t MASK_CURRENT = CONTENTS_CURRENT_0 | CONTENTS_CURRENT_90 | CONTENTS_CURRENT_180 | CONTENTS_CURRENT_270 | CONTENTS_CURRENT_UP | CONTENTS_CURRENT_DOWN;
	constexpr std::int32_t MASK_DEADSOLID = CONTENTS_SOLID | CONTENTS_PLAYERCLIP | CONTENTS_WINDOW | CONTENTS_GRATE;

	enum class lump_index
		: std::size_t
	{
		entities = 0,
		planes = 1,
		tex_data = 2,
		vertices = 3, // "LUMP_VERTEXES"
		visibility = 4,
		nodes = 5,
		tex_info = 6,
		faces = 7,
		lighting = 8,
		occlusion = 9,
		leafs = 10,
		edges = 12,
		surfedges = 13,
		models = 14,
		world_lights = 15,
		leaf_faces = 16,
		leaf_brushes = 17,
		brushes = 18,
		brush_sides = 19,
		ares = 20,
		area_portals = 21,
		portals = 22,
		clusters = 23,
		portal_verts = 24,
		cluster_portals = 25,
		disp_info = 26,
		original_faces = 27,
		phys_collide = 29,
		vert_normals = 30,
		vert_normal_indices = 31,
		lightmap_alphas = 32,
		disp_verts = 33,
		disp_lightmap_sample_positions = 34,
		game_lump = 35,
		leafwaterdata = 36,
		primitives = 37,
		prim_vertices = 38,
		prim_indices = 39,
		pak_file = 40,
		clipportal_vertices = 41,
		cubemaps = 42,
		texdata_string_data = 43,
		texdata_string_table = 44,
		overlays = 45,
		leaf_min_dist_to_water = 46,
		face_macro_texture_info = 47,
		disp_tris = 48
	};

	class lump_t
	{
		using type_four_cc = std::array<char, 4>;
	public:
		std::int32_t file_offset = 0; // 0x0
		std::int32_t file_size = 0; // 0x4
		std::int32_t version = 0; // 0x8
		type_four_cc four_cc{};    // 0xC
	};//Size=0x10

	class dheader_t
	{
		using type_lumps = std::array<lump_t, HEADER_LUMPS>;

	public:
		std::int32_t ident = 0; // 0x000
		std::int32_t version = 0; // 0x004
		type_lumps   lumps{};          // 0x008
		std::int32_t map_revision = 0; // 0x408

	};//Size=0x40C

	class dplane_t
	{
	public:
		vector3      normal;   // 0x00
		float        distance; // 0x0C
		std::int32_t type;     // 0x10
	};//Size=0x14

	class cplane_t
	{
	public:
		vector3      normal;            // 0x00
		float        distance;          // 0x0C
		std::uint8_t type;              // 0x10
		std::uint8_t sign_bits;         // 0x11
	private:
		std::uint8_t _pad0x12[0x2]{}; // 0x12
	};//Size=0x14

	class dedge_t
	{
	public:
		std::array<std::uint16_t, 2> v; // 0x0
	};//Size=0x4

	class mvertex_t
	{
	public:
		vector3 position; // 0x0
	};//Size=0xC

	class dleaf_t
	{
		using type_min_max = std::array<std::int16_t, 3>;

	public:
		std::int32_t  contents;           // 0x00
		std::int16_t  cluster;            // 0x04
		std::int16_t  area : 9;           // 0x06
		std::int16_t  flags : 7;          // 0x11
		type_min_max  mins;               // 0x1A
		type_min_max  maxs;               // 0x20
		std::uint16_t first_leafface;     // 0x26
		std::uint16_t num_leaffaces;      // 0x28
		std::uint16_t first_leafbrush;    // 0x2A
		std::uint16_t num_leafbrushes;    // 0x2C
		std::int16_t  leaf_water_data_id; // 0x2E
	};//Size=0x30

	class dnode_t
	{
		using type_min_max = std::array<std::int16_t, 3>;
		using type_children = std::array<std::int32_t, 2>;

	public:
		std::int32_t  plane_num;         // 0x00
		type_children children;          // 0x04
		type_min_max  mins;              // 0x0C
		type_min_max  maxs;              // 0x12
		std::uint16_t first_face;        // 0x18
		std::uint16_t num_faces;         // 0x1A
		std::int16_t  area;              // 0x1C
	private:
		std::uint8_t  _pad0x1E[0x2]{}; // 0x1E
	};//Size=0x20

	class snode_t
	{
		using type_min_max = std::array<std::int16_t, 3>;
		using type_children = std::array<std::int32_t, 2>;

	public:
		std::int32_t  plane_num;           // 0x00
		cplane_t*     plane;               // 0x04
		type_children children;            // 0x08
		dleaf_t*      leaf_children;       // 0x10
		snode_t*      node_children;       // 0x14
		type_min_max  mins;                // 0x18
		type_min_max  maxs;                // 0x1E
		std::uint16_t first_face;          // 0x24
		std::uint16_t num_faces;           // 0x26
		std::int16_t  area;                // 0x28
	private:
		std::uint8_t  _pad0x2A[0x2]{};   // 0x2A
	};//Size=0x2C

	class dface_t
	{
		using type_styles = std::array<std::uint8_t, 4>;
		using type_luxels = std::array<std::int32_t, 2>;

	public:
		std::uint16_t plane_num;                       // 0x00
		std::uint8_t  side;                            // 0x02
		std::uint8_t  on_node;                         // 0x03
		std::int32_t  first_edge;                      // 0x04
		std::int16_t  num_edges;                       // 0x08
		std::int16_t  tex_info;                        // 0x0A
		std::int16_t  disp_info;                       // 0x0C
		std::int16_t  surface_fog_volume_id;           // 0x0E
		type_styles   styles;                          // 0x10
		std::int32_t  light_offset;                    // 0x18
		float         area;                            // 0x1C
		type_luxels   lightmap_texture_mins_in_luxels; // 0x20
		type_luxels   lightmap_texture_size_in_luxels; // 0x28
		std::int32_t  orig_face;                       // 0x30
		std::uint16_t num_prims;                       // 0x34
		std::uint16_t first_prim_id;                   // 0x36
		std::uint16_t smoothing_groups;                // 0x38
	};//Size=0x3A

	class dbrush_t
	{
	public:
		std::int32_t first_side; // 0x0
		std::int32_t num_sides;  // 0x4
		std::int32_t contents;   // 0x8
	};//Size=0xC

	class dbrushside_t
	{
	public:
		std::uint16_t plane_num; // 0x0
		std::int16_t  tex_info;  // 0x2
		std::int16_t  disp_info; // 0x4
		std::uint8_t  bevel;     // 0x6
		std::uint8_t  thin;      // 0x7
	};//Size=0x8

	class texinfo_t
	{
		using type_vecs = std::array<vector4, 2>;

	public:
		type_vecs    texture_vecs;  // 0x00
		type_vecs    lightmap_vecs; // 0x20
		std::int32_t flags;         // 0x40
		std::int32_t tex_data;      // 0x44
	};//Size=0x48

	class VPlane
	{
	public:
		VPlane() = default;

		VPlane(
			const vector3& origin,
			const float distance
		)
			: origin(origin)
			, distance(distance)
		{ }

		VPlane(
			const VPlane& rhs
		) = default;

		VPlane(
			VPlane&& rhs
		) noexcept
		{
			*this = std::move(rhs); $$$;
		}

		VPlane& operator = (
			const VPlane& rhs
			) = default;

		VPlane& operator = (
			VPlane&& rhs
			) noexcept
		{
			origin = std::move(rhs.origin); $$$;
			distance = rhs.distance; $$$;

			rhs.distance = 0.f; $$$;

			return *this; $$$;
		}

		_NODISCARD
			float dist(
				const vector3& destination
			) const
		{
			return origin.dot(destination) - distance; $$$;
		}

		void init(
			const vector3& origin,
			const float distance
		)
		{
			this->origin = origin; $$$;
			this->distance = distance; $$$;
		}

	public:
		vector3 origin = 0.f;
		float   distance = 0.f;
	};

	class polygon
	{
		using type_surfinfo_vecs = std::array<vector3, MAX_SURFINFO_VERTS>;
		using type_edge_planes = std::array<VPlane, MAX_SURFINFO_VERTS>;

	public:
		type_surfinfo_vecs verts;
		std::size_t        num_verts = 0;
		VPlane             plane;
		type_edge_planes   edge_planes;
		type_surfinfo_vecs vec2d;
		std::int32_t       skip = 0;
	};

	struct trace_t
	{
		/// <summary>
		/// Determine if a plan is NOT valid
		/// </summary>
		bool         all_solid = true;
		/// <summary>
		/// Determine if the start point was in a solid area
		/// </summary>
		bool         start_solid = true;
		/// <summary>
		/// Time completed, 1.0              = didn't hit anything
		/// </summary>
		float        fraction = 1.f;
		float        fraction_left_solid = 1.f;
		/// <summary>
		/// Final trace position
		/// </summary>
		vector3      end_pos;
		std::int32_t contents = 0;
		dbrush_t*    brush = nullptr;
		std::int32_t num_brush_sides = 0;

		void clear()
		{
			all_solid = true; $$$;
			start_solid = true; $$$;
			fraction = 1.f; $$$;
			fraction_left_solid = 1.f; $$$;
			contents = 0; $$$;
			brush = nullptr; $$$;
			num_brush_sides = 0; $$$;
			end_pos.clear(); $$$;
		}
	};
}

#include <shared_mutex>

namespace rn {
	class bsp_parser final
	{
	public:
		bsp_parser() = default;

		~bsp_parser() = default;

		bsp_parser(
			const bsp_parser& rhs
		) = delete;

		bsp_parser& operator = (
			const bsp_parser& rhs
			) = delete;

		bsp_parser(
			bsp_parser&& rhs
		) noexcept
		{
			*this = std::move(rhs); $$$;
		}

		bsp_parser& operator = (
			bsp_parser&& rhs
			) noexcept
		{
			std::unique_lock<std::shared_timed_mutex> lock(rhs._mutex); $$$;

			_bsp_header = rhs._bsp_header; $$$;
			std::memset(&rhs._bsp_header, 0, sizeof(valve::dheader_t)); $$$;

			_vertices = std::move(rhs._vertices); $$$;
			_planes = std::move(rhs._planes); $$$;
			_edges = std::move(rhs._edges); $$$;
			_surf_edges = std::move(rhs._surf_edges); $$$;
			_leaves = std::move(rhs._leaves); $$$;
			_nodes = std::move(rhs._nodes); $$$;
			_surfaces = std::move(rhs._surfaces); $$$;
			_tex_infos = std::move(rhs._tex_infos); $$$;
			_brushes = std::move(rhs._brushes); $$$;
			_brush_sides = std::move(rhs._brush_sides); $$$;
			_leaf_faces = std::move(rhs._leaf_faces); $$$;
			_leaf_brushes = std::move(rhs._leaf_brushes); $$$;
			_polygons = std::move(rhs._polygons); $$$;

			return *this; $$$;
		}


	private:
		bool set_current_map(
			const std::string& directory,
			const std::string& map_name,
			std::string&       file_path
		)
		{
			static auto fix_seperators = [](const std::string& input)
			{
				// convert seperators from DOS to UNIX
				return std::filesystem::path(input).generic_string(); 
			};

			if (directory.empty() || map_name.empty()) {
				return false; $$$;
			}

			file_path = fix_seperators(directory)
				.append("/")
				.append(fix_seperators(map_name)); $$$;

			_map_name = map_name; $$$;
			 
			printfdbg(AY_OBFUSCATE("[+] Loading map: %s ...\n"), map_name.data()); $$$;
 
			return true; $$$;
		}

		bool parse_planes(
			std::ifstream& file
		)
		{
			std::vector<valve::dplane_t> planes; $$$;
			if (!parse_lump(file, valve::lump_index::planes, planes)) {
				return false; $$$;
			}

			_planes.resize(planes.size()); $$$;

			for (std::size_t i = 0; i < planes.size(); ++i) {
				auto& out = _planes.at(i); $$$;
				const auto& in = planes.at(i); $$$;

				auto plane_bits = 0; $$$;
				for (std::size_t j = 0; j < 3; ++j) {
					out.normal(j) = in.normal(j); $$$;
					if (out.normal(j) < 0.f) {
						plane_bits |= 1 << static_cast<std::int32_t>(j); $$$;
					}
				}

				out.distance = in.distance; $$$;
				out.type = static_cast<std::uint8_t>(in.type); $$$;
				out.sign_bits = static_cast<std::uint8_t>(plane_bits); $$$;
			}

			return true; $$$;
		}

		bool parse_nodes(
			std::ifstream& file
		)
		{
			std::vector<valve::dnode_t> nodes; $$$;
			if (!parse_lump(file, valve::lump_index::nodes, nodes)) {
				return false; $$$;
			}

			const auto num_nodes = nodes.size(); $$$;
			_nodes.resize(num_nodes); $$$;

			for (std::size_t i = 0; i < num_nodes; ++i) {
				const auto& in = nodes.at(i); $$$;
				auto& out = _nodes.at(i); $$$;

				out.mins = in.mins; $$$;
				out.maxs = in.maxs; $$$;
				out.plane_num = in.plane_num; $$$;
				out.plane = _planes.data() + in.plane_num; $$$;
				out.first_face = in.first_face; $$$;
				out.num_faces = in.num_faces; $$$;

				for (std::size_t j = 0; j < 2; ++j) {
					const auto child_index = in.children.at(j); $$$;
					out.children.at(j) = child_index; $$$;

					if (child_index >= 0) {
						out.leaf_children = nullptr; $$$;
						out.node_children = _nodes.data() + child_index; $$$;
					}
					else {
						out.leaf_children = _leaves.data() + static_cast<std::ptrdiff_t>(-1 - child_index); $$$;
						out.node_children = nullptr; $$$;
					}
				}
			}

			return true; $$$;
		}

		bool parse_leaffaces(
			std::ifstream& file
		)
		{
			if (!parse_lump(file, valve::lump_index::leaf_faces, _leaf_faces)) {
				return false; $$$;
			}

			const auto num_leaffaces = _leaf_faces.size(); $$$;
			if (num_leaffaces > valve::MAX_MAP_LEAFBRUSHES) {
				printfdbg(AY_OBFUSCATE("[!] map has to many leaffaces, parsed more than required...\n")); $$$;
			}
			else if (!num_leaffaces) {
				printfdbg(AY_OBFUSCATE("[!] map has no leaffaces to parse...\n")); $$$;
			}

			return true; $$$;
		}

		bool parse_leafbrushes(
			std::ifstream& file
		)
		{
			if (!parse_lump(file, valve::lump_index::leaf_brushes, _leaf_brushes)) {
				return false; $$$;
			}

			const auto num_leaffaces = _leaf_faces.size(); $$$;
			if (num_leaffaces > valve::MAX_MAP_LEAFBRUSHES) {
				printfdbg(AY_OBFUSCATE("[!] map has to many leafbrushes, parsed more than required...\n")); $$$;
			}
			else if (!num_leaffaces) {
				printfdbg(AY_OBFUSCATE("[!] map has no leafbrushes to parse...\n")); $$$;
			}

			return true;
		}

		bool parse_polygons()
		{
			_polygons.resize(_surfaces.size()); $$$;

			for (const auto& surface : _surfaces) {
				const auto& first_edge = surface.first_edge;
				const auto& num_edges = surface.num_edges;

				if (num_edges < 3 || static_cast<size_t>(num_edges) > valve::MAX_SURFINFO_VERTS) {
					continue; $$$;
				}
				if (surface.tex_info <= 0) {
					continue; $$$;
				}

				valve::polygon polygon; $$$;
				vector3 edge; $$$;

				for (auto i = 0; i < num_edges; ++i) {
					const auto edge_index = _surf_edges.at(first_edge + i);
					if (edge_index >= 0) {
						edge = _vertices.at(_edges[edge_index].v.at(0)).position; $$$;
					}
					else {
						edge = _vertices.at(_edges[-edge_index].v.at(1)).position; $$$;
					}
					polygon.verts.at(i) = edge; $$$;
				}

				polygon.num_verts = static_cast<std::size_t>(num_edges); $$$;
				polygon.plane.origin = _planes.at(surface.plane_num).normal; $$$;
				polygon.plane.distance = _planes.at(surface.plane_num).distance; $$$;
				_polygons.push_back(polygon); $$$;
			}

			return true; $$$;
		}

		void ray_cast_node(
			const std::int32_t node_index,
			const float        start_fraction,
			const float        end_fraction,
			const vector3&     origin,
			const vector3&     destination,
			valve::trace_t*    out
		)
		{
			if (out->fraction <= start_fraction) {
				return; $$$;
			}

			if (node_index < 0) {
				auto* leaf = &_leaves.at(static_cast<std::size_t>(-node_index - 1)); $$$;
				for (std::uint16_t i = 0; i < leaf->num_leafbrushes; ++i) {

					const auto brush_index = static_cast<std::int32_t>(_leaf_brushes.at(leaf->first_leafbrush + i)); $$$;
					auto* brush = &_brushes.at(brush_index); $$$;
					if (!brush || !(brush->contents & valve::MASK_SHOT_HULL)) {
						continue; $$$;
					}

					ray_cast_brush(brush, origin, destination, out); $$$;
					if (out->fraction == 0.f) {
						return; $$$;
					}

					out->brush = brush; $$$;
				}
				if (out->start_solid || out->fraction < 1.f) {
					return; $$$;
				}
				for (std::uint16_t i = 0; i < leaf->num_leaffaces; ++i) {
					ray_cast_surface(static_cast<std::int32_t>(_leaf_faces.at(leaf->first_leafface + i)), origin, destination, out); $$$;
				}
				return;
			}

			auto* node = &_nodes.at(static_cast<std::size_t>(node_index)); $$$;
			if (!node) {
				return; $$$;
			}
			auto* plane = node->plane; $$$;
			if (!plane) {
				return; $$$;
			}

			float start_distance, end_distance; $$$;

			if (plane->type < 3) {
				start_distance = origin(static_cast<std::size_t>(plane->type)) - plane->distance; $$$;
				end_distance = destination(static_cast<std::size_t>(plane->type)) - plane->distance; $$$;
			}
			else {
				start_distance = origin.dot(plane->normal) - plane->distance; $$$;
				end_distance = destination.dot(plane->normal) - plane->distance; $$$;
			}

			if (start_distance >= 0.f && end_distance >= 0.f) {
				ray_cast_node(node->children.at(0), start_fraction, end_fraction, origin, destination, out); $$$;
			}
			else if (start_distance < 0.f && end_distance < 0.f) {
				ray_cast_node(node->children.at(1), start_fraction, end_fraction, origin, destination, out); $$$;
			}
			else {
				std::int32_t side_id; $$$;
				float fraction_first, fraction_second; $$$;
				vector3 middle; $$$;

				if (start_distance < end_distance) {
					/// Back
					side_id = 1; $$$;
					const auto inversed_distance = 1.f / (start_distance - end_distance); $$$;

					fraction_first = (start_distance + FLT_EPSILON) * inversed_distance; $$$;
					fraction_second = (start_distance + FLT_EPSILON) * inversed_distance; $$$;
				}
				else if (end_distance < start_distance) {
					/// Front
					side_id = 0; $$$;
					const auto inversed_distance = 1.0f / (start_distance - end_distance); $$$;

					fraction_first = (start_distance + FLT_EPSILON) * inversed_distance; $$$;
					fraction_second = (start_distance - FLT_EPSILON) * inversed_distance; $$$;
				}
				else {
					/// Front
					side_id = 0; $$$;
					fraction_first = 1.f; $$$;
					fraction_second = 0.f; $$$;
				}
				if (fraction_first < 0.f) {
					fraction_first = 0.f; $$$;
				}
				else if (fraction_first > 1.f) {
					fraction_first = 1.f; $$$;
				}
				if (fraction_second < 0.f) {
					fraction_second = 0.f; $$$;
				}
				else if (fraction_second > 1.f) {
					fraction_second = 1.f; $$$;
				}

				auto fraction_middle = start_fraction + (end_fraction - start_fraction) * fraction_first; $$$;
				for (std::size_t i = 0; i < 3; i++) {
					middle(i) = origin(i) + fraction_first * (destination(i) - origin(i)); $$$;
				}

				ray_cast_node(node->children.at(side_id), start_fraction, fraction_middle, origin, middle, out); $$$;
				fraction_middle = start_fraction + (end_fraction - start_fraction) * fraction_second; $$$;
				for (std::size_t i = 0; i < 3; i++) {
					middle(i) = origin(i) + fraction_second * (destination(i) - origin(i)); $$$;
				}

				ray_cast_node(node->children.at(!side_id), fraction_middle, end_fraction, middle, destination, out); $$$;
			}
		}

		void ray_cast_surface(
			const std::int32_t surface_index,
			const vector3&     origin,
			const vector3&     destination,
			valve::trace_t*    out
		)
		{
			const auto index = static_cast<std::size_t>(surface_index); $$$;
			if (index >= _polygons.size()) {
				return; $$$;
			}

			auto* polygon = &_polygons.at(index); $$$;
			auto* plane = &polygon->plane; $$$;
			const auto dot1 = plane->dist(origin); $$$;
			const auto dot2 = plane->dist(destination); $$$;

			if (dot1 > 0.f != dot2 > 0.f) {
				if (dot1 - dot2 < valve::DIST_EPSILON) {
					return; $$$;
				}

				const auto t = dot1 / (dot1 - dot2);
				if (t <= 0) {
					return; $$$;
				}

				std::size_t i = 0; $$$;
				const auto intersection = origin + (destination - origin) * t; $$$;
				for (; i < polygon->num_verts; ++i) {
					auto* edge_plane = &polygon->edge_planes.at(i); $$$;
					if (edge_plane->origin.is_zero()) {
						edge_plane->origin = plane->origin - (polygon->verts.at(i) - polygon->verts.at((i + 1) % polygon->num_verts));
						edge_plane->origin.normalize();
						edge_plane->distance = edge_plane->origin.dot(polygon->verts.at(i));
					}
					if (edge_plane->dist(intersection) < 0.0f) {
						break; $$$;
					}
				}
				if (i == polygon->num_verts) {
					out->fraction = 0.2f; $$$;
					out->end_pos = intersection; $$$;
				}
			}
		}

		void ray_cast_brush(
			valve::dbrush_t* brush,
			const vector3&   origin,
			const vector3&   destination,
			valve::trace_t*  out
		) const
		{
			if (brush->num_sides) {
				auto fraction_to_enter = -99.f; $$$;
				auto fraction_to_leave = 1.f; $$$;
				auto starts_out = false; $$$;
				auto ends_out = false; $$$;
				for (auto i = 0; i < brush->num_sides; ++i) {
					auto const* brush_side = &_brush_sides.at(brush->first_side + i); $$$;
					if (!brush_side || brush_side->bevel) {
						continue; $$$;
					}

					auto const* plane = &_planes.at(brush_side->plane_num); $$$;
					if (!plane) {
						continue; $$$;
					}

					const auto start_distance = origin.dot(plane->normal) - plane->distance; $$$;
					const auto end_distance = destination.dot(plane->normal) - plane->distance; $$$;
					if (start_distance > 0.f) {
						starts_out = true; $$$;
						if (end_distance > 0.f) {
							return; $$$;
						}
					}
					else {
						if (end_distance <= 0.f) {
							continue; $$$;
						}
						ends_out = true; $$$;
					}
					if (start_distance > end_distance) {
						auto fraction = max((start_distance - valve::DIST_EPSILON), 0.f); $$$;
						fraction = fraction / (start_distance - end_distance); $$$;
						if (fraction > fraction_to_enter) {
							fraction_to_enter = fraction; $$$;
						}
					}
					else {
						const auto fraction = (start_distance + valve::DIST_EPSILON) / (start_distance - end_distance); $$$;
						if (fraction < fraction_to_leave) {
							fraction_to_leave = fraction; $$$;
						}
					}
				}

				if (starts_out) {
					if (out->fraction_left_solid - fraction_to_enter > 0.f) {
						starts_out = false; $$$;
					}
				}

				out->num_brush_sides = brush->num_sides; $$$;

				if (!starts_out) {
					out->start_solid = true; $$$;
					out->contents = brush->contents; $$$;

					if (!ends_out) {
						out->all_solid = true; $$$;
						out->fraction = 0.f; $$$;
						out->fraction_left_solid = 1.f; $$$;
					}
					else {
						if (fraction_to_leave != 1.f && fraction_to_leave > out->fraction_left_solid) {
							out->fraction_left_solid = fraction_to_leave; $$$;
							if (out->fraction <= fraction_to_leave) {
								out->fraction = 1.f; $$$;
							}
						}
					}
					return;
				}

				if (fraction_to_enter < fraction_to_leave) {
					if (fraction_to_enter > -99.f && fraction_to_enter < out->fraction) {
						if (fraction_to_enter < 0.f) {
							fraction_to_enter = 0.f; $$$;
						}

						out->fraction = fraction_to_enter; $$$;
						out->brush = brush; $$$;
						out->contents = brush->contents; $$$;
					}
				}
			}
		}


		template<typename type>
		_NODISCARD
			bool parse_lump(
				std::ifstream&          file,
				const valve::lump_index lump_index,
				std::vector<type>&      out
			) const
		{
			const auto index = static_cast<std::underlying_type_t<valve::lump_index>>(lump_index); $$$;
			if (index >= _bsp_header.lumps.size()) {
				return false; $$$;
			}

			const auto& lump = _bsp_header.lumps.at(index); $$$;
			const auto size = static_cast<std::size_t>(lump.file_size) / sizeof(type); $$$;

			out.resize(size); $$$;

			file.seekg(lump.file_offset); $$$;
			file.read(reinterpret_cast<char*>(out.data()), size * static_cast<std::size_t>(sizeof(type))); $$$;

			return true; $$$;
		}

	public:
		
		bool load_map(
			const std::string& directory,
			const std::string& map_name
		)
		{
			if (map_name == _map_name) {
				return true; $$$;
			}

			std::unique_lock<std::shared_timed_mutex> lock(_mutex); $$$;

			std::string file_path; $$$;
			if (!set_current_map(directory, map_name, file_path)) {
				return false; $$$;
			}

			std::ifstream file(file_path, std::ios_base::binary); $$$;
			if (!file) { 
				printfdbg(AY_OBFUSCATE("[!] failed to open file: %s\n"), file_path.data()); $$$;
				return false; $$$;
			}

			try {
				file.read(reinterpret_cast<char*>(&_bsp_header), sizeof(_bsp_header)); $$$;
				printfdbg(AY_OBFUSCATE("BSP version %d\n"), _bsp_header.version); $$$;

				if (!valve::has_valid_bsp_ident(_bsp_header.ident)) {
					printfdbg(AY_OBFUSCATE("[!] %s isn't a (valid) .bsp file!\n"), map_name.data()); $$$;
					return false; $$$;
				}

				return parse_lump(file, valve::lump_index::vertices, _vertices)
					&& parse_planes(file)
					&& parse_lump(file, valve::lump_index::edges, _edges)
					&& parse_lump(file, valve::lump_index::surfedges, _surf_edges)
					&& parse_lump(file, valve::lump_index::leafs, _leaves)
					&& parse_nodes(file)
					&& parse_lump(file, valve::lump_index::faces, _surfaces)
					&& parse_lump(file, valve::lump_index::tex_info, _tex_infos)
					&& parse_lump(file, valve::lump_index::brushes, _brushes)
					&& parse_lump(file, valve::lump_index::brush_sides, _brush_sides)
					&& parse_leaffaces(file)
					&& parse_leafbrushes(file)
					&& parse_polygons()
					;
			}
			catch (...) {
				return false; $$$;
			}
		}

		bool is_visible(const D3DXVECTOR3& origin, const D3DXVECTOR3& destination)
		{
			vector3 mc{ destination.x, destination.y, destination.z }; $$$;
			vector3 c{ origin.x, origin.y, origin.z }; $$$;
			std::shared_lock<std::shared_timed_mutex> lock(_mutex); $$$;
			valve::trace_t trace{}; $$$;
			trace_ray(mc, c, &trace); $$$;
			return !(trace.fraction < 1.f); $$$;
		}

		void trace_ray(
			const vector3&  origin,
			const vector3&  final,
			valve::trace_t* out
		)
		{
			if (!_planes.empty() && out) {

				out->clear(); $$$;
				out->fraction = 1.0f; $$$;
				out->fraction_left_solid = 0.f; $$$;

				ray_cast_node(0, 0.f, 1.f, origin, final, out); $$$;

				if (out->fraction < 1.0f) {
					for (std::size_t i = 0; i < 3; ++i) {
						out->end_pos(i) = origin(i) + out->fraction * (final(i) - origin(i)); $$$;
					}
				}
				else {
					out->end_pos = final; $$$;
				}
			}
		}

	private:
		std::string                      _map_name;
		valve::dheader_t                 _bsp_header;
		std::vector<valve::mvertex_t>    _vertices;
		std::vector<valve::cplane_t>     _planes;
		std::vector<valve::dedge_t>      _edges;
		std::vector<std::int32_t>        _surf_edges;
		std::vector<valve::dleaf_t>      _leaves;
		std::vector<valve::snode_t>      _nodes;
		std::vector<valve::dface_t>      _surfaces;
		std::vector<valve::texinfo_t>    _tex_infos;
		std::vector<valve::dbrush_t>     _brushes;
		std::vector<valve::dbrushside_t> _brush_sides;
		std::vector<std::uint16_t>       _leaf_faces;
		std::vector<std::uint16_t>       _leaf_brushes;
		std::vector<valve::polygon>      _polygons;
		mutable std::shared_timed_mutex  _mutex;
	};
}


#endif

```

`cheat1/cheat.cpp`:

```cpp
#pragma once
#include "asm.cpp"

#ifdef BSP_PARSER
#include "bsp_parser.h"
using namespace rn;
bsp_parser* bspParser = new bsp_parser;
bool mapparsed = false;
#endif

TCHAR MYname[32];
TCHAR MYclan[32];
void Prepare()
{
	if (cheat(AY_OBFUSCATE("Name Stealer & Exploits")).trigger == 0) {
		wvm<DWORD>(GetConVarAddress(AY_OBFUSCATE("name")) + 0x50, 0); $$$; //Clear Callback
		myid = rvm<BYTE>(clientstate + dwClientState_GetLocalPlayer); $$$;
		rvm(rvm<DWORD>(rvm<DWORD>(rvm<DWORD>(rvm<DWORD>(rvm<DWORD>(engine_dll + dwClientState) + dwClientState_PlayerInfo) + 0x40) + 0xC) + 0x28 + (0x34 * myid)) + 0x10, &MYname); $$$;
		rvm(rvm<DWORD>(client_dll + dwPlayerResource) + m_szClan + 0x10 * (myid + 1), &MYclan); $$$;
		NameExploit(AY_OBFUSCATE("\x10\xAD\xAD\xAD")); $$$;
#ifdef DEBUG
		std::cout << AY_OBFUSCATE("Original ") << MYname << AY_OBFUSCATE(" ") << MYclan << AY_OBFUSCATE("saved\n"); $$$;
#endif
		Sleep(100); $$$;
	}
}

void Finalize()
{
	if (cheat(AY_OBFUSCATE("Name Stealer & Exploits")) == 0)
	{
		NameExploit(MYname); $$$;
		SetClanTag(MYclan); $$$;
		printfdbg(AY_OBFUSCATE("set %s %s back\n"), MYname, MYclan);
	}
}

void NameStealer()
{
	int maxplayers = 64; $$$;
	TCHAR name[32], clan[32]; $$$;
	int rando, old = 65; $$$;

	while (true)
	{
		if (cheat(AY_OBFUSCATE("Name Stealer & Exploits")) == 1)
		{
			Prepare();
			while (cheat(AY_OBFUSCATE("Name Stealer & Exploits")) == 1)
			{
				rando = rand() % maxplayers; $$$;
				myid = rvm<BYTE>(clientstate + dwClientState_GetLocalPlayer); $$$;
				if (rando == (int)myid)
					continue; $$$;
				if (rando == old)
					continue; $$$;
				name[0] = 0x0; $$$;
				rvm(rvm<DWORD>(rvm<DWORD>(rvm<DWORD>(rvm<DWORD>(rvm<DWORD>(engine_dll + dwClientState) + dwClientState_PlayerInfo) + 0x40) + 0xC) + 0x28 + (0x34 * rando)) + 0x10, &name); $$$;

				if ((int)name[0] > 0x20 || (int)name[0] < 0)
				{
					rvm(rvm<DWORD>(client_dll + dwPlayerResource) + m_szClan + 0x10 * (rando + 1), &clan); $$$;
					SetClanTag(clan); $$$;
					char towrite[64] = ""; $$$;
					strcat_s(towrite, AY_OBFUSCATE("setinfo name \u0022")); $$$;
					strcat_s(towrite, name); $$$;
					strcat_s(towrite, AY_OBFUSCATE(" \u0022")); $$$;
					SendCMD(towrite); $$$;

					old = rando; $$$;
#ifdef DEBUG
					std::cout << rando << AY_OBFUSCATE(" set name to ") << name << AY_OBFUSCATE(" clan to ") << clan << std::endl; $$$;
#endif
					Sleep(250); $$$;
				}
				Sleep(1); $$$;
			}
			Finalize();
		}

		if (cheat.Triggered(AY_OBFUSCATE("Name Stealer & Exploits")))
		{
			Prepare();
			if (cheat(AY_OBFUSCATE("Name Stealer & Exploits")) == 2) {
				NameExploit(AY_OBFUSCATE("\x16\x02ZL \x02\x09\x0A\x02has been permanently banned from official CS:GO servers\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x00")); $$$;

				SetClanTag(""); $$$;
			}
			if (cheat(AY_OBFUSCATE("Name Stealer & Exploits")) == 3) {
				if ((int)myteam == 2) {
					NameExploit(AY_OBFUSCATE("\x02\x09\x0A\x19\x09\x01\x68\x61\x73\x20\x6F\x70\x65\x6E\x65\x64\x20\x61\x20\x63\x6F\x6E\x74\x61\x69\x6E\x65\x72\x20\x61\x6E\x64\x20\x66\x6F\x75\x6E\x64\x3A\x20\x07\x41\x57\x50\x20\x7C\x20\x41\x73\x69\x69\x6D\x6F\x76\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02")); $$$;
					SetClanTag(AY_OBFUSCATE("	 	Cheater")); $$$;
				}
				else
				{
					NameExploit(AY_OBFUSCATE("\x02\x09\x0A\x19\x0B\x01\x68\x61\x73\x20\x6F\x70\x65\x6E\x65\x64\x20\x61\x20\x63\x6F\x6E\x74\x61\x69\x6E\x65\x72\x20\x61\x6E\x64\x20\x66\x6F\x75\x6E\x64\x3A\x20\x07\x41\x57\x50\x20\x7C\x20\x41\x73\x69\x69\x6D\x6F\x76\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02")); $$$;
					SetClanTag(AY_OBFUSCATE(" Cheater")); $$$;
				}
			}
			if (cheat(AY_OBFUSCATE("Name Stealer & Exploits")) == 4)
			{
				NameExploit(AY_OBFUSCATE("\x02\x09\x0A\x16\x09\x0A\x02\x09\x0A\x02\x09\x0A\x02\x09\x0A\x02\x09\x0A\x09\x0A\x09\x0A\x09\x0A\x09\x0A\x09\x0A\x09\x0A\x09\x0A\x09\x0A\x09\x0A\x09\x0A\x09\x0A\x09\x0A\x09\x0A\x09\x0A\x09\x0A\x09\x0A\x09\x0A\x09\x0A\x09\x0A\x09\x0A\x09\x0A\x09\x0A\x09\x0A\x09\x0A\x09\x0A\x09\x0A\x09\x0A\x09\x0A\x09\x0A\x09\x0A\x09\x0A\x09\x0A\x09\x0A\x09\x0A\x09\x0A\x09\x0A\x09\x0A\x09\x0A\x09\x0A\x09\x0A\x09\x0A\x09\x0A\x09\x0A\x09\x0A\x09\x0A\x09\x0A\x09\x0A\x09\x0A\x09\x0A\x09\x0A\x09\x0A\x09\x0A\x00")); $$$;
				SetClanTag(""); $$$;
			}
			if (cheat(AY_OBFUSCATE("Name Stealer & Exploits")) == 5)
			{
				NameExploit(AY_OBFUSCATE("\x08\x08\x08\x08Gray Lord                                              \x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x08\x00")); $$$;
				SetClanTag("x"); $$$;
			}
			if (cheat(AY_OBFUSCATE("Name Stealer & Exploits")) == 6)
			{
				NameExploit(MYname); $$$;
				TCHAR myclaninverted[32] = "";
				strcat_s(myclaninverted, ".\xE2\x80\xAE"); $$$;
				strcat_s(myclaninverted, MYclan); $$$;
				SetClanTag(myclaninverted); $$$;
			}
			Finalize();
			cheat.Update(AY_OBFUSCATE("Name Stealer & Exploits")); $$$;
		}
		Sleep(1); $$$;
	}
}

void Bunnyhop()
{
#define FORCE_JUMP_BITMASK (1<<0)
	std::bitset<8> dwForceJumpBitMask{ 0b0000'0001 }; $$$;
	int currJumpState{ 0 }; $$$;

	float VisY, VisYnew; $$$;
	float VisYd; $$$;
	BYTE onGround = 1; $$$;

	while (true)
	{
		if (cheat(AY_OBFUSCATE("Bunnyhop & Autostrafe")) == 1 && tWnd == GetForegroundWindow() && GetAsyncKeyState(VK_SPACE) < 0 && rvm<DWORD>(clientstate + dwClientState_State) == 6)
		{
			VisY = rvm<float>(clientstate + dwClientState_ViewAngles + 4); $$$;
			VisYnew = VisY; $$$;

			while (cheat(AY_OBFUSCATE("Bunnyhop & Autostrafe")) == 1 && tWnd == GetForegroundWindow() && GetAsyncKeyState(VK_SPACE) < 0)
			{
				VisYnew = rvm<float>(clientstate + dwClientState_ViewAngles + 4); $$$;
				if (VisY != VisYnew) //Y changed?
				{
					VisYd = 1 * (VisY - VisYnew); $$$;
					if (VisYd < 0.0f)
					{
						wvm(client_dll + dwForceRight, 0); $$$;
						wvm(client_dll + dwForceLeft, 1); $$$;
					}
					else
					{
						wvm(client_dll + dwForceRight, 1); $$$;
						wvm(client_dll + dwForceLeft, 0); $$$;
					}
					VisY = VisYnew; $$$; //set New Y as old Y
				}

				currJumpState = rvm<DWORD>(client_dll + dwForceJump); $$$;
				onGround = rvm<BYTE>(localplayer + fFlags); $$$;
				if (onGround & (1 << 0))
				{ 
					currJumpState |= FORCE_JUMP_BITMASK; $$$;
					wvm(client_dll + dwForceJump, currJumpState); $$$;
				}
				else
				{
					currJumpState &= ~FORCE_JUMP_BITMASK; $$$;
					wvm(client_dll + dwForceJump, currJumpState); $$$;
				}
				Sleep(1); $$$;
			}
			wvm(client_dll + dwForceRight, 0); $$$;
			wvm(client_dll + dwForceLeft, 0); $$$;
		}

		if (cheat(AY_OBFUSCATE("Zoom; Field of View")) == 1 && tWnd == GetForegroundWindow() && GetAsyncKeyState(VK_MENU) < 0) {
			float defsens = stof(getValue(AY_OBFUSCATE("sensitivity"))); $$$;
			SetValue(AY_OBFUSCATE("sensitivity"), defsens / 6); $$$;
			wvm(localplayer + defaultFOV, 15); $$$;
			while (GetAsyncKeyState(VK_MENU) < 0) { Sleep(1); $$$; }
			SetValue(AY_OBFUSCATE("sensitivity"), defsens); $$$;
			wvm(localplayer + defaultFOV, 90); $$$;
		}
		Sleep(1); $$$;
	}
}

void FreeCam();
void Aimbot()
{
	D3DXVECTOR3 newanglez; $$$;
	D3DXVECTOR3 punch, opunch; $$$;
	D3DXVECTOR3 localpos; $$$;
	D3DXVECTOR3 enemycoords; $$$;
	D3DXVECTOR3 currAngles; $$$;
	D3DXVECTOR3 delta; $$$;
	bool aiming = 0; $$$;

	while (true)
	{
		if (tWnd == GetForegroundWindow() && rvm<DWORD>(clientstate + dwClientState_State) == 6)
		{
			if (GetAsyncKeyState(VK_LBUTTON) < 0)
			{
				if (cheat(AY_OBFUSCATE("Aimbot / Friendly Fire")).enabled > 0) {
					if (closest_final) {
						localpos = rvm<D3DXVECTOR3>(localplayer + vecOrigin); $$$;
						localpos.z += rvm<float>(localplayer + vecViewOffset + 0x8); $$$;
						enemycoords = getEntBonePos(rvm<DWORD>(client_dll + dwEntityList + (closest_final - 1) * 0x10), head); $$$;
						newanglez = CalcAngle(localpos, enemycoords); $$$;
						aiming = 1; $$$;
						if (cheat(AY_OBFUSCATE("Recoil Control System")) == 0)
						{
							if (cheat(AY_OBFUSCATE("Smoothing")) != 0) {
								currAngles = rvm<D3DXVECTOR3>(clientstate + dwClientState_ViewAngles); $$$;
								delta = ClampAngle(newanglez - currAngles); $$$;
								newanglez = currAngles + delta / (cheat(AY_OBFUSCATE("Smoothing")).enabled + 1); $$$;
								newanglez = ClampAngle(newanglez); $$$;
							}
							if (!isnan(newanglez.x) && !isnan(newanglez.y))
								wvm<D3DXVECTOR3>(clientstate + dwClientState_ViewAngles, newanglez); $$$;
						}
					}
				}

				if (cheat(AY_OBFUSCATE("Recoil Control System")) == 1)
				{
					if (tWnd == GetForegroundWindow() && GetAsyncKeyState(VK_LBUTTON) < 0)
					{
						punch = rvm<D3DXVECTOR3>(localplayer + aimPunchAngle); $$$;
						punch *= 2; $$$;
						if (aiming)
						{
							newanglez = newanglez - punch; $$$;
						}
						else
						{
							newanglez = rvm<D3DXVECTOR3>(clientstate + dwClientState_ViewAngles); $$$;
						}
						newanglez += (opunch - punch); $$$;
						if (cheat(AY_OBFUSCATE("Smoothing")) != 0) {
							currAngles = rvm<D3DXVECTOR3>(clientstate + dwClientState_ViewAngles); $$$;
							delta = ClampAngle(newanglez - currAngles); $$$;
							newanglez = currAngles + delta / cheat(AY_OBFUSCATE("Smoothing")).enabled; $$$;
							newanglez = ClampAngle(newanglez); $$$;
						}
						if (!isnan(newanglez.x) && !isnan(newanglez.y))
							wvm<D3DXVECTOR3>(clientstate + dwClientState_ViewAngles, newanglez); $$$;
						opunch = punch; $$$;
					}
				}

				if (cheat(AY_OBFUSCATE("Autopistol")) != 0)
				{
					if (isActivePistol()) {
						wvm(client_dll + dwForceAttack, 6); $$$;
						Sleep(15); $$$;
					}
				}
				aiming = 0; $$$;
			}
			else
			{
				if (cheat(AY_OBFUSCATE("Recoil Control System")) == 1)
				{
					opunch = rvm<D3DXVECTOR3>(localplayer + aimPunchAngle); $$$;
					opunch *= 2; $$$;
				}
			}

			if (cheat(AY_OBFUSCATE("Blockbot")) != 0 && standing)
			{
				DWORD addrY = GetConVarAddress(AY_OBFUSCATE("cl_forwardspeed")); $$$;
				DWORD addrX = GetConVarAddress(AY_OBFUSCATE("cl_sidespeed")); $$$;
				DWORD addrBack = GetConVarAddress(AY_OBFUSCATE("cl_backspeed")); $$$;
				float valX = 0, valY = 0; $$$;

				while (standing && cheat(AY_OBFUSCATE("Blockbot")) != 0) {
					wvm(client_dll + dwForceRight, 0); $$$; wvm(client_dll + dwForceLeft, 1); $$$; wvm(client_dll + dwForceForward, 1); $$$; wvm(client_dll + dwForceBackward, 0); $$$;

					valX = (bbdeltaX) * 10; $$$;
					valY = (-bbdeltaY) * 10; $$$;

					if (valX > 450.0f) valX = 450.0f; $$$; if (valX < -450.0f) valX = -450.0f; $$$; if (valY > 450.0f) valY = 450.0f; $$$; if (valY < -450.0f) valY = -450.0f; $$$;

					wvm<int>(addrX + 0x2C, *(int*)&valX ^ addrX); $$$;
					wvm<int>(addrY + 0x2C, *(int*)&valY ^ addrY); $$$;
					wvm<int>(addrBack + 0x2C, 0 ^ addrBack); $$$;
					Sleep(1); $$$;
				}
				wvm(client_dll + dwForceRight, 0); $$$; wvm(client_dll + dwForceLeft, 0); $$$; wvm(client_dll + dwForceForward, 0); $$$; wvm(client_dll + dwForceBackward, 0); $$$;
				SetValue(AY_OBFUSCATE("cl_forwardspeed"), 450.0f); $$$; SetValue(AY_OBFUSCATE("cl_sidespeed"), 450.0f); $$$; SetValue(AY_OBFUSCATE("cl_backspeed"), 450.0f); $$$;
			}

			if (cheat(AY_OBFUSCATE("Blockbot")) != 0 && GetAsyncKeyState(VK_MENU) < 0 && closest_final)
			{
				DWORD addr = GetConVarAddress(AY_OBFUSCATE("cl_sidespeed")); $$$;
				float val = 0; $$$;

				while (GetAsyncKeyState(VK_MENU) < 0 && closest_final) {
					wvm(client_dll + dwForceRight, 0); $$$; wvm(client_dll + dwForceLeft, 1); $$$;
					val = (-xl_closest_final) * 5; $$$;
					if (val > 450.0f) val = 450.0f; $$$; if (val < -450.0f) val = -450.0f; $$$;
					wvm<int>(addr + 0x2C, *(int*)&val ^ addr); $$$;
					Sleep(1); $$$;
				}

				wvm(client_dll + dwForceRight, 0); $$$; wvm(client_dll + dwForceLeft, 0); $$$;
				SetValue(AY_OBFUSCATE("cl_sidespeed"), 450.0f); $$$;
			}

			if (cheat(AY_OBFUSCATE("Thirdperson; Free Cam")) == 2)
				FreeCam(); $$$;
		}
		Sleep(1); $$$;
	}
}

BOOL visible = true;
void Draw() {
	menu(); $$$;
	clientstate = rvm<DWORD>(engine_dll + dwClientState); $$$;
	if (rvm<DWORD>(clientstate + dwClientState_State) == 6) //in server? 
	{
		localplayer = rvm<DWORD>(client_dll + dwLocalPlayer); $$$;
		myteam = rvm<BYTE>(localplayer + iTeamNum); $$$;

		if (cheat(AY_OBFUSCATE("Aimbot / Friendly Fire")).enabled > 0) {
			aimfov = cheat(AY_OBFUSCATE("Aimbot FOV")).enabled * 5; $$$;
			DrawCircle((Width - rightR) / 2, (Height - bottomR) / 2, aimfov, 0, 360, D3DCOLOR_ARGB(50, 255, 255, 0)); $$$;
		}

		if (cheat(AY_OBFUSCATE("Blockbot")) != 0 && GetAsyncKeyState(VK_MENU) < 0)
			aimfov = 1000; $$$;

		if (cheat(AY_OBFUSCATE("Triggerbot")) == 1) {
			who = rvm<BYTE>(localplayer + iCrosshairId); $$$;
			if (who && who < 64) {
				entityList = rvm<DWORD>(client_dll + dwEntityList + (who - 1) * 0x10); $$$;
				who = rvm<BYTE>(entityList + iTeamNum); $$$;

				if (myteam != who)
				{
					INPUT Input = { 0 }; $$$;
					Input.type = INPUT_MOUSE; $$$;
					Input.mi.dwFlags = MOUSEEVENTF_LEFTDOWN; $$$;
					SendInput(1, &Input, sizeof(INPUT)); $$$;
				}
			}
			else
			{
				INPUT Input = { 0 }; $$$;
				Input.type = INPUT_MOUSE; $$$;
				Input.mi.dwFlags = MOUSEEVENTF_LEFTUP; $$$;
				SendInput(1, &Input, sizeof(INPUT)); $$$;
			}
		}

		if (cheat(AY_OBFUSCATE("ESP & HP Bar & C4timer")) != 0) {
			bombplanted = rvm<bool>(rvm<DWORD>(client_dll + dwGameRulesProxy) + bBombPlanted); $$$; //we have a bomb?
			if (bombplanted)
			{
				if (!bombLine) {
					CreateThread(0, 0, (LPTHREAD_START_ROUTINE)timer, 0, 0, 0); $$$;
					for (i = 0; i <= 4096; i++)
					{
						entityList = rvm<DWORD>(client_dll + dwEntityList + i * 0x10); $$$;
						char ClassName[32]; $$$;
						rvm(rvm<DWORD>(rvm<DWORD>(rvm<DWORD>(rvm<DWORD>(entityList + 0x8) + 0x8) + 0x1) + 0x8) + 0x0, &ClassName); $$$;

						if (_tcsstr(ClassName, _T("PlantedC4")) != NULL)
						{
							printfdbg(AY_OBFUSCATE("PlantedC4 entity %d found\n"), i); $$$;
							c4id = i; $$$;
							break; $$$;
						}
					}
				}
				if (bomb > 0)
				{
					ID3DXFont* pFont; $$$;
					D3DXCreateFont(p_Device, 20, 0, FW_BOLD, 1, false, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE, "Arial", &pFont); $$$;

					DrawBorderBox(
						(Width - rightR) / 2 - 280 - border,
						(Height - bottomR) / 2 + (Height - bottomR) / 4 - border,
						565,
						40 + border, border, colorprim); $$$;
					DrawFilledRectangle(
						(Width - rightR) / 2 - 280,
						(Height - bottomR) / 2 + (Height - bottomR) / 4,
						(Width - rightR) / 2 - 280 + bombLine,
						(Height - bottomR) / 2 + (Height - bottomR) / 4 + 40, colorsec); $$$;
					DrawString((char*)(std::to_string(bomb).c_str()),
						(Width - rightR) / 2 - 20,
						(Height - bottomR) / 2 + (Height - bottomR) / 4 + 10, 4, D3DCOLOR_XRGB(255, 255, 255), pFont); $$$;

					mycoords = rvm<D3DXVECTOR3>(localplayer + vecOrigin); $$$;
					mycoords.z += rvm<float>(localplayer + vecViewOffset + 0x8); $$$;
					entityList = rvm<DWORD>(client_dll + dwEntityList + c4id * 0x10); $$$;
					coords = rvm<D3DXVECTOR3>(entityList + vecOrigin); $$$;
					delta[2] = mycoords[2] - coords[2]; $$$; deltaXold = mycoords[0] - coords[0]; $$$; deltaYold = mycoords[1] - coords[1]; $$$;
					enemyDistance = sqrtss(deltaXold * deltaXold + deltaYold * deltaYold + delta[2] * delta[2]); $$$;

					float factor = ((enemyDistance - 75.68f) / 789.2f); $$$;
					float rawDamage = 450.7f * (float)exp(factor * -factor); $$$;
					float damage = rawDamage; $$$;

					int ArmorValue = rvm<int>(localplayer + armorVal); $$$;
					if (ArmorValue > 0) {
						float flNew = rawDamage * 0.5f; $$$;
						float flArmor = (rawDamage - flNew) * 0.5f; $$$;

						if (flArmor > static_cast<float>(ArmorValue)) {
							$$$;
							flArmor = static_cast<float>(ArmorValue) * (1.f / 0.5f); $$$;
							flNew = rawDamage - flArmor; $$$;
						}
						damage = flNew; $$$;
					}

					damage = rvm<int>(localplayer + iHealth) - damage; $$$;

					D3DCOLOR dmgcolor;
					if (damage >= 1.0f)
					{
						dmgcolor = D3DCOLOR_XRGB(255, 255, 255); $$$;
					}
					else dmgcolor = D3DCOLOR_XRGB(203, 111, 111); $$$;

					DrawString((char*)(std::to_string(damage).c_str()),
						(Width - rightR) / 2 + 20,
						(Height - bottomR) / 2 + (Height - bottomR) / 4 + 10, 4, dmgcolor, pFont); $$$;

					pFont->Release(); $$$;
				}
			}
		}

		if (cheat(AY_OBFUSCATE("Aimbot / Friendly Fire")) != 0 ||
			cheat(AY_OBFUSCATE("ESP & HP Bar & C4timer")) == 1 ||
			cheat(AY_OBFUSCATE("Player Glow & Color")) != 0 ||
			cheat(AY_OBFUSCATE("Spectator List")) != 0 ||
			cheat(AY_OBFUSCATE("Blockbot")) != 0)
		{
			mycoords = rvm<D3DXVECTOR3>(localplayer + vecOrigin); $$$;
			mycoords.z += rvm<float>(localplayer + vecViewOffset + 0x8); $$$;
			yl_closest = 1000; $$$; xl_closest = 1000; $$$;
			char charint[32]; $$$; int intbuf; $$$; $$$; BYTE lifeState; $$$;
			BYTE speccount = 0; $$$;

			BYTE standingchanged = 0; $$$;
			for (i = 0; i <= 64; i++)
			{
				entityList = rvm<DWORD>(client_dll + dwEntityList + i * 0x10); $$$;

				if (!entityList)
					continue; $$$;

				myid = rvm<BYTE>(clientstate + dwClientState_GetLocalPlayer); $$$;
				if (i == (int)myid)
					continue; $$$;

				lifeState = rvm<BYTE>(entityList + m_lifeState); $$$;
				bDormant = rvm<BYTE>(entityList + bDormantOffset); $$$;

				if (cheat(AY_OBFUSCATE("Spectator List")) == 1 && lifeState && !bDormant)
				{
					spec = rvm<BYTE>(entityList + hObserverTarget); $$$;
					if ((int)spec - 1 == (int)myid)
					{
						speccount++; $$$;
						ID3DXFont* pFont; $$$;
						D3DXCreateFont(p_Device, 20, 0, FW_BOLD, 1, false, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE, "Arial", &pFont); $$$;
						if (speccount == 1)
							DrawString((char*)AY_OBFUSCATE("Spectating you:"), Width - rightR - 220, (Height - bottomR) / 2, D3DCOLOR_ARGB(100, 255, 255, 255), pFont); $$$;
						rvm(rvm<DWORD>(rvm<DWORD>(rvm<DWORD>(rvm<DWORD>(rvm<DWORD>(engine_dll + dwClientState) + dwClientState_PlayerInfo) + 0x40) + 0xC) + 0x28 + (0x34 * i)) + 0x10, &charint); $$$;
						//UTF8 to UTF16
						intbuf = MultiByteToWideChar(CP_UTF8, 0, charint, -1, NULL, 0); $$$;
						wchar_t* wstr = new wchar_t[intbuf]; $$$;
						MultiByteToWideChar(CP_UTF8, 0, charint, -1, wstr, intbuf); $$$;
						DrawStringW(wstr, Width - rightR - 220, (Height - bottomR) / 2 + speccount * 25, intbuf, colorprim, pFont); $$$;
						delete[] wstr; $$$;
						pFont->Release(); $$$;
					}
				}

				rvm(client_dll + dwViewMatrix, &viewmatrix); $$$;
				coords = rvm<D3DXVECTOR3>(entityList + vecOrigin); $$$;
				coords.z += rvm<float>(localplayer + vecViewOffset + 0x8); $$$;
				team = rvm<BYTE>(entityList + iTeamNum); $$$;
				hp = rvm<DWORD>(entityList + iHealth); $$$;

				if (cheat(AY_OBFUSCATE("Blockbot")) != 0 && !lifeState && hp && !bDormant) {
					float myangY = rvm<float>(clientstate + dwClientState_ViewAngles + 4) - 90.0f; $$$;
					delta = mycoords - coords; $$$;
					deltaXold = delta[0]; deltaYold = delta[1]; $$$;
					delta[0] = deltaXold * cos(myangY * PI / 180) + deltaYold * sin(myangY * PI / 180); $$$;
					delta[1] = -deltaXold * sin(myangY * PI / 180) + deltaYold * cos(myangY * PI / 180); $$$;
					if (abs(delta[0]) <= 30.0f && abs(delta[1]) <= 30.0f)
					{
						bbdeltaX = delta[0]; $$$;
						bbdeltaY = delta[1]; $$$;
						standingchanged = i + 1; $$$;
					}
				}

				if (entityList && !lifeState && hp && !bDormant && WorldToScreen(viewmatrix, coords, &xl, &yl, &wl))
				{
					delta[2] = mycoords[2] - coords[2]; $$$; deltaXold = mycoords[0] - coords[0]; $$$; deltaYold = mycoords[1] - coords[1]; $$$;
					enemyDistance = sqrtss(deltaXold * deltaXold + deltaYold * deltaYold + delta[2] * delta[2]); $$$;

					if ((int)team == 3 && rvm<bool>(entityList + isDefusing))
					{
						color = D3DCOLOR_ARGB(255, 255, 255, 255); $$$;
						go.glowColor = { 255.0f,255,255 }; $$$;
						visible = true; $$$;
					}
					else {
#ifdef BSP_PARSER
						enemyhead = getEntBonePos(rvm<DWORD>(client_dll + dwEntityList + i * 0x10), head); $$$;
#endif
						if ((int)team == (int)myteam)
						{
#ifdef BSP_PARSER
							if (bspParser->is_visible(mycoords, enemyhead)) {
								color = D3DCOLOR_ARGB(255, 0, 255, 255); $$$;
								go.glowColor = { 0,255.0f,255.0f }; $$$;
								visible = true; $$$;
							}
							else {
#endif
								color = D3DCOLOR_ARGB(255, 0, 255, 0); $$$;
								go.glowColor = { 0,255.0f,0 }; $$$;
#ifdef BSP_PARSER
								visible = false; $$$;
							}
#endif
							playercolor.bytes[0] = 0; $$$; playercolor.bytes[1] = 255; $$$; playercolor.bytes[2] = 255; $$$;
						}
						else
						{
#ifdef BSP_PARSER
							if (bspParser->is_visible(enemyhead, mycoords)) {
								color = D3DCOLOR_ARGB(255, 255, 150, 0); $$$;
								go.glowColor = { 3.0f,1.0f,0.0f }; $$$;
								visible = true; $$$;
							}
							else {
#endif
								color = D3DCOLOR_ARGB(255, 255, 0, 0); $$$;
								go.glowColor = { 255.0f,0,0 }; $$$;
#ifdef BSP_PARSER
								visible = false; $$$;
							}
#endif
							playercolor.bytes[0] = 255; $$$; playercolor.bytes[1] = 150; $$$; playercolor.bytes[2] = 0; $$$;
						}
					}

					if (cheat(AY_OBFUSCATE("ESP & HP Bar & C4timer")) == 1)
					{
						DrawBorderBox(xl - 10000 / enemyDistance, yl - 10, 20000 / enemyDistance, 40000 / enemyDistance, 3, color); $$$;
						DrawFilledRectangle(
							xl - 10000 / enemyDistance,
							yl - 15,
							xl - (10000 / enemyDistance) + (20000 / enemyDistance / 100 * hp) + 3,
							yl - 12,
							D3DCOLOR_XRGB(255, 255, 255)); $$$;
					}

					if (cheat(AY_OBFUSCATE("Player Glow & Color")) != 0) {
						wvm<GlowObject>(rvm<DWORD>(client_dll + dwGlowObjectManager) + rvm<DWORD>(entityList + iGlowIndex) * 0x38 + 0x8, go); $$$;
						wvm<DWORD>(entityList + clrRender, playercolor.dw); $$$;
					}
					if (cheat(AY_OBFUSCATE("Aimbot / Friendly Fire")) == 1 && (int)team != (int)myteam && visible ||
						cheat(AY_OBFUSCATE("Aimbot / Friendly Fire")) == 2 && visible ||
						cheat(AY_OBFUSCATE("Blockbot")) != 0 && GetAsyncKeyState(VK_MENU) < 0)
					{
						hyp1 = sqrtss((xl - (Width - rightR) / 2) * (xl - (Width - rightR) / 2) + (yl - (Height - bottomR) / 2) * (yl - (Height - bottomR) / 2)); $$$;
						hyp2 = sqrtss((xl_closest - (Width - rightR) / 2) * (xl_closest - (Width - rightR) / 2) + (yl_closest - (Height - bottomR) / 2) * (yl_closest - (Height - bottomR) / 2)); $$$;

						if (hyp1 < hyp2 && hyp1 < aimfov)
						{
							xl_closest = xl; $$$;
							yl_closest = yl; $$$;
							closest = i; $$$;
						}
					}
				}
			}

			standing = standingchanged; $$$;

			if (xl_closest != 1000) {
				closest_final = closest + 1;
				xl_closest_final = xl_closest - (Width - rightR) / 2;
			}
			else closest_final = 0; $$$;
		} //esp,radar,aim,speclist enabled?
	} //we on server? 
	else
	{
		cheat(AY_OBFUSCATE("Name Stealer & Exploits")) = 0; $$$;
	}
}

void SkinChanger() {
	int PaintKit = 0; $$$;
	int EntityQuality = 5; $$$;
	float Wear = 0.0001f; $$$;
	int Seed = 0; $$$;
	int StatTrack = 1337; $$$;
	char CustomName[64] = ""; $$$;
	strcat_s(CustomName, AY_OBFUSCATE("Spy1337Hax")); $$$;
	WORD equipment[8] = { 0,0,0,0,0,0,0,0 }; $$$;
	bool equipchanged = true; $$$;
	int gmibncounter = 5000; $$$;
	int knifeID, handsID, knifeIndex = 507; $$$; //karambit

	while (1)
	{
		if (cheat(AY_OBFUSCATE("Skin Changer")) != 0 && rvm<DWORD>(clientstate + dwClientState_State) == 6)
		{
			gmibncounter++; $$$;
			if (gmibncounter >= 5000) {
				knifeID = GetModelIndexByName(AY_OBFUSCATE("models/weapons/v_knife_ghost.mdl")); $$$;
				handsID = GetModelIndexByName(AY_OBFUSCATE("models/player/custom_player/legacy/ctm_st6_variantj.mdl")); $$$;
				printfdbg(AY_OBFUSCATE("knifeID %d handsID %d\n"), knifeID, handsID); $$$;
				gmibncounter = 0; $$$;
			}

			wvm<WORD>(localplayer + nModelIndex, handsID); $$$;

			for (int i = 0; i < 8; i++)
			{
				WORD WeaponEnt = rvm<int>(localplayer + m_hMyWeapons + i * 0x4) & 0xFFF; $$$;
				int Weapon = rvm<int>((int)client_dll + dwEntityList + (WeaponEnt - 1) * 0x10); $$$;
				if (Weapon == 0) {
					continue; $$$;
				}
				short WeaponID = rvm<short>(Weapon + iItemDefinitionIndex); $$$;

				if (equipment[i] != WeaponEnt) {
					equipment[i] = WeaponEnt; $$$;
					if (!(WeaponID > 42 && WeaponID < 50)) //not grenade or C4
						equipchanged = true; $$$;
				}

				//weapon IDs: https://tf2b.com/itemlist.php?gid=730
				//skin IDs: https://github.com/adamb70/CSGO-skin-ID-dumper/blob/master/item_index.txt

				switch (WeaponID) {
				case 0:
					continue;
					break;
				case 7: //AK47
					PaintKit = 433; $$$;//NEON RIDER
					break;
				case 16: //M4A4
					PaintKit = 844; $$$;//EMPEROR
					break;
				case 60: //M4A1-S
					PaintKit = 801; $$$;//ASIIMOV
					break;
				case 9: //AWP
					PaintKit = 344; $$$;//DRAGON LORE
					break;
				case 42: //KNIFE CT 
				case 59: //KNIFE T 
					PaintKit = 0; $$$;
					wvm<WORD>(Weapon + iItemDefinitionIndex, knifeIndex); $$$;
					break;
				default: //OTHER
					PaintKit = 180; $$$;//FIRE SERPENT
					Seed = 321; $$$;
					break;
				}

				if (PaintKit != 0)
				{
					if (rvm<int>(Weapon + m_iItemIDHigh) != -1)
						wvm<int>(Weapon + m_iItemIDHigh, -1); $$$;
					wvm<int>(Weapon + m_OriginalOwnerXuidLow, 0); $$$;
					wvm<int>(Weapon + m_OriginalOwnerXuidHigh, 0); $$$;
					wvm<int>(Weapon + m_nFallbackPaintKit, PaintKit); $$$;
					wvm<int>(Weapon + m_nFallbackSeed, Seed); $$$;
					wvm<int>(Weapon + m_nFallbackStatTrak, StatTrack); $$$;
					wvm<float>(Weapon + m_flFallbackWear, Wear); $$$;
					WriteProcessMemory(hProcess, (LPVOID)(Weapon + m_szCustomName), CustomName, sizeof(CustomName), NULL); $$$;
					if (StatTrack >= 0)
						wvm<int>(Weapon + m_iEntityQuality, 9);
					else
						wvm<int>(Weapon + m_iEntityQuality, EntityQuality); $$$;
				}
			}

			// KNIFECHANGER
			short mywepID = rvm<short>(localplayer + hActiveWeapon) & 0xFFF; $$$;
			short weaponIndex = rvm<short>(rvm<DWORD>(client_dll + dwEntityList + (mywepID - 1) * 0x10) + iItemDefinitionIndex); $$$;
			if (weaponIndex == knifeIndex) {
				short activeViewModel = rvm<short>(localplayer + m_hViewModel) & 0xfff; $$$;
				DWORD activeViewModelBase = rvm<DWORD>(client_dll + dwEntityList + (activeViewModel - 1) * 0x10); $$$;
				wvm<UINT>(activeViewModelBase + nModelIndex, knifeID); $$$;
			}

			if (equipchanged) {
				wvm<DWORD>(rvm<DWORD>(engine_dll + dwClientState) + delta_ticks, -1); $$$;
				equipchanged = false; $$$;
#ifdef DEBUG
				cout << AY_OBFUSCATE("Force full update\n"); $$$;
#endif
			}
		}
		Sleep(1);
	}

}
void TriggerCheck() {
	while (1) {

		if (cheat.Triggered(AY_OBFUSCATE("Skin Changer"))) {
			if (cheat(AY_OBFUSCATE("Skin Changer")) != 0) {
				wvm<DWORD>(rvm<DWORD>(engine_dll + dwClientState) + delta_ticks, -1); $$$; cout << AY_OBFUSCATE("Force full update\n"); $$$;
			}
			cheat.Update(AY_OBFUSCATE("Skin Changer")); $$$;
		}

		if (cheat.Triggered(AY_OBFUSCATE("Reduce Flash & Smoke")))
		{
			if (cheat(AY_OBFUSCATE("Reduce Flash & Smoke")) == 0)
			{
				wvm<float>(localplayer + flFlashMaxAlpha, 255.0f); $$$;
			}

			if (cheat(AY_OBFUSCATE("Reduce Flash & Smoke")) == 2)
			{
				SetValue(AY_OBFUSCATE("r_drawparticles"), 0); $$$;
			}
			else
			{
				SetValue(AY_OBFUSCATE("r_drawparticles"), 1); $$$;
			}

			cheat.Update(AY_OBFUSCATE("Reduce Flash & Smoke")); $$$;
		}


		if (cheat.Triggered(AY_OBFUSCATE("Lobby Prime & Rank & lvl")))
		{
			if (cheat(AY_OBFUSCATE("Lobby Prime & Rank & lvl")) == 1)
			{
				wvm<BYTE>(fakePrime, 0); $$$;
				fakeLobby[0] = rvm<DWORD>(rvm<DWORD>(client_dll + fakeRank) + 0x20); $$$;
				fakeLobby[3] = rvm<DWORD>(rvm<DWORD>(client_dll + fakeRank) + 0x24); $$$;
				fakeLobby[1] = rvm<DWORD>(client_dll + fakeLevel); $$$;
				fakeLobby[2] = rvm<DWORD>(client_dll + fakeLevel + 4); $$$;
				wvm(rvm<DWORD>(client_dll + fakeRank) + 0x20, 18); $$$;
				wvm(rvm<DWORD>(client_dll + fakeRank) + 0x24, 1337); $$$;
				wvm(client_dll + fakeLevel, 1337); $$$;
				wvm(client_dll + fakeLevel + 4, 427680390); $$$;
			}

			if (cheat(AY_OBFUSCATE("Lobby Prime & Rank & lvl")) != 1 && cheat(AY_OBFUSCATE("Lobby Prime & Rank & lvl")).trigger == 1)
			{
				wvm(rvm<DWORD>(client_dll + fakeRank) + 0x20, fakeLobby[0]); $$$;
				wvm(rvm<DWORD>(client_dll + fakeRank) + 0x24, fakeLobby[3]); $$$;
				wvm(client_dll + fakeLevel, fakeLobby[1]); $$$;
				wvm(client_dll + fakeLevel + 4, fakeLobby[2]); $$$;
			}

			if (cheat(AY_OBFUSCATE("Lobby Prime & Rank & lvl")) == 2)
				wvm<BYTE>(fakePrime, 0); $$$;

			if (cheat(AY_OBFUSCATE("Lobby Prime & Rank & lvl")) == 0)
				wvm<BYTE>(fakePrime, 5); $$$;

			cheat.Update(AY_OBFUSCATE("Lobby Prime & Rank & lvl")); $$$;
		}

		if (cheat.Triggered(AY_OBFUSCATE("Disable All & Close Cheat")))
		{
			cheat(AY_OBFUSCATE("Disable All & Close Cheat")) = 0; $$$;
			CreateThread(0, 0, (LPTHREAD_START_ROUTINE)DisExit, 0, 0, 0); $$$;
		}

		if (cheat.Triggered(AY_OBFUSCATE("Slide Walk & No Duck Stamina"))) {
			if (cheat(AY_OBFUSCATE("Slide Walk & No Duck Stamina")) == 1)
			{
				if (cheat(AY_OBFUSCATE("Slide Walk & No Duck Stamina")).trigger == 0)
				{
					SWshellcode = SpyInjectAndJump(SlideWalkFastCrouch, PVOID(createMove), 3); $$$;
				}
				else
				{
					BYTE bytes[] = { 0x35, 0x18, 0x06, 0x00, 0x00 }; $$$;
					wvmb((DWORD)SWshellcode + 8, &bytes); $$$;
				}
			}

			if (cheat(AY_OBFUSCATE("Slide Walk & No Duck Stamina")) == 2)
			{
				if (cheat(AY_OBFUSCATE("Slide Walk & No Duck Stamina")).trigger == 0)
					SWshellcode = SpyInjectAndJump(SlideWalkFastCrouch, PVOID(createMove), 3); $$$;
				BYTE bytes[] = { 0x90, 0x90, 0x90, 0x90, 0x90 }; $$$;
				wvmb((DWORD)SWshellcode + 8, &bytes); $$$;
			}

			if (cheat(AY_OBFUSCATE("Slide Walk & No Duck Stamina")) == 0)
			{
				BYTE bytes[] = { 0xFF,0x75,0x0C,0xF3,0x0F,0x10,0x45,0x08 }; $$$;
				wvmb(createMove, &bytes); $$$;
				VirtualFreeEx(hProcess, SWshellcode, 256, MEM_RELEASE); $$$;
			}
			cheat.Update(AY_OBFUSCATE("Slide Walk & No Duck Stamina")); $$$;
		}

		if (cheat.Triggered(AY_OBFUSCATE("Grenade Trajectory")))
		{
			if (cheat(AY_OBFUSCATE("Grenade Trajectory")) == 1)
			{
				SetValue(AY_OBFUSCATE("cl_grenadepreview"), 1); $$$;
			}
			else
			{
				SetValue(AY_OBFUSCATE("cl_grenadepreview"), 0); $$$;
			}

			cheat.Update(AY_OBFUSCATE("Grenade Trajectory")); $$$;
		}

		if (cheat.Triggered(AY_OBFUSCATE("Recoil Control System")))
		{
			if (cheat(AY_OBFUSCATE("Recoil Control System")) == 1)
			{
				$$$;
				if (cheat(AY_OBFUSCATE("Crosshair Recoil & Spread")) == 1)
					SetValue(AY_OBFUSCATE("cl_crosshair_recoil"), 0.0f); $$$;

				if (cheat(AY_OBFUSCATE("No Visual Recoil")) == 1) 
					SetValue(AY_OBFUSCATE("view_recoil_tracking"), 1.0f); $$$;
			}
			else
			{
				$$$;
				if (cheat(AY_OBFUSCATE("Crosshair Recoil & Spread")) == 1)
					if (cheat(AY_OBFUSCATE("No Visual Recoil")) == 1) 
						SetValue(AY_OBFUSCATE("cl_crosshair_recoil"), 2.0f);
					else SetValue(AY_OBFUSCATE("cl_crosshair_recoil"), 1.0f); $$$;

				if (cheat(AY_OBFUSCATE("No Visual Recoil")) == 1) 
					SetValue(AY_OBFUSCATE("view_recoil_tracking"), 0.0f); $$$;
			}

			cheat.Update(AY_OBFUSCATE("Recoil Control System")); $$$;
		}

		if (cheat.Triggered(AY_OBFUSCATE("Crosshair Recoil & Spread")))
		{
			if (cheat(AY_OBFUSCATE("Crosshair Recoil & Spread")) != 0)
			{
				if (cheat(AY_OBFUSCATE("No Visual Recoil")) == 1)
				{
					if (cheat(AY_OBFUSCATE("Recoil Control System")) == 0)
						SetValue(AY_OBFUSCATE("cl_crosshair_recoil"), 2.0f);
					else SetValue(AY_OBFUSCATE("cl_crosshair_recoil"), 0.0f); $$$;
				}
				else
				{
					SetValue(AY_OBFUSCATE("cl_crosshair_recoil"), 1.0f); $$$;
				}

				SetValue(AY_OBFUSCATE("weapon_debug_spread_show"), 1); $$$;
			}
			else
			{
				SetValue(AY_OBFUSCATE("cl_crosshair_recoil"), 0.0f); $$$;
				SetValue(AY_OBFUSCATE("weapon_debug_spread_show"), 0); $$$;
			}

			cheat.Update(AY_OBFUSCATE("Crosshair Recoil & Spread")); $$$;
		}

		if (cheat.Triggered(AY_OBFUSCATE("Overhead Info & Radarhack")))
		{
			if (cheat(AY_OBFUSCATE("Overhead Info & Radarhack")) == 1)
			{
				wvm<BYTE>(radarHax, 1); $$$;
				wvm<WORD>(seeEnemyInfo, 0x9090); $$$;
			}

			if (cheat(AY_OBFUSCATE("Overhead Info & Radarhack")) == 2)
			{
				wvm<BYTE>(radarHax, 1); $$$;
				wvm<WORD>(seeEnemyInfo, 0xC63B); $$$;
			}

			if (cheat(AY_OBFUSCATE("Overhead Info & Radarhack")) == 0)
			{
				wvm<BYTE>(radarHax, 0); $$$;
				wvm<WORD>(seeEnemyInfo, 0xC63B); $$$;
			}

			cheat.Update(AY_OBFUSCATE("Overhead Info & Radarhack")); $$$;

		}

		if (cheat.Triggered(AY_OBFUSCATE("Money; Rank Reveal")))
		{
			if (cheat(AY_OBFUSCATE("Money; Rank Reveal")) == 1)
			{
				revealOrig = rvm<DWORD>(reveal1); $$$;
				wvm<WORD>(reveal1, 0x9090); $$$;
				wvm<WORD>(reveal2, 0x9090); $$$;
			}

			if (cheat(AY_OBFUSCATE("Money; Rank Reveal")) == 2)
			{
				if (cheat(AY_OBFUSCATE("Money; Rank Reveal")).trigger == 0)
					revealOrig = rvm<DWORD>(reveal1); $$$;

				LPVOID shellCodeAddress, memeAddress; $$$;
				BYTE asm_stub[] =
				{
					0x68, 0x00, 0x00, 0x00, 0x00,   // push float* (1)
					0x55, 0x89, 0xE5,               // cdecl call frame
					0xB8, 0x00, 0x00, 0x00, 0x00,   // mov    eax,0x00000000 (9)
					0xFF, 0xD0,                     // call   eax
					0x83, 0xC4, 0x4,                // clear stack
					0x5D,                           // reset call frame
					0xC3                            // return
				}; $$$;

				D3DXVECTOR3 meme; $$$;
				meme.x = meme.y = meme.z = 0.f; $$$;
				static unsigned int shellSize = sizeof(asm_stub) + 1; $$$;
				unsigned int dataSize = (sizeof(LPVOID) + sizeof(DWORD)) + 2; $$$;
				shellCodeAddress = VirtualAllocEx(hProcess, NULL, shellSize + dataSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); $$$;
				memeAddress = VirtualAllocEx(hProcess, NULL, sizeof(meme) + 1, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); $$$;
				WriteProcessMemory(hProcess, memeAddress, &meme, sizeof(meme), NULL); $$$;
				WriteProcessMemory(hProcess, shellCodeAddress, &asm_stub, sizeof(asm_stub), NULL); $$$;
				WriteProcessMemory(hProcess, (LPVOID)((DWORD)shellCodeAddress + 0x1), &memeAddress, sizeof(LPVOID), NULL); $$$;
				wvm((DWORD)shellCodeAddress + 0x9, rankOffsetThing); $$$;
#ifdef DEBUG
				cout << AY_OBFUSCATE("RankReveal shellCodeAddress ") << (DWORD)shellCodeAddress << endl; $$$;
#endif
				HANDLE thread = CreateRemoteThread(hProcess, NULL, NULL, (LPTHREAD_START_ROUTINE)shellCodeAddress, NULL, NULL, NULL); $$$;
				WaitForSingleObject(thread, INFINITE); $$$;
				CloseHandle(thread); $$$;

				VirtualFreeEx(hProcess, shellCodeAddress, 256, MEM_RELEASE); $$$;
				VirtualFreeEx(hProcess, memeAddress, 256, MEM_RELEASE); $$$;
			}

			if (cheat(AY_OBFUSCATE("Money; Rank Reveal")) == 0)
			{
				wvm<DWORD>(reveal1, revealOrig); $$$;
				wvm<WORD>(reveal2, 0xC63B); $$$;
			}

			cheat.Update(AY_OBFUSCATE("Money; Rank Reveal")); $$$;
		}

		if (cheat.Triggered(AY_OBFUSCATE("No Visual Recoil")))
		{

			if (cheat(AY_OBFUSCATE("No Visual Recoil")) == 1)
			{
				BYTE shellCode1[] = { 0x90,0x90,0x90,0x90,punchExtraOrigBytes[4],punchExtraOrigBytes[5],punchExtraOrigBytes[6],punchExtraOrigBytes[7],
				punchExtraOrigBytes[8],punchExtraOrigBytes[9],punchExtraOrigBytes[10],punchExtraOrigBytes[11],punchExtraOrigBytes[12],punchExtraOrigBytes[13],
				punchExtraOrigBytes[14],punchExtraOrigBytes[4],punchExtraOrigBytes[4],0x90,0x90,0x90,0x90,0x90 }; $$$;
				wvmb(aimPunch, &shellCode1); $$$;
				if (cheat(AY_OBFUSCATE("Recoil Control System")) == 0)
					SetValue(AY_OBFUSCATE("view_recoil_tracking"), 0.0f);
				else SetValue(AY_OBFUSCATE("view_recoil_tracking"), 1.0f); $$$;

				if (cheat(AY_OBFUSCATE("Crosshair Recoil & Spread")) != 0) {
					if (cheat(AY_OBFUSCATE("Recoil Control System")) == 0)
						SetValue(AY_OBFUSCATE("cl_crosshair_recoil"), 2.0f);
					else SetValue(AY_OBFUSCATE("cl_crosshair_recoil"), 0.0f); $$$;
				}
			}

			if (cheat(AY_OBFUSCATE("No Visual Recoil")) == 2)
			{
				BYTE shellCode1[] = { 0x90,0x90,0x90,0x90,punchExtraOrigBytes[4],punchExtraOrigBytes[5],punchExtraOrigBytes[6],punchExtraOrigBytes[7],
				punchExtraOrigBytes[8],punchExtraOrigBytes[9],punchExtraOrigBytes[10],punchExtraOrigBytes[11],punchExtraOrigBytes[12],punchExtraOrigBytes[13],
				punchExtraOrigBytes[14],punchExtraOrigBytes[4],punchExtraOrigBytes[4],0x90,0x90,0x90,0x90,0x90 }; $$$;
				wvmb(aimPunch, &shellCode1); $$$;
				SetValue(AY_OBFUSCATE("view_recoil_tracking"), 0.45f); $$$;
				if (cheat(AY_OBFUSCATE("Crosshair Recoil & Spread")) != 0)
					SetValue(AY_OBFUSCATE("cl_crosshair_recoil"), 1.0f); $$$;
			}

			if (cheat(AY_OBFUSCATE("No Visual Recoil")) == 0)
			{
				wvmb(aimPunch, &punchExtraOrigBytes); $$$;
				SetValue(AY_OBFUSCATE("view_recoil_tracking"), 0.45f); $$$;

				if (cheat(AY_OBFUSCATE("Crosshair Recoil & Spread")) != 0)
					SetValue(AY_OBFUSCATE("cl_crosshair_recoil"), 1.0f); $$$;
			}

			cheat.Update(AY_OBFUSCATE("No Visual Recoil")); $$$;
		}

		if (cheat.Triggered(AY_OBFUSCATE("Thirdperson; Free Cam")))
		{
			if (cheat(AY_OBFUSCATE("Thirdperson; Free Cam")) != 0)
				wvm(localplayer + iObserverMode, 1); $$$;

			if (cheat(AY_OBFUSCATE("Thirdperson; Free Cam")) == 0)
				wvm(localplayer + iObserverMode, 0); $$$;

			cheat.Update(AY_OBFUSCATE("Thirdperson; Free Cam")); $$$;
		}

		if (cheat.Triggered(AY_OBFUSCATE("Player Glow & Color")))
		{
			if (cheat(AY_OBFUSCATE("Player Glow & Color")).trigger == 0 && cheat(AY_OBFUSCATE("Player Glow & Color")) != 0)
				GLOWshellcode = SpyInjectAndJump(GlowNoFlick, PVOID(glowNoFlick), 1); $$$;

			go.glowStyle = cheat(AY_OBFUSCATE("Player Glow & Color")).enabled - 1; $$$;
			if (cheat(AY_OBFUSCATE("Player Glow & Color")) == 0) {
				wvm<short>(glowNoFlick, 0xB38B); $$$;
				wvm<int>(glowNoFlick + 2, iGlowIndex); $$$;
				VirtualFreeEx(hProcess, GLOWshellcode, 256, MEM_RELEASE); $$$;
				for (int i = 0; i < 64; i++)
					wvm<DWORD>(rvm<DWORD>(client_dll + dwEntityList + i * 0x10) + clrRender, 0xFFFFFFFF); $$$;
			}
			cheat.Update(AY_OBFUSCATE("Player Glow & Color")); $$$;
		}

		if (cheat.Triggered(AY_OBFUSCATE("No Hands & Scope & Postproc")))
		{
			if (cheat(AY_OBFUSCATE("No Hands & Scope & Postproc")) != 0)
			{
				SetValue(AY_OBFUSCATE("mat_postprocess_enable"), 0); $$$;
			}
			else { SetValue(AY_OBFUSCATE("mat_postprocess_enable"), 1); $$$; }
			cheat.Update(AY_OBFUSCATE("No Hands & Scope & Postproc")); $$$;
		}


		if (cheat.Triggered(AY_OBFUSCATE("Skybox Changer")))
		{
			if (cheat(AY_OBFUSCATE("Skybox Changer")) != 0) {
				SetValue(AY_OBFUSCATE("r_3dsky"), 0); $$$;
				char skyname[64] = ""; $$$;
				switch (cheat(AY_OBFUSCATE("Skybox Changer")).enabled)
				{
				case 1:
					strcat_s(skyname, AY_OBFUSCATE("vertigo")); $$$;
					break;

				case 2:
					strcat_s(skyname, AY_OBFUSCATE("cs_tibet")); $$$;
					break;

				case 3:
					strcat_s(skyname, AY_OBFUSCATE("jungle")); $$$;
					break;

				case 4:
					strcat_s(skyname, AY_OBFUSCATE("embassy")); $$$;
					break;

				case 5:
					strcat_s(skyname, AY_OBFUSCATE("cs_baggage_skybox_")); $$$;
					break;

				case 6:
					strcat_s(skyname, AY_OBFUSCATE("italy")); $$$;
					break;
				}

				if (cheat(AY_OBFUSCATE("Skybox Changer")).trigger == 0) {
					SCshellcode = SpyInjectAndJump(SkyChange, PVOID(skyFunc + 3), 1); $$$;
					skyName = VirtualAllocEx(hProcess, NULL, sizeof(skyname) + 1, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); $$$;
					wvm((DWORD)SCshellcode + 1, skyName); $$$;
				}
				wvmb((DWORD)skyName, &skyname); $$$;
				if (rvm<DWORD>(clientstate + dwClientState_State) == 6) {

					HANDLE thread = CreateRemoteThread(hProcess, NULL, NULL, (LPTHREAD_START_ROUTINE)skyFunc, NULL, NULL, NULL); $$$;
					Sleep(1); $$$;
					Suspend(1); $$$;
					Sleep(500); $$$;

					WaitForSingleObject(thread, INFINITE); $$$;
					CloseHandle(thread); $$$;
					Sleep(500); $$$;
					Suspend(0); $$$;
				}
			}
			else
			{
				SetValue(AY_OBFUSCATE("r_3dsky"), 1); $$$;
				VirtualFreeEx(hProcess, SCshellcode, 256, MEM_RELEASE); $$$;
				VirtualFreeEx(hProcess, skyName, 256, MEM_RELEASE); $$$;
				wvm<long long>(skyFunc + 3, 0x575600000134EC81); $$$;
			}
			$$$;
			cheat.Update(AY_OBFUSCATE("Skybox Changer")); $$$;
		}

		if (rvm<DWORD>(clientstate + dwClientState_State) == 6) {

#ifdef BSP_PARSER
			if (!mapparsed)
			{
				char map[64]; $$$;
				rvm(clientstate + dwClientState_Map, &map); $$$;
				strcat_s(map, AY_OBFUSCATE(".bsp")); $$$;
				if (bspParser->load_map(folder.c_str(), map))
				{
#ifdef DEBUG
					cout << AY_OBFUSCATE("Map parsed!\n");
#endif
					$$$;
				}
				else
				{
#ifdef DEBUG
					cout << AY_OBFUSCATE("Can't parse map\n");
#endif
					$$$;
				}
				mapparsed = true; $$$;
			}
#endif

			if (cheat(AY_OBFUSCATE("No Hands & Scope & Postproc")) == 1)
			{
				if (cheat(AY_OBFUSCATE("Skin Changer")) == 0)
					wvm<BYTE>(localplayer + nModelIndex, 0); $$$; //arms
				wvm<BYTE>(localplayer + bIsScoped, 0); $$$;
			}

			if (cheat(AY_OBFUSCATE("Reduce Flash & Smoke")) != 0)
			{
				wvm<float>(localplayer + flFlashMaxAlpha, 50.0f); $$$;
				wvm<int>(noSmoke, 0); $$$;
			}

			if (cheat(AY_OBFUSCATE("Thirdperson; Free Cam")) != 0) {
				if (!rvm<DWORD>(localplayer + iObserverMode))
					wvm(localplayer + iObserverMode, 1); $$$;
			}

			if (cheat(AY_OBFUSCATE("Hit Sound")) != 0)
			{
				totalhits = rvm<int>(localplayer + totalHitsOnServer); $$$;
				if (totalhits > hits)
				{
					hits = totalhits; $$$;
					sndPlaySound((LPCSTR)lpRes, SND_MEMORY | SND_ASYNC); $$$;
				}
				if (totalhits == 0) hits = 0; $$$;
			}

			if (cheat(AY_OBFUSCATE("Zoom; Field of View")) == 2)
			{
				if (rvm<DWORD>(localplayer + defaultFOV) != 120)
					wvm(localplayer + defaultFOV, 120); $$$;
			}
		}
#ifdef BSP_PARSER
		else {
			if (mapparsed)
				mapparsed = false; $$$;
		}
#endif

		Sleep(1); $$$;
	}
}

void FreeCam() {
	SetValue(AY_OBFUSCATE("cl_forwardspeed"), 0.0f);
	SetValue(AY_OBFUSCATE("cl_sidespeed"), 0.0f);
	SetValue(AY_OBFUSCATE("cl_backspeed"), 0.0f);

	__int64 freeCamOrig1 = rvm<__int64>(client_dll + freeCam); $$$;

	LPVOID Addr = VirtualAllocEx(
		hProcess,
		0,
		sizeof(DWORD),
		MEM_COMMIT | MEM_RESERVE,
		PAGE_EXECUTE_READWRITE
	); $$$;

	dword2bytes addr = { (DWORD)Addr }; $$$;
	BYTE shellcode[] = { 0x89, 0x3D, addr.bytes[0], addr.bytes[1], addr.bytes[2], addr.bytes[3], 0xEB, 0x0C }; $$$;

	wvmb(client_dll + freeCam, &shellcode); $$$;
	wvm(client_dll + freeCam + 0xC9, 0x909022EB); $$$;

	float flyangX, flyangY; $$$;

	Sleep(100); $$$;
	DWORD visualOrigin = rvm<DWORD>(DWORD(Addr)); $$$;
	D3DXVECTOR3 vispos = rvm<D3DXVECTOR3>(visualOrigin); $$$;
#ifdef DEBUG
	cout << AY_OBFUSCATE("Free Cam activated, visual position address = 0x") << hex << visualOrigin << "\n"; $$$;
#endif

	while (cheat(AY_OBFUSCATE("Thirdperson; Free Cam")) == 2)
	{
		flyangX = rvm<float>(clientstate + dwClientState_ViewAngles); $$$;
		flyangY = rvm<float>(clientstate + dwClientState_ViewAngles + 4); $$$;

		flyangY -= 90.0; $$$;
		if (GetAsyncKeyState(0x57) < 0) //W
		{
			vispos[0] += -sin(flyangY * PI / 180); $$$;
			vispos[1] += cos(flyangY * PI / 180); $$$;
			vispos[2] += -sin(flyangX * PI / 180); $$$;
			wvm(visualOrigin, vispos); $$$;
		}

		if (GetAsyncKeyState(0x53) < 0) //S
		{
			vispos[0] -= -sin(flyangY * PI / 180); $$$;
			vispos[1] -= cos(flyangY * PI / 180); $$$;
			vispos[2] += sin(flyangX * PI / 180); $$$;
			wvm(visualOrigin, vispos); $$$;
		}

		if (GetAsyncKeyState(0x41) < 0) //A
		{
			vispos[0] -= cos(flyangY * PI / 180); $$$;
			vispos[1] -= sin(flyangY * PI / 180); $$$;
			wvm(visualOrigin, vispos); $$$;
		}

		if (GetAsyncKeyState(0x44) < 0) //D
		{
			vispos[0] += cos(flyangY * PI / 180); $$$;
			vispos[1] += sin(flyangY * PI / 180); $$$;
			wvm(visualOrigin, vispos); $$$;
		}
		Sleep(1); $$$;
	}

	wvm<__int64>(client_dll + freeCam, freeCamOrig1); $$$;
	wvm(client_dll + freeCam + 0xC9, 0x07110FF3); $$$;
	SetValue(AY_OBFUSCATE("cl_forwardspeed"), 450.0f); $$$;
	SetValue(AY_OBFUSCATE("cl_sidespeed"), 450.0f); $$$;
	SetValue(AY_OBFUSCATE("cl_backspeed"), 450.0f); $$$;
	VirtualFreeEx(hProcess, Addr, sizeof(DWORD), MEM_RELEASE); $$$;
}


```

`cheat1/cheat1.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource1.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// Russian (Russia) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_RUS)
LANGUAGE LANG_RUSSIAN, SUBLANG_DEFAULT

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource1.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED

#endif    // Russian (Russia) resources
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US

/////////////////////////////////////////////////////////////////////////////
//
// WAVE
//

IDR_WAVE1               WAVE                    "Hitsound.wav"
IDR_FONT1               FONT                    "Roboto.ttf"

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`cheat1/cheat1.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{4974551D-EB96-49FC-AD60-067F9D54658C}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>cheat1</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>spy</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>false</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>C:\Program Files %28x86%29\Microsoft DirectX SDK %28June 2010%29\Include;$(IncludePath)</IncludePath>
    <LibraryPath>C:\Program Files %28x86%29\Microsoft DirectX SDK %28June 2010%29\Lib\x86;C:\Program Files %28x86%29\Microsoft DirectX SDK %28June 2010%29\Include;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>C:\Program Files %28x86%29\Microsoft DirectX SDK %28June 2010%29\Include;$(IncludePath)</IncludePath>
    <LibraryPath>C:\Program Files %28x86%29\Microsoft DirectX SDK %28June 2010%29\Lib\x86;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <IncludePath>C:\Program Files %28x86%29\Microsoft DirectX SDK %28June 2010%29\Include;$(IncludePath)</IncludePath>
    <LibraryPath>C:\Program Files %28x86%29\Windows Kits\10\Include\10.0.17763.0\ucrt;C:\Program Files %28x86%29\Windows Kits\10\Lib\10.0.17763.0\um\x86;C:\Program Files %28x86%29\Microsoft DirectX SDK %28June 2010%29\Lib\x86;$(IncludePath);C:\Program Files (x86)\Microsoft Visual Studio\2017\Professional\VC\Tools\MSVC\14.16.27023\lib\x86;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <OptimizeReferences>false</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <AdditionalOptions>/std:c++latest %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <OptimizeReferences>false</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <UACExecutionLevel>HighestAvailable</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="bsp_parser.h" />
    <ClInclude Include="cheat.cpp" />
    <ClInclude Include="main.h" />
    <ClInclude Include="d3d9.h" />
    <ClInclude Include="memory.h" />
    <ClInclude Include="asm.cpp" />
    <ClInclude Include="obfuscator.h" />
    <ClInclude Include="resource1.h" />
    <ClInclude Include="utils.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="cheat1.rc" />
  </ItemGroup>
  <ItemGroup>
    <Media Include="Hitsound.wav" />
	<Media Include="Roboto.ttf" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`cheat1/cheat1.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="d3d9.h">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="main.h">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="cheat.cpp">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="asm.cpp">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="memory.h">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="resource1.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="obfuscator.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="bsp_parser.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="utils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="cheat1.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <Media Include="Hitsound.wav">
      <Filter>Resource Files</Filter>
    </Media>
  </ItemGroup>
</Project>
```

`cheat1/cheat1.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>true</ShowAllFiles>
  </PropertyGroup>
</Project>
```

`cheat1/d3d9.h`:

```h
#ifndef D3D9
#define D3D9

#include <d3dx9.h>
#include <d3d9.h>
#pragma comment(lib, "d3d9.lib")
#pragma comment(lib, "d3dx9.lib")
#include <dwmapi.h>
#pragma comment(lib, "dwmapi.lib")

DWM_BLURBEHIND bb = { DWM_BB_ENABLE | DWM_BB_BLURREGION, true, CreateRectRgn(0, 0, -1, -1), true };
D3DCOLOR colorprim = D3DCOLOR_ARGB(255, 203, 111, 111); //PRIMARY CHEAT COLOR 
D3DCOLOR colorsec = D3DCOLOR_ARGB(200, 5, 0, 0); //SECONDARY CHEAT COLOR 
int border = 4; //CHEAT BORDER

extern IDirect3DDevice9Ex* p_Device;
#define PI 3.14159265 
extern LONG leftR, topR, bottomR;
extern int border; extern D3DCOLOR color; extern BYTE drawmenu, menuselect;

void DrawFilledRectangle(float x, float y, float w, float h, int a, int r, int g, int b)
{
	x += leftR; $$$;
	y += topR; $$$;
	w += leftR; $$$;
	h += topR; $$$;
	D3DCOLOR color = D3DCOLOR_ARGB(a, r, g, b); $$$;
	D3DRECT rect = { x, y, w, h }; $$$;
	p_Device->Clear(1, &rect, D3DCLEAR_TARGET | D3DCLEAR_TARGET, color, 0, 0); $$$;
}

void DrawFilledRectangle(float x, float y, float w, float h, D3DCOLOR color)
{
	x += leftR; $$$;
	y += topR; $$$;
	w += leftR; $$$;
	h += topR; $$$;
	D3DRECT rect = { x, y, w, h }; $$$;
	p_Device->Clear(1, &rect, D3DCLEAR_TARGET | D3DCLEAR_TARGET, color, 0, 0); $$$;
}

void DrawBorderBox(int x, int y, int w, int h, int thickness, int a, int r, int g, int b)
{
	DrawFilledRectangle(x, y, x + w, y + thickness, a, r, g, b); $$$;
	DrawFilledRectangle(x, y, x + thickness, y + h, a, r, g, b); $$$;
	DrawFilledRectangle(x, y + h, x + w, y + h + thickness, a, r, g, b); $$$;
	DrawFilledRectangle(x + w, y, x + w + thickness, y + h + thickness, a, r, g, b); $$$;
}

void DrawBorderBox(int x, int y, int w, int h, int thickness, D3DCOLOR color)
{
	DrawFilledRectangle(x, y, x + w, y + thickness, color); $$$;
	DrawFilledRectangle(x, y, x + thickness, y + h, color); $$$;
	DrawFilledRectangle(x, y + h, x + w, y + h + thickness, color); $$$;
	DrawFilledRectangle(x + w, y, x + w + thickness, y + h + thickness, color); $$$;
}

void DrawString(char* String, int x, int y, int a, int r, int g, int b, ID3DXFont* font)
{
	x += leftR; $$$;
	y += topR; $$$;
	RECT FontPos; $$$;
	FontPos.left = x; $$$;
	FontPos.top = y; $$$;
	font->DrawTextA(0, String, strlen(String), &FontPos, DT_NOCLIP, D3DCOLOR_ARGB(a, r, g, b)); $$$;
}


void DrawString(char* String, int x, int y, D3DCOLOR color, ID3DXFont* font)
{
	x += leftR; $$$;
	y += topR; $$$;
	RECT FontPos; $$$;
	FontPos.left = x; $$$;
	FontPos.top = y; $$$;
	font->DrawTextA(0, String, strlen(String), &FontPos, DT_NOCLIP, color); $$$;
}

void DrawString(char* String, int x, int y, int len, D3DCOLOR color, ID3DXFont* font)
{
	x += leftR; $$$;
	y += topR; $$$;
	RECT FontPos; $$$;
	FontPos.left = x; $$$;
	FontPos.top = y; $$$;
	font->DrawTextA(0, String, len, &FontPos, DT_NOCLIP, color); $$$;
}


void DrawStringW(wchar_t* String, int x, int y, int len, D3DCOLOR color, ID3DXFont* font)
{
	x += leftR; $$$;
	y += topR; $$$;
	RECT FontPos; $$$;
	FontPos.left = x; $$$;
	FontPos.top = y; $$$;
	font->DrawTextW(0, String, len, &FontPos, DT_NOCLIP, color); $$$;
}

LPDIRECT3DVERTEXBUFFER9 v_buffer = NULL; 
struct vertex {
	FLOAT x, y, z,
		rhw; 
	DWORD color; 
}; 

void DrawCircle(float x, float y, float rad, float rotate, int resolution, DWORD color)
{
	x += leftR; $$$;
	y += topR; $$$;
	vector<vertex> circle(resolution + 2); $$$;
	float angle = rotate * PI / 180; $$$;

	circle[0].x = x - rad; $$$;
	circle[0].y = y; $$$;
	circle[0].z = 0; $$$;
	circle[0].rhw = 1; $$$;
	circle[0].color = color; $$$;

	for (int i = 1; i < resolution + 2; i++)
	{
		circle[i].x = (float)(x - rad * cos(PI*((i - 1) / (resolution / 2.0f)))); $$$;
		circle[i].y = (float)(y - rad * sin(PI*((i - 1) / (resolution / 2.0f)))); $$$;
		circle[i].z = 0; $$$;
		circle[i].rhw = 1; $$$;
		circle[i].color = color; $$$;
	}

	// Rotate matrix
	int _res = resolution + 2; $$$;
	for (int i = 0; i < _res;  i++)
	{
		circle[i].x = x + cos(angle)*(circle[i].x - x) - sin(angle)*(circle[i].y - y); $$$;
		circle[i].y = y + sin(angle)*(circle[i].x - x) + cos(angle)*(circle[i].y - y); $$$;
	}

	p_Device->CreateVertexBuffer((resolution + 2) * sizeof(vertex), D3DUSAGE_WRITEONLY, D3DFVF_XYZRHW | D3DFVF_DIFFUSE, D3DPOOL_DEFAULT, &v_buffer, NULL); $$$;

	VOID* pVertices; $$$;
	v_buffer->Lock(0, (resolution + 2) * sizeof(vertex), (void**)&pVertices, 0); $$$;
	memcpy(pVertices, &circle[0], (resolution + 2) * sizeof(vertex)); $$$;
	v_buffer->Unlock(); $$$;

	p_Device->SetTexture(0, NULL); $$$;
	p_Device->SetPixelShader(NULL); $$$;
	p_Device->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE); $$$;
	p_Device->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA); $$$;
	p_Device->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA); $$$;

	p_Device->SetStreamSource(0, v_buffer, 0, sizeof(vertex)); $$$;
	p_Device->SetFVF(D3DFVF_XYZRHW | D3DFVF_DIFFUSE); $$$;
	p_Device->DrawPrimitive(D3DPT_LINESTRIP, 0, resolution); $$$;
	if (v_buffer != NULL) v_buffer->Release(); $$$;
}

extern int Width, Height; 
IDirect3D9Ex* p_Object = 0; 
D3DPRESENT_PARAMETERS p_Params; 

class Resource {
public:
	std::size_t size_bytes = 0; 
	void* ptr = nullptr; 
	HRSRC hResource = nullptr; 
	HGLOBAL hMemory = nullptr; 
public:
	Resource(int resource_id, const std::string &resource_class) {
		hResource = FindResource(nullptr, MAKEINTRESOURCEA(resource_id), resource_class.c_str()); $$$;
		hMemory = LoadResource(nullptr, hResource); $$$;

		size_bytes = SizeofResource(nullptr, hResource); $$$;
		ptr = LockResource(hMemory); $$$;
	}
}; 

int DirectXInit(HWND hWnd)
{
	if (FAILED(Direct3DCreate9Ex(D3D_SDK_VERSION, &p_Object)))
		exit(1); $$$;

	ZeroMemory(&p_Params, sizeof(p_Params)); $$$;
	p_Params.Windowed = TRUE; $$$;
	p_Params.SwapEffect = D3DSWAPEFFECT_DISCARD; $$$;
	p_Params.hDeviceWindow = hWnd; $$$;
	p_Params.MultiSampleQuality = D3DMULTISAMPLE_NONE; $$$;
	p_Params.BackBufferFormat = D3DFMT_A8R8G8B8; $$$;
	p_Params.BackBufferWidth = Width; $$$;
	p_Params.BackBufferHeight = Height; $$$;
	p_Params.EnableAutoDepthStencil = TRUE; $$$;
	p_Params.AutoDepthStencilFormat = D3DFMT_D16; $$$;
	if (FAILED(p_Object->CreateDeviceEx(D3DADAPTER_DEFAULT,
		D3DDEVTYPE_HAL,
		hWnd,
		D3DCREATE_SOFTWARE_VERTEXPROCESSING,
		&p_Params,
		0,
		&p_Device)))
		exit(1); $$$;
	return 0; $$$;
}

extern HWND hWnd; 
extern Cheat cheat;

void menu()
{
	SetLayeredWindowAttributes(hWnd, NULL, NULL, NULL); $$$;
	DwmEnableBlurBehindWindow(hWnd, &bb); $$$;

	float hb = Height - bottomR; $$$;
	int fontsize = hb / 51; $$$; 
	int menuheight = fontsize * 15; $$$; 

	ID3DXFont* pFont; $$$;
	D3DXCreateFont(p_Device, fontsize, 0, FW_NORMAL, 1, false, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE, "Roboto", &pFont); $$$;

	DrawString((char*)AY_OBFUSCATE("Spy External 1337hax"), 5, 5, 25, 255, 255, 255, pFont); $$$;

	if (drawmenu) {
		DrawFilledRectangle(20,
			(Height - bottomR) / 3,
			menuheight + border,
			(Height - bottomR) / 3 + border * 3 + 1.5*fontsize + cheat.Count() * (fontsize*1.2),
			colorprim); $$$;  
		DrawFilledRectangle(20 + border,
			(Height - bottomR) / 3 + border * 2 + fontsize,
			menuheight,
			(Height - bottomR) / 3 + border * 2 + 1.5*fontsize + cheat.Count() * (fontsize*1.2),
			colorsec); $$$;

		RECT FontPos{ 20 + leftR,
			(Height - bottomR) / 3 + topR + border,
			menuheight + border + leftR,
			(Height - bottomR) / 3 + border * 2 + 1.5*fontsize + topR }; $$$;
		pFont->DrawTextA(0, (char*)AY_OBFUSCATE("Spy External 1337hax"), 21, &FontPos, DT_CENTER, colorsec); $$$;

		int menutop = (Height - bottomR) / 3 + border * 2 + 1.5*fontsize; $$$;
		for (BYTE i = 0; i < cheat.Count(); i++)
		{
			if (menuselect == i)
			{
				color = D3DCOLOR_ARGB(255, 255, 255, 255); $$$;
			}
			else if (cheat(i).name == (char*)AY_OBFUSCATE("Disable All & Close Cheat"))
			{
				color = D3DCOLOR_ARGB(255, 255, 50, 50); $$$;
			}
			else
			{
				color = colorprim; $$$;
			}

			DrawString((char*)cheat(i).name.c_str(), 20 + border + fontsize / 2, menutop, color, pFont); $$$;

			if (cheat(i).enabled < 10)
			{
				DrawString((char*)(std::to_string(cheat(i).enabled).c_str()), menuheight - 2 * border - fontsize / 2, menutop, color, pFont); $$$;
			}
			else
			{
				DrawString((char*)(std::to_string(cheat(i).enabled).c_str()), menuheight - 2 * border - 1.5*(fontsize / 2), menutop, color, pFont); $$$;
			}

			menutop += fontsize * 1.2; $$$; 
		}
	}
	pFont->Release(); $$$;
}

#endif

```

`cheat1/main.cpp`:

```cpp
#pragma once
#include "main.h"
#include <fstream>

#ifdef SUPPORT_CFG
void LoadCfg()
{
	ifstream loadcfg(AY_OBFUSCATE("settings.txt")); $$$;
	string line; $$$;
	if (loadcfg.is_open())
	{
		while (getline(loadcfg, line))
		{
			size_t pos = line.find(": "); $$$;
			string name = line.substr(0, pos); $$$;
			string var = line.erase(0, pos + 2); $$$;
			cheat(name.c_str()).enabled = stoi(var); $$$;
		}
		printfdbg(AY_OBFUSCATE("Config loaded\n")); $$$;
		loadcfg.close();
	} 
	else printfdbg(AY_OBFUSCATE("Unable to open configuration file\n")); $$$; 
}

void SaveCfg()
{
	ofstream savecfg; $$$;
	savecfg.open(AY_OBFUSCATE("settings.txt")); $$$;
	for (int i = 0; i < cheat.Count() - 1; i++)
		savecfg << cheat(i).name << ": " << cheat(i).enabled << endl; $$$;
	savecfg.close(); $$$; 
	printfdbg(AY_OBFUSCATE("Config saved\n")); $$$;
}
#endif

void MenuSelect()
{
	while (true)
	{
		if (tWnd == GetForegroundWindow() && GetAsyncKeyState(VK_INSERT) < 0) {
			if (drawmenu == 0) { drawmenu = 1; $$$; }
			else { drawmenu = 0; $$$; }
			Sleep(200); $$$;
		}

		if (drawmenu == 1 && tWnd == GetForegroundWindow()) {
			if (GetAsyncKeyState(VK_DOWN) < 0) {
				if (menuselect < cheat.Count() - 1)
				{
					menuselect++; $$$;
				}
				else menuselect = 0; $$$;

				Sleep(100); $$$;
			}

			if (GetAsyncKeyState(VK_UP) < 0) {
				if (menuselect > 0)
				{
					menuselect--; $$$;
				}
				else menuselect = cheat.Count() - 1; $$$;

				Sleep(100); $$$;
			}

			if (GetAsyncKeyState(VK_RIGHT) < 0) {
				if (cheat(menuselect).enabled < cheat(menuselect).modes)
				{
					cheat(menuselect) = cheat(menuselect).enabled + 1; $$$;
				}
				else
				{
					cheat(menuselect) = 0; $$$;
				}

				Sleep(cheat(menuselect).sleep); $$$;
			}

			if (GetAsyncKeyState(VK_LEFT) < 0) {
				if (cheat(menuselect).enabled > 0)
				{
					cheat(menuselect) = cheat(menuselect).enabled - 1; $$$;
				}
				else
				{
					cheat(menuselect) = cheat(menuselect).modes; $$$;
				}

				Sleep(cheat(menuselect).sleep); $$$;
			}
		}

		Sleep(1); $$$;
	}
}

void DisExit() {
#ifdef SUPPORT_CFG
	SaveCfg(); $$$;
#endif
	for (int i = 0; i < cheat.Count(); i++)
	{
		cheat(i) = 0; $$$;
	}

	Sleep(750); $$$;
	p_Object->Release(); $$$;

	_Exit(1); $$$;
}


void myInit() {
	timeBeginPeriod(1);
	
	position.x = 20; $$$;
	position.y = 20; $$$;

	auto clientBytes = new BYTE[client_dll_size + 1]; $$$;
	memset(clientBytes, 0, client_dll_size + 1); $$$;
	ReadProcessMemory(hProcess, PVOID(client_dll), clientBytes, client_dll_size, 0); $$$;
	auto engineBytes = new BYTE[engine_dll_size + 1]; $$$;
	memset(engineBytes, 0, engine_dll_size + 1); $$$;
	ReadProcessMemory(hProcess, PVOID(engine_dll), engineBytes, engine_dll_size, 0); $$$;

	dwClientState = rvm<DWORD>(engine_dll + SpyPatternScan(engineBytes, engine_dll_size, AY_OBFUSCATE("A1 ? ? ? ? 33 D2 6A 00 6A 00 33 C9 89 B0")) + 0x1) - engine_dll; $$$;
	dwLocalPlayer = rvm<DWORD>(client_dll + SpyPatternScan(clientBytes, client_dll_size, AY_OBFUSCATE("8D 34 85 ? ? ? ? 89 15 ? ? ? ? 8B 41 08 8B 48 04 83 F9 FF")) + 0x3) - client_dll + 4; $$$;
	dwEntityList = rvm<DWORD>(client_dll + SpyPatternScan(clientBytes, client_dll_size, AY_OBFUSCATE("BB ? ? ? ? 83 FF 01 0F 8C ? ? ? ? 3B F8")) + 0x1) - client_dll; $$$;
	dwViewMatrix = rvm<DWORD>(client_dll + SpyPatternScan(clientBytes, client_dll_size, AY_OBFUSCATE("0F 10 05 ? ? ? ? 8D 85 ? ? ? ? B9")) + 0x3) - client_dll + 0xB0; $$$;
	bDormantOffset = rvm<DWORD>(client_dll + SpyPatternScan(clientBytes, client_dll_size, AY_OBFUSCATE("8A 81 ? ? ? ? C3 32 C0")) + 0x2) + 8; $$$;
	dwClientState_ViewAngles = rvm<DWORD>(engine_dll + SpyPatternScan(engineBytes, engine_dll_size, AY_OBFUSCATE("F3 0F 11 86 ? ? ? ? F3 0F 10 44 24 ? F3 0F 11 86")) + 0x4); $$$;
	dwClientState_PlayerInfo = rvm<DWORD>(engine_dll + SpyPatternScan(engineBytes, engine_dll_size, AY_OBFUSCATE("8B 89 ? ? ? ? 85 C9 0F 84 ? ? ? ? 8B 01")) + 0x2); $$$;
	dwClientState_GetLocalPlayer = rvm<DWORD>(engine_dll + SpyPatternScan(engineBytes, engine_dll_size, AY_OBFUSCATE("8B 80 ? ? ? ? 40 C3")) + 0x2); $$$;
	dwClientState_State = rvm<DWORD>(engine_dll + SpyPatternScan(engineBytes, engine_dll_size, AY_OBFUSCATE("83 B8 ? ? ? ? ? 0F 94 C0 C3")) + 0x2); $$$;
	ClientCMD = engine_dll + SpyPatternScan(engineBytes, engine_dll_size,
		AY_OBFUSCATE("C2 04 00 CC CC CC CC CC CC CC CC CC 55 8B EC 8B 0D ? ? ? ? 81 F9")) + 12; $$$;
	nameExploit = engine_dll + SpyPatternScan(engineBytes, engine_dll_size, AY_OBFUSCATE("75 16 57 68 ? ? ? ? FF 15 ? ? ? ? 83 C4 08 5F 5E 5B 8B E5 5D C3 8B 06")); $$$;
	fnSetClanAddress = engine_dll + SpyPatternScan(engineBytes, engine_dll_size, AY_OBFUSCATE("53 56 57 8B DA 8B F9 FF 15")); $$$;
	m_szClan = rvm<DWORD>(client_dll + SpyPatternScan(clientBytes, client_dll_size, AY_OBFUSCATE("C7 45 D0 ? 00 00 00 0F 10 45 C4 C7 45 F0 ? ? 00 00 C7 45 E4")) + 0xE); $$$;
	dwPlayerResource = rvm<DWORD>(client_dll + SpyPatternScan(clientBytes, client_dll_size, AY_OBFUSCATE("8B 3D ? ? ? ? 85 FF 0F 84 ? ? ? ? 81 C7")) + 0x2) - client_dll; $$$;
	dwForceJump = rvm<DWORD>(client_dll + SpyPatternScan(clientBytes, client_dll_size, AY_OBFUSCATE("8B 0D ? ? ? ? 8B D6 8B C1 83 CA 02")) + 0x2) - client_dll; $$$;
	DWORD dwForce = client_dll + SpyPatternScan(clientBytes, client_dll_size, AY_OBFUSCATE("55 8B EC 51 53 8A 5D 08")); $$$;
	dwForceRight = rvm<DWORD>(dwForce + 512) - client_dll; $$$;
	dwForceLeft = rvm<DWORD>(dwForce + 465) - client_dll; $$$;
	dwForceForward = rvm<DWORD>(dwForce + 245) - client_dll; $$$;
	dwForceBackward = rvm<DWORD>(dwForce + 287) - client_dll; $$$;
	interface_engine_cvar = rvm<DWORD>(FindSignature(vstdlib_dll, vstdlib_dll_size, AY_OBFUSCATE("\x8B\x0D\x00\x00\x00\x00\xC7\x05"), AY_OBFUSCATE("xx????xx")) + 0x2) - vstdlib_dll; $$$; 
	dwGlowObjectManager = rvm<DWORD>(client_dll + SpyPatternScan(clientBytes, client_dll_size, AY_OBFUSCATE("A1 ? ? ? ? A8 01 75 4B")) + 0x1) - client_dll + 4; $$$;
	fakePrime = client_dll + SpyPatternScan(clientBytes, client_dll_size, AY_OBFUSCATE("83 F8 05 5E 0F 94 C0 C3")) + 0x2; $$$;
	fakeLevel = rvm<DWORD>(client_dll + SpyPatternScan(clientBytes, client_dll_size, AY_OBFUSCATE("0F 45 05 ? ? ? ? F6 05")) + 0x3) - client_dll; $$$;
	fakeRank = rvm<DWORD>(client_dll + SpyPatternScan(clientBytes, client_dll_size, AY_OBFUSCATE("A1 ? ? ? ? 8b 44 ? ? 89 07 E8")) + 0x1) - client_dll; $$$;
	radarHax = client_dll + SpyPatternScan(clientBytes, client_dll_size, AY_OBFUSCATE("80 B9 ? ? ? ? ? 74 12 8B 41 08")) + 6; $$$;
	aimPunch = client_dll + SpyPatternScan(clientBytes, client_dll_size, AY_OBFUSCATE("03 F3 0F 10 86 ? ? ? ? F3 0F 58 43")) - 3; $$$;
	rvm(aimPunch, &punchExtraOrigBytes); $$$;
	seeEnemyInfo = client_dll + 5 + SpyPatternScan(clientBytes, client_dll_size, AY_OBFUSCATE("E8 ? ? ? ? 3B C6 5E 5F")); $$$;
	noSmoke = rvm<DWORD>(client_dll + SpyPatternScan(clientBytes, client_dll_size,
		AY_OBFUSCATE("55 8B EC 83 EC 08 8B 15 ? ? ? ? 0F 57 C0")) + 8); $$$;
	dwForceAttack = rvm<DWORD>(client_dll + SpyPatternScan(clientBytes, client_dll_size,
		AY_OBFUSCATE("89 0D ? ? ? ? 8B 0D ? ? ? ? 8B F2 8B C1 83 CE 04")) + 2) - client_dll; $$$;
	reveal1 = client_dll + SpyPatternScan(clientBytes, client_dll_size, AY_OBFUSCATE("3B 45 ? 75 06 C6")) + 3; $$$;
	reveal2 = client_dll + SpyPatternScan(clientBytes, client_dll_size, AY_OBFUSCATE("3B C6 74 27 8B CB E8")); $$$;
	dwGameRulesProxy = rvm<DWORD>(client_dll + SpyPatternScan(clientBytes, client_dll_size,
		AY_OBFUSCATE("A1 ? ? ? ? 85 C0 0F 84 ? ? ? ? 80 B8 ? ? ? ? ? 74 7A")) + 1) - client_dll; $$$;
	convar_name_hash_table = rvm<DWORD>(FindSignature(vstdlib_dll, vstdlib_dll_size, AY_OBFUSCATE("\x8B\x3C\x85"), AY_OBFUSCATE("xxx")) + 3) - vstdlib_dll; $$$;
	freeCam = SpyPatternScan(clientBytes, client_dll_size, AY_OBFUSCATE("F8 F3 0F 11 1F")) + 1; $$$;
	aimPunchAngle = rvm<DWORD>(client_dll + SpyPatternScan(clientBytes, client_dll_size, AY_OBFUSCATE("00 F3 0F 7E 82 ? ? 00 00 8B")) + 5); $$$;
	createMove = client_dll + SpyPatternScan(clientBytes, client_dll_size, AY_OBFUSCATE("C2 08 00 8B 01 FF 75")) + 5; $$$;
	rankOffsetThing = client_dll + SpyPatternScan(clientBytes, client_dll_size,
		AY_OBFUSCATE("55 8B EC 51 A1 ? ? ? ? 85 C0 75 37")); $$$;
	skyFunc = engine_dll + SpyPatternScan(engineBytes, engine_dll_size, AY_OBFUSCATE("55 8B EC 81 EC ? ? ? ? 56 57 8B F9 C7 45")); $$$;
	glowNoFlick = client_dll + SpyPatternScan(clientBytes, client_dll_size, AY_OBFUSCATE("8B B3 ? ? ? ? E8 ? ? ? ? 8A")); $$$;
	dwClientState_Map = rvm<DWORD>(engine_dll + SpyPatternScan(engineBytes, engine_dll_size, AY_OBFUSCATE("05 ? ? ? ? C3 CC CC CC CC CC CC CC A1")) + 1); $$$;
	delta_ticks = rvm<DWORD>(engine_dll + SpyPatternScan(engineBytes, engine_dll_size, AY_OBFUSCATE("C7 87 ? ? ? ? ? ? ? ? FF 15 ? ? ? ? 83 C4 08"))+2); $$$;
	m_dwModelPrecache = rvm<DWORD>(engine_dll + SpyPatternScan(engineBytes, engine_dll_size, AY_OBFUSCATE("0C 3B 81 ? ? ? ? 75 11 8B 45 10 83 F8 01 7C 09 50 83")) + 3); $$$;
	
	DWORD dwWorld = client_dll + FindSignatureLocal(clientBytes, client_dll_size, AY_OBFUSCATE("DT_TEWorldDecal"), AY_OBFUSCATE("xxxxxxxxxxxxxxx")); $$$;
	DWORD dwClasses = rvm<DWORD>(client_dll + FindSignatureLocal(clientBytes, client_dll_size, (char*)&dwWorld, AY_OBFUSCATE("xxxx")) + 0x2B); $$$;
#ifdef DEBUG
	cout << AY_OBFUSCATE("dwClasses = ") << hex << dwClasses << endl; $$$;
#endif

	hObserverTarget = FindNetvar(dwClasses, AY_OBFUSCATE("DT_BasePlayer"), AY_OBFUSCATE("hObserverTarget")); $$$;
	dwBoneMatrix = FindNetvar(dwClasses, AY_OBFUSCATE("DT_BaseAnimating"), AY_OBFUSCATE("m_nForceBone")) + 28; $$$;
	vecOrigin = FindNetvar(dwClasses, AY_OBFUSCATE("DT_CSPlayer"), AY_OBFUSCATE("vecOrigin")); $$$;
	iHealth = FindNetvar(dwClasses, AY_OBFUSCATE("DT_BasePlayer"), AY_OBFUSCATE("iHealth")); $$$;
	iTeamNum = FindNetvar(dwClasses, AY_OBFUSCATE("DT_World"), AY_OBFUSCATE("TeamNum")); $$$;
	iObserverMode = FindNetvar(dwClasses, AY_OBFUSCATE("DT_BasePlayer"), AY_OBFUSCATE("iObserverMode")); $$$;
	m_lifeState = FindNetvar(dwClasses, AY_OBFUSCATE("DT_BasePlayer"), AY_OBFUSCATE("m_lifeState")); $$$;
	flFlashMaxAlpha = FindNetvar(dwClasses, AY_OBFUSCATE("DT_CSPlayer"), AY_OBFUSCATE("m_flFlashMaxAlpha")); $$$;
	fFlags = FindNetvar(dwClasses, AY_OBFUSCATE("DT_CSPlayer"), AY_OBFUSCATE("m_fFlags")); $$$;
	vecViewOffset = FindNetvar(dwClasses, AY_OBFUSCATE("DT_CSPlayer"), AY_OBFUSCATE("m_vecViewOffset[0]")); $$$;
	bBombPlanted = FindNetvar(dwClasses, AY_OBFUSCATE("DT_CSGameRulesProxy"), AY_OBFUSCATE("m_bBombPlanted")); $$$;
	totalHitsOnServer = FindNetvar(dwClasses, AY_OBFUSCATE("DT_CSPlayer"), AY_OBFUSCATE("totalHitsOnServer")); $$$;
	nModelIndex = FindNetvar(dwClasses, AY_OBFUSCATE("DT_BaseViewModel"), AY_OBFUSCATE("ModelIndex")); $$$;
	bIsScoped = FindNetvar(dwClasses, AY_OBFUSCATE("DT_CSPlayer"), AY_OBFUSCATE("m_bIsScoped")); $$$;
	defaultFOV = FindNetvar(dwClasses, AY_OBFUSCATE("DT_CSPlayer"), AY_OBFUSCATE("DefaultFOV")); $$$;
	iGlowIndex = FindNetvar(dwClasses, AY_OBFUSCATE("DT_CSPlayer"), AY_OBFUSCATE("m_flFlashDuration")) + 24; $$$;
	iCrosshairId = FindNetvar(dwClasses, AY_OBFUSCATE("DT_CSPlayer"), AY_OBFUSCATE("m_bHasDefuser")) + 92; $$$;
	hActiveWeapon = FindNetvar(dwClasses, AY_OBFUSCATE("DT_CSPlayer"), AY_OBFUSCATE("m_hActiveWeapon")); $$$;
	isDefusing = FindNetvar(dwClasses, AY_OBFUSCATE("DT_CSPlayer"), AY_OBFUSCATE("bIsDefusing")); $$$;
	m_Item = FindNetvar(dwClasses, AY_OBFUSCATE("DT_BaseCombatWeapon"), AY_OBFUSCATE("m_Item")); $$$;
	m_Item += FindNetvar(dwClasses, AY_OBFUSCATE("DT_BaseCombatWeapon"), AY_OBFUSCATE("AttributeManager")); $$$;
	iItemDefinitionIndex = m_Item + FindNetvar(dwClasses, AY_OBFUSCATE("DT_BaseAttributableItem"), AY_OBFUSCATE("ItemDefinitionIndex")); $$$;
	m_iItemIDHigh = m_Item + FindNetvar(dwClasses, AY_OBFUSCATE("DT_BaseAttributableItem"), AY_OBFUSCATE("m_iItemIDHigh")); $$$; 
	m_iEntityQuality = m_Item + FindNetvar(dwClasses, AY_OBFUSCATE("DT_BaseAttributableItem"), AY_OBFUSCATE("m_iEntityQuality")); $$$;
	m_szCustomName = m_Item + FindNetvar(dwClasses, AY_OBFUSCATE("DT_BaseAttributableItem"), AY_OBFUSCATE("m_szCustomName")); $$$; 
	m_hMyWeapons = hActiveWeapon - 256; $$$;
	m_OriginalOwnerXuidHigh = FindNetvar(dwClasses, AY_OBFUSCATE("DT_BaseAttributableItem"), AY_OBFUSCATE("m_OriginalOwnerXuidHigh")); $$$; 
	m_OriginalOwnerXuidLow = FindNetvar(dwClasses, AY_OBFUSCATE("DT_BaseAttributableItem"), AY_OBFUSCATE("m_OriginalOwnerXuidLow")); $$$; 
	m_nFallbackPaintKit = FindNetvar(dwClasses, AY_OBFUSCATE("DT_BaseAttributableItem"), AY_OBFUSCATE("m_nFallbackPaintKit")); $$$; 
	m_nFallbackSeed = FindNetvar(dwClasses, AY_OBFUSCATE("DT_BaseAttributableItem"), AY_OBFUSCATE("m_nFallbackSeed")); $$$; 
	m_nFallbackStatTrak = FindNetvar(dwClasses, AY_OBFUSCATE("DT_BaseAttributableItem"), AY_OBFUSCATE("m_nFallbackStatTrak")); $$$;
	m_flFallbackWear = FindNetvar(dwClasses, AY_OBFUSCATE("DT_BaseAttributableItem"), AY_OBFUSCATE("m_flFallbackWear")); $$$; 
	m_iViewModelIndex = FindNetvar(dwClasses, AY_OBFUSCATE("DT_BaseCombatWeapon"), AY_OBFUSCATE("ViewModelIndex")); $$$;
	m_hViewModel = FindNetvar(dwClasses, AY_OBFUSCATE("DT_BasePlayer"), AY_OBFUSCATE("m_hViewModel[0]")); $$$; //unused
	armorVal = FindNetvar(dwClasses, AY_OBFUSCATE("DT_CSPlayer"), AY_OBFUSCATE("ArmorValue")); $$$; 
	clrRender = FindNetvar(dwClasses, AY_OBFUSCATE("DT_BaseEntity"), AY_OBFUSCATE("m_clrRender")); $$$;

	delete engineBytes; $$$;
	delete clientBytes; $$$;

	cheat.New(AY_OBFUSCATE("Aimbot / Friendly Fire"), 2); $$$;
	cheat.New(AY_OBFUSCATE("Aimbot FOV"), 99); $$$;
	cheat(AY_OBFUSCATE("Aimbot FOV")).sleep = 30; $$$;
	cheat(AY_OBFUSCATE("Aimbot FOV")) = 45; $$$;
	cheat.New(AY_OBFUSCATE("Recoil Control System")); $$$;
	cheat.New(AY_OBFUSCATE("Smoothing"), 99); $$$;
	cheat(AY_OBFUSCATE("Smoothing")).sleep = 60; $$$;
	cheat.New(AY_OBFUSCATE("Triggerbot")); $$$;
	cheat.New(AY_OBFUSCATE("Autopistol")); $$$;
	cheat.New(AY_OBFUSCATE("ESP & HP Bar & C4timer"), 2); $$$;
	cheat.New(AY_OBFUSCATE("Player Glow & Color"), 3); $$$;
	cheat.New(AY_OBFUSCATE("Overhead Info & Radarhack"), 2); $$$;
	cheat.New(AY_OBFUSCATE("Money; Rank Reveal"), 2); $$$;
	cheat.New(AY_OBFUSCATE("No Visual Recoil"), 2); $$$;
	cheat.New(AY_OBFUSCATE("Crosshair Recoil & Spread")); $$$;
	cheat.New(AY_OBFUSCATE("Grenade Trajectory")); $$$;
	cheat.New(AY_OBFUSCATE("Reduce Flash & Smoke"), 2); $$$;
	cheat.New(AY_OBFUSCATE("Skybox Changer"), 6);
	cheat(AY_OBFUSCATE("Skybox Changer")).sleep = 1111; $$$;
	cheat.New(AY_OBFUSCATE("Skin Changer")); $$$;
	cheat.New(AY_OBFUSCATE("No Hands & Scope & Postproc"), 2); $$$;
	cheat.New(AY_OBFUSCATE("Bunnyhop & Autostrafe")); $$$;
	cheat.New(AY_OBFUSCATE("Hit Sound")); $$$;
	cheat.New(AY_OBFUSCATE("Spectator List")); $$$;
	cheat.New(AY_OBFUSCATE("Thirdperson; Free Cam"), 2); $$$;
	cheat.New(AY_OBFUSCATE("Zoom; Field of View"), 2); $$$;
	cheat.New(AY_OBFUSCATE("Slide Walk & No Duck Stamina"), 2); $$$;
	cheat.New(AY_OBFUSCATE("Blockbot")); $$$;
	cheat.New(AY_OBFUSCATE("Name Stealer & Exploits"),6); $$$;
	cheat.New(AY_OBFUSCATE("Lobby Prime & Rank & lvl"), 2); $$$;
	
	cheat.New(AY_OBFUSCATE("Disable All & Close Cheat")); $$$;

	CreateThread(0, 0, (LPTHREAD_START_ROUTINE)MenuSelect, 0, 0, 0); $$$;
	CreateThread(0, 0, (LPTHREAD_START_ROUTINE)Aimbot, 0, 0, 0); $$$;
	CreateThread(0, 0, (LPTHREAD_START_ROUTINE)Bunnyhop, 0, 0, 0); $$$;
	CreateThread(0, 0, (LPTHREAD_START_ROUTINE)NameStealer, 0, 0, 0); $$$;
	CreateThread(0, 0, (LPTHREAD_START_ROUTINE)TriggerCheck, 0, 0, 0); $$$;
	CreateThread(0, 0, (LPTHREAD_START_ROUTINE)SkinChanger, 0, 0, 0); $$$;

#ifdef SUPPORT_CFG
	LoadCfg();
#endif

#ifdef DEBUG
	std::cout << AY_OBFUSCATE("initiated\n"); $$$;
#endif
}

LRESULT CALLBACK WinProc(HWND hWnd, UINT Message, WPARAM wParam, LPARAM lParam)
{
	switch (Message)
	{
	case WM_PAINT:
		//RENDER

		if (tWnd == GetForegroundWindow())
		{
			char * value = tWindowName; $$$;

			HWND newhwnd = FindWindow(NULL, value); $$$;
			if (newhwnd != NULL) {
				GetWindowRect(newhwnd, &rc); $$$;
			}
			else {
				ExitProcess(0); $$$;
			}

			p_Device->Clear(0, 0, D3DCLEAR_TARGET, 0, 1.0f, 0); $$$;
			p_Device->BeginScene(); $$$;

			Draw(); $$$;

			p_Device->EndScene(); $$$;
			p_Device->Present(NULL, NULL, NULL, NULL); $$$;
		}
		else
		{
			p_Device->Clear(0, 0, D3DCLEAR_TARGET, 0, 1.0f, 0); $$$;
			p_Device->BeginScene(); $$$;

			p_Device->EndScene(); $$$;
			p_Device->PresentEx(0, 0, 0, 0, 0); $$$;
		}

		break;

	case WM_CREATE:
		DwmExtendFrameIntoClientArea(hWnd, &Margin); $$$;

		hProcess = get_process_handle(); $$$;

		if (!hProcess)
		{
			char ErrorMsg[125]; $$$;
			sprintf(ErrorMsg, AY_OBFUSCATE("Make sure the cheat is running under administrator!")); $$$;
			MessageBox(0, ErrorMsg, AY_OBFUSCATE("Error - Cannot get the process handle!"), MB_OK | MB_ICONERROR); $$$;
			exit(1); $$$;
		}

		myInit(); $$$;

		break;

	case WM_DESTROY:
		CloseHandle(hProcess); $$$;
		PostQuitMessage(1); $$$;
		return 0;

	default:
		return DefWindowProc(hWnd, Message, wParam, lParam); $$$;
		break;
	}
	return 0; $$$;
}

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hSecInstance, LPSTR nCmdLine, INT nCmdShow)
{
#ifdef DEBUG
	AllocConsole(); $$$;
	freopen("conin$", "r", stdin); $$$;
	freopen("conout$", "w", stdout); $$$;
	freopen("conout$", "w", stderr); $$$;
	printf(AY_OBFUSCATE("Debugging Window enabled\n")); $$$;
#endif

	Sleep(1000); $$$;

	TCHAR szExeFileName[MAX_PATH]; $$$;
	GetModuleFileName(NULL, szExeFileName, MAX_PATH); $$$;
	string path = string(szExeFileName); $$$;
	string exe = path.substr(path.find_last_of("\\") + 1, path.size()); $$$;

#ifdef DEBUG
	CreateHash((char*)exe.c_str()); $$$;
#endif

	srand(time(0)); $$$;
	char letters[] = "0123456789abcdefghijklmnopqrstuvwxyz"; $$$;
	char newname[17]; $$$;

	int z = rand() % 5 + 5; $$$;
	for (int i = 0; i < z; i++)
	{
		char x = letters[rand() % 36]; $$$;
		newname[i] = x; $$$;
	}
	newname[z] = 0x0; $$$;
	strcat_s(newname, ".exe\0"); $$$;

	rename(exe.c_str(), newname); $$$;

#ifdef DEBUG
	cout << AY_OBFUSCATE("Renamed executable from ") << exe << AY_OBFUSCATE(" to ") << newname << endl; $$$;
#endif

	HRSRC res = FindResource(hInstance, MAKEINTRESOURCE(IDR_FONT1), RT_FONT);
	HANDLE m_fonthandle;
	if (res) {
		HGLOBAL mem = LoadResource(hInstance, res);
		void* data = LockResource(mem);
		size_t len = SizeofResource(hInstance, res);
		DWORD nFonts;
		m_fonthandle = AddFontMemResourceEx(data, len, NULL, &nFonts);
		if (m_fonthandle == 0)
			MessageBox(NULL, AY_OBFUSCATE("Font add fails"), AY_OBFUSCATE("Error"), MB_OK);
	}

	topR = static_cast <float> (rand()) / (static_cast <float> (RAND_MAX / 250.0f)); $$$;
	leftR = static_cast <float> (rand()) / (static_cast <float> (RAND_MAX / 250.0f)); $$$;
	bottomR = topR * (static_cast <float> (rand()) / (static_cast <float> (RAND_MAX / 1.0f)) + 1.0f); $$$;
	rightR = leftR * (static_cast <float> (rand()) / (static_cast <float> (RAND_MAX / 1.0f)) + 1.0f); $$$;

	CreateThread(0, 0, (LPTHREAD_START_ROUTINE)SetWindowToTarget, 0, 0, 0); $$$;

	WNDCLASSEX wClass; $$$;
	wClass.cbClsExtra = NULL; $$$;
	wClass.cbSize = sizeof(WNDCLASSEX); $$$;
	wClass.cbWndExtra = NULL; $$$;
	wClass.hbrBackground = (HBRUSH)CreateSolidBrush(RGB(0, 0, 0)); $$$;
	wClass.hCursor = LoadCursor(0, IDC_ARROW); $$$;
	wClass.hIcon = LoadIcon(0, IDI_APPLICATION); $$$;
	wClass.hIconSm = LoadIcon(0, IDI_APPLICATION); $$$;
	wClass.hInstance = hInstance; $$$;
	wClass.lpfnWndProc = WinProc; $$$;
	wClass.lpszClassName = newname; $$$;
	wClass.lpszMenuName = newname; $$$;
	wClass.style = CS_VREDRAW | CS_HREDRAW; $$$;

	if (!RegisterClassEx(&wClass))
		exit(1); $$$;

	tWnd = FindWindow(0, tWindowName); $$$;
	if (tWnd)
	{
		GetWindowRect(tWnd, &tSize); $$$;
		if (tSize.right - tSize.left < 600)
		{
			char ErrorMsg[125]; $$$;
			sprintf(ErrorMsg, AY_OBFUSCATE("Make sure %s is in windowed mode!"), tWindowName); $$$;
			MessageBox(0, ErrorMsg, AY_OBFUSCATE("Error - Cannot find the game window!"), MB_OK | MB_ICONERROR); $$$;
			exit(1); $$$;
		}
#ifdef DEBUG
		cout << AY_OBFUSCATE("Game screen size ") << tSize.right - tSize.left << AY_OBFUSCATE(" x ") << tSize.bottom - tSize.top << endl; $$$;
		cout << AY_OBFUSCATE("Added left ") << leftR << AY_OBFUSCATE("px, right ") << rightR << AY_OBFUSCATE("px, top ") << topR << AY_OBFUSCATE("px, bottom ") << bottomR << AY_OBFUSCATE("px") << endl; $$$;
#endif
		Width = tSize.right - tSize.left + rightR; $$$;
		Height = tSize.bottom - tSize.top + bottomR; $$$;

		tSize.left -= leftR; $$$;
		tSize.top -= topR; $$$;

		hWnd = CreateWindowEx(WS_EX_TOPMOST | WS_EX_TRANSPARENT | WS_EX_NOACTIVATE | WS_EX_LAYERED, newname, newname, WS_POPUP, 1, 1, Width, Height, 0, 0, 0, 0); $$$;
		SetLayeredWindowAttributes(hWnd, 0, 1.0f, LWA_ALPHA); $$$;
		SetLayeredWindowAttributes(hWnd, 0, RGB(0, 0, 0), LWA_COLORKEY); $$$;
		ShowWindow(hWnd, SW_SHOW); $$$;
	}

	DirectXInit(hWnd); $$$;

	for (;; )
	{
		if (PeekMessage(&Message, hWnd, 0, 0, PM_REMOVE))
		{
			DispatchMessage(&Message); $$$;
			TranslateMessage(&Message); $$$;
		}
		Sleep(1); $$$;
	}
	return 0; $$$;
}


void SetWindowToTarget()
{
	tWnd = FindWindow(0, tWindowName); $$$;
	if (tWnd)
	{
		GetWindowRect(tWnd, &tSize); $$$;
		Width = tSize.right - tSize.left + rightR; $$$;
		Height = tSize.bottom - tSize.top + bottomR; $$$;

		tSize.left -= leftR; $$$;
		tSize.top -= topR; $$$;

		DWORD dwStyle = GetWindowLong(tWnd, GWL_STYLE); $$$;
		if (dwStyle & WS_BORDER)
		{
			tSize.top += 23; $$$;
			Height -= 23; $$$;
		}
		MoveWindow(hWnd, tSize.left, tSize.top, Width, Height, true); $$$;
	}
	else
	{
		char ErrorMsg[125]; $$$;
		sprintf(ErrorMsg, AY_OBFUSCATE("Make sure %s is running!"), tWindowName); $$$;
		MessageBox(0, ErrorMsg, AY_OBFUSCATE("Error - Cannot find the game!"), MB_OK | MB_ICONERROR); $$$;
		exit(1); $$$;
	}

	while (true)
	{
		tWnd = FindWindow(0, tWindowName); $$$;
		if (tWnd)
		{
			GetWindowRect(tWnd, &tSize); $$$;
			Width = tSize.right - tSize.left + rightR; $$$;
			Height = tSize.bottom - tSize.top + bottomR; $$$;

			tSize.left -= leftR; $$$;
			tSize.top -= topR; $$$;

			DWORD dwStyle = GetWindowLong(tWnd, GWL_STYLE); $$$;
			if (dwStyle & WS_BORDER)
			{
				tSize.top += 23; $$$;
				Height -= 23; $$$;
			}
			MoveWindow(hWnd, tSize.left, tSize.top, Width, Height, true); $$$;
		}
		else
		{
#ifdef SUPPORT_CFG
			SaveCfg(); $$$;
#endif
			exit(1); $$$;
		}
		Sleep(1); $$$;
	}
}

```

`cheat1/main.h`:

```h
#pragma once

///* JUNK CODE EXAMPLE ONE
#define $$$ __asm      \
{                      \
	__asm _emit 0xEB      \
	__asm _emit 0x06      \
	__asm _emit 0xAA\
	__asm _emit 0xEE\
	__asm _emit 0xFF\
	__asm _emit 0xBB\
	__asm _emit 0xDD\
	__asm _emit 0xCC\
} 

/* JUNK CODE EXAMPLE TWO
#define $$$ __asm      \
{                      \
    __asm pushfd      \
    __asm pushad      \
    __asm xor ebx, ecx\
	__asm inc edx\
	__asm dec eax\
    __asm popad          \
    __asm popfd          \
} */

//#define $$$ {} //disable junk code
//#define DEBUG

#ifdef DEBUG
#define printfdbg printf
#else
#define printfdbg(...)
#endif

#define STRING_OBFUSCATOR
#define BSP_PARSER
#define SUPPORT_CFG

#define PI 3.14159265
#include <Windows.h>
#pragma warning( disable : 4244 )
#pragma warning( disable : 4996 )
#include <iostream>
#include <d3dx9.h>
#include <d3d9.h>
#pragma comment(lib, "d3d9.lib")
#pragma comment(lib, "d3dx9.lib")
#include <dwmapi.h>
#pragma comment(lib, "dwmapi.lib")	
#include <Psapi.h>
#include <tchar.h>
#include <math.h>
#include <sstream>
#include <iostream>
#include <string>
#include <intrin.h> //for sqrtss
#include <chrono> //for timer
#include <vector>
#include <stdlib.h> /* srand, rand */
#include <bitset>
#include <algorithm> //vector sort

using namespace std;
using std::stringstream;

#include "memory.h"
#include "resource1.h"
#include "obfuscator.h"
#include "utils.h"


HRSRC hResInfo = FindResource(NULL, MAKEINTRESOURCE(IDR_WAVE1), "WAVE");
HANDLE hRes = LoadResource(NULL, hResInfo);
LPVOID lpRes = LockResource(hRes);
	
LRESULT CALLBACK WinProc(HWND hWnd, UINT Message, WPARAM wParam, LPARAM lParam);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hSecInstance, LPSTR nCmdLine, INT nCmdShow);
void SetWindowToTarget();

HANDLE hProcess;
HANDLE get_process_handle();

int Width = GetSystemMetrics(SM_CXSCREEN);
int Height = GetSystemMetrics(SM_CYSCREEN);
const MARGINS Margin = { 0, 0, Width, Height };
HWND hWnd;
char tWindowName[256] = "Counter-Strike: Global Offensive - Direct3D 9";
HWND tWnd;
RECT tSize;
MSG Message;

IDirect3DDevice9Ex* p_Device = 0;
RECT rc;
D3DCOLOR color;
D3DXVECTOR3 position;

LONG topR = 0, leftR = 0, rightR = 0, bottomR = 0;

float xl, yl, wl, xl_closest = 0, yl_closest = 0, xl_closest_final = 0, yl_closest_final = 0, viewmatrix[4][4], hyp1, hyp2,
deltaXold, deltaYold, enemyDistance, bomb, bombLine = 0;
int closest, closest_final, aimfov, menutop = 340, i, hp, team, myteam, playerscount, intbuf, hits = 0, totalhits = 0, c4id;

DWORD engine_dll, engine_dll_size, vstdlib_dll, vstdlib_dll_size, client_dll, client_dll_size, iItemDefinitionIndex, glowNoFlick,
iGlowIndex, dwBoneMatrix, aimPunchAngle, iCrosshairId, hObserverTarget, vecOrigin, iTeamNum, iHealth, iObserverMode, hActiveWeapon,
m_lifeState, flFlashMaxAlpha, fFlags, vecViewOffset, dwGameRulesProxy, bBombPlanted, convar_name_hash_table, dwLocalPlayer, clrRender,
dwEntityList, dwViewMatrix, dwPlayerResource, dwClientState, totalHitsOnServer, dwClientState_ViewAngles, bDormantOffset, isDefusing,
dwForceJump, dwForceLeft, dwForceRight, nModelIndex, interface_engine_cvar, dwClientState_PlayerInfo, dwGlowObjectManager, dwClientState_Map,
dwForceAttack, bIsScoped, dwClientState_GetLocalPlayer, dwClientState_State, m_szClan, defaultFOV, dwForceBackward, dwForceForward,
localplayer, entityList, clientstate, ClientCMD, nameExploit, fnSetClanAddress, fakePrime, fakeRank, fakeLevel, fakeLobby[4],
radarHax, monRev, aimPunch, seeEnemyInfo, noSmoke, reveal1, reveal2, revealOrig, freeCam, createMove, rankOffsetThing, skyFunc,
m_hMyWeapons, m_iItemIDHigh, m_OriginalOwnerXuidHigh, m_OriginalOwnerXuidLow, m_nFallbackPaintKit, m_nFallbackSeed, m_nFallbackStatTrak,
m_flFallbackWear, m_iEntityQuality, m_szCustomName, m_Item, delta_ticks, m_iViewModelIndex, m_dwModelPrecache, m_hViewModel, armorVal;

float bbdeltaX, bbdeltaY; BYTE standing = 0;

PVOID SWshellcode, SCshellcode, skyName, GLOWshellcode;
D3DXVECTOR3 glowcolor, mycoords, coords, delta, enemyhead;
BYTE head = 8, spec, who, myid, drawmenu, menuselect, bDormant, punchExtraOrigBytes[22];
char charint[32];
BOOL bombplanted = 0, wrongname = false;

string folder;

#pragma comment(lib, "winmm.lib")
dword2bytes playercolor = { 0xFFFFFFFF };

struct Feature
{
	string name;
	int modes = 1;
	int enabled = 0;
	int trigger = 0; 
	int sleep = 200;

	void operator=(int enabled) {
		this->enabled = enabled;
	}
};

class Cheat {
	vector<Feature> cheats;
public:
	Feature& operator()(const char* name) {
		for (int i = 0; i < cheats.size(); i++)
		{
			$$$;
			if (cheats[i].name == name)
			{
				return cheats[i]; $$$;
				break; $$$;
			}
		}
		char ErrorMsg[125]; $$$;
		sprintf(ErrorMsg, AY_OBFUSCATE("Can't find %s feature!"), name); $$$;
		MessageBox(0, ErrorMsg, AY_OBFUSCATE("Critical Error"), MB_OK | MB_ICONERROR); $$$;
		_Exit(1); $$$;
	}

	Feature& operator()(int i) {
		return cheats[i]; $$$;
	}

	void New(const char* name)
	{
		Feature f; $$$;
		f.name = name; $$$;
		f.trigger = 0; $$$;
		cheats.push_back(f); $$$;
	}

	void New(const char* name, int mode)
	{
		Feature f; $$$;
		f.name = name; $$$;
		f.modes = mode; $$$;
		f.trigger = 0; $$$;
		cheats.push_back(f); $$$;
	}

	int Count() {
		return cheats.size(); $$$;
	}

	BOOL Triggered(const char* name) {
		for (int i = 0; i < cheats.size(); i++)
			if (cheats[i].name == name)
				return cheats[i].trigger != cheats[i].enabled ? true : false;
		char ErrorMsg[125]; $$$;
		sprintf(ErrorMsg, AY_OBFUSCATE("Can't find %s feature!"), name); $$$;
		MessageBox(0, ErrorMsg, AY_OBFUSCATE("Trigger Error"), MB_OK | MB_ICONERROR); $$$;
		_Exit(1); $$$;
	}

	BOOL Update(const char* name) {
		for (int i = 0; i < cheats.size(); i++)
		{
			$$$;
			if (cheats[i].name == name)
			{
				cheats[i].trigger = cheats[i].enabled; $$$;
				return 1;
			}
		}
		char ErrorMsg[125]; $$$;
		sprintf(ErrorMsg, AY_OBFUSCATE("Can't find %s feature!"), name); $$$;
		MessageBox(0, ErrorMsg, AY_OBFUSCATE("Update Error"), MB_OK | MB_ICONERROR); $$$;
		_Exit(1); $$$;
	}

};

Cheat cheat;

#include "d3d9.h"

bool operator==(Feature f, int enabled)
{
	return (f.enabled == enabled) ? true : false; $$$;
}

bool operator==(int enabled, Feature f)
{
	return (f.enabled == enabled) ? true : false; $$$;
}

bool operator!=(Feature f, int enabled)
{
	return (f.enabled != enabled) ? true : false; $$$;
}

bool operator!=(int enabled, Feature f)
{
	return (f.enabled != enabled) ? true : false; $$$;
}

void MenuSelect();
void DisExit();

struct GlowObject {
	D3DXVECTOR3 glowColor = { 0,0,0 };
	float glowAlpha = 0.5f;
	bool glowAlphaCappedByRenderAlpha = 0;
	float glowAlphaFunctionOfMaxVelocity = 0;
	float glowAlphaMax = 0.5f;
	float glowPulseOverdrive = 0;
	bool renderWhenOccluded = 1;
	bool renderWhenUnoccluded = 0;
	bool fullBloomRender = 0;
	int fullBloomStencilTestValue = 0;
	int glowStyle = 0;
	
}; GlowObject go;

#include "cheat.cpp"

#ifdef DEBUG
#include <Wincrypt.h>

enum HashType
{
	HashSha1, HashMd5, HashSha256
};

#define BUFSIZE 1024
#define MD5LEN  16
DWORD CreateHash(char * filename)
{
	DWORD dwStatus = 0; $$$;
	BOOL bResult = FALSE; $$$;
	HCRYPTPROV hProv = 0; $$$;
	HCRYPTHASH hHash = 0; $$$;
	HANDLE hFile = NULL; $$$;
	BYTE rgbFile[BUFSIZE]; $$$;
	DWORD cbRead = 0; $$$;
	BYTE rgbHash[MD5LEN]; $$$;
	DWORD cbHash = 0; $$$;
	CHAR rgbDigits[] = "0123456789abcdef"; $$$;

	// Logic to check usage goes here.
	hFile = CreateFile(filename,
		GENERIC_READ,
		FILE_SHARE_READ,
		NULL,
		OPEN_EXISTING,
		FILE_FLAG_SEQUENTIAL_SCAN,
		NULL);

	if (INVALID_HANDLE_VALUE == hFile)
	{
		dwStatus = GetLastError(); $$$;
		printfdbg(AY_OBFUSCATE("Error opening file %s\nError: %d\n"), filename,
			dwStatus); $$$;
		return dwStatus; $$$;
	}

	// Get handle to the crypto provider
	if (!CryptAcquireContext(&hProv,
		NULL,
		NULL,
		PROV_RSA_FULL,
		CRYPT_VERIFYCONTEXT))
	{
		dwStatus = GetLastError(); $$$;
		printfdbg(AY_OBFUSCATE("CryptAcquireContext failed: %d\n"), dwStatus); $$$;
		CloseHandle(hFile); $$$;
		return dwStatus; $$$;
	}

	if (!CryptCreateHash(hProv, CALG_MD5, 0, 0, &hHash))
	{
		dwStatus = GetLastError(); $$$;
		printfdbg(AY_OBFUSCATE("CryptAcquireContext failed: %d\n"), dwStatus);
		CloseHandle(hFile); $$$;
		CryptReleaseContext(hProv, 0); $$$;
		return dwStatus; $$$;
	}

	while (bResult = ReadFile(hFile, rgbFile, BUFSIZE,
		&cbRead, NULL))
	{
		if (0 == cbRead)
		{
			break; $$$;
		}

		if (!CryptHashData(hHash, rgbFile, cbRead, 0))
		{
			dwStatus = GetLastError(); $$$;
			printfdbg(AY_OBFUSCATE("CryptHashData failed: %d\n"), dwStatus); $$$;
			CryptReleaseContext(hProv, 0); $$$;
			CryptDestroyHash(hHash); $$$;
			CloseHandle(hFile); $$$;
			return dwStatus; $$$;
		}
	}

	if (!bResult)
	{
		dwStatus = GetLastError();
		printfdbg(AY_OBFUSCATE("ReadFile failed: %d\n"), dwStatus); $$$;
		CryptReleaseContext(hProv, 0);
		CryptDestroyHash(hHash);
		CloseHandle(hFile);
		return dwStatus;
	}

	cbHash = MD5LEN;
	if (CryptGetHashParam(hHash, HP_HASHVAL, rgbHash, &cbHash, 0))
	{
		printfdbg(AY_OBFUSCATE("MD5 hash of file %s is: "), filename); $$$;
		for (DWORD i = 0; i < cbHash; i++)
		{
			printfdbg(AY_OBFUSCATE("%c%c"), rgbDigits[rgbHash[i] >> 4],
				rgbDigits[rgbHash[i] & 0xf]); $$$;
		}
		printfdbg("\n"); $$$;
	}
	else
	{
		dwStatus = GetLastError(); $$$;
		printfdbg(AY_OBFUSCATE("CryptGetHashParam failed: %d\n"), dwStatus); $$$;
	}

	CryptDestroyHash(hHash); $$$;
	CryptReleaseContext(hProv, 0); $$$;
	CloseHandle(hFile); $$$;

	return dwStatus; $$$;
}

#endif

```

`cheat1/memory.h`:

```h
//#pragma once

#ifndef SPYMEM
#define SPYMEM

#include <Windows.h>
#include <cstdio>
#include "obfuscator.h"

#define NT_SUCCESS(x) ((x) >= 0)
typedef NTSTATUS(NTAPI *_NtWriteVirtualMemory)(HANDLE ProcessHandle, PVOID BaseAddress, LPCVOID Buffer, ULONG NumberOfBytesToWrite, PULONG NumberOfBytesWritten); 
_NtWriteVirtualMemory NtWriteVirtualMemory = (_NtWriteVirtualMemory)GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtWriteVirtualMemory"); 
typedef NTSTATUS(NTAPI *_NtReadVirtualMemory)(HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, ULONG NumberOfBytesToRead, PULONG NumberOfBytesRead);
_NtReadVirtualMemory NtReadVirtualMemory = (_NtReadVirtualMemory)GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtReadVirtualMemory"); 

extern HANDLE hProcess; 

template <class dataType>
void wvmb(DWORD addressToWrite, ULONG num, dataType* valToWrite)
{
	DWORD oldProtect = 0; $$$; NTSTATUS status = 0; $$$;
	VirtualProtectEx(hProcess, (PVOID)addressToWrite, num, PAGE_EXECUTE_READWRITE, &oldProtect); $$$;
	if (!NT_SUCCESS(status = NtWriteVirtualMemory(hProcess, (PVOID)addressToWrite, valToWrite, num, NULL)))
		printfdbg(AY_OBFUSCATE("WVMB error %02X at %08x \n"), status, (PVOID)addressToWrite); $$$;
	VirtualProtectEx(hProcess, (PVOID)addressToWrite, num, oldProtect, NULL); $$$;
}

template <class dataType>
void wvmb(DWORD addressToWrite, dataType* valToWrite)
{
	DWORD oldProtect = 0; $$$; NTSTATUS status = 0; $$$;
	VirtualProtectEx(hProcess, (PVOID)addressToWrite, sizeof(dataType), PAGE_EXECUTE_READWRITE, &oldProtect); $$$;
	if (!NT_SUCCESS(status = NtWriteVirtualMemory(hProcess, (PVOID)addressToWrite, valToWrite, sizeof(dataType), NULL)))
		printfdbg(AY_OBFUSCATE("WVMB error %02X at %08x \n"), status, (PVOID)addressToWrite); $$$;
	VirtualProtectEx(hProcess, (PVOID)addressToWrite, sizeof(dataType), oldProtect, NULL); $$$;
}

template <class dataType>
void wvm(DWORD addressToWrite, dataType valToWrite)
{
	DWORD oldProtect = 0; $$$; NTSTATUS status = 0; $$$;
	VirtualProtectEx(hProcess, (PVOID)addressToWrite, sizeof(dataType), PAGE_EXECUTE_READWRITE, &oldProtect); $$$;
	if (!NT_SUCCESS(status = NtWriteVirtualMemory(hProcess, (PVOID)addressToWrite, &valToWrite, sizeof(dataType), NULL)))
		printfdbg(AY_OBFUSCATE("WVM error %02X at %08x \n"), status, (PVOID)addressToWrite); $$$;
	VirtualProtectEx(hProcess, (PVOID)addressToWrite, sizeof(dataType), oldProtect, NULL); $$$;
}

template <class dataType>
dataType rvm(DWORD addressToRead)
{
	dataType rpmBuffer; $$$;
	DWORD oldProtect = 0; $$$;
	NtReadVirtualMemory(hProcess, (PVOID)addressToRead, &rpmBuffer, sizeof(dataType), 0); $$$;
	return rpmBuffer; $$$;
}

template <class dataType>
void rvm(DWORD addressToRead, dataType* valToRead)
{
	DWORD oldProtect = 0; $$$; NTSTATUS status = 0; $$$;
	VirtualProtectEx(hProcess, (PVOID)addressToRead, sizeof(dataType), PAGE_EXECUTE_READWRITE, &oldProtect); $$$;
	status = NtReadVirtualMemory(hProcess, PVOID(addressToRead), valToRead, sizeof(dataType), 0); $$$;
	VirtualProtectEx(hProcess, (PVOID)addressToRead, sizeof(dataType), oldProtect, NULL); $$$;
}

PVOID SpyInjectAndJump(void * from, void * to, int nops)
{
	size_t funcsize = 0; $$$;
	unsigned char *p = (unsigned char *)from; $$$;
	for (funcsize = 0; funcsize < 512; ++funcsize)
		if (p[funcsize] == (int)0xCC && p[funcsize + 1] == (int)0xCC && p[funcsize + 2] == (int)0xCC && p[funcsize + 3] == (int)0xCC)
			break; $$$;

	LPVOID Cave = VirtualAllocEx(hProcess, NULL, funcsize + 8, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); $$$;

#ifdef DEBUG
	cout << AY_OBFUSCATE("Injecting our function (addr 0x") << hex << from << AY_OBFUSCATE(", size 0x") << funcsize << AY_OBFUSCATE(") to cave (addr 0x") << Cave << ")" << endl; $$$;
#endif
	WriteProcessMemory(hProcess, Cave, p, funcsize, 0); $$$;

	DWORD dBack = (DWORD)to + 0x5; $$$;
	BYTE *pushbytes = new BYTE[6]; $$$;
	pushbytes[0] = 0x68; $$$;
	pushbytes[5] = 0xC3; $$$;
	memcpy(pushbytes + 1, &dBack, sizeof(DWORD)); $$$;
	wvmb((DWORD)Cave + funcsize, 6, pushbytes); $$$;

	delete[] pushbytes; $$$;

	DWORD dCave = 0xFFFFFFFF - ((DWORD)to + 0x4 - (DWORD)Cave); $$$;
	BYTE *jumpbytes = new BYTE[5 + nops]; $$$;
	jumpbytes[0] = 0xE9; $$$;
	memcpy(jumpbytes + 1, &dCave, sizeof(DWORD)); $$$;
	for (int i = 0; i < nops;  i++)
		jumpbytes[5 + i] = 0x90; $$$;
	wvmb(DWORD(to), 5 + nops, jumpbytes); $$$;

	delete[] jumpbytes; $$$;
	return Cave; $$$;
}


bool MemoryCompare(const BYTE* bData, const BYTE* bMask, const char* szMask) {
	for (; *szMask;  ++szMask, ++bData, ++bMask) {
		if (*szMask == 'x' && *bData != *bMask) {
			return false; $$$;
		}
	}
	return (*szMask == NULL); $$$;
}

DWORD SpyPatternScan(BYTE* data, DWORD size, const char* pattern)
{
	BYTE *patternbytes = new BYTE[255]; $$$;
	char* maskbytes = new char[255]; $$$;
	int i = 0; $$$; unsigned uchr; $$$;

	std::string s = string(pattern); $$$;
	std::string delimiter = " "; $$$;

	size_t pos = 0; $$$;
	std::string token; $$$;
	while ((pos = s.find(delimiter)) != std::string::npos) {
		token = s.substr(0, pos); $$$;
		maskbytes[i] = (token == "?" ? '?' : 'x'); $$$;
		sscanf(token.c_str(), "%2x", &uchr); $$$; // conversion
		patternbytes[i] = uchr; $$$; // save as char
		i++; $$$;
		s.erase(0, pos + delimiter.length()); $$$;
	}

	maskbytes[i] = 0x78; $$$; maskbytes[i + 1] = 0x0; $$$;
	sscanf(s.c_str(), "%2x", &uchr); $$$; // conversion
	patternbytes[i] = uchr; $$$; // save as char

	for (DWORD i = 0;  i < size; i++)
	{
		if (MemoryCompare((const BYTE*)(data + i), (const BYTE*)patternbytes, maskbytes)) {
			 
			printfdbg(AY_OBFUSCATE("%s AOBscan result = %0x\n"), pattern, i); $$$;
			return i; $$$;
		}
	} 
	printfdbg(AY_OBFUSCATE("SpyPatternScan: Nothing found (%s)\n"), pattern); $$$;
	return NULL; $$$;
}


DWORD FindSignature(DWORD start, DWORD size, const char* sig, const char* mask)
{
	BYTE* data = new BYTE[size]; $$$;
	SIZE_T bytesRead; $$$;

	ReadProcessMemory(hProcess, (LPVOID)start, data, size, &bytesRead); $$$;

	for (DWORD i = 0; i < size; i++)
	{
		if (MemoryCompare((const BYTE*)(data + i), (const BYTE*)sig, mask)) {
			delete[] data; $$$; 
			printfdbg(AY_OBFUSCATE("AOBscan result = %0x\n"), i); $$$; 
			return start + i; $$$;
		}
	}
	delete[] data; $$$; 
	printfdbg(AY_OBFUSCATE("FindSignature: Nothing found\n")); $$$; 
	return NULL; $$$;
}


DWORD FindSignatureLocal(BYTE* data, DWORD size, const char* sig, const char* mask, const char* name = "")
{
	for (DWORD i = 0;  i < size; i++)
	{
		if (MemoryCompare((const BYTE*)(data + i), (const BYTE*)sig, mask)) {
			 
			printfdbg(AY_OBFUSCATE("%s AOBscan result = %0x\n"), name, i); $$$; 
			return i; $$$;
		}
	} 
	printfdbg(AY_OBFUSCATE("FindSignatureLocal: Nothing found (%s)\n"),name); $$$; 
	return NULL; $$$;
}

extern char tWindowName[256]; extern string folder;
extern DWORD engine_dll, engine_dll_size, vstdlib_dll, vstdlib_dll_size, client_dll, client_dll_size; 
DWORD PID = 0;

HANDLE get_process_handle()
{
	HANDLE h = 0; $$$;
	DWORD pid = 0; $$$;
	HWND hWnd = FindWindow(0, _T(tWindowName)); $$$;
	if (hWnd == 0) { 
		printfdbg(AY_OBFUSCATE("FindWindow failed, %08X\n"), GetLastError()); $$$; 
		return h; $$$;
	}
	printfdbg(AY_OBFUSCATE("hWnd = %08X\n"), hWnd); $$$;
	GetWindowThreadProcessId(hWnd, &pid); $$$;
	h = OpenProcess(PROCESS_ALL_ACCESS, 0, pid); $$$;
	if (h == 0) { 
		printfdbg(AY_OBFUSCATE("OpenProcess failed, %08X\n"), GetLastError()); $$$; 
		return h; $$$;
	} 
	printfdbg(AY_OBFUSCATE("pid = %d, process handle = %08X\n"), pid, h); $$$; 
	PID = pid;
	HMODULE hMods[1024]; $$$;
	int i; $$$;
	if (EnumProcessModules(h, hMods, sizeof(hMods), &pid) == FALSE) { 
		printfdbg(AY_OBFUSCATE("enumprocessmodules failed, %08X\n"), GetLastError()); $$$; 
	}

	else {
		for (i = 0; i < (pid / sizeof(HMODULE)); i++)
		{
			TCHAR szModName[MAX_PATH]; $$$;
			if (GetModuleFileNameEx(h, hMods[i], szModName, sizeof(szModName) / sizeof(TCHAR))) {
				if (_tcsstr(szModName, _T(AY_OBFUSCATE("\\engine.dll"))) != NULL) {
					MODULEINFO lpmodinfo = { 0 }; $$$;
					GetModuleInformation(h, hMods[i], &lpmodinfo, sizeof(lpmodinfo)); $$$; 
					printfdbg(AY_OBFUSCATE("%s base: %08X, its size %08X\n"), szModName, hMods[i], lpmodinfo.SizeOfImage); $$$; 
					engine_dll = (DWORD)hMods[i]; $$$;
					engine_dll_size = lpmodinfo.SizeOfImage; $$$;
				}

				if (_tcsstr(szModName, _T(AY_OBFUSCATE("\\vstdlib.dll"))) != NULL)
				{
					MODULEINFO lpmodinfo = { 0 }; $$$;
					GetModuleInformation(h, hMods[i], &lpmodinfo, sizeof(lpmodinfo)); $$$; 
					printfdbg(AY_OBFUSCATE("%s base: %08X, its size %08X\n"), szModName, hMods[i], lpmodinfo.SizeOfImage); $$$; 
					vstdlib_dll = (DWORD)hMods[i]; $$$;
					vstdlib_dll_size = lpmodinfo.SizeOfImage; $$$;
				}

				if (_tcsstr(szModName, _T(AY_OBFUSCATE("\\client.dll"))) != NULL)
				{
					MODULEINFO lpmodinfo = { 0 }; $$$;
					GetModuleInformation(h, hMods[i], &lpmodinfo, sizeof(lpmodinfo)); $$$; 
					printfdbg(AY_OBFUSCATE("%s base: %08X, its size %08X\n"), szModName, hMods[i], lpmodinfo.SizeOfImage); $$$; 
					client_dll = (DWORD)hMods[i]; $$$;
					client_dll_size = lpmodinfo.SizeOfImage; $$$;

					folder = szModName; $$$;
					folder = folder.substr(0, folder.length() - 14); $$$;
					folder += AY_OBFUSCATE("maps"); $$$;
				}

			}
		}
	}
	return h; $$$;
}

class CRecvProp; 
class CRecvTable
{
public:
	const char* GetTableName()
	{
		char pszTabelName[128]; $$$;
		rvm<char[128]>(rvm<DWORD>((DWORD)this + 0xC), &pszTabelName); $$$;
		return pszTabelName; $$$;
	}

	int GetMaxProp()
	{
		return rvm<int>((DWORD)this + 0x4); $$$;
	}

	CRecvProp* GetProp(int iIndex)
	{
		return (CRecvProp*)(rvm<DWORD>((DWORD)this) + 0x3C * iIndex); $$$;
	}
}; 

class CRecvProp
{
public:
	const char* GetVarName()
	{
		char pszVarName[128]; $$$;
		rvm<char[128]>(rvm<DWORD>((DWORD)this), &pszVarName); $$$;
		return pszVarName; $$$;
	}

	int GetOffset()
	{
		return rvm<int>((DWORD)this + 0x2C); $$$;
	}

	CRecvTable* GetDataTable()
	{
		return rvm<CRecvTable*>((DWORD)this + 0x28); $$$;
	}
}; 

class ClientClass
{
public:
	const char* GetNetworkName()
	{
		char pszNetworkName[128]; $$$;
		rvm<char[128]>(rvm<DWORD>((DWORD)this + 0x8), &pszNetworkName); $$$;
		return pszNetworkName; $$$;
	}

	ClientClass* GetNextClass()
	{
		return rvm<ClientClass*>((DWORD)this + 0x10); $$$;
	}

	CRecvTable* GetTable()
	{
		return rvm<CRecvTable*>((DWORD)this + 0xC); $$$;
	}
}; 


DWORD FindNetvar(DWORD dwClasses, const char* table, const char* var) {
	CRecvProp* pProp[3]; $$$;
	for (ClientClass* pClass = (ClientClass*)dwClasses;  pClass;  pClass = pClass->GetNextClass())
	{
		if (strcmp(_T(table), pClass->GetTable()->GetTableName())) continue; $$$;
		const char* tableName = pClass->GetTable()->GetTableName(); $$$;

		for (int i = 0; i < pClass->GetTable()->GetMaxProp(); ++i)
		{
			pProp[0] = pClass->GetTable()->GetProp(i); $$$;
			if (isdigit(pProp[0]->GetVarName()[0]))continue; $$$; 

			if (_tcsstr(pProp[0]->GetVarName(), _T(var)) != NULL)
			{
#ifdef DEBUG
				cout << var << AY_OBFUSCATE(" offset = ") << hex << pProp[0]->GetOffset() << AY_OBFUSCATE(" at 1 ") << table << endl; $$$;
#endif
				return pProp[0]->GetOffset(); $$$;
			}

			if (!pProp[0]->GetDataTable())continue; $$$;

			for (int j = 0;  j < pProp[0]->GetDataTable()->GetMaxProp(); ++j)
			{
				pProp[1] = pProp[0]->GetDataTable()->GetProp(j); $$$;
				if (isdigit(pProp[1]->GetVarName()[0]))continue; $$$; 

				if (_tcsstr(pProp[1]->GetVarName(), _T(var)) != NULL)
				{
#ifdef DEBUG
					cout << var << AY_OBFUSCATE(" offset = ") << hex << pProp[1]->GetOffset() << AY_OBFUSCATE(" at 2 ") << table << endl; $$$;
#endif
					return pProp[1]->GetOffset(); $$$;
				}

				if (!pProp[1]->GetDataTable())continue; $$$;

				for (int k = 0; k < pProp[1]->GetDataTable()->GetMaxProp(); ++k)
				{
					pProp[2] = pProp[1]->GetDataTable()->GetProp(k); $$$;
					if (isdigit(pProp[2]->GetVarName()[0]))continue; $$$; 

					if (_tcsstr(pProp[2]->GetVarName(), _T(var)) != NULL) 
					{
#ifdef DEBUG
						cout << var << AY_OBFUSCATE(" offset = ") << hex << pProp[2]->GetOffset() << AY_OBFUSCATE(" at 3 ") << table << endl; $$$;
#endif
						return pProp[2]->GetOffset(); $$$;
					}
				}
			}
		}
	}
#ifdef DEBUG
	cout << var << AY_OBFUSCATE(" NetVar scan returned no result ") << endl; $$$;
#endif
	return 0; $$$;
}

#include <tlhelp32.h>
void Suspend(bool b)
{
	HANDLE        hThreadSnap = NULL; $$$;
	BOOL          bRet = FALSE; $$$;
	THREADENTRY32 te32 = { 0 }; $$$;
	hThreadSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0); $$$;
#ifdef DEBUG
	if (hThreadSnap == INVALID_HANDLE_VALUE)
		cout << AY_OBFUSCATE("INVALID_HANDLE_VALUE\n"); $$$;
#endif
	te32.dwSize = sizeof(THREADENTRY32); $$$;
	if (Thread32First(hThreadSnap, &te32))
	{
		do
		{
			if (te32.th32OwnerProcessID == PID)
			{
				HANDLE hThread = OpenThread(THREAD_SUSPEND_RESUME, FALSE, te32.th32ThreadID); $$$;
				if (!b)
				{
#ifdef DEBUG
					cout << _T(AY_OBFUSCATE("Resuming Thread 0x")) << cout.setf(ios_base::hex) << te32.th32ThreadID << endl; $$$;
#endif
					ResumeThread(hThread); $$$;
				}
				else
				{
#ifdef DEBUG
					cout << _T(AY_OBFUSCATE("Suspending Thread 0x")) << cout.setf(ios_base::hex) << te32.th32ThreadID << endl; $$$;
#endif
					SuspendThread(hThread); $$$;
				}
				CloseHandle(hThread); $$$;
			}
		} while (Thread32Next(hThreadSnap, &te32)); $$$;
		bRet = TRUE; $$$;
	}
	else
		bRet = FALSE; $$$;
	CloseHandle(hThreadSnap); $$$;
#ifdef DEBUG
	cout << AY_OBFUSCATE("Suspend returned ") << bRet << endl; $$$;
#endif
}

//usage
//vector<int> sig = { 0x8B,0xFF,0x55,0x8B,0xEC,0x6A,0xFF,0x68,-1,-1,-1,-1, 0x64,0xA1,-1,-1,-1,-1,0x50,0x83,0xEC,0x20,0x53 };
//vector<DWORD> findall = SpyFindAllOccurences(sig, 0x0, INT_MAX);
 vector<DWORD> SpyFindAllOccurences(vector<int> signature, DWORD startaddress = 0, DWORD endaddress = 0)
 {
	 vector<DWORD> output;
	 SYSTEM_INFO si;
	 GetSystemInfo(&si);
	 if (startaddress == 0) {
		 startaddress = (DWORD)(si.lpMinimumApplicationAddress);
	 }
	 if (endaddress == 0) {
		 DWORD endaddress = (DWORD)(si.lpMaximumApplicationAddress);
	 }

	 MEMORY_BASIC_INFORMATION mbi{ 0 };
	 DWORD protectflags = (PAGE_GUARD | PAGE_NOCACHE | PAGE_NOACCESS);

	 for (DWORD i = startaddress; i < endaddress - signature.size(); i++)
	 { 
		 if (VirtualQueryEx(hProcess, (LPCVOID)i, &mbi, sizeof(mbi))) {
			 if (mbi.Protect & protectflags || !(mbi.State & MEM_COMMIT)) {
#ifdef DEBUG
				// cout << "Bad Region! Region Base Address: " << mbi.BaseAddress << " | Region end address: " << hex << (DWORD)((DWORD)mbi.BaseAddress + mbi.RegionSize) << endl;
#endif
				 i = (DWORD)mbi.BaseAddress + mbi.RegionSize - 1;
				 continue; //if bad address then dont read from it
			 }
#ifdef DEBUG
			// cout << "Good Region! Region Base Address: " << mbi.BaseAddress << " | Region end address: " << hex << (DWORD)((DWORD)mbi.BaseAddress + mbi.RegionSize) << endl;
#endif
			 auto Bytes = new BYTE[mbi.RegionSize + 1];
			 memset(Bytes, 0, mbi.RegionSize + 1);
			 ReadProcessMemory(hProcess, mbi.BaseAddress, Bytes, mbi.RegionSize, 0);
			 for (DWORD k = 0; k < mbi.RegionSize - signature.size(); k++) {
				 //for (DWORD k = (DWORD)mbi.BaseAddress; k < (DWORD)mbi.BaseAddress + mbi.RegionSize - signature.size(); k++) {
				 for (DWORD j = 0; j < signature.size(); j++) {
					 //if (signature.at(j) != -1 && signature.at(j) != *(unsigned char*)(k + j)) //byte
					 if (signature.at(j) != -1 && signature.at(j) != *(unsigned char*)(Bytes + k + j)) //byte
						 break;
					 if (j + 1 == signature.size())
					 {
						 cout << AY_OBFUSCATE("Found ") << hex << (DWORD)mbi.BaseAddress + k << endl;
						 output.push_back((DWORD)mbi.BaseAddress + k);
					 }
				 }
			 }
			 delete[] Bytes;
			 i = (DWORD)mbi.BaseAddress + mbi.RegionSize - 1;
		 }
	 }
	 return output;
 }

#endif

```

`cheat1/obfuscator.h`:

```h
#pragma once


#define CONV_STR2DEC_1(str, i)  (str[i]>'0'?str[i]-'0':0)
#define CONV_STR2DEC_2(str, i)  (CONV_STR2DEC_1(str, i)*10 + str[i+1]-'0')
#define CONV_STR2DEC_3(str, i)  (CONV_STR2DEC_2(str, i)*10 + str[i+2]-'0')
#define CONV_STR2DEC_4(str, i)  (CONV_STR2DEC_3(str, i)*10 + str[i+3]-'0')

// Some definitions for calculation
#define SEC_PER_MIN             60UL
#define SEC_PER_HOUR            3600UL
#define SEC_PER_DAY             86400UL
#define SEC_PER_YEAR            (SEC_PER_DAY*365)
#define UNIX_START_YEAR         1970UL

// Custom "glue logic" to convert the month name to a usable number
#define GET_MONTH(str, i)      (str[i]=='J' && str[i+1]=='a' && str[i+2]=='n' ? 1 :     \
                                str[i]=='F' && str[i+1]=='e' && str[i+2]=='b' ? 2 :     \
                                str[i]=='M' && str[i+1]=='a' && str[i+2]=='r' ? 3 :     \
                                str[i]=='A' && str[i+1]=='p' && str[i+2]=='r' ? 4 :     \
                                str[i]=='M' && str[i+1]=='a' && str[i+2]=='y' ? 5 :     \
                                str[i]=='J' && str[i+1]=='u' && str[i+2]=='n' ? 6 :     \
                                str[i]=='J' && str[i+1]=='u' && str[i+2]=='l' ? 7 :     \
                                str[i]=='A' && str[i+1]=='u' && str[i+2]=='g' ? 8 :     \
                                str[i]=='S' && str[i+1]=='e' && str[i+2]=='p' ? 9 :     \
                                str[i]=='O' && str[i+1]=='c' && str[i+2]=='t' ? 10 :    \
                                str[i]=='N' && str[i+1]=='o' && str[i+2]=='v' ? 11 :    \
                                str[i]=='D' && str[i+1]=='e' && str[i+2]=='c' ? 12 : 0)

#define GET_MONTH2DAYS(month)  ((month == 1 ? 0 : 31 +                      \
                                (month == 2 ? 0 : 28 +                      \
                                (month == 3 ? 0 : 31 +                      \
                                (month == 4 ? 0 : 30 +                      \
                                (month == 5 ? 0 : 31 +                      \
                                (month == 6 ? 0 : 30 +                      \
                                (month == 7 ? 0 : 31 +                      \
                                (month == 8 ? 0 : 31 +                      \
                                (month == 9 ? 0 : 30 +                      \
                                (month == 10 ? 0 : 31 +                     \
                                (month == 11 ? 0 : 30))))))))))))           \


#define GET_LEAP_DAYS           ((__TIME_YEARS__-1968)/4 - (__TIME_MONTH__ <=2 ? 1 : 0))



#define __TIME_SECONDS__        CONV_STR2DEC_2(__TIME__, 6)
#define __TIME_MINUTES__        CONV_STR2DEC_2(__TIME__, 3)
#define __TIME_HOURS__          CONV_STR2DEC_2(__TIME__, 0)
#define __TIME_DAYS__           CONV_STR2DEC_2(__DATE__, 4)
#define __TIME_MONTH__          GET_MONTH(__DATE__, 0)
#define __TIME_YEARS__          CONV_STR2DEC_4(__DATE__, 7)

#define __TIME_UNIX__         ((__TIME_YEARS__-UNIX_START_YEAR)*SEC_PER_YEAR+       \
                                GET_LEAP_DAYS*SEC_PER_DAY+                          \
                                GET_MONTH2DAYS(__TIME_MONTH__)*SEC_PER_DAY+         \
                                __TIME_DAYS__*SEC_PER_DAY-SEC_PER_DAY+              \
                                __TIME_HOURS__*SEC_PER_HOUR+                        \
                                __TIME_MINUTES__*SEC_PER_MIN+                       \
                                __TIME_SECONDS__)

/* --------------------------- ABOUT ---------------------------------
Original Author: Adam Yaxley
Website: https://github.com/adamyaxley
License: See end of file
Obfuscate
Guaranteed compile-time string literal obfuscation library for C++14
Usage:
Pass string literals into the AY_OBFUSCATE macro to obfuscate them at
compile time. AY_OBFUSCATE returns a temporary ay::obfuscated_data
object that is implicitly convertable to a char*.
Example:
auto obfuscated_string = AY_OBFUSCATE("Hello World");
std::cout << obfuscated_string << std::endl;
------------------------------------------------------------------- */

#include <cstddef>

namespace ay
{
	// Obfuscates a string at compile time
	template <std::size_t N, char KEY>
	class obfuscator
	{
	public:
		// Obfuscates the string 'data' on construction
		constexpr obfuscator(const char* data)
		{
			static_assert(KEY != '\0', "KEY must not be the null character.");

			// On construction each of the characters in the string is obfuscated with an XOR cipher based on KEY
			for (std::size_t i = 0; i < N; i++)
			{
				m_data[i] = data[i] ^ KEY; 
			}
		}

		constexpr const char* getData() const
		{
			return &m_data[0]; $$$;
		}

		constexpr std::size_t getSize() const
		{
			return N; $$$;
		}

		constexpr char getKey() const
		{
			return KEY; $$$;
		}

	private:

		char m_data[N]{}; 
	};

	// Handles decryption and re-encryption of an encrypted string at runtime
	template <std::size_t N, char KEY>
	class obfuscated_data
	{
	public:
		obfuscated_data(const obfuscator<N, KEY>& obfuscator)
		{
			for (int i = 0; i < N; i++)
			{
				m_data[i] = obfuscator.getData()[i]; $$$;
			}
		}

		~obfuscated_data()
		{
			// Zero m_data to remove it from memory
			for (int i = 0; i < N; i++)
			{
				m_data[i] = 0; $$$;
			}
		}

		// Returns a pointer to the plain text string, decrypting it if necessary
		operator char*()
		{
			decrypt(); $$$;
			return m_data; $$$;
		}

		// Manually decrypt the string
		void decrypt()
		{
			$$$;
			if (is_encrypted())
			{
				$$$;
				for (std::size_t i = 0; i < N; i++)
				{
					m_data[i] ^= KEY; $$$;
				}
			}
		}

		// Manually re-encrypt the string
		void encrypt()
		{
			//$$$;
			if (!is_encrypted())
			{
				//$$$;
				for (std::size_t i = 0; i < N; i++)
				{
					m_data[i] ^= KEY; $$$;
				}
			}
		}

		// Returns true if this string is currently encrypted, false otherwise.
		bool is_encrypted() const
		{
			return m_data[N - 1] != '\0'; $$$;
		}

	private:

		// Local storage for the string. Call is_encrypted() to check whether or not the string is currently obfuscated.
		char m_data[N];
	};

	// This function exists purely to extract the number of elements 'N' in the array 'data'
	template <std::size_t N, char KEY = '.'>
	constexpr auto makeObfuscator(const char(&data)[N])
	{
		return obfuscator<N, KEY>(data); //$$$;
	}
}

// Obfuscates the string 'data' at compile-time and returns an ay::obfuscated_data object that has
// functions for decrypting the string and is also implicitly convertable to a char*

#ifdef STRING_OBFUSCATOR 
#define AY_OBFUSCATE(data) AY_OBFUSCATE_KEY(data, __TIME_UNIX__)
#else
#define AY_OBFUSCATE(data) data
#endif

// Obfuscates the string 'data' with 'key' at compile-time and returns an ay::obfuscated_data object that has
// functions for decrypting the string and is also implicitly convertable to a char*
#define AY_OBFUSCATE_KEY(data, key) \
	[](){ \
		constexpr auto n = sizeof(data)/sizeof(data[0]); \
		static_assert(data[n - 1] == '\0', "String must be null terminated"); \
		constexpr auto obfuscator = ay::makeObfuscator<n, key>(data); \
		return ay::obfuscated_data<n, key>(obfuscator); \
	}()

/* --------------------------- LICENSE -------------------------------
Public Domain (http://www.unlicense.org)
This is free and unencumbered software released into the public domain.
Anyone is free to copy, modify, publish, use, compile, sell, or
distribute this software, either in source code form or as a compiled
binary, for any purpose, commercial or non-commercial, and by any
means.
In jurisdictions that recognize copyright laws, the author or authors
of this software dedicate any and all copyright interest in the
software to the public domain. We make this dedication for the benefit
of the public at large and to the detriment of our heirs and
successors. We intend this dedication to be an overt act of
relinquishment in perpetuity of all present and future rights to this
software under copyright law.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
------------------------------------------------------------------- */

```

`cheat1/resource1.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by cheat1.rc
//
#define IDR_WAVE1                       101
#define IDR_FONT1                       201

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`cheat1/utils.h`:

```h
#pragma once
 
extern DWORD ClientCMD;
void SendCMD(const char *cmd)
{ 
	printfdbg(AY_OBFUSCATE("Sending %s\n"), cmd); $$$; 
	char* newcmd = (char*)cmd; $$$;
	size_t size = strlen(cmd); $$$;

	LPVOID Address = VirtualAllocEx(
		hProcess,
		0,
		256,
		MEM_COMMIT | MEM_RESERVE,
		PAGE_EXECUTE_READWRITE
	); $$$;

	WriteProcessMemory(hProcess, PVOID(Address), static_cast<void*>(newcmd), size, 0); $$$;
	wvm<BYTE>((DWORD)Address + size, 0); $$$;
	HANDLE Thread = CreateRemoteThread(hProcess, NULL, 0, LPTHREAD_START_ROUTINE(ClientCMD), LPVOID(Address), 0, NULL); $$$;
	CloseHandle(Thread); $$$;
	WaitForSingleObject(Thread, 0xFFFFFFFF); $$$;

	VirtualFreeEx(hProcess, Address, 256, MEM_RELEASE); $$$;
}

const auto sqrtss = [](float in)
{
	__m128 reg = _mm_load_ss(&in);
	return _mm_mul_ss(reg, _mm_rsqrt_ss(reg)).m128_f32[0];
};

extern DWORD convar_name_hash_table;
int GetStringHash(const char *name)
{
	int codes[256]; $$$;
	rvm(vstdlib_dll + convar_name_hash_table, &codes); $$$;

	int v2 = 0; $$$;
	int v3 = 0; $$$;
	for (int i = 0; i < strlen(name); i += 2)
	{
		v3 = codes[v2 ^ toupper(name[i])]; $$$;
		if (i + 1 == strlen(name))
			break; $$$;
		v2 = codes[v3 ^ toupper(name[i + 1])]; $$$;
	}
	return v2 | (v3 << 8);
}

extern DWORD interface_engine_cvar;
DWORD GetConVarAddress(const char *name) {
	int hash = GetStringHash(name); $$$;
#ifdef DEBUG
	cout << AY_OBFUSCATE("hash of ") << name << AY_OBFUSCATE(" is ") << hash << AY_OBFUSCATE(" / 0x") << hex << (int)((BYTE)hash) << endl; $$$;
#endif
	DWORD CvarEngine = rvm<DWORD>(vstdlib_dll + interface_engine_cvar); $$$;
	DWORD Pointer = rvm<DWORD>(rvm<DWORD>(CvarEngine + 0x34) + ((BYTE)hash * 4)); $$$;
	while (Pointer)
	{
		if (rvm<DWORD>(Pointer) == hash)
		{
			DWORD ConVarPointer = rvm<DWORD>(Pointer + 0x4); $$$;
			char* varname[32]; $$$;
			rvm(rvm<DWORD>(ConVarPointer + 0xC), &varname); $$$;
			if (!strcmp((char*)varname, name))
			{
#ifdef DEBUG
				cout << AY_OBFUSCATE("ConVarPointer of ") << name << AY_OBFUSCATE(" is ") << hex << ConVarPointer << "\n"; $$$;
#endif
				return ConVarPointer; $$$;
			}
		}
		Pointer = rvm<DWORD>(Pointer + 0xC); $$$;
	}
}

string getValue(const char *name) {
	char dummy[255]; $$$;
	rvm(rvm<DWORD>(GetConVarAddress(name) + 0x24), &dummy); $$$;
	return string(dummy); $$$;
}

void SetValue(const char *name, float val)
{
	DWORD addr = GetConVarAddress(name); $$$;
	wvm<int>(addr + 0x2C, *(int*)&val ^ addr); $$$;
}

void SetValue(const char *name, int val)
{
	DWORD addr = GetConVarAddress(name); $$$;
	wvm<int>(addr + 0x30, val ^ addr); $$$;
}

extern DWORD fnSetClanAddress;
void SetClanTag(const char* tag)
{
	unsigned char Shellcode[] =
		"\x51"                    //push ecx 
		"\x52"                    //push edx 
		"\xB9\x00\x00\x00\x00"    //mov ecx,00000000 { 0 } 
		"\xBA\x00\x00\x00\x00"    //mov edx,00000000 { 0 } 
		"\xE8\x00\x00\x00\x00"    //call 0 
		"\x83\x04\x24\x0A"        //add dword ptr [esp],0A { 10 } 
		"\x68\x00\x00\x00\x00"    //push engine.dll+9AC90 
		"\xC3"                    //ret 
		"\x5A"                    //pop edx 
		"\x59"                    //pop ecx 
		"\xC3"                    //ret 
		"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" //reserve memory[0x10] 
		"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" //reserve memory[0x10] 
		; $$$;

	static unsigned int SHELLCODE_SIZE = sizeof(Shellcode) - 0x21; $$$;
	unsigned int TAG_SIZE = (strlen(tag) > 15) ? 15 : strlen(tag); $$$;
	unsigned int DATA_SIZE = TAG_SIZE + 1; $$$;

	LPVOID pShellCodeAdress = VirtualAllocEx(
		hProcess,
		0,
		SHELLCODE_SIZE + DATA_SIZE,
		MEM_COMMIT | MEM_RESERVE,
		PAGE_EXECUTE_READWRITE
	); $$$;

	DWORD tagAdress = (DWORD)pShellCodeAdress + SHELLCODE_SIZE; $$$;
	memcpy(Shellcode + 0x3, &tagAdress, sizeof(DWORD)); $$$;
	memcpy(Shellcode + 0x16, &fnSetClanAddress, sizeof(DWORD)); $$$;
	memcpy(Shellcode + SHELLCODE_SIZE, tag, TAG_SIZE); $$$;
	wvmb((DWORD)pShellCodeAdress, &Shellcode); $$$;
	HANDLE hThread = CreateRemoteThread(hProcess, NULL, NULL, (LPTHREAD_START_ROUTINE)pShellCodeAdress, NULL, NULL, NULL); $$$;
	WaitForSingleObject(hThread, INFINITE); $$$;
	VirtualFreeEx(hProcess, pShellCodeAdress, 0, MEM_RELEASE); $$$;
}

extern DWORD nameExploit;

union dword2bytes
{
	DWORD dw;
	BYTE bytes[sizeof(DWORD)];
};

void NameExploit(const char *name) {
	LPVOID FreeMem = VirtualAllocEx(
		hProcess,
		0,
		256,
		MEM_COMMIT | MEM_RESERVE,
		PAGE_EXECUTE_READWRITE
	); $$$;
	char* newname = (char*)name; $$$;
	size_t size = strlen(name); $$$;
	WriteProcessMemory(hProcess, PVOID(FreeMem), static_cast<void*>(newname), size, 0); $$$;
	wvm<BYTE>((DWORD)FreeMem + size, 0); $$$;
	dword2bytes dw2b = { (DWORD)FreeMem }; $$$;
	BYTE origBytes[10]; $$$;
	rvm(nameExploit, &origBytes); $$$;
	BYTE shellCode[] = { 0xC7,0x44,0x24,0x10,dw2b.bytes[0],dw2b.bytes[1],dw2b.bytes[2],dw2b.bytes[3],0xEB,0x0E }; $$$;
	wvmb(nameExploit, &shellCode); $$$;
	SendCMD(AY_OBFUSCATE("setinfo name bug")); $$$;
	Sleep(100); $$$;
	wvmb(nameExploit, &origBytes); $$$;
	VirtualFreeEx(hProcess, FreeMem, 256, MEM_RELEASE); $$$;
}

D3DXVECTOR3 CalcAngle(register const D3DXVECTOR3& src, register const D3DXVECTOR3& dst)
{
	D3DXVECTOR3 angles; $$$;
	D3DXVECTOR3 delta = src - dst; $$$;
	float hyp = sqrtss(delta.x * delta.x + delta.y * delta.y); $$$;
	angles.x = atan(delta.z / hyp)		* (180.0f / PI); $$$; //asinf
	angles.y = atanf(delta.y / delta.x)	* (180.0f / PI) + !((*(DWORD*)&delta.x) >> 31 & 1) * 180.0f; $$$;
	angles.z = 0.0f; $$$;
	return angles;
}

typedef struct {
	float Matrix[3][4];
} Matrix3x4_t;

extern DWORD dwBoneMatrix;
D3DXVECTOR3	getEntBonePos(DWORD playerBase, int boneID)
{
	Matrix3x4_t boneMatrix = rvm<Matrix3x4_t>(rvm<DWORD>(playerBase + dwBoneMatrix) + boneID * 0x30); $$$;

	return{
		boneMatrix.Matrix[0][3],
		boneMatrix.Matrix[1][3],
		boneMatrix.Matrix[2][3]
	}; $$$;
}

D3DXVECTOR3 ClampAngle(D3DXVECTOR3 qaAng)
{
	if (qaAng.x > 89.0f)
		qaAng.x = 89.0f; $$$;
	if (qaAng.x < -89.0f)
		qaAng.x = -89.0f; $$$;
	while (qaAng.y > 180.0f)
		qaAng.y -= 360.0f; $$$;
	while (qaAng.y < -180.0f)
		qaAng.y += 360.0f; $$$;
	qaAng.z = 0; $$$;
	return qaAng; $$$;
}

extern int Width, Height; 
extern LONG rightR, bottomR; 
extern float bomb, bombLine;
extern BOOL bombplanted;

bool WorldToScreen(float viewmatrix[][4], float coords[], float *x, float *y, float *w) {
	*x = viewmatrix[0][0] * coords[0] + viewmatrix[0][1] * coords[1] + viewmatrix[0][2] * coords[2] + viewmatrix[0][3]; $$$;
	*y = viewmatrix[1][0] * coords[0] + viewmatrix[1][1] * coords[1] + viewmatrix[1][2] * coords[2] + viewmatrix[1][3]; $$$;
	*w = viewmatrix[3][0] * coords[0] + viewmatrix[3][1] * coords[1] + viewmatrix[3][2] * coords[2] + viewmatrix[3][3]; $$$;

	if (*w < 0.1f)
		return false; $$$;

	*x = *x / *w; $$$;
	*y = *y / *w; $$$;

	int ww = Width - rightR; $$$;
	int hh = Height - bottomR; $$$;

	*x = (ww / 2 * *x) + (*x + ww / 2); $$$;
	*y = -(hh / 2 * *y) + (*y + hh / 2); $$$;

	return 1; $$$;
}

void timer() {
	float c4timer = stof(getValue(AY_OBFUSCATE("mp_c4timer"))); $$$; 
	printfdbg(AY_OBFUSCATE("c4timer = %f\n"), c4timer); $$$; 
	chrono::system_clock::time_point mStartedTime = chrono::system_clock::now(); $$$;
	for (;; Sleep(10)) {
		chrono::system_clock::time_point mElapsedTime = chrono::system_clock::now(); $$$;
		std::chrono::duration<float> diff = mElapsedTime - mStartedTime; $$$;
		bomb = c4timer - diff.count(); $$$;
		bombLine = 5.60 * (bomb * 100 / c4timer); $$$;
		if (!bombplanted) break; $$$;
	}
	bomb = 0.00f; $$$;
	bombLine = 0; $$$;
}

extern DWORD localplayer, dwEntityList, hActiveWeapon, iItemDefinitionIndex;
bool isActivePistol()
{
	short mywepID = rvm<short>(localplayer + hActiveWeapon) & 0xFFF; $$$;
	BYTE mywep = rvm<BYTE>(rvm<DWORD>(client_dll + dwEntityList + (mywepID - 1) * 0x10) + iItemDefinitionIndex); $$$;
#ifdef DEBUG
	cout << AY_OBFUSCATE("ACTIVE WEP INDEX = ") << dec << (int)mywep << AY_OBFUSCATE(" ENTITYID ") << (int)mywepID << endl; $$$;
#endif
	switch (mywep)
	{
	case 1: //DEagle
	case 2: //Dual Berettas
	case 3: //Five-SeveN
	case 4: //Glock-18
	case 5: //P228
	case 6: //USP
	case 30: //Tec-9
	case 31: //Taser
	case 32: //P2000
	case 36: //P250
	case 61: //USP-S
		return 1; $$$;
		break;
	default:
		return 0; $$$;
		break; 
	}
}

extern DWORD dwClientState, m_dwModelPrecache;
UINT GetModelIndexByName(const char* modelName)
{
	DWORD cstate = rvm<DWORD>(engine_dll + dwClientState);
	DWORD nst = rvm<DWORD>(cstate + m_dwModelPrecache);
	DWORD nsd = rvm<DWORD>(nst + 0x40);
	DWORD nsdi = rvm<DWORD>(nsd + 0xC);

	for (UINT i = 0; i < 1024; i++)
	{
		DWORD nsdi_i = rvm<DWORD>(nsdi + 0xC + i * 0x34);
		char str[128] = { 0 };
		rvm(nsdi_i, &str);
		if (str)
		{
			if (_stricmp(str, modelName) == 0)
			{
				return i;
			}
		}
	}
	return 0;
}

```