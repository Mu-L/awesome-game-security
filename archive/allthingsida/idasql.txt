Project Path: arc_allthingsida_idasql_2s2hgymb

Source Tree:

```txt
arc_allthingsida_idasql_2s2hgymb
├── CMakeLists.txt
├── CMakePresets.json
├── LICENSE
├── README.md
├── assets
│   ├── idasql_cli_agent_2.jpg
│   ├── idasql_cli_agent_3.jpg
│   ├── idasql_cli_agent_help.jpg
│   ├── idasql_cli_agent_prompt_1.jpg
│   ├── idasql_cli_handoff_1.jpg
│   ├── idasql_cli_interactive_1.jpg
│   ├── idasql_cli_one_query.jpg
│   ├── idasql_cli_one_query_2.jpg
│   ├── idasql_help.jpg
│   ├── idasql_plugin_agent_1.jpg
│   ├── idasql_plugin_agent_2.jpg
│   ├── idasql_plugin_agent_3.jpg
│   ├── idasql_plugin_agent_4.jpg
│   ├── idasql_plugin_cli_select.jpg
│   └── idasql_plugin_handoff_1.jpg
├── benchmark.md
├── examples
│   ├── CMakeLists.txt
│   ├── agent_session_strings.md
│   ├── example_basic.cpp
│   ├── example_breakpoints.cpp
│   ├── example_custom_vtable.cpp
│   ├── example_decompiler.cpp
│   ├── example_functions.cpp
│   ├── example_instructions.cpp
│   ├── example_jump_entities.cpp
│   ├── example_jump_search.cpp
│   ├── example_plugin_style.cpp
│   └── example_strings.cpp
├── ida-plugin.json
├── prompts
│   └── idasql_agent.md
├── scripts
│   └── embed_prompt.py
└── src
    ├── CMakeLists.txt
    ├── cli
    │   ├── CMakeLists.txt
    │   ├── idasql.manifest
    │   └── main.cpp
    ├── common
    │   ├── agent_settings.hpp
    │   ├── ai_agent.cpp
    │   ├── ai_agent.hpp
    │   ├── http_server.cpp
    │   ├── http_server.hpp
    │   ├── idasql_agent_prompt.hpp
    │   ├── idasql_cli.hpp
    │   ├── idasql_commands.hpp
    │   ├── idasql_version.hpp
    │   ├── json_utils.hpp
    │   ├── mcp_server.cpp
    │   ├── mcp_server.hpp
    │   ├── plugin_control.hpp
    │   └── session_handler.hpp
    ├── lib
    │   ├── CMakeLists.txt
    │   └── include
    │       └── idasql
    │           ├── database.hpp
    │           ├── decompiler.hpp
    │           ├── disassembly.hpp
    │           ├── entities.hpp
    │           ├── entities_dbg.hpp
    │           ├── entities_ext.hpp
    │           ├── entities_search.hpp
    │           ├── entities_types.hpp
    │           ├── functions.hpp
    │           ├── idasql.hpp
    │           ├── metadata.hpp
    │           ├── platform.hpp
    │           ├── platform_undef.hpp
    │           ├── search_bytes.hpp
    │           ├── vtable.hpp
    │           └── vtable_policy.hpp
    └── plugin
        ├── CMakeLists.txt
        └── main.cpp

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.20)
project(idasql VERSION 0.0.7 LANGUAGES C CXX)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

# Silence CMake policy warnings from dependencies
cmake_policy(SET CMP0135 NEW)                     # Use extraction time for DOWNLOAD_EXTRACT_TIMESTAMP
set(CMAKE_POLICY_DEFAULT_CMP0169 OLD CACHE STRING "" FORCE) # Allow FetchContent_Populate() in dependencies

include(FetchContent)

# Output directories (only set if building standalone)
if(CMAKE_SOURCE_DIR STREQUAL CMAKE_CURRENT_SOURCE_DIR)
    set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)
    set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)
    set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)
endif()

# ============================================================================
# IDA SDK (required for CLI and plugin)
# ============================================================================

include($ENV{IDASDK}/src/cmake/bootstrap.cmake)
find_package(idasdk REQUIRED)

# ============================================================================
# HTTP Server Support - must be set BEFORE libxsql
# ============================================================================

set(XSQL_WITH_THINCLIENT ON CACHE BOOL "" FORCE)

# idasql uses only plain HTTP (localhost); prevent cpp-httplib from opportunistically linking OpenSSL
set(HTTPLIB_USE_OPENSSL_IF_AVAILABLE OFF CACHE BOOL "" FORCE)

# ============================================================================
# libxsql dependency
# ============================================================================

if(TARGET xsql::xsql)
    # Monorepo: already available from parent
    message(STATUS "idasql: Using xsql::xsql from parent project")
elseif(EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/../libxsql/CMakeLists.txt")
    # Monorepo: sibling directory (private test infrastructure)
    add_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/../libxsql ${CMAKE_CURRENT_BINARY_DIR}/libxsql)
    message(STATUS "idasql: Added libxsql from sibling directory")
else()
    # Standalone: FetchContent from GitHub
    message(STATUS "idasql: Fetching libxsql from GitHub...")
    FetchContent_Declare(libxsql
        GIT_REPOSITORY https://github.com/0xeb/libxsql.git
        GIT_TAG        main
        GIT_SHALLOW    TRUE
    )
    FetchContent_MakeAvailable(libxsql)
endif()

# Include directories
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/src/include)
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/src/lib/include)

# ============================================================================
# AI Agent Support (libagents - optional)
# ============================================================================

option(IDASQL_WITH_AI_AGENT "Build with AI agent support (libagents)" ON)

if(IDASQL_WITH_AI_AGENT)
    message(STATUS "idasql: Building with AI agent support via libagents")

    # libagents build options
    set(LIBAGENTS_BUILD_TESTS OFF CACHE BOOL "" FORCE)
    set(LIBAGENTS_BUILD_EXAMPLES OFF CACHE BOOL "" FORCE)
    set(LIBAGENTS_BUILD_CLI OFF CACHE BOOL "" FORCE)
    set(LIBAGENTS_BUILD_COPILOT ON CACHE BOOL "" FORCE)

    # FetchContent from GitHub (with recursive submodules for fastmcpp, SDKs)
    message(STATUS "idasql: Fetching libagents from GitHub...")
    FetchContent_Declare(libagents
        GIT_REPOSITORY https://github.com/0xeb/libagents.git
        GIT_TAG        ae162192d49126da6328254aab73417d673379cc
        GIT_SUBMODULES_RECURSE TRUE
    )
    FetchContent_MakeAvailable(libagents)

    # ========================================================================
    # Build speed: enable MSVC parallel compilation for dependency targets.
    # IDA SDK's /MP only applies to ida_add_plugin/ida_add_idalib targets;
    # FetchContent dependencies compile their files sequentially without this.
    # ========================================================================
    if(MSVC)
        foreach(_dep_target fastmcpp_core copilot_sdk_cpp claude_sdk libagents)
            if(TARGET ${_dep_target})
                target_compile_options(${_dep_target} PRIVATE /MP)
            endif()
        endforeach()
    endif()

    # Build speed: merge translation units to reduce header re-parsing.
    # Note: fastmcpp_core is excluded — its server files use duplicate
    # anonymous-namespace symbols that conflict under unity builds.
    foreach(_dep_target copilot_sdk_cpp claude_sdk libagents)
        if(TARGET ${_dep_target})
            set_target_properties(${_dep_target} PROPERTIES UNITY_BUILD ON)
        endif()
    endforeach()

    # Exclude unused targets from default build (e.g. claude-sdk debug tool)
    foreach(_unused_target debug)
        if(TARGET ${_unused_target})
            set_target_properties(${_unused_target} PROPERTIES EXCLUDE_FROM_ALL TRUE)
        endif()
    endforeach()

    # Generate prompt header if needed (conditional on source file age)
    find_package(Python3 COMPONENTS Interpreter)
    if(Python3_FOUND)
        set(PROMPT_MD "${CMAKE_CURRENT_SOURCE_DIR}/prompts/idasql_agent.md")
        set(PROMPT_HPP "${CMAKE_CURRENT_SOURCE_DIR}/src/common/idasql_agent_prompt.hpp")

        add_custom_command(
            OUTPUT ${PROMPT_HPP}
            COMMAND ${Python3_EXECUTABLE}
                ${CMAKE_CURRENT_SOURCE_DIR}/scripts/embed_prompt.py
                ${PROMPT_MD} ${PROMPT_HPP}
            DEPENDS ${PROMPT_MD}
            COMMENT "Checking/regenerating idasql_agent_prompt.hpp"
        )
        add_custom_target(generate_prompt DEPENDS ${PROMPT_HPP})
    endif()
endif()

# Add subdirectories
add_subdirectory(src)

# Examples (optional)
option(IDASQL_BUILD_EXAMPLES "Build IDASQL example programs" ON)
if(IDASQL_BUILD_EXAMPLES AND EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/examples")
    add_subdirectory(examples)
endif()

```

`CMakePresets.json`:

```json
{
  "version": 6,
  "configurePresets": [
    {
      "name": "release",
      "displayName": "Release",
      "generator": "Visual Studio 17 2022",
      "binaryDir": "${sourceDir}/build",
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": "Release",
        "IDASQL_WITH_AI_AGENT": "ON"
      }
    },
    {
      "name": "release-no-agent",
      "displayName": "Release (no AI agent)",
      "description": "Build without AI agent support to reduce binary size. Excludes libagents, fastmcpp, claude_sdk, copilot_sdk_cpp, easywsclient, tiny-process-library.",
      "generator": "Visual Studio 17 2022",
      "binaryDir": "${sourceDir}/build-no-agent",
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": "Release",
        "IDASQL_WITH_AI_AGENT": "OFF"
      }
    }
  ]
}

```

`LICENSE`:

```
MIT License

Copyright (c) 2024-2026 Elias Bachaalany

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# IDASQL

Talk to your IDA database.

```
you:   what's the most called function?
agent: The most called function is `__security_check_cookie` with 1,247 callers.
       This is typical for MSVC-compiled binaries - it's the stack canary check.

you:   find functions that reference "password" strings
agent: Found 3 functions referencing password-related strings:
       - validate_credentials (0x401240) - references "password incorrect"
       - parse_config (0x402890) - references "password_hash"
       - debug_dump (0x405120) - references "password: %s"

you:   decompile validate_credentials
agent: [displays pseudocode]
```

Ask complex questions that would take hours to script:

```
you:   find functions that make at most 3 calls, where those callees
       don't go deeper than 5 levels in the call graph

agent: Looking for shallow functions with bounded call depth...

       Found 47 functions matching your criteria:
       - init_config (0x401000) - 2 calls, max depth 3
       - validate_checksum (0x401200) - 3 calls, max depth 4
       - parse_header (0x401400) - 1 call, max depth 2
       ...

       These are good candidates for isolated analysis - simple entry
       points that don't spiral into deep call chains.
```

IDASQL exposes IDA Pro databases as SQL tables with a built-in AI agent. Ask questions in plain English. The agent writes SQL, runs queries, and explains results.

Works as a **standalone CLI** (query `.i64` files directly) or as an **IDA plugin** (query the open database). No scripting. No IDAPython. Just ask.

**No indexing required.** IDA already has everything indexed. Queries run instantly against the live database.

## Features

- **AI Agent** - Natural language queries with Claude or GitHub Copilot
- **SQL Interface** - Full SQL access to functions, strings, imports, xrefs, instructions, types
- **Unified Entity Search** - `jump_entities()` searches everything: functions, types, members, enums (think "Jump Anywhere")
- **Standalone CLI** - Query `.i64` files without opening IDA GUI
- **IDA Plugin** - SQL/AI interface inside IDA's command line
- **Remote Server** - Query IDA from external tools, scripts, or coding agents
- **Zero Setup** - Uses your existing Claude Code or Copilot authentication

## Screenshots

### CLI - Single Query

Run one query and exit. Useful for scripts and pipelines.

```bash
idasql -s database.i64 -q "SELECT * FROM funcs LIMIT 5"
```

![CLI Single Query](assets/idasql_cli_one_query.jpg)

### CLI - Interactive Mode

Launch a REPL for exploratory analysis. Type SQL directly at the prompt.

```bash
idasql -s database.i64 -i
```

```
idasql> SELECT COUNT(*) FROM strings;
idasql> SELECT name FROM funcs WHERE size > 1000;
idasql> .tables          -- list available tables
idasql> .schema funcs    -- show table schema
idasql> .http start      -- start HTTP server from REPL
idasql> .mcp start       -- start MCP server from REPL
idasql> .quit            -- exit
```

![CLI Interactive](assets/idasql_cli_interactive_1.jpg)

### CLI - AI Agent

Talk to the database in plain English. The agent translates to SQL, runs queries, and explains results.

```bash
idasql -s database.i64 -i --agent
```

Ask questions naturally:
```
idasql> how many functions are there?
idasql> which function is called the most?
idasql> find strings that look like URLs
idasql> what imports are related to file operations?
idasql> show me the largest functions
```

![CLI Agent](assets/idasql_cli_agent_2.jpg)

The agent can generate visualizations like call graphs:

```
idasql> draw a call graph for the main function
idasql> visualize the call hierarchy of CreateFileW
```

![CLI Agent Call Graph](assets/idasql_cli_agent_3.jpg)

### IDA Plugin

Select `idasql` from the CLI dropdown at the bottom of IDA:

![Plugin CLI Select](assets/idasql_plugin_cli_select.jpg)

Type SQL or natural language questions directly. The agent has full access to IDA's capabilities:

```
idasql> what's the busiest function?
idasql> find functions that reference "error"
idasql> which structures have the most members?
```

![Plugin Agent](assets/idasql_plugin_agent_1.jpg)

The agent can invoke the decompiler, analyze types, and trace cross-references:

```
idasql> decompile the free_base function
idasql> what does the _CONTEXT structure look like?
idasql> who calls VirtualAlloc and what do they do with it?
```

![Plugin Decompile](assets/idasql_plugin_agent_2.jpg)

### Remote Server

The plugin runs a TCP server. Query IDA from scripts, other tools, or coding agents:

```bash
idasql --remote localhost:13337 --token <token> -q "SELECT COUNT(*) FROM funcs"
```

![Remote Query](assets/idasql_cli_handoff_1.jpg)

## Quick Start

### CLI

```bash
# Single query
idasql -s database.i64 -q "SELECT name, address FROM funcs LIMIT 10"

# Interactive mode
idasql -s database.i64 -i

# AI agent mode
idasql -s database.i64 -i --agent

# One-shot natural language query
idasql -s database.i64 --prompt "find the largest function"

# Run SQL script
idasql -s database.i64 -f queries.sql

# Export all tables
idasql -s database.i64 --export dump.sql
```

### IDA Plugin

1. Build and install the plugin
2. Open a database in IDA
3. Select `idasql` from the command interpreter dropdown
4. Type SQL or natural language (in agent mode)

```sql
SELECT name, printf('0x%X', address) as addr FROM funcs WHERE size > 1000;
```

## Available Tables

| Table | Description |
|-------|-------------|
| `funcs` | Functions - name, address, size, end address, flags (INSERT/UPDATE/DELETE) |
| `segments` | Segments - name, start/end address, permissions, class (UPDATE/DELETE) |
| `names` | Named locations - address, name, flags (INSERT/UPDATE/DELETE) |
| `imports` | Imports - module, name, address, ordinal |
| `exports` | Exports - name, address, ordinal |
| `strings` | Strings - address, content, length, type |
| `xrefs` | Cross-references - from/to address, type, is_code |
| `instructions` | Disassembly - address, mnemonic, operands, itype, func_addr (DELETE) |
| `blocks` | Basic blocks - start/end address, func_ea, size |
| `types` | Type library - structs, unions, enums with members (INSERT/UPDATE/DELETE) |
| `breakpoints` | Breakpoints - address, type, enabled, condition (full CRUD) |
| `jump_entities(pattern, mode)` | Unified search across all entities (see below) |

### Unified Entity Search

`jump_entities` is a table-valued function that searches across functions, types, struct members, enum values, and names. It works like IDA's "Jump to address" (G) but returns SQL rows.

```sql
-- Search anything starting with "Create"
SELECT name, kind, printf('0x%X', address) as addr
FROM jump_entities('Create', 'prefix')
LIMIT 20;

-- Search anywhere in name (slower but thorough)
SELECT name, kind, full_name
FROM jump_entities('File', 'contains')
WHERE kind IN ('function', 'import')
LIMIT 20;

-- Find struct members
SELECT name, parent_name, full_name
FROM jump_entities('dw', 'prefix')
WHERE kind = 'member';
```

## Query Examples

### Function Analysis

```sql
-- Functions with most incoming calls
SELECT f.name, COUNT(*) as callers
FROM funcs f
JOIN xrefs x ON f.address = x.to_ea
WHERE x.is_code = 1
GROUP BY f.address
ORDER BY callers DESC LIMIT 10;

-- Leaf functions (make no calls)
SELECT name, size FROM funcs f
WHERE NOT EXISTS (
  SELECT 1 FROM instructions i
  WHERE i.func_addr = f.address AND i.mnemonic = 'call'
)
ORDER BY size DESC LIMIT 10;

-- Orphan functions (no callers)
SELECT name, printf('0x%X', address) as addr FROM funcs f
WHERE NOT EXISTS (
  SELECT 1 FROM xrefs x WHERE x.to_ea = f.address AND x.is_code = 1
);

-- Function size distribution
SELECT
  CASE
    WHEN size < 64 THEN 'small (<64)'
    WHEN size < 256 THEN 'medium (64-256)'
    WHEN size < 1024 THEN 'large (256-1K)'
    ELSE 'huge (>1K)'
  END as category,
  COUNT(*) as count
FROM funcs GROUP BY category;
```

### String Analysis

```sql
-- Strings with most references
SELECT s.content, COUNT(x.from_ea) as refs
FROM strings s
JOIN xrefs x ON s.address = x.to_ea
GROUP BY s.address
ORDER BY refs DESC LIMIT 10;

-- Functions using most strings
SELECT func_at(x.from_ea) as func, COUNT(DISTINCT s.address) as str_count
FROM strings s
JOIN xrefs x ON s.address = x.to_ea
GROUP BY func_at(x.from_ea)
ORDER BY str_count DESC LIMIT 10;

-- URL and path strings
SELECT printf('0x%X', address) as addr, content FROM strings
WHERE content LIKE 'http%'
   OR content LIKE '%.exe%'
   OR content LIKE '%.dll%'
   OR content LIKE 'C:\\%';
```

### Instruction Patterns

```sql
-- Most common call targets
SELECT operand0 as target, COUNT(*) as count
FROM instructions
WHERE mnemonic = 'call'
GROUP BY operand0
ORDER BY count DESC LIMIT 15;

-- Jump instruction distribution
SELECT mnemonic, COUNT(*) as count
FROM instructions
WHERE mnemonic LIKE 'j%'
GROUP BY mnemonic
ORDER BY count DESC;

-- Functions with unusual push/pop ratio (potential obfuscation)
SELECT func_at(func_addr) as name,
  SUM(CASE WHEN mnemonic = 'push' THEN 1 ELSE 0 END) as pushes,
  SUM(CASE WHEN mnemonic = 'pop' THEN 1 ELSE 0 END) as pops
FROM instructions
GROUP BY func_addr
HAVING pushes > 20 AND ABS(pushes - pops) > 5;
```

### Breakpoint Management

The `breakpoints` table supports full CRUD: SELECT, INSERT, UPDATE, DELETE. Breakpoints persist in the IDB even without an active debugger session.

```sql
-- List all breakpoints
SELECT printf('0x%08X', address) as addr, type_name, enabled, condition
FROM breakpoints;

-- Add a software breakpoint
INSERT INTO breakpoints (address) VALUES (0x401000);

-- Add a hardware write watchpoint (type=1, size=4)
INSERT INTO breakpoints (address, type, size) VALUES (0x402000, 1, 4);

-- Add a conditional breakpoint
INSERT INTO breakpoints (address, condition) VALUES (0x401000, 'eax == 0');

-- Disable a breakpoint
UPDATE breakpoints SET enabled = 0 WHERE address = 0x401000;

-- Update condition
UPDATE breakpoints SET condition = 'ecx > 5' WHERE address = 0x401000;

-- Delete a breakpoint
DELETE FROM breakpoints WHERE address = 0x401000;

-- Join with functions to see which functions have breakpoints
SELECT b.address, f.name, b.type_name, b.enabled
FROM breakpoints b
JOIN funcs f ON b.address >= f.address AND b.address < f.end_ea;
```

**Breakpoint types:** `0` = software, `1` = hardware write, `2` = hardware read, `3` = hardware rdwr, `4` = hardware exec

**Writable columns:** `enabled`, `type`, `size`, `flags`, `pass_count`, `condition`, `group`

### Database Modification

Several tables support INSERT, UPDATE, and DELETE operations:

| Table | INSERT | UPDATE | DELETE |
|-------|--------|--------|--------|
| `breakpoints` | Yes | Yes | Yes |
| `funcs` | Yes | `name`, `flags` | Yes |
| `names` | Yes | `name` | Yes |
| `comments` | Yes | `comment`, `rpt_comment` | Yes |
| `bookmarks` | Yes | `description` | Yes |
| `segments` | — | `name`, `class`, `perm` | Yes |
| `instructions` | — | — | Yes |
| `types` | Yes | Yes | Yes |
| `types_members` | Yes | Yes | Yes |
| `types_enum_values` | Yes | Yes | Yes |

```sql
-- Create a function at an address (IDA auto-detects boundaries)
INSERT INTO funcs (address) VALUES (0x401000);

-- Create a function with explicit end address and name
INSERT INTO funcs (address, name, end_ea) VALUES (0x401000, 'my_func', 0x401050);

-- Set a name at an address
INSERT INTO names (address, name) VALUES (0x401000, 'main');

-- Add a comment
INSERT INTO comments (address, comment) VALUES (0x401000, 'entry point');

-- Add both regular and repeatable comments
INSERT INTO comments (address, comment, rpt_comment) VALUES (0x401000, 'regular', 'repeatable');

-- Add a bookmark (slot auto-assigned)
INSERT INTO bookmarks (address, description) VALUES (0x401000, 'interesting function');

-- Add a bookmark at a specific slot
INSERT INTO bookmarks (slot, address, description) VALUES (5, 0x401000, 'slot 5 bookmark');

-- Rename a segment
UPDATE segments SET name = '.mytext' WHERE start_ea = 0x401000;

-- Change segment permissions (R=4, W=2, X=1)
UPDATE segments SET perm = 5 WHERE name = '.text';

-- Delete a segment
DELETE FROM segments WHERE name = '.rdata';

-- Delete an instruction (convert to unexplored bytes)
DELETE FROM instructions WHERE address = 0x401000;

-- Create a new struct type
INSERT INTO types (name, kind) VALUES ('my_struct', 'struct');

-- Create an enum type
INSERT INTO types (name, kind) VALUES ('my_flags', 'enum');

-- Add a member to a struct
INSERT INTO types_members (type_ordinal, member_name, member_type) VALUES (42, 'field1', 'int');

-- Add an enum value
INSERT INTO types_enum_values (type_ordinal, value_name, value) VALUES (15, 'FLAG_ACTIVE', 1);
```

## AI Agent

The agent translates natural language to SQL, executes queries, and explains results. It has access to all tables and can perform multi-step analysis.

```
idasql> what functions have the most cross-references?
idasql> find strings that look like file paths
idasql> show me the call hierarchy of main
idasql> which imports are related to networking?
```

See an [example session](examples/agent_session_strings.md) analyzing string references in a binary.

### Prerequisites for AI Features

The AI agent requires one of these CLI tools installed and authenticated:

| Provider | CLI Tool | Install | Login |
|----------|----------|---------|-------|
| Claude (default) | [Claude Code](https://docs.anthropic.com/en/docs/claude-code) | `npm install -g @anthropic-ai/claude-code` | Run `claude`, then `/login` |
| GitHub Copilot | [Copilot CLI](https://github.com/features/copilot/cli/) | `npm install -g @github/copilot` | Run `copilot`, then `/login` |

**Important:** You must be logged in before using AI features. No API keys needed for basic usage.

### Provider Configuration

```
.agent provider claude    # Claude (default)
.agent provider copilot   # GitHub Copilot
```

### Bring Your Own Key (BYOK)

For direct API access or local inference, enable BYOK mode:

```
.agent byok enable
.agent byok type anthropic    # or: openai, azure
.agent byok key sk-ant-...
.agent byok model claude-sonnet-4-20250514
.agent byok endpoint https://api.anthropic.com  # optional
```

With `copilot` provider and BYOK, you can point to local inference servers (Ollama, LM Studio, vLLM) using OpenAI-compatible endpoints:

```
.agent provider copilot
.agent byok enable
.agent byok type openai
.agent byok endpoint http://localhost:11434/v1
.agent byok model llama3
.agent byok key unused
```

Settings persist in `~/.idasql/agent_settings.json`.

## Building

### Prerequisites

- CMake 3.20+
- C++17 compiler
- IDA SDK 9.0+ (set `IDASDK` environment variable)

### CLI

```bash
cmake -S src/cli -B build/cli
cmake --build build/cli --config Release
```

### Plugin

```bash
cmake -S src/plugin -B build/plugin -DIDASQL_WITH_AI_AGENT=ON
cmake --build build/plugin --config Release
```

Output: `$IDASDK/bin/plugins/idasql_plugin.dll`

### Tests

```bash
cmake -S tests -B build/tests
cmake --build build/tests --config Release
ctest --test-dir build/tests -C Release
```

## Remote Server Protocol

The plugin listens on `127.0.0.1:13337` by default. Protocol is length-prefixed JSON over TCP. No MCP, no complex handshakes. A thin CLI client is all you need.

Set `IDASQL_TOKEN` environment variable or let the plugin generate one (printed to IDA Output window on startup).

```bash
# From CLI
idasql --remote localhost:13337 --token <token> -q "SELECT * FROM funcs LIMIT 5"
idasql --remote localhost:13337 --token <token> -i  # Interactive
```

## HTTP REST API

Stateless HTTP server for simple integration. No protocol overhead.

```bash
idasql -s database.i64 --http 8081
```

```bash
curl http://localhost:8081/status
curl -X POST http://localhost:8081/query -d "SELECT name FROM funcs LIMIT 5"
```

For multiple databases, run separate instances:

```bash
idasql -s malware.i64 --http 8081
idasql -s kernel.i64 --http 8082
```

Endpoints: `/status`, `/help`, `/query`, `/shutdown`

### HTTP Server from REPL

Start an HTTP server interactively from the REPL or IDA plugin CLI:

```
idasql -s database.i64 -i
idasql> .http start
HTTP server started on port 8142
URL: http://127.0.0.1:8142
...
Press Ctrl+C to stop and return to REPL.
```

In IDA plugin (non-blocking):
```
idasql> .http start
HTTP server started on port 8142
idasql> .http stop
HTTP server stopped
```

The server uses a random port (8100-8199) to avoid conflicts with `--http`.

## MCP Server

For MCP-compatible clients (Claude Desktop, etc.):

```bash
# Standalone mode
idasql -s database.i64 --mcp
idasql -s database.i64 --mcp 9500  # specific port

# Or in interactive mode
idasql -s database.i64 -i
.mcp start
```

Configure your MCP client:

```json
{
  "mcpServers": {
    "idasql": { "url": "http://127.0.0.1:<port>/sse" }
  }
}
```

Tools: `idasql_query` (direct SQL), `idasql_agent` (natural language)

## Integration with Coding Agents

The CLI is designed for integration with coding agents (Claude Code, Cursor, Aider, Cline, etc.). Agents can query IDA databases directly without writing IDAPython or understanding IDA's API.

### Setup

1. Open your target binary in IDA Pro (plugin loads automatically)
2. Note the auth token printed in IDA's Output window:
   ```
   IDASQL: Auth token generated. Token: 2af05f7152ccc6dd66894c1243f72a2a
   IDASQL: Server listening on 127.0.0.1:13337
   ```
3. The CLI acts as a thin client to query the running IDA instance

### Instructing an Agent

When working with a coding agent on reverse engineering tasks, provide these instructions:

```
IDASQL is running on localhost:13337 with token <token>.

To query the IDA database, use the idasql CLI:

  idasql --remote localhost:13337 --token <token> -q "SQL QUERY"

Available tables: funcs, segments, names, imports, exports, strings, xrefs, instructions, blocks, types

Example queries:
  # List functions
  idasql --remote localhost:13337 --token <token> -q "SELECT name, printf('0x%X', address) as addr FROM funcs LIMIT 20"

  # Find strings containing a keyword
  idasql --remote localhost:13337 --token <token> -q "SELECT * FROM strings WHERE content LIKE '%error%'"

  # Find callers of a function
  idasql --remote localhost:13337 --token <token> -q "SELECT printf('0x%X', from_ea) as caller FROM xrefs WHERE to_ea = 0x401000"

  # Search for any identifier
  idasql --remote localhost:13337 --token <token> -q "SELECT name, kind, address FROM jump_entities('CreateFile', 'prefix') LIMIT 10"
```

### Agent Workflow Example

```
User: "Find all functions that call CreateFileW and check if they handle errors"

Agent thinks: I'll query IDASQL to find the callers

Agent runs:
$ idasql --remote localhost:13337 --token abc123 -q "
  SELECT DISTINCT func_at(x.from_ea) as caller, printf('0x%X', x.from_ea) as call_site
  FROM xrefs x
  JOIN imports i ON x.to_ea = i.address
  WHERE i.name = 'CreateFileW'
"

Agent receives:
| caller              | call_site  |
|---------------------|------------|
| ReadConfigFile      | 0x401234   |
| SaveDocument        | 0x401890   |
| ...                 | ...        |

Agent then queries for error handling patterns in those functions...
```

The agent never needs to write IDAPython. SQL queries are self-contained and portable.

## Claude Code Plugin

IDASQL is available as a Claude Code plugin, allowing Claude to query IDA databases directly within your coding workflow.

### Prerequisites

1. **IDA Pro** installed with `ida.exe` directory in your PATH
2. **idasql.exe** downloaded from [Releases](https://github.com/allthingsida/idasql/releases) and placed next to `ida.exe`
3. Verify setup: `idasql --version` should work from command line

### Installation

```bash
# Add the marketplace (one-time)
/plugin marketplace add 0xeb/anthropic-xsql-tools-plugin

# Install idasql plugin
/plugin install idasql@0xeb-tools
```

### Usage

Once installed, the skill is automatically available:

```
"Using idasql, count functions in myfile.i64"
"Using idasql, decompile main in test.i64"
"Using idasql, find strings containing 'password'"
```

### Updating

```bash
/plugin update idasql
```

### Troubleshooting

**SSH Permission Denied**

If you see `git@github.com: Permission denied (publickey)` during install, configure git to use HTTPS:

```bash
git config --global url."https://github.com/".insteadOf "git@github.com:"
```

## Built With

- **[libxsql](https://github.com/0xeb/libxsql)** - Header-only C++17 library for exposing C++ data structures as SQLite virtual tables. Provides the fluent builder API for defining tables, constraint pushdown, and the socket server/client protocol.

- **[libagents](https://github.com/0xeb/libagents)** - C++ library for building AI agents with tool use. Powers the natural language interface with support for Claude (Anthropic) and GitHub Copilot providers.

## Author

**Elias Bachaalany** ([@0xeb](https://github.com/0xeb))

## License

MIT License - see [LICENSE](LICENSE) for details.

```

`benchmark.md`:

```md
# Build Performance Benchmark

## Environment

- **OS**: Windows 11
- **CPU**: 24 logical processors
- **Compiler**: MSVC (Visual Studio 17.14)
- **CMake**: 4.0.3
- **Config**: Release
- **Features**: All ON (AI Agent, HTTP, Plugin, CLI, Examples)

## Results (clean rebuild, deps already fetched)

| Branch | Build Time | Speedup |
|--------|-----------|---------|
| `main` (baseline) | ~280 sec (4.7 min) | — |
| `build/faster-windows-build` | ~175 sec (2.9 min) | **~38% faster** |

## Changes Applied

### 1. MSVC `/MP` on dependency targets (~80-85 sec saved)
Dependency libraries (fastmcpp_core, copilot_sdk_cpp, claude_sdk, libagents) were compiling
files sequentially because IDA SDK's `/MP` flag only applies to `ida_add_plugin`/`ida_add_idalib`
targets. Adding `/MP` enables multi-processor compilation within each dependency target.

### 2. Unity build on compatible dependency targets (~20-30 sec saved)
Enabled `UNITY_BUILD` for copilot_sdk_cpp, claude_sdk, and libagents. This merges
translation units to reduce redundant header parsing.

**Note**: fastmcpp_core is excluded because its server files (stdio_server.cpp,
sse_server.cpp, streamable_http_server.cpp) use duplicate anonymous-namespace symbols
that conflict under unity builds.

### 3. Pinned dependency versions with `GIT_SHALLOW` (~5-30 sec saved on configure)
Changed `GIT_TAG main` to specific commit SHAs and added `GIT_SHALLOW TRUE` for both
libxsql and libagents. This avoids re-fetching on every configure and reduces clone size.

### 4. Excluded unused targets
The `debug` tool from claude-agent-sdk-cpp is excluded from the default build via
`EXCLUDE_FROM_ALL`.

## Not Yet Applied (potential further improvements)

- **PCH for idasql targets**: Precompiled headers for CLI/plugin/examples could save
  another ~50-60 sec by eliminating redundant IDA SDK + xsql header parsing.
- **libxsql partial de-header-only**: Moving non-template code to .cpp files would
  reduce per-TU compile cost. Requires upstream libxsql changes.

```

`examples/CMakeLists.txt`:

```txt
# examples/CMakeLists.txt - IDASQL Example Programs
#
# Standalone build:
#   cmake -B build
#   cmake --build build --config Release
#
# Run:
#   Windows: set PATH=%IDASDK%\src\bin;%PATH%
#            build\Release\example_basic.exe database.i64
#   Linux:   LD_LIBRARY_PATH=$IDASDK/src/bin ./build/example_basic database.i64

# Standalone mode: set up project and dependencies
if(CMAKE_SOURCE_DIR STREQUAL CMAKE_CURRENT_SOURCE_DIR)
    cmake_minimum_required(VERSION 3.20)
    project(idasql_examples VERSION 1.0 LANGUAGES C CXX)
    set(CMAKE_CXX_STANDARD 20)
    set(CMAKE_CXX_STANDARD_REQUIRED ON)

    # Include IDA SDK bootstrap
    include($ENV{IDASDK}/src/cmake/bootstrap.cmake)
    find_package(idasdk REQUIRED)
endif()

# ============================================================================
# xsql dependency (provides SQLite)
# ============================================================================

if(TARGET xsql::xsql)
    message(STATUS "idasql_examples: Using xsql::xsql from parent project")
elseif(EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/../external/libxsql/CMakeLists.txt")
    add_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/../external/libxsql ${CMAKE_CURRENT_BINARY_DIR}/libxsql)
    message(STATUS "idasql_examples: Added libxsql from external/libxsql")
else()
    message(FATAL_ERROR "libxsql not found. Initialize submodule: git submodule update --init external/libxsql")
endif()

# libidasql interface library (headers only)
add_library(idasql_lib INTERFACE)
target_include_directories(idasql_lib INTERFACE
    ${CMAKE_CURRENT_SOURCE_DIR}/../src/lib/include
)

# Helper function to create examples
function(add_idasql_example name)
    ida_add_idalib(${name}
        TYPE EXECUTABLE
        SOURCES ${name}.cpp
    )
    target_link_libraries(${name} PRIVATE idasql_lib xsql::xsql)
    target_compile_definitions(${name} PRIVATE USE_IDA_SDK USE_HEXRAYS)

    # Platform-specific settings
    if(MSVC)
        file(TO_NATIVE_PATH "${IDABIN}" IDABIN_NATIVE)
        set_target_properties(${name} PROPERTIES
            VS_DEBUGGER_ENVIRONMENT "PATH=${IDABIN_NATIVE};%PATH%"
        )
    elseif(APPLE)
        set_target_properties(${name} PROPERTIES
            BUILD_WITH_INSTALL_RPATH TRUE
            INSTALL_RPATH "@executable_path;$ENV{IDASDK}/src/bin"
        )
    elseif(UNIX)
        set_target_properties(${name} PROPERTIES
            BUILD_WITH_INSTALL_RPATH TRUE
            INSTALL_RPATH "$ORIGIN;$ENV{IDASDK}/src/bin"
        )
    endif()
endfunction()

# Example executables
add_idasql_example(example_basic)
add_idasql_example(example_functions)
add_idasql_example(example_strings)
add_idasql_example(example_instructions)
add_idasql_example(example_decompiler)
add_idasql_example(example_custom_vtable)
add_idasql_example(example_plugin_style)
add_idasql_example(example_jump_search)
add_idasql_example(example_jump_entities)
add_idasql_example(example_breakpoints)

```

`examples/agent_session_strings.md`:

```md
# IDASQL Agent Session: String Analysis

This transcript demonstrates IDASQL's AI agent analyzing string references in a binary.

---

```
IDASQL: Query engine initialized
IDASQL: Auth token generated (set IDASQL_TOKEN to override). Token: 6ce6213e59626ebadc269aebee634240
IDASQL CLI: Installed (AI agent: enabled)
-----------------------------------------------------------------------------------------
Python 3.12.4 (tags/v3.12.4:8e8a4ba, Jun  6 2024, 19:30:16) [MSC v.1940 64 bit (AMD64)]
IDAPython 64-bit v9.2.0 (c) The IDAPython Team <idapython@googlegroups.com>
-----------------------------------------------------------------------------------------
```

**User:** Which function refers to strings the most?

**Agent:** The function that refers to strings the most is **`main`** with **13 string references**.

Here's a summary of the top string-referencing functions:

| Function | String References |
|----------|-------------------|
| `main` | 13 |
| `__acrt_fltout` | 4 |
| `unknown_libname_26` | 2 |
| `__vcrt_InitializeCriticalSectionEx` | 2 |
| `__vcrt_FlsSetValue` | 2 |
| `__vcrt_FlsGetValue` | 2 |
| `__vcrt_FlsFree` | 2 |
| `__vcrt_FlsAlloc` | 2 |

The `main` function stands out significantly with more than 3x the string references of the next highest function, suggesting it likely contains significant user-facing logic with messages, prompts, or configuration strings.

---

**User:** What string does "main" refer to?

**Agent:** The `main` function refers to these 13 strings:

| String | Purpose |
|--------|---------|
| `--pause` | Command-line argument |
| `-monoff` | Monitor off command |
| `-abortshutdown` | Abort shutdown command |
| `-play` | Play command |
| `-lock` | Lock workstation command |
| `-hibernate` | Hibernate command |
| `-logoff` | Log off command |
| `-mute` | Mute audio command |
| `-reboot` | Reboot command |
| `-blank` | Blank screen command |
| `-eject` | Eject media command |
| `-close` | Close command |
| `Invalid usage!\n` | Error message |

This reveals that the binary is a **command-line utility** for system control operations. It parses various command-line arguments to perform actions like:
- Power management: hibernate, reboot, shutdown abort
- Display control: monitor off, blank screen
- Session control: lock, logoff
- Media control: play, mute, eject

The `Invalid usage!` string is displayed when none of the valid arguments are provided.

---

**User:** List all those strings used in main in a nice table and their addresses

**Agent:** Here are all the strings used in `main`:

| String Address | Reference Address | String Content |
|----------------|-------------------|----------------|
| 0x140017410 | 0x140001064 | `--pause` |
| 0x140017418 | 0x1400010B2 | `-monoff` |
| 0x140017420 | 0x1400010DA | `-abortshutdown` |
| 0x140017430 | 0x140001103 | `-play` |
| 0x140017438 | 0x14000112A | `-lock` |
| 0x140017440 | 0x14000114E | `-hibernate` |
| 0x140017450 | 0x140001172 | `-logoff` |
| 0x140017458 | 0x140001196 | `-mute` |
| 0x140017460 | 0x1400011CB | `-reboot` |
| 0x140017468 | 0x1400011EF | `-blank` |
| 0x140017470 | 0x140001215 | `-eject` |
| 0x140017478 | 0x14000123D | `-close` |
| 0x140017480 | 0x140001264 | `Invalid usage!` |

The strings are stored sequentially in the `.rdata` section starting at `0x140017410`, and are referenced in order within the `main` function from `0x140001064` to `0x140001264`.

```

`examples/example_basic.cpp`:

```cpp
/**
 * example_basic.cpp - Basic IDASQL usage with Session
 *
 * Demonstrates:
 *   - Opening an IDA database with Session
 *   - Running queries with query() and getting results
 *   - Using scalar() for single values
 *   - Iterating over result rows
 *
 * This is the pattern for standalone CLI tools that manage the IDA lifecycle.
 *
 * Build & Run:
 *   cmake -B build && cmake --build build --config Release
 *   set PATH=%IDASDK%\bin;%PATH%
 *   build\Release\example_basic.exe database.i64
 */

#include <iostream>
#include <idasql/database.hpp>

int main(int argc, char* argv[]) {
    if (argc < 2) {
        std::cerr << "Usage: " << argv[0] << " <database.i64>\n";
        return 1;
    }

    // ==========================================================================
    // Open the IDA database using Session
    // ==========================================================================

    idasql::Session session;

    std::cout << "Opening: " << argv[1] << "...\n";
    if (!session.open(argv[1])) {
        std::cerr << "Error: " << session.error() << "\n";
        return 1;
    }

    std::cout << "\n" << session.info() << "\n";

    // ==========================================================================
    // Example 1: Get a single value with scalar()
    // ==========================================================================

    std::cout << "=== Scalar Queries ===\n";

    std::string func_count = session.scalar("SELECT COUNT(*) FROM funcs");
    std::cout << "Total functions: " << func_count << "\n";

    std::string segment_count = session.scalar("SELECT COUNT(*) FROM segments");
    std::cout << "Total segments: " << segment_count << "\n";

    // ==========================================================================
    // Example 2: Query with result set
    // ==========================================================================

    std::cout << "\n=== Top 5 Largest Functions ===\n";

    auto result = session.query(
        "SELECT printf('0x%08X', address) as addr, name, size "
        "FROM funcs ORDER BY size DESC LIMIT 5"
    );

    if (result.success) {
        // Print column headers
        for (const auto& col : result.columns) {
            std::cout << col << "\t";
        }
        std::cout << "\n" << std::string(50, '-') << "\n";

        // Print rows
        for (const auto& row : result) {
            std::cout << row[0] << "\t" << row[1] << "\t" << row[2] << "\n";
        }
        std::cout << "\n(" << result.row_count() << " rows)\n";
    } else {
        std::cerr << "Query failed: " << result.error << "\n";
    }

    // ==========================================================================
    // Example 3: Segments listing
    // ==========================================================================

    std::cout << "\n=== Segments ===\n";

    auto segments = session.query(
        "SELECT name, printf('0x%X', start_ea) as start, "
        "       printf('0x%X', end_ea) as end, perm "
        "FROM segments"
    );

    for (const auto& row : segments) {
        std::cout << row[0] << ": " << row[1] << " - " << row[2]
                  << " (perm: " << row[3] << ")\n";
    }

    // ==========================================================================
    // Example 4: Using SQL functions
    // ==========================================================================

    std::cout << "\n=== SQL Functions ===\n";

    // Get function at specific index
    auto first_func = session.query(
        "SELECT printf('0x%X', func_at_index(0)) as addr, "
        "       func_at(func_at_index(0)) as name"
    );
    if (!first_func.empty()) {
        std::cout << "First function: " << first_func.rows[0][1]
                  << " at " << first_func.rows[0][0] << "\n";
    }

    // Cleanup (optional - destructor handles it)
    session.close();

    std::cout << "\nDone.\n";
    return 0;
}

```

`examples/example_breakpoints.cpp`:

```cpp
/**
 * example_breakpoints.cpp - Breakpoint management with IDASQL
 *
 * Demonstrates:
 *   - Querying the breakpoints table
 *   - Adding software and hardware breakpoints via INSERT
 *   - Disabling breakpoints via UPDATE
 *   - Deleting breakpoints via DELETE
 *   - Joining breakpoints with funcs
 *
 * Breakpoints persist in the IDB even without an active debugger session.
 *
 * Build & Run:
 *   cmake -B build && cmake --build build --config Release
 *   set PATH=%IDASDK%\bin;%PATH%
 *   build\Release\example_breakpoints.exe database.i64
 */

#include <iostream>
#include <iomanip>
#include <idasql/database.hpp>

int main(int argc, char* argv[]) {
    if (argc < 2) {
        std::cerr << "Usage: " << argv[0] << " <database.i64>\n";
        return 1;
    }

    idasql::Session session;

    std::cout << "Opening: " << argv[1] << "...\n";
    if (!session.open(argv[1])) {
        std::cerr << "Error: " << session.error() << "\n";
        return 1;
    }

    // =========================================================================
    // 1. List existing breakpoints
    // =========================================================================

    std::cout << "=== Existing Breakpoints ===\n";

    auto existing = session.query(
        "SELECT printf('0x%08X', address) as addr, type_name, enabled, "
        "       loc_type_name, condition, \"group\" "
        "FROM breakpoints"
    );

    if (existing.empty()) {
        std::cout << "(none)\n";
    } else {
        for (const auto& row : existing) {
            std::cout << row[0] << "  " << std::setw(16) << row[1]
                      << "  enabled=" << row[2]
                      << "  loc=" << row[3] << "\n";
        }
    }

    // =========================================================================
    // 2. Add two breakpoints at the first two function addresses
    // =========================================================================

    std::cout << "\n=== Adding Breakpoints ===\n";

    // Get two function addresses to use
    auto funcs = session.query(
        "SELECT address, name FROM funcs ORDER BY address LIMIT 2"
    );

    if (funcs.row_count() < 2) {
        std::cerr << "Need at least 2 functions in database\n";
        return 1;
    }

    std::string addr1 = funcs.rows[0][0];
    std::string name1 = funcs.rows[0][1];
    std::string addr2 = funcs.rows[1][0];
    std::string name2 = funcs.rows[1][1];

    // Insert a software breakpoint at the first function
    auto r1 = session.query(
        "INSERT INTO breakpoints (address) VALUES (" + addr1 + ")"
    );
    std::cout << "Added software breakpoint at " << name1 << "\n";

    // Insert a hardware write watchpoint at the second function
    auto r2 = session.query(
        "INSERT INTO breakpoints (address, type, size) VALUES (" + addr2 + ", 1, 4)"
    );
    std::cout << "Added hardware watchpoint at " << name2 << "\n";

    // Show what we have
    auto after_add = session.query(
        "SELECT printf('0x%08X', address) as addr, type_name, enabled, size "
        "FROM breakpoints"
    );

    std::cout << "\nBreakpoints after adding:\n";
    std::cout << std::left
              << std::setw(14) << "Address"
              << std::setw(18) << "Type"
              << std::setw(10) << "Enabled"
              << std::setw(6)  << "Size" << "\n";
    std::cout << std::string(48, '-') << "\n";

    for (const auto& row : after_add) {
        std::cout << std::setw(14) << row[0]
                  << std::setw(18) << row[1]
                  << std::setw(10) << row[2]
                  << std::setw(6)  << row[3] << "\n";
    }

    // =========================================================================
    // 3. Disable the second breakpoint
    // =========================================================================

    std::cout << "\n=== Disabling Second Breakpoint ===\n";

    session.query(
        "UPDATE breakpoints SET enabled = 0 WHERE address = " + addr2
    );

    auto after_disable = session.query(
        "SELECT printf('0x%08X', address) as addr, enabled, type_name "
        "FROM breakpoints"
    );

    for (const auto& row : after_disable) {
        std::cout << row[0] << "  enabled=" << row[1]
                  << "  " << row[2] << "\n";
    }

    // =========================================================================
    // 4. Delete the first breakpoint
    // =========================================================================

    std::cout << "\n=== Deleting First Breakpoint ===\n";

    session.query(
        "DELETE FROM breakpoints WHERE address = " + addr1
    );

    auto after_delete = session.query(
        "SELECT printf('0x%08X', address) as addr, enabled, type_name, size "
        "FROM breakpoints"
    );

    std::cout << "Remaining breakpoints: " << after_delete.row_count() << "\n";
    for (const auto& row : after_delete) {
        std::cout << row[0] << "  enabled=" << row[1]
                  << "  " << row[2] << "  size=" << row[3] << "\n";
    }

    // =========================================================================
    // 5. Clean up
    // =========================================================================

    session.query("DELETE FROM breakpoints WHERE address = " + addr2);
    std::cout << "\nCleaned up. Final count: "
              << session.scalar("SELECT COUNT(*) FROM breakpoints")
              << " breakpoints.\n";

    std::cout << "\nDone.\n";
    return 0;
}

```

`examples/example_custom_vtable.cpp`:

```cpp
/**
 * example_custom_vtable.cpp - Creating custom virtual tables
 *
 * This example shows how to expose your own data as SQL tables.
 * We'll create a simple "user_functions" table that mirrors the built-in
 * funcs table, demonstrating the pattern you'd use for any custom data.
 *
 * Key concepts:
 *   1. Use VTableBuilder fluent API to define columns
 *   2. Register the module, then create the table instance
 *   3. Query with standard SQL
 */

#include <iostream>
#include <iomanip>

#include <idasql/database.hpp>
#include <idasql/vtable.hpp>

// IDA SDK
#include <funcs.hpp>
#include <name.hpp>

// =============================================================================
// Step 1: Define your table using the fluent API
// =============================================================================

idasql::VTableDef make_user_functions_table() {
    return idasql::table("user_functions")
        // How many rows?
        .count([]() -> size_t {
            return get_func_qty();
        })
        // Column definitions - each takes a lambda (row_index) -> value
        .column_int64("address", [](size_t i) -> int64_t {
            func_t* f = getn_func(i);
            return f ? f->start_ea : BADADDR;
        })
        .column_text("name", [](size_t i) -> std::string {
            func_t* f = getn_func(i);
            if (!f) return "";
            qstring name;
            get_func_name(&name, f->start_ea);
            return std::string(name.c_str());
        })
        .column_int64("size", [](size_t i) -> int64_t {
            func_t* f = getn_func(i);
            return f ? f->size() : 0;
        })
        .column_int("flags", [](size_t i) -> int {
            func_t* f = getn_func(i);
            return f ? f->flags : 0;
        })
        .build();
}

// =============================================================================
// Main
// =============================================================================

int main(int argc, char* argv[]) {
    if (argc < 2) {
        std::cerr << "Usage: " << argv[0] << " <database.i64>\n";
        return 1;
    }

    // Open the IDA database
    idasql::Session session;
    if (!session.open(argv[1])) {
        std::cerr << "Error: " << session.error() << "\n";
        return 1;
    }

    // Get SQLite handle for registration
    sqlite3* db = session.handle();

    // =========================================================================
    // Step 2: Register your custom table
    // =========================================================================

    // Create the table definition (must outlive the registration)
    static auto user_funcs_def = make_user_functions_table();

    // Register the vtable module with SQLite
    idasql::register_vtable(db, "user_functions_module", &user_funcs_def);

    // Create the actual table instance
    idasql::create_vtable(db, "user_functions", "user_functions_module");

    std::cout << "Registered custom table: user_functions\n\n";

    // =========================================================================
    // Step 3: Query your custom table with SQL
    // =========================================================================

    std::cout << "=== Query: user_functions (Top 10 by size) ===\n\n";

    auto result = session.query(
        "SELECT printf('0x%X', address) as addr, name, size, flags "
        "FROM user_functions "
        "ORDER BY size DESC "
        "LIMIT 10"
    );

    // Print results
    std::cout << std::left
              << std::setw(14) << "Address"
              << std::setw(35) << "Name"
              << std::setw(10) << "Size"
              << "Flags\n";
    std::cout << std::string(65, '-') << "\n";

    for (const auto& row : result) {
        std::cout << std::setw(14) << row[0]
                  << std::setw(35) << row[1].substr(0, 33)
                  << std::setw(10) << row[2]
                  << row[3] << "\n";
    }

    // =========================================================================
    // Bonus: Join custom table with built-in tables
    // =========================================================================

    std::cout << "\n=== Join: user_functions + xrefs (most called) ===\n\n";

    auto most_called = session.query(
        "SELECT uf.name, COUNT(x.from_ea) as call_count "
        "FROM user_functions uf "
        "JOIN xrefs x ON uf.address = x.to_ea "
        "WHERE x.type = 17 "  // Code call xref
        "GROUP BY uf.address "
        "ORDER BY call_count DESC "
        "LIMIT 10"
    );

    for (const auto& row : most_called) {
        std::cout << std::setw(40) << row[0]
                  << " called " << row[1] << " times\n";
    }

    std::cout << "\nDone.\n";
    return 0;
}

```

`examples/example_decompiler.cpp`:

```cpp
/**
 * example_decompiler.cpp - Hex-Rays decompiler analysis with IDASQL
 *
 * Demonstrates:
 *   - Querying pseudocode table (line-by-line access)
 *   - Querying ctree_lvars table (local variables)
 *   - Using decompile() SQL function (full text)
 *   - Finding patterns in decompiled code
 *
 * Requires: Hex-Rays decompiler license
 */

#include <iostream>
#include <iomanip>
#include <idasql/database.hpp>

int main(int argc, char* argv[]) {
    if (argc < 2) {
        std::cerr << "Usage: " << argv[0] << " <database.i64>\n";
        std::cerr << "\nNote: Requires Hex-Rays decompiler license.\n";
        return 1;
    }

    idasql::Session session;
    if (!session.open(argv[1])) {
        std::cerr << "Error: " << session.error() << "\n";
        return 1;
    }

    // =========================================================================
    // Decompiler availability check
    // =========================================================================

    std::cout << "=== Decompiler Analysis ===\n\n";

    // Try to decompile a function to check if Hex-Rays is available
    auto test = session.query("SELECT decompile(func_at_index(0)) as code");
    if (!test.success || test.empty() || test.rows[0][0].find("Decompiler") != std::string::npos) {
        std::cerr << "Warning: Hex-Rays decompiler may not be available.\n";
        std::cerr << "Some queries may fail or return empty results.\n\n";
    }

    // =========================================================================
    // Functions by pseudocode line count
    // =========================================================================

    std::cout << "=== Functions by Pseudocode Complexity ===\n";

    auto complex = session.query(
        "SELECT "
        "  func_at(func_addr) as name, "
        "  COUNT(*) as lines "
        "FROM pseudocode "
        "GROUP BY func_addr "
        "ORDER BY lines DESC "
        "LIMIT 10"
    );

    std::cout << std::setw(40) << "Function" << "Lines\n";
    std::cout << std::string(50, '-') << "\n";
    for (const auto& row : complex) {
        std::cout << std::setw(40) << row[0] << row[1] << "\n";
    }

    // =========================================================================
    // Functions with most local variables
    // =========================================================================

    std::cout << "\n=== Functions with Most Local Variables ===\n";

    auto most_vars = session.query(
        "SELECT "
        "  func_at(func_addr) as name, "
        "  COUNT(*) as total_vars, "
        "  SUM(CASE WHEN is_arg = 1 THEN 1 ELSE 0 END) as args, "
        "  SUM(CASE WHEN is_arg = 0 THEN 1 ELSE 0 END) as locals "
        "FROM ctree_lvars "
        "GROUP BY func_addr "
        "ORDER BY total_vars DESC "
        "LIMIT 10"
    );

    std::cout << std::setw(35) << "Function"
              << std::setw(8) << "Total"
              << std::setw(8) << "Args"
              << "Locals\n";
    std::cout << std::string(60, '-') << "\n";
    for (const auto& row : most_vars) {
        std::cout << std::setw(35) << row[0]
                  << std::setw(8) << row[1]
                  << std::setw(8) << row[2]
                  << row[3] << "\n";
    }

    // =========================================================================
    // Variable type analysis
    // =========================================================================

    std::cout << "\n=== Most Common Variable Types ===\n";

    auto var_types = session.query(
        "SELECT type, COUNT(*) as count "
        "FROM ctree_lvars "
        "WHERE type != '' "
        "GROUP BY type "
        "ORDER BY count DESC "
        "LIMIT 15"
    );

    for (const auto& row : var_types) {
        std::cout << std::setw(30) << row[0] << " - " << row[1] << " occurrences\n";
    }

    // =========================================================================
    // Show pseudocode for a specific function
    // =========================================================================

    std::cout << "\n=== Pseudocode for Largest Function (first 30 lines) ===\n";

    auto largest = session.scalar("SELECT address FROM funcs ORDER BY size DESC LIMIT 1");
    std::string pseudocode_sql =
        "SELECT line "
        "FROM pseudocode "
        "WHERE func_addr = " + largest + " "
        "ORDER BY line_num "
        "LIMIT 30";
    auto pseudocode = session.query(pseudocode_sql.c_str());

    for (const auto& row : pseudocode) {
        std::cout << row[0] << "\n";
    }

    // =========================================================================
    // Local variables for a function
    // =========================================================================

    std::cout << "\n=== Variables in Largest Function ===\n";

    std::string vars_sql =
        "SELECT name, type, size, "
        "       CASE WHEN is_arg = 1 THEN 'arg' ELSE 'local' END as kind "
        "FROM ctree_lvars "
        "WHERE func_addr = " + largest + " "
        "ORDER BY is_arg DESC, idx";
    auto vars = session.query(vars_sql.c_str());

    std::cout << std::setw(20) << "Name"
              << std::setw(25) << "Type"
              << std::setw(8) << "Size"
              << "Kind\n";
    std::cout << std::string(60, '-') << "\n";
    for (const auto& row : vars) {
        std::cout << std::setw(20) << row[0]
                  << std::setw(25) << row[1]
                  << std::setw(8) << row[2]
                  << row[3] << "\n";
    }

    // =========================================================================
    // Full decompilation with decompile() function
    // =========================================================================

    std::cout << "\n=== Using decompile() SQL Function ===\n";

    // Find main function
    auto main_addr = session.scalar(
        "SELECT address FROM funcs WHERE name LIKE '%main%' LIMIT 1"
    );

    if (!main_addr.empty()) {
        std::cout << "Decompiling main function:\n\n";
        auto code = session.scalar("SELECT decompile(" + main_addr + ")");
        std::cout << code << "\n";
    } else {
        std::cout << "No 'main' function found.\n";
    }

    // =========================================================================
    // Search pseudocode for patterns
    // =========================================================================

    std::cout << "\n=== Lines Containing 'if' Statements ===\n";

    auto if_lines = session.query(
        "SELECT func_at(func_addr) as func, line "
        "FROM pseudocode "
        "WHERE line LIKE '%if (%' "
        "LIMIT 10"
    );

    for (const auto& row : if_lines) {
        std::cout << "[" << row[0] << "] " << row[1] << "\n";
    }

    std::cout << "\nDone.\n";
    return 0;
}

```

`examples/example_functions.cpp`:

```cpp
/**
 * example_functions.cpp - Function analysis with IDASQL
 *
 * Demonstrates:
 *   - Querying the funcs table
 *   - Using xrefs for call graph analysis
 *   - Using blocks for CFG analysis
 *   - Combining tables with JOINs
 */

#include <iostream>
#include <iomanip>
#include <idasql/database.hpp>

int main(int argc, char* argv[]) {
    if (argc < 2) {
        std::cerr << "Usage: " << argv[0] << " <database.i64>\n";
        return 1;
    }

    idasql::Session session;
    if (!session.open(argv[1])) {
        std::cerr << "Error: " << session.error() << "\n";
        return 1;
    }

    // =========================================================================
    // Function size distribution
    // =========================================================================

    std::cout << "=== Function Size Distribution ===\n";

    auto dist = session.query(
        "SELECT "
        "  CASE "
        "    WHEN size < 16 THEN '1. tiny (<16)' "
        "    WHEN size < 64 THEN '2. small (16-64)' "
        "    WHEN size < 256 THEN '3. medium (64-256)' "
        "    WHEN size < 1024 THEN '4. large (256-1K)' "
        "    ELSE '5. huge (>1K)' "
        "  END as category, "
        "  COUNT(*) as count, "
        "  SUM(size) as total_bytes "
        "FROM funcs "
        "GROUP BY category "
        "ORDER BY category"
    );

    std::cout << std::left << std::setw(20) << "Category"
              << std::setw(10) << "Count"
              << std::setw(15) << "Total Bytes" << "\n";
    std::cout << std::string(45, '-') << "\n";

    for (const auto& row : dist) {
        std::cout << std::setw(20) << row[0]
                  << std::setw(10) << row[1]
                  << std::setw(15) << row[2] << "\n";
    }

    // =========================================================================
    // Most called functions (incoming xrefs)
    // =========================================================================

    std::cout << "\n=== Top 10 Most Called Functions ===\n";

    auto most_called = session.query(
        "SELECT f.name, COUNT(*) as callers "
        "FROM funcs f "
        "JOIN xrefs x ON f.address = x.to_ea "
        "WHERE x.is_code = 1 "
        "GROUP BY f.address "
        "ORDER BY callers DESC "
        "LIMIT 10"
    );

    for (const auto& row : most_called) {
        std::cout << std::setw(40) << row[0] << " - " << row[1] << " callers\n";
    }

    // =========================================================================
    // Functions making most calls (outgoing)
    // =========================================================================

    std::cout << "\n=== Top 10 Functions Making Most Calls ===\n";

    auto most_calls = session.query(
        "SELECT func_at(func_addr) as name, COUNT(*) as calls "
        "FROM instructions "
        "WHERE mnemonic = 'call' "
        "GROUP BY func_addr "
        "ORDER BY calls DESC "
        "LIMIT 10"
    );

    for (const auto& row : most_calls) {
        std::cout << std::setw(40) << row[0] << " - " << row[1] << " calls\n";
    }

    // =========================================================================
    // Functions with most basic blocks (complex CFG)
    // =========================================================================

    std::cout << "\n=== Top 10 Functions by Basic Block Count ===\n";

    auto complex = session.query(
        "SELECT "
        "  (SELECT name FROM funcs WHERE address = b.func_ea) as name, "
        "  COUNT(*) as blocks, "
        "  SUM(b.size) as total_size "
        "FROM blocks b "
        "GROUP BY b.func_ea "
        "ORDER BY blocks DESC "
        "LIMIT 10"
    );

    std::cout << std::setw(40) << "Function"
              << std::setw(10) << "Blocks"
              << std::setw(12) << "Size" << "\n";
    std::cout << std::string(62, '-') << "\n";

    for (const auto& row : complex) {
        std::cout << std::setw(40) << row[0]
                  << std::setw(10) << row[1]
                  << std::setw(12) << row[2] << "\n";
    }

    // =========================================================================
    // "Leaf" functions (no outgoing calls)
    // =========================================================================

    std::cout << "\n=== Leaf Functions (no calls, first 10) ===\n";

    auto leaves = session.query(
        "SELECT f.name, f.size "
        "FROM funcs f "
        "WHERE NOT EXISTS ("
        "  SELECT 1 FROM instructions i "
        "  WHERE i.func_addr = f.address AND i.mnemonic = 'call'"
        ") "
        "ORDER BY f.size DESC "
        "LIMIT 10"
    );

    for (const auto& row : leaves) {
        std::cout << std::setw(40) << row[0] << " (" << row[1] << " bytes)\n";
    }

    // =========================================================================
    // Orphan functions (no incoming xrefs)
    // =========================================================================

    std::cout << "\n=== Orphan Functions (no callers, first 10) ===\n";

    auto orphans = session.query(
        "SELECT f.name, printf('0x%X', f.address) as addr "
        "FROM funcs f "
        "WHERE NOT EXISTS ("
        "  SELECT 1 FROM xrefs x WHERE x.to_ea = f.address AND x.is_code = 1"
        ") "
        "LIMIT 10"
    );

    for (const auto& row : orphans) {
        std::cout << row[0] << " at " << row[1] << "\n";
    }

    std::cout << "\nDone.\n";
    return 0;
}

```

`examples/example_instructions.cpp`:

```cpp
/**
 * example_instructions.cpp - Instruction analysis with IDASQL
 *
 * Demonstrates:
 *   - Querying the instructions table
 *   - Mnemonic distribution analysis
 *   - Finding specific instruction patterns
 *   - Using itype for instruction classification
 */

#include <iostream>
#include <iomanip>
#include <idasql/database.hpp>

int main(int argc, char* argv[]) {
    if (argc < 2) {
        std::cerr << "Usage: " << argv[0] << " <database.i64>\n";
        return 1;
    }

    idasql::Session session;
    if (!session.open(argv[1])) {
        std::cerr << "Error: " << session.error() << "\n";
        return 1;
    }

    // =========================================================================
    // Instruction statistics
    // =========================================================================

    std::cout << "=== Instruction Statistics ===\n";

    // Get stats for the largest function
    auto largest_func = session.scalar("SELECT address FROM funcs ORDER BY size DESC LIMIT 1");
    std::cout << "Analyzing largest function at 0x" << std::hex << std::stoull(largest_func) << std::dec << "\n\n";

    // =========================================================================
    // Mnemonic distribution
    // =========================================================================

    std::cout << "=== Top 20 Most Common Instructions ===\n";

    auto mnemonics = session.query(
        "SELECT mnemonic, COUNT(*) as count "
        "FROM instructions "
        "GROUP BY mnemonic "
        "ORDER BY count DESC "
        "LIMIT 20"
    );

    std::cout << std::left << std::setw(15) << "Mnemonic" << std::setw(10) << "Count" << "\n";
    std::cout << std::string(25, '-') << "\n";

    for (const auto& row : mnemonics) {
        std::cout << std::setw(15) << row[0] << std::setw(10) << row[1] << "\n";
    }

    // =========================================================================
    // Call targets analysis
    // =========================================================================

    std::cout << "\n=== Most Common Call Targets ===\n";

    auto calls = session.query(
        "SELECT operand0, COUNT(*) as count "
        "FROM instructions "
        "WHERE mnemonic = 'call' "
        "GROUP BY operand0 "
        "ORDER BY count DESC "
        "LIMIT 15"
    );

    for (const auto& row : calls) {
        std::cout << std::setw(40) << row[0] << " - called " << row[1] << " times\n";
    }

    // =========================================================================
    // Functions with most NOP instructions (padding/alignment)
    // =========================================================================

    std::cout << "\n=== Functions with Most NOPs ===\n";

    auto nops = session.query(
        "SELECT func_at(func_addr) as name, COUNT(*) as nop_count "
        "FROM instructions "
        "WHERE mnemonic = 'nop' "
        "GROUP BY func_addr "
        "HAVING nop_count > 5 "
        "ORDER BY nop_count DESC "
        "LIMIT 10"
    );

    for (const auto& row : nops) {
        std::cout << std::setw(40) << row[0] << " - " << row[1] << " NOPs\n";
    }

    // =========================================================================
    // Jump instruction analysis
    // =========================================================================

    std::cout << "\n=== Jump Instruction Distribution ===\n";

    auto jumps = session.query(
        "SELECT mnemonic, COUNT(*) as count "
        "FROM instructions "
        "WHERE mnemonic LIKE 'j%' "  // All jump variants
        "GROUP BY mnemonic "
        "ORDER BY count DESC"
    );

    for (const auto& row : jumps) {
        std::cout << std::setw(10) << row[0] << " - " << row[1] << "\n";
    }

    // =========================================================================
    // Suspicious patterns (potential obfuscation)
    // =========================================================================

    std::cout << "\n=== Potential Obfuscation Patterns ===\n";

    // Functions with unusual push/pop ratio
    auto unusual = session.query(
        "SELECT "
        "  func_at(func_addr) as name, "
        "  SUM(CASE WHEN mnemonic = 'push' THEN 1 ELSE 0 END) as pushes, "
        "  SUM(CASE WHEN mnemonic = 'pop' THEN 1 ELSE 0 END) as pops "
        "FROM instructions "
        "GROUP BY func_addr "
        "HAVING pushes > 20 AND ABS(pushes - pops) > 5 "
        "ORDER BY pushes DESC "
        "LIMIT 10"
    );

    std::cout << std::setw(40) << "Function" << std::setw(10) << "Pushes" << "Pops\n";
    std::cout << std::string(60, '-') << "\n";
    for (const auto& row : unusual) {
        std::cout << std::setw(40) << row[0] << std::setw(10) << row[1] << row[2] << "\n";
    }

    // =========================================================================
    // Instruction type (itype) analysis
    // =========================================================================

    std::cout << "\n=== Instruction Types (itype) ===\n";
    std::cout << "(itype 16/17/18 = call variants, 56-111 = jumps)\n\n";

    auto itypes = session.query(
        "SELECT itype, mnemonic, COUNT(*) as count "
        "FROM instructions "
        "WHERE itype IN (16, 17, 18, 56, 57, 58, 59, 60) "  // calls and common jumps
        "GROUP BY itype "
        "ORDER BY count DESC"
    );

    std::cout << std::setw(8) << "itype" << std::setw(12) << "Mnemonic" << "Count\n";
    std::cout << std::string(30, '-') << "\n";
    for (const auto& row : itypes) {
        std::cout << std::setw(8) << row[0] << std::setw(12) << row[1] << row[2] << "\n";
    }

    // =========================================================================
    // Instructions in a specific function
    // =========================================================================

    std::cout << "\n=== Instructions in Largest Function ===\n";

    auto func_insns = session.query(
        "SELECT mnemonic, COUNT(*) as count "
        "FROM instructions "
        "WHERE func_addr = (SELECT address FROM funcs ORDER BY size DESC LIMIT 1) "
        "GROUP BY mnemonic "
        "ORDER BY count DESC "
        "LIMIT 10"
    );

    for (const auto& row : func_insns) {
        std::cout << std::setw(12) << row[0] << " - " << row[1] << "\n";
    }

    std::cout << "\nDone.\n";
    return 0;
}

```

`examples/example_jump_entities.cpp`:

```cpp
/**
 * example_jump_entities.cpp - "Jump to Anything" with table-valued function
 *
 * Demonstrates the jump_entities virtual table for unified entity search.
 * Unlike jump_search() which returns JSON, jump_entities returns proper
 * table rows that can be composed with full SQL.
 *
 * Demonstrates:
 *   - Basic entity search with prefix/contains modes
 *   - Filtering by entity kind (function, struct, member, etc.)
 *   - JOINs with other tables for enriched data
 *   - Pagination for virtual scrolling
 *   - Aggregations and grouping
 */

#include <iostream>
#include <iomanip>
#include <idasql/database.hpp>

int main(int argc, char* argv[]) {
    if (argc < 2) {
        std::cerr << "Usage: " << argv[0] << " <database.i64> [search_prefix]\n";
        return 1;
    }

    idasql::Session session;
    if (!session.open(argv[1])) {
        std::cerr << "Error: " << session.error() << "\n";
        return 1;
    }

    std::string prefix = (argc >= 3) ? argv[2] : "sub";

    // =========================================================================
    // Basic Usage - Function Call Syntax
    // =========================================================================

    std::cout << "=== Basic Search: '" << prefix << "' (prefix mode) ===\n\n";

    auto result = session.query(
        "SELECT name, kind, address, ordinal, parent_name, full_name "
        "FROM jump_entities('" + prefix + "', 'prefix') "
        "LIMIT 10"
    );

    std::cout << std::left
              << std::setw(30) << "Name"
              << std::setw(12) << "Kind"
              << std::setw(12) << "Address"
              << "Full Name\n";
    std::cout << std::string(70, '-') << "\n";

    for (const auto& row : result) {
        std::string addr = row[2].empty() ? "-" : row[2];
        std::cout << std::setw(30) << row[0]
                  << std::setw(12) << row[1]
                  << std::setw(12) << addr
                  << row[5] << "\n";
    }

    // =========================================================================
    // Contains Mode - Search Anywhere in Name
    // =========================================================================

    std::cout << "\n=== Contains Mode: 'main' ===\n\n";

    auto contains = session.query(
        "SELECT name, kind, full_name "
        "FROM jump_entities('main', 'contains') "
        "LIMIT 10"
    );

    for (const auto& row : contains) {
        std::cout << std::setw(40) << row[0]
                  << std::setw(12) << row[1]
                  << row[2] << "\n";
    }

    // =========================================================================
    // Filter by Kind - Only Functions
    // =========================================================================

    std::cout << "\n=== Functions Only ===\n\n";

    auto funcs_only = session.query(
        "SELECT name, address "
        "FROM jump_entities('" + prefix + "', 'prefix') "
        "WHERE kind = 'function' "
        "LIMIT 10"
    );

    for (const auto& row : funcs_only) {
        std::cout << std::setw(30) << row[0] << " @ " << row[1] << "\n";
    }

    // =========================================================================
    // Filter by Kind - Only Types (Structs, Unions, Enums)
    // =========================================================================

    std::cout << "\n=== Types Only (struct/union/enum starting with '_') ===\n\n";

    auto types = session.query(
        "SELECT name, kind, ordinal "
        "FROM jump_entities('_', 'prefix') "
        "WHERE kind IN ('struct', 'union', 'enum') "
        "LIMIT 10"
    );

    for (const auto& row : types) {
        std::cout << std::setw(35) << row[0]
                  << std::setw(10) << row[1]
                  << "ordinal: " << row[2] << "\n";
    }

    // =========================================================================
    // Members with Parent Info
    // =========================================================================

    std::cout << "\n=== Members (showing parent.member) ===\n\n";

    auto members = session.query(
        "SELECT name, parent_name, full_name "
        "FROM jump_entities('e', 'prefix') "
        "WHERE kind IN ('member', 'enum_member') "
        "LIMIT 10"
    );

    for (const auto& row : members) {
        std::cout << std::setw(25) << row[0]
                  << " in " << std::setw(25) << row[1]
                  << " (" << row[2] << ")\n";
    }

    // =========================================================================
    // JOIN with funcs Table - Get Function Sizes
    // =========================================================================

    std::cout << "\n=== JOIN with funcs Table (function sizes) ===\n\n";

    auto with_size = session.query(
        "SELECT j.name, f.size, f.address "
        "FROM jump_entities('" + prefix + "', 'prefix') j "
        "LEFT JOIN funcs f ON j.address = f.address "
        "WHERE j.kind = 'function' "
        "ORDER BY f.size DESC "
        "LIMIT 10"
    );

    std::cout << std::setw(30) << "Function"
              << std::setw(10) << "Size"
              << "Address\n";
    std::cout << std::string(55, '-') << "\n";

    for (const auto& row : with_size) {
        std::cout << std::setw(30) << row[0]
                  << std::setw(10) << row[1]
                  << row[2] << "\n";
    }

    // =========================================================================
    // Aggregation - Count by Kind
    // =========================================================================

    std::cout << "\n=== Entity Count by Kind (prefix '" << prefix << "') ===\n\n";

    auto by_kind = session.query(
        "SELECT kind, COUNT(*) as count "
        "FROM jump_entities('" + prefix + "', 'prefix') "
        "GROUP BY kind "
        "ORDER BY count DESC"
    );

    for (const auto& row : by_kind) {
        std::cout << std::setw(15) << row[0] << ": " << row[1] << "\n";
    }

    // =========================================================================
    // Pagination Demo
    // =========================================================================

    std::cout << "\n=== Pagination Demo ===\n\n";

    // Count total
    auto total = session.query(
        "SELECT COUNT(*) FROM jump_entities('" + prefix + "', 'prefix')"
    );
    std::cout << "Total matches: " << total.scalar() << "\n\n";

    // Page 1
    std::cout << "Page 1 (items 1-3):\n";
    auto page1 = session.query(
        "SELECT name, kind FROM jump_entities('" + prefix + "', 'prefix') LIMIT 3 OFFSET 0"
    );
    for (const auto& row : page1) {
        std::cout << "  " << row[0] << " (" << row[1] << ")\n";
    }

    // Page 2
    std::cout << "\nPage 2 (items 4-6):\n";
    auto page2 = session.query(
        "SELECT name, kind FROM jump_entities('" + prefix + "', 'prefix') LIMIT 3 OFFSET 3"
    );
    for (const auto& row : page2) {
        std::cout << "  " << row[0] << " (" << row[1] << ")\n";
    }

    // =========================================================================
    // Case-Insensitive Search Demo
    // =========================================================================

    std::cout << "\n=== Case-Insensitive Search ===\n\n";

    auto upper = session.query(
        "SELECT COUNT(*) FROM jump_entities('SUB', 'prefix')"
    );
    auto lower = session.query(
        "SELECT COUNT(*) FROM jump_entities('sub', 'prefix')"
    );

    std::cout << "Search 'SUB': " << upper.scalar() << " results\n";
    std::cout << "Search 'sub': " << lower.scalar() << " results\n";
    std::cout << "(Both should match the same entities)\n";

    // =========================================================================
    // Complex Query - Subquery
    // =========================================================================

    std::cout << "\n=== Complex Query - Find Types with Many Members ===\n\n";

    auto complex = session.query(
        "SELECT parent_name, COUNT(*) as member_count "
        "FROM jump_entities('', 'contains') "
        "WHERE kind = 'member' AND parent_name IS NOT NULL "
        "GROUP BY parent_name "
        "HAVING COUNT(*) > 2 "
        "ORDER BY member_count DESC "
        "LIMIT 5"
    );

    // Note: empty pattern returns no results, this is just to show the syntax
    // In practice you'd use a real pattern
    if (complex.row_count() > 0) {
        for (const auto& row : complex) {
            std::cout << std::setw(30) << row[0] << ": " << row[1] << " members\n";
        }
    } else {
        std::cout << "(No results - empty pattern returns no results)\n";
        std::cout << "Try with a real pattern like: SELECT parent_name, COUNT(*) ...\n";
        std::cout << "  FROM jump_entities('e', 'prefix') WHERE kind = 'member' ...\n";
    }

    std::cout << "\nDone.\n";
    return 0;
}

```

`examples/example_jump_search.cpp`:

```cpp
/**
 * example_jump_search.cpp - "Jump to Anything" unified entity search
 *
 * Demonstrates:
 *   - Using jump_search() for unified entity search
 *   - Using jump_query() to get the generated SQL
 *   - Prefix search vs Contains search modes
 *   - Pagination for virtual scrolling
 */

#include <iostream>
#include <iomanip>
#include <idasql/database.hpp>

int main(int argc, char* argv[]) {
    if (argc < 2) {
        std::cerr << "Usage: " << argv[0] << " <database.i64> [search_prefix]\n";
        return 1;
    }

    idasql::Session session;
    if (!session.open(argv[1])) {
        std::cerr << "Error: " << session.error() << "\n";
        return 1;
    }

    std::string prefix = (argc >= 3) ? argv[2] : "main";

    // =========================================================================
    // Basic jump_search usage (returns JSON)
    // =========================================================================

    std::cout << "=== Jump Search: '" << prefix << "' (prefix mode) ===\n\n";

    auto result = session.query(
        "SELECT jump_search('" + prefix + "', 'prefix', 10, 0)"
    );

    if (result.row_count() > 0) {
        std::cout << "JSON result:\n" << result.scalar() << "\n\n";
    }

    // =========================================================================
    // Execute the generated SQL directly for structured results
    // =========================================================================

    std::cout << "=== Structured Results (first 10) ===\n\n";

    // Get the generated query
    auto query_result = session.query(
        "SELECT jump_query('" + prefix + "', 'prefix', 10, 0)"
    );
    std::string sql = query_result.scalar();

    // Execute it directly
    auto entities = session.query(sql);

    std::cout << std::left
              << std::setw(12) << "Kind"
              << std::setw(35) << "Name"
              << std::setw(18) << "Address"
              << "Full Name\n";
    std::cout << std::string(80, '-') << "\n";

    for (const auto& row : entities) {
        std::string addr = row[2].empty() ? "-" : ("0x" + row[2]);
        std::cout << std::setw(12) << row[1]      // kind
                  << std::setw(35) << row[0]      // name
                  << std::setw(18) << addr        // address
                  << row[5] << "\n";              // full_name
    }

    // =========================================================================
    // Pagination demo
    // =========================================================================

    std::cout << "\n=== Pagination: Page 1 vs Page 2 ===\n";

    // Count total matches
    auto count_sql =
        "SELECT COUNT(*) FROM (" +
        session.query("SELECT jump_query('" + prefix + "', 'prefix', 99999, 0)").scalar() +
        ")";
    auto count_result = session.query(count_sql);
    std::cout << "Total matches: " << count_result.scalar() << "\n\n";

    // Page 1
    auto page1 = session.query(
        "SELECT jump_search('" + prefix + "', 'prefix', 5, 0)"
    );
    std::cout << "Page 1 (offset 0, limit 5):\n" << page1.scalar() << "\n\n";

    // Page 2
    auto page2 = session.query(
        "SELECT jump_search('" + prefix + "', 'prefix', 5, 5)"
    );
    std::cout << "Page 2 (offset 5, limit 5):\n" << page2.scalar() << "\n\n";

    // =========================================================================
    // Contains mode (searches anywhere in name)
    // =========================================================================

    std::cout << "=== Contains Mode vs Prefix Mode ===\n\n";

    // Prefix mode - only matches at start
    auto prefix_results = session.query(
        "SELECT jump_search('" + prefix + "', 'prefix', 50, 0)"
    );

    // Contains mode - matches anywhere
    auto contains_results = session.query(
        "SELECT jump_search('" + prefix + "', 'contains', 50, 0)"
    );

    // Count occurrences in each result
    auto count_json = [](const std::string& json) {
        if (json == "[]") return 0;
        int count = 0;
        for (char c : json) if (c == '{') count++;
        return count;
    };

    std::cout << "Prefix mode matches: " << count_json(prefix_results.scalar()) << "\n";
    std::cout << "Contains mode matches: " << count_json(contains_results.scalar()) << "\n";

    // =========================================================================
    // Search different entity types
    // =========================================================================

    std::cout << "\n=== Search by Entity Type ===\n\n";

    // Find some struct names
    auto structs = session.query(
        "SELECT name FROM types WHERE is_struct = 1 LIMIT 1"
    );
    if (structs.row_count() > 0) {
        std::string struct_prefix = structs.scalar().substr(0, 4);
        auto struct_search = session.query(
            "SELECT jump_search('" + struct_prefix + "', 'prefix', 10, 0)"
        );
        std::cout << "Struct search ('" << struct_prefix << "'): "
                  << count_json(struct_search.scalar()) << " results\n";
    }

    // Find some enum names
    auto enums = session.query(
        "SELECT name FROM types WHERE is_enum = 1 LIMIT 1"
    );
    if (enums.row_count() > 0) {
        std::string enum_prefix = enums.scalar().substr(0, 4);
        auto enum_search = session.query(
            "SELECT jump_search('" + enum_prefix + "', 'prefix', 10, 0)"
        );
        std::cout << "Enum search ('" << enum_prefix << "'): "
                  << count_json(enum_search.scalar()) << " results\n";
    }

    // =========================================================================
    // Show the generated SQL
    // =========================================================================

    std::cout << "\n=== Generated SQL Query ===\n\n";
    std::cout << sql << "\n";

    std::cout << "\nDone.\n";
    return 0;
}

```

`examples/example_plugin_style.cpp`:

```cpp
/**
 * example_plugin_style.cpp - IDASQL usage when IDA is already running
 *
 * Demonstrates the recommended patterns for:
 *   - IDA plugins
 *   - IDAPython scripts (via C++ extension)
 *   - Any code where IDA is already initialized
 *
 * Key insight: IDA is singleton, so you don't "open" a database - it's already open.
 * Just create a QueryEngine or use the free functions.
 *
 * NOTE: This example uses Session to simulate IDA being open for standalone testing.
 *       In a real plugin, you'd skip that and just use QueryEngine/free functions.
 */

#include <iostream>
#include <idasql/database.hpp>

// Simulates what your plugin code would look like
void plugin_main() {
    // =========================================================================
    // OPTION 1: Free functions (simplest - recommended for one-off queries)
    // =========================================================================

    std::cout << "=== Using Free Functions ===\n";

    // Quick one-liner queries
    auto funcs = idasql::query("SELECT name, size FROM funcs ORDER BY size DESC LIMIT 5");
    std::cout << "Largest functions:\n";
    for (const auto& row : funcs) {
        std::cout << "  " << row[0] << " (" << row[1] << " bytes)\n";
    }

    // Scalar for single values
    std::string count = idasql::scalar("SELECT COUNT(*) FROM funcs");
    std::cout << "\nTotal functions: " << count << "\n";

    // Execute without results (for comments_live UPDATE, etc.)
    // idasql::execute("UPDATE comments_live SET comment = 'test' WHERE address = 0x401000");

    // =========================================================================
    // OPTION 2: QueryEngine instance (for multiple related queries)
    // =========================================================================

    std::cout << "\n=== Using QueryEngine Instance ===\n";

    idasql::QueryEngine qe;

    // Multiple queries sharing same engine
    auto imports = qe.query("SELECT module, COUNT(*) as cnt FROM imports GROUP BY module ORDER BY cnt DESC LIMIT 3");
    std::cout << "Top imported modules:\n";
    for (const auto& row : imports) {
        std::cout << "  " << row[0] << ": " << row[1] << " imports\n";
    }

    auto strings = qe.query("SELECT content FROM strings WHERE content LIKE '%error%' LIMIT 3");
    std::cout << "\nStrings containing 'error':\n";
    for (const auto& row : strings) {
        std::cout << "  \"" << row[0] << "\"\n";
    }

    // =========================================================================
    // OPTION 3: Callback-based streaming (for large result sets)
    // =========================================================================

    std::cout << "\n=== Using Callback for Streaming ===\n";

    struct Counter {
        int count = 0;
        int total_size = 0;
    } counter;

    qe.exec(
        "SELECT size FROM funcs",
        [](void* data, int argc, char** argv, char**) -> int {
            auto* c = static_cast<Counter*>(data);
            c->count++;
            if (argv[0]) c->total_size += std::atoi(argv[0]);
            return 0;  // Continue
        },
        &counter
    );

    std::cout << "Processed " << counter.count << " functions\n";
    std::cout << "Total code size: " << counter.total_size << " bytes\n";

    // =========================================================================
    // Advanced: Raw SQLite handle access
    // =========================================================================

    std::cout << "\n=== Raw SQLite Handle ===\n";

    sqlite3* db = qe.handle();
    std::cout << "SQLite handle: " << (db ? "valid" : "null") << "\n";

    // You can use db with any SQLite C API directly
    // sqlite3_prepare_v2, sqlite3_bind, etc. for prepared statements
}

int main(int argc, char* argv[]) {
    // For standalone testing, we need to open IDA first
    // In a real plugin, IDA would already be open - skip this part

    if (argc < 2) {
        std::cerr << "Usage: " << argv[0] << " <database.i64>\n\n";
        std::cerr << "NOTE: In a real IDA plugin, you wouldn't need to open anything.\n";
        std::cerr << "      This example uses Session just to simulate IDA being open.\n";
        return 1;
    }

    // Simulate IDA being open (in a plugin, this is already done)
    idasql::Session session;
    if (!session.open(argv[1])) {
        std::cerr << "Error: " << session.error() << "\n";
        return 1;
    }

    std::cout << "Database loaded. Simulating plugin environment...\n\n";

    // This is what your actual plugin code would look like
    plugin_main();

    return 0;
}

```

`examples/example_strings.cpp`:

```cpp
/**
 * example_strings.cpp - String analysis with IDASQL
 *
 * Demonstrates:
 *   - Querying the strings table
 *   - Pattern matching with LIKE
 *   - Finding xrefs to strings
 *   - String statistics
 */

#include <iostream>
#include <iomanip>
#include <idasql/database.hpp>

int main(int argc, char* argv[]) {
    if (argc < 2) {
        std::cerr << "Usage: " << argv[0] << " <database.i64>\n";
        return 1;
    }

    idasql::Session session;
    if (!session.open(argv[1])) {
        std::cerr << "Error: " << session.error() << "\n";
        return 1;
    }

    // =========================================================================
    // String statistics
    // =========================================================================

    std::cout << "=== String Statistics ===\n";

    std::cout << "Total strings: " << session.scalar("SELECT COUNT(*) FROM strings") << "\n";
    std::cout << "ASCII strings: " << session.scalar("SELECT COUNT(*) FROM strings WHERE type = 0") << "\n";
    std::cout << "Unicode strings: " << session.scalar("SELECT COUNT(*) FROM strings WHERE type = 1") << "\n";

    auto avg_len = session.scalar("SELECT AVG(length) FROM strings");
    std::cout << "Average length: " << avg_len << " chars\n";

    // =========================================================================
    // Longest strings
    // =========================================================================

    std::cout << "\n=== Top 10 Longest Strings ===\n";

    auto longest = session.query(
        "SELECT printf('0x%X', address) as addr, length, "
        "       SUBSTR(content, 1, 60) as preview "
        "FROM strings "
        "ORDER BY length DESC "
        "LIMIT 10"
    );

    for (const auto& row : longest) {
        std::cout << row[0] << " [" << row[1] << "] \"" << row[2];
        if (std::stoi(row[1]) > 60) std::cout << "...";
        std::cout << "\"\n";
    }

    // =========================================================================
    // Search for interesting strings
    // =========================================================================

    std::cout << "\n=== Error/Warning Strings ===\n";

    auto errors = session.query(
        "SELECT printf('0x%X', address) as addr, content "
        "FROM strings "
        "WHERE content LIKE '%error%' "
        "   OR content LIKE '%fail%' "
        "   OR content LIKE '%warning%' "
        "   OR content LIKE '%exception%' "
        "LIMIT 15"
    );

    for (const auto& row : errors) {
        std::cout << row[0] << ": \"" << row[1] << "\"\n";
    }

    // =========================================================================
    // URL/Path strings
    // =========================================================================

    std::cout << "\n=== URL/Path Strings ===\n";

    auto urls = session.query(
        "SELECT printf('0x%X', address) as addr, content "
        "FROM strings "
        "WHERE content LIKE 'http%' "
        "   OR content LIKE 'https%' "
        "   OR content LIKE '%.exe%' "
        "   OR content LIKE '%.dll%' "
        "   OR content LIKE 'C:\\\\%' "
        "LIMIT 15"
    );

    for (const auto& row : urls) {
        std::cout << row[0] << ": \"" << row[1] << "\"\n";
    }

    // =========================================================================
    // Strings with most xrefs (most used)
    // =========================================================================

    std::cout << "\n=== Most Referenced Strings (Top 10) ===\n";

    auto most_used = session.query(
        "SELECT s.content, COUNT(x.from_ea) as refs "
        "FROM strings s "
        "LEFT JOIN xrefs x ON s.address = x.to_ea "
        "GROUP BY s.address "
        "HAVING refs > 0 "
        "ORDER BY refs DESC "
        "LIMIT 10"
    );

    for (const auto& row : most_used) {
        std::cout << std::setw(5) << row[1] << " refs: \""
                  << row[0].substr(0, 50);
        if (row[0].length() > 50) std::cout << "...";
        std::cout << "\"\n";
    }

    // =========================================================================
    // Strings by function
    // =========================================================================

    std::cout << "\n=== Functions Using Most Strings (Top 10) ===\n";

    auto by_func = session.query(
        "SELECT func_at(x.from_ea) as func_name, COUNT(DISTINCT s.address) as str_count "
        "FROM strings s "
        "JOIN xrefs x ON s.address = x.to_ea "
        "WHERE func_at(x.from_ea) IS NOT NULL "
        "GROUP BY func_at(x.from_ea) "
        "ORDER BY str_count DESC "
        "LIMIT 10"
    );

    for (const auto& row : by_func) {
        std::cout << std::setw(40) << row[0] << " - " << row[1] << " strings\n";
    }

    // =========================================================================
    // Format strings (potential printf-like usage)
    // =========================================================================

    std::cout << "\n=== Format Strings (contain %s, %d, etc.) ===\n";

    auto formats = session.query(
        "SELECT printf('0x%X', address) as addr, content "
        "FROM strings "
        "WHERE content LIKE '%\\%s%' ESCAPE '\\' "
        "   OR content LIKE '%\\%d%' ESCAPE '\\' "
        "   OR content LIKE '%\\%x%' ESCAPE '\\' "
        "   OR content LIKE '%\\%p%' ESCAPE '\\' "
        "LIMIT 10"
    );

    for (const auto& row : formats) {
        std::cout << row[0] << ": \"" << row[1] << "\"\n";
    }

    std::cout << "\nDone.\n";
    return 0;
}

```

`ida-plugin.json`:

```json
{
  "IDAMetadataDescriptorVersion": 1,
  "plugin": {
    "name": "IDASQL",
    "version": "0.0.8",
    "entryPoint": "idasql",
    "description": "SQL interface for IDA databases. Query functions, xrefs, strings, types, and more using SQL. Supports local CLI, HTTP REST server, and optional AI agent integration.",
    "urls": {
      "repository": "https://github.com/allthingsida/idasql"
    },
    "authors": [
      {
        "name": "Elias Bachaalany",
        "email": "elias.bachaalany@gmail.com"
      }
    ],
    "categories": [
      "api-scripting-and-automation",
      "collaboration-and-productivity"
    ],
    "idaVersions": ">=9.0",
    "platforms": [
      "windows-x86_64",
      "linux-x86_64",
      "macos-aarch64"
    ],
    "license": "MIT"
  }
}

```

`prompts/idasql_agent.md`:

```md
# IDASQL Agent Guide

A comprehensive reference for AI agents to effectively use IDASQL - an SQL interface for reverse engineering binary analysis with IDA Pro.

---

## What is IDA and Why SQL?

**IDA Pro** is the industry-standard disassembler and reverse engineering tool. It analyzes compiled binaries (executables, DLLs, firmware) and produces:
- **Disassembly** - Human-readable assembly code
- **Functions** - Detected code boundaries with names
- **Cross-references** - Who calls what, who references what data
- **Types** - Structures, enums, function prototypes
- **Decompilation** - C-like pseudocode (with Hex-Rays plugin)

**IDASQL** exposes all this analysis data through SQL virtual tables, enabling:
- Complex queries across multiple data types (JOINs)
- Aggregations and statistics (COUNT, GROUP BY)
- Pattern detection across the entire binary
- Scriptable analysis without writing IDA plugins or IDAPython scripts

---

## Core Concepts for Binary Analysis

### Addresses (ea_t)
Everything in a binary has an **address** - a memory location where code or data lives. IDA uses `ea_t` (effective address) as unsigned 64-bit integers. SQL shows these as integers; use `printf('0x%X', address)` for hex display.

### Functions
IDA groups code into **functions** with:
- `address` / `start_ea` - Where the function begins
- `end_ea` - Where it ends
- `name` - Assigned or auto-generated name (e.g., `main`, `sub_401000`)
- `size` - Total bytes in the function

### Cross-References (xrefs)
Binary analysis is about understanding **relationships**:
- **Code xrefs** - Function calls, jumps between code
- **Data xrefs** - Code reading/writing data locations
- `from_ea` → `to_ea` represents "address X references address Y"

### Segments
Memory is divided into **segments** with different purposes:
- `.text` - Executable code (typically)
- `.data` - Initialized global data
- `.rdata` - Read-only data (strings, constants)
- `.bss` - Uninitialized data

Of course, segment names and types can vary. You may query the `segments` table to understand memory layout.

### Basic Blocks
Within a function, **basic blocks** are straight-line code sequences:
- No branches in the middle
- Single entry, single exit
- Useful for control flow analysis

### Decompilation (Hex-Rays)
The **Hex-Rays decompiler** converts assembly to C-like **pseudocode**:
- **ctree** - The Abstract Syntax Tree of decompiled code
- **lvars** - Local variables detected by the decompiler
- Much easier to analyze than raw assembly

---

## Command-Line Interface

IDASQL provides SQL access to IDA databases via command line or as a server.

### Invocation Modes

**1. Single Query (Local)**
```bash
idasql -s database.i64 -q "SELECT * FROM funcs LIMIT 10"
idasql -s database.i64 -c "SELECT COUNT(*) FROM funcs"  # -c is alias for -q
```

**2. SQL File Execution**
```bash
idasql -s database.i64 -f analysis.sql
```

**3. Interactive REPL**
```bash
idasql -s database.i64 -i
```

**4. Remote Mode** (connect to running server)
```bash
idasql --remote localhost:8080 -q "SELECT * FROM funcs"
idasql --remote localhost:8080 -i  # Remote interactive
```

**5. HTTP Server Mode**
```bash
idasql -s database.i64 --http 8080
# Then query via: curl -X POST http://localhost:8080/query -d "SELECT * FROM funcs"
```

**6. Export Mode**
```bash
idasql -s database.i64 --export dump.sql
idasql -s database.i64 --export dump.sql --export-tables=funcs,segments
```

### CLI Options

| Option | Description |
|--------|-------------|
| `-s <file>` | IDA database file (.idb/.i64) |
| `--remote <host:port>` | Connect to IDASQL server |
| `--token <token>` | Auth token for remote/server mode |
| `-q <sql>` | Execute single SQL query |
| `-c <sql>` | Alias for -q (Python-style) |
| `-f <file>` | Execute SQL from file |
| `-i` | Interactive REPL mode |
| `-w, --write` | Save database changes on exit |
| `--export <file>` | Export tables to SQL file |
| `--export-tables=X` | Tables to export: `*` (all) or `table1,table2,...` |
| `--http [port]` | Start HTTP REST server (default: 8080) |
| `--bind <addr>` | Bind address for server (default: 127.0.0.1) |
| `-h, --help` | Show help |

### REPL Commands

| Command | Description |
|---------|-------------|
| `.tables` | List all virtual tables |
| `.schema [table]` | Show table schema |
| `.info` | Show database metadata |
| `.clear` | Clear session |
| `.quit` / `.exit` | Exit REPL |
| `.help` | Show available commands |
| `.http start` | Start HTTP server on random port |
| `.http stop` | Stop HTTP server |
| `.http status` | Show HTTP server status |
| `.agent` | Start AI agent mode |

### Performance Strategy

**Single queries:** Use `-q` directly.
```bash
idasql -s database.i64 -q "SELECT COUNT(*) FROM funcs"
```

**Multiple queries / exploration:** Start a server once, then query as a client.

Opening an IDA database has startup overhead (idalib initialization, auto-analysis). If you plan to run many queries—exploring the database, experimenting with different queries, or iterating on analysis—avoid re-opening the database each time.

**Recommended workflow for iterative analysis:**
```bash
# Terminal 1: Start server (opens database once)
idasql -s database.i64 --http 8080

# Terminal 2: Query repeatedly via remote client (instant responses)
idasql --remote localhost:8080 -q "SELECT * FROM funcs LIMIT 5"
idasql --remote localhost:8080 -q "SELECT * FROM strings WHERE content LIKE '%error%'"
idasql --remote localhost:8080 -q "SELECT name, size FROM funcs ORDER BY size DESC"
# ... as many queries as needed, no startup cost
```

Or use interactive mode on the remote connection:
```bash
idasql --remote localhost:8080 -i
idasql> SELECT COUNT(*) FROM funcs;
idasql> SELECT * FROM xrefs WHERE to_ea = 0x401000;
idasql> .quit
```

This approach is significantly faster for iterative analysis since the database remains open and queries go directly through the already-initialized session.

---

## Tables Reference

### Debugger Tables (Full CRUD)

#### breakpoints
Debugger breakpoints. Supports full CRUD (SELECT, INSERT, UPDATE, DELETE). Breakpoints persist in the IDB even without an active debugger session.

| Column | Type | RW | Description |
|--------|------|----|-------------|
| `address` | INT | R | Breakpoint address |
| `enabled` | INT | RW | 1=enabled, 0=disabled |
| `type` | INT | RW | Breakpoint type (0=software, 1=hw_write, 2=hw_read, 3=hw_rdwr, 4=hw_exec) |
| `type_name` | TEXT | R | Type name (software, hardware_write, etc.) |
| `size` | INT | RW | Breakpoint size (for hardware breakpoints) |
| `flags` | INT | RW | Breakpoint flags |
| `pass_count` | INT | RW | Pass count before trigger |
| `condition` | TEXT | RW | Condition expression |
| `loc_type` | INT | R | Location type code |
| `loc_type_name` | TEXT | R | Location type (absolute, relative, symbolic, source) |
| `module` | TEXT | R | Module path (relative breakpoints) |
| `symbol` | TEXT | R | Symbol name (symbolic breakpoints) |
| `offset` | INT | R | Offset (relative/symbolic) |
| `source_file` | TEXT | R | Source file (source breakpoints) |
| `source_line` | INT | R | Source line number |
| `is_hardware` | INT | R | 1=hardware breakpoint |
| `is_active` | INT | R | 1=currently active |
| `group` | TEXT | RW | Breakpoint group name |
| `bptid` | INT | R | Breakpoint ID |

```sql
-- List all breakpoints
SELECT printf('0x%08X', address) as addr, type_name, enabled, condition
FROM breakpoints;

-- Add software breakpoint
INSERT INTO breakpoints (address) VALUES (0x401000);

-- Add hardware write watchpoint
INSERT INTO breakpoints (address, type, size) VALUES (0x402000, 1, 4);

-- Add conditional breakpoint
INSERT INTO breakpoints (address, condition) VALUES (0x401000, 'eax == 0');

-- Disable a breakpoint
UPDATE breakpoints SET enabled = 0 WHERE address = 0x401000;

-- Delete a breakpoint
DELETE FROM breakpoints WHERE address = 0x401000;

-- Find which functions have breakpoints
SELECT b.address, f.name, b.type_name, b.enabled
FROM breakpoints b
JOIN funcs f ON b.address >= f.address AND b.address < f.end_ea;
```

### Entity Tables

#### funcs
All detected functions in the binary with prototype information.

| Column | Type | Description |
|--------|------|-------------|
| `address` | INT | Function start address |
| `name` | TEXT | Function name |
| `size` | INT | Function size in bytes |
| `end_ea` | INT | Function end address |
| `flags` | INT | Function flags |

**Prototype columns** (populated when type info available):

| Column | Type | Description |
|--------|------|-------------|
| `return_type` | TEXT | Return type string (e.g., "int", "void *") |
| `return_is_ptr` | INT | 1 if return type is pointer |
| `return_is_int` | INT | 1 if return type is exactly int |
| `return_is_integral` | INT | 1 if return type is int-like (int, long, DWORD, BOOL) |
| `return_is_void` | INT | 1 if return type is void |
| `arg_count` | INT | Number of function arguments |
| `calling_conv` | TEXT | Calling convention (cdecl, stdcall, fastcall, etc.) |

```sql
-- 10 largest functions
SELECT name, size FROM funcs ORDER BY size DESC LIMIT 10;

-- Functions starting with "sub_" (auto-named, not analyzed)
SELECT name, printf('0x%X', address) as addr FROM funcs WHERE name LIKE 'sub_%';

-- Functions returning integers with 3+ arguments
SELECT name, return_type, arg_count FROM funcs
WHERE return_is_integral = 1 AND arg_count >= 3;

-- Void functions (side effects, callbacks)
SELECT name, arg_count FROM funcs WHERE return_is_void = 1;

-- Pointer-returning functions (factories, allocators)
SELECT name, return_type FROM funcs WHERE return_is_ptr = 1;

-- Simple getter functions (no args, returns value)
SELECT name, return_type FROM funcs
WHERE arg_count = 0 AND return_is_void = 0;

-- Functions by calling convention
SELECT calling_conv, COUNT(*) as count FROM funcs
WHERE calling_conv IS NOT NULL AND calling_conv != ''
GROUP BY calling_conv ORDER BY count DESC;
```

#### segments
Memory segments. Supports UPDATE (`name`, `class`, `perm`) and DELETE.

| Column | Type | RW | Description |
|--------|------|----|-------------|
| `start_ea` | INT | R | Segment start |
| `end_ea` | INT | R | Segment end |
| `name` | TEXT | RW | Segment name (.text, .data, etc.) |
| `class` | TEXT | RW | Segment class (CODE, DATA) |
| `perm` | INT | RW | Permissions (R=4, W=2, X=1) |

```sql
-- Find executable segments
SELECT name, printf('0x%X', start_ea) as start FROM segments WHERE perm & 1 = 1;

-- Rename a segment
UPDATE segments SET name = '.mytext' WHERE start_ea = 0x401000;

-- Change segment permissions to read+exec
UPDATE segments SET perm = 5 WHERE name = '.text';

-- Delete a segment
DELETE FROM segments WHERE name = '.rdata';
```

#### names
All named locations (functions, labels, data).

| Column | Type | Description |
|--------|------|-------------|
| `address` | INT | Address |
| `name` | TEXT | Name |

#### entries
Entry points (exports, program entry).

| Column | Type | Description |
|--------|------|-------------|
| `ordinal` | INT | Export ordinal |
| `address` | INT | Entry address |
| `name` | TEXT | Entry name |

#### imports
Imported functions from external libraries.

| Column | Type | Description |
|--------|------|-------------|
| `address` | INT | Import address (IAT entry) |
| `name` | TEXT | Import name |
| `module` | TEXT | Module/DLL name |
| `ordinal` | INT | Import ordinal |

```sql
-- Imports from kernel32.dll
SELECT name FROM imports WHERE module LIKE '%kernel32%';
```

#### strings
String literals found in the binary. IDA maintains a cached string list that can be configured.

| Column | Type | Description |
|--------|------|-------------|
| `address` | INT | String address |
| `length` | INT | String length |
| `type` | INT | String type (raw encoding bits) |
| `type_name` | TEXT | Type name: ascii, utf16, utf32 |
| `width` | INT | Char width (0=1-byte, 1=2-byte, 2=4-byte) |
| `width_name` | TEXT | Width name: 1-byte, 2-byte, 4-byte |
| `layout` | INT | String layout (0=null-terminated, 1-3=pascal) |
| `layout_name` | TEXT | Layout name: termchr, pascal1, pascal2, pascal4 |
| `encoding` | INT | Encoding index (0=default) |
| `content` | TEXT | String content |

**String Type Encoding:**
IDA stores string type as a 32-bit value:
- Bits 0-1: Width (0=1B/ASCII, 1=2B/UTF-16, 2=4B/UTF-32)
- Bits 2-7: Layout (0=TERMCHR, 1=PASCAL1, 2=PASCAL2, 3=PASCAL4)
- Bits 8-15: term1 (first termination character)
- Bits 16-23: term2 (second termination character)
- Bits 24-31: encoding index

```sql
-- Find error messages
SELECT content, printf('0x%X', address) as addr FROM strings WHERE content LIKE '%error%';

-- ASCII strings only
SELECT * FROM strings WHERE type_name = 'ascii';

-- UTF-16 strings (common in Windows)
SELECT * FROM strings WHERE type_name = 'utf16';

-- Count strings by type
SELECT type_name, layout_name, COUNT(*) as count
FROM strings GROUP BY type_name, layout_name ORDER BY count DESC;
```

**Important:** For new analysis (exe/dll), strings are auto-built. For existing databases (i64/idb), strings are already saved. If you see 0 strings unexpectedly, run `SELECT rebuild_strings()` once to rebuild the list. See String List Functions section below.

#### xrefs
Cross-references - the most important table for understanding code relationships.

| Column | Type | Description |
|--------|------|-------------|
| `from_ea` | INT | Source address (who references) |
| `to_ea` | INT | Target address (what is referenced) |
| `type` | INT | Xref type code |
| `is_code` | INT | 1=code xref (call/jump), 0=data xref |

```sql
-- Who calls function at 0x401000?
SELECT printf('0x%X', from_ea) as caller FROM xrefs WHERE to_ea = 0x401000 AND is_code = 1;

-- What does function at 0x401000 reference?
SELECT printf('0x%X', to_ea) as target FROM xrefs WHERE from_ea >= 0x401000 AND from_ea < 0x401100;
```

#### blocks
Basic blocks within functions. **Use `func_ea` constraint for performance.**

| Column | Type | Description |
|--------|------|-------------|
| `func_ea` | INT | Containing function |
| `start_ea` | INT | Block start |
| `end_ea` | INT | Block end |
| `size` | INT | Block size |

```sql
-- Blocks in a specific function (FAST - uses constraint pushdown)
SELECT * FROM blocks WHERE func_ea = 0x401000;

-- Functions with most basic blocks
SELECT func_at(func_ea) as name, COUNT(*) as blocks
FROM blocks GROUP BY func_ea ORDER BY blocks DESC LIMIT 10;
```

### Convenience Views

Pre-built views for common xref analysis patterns. These simplify caller/callee queries.

#### callers
Who calls each function. Use this instead of manual xref JOINs.

| Column | Type | Description |
|--------|------|-------------|
| `func_addr` | INT | Target function address |
| `caller_addr` | INT | Xref source address |
| `caller_name` | TEXT | Calling function name |
| `caller_func_addr` | INT | Calling function start |

```sql
-- Who calls function at 0x401000?
SELECT caller_name, printf('0x%X', caller_addr) as from_addr
FROM callers WHERE func_addr = 0x401000;

-- Most called functions
SELECT printf('0x%X', func_addr) as addr, COUNT(*) as callers
FROM callers GROUP BY func_addr ORDER BY callers DESC LIMIT 10;
```

#### callees
What each function calls. Inverse of callers view.

| Column | Type | Description |
|--------|------|-------------|
| `func_addr` | INT | Calling function address |
| `func_name` | TEXT | Calling function name |
| `callee_addr` | INT | Called address |
| `callee_name` | TEXT | Called function/symbol name |

```sql
-- What does main call?
SELECT callee_name, printf('0x%X', callee_addr) as addr
FROM callees WHERE func_name LIKE '%main%';

-- Functions making most calls
SELECT func_name, COUNT(*) as call_count
FROM callees GROUP BY func_addr ORDER BY call_count DESC LIMIT 10;
```

#### string_refs
Which functions reference which strings. Great for finding functions by string content.

| Column | Type | Description |
|--------|------|-------------|
| `string_addr` | INT | String address |
| `string_value` | TEXT | String content |
| `string_length` | INT | String length |
| `ref_addr` | INT | Reference address |
| `func_addr` | INT | Referencing function |
| `func_name` | TEXT | Function name |

```sql
-- Find functions using error strings
SELECT func_name, string_value
FROM string_refs
WHERE string_value LIKE '%error%' OR string_value LIKE '%fail%';

-- Functions with most string references
SELECT func_name, COUNT(*) as string_count
FROM string_refs WHERE func_name IS NOT NULL
GROUP BY func_addr ORDER BY string_count DESC LIMIT 10;
```

### Instruction Tables

#### instructions
Decoded instructions. Supports DELETE (converts instruction to unexplored bytes). **Always filter by `func_addr` for performance.**

| Column | Type | Description |
|--------|------|-------------|
| `address` | INT | Instruction address |
| `func_addr` | INT | Containing function |
| `itype` | INT | Instruction type (architecture-specific) |
| `mnemonic` | TEXT | Instruction mnemonic |
| `size` | INT | Instruction size |
| `operand0` | TEXT | First operand |
| `operand1` | TEXT | Second operand |
| `disasm` | TEXT | Full disassembly line |

```sql
-- Instruction profile of a function (FAST)
SELECT mnemonic, COUNT(*) as count
FROM instructions WHERE func_addr = 0x401330
GROUP BY mnemonic ORDER BY count DESC;

-- Find all call instructions in a function
SELECT address, disasm FROM instructions
WHERE func_addr = 0x401000 AND mnemonic = 'call';

-- Delete an instruction (convert to unexplored bytes)
DELETE FROM instructions WHERE address = 0x401000;
```

**Performance:** `WHERE func_addr = X` uses O(function_size) iteration. Without this constraint, it scans the entire database - SLOW.

#### disasm_calls
All call instructions with resolved targets.

| Column | Type | Description |
|--------|------|-------------|
| `func_addr` | INT | Function containing the call |
| `ea` | INT | Call instruction address |
| `callee_addr` | INT | Target address (0 if unknown) |
| `callee_name` | TEXT | Target name |

```sql
-- Functions that call malloc
SELECT DISTINCT func_at(func_addr) as caller
FROM disasm_calls WHERE callee_name LIKE '%malloc%';
```

### Database Modification

The following tables support modification:

| Table | INSERT | UPDATE columns | DELETE |
|-------|--------|---------------|--------|
| `breakpoints` | Yes | `enabled`, `type`, `size`, `flags`, `pass_count`, `condition`, `group` | Yes |
| `funcs` | Yes | `name`, `flags` | Yes |
| `names` | Yes | `name` | Yes |
| `comments` | Yes | `comment`, `rep_comment` | Yes |
| `bookmarks` | Yes | `description` | Yes |
| `segments` | — | `name`, `class`, `perm` | Yes |
| `instructions` | — | — | Yes |
| `types` | Yes | Yes | Yes |
| `types_members` | Yes | Yes | Yes |
| `types_enum_values` | Yes | Yes | Yes |
| `ctree_lvars` | — | `name`, `type` | — |

**INSERT examples:**
```sql
-- Create a function (IDA auto-detects boundaries)
INSERT INTO funcs (address) VALUES (0x401000);

-- Create a function with name and explicit end
INSERT INTO funcs (address, name, end_ea) VALUES (0x401000, 'my_func', 0x401050);

-- Set a name at an address
INSERT INTO names (address, name) VALUES (0x401000, 'main');

-- Add a comment
INSERT INTO comments (address, comment) VALUES (0x401050, 'Check return value');

-- Add a repeatable comment
INSERT INTO comments (address, rpt_comment) VALUES (0x404000, 'Global config');

-- Add a bookmark (auto-assigned slot)
INSERT INTO bookmarks (address, description) VALUES (0x401000, 'interesting');

-- Add a bookmark at specific slot
INSERT INTO bookmarks (slot, address, description) VALUES (5, 0x401000, 'slot 5');
```

**UPDATE examples:**
```sql
-- Rename a function
UPDATE funcs SET name = 'my_main' WHERE address = 0x401000;

-- Rename any named address
UPDATE names SET name = 'my_global' WHERE address = 0x404000;

-- Add/update comment
UPDATE comments SET comment = 'Check return value' WHERE address = 0x401050;

-- Add repeatable comment
UPDATE comments SET rep_comment = 'Global config' WHERE address = 0x404000;

-- Delete a name
DELETE FROM names WHERE address = 0x401000;
```

**Segments:**
```sql
-- Rename a segment
UPDATE segments SET name = '.mytext' WHERE start_ea = 0x401000;

-- Change segment class
UPDATE segments SET class = 'DATA' WHERE name = '.rdata';

-- Change permissions (R=4, W=2, X=1)
UPDATE segments SET perm = 5 WHERE name = '.text';

-- Delete a segment
DELETE FROM segments WHERE name = '.rdata';
```

**Instructions:**
```sql
-- Delete an instruction (convert to unexplored bytes)
DELETE FROM instructions WHERE address = 0x401000;
```

**Types:**
```sql
-- Create a new struct
INSERT INTO types (name, kind) VALUES ('my_struct', 'struct');

-- Create an enum
INSERT INTO types (name, kind) VALUES ('my_flags', 'enum');

-- Create a union
INSERT INTO types (name, kind) VALUES ('my_union', 'union');

-- Add a struct member with type
INSERT INTO types_members (type_ordinal, member_name, member_type) VALUES (42, 'field1', 'int');

-- Add a struct member (name only, default type)
INSERT INTO types_members (type_ordinal, member_name) VALUES (42, 'field2');

-- Add an enum value
INSERT INTO types_enum_values (type_ordinal, value_name, value) VALUES (15, 'FLAG_ACTIVE', 1);

-- Add an enum value with comment
INSERT INTO types_enum_values (type_ordinal, value_name, value, comment)
VALUES (15, 'FLAG_HIDDEN', 2, 'not visible in UI');
```

**Decompiler local variables (requires Hex-Rays):**
```sql
-- Rename a local variable
UPDATE ctree_lvars SET name = 'buffer_size'
WHERE func_addr = 0x401000 AND name = 'v1';

-- Change variable type
UPDATE ctree_lvars SET type = 'char *'
WHERE func_addr = 0x401000 AND idx = 2;
```

### Persisting Changes

Changes to the database (UPDATE, set_name, etc.) are held in memory by default.

**To persist changes:**
```sql
-- Explicit save (recommended for scripts)
SELECT save_database();  -- Returns 1 on success, 0 on failure
```

**CLI flag for auto-save:**
```bash
# Auto-save on exit (use with caution)
idasql -s db.i64 -q "UPDATE funcs SET name='main' WHERE address=0x401000" -w
```

**Best practice for batch operations:**
```sql
-- Make multiple changes
UPDATE funcs SET name = 'init_config' WHERE address = 0x401000;
UPDATE names SET name = 'g_settings' WHERE address = 0x402000;
-- Persist once at the end
SELECT save_database();
```

> Without `save_database()` or `-w`, changes are lost when the session ends.

### Decompiler Tables (Hex-Rays Required)

**CRITICAL:** Always filter by `func_addr`. Without constraint, these tables will decompile EVERY function - extremely slow!

#### pseudocode
Structured line-by-line pseudocode with writable comments. **Use `decompile(addr)` to view pseudocode; use this table only for surgical edits (comments) or structured queries.**

| Column | Type | Writable | Description |
|--------|------|----------|-------------|
| `func_addr` | INT | No | Function address |
| `line_num` | INT | No | Line number |
| `line` | TEXT | No | Pseudocode text |
| `ea` | INT | No | Corresponding assembly address (from COLOR_ADDR anchor) |
| `comment` | TEXT | **Yes** | Decompiler comment at this ea |
| `comment_placement` | TEXT | **Yes** | Comment placement: `semi` (inline, default), `block1` (above line) |

**Comment placements:** `semi` (after `;`), `block1` (own line above), `block2`, `curly1`, `curly2`, `colon`, `case`, `else`, `do`

```sql
-- VIEWING: Use decompile() function, NOT the pseudocode table
SELECT decompile(0x401000);

-- COMMENTING: Use pseudocode table to add/edit/delete comments
-- Add inline comment (appears after semicolon)
UPDATE pseudocode SET comment = 'buffer overflow here'
WHERE func_addr = 0x401000 AND ea = 0x401020;

-- Add block comment (appears on own line above the statement)
UPDATE pseudocode SET comment_placement = 'block1', comment = 'vulnerable call'
WHERE func_addr = 0x401000 AND ea = 0x401020;

-- Delete a comment
UPDATE pseudocode SET comment = NULL
WHERE func_addr = 0x401000 AND ea = 0x401020;

-- STRUCTURED QUERY: Get specific lines with ea and comment info
SELECT ea, line, comment FROM pseudocode WHERE func_addr = 0x401000;
```

#### ctree
Full Abstract Syntax Tree of decompiled code.

| Column | Type | Description |
|--------|------|-------------|
| `func_addr` | INT | Function address |
| `item_id` | INT | Unique node ID |
| `is_expr` | INT | 1=expression, 0=statement |
| `op_name` | TEXT | Node type (`cot_call`, `cit_if`, etc.) |
| `ea` | INT | Address in binary |
| `parent_id` | INT | Parent node ID |
| `depth` | INT | Tree depth |
| `x_id`, `y_id`, `z_id` | INT | Child node IDs |
| `var_idx` | INT | Local variable index |
| `var_name` | TEXT | Variable name |
| `obj_ea` | INT | Target address |
| `obj_name` | TEXT | Symbol name |
| `num_value` | INT | Numeric literal |
| `str_value` | TEXT | String literal |

#### ctree_lvars
Local variables from decompilation.

| Column | Type | Description |
|--------|------|-------------|
| `func_addr` | INT | Function address |
| `idx` | INT | Variable index |
| `name` | TEXT | Variable name |
| `type` | TEXT | Type string |
| `size` | INT | Size in bytes |
| `is_arg` | INT | 1=function argument |
| `is_stk_var` | INT | 1=stack variable |
| `stkoff` | INT | Stack offset |

#### ctree_call_args
Flattened call arguments for easy querying.

| Column | Type | Description |
|--------|------|-------------|
| `func_addr` | INT | Function address |
| `call_item_id` | INT | Call node ID |
| `arg_idx` | INT | Argument index (0-based) |
| `arg_op` | TEXT | Argument type |
| `arg_var_name` | TEXT | Variable name if applicable |
| `arg_var_is_stk` | INT | 1=stack variable |
| `arg_num_value` | INT | Numeric value |
| `arg_str_value` | TEXT | String value |

### Decompiler Views

Pre-built views for common patterns:

| View | Purpose |
|------|---------|
| `ctree_v_calls` | Function calls with callee info |
| `ctree_v_loops` | for/while/do loops |
| `ctree_v_ifs` | if statements |
| `ctree_v_comparisons` | Comparisons with operands |
| `ctree_v_assignments` | Assignments with operands |
| `ctree_v_derefs` | Pointer dereferences |
| `ctree_v_returns` | Return statements with value details |
| `ctree_v_calls_in_loops` | Calls inside loops (recursive) |
| `ctree_v_calls_in_ifs` | Calls inside if branches (recursive) |
| `ctree_v_leaf_funcs` | Functions with no outgoing calls |
| `ctree_v_call_chains` | Call chain paths up to depth 10 |

#### ctree_v_returns

Return statements with details about what's being returned.

| Column | Type | Description |
|--------|------|-------------|
| `func_addr` | INT | Function address |
| `item_id` | INT | Return statement item_id |
| `ea` | INT | Address of return |
| `return_op` | TEXT | Return value opcode (`cot_num`, `cot_var`, `cot_call`, etc.) |
| `return_num` | INT | Numeric value (if `cot_num`) |
| `return_str` | TEXT | String value (if `cot_str`) |
| `return_var` | TEXT | Variable name (if `cot_var`) |
| `returns_arg` | INT | 1 if returning a function argument |
| `returns_call_result` | INT | 1 if returning result of another call |

```sql
-- Functions that return 0
SELECT DISTINCT func_at(func_addr) as name FROM ctree_v_returns
WHERE return_op = 'cot_num' AND return_num = 0;

-- Functions that return -1 (error sentinel)
SELECT DISTINCT func_at(func_addr) as name FROM ctree_v_returns
WHERE return_op = 'cot_num' AND return_num = -1;

-- Functions that return their argument (pass-through)
SELECT DISTINCT func_at(func_addr) as name FROM ctree_v_returns
WHERE returns_arg = 1;
```

### Type Tables

#### types
All local type definitions. Supports INSERT (create struct/union/enum), UPDATE, and DELETE.

| Column | Type | Description |
|--------|------|-------------|
| `ordinal` | INT | Type ordinal |
| `name` | TEXT | Type name |
| `size` | INT | Size in bytes |
| `kind` | TEXT | struct/union/enum/typedef/func |
| `is_struct` | INT | 1=struct |
| `is_union` | INT | 1=union |
| `is_enum` | INT | 1=enum |

#### types_members
Structure and union members. Supports INSERT (add member to struct/union), UPDATE, and DELETE.

| Column | Type | Description |
|--------|------|-------------|
| `type_ordinal` | INT | Parent type ordinal |
| `type_name` | TEXT | Parent type name |
| `member_name` | TEXT | Member name |
| `offset` | INT | Byte offset |
| `size` | INT | Member size |
| `member_type` | TEXT | Type string |
| `mt_is_ptr` | INT | 1=pointer |
| `mt_is_array` | INT | 1=array |
| `mt_is_struct` | INT | 1=embedded struct |

#### types_enum_values
Enum constant values. Supports INSERT (add value to enum), UPDATE, and DELETE.

| Column | Type | Description |
|--------|------|-------------|
| `type_ordinal` | INT | Enum type ordinal |
| `type_name` | TEXT | Enum name |
| `value_name` | TEXT | Constant name |
| `value` | INT | Constant value |

#### types_func_args
Function prototype arguments with type classification.

| Column | Type | Description |
|--------|------|-------------|
| `type_ordinal` | INT | Function type ordinal |
| `type_name` | TEXT | Function type name |
| `arg_index` | INT | Argument index (-1 = return type, 0+ = args) |
| `arg_name` | TEXT | Argument name |
| `arg_type` | TEXT | Argument type string |
| `calling_conv` | TEXT | Calling convention (on return row only) |

**Surface-level type classification** (literal type as written):

| Column | Type | Description |
|--------|------|-------------|
| `is_ptr` | INT | 1 if pointer type |
| `is_int` | INT | 1 if exactly int type |
| `is_integral` | INT | 1 if int-like (int, long, short, char, bool) |
| `is_float` | INT | 1 if float/double |
| `is_void` | INT | 1 if void |
| `is_struct` | INT | 1 if struct/union |
| `is_array` | INT | 1 if array |
| `ptr_depth` | INT | Pointer depth (int** = 2) |
| `base_type` | TEXT | Type with pointers stripped |

**Resolved type classification** (after typedef resolution):

| Column | Type | Description |
|--------|------|-------------|
| `is_ptr_resolved` | INT | 1 if resolved type is pointer |
| `is_int_resolved` | INT | 1 if resolved type is exactly int |
| `is_integral_resolved` | INT | 1 if resolved type is int-like |
| `is_float_resolved` | INT | 1 if resolved type is float/double |
| `is_void_resolved` | INT | 1 if resolved type is void |
| `ptr_depth_resolved` | INT | Pointer depth after resolution |
| `base_type_resolved` | TEXT | Resolved type with pointers stripped |

```sql
-- Functions returning integers (strict: exactly int)
SELECT type_name FROM types_func_args
WHERE arg_index = -1 AND is_int = 1;

-- Functions returning integers (loose: includes BOOL, DWORD, LONG)
SELECT type_name FROM types_func_args
WHERE arg_index = -1 AND is_integral_resolved = 1;

-- Functions taking 4 pointer arguments
SELECT type_name, COUNT(*) as ptr_args FROM types_func_args
WHERE arg_index >= 0 AND is_ptr = 1
GROUP BY type_ordinal HAVING ptr_args = 4;

-- Typedefs that hide pointers (HANDLE, etc.)
SELECT type_name, arg_type FROM types_func_args
WHERE is_ptr = 0 AND is_ptr_resolved = 1;
```

### Type Views

Convenience views for filtering types:

| View | Description |
|------|-------------|
| `types_v_structs` | `SELECT * FROM types WHERE is_struct = 1` |
| `types_v_unions` | `SELECT * FROM types WHERE is_union = 1` |
| `types_v_enums` | `SELECT * FROM types WHERE is_enum = 1` |
| `types_v_typedefs` | `SELECT * FROM types WHERE is_typedef = 1` |
| `types_v_funcs` | `SELECT * FROM types WHERE is_func = 1` |
| `local_types` | Legacy compatibility view |

### Extended Tables

#### bookmarks
User-defined bookmarks/marked positions.

| Column | Type | Description |
|--------|------|-------------|
| `index` | INT | Bookmark index |
| `address` | INT | Bookmarked address |
| `description` | TEXT | Bookmark description |

```sql
-- List all bookmarks
SELECT printf('0x%X', address) as addr, description FROM bookmarks;
```

#### heads
All defined items (code/data heads) in the database.

| Column | Type | Description |
|--------|------|-------------|
| `address` | INT | Head address |
| `size` | INT | Item size |
| `flags` | INT | IDA flags |

**Performance:** This table can be very large. Always use address range filters.

#### fixups
Relocation and fixup information.

| Column | Type | Description |
|--------|------|-------------|
| `address` | INT | Fixup address |
| `type` | INT | Fixup type |
| `target` | INT | Target address |

#### hidden_ranges
Collapsed/hidden code regions in IDA.

| Column | Type | Description |
|--------|------|-------------|
| `start_ea` | INT | Range start |
| `end_ea` | INT | Range end |
| `description` | TEXT | Description |
| `visible` | INT | Visibility state |

#### problems
IDA analysis problems and warnings.

| Column | Type | Description |
|--------|------|-------------|
| `address` | INT | Problem address |
| `type` | INT | Problem type code |
| `description` | TEXT | Problem description |

```sql
-- Find all analysis problems
SELECT printf('0x%X', address) as addr, description FROM problems;
```

#### fchunks
Function chunks (for functions with non-contiguous code, like exception handlers).

| Column | Type | Description |
|--------|------|-------------|
| `func_addr` | INT | Parent function |
| `start_ea` | INT | Chunk start |
| `end_ea` | INT | Chunk end |
| `size` | INT | Chunk size |

```sql
-- Functions with multiple chunks (complex control flow)
SELECT func_at(func_addr) as name, COUNT(*) as chunks
FROM fchunks GROUP BY func_addr HAVING chunks > 1;
```

#### signatures
FLIRT signature matches.

| Column | Type | Description |
|--------|------|-------------|
| `address` | INT | Matched address |
| `name` | TEXT | Signature name |
| `library` | TEXT | Library name |

#### mappings
Memory mappings for debugging.

| Column | Type | Description |
|--------|------|-------------|
| `from_ea` | INT | Mapped from |
| `to_ea` | INT | Mapped to |
| `size` | INT | Mapping size |

### Metadata Tables

#### db_info
Database-level metadata.

| Column | Type | Description |
|--------|------|-------------|
| `key` | TEXT | Metadata key |
| `value` | TEXT | Metadata value |

```sql
-- Get database info
SELECT * FROM db_info;
```

#### ida_info
IDA processor and analysis info.

| Column | Type | Description |
|--------|------|-------------|
| `key` | TEXT | Info key |
| `value` | TEXT | Info value |

```sql
-- Get processor type
SELECT value FROM ida_info WHERE key = 'procname';
```

### Disassembly Tables

#### disasm_loops
Detected loops in disassembly.

| Column | Type | Description |
|--------|------|-------------|
| `func_addr` | INT | Function address |
| `loop_start` | INT | Loop header address |
| `loop_end` | INT | Loop end address |

### Disassembly Views

Views for disassembly-level analysis (no Hex-Rays required):

| View | Description |
|------|-------------|
| `disasm_v_leaf_funcs` | Functions with no outgoing calls |
| `disasm_v_call_chains` | Call chain paths (recursive CTE) |
| `disasm_v_calls_in_loops` | Calls inside loop bodies |
| `disasm_v_funcs_with_loops` | Functions containing loops |

```sql
-- Find functions that don't call anything
SELECT * FROM disasm_v_leaf_funcs LIMIT 10;

-- Find hotspot calls (inside loops)
SELECT func_at(func_addr) as func, callee_name
FROM disasm_v_calls_in_loops;
```

---

## SQL Functions

### Disassembly
| Function | Description |
|----------|-------------|
| `disasm(addr)` | Disassembly line at address |
| `disasm(addr, n)` | Multiple lines from address |
| `bytes(addr, n)` | Bytes as hex string |
| `bytes_raw(addr, n)` | Raw bytes as BLOB |
| `mnemonic(addr)` | Instruction mnemonic only |
| `operand(addr, n)` | Operand text (n=0-5) |

### Binary Search
| Function | Description |
|----------|-------------|
| `search_bytes(pattern)` | Find all matches, returns JSON array |
| `search_bytes(pattern, start, end)` | Search within address range |
| `search_first(pattern)` | First match address (or NULL) |
| `search_first(pattern, start, end)` | First match in range |

**Pattern syntax (IDA native):**
- `"48 8B 05"` - Exact bytes (hex, space-separated)
- `"48 ? 05"` or `"48 ?? 05"` - `?` = any byte wildcard (whole byte only)
- `"(01 02 03)"` - Alternatives (match any of these bytes)

**Note:** Unlike Binary Ninja, IDA does NOT support nibble wildcards or regex.

**Example:**
```sql
-- Find all matches for a pattern
SELECT search_bytes('48 8B ? 00');

-- Parse JSON results
SELECT json_extract(value, '$.address') as addr
FROM json_each(search_bytes('48 89 ?'))
LIMIT 10;

-- First match only
SELECT printf('0x%llX', search_first('CC CC CC'));

-- Search with alternatives
SELECT search_bytes('E8 (01 02 03 04)');
```

**Optimization Pattern: Find functions using specific instruction**

To answer "How many functions use RDTSC instruction?" efficiently:
```sql
-- Count unique functions containing RDTSC (opcode: 0F 31)
SELECT COUNT(DISTINCT func_start(json_extract(value, '$.address'))) as count
FROM json_each(search_bytes('0F 31'))
WHERE func_start(json_extract(value, '$.address')) IS NOT NULL;

-- List those functions with names
SELECT DISTINCT
    func_start(json_extract(value, '$.address')) as func_ea,
    name_at(func_start(json_extract(value, '$.address'))) as func_name
FROM json_each(search_bytes('0F 31'))
WHERE func_start(json_extract(value, '$.address')) IS NOT NULL;
```

This is **much faster** than scanning all disassembly lines because:
- `search_bytes()` uses native binary search
- `func_start()` is O(1) lookup in IDA's function index

### Names & Functions
| Function | Description |
|----------|-------------|
| `name_at(addr)` | Name at address |
| `func_at(addr)` | Function name containing address |
| `func_start(addr)` | Start of containing function |
| `func_end(addr)` | End of containing function |
| `func_qty()` | Total function count |
| `func_at_index(n)` | Function address at index (O(1)) |

### Cross-References
| Function | Description |
|----------|-------------|
| `xrefs_to(addr)` | JSON array of xrefs TO address |
| `xrefs_from(addr)` | JSON array of xrefs FROM address |

### Navigation
| Function | Description |
|----------|-------------|
| `next_head(addr)` | Next defined item |
| `prev_head(addr)` | Previous defined item |
| `segment_at(addr)` | Segment name at address |
| `hex(val)` | Format as hex string |

### Comments
| Function | Description |
|----------|-------------|
| `comment_at(addr)` | Get comment at address |
| `set_comment(addr, text)` | Set regular comment |
| `set_comment(addr, text, 1)` | Set repeatable comment |

### Modification
| Function | Description |
|----------|-------------|
| `set_name(addr, name)` | Set name at address |

### Item Analysis
| Function | Description |
|----------|-------------|
| `item_type(addr)` | Item type flags at address |
| `item_size(addr)` | Item size at address |
| `is_code(addr)` | Returns 1 if address is code |
| `is_data(addr)` | Returns 1 if address is data |
| `flags_at(addr)` | Raw IDA flags at address |

### Instruction Details
| Function | Description |
|----------|-------------|
| `itype(addr)` | Instruction type code (processor-specific) |
| `decode_insn(addr)` | Full instruction info as JSON |
| `operand_type(addr, n)` | Operand type code (o_void, o_reg, etc.) |
| `operand_value(addr, n)` | Operand value (register num, immediate, etc.) |

```sql
-- Get instruction type for filtering
SELECT address, itype(address) as itype, mnemonic(address)
FROM heads WHERE is_code(address) = 1 LIMIT 10;

-- Decode full instruction
SELECT decode_insn(0x401000);
```

### Decompilation

**When to use `decompile()` vs `pseudocode` table:**
- **To view/show pseudocode** → always use `SELECT decompile(addr)`. Returns the full function as a single text block with `/* ea */` address prefixes. This is fast, efficient, and what you should use when the user asks to "decompile", "show the code", or "show the pseudocode".
- **To read specific lines or columns** → query the `pseudocode` table. If you already have the full output from `decompile()`, refer to it directly. Only query the table when you need structured access (e.g. filtering by ea, reading comment values).
- **To add/edit/delete comments** → `UPDATE pseudocode SET comment = '...' WHERE func_addr = X AND ea = Y`. The pseudocode table is the write interface for decompiler comments.

| Function | Description |
|----------|-------------|
| `decompile(addr)` | **PREFERRED** — Full pseudocode with `/* ea */` prefixes (requires Hex-Rays) |
| `decompile(addr, 1)` | Same but forces re-decompilation (use after writing comments or renaming variables) |
| `list_lvars(addr)` | List local variables as JSON |
| `rename_lvar(addr, old, new)` | Rename a local variable (shortcut for `UPDATE ctree_lvars`) |

```sql
-- Decompile a function (PREFERRED way to view pseudocode)
SELECT decompile(0x401000);

-- After modifying comments or variables, re-decompile to see changes
SELECT decompile(0x401000, 1);

-- Get all local variables in a function
SELECT list_lvars(0x401000);

-- Rename a variable (function shortcut)
SELECT rename_lvar(0x401000, 'v1', 'buffer_size');

-- Equivalent using UPDATE (canonical approach)
UPDATE ctree_lvars SET name = 'buffer_size' WHERE func_addr = 0x401000 AND name = 'v1';
```

### File Generation
| Function | Description |
|----------|-------------|
| `gen_asm_file(start, end, path)` | Generate ASM file |
| `gen_lst_file(start, end, path)` | Generate listing file |
| `gen_map_file(path)` | Generate MAP file |
| `gen_idc_file(start, end, path)` | Generate IDC script |
| `gen_html_file(start, end, path)` | Generate HTML file |

```sql
-- Export function as ASM
SELECT gen_asm_file(0x401000, 0x401100, '/tmp/func.asm');

-- Generate MAP file
SELECT gen_map_file('/tmp/binary.map');
```

### Graph Generation
| Function | Description |
|----------|-------------|
| `gen_cfg_dot(addr)` | Generate CFG as DOT graph string |
| `gen_cfg_dot_file(addr, path)` | Write CFG DOT to file |
| `gen_schema_dot()` | Generate database schema as DOT |

```sql
-- Get CFG for a function as DOT format
SELECT gen_cfg_dot(0x401000);

-- Export schema visualization
SELECT gen_schema_dot();
```

### Entity Search ("Jump to Anything")
| Function | Description |
|----------|-------------|
| `jump_search(pattern, mode, limit, offset)` | Search entities, returns JSON array |
| `jump_query(pattern, mode, limit, offset)` | Returns the generated SQL string |

```sql
-- Search for functions/types/labels starting with 'sub'
SELECT jump_search('sub', 'prefix', 10, 0);

-- Search for anything containing 'main'
SELECT jump_search('main', 'contains', 10, 0);
```

### String List Functions

IDA maintains a cached list of strings. Use `rebuild_strings()` to detect and cache strings.

| Function | Description |
|----------|-------------|
| `rebuild_strings()` | Rebuild with ASCII + UTF-16, minlen 5 (default) |
| `rebuild_strings(minlen)` | Rebuild with custom minimum length |
| `rebuild_strings(minlen, types)` | Rebuild with custom length and type mask |
| `string_count()` | Get current string count (no rebuild) |

**Type mask values:**
- `1` = ASCII only (STRTYPE_C)
- `2` = UTF-16 only (STRTYPE_C_16)
- `4` = UTF-32 only (STRTYPE_C_32)
- `3` = ASCII + UTF-16 (default)
- `7` = All types

```sql
-- Check current string count
SELECT string_count();

-- Rebuild with defaults (ASCII + UTF-16, minlen 5)
SELECT rebuild_strings();

-- Rebuild with shorter minimum length
SELECT rebuild_strings(4);

-- Rebuild with specific types
SELECT rebuild_strings(5, 1);   -- ASCII only
SELECT rebuild_strings(5, 7);   -- All types (ASCII + UTF-16 + UTF-32)

-- Typical workflow: rebuild then query
SELECT rebuild_strings();
SELECT * FROM strings WHERE content LIKE '%error%';
```

**IMPORTANT - Agent Behavior for String Queries:**
When the user asks about strings (e.g., "show me the strings", "what strings are in this binary"):
1. First run `SELECT rebuild_strings()` to ensure strings are detected
2. Then query the `strings` table

The `rebuild_strings()` function configures IDA's string detection with sensible defaults (ASCII + UTF-16, minimum length 5) and rebuilds the string list. This ensures the user gets results even if the database had no prior string analysis.

---

## Entity Search Table (jump_entities)

A table-valued function for unified entity search with full SQL composability.

### Usage

```sql
-- Basic search (function-call syntax)
SELECT * FROM jump_entities('sub', 'prefix') LIMIT 10;

-- Filter by kind
SELECT * FROM jump_entities('EH', 'prefix') WHERE kind = 'struct';

-- JOIN with other tables
SELECT j.name, f.size
FROM jump_entities('sub', 'prefix') j
LEFT JOIN funcs f ON j.address = f.address
WHERE j.kind = 'function';
```

### Parameters

| Parameter | Description |
|-----------|-------------|
| `pattern` | Search pattern (required) |
| `mode` | `'prefix'` or `'contains'` |

### Columns

| Column | Type | Description |
|--------|------|-------------|
| `name` | TEXT | Entity name |
| `kind` | TEXT | function/label/segment/struct/union/enum/member/enum_member |
| `address` | INT | Address (for functions, labels, segments) |
| `ordinal` | INT | Type ordinal (for types, members) |
| `parent_name` | TEXT | Parent type (for members) |
| `full_name` | TEXT | Fully qualified name |

**Use Case:** Implement "Jump to Anything" with virtual scrolling - lazy cursor respects LIMIT.

---

## Performance Rules

### CRITICAL: Constraint Pushdown

Some tables have **optimized filters** that use efficient IDA SDK APIs:

| Table | Optimized Filter | Without Filter |
|-------|------------------|----------------|
| `instructions` | `func_addr = X` | O(all instructions) - SLOW |
| `blocks` | `func_ea = X` | O(all blocks) |
| `xrefs` | `to_ea = X` or `from_ea = X` | O(all xrefs) |
| `pseudocode` | `func_addr = X` | **Decompiles ALL functions** |
| `ctree*` | `func_addr = X` | **Decompiles ALL functions** |

**Always filter decompiler tables by `func_addr`!**

### Use Integer Comparisons

```sql
-- SLOW: String comparison
WHERE mnemonic = 'call'

-- FAST: Integer comparison
WHERE itype IN (16, 18)  -- x86 call opcodes
```

### O(1) Random Access

```sql
-- SLOW: O(n) - sorts all rows
SELECT address FROM funcs ORDER BY RANDOM() LIMIT 1;

-- FAST: O(1) - direct index access
SELECT func_at_index(ABS(RANDOM()) % func_qty());
```

---

## Common Query Patterns

### Find Most Called Functions

```sql
SELECT f.name, COUNT(*) as callers
FROM funcs f
JOIN xrefs x ON f.address = x.to_ea
WHERE x.is_code = 1
GROUP BY f.address
ORDER BY callers DESC
LIMIT 10;
```

### Find Functions Calling a Specific API

```sql
SELECT DISTINCT func_at(from_ea) as caller
FROM xrefs
WHERE to_ea = (SELECT address FROM imports WHERE name = 'CreateFileW');
```

### String Cross-Reference Analysis

```sql
SELECT s.content, func_at(x.from_ea) as used_by
FROM strings s
JOIN xrefs x ON s.address = x.to_ea
WHERE s.content LIKE '%password%';
```

### Function Complexity (by Block Count)

```sql
SELECT func_at(func_ea) as name, COUNT(*) as block_count
FROM blocks
GROUP BY func_ea
ORDER BY block_count DESC
LIMIT 10;
```

### Find Leaf Functions (No Outgoing Calls)

```sql
SELECT f.name, f.size
FROM funcs f
LEFT JOIN disasm_calls c ON c.func_addr = f.address
GROUP BY f.address
HAVING COUNT(c.ea) = 0
ORDER BY f.size DESC;
```

### Functions with Deep Call Chains

```sql
SELECT f.name, MAX(cc.depth) as max_depth
FROM disasm_v_call_chains cc
JOIN funcs f ON f.address = cc.root_func
GROUP BY cc.root_func
ORDER BY max_depth DESC
LIMIT 10;
```

### Security: Dangerous Function Calls with Stack Buffers

```sql
SELECT f.name, c.callee_name, printf('0x%X', c.ea) as address
FROM funcs f
JOIN ctree_v_calls c ON c.func_addr = f.address
JOIN ctree_call_args a ON a.func_addr = c.func_addr AND a.call_item_id = c.item_id
WHERE c.callee_name IN ('strcpy', 'strcat', 'sprintf', 'gets', 'memcpy')
  AND a.arg_idx = 0 AND a.arg_var_is_stk = 1
ORDER BY f.name;
```

### Find Zero Comparisons (Potential Error Checks)

```sql
SELECT func_at(func_addr) as func, printf('0x%X', ea) as addr
FROM ctree_v_comparisons
WHERE op_name = 'cot_eq' AND rhs_op = 'cot_num' AND rhs_num = 0;
```

### Calls Inside Loops (Performance Hotspots)

```sql
SELECT f.name, l.callee_name, l.loop_op
FROM ctree_v_calls_in_loops l
JOIN funcs f ON f.address = l.func_addr
ORDER BY f.name;
```

### malloc with Constant Size

```sql
SELECT func_at(c.func_addr) as func, a.arg_num_value as size
FROM ctree_v_calls c
JOIN ctree_call_args a ON a.func_addr = c.func_addr AND a.call_item_id = c.item_id
WHERE c.callee_name LIKE '%malloc%'
  AND a.arg_idx = 0 AND a.arg_op = 'cot_num'
ORDER BY a.arg_num_value DESC;
```

### Largest Structures

```sql
SELECT name, size, alignment
FROM types
WHERE is_struct = 1 AND size > 0
ORDER BY size DESC
LIMIT 10;
```

### Instruction Profile for a Function

```sql
SELECT mnemonic, COUNT(*) as count
FROM instructions
WHERE func_addr = 0x401330
GROUP BY mnemonic
ORDER BY count DESC;
```

### Import Dependency Map

```sql
-- Which modules does each function depend on?
SELECT f.name as func_name, i.module, COUNT(*) as api_count
FROM funcs f
JOIN disasm_calls dc ON dc.func_addr = f.address
JOIN imports i ON dc.callee_addr = i.address
GROUP BY f.address, i.module
ORDER BY f.name, api_count DESC;
```

### Find Indirect Calls (Potential Virtual Functions/Callbacks)

```sql
-- Functions with indirect calls (call through register/memory)
SELECT f.name, COUNT(*) as indirect_calls
FROM funcs f
JOIN disasm_calls dc ON dc.func_addr = f.address
WHERE dc.callee_addr = 0  -- Unresolved target = indirect
GROUP BY f.address
ORDER BY indirect_calls DESC
LIMIT 20;
```

### String Format Audit (printf-style Vulnerabilities)

```sql
-- Format string usage with variable formats (potential vuln)
SELECT f.name, c.callee_name, printf('0x%X', c.ea) as addr
FROM funcs f
JOIN ctree_v_calls c ON c.func_addr = f.address
JOIN ctree_call_args a ON a.func_addr = c.func_addr AND a.call_item_id = c.item_id
WHERE c.callee_name LIKE '%printf%'
  AND a.arg_idx = 0  -- First arg is format string
  AND a.arg_op = 'cot_var';  -- Variable, not constant string
```

### Memory Allocation Patterns

```sql
-- Find functions that allocate but may not free
WITH allocators AS (
    SELECT func_addr, COUNT(*) as alloc_count
    FROM disasm_calls
    WHERE callee_name LIKE '%alloc%' OR callee_name LIKE '%malloc%'
    GROUP BY func_addr
),
freers AS (
    SELECT func_addr, COUNT(*) as free_count
    FROM disasm_calls
    WHERE callee_name LIKE '%free%'
    GROUP BY func_addr
)
SELECT f.name,
       COALESCE(a.alloc_count, 0) as allocations,
       COALESCE(r.free_count, 0) as frees
FROM funcs f
LEFT JOIN allocators a ON f.address = a.func_addr
LEFT JOIN freers r ON f.address = r.func_addr
WHERE a.alloc_count > 0 AND COALESCE(r.free_count, 0) = 0
ORDER BY allocations DESC;
```

### Control Flow Anomalies

```sql
-- Functions with many basic blocks but few instructions (possibly obfuscated)
SELECT
    f.name,
    f.size,
    COUNT(DISTINCT b.start_ea) as blocks,
    f.size / COUNT(DISTINCT b.start_ea) as avg_block_size
FROM funcs f
JOIN blocks b ON b.func_ea = f.address
WHERE f.size > 100
GROUP BY f.address
HAVING COUNT(DISTINCT b.start_ea) > 10
   AND f.size / COUNT(DISTINCT b.start_ea) < 10  -- Very small blocks
ORDER BY blocks DESC;
```

### Return Value Analysis

```sql
-- Functions with multiple return statements (complex control flow)
SELECT f.name, COUNT(*) as return_count
FROM funcs f
JOIN ctree ct ON ct.func_addr = f.address
WHERE ct.op_name = 'cit_return'
GROUP BY f.address
HAVING COUNT(*) > 3
ORDER BY return_count DESC;

-- Functions that return 0 (common success pattern)
SELECT DISTINCT func_at(func_addr) as name FROM ctree_v_returns
WHERE return_op = 'cot_num' AND return_num = 0;

-- Functions that return -1 (error sentinel)
SELECT DISTINCT func_at(func_addr) as name FROM ctree_v_returns
WHERE return_op = 'cot_num' AND return_num = -1;

-- Functions that return a specific constant
SELECT DISTINCT func_at(func_addr) as name FROM ctree_v_returns
WHERE return_op = 'cot_num' AND return_num = 1;
```

### Function Signature Queries

```sql
-- Functions returning integers (includes BOOL, DWORD via resolved)
SELECT type_name FROM types_func_args
WHERE arg_index = -1 AND is_integral_resolved = 1;

-- Functions taking exactly 4 pointer arguments
SELECT type_name, COUNT(*) as ptr_args FROM types_func_args
WHERE arg_index >= 0 AND is_ptr = 1
GROUP BY type_ordinal HAVING ptr_args = 4;

-- Functions with string parameters (char*/wchar_t*)
SELECT DISTINCT type_name FROM types_func_args
WHERE arg_index >= 0 AND is_ptr = 1
  AND base_type_resolved IN ('char', 'wchar_t', 'CHAR', 'WCHAR');

-- Typedefs hiding pointers (HANDLE, HMODULE, etc.)
SELECT DISTINCT type_name, arg_type FROM types_func_args
WHERE is_ptr = 0 AND is_ptr_resolved = 1;

-- Functions returning void pointers
SELECT type_name FROM types_func_args
WHERE arg_index = -1 AND is_ptr_resolved = 1 AND is_void_resolved = 1;
```

### Loops with System Calls (Performance/Security Hotspots)

```sql
-- System API calls inside loops
SELECT
    f.name as function,
    l.callee_name as api_called,
    l.loop_op as loop_type
FROM ctree_v_calls_in_loops l
JOIN funcs f ON f.address = l.func_addr
JOIN imports i ON l.callee_name = i.name
ORDER BY f.name;
```

### Type Usage Statistics

```sql
-- Most referenced types (by struct member usage in decompiled code)
SELECT tm.type_name, COUNT(DISTINCT ct.func_addr) as func_count
FROM types_members tm
JOIN ctree ct ON ct.var_name = tm.member_name
GROUP BY tm.type_name
ORDER BY func_count DESC
LIMIT 20;
```

### Data Section Analysis

```sql
-- Find functions referencing data sections
SELECT
    f.name,
    s.name as segment,
    COUNT(*) as data_refs
FROM funcs f
JOIN xrefs x ON x.from_ea BETWEEN f.address AND f.end_ea
JOIN segments s ON x.to_ea BETWEEN s.start_ea AND s.end_ea
WHERE s.class = 'DATA' AND x.is_code = 0
GROUP BY f.address, s.name
ORDER BY data_refs DESC
LIMIT 20;
```

### Exception Handler Detection

```sql
-- Functions with multiple chunks (often due to exception handlers)
SELECT
    f.name,
    COUNT(*) as chunk_count,
    SUM(fc.size) as total_size
FROM funcs f
JOIN fchunks fc ON fc.func_addr = f.address
GROUP BY f.address
HAVING COUNT(*) > 1
ORDER BY chunk_count DESC;
```

---

## Advanced SQL Patterns

### Common Table Expressions (CTEs)

CTEs make complex queries readable and allow recursive traversal.

#### Basic CTE for Filtering

```sql
-- Find functions that both call malloc AND check return value
WITH malloc_callers AS (
    SELECT DISTINCT func_addr
    FROM disasm_calls
    WHERE callee_name LIKE '%malloc%'
),
null_checkers AS (
    SELECT DISTINCT func_addr
    FROM ctree_v_comparisons
    WHERE rhs_num = 0 AND op_name = 'cot_eq'
)
SELECT f.name
FROM funcs f
JOIN malloc_callers m ON f.address = m.func_addr
JOIN null_checkers n ON f.address = n.func_addr;
```

#### CTE with Aggregation

```sql
-- Functions ranked by complexity (calls * blocks)
WITH call_counts AS (
    SELECT func_addr, COUNT(*) as call_cnt
    FROM disasm_calls
    GROUP BY func_addr
),
block_counts AS (
    SELECT func_ea as func_addr, COUNT(*) as block_cnt
    FROM blocks
    GROUP BY func_ea
)
SELECT f.name,
       COALESCE(c.call_cnt, 0) as calls,
       COALESCE(b.block_cnt, 0) as blocks,
       COALESCE(c.call_cnt, 0) * COALESCE(b.block_cnt, 0) as complexity
FROM funcs f
LEFT JOIN call_counts c ON f.address = c.func_addr
LEFT JOIN block_counts b ON f.address = b.func_addr
ORDER BY complexity DESC
LIMIT 10;
```

### Recursive CTEs (Call Graph Traversal)

```sql
-- Find all functions reachable from main (up to depth 5)
WITH RECURSIVE call_graph AS (
    -- Base case: start from main
    SELECT address as func_addr, name, 0 as depth
    FROM funcs WHERE name = 'main'

    UNION ALL

    -- Recursive case: follow calls
    SELECT f.address, f.name, cg.depth + 1
    FROM call_graph cg
    JOIN disasm_calls dc ON dc.func_addr = cg.func_addr
    JOIN funcs f ON f.address = dc.callee_addr
    WHERE cg.depth < 5
      AND dc.callee_addr != 0  -- Skip indirect calls
)
SELECT DISTINCT func_addr, name, MIN(depth) as min_depth
FROM call_graph
GROUP BY func_addr
ORDER BY min_depth, name;
```

```sql
-- Reverse call graph: who calls this function (transitive)
WITH RECURSIVE callers AS (
    -- Base: direct callers of target
    SELECT DISTINCT dc.func_addr, 1 as depth
    FROM disasm_calls dc
    WHERE dc.callee_addr = 0x401000

    UNION ALL

    -- Recursive: who calls the callers
    SELECT DISTINCT dc.func_addr, c.depth + 1
    FROM callers c
    JOIN disasm_calls dc ON dc.callee_addr = c.func_addr
    WHERE c.depth < 5
)
SELECT func_at(func_addr) as caller, MIN(depth) as distance
FROM callers
GROUP BY func_addr
ORDER BY distance, caller;
```

### Window Functions

```sql
-- Rank functions by size within each segment
SELECT
    segment_at(f.address) as seg,
    f.name,
    f.size,
    ROW_NUMBER() OVER (PARTITION BY segment_at(f.address) ORDER BY f.size DESC) as rank
FROM funcs f
WHERE f.size > 0;
```

```sql
-- Running total of function sizes
SELECT
    name,
    size,
    SUM(size) OVER (ORDER BY address) as cumulative_size
FROM funcs
ORDER BY address;
```

```sql
-- Find consecutive functions with similar sizes (possible duplicates)
SELECT
    name,
    size,
    LAG(name) OVER (ORDER BY size) as prev_name,
    LAG(size) OVER (ORDER BY size) as prev_size
FROM funcs
WHERE size > 100;
```

### Complex JOINs

#### Multi-Table Join (Functions with Context)

```sql
-- Function overview with all relationships
SELECT
    f.name,
    f.size,
    segment_at(f.address) as segment,
    (SELECT COUNT(*) FROM blocks WHERE func_ea = f.address) as block_count,
    (SELECT COUNT(*) FROM disasm_calls WHERE func_addr = f.address) as outgoing_calls,
    (SELECT COUNT(*) FROM xrefs WHERE to_ea = f.address AND is_code = 1) as incoming_calls,
    (SELECT COUNT(*) FROM ctree_lvars WHERE func_addr = f.address) as local_vars
FROM funcs f
ORDER BY f.size DESC
LIMIT 20;
```

#### Self-Join (Compare Functions)

```sql
-- Find functions with identical sizes (potential clones)
SELECT
    f1.name as func1,
    f2.name as func2,
    f1.size
FROM funcs f1
JOIN funcs f2 ON f1.size = f2.size AND f1.address < f2.address
WHERE f1.size > 50  -- Ignore tiny functions
ORDER BY f1.size DESC;
```

### Subqueries

```sql
-- Functions that call more APIs than average
SELECT f.name, call_count
FROM (
    SELECT func_addr, COUNT(*) as call_count
    FROM disasm_calls dc
    JOIN imports i ON dc.callee_addr = i.address
    GROUP BY func_addr
) sub
JOIN funcs f ON f.address = sub.func_addr
WHERE call_count > (
    SELECT AVG(cnt) FROM (
        SELECT COUNT(*) as cnt
        FROM disasm_calls dc
        JOIN imports i ON dc.callee_addr = i.address
        GROUP BY func_addr
    )
)
ORDER BY call_count DESC;
```

### CASE Expressions

```sql
-- Categorize functions by complexity
SELECT
    name,
    size,
    CASE
        WHEN size < 50 THEN 'tiny'
        WHEN size < 200 THEN 'small'
        WHEN size < 1000 THEN 'medium'
        WHEN size < 5000 THEN 'large'
        ELSE 'huge'
    END as category
FROM funcs
ORDER BY size DESC;
```

```sql
-- Classify strings by content
SELECT
    content,
    CASE
        WHEN content LIKE '%error%' OR content LIKE '%fail%' THEN 'error'
        WHEN content LIKE '%password%' OR content LIKE '%key%' THEN 'sensitive'
        WHEN content LIKE '%http%' OR content LIKE '%://% ' THEN 'url'
        WHEN content LIKE '%.dll%' OR content LIKE '%.exe%' THEN 'file'
        ELSE 'other'
    END as category
FROM strings
WHERE length > 5;
```

### Batch Analysis with UNION ALL

```sql
-- Comprehensive security audit in one query
SELECT 'dangerous_func' as check_type, func_at(func_addr) as location, callee_name as detail
FROM disasm_calls
WHERE callee_name IN ('strcpy', 'strcat', 'sprintf', 'gets', 'scanf')

UNION ALL

SELECT 'crypto_usage', func_at(func_addr), callee_name
FROM disasm_calls
WHERE callee_name LIKE '%Crypt%' OR callee_name LIKE '%AES%' OR callee_name LIKE '%RSA%'

UNION ALL

SELECT 'network_call', func_at(func_addr), callee_name
FROM disasm_calls
WHERE callee_name IN ('socket', 'connect', 'send', 'recv', 'WSAStartup')

UNION ALL

SELECT 'registry_access', func_at(func_addr), callee_name
FROM disasm_calls
WHERE callee_name LIKE 'Reg%'

ORDER BY check_type, location;
```

### Efficient Pagination

```sql
-- Page through large result sets efficiently
SELECT * FROM (
    SELECT
        f.name,
        f.size,
        ROW_NUMBER() OVER (ORDER BY f.size DESC) as row_num
    FROM funcs f
)
WHERE row_num BETWEEN 101 AND 200;  -- Page 2 (100 per page)
```

### EXISTS for Efficient Filtering

```sql
-- Functions that have at least one string reference (more efficient than JOIN + DISTINCT)
SELECT f.name
FROM funcs f
WHERE EXISTS (
    SELECT 1 FROM xrefs x
    JOIN strings s ON x.to_ea = s.address
    WHERE x.from_ea BETWEEN f.address AND f.end_ea
);
```

```sql
-- Functions without any calls (leaf functions, EXISTS version)
SELECT f.name, f.size
FROM funcs f
WHERE NOT EXISTS (
    SELECT 1 FROM disasm_calls dc
    WHERE dc.func_addr = f.address
)
ORDER BY f.size DESC;
```

---

## Hex Address Formatting

IDA uses integer addresses. For display, use `printf()`:

```sql
-- 32-bit format
SELECT printf('0x%08X', address) as addr FROM funcs;

-- 64-bit format
SELECT printf('0x%016llX', address) as addr FROM funcs;

-- Auto-width
SELECT printf('0x%X', address) as addr FROM funcs;
```

---

## Common x86 Instruction Types

When filtering by `itype` (faster than string comparison):

| itype | Mnemonic | Description |
|-------|----------|-------------|
| 16 | call (near) | Direct call |
| 18 | call (indirect) | Indirect call |
| 122 | mov | Move data |
| 143 | push | Push to stack |
| 134 | pop | Pop from stack |
| 159 | retn | Return |
| 85 | jz | Jump if zero |
| 79 | jnz | Jump if not zero |
| 27 | cmp | Compare |
| 103 | nop | No operation |

---

## ctree Operation Names

Common Hex-Rays AST node types:

**Expressions (cot_*):**
- `cot_call` - Function call
- `cot_var` - Local variable
- `cot_obj` - Global object/function
- `cot_num` - Numeric constant
- `cot_str` - String literal
- `cot_ptr` - Pointer dereference
- `cot_ref` - Address-of
- `cot_asg` - Assignment
- `cot_add`, `cot_sub`, `cot_mul`, `cot_sdiv`, `cot_udiv` - Arithmetic
- `cot_eq`, `cot_ne`, `cot_lt`, `cot_gt` - Comparisons
- `cot_land`, `cot_lor`, `cot_lnot` - Logical
- `cot_band`, `cot_bor`, `cot_xor` - Bitwise

**Statements (cit_*):**
- `cit_if` - If statement
- `cit_for` - For loop
- `cit_while` - While loop
- `cit_do` - Do-while loop
- `cit_return` - Return statement
- `cit_block` - Code block

---

## Error Handling

- **No Hex-Rays license:** Decompiler tables (`pseudocode`, `ctree*`, `ctree_lvars`) will be empty or unavailable
- **No constraint on decompiler tables:** Query will be extremely slow (decompiles all functions)
- **Invalid address:** Functions like `func_at(addr)` return NULL
- **Missing function:** JOINs may return fewer rows than expected

---

## Quick Start Examples

### "What does this binary do?"

```sql
-- Entry points
SELECT * FROM entries;

-- Imported APIs (hints at functionality)
SELECT module, name FROM imports ORDER BY module, name;

-- Interesting strings
SELECT content FROM strings WHERE length > 10 ORDER BY length DESC LIMIT 20;
```

### "Find security-relevant code"

```sql
-- Dangerous string functions
SELECT DISTINCT func_at(func_addr) FROM disasm_calls
WHERE callee_name IN ('strcpy', 'strcat', 'sprintf', 'gets');

-- Crypto-related
SELECT * FROM imports WHERE name LIKE '%Crypt%' OR name LIKE '%Hash%';

-- Network-related
SELECT * FROM imports WHERE name LIKE '%socket%' OR name LIKE '%connect%' OR name LIKE '%send%';
```

### "Understand a specific function"

```sql
-- Basic info
SELECT * FROM funcs WHERE address = 0x401000;

-- Decompile (if Hex-Rays available)
SELECT decompile(0x401000);

-- Local variables
SELECT name, type, size FROM ctree_lvars WHERE func_addr = 0x401000;

-- What it calls
SELECT callee_name FROM disasm_calls WHERE func_addr = 0x401000;

-- What calls it
SELECT func_at(from_ea) FROM xrefs WHERE to_ea = 0x401000 AND is_code = 1;
```

### "Find all uses of a string"

```sql
SELECT s.content, func_at(x.from_ea) as function, printf('0x%X', x.from_ea) as location
FROM strings s
JOIN xrefs x ON s.address = x.to_ea
WHERE s.content LIKE '%config%';
```

---

## Natural Language Query Examples

These examples show how to translate common user questions into SQL.

### Function Signature Queries

**"Show me functions that return integers"**
```sql
-- Using funcs table (recommended - direct and fast)
SELECT name, return_type, arg_count FROM funcs
WHERE return_is_integral = 1
LIMIT 20;

-- Or via types_func_args (for typedef-aware queries)
SELECT DISTINCT type_name FROM types_func_args
WHERE arg_index = -1 AND is_integral_resolved = 1;
```

**"Show me functions that take 4 string arguments"**
```sql
-- String = char* or wchar_t*
SELECT type_name, COUNT(*) as string_args
FROM types_func_args
WHERE arg_index >= 0
  AND is_ptr_resolved = 1
  AND base_type_resolved IN ('char', 'wchar_t', 'CHAR', 'WCHAR')
GROUP BY type_ordinal
HAVING string_args = 4;
```

**"Which functions return pointers?"**
```sql
SELECT name, return_type FROM funcs
WHERE return_is_ptr = 1
ORDER BY name LIMIT 20;
```

**"Find void functions with many arguments"**
```sql
SELECT name, arg_count FROM funcs
WHERE return_is_void = 1 AND arg_count >= 4
ORDER BY arg_count DESC;
```

**"What calling conventions are used?"**
```sql
SELECT calling_conv, COUNT(*) as count
FROM funcs
WHERE calling_conv IS NOT NULL AND calling_conv != ''
GROUP BY calling_conv ORDER BY count DESC;
```

### Return Value Analysis

**"Which functions return 0?"**
```sql
SELECT DISTINCT f.name FROM funcs f
JOIN ctree_v_returns r ON r.func_addr = f.address
WHERE r.return_num = 0;
```

**"Find functions that return -1 (error pattern)"**
```sql
SELECT DISTINCT f.name FROM funcs f
JOIN ctree_v_returns r ON r.func_addr = f.address
WHERE r.return_num = -1;
```

**"Functions that return their input argument"**
```sql
SELECT DISTINCT f.name FROM funcs f
JOIN ctree_v_returns r ON r.func_addr = f.address
WHERE r.returns_arg = 1;
```

**"Functions that return the result of another call (wrappers)"**
```sql
SELECT DISTINCT f.name FROM funcs f
JOIN ctree_v_returns r ON r.func_addr = f.address
WHERE r.returns_call_result = 1;
```

**"Functions with multiple return statements"**
```sql
SELECT f.name, COUNT(*) as return_count
FROM funcs f
JOIN ctree_v_returns r ON r.func_addr = f.address
GROUP BY f.address
HAVING return_count > 1
ORDER BY return_count DESC LIMIT 20;
```

### Type Analysis

**"Find typedefs that hide pointers (like HANDLE)"**
```sql
SELECT DISTINCT type_name, arg_type, base_type_resolved
FROM types_func_args
WHERE is_ptr = 0 AND is_ptr_resolved = 1;
```

**"Functions with struct parameters"**
```sql
SELECT type_name, arg_name, arg_type FROM types_func_args
WHERE arg_index >= 0 AND is_struct = 1;
```

### Combined Queries

**"Integer-returning functions with 3+ args that return specific values"**
```sql
SELECT f.name, f.return_type, f.arg_count, r.return_num
FROM funcs f
JOIN ctree_v_returns r ON r.func_addr = f.address
WHERE f.return_is_integral = 1
  AND f.arg_count >= 3
  AND r.return_num IS NOT NULL
ORDER BY r.return_num;
```

**"Fastcall functions that return pointers"**
```sql
SELECT name, return_type, arg_count FROM funcs
WHERE calling_conv = 'fastcall' AND return_is_ptr = 1;
```

---

## Summary: When to Use What

| Goal | Table/Function |
|------|----------------|
| List all functions | `funcs` |
| Functions by return type | `funcs WHERE return_is_integral = 1` |
| Functions by arg count | `funcs WHERE arg_count >= N` |
| Void functions | `funcs WHERE return_is_void = 1` |
| Pointer-returning functions | `funcs WHERE return_is_ptr = 1` |
| Functions by calling convention | `funcs WHERE calling_conv = 'fastcall'` |
| Find who calls what | `xrefs` with `is_code = 1` |
| Find data references | `xrefs` with `is_code = 0` |
| Analyze imports | `imports` |
| Find strings | `strings` |
| Configure string types | `rebuild_strings(types, minlen)` |
| Instruction analysis | `instructions WHERE func_addr = X` |
| View decompiled code | `decompile(addr)` |
| Edit decompiler comments | `UPDATE pseudocode SET comment = '...' WHERE func_addr = X AND ea = Y` |
| AST pattern matching | `ctree WHERE func_addr = X` |
| Call patterns | `ctree_v_calls`, `disasm_calls` |
| Control flow | `ctree_v_loops`, `ctree_v_ifs` |
| Return value analysis | `ctree_v_returns` |
| Functions returning specific values | `ctree_v_returns WHERE return_num = 0` |
| Pass-through functions | `ctree_v_returns WHERE returns_arg = 1` |
| Wrapper functions | `ctree_v_returns WHERE returns_call_result = 1` |
| Variable analysis | `ctree_lvars WHERE func_addr = X` |
| Type information | `types`, `types_members` |
| Function signatures | `types_func_args` (with type classification) |
| Functions by return type | `types_func_args WHERE arg_index = -1` |
| Typedef-aware type queries | `types_func_args` (surface vs resolved) |
| Hidden pointer types | `types_func_args WHERE is_ptr = 0 AND is_ptr_resolved = 1` |
| Manage breakpoints | `breakpoints` (full CRUD) |
| Modify segments | `segments` (UPDATE name/class/perm, DELETE) |
| Delete instructions | `instructions` (DELETE converts to unexplored bytes) |
| Create types | `types` (INSERT struct/union/enum) |
| Add struct members | `types_members` (INSERT) |
| Add enum values | `types_enum_values` (INSERT) |
| Modify database | `funcs`, `names`, `comments`, `bookmarks` (INSERT/UPDATE/DELETE) |
| Jump to Anything | `jump_entities('pattern', 'mode')` |
| Entity search (JSON) | `jump_search('pattern', 'mode', limit, offset)` |

**Remember:** Always use `func_addr = X` constraints on instruction and decompiler tables for acceptable performance.

---

## Server Modes

IDASQL supports two server protocols for remote queries: **HTTP REST** (recommended) and raw TCP.

---

### HTTP REST Server (Recommended)

Standard REST API that works with curl, any HTTP client, or LLM tools.

**Starting the server:**
```bash
# Default port 8081
idasql -s database.i64 --http

# Custom port and bind address
idasql -s database.i64 --http 9000 --bind 0.0.0.0

# With authentication
idasql -s database.i64 --http 8081 --token mysecret
```

**HTTP Endpoints:**

| Endpoint | Method | Auth | Description |
|----------|--------|------|-------------|
| `/` | GET | No | Welcome message |
| `/help` | GET | No | API documentation (for LLM discovery) |
| `/query` | POST | Yes* | Execute SQL (body = raw SQL) |
| `/status` | GET | Yes* | Health check |
| `/shutdown` | POST | Yes* | Stop server |

*Auth required only if `--token` was specified.

**Example with curl:**
```bash
# Get API documentation
curl http://localhost:8081/help

# Execute SQL query
curl -X POST http://localhost:8081/query -d "SELECT name, size FROM funcs LIMIT 5"

# With authentication
curl -X POST http://localhost:8081/query \
     -H "Authorization: Bearer mysecret" \
     -d "SELECT * FROM funcs"

# Check status
curl http://localhost:8081/status
```

**Response Format (JSON):**
```json
{"success": true, "columns": ["name", "size"], "rows": [["main", "500"]], "row_count": 1}
```

```json
{"success": false, "error": "no such table: bad_table"}
```

---

### Raw TCP Server (Legacy)

Binary protocol with length-prefixed JSON. Use only when HTTP is not available.

**Starting the server:**
```bash
idasql -s database.i64 --server 13337
idasql -s database.i64 --server 13337 --token mysecret
```

**Connecting as client:**
```bash
idasql --remote localhost:13337 -q "SELECT name FROM funcs LIMIT 5"
idasql --remote localhost:13337 -i
```

```

`scripts/embed_prompt.py`:

```py
#!/usr/bin/env python3
"""
Converts idasql-agent.md to a C++ header with embedded raw string literal.
Only regenerates if the hpp is older than the md or doesn't exist.

Run: python scripts/embed_prompt.py prompts/idasql_agent.md src/common/idasql_agent_prompt.hpp
"""

import sys
import os
from datetime import datetime


def needs_regeneration(input_path: str, output_path: str) -> bool:
    """Check if output needs regeneration based on file timestamps."""
    if not os.path.exists(output_path):
        return True
    input_mtime = os.path.getmtime(input_path)
    output_mtime = os.path.getmtime(output_path)
    return input_mtime > output_mtime


def split_content(content: str, max_chunk: int = 15000) -> list:
    """Split content into chunks that MSVC can handle.

    MSVC has a ~16KB limit per string literal segment.
    We split at line boundaries to keep it readable.
    """
    chunks = []
    lines = content.split('\n')
    current_chunk = []
    current_size = 0

    for line in lines:
        line_size = len(line) + 1  # +1 for newline
        if current_size + line_size > max_chunk and current_chunk:
            chunks.append('\n'.join(current_chunk))
            current_chunk = [line]
            current_size = line_size
        else:
            current_chunk.append(line)
            current_size += line_size

    if current_chunk:
        chunks.append('\n'.join(current_chunk))

    return chunks


def embed_prompt(input_path: str, output_path: str, force: bool = False) -> bool:
    if not force and not needs_regeneration(input_path, output_path):
        print(f"Skipping {output_path} (up-to-date)")
        return False

    with open(input_path, 'r', encoding='utf-8') as f:
        content = f.read()

    # Use short delimiter (MSVC max is 16 chars)
    delimiter = "PROMPT"

    # Split content for MSVC compatibility
    chunks = split_content(content)

    # Build concatenated string literals
    if len(chunks) == 1:
        string_literal = f'R"{delimiter}({chunks[0]}){delimiter}"'
    else:
        parts = []
        for i, chunk in enumerate(chunks):
            parts.append(f'R"{delimiter}({chunk}){delimiter}"')
        string_literal = '\n    '.join(parts)

    header = f'''// Auto-generated from {os.path.basename(input_path)}
// Generated: {datetime.now().isoformat()}
// DO NOT EDIT - regenerate with: python scripts/embed_prompt.py

#pragma once

namespace idasql {{

inline constexpr const char* SYSTEM_PROMPT =
    {string_literal};

}} // namespace idasql
'''

    os.makedirs(os.path.dirname(output_path), exist_ok=True)
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(header)

    print(f"Generated {output_path} ({len(content)} bytes, {len(chunks)} chunks)")
    return True


if __name__ == "__main__":
    force = "--force" in sys.argv
    args = [a for a in sys.argv[1:] if a != "--force"]

    if len(args) != 2:
        print(f"Usage: {sys.argv[0]} [--force] <input.md> <output.hpp>")
        sys.exit(1)

    embed_prompt(args[0], args[1], force)

```

`src/CMakeLists.txt`:

```txt
# src/CMakeLists.txt - idasql source directory
# SQLite is now provided by xsql::xsql from libxsql

add_subdirectory(lib)

# CLI tool (standalone, uses idalib)
option(IDASQL_BUILD_CLI "Build idasql CLI tool" ON)
if(IDASQL_BUILD_CLI)
    add_subdirectory(cli)
endif()

# IDA Plugin (requires IDASDK)
option(IDASQL_BUILD_PLUGIN "Build idasql IDA plugin" ON)
if(IDASQL_BUILD_PLUGIN)
    add_subdirectory(plugin)
endif()

```

`src/cli/CMakeLists.txt`:

```txt
# idasql CLI - Command-line SQL interface to IDA databases
# Built as part of the main idasql project

# idasql CLI executable
ida_add_idalib(idasql_cli
    TYPE EXECUTABLE
    SOURCES
        main.cpp
)
target_link_libraries(idasql_cli PRIVATE xsql::xsql)
target_include_directories(idasql_cli PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/../lib/include)
target_compile_definitions(idasql_cli PRIVATE USE_IDA_SDK)

# Output name: idasql (not idasql_cli), placed next to ida.exe for idalib
set_target_properties(idasql_cli PROPERTIES
    OUTPUT_NAME "idasql"
    RUNTIME_OUTPUT_DIRECTORY "${IDABIN}"
    RUNTIME_OUTPUT_DIRECTORY_DEBUG "${IDABIN}"
    RUNTIME_OUTPUT_DIRECTORY_RELEASE "${IDABIN}"
)

# Add Windows manifest for UTF-8 support (Windows 10 1903+)
if(WIN32)
    target_sources(idasql_cli PRIVATE
        ${CMAKE_CURRENT_SOURCE_DIR}/idasql.manifest
    )
endif()

# Platform-specific settings
if(MSVC)
    file(TO_NATIVE_PATH "${IDABIN}" IDABIN_NATIVE)
    set_target_properties(idasql_cli PROPERTIES
        VS_DEBUGGER_ENVIRONMENT "PATH=${IDABIN_NATIVE};%PATH%"
    )
    target_link_libraries(idasql_cli PRIVATE ws2_32)
elseif(APPLE)
    set_target_properties(idasql_cli PROPERTIES
        BUILD_WITH_INSTALL_RPATH TRUE
        INSTALL_RPATH "@executable_path;$ENV{IDASDK}/bin"
    )
elseif(UNIX)
    set_target_properties(idasql_cli PROPERTIES
        BUILD_WITH_INSTALL_RPATH TRUE
        INSTALL_RPATH "$ORIGIN;$ENV{IDASDK}/bin"
    )
endif()

# Hex-Rays decompiler support
option(USE_HEXRAYS "Enable Hex-Rays decompiler support" ON)
if(USE_HEXRAYS)
    target_compile_definitions(idasql_cli PRIVATE USE_HEXRAYS)
endif()

# AI Agent support (from parent project)
if(IDASQL_WITH_AI_AGENT)
    target_sources(idasql_cli PRIVATE
        ${CMAKE_CURRENT_SOURCE_DIR}/../common/ai_agent.cpp
        ${CMAKE_CURRENT_SOURCE_DIR}/../common/mcp_server.cpp
    )
    target_include_directories(idasql_cli PRIVATE
        ${CMAKE_CURRENT_SOURCE_DIR}/../common
        ${CMAKE_CURRENT_SOURCE_DIR}/../../external/libagents/external/fastmcpp/include
    )
    target_link_libraries(idasql_cli PRIVATE libagents fastmcpp_core)
    target_compile_definitions(idasql_cli PRIVATE IDASQL_HAS_AI_AGENT)

    if(TARGET generate_prompt)
        add_dependencies(idasql_cli generate_prompt)
    endif()

    message(STATUS "idasql_cli: AI agent support enabled (with MCP server)")
endif()

# HTTP server support
target_sources(idasql_cli PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}/../common/http_server.cpp
)
target_compile_definitions(idasql_cli PRIVATE XSQL_HAS_THINCLIENT)

# cpp-httplib: provided transitively by xsql::xsql when XSQL_WITH_THINCLIENT=ON.
# Only fetch standalone if the target doesn't already exist (e.g. standalone build).
if(NOT TARGET httplib)
    include(FetchContent)
    FetchContent_Declare(
        cpp_httplib
        GIT_REPOSITORY https://github.com/yhirose/cpp-httplib.git
        GIT_TAG v0.15.3
    )
    FetchContent_MakeAvailable(cpp_httplib)
    target_include_directories(idasql_cli PRIVATE ${cpp_httplib_SOURCE_DIR})
endif()

# idasql.exe is placed next to ida.exe via RUNTIME_OUTPUT_DIRECTORY above.

```

`src/cli/idasql.manifest`:

```manifest
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly manifestVersion="1.0" xmlns="urn:schemas-microsoft-com:asm.v1">
  <assemblyIdentity
    type="win32"
    name="idasql"
    version="1.0.0.0"
  />
  <application>
    <windowsSettings>
      <activeCodePage xmlns="http://schemas.microsoft.com/SMI/2019/WindowsSettings">UTF-8</activeCodePage>
    </windowsSettings>
  </application>
</assembly>

```

`src/cli/main.cpp`:

```cpp
/**
 * idasql CLI - Command-line SQL interface to IDA databases
 *
 * Usage:
 *   idasql -s database.i64 -q "SELECT * FROM funcs"     # Single query (local)
 *   idasql -s database.i64 -c "SELECT * FROM funcs"     # Same as -q (Python-style)
 *   idasql -s database.i64 -f script.sql                # Execute SQL file
 *   idasql -s database.i64 -i                           # Interactive mode
 *   idasql -s database.i64 --export out.sql             # Export all tables to SQL
 *   idasql -s database.i64 --export out.sql --export-tables=funcs,segments
 *   idasql --remote localhost:13337 -q "SELECT * FROM funcs"  # Remote mode
 *
 * Switches:
 *   -s <file>            IDA database file (.idb/.i64) for local mode
 *   --remote <host:port> Connect to IDASQL plugin server
 *   -q <sql>             Execute single SQL query
 *   -c <sql>             Execute single SQL query (alias for -q)
 *   -f <file>            Execute SQL from file
 *   -i                   Interactive REPL mode
 *   --export <file>      Export tables to SQL file (local only)
 *   --export-tables=...  Tables to export (* for all, or table1,table2,...)
 *   -h                   Show help
 *
 * Architecture Note:
 *   Remote mode (--remote) is a thin client that only uses sockets - no IDA
 *   functions are called. However, ida.dll must still be in PATH because the
 *   executable links against it (delayed loading is not possible due to
 *   data symbol imports like callui).
 */

#include <idasql/platform.hpp>

#include <iostream>
#include <fstream>
#include <sstream>
#include <iomanip>
#include <string>
#include <cstring>
#include <cctype>
#include <vector>
#include <algorithm>
#include <csignal>
#include <atomic>
#include <mutex>
#include <condition_variable>
#include <queue>
#include <thread>
#include <chrono>

// Windows UTF-8 console support
#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#endif

// Socket client for remote mode (shared library, no IDA dependency)
#include <xsql/socket/client.hpp>
#include <xsql/thinclient/server.hpp>
#include "../common/http_server.hpp"

#include <xsql/script.hpp>
#include "../common/idasql_version.hpp"

// AI Agent integration (optional, enabled via IDASQL_WITH_AI_AGENT)
#ifdef IDASQL_HAS_AI_AGENT
#include "../common/ai_agent.hpp"
#include "../common/idasql_commands.hpp"
#include "../common/mcp_server.hpp"

// Global signal handler state
namespace {
    std::atomic<bool> g_quit_requested{false};
    idasql::AIAgent* g_agent = nullptr;
    std::unique_ptr<idasql::IDAMCPServer> g_mcp_server;
    std::unique_ptr<idasql::AIAgent> g_mcp_agent;
    std::unique_ptr<idasql::IDAHTTPServer> g_repl_http_server;
}

extern "C" void signal_handler(int sig) {
    (void)sig;
    g_quit_requested.store(true);
    if (g_agent) {
        g_agent->request_quit();
    }
}
#endif

// ============================================================================
// Table Printing (shared between remote and local modes)
// ============================================================================

static int print_callback(void*, int argc, char** argv, char** colNames) {
    for (int i = 0; i < argc; i++) {
        std::cout << colNames[i] << " = " << (argv[i] ? argv[i] : "NULL");
        if (i < argc - 1) std::cout << " | ";
    }
    std::cout << std::endl;
    return 0;
}

// Table-style output
struct TablePrinter {
    std::vector<std::string> columns;
    std::vector<std::vector<std::string>> rows;
    std::vector<size_t> widths;
    bool first_row = true;

    void add_row(int argc, char** argv, char** colNames) {
        if (first_row) {
            columns.reserve(argc);
            widths.resize(argc, 0);
            for (int i = 0; i < argc; i++) {
                columns.push_back(colNames[i] ? colNames[i] : "");
                widths[i] = (std::max)(widths[i], columns[i].length());
            }
            first_row = false;
        }

        std::vector<std::string> row;
        row.reserve(argc);
        for (int i = 0; i < argc; i++) {
            std::string val = argv[i] ? argv[i] : "NULL";
            row.push_back(val);
            widths[i] = (std::max)(widths[i], val.length());
        }
        rows.push_back(std::move(row));
    }

    void add_row(const std::vector<std::string>& cols,
                 const std::vector<std::string>& values) {
        if (first_row) {
            columns = cols;
            widths.assign(columns.size(), 0);
            for (size_t i = 0; i < columns.size(); i++) {
                widths[i] = (std::max)(widths[i], columns[i].length());
            }
            first_row = false;
        }

        std::vector<std::string> row = values;
        if (row.size() < columns.size()) {
            row.resize(columns.size());
        }
        for (size_t i = 0; i < row.size(); i++) {
            widths[i] = (std::max)(widths[i], row[i].length());
        }
        rows.push_back(std::move(row));
    }

    void print() {
        if (columns.empty()) return;

        // Header separator
        std::string sep = "+";
        for (size_t w : widths) {
            sep += std::string(w + 2, '-') + "+";
        }

        // Header
        std::cout << sep << "\n| ";
        for (size_t i = 0; i < columns.size(); i++) {
            std::cout << std::left;
            std::cout.width(widths[i]);
            std::cout << columns[i] << " | ";
        }
        std::cout << "\n" << sep << "\n";

        // Rows
        for (const auto& row : rows) {
            std::cout << "| ";
            for (size_t i = 0; i < row.size(); i++) {
                std::cout << std::left;
                std::cout.width(widths[i]);
                std::cout << row[i] << " | ";
            }
            std::cout << "\n";
        }
        std::cout << sep << "\n";
        std::cout << rows.size() << " row(s)\n";
    }
};

static TablePrinter* g_printer = nullptr;

static int table_callback(void*, int argc, char** argv, char** colNames) {      
    if (g_printer) {
        g_printer->add_row(argc, argv, colNames);
    }
    return 0;
}

static bool parse_port(const std::string& s, int& port) {
    try {
        size_t idx = 0;
        int v = std::stoi(s, &idx, 10);
        if (idx != s.size()) return false;
        if (v < 1 || v > 65535) return false;
        port = v;
        return true;
    } catch (...) {
        return false;
    }
}

// ============================================================================ 
// Validation Helpers
// ============================================================================ 

static bool is_safe_table_name(const std::string& name) {
    if (name.empty() || name.size() > 128) return false;
    return std::all_of(name.begin(), name.end(), [](unsigned char c) {
        return std::isalnum(c) || c == '_';
    });
}

// ============================================================================ 
// Remote Mode - Pure socket client (NO IDA DEPENDENCIES)
// ============================================================================ 
// This entire section uses only standard C++ and sockets.
// On Windows with delayed loading, ida.dll/idalib.dll are never loaded
// when running in remote mode.

static void print_remote_result(const xsql::socket::RemoteResult& qr) {
    if (qr.rows.empty() && qr.columns.empty()) {
        std::cout << "OK\n";
        return;
    }
    TablePrinter printer;
    for (size_t r = 0; r < qr.rows.size(); r++) {
        std::vector<char*> argv_ptrs(qr.columns.size());
        std::vector<char*> cols_ptrs(qr.columns.size());
        for (size_t c = 0; c < qr.columns.size(); c++) {
            argv_ptrs[c] = const_cast<char*>(qr.rows[r][c].c_str());
            cols_ptrs[c] = const_cast<char*>(qr.columns[c].c_str());
        }
        printer.add_row(static_cast<int>(qr.columns.size()),
                        argv_ptrs.data(), cols_ptrs.data());
    }
    printer.print();
}

static int run_remote_mode(const std::string& host, int port,
                           const std::string& query,
                           const std::string& sql_file,
                           const std::string& auth_token,
                           bool interactive,
                           const std::string& nl_prompt = "",
                           bool verbose_mode = false,
                           const std::string& provider_override = "") {
    std::cerr << "Connecting to " << host << ":" << port << "..." << std::endl;
    xsql::socket::Client remote;
    if (!auth_token.empty()) {
        remote.set_auth_token(auth_token);
    }
    if (!remote.connect(host, port)) {
        std::cerr << "Error: " << remote.error() << std::endl;
        return 1;
    }
    std::cerr << "Connected." << std::endl;

    int result = 0;

#ifdef IDASQL_HAS_AI_AGENT
    if (!nl_prompt.empty()) {
        // Natural language query via remote
        auto executor = [&remote](const std::string& sql) -> std::string {
            auto qr = remote.query(sql);
            if (!qr.success) {
                return "Error: " + qr.error;
            }
            // Format result as string
            std::ostringstream oss;
            if (!qr.columns.empty()) {
                for (size_t i = 0; i < qr.columns.size(); i++) {
                    if (i > 0) oss << " | ";
                    oss << qr.columns[i];
                }
                oss << "\n";
                for (const auto& row : qr.rows) {
                    for (size_t i = 0; i < row.size(); i++) {
                        if (i > 0) oss << " | ";
                        oss << row[i];
                    }
                    oss << "\n";
                }
            }
            return oss.str();
        };

        idasql::AgentSettings settings = idasql::LoadAgentSettings();
        if (!provider_override.empty()) {
            try {
                settings.default_provider = idasql::ParseProviderType(provider_override);
            } catch (...) {}
        }

        idasql::AIAgent agent(executor, settings, verbose_mode);
        g_agent = &agent;
        std::signal(SIGINT, signal_handler);

        agent.start();
        std::string response = agent.query(nl_prompt);
        agent.stop();

        g_agent = nullptr;
        std::signal(SIGINT, SIG_DFL);

        std::cout << response << "\n";
        return 0;
    }
#else
    (void)nl_prompt;
    (void)verbose_mode;
    (void)provider_override;
#endif

    if (!query.empty()) {
        // Single query
        auto qr = remote.query(query);
        if (qr.success) {
            print_remote_result(qr);
        } else {
            std::cerr << "Error: " << qr.error << "\n";
            result = 1;
        }
    } else if (!sql_file.empty()) {
        // File execution (remote)
        std::ifstream file(sql_file);
        if (!file.is_open()) {
            std::cerr << "Cannot open file: " << sql_file << "\n";
            return 1;
        }
        std::stringstream buffer;
        buffer << file.rdbuf();
        std::string content = buffer.str();

        std::vector<std::string> statements;
        std::string parse_error;
        if (!xsql::collect_statements(nullptr, content, statements, parse_error)) {
            std::cerr << "Error parsing SQL file: " << parse_error << "\n";
            return 1;
        }

        for (const auto& stmt : statements) {
            auto qr = remote.query(stmt);
            if (qr.success) {
                print_remote_result(qr);
                std::cout << "\n";
            } else {
                std::cerr << "Error: " << qr.error << "\n";
                std::cerr << "Query: " << stmt << "\n";
                result = 1;
                break;
            }
        }
    } else if (interactive) {
        // Interactive REPL (remote)
        std::string line;
        std::string stmt;
        std::cout << "IDASQL Remote Interactive Mode (" << host << ":" << port << ")\n"
                  << "Type .quit to exit\n\n";

        while (true) {
            std::cout << (stmt.empty() ? "idasql> " : "   ...> ");
            std::cout.flush();
            if (!std::getline(std::cin, line)) break;
            if (line.empty()) continue;

            if (stmt.empty() && line[0] == '.') {
                if (line == ".quit" || line == ".exit") break;
                if (line == ".tables") {
                    auto qr = remote.query("SELECT name FROM sqlite_master WHERE type='table' ORDER BY name;");
                    if (qr.success) {
                        std::cout << "Tables:\n";
                        for (const auto& row : qr.rows) {
                            std::cout << "  " << row[0] << "\n";
                        }
                    }
                    continue;
                }
                if (line == ".help") {
                    std::cout << R"(
Commands:
  .tables             List all tables
  .clear              Clear session
  .quit / .exit       Exit interactive mode
  .help               Show this help

SQL queries end with semicolon (;)
)" << std::endl;
                    continue;
                }
                if (line == ".clear") {
                    std::cout << "Session cleared\n";
                    continue;
                }
                std::cerr << "Unknown command: " << line << "\n";
                continue;
            }

            stmt += line + " ";
            size_t last = line.length() - 1;
            while (last > 0 && (line[last] == ' ' || line[last] == '\t')) last--;
            if (line[last] == ';') {
                auto qr = remote.query(stmt);
                if (qr.success) {
                    print_remote_result(qr);
                } else {
                    std::cerr << "Error: " << qr.error << "\n";
                }
                stmt.clear();
            }
        }
    }

    return result;
}

// ============================================================================
// Local Mode - Uses IDA SDK (delay-loaded on Windows)
// ============================================================================
// From here on, code may call IDA functions. On Windows with /DELAYLOAD,
// ida.dll and idalib.dll are loaded on first use.
//
// Platform-specific include order:
// - Windows: json before IDA (IDA poisons stdlib functions)
// - macOS/Linux: IDA before json
#include <idasql/platform_undef.hpp>

#ifdef _WIN32
#include <xsql/json.hpp>
#include <idasql/database.hpp>
#else
#include <idasql/database.hpp>
#include <xsql/json.hpp>
#endif

// ============================================================================
// REPL - Interactive Mode (Local)
// ============================================================================

static void show_help() {
    std::cout << R"(
Commands:
  .tables             List all tables
  .schema [table]     Show table schema
  .info               Show database info
  .clear              Clear session (reset conversation)
  .quit / .exit       Exit interactive mode
  .help               Show this help

SQL queries end with semicolon (;)
Multi-line queries are supported.
)" << std::endl;
}

static void show_tables(idasql::Database& db) {
    std::cout << "Tables:\n";
    db.exec(
        "SELECT name FROM sqlite_master WHERE type='table' ORDER BY name;",
        [](void*, int, char** argv, char**) -> int {
            std::cout << "  " << (argv[0] ? argv[0] : "") << "\n";
            return 0;
        },
        nullptr
    );
}

static void show_schema(idasql::Database& db, const std::string& table) {
    if (!is_safe_table_name(table)) {
        std::cerr << "Invalid table name\n";
        return;
    }

    std::string sql = "SELECT sql FROM sqlite_master WHERE type='table' AND name='" + table + "';";
    db.exec(sql.c_str(),
        [](void*, int, char** argv, char**) -> int {
            std::cout << (argv[0] ? argv[0] : "Not found") << "\n";
            return 0;
        },
        nullptr
    );
}

// Helper to execute SQL and format results as string (for AI agent)
static std::string execute_sql_to_string(idasql::Database& db, const std::string& sql) {
    std::stringstream ss;
    TablePrinter printer;
    g_printer = &printer;
    int rc = db.exec(sql.c_str(), table_callback, nullptr);
    g_printer = nullptr;

    if (rc == SQLITE_OK) {
        // Capture to string instead of stdout
        std::streambuf* old_cout = std::cout.rdbuf(ss.rdbuf());
        printer.print();
        std::cout.rdbuf(old_cout);
        return ss.str();
    } else {
        return "Error: " + std::string(db.error());
    }
}

// Forward declaration (defined in HTTP section below)
static std::string query_result_to_json(idasql::Database& db, const std::string& sql);

#ifdef IDASQL_HAS_AI_AGENT
static void run_repl(idasql::Database& db, bool agent_mode, bool verbose,
                     const std::string& provider_override = "") {
#else
static void run_repl(idasql::Database& db) {
    [[maybe_unused]] bool agent_mode = false;
#endif
    std::string line;
    std::string query;

#ifdef IDASQL_HAS_AI_AGENT
    std::unique_ptr<idasql::AIAgent> agent;
    if (agent_mode) {
        auto executor = [&db](const std::string& sql) -> std::string {
            return execute_sql_to_string(db, sql);
        };

        // Load settings (includes BYOK, provider, timeout)
        idasql::AgentSettings settings = idasql::LoadAgentSettings();

        // Apply provider override from CLI if specified
        if (!provider_override.empty()) {
            try {
                settings.default_provider = idasql::ParseProviderType(provider_override);
            } catch (...) {
                // Already validated in argument parsing
            }
        }

        agent = std::make_unique<idasql::AIAgent>(executor, settings, verbose);

        // Register signal handler for clean Ctrl-C handling
        g_agent = agent.get();
        std::signal(SIGINT, signal_handler);
#ifdef _WIN32
        // Windows also needs SIGBREAK for Ctrl-Break
        std::signal(SIGBREAK, signal_handler);
#endif

        agent->start();  // Initialize agent

        std::cout << "IDASQL AI Agent Mode\n"
                  << "Ask questions in natural language or use SQL directly.\n"
                  << "Type .help for commands, .clear to reset, .quit to exit\n\n";
    } else {
#endif
        std::cout << "IDASQL Interactive Mode\n"
                  << "Type .help for commands, .clear to reset, .quit to exit\n\n";
#ifdef IDASQL_HAS_AI_AGENT
    }
#endif

    while (true) {
#ifdef IDASQL_HAS_AI_AGENT
        // Check for quit request from signal handler
        if (g_quit_requested.load()) {
            std::cout << "\nInterrupted.\n";
            break;
        }
#endif

        // Prompt
        std::cout << (query.empty() ? "idasql> " : "   ...> ");
        std::cout.flush();

        if (!std::getline(std::cin, line)) break;
        if (line.empty()) continue;

        // Handle dot commands
        if (query.empty() && !line.empty() && line[0] == '.') {
#ifdef IDASQL_HAS_AI_AGENT
            // Use unified command handler for agent mode
            idasql::CommandCallbacks callbacks;
            callbacks.get_tables = [&db]() -> std::string {
                std::stringstream ss;
                auto result = db.query("SELECT name FROM sqlite_master WHERE type='table' ORDER BY name");
                for (const auto& row : result.rows) {
                    if (row.size() > 0) ss << row[0] << "\n";
                }
                return ss.str();
            };
            callbacks.get_schema = [&db](const std::string& table) -> std::string {
                auto result = db.query("SELECT sql FROM sqlite_master WHERE name='" + table + "'");
                if (!result.empty() && result.rows[0].size() > 0) {
                    return std::string(result.rows[0][0]);
                }
                return "Table not found: " + table;
            };
            callbacks.get_info = [&db]() -> std::string {
                return db.info();
            };
            callbacks.clear_session = [&agent]() -> std::string {
                if (agent) {
                    agent->reset_session();
                    return "Session cleared (conversation history reset)";
                }
                return "Session cleared";
            };

            // MCP server callbacks
            callbacks.mcp_status = []() -> std::string {
                if (g_mcp_server && g_mcp_server->is_running()) {
                    return idasql::format_mcp_status(g_mcp_server->port(), true);
                } else {
                    return "MCP server not running\nUse '.mcp start' to start\n";
                }
            };

            callbacks.mcp_start = [&db, &agent](int req_port, const std::string& bind_addr) -> std::string {
                if (g_mcp_server && g_mcp_server->is_running()) {
                    return idasql::format_mcp_status(g_mcp_server->port(), true);
                }

                // Create MCP server if needed
                if (!g_mcp_server) {
                    g_mcp_server = std::make_unique<idasql::IDAMCPServer>();
                }

                // SQL executor - will be called on main thread via wait()
                idasql::QueryCallback sql_cb = [&db](const std::string& sql) -> std::string {
                    auto result = db.query(sql);
                    if (result.success) {
                        return result.to_string();
                    }
                    return "Error: " + result.error;
                };

                // Create MCP agent for natural language queries
                g_mcp_agent = std::make_unique<idasql::AIAgent>(sql_cb);
                g_mcp_agent->start();

                idasql::AskCallback ask_cb = [](const std::string& question) -> std::string {
                    if (!g_mcp_agent) return "Error: AI agent not available";
                    return g_mcp_agent->query(question);
                };

                // Start with use_queue=true for CLI mode (main thread execution)
                int port = g_mcp_server->start(req_port, sql_cb, ask_cb, bind_addr, true);
                if (port <= 0) {
                    g_mcp_agent.reset();
                    return "Error: Failed to start MCP server\n";
                }

                // Print info
                std::cout << idasql::format_mcp_info(port, true);
                std::cout << "Press Ctrl+C to stop MCP server and return to REPL...\n\n";
                std::cout.flush();

                // Install signal handler so Ctrl+C sets g_quit_requested
                g_quit_requested.store(false);
                auto old_handler = std::signal(SIGINT, signal_handler);
#ifdef _WIN32
                auto old_break_handler = std::signal(SIGBREAK, signal_handler);
#endif

                // Set interrupt check to stop on Ctrl+C
                g_mcp_server->set_interrupt_check([]() {
                    return g_quit_requested.load();
                });

                // Enter wait loop - processes MCP commands on main thread
                // This blocks until Ctrl+C or .mcp stop via another client
                g_mcp_server->run_until_stopped();

                // Restore previous signal handler
                std::signal(SIGINT, old_handler);
#ifdef _WIN32
                std::signal(SIGBREAK, old_break_handler);
#endif
                g_mcp_agent.reset();
                g_quit_requested.store(false);  // Reset for continued REPL use

                return "MCP server stopped. Returning to REPL.\n";
            };

            callbacks.mcp_stop = []() -> std::string {
                if (g_mcp_server && g_mcp_server->is_running()) {
                    g_mcp_server->stop();
                    g_mcp_agent.reset();
                    return "MCP server stopped\n";
                }
                return "MCP server not running\n";
            };

            // HTTP server callbacks
            callbacks.http_status = []() -> std::string {
                if (g_repl_http_server && g_repl_http_server->is_running()) {
                    return idasql::format_http_status(g_repl_http_server->port(), true);
                }
                return "HTTP server not running\nUse '.http start' to start\n";
            };

            callbacks.http_start = [&db](int req_port, const std::string& bind_addr) -> std::string {
                if (g_repl_http_server && g_repl_http_server->is_running()) {
                    return idasql::format_http_status(g_repl_http_server->port(), true);
                }

                // Create HTTP server if needed
                if (!g_repl_http_server) {
                    g_repl_http_server = std::make_unique<idasql::IDAHTTPServer>();
                }

                // SQL executor - called on main thread via run_until_stopped()
                idasql::HTTPQueryCallback sql_cb = [&db](const std::string& sql) -> std::string {
                    return query_result_to_json(db, sql);
                };

                // Start with use_queue=true (CLI mode)
                int port = g_repl_http_server->start(req_port, sql_cb, bind_addr, true);
                if (port <= 0) {
                    return "Error: Failed to start HTTP server\n";
                }

                // Print info
                std::cout << idasql::format_http_info(port);
                std::cout.flush();

                // Install signal handler so Ctrl+C sets g_quit_requested
                g_quit_requested.store(false);
                auto old_handler = std::signal(SIGINT, signal_handler);
#ifdef _WIN32
                auto old_break_handler = std::signal(SIGBREAK, signal_handler);
#endif

                // Set interrupt check to stop on Ctrl+C
                g_repl_http_server->set_interrupt_check([]() {
                    return g_quit_requested.load();
                });

                // Enter wait loop - processes HTTP commands on main thread
                // This blocks until Ctrl+C or /shutdown
                g_repl_http_server->run_until_stopped();

                // Restore previous signal handler
                std::signal(SIGINT, old_handler);
#ifdef _WIN32
                std::signal(SIGBREAK, old_break_handler);
#endif
                g_quit_requested.store(false);  // Reset for continued REPL use

                return "HTTP server stopped. Returning to REPL.\n";
            };

            callbacks.http_stop = []() -> std::string {
                if (g_repl_http_server && g_repl_http_server->is_running()) {
                    g_repl_http_server->stop();
                    return "HTTP server stopped\n";
                }
                return "HTTP server not running\n";
            };

            std::string output;
            auto result = idasql::handle_command(line, callbacks, output);

            switch (result) {
                case idasql::CommandResult::QUIT:
                    goto exit_repl;  // Exit the while loop
                case idasql::CommandResult::HANDLED:
                    if (!output.empty()) {
                        std::cout << output;
                        if (output.back() != '\n') std::cout << "\n";
                    }
                    continue;
                case idasql::CommandResult::NOT_HANDLED:
                    // Fall through to standard handling
                    break;
            }
#else
            // Non-agent mode: basic command handling
            if (line == ".quit" || line == ".exit") break;
            if (line == ".tables") { show_tables(db); continue; }
            if (line == ".info") { std::cout << db.info(); continue; }
            if (line == ".help") { show_help(); continue; }
            if (line == ".clear") {
                std::cout << "Session cleared\n";
                continue;
            }
            if (line.substr(0, 7) == ".schema") {
                std::string table = line.length() > 8 ? line.substr(8) : "";
                while (!table.empty() && table[0] == ' ') table = table.substr(1);
                if (table.empty()) {
                    std::cerr << "Usage: .schema <table_name>\n";
                } else {
                    show_schema(db, table);
                }
                continue;
            }
            std::cerr << "Unknown command: " << line << "\n";
            continue;
#endif
        }

#ifdef IDASQL_HAS_AI_AGENT
        // In agent mode, use query for main-thread safety
        if (agent_mode && agent) {
            std::string result = agent->query(line);
            if (!result.empty()) {
                std::cout << result << "\n";
            }

            // Check if we were interrupted
            if (agent->quit_requested()) {
                std::cout << "Interrupted.\n";
                break;
            }
            continue;
        }
#endif

        // Standard SQL mode: accumulate query
        query += line + " ";

        // Execute if complete (ends with ;)
        size_t last = line.length() - 1;
        while (last > 0 && (line[last] == ' ' || line[last] == '\t')) last--;
        if (line[last] == ';') {
            TablePrinter printer;
            g_printer = &printer;
            int rc = db.exec(query.c_str(), table_callback, nullptr);
            g_printer = nullptr;

            if (rc == SQLITE_OK) {
                printer.print();
            } else {
                std::cerr << "Error: " << db.error() << "\n";
            }
            query.clear();
        }
    }

#ifdef IDASQL_HAS_AI_AGENT
exit_repl:
    if (agent) {
        agent->stop();
        g_agent = nullptr;
    }
    // Restore default signal handler
    std::signal(SIGINT, SIG_DFL);
#endif
}

// ============================================================================
// Export to SQL
// ============================================================================

// Parse table list from string (comma or semicolon separated)
static std::vector<std::string> parse_table_list(const std::string& spec) {
    std::vector<std::string> tables;
    std::string current;
    for (char c : spec) {
        if (c == ',' || c == ';') {
            if (!current.empty()) {
                tables.push_back(current);
                current.clear();
            }
        } else if (c != ' ' && c != '\t') {
            current += c;
        }
    }
    if (!current.empty()) {
        tables.push_back(current);
    }
    return tables;
}

// Export tables to SQL file
static bool export_to_sql(idasql::Database& db, const char* path,
                          const std::string& table_spec) {
    std::vector<std::string> tables;
    if (!(table_spec.empty() || table_spec == "*")) {
        tables = parse_table_list(table_spec);
    }

    std::string error;
    if (!xsql::export_tables(db.handle(), tables, path, error)) {
        std::cerr << "Error: " << error << "\n";
        return false;
    }

    std::cerr << "Export complete: " << path << "\n";
    return true;
}

// ============================================================================
// File Execution
// ============================================================================

static bool execute_file(idasql::Database& db, const char* path) {
    std::ifstream file(path);
    if (!file.is_open()) {
        std::cerr << "Cannot open file: " << path << "\n";
        return false;
    }

    std::stringstream buffer;
    buffer << file.rdbuf();
    std::string content = buffer.str();

    std::vector<xsql::StatementResult> results;
    std::string error;
    if (!xsql::execute_script(db.handle(), content, results, error)) {
        std::cerr << "Error: " << error << "\n";
        return false;
    }

    for (const auto& res : results) {
        if (res.columns.empty()) {
            continue;
        }
        TablePrinter printer;
        for (const auto& row : res.rows) {
            printer.add_row(res.columns, row);
        }
        printer.print();
        std::cout << "\n";
    }

    return true;
}

// ============================================================================
// HTTP Server Mode
// ============================================================================

static xsql::thinclient::server* g_http_server = nullptr;
static std::atomic<bool> g_http_stop_requested{false};

static void http_signal_handler(int) {
    g_http_stop_requested.store(true);
    if (g_http_server) g_http_server->stop();
}

// Command queue for main-thread execution (needed for Hex-Rays decompiler)
struct HttpPendingCommand {
    std::string sql;
    std::string result;
    bool completed = false;
    std::mutex* done_mutex = nullptr;
    std::condition_variable* done_cv = nullptr;
};

static std::mutex g_http_queue_mutex;
static std::condition_variable g_http_queue_cv;
static std::queue<HttpPendingCommand*> g_http_pending_commands;
static std::atomic<bool> g_http_running{false};

// Queue a command and wait for main thread to execute it
static std::string http_queue_and_wait(const std::string& sql) {
    if (!g_http_running.load()) {
        return xsql::json{{"success", false}, {"error", "Server not running"}}.dump();
    }

    HttpPendingCommand cmd;
    cmd.sql = sql;
    cmd.completed = false;

    std::mutex done_mutex;
    std::condition_variable done_cv;
    cmd.done_mutex = &done_mutex;
    cmd.done_cv = &done_cv;

    {
        std::lock_guard<std::mutex> lock(g_http_queue_mutex);
        g_http_pending_commands.push(&cmd);
    }
    g_http_queue_cv.notify_one();

    // Wait for completion - cleanup code will signal if server stops
    // Timeout after 60s as safety net against shutdown race conditions
    {
        std::unique_lock<std::mutex> lock(done_mutex);
        int wait_count = 0;
        while (!cmd.completed && wait_count < 600) {  // 60 seconds max
            done_cv.wait_for(lock, std::chrono::milliseconds(100));
            wait_count++;
        }
        if (!cmd.completed) {
            // Timed out - likely shutdown race, remove from queue if still there
            std::lock_guard<std::mutex> qlock(g_http_queue_mutex);
            // Can't easily remove from std::queue, but server is stopping anyway
            return xsql::json{{"success", false}, {"error", "Request timed out"}}.dump();
        }
    }

    return cmd.result;
}

static std::string query_result_to_json(idasql::Database& db, const std::string& sql) {
    auto result = db.query(sql);
    xsql::json j = {{"success", result.success}};

    if (result.success) {
        j["columns"] = result.columns;

        xsql::json rows = xsql::json::array();
        for (const auto& row : result.rows) {
            rows.push_back(row.values);  // Row::values is std::vector<std::string>
        }
        j["rows"] = rows;
        j["row_count"] = result.rows.size();
    } else {
        j["error"] = result.error;
    }

    return j.dump();
}

static const char* IDASQL_HELP_TEXT = R"(IDASQL HTTP REST API
====================

SQL interface for IDA Pro databases via HTTP.

Endpoints:
  GET  /         - Welcome message
  GET  /help     - This documentation (for LLM discovery)
  POST /query    - Execute SQL (body = raw SQL, response = JSON)
  GET  /status   - Server health
  POST /shutdown - Stop server

Tables:
  funcs           - Functions with address, size, flags
  segments        - Segment/section information
  imports         - Imported functions
  exports         - Exported functions
  names           - Named locations
  strings         - String references
  comments        - User comments
  xrefs           - Cross references
  structs         - Structure definitions
  struct_members  - Structure members
  enums           - Enumeration definitions
  enum_members    - Enumeration values
  localvars       - Local variables (requires Hex-Rays)
  pseudocode      - Decompiled pseudocode (requires Hex-Rays)

Example Queries:
  SELECT name, start_ea, size FROM funcs ORDER BY size DESC LIMIT 10;
  SELECT * FROM imports WHERE name LIKE '%malloc%';
  SELECT s.name, COUNT(*) FROM structs s JOIN struct_members m ON s.id = m.struct_id GROUP BY s.id;

Response Format:
  Success: {"success": true, "columns": [...], "rows": [[...]], "row_count": N}
  Error:   {"success": false, "error": "message"}

Authentication (if enabled):
  Header: Authorization: Bearer <token>
  Or:     X-XSQL-Token: <token>

Example:
  curl http://localhost:8081/help
  curl -X POST http://localhost:8081/query -d "SELECT name FROM funcs LIMIT 5"
)";

static int run_http_mode(idasql::Database& db, int port, const std::string& bind_addr, const std::string& auth_token) {
    xsql::thinclient::server_config cfg;
    cfg.port = port;
    cfg.bind_address = bind_addr.empty() ? "127.0.0.1" : bind_addr;
    if (!auth_token.empty()) cfg.auth_token = auth_token;
    // Allow non-loopback binds if explicitly requested (with warning)
    if (!bind_addr.empty() && bind_addr != "127.0.0.1" && bind_addr != "localhost") {
        cfg.allow_insecure_no_auth = auth_token.empty();
        std::cerr << "WARNING: Binding to non-loopback address " << bind_addr << "\n";
        if (auth_token.empty()) {
            std::cerr << "WARNING: No authentication token set. Server is accessible without authentication.\n";
            std::cerr << "         Consider using --token <secret> for remote access.\n";
        }
    }

    cfg.setup_routes = [&auth_token, port](httplib::Server& svr) {
        svr.Get("/", [port](const httplib::Request&, httplib::Response& res) {
            std::string welcome = "IDASQL HTTP Server\n\nEndpoints:\n"
                "  GET  /help     - API documentation\n"
                "  POST /query    - Execute SQL query\n"
                "  GET  /status   - Health check\n"
                "  POST /shutdown - Stop server\n\n"
                "Example: curl -X POST http://localhost:" + std::to_string(port) + "/query -d \"SELECT name FROM funcs LIMIT 5\"\n";
            res.set_content(welcome, "text/plain");
        });

        svr.Get("/help", [](const httplib::Request&, httplib::Response& res) {
            res.set_content(IDASQL_HELP_TEXT, "text/plain");
        });

        // POST /query - Queue command for main thread execution
        // This is necessary because IDA's Hex-Rays decompiler has thread affinity
        svr.Post("/query", [&auth_token](const httplib::Request& req, httplib::Response& res) {
            if (!auth_token.empty()) {
                std::string token;
                if (req.has_header("X-XSQL-Token")) token = req.get_header_value("X-XSQL-Token");
                else if (req.has_header("Authorization")) {
                    auto auth = req.get_header_value("Authorization");
                    if (auth.rfind("Bearer ", 0) == 0) token = auth.substr(7);
                }
                if (token != auth_token) {
                    res.status = 401;
                    res.set_content(xsql::json{{"success", false}, {"error", "Unauthorized"}}.dump(), "application/json");
                    return;
                }
            }
            if (req.body.empty()) {
                res.status = 400;
                res.set_content(xsql::json{{"success", false}, {"error", "Empty query"}}.dump(), "application/json");
                return;
            }
            // Queue command for main thread execution
            res.set_content(http_queue_and_wait(req.body), "application/json");
        });

        // GET /status - Also needs main thread for db.query()
        svr.Get("/status", [&auth_token](const httplib::Request& req, httplib::Response& res) {
            if (!auth_token.empty()) {
                std::string token;
                if (req.has_header("X-XSQL-Token")) token = req.get_header_value("X-XSQL-Token");
                else if (req.has_header("Authorization")) {
                    auto auth = req.get_header_value("Authorization");
                    if (auth.rfind("Bearer ", 0) == 0) token = auth.substr(7);
                }
                if (token != auth_token) {
                    res.status = 401;
                    res.set_content(xsql::json{{"success", false}, {"error", "Unauthorized"}}.dump(), "application/json");
                    return;
                }
            }
            // Queue for main thread
            std::string result = http_queue_and_wait("SELECT COUNT(*) FROM funcs");
            // Parse result to extract count
            try {
                auto j = xsql::json::parse(result);
                if (j.value("success", false) && j.contains("rows") && !j["rows"].empty()) {
                    int count = std::stoi(j["rows"][0][0].get<std::string>());
                    res.set_content(xsql::json{{"success", true}, {"status", "ok"}, {"tool", "idasql"}, {"functions", count}}.dump(), "application/json");
                    return;
                }
            } catch (...) {}
            res.set_content(xsql::json{{"success", true}, {"status", "ok"}, {"tool", "idasql"}, {"functions", "?"}}.dump(), "application/json");
        });

        svr.Post("/shutdown", [&svr, &auth_token](const httplib::Request& req, httplib::Response& res) {
            if (!auth_token.empty()) {
                std::string token;
                if (req.has_header("X-XSQL-Token")) token = req.get_header_value("X-XSQL-Token");
                else if (req.has_header("Authorization")) {
                    auto auth = req.get_header_value("Authorization");
                    if (auth.rfind("Bearer ", 0) == 0) token = auth.substr(7);
                }
                if (token != auth_token) {
                    res.status = 401;
                    res.set_content(xsql::json{{"success", false}, {"error", "Unauthorized"}}.dump(), "application/json");
                    return;
                }
            }
            res.set_content(xsql::json{{"success", true}, {"message", "Shutting down"}}.dump(), "application/json");
            g_http_stop_requested.store(true);
            g_http_queue_cv.notify_all();
            std::thread([&svr] {
                std::this_thread::sleep_for(std::chrono::milliseconds(100));
                svr.stop();
            }).detach();
        });
    };

    xsql::thinclient::server http_server(cfg);
    g_http_server = &http_server;
    g_http_running.store(true);
    g_http_stop_requested.store(false);

    auto old_handler = std::signal(SIGINT, http_signal_handler);
#ifdef _WIN32
    auto old_break_handler = std::signal(SIGBREAK, http_signal_handler);
#else
    auto old_term_handler = std::signal(SIGTERM, http_signal_handler);
#endif

    // Start HTTP server on a background thread (resolves random port)
    http_server.run_async();
    int actual_port = http_server.port();

    std::cout << "IDASQL HTTP server listening on http://" << cfg.bind_address << ":" << actual_port << "\n";
    std::cout << "Database: " << db.info() << "\n";
    std::cout << "Endpoints: /help, /query, /status, /shutdown\n";
    std::cout << "Example: curl http://localhost:" << actual_port << "/help\n";
    std::cout << "Press Ctrl+C to stop.\n\n";
    std::cout.flush();

    // Main thread processes the command queue (required for Hex-Rays thread affinity)
    while (g_http_running.load() && !g_http_stop_requested.load()) {
        HttpPendingCommand* cmd = nullptr;

        {
            std::unique_lock<std::mutex> lock(g_http_queue_mutex);
            if (g_http_queue_cv.wait_for(lock, std::chrono::milliseconds(100),
                                          []() { return !g_http_pending_commands.empty() ||
                                                        g_http_stop_requested.load(); })) {
                if (!g_http_pending_commands.empty()) {
                    cmd = g_http_pending_commands.front();
                    g_http_pending_commands.pop();
                }
            }
        }

        if (cmd) {
            // Execute query on main thread - safe for Hex-Rays decompiler
            cmd->result = query_result_to_json(db, cmd->sql);
            if (cmd->done_mutex && cmd->done_cv) {
                {
                    std::lock_guard<std::mutex> lock(*cmd->done_mutex);
                    cmd->completed = true;
                }
                cmd->done_cv->notify_one();
            }
        }
    }

    // Cleanup
    g_http_running.store(false);
    g_http_queue_cv.notify_all();

    // Complete any pending commands with error
    {
        std::lock_guard<std::mutex> lock(g_http_queue_mutex);
        while (!g_http_pending_commands.empty()) {
            HttpPendingCommand* cmd = g_http_pending_commands.front();
            g_http_pending_commands.pop();
            if (!cmd || !cmd->done_mutex || !cmd->done_cv) continue;
            cmd->result = xsql::json{{"success", false}, {"error", "Server stopped"}}.dump();
            {
                std::lock_guard<std::mutex> dlock(*cmd->done_mutex);
                cmd->completed = true;
            }
            cmd->done_cv->notify_one();
        }
    }

    // Stop HTTP server (run_async thread joined internally)
    http_server.stop();

    std::signal(SIGINT, old_handler);
#ifdef _WIN32
    std::signal(SIGBREAK, old_break_handler);
#else
    std::signal(SIGTERM, old_term_handler);
#endif
    g_http_server = nullptr;
    std::cout << "\nHTTP server stopped.\n";
    return 0;
}

// ============================================================================
// Main
// ============================================================================

static void print_usage() {
    std::cerr << "idasql v" IDASQL_VERSION_STRING " - SQL interface to IDA databases\n\n"
              << "Usage: idasql -s <database> [-q|-c <query>] [-f <file>] [-i] [--export <file>]\n"
              << "       idasql --remote <host:port> [-q|-c <query>] [-f <file>] [-i]\n\n"
              << "Options:\n"
              << "  -s <file>            IDA database file (.idb/.i64) for local mode\n"
              << "  --remote <host:port> Connect to IDASQL plugin server (e.g., localhost:13337)\n"
              << "  --token <token>      Auth token for remote mode (if server requires it)\n"
              << "  -q <sql>             Execute single SQL query\n"
              << "  -c <sql>             Execute single SQL query (alias for -q)\n"
              << "  -f <file>            Execute SQL from file\n"
              << "  -i                   Interactive REPL mode\n"
              << "  -w, --write          Save database on exit (persist changes)\n"
              << "  --export <file>      Export tables to SQL file (local mode only)\n"
              << "  --export-tables=X    Tables to export: * (all, default) or table1,table2,...\n"
              << "  --http [port]        Start HTTP REST server (default: 8080, local mode only)\n"
              << "  --bind <addr>        Bind address for HTTP/MCP server (default: 127.0.0.1)\n"
#ifdef IDASQL_HAS_AI_AGENT
              << "  --mcp [port]         Start MCP server (default: random port, use in -i mode)\n"
              << "                       Or use .mcp start in interactive mode\n"
#endif
#ifdef IDASQL_HAS_AI_AGENT
              << "  --prompt <text>      Natural language query (uses AI agent)\n"
              << "  --agent              Enable AI agent mode in interactive REPL\n"
              << "  --provider <name>    Override AI provider (claude, copilot)\n"
              << "  --config [path] [val] View/set agent configuration\n"
              << "  -v, --verbose        Show agent debug logs\n"
              << "\n"
              << "Agent settings stored in: ~/.idasql/agent_settings.json\n"
              << "Configure via: .agent provider, .agent byok, .agent timeout\n"
#endif
              << "  -h, --help           Show this help\n"
              << "  --version            Show version\n\n"
              << "Examples:\n"
              << "  idasql -s test.i64 -q \"SELECT name, size FROM funcs LIMIT 10\"\n"
              << "  idasql -s test.i64 -f queries.sql\n"
              << "  idasql -s test.i64 -i\n"
              << "  idasql -s test.i64 --export dump.sql\n"
              << "  idasql --remote localhost:13337 -q \"SELECT * FROM funcs LIMIT 5\"\n"
#ifdef IDASQL_HAS_AI_AGENT
              << "  idasql -s test.i64 --prompt \"Find the largest functions\"\n"
              << "  idasql -s test.i64 -i --agent\n"
              << "  idasql -s test.i64 --provider copilot --prompt \"How many functions?\"\n"
#endif
              << "  idasql --remote localhost:13337 -i\n";
}

int main(int argc, char* argv[]) {
#ifdef _WIN32
    // Enable UTF-8 output on Windows console for proper Unicode display
    SetConsoleOutputCP(CP_UTF8);
#endif

    // Check for help/version first - before any IDA initialization
    for (int i = 1; i < argc; i++) {
        if (strcmp(argv[i], "-h") == 0 || strcmp(argv[i], "--help") == 0) {
            print_usage();
            return 0;
        }
        if (strcmp(argv[i], "--version") == 0) {
            std::cout << "idasql v" IDASQL_VERSION_STRING "\n";
            return 0;
        }
    }

    std::string db_path;
    std::string query;
    std::string sql_file;
    std::string export_file;
    std::string export_tables = "*";  // Default: all tables
    std::string remote_spec;          // host:port for remote mode
    std::string auth_token;           // --token for remote mode
    std::string bind_addr;            // --bind for HTTP/MCP mode
    bool interactive = false;
    bool write_mode = false;          // -w/--write to save on exit
    bool http_mode = false;
    int http_port = 8080;
    bool mcp_mode = false;
    int mcp_port = 0;                 // 0 = random port
#ifdef IDASQL_HAS_AI_AGENT
    std::string nl_prompt;            // --prompt for natural language
    bool agent_mode = false;          // --agent for interactive mode
    bool verbose_mode = false;        // -v for verbose agent output
    std::string provider_override;    // --provider overrides stored setting
#endif

    // Parse arguments
    for (int i = 1; i < argc; i++) {
        if ((strcmp(argv[i], "-s") == 0) && i + 1 < argc) {
            db_path = argv[++i];
        } else if (strcmp(argv[i], "--remote") == 0 && i + 1 < argc) {
            remote_spec = argv[++i];
        } else if (strcmp(argv[i], "--token") == 0 && i + 1 < argc) {
            auth_token = argv[++i];
        } else if ((strcmp(argv[i], "-q") == 0 || strcmp(argv[i], "-c") == 0) && i + 1 < argc) {
            query = argv[++i];
        } else if ((strcmp(argv[i], "-f") == 0) && i + 1 < argc) {
            sql_file = argv[++i];
        } else if (strcmp(argv[i], "-i") == 0) {
            interactive = true;
        } else if (strcmp(argv[i], "-w") == 0 || strcmp(argv[i], "--write") == 0) {
            write_mode = true;
        } else if (strcmp(argv[i], "--export") == 0 && i + 1 < argc) {
            export_file = argv[++i];
        } else if (strncmp(argv[i], "--export-tables=", 16) == 0) {
            export_tables = argv[i] + 16;
#ifdef IDASQL_HAS_AI_AGENT
        } else if (strcmp(argv[i], "--prompt") == 0 && i + 1 < argc) {
            nl_prompt = argv[++i];
        } else if (strcmp(argv[i], "--agent") == 0) {
            agent_mode = true;
        } else if (strcmp(argv[i], "-v") == 0 || strcmp(argv[i], "--verbose") == 0) {
            verbose_mode = true;
        } else if (strcmp(argv[i], "--provider") == 0 && i + 1 < argc) {
            provider_override = argv[++i];
            // Validate provider name
            if (provider_override != "copilot" && provider_override != "Copilot" &&
                provider_override != "claude" && provider_override != "Claude") {
                std::cerr << "Unknown provider: " << provider_override << "\n";
                std::cerr << "Available providers: claude, copilot\n";
                return 1;
            }
        } else if (strcmp(argv[i], "--config") == 0) {
            // Handle --config [path] [value] and exit immediately
            std::string config_path = (i + 1 < argc && argv[i + 1][0] != '-') ? argv[++i] : "";
            std::string config_value = (i + 1 < argc && argv[i + 1][0] != '-') ? argv[++i] : "";
            auto [ok, output, code] = idasql::handle_config_command(config_path, config_value);
            std::cout << output;
            return code;
#endif
        } else if (strcmp(argv[i], "--http") == 0) {
            http_mode = true;
            if (i + 1 < argc && argv[i + 1][0] != '-') {
                http_port = std::stoi(argv[++i]);
            }
        } else if (strcmp(argv[i], "--mcp") == 0) {
            mcp_mode = true;
            if (i + 1 < argc && argv[i + 1][0] != '-') {
                mcp_port = std::stoi(argv[++i]);
            }
        } else if (strcmp(argv[i], "--bind") == 0 && i + 1 < argc) {
            bind_addr = argv[++i];
        } else if (strcmp(argv[i], "-h") == 0 || strcmp(argv[i], "--help") == 0) {
            // Already handled above, but skip here to avoid "unknown option"
            continue;
        } else {
            std::cerr << "Unknown option: " << argv[i] << "\n";
            print_usage();
            return 1;
        }
    }

    // Validate arguments
    bool remote_mode = !remote_spec.empty();

    if (!remote_mode && db_path.empty()) {
        std::cerr << "Error: Database path required (-s) or use --remote\n\n";
        print_usage();
        return 1;
    }

    if (remote_mode && !db_path.empty()) {
        std::cerr << "Error: Cannot use both -s and --remote\n\n";
        print_usage();
        return 1;
    }

    bool has_action = !query.empty() || !sql_file.empty() || interactive || !export_file.empty() || http_mode || mcp_mode;
#ifdef IDASQL_HAS_AI_AGENT
    has_action = has_action || !nl_prompt.empty();
#endif
    if (!has_action) {
        std::cerr << "Error: Specify -q, -c, -f, -i, --export, --http, --mcp"
#ifdef IDASQL_HAS_AI_AGENT
                  << ", or --prompt"
#endif
                  << "\n\n";
        print_usage();
        return 1;
    }

    if (remote_mode && !export_file.empty()) {
        std::cerr << "Error: --export not supported in remote mode\n\n";
        print_usage();
        return 1;
    }

    if (remote_mode && http_mode) {
        std::cerr << "Error: Cannot use both --remote and --http\n\n";
        print_usage();
        return 1;
    }

    //=========================================================================
    // Remote mode - thin client, no IDA kernel loaded
    //=========================================================================
    // IMPORTANT: This path never calls any IDA functions.
    // On Windows with delayed loading, ida.dll/idalib.dll stay unloaded.
    if (remote_mode) {
        // Parse host:port
        std::string host = "127.0.0.1";
        int port = 13337;
        auto colon = remote_spec.find(':');
        if (colon != std::string::npos) {
            host = remote_spec.substr(0, colon);
            std::string port_str = remote_spec.substr(colon + 1);
            if (!parse_port(port_str, port)) {
                std::cerr << "Error: Invalid port in --remote: " << port_str << "\n";
                return 1;
            }
        } else {
            host = remote_spec;
        }
#ifdef IDASQL_HAS_AI_AGENT
        return run_remote_mode(host, port, query, sql_file, auth_token, interactive,
                               nl_prompt, verbose_mode, provider_override);
#else
        return run_remote_mode(host, port, query, sql_file, auth_token, interactive);
#endif
    }

    //=========================================================================
    // Local mode - requires IDA SDK
    //=========================================================================
    std::cerr << "Opening: " << db_path << "..." << std::endl;
    idasql::Database db;
    if (!db.open(db_path.c_str())) {
        std::cerr << "Error: " << db.error() << std::endl;
        return 1;
    }
    std::cerr << "Database opened successfully." << std::endl;

    // HTTP server mode
    if (http_mode) {
        int http_result = run_http_mode(db, http_port, bind_addr, auth_token);
        db.close();
        return http_result;
    }

    // MCP server mode (standalone, not interactive REPL)
#ifdef IDASQL_HAS_AI_AGENT
    if (mcp_mode) {
        // SQL executor - will be called on main thread via wait()
        idasql::QueryCallback sql_cb = [&db](const std::string& sql) -> std::string {
            auto result = db.query(sql);
            if (result.success) {
                return result.to_string();
            }
            return "Error: " + result.error;
        };

        // Create MCP agent for natural language queries
        auto mcp_agent = std::make_unique<idasql::AIAgent>(sql_cb);
        mcp_agent->start();

        idasql::AskCallback ask_cb = [&mcp_agent](const std::string& question) -> std::string {
            if (!mcp_agent) return "Error: AI agent not available";
            return mcp_agent->query(question);
        };

        // Create and start MCP server with use_queue=true
        idasql::IDAMCPServer mcp_server;
        int port = mcp_server.start(mcp_port, sql_cb, ask_cb,
                                    bind_addr.empty() ? "127.0.0.1" : bind_addr, true);
        if (port <= 0) {
            std::cerr << "Error: Failed to start MCP server\n";
            db.close();
            return 1;
        }

        std::cout << idasql::format_mcp_info(port, true);
        std::cout << "Press Ctrl+C to stop...\n\n";
        std::cout.flush();

        // Set up signal handler
        g_quit_requested.store(false);
        std::signal(SIGINT, signal_handler);
#ifdef _WIN32
        std::signal(SIGBREAK, signal_handler);
#endif

        // Set interrupt check
        mcp_server.set_interrupt_check([]() {
            return g_quit_requested.load();
        });

        // Enter wait loop - processes MCP commands on main thread
        mcp_server.run_until_stopped();

        std::signal(SIGINT, SIG_DFL);
        mcp_agent->stop();
        std::cout << "\nMCP server stopped.\n";
        db.close();
        return 0;
    }
#else
    if (mcp_mode) {
        std::cerr << "Error: MCP mode not available. Rebuild with -DIDASQL_WITH_AI_AGENT=ON\n";
        db.close();
        return 1;
    }
#endif

    int result = 0;

    // Execute based on mode
    if (!export_file.empty()) {
        // Export mode
        if (!export_to_sql(db, export_file.c_str(), export_tables)) {
            result = 1;
        }
#ifdef IDASQL_HAS_AI_AGENT
    } else if (!nl_prompt.empty()) {
        // Natural language query mode (one-shot)
        auto executor = [&db](const std::string& sql) -> std::string {
            return execute_sql_to_string(db, sql);
        };

        // Load settings (includes BYOK, provider, timeout)
        idasql::AgentSettings settings = idasql::LoadAgentSettings();

        // Apply provider override from CLI if specified
        if (!provider_override.empty()) {
            try {
                settings.default_provider = idasql::ParseProviderType(provider_override);
            } catch (...) {
                // Already validated in argument parsing
            }
        }

        idasql::AIAgent agent(executor, settings, verbose_mode);

        // Register signal handler
        g_agent = &agent;
        std::signal(SIGINT, signal_handler);

        agent.start();
        std::string response = agent.query(nl_prompt);
        agent.stop();

        g_agent = nullptr;
        std::signal(SIGINT, SIG_DFL);

        std::cout << response << "\n";
#endif
    } else if (!query.empty()) {
        // Single query mode
        TablePrinter printer;
        g_printer = &printer;
        int rc = db.exec(query.c_str(), table_callback, nullptr);
        g_printer = nullptr;

        if (rc == SQLITE_OK) {
            printer.print();
        } else {
            std::cerr << "Error: " << db.error() << "\n";
            result = 1;
        }
    } else if (!sql_file.empty()) {
        // File execution mode
        if (!execute_file(db, sql_file.c_str())) {
            result = 1;
        }
    } else if (interactive) {
        // Interactive REPL
#ifdef IDASQL_HAS_AI_AGENT
        run_repl(db, agent_mode, verbose_mode, provider_override);
#else
        run_repl(db);
#endif
    }

    // Save database if -w/--write was specified
    if (write_mode) {
        if (save_database()) {
            std::cerr << "Database saved.\n";
        } else {
            std::cerr << "Warning: Failed to save database.\n";
        }
    }

    db.close();
    return result;
}

```

`src/common/agent_settings.hpp`:

```hpp
#pragma once

#ifdef IDASQL_HAS_AI_AGENT

#include <libagents/config.hpp>
#include <libagents/provider.hpp>
#include <nlohmann/json.hpp>

#include <string>
#include <unordered_map>
#include <fstream>
#include <cstdlib>

#ifdef _WIN32
#include <shlobj.h>
#include <windows.h>
#else
#include <pwd.h>
#include <unistd.h>
#include <sys/stat.h>
#endif

namespace idasql {

// BYOK (Bring Your Own Key) settings for a single provider
struct BYOKSettings {
    bool enabled = false;
    std::string api_key;
    std::string base_url;
    std::string model;
    std::string provider_type;  // "openai", "anthropic", "azure"
    int timeout_ms = 0;

    // Convert to libagents BYOKConfig
    libagents::BYOKConfig to_config() const {
        libagents::BYOKConfig config;
        config.api_key = api_key;
        config.base_url = base_url;
        config.model = model;
        config.provider_type = provider_type;
        config.timeout_ms = timeout_ms;
        return config;
    }

    // Check if BYOK is usable (enabled and has API key)
    bool is_usable() const { return enabled && !api_key.empty(); }
};

// Agent settings stored in ~/.idasql/agent_settings.json
struct AgentSettings {
    // Default provider (claude, copilot)
    libagents::ProviderType default_provider = libagents::ProviderType::Claude;

    // User's custom prompt (additive to system prompt)
    std::string custom_prompt;

    // Response timeout in milliseconds (0 = use default)
    int response_timeout_ms = 120000;  // 2 minutes default

    // BYOK configuration per provider
    // Key: provider name ("copilot", "claude")
    std::unordered_map<std::string, BYOKSettings> byok;

    // Get BYOK settings for the current provider
    const BYOKSettings* get_byok() const {
        std::string provider_name = libagents::provider_type_name(default_provider);
        auto it = byok.find(provider_name);
        if (it != byok.end())
            return &it->second;
        return nullptr;
    }

    // Get or create BYOK settings for the current provider
    BYOKSettings& get_or_create_byok() {
        std::string provider_name = libagents::provider_type_name(default_provider);
        return byok[provider_name];
    }
};

// Get the settings directory path (~/.idasql or %APPDATA%\idasql)
inline std::string GetSettingsDir() {
#ifdef _WIN32
    char path[MAX_PATH];
    if (SUCCEEDED(SHGetFolderPathA(nullptr, CSIDL_APPDATA, nullptr, 0, path))) {
        return std::string(path) + "\\idasql";
    }
    // Fallback to USERPROFILE
    const char* userprofile = std::getenv("USERPROFILE");
    if (userprofile) {
        return std::string(userprofile) + "\\.idasql";
    }
    return ".idasql";
#else
    const char* home = std::getenv("HOME");
    if (!home) {
        struct passwd* pw = getpwuid(getuid());
        if (pw) home = pw->pw_dir;
    }
    if (home) {
        return std::string(home) + "/.idasql";
    }
    return ".idasql";
#endif
}

// Get the settings file path
inline std::string GetSettingsPath() {
    return GetSettingsDir() +
#ifdef _WIN32
        "\\agent_settings.json";
#else
        "/agent_settings.json";
#endif
}

// Ensure directory exists
inline bool EnsureDir(const std::string& path) {
#ifdef _WIN32
    return CreateDirectoryA(path.c_str(), nullptr) || GetLastError() == ERROR_ALREADY_EXISTS;
#else
    return mkdir(path.c_str(), 0755) == 0 || errno == EEXIST;
#endif
}

// JSON serialization
inline void to_json(nlohmann::json& j, const BYOKSettings& s) {
    j = nlohmann::json{
        {"enabled", s.enabled},
        {"api_key", s.api_key},
        {"base_url", s.base_url},
        {"model", s.model},
        {"provider_type", s.provider_type},
        {"timeout_ms", s.timeout_ms}
    };
}

inline void from_json(const nlohmann::json& j, BYOKSettings& s) {
    s.enabled = j.value("enabled", false);
    s.api_key = j.value("api_key", "");
    s.base_url = j.value("base_url", "");
    s.model = j.value("model", "");
    s.provider_type = j.value("provider_type", "");
    s.timeout_ms = j.value("timeout_ms", 0);
}

inline void to_json(nlohmann::json& j, const AgentSettings& s) {
    j = nlohmann::json{
        {"default_provider", libagents::provider_type_name(s.default_provider)},
        {"custom_prompt", s.custom_prompt},
        {"response_timeout_ms", s.response_timeout_ms},
        {"byok", s.byok}
    };
}

inline void from_json(const nlohmann::json& j, AgentSettings& s) {
    std::string provider_str = j.value("default_provider", "claude");
    if (provider_str == "copilot") {
        s.default_provider = libagents::ProviderType::Copilot;
    } else {
        s.default_provider = libagents::ProviderType::Claude;
    }
    s.custom_prompt = j.value("custom_prompt", "");
    s.response_timeout_ms = j.value("response_timeout_ms", 120000);
    if (j.contains("byok") && j["byok"].is_object()) {
        s.byok = j["byok"].get<std::unordered_map<std::string, BYOKSettings>>();
    }
}

// Load settings from disk (creates default if not exists)
inline AgentSettings LoadAgentSettings() {
    AgentSettings settings;
    std::string path = GetSettingsPath();

    std::ifstream f(path);
    if (f.is_open()) {
        try {
            nlohmann::json j = nlohmann::json::parse(f);
            settings = j.get<AgentSettings>();
        } catch (...) {
            // Ignore parse errors, use defaults
        }
    }
    return settings;
}

// Save settings to disk
inline bool SaveAgentSettings(const AgentSettings& settings) {
    std::string dir = GetSettingsDir();
    if (!EnsureDir(dir)) {
        return false;
    }

    std::string path = GetSettingsPath();
    std::ofstream f(path);
    if (!f.is_open()) {
        return false;
    }

    try {
        nlohmann::json j = settings;
        f << j.dump(2);
        return true;
    } catch (...) {
        return false;
    }
}

// Parse provider type from string
inline libagents::ProviderType ParseProviderType(const std::string& name) {
    if (name == "copilot" || name == "Copilot" || name == "COPILOT") {
        return libagents::ProviderType::Copilot;
    }
    if (name == "claude" || name == "Claude" || name == "CLAUDE") {
        return libagents::ProviderType::Claude;
    }
    throw std::runtime_error("Unknown provider: " + name + " (use 'claude' or 'copilot')");
}

} // namespace idasql

#endif // IDASQL_HAS_AI_AGENT

```

`src/common/ai_agent.cpp`:

```cpp
#include "ai_agent.hpp"

#ifdef IDASQL_HAS_AI_AGENT

// Embedded documentation from prompts/idasql_agent.md
#include "idasql_agent_prompt.hpp"

#include <algorithm>
#include <cctype>
#include <chrono>
#include <cstdlib>
#include <iostream>

namespace idasql {

// ============================================================================
// Construction / Destruction
// ============================================================================

AIAgent::AIAgent(SqlExecutor executor, const AgentSettings& settings, bool verbose)
    : executor_(std::move(executor)), verbose_(verbose),
      provider_type_(settings.default_provider),
      response_timeout_ms_(settings.response_timeout_ms)
{
    // Create agent with provider from settings
    agent_ = libagents::create_agent(provider_type_);

    if (verbose_) {
        std::cerr << "[AGENT] Created " << libagents::provider_type_name(provider_type_)
                  << " provider" << std::endl;
    }

    // Apply BYOK from settings if configured
    const BYOKSettings* byok = settings.get_byok();
    if (byok && byok->is_usable()) {
        set_byok(byok->to_config());
        if (verbose_) {
            std::cerr << "[AGENT] Loaded BYOK from settings" << std::endl;
        }
    } else {
        // Fall back to environment variables
        load_byok_from_env();
    }
}

AIAgent::AIAgent(SqlExecutor executor, bool verbose)
    : AIAgent(std::move(executor), LoadAgentSettings(), verbose)
{
    // Delegates to settings-based constructor
}

void AIAgent::set_byok(const libagents::BYOKConfig& config) {
    byok_config_ = config;
    byok_configured_ = config.is_configured();
    if (verbose_ && byok_configured_) {
        std::cerr << "[AGENT] BYOK configured";
        if (!config.model.empty()) std::cerr << " (model: " << config.model << ")";
        if (!config.base_url.empty()) std::cerr << " (endpoint: " << config.base_url << ")";
        std::cerr << std::endl;
    }
}

bool AIAgent::load_byok_from_env() {
    libagents::BYOKConfig config;

    // Load from COPILOT_SDK_BYOK_* environment variables
    if (const char* key = std::getenv("COPILOT_SDK_BYOK_API_KEY"))
        config.api_key = key;
    if (const char* url = std::getenv("COPILOT_SDK_BYOK_BASE_URL"))
        config.base_url = url;
    if (const char* model = std::getenv("COPILOT_SDK_BYOK_MODEL"))
        config.model = model;
    if (const char* type = std::getenv("COPILOT_SDK_BYOK_PROVIDER_TYPE"))
        config.provider_type = type;

    if (config.is_configured()) {
        if (verbose_) {
            std::cerr << "[AGENT] Loaded BYOK from environment:" << std::endl;
            std::cerr << "[AGENT]   Model: " << (config.model.empty() ? "(default)" : config.model) << std::endl;
            std::cerr << "[AGENT]   Endpoint: " << (config.base_url.empty() ? "(default)" : config.base_url) << std::endl;
            std::cerr << "[AGENT]   Type: " << (config.provider_type.empty() ? "(default)" : config.provider_type) << std::endl;
        }
        set_byok(config);
        return true;
    }
    return false;
}

AIAgent::~AIAgent() {
    stop();
}

// ============================================================================
// Lifecycle
// ============================================================================

void AIAgent::start() {
    if (!agent_) return;

    setup_tools();

    // Apply BYOK configuration before initialize() - required for Copilot provider
    if (byok_configured_) {
        agent_->set_byok(byok_config_);
        if (verbose_) {
            std::cerr << "[AGENT] Applied BYOK configuration" << std::endl;
        }
    }

    // Apply response timeout if configured
    if (response_timeout_ms_ > 0) {
        agent_->set_response_timeout(std::chrono::milliseconds(response_timeout_ms_));
        if (verbose_) {
            std::cerr << "[AGENT] Response timeout: " << response_timeout_ms_ << " ms" << std::endl;
        }
    }

    // Note: We don't use set_system_prompt() because it can break MCP tool
    // visibility with some providers. Instead, we embed the prompt in the
    // first message (priming).

    if (!agent_->initialize()) {
        if (verbose_) {
            std::cerr << "[AGENT] Failed to initialize agent" << std::endl;
        }
        return;
    }

    if (verbose_) {
        std::cerr << "[AGENT] Agent initialized (" << agent_->provider_name() << ")" << std::endl;
    }
}

void AIAgent::stop() {
    if (agent_ && agent_->is_initialized()) {
        agent_->shutdown();
        if (verbose_) {
            std::cerr << "[AGENT] Agent shutdown" << std::endl;
        }
    }
}

void AIAgent::reset_session() {
    if (verbose_) {
        std::cerr << "[AGENT] Resetting session..." << std::endl;
    }

    docs_primed_ = false;
    quit_requested_.store(false);

    if (agent_) {
        agent_->clear_session();
    }

    if (verbose_) {
        std::cerr << "[AGENT] Session reset complete" << std::endl;
    }
}

void AIAgent::request_quit() {
    quit_requested_.store(true);
    if (agent_) {
        agent_->abort();
    }
}

// ============================================================================
// Tool Registration
// ============================================================================

void AIAgent::setup_tools() {
    libagents::Tool idasql_tool;
    idasql_tool.name = "idasql";
    idasql_tool.description =
        "Execute a SQL query against an IDA Pro database. "
        "Available tables: funcs, strings, imports, segments, names, xrefs, instructions, "
        "blocks, comments, types, entries, heads, fchunks, bookmarks, pseudocode, ctree, "
        "ctree_lvars, ctree_call_args. "
        "Example: SELECT name, size FROM funcs WHERE name LIKE 'sub_%' ORDER BY size DESC LIMIT 10";

    idasql_tool.parameters_schema = R"({
        "type": "object",
        "properties": {
            "query": {
                "type": "string",
                "description": "SQL query to execute against the IDA database"
            }
        },
        "required": ["query"]
    })";

    // Tool handler - executes on caller thread via query_hosted()
    idasql_tool.handler = [this](const std::string& args) -> std::string {
        try {
            auto j = libagents::json::parse(args);
            std::string sql = j.value("query", "");

            if (verbose_) {
                std::cerr << "[TOOL] Executing SQL: " << sql.substr(0, 80)
                          << (sql.size() > 80 ? "..." : "") << std::endl;
            }

            // This runs on the main thread (query_hosted guarantees this)
            std::string result = executor_(sql);

            if (verbose_) {
                std::cerr << "[TOOL] Result: " << result.size() << " bytes" << std::endl;
            }

            return result;

        } catch (const std::exception& e) {
            return std::string("Error: ") + e.what();
        }
    };

    agent_->register_tool(idasql_tool);

    if (verbose_) {
        std::cerr << "[AGENT] Registered idasql tool" << std::endl;
    }
}

// ============================================================================
// Query Interface
// ============================================================================

std::string AIAgent::query(const std::string& prompt) {
    // SQL passthrough - execute directly
    if (looks_like_sql(prompt)) {
        return executor_(prompt);
    }

    if (!agent_ || !agent_->is_initialized()) {
        return "Error: Agent not initialized";
    }

    // Build message (prime with docs if first message)
    std::string message = docs_primed_ ? prompt : build_primed_message(prompt);
    docs_primed_ = true;

    // Use query_hosted for main-thread tool dispatch
    libagents::HostContext host;
    host.should_abort = [this]() { return quit_requested_.load(); };

    try {
        return agent_->query_hosted(message, host);
    } catch (const std::exception& e) {
        return std::string("Error: ") + e.what();
    }
}

std::string AIAgent::query_streaming(const std::string& prompt, ContentCallback on_content) {
    // SQL passthrough
    if (looks_like_sql(prompt)) {
        std::string result = executor_(prompt);
        if (on_content) on_content(result);
        return result;
    }

    if (!agent_ || !agent_->is_initialized()) {
        std::string err = "Error: Agent not initialized";
        if (on_content) on_content(err);
        return err;
    }

    // Build message
    std::string message = docs_primed_ ? prompt : build_primed_message(prompt);
    docs_primed_ = true;

    // Use query_hosted with streaming callback
    libagents::HostContext host;
    host.should_abort = [this]() { return quit_requested_.load(); };
    host.on_event = [on_content](const libagents::Event& event) {
        if (on_content && event.type == libagents::EventType::ContentDelta) {
            on_content(event.content);
        }
    };

    try {
        return agent_->query_hosted(message, host);
    } catch (const std::exception& e) {
        return std::string("Error: ") + e.what();
    }
}

// ============================================================================
// Helpers
// ============================================================================

std::string AIAgent::build_primed_message(const std::string& user_message) {
    return std::string(SYSTEM_PROMPT) +
        "\n\n---\n\n"
        "# User Request\n\n"
        "Use the `idasql` tool to execute SQL queries. "
        "Do not use Bash, Grep, or other tools - only use the idasql tool.\n\n" +
        user_message;
}

bool AIAgent::looks_like_sql(const std::string& input) {
    if (input.empty()) return false;

    // Find first non-whitespace character
    size_t start = 0;
    while (start < input.size() && std::isspace(static_cast<unsigned char>(input[start]))) {
        ++start;
    }
    if (start >= input.size()) return false;

    // Convert first ~20 chars to uppercase for comparison
    std::string prefix;
    for (size_t i = start; i < input.size() && i < start + 20; ++i) {
        prefix += static_cast<char>(std::toupper(static_cast<unsigned char>(input[i])));
    }

    // Check for SQL keywords
    return prefix.rfind("SELECT ", 0) == 0 ||
           prefix.rfind("INSERT ", 0) == 0 ||
           prefix.rfind("UPDATE ", 0) == 0 ||
           prefix.rfind("DELETE ", 0) == 0 ||
           prefix.rfind("CREATE ", 0) == 0 ||
           prefix.rfind("DROP ", 0) == 0 ||
           prefix.rfind("PRAGMA ", 0) == 0 ||
           prefix.rfind("WITH ", 0) == 0 ||
           prefix.rfind("EXPLAIN ", 0) == 0 ||
           prefix.rfind(".TABLES", 0) == 0 ||
           prefix.rfind(".SCHEMA", 0) == 0 ||
           prefix.rfind(".HELP", 0) == 0 ||
           prefix.rfind(".QUIT", 0) == 0 ||
           prefix.rfind(".EXIT", 0) == 0;
}

bool AIAgent::is_available() {
    try {
        // Just check if we can create an agent - don't initialize
        // (initialization is expensive and would be redundant if we're about to
        // create another agent anyway)
        auto agent = libagents::create_agent(libagents::ProviderType::Claude);
        return agent != nullptr;
    } catch (...) {
        return false;
    }
}

} // namespace idasql

#endif // IDASQL_HAS_AI_AGENT

```

`src/common/ai_agent.hpp`:

```hpp
#pragma once

#ifdef IDASQL_HAS_AI_AGENT

#include <libagents/agent.hpp>
#include <libagents/config.hpp>
#include "agent_settings.hpp"
#include <atomic>
#include <functional>
#include <memory>
#include <string>

namespace idasql {

/**
 * AIAgent - Natural language interface for IDASQL using libagents
 *
 * This is a simplified wrapper around libagents that provides:
 * - Tool registration for SQL execution
 * - Main-thread tool dispatch via query_hosted() (required for IDA safety)
 * - SQL passthrough detection
 * - Signal handling for Ctrl-C
 * - BYOK (Bring Your Own Key) support for Copilot provider
 *
 * Architecture:
 *   - libagents handles all threading internally
 *   - query_hosted() ensures tool handlers run on the caller thread
 *   - No custom queues or thread management needed
 */
class AIAgent {
public:
    /// Callback to execute SQL and return formatted results
    using SqlExecutor = std::function<std::string(const std::string& sql)>;

    /// Callback for streaming content
    using ContentCallback = std::function<void(const std::string& content)>;

    /**
     * Construct agent with SQL executor and settings
     * @param executor Function that executes SQL and returns formatted results
     * @param settings Agent settings (provider, BYOK, timeout, etc.)
     * @param verbose If true, show debug output
     */
    explicit AIAgent(SqlExecutor executor, const AgentSettings& settings, bool verbose = false);

    /**
     * Construct agent with SQL executor (uses stored settings)
     * @param executor Function that executes SQL and returns formatted results
     * @param verbose If true, show debug output
     */
    explicit AIAgent(SqlExecutor executor, bool verbose = false);

    /**
     * Configure BYOK (Bring Your Own Key) - call before start()
     * Required for Copilot provider, optional for Claude
     * @param config BYOK configuration (api_key, base_url, model, provider_type)
     */
    void set_byok(const libagents::BYOKConfig& config);

    /**
     * Load BYOK config from environment variables (fallback)
     * Looks for COPILOT_SDK_BYOK_API_KEY, COPILOT_SDK_BYOK_BASE_URL, etc.
     * @return true if BYOK was configured from environment
     */
    bool load_byok_from_env();

    /**
     * Get the current provider type
     */
    libagents::ProviderType provider_type() const { return provider_type_; }

    ~AIAgent();

    // Non-copyable, non-movable
    AIAgent(const AIAgent&) = delete;
    AIAgent& operator=(const AIAgent&) = delete;
    AIAgent(AIAgent&&) = delete;
    AIAgent& operator=(AIAgent&&) = delete;

    /**
     * Start the agent and connect to provider
     */
    void start();

    /**
     * Stop the agent and disconnect
     */
    void stop();

    /**
     * Reset the session - clears conversation history
     */
    void reset_session();

    /**
     * Request to quit (e.g., from Ctrl-C handler)
     * Thread-safe, can be called from signal handler
     */
    void request_quit();

    /**
     * Check if quit was requested
     */
    bool quit_requested() const { return quit_requested_.load(); }

    /**
     * Send a query and get response (blocking)
     * SQL is passed through directly, natural language goes to AI.
     * Tool handlers execute on the caller thread (main thread safe).
     *
     * @param prompt User input (natural language or SQL)
     * @return Response text
     */
    std::string query(const std::string& prompt);

    /**
     * Send a query with streaming output
     * @param prompt User input
     * @param on_content Callback for content deltas
     * @return Final response text
     */
    std::string query_streaming(const std::string& prompt, ContentCallback on_content);

    /**
     * Check if input looks like SQL (for passthrough)
     * @param input User input string
     * @return true if input appears to be SQL
     */
    static bool looks_like_sql(const std::string& input);

    /**
     * Check if AI agent is available
     * @return true if the default provider is available
     */
    static bool is_available();

private:
    SqlExecutor executor_;
    bool verbose_ = false;
    bool docs_primed_ = false;
    std::atomic<bool> quit_requested_{false};
    std::unique_ptr<libagents::IAgent> agent_;
    libagents::ProviderType provider_type_ = libagents::ProviderType::Claude;
    libagents::BYOKConfig byok_config_;
    bool byok_configured_ = false;
    int response_timeout_ms_ = 0;

    /// Register the idasql tool with libagents
    void setup_tools();

    /// Build primed message with documentation prepended
    std::string build_primed_message(const std::string& user_message);
};

} // namespace idasql

#endif // IDASQL_HAS_AI_AGENT

```

`src/common/http_server.cpp`:

```cpp
#include "http_server.hpp"

#include <sstream>

namespace idasql {

// Help text served at /help endpoint
static const char* HTTP_HELP_TEXT = R"(IDASQL HTTP REST API
====================

SQL interface for IDA Pro databases via HTTP.

Endpoints:
  GET  /         - Welcome message
  GET  /help     - This documentation
  POST /query    - Execute SQL (body = raw SQL, response = JSON)
  GET  /status   - Server health check
  POST /shutdown - Stop server

Response Format:
  Success: {"success": true, "columns": [...], "rows": [[...]], "row_count": N}
  Error:   {"success": false, "error": "message"}

Example:
  curl http://localhost:<port>/help
  curl -X POST http://localhost:<port>/query -d "SELECT name FROM funcs LIMIT 5"
)";

int IDAHTTPServer::start(int port, HTTPQueryCallback query_cb,
                         const std::string& bind_addr, bool use_queue) {
    if (impl_ && impl_->is_running()) {
        return impl_->port();
    }

    xsql::thinclient::http_query_server_config config;
    config.tool_name = "idasql";
    config.help_text = HTTP_HELP_TEXT;
    config.port = port;
    config.bind_address = bind_addr;
    config.query_fn = std::move(query_cb);
    config.use_queue = use_queue;
    config.status_fn = []() {
        return xsql::json{{"mode", "repl"}};
    };

    impl_ = std::make_unique<xsql::thinclient::http_query_server>(config);
    return impl_->start();
}

void IDAHTTPServer::run_until_stopped() {
    if (impl_) impl_->run_until_stopped();
}

void IDAHTTPServer::stop() {
    if (impl_) {
        impl_->stop();
        impl_.reset();
    }
}

bool IDAHTTPServer::is_running() const {
    return impl_ && impl_->is_running();
}

int IDAHTTPServer::port() const {
    return impl_ ? impl_->port() : 0;
}

std::string IDAHTTPServer::url() const {
    return impl_ ? impl_->url() : "";
}

void IDAHTTPServer::set_interrupt_check(std::function<bool()> check) {
    if (impl_) impl_->set_interrupt_check(std::move(check));
}

std::string format_http_info(int port, const std::string& stop_hint) {
    return xsql::thinclient::format_http_info("idasql", port, stop_hint);
}

std::string format_http_status(int port, bool running) {
    return xsql::thinclient::format_http_status(port, running);
}

} // namespace idasql

```

`src/common/http_server.hpp`:

```hpp
#pragma once

/**
 * IDAHTTPServer - HTTP REST server for IDASQL REPL
 *
 * Thin wrapper over xsql::thinclient::http_query_server.
 * Preserves the existing API for backward compatibility.
 *
 * Usage modes:
 * 1. CLI (idalib): Call run_until_stopped() to process commands on main thread
 * 2. Plugin: Use execute_sync() wrapper in callbacks (no run_until_stopped() needed)
 */

#include <xsql/thinclient/http_query_server.hpp>

#include <string>
#include <functional>
#include <memory>

namespace idasql {

// Callback for handling SQL queries
using HTTPQueryCallback = std::function<std::string(const std::string& sql)>;

class IDAHTTPServer {
public:
    IDAHTTPServer() = default;
    ~IDAHTTPServer() { stop(); }

    // Non-copyable
    IDAHTTPServer(const IDAHTTPServer&) = delete;
    IDAHTTPServer& operator=(const IDAHTTPServer&) = delete;

    /**
     * Start HTTP server on given port with callbacks
     *
     * @param port Port to listen on (0 = random port 8100-8199)
     * @param query_cb SQL query callback (returns JSON string)
     * @param bind_addr Address to bind to (default: localhost only)
     * @param use_queue If true, callbacks are queued for main thread (CLI mode)
     *                  If false, callbacks called directly (plugin mode with execute_sync)
     * @return Actual port used, or -1 on failure
     */
    int start(int port, HTTPQueryCallback query_cb,
              const std::string& bind_addr = "127.0.0.1",
              bool use_queue = false);

    /**
     * Block until server stops, processing commands on the calling thread.
     * Only needed when use_queue=true (CLI mode).
     */
    void run_until_stopped();

    /** Stop the server */
    void stop();

    /** Check if server is running */
    bool is_running() const;

    /** Get the port the server is listening on */
    int port() const;

    /** Get the server URL */
    std::string url() const;

    /** Set interrupt check function (called during wait loop) */
    void set_interrupt_check(std::function<bool()> check);

private:
    std::unique_ptr<xsql::thinclient::http_query_server> impl_;
};

/**
 * Format HTTP server info for display
 */
std::string format_http_info(int port, const std::string& stop_hint = "Press Ctrl+C to stop and return to REPL.");

/**
 * Format HTTP server status
 */
std::string format_http_status(int port, bool running);

} // namespace idasql

```

`src/common/idasql_agent_prompt.hpp`:

```hpp
// Auto-generated from idasql_agent.md
// Generated: 2026-02-12T18:29:38.360124
// DO NOT EDIT - regenerate with: python scripts/embed_prompt.py

#pragma once

namespace idasql {

inline constexpr const char* SYSTEM_PROMPT =
    R"PROMPT(# IDASQL Agent Guide

A comprehensive reference for AI agents to effectively use IDASQL - an SQL interface for reverse engineering binary analysis with IDA Pro.

---

## What is IDA and Why SQL?

**IDA Pro** is the industry-standard disassembler and reverse engineering tool. It analyzes compiled binaries (executables, DLLs, firmware) and produces:
- **Disassembly** - Human-readable assembly code
- **Functions** - Detected code boundaries with names
- **Cross-references** - Who calls what, who references what data
- **Types** - Structures, enums, function prototypes
- **Decompilation** - C-like pseudocode (with Hex-Rays plugin)

**IDASQL** exposes all this analysis data through SQL virtual tables, enabling:
- Complex queries across multiple data types (JOINs)
- Aggregations and statistics (COUNT, GROUP BY)
- Pattern detection across the entire binary
- Scriptable analysis without writing IDA plugins or IDAPython scripts

---

## Core Concepts for Binary Analysis

### Addresses (ea_t)
Everything in a binary has an **address** - a memory location where code or data lives. IDA uses `ea_t` (effective address) as unsigned 64-bit integers. SQL shows these as integers; use `printf('0x%X', address)` for hex display.

### Functions
IDA groups code into **functions** with:
- `address` / `start_ea` - Where the function begins
- `end_ea` - Where it ends
- `name` - Assigned or auto-generated name (e.g., `main`, `sub_401000`)
- `size` - Total bytes in the function

### Cross-References (xrefs)
Binary analysis is about understanding **relationships**:
- **Code xrefs** - Function calls, jumps between code
- **Data xrefs** - Code reading/writing data locations
- `from_ea` → `to_ea` represents "address X references address Y"

### Segments
Memory is divided into **segments** with different purposes:
- `.text` - Executable code (typically)
- `.data` - Initialized global data
- `.rdata` - Read-only data (strings, constants)
- `.bss` - Uninitialized data

Of course, segment names and types can vary. You may query the `segments` table to understand memory layout.

### Basic Blocks
Within a function, **basic blocks** are straight-line code sequences:
- No branches in the middle
- Single entry, single exit
- Useful for control flow analysis

### Decompilation (Hex-Rays)
The **Hex-Rays decompiler** converts assembly to C-like **pseudocode**:
- **ctree** - The Abstract Syntax Tree of decompiled code
- **lvars** - Local variables detected by the decompiler
- Much easier to analyze than raw assembly

---

## Command-Line Interface

IDASQL provides SQL access to IDA databases via command line or as a server.

### Invocation Modes

**1. Single Query (Local)**
```bash
idasql -s database.i64 -q "SELECT * FROM funcs LIMIT 10"
idasql -s database.i64 -c "SELECT COUNT(*) FROM funcs"  # -c is alias for -q
```

**2. SQL File Execution**
```bash
idasql -s database.i64 -f analysis.sql
```

**3. Interactive REPL**
```bash
idasql -s database.i64 -i
```

**4. Remote Mode** (connect to running server)
```bash
idasql --remote localhost:8080 -q "SELECT * FROM funcs"
idasql --remote localhost:8080 -i  # Remote interactive
```

**5. HTTP Server Mode**
```bash
idasql -s database.i64 --http 8080
# Then query via: curl -X POST http://localhost:8080/query -d "SELECT * FROM funcs"
```

**6. Export Mode**
```bash
idasql -s database.i64 --export dump.sql
idasql -s database.i64 --export dump.sql --export-tables=funcs,segments
```

### CLI Options

| Option | Description |
|--------|-------------|
| `-s <file>` | IDA database file (.idb/.i64) |
| `--remote <host:port>` | Connect to IDASQL server |
| `--token <token>` | Auth token for remote/server mode |
| `-q <sql>` | Execute single SQL query |
| `-c <sql>` | Alias for -q (Python-style) |
| `-f <file>` | Execute SQL from file |
| `-i` | Interactive REPL mode |
| `-w, --write` | Save database changes on exit |
| `--export <file>` | Export tables to SQL file |
| `--export-tables=X` | Tables to export: `*` (all) or `table1,table2,...` |
| `--http [port]` | Start HTTP REST server (default: 8080) |
| `--bind <addr>` | Bind address for server (default: 127.0.0.1) |
| `-h, --help` | Show help |

### REPL Commands

| Command | Description |
|---------|-------------|
| `.tables` | List all virtual tables |
| `.schema [table]` | Show table schema |
| `.info` | Show database metadata |
| `.clear` | Clear session |
| `.quit` / `.exit` | Exit REPL |
| `.help` | Show available commands |
| `.http start` | Start HTTP server on random port |
| `.http stop` | Stop HTTP server |
| `.http status` | Show HTTP server status |
| `.agent` | Start AI agent mode |

### Performance Strategy

**Single queries:** Use `-q` directly.
```bash
idasql -s database.i64 -q "SELECT COUNT(*) FROM funcs"
```

**Multiple queries / exploration:** Start a server once, then query as a client.

Opening an IDA database has startup overhead (idalib initialization, auto-analysis). If you plan to run many queries—exploring the database, experimenting with different queries, or iterating on analysis—avoid re-opening the database each time.

**Recommended workflow for iterative analysis:**
```bash
# Terminal 1: Start server (opens database once)
idasql -s database.i64 --http 8080

# Terminal 2: Query repeatedly via remote client (instant responses)
idasql --remote localhost:8080 -q "SELECT * FROM funcs LIMIT 5"
idasql --remote localhost:8080 -q "SELECT * FROM strings WHERE content LIKE '%error%'"
idasql --remote localhost:8080 -q "SELECT name, size FROM funcs ORDER BY size DESC"
# ... as many queries as needed, no startup cost
```

Or use interactive mode on the remote connection:
```bash
idasql --remote localhost:8080 -i
idasql> SELECT COUNT(*) FROM funcs;
idasql> SELECT * FROM xrefs WHERE to_ea = 0x401000;
idasql> .quit
```

This approach is significantly faster for iterative analysis since the database remains open and queries go directly through the already-initialized session.

---

## Tables Reference

### Debugger Tables (Full CRUD)

#### breakpoints
Debugger breakpoints. Supports full CRUD (SELECT, INSERT, UPDATE, DELETE). Breakpoints persist in the IDB even without an active debugger session.

| Column | Type | RW | Description |
|--------|------|----|-------------|
| `address` | INT | R | Breakpoint address |
| `enabled` | INT | RW | 1=enabled, 0=disabled |
| `type` | INT | RW | Breakpoint type (0=software, 1=hw_write, 2=hw_read, 3=hw_rdwr, 4=hw_exec) |
| `type_name` | TEXT | R | Type name (software, hardware_write, etc.) |
| `size` | INT | RW | Breakpoint size (for hardware breakpoints) |
| `flags` | INT | RW | Breakpoint flags |
| `pass_count` | INT | RW | Pass count before trigger |
| `condition` | TEXT | RW | Condition expression |
| `loc_type` | INT | R | Location type code |
| `loc_type_name` | TEXT | R | Location type (absolute, relative, symbolic, source) |
| `module` | TEXT | R | Module path (relative breakpoints) |
| `symbol` | TEXT | R | Symbol name (symbolic breakpoints) |
| `offset` | INT | R | Offset (relative/symbolic) |
| `source_file` | TEXT | R | Source file (source breakpoints) |
| `source_line` | INT | R | Source line number |
| `is_hardware` | INT | R | 1=hardware breakpoint |
| `is_active` | INT | R | 1=currently active |
| `group` | TEXT | RW | Breakpoint group name |
| `bptid` | INT | R | Breakpoint ID |

```sql
-- List all breakpoints
SELECT printf('0x%08X', address) as addr, type_name, enabled, condition
FROM breakpoints;

-- Add software breakpoint
INSERT INTO breakpoints (address) VALUES (0x401000);

-- Add hardware write watchpoint
INSERT INTO breakpoints (address, type, size) VALUES (0x402000, 1, 4);

-- Add conditional breakpoint
INSERT INTO breakpoints (address, condition) VALUES (0x401000, 'eax == 0');

-- Disable a breakpoint
UPDATE breakpoints SET enabled = 0 WHERE address = 0x401000;

-- Delete a breakpoint
DELETE FROM breakpoints WHERE address = 0x401000;

-- Find which functions have breakpoints
SELECT b.address, f.name, b.type_name, b.enabled
FROM breakpoints b
JOIN funcs f ON b.address >= f.address AND b.address < f.end_ea;
```

### Entity Tables

#### funcs
All detected functions in the binary with prototype information.

| Column | Type | Description |
|--------|------|-------------|
| `address` | INT | Function start address |
| `name` | TEXT | Function name |
| `size` | INT | Function size in bytes |
| `end_ea` | INT | Function end address |
| `flags` | INT | Function flags |

**Prototype columns** (populated when type info available):

| Column | Type | Description |
|--------|------|-------------|
| `return_type` | TEXT | Return type string (e.g., "int", "void *") |
| `return_is_ptr` | INT | 1 if return type is pointer |
| `return_is_int` | INT | 1 if return type is exactly int |
| `return_is_integral` | INT | 1 if return type is int-like (int, long, DWORD, BOOL) |
| `return_is_void` | INT | 1 if return type is void |
| `arg_count` | INT | Number of function arguments |
| `calling_conv` | TEXT | Calling convention (cdecl, stdcall, fastcall, etc.) |

```sql
-- 10 largest functions
SELECT name, size FROM funcs ORDER BY size DESC LIMIT 10;

-- Functions starting with "sub_" (auto-named, not analyzed)
SELECT name, printf('0x%X', address) as addr FROM funcs WHERE name LIKE 'sub_%';

-- Functions returning integers with 3+ arguments
SELECT name, return_type, arg_count FROM funcs
WHERE return_is_integral = 1 AND arg_count >= 3;

-- Void functions (side effects, callbacks)
SELECT name, arg_count FROM funcs WHERE return_is_void = 1;

-- Pointer-returning functions (factories, allocators)
SELECT name, return_type FROM funcs WHERE return_is_ptr = 1;

-- Simple getter functions (no args, returns value)
SELECT name, return_type FROM funcs
WHERE arg_count = 0 AND return_is_void = 0;

-- Functions by calling convention
SELECT calling_conv, COUNT(*) as count FROM funcs
WHERE calling_conv IS NOT NULL AND calling_conv != ''
GROUP BY calling_conv ORDER BY count DESC;
```

#### segments
Memory segments. Supports UPDATE (`name`, `class`, `perm`) and DELETE.

| Column | Type | RW | Description |
|--------|------|----|-------------|
| `start_ea` | INT | R | Segment start |
| `end_ea` | INT | R | Segment end |
| `name` | TEXT | RW | Segment name (.text, .data, etc.) |
| `class` | TEXT | RW | Segment class (CODE, DATA) |
| `perm` | INT | RW | Permissions (R=4, W=2, X=1) |

```sql
-- Find executable segments
SELECT name, printf('0x%X', start_ea) as start FROM segments WHERE perm & 1 = 1;

-- Rename a segment
UPDATE segments SET name = '.mytext' WHERE start_ea = 0x401000;

-- Change segment permissions to read+exec
UPDATE segments SET perm = 5 WHERE name = '.text';

-- Delete a segment
DELETE FROM segments WHERE name = '.rdata';
```

#### names
All named locations (functions, labels, data).

| Column | Type | Description |
|--------|------|-------------|
| `address` | INT | Address |
| `name` | TEXT | Name |

#### entries
Entry points (exports, program entry).

| Column | Type | Description |
|--------|------|-------------|
| `ordinal` | INT | Export ordinal |
| `address` | INT | Entry address |
| `name` | TEXT | Entry name |

#### imports
Imported functions from external libraries.

| Column | Type | Description |
|--------|------|-------------|
| `address` | INT | Import address (IAT entry) |
| `name` | TEXT | Import name |
| `module` | TEXT | Module/DLL name |
| `ordinal` | INT | Import ordinal |

```sql
-- Imports from kernel32.dll
SELECT name FROM imports WHERE module LIKE '%kernel32%';
```

#### strings
String literals found in the binary. IDA maintains a cached string list that can be configured.

| Column | Type | Description |
|--------|------|-------------|
| `address` | INT | String address |
| `length` | INT | String length |
| `type` | INT | String type (raw encoding bits) |
| `type_name` | TEXT | Type name: ascii, utf16, utf32 |
| `width` | INT | Char width (0=1-byte, 1=2-byte, 2=4-byte) |
| `width_name` | TEXT | Width name: 1-byte, 2-byte, 4-byte |
| `layout` | INT | String layout (0=null-terminated, 1-3=pascal) |
| `layout_name` | TEXT | Layout name: termchr, pascal1, pascal2, pascal4 |
| `encoding` | INT | Encoding index (0=default) |
| `content` | TEXT | String content |

**String Type Encoding:**
IDA stores string type as a 32-bit value:
- Bits 0-1: Width (0=1B/ASCII, 1=2B/UTF-16, 2=4B/UTF-32)
- Bits 2-7: Layout (0=TERMCHR, 1=PASCAL1, 2=PASCAL2, 3=PASCAL4)
- Bits 8-15: term1 (first termination character)
- Bits 16-23: term2 (second termination character)
- Bits 24-31: encoding index

```sql
-- Find error messages
SELECT content, printf('0x%X', address) as addr FROM strings WHERE content LIKE '%error%';

-- ASCII strings only
SELECT * FROM strings WHERE type_name = 'ascii';

-- UTF-16 strings (common in Windows)
SELECT * FROM strings WHERE type_name = 'utf16';

-- Count strings by type
SELECT type_name, layout_name, COUNT(*) as count
FROM strings GROUP BY type_name, layout_name ORDER BY count DESC;
```

**Important:** For new analysis (exe/dll), strings are auto-built. For existing databases (i64/idb), strings are already saved. If you see 0 strings unexpectedly, run `SELECT rebuild_strings()` once to rebuild the list. See String List Functions section below.

#### xrefs
Cross-references - the most important table for understanding code relationships.

| Column | Type | Description |
|--------|------|-------------|
| `from_ea` | INT | Source address (who references) |
| `to_ea` | INT | Target address (what is referenced) |
| `type` | INT | Xref type code |
| `is_code` | INT | 1=code xref (call/jump), 0=data xref |

```sql
-- Who calls function at 0x401000?
SELECT printf('0x%X', from_ea) as caller FROM xrefs WHERE to_ea = 0x401000 AND is_code = 1;

-- What does function at 0x401000 reference?
SELECT printf('0x%X', to_ea) as target FROM xrefs WHERE from_ea >= 0x401000 AND from_ea < 0x401100;
```

#### blocks
Basic blocks within functions. **Use `func_ea` constraint for performance.**

| Column | Type | Description |
|--------|------|-------------|
| `func_ea` | INT | Containing function |
| `start_ea` | INT | Block start |
| `end_ea` | INT | Block end |
| `size` | INT | Block size |

```sql
-- Blocks in a specific function (FAST - uses constraint pushdown)
SELECT * FROM blocks WHERE func_ea = 0x401000;

-- Functions with most basic blocks
SELECT func_at(func_ea) as name, COUNT(*) as blocks
FROM blocks GROUP BY func_ea ORDER BY blocks DESC LIMIT 10;
```

### Convenience Views

Pre-built views for common xref analysis patterns. These simplify caller/callee queries.

#### callers
Who calls each function. Use this instead of manual xref JOINs.

| Column | Type | Description |
|--------|------|-------------|
| `func_addr` | INT | Target function address |
| `caller_addr` | INT | Xref source address |
| `caller_name` | TEXT | Calling function name |
| `caller_func_addr` | INT | Calling function start |

```sql
-- Who calls function at 0x401000?
SELECT caller_name, printf('0x%X', caller_addr) as from_addr)PROMPT"
    R"PROMPT(FROM callers WHERE func_addr = 0x401000;

-- Most called functions
SELECT printf('0x%X', func_addr) as addr, COUNT(*) as callers
FROM callers GROUP BY func_addr ORDER BY callers DESC LIMIT 10;
```

#### callees
What each function calls. Inverse of callers view.

| Column | Type | Description |
|--------|------|-------------|
| `func_addr` | INT | Calling function address |
| `func_name` | TEXT | Calling function name |
| `callee_addr` | INT | Called address |
| `callee_name` | TEXT | Called function/symbol name |

```sql
-- What does main call?
SELECT callee_name, printf('0x%X', callee_addr) as addr
FROM callees WHERE func_name LIKE '%main%';

-- Functions making most calls
SELECT func_name, COUNT(*) as call_count
FROM callees GROUP BY func_addr ORDER BY call_count DESC LIMIT 10;
```

#### string_refs
Which functions reference which strings. Great for finding functions by string content.

| Column | Type | Description |
|--------|------|-------------|
| `string_addr` | INT | String address |
| `string_value` | TEXT | String content |
| `string_length` | INT | String length |
| `ref_addr` | INT | Reference address |
| `func_addr` | INT | Referencing function |
| `func_name` | TEXT | Function name |

```sql
-- Find functions using error strings
SELECT func_name, string_value
FROM string_refs
WHERE string_value LIKE '%error%' OR string_value LIKE '%fail%';

-- Functions with most string references
SELECT func_name, COUNT(*) as string_count
FROM string_refs WHERE func_name IS NOT NULL
GROUP BY func_addr ORDER BY string_count DESC LIMIT 10;
```

### Instruction Tables

#### instructions
Decoded instructions. Supports DELETE (converts instruction to unexplored bytes). **Always filter by `func_addr` for performance.**

| Column | Type | Description |
|--------|------|-------------|
| `address` | INT | Instruction address |
| `func_addr` | INT | Containing function |
| `itype` | INT | Instruction type (architecture-specific) |
| `mnemonic` | TEXT | Instruction mnemonic |
| `size` | INT | Instruction size |
| `operand0` | TEXT | First operand |
| `operand1` | TEXT | Second operand |
| `disasm` | TEXT | Full disassembly line |

```sql
-- Instruction profile of a function (FAST)
SELECT mnemonic, COUNT(*) as count
FROM instructions WHERE func_addr = 0x401330
GROUP BY mnemonic ORDER BY count DESC;

-- Find all call instructions in a function
SELECT address, disasm FROM instructions
WHERE func_addr = 0x401000 AND mnemonic = 'call';

-- Delete an instruction (convert to unexplored bytes)
DELETE FROM instructions WHERE address = 0x401000;
```

**Performance:** `WHERE func_addr = X` uses O(function_size) iteration. Without this constraint, it scans the entire database - SLOW.

#### disasm_calls
All call instructions with resolved targets.

| Column | Type | Description |
|--------|------|-------------|
| `func_addr` | INT | Function containing the call |
| `ea` | INT | Call instruction address |
| `callee_addr` | INT | Target address (0 if unknown) |
| `callee_name` | TEXT | Target name |

```sql
-- Functions that call malloc
SELECT DISTINCT func_at(func_addr) as caller
FROM disasm_calls WHERE callee_name LIKE '%malloc%';
```

### Database Modification

The following tables support modification:

| Table | INSERT | UPDATE columns | DELETE |
|-------|--------|---------------|--------|
| `breakpoints` | Yes | `enabled`, `type`, `size`, `flags`, `pass_count`, `condition`, `group` | Yes |
| `funcs` | Yes | `name`, `flags` | Yes |
| `names` | Yes | `name` | Yes |
| `comments` | Yes | `comment`, `rep_comment` | Yes |
| `bookmarks` | Yes | `description` | Yes |
| `segments` | — | `name`, `class`, `perm` | Yes |
| `instructions` | — | — | Yes |
| `types` | Yes | Yes | Yes |
| `types_members` | Yes | Yes | Yes |
| `types_enum_values` | Yes | Yes | Yes |
| `ctree_lvars` | — | `name`, `type` | — |

**INSERT examples:**
```sql
-- Create a function (IDA auto-detects boundaries)
INSERT INTO funcs (address) VALUES (0x401000);

-- Create a function with name and explicit end
INSERT INTO funcs (address, name, end_ea) VALUES (0x401000, 'my_func', 0x401050);

-- Set a name at an address
INSERT INTO names (address, name) VALUES (0x401000, 'main');

-- Add a comment
INSERT INTO comments (address, comment) VALUES (0x401050, 'Check return value');

-- Add a repeatable comment
INSERT INTO comments (address, rpt_comment) VALUES (0x404000, 'Global config');

-- Add a bookmark (auto-assigned slot)
INSERT INTO bookmarks (address, description) VALUES (0x401000, 'interesting');

-- Add a bookmark at specific slot
INSERT INTO bookmarks (slot, address, description) VALUES (5, 0x401000, 'slot 5');
```

**UPDATE examples:**
```sql
-- Rename a function
UPDATE funcs SET name = 'my_main' WHERE address = 0x401000;

-- Rename any named address
UPDATE names SET name = 'my_global' WHERE address = 0x404000;

-- Add/update comment
UPDATE comments SET comment = 'Check return value' WHERE address = 0x401050;

-- Add repeatable comment
UPDATE comments SET rep_comment = 'Global config' WHERE address = 0x404000;

-- Delete a name
DELETE FROM names WHERE address = 0x401000;
```

**Segments:**
```sql
-- Rename a segment
UPDATE segments SET name = '.mytext' WHERE start_ea = 0x401000;

-- Change segment class
UPDATE segments SET class = 'DATA' WHERE name = '.rdata';

-- Change permissions (R=4, W=2, X=1)
UPDATE segments SET perm = 5 WHERE name = '.text';

-- Delete a segment
DELETE FROM segments WHERE name = '.rdata';
```

**Instructions:**
```sql
-- Delete an instruction (convert to unexplored bytes)
DELETE FROM instructions WHERE address = 0x401000;
```

**Types:**
```sql
-- Create a new struct
INSERT INTO types (name, kind) VALUES ('my_struct', 'struct');

-- Create an enum
INSERT INTO types (name, kind) VALUES ('my_flags', 'enum');

-- Create a union
INSERT INTO types (name, kind) VALUES ('my_union', 'union');

-- Add a struct member with type
INSERT INTO types_members (type_ordinal, member_name, member_type) VALUES (42, 'field1', 'int');

-- Add a struct member (name only, default type)
INSERT INTO types_members (type_ordinal, member_name) VALUES (42, 'field2');

-- Add an enum value
INSERT INTO types_enum_values (type_ordinal, value_name, value) VALUES (15, 'FLAG_ACTIVE', 1);

-- Add an enum value with comment
INSERT INTO types_enum_values (type_ordinal, value_name, value, comment)
VALUES (15, 'FLAG_HIDDEN', 2, 'not visible in UI');
```

**Decompiler local variables (requires Hex-Rays):**
```sql
-- Rename a local variable
UPDATE ctree_lvars SET name = 'buffer_size'
WHERE func_addr = 0x401000 AND name = 'v1';

-- Change variable type
UPDATE ctree_lvars SET type = 'char *'
WHERE func_addr = 0x401000 AND idx = 2;
```

### Persisting Changes

Changes to the database (UPDATE, set_name, etc.) are held in memory by default.

**To persist changes:**
```sql
-- Explicit save (recommended for scripts)
SELECT save_database();  -- Returns 1 on success, 0 on failure
```

**CLI flag for auto-save:**
```bash
# Auto-save on exit (use with caution)
idasql -s db.i64 -q "UPDATE funcs SET name='main' WHERE address=0x401000" -w
```

**Best practice for batch operations:**
```sql
-- Make multiple changes
UPDATE funcs SET name = 'init_config' WHERE address = 0x401000;
UPDATE names SET name = 'g_settings' WHERE address = 0x402000;
-- Persist once at the end
SELECT save_database();
```

> Without `save_database()` or `-w`, changes are lost when the session ends.

### Decompiler Tables (Hex-Rays Required)

**CRITICAL:** Always filter by `func_addr`. Without constraint, these tables will decompile EVERY function - extremely slow!

#### pseudocode
Structured line-by-line pseudocode with writable comments. **Use `decompile(addr)` to view pseudocode; use this table only for surgical edits (comments) or structured queries.**

| Column | Type | Writable | Description |
|--------|------|----------|-------------|
| `func_addr` | INT | No | Function address |
| `line_num` | INT | No | Line number |
| `line` | TEXT | No | Pseudocode text |
| `ea` | INT | No | Corresponding assembly address (from COLOR_ADDR anchor) |
| `comment` | TEXT | **Yes** | Decompiler comment at this ea |
| `comment_placement` | TEXT | **Yes** | Comment placement: `semi` (inline, default), `block1` (above line) |

**Comment placements:** `semi` (after `;`), `block1` (own line above), `block2`, `curly1`, `curly2`, `colon`, `case`, `else`, `do`

```sql
-- VIEWING: Use decompile() function, NOT the pseudocode table
SELECT decompile(0x401000);

-- COMMENTING: Use pseudocode table to add/edit/delete comments
-- Add inline comment (appears after semicolon)
UPDATE pseudocode SET comment = 'buffer overflow here'
WHERE func_addr = 0x401000 AND ea = 0x401020;

-- Add block comment (appears on own line above the statement)
UPDATE pseudocode SET comment_placement = 'block1', comment = 'vulnerable call'
WHERE func_addr = 0x401000 AND ea = 0x401020;

-- Delete a comment
UPDATE pseudocode SET comment = NULL
WHERE func_addr = 0x401000 AND ea = 0x401020;

-- STRUCTURED QUERY: Get specific lines with ea and comment info
SELECT ea, line, comment FROM pseudocode WHERE func_addr = 0x401000;
```

#### ctree
Full Abstract Syntax Tree of decompiled code.

| Column | Type | Description |
|--------|------|-------------|
| `func_addr` | INT | Function address |
| `item_id` | INT | Unique node ID |
| `is_expr` | INT | 1=expression, 0=statement |
| `op_name` | TEXT | Node type (`cot_call`, `cit_if`, etc.) |
| `ea` | INT | Address in binary |
| `parent_id` | INT | Parent node ID |
| `depth` | INT | Tree depth |
| `x_id`, `y_id`, `z_id` | INT | Child node IDs |
| `var_idx` | INT | Local variable index |
| `var_name` | TEXT | Variable name |
| `obj_ea` | INT | Target address |
| `obj_name` | TEXT | Symbol name |
| `num_value` | INT | Numeric literal |
| `str_value` | TEXT | String literal |

#### ctree_lvars
Local variables from decompilation.

| Column | Type | Description |
|--------|------|-------------|
| `func_addr` | INT | Function address |
| `idx` | INT | Variable index |
| `name` | TEXT | Variable name |
| `type` | TEXT | Type string |
| `size` | INT | Size in bytes |
| `is_arg` | INT | 1=function argument |
| `is_stk_var` | INT | 1=stack variable |
| `stkoff` | INT | Stack offset |

#### ctree_call_args
Flattened call arguments for easy querying.

| Column | Type | Description |
|--------|------|-------------|
| `func_addr` | INT | Function address |
| `call_item_id` | INT | Call node ID |
| `arg_idx` | INT | Argument index (0-based) |
| `arg_op` | TEXT | Argument type |
| `arg_var_name` | TEXT | Variable name if applicable |
| `arg_var_is_stk` | INT | 1=stack variable |
| `arg_num_value` | INT | Numeric value |
| `arg_str_value` | TEXT | String value |

### Decompiler Views

Pre-built views for common patterns:

| View | Purpose |
|------|---------|
| `ctree_v_calls` | Function calls with callee info |
| `ctree_v_loops` | for/while/do loops |
| `ctree_v_ifs` | if statements |
| `ctree_v_comparisons` | Comparisons with operands |
| `ctree_v_assignments` | Assignments with operands |
| `ctree_v_derefs` | Pointer dereferences |
| `ctree_v_returns` | Return statements with value details |
| `ctree_v_calls_in_loops` | Calls inside loops (recursive) |
| `ctree_v_calls_in_ifs` | Calls inside if branches (recursive) |
| `ctree_v_leaf_funcs` | Functions with no outgoing calls |
| `ctree_v_call_chains` | Call chain paths up to depth 10 |

#### ctree_v_returns

Return statements with details about what's being returned.

| Column | Type | Description |
|--------|------|-------------|
| `func_addr` | INT | Function address |
| `item_id` | INT | Return statement item_id |
| `ea` | INT | Address of return |
| `return_op` | TEXT | Return value opcode (`cot_num`, `cot_var`, `cot_call`, etc.) |
| `return_num` | INT | Numeric value (if `cot_num`) |
| `return_str` | TEXT | String value (if `cot_str`) |
| `return_var` | TEXT | Variable name (if `cot_var`) |
| `returns_arg` | INT | 1 if returning a function argument |
| `returns_call_result` | INT | 1 if returning result of another call |

```sql
-- Functions that return 0
SELECT DISTINCT func_at(func_addr) as name FROM ctree_v_returns
WHERE return_op = 'cot_num' AND return_num = 0;

-- Functions that return -1 (error sentinel)
SELECT DISTINCT func_at(func_addr) as name FROM ctree_v_returns
WHERE return_op = 'cot_num' AND return_num = -1;

-- Functions that return their argument (pass-through)
SELECT DISTINCT func_at(func_addr) as name FROM ctree_v_returns
WHERE returns_arg = 1;
```

### Type Tables

#### types
All local type definitions. Supports INSERT (create struct/union/enum), UPDATE, and DELETE.

| Column | Type | Description |
|--------|------|-------------|
| `ordinal` | INT | Type ordinal |
| `name` | TEXT | Type name |
| `size` | INT | Size in bytes |
| `kind` | TEXT | struct/union/enum/typedef/func |
| `is_struct` | INT | 1=struct |
| `is_union` | INT | 1=union |
| `is_enum` | INT | 1=enum |

#### types_members
Structure and union members. Supports INSERT (add member to struct/union), UPDATE, and DELETE.

| Column | Type | Description |
|--------|------|-------------|
| `type_ordinal` | INT | Parent type ordinal |
| `type_name` | TEXT | Parent type name |
| `member_name` | TEXT | Member name |
| `offset` | INT | Byte offset |
| `size` | INT | Member size |
| `member_type` | TEXT | Type string |
| `mt_is_ptr` | INT | 1=pointer |
| `mt_is_array` | INT | 1=array |
| `mt_is_struct` | INT | 1=embedded struct |

#### types_enum_values
Enum constant values. Supports INSERT (add value to enum), UPDATE, and DELETE.

| Column | Type | Description |
|--------|------|-------------|
| `type_ordinal` | INT | Enum type ordinal |
| `type_name` | TEXT | Enum name |
| `value_name` | TEXT | Constant name |
| `value` | INT | Constant value |

#### types_func_args
Function prototype arguments with type classification.

| Column | Type | Description |
|--------|------|-------------|
| `type_ordinal` | INT | Function type ordinal |
| `type_name` | TEXT | Function type name |
| `arg_index` | INT | Argument index (-1 = return type, 0+ = args) |
| `arg_name` | TEXT | Argument name |
| `arg_type` | TEXT | Argument type string |
| `calling_conv` | TEXT | Calling convention (on return row only) |

**Surface-level type classification** (literal type as written):

| Column | Type | Description |
|--------|------|-------------|
| `is_ptr` | INT | 1 if pointer type |
| `is_int` | INT | 1 if exactly int type |
| `is_integral` | INT | 1 if int-like (int, long, short, char, bool) |
| `is_float` | INT | 1 if float/double |
| `is_void` | INT | 1 if void |
| `is_struct` | INT | 1 if struct/union |
| `is_array` | INT | 1 if array |
| `ptr_depth` | INT | Pointer depth (int** = 2) |
| `base_type` | TEXT | Type with pointers stripped |

**Resolved type classification** (after typedef resolution):

| Column | Type | Description |
|--------|------|-------------|
| `is_ptr_resolved` | INT | 1 if resolved type is pointer |)PROMPT"
    R"PROMPT(| `is_int_resolved` | INT | 1 if resolved type is exactly int |
| `is_integral_resolved` | INT | 1 if resolved type is int-like |
| `is_float_resolved` | INT | 1 if resolved type is float/double |
| `is_void_resolved` | INT | 1 if resolved type is void |
| `ptr_depth_resolved` | INT | Pointer depth after resolution |
| `base_type_resolved` | TEXT | Resolved type with pointers stripped |

```sql
-- Functions returning integers (strict: exactly int)
SELECT type_name FROM types_func_args
WHERE arg_index = -1 AND is_int = 1;

-- Functions returning integers (loose: includes BOOL, DWORD, LONG)
SELECT type_name FROM types_func_args
WHERE arg_index = -1 AND is_integral_resolved = 1;

-- Functions taking 4 pointer arguments
SELECT type_name, COUNT(*) as ptr_args FROM types_func_args
WHERE arg_index >= 0 AND is_ptr = 1
GROUP BY type_ordinal HAVING ptr_args = 4;

-- Typedefs that hide pointers (HANDLE, etc.)
SELECT type_name, arg_type FROM types_func_args
WHERE is_ptr = 0 AND is_ptr_resolved = 1;
```

### Type Views

Convenience views for filtering types:

| View | Description |
|------|-------------|
| `types_v_structs` | `SELECT * FROM types WHERE is_struct = 1` |
| `types_v_unions` | `SELECT * FROM types WHERE is_union = 1` |
| `types_v_enums` | `SELECT * FROM types WHERE is_enum = 1` |
| `types_v_typedefs` | `SELECT * FROM types WHERE is_typedef = 1` |
| `types_v_funcs` | `SELECT * FROM types WHERE is_func = 1` |
| `local_types` | Legacy compatibility view |

### Extended Tables

#### bookmarks
User-defined bookmarks/marked positions.

| Column | Type | Description |
|--------|------|-------------|
| `index` | INT | Bookmark index |
| `address` | INT | Bookmarked address |
| `description` | TEXT | Bookmark description |

```sql
-- List all bookmarks
SELECT printf('0x%X', address) as addr, description FROM bookmarks;
```

#### heads
All defined items (code/data heads) in the database.

| Column | Type | Description |
|--------|------|-------------|
| `address` | INT | Head address |
| `size` | INT | Item size |
| `flags` | INT | IDA flags |

**Performance:** This table can be very large. Always use address range filters.

#### fixups
Relocation and fixup information.

| Column | Type | Description |
|--------|------|-------------|
| `address` | INT | Fixup address |
| `type` | INT | Fixup type |
| `target` | INT | Target address |

#### hidden_ranges
Collapsed/hidden code regions in IDA.

| Column | Type | Description |
|--------|------|-------------|
| `start_ea` | INT | Range start |
| `end_ea` | INT | Range end |
| `description` | TEXT | Description |
| `visible` | INT | Visibility state |

#### problems
IDA analysis problems and warnings.

| Column | Type | Description |
|--------|------|-------------|
| `address` | INT | Problem address |
| `type` | INT | Problem type code |
| `description` | TEXT | Problem description |

```sql
-- Find all analysis problems
SELECT printf('0x%X', address) as addr, description FROM problems;
```

#### fchunks
Function chunks (for functions with non-contiguous code, like exception handlers).

| Column | Type | Description |
|--------|------|-------------|
| `func_addr` | INT | Parent function |
| `start_ea` | INT | Chunk start |
| `end_ea` | INT | Chunk end |
| `size` | INT | Chunk size |

```sql
-- Functions with multiple chunks (complex control flow)
SELECT func_at(func_addr) as name, COUNT(*) as chunks
FROM fchunks GROUP BY func_addr HAVING chunks > 1;
```

#### signatures
FLIRT signature matches.

| Column | Type | Description |
|--------|------|-------------|
| `address` | INT | Matched address |
| `name` | TEXT | Signature name |
| `library` | TEXT | Library name |

#### mappings
Memory mappings for debugging.

| Column | Type | Description |
|--------|------|-------------|
| `from_ea` | INT | Mapped from |
| `to_ea` | INT | Mapped to |
| `size` | INT | Mapping size |

### Metadata Tables

#### db_info
Database-level metadata.

| Column | Type | Description |
|--------|------|-------------|
| `key` | TEXT | Metadata key |
| `value` | TEXT | Metadata value |

```sql
-- Get database info
SELECT * FROM db_info;
```

#### ida_info
IDA processor and analysis info.

| Column | Type | Description |
|--------|------|-------------|
| `key` | TEXT | Info key |
| `value` | TEXT | Info value |

```sql
-- Get processor type
SELECT value FROM ida_info WHERE key = 'procname';
```

### Disassembly Tables

#### disasm_loops
Detected loops in disassembly.

| Column | Type | Description |
|--------|------|-------------|
| `func_addr` | INT | Function address |
| `loop_start` | INT | Loop header address |
| `loop_end` | INT | Loop end address |

### Disassembly Views

Views for disassembly-level analysis (no Hex-Rays required):

| View | Description |
|------|-------------|
| `disasm_v_leaf_funcs` | Functions with no outgoing calls |
| `disasm_v_call_chains` | Call chain paths (recursive CTE) |
| `disasm_v_calls_in_loops` | Calls inside loop bodies |
| `disasm_v_funcs_with_loops` | Functions containing loops |

```sql
-- Find functions that don't call anything
SELECT * FROM disasm_v_leaf_funcs LIMIT 10;

-- Find hotspot calls (inside loops)
SELECT func_at(func_addr) as func, callee_name
FROM disasm_v_calls_in_loops;
```

---

## SQL Functions

### Disassembly
| Function | Description |
|----------|-------------|
| `disasm(addr)` | Disassembly line at address |
| `disasm(addr, n)` | Multiple lines from address |
| `bytes(addr, n)` | Bytes as hex string |
| `bytes_raw(addr, n)` | Raw bytes as BLOB |
| `mnemonic(addr)` | Instruction mnemonic only |
| `operand(addr, n)` | Operand text (n=0-5) |

### Binary Search
| Function | Description |
|----------|-------------|
| `search_bytes(pattern)` | Find all matches, returns JSON array |
| `search_bytes(pattern, start, end)` | Search within address range |
| `search_first(pattern)` | First match address (or NULL) |
| `search_first(pattern, start, end)` | First match in range |

**Pattern syntax (IDA native):**
- `"48 8B 05"` - Exact bytes (hex, space-separated)
- `"48 ? 05"` or `"48 ?? 05"` - `?` = any byte wildcard (whole byte only)
- `"(01 02 03)"` - Alternatives (match any of these bytes)

**Note:** Unlike Binary Ninja, IDA does NOT support nibble wildcards or regex.

**Example:**
```sql
-- Find all matches for a pattern
SELECT search_bytes('48 8B ? 00');

-- Parse JSON results
SELECT json_extract(value, '$.address') as addr
FROM json_each(search_bytes('48 89 ?'))
LIMIT 10;

-- First match only
SELECT printf('0x%llX', search_first('CC CC CC'));

-- Search with alternatives
SELECT search_bytes('E8 (01 02 03 04)');
```

**Optimization Pattern: Find functions using specific instruction**

To answer "How many functions use RDTSC instruction?" efficiently:
```sql
-- Count unique functions containing RDTSC (opcode: 0F 31)
SELECT COUNT(DISTINCT func_start(json_extract(value, '$.address'))) as count
FROM json_each(search_bytes('0F 31'))
WHERE func_start(json_extract(value, '$.address')) IS NOT NULL;

-- List those functions with names
SELECT DISTINCT
    func_start(json_extract(value, '$.address')) as func_ea,
    name_at(func_start(json_extract(value, '$.address'))) as func_name
FROM json_each(search_bytes('0F 31'))
WHERE func_start(json_extract(value, '$.address')) IS NOT NULL;
```

This is **much faster** than scanning all disassembly lines because:
- `search_bytes()` uses native binary search
- `func_start()` is O(1) lookup in IDA's function index

### Names & Functions
| Function | Description |
|----------|-------------|
| `name_at(addr)` | Name at address |
| `func_at(addr)` | Function name containing address |
| `func_start(addr)` | Start of containing function |
| `func_end(addr)` | End of containing function |
| `func_qty()` | Total function count |
| `func_at_index(n)` | Function address at index (O(1)) |

### Cross-References
| Function | Description |
|----------|-------------|
| `xrefs_to(addr)` | JSON array of xrefs TO address |
| `xrefs_from(addr)` | JSON array of xrefs FROM address |

### Navigation
| Function | Description |
|----------|-------------|
| `next_head(addr)` | Next defined item |
| `prev_head(addr)` | Previous defined item |
| `segment_at(addr)` | Segment name at address |
| `hex(val)` | Format as hex string |

### Comments
| Function | Description |
|----------|-------------|
| `comment_at(addr)` | Get comment at address |
| `set_comment(addr, text)` | Set regular comment |
| `set_comment(addr, text, 1)` | Set repeatable comment |

### Modification
| Function | Description |
|----------|-------------|
| `set_name(addr, name)` | Set name at address |

### Item Analysis
| Function | Description |
|----------|-------------|
| `item_type(addr)` | Item type flags at address |
| `item_size(addr)` | Item size at address |
| `is_code(addr)` | Returns 1 if address is code |
| `is_data(addr)` | Returns 1 if address is data |
| `flags_at(addr)` | Raw IDA flags at address |

### Instruction Details
| Function | Description |
|----------|-------------|
| `itype(addr)` | Instruction type code (processor-specific) |
| `decode_insn(addr)` | Full instruction info as JSON |
| `operand_type(addr, n)` | Operand type code (o_void, o_reg, etc.) |
| `operand_value(addr, n)` | Operand value (register num, immediate, etc.) |

```sql
-- Get instruction type for filtering
SELECT address, itype(address) as itype, mnemonic(address)
FROM heads WHERE is_code(address) = 1 LIMIT 10;

-- Decode full instruction
SELECT decode_insn(0x401000);
```

### Decompilation

**When to use `decompile()` vs `pseudocode` table:**
- **To view/show pseudocode** → always use `SELECT decompile(addr)`. Returns the full function as a single text block with `/* ea */` address prefixes. This is fast, efficient, and what you should use when the user asks to "decompile", "show the code", or "show the pseudocode".
- **To read specific lines or columns** → query the `pseudocode` table. If you already have the full output from `decompile()`, refer to it directly. Only query the table when you need structured access (e.g. filtering by ea, reading comment values).
- **To add/edit/delete comments** → `UPDATE pseudocode SET comment = '...' WHERE func_addr = X AND ea = Y`. The pseudocode table is the write interface for decompiler comments.

| Function | Description |
|----------|-------------|
| `decompile(addr)` | **PREFERRED** — Full pseudocode with `/* ea */` prefixes (requires Hex-Rays) |
| `decompile(addr, 1)` | Same but forces re-decompilation (use after writing comments or renaming variables) |
| `list_lvars(addr)` | List local variables as JSON |
| `rename_lvar(addr, old, new)` | Rename a local variable (shortcut for `UPDATE ctree_lvars`) |

```sql
-- Decompile a function (PREFERRED way to view pseudocode)
SELECT decompile(0x401000);

-- After modifying comments or variables, re-decompile to see changes
SELECT decompile(0x401000, 1);

-- Get all local variables in a function
SELECT list_lvars(0x401000);

-- Rename a variable (function shortcut)
SELECT rename_lvar(0x401000, 'v1', 'buffer_size');

-- Equivalent using UPDATE (canonical approach)
UPDATE ctree_lvars SET name = 'buffer_size' WHERE func_addr = 0x401000 AND name = 'v1';
```

### File Generation
| Function | Description |
|----------|-------------|
| `gen_asm_file(start, end, path)` | Generate ASM file |
| `gen_lst_file(start, end, path)` | Generate listing file |
| `gen_map_file(path)` | Generate MAP file |
| `gen_idc_file(start, end, path)` | Generate IDC script |
| `gen_html_file(start, end, path)` | Generate HTML file |

```sql
-- Export function as ASM
SELECT gen_asm_file(0x401000, 0x401100, '/tmp/func.asm');

-- Generate MAP file
SELECT gen_map_file('/tmp/binary.map');
```

### Graph Generation
| Function | Description |
|----------|-------------|
| `gen_cfg_dot(addr)` | Generate CFG as DOT graph string |
| `gen_cfg_dot_file(addr, path)` | Write CFG DOT to file |
| `gen_schema_dot()` | Generate database schema as DOT |

```sql
-- Get CFG for a function as DOT format
SELECT gen_cfg_dot(0x401000);

-- Export schema visualization
SELECT gen_schema_dot();
```

### Entity Search ("Jump to Anything")
| Function | Description |
|----------|-------------|
| `jump_search(pattern, mode, limit, offset)` | Search entities, returns JSON array |
| `jump_query(pattern, mode, limit, offset)` | Returns the generated SQL string |

```sql
-- Search for functions/types/labels starting with 'sub'
SELECT jump_search('sub', 'prefix', 10, 0);

-- Search for anything containing 'main'
SELECT jump_search('main', 'contains', 10, 0);
```

### String List Functions

IDA maintains a cached list of strings. Use `rebuild_strings()` to detect and cache strings.

| Function | Description |
|----------|-------------|
| `rebuild_strings()` | Rebuild with ASCII + UTF-16, minlen 5 (default) |
| `rebuild_strings(minlen)` | Rebuild with custom minimum length |
| `rebuild_strings(minlen, types)` | Rebuild with custom length and type mask |
| `string_count()` | Get current string count (no rebuild) |

**Type mask values:**
- `1` = ASCII only (STRTYPE_C)
- `2` = UTF-16 only (STRTYPE_C_16)
- `4` = UTF-32 only (STRTYPE_C_32)
- `3` = ASCII + UTF-16 (default)
- `7` = All types

```sql
-- Check current string count
SELECT string_count();

-- Rebuild with defaults (ASCII + UTF-16, minlen 5)
SELECT rebuild_strings();

-- Rebuild with shorter minimum length
SELECT rebuild_strings(4);

-- Rebuild with specific types
SELECT rebuild_strings(5, 1);   -- ASCII only
SELECT rebuild_strings(5, 7);   -- All types (ASCII + UTF-16 + UTF-32)

-- Typical workflow: rebuild then query
SELECT rebuild_strings();
SELECT * FROM strings WHERE content LIKE '%error%';
```

**IMPORTANT - Agent Behavior for String Queries:**
When the user asks about strings (e.g., "show me the strings", "what strings are in this binary"):
1. First run `SELECT rebuild_strings()` to ensure strings are detected
2. Then query the `strings` table

The `rebuild_strings()` function configures IDA's string detection with sensible defaults (ASCII + UTF-16, minimum length 5) and rebuilds the string list. This ensures the user gets results even if the database had no prior string analysis.

---

## Entity Search Table (jump_entities)

A table-valued function for unified entity search with full SQL composability.

### Usage

```sql
-- Basic search (function-call syntax)
SELECT * FROM jump_entities('sub', 'prefix') LIMIT 10;

-- Filter by kind
SELECT * FROM jump_entities('EH', 'prefix') WHERE kind = 'struct';

-- JOIN with other tables
SELECT j.name, f.size
FROM jump_entities('sub', 'prefix') j
LEFT JOIN funcs f ON j.address = f.address
WHERE j.kind = 'function';
```

### Parameters

| Parameter | Description |
|-----------|-------------|
| `pattern` | Search pattern (required) |
| `mode` | `'prefix'` or `'contains'` |

### Columns

| Column | Type | Description |
|--------|------|-------------|
| `name` | TEXT | Entity name |
| `kind` | TEXT | function/label/segment/struct/union/enum/member/enum_member |)PROMPT"
    R"PROMPT(| `address` | INT | Address (for functions, labels, segments) |
| `ordinal` | INT | Type ordinal (for types, members) |
| `parent_name` | TEXT | Parent type (for members) |
| `full_name` | TEXT | Fully qualified name |

**Use Case:** Implement "Jump to Anything" with virtual scrolling - lazy cursor respects LIMIT.

---

## Performance Rules

### CRITICAL: Constraint Pushdown

Some tables have **optimized filters** that use efficient IDA SDK APIs:

| Table | Optimized Filter | Without Filter |
|-------|------------------|----------------|
| `instructions` | `func_addr = X` | O(all instructions) - SLOW |
| `blocks` | `func_ea = X` | O(all blocks) |
| `xrefs` | `to_ea = X` or `from_ea = X` | O(all xrefs) |
| `pseudocode` | `func_addr = X` | **Decompiles ALL functions** |
| `ctree*` | `func_addr = X` | **Decompiles ALL functions** |

**Always filter decompiler tables by `func_addr`!**

### Use Integer Comparisons

```sql
-- SLOW: String comparison
WHERE mnemonic = 'call'

-- FAST: Integer comparison
WHERE itype IN (16, 18)  -- x86 call opcodes
```

### O(1) Random Access

```sql
-- SLOW: O(n) - sorts all rows
SELECT address FROM funcs ORDER BY RANDOM() LIMIT 1;

-- FAST: O(1) - direct index access
SELECT func_at_index(ABS(RANDOM()) % func_qty());
```

---

## Common Query Patterns

### Find Most Called Functions

```sql
SELECT f.name, COUNT(*) as callers
FROM funcs f
JOIN xrefs x ON f.address = x.to_ea
WHERE x.is_code = 1
GROUP BY f.address
ORDER BY callers DESC
LIMIT 10;
```

### Find Functions Calling a Specific API

```sql
SELECT DISTINCT func_at(from_ea) as caller
FROM xrefs
WHERE to_ea = (SELECT address FROM imports WHERE name = 'CreateFileW');
```

### String Cross-Reference Analysis

```sql
SELECT s.content, func_at(x.from_ea) as used_by
FROM strings s
JOIN xrefs x ON s.address = x.to_ea
WHERE s.content LIKE '%password%';
```

### Function Complexity (by Block Count)

```sql
SELECT func_at(func_ea) as name, COUNT(*) as block_count
FROM blocks
GROUP BY func_ea
ORDER BY block_count DESC
LIMIT 10;
```

### Find Leaf Functions (No Outgoing Calls)

```sql
SELECT f.name, f.size
FROM funcs f
LEFT JOIN disasm_calls c ON c.func_addr = f.address
GROUP BY f.address
HAVING COUNT(c.ea) = 0
ORDER BY f.size DESC;
```

### Functions with Deep Call Chains

```sql
SELECT f.name, MAX(cc.depth) as max_depth
FROM disasm_v_call_chains cc
JOIN funcs f ON f.address = cc.root_func
GROUP BY cc.root_func
ORDER BY max_depth DESC
LIMIT 10;
```

### Security: Dangerous Function Calls with Stack Buffers

```sql
SELECT f.name, c.callee_name, printf('0x%X', c.ea) as address
FROM funcs f
JOIN ctree_v_calls c ON c.func_addr = f.address
JOIN ctree_call_args a ON a.func_addr = c.func_addr AND a.call_item_id = c.item_id
WHERE c.callee_name IN ('strcpy', 'strcat', 'sprintf', 'gets', 'memcpy')
  AND a.arg_idx = 0 AND a.arg_var_is_stk = 1
ORDER BY f.name;
```

### Find Zero Comparisons (Potential Error Checks)

```sql
SELECT func_at(func_addr) as func, printf('0x%X', ea) as addr
FROM ctree_v_comparisons
WHERE op_name = 'cot_eq' AND rhs_op = 'cot_num' AND rhs_num = 0;
```

### Calls Inside Loops (Performance Hotspots)

```sql
SELECT f.name, l.callee_name, l.loop_op
FROM ctree_v_calls_in_loops l
JOIN funcs f ON f.address = l.func_addr
ORDER BY f.name;
```

### malloc with Constant Size

```sql
SELECT func_at(c.func_addr) as func, a.arg_num_value as size
FROM ctree_v_calls c
JOIN ctree_call_args a ON a.func_addr = c.func_addr AND a.call_item_id = c.item_id
WHERE c.callee_name LIKE '%malloc%'
  AND a.arg_idx = 0 AND a.arg_op = 'cot_num'
ORDER BY a.arg_num_value DESC;
```

### Largest Structures

```sql
SELECT name, size, alignment
FROM types
WHERE is_struct = 1 AND size > 0
ORDER BY size DESC
LIMIT 10;
```

### Instruction Profile for a Function

```sql
SELECT mnemonic, COUNT(*) as count
FROM instructions
WHERE func_addr = 0x401330
GROUP BY mnemonic
ORDER BY count DESC;
```

### Import Dependency Map

```sql
-- Which modules does each function depend on?
SELECT f.name as func_name, i.module, COUNT(*) as api_count
FROM funcs f
JOIN disasm_calls dc ON dc.func_addr = f.address
JOIN imports i ON dc.callee_addr = i.address
GROUP BY f.address, i.module
ORDER BY f.name, api_count DESC;
```

### Find Indirect Calls (Potential Virtual Functions/Callbacks)

```sql
-- Functions with indirect calls (call through register/memory)
SELECT f.name, COUNT(*) as indirect_calls
FROM funcs f
JOIN disasm_calls dc ON dc.func_addr = f.address
WHERE dc.callee_addr = 0  -- Unresolved target = indirect
GROUP BY f.address
ORDER BY indirect_calls DESC
LIMIT 20;
```

### String Format Audit (printf-style Vulnerabilities)

```sql
-- Format string usage with variable formats (potential vuln)
SELECT f.name, c.callee_name, printf('0x%X', c.ea) as addr
FROM funcs f
JOIN ctree_v_calls c ON c.func_addr = f.address
JOIN ctree_call_args a ON a.func_addr = c.func_addr AND a.call_item_id = c.item_id
WHERE c.callee_name LIKE '%printf%'
  AND a.arg_idx = 0  -- First arg is format string
  AND a.arg_op = 'cot_var';  -- Variable, not constant string
```

### Memory Allocation Patterns

```sql
-- Find functions that allocate but may not free
WITH allocators AS (
    SELECT func_addr, COUNT(*) as alloc_count
    FROM disasm_calls
    WHERE callee_name LIKE '%alloc%' OR callee_name LIKE '%malloc%'
    GROUP BY func_addr
),
freers AS (
    SELECT func_addr, COUNT(*) as free_count
    FROM disasm_calls
    WHERE callee_name LIKE '%free%'
    GROUP BY func_addr
)
SELECT f.name,
       COALESCE(a.alloc_count, 0) as allocations,
       COALESCE(r.free_count, 0) as frees
FROM funcs f
LEFT JOIN allocators a ON f.address = a.func_addr
LEFT JOIN freers r ON f.address = r.func_addr
WHERE a.alloc_count > 0 AND COALESCE(r.free_count, 0) = 0
ORDER BY allocations DESC;
```

### Control Flow Anomalies

```sql
-- Functions with many basic blocks but few instructions (possibly obfuscated)
SELECT
    f.name,
    f.size,
    COUNT(DISTINCT b.start_ea) as blocks,
    f.size / COUNT(DISTINCT b.start_ea) as avg_block_size
FROM funcs f
JOIN blocks b ON b.func_ea = f.address
WHERE f.size > 100
GROUP BY f.address
HAVING COUNT(DISTINCT b.start_ea) > 10
   AND f.size / COUNT(DISTINCT b.start_ea) < 10  -- Very small blocks
ORDER BY blocks DESC;
```

### Return Value Analysis

```sql
-- Functions with multiple return statements (complex control flow)
SELECT f.name, COUNT(*) as return_count
FROM funcs f
JOIN ctree ct ON ct.func_addr = f.address
WHERE ct.op_name = 'cit_return'
GROUP BY f.address
HAVING COUNT(*) > 3
ORDER BY return_count DESC;

-- Functions that return 0 (common success pattern)
SELECT DISTINCT func_at(func_addr) as name FROM ctree_v_returns
WHERE return_op = 'cot_num' AND return_num = 0;

-- Functions that return -1 (error sentinel)
SELECT DISTINCT func_at(func_addr) as name FROM ctree_v_returns
WHERE return_op = 'cot_num' AND return_num = -1;

-- Functions that return a specific constant
SELECT DISTINCT func_at(func_addr) as name FROM ctree_v_returns
WHERE return_op = 'cot_num' AND return_num = 1;
```

### Function Signature Queries

```sql
-- Functions returning integers (includes BOOL, DWORD via resolved)
SELECT type_name FROM types_func_args
WHERE arg_index = -1 AND is_integral_resolved = 1;

-- Functions taking exactly 4 pointer arguments
SELECT type_name, COUNT(*) as ptr_args FROM types_func_args
WHERE arg_index >= 0 AND is_ptr = 1
GROUP BY type_ordinal HAVING ptr_args = 4;

-- Functions with string parameters (char*/wchar_t*)
SELECT DISTINCT type_name FROM types_func_args
WHERE arg_index >= 0 AND is_ptr = 1
  AND base_type_resolved IN ('char', 'wchar_t', 'CHAR', 'WCHAR');

-- Typedefs hiding pointers (HANDLE, HMODULE, etc.)
SELECT DISTINCT type_name, arg_type FROM types_func_args
WHERE is_ptr = 0 AND is_ptr_resolved = 1;

-- Functions returning void pointers
SELECT type_name FROM types_func_args
WHERE arg_index = -1 AND is_ptr_resolved = 1 AND is_void_resolved = 1;
```

### Loops with System Calls (Performance/Security Hotspots)

```sql
-- System API calls inside loops
SELECT
    f.name as function,
    l.callee_name as api_called,
    l.loop_op as loop_type
FROM ctree_v_calls_in_loops l
JOIN funcs f ON f.address = l.func_addr
JOIN imports i ON l.callee_name = i.name
ORDER BY f.name;
```

### Type Usage Statistics

```sql
-- Most referenced types (by struct member usage in decompiled code)
SELECT tm.type_name, COUNT(DISTINCT ct.func_addr) as func_count
FROM types_members tm
JOIN ctree ct ON ct.var_name = tm.member_name
GROUP BY tm.type_name
ORDER BY func_count DESC
LIMIT 20;
```

### Data Section Analysis

```sql
-- Find functions referencing data sections
SELECT
    f.name,
    s.name as segment,
    COUNT(*) as data_refs
FROM funcs f
JOIN xrefs x ON x.from_ea BETWEEN f.address AND f.end_ea
JOIN segments s ON x.to_ea BETWEEN s.start_ea AND s.end_ea
WHERE s.class = 'DATA' AND x.is_code = 0
GROUP BY f.address, s.name
ORDER BY data_refs DESC
LIMIT 20;
```

### Exception Handler Detection

```sql
-- Functions with multiple chunks (often due to exception handlers)
SELECT
    f.name,
    COUNT(*) as chunk_count,
    SUM(fc.size) as total_size
FROM funcs f
JOIN fchunks fc ON fc.func_addr = f.address
GROUP BY f.address
HAVING COUNT(*) > 1
ORDER BY chunk_count DESC;
```

---

## Advanced SQL Patterns

### Common Table Expressions (CTEs)

CTEs make complex queries readable and allow recursive traversal.

#### Basic CTE for Filtering

```sql
-- Find functions that both call malloc AND check return value
WITH malloc_callers AS (
    SELECT DISTINCT func_addr
    FROM disasm_calls
    WHERE callee_name LIKE '%malloc%'
),
null_checkers AS (
    SELECT DISTINCT func_addr
    FROM ctree_v_comparisons
    WHERE rhs_num = 0 AND op_name = 'cot_eq'
)
SELECT f.name
FROM funcs f
JOIN malloc_callers m ON f.address = m.func_addr
JOIN null_checkers n ON f.address = n.func_addr;
```

#### CTE with Aggregation

```sql
-- Functions ranked by complexity (calls * blocks)
WITH call_counts AS (
    SELECT func_addr, COUNT(*) as call_cnt
    FROM disasm_calls
    GROUP BY func_addr
),
block_counts AS (
    SELECT func_ea as func_addr, COUNT(*) as block_cnt
    FROM blocks
    GROUP BY func_ea
)
SELECT f.name,
       COALESCE(c.call_cnt, 0) as calls,
       COALESCE(b.block_cnt, 0) as blocks,
       COALESCE(c.call_cnt, 0) * COALESCE(b.block_cnt, 0) as complexity
FROM funcs f
LEFT JOIN call_counts c ON f.address = c.func_addr
LEFT JOIN block_counts b ON f.address = b.func_addr
ORDER BY complexity DESC
LIMIT 10;
```

### Recursive CTEs (Call Graph Traversal)

```sql
-- Find all functions reachable from main (up to depth 5)
WITH RECURSIVE call_graph AS (
    -- Base case: start from main
    SELECT address as func_addr, name, 0 as depth
    FROM funcs WHERE name = 'main'

    UNION ALL

    -- Recursive case: follow calls
    SELECT f.address, f.name, cg.depth + 1
    FROM call_graph cg
    JOIN disasm_calls dc ON dc.func_addr = cg.func_addr
    JOIN funcs f ON f.address = dc.callee_addr
    WHERE cg.depth < 5
      AND dc.callee_addr != 0  -- Skip indirect calls
)
SELECT DISTINCT func_addr, name, MIN(depth) as min_depth
FROM call_graph
GROUP BY func_addr
ORDER BY min_depth, name;
```

```sql
-- Reverse call graph: who calls this function (transitive)
WITH RECURSIVE callers AS (
    -- Base: direct callers of target
    SELECT DISTINCT dc.func_addr, 1 as depth
    FROM disasm_calls dc
    WHERE dc.callee_addr = 0x401000

    UNION ALL

    -- Recursive: who calls the callers
    SELECT DISTINCT dc.func_addr, c.depth + 1
    FROM callers c
    JOIN disasm_calls dc ON dc.callee_addr = c.func_addr
    WHERE c.depth < 5
)
SELECT func_at(func_addr) as caller, MIN(depth) as distance
FROM callers
GROUP BY func_addr
ORDER BY distance, caller;
```

### Window Functions

```sql
-- Rank functions by size within each segment
SELECT
    segment_at(f.address) as seg,
    f.name,
    f.size,
    ROW_NUMBER() OVER (PARTITION BY segment_at(f.address) ORDER BY f.size DESC) as rank
FROM funcs f
WHERE f.size > 0;
```

```sql
-- Running total of function sizes
SELECT
    name,
    size,
    SUM(size) OVER (ORDER BY address) as cumulative_size
FROM funcs
ORDER BY address;
```

```sql
-- Find consecutive functions with similar sizes (possible duplicates)
SELECT
    name,
    size,
    LAG(name) OVER (ORDER BY size) as prev_name,
    LAG(size) OVER (ORDER BY size) as prev_size
FROM funcs
WHERE size > 100;
```

### Complex JOINs

#### Multi-Table Join (Functions with Context)

```sql
-- Function overview with all relationships
SELECT
    f.name,
    f.size,
    segment_at(f.address) as segment,
    (SELECT COUNT(*) FROM blocks WHERE func_ea = f.address) as block_count,
    (SELECT COUNT(*) FROM disasm_calls WHERE func_addr = f.address) as outgoing_calls,
    (SELECT COUNT(*) FROM xrefs WHERE to_ea = f.address AND is_code = 1) as incoming_calls,
    (SELECT COUNT(*) FROM ctree_lvars WHERE func_addr = f.address) as local_vars
FROM funcs f
ORDER BY f.size DESC
LIMIT 20;
```

#### Self-Join (Compare Functions)

```sql
-- Find functions with identical sizes (potential clones)
SELECT
    f1.name as func1,
    f2.name as func2,
    f1.size
FROM funcs f1
JOIN funcs f2 ON f1.size = f2.size AND f1.address < f2.address
WHERE f1.size > 50  -- Ignore tiny functions
ORDER BY f1.size DESC;
```

### Subqueries

```sql
-- Functions that call more APIs than average
SELECT f.name, call_count
FROM (
    SELECT func_addr, COUNT(*) as call_count
    FROM disasm_calls dc
    JOIN imports i ON dc.callee_addr = i.address
    GROUP BY func_addr
) sub
JOIN funcs f ON f.address = sub.func_addr
WHERE call_count > (
    SELECT AVG(cnt) FROM (
        SELECT COUNT(*) as cnt
        FROM disasm_calls dc
        JOIN imports i ON dc.callee_addr = i.address
        GROUP BY func_addr
    )
)
ORDER BY call_count DESC;
```

### CASE Expressions

```sql
-- Categorize functions by complexity
SELECT
    name,
    size,
    CASE
        WHEN size < 50 THEN 'tiny'
        WHEN size < 200 THEN 'small'
        WHEN size < 1000 THEN 'medium'
        WHEN size < 5000 THEN 'large'
        ELSE 'huge'
    END as category
FROM funcs
ORDER BY size DESC;
```

```sql
-- Classify strings by content
SELECT
    content,
    CASE
        WHEN content LIKE '%error%' OR content LIKE '%fail%' THEN 'error'
        WHEN content LIKE '%password%' OR content LIKE '%key%' THEN 'sensitive'
        WHEN content LIKE '%http%' OR content LIKE '%://% ' THEN 'url'
        WHEN content LIKE '%.dll%' OR content LIKE '%.exe%' THEN 'file'
        ELSE 'other'
    END as category
FROM strings
WHERE length > 5;
```

### Batch Analysis with UNION ALL

```sql
-- Comprehensive security audit in one query
SELECT 'dangerous_func' as check_type, func_at(func_addr) as location, callee_name as detail
FROM disasm_calls
WHERE callee_name IN ('strcpy', 'strcat', 'sprintf', 'gets', 'scanf')

UNION ALL

SELECT 'crypto_usage', func_at(func_addr), callee_name
FROM disasm_calls)PROMPT"
    R"PROMPT(WHERE callee_name LIKE '%Crypt%' OR callee_name LIKE '%AES%' OR callee_name LIKE '%RSA%'

UNION ALL

SELECT 'network_call', func_at(func_addr), callee_name
FROM disasm_calls
WHERE callee_name IN ('socket', 'connect', 'send', 'recv', 'WSAStartup')

UNION ALL

SELECT 'registry_access', func_at(func_addr), callee_name
FROM disasm_calls
WHERE callee_name LIKE 'Reg%'

ORDER BY check_type, location;
```

### Efficient Pagination

```sql
-- Page through large result sets efficiently
SELECT * FROM (
    SELECT
        f.name,
        f.size,
        ROW_NUMBER() OVER (ORDER BY f.size DESC) as row_num
    FROM funcs f
)
WHERE row_num BETWEEN 101 AND 200;  -- Page 2 (100 per page)
```

### EXISTS for Efficient Filtering

```sql
-- Functions that have at least one string reference (more efficient than JOIN + DISTINCT)
SELECT f.name
FROM funcs f
WHERE EXISTS (
    SELECT 1 FROM xrefs x
    JOIN strings s ON x.to_ea = s.address
    WHERE x.from_ea BETWEEN f.address AND f.end_ea
);
```

```sql
-- Functions without any calls (leaf functions, EXISTS version)
SELECT f.name, f.size
FROM funcs f
WHERE NOT EXISTS (
    SELECT 1 FROM disasm_calls dc
    WHERE dc.func_addr = f.address
)
ORDER BY f.size DESC;
```

---

## Hex Address Formatting

IDA uses integer addresses. For display, use `printf()`:

```sql
-- 32-bit format
SELECT printf('0x%08X', address) as addr FROM funcs;

-- 64-bit format
SELECT printf('0x%016llX', address) as addr FROM funcs;

-- Auto-width
SELECT printf('0x%X', address) as addr FROM funcs;
```

---

## Common x86 Instruction Types

When filtering by `itype` (faster than string comparison):

| itype | Mnemonic | Description |
|-------|----------|-------------|
| 16 | call (near) | Direct call |
| 18 | call (indirect) | Indirect call |
| 122 | mov | Move data |
| 143 | push | Push to stack |
| 134 | pop | Pop from stack |
| 159 | retn | Return |
| 85 | jz | Jump if zero |
| 79 | jnz | Jump if not zero |
| 27 | cmp | Compare |
| 103 | nop | No operation |

---

## ctree Operation Names

Common Hex-Rays AST node types:

**Expressions (cot_*):**
- `cot_call` - Function call
- `cot_var` - Local variable
- `cot_obj` - Global object/function
- `cot_num` - Numeric constant
- `cot_str` - String literal
- `cot_ptr` - Pointer dereference
- `cot_ref` - Address-of
- `cot_asg` - Assignment
- `cot_add`, `cot_sub`, `cot_mul`, `cot_sdiv`, `cot_udiv` - Arithmetic
- `cot_eq`, `cot_ne`, `cot_lt`, `cot_gt` - Comparisons
- `cot_land`, `cot_lor`, `cot_lnot` - Logical
- `cot_band`, `cot_bor`, `cot_xor` - Bitwise

**Statements (cit_*):**
- `cit_if` - If statement
- `cit_for` - For loop
- `cit_while` - While loop
- `cit_do` - Do-while loop
- `cit_return` - Return statement
- `cit_block` - Code block

---

## Error Handling

- **No Hex-Rays license:** Decompiler tables (`pseudocode`, `ctree*`, `ctree_lvars`) will be empty or unavailable
- **No constraint on decompiler tables:** Query will be extremely slow (decompiles all functions)
- **Invalid address:** Functions like `func_at(addr)` return NULL
- **Missing function:** JOINs may return fewer rows than expected

---

## Quick Start Examples

### "What does this binary do?"

```sql
-- Entry points
SELECT * FROM entries;

-- Imported APIs (hints at functionality)
SELECT module, name FROM imports ORDER BY module, name;

-- Interesting strings
SELECT content FROM strings WHERE length > 10 ORDER BY length DESC LIMIT 20;
```

### "Find security-relevant code"

```sql
-- Dangerous string functions
SELECT DISTINCT func_at(func_addr) FROM disasm_calls
WHERE callee_name IN ('strcpy', 'strcat', 'sprintf', 'gets');

-- Crypto-related
SELECT * FROM imports WHERE name LIKE '%Crypt%' OR name LIKE '%Hash%';

-- Network-related
SELECT * FROM imports WHERE name LIKE '%socket%' OR name LIKE '%connect%' OR name LIKE '%send%';
```

### "Understand a specific function"

```sql
-- Basic info
SELECT * FROM funcs WHERE address = 0x401000;

-- Decompile (if Hex-Rays available)
SELECT decompile(0x401000);

-- Local variables
SELECT name, type, size FROM ctree_lvars WHERE func_addr = 0x401000;

-- What it calls
SELECT callee_name FROM disasm_calls WHERE func_addr = 0x401000;

-- What calls it
SELECT func_at(from_ea) FROM xrefs WHERE to_ea = 0x401000 AND is_code = 1;
```

### "Find all uses of a string"

```sql
SELECT s.content, func_at(x.from_ea) as function, printf('0x%X', x.from_ea) as location
FROM strings s
JOIN xrefs x ON s.address = x.to_ea
WHERE s.content LIKE '%config%';
```

---

## Natural Language Query Examples

These examples show how to translate common user questions into SQL.

### Function Signature Queries

**"Show me functions that return integers"**
```sql
-- Using funcs table (recommended - direct and fast)
SELECT name, return_type, arg_count FROM funcs
WHERE return_is_integral = 1
LIMIT 20;

-- Or via types_func_args (for typedef-aware queries)
SELECT DISTINCT type_name FROM types_func_args
WHERE arg_index = -1 AND is_integral_resolved = 1;
```

**"Show me functions that take 4 string arguments"**
```sql
-- String = char* or wchar_t*
SELECT type_name, COUNT(*) as string_args
FROM types_func_args
WHERE arg_index >= 0
  AND is_ptr_resolved = 1
  AND base_type_resolved IN ('char', 'wchar_t', 'CHAR', 'WCHAR')
GROUP BY type_ordinal
HAVING string_args = 4;
```

**"Which functions return pointers?"**
```sql
SELECT name, return_type FROM funcs
WHERE return_is_ptr = 1
ORDER BY name LIMIT 20;
```

**"Find void functions with many arguments"**
```sql
SELECT name, arg_count FROM funcs
WHERE return_is_void = 1 AND arg_count >= 4
ORDER BY arg_count DESC;
```

**"What calling conventions are used?"**
```sql
SELECT calling_conv, COUNT(*) as count
FROM funcs
WHERE calling_conv IS NOT NULL AND calling_conv != ''
GROUP BY calling_conv ORDER BY count DESC;
```

### Return Value Analysis

**"Which functions return 0?"**
```sql
SELECT DISTINCT f.name FROM funcs f
JOIN ctree_v_returns r ON r.func_addr = f.address
WHERE r.return_num = 0;
```

**"Find functions that return -1 (error pattern)"**
```sql
SELECT DISTINCT f.name FROM funcs f
JOIN ctree_v_returns r ON r.func_addr = f.address
WHERE r.return_num = -1;
```

**"Functions that return their input argument"**
```sql
SELECT DISTINCT f.name FROM funcs f
JOIN ctree_v_returns r ON r.func_addr = f.address
WHERE r.returns_arg = 1;
```

**"Functions that return the result of another call (wrappers)"**
```sql
SELECT DISTINCT f.name FROM funcs f
JOIN ctree_v_returns r ON r.func_addr = f.address
WHERE r.returns_call_result = 1;
```

**"Functions with multiple return statements"**
```sql
SELECT f.name, COUNT(*) as return_count
FROM funcs f
JOIN ctree_v_returns r ON r.func_addr = f.address
GROUP BY f.address
HAVING return_count > 1
ORDER BY return_count DESC LIMIT 20;
```

### Type Analysis

**"Find typedefs that hide pointers (like HANDLE)"**
```sql
SELECT DISTINCT type_name, arg_type, base_type_resolved
FROM types_func_args
WHERE is_ptr = 0 AND is_ptr_resolved = 1;
```

**"Functions with struct parameters"**
```sql
SELECT type_name, arg_name, arg_type FROM types_func_args
WHERE arg_index >= 0 AND is_struct = 1;
```

### Combined Queries

**"Integer-returning functions with 3+ args that return specific values"**
```sql
SELECT f.name, f.return_type, f.arg_count, r.return_num
FROM funcs f
JOIN ctree_v_returns r ON r.func_addr = f.address
WHERE f.return_is_integral = 1
  AND f.arg_count >= 3
  AND r.return_num IS NOT NULL
ORDER BY r.return_num;
```

**"Fastcall functions that return pointers"**
```sql
SELECT name, return_type, arg_count FROM funcs
WHERE calling_conv = 'fastcall' AND return_is_ptr = 1;
```

---

## Summary: When to Use What

| Goal | Table/Function |
|------|----------------|
| List all functions | `funcs` |
| Functions by return type | `funcs WHERE return_is_integral = 1` |
| Functions by arg count | `funcs WHERE arg_count >= N` |
| Void functions | `funcs WHERE return_is_void = 1` |
| Pointer-returning functions | `funcs WHERE return_is_ptr = 1` |
| Functions by calling convention | `funcs WHERE calling_conv = 'fastcall'` |
| Find who calls what | `xrefs` with `is_code = 1` |
| Find data references | `xrefs` with `is_code = 0` |
| Analyze imports | `imports` |
| Find strings | `strings` |
| Configure string types | `rebuild_strings(types, minlen)` |
| Instruction analysis | `instructions WHERE func_addr = X` |
| View decompiled code | `decompile(addr)` |
| Edit decompiler comments | `UPDATE pseudocode SET comment = '...' WHERE func_addr = X AND ea = Y` |
| AST pattern matching | `ctree WHERE func_addr = X` |
| Call patterns | `ctree_v_calls`, `disasm_calls` |
| Control flow | `ctree_v_loops`, `ctree_v_ifs` |
| Return value analysis | `ctree_v_returns` |
| Functions returning specific values | `ctree_v_returns WHERE return_num = 0` |
| Pass-through functions | `ctree_v_returns WHERE returns_arg = 1` |
| Wrapper functions | `ctree_v_returns WHERE returns_call_result = 1` |
| Variable analysis | `ctree_lvars WHERE func_addr = X` |
| Type information | `types`, `types_members` |
| Function signatures | `types_func_args` (with type classification) |
| Functions by return type | `types_func_args WHERE arg_index = -1` |
| Typedef-aware type queries | `types_func_args` (surface vs resolved) |
| Hidden pointer types | `types_func_args WHERE is_ptr = 0 AND is_ptr_resolved = 1` |
| Manage breakpoints | `breakpoints` (full CRUD) |
| Modify segments | `segments` (UPDATE name/class/perm, DELETE) |
| Delete instructions | `instructions` (DELETE converts to unexplored bytes) |
| Create types | `types` (INSERT struct/union/enum) |
| Add struct members | `types_members` (INSERT) |
| Add enum values | `types_enum_values` (INSERT) |
| Modify database | `funcs`, `names`, `comments`, `bookmarks` (INSERT/UPDATE/DELETE) |
| Jump to Anything | `jump_entities('pattern', 'mode')` |
| Entity search (JSON) | `jump_search('pattern', 'mode', limit, offset)` |

**Remember:** Always use `func_addr = X` constraints on instruction and decompiler tables for acceptable performance.

---

## Server Modes

IDASQL supports two server protocols for remote queries: **HTTP REST** (recommended) and raw TCP.

---

### HTTP REST Server (Recommended)

Standard REST API that works with curl, any HTTP client, or LLM tools.

**Starting the server:**
```bash
# Default port 8081
idasql -s database.i64 --http

# Custom port and bind address
idasql -s database.i64 --http 9000 --bind 0.0.0.0

# With authentication
idasql -s database.i64 --http 8081 --token mysecret
```

**HTTP Endpoints:**

| Endpoint | Method | Auth | Description |
|----------|--------|------|-------------|
| `/` | GET | No | Welcome message |
| `/help` | GET | No | API documentation (for LLM discovery) |
| `/query` | POST | Yes* | Execute SQL (body = raw SQL) |
| `/status` | GET | Yes* | Health check |
| `/shutdown` | POST | Yes* | Stop server |

*Auth required only if `--token` was specified.

**Example with curl:**
```bash
# Get API documentation
curl http://localhost:8081/help

# Execute SQL query
curl -X POST http://localhost:8081/query -d "SELECT name, size FROM funcs LIMIT 5"

# With authentication
curl -X POST http://localhost:8081/query \
     -H "Authorization: Bearer mysecret" \
     -d "SELECT * FROM funcs"

# Check status
curl http://localhost:8081/status
```

**Response Format (JSON):**
```json
{"success": true, "columns": ["name", "size"], "rows": [["main", "500"]], "row_count": 1}
```

```json
{"success": false, "error": "no such table: bad_table"}
```

---

### Raw TCP Server (Legacy)

Binary protocol with length-prefixed JSON. Use only when HTTP is not available.

**Starting the server:**
```bash
idasql -s database.i64 --server 13337
idasql -s database.i64 --server 13337 --token mysecret
```

**Connecting as client:**
```bash
idasql --remote localhost:13337 -q "SELECT name FROM funcs LIMIT 5"
idasql --remote localhost:13337 -i
```
)PROMPT";

} // namespace idasql

```

`src/common/idasql_cli.hpp`:

```hpp
#pragma once

/**
 * IdasqlCLI - IDA plugin command line interface
 *
 * Wraps SessionHandler and provides cli_t integration for IDA.
 * The actual query processing logic is in SessionHandler (testable without IDA).
 *
 * Usage:
 *   IdasqlCLI cli(executor);
 *   cli.install();  // Register with IDA
 *   // ... plugin lifetime ...
 *   cli.uninstall();  // Unregister on shutdown
 */

#include <string>
#include <functional>
#include <memory>
#include <kernwin.hpp>

#include "session_handler.hpp"

namespace idasql {

class IdasqlCLI
{
public:
    using SqlExecutor = std::function<std::string(const std::string&)>;

    explicit IdasqlCLI(SqlExecutor executor, bool enable_agent = true)
        : session_(std::move(executor), enable_agent)
    {
        // Override clear_session callback to add IDA-specific behavior
        session_.callbacks().clear_session = [this]() {
            return clear_session();
        };
    }

    ~IdasqlCLI()
    {
        uninstall();
    }

    // Non-copyable
    IdasqlCLI(const IdasqlCLI&) = delete;
    IdasqlCLI& operator=(const IdasqlCLI&) = delete;

    /**
     * Install the CLI with IDA
     */
    bool install()
    {
        if (installed_) return true;

        // Store pointer for static callback
        s_instance_ = this;

        // Setup cli_t structure
        cli_.size = sizeof(cli_t);
        cli_.flags = 0;
        cli_.sname = "idasql";
        cli_.lname = session_.is_agent_enabled()
            ? "idasql - SQL queries with AI agent support"
            : "idasql - SQL interface to IDA database";
        cli_.hint = "Enter SQL query, .command, or natural language";
        cli_.execute_line = &IdasqlCLI::execute_line_cb;
        cli_.keydown = nullptr;
        cli_.find_completions = nullptr;

        install_command_interpreter(&cli_);
        installed_ = true;
        msg("IDASQL CLI: Installed (AI agent: %s)\n",
            session_.is_agent_enabled() ? "enabled" : "disabled");
        return true;
    }

    /**
     * Uninstall the CLI from IDA
     */
    void uninstall()
    {
        if (!installed_) return;

        session_.end_session();
        remove_command_interpreter(&cli_);
        installed_ = false;
        s_instance_ = nullptr;

        msg("IDASQL CLI: Uninstalled\n");
    }

    bool is_installed() const { return installed_; }
    bool is_agent_enabled() const { return session_.is_agent_enabled(); }

    /**
     * Clear session - clears IDA message window and resets AI agent
     */
    std::string clear_session()
    {
        // Clear IDA's message window
        msg_clear();

        // Clear the AI agent session
        std::string result = session_.clear_session();

        // Print status to fresh message window
        msg("IDASQL: %s\n", result.c_str());

        return result;
    }

    /**
     * Process a line of input (delegates to SessionHandler)
     */
    std::string process_line(const std::string& line)
    {
        return session_.process_line(line);
    }

    /**
     * Get the underlying session handler (for testing)
     */
    SessionHandler& session() { return session_; }
    const SessionHandler& session() const { return session_; }

private:
    SessionHandler session_;
    cli_t cli_{};
    bool installed_ = false;

    // Static instance for callback
    static IdasqlCLI* s_instance_;

    // Static callback for cli_t
    static bool idaapi execute_line_cb(const char* line)
    {
        if (!s_instance_ || !line) return true;

        std::string result = s_instance_->process_line(line);
        if (!result.empty()) {
            msg("%s\n", result.c_str());
        }

        return true;  // Line was executed
    }
};

// Static member definition
inline IdasqlCLI* IdasqlCLI::s_instance_ = nullptr;

} // namespace idasql

```

`src/common/idasql_commands.hpp`:

```hpp
#pragma once

#include <functional>
#include <string>
#include <sstream>

#ifdef IDASQL_HAS_AI_AGENT
#include "agent_settings.hpp"
#endif

namespace idasql {

/**
 * Command handler result
 */
enum class CommandResult {
    NOT_HANDLED,  // Not a command, process as query
    HANDLED,      // Command executed successfully
    QUIT          // User requested quit
};

/**
 * Command handler callbacks
 *
 * These callbacks allow different environments (CLI, plugin) to extend
 * command behavior. For example, .clear might:
 *   - Core: Reset the AI agent session
 *   - Plugin: Also call msg_clear() to clear IDA's message window
 */
struct CommandCallbacks {
    std::function<std::string()> get_tables;      // Return table list
    std::function<std::string(const std::string&)> get_schema;  // Return schema for table
    std::function<std::string()> get_info;        // Return database info
    std::function<std::string()> clear_session;   // Clear/reset session (agent, UI, etc.)

    // MCP server callbacks (optional - plugin only)
    std::function<std::string()> mcp_status;      // Get MCP status
    std::function<std::string(int, const std::string&)> mcp_start;  // Start MCP server (port, bind_addr)
    std::function<std::string()> mcp_stop;        // Stop MCP server

    // HTTP server callbacks (optional)
    std::function<std::string()> http_status;     // Get HTTP server status
    std::function<std::string(int, const std::string&)> http_start;  // Start HTTP server (port, bind_addr)
    std::function<std::string()> http_stop;       // Stop HTTP server
};

/**
 * Handle dot commands (.tables, .schema, .help, .quit, etc.)
 *
 * @param input User input line
 * @param callbacks Callbacks to execute commands
 * @param output Output string (filled if command produces output)
 * @return CommandResult indicating how to proceed
 */
inline CommandResult handle_command(
    const std::string& input,
    const CommandCallbacks& callbacks,
    std::string& output)
{
    if (input.empty() || input[0] != '.') {
        return CommandResult::NOT_HANDLED;
    }

    if (input == ".quit" || input == ".exit") {
        return CommandResult::QUIT;
    }

    if (input == ".tables") {
        if (callbacks.get_tables) {
            output = callbacks.get_tables();
        }
        return CommandResult::HANDLED;
    }

    if (input == ".info") {
        if (callbacks.get_info) {
            output = callbacks.get_info();
        }
        return CommandResult::HANDLED;
    }

    if (input == ".clear") {
        if (callbacks.clear_session) {
            output = callbacks.clear_session();
        } else {
            output = "Session cleared";
        }
        return CommandResult::HANDLED;
    }

    if (input == ".help") {
        output = "IDASQL Commands:\n"
                 "  .tables         List all tables\n"
                 "  .schema <table> Show table schema\n"
                 "  .info           Show database info\n"
                 "  .clear          Clear/reset session\n"
                 "  .quit / .exit   Exit\n"
                 "  .help           Show this help\n"
#ifdef IDASQL_HAS_AI_AGENT
                 "\n"
                 "MCP Server:\n"
                 "  .mcp                    Show status or start if not running\n"
                 "  .mcp start [bind] [port] Start MCP server\n"
                 "  .mcp stop               Stop MCP server\n"
                 "  .mcp help               Show MCP help\n"
#endif
                 "\n"
                 "HTTP Server:\n"
                 "  .http                    Show status or start if not running\n"
                 "  .http start [bind] [port] Start HTTP server\n"
                 "  .http stop               Stop HTTP server\n"
                 "  .http help               Show HTTP help\n"
                 "\n"
                 "SQL:\n"
                 "  SELECT * FROM funcs LIMIT 10;\n"
                 "  SELECT name, size FROM funcs ORDER BY size DESC;\n"
#ifdef IDASQL_HAS_AI_AGENT
                 "\n"
                 "AI Agent:\n"
                 "  .agent help       Show agent commands\n"
                 "  .agent provider   Show/set AI provider\n"
                 "  .agent clear      Clear conversation\n"
                 "\n"
                 "Natural Language:\n"
                 "  Find the largest functions\n"
                 "  Show functions that call malloc\n"
                 "  What imports does this binary use?\n"
#endif
                 ;
        return CommandResult::HANDLED;
    }

    // .mcp commands (MCP server control - plugin only)
    if (input.rfind(".mcp", 0) == 0) {
#ifdef IDASQL_HAS_AI_AGENT
        std::string subargs = input.length() > 4 ? input.substr(4) : "";
        // Trim leading whitespace
        size_t start = subargs.find_first_not_of(" \t");
        if (start != std::string::npos)
            subargs = subargs.substr(start);

        if (subargs.empty()) {
            // .mcp - show status, start if not running
            if (callbacks.mcp_status) {
                output = callbacks.mcp_status();
            } else {
                output = "MCP server not available (plugin mode only)";
            }
        }
        else if (subargs.rfind("start", 0) == 0) {
            int port = 0;
            std::string bind_addr = "127.0.0.1";
            // Parse optional: "start [bind] [port]"
            std::string rest = subargs.length() > 5 ? subargs.substr(5) : "";
            size_t rs = rest.find_first_not_of(" \t");
            if (rs != std::string::npos) {
                rest = rest.substr(rs);
                // Split into tokens
                std::string tok1, tok2;
                size_t sp = rest.find_first_of(" \t");
                if (sp != std::string::npos) {
                    tok1 = rest.substr(0, sp);
                    size_t t2s = rest.find_first_not_of(" \t", sp);
                    if (t2s != std::string::npos) tok2 = rest.substr(t2s);
                } else {
                    tok1 = rest;
                }
                // Heuristic: if tok1 is all digits, treat as port; otherwise bind_addr
                bool tok1_numeric = !tok1.empty() && tok1.find_first_not_of("0123456789") == std::string::npos;
                if (tok1_numeric) {
                    port = std::stoi(tok1);
                } else {
                    bind_addr = tok1;
                    if (!tok2.empty()) port = std::stoi(tok2);
                }
            }
            if (callbacks.mcp_start) {
                output = callbacks.mcp_start(port, bind_addr);
            } else {
                output = "MCP server not available (plugin mode only)";
            }
        }
        else if (subargs == "stop") {
            if (callbacks.mcp_stop) {
                output = callbacks.mcp_stop();
            } else {
                output = "MCP server not available (plugin mode only)";
            }
        }
        else if (subargs == "help") {
            output = "MCP Server Commands:\n"
                     "  .mcp                     Show status, start if not running\n"
                     "  .mcp start [bind] [port]  Start MCP server (default: 127.0.0.1, random port)\n"
                     "  .mcp stop                Stop MCP server\n"
                     "  .mcp help                Show this help\n"
                     "\n"
                     "The MCP server exposes two tools:\n"
                     "  idasql_query  - Execute SQL query directly\n"
                     "  idasql_agent  - Ask natural language question (AI-powered)\n"
                     "\n"
                     "Connect with Claude Desktop by adding to config:\n"
                     "  {\"mcpServers\": {\"idasql\": {\"url\": \"http://127.0.0.1:<port>/sse\"}}}\n";
        }
        else {
            output = "Unknown MCP command: " + subargs + "\nUse '.mcp help' for available commands.";
        }
#else
        output = "MCP server requires AI agent support. Rebuild with -DIDASQL_WITH_AI_AGENT=ON";
#endif
        return CommandResult::HANDLED;
    }

    // .http commands (HTTP server control)
    if (input.rfind(".http", 0) == 0) {
        std::string subargs = input.length() > 5 ? input.substr(5) : "";
        // Trim leading whitespace
        size_t start = subargs.find_first_not_of(" \t");
        if (start != std::string::npos)
            subargs = subargs.substr(start);

        if (subargs.empty()) {
            // .http - show status, start if not running
            if (callbacks.http_status) {
                output = callbacks.http_status();
            } else {
                output = "HTTP server not available";
            }
        }
        else if (subargs.rfind("start", 0) == 0) {
            int port = 0;
            std::string bind_addr = "127.0.0.1";
            // Parse optional: "start [bind] [port]"
            std::string rest = subargs.length() > 5 ? subargs.substr(5) : "";
            size_t rs = rest.find_first_not_of(" \t");
            if (rs != std::string::npos) {
                rest = rest.substr(rs);
                // Split into tokens
                std::string tok1, tok2;
                size_t sp = rest.find_first_of(" \t");
                if (sp != std::string::npos) {
                    tok1 = rest.substr(0, sp);
                    size_t t2s = rest.find_first_not_of(" \t", sp);
                    if (t2s != std::string::npos) tok2 = rest.substr(t2s);
                } else {
                    tok1 = rest;
                }
                // Heuristic: if tok1 is all digits, treat as port; otherwise bind_addr
                bool tok1_numeric = !tok1.empty() && tok1.find_first_not_of("0123456789") == std::string::npos;
                if (tok1_numeric) {
                    port = std::stoi(tok1);
                } else {
                    bind_addr = tok1;
                    if (!tok2.empty()) port = std::stoi(tok2);
                }
            }
            if (callbacks.http_start) {
                output = callbacks.http_start(port, bind_addr);
            } else {
                output = "HTTP server not available";
            }
        }
        else if (subargs == "stop") {
            if (callbacks.http_stop) {
                output = callbacks.http_stop();
            } else {
                output = "HTTP server not available";
            }
        }
        else if (subargs == "help") {
            output = "HTTP Server Commands:\n"
                     "  .http                     Show status, start if not running\n"
                     "  .http start [bind] [port]  Start HTTP server (default: 127.0.0.1, random port)\n"
                     "  .http stop                Stop HTTP server\n"
                     "  .http help                Show this help\n"
                     "\n"
                     "Endpoints:\n"
                     "  GET  /help       API documentation\n"
                     "  POST /query      Execute SQL (body = raw SQL)\n"
                     "  GET  /status     Health check\n"
                     "  POST /shutdown   Stop server\n"
                     "\n"
                     "Example:\n"
                     "  curl -X POST http://127.0.0.1:<port>/query -d \"SELECT name FROM funcs LIMIT 5\"\n";
        }
        else {
            output = "Unknown HTTP command: " + subargs + "\nUse '.http help' for available commands.";
        }
        return CommandResult::HANDLED;
    }

    // .agent commands
    if (input.rfind(".agent", 0) == 0) {
#ifdef IDASQL_HAS_AI_AGENT
        std::string subargs = input.length() > 6 ? input.substr(6) : "";
        // Trim leading whitespace
        size_t start = subargs.find_first_not_of(" \t");
        if (start != std::string::npos)
            subargs = subargs.substr(start);

        // Parse subcmd and value
        std::string subcmd, value;
        size_t space = subargs.find(' ');
        if (space != std::string::npos) {
            subcmd = subargs.substr(0, space);
            value = subargs.substr(space + 1);
            size_t val_start = value.find_first_not_of(" \t");
            if (val_start != std::string::npos)
                value = value.substr(val_start);
        } else {
            subcmd = subargs;
        }

        auto settings = LoadAgentSettings();
        std::string provider_name = libagents::provider_type_name(settings.default_provider);

        if (subcmd.empty() || subcmd == "help") {
            output = "Agent Commands:\n"
                     "  .agent help               Show this help\n"
                     "  .agent provider           Show current provider\n"
                     "  .agent provider NAME      Switch provider (claude, copilot)\n"
                     "  .agent clear              Clear conversation\n"
                     "  .agent timeout            Show response timeout\n"
                     "  .agent timeout MS         Set response timeout in milliseconds\n"
                     "  .agent byok               Show BYOK status\n"
                     "  .agent byok enable        Enable BYOK\n"
                     "  .agent byok disable       Disable BYOK\n"
                     "  .agent byok key VALUE     Set API key\n"
                     "  .agent byok endpoint URL  Set API endpoint\n"
                     "  .agent byok model NAME    Set model name\n"
                     "  .agent byok type TYPE     Set provider type (openai, anthropic, azure)\n"
                     "\nCurrent provider: " + provider_name + "\n";
        }
        else if (subcmd == "provider") {
            if (value.empty()) {
                output = "Current provider: " + provider_name + "\n"
                         "\nAvailable providers:\n"
                         "  claude   - Claude Code (Anthropic)\n"
                         "  copilot  - GitHub Copilot\n";
            } else {
                try {
                    auto type = ParseProviderType(value);
                    settings.default_provider = type;
                    SaveAgentSettings(settings);
                    output = "Provider set to: " + std::string(libagents::provider_type_name(type)) +
                             " (saved to settings)\n"
                             "Note: Restart agent session for changes to take effect.\n";
                } catch (const std::exception& e) {
                    output = std::string("Error: ") + e.what() + "\n"
                             "Available providers: claude, copilot\n";
                }
            }
        }
        else if (subcmd == "clear") {
            if (callbacks.clear_session) {
                output = callbacks.clear_session();
            } else {
                output = "Session cleared";
            }
        }
        else if (subcmd == "timeout") {
            if (value.empty()) {
                output = "Response timeout: " + std::to_string(settings.response_timeout_ms) + " ms (" +
                         std::to_string(settings.response_timeout_ms / 1000) + " seconds)\n";
            } else {
                try {
                    int ms = std::stoi(value);
                    if (ms < 1000) {
                        output = "Error: Timeout must be at least 1000 ms (1 second).\n";
                    } else {
                        settings.response_timeout_ms = ms;
                        SaveAgentSettings(settings);
                        output = "Timeout set to " + std::to_string(ms) + " ms (" +
                                 std::to_string(ms / 1000) + " seconds).\n";
                    }
                } catch (...) {
                    output = "Error: Invalid timeout value. Use milliseconds.\n";
                }
            }
        }
        else if (subcmd == "byok") {
            // Parse BYOK subcommand
            std::string byok_subcmd, byok_value;
            size_t byok_space = value.find(' ');
            if (byok_space != std::string::npos) {
                byok_subcmd = value.substr(0, byok_space);
                byok_value = value.substr(byok_space + 1);
                size_t bv_start = byok_value.find_first_not_of(" \t");
                if (bv_start != std::string::npos)
                    byok_value = byok_value.substr(bv_start);
            } else {
                byok_subcmd = value;
            }

            const BYOKSettings* byok = settings.get_byok();

            if (byok_subcmd.empty()) {
                std::stringstream ss;
                ss << "BYOK status for provider '" << provider_name << "':\n";
                if (byok) {
                    ss << "  Enabled:  " << (byok->enabled ? "yes" : "no") << "\n"
                       << "  API Key:  " << (byok->api_key.empty() ? "(not set)" : "********") << "\n"
                       << "  Endpoint: " << (byok->base_url.empty() ? "(default)" : byok->base_url) << "\n"
                       << "  Model:    " << (byok->model.empty() ? "(default)" : byok->model) << "\n"
                       << "  Type:     " << (byok->provider_type.empty() ? "(default)" : byok->provider_type) << "\n"
                       << "  Usable:   " << (byok->is_usable() ? "yes" : "no") << "\n";
                } else {
                    ss << "  (not configured)\n";
                }
                output = ss.str();
            }
            else if (byok_subcmd == "enable") {
                auto& b = settings.get_or_create_byok();
                b.enabled = true;
                SaveAgentSettings(settings);
                output = "BYOK enabled for provider '" + provider_name + "'.\n";
                if (b.api_key.empty()) {
                    output += "Warning: API key not set. Use '.agent byok key <value>' to set it.\n";
                }
            }
            else if (byok_subcmd == "disable") {
                auto& b = settings.get_or_create_byok();
                b.enabled = false;
                SaveAgentSettings(settings);
                output = "BYOK disabled for provider '" + provider_name + "'.\n";
            }
            else if (byok_subcmd == "key") {
                if (byok_value.empty()) {
                    output = "Error: API key value required.\n"
                             "Usage: .agent byok key <value>\n";
                } else {
                    auto& b = settings.get_or_create_byok();
                    b.api_key = byok_value;
                    SaveAgentSettings(settings);
                    output = "BYOK API key set for provider '" + provider_name + "'.\n";
                }
            }
            else if (byok_subcmd == "endpoint") {
                auto& b = settings.get_or_create_byok();
                b.base_url = byok_value;
                SaveAgentSettings(settings);
                output = byok_value.empty() ?
                    "BYOK endpoint cleared (using default).\n" :
                    "BYOK endpoint set to: " + byok_value + "\n";
            }
            else if (byok_subcmd == "model") {
                auto& b = settings.get_or_create_byok();
                b.model = byok_value;
                SaveAgentSettings(settings);
                output = byok_value.empty() ?
                    "BYOK model cleared (using default).\n" :
                    "BYOK model set to: " + byok_value + "\n";
            }
            else if (byok_subcmd == "type") {
                auto& b = settings.get_or_create_byok();
                b.provider_type = byok_value;
                SaveAgentSettings(settings);
                output = byok_value.empty() ?
                    "BYOK type cleared (using default).\n" :
                    "BYOK type set to: " + byok_value + "\n";
            }
            else {
                output = "Unknown byok subcommand: " + byok_subcmd + "\n"
                         "Use '.agent byok' to see available commands.\n";
            }
        }
        else {
            output = "Unknown agent subcommand: " + subcmd + "\n"
                     "Use '.agent help' for available commands.\n";
        }
#else
        output = "AI agent support not compiled in. Rebuild with -DIDASQL_WITH_AI_AGENT=ON\n";
#endif
        return CommandResult::HANDLED;
    }

    if (input.rfind(".schema", 0) == 0) {
        std::string table = input.length() > 8 ? input.substr(8) : "";
        // Trim leading whitespace
        size_t start = table.find_first_not_of(" \t");
        if (start != std::string::npos) {
            table = table.substr(start);
            // Trim trailing whitespace
            size_t end = table.find_last_not_of(" \t");
            if (end != std::string::npos) {
                table = table.substr(0, end + 1);
            }
        } else {
            table.clear();
        }

        if (table.empty()) {
            output = "Usage: .schema <table_name>";
        } else if (callbacks.get_schema) {
            output = callbacks.get_schema(table);
        }
        return CommandResult::HANDLED;
    }

    output = "Unknown command: " + input;
    return CommandResult::HANDLED;
}

/**
 * Handle --config CLI commands
 *
 * @param path Config path like "agent.provider" or "agent.byok.key"
 * @param value Value to set (empty = get current value)
 * @return tuple<success, output, exit_code>
 */
inline std::tuple<bool, std::string, int> handle_config_command(
    const std::string& path,
    const std::string& value)
{
#ifdef IDASQL_HAS_AI_AGENT
    auto settings = LoadAgentSettings();
    std::string provider_name = libagents::provider_type_name(settings.default_provider);
    std::stringstream ss;

    // Show all config
    if (path.empty()) {
        ss << "Settings: " << GetSettingsPath() << "\n\n";
        ss << "agent.provider:  " << provider_name << "\n";
        ss << "agent.timeout:   " << settings.response_timeout_ms << " ms\n";
        ss << "agent.prompt:    " << (settings.custom_prompt.empty() ? "(not set)" : "\"" + settings.custom_prompt + "\"") << "\n";
        ss << "\n";

        const BYOKSettings* byok = settings.get_byok();
        ss << "agent.byok (" << provider_name << "):\n";
        if (byok) {
            ss << "  enabled:   " << (byok->enabled ? "true" : "false") << "\n";
            ss << "  key:       " << (byok->api_key.empty() ? "(not set)" : "********") << "\n";
            ss << "  endpoint:  " << (byok->base_url.empty() ? "(default)" : byok->base_url) << "\n";
            ss << "  model:     " << (byok->model.empty() ? "(default)" : byok->model) << "\n";
            ss << "  type:      " << (byok->provider_type.empty() ? "(default)" : byok->provider_type) << "\n";
        } else {
            ss << "  (not configured)\n";
        }
        return {true, ss.str(), 0};
    }

    // Parse path
    std::vector<std::string> parts;
    std::string part;
    std::istringstream iss(path);
    while (std::getline(iss, part, '.')) {
        if (!part.empty()) parts.push_back(part);
    }

    if (parts.empty() || parts[0] != "agent") {
        return {false, "Error: Unknown config path: " + path + "\nUse --config to see available options.\n", 1};
    }

    // agent.*
    if (parts.size() == 1) {
        // Just "agent" - show agent settings
        ss << "agent.provider:  " << provider_name << "\n";
        ss << "agent.timeout:   " << settings.response_timeout_ms << " ms\n";
        ss << "agent.prompt:    " << (settings.custom_prompt.empty() ? "(not set)" : "\"" + settings.custom_prompt + "\"") << "\n";
        return {true, ss.str(), 0};
    }

    std::string key = parts[1];

    // agent.provider
    if (key == "provider") {
        if (value.empty()) {
            ss << "agent.provider = " << provider_name << "\n";
        } else {
            try {
                auto type = ParseProviderType(value);
                settings.default_provider = type;
                SaveAgentSettings(settings);
                ss << "agent.provider = " << libagents::provider_type_name(type) << " (saved)\n";
            } catch (const std::exception& e) {
                return {false, std::string("Error: ") + e.what() + "\n", 1};
            }
        }
        return {true, ss.str(), 0};
    }

    // agent.timeout
    if (key == "timeout") {
        if (value.empty()) {
            ss << "agent.timeout = " << settings.response_timeout_ms << " ms\n";
        } else {
            try {
                int ms = std::stoi(value);
                if (ms < 1000) {
                    return {false, "Error: Timeout must be at least 1000 ms.\n", 1};
                }
                settings.response_timeout_ms = ms;
                SaveAgentSettings(settings);
                ss << "agent.timeout = " << ms << " ms (saved)\n";
            } catch (...) {
                return {false, "Error: Invalid timeout value.\n", 1};
            }
        }
        return {true, ss.str(), 0};
    }

    // agent.prompt
    if (key == "prompt") {
        if (value.empty()) {
            ss << "agent.prompt = " << (settings.custom_prompt.empty() ? "(not set)" : "\"" + settings.custom_prompt + "\"") << "\n";
        } else {
            settings.custom_prompt = value;
            SaveAgentSettings(settings);
            ss << "agent.prompt = \"" << value << "\" (saved)\n";
        }
        return {true, ss.str(), 0};
    }

    // agent.byok.*
    if (key == "byok") {
        // Helper lambda to show BYOK status for a provider
        auto show_byok = [&ss](const std::string& pname, const BYOKSettings* byok) {
            ss << "agent.byok." << pname << ":\n";
            if (byok) {
                ss << "  enabled:   " << (byok->enabled ? "true" : "false") << "\n";
                ss << "  key:       " << (byok->api_key.empty() ? "(not set)" : "********") << "\n";
                ss << "  endpoint:  " << (byok->base_url.empty() ? "(default)" : byok->base_url) << "\n";
                ss << "  model:     " << (byok->model.empty() ? "(default)" : byok->model) << "\n";
                ss << "  type:      " << (byok->provider_type.empty() ? "(default)" : byok->provider_type) << "\n";
            } else {
                ss << "  (not configured)\n";
            }
        };

        // Helper lambda to get/set a BYOK field
        auto handle_byok_field = [&](BYOKSettings& byok, const std::string& field,
                                      const std::string& prefix) -> std::tuple<bool, std::string, int> {
            std::stringstream out;
            if (field == "enabled") {
                if (value.empty()) {
                    out << prefix << ".enabled = " << (byok.enabled ? "true" : "false") << "\n";
                } else {
                    byok.enabled = (value == "true" || value == "1" || value == "yes");
                    SaveAgentSettings(settings);
                    out << prefix << ".enabled = " << (byok.enabled ? "true" : "false") << " (saved)\n";
                }
                return {true, out.str(), 0};
            }
            if (field == "key") {
                if (value.empty()) {
                    out << prefix << ".key = " << (byok.api_key.empty() ? "(not set)" : "********") << "\n";
                } else {
                    byok.api_key = value;
                    SaveAgentSettings(settings);
                    out << prefix << ".key = ******** (saved)\n";
                }
                return {true, out.str(), 0};
            }
            if (field == "endpoint") {
                if (value.empty()) {
                    out << prefix << ".endpoint = " << (byok.base_url.empty() ? "(default)" : byok.base_url) << "\n";
                } else {
                    byok.base_url = value;
                    SaveAgentSettings(settings);
                    out << prefix << ".endpoint = " << value << " (saved)\n";
                }
                return {true, out.str(), 0};
            }
            if (field == "model") {
                if (value.empty()) {
                    out << prefix << ".model = " << (byok.model.empty() ? "(default)" : byok.model) << "\n";
                } else {
                    byok.model = value;
                    SaveAgentSettings(settings);
                    out << prefix << ".model = " << value << " (saved)\n";
                }
                return {true, out.str(), 0};
            }
            if (field == "type") {
                if (value.empty()) {
                    out << prefix << ".type = " << (byok.provider_type.empty() ? "(default)" : byok.provider_type) << "\n";
                } else {
                    byok.provider_type = value;
                    SaveAgentSettings(settings);
                    out << prefix << ".type = " << value << " (saved)\n";
                }
                return {true, out.str(), 0};
            }
            return {false, "Error: Unknown BYOK field: " + field + "\n", 1};
        };

        if (parts.size() == 2) {
            // "agent.byok" - show all providers' BYOK status
            auto it_claude = settings.byok.find("claude");
            auto it_copilot = settings.byok.find("copilot");
            show_byok("claude", it_claude != settings.byok.end() ? &it_claude->second : nullptr);
            ss << "\n";
            show_byok("copilot", it_copilot != settings.byok.end() ? &it_copilot->second : nullptr);
            return {true, ss.str(), 0};
        }

        std::string part2 = parts[2];

        // Check if part2 is a provider name (claude/copilot) or a field name
        if (part2 == "claude" || part2 == "copilot") {
            // agent.byok.<provider> or agent.byok.<provider>.<field>
            std::string target_provider = part2;

            if (parts.size() == 3) {
                // "agent.byok.copilot" - show this provider's BYOK
                auto it = settings.byok.find(target_provider);
                show_byok(target_provider, it != settings.byok.end() ? &it->second : nullptr);
                return {true, ss.str(), 0};
            }

            if (parts.size() == 4) {
                // "agent.byok.copilot.<field>" - get/set field
                std::string field = parts[3];
                auto& byok = settings.byok[target_provider];
                return handle_byok_field(byok, field, "agent.byok." + target_provider);
            }
        } else {
            // agent.byok.<field> - uses current provider
            auto& byok = settings.get_or_create_byok();
            return handle_byok_field(byok, part2, "agent.byok");
        }

        return {false, "Error: Unknown config path: " + path + "\n", 1};
    }

    return {false, "Error: Unknown config path: " + path + "\nUse --config to see available options.\n", 1};

#else
    return {false, "Error: AI agent not compiled in. Rebuild with -DIDASQL_WITH_AI_AGENT=ON\n", 1};
#endif
}

} // namespace idasql

```

`src/common/idasql_version.hpp`:

```hpp
#pragma once

#define IDASQL_VERSION_MAJOR 0
#define IDASQL_VERSION_MINOR 0
#define IDASQL_VERSION_PATCH 8
#define IDASQL_VERSION_STRING "0.0.8"

```

`src/common/json_utils.hpp`:

```hpp
#pragma once

#include <iomanip>
#include <sstream>
#include <string>

namespace idasql {

inline std::string escape_json(const std::string& input) {
    std::ostringstream oss;
    for (unsigned char c : input) {
        switch (c) {
            case '\"': oss << "\\\""; break;
            case '\\': oss << "\\\\"; break;
            case '\b': oss << "\\b"; break;
            case '\f': oss << "\\f"; break;
            case '\n': oss << "\\n"; break;
            case '\r': oss << "\\r"; break;
            case '\t': oss << "\\t"; break;
            default:
                if (c < 0x20) {
                    oss << "\\u"
                        << std::hex << std::uppercase << std::setfill('0')
                        << std::setw(4) << static_cast<int>(c);
                    // reset flags for subsequent writes
                    oss << std::dec;
                } else {
                    oss << static_cast<char>(c);
                }
                break;
        }
    }
    return oss.str();
}

} // namespace idasql

```

`src/common/mcp_server.cpp`:

```cpp
#include "mcp_server.hpp"

#include <fastmcpp/mcp/handler.hpp>
#include <fastmcpp/server/sse_server.hpp>
#include <fastmcpp/tools/manager.hpp>
#include <fastmcpp/tools/tool.hpp>
#include <nlohmann/json.hpp>

#include <chrono>
#include <random>
#include <sstream>

namespace idasql {

using Json = nlohmann::json;

class IDAMCPServer::Impl {
public:
    fastmcpp::tools::ToolManager tool_manager;
    std::unique_ptr<fastmcpp::server::SseServerWrapper> server;
};

IDAMCPServer::IDAMCPServer() = default;

IDAMCPServer::~IDAMCPServer() {
    stop();
}

MCPQueueResult IDAMCPServer::queue_and_wait(MCPPendingCommand::Type type, const std::string& input) {
    if (!running_.load()) {
        return {false, "Error: MCP server is not running"};
    }

    MCPPendingCommand cmd;
    cmd.type = type;
    cmd.input = input;
    cmd.completed = false;

    std::mutex done_mutex;
    std::condition_variable done_cv;
    cmd.done_mutex = &done_mutex;
    cmd.done_cv = &done_cv;

    {
        std::lock_guard<std::mutex> lock(queue_mutex_);
        pending_commands_.push(&cmd);
    }
    queue_cv_.notify_one();

    {
        std::unique_lock<std::mutex> lock(done_mutex);
        done_cv.wait(lock, [&]() { return cmd.completed || !running_.load(); });
    }

    if (!cmd.completed) {
        return {false, "Error: MCP server stopped"};
    }

    return {true, cmd.result};
}

int IDAMCPServer::start(int port, QueryCallback query_cb, AskCallback ask_cb,
                        const std::string& bind_addr, bool use_queue) {
    if (running_.load()) {
        return port_;
    }

    query_cb_ = query_cb;
    ask_cb_ = ask_cb;
    bind_addr_ = bind_addr;
    use_queue_.store(use_queue);

    // If port is 0, pick a random port in the 9000-9999 range
    if (port == 0) {
        std::random_device rd;
        std::mt19937 gen(rd());
        std::uniform_int_distribution<> dis(9000, 9999);
        port = dis(gen);
    }

    impl_ = std::make_unique<Impl>();

    // Register idasql_query tool - direct SQL execution
    Json query_input_schema = {
        {"type", "object"},
        {"properties", {
            {"query", {
                {"type", "string"},
                {"description", "SQL query to execute against the IDA database"}
            }}
        }},
        {"required", Json::array({"query"})}
    };

    Json query_output_schema = {
        {"type", "object"},
        {"properties", {
            {"result", {{"type", "string"}}},
            {"success", {{"type", "boolean"}}}
        }}
    };

    fastmcpp::tools::Tool sql_query_tool{
        "idasql_query",
        query_input_schema,
        query_output_schema,
        [this](const Json& args) -> Json {
            std::string query = args.value("query", "");
            if (query.empty()) {
                return Json{
                    {"content", Json::array({
                        Json{{"type", "text"}, {"text", "Error: missing query"}}
                    })},
                    {"isError", true}
                };
            }

            std::string result;
            bool success = true;

            if (use_queue_.load()) {
                // Queue mode (CLI): queue command for main thread execution
                auto qr = queue_and_wait(MCPPendingCommand::Type::Query, query);
                result = qr.payload;
                success = qr.success;
            } else {
                // Direct mode (plugin): callback uses execute_sync internally
                if (!query_cb_) {
                    return Json{
                        {"content", Json::array({
                            Json{{"type", "text"}, {"text", "Error: query callback not set"}}
                        })},
                        {"isError", true}
                    };
                }
                result = query_cb_(query);
            }

            // MCP tools/call expects content array format
            return Json{
                {"content", Json::array({
                    Json{{"type", "text"}, {"text", result}}
                })},
                {"isError", !success}
            };
        }
    };
    sql_query_tool.set_description("Execute a SQL query against the IDA database and return results");
    impl_->tool_manager.register_tool(sql_query_tool);

    // Register idasql_agent tool - natural language query (if ask_cb provided)
    if (ask_cb_) {
        Json ask_input_schema = {
            {"type", "object"},
            {"properties", {
                {"question", {
                    {"type", "string"},
                    {"description", "Natural language question about the binary (e.g., 'What functions call malloc?')"}
                }}
            }},
            {"required", Json::array({"question"})}
        };

        Json ask_output_schema = {
            {"type", "object"},
            {"properties", {
                {"response", {{"type", "string"}}},
                {"success", {{"type", "boolean"}}}
            }}
        };

        fastmcpp::tools::Tool agent_ask_tool{
            "idasql_agent",
            ask_input_schema,
            ask_output_schema,
            [this](const Json& args) -> Json {
                std::string question = args.value("question", "");
                if (question.empty()) {
                    return Json{
                        {"content", Json::array({
                            Json{{"type", "text"}, {"text", "Error: missing question"}}
                        })},
                        {"isError", true}
                    };
                }

                std::string result;
                bool success = true;

                if (use_queue_.load()) {
                    // Queue mode (CLI): queue command for main thread execution
                    auto qr = queue_and_wait(MCPPendingCommand::Type::Ask, question);
                    result = qr.payload;
                    success = qr.success;
                } else {
                    // Direct mode (plugin): callback handles thread safety
                    result = ask_cb_(question);
                }

                return Json{
                    {"content", Json::array({
                        Json{{"type", "text"}, {"text", result}}
                    })},
                    {"isError", !success}
                };
            }
        };
        agent_ask_tool.set_description("Ask a natural language question about the binary - AI translates to SQL and returns results");
        impl_->tool_manager.register_tool(agent_ask_tool);
    }

    // Create MCP handler
    std::unordered_map<std::string, std::string> descriptions = {
        {"idasql_query", "Execute a SQL query against the IDA database and return results"}
    };
    if (ask_cb_) {
        descriptions["idasql_agent"] = "Ask a natural language question about the binary - AI translates to SQL and returns results";
    }

    auto handler = fastmcpp::mcp::make_mcp_handler(
        "idasql",
        "1.0.0",
        impl_->tool_manager,
        descriptions
    );

    // Create and start SSE server
    impl_->server = std::make_unique<fastmcpp::server::SseServerWrapper>(
        handler,
        bind_addr_,
        port,
        "/sse",
        "/messages"
    );

    if (!impl_->server->start()) {
        impl_.reset();
        return -1;
    }

    port_ = impl_->server->port();
    running_.store(true);

    return port_;
}

void IDAMCPServer::set_interrupt_check(std::function<bool()> check) {
    interrupt_check_ = check;
}

void IDAMCPServer::run_until_stopped() {
    while (running_.load()) {
        if (interrupt_check_ && interrupt_check_()) {
            stop();
            break;
        }

        MCPPendingCommand* cmd = nullptr;

        {
            std::unique_lock<std::mutex> lock(queue_mutex_);
            if (queue_cv_.wait_for(lock, std::chrono::milliseconds(100),
                                   [this]() { return !pending_commands_.empty() || !running_.load(); })) {
                if (!pending_commands_.empty()) {
                    cmd = pending_commands_.front();
                    pending_commands_.pop();
                }
            }
        }

        if (cmd) {
            try {
                if (cmd->type == MCPPendingCommand::Type::Query && query_cb_) {
                    cmd->result = query_cb_(cmd->input);
                } else if (cmd->type == MCPPendingCommand::Type::Ask && ask_cb_) {
                    cmd->result = ask_cb_(cmd->input);
                } else {
                    cmd->result = "Error: No handler for command type";
                }
            } catch (const std::exception& e) {
                cmd->result = std::string("Error: ") + e.what();
            }

            if (cmd->done_mutex && cmd->done_cv) {
                {
                    std::lock_guard<std::mutex> lock(*cmd->done_mutex);
                    cmd->completed = true;
                }
                cmd->done_cv->notify_one();
            }
        }
    }
}

void IDAMCPServer::stop() {
    running_.store(false);
    queue_cv_.notify_all();
    complete_pending_commands("Error: MCP server stopped");

    if (impl_ && impl_->server) {
        impl_->server->stop();
    }

    impl_.reset();
}

void IDAMCPServer::complete_pending_commands(const std::string& result) {
    std::queue<MCPPendingCommand*> pending;
    {
        std::lock_guard<std::mutex> lock(queue_mutex_);
        std::swap(pending, pending_commands_);
    }

    while (!pending.empty()) {
        MCPPendingCommand* cmd = pending.front();
        pending.pop();
        if (!cmd || !cmd->done_mutex || !cmd->done_cv) {
            continue;
        }

        {
            std::lock_guard<std::mutex> lock(*cmd->done_mutex);
            if (!cmd->completed) {
                cmd->result = result;
                cmd->completed = true;
            }
        }
        cmd->done_cv->notify_one();
    }
}

std::string IDAMCPServer::url() const {
    std::ostringstream ss;
    ss << "http://" << bind_addr_ << ":" << port_;
    return ss.str();
}

std::string format_mcp_info(int port, bool has_agent) {
    std::ostringstream ss;
    ss << "MCP server started on port " << port << "\n";
    ss << "SSE endpoint: http://127.0.0.1:" << port << "/sse\n\n";

    ss << "Available tools:\n";
    ss << "  idasql_query  - Execute SQL query directly\n";
    if (has_agent) {
        ss << "  idasql_agent  - Ask natural language question (AI-powered)\n";
    }
    ss << "\n";

    ss << "Add to Claude Desktop config:\n";
    ss << "{\n";
    ss << "  \"mcpServers\": {\n";
    ss << "    \"idasql\": {\n";
    ss << "      \"url\": \"http://127.0.0.1:" << port << "/sse\"\n";
    ss << "    }\n";
    ss << "  }\n";
    ss << "}\n";

    return ss.str();
}

std::string format_mcp_status(int port, bool running) {
    std::ostringstream ss;
    if (running) {
        ss << "MCP server running on port " << port << "\n";
        ss << "SSE endpoint: http://127.0.0.1:" << port << "/sse\n";
    } else {
        ss << "MCP server not running\n";
        ss << "Use '.mcp start' to start\n";
    }
    return ss.str();
}

} // namespace idasql

```

`src/common/mcp_server.hpp`:

```hpp
#pragma once

/**
 * IDAMCPServer - MCP server for IDASQL
 *
 * Thread-safe MCP server using command queue pattern.
 * Tool handlers queue commands for execution on the main thread.
 *
 * Usage modes:
 * 1. CLI (idalib): Call wait() to process commands on main thread
 * 2. Plugin: Use execute_sync() wrapper in callbacks (no wait() needed)
 *
 * For CLI, start() returns immediately. Call wait() to block and process
 * commands. For plugin, the callback itself uses execute_sync() to marshal
 * to IDA's main thread, so no wait() is needed.
 */

#include <string>
#include <functional>
#include <atomic>
#include <mutex>
#include <condition_variable>
#include <queue>
#include <memory>

namespace idasql {

// Callbacks for handling requests
// QueryCallback: Direct SQL execution
// AskCallback: Natural language query (requires AI agent)
using QueryCallback = std::function<std::string(const std::string& sql)>;
using AskCallback = std::function<std::string(const std::string& question)>;

// Internal command structure for cross-thread execution
struct MCPPendingCommand {
    enum class Type { Query, Ask };
    Type type;
    std::string input;
    std::string result;
    bool completed = false;
    std::mutex* done_mutex = nullptr;
    std::condition_variable* done_cv = nullptr;
};

struct MCPQueueResult {
    bool success;
    std::string payload;
};

class IDAMCPServer {
public:
    IDAMCPServer();
    ~IDAMCPServer();

    // Non-copyable
    IDAMCPServer(const IDAMCPServer&) = delete;
    IDAMCPServer& operator=(const IDAMCPServer&) = delete;

    /**
     * Start MCP server on given port with callbacks
     *
     * @param port Port to listen on (0 = random port 9000-9999)
     * @param query_cb SQL query callback
     * @param ask_cb Natural language callback (optional)
     * @param bind_addr Address to bind to (default: localhost only)
     * @param use_queue If true, callbacks are queued for main thread (CLI mode)
     *                  If false, callbacks called directly (plugin mode with execute_sync)
     * @return Actual port used, or -1 on failure
     */
    int start(int port, QueryCallback query_cb, AskCallback ask_cb = nullptr,
              const std::string& bind_addr = "127.0.0.1", bool use_queue = false);

    /**
     * Block until server stops, processing commands on the calling thread
     * Only needed when use_queue=true (CLI mode)
     * This is where query_cb and ask_cb get called
     */
    void run_until_stopped();

    /**
     * Stop the server
     */
    void stop();

    /**
     * Check if server is running
     */
    bool is_running() const { return running_.load(); }

    /**
     * Get the port the server is listening on
     */
    int port() const { return port_; }

    /**
     * Get the SSE endpoint URL
     */
    std::string url() const;

    /**
     * Set interrupt check function (called during wait loop)
     */
    void set_interrupt_check(std::function<bool()> check);

    /**
     * Queue a command for execution on the main thread
     * Called by MCP tool handlers when use_queue=true
     */
    MCPQueueResult queue_and_wait(MCPPendingCommand::Type type, const std::string& input);

private:
    std::function<bool()> interrupt_check_;
    std::atomic<bool> running_{false};
    std::atomic<bool> use_queue_{false};
    std::string bind_addr_{"127.0.0.1"};
    int port_{0};

    // Command queue for cross-thread execution (CLI mode)
    std::mutex queue_mutex_;
    std::condition_variable queue_cv_;
    std::queue<MCPPendingCommand*> pending_commands_;

    // Callbacks stored for execution
    QueryCallback query_cb_;
    AskCallback ask_cb_;

    // Forward declaration - impl hides fastmcpp
    class Impl;
    std::unique_ptr<Impl> impl_;

    void complete_pending_commands(const std::string& result);
};

/**
 * Format MCP server info for display
 */
std::string format_mcp_info(int port, bool has_agent);

/**
 * Format MCP server status
 */
std::string format_mcp_status(int port, bool running);

} // namespace idasql

```

`src/common/plugin_control.hpp`:

```hpp
#pragma once
// IDASQL Plugin Control Codes

namespace idasql {

constexpr size_t PLUGIN_ARG_TOGGLE_CLI = 23;  // Toggle CLI

} // namespace idasql

```

`src/common/session_handler.hpp`:

```hpp
#pragma once

/**
 * SessionHandler - Core query processing logic for IDASQL
 *
 * This class handles:
 * - SQL query execution
 * - Meta commands (.tables, .schema, .help)
 * - Natural language queries via AI agent (when enabled)
 * - Multi-turn conversation state
 *
 * NO IDA DEPENDENCIES - can be tested standalone.
 *
 * Used by:
 * - CLI main.cpp (directly)
 * - IdasqlCLI (wraps this for cli_t)
 */

#include <string>
#include <functional>
#include <memory>
#include <cctype>
#include <algorithm>

#include "idasql_commands.hpp"

#ifdef IDASQL_HAS_AI_AGENT
#include "ai_agent.hpp"
#endif

namespace idasql {

class SessionHandler
{
public:
    using SqlExecutor = std::function<std::string(const std::string&)>;

    // Simple allowlist for table identifiers (alnum + underscore)
    static bool is_safe_table_name(const std::string& name)
    {
        if (name.empty() || name.size() > 128) return false;
        return std::all_of(name.begin(), name.end(), [](unsigned char c) {
            return std::isalnum(c) || c == '_';
        });
    }

    /**
     * Create a session handler
     * @param executor Function to execute SQL and return formatted results
     * @param enable_agent Whether to enable AI agent (if available)
     */
    explicit SessionHandler(SqlExecutor executor, bool enable_agent = false)
        : executor_(std::move(executor))
    {
        // Setup command callbacks
        callbacks_.get_tables = [this]() {
            return executor_("SELECT name FROM sqlite_master WHERE type='table' ORDER BY name");
        };
        callbacks_.get_schema = [this](const std::string& table) {
            if (!is_safe_table_name(table)) {
                return std::string("Invalid table name");
            }
            std::string sql = "SELECT sql FROM sqlite_master WHERE name='" + table + "'";
            return executor_(sql);
        };
        callbacks_.get_info = [this]() {
            return executor_("PRAGMA database_list");
        };
        callbacks_.clear_session = [this]() {
            return clear_session();
        };

#ifdef IDASQL_HAS_AI_AGENT
        if (enable_agent && AIAgent::is_available()) {
            agent_ = std::make_unique<AIAgent>(executor_);
            agent_->start();
            agent_enabled_ = true;
        }
#else
        (void)enable_agent;  // Suppress unused warning
#endif
    }

    ~SessionHandler()
    {
        end_session();
    }

    // Non-copyable, movable
    SessionHandler(const SessionHandler&) = delete;
    SessionHandler& operator=(const SessionHandler&) = delete;
    SessionHandler(SessionHandler&&) = default;
    SessionHandler& operator=(SessionHandler&&) = default;

    /**
     * Process a line of input
     * @param line User input (SQL, meta command, or natural language)
     * @return Result string, or empty if no output
     */
    std::string process_line(const std::string& line)
    {
        if (line.empty()) {
            return "";
        }

        // Check for meta commands first
        std::string output;
        auto cmd_result = handle_command(line, callbacks_, output);

        switch (cmd_result) {
            case CommandResult::QUIT:
                quit_requested_ = true;
                return "";

            case CommandResult::HANDLED:
                return output;

            case CommandResult::NOT_HANDLED:
                // Continue to process as query
                break;
        }

#ifdef IDASQL_HAS_AI_AGENT
        // If AI agent is enabled and input doesn't look like SQL, use agent
        if (agent_enabled_ && agent_ && !AIAgent::looks_like_sql(line)) {
            return agent_->query(line);
        }
#endif

        // Execute as raw SQL
        return executor_(line);
    }

    /**
     * One-shot query (no session, no conversation history)
     */
    std::string query(const std::string& prompt)
    {
#ifdef IDASQL_HAS_AI_AGENT
        if (agent_enabled_ && agent_) {
            return agent_->query(prompt);
        }
#endif
        // Fallback: treat as SQL
        return executor_(prompt);
    }

    /**
     * End the session (cleanup agent)
     */
    void end_session()
    {
#ifdef IDASQL_HAS_AI_AGENT
        if (agent_) {
            agent_->stop();
            agent_.reset();
        }
#endif
        agent_enabled_ = false;
    }

    bool is_agent_enabled() const { return agent_enabled_; }
    bool is_quit_requested() const { return quit_requested_; }

    /**
     * Clear/reset the session
     * Resets AI agent conversation history if enabled.
     * Override the callback to add UI-specific behavior (e.g., msg_clear).
     *
     * @return Status message
     */
    virtual std::string clear_session()
    {
#ifdef IDASQL_HAS_AI_AGENT
        if (agent_) {
            agent_->reset_session();
            return "Session cleared (conversation history reset)";
        }
#endif
        return "Session cleared";
    }

    /**
     * Get command callbacks (for overriding in derived classes)
     */
    CommandCallbacks& callbacks() { return callbacks_; }
    const CommandCallbacks& callbacks() const { return callbacks_; }

    /**
     * Check if AI agent is available on this system
     */
    static bool is_agent_available()
    {
#ifdef IDASQL_HAS_AI_AGENT
        return AIAgent::is_available();
#else
        return false;
#endif
    }

private:
    SqlExecutor executor_;
    CommandCallbacks callbacks_;
    bool agent_enabled_ = false;
    bool quit_requested_ = false;

#ifdef IDASQL_HAS_AI_AGENT
    std::unique_ptr<AIAgent> agent_;
#endif
};

} // namespace idasql

```

`src/lib/CMakeLists.txt`:

```txt
# libidasql - SQL interface to IDA databases
#
# This is a header-only library that extends xsql with IDA-specific tables.
# Users link against this target to get the include paths.

add_library(idasql INTERFACE)

target_include_directories(idasql INTERFACE
    $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
    $<INSTALL_INTERFACE:include>
)

# Link against xsql::xsql for SQLite virtual table framework
target_link_libraries(idasql INTERFACE xsql::xsql)

# Export the library target
# install(TARGETS idasql EXPORT idasqlTargets)
# install(DIRECTORY include/idasql DESTINATION include)

```

`src/lib/include/idasql/database.hpp`:

```hpp
/**
 * database.hpp - IDASQL API
 *
 * Two-tier API design reflecting IDA's singleton nature:
 *
 * TIER 1: QueryEngine (recommended for most use)
 *   - Use when IDA is already initialized (plugins, scripts, idalib)
 *   - Just creates SQLite + virtual tables
 *   - No IDA lifecycle management
 *
 * TIER 2: Session (for standalone CLI tools)
 *   - Full IDA lifecycle: init_library + open_database + close
 *   - Use for tools like idasql.exe that manage everything
 *
 * TIER 3: Free functions (quick one-liners)
 *   - idasql::query(), idasql::exec()
 *   - Use global engine, lazily initialized
 *
 * IMPORTANT: IDA SDK is a singleton. Only ONE database can be open.
 * The Session class doesn't create "a database" - it manages THE database.
 */

#pragma once

#include <idasql/platform.hpp>

#include <xsql/database.hpp>
#include <xsql/json.hpp>
#include <string>
#include <vector>
#include <functional>
#include <memory>

#include <idasql/platform_undef.hpp>

// IDA SDK
#include <ida.hpp>
#include <idalib.hpp>
#include <auto.hpp>
#include <strlist.hpp>
#include <algorithm>

// IDASQL components
#include <idasql/entities.hpp>
#include <idasql/entities_ext.hpp>
#include <idasql/entities_types.hpp>
#include <idasql/metadata.hpp>
#include <idasql/functions.hpp>
#include <idasql/disassembly.hpp>
#include <idasql/search_bytes.hpp>
#include <idasql/entities_dbg.hpp>

// Optional: Decompiler (may not be available)
#ifdef USE_HEXRAYS
#include <idasql/decompiler.hpp>
#endif

namespace idasql {

// ============================================================================
// Result Types
// ============================================================================

/**
 * Single row from a query result
 */
struct Row {
    std::vector<std::string> values;

    const std::string& operator[](size_t i) const { return values[i]; }
    size_t size() const { return values.size(); }
};

/**
 * Query result set
 */
struct QueryResult {
    std::vector<std::string> columns;
    std::vector<Row> rows;
    std::string error;
    bool success = false;

    // Convenience accessors
    size_t row_count() const { return rows.size(); }
    size_t column_count() const { return columns.size(); }
    bool empty() const { return rows.empty(); }

    // Get first cell as scalar (for single-value queries)
    std::string scalar() const {
        return (!empty() && rows[0].size() > 0) ? rows[0][0] : "";
    }

    // Iterator support
    auto begin() { return rows.begin(); }
    auto end() { return rows.end(); }
    auto begin() const { return rows.begin(); }
    auto end() const { return rows.end(); }

    // Format as string for display
    std::string to_string() const {
        if (!success) return error;
        if (empty()) return "(0 rows)";

        std::string result;
        // Header
        for (size_t i = 0; i < columns.size(); ++i) {
            if (i > 0) result += " | ";
            result += columns[i];
        }
        result += "\n";
        // Separator
        for (size_t i = 0; i < columns.size(); ++i) {
            if (i > 0) result += "-+-";
            result += std::string(columns[i].size(), '-');
        }
        result += "\n";
        // Rows
        for (const auto& row : rows) {
            for (size_t i = 0; i < row.size(); ++i) {
                if (i > 0) result += " | ";
                result += row[i];
            }
            result += "\n";
        }
        result += "(" + std::to_string(row_count()) + " rows)";
        return result;
    }
};

// ============================================================================
// TIER 1: QueryEngine - SQL interface (no IDA lifecycle)
// ============================================================================

/**
 * QueryEngine - SQLite query interface to the current IDA database
 *
 * Use this when IDA is already initialized. Does NOT manage IDA lifecycle.
 * You can have multiple QueryEngine instances - they all query the same
 * IDA database (because IDA is singleton).
 *
 * Example:
 *   idasql::QueryEngine qe;
 *   auto result = qe.query("SELECT name, size FROM funcs LIMIT 10");
 *   for (const auto& row : result) {
 *       msg("%s: %s\n", row[0].c_str(), row[1].c_str());
 *   }
 */
class QueryEngine {
public:
    QueryEngine() {
        init();
    }

    ~QueryEngine() = default;

    // Moveable but not copyable
    QueryEngine(QueryEngine&&) noexcept = default;
    QueryEngine& operator=(QueryEngine&&) noexcept = default;

    QueryEngine(const QueryEngine&) = delete;
    QueryEngine& operator=(const QueryEngine&) = delete;

    /**
     * Execute SQL and return results
     */
    QueryResult query(const std::string& sql) {
        return query(sql.c_str());
    }

    QueryResult query(const char* sql) {
        QueryResult result;

        if (!db_.is_open()) {
            result.error = "QueryEngine not initialized";
            return result;
        }

        struct QueryData {
            QueryResult* result;
            bool first_row;
        } qd = { &result, true };

        auto callback = [](void* data, int argc, char** argv, char** cols) -> int {
            auto* qd = static_cast<QueryData*>(data);

            if (qd->first_row) {
                for (int i = 0; i < argc; i++) {
                    qd->result->columns.push_back(cols[i] ? cols[i] : "");
                }
                qd->first_row = false;
            }

            Row row;
            row.values.reserve(argc);
            for (int i = 0; i < argc; i++) {
                row.values.push_back(argv[i] ? argv[i] : "NULL");
            }
            qd->result->rows.push_back(std::move(row));

            return 0;
        };

        int rc = exec(sql, callback, &qd);
        result.success = (rc == SQLITE_OK);
        if (!result.success && result.error.empty()) {
            result.error = sqlite3_errmsg(db_.handle());
        }

        return result;
    }

    /**
     * Execute SQL with callback (for streaming large results)
     */
    int exec(const char* sql, sqlite3_callback callback, void* data) {
        if (!db_.is_open()) {
            error_ = "QueryEngine not initialized";
            return SQLITE_ERROR;
        }

        char* err_msg = nullptr;
        int rc = sqlite3_exec(db_.handle(), sql, callback, data, &err_msg);
        if (err_msg) {
            error_ = err_msg;
            sqlite3_free(err_msg);
        }
        return rc;
    }

    /**
     * Execute SQL, ignore results (for INSERT/UPDATE/DELETE)
     */
    bool execute(const char* sql) {
        return exec(sql, nullptr, nullptr) == SQLITE_OK;
    }

    /**
     * Get single value (first column of first row)
     */
    std::string scalar(const std::string& sql) {
        return scalar(sql.c_str());
    }

    std::string scalar(const char* sql) {
        auto result = query(sql);
        if (result.success && !result.empty()) {
            return result.rows[0].values[0];
        }
        return "";
    }

    /**
     * Get last error message
     */
    const std::string& error() const { return error_; }

    /**
     * Check if initialized
     */
    bool is_valid() const { return db_.is_open(); }

    /**
     * Get raw SQLite handle (for advanced use)
     */
    sqlite3* handle() { return db_.handle(); }

private:
    xsql::Database db_;
    std::string error_;

    // Table registries (prevent dangling virtual table pointers)
    std::unique_ptr<entities::TableRegistry> entities_;
    std::unique_ptr<metadata::MetadataRegistry> metadata_;
    std::unique_ptr<extended::ExtendedRegistry> extended_;
    std::unique_ptr<disassembly::DisassemblyRegistry> disassembly_;
    std::unique_ptr<types::TypesRegistry> types_;
    std::unique_ptr<debugger::DebuggerRegistry> debugger_;
    std::unique_ptr<decompiler::DecompilerRegistry> decompiler_;  // Runtime detection

    void init() {
        // db_ auto-opens :memory: via xsql::Database constructor

        // Register all virtual tables
        entities_ = std::make_unique<entities::TableRegistry>();
        entities_->register_all(db_);

        metadata_ = std::make_unique<metadata::MetadataRegistry>();
        metadata_->register_all(db_);

        extended_ = std::make_unique<extended::ExtendedRegistry>();
        extended_->register_all(db_);

        disassembly_ = std::make_unique<disassembly::DisassemblyRegistry>();
        disassembly_->register_all(db_);

        types_ = std::make_unique<types::TypesRegistry>();
        types_->register_all(db_);

        debugger_ = std::make_unique<debugger::DebuggerRegistry>();
        debugger_->register_all(db_);

        // Decompiler registry - register_all() handles runtime Hex-Rays detection
        // Must be registered before SQL functions so hexrays_available() is set
        decompiler_ = std::make_unique<decompiler::DecompilerRegistry>();
        decompiler_->register_all(db_);

        functions::register_sql_functions(db_);
        search::register_search_bytes(db_);
    }
};

// ============================================================================
// TIER 2: Session - Full IDA lifecycle management
// ============================================================================

/**
 * Session - Manages THE IDA database session
 *
 * Use this for standalone tools that need to open/close IDA databases.
 * Remember: IDA is singleton, so there's only ever ONE session.
 *
 * Example (CLI tool):
 *   idasql::Session session;
 *   if (!session.open("binary.i64")) {
 *       std::cerr << session.error() << std::endl;
 *       return 1;
 *   }
 *   auto result = session.query("SELECT * FROM funcs");
 *   session.close();
 */
class Session {
public:
    Session() = default;
    ~Session() { close(); }

    // Non-copyable, non-moveable (singleton semantics)
    Session(const Session&) = delete;
    Session& operator=(const Session&) = delete;
    Session(Session&&) = delete;
    Session& operator=(Session&&) = delete;

    /**
     * Open an IDA database
     * @param idb_path Path to .idb/.i64 file
     * @return true on success
     */
    bool open(const char* idb_path) {
        if (engine_) close();

        // Initialize IDA library
        int rc = init_library();
        if (rc != 0) {
            error_ = "Failed to initialize IDA library: " + std::to_string(rc);
            return false;
        }

        // Open the database
        rc = open_database(idb_path, true, nullptr);
        if (rc != 0) {
            error_ = "Failed to open database: " + std::string(idb_path);
            return false;
        }
        ida_opened_ = true;

        // Wait for auto-analysis
        auto_wait();

        // For new analysis (exe/dll/etc), build strings after auto-analysis completes
        // For existing databases (i64/idb), strings are already saved
        std::string path_lower = idb_path;
        std::transform(path_lower.begin(), path_lower.end(), path_lower.begin(), ::tolower);
        auto ends_with = [](const std::string& s, const std::string& suffix) {
            return s.size() >= suffix.size() &&
                   s.compare(s.size() - suffix.size(), suffix.size(), suffix) == 0;
        };
        bool is_new_analysis = !(
            ends_with(path_lower, ".i64") ||
            ends_with(path_lower, ".idb")
        );
        if (is_new_analysis) {
            // Configure and build string list with sensible defaults
            strwinsetup_t* opts = const_cast<strwinsetup_t*>(get_strlist_options());
            opts->strtypes.clear();
            opts->strtypes.push_back(STRTYPE_C);      // ASCII
            opts->strtypes.push_back(STRTYPE_C_16);   // UTF-16
            opts->minlen = 5;
            opts->only_7bit = 0;
            clear_strlist();  // Clear before building (like rebuild_strings)
            build_strlist();
        }

        // Create query engine
        engine_ = std::make_unique<QueryEngine>();
        if (!engine_->is_valid()) {
            error_ = engine_->error();
            close();
            return false;
        }

        return true;
    }

    /**
     * Close the session
     */
    void close() {
        engine_.reset();
        if (ida_opened_) {
            close_database(false);
            ida_opened_ = false;
        }
    }

    /**
     * Check if session is open
     */
    bool is_open() const { return engine_ && engine_->is_valid() && ida_opened_; }

    /**
     * Get last error
     */
    const std::string& error() const {
        return engine_ ? engine_->error() : error_;
    }

    // Delegate query methods to engine (with string overloads)
    QueryResult query(const std::string& sql) { return query(sql.c_str()); }
    QueryResult query(const char* sql) {
        if (!engine_) {
            QueryResult r;
            r.error = "Session not open";
            return r;
        }
        return engine_->query(sql);
    }

    int exec(const char* sql, sqlite3_callback cb, void* data) {
        return engine_ ? engine_->exec(sql, cb, data) : SQLITE_ERROR;
    }

    bool execute(const std::string& sql) { return execute(sql.c_str()); }
    bool execute(const char* sql) {
        return engine_ ? engine_->execute(sql) : false;
    }

    std::string scalar(const std::string& sql) { return scalar(sql.c_str()); }
    std::string scalar(const char* sql) {
        return engine_ ? engine_->scalar(sql) : "";
    }

    /**
     * Get raw SQLite handle
     */
    sqlite3* handle() { return engine_ ? engine_->handle() : nullptr; }

    /**
     * Get query engine (for advanced use)
     */
    QueryEngine* engine() { return engine_.get(); }

    /**
     * Get database info
     */
    std::string info() const {
        if (!ida_opened_) return "Not opened";

        std::string s;
        s += "Processor: " + std::string(inf_get_procname().c_str()) + "\n";
        s += "Functions: " + std::to_string(get_func_qty()) + "\n";
        s += "Segments:  " + std::to_string(get_segm_qty()) + "\n";
        s += "Names:     " + std::to_string(get_nlist_size()) + "\n";
        return s;
    }

private:
    std::unique_ptr<QueryEngine> engine_;
    bool ida_opened_ = false;
    std::string error_;
};

// ============================================================================
// TIER 3: Free Functions - Quick one-liners
// ============================================================================

namespace detail {
    inline QueryEngine& global_engine() {
        static QueryEngine engine;
        return engine;
    }
}

/**
 * Quick query - uses global engine
 *
 * Example:
 *   auto funcs = idasql::query("SELECT name FROM funcs LIMIT 5");
 *   for (const auto& row : funcs) {
 *       msg("%s\n", row[0].c_str());
 *   }
 */
inline QueryResult query(const char* sql) {
    return detail::global_engine().query(sql);
}

/**
 * Quick exec with callback
 */
inline int exec(const char* sql, sqlite3_callback cb, void* data) {
    return detail::global_engine().exec(sql, cb, data);
}

/**
 * Quick execute (no results)
 */
inline bool execute(const char* sql) {
    return detail::global_engine().execute(sql);
}

/**
 * Quick scalar query
 */
inline std::string scalar(const char* sql) {
    return detail::global_engine().scalar(sql);
}

// ============================================================================
// Backwards Compatibility Alias
// ============================================================================

// For existing code using idasql::Database
using Database = Session;

} // namespace idasql

```

`src/lib/include/idasql/decompiler.hpp`:

```hpp
/**
 * ida_decompiler.hpp - Hex-Rays Decompiler Virtual Tables
 *
 * Provides SQLite virtual tables for accessing decompiled function data:
 *   pseudocode       - Decompiled function pseudocode lines
 *   ctree_lvars      - Local variables from decompiled functions
 *   ctree            - Full AST (expressions and statements)
 *   ctree_call_args  - Flattened call arguments
 *
 * All tables support constraint pushdown on func_addr via filter_eq framework:
 *   SELECT * FROM pseudocode WHERE func_addr = 0x401000;
 *   SELECT * FROM ctree_lvars WHERE func_addr = 0x401000;
 *
 * Requires Hex-Rays decompiler license.
 */

#pragma once

#include <idasql/platform.hpp>

#include <idasql/vtable.hpp>
#include <xsql/database.hpp>

#include <string>
#include <vector>
#include <map>

#include <idasql/platform_undef.hpp>

// IDA SDK headers
#include <ida.hpp>
#include <auto.hpp>
#include <funcs.hpp>
#include <name.hpp>

// Hex-Rays decompiler headers
#include <lines.hpp>
#include <hexrays.hpp>

namespace idasql {
namespace decompiler {

// ============================================================================
// Decompiler Initialization
// ============================================================================

// Global flag tracking if Hex-Rays is available
// Set once during DecompilerRegistry::register_all()
inline bool& hexrays_available() {
    static bool available = false;
    return available;
}

// Initialize Hex-Rays decompiler - call ONCE at startup
// Returns true if decompiler is available
inline bool init_hexrays() {
    static bool initialized = false;

    if (!initialized) {
        initialized = true;
        hexrays_available() = init_hexrays_plugin();
        if (hexrays_available()) {
            // Hex-Rays initialization may trigger additional auto-analysis work.
            // Ensure analysis is complete before running decompiler-backed queries.
            auto_wait();
        }
    }
    return hexrays_available();
}

// Invalidate decompiler cache for the function containing ea.
// Safe to call even if Hex-Rays is unavailable or ea is not in a function.
inline void invalidate_decompiler_cache(ea_t ea) {
    if (!hexrays_available()) return;
    func_t* f = get_func(ea);
    if (f) {
        mark_cfunc_dirty(f->start_ea, false);
    }
}

// ============================================================================
// Data Structures
// ============================================================================

// ITP name ↔ enum helpers
inline const char* itp_to_name(item_preciser_t itp) {
    switch (itp) {
        case ITP_SEMI:   return "semi";
        case ITP_BLOCK1: return "block1";
        case ITP_BLOCK2: return "block2";
        case ITP_CURLY1: return "curly1";
        case ITP_CURLY2: return "curly2";
        case ITP_BRACE1: return "brace1";
        case ITP_BRACE2: return "brace2";
        case ITP_COLON:  return "colon";
        case ITP_CASE:   return "case";
        case ITP_ELSE:   return "else";
        case ITP_DO:     return "do";
        case ITP_ASM:    return "asm";
        default:         return "semi";
    }
}

inline item_preciser_t name_to_itp(const char* name) {
    if (!name || !name[0]) return ITP_SEMI;
    if (stricmp(name, "block1") == 0) return ITP_BLOCK1;
    if (stricmp(name, "block2") == 0) return ITP_BLOCK2;
    if (stricmp(name, "curly1") == 0) return ITP_CURLY1;
    if (stricmp(name, "curly2") == 0) return ITP_CURLY2;
    if (stricmp(name, "brace1") == 0) return ITP_BRACE1;
    if (stricmp(name, "brace2") == 0) return ITP_BRACE2;
    if (stricmp(name, "colon") == 0)  return ITP_COLON;
    if (stricmp(name, "case") == 0)   return ITP_CASE;
    if (stricmp(name, "else") == 0)   return ITP_ELSE;
    if (stricmp(name, "do") == 0)     return ITP_DO;
    if (stricmp(name, "asm") == 0)    return ITP_ASM;
    return ITP_SEMI;  // default
}

// Pseudocode line data
struct PseudocodeLine {
    ea_t func_addr;
    int line_num;
    std::string text;
    ea_t ea;              // Associated address (from COLOR_ADDR anchor)
    std::string comment;  // User comment at this ea (from restore_user_cmts)
    item_preciser_t comment_placement = ITP_SEMI;  // Comment placement type
};

// Local variable data
struct LvarInfo {
    ea_t func_addr;
    int idx;
    std::string name;
    std::string type;
    int size;
    bool is_arg;
    bool is_result;
    bool is_stk_var;
    bool is_reg_var;
    sval_t stkoff;
    mreg_t mreg;
};

// Ctree item data
struct CtreeItem {
    ea_t func_addr;
    int item_id;
    bool is_expr;
    int op;
    std::string op_name;
    ea_t ea;
    int parent_id;
    int depth;
    int x_id, y_id, z_id;
    int cond_id, then_id, else_id;
    int body_id, init_id, step_id;
    int var_idx;
    ea_t obj_ea;
    int64_t num_value;
    std::string str_value;
    std::string helper_name;
    int member_offset;
    std::string var_name;
    bool var_is_stk, var_is_reg, var_is_arg;
    std::string obj_name;

    CtreeItem() : func_addr(0), item_id(-1), is_expr(false), op(0), ea(BADADDR),
                  parent_id(-1), depth(0),
                  x_id(-1), y_id(-1), z_id(-1),
                  cond_id(-1), then_id(-1), else_id(-1),
                  body_id(-1), init_id(-1), step_id(-1),
                  var_idx(-1), obj_ea(BADADDR), num_value(0), member_offset(0),
                  var_is_stk(false), var_is_reg(false), var_is_arg(false) {}
};

// Call argument data
struct CallArgInfo {
    ea_t func_addr;
    int call_item_id;
    int arg_idx;
    int arg_item_id;
    std::string arg_op;
    int arg_var_idx;
    std::string arg_var_name;
    bool arg_var_is_stk;
    bool arg_var_is_arg;
    ea_t arg_obj_ea;
    std::string arg_obj_name;
    int64_t arg_num_value;
    std::string arg_str_value;

    CallArgInfo() : func_addr(0), call_item_id(-1), arg_idx(-1), arg_item_id(-1),
                    arg_var_idx(-1), arg_var_is_stk(false), arg_var_is_arg(false),
                    arg_obj_ea(BADADDR), arg_num_value(0) {}
};

// ============================================================================
// Helper Functions
// ============================================================================

// Get full ctype name with cot_/cit_ prefix
inline std::string get_full_ctype_name(ctype_t op) {
    const char* name = get_ctype_name(op);
    if (!name || !name[0]) return "";
    if (op < cit_empty) {
        return std::string("cot_") + name;
    } else {
        return std::string("cit_") + name;
    }
}

// Extract the first COLOR_ADDR anchor ea from a raw pseudocode line.
// Returns BADADDR if no anchor found.
inline ea_t extract_line_ea(cfunc_t* cfunc, const qstring& raw_line) {
    const char* p = raw_line.c_str();
    while (*p) {
        if (*p == COLOR_ON && *(p + 1) == COLOR_ADDR) {
            p += 2;  // skip COLOR_ON + COLOR_ADDR
            // Read 16 hex chars
            char hex[17] = {};
            for (int i = 0; i < 16; i++) {
                if (!p[i]) return BADADDR;
                hex[i] = p[i];
            }
            uint64_t val = strtoull(hex, nullptr, 16);
            uint32_t anchor = static_cast<uint32_t>(val);
            // ANCHOR_CITEM = type 0 (bits 31-30)
            uint32_t anchor_type = (anchor >> 30) & 0x3;
            if (anchor_type != 0) return BADADDR;
            uint32_t idx = anchor & 0x3FFFFFFF;
            if (idx >= cfunc->treeitems.size()) return BADADDR;
            citem_t* item = cfunc->treeitems[idx];
            return item ? item->ea : BADADDR;
        }
        p++;
    }
    return BADADDR;
}

// Collect pseudocode for a single function
inline bool collect_pseudocode(std::vector<PseudocodeLine>& lines, ea_t func_addr) {
    lines.clear();

    if (!hexrays_available()) return false;

    func_t* f = get_func(func_addr);
    if (!f) return false;

    hexrays_failure_t hf;
    cfuncptr_t cfunc = decompile(f, &hf);
    if (!cfunc) return false;

    const strvec_t& sv = cfunc->get_pseudocode();

    for (int i = 0; i < sv.size(); i++) {
        PseudocodeLine pl;
        pl.func_addr = func_addr;
        pl.line_num = i;

        // Extract ea from COLOR_ADDR anchor BEFORE stripping tags
        pl.ea = extract_line_ea(&*cfunc, sv[i].line);

        qstring clean;
        tag_remove(&clean, sv[i].line);
        pl.text = clean.c_str();

        lines.push_back(pl);
    }

    // Read stored comments and match to lines by ea
    user_cmts_t* cmts = restore_user_cmts(func_addr);
    if (cmts) {
        for (auto it = user_cmts_begin(cmts); it != user_cmts_end(cmts); it = user_cmts_next(it)) {
            const treeloc_t& loc = user_cmts_first(it);
            const citem_cmt_t& cmt = user_cmts_second(it);
            // Match comment to first line with this ea
            for (auto& pl : lines) {
                if (pl.ea == loc.ea && pl.comment.empty()) {
                    pl.comment = cmt.c_str();
                    pl.comment_placement = loc.itp;
                    break;
                }
            }
        }
        user_cmts_free(cmts);
    }

    return true;
}

// Collect pseudocode for all functions
inline void collect_all_pseudocode(std::vector<PseudocodeLine>& lines) {
    lines.clear();

    if (!hexrays_available()) return;

    size_t func_qty = get_func_qty();
    for (size_t i = 0; i < func_qty; i++) {
        func_t* f = getn_func(i);
        if (!f) continue;

        std::vector<PseudocodeLine> func_lines;
        if (collect_pseudocode(func_lines, f->start_ea)) {
            lines.insert(lines.end(), func_lines.begin(), func_lines.end());
        }
    }
}

// Collect lvars for a single function
inline bool collect_lvars(std::vector<LvarInfo>& vars, ea_t func_addr) {
    vars.clear();

    if (!hexrays_available()) return false;

    func_t* f = get_func(func_addr);
    if (!f) return false;

    hexrays_failure_t hf;
    cfuncptr_t cfunc = decompile(f, &hf);
    if (!cfunc) return false;

    lvars_t* lvars = cfunc->get_lvars();
    if (!lvars) return false;

    for (int i = 0; i < lvars->size(); i++) {
        const lvar_t& lv = (*lvars)[i];

        LvarInfo vi;
        vi.func_addr = func_addr;
        vi.idx = i;
        vi.name = lv.name.c_str();

        qstring type_str;
        lv.type().print(&type_str);
        vi.type = type_str.c_str();

        vi.size = lv.width;
        vi.is_arg = lv.is_arg_var();
        vi.is_result = lv.is_result_var();
        vi.is_stk_var = lv.is_stk_var();
        vi.is_reg_var = lv.is_reg_var();
        vi.stkoff = vi.is_stk_var ? lv.get_stkoff() : 0;
        vi.mreg = vi.is_reg_var ? lv.location.reg1() : mr_none;

        vars.push_back(vi);
    }

    return true;
}

// Collect lvars for all functions
inline void collect_all_lvars(std::vector<LvarInfo>& vars) {
    vars.clear();

    if (!hexrays_available()) return;

    size_t func_qty = get_func_qty();
    for (size_t i = 0; i < func_qty; i++) {
        func_t* f = getn_func(i);
        if (!f) continue;

        std::vector<LvarInfo> func_vars;
        if (collect_lvars(func_vars, f->start_ea)) {
            vars.insert(vars.end(), func_vars.begin(), func_vars.end());
        }
    }
}

// Ctree collector visitor
struct ctree_collector_t : public ctree_parentee_t {
    std::vector<CtreeItem>& items;
    std::map<citem_t*, int> item_ids;
    cfunc_t* cfunc;
    ea_t func_addr;
    int next_id;

    ctree_collector_t(std::vector<CtreeItem>& items_, cfunc_t* cfunc_, ea_t func_addr_)
        : ctree_parentee_t(false), items(items_), cfunc(cfunc_), func_addr(func_addr_), next_id(0) {}

    int idaapi visit_insn(cinsn_t* insn) override {
        int my_id = next_id++;
        item_ids[insn] = my_id;

        CtreeItem ci;
        ci.func_addr = func_addr;
        ci.item_id = my_id;
        ci.is_expr = false;
        ci.op = insn->op;
        ci.op_name = get_full_ctype_name(insn->op);
        ci.ea = insn->ea;
        ci.depth = parents.size();

        citem_t* p = parent_item();
        if (p) {
            auto it = item_ids.find(p);
            if (it != item_ids.end()) ci.parent_id = it->second;
        }

        items.push_back(ci);
        return 0;
    }

    int idaapi visit_expr(cexpr_t* expr) override {
        int my_id = next_id++;
        item_ids[expr] = my_id;

        CtreeItem ci;
        ci.func_addr = func_addr;
        ci.item_id = my_id;
        ci.is_expr = true;
        ci.op = expr->op;
        ci.op_name = get_full_ctype_name(expr->op);
        ci.ea = expr->ea;
        ci.depth = parents.size();

        citem_t* p = parent_item();
        if (p) {
            auto it = item_ids.find(p);
            if (it != item_ids.end()) ci.parent_id = it->second;
        }

        switch (expr->op) {
            case cot_var:
                ci.var_idx = expr->v.idx;
                if (cfunc && ci.var_idx >= 0 && ci.var_idx < cfunc->get_lvars()->size()) {
                    const lvar_t& lv = (*cfunc->get_lvars())[ci.var_idx];
                    ci.var_name = lv.name.c_str();
                    ci.var_is_stk = lv.is_stk_var();
                    ci.var_is_reg = lv.is_reg_var();
                    ci.var_is_arg = lv.is_arg_var();
                }
                break;
            case cot_obj:
                ci.obj_ea = expr->obj_ea;
                {
                    qstring name;
                    if (get_name(&name, expr->obj_ea) > 0) {
                        ci.obj_name = name.c_str();
                    }
                }
                break;
            case cot_num:
                ci.num_value = expr->numval();
                break;
            case cot_str:
                if (expr->string) ci.str_value = expr->string;
                break;
            case cot_helper:
                if (expr->helper) ci.helper_name = expr->helper;
                break;
            case cot_memref:
            case cot_memptr:
                ci.member_offset = expr->m;
                break;
            default:
                break;
        }

        items.push_back(ci);
        return 0;
    }

    void resolve_child_ids() {
        for (auto& ci : items) {
            if (ci.item_id < 0) continue;

            citem_t* item = nullptr;
            for (auto& kv : item_ids) {
                if (kv.second == ci.item_id) {
                    item = kv.first;
                    break;
                }
            }
            if (!item) continue;

            if (ci.is_expr) {
                cexpr_t* expr = static_cast<cexpr_t*>(item);

                if (expr->x) {
                    auto it = item_ids.find(expr->x);
                    if (it != item_ids.end()) ci.x_id = it->second;
                }
                if (expr->y && expr->op != cot_call) {
                    auto it = item_ids.find(expr->y);
                    if (it != item_ids.end()) ci.y_id = it->second;
                }
                if (expr->z) {
                    auto it = item_ids.find(expr->z);
                    if (it != item_ids.end()) ci.z_id = it->second;
                }
            } else {
                cinsn_t* insn = static_cast<cinsn_t*>(item);

                switch (insn->op) {
                    case cit_if:
                        if (insn->cif) {
                            auto cond_it = item_ids.find(&insn->cif->expr);
                            if (cond_it != item_ids.end()) ci.cond_id = cond_it->second;
                            if (insn->cif->ithen) {
                                auto it = item_ids.find(insn->cif->ithen);
                                if (it != item_ids.end()) ci.then_id = it->second;
                            }
                            if (insn->cif->ielse) {
                                auto it = item_ids.find(insn->cif->ielse);
                                if (it != item_ids.end()) ci.else_id = it->second;
                            }
                        }
                        break;
                    case cit_for:
                        if (insn->cfor) {
                            auto cond_it = item_ids.find(&insn->cfor->expr);
                            if (cond_it != item_ids.end()) ci.cond_id = cond_it->second;
                            auto init_it = item_ids.find(&insn->cfor->init);
                            if (init_it != item_ids.end()) ci.init_id = init_it->second;
                            auto step_it = item_ids.find(&insn->cfor->step);
                            if (step_it != item_ids.end()) ci.step_id = step_it->second;
                            if (insn->cfor->body) {
                                auto it = item_ids.find(insn->cfor->body);
                                if (it != item_ids.end()) ci.body_id = it->second;
                            }
                        }
                        break;
                    case cit_while:
                        if (insn->cwhile) {
                            auto cond_it = item_ids.find(&insn->cwhile->expr);
                            if (cond_it != item_ids.end()) ci.cond_id = cond_it->second;
                            if (insn->cwhile->body) {
                                auto it = item_ids.find(insn->cwhile->body);
                                if (it != item_ids.end()) ci.body_id = it->second;
                            }
                        }
                        break;
                    case cit_do:
                        if (insn->cdo) {
                            auto cond_it = item_ids.find(&insn->cdo->expr);
                            if (cond_it != item_ids.end()) ci.cond_id = cond_it->second;
                            if (insn->cdo->body) {
                                auto it = item_ids.find(insn->cdo->body);
                                if (it != item_ids.end()) ci.body_id = it->second;
                            }
                        }
                        break;
                    case cit_return:
                        if (insn->creturn) {
                            auto it = item_ids.find(&insn->creturn->expr);
                            if (it != item_ids.end()) ci.x_id = it->second;
                        }
                        break;
                    case cit_expr:
                        if (insn->cexpr) {
                            auto it = item_ids.find(insn->cexpr);
                            if (it != item_ids.end()) ci.x_id = it->second;
                        }
                        break;
                    default:
                        break;
                }
            }
        }
    }
};

// Collect ctree items for a single function
inline bool collect_ctree(std::vector<CtreeItem>& items, ea_t func_addr) {
    items.clear();

    if (!hexrays_available()) return false;

    func_t* f = get_func(func_addr);
    if (!f) return false;

    hexrays_failure_t hf;
    cfuncptr_t cfunc = decompile(f, &hf);
    if (!cfunc) return false;

    ctree_collector_t collector(items, &*cfunc, func_addr);
    collector.apply_to(&cfunc->body, nullptr);
    collector.resolve_child_ids();

    return true;
}

// Collect ctree for all functions
inline void collect_all_ctree(std::vector<CtreeItem>& items) {
    items.clear();

    if (!hexrays_available()) return;

    size_t func_qty = get_func_qty();
    for (size_t i = 0; i < func_qty; i++) {
        func_t* f = getn_func(i);
        if (!f) continue;

        std::vector<CtreeItem> func_items;
        if (collect_ctree(func_items, f->start_ea)) {
            items.insert(items.end(), func_items.begin(), func_items.end());
        }
    }
}

// Call args collector visitor
struct call_args_collector_t : public ctree_parentee_t {
    std::vector<CallArgInfo>& args;
    std::map<citem_t*, int> item_ids;
    cfunc_t* cfunc;
    ea_t func_addr;
    int next_id;

    call_args_collector_t(std::vector<CallArgInfo>& args_, cfunc_t* cfunc_, ea_t func_addr_)
        : ctree_parentee_t(false), args(args_), cfunc(cfunc_), func_addr(func_addr_), next_id(0) {}

    int idaapi visit_insn(cinsn_t* insn) override {
        item_ids[insn] = next_id++;
        return 0;
    }

    int idaapi visit_expr(cexpr_t* expr) override {
        int my_id = next_id++;
        item_ids[expr] = my_id;

        if (expr->op == cot_call && expr->a) {
            carglist_t& arglist = *expr->a;
            for (size_t i = 0; i < arglist.size(); i++) {
                const carg_t& arg = arglist[i];

                CallArgInfo ai;
                ai.func_addr = func_addr;
                ai.call_item_id = my_id;
                ai.arg_idx = i;
                ai.arg_op = get_full_ctype_name(arg.op);

                auto it = item_ids.find((citem_t*)&arg);
                if (it != item_ids.end()) {
                    ai.arg_item_id = it->second;
                } else {
                    ai.arg_item_id = next_id++;
                    item_ids[(citem_t*)&arg] = ai.arg_item_id;
                }

                switch (arg.op) {
                    case cot_var:
                        ai.arg_var_idx = arg.v.idx;
                        if (cfunc && ai.arg_var_idx >= 0 && ai.arg_var_idx < cfunc->get_lvars()->size()) {
                            const lvar_t& lv = (*cfunc->get_lvars())[ai.arg_var_idx];
                            ai.arg_var_name = lv.name.c_str();
                            ai.arg_var_is_stk = lv.is_stk_var();
                            ai.arg_var_is_arg = lv.is_arg_var();
                        }
                        break;
                    case cot_obj:
                        ai.arg_obj_ea = arg.obj_ea;
                        {
                            qstring name;
                            if (get_name(&name, arg.obj_ea) > 0) {
                                ai.arg_obj_name = name.c_str();
                            }
                        }
                        break;
                    case cot_num:
                        ai.arg_num_value = arg.numval();
                        break;
                    case cot_str:
                        if (arg.string) ai.arg_str_value = arg.string;
                        break;
                    default:
                        break;
                }

                args.push_back(ai);
            }
        }

        return 0;
    }
};

// Collect call args for a single function
inline bool collect_call_args(std::vector<CallArgInfo>& args, ea_t func_addr) {
    args.clear();

    if (!hexrays_available()) return false;

    func_t* f = get_func(func_addr);
    if (!f) return false;

    hexrays_failure_t hf;
    cfuncptr_t cfunc = decompile(f, &hf);
    if (!cfunc) return false;

    call_args_collector_t collector(args, &*cfunc, func_addr);
    collector.apply_to(&cfunc->body, nullptr);

    return true;
}

// Collect call args for all functions
inline void collect_all_call_args(std::vector<CallArgInfo>& args) {
    args.clear();

    if (!hexrays_available()) return;

    size_t func_qty = get_func_qty();
    for (size_t i = 0; i < func_qty; i++) {
        func_t* f = getn_func(i);
        if (!f) continue;

        std::vector<CallArgInfo> func_args;
        if (collect_call_args(func_args, f->start_ea)) {
            args.insert(args.end(), func_args.begin(), func_args.end());
        }
    }
}

// ============================================================================
// Caches for full scans
// ============================================================================

struct LvarsCache {
    static std::vector<LvarInfo>& get() {
        static std::vector<LvarInfo> cache;
        return cache;
    }
    static void rebuild() { collect_all_lvars(get()); }
};

// Note: ctree and ctree_call_args use streaming generator tables (GeneratorTableDef)
// No static caches needed - iteration is lazy and owned by the query cursor

// ============================================================================
// Iterators for constraint pushdown
// ============================================================================

// Pseudocode iterator for single function
class PseudocodeInFuncIterator : public xsql::RowIterator {
    std::vector<PseudocodeLine> lines_;
    size_t idx_ = 0;
    bool started_ = false;

public:
    explicit PseudocodeInFuncIterator(ea_t func_addr) {
        collect_pseudocode(lines_, func_addr);
    }

    bool next() override {
        if (!started_) {
            started_ = true;
            if (lines_.empty()) return false;
            idx_ = 0;
            return true;
        }
        if (idx_ + 1 < lines_.size()) { ++idx_; return true; }
        idx_ = lines_.size();
        return false;
    }

    bool eof() const override { return started_ && idx_ >= lines_.size(); }

    void column(sqlite3_context* ctx, int col) override {
        if (idx_ >= lines_.size()) { sqlite3_result_null(ctx); return; }
        const auto& line = lines_[idx_];
        switch (col) {
            case 0: sqlite3_result_int64(ctx, line.func_addr); break;
            case 1: sqlite3_result_int(ctx, line.line_num); break;
            case 2: sqlite3_result_text(ctx, line.text.c_str(), -1, SQLITE_TRANSIENT); break;
            case 3:
                sqlite3_result_int64(ctx, line.ea != BADADDR ? line.ea : 0);
                break;
            case 4:
                if (!line.comment.empty())
                    sqlite3_result_text(ctx, line.comment.c_str(), -1, SQLITE_TRANSIENT);
                else
                    sqlite3_result_null(ctx);
                break;
            case 5:
                sqlite3_result_text(ctx, itp_to_name(line.comment_placement), -1, SQLITE_STATIC);
                break;
        }
    }

    int64_t rowid() const override { return static_cast<int64_t>(idx_); }
};

// Lvars iterator for single function
class LvarsInFuncIterator : public xsql::RowIterator {
    std::vector<LvarInfo> vars_;
    size_t idx_ = 0;
    bool started_ = false;

public:
    explicit LvarsInFuncIterator(ea_t func_addr) {
        collect_lvars(vars_, func_addr);
    }

    bool next() override {
        if (!started_) {
            started_ = true;
            if (vars_.empty()) return false;
            idx_ = 0;
            return true;
        }
        if (idx_ + 1 < vars_.size()) { ++idx_; return true; }
        idx_ = vars_.size();
        return false;
    }

    bool eof() const override { return started_ && idx_ >= vars_.size(); }

    void column(sqlite3_context* ctx, int col) override {
        if (idx_ >= vars_.size()) { sqlite3_result_null(ctx); return; }
        const auto& v = vars_[idx_];
        switch (col) {
            case 0: sqlite3_result_int64(ctx, v.func_addr); break;
            case 1: sqlite3_result_int(ctx, v.idx); break;
            case 2: sqlite3_result_text(ctx, v.name.c_str(), -1, SQLITE_TRANSIENT); break;
            case 3: sqlite3_result_text(ctx, v.type.c_str(), -1, SQLITE_TRANSIENT); break;
            case 4: sqlite3_result_int(ctx, v.size); break;
            case 5: sqlite3_result_int(ctx, v.is_arg ? 1 : 0); break;
            case 6: sqlite3_result_int(ctx, v.is_result ? 1 : 0); break;
            case 7: sqlite3_result_int(ctx, v.is_stk_var ? 1 : 0); break;
            case 8: sqlite3_result_int(ctx, v.is_reg_var ? 1 : 0); break;
            case 9: v.is_stk_var ? sqlite3_result_int64(ctx, v.stkoff) : sqlite3_result_null(ctx); break;
            case 10: v.is_reg_var ? sqlite3_result_int(ctx, v.mreg) : sqlite3_result_null(ctx); break;
        }
    }

    int64_t rowid() const override { return static_cast<int64_t>(idx_); }
};

// Ctree iterator for single function
class CtreeInFuncIterator : public xsql::RowIterator {
    std::vector<CtreeItem> items_;
    size_t idx_ = 0;
    bool started_ = false;

public:
    explicit CtreeInFuncIterator(ea_t func_addr) {
        collect_ctree(items_, func_addr);
    }

    bool next() override {
        if (!started_) {
            started_ = true;
            if (items_.empty()) return false;
            idx_ = 0;
            return true;
        }
        if (idx_ + 1 < items_.size()) { ++idx_; return true; }
        idx_ = items_.size();
        return false;
    }

    bool eof() const override { return started_ && idx_ >= items_.size(); }

    void column(sqlite3_context* ctx, int col) override {
        if (idx_ >= items_.size()) { sqlite3_result_null(ctx); return; }
        const auto& item = items_[idx_];
        switch (col) {
            case 0: sqlite3_result_int64(ctx, item.func_addr); break;
            case 1: sqlite3_result_int(ctx, item.item_id); break;
            case 2: sqlite3_result_int(ctx, item.is_expr ? 1 : 0); break;
            case 3: sqlite3_result_int(ctx, item.op); break;
            case 4: sqlite3_result_text(ctx, item.op_name.c_str(), -1, SQLITE_TRANSIENT); break;
            case 5: item.ea != BADADDR ? sqlite3_result_int64(ctx, item.ea) : sqlite3_result_null(ctx); break;
            case 6: item.parent_id >= 0 ? sqlite3_result_int(ctx, item.parent_id) : sqlite3_result_null(ctx); break;
            case 7: sqlite3_result_int(ctx, item.depth); break;
            case 8: item.x_id >= 0 ? sqlite3_result_int(ctx, item.x_id) : sqlite3_result_null(ctx); break;
            case 9: item.y_id >= 0 ? sqlite3_result_int(ctx, item.y_id) : sqlite3_result_null(ctx); break;
            case 10: item.z_id >= 0 ? sqlite3_result_int(ctx, item.z_id) : sqlite3_result_null(ctx); break;
            case 11: item.cond_id >= 0 ? sqlite3_result_int(ctx, item.cond_id) : sqlite3_result_null(ctx); break;
            case 12: item.then_id >= 0 ? sqlite3_result_int(ctx, item.then_id) : sqlite3_result_null(ctx); break;
            case 13: item.else_id >= 0 ? sqlite3_result_int(ctx, item.else_id) : sqlite3_result_null(ctx); break;
            case 14: item.body_id >= 0 ? sqlite3_result_int(ctx, item.body_id) : sqlite3_result_null(ctx); break;
            case 15: item.init_id >= 0 ? sqlite3_result_int(ctx, item.init_id) : sqlite3_result_null(ctx); break;
            case 16: item.step_id >= 0 ? sqlite3_result_int(ctx, item.step_id) : sqlite3_result_null(ctx); break;
            case 17: item.var_idx >= 0 ? sqlite3_result_int(ctx, item.var_idx) : sqlite3_result_null(ctx); break;
            case 18: item.obj_ea != BADADDR ? sqlite3_result_int64(ctx, item.obj_ea) : sqlite3_result_null(ctx); break;
            case 19: item.op == cot_num ? sqlite3_result_int64(ctx, item.num_value) : sqlite3_result_null(ctx); break;
            case 20: !item.str_value.empty() ? sqlite3_result_text(ctx, item.str_value.c_str(), -1, SQLITE_TRANSIENT) : sqlite3_result_null(ctx); break;
            case 21: !item.helper_name.empty() ? sqlite3_result_text(ctx, item.helper_name.c_str(), -1, SQLITE_TRANSIENT) : sqlite3_result_null(ctx); break;
            case 22: (item.op == cot_memref || item.op == cot_memptr) ? sqlite3_result_int(ctx, item.member_offset) : sqlite3_result_null(ctx); break;
            case 23: !item.var_name.empty() ? sqlite3_result_text(ctx, item.var_name.c_str(), -1, SQLITE_TRANSIENT) : sqlite3_result_null(ctx); break;
            case 24: item.op == cot_var ? sqlite3_result_int(ctx, item.var_is_stk ? 1 : 0) : sqlite3_result_null(ctx); break;
            case 25: item.op == cot_var ? sqlite3_result_int(ctx, item.var_is_reg ? 1 : 0) : sqlite3_result_null(ctx); break;
            case 26: item.op == cot_var ? sqlite3_result_int(ctx, item.var_is_arg ? 1 : 0) : sqlite3_result_null(ctx); break;
            case 27: !item.obj_name.empty() ? sqlite3_result_text(ctx, item.obj_name.c_str(), -1, SQLITE_TRANSIENT) : sqlite3_result_null(ctx); break;
        }
    }

    int64_t rowid() const override { return static_cast<int64_t>(idx_); }
};

// Call args iterator for single function
class CallArgsInFuncIterator : public xsql::RowIterator {
    std::vector<CallArgInfo> args_;
    size_t idx_ = 0;
    bool started_ = false;

public:
    explicit CallArgsInFuncIterator(ea_t func_addr) {
        collect_call_args(args_, func_addr);
    }

    bool next() override {
        if (!started_) {
            started_ = true;
            if (args_.empty()) return false;
            idx_ = 0;
            return true;
        }
        if (idx_ + 1 < args_.size()) { ++idx_; return true; }
        idx_ = args_.size();
        return false;
    }

    bool eof() const override { return started_ && idx_ >= args_.size(); }

    void column(sqlite3_context* ctx, int col) override {
        if (idx_ >= args_.size()) { sqlite3_result_null(ctx); return; }
        const auto& ai = args_[idx_];
        switch (col) {
            case 0: sqlite3_result_int64(ctx, ai.func_addr); break;
            case 1: sqlite3_result_int(ctx, ai.call_item_id); break;
            case 2: sqlite3_result_int(ctx, ai.arg_idx); break;
            case 3: ai.arg_item_id >= 0 ? sqlite3_result_int(ctx, ai.arg_item_id) : sqlite3_result_null(ctx); break;
            case 4: sqlite3_result_text(ctx, ai.arg_op.c_str(), -1, SQLITE_TRANSIENT); break;
            case 5: ai.arg_var_idx >= 0 ? sqlite3_result_int(ctx, ai.arg_var_idx) : sqlite3_result_null(ctx); break;
            case 6: !ai.arg_var_name.empty() ? sqlite3_result_text(ctx, ai.arg_var_name.c_str(), -1, SQLITE_TRANSIENT) : sqlite3_result_null(ctx); break;
            case 7: ai.arg_var_idx >= 0 ? sqlite3_result_int(ctx, ai.arg_var_is_stk ? 1 : 0) : sqlite3_result_null(ctx); break;
            case 8: ai.arg_var_idx >= 0 ? sqlite3_result_int(ctx, ai.arg_var_is_arg ? 1 : 0) : sqlite3_result_null(ctx); break;
            case 9: ai.arg_obj_ea != BADADDR ? sqlite3_result_int64(ctx, ai.arg_obj_ea) : sqlite3_result_null(ctx); break;
            case 10: !ai.arg_obj_name.empty() ? sqlite3_result_text(ctx, ai.arg_obj_name.c_str(), -1, SQLITE_TRANSIENT) : sqlite3_result_null(ctx); break;
            case 11: ai.arg_op == "cot_num" ? sqlite3_result_int64(ctx, ai.arg_num_value) : sqlite3_result_null(ctx); break;
            case 12: !ai.arg_str_value.empty() ? sqlite3_result_text(ctx, ai.arg_str_value.c_str(), -1, SQLITE_TRANSIENT) : sqlite3_result_null(ctx); break;
        }
    }

    int64_t rowid() const override { return static_cast<int64_t>(idx_); }
};

// ============================================================================
// Generators for full scans (lazy, one function at a time)
// ============================================================================

class CtreeGenerator : public xsql::Generator<CtreeItem> {
    size_t func_idx_ = 0;
    std::vector<CtreeItem> items_;
    size_t idx_ = 0;
    sqlite3_int64 rowid_ = -1;
    bool started_ = false;

    bool load_next_func() {
        if (!hexrays_available()) return false;

        size_t func_qty = get_func_qty();
        while (func_idx_ < func_qty) {
            func_t* f = getn_func(func_idx_++);
            if (!f) continue;

            if (collect_ctree(items_, f->start_ea) && !items_.empty()) {
                idx_ = 0;
                return true;
            }
        }
        return false;
    }

public:
    bool next() override {
        if (!started_) {
            started_ = true;
            if (!load_next_func()) return false;
            rowid_ = 0;
            return true;
        }

        if (idx_ + 1 < items_.size()) {
            ++idx_;
            ++rowid_;
            return true;
        }

        if (!load_next_func()) return false;
        ++rowid_;
        return true;
    }

    const CtreeItem& current() const override { return items_[idx_]; }

    sqlite3_int64 rowid() const override { return rowid_; }
};

class CallArgsGenerator : public xsql::Generator<CallArgInfo> {
    size_t func_idx_ = 0;
    std::vector<CallArgInfo> args_;
    size_t idx_ = 0;
    sqlite3_int64 rowid_ = -1;
    bool started_ = false;

    bool load_next_func() {
        if (!hexrays_available()) return false;

        size_t func_qty = get_func_qty();
        while (func_idx_ < func_qty) {
            func_t* f = getn_func(func_idx_++);
            if (!f) continue;

            if (collect_call_args(args_, f->start_ea) && !args_.empty()) {
                idx_ = 0;
                return true;
            }
        }
        return false;
    }

public:
    bool next() override {
        if (!started_) {
            started_ = true;
            if (!load_next_func()) return false;
            rowid_ = 0;
            return true;
        }

        if (idx_ + 1 < args_.size()) {
            ++idx_;
            ++rowid_;
            return true;
        }

        if (!load_next_func()) return false;
        ++rowid_;
        return true;
    }

    const CallArgInfo& current() const override { return args_[idx_]; }

    sqlite3_int64 rowid() const override { return rowid_; }
};

// ============================================================================
// Table Definitions
// ============================================================================

// Helper: Set or delete a decompiler comment at an ea within a function
inline bool set_decompiler_comment(ea_t func_addr, ea_t target_ea, const char* comment, item_preciser_t itp = ITP_SEMI) {
    if (!hexrays_available()) return false;
    if (target_ea == BADADDR || target_ea == 0) return false;

    func_t* f = get_func(func_addr);
    if (!f) return false;

    hexrays_failure_t hf;
    cfuncptr_t cfunc = decompile(f, &hf);
    if (!cfunc) return false;

    treeloc_t loc;
    loc.ea = target_ea;
    loc.itp = itp;

    // set_user_cmt with empty/nullptr deletes the comment
    cfunc->set_user_cmt(loc, (comment && comment[0]) ? comment : nullptr);

    cfunc->save_user_cmts();
    invalidate_decompiler_cache(func_addr);
    return true;
}

inline CachedTableDef<PseudocodeLine> define_pseudocode() {
    return cached_table<PseudocodeLine>("pseudocode")
        .estimate_rows([]() -> size_t { return get_func_qty() * 20; })
        .cache_builder([](std::vector<PseudocodeLine>& cache) {
            collect_all_pseudocode(cache);
        })
        .row_populator([](PseudocodeLine& row, int argc, sqlite3_value** argv) {
            // argv[2]=func_addr, argv[3]=line_num, argv[4]=line, argv[5]=ea, argv[6]=comment, argv[7]=comment_placement
            if (argc > 2) row.func_addr = static_cast<ea_t>(sqlite3_value_int64(argv[2]));
            if (argc > 3) row.line_num = sqlite3_value_int(argv[3]);
            if (argc > 5) row.ea = static_cast<ea_t>(sqlite3_value_int64(argv[5]));
            if (argc > 7 && sqlite3_value_type(argv[7]) != SQLITE_NULL) {
                const char* p = reinterpret_cast<const char*>(sqlite3_value_text(argv[7]));
                row.comment_placement = name_to_itp(p);
            }
        })
        .column_int64("func_addr", [](const PseudocodeLine& r) -> int64_t { return r.func_addr; })
        .column_int("line_num", [](const PseudocodeLine& r) -> int { return r.line_num; })
        .column_text("line", [](const PseudocodeLine& r) -> std::string { return r.text; })
        .column_int64("ea", [](const PseudocodeLine& r) -> int64_t {
            return r.ea != BADADDR ? r.ea : 0;
        })
        .column_text_rw("comment",
            [](const PseudocodeLine& r) -> std::string { return r.comment; },
            [](PseudocodeLine& row, sqlite3_value* val) -> bool {
                if (row.ea == BADADDR || row.ea == 0) return false;
                const char* text = nullptr;
                if (sqlite3_value_type(val) != SQLITE_NULL) {
                    text = reinterpret_cast<const char*>(sqlite3_value_text(val));
                }
                bool ok = set_decompiler_comment(row.func_addr, row.ea, text, row.comment_placement);
                if (ok) {
                    row.comment = text ? text : "";
                }
                return ok;
            })
        .column_text_rw("comment_placement",
            [](const PseudocodeLine& r) -> std::string { return itp_to_name(r.comment_placement); },
            [](PseudocodeLine& row, sqlite3_value* val) -> bool {
                if (sqlite3_value_type(val) == SQLITE_NULL) return false;
                const char* name = reinterpret_cast<const char*>(sqlite3_value_text(val));
                row.comment_placement = name_to_itp(name);
                return true;  // just sets the field, actual comment write happens in comment setter
            })
        .filter_eq("func_addr", [](int64_t func_addr) -> std::unique_ptr<xsql::RowIterator> {
            return std::make_unique<PseudocodeInFuncIterator>(static_cast<ea_t>(func_addr));
        }, 50.0)
        .build();
}

// Helper: Rename lvar by func_addr and lvar index
inline bool rename_lvar_at(ea_t func_addr, int lvar_idx, const char* new_name) {
    if (!hexrays_available())
        return false;

    func_t* f = get_func(func_addr);
    if (!f)
        return false;

    hexrays_failure_t hf;
    cfuncptr_t cfunc = decompile(f, &hf);
    if (!cfunc)
        return false;

    lvars_t* lvars = cfunc->get_lvars();
    if (!lvars || lvar_idx < 0 || static_cast<size_t>(lvar_idx) >= lvars->size())
        return false;

    lvar_t& lv = (*lvars)[lvar_idx];

    // Use modify_user_lvar_info to persist the name change
    lvar_saved_info_t lsi;
    lsi.ll = lv;  // Copy lvar_locator_t
    lsi.name = new_name;
    lsi.flags = 0;  // No special flags needed

    bool ok = modify_user_lvar_info(func_addr, MLI_NAME, lsi);
    if (ok) invalidate_decompiler_cache(func_addr);
    return ok;
}

// Helper: Set lvar type by func_addr and lvar index
inline bool set_lvar_type_at(ea_t func_addr, int lvar_idx, const char* type_str) {
    if (!hexrays_available())
        return false;

    func_t* f = get_func(func_addr);
    if (!f)
        return false;

    hexrays_failure_t hf;
    cfuncptr_t cfunc = decompile(f, &hf);
    if (!cfunc)
        return false;

    lvars_t* lvars = cfunc->get_lvars();
    if (!lvars || lvar_idx < 0 || static_cast<size_t>(lvar_idx) >= lvars->size())
        return false;

    lvar_t& lv = (*lvars)[lvar_idx];

    // Parse type string - try named type first, then parse as declaration
    tinfo_t tif;
    if (!tif.get_named_type(nullptr, type_str)) {
        // Use parse_decl for C declaration parsing
        qstring decl;
        decl.sprnt("%s __x;", type_str);
        qstring out_name;
        if (!parse_decl(&tif, &out_name, nullptr, decl.c_str(), PT_SIL))
            return false;
    }

    // Use modify_user_lvar_info to persist the type change
    lvar_saved_info_t lsi;
    lsi.ll = lv;  // Copy lvar_locator_t
    lsi.type = tif;
    lsi.flags = 0;  // No special flags needed

    bool ok = modify_user_lvar_info(func_addr, MLI_TYPE, lsi);
    if (ok) invalidate_decompiler_cache(func_addr);
    return ok;
}

inline VTableDef define_ctree_lvars() {
    return table("ctree_lvars")
        .count([]() { LvarsCache::rebuild(); return LvarsCache::get().size(); })
        .column_int64("func_addr", [](size_t i) -> int64_t {
            auto& c = LvarsCache::get(); return i < c.size() ? c[i].func_addr : 0;
        })
        .column_int("idx", [](size_t i) -> int {
            auto& c = LvarsCache::get(); return i < c.size() ? c[i].idx : 0;
        })
        .column_text_rw("name",
            // Getter
            [](size_t i) -> std::string {
                auto& c = LvarsCache::get();
                return i < c.size() ? c[i].name : "";
            },
            // Setter - rename lvar
            [](size_t i, const char* new_name) -> bool {
                auto& c = LvarsCache::get();
                if (i >= c.size()) return false;
                ea_t func_addr = c[i].func_addr;
                int idx = c[i].idx;
                bool ok = rename_lvar_at(func_addr, idx, new_name);
                if (ok) {
                    // Update cache entry
                    c[i].name = new_name;
                }
                return ok;
            })
        .column_text_rw("type",
            // Getter
            [](size_t i) -> std::string {
                auto& c = LvarsCache::get();
                return i < c.size() ? c[i].type : "";
            },
            // Setter - change lvar type
            [](size_t i, const char* new_type) -> bool {
                auto& c = LvarsCache::get();
                if (i >= c.size()) return false;
                ea_t func_addr = c[i].func_addr;
                int idx = c[i].idx;
                bool ok = set_lvar_type_at(func_addr, idx, new_type);
                if (ok) {
                    // Update cache entry
                    c[i].type = new_type;
                }
                return ok;
            })
        .column_int("size", [](size_t i) -> int {
            auto& c = LvarsCache::get(); return i < c.size() ? c[i].size : 0;
        })
        .column_int("is_arg", [](size_t i) -> int {
            auto& c = LvarsCache::get(); return i < c.size() ? (c[i].is_arg ? 1 : 0) : 0;
        })
        .column_int("is_result", [](size_t i) -> int {
            auto& c = LvarsCache::get(); return i < c.size() ? (c[i].is_result ? 1 : 0) : 0;
        })
        .column_int("is_stk_var", [](size_t i) -> int {
            auto& c = LvarsCache::get(); return i < c.size() ? (c[i].is_stk_var ? 1 : 0) : 0;
        })
        .column_int("is_reg_var", [](size_t i) -> int {
            auto& c = LvarsCache::get(); return i < c.size() ? (c[i].is_reg_var ? 1 : 0) : 0;
        })
        .column_int64("stkoff", [](size_t i) -> int64_t {
            auto& c = LvarsCache::get(); return i < c.size() ? c[i].stkoff : 0;
        })
        .column_int("mreg", [](size_t i) -> int {
            auto& c = LvarsCache::get(); return i < c.size() ? c[i].mreg : 0;
        })
        .filter_eq("func_addr", [](int64_t func_addr) -> std::unique_ptr<xsql::RowIterator> {
            return std::make_unique<LvarsInFuncIterator>(static_cast<ea_t>(func_addr));
        }, 10.0)
        .build();
}

inline GeneratorTableDef<CtreeItem> define_ctree() {
    return generator_table<CtreeItem>("ctree")
        // Cheap estimate for query planning (doesn't decompile)
        .estimate_rows([]() -> size_t {
            // Heuristic: ~50 AST items per function
            return get_func_qty() * 50;
        })
        // Full scan generator (decompiles one function at a time)
        .generator([]() -> std::unique_ptr<xsql::Generator<CtreeItem>> {
            return std::make_unique<CtreeGenerator>();
        })
        .column_int64("func_addr", [](const CtreeItem& r) -> int64_t { return r.func_addr; })
        .column_int("item_id", [](const CtreeItem& r) -> int { return r.item_id; })
        .column_int("is_expr", [](const CtreeItem& r) -> int { return r.is_expr ? 1 : 0; })
        .column_int("op", [](const CtreeItem& r) -> int { return r.op; })
        .column_text("op_name", [](const CtreeItem& r) -> std::string { return r.op_name; })
        .column_int64("ea", [](const CtreeItem& r) -> int64_t { return r.ea != BADADDR ? r.ea : 0; })
        .column_int("parent_id", [](const CtreeItem& r) -> int { return r.parent_id; })
        .column_int("depth", [](const CtreeItem& r) -> int { return r.depth; })
        .column_int("x_id", [](const CtreeItem& r) -> int { return r.x_id; })
        .column_int("y_id", [](const CtreeItem& r) -> int { return r.y_id; })
        .column_int("z_id", [](const CtreeItem& r) -> int { return r.z_id; })
        .column_int("cond_id", [](const CtreeItem& r) -> int { return r.cond_id; })
        .column_int("then_id", [](const CtreeItem& r) -> int { return r.then_id; })
        .column_int("else_id", [](const CtreeItem& r) -> int { return r.else_id; })
        .column_int("body_id", [](const CtreeItem& r) -> int { return r.body_id; })
        .column_int("init_id", [](const CtreeItem& r) -> int { return r.init_id; })
        .column_int("step_id", [](const CtreeItem& r) -> int { return r.step_id; })
        .column_int("var_idx", [](const CtreeItem& r) -> int { return r.var_idx; })
        .column_int64("obj_ea", [](const CtreeItem& r) -> int64_t { return r.obj_ea != BADADDR ? r.obj_ea : 0; })
        .column_int64("num_value", [](const CtreeItem& r) -> int64_t { return r.num_value; })
        .column_text("str_value", [](const CtreeItem& r) -> std::string { return r.str_value; })
        .column_text("helper_name", [](const CtreeItem& r) -> std::string { return r.helper_name; })
        .column_int("member_offset", [](const CtreeItem& r) -> int { return r.member_offset; })
        .column_text("var_name", [](const CtreeItem& r) -> std::string { return r.var_name; })
        .column_int("var_is_stk", [](const CtreeItem& r) -> int { return r.var_is_stk ? 1 : 0; })
        .column_int("var_is_reg", [](const CtreeItem& r) -> int { return r.var_is_reg ? 1 : 0; })
        .column_int("var_is_arg", [](const CtreeItem& r) -> int { return r.var_is_arg ? 1 : 0; })
        .column_text("obj_name", [](const CtreeItem& r) -> std::string { return r.obj_name; })
        .filter_eq("func_addr", [](int64_t func_addr) -> std::unique_ptr<xsql::RowIterator> {
            return std::make_unique<CtreeInFuncIterator>(static_cast<ea_t>(func_addr));
        }, 100.0, 100.0)
        .build();
}

inline GeneratorTableDef<CallArgInfo> define_ctree_call_args() {
    return generator_table<CallArgInfo>("ctree_call_args")
        // Cheap estimate for query planning
        .estimate_rows([]() -> size_t {
            // Heuristic: ~20 call args per function
            return get_func_qty() * 20;
        })
        // Full scan generator (decompiles one function at a time)
        .generator([]() -> std::unique_ptr<xsql::Generator<CallArgInfo>> {
            return std::make_unique<CallArgsGenerator>();
        })
        .column_int64("func_addr", [](const CallArgInfo& r) -> int64_t { return r.func_addr; })
        .column_int("call_item_id", [](const CallArgInfo& r) -> int { return r.call_item_id; })
        .column_int("arg_idx", [](const CallArgInfo& r) -> int { return r.arg_idx; })
        .column_int("arg_item_id", [](const CallArgInfo& r) -> int { return r.arg_item_id; })
        .column_text("arg_op", [](const CallArgInfo& r) -> std::string { return r.arg_op; })
        .column_int("arg_var_idx", [](const CallArgInfo& r) -> int { return r.arg_var_idx; })
        .column_text("arg_var_name", [](const CallArgInfo& r) -> std::string { return r.arg_var_name; })
        .column_int("arg_var_is_stk", [](const CallArgInfo& r) -> int { return r.arg_var_is_stk ? 1 : 0; })
        .column_int("arg_var_is_arg", [](const CallArgInfo& r) -> int { return r.arg_var_is_arg ? 1 : 0; })
        .column_int64("arg_obj_ea", [](const CallArgInfo& r) -> int64_t { return r.arg_obj_ea != BADADDR ? r.arg_obj_ea : 0; })
        .column_text("arg_obj_name", [](const CallArgInfo& r) -> std::string { return r.arg_obj_name; })
        .column_int64("arg_num_value", [](const CallArgInfo& r) -> int64_t { return r.arg_num_value; })
        .column_text("arg_str_value", [](const CallArgInfo& r) -> std::string { return r.arg_str_value; })
        .filter_eq("func_addr", [](int64_t func_addr) -> std::unique_ptr<xsql::RowIterator> {
            return std::make_unique<CallArgsInFuncIterator>(static_cast<ea_t>(func_addr));
        }, 100.0, 100.0)
        .build();
}

// ============================================================================
// Views Registration
// ============================================================================

inline bool register_ctree_views(xsql::Database& db) {

    const char* v_calls = R"(
        CREATE VIEW IF NOT EXISTS ctree_v_calls AS
        SELECT
            c.func_addr, c.item_id, c.ea,
            x.op_name AS callee_op,
            NULLIF(x.obj_ea, 0) AS callee_addr,
            x.obj_name AS callee_name,
            x.helper_name,
            (SELECT COUNT(*) FROM ctree_call_args a
             WHERE a.func_addr = c.func_addr AND a.call_item_id = c.item_id) AS arg_count
        FROM ctree c
        LEFT JOIN ctree x ON x.func_addr = c.func_addr AND x.item_id = c.x_id
        WHERE c.op_name = 'cot_call'
    )";
    db.exec(v_calls);

    const char* v_loops = R"(
        CREATE VIEW IF NOT EXISTS ctree_v_loops AS
        SELECT * FROM ctree
        WHERE op_name IN ('cit_for', 'cit_while', 'cit_do')
    )";
    db.exec(v_loops);

    const char* v_ifs = R"(
        CREATE VIEW IF NOT EXISTS ctree_v_ifs AS
        SELECT * FROM ctree WHERE op_name = 'cit_if'
    )";
    db.exec(v_ifs);

    const char* v_signed = R"(
        CREATE VIEW IF NOT EXISTS ctree_v_signed_ops AS
        SELECT * FROM ctree WHERE op_name IN (
            'cot_sge', 'cot_sle', 'cot_sgt', 'cot_slt',
            'cot_sshr', 'cot_sdiv', 'cot_smod',
            'cot_asgsshr', 'cot_asgsdiv', 'cot_asgsmod'
        )
    )";
    db.exec(v_signed);

    const char* v_cmp = R"(
        CREATE VIEW IF NOT EXISTS ctree_v_comparisons AS
        SELECT
            c.func_addr, c.item_id, c.ea, c.op_name,
            lhs.op_name AS lhs_op, lhs.var_idx AS lhs_var_idx, lhs.num_value AS lhs_num,
            rhs.op_name AS rhs_op, rhs.var_idx AS rhs_var_idx, rhs.num_value AS rhs_num
        FROM ctree c
        LEFT JOIN ctree lhs ON lhs.func_addr = c.func_addr AND lhs.item_id = c.x_id
        LEFT JOIN ctree rhs ON rhs.func_addr = c.func_addr AND rhs.item_id = c.y_id
        WHERE c.op_name IN (
            'cot_eq', 'cot_ne',
            'cot_sge', 'cot_uge', 'cot_sle', 'cot_ule',
            'cot_sgt', 'cot_ugt', 'cot_slt', 'cot_ult'
        )
    )";
    db.exec(v_cmp);

    const char* v_asg = R"(
        CREATE VIEW IF NOT EXISTS ctree_v_assignments AS
        SELECT
            c.func_addr, c.item_id, c.ea, c.op_name,
            lhs.op_name AS lhs_op, lhs.var_idx AS lhs_var_idx,
            lhs.var_is_stk AS lhs_is_stk, lhs.obj_ea AS lhs_obj,
            rhs.op_name AS rhs_op, rhs.var_idx AS rhs_var_idx, rhs.num_value AS rhs_num
        FROM ctree c
        LEFT JOIN ctree lhs ON lhs.func_addr = c.func_addr AND lhs.item_id = c.x_id
        LEFT JOIN ctree rhs ON rhs.func_addr = c.func_addr AND rhs.item_id = c.y_id
        WHERE c.op_name LIKE 'cot_asg%'
    )";
    db.exec(v_asg);

    const char* v_deref = R"(
        CREATE VIEW IF NOT EXISTS ctree_v_derefs AS
        SELECT
            c.func_addr, c.item_id, c.ea,
            x.op_name AS ptr_op, x.var_idx AS ptr_var_idx,
            x.var_is_stk AS ptr_is_stk, x.var_is_arg AS ptr_is_arg
        FROM ctree c
        LEFT JOIN ctree x ON x.func_addr = c.func_addr AND x.item_id = c.x_id
        WHERE c.op_name IN ('cot_ptr', 'cot_memptr')
    )";
    db.exec(v_deref);

    const char* v_calls_in_loops = R"(
        CREATE VIEW IF NOT EXISTS ctree_v_calls_in_loops AS
        WITH RECURSIVE loop_contents(func_addr, item_id, loop_id, loop_op, depth) AS (
            SELECT func_addr, item_id, item_id, op_name, 0
            FROM ctree
            WHERE op_name IN ('cit_for', 'cit_while', 'cit_do')
            UNION ALL
            SELECT c.func_addr, c.item_id, lc.loop_id, lc.loop_op, lc.depth + 1
            FROM ctree c
            JOIN loop_contents lc ON c.func_addr = lc.func_addr AND c.parent_id = lc.item_id
            WHERE lc.depth < 50
        )
        SELECT DISTINCT
            c.func_addr, c.item_id, c.ea, c.depth AS call_depth,
            lc.loop_id, lc.loop_op,
            NULLIF(x.obj_ea, 0) AS callee_addr, x.obj_name AS callee_name, x.helper_name
        FROM loop_contents lc
        JOIN ctree c ON c.func_addr = lc.func_addr AND c.item_id = lc.item_id
        LEFT JOIN ctree x ON x.func_addr = c.func_addr AND x.item_id = c.x_id
        WHERE c.op_name = 'cot_call'
    )";
    db.exec(v_calls_in_loops);

    const char* v_calls_in_ifs = R"(
        CREATE VIEW IF NOT EXISTS ctree_v_calls_in_ifs AS
        WITH RECURSIVE if_contents(func_addr, item_id, if_id, branch, depth) AS (
            SELECT c.func_addr, c.item_id, p.item_id, 'then', 0
            FROM ctree c
            JOIN ctree p ON c.func_addr = p.func_addr AND c.item_id = p.then_id
            WHERE p.op_name = 'cit_if'
            UNION ALL
            SELECT c.func_addr, c.item_id, p.item_id, 'else', 0
            FROM ctree c
            JOIN ctree p ON c.func_addr = p.func_addr AND c.item_id = p.else_id
            WHERE p.op_name = 'cit_if'
            UNION ALL
            SELECT c.func_addr, c.item_id, ic.if_id, ic.branch, ic.depth + 1
            FROM ctree c
            JOIN if_contents ic ON c.func_addr = ic.func_addr AND c.parent_id = ic.item_id
            WHERE ic.depth < 50
        )
        SELECT DISTINCT
            c.func_addr, c.item_id, c.ea, c.depth AS call_depth,
            ic.if_id, ic.branch,
            NULLIF(x.obj_ea, 0) AS callee_addr, x.obj_name AS callee_name, x.helper_name
        FROM if_contents ic
        JOIN ctree c ON c.func_addr = ic.func_addr AND c.item_id = ic.item_id
        LEFT JOIN ctree x ON x.func_addr = c.func_addr AND x.item_id = c.x_id
        WHERE c.op_name = 'cot_call'
    )";
    db.exec(v_calls_in_ifs);

    const char* v_leaf_funcs = R"(
        CREATE VIEW IF NOT EXISTS ctree_v_leaf_funcs AS
        SELECT f.address, f.name
        FROM funcs f
        WHERE
            -- Only consider functions that Hex-Rays can decompile (avoid false "leaf" results
            -- when decompilation fails and the ctree tables return empty rows).
            EXISTS (
                SELECT 1 FROM ctree t
                WHERE t.func_addr = f.address
                LIMIT 1
            )
            AND NOT EXISTS (
                SELECT 1 FROM ctree_v_calls c
                WHERE c.func_addr = f.address AND c.callee_addr IS NOT NULL
                LIMIT 1
            )
    )";
    db.exec(v_leaf_funcs);

    const char* v_call_chains = R"(
        CREATE VIEW IF NOT EXISTS ctree_v_call_chains AS
        WITH RECURSIVE call_chain(root_func, current_func, depth) AS (
            SELECT func_addr, callee_addr, 1
            FROM ctree_v_calls
            WHERE callee_addr IS NOT NULL
            UNION ALL
            SELECT cc.root_func, c.callee_addr, cc.depth + 1
            FROM call_chain cc
            JOIN ctree_v_calls c ON c.func_addr = cc.current_func
            WHERE cc.depth < 10 AND c.callee_addr IS NOT NULL
        )
        SELECT root_func, current_func, depth FROM call_chain
    )";
    db.exec(v_call_chains);

    // Return statements with return value details
    const char* v_returns = R"(
        CREATE VIEW IF NOT EXISTS ctree_v_returns AS
        SELECT
            ret.func_addr,
            ret.item_id,
            ret.ea,
            val.op_name AS return_op,
            val.item_id AS return_item_id,
            -- Numeric return (cot_num)
            CASE WHEN val.op_name = 'cot_num' THEN val.num_value ELSE NULL END AS return_num,
            -- String return (cot_str)
            CASE WHEN val.op_name = 'cot_str' THEN val.str_value ELSE NULL END AS return_str,
            -- Variable return (cot_var)
            CASE WHEN val.op_name = 'cot_var' THEN val.var_name ELSE NULL END AS return_var,
            CASE WHEN val.op_name = 'cot_var' THEN val.var_idx ELSE NULL END AS return_var_idx,
            CASE WHEN val.op_name = 'cot_var' THEN val.var_is_arg ELSE NULL END AS returns_arg,
            CASE WHEN val.op_name = 'cot_var' THEN val.var_is_stk ELSE NULL END AS returns_stk_var,
            -- Object/symbol return (cot_obj)
            CASE WHEN val.op_name = 'cot_obj' THEN val.obj_name ELSE NULL END AS return_obj,
            CASE WHEN val.op_name = 'cot_obj' THEN val.obj_ea ELSE NULL END AS return_obj_ea,
            -- Call result return (cot_call) - returning result of another call
            CASE WHEN val.op_name = 'cot_call' THEN 1 ELSE 0 END AS returns_call_result
        FROM ctree ret
        LEFT JOIN ctree val ON val.func_addr = ret.func_addr AND val.item_id = ret.x_id
        WHERE ret.op_name = 'cit_return'
    )";
    db.exec(v_returns);

    return true;
}

// ============================================================================
// Registry
// ============================================================================

struct DecompilerRegistry {
    // Cached table (shared cache, write support)
    CachedTableDef<PseudocodeLine> pseudocode;
    // Index-based table
    VTableDef ctree_lvars;
    // Generator tables (lazy full scans)
    GeneratorTableDef<CtreeItem> ctree;
    GeneratorTableDef<CallArgInfo> ctree_call_args;

    DecompilerRegistry()
        : pseudocode(define_pseudocode())
        , ctree_lvars(define_ctree_lvars())
        , ctree(define_ctree())
        , ctree_call_args(define_ctree_call_args())
    {}

    void register_all(xsql::Database& db) {
        // Initialize Hex-Rays decompiler ONCE at startup
        // If unavailable, skip registering decompiler tables entirely
        if (!init_hexrays()) {
            // Hex-Rays not available - don't register decompiler tables
            return;
        }

        // Cached table (query-scoped cache, freed when no cursors reference it)
        db.register_cached_table("ida_pseudocode", &pseudocode);
        db.create_table("pseudocode", "ida_pseudocode");

        // Index-based table
        db.register_table("ida_ctree_lvars", &ctree_lvars);
        db.create_table("ctree_lvars", "ida_ctree_lvars");

        // Generator tables (lazy full scans, stop work early with LIMIT)
        db.register_generator_table("ida_ctree", &ctree);
        db.create_table("ctree", "ida_ctree");

        db.register_generator_table("ida_ctree_call_args", &ctree_call_args);
        db.create_table("ctree_call_args", "ida_ctree_call_args");

        register_ctree_views(db);
    }
};

} // namespace decompiler
} // namespace idasql

```

`src/lib/include/idasql/disassembly.hpp`:

```hpp
/**
 * disassembly.hpp - Disassembly-level SQL tables
 *
 * Provides instruction-level analysis via SQLite virtual tables.
 * Parallels the decompiler.hpp ctree tables but at the disassembly level.
 *
 * Tables:
 *   disasm_calls    - All call instructions with callee info
 *   disasm_loops    - Detected loops via back-edge analysis
 *
 * Views:
 *   disasm_v_leaf_funcs     - Functions with no outgoing calls
 *   disasm_v_call_chains    - Recursive call chain paths up to depth 10
 *   disasm_v_calls_in_loops - Calls that occur inside detected loops
 *   disasm_v_funcs_with_loops - Functions that contain loops
 *
 * All tables support constraint pushdown on func_addr for efficient queries.
 */

#pragma once

#include <idasql/platform.hpp>

#include <idasql/vtable.hpp>
#include <xsql/database.hpp>

#include <idasql/platform_undef.hpp>

// IDA SDK headers
#include <ida.hpp>
#include <funcs.hpp>
#include <ua.hpp>      // decode_insn, insn_t, is_call_insn
#include <idp.hpp>     // is_call_insn
#include <xref.hpp>    // get_first_fcref_from
#include <name.hpp>    // get_name
#include <gdl.hpp>     // qflow_chart_t for CFG analysis

#include <vector>
#include <string>

namespace idasql {
namespace disassembly {

// ============================================================================
// Helper functions
// ============================================================================

inline std::string safe_name(ea_t ea) {
    qstring name;
    get_name(&name, ea);
    return std::string(name.c_str());
}

// ============================================================================
// DISASM_CALLS Table
// All call instructions across all functions
// ============================================================================

struct DisasmCallInfo {
    ea_t func_addr;     // Function containing this call
    ea_t ea;            // Address of call instruction
    ea_t callee_addr;   // Target of call (BADADDR if unknown)
    std::string callee_name;
};

// ============================================================================
// DisasmCallsInFuncIterator - Constraint pushdown for func_addr = X
// Iterates calls in a single function without building the full cache
// ============================================================================

class DisasmCallsInFuncIterator : public xsql::RowIterator {
    ea_t func_addr_;
    func_t* pfn_ = nullptr;
    func_item_iterator_t fii_;
    bool started_ = false;
    bool valid_ = false;

    // Current call info
    ea_t current_ea_ = BADADDR;
    ea_t callee_addr_ = BADADDR;
    std::string callee_name_;

    bool find_next_call() {
        while (fii_.next_code()) {
            ea_t ea = fii_.current();
            insn_t insn;
            if (decode_insn(&insn, ea) > 0 && is_call_insn(insn)) {
                current_ea_ = ea;
                callee_addr_ = get_first_fcref_from(ea);
                if (callee_addr_ != BADADDR) {
                    callee_name_ = safe_name(callee_addr_);
                } else {
                    callee_name_.clear();
                }
                return true;
            }
        }
        return false;
    }

public:
    explicit DisasmCallsInFuncIterator(ea_t func_addr)
        : func_addr_(func_addr)
    {
        pfn_ = get_func(func_addr_);
    }

    bool next() override {
        if (!pfn_) return false;

        if (!started_) {
            started_ = true;
            // Initialize iterator and find first code item
            if (!fii_.set(pfn_)) {
                valid_ = false;
                return false;
            }
            // Check if first item is a call
            ea_t ea = fii_.current();
            insn_t insn;
            if (decode_insn(&insn, ea) > 0 && is_call_insn(insn)) {
                current_ea_ = ea;
                callee_addr_ = get_first_fcref_from(ea);
                if (callee_addr_ != BADADDR) {
                    callee_name_ = safe_name(callee_addr_);
                } else {
                    callee_name_.clear();
                }
                valid_ = true;
                return true;
            }
            // First item wasn't a call, find next
            valid_ = find_next_call();
            return valid_;
        }

        valid_ = find_next_call();
        return valid_;
    }

    bool eof() const override {
        return started_ && !valid_;
    }

    void column(sqlite3_context* ctx, int col) override {
        switch (col) {
            case 0: // func_addr
                sqlite3_result_int64(ctx, static_cast<int64_t>(func_addr_));
                break;
            case 1: // ea
                sqlite3_result_int64(ctx, static_cast<int64_t>(current_ea_));
                break;
            case 2: // callee_addr
                if (callee_addr_ != BADADDR) {
                    sqlite3_result_int64(ctx, static_cast<int64_t>(callee_addr_));
                } else {
                    sqlite3_result_int64(ctx, 0);
                }
                break;
            case 3: // callee_name
                sqlite3_result_text(ctx, callee_name_.c_str(),
                                    static_cast<int>(callee_name_.size()),
                                    SQLITE_TRANSIENT);
                break;
        }
    }

    int64_t rowid() const override {
        return static_cast<int64_t>(current_ea_);
    }
};

class DisasmCallsGenerator : public xsql::Generator<DisasmCallInfo> {
    size_t func_idx_ = 0;
    func_t* pfn_ = nullptr;
    func_item_iterator_t fii_;
    bool in_func_started_ = false;
    DisasmCallInfo current_;

    bool start_next_func() {
        size_t func_qty = get_func_qty();
        while (func_idx_ < func_qty) {
            pfn_ = getn_func(func_idx_++);
            if (!pfn_) continue;

            if (fii_.set(pfn_)) {
                in_func_started_ = false;
                return true;
            }
        }
        pfn_ = nullptr;
        return false;
    }

    bool find_next_call_in_current_func() {
        if (!pfn_) return false;

        while (true) {
            ea_t ea = BADADDR;
            if (!in_func_started_) {
                in_func_started_ = true;
                ea = fii_.current();
            } else {
                if (!fii_.next_code()) return false;
                ea = fii_.current();
            }

            insn_t insn;
            if (decode_insn(&insn, ea) > 0 && is_call_insn(insn)) {
                current_.func_addr = pfn_->start_ea;
                current_.ea = ea;
                current_.callee_addr = get_first_fcref_from(ea);
                if (current_.callee_addr != BADADDR) {
                    current_.callee_name = safe_name(current_.callee_addr);
                } else {
                    current_.callee_name.clear();
                }
                return true;
            }
        }
    }

public:
    bool next() override {
        while (true) {
            if (!pfn_) {
                if (!start_next_func()) return false;
            }

            if (find_next_call_in_current_func()) return true;
            pfn_ = nullptr;
        }
    }

    const DisasmCallInfo& current() const override { return current_; }

    sqlite3_int64 rowid() const override { return static_cast<sqlite3_int64>(current_.ea); }
};

inline GeneratorTableDef<DisasmCallInfo> define_disasm_calls() {
    return generator_table<DisasmCallInfo>("disasm_calls")
        .estimate_rows([]() -> size_t {
            // Heuristic: a few calls per function
            return get_func_qty() * 5;
        })
        .generator([]() -> std::unique_ptr<xsql::Generator<DisasmCallInfo>> {
            return std::make_unique<DisasmCallsGenerator>();
        })
        .column_int64("func_addr", [](const DisasmCallInfo& r) -> int64_t { return r.func_addr; })
        .column_int64("ea", [](const DisasmCallInfo& r) -> int64_t { return r.ea; })
        .column_int64("callee_addr", [](const DisasmCallInfo& r) -> int64_t {
            return r.callee_addr != BADADDR ? static_cast<int64_t>(r.callee_addr) : 0;
        })
        .column_text("callee_name", [](const DisasmCallInfo& r) -> std::string { return r.callee_name; })
        // Constraint pushdown: func_addr = X bypasses full scan
        .filter_eq("func_addr", [](int64_t func_addr) -> std::unique_ptr<xsql::RowIterator> {
            return std::make_unique<DisasmCallsInFuncIterator>(static_cast<ea_t>(func_addr));
        }, 10.0)  // Low cost - only iterates one function
        .build();
}

// ============================================================================
// DISASM_LOOPS Table
// Detected loops via back-edge analysis using qflow_chart_t
// ============================================================================

struct LoopInfo {
    ea_t func_addr;
    int loop_id;           // Unique ID (header block index)
    ea_t header_ea;        // Loop header start address
    ea_t header_end_ea;    // Loop header end address
    ea_t back_edge_block_ea;  // Block containing the back-edge jump
    ea_t back_edge_block_end; // End of back-edge block
};

inline void collect_loops_for_func(std::vector<LoopInfo>& loops, func_t* pfn) {
    if (!pfn) return;

    qflow_chart_t fc;
    fc.create("", pfn, pfn->start_ea, pfn->end_ea, FC_NOEXT);

    for (int i = 0; i < fc.size(); i++) {
        const qbasic_block_t& block = fc.blocks[i];

        // Check each successor for back-edges
        for (int j = 0; j < fc.nsucc(i); j++) {
            int succ_idx = fc.succ(i, j);
            if (succ_idx < 0 || succ_idx >= fc.size()) continue;

            const qbasic_block_t& succ = fc.blocks[succ_idx];

            // Back-edge: successor starts at or before current block
            // This indicates a loop where succ is the header
            if (succ.start_ea <= block.start_ea) {
                LoopInfo li;
                li.func_addr = pfn->start_ea;
                li.loop_id = succ_idx;  // Use header block index as loop ID
                li.header_ea = succ.start_ea;
                li.header_end_ea = succ.end_ea;
                li.back_edge_block_ea = block.start_ea;
                li.back_edge_block_end = block.end_ea;
                loops.push_back(li);
            }
        }
    }
}

// Iterator for loops in a single function (constraint pushdown)
class LoopsInFuncIterator : public xsql::RowIterator {
    std::vector<LoopInfo> loops_;
    size_t idx_ = 0;
    bool started_ = false;

public:
    explicit LoopsInFuncIterator(ea_t func_addr) {
        func_t* pfn = get_func(func_addr);
        if (pfn) {
            collect_loops_for_func(loops_, pfn);
        }
    }

    bool next() override {
        if (!started_) {
            started_ = true;
            if (loops_.empty()) return false;
            idx_ = 0;
            return true;
        }
        if (idx_ + 1 < loops_.size()) { ++idx_; return true; }
        idx_ = loops_.size();
        return false;
    }

    bool eof() const override { return started_ && idx_ >= loops_.size(); }

    void column(sqlite3_context* ctx, int col) override {
        if (idx_ >= loops_.size()) { sqlite3_result_null(ctx); return; }
        const auto& li = loops_[idx_];
        switch (col) {
            case 0: sqlite3_result_int64(ctx, static_cast<int64_t>(li.func_addr)); break;
            case 1: sqlite3_result_int(ctx, li.loop_id); break;
            case 2: sqlite3_result_int64(ctx, static_cast<int64_t>(li.header_ea)); break;
            case 3: sqlite3_result_int64(ctx, static_cast<int64_t>(li.header_end_ea)); break;
            case 4: sqlite3_result_int64(ctx, static_cast<int64_t>(li.back_edge_block_ea)); break;
            case 5: sqlite3_result_int64(ctx, static_cast<int64_t>(li.back_edge_block_end)); break;
        }
    }

    int64_t rowid() const override { return static_cast<int64_t>(idx_); }
};

class DisasmLoopsGenerator : public xsql::Generator<LoopInfo> {
    size_t func_idx_ = 0;
    std::vector<LoopInfo> loops_;
    size_t idx_ = 0;
    sqlite3_int64 rowid_ = -1;
    bool started_ = false;

    bool load_next_func() {
        size_t func_qty = get_func_qty();
        while (func_idx_ < func_qty) {
            func_t* pfn = getn_func(func_idx_++);
            if (!pfn) continue;

            loops_.clear();
            collect_loops_for_func(loops_, pfn);
            if (!loops_.empty()) {
                idx_ = 0;
                return true;
            }
        }
        return false;
    }

public:
    bool next() override {
        if (!started_) {
            started_ = true;
            if (!load_next_func()) return false;
            rowid_ = 0;
            return true;
        }

        if (idx_ + 1 < loops_.size()) {
            ++idx_;
            ++rowid_;
            return true;
        }

        if (!load_next_func()) return false;
        ++rowid_;
        return true;
    }

    const LoopInfo& current() const override { return loops_[idx_]; }

    sqlite3_int64 rowid() const override { return rowid_; }
};

inline GeneratorTableDef<LoopInfo> define_disasm_loops() {
    return generator_table<LoopInfo>("disasm_loops")
        .estimate_rows([]() -> size_t {
            // Heuristic: very few loops per function
            return get_func_qty() * 2;
        })
        .generator([]() -> std::unique_ptr<xsql::Generator<LoopInfo>> {
            return std::make_unique<DisasmLoopsGenerator>();
        })
        .column_int64("func_addr", [](const LoopInfo& r) -> int64_t { return r.func_addr; })
        .column_int("loop_id", [](const LoopInfo& r) -> int { return r.loop_id; })
        .column_int64("header_ea", [](const LoopInfo& r) -> int64_t { return r.header_ea; })
        .column_int64("header_end_ea", [](const LoopInfo& r) -> int64_t { return r.header_end_ea; })
        .column_int64("back_edge_block_ea", [](const LoopInfo& r) -> int64_t { return r.back_edge_block_ea; })
        .column_int64("back_edge_block_end", [](const LoopInfo& r) -> int64_t { return r.back_edge_block_end; })
        .filter_eq("func_addr", [](int64_t func_addr) -> std::unique_ptr<xsql::RowIterator> {
            return std::make_unique<LoopsInFuncIterator>(static_cast<ea_t>(func_addr));
        }, 5.0)
        .build();
}

// ============================================================================
// View Registration
// ============================================================================

inline bool register_disasm_views(xsql::Database& db) {

    // disasm_v_leaf_funcs - Functions with no outgoing calls (terminal/leaf functions)
    // Uses disasm_calls to detect calls at the disassembly level
    const char* v_leaf_funcs = R"(
        CREATE VIEW IF NOT EXISTS disasm_v_leaf_funcs AS
        SELECT f.address, f.name
        FROM funcs f
        LEFT JOIN disasm_calls c ON c.func_addr = f.address
        GROUP BY f.address
        HAVING COUNT(c.callee_addr) = 0
    )";
    db.exec(v_leaf_funcs);

    // disasm_v_call_chains - All call chain paths (root_func -> current_func at depth N)
    // Enables queries like "find functions with call chains reaching depth 6"
    const char* v_call_chains = R"(
        CREATE VIEW IF NOT EXISTS disasm_v_call_chains AS
        WITH RECURSIVE call_chain(root_func, current_func, depth) AS (
            -- Base: direct calls from each function
            SELECT DISTINCT func_addr, callee_addr, 1
            FROM disasm_calls
            WHERE callee_addr IS NOT NULL AND callee_addr != 0

            UNION ALL

            -- Recursive: follow callees deeper
            SELECT cc.root_func, c.callee_addr, cc.depth + 1
            FROM call_chain cc
            JOIN disasm_calls c ON c.func_addr = cc.current_func
            WHERE cc.depth < 10
              AND c.callee_addr IS NOT NULL
              AND c.callee_addr != 0
        )
        SELECT DISTINCT
            root_func,
            current_func,
            depth
        FROM call_chain
    )";
    db.exec(v_call_chains);

    // disasm_v_calls_in_loops - Calls that occur inside detected loops
    // A call is considered "in a loop" if its address is between the loop header
    // and the end of the back-edge block
    const char* v_calls_in_loops = R"(
        CREATE VIEW IF NOT EXISTS disasm_v_calls_in_loops AS
        SELECT
            c.func_addr,
            c.ea,
            c.callee_addr,
            c.callee_name,
            l.loop_id,
            l.header_ea as loop_header,
            l.back_edge_block_ea,
            l.back_edge_block_end
        FROM disasm_calls c
        JOIN disasm_loops l ON l.func_addr = c.func_addr
        WHERE c.ea >= l.header_ea AND c.ea < l.back_edge_block_end
    )";
    db.exec(v_calls_in_loops);

    // disasm_v_funcs_with_loops - Functions that contain loops
    const char* v_funcs_with_loops = R"(
        CREATE VIEW IF NOT EXISTS disasm_v_funcs_with_loops AS
        SELECT
            f.address,
            f.name,
            COUNT(DISTINCT l.loop_id) as loop_count
        FROM funcs f
        JOIN disasm_loops l ON l.func_addr = f.address
        GROUP BY f.address
    )";
    db.exec(v_funcs_with_loops);

    return true;
}

// ============================================================================
// Registry for all disassembly tables
// ============================================================================

struct DisassemblyRegistry {
    GeneratorTableDef<DisasmCallInfo> disasm_calls;
    GeneratorTableDef<LoopInfo> disasm_loops;

    DisassemblyRegistry()
        : disasm_calls(define_disasm_calls())
        , disasm_loops(define_disasm_loops())
    {}

    void register_all(xsql::Database& db) {
        db.register_generator_table("ida_disasm_calls", &disasm_calls);
        db.create_table("disasm_calls", "ida_disasm_calls");

        db.register_generator_table("ida_disasm_loops", &disasm_loops);
        db.create_table("disasm_loops", "ida_disasm_loops");

        // Register views on top
        register_disasm_views(db);
    }
};

} // namespace disassembly
} // namespace idasql

```

`src/lib/include/idasql/entities.hpp`:

```hpp
/**
 * ida_entities.hpp - IDA entity definitions for SQLite virtual tables
 *
 * Defines all IDA entities as virtual tables using the clean ida_vtable.hpp framework.
 *
 * Tables:
 *   funcs      - Functions
 *   segments   - Memory segments
 *   names      - Named locations (from nlist)
 *   entries    - Entry points (exports)
 *   imports    - Imported functions
 *   strings    - String literals
 *   xrefs      - Cross-references (universal)
 */

#pragma once

#include <idasql/platform.hpp>

#include <idasql/vtable.hpp>
#include <xsql/database.hpp>
#include <idasql/entities_search.hpp>

#include <idasql/platform_undef.hpp>

// IDA SDK headers
#include <ida.hpp>
#include <idp.hpp>
#include <kernwin.hpp>  // Must come before moves.hpp
#include <funcs.hpp>
#include <segment.hpp>
#include <name.hpp>
#include <entry.hpp>
#include <nalt.hpp>
#include <typeinf.hpp>  // For tinfo_t, func_type_data_t
#include <xref.hpp>
#include <strlist.hpp>
#include <gdl.hpp>
#include <bytes.hpp>
#include <lines.hpp>   // For comments (get_cmt, set_cmt)
#include <ua.hpp>      // For instructions (insn_t, decode_insn)
#include <moves.hpp>   // For bookmarks

#include <idasql/decompiler.hpp>  // For invalidate_decompiler_cache

namespace idasql {
namespace entities {

// ============================================================================
// Helper: Safe string extraction from IDA
// ============================================================================

inline std::string safe_func_name(ea_t ea) {
    qstring name;
    get_func_name(&name, ea);
    return std::string(name.c_str());
}

inline std::string safe_segm_name(segment_t* seg) {
    if (!seg) return "";
    qstring name;
    get_segm_name(&name, seg);
    return std::string(name.c_str());
}

inline std::string safe_segm_class(segment_t* seg) {
    if (!seg) return "";
    qstring cls;
    get_segm_class(&cls, seg);
    return std::string(cls.c_str());
}

inline std::string safe_name(ea_t ea) {
    qstring name;
    get_name(&name, ea);
    return std::string(name.c_str());
}

inline std::string safe_entry_name(size_t idx) {
    uval_t ord = get_entry_ordinal(idx);
    qstring name;
    get_entry_name(&name, ord);
    return std::string(name.c_str());
}

// ============================================================================
// FUNCS Table (with UPDATE/DELETE support)
// ============================================================================

// Helper to get function type info
inline bool get_func_tinfo(ea_t ea, tinfo_t& tif) {
    return get_tinfo(&tif, ea);
}

// Helper to get calling convention name from callcnv_t
inline const char* get_cc_name(callcnv_t cc) {
    switch (cc) {
        case CM_CC_CDECL:    return "cdecl";
        case CM_CC_STDCALL:  return "stdcall";
        case CM_CC_FASTCALL: return "fastcall";
        case CM_CC_THISCALL: return "thiscall";
        case CM_CC_PASCAL:   return "pascal";
        case CM_CC_SPECIAL:  return "special";
        case CM_CC_SPECIALE: return "speciale";
        case CM_CC_SPECIALP: return "specialp";
        case CM_CC_ELLIPSIS: return "ellipsis";
        default:             return "unknown";
    }
}

inline VTableDef define_funcs() {
    return table("funcs")
        .count([]() { return get_func_qty(); })
        .column_int64("address", [](size_t i) -> int64_t {
            func_t* f = getn_func(i);
            return f ? static_cast<int64_t>(f->start_ea) : 0;
        })
        .column_text_rw("name",
            // Getter
            [](size_t i) -> std::string {
                func_t* f = getn_func(i);
                return f ? safe_func_name(f->start_ea) : "";
            },
            // Setter - rename function
            [](size_t i, const char* new_name) -> bool {
                auto_wait();
                func_t* f = getn_func(i);
                if (!f) return false;
                bool ok = set_name(f->start_ea, new_name, SN_CHECK) != 0;
                if (ok) decompiler::invalidate_decompiler_cache(f->start_ea);
                auto_wait();
                return ok;
            })
        .column_int64("size", [](size_t i) -> int64_t {
            func_t* f = getn_func(i);
            return f ? static_cast<int64_t>(f->size()) : 0;
        })
        .column_int64("end_ea", [](size_t i) -> int64_t {
            func_t* f = getn_func(i);
            return f ? static_cast<int64_t>(f->end_ea) : 0;
        })
        .column_int64_rw("flags",
            [](size_t i) -> int64_t {
                func_t* f = getn_func(i);
                return f ? static_cast<int64_t>(f->flags) : 0;
            },
            [](size_t i, int64_t new_flags) -> bool {
                func_t* f = getn_func(i);
                if (!f) return false;
                f->flags = static_cast<ushort>(new_flags);
                bool ok = update_func(f);
                if (ok) decompiler::invalidate_decompiler_cache(f->start_ea);
                return ok;
            })
        // Prototype columns - return type
        .column_text("return_type", [](size_t i) -> std::string {
            func_t* f = getn_func(i);
            if (!f) return "";
            tinfo_t tif;
            if (!get_func_tinfo(f->start_ea, tif) || !tif.is_func()) return "";
            func_type_data_t fi;
            if (!tif.get_func_details(&fi)) return "";
            qstring ret_str;
            fi.rettype.print(&ret_str);
            return ret_str.c_str();
        })
        .column_int("return_is_ptr", [](size_t i) -> int {
            func_t* f = getn_func(i);
            if (!f) return 0;
            tinfo_t tif;
            if (!get_func_tinfo(f->start_ea, tif) || !tif.is_func()) return 0;
            func_type_data_t fi;
            if (!tif.get_func_details(&fi)) return 0;
            return fi.rettype.is_ptr() ? 1 : 0;
        })
        .column_int("return_is_int", [](size_t i) -> int {
            func_t* f = getn_func(i);
            if (!f) return 0;
            tinfo_t tif;
            if (!get_func_tinfo(f->start_ea, tif) || !tif.is_func()) return 0;
            func_type_data_t fi;
            if (!tif.get_func_details(&fi)) return 0;
            return fi.rettype.is_int() ? 1 : 0;
        })
        .column_int("return_is_integral", [](size_t i) -> int {
            func_t* f = getn_func(i);
            if (!f) return 0;
            tinfo_t tif;
            if (!get_func_tinfo(f->start_ea, tif) || !tif.is_func()) return 0;
            func_type_data_t fi;
            if (!tif.get_func_details(&fi)) return 0;
            return fi.rettype.is_integral() ? 1 : 0;
        })
        .column_int("return_is_void", [](size_t i) -> int {
            func_t* f = getn_func(i);
            if (!f) return 0;
            tinfo_t tif;
            if (!get_func_tinfo(f->start_ea, tif) || !tif.is_func()) return 0;
            func_type_data_t fi;
            if (!tif.get_func_details(&fi)) return 0;
            return fi.rettype.is_void() ? 1 : 0;
        })
        // Prototype columns - arguments
        .column_int("arg_count", [](size_t i) -> int {
            func_t* f = getn_func(i);
            if (!f) return 0;
            tinfo_t tif;
            if (!get_func_tinfo(f->start_ea, tif) || !tif.is_func()) return 0;
            func_type_data_t fi;
            if (!tif.get_func_details(&fi)) return 0;
            return static_cast<int>(fi.size());
        })
        .column_text("calling_conv", [](size_t i) -> std::string {
            func_t* f = getn_func(i);
            if (!f) return "";
            tinfo_t tif;
            if (!get_func_tinfo(f->start_ea, tif) || !tif.is_func()) return "";
            func_type_data_t fi;
            if (!tif.get_func_details(&fi)) return "";
            return get_cc_name(fi.get_cc());
        })
        .deletable([](size_t i) -> bool {
            auto_wait();
            func_t* f = getn_func(i);
            if (!f) return false;
            bool ok = del_func(f->start_ea);
            auto_wait();
            return ok;
        })
        .insertable([](int argc, sqlite3_value** argv) -> bool {
            // address (col 0) is required
            if (argc < 1 || sqlite3_value_type(argv[0]) == SQLITE_NULL)
                return false;

            ea_t ea = static_cast<ea_t>(sqlite3_value_int64(argv[0]));

            // Check if function already exists at this address
            if (get_func(ea) != nullptr)
                return false;

            auto_wait();
            // end_ea from col 3 if provided, else BADADDR (IDA auto-detects)
            ea_t end = BADADDR;
            if (argc > 3 && sqlite3_value_type(argv[3]) != SQLITE_NULL)
                end = static_cast<ea_t>(sqlite3_value_int64(argv[3]));

            bool ok = add_func(ea, end);
            auto_wait();

            if (!ok) return false;

            // Optional: set name (col 1) after creation
            if (argc > 1 && sqlite3_value_type(argv[1]) != SQLITE_NULL) {
                const char* name = reinterpret_cast<const char*>(
                    sqlite3_value_text(argv[1]));
                if (name && name[0])
                    set_name(ea, name, SN_CHECK);
            }

            return true;
        })
        .build();
}

// ============================================================================
// SEGMENTS Table
// ============================================================================

inline VTableDef define_segments() {
    return table("segments")
        .count([]() { return static_cast<size_t>(get_segm_qty()); })
        .column_int64("start_ea", [](size_t i) -> int64_t {
            segment_t* s = getnseg(static_cast<int>(i));
            return s ? static_cast<int64_t>(s->start_ea) : 0;
        })
        .column_int64("end_ea", [](size_t i) -> int64_t {
            segment_t* s = getnseg(static_cast<int>(i));
            return s ? static_cast<int64_t>(s->end_ea) : 0;
        })
        .column_text_rw("name",
            // Getter
            [](size_t i) -> std::string {
                segment_t* s = getnseg(static_cast<int>(i));
                return safe_segm_name(s);
            },
            // Setter - rename segment
            [](size_t i, const char* new_name) -> bool {
                auto_wait();
                segment_t* s = getnseg(static_cast<int>(i));
                if (!s) return false;
                bool ok = set_segm_name(s, new_name) != 0;
                auto_wait();
                return ok;
            })
        .column_text_rw("class",
            // Getter
            [](size_t i) -> std::string {
                segment_t* s = getnseg(static_cast<int>(i));
                return safe_segm_class(s);
            },
            // Setter - change segment class
            [](size_t i, const char* new_class) -> bool {
                auto_wait();
                segment_t* s = getnseg(static_cast<int>(i));
                if (!s) return false;
                bool ok = set_segm_class(s, new_class) != 0;
                auto_wait();
                return ok;
            })
        .column_int_rw("perm",
            // Getter
            [](size_t i) -> int {
                segment_t* s = getnseg(static_cast<int>(i));
                return s ? s->perm : 0;
            },
            // Setter - change segment permissions
            [](size_t i, int new_perm) -> bool {
                auto_wait();
                segment_t* s = getnseg(static_cast<int>(i));
                if (!s) return false;
                s->perm = static_cast<uchar>(new_perm);
                bool ok = s->update();
                auto_wait();
                return ok;
            })
        .deletable([](size_t i) -> bool {
            auto_wait();
            segment_t* s = getnseg(static_cast<int>(i));
            if (!s) return false;
            bool ok = del_segm(s->start_ea, SEGMOD_KILL) != 0;
            auto_wait();
            return ok;
        })
        .build();
}

// ============================================================================
// NAMES Table (with UPDATE/DELETE support)
// ============================================================================

inline VTableDef define_names() {
    return table("names")
        .count([]() { return get_nlist_size(); })
        .column_int64("address", [](size_t i) -> int64_t {
            return static_cast<int64_t>(get_nlist_ea(i));
        })
        .column_text_rw("name",
            // Getter
            [](size_t i) -> std::string {
                const char* n = get_nlist_name(i);
                return n ? std::string(n) : "";
            },
            // Setter - rename the address
            [](size_t i, const char* new_name) -> bool {
                auto_wait();
                ea_t ea = get_nlist_ea(i);
                if (ea == BADADDR) return false;
                bool ok = set_name(ea, new_name, SN_CHECK) != 0;
                if (ok) decompiler::invalidate_decompiler_cache(ea);
                auto_wait();
                return ok;
            })
        .column_int("is_public", [](size_t i) -> int {
            return is_public_name(get_nlist_ea(i)) ? 1 : 0;
        })
        .column_int("is_weak", [](size_t i) -> int {
            return is_weak_name(get_nlist_ea(i)) ? 1 : 0;
        })
        // DELETE via set_name(ea, "") - removes the name
        .deletable([](size_t i) -> bool {
            auto_wait();
            ea_t ea = get_nlist_ea(i);
            if (ea == BADADDR) return false;
            bool ok = set_name(ea, "", SN_NOWARN) != 0;
            auto_wait();
            return ok;
        })
        .insertable([](int argc, sqlite3_value** argv) -> bool {
            // address (col 0) and name (col 1) are both required
            if (argc < 2
                || sqlite3_value_type(argv[0]) == SQLITE_NULL
                || sqlite3_value_type(argv[1]) == SQLITE_NULL)
                return false;

            ea_t ea = static_cast<ea_t>(sqlite3_value_int64(argv[0]));
            const char* name = reinterpret_cast<const char*>(
                sqlite3_value_text(argv[1]));
            if (!name || !name[0]) return false;

            auto_wait();
            bool ok = set_name(ea, name, SN_CHECK) != 0;
            if (ok) decompiler::invalidate_decompiler_cache(ea);
            auto_wait();
            return ok;
        })
        .build();
}

// ============================================================================
// ENTRIES Table (entry points / exports)
// ============================================================================

inline VTableDef define_entries() {
    return table("entries")
        .count([]() { return get_entry_qty(); })
        .column_int64("ordinal", [](size_t i) -> int64_t {
            return static_cast<int64_t>(get_entry_ordinal(i));
        })
        .column_int64("address", [](size_t i) -> int64_t {
            uval_t ord = get_entry_ordinal(i);
            return static_cast<int64_t>(get_entry(ord));
        })
        .column_text("name", [](size_t i) -> std::string {
            return safe_entry_name(i);
        })
        .build();
}

// ============================================================================
// COMMENTS Table (with UPDATE/DELETE support)
// ============================================================================

// Helper to iterate addresses with comments
struct CommentIterator {
    static std::vector<ea_t>& get_addresses() {
        static std::vector<ea_t> addrs;
        return addrs;
    }

    static void rebuild() {
        auto& addrs = get_addresses();
        addrs.clear();

        ea_t ea = inf_get_min_ea();
        ea_t max_ea = inf_get_max_ea();

        while (ea < max_ea) {
            qstring cmt, rpt;
            bool has_cmt = get_cmt(&cmt, ea, false) > 0;
            bool has_rpt = get_cmt(&rpt, ea, true) > 0;

            if (has_cmt || has_rpt) {
                addrs.push_back(ea);
            }

            ea = next_head(ea, max_ea);
            if (ea == BADADDR) break;
        }
    }
};

inline VTableDef define_comments() {
    return table("comments")
        .count([]() {
            CommentIterator::rebuild();
            return CommentIterator::get_addresses().size();
        })
        .column_int64("address", [](size_t i) -> int64_t {
            auto& addrs = CommentIterator::get_addresses();
            return i < addrs.size() ? addrs[i] : 0;
        })
        .column_text_rw("comment",
            // Getter
            [](size_t i) -> std::string {
                auto& addrs = CommentIterator::get_addresses();
                if (i >= addrs.size()) return "";
                qstring cmt;
                get_cmt(&cmt, addrs[i], false);
                return cmt.c_str();
            },
            // Setter
            [](size_t i, const char* new_cmt) -> bool {
                auto_wait();
                auto& addrs = CommentIterator::get_addresses();
                if (i >= addrs.size()) return false;
                bool ok = set_cmt(addrs[i], new_cmt, false);
                auto_wait();
                return ok;
            })
        .column_text_rw("rpt_comment",
            // Getter
            [](size_t i) -> std::string {
                auto& addrs = CommentIterator::get_addresses();
                if (i >= addrs.size()) return "";
                qstring cmt;
                get_cmt(&cmt, addrs[i], true);
                return cmt.c_str();
            },
            // Setter
            [](size_t i, const char* new_cmt) -> bool {
                auto_wait();
                auto& addrs = CommentIterator::get_addresses();
                if (i >= addrs.size()) return false;
                bool ok = set_cmt(addrs[i], new_cmt, true);
                auto_wait();
                return ok;
            })
        .deletable([](size_t i) -> bool {
            auto_wait();
            // Delete both comments at this address
            auto& addrs = CommentIterator::get_addresses();
            if (i >= addrs.size()) return false;
            ea_t ea = addrs[i];
            set_cmt(ea, "", false);  // Delete regular
            set_cmt(ea, "", true);   // Delete repeatable
            auto_wait();
            return true;
        })
        .insertable([](int argc, sqlite3_value** argv) -> bool {
            // address (col 0) is required, plus at least one comment column
            if (argc < 1 || sqlite3_value_type(argv[0]) == SQLITE_NULL)
                return false;

            ea_t ea = static_cast<ea_t>(sqlite3_value_int64(argv[0]));

            bool did_something = false;
            auto_wait();

            // Regular comment (col 1)
            if (argc > 1 && sqlite3_value_type(argv[1]) != SQLITE_NULL) {
                const char* cmt = reinterpret_cast<const char*>(
                    sqlite3_value_text(argv[1]));
                if (cmt) {
                    set_cmt(ea, cmt, false);
                    did_something = true;
                }
            }

            // Repeatable comment (col 2)
            if (argc > 2 && sqlite3_value_type(argv[2]) != SQLITE_NULL) {
                const char* rpt = reinterpret_cast<const char*>(
                    sqlite3_value_text(argv[2]));
                if (rpt) {
                    set_cmt(ea, rpt, true);
                    did_something = true;
                }
            }

            auto_wait();
            return did_something;
        })
        .build();
}

// ============================================================================
// IMPORTS Table
// Collects all imports across all modules into a flat table
// ============================================================================

struct ImportInfo {
    int module_idx;
    ea_t ea;
    std::string name;
    uval_t ord;
};

inline std::string get_import_module_name_safe(int idx) {
    qstring name;
    get_import_module_name(&name, idx);
    return std::string(name.c_str());
}

// ============================================================================
// STRINGS Tables - By type (ASCII, Unicode)
// ============================================================================

// String type encoding (from ida_nalt):
// Bits 0-1: Width (0=1B/ASCII, 1=2B/UTF-16, 2=4B/UTF-32)
// Bits 2-7: Layout (0=TERMCHR, 1=PASCAL1, 2=PASCAL2, 3=PASCAL4)
// Bits 8-15: term1 (first termination character)
// Bits 16-23: term2 (second termination character)
// Bits 24-31: encoding index

inline int get_string_width(int strtype) {
    return strtype & 0x03;  // 0=ASCII, 1=UTF-16, 2=UTF-32
}

inline const char* get_string_width_name(int strtype) {
    int width = get_string_width(strtype);
    switch (width) {
        case 0: return "1-byte";
        case 1: return "2-byte";
        case 2: return "4-byte";
        default: return "unknown";
    }
}

inline const char* get_string_type_name(int strtype) {
    int width = get_string_width(strtype);
    switch (width) {
        case 0: return "ascii";
        case 1: return "utf16";
        case 2: return "utf32";
        default: return "unknown";
    }
}

inline int get_string_layout(int strtype) {
    return (strtype >> 2) & 0x3F;  // Bits 2-7
}

inline const char* get_string_layout_name(int strtype) {
    int layout = get_string_layout(strtype);
    switch (layout) {
        case 0: return "termchr";    // Null-terminated (C-style)
        case 1: return "pascal1";    // 1-byte length prefix
        case 2: return "pascal2";    // 2-byte length prefix
        case 3: return "pascal4";    // 4-byte length prefix
        default: return "unknown";
    }
}

inline int get_string_encoding(int strtype) {
    return (strtype >> 24) & 0xFF;  // Bits 24-31: encoding index
}

inline std::string get_string_content(const string_info_t& si) {
    qstring content;
    get_strlit_contents(&content, si.ea, si.length, si.type);
    return std::string(content.c_str());
}

// ============================================================================
// XREFS Table (universal cross-references)
// Collects all xrefs from all functions
// ============================================================================

struct XrefInfo {
    ea_t from_ea;
    ea_t to_ea;
    uint8_t type;
    bool is_code;
};

// ============================================================================
// Xref Iterators for Constraint Pushdown
// ============================================================================

/**
 * Iterator for xrefs TO a specific address.
 * Used when query has: WHERE to_ea = X
 * Uses xrefblk_t::first_to/next_to for O(refs_to_X) instead of O(all_xrefs)
 */
class XrefsToIterator : public xsql::RowIterator {
    ea_t target_;
    xrefblk_t xb_;
    bool started_ = false;
    bool valid_ = false;

public:
    explicit XrefsToIterator(ea_t target) : target_(target) {}

    bool next() override {
        if (!started_) {
            started_ = true;
            valid_ = xb_.first_to(target_, XREF_ALL);
        } else if (valid_) {
            valid_ = xb_.next_to();
        }
        return valid_;
    }

    bool eof() const override {
        return started_ && !valid_;
    }

    void column(sqlite3_context* ctx, int col) override {
        if (!valid_) {
            sqlite3_result_null(ctx);
            return;
        }
        switch (col) {
            case 0: sqlite3_result_int64(ctx, static_cast<int64_t>(xb_.from)); break;
            case 1: sqlite3_result_int64(ctx, static_cast<int64_t>(target_)); break;
            case 2: sqlite3_result_int(ctx, xb_.type); break;
            case 3: sqlite3_result_int(ctx, xb_.iscode ? 1 : 0); break;
            default: sqlite3_result_null(ctx); break;
        }
    }

    int64_t rowid() const override {
        return valid_ ? static_cast<int64_t>(xb_.from) : 0;
    }
};

/**
 * Iterator for xrefs FROM a specific address.
 * Used when query has: WHERE from_ea = X
 * Uses xrefblk_t::first_from/next_from for O(refs_from_X) instead of O(all_xrefs)
 */
class XrefsFromIterator : public xsql::RowIterator {
    ea_t source_;
    xrefblk_t xb_;
    bool started_ = false;
    bool valid_ = false;

public:
    explicit XrefsFromIterator(ea_t source) : source_(source) {}

    bool next() override {
        if (!started_) {
            started_ = true;
            valid_ = xb_.first_from(source_, XREF_ALL);
        } else if (valid_) {
            valid_ = xb_.next_from();
        }
        return valid_;
    }

    bool eof() const override {
        return started_ && !valid_;
    }

    void column(sqlite3_context* ctx, int col) override {
        if (!valid_) {
            sqlite3_result_null(ctx);
            return;
        }
        switch (col) {
            case 0: sqlite3_result_int64(ctx, static_cast<int64_t>(source_)); break;
            case 1: sqlite3_result_int64(ctx, static_cast<int64_t>(xb_.to)); break;
            case 2: sqlite3_result_int(ctx, xb_.type); break;
            case 3: sqlite3_result_int(ctx, xb_.iscode ? 1 : 0); break;
            default: sqlite3_result_null(ctx); break;
        }
    }

    int64_t rowid() const override {
        return valid_ ? static_cast<int64_t>(xb_.to) : 0;
    }
};

/**
 * Xrefs table with query-scoped cache.
 *
 * Features:
 * - Cache lives in cursor (freed when query completes)
 * - Lazy cache build (only if not using constraint pushdown)
 * - Row count estimation (no cache rebuild in xBestIndex)
 */
inline CachedTableDef<XrefInfo> define_xrefs() {
    return cached_table<XrefInfo>("xrefs")
        // Estimate row count without building cache
        .estimate_rows([]() -> size_t {
            // Heuristic: ~10 xrefs per function on average
            return get_func_qty() * 10;
        })
        // Cache builder (called lazily, only if pushdown doesn't handle query)
        .cache_builder([](std::vector<XrefInfo>& cache) {
            size_t func_qty = get_func_qty();
            for (size_t i = 0; i < func_qty; i++) {
                func_t* func = getn_func(i);
                if (!func) continue;

                // Xrefs TO this function
                xrefblk_t xb;
                for (bool ok = xb.first_to(func->start_ea, XREF_ALL); ok; ok = xb.next_to()) {
                    XrefInfo xi;
                    xi.from_ea = xb.from;
                    xi.to_ea = func->start_ea;
                    xi.type = xb.type;
                    xi.is_code = xb.iscode;
                    cache.push_back(xi);
                }
            }
        })
        // Column accessors take const XrefInfo& directly
        .column_int64("from_ea", [](const XrefInfo& r) -> int64_t {
            return static_cast<int64_t>(r.from_ea);
        })
        .column_int64("to_ea", [](const XrefInfo& r) -> int64_t {
            return static_cast<int64_t>(r.to_ea);
        })
        .column_int("type", [](const XrefInfo& r) -> int {
            return static_cast<int>(r.type);
        })
        .column_int("is_code", [](const XrefInfo& r) -> int {
            return r.is_code ? 1 : 0;
        })
        // Constraint pushdown filters (same iterators as V1)
        .filter_eq("to_ea", [](int64_t target) -> std::unique_ptr<xsql::RowIterator> {
            return std::make_unique<XrefsToIterator>(static_cast<ea_t>(target));
        }, 10.0, 5.0)
        .filter_eq("from_ea", [](int64_t source) -> std::unique_ptr<xsql::RowIterator> {
            return std::make_unique<XrefsFromIterator>(static_cast<ea_t>(source));
        }, 10.0, 5.0)
        .build();
}

// ============================================================================
// BLOCKS Table (basic blocks)
// ============================================================================

struct BlockInfo {
    ea_t func_ea;
    ea_t start_ea;
    ea_t end_ea;
};

/**
 * Iterator for blocks in a specific function.
 * Used when query has: WHERE func_ea = X
 * Uses qflow_chart_t on single function for O(func_blocks) instead of O(all_blocks)
 */
class BlocksInFuncIterator : public xsql::RowIterator {
    ea_t func_ea_;
    qflow_chart_t fc_;
    int idx_ = -1;
    bool valid_ = false;

public:
    explicit BlocksInFuncIterator(ea_t func_ea) : func_ea_(func_ea) {
        func_t* pfn = get_func(func_ea);
        if (pfn) {
            fc_.create("", pfn, pfn->start_ea, pfn->end_ea, FC_NOEXT);
        }
    }

    bool next() override {
        ++idx_;
        valid_ = (idx_ < fc_.size());
        return valid_;
    }

    bool eof() const override {
        return idx_ >= 0 && !valid_;
    }

    void column(sqlite3_context* ctx, int col) override {
        if (!valid_ || idx_ < 0 || idx_ >= fc_.size()) {
            sqlite3_result_null(ctx);
            return;
        }
        const qbasic_block_t& bb = fc_.blocks[idx_];
        switch (col) {
            case 0: sqlite3_result_int64(ctx, static_cast<int64_t>(func_ea_)); break;
            case 1: sqlite3_result_int64(ctx, static_cast<int64_t>(bb.start_ea)); break;
            case 2: sqlite3_result_int64(ctx, static_cast<int64_t>(bb.end_ea)); break;
            case 3: sqlite3_result_int64(ctx, static_cast<int64_t>(bb.end_ea - bb.start_ea)); break;
            default: sqlite3_result_null(ctx); break;
        }
    }

    int64_t rowid() const override {
        if (!valid_ || idx_ < 0 || idx_ >= fc_.size()) return 0;
        return static_cast<int64_t>(fc_.blocks[idx_].start_ea);
    }
};

inline CachedTableDef<BlockInfo> define_blocks() {
    return cached_table<BlockInfo>("blocks")
        .estimate_rows([]() -> size_t {
            // Heuristic: ~10 blocks per function
            return get_func_qty() * 10;
        })
        .cache_builder([](std::vector<BlockInfo>& cache) {
            size_t func_qty = get_func_qty();
            for (size_t i = 0; i < func_qty; i++) {
                func_t* func = getn_func(i);
                if (!func) continue;

                qflow_chart_t fc;
                fc.create("", func, func->start_ea, func->end_ea, FC_NOEXT);

                for (int j = 0; j < fc.size(); j++) {
                    const qbasic_block_t& bb = fc.blocks[j];
                    BlockInfo bi;
                    bi.func_ea = func->start_ea;
                    bi.start_ea = bb.start_ea;
                    bi.end_ea = bb.end_ea;
                    cache.push_back(bi);
                }
            }
        })
        .column_int64("func_ea", [](const BlockInfo& r) -> int64_t {
            return static_cast<int64_t>(r.func_ea);
        })
        .column_int64("start_ea", [](const BlockInfo& r) -> int64_t {
            return static_cast<int64_t>(r.start_ea);
        })
        .column_int64("end_ea", [](const BlockInfo& r) -> int64_t {
            return static_cast<int64_t>(r.end_ea);
        })
        .column_int64("size", [](const BlockInfo& r) -> int64_t {
            return static_cast<int64_t>(r.end_ea - r.start_ea);
        })
        .filter_eq("func_ea", [](int64_t func_addr) -> std::unique_ptr<xsql::RowIterator> {
            return std::make_unique<BlocksInFuncIterator>(static_cast<ea_t>(func_addr));
        }, 10.0, 10.0)
        .build();
}

// ============================================================================
// IMPORTS Table (query-scoped cache)
// ============================================================================

// Helper struct for import enumeration callback
struct ImportEnumContext {
    std::vector<ImportInfo>* cache;
    int module_idx;
};

inline CachedTableDef<ImportInfo> define_imports() {
    return cached_table<ImportInfo>("imports")
        .estimate_rows([]() -> size_t {
            // Estimate: ~100 imports per module
            return get_import_module_qty() * 100;
        })
        .cache_builder([](std::vector<ImportInfo>& cache) {
            uint mod_qty = get_import_module_qty();
            for (uint m = 0; m < mod_qty; m++) {
                ImportEnumContext ctx;
                ctx.cache = &cache;
                ctx.module_idx = static_cast<int>(m);

                enum_import_names(m, [](ea_t ea, const char* name, uval_t ord, void* param) -> int {
                    auto* ctx = static_cast<ImportEnumContext*>(param);
                    ImportInfo info;
                    info.module_idx = ctx->module_idx;
                    info.ea = ea;
                    info.name = name ? name : "";
                    info.ord = ord;
                    ctx->cache->push_back(info);
                    return 1;  // continue enumeration
                }, &ctx);
            }
        })
        .column_int64("address", [](const ImportInfo& r) -> int64_t {
            return static_cast<int64_t>(r.ea);
        })
        .column_text("name", [](const ImportInfo& r) -> std::string {
            return r.name;
        })
        .column_int64("ordinal", [](const ImportInfo& r) -> int64_t {
            return static_cast<int64_t>(r.ord);
        })
        .column_text("module", [](const ImportInfo& r) -> std::string {
            return get_import_module_name_safe(r.module_idx);
        })
        .column_int("module_idx", [](const ImportInfo& r) -> int {
            return r.module_idx;
        })
        .build();
}

// ============================================================================
// STRINGS Table (query-scoped cache)
// ============================================================================

inline CachedTableDef<string_info_t> define_strings() {
    return cached_table<string_info_t>("strings")
        .estimate_rows([]() -> size_t {
            return get_strlist_qty();
        })
        .cache_builder([](std::vector<string_info_t>& cache) {
            size_t n = get_strlist_qty();
            for (size_t i = 0; i < n; i++) {
                string_info_t si;
                if (get_strlist_item(&si, i)) {
                    cache.push_back(si);
                }
            }
        })
        .column_int64("address", [](const string_info_t& r) -> int64_t {
            return static_cast<int64_t>(r.ea);
        })
        .column_int("length", [](const string_info_t& r) -> int {
            return static_cast<int>(r.length);
        })
        .column_int("type", [](const string_info_t& r) -> int {
            return static_cast<int>(r.type);
        })
        .column_text("type_name", [](const string_info_t& r) -> std::string {
            return get_string_type_name(r.type);
        })
        .column_int("width", [](const string_info_t& r) -> int {
            return get_string_width(r.type);
        })
        .column_text("width_name", [](const string_info_t& r) -> std::string {
            return get_string_width_name(r.type);
        })
        .column_int("layout", [](const string_info_t& r) -> int {
            return get_string_layout(r.type);
        })
        .column_text("layout_name", [](const string_info_t& r) -> std::string {
            return get_string_layout_name(r.type);
        })
        .column_int("encoding", [](const string_info_t& r) -> int {
            return get_string_encoding(r.type);
        })
        .column_text("content", [](const string_info_t& r) -> std::string {
            return get_string_content(r);
        })
        .build();
}

// ============================================================================
// BOOKMARKS Table (with UPDATE/DELETE support)
// ============================================================================

struct BookmarkIterator {
    struct Entry {
        uint32_t index;
        ea_t ea;
        std::string desc;
    };

    static std::vector<Entry>& get_entries() {
        static std::vector<Entry> entries;
        return entries;
    }

    static void rebuild() {
        auto& entries = get_entries();
        entries.clear();

        // Get bookmarks for IDA View (disassembly)
        idaplace_t idaplace(inf_get_min_ea(), 0);
        renderer_info_t rinfo;
        lochist_entry_t loc(&idaplace, rinfo);

        uint32_t count = bookmarks_t::size(loc, nullptr);

        for (uint32_t idx = 0; idx < count; ++idx) {
            idaplace_t place(0, 0);
            lochist_entry_t entry(&place, rinfo);
            qstring desc;
            uint32_t index = idx;

            if (bookmarks_t::get(&entry, &desc, &index, nullptr)) {
                Entry e;
                e.index = index;
                e.ea = ((idaplace_t*)entry.place())->ea;
                e.desc = desc.c_str();
                entries.push_back(e);
            }
        }
    }
};

inline VTableDef define_bookmarks() {
    return table("bookmarks")
        .count([]() {
            BookmarkIterator::rebuild();
            return BookmarkIterator::get_entries().size();
        })
        .column_int("slot", [](size_t i) -> int {
            auto& entries = BookmarkIterator::get_entries();
            return i < entries.size() ? entries[i].index : 0;
        })
        .column_int64("address", [](size_t i) -> int64_t {
            auto& entries = BookmarkIterator::get_entries();
            return i < entries.size() ? entries[i].ea : 0;
        })
        .column_text_rw("description",
            // Getter
            [](size_t i) -> std::string {
                auto& entries = BookmarkIterator::get_entries();
                return i < entries.size() ? entries[i].desc : "";
            },
            // Setter - update bookmark description
            [](size_t i, const char* new_desc) -> bool {
                auto_wait();
                auto& entries = BookmarkIterator::get_entries();
                if (i >= entries.size()) return false;

                idaplace_t place(entries[i].ea, 0);
                renderer_info_t rinfo;
                lochist_entry_t loc(&place, rinfo);
                bool ok = bookmarks_t_set_desc(qstring(new_desc), loc, entries[i].index, nullptr);
                auto_wait();
                return ok;
            })
        .deletable([](size_t i) -> bool {
            auto_wait();
            auto& entries = BookmarkIterator::get_entries();
            if (i >= entries.size()) return false;

            idaplace_t place(entries[i].ea, 0);
            renderer_info_t rinfo;
            lochist_entry_t loc(&place, rinfo);
            bool ok = bookmarks_t::erase(loc, entries[i].index, nullptr);
            auto_wait();
            return ok;
        })
        .insertable([](int argc, sqlite3_value** argv) -> bool {
            // address (col 1) is required
            if (argc < 2 || sqlite3_value_type(argv[1]) == SQLITE_NULL)
                return false;

            ea_t ea = static_cast<ea_t>(sqlite3_value_int64(argv[1]));

            const char* desc = "";
            if (argc > 2 && sqlite3_value_type(argv[2]) != SQLITE_NULL) {
                desc = reinterpret_cast<const char*>(sqlite3_value_text(argv[2]));
                if (!desc) desc = "";
            }

            auto_wait();

            idaplace_t place(ea, 0);
            renderer_info_t rinfo;
            lochist_entry_t loc(&place, rinfo);

            // slot (col 0): use provided slot or auto-assign next
            uint32_t slot = bookmarks_t::size(loc, nullptr);
            if (argc > 0 && sqlite3_value_type(argv[0]) != SQLITE_NULL)
                slot = static_cast<uint32_t>(sqlite3_value_int(argv[0]));

            uint32_t result = bookmarks_t::mark(loc, slot, nullptr, desc, nullptr);
            auto_wait();

            return result != BADADDR32;
        })
        .build();
}

// ============================================================================
// HEADS Table - All defined items in the database
// ============================================================================

struct HeadsIterator {
    static std::vector<ea_t>& get_addresses() {
        static std::vector<ea_t> addrs;
        return addrs;
    }

    static void rebuild() {
        auto& addrs = get_addresses();
        addrs.clear();

        ea_t ea = inf_get_min_ea();
        ea_t max_ea = inf_get_max_ea();

        while (ea < max_ea && ea != BADADDR) {
            addrs.push_back(ea);
            ea = next_head(ea, max_ea);
        }
    }
};

inline const char* get_item_type_str(ea_t ea) {
    flags64_t f = get_flags(ea);
    if (is_code(f)) return "code";
    if (is_strlit(f)) return "string";
    if (is_struct(f)) return "struct";
    if (is_align(f)) return "align";
    if (is_data(f)) return "data";
    if (is_unknown(f)) return "unknown";
    return "other";
}

inline VTableDef define_heads() {
    return table("heads")
        .count([]() {
            HeadsIterator::rebuild();
            return HeadsIterator::get_addresses().size();
        })
        .column_int64("address", [](size_t i) -> int64_t {
            auto& addrs = HeadsIterator::get_addresses();
            return i < addrs.size() ? addrs[i] : 0;
        })
        .column_int64("size", [](size_t i) -> int64_t {
            auto& addrs = HeadsIterator::get_addresses();
            if (i >= addrs.size()) return 0;
            return get_item_size(addrs[i]);
        })
        .column_text("type", [](size_t i) -> std::string {
            auto& addrs = HeadsIterator::get_addresses();
            if (i >= addrs.size()) return "";
            return get_item_type_str(addrs[i]);
        })
        .column_int64("flags", [](size_t i) -> int64_t {
            auto& addrs = HeadsIterator::get_addresses();
            if (i >= addrs.size()) return 0;
            return get_flags(addrs[i]);
        })
        .column_text("disasm", [](size_t i) -> std::string {
            auto& addrs = HeadsIterator::get_addresses();
            if (i >= addrs.size()) return "";
            qstring line;
            generate_disasm_line(&line, addrs[i], GENDSM_FORCE_CODE);
            tag_remove(&line);
            return line.c_str();
        })
        .build();
}

// ============================================================================
// INSTRUCTIONS Table - With func_addr constraint pushdown
// ============================================================================

// Iterator for instructions within a single function (constraint pushdown)
class InstructionsInFuncIterator : public xsql::RowIterator {
    ea_t func_addr_;
    func_t* pfn_ = nullptr;
    func_item_iterator_t fii_;
    bool started_ = false;
    bool valid_ = false;
    ea_t current_ea_ = BADADDR;

public:
    explicit InstructionsInFuncIterator(ea_t func_addr)
        : func_addr_(func_addr)
    {
        pfn_ = get_func(func_addr_);
    }

    bool next() override {
        if (!pfn_) return false;

        if (!started_) {
            started_ = true;
            valid_ = fii_.set(pfn_);
            if (valid_) current_ea_ = fii_.current();
        } else if (valid_) {
            valid_ = fii_.next_code();
            if (valid_) current_ea_ = fii_.current();
        }
        return valid_;
    }

    bool eof() const override {
        return started_ && !valid_;
    }

    void column(sqlite3_context* ctx, int col) override {
        switch (col) {
            case 0: // address
                sqlite3_result_int64(ctx, current_ea_);
                break;
            case 1: { // itype
                insn_t insn;
                if (decode_insn(&insn, current_ea_) > 0) {
                    sqlite3_result_int(ctx, insn.itype);
                } else {
                    sqlite3_result_int(ctx, 0);
                }
                break;
            }
            case 2: { // mnemonic
                qstring mnem;
                print_insn_mnem(&mnem, current_ea_);
                sqlite3_result_text(ctx, mnem.c_str(), -1, SQLITE_TRANSIENT);
                break;
            }
            case 3: // size
                sqlite3_result_int(ctx, get_item_size(current_ea_));
                break;
            case 4: // operand0
            case 5: // operand1
            case 6: { // operand2
                qstring op;
                print_operand(&op, current_ea_, col - 4);
                tag_remove(&op);
                sqlite3_result_text(ctx, op.c_str(), -1, SQLITE_TRANSIENT);
                break;
            }
            case 7: { // disasm
                qstring line;
                generate_disasm_line(&line, current_ea_, 0);
                tag_remove(&line);
                sqlite3_result_text(ctx, line.c_str(), -1, SQLITE_TRANSIENT);
                break;
            }
            case 8: // func_addr
                sqlite3_result_int64(ctx, func_addr_);
                break;
        }
    }

    int64_t rowid() const override {
        return static_cast<int64_t>(current_ea_);
    }
};

// Cache for full instruction scan
struct InstructionsCache {
    static std::vector<ea_t>& get() {
        static std::vector<ea_t> cache;
        return cache;
    }

    static void rebuild() {
        auto& cache = get();
        cache.clear();

        ea_t ea = inf_get_min_ea();
        ea_t max_ea = inf_get_max_ea();

        while (ea < max_ea && ea != BADADDR) {
            flags64_t f = get_flags(ea);
            if (is_code(f)) {
                cache.push_back(ea);
            }
            ea = next_head(ea, max_ea);
        }
    }
};

inline VTableDef define_instructions() {
    return table("instructions")
        .count([]() {
            InstructionsCache::rebuild();
            return InstructionsCache::get().size();
        })
        .column_int64("address", [](size_t i) -> int64_t {
            auto& cache = InstructionsCache::get();
            return i < cache.size() ? cache[i] : 0;
        })
        .column_int("itype", [](size_t i) -> int {
            auto& cache = InstructionsCache::get();
            if (i >= cache.size()) return 0;
            insn_t insn;
            if (decode_insn(&insn, cache[i]) > 0) return insn.itype;
            return 0;
        })
        .column_text("mnemonic", [](size_t i) -> std::string {
            auto& cache = InstructionsCache::get();
            if (i >= cache.size()) return "";
            qstring mnem;
            print_insn_mnem(&mnem, cache[i]);
            return mnem.c_str();
        })
        .column_int("size", [](size_t i) -> int {
            auto& cache = InstructionsCache::get();
            if (i >= cache.size()) return 0;
            return get_item_size(cache[i]);
        })
        .column_text("operand0", [](size_t i) -> std::string {
            auto& cache = InstructionsCache::get();
            if (i >= cache.size()) return "";
            qstring op;
            print_operand(&op, cache[i], 0);
            tag_remove(&op);
            return op.c_str();
        })
        .column_text("operand1", [](size_t i) -> std::string {
            auto& cache = InstructionsCache::get();
            if (i >= cache.size()) return "";
            qstring op;
            print_operand(&op, cache[i], 1);
            tag_remove(&op);
            return op.c_str();
        })
        .column_text("operand2", [](size_t i) -> std::string {
            auto& cache = InstructionsCache::get();
            if (i >= cache.size()) return "";
            qstring op;
            print_operand(&op, cache[i], 2);
            tag_remove(&op);
            return op.c_str();
        })
        .column_text("disasm", [](size_t i) -> std::string {
            auto& cache = InstructionsCache::get();
            if (i >= cache.size()) return "";
            qstring line;
            generate_disasm_line(&line, cache[i], 0);
            tag_remove(&line);
            return line.c_str();
        })
        .column_int64("func_addr", [](size_t i) -> int64_t {
            auto& cache = InstructionsCache::get();
            if (i >= cache.size()) return 0;
            func_t* f = get_func(cache[i]);
            return f ? f->start_ea : 0;
        })
        .deletable([](size_t i) -> bool {
            auto_wait();
            auto& cache = InstructionsCache::get();
            if (i >= cache.size()) return false;
            ea_t ea = cache[i];
            asize_t sz = get_item_size(ea);
            bool ok = del_items(ea, DELIT_SIMPLE, sz);
            auto_wait();
            return ok;
        })
        // Constraint pushdown: func_addr = X uses optimized iterator
        .filter_eq("func_addr", [](int64_t func_addr) -> std::unique_ptr<xsql::RowIterator> {
            return std::make_unique<InstructionsInFuncIterator>(static_cast<ea_t>(func_addr));
        }, 100.0)
        .build();
}

// ============================================================================
// Registry: All tables in one place
// ============================================================================

struct TableRegistry {
    // Index-based tables (use IDA's indexed access, no cache needed)
    VTableDef funcs;
    VTableDef segments;
    VTableDef names;
    VTableDef entries;
    VTableDef comments;
    VTableDef bookmarks;
    VTableDef heads;
    VTableDef instructions;

    // Cached tables (query-scoped cache - memory freed after query)
    CachedTableDef<XrefInfo> xrefs;
    CachedTableDef<BlockInfo> blocks;
    CachedTableDef<ImportInfo> imports;
    CachedTableDef<string_info_t> strings;

    // Global pointer for cache invalidation from SQL functions
    static inline TableRegistry* g_instance = nullptr;

    TableRegistry()
        : funcs(define_funcs())
        , segments(define_segments())
        , names(define_names())
        , entries(define_entries())
        , comments(define_comments())
        , bookmarks(define_bookmarks())
        , heads(define_heads())
        , instructions(define_instructions())
        , xrefs(define_xrefs())
        , blocks(define_blocks())
        , imports(define_imports())
        , strings(define_strings())
    {
        g_instance = this;
    }

    ~TableRegistry() {
        if (g_instance == this) g_instance = nullptr;
    }

    // Invalidate the strings cache (call after rebuild_strings)
    void invalidate_strings_cache() {
        strings.invalidate_cache();
    }

    // Static method for SQL functions to invalidate strings cache
    static void invalidate_strings_cache_global() {
        if (g_instance) g_instance->invalidate_strings_cache();
    }

    void register_all(xsql::Database& db) {
        // Index-based tables (use IDA's indexed access)
        register_index_table(db, "funcs", &funcs);
        register_index_table(db, "segments", &segments);
        register_index_table(db, "names", &names);
        register_index_table(db, "entries", &entries);
        register_index_table(db, "comments", &comments);
        register_index_table(db, "bookmarks", &bookmarks);
        register_index_table(db, "heads", &heads);
        register_index_table(db, "instructions", &instructions);

        // Cached tables (query-scoped cache)
        register_cached_table(db, "xrefs", &xrefs);
        register_cached_table(db, "blocks", &blocks);
        register_cached_table(db, "imports", &imports);
        register_cached_table(db, "strings", &strings);

        // Table-valued function for entity search
        search::register_jump_entities(db);

        // Create convenience views for common queries
        create_helper_views(db);
    }

    void create_helper_views(xsql::Database& db) {
        // callers view - who calls a function
        db.exec(R"(
            CREATE VIEW IF NOT EXISTS callers AS
            SELECT
                x.to_ea as func_addr,
                x.from_ea as caller_addr,
                f.name as caller_name,
                f.address as caller_func_addr
            FROM xrefs x
            LEFT JOIN funcs f ON x.from_ea >= f.address
                AND x.from_ea < f.end_ea
            WHERE x.is_code = 1
        )");

        // callees view - what does a function call
        db.exec(R"(
            CREATE VIEW IF NOT EXISTS callees AS
            SELECT
                f.address as func_addr,
                f.name as func_name,
                x.to_ea as callee_addr,
                COALESCE(f2.name, n.name, printf('sub_%X', x.to_ea)) as callee_name
            FROM funcs f
            JOIN xrefs x ON x.from_ea >= f.address
                AND x.from_ea < f.end_ea
            LEFT JOIN funcs f2 ON x.to_ea = f2.address
            LEFT JOIN names n ON x.to_ea = n.address
            WHERE x.is_code = 1
        )");

        // string_refs view - which functions reference which strings
        db.exec(R"(
            CREATE VIEW IF NOT EXISTS string_refs AS
            SELECT
                s.address as string_addr,
                s.content as string_value,
                s.length as string_length,
                x.from_ea as ref_addr,
                f.address as func_addr,
                f.name as func_name
            FROM strings s
            JOIN xrefs x ON x.to_ea = s.address
            LEFT JOIN funcs f ON x.from_ea >= f.address
                AND x.from_ea < f.end_ea
        )");
    }

private:
    void register_index_table(xsql::Database& db, const char* name, const VTableDef* def) {
        std::string module_name = std::string("ida_") + name;
        db.register_table(module_name.c_str(), def);
        db.create_table(name, module_name.c_str());
    }

    template<typename RowData>
    void register_cached_table(xsql::Database& db, const char* name, const CachedTableDef<RowData>* def) {
        std::string module_name = std::string("ida_") + name;
        db.register_cached_table(module_name.c_str(), def);
        db.create_table(name, module_name.c_str());
    }
};

} // namespace entities
} // namespace idasql

```

`src/lib/include/idasql/entities_dbg.hpp`:

```hpp
/**
 * entities_dbg.hpp - Debugger-related IDA entities as virtual tables
 *
 * Tables:
 *   breakpoints - Debugger breakpoints (software, hardware, symbolic, source)
 *
 * Breakpoints persist in the IDB, so they're queryable even without an active
 * debugger session. Supports full CRUD operations.
 */

#pragma once

#include <idasql/platform.hpp>

#include <idasql/vtable.hpp>
#include <xsql/database.hpp>

#include <idasql/platform_undef.hpp>

// IDA SDK headers
#include <ida.hpp>
#include <dbg.hpp>
#include <auto.hpp>

namespace idasql {
namespace debugger {

// ============================================================================
// Helpers
// ============================================================================

inline const char* bpt_type_name(bpttype_t type) {
    switch (type) {
        case BPT_WRITE: return "hardware_write";
        case BPT_READ:  return "hardware_read";
        case BPT_RDWR:  return "hardware_rdwr";
        case BPT_SOFT:  return "software";
        case BPT_EXEC:  return "hardware_exec";
        default:        return "unknown";
    }
}

inline const char* bpt_loc_type_name(int loc_type) {
    switch (loc_type) {
        case BPLT_ABS: return "absolute";
        case BPLT_REL: return "relative";
        case BPLT_SYM: return "symbolic";
        case BPLT_SRC: return "source";
        default:       return "unknown";
    }
}

inline std::string safe_bpt_group(const bpt_t& bpt) {
    qstring grp;
    if (get_bpt_group(&grp, bpt.loc))
        return std::string(grp.c_str());
    return "";
}

inline std::string safe_bpt_loc_path(const bpt_t& bpt) {
    const bpt_location_t& loc = bpt.loc;
    if (loc.type() == BPLT_REL || loc.type() == BPLT_SRC) {
        const char* p = loc.path();
        return p ? std::string(p) : "";
    }
    return "";
}

inline std::string safe_bpt_loc_symbol(const bpt_t& bpt) {
    const bpt_location_t& loc = bpt.loc;
    if (loc.type() == BPLT_SYM) {
        const char* s = loc.symbol();
        return s ? std::string(s) : "";
    }
    return "";
}

// ============================================================================
// BREAKPOINTS Table (full CRUD)
// ============================================================================

inline VTableDef define_breakpoints() {
    return table("breakpoints")
        .count([]() { return static_cast<size_t>(get_bpt_qty()); })
        // Column 0: address (R)
        .column_int64("address", [](size_t i) -> int64_t {
            bpt_t bpt;
            if (!getn_bpt(i, &bpt)) return 0;
            return static_cast<int64_t>(bpt.ea);
        })
        // Column 1: enabled (RW)
        .column_int_rw("enabled",
            [](size_t i) -> int {
                bpt_t bpt;
                if (!getn_bpt(i, &bpt)) return 0;
                return bpt.enabled() ? 1 : 0;
            },
            [](size_t i, int val) -> bool {
                bpt_t bpt;
                if (!getn_bpt(i, &bpt)) return false;
                return enable_bpt(bpt.loc, val != 0);
            })
        // Column 2: type (RW)
        .column_int_rw("type",
            [](size_t i) -> int {
                bpt_t bpt;
                if (!getn_bpt(i, &bpt)) return 0;
                return static_cast<int>(bpt.type);
            },
            [](size_t i, int val) -> bool {
                bpt_t bpt;
                if (!getn_bpt(i, &bpt)) return false;
                bpt.type = static_cast<bpttype_t>(val);
                return update_bpt(&bpt);
            })
        // Column 3: type_name (R)
        .column_text("type_name", [](size_t i) -> std::string {
            bpt_t bpt;
            if (!getn_bpt(i, &bpt)) return "";
            return bpt_type_name(bpt.type);
        })
        // Column 4: size (RW)
        .column_int_rw("size",
            [](size_t i) -> int {
                bpt_t bpt;
                if (!getn_bpt(i, &bpt)) return 0;
                return bpt.size;
            },
            [](size_t i, int val) -> bool {
                bpt_t bpt;
                if (!getn_bpt(i, &bpt)) return false;
                bpt.size = val;
                return update_bpt(&bpt);
            })
        // Column 5: flags (RW)
        .column_int64_rw("flags",
            [](size_t i) -> int64_t {
                bpt_t bpt;
                if (!getn_bpt(i, &bpt)) return 0;
                return static_cast<int64_t>(bpt.flags);
            },
            [](size_t i, int64_t val) -> bool {
                bpt_t bpt;
                if (!getn_bpt(i, &bpt)) return false;
                // Preserve BPT_ENABLED from current state so flags writes
                // don't undo enable_bpt() calls during batch vtable updates
                uint32 cur_enabled = bpt.flags & BPT_ENABLED;
                bpt.flags = (static_cast<uint32>(val) & ~BPT_ENABLED) | cur_enabled;
                return update_bpt(&bpt);
            })
        // Column 6: pass_count (RW)
        .column_int_rw("pass_count",
            [](size_t i) -> int {
                bpt_t bpt;
                if (!getn_bpt(i, &bpt)) return 0;
                return bpt.pass_count;
            },
            [](size_t i, int val) -> bool {
                bpt_t bpt;
                if (!getn_bpt(i, &bpt)) return false;
                bpt.pass_count = val;
                return update_bpt(&bpt);
            })
        // Column 7: condition (RW)
        .column_text_rw("condition",
            [](size_t i) -> std::string {
                bpt_t bpt;
                if (!getn_bpt(i, &bpt)) return "";
                return std::string(bpt.cndbody.c_str());
            },
            [](size_t i, const char* val) -> bool {
                bpt_t bpt;
                if (!getn_bpt(i, &bpt)) return false;
                bpt.cndbody = val;
                return update_bpt(&bpt);
            })
        // Column 8: loc_type (R)
        .column_int("loc_type", [](size_t i) -> int {
            bpt_t bpt;
            if (!getn_bpt(i, &bpt)) return 0;
            return bpt.loc.type();
        })
        // Column 9: loc_type_name (R)
        .column_text("loc_type_name", [](size_t i) -> std::string {
            bpt_t bpt;
            if (!getn_bpt(i, &bpt)) return "";
            return bpt_loc_type_name(bpt.loc.type());
        })
        // Column 10: module (R)
        .column_text("module", [](size_t i) -> std::string {
            bpt_t bpt;
            if (!getn_bpt(i, &bpt)) return "";
            return safe_bpt_loc_path(bpt);
        })
        // Column 11: symbol (R)
        .column_text("symbol", [](size_t i) -> std::string {
            bpt_t bpt;
            if (!getn_bpt(i, &bpt)) return "";
            return safe_bpt_loc_symbol(bpt);
        })
        // Column 12: offset (R)
        .column_int64("offset", [](size_t i) -> int64_t {
            bpt_t bpt;
            if (!getn_bpt(i, &bpt)) return 0;
            int lt = bpt.loc.type();
            if (lt == BPLT_REL || lt == BPLT_SYM)
                return static_cast<int64_t>(bpt.loc.offset());
            return 0;
        })
        // Column 13: source_file (R)
        .column_text("source_file", [](size_t i) -> std::string {
            bpt_t bpt;
            if (!getn_bpt(i, &bpt)) return "";
            if (bpt.loc.type() == BPLT_SRC) {
                const char* p = bpt.loc.path();
                return p ? std::string(p) : "";
            }
            return "";
        })
        // Column 14: source_line (R)
        .column_int("source_line", [](size_t i) -> int {
            bpt_t bpt;
            if (!getn_bpt(i, &bpt)) return 0;
            if (bpt.loc.type() == BPLT_SRC)
                return bpt.loc.lineno();
            return 0;
        })
        // Column 15: is_hardware (R)
        .column_int("is_hardware", [](size_t i) -> int {
            bpt_t bpt;
            if (!getn_bpt(i, &bpt)) return 0;
            return bpt.is_hwbpt() ? 1 : 0;
        })
        // Column 16: is_active (R)
        .column_int("is_active", [](size_t i) -> int {
            bpt_t bpt;
            if (!getn_bpt(i, &bpt)) return 0;
            return bpt.is_active() ? 1 : 0;
        })
        // Column 17: group (RW)
        .column_text_rw("group",
            [](size_t i) -> std::string {
                bpt_t bpt;
                if (!getn_bpt(i, &bpt)) return "";
                return safe_bpt_group(bpt);
            },
            [](size_t i, const char* val) -> bool {
                bpt_t bpt;
                if (!getn_bpt(i, &bpt)) return false;
                return set_bpt_group(bpt, val);
            })
        // Column 18: bptid (R)
        .column_int64("bptid", [](size_t i) -> int64_t {
            bpt_t bpt;
            if (!getn_bpt(i, &bpt)) return 0;
            return static_cast<int64_t>(bpt.bptid);
        })
        // DELETE support
        .deletable([](size_t i) -> bool {
            bpt_t bpt;
            if (!getn_bpt(i, &bpt)) return false;
            return del_bpt(bpt.loc);
        })
        // INSERT support
        // argv column order: address(0), enabled(1), type(2), type_name(3),
        //   size(4), flags(5), pass_count(6), condition(7), loc_type(8),
        //   loc_type_name(9), module(10), symbol(11), offset(12),
        //   source_file(13), source_line(14), is_hardware(15), is_active(16),
        //   group(17), bptid(18)
        .insertable([](int argc, sqlite3_value** argv) -> bool {
            // Determine location type from which columns are non-NULL
            // argv[0] = address, argv[11] = symbol, argv[10] = module,
            // argv[13] = source_file

            auto is_non_null = [&](int col) -> bool {
                return col < argc && sqlite3_value_type(argv[col]) != SQLITE_NULL;
            };

            auto get_text = [&](int col) -> const char* {
                if (col >= argc) return nullptr;
                const char* t = reinterpret_cast<const char*>(sqlite3_value_text(argv[col]));
                return t;
            };

            auto get_int = [&](int col, int def = 0) -> int {
                if (!is_non_null(col)) return def;
                return sqlite3_value_int(argv[col]);
            };

            auto get_int64 = [&](int col, int64_t def = 0) -> int64_t {
                if (!is_non_null(col)) return def;
                return sqlite3_value_int64(argv[col]);
            };

            bool ok = false;

            if (is_non_null(11)) {
                // Symbolic breakpoint: symbol column set
                const char* sym = get_text(11);
                if (!sym) return false;
                int64_t off = get_int64(12, 0);
                bpt_t bpt;
                bpt.loc.set_sym_bpt(sym, static_cast<uval_t>(off));
                bpt.type = static_cast<bpttype_t>(get_int(2, BPT_SOFT));
                bpt.size = get_int(4, 0);
                ok = add_bpt(bpt);
            } else if (is_non_null(10)) {
                // Relative breakpoint: module column set
                const char* mod = get_text(10);
                if (!mod) return false;
                int64_t off = get_int64(12, 0);
                bpt_t bpt;
                bpt.loc.set_rel_bpt(mod, static_cast<uval_t>(off));
                bpt.type = static_cast<bpttype_t>(get_int(2, BPT_SOFT));
                bpt.size = get_int(4, 0);
                ok = add_bpt(bpt);
            } else if (is_non_null(13)) {
                // Source breakpoint: source_file column set
                const char* file = get_text(13);
                if (!file) return false;
                int line = get_int(14, 1);
                bpt_t bpt;
                bpt.loc.set_src_bpt(file, line);
                bpt.type = static_cast<bpttype_t>(get_int(2, BPT_SOFT));
                bpt.size = get_int(4, 0);
                ok = add_bpt(bpt);
            } else if (is_non_null(0)) {
                // Absolute breakpoint: address column set
                ea_t ea = static_cast<ea_t>(get_int64(0));
                int sz = get_int(4, 0);
                bpttype_t tp = static_cast<bpttype_t>(get_int(2, BPT_SOFT));
                ok = add_bpt(ea, sz, tp);
            } else {
                return false;  // No location specified
            }

            if (!ok) return false;

            // Apply optional properties after creation
            // We need to find the breakpoint we just created
            // Re-read to get the bpt_t for the newly added breakpoint
            if (is_non_null(7)) {
                // condition
                const char* cond = get_text(7);
                if (cond) {
                    // Find the breakpoint and update condition
                    bpt_t bpt;
                    int n = get_bpt_qty();
                    for (int j = n - 1; j >= 0; --j) {
                        if (getn_bpt(j, &bpt)) {
                            // Match by address for absolute, or just use last added
                            if (is_non_null(0) && bpt.ea == static_cast<ea_t>(get_int64(0))) {
                                bpt.cndbody = cond;
                                update_bpt(&bpt);
                                break;
                            } else if (!is_non_null(0)) {
                                // For non-absolute, use the last breakpoint
                                bpt.cndbody = cond;
                                update_bpt(&bpt);
                                break;
                            }
                        }
                    }
                }
            }

            if (is_non_null(6)) {
                // pass_count
                bpt_t bpt;
                int n = get_bpt_qty();
                for (int j = n - 1; j >= 0; --j) {
                    if (getn_bpt(j, &bpt)) {
                        if (is_non_null(0) && bpt.ea == static_cast<ea_t>(get_int64(0))) {
                            bpt.pass_count = get_int(6);
                            update_bpt(&bpt);
                            break;
                        } else if (!is_non_null(0)) {
                            bpt.pass_count = get_int(6);
                            update_bpt(&bpt);
                            break;
                        }
                    }
                }
            }

            if (is_non_null(5)) {
                // flags
                bpt_t bpt;
                int n = get_bpt_qty();
                for (int j = n - 1; j >= 0; --j) {
                    if (getn_bpt(j, &bpt)) {
                        if (is_non_null(0) && bpt.ea == static_cast<ea_t>(get_int64(0))) {
                            bpt.flags = static_cast<uint32>(get_int64(5));
                            update_bpt(&bpt);
                            break;
                        } else if (!is_non_null(0)) {
                            bpt.flags = static_cast<uint32>(get_int64(5));
                            update_bpt(&bpt);
                            break;
                        }
                    }
                }
            }

            if (is_non_null(1)) {
                // enabled - use enable_bpt API
                bool enable = get_int(1) != 0;
                bpt_t bpt;
                int n = get_bpt_qty();
                for (int j = n - 1; j >= 0; --j) {
                    if (getn_bpt(j, &bpt)) {
                        if (is_non_null(0) && bpt.ea == static_cast<ea_t>(get_int64(0))) {
                            enable_bpt(bpt.loc, enable);
                            break;
                        } else if (!is_non_null(0)) {
                            enable_bpt(bpt.loc, enable);
                            break;
                        }
                    }
                }
            }

            if (is_non_null(17)) {
                // group
                const char* grp = get_text(17);
                if (grp) {
                    bpt_t bpt;
                    int n = get_bpt_qty();
                    for (int j = n - 1; j >= 0; --j) {
                        if (getn_bpt(j, &bpt)) {
                            if (is_non_null(0) && bpt.ea == static_cast<ea_t>(get_int64(0))) {
                                set_bpt_group(bpt, grp);
                                break;
                            } else if (!is_non_null(0)) {
                                set_bpt_group(bpt, grp);
                                break;
                            }
                        }
                    }
                }
            }

            return true;
        })
        .build();
}

// ============================================================================
// Debugger Registry
// ============================================================================

struct DebuggerRegistry {
    VTableDef breakpoints;

    DebuggerRegistry()
        : breakpoints(define_breakpoints())
    {}

    void register_all(xsql::Database& db) {
        db.register_table("ida_breakpoints", &breakpoints);
        db.create_table("breakpoints", "ida_breakpoints");
    }
};

} // namespace debugger
} // namespace idasql

```

`src/lib/include/idasql/entities_ext.hpp`:

```hpp
/**
 * ida_entities_extended.hpp - Additional IDA entities as virtual tables
 *
 * This file provides additional virtual tables beyond the core entities.
 * These tables cover: fixups, hidden ranges, problems, function chunks,
 * signatures, local types, and more.
 *
 * Tables:
 *   fixups         - Relocation/fixup records
 *   hidden_ranges  - Collapsed/hidden regions
 *   problems       - Analysis problems
 *   fchunks        - Function chunks (tails)
 *   signatures     - Applied FLIRT signatures
 *   local_types    - Local type library entries
 *   mappings       - Address mappings
 */

#pragma once

#include <idasql/platform.hpp>

#include <idasql/vtable.hpp>
#include <xsql/database.hpp>

#include <idasql/platform_undef.hpp>

// IDA SDK headers
#include <ida.hpp>
#include <fixup.hpp>
#include <bytes.hpp>
#include <problems.hpp>
#include <funcs.hpp>
#include <typeinf.hpp>
#include <frame.hpp>
#include <name.hpp>
#include <lines.hpp>

namespace idasql {
namespace extended {

// ============================================================================
// FIXUPS Table - Relocation records
// ============================================================================

struct FixupEntry {
    ea_t ea;
    fixup_data_t data;
};

inline std::vector<FixupEntry>& get_fixups_cache() {
    static std::vector<FixupEntry> cache;
    return cache;
}

inline void rebuild_fixups_cache() {
    auto& cache = get_fixups_cache();
    cache.clear();

    for (ea_t ea = get_first_fixup_ea(); ea != BADADDR; ea = get_next_fixup_ea(ea)) {
        FixupEntry entry;
        entry.ea = ea;
        if (get_fixup(&entry.data, ea)) {
            cache.push_back(entry);
        }
    }
}

inline VTableDef define_fixups() {
    return table("fixups")
        .count([]() {
            rebuild_fixups_cache();
            return get_fixups_cache().size();
        })
        .column_int64("address", [](size_t i) -> int64_t {
            auto& cache = get_fixups_cache();
            return i < cache.size() ? cache[i].ea : 0;
        })
        .column_int64("target", [](size_t i) -> int64_t {
            auto& cache = get_fixups_cache();
            return i < cache.size() ? cache[i].data.off : 0;
        })
        .column_int("type", [](size_t i) -> int {
            auto& cache = get_fixups_cache();
            return i < cache.size() ? cache[i].data.get_type() : 0;
        })
        .column_int("flags", [](size_t i) -> int {
            auto& cache = get_fixups_cache();
            return i < cache.size() ? cache[i].data.get_flags() : 0;
        })
        .build();
}

// ============================================================================
// HIDDEN_RANGES Table - Collapsed/hidden regions
// ============================================================================

inline VTableDef define_hidden_ranges() {
    return table("hidden_ranges")
        .count([]() {
            return static_cast<size_t>(get_hidden_range_qty());
        })
        .column_int64("start_ea", [](size_t i) -> int64_t {
            hidden_range_t* hr = getn_hidden_range(static_cast<int>(i));
            return hr ? hr->start_ea : 0;
        })
        .column_int64("end_ea", [](size_t i) -> int64_t {
            hidden_range_t* hr = getn_hidden_range(static_cast<int>(i));
            return hr ? hr->end_ea : 0;
        })
        .column_int64("size", [](size_t i) -> int64_t {
            hidden_range_t* hr = getn_hidden_range(static_cast<int>(i));
            return hr ? (hr->end_ea - hr->start_ea) : 0;
        })
        .column_text("description", [](size_t i) -> std::string {
            hidden_range_t* hr = getn_hidden_range(static_cast<int>(i));
            return hr && hr->description ? hr->description : "";
        })
        .column_text("header", [](size_t i) -> std::string {
            hidden_range_t* hr = getn_hidden_range(static_cast<int>(i));
            return hr && hr->header ? hr->header : "";
        })
        .column_text("footer", [](size_t i) -> std::string {
            hidden_range_t* hr = getn_hidden_range(static_cast<int>(i));
            return hr && hr->footer ? hr->footer : "";
        })
        .column_int("visible", [](size_t i) -> int {
            hidden_range_t* hr = getn_hidden_range(static_cast<int>(i));
            return hr ? hr->visible : 0;
        })
        .column_int("color", [](size_t i) -> int {
            hidden_range_t* hr = getn_hidden_range(static_cast<int>(i));
            return hr ? hr->color : 0;
        })
        .build();
}

// ============================================================================
// PROBLEMS Table - Analysis problems
// ============================================================================

struct ProblemEntry {
    ea_t ea;
    problist_id_t type;
    std::string description;
    std::string type_name;
};

inline std::vector<ProblemEntry>& get_problems_cache() {
    static std::vector<ProblemEntry> cache;
    return cache;
}

inline void rebuild_problems_cache() {
    auto& cache = get_problems_cache();
    cache.clear();

    // Iterate all problem types
    for (int t = PR_NOBASE; t < PR_END; ++t) {
        problist_id_t ptype = static_cast<problist_id_t>(t);
        const char* tname = get_problem_name(ptype, true);

        for (ea_t ea = get_problem(ptype, 0); ea != BADADDR; ea = get_problem(ptype, ea + 1)) {
            ProblemEntry entry;
            entry.ea = ea;
            entry.type = ptype;
            entry.type_name = tname ? tname : "";

            qstring desc;
            if (get_problem_desc(&desc, ptype, ea) > 0) {
                entry.description = desc.c_str();
            }
            cache.push_back(entry);
        }
    }
}

inline VTableDef define_problems() {
    return table("problems")
        .count([]() {
            rebuild_problems_cache();
            return get_problems_cache().size();
        })
        .column_int64("address", [](size_t i) -> int64_t {
            auto& cache = get_problems_cache();
            return i < cache.size() ? cache[i].ea : 0;
        })
        .column_int("type_id", [](size_t i) -> int {
            auto& cache = get_problems_cache();
            return i < cache.size() ? cache[i].type : 0;
        })
        .column_text("type", [](size_t i) -> std::string {
            auto& cache = get_problems_cache();
            return i < cache.size() ? cache[i].type_name : "";
        })
        .column_text("description", [](size_t i) -> std::string {
            auto& cache = get_problems_cache();
            return i < cache.size() ? cache[i].description : "";
        })
        .build();
}

// ============================================================================
// FCHUNKS Table - Function chunks (tails)
// ============================================================================

inline VTableDef define_fchunks() {
    return table("fchunks")
        .count([]() {
            return get_fchunk_qty();
        })
        .column_int64("start_ea", [](size_t i) -> int64_t {
            func_t* chunk = getn_fchunk(i);
            return chunk ? chunk->start_ea : 0;
        })
        .column_int64("end_ea", [](size_t i) -> int64_t {
            func_t* chunk = getn_fchunk(i);
            return chunk ? chunk->end_ea : 0;
        })
        .column_int64("size", [](size_t i) -> int64_t {
            func_t* chunk = getn_fchunk(i);
            return chunk ? chunk->size() : 0;
        })
        .column_int64("owner", [](size_t i) -> int64_t {
            func_t* chunk = getn_fchunk(i);
            if (!chunk) return 0;
            // For tail chunks, find the owner
            func_t* owner = get_func(chunk->start_ea);
            return owner ? owner->start_ea : 0;
        })
        .column_int("flags", [](size_t i) -> int {
            func_t* chunk = getn_fchunk(i);
            return chunk ? chunk->flags : 0;
        })
        .column_int("is_tail", [](size_t i) -> int {
            func_t* chunk = getn_fchunk(i);
            // FUNC_TAIL indicates this is a tail/chunk of another function
            return chunk ? ((chunk->flags & FUNC_TAIL) ? 1 : 0) : 0;
        })
        .build();
}

// ============================================================================
// SIGNATURES Table - Applied FLIRT signatures
// ============================================================================

struct SignatureEntry {
    int index;
    std::string name;
    std::string optlibs;
    int32 state;
};

inline std::vector<SignatureEntry>& get_signatures_cache() {
    static std::vector<SignatureEntry> cache;
    return cache;
}

inline void rebuild_signatures_cache() {
    auto& cache = get_signatures_cache();
    cache.clear();

    int qty = get_idasgn_qty();
    for (int i = 0; i < qty; ++i) {
        SignatureEntry entry;
        entry.index = i;

        qstring signame, optlibs;
        entry.state = get_idasgn_desc(&signame, &optlibs, i);
        entry.name = signame.c_str();
        entry.optlibs = optlibs.c_str();
        cache.push_back(entry);
    }
}

inline VTableDef define_signatures() {
    return table("signatures")
        .count([]() {
            rebuild_signatures_cache();
            return get_signatures_cache().size();
        })
        .column_int("index", [](size_t i) -> int {
            auto& cache = get_signatures_cache();
            return i < cache.size() ? cache[i].index : 0;
        })
        .column_text("name", [](size_t i) -> std::string {
            auto& cache = get_signatures_cache();
            return i < cache.size() ? cache[i].name : "";
        })
        .column_text("optlibs", [](size_t i) -> std::string {
            auto& cache = get_signatures_cache();
            return i < cache.size() ? cache[i].optlibs : "";
        })
        .column_int("state", [](size_t i) -> int {
            auto& cache = get_signatures_cache();
            return i < cache.size() ? cache[i].state : 0;
        })
        .build();
}

// ============================================================================
// LOCAL_TYPES Table - Local type library entries
// ============================================================================

struct LocalTypeEntry {
    uint32_t ordinal;
    std::string name;
    std::string type_str;
    bool is_struct;
    bool is_enum;
    bool is_typedef;
};

inline std::vector<LocalTypeEntry>& get_local_types_cache() {
    static std::vector<LocalTypeEntry> cache;
    return cache;
}

inline void rebuild_local_types_cache() {
    auto& cache = get_local_types_cache();
    cache.clear();

    til_t* ti = get_idati();
    if (!ti) return;

    // Iterate numbered types
    uint32_t ord = 1;
    while (true) {
        const char* name = get_numbered_type_name(ti, ord);
        if (!name) break;

        LocalTypeEntry entry;
        entry.ordinal = ord;
        entry.name = name;

        tinfo_t tif;
        if (tif.get_numbered_type(ti, ord)) {
            qstring ts;
            tif.print(&ts);
            entry.type_str = ts.c_str();
            entry.is_struct = tif.is_struct() || tif.is_union();
            entry.is_enum = tif.is_enum();
            entry.is_typedef = tif.is_typedef();
        } else {
            entry.is_struct = false;
            entry.is_enum = false;
            entry.is_typedef = false;
        }

        cache.push_back(entry);
        ++ord;
    }
}

inline VTableDef define_local_types() {
    return table("local_types")
        .count([]() {
            rebuild_local_types_cache();
            return get_local_types_cache().size();
        })
        .column_int("ordinal", [](size_t i) -> int {
            auto& cache = get_local_types_cache();
            return i < cache.size() ? cache[i].ordinal : 0;
        })
        .column_text("name", [](size_t i) -> std::string {
            auto& cache = get_local_types_cache();
            return i < cache.size() ? cache[i].name : "";
        })
        .column_text("type", [](size_t i) -> std::string {
            auto& cache = get_local_types_cache();
            return i < cache.size() ? cache[i].type_str : "";
        })
        .column_int("is_struct", [](size_t i) -> int {
            auto& cache = get_local_types_cache();
            return i < cache.size() ? (cache[i].is_struct ? 1 : 0) : 0;
        })
        .column_int("is_enum", [](size_t i) -> int {
            auto& cache = get_local_types_cache();
            return i < cache.size() ? (cache[i].is_enum ? 1 : 0) : 0;
        })
        .column_int("is_typedef", [](size_t i) -> int {
            auto& cache = get_local_types_cache();
            return i < cache.size() ? (cache[i].is_typedef ? 1 : 0) : 0;
        })
        .build();
}

// ============================================================================
// MAPPINGS Table - Address mappings
// ============================================================================

inline VTableDef define_mappings() {
    return table("mappings")
        .count([]() {
            return get_mappings_qty();
        })
        .column_int64("from_ea", [](size_t i) -> int64_t {
            ea_t from, to;
            asize_t size;
            if (get_mapping(&from, &to, &size, i)) {
                return from;
            }
            return 0;
        })
        .column_int64("to_ea", [](size_t i) -> int64_t {
            ea_t from, to;
            asize_t size;
            if (get_mapping(&from, &to, &size, i)) {
                return to;
            }
            return 0;
        })
        .column_int64("size", [](size_t i) -> int64_t {
            ea_t from, to;
            asize_t size;
            if (get_mapping(&from, &to, &size, i)) {
                return size;
            }
            return 0;
        })
        .build();
}

// ============================================================================
// Extended Registry
// ============================================================================

struct ExtendedRegistry {
    VTableDef fixups;
    VTableDef hidden_ranges;
    VTableDef problems;
    VTableDef fchunks;
    VTableDef signatures;
    VTableDef local_types;
    VTableDef mappings;

    ExtendedRegistry()
        : fixups(define_fixups())
        , hidden_ranges(define_hidden_ranges())
        , problems(define_problems())
        , fchunks(define_fchunks())
        , signatures(define_signatures())
        , local_types(define_local_types())
        , mappings(define_mappings())
    {}

    void register_all(xsql::Database& db) {
        db.register_table("ida_fixups", &fixups);
        db.create_table("fixups", "ida_fixups");

        db.register_table("ida_hidden_ranges", &hidden_ranges);
        db.create_table("hidden_ranges", "ida_hidden_ranges");

        db.register_table("ida_problems", &problems);
        db.create_table("problems", "ida_problems");

        db.register_table("ida_fchunks", &fchunks);
        db.create_table("fchunks", "ida_fchunks");

        db.register_table("ida_signatures", &signatures);
        db.create_table("signatures", "ida_signatures");

        db.register_table("ida_local_types", &local_types);
        db.create_table("local_types", "ida_local_types");

        db.register_table("ida_mappings", &mappings);
        db.create_table("mappings", "ida_mappings");
    }
};

} // namespace extended
} // namespace idasql

```

`src/lib/include/idasql/entities_search.hpp`:

```hpp
/**
 * entities_search.hpp - Table-valued function for unified entity search
 *
 * Provides the `jump_entities` virtual table for "Jump to Anything" functionality.
 * This is an eponymous virtual table that acts like a table-valued function:
 *
 *   SELECT * FROM jump_entities('pattern', 'mode') LIMIT 10;
 *
 * Or equivalently:
 *
 *   SELECT * FROM jump_entities WHERE pattern = 'main' AND mode = 'prefix' LIMIT 10;
 *
 * Parameters:
 *   pattern - Search pattern (required)
 *   mode    - 'prefix' (LIKE 'x%') or 'contains' (LIKE '%x%')
 *
 * Columns returned:
 *   name        - Entity name
 *   kind        - 'function', 'label', 'segment', 'struct', 'union', 'enum', 'member', 'enum_member'
 *   address     - Address (for functions, labels, segments) or NULL
 *   ordinal     - Type ordinal (for types, members) or NULL
 *   parent_name - Parent type name (for members) or NULL
 *   full_name   - Fully qualified name (parent.member for members)
 *
 * The table lazily iterates through source tables, stopping when LIMIT is reached.
 */

#pragma once

#include <idasql/platform.hpp>

#include <xsql/database.hpp>
#include <string>
#include <cstring>
#include <cctype>
#include <algorithm>

#include <idasql/platform_undef.hpp>

// IDA SDK
#include <ida.hpp>
#include <funcs.hpp>
#include <name.hpp>
#include <segment.hpp>
#include <typeinf.hpp>

namespace idasql {
namespace search {

// ============================================================================
// Entity Sources - each represents one category of searchable entities
// ============================================================================

enum class EntitySource {
    Functions = 0,
    Labels,
    Segments,
    Structs,
    Unions,
    Enums,
    Members,
    EnumMembers,
    Done
};

// ============================================================================
// Entity Row - one result row
// ============================================================================

struct EntityRow {
    std::string name;
    std::string kind;
    ea_t address = BADADDR;
    uint32 ordinal = 0;
    std::string parent_name;
    std::string full_name;
    bool has_address = false;
    bool has_ordinal = false;
};

// ============================================================================
// Entity Generator - iterates through all matching entities
// ============================================================================

class EntityGenerator {
    std::string pattern_;
    bool contains_mode_;

    EntitySource current_source_ = EntitySource::Functions;
    size_t current_index_ = 0;
    EntityRow current_row_;
    bool has_current_ = false;

    // For type iteration
    uint32 type_ordinal_ = 0;
    size_t member_index_ = 0;
    tinfo_t current_type_;

public:
    EntityGenerator(const std::string& pattern, bool contains_mode)
        : pattern_(to_lower(pattern)), contains_mode_(contains_mode) {}

    bool next() {
        has_current_ = false;

        while (current_source_ != EntitySource::Done) {
            if (advance_current_source()) {
                has_current_ = true;
                return true;
            }
            // Move to next source
            current_source_ = static_cast<EntitySource>(static_cast<int>(current_source_) + 1);
            current_index_ = 0;
            type_ordinal_ = 0;
            member_index_ = 0;
        }
        return false;
    }

    const EntityRow& current() const { return current_row_; }
    bool eof() const { return !has_current_ && current_source_ == EntitySource::Done; }

private:
    static std::string to_lower(const std::string& s) {
        std::string result;
        result.reserve(s.size());
        for (char c : s) {
            result += static_cast<char>(std::tolower(static_cast<unsigned char>(c)));
        }
        return result;
    }

    bool matches(const std::string& name) const {
        std::string lower_name = to_lower(name);
        if (contains_mode_) {
            return lower_name.find(pattern_) != std::string::npos;
        } else {
            return lower_name.compare(0, pattern_.size(), pattern_) == 0;
        }
    }

    bool advance_current_source() {
        switch (current_source_) {
            case EntitySource::Functions:  return advance_functions();
            case EntitySource::Labels:     return advance_labels();
            case EntitySource::Segments:   return advance_segments();
            case EntitySource::Structs:    return advance_structs();
            case EntitySource::Unions:     return advance_unions();
            case EntitySource::Enums:      return advance_enums();
            case EntitySource::Members:    return advance_members();
            case EntitySource::EnumMembers: return advance_enum_members();
            case EntitySource::Done:       return false;
        }
        return false;
    }

    bool advance_functions() {
        size_t count = get_func_qty();
        while (current_index_ < count) {
            func_t* fn = getn_func(current_index_++);
            if (!fn) continue;

            qstring name;
            if (get_func_name(&name, fn->start_ea) <= 0) continue;

            std::string name_str(name.c_str());
            if (matches(name_str)) {
                current_row_.name = name_str;
                current_row_.kind = "function";
                current_row_.address = fn->start_ea;
                current_row_.has_address = true;
                current_row_.has_ordinal = false;
                current_row_.parent_name.clear();
                current_row_.full_name = name_str;
                return true;
            }
        }
        return false;
    }

    bool advance_labels() {
        // Iterate named locations that aren't function starts
        // Use get_nlist_size/get_nlist_ea/get_nlist_name
        size_t count = get_nlist_size();
        while (current_index_ < count) {
            ea_t ea = get_nlist_ea(current_index_);
            const char* name = get_nlist_name(current_index_);
            current_index_++;

            if (!name || !*name) continue;

            // Skip if it's a function start
            func_t* fn = get_func(ea);
            if (fn && fn->start_ea == ea) continue;

            std::string name_str(name);
            if (matches(name_str)) {
                current_row_.name = name_str;
                current_row_.kind = "label";
                current_row_.address = ea;
                current_row_.has_address = true;
                current_row_.has_ordinal = false;
                current_row_.parent_name.clear();
                current_row_.full_name = name_str;
                return true;
            }
        }
        return false;
    }

    bool advance_segments() {
        int count = get_segm_qty();
        while (static_cast<int>(current_index_) < count) {
            segment_t* seg = getnseg(static_cast<int>(current_index_++));
            if (!seg) continue;

            qstring name;
            if (get_segm_name(&name, seg) <= 0) continue;

            std::string name_str(name.c_str());
            if (matches(name_str)) {
                current_row_.name = name_str;
                current_row_.kind = "segment";
                current_row_.address = seg->start_ea;
                current_row_.has_address = true;
                current_row_.has_ordinal = false;
                current_row_.parent_name.clear();
                current_row_.full_name = name_str;
                return true;
            }
        }
        return false;
    }

    bool advance_types_of_kind(const char* kind, bool want_struct, bool want_union, bool want_enum) {
        uint32 count = get_ordinal_count(nullptr);
        while (type_ordinal_ < count) {
            uint32 ord = type_ordinal_++;
            tinfo_t tif;
            if (!tif.get_numbered_type(nullptr, ord)) continue;

            bool is_struct = tif.is_struct();
            bool is_union = tif.is_union();
            bool is_enum = tif.is_enum();

            if (want_struct && !is_struct) continue;
            if (want_union && !is_union) continue;
            if (want_enum && !is_enum) continue;

            qstring name;
            if (!tif.get_type_name(&name)) continue;

            std::string name_str(name.c_str());
            if (matches(name_str)) {
                current_row_.name = name_str;
                current_row_.kind = kind;
                current_row_.has_address = false;
                current_row_.ordinal = ord;
                current_row_.has_ordinal = true;
                current_row_.parent_name.clear();
                current_row_.full_name = name_str;
                return true;
            }
        }
        return false;
    }

    bool advance_structs() {
        return advance_types_of_kind("struct", true, false, false);
    }

    bool advance_unions() {
        return advance_types_of_kind("union", false, true, false);
    }

    bool advance_enums() {
        return advance_types_of_kind("enum", false, false, true);
    }

    bool advance_members() {
        // Iterate struct/union members
        uint32 count = get_ordinal_count(nullptr);

        while (type_ordinal_ < count) {
            // Get current type if not already loaded
            if (!current_type_.get_numbered_type(nullptr, type_ordinal_)) {
                type_ordinal_++;
                member_index_ = 0;
                continue;
            }

            if (!current_type_.is_struct() && !current_type_.is_union()) {
                type_ordinal_++;
                member_index_ = 0;
                continue;
            }

            udt_type_data_t udt;
            if (!current_type_.get_udt_details(&udt)) {
                type_ordinal_++;
                member_index_ = 0;
                continue;
            }

            while (member_index_ < udt.size()) {
                const udm_t& member = udt[member_index_++];
                std::string member_name(member.name.c_str());

                if (matches(member_name)) {
                    qstring type_name;
                    current_type_.get_type_name(&type_name);

                    current_row_.name = member_name;
                    current_row_.kind = "member";
                    current_row_.has_address = false;
                    current_row_.ordinal = type_ordinal_;
                    current_row_.has_ordinal = true;
                    current_row_.parent_name = type_name.c_str();
                    current_row_.full_name = std::string(type_name.c_str()) + "." + member_name;
                    return true;
                }
            }

            // Exhausted members of this type, move to next
            type_ordinal_++;
            member_index_ = 0;
        }
        return false;
    }

    bool advance_enum_members() {
        // Iterate enum values
        uint32 count = get_ordinal_count(nullptr);

        while (type_ordinal_ < count) {
            if (!current_type_.get_numbered_type(nullptr, type_ordinal_)) {
                type_ordinal_++;
                member_index_ = 0;
                continue;
            }

            if (!current_type_.is_enum()) {
                type_ordinal_++;
                member_index_ = 0;
                continue;
            }

            enum_type_data_t etd;
            if (!current_type_.get_enum_details(&etd)) {
                type_ordinal_++;
                member_index_ = 0;
                continue;
            }

            while (member_index_ < etd.size()) {
                const edm_t& em = etd[member_index_++];
                std::string value_name(em.name.c_str());

                if (matches(value_name)) {
                    qstring type_name;
                    current_type_.get_type_name(&type_name);

                    current_row_.name = value_name;
                    current_row_.kind = "enum_member";
                    current_row_.has_address = false;
                    current_row_.ordinal = type_ordinal_;
                    current_row_.has_ordinal = true;
                    current_row_.parent_name = type_name.c_str();
                    current_row_.full_name = std::string(type_name.c_str()) + "." + value_name;
                    return true;
                }
            }

            type_ordinal_++;
            member_index_ = 0;
        }
        return false;
    }
};

// ============================================================================
// SQLite Virtual Table Implementation
// ============================================================================

// Column indices
enum {
    COL_NAME = 0,
    COL_KIND,
    COL_ADDRESS,
    COL_ORDINAL,
    COL_PARENT_NAME,
    COL_FULL_NAME,
    COL_PATTERN,    // HIDDEN
    COL_MODE        // HIDDEN
};

struct JumpEntitiesVtab : sqlite3_vtab {
    // No extra data needed
};

struct JumpEntitiesCursor : sqlite3_vtab_cursor {
    std::unique_ptr<EntityGenerator> generator;
    int64_t rowid = 0;
};

inline int je_connect(sqlite3* db, void*, int, const char* const*,
                      sqlite3_vtab** ppVtab, char**) {
    int rc = sqlite3_declare_vtab(db,
        "CREATE TABLE x("
        "  name TEXT,"
        "  kind TEXT,"
        "  address INTEGER,"
        "  ordinal INTEGER,"
        "  parent_name TEXT,"
        "  full_name TEXT,"
        "  pattern TEXT HIDDEN,"
        "  mode TEXT HIDDEN"
        ")"
    );
    if (rc != SQLITE_OK) return rc;

    auto* vtab = new JumpEntitiesVtab();
    memset(static_cast<sqlite3_vtab*>(vtab), 0, sizeof(sqlite3_vtab));
    *ppVtab = vtab;
    return SQLITE_OK;
}

inline int je_disconnect(sqlite3_vtab* pVtab) {
    delete static_cast<JumpEntitiesVtab*>(pVtab);
    return SQLITE_OK;
}

inline int je_open(sqlite3_vtab*, sqlite3_vtab_cursor** ppCursor) {
    auto* cursor = new JumpEntitiesCursor();
    memset(static_cast<sqlite3_vtab_cursor*>(cursor), 0, sizeof(sqlite3_vtab_cursor));
    *ppCursor = cursor;
    return SQLITE_OK;
}

inline int je_close(sqlite3_vtab_cursor* pCursor) {
    delete static_cast<JumpEntitiesCursor*>(pCursor);
    return SQLITE_OK;
}

inline int je_best_index(sqlite3_vtab*, sqlite3_index_info* pInfo) {
    int pattern_idx = -1;
    int mode_idx = -1;

    // Look for constraints on the hidden columns
    for (int i = 0; i < pInfo->nConstraint; i++) {
        const auto& c = pInfo->aConstraint[i];
        if (!c.usable) continue;
        if (c.op != SQLITE_INDEX_CONSTRAINT_EQ) continue;

        if (c.iColumn == COL_PATTERN) pattern_idx = i;
        if (c.iColumn == COL_MODE) mode_idx = i;
    }

    if (pattern_idx >= 0) {
        // We have a pattern - this is usable
        pInfo->aConstraintUsage[pattern_idx].argvIndex = 1;
        pInfo->aConstraintUsage[pattern_idx].omit = 1;

        if (mode_idx >= 0) {
            pInfo->aConstraintUsage[mode_idx].argvIndex = 2;
            pInfo->aConstraintUsage[mode_idx].omit = 1;
            pInfo->idxNum = 2;  // Both pattern and mode
        } else {
            pInfo->idxNum = 1;  // Pattern only (default to prefix mode)
        }

        pInfo->estimatedCost = 1000.0;
        pInfo->estimatedRows = 100;
    } else {
        // No pattern constraint - discourage full table scan
        pInfo->estimatedCost = 1000000.0;
        pInfo->estimatedRows = 100000;
        pInfo->idxNum = 0;
    }

    return SQLITE_OK;
}

inline int je_filter(sqlite3_vtab_cursor* pCursor, int idxNum, const char*,
                     int argc, sqlite3_value** argv) {
    auto* cursor = static_cast<JumpEntitiesCursor*>(pCursor);
    cursor->generator.reset();
    cursor->rowid = 0;

    if (idxNum == 0 || argc < 1) {
        // No pattern - return empty result
        return SQLITE_OK;
    }

    const char* pattern = reinterpret_cast<const char*>(sqlite3_value_text(argv[0]));
    if (!pattern || !*pattern) {
        return SQLITE_OK;
    }

    bool contains_mode = false;
    if (argc >= 2 && idxNum >= 2) {
        const char* mode = reinterpret_cast<const char*>(sqlite3_value_text(argv[1]));
        if (mode && strcmp(mode, "contains") == 0) {
            contains_mode = true;
        }
    }

    cursor->generator = std::make_unique<EntityGenerator>(pattern, contains_mode);
    cursor->generator->next();  // Position to first row

    return SQLITE_OK;
}

inline int je_next(sqlite3_vtab_cursor* pCursor) {
    auto* cursor = static_cast<JumpEntitiesCursor*>(pCursor);
    if (cursor->generator) {
        cursor->generator->next();
        cursor->rowid++;
    }
    return SQLITE_OK;
}

inline int je_eof(sqlite3_vtab_cursor* pCursor) {
    auto* cursor = static_cast<JumpEntitiesCursor*>(pCursor);
    if (!cursor->generator) return 1;
    return cursor->generator->eof() ? 1 : 0;
}

inline int je_column(sqlite3_vtab_cursor* pCursor, sqlite3_context* ctx, int col) {
    auto* cursor = static_cast<JumpEntitiesCursor*>(pCursor);
    if (!cursor->generator || cursor->generator->eof()) {
        sqlite3_result_null(ctx);
        return SQLITE_OK;
    }

    const EntityRow& row = cursor->generator->current();

    switch (col) {
        case COL_NAME:
            sqlite3_result_text(ctx, row.name.c_str(), -1, SQLITE_TRANSIENT);
            break;
        case COL_KIND:
            sqlite3_result_text(ctx, row.kind.c_str(), -1, SQLITE_TRANSIENT);
            break;
        case COL_ADDRESS:
            if (row.has_address) {
                sqlite3_result_int64(ctx, static_cast<sqlite3_int64>(row.address));
            } else {
                sqlite3_result_null(ctx);
            }
            break;
        case COL_ORDINAL:
            if (row.has_ordinal) {
                sqlite3_result_int64(ctx, row.ordinal);
            } else {
                sqlite3_result_null(ctx);
            }
            break;
        case COL_PARENT_NAME:
            if (!row.parent_name.empty()) {
                sqlite3_result_text(ctx, row.parent_name.c_str(), -1, SQLITE_TRANSIENT);
            } else {
                sqlite3_result_null(ctx);
            }
            break;
        case COL_FULL_NAME:
            sqlite3_result_text(ctx, row.full_name.c_str(), -1, SQLITE_TRANSIENT);
            break;
        case COL_PATTERN:
        case COL_MODE:
            // Hidden columns - return null (they're inputs, not outputs)
            sqlite3_result_null(ctx);
            break;
        default:
            sqlite3_result_null(ctx);
            break;
    }
    return SQLITE_OK;
}

inline int je_rowid(sqlite3_vtab_cursor* pCursor, sqlite3_int64* pRowid) {
    auto* cursor = static_cast<JumpEntitiesCursor*>(pCursor);
    *pRowid = cursor->rowid;
    return SQLITE_OK;
}

// Module definition
inline sqlite3_module& get_jump_entities_module() {
    static sqlite3_module mod = {
        0,              // iVersion
        je_connect,     // xCreate
        je_connect,     // xConnect
        je_best_index,  // xBestIndex
        je_disconnect,  // xDisconnect
        je_disconnect,  // xDestroy
        je_open,        // xOpen
        je_close,       // xClose
        je_filter,      // xFilter
        je_next,        // xNext
        je_eof,         // xEof
        je_column,      // xColumn
        je_rowid,       // xRowid
        nullptr,        // xUpdate
        nullptr,        // xBegin
        nullptr,        // xSync
        nullptr,        // xCommit
        nullptr,        // xRollback
        nullptr,        // xFindFunction
        nullptr,        // xRename
        nullptr,        // xSavepoint
        nullptr,        // xRelease
        nullptr,        // xRollbackTo
        nullptr         // xShadowName
    };
    return mod;
}

/**
 * Register the jump_entities table-valued function.
 *
 * Usage after registration:
 *   SELECT * FROM jump_entities('pattern', 'prefix') LIMIT 10;
 *   SELECT * FROM jump_entities('main', 'contains');
 *   SELECT * FROM jump_entities WHERE pattern = 'sub' AND mode = 'prefix' LIMIT 20;
 */
inline bool register_jump_entities(xsql::Database& db) {
    int rc = sqlite3_create_module(db.handle(), "jump_entities", &get_jump_entities_module(), nullptr);
    return rc == SQLITE_OK;
}

} // namespace search
} // namespace idasql

```

`src/lib/include/idasql/entities_types.hpp`:

```hpp
/**
 * entities_types.hpp - IDA type system tables
 *
 * Provides SQL tables for querying IDA's type library:
 *   types             - All local types (structs, unions, enums, typedefs, funcs)
 *   types_members     - Struct/union member details
 *   types_enum_values - Enum constant values
 *   types_func_args   - Function prototype arguments
 *
 * Also provides views:
 *   types_v_structs   - Filter: structs only
 *   types_v_unions    - Filter: unions only
 *   types_v_enums     - Filter: enums only
 *   types_v_typedefs  - Filter: typedefs only
 *   types_v_funcs     - Filter: function types only
 */

#pragma once

#include <idasql/platform.hpp>

#include <idasql/vtable.hpp>
#include <xsql/database.hpp>

#include <idasql/platform_undef.hpp>

// IDA SDK headers
#include <ida.hpp>
#include <typeinf.hpp>

namespace idasql {
namespace types {

inline void ida_undo_hook(const std::string&) {}

// ============================================================================
// Type Kind Classification
// ============================================================================

inline const char* get_type_kind(const tinfo_t& tif) {
    if (tif.is_struct()) return "struct";
    if (tif.is_union()) return "union";
    if (tif.is_enum()) return "enum";
    if (tif.is_typedef()) return "typedef";
    if (tif.is_func()) return "func";
    if (tif.is_ptr()) return "ptr";
    if (tif.is_array()) return "array";
    return "other";
}

// ============================================================================
// Type Entry Cache
// ============================================================================

struct TypeEntry {
    uint32_t ordinal;
    std::string name;
    std::string kind;
    int64_t size;
    int alignment;
    bool is_struct;
    bool is_union;
    bool is_enum;
    bool is_typedef;
    bool is_func;
    bool is_ptr;
    bool is_array;
    std::string definition;
    std::string resolved;  // For typedefs: what it resolves to
};

inline std::vector<TypeEntry>& get_types_cache() {
    static std::vector<TypeEntry> cache;
    return cache;
}

inline void rebuild_types_cache() {
    auto& cache = get_types_cache();
    cache.clear();

    til_t* ti = get_idati();
    if (!ti) return;

    uint32_t max_ord = get_ordinal_limit(ti);
    if (max_ord == 0 || max_ord == uint32_t(-1)) return;

    for (uint32_t ord = 1; ord < max_ord; ++ord) {
        const char* name = get_numbered_type_name(ti, ord);
        if (!name) continue;  // Skip gaps in ordinal space

        TypeEntry entry;
        entry.ordinal = ord;
        entry.name = name;

        tinfo_t tif;
        if (tif.get_numbered_type(ti, ord)) {
            entry.kind = get_type_kind(tif);
            entry.is_struct = tif.is_struct();
            entry.is_union = tif.is_union();
            entry.is_enum = tif.is_enum();
            entry.is_typedef = tif.is_typedef();
            entry.is_func = tif.is_func();
            entry.is_ptr = tif.is_ptr();
            entry.is_array = tif.is_array();

            // Get size
            size_t sz = tif.get_size();
            entry.size = (sz != BADSIZE) ? static_cast<int64_t>(sz) : -1;

            // Get alignment for structs/unions
            entry.alignment = 0;
            if (tif.is_struct() || tif.is_union()) {
                udt_type_data_t udt;
                if (tif.get_udt_details(&udt)) {
                    entry.alignment = static_cast<int>(udt.effalign);
                }
            }

            // Get definition string
            qstring def_str;
            tif.print(&def_str);
            entry.definition = def_str.c_str();

            // For typedefs, get the resolved type name
            if (tif.is_typedef()) {
                qstring res_name;
                if (tif.get_final_type_name(&res_name)) {
                    entry.resolved = res_name.c_str();
                }
            }
        } else {
            entry.kind = "unknown";
            entry.size = -1;
            entry.alignment = 0;
            entry.is_struct = false;
            entry.is_union = false;
            entry.is_enum = false;
            entry.is_typedef = false;
            entry.is_func = false;
            entry.is_ptr = false;
            entry.is_array = false;
        }

        cache.push_back(entry);
    }
}

// ============================================================================
// TYPES Table - All local types (enhanced)
// ============================================================================

inline VTableDef define_types() {
    return table("types")
        .on_modify(ida_undo_hook)
        .count([]() {
            rebuild_types_cache();
            return get_types_cache().size();
        })
        .column_int("ordinal", [](size_t i) -> int {
            auto& cache = get_types_cache();
            return i < cache.size() ? cache[i].ordinal : 0;
        })
        .column_text_rw("name",
            // Getter
            [](size_t i) -> std::string {
                auto& cache = get_types_cache();
                return i < cache.size() ? cache[i].name : "";
            },
            // Setter - rename type
            [](size_t i, const char* new_name) -> bool {
                auto& cache = get_types_cache();
                if (i >= cache.size()) return false;

                til_t* ti = get_idati();
                if (!ti) return false;

                // Get the type
                tinfo_t tif;
                if (!tif.get_numbered_type(ti, cache[i].ordinal)) return false;

                // Rename it using tinfo_t::rename_type()
                return tif.rename_type(new_name) == TERR_OK;
            })
        .column_text("kind", [](size_t i) -> std::string {
            auto& cache = get_types_cache();
            return i < cache.size() ? cache[i].kind : "";
        })
        .column_int64("size", [](size_t i) -> int64_t {
            auto& cache = get_types_cache();
            return i < cache.size() ? cache[i].size : -1;
        })
        .column_int("alignment", [](size_t i) -> int {
            auto& cache = get_types_cache();
            return i < cache.size() ? cache[i].alignment : 0;
        })
        .column_int("is_struct", [](size_t i) -> int {
            auto& cache = get_types_cache();
            return i < cache.size() ? (cache[i].is_struct ? 1 : 0) : 0;
        })
        .column_int("is_union", [](size_t i) -> int {
            auto& cache = get_types_cache();
            return i < cache.size() ? (cache[i].is_union ? 1 : 0) : 0;
        })
        .column_int("is_enum", [](size_t i) -> int {
            auto& cache = get_types_cache();
            return i < cache.size() ? (cache[i].is_enum ? 1 : 0) : 0;
        })
        .column_int("is_typedef", [](size_t i) -> int {
            auto& cache = get_types_cache();
            return i < cache.size() ? (cache[i].is_typedef ? 1 : 0) : 0;
        })
        .column_int("is_func", [](size_t i) -> int {
            auto& cache = get_types_cache();
            return i < cache.size() ? (cache[i].is_func ? 1 : 0) : 0;
        })
        .column_int("is_ptr", [](size_t i) -> int {
            auto& cache = get_types_cache();
            return i < cache.size() ? (cache[i].is_ptr ? 1 : 0) : 0;
        })
        .column_int("is_array", [](size_t i) -> int {
            auto& cache = get_types_cache();
            return i < cache.size() ? (cache[i].is_array ? 1 : 0) : 0;
        })
        .column_text("definition", [](size_t i) -> std::string {
            auto& cache = get_types_cache();
            return i < cache.size() ? cache[i].definition : "";
        })
        .column_text("resolved", [](size_t i) -> std::string {
            auto& cache = get_types_cache();
            return i < cache.size() ? cache[i].resolved : "";
        })
        .deletable([](size_t i) -> bool {
            auto& cache = get_types_cache();
            if (i >= cache.size()) return false;

            til_t* ti = get_idati();
            if (!ti) return false;

            return del_numbered_type(ti, cache[i].ordinal);
        })
        .insertable([](int argc, sqlite3_value** argv) -> bool {
            // Column layout: ordinal(0), name(1), kind(2), ...
            // name (col 1) is required
            if (argc < 2 || sqlite3_value_type(argv[1]) == SQLITE_NULL)
                return false;

            const char* name = reinterpret_cast<const char*>(
                sqlite3_value_text(argv[1]));
            if (!name || !name[0]) return false;

            // kind (col 2): defaults to "struct"
            std::string kind = "struct";
            if (argc > 2 && sqlite3_value_type(argv[2]) != SQLITE_NULL) {
                const char* k = reinterpret_cast<const char*>(
                    sqlite3_value_text(argv[2]));
                if (k && k[0]) kind = k;
            }

            til_t* ti = get_idati();
            if (!ti) return false;

            // Check if type with this name already exists
            if (get_type_ordinal(ti, name) != 0)
                return false;

            uint32_t ord = alloc_type_ordinal(ti);
            if (ord == 0) return false;

            tinfo_t tif;
            if (kind == "struct") {
                udt_type_data_t udt;
                udt.is_union = false;
                tif.create_udt(udt);
            } else if (kind == "union") {
                udt_type_data_t udt;
                udt.is_union = true;
                tif.create_udt(udt);
            } else if (kind == "enum") {
                enum_type_data_t ei;
                tif.create_enum(ei);
            } else {
                return false;
            }

            return tif.set_numbered_type(ti, ord, NTF_REPLACE, name) == TERR_OK;
        })
        .build();
}

// ============================================================================
// TYPES_MEMBERS Table - Struct/union field details
// ============================================================================

struct MemberEntry {
    uint32_t type_ordinal;
    std::string type_name;
    int member_index;
    std::string member_name;
    int64_t offset;
    int64_t offset_bits;
    int64_t size;
    int64_t size_bits;
    std::string member_type;
    bool is_bitfield;
    bool is_baseclass;
    std::string comment;
    // Member type classification (for efficient filtering)
    bool mt_is_struct;
    bool mt_is_union;
    bool mt_is_enum;
    bool mt_is_ptr;
    bool mt_is_array;
    int member_type_ordinal;  // -1 if member type not in local types
};

inline std::vector<MemberEntry>& get_members_cache() {
    static std::vector<MemberEntry> cache;
    return cache;
}

// Helper to get ordinal of a type by name
inline int get_type_ordinal_by_name(til_t* ti, const char* type_name) {
    if (!ti || !type_name || !type_name[0]) return -1;
    uint32_t ord = get_type_ordinal(ti, type_name);
    return (ord != 0) ? static_cast<int>(ord) : -1;
}

// Helper to classify member type and get ordinal
inline void classify_member_type(const tinfo_t& mtype, til_t* ti,
                                  bool& is_struct, bool& is_union, bool& is_enum,
                                  bool& is_ptr, bool& is_array, int& type_ordinal) {
    is_struct = false;
    is_union = false;
    is_enum = false;
    is_ptr = mtype.is_ptr();
    is_array = mtype.is_array();
    type_ordinal = -1;

    // Get the base type (dereference pointers/arrays to find underlying type)
    tinfo_t base_type = mtype;
    if (mtype.is_ptr()) {
        base_type = mtype.get_pointed_object();
    } else if (mtype.is_array()) {
        base_type = mtype.get_array_element();
    }

    // Classify the base type
    is_struct = base_type.is_struct();
    is_union = base_type.is_union();
    is_enum = base_type.is_enum();

    // Try to get ordinal of the base type
    qstring type_name;
    if (base_type.get_type_name(&type_name) && !type_name.empty()) {
        type_ordinal = get_type_ordinal_by_name(ti, type_name.c_str());
    }
}

inline void rebuild_members_cache() {
    auto& cache = get_members_cache();
    cache.clear();

    til_t* ti = get_idati();
    if (!ti) return;

    uint32_t max_ord = get_ordinal_limit(ti);
    if (max_ord == 0 || max_ord == uint32_t(-1)) return;

    for (uint32_t ord = 1; ord < max_ord; ++ord) {
        const char* name = get_numbered_type_name(ti, ord);
        if (!name) continue;  // Skip gaps in ordinal space

        tinfo_t tif;
        if (tif.get_numbered_type(ti, ord)) {
            if (tif.is_struct() || tif.is_union()) {
                udt_type_data_t udt;
                if (tif.get_udt_details(&udt)) {
                    for (size_t i = 0; i < udt.size(); i++) {
                        const udm_t& m = udt[i];
                        MemberEntry entry;
                        entry.type_ordinal = ord;
                        entry.type_name = name;
                        entry.member_index = static_cast<int>(i);
                        entry.member_name = m.name.c_str();
                        entry.offset = static_cast<int64_t>(m.offset / 8);
                        entry.offset_bits = static_cast<int64_t>(m.offset);
                        entry.size = static_cast<int64_t>(m.size / 8);
                        entry.size_bits = static_cast<int64_t>(m.size);
                        entry.is_bitfield = m.is_bitfield();
                        entry.is_baseclass = m.is_baseclass();
                        entry.comment = m.cmt.c_str();

                        qstring type_str;
                        m.type.print(&type_str);
                        entry.member_type = type_str.c_str();

                        // Classify member type
                        classify_member_type(m.type, ti,
                            entry.mt_is_struct, entry.mt_is_union, entry.mt_is_enum,
                            entry.mt_is_ptr, entry.mt_is_array, entry.member_type_ordinal);

                        cache.push_back(entry);
                    }
                }
            }
        }
    }
}

/**
 * Iterator for members of a specific type.
 * Used when query has: WHERE type_ordinal = X
 */
class MembersInTypeIterator : public xsql::RowIterator {
    uint32_t type_ordinal_;
    std::string type_name_;
    udt_type_data_t udt_;
    int idx_ = -1;
    bool valid_ = false;
    bool has_data_ = false;

public:
    explicit MembersInTypeIterator(uint32_t ordinal) : type_ordinal_(ordinal) {
        til_t* ti = get_idati();
        if (!ti) return;

        const char* name = get_numbered_type_name(ti, type_ordinal_);
        if (!name) return;
        type_name_ = name;

        tinfo_t tif;
        if (tif.get_numbered_type(ti, type_ordinal_)) {
            if (tif.is_struct() || tif.is_union()) {
                has_data_ = tif.get_udt_details(&udt_);
            }
        }
    }

    bool next() override {
        if (!has_data_) return false;
        ++idx_;
        valid_ = (idx_ >= 0 && static_cast<size_t>(idx_) < udt_.size());
        return valid_;
    }

    bool eof() const override {
        return idx_ >= 0 && !valid_;
    }

    void column(sqlite3_context* ctx, int col) override {
        if (!valid_ || idx_ < 0 || static_cast<size_t>(idx_) >= udt_.size()) {
            sqlite3_result_null(ctx);
            return;
        }
        const udm_t& m = udt_[idx_];
        switch (col) {
            case 0: sqlite3_result_int(ctx, type_ordinal_); break;
            case 1: sqlite3_result_text(ctx, type_name_.c_str(), -1, SQLITE_TRANSIENT); break;
            case 2: sqlite3_result_int(ctx, idx_); break;
            case 3: sqlite3_result_text(ctx, m.name.c_str(), -1, SQLITE_TRANSIENT); break;
            case 4: sqlite3_result_int64(ctx, static_cast<int64_t>(m.offset / 8)); break;
            case 5: sqlite3_result_int64(ctx, static_cast<int64_t>(m.offset)); break;
            case 6: sqlite3_result_int64(ctx, static_cast<int64_t>(m.size / 8)); break;
            case 7: sqlite3_result_int64(ctx, static_cast<int64_t>(m.size)); break;
            case 8: {
                qstring type_str;
                m.type.print(&type_str);
                sqlite3_result_text(ctx, type_str.c_str(), -1, SQLITE_TRANSIENT);
                break;
            }
            case 9: sqlite3_result_int(ctx, m.is_bitfield() ? 1 : 0); break;
            case 10: sqlite3_result_int(ctx, m.is_baseclass() ? 1 : 0); break;
            case 11: sqlite3_result_text(ctx, m.cmt.c_str(), -1, SQLITE_TRANSIENT); break;
            // Member type classification columns
            case 12: case 13: case 14: case 15: case 16: case 17: {
                // Classify the member type on-the-fly for iterator
                bool mt_is_struct, mt_is_union, mt_is_enum, mt_is_ptr, mt_is_array;
                int mt_ordinal;
                classify_member_type(m.type, get_idati(),
                    mt_is_struct, mt_is_union, mt_is_enum,
                    mt_is_ptr, mt_is_array, mt_ordinal);
                switch (col) {
                    case 12: sqlite3_result_int(ctx, mt_is_struct ? 1 : 0); break;
                    case 13: sqlite3_result_int(ctx, mt_is_union ? 1 : 0); break;
                    case 14: sqlite3_result_int(ctx, mt_is_enum ? 1 : 0); break;
                    case 15: sqlite3_result_int(ctx, mt_is_ptr ? 1 : 0); break;
                    case 16: sqlite3_result_int(ctx, mt_is_array ? 1 : 0); break;
                    case 17: sqlite3_result_int(ctx, mt_ordinal); break;
                }
                break;
            }
            default: sqlite3_result_null(ctx); break;
        }
    }

    int64_t rowid() const override {
        return static_cast<int64_t>(type_ordinal_) * 10000 + idx_;
    }
};

// Helper to get type and member by ordinal/index (for write operations)
struct TypeMemberRef {
    tinfo_t tif;
    udt_type_data_t udt;
    bool valid;
    uint32_t ordinal;

    TypeMemberRef(uint32_t ord) : valid(false), ordinal(ord) {
        til_t* ti = get_idati();
        if (!ti) return;
        if (tif.get_numbered_type(ti, ord)) {
            if (tif.is_struct() || tif.is_union()) {
                valid = tif.get_udt_details(&udt);
            }
        }
    }

    bool save() {
        if (!valid) return false;
        tinfo_t new_tif;
        new_tif.create_udt(udt, tif.is_union() ? BTF_UNION : BTF_STRUCT);
        return new_tif.set_numbered_type(get_idati(), ordinal, NTF_REPLACE, nullptr);
    }
};

inline VTableDef define_types_members() {
    return table("types_members")
        .on_modify(ida_undo_hook)
        .count([]() {
            rebuild_members_cache();
            return get_members_cache().size();
        })
        .column_int("type_ordinal", [](size_t i) -> int {
            auto& cache = get_members_cache();
            return i < cache.size() ? cache[i].type_ordinal : 0;
        })
        .column_text("type_name", [](size_t i) -> std::string {
            auto& cache = get_members_cache();
            return i < cache.size() ? cache[i].type_name : "";
        })
        .column_int("member_index", [](size_t i) -> int {
            auto& cache = get_members_cache();
            return i < cache.size() ? cache[i].member_index : 0;
        })
        .column_text_rw("member_name",
            // Getter
            [](size_t i) -> std::string {
                auto& cache = get_members_cache();
                return i < cache.size() ? cache[i].member_name : "";
            },
            // Setter - rename member
            [](size_t i, const char* new_name) -> bool {
                auto& cache = get_members_cache();
                if (i >= cache.size()) return false;

                TypeMemberRef ref(cache[i].type_ordinal);
                if (!ref.valid) return false;

                int idx = cache[i].member_index;
                if (idx < 0 || static_cast<size_t>(idx) >= ref.udt.size()) return false;

                ref.udt[idx].name = new_name;
                return ref.save();
            })
        .column_int64("offset", [](size_t i) -> int64_t {
            auto& cache = get_members_cache();
            return i < cache.size() ? cache[i].offset : 0;
        })
        .column_int64("offset_bits", [](size_t i) -> int64_t {
            auto& cache = get_members_cache();
            return i < cache.size() ? cache[i].offset_bits : 0;
        })
        .column_int64("size", [](size_t i) -> int64_t {
            auto& cache = get_members_cache();
            return i < cache.size() ? cache[i].size : 0;
        })
        .column_int64("size_bits", [](size_t i) -> int64_t {
            auto& cache = get_members_cache();
            return i < cache.size() ? cache[i].size_bits : 0;
        })
        .column_text("member_type", [](size_t i) -> std::string {
            auto& cache = get_members_cache();
            return i < cache.size() ? cache[i].member_type : "";
        })
        .column_int("is_bitfield", [](size_t i) -> int {
            auto& cache = get_members_cache();
            return i < cache.size() ? (cache[i].is_bitfield ? 1 : 0) : 0;
        })
        .column_int("is_baseclass", [](size_t i) -> int {
            auto& cache = get_members_cache();
            return i < cache.size() ? (cache[i].is_baseclass ? 1 : 0) : 0;
        })
        .column_text_rw("comment",
            // Getter
            [](size_t i) -> std::string {
                auto& cache = get_members_cache();
                return i < cache.size() ? cache[i].comment : "";
            },
            // Setter - update member comment
            [](size_t i, const char* new_comment) -> bool {
                auto& cache = get_members_cache();
                if (i >= cache.size()) return false;

                TypeMemberRef ref(cache[i].type_ordinal);
                if (!ref.valid) return false;

                int idx = cache[i].member_index;
                if (idx < 0 || static_cast<size_t>(idx) >= ref.udt.size()) return false;

                ref.udt[idx].cmt = new_comment;
                return ref.save();
            })
        // Member type classification columns (for efficient filtering)
        .column_int("mt_is_struct", [](size_t i) -> int {
            auto& cache = get_members_cache();
            return i < cache.size() ? (cache[i].mt_is_struct ? 1 : 0) : 0;
        })
        .column_int("mt_is_union", [](size_t i) -> int {
            auto& cache = get_members_cache();
            return i < cache.size() ? (cache[i].mt_is_union ? 1 : 0) : 0;
        })
        .column_int("mt_is_enum", [](size_t i) -> int {
            auto& cache = get_members_cache();
            return i < cache.size() ? (cache[i].mt_is_enum ? 1 : 0) : 0;
        })
        .column_int("mt_is_ptr", [](size_t i) -> int {
            auto& cache = get_members_cache();
            return i < cache.size() ? (cache[i].mt_is_ptr ? 1 : 0) : 0;
        })
        .column_int("mt_is_array", [](size_t i) -> int {
            auto& cache = get_members_cache();
            return i < cache.size() ? (cache[i].mt_is_array ? 1 : 0) : 0;
        })
        .column_int("member_type_ordinal", [](size_t i) -> int {
            auto& cache = get_members_cache();
            return i < cache.size() ? cache[i].member_type_ordinal : -1;
        })
        .deletable([](size_t i) -> bool {
            auto& cache = get_members_cache();
            if (i >= cache.size()) return false;

            TypeMemberRef ref(cache[i].type_ordinal);
            if (!ref.valid) return false;

            int idx = cache[i].member_index;
            if (idx < 0 || static_cast<size_t>(idx) >= ref.udt.size()) return false;

            ref.udt.erase(ref.udt.begin() + idx);
            return ref.save();
        })
        .insertable([](int argc, sqlite3_value** argv) -> bool {
            // Column layout: type_ordinal(0), type_name(1), member_index(2),
            //                 member_name(3), offset(4), ..., member_type(8), ..., comment(11)
            // type_ordinal (col 0) and member_name (col 3) are required
            if (argc < 4
                || sqlite3_value_type(argv[0]) == SQLITE_NULL
                || sqlite3_value_type(argv[3]) == SQLITE_NULL)
                return false;

            uint32_t ordinal = static_cast<uint32_t>(sqlite3_value_int(argv[0]));
            const char* member_name = reinterpret_cast<const char*>(
                sqlite3_value_text(argv[3]));
            if (!member_name || !member_name[0]) return false;

            TypeMemberRef ref(ordinal);
            if (!ref.valid) return false;

            // Build the new member
            udm_t new_member;
            new_member.name = member_name;

            // member_type (col 8): parse type string, default to "int"
            std::string type_str = "int";
            if (argc > 8 && sqlite3_value_type(argv[8]) != SQLITE_NULL) {
                const char* mt = reinterpret_cast<const char*>(
                    sqlite3_value_text(argv[8]));
                if (mt && mt[0]) type_str = mt;
            }

            // Parse the type string into a tinfo_t
            tinfo_t member_type;
            qstring parsed_name;
            if (parse_decl(&member_type, &parsed_name, nullptr,
                           (type_str + " x;").c_str(), PT_SIL)) {
                new_member.type = member_type;
                new_member.size = member_type.get_size() * 8;  // size in bits
            } else {
                // Fallback: default to int (4 bytes)
                new_member.type = tinfo_t(BT_INT32);
                new_member.size = 32;
            }

            // comment (col 11)
            if (argc > 11 && sqlite3_value_type(argv[11]) != SQLITE_NULL) {
                const char* cmt = reinterpret_cast<const char*>(
                    sqlite3_value_text(argv[11]));
                if (cmt) new_member.cmt = cmt;
            }

            // Compute offset: append after last member
            if (!ref.udt.empty()) {
                const udm_t& last = ref.udt.back();
                new_member.offset = last.offset + last.size;
            } else {
                new_member.offset = 0;
            }

            ref.udt.push_back(new_member);
            return ref.save();
        })
        // Constraint pushdown: type_ordinal = X
        .filter_eq("type_ordinal", [](int64_t ordinal) -> std::unique_ptr<xsql::RowIterator> {
            return std::make_unique<MembersInTypeIterator>(static_cast<uint32_t>(ordinal));
        }, 10.0, 5.0)
        .build();
}

// ============================================================================
// TYPES_ENUM_VALUES Table - Enum constants
// ============================================================================

struct EnumValueEntry {
    uint32_t type_ordinal;
    std::string type_name;
    int value_index;
    std::string value_name;
    int64_t value;
    uint64_t uvalue;
    std::string comment;
};

inline std::vector<EnumValueEntry>& get_enum_values_cache() {
    static std::vector<EnumValueEntry> cache;
    return cache;
}

inline void rebuild_enum_values_cache() {
    auto& cache = get_enum_values_cache();
    cache.clear();

    til_t* ti = get_idati();
    if (!ti) return;

    uint32_t max_ord = get_ordinal_limit(ti);
    if (max_ord == 0 || max_ord == uint32_t(-1)) return;

    for (uint32_t ord = 1; ord < max_ord; ++ord) {
        const char* name = get_numbered_type_name(ti, ord);
        if (!name) continue;  // Skip gaps in ordinal space

        tinfo_t tif;
        if (tif.get_numbered_type(ti, ord)) {
            if (tif.is_enum()) {
                enum_type_data_t ei;
                if (tif.get_enum_details(&ei)) {
                    for (size_t i = 0; i < ei.size(); i++) {
                        const edm_t& e = ei[i];
                        EnumValueEntry entry;
                        entry.type_ordinal = ord;
                        entry.type_name = name;
                        entry.value_index = static_cast<int>(i);
                        entry.value_name = e.name.c_str();
                        entry.value = static_cast<int64_t>(e.value);
                        entry.uvalue = e.value;
                        entry.comment = e.cmt.c_str();
                        cache.push_back(entry);
                    }
                }
            }
        }
    }
}

/**
 * Iterator for enum values of a specific enum type.
 * Used when query has: WHERE type_ordinal = X
 */
class EnumValuesInTypeIterator : public xsql::RowIterator {
    uint32_t type_ordinal_;
    std::string type_name_;
    enum_type_data_t ei_;
    int idx_ = -1;
    bool valid_ = false;
    bool has_data_ = false;

public:
    explicit EnumValuesInTypeIterator(uint32_t ordinal) : type_ordinal_(ordinal) {
        til_t* ti = get_idati();
        if (!ti) return;

        const char* name = get_numbered_type_name(ti, type_ordinal_);
        if (!name) return;
        type_name_ = name;

        tinfo_t tif;
        if (tif.get_numbered_type(ti, type_ordinal_)) {
            if (tif.is_enum()) {
                has_data_ = tif.get_enum_details(&ei_);
            }
        }
    }

    bool next() override {
        if (!has_data_) return false;
        ++idx_;
        valid_ = (idx_ >= 0 && static_cast<size_t>(idx_) < ei_.size());
        return valid_;
    }

    bool eof() const override {
        return idx_ >= 0 && !valid_;
    }

    void column(sqlite3_context* ctx, int col) override {
        if (!valid_ || idx_ < 0 || static_cast<size_t>(idx_) >= ei_.size()) {
            sqlite3_result_null(ctx);
            return;
        }
        const edm_t& e = ei_[idx_];
        switch (col) {
            case 0: sqlite3_result_int(ctx, type_ordinal_); break;
            case 1: sqlite3_result_text(ctx, type_name_.c_str(), -1, SQLITE_TRANSIENT); break;
            case 2: sqlite3_result_int(ctx, idx_); break;
            case 3: sqlite3_result_text(ctx, e.name.c_str(), -1, SQLITE_TRANSIENT); break;
            case 4: sqlite3_result_int64(ctx, static_cast<int64_t>(e.value)); break;
            case 5: sqlite3_result_int64(ctx, static_cast<int64_t>(e.value)); break;  // uvalue
            case 6: sqlite3_result_text(ctx, e.cmt.c_str(), -1, SQLITE_TRANSIENT); break;
            default: sqlite3_result_null(ctx); break;
        }
    }

    int64_t rowid() const override {
        return static_cast<int64_t>(type_ordinal_) * 10000 + idx_;
    }
};

// Helper to get enum type by ordinal (for write operations)
struct EnumTypeRef {
    tinfo_t tif;
    enum_type_data_t ei;
    bool valid;
    uint32_t ordinal;

    EnumTypeRef(uint32_t ord) : valid(false), ordinal(ord) {
        til_t* ti = get_idati();
        if (!ti) return;
        if (tif.get_numbered_type(ti, ord)) {
            if (tif.is_enum()) {
                valid = tif.get_enum_details(&ei);
            }
        }
    }

    bool save() {
        if (!valid) return false;
        tinfo_t new_tif;
        new_tif.create_enum(ei);
        return new_tif.set_numbered_type(get_idati(), ordinal, NTF_REPLACE, nullptr);
    }
};

inline VTableDef define_types_enum_values() {
    return table("types_enum_values")
        .on_modify(ida_undo_hook)
        .count([]() {
            rebuild_enum_values_cache();
            return get_enum_values_cache().size();
        })
        .column_int("type_ordinal", [](size_t i) -> int {
            auto& cache = get_enum_values_cache();
            return i < cache.size() ? cache[i].type_ordinal : 0;
        })
        .column_text("type_name", [](size_t i) -> std::string {
            auto& cache = get_enum_values_cache();
            return i < cache.size() ? cache[i].type_name : "";
        })
        .column_int("value_index", [](size_t i) -> int {
            auto& cache = get_enum_values_cache();
            return i < cache.size() ? cache[i].value_index : 0;
        })
        .column_text_rw("value_name",
            // Getter
            [](size_t i) -> std::string {
                auto& cache = get_enum_values_cache();
                return i < cache.size() ? cache[i].value_name : "";
            },
            // Setter - rename enum value
            [](size_t i, const char* new_name) -> bool {
                auto& cache = get_enum_values_cache();
                if (i >= cache.size()) return false;

                EnumTypeRef ref(cache[i].type_ordinal);
                if (!ref.valid) return false;

                int idx = cache[i].value_index;
                if (idx < 0 || static_cast<size_t>(idx) >= ref.ei.size()) return false;

                ref.ei[idx].name = new_name;
                return ref.save();
            })
        .column_int64_rw("value",
            // Getter
            [](size_t i) -> int64_t {
                auto& cache = get_enum_values_cache();
                return i < cache.size() ? cache[i].value : 0;
            },
            // Setter - change enum value
            [](size_t i, int64_t new_value) -> bool {
                auto& cache = get_enum_values_cache();
                if (i >= cache.size()) return false;

                EnumTypeRef ref(cache[i].type_ordinal);
                if (!ref.valid) return false;

                int idx = cache[i].value_index;
                if (idx < 0 || static_cast<size_t>(idx) >= ref.ei.size()) return false;

                ref.ei[idx].value = static_cast<uint64_t>(new_value);
                return ref.save();
            })
        .column_int64("uvalue", [](size_t i) -> int64_t {
            auto& cache = get_enum_values_cache();
            return i < cache.size() ? static_cast<int64_t>(cache[i].uvalue) : 0;
        })
        .column_text_rw("comment",
            // Getter
            [](size_t i) -> std::string {
                auto& cache = get_enum_values_cache();
                return i < cache.size() ? cache[i].comment : "";
            },
            // Setter - update enum value comment
            [](size_t i, const char* new_comment) -> bool {
                auto& cache = get_enum_values_cache();
                if (i >= cache.size()) return false;

                EnumTypeRef ref(cache[i].type_ordinal);
                if (!ref.valid) return false;

                int idx = cache[i].value_index;
                if (idx < 0 || static_cast<size_t>(idx) >= ref.ei.size()) return false;

                ref.ei[idx].cmt = new_comment;
                return ref.save();
            })
        .deletable([](size_t i) -> bool {
            auto& cache = get_enum_values_cache();
            if (i >= cache.size()) return false;

            EnumTypeRef ref(cache[i].type_ordinal);
            if (!ref.valid) return false;

            int idx = cache[i].value_index;
            if (idx < 0 || static_cast<size_t>(idx) >= ref.ei.size()) return false;

            ref.ei.erase(ref.ei.begin() + idx);
            return ref.save();
        })
        .insertable([](int argc, sqlite3_value** argv) -> bool {
            // Column layout: type_ordinal(0), type_name(1), value_index(2),
            //                 value_name(3), value(4), uvalue(5), comment(6)
            // type_ordinal (col 0) and value_name (col 3) are required
            if (argc < 4
                || sqlite3_value_type(argv[0]) == SQLITE_NULL
                || sqlite3_value_type(argv[3]) == SQLITE_NULL)
                return false;

            uint32_t ordinal = static_cast<uint32_t>(sqlite3_value_int(argv[0]));
            const char* value_name = reinterpret_cast<const char*>(
                sqlite3_value_text(argv[3]));
            if (!value_name || !value_name[0]) return false;

            EnumTypeRef ref(ordinal);
            if (!ref.valid) return false;

            // Build the new enum member
            edm_t new_edm;
            new_edm.name = value_name;

            // value (col 4): default to 0
            if (argc > 4 && sqlite3_value_type(argv[4]) != SQLITE_NULL) {
                new_edm.value = static_cast<uint64_t>(sqlite3_value_int64(argv[4]));
            } else {
                // Auto-assign: next value after last member
                if (!ref.ei.empty()) {
                    new_edm.value = ref.ei.back().value + 1;
                } else {
                    new_edm.value = 0;
                }
            }

            // comment (col 6)
            if (argc > 6 && sqlite3_value_type(argv[6]) != SQLITE_NULL) {
                const char* cmt = reinterpret_cast<const char*>(
                    sqlite3_value_text(argv[6]));
                if (cmt) new_edm.cmt = cmt;
            }

            ref.ei.push_back(new_edm);
            return ref.save();
        })
        // Constraint pushdown: type_ordinal = X
        .filter_eq("type_ordinal", [](int64_t ordinal) -> std::unique_ptr<xsql::RowIterator> {
            return std::make_unique<EnumValuesInTypeIterator>(static_cast<uint32_t>(ordinal));
        }, 10.0, 10.0)
        .build();
}

// ============================================================================
// TYPES_FUNC_ARGS Table - Function prototype arguments
// ============================================================================

// Type classification info (surface + resolved)
struct TypeClassification {
    // Surface-level classification (literal type as written)
    bool is_ptr = false;
    bool is_int = false;        // Exactly int type
    bool is_integral = false;   // Int-like family (int, long, short, char, bool)
    bool is_float = false;
    bool is_void = false;
    bool is_struct = false;
    bool is_array = false;
    int ptr_depth = 0;
    std::string base_type;      // Type name with pointers stripped

    // Resolved classification (after typedef resolution)
    bool is_ptr_resolved = false;
    bool is_int_resolved = false;
    bool is_integral_resolved = false;
    bool is_float_resolved = false;
    bool is_void_resolved = false;
    int ptr_depth_resolved = 0;
    std::string base_type_resolved;
};

// Get pointer depth (int** -> 2, int* -> 1, int -> 0)
inline int get_ptr_depth(tinfo_t tif) {
    int depth = 0;
    while (tif.is_ptr()) {
        depth++;
        tif = tif.get_pointed_object();
    }
    return depth;
}

// Get base type name (strips pointers/arrays)
inline std::string get_base_type_name(tinfo_t tif) {
    // Strip pointers
    while (tif.is_ptr()) {
        tif = tif.get_pointed_object();
    }
    // Strip arrays
    while (tif.is_array()) {
        tif = tif.get_array_element();
    }
    qstring name;
    tif.print(&name);
    return name.c_str();
}

// Classify a single tinfo_t (surface or resolved)
inline void classify_tinfo(const tinfo_t& tif,
                           bool& is_ptr, bool& is_int, bool& is_integral,
                           bool& is_float, bool& is_void, bool& is_struct,
                           bool& is_array, int& ptr_depth, std::string& base_type) {
    is_ptr = tif.is_ptr();
    is_array = tif.is_array();
    is_struct = tif.is_struct() || tif.is_union();
    is_void = tif.is_void();
    is_float = tif.is_float() || tif.is_double() || tif.is_ldouble() ||
               tif.is_floating();

    // For int classification, we need to check the actual type
    // is_int = exactly "int" type
    // is_integral = int-like family
    is_integral = tif.is_integral();  // IDA SDK: int, char, short, long, bool, etc.
    is_int = tif.is_int();            // IDA SDK: exactly int32/int64

    ptr_depth = get_ptr_depth(tif);
    base_type = get_base_type_name(tif);
}

// Check if type is a typedef (type reference) at surface level
inline bool is_surface_typedef(const tinfo_t& tif) {
    return tif.is_typeref();
}

// Classify surface-level type (WITHOUT typedef resolution)
// If tif is a typedef, surface classification shows it as "other" not the underlying type
inline void classify_surface(const tinfo_t& tif,
                             bool& is_ptr, bool& is_int, bool& is_integral,
                             bool& is_float, bool& is_void, bool& is_struct,
                             bool& is_array, int& ptr_depth, std::string& base_type) {
    // If it's a typedef, surface level is NOT a ptr/int/etc - it's a typedef
    if (is_surface_typedef(tif)) {
        is_ptr = false;
        is_int = false;
        is_integral = false;
        is_float = false;
        is_void = false;
        is_struct = false;
        is_array = false;
        ptr_depth = 0;
        // Get the typedef name as base_type
        qstring name;
        if (tif.get_type_name(&name)) {
            base_type = name.c_str();
        } else {
            tif.print(&name);
            base_type = name.c_str();
        }
        return;
    }

    // Not a typedef - classify directly
    classify_tinfo(tif, is_ptr, is_int, is_integral, is_float,
                   is_void, is_struct, is_array, ptr_depth, base_type);
}

// Full type classification (surface + resolved)
inline TypeClassification classify_arg_type(const tinfo_t& tif) {
    TypeClassification tc;

    // Surface classification (without typedef resolution)
    classify_surface(tif,
        tc.is_ptr, tc.is_int, tc.is_integral, tc.is_float,
        tc.is_void, tc.is_struct, tc.is_array,
        tc.ptr_depth, tc.base_type);

    // Resolved classification (with typedef resolution)
    // IDA SDK's is_ptr(), is_integral(), etc. already resolve typedefs via get_realtype()
    classify_tinfo(tif,
        tc.is_ptr_resolved, tc.is_int_resolved, tc.is_integral_resolved,
        tc.is_float_resolved, tc.is_void_resolved,
        tc.is_struct, tc.is_array,  // Reuse - struct/array handled by classify_tinfo
        tc.ptr_depth_resolved, tc.base_type_resolved);

    return tc;
}

struct FuncArgEntry {
    uint32_t type_ordinal;
    std::string type_name;
    int arg_index;  // -1 for return type
    std::string arg_name;
    std::string arg_type;
    std::string calling_conv;  // Only set on arg_index=-1 row

    // Type classification
    TypeClassification tc;
};

inline std::vector<FuncArgEntry>& get_func_args_cache() {
    static std::vector<FuncArgEntry> cache;
    return cache;
}

inline const char* get_calling_convention_name(cm_t cc) {
    // Extract calling convention from cm_t (using CM_CC_MASK)
    callcnv_t conv = cc & CM_CC_MASK;
    switch (conv) {
        case CM_CC_CDECL: return "cdecl";
        case CM_CC_STDCALL: return "stdcall";
        case CM_CC_FASTCALL: return "fastcall";
        case CM_CC_THISCALL: return "thiscall";
        case CM_CC_PASCAL: return "pascal";
        case CM_CC_ELLIPSIS: return "ellipsis";
        case CM_CC_SPECIAL: return "usercall";
        case CM_CC_SPECIALE: return "usercall_ellipsis";
        case CM_CC_SPECIALP: return "usercall_purged";
        case CM_CC_VOIDARG: return "voidarg";
        case CM_CC_UNKNOWN: return "unknown";
        case CM_CC_INVALID: return "invalid";
        default: return "other";
    }
}

inline void rebuild_func_args_cache() {
    auto& cache = get_func_args_cache();
    cache.clear();

    til_t* ti = get_idati();
    if (!ti) return;

    uint32_t max_ord = get_ordinal_limit(ti);
    if (max_ord == 0 || max_ord == uint32_t(-1)) return;

    for (uint32_t ord = 1; ord < max_ord; ++ord) {
        const char* name = get_numbered_type_name(ti, ord);
        if (!name) continue;  // Skip gaps in ordinal space

        tinfo_t tif;
        if (tif.get_numbered_type(ti, ord)) {
            if (tif.is_func()) {
                func_type_data_t fi;
                if (tif.get_func_details(&fi)) {
                    // Return type (arg_index = -1)
                    FuncArgEntry ret_entry;
                    ret_entry.type_ordinal = ord;
                    ret_entry.type_name = name;
                    ret_entry.arg_index = -1;
                    ret_entry.arg_name = "(return)";

                    qstring ret_str;
                    fi.rettype.print(&ret_str);
                    ret_entry.arg_type = ret_str.c_str();
                    ret_entry.calling_conv = get_calling_convention_name(fi.get_cc());
                    ret_entry.tc = classify_arg_type(fi.rettype);
                    cache.push_back(ret_entry);

                    // Arguments
                    for (size_t i = 0; i < fi.size(); i++) {
                        const funcarg_t& a = fi[i];
                        FuncArgEntry entry;
                        entry.type_ordinal = ord;
                        entry.type_name = name;
                        entry.arg_index = static_cast<int>(i);
                        entry.arg_name = a.name.empty() ? "" : a.name.c_str();

                        qstring type_str;
                        a.type.print(&type_str);
                        entry.arg_type = type_str.c_str();
                        entry.tc = classify_arg_type(a.type);
                        // calling_conv only on return type row
                        cache.push_back(entry);
                    }
                }
            }
        }
    }
}

/**
 * Iterator for function args of a specific function type.
 * Used when query has: WHERE type_ordinal = X
 */
class FuncArgsInTypeIterator : public xsql::RowIterator {
    uint32_t type_ordinal_;
    std::string type_name_;
    func_type_data_t fi_;
    int idx_ = -2;  // Start at -2, first next() moves to -1 (return type)
    bool valid_ = false;
    bool has_data_ = false;

public:
    explicit FuncArgsInTypeIterator(uint32_t ordinal) : type_ordinal_(ordinal) {
        til_t* ti = get_idati();
        if (!ti) return;

        const char* name = get_numbered_type_name(ti, type_ordinal_);
        if (!name) return;
        type_name_ = name;

        tinfo_t tif;
        if (tif.get_numbered_type(ti, type_ordinal_)) {
            if (tif.is_func()) {
                has_data_ = tif.get_func_details(&fi_);
            }
        }
    }

    bool next() override {
        if (!has_data_) return false;
        ++idx_;
        // idx_=-1 is return type, then 0..n-1 are args
        valid_ = (idx_ >= -1 && static_cast<size_t>(idx_) < fi_.size() + 1);
        // Adjust: idx_=-1 is return, idx_=0 is first arg, etc.
        // Total items = 1 (return) + fi_.size() (args)
        valid_ = (idx_ >= -1 && idx_ < static_cast<int>(fi_.size()));
        // Correction: idx=-1 is return, idx=0..fi_.size()-1 are args
        // So valid when idx >= -1 and idx < fi_.size()
        // Actually: return type is one row, args are fi_.size() rows
        // Total rows = 1 + fi_.size()
        valid_ = (idx_ >= -1 && idx_ <= static_cast<int>(fi_.size()) - 1 + 1 - 1);
        // Simpler: idx=-1 valid, idx=0..fi_.size()-1 valid
        valid_ = (idx_ == -1) || (idx_ >= 0 && static_cast<size_t>(idx_) < fi_.size());
        return valid_;
    }

    bool eof() const override {
        return idx_ >= -1 && !valid_;
    }

    void column(sqlite3_context* ctx, int col) override {
        if (!valid_) {
            sqlite3_result_null(ctx);
            return;
        }

        // Get the type for classification (computed on-the-fly for iterator)
        auto get_current_type = [&]() -> tinfo_t {
            if (idx_ == -1) return fi_.rettype;
            if (static_cast<size_t>(idx_) < fi_.size()) return fi_[idx_].type;
            return tinfo_t();
        };

        switch (col) {
            case 0: // type_ordinal
                sqlite3_result_int(ctx, type_ordinal_);
                break;
            case 1: // type_name
                sqlite3_result_text(ctx, type_name_.c_str(), -1, SQLITE_TRANSIENT);
                break;
            case 2: // arg_index
                sqlite3_result_int(ctx, idx_);
                break;
            case 3: // arg_name
                if (idx_ == -1) {
                    sqlite3_result_text(ctx, "(return)", -1, SQLITE_STATIC);
                } else if (static_cast<size_t>(idx_) < fi_.size()) {
                    sqlite3_result_text(ctx, fi_[idx_].name.c_str(), -1, SQLITE_TRANSIENT);
                } else {
                    sqlite3_result_null(ctx);
                }
                break;
            case 4: // arg_type
                if (idx_ == -1) {
                    qstring ret_str;
                    fi_.rettype.print(&ret_str);
                    sqlite3_result_text(ctx, ret_str.c_str(), -1, SQLITE_TRANSIENT);
                } else if (static_cast<size_t>(idx_) < fi_.size()) {
                    qstring type_str;
                    fi_[idx_].type.print(&type_str);
                    sqlite3_result_text(ctx, type_str.c_str(), -1, SQLITE_TRANSIENT);
                } else {
                    sqlite3_result_null(ctx);
                }
                break;
            case 5: // calling_conv
                if (idx_ == -1) {
                    sqlite3_result_text(ctx, get_calling_convention_name(fi_.get_cc()), -1, SQLITE_STATIC);
                } else {
                    sqlite3_result_text(ctx, "", -1, SQLITE_STATIC);
                }
                break;
            // Type classification columns (computed on-the-fly)
            case 6: case 7: case 8: case 9: case 10: case 11: case 12: case 13: case 14:
            case 15: case 16: case 17: case 18: case 19: case 20: case 21: {
                TypeClassification tc = classify_arg_type(get_current_type());
                switch (col) {
                    case 6:  sqlite3_result_int(ctx, tc.is_ptr ? 1 : 0); break;
                    case 7:  sqlite3_result_int(ctx, tc.is_int ? 1 : 0); break;
                    case 8:  sqlite3_result_int(ctx, tc.is_integral ? 1 : 0); break;
                    case 9:  sqlite3_result_int(ctx, tc.is_float ? 1 : 0); break;
                    case 10: sqlite3_result_int(ctx, tc.is_void ? 1 : 0); break;
                    case 11: sqlite3_result_int(ctx, tc.is_struct ? 1 : 0); break;
                    case 12: sqlite3_result_int(ctx, tc.is_array ? 1 : 0); break;
                    case 13: sqlite3_result_int(ctx, tc.ptr_depth); break;
                    case 14: sqlite3_result_text(ctx, tc.base_type.c_str(), -1, SQLITE_TRANSIENT); break;
                    case 15: sqlite3_result_int(ctx, tc.is_ptr_resolved ? 1 : 0); break;
                    case 16: sqlite3_result_int(ctx, tc.is_int_resolved ? 1 : 0); break;
                    case 17: sqlite3_result_int(ctx, tc.is_integral_resolved ? 1 : 0); break;
                    case 18: sqlite3_result_int(ctx, tc.is_float_resolved ? 1 : 0); break;
                    case 19: sqlite3_result_int(ctx, tc.is_void_resolved ? 1 : 0); break;
                    case 20: sqlite3_result_int(ctx, tc.ptr_depth_resolved); break;
                    case 21: sqlite3_result_text(ctx, tc.base_type_resolved.c_str(), -1, SQLITE_TRANSIENT); break;
                }
                break;
            }
            default:
                sqlite3_result_null(ctx);
                break;
        }
    }

    int64_t rowid() const override {
        return static_cast<int64_t>(type_ordinal_) * 10000 + (idx_ + 1);
    }
};

inline VTableDef define_types_func_args() {
    return table("types_func_args")
        .count([]() {
            rebuild_func_args_cache();
            return get_func_args_cache().size();
        })
        .column_int("type_ordinal", [](size_t i) -> int {
            auto& cache = get_func_args_cache();
            return i < cache.size() ? cache[i].type_ordinal : 0;
        })
        .column_text("type_name", [](size_t i) -> std::string {
            auto& cache = get_func_args_cache();
            return i < cache.size() ? cache[i].type_name : "";
        })
        .column_int("arg_index", [](size_t i) -> int {
            auto& cache = get_func_args_cache();
            return i < cache.size() ? cache[i].arg_index : 0;
        })
        .column_text("arg_name", [](size_t i) -> std::string {
            auto& cache = get_func_args_cache();
            return i < cache.size() ? cache[i].arg_name : "";
        })
        .column_text("arg_type", [](size_t i) -> std::string {
            auto& cache = get_func_args_cache();
            return i < cache.size() ? cache[i].arg_type : "";
        })
        .column_text("calling_conv", [](size_t i) -> std::string {
            auto& cache = get_func_args_cache();
            return i < cache.size() ? cache[i].calling_conv : "";
        })
        // Surface-level type classification
        .column_int("is_ptr", [](size_t i) -> int {
            auto& cache = get_func_args_cache();
            return i < cache.size() ? (cache[i].tc.is_ptr ? 1 : 0) : 0;
        })
        .column_int("is_int", [](size_t i) -> int {
            auto& cache = get_func_args_cache();
            return i < cache.size() ? (cache[i].tc.is_int ? 1 : 0) : 0;
        })
        .column_int("is_integral", [](size_t i) -> int {
            auto& cache = get_func_args_cache();
            return i < cache.size() ? (cache[i].tc.is_integral ? 1 : 0) : 0;
        })
        .column_int("is_float", [](size_t i) -> int {
            auto& cache = get_func_args_cache();
            return i < cache.size() ? (cache[i].tc.is_float ? 1 : 0) : 0;
        })
        .column_int("is_void", [](size_t i) -> int {
            auto& cache = get_func_args_cache();
            return i < cache.size() ? (cache[i].tc.is_void ? 1 : 0) : 0;
        })
        .column_int("is_struct", [](size_t i) -> int {
            auto& cache = get_func_args_cache();
            return i < cache.size() ? (cache[i].tc.is_struct ? 1 : 0) : 0;
        })
        .column_int("is_array", [](size_t i) -> int {
            auto& cache = get_func_args_cache();
            return i < cache.size() ? (cache[i].tc.is_array ? 1 : 0) : 0;
        })
        .column_int("ptr_depth", [](size_t i) -> int {
            auto& cache = get_func_args_cache();
            return i < cache.size() ? cache[i].tc.ptr_depth : 0;
        })
        .column_text("base_type", [](size_t i) -> std::string {
            auto& cache = get_func_args_cache();
            return i < cache.size() ? cache[i].tc.base_type : "";
        })
        // Resolved type classification (after typedef resolution)
        .column_int("is_ptr_resolved", [](size_t i) -> int {
            auto& cache = get_func_args_cache();
            return i < cache.size() ? (cache[i].tc.is_ptr_resolved ? 1 : 0) : 0;
        })
        .column_int("is_int_resolved", [](size_t i) -> int {
            auto& cache = get_func_args_cache();
            return i < cache.size() ? (cache[i].tc.is_int_resolved ? 1 : 0) : 0;
        })
        .column_int("is_integral_resolved", [](size_t i) -> int {
            auto& cache = get_func_args_cache();
            return i < cache.size() ? (cache[i].tc.is_integral_resolved ? 1 : 0) : 0;
        })
        .column_int("is_float_resolved", [](size_t i) -> int {
            auto& cache = get_func_args_cache();
            return i < cache.size() ? (cache[i].tc.is_float_resolved ? 1 : 0) : 0;
        })
        .column_int("is_void_resolved", [](size_t i) -> int {
            auto& cache = get_func_args_cache();
            return i < cache.size() ? (cache[i].tc.is_void_resolved ? 1 : 0) : 0;
        })
        .column_int("ptr_depth_resolved", [](size_t i) -> int {
            auto& cache = get_func_args_cache();
            return i < cache.size() ? cache[i].tc.ptr_depth_resolved : 0;
        })
        .column_text("base_type_resolved", [](size_t i) -> std::string {
            auto& cache = get_func_args_cache();
            return i < cache.size() ? cache[i].tc.base_type_resolved : "";
        })
        // Constraint pushdown: type_ordinal = X
        .filter_eq("type_ordinal", [](int64_t ordinal) -> std::unique_ptr<xsql::RowIterator> {
            return std::make_unique<FuncArgsInTypeIterator>(static_cast<uint32_t>(ordinal));
        }, 10.0, 5.0)
        .build();
}

// ============================================================================
// Types Registry
// ============================================================================

struct TypesRegistry {
    VTableDef types;
    VTableDef types_members;
    VTableDef types_enum_values;
    VTableDef types_func_args;

    TypesRegistry()
        : types(define_types())
        , types_members(define_types_members())
        , types_enum_values(define_types_enum_values())
        , types_func_args(define_types_func_args())
    {}

    void register_all(xsql::Database& db) {
        // Register tables
        db.register_table("ida_types", &types);
        db.create_table("types", "ida_types");

        db.register_table("ida_types_members", &types_members);
        db.create_table("types_members", "ida_types_members");

        db.register_table("ida_types_enum_values", &types_enum_values);
        db.create_table("types_enum_values", "ida_types_enum_values");

        db.register_table("ida_types_func_args", &types_func_args);
        db.create_table("types_func_args", "ida_types_func_args");

        // Create views
        create_views(db);
    }

private:
    void create_views(xsql::Database& db) {
        // Filtering views
        db.exec("CREATE VIEW IF NOT EXISTS types_v_structs AS SELECT * FROM types WHERE is_struct = 1");
        db.exec("CREATE VIEW IF NOT EXISTS types_v_unions AS SELECT * FROM types WHERE is_union = 1");
        db.exec("CREATE VIEW IF NOT EXISTS types_v_enums AS SELECT * FROM types WHERE is_enum = 1");
        db.exec("CREATE VIEW IF NOT EXISTS types_v_typedefs AS SELECT * FROM types WHERE is_typedef = 1");
        db.exec("CREATE VIEW IF NOT EXISTS types_v_funcs AS SELECT * FROM types WHERE is_func = 1");
    }
};

} // namespace types
} // namespace idasql

```

`src/lib/include/idasql/functions.hpp`:

```hpp
/**
 * ida_sql_functions.hpp - Custom SQL functions for IDA operations
 *
 * Query Functions:
 *   - disasm(address)           - Get disassembly line at address
 *   - disasm(address, count)    - Get multiple disassembly lines
 *   - decompile(address)        - Get decompiled pseudocode for function
 *   - bytes(address, count)     - Get bytes as hex string
 *   - bytes_raw(address, count) - Get bytes as blob
 *   - name_at(address)          - Get name at address
 *   - func_at(address)          - Get function name containing address
 *   - func_start(address)       - Get start address of function containing address
 *   - func_end(address)         - Get end address of function containing address
 *   - xrefs_to(address)         - Get xrefs to address (JSON array)
 *   - xrefs_from(address)       - Get xrefs from address (JSON array)
 *   - segment_at(address)       - Get segment name containing address
 *   - comment_at(address)       - Get comment at address
 *   - set_comment(address, text) - Set comment at address
 *   - set_name(address, name)   - Set name at address
 *
 * Function Index Functions (O(1) access):
 *   - func_qty()                - Get total function count
 *   - func_at_index(n)          - Get function address at index n
 *
 * Instruction Decoding Functions:
 *   - itype(address)            - Get instruction type code at address
 *   - decode_insn(address)      - Get full instruction info as JSON
 *   - operand_type(address, n)  - Get operand type (0-5)
 *   - operand_value(address, n) - Get operand value/address
 *
 * File Generation Functions:
 *   - gen_asm_file(ea1, ea2, path)  - Generate assembly file
 *   - gen_lst_file(ea1, ea2, path)  - Generate listing file (with addresses)
 *   - gen_map_file(path)            - Generate MAP file
 *   - gen_idc_file(ea1, ea2, path)  - Generate IDC script
 *   - gen_html_file(ea1, ea2, path) - Generate HTML listing
 *   - gen_cfg_dot(address)          - Generate CFG as DOT (returns string)
 *   - gen_cfg_dot_file(address, path) - Generate CFG DOT to file
 *   - gen_schema_dot()              - Generate schema diagram as DOT
 *
 * Database Persistence:
 *   - save_database()               - Persist changes to .i64 file (returns 1/0)
 *
 * Introspection (standard SQLite):
 *   - SELECT * FROM sqlite_master WHERE type='table'
 *   - PRAGMA table_info(tablename)
 *   - PRAGMA table_xinfo(tablename)
 */

#pragma once

#include <idasql/platform.hpp>

#include <xsql/database.hpp>
#include <xsql/json.hpp>
#include <string>
#include <sstream>
#include <iomanip>
#include <vector>

#include <idasql/platform_undef.hpp>

// IDA SDK headers (order matters)
#include <ida.hpp>
#include <idp.hpp>
#include <kernwin.hpp>  // Must come early
#include <ua.hpp>       // insn_t, decode_insn for instruction decoding
#include <bytes.hpp>
#include <name.hpp>
#include <funcs.hpp>
#include <segment.hpp>
#include <lines.hpp>
#include <xref.hpp>
#include <loader.hpp>   // gen_file
#include <fpro.h>       // qfile_t for file operations
#include <gdl.hpp>      // FlowChart for CFG generation
#include <strlist.hpp>  // String list functions
#include <nalt.hpp>     // String type constants

// Hex-Rays decompiler - always included, runtime detection
#include <hexrays.hpp>
#include <idasql/decompiler.hpp>  // For hexrays_available()

namespace idasql {
namespace functions {

// ============================================================================
// Disassembly Functions
// ============================================================================

// disasm(address) - Get single disassembly line
// disasm(address, count) - Get multiple lines
static void sql_disasm(xsql::FunctionContext& ctx, int argc, xsql::FunctionArg* argv) {
    if (argc < 1) {
        ctx.result_error("disasm requires at least 1 argument (address)");
        return;
    }

    ea_t ea = static_cast<ea_t>(argv[0].as_int64());
    int count = (argc >= 2) ? argv[1].as_int() : 1;
    if (count < 1) count = 1;
    if (count > 1000) count = 1000;  // Safety limit

    std::ostringstream result;
    for (int i = 0; i < count && ea != BADADDR; i++) {
        qstring line;
        if (generate_disasm_line(&line, ea, GENDSM_FORCE_CODE)) {
            // Strip color codes
            tag_remove(&line);
            if (i > 0) result << "\n";
            result << std::hex << ea << ": " << line.c_str();
        }
        ea = next_head(ea, BADADDR);
    }

    std::string str = result.str();
    ctx.result_text(str);
}

// ============================================================================
// Bytes Functions
// ============================================================================

// bytes(address, count) - Get bytes as hex string
static void sql_bytes_hex(xsql::FunctionContext& ctx, int argc, xsql::FunctionArg* argv) {
    if (argc < 2) {
        ctx.result_error("bytes requires 2 arguments (address, count)");
        return;
    }

    ea_t ea = static_cast<ea_t>(argv[0].as_int64());
    size_t count = static_cast<size_t>(argv[1].as_int());
    if (count > 4096) count = 4096;  // Safety limit

    std::ostringstream result;
    result << std::hex << std::setfill('0');
    for (size_t i = 0; i < count; i++) {
        if (i > 0) result << " ";
        uchar byte = get_byte(ea + i);
        result << std::setw(2) << static_cast<int>(byte);
    }

    std::string str = result.str();
    ctx.result_text(str);
}

// bytes_raw(address, count) - Get bytes as blob
static void sql_bytes_raw(xsql::FunctionContext& ctx, int argc, xsql::FunctionArg* argv) {
    if (argc < 2) {
        ctx.result_error("bytes_raw requires 2 arguments (address, count)");
        return;
    }

    ea_t ea = static_cast<ea_t>(argv[0].as_int64());
    size_t count = static_cast<size_t>(argv[1].as_int());
    if (count > 4096) count = 4096;  // Safety limit

    std::vector<uchar> data(count);
    for (size_t i = 0; i < count; i++) {
        data[i] = get_byte(ea + i);
    }

    ctx.result_blob(data.data(), static_cast<size_t>(data.size()));
}

// ============================================================================
// Name Functions
// ============================================================================

// name_at(address) - Get name at address
static void sql_name_at(xsql::FunctionContext& ctx, int argc, xsql::FunctionArg* argv) {
    if (argc < 1) {
        ctx.result_error("name_at requires 1 argument (address)");
        return;
    }

    ea_t ea = static_cast<ea_t>(argv[0].as_int64());
    qstring name;
    if (get_name(&name, ea) > 0 && !name.empty()) {
        ctx.result_text(name.c_str());
    } else {
        ctx.result_null();
    }
}

// func_at(address) - Get function name containing address
static void sql_func_at(xsql::FunctionContext& ctx, int argc, xsql::FunctionArg* argv) {
    if (argc < 1) {
        ctx.result_error("func_at requires 1 argument (address)");
        return;
    }

    ea_t ea = static_cast<ea_t>(argv[0].as_int64());
    func_t* func = get_func(ea);
    if (func) {
        qstring name;
        if (get_func_name(&name, func->start_ea) > 0) {
            ctx.result_text(name.c_str());
            return;
        }
    }
    ctx.result_null();
}

// func_start(address) - Get start address of function containing address
static void sql_func_start(xsql::FunctionContext& ctx, int argc, xsql::FunctionArg* argv) {
    if (argc < 1) {
        ctx.result_error("func_start requires 1 argument (address)");
        return;
    }

    ea_t ea = static_cast<ea_t>(argv[0].as_int64());
    func_t* func = get_func(ea);
    if (func) {
        ctx.result_int64(func->start_ea);
    } else {
        ctx.result_null();
    }
}

// func_end(address) - Get end address of function containing address
static void sql_func_end(xsql::FunctionContext& ctx, int argc, xsql::FunctionArg* argv) {
    if (argc < 1) {
        ctx.result_error("func_end requires 1 argument (address)");
        return;
    }

    ea_t ea = static_cast<ea_t>(argv[0].as_int64());
    func_t* func = get_func(ea);
    if (func) {
        ctx.result_int64(func->end_ea);
    } else {
        ctx.result_null();
    }
}

// ============================================================================
// Function Index Functions (O(1) access)
// ============================================================================

// func_qty() - Get total function count
static void sql_func_qty(xsql::FunctionContext& ctx, int, xsql::FunctionArg*) {
    ctx.result_int64(get_func_qty());
}

// func_at_index(n) - Get function address at index n
static void sql_func_at_index(xsql::FunctionContext& ctx, int argc, xsql::FunctionArg* argv) {
    if (argc < 1) {
        ctx.result_error("func_at_index requires 1 argument (index)");
        return;
    }

    size_t idx = static_cast<size_t>(argv[0].as_int64());
    size_t qty = get_func_qty();

    if (idx >= qty) {
        ctx.result_null();
        return;
    }

    func_t* f = getn_func(idx);
    if (f) {
        ctx.result_int64(f->start_ea);
    } else {
        ctx.result_null();
    }
}

// ============================================================================
// Name Modification Functions
// ============================================================================

// set_name(address, name) - Set name at address
static void sql_set_name(xsql::FunctionContext& ctx, int argc, xsql::FunctionArg* argv) {
    if (argc < 2) {
        ctx.result_error("set_name requires 2 arguments (address, name)");
        return;
    }

    ea_t ea = static_cast<ea_t>(argv[0].as_int64());
    const char* name = argv[1].as_c_str();

    bool success = set_name(ea, name, SN_CHECK) != 0;
    if (success) decompiler::invalidate_decompiler_cache(ea);
    ctx.result_int(success ? 1 : 0);
}

// ============================================================================
// Segment Functions
// ============================================================================

// segment_at(address) - Get segment name containing address
static void sql_segment_at(xsql::FunctionContext& ctx, int argc, xsql::FunctionArg* argv) {
    if (argc < 1) {
        ctx.result_error("segment_at requires 1 argument (address)");
        return;
    }

    ea_t ea = static_cast<ea_t>(argv[0].as_int64());
    segment_t* seg = getseg(ea);
    if (seg) {
        qstring name;
        if (get_segm_name(&name, seg) > 0) {
            ctx.result_text(name.c_str());
            return;
        }
    }
    ctx.result_null();
}

// ============================================================================
// Comment Functions
// ============================================================================

// comment_at(address) - Get comment at address
static void sql_comment_at(xsql::FunctionContext& ctx, int argc, xsql::FunctionArg* argv) {
    if (argc < 1) {
        ctx.result_error("comment_at requires 1 argument (address)");
        return;
    }

    ea_t ea = static_cast<ea_t>(argv[0].as_int64());
    qstring cmt;
    if (get_cmt(&cmt, ea, false) > 0) {
        ctx.result_text(cmt.c_str());
    } else if (get_cmt(&cmt, ea, true) > 0) {
        // Try repeatable comment
        ctx.result_text(cmt.c_str());
    } else {
        ctx.result_null();
    }
}

// set_comment(address, text) - Set comment at address
// set_comment(address, text, repeatable) - Set comment with type
static void sql_set_comment(xsql::FunctionContext& ctx, int argc, xsql::FunctionArg* argv) {
    if (argc < 2) {
        ctx.result_error("set_comment requires 2-3 arguments (address, text, [repeatable])");
        return;
    }

    ea_t ea = static_cast<ea_t>(argv[0].as_int64());
    const char* cmt = argv[1].as_c_str();
    bool repeatable = (argc >= 3) ? argv[2].as_int() != 0 : false;

    bool success = set_cmt(ea, cmt ? cmt : "", repeatable);
    ctx.result_int(success ? 1 : 0);
}

// ============================================================================
// Cross-Reference Functions
// ============================================================================

// xrefs_to(address) - Get xrefs to address as JSON array
static void sql_xrefs_to(xsql::FunctionContext& ctx, int argc, xsql::FunctionArg* argv) {
    if (argc < 1) {
        ctx.result_error("xrefs_to requires 1 argument (address)");
        return;
    }

    ea_t ea = static_cast<ea_t>(argv[0].as_int64());

    xsql::json arr = xsql::json::array();
    xrefblk_t xb;
    for (bool ok = xb.first_to(ea, XREF_ALL); ok; ok = xb.next_to()) {
        arr.push_back({{"from", xb.from}, {"type", static_cast<int>(xb.type)}});
    }

    std::string str = arr.dump();
    ctx.result_text(str);
}

// xrefs_from(address) - Get xrefs from address as JSON array
static void sql_xrefs_from(xsql::FunctionContext& ctx, int argc, xsql::FunctionArg* argv) {
    if (argc < 1) {
        ctx.result_error("xrefs_from requires 1 argument (address)");
        return;
    }

    ea_t ea = static_cast<ea_t>(argv[0].as_int64());

    xsql::json arr = xsql::json::array();
    xrefblk_t xb;
    for (bool ok = xb.first_from(ea, XREF_ALL); ok; ok = xb.next_from()) {
        arr.push_back({{"to", xb.to}, {"type", static_cast<int>(xb.type)}});
    }

    std::string str = arr.dump();
    ctx.result_text(str);
}

// ============================================================================
// Decompiler Functions (Optional - requires Hex-Rays)
// ============================================================================

// Render pseudocode lines with ea prefixes
static std::string render_pseudocode(cfuncptr_t& cfunc) {
    const strvec_t& sv = cfunc->get_pseudocode();
    std::ostringstream result;
    for (size_t i = 0; i < sv.size(); i++) {
        ea_t line_ea = decompiler::extract_line_ea(&*cfunc, sv[i].line);
        qstring line = sv[i].line;
        tag_remove(&line);
        if (i > 0) result << "\n";
        char prefix[48];
        if (line_ea != 0 && line_ea != BADADDR)
            qsnprintf(prefix, sizeof(prefix), "/* %a */ ", line_ea);
        else
            qsnprintf(prefix, sizeof(prefix), "/*          */ ");
        result << prefix << line.c_str();
    }
    return result.str();
}

// decompile(address) - Get decompiled pseudocode (runtime Hex-Rays detection)
// Uses decompiler::hexrays_available() set during DecompilerRegistry::register_all()
static void sql_decompile(xsql::FunctionContext& ctx, int argc, xsql::FunctionArg* argv) {
    if (argc < 1) {
        ctx.result_error("decompile requires 1 argument (address)");
        return;
    }

    // Check cached Hex-Rays availability (set during DecompilerRegistry::register_all)
    if (!decompiler::hexrays_available()) {
        ctx.result_error("Decompiler not available (requires Hex-Rays license)");
        return;
    }

    ea_t ea = static_cast<ea_t>(argv[0].as_int64());

    func_t* func = get_func(ea);
    if (!func) {
        ctx.result_error("No function at address");
        return;
    }

    hexrays_failure_t hf;
    cfuncptr_t cfunc = decompile(func, &hf);
    if (!cfunc) {
        std::string err = "Decompilation failed: " + std::string(hf.desc().c_str());
        ctx.result_error(err);
        return;
    }

    std::string str = render_pseudocode(cfunc);
    ctx.result_text(str);
}

// decompile(address, refresh) - Get decompiled pseudocode with optional cache invalidation
// When refresh=1, invalidates the cached decompilation before decompiling.
// Use after renaming functions or local variables to get fresh pseudocode.
static void sql_decompile_2(xsql::FunctionContext& ctx, int argc, xsql::FunctionArg* argv) {
    if (argc < 2) {
        ctx.result_error("decompile requires 2 arguments (address, refresh)");
        return;
    }

    if (!decompiler::hexrays_available()) {
        ctx.result_error("Decompiler not available (requires Hex-Rays license)");
        return;
    }

    ea_t ea = static_cast<ea_t>(argv[0].as_int64());
    int refresh = argv[1].as_int();

    func_t* func = get_func(ea);
    if (!func) {
        ctx.result_error("No function at address");
        return;
    }

    if (refresh) {
        mark_cfunc_dirty(func->start_ea, false);
    }

    hexrays_failure_t hf;
    cfuncptr_t cfunc = decompile(func, &hf);
    if (!cfunc) {
        std::string err = "Decompilation failed: " + std::string(hf.desc().c_str());
        ctx.result_error(err);
        return;
    }

    std::string str = render_pseudocode(cfunc);
    ctx.result_text(str);
}

// ============================================================================
// Address Utility Functions
// ============================================================================

// next_head(address) - Get next defined head
static void sql_next_head(xsql::FunctionContext& ctx, int argc, xsql::FunctionArg* argv) {
    if (argc < 1) {
        ctx.result_error("next_head requires 1 argument (address)");
        return;
    }

    ea_t ea = static_cast<ea_t>(argv[0].as_int64());
    ea_t next = next_head(ea, BADADDR);
    if (next != BADADDR) {
        ctx.result_int64(next);
    } else {
        ctx.result_null();
    }
}

// prev_head(address) - Get previous defined head
static void sql_prev_head(xsql::FunctionContext& ctx, int argc, xsql::FunctionArg* argv) {
    if (argc < 1) {
        ctx.result_error("prev_head requires 1 argument (address)");
        return;
    }

    ea_t ea = static_cast<ea_t>(argv[0].as_int64());
    ea_t prev = prev_head(ea, 0);
    if (prev != BADADDR) {
        ctx.result_int64(prev);
    } else {
        ctx.result_null();
    }
}

// hex(value) - Format integer as hex string
static void sql_hex(xsql::FunctionContext& ctx, int argc, xsql::FunctionArg* argv) {
    if (argc < 1) {
        ctx.result_error("hex requires 1 argument (value)");
        return;
    }

    int64_t val = argv[0].as_int64();
    std::ostringstream result;
    result << "0x" << std::hex << val;
    std::string str = result.str();
    ctx.result_text(str);
}

// ============================================================================
// Item Query Functions
// ============================================================================

// item_type(address) - Get type of item at address
static void sql_item_type(xsql::FunctionContext& ctx, int argc, xsql::FunctionArg* argv) {
    if (argc < 1) {
        ctx.result_error("item_type requires 1 argument (address)");
        return;
    }

    ea_t ea = static_cast<ea_t>(argv[0].as_int64());
    flags64_t f = get_flags(ea);

    const char* type = "unknown";
    if (is_code(f)) type = "code";
    else if (is_strlit(f)) type = "string";
    else if (is_struct(f)) type = "struct";
    else if (is_align(f)) type = "align";
    else if (is_data(f)) type = "data";

    ctx.result_text_static(type);
}

// item_size(address) - Get size of item at address
static void sql_item_size(xsql::FunctionContext& ctx, int argc, xsql::FunctionArg* argv) {
    if (argc < 1) {
        ctx.result_error("item_size requires 1 argument (address)");
        return;
    }

    ea_t ea = static_cast<ea_t>(argv[0].as_int64());
    asize_t size = get_item_size(ea);
    ctx.result_int64(size);
}

// is_code(address) - Check if address is code
static void sql_is_code(xsql::FunctionContext& ctx, int argc, xsql::FunctionArg* argv) {
    if (argc < 1) {
        ctx.result_error("is_code requires 1 argument (address)");
        return;
    }

    ea_t ea = static_cast<ea_t>(argv[0].as_int64());
    ctx.result_int(is_code(get_flags(ea)) ? 1 : 0);
}

// is_data(address) - Check if address is data
static void sql_is_data(xsql::FunctionContext& ctx, int argc, xsql::FunctionArg* argv) {
    if (argc < 1) {
        ctx.result_error("is_data requires 1 argument (address)");
        return;
    }

    ea_t ea = static_cast<ea_t>(argv[0].as_int64());
    ctx.result_int(is_data(get_flags(ea)) ? 1 : 0);
}

// mnemonic(address) - Get instruction mnemonic
static void sql_mnemonic(xsql::FunctionContext& ctx, int argc, xsql::FunctionArg* argv) {
    if (argc < 1) {
        ctx.result_error("mnemonic requires 1 argument (address)");
        return;
    }

    ea_t ea = static_cast<ea_t>(argv[0].as_int64());
    if (!is_code(get_flags(ea))) {
        ctx.result_null();
        return;
    }

    qstring mnem;
    print_insn_mnem(&mnem, ea);
    ctx.result_text(mnem.c_str());
}

// operand(address, n) - Get operand text
static void sql_operand(xsql::FunctionContext& ctx, int argc, xsql::FunctionArg* argv) {
    if (argc < 2) {
        ctx.result_error("operand requires 2 arguments (address, operand_num)");
        return;
    }

    ea_t ea = static_cast<ea_t>(argv[0].as_int64());
    int n = argv[1].as_int();

    if (!is_code(get_flags(ea)) || n < 0 || n > 5) {
        ctx.result_null();
        return;
    }

    qstring op;
    print_operand(&op, ea, n);
    tag_remove(&op);
    if (op.empty()) {
        ctx.result_null();
    } else {
        ctx.result_text(op.c_str());
    }
}

// flags_at(address) - Get raw flags at address
static void sql_flags_at(xsql::FunctionContext& ctx, int argc, xsql::FunctionArg* argv) {
    if (argc < 1) {
        ctx.result_error("flags_at requires 1 argument (address)");
        return;
    }

    ea_t ea = static_cast<ea_t>(argv[0].as_int64());
    ctx.result_int64(get_flags(ea));
}

// ============================================================================
// Instruction Decoding Functions
// ============================================================================

// Operand type names
static const char* get_optype_name(optype_t type) {
    switch (type) {
        case o_void:    return "void";
        case o_reg:     return "reg";
        case o_mem:     return "mem";
        case o_phrase:  return "phrase";
        case o_displ:   return "displ";
        case o_imm:     return "imm";
        case o_far:     return "far";
        case o_near:    return "near";
        default:        return "idpspec";
    }
}

// itype(address) - Get instruction type code
static void sql_itype(xsql::FunctionContext& ctx, int argc, xsql::FunctionArg* argv) {
    if (argc < 1) {
        ctx.result_error("itype requires 1 argument (address)");
        return;
    }

    ea_t ea = static_cast<ea_t>(argv[0].as_int64());

    if (!is_code(get_flags(ea))) {
        ctx.result_null();
        return;
    }

    insn_t insn;
    if (decode_insn(&insn, ea) > 0) {
        ctx.result_int(insn.itype);
    } else {
        ctx.result_null();
    }
}

// decode_insn(address) - Get full instruction info as JSON
static void sql_decode_insn(xsql::FunctionContext& ctx, int argc, xsql::FunctionArg* argv) {
    if (argc < 1) {
        ctx.result_error("decode_insn requires 1 argument (address)");
        return;
    }

    ea_t ea = static_cast<ea_t>(argv[0].as_int64());

    if (!is_code(get_flags(ea))) {
        ctx.result_null();
        return;
    }

    insn_t insn;
    int len = decode_insn(&insn, ea);
    if (len <= 0) {
        ctx.result_null();
        return;
    }

    // Get mnemonic
    qstring mnem;
    print_insn_mnem(&mnem, ea);

    // Build JSON using xsql::json
    xsql::json result = {
        {"ea", insn.ea},
        {"itype", insn.itype},
        {"size", insn.size},
        {"mnemonic", mnem.c_str()}
    };

    // Operands array
    xsql::json ops = xsql::json::array();
    for (int i = 0; i < UA_MAXOP; i++) {
        const op_t& op = insn.ops[i];
        if (op.type == o_void) break;

        // Get operand text
        qstring op_text;
        print_operand(&op_text, ea, i);
        tag_remove(&op_text);

        ops.push_back({
            {"n", i},
            {"type", static_cast<int>(op.type)},
            {"type_name", get_optype_name(op.type)},
            {"dtype", static_cast<int>(op.dtype)},
            {"reg", op.reg},
            {"addr", op.addr},
            {"value", op.value},
            {"text", op_text.c_str()}  // nlohmann auto-escapes
        });
    }
    result["operands"] = ops;

    std::string str = result.dump();
    ctx.result_text(str);
}

// operand_type(address, n) - Get operand type
static void sql_operand_type(xsql::FunctionContext& ctx, int argc, xsql::FunctionArg* argv) {
    if (argc < 2) {
        ctx.result_error("operand_type requires 2 arguments (address, operand_num)");
        return;
    }

    ea_t ea = static_cast<ea_t>(argv[0].as_int64());
    int n = argv[1].as_int();

    if (!is_code(get_flags(ea)) || n < 0 || n >= UA_MAXOP) {
        ctx.result_null();
        return;
    }

    insn_t insn;
    if (decode_insn(&insn, ea) <= 0) {
        ctx.result_null();
        return;
    }

    const op_t& op = insn.ops[n];
    if (op.type == o_void) {
        ctx.result_null();
    } else {
        ctx.result_text_static(get_optype_name(op.type));
    }
}

// operand_value(address, n) - Get operand value (immediate or address)
static void sql_operand_value(xsql::FunctionContext& ctx, int argc, xsql::FunctionArg* argv) {
    if (argc < 2) {
        ctx.result_error("operand_value requires 2 arguments (address, operand_num)");
        return;
    }

    ea_t ea = static_cast<ea_t>(argv[0].as_int64());
    int n = argv[1].as_int();

    if (!is_code(get_flags(ea)) || n < 0 || n >= UA_MAXOP) {
        ctx.result_null();
        return;
    }

    insn_t insn;
    if (decode_insn(&insn, ea) <= 0) {
        ctx.result_null();
        return;
    }

    const op_t& op = insn.ops[n];
    switch (op.type) {
        case o_void:
            ctx.result_null();
            break;
        case o_imm:
            ctx.result_int64(op.value);
            break;
        case o_mem:
        case o_near:
        case o_far:
        case o_displ:
            ctx.result_int64(op.addr);
            break;
        case o_reg:
            ctx.result_int(op.reg);
            break;
        default:
            ctx.result_int64(op.value);
            break;
    }
}

// ============================================================================
// File Generation Functions
// ============================================================================

// Helper: Generate file using ida_loader.gen_file
static int gen_file_helper(ofile_type_t ofile_type, const char* filepath, ea_t ea1, ea_t ea2, int flags) {
    qstring path(filepath);
    FILE* fp = qfopen(path.c_str(), "w");
    if (!fp) return -1;

    int result = gen_file(ofile_type, fp, ea1, ea2, flags);
    qfclose(fp);
    return result;
}

// gen_asm_file(ea1, ea2, path) - Generate assembly file
static void sql_gen_asm_file(xsql::FunctionContext& ctx, int argc, xsql::FunctionArg* argv) {
    if (argc < 3) {
        ctx.result_error("gen_asm_file requires 3 arguments (ea1, ea2, path)");
        return;
    }

    ea_t ea1 = static_cast<ea_t>(argv[0].as_int64());
    ea_t ea2 = static_cast<ea_t>(argv[1].as_int64());
    const char* path = argv[2].as_c_str();
    if (!path) {
        ctx.result_error("Invalid path");
        return;
    }

    int result = gen_file_helper(OFILE_ASM, path, ea1, ea2, 0);
    ctx.result_int(result);
}

// gen_lst_file(ea1, ea2, path) - Generate listing file with addresses
static void sql_gen_lst_file(xsql::FunctionContext& ctx, int argc, xsql::FunctionArg* argv) {
    if (argc < 3) {
        ctx.result_error("gen_lst_file requires 3 arguments (ea1, ea2, path)");
        return;
    }

    ea_t ea1 = static_cast<ea_t>(argv[0].as_int64());
    ea_t ea2 = static_cast<ea_t>(argv[1].as_int64());
    const char* path = argv[2].as_c_str();
    if (!path) {
        ctx.result_error("Invalid path");
        return;
    }

    int result = gen_file_helper(OFILE_LST, path, ea1, ea2, 0);
    ctx.result_int(result);
}

// gen_map_file(path) - Generate MAP file
static void sql_gen_map_file(xsql::FunctionContext& ctx, int argc, xsql::FunctionArg* argv) {
    if (argc < 1) {
        ctx.result_error("gen_map_file requires 1 argument (path)");
        return;
    }

    const char* path = argv[0].as_c_str();
    if (!path) {
        ctx.result_error("Invalid path");
        return;
    }

    // MAP files ignore ea1/ea2, use GENFLG_MAPSEG | GENFLG_MAPNAME
    int flags = GENFLG_MAPSEG | GENFLG_MAPNAME | GENFLG_MAPDMNG;
    int result = gen_file_helper(OFILE_MAP, path, 0, BADADDR, flags);
    ctx.result_int(result);
}

// gen_idc_file(ea1, ea2, path) - Generate IDC script
static void sql_gen_idc_file(xsql::FunctionContext& ctx, int argc, xsql::FunctionArg* argv) {
    if (argc < 3) {
        ctx.result_error("gen_idc_file requires 3 arguments (ea1, ea2, path)");
        return;
    }

    ea_t ea1 = static_cast<ea_t>(argv[0].as_int64());
    ea_t ea2 = static_cast<ea_t>(argv[1].as_int64());
    const char* path = argv[2].as_c_str();
    if (!path) {
        ctx.result_error("Invalid path");
        return;
    }

    int result = gen_file_helper(OFILE_IDC, path, ea1, ea2, 0);
    ctx.result_int(result);
}

// gen_html_file(ea1, ea2, path) - Generate HTML listing
static void sql_gen_html_file(xsql::FunctionContext& ctx, int argc, xsql::FunctionArg* argv) {
    if (argc < 3) {
        ctx.result_error("gen_html_file requires 3 arguments (ea1, ea2, path)");
        return;
    }

    ea_t ea1 = static_cast<ea_t>(argv[0].as_int64());
    ea_t ea2 = static_cast<ea_t>(argv[1].as_int64());
    const char* path = argv[2].as_c_str();
    if (!path) {
        ctx.result_error("Invalid path");
        return;
    }

    int result = gen_file_helper(OFILE_LST, path, ea1, ea2, GENFLG_GENHTML);
    ctx.result_int(result);
}

// gen_cfg_dot(address) - Generate CFG as DOT string
static void sql_gen_cfg_dot(xsql::FunctionContext& ctx, int argc, xsql::FunctionArg* argv) {
    if (argc < 1) {
        ctx.result_error("gen_cfg_dot requires 1 argument (func_address)");
        return;
    }

    ea_t ea = static_cast<ea_t>(argv[0].as_int64());
    func_t* func = get_func(ea);
    if (!func) {
        ctx.result_error("No function at address");
        return;
    }

    // Build DOT representation using FlowChart
    qflow_chart_t fc;
    fc.create("", func, func->start_ea, func->end_ea, FC_NOEXT);

    qstring func_name;
    get_func_name(&func_name, func->start_ea);
    if (func_name.empty()) {
        func_name.sprnt("sub_%llX", (uint64)func->start_ea);
    }

    std::ostringstream dot;
    dot << "digraph CFG {\n";
    dot << "  node [shape=box, fontname=\"Courier\"];\n";
    dot << "  label=\"" << func_name.c_str() << "\";\n\n";

    // Emit nodes
    for (int i = 0; i < fc.size(); i++) {
        const qbasic_block_t& bb = fc.blocks[i];
        dot << "  n" << i << " [label=\"";
        dot << std::hex << "0x" << bb.start_ea << " - 0x" << bb.end_ea;
        dot << "\"];\n";
    }

    dot << "\n";

    // Emit edges
    for (int i = 0; i < fc.size(); i++) {
        const qbasic_block_t& bb = fc.blocks[i];
        for (int j = 0; j < bb.succ.size(); j++) {
            dot << "  n" << i << " -> n" << bb.succ[j] << ";\n";
        }
    }

    dot << "}\n";

    std::string str = dot.str();
    ctx.result_text(str);
}

// gen_cfg_dot_file(address, path) - Generate CFG DOT to file
static void sql_gen_cfg_dot_file(xsql::FunctionContext& ctx, int argc, xsql::FunctionArg* argv) {
    if (argc < 2) {
        ctx.result_error("gen_cfg_dot_file requires 2 arguments (func_address, path)");
        return;
    }

    ea_t ea = static_cast<ea_t>(argv[0].as_int64());
    const char* path = argv[1].as_c_str();
    if (!path) {
        ctx.result_error("Invalid path");
        return;
    }

    func_t* func = get_func(ea);
    if (!func) {
        ctx.result_error("No function at address");
        return;
    }

    // Build DOT using FlowChart
    qflow_chart_t fc;
    fc.create("", func, func->start_ea, func->end_ea, FC_NOEXT);

    qstring func_name;
    get_func_name(&func_name, func->start_ea);
    if (func_name.empty()) {
        func_name.sprnt("sub_%llX", (uint64)func->start_ea);
    }

    FILE* fp = qfopen(path, "w");
    if (!fp) {
        ctx.result_error("Failed to open file");
        return;
    }

    qfprintf(fp, "digraph CFG {\n");
    qfprintf(fp, "  node [shape=box, fontname=\"Courier\"];\n");
    qfprintf(fp, "  label=\"%s\";\n\n", func_name.c_str());

    // Emit nodes
    for (int i = 0; i < fc.size(); i++) {
        const qbasic_block_t& bb = fc.blocks[i];
        qfprintf(fp, "  n%d [label=\"0x%llX - 0x%llX\"];\n",
                 i, (uint64)bb.start_ea, (uint64)bb.end_ea);
    }

    qfprintf(fp, "\n");

    // Emit edges
    for (int i = 0; i < fc.size(); i++) {
        const qbasic_block_t& bb = fc.blocks[i];
        for (int j = 0; j < bb.succ.size(); j++) {
            qfprintf(fp, "  n%d -> n%d;\n", i, bb.succ[j]);
        }
    }

    qfprintf(fp, "}\n");
    qfclose(fp);

    ctx.result_int(1);  // Success
}

// gen_schema_dot(db) - Generate DOT diagram of all tables
// This uses SQLite introspection to build the schema
static void sql_gen_schema_dot(xsql::FunctionContext& ctx, int argc, xsql::FunctionArg* argv) {
    sqlite3* db = ctx.db_handle();

    std::ostringstream dot;
    dot << "digraph IDASQL_Schema {\n";
    dot << "  rankdir=TB;\n";
    dot << "  node [shape=record, fontname=\"Helvetica\", fontsize=10];\n";
    dot << "  edge [fontname=\"Helvetica\", fontsize=8];\n\n";

    // Query all tables from sqlite_master
    sqlite3_stmt* stmt;
    const char* sql = "SELECT name, type FROM sqlite_master WHERE type IN ('table', 'view') ORDER BY name";
    if (sqlite3_prepare_v2(db, sql, -1, &stmt, nullptr) != SQLITE_OK) {
        ctx.result_error("Failed to query schema");
        return;
    }

    std::vector<std::string> tables;
    while (sqlite3_step(stmt) == SQLITE_ROW) {
        const char* name = (const char*)sqlite3_column_text(stmt, 0);
        const char* type = (const char*)sqlite3_column_text(stmt, 1);
        if (name) {
            tables.push_back(name);

            // Get column info for this table
            std::string pragma = "PRAGMA table_info(" + std::string(name) + ")";
            sqlite3_stmt* col_stmt;
            if (sqlite3_prepare_v2(db, pragma.c_str(), -1, &col_stmt, nullptr) == SQLITE_OK) {
                dot << "  " << name << " [label=\"{" << name;
                if (type && strcmp(type, "view") == 0) dot << " (view)";
                dot << "|";

                bool first = true;
                while (sqlite3_step(col_stmt) == SQLITE_ROW) {
                    const char* col_name = (const char*)sqlite3_column_text(col_stmt, 1);
                    const char* col_type = (const char*)sqlite3_column_text(col_stmt, 2);
                    if (!first) dot << "\\l";
                    first = false;
                    dot << (col_name ? col_name : "?");
                    if (col_type && strlen(col_type) > 0) {
                        dot << " : " << col_type;
                    }
                }
                dot << "\\l}\"];\n";
                sqlite3_finalize(col_stmt);
            }
        }
    }
    sqlite3_finalize(stmt);

    // Add relationships based on naming conventions
    dot << "\n  // Relationships (inferred from naming)\n";

    // Common relationships in IDA
    for (const auto& t : tables) {
        if (t == "funcs" || t == "funcs_live") {
            dot << "  segments -> " << t << " [label=\"contains\"];\n";
        }
        if (t == "names" || t == "names_live") {
            dot << "  segments -> " << t << " [label=\"contains\"];\n";
        }
        if (t == "strings") {
            dot << "  segments -> strings [label=\"contains\"];\n";
        }
        if (t == "xrefs") {
            dot << "  funcs -> xrefs [label=\"has\"];\n";
            dot << "  xrefs -> names [label=\"references\"];\n";
        }
        if (t == "blocks") {
            dot << "  funcs -> blocks [label=\"contains\"];\n";
        }
        if (t == "comments_live") {
            dot << "  funcs -> comments_live [label=\"has\"];\n";
        }
    }

    dot << "}\n";

    std::string str = dot.str();
    ctx.result_text(str);
}

// ============================================================================
// Decompiler Lvar Functions (requires Hex-Rays)
// ============================================================================

// rename_lvar(func_addr, lvar_idx, new_name) - Rename a local variable
// Uses locator-based rename_lvar_at() for precise identification by index.
// Returns JSON with result details.
static void sql_rename_lvar(xsql::FunctionContext& ctx, int argc, xsql::FunctionArg* argv) {
    if (argc < 3) {
        ctx.result_error("rename_lvar requires 3 arguments (func_addr, lvar_idx, new_name)");
        return;
    }

    ea_t func_addr = static_cast<ea_t>(argv[0].as_int64());
    int lvar_idx = argv[1].as_int();
    const char* new_name = argv[2].as_c_str();

    if (!new_name) {
        ctx.result_error("Invalid name");
        return;
    }

    bool success = decompiler::rename_lvar_at(func_addr, lvar_idx, new_name);

    xsql::json result = {
        {"func_addr", func_addr},
        {"lvar_idx", lvar_idx},
        {"new_name", new_name},
        {"success", success}
    };
    if (!success) {
        result["error"] = "rename failed";
    }
    std::string str = result.dump();
    ctx.result_text(str);
}

// list_lvars(func_addr) - List local variables for a function as JSON
static void sql_list_lvars(xsql::FunctionContext& ctx, int argc, xsql::FunctionArg* argv) {
    if (argc < 1) {
        ctx.result_error("list_lvars requires 1 argument (func_addr)");
        return;
    }

    ea_t func_addr = static_cast<ea_t>(argv[0].as_int64());

    // Check cached Hex-Rays availability
    if (!decompiler::hexrays_available()) {
        ctx.result_error("Hex-Rays not available");
        return;
    }

    func_t* f = get_func(func_addr);
    if (!f) {
        ctx.result_error("Function not found");
        return;
    }

    hexrays_failure_t hf;
    cfuncptr_t cfunc = decompile(f, &hf);
    if (!cfunc) {
        std::string err = "Decompilation failed: " + std::string(hf.str.c_str());
        ctx.result_error(err);
        return;
    }

    lvars_t* lvars = cfunc->get_lvars();
    if (!lvars) {
        ctx.result_text_static("[]");
        return;
    }

    xsql::json arr = xsql::json::array();
    for (size_t i = 0; i < lvars->size(); i++) {
        const lvar_t& lv = (*lvars)[i];

        qstring type_str;
        lv.type().print(&type_str);

        arr.push_back({
            {"idx", i},
            {"name", lv.name.c_str()},
            {"type", type_str.c_str()},
            {"size", lv.width},
            {"is_arg", lv.is_arg_var()},
            {"is_result", lv.is_result_var()}
        });
    }

    std::string str = arr.dump();
    ctx.result_text(str);
}

// ============================================================================
// Jump Search Functions (unified entity search)
// ============================================================================

// Build dynamic SQL query for entity search
// prefix: search pattern
// contains: if true, use '%prefix%', otherwise 'prefix%'
// limit: max results
// offset: pagination offset
inline std::string build_jump_query(const std::string& prefix, bool contains, int limit, int offset) {
    if (prefix.empty()) return "";

    // Escape single quotes in prefix
    std::string escaped;
    for (char c : prefix) {
        if (c == '\'') escaped += "''";
        else escaped += std::tolower(c);
    }

    std::string pattern = contains
        ? ("'%" + escaped + "%'")
        : ("'" + escaped + "%'");

    std::ostringstream sql;
    sql << "SELECT name, kind, address, ordinal, parent_name, full_name FROM (\n";

    // Functions
    sql << "    SELECT name, 'function' as kind, address, NULL as ordinal,\n";
    sql << "           NULL as parent_name, name as full_name\n";
    sql << "    FROM funcs WHERE LOWER(name) LIKE " << pattern << "\n";
    sql << "    UNION ALL\n";

    // Labels (exclude function starts)
    sql << "    SELECT name, 'label', address, NULL, NULL, name\n";
    sql << "    FROM names n WHERE LOWER(name) LIKE " << pattern << "\n";
    sql << "      AND NOT EXISTS (SELECT 1 FROM funcs f WHERE f.address = n.address)\n";
    sql << "    UNION ALL\n";

    // Segments
    sql << "    SELECT name, 'segment', start_ea, NULL, NULL, name\n";
    sql << "    FROM segments WHERE LOWER(name) LIKE " << pattern << "\n";
    sql << "    UNION ALL\n";

    // Structs
    sql << "    SELECT name, 'struct', NULL, ordinal, NULL, name\n";
    sql << "    FROM types WHERE is_struct = 1 AND LOWER(name) LIKE " << pattern << "\n";
    sql << "    UNION ALL\n";

    // Unions
    sql << "    SELECT name, 'union', NULL, ordinal, NULL, name\n";
    sql << "    FROM types WHERE is_union = 1 AND LOWER(name) LIKE " << pattern << "\n";
    sql << "    UNION ALL\n";

    // Enums
    sql << "    SELECT name, 'enum', NULL, ordinal, NULL, name\n";
    sql << "    FROM types WHERE is_enum = 1 AND LOWER(name) LIKE " << pattern << "\n";
    sql << "    UNION ALL\n";

    // Struct/union members
    sql << "    SELECT member_name, 'member', NULL, type_ordinal,\n";
    sql << "           type_name, type_name || '.' || member_name\n";
    sql << "    FROM types_members WHERE LOWER(member_name) LIKE " << pattern << "\n";
    sql << "    UNION ALL\n";

    // Enum members
    sql << "    SELECT value_name, 'enum_member', NULL, type_ordinal,\n";
    sql << "           type_name, type_name || '.' || value_name\n";
    sql << "    FROM types_enum_values WHERE LOWER(value_name) LIKE " << pattern << "\n";

    sql << ")\n";
    sql << "ORDER BY kind, name\n";
    sql << "LIMIT " << limit << " OFFSET " << offset;

    return sql.str();
}

// jump_search(prefix, mode, limit, offset) - Search entities, return JSON array
// mode: 'prefix' or 'contains'
static void sql_jump_search(xsql::FunctionContext& ctx, int argc, xsql::FunctionArg* argv) {
    if (argc < 4) {
        ctx.result_error("jump_search requires 4 arguments (prefix, mode, limit, offset)");
        return;
    }

    const char* prefix = argv[0].as_c_str();
    const char* mode = argv[1].as_c_str();
    int limit = argv[2].as_int();
    int offset = argv[3].as_int();

    if (!prefix || !mode) {
        ctx.result_error("Invalid arguments");
        return;
    }

    bool contains = (strcmp(mode, "contains") == 0);
    std::string query = build_jump_query(prefix, contains, limit, offset);

    if (query.empty()) {
        ctx.result_text_static("[]");
        return;
    }

    // Execute query and build JSON result
    sqlite3* db = ctx.db_handle();
    sqlite3_stmt* stmt;

    if (sqlite3_prepare_v2(db, query.c_str(), -1, &stmt, nullptr) != SQLITE_OK) {
        std::string err = "Query error: " + std::string(sqlite3_errmsg(db));
        ctx.result_error(err);
        return;
    }

    xsql::json arr = xsql::json::array();

    while (sqlite3_step(stmt) == SQLITE_ROW) {
        const char* name = (const char*)sqlite3_column_text(stmt, 0);
        const char* kind = (const char*)sqlite3_column_text(stmt, 1);
        int64_t address = sqlite3_column_int64(stmt, 2);
        int ordinal = sqlite3_column_int(stmt, 3);
        const char* parent = (const char*)sqlite3_column_text(stmt, 4);
        const char* full_name = (const char*)sqlite3_column_text(stmt, 5);

        xsql::json obj = {
            {"name", name ? name : ""},
            {"kind", kind ? kind : ""},
            {"full_name", full_name ? full_name : ""}
        };

        // Handle nullable fields
        if (sqlite3_column_type(stmt, 2) != SQLITE_NULL) {
            obj["address"] = address;
        } else {
            obj["address"] = nullptr;
        }

        if (sqlite3_column_type(stmt, 3) != SQLITE_NULL) {
            obj["ordinal"] = ordinal;
        } else {
            obj["ordinal"] = nullptr;
        }

        obj["parent_name"] = parent ? xsql::json(parent) : xsql::json(nullptr);

        arr.push_back(obj);
    }

    sqlite3_finalize(stmt);

    std::string result = arr.dump();
    ctx.result_text(result);
}

// jump_query(prefix, mode, limit, offset) - Return the SQL query string
static void sql_jump_query(xsql::FunctionContext& ctx, int argc, xsql::FunctionArg* argv) {
    if (argc < 4) {
        ctx.result_error("jump_query requires 4 arguments (prefix, mode, limit, offset)");
        return;
    }

    const char* prefix = argv[0].as_c_str();
    const char* mode = argv[1].as_c_str();
    int limit = argv[2].as_int();
    int offset = argv[3].as_int();

    if (!prefix || !mode) {
        ctx.result_error("Invalid arguments");
        return;
    }

    bool contains = (strcmp(mode, "contains") == 0);
    std::string query = build_jump_query(prefix, contains, limit, offset);

    ctx.result_text(query);
}

// ============================================================================
// String List Functions
// ============================================================================

// rebuild_strings() - Rebuild IDA's string list
// Returns: number of strings found
//
// Args (all optional):
//   min_len: minimum string length (default 5)
//   types: string types bitmask (default 3 = ASCII + UTF-16)
//          1 = ASCII (STRTYPE_C)
//          2 = UTF-16 (STRTYPE_C_16)
//          4 = UTF-32 (STRTYPE_C_32)
//          3 = ASCII + UTF-16 (default)
//          7 = all types
//
// Example:
//   SELECT rebuild_strings();        -- Default: ASCII + UTF-16, minlen 5
//   SELECT rebuild_strings(4);       -- ASCII + UTF-16, minlen 4
//   SELECT rebuild_strings(5, 1);    -- ASCII only, minlen 5
//   SELECT rebuild_strings(5, 7);    -- All types, minlen 5
static void sql_rebuild_strings(xsql::FunctionContext& ctx, int argc, xsql::FunctionArg* argv) {
    int min_len = 5;
    int types_mask = 3;  // Default: ASCII + UTF-16

    if (argc >= 1 && !argv[0].is_null()) {
        min_len = argv[0].as_int();
        if (min_len < 1) min_len = 1;
        if (min_len > 1000) min_len = 1000;
    }
    if (argc >= 2 && !argv[1].is_null()) {
        types_mask = argv[1].as_int();
    }

    // Get the options pointer - despite 'const', it IS modifiable (same as Python bindings)
    strwinsetup_t* opts = const_cast<strwinsetup_t*>(get_strlist_options());

    // Configure string types based on mask
    opts->strtypes.clear();
    if (types_mask & 1) opts->strtypes.push_back(STRTYPE_C);      // ASCII
    if (types_mask & 2) opts->strtypes.push_back(STRTYPE_C_16);   // UTF-16
    if (types_mask & 4) opts->strtypes.push_back(STRTYPE_C_32);   // UTF-32

    // Set minimum length
    opts->minlen = min_len;

    // Allow extended ASCII
    opts->only_7bit = 0;

    // Clear and rebuild with new settings
    clear_strlist();
    build_strlist();

    // Invalidate the strings virtual table cache so queries see new data
    entities::TableRegistry::invalidate_strings_cache_global();

    // Return the count
    size_t count = get_strlist_qty();
    ctx.result_int64(static_cast<int64_t>(count));
}

// string_count() - Get current count of strings in IDA's cached list (no rebuild)
static void sql_string_count(xsql::FunctionContext& ctx, int /*argc*/, xsql::FunctionArg* /*argv*/) {
    ctx.result_int64(static_cast<int64_t>(get_strlist_qty()));
}

// ============================================================================
// Database Persistence
// ============================================================================

// save_database() - Persist changes to the IDA database file
// Returns: 1 on success, 0 on failure
static void sql_save_database(xsql::FunctionContext& ctx, int /*argc*/, xsql::FunctionArg* /*argv*/) {
    bool ok = save_database();  // IDA API: save to current file with default flags
    ctx.result_int(ok ? 1 : 0);
}

// ============================================================================
// Registration
// ============================================================================

inline bool register_sql_functions(xsql::Database& db) {
    // Disassembly
    db.register_function("disasm", 1, xsql::ScalarFn(sql_disasm));
    db.register_function("disasm", 2, xsql::ScalarFn(sql_disasm));

    // Bytes
    db.register_function("bytes", 2, xsql::ScalarFn(sql_bytes_hex));
    db.register_function("bytes_raw", 2, xsql::ScalarFn(sql_bytes_raw));

    // Names
    db.register_function("name_at", 1, xsql::ScalarFn(sql_name_at));
    db.register_function("func_at", 1, xsql::ScalarFn(sql_func_at));
    db.register_function("func_start", 1, xsql::ScalarFn(sql_func_start));
    db.register_function("func_end", 1, xsql::ScalarFn(sql_func_end));
    db.register_function("set_name", 2, xsql::ScalarFn(sql_set_name));

    // Function index (O(1) access)
    db.register_function("func_qty", 0, xsql::ScalarFn(sql_func_qty));
    db.register_function("func_at_index", 1, xsql::ScalarFn(sql_func_at_index));

    // Segments
    db.register_function("segment_at", 1, xsql::ScalarFn(sql_segment_at));

    // Comments
    db.register_function("comment_at", 1, xsql::ScalarFn(sql_comment_at));
    db.register_function("set_comment", 2, xsql::ScalarFn(sql_set_comment));
    db.register_function("set_comment", 3, xsql::ScalarFn(sql_set_comment));

    // Cross-references
    db.register_function("xrefs_to", 1, xsql::ScalarFn(sql_xrefs_to));
    db.register_function("xrefs_from", 1, xsql::ScalarFn(sql_xrefs_from));

    // Decompiler (only registered if Hex-Rays is available)
    if (decompiler::hexrays_available()) {
        db.register_function("decompile", 1, xsql::ScalarFn(sql_decompile));
        db.register_function("decompile", 2, xsql::ScalarFn(sql_decompile_2));
        db.register_function("list_lvars", 1, xsql::ScalarFn(sql_list_lvars));
        db.register_function("rename_lvar", 3, xsql::ScalarFn(sql_rename_lvar));
    }

    // Address utilities
    db.register_function("next_head", 1, xsql::ScalarFn(sql_next_head));
    db.register_function("prev_head", 1, xsql::ScalarFn(sql_prev_head));
    db.register_function("hex", 1, xsql::ScalarFn(sql_hex));

    // Item query functions
    db.register_function("item_type", 1, xsql::ScalarFn(sql_item_type));
    db.register_function("item_size", 1, xsql::ScalarFn(sql_item_size));
    db.register_function("is_code", 1, xsql::ScalarFn(sql_is_code));
    db.register_function("is_data", 1, xsql::ScalarFn(sql_is_data));
    db.register_function("mnemonic", 1, xsql::ScalarFn(sql_mnemonic));
    db.register_function("operand", 2, xsql::ScalarFn(sql_operand));
    db.register_function("flags_at", 1, xsql::ScalarFn(sql_flags_at));

    // Instruction decoding
    db.register_function("itype", 1, xsql::ScalarFn(sql_itype));
    db.register_function("decode_insn", 1, xsql::ScalarFn(sql_decode_insn));
    db.register_function("operand_type", 2, xsql::ScalarFn(sql_operand_type));
    db.register_function("operand_value", 2, xsql::ScalarFn(sql_operand_value));

    // File generation
    db.register_function("gen_asm_file", 3, xsql::ScalarFn(sql_gen_asm_file));
    db.register_function("gen_lst_file", 3, xsql::ScalarFn(sql_gen_lst_file));
    db.register_function("gen_map_file", 1, xsql::ScalarFn(sql_gen_map_file));
    db.register_function("gen_idc_file", 3, xsql::ScalarFn(sql_gen_idc_file));
    db.register_function("gen_html_file", 3, xsql::ScalarFn(sql_gen_html_file));

    // Graph generation
    db.register_function("gen_cfg_dot", 1, xsql::ScalarFn(sql_gen_cfg_dot));
    db.register_function("gen_cfg_dot_file", 2, xsql::ScalarFn(sql_gen_cfg_dot_file));
    db.register_function("gen_schema_dot", 0, xsql::ScalarFn(sql_gen_schema_dot));

    // Jump search
    db.register_function("jump_search", 4, xsql::ScalarFn(sql_jump_search));
    db.register_function("jump_query", 4, xsql::ScalarFn(sql_jump_query));

    // String list functions
    db.register_function("rebuild_strings", 0, xsql::ScalarFn(sql_rebuild_strings));
    db.register_function("rebuild_strings", 1, xsql::ScalarFn(sql_rebuild_strings));
    db.register_function("rebuild_strings", 2, xsql::ScalarFn(sql_rebuild_strings));
    db.register_function("string_count", 0, xsql::ScalarFn(sql_string_count));

    // Database persistence
    db.register_function("save_database", 0, xsql::ScalarFn(sql_save_database));

    return true;
}

} // namespace functions
} // namespace idasql

```

`src/lib/include/idasql/idasql.hpp`:

```hpp
/**
 * idasql.hpp - Main include header for IDASQL library
 *
 * This is the convenience header that includes all IDASQL components.
 *
 * Usage:
 *   #include <idasql/idasql.hpp>
 *
 *   idasql::Database db;
 *   db.open("database.i64");
 *   db.exec("SELECT * FROM funcs", callback, nullptr);
 *   db.close();
 */

#pragma once

// Core virtual table framework
#include <idasql/vtable.hpp>

// Entity tables
#include <idasql/entities.hpp>
#include <idasql/entities_ext.hpp>
#include <idasql/entities_types.hpp>

// Decompiler tables (requires Hex-Rays)
#include <idasql/decompiler.hpp>

// Metadata tables
#include <idasql/metadata.hpp>

// SQL functions
#include <idasql/functions.hpp>

// Database wrapper class
#include <idasql/database.hpp>

```

`src/lib/include/idasql/metadata.hpp`:

```hpp
/**
 * ida_metadata.hpp - IDA database metadata as virtual tables
 *
 * These tables provide metadata about the database itself, not entities within it.
 * Many of these work even without a fully loaded database.
 *
 * Tables:
 *   db_info     - Database information (processor, file type, etc.)
 *   ida_info    - IDA analysis settings and flags
 */

#pragma once

#include <idasql/platform.hpp>

#include <idasql/vtable.hpp>
#include <xsql/database.hpp>

#include <idasql/platform_undef.hpp>

// IDA SDK headers
#include <ida.hpp>
#include <idp.hpp>
#include <loader.hpp>

namespace idasql {
namespace metadata {

// ============================================================================
// Helper: Key-Value pair for metadata tables
// ============================================================================

struct MetadataItem {
    std::string key;
    std::string value;
    std::string type;  // "string", "int", "hex", "bool"
};

// ============================================================================
// DB_INFO Table - Database information
// ============================================================================

inline std::vector<MetadataItem>& get_db_info_cache() {
    static std::vector<MetadataItem> cache;
    return cache;
}

inline void rebuild_db_info_cache() {
    auto& cache = get_db_info_cache();
    cache.clear();

    auto add_str = [&](const char* k, const std::string& v) {
        cache.push_back({k, v, "string"});
    };
    auto add_int = [&](const char* k, int64_t v) {
        cache.push_back({k, std::to_string(v), "int"});
    };
    auto add_hex = [&](const char* k, uint64_t v) {
        char buf[32];
        qsnprintf(buf, sizeof(buf), "0x%llX", (unsigned long long)v);
        cache.push_back({k, buf, "hex"});
    };
    auto add_bool = [&](const char* k, bool v) {
        cache.push_back({k, v ? "true" : "false", "bool"});
    };

    // Processor info
    add_str("processor", inf_get_procname().c_str());
    add_int("filetype", inf_get_filetype());
    add_int("ostype", inf_get_ostype());
    add_int("apptype", inf_get_apptype());

    // Address info
    add_hex("min_ea", inf_get_min_ea());
    add_hex("max_ea", inf_get_max_ea());
    add_hex("start_ea", inf_get_start_ea());
    add_hex("main_ea", inf_get_main());

    // Addressing
    add_int("cc_id", inf_get_cc_id());
    add_bool("is_32bit", !inf_is_64bit());
    add_bool("is_64bit", inf_is_64bit());
    add_bool("is_be", inf_is_be());

    // Database info
    add_int("database_change_count", inf_get_database_change_count());
    add_int("version", IDA_SDK_VERSION);
}

inline VTableDef define_db_info() {
    return table("db_info")
        .count([]() {
            rebuild_db_info_cache();
            return get_db_info_cache().size();
        })
        .column_text("key", [](size_t i) -> std::string {
            auto& cache = get_db_info_cache();
            return i < cache.size() ? cache[i].key : "";
        })
        .column_text("value", [](size_t i) -> std::string {
            auto& cache = get_db_info_cache();
            return i < cache.size() ? cache[i].value : "";
        })
        .column_text("type", [](size_t i) -> std::string {
            auto& cache = get_db_info_cache();
            return i < cache.size() ? cache[i].type : "";
        })
        .build();
}

// ============================================================================
// IDA_INFO Table - IDA analysis flags (from inf structure)
// ============================================================================

inline std::vector<MetadataItem>& get_ida_info_cache() {
    static std::vector<MetadataItem> cache;
    return cache;
}

inline void rebuild_ida_info_cache() {
    auto& cache = get_ida_info_cache();
    cache.clear();

    auto add_bool = [&](const char* k, bool v) {
        cache.push_back({k, v ? "1" : "0", "bool"});
    };
    auto add_int = [&](const char* k, int64_t v) {
        cache.push_back({k, std::to_string(v), "int"});
    };

    // Analysis flags
    add_bool("show_auto", inf_should_create_stkvars());  // approximate
    add_bool("show_void", inf_is_graph_view());
    add_bool("is_dll", inf_is_dll());
    add_bool("is_flat", inf_is_flat_off32());
    add_bool("wide_fids", inf_is_wide_high_byte_first());

    // Naming
    add_int("long_demnames", inf_get_long_demnames());
    add_int("short_demnames", inf_get_short_demnames());
    add_int("demnames", inf_get_demnames());

    // Limits
    add_int("max_autoname_len", inf_get_max_autoname_len());
}

inline VTableDef define_ida_info() {
    return table("ida_info")
        .count([]() {
            rebuild_ida_info_cache();
            return get_ida_info_cache().size();
        })
        .column_text("key", [](size_t i) -> std::string {
            auto& cache = get_ida_info_cache();
            return i < cache.size() ? cache[i].key : "";
        })
        .column_text("value", [](size_t i) -> std::string {
            auto& cache = get_ida_info_cache();
            return i < cache.size() ? cache[i].value : "";
        })
        .column_text("type", [](size_t i) -> std::string {
            auto& cache = get_ida_info_cache();
            return i < cache.size() ? cache[i].type : "";
        })
        .build();
}

// ============================================================================
// Metadata Registry
// ============================================================================

struct MetadataRegistry {
    VTableDef db_info;
    VTableDef ida_info;

    MetadataRegistry()
        : db_info(define_db_info())
        , ida_info(define_ida_info())
    {}

    void register_all(xsql::Database& db) {
        db.register_table("ida_db_info", &db_info);
        db.create_table("db_info", "ida_db_info");

        db.register_table("ida_ida_info", &ida_info);
        db.create_table("ida_info", "ida_ida_info");
    }
};

} // namespace metadata
} // namespace idasql

```

`src/lib/include/idasql/platform.hpp`:

```hpp
/**
 * platform.hpp - Platform fixups for IDA SDK compatibility
 *
 * macOS Mach kernel headers define processor_t and token_t as integer
 * typedefs (via <mach/machine_types.h>), which conflict with IDA SDK's
 * struct processor_t. Since #undef cannot remove typedefs, we redirect
 * them via #define before any system headers are included.
 *
 * Usage (every header or .cpp that includes both system and IDA headers):
 *
 *   #include <idasql/platform.hpp>        // FIRST: redirect macOS typedefs
 *   #include <system_or_library_header>    // system headers see harmless names
 *   #include <idasql/platform_undef.hpp>  // clean up before IDA headers
 *   #include <ida.hpp>                     // IDA sees clean namespace
 */

#pragma once

#ifdef __APPLE__
#define processor_t __mach_processor_t
#define token_t __mach_token_t
#endif

```

`src/lib/include/idasql/platform_undef.hpp`:

```hpp
/**
 * platform_undef.hpp - Undo platform.hpp redirects before IDA headers
 *
 * Include this after all system/library headers and before any IDA SDK
 * headers. See platform.hpp for details.
 *
 * This file is intentionally NOT guarded with #pragma once so it can
 * be included multiple times (each header pair needs its own cleanup).
 */

#ifdef __APPLE__
#undef processor_t
#undef token_t
#endif

```

`src/lib/include/idasql/search_bytes.hpp`:

```hpp
// Copyright (c) 2025 Elias Bachaalany
// SPDX-License-Identifier: MIT

/**
 * search_bytes.hpp - Binary pattern search functions for IDASQL
 *
 * Provides search_bytes() and search_first() functions for finding byte patterns.
 *
 * Pattern syntax (IDA native):
 *   - "48 8B 05"       - Exact bytes (hex, space-separated)
 *   - "48 ? 05"        - ? = any byte wildcard (whole byte only)
 *   - "48 ?? 05"       - ?? = same as ? (any byte)
 *   - "(01 02 03)"     - Alternatives (match any of these bytes)
 *
 * SQL usage:
 *   SELECT search_bytes('48 8B ? 00');                    -- Returns JSON array
 *   SELECT search_bytes('48 8B ? 00', 0x401000, 0x402000); -- With range
 *   SELECT search_first('48 8B ? 00');                    -- Returns first address
 *
 * Unlike Binary Ninja:
 *   - No nibble wildcards (? always means full byte)
 *   - No regex support
 *   - Supports alternatives like (01 02 03)
 */

#pragma once

#include <idasql/platform.hpp>

#include <xsql/database.hpp>
#include <xsql/functions.hpp>
#include <xsql/json.hpp>
#include <string>
#include <vector>
#include <sstream>
#include <iomanip>

#include <idasql/platform_undef.hpp>

// IDA SDK
#include <ida.hpp>
#include <idp.hpp>
#include <bytes.hpp>
#include <kernwin.hpp>
#include <segment.hpp>

namespace idasql {
namespace search {

// ============================================================================
// Search Result
// ============================================================================

struct ByteSearchResult {
    ea_t address;
    std::vector<uchar> matched_bytes;
    std::string matched_hex;
};

// ============================================================================
// Binary Pattern Search Implementation
// ============================================================================

/**
 * Find all matches for a byte pattern in the given range.
 *
 * @param pattern   Pattern string like "48 8B ? 00" or "48 ?? (01 02) 00"
 * @param start_ea  Start of search range (default: inf_get_min_ea())
 * @param end_ea    End of search range (default: inf_get_max_ea())
 * @param results   Vector to store results
 * @param max_results Maximum results to return (0 = unlimited)
 * @return Number of matches found
 */
inline size_t find_byte_pattern(
    const char* pattern,
    ea_t start_ea,
    ea_t end_ea,
    std::vector<ByteSearchResult>& results,
    size_t max_results = 0)
{
    if (!pattern || !*pattern) return 0;

    // Parse the pattern string
    compiled_binpat_vec_t binpat;
    qstring errbuf;

    if (!parse_binpat_str(&binpat, start_ea, pattern, 16, PBSENC_DEF1BPU, &errbuf)) {
        // Pattern parse failed
        return 0;
    }

    if (binpat.empty()) return 0;

    // Get pattern length for reading matched bytes
    size_t pattern_len = binpat[0].bytes.size();

    ea_t ea = start_ea;
    size_t count = 0;

    while (ea < end_ea) {
        ea_t found = bin_search(ea, end_ea, binpat, BIN_SEARCH_FORWARD);
        if (found == BADADDR) break;

        ByteSearchResult result;
        result.address = found;

        // Read matched bytes
        result.matched_bytes.resize(pattern_len);
        for (size_t i = 0; i < pattern_len; i++) {
            result.matched_bytes[i] = get_byte(found + i);
        }

        // Build hex string
        std::ostringstream hex;
        hex << std::hex << std::setfill('0');
        for (size_t i = 0; i < pattern_len; i++) {
            if (i > 0) hex << " ";
            hex << std::setw(2) << static_cast<int>(result.matched_bytes[i]);
        }
        result.matched_hex = hex.str();

        results.push_back(std::move(result));
        count++;

        if (max_results > 0 && count >= max_results) break;

        ea = found + 1;  // Move past this match
    }

    return count;
}

/**
 * Find first match for a byte pattern.
 *
 * @return Address of first match, or BADADDR if not found
 */
inline ea_t find_first_pattern(const char* pattern, ea_t start_ea, ea_t end_ea) {
    if (!pattern || !*pattern) return BADADDR;

    compiled_binpat_vec_t binpat;
    qstring errbuf;

    if (!parse_binpat_str(&binpat, start_ea, pattern, 16, PBSENC_DEF1BPU, &errbuf)) {
        return BADADDR;
    }

    if (binpat.empty()) return BADADDR;

    return bin_search(start_ea, end_ea, binpat, BIN_SEARCH_FORWARD);
}

// ============================================================================
// SQL Function Registration
// ============================================================================

// search_bytes(pattern) - Returns JSON array of all matches
static void sql_search_bytes_1(xsql::FunctionContext& ctx, int argc, xsql::FunctionArg* argv) {
    if (argc < 1) {
        ctx.result_error("search_bytes requires pattern argument");
        return;
    }

    const char* pattern = argv[0].as_c_str();
    if (!pattern) {
        ctx.result_error("Invalid pattern");
        return;
    }

    ea_t start_ea = inf_get_min_ea();
    ea_t end_ea = inf_get_max_ea();

    std::vector<ByteSearchResult> results;
    find_byte_pattern(pattern, start_ea, end_ea, results);

    // Build JSON array
    xsql::json arr = xsql::json::array();
    for (const auto& r : results) {
        arr.push_back({
            {"address", r.address},
            {"matched_hex", r.matched_hex},
            {"size", r.matched_bytes.size()}
        });
    }

    std::string result = arr.dump();
    ctx.result_text(result);
}

// search_bytes(pattern, start, end) - Returns JSON array within range
static void sql_search_bytes_3(xsql::FunctionContext& ctx, int argc, xsql::FunctionArg* argv) {
    if (argc < 3) {
        ctx.result_error("search_bytes requires (pattern, start, end) arguments");
        return;
    }

    const char* pattern = argv[0].as_c_str();
    if (!pattern) {
        ctx.result_error("Invalid pattern");
        return;
    }

    ea_t start_ea = static_cast<ea_t>(argv[1].as_int64());
    ea_t end_ea = static_cast<ea_t>(argv[2].as_int64());

    std::vector<ByteSearchResult> results;
    find_byte_pattern(pattern, start_ea, end_ea, results);

    // Build JSON array
    xsql::json arr = xsql::json::array();
    for (const auto& r : results) {
        arr.push_back({
            {"address", r.address},
            {"matched_hex", r.matched_hex},
            {"size", r.matched_bytes.size()}
        });
    }

    std::string result = arr.dump();
    ctx.result_text(result);
}

// search_first(pattern) - Returns first match address
static void sql_search_first_1(xsql::FunctionContext& ctx, int argc, xsql::FunctionArg* argv) {
    if (argc < 1) {
        ctx.result_error("search_first requires pattern argument");
        return;
    }

    const char* pattern = argv[0].as_c_str();
    if (!pattern) {
        ctx.result_error("Invalid pattern");
        return;
    }

    ea_t result = find_first_pattern(pattern, inf_get_min_ea(), inf_get_max_ea());
    if (result != BADADDR) {
        ctx.result_int64(static_cast<int64_t>(result));
    } else {
        ctx.result_null();
    }
}

// search_first(pattern, start, end) - Returns first match in range
static void sql_search_first_3(xsql::FunctionContext& ctx, int argc, xsql::FunctionArg* argv) {
    if (argc < 3) {
        ctx.result_error("search_first requires (pattern, start, end) arguments");
        return;
    }

    const char* pattern = argv[0].as_c_str();
    if (!pattern) {
        ctx.result_error("Invalid pattern");
        return;
    }

    ea_t start_ea = static_cast<ea_t>(argv[1].as_int64());
    ea_t end_ea = static_cast<ea_t>(argv[2].as_int64());

    ea_t result = find_first_pattern(pattern, start_ea, end_ea);
    if (result != BADADDR) {
        ctx.result_int64(static_cast<int64_t>(result));
    } else {
        ctx.result_null();
    }
}

/**
 * Register all search_bytes SQL functions.
 */
inline bool register_search_bytes(xsql::Database& db) {
    db.register_function("search_bytes", 1, xsql::ScalarFn(sql_search_bytes_1));
    db.register_function("search_bytes", 3, xsql::ScalarFn(sql_search_bytes_3));
    db.register_function("search_first", 1, xsql::ScalarFn(sql_search_first_1));
    db.register_function("search_first", 3, xsql::ScalarFn(sql_search_first_3));
    return true;
}

} // namespace search
} // namespace idasql

```

`src/lib/include/idasql/vtable.hpp`:

```hpp
/**
 * vtable.hpp - SQLite Virtual Table framework for IDA
 *
 * This file re-exports the xsql virtual table framework types into the idasql
 * namespace for convenience.
 *
 * Two table patterns are available:
 *
 * 1. Index-based tables (for IDA's indexed access like getn_func):
 *
 *   auto funcs_table = idasql::table("funcs")
 *       .count([]() { return get_func_qty(); })
 *       .column_int64("address", [](size_t i) { return getn_func(i)->start_ea; })
 *       .build();
 *
 * 2. Cached tables (for enumeration-based data, cache freed after query):
 *
 *   auto xrefs_table = idasql::cached_table<XrefInfo>("xrefs")
 *       .estimate_rows([]() { return get_func_qty() * 10; })
 *       .cache_builder([](auto& cache) { ... populate ... })
 *       .column_int64("from_ea", [](const XrefInfo& r) { return r.from_ea; })
 *       .build();
 *
 * 3. Generator tables (for expensive full scans that must be lazy):
 *
 *   auto ctree_table = idasql::generator_table<CtreeItem>("ctree")
 *       .estimate_rows([]() { return get_func_qty() * 50; })
 *       .generator([]() { return std::make_unique<CtreeGenerator>(); })
 *       .column_int64("func_addr", [](const CtreeItem& r) { return r.func_addr; })
 *       .build();
 */

#pragma once

#include <xsql/xsql.hpp>

namespace idasql {

// ============================================================================
// Re-export xsql types into idasql namespace
// ============================================================================

// Column types
using xsql::ColumnType;
using xsql::column_type_sql;

// Column definition (index-based)
using xsql::ColumnDef;

// Virtual table definition (index-based)
using xsql::VTableDef;

// SQLite virtual table implementation
using xsql::Vtab;
using xsql::Cursor;

// Registration helpers
using xsql::register_vtable;
using xsql::create_vtable;

// Index-based table builder
using xsql::VTableBuilder;
using xsql::table;

// ============================================================================
// Cached Table API (query-scoped cache, freed after query)
// ============================================================================

// Row iterator for constraint pushdown
using xsql::RowIterator;
using xsql::FilterDef;
using xsql::FILTER_NONE;

// Cached column definition (row-typed)
template<typename RowData>
using CachedColumnDef = xsql::CachedColumnDef<RowData>;

// Cached table definition
template<typename RowData>
using CachedTableDef = xsql::CachedTableDef<RowData>;

// Cached cursor (owns cache)
template<typename RowData>
using CachedCursor = xsql::CachedCursor<RowData>;

// Cached table registration
template<typename RowData>
inline bool register_cached_vtable(sqlite3* db, const char* module_name,
                                   const CachedTableDef<RowData>* def) {
    return xsql::register_cached_vtable(db, module_name, def);
}

// Cached table builder
template<typename RowData>
using CachedTableBuilder = xsql::CachedTableBuilder<RowData>;

template<typename RowData>
inline CachedTableBuilder<RowData> cached_table(const char* name) {
    return xsql::cached_table<RowData>(name);
}

// ============================================================================
// Generator Table API (streaming, no full-cache materialization)
// ============================================================================

template<typename RowData>
using Generator = xsql::Generator<RowData>;

template<typename RowData>
using GeneratorTableDef = xsql::GeneratorTableDef<RowData>;

template<typename RowData>
using GeneratorCursor = xsql::GeneratorCursor<RowData>;

template<typename RowData>
inline bool register_generator_vtable(sqlite3* db, const char* module_name,
                                      const GeneratorTableDef<RowData>* def) {
    return xsql::register_generator_vtable(db, module_name, def);
}

template<typename RowData>
using GeneratorTableBuilder = xsql::GeneratorTableBuilder<RowData>;

template<typename RowData>
inline GeneratorTableBuilder<RowData> generator_table(const char* name) {
    return xsql::generator_table<RowData>(name);
}

} // namespace idasql

// ============================================================================
// Convenience Macros (namespace-qualified for idasql)
// ============================================================================

#define COLUMN_INT64(name, getter) \
    .column_int64(#name, getter)

#define COLUMN_INT(name, getter) \
    .column_int(#name, getter)

#define COLUMN_TEXT(name, getter) \
    .column_text(#name, getter)

#define COLUMN_DOUBLE(name, getter) \
    .column_double(#name, getter)

```

`src/lib/include/idasql/vtable_policy.hpp`:

```hpp
/**
 * ida_vtable_policy.hpp - Policy and configuration system for IDASQL
 *
 * This allows passing options to virtual tables via:
 *   1. Module arguments: CREATE VIRTUAL TABLE funcs USING ida_funcs(cache=off)
 *   2. Global configuration via SQL function: SELECT idasql_config('cache', 'off')
 *   3. Per-session settings stored in a config table
 *
 * Supported policies:
 *   - cache: 'on'|'off' - Enable/disable result caching
 *   - undo: 'on'|'off' - Create undo points for modifications
 *   - batch: 'on'|'off' - Batch multiple operations into one undo point
 */

#pragma once

#include <xsql/database.hpp>
#include <xsql/functions.hpp>
#include <string>
#include <unordered_map>
#include <mutex>

namespace idasql {
namespace policy {

// ============================================================================
// Policy Values
// ============================================================================

enum class CachePolicy {
    Off,        // No caching, always fetch live data
    Session,    // Cache for the duration of SQL statement
    Persistent  // Cache until invalidated
};

enum class UndoPolicy {
    Off,        // No undo points
    PerRow,     // Undo point per row modification
    PerStatement // One undo point per SQL statement (recommended)
};

// ============================================================================
// Global Configuration
// ============================================================================

struct IdasqlConfig {
    CachePolicy cache = CachePolicy::Off;          // Default: live data
    UndoPolicy undo = UndoPolicy::PerStatement;    // Default: one undo per statement
    bool batch_operations = true;                   // Batch ops under one undo
    bool verbose = false;                           // Debug output

    static IdasqlConfig& instance() {
        static IdasqlConfig config;
        return config;
    }

private:
    IdasqlConfig() = default;
};

// ============================================================================
// Configuration Parsing from Module Arguments
// ============================================================================

struct ModuleOptions {
    CachePolicy cache = CachePolicy::Off;
    UndoPolicy undo = UndoPolicy::PerStatement;

    // Parse from CREATE VIRTUAL TABLE ... USING module(key=value, ...)
    static ModuleOptions parse(int argc, const char* const* argv) {
        ModuleOptions opts;

        // argv[0] = module name, argv[1] = database name, argv[2] = table name
        // argv[3..] = additional arguments
        for (int i = 3; i < argc; ++i) {
            std::string arg = argv[i];
            size_t eq = arg.find('=');
            if (eq == std::string::npos) continue;

            std::string key = arg.substr(0, eq);
            std::string val = arg.substr(eq + 1);

            // Trim quotes if present
            if (val.size() >= 2 && val.front() == '\'' && val.back() == '\'') {
                val = val.substr(1, val.size() - 2);
            }

            if (key == "cache") {
                if (val == "off" || val == "0" || val == "false") {
                    opts.cache = CachePolicy::Off;
                } else if (val == "session") {
                    opts.cache = CachePolicy::Session;
                } else if (val == "on" || val == "1" || val == "true" || val == "persistent") {
                    opts.cache = CachePolicy::Persistent;
                }
            } else if (key == "undo") {
                if (val == "off" || val == "0" || val == "false") {
                    opts.undo = UndoPolicy::Off;
                } else if (val == "row" || val == "perrow") {
                    opts.undo = UndoPolicy::PerRow;
                } else if (val == "on" || val == "1" || val == "true" || val == "statement") {
                    opts.undo = UndoPolicy::PerStatement;
                }
            }
        }

        return opts;
    }
};

// ============================================================================
// SQL Configuration Function
// ============================================================================

// Register: SELECT idasql_config('key', 'value') to set
// Register: SELECT idasql_config('key') to get
inline void idasql_config_func(xsql::FunctionContext& ctx, int argc, xsql::FunctionArg* argv) {
    if (argc < 1) {
        ctx.result_error("idasql_config requires at least 1 argument");
        return;
    }

    const char* key = argv[0].as_c_str();
    if (!key) {
        ctx.result_null();
        return;
    }

    auto& config = IdasqlConfig::instance();

    // Setter mode
    if (argc >= 2) {
        const char* val = argv[1].as_c_str();
        if (!val) val = "";

        if (strcmp(key, "cache") == 0) {
            if (strcmp(val, "off") == 0 || strcmp(val, "0") == 0) {
                config.cache = CachePolicy::Off;
            } else if (strcmp(val, "session") == 0) {
                config.cache = CachePolicy::Session;
            } else {
                config.cache = CachePolicy::Persistent;
            }
            ctx.result_text(val);
        } else if (strcmp(key, "undo") == 0) {
            if (strcmp(val, "off") == 0 || strcmp(val, "0") == 0) {
                config.undo = UndoPolicy::Off;
            } else if (strcmp(val, "row") == 0) {
                config.undo = UndoPolicy::PerRow;
            } else {
                config.undo = UndoPolicy::PerStatement;
            }
            ctx.result_text(val);
        } else if (strcmp(key, "verbose") == 0) {
            config.verbose = (strcmp(val, "on") == 0 || strcmp(val, "1") == 0);
            ctx.result_int(config.verbose ? 1 : 0);
        } else {
            ctx.result_error("Unknown config key");
        }
        return;
    }

    // Getter mode
    if (strcmp(key, "cache") == 0) {
        const char* val = "off";
        if (config.cache == CachePolicy::Session) val = "session";
        else if (config.cache == CachePolicy::Persistent) val = "persistent";
        ctx.result_text_static(val);
    } else if (strcmp(key, "undo") == 0) {
        const char* val = "statement";
        if (config.undo == UndoPolicy::Off) val = "off";
        else if (config.undo == UndoPolicy::PerRow) val = "row";
        ctx.result_text_static(val);
    } else if (strcmp(key, "verbose") == 0) {
        ctx.result_int(config.verbose ? 1 : 0);
    } else {
        ctx.result_null();
    }
}

// Register the config function with SQLite
inline bool register_config_function(xsql::Database& db) {
    return db.register_function("idasql_config", -1, xsql::ScalarFn(idasql_config_func)) == SQLITE_OK;
}

// ============================================================================
// Configuration Table (Alternative approach)
// ============================================================================

inline bool create_config_table(xsql::Database& db) {
    const char* sql = R"(
        CREATE TABLE IF NOT EXISTS idasql_settings (
            key TEXT PRIMARY KEY,
            value TEXT,
            description TEXT
        );

        INSERT OR IGNORE INTO idasql_settings VALUES
            ('cache', 'off', 'Cache policy: off, session, persistent'),
            ('undo', 'statement', 'Undo policy: off, row, statement'),
            ('verbose', '0', 'Debug output: 0 or 1');
    )";

    return db.exec(sql) == SQLITE_OK;
}

// Sync config from table to memory
inline bool load_config_from_table(xsql::Database& db) {
    auto& config = IdasqlConfig::instance();

    auto result = db.query("SELECT key, value FROM idasql_settings");
    if (!result.ok()) return false;

    for (const auto& row : result) {
        const auto& key = row[0];
        const auto& val = row[1];

        if (key == "cache") {
            if (val == "off") config.cache = CachePolicy::Off;
            else if (val == "session") config.cache = CachePolicy::Session;
            else config.cache = CachePolicy::Persistent;
        } else if (key == "undo") {
            if (val == "off") config.undo = UndoPolicy::Off;
            else if (val == "row") config.undo = UndoPolicy::PerRow;
            else config.undo = UndoPolicy::PerStatement;
        } else if (key == "verbose") {
            config.verbose = (val == "1");
        }
    }

    return true;
}

// ============================================================================
// Initialization Helper
// ============================================================================

inline bool init_policy_system(xsql::Database& db) {
    bool ok = true;
    ok = ok && register_config_function(db);
    ok = ok && create_config_table(db);
    ok = ok && load_config_from_table(db);
    return ok;
}

} // namespace policy
} // namespace idasql

```

`src/plugin/CMakeLists.txt`:

```txt
# idasql Plugin - IDA Pro plugin for SQL queries
# Built as part of the main idasql project

# Plugin sources
ida_add_plugin(idasql_plugin
    SOURCES main.cpp
)

# Output as idasql.dll (not idasql_plugin.dll)
set_target_properties(idasql_plugin PROPERTIES OUTPUT_NAME "idasql")

# Include directories and link dependencies
target_include_directories(idasql_plugin PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}/../lib/include
)
target_link_libraries(idasql_plugin PRIVATE xsql::xsql)

# USE_DANGEROUS_FUNCTIONS: Disable IDA's safe function macros (pro.h: strcpy, sprintf, getenv, etc.)
# USE_STANDARD_FILE_FUNCTIONS: Disable IDA's file function macros (fpro.h: fgetc, fputc, etc.)
#   Required for std::getenv and file I/O in agent_settings.hpp
target_compile_definitions(idasql_plugin PRIVATE
    USE_DANGEROUS_FUNCTIONS
    USE_STANDARD_FILE_FUNCTIONS
)

# Windows-specific settings
if(WIN32)
    target_link_libraries(idasql_plugin PRIVATE ws2_32)
    # WIN32_LEAN_AND_MEAN: Exclude rarely-used Windows headers
    # NOMINMAX: Prevent Windows.h from defining min/max macros
    target_compile_definitions(idasql_plugin PRIVATE
        WIN32_LEAN_AND_MEAN
        NOMINMAX
    )
endif()

# Hex-Rays support
target_compile_definitions(idasql_plugin PRIVATE USE_HEXRAYS)

# ============================================================================
# AI Agent support (from parent project)
# ============================================================================

if(IDASQL_WITH_AI_AGENT)
    # Add ai_agent and mcp_server source files
    target_sources(idasql_plugin PRIVATE
        ${CMAKE_CURRENT_SOURCE_DIR}/../common/ai_agent.cpp
        ${CMAKE_CURRENT_SOURCE_DIR}/../common/mcp_server.cpp
    )
    target_include_directories(idasql_plugin PRIVATE
        ${CMAKE_CURRENT_SOURCE_DIR}/../common
        ${CMAKE_CURRENT_SOURCE_DIR}/../../external/libagents/external/fastmcpp/include
    )

    # Link against libagents and fastmcpp
    target_link_libraries(idasql_plugin PRIVATE libagents fastmcpp_core)

    # Define the feature flag
    target_compile_definitions(idasql_plugin PRIVATE IDASQL_HAS_AI_AGENT)

    # Add dependency on prompt generation
    if(TARGET generate_prompt)
        add_dependencies(idasql_plugin generate_prompt)
    endif()

    message(STATUS "idasql_plugin: AI agent support enabled")
endif()

# ============================================================================
# HTTP Server support
# ============================================================================

target_sources(idasql_plugin PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}/../common/http_server.cpp
)
target_include_directories(idasql_plugin PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}/../common
)
target_compile_definitions(idasql_plugin PRIVATE XSQL_HAS_THINCLIENT)

# cpp-httplib: provided transitively by xsql::xsql when XSQL_WITH_THINCLIENT=ON.
# Only fetch standalone if the target doesn't already exist.
if(NOT TARGET httplib)
    include(FetchContent)
    FetchContent_Declare(
        cpp_httplib
        GIT_REPOSITORY https://github.com/yhirose/cpp-httplib.git
        GIT_TAG v0.15.3
    )
    FetchContent_MakeAvailable(cpp_httplib)
    target_include_directories(idasql_plugin PRIVATE ${cpp_httplib_SOURCE_DIR})
endif()

```

`src/plugin/main.cpp`:

```cpp
/**
 * idasql_plugin - IDA plugin providing SQL interface to IDA databases
 *
 * The plugin auto-installs a CLI (command line interface) on load.
 * Use dot commands: .http, .mcp, .help
 *
 * The plugin is hidden from the Edit > Plugins menu (PLUGIN_HIDE).
 * See plugin_control.hpp for run() arg codes.
 */

// =============================================================================
// CRITICAL: Include order matters on Windows!
// 1. nlohmann/json before IDA headers (IDA macros can interfere)
// 2. Standard library headers
// 3. IDA headers
//
// Note: USE_DANGEROUS_FUNCTIONS and USE_STANDARD_FILE_FUNCTIONS are defined
// via CMakeLists.txt to disable IDA's safe function macros that conflict
// with MSVC standard library (__msvc_filebuf.hpp uses fgetc/fputc).
// =============================================================================

#include <idasql/platform.hpp>

// Standard library includes
#include <memory>
#include <string>
#include <functional>

// Platform-specific include order:
// - Windows: json before IDA (IDA poisons stdlib functions)
// - macOS/Linux: IDA before json
#include <idasql/platform_undef.hpp>

#ifdef _WIN32
// Include shlobj.h BEFORE IDA headers: agent_settings.hpp pulls in <shlobj.h>
// which defines CM_MASK/CM_STATE enums in shobjidl_core.h. IDA's typeinf.hpp
// also defines CM_MASK (const uchar). Including Windows headers first lets
// IDA's definition shadow the Windows enum without conflict.
#include <shlobj.h>
#include <xsql/json.hpp>
#include <ida.hpp>
#include <idp.hpp>
#include <loader.hpp>
#include <kernwin.hpp>
#include <idasql/database.hpp>
#else
#include <ida.hpp>
#include <idp.hpp>
#include <loader.hpp>
#include <kernwin.hpp>
#include <idasql/database.hpp>
#include <xsql/json.hpp>
#endif

// IDASQL CLI (command line interface)
#include "../common/idasql_cli.hpp"

// Plugin control codes
#include "../common/plugin_control.hpp"

// Version info
#include "../common/idasql_version.hpp"

// MCP server (when AI agent is enabled)
#ifdef IDASQL_HAS_AI_AGENT
#include "../common/mcp_server.hpp"
#include "../common/ai_agent.hpp"
#endif

// HTTP server for .http REPL command
#include "../common/http_server.hpp"

//=============================================================================
// IDA execute_sync wrapper
//=============================================================================

namespace {

struct query_request_t : public exec_request_t
{
    idasql::QueryEngine* engine;
    std::string sql;
    idasql::QueryResult result;

    query_request_t(idasql::QueryEngine* e, const std::string& s)
        : engine(e), sql(s) {}

    virtual ssize_t idaapi execute() override
    {
        result = engine->query(sql);
        return result.success ? 0 : -1;
    }
};

} // anonymous namespace

//=============================================================================
// IDA Plugin
//=============================================================================

struct idasql_plugmod_t : public plugmod_t
{
    std::unique_ptr<idasql::QueryEngine> engine_;
    std::unique_ptr<idasql::IdasqlCLI> cli_;

#ifdef IDASQL_HAS_AI_AGENT
    idasql::IDAMCPServer mcp_server_;
    std::unique_ptr<idasql::AIAgent> mcp_agent_;  // AI agent for MCP
#endif

    idasql::IDAHTTPServer http_server_;

    idasql_plugmod_t()
    {
        engine_ = std::make_unique<idasql::QueryEngine>();
        if (engine_->is_valid()) {
            msg("IDASQL v" IDASQL_VERSION_STRING ": Query engine initialized\n");

            // SQL executor that uses execute_sync for thread safety
            auto sql_executor = [this](const std::string& sql) -> std::string {
                query_request_t req(engine_.get(), sql);
                execute_sync(req, MFF_WRITE);
                if (req.result.success) {
                    return req.result.to_string();
                } else {
                    return "Error: " + req.result.error;
                }
            };

            // Create CLI with execute_sync wrapper for thread safety
            cli_ = std::make_unique<idasql::IdasqlCLI>(sql_executor);

#ifdef IDASQL_HAS_AI_AGENT
            // Setup MCP callbacks
            cli_->session().callbacks().mcp_status = [this]() -> std::string {
                if (mcp_server_.is_running()) {
                    return idasql::format_mcp_status(mcp_server_.port(), true);
                } else {
                    // Auto-start if not running
                    return start_mcp_server();
                }
            };

            cli_->session().callbacks().mcp_start = [this](int port, const std::string& bind_addr) -> std::string {
                return start_mcp_server(port, bind_addr);
            };

            cli_->session().callbacks().mcp_stop = [this]() -> std::string {
                if (mcp_server_.is_running()) {
                    mcp_server_.stop();
                    mcp_agent_.reset();
                    return "MCP server stopped";
                } else {
                    return "MCP server not running";
                }
            };
#endif

            // Setup HTTP server callbacks
            cli_->session().callbacks().http_status = [this]() -> std::string {
                if (http_server_.is_running()) {
                    return idasql::format_http_status(http_server_.port(), true);
                } else {
                    return "HTTP server not running\nUse '.http start' to start\n";
                }
            };

            cli_->session().callbacks().http_start = [this](int port, const std::string& bind_addr) -> std::string {
                return start_http_server(port, bind_addr);
            };

            cli_->session().callbacks().http_stop = [this]() -> std::string {
                if (http_server_.is_running()) {
                    http_server_.stop();
                    return "HTTP server stopped";
                } else {
                    return "HTTP server not running";
                }
            };

            // Auto-install CLI so it's available immediately
            // User can still toggle it off with run(23) if desired
            cli_->install();
        } else {
            msg("IDASQL: Failed to init engine: %s\n", engine_->error().c_str());
        }
    }

#ifdef IDASQL_HAS_AI_AGENT
    std::string start_mcp_server(int req_port = 0, const std::string& bind_addr = "127.0.0.1")
    {
        if (mcp_server_.is_running()) {
            return idasql::format_mcp_status(mcp_server_.port(), true);
        }

        // SQL executor that uses execute_sync for thread safety
        auto sql_executor = [this](const std::string& sql) -> std::string {
            query_request_t req(engine_.get(), sql);
            execute_sync(req, MFF_WRITE);
            if (req.result.success) {
                return req.result.to_string();
            } else {
                return "Error: " + req.result.error;
            }
        };

        // Create AI agent for MCP (runs on MCP thread, SQL via execute_sync)
        mcp_agent_ = std::make_unique<idasql::AIAgent>(sql_executor);
        mcp_agent_->start();

        // MCP ask callback - agent runs on MCP thread
        idasql::AskCallback ask_cb = [this](const std::string& question) -> std::string {
            if (!mcp_agent_) return "Error: AI agent not available";
            return mcp_agent_->query(question);
        };

        // Start MCP server
        int port = mcp_server_.start(req_port, sql_executor, ask_cb, bind_addr);
        if (port <= 0) {
            mcp_agent_.reset();
            return "Error: Failed to start MCP server";
        }

        return idasql::format_mcp_info(port, true);
    }
#endif

    std::string start_http_server(int req_port = 0, const std::string& bind_addr = "127.0.0.1")
    {
        if (http_server_.is_running()) {
            return idasql::format_http_status(http_server_.port(), true);
        }

        // SQL executor that uses execute_sync for thread safety and returns JSON
        idasql::HTTPQueryCallback sql_cb = [this](const std::string& sql) -> std::string {
            query_request_t req(engine_.get(), sql);
            execute_sync(req, MFF_WRITE);

            xsql::json j = {{"success", req.result.success}};
            if (req.result.success) {
                j["columns"] = req.result.columns;
                xsql::json rows = xsql::json::array();
                for (const auto& row : req.result.rows) {
                    rows.push_back(row.values);
                }
                j["rows"] = rows;
                j["row_count"] = req.result.rows.size();
            } else {
                j["error"] = req.result.error;
            }
            return j.dump();
        };

        // Start HTTP server, no queue (plugin mode)
        int port = http_server_.start(req_port, sql_cb, bind_addr);
        if (port <= 0) {
            return "Error: Failed to start HTTP server";
        }

        return idasql::format_http_info(port, "Type '.http stop' to stop the server.");
    }

    ~idasql_plugmod_t()
    {
#ifdef IDASQL_HAS_AI_AGENT
        // Stop MCP server before destroying engine
        if (mcp_server_.is_running()) {
            mcp_server_.stop();
        }
        mcp_agent_.reset();
#endif
        // Stop HTTP server before destroying engine
        if (http_server_.is_running()) {
            http_server_.stop();
        }
        if (cli_) cli_->uninstall();
        engine_.reset();
        msg("IDASQL: Plugin terminated\n");
    }

    virtual bool idaapi run(size_t arg) override
    {
        using namespace idasql;

        switch (arg) {
            case 0:
                msg("IDASQL v" IDASQL_VERSION_STRING " - SQL interface for IDA database\n");
                msg("Use dot commands: .http, .mcp, .help\n");
                return true;

            case PLUGIN_ARG_TOGGLE_CLI:
                if (cli_) {
                    if (cli_->is_installed()) {
                        cli_->uninstall();
                    } else {
                        cli_->install();
                    }
                }
                return true;

            default:
                return false;
        }
    }
};

//=============================================================================
// Plugin Entry Points
//=============================================================================

static plugmod_t* idaapi init()
{
    // Skip loading when running under idalib (e.g., idasql CLI)
    if (is_ida_library()) {
        msg("IDASQL: Running under idalib, plugin skipped\n");
        return nullptr;
    }

    return new idasql_plugmod_t();
}

plugin_t PLUGIN =
{
    IDP_INTERFACE_VERSION,
    PLUGIN_MULTI | PLUGIN_HIDE,
    init,
    nullptr,
    nullptr,
    "IDASQL - SQL interface for IDA database",
    "IDASQL Plugin\n"
    "\n"
    "Auto-installs CLI on load. Use dot commands:\n"
    "  .http start/stop  - HTTP REST server\n"
    "  .mcp start/stop   - MCP server\n"
    "  .help             - Show all commands\n"
    "\n"
    "run(23): Toggle CLI (command line interface)",
    "IDASQL",
    ""
};

```