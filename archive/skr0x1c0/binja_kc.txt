Project Path: arc_skr0x1c0_binja_kc_4yv23v0h

Source Tree:

```txt
arc_skr0x1c0_binja_kc_4yv23v0h
├── CMakeLists.txt
├── LICENSE
├── README.md
├── cmake
│   └── Modules
│       └── FindLLVM.cmake
├── common
│   ├── CMakeLists.txt
│   ├── include
│   │   └── binja
│   │       ├── macho
│   │       │   └── macho.h
│   │       ├── types
│   │       │   ├── errors.h
│   │       │   └── uuid.h
│   │       └── utils
│   │           ├── binary_view.h
│   │           ├── debug.h
│   │           ├── demangle.h
│   │           ├── interval_map.h
│   │           ├── log.h
│   │           ├── settings.h
│   │           ├── span_reader.h
│   │           └── strconv.h
│   └── src
│       ├── macho
│       │   └── macho.cpp
│       └── utils
│           ├── binary_view.cpp
│           ├── demangle.cpp
│           ├── settings.cpp
│           ├── span_reader.cpp
│           └── strconv.cpp
├── debuginfo
│   ├── CMakeLists.txt
│   ├── include
│   │   └── binja
│   │       └── debuginfo
│   │           ├── debug.h
│   │           ├── dsym.h
│   │           ├── dwarf.h
│   │           ├── dwarf_task.h
│   │           ├── errors.h
│   │           ├── function.h
│   │           ├── macho_task.h
│   │           ├── name_index.h
│   │           ├── plugin_dsym.h
│   │           ├── plugin_function_starts.h
│   │           ├── plugin_macho.h
│   │           ├── plugin_symtab.h
│   │           ├── slider.h
│   │           ├── source_finder.h
│   │           ├── types.h
│   │           └── variable.h
│   ├── src
│   │   ├── dsym.cpp
│   │   ├── dwarf.cpp
│   │   ├── dwarf_task.cpp
│   │   ├── function.cpp
│   │   ├── macho_task.cpp
│   │   ├── name_index.cpp
│   │   ├── plugin_dsym.cpp
│   │   ├── plugin_function_starts.cpp
│   │   ├── plugin_macho.cpp
│   │   ├── plugin_symtab.cpp
│   │   ├── slider.cpp
│   │   ├── source_finder.cpp
│   │   ├── types.cpp
│   │   └── variable.cpp
│   └── test
│       ├── CMakeLists.txt
│       └── main.cpp
├── external
│   ├── CMakeLists.txt
│   ├── fmtlib
│   ├── mio
│   ├── taskflow
│   └── zstd
├── kcview
│   ├── CMakeLists.txt
│   ├── include
│   │   └── binja
│   │       └── kcview
│   │           ├── errors.h
│   │           ├── lib.h
│   │           └── range.h
│   ├── src
│   │   └── lib.cpp
│   └── test
│       ├── CMakeLists.txt
│       └── main.cpp
├── main.cpp
└── resources
    └── screenshot.png

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.22)

include(CheckCXXCompilerFlag)

project(binja_kc)

list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake/Modules")

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_POSITION_INDEPENDENT_CODE ON)

add_compile_options(-Wall
        -Werror=return-type
        -Werror=switch
        -Wno-deprecated-declarations
        -Wno-unused-local-typedef
        -Wno-deprecated-enum-enum-conversion
        -Wno-deprecated-anon-enum-enum-conversion)
check_cxx_compiler_flag(-Wdeprecated-builtins COMPILER_HAS_DEPRECATED_BUILTINS)
if (${COMPILER_HAS_DEPRECATED_BUILTINS})
    add_compile_options(-Wno-deprecated-builtins)
endif ()

add_library(${PROJECT_NAME} SHARED main.cpp)


if (NOT BKC_INTERNAL_BUILD)
    find_path(
            BN_API_PATH
            NAMES binaryninjaapi.h
            HINTS $ENV{BN_API_PATH}
            REQUIRED)
    add_subdirectory(${BN_API_PATH} api)
    add_subdirectory(external)
endif ()

find_package(LLVM 15.0 REQUIRED
        COMPONENTS support object debugInfoDWARF demangle)

add_subdirectory(common)
add_subdirectory(debuginfo)
add_subdirectory(kcview)

target_link_libraries(${PROJECT_NAME} PRIVATE dwarf_debuginfo kcview)
target_link_directories(${PROJECT_NAME} PRIVATE ${LLVM_LIBRARY_DIRS})
target_link_libraries(${PROJECT_NAME} PRIVATE ${LLVM_LIBRARIES} libzstd_static)
target_link_options(${PROJECT_NAME} PRIVATE -lz -lm -lcurses)

set_target_properties(${PROJECT_NAME} PROPERTIES
        CXX_VISIBILITY_PRESET hidden
        CXX_STANDARD_REQUIRED ON
        VISIBILITY_INLINES_HIDDEN ON
        POSITION_INDEPENDENT_CODE ON
        LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/out/bin)

get_target_property(BN_API_SOURCE_DIR binaryninjaapi SOURCE_DIR)
list(APPEND CMAKE_MODULE_PATH "${BN_API_SOURCE_DIR}/cmake")
find_package(BinaryNinjaCore REQUIRED)
add_custom_target(install_binja_kc
        COMMAND ${CMAKE_COMMAND} -E copy $<TARGET_FILE:binja_kc> ${BinaryNinjaCore_USER_PLUGINS_DIR}
        DEPENDS binja_kc
        COMMENT "Installing binja_kc to ${BinaryNinjaCore_USER_PLUGINS_DIR}")

```

`LICENSE`:

```
MIT License

Copyright (c) 2022 skr0x1c0

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# BinjaKC

A plugin for loading Mach-O kernelcache and dSYM files into Binary Ninja.

<img align="center" src="./resources/screenshot.png">

This plugin can load symbols and type information from multiple dSYM files contained in the KDK to the corresponding kernelcache opened in Binary Ninja. It will automatically handle sliding of symbol address, merging of duplicate types and renaming of different types with same name. It can also import function and data symbol names from Mach-O kernel extensions contained in the KDK to the corresponding kernelcache.

## Installation

### Prerequisites

#### Setup Binary Ninja API

1. Clone the Binary Ninja API repository along with its submodules

```bash
git clone --recursive https://github.com/Vector35/binaryninja-api.git
```

2. Set the environment variable `BN_API_PATH` to the path of directory containing the cloned Binary Ninja API source code 

```bash
export BN_API_PATH="$PWD/binaryninja-api"
```

3. If the Binary Ninja app is in a non-standard installation location (`/Applications` for macOS), set the environment variable `BN_INSTALL_DIR` to path of the Binary Ninja installation

```bash
export BN_INSTALL_DIR="<path-to-binary-ninja-application>"
```

4. If you are using the stable version of Binary Ninja app, checkout the `master` branch of the Binary Ninja API repository

```bash
pushd "$BN_API_PATH"
git checkout master
popd
```

#### Install LLVM 15

```
brew install llvm@15
```


### Building and installation

1. Clone the BinjaKC repository along with its submodules

```bash
git clone --recursive https://github.com/skr0x1c0/binja_kc
```

2. Use `cmake` to build the plugin

```bash
cd binja_kc
mkdir build
cd build
cmake .. -DCMAKE_BUILD_TYPE=RelWithDebInfo
make -j$(nproc) install_binja_kc
```

If everything goes well, the plugin will be installed on the plugins folder in the Binary Ninja user directory. You can verify this by opening the Binary Ninja application. The message `[Core] Loaded native plugin binja_kc` will be displayed on the log.

## Usage

### For loading kernelcache with symbols from KDK

NOTE: The kernelcache should be a Mach-O file

1. Place the kernelcache in a directory of your choice

```bash
mkdir kc
cd kc
cp /private/var/db/KernelExtensionManagement/KernelCollections/BootKernelCollection.kc ./kernelcache
```

2. Copy the respective KDK to the same directory with name `<name-of-kernel-cache>.symbols`

```bash
cp -R /Library/Developer/KDKs/KDK_13.0_22A5331f.kdk ./kernelcache.symbols
```

3. Now you can directly open the kernelcache in Binary Ninja application. The symbols and type information from the KDK will be loaded automatically.

### For loading normal Mach-O files with symbols from dSYM

Place the dSYM file in the same directory as that of Mach-O binary with name `<name-of-binary>.dSYM` and open the binary as usual using Binary Ninja application. The symbols and type information will be automatically loaded.

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details

```

`cmake/Modules/FindLLVM.cmake`:

```cmake
# Copied from https://github.com/ldc-developers/ldc/blob/master/cmake/Modules/FindLLVM.cmake
# See license at https://github.com/ldc-developers/ldc/blob/master/LICENSE

# - Find LLVM headers and libraries.
# This module locates LLVM and adapts the llvm-config output for use with
# CMake.
#
# A given list of COMPONENTS is passed to llvm-config.
#
# The following variables are defined:
#  LLVM_FOUND          - true if LLVM was found
#  LLVM_CXXFLAGS       - C++ compiler flags for files that include LLVM headers.
#  LLVM_ENABLE_ASSERTIONS - Whether LLVM was built with enabled assertions (ON/OFF).
#  LLVM_INCLUDE_DIRS   - Directory containing LLVM include files.
#  LLVM_IS_SHARED      - Whether LLVM is going to be linked dynamically (ON) or statically (OFF).
#  LLVM_LDFLAGS        - Linker flags to add when linking against LLVM
#                        (includes -LLLVM_LIBRARY_DIRS).
#  LLVM_LIBRARIES      - Full paths to the library files to link against.
#  LLVM_LIBRARY_DIRS   - Directory containing LLVM libraries.
#  LLVM_NATIVE_ARCH    - Backend corresponding to LLVM_HOST_TARGET, e.g.,
#                        X86 for x86_64 and i686 hosts.
#  LLVM_ROOT_DIR       - The root directory of the LLVM installation.
#                        llvm-config is searched for in ${LLVM_ROOT_DIR}/bin.
#  LLVM_TARGETS_TO_BUILD - List of built LLVM targets.
#  LLVM_VERSION_MAJOR  - Major version of LLVM.
#  LLVM_VERSION_MINOR  - Minor version of LLVM.
#  LLVM_VERSION_STRING - Full LLVM version string (e.g. 6.0.0svn).
#  LLVM_VERSION_BASE_STRING - Base LLVM version string without git/svn suffix (e.g. 6.0.0).
#
# Note: The variable names were chosen in conformance with the offical CMake
# guidelines, see ${CMAKE_ROOT}/Modules/readme.txt.

# Try suffixed versions to pick up the newest LLVM install available on Debian
# derivatives.
# We also want an user-specified LLVM_ROOT_DIR to take precedence over the
# system default locations such as /usr/local/bin. Executing find_program()
# multiples times is the approach recommended in the docs.
set(llvm_config_names llvm-config-15.0 llvm-config150 llvm-config-15
        llvm-config-14.0 llvm-config140 llvm-config-14
        llvm-config-13.0 llvm-config130 llvm-config-13
        llvm-config-12.0 llvm-config120 llvm-config-12
        llvm-config-11.0 llvm-config110 llvm-config-11
        llvm-config-10.0 llvm-config100 llvm-config-10
        llvm-config-9.0 llvm-config90 llvm-config-9
        llvm-config)
find_program(LLVM_CONFIG
        NAMES ${llvm_config_names}
        PATHS ${LLVM_ROOT_DIR}/bin NO_DEFAULT_PATH
        DOC "Path to llvm-config tool.")
find_program(LLVM_CONFIG NAMES ${llvm_config_names})
if(APPLE)
    # extra fallbacks for MacPorts & Homebrew
    find_program(LLVM_CONFIG
            NAMES ${llvm_config_names}
            PATHS /opt/local/libexec/llvm-15/bin
            /opt/local/libexec/llvm-14/bin  /opt/local/libexec/llvm-13/bin  /opt/local/libexec/llvm-12/bin
            /opt/local/libexec/llvm-11/bin  /opt/local/libexec/llvm-10/bin  /opt/local/libexec/llvm-9.0/bin
            /opt/local/libexec/llvm/bin
            /usr/local/opt/llvm@15/bin
            /usr/local/opt/llvm@14/bin /usr/local/opt/llvm@13/bin /usr/local/opt/llvm@12/bin
            /usr/local/opt/llvm@11/bin /usr/local/opt/llvm@10/bin /usr/local/opt/llvm@9/bin
            /usr/local/opt/llvm/bin
            /opt/homebrew/opt/llvm@15/bin
            /opt/homebrew/opt/llvm@14/bin /opt/homebrew/opt/llvm@13/bin /opt/homebrew/opt/llvm@12/bin
            /opt/homebrew/opt/llvm@11/bin /opt/homebrew/opt/llvm@10/bin /opt/homebrew/opt/llvm@9/bin
            /opt/homebrew/opt/llvm/bin
            NO_DEFAULT_PATH)
endif()

set(_LLVM_CONFIG_EXTRA_FLAGS --link-static)

# Prints a warning/failure message depending on the required/quiet flags. Copied
# from FindPackageHandleStandardArgs.cmake because it doesn't seem to be exposed.
macro(_LLVM_FAIL _msg)
    if(LLVM_FIND_REQUIRED)
        message(FATAL_ERROR "${_msg}")
    else()
        if(NOT LLVM_FIND_QUIETLY)
            message(WARNING "${_msg}")
        endif()
    endif()
endmacro()


if(NOT LLVM_CONFIG)
    if(NOT LLVM_FIND_QUIETLY)
        _LLVM_FAIL("No LLVM installation (>= ${LLVM_FIND_VERSION}) found. Try manually setting the 'LLVM_ROOT_DIR' or 'LLVM_CONFIG' variables.")
    endif()
else()
    macro(llvm_set var flag)
        if(LLVM_FIND_QUIETLY)
            set(_quiet_arg ERROR_QUIET)
        endif()
        set(result_code)
        execute_process(
                COMMAND ${LLVM_CONFIG} ${_LLVM_CONFIG_EXTRA_FLAGS} --${flag}
                RESULT_VARIABLE result_code
                OUTPUT_VARIABLE LLVM_${var}
                OUTPUT_STRIP_TRAILING_WHITESPACE
                ${_quiet_arg}
        )
        if(result_code)
            _LLVM_FAIL("Failed to execute llvm-config ('${LLVM_CONFIG}', result code: '${result_code})'")
        else()
            if(${ARGV2})
                file(TO_CMAKE_PATH "${LLVM_${var}}" LLVM_${var})
            endif()
        endif()
    endmacro()
    macro(llvm_set_libs var flag components)
        if(LLVM_FIND_QUIETLY)
            set(_quiet_arg ERROR_QUIET)
        endif()
        set(result_code)
        execute_process(
                COMMAND ${LLVM_CONFIG} ${_LLVM_CONFIG_EXTRA_FLAGS} --${flag} ${components}
                RESULT_VARIABLE result_code
                OUTPUT_VARIABLE tmplibs
                OUTPUT_STRIP_TRAILING_WHITESPACE
                ${_quiet_arg}
        )
        if(result_code)
            _LLVM_FAIL("Failed to execute llvm-config ('${LLVM_CONFIG}', result code: '${result_code})'")
        else()
            file(TO_CMAKE_PATH "${tmplibs}" tmplibs)
            string(REGEX MATCHALL "${pattern}[^ ]+" LLVM_${var} ${tmplibs})
        endif()
    endmacro()

    llvm_set(VERSION_STRING version)
    llvm_set(CXXFLAGS cxxflags)
    llvm_set(INCLUDE_DIRS includedir true)
    llvm_set(ROOT_DIR prefix true)
    llvm_set(ENABLE_ASSERTIONS assertion-mode)

    # The LLVM version string _may_ contain a git/svn suffix, so match only the x.y.z part
    string(REGEX MATCH "^[0-9]+[.][0-9]+[.][0-9]+" LLVM_VERSION_BASE_STRING "${LLVM_VERSION_STRING}")
    string(REGEX REPLACE "([0-9]+).*" "\\1" LLVM_VERSION_MAJOR "${LLVM_VERSION_STRING}" )
    string(REGEX REPLACE "[0-9]+\\.([0-9]+).*[A-Za-z]*" "\\1" LLVM_VERSION_MINOR "${LLVM_VERSION_STRING}" )

    llvm_set(SHARED_MODE shared-mode)
    if(LLVM_SHARED_MODE STREQUAL "shared")
        set(LLVM_IS_SHARED ON)
    else()
        set(LLVM_IS_SHARED OFF)
    endif()

    llvm_set(LDFLAGS ldflags)
    llvm_set(SYSTEM_LIBS system-libs)
    string(REPLACE "\n" " " LLVM_LDFLAGS "${LLVM_LDFLAGS} ${LLVM_SYSTEM_LIBS}")
    if(APPLE) # unclear why/how this happens
        string(REPLACE "-llibxml2.tbd" "-lxml2" LLVM_LDFLAGS ${LLVM_LDFLAGS})
    endif()

    if(${LLVM_VERSION_MAJOR} LESS "15")
        # Versions below 15.0 do not support component windowsdriver
        list(REMOVE_ITEM LLVM_FIND_COMPONENTS "windowsdriver")
    endif()

    llvm_set(LIBRARY_DIRS libdir true)
    llvm_set_libs(LIBRARIES libs "${LLVM_FIND_COMPONENTS}")
    # LLVM bug: llvm-config --libs tablegen returns -lLLVM-3.8.0
    # but code for it is not in shared library
    if("${LLVM_FIND_COMPONENTS}" MATCHES "tablegen")
        if (NOT "${LLVM_LIBRARIES}" MATCHES "LLVMTableGen")
            set(LLVM_LIBRARIES "${LLVM_LIBRARIES};-lLLVMTableGen")
        endif()
    endif()

    llvm_set(CMAKEDIR cmakedir)
    llvm_set(TARGETS_TO_BUILD targets-built)
    string(REGEX MATCHALL "${pattern}[^ ]+" LLVM_TARGETS_TO_BUILD ${LLVM_TARGETS_TO_BUILD})

    # Parse LLVM_NATIVE_ARCH manually from LLVMConfig.cmake; including it leads to issues like
    # https://github.com/ldc-developers/ldc/issues/3079.
    file(STRINGS "${LLVM_CMAKEDIR}/LLVMConfig.cmake" LLVM_NATIVE_ARCH LIMIT_COUNT 1 REGEX "^set\\(LLVM_NATIVE_ARCH (.+)\\)$")
    string(REGEX MATCH "set\\(LLVM_NATIVE_ARCH (.+)\\)" LLVM_NATIVE_ARCH "${LLVM_NATIVE_ARCH}")
    set(LLVM_NATIVE_ARCH ${CMAKE_MATCH_1})
    message(STATUS "LLVM_NATIVE_ARCH: ${LLVM_NATIVE_ARCH}")

    # On CMake builds of LLVM, the output of llvm-config --cxxflags does not
    # include -fno-rtti, leading to linker errors. Be sure to add it.
    if(NOT MSVC AND (CMAKE_COMPILER_IS_GNUCXX OR (${CMAKE_CXX_COMPILER_ID} STREQUAL "Clang")))
        if(NOT ${LLVM_CXXFLAGS} MATCHES "-fno-rtti")
            set(LLVM_CXXFLAGS "${LLVM_CXXFLAGS} -fno-rtti")
        endif()
    endif()

    # Remove some clang-specific flags for gcc.
    if(CMAKE_COMPILER_IS_GNUCXX)
        string(REPLACE "-Wcovered-switch-default " "" LLVM_CXXFLAGS ${LLVM_CXXFLAGS})
        string(REPLACE "-Wstring-conversion " "" LLVM_CXXFLAGS ${LLVM_CXXFLAGS})
        string(REPLACE "-fcolor-diagnostics " "" LLVM_CXXFLAGS ${LLVM_CXXFLAGS})
        # this requires more recent gcc versions (not supported by 4.9)
        string(REPLACE "-Werror=unguarded-availability-new " "" LLVM_CXXFLAGS ${LLVM_CXXFLAGS})
    endif()

    # Remove gcc-specific flags for clang.
    if(${CMAKE_CXX_COMPILER_ID} MATCHES "Clang")
        string(REPLACE "-Wno-maybe-uninitialized " "" LLVM_CXXFLAGS ${LLVM_CXXFLAGS})
    endif()

    if (${LLVM_VERSION_STRING} VERSION_LESS ${LLVM_FIND_VERSION})
        _LLVM_FAIL("Unsupported LLVM version ${LLVM_VERSION_STRING} found (${LLVM_CONFIG}). At least version ${LLVM_FIND_VERSION} is required. You can also set variables 'LLVM_ROOT_DIR' or 'LLVM_CONFIG' to use a different LLVM installation.")
    endif()
endif()

# Use the default CMake facilities for handling QUIET/REQUIRED.
include(FindPackageHandleStandardArgs)

find_package_handle_standard_args(LLVM
        REQUIRED_VARS LLVM_ROOT_DIR
        VERSION_VAR LLVM_VERSION_STRING)
```

`common/CMakeLists.txt`:

```txt
set(LIBRARY_NAME binja_kc_common)

set(BINJA_KC_COMMON_HEADERS
        include/binja/utils/binary_view.h
        include/binja/macho/macho.h
        include/binja/types/errors.h
        include/binja/types/uuid.h
        include/binja/utils/debug.h
        include/binja/utils/demangle.h
        include/binja/utils/log.h
        include/binja/utils/settings.h
        include/binja/utils/span_reader.h
        include/binja/utils/strconv.h
        include/binja/utils/interval_map.h)

set(BINJA_KC_COMMON_SOURCES
        src/macho/macho.cpp
        src/utils/binary_view.cpp
        src/utils/demangle.cpp
        src/utils/settings.cpp
        src/utils/span_reader.cpp
        src/utils/strconv.cpp)

add_library(${LIBRARY_NAME} STATIC ${BINJA_KC_COMMON_HEADERS} ${BINJA_KC_COMMON_SOURCES})
target_include_directories(${LIBRARY_NAME} PUBLIC include)
target_include_directories(${LIBRARY_NAME} PRIVATE include/binja)

target_link_libraries(${LIBRARY_NAME} PRIVATE ${LLVM_LIBRARIES})
target_include_directories(${LIBRARY_NAME} PUBLIC ${LLVM_INCLUDE_DIRS})

target_link_libraries(${LIBRARY_NAME} PUBLIC binaryninjaapi fmt::fmt)
```

`common/include/binja/macho/macho.h`:

```h
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#pragma once

#include <span>
#include <string>

#include <binaryninjaapi.h>
#include <binaryninjacore.h>

#include "../types/errors.h"
#include "../types/uuid.h"
#include "../utils/binary_view.h"


namespace Binja::MachO {

class DataReaderError : public Types::DecodeError {
    using Types::DecodeError::DecodeError;
};


class MachDataBackend {
public:
    virtual ~MachDataBackend() = default;
    virtual size_t GetStart() const = 0;
    virtual size_t GetLength() const = 0;
    virtual size_t Read(void *buffer, size_t offset, size_t length) const = 0;
};


class MachBinaryViewDataBackend : public MachDataBackend {
public:
    explicit MachBinaryViewDataBackend(BinaryNinja::BinaryView &base) : base_(base) {}

    size_t GetStart() const override {
        return base_.GetStart();
    }

    size_t GetLength() const override {
        return base_.GetLength();
    }

    size_t Read(void *buffer, size_t offset, size_t length) const override {
        return base_.Read(buffer, offset, length);
    }

private:
    BinaryNinja::BinaryView &base_;
};


class MachSpanDataBackend : public MachDataBackend {
public:
    explicit MachSpanDataBackend(const std::span<char>& base) : base_{base} {}

    size_t GetStart() const override {
        return 0;
    }

    size_t GetLength() const override {
        return base_.size();
    }

    size_t Read(void *buffer, size_t offset, size_t length) const override {
        if (offset >= base_.size()) {
            return 0;
        }
        length = std::min(length, base_.size() - offset);
        std::memcpy(buffer, base_.data() + offset, length);
        return length;
    }

private:
    const std::span<char>& base_;
};

}// namespace Binja::MachO


namespace Binja::MachO::Detail {


class DataReader {
public:
    explicit DataReader(const MachDataBackend *base, uint64_t offset)
        : base_{base}, offset_{offset} {}

    template<class T>
    T Read() {
        T result = Peek<T>();
        offset_ += sizeof(T);
        return result;
    }

    template<class T>
    T Peek() {
        T result;
        auto size = sizeof(T);
        auto read = base_->Read(&result, offset_, size);
        if (read != size) {
            throw DataReaderError{"Failed to read data of size {} at offset {}, read only {} bytes", size, offset_, read};
        }
        return result;
    }

    std::string ReadString(size_t maxLength = 1024) {
        size_t length = FindStringLength(maxLength);
        std::string result;
        result.resize(length);
        auto read = base_->Read(result.data(), offset_, length);
        BDVerify(read == length);
        offset_ += length;
        return result;
    }

    void Seek(size_t length) {
        offset_ += length;
        if (offset_ > base_->GetStart() + base_->GetLength()) {
            throw DataReaderError{"Attempt to seek to position {} past EOF, file size: {}", offset_, base_->GetLength()};
        }
    }

    const uint64_t Offset() const {
        return offset_;
    }

private:
    size_t FindStringLength(size_t maxLength) {
        char buffer[32];
        for (size_t cursor = 0; cursor < maxLength; cursor += sizeof(buffer)) {
            size_t read = base_->Read(buffer, offset_ + cursor, sizeof(buffer));
            for (size_t i = 0; i < read; ++i) {
                if (buffer[i] == '\0') {
                    return cursor + i;
                }
            }
            if (read != sizeof(buffer)) {
                throw DataReaderError{"Failed to read string at offset {}, reached EOF at {}", offset_, cursor + read};
            }
        }
        throw DataReaderError{"Failed to read string at offset {}, string exceeds max length {}", offset_, maxLength};
    }

private:
    const MachDataBackend *base_;
    uint64_t offset_;
};

}// namespace Binja::MachO::Detail

namespace Binja::MachO {

class MachHeaderDecodeError : public Types::DecodeError {
    using Types::DecodeError::DecodeError;
};

struct Fileset {
    std::string name;
    uint64_t vmAddr;
    uint64_t fileOffset;
};

struct Section {
    std::string name;
    uint64_t vaStart;
    uint64_t vaLength;
    BNSectionSemantics semantics;
};

struct Segment {
    std::string name;
    uint64_t vaStart;
    uint64_t vaLength;
    uint64_t dataStart;
    uint64_t dataLength;
    uint32_t flags;
    std::vector<Section> sections;
};

struct Symbol {
    std::string name;
    uint64_t addr;
};

struct DyldChainedPtr {
    uint64_t fileOffset;
    uint64_t value;
};

class MachHeaderParser {
public:
    MachHeaderParser(const MachDataBackend &data, uint64_t machHeaderOffset)
        : data_{data}, machHeaderOffset_{machHeaderOffset} {
        VerifyHeader();
    }

    std::vector<Fileset> DecodeFilesets();
    std::vector<Segment> DecodeSegments();
    std::optional<uint64_t> DecodeEntryPoint();
    std::optional<Types::UUID> DecodeUUID();
    std::vector<Symbol> DecodeSymbols();
    std::vector<uint64_t> DecodeFunctionStarts();
    std::vector<DyldChainedPtr> DecodeDyldChainedPtrs();

private:
    void VerifyHeader();
    template<class T> std::optional<T> FindCommand(uint32_t cmd);
    std::optional<uint64_t> FindVMBase();

    static Fileset DecodeFileset(Detail::DataReader &reader);
    static Segment DecodeSegment(Detail::DataReader &reader);
    static std::vector<Section> DecodeSections(Detail::DataReader &reader);

private:
    const MachDataBackend &data_;
    uint64_t machHeaderOffset_;
};


class MachBinaryView {
public:
    MachBinaryView(BinaryNinja::BinaryView &binaryView) : binaryView_{binaryView} {}
    std::map<Types::UUID, std::vector<Segment>> ReadMachOHeaders();
    std::vector<uint64_t> ReadMachOHeaderOffsets();

private:
    BinaryNinja::BinaryView &binaryView_;
};

}// namespace Binja::MachO

```

`common/include/binja/types/errors.h`:

```h
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#pragma once

#include <exception>
#include <fmt/format.h>

namespace Binja::Types {

class GenericException : public std::exception {
public:
    template<typename... T>
    explicit GenericException(fmt::format_string<T...> fmt, T &&...args)
        : msg_{fmt::format(fmt, std::forward<T>(args)...)} {}
    [[nodiscard]] const char *what() const noexcept override { return msg_.c_str(); }

private:
    std::string msg_;
};

class FatalError : public GenericException {
    using GenericException::GenericException;
};

class DecodeError : public GenericException {
    using GenericException::GenericException;
};

}// namespace Binja::Types

```

`common/include/binja/types/uuid.h`:

```h
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#pragma once

#include <fmt/format.h>

namespace Binja::Types {

struct UUID {
    uint8_t data[16];
    auto operator <=>(const UUID&) const = default;
};


}// namespace Binja::Types

namespace fmt {

template<>
struct formatter<Binja::Types::UUID> : formatter<string_view> {
    template<typename FormatContext>
    auto format(const Binja::Types::UUID &p, FormatContext &ctx) const -> decltype(ctx.out()) {
        return fmt::format_to(ctx.out(), "{:2x}", fmt::join(p.data, ""));
    }
};

}// namespace fmt
```

`common/include/binja/utils/binary_view.h`:

```h
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#pragma once

#include <binaryninjaapi.h>

#include "../types/errors.h"
#include "../utils/debug.h"

namespace Binja::Utils {

class BinaryViewReaderError : public Types::DecodeError {
    using Types::DecodeError::DecodeError;
};

class BinaryViewDataReader {
public:
    BinaryViewDataReader(BinaryNinja::BinaryView *base, uint64_t offset)
        : base_{base}, offset_{offset} {}

    template<class T>
    T Read() {
        T result = Peek<T>();
        offset_ += sizeof(T);
        return result;
    }

    template<class T>
    T Peek() {
        T result;
        auto size = sizeof(T);
        auto read = base_->Read(&result, offset_, size);
        if (read != size) {
            throw BinaryViewReaderError{"Failed to read data of size {} at offset {}, read only {} bytes", size, offset_, read};
        }
        return result;
    }

    std::string ReadString(size_t maxLength = 1024) {
        size_t length = FindStringLength(maxLength);
        std::string result;
        result.resize(length);
        auto read = base_->Read(result.data(), offset_, length);
        BDVerify(read == length);
        offset_ += length;
        return result;
    }

    void Seek(size_t length) {
        offset_ += length;
        if (offset_ > base_->GetStart() + base_->GetLength()) {
            throw BinaryViewReaderError{"Attempt to seek to position {} past EOF, file size: {}", offset_, base_->GetLength()};
        }
    }

    const uint64_t Offset() const {
        return offset_;
    }

private:
    size_t FindStringLength(size_t maxLength) {
        char buffer[32];
        for (size_t cursor = 0; cursor < maxLength; cursor += sizeof(buffer)) {
            size_t read = base_->Read(buffer, offset_ + cursor, sizeof(buffer));
            for (size_t i = 0; i < read; ++i) {
                if (buffer[i] == '\0') {
                    return cursor + i;
                }
            }
            if (read != sizeof(buffer)) {
                throw BinaryViewReaderError{"Failed to read string at offset {}, reached EOF at {}", offset_, cursor + read};
            }
        }
        throw BinaryViewReaderError{"Failed to read string at offset {}, string exceeds max length {}", offset_, maxLength};
    }

private:
    BinaryNinja::BinaryView *base_;
    uint64_t offset_;
};

BinaryNinja::Ref<BinaryNinja::BinaryView> OpenBinaryView(
    const std::string &path, bool updateAnalysis = true,
    BinaryNinja::Ref<BinaryNinja::BinaryViewType> viewType = nullptr,
    std::function<bool(size_t, size_t)> progress = nullptr,
    Json::Value options = Json::Value{});

BinaryNinja::Ref<BinaryNinja::BinaryView> OpenBinaryView(
    BinaryNinja::Ref<BinaryNinja::BinaryView> view, bool updateAnalysis = true,
    BinaryNinja::Ref<BinaryNinja::BinaryViewType> requestedViewType = nullptr,
    std::function<bool(size_t, size_t)> progress = nullptr,
    Json::Value options = Json::Value{}, bool isDatabase = false);

}// namespace Binja::Utils
```

`common/include/binja/utils/debug.h`:

```h
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.



#pragma once

#include "../types/errors.h"

#define BDVerify(CONDITION)                                                                                    \
    if (!(CONDITION)) {                                                                                        \
        throw Binja::Types::FatalError{"verify condition {} failed at {}:{}", #CONDITION, __FILE__, __LINE__}; \
    }                                                                                                          \
    0
```

`common/include/binja/utils/demangle.h`:

```h
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#pragma once

#include <string>

namespace Binja::Utils {

std::string Demangle(const std::string &name);

}

```

`common/include/binja/utils/interval_map.h`:

```h
//
// Created by Sreejith Krishnan R on 26/12/22.
//

#pragma once

#include <fmt/format.h>
#include <map>

#include "debug.h"

namespace Binja::Utils {

template<class Domain>
class Interval {
public:
    Interval(Domain start, Domain end) : start_{start}, end_{end} {
        BDVerify(start <= end);
    }

    Domain lower() const {
        return start_;
    }

    Domain upper() const {
        return end_;
    }

    bool overlaps(const Interval<Domain> &oth) const {
        return (start_ >= oth.start_ && start_ < oth.end_)
               || (end_ > oth.start_ && end_ <= oth.end_)
               || (oth.start_ >= start_ && oth.start_ < end_)
               || (oth.end_ > start_ && oth.end_ <= end_);
    }

private:
    Domain start_;
    Domain end_;
};

template<class Domain, class Value>
class IntervalMap {
private:
public:
    void insert(Interval<Domain> interval, Value value) {
        auto entry = entries_.lower_bound(interval);
        if (entry != entries_.end() && entry->first.overlaps(interval)) {
            throw std::range_error{fmt::format("existing interval {} overlaps with provided interval {}",
                                               entry->first, interval)};
        }
        entries_.insert({interval, value});
    }

    auto find(const Domain &key) const {
        if (key + 1 < key) {
            return end();
        }
        Interval interval{key, key + 1};
        return find(interval);
    }

    auto find(const Interval<Domain> &interval) const {
        auto entry = entries_.lower_bound(interval);
        if (entry == entries_.end() || !entry->first.overlaps(interval)) {
            return entries_.end();
        }
        return entry;
    }

    const size_t size() const {
        return entries_.size();
    }

    auto begin() const {
        return entries_.begin();
    }

    auto end() const {
        return entries_.end();
    }

private:
    struct IntervalComparator {
        bool operator()(const Interval<Domain>& i1, const Interval<Domain>& i2) const {
            return i2.lower() < i1.lower();
        }
    };

private:
    std::map<Interval<Domain>, Value, IntervalComparator> entries_;
};

}// namespace Binja::Utils

namespace fmt {

template<class Domain>
struct formatter<Binja::Utils::Interval<Domain>> : formatter<string_view> {
    template<typename FormatContext>
    auto format(const Binja::Utils::Interval<Domain> &p, FormatContext &ctx) const -> decltype(ctx.out()) {
        return fmt::format_to(ctx.out(), "[{},{})", p.lower(), p.upper());
    }
};

}// namespace fmt
```

`common/include/binja/utils/log.h`:

```h
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#pragma once

#include <binaryninjaapi.h>
#include <fmt/format.h>

#define BDLogDebug(...)                                                                  \
    do {                                                                                 \
        auto msg = fmt::format(__VA_ARGS__);                                             \
        BinaryNinja::LogDebug("binja_dwarf: %s:%d %s", __FILE__, __LINE__, msg.c_str()); \
    } while (0)

#define BDLogWarn(...)                                                                  \
    do {                                                                                \
        auto msg = fmt::format(__VA_ARGS__);                                            \
        BinaryNinja::LogWarn("binja_dwarf: %s:%d %s", __FILE__, __LINE__, msg.c_str()); \
    } while (0)

#define BDLogInfo(...)                                                                  \
    do {                                                                                \
        auto msg = fmt::format(__VA_ARGS__);                                            \
        BinaryNinja::LogInfo("binja_dwarf: %s:%d %s", __FILE__, __LINE__, msg.c_str()); \
    } while (0)

#define BDLogError(...)                                                                  \
    do {                                                                                 \
        auto msg = fmt::format(__VA_ARGS__);                                             \
        BinaryNinja::LogError("binja_dwarf: %s:%d %s", __FILE__, __LINE__, msg.c_str()); \
    } while (0)

```

`common/include/binja/utils/settings.h`:

```h
//
// Created by Sreejith Krishnan R on 10/01/23.
//

#pragma once

#include <binaryninjaapi.h>

namespace Binja::Utils {

class BinjaSettings {
public:
    explicit BinjaSettings(BNBinaryView* bvObj, BNSettings* settingsObj)
        : bvObj_{bvObj}, settingsObj_{settingsObj} {}

    const bool KCApplyDyldChainedFixups() const;
    const bool KCStripPAC() const;
    const std::vector<std::string> KCExcludedFilesets() const;
    const std::vector<std::string> KCIncludedFilesets() const;
    const bool KCSymbolicateKallocTypes() const;

    const std::optional<std::string> DebugInfoSymbolsSearchPath() const;

    const bool DWARFEnabled() const;
    const bool DWARFLoadTypes() const;
    const bool DWARFLoadDataVariables() const;
    const bool DWARFLoadFunctions() const;

    const bool MachoEnabled() const;
    const bool MachoLoadDataVariables() const;
    const bool MachoLoadFunctions() const;

    const bool SymtabEnabled() const;
    const bool SymtabLoadDataVariables() const;
    const bool SymtabLoadFunctions() const;

    const bool FunctionStartsEnabled() const;

private:
    template <class T>
    T GetSetting(const std::string& key) const;

public:
    static void Register();

private:
    BNBinaryView* bvObj_;
    BNSettings* settingsObj_;
};

}// namespace Binja::Utils

```

`common/include/binja/utils/span_reader.h`:

```h
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#pragma once

#include <span>

#include "../types/errors.h"

namespace Binja::Utils {

class SpanReader {
public:
    class ReadError : public Types::DecodeError {
        using Types::DecodeError::DecodeError;
    };

public:
    explicit SpanReader(const std::span<const char> &data)
        : image_{data} {}

    template<class T> const T *Read();
    std::string ReadString();
    template<class T> const T *Peek(size_t offset = 0);
    std::string PeekString(size_t offset = 0);
    SpanReader &Skip(size_t size);
    SpanReader Sub(size_t size);

private:
    void VerifyAvailable(uint64_t size);

private:
    const std::span<const char> image_;
    size_t offset_ = 0;
};

template<class T>
inline const T *SpanReader::Read() {
    const T *result = Peek<T>();
    offset_ += sizeof(T);
    return result;
}

template<class T>
inline const T *SpanReader::Peek(size_t offset) {
    VerifyAvailable(offset + sizeof(T));
    const T *result = reinterpret_cast<const T *>(&image_.data()[offset_ + offset]);
    return result;
}

}// namespace Binja::Utils
```

`common/include/binja/utils/strconv.h`:

```h
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#pragma once

#include <string>

#include <fmt/format.h>

namespace Binja::Utils {

uint64_t Strtoull(const std::string &str, int base = 0);

}// namespace Binja::Utils
```

`common/src/macho/macho.cpp`:

```cpp
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <llvm/Object/MachO.h>

#include "macho/macho.h"
#include "utils/demangle.h"
#include "utils/log.h"

using namespace Binja;
using namespace MachO;
using namespace llvm::MachO;

namespace BN = BinaryNinja;

namespace {

#define LC_FILESET_ENTRY (0x35 | LC_REQ_DYLD)

/*
 * A variable length string in a load command is represented by an lc_str
 * union.  The strings are stored just after the load command structure and
 * the offset is from the start of the load command structure.  The size
 * of the string is reflected in the cmdsize field of the load command.
 * Once again any padded bytes to bring the cmdsize field to a multiple
 * of 4 bytes must be zero.
 */
union lc_str {
    uint32_t offset; /* offset to the string */
#ifndef __LP64__
    char *ptr; /* pointer to the string */
#endif
};

/*
 * LC_FILESET_ENTRY commands describe constituent Mach-O files that are part
 * of a fileset. In one implementation, entries are dylibs with individual
 * mach headers and repositionable text and data segments. Each entry is
 * further described by its own mach header.
 */
struct fileset_entry_command {
    uint32_t cmd;          /* LC_FILESET_ENTRY */
    uint32_t cmdsize;      /* includes entry_id string */
    uint64_t vmaddr;       /* memory address of the entry */
    uint64_t fileoff;      /* file offset of the entry */
    union lc_str entry_id; /* contained entry id */
    uint32_t reserved;     /* reserved */
};

struct arm_unified_thread_state {
    arm_state_hdr_t ash;
    union {
        arm_thread_state32_t ts_32;
        arm_thread_state64_t ts_64;
    } uts;
};

struct dyld_chained_starts_in_segment {
    uint32_t size;             // size of this (amount kernel needs to copy)
    uint16_t page_size;        // 0x1000 or 0x4000
    uint16_t pointer_format;   // DYLD_CHAINED_PTR_*
    uint64_t segment_offset;   // offset in memory to start of segment
    uint32_t max_valid_pointer;// for 32-bit OS, any value beyond this is not a pointer
    uint16_t page_count;       // how many pages are in array
    uint16_t page_start[1];    // each entry is offset in each page of first element in chain
                               // or DYLD_CHAINED_PTR_START_NONE if no fixups on page
                               // uint16_t    chain_starts[1];    // some 32-bit formats may require multiple starts per page.
                               // for those, if high bit is set in page_starts[], then it
                               // is index into chain_starts[] which is a list of starts
                               // the last of which has the high bit set
};

enum {
    DYLD_CHAINED_PTR_START_NONE = 0xFFFF, // used in page_start[] to denote a page with no fixups
    DYLD_CHAINED_PTR_START_MULTI = 0x8000,// used in page_start[] to denote a page which has multiple starts
    DYLD_CHAINED_PTR_START_LAST = 0x8000, // used in chain_starts[] to denote last start in list for page
};

// values for dyld_chained_starts_in_segment.pointer_format
enum {
    DYLD_CHAINED_PTR_ARM64E = 1,// stride 8, unauth target is vmaddr
    DYLD_CHAINED_PTR_64 = 2,    // target is vmaddr
    DYLD_CHAINED_PTR_32 = 3,
    DYLD_CHAINED_PTR_32_CACHE = 4,
    DYLD_CHAINED_PTR_32_FIRMWARE = 5,
    DYLD_CHAINED_PTR_64_OFFSET = 6,    // target is vm offset
    DYLD_CHAINED_PTR_ARM64E_OFFSET = 7,// old name
    DYLD_CHAINED_PTR_ARM64E_KERNEL = 7,// stride 4, unauth target is vm offset
    DYLD_CHAINED_PTR_64_KERNEL_CACHE = 8,
    DYLD_CHAINED_PTR_ARM64E_USERLAND = 9,     // stride 8, unauth target is vm offset
    DYLD_CHAINED_PTR_ARM64E_FIRMWARE = 10,    // stride 4, unauth target is vmaddr
    DYLD_CHAINED_PTR_X86_64_KERNEL_CACHE = 11,// stride 1, x86_64 kernel caches
    DYLD_CHAINED_PTR_ARM64E_USERLAND24 = 12,  // stride 8, unauth target is vm offset, 24-bit bind
};

// DYLD_CHAINED_PTR_ARM64E
struct dyld_chained_ptr_arm64e_rebase {
    uint64_t target : 43,
        high8 : 8,
        next : 11,// 4 or 8-byte stide
        bind : 1, // == 0
        auth : 1; // == 0
};

// DYLD_CHAINED_PTR_ARM64E
struct dyld_chained_ptr_arm64e_bind {
    uint64_t ordinal : 16,
        zero : 16,
        addend : 19,// +/-256K
        next : 11,  // 4 or 8-byte stide
        bind : 1,   // == 1
        auth : 1;   // == 0
};

// DYLD_CHAINED_PTR_ARM64E
struct dyld_chained_ptr_arm64e_auth_rebase {
    uint64_t target : 32,// runtimeOffset
        diversity : 16,
        addrDiv : 1,
        key : 2,
        next : 11,// 4 or 8-byte stide
        bind : 1, // == 0
        auth : 1; // == 1
};

// DYLD_CHAINED_PTR_ARM64E
struct dyld_chained_ptr_arm64e_auth_bind {
    uint64_t ordinal : 16,
        zero : 16,
        diversity : 16,
        addrDiv : 1,
        key : 2,
        next : 11,// 4 or 8-byte stide
        bind : 1, // == 1
        auth : 1; // == 1
};

// DYLD_CHAINED_PTR_64/DYLD_CHAINED_PTR_64_OFFSET
struct dyld_chained_ptr_64_rebase {
    uint64_t target : 36,// 64GB max image size (DYLD_CHAINED_PTR_64 => vmAddr, DYLD_CHAINED_PTR_64_OFFSET => runtimeOffset)
        high8 : 8,       // top 8 bits set to this (DYLD_CHAINED_PTR_64 => after slide added, DYLD_CHAINED_PTR_64_OFFSET => before slide added)
        reserved : 7,    // all zeros
        next : 12,       // 4-byte stride
        bind : 1;        // == 0
};

// DYLD_CHAINED_PTR_64
struct dyld_chained_ptr_64_bind {
    uint64_t ordinal : 24,
        addend : 8,   // 0 thru 255
        reserved : 19,// all zeros
        next : 12,    // 4-byte stride
        bind : 1;     // == 1
};

// DYLD_CHAINED_PTR_64_KERNEL_CACHE, DYLD_CHAINED_PTR_X86_64_KERNEL_CACHE
struct dyld_chained_ptr_64_kernel_cache_rebase {
    uint64_t target : 30,// basePointers[cacheLevel] + target
        cacheLevel : 2,  // what level of cache to bind to (indexes a mach_header array)
        diversity : 16,
        addrDiv : 1,
        key : 2,
        next : 12, // 1 or 4-byte stide
        isAuth : 1;// 0 -> not authenticated.  1 -> authenticated
};

int32_t FixupSegmentMaxProt(const segment_command_64 &cmd) {
    if (std::string(cmd.segname) != "__&data_CONST") {
        return cmd.maxprot;
    }
    return cmd.maxprot & (~VM_PROT_WRITE);
}

}// namespace

/// Macho header parser

void MachO::MachHeaderParser::VerifyHeader() {
    Detail::DataReader reader{&data_, machHeaderOffset_};
    auto cmd = reader.Read<mach_header_64>();
    if (cmd.magic != MH_MAGIC_64 && cmd.magic != MH_CIGAM_64) {
        throw MachHeaderDecodeError{"unsupported mach header magic {} at offset {}", cmd.magic, machHeaderOffset_};
    }
}

Fileset MachHeaderParser::DecodeFileset(Detail::DataReader &reader) {
    auto cmd = reader.Peek<fileset_entry_command>();
    reader.Seek(cmd.entry_id.offset);
    std::string name = reader.ReadString();
    return Fileset{
        .name = name,
        .vmAddr = cmd.vmaddr,
        .fileOffset = cmd.fileoff,
    };
}

std::vector<Fileset> MachHeaderParser::DecodeFilesets() {
    Detail::DataReader reader{&data_, machHeaderOffset_};
    auto header = reader.Read<mach_header_64>();
    std::vector<Fileset> result;
    for (int i = 0; i < header.ncmds; ++i) {
        auto cmd = reader.Peek<load_command>();
        if (cmd.cmd == LC_FILESET_ENTRY) {
            Detail::DataReader sub{reader};
            result.push_back(DecodeFileset(sub));
        }
        reader.Seek(cmd.cmdsize);
    }
    return result;
}

std::vector<Section> MachHeaderParser::DecodeSections(Detail::DataReader &reader) {
    auto segment = reader.Read<segment_command_64>();

    auto decodeSectionSemantics = [](const segment_command_64 &segment, const section_64 &section) {
        auto maxProt = FixupSegmentMaxProt(segment);
        if (maxProt & VM_PROT_EXECUTE) {
            return BNSectionSemantics::ReadOnlyCodeSectionSemantics;
        }
        if (!(maxProt & VM_PROT_WRITE)) {
            return BNSectionSemantics::ReadOnlyDataSectionSemantics;
        }
        assert(maxProt & VM_PROT_READ);
        return BNSectionSemantics::ReadWriteDataSectionSemantics;
    };

    std::vector<Section> result;
    result.reserve(segment.nsects);
    for (int i = 0; i < segment.nsects; ++i) {
        auto section = reader.Read<section_64>();
        result.push_back(Section{
            .name = section.sectname,
            .vaStart = section.addr,
            .vaLength = section.size,
            .semantics = decodeSectionSemantics(segment, section),
        });
    }
    return result;
}

Segment MachHeaderParser::DecodeSegment(Detail::DataReader &reader) {
    auto decodeSegmentFlags = [](const segment_command_64 &cmd) {
        uint32_t flags = 0;
        auto maxProt = FixupSegmentMaxProt(cmd);
        if (maxProt & VM_PROT_EXECUTE) {
            flags |= BNSegmentFlag::SegmentContainsCode;
            flags |= BNSegmentFlag::SegmentExecutable;
            flags |= BNSegmentFlag::SegmentDenyWrite;
        }
        if (maxProt & VM_PROT_READ) {
            flags |= BNSegmentFlag::SegmentReadable;
        }
        if ((maxProt & VM_PROT_WRITE)) {
            flags |= BNSegmentFlag::SegmentWritable;
            flags |= BNSegmentFlag::SegmentDenyExecute;
        }
        return flags;
    };

    auto cmd = reader.Peek<segment_command_64>();
    Segment result{
        .name = cmd.segname,
        .vaStart = cmd.vmaddr,
        .vaLength = cmd.vmsize,
        .dataStart = cmd.fileoff,
        .dataLength = cmd.filesize,
        .flags = decodeSegmentFlags(cmd),
    };
    result.sections = DecodeSections(reader);
    return result;
}

std::vector<Segment> MachHeaderParser::DecodeSegments() {
    Detail::DataReader reader{&data_, machHeaderOffset_};
    auto header = reader.Read<mach_header_64>();
    std::vector<Segment> result;
    for (int i = 0; i < header.ncmds; ++i) {
        auto cmd = reader.Peek<load_command>();
        if (cmd.cmd == LC_SEGMENT_64) {
            Detail::DataReader sub{reader};
            result.push_back(DecodeSegment(sub));
        }
        reader.Seek(cmd.cmdsize);
    }
    return result;
}

std::optional<uint64_t> MachHeaderParser::DecodeEntryPoint() {
    Detail::DataReader reader{&data_, machHeaderOffset_};
    auto header = reader.Read<mach_header_64>();
    for (int i = 0; i < header.ncmds; ++i) {
        auto cmd = reader.Peek<load_command>();
        if (cmd.cmd != LC_UNIXTHREAD) {
            reader.Seek(cmd.cmdsize);
            continue;
        }
        auto sub = Detail::DataReader{reader};
        sub.Seek(sizeof(thread_command));
        auto flavor = sub.Peek<uint32_t>();
        if (flavor != ARM_THREAD_STATE64) {
            throw MachHeaderDecodeError{"unsupported LC_UNIXTHREAD flavor {}", flavor};
        }
        auto state = sub.Read<arm_unified_thread_state>();
        return state.uts.ts_64.pc;
    }
    return std::nullopt;
}

std::optional<Types::UUID> MachHeaderParser::DecodeUUID() {
    if (auto uuid = FindCommand<uuid_command>(LC_UUID)) {
        Types::UUID result;
        static_assert(sizeof(result.data) == sizeof(uuid->uuid));
        memcpy(result.data, uuid->uuid, sizeof(result.data));
        return result;
    }
    return std::nullopt;
}


std::vector<Symbol> MachHeaderParser::DecodeSymbols() {
    std::vector<Symbol> result;
    if (auto symtab = FindCommand<symtab_command>(LC_SYMTAB)) {
        Detail::DataReader symReader{&data_, symtab->symoff};
        for (size_t i = 0; i < symtab->nsyms; ++i) {
            auto sym = symReader.Read<nlist_64>();
            if ((sym.n_type & N_TYPE) == N_UNDF) {
                continue;
            }
            Detail::DataReader strReader{&data_, symtab->stroff + sym.n_strx};
            std::string name = strReader.ReadString();
            if (name.starts_with("_")) {
                name = name.substr(1);
            }
            result.emplace_back(Symbol{
                .name = name,
                .addr = sym.n_value,
            });
        }
    }
    return result;
}

namespace {

uint64_t DecodeULEB128(Detail::DataReader &reader) {
    uint64_t result = 0;
    uint64_t shift = 0;
    uint8_t byte = 0;
    do {
        byte = reader.Read<uint8_t>();
        result |= ((byte & 0x7f) << shift);
        shift += 7;
    } while ((byte & 0x80) != 0);
    return result;
}

}// namespace

std::vector<uint64_t> MachHeaderParser::DecodeFunctionStarts() {
    std::vector<uint64_t> result;
    if (auto cmd = FindCommand<linkedit_data_command>(LC_FUNCTION_STARTS)) {
        Detail::DataReader dataReader{&data_, cmd->dataoff};
        uint64_t cursor = *FindVMBase();
        size_t end = dataReader.Offset() + cmd->datasize;
        while (dataReader.Offset() < end) {
            uint64_t value = DecodeULEB128(dataReader);
            cursor += value;
            result.push_back(cursor);
        }
    }
    return result;
}

std::vector<DyldChainedPtr> MachHeaderParser::DecodeDyldChainedPtrs() {
    auto cmd = FindCommand<linkedit_data_command>(LC_DYLD_CHAINED_FIXUPS);
    if (!cmd) {
        BDLogWarn("Skipping DYLD_CHAINED_FIXUPS since no LC_DYLD_CHAINED_FIXUPS command found");
        return std::vector<DyldChainedPtr>();
    }

    uint64_t vmBase = *FindVMBase();
    std::vector<DyldChainedPtr> result;

    Detail::DataReader startsInImageReader{&data_, cmd->dataoff};
    auto fixupsHeader = startsInImageReader.Peek<dyld_chained_fixups_header>();
    startsInImageReader.Seek(fixupsHeader.starts_offset);

    auto startsInImageHeader = startsInImageReader.Peek<dyld_chained_starts_in_image>();
    startsInImageReader.Seek(offsetof(dyld_chained_starts_in_image, seg_info_offset));

    for (size_t segInfoIndex = 0; segInfoIndex < startsInImageHeader.seg_count; ++segInfoIndex) {
        static_assert(sizeof(dyld_chained_starts_in_image::seg_info_offset) == sizeof(uint32_t));
        auto segInfoOffset = startsInImageReader.Read<uint32_t>();
        if (segInfoOffset == 0) {
            continue;
        }

        Detail::DataReader startsInSegmentReader{&data_, cmd->dataoff + fixupsHeader.starts_offset + segInfoOffset};
        auto startsInSegmentHeader = startsInSegmentReader.Peek<dyld_chained_starts_in_segment>();

        static_assert(offsetof(dyld_chained_starts_in_segment, page_start) + sizeof(dyld_chained_starts_in_segment::page_start) == sizeof(dyld_chained_starts_in_segment));
        static_assert(sizeof(dyld_chained_starts_in_segment::page_start) == sizeof(uint16_t));

        startsInSegmentReader.Seek(offsetof(dyld_chained_starts_in_segment, page_start));
        for (size_t pageIndex = 0; pageIndex < startsInSegmentHeader.page_count; ++pageIndex) {
            auto offsetInPage = startsInSegmentReader.Read<uint16_t>();
            if (offsetInPage == DYLD_CHAINED_PTR_START_NONE) {
                continue;
            }
            if (offsetInPage & DYLD_CHAINED_PTR_START_MULTI) {
                BDLogWarn("Skipping DYLD_CHAINED_PTR_START_MULTI");
                continue;
            }
            switch (startsInSegmentHeader.pointer_format) {
                case DYLD_CHAINED_PTR_64_KERNEL_CACHE: {
                    union PtrARM64e {
                        uint64_t raw;
                        dyld_chained_ptr_arm64e_rebase rebase;
                        dyld_chained_ptr_arm64e_bind bind;
                        dyld_chained_ptr_arm64e_auth_rebase auth_rebase;
                        dyld_chained_ptr_arm64e_auth_bind auth_bind;
                    };
                    Detail::DataReader ptrReader{
                        &data_,
                        startsInSegmentHeader.segment_offset + pageIndex * startsInSegmentHeader.page_size + offsetInPage};
                    while (true) {
                        auto ptr = ptrReader.Peek<PtrARM64e>();
                        bool auth = ptr.rebase.auth;
                        bool bind = ptr.rebase.bind;
                        auto next = ptr.rebase.next;

                        if (auth && bind) {
                            BDLogWarn("Cannot fixup chained pointer with both auth and bind set "
                                      "at offset {:#016x}", ptrReader.Offset());
                        } else if (auth) {
                            auto address = vmBase + ptr.auth_rebase.target;
                            result.emplace_back(DyldChainedPtr{
                                .fileOffset = ptrReader.Offset(),
                                .value = address,
                            });
                        } else if (bind) {
                            BDLogWarn("Cannot chained pointer with bind set "
                                      "at offset {:#016x}", ptrReader.Offset());
                        } else {
                            auto top8Bits = (ptr.raw >> 43) & 0xFFL;
                            auto bottom43Bits = ptr.raw & 0x000007FFFFFFFFFFL;
                            if (top8Bits == 0x80) {
                                top8Bits = 0;
                            }
                            auto address = vmBase + ((top8Bits << 56) | bottom43Bits);
                            result.emplace_back(DyldChainedPtr{
                                .fileOffset = ptrReader.Offset(),
                                .value = address,
                            });
                        }

                        if (next == 0) {
                            break;
                        }
                        ptrReader.Seek(next * 4);
                    }
                    break;
                }
                default:
                    BDLogWarn("Encountered unknown pointer format {}, skipping", startsInSegmentHeader.pointer_format);
                    continue;
            }
        }
    }

    return result;
}

template<class T>
std::optional<T> MachHeaderParser::FindCommand(uint32_t cmd) {
    Detail::DataReader reader{&data_, machHeaderOffset_};
    auto header = reader.Read<mach_header_64>();
    for (uint32_t i = 0; i < header.ncmds; ++i) {
        auto lc = reader.Peek<load_command>();
        if (lc.cmd != cmd) {
            reader.Seek(lc.cmdsize);
            continue;
        }
        return reader.Peek<T>();
    }
    return std::nullopt;
}

std::optional<uint64_t> MachHeaderParser::FindVMBase() {
    Detail::DataReader reader{&data_, machHeaderOffset_};
    auto header = reader.Read<mach_header_64>();
    for (uint32_t i = 0; i < header.ncmds; ++i) {
        auto lc = reader.Peek<load_command>();
        if (lc.cmd != LC_SEGMENT_64) {
            reader.Seek(lc.cmdsize);
            continue;
        }
        auto segment = reader.Peek<segment_command_64>();
        if (segment.vmaddr > 0) {
            return segment.vmaddr;
        }
        reader.Seek(lc.cmdsize);
    }
    return std::nullopt;
}

/// Mach binary view

std::vector<uint64_t> MachBinaryView::ReadMachOHeaderOffsets() {
    uint64_t start = binaryView_.GetStart();
    std::vector<uint64_t> result{start};
    MachBinaryViewDataBackend backend{binaryView_};
    MachHeaderParser header{backend, start};
    for (const auto &fileset: header.DecodeFilesets()) {
        if (binaryView_.GetTypeName() == "Raw") {
            result.push_back(fileset.fileOffset + binaryView_.GetStart());
        } else {
            result.push_back(fileset.vmAddr);
        }
    }
    return result;
}

std::map<Types::UUID, std::vector<Segment>> MachBinaryView::ReadMachOHeaders() {
    std::map<Types::UUID, std::vector<Segment>> result;
    for (const auto offset: ReadMachOHeaderOffsets()) {
        if (!binaryView_.IsValidOffset(offset)) {
            continue;
        }
        MachBinaryViewDataBackend backend{binaryView_};
        MachHeaderParser parser{backend, offset};
        auto uuid = parser.DecodeUUID();
        if (!uuid) {
            BDLogWarn("mach header at {:#016x} does not have LC_UUID command, "
                      "symbols won't be loaded for this segments in this header",
                      offset);
            continue;
        }
        result[*uuid] = parser.DecodeSegments();
    }
    return result;
}

```

`common/src/utils/binary_view.cpp`:

```cpp
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include "utils/binary_view.h"

using namespace Binja;
using namespace Utils;
using namespace BinaryNinja;

Ref<BinaryView> Utils::OpenBinaryView(const std::string &filename, bool updateAnalysis, Ref<BinaryViewType> viewType,
                                      std::function<bool(size_t, size_t)> progress, Json::Value options) {
    if (!progress)
        progress = [](size_t, size_t) { return true; };

    // Loading will surely fail if the file does not exist, so exit early
    if (!BNPathExists(filename.c_str()))
        return nullptr;

    // Detect bndb
    bool isDatabase = false;
    Ref<BinaryView> view = nullptr;

    if (filename.size() > 6 && filename.substr(filename.size() - 5) == ".bndb") {
        // Open database, read raw view contents from it
        static const std::string sqlite_header = "SQLite format 3";

        FILE *f = fopen(filename.c_str(), "rb");
        // Unable to open file
        if (f == nullptr)
            return nullptr;

        char header[0x20];
        fread(header, 1, sqlite_header.size(), f);
        fclose(f);
        header[sqlite_header.size()] = 0;

        // File is not a valid sqlite db
        if (sqlite_header != header)
            return nullptr;

        Ref<FileMetadata> file = new FileMetadata(filename);
        view = file->OpenDatabaseForConfiguration(filename);
        isDatabase = true;
    } else {
        // Open file, read raw contents
        Ref<FileMetadata> file = new FileMetadata(filename);
        view = new BinaryData(file, filename);
    }

    if (!view)
        return nullptr;
    return Utils::OpenBinaryView(view, updateAnalysis, viewType, progress, options, isDatabase);
}

BinaryNinja::Ref<BinaryNinja::BinaryView> Utils::OpenBinaryView(
    BinaryNinja::Ref<BinaryNinja::BinaryView> view, bool updateAnalysis, Ref<BinaryViewType> requestedViewType,
    std::function<bool(size_t, size_t)> progress, Json::Value options, bool isDatabase) {
    Ref<BinaryViewType> bvt = requestedViewType;
    Ref<BinaryViewType> universalBvt;
    std::vector<Ref<BinaryViewType>> availableViewTypes = BinaryViewType::GetViewTypesForData(view);
    for (auto it = availableViewTypes.rbegin(), end = availableViewTypes.rend(); it != end; ++it) {
        Ref<BinaryViewType> available = *it;
        if (available->GetName() == "Universal") {
            universalBvt = available;
            continue;
        }
        if (!bvt && available->GetName() != "Raw") {
            bvt = available;
        }
    }

    // No available views: Load as Mapped
    if (!bvt)
        bvt = BinaryViewType::GetByName("Mapped");

    Ref<Settings> defaultSettings = Settings::Instance(bvt->GetName() + "_settings");
    defaultSettings->DeserializeSchema(Settings::Instance()->SerializeSchema());
    defaultSettings->SetResourceId(bvt->GetName());

    Ref<Settings> loadSettings;
    if (isDatabase) {
        loadSettings = view->GetLoadSettings(bvt->GetName());
    }
    if (!loadSettings) {
        if (universalBvt && options.isMember("files.universal.architecturePreference")) {
            // Load universal architecture
            loadSettings = universalBvt->GetLoadSettingsForData(view);
            if (!loadSettings) {
                LogError("Could not load entry from Universal image. No load settings!");
                return nullptr;
            }
            std::string architectures = loadSettings->Get<std::string>("loader.universal.architectures");

            std::unique_ptr<Json::CharReader> reader(Json::CharReaderBuilder().newCharReader());
            Json::Value archList;
            std::string errors;
            if (!reader->parse((const char *) architectures.data(), (const char *) architectures.data() + architectures.size(), &archList, &errors)) {
                BinaryNinja::LogError("Error parsing architecture list: %s", errors.data());
                return nullptr;
            }

            Json::Value archEntry;
            for (auto archPref: options["files.universal.architecturePreference"]) {
                for (auto entry: archList) {
                    if (entry["architecture"].asString() == archPref.asString()) {
                        archEntry = entry;
                        break;
                    }
                }
                if (!archEntry.isNull())
                    break;
            }
            if (archEntry.isNull()) {
                std::string error = "Could not load any of:";
                for (auto archPref: options["files.universal.architecturePreference"]) {
                    error += std::string(" ") + archPref.asString();
                }
                error += " from Universal image. Entry not found! Available entries:";
                for (auto entry: archList) {
                    error += std::string(" ") + entry["architecture"].asString();
                }
                LogError("%s", error.c_str());
                return nullptr;
            }

            loadSettings = Settings::Instance(GetUniqueIdentifierString());
            loadSettings->DeserializeSchema(archEntry["loadSchema"].asString());
        } else {
            // Load non-universal architecture
            loadSettings = bvt->GetLoadSettingsForData(view);
        }
    }

    if (!loadSettings) {
        LogError("Could not get load settings for binary view of type '%s'", bvt->GetName().c_str());
        return nullptr;
    }

    loadSettings->SetResourceId(bvt->GetName());
    view->SetLoadSettings(bvt->GetName(), loadSettings);

    for (auto key: options.getMemberNames()) {
        auto value = options[key];
        if (loadSettings->Contains(key)) {
            Json::StreamWriterBuilder builder;
            builder["indentation"] = "";
            std::string json = Json::writeString(builder, value);

            if (!loadSettings->SetJson(key, json, view)) {
                LogError("Setting: %s set operation failed!", key.c_str());
                return nullptr;
            }
        } else if (defaultSettings->Contains(key)) {
            Json::StreamWriterBuilder builder;
            builder["indentation"] = "";
            std::string json = Json::writeString(builder, value);

            if (!defaultSettings->SetJson(key, json, view)) {
                LogError("Setting: %s set operation failed!", key.c_str());
                return nullptr;
            }
        } else {
            LogError("Setting: %s not available!", key.c_str());
            return nullptr;
        }
    }

    Ref<BinaryView> bv;
    if (isDatabase) {
        view = view->GetFile()->OpenExistingDatabase(view->GetFile()->GetFilename(), progress);
        if (!view) {
            LogError("Unable to open existing database with filename %s", view->GetFile()->GetFilename().c_str());
            return nullptr;
        }
        bv = view->GetFile()->GetViewOfType(bvt->GetName());
    } else {
        bv = bvt->Create(view);
    }

    if (!bv) {
        return view;
    }
    if (updateAnalysis) {
        bv->UpdateAnalysisAndWait();
    }
    return bv;
}
```

`common/src/utils/demangle.cpp`:

```cpp
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <cxxabi.h>

#include "utils/demangle.h"

std::string Binja::Utils::Demangle(const std::string& name) {
    int status = 0;
    char* ret = abi::__cxa_demangle(name.c_str(), nullptr, nullptr, &status);
    if (status) {
        return name;
    }

    std::string result{ret};
    free(ret);
    return result;
}
```

`common/src/utils/settings.cpp`:

```cpp
//
// Created by Sreejith Krishnan R on 10/01/23.
//

#include <binaryninjaapi.h>

#include "binja/utils/settings.h"

using namespace Binja;
using namespace Utils;

namespace BN = BinaryNinja;

using SettingsRef = BN::Ref<BN::Settings>;

#define MAIN_SETTINGS_GROUP "binjaKC"

#define KC_SETTINGS_GROUP MAIN_SETTINGS_GROUP ".kernelcache"
#define KC_SETTING_EXCLUDED_FILESETS KC_SETTINGS_GROUP ".excludedFilesets"
#define KC_SETTING_INCLUDED_FILESETS KC_SETTINGS_GROUP ".includedFilesets"
#define KC_SETTING_APPLY_DYLD_CHAINED_FIXUPS KC_SETTINGS_GROUP ".applyDyldChainedFixups"
#define KC_SETTING_STRIP_PAC KC_SETTINGS_GROUP ".stripPAC"
#define KC_SETTING_SYMBOLICATE_KALLOC_TYPES KC_SETTINGS_GROUP ".symbolicateKallocTypes"

#define DEBUGINFO_SETTINGS_GROUP MAIN_SETTINGS_GROUP ".debugInfo"
#define DEBUGINFO_SETTING_SYMBOLS_DIRECTORY DEBUGINFO_SETTINGS_GROUP ".symbolsDirectory"

#define DWARF_SETTINGS_GROUP MAIN_SETTINGS_GROUP ".dwarf"
#define DWARF_SETTINGS_ENABLE_DWARF DWARF_SETTINGS_GROUP ".enableDWARF"
#define DWARF_SETTINGS_LOAD_TYPES DWARF_SETTINGS_GROUP ".loadTypes"
#define DWARF_SETTINGS_LOAD_DATA_VARIABLES DWARF_SETTINGS_GROUP ".loadDataVariables"
#define DWARF_SETTINGS_LOAD_FUNCTIONS DWARF_SETTINGS_GROUP ".loadFunctions"

#define MACHO_SETTINGS_GROUP MAIN_SETTINGS_GROUP ".machoDebugInfo"
#define MACHO_SETTINGS_ENABLE_MACHO MACHO_SETTINGS_GROUP ".enableMacho"
#define MACHO_SETTINGS_LOAD_DATA_VARIABLES MACHO_SETTINGS_GROUP ".loadDataVariables"
#define MACHO_SETTINGS_LOAD_FUNCTIONS MACHO_SETTINGS_GROUP ".loadFunctions"

#define SYMTAB_SETTINGS_GROUP MAIN_SETTINGS_GROUP ".symtab"
#define SYMTAB_SETTINGS_ENABLE_SYMTAB SYMTAB_SETTINGS_GROUP ".enableSymtab"
#define SYMTAB_SETTINGS_LOAD_DATA_VARIABLES SYMTAB_SETTINGS_GROUP ".loadDataVariables"
#define SYMTAB_SETTINGS_LOAD_FUNCTIONS SYMTAB_SETTINGS_GROUP ".loadFunctions"

#define FUNCTION_STARTS_SETTINGS_GROUP MAIN_SETTINGS_GROUP ".functionStarts"
#define FUNCTION_STARTS_SETTINGS_ENABLE_FUNCTION_STARTS FUNCTION_STARTS_SETTINGS_GROUP ".enableFunctionStarts"

namespace {

void RegisterKCSettings(SettingsRef settings) {
    settings->RegisterSetting(
        KC_SETTING_EXCLUDED_FILESETS,
        R"({
            "default": ["com.apple.driver.FairPlayIOKit"],
            "description": "List of filesets in kernel cache to ignore",
            "elementType": "string",
            "ignore": [],
            "title": "Excluded filesets",
            "type": "array"
        })");

    settings->RegisterSetting(
        KC_SETTING_INCLUDED_FILESETS,
        R"({
            "default": [],
            "description": "List of filesets in kernel cache to include. If empty, all filesets are included except the ones in 'Excluded filesets'",
            "elementType": "string",
            "ignore": [],
            "title": "Included filesets",
            "type": "array"
        })");
    // TODO: fix description
    settings->RegisterSetting(
        KC_SETTING_APPLY_DYLD_CHAINED_FIXUPS,
        R"({
            "default": true,
            "description": "Apply dyld chained fixups",
            "title": "Apply dyld chained fixups",
            "type": "boolean"
        })");
    settings->RegisterSetting(
        KC_SETTING_STRIP_PAC,
        R"({
            "default": false,
            "description": "Strip PAC from PAC signed pointers",
            "title": "Strip PAC",
            "type": "boolean"
        })");
    settings->RegisterSetting(
        KC_SETTING_SYMBOLICATE_KALLOC_TYPES,
        R"({
            "default": true,
            "description": "Symbolicate __kalloc_type and __kalloc_var sections",
            "title": "Symbolicate kalloc types",
            "type": "boolean"
        })");
}

void RegisterDebugInfoSettings(SettingsRef settings) {
    settings->RegisterSetting(
        DEBUGINFO_SETTING_SYMBOLS_DIRECTORY,
        R""({
            "default": "",
            "description": "Absolute path to directory containing symbol sources (dSYM and Mach-O)",
            "title": "Symbols directory",
            "type": "string",
            "optional": true
        })"");
}

void RegisterDWARFSettings(SettingsRef settings) {
    settings->RegisterSetting(
        DWARF_SETTINGS_ENABLE_DWARF,
        R"({
            "default": true,
            "description": "Load debug info from .dSYM files",
            "title": "Enable DWARF debug info",
            "type": "boolean"
        })");

    settings->RegisterSetting(
        DWARF_SETTINGS_LOAD_TYPES,
        R"({
            "default": true,
            "description":"Load type information from DWARF",
            "title":"Load types",
            "type":"boolean"
        })");

    settings->RegisterSetting(
        DWARF_SETTINGS_LOAD_DATA_VARIABLES,
        R"({
            "default": true,
            "description":"Load global data variable debug info from DWARF",
            "title":"Load data variable info",
            "type":"boolean"
        })");

    settings->RegisterSetting(
        DWARF_SETTINGS_LOAD_FUNCTIONS,
        R"({
            "default": true,
            "description":"Load function debug info from DWARF",
            "title":"Load function info",
            "type":"boolean"
        })");
}

void RegisterMachoSettings(SettingsRef settings) {
    settings->RegisterSetting(
        MACHO_SETTINGS_ENABLE_MACHO,
        R""({
            "default": false,
            "description": "Load debug info from Mach-O files (eg: *.kext inside KDK)",
            "title": "Enable Mach-O debug info",
            "type": "boolean"
        })"");

    settings->RegisterSetting(
        MACHO_SETTINGS_LOAD_DATA_VARIABLES,
        R"({
            "default": true,
            "description":"Load global data variable debug info from Mach-O",
            "title":"Load data variable info",
            "type":"boolean"
        })");

    settings->RegisterSetting(
        MACHO_SETTINGS_LOAD_FUNCTIONS,
        R"({
            "default": true,
            "description":"Load function debug info from Mach-O",
            "title":"Load function info",
            "type":"boolean"
        })");
}

void RegisterSymtabSettings(SettingsRef settings) {
    settings->RegisterSetting(
        SYMTAB_SETTINGS_ENABLE_SYMTAB,
        R"({
            "default": true,
            "description": "Load debug info from kernelcache SYMTAB",
            "title": "Enable symbol table debug info",
            "type": "boolean"
        })");

    settings->RegisterSetting(
        SYMTAB_SETTINGS_LOAD_DATA_VARIABLES,
        R"({
            "default": true,
            "description":"Load global data variable debug info from symbol table",
            "title":"Load data variable info",
            "type":"boolean"
        })");

    settings->RegisterSetting(
        SYMTAB_SETTINGS_LOAD_FUNCTIONS,
        R"({
            "default": true,
            "description":"Load function debug info from symbol table",
            "title":"Load function info",
            "type":"boolean"
        })");
}

void RegisterFunctionStartsSettings(SettingsRef settings) {
    settings->RegisterSetting(
        FUNCTION_STARTS_SETTINGS_ENABLE_FUNCTION_STARTS,
        R"""({
            "default": false,
            "description": "Load function starts using LC_FUNCTION_STARTS load command",
            "title": "Enable LC_FUNCTION_STARTS debug info",
            "type": "boolean"
        })""");
}

}// namespace


void BinjaSettings::Register() {
    auto settings = BN::Settings::Instance();
    settings->RegisterGroup(MAIN_SETTINGS_GROUP, "Binja KC");
    RegisterKCSettings(settings);
    RegisterDebugInfoSettings(settings);
    RegisterDWARFSettings(settings);
    RegisterMachoSettings(settings);
    RegisterSymtabSettings(settings);
    RegisterFunctionStartsSettings(settings);
}


template<>
bool BinjaSettings::GetSetting(const std::string &key) const {
    const SettingsRef settings = BinaryNinja::Settings::Instance();
    return BNSettingsGetBool(
        settingsObj_,
        key.c_str(),
        bvObj_,
        nullptr,
        nullptr);
}

template<>
std::string BinjaSettings::GetSetting(const std::string &key) const {
    const SettingsRef settings = BinaryNinja::Settings::Instance();
    return BNSettingsGetString(
        settingsObj_,
        key.c_str(),
        bvObj_,
        nullptr,
        nullptr);
}

template<>
std::vector<std::string> BinjaSettings::GetSetting(const std::string &key) const {
    size_t size = 0;
    char **outBuffer = (char **) BNSettingsGetStringList(
        settingsObj_, key.c_str(), bvObj_, nullptr, nullptr, &size);

    std::vector<std::string> result;
    result.reserve(size);
    for (size_t i = 0; i < size; i++)
        result.emplace_back(outBuffer[i]);

    BNFreeStringList(outBuffer, size);
    return result;
}

const bool BinjaSettings::KCApplyDyldChainedFixups() const {
    return GetSetting<bool>(KC_SETTING_APPLY_DYLD_CHAINED_FIXUPS);
}

const bool BinjaSettings::KCStripPAC() const {
    return GetSetting<bool>(KC_SETTING_STRIP_PAC);
}

const std::vector<std::string> BinjaSettings::KCExcludedFilesets() const {
    return GetSetting<std::vector<std::string>>(KC_SETTING_EXCLUDED_FILESETS);
}

const std::vector<std::string> BinjaSettings::KCIncludedFilesets() const {
    return GetSetting<std::vector<std::string>>(KC_SETTING_INCLUDED_FILESETS);
}

const bool BinjaSettings::KCSymbolicateKallocTypes() const {
    return GetSetting<bool>(KC_SETTING_SYMBOLICATE_KALLOC_TYPES);
}

const std::optional<std::string> BinjaSettings::DebugInfoSymbolsSearchPath() const {
    std::string result = GetSetting<std::string>(DEBUGINFO_SETTING_SYMBOLS_DIRECTORY);
    if (!result.empty()) {
        return result;
    }
    return std::nullopt;
}

const bool BinjaSettings::DWARFEnabled() const {
    return GetSetting<bool>(DWARF_SETTINGS_ENABLE_DWARF);
}

const bool BinjaSettings::DWARFLoadTypes() const {
    return GetSetting<bool>(DWARF_SETTINGS_LOAD_TYPES);
}

const bool BinjaSettings::DWARFLoadDataVariables() const {
    return GetSetting<bool>(DWARF_SETTINGS_LOAD_DATA_VARIABLES);
}

const bool BinjaSettings::DWARFLoadFunctions() const {
    return GetSetting<bool>(DWARF_SETTINGS_LOAD_FUNCTIONS);
}

const bool BinjaSettings::MachoEnabled() const {
    return GetSetting<bool>(MACHO_SETTINGS_ENABLE_MACHO);
}

const bool BinjaSettings::MachoLoadDataVariables() const {
    return GetSetting<bool>(MACHO_SETTINGS_LOAD_DATA_VARIABLES);
}

const bool BinjaSettings::MachoLoadFunctions() const {
    return GetSetting<bool>(MACHO_SETTINGS_LOAD_FUNCTIONS);
}

const bool BinjaSettings::SymtabEnabled() const {
    return GetSetting<bool>(SYMTAB_SETTINGS_ENABLE_SYMTAB);
}

const bool BinjaSettings::SymtabLoadDataVariables() const {
    return GetSetting<bool>(SYMTAB_SETTINGS_LOAD_DATA_VARIABLES);
}

const bool BinjaSettings::SymtabLoadFunctions() const {
    return GetSetting<bool>(SYMTAB_SETTINGS_LOAD_FUNCTIONS);
}

const bool BinjaSettings::FunctionStartsEnabled() const {
    return GetSetting<bool>(FUNCTION_STARTS_SETTINGS_ENABLE_FUNCTION_STARTS);
}

```

`common/src/utils/span_reader.cpp`:

```cpp
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include "utils/span_reader.h"

using namespace Binja;
using namespace Utils;

std::string SpanReader::ReadString() {
    std::string result;
    while (true) {
        char c = *Read<char>();
        if (c == '\0') {
            break;
        }
        result += c;
    }
    return result;
}

std::string SpanReader::PeekString(size_t offset) {
    std::string result;
    while (true) {
        char c = *Peek<char>(offset++);
        if (c == '\0') {
            break;
        }
        result += c;
    }
    return result;
}

SpanReader &SpanReader::Skip(size_t size) {
    VerifyAvailable(size);
    offset_ += size;
    return *this;
}

SpanReader SpanReader::Sub(size_t size) {
    VerifyAvailable(size);
    SpanReader reader{image_.subspan(offset_, size)};
    offset_ += size;
    return reader;
}

void SpanReader::VerifyAvailable(uint64_t size) {
    if (offset_ + size > image_.size()) {
        throw ReadError{"Required data of size {} is not available at offset {}", size, offset_};
    }
}
```

`common/src/utils/strconv.cpp`:

```cpp
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include "utils/strconv.h"

using namespace Binja;
using namespace Utils;

uint64_t Utils::Strtoull(const std::string &str, int base) {
    char *endp = nullptr;
    uint64_t value = std::strtoull(str.data(), &endp, base);
    if (endp - str.data() != str.size()) {
        throw std::invalid_argument(fmt::format(
            "value {} cannot be converted to uint64 with base {}", str, base));
    }
    return value;
}

```

`debuginfo/CMakeLists.txt`:

```txt
set(LIBRARY_NAME dwarf_debuginfo)

set(DWARF_LOADER_HEADERS
        include/binja/debuginfo/errors.h
        include/binja/debuginfo/debug.h
        include/binja/debuginfo/dwarf.h
        include/binja/debuginfo/dwarf_task.h
        include/binja/debuginfo/function.h
        include/binja/debuginfo/macho_task.h
        include/binja/debuginfo/name_index.h
        include/binja/debuginfo/plugin_dsym.h
        include/binja/debuginfo/plugin_function_starts.h
        include/binja/debuginfo/plugin_macho.h
        include/binja/debuginfo/plugin_symtab.h
        include/binja/debuginfo/source_finder.h
        include/binja/debuginfo/slider.h
        include/binja/debuginfo/types.h
        include/binja/debuginfo/variable.h)

set(DWARF_LOADER_SOURCES
        src/dsym.cpp
        src/dwarf.cpp
        src/dwarf_task.cpp
        src/function.cpp
        src/macho_task.cpp
        src/name_index.cpp
        src/plugin_dsym.cpp
        src/plugin_function_starts.cpp
        src/plugin_macho.cpp
        src/plugin_symtab.cpp
        src/types.cpp
        src/slider.cpp
        src/source_finder.cpp
        src/variable.cpp)

add_library(${LIBRARY_NAME} STATIC ${DWARF_LOADER_SOURCES} ${DWARF_LOADER_HEADERS})
target_include_directories(${LIBRARY_NAME} PUBLIC include/binja)
target_include_directories(${LIBRARY_NAME} PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}/include)
target_include_directories(${LIBRARY_NAME} PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/include/binja/debuginfo)

target_link_libraries(${LIBRARY_NAME} PRIVATE ${LLVM_LIBRARIES})
target_include_directories(${LIBRARY_NAME} PUBLIC ${LLVM_INCLUDE_DIRS})

target_link_libraries(${LIBRARY_NAME} PUBLIC binja_kc_common)
target_link_libraries(${LIBRARY_NAME} PUBLIC binaryninjaapi fmt::fmt mio::mio Taskflow)

add_subdirectory(test)
```

`debuginfo/include/binja/debuginfo/debug.h`:

```h


// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#pragma once

#include <binaryninjaapi.h>
#include <binaryninjacore.h>
#include <fmt/format.h>

#include "dwarf.h"
#include "errors.h"

#define DWARF_DEBUG_BUILD 1

#define VerifyNotReachable() \
    throw Binja::DebugInfo::FatalError { "VerifyNotReachable failed at {}:{}", __FILE__, __LINE__ }

#define Verify(Condition, ErrorType)                               \
    if (!(Condition)) {                                            \
        throw ErrorType{"Verify condition {} failed", #Condition}; \
    }                                                              \
    0

#if DWARF_DEBUG_BUILD
#define DebugVerify(Condition, ErrorType)                            \
    if (!(Condition)) {                                              \
        throw ErrorType{"Debug verify condition {} failed at {}:{}", \
                        #Condition, __FILE_NAME__, __LINE__};        \
    }                                                                \
    0
#else
#define DebugVerify(Condition, ErrorType) \
    do {                                  \
    } while (0)
#endif

#define Todo() \
    throw Binja::Dwarf::FatalError { "todo at {}:{}", __FILE__, __LINE__ }

#define VerifyDumpDie(Condition, Die)                                                        \
    if (!(Condition)) {                                                                      \
        throw Binja::DebugInfo::DwarfError{"Verify condition {} failed at {}:{} for DIE {}", \
                                           #Condition, __FILE_NAME__, __LINE__,              \
                                           Binja::DebugInfo::DieReader{Die}.Dump()};         \
    }                                                                                        \
    0

#if DWARF_DEBUG_BUILD
#define VerifyDebugDumpDie(Condition, Die)                                                         \
    if (!(Condition)) {                                                                            \
        throw Binja::DebugInfo::DwarfError{"Debug verify condition {} failed at {}:{} for DIE {}", \
                                           #Condition, __FILE_NAME__, __LINE__,                    \
                                           Binja::DebugInfo::DieReader{Die}.Dump()};               \
    }                                                                                              \
    0
#else
#define VerifyDebugDumpDie(Condition, Die)                           \
    if (!(Condition)) {                                              \
        Binja::Dwarf::AttributeReader reader{Die};                   \
        throw LogWarn{"Debug verify condition {} failed for DIE {}", \
                      #Condition, reader.DebugInfo()};               \
    }
#endif
```

`debuginfo/include/binja/debuginfo/dsym.h`:

```h
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#pragma once

#include <filesystem>
#include <string>
#include <vector>

#include <binja/macho/macho.h>
#include <binja/types/uuid.h>

#include <llvm/DebugInfo/DWARF/DWARFContext.h>
#include <llvm/Object/MachO.h>

namespace Binja::DebugInfo {

class DwarfObjectFile {
public:
    explicit DwarfObjectFile(const std::filesystem::path &objectPath);
    llvm::DWARFContext &GetDWARFContext() { return *dwarfContext_; }

    static std::vector<std::filesystem::path> DsymFindObjects(
        const std::filesystem::path &symbolsPath);

    std::optional<Types::UUID> DecodeUUID() const;
    std::vector<MachO::Segment> DecodeSegments() const;

private:
    std::unique_ptr<llvm::MemoryBuffer> buffer_;
    std::unique_ptr<llvm::object::Binary> binaryObject_;
    std::unique_ptr<llvm::DWARFContext> dwarfContext_;
};

}// namespace Binja::DebugInfo

```

`debuginfo/include/binja/debuginfo/dwarf.h`:

```h
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#pragma once

#include <functional>
#include <optional>

#include <fmt/format.h>
#include <llvm/DebugInfo/DWARF/DWARFDie.h>

#include <binja/utils/debug.h>

#include "debug.h"
#include "dsym.h"
#include "errors.h"
#include "slider.h"

namespace Binja::DebugInfo {

struct DwarfOffset {
    uint64_t
        binaryId : 16,
        offset : 48;
    auto operator<=>(const DwarfOffset &oth) const = default;
};

class DwarfDieWrapper;
class DwarfDebugInfoEntryWrapper;
class DwarfUnitWrapper;

}// namespace Binja::DebugInfo

namespace Binja::DebugInfo::Detail {

class DwarfDieWrapperIterator;

}


namespace std {

template<>
struct hash<Binja::DebugInfo::DwarfOffset> {
    std::size_t operator()(Binja::DebugInfo::DwarfOffset const &s) const noexcept {
        static_assert(sizeof(s) == sizeof(uint64_t));
        auto v = *reinterpret_cast<const uint64_t *>(&s);
        return hash<uint64_t>{}(v);
    }
};

}// namespace std


namespace Binja::DebugInfo {

using BinaryId = uint16_t;

class DwarfDebugInfoEntryWrapper {
public:
    DwarfDebugInfoEntryWrapper(llvm::DWARFDebugInfoEntry entry, BinaryId binaryId)
        : entry_{entry}, binaryId_{binaryId} {}

    [[nodiscard]] DwarfOffset GetOffset() const { return DwarfOffset{binaryId_, entry_.getOffset()}; }

private:
    llvm::DWARFDebugInfoEntry entry_;
    BinaryId binaryId_;
};

class DwarfUnitWrapper {
public:
    DwarfUnitWrapper(llvm::DWARFUnit &unit, BinaryId binaryId)
        : unit_{unit}, binaryId_{binaryId} {}

    [[nodiscard]] uint8_t GetAddressByteSize() const;
    [[nodiscard]] std::vector<DwarfDebugInfoEntryWrapper> Dies() const;
    [[nodiscard]] const llvm::dwarf::FormParams GetFormParams();

private:
    llvm::DWARFUnit &unit_;
    BinaryId binaryId_;
};

class DwarfDieWrapper {
private:
    using Tag = llvm::dwarf::Tag;
    using Attribute = llvm::dwarf::Attribute;
    using DWARFFormValue = llvm::DWARFFormValue;
    using IteratorTransform = std::function<DwarfDieWrapper(const llvm::DWARFDie &)>;
    using Iterator = llvm::iterator_range<Detail::DwarfDieWrapperIterator>;
    template<class T> using Optional = llvm::Optional<T>;

public:
    DwarfDieWrapper(llvm::DWARFDie die, BinaryId binaryId)
        : die_{die}, offset_{binaryId, 0} {
        if (die.isValid()) {
            offset_.offset = die_.getOffset();
        }
    }

    DwarfDieWrapper()
        : die_{}, offset_{std::numeric_limits<BinaryId>::max()} {}

    [[nodiscard]] Tag GetTag() const { return die_.getTag(); }
    [[nodiscard]] DwarfOffset GetOffset() const { return offset_; }
    [[nodiscard]] Optional<DWARFFormValue> Find(Attribute attr) const { return die_.find(attr); }
    [[nodiscard]] Optional<DWARFFormValue> FindRecursively(Attribute attr) const { return die_.findRecursively(attr); }
    [[nodiscard]] bool IsValid() { return die_.isValid(); }
    [[nodiscard]] bool operator==(const DwarfDieWrapper &oth) const;

    [[nodiscard]] Optional<DwarfDieWrapper> GetAttributeValueAsReferencedDie(const llvm::DWARFFormValue &value) const;
    [[nodiscard]] DwarfUnitWrapper GetDwarfUnit() const;
    [[nodiscard]] DwarfDieWrapper GetParent() const;
    [[nodiscard]] DwarfDieWrapper GetSibling();
    [[nodiscard]] DwarfDieWrapper GetPreviousSibling();
    [[nodiscard]] DwarfDieWrapper GetFirstChild();
    [[nodiscard]] DwarfDieWrapper GetLastChild();
    [[nodiscard]] Iterator Children();
    [[nodiscard]] llvm::Expected<llvm::DWARFAddressRangesVector> GetAddressRanges();
    [[nodiscard]] llvm::Expected<llvm::DWARFLocationExpressionsVector> GetLocations(llvm::dwarf::Attribute attr);
    void Dump(llvm::raw_ostream &ss, uint32_t indent = 0, llvm::DIDumpOptions opts = llvm::DIDumpOptions{});

private:
    llvm::DWARFDie die_;
    DwarfOffset offset_;
};

class DwarfContextWrapper {
public:
    struct Entry {
        DwarfObjectFile object;
        AddressSlider slider;
    };

public:
    explicit DwarfContextWrapper(std::vector<Entry> entries)
        : entries_{std::move(entries)} {
        BDVerify(entries_.size() <= std::numeric_limits<BinaryId>::max());
    }

    [[nodiscard]] DwarfDieWrapper GetDIEForOffset(DwarfOffset offset);
    [[nodiscard]] std::vector<DwarfUnitWrapper> GetNormalUnitsVector();
    [[nodiscard]] std::optional<uint64_t> GetSlidAddress(DwarfOffset offset, uint64_t source);
    [[nodiscard]] size_t GetDwarfObjectCount() const { return entries_.size(); }

private:
    std::vector<Entry> entries_;
};

class AttributeReader {
public:
    explicit AttributeReader(DwarfDieWrapper &die) : die_{die} {}
    [[nodiscard]] std::optional<uint64_t> ReadUInt(llvm::dwarf::Attribute attribute, bool recursive = false) const;
    [[nodiscard]] std::optional<uint64_t> ReadInt(llvm::dwarf::Attribute attribute, bool recursive = false) const;
    [[nodiscard]] std::string ReadString(llvm::dwarf::Attribute attribute, const char *defaultValue = "", bool recursive = false) const;
    [[nodiscard]] std::string ReadName(const char *defaultName = "", bool recursive = false) const;
    [[nodiscard]] std::optional<DwarfDieWrapper> ReadReference(llvm::dwarf::Attribute attribute, bool recursive = false) const;
    [[nodiscard]] bool HasAttribute(llvm::dwarf::Attribute attribute, bool recursive = false) const;
    [[nodiscard]] std::string ReadLinkageName(const char *defaultName = "", bool recursive = false) const;
    [[nodiscard]] std::optional<llvm::DWARFFormValue> FindAttribute(llvm::dwarf::Attribute attr, bool recursive) const;
    [[nodiscard]] std::optional<uint64_t> ReadLocationAddress() const;

private:
    DwarfDieWrapper &die_;
};

class DieReader {
public:
    explicit DieReader(DwarfDieWrapper &die) : die_{die}, attrReader_{die} {}
    const AttributeReader &AttrReader() const { return attrReader_; }
    std::vector<std::string> ReadQualifiedName() const;
    uint8_t ReadAddressSize() const;
    [[nodiscard]] std::string Dump() const;

private:
    DwarfDieWrapper &die_;
    AttributeReader attrReader_;
};

}// namespace Binja::DebugInfo


namespace Binja::DebugInfo::Detail {

class DwarfDieWrapperIterator
    : public llvm::iterator_facade_base<DwarfDieWrapperIterator, std::bidirectional_iterator_tag,
                                        const DwarfDieWrapperIterator> {

    friend std::reverse_iterator<llvm::DWARFDie::iterator>;
    friend bool operator==(const DwarfDieWrapperIterator &lhs,
                           const DwarfDieWrapperIterator &rhs);

public:
    DwarfDieWrapperIterator() = default;

    explicit DwarfDieWrapperIterator(DwarfDieWrapper die) : die_(die) {}

    DwarfDieWrapperIterator &operator++() {
        die_ = die_.GetSibling();
        return *this;
    }

    DwarfDieWrapperIterator &operator--() {
        die_ = die_.GetPreviousSibling();
        return *this;
    }

    const DwarfDieWrapper &operator*() const { return die_; }

private:
    DwarfDieWrapper die_;
};

inline bool operator==(const DwarfDieWrapperIterator &v1,
                       const DwarfDieWrapperIterator &v2) {
    return v1.die_ == v2.die_;
}

}// namespace Binja::DebugInfo::Detail

namespace fmt {

template<>
struct formatter<Binja::DebugInfo::DwarfOffset> : formatter<string_view> {
    template<typename FormatContext>
    auto format(const Binja::DebugInfo::DwarfOffset &p, FormatContext &ctx) const -> decltype(ctx.out()) {
        return fmt::format_to(ctx.out(), "b{}o{}", p.binaryId, p.offset);
    }
};

}// namespace fmt
```

`debuginfo/include/binja/debuginfo/dwarf_task.h`:

```h
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#pragma once

#include <llvm/DebugInfo/DWARF/DWARFContext.h>

#include "dwarf.h"

namespace Binja::DebugInfo {

struct ImportOptions {
    bool importTypes;
    bool importFunctions;
    bool importGlobals;
};

enum class DwarfImportPhase : int {
    Min = -1,
    IndexingQualifiedNames,
    DecodingTypes,
    AddingTypesToBinaryView,
    ImportingFunctionsAndGlobals,
    Max
};

struct DwarfImportProgressMonitor {
    virtual bool operator()(DwarfImportPhase phase, size_t total, size_t done) = 0;
};

class DwarfImportTask {
public:
    DwarfImportTask(const std::vector<std::filesystem::path> &dwarfObjects,
                    BinaryNinja::BinaryView &binaryView,
                    BinaryNinja::DebugInfo &debugInfo,
                    ImportOptions options,
                    DwarfImportProgressMonitor &monitor)
        : dwarfObjects_{dwarfObjects},
          binaryView_{binaryView},
          debugInfo_{debugInfo},
          options_{options},
          monitor_{monitor} {}

    const ImportOptions &GetImportOptions() { return options_; }
    void Import();
    static bool IsNamedTypeTag(llvm::dwarf::Tag tag);

private:
    DwarfContextWrapper BuildDwarfContext();

private:
    const std::vector<std::filesystem::path> &dwarfObjects_;
    BinaryNinja::BinaryView &binaryView_;
    BinaryNinja::DebugInfo &debugInfo_;
    ImportOptions options_;
    DwarfImportProgressMonitor &monitor_;
};

}// namespace Binja::DebugInfo
```

`debuginfo/include/binja/debuginfo/errors.h`:

```h
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#pragma once

#include <exception>
#include <fmt/format.h>

namespace Binja::DebugInfo {

class GenericException : public std::exception {
public:
    template<typename... T>
    explicit GenericException(fmt::format_string<T...> fmt, T &&...args)
        : msg_{fmt::format(fmt, std::forward<T>(args)...)} {}
    [[nodiscard]] const char *what() const noexcept override { return msg_.c_str(); }

private:
    std::string msg_;
};

class FatalError : public GenericException {
    using GenericException::GenericException;
};

class DwarfError : public GenericException {
    using GenericException::GenericException;
};

void test(const std::string &path);
}// namespace Binja::DebugInfo

```

`debuginfo/include/binja/debuginfo/function.h`:

```h
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#pragma once

#include <binaryninjaapi.h>

#include <llvm/DebugInfo/DWARF/DWARFDie.h>

#include "dwarf.h"
#include "types.h"

namespace Binja::DebugInfo {

struct DwarfFunctionInfo {
    BinaryNinja::Ref<BinaryNinja::Type> type;
    BinaryNinja::QualifiedName qualifiedName;
    uint64_t entryPoint;
    bool isNoReturn;
};

class FunctionDecoder {
public:
    FunctionDecoder(TypeBuilderContext &ctx, DwarfDieWrapper &die)
        : ctx_{ctx}, die_{die}, dieReader_{die_} {}

    std::optional<DwarfFunctionInfo> Decode();

private:
    std::optional<uint64_t> DecodeEntryPoint();
    bool DecodeIsNoReturn();

private:
    TypeBuilderContext &ctx_;
    DwarfDieWrapper &die_;
    DieReader dieReader_;
};

}// namespace Binja::DebugInfo

```

`debuginfo/include/binja/debuginfo/macho_task.h`:

```h
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#pragma once

#include <filesystem>
#include <vector>

#include <binaryninjaapi.h>

#include <binja/macho/macho.h>
#include <binja/types/uuid.h>

#include "slider.h"

namespace Binja::DebugInfo {

struct MachOImportProgressMonitor {
    virtual bool operator()(size_t total, size_t done) = 0;
};

struct MachOImportOptions {
    bool importFunctions;
    bool importDataVariables;
};

class MachOImportTask {
public:
    MachOImportTask(std::vector<std::filesystem::path> sources,
                    BinaryNinja::BinaryView &binaryView, BinaryNinja::DebugInfo &debugInfo,
                    MachOImportOptions options,
                    MachOImportProgressMonitor &monitor);
    void Import();

private:
    BinaryNinja::Ref<BinaryNinja::BinaryView> OpenMachO(const std::filesystem::path &path);
    bool AddSymbol(const BinaryNinja::Symbol &symbol, AddressSlider &slider);

private:
    BinaryNinja::BinaryView &binaryView_;
    BinaryNinja::DebugInfo &debugInfo_;
    std::vector<std::filesystem::path> sources_;
    std::map<uint64_t, std::string> registeredSymbols_;
    MachOImportOptions options_;
    MachOImportProgressMonitor &monitor_;
    std::map<Types::UUID, std::vector<MachO::Segment>> targetSegments_;
};

}// namespace Binja::DebugInfo

```

`debuginfo/include/binja/debuginfo/name_index.h`:

```h
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#pragma once

#include <limits>
#include <unordered_map>

#include <llvm/DebugInfo/DWARF/DWARFContext.h>
#include <llvm/DebugInfo/DWARF/DWARFDie.h>

#include "dwarf.h"
#include "types.h"

namespace Binja::DebugInfo {

class NameIndex {
private:
    struct Node;

    using QualfiedName = BinaryNinja::QualifiedName;
    using NodeInfoVectorIndex = size_t;
    using NodeEntryMap = std::map<std::string, Node>;

    struct Node {
        NodeInfoVectorIndex info;
        NodeEntryMap children;
    };

    struct NodeInfo {
        std::string name;
        DwarfOffset baseDie;
        int forkIndex = 0;
    };

    enum class NodeMergeStrategy {
        fork,
        replace,
        alias
    };

    using NodeInfoVector = std::vector<NodeInfo>;
    using AliasMap = std::unordered_map<DwarfOffset, NodeInfoVectorIndex>;

private:
    const NodeInfoVectorIndex kRootNodeIndex_ = std::numeric_limits<NodeInfoVectorIndex>::max();

public:
    NameIndex(DwarfContextWrapper &dwarfContext) : dwarfContext_{dwarfContext} {}
    void IndexDie(DwarfDieWrapper &die);
    QualfiedName DecodeQualifiedName(DwarfDieWrapper &die);
    DwarfDieWrapper ResolveDieOffset(DwarfOffset offset);
    void VisitEntries(std::function<void(const std::vector<std::string> &, DwarfOffset)> cb);
    size_t NumEntries() const { return nodeCount_; }
    std::vector<DwarfOffset> DecodeHierarchy(DwarfOffset offset);

private:
    void InsertHierarchy(const std::vector<DwarfOffset> &hierarchy);
    NodeMergeStrategy EvaluateMergeStrategy(DwarfOffset currentDieOffset, DwarfOffset newDieOffset);
    NameIndex::Node *MergeNode(Node &parentNode, std::string name, DwarfOffset newDieOffset);
    NameIndex::Node *InsertNode(Node &parent, std::string name, DwarfOffset dieOffset);
    const NameIndex::Node *FindChild(const Node &parent, DwarfOffset dieOffset);

    static const char *GetAnonymousNameSuffix(llvm::dwarf::Tag tag);
    static std::string GetAnonymousName(DwarfDieWrapper &die);

private:
    DwarfContextWrapper &dwarfContext_;
    Node root_{kRootNodeIndex_};
    NodeInfoVector nodeInfoVector_;
    AliasMap aliasMap_;
    size_t nodeCount_ = 0;
};

}// namespace Binja::DebugInfo
```

`debuginfo/include/binja/debuginfo/plugin_dsym.h`:

```h
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#pragma once

#include <filesystem>

#include <binaryninjaapi.h>

#include "dsym.h"
#include "dwarf_task.h"

namespace Binja::DebugInfo {

class PluginDSYM {
public:
    static constexpr auto kPluginName = "dsym_debug_info";

public:
    PluginDSYM(BinaryNinja::BinaryView &binaryView)
        : binaryView_{binaryView} {}

    void Load(BinaryNinja::DebugInfo &debugInfo, DwarfImportProgressMonitor &monitor);

    static void RegisterPlugin();
    std::optional<std::filesystem::path> GetSymbolSource();

private:
    BinaryNinja::BinaryView &binaryView_;
};

}// namespace Binja::DebugInfo
```

`debuginfo/include/binja/debuginfo/plugin_function_starts.h`:

```h
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#pragma once

#include <binaryninjaapi.h>

namespace Binja::DebugInfo {

class PluginFunctionStarts {
public:
    static constexpr auto kPluginName = "macho_kc_function_starts_debug_info";

public:
    static void RegisterPlugin();
};

}// namespace Binja::DebugInfo

```

`debuginfo/include/binja/debuginfo/plugin_macho.h`:

```h
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#pragma once

#include <filesystem>

#include <binaryninjaapi.h>

#include "dsym.h"
#include "macho_task.h"

namespace Binja::DebugInfo {

class PluginMacho {
public:
    static constexpr auto kPluginName = "macho_debug_info";

public:
    PluginMacho(BinaryNinja::BinaryView &binaryView)
        : binaryView_{binaryView} {}

    void Load(BinaryNinja::DebugInfo &debugInfo, MachOImportProgressMonitor &monitor);

    static void RegisterPlugin();
    std::optional<std::filesystem::path> GetSymbolSource();

private:
    BinaryNinja::BinaryView &binaryView_;
};

}// namespace Binja::DebugInfo
```

`debuginfo/include/binja/debuginfo/plugin_symtab.h`:

```h
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#pragma once

#include <binaryninjaapi.h>

namespace Binja::DebugInfo {

class PluginSymtab {
public:
    static constexpr auto kPluginName = "macho_kc_symtab_debug_info";

public:
    static void RegisterPlugin();
};

}// namespace Binja::DebugInfo

```

`debuginfo/include/binja/debuginfo/slider.h`:

```h
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#pragma once

#include <binja/macho/macho.h>
#include <binja/utils/interval_map.h>

namespace Binja::DebugInfo {

class AddressSlider {
private:
    using Interval = Utils::Interval<uint64_t>;

public:
    void Map(Interval from, Interval to);
    std::optional<uint64_t> SlideAddress(uint64_t address);

    static AddressSlider CreateFromMachOSegments(const std::vector<MachO::Segment> &from,
                                                 const std::vector<MachO::Segment> &to);

private:
    Utils::IntervalMap<uint64_t, uint64_t> s1map_;
    Utils::IntervalMap<uint64_t, uint64_t> s2map_;
};

}// namespace Binja::DebugInfo
```

`debuginfo/include/binja/debuginfo/source_finder.h`:

```h
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#pragma once

#include <filesystem>
#include <map>
#include <set>

#include <binaryninjaapi.h>

#include <binja/types/errors.h>
#include <binja/types/uuid.h>

#include "./dwarf.h"

namespace Binja::DebugInfo {

class KDKError : public Types::DecodeError {
    using Types::DecodeError::DecodeError;
};

class SymbolSourceFinder {
public:
    explicit SymbolSourceFinder(std::filesystem::path path) : path_{std::move(path)} { VerifyKDK(); }
    std::set<std::filesystem::path> FindAllDSYMObjects();
    std::set<std::filesystem::path> FindAllMachoObjects();
    std::set<std::filesystem::path> FindAllKernelExtensions();

private:
    void VerifyKDK();

private:
    std::filesystem::path path_;
};

}// namespace Binja::DebugInfo

```

`debuginfo/include/binja/debuginfo/types.h`:

```h
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#pragma once

#include <string>
#include <unordered_map>
#include <unordered_set>
#include <vector>

#include <binaryninjaapi.h>

#include "dwarf.h"

namespace Binja::DebugInfo {

class TypeBuilderContext {
public:
    using Type = BinaryNinja::Type;
    using TypeRef = BinaryNinja::Ref<Type>;
    using QualifiedName = BinaryNinja::QualifiedName;

public:
    TypeBuilderContext(DwarfContextWrapper &dwarfContext) : dwarfContext_{dwarfContext} {}
    virtual ~TypeBuilderContext() = default;
    virtual BinaryNinja::QualifiedName DecodeQualifiedName(DwarfDieWrapper &die) = 0;
    virtual DwarfDieWrapper ResolveDie(DwarfDieWrapper &die) = 0;
    virtual bool TagDieAsProcessing(DwarfDieWrapper &die);
    virtual void UntagDieAsProcessing(DwarfDieWrapper &die);
    virtual std::optional<uint64_t> SlideAddress(DwarfOffset die, uint64_t address);

protected:
    DwarfContextWrapper &dwarfContext_;
    std::unordered_set<DwarfOffset> workingSet_;
};

class TypeBuilder {
public:
    TypeBuilder(TypeBuilderContext &ctx, DwarfDieWrapper &die)
        : ctx_{ctx}, die_{die}, dieReader_{die}, attributeReader_{die} {}

    virtual BinaryNinja::Ref<BinaryNinja::Type> Build() = 0;

    static bool IsTypeTag(llvm::dwarf::Tag tag);

protected:
    TypeBuilderContext &ctx_;
    DwarfDieWrapper &die_;
    DieReader dieReader_;
    AttributeReader attributeReader_;
};

class GenericTypeBuilder : public TypeBuilder {
public:
    GenericTypeBuilder(TypeBuilderContext &ctx, DwarfDieWrapper &die, bool decodeNamedTypes = false)
        : TypeBuilder{ctx, die}, decodeNamedTypes_{decodeNamedTypes},
          resolvedDie_{ctx.ResolveDie(die)}, resolvedDieReader_{resolvedDie_} {}
    BinaryNinja::Ref<BinaryNinja::Type> Build() override;

private:
    BinaryNinja::Ref<BinaryNinja::Type> DoBuild();

private:
    bool decodeNamedTypes_;
    DwarfDieWrapper resolvedDie_;
    DieReader resolvedDieReader_;
};

class BaseTypeBuilder : public TypeBuilder {
public:
    using TypeBuilder::TypeBuilder;
    BinaryNinja::Ref<BinaryNinja::Type> Build() override;
    BinaryNinja::Ref<BinaryNinja::Type> MapBNType(uint64_t size, uint64_t encoding);
};

class TypeModifierBuilder : public TypeBuilder {
public:
    using TypeBuilder::TypeBuilder;
    BinaryNinja::Ref<BinaryNinja::Type> Build() override;
    static bool IsTypeModifierTag(llvm::dwarf::Tag tag);
};

class TypedefBuilder : public TypeBuilder {
public:
    using TypeBuilder::TypeBuilder;
    BinaryNinja::Ref<BinaryNinja::Type> Build() override;
    static std::optional<DwarfDieWrapper> Resolve(DwarfDieWrapper &die);
};

class ArrayTypeBuilder : public TypeBuilder {
public:
    using TypeBuilder::TypeBuilder;
    BinaryNinja::Ref<BinaryNinja::Type> Build() override;

private:
    BinaryNinja::Ref<BinaryNinja::Type> BuildDynamic();
    BinaryNinja::Ref<BinaryNinja::Type> BuildStatic();
    std::optional<size_t> DecodeCountFromSubrange(DwarfDieWrapper &die);
    size_t GetDefaultLowerBound();
};

class FunctionTypeBuilder : public TypeBuilder {
public:
    using TypeBuilder::TypeBuilder;
    BinaryNinja::Ref<BinaryNinja::Type> Build() override;

private:
    struct DecodeParametersResult {
        bool hasVarArg;
        std::vector<BinaryNinja::FunctionParameter> parameters;
    };

private:
    BinaryNinja::Ref<BinaryNinja::Type> DecodeReturnType();
    BinaryNinja::Ref<BinaryNinja::CallingConvention> DecodeCallingConvention();
    DecodeParametersResult DecodeParameters();
    BinaryNinja::Ref<BinaryNinja::Type> DecodeParameterType(DwarfDieWrapper &die);
    BinaryNinja::Ref<BinaryNinja::Type> ApplyParameterTypeModifiers(BinaryNinja::Ref<BinaryNinja::Type> type, DwarfDieWrapper &die);
};

class EnumTypeBuilder : public TypeBuilder {
public:
    using TypeBuilder::TypeBuilder;
    BinaryNinja::Ref<BinaryNinja::Type> Build() override;

private:
    std::optional<DwarfDieWrapper> ResolveBaseType();
};

class CompositeTypeBuilder : public TypeBuilder {
public:
    using TypeBuilder::TypeBuilder;
    BinaryNinja::Ref<BinaryNinja::Type> Build() override;
    static bool IsCompositeTypeTag(llvm::dwarf::Tag tag);


private:
    BNStructureVariant DecodeVariant();
    BNMemberAccess GetDefaultMemberAccess();
    bool IsPacked();
    uint8_t DecodeAlignment();
    size_t DecodeWidth();

private:
    struct DecodeMemberResult {
        BinaryNinja::Ref<BinaryNinja::Type> type;
        std::string name;
        uint64_t offset;
        BNMemberAccess access;
    };

    struct DecodeVariableResult {
        BinaryNinja::Ref<BinaryNinja::Type> type;
        std::string name;
        BNMemberAccess access;
    };

private:
    std::optional<DecodeMemberResult> DecodeMember(DwarfDieWrapper &die);
    BNMemberAccess DecodeMemberAccess(std::optional<uint64_t> accessibility);
    std::optional<DecodeVariableResult> DecodeVariable(DwarfDieWrapper &die);
    void ProcessBitfields(BinaryNinja::StructureBuilder &builder);
    std::optional<DwarfDieWrapper> ProcessBitfield(BinaryNinja::StructureBuilder &builder, DwarfDieWrapper &start);
};

class PointerToMemberTypeBuilder : public TypeBuilder {
public:
    using TypeBuilder::TypeBuilder;
    BinaryNinja::Ref<BinaryNinja::Type> Build() override;
};

class NamedTypeReferenceBuilder : public TypeBuilder {
public:
    using TypeBuilder::TypeBuilder;
    BinaryNinja::Ref<BinaryNinja::Type> Build() override;
    BNNamedTypeReferenceClass DecodeTypeClass();
};

class TypeSizeDecoder {
public:
    TypeSizeDecoder(DwarfDieWrapper die) : die_{die} {}
    std::optional<uint64_t> Decode();

private:
    static std::optional<DwarfDieWrapper> ResolveType(DwarfDieWrapper &die);

private:
    DwarfDieWrapper die_;
};

}// namespace Binja::DebugInfo
```

`debuginfo/include/binja/debuginfo/variable.h`:

```h
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#pragma once

#include <binaryninjaapi.h>

#include "./dwarf.h"
#include "./types.h"

namespace Binja::DebugInfo {

struct DwarfVariableInfo {
    BinaryNinja::Ref<BinaryNinja::Type> type;
    BinaryNinja::QualifiedName qualifiedName;
    uint64_t location;
};

class VariableDecoder {
public:
    VariableDecoder(TypeBuilderContext &ctx, DwarfDieWrapper &die)
        : ctx_{ctx}, die_{die}, dieReader_{die_} {}

    std::optional<DwarfVariableInfo> Decode();

private:
    TypeBuilderContext &ctx_;
    DwarfDieWrapper die_;
    DieReader dieReader_;
};

}// namespace Binja::DebugInfo
```

`debuginfo/src/dsym.cpp`:

```cpp
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <llvm/DebugInfo/DWARF/DWARFContext.h>
#include <llvm/Object/MachO.h>
#include <llvm/Object/MachOUniversal.h>
#include <llvm/Support/Error.h>

#include <binja/types/errors.h>
#include <binja/utils/debug.h>

#include "debug.h"
#include "dsym.h"


using namespace Binja;
using namespace DebugInfo;
using namespace llvm;

namespace fs = std::filesystem;

/// LLVM error utility methods

namespace {

std::string LLVMErrorToString(llvm::Error error) {
    std::string out;
    llvm::raw_string_ostream ss{out};
    logAllUnhandledErrors(std::move(error), ss, "");
    return out;
}

std::string LLVMErrorToString(std::error_code ec) {
    llvm::Error error = llvm::errorCodeToError(ec);
    return LLVMErrorToString(std::move(error));
}

}// namespace


/// Dwarf object file

DwarfObjectFile::DwarfObjectFile(const std::filesystem::path &objectPath) {
    {
        ErrorOr<std::unique_ptr<MemoryBuffer>> buff = MemoryBuffer::getFileOrSTDIN(objectPath.string());
        if (!buff) {
            throw DwarfError{"failed to open file {}, error: {}", objectPath.string(),
                             LLVMErrorToString(buff.getError())};
        }
        buffer_ = std::move(buff.get());
    }

    {
        Expected<std::unique_ptr<object::Binary>> binary = object::createBinary(*buffer_);
        if (!binary) {
            throw DwarfError{"invalid dwarf symbol file {}, error: {}", objectPath.string(),
                             LLVMErrorToString(binary.takeError())};
        }
        binaryObject_ = std::move(binary.get());
    }

    if (auto *obj = llvm::dyn_cast<object::ObjectFile>(&*binaryObject_)) {
        dwarfContext_ = DWARFContext::create(*obj, DWARFContext::ProcessDebugRelocations::Process);
        Verify(dwarfContext_, FatalError);
        return;
    }

    if (auto *fat = dyn_cast<object::MachOUniversalBinary>(&*binaryObject_)) {
        for (auto &obj: fat->objects()) {
            if (auto mach = obj.getAsObjectFile()) {
                std::unique_ptr<object::MachOObjectFile> machObj = std::move(*mach);
                if (machObj->getArch() == llvm::Triple::aarch64) {
                    dwarfContext_ = DWARFContext::create(*machObj, DWARFContext::ProcessDebugRelocations::Process);
                    binaryObject_ = std::move(machObj);
                    Verify(dwarfContext_, FatalError);
                    return;
                }
            } else {
                throw DwarfError{"failed to open universal macho, err: {}", LLVMErrorToString(mach.takeError())};
            }
        }
        throw DwarfError{"dwarf object file does not have symbols for aarch64 architecture"};
    }
    throw DwarfError{"invalid dwarf object file"};
}

std::vector<fs::path> DwarfObjectFile::DsymFindObjects(const fs::path &symbolsPath) {
    std::vector<fs::path> objectPaths;
    if (auto objects = object::MachOObjectFile::findDsymObjectMembers(symbolsPath.string())) {
        if (objects->empty()) {
            objectPaths.push_back(symbolsPath);
        } else {
            for (const auto &object: *objects) {
                auto result = object::createBinary(object);
                if (result) {
                    objectPaths.push_back(object);
                } else if (llvm::errorToErrorCode(result.takeError()) != object::object_error::invalid_file_type) {
                    throw FatalError{"unexpected error: {}", LLVMErrorToString(result.takeError())};
                }
            }
        }
    } else {
        throw DwarfError{"invalid symbols file {}, error: {}", symbolsPath.string(),
                         LLVMErrorToString(objects.takeError())};
    }
    return objectPaths;
}

std::optional<Types::UUID> DwarfObjectFile::DecodeUUID() const {
    auto *macho = llvm::dyn_cast<llvm::object::MachOObjectFile>(dwarfContext_->getDWARFObj().getFile());
    BDVerify(macho);
    for (auto lc: macho->load_commands()) {
        if (lc.C.cmd != llvm::MachO::LC_UUID) {
            continue;
        }
        Types::UUID result;
        if (lc.C.cmdsize < sizeof(lc.C) + sizeof(result.data)) {
            throw Types::DecodeError{"too small LC_UUID command size: {}", lc.C.cmdsize};
        }
        memcpy(&result.data, lc.Ptr + sizeof(lc.C), sizeof(result.data));
        return result;
    }
    return std::nullopt;
}

std::vector<Binja::MachO::Segment> DwarfObjectFile::DecodeSegments() const {
    auto *macho = llvm::dyn_cast<llvm::object::MachOObjectFile>(dwarfContext_->getDWARFObj().getFile());
    BDVerify(macho);
    std::vector<Binja::MachO::Segment> result;
    for (auto lc: macho->load_commands()) {
        if (lc.C.cmd != llvm::MachO::LC_SEGMENT_64) {
            continue;
        }
        const auto *cmd = reinterpret_cast<const llvm::MachO::segment_command_64 *>(lc.Ptr);
        MachO::Segment segment;
        segment.name = cmd->segname;
        segment.vaStart = cmd->vmaddr;
        segment.vaLength = cmd->vmsize;
        segment.dataStart = cmd->fileoff;
        segment.dataLength = cmd->filesize;
        // TODO: decode sections and flags
        result.push_back(segment);
    }
    return result;
}

```

`debuginfo/src/dwarf.cpp`:

```cpp
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <llvm/DebugInfo/DWARF/DWARFContext.h>
#include <llvm/DebugInfo/DWARF/DWARFExpression.h>
#include <llvm/DebugInfo/DWARF/DWARFUnit.h>

#include <fmt/format.h>

#include <binja/utils/log.h>

#include "debug.h"
#include "dwarf.h"

using namespace llvm;
using namespace Binja;
using namespace DebugInfo;

using dwarf::Attribute;


/// LLVM error utility methods

namespace {

std::string LLVMErrorToString(llvm::Error error) {
    std::string out;
    llvm::raw_string_ostream ss{out};
    logAllUnhandledErrors(std::move(error), ss, "");
    return out;
}

std::string LLVMFormValueToString(const Optional<DWARFFormValue> &value, const char *defaultValue) {
    if (value) {
        Expected<const char *> cstr = value->getAsCString();
        if (cstr) {
            return std::string(cstr.get());
        }
        LLVMErrorToString(cstr.takeError());
    }
    return std::string(defaultValue);
}

}// namespace


/// Dwarf unit wrapper

std::vector<DwarfDebugInfoEntryWrapper> DwarfUnitWrapper::Dies() const {
    std::vector<DwarfDebugInfoEntryWrapper> entries;
    for (const auto &die: unit_.dies()) {
        entries.push_back(DwarfDebugInfoEntryWrapper{die, binaryId_});
    }
    return entries;
}

uint8_t DwarfUnitWrapper::GetAddressByteSize() const {
    return unit_.getAddressByteSize();
}

const dwarf::FormParams DwarfUnitWrapper::GetFormParams() {
    return unit_.getFormParams();
}


/// Dwarf die wrapper

Optional<DwarfDieWrapper> DwarfDieWrapper::GetAttributeValueAsReferencedDie(const llvm::DWARFFormValue &value) const {
    if (auto ref = die_.getAttributeValueAsReferencedDie(value)) {
        return DwarfDieWrapper{ref, (BinaryId) offset_.binaryId};
    }
    return llvm::None;
}

DwarfUnitWrapper DwarfDieWrapper::GetDwarfUnit() const {
    return DwarfUnitWrapper{*die_.getDwarfUnit(), (BinaryId) offset_.binaryId};
}

void DwarfDieWrapper::Dump(raw_ostream &ostream, uint32_t indent, llvm::DIDumpOptions opts) {
    die_.dump(ostream, indent, opts);
}

DwarfDieWrapper DwarfDieWrapper::GetParent() const {
    return DwarfDieWrapper{die_.getParent(), (BinaryId) offset_.binaryId};
}

DwarfDieWrapper DwarfDieWrapper::GetSibling() {
    return DwarfDieWrapper{die_.getSibling(), (BinaryId) offset_.binaryId};
}

DwarfDieWrapper DwarfDieWrapper::GetPreviousSibling() {
    return DwarfDieWrapper{die_.getPreviousSibling(), (BinaryId) offset_.binaryId};
}

bool DwarfDieWrapper::operator==(const DwarfDieWrapper &oth) const {
    return die_ == oth.die_ && offset_.binaryId == oth.offset_.binaryId;
}

DwarfDieWrapper::Iterator DwarfDieWrapper::Children() {
    return llvm::iterator_range<Detail::DwarfDieWrapperIterator>(
        Detail::DwarfDieWrapperIterator{GetFirstChild()},
        Detail::DwarfDieWrapperIterator{GetLastChild()});
}

DwarfDieWrapper DwarfDieWrapper::GetFirstChild() {
    return DwarfDieWrapper{die_.getFirstChild(), (BinaryId) offset_.binaryId};
}

DwarfDieWrapper DwarfDieWrapper::GetLastChild() {
    return DwarfDieWrapper{die_.getLastChild(), (BinaryId) offset_.binaryId};
}

Expected<DWARFAddressRangesVector> DwarfDieWrapper::GetAddressRanges() {
    return die_.getAddressRanges();
}

Expected<DWARFLocationExpressionsVector> DwarfDieWrapper::GetLocations(llvm::dwarf::Attribute attr) {
    return die_.getLocations(attr);
}


/// Dwarf context wrapper

DwarfDieWrapper DwarfContextWrapper::GetDIEForOffset(DwarfOffset offset) {
    DWARFDie die = entries_[offset.binaryId].object.GetDWARFContext().getDIEForOffset(offset.offset);
    return DwarfDieWrapper{die, (BinaryId) offset.binaryId};
}

std::vector<DwarfUnitWrapper> DwarfContextWrapper::GetNormalUnitsVector() {
    std::vector<DwarfUnitWrapper> result;
    for (size_t i = 0; i < entries_.size(); ++i) {
        llvm::DWARFContext &ctx = entries_[i].object.GetDWARFContext();
        for (const auto &unit: ctx.getNormalUnitsVector()) {
            result.push_back(DwarfUnitWrapper{*unit, (BinaryId) i});
        }
    }
    return result;
}

std::optional<uint64_t> DwarfContextWrapper::GetSlidAddress(DwarfOffset offset, uint64_t address) {
    if (auto value = entries_[offset.binaryId].slider.SlideAddress(address)) {
        return value;
    }
    return std::nullopt;
}


/// Attribute reader

std::optional<uint64_t> AttributeReader::ReadUInt(Attribute attribute, bool recursive) const {
    if (auto ref = FindAttribute(attribute, recursive)) {
        if (auto value = ref->getAsUnsignedConstant()) {
            return *value;
        }
    }
    return std::nullopt;
}

std::optional<uint64_t> AttributeReader::ReadInt(Attribute attribute, bool recursive) const {
    if (auto ref = FindAttribute(attribute, recursive)) {
        if (auto value = ref->getAsSignedConstant()) {
            return *value;
        }
    }
    return std::nullopt;
}

std::string AttributeReader::ReadString(Attribute attribute, const char *defaultValue, bool recursive) const {
    if (recursive) {
        return LLVMFormValueToString(die_.FindRecursively(attribute), defaultValue);
    }
    return LLVMFormValueToString(die_.Find(attribute), defaultValue);
}

std::optional<DwarfDieWrapper> AttributeReader::ReadReference(Attribute attribute, bool recursive) const {
    if (auto attr = FindAttribute(attribute, recursive)) {
        return die_.GetAttributeValueAsReferencedDie(*attr).getValue();
    }
    return std::nullopt;
}

std::string AttributeReader::ReadName(const char *defaultName, bool recursive) const {
    return ReadString(llvm::dwarf::DW_AT_name, defaultName, recursive);
}

bool AttributeReader::HasAttribute(Attribute attribute, bool recursive) const {
    if (auto ref = FindAttribute(attribute, recursive)) {
        return true;
    }
    return false;
}

std::string AttributeReader::ReadLinkageName(const char *defaultName, bool recursive) const {
    return ReadString(dwarf::DW_AT_linkage_name, defaultName, recursive);
}

std::optional<llvm::DWARFFormValue> AttributeReader::FindAttribute(
    llvm::dwarf::Attribute attr, bool recursive) const {
    if (recursive) {
        if (auto v = die_.FindRecursively(attr)) {
            return *v;
        }
    } else {
        if (auto v = die_.Find(attr)) {
            return *v;
        }
    }
    return std::nullopt;
}

std::optional<uint64_t> AttributeReader::ReadLocationAddress() const {
    auto formValue = die_.Find(dwarf::DW_AT_location);
    if (!formValue) {
        return std::nullopt;
    }

    auto block = formValue->getAsBlock();
    if (!block) {
        return std::nullopt;
    }

    auto unit = die_.GetDwarfUnit();

    // TODO: hardcoded endian
    DataExtractor data(StringRef((const char *) block->data(), block->size()), true, 0);
    DWARFExpression expression{data, unit.GetAddressByteSize(), unit.GetFormParams().Format};
    if (expression.begin() == expression.end()) {
        return std::nullopt;
    }

    auto operation = *expression.begin();
    if (operation.getCode() != dwarf::DW_OP_addr) {
        return std::nullopt;
    }
    return operation.getRawOperand(0);
}

/// DIE reader


std::string DieReader::Dump() const {
    auto addressSize = die_.GetDwarfUnit().GetAddressByteSize();
    std::string out;
    llvm::raw_string_ostream ss{out};
    llvm::DIDumpOptions opts{.AddrSize = addressSize};
    ss << "\n";
    ss << "=========================\n"
          "PARENTS: \n"
          "=========================\n";
    opts.ShowParents = true;
    opts.ShowAddresses = true;
    opts.ShowForm = true;
    die_.Dump(ss, 0, opts);
    ss << "\n";
    ss << "=========================\n"
          "CHILDREN: \n"
          "=========================\n";
    opts.ShowParents = false;
    opts.ShowChildren = true;
    die_.Dump(ss, 0, opts);
    return out;
}

namespace {

class QualifiedNameBuilder {
public:
    explicit QualifiedNameBuilder(DwarfDieWrapper &die) : die_{die} {}

    std::vector<std::string> Build() {
        using namespace dwarf;
        auto tag = die_.GetTag();
        AttributeReader reader{die_};
        switch (tag) {
            case DW_TAG_variable:
            case DW_TAG_array_type:
            case DW_TAG_base_type:
            case DW_TAG_subroutine_type:
            case DW_TAG_unspecified_type: {
                auto name = reader.ReadString(DW_AT_name);
                if (name.empty()) {
                    name = GetAnonymousName(die_);
                }
                qf_.push_back(name);
                DwarfDieWrapper parent = die_.GetParent();
                ScanContainer(parent);
                break;
            }
            default: {
                ScanContainer(die_);
                break;
            }
        }
        std::reverse(qf_.begin(), qf_.end());
        return std::move(qf_);
    }

private:
    void ScanContainer(DwarfDieWrapper &die) {
        using namespace dwarf;

        if (!die.IsValid()) {
            return;
        }

        auto tag = die.GetTag();
        AttributeReader reader{die};
        std::string name = reader.ReadString(DW_AT_name, "", true);

        switch (tag) {
            case llvm::dwarf::DW_TAG_compile_unit:
                return;
            case DW_TAG_namespace: {
                if (name.empty()) {
                    name = GetAnonymousName(die);
                }
                qf_.push_back(name);
                break;
            }
            case DW_TAG_lexical_block: {
                name = GetAnonymousName(die);
                qf_.push_back(name);
                break;
            }
            case DW_TAG_enumeration_type: {
                if (!reader.HasAttribute(DW_AT_enum_class)) {
                    break;
                }
                // fallthrough
            }
            case DW_TAG_base_type:
            case DW_TAG_typedef:
            case DW_TAG_template_alias: {
                VerifyDebugDumpDie(!name.empty(), die);
                if (name.empty()) {
                    name = GetAnonymousName(die);
                }
                qf_.push_back(name);
                break;
            }
            case DW_TAG_class_type: {
                if (auto base = reader.ReadReference(DW_AT_specification)) {
                    ScanContainer(*base);
                    return;
                }
                // fallthrough
            }
            case DW_TAG_structure_type:
            case DW_TAG_union_type: {
                if (!reader.HasAttribute(DW_AT_export_symbols)) {
                    if (name.empty()) {
                        name = GetAnonymousName(die);
                    }
                    qf_.push_back(name);
                }
                break;
            }
            case DW_TAG_inlined_subroutine: {
                auto base = reader.ReadReference(DW_AT_abstract_origin);
                VerifyDumpDie(base, die);
                ScanContainer(*base);
                break;
            }
            case DW_TAG_subprogram: {
                if (auto base = reader.ReadReference(DW_AT_specification)) {
                    ScanContainer(*base);
                    return;
                }
                if (auto base = reader.ReadReference(DW_AT_abstract_origin)) {
                    ScanContainer(*base);
                    return;
                }
                if (name.empty()) {
                    name = GetAnonymousName(die);
                }
                qf_.push_back(name);
                break;
            }
            default: {
                throw DwarfError{"unexpected container type {}, DIE: {}",
                                 TagString(tag).str(), DieReader{die}.Dump()};
            }
        }

        DwarfDieWrapper parent = die.GetParent();
        ScanContainer(parent);
    }

    static const char *GetAnonymousNameSuffix(dwarf::Tag tag) {
        switch (tag) {
            case dwarf::DW_TAG_namespace:
                return "ns";
            case dwarf::DW_TAG_structure_type:
                return "struct";
            case dwarf::DW_TAG_class_type:
                return "class";
            case dwarf::DW_TAG_union_type:
                return "union";
            case dwarf::DW_TAG_subprogram:
            case dwarf::DW_TAG_inlined_subroutine:
                return "function";
            case dwarf::DW_TAG_subroutine_type:
                return "functor";
            case dwarf::DW_TAG_enumeration_type:
                return "enum";
            case dwarf::DW_TAG_lexical_block:
                return "block";
            default:
                throw FatalError{"unexpected dwarf tag {}", dwarf::TagString(tag).str()};
        }
    }

    static std::string GetAnonymousName(DwarfDieWrapper &die) {
        return fmt::format("__anon_{}_{:#04x}_{:#08x}", GetAnonymousNameSuffix(die.GetTag()),
                           die.GetOffset().binaryId, die.GetOffset().offset);
    }

private:
    DwarfDieWrapper &die_;
    std::vector<std::string> qf_;
};

}// namespace

std::vector<std::string> DieReader::ReadQualifiedName() const {
    return QualifiedNameBuilder{die_}.Build();
}

uint8_t DieReader::ReadAddressSize() const {
    return die_.GetDwarfUnit().GetAddressByteSize();
}

```

`debuginfo/src/dwarf_task.cpp`:

```cpp
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <binaryninjaapi.h>

#include <llvm/DebugInfo/DWARF/DWARFDie.h>

#include <binja/utils/debug.h>
#include <binja/utils/log.h>

#include "debug.h"
#include "dwarf_task.h"
#include "function.h"
#include "name_index.h"
#include "types.h"
#include "variable.h"

using namespace Binja;
using namespace DebugInfo;
using namespace llvm;
using namespace BinaryNinja;

namespace {

class OrderedTypeBuilderContext : public TypeBuilderContext {
public:
    OrderedTypeBuilderContext(DwarfContextWrapper &dwarfContext, NameIndex &index)
        : TypeBuilderContext{dwarfContext}, index_{index} {}

    QualifiedName DecodeQualifiedName(DwarfDieWrapper &die) {
        return index_.DecodeQualifiedName(die);
    }

    DwarfDieWrapper ResolveDie(DwarfDieWrapper &die) {
        return index_.ResolveDieOffset(die.GetOffset());
    }

private:
    NameIndex index_;
};

}// namespace

void DwarfImportTask::Import() {
    DwarfContextWrapper dwarfContext = BuildDwarfContext();
    BDLogInfo("importing symbols from {} dwarf objects",
              dwarfContext.GetDwarfObjectCount());

    NameIndex nameIndex{dwarfContext};

    // phase 1
    {
        const auto &units = dwarfContext.GetNormalUnitsVector();
        size_t numUnits = units.size();
        BDLogInfo("indexing types from {} units", numUnits);

        for (size_t i = 0; i < numUnits; ++i) {
            for (const auto &dieInfo: units[i].Dies()) {
                DwarfDieWrapper die = dwarfContext.GetDIEForOffset(dieInfo.GetOffset());
                if (!IsNamedTypeTag(die.GetTag())) {
                    continue;
                }
                if (AttributeReader{die}.ReadName("", true).empty()) {
                    continue;
                }
                nameIndex.IndexDie(die);
            }
            monitor_(DwarfImportPhase::IndexingQualifiedNames, i, numUnits);
        }
    }

    if (options_.importTypes) {
        // phase 2
        size_t numNamedNodes = nameIndex.NumEntries();
        OrderedTypeBuilderContext context{dwarfContext, nameIndex};
        BDLogInfo("indexed {} named entities", numNamedNodes);
        size_t index = 0;
        nameIndex.VisitEntries([&](const std::vector<std::string> &qualifiedName, DwarfOffset dieOffset) {
            DwarfDieWrapper die = dwarfContext.GetDIEForOffset(dieOffset);
            if (IsNamedTypeTag(die.GetTag()) && !AttributeReader{die}.ReadName("", true).empty()) {
                auto type = GenericTypeBuilder{context, die, true}.Build();
                auto name = QualifiedName{qualifiedName};
                debugInfo_.AddType(name.GetString(), type);
            }
            monitor_(DwarfImportPhase::DecodingTypes, ++index, ++numNamedNodes);
        });
        BDLogInfo("imported {} named types to binary view", numNamedNodes);
    } else {
        BDLogInfo("skipping type import");
    }

    // phase 3
    {
        const auto &units = dwarfContext.GetNormalUnitsVector();
        size_t numUnits = units.size();
        BDLogInfo("importing functions and globals from {} units", numUnits);

        OrderedTypeBuilderContext context{dwarfContext, nameIndex};
        std::set<uint64_t> importedFunctions;
        std::set<uint64_t> importedGlobals;
        for (size_t i = 0; i < numUnits; ++i) {
            for (const auto &dieInfo: units[i].Dies()) {
                DwarfDieWrapper die = dwarfContext.GetDIEForOffset(dieInfo.GetOffset());
                switch (die.GetTag()) {
                    case dwarf::DW_TAG_subprogram: {
                        if (!options_.importFunctions) {
                            break;
                        }

                        auto info = FunctionDecoder{context, die}.Decode();
                        if (!info) {
                            break;
                        }
                        auto [_, ok] = importedFunctions.insert(info->entryPoint);
                        if (!ok) {
                            continue;
                        }

                        QualifiedName name = nameIndex.DecodeQualifiedName(die);
                        std::string rawName = AttributeReader{die}.ReadLinkageName(
                            name.GetString().c_str(),
                            true);

                        DebugFunctionInfo symbol{
                            name.back(),
                            name.GetString(),
                            rawName,
                            info->entryPoint,
                            info->type,
                            binaryView_.GetDefaultPlatform(),
                            {},
                            {}
                        };
                        symbol.type = info->type;

                        debugInfo_.AddFunction(symbol);
                        break;
                    }
                    case dwarf::DW_TAG_constant:
                    case dwarf::DW_TAG_variable: {
                        if (!options_.importGlobals) {
                            break;
                        }
                        auto info = VariableDecoder{context, die}.Decode();
                        if (!info) {
                            break;
                        }

                        auto [_, ok] = importedGlobals.insert(info->location);
                        if (!ok) {
                            continue;
                        }

                        Ref<Symbol> symbol = new Symbol{
                            BNSymbolType::DataSymbol,
                            info->qualifiedName.back(),
                            info->qualifiedName.GetString(),
                            fmt::format("data_{:#016x}", info->location),
                            info->location,
                        };
                        debugInfo_.AddDataVariable(info->location, info->type, info->qualifiedName.GetString());
                        break;
                    }
                    default: {
                        break;
                    }
                }
            }
            monitor_(DwarfImportPhase::ImportingFunctionsAndGlobals, i, numUnits);
        }

        BDLogInfo("imported {} functions", importedFunctions.size());
        BDLogInfo("imported {} globals", importedGlobals.size());
    }
}

bool DwarfImportTask::IsNamedTypeTag(dwarf::Tag tag) {
    switch (tag) {
        case dwarf::DW_TAG_typedef:
        case dwarf::DW_TAG_array_type:
        case dwarf::DW_TAG_enumeration_type:
        case dwarf::DW_TAG_subroutine_type:
        case dwarf::DW_TAG_structure_type:
        case dwarf::DW_TAG_union_type:
        case dwarf::DW_TAG_class_type:
        case dwarf::DW_TAG_ptr_to_member_type:
        case dwarf::DW_TAG_unspecified_type:
            return true;
        default:
            return false;
    }
}

DwarfContextWrapper DwarfImportTask::BuildDwarfContext() {
    auto targetObjects = MachO::MachBinaryView{binaryView_}.ReadMachOHeaders();
    std::vector<DwarfContextWrapper::Entry> entries;
    for (const auto &sourceObject: dwarfObjects_) {
        DwarfObjectFile object{sourceObject};
        auto uuid = object.DecodeUUID();
        BDVerify(uuid);
        BDVerify(targetObjects.contains(*uuid));
        auto symbolSegments = object.DecodeSegments();
        entries.emplace_back(DwarfContextWrapper::Entry{
            .object = std::move(object),
            .slider = AddressSlider::CreateFromMachOSegments(
                symbolSegments, targetObjects[*uuid])});
    }
    return DwarfContextWrapper{std::move(entries)};
}

```

`debuginfo/src/function.cpp`:

```cpp
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <binaryninjaapi.h>

#include <binja/utils/log.h>

#include "function.h"

using namespace Binja;
using namespace DebugInfo;

using namespace BinaryNinja;
namespace DW = llvm::dwarf;

std::optional<DwarfFunctionInfo> FunctionDecoder::Decode() {
    DwarfFunctionInfo info;
    if (auto entry = DecodeEntryPoint()) {
        info.entryPoint = *entry;
    } else {
        return std::nullopt;
    }

    if (auto slidAddress = ctx_.SlideAddress(die_.GetOffset(), info.entryPoint)) {
        info.entryPoint = *slidAddress;
    } else {
        BDLogWarn("cannot slide address {:#016x} using binary {}",
                  info.entryPoint, die_.GetOffset().binaryId);
        return std::nullopt;
    }

    info.qualifiedName = ctx_.DecodeQualifiedName(die_);
    info.type = FunctionTypeBuilder{ctx_, die_}.Build();
    info.isNoReturn = DecodeIsNoReturn();

    return info;
}

std::optional<uint64_t> FunctionDecoder::DecodeEntryPoint() {
    const AttributeReader &attributeReader = dieReader_.AttrReader();
    if (auto value = attributeReader.ReadUInt(DW::DW_AT_low_pc)) {
        return value;
    }
    if (auto ranges = die_.GetAddressRanges()) {
        if (ranges->size() != 0) {
            return ranges.get().begin()->LowPC;
        }
    }
    if (auto value = attributeReader.ReadUInt(DW::DW_AT_entry_pc)) {
        return value;
    }
    return std::nullopt;
}

bool FunctionDecoder::DecodeIsNoReturn() {
    return dieReader_.AttrReader().HasAttribute(DW::DW_AT_noreturn, true);
}

```

`debuginfo/src/macho_task.cpp`:

```cpp
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <filesystem>
#include <mutex>

#include <binaryninjaapi.h>
#include <binaryninjacore.h>

#include <taskflow/taskflow.hpp>

#include <binja/utils/binary_view.h>
#include <binja/utils/debug.h>
#include <binja/utils/log.h>

#include "macho_task.h"

using namespace Binja;
using namespace DebugInfo;
using namespace BinaryNinja;
namespace fs = std::filesystem;


/// MachO import task

MachOImportTask::MachOImportTask(std::vector<fs::path> sources, BinaryView &binaryView,
                                 BinaryNinja::DebugInfo &debugInfo,
                                 MachOImportOptions options, MachOImportProgressMonitor &monitor)
    : binaryView_{binaryView}, debugInfo_{debugInfo}, sources_{sources},
      options_{options}, monitor_{monitor},
      targetSegments_{MachO::MachBinaryView{binaryView}.ReadMachOHeaders()} {
    for (const auto &symbol: binaryView.GetSymbols()) {
        registeredSymbols_[symbol->GetAddress()] = symbol->GetFullName();
    }
}

void MachOImportTask::Import() {
    tf::Taskflow taskflow;
    tf::Executor executor;

    std::mutex mtx;
    size_t numAdded = 0;
    std::atomic<size_t> completed;
    taskflow.for_each(sources_.begin(), sources_.end(), [&](const auto &source) {
        auto binary = OpenMachO(source);
        completed++;
        if (!binary) {
            return;
        }

        BDLogDebug("importing symbols from macho {}", binary->GetFile()->GetOriginalFilename());
        MachO::MachBinaryViewDataBackend dataBackend{*binary};
        auto uuid = MachO::MachHeaderParser{dataBackend, binary->GetStart()}.DecodeUUID();
        BDVerify(uuid);
        auto targetSegments = targetSegments_[*uuid];

        AddressSlider slider = AddressSlider::CreateFromMachOSegments(
            MachO::MachHeaderParser{dataBackend, binary->GetStart()}.DecodeSegments(),
            targetSegments);

        std::vector<Ref<Symbol>> symbols = binary->GetSymbols();
        std::lock_guard lock{mtx};
        monitor_(completed, sources_.size());

        for (Ref<Symbol> symbol: symbols) {
            if (AddSymbol(*symbol, slider)) {
                numAdded++;
            }
        }
    });

    executor.run(taskflow).wait();
    BDLogInfo("Imported {} symbols from {} macho sources", numAdded, sources_.size());
}

Ref<BinaryView> MachOImportTask::OpenMachO(const fs::path &path) {
    Json::Value options;
    Json::Value preferredArchs;
    preferredArchs.append("arm64e");
    preferredArchs.append("arm64");
    options["files.universal.architecturePreference"] = preferredArchs;// TODO: dynamic
    options["analysis.debugInfo.internal"] = false;
    auto bv = Utils::OpenBinaryView(path, false, nullptr, nullptr, options);
    if (!bv->HasSymbols()) {
        BDLogWarn("ignoring macho image {} with no symbols", path.string());
        return nullptr;
    }
    MachO::MachBinaryViewDataBackend dataBackend{*bv};
    auto uuid = MachO::MachHeaderParser{dataBackend, bv->GetStart()}.DecodeUUID();
    if (!uuid) {
        BDLogWarn("ignoring macho image {} with no LC_UUID", path.string());
        return nullptr;
    }
    if (!targetSegments_.contains(*uuid)) {
        BDLogDebug("ignoring macho image {} with uuid {} since its uuid does not match with any "
                   "segment in binary view",
                   path.string(), *uuid);
        return nullptr;
    }
    return bv;
}

bool MachOImportTask::AddSymbol(const Symbol &symbol, AddressSlider &slider) {
    std::string qualifiedName = symbol.GetFullName();
    uint64_t address = symbol.GetAddress();

    if (symbol.GetType() != BNSymbolType::FunctionSymbol && symbol.GetType() != BNSymbolType::DataSymbol) {
        BDLogDebug("ignoring external symbol {} at {}",
                   symbol.GetFullName(), symbol.GetAddress());
        return false;
    }

    if (symbol.GetType() == BNSymbolType::FunctionSymbol && !options_.importFunctions) {
        return false;
    }

    if (symbol.GetType() == BNSymbolType::DataSymbol && !options_.importDataVariables) {
        return false;
    }

    if (auto slidAddress = slider.SlideAddress(address)) {
        address = *slidAddress;
    } else {
        BDLogWarn("failed to slide address {}", address);
        return false;
    }

    if (registeredSymbols_.contains(address)) {
        BDLogWarn("skipping symbol {} since another symbol {} already exist at address {:#016x}",
                  qualifiedName, registeredSymbols_[address], address);
        return false;
    }

    Ref<Symbol> newSymbol = new Symbol{
        symbol.GetType(),
        qualifiedName,
        address,
        symbol.GetBinding(),
        symbol.GetNameSpace()};

    registeredSymbols_[address] = qualifiedName;

    switch (symbol.GetType()) {
        case FunctionSymbol: {
            DebugFunctionInfo info{
                symbol.GetShortName(),
                symbol.GetFullName(),
                symbol.GetRawName(),
                address,
                nullptr,
                binaryView_.GetDefaultPlatform(),
                {},
                {}
            };
            debugInfo_.AddFunction(info);
            break;
        }
        case DataSymbol: {
            debugInfo_.AddDataVariable(address, Type::VoidType(), symbol.GetFullName());
            break;
        }
        case ImportAddressSymbol:
        case ImportedFunctionSymbol:
        case ImportedDataSymbol:
        case ExternalSymbol:
        case LibraryFunctionSymbol:
        case SymbolicFunctionSymbol:
        case LocalLabelSymbol:
            BDVerify(false);
    }
    return true;
}

```

`debuginfo/src/name_index.cpp`:

```cpp
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <binaryninjaapi.h>

#include "debug.h"
#include "name_index.h"
#include "types.h"

using namespace Binja;
using namespace DebugInfo;

namespace DW = llvm::dwarf;

using BinaryNinja::QualifiedName;
using llvm::DWARFDie;

using Type = BinaryNinja::Type;
using TypeRef = BinaryNinja::Ref<Type>;


/// Type builder context

namespace {

class BasicTypeBuilderContext : public TypeBuilderContext {
public:
    BasicTypeBuilderContext(DwarfContextWrapper &dwarfContext)
        : TypeBuilderContext{dwarfContext} {}

    QualifiedName DecodeQualifiedName(DwarfDieWrapper &die) {
        return QualifiedName{DieReader{die}.ReadQualifiedName()};
    }

    DwarfDieWrapper ResolveDie(DwarfDieWrapper &die) {
        return die;
    }
};

}// namespace


/// Name index

void NameIndex::IndexDie(DwarfDieWrapper &die) {
    auto tag = die.GetTag();
    Verify(TypeBuilder::IsTypeTag(tag), FatalError);

    AttributeReader attributeReader{die};
    Verify(!attributeReader.ReadName("", true).empty(), FatalError);

    std::vector<DwarfOffset> hierarchy = DecodeHierarchy(die.GetOffset());
    InsertHierarchy(hierarchy);
}

void NameIndex::InsertHierarchy(const std::vector<DwarfOffset> &hierarchy) {
    Node *node = &root_;
    for (DwarfOffset newDieOffset: hierarchy) {
        DwarfDieWrapper newDie = ResolveDieOffset(newDieOffset);

        std::string name = AttributeReader{newDie}.ReadName("", true);
        if (name.empty()) {
            name = GetAnonymousName(newDie);
        }

        auto it = node->children.find(name);
        if (it != node->children.end()) {
            if (nodeInfoVector_[it->second.info].baseDie != newDie.GetOffset()) {
                node = MergeNode(*node, name, newDieOffset);
            } else {
                node = &it->second;
            }
        } else {
            node = InsertNode(*node, name, newDie.GetOffset());
        }
    }
}

std::vector<DwarfOffset> NameIndex::DecodeHierarchy(DwarfOffset offset) {
    using namespace llvm::dwarf;
    DwarfDieWrapper die = ResolveDieOffset(offset);
    std::vector<DwarfOffset> result;

    std::function<void(DwarfDieWrapper &)> scanContainer = [&](DwarfDieWrapper &die) {
        auto tag = die.GetTag();
        AttributeReader reader{die};
        std::string name = reader.ReadString(DW_AT_name, "", true);

        switch (tag) {
            case DW_TAG_compile_unit:
                return;
            case DW_TAG_namespace:
            case DW_TAG_lexical_block: {
                result.push_back(die.GetOffset());
                break;
            }
            case DW_TAG_enumeration_type:
            case DW_TAG_base_type:
            case DW_TAG_typedef:
            case DW_TAG_template_alias: {
                VerifyDebugDumpDie(!name.empty(), die);
                result.push_back(die.GetOffset());
                break;
            }
            case DW_TAG_class_type: {
                if (auto base = reader.ReadReference(DW_AT_specification)) {
                    scanContainer(*base);
                    return;
                }
                // fallthrough
            }
            case DW_TAG_structure_type:
            case DW_TAG_union_type: {
                if (!reader.HasAttribute(DW_AT_export_symbols)) {
                    result.push_back(die.GetOffset());
                }
                break;
            }
            case DW_TAG_inlined_subroutine: {
                auto base = reader.ReadReference(DW_AT_abstract_origin);
                VerifyDumpDie(base, die);
                scanContainer(*base);
                break;
            }
            case DW_TAG_subprogram: {
                if (auto base = reader.ReadReference(DW_AT_specification)) {
                    scanContainer(*base);
                    return;
                }
                if (auto base = reader.ReadReference(DW_AT_abstract_origin)) {
                    scanContainer(*base);
                    return;
                }
                result.push_back(die.GetOffset());
                break;
            }
            default: {
                throw DwarfError{"unexpected container type {}, DIE: {}",
                                 TagString(tag).str(), DieReader{die}.Dump()};
            }
        }

        DwarfDieWrapper parent = die.GetParent();
        scanContainer(parent);
    };

    switch (die.GetTag()) {
        case DW_TAG_unspecified_type:
        case DW_TAG_variable:
        case DW_TAG_array_type:
        case DW_TAG_base_type:
        case DW_TAG_subroutine_type: {
            result.push_back(offset);
            break;
        }
        default: {
            scanContainer(die);
            break;
        }
    }

    std::reverse(result.begin(), result.end());
    BDVerify(!result.empty());
    return result;
}

NameIndex::Node *NameIndex::MergeNode(Node &parentNode, std::string name, DwarfOffset newDieOffset) {
    Node &baseNode = parentNode.children.find(name)->second;
    NodeInfo &baseNodeInfo = nodeInfoVector_[baseNode.info];
    for (int i = 0; i <= baseNodeInfo.forkIndex; ++i) {
        std::string childName;
        if (i != 0) {
            childName = fmt::format("{}__{}", name, i);
        } else {
            childName = name;
        }

        Node &child = parentNode.children.find(childName)->second;
        NodeInfo &childInfo = nodeInfoVector_[child.info];

        if (childInfo.baseDie == newDieOffset) {
            return &child;
        }

        switch (EvaluateMergeStrategy(childInfo.baseDie, newDieOffset)) {
            case NodeMergeStrategy::replace: {
                aliasMap_.insert({childInfo.baseDie, child.info});
                childInfo.baseDie = newDieOffset;
                return &child;
            }
            case NodeMergeStrategy::alias: {
                aliasMap_.insert({newDieOffset, child.info});
                return &child;
            }
            case NodeMergeStrategy::fork: {
                break;
            }
        }
    }

    std::string newName = fmt::format("{}__{}", name, ++baseNodeInfo.forkIndex);
    return InsertNode(parentNode, newName, newDieOffset);
}

DwarfDieWrapper NameIndex::ResolveDieOffset(DwarfOffset offset) {
    auto it = aliasMap_.find(offset);
    if (it != aliasMap_.end()) {
        return dwarfContext_.GetDIEForOffset(nodeInfoVector_[it->second].baseDie);
    }
    return dwarfContext_.GetDIEForOffset(offset);
}

namespace {

bool IsSameType(const Type &lhs, const Type &rhs);

bool IsSameStructureType(const BinaryNinja::Structure &lhs, const BinaryNinja::Structure &rhs) {
    if (lhs.GetWidth() != rhs.GetWidth()) {
        return false;
    }

    auto lhsMembers = lhs.GetMembers();
    auto rhsMembers = rhs.GetMembers();
    if (lhsMembers.size() != rhsMembers.size()) {
        return false;
    }

    for (size_t i = 0; i < lhsMembers.size(); ++i) {
        const auto &m1 = lhsMembers[i];
        const auto &m2 = rhsMembers[i];
        if (m1.name != m2.name || m1.offset != m2.offset || m1.access != m2.access || m1.scope != m2.scope) {
            return false;
        }
        if (m1.type && m2.type) {
            if (!IsSameType(*m1.type, *m2.type)) {
                return false;
            }
        } else if (m1.type || m2.type) {
            return false;
        }
    }

    return true;
}

bool IsSameType(const Type &lhs, const Type &rhs) {
    if (lhs.IsStructure() && rhs.IsStructure()) {
        auto s1 = lhs.GetStructure();
        auto s2 = rhs.GetStructure();
        return IsSameStructureType(*s1, *s2);
    }
    if (lhs.IsPointer() && rhs.IsPointer()) {
        auto b1 = lhs.GetChildType();
        auto b2 = rhs.GetChildType();
        return IsSameType(*b1, *b2);
    }
    if (lhs.IsNamedTypeRefer() && rhs.IsNamedTypeRefer()) {
        auto n1 = lhs.GetNamedTypeReference();
        auto n2 = rhs.GetNamedTypeReference();
        return n1->GetName() == n2->GetName();
    }
    return BNTypesEqual(lhs.GetObject(), rhs.GetObject());
}

}// namespace

NameIndex::NodeMergeStrategy NameIndex::EvaluateMergeStrategy(DwarfOffset currentDieOffset, DwarfOffset newDieOffset) {
    using namespace DW;
    Verify(currentDieOffset != newDieOffset, FatalError);

    DwarfDieWrapper currentDie = ResolveDieOffset(currentDieOffset);
    auto currentTag = currentDie.GetTag();
    bool currentIsType = TypeBuilder::IsTypeTag(currentTag);

    DwarfDieWrapper newDie = ResolveDieOffset(newDieOffset);
    auto newTag = newDie.GetTag();
    bool newIsType = TypeBuilder::IsTypeTag(newTag);

    if (currentIsType != newIsType) {
        return NameIndex::NodeMergeStrategy::fork;
    }

    if (currentIsType) {
        DwarfDieWrapper resolvedCurrentDie = currentDie;
        if (currentTag == DW_TAG_typedef) {
            if (auto resolved = TypedefBuilder::Resolve(currentDie)) {
                resolvedCurrentDie = ResolveDieOffset(resolved->GetOffset());
            }
        }
        DwarfDieWrapper resolvedNewDie = newDie;
        if (currentTag == DW_TAG_typedef) {
            if (auto resolved = TypedefBuilder::Resolve(newDie)) {
                resolvedNewDie = ResolveDieOffset(resolved->GetOffset());
            }
        }

        if (resolvedNewDie.GetOffset() == resolvedCurrentDie.GetOffset()) {
            return NodeMergeStrategy::alias;
        }

        BasicTypeBuilderContext ctx{dwarfContext_};
        TypeRef currentType = GenericTypeBuilder{ctx, resolvedCurrentDie, true}.Build();
        TypeRef newType = GenericTypeBuilder{ctx, resolvedNewDie, true}.Build();
        if (currentType && newType) {
            if (IsSameType(*currentType, *newType)) {
                return NodeMergeStrategy::alias;
            }
        }
    }

    if ((CompositeTypeBuilder::IsCompositeTypeTag(currentTag) || currentTag == DW_TAG_enumeration_type) && (CompositeTypeBuilder::IsCompositeTypeTag(newTag) || newTag == DW_TAG_enumeration_type)) {
        auto isForwardDeclaration = [](DwarfDieWrapper &die) {
            AttributeReader attributeReader{die};
            return attributeReader.HasAttribute(DW_AT_declaration);
        };
        bool currentIsDecl = isForwardDeclaration(currentDie);
        bool newIsDecl = isForwardDeclaration(newDie);
        if (currentIsDecl && !newIsDecl) {
            return NodeMergeStrategy::replace;
        }
        if (newIsDecl) {
            return NodeMergeStrategy::alias;
        }
    }

    return NodeMergeStrategy::fork;
}

const char *NameIndex::GetAnonymousNameSuffix(DW::Tag tag) {
    using namespace DW;
    switch (tag) {
        case DW_TAG_namespace:
            return "ns";
        case DW_TAG_structure_type:
            return "struct";
        case DW_TAG_class_type:
            return "class";
        case DW_TAG_union_type:
            return "union";
        case DW_TAG_subprogram:
        case DW_TAG_inlined_subroutine:
            return "function";
        case DW_TAG_subroutine_type:
            return "functor";
        case DW_TAG_enumeration_type:
            return "enum";
        case DW_TAG_lexical_block:
            return "block";
        case DW_TAG_unspecified_type:
            return "unknown";
        default:
            throw FatalError{"unexpected dwarf tag {}", TagString(tag).str()};
    }
}

std::string NameIndex::GetAnonymousName(DwarfDieWrapper &die) {
    return fmt::format("__anon_{}_{:#04x}_{:#08x}", GetAnonymousNameSuffix(die.GetTag()), die.GetOffset().binaryId, die.GetOffset().offset);
}

QualifiedName NameIndex::DecodeQualifiedName(DwarfDieWrapper &die) {
    std::vector<DwarfOffset> hierarchy = DecodeHierarchy(die.GetOffset());
    BDVerify(hierarchy.size() > 0);
    QualifiedName qualifiedName;
    const Node *node = &root_;
    for (DwarfOffset offset: hierarchy) {
        node = node ? FindChild(*node, offset) : nullptr;
        if (node) {
            const auto &info = nodeInfoVector_[node->info];
            qualifiedName.push_back(info.name);
        } else {
            auto child = ResolveDieOffset(offset);
            auto name = AttributeReader{child}.ReadName("", true);
            if (name.empty()) {
                name = GetAnonymousName(child);
            }
            qualifiedName.push_back(name);
        }
    }
    return qualifiedName;
}

const NameIndex::Node *NameIndex::FindChild(const NameIndex::Node &parent, DwarfOffset dieOffset) {
    auto die = ResolveDieOffset(dieOffset);
    std::string name = AttributeReader{die}.ReadName("", true);
    if (name.empty()) {
        name = GetAnonymousName(die);
    }

    auto it = parent.children.find(name);
    if (it == parent.children.end()) {
        return nullptr;
    }

    if (nodeInfoVector_[it->second.info].baseDie == die.GetOffset()) {
        return &it->second;
    }

    for (int i = 0; i <= nodeInfoVector_[it->second.info].forkIndex; i++) {
        std::string forkName = i == 0 ? name : fmt::format("{}__{}", name, i);
        auto forkIt = parent.children.find(forkName);
        const auto &info = nodeInfoVector_[forkIt->second.info];
        if (info.baseDie == dieOffset) {
            return &forkIt->second;
        }
    }

    return nullptr;
}

NameIndex::Node *NameIndex::InsertNode(NameIndex::Node &parent, std::string name, DwarfOffset dieOffset) {
    NodeInfoVectorIndex newEntryInfoIndex = nodeInfoVector_.size();
    NodeInfo newEntryInfo{name, dieOffset, 0};
    nodeInfoVector_.push_back(newEntryInfo);
    auto [it, ok] = parent.children.insert({std::move(name), Node{newEntryInfoIndex, {}}});
    Verify(ok, FatalError);
    ++nodeCount_;
    return &it->second;
}

void NameIndex::VisitEntries(std::function<void(const std::vector<std::string> &, DwarfOffset)> cb) {
    std::vector<std::string> name;
    std::function<void(const Node &)> iterateNode = [&](const Node &node) {
        for (const auto &child: node.children) {
            name.push_back(child.first);
            cb(name, nodeInfoVector_[child.second.info].baseDie);
            iterateNode(child.second);
            name.pop_back();
        }
    };
    iterateNode(root_);
}

```

`debuginfo/src/plugin_dsym.cpp`:

```cpp
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <filesystem>
#include <type_traits>

#include <binaryninjaapi.h>
#include <binaryninjacore.h>
#include <fmt/format.h>

#include <binja/macho/macho.h>
#include <binja/utils/log.h>
#include <binja/utils/settings.h>

#include "debug.h"
#include "dsym.h"
#include "dwarf_task.h"
#include "plugin_dsym.h"
#include "source_finder.h"

using namespace Binja;
using namespace DebugInfo;
using namespace BinaryNinja;
using namespace llvm;

namespace fs = std::filesystem;


void PluginDSYM::Load(BinaryNinja::DebugInfo &debugInfo, DwarfImportProgressMonitor &monitor) {
    auto source = GetSymbolSource();
    if (!source) {
        BDLogDebug("skipping dwarf symbols importing since no "
                   "dwarf source can be found");
        return;
    }

    SymbolSourceFinder sourceFinder{*source};

    std::vector<fs::path> dwarfObjects;
    for (const auto &dSYMFile: sourceFinder.FindAllDSYMObjects()) {
        try {
            auto objects = DwarfObjectFile::DsymFindObjects(dSYMFile);
            dwarfObjects.insert(dwarfObjects.end(), objects.begin(), objects.end());
        } catch (const DwarfError &e) {
            BDLogError("failed to open symbols file {}, error: {}",
                       dSYMFile.string(), e.what());
            return;
        }
    }

    auto targetObjects = MachO::MachBinaryView{binaryView_}.ReadMachOHeaders();
    std::vector<fs::path> sourceObjects;

    for (const auto &dwarfObject: dwarfObjects) {
        DwarfObjectFile objectFile{dwarfObject};
        auto uuid = objectFile.DecodeUUID();
        if (!uuid) {
            BDLogWarn("ignoring dwarf object {} since it does not have LC_UUID",
                      dwarfObject.string());
            continue;
        }

        if (!targetObjects.contains(*uuid)) {
            BDLogWarn("ignoring dwarf object {} since its uuid does not match with "
                      "any macho headers in binary view",
                      dwarfObject.string());
            continue;
        }

        sourceObjects.push_back(dwarfObject);
    }

    auto bnSettings = BinaryNinja::Settings::Instance();
    Utils::BinjaSettings settings {binaryView_.GetObject(), bnSettings->GetObject()};

    BDVerify(settings.DWARFEnabled());
    ImportOptions options{
        .importTypes = settings.DWARFLoadTypes(),
        .importFunctions = settings.DWARFLoadFunctions(),
        .importGlobals = settings.DWARFLoadDataVariables(),
    };

    BDLogInfo("found {} dwarf symbols sources at {}", dwarfObjects.size(), source->string());
    try {
        DwarfImportTask task{sourceObjects, binaryView_, debugInfo, options, monitor};
        task.Import();
    } catch (const Types::DecodeError &e) {
        BDLogError("Failed to load symbols, error: {}", e.what());
    }
}

std::optional<fs::path> PluginDSYM::GetSymbolSource() {
    auto bnSettings = BinaryNinja::Settings::Instance();
    Utils::BinjaSettings settings {binaryView_.GetObject(), bnSettings->GetObject()};
    BDVerify(settings.DWARFEnabled());

    if (auto path = settings.DebugInfoSymbolsSearchPath()) {
        if (!fs::exists(*path)) {
            BDLogError("skipping dwarf import since specified symbols directory {} does not exist", *path);
            return std::nullopt;
        }
        return *path;
    }

    fs::path binarySource = binaryView_.GetFile()->GetOriginalFilename();

    fs::path symbolsDirectory = fmt::format("{}.symbols", binarySource.string());
    if (fs::exists(symbolsDirectory)) {
        return symbolsDirectory;
    }
    BDLogInfo("no symbols source directory found at {}", symbolsDirectory.string());

    fs::path dsym = fmt::format("{}.dSYM", binarySource.string());

    if (fs::exists(dsym)) {
        return dsym;
    }
    BDLogInfo("no dSYM found at {}", dsym.string());

    return std::nullopt;
}

/// Progress monitor

namespace {

class ImportProgressMonitor : public DwarfImportProgressMonitor {
private:
    using Callback = bool (*)(void *, size_t, size_t);

public:
    explicit ImportProgressMonitor(Callback cb, void *pctx) : cb_{cb}, pctx_{pctx} {}

    bool operator()(DwarfImportPhase phase, size_t done, size_t total) override {
        return cb_(pctx_, done, total);
    }

private:
    Callback cb_;
    void *pctx_;
};

}// namespace


/// Binary ninja plugin API

namespace {

bool IsValidForBinaryView(void *context, BNBinaryView *handle) {
    BinaryNinja::BinaryView bv{handle};

    auto bnSettings = BinaryNinja::Settings::Instance();
    Utils::BinjaSettings settings {bv.GetObject(), bnSettings->GetObject()};
    if (!settings.DWARFEnabled()) {
        BDLogInfo("skipping dsym debug info import since it is disabled");
        return false;
    }

    PluginDSYM plugin{bv};
    if (plugin.GetSymbolSource()) {
        return true;
    }

    BDLogInfo("skipping dsym debug info import since no valid symbol source found");
    return false;
}

template <typename ...Extra>
struct DoParseDebugInfoImpl {
    static bool Invoke(void *context, BNDebugInfo *debugInfoHandle, BNBinaryView *binaryViewHandle, Extra..., bool(progress)(void *, size_t, size_t), void *pctx) {
        BinaryNinja::DebugInfo debugInfo{debugInfoHandle};
        BinaryNinja::BinaryView binaryView{binaryViewHandle};

        ImportProgressMonitor monitor{progress, pctx};
        PluginDSYM plugin{binaryView};
        plugin.Load(debugInfo, monitor);
        return true;
    }
};
using DoParseDebugInfo = std::conditional_t<BN_CURRENT_CORE_ABI_VERSION >= 35, DoParseDebugInfoImpl<BNBinaryView *>, DoParseDebugInfoImpl<>>;

}// namespace

void PluginDSYM::RegisterPlugin() {
    BNRegisterDebugInfoParser(kPluginName, IsValidForBinaryView, DoParseDebugInfo::Invoke, nullptr);
}

```

`debuginfo/src/plugin_function_starts.cpp`:

```cpp
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <mutex>
#include <type_traits>

#include <binja/macho/macho.h>
#include <binja/utils/log.h>
#include <binja/utils/settings.h>

#include "plugin_function_starts.h"

using namespace Binja;
using namespace DebugInfo;

namespace BN = BinaryNinja;

/// Binary ninja plugin API

namespace {

bool IsValidForBinaryView(void *context, BNBinaryView *handle) {
    BinaryNinja::BinaryView bv{handle};

    if (bv.GetTypeName() != "MachO-KC") {
        return false;
    }

    auto bnSettings = BinaryNinja::Settings::Instance();
    Utils::BinjaSettings settings {bv.GetObject(), bnSettings->GetObject()};

    if (!settings.FunctionStartsEnabled()) {
        BDLogInfo("skipping LC_FUNCTION_STARTS debug info import since it is disabled");
        return false;
    }

    return true;
}

template <typename ...Extra>
struct DoParseDebugInfoImpl {
    static bool Invoke(void *context, BNDebugInfo *debugInfoHandle, BNBinaryView *binaryViewHandle, Extra..., bool(progress)(void *, size_t, size_t), void *pctx) {
        BN::BinaryView binaryView{binaryViewHandle};
        BN::Ref<BN::BinaryView> rawView = binaryView.GetParentView();

        auto bnSettings = BinaryNinja::Settings::Instance();
        Utils::BinjaSettings settings {binaryView.GetObject(), bnSettings->GetObject()};
        BDVerify(settings.FunctionStartsEnabled());

        BN::DebugInfo debugInfo{debugInfoHandle};
        MachO::MachBinaryViewDataBackend dataBackend{*rawView};

        std::vector<MachO::Fileset> filesets = MachO::MachHeaderParser{dataBackend, 0}.DecodeFilesets();
        for (size_t i=0; i<filesets.size(); ++i) {
            MachO::Fileset &fileset = filesets[i];
            uint64_t addr;
            if (!binaryView.GetAddressForDataOffset(fileset.fileOffset, addr)) {
                continue;
            }

            MachO::MachHeaderParser parser{dataBackend, fileset.fileOffset};
            std::vector<uint64_t> functionStarts = parser.DecodeFunctionStarts();
            BDLogInfo("found {} entries from LC_FUNCTION_START in fileset {}", functionStarts.size(), fileset.name);

            for (auto start: functionStarts) {
                BN::Ref<BN::Segment> segment = binaryView.GetSegmentAt(start);
                if (!segment) {
                    BDLogDebug("ignoring LC_FUNCTION_START entry {:#016x} is not in any segment", start);
                    continue;
                }
                bool isFunction = segment->GetFlags() & BNSegmentFlag::SegmentContainsCode;
                if (!isFunction) {
                    BDLogWarn("ignoring LC_FUNCTION_START entry {:#016x} since it is not in segment "
                              "with SegmentContainsCode", start);
                    continue;
                }

                std::string name = fmt::format("sub_{:x}", start);
                BN::DebugFunctionInfo info{
                    name,
                    name,
                    name,
                    start,
                    nullptr,
                    nullptr,
                    {},
                    {}
                };
                debugInfo.AddFunction(info);
            }
            progress(pctx, i, filesets.size());
        }
        return true;
    }
};
using DoParseDebugInfo = std::conditional_t<BN_CURRENT_CORE_ABI_VERSION >= 35, DoParseDebugInfoImpl<BNBinaryView *>, DoParseDebugInfoImpl<>>;

}// namespace

void PluginFunctionStarts::RegisterPlugin() {
    BNRegisterDebugInfoParser(kPluginName, IsValidForBinaryView, DoParseDebugInfo::Invoke, nullptr);
}

```

`debuginfo/src/plugin_macho.cpp`:

```cpp
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <filesystem>
#include <type_traits>

#include <binaryninjaapi.h>
#include <binaryninjacore.h>
#include <fmt/format.h>

#include <binja/utils/log.h>
#include <binja/utils/settings.h>

#include "macho_task.h"
#include "plugin_macho.h"
#include "source_finder.h"

using namespace Binja;
using namespace DebugInfo;
using namespace BinaryNinja;
using namespace llvm;

namespace fs = std::filesystem;


void PluginMacho::Load(BinaryNinja::DebugInfo &debugInfo, MachOImportProgressMonitor &monitor) {
    auto source = GetSymbolSource();
    if (!source) {
        BDLogDebug("skipping macho symbols import since valid source cannot be found");
        return;
    }

    auto bnSettings = BinaryNinja::Settings::Instance();
    Utils::BinjaSettings settings {binaryView_.GetObject(), bnSettings->GetObject()};
    BDVerify(settings.MachoEnabled());

    MachOImportOptions options {
        .importFunctions = settings.MachoLoadFunctions(),
        .importDataVariables = settings.MachoLoadDataVariables()
    };

    if (!options.importFunctions) {
        BDLogDebug("skipping macho function symbols import since import functions is disabled");
    }

    if (!options.importDataVariables) {
        BDLogDebug("skipping macho data variable symbols import since import data variables is disabled");
    }

    auto machoObjects = SymbolSourceFinder{*source}.FindAllMachoObjects();
    BDLogInfo("found {} macho symbol sources at {}", machoObjects.size(), source->string());
    MachOImportTask task{std::vector<fs::path>{machoObjects.begin(), machoObjects.end()},
                         binaryView_, debugInfo, options, monitor};
    task.Import();
}

std::optional<fs::path> PluginMacho::GetSymbolSource() {
    auto bnSettings = BinaryNinja::Settings::Instance();
    Utils::BinjaSettings settings {binaryView_.GetObject(), bnSettings->GetObject()};
    BDVerify(settings.MachoEnabled());

    if (auto path = settings.DebugInfoSymbolsSearchPath()) {
        if (!fs::exists(*path)) {
            BDLogError("skipping macho import since specified symbols directory {} does not exist", *path);
            return std::nullopt;
        }
        return *path;
    }

    fs::path binarySource = binaryView_.GetFile()->GetOriginalFilename();

    fs::path symbolsDirectory = fmt::format("{}.symbols", binarySource.string());

    if (fs::exists(symbolsDirectory)) {
        return symbolsDirectory;
    }
    BDLogInfo("no symbols source directory found at {}", symbolsDirectory.string());
    return std::nullopt;
}


/// Progress monitor

namespace {

class ImportProgressMonitor : public MachOImportProgressMonitor {
private:
    using Callback = bool (*)(void *, size_t, size_t);

public:
    ImportProgressMonitor(Callback cb, void *pctx) : cb_{cb}, pctx_{pctx} {}

    bool operator()(size_t done, size_t total) override {
        return cb_(pctx_, done, total);
    }

private:
    Callback cb_;
    void *pctx_;
};

}// namespace


/// Binary ninja plugin API

namespace {

bool IsValidForBinaryView(void *context, BNBinaryView *handle) {
    BinaryNinja::BinaryView bv{handle};

    auto bnSettings = BinaryNinja::Settings::Instance();
    Utils::BinjaSettings settings {bv.GetObject(), bnSettings->GetObject()};
    if (!settings.MachoEnabled()) {
        BDLogInfo("skipping Mach-O debug info import since it is disabled");
        return false;
    }

    PluginMacho plugin{bv};
    if (plugin.GetSymbolSource()) {
        return true;
    }

    BDLogInfo("skipping import since no valid symbol source found");
    return false;
}

template <typename ...Extra>
struct DoParseDebugInfoImpl {
    static bool Invoke(void *context, BNDebugInfo *debugInfoHandle, BNBinaryView *binaryViewHandle, Extra..., bool(progress)(void *, size_t, size_t), void *pctx) {
        BinaryNinja::DebugInfo debugInfo{debugInfoHandle};
        BinaryNinja::BinaryView binaryView{binaryViewHandle};

        PluginMacho plugin{binaryView};
        ImportProgressMonitor monitor{progress, pctx};
        plugin.Load(debugInfo, monitor);
        return true;
    }
};
using DoParseDebugInfo = std::conditional_t<BN_CURRENT_CORE_ABI_VERSION >= 35, DoParseDebugInfoImpl<BNBinaryView *>, DoParseDebugInfoImpl<>>;

}// namespace

void PluginMacho::RegisterPlugin() {
    BNRegisterDebugInfoParser(kPluginName, IsValidForBinaryView, DoParseDebugInfo::Invoke, nullptr);
}

```

`debuginfo/src/plugin_symtab.cpp`:

```cpp
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <llvm/Demangle/ItaniumDemangle.h>
#include <type_traits>

#include <binja/macho/macho.h>
#include <binja/utils/demangle.h>
#include <binja/utils/log.h>
#include <binja/utils/settings.h>

#include "plugin_symtab.h"

using namespace Binja;
using namespace DebugInfo;

namespace BN = BinaryNinja;
namespace LD = llvm::itanium_demangle;

// LLVM demangler

namespace {
class BumpPointerAllocator {
    struct BlockMeta {
        BlockMeta* Next;
        size_t Current;
    };

    static constexpr size_t AllocSize = 4096;
    static constexpr size_t UsableAllocSize = AllocSize - sizeof(BlockMeta);

    alignas(long double) char InitialBuffer[AllocSize];
    BlockMeta* BlockList = nullptr;

    void grow() {
        char* NewMeta = static_cast<char *>(std::malloc(AllocSize));
        if (NewMeta == nullptr)
            std::terminate();
        BlockList = new (NewMeta) BlockMeta{BlockList, 0};
    }

    void* allocateMassive(size_t NBytes) {
        NBytes += sizeof(BlockMeta);
        BlockMeta* NewMeta = reinterpret_cast<BlockMeta*>(std::malloc(NBytes));
        if (NewMeta == nullptr)
            std::terminate();
        BlockList->Next = new (NewMeta) BlockMeta{BlockList->Next, 0};
        return static_cast<void*>(NewMeta + 1);
    }

public:
    BumpPointerAllocator()
        : BlockList(new (InitialBuffer) BlockMeta{nullptr, 0}) {}

    void* allocate(size_t N) {
        N = (N + 15u) & ~15u;
        if (N + BlockList->Current >= UsableAllocSize) {
            if (N > UsableAllocSize)
                return allocateMassive(N);
            grow();
        }
        BlockList->Current += N;
        return static_cast<void*>(reinterpret_cast<char*>(BlockList + 1) +
                                   BlockList->Current - N);
    }

    void reset() {
        while (BlockList) {
            BlockMeta* Tmp = BlockList;
            BlockList = BlockList->Next;
            if (reinterpret_cast<char*>(Tmp) != InitialBuffer)
                std::free(Tmp);
        }
        BlockList = new (InitialBuffer) BlockMeta{nullptr, 0};
    }

    ~BumpPointerAllocator() { reset(); }
};

class DefaultAllocator {
    BumpPointerAllocator Alloc;

public:
    void reset() { Alloc.reset(); }

    template<typename T, typename ...Args> T *makeNode(Args &&...args) {
        return new (Alloc.allocate(sizeof(T)))
            T(std::forward<Args>(args)...);
    }

    void *allocateNodeArray(size_t sz) {
        return Alloc.allocate(sizeof(LD::Node *) * sz);
    }
};
}  // unnamed namespace

/// Binary ninja plugin API

namespace {

bool IsValidForBinaryView(void *context, BNBinaryView *handle) {
    BinaryNinja::BinaryView bv{handle};

    if (bv.GetTypeName() != "MachO-KC") {
        return false;
    }

    auto bnSettings = BinaryNinja::Settings::Instance();
    Utils::BinjaSettings settings {bv.GetObject(), bnSettings->GetObject()};

    if (!settings.SymtabEnabled()) {
        BDLogInfo("skipping KC SYMTAB debug info import since it is disabled");
        return false;
    }

    return true;
}

std::string NodeToString(const LD::Node* node) {
    LD::OutputBuffer buffer;
    LD::initializeOutputBuffer(nullptr, nullptr, buffer, 512);
    node->print(buffer);
    std::string result {buffer.getBuffer(), buffer.getCurrentPosition()};
    free(buffer.getBuffer());
    return result;
}

std::optional<BN::DebugFunctionInfo> ParseMangledFunctionInfo(const MachO::Symbol& symbol) {
    std::string name = symbol.name;

    bool isMangled = name.starts_with("_Z");
    if (!isMangled) {
        return std::nullopt;
    }

    LD::ManglingParser<DefaultAllocator> parser{
        name.c_str(),
        name.c_str() + name.size()
    };

    LD::Node* root = parser.parse();
    if (!root) {
        return std::nullopt;
    }

    if (root->getKind() != LD::Node::KFunctionEncoding) {
        return std::nullopt;
    }

    auto* func = static_cast<LD::FunctionEncoding*>(root);
    std::string functionName = NodeToString(func->getName());
    return BN::DebugFunctionInfo{
        functionName,
        Utils::Demangle(name),
        name,
        symbol.addr,
        nullptr,
        nullptr,
        {},
        {}
    };
}

BN::DebugFunctionInfo ParseFunctionInfo(const MachO::Symbol& symbol) {
    if (auto info = ParseMangledFunctionInfo(symbol)) {
        return *info;
    }

    std::string name = symbol.name;

    return BN::DebugFunctionInfo {
        name,
        name,
        name,
        symbol.addr,
        nullptr,
        nullptr,
        {},
        {}
    };
}

template <typename ...Extra>
struct DoParseDebugInfoImpl {
    static bool Invoke(void *context, BNDebugInfo *debugInfoHandle, BNBinaryView *binaryViewHandle, Extra..., bool(progress)(void *, size_t, size_t), void *pctx) {
        BN::BinaryView binaryView{binaryViewHandle};
        BN::Ref<BN::BinaryView> rawView = binaryView.GetParentView();

        auto bnSettings = BinaryNinja::Settings::Instance();
        Utils::BinjaSettings settings {binaryView.GetObject(), bnSettings->GetObject()};

        if (!settings.SymtabLoadFunctions()) {
            BDLogInfo("functions debug info import from KC SYMTAB is disabled");
        }

        if (!settings.SymtabLoadDataVariables()) {
            BDLogInfo("data variables debug info import from KC SYMTAB is disabled");
        }

        BN::DebugInfo debugInfo{debugInfoHandle};
        MachO::MachBinaryViewDataBackend dataBackend{*rawView};

        std::vector<MachO::Fileset> filesets = MachO::MachHeaderParser{dataBackend, 0}.DecodeFilesets();
        for (size_t i=0; i<filesets.size(); ++i) {
            MachO::Fileset &fileset = filesets[i];
            MachO::MachHeaderParser parser{dataBackend, fileset.fileOffset};
            std::vector<MachO::Symbol> symbols = parser.DecodeSymbols();

            for (auto &symbol: symbols) {
                BN::Ref<BN::Segment> segment = binaryView.GetSegmentAt(symbol.addr);
                if (!segment) {
                    BDLogDebug("ignoring nlist_64 entry, n_value {:#016x} is not in any segment", symbol.addr);
                    continue;
                }
                bool isFunction = segment->GetFlags() & BNSegmentFlag::SegmentContainsCode;
                if (isFunction && settings.SymtabLoadFunctions()) {
                    debugInfo.AddFunction(ParseFunctionInfo(symbol));
                } else if (settings.SymtabLoadDataVariables()) {
                    debugInfo.AddDataVariable(symbol.addr, BN::Type::VoidType(), symbol.name);
                }
            }
            progress(pctx, i, filesets.size());
        }
        return true;
    }
};
using DoParseDebugInfo = std::conditional_t<BN_CURRENT_CORE_ABI_VERSION >= 35, DoParseDebugInfoImpl<BNBinaryView *>, DoParseDebugInfoImpl<>>;

}// namespace

void PluginSymtab::RegisterPlugin() {
    BNRegisterDebugInfoParser(kPluginName, IsValidForBinaryView, DoParseDebugInfo::Invoke, nullptr);
}

```

`debuginfo/src/slider.cpp`:

```cpp
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <binja/utils/debug.h>
#include <binja/utils/log.h>

#include "slider.h"

using namespace Binja;
using namespace DebugInfo;

void AddressSlider::Map(AddressSlider::Interval from, AddressSlider::Interval to) {
    BDVerify(from.upper() - from.lower() == to.upper() - to.lower());
    BDVerify(from.upper() - from.lower() > 0);
    BDVerify(s1map_.find(from) == s1map_.end());
    BDVerify(s2map_.find(to) == s2map_.end());
    s1map_.insert(from, to.lower());
    s2map_.insert(to, from.lower());
}

std::optional<uint64_t> AddressSlider::SlideAddress(uint64_t address) {
    auto it = s1map_.find(address);
    if (it == s1map_.end()) {
        return std::nullopt;
    }
    return it->second + address - it->first.lower();
}

AddressSlider AddressSlider::CreateFromMachOSegments(const std::vector<MachO::Segment> &from,
                                                     const std::vector<MachO::Segment> &to) {
    AddressSlider slider;
    for (const auto &targetSegment: to) {
        if (!targetSegment.vaLength) {
            BDLogDebug("skipping binary segment {} with no VA", targetSegment.name);
            continue;
        }
        auto sourceSegmentIt = std::find_if(from.begin(), from.end(), [&targetSegment](const auto &sourceSegment) {
            return sourceSegment.name == targetSegment.name;
        });
        if (sourceSegmentIt == from.end()) {
            BDLogDebug("binary segment {} did not match with any segment in symbol",
                       targetSegment.name);
            continue;
        }
        if (!sourceSegmentIt->vaLength) {
            BDLogDebug("symbol segment {} had zero VA length", targetSegment.name);
            continue;
        }
        size_t vaLength = std::min(sourceSegmentIt->vaLength, targetSegment.vaLength);
        AddressSlider::Interval sourceAddressRange{
            sourceSegmentIt->vaStart, sourceSegmentIt->vaStart + vaLength};
        AddressSlider::Interval destAddressRange{
            targetSegment.vaStart, targetSegment.vaStart + vaLength};
        if (sourceSegmentIt->vaLength != targetSegment.vaLength) {
            BDLogWarn("va range trimmed due to length mismatch at segment {} [{:#016x}, {:#016x})->[{:#016x}, {:#016x})",
                      targetSegment.name, sourceAddressRange.lower(), sourceAddressRange.upper(),
                      destAddressRange.lower(), destAddressRange.upper());
        }
        BDLogDebug("mapping segment {}", targetSegment.name);
        slider.Map(sourceAddressRange, destAddressRange);
    }
    return slider;
}

```

`debuginfo/src/source_finder.cpp`:

```cpp
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <arpa/inet.h>
#include <fstream>

#include <mio/mmap.hpp>
#include <llvm/Object/MachO.h>

#include <binja/macho/macho.h>
#include <binja/utils/debug.h>
#include <binja/utils/log.h>
#include <binja/utils/span_reader.h>

#include "dsym.h"
#include "source_finder.h"

using namespace Binja;
using namespace DebugInfo;

namespace fs = std::filesystem;

/// KDK

namespace {

static const std::set<uint32_t> kMachOMagics{
    llvm::MachO::MH_MAGIC_64,
    llvm::MachO::MH_CIGAM_64,
};

static const std::set<uint32_t> kFileTypes{
    llvm::MachO::MH_KEXT_BUNDLE,
    llvm::MachO::MH_EXECUTE,

};

static const std::set<uint32_t> kFATMagics{
    llvm::MachO::FAT_MAGIC_64,
    llvm::MachO::FAT_CIGAM_64,
    llvm::MachO::FAT_CIGAM,
    llvm::MachO::FAT_MAGIC,
};

static const std::set<uint32_t> kCPUTypes{
    llvm::MachO::CPU_TYPE_ARM64};

static bool IsSupportedMachO(std::span<const char> data) {
    const auto *header = Utils::SpanReader{data}.Read<llvm::MachO::mach_header_64>();

    if (!kMachOMagics.contains(header->magic)) {
        return false;
    }

    if (!kFileTypes.contains(header->filetype)) {
        return false;
    }

    if (!kCPUTypes.contains(header->cputype)) {
        return false;
    }

    if ((header->flags & llvm::MachO::MH_INCRLINK) != 0) {
        return false;
    }

    return true;
}

static bool IsSupportedFat(std::span<const char> data) {
    Utils::SpanReader reader{data};
    const auto *header = reader.Read<llvm::MachO::fat_header>();

    if (!kFATMagics.contains(header->magic)) {
        return false;
    }

    std::vector<llvm::MachO::fat_arch> supportedArchs;
    for (uint32_t i = 0; i < ntohl(header->nfat_arch); ++i) {
        const auto *arch = reader.Read<llvm::MachO::fat_arch>();
        if (!kCPUTypes.contains(ntohl(arch->cputype))) {
            continue;
        }
        auto size = ntohl(arch->size);
        auto offset = ntohl(arch->offset);
        if (offset + size > data.size()) {
            continue;
        }
        if (IsSupportedMachO(data.subspan(offset, size))) {
            return true;
        }
    }

    return false;
}

}// namespace

void SymbolSourceFinder::VerifyKDK() {
    if (!fs::exists(path_)) {
        throw KDKError{"path {} does not exist", path_.string()};
    }
    if (!fs::is_directory(path_)) {
        throw KDKError{"KDK at path {} is not a directory", path_.string()};
    }
}

std::set<fs::path> SymbolSourceFinder::FindAllDSYMObjects() {
    std::set<fs::path> result;
    if (fs::is_directory(path_) && path_.extension() == ".dSYM") {
        result.insert(path_);
    } else {
        for (const auto &dirent: fs::recursive_directory_iterator(path_)) {
            if (dirent.is_directory() && dirent.path().extension() == ".dSYM") {
                auto [_, ok] = result.insert(dirent.path());
                BDVerify(ok);
            }
        }
    }
    BDLogDebug("found {} dSYM files {}", result.size(), path_.string());
    return result;
}

std::set<fs::path> SymbolSourceFinder::FindAllMachoObjects() {
    std::set<fs::path> result;
    for (const auto &dirent: fs::recursive_directory_iterator(path_)) {
        if (dirent.is_directory()) {
            continue;
        }

        mio::mmap_source file{dirent.path().string()};
        std::span<const char> data{file.data(), file.size()};
        Utils::SpanReader reader{data};

        auto magic = *reader.Read<uint32_t>();

        bool isFat = kFATMagics.contains(magic);
        bool isMacho = kMachOMagics.contains(magic);
        if (!isFat && !isMacho) {
            continue;
        }

        try {
            if (isFat && !IsSupportedFat(data)) {
                continue;
            }
            if (isMacho && !IsSupportedMachO(data)) {
                continue;
            }
        } catch (const Utils::SpanReader::ReadError &e) {
            BDLogWarn("failed to verify file at path {}, error: {}", dirent.path().string(), e.what());
            continue;
        }

        auto [_, ok] = result.insert(dirent.path());
        BDVerify(ok);
    }
    return result;
}

std::set<fs::path> SymbolSourceFinder::FindAllKernelExtensions() {
    std::set<fs::path> result;
    for (const auto &dirent: fs::recursive_directory_iterator(path_)) {
        if (dirent.is_directory() && dirent.path().extension() == "kext") {
            auto [_, ok] = result.insert(dirent.path());
            BDVerify(ok);
        }
    }
    return result;
}

```

`debuginfo/src/types.cpp`:

```cpp
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <unordered_set>

#include <llvm/DebugInfo/DWARF/DWARFUnit.h>

#include <binja/utils/log.h>

#include "debug.h"
#include "types.h"

namespace BN = BinaryNinja;
namespace DW = llvm::dwarf;
using namespace Binja;
using namespace DebugInfo;

using BN::Type;
using TypeRef = BN::Ref<Type>;
using BN::QualifiedName;

const DW::Tag DW_TAG_APPLE_ptrauth_type = (DW::Tag) 0x4300;// NOLINT(readability-identifier-naming)


/// Type builder

bool TypeBuilder::IsTypeTag(DW::Tag tag) {
    static const std::unordered_set<DW::Tag> kDwarfTypeTags{
        DW::DW_TAG_array_type,
        DW::DW_TAG_class_type,
        DW::DW_TAG_enumeration_type,
        DW::DW_TAG_pointer_type,
        DW::DW_TAG_reference_type,
        DW::DW_TAG_string_type,
        DW::DW_TAG_structure_type,
        DW::DW_TAG_subroutine_type,
        DW::DW_TAG_typedef,
        DW::DW_TAG_union_type,
        DW::DW_TAG_ptr_to_member_type,
        DW::DW_TAG_set_type,
        DW::DW_TAG_subrange_type,
        DW::DW_TAG_base_type,
        DW::DW_TAG_const_type,
        DW::DW_TAG_file_type,
        DW::DW_TAG_packed_type,
        DW::DW_TAG_thrown_type,
        DW::DW_TAG_volatile_type,
        DW::DW_TAG_restrict_type,
        DW::DW_TAG_interface_type,
        DW::DW_TAG_unspecified_type,
        DW::DW_TAG_shared_type,
        DW::DW_TAG_rvalue_reference_type,
        DW::DW_TAG_coarray_type,
        DW::DW_TAG_dynamic_type,
        DW::DW_TAG_atomic_type,
        DW::DW_TAG_immutable_type,
        DW_TAG_APPLE_ptrauth_type,
    };
    return kDwarfTypeTags.contains(tag);
}

/// Base type builder

BN::Ref<BinaryNinja::Type> BaseTypeBuilder::Build() {
    DebugVerify(die_.GetTag() == DW::DW_TAG_base_type, FatalError);

    std::optional<uint64_t> encoding = attributeReader_.ReadUInt(DW::DW_AT_encoding);
    VerifyDumpDie(encoding, die_);

    std::optional<uint64_t> size = attributeReader_.ReadUInt(DW::DW_AT_byte_size);
    VerifyDumpDie(size, die_);

    std::vector<std::string> qualifiedName = dieReader_.ReadQualifiedName();
    VerifyDumpDie(qualifiedName.size() == 1, die_);
    return MapBNType(*size, *encoding);
}

BinaryNinja::Ref<BinaryNinja::Type> BaseTypeBuilder::MapBNType(uint64_t size, uint64_t encoding) {
    switch (encoding) {
        case DW::DW_ATE_boolean:
            return Type::BoolType();
        case DW::DW_ATE_address:
            return Type::PointerType(size, Type::VoidType());
        case DW::DW_ATE_signed:
        case DW::DW_ATE_signed_char:
            return Type::IntegerType(size, true);
        case DW::DW_ATE_unsigned:
        case DW::DW_ATE_unsigned_char:
            return Type::IntegerType(size, false);
        case DW::DW_ATE_UTF: {
            switch (size) {
                case 1:
                    return Type::IntegerType(1, true);
                case 2:
                    return Type::WideCharType(2, "char16_t");
                default:
                    return Type::WideCharType(size);
            }
            case DW::DW_ATE_float:
            case DW::DW_ATE_decimal_float:
                return Type::FloatType(size);
            case DW::DW_ATE_ASCII:
            case DW::DW_ATE_UCS:
            case DW::DW_ATE_signed_fixed:
            case DW::DW_ATE_unsigned_fixed:
            case DW::DW_ATE_complex_float:
            case DW::DW_ATE_imaginary_float:
            case DW::DW_ATE_packed_decimal:
            case DW::DW_ATE_numeric_string:
            case DW::DW_ATE_edited:
                throw DwarfError{"base type encoding {} not supported for DIE {}",
                                 encoding, dieReader_.Dump()};
            default:
                throw DwarfError{"invalid base type encoding {} for DIE {}",
                                 encoding, dieReader_.Dump()};
        }
    }
}


/// Type modifier builder

BinaryNinja::Ref<BinaryNinja::Type> TypeModifierBuilder::Build() {
    auto tag = die_.GetTag();
    Verify(IsTypeModifierTag(tag), FatalError);

    auto base = attributeReader_.ReadReference(DW::DW_AT_type);

    BN::Ref<Type> baseType;
    if (base) {
        baseType = GenericTypeBuilder{ctx_, *base}.Build();
    } else {
        baseType = Type::VoidType();
    }

    BN::TypeBuilder builder{baseType};

    switch (tag) {
        case DW::DW_TAG_const_type:
            builder.SetConst(true);
            break;
        case DW::DW_TAG_volatile_type:
            builder.SetVolatile(true);
            break;
        case DW::DW_TAG_pointer_type:
            return Type::PointerType(dieReader_.ReadAddressSize(), baseType);
        case DW::DW_TAG_reference_type:
            return Type::PointerType(dieReader_.ReadAddressSize(), baseType,
                                     false, false, BNReferenceType::ReferenceReferenceType);
        case DW::DW_TAG_rvalue_reference_type:
            return Type::PointerType(dieReader_.ReadAddressSize(), baseType,
                                     false, false, BNReferenceType::ReferenceReferenceType);
        case DW::DW_TAG_packed_type:
            if (baseType->IsStructure()) {
                BN::StructureBuilder structureBuilder{baseType->GetStructure()};
                structureBuilder.SetPacked(true);
                return Type::StructureType(structureBuilder.Finalize());
            }
            BDLogWarn("attempt to apply packed modifier on non struct type {}, DIE: {}",
                      baseType->GetTypeName().GetString(), dieReader_.Dump());
            return baseType;
        case DW_TAG_APPLE_ptrauth_type:
            return baseType;
        case DW::DW_TAG_atomic_type:
        case DW::DW_TAG_immutable_type:
        case DW::DW_TAG_restrict_type:
        case DW::DW_TAG_shared_type:
            BDLogWarn("encountered unsupported type modifier tag {}", DW::TagString(tag).str());
            return baseType;
        default:
            BDLogWarn("encountered unknown type modifier tag {}", DW::TagString(tag).str());
            return baseType;
    }

    return builder.Finalize();
}


bool TypeModifierBuilder::IsTypeModifierTag(DW::Tag tag) {
    static const std::unordered_set<DW::Tag> kTypeModifierTags{
        DW::DW_TAG_const_type,
        DW::DW_TAG_volatile_type,
        DW::DW_TAG_pointer_type,
        DW::DW_TAG_reference_type,
        DW::DW_TAG_rvalue_reference_type,
        DW::DW_TAG_atomic_type,
        DW::DW_TAG_immutable_type,
        DW::DW_TAG_packed_type,
        DW::DW_TAG_restrict_type,
        DW::DW_TAG_shared_type,
        DW_TAG_APPLE_ptrauth_type,
    };
    return kTypeModifierTags.contains(tag);
}


/// Typedef builder

BinaryNinja::Ref<BinaryNinja::Type> TypedefBuilder::Build() {
    auto base = attributeReader_.ReadReference(DW::DW_AT_type);
    if (!base) {
        BDLogWarn("typedef without DW_AT_type attribute, DIE: {}", dieReader_.Dump());
        return nullptr;
    }

    auto name = attributeReader_.ReadName();
    if (name.empty()) {
        BDLogWarn("typedef without DW_AT_name attribute, DIE: {}", dieReader_.Dump());
        return nullptr;
    }

    BN::Ref<Type> baseType = GenericTypeBuilder{ctx_, *base}.Build();
    return baseType;
}

std::optional<DwarfDieWrapper> TypedefBuilder::Resolve(DwarfDieWrapper &die) {
    auto type = AttributeReader{die}.ReadReference(DW::DW_AT_type);
    while (type) {
        if (type->GetTag() != DW::DW_TAG_typedef) {
            return *type;
        }
        type = AttributeReader{*type}.ReadReference(DW::DW_AT_type);
    }
    return std::nullopt;
}


/// Array type builder

BinaryNinja::Ref<BinaryNinja::Type> ArrayTypeBuilder::Build() {
    auto name = attributeReader_.ReadName();
    if (!name.empty()) {
        BDLogWarn("ignoring array with DW_AT_name not implemented, DIE: {}", dieReader_.Dump());
        return nullptr;
    }

    auto elementType = attributeReader_.ReadReference(DW::DW_AT_type);
    if (!elementType) {
        BDLogWarn("ignoring array with no DW_AT_type attribute, DIE: {}", dieReader_.Dump());
        return nullptr;
    }

    if (attributeReader_.HasAttribute(DW::DW_AT_rank)) {
        return BuildDynamic();
    }

    return BuildStatic();
}

BinaryNinja::Ref<BinaryNinja::Type> ArrayTypeBuilder::BuildDynamic() {
    auto rank = attributeReader_.ReadUInt(DW::DW_AT_rank);
    if (!rank) {
        BDLogWarn("ignoring array having DW_AT_rank value as DWARF expression, DIE: {}",
                  dieReader_.Dump());
        return nullptr;
    }

    if (*rank == 0) {
        BDLogWarn("ignoring array having DW_AT_rank value 0, DIE: {}",
                  dieReader_.Dump());
        return nullptr;
    }

    auto elementType = *attributeReader_.ReadReference(DW::DW_AT_type);

    BN::Ref<Type> result = GenericTypeBuilder{ctx_, elementType}.Build();
    for (int i = 0; i < *rank; ++i) {
        result = Type::PointerType(dieReader_.ReadAddressSize(), result);
    }

    return result;
}

BinaryNinja::Ref<BinaryNinja::Type> ArrayTypeBuilder::BuildStatic() {
    std::vector<size_t> dimensions;
    for (auto &child: die_.Children()) {
        if (auto dim = DecodeCountFromSubrange(const_cast<DwarfDieWrapper &>(child))) {
            dimensions.push_back(*dim);
        } else {
            dimensions.push_back(0);
        }
    }

    auto elementType = *attributeReader_.ReadReference(DW::DW_AT_type);
    BN::Ref<Type> result = GenericTypeBuilder{ctx_, elementType}.Build();

    for (auto it = dimensions.rbegin(), end = dimensions.rend(); it != end; ++it) {
        if (*it != 0) {
            result = Type::ArrayType(result, *it);
        } else {
            result = Type::PointerType(dieReader_.ReadAddressSize(), result);
        }
    }

    return result;
}


std::optional<size_t> ArrayTypeBuilder::DecodeCountFromSubrange(DwarfDieWrapper &die) {
    AttributeReader attributeReader{die};
    if (auto count = attributeReader.ReadUInt(DW::DW_AT_count)) {
        return count;
    }

    if (auto ub = attributeReader.ReadUInt(DW::DW_AT_upper_bound)) {
        size_t lb;
        if (auto value = attributeReader.ReadUInt(DW::DW_AT_lower_bound)) {
            lb = *value;
        } else {
            lb = GetDefaultLowerBound();
        }
        if (*ub <= lb) {
            BDLogWarn("ignoring array index with ub <= lb, die: {}", dieReader_.Dump());
            return std::nullopt;
        }
        return *ub - lb;
    }

    return std::nullopt;
}

size_t ArrayTypeBuilder::GetDefaultLowerBound() {
    // TODO: language dependent???
    return 0;
}


/// Function type builder

BinaryNinja::Ref<BinaryNinja::Type> FunctionTypeBuilder::Build() {
    auto returnType = DecodeReturnType();
    auto parameters = DecodeParameters();
    return Type::FunctionType(returnType, DecodeCallingConvention(),
                              parameters.parameters, parameters.hasVarArg);
}

BinaryNinja::Ref<BinaryNinja::Type> FunctionTypeBuilder::DecodeReturnType() {
    auto returnType = attributeReader_.ReadReference(DW::DW_AT_type, true);
    if (!returnType) {
        return Type::VoidType();
    }
    return GenericTypeBuilder{ctx_, *returnType}.Build();
}

BinaryNinja::Ref<BinaryNinja::CallingConvention> FunctionTypeBuilder::DecodeCallingConvention() {
    // TODO??
    return nullptr;
}

FunctionTypeBuilder::DecodeParametersResult FunctionTypeBuilder::DecodeParameters() {
    DecodeParametersResult result{.hasVarArg = false};
    for (auto &entry: die_.Children()) {
        auto tag = entry.GetTag();
        auto &child = const_cast<DwarfDieWrapper &>(entry);
        AttributeReader attributeReader{child};
        switch (tag) {
            case DW::DW_TAG_formal_parameter: {
                if (result.hasVarArg) {
                    BDLogWarn("encountered function with formal parameter "
                              "after vararg, DIE: {}",
                              dieReader_.Dump());
                }

                BN::FunctionParameter functionParameter;
                functionParameter.type = ApplyParameterTypeModifiers(DecodeParameterType(child), child);
                functionParameter.name = attributeReader.ReadName("", true);
                functionParameter.defaultLocation = true;
                result.parameters.push_back(std::move(functionParameter));
                break;
            }
            case DW::DW_TAG_unspecified_parameters: {
                result.hasVarArg = true;
                break;
            }
            default: {
                break;
            }
        }
    }
    return result;
}

BinaryNinja::Ref<BinaryNinja::Type> FunctionTypeBuilder::DecodeParameterType(DwarfDieWrapper &die) {
    AttributeReader attributeReader{die};
    auto type = attributeReader.ReadReference(DW::DW_AT_type, true);
    if (!type) {
        BDLogWarn("encountered function formal parameter with no DW_AT_type "
                  "attribute, DIE: {}",
                  DieReader{die}.Dump());
        return Type::VoidType();
    }
    return GenericTypeBuilder{ctx_, *type}.Build();
}

BinaryNinja::Ref<BinaryNinja::Type> FunctionTypeBuilder::ApplyParameterTypeModifiers(
    BinaryNinja::Ref<BinaryNinja::Type> type, DwarfDieWrapper &die) {
    AttributeReader attributeReader{die};
    DieReader dieReader{die};
    bool isReferenceType = attributeReader.HasAttribute(DW::DW_AT_reference, true);
    bool isRValueReferenceType = attributeReader.HasAttribute(DW::DW_AT_rvalue_reference, true);
    if (isRValueReferenceType && isReferenceType) {
        BDLogWarn("function parameter have both DW_AT_reference and DW_AT_rvalue_reference "
                  "tags, DIE: {}",
                  DieReader{die}.Dump());
        return type;
    }
    if (isRValueReferenceType) {
        return Type::PointerType(dieReader.ReadAddressSize(), type, false, false,
                                 BNReferenceType::RValueReferenceType);
    }
    if (isReferenceType) {
        return Type::PointerType(dieReader.ReadAddressSize(), type, false, false,
                                 BNReferenceType::ReferenceReferenceType);
    }
    return type;
}


/// Enum type builder

BinaryNinja::Ref<BinaryNinja::Type> EnumTypeBuilder::Build() {
    auto type = ResolveBaseType();
    if (!type) {
        BDLogWarn("ignoring enum with no / invalid DW_AT_type attribute, DIE: {}", dieReader_.Dump());
        return nullptr;
    }

    if (type->GetTag() != DW::DW_TAG_base_type) {
        BDLogWarn("ignoring enum having base type with tag != DW_TAG_base_type, DIE: {}",
                  dieReader_.Dump());
        return nullptr;
    }

    BN::Ref<Type> baseType = GenericTypeBuilder{ctx_, *type}.Build();
    auto size = attributeReader_.ReadUInt(DW::DW_AT_byte_size);
    if (!size) {
        size = baseType->GetWidth();
    }

    auto isClass = attributeReader_.HasAttribute(DW::DW_AT_enum_class);
    if (isClass) {
        BDLogDebug("encountered class enum {}", dieReader_.Dump());
    }

    BN::EnumerationBuilder builder{};
    for (auto &child: die_.Children()) {
        auto tag = child.GetTag();
        if (tag == DW::DW_TAG_enumerator) {
            auto &enumerator = const_cast<DwarfDieWrapper &>(child);
            AttributeReader attributeReader{enumerator};
            std::string name = attributeReader.ReadName();
            if (name.empty()) {
                BDLogWarn("ignoring enum entry with no name, DIE: {}", DieReader{enumerator}.Dump());
                continue;
            }
            if (baseType->IsSigned()) {
                auto value = attributeReader.ReadInt(DW::DW_AT_const_value);
                if (!value) {
                    BDLogWarn("ignoring enum entry with no value, DIE: {}", DieReader{enumerator}.Dump());
                    continue;
                }
                builder.AddMemberWithValue(name, *value);
            } else {
                auto value = attributeReader.ReadUInt(DW::DW_AT_const_value);
                if (!value) {
                    BDLogWarn("ignoring enum entry with no value, DIE: {}", DieReader{enumerator}.Dump());
                    continue;
                }
                builder.AddMemberWithValue(name, *value);
            }
        } else {
            BDLogWarn("ignoring unexpected tag {} inside enum, DIE: {}",
                      DW::TagString(tag).str(), dieReader_.Dump());
        }
    }

    return Type::EnumerationType(builder.Finalize(), *size, baseType->IsSigned());
}

std::optional<DwarfDieWrapper> EnumTypeBuilder::ResolveBaseType() {
    auto type = attributeReader_.ReadReference(DW::DW_AT_type);
    while (type) {
        if (type->GetTag() == DW::DW_TAG_base_type) {
            return *type;
        }
        type = AttributeReader{*type}.ReadReference(DW::DW_AT_type);
    }
    return std::nullopt;
}


/// Composite type builder

BinaryNinja::Ref<BinaryNinja::Type> CompositeTypeBuilder::Build() {
    BN::StructureBuilder builder{};
    builder.SetStructureType(DecodeVariant());
    builder.SetPacked(IsPacked());
    builder.SetAlignment(DecodeAlignment());
    builder.SetWidth(DecodeWidth());

    for (auto &child: die_.Children()) {
        switch (child.GetTag()) {
            case DW::DW_TAG_inheritance:
            case DW::DW_TAG_member:
                if (auto result = DecodeMember(const_cast<DwarfDieWrapper &>(child))) {
                    builder.AddMemberAtOffset(result->type, result->name,
                                              result->offset, false, result->access);
                }
                break;
            case DW::DW_TAG_variable:
                if (auto result = DecodeVariable(const_cast<DwarfDieWrapper &>(child))) {
                    builder.AddMember(result->type, result->name, result->access,
                                      BNMemberScope::StaticScope);
                }
                break;
            case DW::DW_TAG_subprogram:
                // TODO: should we add entry in container???
                break;
            case DW::DW_TAG_template_value_parameter:
            case DW::DW_TAG_template_type_parameter:
                break;
            case DW::DW_TAG_structure_type:
            case DW::DW_TAG_union_type:
            case DW::DW_TAG_class_type:
            case DW::DW_TAG_enumeration_type:
            case DW::DW_TAG_typedef:
                // Already handled in member access / index DB iteration
                break;
            default: {
                BDLogInfo("Ignoring unexpected tag {} of DIE {}", DW::TagString(child.GetTag()).str(),
                          DieReader{const_cast<DwarfDieWrapper &>(child)}.Dump());
                break;
            }
        }
    }

    ProcessBitfields(builder);
    return Type::StructureType(builder.Finalize());
}

bool CompositeTypeBuilder::IsCompositeTypeTag(DW::Tag tag) {
    switch (tag) {
        case DW::DW_TAG_structure_type:
        case DW::DW_TAG_union_type:
        case DW::DW_TAG_class_type:
            return true;
        default:
            return false;
    }
}

BNStructureVariant CompositeTypeBuilder::DecodeVariant() {
    switch (die_.GetTag()) {
        case DW::DW_TAG_structure_type:
            return BNStructureVariant::StructStructureType;
        case DW::DW_TAG_union_type:
            return BNStructureVariant::UnionStructureType;
        case DW::DW_TAG_class_type:
            return BNStructureVariant::ClassStructureType;
        default:
            VerifyNotReachable();
    }
}

bool CompositeTypeBuilder::IsPacked() {
    return false;
}

uint8_t CompositeTypeBuilder::DecodeAlignment() {
    return 1;
}

size_t CompositeTypeBuilder::DecodeWidth() {
    if (auto size = attributeReader_.ReadUInt(DW::DW_AT_byte_size)) {
        return *size;
    }
    auto isDeclaration = attributeReader_.HasAttribute(DW::DW_AT_declaration);
    if (!isDeclaration) {
        BDLogWarn("Container does not have DW_AT_byte_size attribute, DIE: {}", dieReader_.Dump());
    }
    return 0;
}

BNMemberAccess CompositeTypeBuilder::GetDefaultMemberAccess() {
    switch (die_.GetTag()) {
        case DW::DW_TAG_structure_type:
        case DW::DW_TAG_union_type:
            return BNMemberAccess::PublicAccess;
        case DW::DW_TAG_class_type:
            return BNMemberAccess::PrivateAccess;
        default:
            VerifyNotReachable();
    }
}

std::optional<CompositeTypeBuilder::DecodeMemberResult> CompositeTypeBuilder::DecodeMember(DwarfDieWrapper &die) {
    DieReader dieReader{die};
    const auto &attributeReader = dieReader.AttrReader();

    if (attributeReader.HasAttribute(DW::DW_AT_data_bit_offset)) {
        return std::nullopt;
    }

    auto type = attributeReader.ReadReference(DW::DW_AT_type);
    if (!type) {
        BDLogInfo("Skipping member DIE without DW_AT_type attribute, "
                  "DIE: {}",
                  dieReader.Dump());
        return std::nullopt;
    }

    auto isExternal = attributeReader.HasAttribute(DW::DW_AT_external);
    if (isExternal) {
        // TODO: static members
        return std::nullopt;
    }

    auto offset = attributeReader.ReadUInt(DW::DW_AT_data_member_location);
    if (!offset) {
        BDLogWarn("composite type member without DW_AT_data_member_location, DIE: {}",
                  DieReader{die}.Dump());
        return std::nullopt;
    }

    std::string name = attributeReader.ReadName("", true);
    bool isAnonymous = name.empty();
    bool isInheritance = die.GetTag() == DW::DW_TAG_inheritance;

    AttributeReader typeAttributeReader{*type};

    if ((isAnonymous && !isInheritance) && !typeAttributeReader.HasAttribute(DW::DW_AT_export_symbols) && !typeAttributeReader.ReadName("").empty()) {
        BDLogDebug("Anonymous member of container does not have DW_AT_export_symbols "
                   "attribute and member type has name, DIE: {}",
                   dieReader.Dump());
    }

    DecodeMemberResult result;
    result.access = DecodeMemberAccess(attributeReader.ReadUInt(DW::DW_AT_accessibility));
    result.name = std::move(name);
    result.offset = *offset;
    result.type = GenericTypeBuilder{ctx_, *type}.Build();

    return result;
}

std::optional<CompositeTypeBuilder::DecodeVariableResult> CompositeTypeBuilder::DecodeVariable(DwarfDieWrapper &die) {
    DieReader dieReader{die};
    const auto &attributeReader = dieReader.AttrReader();

    auto type = attributeReader.ReadReference(DW::DW_AT_type);
    VerifyDebugDumpDie(type, die);

    std::string name = attributeReader.ReadName("", true);
    VerifyDebugDumpDie(!name.empty(), die);

    DecodeVariableResult result;
    result.access = DecodeMemberAccess(attributeReader.ReadUInt(DW::DW_AT_accessibility));
    result.name = std::move(name);
    result.type = GenericTypeBuilder{ctx_, *type}.Build();
    return result;
}


BNMemberAccess CompositeTypeBuilder::DecodeMemberAccess(std::optional<uint64_t> accessibility) {
    if (!accessibility) {
        return GetDefaultMemberAccess();
    }
    switch (*accessibility) {
        case DW::DW_ACCESS_private:
            return BNMemberAccess::PrivateAccess;
        case DW::DW_ACCESS_protected:
            return BNMemberAccess::ProtectedAccess;
        case DW::DW_ACCESS_public:
            return BNMemberAccess::PublicAccess;
    }
    BDLogWarn("encountered struct having member invalid DW_AT_accessibility "
              "value, DIE: {}",
              dieReader_.Dump());
    return NoAccess;
}


void CompositeTypeBuilder::ProcessBitfields(BN::StructureBuilder &builder) {
    auto child = die_.GetFirstChild();
    while (child.IsValid()) {
        if (child.GetTag() == DW::DW_TAG_member) {
            AttributeReader attributeReader{child};
            if (attributeReader.HasAttribute(DW::DW_AT_bit_size)) {
                if (auto next = ProcessBitfield(builder, child)) {
                    child = *next;
                } else {
                    BDLogWarn("failed processing of bitfields in DIE {}", dieReader_.Dump());
                    return;
                }
                continue;
            }
        }
        child = child.GetSibling();
    }
}


std::optional<DwarfDieWrapper> CompositeTypeBuilder::ProcessBitfield(
    BinaryNinja::StructureBuilder &builder, DwarfDieWrapper &start) {
    const int kMaxBitSize = 64;

    int startBit = 0;
    if (auto bit = AttributeReader{start}.ReadUInt(DW::DW_AT_bit_offset)) {
        startBit = *bit;
    }

    if (startBit % 8 != 0) {
        BDLogWarn("unexpected alignment of start bit in DIE offset: {}", start.GetOffset());
        return std::nullopt;
    }

    int bitsUsed = 0;
    DwarfDieWrapper end = start.GetSibling();
    for (int previousMaxBit = startBit; end.IsValid();) {
        if (end.GetTag() != DW::DW_TAG_member) {
            break;
        }

        AttributeReader attributeReader{end};
        auto bitSize = attributeReader.ReadUInt(DW::DW_AT_bit_size);
        if (!bitSize) {
            break;
        }

        auto bitOffset = attributeReader.ReadUInt(DW::DW_AT_data_bit_offset);
        if (!bitOffset) {
            bitOffset = 0;
        }

        int maxBit = *bitOffset + *bitSize;
        if (maxBit < previousMaxBit) {
            BDLogWarn("unexpected order of bitfields in DIE offset: {}", end.GetOffset());
            return std::nullopt;
        }

        if (maxBit - startBit > kMaxBitSize) {
            break;
        }

        bitsUsed = maxBit - startBit;
        end = end.GetSibling();
    }

    BN::EnumerationBuilder enumerationBuilder{};
    int enumSize = bitsUsed <= 8 ? 1 : bitsUsed <= 16 ? 2
                                   : bitsUsed <= 32   ? 4
                                                      : 8;

    for (DwarfDieWrapper die = start; die != end; die = die.GetSibling()) {
        AttributeReader bitfieldAttributeReader{die};

        auto bitSize = *bitfieldAttributeReader.ReadUInt(DW::DW_AT_bit_size);
        auto bitOffset = bitfieldAttributeReader.ReadUInt(DW::DW_AT_data_bit_offset);
        bitOffset = bitOffset ? bitOffset : 0;

        auto name = bitfieldAttributeReader.ReadName();
        if (name.empty()) {
            name = fmt::format("__bitfield_noname_{}", *bitOffset);
        }

        enumerationBuilder.AddMemberWithValue(fmt::format("{}_bit_offset", name), *bitOffset);
        enumerationBuilder.AddMemberWithValue(fmt::format("{}_bit_size", name), bitSize);
    }

    BN::Ref<Type> enumeration = Type::EnumerationType(enumerationBuilder.Finalize(), enumSize, false);
    builder.AddMemberAtOffset(enumeration, "", bitsUsed / 8);
    return end;
}

/// Pointer to member type builder

BinaryNinja::Ref<BinaryNinja::Type> PointerToMemberTypeBuilder::Build() {
    auto memberType = attributeReader_.ReadReference(DW::DW_AT_type);
    if (!memberType) {
        BDLogWarn("encountered pointer to member type with no DW_AT_type, DIE: {}",
                  dieReader_.Dump());
        return nullptr;
    }

    auto containerType = attributeReader_.ReadReference(DW::DW_AT_containing_type);
    if (!containerType) {
        BDLogWarn("encountered pointer to member type with no DW_AT_containing_type, DIE: {}",
                  dieReader_.Dump());
        return nullptr;
    }

    BN::StructureBuilder builder;
    auto memberTypeRef = GenericTypeBuilder{ctx_, *memberType}.Build();
    if (!memberTypeRef) {
        return nullptr;
    }

    builder.AddMemberAtOffset(Type::PointerType(dieReader_.ReadAddressSize(), memberTypeRef), "ptr", 0);
    return Type::StructureType(builder.Finalize());
}


/// Generic type builder

BinaryNinja::Ref<BinaryNinja::Type> GenericTypeBuilder::Build() {
    auto tag = resolvedDie_.GetTag();
    VerifyDumpDie(IsTypeTag(tag), resolvedDie_);

    if (tag == DW::DW_TAG_base_type) {
        return BaseTypeBuilder{ctx_, resolvedDie_}.Build();
    }

    if (TypeModifierBuilder::IsTypeModifierTag(tag)) {
        return TypeModifierBuilder{ctx_, resolvedDie_}.Build();
    }

    if (tag == DW::DW_TAG_unspecified_type) {
        return NamedTypeReferenceBuilder{ctx_, resolvedDie_}.Build();
    }

    if (!ctx_.TagDieAsProcessing(resolvedDie_)) {
        return NamedTypeReferenceBuilder{ctx_, resolvedDie_}.Build();
    }

    bool isAnonymous = resolvedDieReader_.AttrReader().ReadName("", true).empty();
    if (!isAnonymous && !decodeNamedTypes_) {
        ctx_.UntagDieAsProcessing(resolvedDie_);
        return NamedTypeReferenceBuilder{ctx_, resolvedDie_}.Build();
    }

    auto type = DoBuild();
    if (!type) {
        BinaryNinja::NamedTypeReference ref{
            BNNamedTypeReferenceClass::TypedefNamedTypeClass,
            "", QualifiedName{"__dwarf_bad_type"}};
        type = Type::NamedType(&ref);
    }

    ctx_.UntagDieAsProcessing(resolvedDie_);
    return type;
}

BinaryNinja::Ref<BinaryNinja::Type> GenericTypeBuilder::DoBuild() {
    auto tag = resolvedDie_.GetTag();
    VerifyDumpDie(IsTypeTag(tag), resolvedDie_);

    if (tag == DW::DW_TAG_typedef) {
        return TypedefBuilder{ctx_, resolvedDie_}.Build();
    }

    if (tag == DW::DW_TAG_array_type) {
        return ArrayTypeBuilder{ctx_, resolvedDie_}.Build();
    }

    if (tag == DW::DW_TAG_enumeration_type) {
        return EnumTypeBuilder{ctx_, resolvedDie_}.Build();
    }

    if (tag == DW::DW_TAG_subroutine_type) {
        return FunctionTypeBuilder{ctx_, resolvedDie_}.Build();
    }

    if (CompositeTypeBuilder::IsCompositeTypeTag(tag)) {
        return CompositeTypeBuilder{ctx_, resolvedDie_}.Build();
    }

    if (tag == DW::DW_TAG_ptr_to_member_type) {
        return PointerToMemberTypeBuilder{ctx_, resolvedDie_}.Build();
    }

    BDLogWarn("encountered type die with unknown tag, DIE: {}", resolvedDieReader_.Dump());
    return nullptr;
}


/// Abstract type builder context

bool TypeBuilderContext::TagDieAsProcessing(DwarfDieWrapper &die) {
    auto [_, inserted] = workingSet_.insert(die.GetOffset());
    return inserted;
}

void TypeBuilderContext::UntagDieAsProcessing(DwarfDieWrapper &die) {
    bool ok = workingSet_.erase(die.GetOffset());
    Verify(ok, FatalError);
}

std::optional<uint64_t> TypeBuilderContext::SlideAddress(DwarfOffset offset, uint64_t address) {
    return dwarfContext_.GetSlidAddress(offset, address);
}


/// Named type reference builder

BinaryNinja::Ref<BinaryNinja::Type> NamedTypeReferenceBuilder::Build() {
    BN::QualifiedName qualifiedName{ctx_.DecodeQualifiedName(die_)};
    BN::NamedTypeReference reference{DecodeTypeClass(), "", qualifiedName};
    auto size = TypeSizeDecoder{die_}.Decode();
    return Type::NamedType(&reference, size ? *size : 0);
}

BNNamedTypeReferenceClass NamedTypeReferenceBuilder::DecodeTypeClass() {
    auto tag = die_.GetTag();
    switch (tag) {
        case DW::DW_TAG_typedef:
            return BNNamedTypeReferenceClass::TypedefNamedTypeClass;
        case DW::DW_TAG_enumeration_type:
            return BNNamedTypeReferenceClass::EnumNamedTypeClass;
        case DW::DW_TAG_structure_type:
        case DW::DW_TAG_class_type:
            return BNNamedTypeReferenceClass::StructNamedTypeClass;
        case DW::DW_TAG_union_type:
            return BNNamedTypeReferenceClass::UnionNamedTypeClass;
        default:
            BDLogWarn("encountered die with unexpected tag, DIE: {}", dieReader_.Dump());
            return BNNamedTypeReferenceClass::UnknownNamedTypeClass;
    }
}

/// Type size decoder

std::optional<DwarfDieWrapper> TypeSizeDecoder::ResolveType(DwarfDieWrapper &die) {
    if (!die.IsValid()) {
        return std::nullopt;
    }

    switch (die.GetTag()) {
        case DW::DW_TAG_enumeration_type:
        case DW::DW_TAG_typedef:
        case DW::DW_TAG_const_type:
        case DW::DW_TAG_volatile_type:
        case DW::DW_TAG_atomic_type:
        case DW::DW_TAG_immutable_type:
        case DW::DW_TAG_packed_type:// TODO: verify all
        case DW::DW_TAG_restrict_type:
        case DW::DW_TAG_shared_type:
        case DW_TAG_APPLE_ptrauth_type: {
            auto base = AttributeReader{die}.ReadReference(DW::DW_AT_type);
            if (!base) {
                return die;
            }
            return ResolveType(*base);
        }
        default:
            return die;
    }
}

std::optional<uint64_t> TypeSizeDecoder::Decode() {
    auto die = ResolveType(die_);
    if (!die) {
        return std::nullopt;
    }

    switch (die->GetTag()) {
        case DW::DW_TAG_subroutine_type:
        case DW::DW_TAG_pointer_type:
        case DW::DW_TAG_reference_type:
        case DW::DW_TAG_rvalue_reference_type:
            return die->GetDwarfUnit().GetAddressByteSize();
        case DW::DW_TAG_structure_type:
        case DW::DW_TAG_union_type:
        case DW::DW_TAG_class_type:
        case DW::DW_TAG_base_type:
            return AttributeReader{*die}.ReadUInt(DW::DW_AT_byte_size, true);
        case DW::DW_TAG_array_type:

        default:
            return std::nullopt;
    }
}

```

`debuginfo/src/variable.cpp`:

```cpp
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <binaryninjaapi.h>

#include <llvm/DebugInfo/DWARF/DWARFContext.h>

#include <binja/utils/log.h>

#include "variable.h"

using namespace Binja;
using namespace DebugInfo;

namespace DW = llvm::dwarf;
namespace BN = BinaryNinja;

std::optional<DwarfVariableInfo> VariableDecoder::Decode() {
    auto &attributeReader = dieReader_.AttrReader();
    DwarfVariableInfo info;

    if (auto location = attributeReader.ReadLocationAddress()) {
        info.location = *location;
    } else {
        return std::nullopt;
    }

    if (auto slidLocation = ctx_.SlideAddress(die_.GetOffset(), info.location)) {
        info.location = *slidLocation;
    } else {
        BDLogDebug("cannot slide data symbol address {}", info.location);
        return std::nullopt;
    }

    std::string name = attributeReader.ReadName("", true);
    if (name.empty()) {
        BDLogDebug("ignoring variable with no name, DIE: {}", dieReader_.Dump());
        return std::nullopt;
    }
    info.qualifiedName = ctx_.DecodeQualifiedName(die_);

    auto valueType = attributeReader.ReadReference(DW::DW_AT_type);
    if (valueType) {
        info.type = GenericTypeBuilder{ctx_, *valueType}.Build();
    } else {
        BDLogWarn("encountered variable with no type, DIE: {}", dieReader_.Dump());
        info.type = BN::Type::VoidType();
    }
    return info;
}
```

`debuginfo/test/CMakeLists.txt`:

```txt
add_executable(dwarf_debuginfo_test main.cpp)

target_link_libraries(dwarf_debuginfo_test PRIVATE dwarf_debuginfo kcview)
```

`debuginfo/test/main.cpp`:

```cpp
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <iostream>

#include <binaryninjaapi.h>
#include <binaryninjacore.h>

#include <binja/debuginfo/plugin_dsym.h>
#include <binja/debuginfo/plugin_macho.h>
#include <binja/debuginfo/plugin_symtab.h>
#include <binja/kcview/lib.h>
#include <binja/utils/binary_view.h>
#include <binja/utils/settings.h>

using namespace Binja;
using BinaryNinja::BinaryView;
using BinaryNinja::BinaryViewType;
using BinaryNinja::Ref;
namespace BN = BinaryNinja;

int main(int argc, const char **argv) {
    if (argc != 2) {
        std::cerr << "Invalid arguments\n";
        return 1;
    }
    std::string binaryPath = argv[1];

    BN::SetBundledPluginDirectory(BNGetBundledPluginDirectory());
    BN::InitPlugins(true);
    Utils::BinjaSettings::Register();
    DebugInfo::PluginDSYM::RegisterPlugin();
    DebugInfo::PluginMacho::RegisterPlugin();
    DebugInfo::PluginSymtab::RegisterPlugin();
    KCView::CorePluginInit();

    BNLogToStdout(BNLogLevel::InfoLog);

    Ref<BinaryView> bv = Utils::OpenBinaryView(binaryPath, false, nullptr, nullptr);
    bv->UpdateAnalysisAndWait();
    return 0;
}
```

`external/CMakeLists.txt`:

```txt
add_subdirectory(fmtlib)
add_subdirectory(taskflow)
add_subdirectory(mio)
add_subdirectory(zstd/build/cmake)

```

`kcview/CMakeLists.txt`:

```txt
set(LIBRARY_NAME kcview)

set(KERNCACHE_HEADERS
        include/binja/kcview/errors.h
        include/binja/kcview/lib.h
        include/binja/kcview/range.h)

set(KERNCACHE_SOURCES
        src/lib.cpp)

add_library(${LIBRARY_NAME} STATIC ${KERNCACHE_SOURCES} ${KERNCACHE_HEADERS})
target_include_directories(${LIBRARY_NAME} PUBLIC include)
target_include_directories(${LIBRARY_NAME} PRIVATE include/binja/kcview)
target_link_libraries(${LIBRARY_NAME} PUBLIC binja_kc_common)
target_link_libraries(${LIBRARY_NAME} PUBLIC Taskflow fmt::fmt binaryninjaapi)

add_subdirectory(test)
```

`kcview/include/binja/kcview/errors.h`:

```h
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//


#pragma once

#include <binja/types/errors.h>

namespace Binja::KCView {

class MachoDecodeError : public Types::DecodeError {
    using Types::DecodeError::DecodeError;
};

}// namespace Binja::KCView

```

`kcview/include/binja/kcview/lib.h`:

```h
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//


#pragma once

namespace Binja::KCView {

void CorePluginInit();

}// namespace Binja::KCView
```

`kcview/include/binja/kcview/range.h`:

```h
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//


#pragma once

#include <binja/utils/debug.h>
#include <binja/utils/interval_map.h>

namespace Binja::KCView {

template<class K, class V>
class RangeMap {
public:
    void Insert(Utils::Interval<K> key, V value) {
        auto it = index_.find(key);
        BDVerify(it == index_.end());
        auto idx = values_.size();
        values_.push_back(value);
        index_.insert(key, idx);
    }

    const V *Query(K key) {
        return QueryInternal(key);
    }

    const V *Query(Utils::Interval<K> key) {
        return QueryInternal(key);
    }

    K FindNextValid(K key) {
        BDVerify(Query(key) == nullptr);
        for (auto it = index_.begin(), end = index_.end(); it != end; ++it) {
            if (it->first.lower() > key) {
                return it->first.lower();
            }
        }
        return 0;
    }

    const std::vector<V> &Values() {
        return values_;
    }

private:
    template<class T>
    const V *QueryInternal(T key) {
        auto it = index_.find(key);
        if (it == index_.end()) {
            return nullptr;
        }
        return &values_[it->second];
    }

    Utils::IntervalMap<K, size_t> index_;
    std::vector<V> values_;
};

}// namespace Binja::KCView
```

`kcview/src/lib.cpp`:

```cpp
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//


#include <binaryninjaapi.h>
#include <binaryninjacore.h>

#include <llvm/Object/MachO.h>
#include <fmt/format.h>
#include <taskflow/taskflow.hpp>

#include <binja/macho/macho.h>
#include <binja/utils/binary_view.h>
#include <binja/utils/debug.h>
#include <binja/utils/log.h>
#include <binja/utils/settings.h>

#include "errors.h"
#include "lib.h"
#include "range.h"

using namespace Binja;
using namespace llvm::MachO;

using Binja::Utils::BinaryViewDataReader;
using KCView::MachoDecodeError;
using KCView::RangeMap;
using MachO::Fileset;
using MachO::MachHeaderParser;
using MachO::MachBinaryViewDataBackend;
using MachO::Section;
using MachO::Segment;

using BinaryNinja::Architecture;
using BinaryNinja::BinaryView;
using BinaryNinja::BinaryViewType;
using BinaryNinja::FileAccessor;
using BinaryNinja::NamedTypeReference;
using BinaryNinja::Platform;
using BinaryNinja::QualifiedName;
using BinaryNinja::Ref;
using BinaryNinja::Settings;
using BinaryNinja::Symbol;
using BinaryNinja::Type;

using Utils::Interval;
using Utils::IntervalMap;

namespace {

constexpr auto *kBinaryType = "MachO-KC";

class CustomBinaryView : public BinaryView {
public:
    explicit CustomBinaryView(BinaryView *parent)
        : BinaryView{kBinaryType, parent->GetFile(), parent} {
        base_ = GetParentView();
        auto bnSettings = BinaryNinja::Settings::Instance();
        Utils::BinjaSettings settings {GetObject(), bnSettings->GetObject()};
        for (const auto& fileset: settings.KCExcludedFilesets()) {
            excludedFilesets_.insert(fileset);
        }
        for (const auto& fileset: settings.KCIncludedFilesets()) {
            includedFilesets_.insert(fileset);
        }
        applyDyldChainedFixups_ = settings.KCApplyDyldChainedFixups();
        stripPAC_ = settings.KCStripPAC();
        defineKallocTypeSymbols_ = settings.KCSymbolicateKallocTypes();
    }

    bool Init() override {
        ProcessKC();
        return true;
    }

    void Parse() {}

    size_t PerformRead(void *dest, uint64_t offset, size_t len) override {
        const auto *segment = va2RawMap_.Query(offset);
        if (!segment) {
            return 0;
        }
        return base_->Read(dest, offset - segment->vaStart + segment->dataStart, len);
    }

    size_t PerformWrite(uint64_t offset, const void *data, size_t len) override {
        BDLogError("PerformWrite not supported");
        return 0;
    }

    size_t PerformInsert(uint64_t offset, const void *data, size_t len) override {
        BDLogError("PerformInsert not supported");
        return 0;
    }

    size_t PerformRemove(uint64_t offset, uint64_t len) override {
        BDLogError("PerformRemove not supported");
        return 0;
    }

    BNModificationStatus PerformGetModification(uint64_t offset) override {
        return BNModificationStatus::Original;
    }

    bool PerformIsValidOffset(uint64_t offset) override {
        return va2RawMap_.Query(offset) != nullptr;
    }

    bool PerformIsOffsetReadable(uint64_t offset) override {
        if (const auto *segment = va2RawMap_.Query(offset)) {
            return segment->flags & BNSegmentFlag::SegmentReadable;
        }
        return false;

    }

    bool PerformIsOffsetWritable(uint64_t offset) override {
        if (const auto *segment = va2RawMap_.Query(offset)) {
            return segment->flags & BNSegmentFlag::SegmentWritable;
        }
        return false;

    }

    bool PerformIsOffsetExecutable(uint64_t offset) override {
        if (const auto *segment = va2RawMap_.Query(offset)) {
            return segment->flags & BNSegmentFlag::SegmentExecutable;
        }
        return false;

    }

    bool PerformIsOffsetBackedByFile(uint64_t offset) override {
        return va2RawMap_.Query(offset + vaStart_) != nullptr;
    }

    uint64_t PerformGetNextValidOffset(uint64_t offset) override {
        return va2RawMap_.FindNextValid(offset);
    }

    uint64_t PerformGetStart() const override {
        return vaStart_;
    }

    uint64_t PerformGetLength() const override {
        return vaLength_;
    }

    uint64_t PerformGetEntryPoint() const override {
        return entryPoint_;
    }

    bool PerformSave(FileAccessor *file) override {
        return base_->Save(file);
    }

    bool PerformIsExecutable() const override { return true; }
    BNEndianness PerformGetDefaultEndianness() const override { return BNEndianness::LittleEndian; }
    bool PerformIsRelocatable() const override { return false; }
    size_t PerformGetAddressSize() const override { return 8; }

private:
    void ProcessKC() {
        VerifyKC();
        FindVAStart();
        ProcessBaseSegments();
        auto filesets = DecodeFilesets();
        for (const auto &fileset: filesets) {
            ProcessFileset(fileset);
        }
        FindVALength();
        FindEntryPoint();

        // TODO: handle case when only file contents are saved??
        if (BNIsBackedByDatabase(GetFile()->GetObject(), kBinaryType)) {
            return;
        }

        if (defineKallocTypeSymbols_) {
            DefineKallocTypeSymbols();
        }

        if (applyDyldChainedFixups_) {
            std::vector<char> buffer{};
            buffer.resize(base_->GetLength());
            size_t read = base_->Read(buffer.data(), 0, buffer.size());
            BDVerify(read == buffer.size());
            ApplyDyldChainedFixups(std::span<char>{buffer.data(), buffer.size()});
            size_t wrote = base_->Write(0, buffer.data(), buffer.size());
            BDVerify(wrote == buffer.size());
        }

        if (stripPAC_) {
            StripPAC();
        }

    }

    void VerifyKC() {
        BinaryViewDataReader reader{base_, 0};
        auto header = reader.Read<mach_header_64>();
        BDVerify(header.magic == MH_MAGIC_64 || header.magic == MH_CIGAM_64);
        BDVerify(header.cputype == CPU_TYPE_ARM64);
        BDVerify(header.cpusubtype == CPU_SUBTYPE_ARM64E);
        SetDefaultArchitecture(Architecture::GetByName("aarch64"));
        SetDefaultPlatform(Platform::GetByName("mac-aarch64"));
    }

    void FindVAStart() {
        auto segments = DecodeSegments(0);
        for (const auto &segment: segments) {
            if (segment.vaStart > 0) {
                vaStart_ = segment.vaStart;
                return;
            }
        }
        throw MachoDecodeError{"Image does not have segment with non zero VA"};
    }

    void FindVALength() {
        uint64_t maxVA = vaStart_;
        for (const auto &segment: va2RawMap_.Values()) {
            maxVA = std::max(segment.vaStart + segment.vaLength, maxVA);
        }
        vaLength_ = maxVA - vaStart_;
    }

    void FindEntryPoint() {
        MachBinaryViewDataBackend backend{*base_};
        if (auto entry = MachHeaderParser{backend, 0}.DecodeEntryPoint()) {
            entryPoint_ = *entry;
        } else {
            throw MachoDecodeError{"binary does not have LC_UNIXTHREAD command"};
        }
    }

    bool ShouldSkipSegment(const Fileset &fileset, const Segment &segment) {
        if (!includedFilesets_.empty() && !includedFilesets_.contains(fileset.name)) {
            return true;
        }
        if (excludedFilesets_.contains(fileset.name)) {
            return true;
        }
        if (segment.name == "__LINKEDIT" || segment.name == "__LINKINFO") {
            return true;
        }
        if (segment.vaLength == 0) {
            return true;
        }
        return false;
    }

    void ProcessBaseSegments() {
        MachBinaryViewDataBackend backend{*base_};
        MachHeaderParser parser{backend, 0};
        std::set<std::string> shouldMap{"__TEXT", "__LINKEDIT"};
        for (const auto &segment: parser.DecodeSegments()) {
            if (!shouldMap.contains(segment.name)) {
                BDLogDebug("skipping base segment {}", segment.name);
                continue;
            }
            if (segment.vaLength == 0) {
                BDLogWarn("base segment {} has no VA", segment.name);
            }
            BDLogDebug("adding base segment {}", segment.name);
            InsertSegment(segment);
        }
    }

    void ProcessFileset(const Fileset &fileset) {
        BDLogInfo("Adding fileset {}", fileset.name.c_str());
        auto segments = DecodeSegments(fileset.fileOffset);
        for (const auto &segment: segments) {
            if (ShouldSkipSegment(fileset, segment)) {
                BDLogDebug("Skipping segment {}", segment.name.c_str());
                continue;
            }
            InsertSegment(segment, fileset.name.c_str());
        }
        AddFilesetDataVariables(fileset);
    }

    void InsertSegment(const Segment &segment, const char *prefix = "") {
        BDVerify(segment.vaStart >= vaStart_);
        auto va = Interval{segment.vaStart, segment.vaStart + segment.vaLength};
        if (const Segment *entry = va2RawMap_.Query(va)) {
            throw MachoDecodeError{"VA overlap between [{:#016x}-{:#016x}) and [{:#016x}-{:#016x}) while trying to add segment {}",
                                   va.lower(), va.upper(),
                                   entry->vaStart, entry->vaStart + entry->vaLength, segment.name};
        }
        va2RawMap_.Insert(va, segment);
        AddAutoSegment(segment.vaStart, segment.vaLength, segment.dataStart, segment.dataLength, segment.flags);
        for (const auto &section: segment.sections) {
            BDLogDebug("Adding section {}", section.name.c_str());
            AddAutoSection(
                fmt::format("{}::{}::{}", prefix, segment.name, section.name),
                section.vaStart,
                section.vaLength,
                section.semantics);
        }
    }

    void ApplyDyldChainedFixups(std::span<char> data) {
        MachO::MachSpanDataBackend backend{data};
        MachO::MachHeaderParser parser {backend, 0};
        std::vector<MachO::DyldChainedPtr> chainedPtrs = parser.DecodeDyldChainedPtrs();
        BDLogInfo("Found {} chained pointers", chainedPtrs.size());
        for (const auto& ptr: chainedPtrs) {
            BDVerify(ptr.fileOffset + sizeof(ptr.value) < data.size_bytes());
            memcpy(&data[ptr.fileOffset], &ptr.value, sizeof(ptr.value));
        }
    }

    void AddFilesetDataVariables(const Fileset &fileset) {
        NamedTypeReference ref{
            BNNamedTypeReferenceClass::StructNamedTypeClass,
            "", QualifiedName{"mach_header_64"}};
        DefineDataVariable(fileset.vmAddr, Type::NamedType(&ref));
        Ref<BinaryNinja::Symbol> symbol = new BinaryNinja::Symbol{
            BNSymbolType::DataSymbol,
            "__mach_header", "__mach_header", "__mach_header", fileset.vmAddr};
        DefineAutoSymbol(symbol);
    }

    void StripPAC() {
        tf::Executor executor;
        tf::Taskflow taskflow;

        std::atomic<size_t> totalXPACs = 0;
        const auto &segments = va2RawMap_.Values();

        taskflow.for_each(segments.begin(), segments.end(), [&](const auto &segment) {
            if (segment.flags & BNSegmentFlag::SegmentExecutable) {
                return;
            }
            if (segment.flags & BNSegmentFlag::SegmentContainsCode) {
                return;
            }

            std::vector<uint64_t> data{};
            data.resize(segment.dataLength / 8);
            size_t dataSize = data.size() * 8;
            auto read = base_->Read(data.data(), segment.dataStart, dataSize);
            if (read < dataSize) {
                data.resize(read / 8);
                dataSize = data.size() * 8;
            }

            size_t numXPAC = 0;
            for (auto it = data.begin(), end = data.end(); it != end; ++it) {
                uint64_t value = *it;
                uint32_t signature = value >> 44;
                if (signature == 0 || signature == 0xfffff) {
                    continue;
                }
                uint8_t checkField = (value >> 40) & 0xf;
                if (checkField != 0xe) {
                    continue;
                }
                uint64_t address = value | 0xfffff00000000000ULL;
                if (address < vaStart_ || address >= vaStart_ + vaLength_ || va2RawMap_.Query(address) == nullptr) {
                    continue;
                }
                *it = address;
                ++numXPAC;
            }

            BDLogInfo("XPACed {} pointer from segment {}", numXPAC, segment.name);
            if (numXPAC) {
                size_t wrote = base_->Write(segment.dataStart, data.data(), dataSize);
                BDVerify(wrote == dataSize);
                totalXPACs += numXPAC;
            }
        });

        executor.run(taskflow).wait();
        BDLogInfo("XPACed total {} pointers", totalXPACs.load());
    }

    void DefineKallocTypeSymbols() {
        const auto &segments = va2RawMap_.Values();

        NamedTypeReference kallocTypeRef{
            BNNamedTypeReferenceClass::StructNamedTypeClass,
            "",
            QualifiedName{"kalloc_type_view"}};
        Ref<Type> kallocType = Type::NamedType(&kallocTypeRef, 64);

        NamedTypeReference kallocVarRef{
            BNNamedTypeReferenceClass::StructNamedTypeClass,
            "",
            QualifiedName{"kalloc_type_var_view"}};
        Ref<Type> kallocVarType = Type::NamedType(&kallocVarRef, 80);

        BeginBulkModifySymbols();
        size_t totalSymbols = 0;
        for (const auto &segment: segments) {
            for (const auto &section: segment.sections) {
                bool isVar;
                if (section.name.ends_with("__kalloc_var")) {
                    isVar = true;
                } else if (section.name.ends_with("__kalloc_type")) {
                    isVar = false;
                } else {
                    continue;
                }
                size_t size = isVar ? 80 : 64;
                Ref<Type> type = isVar ? kallocVarType : kallocType;
                for (size_t cursor = section.vaStart;
                     (cursor + size) <= section.vaStart + section.vaLength;
                     cursor += size) {
                    Ref<Symbol> symbol = new Symbol{
                        BNSymbolType::DataSymbol,
                        isVar ? "kalloc_type_var_view" : "kalloc_type_view",
                        cursor};
                    DefineAutoSymbolAndVariableOrFunction(GetDefaultPlatform(), symbol, type);
                    ++totalSymbols;
                }
            }
        }
        EndBulkModifySymbols();
        BDLogInfo("defined {} kalloc type (var) view symbols", totalSymbols);
    }

    std::vector<Fileset> DecodeFilesets() {
        MachBinaryViewDataBackend backend{*base_};
        return MachHeaderParser{backend, 0}.DecodeFilesets();
    }

    std::vector<Segment> DecodeSegments(uint64_t fileoff) {
        MachBinaryViewDataBackend backend{*base_};
        return MachHeaderParser{backend, fileoff}.DecodeSegments();
    }

private:
    uint64_t vaStart_;
    uint64_t vaLength_;
    uint64_t entryPoint_;
    RangeMap<uint64_t, Segment> va2RawMap_;
    Ref<BinaryView> base_;

    std::set<std::string> excludedFilesets_;
    std::set<std::string> includedFilesets_;
    bool applyDyldChainedFixups_;
    bool stripPAC_;
    bool defineKallocTypeSymbols_;
};

class CustomBinaryType : public BinaryViewType {
public:
    CustomBinaryType() : BinaryViewType{kBinaryType, "MachO Kernel Cache"} {}

    bool IsDeprecated() override { return false; }

    std::conditional_t<BN_CURRENT_CORE_ABI_VERSION >= 31, Ref<BinaryView>, BinaryView *> Create(BinaryView *data) override {
        try {
            return new CustomBinaryView{data};
        } catch (const Types::DecodeError &e) {
            BDLogError("Failed to decode MachO Kernel Cache, error: {}", e.what());
            return nullptr;
        }
    }

    std::conditional_t<BN_CURRENT_CORE_ABI_VERSION >= 31, Ref<BinaryView>, BinaryView *> Parse(BinaryView *data) override {
        try {
            auto *bv = dynamic_cast<CustomBinaryView *>(data);
            bv->Parse();
            return bv;
        } catch (const Types::DecodeError &e) {
            BDLogError("Failed to parse MachO Kernel Cache, error: {}", e.what());
            return nullptr;
        }
    }

    bool IsTypeValidForData(BinaryView *data) override {
        if (data->GetLength() < sizeof(mach_header_64)) {
            return false;
        }

        BinaryViewDataReader reader{data, 0};
        auto header = reader.Read<mach_header_64>();
        if (header.magic != MH_CIGAM_64 && header.magic != MH_MAGIC_64) {
            return false;
        }
        if (header.filetype != 0xc /* MH_FILESET */) {
            return false;
        }
        BDLogDebug("Matched Kernel Cache");
        return true;
    }

    Ref<Settings> GetLoadSettingsForData(BinaryView *data) override {
        return new Settings{
            BNGetBinaryViewDefaultLoadSettingsForData(m_object, data->GetObject())};
    }
};

}// namespace


void KCView::CorePluginInit() {
    BinaryViewType::Register(new CustomBinaryType{});
}

```

`kcview/test/CMakeLists.txt`:

```txt
add_executable(kcview_test main.cpp)

find_package(LLVM 15.0 REQUIRED
        COMPONENTS support object debugInfoDWARF)
target_link_directories(kcview_test PRIVATE ${LLVM_LIBRARY_DIRS})
target_link_libraries(kcview_test PRIVATE ${LLVM_LIBRARIES} libzstd_static)
target_link_options(kcview_test PRIVATE -lz -lm -lcurses)

target_link_libraries(kcview_test PRIVATE kcview)

```

`kcview/test/main.cpp`:

```cpp
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//


#include <sys/stat.h>

#include <cstdlib>
#include <iostream>

#include <binaryninjaapi.h>
#include <binaryninjacore.h>
#include <lowlevelilinstruction.h>

#include <binja/kcview/lib.h>
#include <binja/utils/binary_view.h>
#include <binja/utils/settings.h>

using namespace BinaryNinja;
using namespace std;
using namespace Binja;

bool is_file(char *fname) {
    struct stat buf;
    if (stat(fname, &buf) == 0 && (buf.st_mode & S_IFREG) == S_IFREG)
        return true;

    return false;
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        cerr << "USAGE: " << argv[0] << " <file_name>" << endl;
        exit(-1);
    }

    char *fname = argv[1];
    if (!is_file(fname)) {
        cerr << "Error: " << fname << " is not a regular file" << endl;
        exit(-1);
    }

    SetBundledPluginDirectory(BNGetBundledPluginDirectory());
    InitPlugins(true);

    Utils::BinjaSettings::Register();
    KCView::CorePluginInit();
    LogToStdout(BNLogLevel::InfoLog);

    Json::Value opts;
    Ref<BinaryView> bv = Binja::Utils::OpenBinaryView(fname, false, nullptr, nullptr, opts);
    bv->UpdateAnalysisAndWait();

    cout << "Target:   " << fname << endl
         << endl;
    cout << "TYPE:     " << bv->GetTypeName() << endl;
    cout << "START:    0x" << hex << bv->GetStart() << endl;
    cout << "ENTRY:    0x" << hex << bv->GetEntryPoint() << endl;
    cout << "PLATFORM: " << bv->GetDefaultPlatform()->GetName() << endl;
    cout << endl;

    cout << "---------- 10 Functions ----------" << endl;
    int x = 0;
    for (auto func: bv->GetAnalysisFunctionList()) {
        cout << hex << func->GetStart() << " " << func->GetSymbol()->GetFullName() << endl;
        if (++x >= 10)
            break;
    }
    cout << endl;

    cout << "---------- 10 Strings ----------" << endl;
    x = 0;
    for (auto str_ref: bv->GetStrings()) {
        char *str = (char *) malloc(str_ref.length + 1);
        bv->Read(str, str_ref.start, str_ref.length);
        str[str_ref.length] = 0;

        cout << hex << str_ref.start << " (" << dec << str_ref.length << ") " << str << endl;
        free(str);

        if (++x >= 10)
            break;
    }

    // Shutting down is required to allow for clean exit of the core
    BNShutdown();

    return 0;
}

```

`main.cpp`:

```cpp
// Copyright (c) skr0x1c0 2022.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.


#include <binaryninjacore.h>

#include <binja/utils/settings.h>
#include <binja/debuginfo/plugin_dsym.h>
#include <binja/debuginfo/plugin_macho.h>
#include <binja/debuginfo/plugin_symtab.h>
#include <binja/debuginfo/plugin_function_starts.h>
#include <binja/kcview/lib.h>

using namespace Binja;

extern "C" {
BN_DECLARE_CORE_ABI_VERSION

BINARYNINJAPLUGIN bool CorePluginInit() {
    Utils::BinjaSettings::Register();
    DebugInfo::PluginDSYM::RegisterPlugin();
    DebugInfo::PluginMacho::RegisterPlugin();
    DebugInfo::PluginSymtab::RegisterPlugin();
    DebugInfo::PluginFunctionStarts::RegisterPlugin();
    KCView::CorePluginInit();
    return true;
}
}
```