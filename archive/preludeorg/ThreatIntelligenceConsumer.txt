Project Path: arc_preludeorg_ThreatIntelligenceConsumer_n4ow8xhr

Source Tree:

```txt
arc_preludeorg_ThreatIntelligenceConsumer_n4ow8xhr
├── LICENSE
├── README.md
├── ThreatIntelligenceConsumer
│   ├── Helpers.cpp
│   ├── Helpers.hpp
│   ├── Hooks.asm
│   ├── Main.cpp
│   ├── SecurityTrace.cpp
│   ├── SecurityTrace.hpp
│   ├── ThreatIntelligenceCallback.cpp
│   ├── ThreatIntelligenceCallback.hpp
│   ├── ThreatIntelligenceConsumer.filters
│   ├── ThreatIntelligenceConsumer.sln
│   ├── ThreatIntelligenceConsumer.vcxproj
│   ├── ThreatIntelligenceConsumer.vcxproj.filters
│   ├── Trace.cpp
│   └── Trace.hpp
├── poc.png
└── threat_intel_auto_logger.reg

```

`LICENSE`:

```
Copyright (c) 2026 Prelude Research, Inc. All rights reserved.

This source code is provided solely for transparency, educational, and research purposes related to Prelude. It may be viewed, read, and discussed freely, but no license or rights are granted to use, copy, modify, merge, publish, distribute, sublicense, or sell copies of this code or its derivatives, in whole or in part, without express written permission from Prelude. This code is not open source under the Open Source Initiative (OSI) definition and remains proprietary intellectual property of Prelude.

For commercial licensing, partnerships, or permissions, please contact legal@preludesecurity.com
```

`README.md`:

```md
# ThreatIntelligenceConsumer
Proof-of-concept (POC) to consume from the Microsoft-Windows-Threat-Intelligence ETW provider without needing Protected Process Light (PPL) permissions/signing or a driver that does kernel-mode patching. It has been formally tested against Windows 11 24H2 and Windows 11 25H2 (alongside the latest Canary Insider Preview build, as of the time of this POC being uploaded).

## Output
![Screenshot](poc.png)

### Overview
`ThreatIntelligenceConsumer` takes advantage of logic surrounding how [AutoLogger](https://learn.microsoft.com/en-us/windows/win32/etw/configuring-and-starting-an-autologger-session) ETW sessions which consume from privileged ETW providers are "protected" from being consumed by lower-privileged processes.

Please see the [associated blog](https://www.originhq.com/blog/securitytrace-etw-ppl) for technical details.

### Requirements
1. Administrative privilege
2. Writing to the AutoLogger Registry key
3. Running `ThreatIntelligenceConsumer.exe`
4. x64. No other architecture is supported due to function hooking and custom assembly.

### Instructions
1. First, install the `threat_intel_auto_logger.reg` Registry key.
2. Reboot your machine. This is so your AutoLogger session will be registered and running when the machine boots
3. Compile and run the `ThreatIntelligenceConsumer` project and associated output executable.

### Caveats
- The `ThreatIntelligenceConsumer` project makes a best effort to determine the logger ID (`TraceProperties->Wnode.HistoricalContext`). This should work in 99.9% of cases since retrieving this value is very deterministic. However, if the logger ID is wrong the project will emit errors or, additionally, no ETW events will arrive. In this case, the logger ID can be extracted from a kernel debugger (see the blog for reasons why you cannot query an AutoLogger ETW session which is emitting Threat-Intelligence ETW events without PPL):

```js
lkd> dx ((nt!_WMI_LOGGER_CONTEXT*(*)[0x50])(((nt!_ESERVERSILO_GLOBALS*)&nt!PspHostSiloGlobals)->EtwSiloState->EtwpLoggerContext))->Where(l => l != 1)->Select(i => i->LoggerName)
((nt!_WMI_LOGGER_CONTEXT*(*)[0x50])(((nt!_ESERVERSILO_GLOBALS*)&nt!PspHostSiloGlobals)->EtwSiloState->EtwpLoggerContext))->Where(l => l != 1)->Select(i => i->LoggerName)                
    [2]              : "Circular Kernel Context Logger" [Type: _UNICODE_STRING]
    [3]              : "Eventlog-Security" [Type: _UNICODE_STRING]
    [4]              : "CimFSUnionFS-Filter" [Type: _UNICODE_STRING]
    [5]              : "SdmaTracingEvents" [Type: _UNICODE_STRING]
    [6]              : "DefenderApiLogger" [Type: _UNICODE_STRING]
    [7]              : "DefenderAuditLogger" [Type: _UNICODE_STRING]
    [8]              : "DiagLog" [Type: _UNICODE_STRING]
    [9]              : "Diagtrack-Listener" [Type: _UNICODE_STRING]
    [10]             : "EventLog-Application" [Type: _UNICODE_STRING]
    [11]             : "EventLog-Intel-SST-DVD-DVD_ETW_Telemetry" [Type: _UNICODE_STRING]
    [12]             : "MpWppUpdateLogging" [Type: _UNICODE_STRING]
    [13]             : "EventLog-Microsoft-Windows-Hotpatch-Monitor-Analytic" [Type: _UNICODE_STRING]
    [14]             : "EventLog-System" [Type: _UNICODE_STRING]
    [15]             : "FilterMgr-Logger" [Type: _UNICODE_STRING]
    [16]             : "iclsClient" [Type: _UNICODE_STRING]
    [17]             : "iclsProxy" [Type: _UNICODE_STRING]
    [18]             : "Intel-Gfx-Driver" [Type: _UNICODE_STRING]
    [19]             : "LwtNetLog" [Type: _UNICODE_STRING]
    [20]             : "Microsoft-Windows-Rdp-Graphics-RdpIdd-Trace" [Type: _UNICODE_STRING]
    [21]             : "8696EAC4-1288-4288-A4EE-49EE431B0AD9" [Type: _UNICODE_STRING]
    [22]             : "NetCore" [Type: _UNICODE_STRING]
    [23]             : "NtfsLog" [Type: _UNICODE_STRING]
    [24]             : "PlatformLicenseManagerService" [Type: _UNICODE_STRING]
    [25]             : "RadioMgr" [Type: _UNICODE_STRING]
    [26]             : "MpWppTracing-20260103-050646-00000003-fffffffeffffffff" [Type: _UNICODE_STRING]
    [27]             : "ReFSLog" [Type: _UNICODE_STRING]
    [28]             : "WPR_initiated_DiagTrackAotLogger_WPR System Collector" [Type: _UNICODE_STRING]
    [29]             : "WinDiag-Realtime-Session" [Type: _UNICODE_STRING]
    [30]             : "UBPM" [Type: _UNICODE_STRING]
    [31]             : "WdiContextLog" [Type: _UNICODE_STRING]
    [32]             : "WiFiDriverIHVSession" [Type: _UNICODE_STRING]
    [33]             : "WiFiSession" [Type: _UNICODE_STRING]
    [35]             : "umstartup" [Type: _UNICODE_STRING]
    [36]             : "SCM" [Type: _UNICODE_STRING]
    [37]             : "SleepStudyTraceSession" [Type: _UNICODE_STRING]
    [38]             : "COM" [Type: _UNICODE_STRING]
    [39]             : "Terminal-Services-LSM" [Type: _UNICODE_STRING]
    [40]             : "Terminal-Services-RCM" [Type: _UNICODE_STRING]
    [41]             : "UpdateSessionOrchestration" [Type: _UNICODE_STRING]
    [42]             : "UserMgr" [Type: _UNICODE_STRING]
    [43]             : "CldFltLog" [Type: _UNICODE_STRING]
    [44]             : "WFP-IPsec Diagnostics" [Type: _UNICODE_STRING]
    [45]             : "ScreenOnPowerStudyTraceSession" [Type: _UNICODE_STRING]
    [46]             : "Admin_PS_Provider" [Type: _UNICODE_STRING]
    [49]             : "SMLS_Trace_Listener" [Type: _UNICODE_STRING]
    [50]             : "MoUxCoreWorker" [Type: _UNICODE_STRING]
    [51]             : "MpWppCoreTracing-20260102-230646-00000003-100000000" [Type: _UNICODE_STRING]
    [52]             : "1DSListener" [Type: _UNICODE_STRING]
    [53]             : "SHS-01022026-231728-7-1ff" [Type: _UNICODE_STRING]
    [54]             : "WPR_initiated_DiagTrackMiniLogger_WPR System Collector" [Type: _UNICODE_STRING]
    [55]             : "WINNETESP" [Type: _UNICODE_STRING]
```

The associated index is the ID. for instance, `DiagLog` (seen above) is logger ID `8`.

- The project simply just prints the GUID of the provider of which the ETW event was emitted (the Threat-Intelligence GUID). Event parsing is up to the user to implement. See details of how to parse manifest-based ETW providers via [TDH](https://learn.microsoft.com/en-us/windows/win32/etw/retrieving-event-data-using-tdh).

- The keyword mask for the provider is hardcoded to enable all Threat-Intelligence ETW events.
```

`ThreatIntelligenceConsumer/Helpers.cpp`:

```cpp
/*++
*
* @file:      ThreatIntelligenceConsumer/Helpers.cpp
*
* @summary:   Various helper functions.
*
* @author:    Connor McGarr (@33y0re)
*
--*/
#include "Helpers.hpp"
#include <string>

/**
*
* @brief			Retrieves the trace properties of our target AutoLogger from the Registry.
* @param[in,out]    TraceProperties - The target trace properties to populate.
* @return			ERROR_SUCCESS on success, otherwise appropriate error code.
*
*/
ULONG
RetrieveAutoLoggerTraceProperties (
	_Inout_ PEVENT_TRACE_PROPERTIES* TraceProperties,
	_In_ ULONG TracePropertiesSize
	)
{
	LSTATUS status;
	ULONG error;
	HKEY regHandle;
	ULONG historicalContext;
	ULONG doubleWordSize;
	ULONG guidStringSize;
	bool loggerFound;
	PEVENT_TRACE_PROPERTIES traceProps;
	PEVENT_TRACE_PROPERTIES tempProps;

	//
	// A GUID is 80 bytes as a string (78 + null terminator)
	//
	WCHAR guidString[78 + sizeof(UNICODE_NULL)];

	status = ERROR_SUCCESS;
	error = ERROR_SUCCESS;
	regHandle = nullptr;
	historicalContext = 0;
	doubleWordSize = sizeof(DWORD);
	guidStringSize = (78 + sizeof(UNICODE_NULL));
	loggerFound = false;
	traceProps = *TraceProperties;
	tempProps = nullptr;

	RtlZeroMemory(&guidString, sizeof(guidString));

	status = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
						   AUTO_LOGGER_REGISTRY_PATH,
						   0,
						   KEY_READ,
						   &regHandle);
	if (status != ERROR_SUCCESS)
	{
		wprintf(L"[-] RegOpenKeyExW failed in RetrieveAutoLoggerTraceProperties! (Error: 0x%lx)\n", status);
		goto Exit;
	}

	//
	// The "HistoricalContext" value is the trace ID. We need to know
	// what the ID is for our trace properties, since we cannot query for it.
	// A query requires PPL (which we don't have).
	// 
	// AutoLogger trace sessions are assigned IDs starting at 2 and each
	// session (generally speaking) is enabled alphabetically (the exceptions
	// being session 3 and some of the other "earlier" sessions).
	// 
	// Since we know that our session has SecurityTrace enabled, a query
	// will result in access denied. However, there could be other
	// traces which also SecurityTrace enabled.
	// 
	// So what we do is we enumerate the number of AutoLoggers in the registry.
	// The "numbers" relatively map to the trace ID. So, therefore, the trace
	// session being used starts with the value "0" (MY_TRACE_NAME) - meaning
	// it will be the FIRST session alphabetically. The "ultimate" would just
	// to have the session name be exactly "0", as this always "wins" - but this
	// is a POC and we want some way to make the session truly attributable.
	// 
	// Since we assume our entry will be "first" alphabetically, we can brute-force
	// the ID this way. Starting with the first valid value (2 is the first ID - reserved usually
	// for the legacy kernel session and 3 is hardcoded for EventLog-Security), we call ControlTraceW
	// with EVENT_TRACE_CONTROL_QUERY. Access denied indicates the trace has SecurityTrace
	// enabled - and that this is our trace session.
	// 
	// This is obviously not perfect, but this is a POC! It should work in almost all scenarios.
	//

	//
	// Start brute-forcing the various logger IDs.
	//
	tempProps = reinterpret_cast<PEVENT_TRACE_PROPERTIES>(malloc(TracePropertiesSize));
	if (tempProps == nullptr)
	{
		wprintf(L"[-] malloc failed in RetrieveAutoLoggerTraceProperties! (GLE: %d)\n", GetLastError());

		status = ERROR_OUTOFMEMORY;
		goto Exit;
	}

	//
	// As mentioned, really "4" is the first valid ID to check.
	//
	for (ULONG i = 4; i < MAX_LOGGERS; i++)
	{
		//
		// Reset the placeholder properties
		//
		RtlZeroMemory(tempProps, TracePropertiesSize);

		RtlCopyMemory(tempProps,
					  *TraceProperties,
					  TracePropertiesSize);

		//
		// Our trace ID should always realistically be the first. However,
		// we are doing our due diligence by ensuring we find the first
		// session that results in access denied.
		//
		error = ControlTraceW(static_cast<TRACEHANDLE>(i),
							  NULL,
							  tempProps,
							  EVENT_TRACE_CONTROL_QUERY);

		//
		// We are looking for the first access denied error,
		// which indicates a session has SecurityTrace enabled.
		//
		if (error != ERROR_ACCESS_DENIED)
		{
			continue;
		}

		//
		// Access denied - this is our logger!
		//
		historicalContext = i;
		loggerFound = true;

		break;
	}

	if (!loggerFound)
	{
		wprintf(L"[-] Error! Could not find %s in the AutoLoggers!\n", MY_TRACE_NAME);

		status = ERROR_NOT_FOUND;
		goto Exit;
	}

	//
	// Update the logger ID
	//
	traceProps->Wnode.HistoricalContext = historicalContext;

	//
	// BufferSize
	//
	status = RegGetValueW(regHandle,
						  MY_TRACE_NAME,
						  L"BufferSize",
						  RRF_RT_REG_DWORD,
						  NULL,
						  &traceProps->BufferSize,
						  &doubleWordSize);
	if (status != ERROR_SUCCESS)
	{
		wprintf(L"[-] RegGetValueW failed in RetrieveAutoLoggerTraceProperties! (Error: 0x%lx)\n", status);
		goto Exit;
	}

	//
	// ClockType
	//
	status = RegGetValueW(regHandle,
						  MY_TRACE_NAME,
						  L"ClockType",
						  RRF_RT_REG_DWORD,
						  NULL,
						  &traceProps->Wnode.ClientContext,
						  &doubleWordSize);
	if (status != ERROR_SUCCESS)
	{
		wprintf(L"[-] RegGetValueW failed in RetrieveAutoLoggerTraceProperties! (Error: 0x%lx)\n", status);
		goto Exit;
	}

	//
	// FlushTimer
	//
	status = RegGetValueW(regHandle,
						  MY_TRACE_NAME,
						  L"FlushTimer",
						  RRF_RT_REG_DWORD,
						  NULL,
						  &traceProps->FlushTimer,
						  &doubleWordSize);
	if (status != ERROR_SUCCESS)
	{
		wprintf(L"[-] RegGetValueW failed in RetrieveAutoLoggerTraceProperties! (Error: 0x%lx)\n", status);
		goto Exit;
	}

	//
	// GUID (as string)
	//
	status = RegGetValueW(regHandle,
						  MY_TRACE_NAME,
						  L"Guid",
						  RRF_RT_REG_SZ,
						  NULL,
						  &guidString,
						  &guidStringSize);
	if (status != ERROR_SUCCESS)
	{
		wprintf(L"[-] RegGetValueW failed in RetrieveAutoLoggerTraceProperties! (Error: 0x%lx)\n", status);
		goto Exit;
	}

	if (CLSIDFromString(guidString,
						reinterpret_cast<LPCLSID>(&traceProps->Wnode.Guid)) != S_OK)
	{
		wprintf(L"[-] CLSIDFromString failed in RetrieveAutoLoggerTraceProperties! (Error: 0x%lx)\n", status);
		goto Exit;
	}

	//
	// LogFileMode
	//
	status = RegGetValueW(regHandle,
						  MY_TRACE_NAME,
						  L"LogFileMode",
						  RRF_RT_REG_DWORD,
						  NULL,
						  &traceProps->LogFileMode,
						  &doubleWordSize);
	if (status != ERROR_SUCCESS)
	{
		wprintf(L"[-] RegGetValueW failed in RetrieveAutoLoggerTraceProperties! (Error: 0x%lx)\n", status);
		goto Exit;
	}


	//
	// MaximumBuffers
	//
	status = RegGetValueW(regHandle,
						  MY_TRACE_NAME,
						  L"MaximumBuffers",
						  RRF_RT_REG_DWORD,
						  NULL,
						  &traceProps->MaximumBuffers,
						  &doubleWordSize);
	if (status != ERROR_SUCCESS)
	{
		wprintf(L"[-] RegGetValueW failed in RetrieveAutoLoggerTraceProperties! (Error: 0x%lx)\n", status);
		goto Exit;
	}

	//
	// MinimumBuffers
	//
	status = RegGetValueW(regHandle,
						  MY_TRACE_NAME,
						  L"MinimumBuffers",
						  RRF_RT_REG_DWORD,
						  NULL,
						  &traceProps->MinimumBuffers,
						  &doubleWordSize);
	if (status != ERROR_SUCCESS)
	{
		wprintf(L"[-] RegGetValueW failed in RetrieveAutoLoggerTraceProperties! (Error: 0x%lx)\n", status);
		goto Exit;
	}

	*TraceProperties = traceProps;
	status = ERROR_SUCCESS;

Exit:
	if (regHandle != nullptr)
	{
		RegCloseKey(regHandle);
	}

	if (tempProps != nullptr)
	{
		free(tempProps);
	}

	return static_cast<ULONG>(status);
}
```

`ThreatIntelligenceConsumer/Helpers.hpp`:

```hpp
#pragma once
#include "Trace.hpp"

#define MAX_LOGGERS 0x50
#define MY_TRACE_NAME L"0MyThreatIntelTrace"
#define AUTO_LOGGER_REGISTRY_PATH L"SYSTEM\\CurrentControlSet\\Control\\WMI\\Autologger"

ULONG
RetrieveAutoLoggerTraceProperties (
	_Inout_ PEVENT_TRACE_PROPERTIES* TraceProperties,
	_In_ ULONG TracePropertiesSize
	);
```

`ThreatIntelligenceConsumer/Hooks.asm`:

```asm
; /*++
; *
; * @file:      ThreatIntelligenceConsumer/Hooks.asm
; *
; * @summary:   ControlTraceW hook implementation.
; *
; * @author:    Connor McGarr (@33y0re)
; *
; --*/

.CODE

extern k_TraceProperties:QWORD
extern g_OriginalControlTraceW:QWORD

; RCX: TraceId
; RDX: InstanceName
; R8: Properties
; R9: ControlCode
MyControlTraceW PROC
	; If the target operation is anything other than a query,
	; jump to the real ControlTraceW function.
	cmp r9, 0 ; EVENT_TRACE_CONTROL_QUERY
	je hooked_control_tracew
	jmp real_control_tracew

hooked_control_tracew:
	; RDI, RSI, and RCX are going to be used here.
	; Preserve them. Also the flags.
	pushfq
	push rdi
	push rsi
	push rcx

	; R8 is a structure on the stack. Therefore
	; we need to memcpy instead of just assigning
	; the value.
	mov rdi, r8
	mov rsi, k_TraceProperties
	xor rax, rax
	mov eax, 20Fh                    ; Counter: 0x1078 / 8 = 0x20F (527 qwords)

	; memcpy implementation.
memcpy_loop:
    mov rcx, qword ptr [rsi]       ; Read 8 bytes from source
    mov qword ptr [rdi], rcx       ; Write 8 bytes to destination
    add rsi, 8                     ; Advance source
    add rdi, 8                     ; Advance destination
    dec eax                        ; Decrement counter
    jnz memcpy_loop

	; Restore non-volatile registers. And flags.
	pop rcx
	pop rsi
	pop rdi
	popfq

	; bail
	jmp exit_label

exit_label:
	; ERROR_SUCCESS
	xor rax, rax
	ret

; Forward to standalone trampoline that properly executes
; the original ControlTraceW with all parameters intact.
real_control_tracew:
	; Simply jump to the trampoline function in allocated memory.
	; All parameters (RCX, RDX, R8, R9) are still intact.
	; The trampoline will execute the original bytes and return properly.
	int 3
	jmp qword ptr [g_OriginalControlTraceW]
MyControlTraceW ENDP

END
```

`ThreatIntelligenceConsumer/Main.cpp`:

```cpp
/*++
*
* @file:      ThreatIntelligenceConsumer/Main.cpp
*
* @summary:   ThreatIntelligenceConsumer entry point.
*
* @author:    Connor McGarr (@33y0re)
*
--*/
#include "Trace.hpp"
#include "SecurityTrace.hpp"
#include "ThreatIntelligenceCallback.hpp"
#include "Helpers.hpp"

/**
*
* @brief        ThreatIntelligenceConsumer entry point.
* @param[in]    argc - Number of arguments.
* @param[in]	argv - Argument array.
* @return       ERROR_SUCCESS on success, otherwise appropriate error code.
*
*/
int
wmain (
	_In_ int argc,
	_In_ wchar_t** argv
	)
{
	ULONG error;
	PEVENT_TRACE_PROPERTIES traceProperties;
	HANDLE traceThread;

	error = ERROR_GEN_FAILURE;
	traceProperties = nullptr;
	traceThread = nullptr;

	error = ConfigureTracingProperties(&traceProperties,
									   MY_TRACE_NAME,
									   sizeof(MY_TRACE_NAME));
	if (error != ERROR_SUCCESS)
	{
		goto Exit;
	}

	error = RetrieveAutoLoggerTraceProperties(&traceProperties,
											  TRACE_PROPS_SIZE);
	if (error != ERROR_SUCCESS)
	{
		goto Exit;
	}

	//
	// Store the updated trace properties for the assembly thunk.
	//
	PreserveTraceProperties(traceProperties);

	//
	// Now patch ControlTraceW.
	//
	PatchControlTrace();

	//
	// Start consuming events
	//
	error = StartTracing(HandleThreatIntelligenceCallback,
						 &traceThread,
						 MY_TRACE_NAME);
	if (error != ERROR_SUCCESS)
	{
		wprintf(L"[-] StartTracing failed for MyTrace! (Error: 0x%lx)\n", error);
		goto Exit;
	}

	getchar();

Exit:
	//
	// Notice we do not stop the AutoLogger session here
	// by calling ControlTraceW with EVENT_TRACE_CONTROL_STOP.
	// Instead, this allows users to consume Threat-Intelligence
	// events once more when the application has exited.
	// 
	// You could call ControlTraceW here if desired.
	//
	if (traceThread != nullptr)
	{
		CloseHandle(traceThread);
	}

	CleanupSecurityTraceResources();

	return error;
}
```

`ThreatIntelligenceConsumer/SecurityTrace.cpp`:

```cpp
/*++
*
* @file:      ThreatIntelligenceConsumer/SecurityTrace.cpp
*
* @summary:   Functionality for consuming ETW trace sessions with SecurityTrace without PPL.
*
* @author:    Connor McGarr (@33y0re)
*
--*/
#include "SecurityTrace.hpp"
#include "Helpers.hpp"

//
// C linkage for Hooks.asm
//
extern "C"
{
    PEVENT_TRACE_PROPERTIES k_TraceProperties = nullptr;
	ControlTraceW_t g_OriginalControlTraceW = nullptr;
};

//
// Hooks.asm
//
extern
"C"
FORCEINLINE
ULONG
__fastcall
MyControlTraceW (
    _In_ CONTROLTRACE_ID TraceId,
    _In_ LPCWSTR InstanceName,
    _Inout_ PEVENT_TRACE_PROPERTIES Properties,
    _In_ ULONG ControlCode
    );

/**
*
* @brief        Creates the detour for non-query ControlTraceW calls.
* @param[in]    FunctionAddress - ControlTraceW's address.
* @param[in]	OriginalBytes - Original 14 bytes from ControlTraceW.
* @param[in]	SizeOfOriginalBytes - The size of the original bytes (14 bytes for a relative JMP).
* @return       The detour trampoline on success, otherwise NULL.
*
*/
static
PVOID
CreateControlTraceDetour (
	_In_ ULONG_PTR FunctionAddress,
	_In_ BYTE* OriginalBytes,
	_In_ SIZE_T SizeOfOriginalBytes
	)
{
	PVOID trampolineMemory;
	SIZE_T trampolineSize;
	BYTE* trampoline;
    ULONG oldProtection;

	trampolineMemory = nullptr;

    //
	// The installed hook is a jump (14 bytes). So we need to compensate
	// for this, plus the _additional_ absolute jump we will add to the trampoline.
    //
	trampolineSize = SizeOfOriginalBytes + SECURITY_TRACE_HOOK_SIZE;
	trampoline = nullptr;
    oldProtection = 0;

	//
	// Allocate the trampoline
	//
    trampolineMemory = malloc(trampolineSize);
    if (trampolineMemory == NULL)
    {
        wprintf(L"[-] Error! malloc failed in CreateControlTraceDetour! (GLE: %d)\n", GetLastError());
        goto Exit;
	}

    //
	// Mark the trampoline memory as executable
    //
    if (VirtualProtect(trampolineMemory,
                       trampolineSize,
                       PAGE_EXECUTE_READWRITE,
                       &oldProtection) == FALSE)
    {
        wprintf(L"[-] VirtualProtect! malloc failed in CreateControlTraceDetour! (GLE: %d)\n", GetLastError());
        goto Exit;
    }

	trampoline = (BYTE*)trampolineMemory;

	//
	// Copy original bytes
	//
	RtlCopyMemory(trampoline,
                  OriginalBytes,
                  SizeOfOriginalBytes);

	//
	// Build absolute JMP to ControlTraceW index
    // for legitimate execution (detours for non-query calls).
	//
	trampoline[SizeOfOriginalBytes + 0] = 0xFF;
	trampoline[SizeOfOriginalBytes + 1] = 0x25;
	*(ULONG*)(&trampoline[SizeOfOriginalBytes + 2]) = 0;  // RIP + 0
	*(ULONG_PTR*)(&trampoline[SizeOfOriginalBytes + 6]) = FunctionAddress + SizeOfOriginalBytes;

	//
	// We have updated some code. Flush the instruction cache.
	//
	FlushInstructionCache(GetCurrentProcess(),
                          trampolineMemory,
                          trampolineSize);

Exit:
	return trampolineMemory;
}

/**
*
* @brief        Patches ControlTraceW to avoid the query operation for the SecurityTrace session.
* @return       true on success, otherwise false.
*
*/
bool
PatchControlTrace ()
{
    bool result;
    HMODULE sechost;
    BYTE trampoline[14];
    SIZE_T writtenBytes;
    ULONG_PTR controlTraceW;
    ULONG controlTraceWSize;
    BYTE* originalControlTraceWBytes;

    writtenBytes = 0;
    controlTraceW = 0;
    controlTraceWSize = 0;
    originalControlTraceWBytes = nullptr;
    result = false;

    RtlZeroMemory(&trampoline, sizeof(trampoline));

	sechost = GetModuleHandleW(L"sechost.dll");
    if (sechost == NULL)
    {
        wprintf(L"[-] Error! GetModuleHandleW failed in PatchControlTrace! (GLE: %d)\n", GetLastError());
        goto Exit;
	}

    controlTraceW = reinterpret_cast<ULONG_PTR>(GetProcAddress(sechost, "ControlTraceW"));
    if (controlTraceW == 0)
    {
        wprintf(L"[-] Error! GetProcAddress failed in PatchControlTrace! (GLE: %d)\n", GetLastError());
        goto Exit;
    }

    //
    // Preserve ControlTraceW's original bytes.
    //
    originalControlTraceWBytes = reinterpret_cast<BYTE*>(malloc(SECURITY_TRACE_HOOK_SIZE));
    if (originalControlTraceWBytes == nullptr)
    {
        wprintf(L"[-] Error! malloc failed in PatchControlTrace! (GLE: %d)\n", GetLastError());
        goto Exit;
    }

	RtlZeroMemory(originalControlTraceWBytes, SECURITY_TRACE_HOOK_SIZE);

    //
    // Store the original bytes for ControlTraceW.
    //
    RtlCopyMemory(originalControlTraceWBytes,
                  reinterpret_cast<PVOID>(controlTraceW),
		          SECURITY_TRACE_HOOK_SIZE);

    //
    // Create standalone trampoline in separate executable memory
    // This will properly forward non-query calls to the original ControlTraceW
    //
    g_OriginalControlTraceW = reinterpret_cast<ControlTraceW_t>(CreateControlTraceDetour(controlTraceW,
                                                                                         originalControlTraceWBytes,
                                                                                         SECURITY_TRACE_HOOK_SIZE));
    if (g_OriginalControlTraceW == nullptr)
    {
        wprintf(L"[-] Error! CreateTrampoline failed in PatchControlTrace!\n");
        goto Exit;
    }

    //
    // RIP-relative jump into our patched function.
    //
    trampoline[0] = 0xFF;
    trampoline[1] = 0x25;

    //
    // Jump displacement is 0
    //
    *(ULONG*)(&trampoline[2]) = 0;
    *(ULONG_PTR*)(&trampoline[6]) = reinterpret_cast<ULONG_PTR>(MyControlTraceW);

    if (WriteProcessMemory(GetCurrentProcess(),
                           reinterpret_cast<PVOID>(controlTraceW),
                           trampoline,
                           sizeof(trampoline),
                           &writtenBytes) == FALSE)
    {
        wprintf(L"[-] Error! WriteProcessMemory failed in PatchEtwpQueryRealTimeTraceProperties! (GLE: %d)\n", GetLastError());
		goto Exit;
    }

    result = true;

Exit:
    if (originalControlTraceWBytes != NULL)
    {
        free(originalControlTraceWBytes);
    }

    return result;
}

/**
*
* @brief       Preserves the trace properties so we can "mimic" a query operation.
*
*/
void
PreserveTraceProperties (
	_In_ PEVENT_TRACE_PROPERTIES TraceProperties
    )
{
	k_TraceProperties = TraceProperties;

    return;
}

/**
*
* @brief        frees the detour trampoline memory.
*
*/
void
CleanupSecurityTraceResources ()
{
    if (g_OriginalControlTraceW != nullptr)
    {
        free(g_OriginalControlTraceW);
	}
}
```

`ThreatIntelligenceConsumer/SecurityTrace.hpp`:

```hpp
#pragma once
#include <Windows.h>
#include <evntrace.h>
#include <evntcons.h>
#include <stdio.h>
#include <winternl.h>

#define SECURITY_TRACE_HOOK_SIZE 14

//
// Function pointer typedef for ControlTraceW
//
typedef
ULONG
(WINAPI *ControlTraceW_t)(
    _In_ CONTROLTRACE_ID TraceHandle,
    _In_ LPCWSTR InstanceName,
    _Inout_ PEVENT_TRACE_PROPERTIES Properties,
    _In_ ULONG ControlCode
    );

//
// Function definitions
//
void
PreserveTraceProperties (
    _In_ PEVENT_TRACE_PROPERTIES TraceProperties
    );

bool
PatchControlTrace ();

void
CleanupSecurityTraceResources ();
```

`ThreatIntelligenceConsumer/ThreatIntelligenceCallback.cpp`:

```cpp
/*++
*
* @file:      ThreatIntelligenceConsumer/Callback.cpp
*
* @summary:   ETW callback implementation.
*
* @author:    Connor McGarr (@33y0re)
*
--*/
#include "ThreatIntelligenceCallback.hpp"

/**
*
* @brief        Threat-Intelligence ETW callback.
* @param[in]    EventRecord - Associated ETW event record.
*
*/
void
HandleThreatIntelligenceCallback (
    _In_ PEVENT_RECORD EventRecord
    )
{
    wprintf(L"[+] [HandleThreatIntelligenceCallback] Hello from the Threat-Intelligence ETW callback!\n");

    //
    // Print the GUID
    //
    wprintf(L"  [*] GUID = {%08lX-%04hX-%04hX-%02hhX%02hhX-%02hhX%02hhX%02hhX%02hhX%02hhX%02hhX}\n",
            EventRecord->EventHeader.ProviderId.Data1,
            EventRecord->EventHeader.ProviderId.Data2,
            EventRecord->EventHeader.ProviderId.Data3,
            EventRecord->EventHeader.ProviderId.Data4[0],
            EventRecord->EventHeader.ProviderId.Data4[1],
            EventRecord->EventHeader.ProviderId.Data4[2],
            EventRecord->EventHeader.ProviderId.Data4[3],
            EventRecord->EventHeader.ProviderId.Data4[4],
            EventRecord->EventHeader.ProviderId.Data4[5],
            EventRecord->EventHeader.ProviderId.Data4[6],
            EventRecord->EventHeader.ProviderId.Data4[7]);

    return;
}
```

`ThreatIntelligenceConsumer/ThreatIntelligenceCallback.hpp`:

```hpp
#pragma once
#include "Trace.hpp"

void
HandleThreatIntelligenceCallback (
    _In_ PEVENT_RECORD EventRecord
    );
```

`ThreatIntelligenceConsumer/ThreatIntelligenceConsumer.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Source.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Trace.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="SecurityTracePoc.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Trace.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="SecurityTracePoc.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="Hooks.asm">
      <Filter>Source Files</Filter>
    </MASM>
  </ItemGroup>
</Project>
```

`ThreatIntelligenceConsumer/ThreatIntelligenceConsumer.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.14.36401.2 d17.14
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ThreatIntelligenceConsumer", "ThreatIntelligenceConsumer.vcxproj", "{35F50F8F-4747-43CF-9BEF-36057001744C}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{35F50F8F-4747-43CF-9BEF-36057001744C}.Debug|x64.ActiveCfg = Debug|x64
		{35F50F8F-4747-43CF-9BEF-36057001744C}.Debug|x64.Build.0 = Debug|x64
		{35F50F8F-4747-43CF-9BEF-36057001744C}.Debug|x86.ActiveCfg = Debug|Win32
		{35F50F8F-4747-43CF-9BEF-36057001744C}.Debug|x86.Build.0 = Debug|Win32
		{35F50F8F-4747-43CF-9BEF-36057001744C}.Release|x64.ActiveCfg = Release|x64
		{35F50F8F-4747-43CF-9BEF-36057001744C}.Release|x64.Build.0 = Release|x64
		{35F50F8F-4747-43CF-9BEF-36057001744C}.Release|x86.ActiveCfg = Release|Win32
		{35F50F8F-4747-43CF-9BEF-36057001744C}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {07DE7097-CA1A-4BC4-B651-D234604500D1}
	EndGlobalSection
EndGlobal

```

`ThreatIntelligenceConsumer/ThreatIntelligenceConsumer.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{35f50f8f-4747-43cf-9bef-36057001744c}</ProjectGuid>
    <RootNamespace>SecurityTracePoc</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>ThreatIntelligenceConsumer</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Helpers.cpp" />
    <ClCompile Include="SecurityTrace.cpp" />
    <ClCompile Include="Main.cpp" />
    <ClCompile Include="ThreatIntelligenceCallback.cpp" />
    <ClCompile Include="Trace.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Helpers.hpp" />
    <ClInclude Include="SecurityTrace.hpp" />
    <ClInclude Include="ThreatIntelligenceCallback.hpp" />
    <ClInclude Include="Trace.hpp" />
  </ItemGroup>
  <ItemGroup>
    <MASM Include="Hooks.asm" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>
```

`ThreatIntelligenceConsumer/ThreatIntelligenceConsumer.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="SecurityTrace.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Trace.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ThreatIntelligenceCallback.cpp">
      <Filter>ThreatIntelligenceCallback</Filter>
    </ClCompile>
    <ClCompile Include="Helpers.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="SecurityTrace.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Trace.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ThreatIntelligenceCallback.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Helpers.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{bd943827-7367-478a-9dfa-c2011f22b93e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{af6015ec-0af5-482f-9e8c-94d43244b54f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Assembly Files">
      <UniqueIdentifier>{45dfeab7-cca7-4408-b78f-b5b888f84e07}</UniqueIdentifier>
    </Filter>
    <Filter Include="ThreatIntelligenceCallback">
      <UniqueIdentifier>{4bafb50c-a462-4c81-9bcb-e9670ef8a546}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="Hooks.asm">
      <Filter>Assembly Files</Filter>
    </MASM>
  </ItemGroup>
</Project>
```

`ThreatIntelligenceConsumer/Trace.cpp`:

```cpp
/*++
*
* @file:      ThreatIntelligenceConsumer/Trace.cpp
*
* @summary:   ETW trace session management functionality.
*
* @author:    Connor McGarr (@33y0re)
*
--*/
#include "Trace.hpp"

/**
*
* @brief        Calls ProcessTrace on a separate thread to receive ETW events.
*
*/
static
void
ProcessMyTrace (
    _In_ PVOID TraceHandle
    )
{
    ULONG error;
    PROCESSTRACE_HANDLE* traceHandle;

    traceHandle = (PROCESSTRACE_HANDLE*)TraceHandle;

    //
    // Begin.
    //
    error = ProcessTrace(traceHandle, 1, NULL, NULL);
    if (error != ERROR_SUCCESS)
    {
        error = GetLastError();
        wprintf(L"[-] Error in ProcessTrace! (Error: 0x%lx)\n", error);
        goto Exit;
    }

    //
    // ProcessTrace only returns when we have finished processing events
    // (when ControlTrace w/ stop code is invoked)
    //
    CloseTrace(*traceHandle);

Exit:
    return;
}

/**
*
* @brief            Configures the non-AutoLogger trace settings
* @param[in,out]    TraceProperties - The trace properties,
* @param[in]        TraceName - The name of the ETW session.
* @param[in]        TraceNameSize - The size of the ETW session name.
* @return           ERROR_SUCCESS on success, otherwise appropriate Win32 error code.
*
*/
ULONG
ConfigureTracingProperties (
    _Inout_ PEVENT_TRACE_PROPERTIES* TraceProperties,
    _In_ LPCWSTR TraceName,
    _In_ ULONG TraceNameSize
    )
{
    ULONG error;
    PEVENT_TRACE_PROPERTIES traceProperties;

    error = ERROR_SUCCESS;

    traceProperties = (PEVENT_TRACE_PROPERTIES)malloc(TRACE_PROPS_SIZE);
    if (traceProperties == NULL)
    {
        wprintf(L"[-] malloc error in ConfigureTracingProperties!\n");
        error = ERROR_INSUFFICIENT_BUFFER;
        goto Exit;
    }

    //
    // This is necessary!
    //
    RtlZeroMemory(traceProperties, TRACE_PROPS_SIZE);

    //
    // Everything else is the standard settings not applicable to AutoLogger.
    // All other applicable settings (like max/min buffers come from the registry).
    //
    traceProperties->Wnode.BufferSize = TRACE_PROPS_SIZE;
    traceProperties->Wnode.Flags = WNODE_FLAG_TRACED_GUID;
    traceProperties->LogFileNameOffset = 0;
    traceProperties->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);

    //
    // Remember, we are dealing with AutoLogger here. There is no call
    // to StartTrace.
    //
	wprintf(L"[+] Successfully configured the tracing properties for the target ETW session!\n");

    *TraceProperties = traceProperties;

Exit:
    return error;
}

/**
*
* @brief        Configures the non-AutoLogger trace settings
* @param[in]    TraceProperties - The trace properties,
* @param[out]   ThreadHandle - The output thread handle the trace is being processed on.
* @param[in]    TraceName - The name of the target ETW trace to consume from.
* @return       ERROR_SUCCESS on success, otherwise appropriate Win32 error code.
*
*/
ULONG
StartTracing (
    _In_ PEVENT_RECORD_CALLBACK EventCallback,
    _Out_opt_ PHANDLE ThreadHandle,
    _In_ LPCWSTR TraceName
    )
{
    ULONG error;
    EVENT_TRACE_LOGFILEW traceLogFile;
    PROCESSTRACE_HANDLE* traceHandle;
    bool traceOpened;

    error = ERROR_SUCCESS;
    traceOpened = false;

    RtlZeroMemory(&traceLogFile, sizeof(traceLogFile));

    traceLogFile.ProcessTraceMode = PROCESS_TRACE_MODE_REAL_TIME |
                                    PROCESS_TRACE_MODE_EVENT_RECORD |
                                    PROCESS_TRACE_MODE_RAW_TIMESTAMP;
    traceLogFile.LoggerName = (LPWSTR)TraceName;
    traceLogFile.EventRecordCallback = EventCallback;

    if (ThreadHandle)
    {
        *ThreadHandle = NULL;
    }

    traceHandle = (PROCESSTRACE_HANDLE*)malloc(sizeof(PROCESSTRACE_HANDLE));
    if (traceHandle == NULL)
    {
        wprintf(L"[-] malloc error in StartTracing!\n");
        error = ERROR_INSUFFICIENT_BUFFER;
        goto Exit;
    }

    *traceHandle = OpenTraceW(&traceLogFile);
    if (*traceHandle == INVALID_PROCESSTRACE_HANDLE)
    {
        error = GetLastError();
        wprintf(L"[-] Error in OpenTraceW! (Error: 0x%lx)\n", error);
        goto Exit;
    }

    traceOpened = true;

    if (ThreadHandle)
    {
        *ThreadHandle = CreateThread(NULL,
                                     0,
                                     (LPTHREAD_START_ROUTINE)ProcessMyTrace,
                                     traceHandle,
                                     0,
                                     NULL);
        if (*ThreadHandle == NULL)
        {
            error = GetLastError();
            wprintf(L"[-] Error in OpenTraceW! (Error: 0x%lx)\n", error);
            goto Exit;
        }
    }
    else
    {
        ProcessMyTrace(traceHandle);
    }

    wprintf(L"[+] Started processing!\n");

Exit:
    if (error != ERROR_SUCCESS)
    {
        if (traceOpened)
        {
            CloseTrace(*traceHandle);
        }
    }

    return error;
}
```

`ThreatIntelligenceConsumer/Trace.hpp`:

```hpp
#pragma once
#include <Windows.h>
#include <evntrace.h>
#include <evntcons.h>
#include <stdio.h>

//
// sechost!EtwpQueryRealTimeTraceProperties uses this size.
//
#define TRACE_PROPS_SIZE 0x1078

ULONG
ConfigureTracingProperties (
    _Inout_ PEVENT_TRACE_PROPERTIES* TraceProperties,
    _In_ LPCWSTR TraceName,
    _In_ ULONG TraceNameSize
    );

ULONG
StartTracing (
    _In_ PEVENT_RECORD_CALLBACK EventCallback,
    _Out_opt_ PHANDLE ThreadHandle,
    _In_ LPCWSTR TraceName
    );
```

`threat_intel_auto_logger.reg`:

```reg
Windows Registry Editor Version 5.00

[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\WMI\Autologger\0MyThreatIntelTrace]
"Age"=dword:00000001
"BufferSize"=dword:00000040
"ClockType"=dword:00000001
"FlushTimer"=dword:00000001
"GUID"="{7F6E5C2A-1B9D-4E3A-8C61-2F4B8A91D7C8}"
"LogFileMode"=dword:00000100
"MaximumBuffers"=dword:00000010
"MinimumBuffers"=dword:00000000
"Start"=dword:00000001
"Status"=dword:00000000

[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\WMI\Autologger\0MyThreatIntelTrace\{f4e1897c-bb5d-5668-f1d8-040f4d8dd344}]
"Enabled"=dword:00000001
"EnableLevel"=dword:00000004
"MatchAnyKeyword"=hex(b):ff,ff,ff,ff,ff,05,00,00
"Status"=dword:00000000

```