Project Path: arc_fcancelog_EftStreamedCheat_8fzv61gl

Source Tree:

```txt
arc_fcancelog_EftStreamedCheat_8fzv61gl
├── EFTViloresiSockClient
│   ├── EFT-Viloresi
│   │   ├── ConstantsAndOffsets.h
│   │   ├── D2DOverlay.lib
│   │   ├── DirectOverlay.h
│   │   ├── EFT-Viloresi.vcxproj
│   │   ├── EFT-Viloresi.vcxproj.filters
│   │   ├── EFT-Viloresi.vcxproj.user
│   │   ├── EFTData.h
│   │   ├── EFTSockClient.h
│   │   ├── GameVariables.h
│   │   ├── MemOperations.h
│   │   ├── main.cpp
│   │   ├── math.cpp
│   │   ├── math.hpp
│   │   ├── utils.h
│   │   └── visuals.h
│   └── EFTViloresiSockClient.sln
├── EFTViloresiSockServer
│   ├── EFT-Viloresi
│   │   ├── ConstantsAndOffsets.h
│   │   ├── D2DOverlay.lib
│   │   ├── EFT-Viloresi.vcxproj
│   │   ├── EFT-Viloresi.vcxproj.filters
│   │   ├── EFT-Viloresi.vcxproj.user
│   │   ├── EFTData.h
│   │   ├── EFTSockServer.h
│   │   ├── GameVariables.h
│   │   ├── MemOperations.h
│   │   ├── main.cpp
│   │   ├── math.cpp
│   │   ├── math.hpp
│   │   └── utils.h
│   └── EFT-ViloresiSockServer.sln
├── EftDriver
│   ├── Driver
│   │   ├── ARM
│   │   │   └── Release
│   │   │       └── Driver.log
│   │   ├── ARM64
│   │   │   └── Release
│   │   │       └── Driver.log
│   │   ├── Driver.c
│   │   ├── Driver.vcxproj
│   │   ├── Driver.vcxproj.filters
│   │   ├── Driver.vcxproj.user
│   │   ├── Release
│   │   │   └── Driver.log
│   │   ├── imports.h
│   │   ├── ntos.h
│   │   └── x64
│   │       └── Release
│   │           ├── Driver.Build.CppClean.log
│   │           ├── Driver.log
│   │           ├── Driver.obj
│   │           ├── EftDriver.Build.CppClean.log
│   │           ├── EftDriver.iobj
│   │           ├── EftDriver.ipdb
│   │           ├── EftDriver.sys.recipe
│   │           └── EftDriver.tlog
│   │               ├── CL.command.1.tlog
│   │               ├── CL.read.1.tlog
│   │               ├── CL.write.1.tlog
│   │               ├── EftDriver.lastbuildstate
│   │               ├── link.command.1.tlog
│   │               ├── link.read.1.tlog
│   │               └── link.write.1.tlog
│   └── EftDriver.sln
├── LICENSE
└── README.md

```

`EFTViloresiSockClient/EFT-Viloresi/ConstantsAndOffsets.h`:

```h
#pragma once
//#define SERVER_IP "192.168.1.6" // PC GIACOMO
#define SERVER_IP "192.168.1.9" // PC GIORGIO
//#define DEFAULT_PORT "27015" // PORTA GIACOMO
#define DEFAULT_PORT "27016" // PORTA GIORGIO

//#define SERVER_IP "192.168.37.129"

// communication constants
#define PLAYERS_LIST_AND_MATRIX_REQUEST 0x02
#define ITEMS_REQUEST 0x03
#define PLAYERS_MATRIX_PACKET_SIZE 28800 // 28 KB is the size of about 100 player structs 
#define ITEMS_PACKET_SIZE 106000
#define MAX_PLAYERS_SAVED 100
#define TOTAL_SAVED_BONES 22

#define GAME_OBJECT_MANAGER_OFF 0x17F8D28
#define PLAYERCOUNT_OFF	0x18

#define headPosN 0
#define neckPosN 1
#define RupperarmPosN 2
#define LupperarmPosN 3
#define Rforearm1PosN 4
#define Lforearm1PosN 5
#define Rforearm2PosN 6
#define Lforearm2PosN 7
#define Rforearm3PosN 8
#define Lforearm3PosN 9
#define pelvisPosN 10
#define LCalfN 11
#define RCalfN 12
#define LfootN 13
#define RfootN 14
#define RPalmPosN 15
#define LPalmPosN 16
#define Spine1PosN 17
#define Spine2PosN 18
#define Spine3PosN 19
#define IS_LOCAL_PLAYER 20
#define IS_PLAYER 21

#define TOTAL_SAVED_ITEMIDS 30

wchar_t itemIds[TOTAL_SAVED_ITEMIDS][25] = {
		L"59faff1d86f7746c51718c9c",
		L"5c0530ee86f774697952d952",
		L"5c12613b86f7743bbe2c3f76",
		L"5c052e6986f7746b207bc3c9",
		L"5c1267ee86f77416ec610f72",
		L"5c05308086f7746b2101e90b",
		L"5af0534a86f7743b6f354284",
		L"5c12620d86f7743f8b198b72",
		L"5c05300686f7746dce784e5d",
		L"5c0126f40db834002a125382",
		L"5d1b2f3f86f774252167a52c",
		L"5d0378d486f77420421a5ff4",
		L"5c052f6886f7746b1e3db148",
		L"5d0376a486f7747d8050965c",
		L"5d03775b86f774203e7e0c4b",
		L"5d03794386f77420415576f5",
		L"59e3639286f7741777737013",
		L"5c1d0c5f86f7744bb2683cf0",
		L"5c94bbff86f7747ee735c08f",
		L"5c1d0efb86f7744baf2e7b7b",
		L"5c1e495a86f7743109743dfb",
		L"5c1d0d6d86f7744bb2683e1f",
		L"5c1d0f4986f7744bb01837fa",
		L"5c1d0dc586f7744baf2e7b79",
		L"5780cf7f2459777de4559322",
		L"5d1b36a186f7742523398433",
		L"590c60fc86f77412b13fddcf",
		L"59fb023c86f7746d0d4b423c",
		L"59fb042886f7746c5005a7b2",
		L"590a3efd86f77437d351a25b"
};
string itemRealName[TOTAL_SAVED_ITEMIDS] = {
	"Bitcoin",
	"LEDX",
	"Intelligence folder",
	"Portable Defibrillator",
	"Prokill medallion",
	"Virtex processor",
	"Ophthalmoscope",
	"Tetriz",
	"VPX Flash Storage",
	"R. R. Ice Pick",
	"FP-100 filter absorber",
	"Military power filter",
	"Military COFDM",
	"Military circuit board",
	"Phased array element",
	"military battery",
	"Bronze lion",
	"Terragroup LabKey BLUE",
	"Terragroup LabKey Access",
	"Terragroup LabKey RED",
	"Terragroup LabKey VIOLET",
	"Terragroup LabKey YELLOW",
	"Terragroup LabKey BLACK",
	"Terragroup LabKey GREEN",
	"Dorm Room 314 MARKED KEY",
	"Metal Fuel Tank",
	"Documents Case",
	"Weapon Case",
	"Item Case",
	"Gas Analyzer"
};
```

`EFTViloresiSockClient/EFT-Viloresi/DirectOverlay.h`:

```h
/*
	Direct2D Overlay by Coltonon
	Simple library used to make a Direct2d overlay over any application quickly.
	Simply set up your drawing loop, and initialize the overlay.

	Sample use:

-----------------------------------------------------------------------------------------
	#include "DirectOverlay.h"

	void drawLoop(int width, int height) {  // our loop to render in
		DrawString("The quick brown fox jumped over the lazy dog", 48, 100, 20, 0, 1, 1);
	}

	int main(){
		DirectOverlaySetOption(D2DOV_DRAW_FPS | D2DOV_FONT_IMPACT);	// set the font, and draw the fps
		DirectOverlaySetup(drawLoop);		// initialize our overlay
		getchar();	// The overlay operates in it's own thread, ours will continue as normal
	}
-----------------------------------------------------------------------------------------

	The #defines are settings for the window, pass them to the DirectOverlaySetOption function.
	You may OR them together '|', you must set them before calling DirectOverlaySetup.

*/
#pragma once
#include <Windows.h>
#include <string>

// Link the static library (make sure that file is in the same directory as this file)
#pragma comment(lib, "D2DOverlay.lib")

// Requires the targetted window to be active and the foreground window to draw.
#define D2DOV_REQUIRE_FOREGROUND	(1 << 0)

// Draws the FPS of the overlay in the top-right corner
#define D2DOV_DRAW_FPS				(1 << 1)

// Attempts to limit the frametimes so you don't render at 500fps
#define D2DOV_VSYNC					(1 << 2)

// Sets the text font to Calibri
#define D2DOV_FONT_CALIBRI			(1 << 3)

// Sets the text font to Arial
#define D2DOV_FONT_ARIAL			(1 << 4)

// Sets the text font to Courier
#define D2DOV_FONT_COURIER			(1 << 5)

// Sets the text font to Gabriola
#define D2DOV_FONT_GABRIOLA			(1 << 6)

// Sets the text font to Impact
#define D2DOV_FONT_IMPACT			(1 << 7)

// The function you call to set up the above options.  Make sure its called before the DirectOverlaySetup function
void DirectOverlaySetOption(DWORD option);

// typedef for the callback function, where you'll do the drawing.
typedef void(*DirectOverlayCallback)(int width, int height);

// Initializes a the overlay window, and the thread to run it.  Input your callback function.
// Uses the first window in the current process to target.  If you're external, use the next function
void DirectOverlaySetup(DirectOverlayCallback callbackFunction);

// Used to specify the window manually, to be used with externals.
void DirectOverlaySetup(DirectOverlayCallback callbackFunction, HWND targetWindow);

// Draws a line from (x1, y1) to (x2, y2), with a specified thickness.
// Specify the color, and optionally an alpha for the line.
void DrawLine(float x1, float y1, float x2, float y2, float thickness, float r, float g, float b, float a = 1);

// Draws a rectangle on the screen.  Width and height are relative to the coordinates of the box.  
// Use the "filled" bool to make it a solid rectangle; ignore the thickness.
// To just draw the border around the rectangle, specify a thickness and pass "filled" as false.
void DrawBox(float x, float y, float width, float height, float thickness, float r, float g, float b, float a, bool filled);

// Draws a circle.  As with the DrawBox, the "filled" bool will make it a solid circle, and thickness is only used when filled=false.
void DrawCircle(float x, float y, float radius, float thickness, float r, float g, float b, float a, bool filled);

// Allows you to draw an elipse.  Same as a circle, except you have two different radii, for width and height.
void DrawEllipse(float x, float y, float width, float height, float thickness, float r, float g, float b, float a, bool filled);

// Draw a string on the screen.  Input is in the form of an std::string.
void DrawString(std::string str, float fontSize, float x, float y, float r, float g, float b, float a = 1);
```

`EFTViloresiSockClient/EFT-Viloresi/EFT-Viloresi.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{4e76ea4e-885f-46f3-b5aa-617f51565d65}</ProjectGuid>
    <RootNamespace>EFTViloresi</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>imxyviEftStreamedCLIENT</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <LibraryPath>C:\Program Files %28x86%29\Microsoft DirectX SDK %28June 2010%29\Lib\x64;$(SourceDir)Libs;$(LibraryPath)</LibraryPath>
    <IncludePath>C:\Program Files %28x86%29\Microsoft DirectX SDK %28June 2010%29\Include;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>HighestAvailable</UACExecutionLevel>
      <AdditionalDependencies>d3d9.lib;d3dx9.lib;dwmapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
    <ClCompile Include="math.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="DirectOverlay.h" />
    <ClInclude Include="EFTData.h" />
    <ClInclude Include="ConstantsAndOffsets.h" />
    <ClInclude Include="EFTSockClient.h" />
    <ClInclude Include="GameVariables.h" />
    <ClInclude Include="math.hpp" />
    <ClInclude Include="MemOperations.h" />
    <ClInclude Include="utils.h" />
    <ClInclude Include="visuals.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`EFTViloresiSockClient/EFT-Viloresi/EFT-Viloresi.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="File di origine">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="File di intestazione">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="File di risorse">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>File di origine</Filter>
    </ClCompile>
    <ClCompile Include="math.cpp">
      <Filter>File di origine</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="DirectOverlay.h">
      <Filter>File di intestazione</Filter>
    </ClInclude>
    <ClInclude Include="MemOperations.h">
      <Filter>File di intestazione</Filter>
    </ClInclude>
    <ClInclude Include="utils.h">
      <Filter>File di intestazione</Filter>
    </ClInclude>
    <ClInclude Include="ConstantsAndOffsets.h">
      <Filter>File di intestazione</Filter>
    </ClInclude>
    <ClInclude Include="GameVariables.h">
      <Filter>File di intestazione</Filter>
    </ClInclude>
    <ClInclude Include="EFTData.h">
      <Filter>File di intestazione</Filter>
    </ClInclude>
    <ClInclude Include="math.hpp">
      <Filter>File di intestazione</Filter>
    </ClInclude>
    <ClInclude Include="visuals.h">
      <Filter>File di intestazione</Filter>
    </ClInclude>
    <ClInclude Include="EFTSockClient.h">
      <Filter>File di intestazione</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`EFTViloresiSockClient/EFT-Viloresi/EFT-Viloresi.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`EFTViloresiSockClient/EFT-Viloresi/EFTData.h`:

```h
#pragma once
#include "GameVariables.h"
#include <xmmintrin.h>  
#include <emmintrin.h>
#include <d3dx9.h>
using namespace std;

namespace EFTStructs
{
	struct BaseObject
	{
		uint64_t previousObjectLink; //0x0000
		uint64_t nextObjectLink; //0x0008
		uint64_t object; //0x0010
	};

	struct GameObjectManager {
		uint64_t lastTaggedNode; // 0x0
		uint64_t taggedNodes; // 0x8
		uint64_t lastMainCameraTaggedNode; // 0x10
		uint64_t mainCameraTaggedNodes; // 0x18
		uint64_t lastActiveNode; // 0x20
		uint64_t activeNodes; // 0x28
	};
	class ListInternal
	{
	public:
		char pad_0x0000[0x20]; //0x0000
		uintptr_t* firstEntry; //0x0020 
	}; //Size=0x0028

	class List
	{
	public:
		char pad_0x0000[0x10]; //0x0000
		ListInternal* listBase; //0x0010 
		__int32 itemCount; //0x0018 
	}; //Size=0x001C
}
class EFTData
{
private:
	uint64_t matrix_list_base = 0;
	uint64_t dependency_index_table_base = 0;
public:
	EFT_Offsets offsets;
	uint64_t Unity_Player_DllBase = 0;
	int          playercount;
	EFTPlayer localPlayer;
	std::vector<EFTPlayer> players;
	D3DXMATRIX viewMatrix;

	uint64_t getbone_matrix(uint64_t instance)
	{
		static std::vector<uint64_t> temp{ offsets.Player.playerBody, 0x28, 0x28, 0x10 };

		return ReadChain(instance, temp);
	}
	uint64_t GetObjectFromList(uint64_t listPtr, uint64_t lastObjectPtr, const char* objectName)
	{
		using EFTStructs::BaseObject;
		char name[256];
		uint64_t classNamePtr = 0x0;
		uint32_t BaseObjectSize = sizeof(uint64_t) * 3;
		BaseObject activeObject, lastObject;
		readmem(listPtr, &activeObject, BaseObjectSize);
		readmem(lastObjectPtr, &lastObject, BaseObjectSize);

		if (activeObject.object != 0x0)
		{
			readmem(activeObject.nextObjectLink, &activeObject, BaseObjectSize);
			while (activeObject.object != 0 && activeObject.object != lastObject.object)
			{

				readmem(activeObject.object + 0x60, &(classNamePtr), sizeof(uint64_t));
				readmem(classNamePtr + 0x0, &name, sizeof(name));

				if (strcmp(name, objectName) == 0)
				{
					return activeObject.object;
				}
				readmem(activeObject.nextObjectLink, &activeObject, BaseObjectSize);
			}
		}
		if (lastObject.object != 0x0)
		{
			readmem(lastObject.object + 0x60, &classNamePtr, sizeof(uint64_t));
			readmem(classNamePtr + 0x0, &name, 256);

			if (strcmp(name, objectName) == 0)
			{
				return lastObject.object;
			}
		}

		return uint64_t();
	}
	FVector GetPosition(uint64_t transform)
	{
		uint64_t transform_internal = 0, matrices = 0;
		int index = 0;

		readmem(transform + 0x10, &transform_internal, sizeof(uint64_t));
		readmem(transform_internal + 0x38, &matrices, sizeof(uint64_t));
		readmem(transform_internal + 0x40, &index, sizeof(int));

		readmem(matrices + 0x18, &matrix_list_base, sizeof(matrix_list_base));

		readmem((matrices + 0x20), &dependency_index_table_base, sizeof(dependency_index_table_base));

		static auto get_dependency_index = [this](uint64_t base, int32_t index)
		{
			readmem((base + index * 4), &index, sizeof(index));
			return index;
		};

		static auto get_matrix_blob = [this](uint64_t base, uint64_t offs, float* blob, uint32_t size) {
			readmem((base + offs), blob, size);
		};

		int32_t index_relation = get_dependency_index(dependency_index_table_base, index);

		FVector ret_value;
		{
			float* base_matrix3x4 = (float*)malloc(64),
				* matrix3x4_buffer0 = (float*)((uint64_t)base_matrix3x4 + 16),
				* matrix3x4_buffer1 = (float*)((uint64_t)base_matrix3x4 + 32),
				* matrix3x4_buffer2 = (float*)((uint64_t)base_matrix3x4 + 48);

			get_matrix_blob(matrix_list_base, index * 48, base_matrix3x4, 16);

			__m128 xmmword_1410D1340 = { -2.f, 2.f, -2.f, 0.f };
			__m128 xmmword_1410D1350 = { 2.f, -2.f, -2.f, 0.f };
			__m128 xmmword_1410D1360 = { -2.f, -2.f, 2.f, 0.f };

			while (index_relation >= 0)
			{
				uint32_t matrix_relation_index = 6 * index_relation;

				// paziuret kur tik 3 nureadina, ten translationas, kur 4 = quatas ir yra rotationas.
				get_matrix_blob(matrix_list_base, 8 * matrix_relation_index, matrix3x4_buffer2, 16);
				__m128 v_0 = *(__m128*)matrix3x4_buffer2;

				get_matrix_blob(matrix_list_base, 8 * matrix_relation_index + 32, matrix3x4_buffer0, 16);
				__m128 v_1 = *(__m128*)matrix3x4_buffer0;

				get_matrix_blob(matrix_list_base, 8 * matrix_relation_index + 16, matrix3x4_buffer1, 16);
				__m128i v9 = *(__m128i*)matrix3x4_buffer1;

				__m128* v3 = (__m128*)base_matrix3x4; // r10@1
				__m128 v10; // xmm9@2
				__m128 v11; // xmm3@2
				__m128 v12; // xmm8@2
				__m128 v13; // xmm4@2
				__m128 v14; // xmm2@2
				__m128 v15; // xmm5@2
				__m128 v16; // xmm6@2
				__m128 v17; // xmm7@2

				v10 = _mm_mul_ps(v_1, *v3);
				v11 = _mm_castsi128_ps(_mm_shuffle_epi32(v9, 0));
				v12 = _mm_castsi128_ps(_mm_shuffle_epi32(v9, 85));
				v13 = _mm_castsi128_ps(_mm_shuffle_epi32(v9, -114));
				v14 = _mm_castsi128_ps(_mm_shuffle_epi32(v9, -37));
				v15 = _mm_castsi128_ps(_mm_shuffle_epi32(v9, -86));
				v16 = _mm_castsi128_ps(_mm_shuffle_epi32(v9, 113));

				v17 = _mm_add_ps(
					_mm_add_ps(
						_mm_add_ps(
							_mm_mul_ps(
								_mm_sub_ps(
									_mm_mul_ps(_mm_mul_ps(v11, (__m128)xmmword_1410D1350), v13),
									_mm_mul_ps(_mm_mul_ps(v12, (__m128)xmmword_1410D1360), v14)),
								_mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(v10), -86))),
							_mm_mul_ps(
								_mm_sub_ps(
									_mm_mul_ps(_mm_mul_ps(v15, (__m128)xmmword_1410D1360), v14),
									_mm_mul_ps(_mm_mul_ps(v11, (__m128)xmmword_1410D1340), v16)),
								_mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(v10), 85)))),
						_mm_add_ps(
							_mm_mul_ps(
								_mm_sub_ps(
									_mm_mul_ps(_mm_mul_ps(v12, (__m128)xmmword_1410D1340), v16),
									_mm_mul_ps(_mm_mul_ps(v15, (__m128)xmmword_1410D1350), v13)),
								_mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(v10), 0))),
							v10)),
					v_0);

				*v3 = v17;

				index_relation = get_dependency_index(dependency_index_table_base, index_relation);
			}

			ret_value = *(FVector*)base_matrix3x4;
			delete[] base_matrix3x4;
		}

		return ret_value;
	}
	bool InitOffsets()
	{

		//SockGetUnityPlayerRequest((uint64_t*)&Unity_Player_DllBase);
		//GetUnityPlayer(hDriver, GAME_PROCESS_ID, (uint64_t)&Unity_Player_DllBase);
		if (!Unity_Player_DllBase)
			return false;
		cout << "reading gameobject manager: ";
		cout << hex << Unity_Player_DllBase + GAME_OBJECT_MANAGER_OFF << endl;
		readmem(Unity_Player_DllBase + GAME_OBJECT_MANAGER_OFF, &(offsets.gameObjectManager), sizeof(DWORD64));
		
		if (!offsets.gameObjectManager)
		{ 
			cout << "objectmanager fail";
			return false;
		}
		uint64_t LastActiveNode = 0, ActiveNodes = 0;
		uint64_t LastMainCameraTaggedNode = 0, MainCameraTaggedNodes = 0;
		uint64_t LastTaggedNode = 0, TaggedNodes = 0;

		readmem(offsets.gameObjectManager + offsetof(EFTStructs::GameObjectManager, lastActiveNode), &LastActiveNode, sizeof(uint64_t));
		readmem(offsets.gameObjectManager + offsetof(EFTStructs::GameObjectManager, activeNodes), &ActiveNodes, sizeof(uint64_t));

		readmem(offsets.gameObjectManager + offsetof(EFTStructs::GameObjectManager, lastMainCameraTaggedNode), &LastMainCameraTaggedNode, sizeof(uint64_t));
		readmem(offsets.gameObjectManager + offsetof(EFTStructs::GameObjectManager, mainCameraTaggedNodes), &MainCameraTaggedNodes, sizeof(uint64_t));

		//readmem(offsets.gameObjectManager + offsetof(EFTStructs::GameObjectManager, lastTaggedNode), &LastTaggedNode, sizeof(uint64_t));
		//readmem(offsets.gameObjectManager + offsetof(EFTStructs::GameObjectManager, taggedNodes), &TaggedNodes, sizeof(uint64_t));

		if (!LastActiveNode || !ActiveNodes || !LastMainCameraTaggedNode || !MainCameraTaggedNodes)
			return false;
		if (!(offsets.gameWorld = GetObjectFromList(ActiveNodes, LastActiveNode, "GameWorld")))
			return false;
		if (!(offsets.fpsCamera = GetObjectFromList(MainCameraTaggedNodes, LastMainCameraTaggedNode, "FPS Camera")))
			return false;
		if (!(offsets.localGameWorld = ReadChain(offsets.gameWorld, { 0x30, 0x18, 0x28 })))
			return false;

		//const auto cameracom = ReadChain(offsets.fpsCamera, { 0x30, 0x18 });

		//G::MATRIX = Mem::read<geo::mat4x4_t>(cameracom + 0xDC);

		return true;
	}
	bool ReadLoop()
	{
		players.clear();
		if (!(offsets.localGameWorld = ReadChain(offsets.gameWorld, { 0x30, 0x18, 0x28 })))
			return false;
		uint64_t onlineusers = 0, list_base = 0;
		int player_count = 0;
		readmem(offsets.localGameWorld + 0x80, &onlineusers, sizeof(uint64_t));
		if (!onlineusers)
			return false;
		readmem(onlineusers + offsetof(EFTStructs::List, listBase), &list_base, sizeof(uint64_t));
		readmem(onlineusers + 0x18, &player_count, sizeof(int)); //  + 0x18
		if (player_count <= 0 || !list_base)
			return false;

		constexpr auto BUFFER_SIZE = 128;

		uint64_t player_buffer[BUFFER_SIZE];
		readmem(list_base + offsetof(EFTStructs::ListInternal, firstEntry), player_buffer, sizeof(uint64_t) * player_count);
		if (!player_buffer)
			return false;
		EFTPlayer player;

		for (int i = 0; i < player_count; i++)
		{
			player.instance = player_buffer[i];
			playercount = player_count;


			uint64_t bone_matrix = getbone_matrix(player.instance);

			if (bone_matrix)
			{
				uint64_t bone = ReadChain(bone_matrix, { 0x20, 0x10, 0x38 });
				if (!bone)
					return false;
				readmem(bone + 0x90, &(player.location), sizeof(FVector));
				uint64_t boneheadpos = 0, boneneckpos = 0, boneRupperarmpos = 0, boneLupperarmpos = 0, boneRforearm1pos = 0, boneLforearm1pos = 0, bonepelvispos = 0, boneLCalfpos = 0, boneRCalfpos = 0, boneLFootpos = 0, boneRFootpos = 0, boneLforearm2pos = 0, boneRforearm2pos = 0, boneLforearm3pos = 0, boneRforearm3pos = 0;
				uint64_t boneRPalmpos = 0, boneLPalmpos = 0, boneSpine1pos = 0, boneSpine2pos = 0, boneSpine3pos = 0;
				readmem(bone_matrix + 0x20 + (int)Bones::HumanHead * 8, &boneheadpos, sizeof(uint64_t));
				readmem(bone_matrix + 0x20 + (int)Bones::HumanNeck * 8, &boneneckpos, sizeof(uint64_t));
				readmem(bone_matrix + 0x20 + (int)Bones::HumanRUpperarm * 8, &boneRupperarmpos, sizeof(uint64_t));
				readmem(bone_matrix + 0x20 + (int)Bones::HumanLUpperarm * 8, &boneLupperarmpos, sizeof(uint64_t));
				readmem(bone_matrix + 0x20 + (int)Bones::HumanRForearm1 * 8, &boneRforearm1pos, sizeof(uint64_t));
				readmem(bone_matrix + 0x20 + (int)Bones::HumanLForearm1 * 8, &boneLforearm1pos, sizeof(uint64_t));
				readmem(bone_matrix + 0x20 + (int)Bones::HumanLForearm2 * 8, &boneLforearm2pos, sizeof(uint64_t));
				readmem(bone_matrix + 0x20 + (int)Bones::HumanRForearm2 * 8, &boneRforearm2pos, sizeof(uint64_t));
				readmem(bone_matrix + 0x20 + (int)Bones::HumanLForearm3 * 8, &boneLforearm3pos, sizeof(uint64_t));
				readmem(bone_matrix + 0x20 + (int)Bones::HumanRForearm3 * 8, &boneRforearm3pos, sizeof(uint64_t));
				readmem(bone_matrix + 0x20 + (int)Bones::HumanRPalm * 8, &boneRPalmpos, sizeof(uint64_t));
				readmem(bone_matrix + 0x20 + (int)Bones::HumanLPalm * 8, &boneLPalmpos, sizeof(uint64_t));
				readmem(bone_matrix + 0x20 + (int)Bones::HumanSpine1 * 8, &boneSpine1pos, sizeof(uint64_t));
				readmem(bone_matrix + 0x20 + (int)Bones::HumanSpine2 * 8, &boneSpine2pos, sizeof(uint64_t));
				readmem(bone_matrix + 0x20 + (int)Bones::HumanSpine3 * 8, &boneSpine3pos, sizeof(uint64_t));
				
				readmem(bone_matrix + 0x20 + (int)Bones::HumanPelvis * 8, &bonepelvispos, sizeof(uint64_t));
				readmem(bone_matrix + 0x20 + (int)Bones::HumanLCalf * 8, &boneLCalfpos, sizeof(uint64_t));
				readmem(bone_matrix + 0x20 + (int)Bones::HumanRCalf * 8, &boneRCalfpos, sizeof(uint64_t));
				readmem(bone_matrix + 0x20 + (int)Bones::HumanLFoot * 8, &boneLFootpos, sizeof(uint64_t));
				readmem(bone_matrix + 0x20 + (int)Bones::HumanRFoot * 8, &boneRFootpos, sizeof(uint64_t)); 
				

				player.headPos = GetPosition(boneheadpos);
				player.neckPos = GetPosition(boneneckpos);
				player.RupperarmPos = GetPosition(boneRupperarmpos);
				player.LupperarmPos = GetPosition(boneLupperarmpos);
				player.Rforearm1Pos = GetPosition(boneRforearm1pos);
				player.Lforearm1Pos = GetPosition(boneLforearm1pos);
				player.Rforearm2Pos = GetPosition(boneRforearm2pos);
				player.Lforearm2Pos = GetPosition(boneLforearm2pos);
				player.Rforearm3Pos = GetPosition(boneRforearm3pos);
				player.Lforearm3Pos = GetPosition(boneLforearm3pos);
				player.pelvisPos = GetPosition(bonepelvispos);
				player.LCalf = GetPosition(boneLCalfpos);
				player.RCalf = GetPosition(boneRCalfpos);
				player.Lfoot = GetPosition(boneLFootpos);
				player.Rfoot = GetPosition(boneRFootpos);
				player.RPalmPos = GetPosition(boneRPalmpos);
				player.LPalmPos = GetPosition(boneLPalmpos);
				player.Spine1Pos = GetPosition(boneSpine1pos);
				player.Spine2Pos = GetPosition(boneSpine2pos);
				player.Spine3Pos = GetPosition(boneSpine3pos);
			}
			else 
				return false;
			 
			int boolplayer = 0;
			
			uint64_t PlayerInfo = ReadChain(player.instance, { 0x4B8, 0x28 });
			if (PlayerInfo)
			{
				readmem(PlayerInfo + 0x5C, &player.RegistrationDate, sizeof(uint32_t));
				//player.WildSpawnType = ReadChain(PlayerInfo, { 0x38,0x10 });
			}
			else
				return false;
			readmem(player.instance + 0x18, &boolplayer, sizeof(int));
			if (boolplayer)
			{
				localPlayer = player;
				localPlayer.location = player.location;
			}

			players.emplace_back(player);

		}
		//VieMatrix
		uint64_t temp = offsets.fpsCamera;
		readmem(temp + 0x30, &temp, sizeof(uint64_t));
		if (!temp)
			return false;
		readmem(temp + 0x18, &temp, sizeof(uint64_t));
		if (!temp)
			return false;

		D3DXMATRIX temp_matrix;
		readmem(temp + 0xDC, &temp_matrix, sizeof(temp_matrix));
		D3DXMatrixTranspose(&viewMatrix, &temp_matrix);
		return true;
	}

};

```

`EFTViloresiSockClient/EFT-Viloresi/EFTSockClient.h`:

```h
#pragma once
// Need to link with Ws2_32.lib, Mswsock.lib, and Advapi32.lib

#pragma comment (lib, "Ws2_32.lib")
#pragma comment (lib, "Mswsock.lib")
#pragma comment (lib, "AdvApi32.lib")

#define DEFAULT_BUFLEN 512


WSADATA wsaData;
SOCKET ConnectSocket = INVALID_SOCKET;
struct addrinfo* result = NULL,
    * ptr = NULL,
    hints;
const char* sendbuf = "this is a test";
char recvbuf[DEFAULT_BUFLEN];
int iResult;
int recvbuflen = DEFAULT_BUFLEN;

D3DXMATRIX temp_matrix, viewMatrix;

uint32_t savedplayersnum,saveditemsnum;

int InitSockClient()
{
    // Initialize Winsock
    iResult = WSAStartup(MAKEWORD(2, 2), &wsaData);
    if (iResult != 0) {
        printf("WSAStartup failed with error: %d\n", iResult);
        return 0;
    }

    ZeroMemory(&hints, sizeof(hints));
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_protocol = IPPROTO_TCP;

    // Resolve the server address and port
    iResult = getaddrinfo(SERVER_IP, DEFAULT_PORT, &hints, &result);
    if (iResult != 0) {
        printf("getaddrinfo failed with error: %d\n", iResult);
        WSACleanup();
        return 0;
    }

    // Attempt to connect to an address until one succeeds
    for (ptr = result; ptr != NULL; ptr = ptr->ai_next) {

        // Create a SOCKET for connecting to server
        ConnectSocket = socket(ptr->ai_family, ptr->ai_socktype,
            ptr->ai_protocol);
        if (ConnectSocket == INVALID_SOCKET) {
            printf("socket failed with error: %ld\n", WSAGetLastError());
            WSACleanup();
            return 0;
        }

        // Connect to server.
        iResult = connect(ConnectSocket, ptr->ai_addr, (int)ptr->ai_addrlen);
        if (iResult == SOCKET_ERROR) {
            closesocket(ConnectSocket);
            ConnectSocket = INVALID_SOCKET;
            continue;
        }
        break;
    }

    freeaddrinfo(result);

    if (ConnectSocket == INVALID_SOCKET) {
        printf("Unable to connect to server!\n");
        WSACleanup();
        return 0;
    }


    return 1;
}
int SockRequest(uint64_t addresstoread, uint64_t* addresstowrite, uint32_t size)
{
	char sendbuffer[DEFAULT_BUFLEN];
	char receivebuffer[DEFAULT_BUFLEN];
    sendbuffer[0] = 0x1; // 0x1 is the readrequest
	memcpy(&(sendbuffer[1]), &addresstoread, sizeof(uint64_t)); //copy address at the start of the buffer + 0x1 (the first byte indicates the operation to do)
	memcpy(&(sendbuffer[sizeof(uint64_t) + 0x1]), &size, sizeof(uint32_t)); // copy the size to read after the address
    iResult = send(ConnectSocket, sendbuffer, 0x1 + sizeof(uint64_t) + sizeof(uint32_t), 0);

	if (iResult == SOCKET_ERROR)
		return 0;

	iResult = recv(ConnectSocket, receivebuffer, DEFAULT_BUFLEN, 0);
	if (iResult != size)
	{
		cerr << "error: received size does not match! \n";
		return 0;
	}

	if (iResult > 0)
	{
		memcpy(addresstowrite, receivebuffer, size);
	}
	else if (iResult == 0)
		return 0;//connection closed
	else
		return 0; //whatever error

	return 1;
}
void ReassemblePlayersPacket(char* receivedpacket)
{
    memcpy(&savedplayersnum, receivedpacket, sizeof(int));
    int counter = 1; // gonna skip the first byte because it's the savedplayersnum
    for (int i = 0; i < savedplayersnum; i++)
    {
        for (int k = 0; k < TOTAL_SAVED_BONES; k++)
        {
            for (int j = 0; j < 3; j++,counter++)
            {
                memcpy(playersposarray[i][k] + j * 4, receivedpacket + counter * sizeof(float) , sizeof(float));
            }
        }
    }

    memcpy(&temp_matrix, receivedpacket + counter * sizeof(float), sizeof(D3DXMATRIX));
    D3DXMatrixTranspose(&viewMatrix, &temp_matrix);
}
void ReassembleItemsPacket(char* receivedpacket)
{
    memcpy(&saveditemsnum, receivedpacket, sizeof(int));
    int counter = 1, namesizecounter = 0; // gonna skip the first byte because it's the savedplayersnum
    for (int i = 0; i < saveditemsnum; i++)
    {
            for (int j = 0; j < 3; j++, counter++)
            {
                memcpy(itemCoord[i] + j * 4, receivedpacket + counter * sizeof(float) + namesizecounter * 50, sizeof(float));
            }
            memcpy(itemName[i] , receivedpacket + counter * sizeof(float) + namesizecounter * 50, 50); // 50 bytes is the ItemNameSize
            namesizecounter++;
    }
}
int SockGetPlayersAndMatrix()
{
    char sendbuffer[DEFAULT_BUFLEN];
    char receivebuffer[PLAYERS_MATRIX_PACKET_SIZE];
    sendbuffer[0] = PLAYERS_LIST_AND_MATRIX_REQUEST; // 0x2 is PlayersAndMatrix
    iResult = send(ConnectSocket, sendbuffer, 0x1, 0);

    if (iResult == SOCKET_ERROR)
        return 0;
    iResult = recv(ConnectSocket, receivebuffer, PLAYERS_MATRIX_PACKET_SIZE, 0);
    if (iResult > 0)
    {
        ReassemblePlayersPacket(receivebuffer);
    }
    else if (iResult == 0)
        return 0;//connection closed
    else
        return 0; //whatever error

    return 1;
}
int SockGetItems()
{
    char sendbuffer[DEFAULT_BUFLEN];
    char receivebuffer[ITEMS_PACKET_SIZE];
    sendbuffer[0] = ITEMS_REQUEST; // 0x3 is Items
    iResult = send(ConnectSocket, sendbuffer, 0x1, 0);

    if (iResult == SOCKET_ERROR)
        return 0;
    iResult = recv(ConnectSocket, receivebuffer, ITEMS_PACKET_SIZE, 0);
    if (iResult > 0)
    {
        ReassembleItemsPacket(receivebuffer);
    }
    else if (iResult == 0)
        return 0;//connection closed
    else
        return 0; //whatever error

    return 1;
}
```

`EFTViloresiSockClient/EFT-Viloresi/GameVariables.h`:

```h
#pragma once
#include "math.hpp"
struct EFT_Offsets
{
	uint64_t gameObjectManager = 0x0;
	uint64_t gameWorld = 0x0;
	uint64_t localGameWorld = 0x0;
	uint64_t fpsCamera = 0x0;
	uint64_t OpticCamera = 0x0;
	struct
	{
		static constexpr uint64_t ExfiltrationController = 0x18;//private \uE334 \uE000;
		static constexpr uint64_t LootList = 0x60;//public readonly List<\uE1B5> LootList = new List<\uE1B5>(1000);
		static constexpr uint64_t RegisteredPlayers = 0x80;//public readonly List<Player> RegisteredPlayers = new List<Player>(40);
	} localGameWorld_offsets;

	struct
	{
		static constexpr uint64_t length = 0x10; //good
		static constexpr uint64_t stringBase = 0x14; //good
	} unicodeString;

	struct
	{
		static constexpr uint64_t information = 0x28; //updated
		static constexpr uint64_t id = 0x10; //updated
	} profile;

	struct
	{
		static constexpr uint64_t playerName = 0x10; //updated
	} information;

	struct
	{
		static constexpr uint64_t angles_0 = 0x1D0;
		static constexpr uint64_t angles_1 = 0x1D8;
		static constexpr uint64_t position = 0x1E0;
	} movementContext;

	struct
	{
		static constexpr uint64_t m_pPlayerProfile = 0x03A0;
		static constexpr uint64_t movementContext = 0x38;
		static constexpr uint64_t proceduralWeaponAnimation = 0x70; //updayed 1/11/2020
		static constexpr uint64_t playerBody = 0xa8; 
		static constexpr uint64_t m_pHealthController = 0x3D0; //updated 1/11/2020
		static constexpr uint64_t profile = 0x3A0; //updayed 1/11/2020

	} Player;
};

struct EFTPlayer
{
	uintptr_t	 instance;
	FVector		 headPos;
	FVector		 neckPos;
	FVector		 LupperarmPos;
	FVector		 RupperarmPos;
	FVector		 Lforearm1Pos;
	FVector		 Rforearm1Pos;
	FVector		 Lforearm2Pos;
	FVector		 Rforearm2Pos;
	FVector		 Lforearm3Pos;
	FVector		 Rforearm3Pos;
	FVector		 pelvisPos;
	FVector		 RThigh1Pos;
	FVector		 LThigh1Pos;
	FVector		RPalmPos;
	FVector		LPalmPos;
	FVector		Spine1Pos;
	FVector Spine2Pos;
	FVector Spine3Pos;
	FVector		LCalf;
	FVector		RCalf;
	FVector		Lfoot;
	FVector		Rfoot;
	FVector		 location;
	uint32_t		RegistrationDate;
//	int		WildSpawnType;
};

struct EFTExtract
{
	uintptr_t	 instance;
	std::string  name;
	FVector		 location;
};
enum Bones : int
{
	HumanBase = 0,
	HumanPelvis = 14,
	HumanLThigh1 = 15,
	HumanLThigh2 = 16,
	HumanLCalf = 17,
	HumanLFoot = 18,
	HumanLToe = 19,
	HumanRThigh1 = 20,
	HumanRThigh2 = 21,
	HumanRCalf = 22,
	HumanRFoot = 23,
	HumanRToe = 24,
	HumanSpine1 = 29,
	HumanSpine2 = 36,
	HumanSpine3 = 37,
	HumanLCollarbone = 89,
	HumanLUpperarm = 90,
	HumanLForearm1 = 91,
	HumanLForearm2 = 92,
	HumanLForearm3 = 93,
	HumanLPalm = 94,
	HumanRCollarbone = 110,
	HumanRUpperarm = 111,
	HumanRForearm1 = 112,
	HumanRForearm2 = 113,
	HumanRForearm3 = 114,
	HumanRPalm = 115,
	HumanNeck = 132,
	HumanHead = 133
};

```

`EFTViloresiSockClient/EFT-Viloresi/MemOperations.h`:

```h
#pragma once
#include "ConstantsAndOffsets.h"
#include "utils.h"

void readmem(void* addresstoread, void* buffer, uint32_t size)
{
	if ((uint64_t)addresstoread < 0x10000) //address in non paged area
	{
		buffer = 0;
		return;
	}
	//if (!SockRequest((uint64_t)addresstoread, (uint64_t*)buffer, size))
	//	cerr << "error sockrequestfailed\n";
	//ReadVirtualMemory(hDriver, GAME_PROCESS_ID, (uint64_t)addresstoread, (uint64_t)buffer, size);
}
void readmem(uint64_t addresstoread, void* buffer, uint32_t size)
{
	if (addresstoread < 0x10000) //address in non paged area
	{
		buffer = 0;
		return;
	}
	//if(!SockRequest((uint64_t)addresstoread, (uint64_t*)buffer, size))
	//cerr << "error sockrequestfailed\n";
	//ReadVirtualMemory(hDriver, GAME_PROCESS_ID, (uint64_t)addresstoread, (uint64_t)buffer, size);
}

uint64_t ReadChain(uint64_t base, const std::vector<uint64_t>& offsets) {
	uint64_t result = 0;
	readmem(base + offsets.at(0), &result, sizeof(uint64_t));
	if (!result)
		return 0;
	for (int i = 1; i < offsets.size(); i++) {
		readmem(result + offsets.at(i), &result, sizeof(uint64_t));
		if (!result)
			return 0;
	}
	return result;
}
```

`EFTViloresiSockClient/EFT-Viloresi/main.cpp`:

```cpp
#include <winsock2.h>
#include <ws2tcpip.h>
#include <stdlib.h>
#include <stdio.h>

#include <Windows.h>
#include <iostream>
#include <vector>
#include<cmath>
using namespace std;

#include "ConstantsAndOffsets.h"
#include "DirectOverlay.h"
#include "MemOperations.h"
float playersposarray[MAX_PLAYERS_SAVED][TOTAL_SAVED_BONES][3];
wchar_t itemName[2000][25];
float itemCoord[2000][3] = { 0 };
#include "GameVariables.h"
#include "EFTData.h"
EFTData Data;
#include "EFTSockClient.h"
#include "visuals.h"
#include "utils.h"




int width = 0;
int height = 0;
int ScreenCenterX = 0;
int ScreenCenterY = 0;
int sentplayerrequests = 0;
void ReadLoop()
{
	while (1)
	{


		SockGetPlayersAndMatrix();
		sentplayerrequests++;
		if (sentplayerrequests == 100)
		{
			SockGetItems();
			sentplayerrequests = 0;
		}
	}
}
void drawLoop(int width, int height) {

	Render();
}

int main()
{
	InitSockClient();
	SockGetPlayersAndMatrix();
	SockGetItems();
	DirectOverlaySetOption(D2DOV_DRAW_FPS | D2DOV_FONT_IMPACT);

	HWND windowhwnd = FindWindowA("TESTWINDOW", NULL);

	DirectOverlaySetup(drawLoop, windowhwnd);
	RECT rect;
	if (GetWindowRect(windowhwnd, &rect))
	{
		int width = rect.right - rect.left;
		int height = rect.bottom - rect.top;
	}
	CreateThread(nullptr, 0, (LPTHREAD_START_ROUTINE)ReadLoop, 0, 0, nullptr);

	getchar();
	return 1;
}

bool WorldToScreenv2(float* point3D, D2D1_POINT_2F& point2D)
{

	D3DXVECTOR3 _point3D = D3DXVECTOR3(point3D[0], point3D[1], point3D[2]);

	auto& matrix = viewMatrix;



	D3DXVECTOR3 translationVector = D3DXVECTOR3(matrix._41, matrix._42, matrix._43);
	D3DXVECTOR3 up = D3DXVECTOR3(matrix._21, matrix._22, matrix._23);
	D3DXVECTOR3 right = D3DXVECTOR3(matrix._11, matrix._12, matrix._13);

	float w = D3DXVec3Dot(&translationVector, &_point3D) + matrix._44;

	if (w < 0.098f)
		return false;

	float y = D3DXVec3Dot(&up, &_point3D) + matrix._24;
	float x = D3DXVec3Dot(&right, &_point3D) + matrix._14;
	RECT desktop;
	// Get a handle to the desktop window
	const HWND hDesktop = GetDesktopWindow();
	// Get the size of screen to the variable desktop
	GetWindowRect(hDesktop, &desktop);
	int horizontal = desktop.right;
	int vertical = desktop.bottom;
	point2D.x = (horizontal / 2) * (1.f + x / w);
	point2D.y = (vertical / 2) * (1.f - y / w);
	ScreenCenterX = (horizontal / 2);
	ScreenCenterY = (vertical / 2);
	//point2D.x = (1920 / 2) * (1.f + x / w);
	//point2D.y = (1080 / 2) * (1.f - y / w);
	return true;
}



void Render()
{

	auto& local_player = Data.localPlayer;

	float distance;
	float distance2;
	float MaxDrawDistance = 300.f;
	D3DCOLOR color = 0;
	D2D1_POINT_2F itemCoord2D;

	for (int i = 0; i < savedplayersnum; i++)
	{

		D2D1_POINT_2F screen_pos, head_pos, neck_pos, Lupperarm_pos, Rupperarm_pos, Lforearm1_pos, Rforearm1_pos, Lforearm2_pos, Rforearm2_pos, Lforearm3_pos, Rforearm3_pos, pelvis_pos, LCalf_pos, RCalf_pos, LFoot_pos, RFoot_pos;
		D2D1_POINT_2F RPalm_pos, LPalm_pos, Spine1_pos, Spine2_pos, Spine3_pos;
		int R = 0, G = 0, B = 0;
		if (playersposarray[i][IS_LOCAL_PLAYER][0] == 1)
			continue;
		if (playersposarray[i][IS_PLAYER][0] == 1)
		{
			R = 256;
			G = 0;
			B = 0;
		}
		else
		{
			R = 0;
			G = 256;
			B = 0;
		}

		WorldToScreenv2(playersposarray[i][headPosN], head_pos);
		WorldToScreenv2(playersposarray[i][neckPosN], neck_pos);
		WorldToScreenv2(playersposarray[i][LupperarmPosN], Lupperarm_pos);
		WorldToScreenv2(playersposarray[i][RupperarmPosN], Rupperarm_pos);
		WorldToScreenv2(playersposarray[i][Lforearm1PosN], Lforearm1_pos);
		WorldToScreenv2(playersposarray[i][Rforearm1PosN], Rforearm1_pos);
		WorldToScreenv2(playersposarray[i][Lforearm2PosN], Lforearm2_pos);
		WorldToScreenv2(playersposarray[i][Rforearm2PosN], Rforearm2_pos);
		WorldToScreenv2(playersposarray[i][Lforearm3PosN], Lforearm3_pos);
		WorldToScreenv2(playersposarray[i][Rforearm3PosN], Rforearm3_pos);
		WorldToScreenv2(playersposarray[i][pelvisPosN], pelvis_pos);
		WorldToScreenv2(playersposarray[i][RCalfN], RCalf_pos);
		WorldToScreenv2(playersposarray[i][LCalfN], LCalf_pos);
		WorldToScreenv2(playersposarray[i][RfootN], RFoot_pos);
		WorldToScreenv2(playersposarray[i][LfootN], LFoot_pos);
		WorldToScreenv2(playersposarray[i][RPalmPosN], RPalm_pos);
		WorldToScreenv2(playersposarray[i][LPalmPosN], LPalm_pos);
		WorldToScreenv2(playersposarray[i][Spine1PosN], Spine1_pos);
		WorldToScreenv2(playersposarray[i][Spine2PosN], Spine2_pos);
		WorldToScreenv2(playersposarray[i][Spine3PosN], Spine3_pos);

		float HeadNeckDistance = sqrtf(pow(neck_pos.y - head_pos.y, 2) + pow(neck_pos.x - head_pos.x, 2));
		DrawCircle((int)head_pos.x, (int)head_pos.y, HeadNeckDistance, 2, R, G, B, 255, false);
		DrawLine((int)neck_pos.x, (int)neck_pos.y, Lupperarm_pos.x, Lupperarm_pos.y, 2, R, G, B);
		DrawLine((int)neck_pos.x, (int)neck_pos.y, Rupperarm_pos.x, Rupperarm_pos.y, 2, R, G, B);
		DrawLine((int)Lupperarm_pos.x, (int)Lupperarm_pos.y, Lforearm1_pos.x, Lforearm1_pos.y, 2, R, G, B);
		DrawLine((int)Lforearm1_pos.x, (int)Lforearm1_pos.y, Lforearm2_pos.x, Lforearm2_pos.y, 2, R, G, B);
		DrawLine((int)Lforearm2_pos.x, (int)Lforearm2_pos.y, Lforearm3_pos.x, Lforearm3_pos.y, 2, R, G, B);
		DrawLine((int)Lforearm3_pos.x, (int)Lforearm3_pos.y, LPalm_pos.x, LPalm_pos.y, 2, R, G, B);
		DrawLine((int)Rupperarm_pos.x, (int)Rupperarm_pos.y, Rforearm1_pos.x, Rforearm1_pos.y, 2, R, G, B);
		DrawLine((int)Rforearm1_pos.x, (int)Rforearm1_pos.y, Rforearm2_pos.x, Rforearm2_pos.y, 2, R, G, B);
		DrawLine((int)Rforearm2_pos.x, (int)Rforearm2_pos.y, Rforearm3_pos.x, Rforearm3_pos.y, 2, R, G, B);
		DrawLine((int)Rforearm3_pos.x, (int)Rforearm3_pos.y, RPalm_pos.x, RPalm_pos.y, 2, R, G, B);
		DrawLine((int)neck_pos.x, (int)neck_pos.y, Spine1_pos.x, Spine1_pos.y, 2, R, G, B);
		DrawLine((int)Spine1_pos.x, (int)Spine1_pos.y, Spine2_pos.x, Spine2_pos.y, 2, R, G, B);
		DrawLine((int)Spine2_pos.x, (int)Spine2_pos.y, Spine3_pos.x, Spine3_pos.y, 2, R, G, B);
		DrawLine((int)Spine3_pos.x, (int)Spine3_pos.y, pelvis_pos.x, pelvis_pos.y, 2, R, G, B);
		DrawLine((int)pelvis_pos.x, (int)pelvis_pos.y, RCalf_pos.x, RCalf_pos.y, 2, R, G, B);
		DrawLine((int)pelvis_pos.x, (int)pelvis_pos.y, LCalf_pos.x, LCalf_pos.y, 2, R, G, B);
		DrawLine((int)LCalf_pos.x, (int)LCalf_pos.y, LFoot_pos.x, LFoot_pos.y, 2, R, G, B);
		DrawLine((int)RCalf_pos.x, (int)RCalf_pos.y, RFoot_pos.x, RFoot_pos.y, 2, R, G, B);
	}
	for (int k = 0; k < saveditemsnum; k++)
	{
		for (int w = 0; w < TOTAL_SAVED_ITEMIDS; w++)
		{
			for (int j = 0; itemName[k][j] == itemIds[w][j] && j < 25; j++)
			{
				if (j == 24)
				{
					WorldToScreenv2(itemCoord[k], itemCoord2D);
					DrawString(itemRealName[w], 10.f, itemCoord2D.x, itemCoord2D.y, 0, 255, 0, 255);
				}
			}
		}
	}
}




```

`EFTViloresiSockClient/EFT-Viloresi/math.cpp`:

```cpp
#include "math.hpp"
#include <cmath>
#include <cfloat>

#define M_PI       3.14159265358979323846   // pi

float DegToRad(float x)
{
	return x * ((float)M_PI / 180.f);
}

float RadToDeg(float x)
{
	return x * (180.f / (float)M_PI);
}

float DistancePointToLine(FVector Point, FVector LineOrigin, FVector Dir)
{
	FVector PointDir = Point - LineOrigin;

	float TempOffset = (PointDir * Dir) / Dir.GetMagnitudeSqr(); // Calculates the Offset for: LineOrigin + TempOffset*Dir; - if Dir is already normalized you can skip the dividing
	if (TempOffset < 0.000001f)
		return FLT_MAX;

	FVector PerpendicularPoint = LineOrigin + (Dir * TempOffset);

	return (Point - PerpendicularPoint).GetLength();
}

Vector4::Vector4()
{
	x = 0.0f;
	y = 0.0f;
	z = 0.0f;
	w = 1.0f;
	pointer = false;
}

Vector4::Vector4(float x, float y, float z, float w)
{
	this->x = x; this->y = y; this->z = z; this->w = w;
	pointer = false;
}

Vector4::Vector4(float x, float y, float z)
{
	this->x = x; this->y = y; this->z = z; this->w = 1.0f;
	pointer = false;
}

Vector4::Vector4(float* x, float* y, float* z, float* w)
{
	this->px = x; this->py = y; this->pz = z; this->pw = w;
	this->x = *x; this->y = *y; this->z = *z; this->w = *w;
	pointer = true;
}

Vector4 Vector4::operator= (const Vector4& v)
{
	if (pointer)
	{
		*px = x = v.x;
		*py = y = v.y;
		*pz = z = v.z;
		*pw = w = v.w;
	}
	else
	{
		x = v.x;
		y = v.y;
		z = v.z;
		w = v.w;
	}
}

const Vector4 Vector4::operator* (const float& scalar) const
{
	return Vector4(x * scalar, y * scalar, z * scalar, w * scalar);
}

const Vector4 Vector4::operator+ (const Vector4& v) const
{
	Vector4 vec;
	vec.x = this->x + v.x;
	vec.y = this->y + v.y;
	vec.z = this->z + v.z;
	vec.w = this->w + v.w;
	return vec;
}

float Vector3::Distance(Vector3 v)
{
	return float(sqrtf(powf(v.x - x, 2.0) + powf(v.y - y, 2.0) + powf(v.z - z, 2.0)));
}

Vector3 Vector3::operator+(Vector3 v)
{
	return Vector3(x + v.x, y + v.y, z + v.z);
}

float Vector3::Dot(Vector3 v)
{
	return x * v.x + y * v.y + z * v.z;
}

Vector3 Vector3::operator-(Vector3 v)
{
	return Vector3(x - v.x, y - v.y, z - v.z);
}

FVector::FVector() : x(0.f), y(0.f), z(0.f) {}

FVector::FVector(float x, float y, float z) : x(x), y(y), z(z) {}

FVector::FVector(const FVector& other) : x(other.x), y(other.y), z(other.z) {}

FVector FVector::operator+(const FVector& other) const
{
	return FVector(x + other.x, y + other.y, z + other.z);
}

FVector FVector::operator-(const FVector& other) const
{
	return FVector(x - other.x, y - other.y, z - other.z);
}

FVector FVector::operator*(const float other) const
{
	return FVector(x * other, y * other, z * other);
}

float FVector::operator*(const FVector& other) const
{
	return (x * other.x + y * other.y + z * other.z);
}

bool FVector::operator==(const FVector& other) const
{
	return x == other.x && y == other.y && z == other.z;
}

bool FVector::operator!=(const FVector& other) const
{
	return x != other.x || y != other.y || z != other.z;
}

FVector& FVector::operator=(const FVector& other)
{
	x = other.x;
	y = other.y;
	z = other.z;

	return *this;
}

FVector& FVector::operator+=(const FVector& other)
{
	x += other.x;
	y += other.y;
	z += other.z;

	return *this;
}

FVector& FVector::operator-=(const FVector& other)
{
	x -= other.x;
	y -= other.y;
	z -= other.z;

	return *this;
}

FVector& FVector::operator*=(const float other)
{
	x *= other;
	y *= other;
	z *= other;

	return *this;
}

float& FVector::operator[](size_t i)
{
	return reinterpret_cast<float*>(this)[i];
}

const float& FVector::operator[](size_t i) const
{
	return reinterpret_cast<const float*>(this)[i];
}

float FVector::GetLength() const
{
	return sqrt(x * x + y * y + z * z);
}

float FVector::Distance(FVector v)
{
	return float(sqrtf(powf(v.x - x, 2.0) + powf(v.y - y, 2.0) + powf(v.z - z, 2.0)));
}

float FVector::Distance2(FVector a, FVector b)

{

	float diff_x = a.x - b.x;

	float diff_y = a.y - b.y;

	float diff_z = a.z - b.z;

	return float(sqrtf(diff_x * diff_x + diff_y * diff_y + diff_z * diff_z));

}
float FVector::GetMagnitudeSqr()
{
	return (x * x + y * y + z * z);
}

FRotator FVector::VectorAngles() const
{
	return FRotator(atan2(-x, z), atan2(y, sqrt(x * x + z * z)), 0.f);
}

FRotator::FRotator() : pitch(0.f), yaw(0.f), roll(0.f) {}

FRotator::FRotator(float pitch, float yaw, float roll) : pitch(pitch), yaw(yaw), roll(roll) {}

FRotator::FRotator(const FRotator& other) : pitch(other.pitch), yaw(other.yaw), roll(other.roll) {}

void FRotator::ToSourceAngles()
{
	yaw = -yaw + 90.f;
	Normalize();
}

void FRotator::ToUnityAngles()
{
	ToSourceAngles(); // Toggle behaviour.
}

void FRotator::Normalize()
{
	yaw = remainder(yaw, static_cast<float>(2 * M_PI));
	pitch = remainder(pitch, static_cast<float>(2 * M_PI));
}

FVector FRotator::AngleVector()
{
	float sp, sy, cp, cy;

	sy = sin(yaw / 180.f * (float)M_PI);
	cy = cos(yaw / 180.f * (float)M_PI);

	sp = sin(pitch / 180.f * (float)M_PI);
	cp = cos(pitch / 180.f * (float)M_PI);

	return FVector(cp * cy, cp * sy, -sp);
}

void FRotator::AngleVectors(FVector* x, FVector* y, FVector* z)
{
	float radPitch = (pitch * static_cast<float>(M_PI / 180.f));
	float radYaw = (yaw * static_cast<float>(M_PI / 180.f));
	float radRoll = (roll * static_cast<float>(M_PI / 180.f));

	float SP = sin(radPitch);
	float CP = cos(radPitch);
	float SY = sin(radYaw);
	float CY = cos(radYaw);
	float SR = sin(radRoll);
	float CR = cos(radRoll);


	x->x = CP * CY;
	x->y = CP * SY;
	x->z = SP;

	y->x = SR * SP * CY - CR * SY;
	y->y = SR * SP * SY + CR * CY;
	y->z = -SR * CP;

	z->x = -(CR * SP * CY + SR * SY);
	z->y = CY * SR - CR * SP * SY;
	z->z = CR * CP;
}

FQuat FQuat::operator*(const FQuat& other)
{
	FQuat ret;

	auto& q1 = *this;
	auto& q2 = other;

	ret.x = q1.x * q2.w + q1.y * q2.z - q1.z * q2.y + q1.w * q2.x;
	ret.y = -q1.x * q2.z + q1.y * q2.w + q1.z * q2.x + q1.w * q2.y;
	ret.z = q1.x * q2.y - q1.y * q2.x + q1.z * q2.w + q1.w * q2.z;
	ret.w = -q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w;

	return ret;
}
//
//FMatrix FMatrix::operator*(const FMatrix & other)
//{
//	FMatrix result;
//	for (int i = 0; i < 4; i++)
//	{
//		for (int j = 0; j < 4; j++)
//		{
//			result[i][j] = 0;
//
//			for (int k = 0; k < 4; k++)
//			{
//				result[i][j] += (*this)[i][k] * other[k][j];
//			}
//		}
//	}
//
//	return result;
//}

FVector FMatrix::operator*(const FVector& vec)
{
	/*
	FVector pOut;
	int a[3][3] = { { 2,4,3 },{ 1,5,7 },{ 0,2,3 } };
	int b[] = { 2,5,6 };
	FVector out;

	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			out[i] += (a[i][j] * b[j]);
		}
	}

	return pOut;
	*/


	FMatrix m;

	m[3][0] = vec.x;
	m[3][1] = vec.y;
	m[3][2] = vec.z;

	m[0][0] = 1.f;
	m[1][1] = 1.f;
	m[2][2] = 1.f;


	m[0][3] = 0.0f;
	m[1][3] = 0.0f;
	m[2][3] = 0.0f;
	m[3][3] = 1.0f;

	auto result = m * (*this);

	return FVector(result[3][0], result[3][1], result[3][2]);

}

FMatrix FMatrix::operator*(const FMatrix& pM2)
{
	auto pM1 = *this;

	FMatrix pOut;
	pOut[0][0] = pM1[0][0] * pM2[0][0] + pM1[0][1] * pM2[1][0] + pM1[0][2] * pM2[2][0] + pM1[0][3] * pM2[3][0];
	pOut[0][1] = pM1[0][0] * pM2[0][1] + pM1[0][1] * pM2[1][1] + pM1[0][2] * pM2[2][1] + pM1[0][3] * pM2[3][1];
	pOut[0][2] = pM1[0][0] * pM2[0][2] + pM1[0][1] * pM2[1][2] + pM1[0][2] * pM2[2][2] + pM1[0][3] * pM2[3][2];
	pOut[0][3] = pM1[0][0] * pM2[0][3] + pM1[0][1] * pM2[1][3] + pM1[0][2] * pM2[2][3] + pM1[0][3] * pM2[3][3];
	pOut[1][0] = pM1[1][0] * pM2[0][0] + pM1[1][1] * pM2[1][0] + pM1[1][2] * pM2[2][0] + pM1[1][3] * pM2[3][0];
	pOut[1][1] = pM1[1][0] * pM2[0][1] + pM1[1][1] * pM2[1][1] + pM1[1][2] * pM2[2][1] + pM1[1][3] * pM2[3][1];
	pOut[1][2] = pM1[1][0] * pM2[0][2] + pM1[1][1] * pM2[1][2] + pM1[1][2] * pM2[2][2] + pM1[1][3] * pM2[3][2];
	pOut[1][3] = pM1[1][0] * pM2[0][3] + pM1[1][1] * pM2[1][3] + pM1[1][2] * pM2[2][3] + pM1[1][3] * pM2[3][3];
	pOut[2][0] = pM1[2][0] * pM2[0][0] + pM1[2][1] * pM2[1][0] + pM1[2][2] * pM2[2][0] + pM1[2][3] * pM2[3][0];
	pOut[2][1] = pM1[2][0] * pM2[0][1] + pM1[2][1] * pM2[1][1] + pM1[2][2] * pM2[2][1] + pM1[2][3] * pM2[3][1];
	pOut[2][2] = pM1[2][0] * pM2[0][2] + pM1[2][1] * pM2[1][2] + pM1[2][2] * pM2[2][2] + pM1[2][3] * pM2[3][2];
	pOut[2][3] = pM1[2][0] * pM2[0][3] + pM1[2][1] * pM2[1][3] + pM1[2][2] * pM2[2][3] + pM1[2][3] * pM2[3][3];
	pOut[3][0] = pM1[3][0] * pM2[0][0] + pM1[3][1] * pM2[1][0] + pM1[3][2] * pM2[2][0] + pM1[3][3] * pM2[3][0];
	pOut[3][1] = pM1[3][0] * pM2[0][1] + pM1[3][1] * pM2[1][1] + pM1[3][2] * pM2[2][1] + pM1[3][3] * pM2[3][1];
	pOut[3][2] = pM1[3][0] * pM2[0][2] + pM1[3][1] * pM2[1][2] + pM1[3][2] * pM2[2][2] + pM1[3][3] * pM2[3][2];
	pOut[3][3] = pM1[3][0] * pM2[0][3] + pM1[3][1] * pM2[1][3] + pM1[3][2] * pM2[2][3] + pM1[3][3] * pM2[3][3];

	return pOut;
}



FMatrix FTransform::ToMatrixWithScale()
{
	FMatrix OutMatrix = {};

	OutMatrix[3][0] = Translation.x;
	OutMatrix[3][1] = Translation.y;
	OutMatrix[3][2] = Translation.z;

	float x2 = Rotation.x + Rotation.x;
	float y2 = Rotation.y + Rotation.y;
	float z2 = Rotation.z + Rotation.z;
	{
		float xx2 = Rotation.x * x2;
		float yy2 = Rotation.y * y2;
		float zz2 = Rotation.z * z2;
		OutMatrix[0][0] = (1.0f - (yy2 + zz2)) * Scale3D.x;
		OutMatrix[1][1] = (1.0f - (xx2 + zz2)) * Scale3D.y;
		OutMatrix[2][2] = (1.0f - (xx2 + yy2)) * Scale3D.z;
	}
	{
		float yz2 = Rotation.y * z2;
		float wx2 = Rotation.w * x2;

		OutMatrix[2][1] = (yz2 - wx2) * Scale3D.z;
		OutMatrix[1][2] = (yz2 + wx2) * Scale3D.y;
	}
	{
		float xy2 = Rotation.x * y2;
		float wz2 = Rotation.w * z2;

		OutMatrix[1][0] = (xy2 - wz2) * Scale3D.y;
		OutMatrix[0][1] = (xy2 + wz2) * Scale3D.x;
	}
	{
		float xz2 = Rotation.x * z2;
		float wy2 = Rotation.w * y2;

		OutMatrix[2][0] = (xz2 + wy2) * Scale3D.z;
		OutMatrix[0][2] = (xz2 - wy2) * Scale3D.x;
	}

	OutMatrix[0][3] = 0.0f;
	OutMatrix[1][3] = 0.0f;
	OutMatrix[2][3] = 0.0f;
	OutMatrix[3][3] = 1.0f;

	return OutMatrix;
}

```

`EFTViloresiSockClient/EFT-Viloresi/math.hpp`:

```hpp
#pragma once
// Libraries
#include <math.h>
#include <assert.h>

class FVector;
class FRotator;
class Vector3;

float DegToRad(float x);
float RadToDeg(float x);
float DistancePointToLine(FVector Point, FVector LineOrigin, FVector Dir);



// Class Vector2
// This class represents a 2D vector.
class Vector2 {

public:

    // -------------------- Attributes -------------------- //

    // Components of the vector
    float x, y;


    // -------------------- Methods -------------------- //

    // Constructor
    Vector2(float x = 0, float y = 0) : x(x), y(y) {}

    // Constructor
    Vector2(const Vector2& vector) : x(vector.x), y(vector.y) {}

    // + operator
    Vector2 operator+(const Vector2& v) const {
        return Vector2(x + v.x, y + v.y);
    }

    // += operator
    Vector2& operator+=(const Vector2& v) {
        x += v.x; y += v.y;
        return *this;
    }

    // - operator
    Vector2 operator-(const Vector2& v) const {
        return Vector2(x - v.x, y - v.y);
    }

    // -= operator
    Vector2& operator-=(const Vector2& v) {
        x -= v.x; y -= v.y;
        return *this;
    }

    // = operator
    Vector2& operator=(const Vector2& vector) {
        if (&vector != this) {
            x = vector.x;
            y = vector.y;
        }
        return *this;
    }

    // == operator
    bool operator==(const Vector2& v) const {
        return x == v.x && y == v.y;
    }

    // * operator
    Vector2 operator*(float f) const {
        return Vector2(f * x, f * y);
    }

    // *= operator
    Vector2& operator*=(float f) {
        x *= f; y *= f;
        return *this;
    }

    // / operator
    Vector2 operator/(float f) const {
        assert(f != 0);
        float inv = 1.f / f;
        return Vector2(x * inv, y * inv);
    }

    // /= operator
    Vector2& operator/=(float f) {
        assert(f != 0);
        float inv = 1.f / f;
        x *= inv; y *= inv;
        return *this;
    }

    // - operator
    Vector2 operator-() const {
        return Vector2(-x, -y);
    }

    // [] operator
    float& operator[](int i) {
        assert(i >= 0 && i <= 1);
        switch (i) {
        case 0: return x;
        case 1: return y;
        }
        return y;
    }

    // Normalize the vector and return it
    Vector2 normalize() {
        float l = length();
        assert(l > 0);
        x /= l;
        y /= l;
        return *this;
    }

    // Clamp the vector values between 0 and 1
    Vector2 clamp01() {
        if (x > 1.f) x = 1.f;
        else if (x < 0.f) x = 0.f;
        if (y > 1.f) y = 1.f;
        else if (y < 0.f) y = 0.f;
        return *this;
    }

    // Return the squared length of the vector
    float lengthSquared() const { return x * x + y * y; }

    // Return the length of the vector
    float length() const { return sqrt(lengthSquared()); }
};


//Vector3
class Vector3
{
public:
    Vector3() : x(0.f), y(0.f), z(0.f)
    {

    }

    Vector3(float _x, float _y, float _z) : x(_x), y(_y), z(_z)
    {

    }
    ~Vector3()
    {

    }

    float x;
    float y;
    float z;

    float Dot(Vector3 v);
    Vector3 operator+(Vector3 v);
    Vector3 operator-(Vector3 v);
    float Distance(Vector3 v);
};

class Vector4
{
public:
    float x, z, y;

    Vector4();
    Vector4(float x, float y, float z, float w);
    Vector4(float x, float y, float z);
    Vector4(float* x, float* y, float* z, float* w);
    ~Vector4() {}

    Vector4 operator= (const Vector4& v);
    const Vector4 operator* (const float& scalar) const;
    const Vector4 operator+ (const Vector4& v) const;

    //inline void show() { std::cout << this->x << " " << this->y << " " << this->z << " " << this->w << std::endl; }

private:

    float w;

    // only to allow do that: m(0) = Vector4(1,1,1,1) //
    float* px;
    float* py;
    float* pz;
    float* pw;

    bool pointer;  // to check what constructor was called //
};

class FVector
{
public:
    float x, z, y;

    FVector();
    FVector(float x, float y, float z);
    FVector(const FVector& other);

    FVector operator+ (const FVector& other) const;
    FVector operator- (const FVector& other) const;
    FVector operator* (const float other) const;
    float operator* (const FVector& other) const;

    bool operator == (const FVector& other) const;
    bool operator != (const FVector& other) const;

    FVector& operator= (const FVector& other);
    FVector& operator+= (const FVector& other);
    FVector& operator-= (const FVector& other);
    FVector& operator*= (const float other);

    float& operator[](size_t i);
    const float& operator[](size_t i) const;

    float GetLength() const;
    float Distance(FVector v);
    float Distance2(FVector a, FVector b);
    float GetMagnitudeSqr();

    FRotator VectorAngles() const;
};

class FMatrix
{
public:
    FMatrix() : m{
        { 0.f, 0.f, 0.f, 0.f },
        { 0.f, 0.f, 0.f, 0.f },
        { 0.f, 0.f, 0.f, 0.f },
        { 0.f, 0.f, 0.f, 0.f } }
    {
    }

    FMatrix(const FMatrix&) = default;


    float* operator[](size_t i) { return m[i]; }
    const float* operator[](size_t i) const { return m[i]; }


    FVector operator*(const FVector& vec);
    FMatrix operator*(const FMatrix& other);
    float m[4][4];
};

class FRotator
{
public:
    float yaw;
    float pitch;
    float roll;

    FRotator();
    FRotator(float pitch, float yaw, float roll);
    FRotator(const FRotator& other);

    void ToSourceAngles();
    void ToUnityAngles();
    void Normalize();
    FVector AngleVector();
    void AngleVectors(FVector* x, FVector* y, FVector* z);
};

struct FQuat
{
    float x;
    float y;
    float z;
    float w;

    FQuat operator*(const FQuat& other);
};

struct FTransform
{
public:
    FQuat Rotation;
    FVector Translation;
private:
    float pad0;
public:
    FVector Scale3D;
private:
    float pad1;

public:
    FMatrix ToMatrixWithScale();

};

struct FBoxSphereBounds
{
    FVector	Origin;
    FVector BoxExtent;
    float SphereRadius;
};

```

`EFTViloresiSockClient/EFT-Viloresi/utils.h`:

```h
#pragma once
#include <TlHelp32.h>
#include <iostream>
#include <vector>


int GetProcessIdByName(std::wstring targetProcessName) {
	std::vector<DWORD> pids;
	//std::wstring targetProcessName = PROCESS_NAME_TOGETPID;

	HANDLE snap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); //all processes

	PROCESSENTRY32W entry; //current process
	entry.dwSize = sizeof entry;

	if (!Process32FirstW(snap, &entry)) { //start with the first in snapshot
		return 0;
	}

	do {
		if (std::wstring(entry.szExeFile) == targetProcessName) {
			pids.emplace_back(entry.th32ProcessID); //name matches; add to list
		}
	} while (Process32NextW(snap, &entry)); //keep going until end of snapshot

	for (int i(0); i < pids.size(); ++i) {
		//std::cout << "pids:" << pids[i] << std::endl;
		return pids[i];

	}
	return 0;
}


```

`EFTViloresiSockClient/EFT-Viloresi/visuals.h`:

```h
#pragma once
#include <Windows.h>
#include <d2d1.h>
#include <d3dx9.h>
#include <d3d9.h>
#include <Dwmapi.h> 
#include <list>

#include "math.hpp"


	void Render();
	bool WorldToScreenv2(const FVector& point3D, D2D1_POINT_2F& point2D);


```

`EFTViloresiSockClient/EFTViloresiSockClient.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31911.196
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "imxyviEftStreamedCLIENT", "EFT-Viloresi\EFT-Viloresi.vcxproj", "{4E76EA4E-885F-46F3-B5AA-617F51565D65}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{4E76EA4E-885F-46F3-B5AA-617F51565D65}.Debug|x64.ActiveCfg = Debug|x64
		{4E76EA4E-885F-46F3-B5AA-617F51565D65}.Debug|x64.Build.0 = Debug|x64
		{4E76EA4E-885F-46F3-B5AA-617F51565D65}.Debug|x86.ActiveCfg = Debug|Win32
		{4E76EA4E-885F-46F3-B5AA-617F51565D65}.Debug|x86.Build.0 = Debug|Win32
		{4E76EA4E-885F-46F3-B5AA-617F51565D65}.Release|x64.ActiveCfg = Release|x64
		{4E76EA4E-885F-46F3-B5AA-617F51565D65}.Release|x64.Build.0 = Release|x64
		{4E76EA4E-885F-46F3-B5AA-617F51565D65}.Release|x86.ActiveCfg = Release|Win32
		{4E76EA4E-885F-46F3-B5AA-617F51565D65}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {E4449E18-78F4-4CF6-8F4D-DE1612F9EFCF}
	EndGlobalSection
EndGlobal

```

`EFTViloresiSockServer/EFT-Viloresi/ConstantsAndOffsets.h`:

```h
#pragma once
#define DEFAULT_PORT "27016" // server GIUACOM
//#define DEFAULT_PORT "27015" // server GIORGIO

#define GAME_PROCESS_NAME L"EscapeFromTarkov.exe"
#define DRIVER_FILENAMEW L"\\\\.\\Fafaki"
#define IO_READorWRITE_REQUEST CTL_CODE(FILE_DEVICE_UNKNOWN, 0x0341, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define IO_GET_UNITYPLAYER CTL_CODE(FILE_DEVICE_UNKNOWN, 0x0342, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)

//#define DRIVER_FILENAMEW L"\\\\.\\Kikiki"
//#define IO_READorWRITE_REQUEST CTL_CODE(FILE_DEVICE_UNKNOWN, 0x0301, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
//#define IO_GET_UNITYPLAYER CTL_CODE(FILE_DEVICE_UNKNOWN, 0x0302, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
// communication constants
#define PLAYERS_LIST_REQUEST 0x02
#define ITEMS_REQUEST 0x03
#define PLAYERS_MATRIX_PACKET_SIZE 28800 // 28 KB is the size of about 100 player structs 
#define ITEMS_PACKET_SIZE 106000
//others
#define PLAYER_SAVED_BONES_COUNT 23 // I've saved 23 different bones positions for each player
#define MAX_PLAYERS_SAVED 100
#define TOTAL_SAVED_BONES 22
#define headPosN 0
#define neckPosN 1
#define RupperarmPosN 2
#define LupperarmPosN 3
#define Rforearm1PosN 4
#define Lforearm1PosN 5
#define Rforearm2PosN 6
#define Lforearm2PosN 7
#define Rforearm3PosN 8
#define Lforearm3PosN 9
#define pelvisPosN 10
#define LCalfN 11
#define RCalfN 12
#define LfootN 13
#define RfootN 14
#define RPalmPosN 15
#define LPalmPosN 16
#define Spine1PosN 17
#define Spine2PosN 18
#define Spine3PosN 19
#define IS_LOCAL_PLAYER 20
#define IS_PLAYER 21

//game offsets

#define GAME_OBJECT_MANAGER_OFF 0x17F8D28
#define PLAYERCOUNT_OFF	0x18
```

`EFTViloresiSockServer/EFT-Viloresi/EFT-Viloresi.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{4e76ea4e-885f-46f3-b5aa-617f51565d65}</ProjectGuid>
    <RootNamespace>EFTViloresi</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>EFT-ViloresiSockServer</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <LibraryPath>C:\Program Files %28x86%29\Microsoft DirectX SDK %28June 2010%29\Lib\x64;$(SourceDir)Libs;$(LibraryPath)</LibraryPath>
    <IncludePath>C:\Program Files %28x86%29\Microsoft DirectX SDK %28June 2010%29\Include;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
      <AdditionalDependencies>d3d9.lib;d3dx9.lib;dwmapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
    <ClCompile Include="math.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="ConstantsAndOffsets.h" />
    <ClInclude Include="EFTData.h" />
    <ClInclude Include="EFTSockServer.h" />
    <ClInclude Include="GameVariables.h" />
    <ClInclude Include="math.hpp" />
    <ClInclude Include="MemOperations.h" />
    <ClInclude Include="utils.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`EFTViloresiSockServer/EFT-Viloresi/EFT-Viloresi.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="File di origine">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="File di intestazione">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="File di risorse">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>File di origine</Filter>
    </ClCompile>
    <ClCompile Include="math.cpp">
      <Filter>File di origine</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="MemOperations.h">
      <Filter>File di intestazione</Filter>
    </ClInclude>
    <ClInclude Include="utils.h">
      <Filter>File di intestazione</Filter>
    </ClInclude>
    <ClInclude Include="ConstantsAndOffsets.h">
      <Filter>File di intestazione</Filter>
    </ClInclude>
    <ClInclude Include="EFTSockServer.h">
      <Filter>File di intestazione</Filter>
    </ClInclude>
    <ClInclude Include="EFTData.h">
      <Filter>File di intestazione</Filter>
    </ClInclude>
    <ClInclude Include="GameVariables.h">
      <Filter>File di intestazione</Filter>
    </ClInclude>
    <ClInclude Include="math.hpp">
      <Filter>File di intestazione</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`EFTViloresiSockServer/EFT-Viloresi/EFT-Viloresi.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`EFTViloresiSockServer/EFT-Viloresi/EFTData.h`:

```h
#pragma once
#include "GameVariables.h"
#include <xmmintrin.h>  
#include <emmintrin.h>
#include <d3dx9.h>
using namespace std;

namespace EFTStructs
{
	struct BaseObject
	{
		uint64_t previousObjectLink; //0x0000
		uint64_t nextObjectLink; //0x0008
		uint64_t object; //0x0010
	};

	struct GameObjectManager {
		uint64_t lastTaggedNode; // 0x0
		uint64_t taggedNodes; // 0x8
		uint64_t lastMainCameraTaggedNode; // 0x10
		uint64_t mainCameraTaggedNodes; // 0x18
		uint64_t lastActiveNode; // 0x20
		uint64_t activeNodes; // 0x28
	};
	class ListInternal
	{
	public:
		char pad_0x0000[0x20]; //0x0000
		uintptr_t* firstEntry; //0x0020 
	}; //Size=0x0028

	class List
	{
	public:
		char pad_0x0000[0x10]; //0x0000
		ListInternal* listBase; //0x0010 
		__int32 itemCount; //0x0018 
	}; //Size=0x001C
}
class EFTData
{
private:
	uint64_t matrix_list_base = 0;
	uint64_t dependency_index_table_base = 0;
public:
	EFT_Offsets offsets;
	uint64_t Unity_Player_DllBase = 0;
	int          playercount;
	EFTPlayer localPlayer;
	std::vector<EFTPlayer> players;
	D3DXMATRIX viewMatrix;
	D3DXMATRIX temp_matrix;
	uint64_t getbone_matrix(uint64_t instance)
	{
		static std::vector<uint64_t> temp{ offsets.Player.playerBody, 0x28, 0x28, 0x10 };
		return ReadChain(instance, temp);
	}
	uint64_t GetObjectFromList(uint64_t listPtr, uint64_t lastObjectPtr, const char* objectName)
	{
		using EFTStructs::BaseObject;
		char name[256];
		uint64_t classNamePtr = 0x0;
		uint32_t BaseObjectSize = sizeof(uint64_t) * 3;
		BaseObject activeObject, lastObject;
		readmem(listPtr, &activeObject, BaseObjectSize);
		readmem(lastObjectPtr, &lastObject, BaseObjectSize);

		if (activeObject.object != 0x0)
		{
			readmem(activeObject.nextObjectLink, &activeObject, BaseObjectSize);
			while (activeObject.object != 0 && activeObject.object != lastObject.object)
			{

				readmem(activeObject.object + 0x60, &(classNamePtr), sizeof(uint64_t));
				readmem(classNamePtr + 0x0, &name, sizeof(name));

				if (strcmp(name, objectName) == 0)
				{
					return activeObject.object;
				}
				readmem(activeObject.nextObjectLink, &activeObject, BaseObjectSize);
			}
		}
		if (lastObject.object != 0x0)
		{
			readmem(lastObject.object + 0x60, &classNamePtr, sizeof(uint64_t));
			readmem(classNamePtr + 0x0, &name, 256);

			if (strcmp(name, objectName) == 0)
			{
				return lastObject.object;
			}
		}

		return uint64_t();
	}
	FVector GetPosition(uint64_t transform)
	{
		uint64_t transform_internal = 0, matrices = 0;
		int index = 0;

		readmem(transform + 0x10, &transform_internal, sizeof(uint64_t));
		readmem(transform_internal + 0x38, &matrices, sizeof(uint64_t));
		readmem(transform_internal + 0x40, &index, sizeof(int));

		readmem(matrices + 0x18, &matrix_list_base, sizeof(matrix_list_base));

		readmem((matrices + 0x20), &dependency_index_table_base, sizeof(dependency_index_table_base));

		static auto get_dependency_index = [this](uint64_t base, int32_t index)
		{
			readmem((base + index * 4), &index, sizeof(index));
			return index;
		};

		static auto get_matrix_blob = [this](uint64_t base, uint64_t offs, float* blob, uint32_t size) {
			readmem((base + offs), blob, size);
		};

		int32_t index_relation = get_dependency_index(dependency_index_table_base, index);

		FVector ret_value;
		{
			float* base_matrix3x4 = (float*)malloc(64),
				* matrix3x4_buffer0 = (float*)((uint64_t)base_matrix3x4 + 16),
				* matrix3x4_buffer1 = (float*)((uint64_t)base_matrix3x4 + 32),
				* matrix3x4_buffer2 = (float*)((uint64_t)base_matrix3x4 + 48);

			get_matrix_blob(matrix_list_base, index * 48, base_matrix3x4, 16);

			__m128 xmmword_1410D1340 = { -2.f, 2.f, -2.f, 0.f };
			__m128 xmmword_1410D1350 = { 2.f, -2.f, -2.f, 0.f };
			__m128 xmmword_1410D1360 = { -2.f, -2.f, 2.f, 0.f };

			while (index_relation >= 0)
			{
				uint32_t matrix_relation_index = 6 * index_relation;

				// paziuret kur tik 3 nureadina, ten translationas, kur 4 = quatas ir yra rotationas.
				get_matrix_blob(matrix_list_base, 8 * matrix_relation_index, matrix3x4_buffer2, 16);
				__m128 v_0 = *(__m128*)matrix3x4_buffer2;

				get_matrix_blob(matrix_list_base, 8 * matrix_relation_index + 32, matrix3x4_buffer0, 16);
				__m128 v_1 = *(__m128*)matrix3x4_buffer0;

				get_matrix_blob(matrix_list_base, 8 * matrix_relation_index + 16, matrix3x4_buffer1, 16);
				__m128i v9 = *(__m128i*)matrix3x4_buffer1;

				__m128* v3 = (__m128*)base_matrix3x4; // r10@1
				__m128 v10; // xmm9@2
				__m128 v11; // xmm3@2
				__m128 v12; // xmm8@2
				__m128 v13; // xmm4@2
				__m128 v14; // xmm2@2
				__m128 v15; // xmm5@2
				__m128 v16; // xmm6@2
				__m128 v17; // xmm7@2

				v10 = _mm_mul_ps(v_1, *v3);
				v11 = _mm_castsi128_ps(_mm_shuffle_epi32(v9, 0));
				v12 = _mm_castsi128_ps(_mm_shuffle_epi32(v9, 85));
				v13 = _mm_castsi128_ps(_mm_shuffle_epi32(v9, -114));
				v14 = _mm_castsi128_ps(_mm_shuffle_epi32(v9, -37));
				v15 = _mm_castsi128_ps(_mm_shuffle_epi32(v9, -86));
				v16 = _mm_castsi128_ps(_mm_shuffle_epi32(v9, 113));

				v17 = _mm_add_ps(
					_mm_add_ps(
						_mm_add_ps(
							_mm_mul_ps(
								_mm_sub_ps(
									_mm_mul_ps(_mm_mul_ps(v11, (__m128)xmmword_1410D1350), v13),
									_mm_mul_ps(_mm_mul_ps(v12, (__m128)xmmword_1410D1360), v14)),
								_mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(v10), -86))),
							_mm_mul_ps(
								_mm_sub_ps(
									_mm_mul_ps(_mm_mul_ps(v15, (__m128)xmmword_1410D1360), v14),
									_mm_mul_ps(_mm_mul_ps(v11, (__m128)xmmword_1410D1340), v16)),
								_mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(v10), 85)))),
						_mm_add_ps(
							_mm_mul_ps(
								_mm_sub_ps(
									_mm_mul_ps(_mm_mul_ps(v12, (__m128)xmmword_1410D1340), v16),
									_mm_mul_ps(_mm_mul_ps(v15, (__m128)xmmword_1410D1350), v13)),
								_mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(v10), 0))),
							v10)),
					v_0);

				*v3 = v17;

				index_relation = get_dependency_index(dependency_index_table_base, index_relation);
			}

			ret_value = *(FVector*)base_matrix3x4;
			delete[] base_matrix3x4;
		}

		return ret_value;
	}
	bool InitOffsets()
	{

		GetUnityPlayer(hDriver, GAME_PROCESS_ID, (uint64_t)&Unity_Player_DllBase);
		if (!Unity_Player_DllBase)
			return false;
		readmem(Unity_Player_DllBase + GAME_OBJECT_MANAGER_OFF, &(offsets.gameObjectManager), sizeof(DWORD64));

		if (!offsets.gameObjectManager)
		{
			cout << "objectmanager fail";
			return false;
		}
		uint64_t LastActiveNode = 0, ActiveNodes = 0;
		uint64_t LastMainCameraTaggedNode = 0, MainCameraTaggedNodes = 0;
		uint64_t LastTaggedNode = 0, TaggedNodes = 0;

		readmem(offsets.gameObjectManager + offsetof(EFTStructs::GameObjectManager, lastActiveNode), &LastActiveNode, sizeof(uint64_t));
		readmem(offsets.gameObjectManager + offsetof(EFTStructs::GameObjectManager, activeNodes), &ActiveNodes, sizeof(uint64_t));

		readmem(offsets.gameObjectManager + offsetof(EFTStructs::GameObjectManager, lastMainCameraTaggedNode), &LastMainCameraTaggedNode, sizeof(uint64_t));
		readmem(offsets.gameObjectManager + offsetof(EFTStructs::GameObjectManager, mainCameraTaggedNodes), &MainCameraTaggedNodes, sizeof(uint64_t));

		//readmem(offsets.gameObjectManager + offsetof(EFTStructs::GameObjectManager, lastTaggedNode), &LastTaggedNode, sizeof(uint64_t));
		//readmem(offsets.gameObjectManager + offsetof(EFTStructs::GameObjectManager, taggedNodes), &TaggedNodes, sizeof(uint64_t));

		if (!LastActiveNode || !ActiveNodes || !LastMainCameraTaggedNode || !MainCameraTaggedNodes)
			return false;
		if (!(offsets.gameWorld = GetObjectFromList(ActiveNodes, LastActiveNode, "GameWorld")))
			return false;
		if (!(offsets.fpsCamera = GetObjectFromList(MainCameraTaggedNodes, LastMainCameraTaggedNode, "FPS Camera")))
			return false;
		if (!(offsets.localGameWorld = ReadChain(offsets.gameWorld, { 0x30, 0x18, 0x28 })))
			return false;

		return true;
	}
	float playersposarray[MAX_PLAYERS_SAVED][TOTAL_SAVED_BONES][3];
	bool PrepareAndSendPlayersAndMatrixPacket(int playerscount)
	{
		char PreparedPacket[PLAYERS_MATRIX_PACKET_SIZE];
		int counter = 1; // the first 4 bytes are needed for the playerscount
		memcpy(PreparedPacket, &playerscount, sizeof(int));
		for (int i = 0; i < playerscount; i++)
		{
			for (int k = 0; k < TOTAL_SAVED_BONES; k++)
			{
				for (int j = 0; j < 3; j++, counter++)
				{
					memcpy(PreparedPacket + counter * sizeof(float), playersposarray[i][k] + j * sizeof(float), sizeof(float));
				}
			}
		}
		memcpy(PreparedPacket + counter * sizeof(float), &(temp_matrix), sizeof(D3DXMATRIX));
		int iResult = send(ClientSocket, PreparedPacket, counter * sizeof(float) + sizeof(D3DXMATRIX) , 0);
		if (iResult == SOCKET_ERROR)
			return false;
		return true;
	}
	wchar_t itemName[2000][25];
	float itemCoord[2000][3] = { 0 };
	bool PrepareAndSendItemsPacket(int itemscount)
	{
		char PreparedPacket[ITEMS_PACKET_SIZE];
		int counter = 1, namesizecounter = 0; // the first 4 bytes are needed for the itemscount
		memcpy(PreparedPacket, &itemscount, sizeof(int));
		for (int i = 0; i < itemscount; i++)
		{
				for (int j = 0; j < 3; j++, counter++)
				{
					memcpy(PreparedPacket + counter * sizeof(float) + namesizecounter * 50, itemCoord[i] + j * sizeof(float), sizeof(float));
				}
				memcpy(PreparedPacket + counter * sizeof(float) + namesizecounter * 50, itemName[i], 50); // 50 bytes is the ItemNameSize
				namesizecounter++;
		}
		int iResult = send(ClientSocket, PreparedPacket, counter * sizeof(float) + namesizecounter * 50, 0);
		if (iResult == SOCKET_ERROR)
			return false;
		return true;
	}
	bool ReadItemsLoop()
	{
		uint64_t loot_array = 0, get_item_list = 0;
		uint64_t loot = 0, itemObject = 0, itemProfile = 0, itemtemp11 = 0, transform_1 = 0, TransformTwo = 0, m_pItemPosition = 0;
		uint64_t interactive = 0, item_template_temp1 = 0, item_template = 0, id_obj = 0;
		uint32_t itemscount = 0;
		

		if (!(offsets.localGameWorld = ReadChain(offsets.gameWorld, { 0x30, 0x18, 0x28 })))
			return false;
		readmem(offsets.localGameWorld + 0x60, &loot_array, sizeof(uint64_t));
		if (!loot_array)
			return false;
		readmem(loot_array + 0x18, &itemscount, sizeof(uint32_t));
		readmem(loot_array + 0x10, &get_item_list, sizeof(uint64_t));
		if (itemscount <= 0 || itemscount >= 6000 || !get_item_list)
			return false;
		
		for (int i = 0; i < itemscount; i++)
		{
			readmem(get_item_list + 0x20 + (i * 0x8), &loot, sizeof(uint64_t));
			readmem(loot + 0x10, &itemObject, sizeof(uint64_t));
			readmem(itemObject + 0x28, &itemProfile, sizeof(uint64_t));
			readmem(itemObject + 0x30, &itemtemp11, sizeof(uint64_t));
			readmem(itemtemp11 + 0x30, &transform_1, sizeof(uint64_t));
			readmem(transform_1 + 0x08, &TransformTwo, sizeof(uint64_t));
			readmem(TransformTwo + 0x38, &m_pItemPosition, sizeof(uint64_t));
			readmem(m_pItemPosition + 0x90, &itemCoord[i], sizeof(float) * 3);

			readmem(itemProfile + 0x50, &item_template_temp1, sizeof(uint64_t));
			readmem(item_template_temp1 + 0x40, &item_template, sizeof(uint64_t));
			readmem(item_template + 0x50, &id_obj, sizeof(uint64_t));
			readmem(id_obj + 0x14, &itemName[i], 50); // 25 bytes * 2 itemName
		}
		PrepareAndSendItemsPacket(itemscount);
		return true;
	}
	bool ReadLoop()
	{

		players.clear();
		if (!(offsets.localGameWorld = ReadChain(offsets.gameWorld, { 0x30, 0x18, 0x28 })))
		{ 
			cout << "no localgameworld\n";
			return false;
		}

		uint64_t onlineusers = 0, list_base = 0;
		int player_count = 0;
		readmem(offsets.localGameWorld + 0x80, &onlineusers, sizeof(uint64_t));
		if (!onlineusers)
		{ 
			cout << "no onlineusers\n";
			return false;
		}
		readmem(onlineusers + offsetof(EFTStructs::List, listBase), &list_base, sizeof(uint64_t));
		readmem(onlineusers + 0x18, &player_count, sizeof(int)); //  + 0x18
		if (player_count <= 0 || !list_base)
		{ 
			cout << "no playercount\n";
			return false;
		}

		constexpr auto BUFFER_SIZE = 128;

		uint64_t player_buffer[BUFFER_SIZE];
		readmem(list_base + offsetof(EFTStructs::ListInternal, firstEntry), player_buffer, sizeof(uint64_t) * player_count);
		if (!player_buffer)
		{ 
			cout << "no playerbuffer\n";
			return false;
		}
		EFTPlayer player;

		for (int i = 0; i < player_count; i++)
		{


			player.instance = player_buffer[i];
			playercount = player_count;

			int boolplayer = 0;

			uint64_t PlayerInfo = ReadChain(player.instance, { 0x4E0, 0x28 });
			if (PlayerInfo)
			{
				readmem(PlayerInfo + 0x5C, &player.RegistrationDate, sizeof(uint32_t));
				if (player.RegistrationDate != 0)
					playersposarray[i][IS_PLAYER][0] = 1;
				else
					playersposarray[i][IS_PLAYER][0] = 0;
			}
			else
			{ 
				cout << "no playerinfo\n";
				continue;
				//return false;
			}

			readmem(player.instance + 0x18, &boolplayer, sizeof(int));
			if (boolplayer)
			{
				localPlayer = player;
				localPlayer.location = player.location;
				playersposarray[i][IS_LOCAL_PLAYER][0] = 1;
			}
			else
				playersposarray[i][IS_LOCAL_PLAYER][0] = 0;

			uint64_t bone_matrix = getbone_matrix(player.instance);

			if (bone_matrix)
			{
				uint64_t bone = ReadChain(bone_matrix, { 0x20, 0x10, 0x38 });
				if (!bone)
				{
					cout << "no bone \n";
					continue;
					//return false;
				}
				readmem(bone + 0x90, &(player.location), sizeof(FVector));
				uint64_t boneheadpos = 0, boneneckpos = 0, boneRupperarmpos = 0, boneLupperarmpos = 0, boneRforearm1pos = 0, boneLforearm1pos = 0, bonepelvispos = 0, boneLCalfpos = 0, boneRCalfpos = 0, boneLFootpos = 0, boneRFootpos = 0, boneLforearm2pos = 0, boneRforearm2pos = 0, boneLforearm3pos = 0, boneRforearm3pos = 0;
				uint64_t boneRPalmpos = 0, boneLPalmpos = 0, boneSpine1pos = 0, boneSpine2pos = 0, boneSpine3pos = 0;
				readmem(bone_matrix + 0x20 + (int)Bones::HumanHead * 8, &boneheadpos, sizeof(uint64_t));
				readmem(bone_matrix + 0x20 + (int)Bones::HumanNeck * 8, &boneneckpos, sizeof(uint64_t));
				readmem(bone_matrix + 0x20 + (int)Bones::HumanRUpperarm * 8, &boneRupperarmpos, sizeof(uint64_t));
				readmem(bone_matrix + 0x20 + (int)Bones::HumanLUpperarm * 8, &boneLupperarmpos, sizeof(uint64_t));
				readmem(bone_matrix + 0x20 + (int)Bones::HumanRForearm1 * 8, &boneRforearm1pos, sizeof(uint64_t));
				readmem(bone_matrix + 0x20 + (int)Bones::HumanLForearm1 * 8, &boneLforearm1pos, sizeof(uint64_t));
				readmem(bone_matrix + 0x20 + (int)Bones::HumanLForearm2 * 8, &boneLforearm2pos, sizeof(uint64_t));
				readmem(bone_matrix + 0x20 + (int)Bones::HumanRForearm2 * 8, &boneRforearm2pos, sizeof(uint64_t));
				readmem(bone_matrix + 0x20 + (int)Bones::HumanLForearm3 * 8, &boneLforearm3pos, sizeof(uint64_t));
				readmem(bone_matrix + 0x20 + (int)Bones::HumanRForearm3 * 8, &boneRforearm3pos, sizeof(uint64_t));
				readmem(bone_matrix + 0x20 + (int)Bones::HumanRPalm * 8, &boneRPalmpos, sizeof(uint64_t));
				readmem(bone_matrix + 0x20 + (int)Bones::HumanLPalm * 8, &boneLPalmpos, sizeof(uint64_t));
				readmem(bone_matrix + 0x20 + (int)Bones::HumanSpine1 * 8, &boneSpine1pos, sizeof(uint64_t));
				readmem(bone_matrix + 0x20 + (int)Bones::HumanSpine2 * 8, &boneSpine2pos, sizeof(uint64_t));
				readmem(bone_matrix + 0x20 + (int)Bones::HumanSpine3 * 8, &boneSpine3pos, sizeof(uint64_t));

				readmem(bone_matrix + 0x20 + (int)Bones::HumanPelvis * 8, &bonepelvispos, sizeof(uint64_t));
				readmem(bone_matrix + 0x20 + (int)Bones::HumanLCalf * 8, &boneLCalfpos, sizeof(uint64_t));
				readmem(bone_matrix + 0x20 + (int)Bones::HumanRCalf * 8, &boneRCalfpos, sizeof(uint64_t));
				readmem(bone_matrix + 0x20 + (int)Bones::HumanLFoot * 8, &boneLFootpos, sizeof(uint64_t));
				readmem(bone_matrix + 0x20 + (int)Bones::HumanRFoot * 8, &boneRFootpos, sizeof(uint64_t));


				player.headPos = GetPosition(boneheadpos);
				player.neckPos = GetPosition(boneneckpos);
				player.RupperarmPos = GetPosition(boneRupperarmpos);
				player.LupperarmPos = GetPosition(boneLupperarmpos);
				player.Rforearm1Pos = GetPosition(boneRforearm1pos);
				player.Lforearm1Pos = GetPosition(boneLforearm1pos);
				player.Rforearm2Pos = GetPosition(boneRforearm2pos);
				player.Lforearm2Pos = GetPosition(boneLforearm2pos);
				player.Rforearm3Pos = GetPosition(boneRforearm3pos);
				player.Lforearm3Pos = GetPosition(boneLforearm3pos);
				player.pelvisPos = GetPosition(bonepelvispos);
				player.LCalf = GetPosition(boneLCalfpos);
				player.RCalf = GetPosition(boneRCalfpos);
				player.Lfoot = GetPosition(boneLFootpos);
				player.Rfoot = GetPosition(boneRFootpos);
				player.RPalmPos = GetPosition(boneRPalmpos);
				player.LPalmPos = GetPosition(boneLPalmpos);
				player.Spine1Pos = GetPosition(boneSpine1pos);
				player.Spine2Pos = GetPosition(boneSpine2pos);
				player.Spine3Pos = GetPosition(boneSpine3pos);
				for (int k = 0; k < 3; k++)
				{
					playersposarray[i][headPosN][k] = player.headPos[k];
					playersposarray[i][neckPosN][k] = player.neckPos[k];
					playersposarray[i][RupperarmPosN][k] = player.RupperarmPos[k];
					playersposarray[i][LupperarmPosN][k] = player.LupperarmPos[k];
					playersposarray[i][Rforearm1PosN][k] = player.Rforearm1Pos[k];
					playersposarray[i][Lforearm1PosN][k] = player.Lforearm1Pos[k];
					playersposarray[i][Rforearm2PosN][k] = player.Rforearm2Pos[k];
					playersposarray[i][Lforearm2PosN][k] = player.Lforearm2Pos[k];
					playersposarray[i][Rforearm3PosN][k] = player.Rforearm3Pos[k];
					playersposarray[i][Lforearm3PosN][k] = player.Lforearm3Pos[k];
					playersposarray[i][pelvisPosN][k] = player.pelvisPos[k];
					playersposarray[i][LCalfN][k] = player.LCalf[k];
					playersposarray[i][RCalfN][k] = player.RCalf[k];
					playersposarray[i][LfootN][k] = player.Lfoot[k];
					playersposarray[i][RfootN][k] = player.Rfoot[k];
					playersposarray[i][RPalmPosN][k] = player.RPalmPos[k];
					playersposarray[i][LPalmPosN][k] = player.LPalmPos[k];
					playersposarray[i][Spine1PosN][k] = player.Spine1Pos[k];
					playersposarray[i][Spine2PosN][k] = player.Spine2Pos[k];
					playersposarray[i][Spine3PosN][k] = player.Spine3Pos[k];
				}
			}
			else
			{ 
				cout << "no bone matrix \n";
				//return false;
				continue;
			}



			players.emplace_back(player);

		}

		//VieMatrix
		uint64_t temp = offsets.fpsCamera;
		readmem(temp + 0x30, &temp, sizeof(uint64_t));
		if (!temp)
		{
			cout << "no temp 1 \n";
			return false;
		}
		readmem(temp + 0x18, &temp, sizeof(uint64_t));
		if (!temp)
		{ 
			cout << "no temp 2\n";
			return false;
		}


		readmem(temp + 0xDC, &temp_matrix, sizeof(temp_matrix));

		PrepareAndSendPlayersAndMatrixPacket(player_count);

		//D3DXMatrixTranspose(&viewMatrix, &temp_matrix);
		return true;
	}

};

```

`EFTViloresiSockServer/EFT-Viloresi/EFTSockServer.h`:

```h
#pragma once

// Need to link with Ws2_32.lib
#pragma comment (lib, "Ws2_32.lib")
// #pragma comment (lib, "Mswsock.lib")

#define DEFAULT_BUFLEN 512


WSADATA wsaData;
SOCKET ListenSocket = INVALID_SOCKET, ClientSocket = INVALID_SOCKET;
struct addrinfo* result = NULL;
struct addrinfo hints;
int iSendResult, iResult, recvbuflen = DEFAULT_BUFLEN;


int __cdecl InitSock(void)
{
	// Initialize Winsock
	iResult = WSAStartup(MAKEWORD(2, 2), &wsaData);
	ZeroMemory(&hints, sizeof(hints));
	hints.ai_family = AF_INET;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_protocol = IPPROTO_TCP;
	hints.ai_flags = AI_PASSIVE;
	// Resolve the server address and port
	iResult = getaddrinfo(NULL, DEFAULT_PORT, &hints, &result);
	// Create a SOCKET for connecting to server
	ListenSocket = socket(result->ai_family, result->ai_socktype, result->ai_protocol);
	// Setup the TCP listening socket
	iResult = bind(ListenSocket, result->ai_addr, (int)result->ai_addrlen);
	if (iResult == SOCKET_ERROR)
		return 0;
	freeaddrinfo(result);
	iResult = listen(ListenSocket, SOMAXCONN);
	if (iResult == SOCKET_ERROR)
		return 0;
	// Accept a client socket
	ClientSocket = accept(ListenSocket, NULL, NULL);
	if (ClientSocket == INVALID_SOCKET)
		return 0;
	return 1;
}

```

`EFTViloresiSockServer/EFT-Viloresi/GameVariables.h`:

```h
#pragma once
#include "math.hpp"
struct EFT_Offsets
{
	uint64_t gameObjectManager = 0x0;
	uint64_t gameWorld = 0x0;
	uint64_t localGameWorld = 0x0;
	uint64_t fpsCamera = 0x0;
	uint64_t OpticCamera = 0x0;
	struct
	{
		static constexpr uint64_t ExfiltrationController = 0x18;//private \uE334 \uE000;
		static constexpr uint64_t LootList = 0x60;//public readonly List<\uE1B5> LootList = new List<\uE1B5>(1000);
		static constexpr uint64_t RegisteredPlayers = 0x80;//public readonly List<Player> RegisteredPlayers = new List<Player>(40);
	} localGameWorld_offsets;

	struct
	{
		static constexpr uint64_t length = 0x10; //good
		static constexpr uint64_t stringBase = 0x14; //good
	} unicodeString;

	struct
	{
		static constexpr uint64_t information = 0x28; //updated
		static constexpr uint64_t id = 0x10; //updated
	} profile;

	struct
	{
		static constexpr uint64_t playerName = 0x10; //updated
	} information;

	struct
	{
		static constexpr uint64_t angles_0 = 0x1D0;
		static constexpr uint64_t angles_1 = 0x1D8;
		static constexpr uint64_t position = 0x1E0;
	} movementContext;

	struct
	{
		static constexpr uint64_t m_pPlayerProfile = 0x03A0;
		static constexpr uint64_t movementContext = 0x38;
		static constexpr uint64_t proceduralWeaponAnimation = 0x70; //updayed 1/11/2020
		static constexpr uint64_t playerBody = 0xa8;
		static constexpr uint64_t m_pHealthController = 0x3D0; //updated 1/11/2020
		static constexpr uint64_t profile = 0x3A0; //updayed 1/11/2020

	} Player;
};

struct EFTPlayer
{
	uintptr_t	 instance;
	FVector		 headPos;
	FVector		 neckPos;
	FVector		 LupperarmPos;
	FVector		 RupperarmPos;
	FVector		 Lforearm1Pos;
	FVector		 Rforearm1Pos;
	FVector		 Lforearm2Pos;
	FVector		 Rforearm2Pos;
	FVector		 Lforearm3Pos;
	FVector		 Rforearm3Pos;
	FVector		 pelvisPos;
	FVector		 RThigh1Pos;
	FVector		 LThigh1Pos;
	FVector		RPalmPos;
	FVector		LPalmPos;
	FVector		Spine1Pos;
	FVector Spine2Pos;
	FVector Spine3Pos;
	FVector		LCalf;
	FVector		RCalf;
	FVector		Lfoot;
	FVector		Rfoot;
	FVector		 location;
	uint32_t		RegistrationDate;
	//	int		WildSpawnType;
};

struct EFTExtract
{
	uintptr_t	 instance;
	std::string  name;
	FVector		 location;
};
enum Bones : int
{
	HumanBase = 0,
	HumanPelvis = 14,
	HumanLThigh1 = 15,
	HumanLThigh2 = 16,
	HumanLCalf = 17,
	HumanLFoot = 18,
	HumanLToe = 19,
	HumanRThigh1 = 20,
	HumanRThigh2 = 21,
	HumanRCalf = 22,
	HumanRFoot = 23,
	HumanRToe = 24,
	HumanSpine1 = 29,
	HumanSpine2 = 36,
	HumanSpine3 = 37,
	HumanLCollarbone = 89,
	HumanLUpperarm = 90,
	HumanLForearm1 = 91,
	HumanLForearm2 = 92,
	HumanLForearm3 = 93,
	HumanLPalm = 94,
	HumanRCollarbone = 110,
	HumanRUpperarm = 111,
	HumanRForearm1 = 112,
	HumanRForearm2 = 113,
	HumanRForearm3 = 114,
	HumanRPalm = 115,
	HumanNeck = 132,
	HumanHead = 133
};

```

`EFTViloresiSockServer/EFT-Viloresi/MemOperations.h`:

```h
#pragma once
#include "ConstantsAndOffsets.h"
#include "utils.h"

#define DRIVER_NOT_LOADED 1
#define PROCESS_NOT_FOUND 2
DWORD GAME_PROCESS_ID;
DWORD CURRENT_PROCESS_ID;
HANDLE hDriver;

typedef struct _KERNEL_READorWRITE_REQUEST
{
	uint32_t sourceProcessId;
	uint32_t destProcessId;
	uint64_t sourceAddress;
	uint64_t destAddress;
	uint32_t Size;
} KERNEL_READorWRITE_REQUEST, * PKERNEL_READorWRITE_REQUEST;

typedef struct _KERNEL_GETUNITYPLAYER_REQUEST
{
	uint32_t sourceProcessId; //gameprocessId
	uint32_t destProcessId; //usermode hack process id
	uint64_t sourceAddress; // usermode hack buffer

} KERNEL_GETUNITYPLAYER_REQUEST, * PKERNEL_GETUNITYPLAYER_REQUEST;

bool ReadVirtualMemory(HANDLE hDriver, uint32_t sourceProcessId, uint64_t sourceAddress, uint64_t readbuffer, uint32_t Size)
{
	KERNEL_READorWRITE_REQUEST ReadRequest;
	DWORD Bytes;
	ReadRequest.sourceProcessId = sourceProcessId;
	ReadRequest.sourceAddress = sourceAddress;
	ReadRequest.destProcessId = GetCurrentProcessId();
	ReadRequest.destAddress = readbuffer;
	ReadRequest.Size = Size;
	if (DeviceIoControl(hDriver, IO_READorWRITE_REQUEST, &ReadRequest, sizeof(ReadRequest), 0, 0, &Bytes, NULL))
		return true;
	else
		return false;
}

bool GetUnityPlayer(HANDLE hDriver, uint32_t sourceProcessId, uint64_t readbuffer)
{
	KERNEL_GETUNITYPLAYER_REQUEST GetUnityRequest;
	DWORD Bytes;
	GetUnityRequest.sourceProcessId = sourceProcessId;
	GetUnityRequest.sourceAddress = readbuffer;
	GetUnityRequest.destProcessId = GetCurrentProcessId();

	if (DeviceIoControl(hDriver, IO_GET_UNITYPLAYER, &GetUnityRequest, sizeof(GetUnityRequest), 0, 0, &Bytes, NULL))
		return true;
	else
		return false;
}

int Init()
{
	hDriver = CreateFile(DRIVER_FILENAMEW, GENERIC_ALL, FILE_SHARE_READ | FILE_SHARE_WRITE, nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);
	GAME_PROCESS_ID = GetProcessIdByName(GAME_PROCESS_NAME);
	CURRENT_PROCESS_ID = GetCurrentProcessId();
	if (hDriver == INVALID_HANDLE_VALUE)
		return DRIVER_NOT_LOADED;
	else if (GAME_PROCESS_ID == 0)
		return PROCESS_NOT_FOUND;
	else
		return 0;
}

void readmem(void* addresstoread, void* buffer, uint32_t size)
{
	if ((uint64_t)addresstoread < 0x10000) //address in non paged area
	{
		buffer = 0;
		return;
	}
	ReadVirtualMemory(hDriver, GAME_PROCESS_ID, (uint64_t)addresstoread, (uint64_t)buffer, size);
	//SockRequest((uint64_t)addresstoread, (uint64_t)buffer, size);

}
void readmem(uint64_t addresstoread, void* buffer, uint32_t size)
{
	if (addresstoread < 0x10000) //address in non paged area
	{
		buffer = 0;
		return;
	}
		
	ReadVirtualMemory(hDriver, GAME_PROCESS_ID, (uint64_t)addresstoread, (uint64_t)buffer, size);
	//SockRequest((uint64_t)addresstoread, (uint64_t)buffer, size);

}

uint64_t ReadChain(uint64_t base, const std::vector<uint64_t>& offsets) {
	uint64_t result = 0;
	readmem(base + offsets.at(0), &result, sizeof(uint64_t));
	if (!result)
		return 0;
	for (int i = 1; i < offsets.size(); i++) {
		readmem(result + offsets.at(i), &result, sizeof(uint64_t));
		if (!result)
			return 0;
	}
	return result;
}
```

`EFTViloresiSockServer/EFT-Viloresi/main.cpp`:

```cpp
#include <winsock2.h>
#include <ws2tcpip.h>
#include <stdlib.h>
#include <stdio.h>
#include <Windows.h>
#include <iostream>
#include <vector>

using namespace std;
#include "ConstantsAndOffsets.h"

#include "GameVariables.h"
#include "math.hpp"
#include "MemOperations.h"
#include "EFTSockServer.h"
#include "EFTData.h"

#include "utils.h"

EFTData Data;



int SockReadAndReply()
{
	char sendbuffer[DEFAULT_BUFLEN];
	char receivebuffer[DEFAULT_BUFLEN];
	uint64_t addresstoread = 0;
	uint32_t size = 0;
	
	iResult = recv(ClientSocket, receivebuffer, DEFAULT_BUFLEN, 0);
	
	if (iResult == 0x1) // request packet because the size of the packet is 0x1
	{

		if (receivebuffer[0] == PLAYERS_LIST_REQUEST)
		{
			
			if (!Data.ReadLoop())
				cout << "readloop error\n";
			else
				cout << "readloop ok\n";
		}
		if (receivebuffer[0] == ITEMS_REQUEST)
		{

			Data.ReadItemsLoop();
		}
		return 1;
	}
	else if (iResult == 0)
	{
		cerr << "connection with the client lost! \n";
	}
	else if (iResult != (0x1 + sizeof(uint64_t) + sizeof(uint32_t)))
	{
		cerr << "size of the received packet is different from 13 bytes \n";
		return 0;
	}
	if (iSendResult == SOCKET_ERROR)
		return 0;

	return 1;
}

int main()
{
	cout << "initializing and waiting for the client\n";
	if (int returnvalue = Init()) //driver handle and process Ids
	{
		if (returnvalue == DRIVER_NOT_LOADED)
			cout << "Driver not loaded\n";
		if (returnvalue == PROCESS_NOT_FOUND)
			cout << "Process not found\n";
		system("pause");
		return 0;
	}

	if (!Data.InitOffsets())
		cout << "offsets initialization error\n";
	InitSock();
	while (1)
	{
		SockReadAndReply();
	}
	getchar();
	return 1;
}
```

`EFTViloresiSockServer/EFT-Viloresi/math.cpp`:

```cpp
#include "math.hpp"
#include <cmath>
#include <cfloat>

#define M_PI       3.14159265358979323846   // pi

float DegToRad(float x)
{
	return x * ((float)M_PI / 180.f);
}

float RadToDeg(float x)
{
	return x * (180.f / (float)M_PI);
}

float DistancePointToLine(FVector Point, FVector LineOrigin, FVector Dir)
{
	FVector PointDir = Point - LineOrigin;

	float TempOffset = (PointDir * Dir) / Dir.GetMagnitudeSqr(); // Calculates the Offset for: LineOrigin + TempOffset*Dir; - if Dir is already normalized you can skip the dividing
	if (TempOffset < 0.000001f)
		return FLT_MAX;

	FVector PerpendicularPoint = LineOrigin + (Dir * TempOffset);

	return (Point - PerpendicularPoint).GetLength();
}

Vector4::Vector4()
{
	x = 0.0f;
	y = 0.0f;
	z = 0.0f;
	w = 1.0f;
	pointer = false;
}

Vector4::Vector4(float x, float y, float z, float w)
{
	this->x = x; this->y = y; this->z = z; this->w = w;
	pointer = false;
}

Vector4::Vector4(float x, float y, float z)
{
	this->x = x; this->y = y; this->z = z; this->w = 1.0f;
	pointer = false;
}

Vector4::Vector4(float* x, float* y, float* z, float* w)
{
	this->px = x; this->py = y; this->pz = z; this->pw = w;
	this->x = *x; this->y = *y; this->z = *z; this->w = *w;
	pointer = true;
}

Vector4 Vector4::operator= (const Vector4& v)
{
	if (pointer)
	{
		*px = x = v.x;
		*py = y = v.y;
		*pz = z = v.z;
		*pw = w = v.w;
	}
	else
	{
		x = v.x;
		y = v.y;
		z = v.z;
		w = v.w;
	}
}

const Vector4 Vector4::operator* (const float& scalar) const
{
	return Vector4(x * scalar, y * scalar, z * scalar, w * scalar);
}

const Vector4 Vector4::operator+ (const Vector4& v) const
{
	Vector4 vec;
	vec.x = this->x + v.x;
	vec.y = this->y + v.y;
	vec.z = this->z + v.z;
	vec.w = this->w + v.w;
	return vec;
}

float Vector3::Distance(Vector3 v)
{
	return float(sqrtf(powf(v.x - x, 2.0) + powf(v.y - y, 2.0) + powf(v.z - z, 2.0)));
}

Vector3 Vector3::operator+(Vector3 v)
{
	return Vector3(x + v.x, y + v.y, z + v.z);
}

float Vector3::Dot(Vector3 v)
{
	return x * v.x + y * v.y + z * v.z;
}

Vector3 Vector3::operator-(Vector3 v)
{
	return Vector3(x - v.x, y - v.y, z - v.z);
}

FVector::FVector() : x(0.f), y(0.f), z(0.f) {}

FVector::FVector(float x, float y, float z) : x(x), y(y), z(z) {}

FVector::FVector(const FVector& other) : x(other.x), y(other.y), z(other.z) {}

FVector FVector::operator+(const FVector& other) const
{
	return FVector(x + other.x, y + other.y, z + other.z);
}

FVector FVector::operator-(const FVector& other) const
{
	return FVector(x - other.x, y - other.y, z - other.z);
}

FVector FVector::operator*(const float other) const
{
	return FVector(x * other, y * other, z * other);
}

float FVector::operator*(const FVector& other) const
{
	return (x * other.x + y * other.y + z * other.z);
}

bool FVector::operator==(const FVector& other) const
{
	return x == other.x && y == other.y && z == other.z;
}

bool FVector::operator!=(const FVector& other) const
{
	return x != other.x || y != other.y || z != other.z;
}

FVector& FVector::operator=(const FVector& other)
{
	x = other.x;
	y = other.y;
	z = other.z;

	return *this;
}

FVector& FVector::operator+=(const FVector& other)
{
	x += other.x;
	y += other.y;
	z += other.z;

	return *this;
}

FVector& FVector::operator-=(const FVector& other)
{
	x -= other.x;
	y -= other.y;
	z -= other.z;

	return *this;
}

FVector& FVector::operator*=(const float other)
{
	x *= other;
	y *= other;
	z *= other;

	return *this;
}

float& FVector::operator[](size_t i)
{
	return reinterpret_cast<float*>(this)[i];
}

const float& FVector::operator[](size_t i) const
{
	return reinterpret_cast<const float*>(this)[i];
}

float FVector::GetLength() const
{
	return sqrt(x * x + y * y + z * z);
}

float FVector::Distance(FVector v)
{
	return float(sqrtf(powf(v.x - x, 2.0) + powf(v.y - y, 2.0) + powf(v.z - z, 2.0)));
}

float FVector::Distance2(FVector a, FVector b)

{

	float diff_x = a.x - b.x;

	float diff_y = a.y - b.y;

	float diff_z = a.z - b.z;

	return float(sqrtf(diff_x * diff_x + diff_y * diff_y + diff_z * diff_z));

}
float FVector::GetMagnitudeSqr()
{
	return (x * x + y * y + z * z);
}

FRotator FVector::VectorAngles() const
{
	return FRotator(atan2(-x, z), atan2(y, sqrt(x * x + z * z)), 0.f);
}

FRotator::FRotator() : pitch(0.f), yaw(0.f), roll(0.f) {}

FRotator::FRotator(float pitch, float yaw, float roll) : pitch(pitch), yaw(yaw), roll(roll) {}

FRotator::FRotator(const FRotator& other) : pitch(other.pitch), yaw(other.yaw), roll(other.roll) {}

void FRotator::ToSourceAngles()
{
	yaw = -yaw + 90.f;
	Normalize();
}

void FRotator::ToUnityAngles()
{
	ToSourceAngles(); // Toggle behaviour.
}

void FRotator::Normalize()
{
	yaw = remainder(yaw, static_cast<float>(2 * M_PI));
	pitch = remainder(pitch, static_cast<float>(2 * M_PI));
}

FVector FRotator::AngleVector()
{
	float sp, sy, cp, cy;

	sy = sin(yaw / 180.f * (float)M_PI);
	cy = cos(yaw / 180.f * (float)M_PI);

	sp = sin(pitch / 180.f * (float)M_PI);
	cp = cos(pitch / 180.f * (float)M_PI);

	return FVector(cp * cy, cp * sy, -sp);
}

void FRotator::AngleVectors(FVector* x, FVector* y, FVector* z)
{
	float radPitch = (pitch * static_cast<float>(M_PI / 180.f));
	float radYaw = (yaw * static_cast<float>(M_PI / 180.f));
	float radRoll = (roll * static_cast<float>(M_PI / 180.f));

	float SP = sin(radPitch);
	float CP = cos(radPitch);
	float SY = sin(radYaw);
	float CY = cos(radYaw);
	float SR = sin(radRoll);
	float CR = cos(radRoll);


	x->x = CP * CY;
	x->y = CP * SY;
	x->z = SP;

	y->x = SR * SP * CY - CR * SY;
	y->y = SR * SP * SY + CR * CY;
	y->z = -SR * CP;

	z->x = -(CR * SP * CY + SR * SY);
	z->y = CY * SR - CR * SP * SY;
	z->z = CR * CP;
}

FQuat FQuat::operator*(const FQuat& other)
{
	FQuat ret;

	auto& q1 = *this;
	auto& q2 = other;

	ret.x = q1.x * q2.w + q1.y * q2.z - q1.z * q2.y + q1.w * q2.x;
	ret.y = -q1.x * q2.z + q1.y * q2.w + q1.z * q2.x + q1.w * q2.y;
	ret.z = q1.x * q2.y - q1.y * q2.x + q1.z * q2.w + q1.w * q2.z;
	ret.w = -q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w;

	return ret;
}
//
//FMatrix FMatrix::operator*(const FMatrix & other)
//{
//	FMatrix result;
//	for (int i = 0; i < 4; i++)
//	{
//		for (int j = 0; j < 4; j++)
//		{
//			result[i][j] = 0;
//
//			for (int k = 0; k < 4; k++)
//			{
//				result[i][j] += (*this)[i][k] * other[k][j];
//			}
//		}
//	}
//
//	return result;
//}

FVector FMatrix::operator*(const FVector& vec)
{
	/*
	FVector pOut;
	int a[3][3] = { { 2,4,3 },{ 1,5,7 },{ 0,2,3 } };
	int b[] = { 2,5,6 };
	FVector out;

	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			out[i] += (a[i][j] * b[j]);
		}
	}

	return pOut;
	*/


	FMatrix m;

	m[3][0] = vec.x;
	m[3][1] = vec.y;
	m[3][2] = vec.z;

	m[0][0] = 1.f;
	m[1][1] = 1.f;
	m[2][2] = 1.f;


	m[0][3] = 0.0f;
	m[1][3] = 0.0f;
	m[2][3] = 0.0f;
	m[3][3] = 1.0f;

	auto result = m * (*this);

	return FVector(result[3][0], result[3][1], result[3][2]);

}

FMatrix FMatrix::operator*(const FMatrix& pM2)
{
	auto pM1 = *this;

	FMatrix pOut;
	pOut[0][0] = pM1[0][0] * pM2[0][0] + pM1[0][1] * pM2[1][0] + pM1[0][2] * pM2[2][0] + pM1[0][3] * pM2[3][0];
	pOut[0][1] = pM1[0][0] * pM2[0][1] + pM1[0][1] * pM2[1][1] + pM1[0][2] * pM2[2][1] + pM1[0][3] * pM2[3][1];
	pOut[0][2] = pM1[0][0] * pM2[0][2] + pM1[0][1] * pM2[1][2] + pM1[0][2] * pM2[2][2] + pM1[0][3] * pM2[3][2];
	pOut[0][3] = pM1[0][0] * pM2[0][3] + pM1[0][1] * pM2[1][3] + pM1[0][2] * pM2[2][3] + pM1[0][3] * pM2[3][3];
	pOut[1][0] = pM1[1][0] * pM2[0][0] + pM1[1][1] * pM2[1][0] + pM1[1][2] * pM2[2][0] + pM1[1][3] * pM2[3][0];
	pOut[1][1] = pM1[1][0] * pM2[0][1] + pM1[1][1] * pM2[1][1] + pM1[1][2] * pM2[2][1] + pM1[1][3] * pM2[3][1];
	pOut[1][2] = pM1[1][0] * pM2[0][2] + pM1[1][1] * pM2[1][2] + pM1[1][2] * pM2[2][2] + pM1[1][3] * pM2[3][2];
	pOut[1][3] = pM1[1][0] * pM2[0][3] + pM1[1][1] * pM2[1][3] + pM1[1][2] * pM2[2][3] + pM1[1][3] * pM2[3][3];
	pOut[2][0] = pM1[2][0] * pM2[0][0] + pM1[2][1] * pM2[1][0] + pM1[2][2] * pM2[2][0] + pM1[2][3] * pM2[3][0];
	pOut[2][1] = pM1[2][0] * pM2[0][1] + pM1[2][1] * pM2[1][1] + pM1[2][2] * pM2[2][1] + pM1[2][3] * pM2[3][1];
	pOut[2][2] = pM1[2][0] * pM2[0][2] + pM1[2][1] * pM2[1][2] + pM1[2][2] * pM2[2][2] + pM1[2][3] * pM2[3][2];
	pOut[2][3] = pM1[2][0] * pM2[0][3] + pM1[2][1] * pM2[1][3] + pM1[2][2] * pM2[2][3] + pM1[2][3] * pM2[3][3];
	pOut[3][0] = pM1[3][0] * pM2[0][0] + pM1[3][1] * pM2[1][0] + pM1[3][2] * pM2[2][0] + pM1[3][3] * pM2[3][0];
	pOut[3][1] = pM1[3][0] * pM2[0][1] + pM1[3][1] * pM2[1][1] + pM1[3][2] * pM2[2][1] + pM1[3][3] * pM2[3][1];
	pOut[3][2] = pM1[3][0] * pM2[0][2] + pM1[3][1] * pM2[1][2] + pM1[3][2] * pM2[2][2] + pM1[3][3] * pM2[3][2];
	pOut[3][3] = pM1[3][0] * pM2[0][3] + pM1[3][1] * pM2[1][3] + pM1[3][2] * pM2[2][3] + pM1[3][3] * pM2[3][3];

	return pOut;
}



FMatrix FTransform::ToMatrixWithScale()
{
	FMatrix OutMatrix = {};

	OutMatrix[3][0] = Translation.x;
	OutMatrix[3][1] = Translation.y;
	OutMatrix[3][2] = Translation.z;

	float x2 = Rotation.x + Rotation.x;
	float y2 = Rotation.y + Rotation.y;
	float z2 = Rotation.z + Rotation.z;
	{
		float xx2 = Rotation.x * x2;
		float yy2 = Rotation.y * y2;
		float zz2 = Rotation.z * z2;
		OutMatrix[0][0] = (1.0f - (yy2 + zz2)) * Scale3D.x;
		OutMatrix[1][1] = (1.0f - (xx2 + zz2)) * Scale3D.y;
		OutMatrix[2][2] = (1.0f - (xx2 + yy2)) * Scale3D.z;
	}
	{
		float yz2 = Rotation.y * z2;
		float wx2 = Rotation.w * x2;

		OutMatrix[2][1] = (yz2 - wx2) * Scale3D.z;
		OutMatrix[1][2] = (yz2 + wx2) * Scale3D.y;
	}
	{
		float xy2 = Rotation.x * y2;
		float wz2 = Rotation.w * z2;

		OutMatrix[1][0] = (xy2 - wz2) * Scale3D.y;
		OutMatrix[0][1] = (xy2 + wz2) * Scale3D.x;
	}
	{
		float xz2 = Rotation.x * z2;
		float wy2 = Rotation.w * y2;

		OutMatrix[2][0] = (xz2 + wy2) * Scale3D.z;
		OutMatrix[0][2] = (xz2 - wy2) * Scale3D.x;
	}

	OutMatrix[0][3] = 0.0f;
	OutMatrix[1][3] = 0.0f;
	OutMatrix[2][3] = 0.0f;
	OutMatrix[3][3] = 1.0f;

	return OutMatrix;
}

```

`EFTViloresiSockServer/EFT-Viloresi/math.hpp`:

```hpp
#pragma once
// Libraries
#include <math.h>
#include <assert.h>

class FVector;
class FRotator;
class Vector3;

float DegToRad(float x);
float RadToDeg(float x);
float DistancePointToLine(FVector Point, FVector LineOrigin, FVector Dir);



// Class Vector2
// This class represents a 2D vector.
class Vector2 {

public:

    // -------------------- Attributes -------------------- //

    // Components of the vector
    float x, y;


    // -------------------- Methods -------------------- //

    // Constructor
    Vector2(float x = 0, float y = 0) : x(x), y(y) {}

    // Constructor
    Vector2(const Vector2& vector) : x(vector.x), y(vector.y) {}

    // + operator
    Vector2 operator+(const Vector2& v) const {
        return Vector2(x + v.x, y + v.y);
    }

    // += operator
    Vector2& operator+=(const Vector2& v) {
        x += v.x; y += v.y;
        return *this;
    }

    // - operator
    Vector2 operator-(const Vector2& v) const {
        return Vector2(x - v.x, y - v.y);
    }

    // -= operator
    Vector2& operator-=(const Vector2& v) {
        x -= v.x; y -= v.y;
        return *this;
    }

    // = operator
    Vector2& operator=(const Vector2& vector) {
        if (&vector != this) {
            x = vector.x;
            y = vector.y;
        }
        return *this;
    }

    // == operator
    bool operator==(const Vector2& v) const {
        return x == v.x && y == v.y;
    }

    // * operator
    Vector2 operator*(float f) const {
        return Vector2(f * x, f * y);
    }

    // *= operator
    Vector2& operator*=(float f) {
        x *= f; y *= f;
        return *this;
    }

    // / operator
    Vector2 operator/(float f) const {
        assert(f != 0);
        float inv = 1.f / f;
        return Vector2(x * inv, y * inv);
    }

    // /= operator
    Vector2& operator/=(float f) {
        assert(f != 0);
        float inv = 1.f / f;
        x *= inv; y *= inv;
        return *this;
    }

    // - operator
    Vector2 operator-() const {
        return Vector2(-x, -y);
    }

    // [] operator
    float& operator[](int i) {
        assert(i >= 0 && i <= 1);
        switch (i) {
        case 0: return x;
        case 1: return y;
        }
        return y;
    }

    // Normalize the vector and return it
    Vector2 normalize() {
        float l = length();
        assert(l > 0);
        x /= l;
        y /= l;
        return *this;
    }

    // Clamp the vector values between 0 and 1
    Vector2 clamp01() {
        if (x > 1.f) x = 1.f;
        else if (x < 0.f) x = 0.f;
        if (y > 1.f) y = 1.f;
        else if (y < 0.f) y = 0.f;
        return *this;
    }

    // Return the squared length of the vector
    float lengthSquared() const { return x * x + y * y; }

    // Return the length of the vector
    float length() const { return sqrt(lengthSquared()); }
};


//Vector3
class Vector3
{
public:
    Vector3() : x(0.f), y(0.f), z(0.f)
    {

    }

    Vector3(float _x, float _y, float _z) : x(_x), y(_y), z(_z)
    {

    }
    ~Vector3()
    {

    }

    float x;
    float y;
    float z;

    float Dot(Vector3 v);
    Vector3 operator+(Vector3 v);
    Vector3 operator-(Vector3 v);
    float Distance(Vector3 v);
};

class Vector4
{
public:
    float x, z, y;

    Vector4();
    Vector4(float x, float y, float z, float w);
    Vector4(float x, float y, float z);
    Vector4(float* x, float* y, float* z, float* w);
    ~Vector4() {}

    Vector4 operator= (const Vector4& v);
    const Vector4 operator* (const float& scalar) const;
    const Vector4 operator+ (const Vector4& v) const;

    //inline void show() { std::cout << this->x << " " << this->y << " " << this->z << " " << this->w << std::endl; }

private:

    float w;

    // only to allow do that: m(0) = Vector4(1,1,1,1) //
    float* px;
    float* py;
    float* pz;
    float* pw;

    bool pointer;  // to check what constructor was called //
};

class FVector
{
public:
    float x, z, y;

    FVector();
    FVector(float x, float y, float z);
    FVector(const FVector& other);

    FVector operator+ (const FVector& other) const;
    FVector operator- (const FVector& other) const;
    FVector operator* (const float other) const;
    float operator* (const FVector& other) const;

    bool operator == (const FVector& other) const;
    bool operator != (const FVector& other) const;

    FVector& operator= (const FVector& other);
    FVector& operator+= (const FVector& other);
    FVector& operator-= (const FVector& other);
    FVector& operator*= (const float other);

    float& operator[](size_t i);
    const float& operator[](size_t i) const;

    float GetLength() const;
    float Distance(FVector v);
    float Distance2(FVector a, FVector b);
    float GetMagnitudeSqr();

    FRotator VectorAngles() const;
};

class FMatrix
{
public:
    FMatrix() : m{
        { 0.f, 0.f, 0.f, 0.f },
        { 0.f, 0.f, 0.f, 0.f },
        { 0.f, 0.f, 0.f, 0.f },
        { 0.f, 0.f, 0.f, 0.f } }
    {
    }

    FMatrix(const FMatrix&) = default;


    float* operator[](size_t i) { return m[i]; }
    const float* operator[](size_t i) const { return m[i]; }


    FVector operator*(const FVector& vec);
    FMatrix operator*(const FMatrix& other);
    float m[4][4];
};

class FRotator
{
public:
    float yaw;
    float pitch;
    float roll;

    FRotator();
    FRotator(float pitch, float yaw, float roll);
    FRotator(const FRotator& other);

    void ToSourceAngles();
    void ToUnityAngles();
    void Normalize();
    FVector AngleVector();
    void AngleVectors(FVector* x, FVector* y, FVector* z);
};

struct FQuat
{
    float x;
    float y;
    float z;
    float w;

    FQuat operator*(const FQuat& other);
};

struct FTransform
{
public:
    FQuat Rotation;
    FVector Translation;
private:
    float pad0;
public:
    FVector Scale3D;
private:
    float pad1;

public:
    FMatrix ToMatrixWithScale();

};

struct FBoxSphereBounds
{
    FVector	Origin;
    FVector BoxExtent;
    float SphereRadius;
};

```

`EFTViloresiSockServer/EFT-Viloresi/utils.h`:

```h
#pragma once
#include <TlHelp32.h>
#include <iostream>
#include <vector>


int GetProcessIdByName(std::wstring targetProcessName) {
	std::vector<DWORD> pids;
	//std::wstring targetProcessName = PROCESS_NAME_TOGETPID;

	HANDLE snap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); //all processes

	PROCESSENTRY32W entry; //current process
	entry.dwSize = sizeof entry;

	if (!Process32FirstW(snap, &entry)) { //start with the first in snapshot
		return 0;
	}

	do {
		if (std::wstring(entry.szExeFile) == targetProcessName) {
			pids.emplace_back(entry.th32ProcessID); //name matches; add to list
		}
	} while (Process32NextW(snap, &entry)); //keep going until end of snapshot

	for (int i(0); i < pids.size(); ++i) {
		//std::cout << "pids:" << pids[i] << std::endl;
		return pids[i];

	}
	return 0;
}


```

`EFTViloresiSockServer/EFT-ViloresiSockServer.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31911.196
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "EFT-Viloresi", "EFT-Viloresi\EFT-Viloresi.vcxproj", "{4E76EA4E-885F-46F3-B5AA-617F51565D65}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{4E76EA4E-885F-46F3-B5AA-617F51565D65}.Debug|x64.ActiveCfg = Debug|x64
		{4E76EA4E-885F-46F3-B5AA-617F51565D65}.Debug|x64.Build.0 = Debug|x64
		{4E76EA4E-885F-46F3-B5AA-617F51565D65}.Debug|x86.ActiveCfg = Debug|Win32
		{4E76EA4E-885F-46F3-B5AA-617F51565D65}.Debug|x86.Build.0 = Debug|Win32
		{4E76EA4E-885F-46F3-B5AA-617F51565D65}.Release|x64.ActiveCfg = Release|x64
		{4E76EA4E-885F-46F3-B5AA-617F51565D65}.Release|x64.Build.0 = Release|x64
		{4E76EA4E-885F-46F3-B5AA-617F51565D65}.Release|x86.ActiveCfg = Release|Win32
		{4E76EA4E-885F-46F3-B5AA-617F51565D65}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {E4449E18-78F4-4CF6-8F4D-DE1612F9EFCF}
	EndGlobalSection
EndGlobal

```

`EftDriver/Driver/ARM/Release/Driver.log`:

```log
C:\Program Files\Microsoft Visual Studio\2022\Community\MSBuild\Microsoft\VC\v170\Microsoft.CppBuild.targets(440,5): error MSB8020: The build tools for WindowsKernelModeDriver10.0 (Platform Toolset = 'WindowsKernelModeDriver10.0') cannot be found. To build using the WindowsKernelModeDriver10.0 build tools, please install WindowsKernelModeDriver10.0 build tools.  Alternatively, you may upgrade to the current Visual Studio tools by selecting the Project menu or right-click the solution, and then selecting "Retarget solution".

```

`EftDriver/Driver/ARM64/Release/Driver.log`:

```log
C:\Program Files\Microsoft Visual Studio\2022\Community\MSBuild\Microsoft\VC\v170\Microsoft.CppBuild.targets(440,5): error MSB8020: The build tools for WindowsKernelModeDriver10.0 (Platform Toolset = 'WindowsKernelModeDriver10.0') cannot be found. To build using the WindowsKernelModeDriver10.0 build tools, please install WindowsKernelModeDriver10.0 build tools.  Alternatively, you may upgrade to the current Visual Studio tools by selecting the Project menu or right-click the solution, and then selecting "Retarget solution".

```

`EftDriver/Driver/Driver.c`:

```c
/* Cheat that uses a driver for reading / writing virtual memory,
instead of using Win32API Functions. Written By Zer0Mem0ry,
https://www.youtube.com/watch?v=sJdBtPosWQs */




#define IO_READorWRITE_REQUEST CTL_CODE(FILE_DEVICE_UNKNOWN, 0x0341, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define IO_GET_UNITYPLAYER CTL_CODE(FILE_DEVICE_UNKNOWN, 0x0342, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#include "ntos.h"
#include "stdint.h"
#include "ntstrsafe.h"
#include "imports.h"
DWORD64  ClientAddress, PID;
PEPROCESS process;
UNICODE_STRING dev, dos; // Driver registry paths
UNICODE_STRING DLLName;
PDEVICE_OBJECT pDeviceObject; // our driver object




uint64_t RDrvGetModuleEntry(PEPROCESS Process, UNICODE_STRING
	module_name)
{
	if (!Process) return 0;
	PPEB peb = PsGetProcessPeb(Process);

	if (!peb) {
		return 0;
	}
	KAPC_STATE state;
	KeStackAttachProcess(Process, &state);
	PPEB_LDR_DATA ldr = peb->Ldr;

	if (!ldr)
	{
		KeUnstackDetachProcess(&state);
		return 0; // failed
	}

	for (PLIST_ENTRY listEntry = (PLIST_ENTRY)ldr->ModuleListLoadOrder.Flink;
		listEntry != &ldr->ModuleListLoadOrder;
		listEntry = (PLIST_ENTRY)listEntry->Flink)
	{

		PLDR_DATA_TABLE_ENTRY ldrEntry = CONTAINING_RECORD(listEntry, LDR_DATA_TABLE_ENTRY, InLoadOrderModuleList);
		if (RtlCompareUnicodeString(&ldrEntry->BaseDllName, &module_name, TRUE) ==
			0) {
			ULONG64 baseAddr = (ULONG64)ldrEntry->DllBase;
			KeUnstackDetachProcess(&state);
			return baseAddr;
		}

	}

	KeUnstackDetachProcess(&state);

	return 0;
}



typedef struct _KERNEL_GETUNITYPLAYER_REQUEST
{
	uint32_t gameProcessId; //gameprocessId
	uint32_t destProcessId; //usermode hack process id
	uint64_t sourceAddress; // usermode hack buffer

} KERNEL_GETUNITYPLAYER_REQUEST, * PKERNEL_GETUNITYPLAYER_REQUEST;
typedef struct _KERNEL_READorWRITE_REQUEST
{
	uint32_t sourceProcessId;
	uint32_t destProcessId;
	uint64_t sourceAddress;
	uint64_t destAddress;
	uint32_t Size;

} KERNEL_READorWRITE_REQUEST, * PKERNEL_READorWRITE_REQUEST;

NTSTATUS CloseCall(PDEVICE_OBJECT DeviceObject, PIRP irp);
NTSTATUS CreateCall(PDEVICE_OBJECT DeviceObject, PIRP irp);

NTSTATUS KeWriteVirtualMemory(PEPROCESS sourceProcess, PVOID SourceAddress, PEPROCESS destProcess, PVOID TargetAddress, SIZE_T Size)
{
	PSIZE_T Bytes;
	if (NT_SUCCESS(MmCopyVirtualMemory(sourceProcess, SourceAddress, destProcess,
		TargetAddress, Size, KernelMode, &Bytes)))
		return STATUS_SUCCESS;
	else
		return STATUS_ACCESS_DENIED;
}

NTSTATUS IoControl(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
	NTSTATUS Status;
	ULONG BytesIO = 0;
	PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(Irp);
	ULONG ControlCode = stack->Parameters.DeviceIoControl.IoControlCode;

	if (ControlCode == IO_READorWRITE_REQUEST)
	{
		PKERNEL_READorWRITE_REQUEST WriteInput = (PKERNEL_READorWRITE_REQUEST)Irp->AssociatedIrp.SystemBuffer;
		PEPROCESS sourceProcess, destProcess;
		NTSTATUS status;
		PsLookupProcessByProcessId(WriteInput->destProcessId, &destProcess);
		PsLookupProcessByProcessId(WriteInput->sourceProcessId, &sourceProcess);
		status = KeWriteVirtualMemory(sourceProcess, WriteInput->sourceAddress, destProcess, WriteInput->destAddress, WriteInput->Size);
		Status = STATUS_SUCCESS;
		BytesIO = sizeof(KERNEL_READorWRITE_REQUEST);
	}
	else if (ControlCode == IO_GET_UNITYPLAYER)
	{

		PKERNEL_GETUNITYPLAYER_REQUEST GetUnityInput = (PKERNEL_GETUNITYPLAYER_REQUEST)Irp->AssociatedIrp.SystemBuffer;
		PEPROCESS gameProcess, destProcess;
		NTSTATUS status;
		PsLookupProcessByProcessId(GetUnityInput->destProcessId, &destProcess);
		PsLookupProcessByProcessId(GetUnityInput->gameProcessId, &gameProcess);
		
		RtlInitUnicodeString(&DLLName, L"UnityPlayer.dll");
		uint64_t base_address = RDrvGetModuleEntry(gameProcess, DLLName);
		KeWriteVirtualMemory(PsGetCurrentProcess(), &base_address, destProcess, GetUnityInput->sourceAddress, sizeof(uint64_t));
	}
	else
	{
		Status = STATUS_INVALID_PARAMETER;
		BytesIO = 0;
	}
	Irp->IoStatus.Status = Status;
	Irp->IoStatus.Information = BytesIO;
	IoCompleteRequest(Irp, IO_NO_INCREMENT);
	return Status;
}

NTSTATUS DriverInitialize(PDRIVER_OBJECT pDriverObject,
	PUNICODE_STRING pRegistryPath)
{
	RtlInitUnicodeString(&dos, L"\\DosDevices\\Fafaki");
	RtlInitUnicodeString(&dev, L"\\Device\\Fafaki");
	
	IoCreateDevice(pDriverObject, 0, &dev, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &pDeviceObject);
	IoCreateSymbolicLink(&dos, &dev);
	pDriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = IoControl;
	pDriverObject->MajorFunction[IRP_MJ_CLOSE] = CloseCall;
	pDriverObject->MajorFunction[IRP_MJ_CREATE] = CreateCall;
	pDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
	pDeviceObject->Flags |= DO_DIRECT_IO;
	return STATUS_SUCCESS;
}
void createdummydevice()
{
	UNICODE_STRING drv_name;
	RtlInitUnicodeString(&drv_name, L"\\Device\\ddmas");
	IoCreateDriver(&drv_name, &DriverInitialize);
}
NTSTATUS DriverEntry(PDRIVER_OBJECT pDriverObject, PUNICODE_STRING RegistryPath) {
	HANDLE out;
	NTSTATUS result = PsCreateSystemThread(&out, GENERIC_ALL, NULL, NULL, NULL, createdummydevice, NULL);
	return result;
}
NTSTATUS CreateCall(PDEVICE_OBJECT DeviceObject, PIRP irp)
{
	irp->IoStatus.Status = STATUS_SUCCESS;
	irp->IoStatus.Information = 0;

	IoCompleteRequest(irp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}
NTSTATUS CloseCall(PDEVICE_OBJECT DeviceObject, PIRP irp)
{
	irp->IoStatus.Status = STATUS_SUCCESS;
	irp->IoStatus.Information = 0;

	IoCompleteRequest(irp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}

```

`EftDriver/Driver/Driver.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Driver.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="imports.h" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{23F27013-5E01-4B4D-88D4-932C0D775DAA}</ProjectGuid>
    <TemplateGuid>{497e31cb-056b-4f31-abb8-447fd55ee5a5}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>Driver</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.22000.0</WindowsTargetPlatformVersion>
    <ProjectName>EftDriver</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <SpectreMitigation>false</SpectreMitigation>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <OutDir>..\Release</OutDir>
    <TimeStampServer />
    <ApiValidator_Enable>false</ApiValidator_Enable>
    <EnableInf2cat>false</EnableInf2cat>
    <PreBuildEventUseInBuild>false</PreBuildEventUseInBuild>
    <PreLinkEventUseInBuild>false</PreLinkEventUseInBuild>
    <PostBuildEventUseInBuild>false</PostBuildEventUseInBuild>
    <TargetName>EftDriver</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WppEnabled>false</WppEnabled>
      <WppRecorderEnabled>false</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
      <TreatWarningAsError>false</TreatWarningAsError>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <DebugInformationFormat>
      </DebugInformationFormat>
      <UseFullPaths>false</UseFullPaths>
      <WppMinimalRebuildFromTracking>false</WppMinimalRebuildFromTracking>
      <Optimization>MinSpace</Optimization>
      <ProgramDataBaseFileName>avast.pdb</ProgramDataBaseFileName>
    </ClCompile>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <ProgramDatabaseFile>
      </ProgramDatabaseFile>
      <GenerateWindowsMetadata>false</GenerateWindowsMetadata>
      <ProfileGuidedDatabase>0</ProfileGuidedDatabase>
      <Profile>false</Profile>
    </Link>
    <MessageCompile>
      <GeneratedHeaderPath>false</GeneratedHeaderPath>
    </MessageCompile>
    <MessageCompile>
      <GeneratedRCAndMessagesPath>false</GeneratedRCAndMessagesPath>
    </MessageCompile>
    <Ctrpp>
      <GenerateHeaderFileForCounter>false</GenerateHeaderFileForCounter>
      <GenerateHeaderFileForProvider>false</GenerateHeaderFileForProvider>
    </Ctrpp>
    <ProjectReference>
      <LinkLibraryDependencies>false</LinkLibraryDependencies>
    </ProjectReference>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`EftDriver/Driver/Driver.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="Driver.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="imports.h" />
  </ItemGroup>
</Project>
```

`EftDriver/Driver/Driver.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <SignMode>Off</SignMode>
    <UmdfVLogLevel>1</UmdfVLogLevel>
  </PropertyGroup>
</Project>
```

`EftDriver/Driver/Release/Driver.log`:

```log
C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\MSBuild\Microsoft\VC\v160\Microsoft.CppBuild.targets(382,5): error MSB8020: The build tools for WindowsKernelModeDriver10.0 (Platform Toolset = 'WindowsKernelModeDriver10.0') cannot be found. To build using the WindowsKernelModeDriver10.0 build tools, please install WindowsKernelModeDriver10.0 build tools.  Alternatively, you may upgrade to the current Visual Studio tools by selecting the Project menu or right-click the solution, and then selecting "Retarget solution".

```

`EftDriver/Driver/imports.h`:

```h
#pragma once
#include <ntddk.h>
#include <intrin.h>
#include <stdlib.h>
#include <Ntstrsafe.h>
#include <windef.h>

typedef enum _SYSTEM_INFORMATION_CLASS
{
	SystemBasicInformation = 0x0,
	SystemProcessorInformation = 0x1,
	SystemPerformanceInformation = 0x2,
	SystemTimeOfDayInformation = 0x3,
	SystemPathInformation = 0x4,
	SystemProcessInformation = 0x5,
	SystemCallCountInformation = 0x6,
	SystemDeviceInformation = 0x7,
	SystemProcessorPerformanceInformation = 0x8,
	SystemFlagsInformation = 0x9,
	SystemCallTimeInformation = 0xa,
	SystemModuleInformation = 0xb,
	SystemLocksInformation = 0xc,
	SystemStackTraceInformation = 0xd,
	SystemPagedPoolInformation = 0xe,
	SystemNonPagedPoolInformation = 0xf,
	SystemHandleInformation = 0x10,
	SystemObjectInformation = 0x11,
	SystemPageFileInformation = 0x12,
	SystemVdmInstemulInformation = 0x13,
	SystemVdmBopInformation = 0x14,
	SystemFileCacheInformation = 0x15,
	SystemPoolTagInformation = 0x16,
	SystemInterruptInformation = 0x17,
	SystemDpcBehaviorInformation = 0x18,
	SystemFullMemoryInformation = 0x19,
	SystemLoadGdiDriverInformation = 0x1a,
	SystemUnloadGdiDriverInformation = 0x1b,
	SystemTimeAdjustmentInformation = 0x1c,
	SystemSummaryMemoryInformation = 0x1d,
	SystemMirrorMemoryInformation = 0x1e,
	SystemPerformanceTraceInformation = 0x1f,
	SystemObsolete0 = 0x20,
	SystemExceptionInformation = 0x21,
	SystemCrashDumpStateInformation = 0x22,
	SystemKernelDebuggerInformation = 0x23,
	SystemContextSwitchInformation = 0x24,
	SystemRegistryQuotaInformation = 0x25,
	SystemExtendServiceTableInformation = 0x26,
	SystemPrioritySeperation = 0x27,
	SystemVerifierAddDriverInformation = 0x28,
	SystemVerifierRemoveDriverInformation = 0x29,
	SystemProcessorIdleInformation = 0x2a,
	SystemLegacyDriverInformation = 0x2b,
	SystemCurrentTimeZoneInformation = 0x2c,
	SystemLookasideInformation = 0x2d,
	SystemTimeSlipNotification = 0x2e,
	SystemSessionCreate = 0x2f,
	SystemSessionDetach = 0x30,
	SystemSessionInformation = 0x31,
	SystemRangeStartInformation = 0x32,
	SystemVerifierInformation = 0x33,
	SystemVerifierThunkExtend = 0x34,
	SystemSessionProcessInformation = 0x35,
	SystemLoadGdiDriverInSystemSpace = 0x36,
	SystemNumaProcessorMap = 0x37,
	SystemPrefetcherInformation = 0x38,
	SystemExtendedProcessInformation = 0x39,
	SystemRecommendedSharedDataAlignment = 0x3a,
	SystemComPlusPackage = 0x3b,
	SystemNumaAvailableMemory = 0x3c,
	SystemProcessorPowerInformation = 0x3d,
	SystemEmulationBasicInformation = 0x3e,
	SystemEmulationProcessorInformation = 0x3f,
	SystemExtendedHandleInformation = 0x40,
	SystemLostDelayedWriteInformation = 0x41,
	SystemBigPoolInformation = 0x42,
	SystemSessionPoolTagInformation = 0x43,
	SystemSessionMappedViewInformation = 0x44,
	SystemHotpatchInformation = 0x45,
	SystemObjectSecurityMode = 0x46,
	SystemWatchdogTimerHandler = 0x47,
	SystemWatchdogTimerInformation = 0x48,
	SystemLogicalProcessorInformation = 0x49,
	SystemWow64SharedInformationObsolete = 0x4a,
	SystemRegisterFirmwareTableInformationHandler = 0x4b,
	SystemFirmwareTableInformation = 0x4c,
	SystemModuleInformationEx = 0x4d,
	SystemVerifierTriageInformation = 0x4e,
	SystemSuperfetchInformation = 0x4f,
	SystemMemoryListInformation = 0x50,
	SystemFileCacheInformationEx = 0x51,
	SystemThreadPriorityClientIdInformation = 0x52,
	SystemProcessorIdleCycleTimeInformation = 0x53,
	SystemVerifierCancellationInformation = 0x54,
	SystemProcessorPowerInformationEx = 0x55,
	SystemRefTraceInformation = 0x56,
	SystemSpecialPoolInformation = 0x57,
	SystemProcessIdInformation = 0x58,
	SystemErrorPortInformation = 0x59,
	SystemBootEnvironmentInformation = 0x5a,
	SystemHypervisorInformation = 0x5b,
	SystemVerifierInformationEx = 0x5c,
	SystemTimeZoneInformation = 0x5d,
	SystemImageFileExecutionOptionsInformation = 0x5e,
	SystemCoverageInformation = 0x5f,
	SystemPrefetchPatchInformation = 0x60,
	SystemVerifierFaultsInformation = 0x61,
	SystemSystemPartitionInformation = 0x62,
	SystemSystemDiskInformation = 0x63,
	SystemProcessorPerformanceDistribution = 0x64,
	SystemNumaProximityNodeInformation = 0x65,
	SystemDynamicTimeZoneInformation = 0x66,
	SystemCodeIntegrityInformation = 0x67,
	SystemProcessorMicrocodeUpdateInformation = 0x68,
	SystemProcessorBrandString = 0x69,
	SystemVirtualAddressInformation = 0x6a,
	SystemLogicalProcessorAndGroupInformation = 0x6b,
	SystemProcessorCycleTimeInformation = 0x6c,
	SystemStoreInformation = 0x6d,
	SystemRegistryAppendString = 0x6e,
	SystemAitSamplingValue = 0x6f,
	SystemVhdBootInformation = 0x70,
	SystemCpuQuotaInformation = 0x71,
	SystemNativeBasicInformation = 0x72,
	SystemErrorPortTimeouts = 0x73,
	SystemLowPriorityIoInformation = 0x74,
	SystemBootEntropyInformation = 0x75,
	SystemVerifierCountersInformation = 0x76,
	SystemPagedPoolInformationEx = 0x77,
	SystemSystemPtesInformationEx = 0x78,
	SystemNodeDistanceInformation = 0x79,
	SystemAcpiAuditInformation = 0x7a,
	SystemBasicPerformanceInformation = 0x7b,
	SystemQueryPerformanceCounterInformation = 0x7c,
	SystemSessionBigPoolInformation = 0x7d,
	SystemBootGraphicsInformation = 0x7e,
	SystemScrubPhysicalMemoryInformation = 0x7f,
	SystemBadPageInformation = 0x80,
	SystemProcessorProfileControlArea = 0x81,
	SystemCombinePhysicalMemoryInformation = 0x82,
	SystemEntropyInterruptTimingInformation = 0x83,
	SystemConsoleInformation = 0x84,
	SystemPlatformBinaryInformation = 0x85,
	SystemThrottleNotificationInformation = 0x86,
	SystemHypervisorProcessorCountInformation = 0x87,
	SystemDeviceDataInformation = 0x88,
	SystemDeviceDataEnumerationInformation = 0x89,
	SystemMemoryTopologyInformation = 0x8a,
	SystemMemoryChannelInformation = 0x8b,
	SystemBootLogoInformation = 0x8c,
	SystemProcessorPerformanceInformationEx = 0x8d,
	SystemSpare0 = 0x8e,
	SystemSecureBootPolicyInformation = 0x8f,
	SystemPageFileInformationEx = 0x90,
	SystemSecureBootInformation = 0x91,
	SystemEntropyInterruptTimingRawInformation = 0x92,
	SystemPortableWorkspaceEfiLauncherInformation = 0x93,
	SystemFullProcessInformation = 0x94,
	SystemKernelDebuggerInformationEx = 0x95,
	SystemBootMetadataInformation = 0x96,
	SystemSoftRebootInformation = 0x97,
	SystemElamCertificateInformation = 0x98,
	SystemOfflineDumpConfigInformation = 0x99,
	SystemProcessorFeaturesInformation = 0x9a,
	SystemRegistryReconciliationInformation = 0x9b,
	MaxSystemInfoClass = 0x9c,
} SYSTEM_INFORMATION_CLASS;

typedef struct _DYNDATA
{
	UINT64 CallbackListOffset;
}DYNDATA, * PDYNDATA;

typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
	HANDLE Section;         // Not filled in
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR  FullPathName[MAXIMUM_FILENAME_LENGTH];
} RTL_PROCESS_MODULE_INFORMATION, * PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES
{
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, * PRTL_PROCESS_MODULES;

typedef struct _CALLBACK_ENTRY {
	UINT16 Version; // 0x0
	UINT16 OperationRegistrationCount; // 0x2
	UINT32 unk1; // 0x4
	PVOID RegistrationContext; // 0x8
	UNICODE_STRING Altitude; // 0x10
} CALLBACK_ENTRY, * PCALLBACK_ENTRY;

typedef struct _OBJECT_CALLBACK_ENTRY {
	LIST_ENTRY CallbackList;
	OB_OPERATION Operations;
	ULONG Active;
	/*OB_HANDLE*/ PCALLBACK_ENTRY CallbackEntry;
	POBJECT_TYPE ObjectType;
	POB_PRE_OPERATION_CALLBACK  PreOperation;
	POB_POST_OPERATION_CALLBACK PostOperation;
} OBJECT_CALLBACK_ENTRY, * POBJECT_CALLBACK_ENTRY;

struct REQUEST_STRUCT
{
	PIO_COMPLETION_ROUTINE OldRoutine;
	PVOID OldContext;
	ULONG OutputBufferLength;
	PVOID SystemBuffer;
};

typedef struct _PS_CALLBACK_ENTRY
{
	PVOID* Callback;
	LARGE_INTEGER* Fillz;
} PS_CALLBACK_ENTRY, * PPS_CALLBACK_ENTRY;

typedef struct _OB_CALLBACK_ADDRESSES
{
	UINT64* pProcPreCallback, * pProcPostCallback;
	UINT64* pThreadPreCallback, * pThreadPostCallback;
	UINT64 OrigProcPre, OrigProcPost;
	UINT64 OrigThreadPre, OrigThreadPost;
}OB_CALLBACK_ADDRESSES, * POB_CALLBACK_ADDRESSES;

typedef struct _IDINFO
{
	USHORT	wGenConfig;
	USHORT	wNumCyls;
	USHORT	wReserved;
	USHORT	wNumHeads;
	USHORT	wBytesPerTrack;
	USHORT	wBytesPerSector;
	USHORT	wNumSectorsPerTrack;
	USHORT	wVendorUnique[3];
	CHAR	sSerialNumber[20];
	USHORT	wBufferType;
	USHORT	wBufferSize;
	USHORT	wECCSize;
	CHAR	sFirmwareRev[8];
	CHAR	sModelNumber[40];
	USHORT	wMoreVendorUnique;
	USHORT	wDoubleWordIO;
	struct {
		USHORT	Reserved : 8;
		USHORT	DMA : 1;
		USHORT	LBA : 1;
		USHORT	DisIORDY : 1;
		USHORT	IORDY : 1;
		USHORT	SoftReset : 1;
		USHORT	Overlap : 1;
		USHORT	Queue : 1;
		USHORT	InlDMA : 1;
	} wCapabilities;
	USHORT	wReserved1;
	USHORT	wPIOTiming;
	USHORT	wDMATiming;
	struct {
		USHORT	CHSNumber : 1;
		USHORT	CycleNumber : 1;
		USHORT	UnltraDMA : 1;
		USHORT	Reserved : 13;
	} wFieldValidity;
	USHORT	wNumCurCyls;
	USHORT	wNumCurHeads;
	USHORT	wNumCurSectorsPerTrack;
	USHORT	wCurSectorsLow;
	USHORT	wCurSectorsHigh;
	struct {
		USHORT	CurNumber : 8;
		USHORT	Multi : 1;
		USHORT	Reserved : 7;
	} wMultSectorStuff;
	ULONG	dwTotalSectors;
	USHORT	wSingleWordDMA;
	struct {
		USHORT	Mode0 : 1;
		USHORT	Mode1 : 1;
		USHORT	Mode2 : 1;
		USHORT	Reserved1 : 5;
		USHORT	Mode0Sel : 1;
		USHORT	Mode1Sel : 1;
		USHORT	Mode2Sel : 1;
		USHORT	Reserved2 : 5;
	} wMultiWordDMA;
	struct {
		USHORT	AdvPOIModes : 8;
		USHORT	Reserved : 8;
	} wPIOCapacity;
	USHORT	wMinMultiWordDMACycle;
	USHORT	wRecMultiWordDMACycle;
	USHORT	wMinPIONoFlowCycle;
	USHORT	wMinPOIFlowCycle;
	USHORT	wReserved69[11];
	struct {
		USHORT	Reserved1 : 1;
		USHORT	ATA1 : 1;
		USHORT	ATA2 : 1;
		USHORT	ATA3 : 1;
		USHORT	ATA4 : 1;
		USHORT	ATA5 : 1;
		USHORT	ATA6 : 1;
		USHORT	ATA7 : 1;
		USHORT	ATA8 : 1;
		USHORT	ATA9 : 1;
		USHORT	ATA10 : 1;
		USHORT	ATA11 : 1;
		USHORT	ATA12 : 1;
		USHORT	ATA13 : 1;
		USHORT	ATA14 : 1;
		USHORT	Reserved2 : 1;
	} wMajorVersion;
	USHORT	wMinorVersion;
	USHORT	wReserved82[6];
	struct {
		USHORT	Mode0 : 1;
		USHORT	Mode1 : 1;
		USHORT	Mode2 : 1;
		USHORT	Mode3 : 1;
		USHORT	Mode4 : 1;
		USHORT	Mode5 : 1;
		USHORT	Mode6 : 1;
		USHORT	Mode7 : 1;
		USHORT	Mode0Sel : 1;
		USHORT	Mode1Sel : 1;
		USHORT	Mode2Sel : 1;
		USHORT	Mode3Sel : 1;
		USHORT	Mode4Sel : 1;
		USHORT	Mode5Sel : 1;
		USHORT	Mode6Sel : 1;
		USHORT	Mode7Sel : 1;
	} wUltraDMA;
	USHORT	wReserved89[167];
} IDINFO, * PIDINFO;

typedef struct _SYSTEM_MODULE   // Information Class 11
{
	ULONG_PTR Reserved[2];
	PVOID Base;
	ULONG Size;
	ULONG Flags;
	USHORT Index;
	USHORT Unknown;
	USHORT LoadCount;
	USHORT ModuleNameOffset;
	CHAR ImageName[256];
} SYSTEM_MODULE, * PSYSTEM_MODULE;

typedef struct _SYSTEM_MODULE_INFORMATION   // Information Class 11
{
	ULONG_PTR ulModuleCount;
	SYSTEM_MODULE Modules[1];
} SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;

struct piddbcache
{
	LIST_ENTRY		List;
	UNICODE_STRING	DriverName;
	ULONG			TimeDateStamp;
	NTSTATUS		LoadStatus;
	char			_0x0028[16]; // data from the shim engine, or uninitialized memory for custom drivers
};


typedef struct _PEB_LDR_DATA {
	ULONG Length;
	BOOLEAN Initialized;
	PVOID SsHandle;
	LIST_ENTRY ModuleListLoadOrder;
	LIST_ENTRY ModuleListMemoryOrder;
	LIST_ENTRY ModuleListInitOrder;
} PEB_LDR_DATA, * PPEB_LDR_DATA;

typedef struct _RTL_USER_PROCESS_PARAMETERS {
	BYTE Reserved1[16];
	PVOID Reserved2[10];
	UNICODE_STRING ImagePathName;
	UNICODE_STRING CommandLine;
} RTL_USER_PROCESS_PARAMETERS, * PRTL_USER_PROCESS_PARAMETERS;

typedef void(__stdcall* PPS_POST_PROCESS_INIT_ROUTINE)(void);

typedef struct _PEB {
	BYTE Reserved1[2];
	BYTE BeingDebugged;
	BYTE Reserved2[1];
	PVOID Reserved3[2];
	PPEB_LDR_DATA Ldr;
	PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
	PVOID Reserved4[3];
	PVOID AtlThunkSListPtr;
	PVOID Reserved5;
	ULONG Reserved6;
	PVOID Reserved7;
	ULONG Reserved8;
	ULONG AtlThunkSListPtr32;
	PVOID Reserved9[45];
	BYTE Reserved10[96];
	PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;
	BYTE Reserved11[128];
	PVOID Reserved12[1];
	ULONG SessionId;
} PEB, * PPEB;

typedef struct _LDR_DATA_TABLE_ENTRY {
	LIST_ENTRY InLoadOrderModuleList;
	LIST_ENTRY InMemoryOrderModuleList;
	LIST_ENTRY InInitializationOrderModuleList;
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;  // in bytes
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	ULONG Flags;  // LDR_*
	USHORT LoadCount;
	USHORT TlsIndex;
	LIST_ENTRY HashLinks;
	PVOID SectionPointer;
	ULONG CheckSum;
	ULONG TimeDateStamp;
} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;

```

`EftDriver/Driver/ntos.h`:

```h
#pragma once 

#include <ntdef.h>
#include <ntifs.h>
#include <ntddk.h>


typedef unsigned long long QWORD;

NTKERNELAPI
NTSTATUS
PsCreateSystemProcess(
	OUT PHANDLE ProcessHandle,
	IN ULONG DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes
);

typedef unsigned short WORD;


typedef
VOID
(*PCREATE_THREAD_NOTIFY_ROUTINE)(
	IN HANDLE ProcessId,
	IN HANDLE ThreadId,
	IN BOOLEAN Create
	);




typedef
VOID
(*PLOAD_IMAGE_NOTIFY_ROUTINE)(
	IN PUNICODE_STRING FullImageName,
	IN HANDLE ProcessId,                // pid into which image is being mapped 
	IN PIMAGE_INFO ImageInfo
	);


NTKERNELAPI
NTSTATUS
PsRemoveCreateThreadNotifyRoutine(
	IN PCREATE_THREAD_NOTIFY_ROUTINE NotifyRoutine
);

NTKERNELAPI
NTSTATUS
PsRemoveLoadImageNotifyRoutine(
	IN PLOAD_IMAGE_NOTIFY_ROUTINE NotifyRoutine
);

NTKERNELAPI
BOOLEAN
PsIsThreadTerminating(
	IN PETHREAD Thread
);

/*
typedef struct _CLIENT_ID {
HANDLE UniqueProcess;
HANDLE UniqueThread;
} CLIENT_ID;
typedef CLIENT_ID *PCLIENT_ID;
*/

NTKERNELAPI
NTSTATUS
PsLookupProcessThreadByCid(
	IN PCLIENT_ID Cid,
	OUT PEPROCESS *Process,
	OUT PETHREAD *Thread
);

// begin_ntosp 

NTKERNELAPI
NTSTATUS
PsLookupProcessByProcessId(
	IN HANDLE ProcessId,
	OUT PEPROCESS *Process
);

NTKERNELAPI
NTSTATUS
PsLookupThreadByThreadId(
	IN HANDLE ThreadId,
	OUT PETHREAD *Thread
);
NTKERNELAPI
PVOID
PsGetCurrentThreadStackLimit(
	VOID
);

NTKERNELAPI
PVOID
PsGetCurrentThreadStackBase(
	VOID
);

NTKERNELAPI
PVOID
PsGetProcessDebugPort(
	IN PEPROCESS Process
);

NTKERNELAPI
BOOLEAN
PsIsProcessBeingDebugged(
	IN PEPROCESS Process
);

NTKERNELAPI
HANDLE
PsGetProcessId(
	IN PEPROCESS Process
);

NTKERNELAPI
HANDLE
PsGetProcessInheritedFromUniqueProcessId(
	IN PEPROCESS Process
);

NTKERNELAPI
PPEB
PsGetProcessPeb(
	IN PEPROCESS Process
);

NTKERNELAPI
PVOID
PsGetThreadTeb(
	IN PETHREAD Thread
);

NTKERNELAPI                         //ntifs 
BOOLEAN                             //ntifs 
PsIsSystemThread(                   //ntifs 
	IN PETHREAD Thread                 //ntifs 
);                              //ntifs 

NTKERNELAPI
NTSTATUS
PsSetProcessWin32Process(
	IN PEPROCESS Process,
	IN PVOID Win32Process,
	IN PVOID PrevWin32Process
);

NTKERNELAPI
VOID
PsSetProcessWindowStation(
	OUT PEPROCESS Process,
	IN HANDLE Win32WindowStation
);

NTKERNELAPI
VOID
PsSetThreadWin32Thread(
	IN OUT PETHREAD Thread,
	IN PVOID Win32Thread,
	IN PVOID PrevWin32Thread
);



// Processor modes. 
// 
/*
typedef CCHAR KPROCESSOR_MODE;
typedef enum _MODE {
KernelMode,
UserMode,
MaximumMode
} MODE;
#define OBJECT_LOCK_COUNT 4
// Object Manager types
//
typedef struct _OBJECT_HANDLE_INFORMATION {
ULONG HandleAttributes;
ACCESS_MASK GrantedAccess;
} OBJECT_HANDLE_INFORMATION, *POBJECT_HANDLE_INFORMATION;
// end_ntddk end_wdm end_nthal end_ntifs
typedef struct _OBJECT_DUMP_CONTROL {
PVOID Stream;
ULONG Detail;
} OB_DUMP_CONTROL, *POB_DUMP_CONTROL;
typedef VOID (*OB_DUMP_METHOD)(
IN PVOID Object,
IN POB_DUMP_CONTROL Control OPTIONAL
);
typedef enum _OB_OPEN_REASON {
ObCreateHandle,
ObOpenHandle,
ObDuplicateHandle,
ObInheritHandle,
ObMaxOpenReason
} OB_OPEN_REASON;
typedef NTSTATUS (*OB_OPEN_METHOD)(
IN OB_OPEN_REASON OpenReason,
IN PEPROCESS Process OPTIONAL,
IN PVOID Object,
IN ACCESS_MASK GrantedAccess,
IN ULONG HandleCount
);
typedef BOOLEAN (*OB_OKAYTOCLOSE_METHOD)(
IN PEPROCESS Process OPTIONAL,
IN PVOID Object,
IN HANDLE Handle,
IN KPROCESSOR_MODE PreviousMode
);
typedef VOID (*OB_CLOSE_METHOD)(
IN PEPROCESS Process OPTIONAL,
IN PVOID Object,
IN ACCESS_MASK GrantedAccess,
IN ULONG_PTR ProcessHandleCount,
IN ULONG_PTR SystemHandleCount
);
typedef VOID (*OB_DELETE_METHOD)(
IN  PVOID   Object
);
typedef NTSTATUS (*OB_PARSE_METHOD)(
IN PVOID ParseObject,
IN PVOID ObjectType,
IN OUT PACCESS_STATE AccessState,
IN KPROCESSOR_MODE AccessMode,
IN ULONG Attributes,
IN OUT PUNICODE_STRING CompleteName,
IN OUT PUNICODE_STRING RemainingName,
IN OUT PVOID Context OPTIONAL,
IN PSECURITY_QUALITY_OF_SERVICE SecurityQos OPTIONAL,
OUT PVOID *Object
);
typedef NTSTATUS (*OB_SECURITY_METHOD)(
IN PVOID Object,
IN SECURITY_OPERATION_CODE OperationCode,
IN PSECURITY_INFORMATION SecurityInformation,
IN OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
IN OUT PULONG CapturedLength,
IN OUT PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
IN POOL_TYPE PoolType,
IN PGENERIC_MAPPING GenericMapping
);
typedef NTSTATUS (*OB_QUERYNAME_METHOD)(
IN PVOID Object,
IN BOOLEAN HasObjectName,
OUT POBJECT_NAME_INFORMATION ObjectNameInfo,
IN ULONG Length,
OUT PULONG ReturnLength,
IN KPROCESSOR_MODE Mode
);
typedef struct _OBJECT_TYPE_INITIALIZER {
USHORT Length;
BOOLEAN UseDefaultObject;
BOOLEAN CaseInsensitive;
ULONG InvalidAttributes;
GENERIC_MAPPING GenericMapping;
ULONG ValidAccessMask;
BOOLEAN SecurityRequired;
BOOLEAN MaintainHandleCount;
BOOLEAN MaintainTypeList;
POOL_TYPE PoolType;
ULONG DefaultPagedPoolCharge;
ULONG DefaultNonPagedPoolCharge;
OB_DUMP_METHOD DumpProcedure;
OB_OPEN_METHOD OpenProcedure;
OB_CLOSE_METHOD CloseProcedure;
OB_DELETE_METHOD DeleteProcedure;
OB_PARSE_METHOD ParseProcedure;
OB_SECURITY_METHOD SecurityProcedure;
OB_QUERYNAME_METHOD QueryNameProcedure;
OB_OKAYTOCLOSE_METHOD OkayToCloseProcedure;
} OBJECT_TYPE_INITIALIZER, *POBJECT_TYPE_INITIALIZER;
typedef struct _OBJECT_TYPE {
ERESOURCE Mutex;
LIST_ENTRY TypeList;
UNICODE_STRING Name;            // Copy from object header for convenience
PVOID DefaultObject;
ULONG Index;
ULONG TotalNumberOfObjects;
ULONG TotalNumberOfHandles;
ULONG HighWaterNumberOfObjects;
ULONG HighWaterNumberOfHandles;
OBJECT_TYPE_INITIALIZER TypeInfo;
#ifdef POOL_TAGGING
ULONG Key;
#endif //POOL_TAGGING
ERESOURCE ObjectLocks[ OBJECT_LOCK_COUNT ];
} OBJECT_TYPE, *POBJECT_TYPE;
NTKERNELAPI
NTSTATUS
ObCreateObject(
IN KPROCESSOR_MODE ProbeMode,
IN POBJECT_TYPE ObjectType,
IN POBJECT_ATTRIBUTES ObjectAttributes,
IN KPROCESSOR_MODE OwnershipMode,
INout_opt PVOID ParseContext,
IN ULONG ObjectBodySize,
IN ULONG PagedPoolCharge,
IN ULONG NonPagedPoolCharge,
OUT PVOID *Object
);
NTKERNELAPI
NTSTATUS
ObInsertObject(
IN PVOID Object,
IN PACCESS_STATE PassedAccessState,
IN ACCESS_MASK DesiredAccess,
IN ULONG ObjectPointerBias,
OUT_opt PVOID *NewObject,
OUT_opt PHANDLE Handle
);
NTKERNELAPI
NTSTATUS
ObOpenObjectByName(
IN POBJECT_ATTRIBUTES ObjectAttributes,
IN POBJECT_TYPE ObjectType,
IN KPROCESSOR_MODE AccessMode,
INout_opt PACCESS_STATE AccessState,
IN ACCESS_MASK DesiredAccess,
INout_opt PVOID ParseContext,
OUT PHANDLE Handle
);
NTKERNELAPI                                                     // ntifs
NTSTATUS                                                        // ntifs
ObOpenObjectByPointer(                                          // ntifs
IN PVOID Object,                                            // ntifs
IN ULONG HandleAttributes,                                  // ntifs
IN PACCESS_STATE PassedAccessState,                // ntifs
IN ACCESS_MASK DesiredAccess,                      // ntifs
IN POBJECT_TYPE ObjectType,                        // ntifs
IN KPROCESSOR_MODE AccessMode,                              // ntifs
OUT PHANDLE Handle                                          // ntifs
);                                                          // ntifs
NTKERNELAPI
NTSTATUS
ObReferenceObjectByName(
IN PUNICODE_STRING ObjectName,
IN ULONG Attributes,
IN PACCESS_STATE AccessState,
IN ACCESS_MASK DesiredAccess,
IN POBJECT_TYPE ObjectType,
IN KPROCESSOR_MODE AccessMode,
INout_opt PVOID ParseContext,
OUT PVOID *Object
);
NTKERNELAPI
BOOLEAN
ObFindHandleForObject(
IN PEPROCESS Process,
IN PVOID Object,
IN POBJECT_TYPE ObjectType,
IN POBJECT_HANDLE_INFORMATION MatchCriteria,
OUT PHANDLE Handle
);
// begin_ntifs begin_ntosp
NTKERNELAPI
NTSTATUS
ObQueryNameString(
IN PVOID Object,
OUT_bcount(Length) POBJECT_NAME_INFORMATION ObjectNameInfo,
IN ULONG Length,
OUT PULONG ReturnLength
);
NTKERNELAPI
NTSTATUS
ObSetHandleAttributes (
IN HANDLE Handle,
IN POBJECT_HANDLE_FLAG_INFORMATION HandleFlags,
IN KPROCESSOR_MODE PreviousMode
);
NTKERNELAPI
NTSTATUS
ObCloseHandle (
IN HANDLE Handle,
IN KPROCESSOR_MODE PreviousMode
);
*/
////////////////////////////////////////////////////////////////////////// 
//Nt?|????им??????бз??????бь?|D 

//typedef struct _KPROCESS *PKPROCESS, *PRKPROCESS, *PEPROCESS;

// begin_ntddk begin_ntifs 
NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenProcess(
	OUT PHANDLE ProcessHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes,
	IN PCLIENT_ID ClientId
);
// end_ntddk end_ntifs 

// begin_ntddk begin_ntifs 
/*
typedef enum _PROCESSINFOCLASS {
ProcessBasicInformation,
ProcessQuotaLimits,
ProcessIoCounters,
ProcessVmCounters,
ProcessTimes,
ProcessBasePriority,
ProcessRaisePriority,
ProcessDebugPort,
ProcessExceptionPort,
ProcessAccessToken,
ProcessLdtInformation,
ProcessLdtSize,
ProcessDefaultHardErrorMode,
ProcessIoPortHandlers,          // Note: this is kernel mode only
ProcessPooledUsageAndLimits,
ProcessWorkingSetWatch,
ProcessUserModeIOPL,
ProcessEnableAlignmentFaultFixup,
ProcessPriorityClass,
ProcessWx86Information,
ProcessHandleCount,
ProcessAffinityMask,
ProcessPriorityBoost,
ProcessDeviceMap,
ProcessSessionInformation,
ProcessForegroundInformation,
ProcessWow64Information,
ProcessImageFileName,
ProcessLUIDDeviceMapsEnabled,
ProcessBreakOnTermination,
ProcessDebugObjectHandle,
ProcessDebugFlags,
ProcessHandleTracing,
ProcessIoPriority,
ProcessExecuteFlags,
ProcessResourceManagement,
ProcessCookie,
ProcessImageInformation,
MaxProcessInfoClass             // MaxProcessInfoClass should always be the last enum
} PROCESSINFOCLASS;
*/

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationProcess(
	IN HANDLE ProcessHandle,
	IN PROCESSINFOCLASS ProcessInformationClass,
	OUT  PVOID ProcessInformation,
	IN ULONG ProcessInformationLength,
	OUT PULONG ReturnLength
);
// end_ntddk end_ntifs 


NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationProcess(
	IN HANDLE ProcessHandle,
	IN PROCESSINFOCLASS ProcessInformationClass,
	IN PVOID ProcessInformation,
	IN ULONG ProcessInformationLength
);


NTSYSCALLAPI
NTSTATUS
NTAPI
NtOpenThread(
	OUT PHANDLE ThreadHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes,
	IN PCLIENT_ID ClientId
);

// 
// Thread Information Classes 
// 
/*
typedef enum _THREADINFOCLASS {
ThreadBasicInformation,
ThreadTimes,
ThreadPriority,
ThreadBasePriority,
ThreadAffinityMask,
ThreadImpersonationToken,
ThreadDescriptorTableEntry,
ThreadEnableAlignmentFaultFixup,
ThreadEventPair_Reusable,
ThreadQuerySetWin32StartAddress,
ThreadZeroTlsCell,
ThreadPerformanceCount,
ThreadAmILastThread,
ThreadIdealProcessor,
ThreadPriorityBoost,
ThreadSetTlsArrayAddress,
ThreadIsIoPending,
ThreadHideFromDebugger,
ThreadBreakOnTermination,
ThreadSwitchLegacyState,
ThreadIsTerminated,
MaxThreadInfoClass
} THREADINFOCLASS;
// end_ntddk end_ntifs
*/

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationThread(
	IN HANDLE ThreadHandle,
	IN THREADINFOCLASS ThreadInformationClass,
	OUT PVOID ThreadInformation,
	IN ULONG ThreadInformationLength,
	OUT PULONG ReturnLength
);

// begin_ntifs 
NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationThread(
	IN HANDLE ThreadHandle,
	IN THREADINFOCLASS ThreadInformationClass,
	IN PVOID ThreadInformation,
	IN ULONG ThreadInformationLength
);
// end_ntifs 
/*
typedef struct _IO_STATUS_BLOCK {
union {
NTSTATUS Status;
PVOID Pointer;
};
ULONG_PTR Information;
} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;
*/
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCreateFile(
	OUT PHANDLE FileHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	IN PLARGE_INTEGER AllocationSize,
	IN ULONG FileAttributes,
	IN ULONG ShareAccess,
	IN ULONG CreateDisposition,
	IN ULONG CreateOptions,
	IN PVOID EaBuffer,
	IN ULONG EaLength
);

typedef
VOID
(NTAPI *PIO_APC_ROUTINE) (
	IN PVOID ApcContext,
	IN PIO_STATUS_BLOCK IoStatusBlock,
	IN ULONG Reserved
	);


NTSYSCALLAPI
NTSTATUS
NTAPI
NtDeviceIoControlFile(
	IN HANDLE FileHandle,
	IN HANDLE Event,
	IN PIO_APC_ROUTINE ApcRoutine,
	IN PVOID ApcContext,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	IN ULONG IoControlCode,
	IN PVOID InputBuffer,
	IN ULONG InputBufferLength,
	OUT PVOID OutputBuffer,
	IN ULONG OutputBufferLength
);

/*
typedef enum _FILE_INFORMATION_CLASS {
// end_wdm
FileDirectoryInformation         = 1,
FileFullDirectoryInformation,   // 2
FileBothDirectoryInformation,   // 3
FileBasicInformation,           // 4  wdm
FileStandardInformation,        // 5  wdm
FileInternalInformation,        // 6
FileEaInformation,              // 7
FileAccessInformation,          // 8
FileNameInformation,            // 9
FileRenameInformation,          // 10
FileLinkInformation,            // 11
FileNamesInformation,           // 12
FileDispositionInformation,     // 13
FilePositionInformation,        // 14 wdm
FileFullEaInformation,          // 15
FileModeInformation,            // 16
FileAlignmentInformation,       // 17
FileAllInformation,             // 18
FileAllocationInformation,      // 19
FileEndOfFileInformation,       // 20 wdm
FileAlternateNameInformation,   // 21
FileStreamInformation,          // 22
FilePipeInformation,            // 23
FilePipeLocalInformation,       // 24
FilePipeRemoteInformation,      // 25
FileMailslotQueryInformation,   // 26
FileMailslotSetInformation,     // 27
FileCompressionInformation,     // 28
FileObjectIdInformation,        // 29
FileCompletionInformation,      // 30
FileMoveClusterInformation,     // 31
FileQuotaInformation,           // 32
FileReparsePointInformation,    // 33
FileNetworkOpenInformation,     // 34
FileAttributeTagInformation,    // 35
FileTrackingInformation,        // 36
FileIdBothDirectoryInformation, // 37
FileIdFullDirectoryInformation, // 38
FileValidDataLengthInformation, // 39
FileShortNameInformation,       // 40
FileMaximumInformation
// begin_wdm
} FILE_INFORMATION_CLASS, *PFILE_INFORMATION_CLASS;
*/

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryDirectoryFile(
	IN HANDLE FileHandle,
	IN HANDLE Event,
	IN PIO_APC_ROUTINE ApcRoutine,
	IN PVOID ApcContext,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	OUT PVOID FileInformation,
	IN ULONG Length,
	IN FILE_INFORMATION_CLASS FileInformationClass,
	IN BOOLEAN ReturnSingleEntry,
	IN PUNICODE_STRING FileName,
	IN BOOLEAN RestartScan
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryInformationFile(
	IN HANDLE FileHandle,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	OUT PVOID FileInformation,
	IN ULONG Length,
	IN FILE_INFORMATION_CLASS FileInformationClass
);

/*
typedef enum _FSINFOCLASS {
FileFsVolumeInformation       = 1,
FileFsLabelInformation,      // 2
FileFsSizeInformation,       // 3
FileFsDeviceInformation,     // 4
FileFsAttributeInformation,  // 5
FileFsControlInformation,    // 6
FileFsFullSizeInformation,   // 7
FileFsObjectIdInformation,   // 8
FileFsDriverPathInformation, // 9
FileFsMaximumInformation
} FS_INFORMATION_CLASS, *PFS_INFORMATION_CLASS;
*/

NTSYSCALLAPI
NTSTATUS
NTAPI
NtQueryVolumeInformationFile(
	IN HANDLE FileHandle,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	OUT  PVOID FsInformation,
	IN ULONG Length,
	IN FS_INFORMATION_CLASS FsInformationClass
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtReadFile(
	IN HANDLE FileHandle,
	IN HANDLE Event,
	IN PIO_APC_ROUTINE ApcRoutine,
	IN PVOID ApcContext,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	OUT PVOID Buffer,
	IN ULONG Length,
	IN PLARGE_INTEGER ByteOffset,
	IN PULONG Key
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetInformationFile(
	IN HANDLE FileHandle,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	IN PVOID FileInformation,
	IN ULONG Length,
	IN FILE_INFORMATION_CLASS FileInformationClass
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetVolumeInformationFile(
	IN HANDLE FileHandle,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	IN PVOID FsInformation,
	IN ULONG Length,
	IN FS_INFORMATION_CLASS FsInformationClass
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtWriteFile(
	IN HANDLE FileHandle,
	IN HANDLE Event,
	IN PIO_APC_ROUTINE ApcRoutine,
	IN PVOID ApcContext,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	IN PVOID Buffer,
	IN ULONG Length,
	IN PLARGE_INTEGER ByteOffset,
	IN PULONG Key
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtUnlockFile(
	IN HANDLE FileHandle,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	IN PLARGE_INTEGER ByteOffset,
	IN PLARGE_INTEGER Length,
	IN ULONG Key
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtSetEaFile(
	IN HANDLE FileHandle,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	IN PVOID Buffer,
	IN ULONG Length
);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtLockFile(
	IN HANDLE FileHandle,
	IN HANDLE Event,
	IN PIO_APC_ROUTINE ApcRoutine,
	IN PVOID ApcContext,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	IN PLARGE_INTEGER ByteOffset,
	IN PLARGE_INTEGER Length,
	IN ULONG Key,
	IN BOOLEAN FailImmediately,
	IN BOOLEAN ExclusiveLock
);

typedef enum _SHUTDOWN_ACTION {
	ShutdownNoReboot,
	ShutdownReboot,
	ShutdownPowerOff
} SHUTDOWN_ACTION;

NTSYSCALLAPI
NTSTATUS
NTAPI
NtShutdownSystem(
	IN SHUTDOWN_ACTION Action
);

////////////////////////////////////////////////////////////////////////// 
//Io?|????им??????бз??????бь?|D (1??a|????им???????бз?????????бз??????бь????бь?????бз??????бь?|??????им?o????????им????бз???бз?????бз??????бз????..) 
// 
// Define driver initialization routine type. 
// 
typedef
NTSTATUS
(*PDRIVER_INITIALIZE) (
	IN struct _DRIVER_OBJECT *DriverObject,
	IN PUNICODE_STRING RegistryPath
	);

NTKERNELAPI
NTSTATUS
IoCreateDriver(
	IN PUNICODE_STRING DriverName, OPTIONAL
	IN PDRIVER_INITIALIZE InitializationFunction
);

NTKERNELAPI
VOID
IoDeleteDriver(
	IN PDRIVER_OBJECT DriverObject
);

////////////////////////////////////////////////////////////////////////// 
//Kd?|????им??????бз??????бь?|D 
/*
NTKERNELAPI
NTSTATUS
KdDisableDebugger(
VOID
);
NTKERNELAPI
NTSTATUS
KdEnableDebugger(
VOID
);
*/



NTKERNELAPI
NTSTATUS
KdPowerTransition(
	IN DEVICE_POWER_STATE newDeviceState
);

NTKERNELAPI
BOOLEAN
KdPollBreakIn(
	VOID
);

////////////////////////////////////////////////////////////////////////// 
//Ke?|????им??????бз??????бь?|D 

NTSTATUS
NTAPI
Ke386CallBios(
	IN ULONG BiosCommand,
	IN OUT PCONTEXT BiosArguments
);

#define IOPM_SIZE           8192 

typedef UCHAR   KIO_ACCESS_MAP[IOPM_SIZE];

typedef KIO_ACCESS_MAP *PKIO_ACCESS_MAP;

BOOLEAN
NTAPI
Ke386SetIoAccessMap(
	ULONG               MapNumber,
	PKIO_ACCESS_MAP     IoAccessMap
);

BOOLEAN
NTAPI
Ke386QueryIoAccessMap(
	ULONG              MapNumber,
	PKIO_ACCESS_MAP    IoAccessMap
);


NTKERNELAPI
BOOLEAN
KeAddSystemServiceTable(
	IN PULONG_PTR Base,
	IN PULONG Count OPTIONAL,
	IN ULONG Limit,
	IN PUCHAR Number,
	IN ULONG Index
);

#define PKPROCESS PRKPROCESS 


NTKERNELAPI
VOID
KeDetachProcess(
	VOID
);

NTKERNELAPI
DECLSPEC_NORETURN
VOID
NTAPI
KeBugCheck(
	IN ULONG BugCheckCode
);

NTKERNELAPI
DECLSPEC_NORETURN
VOID
KeBugCheckEx(
	IN ULONG BugCheckCode,
	IN ULONG_PTR BugCheckParameter1,
	IN ULONG_PTR BugCheckParameter2,
	IN ULONG_PTR BugCheckParameter3,
	IN ULONG_PTR BugCheckParameter4
);

/*
//
// Interrupt object
//
struct _KINTERRUPT;
// begin_ntddk begin_wdm begin_ntifs begin_ntosp
typedef
BOOLEAN
(*PKSERVICE_ROUTINE) (
IN struct _KINTERRUPT *Interrupt,
IN PVOID ServiceContext
);
typedef struct _KINTERRUPT {
CSHORT Type;
CSHORT Size;
LIST_ENTRY InterruptListEntry;
PKSERVICE_ROUTINE ServiceRoutine;
PVOID ServiceContext;
KSPIN_LOCK SpinLock;
ULONG TickCount;
PKSPIN_LOCK ActualLock;
PKINTERRUPT_ROUTINE DispatchAddress;
ULONG Vector;
KIRQL Irql;
KIRQL SynchronizeIrql;
BOOLEAN FloatingSave;
BOOLEAN Connected;
CCHAR Number;
BOOLEAN ShareVector;
KINTERRUPT_MODE Mode;
ULONG ServiceCount;
ULONG DispatchCount;
#if defined(_AMD64_)
PKTRAP_FRAME TrapFrame;
PVOID Reserved;
ULONG DispatchCode[DISPATCH_LENGTH];
#else
ULONG DispatchCode[DISPATCH_LENGTH];
#endif
} KINTERRUPT;
#if !defined(_X86AMD64_) && defined(_AMD64_)
C_ASSERT((FIELD_OFFSET(KINTERRUPT, DispatchCode) % 16) == 0);
C_ASSERT((sizeof(KINTERRUPT) % 16) == 0);
#endif
typedef struct _KINTERRUPT *PKINTERRUPT, *PRKINTERRUPT; // ntndis ntosp
NTKERNELAPI
BOOLEAN
KeDisconnectInterrupt (
INout PKINTERRUPT Interrupt
);
*/

NTKERNELAPI
VOID
KeEnterKernelDebugger(
	VOID
);

NTSTATUS
NTAPI
KeI386AbiosCall(
	IN USHORT LogicalId,
	IN struct _DRIVER_OBJECT *DriverObject,
	IN PUCHAR RequestBlock,
	IN USHORT EntryPoint
);

NTSTATUS
NTAPI
KeI386AllocateGdtSelectors(
	OUT PUSHORT SelectorArray,
	IN USHORT NumberOfSelectors
);

NTSTATUS
NTAPI
KeI386FlatToGdtSelector(
	IN ULONG SelectorBase,
	IN USHORT Length,
	IN USHORT Selector
);

NTSTATUS
NTAPI
KeI386ReleaseGdtSelectors(
	OUT PUSHORT SelectorArray,
	IN USHORT NumberOfSelectors
);

// 
// GDT Entry 
// 

typedef struct _KGDTENTRY {
	USHORT  LimitLow;
	USHORT  BaseLow;
	union {
		struct {
			UCHAR   BaseMid;
			UCHAR   Flags1;     // Declare as bytes to avoid alignment 
			UCHAR   Flags2;     // Problems. 
			UCHAR   BaseHi;
		} Bytes;
		struct {
			ULONG   BaseMid : 8;
			ULONG   Type : 5;
			ULONG   Dpl : 2;
			ULONG   Pres : 1;
			ULONG   LimitHi : 4;
			ULONG   Sys : 1;
			ULONG   Reserved_0 : 1;
			ULONG   Default_Big : 1;
			ULONG   Granularity : 1;
			ULONG   BaseHi : 8;
		} Bits;
	} HighWord;
} KGDTENTRY, *PKGDTENTRY;

NTSTATUS
NTAPI
KeI386SetGdtSelector(
	ULONG       Selector,
	PKGDTENTRY  GdtValue
);

NTSTATUS
NTAPI
KeI386GetLid(
	IN USHORT DeviceId,
	IN USHORT RelativeLid,
	IN BOOLEAN SharedLid,
	IN struct _DRIVER_OBJECT *DeviceObject,
	OUT PUSHORT LogicalId
);


NTSTATUS
NTAPI
KeI386ReleaseLid(
	IN USHORT LogicalId,
	IN struct _DRIVER_OBJECT *DeviceObject
);

/*
typedef enum _MODE {
KernelMode,
UserMode,
MaximumMode
} MODE;
*/



NTKERNELAPI
VOID
KeTerminateThread(
	IN KPRIORITY Increment
);


////////////////////////////////////////////////////////////////////////// 
//Mm?|????им??????бз??????бь?|D 
NTKERNELAPI
PVOID
MmGetVirtualForPhysical(
	IN PHYSICAL_ADDRESS PhysicalAddress
);

NTKERNELAPI
NTSTATUS
MmMapUserAddressesToPage(
	IN PVOID BaseAddress,
	IN SIZE_T NumberOfBytes,
	IN PVOID PageAddress
);

NTKERNELAPI
NTSTATUS
MmMapViewOfSection(
	IN PVOID SectionToMap,
	IN PEPROCESS Process,
	PVOID *CapturedBase,
	IN ULONG_PTR ZeroBits,
	IN SIZE_T CommitSize,
	IN OUT PLARGE_INTEGER SectionOffset,
	IN OUT PSIZE_T CapturedViewSize,
	IN SECTION_INHERIT InheritDisposition,
	IN ULONG AllocationType,
	IN ULONG Win32Protect
);

NTKERNELAPI
NTSTATUS
MmUnmapViewOfSection(
	IN PEPROCESS Process,
	IN PVOID BaseAddress
);

/*
typedef enum _MM_SYSTEM_SIZE {
MmSmallSystem,
MmMediumSystem,
MmLargeSystem
} MM_SYSTEMSIZE;
*/
NTKERNELAPI
MM_SYSTEMSIZE
MmQuerySystemSize(
	VOID
);

NTSTATUS NTAPI MmCopyVirtualMemory
(
	PEPROCESS SourceProcess,
	PVOID SourceAddress,
	PEPROCESS TargetProcess,
	PVOID TargetAddress,
	SIZE_T BufferSize,
	KPROCESSOR_MODE PreviousMode,
	PSIZE_T ReturnSize
);

NTSTATUS ZwQuerySystemInformation(ULONG InfoClass, PVOID Buffer, ULONG Length, PULONG ReturnLength);
LPSTR PsGetProcessImageFileName(PEPROCESS Process);


BOOLEAN KeInsertQueueApc(
	PRKAPC Apc,
	PVOID SystemArgument1,
	PVOID SystemArgument2,
	KPRIORITY Increment);

NTSTATUS ZwAllocateVirtualMemory(
	_In_    HANDLE    ProcessHandle,
	_Inout_ PVOID     *BaseAddress,
	_In_    ULONG_PTR ZeroBits,
	_Inout_ PSIZE_T   RegionSize,
	_In_    ULONG     AllocationType,
	_In_    ULONG     Protect
);
NTSTATUS ZwFreeVirtualMemory(
	_In_    HANDLE  ProcessHandle,
	_Inout_ PVOID   *BaseAddress,
	_Inout_ PSIZE_T RegionSize,
	_In_    ULONG   FreeType
);

//
// Copyright (c) Microsoft Corporation. All rights reserved.
//
// You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
// If you do not agree to the terms, do not use the code.
//

NTSYSAPI
NTSTATUS
NTAPI
ZwDelayExecution(
	__in BOOLEAN Alertable,
	__in PLARGE_INTEGER DelayInterval
);
NTSYSAPI
NTSTATUS
NTAPI
ZwQuerySystemEnvironmentValue(
	__in PUNICODE_STRING VariableName,
	__out_bcount(ValueLength) PWSTR VariableValue,
	__in USHORT ValueLength,
	__out_opt PUSHORT ReturnLength
);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetSystemEnvironmentValue(
	__in PUNICODE_STRING VariableName,
	__in PUNICODE_STRING VariableValue
);
NTSYSAPI
NTSTATUS
NTAPI
ZwQuerySystemEnvironmentValueEx(
	__in PUNICODE_STRING VariableName,
	__in LPGUID VendorGuid,
	__out_bcount_opt(*ValueLength) PVOID Value,
	__inout PULONG ValueLength,
	__out_opt PULONG Attributes
);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetSystemEnvironmentValueEx(
	__in PUNICODE_STRING VariableName,
	__in LPGUID VendorGuid,
	__in_bcount_opt(ValueLength) PVOID Value,
	__in ULONG ValueLength,
	__in ULONG Attributes
);
NTSYSAPI
NTSTATUS
NTAPI
ZwEnumerateSystemEnvironmentValuesEx(
	__in ULONG InformationClass,
	__out PVOID Buffer,
	__inout PULONG BufferLength
);

NTSYSAPI
NTSTATUS
NTAPI
ZwDeleteBootEntry(
	__in ULONG Id
);

NTSYSAPI
NTSTATUS
NTAPI
ZwEnumerateBootEntries(
	__out_bcount_opt(*BufferLength) PVOID Buffer,
	__inout PULONG BufferLength
);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryBootEntryOrder(
	__out_ecount_opt(*Count) PULONG Ids,
	__inout PULONG Count
);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetBootEntryOrder(
	__in_ecount(Count) PULONG Ids,
	__in ULONG Count
);

NTSYSAPI
NTSTATUS
NTAPI
ZwDeleteDriverEntry(
	__in ULONG Id
);

NTSYSAPI
NTSTATUS
NTAPI
ZwEnumerateDriverEntries(
	__out_bcount(*BufferLength) PVOID Buffer,
	__inout PULONG BufferLength
);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryDriverEntryOrder(
	__out_ecount(*Count) PULONG Ids,
	__inout PULONG Count
);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetDriverEntryOrder(
	__in_ecount(Count) PULONG Ids,
	__in ULONG Count
);
NTSYSAPI
NTSTATUS
NTAPI
ZwClearEvent(
	__in HANDLE EventHandle
);
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateEvent(
	__out PHANDLE EventHandle,
	__in ACCESS_MASK DesiredAccess,
	__in_opt POBJECT_ATTRIBUTES ObjectAttributes,
	__in EVENT_TYPE EventType,
	__in BOOLEAN InitialState
);
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenEvent(
	__out PHANDLE EventHandle,
	__in ACCESS_MASK DesiredAccess,
	__in POBJECT_ATTRIBUTES ObjectAttributes
);
NTSYSAPI
NTSTATUS
NTAPI
ZwPulseEvent(
	__in HANDLE EventHandle,
	__out_opt PLONG PreviousState
);

NTSYSAPI
NTSTATUS
NTAPI
ZwResetEvent(
	__in HANDLE EventHandle,
	__out_opt PLONG PreviousState
);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetEvent(
	__in HANDLE EventHandle,
	__out_opt PLONG PreviousState
);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetEventBoostPriority(
	__in HANDLE EventHandle
);
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateEventPair(
	__out PHANDLE EventPairHandle,
	__in ACCESS_MASK DesiredAccess,
	__in_opt POBJECT_ATTRIBUTES ObjectAttributes
);
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenEventPair(
	__out PHANDLE EventPairHandle,
	__in ACCESS_MASK DesiredAccess,
	__in POBJECT_ATTRIBUTES ObjectAttributes
);
NTSYSAPI
NTSTATUS
NTAPI
ZwWaitLowEventPair(
	__in HANDLE EventPairHandle
);
NTSYSAPI
NTSTATUS
NTAPI
ZwWaitHighEventPair(
	__in HANDLE EventPairHandle
);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetLowWaitHighEventPair(
	__in HANDLE EventPairHandle
);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetHighWaitLowEventPair(
	__in HANDLE EventPairHandle
);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetLowEventPair(
	__in HANDLE EventPairHandle
);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetHighEventPair(
	__in HANDLE EventPairHandle
);
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateMutant(
	__out PHANDLE MutantHandle,
	__in ACCESS_MASK DesiredAccess,
	__in_opt POBJECT_ATTRIBUTES ObjectAttributes,
	__in BOOLEAN InitialOwner
);
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenMutant(
	__out PHANDLE MutantHandle,
	__in ACCESS_MASK DesiredAccess,
	__in POBJECT_ATTRIBUTES ObjectAttributes
);

NTSYSAPI
NTSTATUS
NTAPI
ZwReleaseMutant(
	__in HANDLE MutantHandle,
	__out_opt PLONG PreviousCount
);
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateSemaphore(
	__out PHANDLE SemaphoreHandle,
	__in ACCESS_MASK DesiredAccess,
	__in_opt POBJECT_ATTRIBUTES ObjectAttributes,
	__in LONG InitialCount,
	__in LONG MaximumCount
);
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenSemaphore(
	__out PHANDLE SemaphoreHandle,
	__in ACCESS_MASK DesiredAccess,
	__in POBJECT_ATTRIBUTES ObjectAttributes
);

NTSYSAPI
NTSTATUS
NTAPI
ZwReleaseSemaphore(
	__in HANDLE SemaphoreHandle,
	__in LONG ReleaseCount,
	__out_opt PLONG PreviousCount
);


NTSYSAPI
NTSTATUS
NTAPI
ZwQuerySystemTime(
	__out PLARGE_INTEGER SystemTime
);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetSystemTime(
	__in_opt PLARGE_INTEGER SystemTime,
	__out_opt PLARGE_INTEGER PreviousTime
);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryTimerResolution(
	__out PULONG MaximumTime,
	__out PULONG MinimumTime,
	__out PULONG CurrentTime
);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetTimerResolution(
	__in ULONG DesiredTime,
	__in BOOLEAN SetResolution,
	__out PULONG ActualTime
);
NTSYSAPI
NTSTATUS
NTAPI
ZwAllocateLocallyUniqueId(
	__out PLUID Luid
);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetUuidSeed(
	__in PCHAR Seed
);
NTSYSAPI
NTSTATUS
NTAPI
ZwAllocateUuids(
	__out PULARGE_INTEGER Time,
	__out PULONG Range,
	__out PULONG Sequence,
	__out PCHAR Seed
);
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateProfile(
	__out PHANDLE ProfileHandle,
	__in HANDLE Process OPTIONAL,
	__in PVOID ProfileBase,
	__in SIZE_T ProfileSize,
	__in ULONG BucketSize,
	__in PULONG Buffer,
	__in ULONG BufferSize,
	__in KPROFILE_SOURCE ProfileSource,
	__in KAFFINITY Affinity
);
NTSYSAPI
NTSTATUS
NTAPI
ZwStartProfile(
	__in HANDLE ProfileHandle
);
NTSYSAPI
NTSTATUS
NTAPI
ZwStopProfile(
	__in HANDLE ProfileHandle
);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetIntervalProfile(
	__in ULONG Interval,
	__in KPROFILE_SOURCE Source
);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryIntervalProfile(
	__in KPROFILE_SOURCE ProfileSource,
	__out PULONG Interval
);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryPerformanceCounter(
	__out PLARGE_INTEGER PerformanceCounter,
	__out_opt PLARGE_INTEGER PerformanceFrequency
);
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateKeyedEvent(
	__out PHANDLE KeyedEventHandle,
	__in ACCESS_MASK DesiredAccess,
	__in_opt POBJECT_ATTRIBUTES ObjectAttributes,
	__in ULONG Flags
);
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenKeyedEvent(
	__out PHANDLE KeyedEventHandle,
	__in ACCESS_MASK DesiredAccess,
	__in POBJECT_ATTRIBUTES ObjectAttributes
);
NTSYSAPI
NTSTATUS
NTAPI
ZwReleaseKeyedEvent(
	__in HANDLE KeyedEventHandle,
	__in PVOID KeyValue,
	__in BOOLEAN Alertable,
	__in_opt PLARGE_INTEGER Timeout
);
NTSYSAPI
NTSTATUS
NTAPI
ZwWaitForKeyedEvent(
	__in HANDLE KeyedEventHandle,
	__in PVOID KeyValue,
	__in BOOLEAN Alertable,
	__in_opt PLARGE_INTEGER Timeout
);


NTSYSAPI
NTSTATUS
NTAPI
ZwRaiseHardError(
	__in NTSTATUS ErrorStatus,
	__in ULONG NumberOfParameters,
	__in ULONG UnicodeStringParameterMask,
	__in_ecount(NumberOfParameters) PULONG_PTR Parameters,
	__in ULONG ValidResponseOptions,
	__out PULONG Response
);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryDefaultLocale(
	__in BOOLEAN UserProfile,
	__out PLCID DefaultLocaleId
);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetDefaultLocale(
	__in BOOLEAN UserProfile,
	__in LCID DefaultLocaleId
);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryInstallUILanguage(
	__out LANGID *InstallUILanguageId
);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryDefaultUILanguage(
	__out LANGID *DefaultUILanguageId
);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetDefaultUILanguage(
	__in LANGID DefaultUILanguageId
);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetDefaultHardErrorPort(
	__in HANDLE DefaultHardErrorPort
);
NTSYSAPI
NTSTATUS
NTAPI
ZwShutdownSystem(
	__in SHUTDOWN_ACTION Action
);
NTSYSAPI
NTSTATUS
NTAPI
ZwDisplayString(
	__in PUNICODE_STRING String
);

NTSYSAPI
NTSTATUS
NTAPI
ZwCancelIoFile(
	__in HANDLE FileHandle,
	__out PIO_STATUS_BLOCK IoStatusBlock
);
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateNamedPipeFile(
	__out PHANDLE FileHandle,
	__in ULONG DesiredAccess,
	__in POBJECT_ATTRIBUTES ObjectAttributes,
	__out PIO_STATUS_BLOCK IoStatusBlock,
	__in ULONG ShareAccess,
	__in ULONG CreateDisposition,
	__in ULONG CreateOptions,
	__in ULONG NamedPipeType,
	__in ULONG ReadMode,
	__in ULONG CompletionMode,
	__in ULONG MaximumInstances,
	__in ULONG InboundQuota,
	__in ULONG OutboundQuota,
	__in_opt PLARGE_INTEGER DefaultTimeout
);
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateMailslotFile(
	__out PHANDLE FileHandle,
	__in ULONG DesiredAccess,
	__in POBJECT_ATTRIBUTES ObjectAttributes,
	__out PIO_STATUS_BLOCK IoStatusBlock,
	__in ULONG CreateOptions,
	__in ULONG MailslotQuota,
	__in ULONG MaximumMessageSize,
	__in PLARGE_INTEGER ReadTimeout
);
NTSYSAPI
NTSTATUS
NTAPI
ZwDeleteFile(
	__in POBJECT_ATTRIBUTES ObjectAttributes
);
NTSYSAPI
NTSTATUS
NTAPI
ZwFlushBuffersFile(
	__in HANDLE FileHandle,
	__out PIO_STATUS_BLOCK IoStatusBlock
);
NTSYSAPI
NTSTATUS
NTAPI
ZwNotifyChangeDirectoryFile(
	__in HANDLE FileHandle,
	__in_opt HANDLE Event,
	__in_opt PIO_APC_ROUTINE ApcRoutine,
	__in_opt PVOID ApcContext,
	__out PIO_STATUS_BLOCK IoStatusBlock,
	__out_bcount(Length) PVOID Buffer,
	__in ULONG Length,
	__in ULONG CompletionFilter,
	__in BOOLEAN WatchTree
);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryAttributesFile(
	__in POBJECT_ATTRIBUTES ObjectAttributes,
	__out PFILE_BASIC_INFORMATION FileInformation
);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryFullAttributesFile(
	__in POBJECT_ATTRIBUTES ObjectAttributes,
	__out PFILE_NETWORK_OPEN_INFORMATION FileInformation
);
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateFile(
	__out PHANDLE FileHandle,
	__in ACCESS_MASK DesiredAccess,
	__in POBJECT_ATTRIBUTES ObjectAttributes,
	__out PIO_STATUS_BLOCK IoStatusBlock,
	__in_opt PLARGE_INTEGER AllocationSize,
	__in ULONG FileAttributes,
	__in ULONG ShareAccess,
	__in ULONG CreateDisposition,
	__in ULONG CreateOptions,
	__in_bcount_opt(EaLength) PVOID EaBuffer,
	__in ULONG EaLength
);
NTSYSAPI
NTSTATUS
NTAPI
ZwDeviceIoControlFile(
	__in HANDLE FileHandle,
	__in_opt HANDLE Event,
	__in_opt PIO_APC_ROUTINE ApcRoutine,
	__in_opt PVOID ApcContext,
	__out PIO_STATUS_BLOCK IoStatusBlock,
	__in ULONG IoControlCode,
	__in_bcount_opt(InputBufferLength) PVOID InputBuffer,
	__in ULONG InputBufferLength,
	__out_bcount_opt(OutputBufferLength) PVOID OutputBuffer,
	__in ULONG OutputBufferLength
);
NTSYSAPI
NTSTATUS
NTAPI
ZwFsControlFile(
	__in HANDLE FileHandle,
	__in_opt HANDLE Event,
	__in_opt PIO_APC_ROUTINE ApcRoutine,
	__in_opt PVOID ApcContext,
	__out PIO_STATUS_BLOCK IoStatusBlock,
	__in ULONG FsControlCode,
	__in_bcount_opt(InputBufferLength) PVOID InputBuffer,
	__in ULONG InputBufferLength,
	__out_bcount_opt(OutputBufferLength) PVOID OutputBuffer,
	__in ULONG OutputBufferLength
);
NTSYSAPI
NTSTATUS
NTAPI
ZwLockFile(
	__in HANDLE FileHandle,
	__in_opt HANDLE Event,
	__in_opt PIO_APC_ROUTINE ApcRoutine,
	__in_opt PVOID ApcContext,
	__out PIO_STATUS_BLOCK IoStatusBlock,
	__in PLARGE_INTEGER ByteOffset,
	__in PLARGE_INTEGER Length,
	__in ULONG Key,
	__in BOOLEAN FailImmediately,
	__in BOOLEAN ExclusiveLock
);
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenFile(
	__out PHANDLE FileHandle,
	__in ACCESS_MASK DesiredAccess,
	__in POBJECT_ATTRIBUTES ObjectAttributes,
	__out PIO_STATUS_BLOCK IoStatusBlock,
	__in ULONG ShareAccess,
	__in ULONG OpenOptions
);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryDirectoryFile(
	__in HANDLE FileHandle,
	__in_opt HANDLE Event,
	__in_opt PIO_APC_ROUTINE ApcRoutine,
	__in_opt PVOID ApcContext,
	__out PIO_STATUS_BLOCK IoStatusBlock,
	__out_bcount(Length) PVOID FileInformation,
	__in ULONG Length,
	__in FILE_INFORMATION_CLASS FileInformationClass,
	__in BOOLEAN ReturnSingleEntry,
	__in_opt PUNICODE_STRING FileName,
	__in BOOLEAN RestartScan
);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryInformationFile(
	__in HANDLE FileHandle,
	__out PIO_STATUS_BLOCK IoStatusBlock,
	__out_bcount(Length) PVOID FileInformation,
	__in ULONG Length,
	__in FILE_INFORMATION_CLASS FileInformationClass
);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryQuotaInformationFile(
	__in HANDLE FileHandle,
	__out PIO_STATUS_BLOCK IoStatusBlock,
	__out_bcount(Length) PVOID Buffer,
	__in ULONG Length,
	__in BOOLEAN ReturnSingleEntry,
	__in_bcount_opt(SidListLength) PVOID SidList,
	__in ULONG SidListLength,
	__in_opt PSID StartSid,
	__in BOOLEAN RestartScan
);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryVolumeInformationFile(
	__in HANDLE FileHandle,
	__out PIO_STATUS_BLOCK IoStatusBlock,
	__out_bcount(Length) PVOID FsInformation,
	__in ULONG Length,
	__in FS_INFORMATION_CLASS FsInformationClass
);
NTSYSAPI
NTSTATUS
NTAPI
ZwReadFile(
	__in HANDLE FileHandle,
	__in_opt HANDLE Event,
	__in_opt PIO_APC_ROUTINE ApcRoutine,
	__in_opt PVOID ApcContext,
	__out PIO_STATUS_BLOCK IoStatusBlock,
	__out_bcount(Length) PVOID Buffer,
	__in ULONG Length,
	__in_opt PLARGE_INTEGER ByteOffset,
	__in_opt PULONG Key
);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetInformationFile(
	__in HANDLE FileHandle,
	__out PIO_STATUS_BLOCK IoStatusBlock,
	__in_bcount(Length) PVOID FileInformation,
	__in ULONG Length,
	__in FILE_INFORMATION_CLASS FileInformationClass
);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetQuotaInformationFile(
	__in HANDLE FileHandle,
	__out PIO_STATUS_BLOCK IoStatusBlock,
	__in_bcount(Length) PVOID Buffer,
	__in ULONG Length
);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetVolumeInformationFile(
	__in HANDLE FileHandle,
	__out PIO_STATUS_BLOCK IoStatusBlock,
	__in_bcount(Length) PVOID FsInformation,
	__in ULONG Length,
	__in FS_INFORMATION_CLASS FsInformationClass
);
NTSYSAPI
NTSTATUS
NTAPI
ZwWriteFile(
	__in HANDLE FileHandle,
	__in_opt HANDLE Event,
	__in_opt PIO_APC_ROUTINE ApcRoutine,
	__in_opt PVOID ApcContext,
	__out PIO_STATUS_BLOCK IoStatusBlock,
	__in_bcount(Length) PVOID Buffer,
	__in ULONG Length,
	__in_opt PLARGE_INTEGER ByteOffset,
	__in_opt PULONG Key
);
NTSYSAPI
NTSTATUS
NTAPI
ZwUnlockFile(
	__in HANDLE FileHandle,
	__out PIO_STATUS_BLOCK IoStatusBlock,
	__in PLARGE_INTEGER ByteOffset,
	__in PLARGE_INTEGER Length,
	__in ULONG Key
);
NTSYSAPI
NTSTATUS
NTAPI
ZwReadFileScatter(
	__in HANDLE FileHandle,
	__in_opt HANDLE Event,
	__in_opt PIO_APC_ROUTINE ApcRoutine,
	__in_opt PVOID ApcContext,
	__out PIO_STATUS_BLOCK IoStatusBlock,
	__in PFILE_SEGMENT_ELEMENT SegmentArray,
	__in ULONG Length,
	__in_opt PLARGE_INTEGER ByteOffset,
	__in_opt PULONG Key
);

NTSYSAPI
NTSTATUS
NTAPI
ZwWriteFileGather(
	__in HANDLE FileHandle,
	__in_opt HANDLE Event,
	__in_opt PIO_APC_ROUTINE ApcRoutine,
	__in_opt PVOID ApcContext,
	__out PIO_STATUS_BLOCK IoStatusBlock,
	__in PFILE_SEGMENT_ELEMENT SegmentArray,
	__in ULONG Length,
	__in_opt PLARGE_INTEGER ByteOffset,
	__in_opt PULONG Key
);
NTSYSAPI
NTSTATUS
NTAPI
ZwLoadDriver(
	__in PUNICODE_STRING DriverServiceName
);
NTSYSAPI
NTSTATUS
NTAPI
ZwUnloadDriver(
	__in PUNICODE_STRING DriverServiceName
);
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateIoCompletion(
	__out PHANDLE IoCompletionHandle,
	__in ACCESS_MASK DesiredAccess,
	__in_opt POBJECT_ATTRIBUTES ObjectAttributes,
	__in ULONG Count OPTIONAL
);
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenIoCompletion(
	__out PHANDLE IoCompletionHandle,
	__in ACCESS_MASK DesiredAccess,
	__in POBJECT_ATTRIBUTES ObjectAttributes
);

NTSYSAPI
NTSTATUS
NTAPI
ZwSetIoCompletion(
	__in HANDLE IoCompletionHandle,
	__in PVOID KeyContext,
	__in_opt PVOID ApcContext,
	__in NTSTATUS IoStatus,
	__in ULONG_PTR IoStatusInformation
);
NTSYSAPI
NTSTATUS
NTAPI
ZwRemoveIoCompletion(
	__in HANDLE IoCompletionHandle,
	__out PVOID *KeyContext,
	__out PVOID *ApcContext,
	__out PIO_STATUS_BLOCK IoStatusBlock,
	__in_opt PLARGE_INTEGER Timeout
);
NTSYSAPI
NTSTATUS
NTAPI
ZwCallbackReturn(
	__in_bcount_opt(OutputLength) PVOID OutputBuffer,
	__in ULONG OutputLength,
	__in NTSTATUS Status
);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryDebugFilterState(
	__in ULONG ComponentId,
	__in ULONG Level
);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetDebugFilterState(
	__in ULONG ComponentId,
	__in ULONG Level,
	__in BOOLEAN State
);
NTSYSAPI
NTSTATUS
NTAPI
ZwYieldExecution(
	VOID
);
NTSYSAPI
NTSTATUS
NTAPI
ZwCreatePort(
	__out PHANDLE PortHandle,
	__in POBJECT_ATTRIBUTES ObjectAttributes,
	__in ULONG MaxConnectionInfoLength,
	__in ULONG MaxMessageLength,
	__in_opt ULONG MaxPoolUsage
);
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateWaitablePort(
	__out PHANDLE PortHandle,
	__in POBJECT_ATTRIBUTES ObjectAttributes,
	__in ULONG MaxConnectionInfoLength,
	__in ULONG MaxMessageLength,
	__in_opt ULONG MaxPoolUsage
);

NTSYSAPI
NTSTATUS
NTAPI
ZwCompleteConnectPort(
	__in HANDLE PortHandle
);

NTSYSAPI
NTSTATUS
NTAPI
ZwCreateSection(
	__out PHANDLE SectionHandle,
	__in ACCESS_MASK DesiredAccess,
	__in_opt POBJECT_ATTRIBUTES ObjectAttributes,
	__in_opt PLARGE_INTEGER MaximumSize,
	__in ULONG SectionPageProtection,
	__in ULONG AllocationAttributes,
	__in_opt HANDLE FileHandle
);
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenSection(
	__out PHANDLE SectionHandle,
	__in ACCESS_MASK DesiredAccess,
	__in POBJECT_ATTRIBUTES ObjectAttributes
);
NTSYSAPI
NTSTATUS
NTAPI
ZwMapViewOfSection(
	__in HANDLE SectionHandle,
	__in HANDLE ProcessHandle,
	__inout PVOID *BaseAddress,
	__in ULONG_PTR ZeroBits,
	__in SIZE_T CommitSize,
	__inout_opt PLARGE_INTEGER SectionOffset,
	__inout PSIZE_T ViewSize,
	__in SECTION_INHERIT InheritDisposition,
	__in ULONG AllocationType,
	__in ULONG Win32Protect
);
NTSYSAPI
NTSTATUS
NTAPI
ZwUnmapViewOfSection(
	__in HANDLE ProcessHandle,
	__in PVOID BaseAddress
);
NTSYSAPI
NTSTATUS
NTAPI
ZwExtendSection(
	__in HANDLE SectionHandle,
	__inout PLARGE_INTEGER NewSectionSize
);
NTSYSAPI
NTSTATUS
NTAPI
ZwAreMappedFilesTheSame(
	__in PVOID File1MappedAsAnImage,
	__in PVOID File2MappedAsFile
);

NTSYSAPI
NTSTATUS
NTAPI
ZwReadVirtualMemory(
	__in HANDLE ProcessHandle,
	__in_opt PVOID BaseAddress,
	__out_bcount(BufferSize) PVOID Buffer,
	__in SIZE_T BufferSize,
	__out_opt PSIZE_T NumberOfBytesRead
);
NTSYSAPI
NTSTATUS
NTAPI
ZwWriteVirtualMemory(
	__in HANDLE ProcessHandle,
	__in_opt PVOID BaseAddress,
	__in_bcount(BufferSize) CONST VOID *Buffer,
	__in SIZE_T BufferSize,
	__out_opt PSIZE_T NumberOfBytesWritten
);
NTSYSAPI
NTSTATUS
NTAPI
ZwFlushVirtualMemory(
	__in HANDLE ProcessHandle,
	__inout PVOID *BaseAddress,
	__inout PSIZE_T RegionSize,
	__out PIO_STATUS_BLOCK IoStatus
);
NTSYSAPI
NTSTATUS
NTAPI
ZwLockVirtualMemory(
	__in HANDLE ProcessHandle,
	__inout PVOID *BaseAddress,
	__inout PSIZE_T RegionSize,
	__in ULONG MapType
);
NTSYSAPI
NTSTATUS
NTAPI
ZwUnlockVirtualMemory(
	__in HANDLE ProcessHandle,
	__inout PVOID *BaseAddress,
	__inout PSIZE_T RegionSize,
	__in ULONG MapType
);
NTSYSAPI
NTSTATUS
NTAPI
ZwProtectVirtualMemory(
	__in HANDLE ProcessHandle,
	__inout PVOID *BaseAddress,
	__inout PSIZE_T RegionSize,
	__in ULONG NewProtect,
	__out PULONG OldProtect
);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryVirtualMemory(
	__in HANDLE ProcessHandle,
	__in PVOID BaseAddress,
	__in MEMORY_INFORMATION_CLASS MemoryInformationClass,
	__out_bcount(MemoryInformationLength) PVOID MemoryInformation,
	__in SIZE_T MemoryInformationLength,
	__out_opt PSIZE_T ReturnLength
);
NTSYSAPI
NTSTATUS
NTAPI
ZwMapUserPhysicalPages(
	__in PVOID VirtualAddress,
	__in ULONG_PTR NumberOfPages,
	__in_ecount_opt(NumberOfPages) PULONG_PTR UserPfnArray
);
NTSYSAPI
NTSTATUS
NTAPI
ZwMapUserPhysicalPagesScatter(
	__in_ecount(NumberOfPages) PVOID *VirtualAddresses,
	__in ULONG_PTR NumberOfPages,
	__in_ecount_opt(NumberOfPages) PULONG_PTR UserPfnArray
);
NTSYSAPI
NTSTATUS
NTAPI
ZwAllocateUserPhysicalPages(
	__in HANDLE ProcessHandle,
	__inout PULONG_PTR NumberOfPages,
	__out_ecount(*NumberOfPages) PULONG_PTR UserPfnArray
);
NTSYSAPI
NTSTATUS
NTAPI
ZwFreeUserPhysicalPages(
	__in HANDLE ProcessHandle,
	__inout PULONG_PTR NumberOfPages,
	__in_ecount(*NumberOfPages) PULONG_PTR UserPfnArray
);
NTSYSAPI
NTSTATUS
NTAPI
ZwGetWriteWatch(
	__in HANDLE ProcessHandle,
	__in ULONG Flags,
	__in PVOID BaseAddress,
	__in SIZE_T RegionSize,
	__out_ecount(*EntriesInUserAddressArray) PVOID *UserAddressArray,
	__inout PULONG_PTR EntriesInUserAddressArray,
	__out PULONG Granularity
);
NTSYSAPI
NTSTATUS
NTAPI
ZwResetWriteWatch(
	__in HANDLE ProcessHandle,
	__in PVOID BaseAddress,
	__in SIZE_T RegionSize
);
NTSYSAPI
NTSTATUS
NTAPI
ZwCreatePagingFile(
	__in PUNICODE_STRING PageFileName,
	__in PLARGE_INTEGER MinimumSize,
	__in PLARGE_INTEGER MaximumSize,
	__in ULONG Priority
);
NTSYSAPI
NTSTATUS
NTAPI
ZwFlushInstructionCache(
	__in HANDLE ProcessHandle,
	__in_opt PVOID BaseAddress,
	__in SIZE_T Length
);
NTSYSAPI
NTSTATUS
NTAPI
ZwFlushWriteBuffer(
	VOID
);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryObject(
	__in HANDLE Handle,
	__in OBJECT_INFORMATION_CLASS ObjectInformationClass,
	__out_bcount_opt(ObjectInformationLength) PVOID ObjectInformation,
	__in ULONG ObjectInformationLength,
	__out_opt PULONG ReturnLength
);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetInformationObject(
	__in HANDLE Handle,
	__in OBJECT_INFORMATION_CLASS ObjectInformationClass,
	__in_bcount(ObjectInformationLength) PVOID ObjectInformation,
	__in ULONG ObjectInformationLength
);
NTSYSAPI
NTSTATUS
NTAPI
ZwDuplicateObject(
	__in HANDLE SourceProcessHandle,
	__in HANDLE SourceHandle,
	__in_opt HANDLE TargetProcessHandle,
	__out_opt PHANDLE TargetHandle,
	__in ACCESS_MASK DesiredAccess,
	__in ULONG HandleAttributes,
	__in ULONG Options
);
NTSYSAPI
NTSTATUS
NTAPI
ZwMakeTemporaryObject(
	__in HANDLE Handle
);
NTSYSAPI
NTSTATUS
NTAPI
ZwMakePermanentObject(
	__in HANDLE Handle
);
NTSYSAPI
NTSTATUS
NTAPI
ZwSignalAndWaitForSingleObject(
	__in HANDLE SignalHandle,
	__in HANDLE WaitHandle,
	__in BOOLEAN Alertable,
	__in_opt PLARGE_INTEGER Timeout
);
NTSYSAPI
NTSTATUS
NTAPI
ZwWaitForSingleObject(
	__in HANDLE Handle,
	__in BOOLEAN Alertable,
	__in_opt PLARGE_INTEGER Timeout
);
NTSYSAPI
NTSTATUS
NTAPI
ZwWaitForMultipleObjects(
	__in ULONG Count,
	__in_ecount(Count) HANDLE Handles[],
	__in WAIT_TYPE WaitType,
	__in BOOLEAN Alertable,
	__in_opt PLARGE_INTEGER Timeout
);
NTSYSAPI
NTSTATUS
NTAPI
ZwWaitForMultipleObjects32(
	__in ULONG Count,
	__in_ecount(Count) LONG Handles[],
	__in WAIT_TYPE WaitType,
	__in BOOLEAN Alertable,
	__in_opt PLARGE_INTEGER Timeout
);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetSecurityObject(
	__in HANDLE Handle,
	__in SECURITY_INFORMATION SecurityInformation,
	__in PSECURITY_DESCRIPTOR SecurityDescriptor
);
NTSYSAPI
NTSTATUS
NTAPI
ZwQuerySecurityObject(
	__in HANDLE Handle,
	__in SECURITY_INFORMATION SecurityInformation,
	__out_bcount_opt(Length) PSECURITY_DESCRIPTOR SecurityDescriptor,
	__in ULONG Length,
	__out PULONG LengthNeeded
);
NTSYSAPI
NTSTATUS
NTAPI
ZwClose(
	__in HANDLE Handle
);
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateDirectoryObject(
	__out PHANDLE DirectoryHandle,
	__in ACCESS_MASK DesiredAccess,
	__in POBJECT_ATTRIBUTES ObjectAttributes
);
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenDirectoryObject(
	__out PHANDLE DirectoryHandle,
	__in ACCESS_MASK DesiredAccess,
	__in POBJECT_ATTRIBUTES ObjectAttributes
);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryDirectoryObject(
	__in HANDLE DirectoryHandle,
	__out_bcount_opt(Length) PVOID Buffer,
	__in ULONG Length,
	__in BOOLEAN ReturnSingleEntry,
	__in BOOLEAN RestartScan,
	__inout PULONG Context,
	__out_opt PULONG ReturnLength
);
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateSymbolicLinkObject(
	__out PHANDLE LinkHandle,
	__in ACCESS_MASK DesiredAccess,
	__in POBJECT_ATTRIBUTES ObjectAttributes,
	__in PUNICODE_STRING LinkTarget
);
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenSymbolicLinkObject(
	__out PHANDLE LinkHandle,
	__in ACCESS_MASK DesiredAccess,
	__in POBJECT_ATTRIBUTES ObjectAttributes
);
NTSYSAPI
NTSTATUS
NTAPI
ZwQuerySymbolicLinkObject(
	__in HANDLE LinkHandle,
	__inout PUNICODE_STRING LinkTarget,
	__out_opt PULONG ReturnedLength
);

NTSYSAPI
NTSTATUS
NTAPI
ZwPowerInformation(
	__in POWER_INFORMATION_LEVEL InformationLevel,
	__in_bcount_opt(InputBufferLength) PVOID InputBuffer,
	__in ULONG InputBufferLength,
	__out_bcount_opt(OutputBufferLength) PVOID OutputBuffer,
	__in ULONG OutputBufferLength
);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetThreadExecutionState(
	__in EXECUTION_STATE esFlags,               // ES_xxx flags
	__out EXECUTION_STATE *PreviousFlags
);
NTSYSAPI
NTSTATUS
NTAPI
ZwRequestWakeupLatency(
	__in LATENCY_TIME latency
);
NTSYSAPI
NTSTATUS
NTAPI
ZwInitiatePowerAction(
	__in POWER_ACTION SystemAction,
	__in SYSTEM_POWER_STATE MinSystemState,
	__in ULONG Flags,                 // POWER_ACTION_xxx flags
	__in BOOLEAN Asynchronous
);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetSystemPowerState(
	__in POWER_ACTION SystemAction,
	__in SYSTEM_POWER_STATE MinSystemState,
	__in ULONG Flags                  // POWER_ACTION_xxx flags
);
NTSYSAPI
NTSTATUS
NTAPI
ZwGetDevicePowerState(
	__in HANDLE Device,
	__out DEVICE_POWER_STATE *State
);
NTSYSAPI
NTSTATUS
NTAPI
ZwCancelDeviceWakeupRequest(
	__in HANDLE Device
);
NTSYSAPI
NTSTATUS
NTAPI
ZwRequestDeviceWakeup(
	__in HANDLE Device
);
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateProcess(
	__out PHANDLE ProcessHandle,
	__in ACCESS_MASK DesiredAccess,
	__in_opt POBJECT_ATTRIBUTES ObjectAttributes,
	__in HANDLE ParentProcess,
	__in BOOLEAN InheritObjectTable,
	__in_opt HANDLE SectionHandle,
	__in_opt HANDLE DebugPort,
	__in_opt HANDLE ExceptionPort
);
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateProcessEx(
	__out PHANDLE ProcessHandle,
	__in ACCESS_MASK DesiredAccess,
	__in_opt POBJECT_ATTRIBUTES ObjectAttributes,
	__in HANDLE ParentProcess,
	__in ULONG Flags,
	__in_opt HANDLE SectionHandle,
	__in_opt HANDLE DebugPort,
	__in_opt HANDLE ExceptionPort,
	__in ULONG JobMemberLevel
);
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenProcess(
	__out PHANDLE ProcessHandle,
	__in ACCESS_MASK DesiredAccess,
	__in POBJECT_ATTRIBUTES ObjectAttributes,
	__in_opt PCLIENT_ID ClientId
);
NTSYSAPI
NTSTATUS
NTAPI
ZwTerminateProcess(
	__in_opt HANDLE ProcessHandle,
	__in NTSTATUS ExitStatus
);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryInformationProcess(
	__in HANDLE ProcessHandle,
	__in PROCESSINFOCLASS ProcessInformationClass,
	__out_bcount(ProcessInformationLength) PVOID ProcessInformation,
	__in ULONG ProcessInformationLength,
	__out_opt PULONG ReturnLength
);
NTSYSAPI
NTSTATUS
NTAPI
ZwGetNextProcess(
	__in HANDLE ProcessHandle,
	__in ACCESS_MASK DesiredAccess,
	__in ULONG HandleAttributes,
	__in ULONG Flags,
	__out PHANDLE NewProcessHandle
);
NTSYSAPI
NTSTATUS
NTAPI
ZwGetNextThread(
	__in HANDLE ProcessHandle,
	__in HANDLE ThreadHandle,
	__in ACCESS_MASK DesiredAccess,
	__in ULONG HandleAttributes,
	__in ULONG Flags,
	__out PHANDLE NewThreadHandle
);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryPortInformationProcess(
	VOID
);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetInformationProcess(
	__in HANDLE ProcessHandle,
	__in PROCESSINFOCLASS ProcessInformationClass,
	__in_bcount(ProcessInformationLength) PVOID ProcessInformation,
	__in ULONG ProcessInformationLength
);

NTSYSAPI
NTSTATUS
NTAPI
ZwOpenThread(
	__out PHANDLE ThreadHandle,
	__in ACCESS_MASK DesiredAccess,
	__in POBJECT_ATTRIBUTES ObjectAttributes,
	__in_opt PCLIENT_ID ClientId
);
NTSYSAPI
NTSTATUS
NTAPI
ZwTerminateThread(
	__in_opt HANDLE ThreadHandle,
	__in NTSTATUS ExitStatus
);
NTSYSAPI
NTSTATUS
NTAPI
ZwSuspendThread(
	__in HANDLE ThreadHandle,
	__out_opt PULONG PreviousSuspendCount
);
NTSYSAPI
NTSTATUS
NTAPI
ZwResumeThread(
	__in HANDLE ThreadHandle,
	__out_opt PULONG PreviousSuspendCount
);
NTSYSAPI
NTSTATUS
NTAPI
ZwSuspendProcess(
	__in HANDLE ProcessHandle
);
NTSYSAPI
NTSTATUS
NTAPI
ZwResumeProcess(
	__in HANDLE ProcessHandle
);
NTSYSAPI
NTSTATUS
NTAPI
ZwGetContextThread(
	__in HANDLE ThreadHandle,
	__inout PCONTEXT ThreadContext
);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetContextThread(
	__in HANDLE ThreadHandle,
	__in PCONTEXT ThreadContext
);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryInformationThread(
	__in HANDLE ThreadHandle,
	__in THREADINFOCLASS ThreadInformationClass,
	__out_bcount(ThreadInformationLength) PVOID ThreadInformation,
	__in ULONG ThreadInformationLength,
	__out_opt PULONG ReturnLength
);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetInformationThread(
	__in HANDLE ThreadHandle,
	__in THREADINFOCLASS ThreadInformationClass,
	__in_bcount(ThreadInformationLength) PVOID ThreadInformation,
	__in ULONG ThreadInformationLength
);
NTSYSAPI
NTSTATUS
NTAPI
ZwAlertThread(
	__in HANDLE ThreadHandle
);
NTSYSAPI
NTSTATUS
NTAPI
ZwAlertResumeThread(
	__in HANDLE ThreadHandle,
	__out_opt PULONG PreviousSuspendCount
);
NTSYSAPI
NTSTATUS
NTAPI
ZwImpersonateThread(
	__in HANDLE ServerThreadHandle,
	__in HANDLE ClientThreadHandle,
	__in PSECURITY_QUALITY_OF_SERVICE SecurityQos
);
NTSYSAPI
NTSTATUS
NTAPI
ZwTestAlert(
	VOID
);
NTSYSAPI
NTSTATUS
NTAPI
ZwRegisterThreadTerminatePort(
	__in HANDLE PortHandle
);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetLdtEntries(
	__in ULONG Selector0,
	__in ULONG Entry0Low,
	__in ULONG Entry0Hi,
	__in ULONG Selector1,
	__in ULONG Entry1Low,
	__in ULONG Entry1Hi
);

NTSYSAPI
NTSTATUS
NTAPI
ZwCreateJobObject(
	__out PHANDLE JobHandle,
	__in ACCESS_MASK DesiredAccess,
	__in_opt POBJECT_ATTRIBUTES ObjectAttributes
);
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenJobObject(
	__out PHANDLE JobHandle,
	__in ACCESS_MASK DesiredAccess,
	__in POBJECT_ATTRIBUTES ObjectAttributes
);
NTSYSAPI
NTSTATUS
NTAPI
ZwAssignProcessToJobObject(
	__in HANDLE JobHandle,
	__in HANDLE ProcessHandle
);
NTSYSAPI
NTSTATUS
NTAPI
ZwTerminateJobObject(
	__in HANDLE JobHandle,
	__in NTSTATUS ExitStatus
);
NTSYSAPI
NTSTATUS
NTAPI
ZwIsProcessInJob(
	__in HANDLE ProcessHandle,
	__in_opt HANDLE JobHandle
);

NTSYSAPI
NTSTATUS
NTAPI
ZwCreateKey(
	__out PHANDLE KeyHandle,
	__in ACCESS_MASK DesiredAccess,
	__in POBJECT_ATTRIBUTES ObjectAttributes,
	__reserved ULONG TitleIndex,
	__in_opt PUNICODE_STRING Class,
	__in ULONG CreateOptions,
	__out_opt PULONG Disposition
);
NTSYSAPI
NTSTATUS
NTAPI
ZwDeleteKey(
	__in HANDLE KeyHandle
);
NTSYSAPI
NTSTATUS
NTAPI
ZwDeleteValueKey(
	__in HANDLE KeyHandle,
	__in PUNICODE_STRING ValueName
);
NTSYSAPI
NTSTATUS
NTAPI
ZwEnumerateKey(
	__in HANDLE KeyHandle,
	__in ULONG Index,
	__in KEY_INFORMATION_CLASS KeyInformationClass,
	__out_bcount_opt(Length) PVOID KeyInformation,
	__in ULONG Length,
	__out PULONG ResultLength
);
NTSYSAPI
NTSTATUS
NTAPI
ZwEnumerateValueKey(
	__in HANDLE KeyHandle,
	__in ULONG Index,
	__in KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
	__out_bcount_opt(Length) PVOID KeyValueInformation,
	__in ULONG Length,
	__out PULONG ResultLength
);
NTSYSAPI
NTSTATUS
NTAPI
ZwFlushKey(
	__in HANDLE KeyHandle
);
NTSYSAPI
NTSTATUS
NTAPI
ZwInitializeRegistry(
	__in USHORT BootCondition
);
NTSYSAPI
NTSTATUS
NTAPI
ZwNotifyChangeKey(
	__in HANDLE KeyHandle,
	__in_opt HANDLE Event,
	__in_opt PIO_APC_ROUTINE ApcRoutine,
	__in_opt PVOID ApcContext,
	__out PIO_STATUS_BLOCK IoStatusBlock,
	__in ULONG CompletionFilter,
	__in BOOLEAN WatchTree,
	__out_bcount_opt(BufferSize) PVOID Buffer,
	__in ULONG BufferSize,
	__in BOOLEAN Asynchronous
);
NTSYSAPI
NTSTATUS
NTAPI
ZwNotifyChangeMultipleKeys(
	__in HANDLE MasterKeyHandle,
	__in_opt ULONG Count,
	__in_ecount_opt(Count) OBJECT_ATTRIBUTES SlaveObjects[],
	__in_opt HANDLE Event,
	__in_opt PIO_APC_ROUTINE ApcRoutine,
	__in_opt PVOID ApcContext,
	__out PIO_STATUS_BLOCK IoStatusBlock,
	__in ULONG CompletionFilter,
	__in BOOLEAN WatchTree,
	__out_bcount_opt(BufferSize) PVOID Buffer,
	__in ULONG BufferSize,
	__in BOOLEAN Asynchronous
);
NTSYSAPI
NTSTATUS
NTAPI
ZwLoadKey(
	__in POBJECT_ATTRIBUTES TargetKey,
	__in POBJECT_ATTRIBUTES SourceFile
);
NTSYSAPI
NTSTATUS
NTAPI
ZwLoadKey2(
	__in POBJECT_ATTRIBUTES   TargetKey,
	__in POBJECT_ATTRIBUTES   SourceFile,
	__in ULONG                Flags
);
NTSYSAPI
NTSTATUS
NTAPI
ZwLoadKeyEx(
	__in POBJECT_ATTRIBUTES   TargetKey,
	__in POBJECT_ATTRIBUTES   SourceFile,
	__in ULONG                Flags,
	__in_opt HANDLE           TrustClassKey
);
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenKey(
	__out PHANDLE KeyHandle,
	__in ACCESS_MASK DesiredAccess,
	__in POBJECT_ATTRIBUTES ObjectAttributes
);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryKey(
	__in HANDLE KeyHandle,
	__in KEY_INFORMATION_CLASS KeyInformationClass,
	__out_bcount_opt(Length) PVOID KeyInformation,
	__in ULONG Length,
	__out PULONG ResultLength
);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryValueKey(
	__in HANDLE KeyHandle,
	__in PUNICODE_STRING ValueName,
	__in KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
	__out_bcount_opt(Length) PVOID KeyValueInformation,
	__in ULONG Length,
	__out PULONG ResultLength
);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryMultipleValueKey(
	__in HANDLE KeyHandle,
	__inout_ecount(EntryCount) PKEY_VALUE_ENTRY ValueEntries,
	__in ULONG EntryCount,
	__out_bcount(*BufferLength) PVOID ValueBuffer,
	__inout PULONG BufferLength,
	__out_opt PULONG RequiredBufferLength
);
NTSYSAPI
NTSTATUS
NTAPI
ZwReplaceKey(
	__in POBJECT_ATTRIBUTES NewFile,
	__in HANDLE             TargetHandle,
	__in POBJECT_ATTRIBUTES OldFile
);
NTSYSAPI
NTSTATUS
NTAPI
ZwRenameKey(
	__in HANDLE           KeyHandle,
	__in PUNICODE_STRING  NewName
);
NTSYSAPI
NTSTATUS
NTAPI
ZwCompactKeys(
	__in ULONG Count,
	__in_ecount(Count) HANDLE KeyArray[]
);
NTSYSAPI
NTSTATUS
NTAPI
ZwCompressKey(
	__in HANDLE Key
);
NTSYSAPI
NTSTATUS
NTAPI
ZwRestoreKey(
	__in HANDLE KeyHandle,
	__in HANDLE FileHandle,
	__in ULONG Flags
);
NTSYSAPI
NTSTATUS
NTAPI
ZwSaveKey(
	__in HANDLE KeyHandle,
	__in HANDLE FileHandle
);
NTSYSAPI
NTSTATUS
NTAPI
ZwSaveKeyEx(
	__in HANDLE KeyHandle,
	__in HANDLE FileHandle,
	__in ULONG  Format
);
NTSYSAPI
NTSTATUS
NTAPI
ZwSaveMergedKeys(
	__in HANDLE HighPrecedenceKeyHandle,
	__in HANDLE LowPrecedenceKeyHandle,
	__in HANDLE FileHandle
);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetValueKey(
	__in HANDLE KeyHandle,
	__in PUNICODE_STRING ValueName,
	__in_opt ULONG TitleIndex,
	__in ULONG Type,
	__in_bcount_opt(DataSize) PVOID Data,
	__in ULONG DataSize
);
NTSYSAPI
NTSTATUS
NTAPI
ZwUnloadKey(
	__in POBJECT_ATTRIBUTES TargetKey
);
NTSYSAPI
NTSTATUS
NTAPI
ZwUnloadKey2(
	__in POBJECT_ATTRIBUTES   TargetKey,
	__in ULONG                Flags
);
NTSYSAPI
NTSTATUS
NTAPI
ZwUnloadKeyEx(
	__in POBJECT_ATTRIBUTES TargetKey,
	__in_opt HANDLE Event
);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetInformationKey(
	__in HANDLE KeyHandle,
	__in KEY_SET_INFORMATION_CLASS KeySetInformationClass,
	__in_bcount(KeySetInformationLength) PVOID KeySetInformation,
	__in ULONG KeySetInformationLength
);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryOpenSubKeys(
	__in POBJECT_ATTRIBUTES TargetKey,
	__out PULONG  HandleCount
);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryOpenSubKeysEx(
	__in POBJECT_ATTRIBUTES   TargetKey,
	__in ULONG                BufferLength,
	__out_bcount(BufferLength) PVOID               Buffer,
	__out PULONG              RequiredSize
);
NTSYSAPI
NTSTATUS
NTAPI
ZwLockRegistryKey(
	__in HANDLE           KeyHandle
);
NTSYSAPI
NTSTATUS
NTAPI
ZwLockProductActivationKeys(
	__inout_opt ULONG   *pPrivateVer,
	__out_opt ULONG   *pSafeMode
);
NTSYSAPI
NTSTATUS
NTAPI
ZwAccessCheck(
	__in PSECURITY_DESCRIPTOR SecurityDescriptor,
	__in HANDLE ClientToken,
	__in ACCESS_MASK DesiredAccess,
	__in PGENERIC_MAPPING GenericMapping,
	__out_bcount(*PrivilegeSetLength) PPRIVILEGE_SET PrivilegeSet,
	__inout PULONG PrivilegeSetLength,
	__out PACCESS_MASK GrantedAccess,
	__out PNTSTATUS AccessStatus
);
NTSYSAPI
NTSTATUS
NTAPI
ZwAccessCheckByType(
	__in PSECURITY_DESCRIPTOR SecurityDescriptor,
	__in_opt PSID PrincipalSelfSid,
	__in HANDLE ClientToken,
	__in ACCESS_MASK DesiredAccess,
	__in_ecount(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
	__in ULONG ObjectTypeListLength,
	__in PGENERIC_MAPPING GenericMapping,
	__out_bcount(*PrivilegeSetLength) PPRIVILEGE_SET PrivilegeSet,
	__inout PULONG PrivilegeSetLength,
	__out PACCESS_MASK GrantedAccess,
	__out PNTSTATUS AccessStatus
);
NTSYSAPI
NTSTATUS
NTAPI
ZwAccessCheckByTypeResultList(
	__in PSECURITY_DESCRIPTOR SecurityDescriptor,
	__in_opt PSID PrincipalSelfSid,
	__in HANDLE ClientToken,
	__in ACCESS_MASK DesiredAccess,
	__in_ecount(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
	__in ULONG ObjectTypeListLength,
	__in PGENERIC_MAPPING GenericMapping,
	__out_bcount(*PrivilegeSetLength) PPRIVILEGE_SET PrivilegeSet,
	__inout PULONG PrivilegeSetLength,
	__out_ecount(ObjectTypeListLength) PACCESS_MASK GrantedAccess,
	__out_ecount(ObjectTypeListLength) PNTSTATUS AccessStatus
);
NTSYSAPI
NTSTATUS
NTAPI
ZwCreateToken(
	__out PHANDLE TokenHandle,
	__in ACCESS_MASK DesiredAccess,
	__in_opt POBJECT_ATTRIBUTES ObjectAttributes,
	__in TOKEN_TYPE TokenType,
	__in PLUID AuthenticationId,
	__in PLARGE_INTEGER ExpirationTime,
	__in PTOKEN_USER User,
	__in PTOKEN_GROUPS Groups,
	__in PTOKEN_PRIVILEGES Privileges,
	__in_opt PTOKEN_OWNER Owner,
	__in PTOKEN_PRIMARY_GROUP PrimaryGroup,
	__in_opt PTOKEN_DEFAULT_DACL DefaultDacl,
	__in PTOKEN_SOURCE TokenSource
);
NTSYSAPI
NTSTATUS
NTAPI
ZwCompareTokens(
	__in HANDLE FirstTokenHandle,
	__in HANDLE SecondTokenHandle,
	__out PBOOLEAN Equal
);
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenThreadToken(
	__in HANDLE ThreadHandle,
	__in ACCESS_MASK DesiredAccess,
	__in BOOLEAN OpenAsSelf,
	__out PHANDLE TokenHandle
);
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenThreadTokenEx(
	__in HANDLE ThreadHandle,
	__in ACCESS_MASK DesiredAccess,
	__in BOOLEAN OpenAsSelf,
	__in ULONG HandleAttributes,
	__out PHANDLE TokenHandle
);
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenProcessToken(
	__in HANDLE ProcessHandle,
	__in ACCESS_MASK DesiredAccess,
	__out PHANDLE TokenHandle
);
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenProcessTokenEx(
	__in HANDLE ProcessHandle,
	__in ACCESS_MASK DesiredAccess,
	__in ULONG HandleAttributes,
	__out PHANDLE TokenHandle
);
NTSYSAPI
NTSTATUS
NTAPI
ZwDuplicateToken(
	__in HANDLE ExistingTokenHandle,
	__in ACCESS_MASK DesiredAccess,
	__in POBJECT_ATTRIBUTES ObjectAttributes,
	__in BOOLEAN EffectiveOnly,
	__in TOKEN_TYPE TokenType,
	__out PHANDLE NewTokenHandle
);
NTSYSAPI
NTSTATUS
NTAPI
ZwFilterToken(
	__in HANDLE ExistingTokenHandle,
	__in ULONG Flags,
	__in_opt PTOKEN_GROUPS SidsToDisable,
	__in_opt PTOKEN_PRIVILEGES PrivilegesToDelete,
	__in_opt PTOKEN_GROUPS RestrictedSids,
	__out PHANDLE NewTokenHandle
);
NTSYSAPI
NTSTATUS
NTAPI
ZwImpersonateAnonymousToken(
	__in HANDLE ThreadHandle
);
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryInformationToken(
	__in HANDLE TokenHandle,
	__in TOKEN_INFORMATION_CLASS TokenInformationClass,
	__out_bcount_part_opt(TokenInformationLength, *ReturnLength) PVOID TokenInformation,
	__in ULONG TokenInformationLength,
	__out PULONG ReturnLength
);
NTSYSAPI
NTSTATUS
NTAPI
ZwSetInformationToken(
	__in HANDLE TokenHandle,
	__in TOKEN_INFORMATION_CLASS TokenInformationClass,
	__in_bcount(TokenInformationLength) PVOID TokenInformation,
	__in ULONG TokenInformationLength
);
NTSYSAPI
NTSTATUS
NTAPI
ZwAdjustPrivilegesToken(
	__in HANDLE TokenHandle,
	__in BOOLEAN DisableAllPrivileges,
	__in_opt PTOKEN_PRIVILEGES NewState,
	__in_opt ULONG BufferLength,
	__out_bcount_part_opt(BufferLength, *ReturnLength) PTOKEN_PRIVILEGES PreviousState,
	__out_opt PULONG ReturnLength
);
NTSYSAPI
NTSTATUS
NTAPI
ZwAdjustGroupsToken(
	__in HANDLE TokenHandle,
	__in BOOLEAN ResetToDefault,
	__in PTOKEN_GROUPS NewState,
	__in_opt ULONG BufferLength,
	__out_bcount_part_opt(BufferLength, *ReturnLength) PTOKEN_GROUPS PreviousState,
	__out PULONG ReturnLength
);
NTSYSAPI
NTSTATUS
NTAPI
ZwPrivilegeCheck(
	__in HANDLE ClientToken,
	__inout PPRIVILEGE_SET RequiredPrivileges,
	__out PBOOLEAN Result
);
NTSYSAPI
NTSTATUS
NTAPI
ZwAccessCheckAndAuditAlarm(
	__in PUNICODE_STRING SubsystemName,
	__in_opt PVOID HandleId,
	__in PUNICODE_STRING ObjectTypeName,
	__in PUNICODE_STRING ObjectName,
	__in PSECURITY_DESCRIPTOR SecurityDescriptor,
	__in ACCESS_MASK DesiredAccess,
	__in PGENERIC_MAPPING GenericMapping,
	__in BOOLEAN ObjectCreation,
	__out PACCESS_MASK GrantedAccess,
	__out PNTSTATUS AccessStatus,
	__out PBOOLEAN GenerateOnClose
);
NTSYSAPI
NTSTATUS
NTAPI
ZwAccessCheckByTypeAndAuditAlarm(
	__in PUNICODE_STRING SubsystemName,
	__in_opt PVOID HandleId,
	__in PUNICODE_STRING ObjectTypeName,
	__in PUNICODE_STRING ObjectName,
	__in PSECURITY_DESCRIPTOR SecurityDescriptor,
	__in_opt PSID PrincipalSelfSid,
	__in ACCESS_MASK DesiredAccess,
	__in AUDIT_EVENT_TYPE AuditType,
	__in ULONG Flags,
	__in_ecount_opt(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
	__in ULONG ObjectTypeListLength,
	__in PGENERIC_MAPPING GenericMapping,
	__in BOOLEAN ObjectCreation,
	__out PACCESS_MASK GrantedAccess,
	__out PNTSTATUS AccessStatus,
	__out PBOOLEAN GenerateOnClose
);
NTSYSAPI
NTSTATUS
NTAPI
ZwAccessCheckByTypeResultListAndAuditAlarm(
	__in PUNICODE_STRING SubsystemName,
	__in_opt PVOID HandleId,
	__in PUNICODE_STRING ObjectTypeName,
	__in PUNICODE_STRING ObjectName,
	__in PSECURITY_DESCRIPTOR SecurityDescriptor,
	__in_opt PSID PrincipalSelfSid,
	__in ACCESS_MASK DesiredAccess,
	__in AUDIT_EVENT_TYPE AuditType,
	__in ULONG Flags,
	__in_ecount_opt(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
	__in ULONG ObjectTypeListLength,
	__in PGENERIC_MAPPING GenericMapping,
	__in BOOLEAN ObjectCreation,
	__out_ecount(ObjectTypeListLength) PACCESS_MASK GrantedAccess,
	__out_ecount(ObjectTypeListLength) PNTSTATUS AccessStatus,
	__out PBOOLEAN GenerateOnClose
);
NTSYSAPI
NTSTATUS
NTAPI
ZwAccessCheckByTypeResultListAndAuditAlarmByHandle(
	__in PUNICODE_STRING SubsystemName,
	__in_opt PVOID HandleId,
	__in HANDLE ClientToken,
	__in PUNICODE_STRING ObjectTypeName,
	__in PUNICODE_STRING ObjectName,
	__in PSECURITY_DESCRIPTOR SecurityDescriptor,
	__in_opt PSID PrincipalSelfSid,
	__in ACCESS_MASK DesiredAccess,
	__in AUDIT_EVENT_TYPE AuditType,
	__in ULONG Flags,
	__in_ecount_opt(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
	__in ULONG ObjectTypeListLength,
	__in PGENERIC_MAPPING GenericMapping,
	__in BOOLEAN ObjectCreation,
	__out_ecount(ObjectTypeListLength) PACCESS_MASK GrantedAccess,
	__out_ecount(ObjectTypeListLength) PNTSTATUS AccessStatus,
	__out PBOOLEAN GenerateOnClose
);
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenObjectAuditAlarm(
	__in PUNICODE_STRING SubsystemName,
	__in_opt PVOID HandleId,
	__in PUNICODE_STRING ObjectTypeName,
	__in PUNICODE_STRING ObjectName,
	__in_opt PSECURITY_DESCRIPTOR SecurityDescriptor,
	__in HANDLE ClientToken,
	__in ACCESS_MASK DesiredAccess,
	__in ACCESS_MASK GrantedAccess,
	__in_opt PPRIVILEGE_SET Privileges,
	__in BOOLEAN ObjectCreation,
	__in BOOLEAN AccessGranted,
	__out PBOOLEAN GenerateOnClose
);
NTSYSAPI
NTSTATUS
NTAPI
ZwPrivilegeObjectAuditAlarm(
	__in PUNICODE_STRING SubsystemName,
	__in_opt PVOID HandleId,
	__in HANDLE ClientToken,
	__in ACCESS_MASK DesiredAccess,
	__in PPRIVILEGE_SET Privileges,
	__in BOOLEAN AccessGranted
);
NTSYSAPI
NTSTATUS
NTAPI
ZwCloseObjectAuditAlarm(
	__in PUNICODE_STRING SubsystemName,
	__in_opt PVOID HandleId,
	__in BOOLEAN GenerateOnClose
);
NTSYSAPI
NTSTATUS
NTAPI
ZwDeleteObjectAuditAlarm(
	__in PUNICODE_STRING SubsystemName,
	__in_opt PVOID HandleId,
	__in BOOLEAN GenerateOnClose
);
NTSYSAPI
NTSTATUS
NTAPI
ZwPrivilegedServiceAuditAlarm(
	__in PUNICODE_STRING SubsystemName,
	__in PUNICODE_STRING ServiceName,
	__in HANDLE ClientToken,
	__in PPRIVILEGE_SET Privileges,
	__in BOOLEAN AccessGranted
);
NTSYSAPI
NTSTATUS
NTAPI
ZwTraceEvent(
	__in HANDLE TraceHandle,
	__in ULONG Flags,
	__in ULONG FieldSize,
	__in PVOID Fields
);
NTSYSAPI
NTSTATUS
NTAPI
ZwContinue(
	__in PCONTEXT ContextRecord,
	__in BOOLEAN TestAlert
);
NTSYSAPI
NTSTATUS
NTAPI
ZwRaiseException(
	__in PEXCEPTION_RECORD ExceptionRecord,
	__in PCONTEXT ContextRecord,
	__in BOOLEAN FirstChance
);

NTSTATUS NTAPI MmCopyVirtualMemory
(
	PEPROCESS SourceProcess,
	PVOID SourceAddress,
	PEPROCESS TargetProcess,
	PVOID TargetAddress,
	SIZE_T BufferSize,
	KPROCESSOR_MODE PreviousMode,
	PSIZE_T ReturnSize
);
```

`EftDriver/Driver/x64/Release/Driver.Build.CppClean.log`:

```log
c:\users\kev\desktop\rattismo\kernelbhopwithwriter\driver\x64\release\driver.obj
c:\users\kev\desktop\rattismo\kernelbhopwithwriter\driver\x64\release\driver.ipdb
c:\users\kev\desktop\rattismo\kernelbhopwithwriter\driver\x64\release\driver.iobj
c:\users\kev\desktop\rattismo\kernelbhopwithwriter\driver\x64\release\driver.tlog\cl.command.1.tlog
c:\users\kev\desktop\rattismo\kernelbhopwithwriter\driver\x64\release\driver.tlog\cl.read.1.tlog
c:\users\kev\desktop\rattismo\kernelbhopwithwriter\driver\x64\release\driver.tlog\cl.write.1.tlog
c:\users\kev\desktop\rattismo\kernelbhopwithwriter\driver\x64\release\driver.tlog\link.command.1.tlog
c:\users\kev\desktop\rattismo\kernelbhopwithwriter\driver\x64\release\driver.tlog\link.read.1.tlog
c:\users\kev\desktop\rattismo\kernelbhopwithwriter\driver\x64\release\driver.tlog\link.write.1.tlog

```

`EftDriver/Driver/x64/Release/Driver.log`:

```log
  Building 'EftDriver' with toolset 'WindowsKernelModeDriver10.0' and the 'Universal' target platform.
C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\MSBuild\Microsoft\VC\v160\Microsoft.CppBuild.targets(499,5): warning MSB8004: Output Directory does not end with a trailing slash.  This build instance will add the slash as it is required to allow proper evaluation of the Output Directory.
  Driver.c
C:\Users\kev\Desktop\GAMEHACKING\EFT HACKING\EftDriver\Driver\ntos.h(1147,2): warning C4273: 'ZwAllocateVirtualMemory': inconsistent dll linkage
C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\km\ntifs.h(29463,1): message : see previous definition of 'ZwAllocateVirtualMemory'
C:\Users\kev\Desktop\GAMEHACKING\EFT HACKING\EftDriver\Driver\ntos.h(1153,2): warning C4273: 'ZwFreeVirtualMemory': inconsistent dll linkage
C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\km\ntifs.h(29498,1): message : see previous definition of 'ZwFreeVirtualMemory'
C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime.h(61,26): warning C4083: expected ')'; found identifier '_VCRUNTIME_DISABLED_WARNINGS'
C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime.h(111,1): warning C4005: '_CRT_STRINGIZE': macro redefinition
C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\km\crt\crtdefs.h(85): message : see previous definition of '_CRT_STRINGIZE'
C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime.h(114,1): warning C4005: '_CRT_WIDE': macro redefinition
C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\km\crt\crtdefs.h(88): message : see previous definition of '_CRT_WIDE'
C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime.h(155,1): warning C4005: '__CRTDECL': macro redefinition
C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\km\crt\crtdefs.h(640): message : see previous definition of '__CRTDECL'
C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\stdint.h(16,26): warning C4083: expected ')'; found identifier '_VCRUNTIME_DISABLED_WARNINGS'
Driver.c(88,1): warning C4047: 'function': 'PSIZE_T' differs in levels of indirection from 'PSIZE_T *'
Driver.c(87,1): warning C4024: 'MmCopyVirtualMemory': different types for formal and actual parameter 7
Driver.c(106,40): warning C4022: 'PsLookupProcessByProcessId': pointer mismatch for actual parameter 1
Driver.c(107,40): warning C4022: 'PsLookupProcessByProcessId': pointer mismatch for actual parameter 1
Driver.c(108,58): warning C4022: 'KeWriteVirtualMemory': pointer mismatch for actual parameter 2
Driver.c(108,98): warning C4022: 'KeWriteVirtualMemory': pointer mismatch for actual parameter 4
Driver.c(118,43): warning C4022: 'PsLookupProcessByProcessId': pointer mismatch for actual parameter 1
Driver.c(119,43): warning C4022: 'PsLookupProcessByProcessId': pointer mismatch for actual parameter 1
Driver.c(123,88): warning C4022: 'KeWriteVirtualMemory': pointer mismatch for actual parameter 4
Driver.c(94,35): warning C4100: 'DeviceObject': unreferenced formal parameter
Driver.c(117,12): warning C4101: 'status': unreferenced local variable
Driver.c(137,18): warning C4100: 'pRegistryPath': unreferenced formal parameter
Driver.c(159,95): warning C4113: 'void (__cdecl *)()' differs in parameter lists from 'PKSTART_ROUTINE'
Driver.c(157,68): warning C4100: 'RegistryPath': unreferenced formal parameter
Driver.c(157,37): warning C4100: 'pDriverObject': unreferenced formal parameter
Driver.c(162,36): warning C4100: 'DeviceObject': unreferenced formal parameter
Driver.c(170,35): warning C4100: 'DeviceObject': unreferenced formal parameter
  Generating code
  Previous IPDB not found, fall back to full compilation.
C:\Users\kev\Desktop\GAMEHACKING\EFT HACKING\EftDriver\Driver\Driver.c(130): warning C4701: potentially uninitialized local variable 'Status' used
  All 9 functions were compiled because no usable IPDB/IOBJ from previous compilation was found.
  Finished generating code
  Driver.vcxproj -> C:\Users\kev\Desktop\GAMEHACKING\EFT HACKING\EftDriver\Release\EftDriver.sys

```

`EftDriver/Driver/x64/Release/EftDriver.Build.CppClean.log`:

```log
c:\users\kev\desktop\gamehacking\eft hacking\eftdriver\driver\x64\release\driver.obj
c:\users\kev\desktop\gamehacking\eft hacking\eftdriver\release\eftdriver.sys
c:\users\kev\desktop\gamehacking\eft hacking\eftdriver\driver\x64\release\eftdriver.ipdb
c:\users\kev\desktop\gamehacking\eft hacking\eftdriver\driver\x64\release\eftdriver.iobj
c:\users\kev\desktop\gamehacking\eft hacking\eftdriver\driver\x64\release\eftdriver.tlog\cl.command.1.tlog
c:\users\kev\desktop\gamehacking\eft hacking\eftdriver\driver\x64\release\eftdriver.tlog\cl.read.1.tlog
c:\users\kev\desktop\gamehacking\eft hacking\eftdriver\driver\x64\release\eftdriver.tlog\cl.write.1.tlog
c:\users\kev\desktop\gamehacking\eft hacking\eftdriver\driver\x64\release\eftdriver.tlog\link.command.1.tlog
c:\users\kev\desktop\gamehacking\eft hacking\eftdriver\driver\x64\release\eftdriver.tlog\link.read.1.tlog
c:\users\kev\desktop\gamehacking\eft hacking\eftdriver\driver\x64\release\eftdriver.tlog\link.write.1.tlog

```

`EftDriver/Driver/x64/Release/EftDriver.sys.recipe`:

```recipe
<?xml version="1.0" encoding="utf-8"?>
<Project>
  <ProjectOutputs>
    <ProjectOutput>
      <FullPath>C:\Users\kev\Desktop\GAMEHACKING\EFT HACKING\EftDriver\Release\EftDriver.sys</FullPath>
    </ProjectOutput>
  </ProjectOutputs>
  <ContentFiles />
  <SatelliteDlls />
  <NonRecipeFileRefs />
</Project>
```

`EftDriver/Driver/x64/Release/EftDriver.tlog/CL.command.1.tlog`:

```tlog
^C:\USERS\KEV\DESKTOP\GAMEHACKING\EFT HACKING\EFTDRIVER\DRIVER\DRIVER.C
/c /IX64\RELEASE\ /nologo /W4 /WX- /diagnostics:column /O1 /Os /Oy- /GL /D _WIN64 /D _AMD64_ /D AMD64 /D _WIN32_WINNT=0x0A00 /D WINVER=0x0A00 /D WINNT=1 /D NTDDI_VERSION=0xA00000B /D KMDF_VERSION_MAJOR=1 /D KMDF_VERSION_MINOR=15 /GF /Gm- /Zp8 /GS- /guard:cf /Gy /fp:precise /Zc:wchar_t- /Zc:forScope /Zc:inline /GR- /Fo"X64\RELEASE\\" /Fd"AVAST.PDB" /external:W4 /Gz /wd4603 /wd4627 /wd4986 /wd4987 /FI"C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\WARNING.H" /kernel -cbstring -d2epilogunwind  /d1nodatetime /d1import_no_registry /d2AllowCompatibleILVersions /d2Zi+  C:\USERS\KEV\DESKTOP\GAMEHACKING\EFT HACKING\EFTDRIVER\DRIVER\DRIVER.C

```

`EftDriver/Driver/x64/Release/EftDriver.tlog/CL.read.1.tlog`:

```tlog
^C:\USERS\KEV\DESKTOP\GAMEHACKING\EFT HACKING\EFTDRIVER\DRIVER\DRIVER.C
C:\WINDOWS\GLOBALIZATION\SORTING\SORTDEFAULT.NLS
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\BIN\HOSTX86\X64\1033\CLUI.DLL
C:\WINDOWS\SYSTEM32\TZRES.DLL
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\WARNING.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\SUPPRESS.H
C:\USERS\KEV\DESKTOP\GAMEHACKING\EFT HACKING\EFTDRIVER\DRIVER\NTOS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\NTDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\KM\CRT\CTYPE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\KM\CRT\CRTDEFS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\SPECSTRINGS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\SAL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\CONCURRENCYSAL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\SPECSTRINGS_STRICT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\SPECSTRINGS_UNDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\DRIVERSPECS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\SDV_DRIVERSPECS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\KM\CRT\VADEFS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\WINAPIFAMILY.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\WINPACKAGEFAMILY.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\KERNELSPECS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\BASETSD.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\GUIDDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\KM\CRT\STRING.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\KM\CRT\EXCPT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\SDKDDKVER.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\KM\NTIFS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\KM\NTDDK.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\KM\WDM.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\NTSTATUS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\BUGCODES.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\NTIOLOGC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\KM\MCE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\PSHPACK4.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\POPPACK.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\PSHPACK1.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\DPFILTER.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\APISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\KTMTYPES.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\EVNTPROV.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\DEVPROPDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\KM\NTNLS.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\STDINT.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\VCRUNTIME.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\KM\NTSTRSAFE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\KM\CRT\STDIO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\KM\CRT\SWPRINTF.INL
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\KM\CRT\STDARG.H
C:\USERS\KEV\DESKTOP\GAMEHACKING\EFT HACKING\EFTDRIVER\DRIVER\IMPORTS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\KM\CRT\INTRIN.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\KM\CRT\SETJMP.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\KM\CRT\STDDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\KM\CRT\IMMINTRIN.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\KM\CRT\WMMINTRIN.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\KM\CRT\NMMINTRIN.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\KM\CRT\SMMINTRIN.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\KM\CRT\TMMINTRIN.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\KM\CRT\PMMINTRIN.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\KM\CRT\EMMINTRIN.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\KM\CRT\XMMINTRIN.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\KM\CRT\MMINTRIN.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\KM\CRT\MALLOC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\KM\CRT\LIMITS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\KM\CRT\ZMMINTRIN.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\KM\CRT\AMMINTRIN.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\KM\CRT\STDLIB.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\WINDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\MINWINDEF.H

```

`EftDriver/Driver/x64/Release/EftDriver.tlog/CL.write.1.tlog`:

```tlog
^C:\USERS\KEV\DESKTOP\GAMEHACKING\EFT HACKING\EFTDRIVER\DRIVER\DRIVER.C
C:\USERS\KEV\DESKTOP\GAMEHACKING\EFT HACKING\EFTDRIVER\DRIVER\X64\RELEASE\DRIVER.OBJ

```

`EftDriver/Driver/x64/Release/EftDriver.tlog/EftDriver.lastbuildstate`:

```lastbuildstate
PlatformToolSet=WindowsKernelModeDriver10.0:VCToolArchitecture=Native32Bit:VCToolsVersion=14.29.30133:VCServicingVersionCrtHeaders=14.29.30136:TargetPlatformVersion=10.0.22000.0:
Release|x64|C:\Users\kev\Desktop\GAMEHACKING\EFT HACKING\EftDriver\|

```

`EftDriver/Driver/x64/Release/EftDriver.tlog/link.command.1.tlog`:

```tlog
^C:\USERS\KEV\DESKTOP\GAMEHACKING\EFT HACKING\EFTDRIVER\DRIVER\X64\RELEASE\DRIVER.OBJ
/OUT:"..\RELEASE\EFTDRIVER.SYS" /VERSION:"10.0" /INCREMENTAL:NO /NOLOGO /WX /SECTION:"INIT,d" "C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.22000.0\KM\X64\BUFFEROVERFLOWFASTFAILK.LIB" "C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.22000.0\KM\X64\NTOSKRNL.LIB" "C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.22000.0\KM\X64\HAL.LIB" "C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.22000.0\KM\X64\WMILIB.LIB" "C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\WDF\KMDF\X64\1.15\WDFLDR.LIB" "C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\WDF\KMDF\X64\1.15\WDFDRIVERENTRY.LIB" /NODEFAULTLIB /MANIFEST:NO /SUBSYSTEM:NATIVE,"10.00" /Driver /OPT:REF /OPT:ICF /LTCG:incremental /LTCGOUT:"X64\RELEASE\EFTDRIVER.IOBJ" /WINMD:NO /ENTRY:"DriverEntry" /RELEASE /IMPLIB:"..\RELEASE\EFTDRIVER.LIB" /MERGE:"_TEXT=.text;_PAGE=PAGE" /MACHINE:X64 /guard:cf /kernel /IGNORE:4198,4010,4037,4039,4065,4070,4078,4087,4089,4221,4108,4088,4218,4218,4235 /osversion:10.0 /pdbcompress /debugtype:pdata X64\RELEASE\DRIVER.OBJ

```

`EftDriver/Driver/x64/Release/EftDriver.tlog/link.read.1.tlog`:

```tlog
^C:\USERS\KEV\DESKTOP\GAMEHACKING\EFT HACKING\EFTDRIVER\DRIVER\X64\RELEASE\DRIVER.OBJ
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.22000.0\KM\X64\BUFFEROVERFLOWFASTFAILK.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.22000.0\KM\X64\NTOSKRNL.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.22000.0\KM\X64\HAL.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.22000.0\KM\X64\WMILIB.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\WDF\KMDF\X64\1.15\WDFLDR.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\WDF\KMDF\X64\1.15\WDFDRIVERENTRY.LIB
C:\USERS\KEV\DESKTOP\GAMEHACKING\EFT HACKING\EFTDRIVER\DRIVER\X64\RELEASE\DRIVER.OBJ
C:\WINDOWS\GLOBALIZATION\SORTING\SORTDEFAULT.NLS
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\BIN\HOSTX86\X64\C2.DLL
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\BIN\HOSTX86\X64\1033\LINKUI.DLL
C:\WINDOWS\SYSTEM32\TZRES.DLL
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\BIN\HOSTX86\X64\1033\CLUI.DLL

```

`EftDriver/Driver/x64/Release/EftDriver.tlog/link.write.1.tlog`:

```tlog
^C:\USERS\KEV\DESKTOP\GAMEHACKING\EFT HACKING\EFTDRIVER\DRIVER\X64\RELEASE\DRIVER.OBJ
C:\USERS\KEV\DESKTOP\GAMEHACKING\EFT HACKING\EFTDRIVER\RELEASE\EFTDRIVER.SYS
C:\USERS\KEV\DESKTOP\GAMEHACKING\EFT HACKING\EFTDRIVER\DRIVER\X64\RELEASE\EFTDRIVER.IPDB
C:\USERS\KEV\DESKTOP\GAMEHACKING\EFT HACKING\EFTDRIVER\DRIVER\X64\RELEASE\EFTDRIVER.IOBJ

```

`EftDriver/EftDriver.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31624.102
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Driver", "Driver\Driver.vcxproj", "{23F27013-5E01-4B4D-88D4-932C0D775DAA}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{23F27013-5E01-4B4D-88D4-932C0D775DAA}.Debug|ARM.ActiveCfg = Debug|ARM
		{23F27013-5E01-4B4D-88D4-932C0D775DAA}.Debug|ARM.Build.0 = Debug|ARM
		{23F27013-5E01-4B4D-88D4-932C0D775DAA}.Debug|ARM.Deploy.0 = Debug|ARM
		{23F27013-5E01-4B4D-88D4-932C0D775DAA}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{23F27013-5E01-4B4D-88D4-932C0D775DAA}.Debug|ARM64.Build.0 = Debug|ARM64
		{23F27013-5E01-4B4D-88D4-932C0D775DAA}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{23F27013-5E01-4B4D-88D4-932C0D775DAA}.Debug|x64.ActiveCfg = Debug|x64
		{23F27013-5E01-4B4D-88D4-932C0D775DAA}.Debug|x64.Build.0 = Debug|x64
		{23F27013-5E01-4B4D-88D4-932C0D775DAA}.Debug|x64.Deploy.0 = Debug|x64
		{23F27013-5E01-4B4D-88D4-932C0D775DAA}.Debug|x86.ActiveCfg = Debug|Win32
		{23F27013-5E01-4B4D-88D4-932C0D775DAA}.Debug|x86.Build.0 = Debug|Win32
		{23F27013-5E01-4B4D-88D4-932C0D775DAA}.Debug|x86.Deploy.0 = Debug|Win32
		{23F27013-5E01-4B4D-88D4-932C0D775DAA}.Release|ARM.ActiveCfg = Release|ARM
		{23F27013-5E01-4B4D-88D4-932C0D775DAA}.Release|ARM.Build.0 = Release|ARM
		{23F27013-5E01-4B4D-88D4-932C0D775DAA}.Release|ARM.Deploy.0 = Release|ARM
		{23F27013-5E01-4B4D-88D4-932C0D775DAA}.Release|ARM64.ActiveCfg = Release|ARM64
		{23F27013-5E01-4B4D-88D4-932C0D775DAA}.Release|ARM64.Build.0 = Release|ARM64
		{23F27013-5E01-4B4D-88D4-932C0D775DAA}.Release|ARM64.Deploy.0 = Release|ARM64
		{23F27013-5E01-4B4D-88D4-932C0D775DAA}.Release|x64.ActiveCfg = Release|x64
		{23F27013-5E01-4B4D-88D4-932C0D775DAA}.Release|x64.Build.0 = Release|x64
		{23F27013-5E01-4B4D-88D4-932C0D775DAA}.Release|x64.Deploy.0 = Release|x64
		{23F27013-5E01-4B4D-88D4-932C0D775DAA}.Release|x86.ActiveCfg = Release|Win32
		{23F27013-5E01-4B4D-88D4-932C0D775DAA}.Release|x86.Build.0 = Release|Win32
		{23F27013-5E01-4B4D-88D4-932C0D775DAA}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {4CD85E3A-72A0-48BD-A507-33F03F796475}
	EndGlobalSection
EndGlobal

```

`LICENSE`:

```
MIT License

Copyright (c) 2022 imxyvi

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# EftStreamedCheat
This is a cheat for EFT, it uses windows socket to pass the values read by the driver into server.exe and then into the other computer or virtual machine running client.exe.
This is a very undetected way of making a cheat because if the anticheat takes screenshots it will never be able to catch your ESP since it will be drawn on the other PC (running client.exe) for example.
The code is messy it needs to be fixed


Credits:
coltonon for making D2D -> in case you need to recompile the D2D lib file : https://github.com/coltonon/D2DOverlay

```