Project Path: arc_yardenshafir_WinDbg_Scripts_h80flrg9

Source Tree:

```txt
arc_yardenshafir_WinDbg_Scripts_h80flrg9
├── EtwAllRegisteredTraceGuids
├── EtwConsumersForProcesses
├── EtwPrintNotificationGuids.txt
├── EtwPrintRegisteredProvidersForNotificationGuid.txt
├── EtwRegisteredProvidersForProcess
├── FilterCommsHelpers.txt
├── FindLookasideLists.txt
├── FindNonSystem32Modules.txt
├── FindResourcesInPool.txt
├── FindSymbolForNPagedLookasideList.txt
├── GroupProcsBySecurityDomain
├── OPCDE
│   └── opcde_commands
├── README.md
├── TokenTrustLevel
├── WnfKernelRegistrations
├── alpcPortsForProcesses.txt
├── appcontainers.txt
├── enumerateProcessesFromHandleTable.txt
├── filterCommPorts.js
├── getMemWritesInFunction.txt
├── getProcessNotifyRoutinesWithSyntheticTypes.txt
├── getWaitBlockInformation.txt
├── halDispatchTableWithSymbol
├── printApcs.txt
├── printIrpsForLsass.txt
├── printKernelInvertedFunctionTable.txt
├── printUserInvertedFunctionTable.txt
├── processNotifyRoutinesSymbols
├── processRedirectionTrust.txt
├── symbolBuilderLogIoctls.js
├── symbolBuilderWnf.js
├── threadNames
├── windbg_the_fun_way.pdf
├── wow64_peb
└── writeVerAccessInFile.txt

```

`EtwAllRegisteredTraceGuids`:

```
dx -r0 @$GuidTable = ((nt!_ESERVERSILO_GLOBALS*)&nt!PspHostSiloGlobals)->EtwSiloState->EtwpGuidHashTable
dx -s @$nonEmptyTraceGuids = @$GuidTable.Select(bucket => bucket.ListHead[0]).Where(l => l.Flink != &l)
dx -r2 @$nonEmptyTraceGuids.Select(l => Debugger.Utility.Collections.FromListEntry(l, "nt!_ETW_GUID_ENTRY", "GuidList").Select(g => g.Guid))

```

`EtwConsumersForProcesses`:

```
dx -s @$etwConsumersForProcess = (p => p.Io.Handles.Where(h => h.Type == "EtwConsumer").Select(h => Debugger.Utility.Collections.FromListEntry(((nt!_ETW_REALTIME_CONSUMER*)&h.Object.Body)->Links, "nt!_WMI_LOGGER_CONTEXT", "Consumers").Select(l => new {Name = l->LoggerName, InstanceGuid = l->InstanceGuid, RealtimeLogfileName = l->RealtimeLogfileName})))
dx -r5 @$cursession.Processes.Select(p => new {Name = p.Name, EtwConsumers = @$etwConsumersForProcess(p)})

```

`EtwPrintNotificationGuids.txt`:

```txt
dx -r0 @$etwNotificationGuid = 1
dx -r0 @$GuidTable = ((nt!_ESERVERSILO_GLOBALS*)&nt!PspHostSiloGlobals)->EtwSiloState->EtwpGuidHashTable
dx -g @$GuidTable.Select(bucket => bucket.ListHead[@$etwNotificationGuid]).Where(list => list.Flink != &list).Select(list => (nt!_ETW_GUID_ENTRY*)(list.Flink)).Select(Entry => new { Guid = Entry->Guid, Refs = Entry->RefCount, SD = Entry->SecurityDescriptor, Reg = (nt!_ETW_REG_ENTRY*)Entry->RegListHead.Flink})
```

`EtwPrintRegisteredProvidersForNotificationGuid.txt`:

```txt
dx -r0 @$guidEntryIndex = 0n25
dx -r0 @$etwNotificationGuid = 1
dx -r0 @$GuidTable = ((nt!_ESERVERSILO_GLOBALS*)&nt!PspHostSiloGlobals)->EtwSiloState->EtwpGuidHashTable
dx -r0 @$guidEntry = (nt!_ETW_GUID_ENTRY*)(@$GuidTable.Select(bucket => bucket.ListHead[@$etwNotificationGuid])[@$guidEntryIndex].Flink)
dx -g Debugger.Utility.Collections.FromListEntry(@$guidEntry->RegListHead, "nt!_ETW_REG_ENTRY", "RegList").Select(r => new {Caller = r.Caller, SessionId = r.SessionId, Process = r.Process, ProcessName = ((char[15])r.Process->ImageFileName)->ToDisplayString("s"), Callback = r.Callback, CallbackContext = r.CallbackContext})

```

`EtwRegisteredProvidersForProcess`:

```
dx @$pid = 0xABCD
dx @$cursession.Processes[@$pid].Io.Handles.Where(h => h.Type == "EtwRegistration").Select(h => ((nt!_ETW_REG_ENTRY*)(&h.Object.Body))->GuidEntry->Guid)

```

`FilterCommsHelpers.txt`:

```txt
# helper method to enumerate the registered communication ports for a filter driver.
#     filter - address of a filter driver
dx @$enumPortsForFilter = (filter => Debugger.Utility.Collections.FromListEntry(((fltmgr!_FLT_FILTER*)filter)->PortList.mList, "fltmgr!_FLT_PORT_OBJECT", "FilterLink"))

# helper method to find all the open handles to a file pointing to a specific device:
#     proc - debugger data model process (such as @$cursession.Process[4]
#     dev - address of a device object, such as the address of \FileSystem\Filters\FltMgrMsg
dx @$getHandlesToDevice = ((proc, dev) => proc.Io.Handles.Where(h => h.Type == "File" && h.Object.UnderlyingObject.DeviceObject == dev))

# helper method to get all the IRPs waiting on a communication port.
#     port - address of a port, such as the ones returned from @$enumPortsForFilter
dx @$getIrpList = (port => Debugger.Utility.Collections.FromListEntry(((fltmgr!_FLT_PORT_OBJECT*)port)->MsgQ.WaiterQ.mList, "nt!_IRP", "Tail.Overlay.ListEntry"))

# print all registered connection ports by iterating over the kernel handle table. Print the name and number of connections for each one.
dx -g @$cursession.Processes[4].Io.Handles.Where(h => !__iserror(h.Type == "FilterConnectionPort") && h.Type == "FilterConnectionPort").Select(h => new {Name = h.ObjectName, Object = (fltmgr!_FLT_SERVER_PORT_OBJECT*)(&h.Object.Body), NumberOfConnections = ((fltmgr!_FLT_SERVER_PORT_OBJECT*)(&h.Object.Body))->NumberOfConnections})

```

`FindLookasideLists.txt`:

```txt
dx -r0 @$GeneralLookaside = Debugger.Utility.Collections.FromListEntry(*(nt!_LIST_ENTRY*)&nt!ExPagedLookasideListHead, "nt!_GENERAL_LOOKASIDE", "ListEntry")
dx -r0 @$lookasideAddr = @$GeneralLookaside.Select(l => ((__int64)&l).ToDisplayString("x"))
dx -r0 @$extractBetween = ((x,y,z) => x.Substring(x.IndexOf(y) + y.Length, x.IndexOf(z) - x.IndexOf(y) - y.Length))
dx -r0 @$extractWithSize = ((x,y,z) => x.Substring(x.IndexOf(y) + y.Length, z))
dx -r0 @$poolData = @$lookasideAddr.Select(l => Debugger.Utility.Control.ExecuteCommand("!pool "+l+" 2")).Where(l => l[1].Length != 0x55 && l[1].Length != 0).Select(l => new {address = "0x" + @$extractBetween(l[1], "*", "size:"), tag = @$extractWithSize(l[1], "(Allocated) *", 4), tagDesc = l[2].Contains(",") ? @$extractBetween(l[2], ": ", ",") : l[2].Substring(l[2].IndexOf(":")+2), binary = l[2].Contains("Binary") ? l[2].Substring(l[2].IndexOf("Binary :")+9) : "unknown", size = "0x" + @$extractBetween(l[1], "size:", "previous size:").Replace(" ", "")})

```

`FindNonSystem32Modules.txt`:

```txt
# Prints a table of all processes, total number of modules loaded in them and number of modules whose path contains "System32"
# Run in a kernel debugger session (first run .reload to get all paths) - 
# having a small gap isn normal: ntkrnlmp.exe, hal.dll, kdnet.dll only contain a basename
# Other processes might have their own DLLs loaded from "Program Files" or have DLLs injected by AVs such as Windows Defender
dx -g @$cursession.Processes.Select(p => new {Name = p.Name, PID = p.Id, System32Modules = p.Modules.Where(m => m.Name.ToLower().Contains("system32")).Count(), TotalModules = p.Modules.Count()})

# To print all the non-system32 modules in a specific process:
dx @$pid = 0
dx @$cursession.Processes[0].Modules.Where(m => m.Name.ToLower().Contains("system32") == false)

```

`FindResourcesInPool.txt`:

```txt
dx -r0 @$eresource = Debugger.Utility.Collections.FromListEntry(*(nt!_LIST_ENTRY*)&nt!ExpSystemResourcesList, "nt!_ERESOURCE", "SystemResourcesList")
dx -r0 @$eresourceAddr = @$eresource.Select(l => ((__int64)&l).ToDisplayString("x"))
dx -r0 @$extractBetween = ((x,y,z) => x.Substring(x.IndexOf(y) + y.Length, x.IndexOf(z) - x.IndexOf(y) - y.Length))
dx -r0 @$extractWithSize = ((x,y,z) => x.Substring(x.IndexOf(y) + y.Length, z))
dx -r0 @$poolData = @$eresourceAddr.Select(l => Debugger.Utility.Control.ExecuteCommand("!pool "+l+" 2")).Where(l => l[1].Length != 0x55 && l[1].Length != 0).Select(l => new {address = "0x" + @$extractBetween(l[1], "*", "size:"), tag = @$extractWithSize(l[1], "(Allocated) *", 4), tagDesc = l[2].Contains(",") ? @$extractBetween(l[2], ": ", ",") : l[2].Substring(l[2].IndexOf(":")+2), binary = l[2].Contains("Binary") ? l[2].Substring(l[2].IndexOf("Binary :")+9) : "unknown", size = "0x" + @$extractBetween(l[1], "size:", "previous size:").Replace(" ", "")})
dx -r1 @$poolData.Where(l => l.size != "0x80")

```

`FindSymbolForNPagedLookasideList.txt`:

```txt
dx -r0 @$GeneralLookaside = Debugger.Utility.Collections.FromListEntry(*(nt!_LIST_ENTRY*)&nt!ExNPagedLookasideListHead, "nt!_GENERAL_LOOKASIDE", "ListEntry")
dx -r0 @$lookasideAddr = @$GeneralLookaside.Select(l => ((__int64)&l).ToDisplayString("x"))
dx -r0 @$extractBetween = ((x,y,z) => x.Substring(x.IndexOf(y) + y.Length, x.IndexOf(z) - x.IndexOf(y) - y.Length))
dx -r2 @$symData = @$lookasideAddr.Select(l => new {addr = l, sym = Debugger.Utility.Control.ExecuteCommand("ln "+l)}).Where(l => l.sym.Count() > 3).Select(l => new {addr = l.addr, sym = @$extractBetween(l.sym[3], "   ", "|")})
```

`GroupProcsBySecurityDomain`:

```
dx -r2 @$cursession.Processes.Select(p => new {Name = p.Name, SecurityDomain = p.KernelObject.SecurityDomain}).GroupBy(p => p.SecurityDomain).Select(x => x.Select(p => p.Name)), 1000

```

`OPCDE/opcde_commands`:

```
OPCDE Keynote - commands and steps:

1. Explore built-in registers - @$curthread, @$curprocess, @$cursession...
   Print process array in decimal: dx @$cursession.Processes, d

2. Find explorer.exe and its signature level:
    dx @$cursession.Processes.Where(p => p.Name == "explorer.exe").KernelObject.SignatureLevel & 0xF
    
3. Print signature level for all processes:
    dx -r2 @$cursession.Processes.Select(p => p.KernelObject.SignatureLevel)
    
4. Use anonymous type to print more information for each process, use -r2 to show 2 levels, use -g for grid view, order by signature level:
    dx -r2 @$cursession.Processes.Select(p => new {Name = p.Name, PID = p.Id, SignatureLevel = p.KernelObject.SignatureLevel & 0xF}).OrderBy(p => p.SignatureLevel)

5. Conditional Breakpoint - use bp /w to break on nt!NtWriteFile only when writing thread is impersonating:
    bp /w "@$curthread.KernelObject.ClientSecurity.ImpersonationData != 0" nt!NtWriteFile
    
6. When breakpoint is hit, use anonymous type to print process name, thread ID, impersonation token authentication ID and name of file that's written into, and keep running:
    bp /w "@$curthread.KernelObject.ClientSecurity.ImpersonationData != 0" nt!NtWriteFile "dx new { ProcName = @$curprocess.Name, ThreadId = @$curthread.Id, 
      AuthId = ((nt!_TOKEN*)(@$curthread.KernelObject.ClientSecurity.ImpersonationToken & ~0xF))->AuthenticationId.LowPart, 
      FileName = @$curprocess.Io.Handles[@rcx].Object.UnderlyingObject.FileName}; g"
      
Bonus - How to choose number of items printed from an array:
    Only show first 10 items: dx @$cursession.Processes, 10
    Show 9999 items: dx @$cursession.Processes, 9999
    Show all items in array: dx @$cursession.Processes, [@$cursession.Processes.Count()]
```

`README.md`:

```md
# WinDbg_Scripts
Useful scripts for WinDbg using the debugger data model

Usage, examples, explanations and general rants (also available in PDF form here):

https://medium.com/@yardenshafir2/windbg-the-fun-way-part-1-2e4978791f9b  </br>
https://medium.com/@yardenshafir2/windbg-the-fun-way-part-2-7a904cba5435

## Useful Commands and Syntax
- <b>__iserror(x)</b>   
Returns true if a statement throws an error.
```
dx @$curprocess.Io.Handles.Where(h => !__iserror(h.Type == "File") && h.Type == "File")
```

- <b>SelectMany</b>  
Flattens a nested collection, for example runs a query on all threads in all processes and flattens the results
```
dx @$cursession.Processes.SelectMany(p => p.Threads.Select(t => t.KernelObject.ThreadName))
```

- <b>Conditional Operations</b>
```
dx @$curthread.KernelObject.ActiveImpersonationInfo != 0 ? @$curthread.KernelObject.ClientSecurity.ImpersonationLevel : "Not Impersonating"
```

- <b>Executing a Legacy Command</b>
```
dx @$printSecurityDescriptor = (sd => Debugger.Utility.Control.ExecuteCommand("!sd " + ((__int64)sd).ToDisplayString("x") + " 1"))
```

- <b>Cast Pointer to Function Address</b>
```
dx @$curprocess.Threads.Select(t => (void(*)())t.KernelObject.StartAddress)
```

## String Types and Conversions
WinDbg uses regular, null terminated strings.
That can be challenging when trying to compare them with Windows strings, which can be counted strings (ANSI or UNICODE strings) or wide strings.
To fix that, you can cast Windows strings into "regular" strings with .ToDisplayString:
- .ToDisplayString("s"): convert a char array (not a wide string) to a string. Outout string will be wrapped in double quotes.
- .ToDisplayString("sb"): convert a char array (not a wide string) to a string. Outout string will not be wrapped in double quotes.
- .ToDisplayString("su"): convert a wchar_t array (wide string) to a string. Outout string will be wrapped in double quotes.

To convert a counted string to a basic string, convert the Buffer field of the counted string using .ToDisplayString(). For example, to convert an ANSI_STRING to a string:
```
dx (@$CountedString->Buffer).ToDisplayString("sb")
```

As another example, you can create a helper function to compare a user-defined path to the ObjectName field of an OBJECT_ATTRIBUTES structure. ObjectName is a wide string so use .ToDisplayString("su"), and wrap the requested string in double quotes to match the output received from .ToDisplayString("su").
In this helper function, the two arguments are:
- o: a pointer to an OBJECT_ATTRIBUTES structure
- p: a string to be compared to the ObjectName field of the OBJECT_ATRIBUTES structure passed in argument o
```
dx @$comparePathFromObjAttr = ((o, p) => (((nt!_OBJECT_ATTRIBUTES*)o)->ObjectName->Buffer).ToDisplayString("su") == "\"" + p + "\"")
```

```

`TokenTrustLevel`:

```
dx @$getTokenTrustLabelSidForProcess = (p => ((nt!_TOKEN*)(p.KernelObject.Token.Object & ~0xf))->TrustLevelSid)
dx @$parseSid = (s => Debugger.Utility.Control.ExecuteCommand("!sid " + ((__int64)s).ToDisplayString("x"))[0])
dx -g @$cursession.Processes.Select(p => new {Name = p.Name, TrustLevelSid = @$getTokenTrustLabelSidForProcess(p)}).Where(p => p.TrustLevelSid).Select(p => new {Name = p.Name, TrustLevelSid = @$parseSid(p.TrustLevelSid)})

```

`WnfKernelRegistrations`:

```
# Dump the WNF state names that each process in the system is registered to.
# Notice that the "Callback" field will be 0 for all user-mode registrations.

dx @$getStateNameWnfSubsForProcess = (p => Debugger.Utility.Collections.FromListEntry(((nt!_WNF_PROCESS_CONTEXT*)p.KernelObject.WnfContext)->ProcessSubscriptionListHead, "nt!_WNF_SUBSCRIPTION", "ProcessSubscriptionListEntry"))
dx -r4 @$cursession.Processes.Select(p => new {Name = p.Name, Subscriptions = @$getStateNameWnfSubsForProcess(p).Select(s => new {StateName = 0x41C64E6DA3BC0074 ^ (*(__int64*)&s.StateName), Callback = (void(*)())s.CallbackRoutine})}), x

```

`alpcPortsForProcesses.txt`:

```txt
# Get all open ALPC ports for all processes. Pretty much like !alpc /lpp but for all processes, with much uglier output

dx -r4 @$ports = @$cursession.Processes.Select(p => new {Name = p.Name, AlpcPorts = p.Io.Handles.Where(h => h.Type == "ALPC Port").Select(a => new {PortName = a.ObjectName, Port = (nt!_ALPC_PORT*)&a.Object.Body})}).Select(p => new {Name = p.Name, AlpcPortsCount = p.AlpcPorts.Count(), AlpcPorts = p.AlpcPorts})


# Alternatively, run !alpc /lpp on all processes (slower but nicer output):

dx @$getPortsForProcess = (p => Debugger.Utility.Control.ExecuteCommand("!alpc /lpp " + ((__int64)p).ToDisplayString("x")))
dx -r3 @$cursession.Processes.Select(p => new {Name = p.Name, Ports = @$getPortsForProcess(&p.KernelObject)})

```

`appcontainers.txt`:

```txt
# Get all appcontainer processes (makred by Token.TokenFlags.LowBox (value == 0x4000)

dx -g @$appcontainers = @$cursession.Processes.Select(p => new {Name = p.Name, Id = p.Id, ProcessObj = p, TokenFlags = ((nt!_TOKEN*)(p.KernelObject.Token.Object & ~0xf))->TokenFlags}).Where(p => (p.TokenFlags & 0x4000) == 0x4000)

```

`enumerateProcessesFromHandleTable.txt`:

```txt
dx -r2 (Debugger.Utility.Collections.FromListEntry(*(nt!_LIST_ENTRY*)&nt!HandleTableListHead, "nt!_HANDLE_TABLE", "HandleTableList")).Where(h => h.QuotaProcess != 0).Select(h => new { Object = h.QuotaProcess, Name = (char*)h.QuotaProcess->ImageFileName, PID = h.QuotaProcess->UniqueProcessId})
```

`filterCommPorts.js`:

```js
"use strict";

function initializeScript()
{
    return [new host.functionAlias(GetHandlesToDevice, "DeviceFileHandles"),
			new host.functionAlias(GetQueuedIrpsForPort, "IrpsForPort"),
			new host.functionAlias(RegisteredFilterDrivers, "RegisteredFilters"),
			new host.functionAlias(EnumCommPortListForFilter, "EnumCommPortListForFilter"),
	        new host.functionAlias(EnumServerPortsForFilter, "EnumServerPortsForFilter"),
			new host.functionAlias(AllServerPorts, "AllServerPorts"),
			new host.apiVersionSupport(1, 6)];
}

function GetHandlesToDevice(Device)
{
    // Get easy access to the debug output method
    let dbgOutput = host.diagnostics.debugLog;

    // Loop over each process
    let processes = host.currentSession.Processes;
	let objHeaderType = host.getModuleType("nt", "_OBJECT_HEADER");
	let objHeaderOffset = objHeaderType.fields.Body.offset;
 
    for (let process of processes)
    { 
        let handles = process.Io.Handles;
 
        try {
 
            for (let handle of handles) {
 
                try {
 
                    let fileObj = handle.Object.ObjectType;
                    if (fileObj === "File") {
						if (host.parseInt64(handle.Object.UnderlyingObject.DeviceObject.address, 16).compareTo(Device) == 0)
                        {
							let fscontext2 = handle.Object.UnderlyingObject.FsContext2.address;
							let fltCcbType = host.getModuleType("FltMgr", "_FLT_CCB");
							let port = host.createTypedObject(fscontext2, fltCcbType).Data.Port.Port;
							let portObjHeader = host.createTypedObject(port.ServerPort.address.subtract(objHeaderOffset), objHeaderType);
							dbgOutput("\tProcess ", process.Name, " has handle ", handle.Handle, " to port ", portObjHeader.ObjectName, "\n");
							
                        }
                    }
                   
                } catch (e) {
 
                    dbgOutput("\tException parsing handle ", handle.Handle, "in process ", process.Name, "!\n");
 
                }
 
            }
 
        } catch (e) {
 
           // dbgOutput("\tException parsing handle table for process ", process.Name, " PID ", process.Id, "!\n");
 
        }
 
    }

}

function GetQueuedIrpsForPort(Port)
{
	let dbgOutput = host.diagnostics.debugLog;
	let v_port = host.createTypedObject(Port.address, host.getModuleType("FltMgr", "_FLT_PORT_OBJECT"));
	dbgOutput("Port: ", v_port.address, "\n");
	let waiterlist = host.namespace.Debugger.Utility.Collections.FromListEntry(v_port.MsgQ.WaiterQ.mList, "nt!_IRP", "Tail.Overlay.ListEntry");
	
	for (let entry of waiterlist) {
		dbgOutput("\tIRP address: ", entry.address, " by thread ", entry.CurrentThread.Cid.UniqueThread.address,"\n");
	}
}

function RegisteredFilterDrivers()
{
	let dbgOutput = host.diagnostics.debugLog;
	let fltglobals = host.getModuleSymbolAddress("fltmgr", "FltGlobals");
	let typedFltGlobals = host.createTypedObject(fltglobals, "fltmgr", "_GLOBALS");
	
	dbgOutput("Flt Globals: ", typedFltGlobals.address, "\n");
	
	let flt_frames = host.namespace.Debugger.Utility.Collections.FromListEntry(typedFltGlobals.FrameList.rList, "fltmgr!_FLTP_FRAME", "Links");
	
	for (let flt_frame of flt_frames) {
		dbgOutput("Frame ", flt_frame.FrameID, "\n");
		
		let filters = host.namespace.Debugger.Utility.Collections.FromListEntry(flt_frame.RegisteredFilters.rList, "fltmgr!_FLT_FILTER", "Base.PrimaryLink");
		
		for (let filter of filters) {
			dbgOutput("\tFilter ", filter.Name, " : ", filter.address, "\n");
			
			let instances = host.namespace.Debugger.Utility.Collections.FromListEntry(filter.InstanceList.rList, "fltmgr!_FLT_INSTANCE", "FilterLink");
			for (let instance of instances) {
				dbgOutput("\t\tInstance: ", instance.address, ", Name: ", instance.Name, ", Altitude: ", instance.Altitude, "\n");
			}

		}
	}
}

function EnumCommPortListForFilter(Filter)
{
	let dbgOutput = host.diagnostics.debugLog;
	let v_filter = host.createTypedObject(Filter, host.getModuleType("FltMgr", "_FLT_FILTER"));
	dbgOutput("Filter: ", v_filter.address, "\n");

	if (v_filter.PortList.mCount != 0) {
		let ports = host.namespace.Debugger.Utility.Collections.FromListEntry(v_filter.PortList.mList, "fltmgr!_FLT_PORT_OBJECT", "FilterLink");

		for (let port of ports) {
			if (port != 0) {
				dbgOutput("Port: ", port.address, "\n");
				dbgOutput("\tServerPort: ", port.ServerPort.address, "\n");
				dbgOutput("\t\tConnectNotify: ", port.ServerPort.ConnectNotify.address, "\n");
				dbgOutput("\t\tDisconnectNotify: ", port.ServerPort.DisconnectNotify.address, "\n");
				dbgOutput("\t\tMessageNotify: ", port.ServerPort.MessageNotify.address, "\n");
				dbgOutput("\t\tNumberOfConnections: ", port.ServerPort.NumberOfConnections, "\n");
				dbgOutput("\t\tMaxConnections: ", port.ServerPort.MaxConnections, "\n");
				dbgOutput("\tMsgQ: ", port.MsgQ.address, "\n");
				dbgOutput("\tDisconnected: ", port.Disconnected, "\n");
			}
		}
	}	
}

function EnumServerPortsForFilter(Filter)
{
	let dbgOutput = host.diagnostics.debugLog;
	let v_filter = host.createTypedObject(Filter, host.getModuleType("FltMgr", "_FLT_FILTER"));

	if (v_filter.ConnectionList.mCount != 0)
	{
		let ports = host.namespace.Debugger.Utility.Collections.FromListEntry(v_filter.ConnectionList.mList, "fltmgr!_FLT_SERVER_PORT_OBJECT", "FilterLink");

		for (let port of ports) {
			let objectHeaderAddress = host.parseInt64(port.address, 16).subtract(0x30);
			let objectHeader = host.createTypedObject(objectHeaderAddress, host.getModuleType("nt", "_OBJECT_HEADER"));
			
			dbgOutput("\tServerPort ", objectHeader.ObjectName, ": ", port.address, "\n");
			dbgOutput("\t\tConnectNotify: ", port.ConnectNotify.address, "\n");
			dbgOutput("\t\tDisconnectNotify: ", port.DisconnectNotify.address, "\n");
			dbgOutput("\t\tMessageNotify: ", port.MessageNotify.address, "\n");
			dbgOutput("\t\tNumberOfConnections: ", port.NumberOfConnections, "\n");
			dbgOutput("\t\tMaxConnections: ", port.MaxConnections, "\n");
		}
	}
}

function AllServerPorts()
{
	let dbgOutput = host.diagnostics.debugLog;
	let fltglobals = host.getModuleSymbolAddress("fltmgr", "FltGlobals");
	let typedFltGlobals = host.createTypedObject(fltglobals, "fltmgr", "_GLOBALS");
	let flt_frames = host.namespace.Debugger.Utility.Collections.FromListEntry(typedFltGlobals.FrameList.rList, "fltmgr!_FLTP_FRAME", "Links");
	
	for (let flt_frame of flt_frames) {
		dbgOutput("Frame ", flt_frame.FrameID, "\n");
		
		let filters = host.namespace.Debugger.Utility.Collections.FromListEntry(flt_frame.RegisteredFilters.rList, "fltmgr!_FLT_FILTER", "Base.PrimaryLink");
		
		for (let filter of filters) {
			dbgOutput("Filter ", filter.Name, " : ", filter.address, "\n");
			EnumServerPortsForFilter(filter.address);
			dbgOutput("\n");
		}
	}
}

```

`getMemWritesInFunction.txt`:

```txt
dx -r0 @$rspId = 0x14
dx -r0 @$rbpId = 0x15
dx -r0 @$isMemWrite = (b => b.Instructions.Where(i => i.Operands.Count() > 1 && i.Operands[0].Attributes.IsOutput && i.Operands[0].Registers[0].Id != @$rspId && i.Operands[0].Registers[0].Id != @$rbpId && i.Operands[0].Attributes.IsMemoryReference))
dx -r0 @$findMemWrite = (a => Debugger.Utility.Code.CreateDisassembler().DisassembleBlocks(a).Select(b => @$isMemWrite(b)))
dx -r2 @$findMemWrite(&nt!ZwSetInformationProcess).Where(b => b.Count() != 0)
```

`getProcessNotifyRoutinesWithSyntheticTypes.txt`:

```txt
# define this structure in header file (c:\temp\header.h):
typedef struct _EX_CALLBACK_ROUTINE_BLOCK
{
    _EX_RUNDOWN_REF RundownProtect;
    void* Function;
    void* Context;
} EX_CALLBACK_ROUTINE_BLOCK, *PEX_CALLBACK_ROUTINE_BLOCK;


dx Debugger.Utility.Analysis.SyntheticTypes.ReadHeader("c:\\temp\\header.h", "nt")
dx @$getCallbackRoutine = (a => Debugger.Utility.Analysis.SyntheticTypes.CreateInstance("_EX_CALLBACK_ROUTINE_BLOCK", (__int64)(a & ~0xf)))
dx -r0 @$getsym = (x => Debugger.Utility.Control.ExecuteCommand(".printf\"%y\", " + ((__int64)x).ToDisplayString("x")))[0]
dx ((void**[0x40])&nt!PspCreateProcessNotifyRoutine).Where(a => a != 0).Select(a => @$getsym(@$getCallbackRoutine(a).Function))

```

`getWaitBlockInformation.txt`:

```txt
//
// Print the first wait block in each process wait list
//
dx -g @$procWaits = @$cursession.Processes.Where(p => (__int64)&p.KernelObject.Pcb.Header.WaitListHead != (__int64)p.KernelObject.Pcb.Header.WaitListHead.Flink).Select(p => Debugger.Utility.Collections.FromListEntry(p.KernelObject.Pcb.Header.WaitListHead, "nt!_KWAIT_BLOCK", "WaitListEntry")[0]).Select(p => new { WaitType = p.WaitType, BlockState = p.BlockState, Thread = p.Thread, Dpc = p.Dpc, Object = p.Object, Name = ((char*)((nt!_EPROCESS*)p.Object)->ImageFileName).ToDisplayString("sb")})

//
// Find all processes that have wait blocks with WaitDpc type
//
dx @$dpcwaits = @$cursession.Processes.Where(p => (__int64)&p.KernelObject.Pcb.Header.WaitListHead != (__int64)p.KernelObject.Pcb.Header.WaitListHead.Flink && Debugger.Utility.Collections.FromListEntry(p.KernelObject.Pcb.Header.WaitListHead, "nt!_KWAIT_BLOCK", "WaitListEntry").Where(p => p.WaitType == 4).Count() != 0)

//
// Print information about wait blocks of type WaitDpc waiting on processes
//
dx -r0 @$getsym = (x => Debugger.Utility.Control.ExecuteCommand(".printf\"%y\", " + ((__int64)x).ToDisplayString("x")))
dx -g Debugger.Utility.Collections.FromListEntry(@$dpcwaits.First().KernelObject.Pcb.Header.WaitListHead, "nt!_KWAIT_BLOCK", "WaitListEntry").Select(p => new { WaitType = p.WaitType, BlockState = p.BlockState, Thread = p.Thread, Dpc = p.Dpc, Object = p.Object, Name = ((char*)((nt!_EPROCESS*)p.Object)->ImageFileName).ToDisplayString("sb"), DpcTarget = (@$getsym(p.Dpc->DeferredRoutine))[0]})
```

`halDispatchTableWithSymbol`:

```
dx ((__int64*(*)[30])&nt!HalDispatchTable)->Select(f => (void(*)())f)

```

`printApcs.txt`:

```txt
dx -r0 @$printLn = (a => Debugger.Utility.Control.ExecuteCommand("ln "+((__int64)a).ToDisplayString("x")))
dx -r0 @$extractBetween = ((x,y,z) => x.Substring(x.IndexOf(y) + y.Length, x.IndexOf(z) - x.IndexOf(y) - y.Length))
dx -r0 @$printSymbol = (a => @$extractBetween(@$printLn(a)[3], " ", "|"))
dx -r0 @$apcsForThread = (t => new {TID = t.Id, Object = (void*)&t.KernelObject, Apcs = Debugger.Utility.Collections.FromListEntry(*(nt!_LIST_ENTRY*)&t.KernelObject.Tcb.ApcState.ApcListHead[0], "nt!_KAPC", "ApcListEntry").Select(a => new { Kernel = @$printSymbol(a.KernelRoutine), Rundown = @$printSymbol(a.RundownRoutine)})})
dx -r0 @$procWithKernelApc = @$cursession.Processes.Select(p => new {Name = p.Name, PID = p.Id, Object = (void*)&p.KernelObject, ApcThreads = p.Threads.Where(t => t.KernelObject.Tcb.ApcState.KernelApcPending != 0)}).Where(p => p.ApcThreads.Count() != 0)
dx -r6 @$procWithKernelApc.Select(p => new { Name = p.Name, PID = p.PID, Object = p.Object, ApcThreads = p.ApcThreads.Select(t => @$apcsForThread(t))})
```

`printIrpsForLsass.txt`:

```txt
dx @$lsass = @$cursession.Processes.Where(p => p.Name == "lsass.exe").First()
dx -r4 @$irpThreads = @$lsass.Threads.Select(t => new {irp = Debugger.Utility.Collections.FromListEntry(t.KernelObject.IrpList, "nt!_IRP", "ThreadListEntry")}).Where(t => t.irp.Count() != 0)
dx -r3 @$irpThreads.Select(t => t.irp.Select(i => Debugger.Utility.Control.ExecuteCommand("!irp " + ((__int64)&i).ToDisplayString("x"))))
```

`printKernelInvertedFunctionTable.txt`:

```txt
dx @$inverted = (nt!_INVERTED_FUNCTION_TABLE*)&nt!PsInvertedFunctionTable
dx -g @$tableEntry = *(nt!_INVERTED_FUNCTION_TABLE_ENTRY(*)[0xbe])@$inverted->TableEntry
```

`printUserInvertedFunctionTable.txt`:

```txt
dx @$inverted = *(nt!_INVERTED_FUNCTION_TABLE**)&nt!KeUserInvertedFunctionTable
dx -g @$inverted->TableEntry->Take(@$inverted->CurrentSize)
```

`processNotifyRoutinesSymbols`:

```
# This works on newer debugger builds to print the symbols for each registered routine with the syntax: (void(*)()).
# The structure is not documenting so I'm hardcoding the offset of the routine pointer inside the callback block (offset 8).
# Notice that the pointers need to be alined since they encode a reference number.
# Replace PspCreateProcessNotifyRoutine with PspCreateThreadNotifyRoutine or PspLoadImageNotifyRoutine to print the registered routines for those.

dx ((__int64(*)[64])&nt!PspCreateProcessNotifyRoutine)->Where(p => p)->Select(p => (void(*)())(*(((__int64*)(p & ~0xf)) + 1)))

```

`processRedirectionTrust.txt`:

```txt
# Print a table of all the processes running with a token that has Redirection Trust mitigation enabled in full / audit mode
# Only looks at primany token, not at impersonation token

dx -g @$cursession.Processes.Select(p => new {Name = p.Name, RedirectionTrust = ((((nt!_TOKEN*)(p.KernelObject.Token.Object & ~0xf))->TokenFlags & 0x400000) == 0x400000), RedirectionTrustAudit = ((((nt!_TOKEN*)(p.KernelObject.Token.Object & ~0xf))->TokenFlags & 0x800000) == 0x800000)}).OrderByDescending(obj => obj.@"RedirectionTrustAudit").Where(p => p.RedirectionTrust || p.RedirectionTrustAudit)

```

`symbolBuilderLogIoctls.js`:

```js
"use strict";

//
// To use the script:
// 1. Load SymbolBuilderComposition (clone and build from: https://github.com/microsoft/WinDbg-Samples/blob/master/TargetComposition/SymBuilder/Readme.txt)
// 2. Fix function offset and size as needed in DefineNtDeviceIoControlFileSignature (current offset and size match 24H2 Preview build 10.026080.1)
// 3. Call DefineNtDeviceIoControlFileSignature with: dx @$DefineNtDeviceIoControlFileSignature()
// 4. Reload symbols: .reload
// 5. Define breakpoint on NtDeviceIoControlFile: bp nt!NtDeviceIoControlFile "dx @$LogIoctlArgs(); g"
// 6. Define breakpoint on end of NtDeviceIoControlFile: bp nt!NtDeviceIoControlFile+0x62 "dx @$LogIoctlOutput(); g"
// 7. Let the machine run with "g"
// 8. When you'd like to stop the trace and flush data to the file, call CloseLogFile: dx @$CloseLogFile()
//

function initializeScript()
{
    return [new host.apiVersionSupport(1, 9),
            new host.functionAlias(CreateTextWriter, "CreateTextWriter"),
            new host.functionAlias(CloseLogFile, "CloseLogFile"),
            new host.functionAlias(DefineNtDeviceIoControlFileSignature, "DefineNtDeviceIoControlFileSignature"),
            new host.functionAlias(LogIoctlArgs, "LogIoctlArgs"),
            new host.functionAlias(LogIoctlOutput, "LogIoctlOutput")];
}

function invokeScript()
{
}

let sym = 0;
let lastOutputBuffer = 0;
let lastOutputBufferLength = 0;
let logFile = 0;
let txtWriter = 0;


function CreateTextWriter(f)
{
    return host.namespace.Debugger.Utility.FileSystem.CreateTextWriter(f);
}

function CloseLogFile()
{
    if (logFile != 0)
    {
        logFile.Close();
        logFile = 0;
        txtWriter = 0;
    }
}

let filename = "c:\\temp\\ioctl_args.txt";

function LogIoctlOutput()
{
    let dbgOutput = host.diagnostics.debugLog;

    if ((logFile === 0) || (txtWriter === 0))
    {
        if (host.namespace.Debugger.Utility.FileSystem.FileExists(filename))
        {
            logFile = host.namespace.Debugger.Utility.FileSystem.OpenFile(filename);
        }
        else
        {
            return;
        }
        txtWriter = CreateTextWriter(logFile);
    }

    let outputBuffer = lastOutputBuffer
    let outputBufferLen = lastOutputBufferLength

    if (outputBuffer.address != 0)
    {
        try
        {
            let outputData = host.memory.readMemoryValues(outputBuffer, outputBufferLen, 1);
            txtWriter.WriteLine("\tOutput data @0x" + outputBuffer.toString(16) + ": " + outputData);
        }
        catch (e) {}
    }
}

function LogIoctlArgs()
{
    let dbgOutput = host.diagnostics.debugLog;

    if ((logFile === 0) || (txtWriter === 0))
    {
        if (host.namespace.Debugger.Utility.FileSystem.FileExists(filename))
        {
            logFile = host.namespace.Debugger.Utility.FileSystem.CreateFile(filename, "OpenExisting");
        }
        else
        {
            dbgOutput("Creating new log file\n");
            logFile = host.namespace.Debugger.Utility.FileSystem.CreateFile(filename);
        }
        txtWriter = CreateTextWriter(logFile);
    }

    txtWriter.WriteLine("\nNtDeviceIoControlFile arguments:");

    let callingProcessName = host.currentProcess.Name;
    let callingProcessId = host.currentProcess.Id;
    txtWriter.WriteLine("\tProcess: " + callingProcessName + " (" + callingProcessId + ")");

    let fileHandle = host.currentThread.Stack.Frames[0].Parameters.FileHandle;
    let targetDeviceName = host.currentProcess.Io.Handles[fileHandle].Object.UnderlyingObject.FileName;
    let targetDriverName = host.currentProcess.Io.Handles[fileHandle].Object.UnderlyingObject.Device.Driver.DriverName;

    txtWriter.WriteLine("\tDevice: " + targetDeviceName + " (Driver: " + targetDriverName + ")");

    let ioctlCode = host.currentThread.Stack.Frames[0].Parameters.IoControlCode;
    txtWriter.WriteLine("\tIOCTL code: 0x" + ioctlCode.toString(16));

    let inputBuffer = host.currentThread.Stack.Frames[0].Parameters.InputBuffer;
    txtWriter.WriteLine("\tInput Buffer address: 0x" + inputBuffer.address.toString(16));
    let inputBufferLen = host.currentThread.Stack.Frames[0].Parameters.InputBufferLength;
    txtWriter.WriteLine("\tInput Buffer length: 0x" + inputBufferLen.toString(16));

    // read input buffer
    if (inputBuffer.address != 0)
    {
        try
        {
            let inputData = host.memory.readMemoryValues(inputBuffer.address, inputBufferLen, 1);
            txtWriter.WriteLine("\tInput data: " + inputData);
        }
        catch (e) {}
    }

    let outputBuffer = host.currentThread.Stack.Frames[0].Parameters.OutputBuffer;
    txtWriter.WriteLine("\tOutput Buffer address: 0x" + outputBuffer.address.toString(16));
    let outputBufferLen = host.currentThread.Stack.Frames[0].Parameters.OutputBufferLength;
    txtWriter.WriteLine("\tOutput Buffer length: 0x" + outputBufferLen.toString(16));

    // save the output buffer and output buffer length so we can use them on function exit (best effort, this won't always be accurate)
    lastOutputBuffer = outputBuffer.address;
    lastOutputBufferLength = outputBufferLen;
}

function DefineNtDeviceIoControlFileSignature()
{
    if (sym === 0)
    {
        sym = host.namespace.Debugger.Utility.SymbolBuilder.CreateSymbols("nt", {AutoImportSymbols: true});
    }
    // hardcode function size because I'm lazy
	let NtDeviceIoControlFileSize = 0x62;
    let psNtosBase = host.getModuleSymbolAddress("nt", "PsNtosImageBase");
    let ntosBase = host.memory.readMemoryValues(psNtosBase, 1, 8);
    let pNtDeviceIoControlFile = host.getModuleSymbolAddress("nt", "NtDeviceIoControlFile");
    let ntDeviceIoControlSym = sym.Functions.Create("NtDeviceIoControlFile", "int", host.parseInt64(pNtDeviceIoControlFile, 16).subtract(ntosBase[0]), NtDeviceIoControlFileSize);
    let fileHandle = ntDeviceIoControlSym.Parameters.Add("FileHandle", "__int64");
    fileHandle.LiveRanges.Add(0, 8, "@rcx");
    let event = ntDeviceIoControlSym.Parameters.Add("Event", "__int64");
    event.LiveRanges.Add(0, 8, "@rdx");
    let apcRoutine = ntDeviceIoControlSym.Parameters.Add("ApcRoutine", "void*");
    apcRoutine.LiveRanges.Add(0, 8, "@r8");
    let apcContext = ntDeviceIoControlSym.Parameters.Add("ApcContext", "void*");
    apcContext.LiveRanges.Add(0, 8, "@r9");
    let ioStarusBlock = ntDeviceIoControlSym.Parameters.Add("IoStatusBlock", "_IO_STATUS_BLOCK*");
    ioStarusBlock.LiveRanges.Add(0, 8, "[@rsp + 28]");
    let ioctl = ntDeviceIoControlSym.Parameters.Add("IoControlCode", "int");
    ioctl.LiveRanges.Add(0, 4, "[@rsp + 30]");
    let inputBuffer = ntDeviceIoControlSym.Parameters.Add("InputBuffer", "void*");
    inputBuffer.LiveRanges.Add(0, 4, "[@rsp + 38]");
    let inputBufferLength = ntDeviceIoControlSym.Parameters.Add("InputBufferLength", "int");
    inputBufferLength.LiveRanges.Add(0, 4, "[@rsp + 40]");
    let outputBuffer = ntDeviceIoControlSym.Parameters.Add("OutputBuffer", "void*");
    outputBuffer.LiveRanges.Add(0, 4, "[@rsp + 48]");
    let outputBufferLength = ntDeviceIoControlSym.Parameters.Add("OutputBufferLength", "int");
    outputBufferLength.LiveRanges.Add(0, 4, "[@rsp + 50]");
}

```

`symbolBuilderWnf.js`:

```js
"use strict";

function initializeScript()
{
    return [new host.apiVersionSupport(1, 7),
            new host.functionAlias(AddSymbolsToDll, "CreateSym"),
            new host.functionAlias(GeneralSymbols, "GeneralSymbols"),
            new host.functionAlias(WnfSymbols, "WnfSymbols")];
}

function invokeScript()
{
    //
    // Insert your script content here.  This method will be called whenever the script is
    // invoked from a client.
    //
    // See the following for more details:
    //
    //     https://aka.ms/JsDbgExt
    //
}

//
// To use:
// 1. Build and load SymbolBuilderComposition.dll from here:
//    https://github.com/microsoft/WinDbg-Samples/blob/master/TargetComposition/SymBuilder/Readme.txt
// 2. Call AddSymbolsToDll with your chosen dll name to add the symbols to:
//    dx @$testSym = @$CreateSym("nsi.dll")
// 3. Add the general symbols to the dll (those are required for the WNF symbols):
//    dx @$GeneralSymbols(@$testSym)
// 4. Add WNF symbols to the dll:
//    dx @$WnfSymbols(@$testSym)
// 5. In the debugger run .reload
// 
// Now all new symbols are available in the DLL you chose in step 2
//

function AddSymbolsToDll(dllName)
{
    return host.namespace.Debugger.Utility.SymbolBuilder.CreateSymbols(dllName);
}

function GeneralSymbols(sym)
{
    var rtlBalancedNode = sym.Types.Create("_RTL_BALANCED_NODE");
    rtlBalancedNode.Fields.Add("Left", "_RTL_BALANCED_NODE*");
    rtlBalancedNode.Fields.Add("Right", "_RTL_BALANCED_NODE*");
    rtlBalancedNode.Fields.Add("ParentValue", "char");

    var rtlRbTree = sym.Types.Create("_RTL_RB_TREE");
    rtlRbTree.Fields.Add("Root", "_RTL_BALANCED_NODE*");
    rtlRbTree.Fields.Add("Min", "_RTL_BALANCED_NODE*");

    var listEntry = sym.Types.Create("_LIST_ENTRY");
    listEntry.Fields.Add("Flink", "_LIST_ENTRY*");
    listEntry.Fields.Add("Blink", "_LIST_ENTRY*");

    var guid = sym.Types.Create("_GUID");
    guid.Fields.Add("Data1", "int");
    guid.Fields.Add("Data2", "int");
    guid.Fields.Add("Data3", "int");
    guid.Fields.Add("Data4_0", "char");
    guid.Fields.Add("Data4_1", "char");
    guid.Fields.Add("Data4_2", "char");
    guid.Fields.Add("Data4_3", "char");
    guid.Fields.Add("Data4_4", "char");
    guid.Fields.Add("Data4_5", "char");
    guid.Fields.Add("Data4_6", "char");
    guid.Fields.Add("Data4_7", "char");
}

function WnfSymbols(sym)
{
    var wnfNodeHeader = sym.Types.Create("_WNF_NODE_HEADER");
    wnfNodeHeader.Fields.Add("NodeTypeCode", "wchar_t");
    wnfNodeHeader.Fields.Add("NodeByteSize", "wchar_t");

    var wnfTypeId = sym.Types.Create("_WNF_TYPE_ID");
    wnfTypeId.Fields.Add("TypeId", "_GUID");

    var wnfStateName = sym.Types.Create("_WNF_STATE_NAME");
    wnfStateName.Fields.Add("Data1", "int");
    wnfStateName.Fields.Add("Data2", "int");

    var wnfSubscriptionTable = sym.Types.Create("_WNF_SUBSCRIPTION_TABLE");
    wnfSubscriptionTable.Fields.Add("Header", "_WNF_NODE_HEADER");
    wnfSubscriptionTable.Fields.Add("NamesTableLock", "void*");
    wnfSubscriptionTable.Fields.Add("NamesTree", "_RTL_RB_TREE");
    wnfSubscriptionTable.Fields.Add("SerializationGroupListHead", "_LIST_ENTRY");
    wnfSubscriptionTable.Fields.Add("SerializationListLock", "void*");
    wnfSubscriptionTable.Fields.Add("Unknown1", "int");
    wnfSubscriptionTable.Fields.Add("Unknown2", "int");
    wnfSubscriptionTable.Fields.Add("SubscribedEventSet", "int");
    wnfSubscriptionTable.Fields.Add("Unknown3", "int");
    wnfSubscriptionTable.Fields.Add("Unknown4", "int");
    wnfSubscriptionTable.Fields.Add("Timer", "void*");
    wnfSubscriptionTable.Fields.Add("TimerDueTime", "__int64");

    var wnfDeliveryDescriptor = sym.Types.Create("_WNF_DELIVERY_DESCRIPTOR");
    wnfDeliveryDescriptor.Fields.Add("SubscriptionId", "__int64");
    wnfDeliveryDescriptor.Fields.Add("StateName", "_WNF_STATE_NAME");
    wnfDeliveryDescriptor.Fields.Add("ChangeStamp", "int");
    wnfDeliveryDescriptor.Fields.Add("StateDataSize", "int");
    wnfDeliveryDescriptor.Fields.Add("EventMask", "int");
    wnfDeliveryDescriptor.Fields.Add("TypeId", "_WNF_TYPE_ID");
    wnfDeliveryDescriptor.Fields.Add("StateDataOffset", "int");

    var wnfNameSubscription = sym.Types.Create("_WNF_NAME_SUBSCRIPTION");
    wnfNameSubscription.Fields.Add("Header", "_WNF_NODE_HEADER");
    wnfNameSubscription.Fields.Add("SubscriptionId", "__int64");
    wnfNameSubscription.Fields.Add("StateName", "_WNF_STATE_NAME");
    wnfNameSubscription.Fields.Add("CurrentChangeStamp", "int");
    wnfNameSubscription.Fields.Add("NamesTreeNode", "_RTL_BALANCED_NODE");
    wnfNameSubscription.Fields.Add("TypeId", "_WNF_TYPE_ID*");
    wnfNameSubscription.Fields.Add("NameSubscriptionLock", "void*");
    wnfNameSubscription.Fields.Add("SubscriptionsListHead", "_LIST_ENTRY");
    wnfNameSubscription.Fields.Add("NormalDeliverySubscriptions", "int");
    wnfNameSubscription.Fields.Add("Unknown1", "int");
    wnfNameSubscription.Fields.Add("NotificationTypeCount0", "int");
    wnfNameSubscription.Fields.Add("NotificationTypeCount1", "int");
    wnfNameSubscription.Fields.Add("NotificationTypeCount2", "int");
    wnfNameSubscription.Fields.Add("NotificationTypeCount3", "int");
    wnfNameSubscription.Fields.Add("NotificationTypeCount4", "int");
    wnfNameSubscription.Fields.Add("Unknown2", "int");
    wnfNameSubscription.Fields.Add("Unknown3", "int");
    wnfNameSubscription.Fields.Add("RetryDescriptor", "_WNF_DELIVERY_DESCRIPTOR*");
    wnfNameSubscription.Fields.Add("DeliveryState", "int");
    wnfNameSubscription.Fields.Add("ReliableRetryTime", "__int64");

    var wnfUserSubscription = sym.Types.Create("_WNF_USER_SUBSCRIPTION");
    wnfUserSubscription.Fields.Add("Header", "_WNF_NODE_HEADER");
    wnfUserSubscription.Fields.Add("SubscriptionsListEntry", "_LIST_ENTRY");
    wnfUserSubscription.Fields.Add("NameSubscription", "_WNF_NAME_SUBSCRIPTION*");
    wnfUserSubscription.Fields.Add("Callback", "void*");
    wnfUserSubscription.Fields.Add("CallbackContext", "void*");
    wnfUserSubscription.Fields.Add("SubProcessTag", "__int64");
    wnfUserSubscription.Fields.Add("ChangeStamp", "int");
    wnfUserSubscription.Fields.Add("DeliveryOptions", "int");
    wnfUserSubscription.Fields.Add("SubscribedEventSet", "int");
    wnfUserSubscription.Fields.Add("SerializationGroup", "void*");
    wnfUserSubscription.Fields.Add("UserSubscriptionCount", "int");
    wnfUserSubscription.Fields.Add("Unknown1", "__int64");
    wnfUserSubscription.Fields.Add("Unknown2", "__int64");
    wnfUserSubscription.Fields.Add("Unknown3", "__int64");
    wnfUserSubscription.Fields.Add("Unknown4", "__int64");
    wnfUserSubscription.Fields.Add("Unknown5", "__int64");
    wnfUserSubscription.Fields.Add("Unknown6", "__int64");
    wnfUserSubscription.Fields.Add("Unknown7", "__int64");
    wnfUserSubscription.Fields.Add("Unknown8", "__int64");
    wnfUserSubscription.Fields.Add("Unknown9", "__int64");
    wnfUserSubscription.Fields.Add("Unknown10", "__int64");
}

function TestNewSymbols()
{
    var sym = host.namespace.Debugger.Utility.SymbolBuilder.CreateSymbols("nduprov.dll");
    var foo = sym.Types.Create("foo");
    foo.Fields.Add("x", "int");
}

```

`threadNames`:

```
dx -g @$cursession.Processes.SelectMany(p => p.Threads.Select(t => new {ThreadId = t.Id, Name = t.KernelObject.ThreadName ? t.KernelObject.ThreadName->ToDisplayString("sb") : "unnamed"})

```

`wow64_peb`:

```
# get the 64-bit and 32-bit PEB for all WoW64 processes

dx -g @$cursession.Processes.Where(p => p.KernelObject.WoW64Process).Select(p => new {Name = p.Name, Peb = p.KernelObject.Peb, Peb32 = p.KernelObject.WoW64Process->Peb})

```

`writeVerAccessInFile.txt`:

```txt
dx @$tmpFile = Debugger.Utility.FileSystem.TempDirectory.OpenFile("log.txt")
dx @$txtWriter = Debugger.Utility.FileSystem.CreateTextWriter(@$tmpFile)
ba r4 nt!PsInitialSystemProcess "dx @$txtWriter.WriteLine(@$getsym(@$curstack.Frames[0].Attributes.InstructionOffset)); g"
dx @$tmpFile.Close()
```