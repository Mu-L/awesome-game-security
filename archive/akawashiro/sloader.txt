Project Path: arc_akawashiro_sloader_xunr7tla

Source Tree:

```txt
arc_akawashiro_sloader_xunr7tla
├── CMakeLists.txt
├── CTestCustom.cmake
├── LICENSE
├── README.md
├── addr_to_offset.py
├── cmake
│   └── third-party.cmake
├── debian-Dockerfile
├── debug.gdb
├── dyn_loader.cc
├── dyn_loader.h
├── example
│   └── kernelvm
│       ├── hello.c
│       ├── hoge.c
│       └── run.sh
├── exec_loader.h
├── gen_libc_mapping.sh
├── ldsodefs.h
├── libc_mapping.cc
├── libc_mapping.h
├── make-sloader-itself.sh
├── misc
│   ├── build_chibicc.sh
│   ├── build_curl.sh
│   └── build_ninja.sh
├── perf_svg.sh
├── raw_write
│   └── raw_write.h
├── run-format.sh
├── scripts
│   ├── build_glibc.sh
│   └── clone_glibc.sh
├── sloader.cc
├── sloader.map
├── sloader_dl.cc
├── sloader_dl.h
├── sloader_static.map
├── tests
│   ├── CMakeLists.txt
│   ├── cascades
│   │   ├── CMakeLists.txt
│   │   ├── fuga.c
│   │   ├── hoge.c
│   │   ├── main.c
│   │   └── run.py
│   ├── compare_stdout.py
│   ├── constructor
│   │   ├── CMakeLists.txt
│   │   ├── hoge.c
│   │   ├── main.c
│   │   └── run.py
│   ├── dlopen
│   │   ├── CMakeLists.txt
│   │   ├── hoge.c
│   │   └── main.c
│   ├── dlopen2
│   │   ├── CMakeLists.txt
│   │   ├── hoge.c
│   │   └── main.c
│   ├── errno
│   │   ├── CMakeLists.txt
│   │   ├── main.c
│   │   └── run.py
│   ├── find_a_depending_so
│   │   ├── CMakeLists.txt
│   │   ├── hoge.c
│   │   ├── main.c
│   │   └── run.py
│   ├── generic_dynamic
│   │   ├── CMakeLists.txt
│   │   ├── hoge.c
│   │   ├── main.c
│   │   └── run.py
│   ├── global_variable
│   │   ├── CMakeLists.txt
│   │   ├── hoge.c
│   │   ├── main.c
│   │   └── run.py
│   ├── hello.asm
│   ├── hello.c
│   ├── hello.py
│   ├── hello_glibc
│   │   ├── CMakeLists.txt
│   │   ├── main.c
│   │   └── run.py
│   ├── hello_static_glibc
│   │   ├── CMakeLists.txt
│   │   ├── hello.c
│   │   └── run.py
│   ├── initial_exec
│   │   ├── CMakeLists.txt
│   │   ├── hoge.c
│   │   ├── main.c
│   │   └── run.py
│   ├── local_dynamic
│   │   ├── CMakeLists.txt
│   │   ├── hoge.c
│   │   ├── main.c
│   │   └── run.py
│   ├── local_exec
│   │   ├── CMakeLists.txt
│   │   ├── main.c
│   │   └── run.py
│   ├── ls
│   │   ├── CMakeLists.txt
│   │   ├── ls.c
│   │   └── run.py
│   ├── one_plus_one.sh
│   ├── print_args
│   │   ├── CMakeLists.txt
│   │   ├── main.c
│   │   └── run.py
│   ├── print_env_aux
│   │   ├── CMakeLists.txt
│   │   ├── print_env_aux.c
│   │   └── run.py
│   ├── static_struct
│   │   ├── CMakeLists.txt
│   │   ├── hoge.c
│   │   ├── main.c
│   │   └── run.py
│   └── torch_ones.py
├── third_party
│   └── glog.cmake
├── tls_secure.cc
├── ubuntu-Dockerfile
├── ubuntu_usr_bin_commands
├── utils.cc
├── utils.h
└── xapps-launched-by-sloader.png

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)
project(sloader)

enable_testing()
set(CMAKE_CXX_STANDARD 20)
if(NOT CMAKE_BUILD_TYPE)
  set(CMAKE_BUILD_TYPE "RelWithDebInfo")
endif()

set(CUSTOM_LIBC_PATH CACHE PATH "")

set(CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/cmake)

include(third-party)
set(WITH_GFLAGS
    OFF
    CACHE INTERNAL "" FORCE)
set(WITH_UNWIND OFF)
set(BUILD_SHARED_LIBS OFF)
add_definitions(-DC10_USE_GLOG=1)

include_directories(${CMAKE_CURRENT_SOURCE_DIR}/raw_write)

add_library(tls_secure tls_secure.cc)

if(CUSTOM_LIBC_PATH)
  execute_process(
    COMMAND ${CMAKE_CXX_COMPILER} --print-file-name=crtbegin.o
    OUTPUT_VARIABLE CRT_BEGIN
    OUTPUT_STRIP_TRAILING_WHITESPACE)
  execute_process(
    COMMAND ${CMAKE_CXX_COMPILER} --print-file-name=crtend.o
    OUTPUT_VARIABLE CRT_END
    OUTPUT_STRIP_TRAILING_WHITESPACE)
  execute_process(
    COMMAND ${CMAKE_CXX_COMPILER} --print-file-name=libstdc++.a
    OUTPUT_VARIABLE LIBSTDCXX
    OUTPUT_STRIP_TRAILING_WHITESPACE)

  add_executable(sloader sloader.cc dyn_loader.cc libc_mapping.cc sloader_dl.cc
                         utils.cc sloader_static.map)
  target_link_libraries(
    sloader
    ${CUSTOM_LIBC_PATH}/lib/crt1.o
    ${CUSTOM_LIBC_PATH}/lib/crti.o
    ${CRT_BEGIN}
    ${LIBSTDCXX}
    ${CUSTOM_LIBC_PATH}/lib/libpthread.a
    -Wl,--start-group
    ${CUSTOM_LIBC_PATH}/lib/libc.a
    -lgcc
    -lgcc_eh
    -Wl,--end-group
    ${CRT_END}
    ${CUSTOM_LIBC_PATH}/lib/crtn.o
    tls_secure)
  target_compile_options(sloader PUBLIC -Wall -Werror)
  target_link_options(
    sloader
    BEFORE
    PUBLIC
    -nostdlib
    -nostartfiles
    -static
    -Wl,-verbose
    -T
    ${CMAKE_CURRENT_SOURCE_DIR}/sloader_static.map)
else()
  add_executable(sloader sloader.cc dyn_loader.cc libc_mapping.cc sloader_dl.cc
                         utils.cc sloader_static.map)
  target_link_libraries(sloader tls_secure)
  target_compile_options(sloader PUBLIC -Wall -Werror)
  target_link_options(sloader PUBLIC -static -Wl,-verbose -T
                      ${CMAKE_CURRENT_SOURCE_DIR}/sloader_static.map)
endif()

configure_file(${CMAKE_CURRENT_SOURCE_DIR}/CTestCustom.cmake
               ${CMAKE_CURRENT_BINARY_DIR})

add_subdirectory(tests)

```

`CTestCustom.cmake`:

```cmake
set(CTEST_CUSTOM_TESTS_IGNORE
      demangle
      logging
      signalhandler
      stacktrace
      stl_logging
      symbolize
      cmake_package_config_init
      cmake_package_config_generate
      cleanup_immediately
      cleanup_with_absolute_prefix
      cleanup_with_relative_prefix
      cmake_package_config_build
      logging_custom_prefix
      cmake_package_config_cleanup
      cleanup_init
      cleanup_logdir
      )

```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.



```

`README.md`:

```md
# sloader <!-- omit in toc -->
`sloader` is an ELF loader that aims to replace `ld-linux.so.2` of glibc. 

## Notice
`sloader` haven't implmented almost all security related features. Please be careful.

## Table of Contents <!-- omit in toc -->
- [Current status](#current-status)
- [How to build and use](#how-to-build-and-use)
- [Why I am making alternative loader](#why-i-am-making-alternative-loader)
  - [What is a loader](#what-is-a-loader)
  - [Problem of `ld-linux.so`](#problem-of-ld-linuxso)
  - [Motivation of making sloader](#motivation-of-making-sloader)
  - [Developement principles of sloader](#developement-principles-of-sloader)
- [For developpers](#for-developpers)
  - [How to build and run tests](#how-to-build-and-run-tests)
  - [Test using custom build glibc](#test-using-custom-build-glibc)

## Current status
`sloader` can load many practical programs such as `cmake`, `g++`, `ld`, `htop`, etc. Furthermore, `sloader` can launche some GUI applications.
![GUI applications launched by sloader](./xapps-launched-by-sloader.png)

However, `sloader` depends on `ld-linux.so` because I cannot statically link `sloader` now. 

## How to build and use
```
$ git clone https://github.com/akawashiro/sloader.git
$ cd sloader
$ mkdir build
$ cmake -S . -B build -G Ninja
$ cmake --build build
$ ./build/sloader ls
```

## Why I am making alternative loader
### What is a loader
When you run an executable binary file on Linux using execve(2), there are two execution paths.
- Linux kernel loads the file to the memory space.
- The loader specified by the file loads the file to the memory space.

You can check the specified loader path using `readelf -l`. In most cases,  you will find `Requesting program interpreter: /lib64/ld-linux-x86-64.so.2` which means the loader loads the binary. Although the path includes `-x86-64` because my machine is x86-64, I call it `ld-linux.so` from now for generality.

```
$ readelf -l $(which nvim) | grep INTERP -A 2
  INTERP         0x0000000000000318 0x0000000000000318 0x0000000000000318
                 0x000000000000001c 0x000000000000001c  R      0x1
      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
```

`ld-linux.so` does three things when loading binary files.
- Seaches shared libraries that the file needs.
- Loads all shared libraries and the file to the memory.
- Resolves symbols of shared libraries and the file.

It is important to understand precisely how `ld-linux.so` works. For example, valuable hacks with environment variables such as LD_PRELOAD and LD_AUDIT are implemented by changing their behavior. Understanding the behavior of `ld-linux.so` will allow you to infer what these environment variables can and cannot do. Also, understanding it is essential for creating software like [https://github.com/akawashiro/sold](https://github.com/akawashiro/sold) that forcibly links shared libraries.

### Problem of `ld-linux.so`
`ld-linux.so` is installed on Linux as part of GNU libc, and its complete source code is publicly available. However, two problems exist in understanding the behavior of `ld-linux.so` from the published source code.

The first problem is that the GNU libc source code is hard to read. GNU libc is a software with a long history written in C language. It also requires portability to multiple architectures such as x86-84, Alpha, ARM, and PowerPC. As a result, macros are used extensively throughout the source code, making it difficult to follow the flow of the program.

The second problem is that `libc.so` is simultaneously initialized when `ld-linux.so` loads an executable file. And it is hard to understand the initialization and the loading process separately. libc.so is the so-called standard C library, which is almost certainly loaded when the binary file is loaded by `ld-linux.so`. `libc.so` and `ld-linux.so` are in the same package, and glibc doesn't explicitly document the relationship between the two components.

### Motivation of making sloader
To solve the above problems and understand `ld-linux.so` behavior, I decided to develop a new loader that can replace `ld-linux.so` . In other words, I am trying to load all the programs that start on Linux (`systemd`, `cat`, `find`, `firefox`, etc.). 

### Developement principles of sloader
I decided the following two principles when I started the development.

The first principle is to use modern C++ instead of C. I try to use modern C++ features up to C++20 to improve readability. I considered using Rust, but I decided that a language compatible with the C language would be better because I would be developing while referring to the GNU libc source code.

The second principle is not to initialize `libc.so`. The purpose is to understand only the load part, so I will not do the complicated `libc.so`.

## For developpers
### How to build and run tests
```
$ git clone https://github.com/akawashiro/sloader.git
$ cd sloader
$ mkdir build
$ cmake -S . -B build -G Ninja
$ cmake --build build
$ cd build
$ ctest -V
```

### Test using custom build glibc
```
$ git clone https://github.com/akawashiro/sloader.git
$ cd sloader
$ mkdir build
$ cmake -S . -B build -G Ninja
$ cmake --build build
$ ./misc/clone_glibc.sh
$ ./misc/build_glibc.sh
$ SLOADER_LIBRARY_PATH=/home/akira/sloader/glibc-install/lib ./build/sloader ./build/tests/hello_glibc/hello_glibc
```

```

`addr_to_offset.py`:

```py
#! python3

import argparse
import pathlib
import subprocess

parser = argparse.ArgumentParser()
parser.add_argument('map_file', type=pathlib.Path)
parser.add_argument('address', type=str)

args = parser.parse_args()
if args.address[0:2] == "0x":
    address = int(args.address, 16)
else:
    address = int(args.address)

with open(args.map_file) as f:
    for line in f.readlines():
        fields = line.split(" ")
        filename = fields[0]
        file_start = int(fields[1][:18], 16)
        file_end = int(fields[1][19:37], 16)
        mem_start = int(fields[5][:18], 16)
        mem_end = int(fields[5][19:37], 16)

        if mem_start <= address and address <= mem_end:
            print(filename, ":", hex(address - mem_start + file_start))
            addr2line_cmd = ["addr2line", "-e", filename, hex(address - mem_start + file_start)]
            comp = subprocess.run(addr2line_cmd, capture_output=True)
            print(comp.stdout.decode("utf-8"), end="")

```

`cmake/third-party.cmake`:

```cmake
# Download and unpack a third-party library at configure time
# The original code is at the README of google-test:
# https://github.com/google/googletest/tree/master/googletest
function(get_third_party name)
    configure_file(
        "${PROJECT_SOURCE_DIR}/third_party/${name}.cmake"
        "${CMAKE_CURRENT_BINARY_DIR}/${name}-download/CMakeLists.txt")
    execute_process(COMMAND ${CMAKE_COMMAND} -G "${CMAKE_GENERATOR}" .
        RESULT_VARIABLE result
        WORKING_DIRECTORY "${CMAKE_CURRENT_BINARY_DIR}/${name}-download")
    if(result)
        message(FATAL_ERROR "CMake step for ${name} failed: ${result}")
    endif()
    execute_process(COMMAND ${CMAKE_COMMAND} --build .
        RESULT_VARIABLE result
        WORKING_DIRECTORY "${CMAKE_CURRENT_BINARY_DIR}/${name}-download")
    if(result)
        message(FATAL_ERROR "Build step for ${name} failed: ${result}")
    endif()
endfunction()

```

`debian-Dockerfile`:

```
FROM debian:12.2
ENV DEBIAN_FRONTEND=noninteractive
RUN apt-get update
RUN apt-get install -y ninja-build cmake gcc g++ git python3 python3-distutils python3-dev python3-pip nasm clang-format libcap-dev tmux zsh neovim ccache gawk bison
# RUN pip3 install torch==1.13.0+cpu -f https://download.pytorch.org/whl/torch_stable.html
COPY . /sloader
WORKDIR /sloader
RUN ./scripts/clone_glibc.sh glibc-2.36
RUN ./scripts/build_glibc.sh
RUN rm -rf build
RUN mkdir build
RUN cmake -GNinja -S . -B build -DCUSTOM_LIBC_PATH=/sloader/glibc-install
RUN cmake --build build -j $(nproc)
RUN cd build && ctest --output-on-failure -j $(nproc)
RUN ./make-sloader-itself.sh

```

`debug.gdb`:

```gdb
b Execute
r
b *0x4016c0
b *0x4027a0
b *0x00000000004017e5
b *0x00000000004017e6
c
# _dl_aux_init
# b *0x442180
# c
# Just after call of _dl_aux_init
# b *0x402800
# SIGSEGV in __tunable_get_val
b *0x442110
c

```

`dyn_loader.cc`:

```cc
#include "dyn_loader.h"

#include <asm/prctl.h>
#include <elf.h>
#include <fcntl.h>
#include <sys/auxv.h>
#include <sys/mman.h>
#include <sys/prctl.h>
#include <sys/stat.h>

#include <cstring>
#include <filesystem>
#include <fstream>
#include <map>
#include <memory>
#include <optional>

#include "libc_mapping.h"
#include "utils.h"

extern thread_local unsigned long sloader_dummy_to_secure_tls_space[];
extern unsigned long sloader_tls_offset;
void write_sloader_dummy_to_secure_tls_space();

namespace {

void read_ldsoconf_dfs(std::vector<std::filesystem::path>& res, const std::string& filename) {
    std::ifstream f;
    f.open(filename);

    // TODO: Workaround not to load i386 libs.
    if (!f || filename.find("i386") != std::string::npos || filename.find("lib32") != std::string::npos) {
        return;
    }
    std::string head;
    while (f >> head) {
        if (head.substr(0, 1) == "#") {
            std::string comment;
            std::getline(f, comment);
        } else if (head == "include") {
            std::string descendants;
            f >> descendants;

            glob_t globbuf;
            glob(descendants.c_str(), 0, NULL, &globbuf);
            for (size_t i = 0; i < globbuf.gl_pathc; i++) {
                read_ldsoconf_dfs(res, globbuf.gl_pathv[i]);
            }
            globfree(&globbuf);
        } else {
            res.push_back(head);
        }
    }
}

}  // namespace

std::vector<std::filesystem::path> read_ldsoconf() {
    std::vector<std::filesystem::path> res;
    read_ldsoconf_dfs(res, "/etc/ld.so.conf");

    return res;
}

ELFBinary::ELFBinary(const std::filesystem::path path) : path_(path) {
    int fd = open(path_.c_str(), O_RDONLY);
    LOG(INFO) << LOG_KEY(path_) << LOG_KEY(fd);
    CHECK(fd >= 0);

    size_t size = lseek(fd, 0, SEEK_END);
    CHECK_GT(size, 8UL + 16UL);

    size_t mapped_size = (size + 0xfff) & ~0xfff;

    file_base_addr_ = (char*)mmap(NULL, mapped_size, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE, fd, 0);
    CHECK(file_base_addr_ != MAP_FAILED);

    ehdr_ = *reinterpret_cast<Elf64_Ehdr*>(file_base_addr_);
    for (uint16_t i = 0; i < ehdr_.e_phnum; i++) {
        Elf64_Phdr ph = *reinterpret_cast<Elf64_Phdr*>(file_base_addr_ + ehdr_.e_phoff + i * ehdr_.e_phentsize);
        file_phdrs_.emplace_back(ph);

        if (ph.p_type == PT_DYNAMIC) {
            LOG(INFO) << "Found PT_DYNAMIC";
            file_dynamic_ = ph;
        } else if (ph.p_type == PT_TLS) {
            LOG(INFO) << "Found PT_TLS";
            has_tls_ = true;
            file_tls_ = ph;
        }
    }
}

Elf64_Addr ELFBinary::Load(Elf64_Addr base_addr_arg, std::shared_ptr<std::ofstream> map_file) {
    LOG(INFO) << LOG_BITS(base_addr_arg);
    base_addr_ = (ehdr().e_type == ET_DYN) ? base_addr_arg : 0;
    end_addr_ = base_addr_;

    LOG(INFO) << "Load start " << path_;

    for (auto ph : file_phdrs_) {
        if (ph.p_type != PT_LOAD) {
            continue;
        }
        LOG(INFO) << LOG_BITS(reinterpret_cast<void*>(ph.p_vaddr)) << LOG_BITS(ph.p_memsz);
        void* mmap_start = reinterpret_cast<void*>(((ph.p_vaddr + base_addr()) & (~(0xfff))));
        void* mmap_end = reinterpret_cast<void*>((((ph.p_vaddr + ph.p_memsz + base_addr()) + 0xfff) & (~(0xfff))));
        end_addr_ = reinterpret_cast<Elf64_Addr>(mmap_end);
        size_t mmap_size = reinterpret_cast<size_t>(mmap_end) - reinterpret_cast<size_t>(mmap_start);
        int flags = 0;
        std::string flags_str = "";
        if (ph.p_flags & PF_R) {
            flags |= PROT_READ;
            flags_str += "r";
        } else {
            flags_str += "_";
        }
        if ((ph.p_flags & PF_W) || true) {  // TODO: We need to write contents after mmap.
            flags |= PROT_WRITE;
            flags_str += "w";
        } else {
            flags_str += "_";
        }
        if (ph.p_flags & PF_X) {
            flags |= PROT_EXEC;
            flags_str += "x";
        } else {
            flags_str += "_";
        }

        char* p = reinterpret_cast<char*>(mmap(mmap_start, mmap_size, flags, MAP_SHARED | MAP_ANONYMOUS, -1, 0));
        LOG(INFO) << "mmap: " << LOG_KEY(path_) << LOG_BITS(p) << LOG_BITS(mmap_start) << LOG_BITS(ph.p_vaddr)
                  << "errno = " << std::strerror(errno);
        CHECK_EQ(mmap_start, reinterpret_cast<void*>(p));
        CHECK_LE(reinterpret_cast<Elf64_Addr>(mmap_start), ph.p_vaddr + base_addr());
        CHECK_LE(ph.p_vaddr + base_addr() + ph.p_memsz, reinterpret_cast<Elf64_Addr>(mmap_end));
        LOG(INFO) << LOG_BITS(mmap_start) << LOG_BITS(reinterpret_cast<size_t>(file_base_addr_ + ph.p_offset)) << LOG_BITS(ph.p_filesz);
        *map_file << path().string() << " " << HexString(ph.p_offset, 16) << "-" << HexString(ph.p_offset + ph.p_filesz, 16) << " "
                  << flags_str << " " << HexString(ph.p_filesz, 16) << " => " << HexString(mmap_start, 16) << "-" << HexString(mmap_end, 16)
                  << std::endl;
        memcpy(reinterpret_cast<void*>(ph.p_vaddr + base_addr()), file_base_addr_ + ph.p_offset, ph.p_filesz);
    }
    LOG(INFO) << "Load end";

    LOG(INFO) << "ParseDynamic start";
    ParseDynamic();
    LOG(INFO) << "ParseDynamic end";

    return (end_addr() + (0x400000 - 1)) / 0x400000 * 0x400000;
}

void ELFBinary::ParseDynamic() {
    // Must mmap PT_LOADs before call ParseDynamic.
    CHECK(base_addr_ != 0UL || ehdr_.e_type == ET_EXEC);

    const size_t dyn_size = sizeof(Elf64_Dyn);
    CHECK_EQ(file_dynamic_.p_filesz % dyn_size, 0U);

    // Search DT_STRTAB at first.
    for (size_t i = 0; i < file_dynamic_.p_filesz / dyn_size; ++i) {
        Elf64_Dyn* dyn = reinterpret_cast<Elf64_Dyn*>(base_addr_ + file_dynamic_.p_vaddr + dyn_size * i);
        LOG(INFO) << LOG_KEY(dyn);
        if (dyn->d_tag == DT_STRTAB) {
            LOG(INFO) << "Found DT_STRTAB";
            strtab_ = reinterpret_cast<char*>(dyn->d_un.d_ptr + base_addr_);
        } else if (dyn->d_tag == DT_STRSZ) {
            LOG(INFO) << "Found DT_STRSZ";
            strsz_ = dyn->d_un.d_val;
        }
    }

    CHECK(strtab_ != nullptr || ehdr_.e_type == ET_EXEC);

    for (size_t i = 0; i < file_dynamic_.p_filesz / dyn_size; ++i) {
        Elf64_Dyn* dyn = reinterpret_cast<Elf64_Dyn*>(base_addr_ + file_dynamic_.p_vaddr + dyn_size * i);
        if (dyn->d_tag == DT_NEEDED) {
            std::string needed = strtab_ + dyn->d_un.d_val;
            neededs_.emplace_back(needed);
            LOG(INFO) << LOG_KEY(needed);
        } else if (dyn->d_tag == DT_RUNPATH) {
            // TODO: Handle relative path
            runpath_ = strtab_ + dyn->d_un.d_val;
        } else if (dyn->d_tag == DT_RPATH) {
            // TODO: Handle relative path
            rpath_ = strtab_ + dyn->d_un.d_val;
        } else if (dyn->d_tag == DT_RELA) {
            LOG(INFO) << "Found DT_RELA";
            rela_ = reinterpret_cast<Elf64_Rela*>(base_addr_ + dyn->d_un.d_val);
        } else if (dyn->d_tag == DT_RELASZ) {
            relasz_ = dyn->d_un.d_val;
        } else if (dyn->d_tag == DT_RELAENT) {
            relaent_ = dyn->d_un.d_val;
        } else if (dyn->d_tag == DT_RELACOUNT) {
            relacount_ = dyn->d_un.d_val;
        } else if (dyn->d_tag == DT_JMPREL) {
            jmprel_ = reinterpret_cast<Elf64_Rela*>(base_addr_ + dyn->d_un.d_val);
        } else if (dyn->d_tag == DT_PLTRELSZ) {
            pltrelsz_ = dyn->d_un.d_val;
        } else if (dyn->d_tag == DT_PLTREL) {
            pltrel_ = dyn->d_un.d_val;
            CHECK(pltrel_ == DT_RELA || pltrel_ == DT_REL);
            pltrelent_ = (pltrel_ == DT_RELA) ? sizeof(Elf64_Rela) : sizeof(Elf64_Rel);
        } else if (dyn->d_tag == DT_SYMTAB) {
            symtab_ = reinterpret_cast<Elf64_Sym*>(base_addr_ + dyn->d_un.d_val);
        } else if (dyn->d_tag == DT_SYMENT) {
            syment_ = dyn->d_un.d_val;
            CHECK_EQ(syment_, sizeof(Elf64_Sym));
        } else if (dyn->d_tag == DT_INIT) {
            init_ = dyn->d_un.d_val;
        } else if (dyn->d_tag == DT_FINI) {
            fini_ = dyn->d_un.d_val;
        } else if (dyn->d_tag == DT_INIT_ARRAY) {
            init_array_ = dyn->d_un.d_val;
        } else if (dyn->d_tag == DT_INIT_ARRAYSZ) {
            init_arraysz_ = dyn->d_un.d_val;
        } else if (dyn->d_tag == DT_FINI_ARRAY) {
            fini_array_ = dyn->d_un.d_val;
        } else if (dyn->d_tag == DT_FINI_ARRAYSZ) {
            fini_arraysz_ = dyn->d_un.d_val;
        }
    }

    LOG(INFO) << LOG_KEY(relasz_) << LOG_KEY(relaent_) << LOG_KEY(relacount_);
    if (rela_ != nullptr) {
        CHECK_EQ(relasz_ % relaent_, 0UL);
        Elf64_Rela* r = rela_;
        for (size_t i = 0; i < relasz_ / relaent_; i++, r++) {
            relas_.emplace_back(*r);
            LOG(INFO) << ShowRela(relas_.back());
        }
    }

    LOG(INFO) << LOG_KEY(pltrelsz_) << LOG_KEY(pltrelent_);
    if (jmprel_ != nullptr) {
        CHECK_EQ(pltrelsz_ % pltrelent_, 0UL);
        CHECK_EQ(pltrel_, static_cast<unsigned long>(DT_RELA));
        Elf64_Rela* r = jmprel_;
        for (size_t i = 0; i < pltrelsz_ / pltrelent_; i++, r++) {
            pltrelas_.emplace_back(*r);
            LOG(INFO) << ShowRela(pltrelas_.back());
        }
    }

    if (symtab_ != nullptr) {
        Elf64_Sym* s = symtab_;
        symtabs_.emplace_back(*s);
        s++;

        // TODO: This is a hack. Listing up all symbols is always difficult.
        while (0 <= s->st_name && s->st_name < strsz_) {
            symtabs_.emplace_back(*s);
            s++;
        }

        for (const auto& s : symtabs_) {
            LOG(INFO) << LOG_KEY(s.st_name);
            LOG(INFO) << ShowSym(s, strtab_);
        }
    }
}

const Elf64_Addr ELFBinary::GetSymbolAddr(const size_t symbol_index) {
    CHECK_LT(symbol_index, symtabs().size());
    return symtabs()[symbol_index].st_value + base_addr();
}

std::filesystem::path FindLibrary(std::string library_name, std::optional<std::filesystem::path> runpath,
                                  std::optional<std::filesystem::path> rpath) {
    {
        std::filesystem::path library_path(library_name);
        if (library_path.is_absolute() && std::filesystem::exists(library_path)) {
            return library_path;
        }
    }

    std::vector<std::filesystem::path> library_directory;

    std::string sloader_library_path(std::getenv("SLOADER_LIBRARY_PATH") == nullptr ? "" : std::getenv("SLOADER_LIBRARY_PATH"));
    if (!sloader_library_path.empty()) {
        library_directory.emplace_back(sloader_library_path);
    }

    if (runpath) {
        library_directory.emplace_back(runpath.value());
    }
    if (rpath) {
        library_directory.emplace_back(rpath.value());
    }
    const auto ldsoconfs = read_ldsoconf();
    library_directory.insert(library_directory.end(), ldsoconfs.begin(), ldsoconfs.end());
    library_directory.emplace_back("/lib");
    library_directory.emplace_back("/usr/lib");
    library_directory.emplace_back("/usr/lib64");
    library_directory.emplace_back("/usr/lib/x86_64-linux-gnu");
    library_directory.emplace_back(".");

    for (const auto& d : library_directory) {
        if(!std::filesystem::is_directory(d)) {
            continue;
        }

        std::string searching_filename = std::filesystem::path(library_name).filename();
        for (const auto& entry : std::filesystem::directory_iterator(d)) {
            LOG(INFO) << LOG_KEY(entry.path().filename().string()) << LOG_KEY(searching_filename);
            if (entry.path().filename().string().starts_with(searching_filename)) {
                LOG(INFO) << LOG_KEY(entry.path());
                return entry.path();
            }
        }
    }
    LOG(FATAL) << "Cannot find" << LOG_KEY(library_name);
    std::abort();
}

void DynLoader::LoadDependingLibs(const std::filesystem::path& root_path) {
    binaries_.emplace_back(ELFBinary(root_path));
    next_base_addr_ = binaries_.back().Load(next_base_addr_, map_file_);
    loaded_.insert(root_path.filename());

    std::queue<std::tuple<std::string, std::optional<std::filesystem::path>, std::optional<std::filesystem::path>>> queue;

    for (const auto& n : binaries_.back().neededs()) {
        queue.push(std::make_tuple(n, binaries_.back().runpath(), binaries_.back().rpath()));
    }

    // Search depending sos.
    while (!queue.empty()) {
        const auto [library_name, runpath, rpath] = queue.front();
        queue.pop();

        if (loaded_.count(library_name) != 0) continue;
        loaded_.insert(library_name);

        // Skip dynamic loader and libc.so
        if (library_name.find("ld-linux") != std::string::npos || library_name.find("libc.so") != std::string::npos) {
            LOG(INFO) << "Skip " << library_name;
            continue;
        }

        const auto library_path = FindLibrary(library_name, runpath, rpath);
        binaries_.emplace_back(ELFBinary(library_path));
        next_base_addr_ = binaries_.back().Load(next_base_addr_, map_file_);
        for (const auto& n : binaries_.back().neededs()) {
            queue.push(std::make_tuple(n, binaries_.back().runpath(), binaries_.back().rpath()));
        }
    }
}

DynLoader::DynLoader(const std::filesystem::path& main_path, const std::vector<std::string>& args, const std::vector<std::string>& envs)
    : main_path_(main_path), args_(args), envs_(envs), next_base_addr_(0x140'0000) {
    map_file_ =
        std::make_shared<std::ofstream>(std::getenv("SLOADER_MAP_FILE") == nullptr ? "/tmp/sloader_map" : std::getenv("SLOADER_MAP_FILE"));
}

void DynLoader::Run() {
    LoadDependingLibs(main_path_);
    Relocate();
    Execute(args_, envs_);
}

// To assign variables of stack, stack_num and entry to %rdi, %rsi and %rdx
// I use the calling convention. For details, see A.2.1 Calling Conventions
// in https://refspecs.linuxfoundation.org/elf/x86_64-abi-0.99.pdf. Of
// course, compiler must not inline this function.
void __attribute__((noinline)) DynLoader::ExecuteCore(uint64_t* stack, size_t stack_num, uint64_t entry) {
    for (size_t i = 0; i < stack_num; i++) {
        asm volatile("pushq %0" ::"m"(*(stack + i)));
    }

    asm volatile("jmp *%0" ::"r"(entry));
}

// Copied from glibc
// Type of a constructor function, in DT_INIT, DT_INIT_ARRAY, DT_PREINIT_ARRAY.
// argc, argv, env
typedef void (*dl_init_t)(int, char**, char**);

void DynLoader::Execute(std::vector<std::string> args, std::vector<std::string> envs) {
    // TODO: Pass arguments
    char* argv[] = {const_cast<char*>(main_path_.c_str())};
    char** env = reinterpret_cast<char**>(malloc(sizeof(const char*) * envs.size()));
    for (size_t i = 0; i < envs.size(); i++) {
        env[i] = const_cast<char*>(envs[i].c_str());
    }

    for (int i = binaries_.size() - 1; 0 <= i; i--) {
        if (binaries_[i].init() != 0) {
            reinterpret_cast<dl_init_t>(binaries_[i].init() + binaries_[i].base_addr())(1, argv, env);
        }
        if (binaries_[i].init_arraysz() != 0) {
            CHECK_EQ(binaries_[i].init_arraysz() % 8, 0UL);  // Assume 64bits
            LOG(INFO) << LOG_BITS(i) << LOG_BITS(binaries_[i].init_arraysz());
            Elf64_Addr* init_array_funs =
                reinterpret_cast<Elf64_Addr*>((reinterpret_cast<char**>(binaries_[i].init_array() + binaries_[i].base_addr())));

            for (long unsigned int j = 0; j < binaries_[i].init_arraysz() / 8; j++) {
                LOG(INFO) << LOG_KEY(binaries_[i].filename()) << LOG_BITS(binaries_[i].init_array()) << LOG_BITS(init_array_funs[j])
                          << LOG_BITS(binaries_[i].base_addr()) << LOG_BITS(init_array_funs[j] + binaries_[i].base_addr());
                if (reinterpret_cast<dl_init_t>(init_array_funs[j]) == nullptr) {
                    LOG(FATAL) << LOG_BITS(init_array_funs[j]);
                    break;
                }
                reinterpret_cast<dl_init_t>(init_array_funs[j])(1, argv, env);
            }
        }
    }

    unsigned long at_random = getauxval(AT_RANDOM);
    unsigned long at_pagesz = getauxval(AT_PAGESZ);
    CHECK_NE(at_random, 0UL);
    LOG(INFO) << LOG_BITS(at_random) << LOG_BITS(at_pagesz);

    // Some commented out auxiliary values because they are not appropriate
    // as loading programs. These values are for sloader itself.
    std::vector<unsigned long> aux_types{AT_IGNORE,
                                         // AT_EXECFD,
                                         // AT_PHDR,
                                         AT_PHENT,
                                         // AT_PHNUM,
                                         AT_PAGESZ,
                                         // AT_BASE,
                                         AT_FLAGS,
                                         // AT_ENTRY,
                                         AT_NOTELF, AT_UID, AT_EUID, AT_GID, AT_EGID, AT_CLKTCK, AT_PLATFORM, AT_HWCAP, AT_FPUCW,
                                         AT_DCACHEBSIZE, AT_ICACHEBSIZE, AT_UCACHEBSIZE, AT_IGNOREPPC, AT_SECURE, AT_BASE_PLATFORM,
                                         AT_RANDOM, AT_HWCAP2,
                                         // AT_EXECFN,
                                         AT_SYSINFO, AT_SYSINFO_EHDR, AT_L1I_CACHESHAPE, AT_L1D_CACHESHAPE, AT_L2_CACHESHAPE,
                                         AT_L3_CACHESHAPE, AT_L1I_CACHESIZE, AT_L1I_CACHEGEOMETRY, AT_L1D_CACHESIZE, AT_L1D_CACHEGEOMETRY,
                                         AT_L2_CACHESIZE, AT_L2_CACHEGEOMETRY, AT_L3_CACHESIZE, AT_L3_CACHEGEOMETRY, AT_MINSIGSTKSZ};

    std::vector<std::pair<unsigned long, unsigned long>> aux_tvs;
    for (size_t i = 0; i < aux_types.size(); i++) {
        unsigned long v = getauxval(aux_types[i]);
        if (v != 0) {
            aux_tvs.emplace_back(std::make_pair(aux_types[i], v));
            LOG(INFO) << LOG_BITS(aux_types[i]) << LOG_BITS(v);
        }
    }

    // See http://articles.manugarg.com/aboutelfauxiliaryvectors.html for
    // the stack layout padding.
    //
    // 4 words padding
    // 0
    // AT_NULL
    // auxs
    // NULL
    // envs
    // argv[argc] (must be null)
    // argv[0] = filename
    // argc
    size_t stack_index = 0;
    size_t stack_num = 4 + 2 + 2 * aux_tvs.size() + 1 + envs.size() + 2 + args.size();
    size_t stack_size = sizeof(uint64_t) * stack_num;
    unsigned long* stack = reinterpret_cast<uint64_t*>(malloc(stack_size));
    memset(stack, 0, stack_size);

    // 4 words padding
    stack_index += 4;

    // First two elements are 0 and AT_NULL.
    stack_index += 2;

    // auxs
    for (size_t i = 0; i < aux_tvs.size(); i++) {
        *(stack + stack_index) = aux_tvs[i].second;
        stack_index++;
        *(stack + stack_index) = aux_tvs[i].first;
        stack_index++;
    }

    // End of environment variables
    stack_index++;

    // Environment variables
    for (size_t i = 0; i < envs.size(); i++) {
        *(stack + stack_index) = reinterpret_cast<uint64_t>(envs[envs.size() - 1 - i].c_str());
        stack_index++;
    }

    // argv[argc]
    stack_index++;

    for (size_t i = 0; i < args.size(); i++) {
        LOG(INFO) << (args[i]);
        *(stack + stack_index) = reinterpret_cast<uint64_t>(args[args.size() - 1 - i].c_str());
        stack_index++;
    }

    // argc
    *(stack + stack_index) = args.size();
    stack_index++;

    CHECK_EQ(stack_index, stack_num);

    LOG(INFO) << LOG_BITS(binaries_[0].ehdr().e_entry + binaries_[0].base_addr()) << std::endl;

    // TLS initialization
    // TODO: We support only static TLS i.e. don't support dlopen.
    //
    // =========== address ==========>
    //
    // tls_block (= sloader_dummy_to_secure_tls_space)                       tls_block + TLS_SPACE_FOR_LOADEE
    // |                                                                                                   |
    // v                                                                                                   v
    // [.tdata of binaries_[n]] [.tbss of binaries_[n]] ... [.tdata of binaries_[0]] [.tbss of binaries_[0]]

    {
        size_t tls_block_size = 0;
        for (const ELFBinary& b : binaries_) {
            if (b.has_tls()) {
                tls_block_size += b.file_tls().p_memsz;
            }
        }
        CHECK_LE(tls_block_size, 4096UL);
    }

    void* tls_block = sloader_dummy_to_secure_tls_space;

    // Copy .tdata and .tbss of each binary
    for (const ELFBinary& b : binaries_) {
        if (b.has_tls()) {
            LOG(INFO) << LOG_BITS(reinterpret_cast<uint64_t>(tls_block)) << LOG_BITS(reinterpret_cast<uint64_t>(b.file_tls().p_memsz));
            LOG(INFO) << LOG_BITS(reinterpret_cast<uint64_t>(b.file_tls().p_memsz))
                      << LOG_BITS(reinterpret_cast<uint64_t>(b.file_tls().p_filesz)) << LOG_KEY(b.path());

            // Set .tdata
            memcpy(reinterpret_cast<char*>(tls_block) + sloader_tls_offset - b.file_tls().p_memsz,
                   reinterpret_cast<const void*>(b.base_addr() + b.file_tls().p_vaddr), b.file_tls().p_memsz);
            // Set .tbss
            memset(reinterpret_cast<char*>(tls_block) + sloader_tls_offset - (b.file_tls().p_memsz - b.file_tls().p_filesz), 0x0,
                   b.file_tls().p_memsz - b.file_tls().p_filesz);

            *reinterpret_cast<void**>(reinterpret_cast<char*>(tls_block) + sloader_tls_offset) =
                reinterpret_cast<char*>(tls_block) + sloader_tls_offset;
            sloader_tls_offset -= b.file_tls().p_memsz;
        }
    }

    ExecuteCore(stack, stack_num, binaries_[0].ehdr().e_entry + binaries_[0].base_addr());

    free(stack);
    LOG(INFO) << "Execute end";
}

// Search the first defined symbol
// Return pair of the index of ELFBinary and the index of the Elf64_Sym
// TODO: Consider version information
// TODO: Return ELFBinary and Elf64_Sym theirselves
std::optional<std::pair<size_t, size_t>> DynLoader::SearchSym(const std::string& name, bool skip_main = false) {
    LOG(INFO) << "========== SearchSym " << name << " ==========";
    // binaries_[0] is the executable itself. We should skip it.
    // TODO: Add reference here.
    for (size_t i = skip_main ? 1 : 0; i < binaries_.size(); i++) {
        for (size_t j = 0; j < binaries_[i].symtabs().size(); j++) {
            const Elf64_Sym& s = binaries_[i].symtabs()[j];
            std::string_view n(s.st_name + binaries_[i].strtab());
            if (n == name && s.st_shndx != SHN_UNDEF) {
                LOG(INFO) << "Found " << name << " at index " << j << " of " << binaries_[i].path();
                return std::make_optional(std::make_pair(i, j));
            }
        }
    }
    for (size_t i = skip_main ? 1 : 0; i < binaries_.size(); i++) {
        for (size_t j = 0; j < binaries_[i].symtabs().size(); j++) {
            const Elf64_Sym& s = binaries_[i].symtabs()[j];
            std::string_view n(s.st_name + binaries_[i].strtab());
            if (n == name && s.st_shndx == SHN_UNDEF && ELF64_ST_BIND(s.st_info) == STB_WEAK) {
                LOG(WARNING) << "Found " << name << " at index as an weak symbol " << j << " of " << binaries_[i].path();
                return std::make_optional(std::make_pair(i, j));
            }
        }
    }
    return std::nullopt;
}

Elf64_Addr DynLoader::TLSSymOffset(const std::string& name) {
    // Intentional use of underflow
    Elf64_Addr offset = 0x0;
    for (size_t i = 0; i < binaries_.size(); i++) {
        for (size_t j = 0; j < binaries_[i].symtabs().size(); j++) {
            Elf64_Sym s = binaries_[i].symtabs()[j];
            std::string n = s.st_name + binaries_[i].strtab();
            if (n == name && s.st_shndx != SHN_UNDEF && ELF64_ST_TYPE(s.st_info) == STT_TLS) {
                Elf64_Addr o = offset - binaries_[i].file_tls().p_memsz + s.st_value;
                LOG(INFO) << "Found " << name << " at index " << j << " of " << binaries_[i].path() << LOG_BITS(o);
                return offset - binaries_[i].file_tls().p_memsz + s.st_value;
            }
        }
        if (binaries_[i].has_tls()) {
            offset -= binaries_[i].file_tls().p_memsz;
        }
    }

    // Workaround for TLS variable in libc.so such as errno
    if (libc_mapping::sloader_libc_tls_variables.find(name) != libc_mapping::sloader_libc_tls_variables.end()) {
        const char* addr = libc_mapping::sloader_libc_tls_variables[name];
        return (reinterpret_cast<const char*>(sloader_dummy_to_secure_tls_space) + 4096 - addr);
    }
    LOG(FATAL) << "Cannot find " << name;
    std::abort();
}

void DynLoader::Relocate() {
    for (const auto& bin : binaries_) {
        LOG(INFO) << bin.path();
        if (relocated_[bin.path()]) continue;
        relocated_[bin.path()] = true;

        std::vector<Elf64_Rela> relas = bin.pltrelas();
        // TODO: Use std::copy?
        for (const auto r : bin.relas()) {
            relas.emplace_back(r);
        }

        for (const auto& r : relas) {
            CHECK_LT(ELF64_R_SYM(r.r_info), bin.symtabs().size());
            Elf64_Sym s = bin.symtabs()[ELF64_R_SYM(r.r_info)];
            std::string name = s.st_name + bin.strtab();
            LOG(INFO) << ShowRela(r) << LOG_KEY(name);

            switch (ELF64_R_TYPE(r.r_info)) {
                case R_X86_64_GLOB_DAT:
                case R_X86_64_JUMP_SLOT: {
                    LOG(INFO) << ShowRelocationType(ELF64_R_TYPE(r.r_info));
                    const auto opt = SearchSym(name);
                    Elf64_Addr sym_addr;

                    if (libc_mapping::sloader_libc_map.find(name) != libc_mapping::sloader_libc_map.end()) {
                        sym_addr = libc_mapping::sloader_libc_map[name];
                    } else if (opt) {
                        const auto [bin_index, sym_index] = opt.value();
                        sym_addr = binaries_[bin_index].GetSymbolAddr(sym_index);
                    } else {
                        LOG(WARNING) << "Cannot find " << name << LOG_KEY(bin.path());
                        break;
                    }

                    Elf64_Addr* reloc_addr = reinterpret_cast<Elf64_Addr*>(bin.base_addr() + r.r_offset);
                    LOG(INFO) << LOG_KEY(reloc_addr) << LOG_BITS(*reloc_addr) << LOG_BITS(sym_addr);
                    // TODO: Although glibc add sym_addr to the original value
                    // here
                    // https://github.com/akawashiro/glibc/blob/008003dc6e83439c5e04a744b7fd8197df19096e/sysdeps/x86_64/dl-machine.h#L561,
                    // We just assign it.
                    *reloc_addr = sym_addr;
                    break;
                }
                    // TODO: Is is correct?
                case R_X86_64_IRELATIVE:
                case R_X86_64_RELATIVE: {
                    Elf64_Addr* reloc_addr = reinterpret_cast<Elf64_Addr*>(bin.base_addr() + r.r_offset);
                    *reloc_addr = reinterpret_cast<Elf64_Addr>(bin.base_addr() + r.r_addend);
                    break;
                }
                case R_X86_64_64: {
                    const auto opt = SearchSym(name);
                    Elf64_Addr sym_addr;

                    if (libc_mapping::sloader_libc_map.find(name) != libc_mapping::sloader_libc_map.end()) {
                        sym_addr = libc_mapping::sloader_libc_map[name];
                    } else if (opt) {
                        const auto [bin_index, sym_index] = opt.value();
                        sym_addr = binaries_[bin_index].GetSymbolAddr(sym_index);
                    } else {
                        LOG(WARNING) << "Cannot find " << name << LOG_KEY(bin.path());
                        break;
                    }

                    Elf64_Addr* reloc_addr = reinterpret_cast<Elf64_Addr*>(bin.base_addr() + r.r_offset);

                    // TODO: This is wrong, maybe. What is symbol value?
                    // Elf64_Sym sym = binaries_[bin_index].symtabs()[sym_index];
                    // *reloc_addr = bin.base_addr() + sym.st_value + r.r_addend;
                    *reloc_addr = sym_addr + r.r_addend;
                    break;
                }
                case R_X86_64_TPOFF64: {
                    Elf64_Addr* reloc_addr = reinterpret_cast<Elf64_Addr*>(bin.base_addr() + r.r_offset);
                    Elf64_Addr offset = TLSSymOffset(name);
                    *reloc_addr = offset;
                    break;
                }
                case R_X86_64_DTPMOD64: {
                    Elf64_Addr* reloc_addr = reinterpret_cast<Elf64_Addr*>(bin.base_addr() + r.r_offset);
                    // TODO: Need reference.
                    *reloc_addr = 0x1;
                    break;
                }
                case R_X86_64_DTPOFF64: {
                    break;
                }
                case R_X86_64_COPY: {
                    const auto opt = SearchSym(name, true);
                    void* src;
                    Elf64_Xword size;

                    if (libc_mapping::sloader_libc_map.find(name) != libc_mapping::sloader_libc_map.end()) {
                        src = reinterpret_cast<void*>(libc_mapping::sloader_libc_map[name]);
                        size = 8;
                    } else if (opt) {
                        const auto [bin_index, sym_index] = opt.value();
                        Elf64_Sym sym = binaries_[bin_index].symtabs()[sym_index];
                        src = reinterpret_cast<void*>(binaries_[bin_index].base_addr() + sym.st_value);
                        size = sym.st_size;
                    } else {
                        LOG(FATAL) << "Cannot find " << name;
                        std::abort();
                        break;
                    }
                    void* dest = reinterpret_cast<void*>(bin.base_addr() + r.r_offset);
                    LOG(INFO) << LOG_BITS(src) << LOG_BITS(dest) << LOG_BITS(*reinterpret_cast<const unsigned long*>(src))
                              << LOG_BITS(size);
                    std::memcpy(dest, src, size);
                    // std::abort();
                    break;
                }
                default: {
                    LOG(FATAL) << "Unsupported! " << ShowRela(r) << std::endl;
                    std::abort();
                    break;
                }
            }
        }
    }
}

namespace {
std::optional<std::shared_ptr<DynLoader>> dynloader = std::nullopt;
}

void InitializeDynLoader(const std::filesystem::path& main_path, const std::vector<std::string>& envs,
                         const std::vector<std::string>& args) {
    // TODO: Remove this call
    CHECK(dynloader == std::nullopt);
    write_sloader_dummy_to_secure_tls_space();
    dynloader = std::make_shared<DynLoader>(main_path, args, envs);
}

std::shared_ptr<DynLoader> GetDynLoader() {
    CHECK(dynloader);
    return *dynloader;
}

```

`dyn_loader.h`:

```h
#pragma once

#include <elf.h>
#include <glob.h>

#include <filesystem>
#include <fstream>
#include <map>
#include <memory>
#include <optional>
#include <queue>
#include <set>
#include <tuple>

#include "utils.h"

class ELFBinary {
public:
    ELFBinary(const std::filesystem::path path);
    ELFBinary(const ELFBinary&) = default;

    const std::string filename() const { return path_.filename().string(); }
    const Elf64_Addr GetSymbolAddr(const size_t symbol_index);
    const std::vector<std::string> neededs() const { return neededs_; }
    const std::vector<Elf64_Sym>& symtabs() const { return symtabs_; }
    const std::optional<std::filesystem::path> runpath() const { return runpath_; }
    const std::optional<std::filesystem::path> rpath() const { return rpath_; }
    const bool has_tls() const { return has_tls_; }
    const Elf64_Phdr file_tls() const { return file_tls_; }
    const Elf64_Addr base_addr() const { return base_addr_; }
    const Elf64_Addr end_addr() const { return end_addr_; }
    const std::filesystem::path path() const { return path_; }
    const std::vector<Elf64_Rela> relas() const { return relas_; }
    const std::vector<Elf64_Rela> pltrelas() const { return pltrelas_; }
    const Elf64_Xword init() const { return init_; }
    const Elf64_Xword fini() const { return fini_; }
    const Elf64_Xword init_arraysz() const { return init_arraysz_; }
    const Elf64_Xword init_array() const { return init_array_; }
    const Elf64_Xword fini_arraysz() const { return fini_arraysz_; }
    const Elf64_Xword fini_array() const { return fini_array_; }
    const char* strtab() const { return strtab_; }
    const Elf64_Ehdr ehdr() const { return ehdr_; }

    Elf64_Addr Load(Elf64_Addr base_addr, std::shared_ptr<std::ofstream> map_file);
    void ParseDynamic();

private:
    // To generate copy constructor, we cannot make member variables const.
    std::filesystem::path path_;
    char* file_base_addr_;
    Elf64_Addr base_addr_ = 0;
    Elf64_Addr end_addr_ = 0;
    Elf64_Ehdr ehdr_;
    Elf64_Rela* rela_ = nullptr;
    Elf64_Rela* jmprel_ = nullptr;
    std::vector<Elf64_Rela> relas_;
    std::vector<Elf64_Rela> pltrelas_;
    Elf64_Xword relasz_ = 0;
    Elf64_Xword relacount_ = 0;  // What's this?
    Elf64_Xword relaent_ = 0;
    Elf64_Xword pltrelsz_ = 0;
    Elf64_Xword pltrel_ = 0;
    Elf64_Xword pltrelent_ = 0;
    Elf64_Xword init_ = 0;
    Elf64_Xword fini_ = 0;
    Elf64_Xword init_arraysz_ = 0;
    Elf64_Xword init_array_ = 0;
    Elf64_Xword fini_arraysz_ = 0;
    Elf64_Xword fini_array_ = 0;
    Elf64_Sym* symtab_ = nullptr;
    std::vector<Elf64_Sym> symtabs_;
    Elf64_Xword syment_ = 0;
    std::vector<Elf64_Phdr> file_phdrs_;
    Elf64_Phdr file_dynamic_ = {.p_filesz = 0};
    bool has_tls_ = false;
    Elf64_Phdr file_tls_;
    std::vector<std::string> neededs_;
    std::optional<std::filesystem::path> runpath_ = std::nullopt;
    std::optional<std::filesystem::path> rpath_ = std::nullopt;
    char* strtab_ = nullptr;
    Elf64_Xword strsz_ = 0;
};

class DynLoader {
public:
    DynLoader(const std::filesystem::path& main_path, const std::vector<std::string>& args, const std::vector<std::string>& envs);
    // The main function
    void Run();

    void LoadDependingLibs(const std::filesystem::path& root_path);
    void Relocate();
    std::optional<std::pair<size_t, size_t>> SearchSym(const std::string& name, bool skip_main);
    std::vector<ELFBinary> binaries_;

private:
    std::filesystem::path main_path_;
    std::shared_ptr<std::ofstream> map_file_;
    const std::vector<std::string> args_;
    const std::vector<std::string> envs_;
    Elf64_Addr next_base_addr_;
    std::set<std::string> loaded_;
    std::map<std::filesystem::path, bool> relocated_;

    void Execute(std::vector<std::string> args, std::vector<std::string> envs);
    void __attribute__((noinline)) ExecuteCore(uint64_t* stack, size_t stack_num, uint64_t entry);
    Elf64_Addr TLSSymOffset(const std::string& name);
};

void InitializeDynLoader(const std::filesystem::path& main_path, const std::vector<std::string>& envs,
                         const std::vector<std::string>& argv);

std::shared_ptr<DynLoader> GetDynLoader();

std::filesystem::path FindLibrary(std::string library_name, std::optional<std::filesystem::path> runpath,
                                  std::optional<std::filesystem::path> rpath);

```

`example/kernelvm/hello.c`:

```c
void hoge();
int main() {
    hoge();
}

```

`example/kernelvm/hoge.c`:

```c
#include <stdio.h>
void hoge() {
    printf("hoge\n");
}

```

`example/kernelvm/run.sh`:

```sh
#!/bin/bash -eux
cat ./hoge.c
cat ./hello.c
gcc -o libhoge.so -fPIC -shared hoge.c
gcc -o hello -fPIC hello.c libhoge.so
./hello
ldd libhoge.so
ldd hello

```

`exec_loader.h`:

```h
#pragma once

#include "utils.h"

class ExecLoader {
   public:
    ExecLoader(const std::string& filename, char* head, const size_t size)
        : head_(head), size_(size), filename_(filename) {
        ehdr_ = reinterpret_cast<Elf64_Ehdr*>(head);
        for (uint16_t i = 0; i < ehdr()->e_phnum; i++) {
            phdrs_.emplace_back(reinterpret_cast<Elf64_Phdr*>(
                head_ + ehdr()->e_phoff + i * ehdr()->e_phentsize));
        }
        for (auto ph : phdrs()) {
            LOG(INFO) << LOG_BITS(ph->p_type);
            if (ph->p_type == PT_DYNAMIC) {
                CHECK(ph_dynamic_ == NULL);
                ph_dynamic_ = ph;
            }
        }
    }

    void Show() {
        LOG(INFO) << "Ehdr:" << LOG_BITS(ehdr()->e_entry) << LOG_BITS(size_)
                  << LOG_BITS(head_);
        for (auto p : phdrs()) {
            LOG(INFO) << "Phdr:" << LOG_BITS(p->p_vaddr)
                      << LOG_BITS(p->p_offset) << LOG_BITS(p->p_filesz);
        }
    }

    void Load() {
        LOG(INFO) << "Load start";
        for (auto ph : phdrs()) {
            if (ph->p_type != PT_LOAD) {
                continue;
            }
            LOG(INFO) << LOG_BITS(reinterpret_cast<void*>(ph->p_vaddr))
                      << LOG_BITS(ph->p_memsz);
            void* mmap_start =
                reinterpret_cast<void*>((ph->p_vaddr) & (~(0xfff)));
            void* mmap_end = reinterpret_cast<void*>(
                ((ph->p_vaddr + ph->p_memsz) + 0xfff) & (~(0xfff)));
            size_t mmap_size = reinterpret_cast<size_t>(mmap_end) -
                               reinterpret_cast<size_t>(mmap_start);
            char* p = reinterpret_cast<char*>(
                mmap(mmap_start, mmap_size, PROT_READ | PROT_WRITE | PROT_EXEC,
                     MAP_SHARED | MAP_ANONYMOUS, -1, 0));
            LOG(INFO) << "mmap: " << LOG_KEY(filename()) << LOG_BITS(p)
                      << LOG_BITS(ph->p_vaddr);
            CHECK_EQ(mmap_start, p);
            CHECK_LE(reinterpret_cast<Elf64_Addr>(mmap_start), ph->p_vaddr);
            CHECK_LT(ph->p_vaddr + ph->p_memsz,
                     reinterpret_cast<Elf64_Addr>(mmap_end));
            LOG(INFO) << LOG_BITS(p) << LOG_BITS(head() + ph->p_offset)
                      << LOG_BITS(ph->p_filesz);
            memcpy(reinterpret_cast<void*>(ph->p_vaddr), head() + ph->p_offset,
                   ph->p_filesz);
            memories_.emplace_back(std::make_pair(p, ph->p_memsz));
        }
        LOG(INFO) << "Load end";
    }

    void Unload() {
        for (auto p : memories_) {
            munmap(p.first, p.second);
        }
    }

    void Relocate() {}

    // To assign variables of stack, stack_num and entry to %rdi, %rsi and %rdx
    // I use the calling convention. For details, see A.2.1 Calling Conventions
    // in https://refspecs.linuxfoundation.org/elf/x86_64-abi-0.99.pdf. Of
    // course, compiler must not inline this function.
    void __attribute__((noinline))
    ExecuteCore(uint64_t* stack, size_t stack_num, uint64_t entry) {
        for (size_t i = 0; i < stack_num; i++) {
            asm volatile("pushq %0" ::"m"(*(stack + i)));
        }

        asm volatile("jmp *%0" ::"r"(entry));
    }

    void Execute(std::vector<std::string> envs) {
        unsigned long at_random = getauxval(AT_RANDOM);
        unsigned long at_pagesz = getauxval(AT_PAGESZ);
        CHECK_NE(at_random, 0UL);
        LOG(INFO) << LOG_BITS(at_random) << LOG_BITS(at_pagesz);

        // Some commented out auxiliary values because they are not appropriate
        // as loading programs. These values are for sloader itself.
        std::vector<unsigned long> aux_types{
            AT_IGNORE,
            // AT_EXECFD,
            // AT_PHDR,
            AT_PHENT,
            // AT_PHNUM,
            AT_PAGESZ,
            // AT_BASE,
            AT_FLAGS,
            // AT_ENTRY,
            AT_NOTELF, AT_UID, AT_EUID, AT_GID, AT_EGID, AT_CLKTCK, AT_PLATFORM,
            AT_HWCAP, AT_FPUCW, AT_DCACHEBSIZE, AT_ICACHEBSIZE, AT_UCACHEBSIZE,
            AT_IGNOREPPC, AT_SECURE, AT_BASE_PLATFORM, AT_RANDOM, AT_HWCAP2,
            // AT_EXECFN,
            AT_SYSINFO, AT_SYSINFO_EHDR, AT_L1I_CACHESHAPE, AT_L1D_CACHESHAPE,
            AT_L2_CACHESHAPE, AT_L3_CACHESHAPE, AT_L1I_CACHESIZE,
            AT_L1I_CACHEGEOMETRY, AT_L1D_CACHESIZE, AT_L1D_CACHEGEOMETRY,
            AT_L2_CACHESIZE, AT_L2_CACHEGEOMETRY, AT_L3_CACHESIZE,
            AT_L3_CACHEGEOMETRY, AT_MINSIGSTKSZ};

        std::vector<std::pair<unsigned long, unsigned long>> aux_tvs;
        for (size_t i = 0; i < aux_types.size(); i++) {
            unsigned long v = getauxval(aux_types[i]);
            if (v != 0) {
                aux_tvs.emplace_back(std::make_pair(aux_types[i], v));
                LOG(INFO) << LOG_BITS(aux_types[i]) << LOG_BITS(v);
            }
        }

        // See http://articles.manugarg.com/aboutelfauxiliaryvectors.html for
        // the stack layout padding.
        //
        // 4 words padding
        // 0
        // AT_NULL
        // auxs
        // NULL
        // envs
        // argv[argc] (must be null)
        // argv[0] = filename
        // argc
        size_t stack_index = 0;
        size_t stack_num = 4 + 2 + 2 * aux_tvs.size() + 1 + envs.size() + 3;
        size_t stack_size = sizeof(uint64_t) * stack_num;
        unsigned long* stack = reinterpret_cast<uint64_t*>(malloc(stack_size));
        memset(stack, 0, stack_size);

        // 4 words padding
        stack_index += 4;

        // First two elements are 0 and AT_NULL.
        stack_index += 2;

        // auxs
        for (size_t i = 0; i < aux_tvs.size(); i++) {
            *(stack + stack_index) = aux_tvs[i].second;
            stack_index++;
            *(stack + stack_index) = aux_tvs[i].first;
            stack_index++;
        }

        // End of environment variables
        stack_index++;

        // Environment variables
        for (size_t i = 0; i < envs.size(); i++) {
            *(stack + stack_index) =
                reinterpret_cast<uint64_t>(envs[i].c_str());
            stack_index++;
        }

        // argv[argc]
        stack_index++;

        // argv[0]
        *(stack + stack_index) = reinterpret_cast<uint64_t>(filename().c_str());
        stack_index++;

        // argc
        *(stack + stack_index) = 1;
        stack_index++;

        CHECK_EQ(stack_index, stack_num);

        ExecuteCore(stack, stack_num, ehdr()->e_entry);

        free(stack);
        LOG(INFO) << "Execute end";
    }
    std::string filename() { return filename_; }
    Elf64_Ehdr* ehdr() { return ehdr_; }
    char* head() { return head_; }
    std::vector<Elf64_Phdr*> phdrs() { return phdrs_; }

   private:
    char* head_ = nullptr;
    size_t size_;
    std::string filename_ = "";
    Elf64_Ehdr* ehdr_ = nullptr;
    std::vector<Elf64_Phdr*> phdrs_;
    Elf64_Phdr* ph_dynamic_ = nullptr;
    std::vector<Elf64_Dyn*> dyns_;
    std::vector<std::pair<char*, uint32_t>> memories_;
};

std::unique_ptr<ExecLoader> MakeExecLoader(
    const std::filesystem::path& filepath, const std::string& argv0) {
    int fd = open(filepath.c_str(), O_RDONLY);
    CHECK(fd >= 0);

    size_t size = lseek(fd, 0, SEEK_END);
    CHECK_GT(size, 8UL + 16UL);

    size_t mapped_size = (size + 0xfff) & ~0xfff;

    char* p = (char*)mmap(NULL, mapped_size, PROT_READ | PROT_WRITE | PROT_EXEC,
                          MAP_PRIVATE, fd, 0);
    CHECK(p != MAP_FAILED);

    return std::make_unique<ExecLoader>(argv0, p, mapped_size);
}

```

`gen_libc_mapping.sh`:

```sh
#!/bin/bash -u

COMMANDS_TO_RUN=$(cat ./ubuntu_usr_bin_commands | grep -v bus | grep -v linux | grep -v ctl | grep -v mtr | grep -v sh | grep -v ".*bin/[nipxkX].*" | grep -v sys | grep -v last | grep -v join | grep -v less)

for c in ${COMMANDS_TO_RUN}; do
    is_dyn=$(readelf -h ${c} 2>&1 | grep DYN | wc -l)
    if [ ${is_dyn} = "1" ]; then
        fs=$(GLOG_logtostderr=1 ./build/sloader ${c} --help 2>&1 | grep --text "Cannot find" | awk -e '{print $7}')
        for f in ${fs}; do
            echo \{\"${f}\", reinterpret_cast\<Elf64_Addr\>\(\&${f}\)\},
        done
    fi
done

```

`ldsodefs.h`:

```h
/* Run-time dynamic linker data structures for loaded ELF shared objects.
   Copyright (C) 1995-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */

#ifndef _LDSODEFS_H
#define _LDSODEFS_H 1

#include <features.h>
#include <stdbool.h>
#define __need_size_t
#define __need_NULL
#include <dlfcn.h>
#include <elf.h>
#include <fpu_control.h>
// #include <link.h>
#include <stddef.h>
#include <stdint.h>
#include <string.h>
#include <sys/mman.h>
// TODO (akawashiro)
// #include <dl-lookupcfg.h>
// #include <dl-fixup-attribute.h>
// #include <dl-sysdep.h>
// #include <hp-timing.h>
// #include <libc-lock.h>
// #include <list_t.h>
// #include <tls.h>

// TODO (akawashiro)
#define SHARED
#define IS_IN(lib) 0
#define attribute_hidden __attribute__((visibility("hidden")))
#define attribute_relro __attribute__((section(".data.rel.ro")))
#define rtld_hidden_proto(name, attrs...)
#define libc_hidden_proto(name, attrs...)

#define ElfW(type) Elf64_##type
#define ELFW(type) ELF64_##type
#define DT_THISPROCNUM 0
#define DL_FIXUP_VALUE_TYPE struct fdesc

/* For POSIX.1 systems, the pair of st_dev and st_ino constitute
   a unique identifier for a file.  */
struct r_file_id {
    dev_t dev;
    ino64_t ino;
};

struct fdesc {
    ElfW(Addr) ip; /* code entry point */
    ElfW(Addr) gp; /* global pointer */
};

struct link_map_machine {
    Elf32_Addr plt;    /* Address of .plt + 36 */
    Elf32_Addr gotplt; /* Address of .got + 0x0c */
};

typedef uint32_t Elf_Symndx;

/* Forward declaration.  */
struct link_map;

/* Structure to describe a single list of scope elements.  The lookup
   functions get passed an array of pointers to such structures.  */
struct r_scope_elem {
    /* Array of maps for the scope.  */
    struct link_map **r_list;
    /* Number of entries in the scope.  */
    unsigned int r_nlist;
};

struct r_debug {
    /* Version number for this protocol.  It should be greater than 0.  */
    int r_version;

    struct link_map *r_map; /* Head of the chain of loaded objects.  */

    /* This is the address of a function internal to the run-time linker,
       that will always be called when the linker begins to map in a
       library or unmap it, and again when the mapping change is complete.
       The debugger can set a breakpoint at this address if it wants to
       notice shared object mapping changes.  */
    ElfW(Addr) r_brk;
    enum {
        /* This state value describes the mapping change taking place when
           the `r_brk' address is called.  */
        RT_CONSISTENT, /* Mapping change is complete.  */
        RT_ADD,        /* Beginning to add a new object.  */
        RT_DELETE      /* Beginning to remove an object mapping.  */
    } r_state;

    ElfW(Addr) r_ldbase; /* Base address the linker is loaded at.  */
};

/* This is the symbol of that structure provided by the dynamic linker.  */
extern struct r_debug _r_debug;

/* The extended rendezvous structure used by the run-time dynamic linker
   to communicate details of shared object loading to the debugger.  If
   the executable's dynamic section has a DT_DEBUG element, the run-time
   linker sets that element's value to the address where this structure
   can be found.  */

struct r_debug_extended {
    struct r_debug base;

    /* The following field is added by r_version == 2.  */

    /* Link to the next r_debug_extended structure.  Each r_debug_extended
       structure represents a different namespace.  The first
       r_debug_extended structure is for the default namespace.  */
    struct r_debug_extended *r_next;
};

/* Structure to record search path and allocation mechanism.  */
struct r_search_path_struct {
    struct r_search_path_elem **dirs;
    int malloced;
};

struct auditstate {
    uintptr_t cookie;
    unsigned int bindflags;
};

__BEGIN_DECLS

#define VERSYMIDX(sym) (DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGIDX(sym))
#define VALIDX(tag)                                             \
    (DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM + DT_EXTRANUM + \
     DT_VALTAGIDX(tag))
#define ADDRIDX(tag)                                                        \
    (DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM + DT_EXTRANUM + DT_VALNUM + \
     DT_ADDRTAGIDX(tag))

/* Type of GNU hash which the machine uses.  */
#ifndef ELF_MACHINE_GNU_HASH_ADDRIDX
#define ELF_MACHINE_GNU_HASH_ADDRIDX ADDRIDX(DT_GNU_HASH)
#endif

/* Calculate the index of a symbol in GNU hash.  */
#ifndef ELF_MACHINE_HASH_SYMIDX
#define ELF_MACHINE_HASH_SYMIDX(map, hasharr) \
    ((hasharr) - (map)->l_gnu_chain_zero)
#endif

/* Setup MIPS xhash.  Defined only for MIPS.  */
#ifndef ELF_MACHINE_XHASH_SETUP
#define ELF_MACHINE_XHASH_SETUP(hash32, symbias, map) \
    ((void)(hash32), (void)(symbias), (void)(map))
#endif

/* We use this macro to refer to ELF types independent of the native wordsize.
   `ElfW(TYPE)' is used in place of `Elf32_TYPE' or `Elf64_TYPE'.  */
// #define ELFW(type) _ElfW(ELF, __ELF_NATIVE_CLASS, type)

/* Return true if dynamic section in the shared library L should be
   relocated.  */

// TODO (akawashiro)
// static inline bool dl_relocate_ld(const struct link_map *l) {
//     /* Don't relocate dynamic section if it is readonly  */
//     return !(l->l_ld_readonly || DL_RO_DYN_SECTION);
// }

/* All references to the value of l_info[DT_PLTGOT],
  l_info[DT_STRTAB], l_info[DT_SYMTAB], l_info[DT_RELA],
  l_info[DT_REL], l_info[DT_JMPREL], and l_info[VERSYMIDX (DT_VERSYM)]
  have to be accessed via the D_PTR macro.  The macro is needed since for
  most architectures the entry is already relocated - but for some not
  and we need to relocate at access time.  */
// TODO (akawashiro)
/*
#define D_PTR(map, i) \
    ((map)->i->d_un.d_ptr + (dl_relocate_ld(map) ? 0 : (map)->l_addr))
*/

/* Result of the lookup functions and how to retrieve the base address.  */
typedef struct link_map *lookup_t;
#define LOOKUP_VALUE(map) map
#define LOOKUP_VALUE_ADDRESS(map, set) ((set) || (map) ? (map)->l_addr : 0)

/* Calculate the address of symbol REF using the base address from map MAP,
   if non-NULL.  Don't check for NULL map if MAP_SET is TRUE.  */
#define SYMBOL_ADDRESS(map, ref, map_set)                          \
    ((ref) == NULL ? 0                                             \
                   : (__glibc_unlikely((ref)->st_shndx == SHN_ABS) \
                          ? 0                                      \
                          : LOOKUP_VALUE_ADDRESS(map, map_set)) +  \
                         (ref)->st_value)

/* Type of a constructor function, in DT_INIT, DT_INIT_ARRAY,
   DT_PREINIT_ARRAY.  */
typedef void (*dl_init_t)(int, char **, char **);

/* On some architectures a pointer to a function is not just a pointer
   to the actual code of the function but rather an architecture
   specific descriptor. */
#ifndef ELF_FUNCTION_PTR_IS_SPECIAL
#define DL_SYMBOL_ADDRESS(map, ref) (void *)SYMBOL_ADDRESS(map, ref, false)
#define DL_LOOKUP_ADDRESS(addr) ((ElfW(Addr))(addr))
#define DL_CALL_DT_INIT(map, start, argc, argv, env) \
    ((dl_init_t)(start))(argc, argv, env)
#define DL_CALL_DT_FINI(map, start) ((fini_t)(start))()
#endif

/* On some architectures dladdr can't use st_size of all symbols this way.  */
#define DL_ADDR_SYM_MATCH(L, SYM, MATCHSYM, ADDR)                 \
    ((ADDR) >= (L)->l_addr + (SYM)->st_value &&                   \
     ((((SYM)->st_shndx == SHN_UNDEF || (SYM)->st_size == 0) &&   \
       (ADDR) == (L)->l_addr + (SYM)->st_value) ||                \
      (ADDR) < (L)->l_addr + (SYM)->st_value + (SYM)->st_size) && \
     ((MATCHSYM) == NULL || (MATCHSYM)->st_value < (SYM)->st_value))

/* According to the ELF gABI no STV_HIDDEN or STV_INTERNAL symbols are
   expected to be present in dynamic symbol tables as they should have
   been either removed or converted to STB_LOCAL binding by the static
   linker.  However some GNU binutils versions produce such symbols in
   some cases.  To prevent such symbols present in a buggy binary from
   preempting global symbols we filter them out with this predicate.  */
static __always_inline bool dl_symbol_visibility_binds_local_p(const ElfW(Sym) *
                                                               sym) {
    return (ELFW(ST_VISIBILITY)(sym->st_other) == STV_HIDDEN ||
            ELFW(ST_VISIBILITY)(sym->st_other) == STV_INTERNAL);
}

/* Unmap a loaded object, called by _dl_close (). */
#ifndef DL_UNMAP_IS_SPECIAL
#define DL_UNMAP(map) _dl_unmap_segments(map)
#endif

/* Reloc type classes as returned by elf_machine_type_class().
   ELF_RTYPE_CLASS_PLT means this reloc should not be satisfied by
   some PLT symbol, ELF_RTYPE_CLASS_COPY means this reloc should not be
   satisfied by any symbol in the executable.  Some architectures do
   not support copy relocations.  In this case we define the macro to
   zero so that the code for handling them gets automatically optimized
   out.  ELF_RTYPE_CLASS_EXTERN_PROTECTED_DATA means address of protected
   data defined in the shared library may be external, i.e., due to copy
   relocation.  */
#define ELF_RTYPE_CLASS_PLT 1
#ifndef DL_NO_COPY_RELOCS
#define ELF_RTYPE_CLASS_COPY 2
#else
#define ELF_RTYPE_CLASS_COPY 0
#endif
/* If DL_EXTERN_PROTECTED_DATA is defined, address of protected data
   defined in the shared library may be external, i.e., due to copy
   relocation.   */
#ifdef DL_EXTERN_PROTECTED_DATA
#define ELF_RTYPE_CLASS_EXTERN_PROTECTED_DATA 4
#else
#define ELF_RTYPE_CLASS_EXTERN_PROTECTED_DATA 0
#endif

/* ELF uses the PF_x macros to specify the segment permissions, mmap
   uses PROT_xxx.  In most cases the three macros have the values 1, 2,
   and 3 but not in a matching order.  The following macros allows
   converting from the PF_x values to PROT_xxx values.  */
#define PF_TO_PROT                                            \
    ((PROT_READ << (PF_R * 4)) | (PROT_WRITE << (PF_W * 4)) | \
     (PROT_EXEC << (PF_X * 4)) |                              \
     ((PROT_READ | PROT_WRITE) << ((PF_R | PF_W) * 4)) |      \
     ((PROT_READ | PROT_EXEC) << ((PF_R | PF_X) * 4)) |       \
     ((PROT_WRITE | PROT_EXEC) << (PF_W | PF_X) * 4) |        \
     ((PROT_READ | PROT_WRITE | PROT_EXEC) << ((PF_R | PF_W | PF_X) * 4)))

/* The filename itself, or the main program name, if available.  */
#define DSO_FILENAME(name) \
    ((name)[0] ? (name) : (rtld_progname ?: "<main program>"))

#define RTLD_PROGNAME (rtld_progname ?: "<program name unknown>")

/* For the version handling we need an array with only names and their
   hash values.  */
struct r_found_version {
    const char *name;
    ElfW(Word) hash;

    int hidden;
    const char *filename;
};

/* We want to cache information about the searches for shared objects.  */

enum r_dir_status { unknown, nonexisting, existing };

struct r_search_path_elem {
    /* This link is only used in the `all_dirs' member of `r_search_path'.  */
    struct r_search_path_elem *next;

    /* Strings saying where the definition came from.  */
    const char *what;
    const char *where;

    /* Basename for this search path element.  The string must end with
       a slash character.  */
    const char *dirname;
    size_t dirnamelen;

    enum r_dir_status status[0];
};

struct r_strlenpair {
    const char *str;
    size_t len;
};

/* A data structure for a simple single linked list of strings.  */
struct libname_list {
    const char *name;          /* Name requested (before search).  */
    struct libname_list *next; /* Link to next name for this object.  */
    int dont_free;             /* Flag whether this element should be freed
                                  if the object is not entirely unloaded.  */
};

/* Bit masks for the objects which valid callers can come from to
   functions with restricted interface.  */
enum allowmask {
    allow_libc = 1,
    allow_libdl = 2,
    allow_libpthread = 4,
    allow_ldso = 8
};

/* DSO sort algorithm to use (check dl-sort-maps.c).  */
enum dso_sort_algorithm { dso_sort_algorithm_original, dso_sort_algorithm_dfs };

struct audit_ifaces {
    void (*activity)(uintptr_t *, unsigned int);
    char *(*objsearch)(const char *, uintptr_t *, unsigned int);
    unsigned int (*objopen)(struct link_map *, Lmid_t, uintptr_t *);
    void (*preinit)(uintptr_t *);
    union {
        uintptr_t (*symbind32)(Elf32_Sym *, unsigned int, uintptr_t *,
                               uintptr_t *, unsigned int *, const char *);
        uintptr_t (*symbind64)(Elf64_Sym *, unsigned int, uintptr_t *,
                               uintptr_t *, unsigned int *, const char *);
    };
    union {
#ifdef ARCH_PLTENTER_MEMBERS
        ARCH_PLTENTER_MEMBERS;
#endif
    };
    union {
#ifdef ARCH_PLTEXIT_MEMBERS
        ARCH_PLTEXIT_MEMBERS;
#endif
    };
    unsigned int (*objclose)(uintptr_t *);

    struct audit_ifaces *next;
};

/* Test whether given NAME matches any of the names of the given object.  */
extern int _dl_name_match_p(const char *__name,
                            const struct link_map *__map) attribute_hidden;

/* Compute next higher prime number.  */
extern unsigned long int _dl_higher_prime_number(unsigned long int n)
    attribute_hidden;

/* A stripped down strtoul-like implementation.  */
uint64_t _dl_strtoul(const char *, char **) attribute_hidden;

/* Function used as argument for `_dl_receive_error' function.  The
   arguments are the error code, error string, and the objname the
   error occurred in.  */
typedef void (*receiver_fct)(int, const char *, const char *);

// TODO (akawashiro)
struct link_map {
    /* These first few members are part of the protocol with the debugger.
       This is the same format used in SVR4.  */

    ElfW(Addr) l_addr; /* Difference between the address in the ELF
                          file and the addresses in memory.  */
    char *l_name;      /* Absolute file name object was found in.  */
    ElfW(Dyn) * l_ld;  /* Dynamic section of the shared object.  */
    struct link_map *l_next, *l_prev; /* Chain of loaded objects.  */

    /* All following members are internal to the dynamic linker.
       They may change without notice.  */

    /* This is an element which is only ever different from a pointer to
       the very same copy of this type for ld.so when it is used in more
       than one namespace.  */
    struct link_map *l_real;

    /* Number of the namespace this link map belongs to.  */
    Lmid_t l_ns;

    struct libname_list *l_libname;
    /* Indexed pointers to dynamic section.
       [0,DT_NUM) are indexed by the processor-independent tags.
       [DT_NUM,DT_NUM+DT_THISPROCNUM) are indexed by the tag minus DT_LOPROC.
       [DT_NUM+DT_THISPROCNUM,DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM) are
       indexed by DT_VERSIONTAGIDX(tagvalue).
       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM,
        DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM) are indexed by
       DT_EXTRATAGIDX(tagvalue).
       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM,
        DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM) are
       indexed by DT_VALTAGIDX(tagvalue) and
       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM,
        DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM+DT_ADDRNUM)
       are indexed by DT_ADDRTAGIDX(tagvalue), see <elf.h>.  */

    ElfW(Dyn) * l_info[DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM +
                       DT_EXTRANUM + DT_VALNUM + DT_ADDRNUM];
    const ElfW(Phdr) * l_phdr; /* Pointer to program header table in core.  */
    ElfW(Addr) l_entry;        /* Entry point location.  */
    ElfW(Half) l_phnum;        /* Number of program header entries.  */
    ElfW(Half) l_ldnum;        /* Number of dynamic segment entries.  */

    /* Array of DT_NEEDED dependencies and their dependencies, in
       dependency order for symbol lookup (with and without
       duplicates).  There is no entry before the dependencies have
       been loaded.  */
    struct r_scope_elem l_searchlist;

    /* We need a special searchlist to process objects marked with
       DT_SYMBOLIC.  */
    struct r_scope_elem l_symbolic_searchlist;

    /* Dependent object that first caused this object to be loaded.  */
    struct link_map *l_loader;

    /* Array with version names.  */
    struct r_found_version *l_versions;
    unsigned int l_nversions;

    /* Symbol hash table.  */
    Elf_Symndx l_nbuckets;
    Elf32_Word l_gnu_bitmask_idxbits;
    Elf32_Word l_gnu_shift;
    const ElfW(Addr) * l_gnu_bitmask;
    union {
        const Elf32_Word *l_gnu_buckets;
        const Elf_Symndx *l_chain;
    };
    union {
        const Elf32_Word *l_gnu_chain_zero;
        const Elf_Symndx *l_buckets;
    };

    unsigned int l_direct_opencount; /* Reference count for dlopen/dlclose.  */
    enum                             /* Where this object came from.  */
    {
        lt_executable, /* The main executable program.  */
        lt_library,    /* Library needed by main executable.  */
        lt_loaded      /* Extra run-time loaded shared object.  */
    } l_type : 2;
    unsigned int l_relocated : 1;   /* Nonzero if object's relocations done.  */
    unsigned int l_init_called : 1; /* Nonzero if DT_INIT function called.  */
    unsigned int l_global : 1;   /* Nonzero if object in _dl_global_scope.  */
    unsigned int l_reserved : 2; /* Reserved for internal use.  */
    unsigned int l_main_map : 1; /* Nonzero for the map of the main program.  */
    unsigned int l_visited : 1;  /* Used internally for map dependency
                                    graph traversal.  */
    unsigned int l_map_used : 1; /* These two bits are used during traversal */
    unsigned int l_map_done : 1; /* of maps in _dl_close_worker. */
    unsigned int l_phdr_allocated : 1; /* Nonzero if the data structure pointed
                                          to by `l_phdr' is allocated.  */
    unsigned int l_soname_added : 1;   /* Nonzero if the SONAME is for sure in
                                          the l_libname list.  */
    unsigned int l_faked : 1;          /* Nonzero if this is a faked descriptor
                                          without associated file.  */
    unsigned int l_need_tls_init : 1;  /* Nonzero if GL(dl_init_static_tls)
                                          should be called on this link map
                                          when relocation finishes.  */
    unsigned int l_auditing : 1; /* Nonzero if the DSO is used in auditing.  */
    unsigned int
        l_audit_any_plt : 1;    /* Nonzero if at least one audit module
                                   is interested in the PLT interception.*/
    unsigned int l_removed : 1; /* Nozero if the object cannot be used anymore
                                   since it is removed.  */
    unsigned int l_contiguous : 1; /* Nonzero if inter-segment holes are
                                      mprotected or if no holes are present at
                                      all.  */
    unsigned int l_symbolic_in_local_scope : 1; /* Nonzero if l_local_scope
                                                   during LD_TRACE_PRELINKING=1
                                                   contains any DT_SYMBOLIC
                                                   libraries.  */
    unsigned int l_free_initfini : 1;           /* Nonzero if l_initfini can be
                                                   freed, ie. not allocated with
                                                   the dummy malloc in ld.so.  */
    unsigned int
        l_ld_readonly : 1; /* Nonzero if dynamic section is readonly.  */
    unsigned int l_find_object_processed : 1; /* Zero if _dl_find_object_update
                                                 needs to process this
                                                 lt_library map.  */

    /* NODELETE status of the map.  Only valid for maps of type
       lt_loaded.  Lazy binding sets l_nodelete_active directly,
       potentially from signal handlers.  Initial loading of an
       DF_1_NODELETE object set l_nodelete_pending.  Relocation may
       set l_nodelete_pending as well.  l_nodelete_pending maps are
       promoted to l_nodelete_active status in the final stages of
       dlopen, prior to calling ELF constructors.  dlclose only
       refuses to unload l_nodelete_active maps, the pending status is
       ignored.  */
    bool l_nodelete_active;
    bool l_nodelete_pending;

    // TODO (akawashiro)
    // #include <link_map.h>

    /* if this object has GNU property.  */
    enum {
        lc_property_unknown = 0,   /* Unknown property status.  */
        lc_property_none = 1 << 0, /* No property.  */
        lc_property_valid = 1 << 1 /* Has valid property.  */
    } l_property : 2;

    /* GNU_PROPERTY_X86_FEATURE_1_AND of this object.  */
    unsigned int l_x86_feature_1_and;

    /* GNU_PROPERTY_X86_ISA_1_NEEDED of this object.  */
    unsigned int l_x86_isa_1_needed;

    // #include <sysdeps/generic/link_map.h>
    unsigned int l_1_needed;

    /* Collected information about own RPATH directories.  */
    struct r_search_path_struct l_rpath_dirs;

    /* Collected results of relocation while profiling.  */
    struct reloc_result {
        DL_FIXUP_VALUE_TYPE addr;
        struct link_map *bound;
        unsigned int boundndx;
        uint32_t enterexit;
        unsigned int flags;
        /* CONCURRENCY NOTE: This is used to guard the concurrent initialization
           of the relocation result across multiple threads.  See the more
           detailed notes in elf/dl-runtime.c.  */
        unsigned int init;
    } * l_reloc_result;

    /* Pointer to the version information if available.  */
    ElfW(Versym) * l_versyms;

    /* String specifying the path where this object was found.  */
    const char *l_origin;

    /* Start and finish of memory map for this object.  l_map_start
       need not be the same as l_addr.  */
    ElfW(Addr) l_map_start, l_map_end;
    /* End of the executable part of the mapping.  */
    ElfW(Addr) l_text_end;

    /* Default array for 'l_scope'.  */
    struct r_scope_elem *l_scope_mem[4];
    /* Size of array allocated for 'l_scope'.  */
    size_t l_scope_max;
    /* This is an array defining the lookup scope for this link map.
       There are initially at most three different scope lists.  */
    struct r_scope_elem **l_scope;

    /* A similar array, this time only with the local scope.  This is
       used occasionally.  */
    struct r_scope_elem *l_local_scope[2];

    /* This information is kept to check for sure whether a shared
       object is the same as one already loaded.  */
    struct r_file_id l_file_id;

    /* Collected information about own RUNPATH directories.  */
    struct r_search_path_struct l_runpath_dirs;

    /* List of object in order of the init and fini calls.  */
    struct link_map **l_initfini;

    /* List of the dependencies introduced through symbol binding.  */
    struct link_map_reldeps {
        unsigned int act;
        struct link_map *list[];
    } * l_reldeps;
    unsigned int l_reldepsmax;

    /* Nonzero if the DSO is used.  */
    unsigned int l_used;

    /* Various flag words.  */
    ElfW(Word) l_feature_1;
    ElfW(Word) l_flags_1;
    ElfW(Word) l_flags;

    /* Temporarily used in `dl_close'.  */
    int l_idx;

    struct link_map_machine l_mach;

    struct {
        const ElfW(Sym) * sym;
        int type_class;
        struct link_map *value;
        const ElfW(Sym) * ret;
    } l_lookup_cache;

    /* Thread-local storage related info.  */

    /* Start of the initialization image.  */
    void *l_tls_initimage;
    /* Size of the initialization image.  */
    size_t l_tls_initimage_size;
    /* Size of the TLS block.  */
    size_t l_tls_blocksize;
    /* Alignment requirement of the TLS block.  */
    size_t l_tls_align;
    /* Offset of first byte module alignment.  */
    size_t l_tls_firstbyte_offset;
#ifndef NO_TLS_OFFSET
#define NO_TLS_OFFSET 0
#endif
#ifndef FORCED_DYNAMIC_TLS_OFFSET
#if NO_TLS_OFFSET == 0
#define FORCED_DYNAMIC_TLS_OFFSET -1
#elif NO_TLS_OFFSET == -1
#define FORCED_DYNAMIC_TLS_OFFSET -2
#else
#error "FORCED_DYNAMIC_TLS_OFFSET is not defined"
#endif
#endif
    /* For objects present at startup time: offset in the static TLS block.  */
    ptrdiff_t l_tls_offset;
    /* Index of the module in the dtv array.  */
    size_t l_tls_modid;

    /* Number of thread_local objects constructed by this DSO.  This is
       atomically accessed and modified and is not always protected by the load
       lock.  See also: CONCURRENCY NOTES in cxa_thread_atexit_impl.c.  */
    size_t l_tls_dtor_count;

    /* Information used to change permission after the relocations are
       done.  */
    ElfW(Addr) l_relro_addr;
    size_t l_relro_size;

    unsigned long long int l_serial;
};

/* Internal functions of the run-time dynamic linker.
   These can be accessed if you link again the dynamic linker
   as a shared library, as in `-lld' or `/lib/ld.so' explicitly;
   but are not normally of interest to user programs.

   The `-ldl' library functions in <dlfcn.h> provide a simple
   user interface to run-time dynamic linking.  */

#ifndef SHARED
#define EXTERN extern
#define GL(name) _##name
#else
#define EXTERN
#if IS_IN(rtld)
#define GL(name) _rtld_local._##name
#else
#define GL(name) _rtld_global._##name
#endif
struct rtld_global {
#endif
/* Don't change the order of the following elements.  'dl_loaded'
   must remain the first element.  Forever.  */

/* Non-shared code has no support for multiple namespaces.  */
#ifdef SHARED
#define DL_NNS 16
#else
#define DL_NNS 1
#endif
EXTERN struct link_namespaces {
    /* A pointer to the map for the main map.  */
    struct link_map *_ns_loaded;
    /* Number of object in the _dl_loaded list.  */
    unsigned int _ns_nloaded;
    /* Direct pointer to the searchlist of the main object.  */
    struct r_scope_elem *_ns_main_searchlist;
    /* This is zero at program start to signal that the global scope map is
       allocated by rtld.  Later it keeps the size of the map.  It might be
       reset if in _dl_close if the last global object is removed.  */
    unsigned int _ns_global_scope_alloc;

    /* During dlopen, this is the number of objects that still need to
       be added to the global scope map.  It has to be taken into
       account when resizing the map, for future map additions after
       recursive dlopen calls from ELF constructors.  */
    unsigned int _ns_global_scope_pending_adds;

    /* Once libc.so has been loaded into the namespace, this points to
       its link map.  */
    struct link_map *libc_map;

    /* Search table for unique objects.  */
    // TODO (akawashiro)
    // struct unique_sym_table {
    //     __rtld_lock_define_recursive(, lock) struct unique_sym {
    //         uint32_t hashval;
    //         const char *name;
    //         const ElfW(Sym) * sym;
    //         const struct link_map *map;
    //     } * entries;
    //     size_t size;
    //     size_t n_elements;
    //     void (*free)(void *);
    // } _ns_unique_sym_table;
    /* Keep track of changes to each namespace' list.  */
    struct r_debug_extended _ns_debug;
} _dl_ns[DL_NNS];
/* One higher than index of last used namespace.  */
EXTERN size_t _dl_nns;

/* During the program run we must not modify the global data of
   loaded shared object simultanously in two threads.  Therefore we
   protect `_dl_open' and `_dl_close' in dl-close.c.

   This must be a recursive lock since the initializer function of
   the loaded object might as well require a call to this function.
   At this time it is not anymore a problem to modify the tables.  */
// TODO (akawashiro)
// __rtld_lock_define_recursive(EXTERN, _dl_load_lock)
/* This lock is used to keep __dl_iterate_phdr from inspecting the
   list of loaded objects while an object is added to or removed
   from that list.  */
// TODO (akawashiro)
// __rtld_lock_define_recursive(EXTERN, _dl_load_write_lock)
/* This lock protects global and module specific TLS related data.
   E.g. it is held in dlopen and dlclose when GL(dl_tls_generation),
   GL(dl_tls_max_dtv_idx) or GL(dl_tls_dtv_slotinfo_list) are
   accessed and when TLS related relocations are processed for a
   module.  It was introduced to keep pthread_create accessing TLS
   state that is being set up.  */
// TODO (akawashiro)
// __rtld_lock_define_recursive(EXTERN, _dl_load_tls_lock)

/* Incremented whenever something may have been added to dl_loaded.  */
EXTERN unsigned long long _dl_load_adds;

/* The object to be initialized first.  */
EXTERN struct link_map *_dl_initfirst;

/* Map of shared object to be profiled.  */
EXTERN struct link_map *_dl_profile_map;

/* Counters for the number of relocations performed.  */
EXTERN unsigned long int _dl_num_relocations;
EXTERN unsigned long int _dl_num_cache_relocations;

/* List of search directories.  */
EXTERN struct r_search_path_elem *_dl_all_dirs;

/* Structure describing the dynamic linker itself.  */
EXTERN struct link_map _dl_rtld_map;
#ifdef SHARED
/* Used to store the audit information for the link map of the
   dynamic loader.  */
struct auditstate _dl_rtld_auditstate[DL_NNS];
#endif

#if !PTHREAD_IN_LIBC && defined SHARED && \
    defined __rtld_lock_default_lock_recursive
EXTERN void (*_dl_rtld_lock_recursive)(void *);
EXTERN void (*_dl_rtld_unlock_recursive)(void *);
#endif

/* Get architecture specific definitions.  */
#define PROCINFO_DECL
#ifndef PROCINFO_CLASS
#define PROCINFO_CLASS EXTERN
#endif
// TODO (akawashiro)
// #include <dl-procruntime.c>

#if !PTHREAD_IN_LIBC
/* If loading a shared object requires that we make the stack executable
   when it was not, we do it by calling this function.
   It returns an errno code or zero on success.  */
EXTERN int (*_dl_make_stack_executable_hook)(void **);
#endif

/* Prevailing state of the stack, PF_X indicating it's executable.  */
EXTERN ElfW(Word) _dl_stack_flags;

/* Flag signalling whether there are gaps in the module ID allocation.  */
EXTERN bool _dl_tls_dtv_gaps;
/* Highest dtv index currently needed.  */
EXTERN size_t _dl_tls_max_dtv_idx;
/* Information about the dtv slots.  */
EXTERN struct dtv_slotinfo_list {
    size_t len;
    struct dtv_slotinfo_list *next;
    struct dtv_slotinfo {
        size_t gen;
        struct link_map *map;
    } slotinfo[];
} * _dl_tls_dtv_slotinfo_list;
/* Number of modules in the static TLS block.  */
EXTERN size_t _dl_tls_static_nelem;
/* Size actually allocated in the static TLS block.  */
EXTERN size_t _dl_tls_static_used;
/* Remaining amount of static TLS that may be used for optimizing
   dynamic TLS access (e.g. with TLSDESC).  */
EXTERN size_t _dl_tls_static_optional;

/* Number of additional entries in the slotinfo array of each slotinfo
   list element.  A large number makes it almost certain take we never
   have to iterate beyond the first element in the slotinfo list.  */
#define TLS_SLOTINFO_SURPLUS (62)

/* Number of additional slots in the dtv allocated.  */
#define DTV_SURPLUS (14)

/* Initial dtv of the main thread, not allocated with normal malloc.  */
EXTERN void *_dl_initial_dtv;
/* Generation counter for the dtv.  */
EXTERN size_t _dl_tls_generation;

#if !PTHREAD_IN_LIBC
EXTERN void (*_dl_init_static_tls)(struct link_map *);
#endif

/* Scopes to free after next THREAD_GSCOPE_WAIT ().  */
EXTERN struct dl_scope_free_list {
    size_t count;
    void *list[50];
} * _dl_scope_free_list;
#if PTHREAD_IN_LIBC
/* List of active thread stacks, with memory managed by glibc.  */
EXTERN list_t _dl_stack_used;

/* List of thread stacks that were allocated by the application.  */
EXTERN list_t _dl_stack_user;

/* List of queued thread stacks.  */
EXTERN list_t _dl_stack_cache;

/* Total size of all stacks in the cache (sum over stackblock_size).  */
EXTERN size_t _dl_stack_cache_actsize;

/* We need to record what list operations we are going to do so
   that, in case of an asynchronous interruption due to a fork()
   call, we can correct for the work.  */
EXTERN uintptr_t _dl_in_flight_stack;

/* Mutex protecting the stack lists.  */
EXTERN int _dl_stack_cache_lock;
#else
    /* The total number of thread IDs currently in use, or on the list of
       available thread IDs.  */
    EXTERN int _dl_pthread_num_threads;

    /* Array of __pthread structures and its lock.  */
    EXTERN struct __pthread **_dl_pthread_threads;
// TODO (akawashiro)
// __libc_rwlock_define(EXTERN, _dl_pthread_threads_lock)
#endif
#ifdef SHARED
}
;
#define __rtld_global_attribute__
#if IS_IN(rtld)
#ifdef HAVE_SDATA_SECTION
#define __rtld_local_attribute__ \
    __attribute__((visibility("hidden"), section(".sdata")))
#undef __rtld_global_attribute__
#define __rtld_global_attribute__ __attribute__((section(".sdata")))
#else
#define __rtld_local_attribute__ __attribute__((visibility("hidden")))
#endif
extern struct rtld_global _rtld_local __rtld_local_attribute__;
#undef __rtld_local_attribute__
#endif
extern struct rtld_global _rtld_global __rtld_global_attribute__;
#undef __rtld_global_attribute__
#endif

#ifndef SHARED
#define GLRO(name) _##name
#else
#if IS_IN(rtld)
#define GLRO(name) _rtld_local_ro._##name
#else
#define GLRO(name) _rtld_global_ro._##name
#endif
    struct rtld_global_ro {
#endif

/* If nonzero the appropriate debug information is printed.  */
EXTERN int _dl_debug_mask;
#define DL_DEBUG_LIBS (1 << 0)
#define DL_DEBUG_IMPCALLS (1 << 1)
#define DL_DEBUG_BINDINGS (1 << 2)
#define DL_DEBUG_SYMBOLS (1 << 3)
#define DL_DEBUG_VERSIONS (1 << 4)
#define DL_DEBUG_RELOC (1 << 5)
#define DL_DEBUG_FILES (1 << 6)
#define DL_DEBUG_STATISTICS (1 << 7)
#define DL_DEBUG_UNUSED (1 << 8)
#define DL_DEBUG_SCOPES (1 << 9)
/* These two are used only internally.  */
#define DL_DEBUG_HELP (1 << 10)
#define DL_DEBUG_PRELINK (1 << 11)

/* OS version.  */
EXTERN unsigned int _dl_osversion;
/* Platform name.  */
EXTERN const char *_dl_platform;
EXTERN size_t _dl_platformlen;

/* Cached value of `getpagesize ()'.  */
EXTERN size_t _dl_pagesize;

/* Cached value of `sysconf (_SC_MINSIGSTKSZ)'.  */
EXTERN size_t _dl_minsigstacksize;

/* Do we read from ld.so.cache?  */
EXTERN int _dl_inhibit_cache;

/* Copy of the content of `_dl_main_searchlist' at startup time.  */
// TODO (akawashiro)
// EXTERN struct r_scope_elem _dl_initial_searchlist;

/* CLK_TCK as reported by the kernel.  */
EXTERN int _dl_clktck;

/* If nonzero print warnings messages.  */
EXTERN int _dl_verbose;

/* File descriptor to write debug messages to.  */
EXTERN int _dl_debug_fd;

/* Do we do lazy relocations?  */
EXTERN int _dl_lazy;

/* Nonzero if runtime lookups should not update the .got/.plt.  */
EXTERN int _dl_bind_not;

/* Nonzero if references should be treated as weak during runtime
   linking.  */
EXTERN int _dl_dynamic_weak;

/* Default floating-point control word.  */
EXTERN fpu_control_t _dl_fpu_control;

/* Expected cache ID.  */
EXTERN int _dl_correct_cache_id;

/* Mask for hardware capabilities that are available.  */
EXTERN uint64_t _dl_hwcap;

#if !HAVE_TUNABLES
/* Mask for important hardware capabilities we honour. */
EXTERN uint64_t _dl_hwcap_mask;
#endif

#ifdef HAVE_AUX_VECTOR
/* Pointer to the auxv list supplied to the program at startup.  */
EXTERN ElfW(auxv_t) * _dl_auxv;
#endif

/* Get architecture specific definitions.  */
// TODO (akawashiro)
// #include <dl-procinfo.c>

/* Names of shared object for which the RPATH should be ignored.  */
EXTERN const char *_dl_inhibit_rpath;

/* Location of the binary.  */
EXTERN const char *_dl_origin_path;

/* -1 if the dynamic linker should honor library load bias,
   0 if not, -2 use the default (honor biases for normal
   binaries, don't honor for PIEs).  */
EXTERN ElfW(Addr) _dl_use_load_bias;

/* Size of the static TLS block.  */
EXTERN size_t _dl_tls_static_size;

/* Alignment requirement of the static TLS block.  */
EXTERN size_t _dl_tls_static_align;

/* Size of surplus space in the static TLS area for dynamically
   loaded modules with IE-model TLS or for TLSDESC optimization.
   See comments in elf/dl-tls.c where it is initialized.  */
EXTERN size_t _dl_tls_static_surplus;

/* Name of the shared object to be profiled (if any).  */
EXTERN const char *_dl_profile;
/* Filename of the output file.  */
EXTERN const char *_dl_profile_output;
/* Name of the object we want to trace the prelinking.  */
EXTERN const char *_dl_trace_prelink;
/* Map of shared object to be prelink traced.  */
EXTERN struct link_map *_dl_trace_prelink_map;

/* All search directories defined at startup.  This is assigned a
   non-NULL pointer by the ld.so startup code (after initialization
   to NULL), so this can also serve as an indicator whether a copy
   of ld.so is initialized and active.  See the rtld_active function
   below.  */
EXTERN struct r_search_path_elem *_dl_init_all_dirs;

#ifdef NEED_DL_SYSINFO
/* Syscall handling improvements.  This is very specific to x86.  */
EXTERN uintptr_t _dl_sysinfo;
#endif

#ifdef NEED_DL_SYSINFO_DSO
/* The vsyscall page is a virtual DSO pre-mapped by the kernel.
   This points to its ELF header.  */
EXTERN const ElfW(Ehdr) * _dl_sysinfo_dso;

/* At startup time we set up the normal DSO data structure for it,
   and this points to it.  */
EXTERN struct link_map *_dl_sysinfo_map;

#define PROCINFO_DECL
#ifndef PROCINFO_CLASS
#define PROCINFO_CLASS EXTERN
#endif
#include <dl-vdso-setup.c>
#endif

/* Mask for more hardware capabilities that are available on some
   platforms.  */
EXTERN uint64_t _dl_hwcap2;

EXTERN enum dso_sort_algorithm _dl_dso_sort_algo;

#ifdef SHARED
/* We add a function table to _rtld_global which is then used to
   call the function instead of going through the PLT.  The result
   is that we can avoid exporting the functions and we do not jump
   PLT relocations in libc.so.  */
void (*_dl_debug_printf)(const char *, ...)
    __attribute__((__format__(__printf__, 1, 2)));
void (*_dl_mcount)(ElfW(Addr) frompc, ElfW(Addr) selfpc);
lookup_t (*_dl_lookup_symbol_x)(const char *, struct link_map *,
                                const ElfW(Sym) **, struct r_scope_elem *[],
                                const struct r_found_version *, int, int,
                                struct link_map *);
void *(*_dl_open)(const char *file, int mode, const void *caller_dlopen,
                  Lmid_t nsid, int argc, char *argv[], char *env[]);
void (*_dl_close)(void *map);
/* libdl in a secondary namespace (after dlopen) must use
   _dl_catch_error from the main namespace, so it has to be
   exported in some way.  */
int (*_dl_catch_error)(const char **objname, const char **errstring,
                       bool *mallocedp, void (*operate)(void *), void *args);
/* libdl in a secondary namespace must use free from the base
   namespace.  */
void (*_dl_error_free)(void *);
void *(*_dl_tls_get_addr_soft)(struct link_map *);

/* Called from __libc_shared to deallocate malloc'ed memory.  */
void (*_dl_libc_freeres)(void);

/* Implementation of _dl_find_object.  The public entry point is in
   libc, and this is patched by __rtld_static_init to support static
   dlopen.  */
int (*_dl_find_object)(void *, struct dl_find_object *);

#ifdef HAVE_DL_DISCOVER_OSVERSION
int (*_dl_discover_osversion)(void);
#endif

/* Dynamic linker operations used after static dlopen.  */
const struct dlfcn_hook *_dl_dlfcn_hook;

/* List of auditing interfaces.  */
struct audit_ifaces *_dl_audit;
unsigned int _dl_naudit;
}
;
#define __rtld_global_attribute__
#if IS_IN(rtld)
#define __rtld_local_attribute__ __attribute__((visibility("hidden")))
extern struct rtld_global_ro _rtld_local_ro attribute_relro
    __rtld_local_attribute__;
extern struct rtld_global_ro _rtld_global_ro attribute_relro
    __rtld_global_attribute__;
#undef __rtld_local_attribute__
#else
/* We cheat a bit here.  We declare the variable as as const even
   though it is at startup.  */
// TODO (akawashiro): Remove const
extern struct rtld_global_ro _rtld_global_ro attribute_relro
    __rtld_global_attribute__;
#endif
#undef __rtld_global_attribute__
#endif
#undef EXTERN

#ifndef SHARED
/* dl-support.c defines these and initializes them early on.  */
extern const ElfW(Phdr) * _dl_phdr;
extern size_t _dl_phnum;
#endif

#if PTHREAD_IN_LIBC
/* This function changes the permissions of all stacks (not just those
   of the main stack).  */
int _dl_make_stacks_executable(void **stack_endp) attribute_hidden;
#else
        /* This is the initial value of GL(dl_make_stack_executable_hook).
           A threads library can change it.  The ld.so implementation changes
           the permissions of the main stack only.  */
        extern int _dl_make_stack_executable(void **stack_endp);
        // TODO (akawashiro)
        // rtld_hidden_proto(_dl_make_stack_executable)
#endif

/* Variable pointing to the end of the stack (or close to it).  This value
   must be constant over the runtime of the application.  Some programs
   might use the variable which results in copy relocations on some
   platforms.  But this does not matter, ld.so can always use the local
   copy.  */
extern void *__libc_stack_end
#ifndef LIBC_STACK_END_NOT_RELRO
    attribute_relro
#endif
    ;
rtld_hidden_proto(__libc_stack_end)

    /* Parameters passed to the dynamic linker.  */
    extern int _dl_argc attribute_hidden attribute_relro;
extern char **_dl_argv
#ifndef DL_ARGV_NOT_RELRO
    attribute_relro
#endif
    ;
rtld_hidden_proto(_dl_argv)
#if IS_IN(rtld)
    extern unsigned int _dl_skip_args attribute_hidden
#ifndef DL_ARGV_NOT_RELRO
    attribute_relro
#endif
    ;
extern unsigned int _dl_skip_args_internal attribute_hidden
#ifndef DL_ARGV_NOT_RELRO
    attribute_relro
#endif
    ;
#endif
#define rtld_progname _dl_argv[0]

/* Flag set at startup and cleared when the last initializer has run.  */
extern int _dl_starting_up;
// TODO (akawashiro)
// weak_extern(_dl_starting_up) rtld_hidden_proto(_dl_starting_up)

/* Random data provided by the kernel.  */
extern void *_dl_random attribute_hidden attribute_relro;

/* Write message on the debug file descriptor.  The parameters are
   interpreted as for a `printf' call.  All the lines start with a
   tag showing the PID.  */
extern void _dl_debug_printf(const char *fmt, ...)
    __attribute__((__format__(__printf__, 1, 2))) attribute_hidden;

/* Write message on the debug file descriptor.  The parameters are
   interpreted as for a `printf' call.  All the lines buf the first
   start with a tag showing the PID.  */
extern void _dl_debug_printf_c(const char *fmt, ...)
    __attribute__((__format__(__printf__, 1, 2))) attribute_hidden;

/* Write a message on the specified descriptor FD.  The parameters are
   interpreted as for a `printf' call.  */
#if IS_IN(rtld) || !defined(SHARED)
extern void _dl_dprintf(int fd, const char *fmt, ...)
    __attribute__((__format__(__printf__, 2, 3))) attribute_hidden;
#else
        __attribute__((always_inline,
                       __format__(__printf__, 2, 3))) static inline void
        _dl_dprintf(int fd, const char *fmt, ...) {
            /* Use local declaration to avoid includign <stdio.h>.  */
            extern int __dprintf(int fd, const char *format, ...)
                attribute_hidden;
            __dprintf(fd, fmt, __builtin_va_arg_pack());
        }
#endif

/* Write LENGTH bytes at BUFFER to FD, like write.  Returns the number
   of bytes written on success, or a negative error constant on
   failure.  */
ssize_t _dl_write(int fd, const void *buffer, size_t length) attribute_hidden;

/* Write a message on the specified descriptor standard output.  The
   parameters are interpreted as for a `printf' call.  */
void _dl_printf(const char *fmt, ...) attribute_hidden
    __attribute__((__format__(__printf__, 1, 2)));

/* Write a message on the specified descriptor standard error.  The
   parameters are interpreted as for a `printf' call.  */
void _dl_error_printf(const char *fmt, ...) attribute_hidden
    __attribute__((__format__(__printf__, 1, 2)));

/* Write a message on the specified descriptor standard error and exit
   the program.  The parameters are interpreted as for a `printf' call.  */
void _dl_fatal_printf(const char *fmt, ...)
    __attribute__((__format__(__printf__, 1, 2), __noreturn__));
rtld_hidden_proto(_dl_fatal_printf)

    /* An exception raised by the _dl_signal_error function family and
       caught by _dl_catch_error function family.  Exceptions themselves
       are copied as part of the raise operation, but the strings are
       not.  */
    struct dl_exception {
    const char *objname;
    const char *errstring;

    /* This buffer typically stores both objname and errstring
       above.  */
    char *message_buffer;
};

/* Creates a new exception.  This calls malloc; if allocation fails,
   dummy values are inserted.  OBJECT is the name of the problematical
   shared object, or null if its a general problem.  ERRSTRING is a
   string describing the specific problem.  */
void _dl_exception_create(struct dl_exception *, const char *object,
                          const char *errstring) __attribute__((nonnull(1, 3)));
rtld_hidden_proto(_dl_exception_create)

    /* Used internally to implement dlerror message freeing.  See
       include/dlfcn.h and dlfcn/dlerror.c.  */
    void _dl_error_free(void *ptr) attribute_hidden;

/* Like _dl_exception_create, but create errstring from a format
   string FMT.  Currently, only "%s" and "%%" are supported as format
   directives.  */
void _dl_exception_create_format(struct dl_exception *, const char *objname,
                                 const char *fmt, ...)
    __attribute__((nonnull(1, 3), format(printf, 3, 4)));
rtld_hidden_proto(_dl_exception_create_format)

    /* Deallocate the exception, freeing allocated buffers (if
       possible).  */
    void _dl_exception_free(struct dl_exception *) __attribute__((nonnull(1)));
rtld_hidden_proto(_dl_exception_free)

    /* This function is called by all the internal dynamic linker
       functions when they encounter an error.  ERRCODE is either an
       `errno' code or zero; it specifies the return value of
       _dl_catch_error.  OCCASION is included in the error message if the
       process is terminated immediately.  */
    void _dl_signal_exception(int errcode, struct dl_exception *,
                              const char *occasion)
        __attribute__((__noreturn__));
libc_hidden_proto(_dl_signal_exception)

    /* Like _dl_signal_exception, but creates the exception first.  */
    extern void _dl_signal_error(int errcode, const char *object,
                                 const char *occasion, const char *errstring)
        __attribute__((__noreturn__));
libc_hidden_proto(_dl_signal_error)

/* Like _dl_signal_exception, but may return when called in the
   context of _dl_receive_error.  This is only used during ld.so
   bootstrap.  In static and profiled builds, this is equivalent to
   _dl_signal_exception.  */
#if IS_IN(rtld)
    extern void _dl_signal_cexception(int errcode, struct dl_exception *,
                                      const char *occasion) attribute_hidden;
#else
            __attribute__((always_inline)) static inline void _dl_signal_cexception(
                int errcode, struct dl_exception *exception,
                const char *occasion) {
            _dl_signal_exception(errcode, exception, occasion);
        }
#endif

/* See _dl_signal_cexception above.  */
#if IS_IN(rtld)
extern void _dl_signal_cerror(int errcode, const char *object,
                              const char *occasion,
                              const char *errstring) attribute_hidden;
#else
        __attribute__((always_inline)) static inline void _dl_signal_cerror(
            int errcode, const char *object, const char *occasion,
            const char *errstring) {
            _dl_signal_error(errcode, object, occasion, errstring);
        }
#endif

/* Call OPERATE, receiving errors from `dl_signal_cerror'.  Unlike
   `_dl_catch_error' the operation is resumed after the OPERATE
   function returns.
   ARGS is passed as argument to OPERATE.  */
extern void _dl_receive_error(receiver_fct fct, void (*operate)(void *),
                              void *args) attribute_hidden;

/* Call OPERATE, catching errors from `_dl_signal_error' and related
   functions.  If there is no error, *ERRSTRING is set to null.  If
   there is an error, *ERRSTRING is set to a string constructed from
   the strings passed to _dl_signal_error, and the error code passed
   is the return value and *OBJNAME is set to the object name which
   experienced the problems.  ERRSTRING if nonzero points to a
   malloc'ed string which the caller has to free after use.  ARGS is
   passed as argument to OPERATE.  MALLOCEDP is set to true only if
   the returned string is allocated using the libc's malloc.  */
extern int _dl_catch_error(const char **objname, const char **errstring,
                           bool *mallocedp, void (*operate)(void *),
                           void *args);
libc_hidden_proto(_dl_catch_error)

    /* Used for initializing GLRO (_dl_catch_error).  */
    extern __typeof__(_dl_catch_error) _rtld_catch_error attribute_hidden;

/* Call OPERATE (ARGS).  If no error occurs, set *EXCEPTION to zero.
   Otherwise, store a copy of the raised exception in *EXCEPTION,
   which has to be freed by _dl_exception_free.  As a special case, if
   EXCEPTION is null, call OPERATE (ARGS) with exception handling
   disabled (so that exceptions are fatal).  */
int _dl_catch_exception(struct dl_exception *exception, void (*operate)(void *),
                        void *args);
libc_hidden_proto(_dl_catch_exception)

    /* Open the shared object NAME and map in its segments.
       LOADER's DT_RPATH is used in searching for NAME.
       If the object is already opened, returns its existing map.  */
    extern struct link_map *_dl_map_object(struct link_map *loader,
                                           const char *name, int type,
                                           int trace_mode, int mode,
                                           Lmid_t nsid) attribute_hidden;

/* Call _dl_map_object on the dependencies of MAP, and set up
   MAP->l_searchlist.  PRELOADS points to a vector of NPRELOADS previously
   loaded objects that will be inserted into MAP->l_searchlist after MAP
   but before its dependencies.  */
extern void _dl_map_object_deps(struct link_map *map,
                                struct link_map **preloads,
                                unsigned int npreloads, int trace_mode,
                                int open_mode) attribute_hidden;

/* Cache the locations of MAP's hash table.  */
extern void _dl_setup_hash(struct link_map *map) attribute_hidden;

/* Collect the directories in the search path for LOADER's dependencies.
   The data structure is defined in <dlfcn.h>.  If COUNTING is true,
   SI->dls_cnt and SI->dls_size are set; if false, those must be as set
   by a previous call with COUNTING set, and SI must point to SI->dls_size
   bytes to be used in filling in the result.  */
extern void _dl_rtld_di_serinfo(struct link_map *loader, Dl_serinfo *si,
                                bool counting);

/* Process PT_GNU_PROPERTY program header PH in module L after
   PT_LOAD segments are mapped from file FD.  */
void _dl_process_pt_gnu_property(struct link_map *l, int fd,
                                 const ElfW(Phdr) * ph);

/* Search loaded objects' symbol tables for a definition of the symbol
   referred to by UNDEF.  *SYM is the symbol table entry containing the
   reference; it is replaced with the defining symbol, and the base load
   address of the defining object is returned.  SYMBOL_SCOPE is a
   null-terminated list of object scopes to search; each object's
   l_searchlist (i.e. the segment of the dependency tree starting at that
   object) is searched in turn.  REFERENCE_NAME should name the object
   containing the reference; it is used in error messages.
   TYPE_CLASS describes the type of symbol we are looking for.  */
enum {
    /* If necessary add dependency between user and provider object.  */
    DL_LOOKUP_ADD_DEPENDENCY = 1,
    /* Return most recent version instead of default version for
       unversioned lookup.  */
    DL_LOOKUP_RETURN_NEWEST = 2,
    /* Set if dl_lookup* called with GSCOPE lock held.  */
    DL_LOOKUP_GSCOPE_LOCK = 4,
    /* Set if dl_lookup is called for non-lazy relocation processing
       from _dl_relocate_object in elf/dl-reloc.c.  */
    DL_LOOKUP_FOR_RELOCATE = 8,
};

/* Lookup versioned symbol.  */
extern lookup_t _dl_lookup_symbol_x(
    const char *undef, struct link_map *undef_map, const ElfW(Sym) * *sym,
    struct r_scope_elem *symbol_scope[], const struct r_found_version *version,
    int type_class, int flags, struct link_map *skip_map) attribute_hidden;

/* Restricted version of _dl_lookup_symbol_x.  Searches MAP (and only
   MAP) for the symbol UNDEF_NAME, with GNU hash NEW_HASH (computed
   with dl_new_hash), symbol version VERSION, and symbol version hash
   VERSION_HASH (computed with _dl_elf_hash).  Returns a pointer to
   the symbol table entry in MAP on success, or NULL on failure.  MAP
   must have symbol versioning information, or otherwise the result is
   undefined.  */
const ElfW(Sym) * _dl_lookup_direct(struct link_map *map,
                                    const char *undef_name, uint32_t new_hash,
                                    const char *version,
                                    uint32_t version_hash) attribute_hidden;

/* Add the new link_map NEW to the end of the namespace list.  */
// TODO (akawashiro)
// extern void _dl_add_to_namespace_list(struct link_map *new,
// Lmid_t nsid) attribute_hidden;

/* Allocate a `struct link_map' for a new object being loaded.  */
extern struct link_map *_dl_new_object(char *realname, const char *libname,
                                       int type, struct link_map *loader,
                                       int mode, Lmid_t nsid) attribute_hidden;

/* Relocate the given object (if it hasn't already been).
   SCOPE is passed to _dl_lookup_symbol in symbol lookups.
   If RTLD_LAZY is set in RELOC-MODE, don't relocate its PLT.  */
extern void _dl_relocate_object(struct link_map *map,
                                struct r_scope_elem *scope[], int reloc_mode,
                                int consider_profiling) attribute_hidden;

/* Protect PT_GNU_RELRO area.  */
extern void _dl_protect_relro(struct link_map *map) attribute_hidden;

/* Call _dl_signal_error with a message about an unhandled reloc type.
   TYPE is the result of ELFW(R_TYPE) (r_info), i.e. an R_<CPU>_* value.
   PLT is nonzero if this was a PLT reloc; it just affects the message.  */
extern void _dl_reloc_bad_type(struct link_map *map, unsigned int type,
                               int plt) attribute_hidden
    __attribute__((__noreturn__));

/* Resolve conflicts if prelinking.  */
extern void _dl_resolve_conflicts(struct link_map *l, ElfW(Rela) * conflict,
                                  ElfW(Rela) * conflictend) attribute_hidden;

/* Check the version dependencies of all objects available through
   MAP.  If VERBOSE print some more diagnostics.  */
extern int _dl_check_all_versions(struct link_map *map, int verbose,
                                  int trace_mode) attribute_hidden;

/* Check the version dependencies for MAP.  If VERBOSE print some more
   diagnostics.  */
extern int _dl_check_map_versions(struct link_map *map, int verbose,
                                  int trace_mode) attribute_hidden;

/* Initialize the object in SCOPE by calling the constructors with
   ARGC, ARGV, and ENV as the parameters.  */
extern void _dl_init(struct link_map *main_map, int argc, char **argv,
                     char **env) attribute_hidden;

/* Call the finalizer functions of all shared objects whose
   initializer functions have completed.  */
extern void _dl_fini(void) attribute_hidden;

/* Sort array MAPS according to dependencies of the contained objects.  */
extern void _dl_sort_maps(struct link_map **maps, unsigned int nmaps,
                          unsigned int skip, bool for_fini) attribute_hidden;

/* The dynamic linker calls this function before and having changing
   any shared object mappings.  The `r_state' member of `struct r_debug'
   says what change is taking place.  This function's address is
   the value of the `r_brk' member.  */
extern void _dl_debug_state(void);
rtld_hidden_proto(_dl_debug_state)

    /* Initialize `struct r_debug_extended' for the namespace NS.  LDBASE
       is the run-time load address of the dynamic linker, to be put in the
       `r_ldbase' member.  Return the address of the structure.  */
    extern struct r_debug *_dl_debug_initialize(ElfW(Addr) ldbase,
                                                Lmid_t ns) attribute_hidden;

/* Update the `r_map' member and return the address of `struct r_debug'
   of the namespace NS.  */
extern struct r_debug *_dl_debug_update(Lmid_t ns) attribute_hidden;

/* Initialize the basic data structure for the search paths.  SOURCE
   is either "LD_LIBRARY_PATH" or "--library-path".
   GLIBC_HWCAPS_PREPEND adds additional glibc-hwcaps subdirectories to
   search.  GLIBC_HWCAPS_MASK is used to filter the built-in
   subdirectories if not NULL.  */
extern void _dl_init_paths(const char *library_path, const char *source,
                           const char *glibc_hwcaps_prepend,
                           const char *glibc_hwcaps_mask) attribute_hidden;

/* Gather the information needed to install the profiling tables and start
   the timers.  */
extern void _dl_start_profile(void) attribute_hidden;

/* The actual functions used to keep book on the calls.  */
extern void _dl_mcount(ElfW(Addr) frompc, ElfW(Addr) selfpc);
rtld_hidden_proto(_dl_mcount)

    /* This function is simply a wrapper around the _dl_mcount function
       which does not require a FROMPC parameter since this is the
       calling function.  */
    extern void _dl_mcount_wrapper(void *selfpc);

/* Show the members of the auxiliary array passed up from the kernel.  */
extern void _dl_show_auxv(void) attribute_hidden;

/* Return all environment variables starting with `LD_', one after the
   other.  */
extern char *_dl_next_ld_env_entry(char ***position) attribute_hidden;

/* Return an array with the names of the important hardware
   capabilities.  PREPEND is a colon-separated list of glibc-hwcaps
   directories to search first.  MASK is a colon-separated list used
   to filter the built-in glibc-hwcaps subdirectories.  The length of
   the array is written to *SZ, and the maximum of all strings length
   is written to *MAX_CAPSTRLEN.  */
const struct r_strlenpair *_dl_important_hwcaps(
    const char *prepend, const char *mask, size_t *sz,
    size_t *max_capstrlen) attribute_hidden;

/* Look up NAME in ld.so.cache and return the file name stored there,
   or null if none is found.  Caller must free returned string.  */
extern char *_dl_load_cache_lookup(const char *name) attribute_hidden;

/* If the system does not support MAP_COPY we cannot leave the file open
   all the time since this would create problems when the file is replaced.
   Therefore we provide this function to close the file and open it again
   once needed.  */
extern void _dl_unload_cache(void) attribute_hidden;

/* System-dependent function to read a file's whole contents in the
   most convenient manner available.  *SIZEP gets the size of the
   file.  On error MAP_FAILED is returned.  */
extern void *_dl_sysdep_read_whole_file(const char *file, size_t *sizep,
                                        int prot) attribute_hidden;

/* System-specific function to do initial startup for the dynamic linker.
   After this, file access calls and getenv must work.  This is responsible
   for setting __libc_enable_secure if we need to be secure (e.g. setuid),
   and for setting _dl_argc and _dl_argv, and then calling _dl_main.  */
extern ElfW(Addr)
    _dl_sysdep_start(void **start_argptr,
                     void (*dl_main)(const ElfW(Phdr) * phdr, ElfW(Word) phnum,
                                     ElfW(Addr) * user_entry,
                                     ElfW(auxv_t) * auxv)) attribute_hidden;

extern void _dl_sysdep_start_cleanup(void) attribute_hidden;

/* Determine next available module ID and set the L l_tls_modid.  */
extern void _dl_assign_tls_modid(struct link_map *l) attribute_hidden;

/* Count the modules with TLS segments.  */
extern size_t _dl_count_modids(void) attribute_hidden;

/* Calculate offset of the TLS blocks in the static TLS block.  */
extern void _dl_determine_tlsoffset(void) attribute_hidden;

/* Calculate the size of the static TLS surplus, when the given
   number of audit modules are loaded.  */
void _dl_tls_static_surplus_init(size_t naudit) attribute_hidden;

/* This function is called very early from dl_main to set up TLS and
   other thread-related data structures.  */
void __tls_pre_init_tp(void) attribute_hidden;

/* This function is called after processor-specific initialization of
   the TCB and thread pointer via TLS_INIT_TP, to complete very early
   initialization of the thread library.  */
void __tls_init_tp(void) attribute_hidden;

#ifndef SHARED
/* Set up the TCB for statically linked applications.  This is called
   early during startup because we always use TLS (for errno and the
   stack protector, among other things).  */
void __libc_setup_tls(void);

#if ENABLE_STATIC_PIE
/* Relocate static executable with PIE.  */
extern void _dl_relocate_static_pie(void) attribute_hidden;

/* Get a pointer to _dl_main_map.  */
extern struct link_map *_dl_get_dl_main_map(void)
    __attribute__((visibility("hidden")));
#else
#define _dl_relocate_static_pie()
#endif
#endif

/* Perform early memory allocation, avoding a TCB dependency.
   Terminate the process if allocation fails.  May attempt to use
   brk.  */
void *_dl_early_allocate(size_t size) attribute_hidden;

/* Initialize the DSO sort algorithm to use.  */
#if !HAVE_TUNABLES
// TODO (akawashiro)
// static inline void __always_inline _dl_sort_maps_init(void) {
/* This is optimized out if tunables are not enabled.  */
}
#else
        extern void _dl_sort_maps_init(void) attribute_hidden;
#endif

/* Initialization of libpthread for statically linked applications.
   If libpthread is not linked in, this is an empty function.  */
// TODO (akawashiro)
// void __pthread_initialize_minimal(void) weak_function;

/* Allocate memory for static TLS block (unless MEM is nonzero) and dtv.  */
extern void *_dl_allocate_tls(void *mem);
rtld_hidden_proto(_dl_allocate_tls)

    /* Get size and alignment requirements of the static TLS block.  */
    extern void _dl_get_tls_static_info(size_t *sizep, size_t *alignp);

extern void _dl_allocate_static_tls(struct link_map *map) attribute_hidden;

/* These are internal entry points to the two halves of _dl_allocate_tls,
   only used within rtld.c itself at startup time.  */
extern void *_dl_allocate_tls_storage(void) attribute_hidden;
extern void *_dl_allocate_tls_init(void *, bool);
rtld_hidden_proto(_dl_allocate_tls_init)

    /* Deallocate memory allocated with _dl_allocate_tls.  */
    extern void _dl_deallocate_tls(void *tcb, bool dealloc_tcb);
rtld_hidden_proto(_dl_deallocate_tls)

    extern void _dl_nothread_init_static_tls(struct link_map *)
        attribute_hidden;

/* Find origin of the executable.  */
extern const char *_dl_get_origin(void) attribute_hidden;

/* Count DSTs.  */
extern size_t _dl_dst_count(const char *name) attribute_hidden;

/* Substitute DST values.  */
extern char *_dl_dst_substitute(struct link_map *l, const char *name,
                                char *result) attribute_hidden;

/* Open the shared object NAME, relocate it, and run its initializer if it
   hasn't already been run.  MODE is as for `dlopen' (see <dlfcn.h>).  If
   the object is already opened, returns its existing map.  */
extern void *_dl_open(const char *name, int mode, const void *caller,
                      Lmid_t nsid, int argc, char *argv[],
                      char *env[]) attribute_hidden;

/* Free or queue for freeing scope OLD.  If other threads might be
   in the middle of _dl_fixup, _dl_profile_fixup or dl*sym using the
   old scope, OLD can't be freed until no thread is using it.  */
extern int _dl_scope_free(void *) attribute_hidden;

/* Add module to slot information data.  If DO_ADD is false, only the
   required memory is allocated.  Must be called with GL
   (dl_load_tls_lock) acquired.  If the function has already been called
   for the link map L with !do_add, then this function will not raise
   an exception, otherwise it is possible that it encounters a memory
   allocation failure.  */
extern void _dl_add_to_slotinfo(struct link_map *l,
                                bool do_add) attribute_hidden;

/* Update slot information data for at least the generation of the
   module with the given index.  */
extern struct link_map *_dl_update_slotinfo(unsigned long int req_modid)
    attribute_hidden;

/* Look up the module's TLS block as for __tls_get_addr,
   but never touch anything.  Return null if it's not allocated yet.  */
extern void *_dl_tls_get_addr_soft(struct link_map *l) attribute_hidden;

extern int _dl_addr_inside_object(struct link_map *l,
                                  const ElfW(Addr) addr) attribute_hidden;

/* Show show of an object.  */
// TODO (akawashiro)
// extern void _dl_show_scope(struct link_map *new, int from) attribute_hidden;

extern struct link_map *_dl_find_dso_for_object(const ElfW(Addr) addr);
rtld_hidden_proto(_dl_find_dso_for_object)

    /* Initialization which is normally done by the dynamic linker.  */
    extern void _dl_non_dynamic_init(void) attribute_hidden;

/* Used by static binaries to check the auxiliary vector.  */
extern void _dl_aux_init(ElfW(auxv_t) * av) attribute_hidden;

/* Initialize the static TLS space for the link map in all existing
   threads. */
#if PTHREAD_IN_LIBC
void _dl_init_static_tls(struct link_map *map) attribute_hidden;
#endif
static inline void dl_init_static_tls(struct link_map *map) {
#if PTHREAD_IN_LIBC
    /* The stack list is available to ld.so, so the initialization can
       be handled within ld.so directly.  */
    _dl_init_static_tls(map);
#else
            GL(dl_init_static_tls)(map);
#endif
}

#ifndef SHARED
/* Called before relocating ld.so during static dlopen.  This can be
   used to partly initialize the dormant ld.so copy in the static
   dlopen namespace.  */
void __rtld_static_init(struct link_map *map) attribute_hidden;
#endif

/* Return true if the ld.so copy in this namespace is actually active
   and working.  If false, the dl_open/dlfcn hooks have to be used to
   call into the outer dynamic linker (which happens after static
   dlopen).  */
#ifdef SHARED
static inline bool rtld_active(void) {
    /* The default-initialized variable does not have a non-zero
       dl_init_all_dirs member, so this allows us to recognize an
       initialized and active ld.so copy.  */
    return GLRO(dl_init_all_dirs) != NULL;
}

static inline struct auditstate *link_map_audit_state(struct link_map *l,
                                                      size_t index) {
    if (l == &GL(dl_rtld_map)) /* The auditstate array is stored separately.  */
        return &GL(dl_rtld_auditstate)[index];
    else {
        /* The auditstate array follows the link map in memory.  */
        struct auditstate *base = (struct auditstate *)(l + 1);
        return &base[index];
    }
}

/* Call the la_objsearch from the audit modules from the link map L.  If
   ORIGNAME is non NULL, it is updated with the revious name prior calling
   la_objsearch.  */
const char *_dl_audit_objsearch(const char *name, struct link_map *l,
                                unsigned int code) attribute_hidden;

/* Call the la_activity from the audit modules from the link map L and issues
   the ACTION argument.  */
void _dl_audit_activity_map(struct link_map *l, int action) attribute_hidden;

/* Call the la_activity from the audit modules from the link map from the
   namespace NSID and issues the ACTION argument.  */
void _dl_audit_activity_nsid(Lmid_t nsid, int action) attribute_hidden;

/* Call the la_objopen from the audit modules for the link_map L on the
   namespace identification NSID.  */
void _dl_audit_objopen(struct link_map *l, Lmid_t nsid) attribute_hidden;

/* Call the la_objclose from the audit modules for the link_map L.  */
void _dl_audit_objclose(struct link_map *l) attribute_hidden;

/* Call the la_preinit from the audit modules for the link_map L.  */
void _dl_audit_preinit(struct link_map *l);

/* Call the la_symbind{32,64} from the audit modules for the link_map L.  If
   RELOC_RESULT is NULL it assumes the symbol to be bind-now and will set
   the flags with LA_SYMB_NOPLTENTER | LA_SYMB_NOPLTEXIT prior calling
   la_symbind{32,64}.  */
// TODO (akawashiro)
// void _dl_audit_symbind(struct link_map *l, struct reloc_result *reloc_result,
//                        const ElfW(Sym) * defsym, DL_FIXUP_VALUE_TYPE *value,
//                        lookup_t result) attribute_hidden;
/* Same as _dl_audit_symbind, but also sets LA_SYMB_DLSYM flag.  */
void _dl_audit_symbind_alt(struct link_map *l, const ElfW(Sym) * ref,
                           void **value, lookup_t result);
// TODO (akawashiro)
// rtld_hidden_proto(_dl_audit_symbind_alt) void _dl_audit_pltenter(
//     struct link_map *l, struct reloc_result *reloc_result,
//     DL_FIXUP_VALUE_TYPE *value, void *regs,
//     long int *framesize) attribute_hidden;
// void DL_ARCH_FIXUP_ATTRIBUTE _dl_audit_pltexit(struct link_map *l,
//                                                ElfW(Word) reloc_arg,
//                                                const void *inregs,
//                                                void *outregs)
//                                                attribute_hidden;
#endif /* SHARED */

#if PTHREAD_IN_LIBC && defined SHARED
/* Recursive locking implementation for use within the dynamic loader.
   Used to define the __rtld_lock_lock_recursive and
   __rtld_lock_unlock_recursive via <libc-lock.h>.  Initialized to a
   no-op dummy implementation early.  Similar
   to GL (dl_rtld_lock_recursive) and GL (dl_rtld_unlock_recursive)
   in !PTHREAD_IN_LIBC builds.  */
extern int (*___rtld_mutex_lock)(pthread_mutex_t *) attribute_hidden;
extern int (*___rtld_mutex_unlock)(pthread_mutex_t *lock) attribute_hidden;

/* Called after libc has been loaded, but before RELRO is activated.
   Used to initialize the function pointers to the actual
   implementations.  */
void __rtld_mutex_init(void) attribute_hidden;
#else  /* !PTHREAD_IN_LIBC */
        static inline void __rtld_mutex_init(void) {
            /* The initialization happens later (!PTHREAD_IN_LIBC) or is not
               needed at all (!SHARED).  */
        }
#endif /* !PTHREAD_IN_LIBC */

/* Implementation of GL (dl_libc_freeres).  */
void __rtld_libc_freeres(void) attribute_hidden;

void __thread_gscope_wait(void) attribute_hidden;
#define THREAD_GSCOPE_WAIT() __thread_gscope_wait()

// TODO (akawashiro)
// __END_DECLS

#endif /* ldsodefs.h */

```

`libc_mapping.cc`:

```cc
#include "libc_mapping.h"
#include "raw_write.h"

#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#include <aliases.h>
#include <argp.h>
#include <argz.h>
#include <arpa/inet.h>
#include <arpa/nameser.h>
#include <asm/prctl.h>
#include <ctype.h>
#include <dirent.h>
#include <dlfcn.h>
#include <elf.h>
#include <err.h>
#include <errno.h>
#include <error.h>
#include <execinfo.h>
#include <fcntl.h>
#include <fnmatch.h>
#include <fts.h>
#include <ftw.h>
#include <getopt.h>
#include <glob.h>
#include <gnu/libc-version.h>
#include <grp.h>
#include <gshadow.h>
#include <iconv.h>
#include <ifaddrs.h>
#include <langinfo.h>
#include <libgen.h>
#include <libintl.h>
#include <link.h>
#include <malloc.h>
#include <math.h>
#include <mcheck.h>
#include <mntent.h>
#include <mqueue.h>
#include <net/if.h>
#include <netdb.h>
#include <netinet/ether.h>
#include <netinet/in.h>
#include <obstack.h>
#include <poll.h>
#include <printf.h>
#include <pthread.h>
#include <pty.h>
#include <pwd.h>
#include <regex.h>
#include <resolv.h>
#include <sched.h>
#include <search.h>
#include <semaphore.h>
#include <setjmp.h>
#include <shadow.h>
#include <signal.h>
#include <spawn.h>
#include <stdio.h>
#include <stdio_ext.h>
#include <stdlib.h>
#include <string.h>
#include <sys/auxv.h>
#include <sys/capability.h>
#include <sys/epoll.h>
#include <sys/eventfd.h>
#include <sys/file.h>
#include <sys/fsuid.h>
#include <sys/inotify.h>
#include <sys/io.h>
#include <sys/ioctl.h>
#include <sys/ipc.h>
#include <sys/klog.h>
#include <sys/mman.h>
#include <sys/mount.h>
#include <sys/msg.h>
#include <sys/personality.h>
#include <sys/prctl.h>
#include <sys/ptrace.h>
#include <sys/random.h>
#include <sys/resource.h>
#include <sys/sem.h>
#include <sys/sendfile.h>
#include <sys/shm.h>
#include <sys/signalfd.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/statvfs.h>
#include <sys/syscall.h>
#include <sys/sysinfo.h>
#include <sys/sysmacros.h>
#include <sys/time.h>
#include <sys/timerfd.h>
#include <sys/times.h>
#include <sys/timex.h>
#include <sys/types.h>
#include <sys/uio.h>
#include <sys/utsname.h>
#include <sys/vfs.h>
#include <sys/wait.h>
#include <sys/xattr.h>
#include <syslog.h>
#include <termios.h>
#include <ttyent.h>
#include <ucontext.h>
#include <unistd.h>
#include <utime.h>
#include <utmp.h>
#include <utmpx.h>
#include <wchar.h>
#include <wctype.h>
#include <cinttypes>
#include <cstring>
#include <ctime>

#include "sloader_dl.h"

extern thread_local unsigned long sloader_dummy_to_secure_tls_space[];
extern unsigned long sloader_tls_offset;

// Copy from libc
extern __thread struct __res_state* __resp;

namespace libc_mapping {

const char* (*strchr_c)(const char*, int) = strchr;
const char* (*strrchr_c)(const char*, int) = strrchr;
const void* (*rawmemchr_c)(const void*, int) = rawmemchr;
const wchar_t* (*wmemchr_c)(const wchar_t*, wchar_t, size_t) = wmemchr;
const void* (*memchr_c)(const void*, int, size_t) = memchr;
const char* (*strstr_c)(const char*, const char*) = strstr;
const char* (*strpbrk_c)(const char*, const char*) = strpbrk;
double (*frexp_c)(double, int*) = frexp;
double (*ldexp_c)(double, int) = ldexp;
const char* (*strchrnul_c)(const char*, int) = strchrnul;
const char* (*strcasestr_c)(const char* haystack, const char* needle) = strcasestr;
double (*modf_c)(double x, double* iptr) = modf;
const char* (*rindex_c)(const char* s, int c) = rindex;
const wchar_t* (*wcsstr_c)(const wchar_t* dest, const wchar_t* src) = wcsstr;
const wchar_t* (*wcspbrk_c)(const wchar_t* wcs1, const wchar_t* wcs2) = wcspbrk;

// TODO: I don't know why these functions need dummy definition not casts of function pointers.
// const wchar_t* (*wcschr_c)(const wchar_t* string, wchar_t character) = wcschr;
const wchar_t* wcschr_c(const wchar_t* string, wchar_t character) {
    // printf("wcschr_c: string=%p wc=%d\n", string, character);
    return wcschr(string, character);
}

// const wchar_t* (*wcsrchr_c)(const wchar_t *wcs, wchar_t wc) = wcsrchr;
const wchar_t* wcsrchr_c(const wchar_t* wcs, wchar_t wc) {
    // printf("wcsrchr_c: wcs=%p wc=%d\n", wcs, wc);
    return wcsrchr(wcs, wc);
}

// const void* (*memrchr_c)(const void*, int, size_t) = memrchr;
const void* memrchr_c(const void* s, int c, size_t n) {
    // printf("memrchr_c: s=%p c=%d n=%zu\n", s, c, n);
    return memchr(s, c, n);
}

int sloader_register_atfork(void (*prepare)(void), void (*parent)(void), void (*child)(void), void* dso_handle) {
    return pthread_atfork(prepare, parent, child);
}

typedef struct {
    unsigned long int ti_module;
    unsigned long int ti_offset;
} tls_index;

void* sloader_tls_get_addr(tls_index* ti) {
    return reinterpret_cast<void*>(reinterpret_cast<char*>(sloader_dummy_to_secure_tls_space) + sloader_tls_offset + ti->ti_offset);
}

void sloader_libc_start_main(int (*main)(int, char**, char**), int argc, char** argv, void (*init)(void), void (*fini)(void),
                             void (*rtld_fini)(void), void* stack_end) {
    // Although glibc write this function in assembly, we can use a plain C function?
    // https://github.com/akawashiro/glibc/blob/0005e54f762b2ec65cee2c4ecf1e9d42612030f0/sysdeps/x86_64/start.S#L64-L76
    // TODO
    // After SYS_arch_prctl, we cannot use glog.
    // LOG(INFO) << LOG_BITS(main);
    // We need __libc_stack_end
   
    // TODO: Passing __environ to main is not correct.
    exit(main(argc, argv, __environ));
}

#define DEFINE_DUMMY_FUN(name) \
    void sloader_##name() {    \
        ;                      \
    }
// #define DEFINE_DUMMY_FUN(name) void sloader_##name(){ RAW_PRINT_STR(#name); }

DEFINE_DUMMY_FUN(ZSTD_trace_compress_begin)
DEFINE_DUMMY_FUN(ZSTD_trace_compress_end)
DEFINE_DUMMY_FUN(ZSTD_trace_decompress_begin)
DEFINE_DUMMY_FUN(ZSTD_trace_decompress_end)
DEFINE_DUMMY_FUN(_ITM_deregisterTMCloneTable)
DEFINE_DUMMY_FUN(_ITM_registerTMCloneTable)
DEFINE_DUMMY_FUN(__asprintf_chk)
DEFINE_DUMMY_FUN(__assert_fail)
DEFINE_DUMMY_FUN(__cxa_finalize)
DEFINE_DUMMY_FUN(__gmon_start__)
DEFINE_DUMMY_FUN(__gmtime_r)
DEFINE_DUMMY_FUN(__libc_dn_expand)
DEFINE_DUMMY_FUN(__libc_ns_makecanon)
DEFINE_DUMMY_FUN(__libc_ns_samename)
DEFINE_DUMMY_FUN(__libc_res_nameinquery)
DEFINE_DUMMY_FUN(__libc_res_queriesmatch)
DEFINE_DUMMY_FUN(__stack_chk_fail)
DEFINE_DUMMY_FUN(__xpg_strerror_r)
DEFINE_DUMMY_FUN(__xstat)
DEFINE_DUMMY_FUN(atexit)
DEFINE_DUMMY_FUN(__cxa_atexit)
DEFINE_DUMMY_FUN(_nl_msg_cat_cntr)
DEFINE_DUMMY_FUN(__fxstat)
DEFINE_DUMMY_FUN(__strtold_nan)
DEFINE_DUMMY_FUN(__strtod_nan)
DEFINE_DUMMY_FUN(__strtof128_nan)
DEFINE_DUMMY_FUN(__strtof_nan)
DEFINE_DUMMY_FUN(_rtld_global_ro)
DEFINE_DUMMY_FUN(__cxa_thread_atexit_impl)
DEFINE_DUMMY_FUN(delete_module)
DEFINE_DUMMY_FUN(init_module)
DEFINE_DUMMY_FUN(__libc_dynarray_resize)
DEFINE_DUMMY_FUN(_libc_intl_domainname)
DEFINE_DUMMY_FUN(__nss_configure_lookup)
DEFINE_DUMMY_FUN(__progname_full)
DEFINE_DUMMY_FUN(__progname)
DEFINE_DUMMY_FUN(__res_context_hostalias)
DEFINE_DUMMY_FUN(__res_context_query)
DEFINE_DUMMY_FUN(__res_context_search)
DEFINE_DUMMY_FUN(__resolv_context_get_override)
DEFINE_DUMMY_FUN(__resolv_context_get)
DEFINE_DUMMY_FUN(__resolv_context_put)
DEFINE_DUMMY_FUN(__res_get_nsaddr)
DEFINE_DUMMY_FUN(__res_iclose)

std::map<std::string, const char*> sloader_libc_tls_variables = {
    {"errno", reinterpret_cast<const char*>(&errno)},
    {"__h_errno", reinterpret_cast<const char*>(&h_errno)},
    {"__resp", reinterpret_cast<const char*>(&_res)},
};

int sloader_atexit_always_success(void (*function)(void)) {
    return 0;
}

std::map<std::string, Elf64_Addr> sloader_libc_map = {
    // sloader dummy functions
    {"ZSTD_trace_compress_begin", reinterpret_cast<Elf64_Addr>(&sloader_ZSTD_trace_compress_begin)},
    {"ZSTD_trace_compress_end", reinterpret_cast<Elf64_Addr>(&sloader_ZSTD_trace_compress_end)},
    {"ZSTD_trace_decompress_begin", reinterpret_cast<Elf64_Addr>(&sloader_ZSTD_trace_decompress_begin)},
    {"ZSTD_trace_decompress_end", reinterpret_cast<Elf64_Addr>(&sloader_ZSTD_trace_decompress_end)},
    {"_ITM_deregisterTMCloneTable", reinterpret_cast<Elf64_Addr>(&sloader__ITM_deregisterTMCloneTable)},
    {"_ITM_registerTMCloneTable", reinterpret_cast<Elf64_Addr>(&sloader__ITM_registerTMCloneTable)},
    {"__asprintf_chk", reinterpret_cast<Elf64_Addr>(&sloader___asprintf_chk)},
    {"__assert_fail", reinterpret_cast<Elf64_Addr>(&sloader___assert_fail)},
    {"__cxa_atexit", reinterpret_cast<Elf64_Addr>(&sloader_atexit_always_success)},
    {"__cxa_finalize", reinterpret_cast<Elf64_Addr>(&sloader___cxa_finalize)},
    {"__cxa_thread_atexit_impl", reinterpret_cast<Elf64_Addr>(&sloader___cxa_thread_atexit_impl)},
    {"__fxstat", reinterpret_cast<Elf64_Addr>(&sloader___fxstat)},
    {"__gmon_start__", reinterpret_cast<Elf64_Addr>(&sloader___gmon_start__)},
    {"__gmtime_r", reinterpret_cast<Elf64_Addr>(&sloader___gmtime_r)},
    {"__libc_dn_expand", reinterpret_cast<Elf64_Addr>(&sloader___libc_dn_expand)},
    {"__libc_dynarray_resize", reinterpret_cast<Elf64_Addr>(&sloader___libc_dynarray_resize)},
    {"__libc_ns_makecanon", reinterpret_cast<Elf64_Addr>(&sloader___libc_ns_makecanon)},
    {"__libc_ns_samename", reinterpret_cast<Elf64_Addr>(&sloader___libc_ns_samename)},
    {"__libc_res_nameinquery", reinterpret_cast<Elf64_Addr>(&sloader___libc_res_nameinquery)},
    {"__libc_res_queriesmatch", reinterpret_cast<Elf64_Addr>(&sloader___libc_res_queriesmatch)},
    {"__nss_configure_lookup", reinterpret_cast<Elf64_Addr>(&sloader___nss_configure_lookup)},
    {"__progname", reinterpret_cast<Elf64_Addr>(&sloader___progname)},
    {"__progname_full", reinterpret_cast<Elf64_Addr>(&sloader___progname_full)},
    {"__res_context_hostalias", reinterpret_cast<Elf64_Addr>(&sloader___res_context_hostalias)},
    {"__res_context_query", reinterpret_cast<Elf64_Addr>(&sloader___res_context_query)},
    {"__res_context_search", reinterpret_cast<Elf64_Addr>(&sloader___res_context_search)},
    {"__res_get_nsaddr", reinterpret_cast<Elf64_Addr>(&sloader___res_get_nsaddr)},
    {"__res_iclose", reinterpret_cast<Elf64_Addr>(&sloader___res_iclose)},
    {"__resolv_context_get", reinterpret_cast<Elf64_Addr>(&sloader___resolv_context_get)},
    {"__resolv_context_get_override", reinterpret_cast<Elf64_Addr>(&sloader___resolv_context_get_override)},
    {"__resolv_context_put", reinterpret_cast<Elf64_Addr>(&sloader___resolv_context_put)},
    {"__stack_chk_fail", reinterpret_cast<Elf64_Addr>(&sloader___stack_chk_fail)},
    {"__strtod_nan", reinterpret_cast<Elf64_Addr>(&sloader___strtod_nan)},
    {"__strtof128_nan", reinterpret_cast<Elf64_Addr>(&sloader___strtof128_nan)},
    {"__strtof_nan", reinterpret_cast<Elf64_Addr>(&sloader___strtof_nan)},
    {"__strtold_nan", reinterpret_cast<Elf64_Addr>(&sloader___strtold_nan)},
    {"__xpg_strerror_r", reinterpret_cast<Elf64_Addr>(&sloader___xpg_strerror_r)},
    {"__xstat", reinterpret_cast<Elf64_Addr>(&sloader___xstat)},
    {"_libc_intl_domainname", reinterpret_cast<Elf64_Addr>(&sloader__libc_intl_domainname)},
    {"_nl_msg_cat_cntr", reinterpret_cast<Elf64_Addr>(&sloader__nl_msg_cat_cntr)},
    {"_rtld_global_ro", reinterpret_cast<Elf64_Addr>(&sloader__rtld_global_ro)},
    {"atexit", reinterpret_cast<Elf64_Addr>(&sloader_atexit)},
    {"delete_module", reinterpret_cast<Elf64_Addr>(&sloader_delete_module)},
    {"init_module", reinterpret_cast<Elf64_Addr>(&sloader_init_module)},

    // sloader original functions
    {"__libc_start_main", reinterpret_cast<Elf64_Addr>(&sloader_libc_start_main)},
    {"__register_atfork", reinterpret_cast<Elf64_Addr>(&sloader_register_atfork)},
    {"__tls_get_addr", reinterpret_cast<Elf64_Addr>(&sloader_tls_get_addr)},

    // libc functions
    {"__ctype_b_loc", reinterpret_cast<Elf64_Addr>(&__ctype_b_loc)},
    {"__ctype_get_mb_cur_max", reinterpret_cast<Elf64_Addr>(&__ctype_get_mb_cur_max)},
    {"__ctype_tolower_loc", reinterpret_cast<Elf64_Addr>(&__ctype_tolower_loc)},
    {"__ctype_toupper_loc", reinterpret_cast<Elf64_Addr>(&__ctype_toupper_loc)},
    {"__dcgettext", reinterpret_cast<Elf64_Addr>(&__dcgettext)},
    {"__dprintf_chk", reinterpret_cast<Elf64_Addr>(&__dprintf_chk)},
    {"__duplocale", reinterpret_cast<Elf64_Addr>(&duplocale)},
    {"__environ", reinterpret_cast<Elf64_Addr>(&__environ)},
    {"__errno_location", reinterpret_cast<Elf64_Addr>(&__errno_location)},
    {"__explicit_bzero_chk", reinterpret_cast<Elf64_Addr>(&__explicit_bzero_chk)},
    {"__fdelt_chk", reinterpret_cast<Elf64_Addr>(&__fdelt_chk)},
    {"__fgets_chk", reinterpret_cast<Elf64_Addr>(&__fgets_chk)},
    {"__fgets_unlocked_chk", reinterpret_cast<Elf64_Addr>(&__fgets_unlocked_chk)},
    {"__fgetws_chk", reinterpret_cast<Elf64_Addr>(&__fgetws_chk)},
    {"__fpending", reinterpret_cast<Elf64_Addr>(&__fpending)},
    {"__fprintf_chk", reinterpret_cast<Elf64_Addr>(&__fprintf_chk)},
    {"__fpurge", reinterpret_cast<Elf64_Addr>(&__fpurge)},
    {"__fread_chk", reinterpret_cast<Elf64_Addr>(&__fread_chk)},
    {"__fread_unlocked_chk", reinterpret_cast<Elf64_Addr>(&__fread_unlocked_chk)},
    {"__freading", reinterpret_cast<Elf64_Addr>(&__freading)},
    {"__freelocale", reinterpret_cast<Elf64_Addr>(&freelocale)},
    {"__fsetlocking", reinterpret_cast<Elf64_Addr>(&__fsetlocking)},
    {"__fwriting", reinterpret_cast<Elf64_Addr>(&__fwriting)},
    {"__getdelim", reinterpret_cast<Elf64_Addr>(&__getdelim)},
    {"__getgroups_chk", reinterpret_cast<Elf64_Addr>(&__getgroups_chk)},
    {"__gethostname_chk", reinterpret_cast<Elf64_Addr>(&__gethostname_chk)},
    {"__getpagesize", reinterpret_cast<Elf64_Addr>(&__getpagesize)},
    {"__h_errno_location", reinterpret_cast<Elf64_Addr>(&__h_errno_location)},
    {"__isoc99_fscanf", reinterpret_cast<Elf64_Addr>(&fscanf)},
    {"__isoc99_scanf", reinterpret_cast<Elf64_Addr>(&scanf)},
    {"__isoc99_sscanf", reinterpret_cast<Elf64_Addr>(&sscanf)},  // TODO
    {"__isoc99_vfscanf", reinterpret_cast<Elf64_Addr>(&vfscanf)},
    {"__isoc99_vsscanf", reinterpret_cast<Elf64_Addr>(&vsscanf)},
    {"__iswctype_l", reinterpret_cast<Elf64_Addr>(&iswctype_l)},
    {"__libc_current_sigrtmax", reinterpret_cast<Elf64_Addr>(&__libc_current_sigrtmax)},
    {"__libc_current_sigrtmin", reinterpret_cast<Elf64_Addr>(&__libc_current_sigrtmin)},
    {"__libc_current_sigrtmin", reinterpret_cast<Elf64_Addr>(&__libc_current_sigrtmin)},
    {"__libc_single_threaded", reinterpret_cast<Elf64_Addr>(&__libc_single_threaded)},
    {"__longjmp_chk", reinterpret_cast<Elf64_Addr>(&longjmp)},
    {"__mbrlen", reinterpret_cast<Elf64_Addr>(&__mbrlen)},
    {"__mbsnrtowcs_chk", reinterpret_cast<Elf64_Addr>(&__mbsnrtowcs_chk)},
    {"__mbsrtowcs_chk", reinterpret_cast<Elf64_Addr>(&__mbsrtowcs_chk)},
    {"__mbstowcs_chk", reinterpret_cast<Elf64_Addr>(&__mbstowcs_chk)},
    {"__memcpy_chk", reinterpret_cast<Elf64_Addr>(&memcpy)},
    {"__memmove_chk", reinterpret_cast<Elf64_Addr>(&memmove)},
    {"__mempcpy", reinterpret_cast<Elf64_Addr>(&__mempcpy)},
    {"__mempcpy_chk", reinterpret_cast<Elf64_Addr>(&mempcpy)},
    {"__memset_chk", reinterpret_cast<Elf64_Addr>(&memset)},
    {"__newlocale", reinterpret_cast<Elf64_Addr>(&newlocale)},
    {"__nl_langinfo_l", reinterpret_cast<Elf64_Addr>(&nl_langinfo_l)},
    {"__open64_2", reinterpret_cast<Elf64_Addr>(&__open64_2)},
    {"__open_2", reinterpret_cast<Elf64_Addr>(&__open_2)},
    {"__openat64_2", reinterpret_cast<Elf64_Addr>(&__openat64_2)},
    {"__openat_2", reinterpret_cast<Elf64_Addr>(&__openat_2)},
    {"__overflow", reinterpret_cast<Elf64_Addr>(&__overflow)},
    {"__poll_chk", reinterpret_cast<Elf64_Addr>(&__poll_chk)},
    {"__ppoll_chk", reinterpret_cast<Elf64_Addr>(&__ppoll_chk)},
    {"__pread64_chk", reinterpret_cast<Elf64_Addr>(&__pread64_chk)},
    {"__pread_chk", reinterpret_cast<Elf64_Addr>(&__pread_chk)},
    {"__printf_chk", reinterpret_cast<Elf64_Addr>(&__printf_chk)},
    {"__rawmemchr", reinterpret_cast<Elf64_Addr>(&rawmemchr_c)},
    {"__read_chk", reinterpret_cast<Elf64_Addr>(&__read_chk)},
    {"__realpath_chk", reinterpret_cast<Elf64_Addr>(&__realpath_chk)},
    {"__res_init", reinterpret_cast<Elf64_Addr>(&__res_init)},
    {"__res_nclose", reinterpret_cast<Elf64_Addr>(&__res_nclose)},
    {"__res_ninit", reinterpret_cast<Elf64_Addr>(&__res_ninit)},
    {"__resp", reinterpret_cast<Elf64_Addr>(&__resp)},
    {"__sched_cpualloc", reinterpret_cast<Elf64_Addr>(&__sched_cpualloc)},
    {"__sched_cpucount", reinterpret_cast<Elf64_Addr>(&__sched_cpucount)},
    {"__sched_cpufree", reinterpret_cast<Elf64_Addr>(&__sched_cpufree)},
    {"__sigsetjmp", reinterpret_cast<Elf64_Addr>(&__sigsetjmp)},
    {"__snprintf_chk", reinterpret_cast<Elf64_Addr>(&__snprintf_chk)},
    {"__sprintf_chk", reinterpret_cast<Elf64_Addr>(&__sprintf_chk)},
    {"__stpcpy", reinterpret_cast<Elf64_Addr>(&__stpcpy)},
    {"__stpcpy_chk", reinterpret_cast<Elf64_Addr>(&stpcpy)},
    {"__strcat_chk", reinterpret_cast<Elf64_Addr>(&strcat)},
    {"__strcoll_l", reinterpret_cast<Elf64_Addr>(&strcoll_l)},
    {"__strcpy_chk", reinterpret_cast<Elf64_Addr>(&strcpy)},
    {"__strftime_l", reinterpret_cast<Elf64_Addr>(&strftime_l)},
    {"__strncat_chk", reinterpret_cast<Elf64_Addr>(&strncat)},
    {"__strncpy_chk", reinterpret_cast<Elf64_Addr>(&strncpy)},
    {"__strtod_l", reinterpret_cast<Elf64_Addr>(&strtod_l)},
    {"__strtof_l", reinterpret_cast<Elf64_Addr>(&strtof_l)},
    {"__strxfrm_l", reinterpret_cast<Elf64_Addr>(&strxfrm_l)},
    {"__sysconf", reinterpret_cast<Elf64_Addr>(&__sysconf)},
    {"__syslog_chk", reinterpret_cast<Elf64_Addr>(&__syslog_chk)},
    {"__sysv_signal", reinterpret_cast<Elf64_Addr>(&__sysv_signal)},
    {"__timezone", reinterpret_cast<Elf64_Addr>(&__timezone)},
    {"__towlower_l", reinterpret_cast<Elf64_Addr>(&towlower_l)},
    {"__towupper_l", reinterpret_cast<Elf64_Addr>(&towupper_l)},
    {"__uflow", reinterpret_cast<Elf64_Addr>(&__uflow)},
    {"__uselocale", reinterpret_cast<Elf64_Addr>(&__gnu_cxx::__uselocale)},
    {"__vasprintf_chk", reinterpret_cast<Elf64_Addr>(&__vasprintf_chk)},
    {"__vfprintf_chk", reinterpret_cast<Elf64_Addr>(&__vfprintf_chk)},
    {"__vsnprintf_chk", reinterpret_cast<Elf64_Addr>(&__vsnprintf_chk)},
    {"__vsprintf_chk", reinterpret_cast<Elf64_Addr>(&__vsprintf_chk)},
    {"__vsyslog_chk", reinterpret_cast<Elf64_Addr>(&__vsyslog_chk)},
    {"__wcscoll_l", reinterpret_cast<Elf64_Addr>(&wcscoll_l)},
    {"__wcsftime_l", reinterpret_cast<Elf64_Addr>(&wcsftime_l)},
    {"__wcsncpy_chk", reinterpret_cast<Elf64_Addr>(&__wcsncpy_chk)},
    {"__wcsxfrm_l", reinterpret_cast<Elf64_Addr>(&wcsxfrm_l)},
    {"__wctomb_chk", reinterpret_cast<Elf64_Addr>(&__wctomb_chk)},
    {"__wctype_l", reinterpret_cast<Elf64_Addr>(&wctype_l)},
    {"__wmemcpy_chk", reinterpret_cast<Elf64_Addr>(&__wmemcpy_chk)},
    {"__wmemmove_chk", reinterpret_cast<Elf64_Addr>(&__wmemmove_chk)},
    {"__wmemset_chk", reinterpret_cast<Elf64_Addr>(&__wmemset_chk)},
    {"__xpg_basename", reinterpret_cast<Elf64_Addr>(&__xpg_basename)},
    {"_dl_find_object", reinterpret_cast<Elf64_Addr>(&_dl_find_object)},
    {"_exit", reinterpret_cast<Elf64_Addr>(&_exit)},
    {"_longjmp", reinterpret_cast<Elf64_Addr>(&_longjmp)},
    {"_obstack_begin", reinterpret_cast<Elf64_Addr>(&_obstack_begin)},
    {"_obstack_newchunk", reinterpret_cast<Elf64_Addr>(&_obstack_newchunk)},
    {"_obstack_free", reinterpret_cast<Elf64_Addr>(&obstack_free)},
    {"_setjmp", reinterpret_cast<Elf64_Addr>(&_setjmp)},
    {"abort", reinterpret_cast<Elf64_Addr>(&abort)},
    {"accept", reinterpret_cast<Elf64_Addr>(&accept)},
    {"accept4", reinterpret_cast<Elf64_Addr>(&accept4)},
    {"access", reinterpret_cast<Elf64_Addr>(&access)},
    {"access", reinterpret_cast<Elf64_Addr>(&access)},
    {"alarm", reinterpret_cast<Elf64_Addr>(&alarm)},
    {"aligned_alloc", reinterpret_cast<Elf64_Addr>(&aligned_alloc)},
    {"alphasort", reinterpret_cast<Elf64_Addr>(&alphasort)},
    {"alphasort64", reinterpret_cast<Elf64_Addr>(&alphasort64)},
    {"argp_err_exit_status", reinterpret_cast<Elf64_Addr>(&argp_err_exit_status)},
    {"argp_help", reinterpret_cast<Elf64_Addr>(&argp_help)},
    {"argp_parse", reinterpret_cast<Elf64_Addr>(&argp_parse)},
    {"argz_create_sep", reinterpret_cast<Elf64_Addr>(&argz_create_sep)},
    {"asctime", reinterpret_cast<Elf64_Addr>(&asctime)},
    {"asctime_r", reinterpret_cast<Elf64_Addr>(&asctime_r)},
    {"asprintf", reinterpret_cast<Elf64_Addr>(&asprintf)},
    {"atof", reinterpret_cast<Elf64_Addr>(&atof)},
    {"atoi", reinterpret_cast<Elf64_Addr>(&atoi)},
    {"atol", reinterpret_cast<Elf64_Addr>(&atol)},
    {"atoll", reinterpret_cast<Elf64_Addr>(&atoll)},
    {"backtrace", reinterpret_cast<Elf64_Addr>(&backtrace)},
    {"backtrace_symbols", reinterpret_cast<Elf64_Addr>(&backtrace_symbols)},
    {"backtrace_symbols_fd", reinterpret_cast<Elf64_Addr>(&backtrace_symbols_fd)},
    {"basename", reinterpret_cast<Elf64_Addr>(&basename)},
    {"bind", reinterpret_cast<Elf64_Addr>(&bind)},
    {"bind_textdomain_codeset", reinterpret_cast<Elf64_Addr>(&bind_textdomain_codeset)},
    {"bindtextdomain", reinterpret_cast<Elf64_Addr>(&bindtextdomain)},
    {"bsearch", reinterpret_cast<Elf64_Addr>(&bsearch)},
    {"bsearch", reinterpret_cast<Elf64_Addr>(&bsearch)},
    {"bsearch", reinterpret_cast<Elf64_Addr>(&bsearch)},
    {"bsearch", reinterpret_cast<Elf64_Addr>(&bsearch)},
    {"bsearch", reinterpret_cast<Elf64_Addr>(&bsearch)},
    {"btowc", reinterpret_cast<Elf64_Addr>(&btowc)},
    {"calloc", reinterpret_cast<Elf64_Addr>(&calloc)},
    {"canonicalize_file_name", reinterpret_cast<Elf64_Addr>(&canonicalize_file_name)},
    {"capget", reinterpret_cast<Elf64_Addr>(&capget)},
    {"capset", reinterpret_cast<Elf64_Addr>(&capset)},
    {"cfgetispeed", reinterpret_cast<Elf64_Addr>(&cfgetispeed)},
    {"cfgetospeed", reinterpret_cast<Elf64_Addr>(&cfgetospeed)},
    {"cfmakeraw", reinterpret_cast<Elf64_Addr>(&cfmakeraw)},
    {"cfsetispeed", reinterpret_cast<Elf64_Addr>(&cfsetispeed)},
    {"cfsetospeed", reinterpret_cast<Elf64_Addr>(&cfsetospeed)},
    {"cfsetspeed", reinterpret_cast<Elf64_Addr>(&cfsetspeed)},
    {"chdir", reinterpret_cast<Elf64_Addr>(&chdir)},
    {"chmod", reinterpret_cast<Elf64_Addr>(&chmod)},
    {"chown", reinterpret_cast<Elf64_Addr>(&chown)},
    {"chroot", reinterpret_cast<Elf64_Addr>(&chroot)},
    {"clearenv", reinterpret_cast<Elf64_Addr>(&clearenv)},
    {"clearerr", reinterpret_cast<Elf64_Addr>(&clearerr)},
    {"clearerr_unlocked", reinterpret_cast<Elf64_Addr>(&clearerr_unlocked)},
    {"clock", reinterpret_cast<Elf64_Addr>(&clock)},
    {"clock_getres", reinterpret_cast<Elf64_Addr>(&clock_getres)},
    {"clock_gettime", reinterpret_cast<Elf64_Addr>(&clock_gettime)},
    {"clock_settime", reinterpret_cast<Elf64_Addr>(&clock_settime)},
    {"clone", reinterpret_cast<Elf64_Addr>(&clone)},
    {"close", reinterpret_cast<Elf64_Addr>(&close)},
    {"close_range", reinterpret_cast<Elf64_Addr>(&close_range)},
    {"closedir", reinterpret_cast<Elf64_Addr>(&closedir)},
    {"closefrom", reinterpret_cast<Elf64_Addr>(&closefrom)},
    {"closelog", reinterpret_cast<Elf64_Addr>(&closelog)},
    {"confstr", reinterpret_cast<Elf64_Addr>(&confstr)},
    {"connect", reinterpret_cast<Elf64_Addr>(&connect)},
    {"copy_file_range", reinterpret_cast<Elf64_Addr>(&copy_file_range)},
    {"creat", reinterpret_cast<Elf64_Addr>(&creat)},
    {"creat64", reinterpret_cast<Elf64_Addr>(&creat64)},
    {"ctermid", reinterpret_cast<Elf64_Addr>(&ctermid)},
    {"ctime", reinterpret_cast<Elf64_Addr>(&ctime)},
    {"ctime_r", reinterpret_cast<Elf64_Addr>(&ctime_r)},
    {"daemon", reinterpret_cast<Elf64_Addr>(&daemon)},
    {"dcgettext", reinterpret_cast<Elf64_Addr>(&dcgettext)},
    {"dcngettext", reinterpret_cast<Elf64_Addr>(&dcngettext)},
    {"dgettext", reinterpret_cast<Elf64_Addr>(&dgettext)},
    {"difftime", reinterpret_cast<Elf64_Addr>(&difftime)},
    {"dirfd", reinterpret_cast<Elf64_Addr>(&dirfd)},
    {"dirname", reinterpret_cast<Elf64_Addr>(&dirname)},
    {"dl_iterate_phdr", reinterpret_cast<Elf64_Addr>(&dl_iterate_phdr)},
    {"dladdr", reinterpret_cast<Elf64_Addr>(&sloader_dladdr)},
    {"dlclose", reinterpret_cast<Elf64_Addr>(&dlclose)},
    {"dlerror", reinterpret_cast<Elf64_Addr>(&dlerror)},
    {"dlopen", reinterpret_cast<Elf64_Addr>(&sloader_dlopen)},
    {"dlsym", reinterpret_cast<Elf64_Addr>(&sloader_dlsym)},
    {"dlvsym", reinterpret_cast<Elf64_Addr>(&sloader_dlvsym)},
    {"dn_expand", reinterpret_cast<Elf64_Addr>(&dn_expand)},
    {"dn_skipname", reinterpret_cast<Elf64_Addr>(&dn_skipname)},
    {"dngettext", reinterpret_cast<Elf64_Addr>(&dngettext)},
    {"dup", reinterpret_cast<Elf64_Addr>(&dup)},
    {"dup2", reinterpret_cast<Elf64_Addr>(&dup2)},
    {"dup3", reinterpret_cast<Elf64_Addr>(&dup3)},
    {"duplocale", reinterpret_cast<Elf64_Addr>(&duplocale)},
    {"duplocale", reinterpret_cast<Elf64_Addr>(&duplocale)},
    {"duplocale", reinterpret_cast<Elf64_Addr>(&duplocale)},
    {"duplocale", reinterpret_cast<Elf64_Addr>(&duplocale)},
    {"eaccess", reinterpret_cast<Elf64_Addr>(&eaccess)},
    {"endaliasent", reinterpret_cast<Elf64_Addr>(&endaliasent)},
    {"endgrent", reinterpret_cast<Elf64_Addr>(&endgrent)},
    {"endhostent", reinterpret_cast<Elf64_Addr>(&endhostent)},
    {"endmntent", reinterpret_cast<Elf64_Addr>(&endmntent)},
    {"endnetent", reinterpret_cast<Elf64_Addr>(&endnetent)},
    {"endnetgrent", reinterpret_cast<Elf64_Addr>(&endnetgrent)},
    {"endprotoent", reinterpret_cast<Elf64_Addr>(&endprotoent)},
    {"endpwent", reinterpret_cast<Elf64_Addr>(&endpwent)},
    {"endrpcent", reinterpret_cast<Elf64_Addr>(&endrpcent)},
    {"endservent", reinterpret_cast<Elf64_Addr>(&endservent)},
    {"endsgent", reinterpret_cast<Elf64_Addr>(&endsgent)},
    {"endspent", reinterpret_cast<Elf64_Addr>(&endspent)},
    {"endusershell", reinterpret_cast<Elf64_Addr>(&endusershell)},
    {"endutent", reinterpret_cast<Elf64_Addr>(&endutent)},
    {"endutxent", reinterpret_cast<Elf64_Addr>(&endutxent)},
    {"environ", reinterpret_cast<Elf64_Addr>(&environ)},
    {"epoll_create", reinterpret_cast<Elf64_Addr>(&epoll_create)},
    {"epoll_create1", reinterpret_cast<Elf64_Addr>(&epoll_create1)},
    {"epoll_ctl", reinterpret_cast<Elf64_Addr>(&epoll_ctl)},
    {"epoll_pwait", reinterpret_cast<Elf64_Addr>(&epoll_pwait)},
    {"epoll_wait", reinterpret_cast<Elf64_Addr>(&epoll_wait)},
    {"err", reinterpret_cast<Elf64_Addr>(&err)},
    {"error", reinterpret_cast<Elf64_Addr>(&error)},
    {"error_at_line", reinterpret_cast<Elf64_Addr>(&error_at_line)},
    {"errx", reinterpret_cast<Elf64_Addr>(&errx)},
    {"ether_aton", reinterpret_cast<Elf64_Addr>(&ether_aton)},
    {"ether_hostton", reinterpret_cast<Elf64_Addr>(&ether_hostton)},
    {"ether_ntoa", reinterpret_cast<Elf64_Addr>(&ether_ntoa)},
    {"ether_ntohost", reinterpret_cast<Elf64_Addr>(&ether_ntohost)},
    {"euidaccess", reinterpret_cast<Elf64_Addr>(&euidaccess)},
    {"eventfd", reinterpret_cast<Elf64_Addr>(&eventfd)},
    {"eventfd_read", reinterpret_cast<Elf64_Addr>(&eventfd_read)},
    {"eventfd_write", reinterpret_cast<Elf64_Addr>(&eventfd_write)},
    {"execl", reinterpret_cast<Elf64_Addr>(&execl)},
    {"execle", reinterpret_cast<Elf64_Addr>(&execle)},
    {"execlp", reinterpret_cast<Elf64_Addr>(&execlp)},
    {"execv", reinterpret_cast<Elf64_Addr>(&execv)},
    {"execve", reinterpret_cast<Elf64_Addr>(&execve)},
    {"execvp", reinterpret_cast<Elf64_Addr>(&execvp)},
    {"exit", reinterpret_cast<Elf64_Addr>(&exit)},
    {"faccessat", reinterpret_cast<Elf64_Addr>(&faccessat)},
    {"fallocate", reinterpret_cast<Elf64_Addr>(&fallocate)},
    {"fallocate64", reinterpret_cast<Elf64_Addr>(&fallocate64)},
    {"fchdir", reinterpret_cast<Elf64_Addr>(&fchdir)},
    {"fchmod", reinterpret_cast<Elf64_Addr>(&fchmod)},
    {"fchmodat", reinterpret_cast<Elf64_Addr>(&fchmodat)},
    {"fchown", reinterpret_cast<Elf64_Addr>(&fchown)},
    {"fchownat", reinterpret_cast<Elf64_Addr>(&fchownat)},
    {"fclose", reinterpret_cast<Elf64_Addr>(&fclose)},
    {"fcntl", reinterpret_cast<Elf64_Addr>(&fcntl)},
    {"fcntl64", reinterpret_cast<Elf64_Addr>(&fcntl64)},
    {"fdatasync", reinterpret_cast<Elf64_Addr>(&fdatasync)},
    {"fdopen", reinterpret_cast<Elf64_Addr>(&fdopen)},
    {"fdopendir", reinterpret_cast<Elf64_Addr>(&fdopendir)},
    {"feof", reinterpret_cast<Elf64_Addr>(&feof)},
    {"ferror", reinterpret_cast<Elf64_Addr>(&ferror)},
    {"fexecve", reinterpret_cast<Elf64_Addr>(&fexecve)},
    {"fflush", reinterpret_cast<Elf64_Addr>(&fflush)},
    {"fflush_unlocked", reinterpret_cast<Elf64_Addr>(&fflush_unlocked)},
    {"fgetc", reinterpret_cast<Elf64_Addr>(&fgetc)},
    {"fgets", reinterpret_cast<Elf64_Addr>(&fgets)},
    {"fgets_unlocked", reinterpret_cast<Elf64_Addr>(&fgets_unlocked)},
    {"fgetwc", reinterpret_cast<Elf64_Addr>(&fgetwc)},
    {"fgetxattr", reinterpret_cast<Elf64_Addr>(&fgetxattr)},
    {"fileno", reinterpret_cast<Elf64_Addr>(&fileno)},
    {"fileno_unlocked", reinterpret_cast<Elf64_Addr>(&fileno_unlocked)},
    {"flistxattr", reinterpret_cast<Elf64_Addr>(&flistxattr)},
    {"flock", reinterpret_cast<Elf64_Addr>(&flock)},
    {"flockfile", reinterpret_cast<Elf64_Addr>(&flockfile)},
    {"fmemopen", reinterpret_cast<Elf64_Addr>(&fmemopen)},
    {"fnmatch", reinterpret_cast<Elf64_Addr>(&fnmatch)},
    {"fopen", reinterpret_cast<Elf64_Addr>(&fopen)},
    {"fopen64", reinterpret_cast<Elf64_Addr>(&fopen64)},
    {"fopencookie", reinterpret_cast<Elf64_Addr>(&fopencookie)},
    {"fork", reinterpret_cast<Elf64_Addr>(&fork)},
    {"forkpty", reinterpret_cast<Elf64_Addr>(&forkpty)},
    {"fpathconf", reinterpret_cast<Elf64_Addr>(&fpathconf)},
    {"fprintf", reinterpret_cast<Elf64_Addr>(&fprintf)},
    {"fputc", reinterpret_cast<Elf64_Addr>(&fputc)},
    {"fputc_unlocked", reinterpret_cast<Elf64_Addr>(&fputc_unlocked)},
    {"fputs", reinterpret_cast<Elf64_Addr>(&fputs)},
    {"fputs_unlocked", reinterpret_cast<Elf64_Addr>(&fputs_unlocked)},
    {"fputwc", reinterpret_cast<Elf64_Addr>(&fputwc)},
    {"fputws", reinterpret_cast<Elf64_Addr>(&fputws)},
    {"fread", reinterpret_cast<Elf64_Addr>(&fread)},
    {"fread_unlocked", reinterpret_cast<Elf64_Addr>(&fread_unlocked)},
    {"free", reinterpret_cast<Elf64_Addr>(&free)},
    {"freeaddrinfo", reinterpret_cast<Elf64_Addr>(&freeaddrinfo)},
    {"freeaddrinfo", reinterpret_cast<Elf64_Addr>(&freeaddrinfo)},
    {"freeaddrinfo", reinterpret_cast<Elf64_Addr>(&freeaddrinfo)},
    {"freeaddrinfo", reinterpret_cast<Elf64_Addr>(&freeaddrinfo)},
    {"freeaddrinfo", reinterpret_cast<Elf64_Addr>(&freeaddrinfo)},
    {"freeifaddrs", reinterpret_cast<Elf64_Addr>(&freeifaddrs)},
    {"freelocale", reinterpret_cast<Elf64_Addr>(&freelocale)},
    {"fremovexattr", reinterpret_cast<Elf64_Addr>(&fremovexattr)},
    {"freopen", reinterpret_cast<Elf64_Addr>(&freopen)},
    {"freopen64", reinterpret_cast<Elf64_Addr>(&freopen64)},
    {"frexp", reinterpret_cast<Elf64_Addr>(frexp_c)},
    {"frexpl", reinterpret_cast<Elf64_Addr>(&frexpl)},
    {"fscanf", reinterpret_cast<Elf64_Addr>(&fscanf)},
    {"fseek", reinterpret_cast<Elf64_Addr>(&fseek)},
    {"fseeko", reinterpret_cast<Elf64_Addr>(&fseeko)},
    {"fseeko64", reinterpret_cast<Elf64_Addr>(&fseeko64)},
    {"fsetxattr", reinterpret_cast<Elf64_Addr>(&fsetxattr)},
    {"fstat", reinterpret_cast<Elf64_Addr>(&fstat)},
    {"fstat64", reinterpret_cast<Elf64_Addr>(&fstat64)},
    {"fstatat", reinterpret_cast<Elf64_Addr>(&fstatat)},
    {"fstatat64", reinterpret_cast<Elf64_Addr>(&fstatat64)},
    {"fstatfs", reinterpret_cast<Elf64_Addr>(&fstatfs)},
    {"fstatfs64", reinterpret_cast<Elf64_Addr>(&fstatfs64)},
    {"fstatvfs", reinterpret_cast<Elf64_Addr>(&fstatvfs)},
    {"fstatvfs64", reinterpret_cast<Elf64_Addr>(&fstatvfs64)},
    {"fsync", reinterpret_cast<Elf64_Addr>(&fsync)},
    {"ftell", reinterpret_cast<Elf64_Addr>(&ftell)},
    {"ftello", reinterpret_cast<Elf64_Addr>(&ftello)},
    {"ftello64", reinterpret_cast<Elf64_Addr>(&ftello64)},
    {"ftruncate", reinterpret_cast<Elf64_Addr>(&ftruncate)},
    {"ftruncate64", reinterpret_cast<Elf64_Addr>(&ftruncate64)},
    {"fts_close", reinterpret_cast<Elf64_Addr>(&fts_close)},
    {"fts_open", reinterpret_cast<Elf64_Addr>(&fts_open)},
    {"fts_read", reinterpret_cast<Elf64_Addr>(&fts_read)},
    {"fts_set", reinterpret_cast<Elf64_Addr>(&fts_set)},
    {"ftw", reinterpret_cast<Elf64_Addr>(&ftw)},
    {"funlockfile", reinterpret_cast<Elf64_Addr>(&funlockfile)},
    {"futimens", reinterpret_cast<Elf64_Addr>(&futimens)},
    {"futimesat", reinterpret_cast<Elf64_Addr>(&futimesat)},
    {"fwrite", reinterpret_cast<Elf64_Addr>(&fwrite)},
    {"fwrite_unlocked", reinterpret_cast<Elf64_Addr>(&fwrite_unlocked)},
    {"gai_strerror", reinterpret_cast<Elf64_Addr>(&gai_strerror)},
    {"get_current_dir_name", reinterpret_cast<Elf64_Addr>(&get_current_dir_name)},
    {"get_nprocs", reinterpret_cast<Elf64_Addr>(&get_nprocs)},
    {"getaddrinfo", reinterpret_cast<Elf64_Addr>(&getaddrinfo)},
    {"getaliasbyname", reinterpret_cast<Elf64_Addr>(&getaliasbyname)},
    {"getaliasent", reinterpret_cast<Elf64_Addr>(&getaliasent)},
    {"getauxval", reinterpret_cast<Elf64_Addr>(&getauxval)},
    {"getc", reinterpret_cast<Elf64_Addr>(&getc)},
    {"getcontext", reinterpret_cast<Elf64_Addr>(&getcontext)},
    {"getcwd", reinterpret_cast<Elf64_Addr>(&getcwd)},
    {"getdelim", reinterpret_cast<Elf64_Addr>(&getdelim)},
    {"getdomainname", reinterpret_cast<Elf64_Addr>(&getdomainname)},
    {"getdtablesize", reinterpret_cast<Elf64_Addr>(&getdtablesize)},
    {"getegid", reinterpret_cast<Elf64_Addr>(&getegid)},
    {"getentropy", reinterpret_cast<Elf64_Addr>(&getentropy)},
    {"getenv", reinterpret_cast<Elf64_Addr>(&getenv)},
    {"geteuid", reinterpret_cast<Elf64_Addr>(&geteuid)},
    {"getgid", reinterpret_cast<Elf64_Addr>(&getgid)},
    {"getgrent", reinterpret_cast<Elf64_Addr>(&getgrent)},
    {"getgrgid", reinterpret_cast<Elf64_Addr>(&getgrgid)},
    {"getgrgid_r", reinterpret_cast<Elf64_Addr>(&getgrgid_r)},
    {"getgrnam", reinterpret_cast<Elf64_Addr>(&getgrnam)},
    {"getgrnam_r", reinterpret_cast<Elf64_Addr>(&getgrnam_r)},
    {"getgrouplist", reinterpret_cast<Elf64_Addr>(&getgrouplist)},
    {"getgroups", reinterpret_cast<Elf64_Addr>(&getgroups)},
    {"gethostbyaddr", reinterpret_cast<Elf64_Addr>(&gethostbyaddr)},
    {"gethostbyaddr_r", reinterpret_cast<Elf64_Addr>(&gethostbyaddr_r)},
    {"gethostbyname", reinterpret_cast<Elf64_Addr>(&gethostbyname)},
    {"gethostbyname2", reinterpret_cast<Elf64_Addr>(&gethostbyname2)},
    {"gethostbyname_r", reinterpret_cast<Elf64_Addr>(&gethostbyname_r)},
    {"gethostent", reinterpret_cast<Elf64_Addr>(&gethostent)},
    {"gethostid", reinterpret_cast<Elf64_Addr>(&gethostid)},
    {"gethostname", reinterpret_cast<Elf64_Addr>(&gethostname)},
    {"getifaddrs", reinterpret_cast<Elf64_Addr>(&getifaddrs)},
    {"getifaddrs", reinterpret_cast<Elf64_Addr>(&getifaddrs)},
    {"getitimer", reinterpret_cast<Elf64_Addr>(&getitimer)},
    {"getline", reinterpret_cast<Elf64_Addr>(&getline)},
    {"getloadavg", reinterpret_cast<Elf64_Addr>(&getloadavg)},
    {"getlogin", reinterpret_cast<Elf64_Addr>(&getlogin)},
    {"getmntent", reinterpret_cast<Elf64_Addr>(&getmntent)},
    {"getmntent_r", reinterpret_cast<Elf64_Addr>(&getmntent_r)},
    {"getnameinfo", reinterpret_cast<Elf64_Addr>(&getnameinfo)},
    {"getnetbyaddr", reinterpret_cast<Elf64_Addr>(&getnetbyaddr)},
    {"getnetbyname", reinterpret_cast<Elf64_Addr>(&getnetbyname)},
    {"getnetent", reinterpret_cast<Elf64_Addr>(&getnetent)},
    {"getnetgrent", reinterpret_cast<Elf64_Addr>(&getnetgrent)},
    {"getopt", reinterpret_cast<Elf64_Addr>(&getopt)},
    {"getopt_long", reinterpret_cast<Elf64_Addr>(&getopt_long)},
    {"getopt_long_only", reinterpret_cast<Elf64_Addr>(&getopt_long_only)},
    {"getpagesize", reinterpret_cast<Elf64_Addr>(&getpagesize)},
    {"getpass", reinterpret_cast<Elf64_Addr>(&getpass)},
    {"getpeername", reinterpret_cast<Elf64_Addr>(&getpeername)},
    {"getpgid", reinterpret_cast<Elf64_Addr>(&getpgid)},
    {"getpgrp", reinterpret_cast<Elf64_Addr>(&getpgrp)},
    {"getpid", reinterpret_cast<Elf64_Addr>(&getpid)},
    {"getppid", reinterpret_cast<Elf64_Addr>(&getppid)},
    {"getpriority", reinterpret_cast<Elf64_Addr>(&getpriority)},
    {"getprotobyname", reinterpret_cast<Elf64_Addr>(&getprotobyname)},
    {"getprotobynumber", reinterpret_cast<Elf64_Addr>(&getprotobynumber)},
    {"getprotoent", reinterpret_cast<Elf64_Addr>(&getprotoent)},
    {"getpwent", reinterpret_cast<Elf64_Addr>(&getpwent)},
    {"getpwnam", reinterpret_cast<Elf64_Addr>(&getpwnam)},
    {"getpwnam_r", reinterpret_cast<Elf64_Addr>(&getpwnam_r)},
    {"getpwuid", reinterpret_cast<Elf64_Addr>(&getpwuid)},
    {"getpwuid_r", reinterpret_cast<Elf64_Addr>(&getpwuid_r)},
    {"getpwuid_r", reinterpret_cast<Elf64_Addr>(&getpwuid_r)},
    {"getpwuid_r", reinterpret_cast<Elf64_Addr>(&getpwuid_r)},
    {"getrandom", reinterpret_cast<Elf64_Addr>(&getrandom)},
    {"getresgid", reinterpret_cast<Elf64_Addr>(&getresgid)},
    {"getresuid", reinterpret_cast<Elf64_Addr>(&getresuid)},
    {"getrlimit", reinterpret_cast<Elf64_Addr>(&getrlimit)},
    {"getrlimit64", reinterpret_cast<Elf64_Addr>(&getrlimit64)},
    {"getrpcbyname", reinterpret_cast<Elf64_Addr>(&getrpcbyname)},
    {"getrpcbynumber", reinterpret_cast<Elf64_Addr>(&getrpcbynumber)},
    {"getrpcent", reinterpret_cast<Elf64_Addr>(&getrpcent)},
    {"getrusage", reinterpret_cast<Elf64_Addr>(&getrusage)},
    {"getservbyname", reinterpret_cast<Elf64_Addr>(&getservbyname)},
    {"getservbyport", reinterpret_cast<Elf64_Addr>(&getservbyport)},
    {"getservbyport_r", reinterpret_cast<Elf64_Addr>(&getservbyport_r)},
    {"getservent", reinterpret_cast<Elf64_Addr>(&getservent)},
    {"getsgent", reinterpret_cast<Elf64_Addr>(&getsgent)},
    {"getsgnam", reinterpret_cast<Elf64_Addr>(&getsgnam)},
    {"getsid", reinterpret_cast<Elf64_Addr>(&getsid)},
    {"getsockname", reinterpret_cast<Elf64_Addr>(&getsockname)},
    {"getsockopt", reinterpret_cast<Elf64_Addr>(&getsockopt)},
    {"getspent", reinterpret_cast<Elf64_Addr>(&getspent)},
    {"getspnam", reinterpret_cast<Elf64_Addr>(&getspnam)},
    {"getspnam_r", reinterpret_cast<Elf64_Addr>(&getspnam_r)},
    {"gettext", reinterpret_cast<Elf64_Addr>(&gettext)},
    {"gettid", reinterpret_cast<Elf64_Addr>(&gettid)},
    {"gettimeofday", reinterpret_cast<Elf64_Addr>(&gettimeofday)},
    {"getttynam", reinterpret_cast<Elf64_Addr>(&getttynam)},
    {"getuid", reinterpret_cast<Elf64_Addr>(&getuid)},
    {"getusershell", reinterpret_cast<Elf64_Addr>(&getusershell)},
    {"getutent", reinterpret_cast<Elf64_Addr>(&getutent)},
    {"getutline", reinterpret_cast<Elf64_Addr>(&getutline)},
    {"getutxent", reinterpret_cast<Elf64_Addr>(&getutxent)},
    {"getutxline", reinterpret_cast<Elf64_Addr>(&getutxline)},
    {"getwc", reinterpret_cast<Elf64_Addr>(&getwc)},
    {"getwchar", reinterpret_cast<Elf64_Addr>(&getwchar)},
    {"getxattr", reinterpret_cast<Elf64_Addr>(&getxattr)},
    {"glob", reinterpret_cast<Elf64_Addr>(&glob)},
    {"glob64", reinterpret_cast<Elf64_Addr>(&glob64)},
    {"glob_pattern_p", reinterpret_cast<Elf64_Addr>(&glob_pattern_p)},
    {"globfree", reinterpret_cast<Elf64_Addr>(&globfree)},
    {"globfree64", reinterpret_cast<Elf64_Addr>(&globfree64)},
    {"gmtime", reinterpret_cast<Elf64_Addr>(&gmtime)},
    {"gmtime_r", reinterpret_cast<Elf64_Addr>(&gmtime_r)},
    {"gnu_dev_major", reinterpret_cast<Elf64_Addr>(&gnu_dev_major)},
    {"gnu_dev_major", reinterpret_cast<Elf64_Addr>(&gnu_dev_major)},
    {"gnu_dev_major", reinterpret_cast<Elf64_Addr>(&gnu_dev_major)},
    {"gnu_dev_major", reinterpret_cast<Elf64_Addr>(&gnu_dev_major)},
    {"gnu_dev_major", reinterpret_cast<Elf64_Addr>(&gnu_dev_major)},
    {"gnu_dev_makedev", reinterpret_cast<Elf64_Addr>(&gnu_dev_makedev)},
    {"gnu_dev_makedev", reinterpret_cast<Elf64_Addr>(&gnu_dev_makedev)},
    {"gnu_dev_makedev", reinterpret_cast<Elf64_Addr>(&gnu_dev_makedev)},
    {"gnu_dev_makedev", reinterpret_cast<Elf64_Addr>(&gnu_dev_makedev)},
    {"gnu_dev_makedev", reinterpret_cast<Elf64_Addr>(&gnu_dev_makedev)},
    {"gnu_dev_minor", reinterpret_cast<Elf64_Addr>(&gnu_dev_minor)},
    {"gnu_dev_minor", reinterpret_cast<Elf64_Addr>(&gnu_dev_minor)},
    {"gnu_dev_minor", reinterpret_cast<Elf64_Addr>(&gnu_dev_minor)},
    {"gnu_dev_minor", reinterpret_cast<Elf64_Addr>(&gnu_dev_minor)},
    {"gnu_dev_minor", reinterpret_cast<Elf64_Addr>(&gnu_dev_minor)},
    {"gnu_get_libc_version", reinterpret_cast<Elf64_Addr>(&gnu_get_libc_version)},
    {"grantpt", reinterpret_cast<Elf64_Addr>(&grantpt)},
    {"group_member", reinterpret_cast<Elf64_Addr>(&group_member)},
    {"hasmntopt", reinterpret_cast<Elf64_Addr>(&hasmntopt)},
    {"herror", reinterpret_cast<Elf64_Addr>(&herror)},
    {"hstrerror", reinterpret_cast<Elf64_Addr>(&hstrerror)},
    {"iconv", reinterpret_cast<Elf64_Addr>(&iconv)},
    {"iconv_close", reinterpret_cast<Elf64_Addr>(&iconv_close)},
    {"iconv_open", reinterpret_cast<Elf64_Addr>(&iconv_open)},
    {"if_freenameindex", reinterpret_cast<Elf64_Addr>(&if_freenameindex)},
    {"if_indextoname", reinterpret_cast<Elf64_Addr>(&if_indextoname)},
    {"if_nameindex", reinterpret_cast<Elf64_Addr>(&if_nameindex)},
    {"if_nametoindex", reinterpret_cast<Elf64_Addr>(&if_nametoindex)},
    {"in6addr_any", reinterpret_cast<Elf64_Addr>(&in6addr_any)},
    {"in6addr_any", reinterpret_cast<Elf64_Addr>(&in6addr_any)},
    {"in6addr_loopback", reinterpret_cast<Elf64_Addr>(&in6addr_loopback)},
    {"inet_addr", reinterpret_cast<Elf64_Addr>(&inet_addr)},
    {"inet_aton", reinterpret_cast<Elf64_Addr>(&inet_aton)},
    {"inet_nsap_ntoa", reinterpret_cast<Elf64_Addr>(&inet_nsap_ntoa)},
    {"inet_ntoa", reinterpret_cast<Elf64_Addr>(&inet_ntoa)},
    {"inet_ntop", reinterpret_cast<Elf64_Addr>(&inet_ntop)},
    {"inet_pton", reinterpret_cast<Elf64_Addr>(&inet_pton)},
    {"initgroups", reinterpret_cast<Elf64_Addr>(&initgroups)},
    {"innetgr", reinterpret_cast<Elf64_Addr>(&innetgr)},
    {"inotify_add_watch", reinterpret_cast<Elf64_Addr>(&inotify_add_watch)},
    {"inotify_init", reinterpret_cast<Elf64_Addr>(&inotify_init)},
    {"inotify_init1", reinterpret_cast<Elf64_Addr>(&inotify_init1)},
    {"inotify_rm_watch", reinterpret_cast<Elf64_Addr>(&inotify_rm_watch)},
    {"ioctl", reinterpret_cast<Elf64_Addr>(&ioctl)},
    {"iopl", reinterpret_cast<Elf64_Addr>(&iopl)},
    {"isalnum", reinterpret_cast<Elf64_Addr>(&isalnum)},
    {"isalpha", reinterpret_cast<Elf64_Addr>(&isalpha)},
    {"isatty", reinterpret_cast<Elf64_Addr>(&isatty)},
    {"isblank", reinterpret_cast<Elf64_Addr>(&isblank)},
    {"iscntrl", reinterpret_cast<Elf64_Addr>(&iscntrl)},
    {"isdigit", reinterpret_cast<Elf64_Addr>(&isdigit)},
    {"isgraph", reinterpret_cast<Elf64_Addr>(&isgraph)},
    {"islower", reinterpret_cast<Elf64_Addr>(&islower)},
    {"isprint", reinterpret_cast<Elf64_Addr>(&isprint)},
    {"ispunct", reinterpret_cast<Elf64_Addr>(&ispunct)},
    {"isspace", reinterpret_cast<Elf64_Addr>(&isspace)},
    {"isupper", reinterpret_cast<Elf64_Addr>(&isupper)},
    {"iswalnum", reinterpret_cast<Elf64_Addr>(&iswalnum)},
    {"iswalpha", reinterpret_cast<Elf64_Addr>(&iswalpha)},
    {"iswcntrl", reinterpret_cast<Elf64_Addr>(&iscntrl)},
    {"iswctype", reinterpret_cast<Elf64_Addr>(&iswctype)},
    {"iswdigit", reinterpret_cast<Elf64_Addr>(&iswdigit)},
    {"iswgraph", reinterpret_cast<Elf64_Addr>(&iswgraph)},
    {"iswlower", reinterpret_cast<Elf64_Addr>(&iswlower)},
    {"iswprint", reinterpret_cast<Elf64_Addr>(&isprint)},
    {"iswspace", reinterpret_cast<Elf64_Addr>(&iswspace)},
    {"iswupper", reinterpret_cast<Elf64_Addr>(&iswupper)},
    {"isxdigit", reinterpret_cast<Elf64_Addr>(&isxdigit)},
    {"jrand48", reinterpret_cast<Elf64_Addr>(&jrand48)},
    {"kill", reinterpret_cast<Elf64_Addr>(&kill)},
    {"killpg", reinterpret_cast<Elf64_Addr>(&killpg)},
    {"klogctl", reinterpret_cast<Elf64_Addr>(&klogctl)},
    {"l64a", reinterpret_cast<Elf64_Addr>(&l64a)},
    {"lchmod", reinterpret_cast<Elf64_Addr>(&lchmod)},
    {"lchown", reinterpret_cast<Elf64_Addr>(&lchown)},
    {"lckpwdf", reinterpret_cast<Elf64_Addr>(&lckpwdf)},
    {"ldexp", reinterpret_cast<Elf64_Addr>(ldexp_c)},
    {"ldexpl", reinterpret_cast<Elf64_Addr>(&ldexpl)},
    {"lgetxattr", reinterpret_cast<Elf64_Addr>(&lgetxattr)},
    {"link", reinterpret_cast<Elf64_Addr>(&link)},
    {"linkat", reinterpret_cast<Elf64_Addr>(&linkat)},
    {"listen", reinterpret_cast<Elf64_Addr>(&listen)},
    {"listen", reinterpret_cast<Elf64_Addr>(&listen)},
    {"listxattr", reinterpret_cast<Elf64_Addr>(&listxattr)},
    {"llistxattr", reinterpret_cast<Elf64_Addr>(&llistxattr)},
    {"localeconv", reinterpret_cast<Elf64_Addr>(&localeconv)},
    {"localtime", reinterpret_cast<Elf64_Addr>(&localtime)},
    {"localtime_r", reinterpret_cast<Elf64_Addr>(&localtime_r)},
    {"lockf", reinterpret_cast<Elf64_Addr>(&lockf)},
    {"lockf64", reinterpret_cast<Elf64_Addr>(&lockf64)},
    {"lremovexattr", reinterpret_cast<Elf64_Addr>(&lremovexattr)},
    {"lsearch", reinterpret_cast<Elf64_Addr>(&lsearch)},
    {"lseek", reinterpret_cast<Elf64_Addr>(&lseek)},
    {"lseek", reinterpret_cast<Elf64_Addr>(&lseek)},
    {"lseek64", reinterpret_cast<Elf64_Addr>(&lseek64)},
    {"lsetxattr", reinterpret_cast<Elf64_Addr>(&lsetxattr)},
    {"lstat", reinterpret_cast<Elf64_Addr>(&lstat)},
    {"lstat64", reinterpret_cast<Elf64_Addr>(&lstat64)},
    {"lutimes", reinterpret_cast<Elf64_Addr>(&lutimes)},
    {"madvise", reinterpret_cast<Elf64_Addr>(&madvise)},
    {"makecontext", reinterpret_cast<Elf64_Addr>(&makecontext)},
    {"mallinfo", reinterpret_cast<Elf64_Addr>(&mallinfo)},
    {"mallinfo2", reinterpret_cast<Elf64_Addr>(&mallinfo2)},
    {"malloc", reinterpret_cast<Elf64_Addr>(&malloc)},
    {"malloc_trim", reinterpret_cast<Elf64_Addr>(&malloc_trim)},
    {"malloc_usable_size", reinterpret_cast<Elf64_Addr>(&malloc_usable_size)},
    {"mblen", reinterpret_cast<Elf64_Addr>(&mblen)},
    {"mbrtowc", reinterpret_cast<Elf64_Addr>(&mbrtowc)},
    {"mbsinit", reinterpret_cast<Elf64_Addr>(&mbsinit)},
    {"mbsnrtowcs", reinterpret_cast<Elf64_Addr>(&mbsnrtowcs)},
    {"mbsrtowcs", reinterpret_cast<Elf64_Addr>(&mbsrtowcs)},
    {"mbstowcs", reinterpret_cast<Elf64_Addr>(&mbstowcs)},
    {"mbtowc", reinterpret_cast<Elf64_Addr>(&mbtowc)},
    {"memccpy", reinterpret_cast<Elf64_Addr>(&memccpy)},
    {"memchr", reinterpret_cast<Elf64_Addr>(memchr_c)},
    {"memcmp", reinterpret_cast<Elf64_Addr>(&memcmp)},
    {"memcpy", reinterpret_cast<Elf64_Addr>(&memcpy)},
    {"memfd_create", reinterpret_cast<Elf64_Addr>(&memfd_create)},
    {"memmem", reinterpret_cast<Elf64_Addr>(&memmem)},
    {"memmove", reinterpret_cast<Elf64_Addr>(&memmove)},
    {"mempcpy", reinterpret_cast<Elf64_Addr>(&mempcpy)},
    {"memrchr", reinterpret_cast<Elf64_Addr>(&memrchr_c)},
    {"memset", reinterpret_cast<Elf64_Addr>(&memset)},
    {"mincore", reinterpret_cast<Elf64_Addr>(&mincore)},
    {"mkdir", reinterpret_cast<Elf64_Addr>(&mkdir)},
    {"mkdirat", reinterpret_cast<Elf64_Addr>(&mkdirat)},
    {"mkdtemp", reinterpret_cast<Elf64_Addr>(&mkdtemp)},
    {"mkfifo", reinterpret_cast<Elf64_Addr>(&mkfifo)},
    {"mkfifoat", reinterpret_cast<Elf64_Addr>(&mkfifoat)},
    {"mknod", reinterpret_cast<Elf64_Addr>(&mknod)},
    {"mknodat", reinterpret_cast<Elf64_Addr>(&mknodat)},
    {"mkostemp", reinterpret_cast<Elf64_Addr>(&mkostemp)},
    {"mkostemp64", reinterpret_cast<Elf64_Addr>(&mkostemp64)},
    {"mkstemp", reinterpret_cast<Elf64_Addr>(&mkstemp)},
    {"mkstemp64", reinterpret_cast<Elf64_Addr>(&mkstemp64)},
    {"mkstemp64", reinterpret_cast<Elf64_Addr>(&mkstemp64)},
    {"mkstemps", reinterpret_cast<Elf64_Addr>(&mkstemps)},
    {"mktime", reinterpret_cast<Elf64_Addr>(&mktime)},
    {"mlock", reinterpret_cast<Elf64_Addr>(&mlock)},
    {"mmap", reinterpret_cast<Elf64_Addr>(&mmap)},
    {"mmap64", reinterpret_cast<Elf64_Addr>(&mmap64)},
    {"modf", reinterpret_cast<Elf64_Addr>(&modf_c)},
    {"mount", reinterpret_cast<Elf64_Addr>(&mount)},
    {"mprotect", reinterpret_cast<Elf64_Addr>(&mprotect)},
    {"mq_getattr", reinterpret_cast<Elf64_Addr>(&mq_getattr)},
    {"mremap", reinterpret_cast<Elf64_Addr>(&mremap)},
    {"msgctl", reinterpret_cast<Elf64_Addr>(&msgctl)},
    {"msync", reinterpret_cast<Elf64_Addr>(&msync)},
    {"mtrace", reinterpret_cast<Elf64_Addr>(&mtrace)},
    {"munlock", reinterpret_cast<Elf64_Addr>(&munlock)},
    {"munmap", reinterpret_cast<Elf64_Addr>(&munmap)},
    {"name_to_handle_at", reinterpret_cast<Elf64_Addr>(&name_to_handle_at)},
    {"nanosleep", reinterpret_cast<Elf64_Addr>(&nanosleep)},
    {"newlocale", reinterpret_cast<Elf64_Addr>(&newlocale)},
    {"nftw64", reinterpret_cast<Elf64_Addr>(&nftw64)},
    {"nice", reinterpret_cast<Elf64_Addr>(&nice)},
    {"nl_langinfo", reinterpret_cast<Elf64_Addr>(&nl_langinfo)},
    {"ns_name_uncompress", reinterpret_cast<Elf64_Addr>(&ns_name_uncompress)},
    {"ntp_gettimex", reinterpret_cast<Elf64_Addr>(&ntp_gettimex)},
    {"obstack_free", reinterpret_cast<Elf64_Addr>(&obstack_free)},
    {"obstack_printf", reinterpret_cast<Elf64_Addr>(&obstack_printf)},
    {"obstack_vprintf", reinterpret_cast<Elf64_Addr>(&obstack_vprintf)},
    {"open", reinterpret_cast<Elf64_Addr>(&open)},
    {"open64", reinterpret_cast<Elf64_Addr>(&open64)},
    {"open_by_handle_at", reinterpret_cast<Elf64_Addr>(&open_by_handle_at)},
    {"open_memstream", reinterpret_cast<Elf64_Addr>(&open_memstream)},
    {"openat", reinterpret_cast<Elf64_Addr>(&openat)},
    {"openat64", reinterpret_cast<Elf64_Addr>(&openat64)},
    {"opendir", reinterpret_cast<Elf64_Addr>(&opendir)},
    {"openlog", reinterpret_cast<Elf64_Addr>(&openlog)},
    {"openpty", reinterpret_cast<Elf64_Addr>(&openpty)},
    {"optarg", reinterpret_cast<Elf64_Addr>(&optarg)},
    {"opterr", reinterpret_cast<Elf64_Addr>(&opterr)},
    {"optind", reinterpret_cast<Elf64_Addr>(&optind)},
    {"optopt", reinterpret_cast<Elf64_Addr>(&optopt)},
    {"parse_printf_format", reinterpret_cast<Elf64_Addr>(&parse_printf_format)},
    {"pathconf", reinterpret_cast<Elf64_Addr>(&pathconf)},
    {"pause", reinterpret_cast<Elf64_Addr>(&pause)},
    {"pclose", reinterpret_cast<Elf64_Addr>(&pclose)},
    {"perror", reinterpret_cast<Elf64_Addr>(&perror)},
    {"personality", reinterpret_cast<Elf64_Addr>(&personality)},
    {"pipe", reinterpret_cast<Elf64_Addr>(&pipe)},
    {"pipe2", reinterpret_cast<Elf64_Addr>(&pipe2)},
    {"poll", reinterpret_cast<Elf64_Addr>(&poll)},
    {"popen", reinterpret_cast<Elf64_Addr>(&popen)},
    {"posix_fadvise", reinterpret_cast<Elf64_Addr>(&posix_fadvise)},
    {"posix_fadvise64", reinterpret_cast<Elf64_Addr>(&posix_fadvise64)},
    {"posix_fallocate", reinterpret_cast<Elf64_Addr>(&posix_fallocate)},
    {"posix_fallocate64", reinterpret_cast<Elf64_Addr>(&posix_fallocate64)},
    {"posix_madvise", reinterpret_cast<Elf64_Addr>(&posix_madvise)},
    {"posix_memalign", reinterpret_cast<Elf64_Addr>(&posix_memalign)},
    {"posix_openpt", reinterpret_cast<Elf64_Addr>(&posix_openpt)},
    {"posix_spawn", reinterpret_cast<Elf64_Addr>(&posix_spawn)},
    {"posix_spawn_file_actions_addclose", reinterpret_cast<Elf64_Addr>(&posix_spawn_file_actions_addclose)},
    {"posix_spawn_file_actions_adddup2", reinterpret_cast<Elf64_Addr>(&posix_spawn_file_actions_adddup2)},
    {"posix_spawn_file_actions_addopen", reinterpret_cast<Elf64_Addr>(&posix_spawn_file_actions_addopen)},
    {"posix_spawn_file_actions_destroy", reinterpret_cast<Elf64_Addr>(&posix_spawn_file_actions_destroy)},
    {"posix_spawn_file_actions_init", reinterpret_cast<Elf64_Addr>(&posix_spawn_file_actions_init)},
    {"posix_spawnattr_destroy", reinterpret_cast<Elf64_Addr>(&posix_spawnattr_destroy)},
    {"posix_spawnattr_init", reinterpret_cast<Elf64_Addr>(&posix_spawnattr_init)},
    {"posix_spawnattr_setflags", reinterpret_cast<Elf64_Addr>(&posix_spawnattr_setflags)},
    {"posix_spawnattr_setpgroup", reinterpret_cast<Elf64_Addr>(&posix_spawnattr_setpgroup)},
    {"posix_spawnattr_setschedparam", reinterpret_cast<Elf64_Addr>(&posix_spawnattr_setschedparam)},
    {"posix_spawnattr_setschedpolicy", reinterpret_cast<Elf64_Addr>(&posix_spawnattr_setschedpolicy)},
    {"posix_spawnattr_setsigdefault", reinterpret_cast<Elf64_Addr>(&posix_spawnattr_setsigdefault)},
    {"posix_spawnattr_setsigmask", reinterpret_cast<Elf64_Addr>(&posix_spawnattr_setsigmask)},
    {"posix_spawnp", reinterpret_cast<Elf64_Addr>(&posix_spawnp)},
    {"ppoll", reinterpret_cast<Elf64_Addr>(&ppoll)},
    {"prctl", reinterpret_cast<Elf64_Addr>(&prctl)},
    {"pread", reinterpret_cast<Elf64_Addr>(&pread)},
    {"pread64", reinterpret_cast<Elf64_Addr>(&pread64)},
    {"preadv64v2", reinterpret_cast<Elf64_Addr>(&preadv64v2)},
    {"printf", reinterpret_cast<Elf64_Addr>(&printf)},
    {"process_vm_readv", reinterpret_cast<Elf64_Addr>(&process_vm_readv)},
    {"process_vm_writev", reinterpret_cast<Elf64_Addr>(&process_vm_writev)},
    {"program_invocation_name", reinterpret_cast<Elf64_Addr>(&program_invocation_name)},
    {"program_invocation_short_name", reinterpret_cast<Elf64_Addr>(&program_invocation_short_name)},
    {"pselect", reinterpret_cast<Elf64_Addr>(&pselect)},
    {"pthread_getattr_np", reinterpret_cast<Elf64_Addr>(&pthread_getattr_np)},
    {"pthread_attr_getguardsize", reinterpret_cast<Elf64_Addr>(&pthread_attr_getguardsize)},
    {"__fxstat64", reinterpret_cast<Elf64_Addr>(&fstat64)},
    {"pthread_attr_getstack", reinterpret_cast<Elf64_Addr>(&pthread_attr_getstack)},
    {"bcmp", reinterpret_cast<Elf64_Addr>(&bcmp)},
    {"__lxstat64", reinterpret_cast<Elf64_Addr>(&lstat64)},
    {"__xstat64", reinterpret_cast<Elf64_Addr>(&stat64)},
    {"__fxstatat64", reinterpret_cast<Elf64_Addr>(&fstatat64)},
    // {"__libc_fatal", reinterpret_cast<Elf64_Addr>(&__libc_fatal)},
    // {"__libc_unwind_link_get", reinterpret_cast<Elf64_Addr>(&__libc_unwind_link_get)},
    {"pthread_attr_destroy", reinterpret_cast<Elf64_Addr>(&pthread_attr_destroy)},
    {"pthread_attr_getstacksize", reinterpret_cast<Elf64_Addr>(&pthread_attr_getstacksize)},
    {"pthread_attr_init", reinterpret_cast<Elf64_Addr>(&pthread_attr_init)},
    {"pthread_attr_setdetachstate", reinterpret_cast<Elf64_Addr>(&pthread_attr_setdetachstate)},
    {"pthread_attr_setguardsize", reinterpret_cast<Elf64_Addr>(&pthread_attr_setguardsize)},
    {"pthread_attr_setinheritsched", reinterpret_cast<Elf64_Addr>(&pthread_attr_setinheritsched)},
    {"pthread_attr_setscope", reinterpret_cast<Elf64_Addr>(&pthread_attr_setscope)},
    {"pthread_attr_setstacksize", reinterpret_cast<Elf64_Addr>(&pthread_attr_setstacksize)},
    {"pthread_barrier_destroy", reinterpret_cast<Elf64_Addr>(&pthread_barrier_destroy)},
    {"pthread_barrier_init", reinterpret_cast<Elf64_Addr>(&pthread_barrier_init)},
    {"pthread_barrier_wait", reinterpret_cast<Elf64_Addr>(&pthread_barrier_wait)},
    {"pthread_cancel", reinterpret_cast<Elf64_Addr>(&pthread_cancel)},
    {"pthread_cond_broadcast", reinterpret_cast<Elf64_Addr>(&pthread_cond_broadcast)},
    {"pthread_cond_broadcast", reinterpret_cast<Elf64_Addr>(&pthread_cond_broadcast)},
    {"pthread_cond_destroy", reinterpret_cast<Elf64_Addr>(&pthread_cond_destroy)},
    {"pthread_cond_destroy", reinterpret_cast<Elf64_Addr>(&pthread_cond_destroy)},
    {"pthread_cond_init", reinterpret_cast<Elf64_Addr>(&pthread_cond_init)},
    {"pthread_cond_init", reinterpret_cast<Elf64_Addr>(&pthread_cond_init)},
    {"pthread_cond_signal", reinterpret_cast<Elf64_Addr>(&pthread_cond_signal)},
    {"pthread_cond_signal", reinterpret_cast<Elf64_Addr>(&pthread_cond_signal)},
    {"pthread_cond_timedwait", reinterpret_cast<Elf64_Addr>(&pthread_cond_timedwait)},
    {"pthread_cond_wait", reinterpret_cast<Elf64_Addr>(&pthread_cond_wait)},
    {"pthread_cond_wait", reinterpret_cast<Elf64_Addr>(&pthread_cond_wait)},
    {"pthread_condattr_destroy", reinterpret_cast<Elf64_Addr>(&pthread_condattr_destroy)},
    {"pthread_condattr_init", reinterpret_cast<Elf64_Addr>(&pthread_condattr_init)},
    {"pthread_condattr_setclock", reinterpret_cast<Elf64_Addr>(&pthread_condattr_setclock)},
    {"pthread_condattr_setpshared", reinterpret_cast<Elf64_Addr>(&pthread_condattr_setpshared)},
    {"pthread_create", reinterpret_cast<Elf64_Addr>(&pthread_create)},
    {"pthread_detach", reinterpret_cast<Elf64_Addr>(&pthread_detach)},
    {"pthread_equal", reinterpret_cast<Elf64_Addr>(&pthread_equal)},
    {"pthread_exit", reinterpret_cast<Elf64_Addr>(&pthread_exit)},
    {"pthread_getconcurrency", reinterpret_cast<Elf64_Addr>(&pthread_getconcurrency)},
    {"pthread_getcpuclockid", reinterpret_cast<Elf64_Addr>(&pthread_getcpuclockid)},
    {"pthread_getname_np", reinterpret_cast<Elf64_Addr>(&pthread_getname_np)},
    {"pthread_getspecific", reinterpret_cast<Elf64_Addr>(&pthread_getspecific)},
    {"pthread_getspecific", reinterpret_cast<Elf64_Addr>(&pthread_getspecific)},
    {"pthread_getspecific", reinterpret_cast<Elf64_Addr>(&pthread_getspecific)},
    {"pthread_join", reinterpret_cast<Elf64_Addr>(&pthread_join)},
    {"pthread_join", reinterpret_cast<Elf64_Addr>(&pthread_join)},
    {"pthread_join", reinterpret_cast<Elf64_Addr>(&pthread_join)},
    {"pthread_join", reinterpret_cast<Elf64_Addr>(&pthread_join)},
    {"pthread_key_create", reinterpret_cast<Elf64_Addr>(&pthread_key_create)},
    {"pthread_key_delete", reinterpret_cast<Elf64_Addr>(&pthread_key_delete)},
    {"pthread_kill", reinterpret_cast<Elf64_Addr>(&pthread_kill)},
    {"pthread_mutex_consistent", reinterpret_cast<Elf64_Addr>(&pthread_mutex_consistent)},
    {"pthread_mutex_consistent", reinterpret_cast<Elf64_Addr>(&pthread_mutex_consistent)},
    {"pthread_mutex_consistent", reinterpret_cast<Elf64_Addr>(&pthread_mutex_consistent)},
    {"pthread_mutex_consistent", reinterpret_cast<Elf64_Addr>(&pthread_mutex_consistent)},
    {"pthread_mutex_destroy", reinterpret_cast<Elf64_Addr>(&pthread_mutex_destroy)},
    {"pthread_mutex_init", reinterpret_cast<Elf64_Addr>(&pthread_mutex_init)},
    {"pthread_mutex_lock", reinterpret_cast<Elf64_Addr>(&pthread_mutex_lock)},
    {"pthread_mutex_timedlock", reinterpret_cast<Elf64_Addr>(&pthread_mutex_timedlock)},
    {"pthread_mutex_trylock", reinterpret_cast<Elf64_Addr>(&pthread_mutex_trylock)},
    {"pthread_mutex_unlock", reinterpret_cast<Elf64_Addr>(&pthread_mutex_unlock)},
    {"pthread_mutexattr_destroy", reinterpret_cast<Elf64_Addr>(&pthread_mutexattr_destroy)},
    {"pthread_mutexattr_init", reinterpret_cast<Elf64_Addr>(&pthread_mutexattr_init)},
    {"pthread_mutexattr_setpshared", reinterpret_cast<Elf64_Addr>(&pthread_mutexattr_setpshared)},
    {"pthread_mutexattr_setrobust", reinterpret_cast<Elf64_Addr>(&pthread_mutexattr_setrobust)},
    {"pthread_mutexattr_setrobust", reinterpret_cast<Elf64_Addr>(&pthread_mutexattr_setrobust)},
    {"pthread_mutexattr_setrobust", reinterpret_cast<Elf64_Addr>(&pthread_mutexattr_setrobust)},
    {"pthread_mutexattr_setrobust", reinterpret_cast<Elf64_Addr>(&pthread_mutexattr_setrobust)},
    {"pthread_mutexattr_settype", reinterpret_cast<Elf64_Addr>(&pthread_mutexattr_settype)},
    {"pthread_once", reinterpret_cast<Elf64_Addr>(&pthread_once)},
    {"pthread_rwlock_destroy", reinterpret_cast<Elf64_Addr>(&pthread_rwlock_destroy)},
    {"pthread_rwlock_init", reinterpret_cast<Elf64_Addr>(&pthread_rwlock_init)},
    {"pthread_rwlock_rdlock", reinterpret_cast<Elf64_Addr>(&pthread_rwlock_rdlock)},
    {"pthread_rwlock_timedrdlock", reinterpret_cast<Elf64_Addr>(&pthread_rwlock_timedrdlock)},
    {"pthread_rwlock_timedwrlock", reinterpret_cast<Elf64_Addr>(&pthread_rwlock_timedwrlock)},
    {"pthread_rwlock_tryrdlock", reinterpret_cast<Elf64_Addr>(&pthread_rwlock_tryrdlock)},
    {"pthread_rwlock_trywrlock", reinterpret_cast<Elf64_Addr>(&pthread_rwlock_trywrlock)},
    {"pthread_rwlock_unlock", reinterpret_cast<Elf64_Addr>(&pthread_rwlock_unlock)},
    {"pthread_rwlock_wrlock", reinterpret_cast<Elf64_Addr>(&pthread_rwlock_wrlock)},
    {"pthread_rwlockattr_destroy", reinterpret_cast<Elf64_Addr>(&pthread_rwlockattr_destroy)},
    {"pthread_rwlockattr_init", reinterpret_cast<Elf64_Addr>(&pthread_rwlockattr_init)},
    {"pthread_rwlockattr_setkind_np", reinterpret_cast<Elf64_Addr>(&pthread_rwlockattr_setkind_np)},
    {"pthread_rwlockattr_setpshared", reinterpret_cast<Elf64_Addr>(&pthread_rwlockattr_setpshared)},
    {"pthread_self", reinterpret_cast<Elf64_Addr>(&pthread_self)},
    {"pthread_setcancelstate", reinterpret_cast<Elf64_Addr>(&pthread_setcancelstate)},
    {"pthread_setconcurrency", reinterpret_cast<Elf64_Addr>(&pthread_setconcurrency)},
    {"pthread_setname_np", reinterpret_cast<Elf64_Addr>(&pthread_setname_np)},
    {"pthread_setspecific", reinterpret_cast<Elf64_Addr>(&pthread_setspecific)},
    {"pthread_sigmask", reinterpret_cast<Elf64_Addr>(&pthread_sigmask)},
    {"pthread_tryjoin_np", reinterpret_cast<Elf64_Addr>(&pthread_tryjoin_np)},
    {"ptrace", reinterpret_cast<Elf64_Addr>(&ptrace)},
    {"ptsname", reinterpret_cast<Elf64_Addr>(&ptsname)},
    {"ptsname_r", reinterpret_cast<Elf64_Addr>(&ptsname_r)},
    {"putc", reinterpret_cast<Elf64_Addr>(&putc)},
    {"putchar", reinterpret_cast<Elf64_Addr>(&putchar)},
    {"putenv", reinterpret_cast<Elf64_Addr>(&putenv)},
    {"putgrent", reinterpret_cast<Elf64_Addr>(&putgrent)},
    {"putpwent", reinterpret_cast<Elf64_Addr>(&putpwent)},
    {"puts", reinterpret_cast<Elf64_Addr>(&puts)},
    {"putsgent", reinterpret_cast<Elf64_Addr>(&putsgent)},
    {"putspent", reinterpret_cast<Elf64_Addr>(&putspent)},
    {"pututline", reinterpret_cast<Elf64_Addr>(&pututline)},
    {"pututxline", reinterpret_cast<Elf64_Addr>(&pututxline)},
    {"putwc", reinterpret_cast<Elf64_Addr>(&putwc)},
    {"putwchar", reinterpret_cast<Elf64_Addr>(&putwchar)},
    {"pwrite", reinterpret_cast<Elf64_Addr>(&pwrite)},
    {"pwrite64", reinterpret_cast<Elf64_Addr>(&pwrite64)},
    {"pwritev64v2", reinterpret_cast<Elf64_Addr>(&pwritev64v2)},
    {"qsort", reinterpret_cast<Elf64_Addr>(&qsort)},
    {"qsort_r", reinterpret_cast<Elf64_Addr>(&qsort_r)},
    {"raise", reinterpret_cast<Elf64_Addr>(&raise)},
    {"rand", reinterpret_cast<Elf64_Addr>(&rand)},
    {"rand_r", reinterpret_cast<Elf64_Addr>(&rand_r)},
    {"random", reinterpret_cast<Elf64_Addr>(&random)},
    {"rawmemchr", reinterpret_cast<Elf64_Addr>(rawmemchr_c)},
    {"re_compile_pattern", reinterpret_cast<Elf64_Addr>(&re_compile_pattern)},
    {"re_match", reinterpret_cast<Elf64_Addr>(&re_match)},
    {"re_search", reinterpret_cast<Elf64_Addr>(&re_search)},
    {"re_set_syntax", reinterpret_cast<Elf64_Addr>(&re_set_syntax)},
    {"read", reinterpret_cast<Elf64_Addr>(&read)},
    {"readdir", reinterpret_cast<Elf64_Addr>(&readdir)},
    {"readdir64", reinterpret_cast<Elf64_Addr>(&readdir64)},
    {"readlink", reinterpret_cast<Elf64_Addr>(&readlink)},
    {"readlinkat", reinterpret_cast<Elf64_Addr>(&readlinkat)},
    {"readv", reinterpret_cast<Elf64_Addr>(&readv)},
    {"realloc", reinterpret_cast<Elf64_Addr>(&realloc)},
    {"reallocarray", reinterpret_cast<Elf64_Addr>(&reallocarray)},
    {"realpath", reinterpret_cast<Elf64_Addr>(&realpath)},
    {"recv", reinterpret_cast<Elf64_Addr>(&recv)},
    {"recvfrom", reinterpret_cast<Elf64_Addr>(&recvfrom)},
    {"recvmmsg", reinterpret_cast<Elf64_Addr>(&recvmmsg)},
    {"recvmsg", reinterpret_cast<Elf64_Addr>(&recvmsg)},
    {"regcomp", reinterpret_cast<Elf64_Addr>(&regcomp)},
    {"regerror", reinterpret_cast<Elf64_Addr>(&regerror)},
    {"regexec", reinterpret_cast<Elf64_Addr>(&regexec)},
    {"regfree", reinterpret_cast<Elf64_Addr>(&regfree)},
    {"remove", reinterpret_cast<Elf64_Addr>(&remove)},
    {"removexattr", reinterpret_cast<Elf64_Addr>(&removexattr)},
    {"rename", reinterpret_cast<Elf64_Addr>(&rename)},
    {"renameat", reinterpret_cast<Elf64_Addr>(&renameat)},
    {"renameat2", reinterpret_cast<Elf64_Addr>(&renameat2)},
    {"res_dnok", reinterpret_cast<Elf64_Addr>(&res_dnok)},
    {"res_hnok", reinterpret_cast<Elf64_Addr>(&res_hnok)},
    {"res_nquery", reinterpret_cast<Elf64_Addr>(&res_nquery)},
    {"res_nsearch", reinterpret_cast<Elf64_Addr>(&res_nsearch)},
    {"res_query", reinterpret_cast<Elf64_Addr>(&res_query)},
    {"rewind", reinterpret_cast<Elf64_Addr>(&rewind)},
    {"rewinddir", reinterpret_cast<Elf64_Addr>(&rewinddir)},
    {"rindex", reinterpret_cast<Elf64_Addr>(&rindex_c)},
    {"rmdir", reinterpret_cast<Elf64_Addr>(&rmdir)},
    {"rpmatch", reinterpret_cast<Elf64_Addr>(&rpmatch)},
    {"ruserok", reinterpret_cast<Elf64_Addr>(&ruserok)},
    {"sbrk", reinterpret_cast<Elf64_Addr>(&sbrk)},
    {"scandir", reinterpret_cast<Elf64_Addr>(&scandir)},
    {"scandir64", reinterpret_cast<Elf64_Addr>(&scandir64)},
    {"scandirat", reinterpret_cast<Elf64_Addr>(&scandirat)},
    {"sched_get_priority_max", reinterpret_cast<Elf64_Addr>(&sched_get_priority_max)},
    {"sched_get_priority_min", reinterpret_cast<Elf64_Addr>(&sched_get_priority_min)},
    {"sched_getaffinity", reinterpret_cast<Elf64_Addr>(&sched_getaffinity)},
    {"sched_getparam", reinterpret_cast<Elf64_Addr>(&sched_getparam)},
    {"sched_getscheduler", reinterpret_cast<Elf64_Addr>(&sched_getscheduler)},
    {"sched_rr_get_interval", reinterpret_cast<Elf64_Addr>(&sched_rr_get_interval)},
    {"sched_setaffinity", reinterpret_cast<Elf64_Addr>(&sched_setaffinity)},
    {"sched_setparam", reinterpret_cast<Elf64_Addr>(&sched_setparam)},
    {"sched_setscheduler", reinterpret_cast<Elf64_Addr>(&sched_setscheduler)},
    {"sched_yield", reinterpret_cast<Elf64_Addr>(&sched_yield)},
    {"secure_getenv", reinterpret_cast<Elf64_Addr>(&secure_getenv)},
    {"select", reinterpret_cast<Elf64_Addr>(&select)},
    {"sem_clockwait", reinterpret_cast<Elf64_Addr>(&sem_clockwait)},
    {"sem_destroy", reinterpret_cast<Elf64_Addr>(&sem_destroy)},
    {"sem_init", reinterpret_cast<Elf64_Addr>(&sem_init)},
    {"sem_post", reinterpret_cast<Elf64_Addr>(&sem_post)},
    {"sem_trywait", reinterpret_cast<Elf64_Addr>(&sem_trywait)},
    {"sem_wait", reinterpret_cast<Elf64_Addr>(&sem_wait)},
    {"semctl", reinterpret_cast<Elf64_Addr>(&semctl)},
    {"send", reinterpret_cast<Elf64_Addr>(&send)},
    {"sendfile", reinterpret_cast<Elf64_Addr>(&sendfile)},
    {"sendfile64", reinterpret_cast<Elf64_Addr>(&sendfile64)},
    {"sendmmsg", reinterpret_cast<Elf64_Addr>(&sendmmsg)},
    {"sendmsg", reinterpret_cast<Elf64_Addr>(&sendmsg)},
    {"sendto", reinterpret_cast<Elf64_Addr>(&sendto)},
    {"setaliasent", reinterpret_cast<Elf64_Addr>(&setaliasent)},
    {"setbuf", reinterpret_cast<Elf64_Addr>(&setbuf)},
    {"setbuf", reinterpret_cast<Elf64_Addr>(&setbuf)},
    {"setbuffer", reinterpret_cast<Elf64_Addr>(&setbuffer)},
    {"setcontext", reinterpret_cast<Elf64_Addr>(&setcontext)},
    {"setdomainname", reinterpret_cast<Elf64_Addr>(&setdomainname)},
    {"setegid", reinterpret_cast<Elf64_Addr>(&setegid)},
    {"setenv", reinterpret_cast<Elf64_Addr>(&setenv)},
    {"seteuid", reinterpret_cast<Elf64_Addr>(&seteuid)},
    {"setfsgid", reinterpret_cast<Elf64_Addr>(&setfsgid)},
    {"setfsuid", reinterpret_cast<Elf64_Addr>(&setfsuid)},
    {"setgid", reinterpret_cast<Elf64_Addr>(&setgid)},
    {"setgrent", reinterpret_cast<Elf64_Addr>(&setgrent)},
    {"setgroups", reinterpret_cast<Elf64_Addr>(&setgroups)},
    {"sethostent", reinterpret_cast<Elf64_Addr>(&sethostent)},
    {"sethostname", reinterpret_cast<Elf64_Addr>(&sethostname)},
    {"setitimer", reinterpret_cast<Elf64_Addr>(&setitimer)},
    {"setlinebuf", reinterpret_cast<Elf64_Addr>(&setlinebuf)},
    {"setlocale", reinterpret_cast<Elf64_Addr>(&setlocale)},
    {"setlogmask", reinterpret_cast<Elf64_Addr>(&setlogmask)},
    {"setmntent", reinterpret_cast<Elf64_Addr>(&setmntent)},
    {"setnetent", reinterpret_cast<Elf64_Addr>(&setnetent)},
    {"setnetgrent", reinterpret_cast<Elf64_Addr>(&setnetgrent)},
    {"setns", reinterpret_cast<Elf64_Addr>(&setns)},
    {"setpgid", reinterpret_cast<Elf64_Addr>(&setpgid)},
    {"setpgrp", reinterpret_cast<Elf64_Addr>(&setpgrp)},
    {"setpriority", reinterpret_cast<Elf64_Addr>(&setpriority)},
    {"setprotoent", reinterpret_cast<Elf64_Addr>(&setprotoent)},
    {"setpwent", reinterpret_cast<Elf64_Addr>(&setpwent)},
    {"setregid", reinterpret_cast<Elf64_Addr>(&setregid)},
    {"setresgid", reinterpret_cast<Elf64_Addr>(&setresgid)},
    {"setresuid", reinterpret_cast<Elf64_Addr>(&setresuid)},
    {"setreuid", reinterpret_cast<Elf64_Addr>(&setreuid)},
    {"setrlimit", reinterpret_cast<Elf64_Addr>(&setrlimit)},
    {"setrlimit64", reinterpret_cast<Elf64_Addr>(&setrlimit64)},
    {"setrpcent", reinterpret_cast<Elf64_Addr>(&setrpcent)},
    {"setservent", reinterpret_cast<Elf64_Addr>(&setservent)},
    {"setsgent", reinterpret_cast<Elf64_Addr>(&setsgent)},
    {"setsid", reinterpret_cast<Elf64_Addr>(&setsid)},
    {"setsid", reinterpret_cast<Elf64_Addr>(&setsid)},
    {"setsockopt", reinterpret_cast<Elf64_Addr>(&setsockopt)},
    {"setspent", reinterpret_cast<Elf64_Addr>(&setspent)},
    {"settimeofday", reinterpret_cast<Elf64_Addr>(&settimeofday)},
    {"setuid", reinterpret_cast<Elf64_Addr>(&setuid)},
    {"setusershell", reinterpret_cast<Elf64_Addr>(&setusershell)},
    {"setutent", reinterpret_cast<Elf64_Addr>(&setutent)},
    {"setutxent", reinterpret_cast<Elf64_Addr>(&setutxent)},
    {"setvbuf", reinterpret_cast<Elf64_Addr>(&setvbuf)},
    {"setxattr", reinterpret_cast<Elf64_Addr>(&setxattr)},
    {"sgetspent", reinterpret_cast<Elf64_Addr>(&sgetspent)},
    {"shmat", reinterpret_cast<Elf64_Addr>(&shmat)},
    {"shmctl", reinterpret_cast<Elf64_Addr>(&shmctl)},
    {"shmdt", reinterpret_cast<Elf64_Addr>(&shmdt)},
    {"shmget", reinterpret_cast<Elf64_Addr>(&shmget)},
    {"shutdown", reinterpret_cast<Elf64_Addr>(&shutdown)},
    {"sigabbrev_np", reinterpret_cast<Elf64_Addr>(&sigabbrev_np)},
    {"sigaction", reinterpret_cast<Elf64_Addr>(&sigaction)},
    {"sigaddset", reinterpret_cast<Elf64_Addr>(&sigaddset)},
    {"sigaltstack", reinterpret_cast<Elf64_Addr>(&sigaltstack)},
    {"sigdelset", reinterpret_cast<Elf64_Addr>(&sigdelset)},
    {"sigemptyset", reinterpret_cast<Elf64_Addr>(&sigemptyset)},
    {"sigfillset", reinterpret_cast<Elf64_Addr>(&sigfillset)},
    {"sigfillset", reinterpret_cast<Elf64_Addr>(&sigfillset)},
    {"sigfillset", reinterpret_cast<Elf64_Addr>(&sigfillset)},
    {"sigisemptyset", reinterpret_cast<Elf64_Addr>(&sigisemptyset)},
    {"sigismember", reinterpret_cast<Elf64_Addr>(&sigismember)},
    {"signal", reinterpret_cast<Elf64_Addr>(&signal)},
    {"signalfd", reinterpret_cast<Elf64_Addr>(&signalfd)},
    {"sigpending", reinterpret_cast<Elf64_Addr>(&sigpending)},
    {"sigprocmask", reinterpret_cast<Elf64_Addr>(&sigprocmask)},
    {"sigqueue", reinterpret_cast<Elf64_Addr>(&sigqueue)},
    {"sigset", reinterpret_cast<Elf64_Addr>(&sigset)},
    {"sigsuspend", reinterpret_cast<Elf64_Addr>(&sigsuspend)},
    {"sigtimedwait", reinterpret_cast<Elf64_Addr>(&sigtimedwait)},
    {"sigwait", reinterpret_cast<Elf64_Addr>(&sigwait)},
    {"sigwaitinfo", reinterpret_cast<Elf64_Addr>(&sigwaitinfo)},
    {"sleep", reinterpret_cast<Elf64_Addr>(&sleep)},
    {"snprintf", reinterpret_cast<Elf64_Addr>(&snprintf)},
    {"socket", reinterpret_cast<Elf64_Addr>(&socket)},
    {"socketpair", reinterpret_cast<Elf64_Addr>(&socketpair)},
    {"splice", reinterpret_cast<Elf64_Addr>(&splice)},
    {"sprintf", reinterpret_cast<Elf64_Addr>(&sprintf)},
    {"sprintf", reinterpret_cast<Elf64_Addr>(&sprintf)},
    {"srand", reinterpret_cast<Elf64_Addr>(&srand)},
    {"srandom", reinterpret_cast<Elf64_Addr>(&srandom)},
    {"sscanf", reinterpret_cast<Elf64_Addr>(&sscanf)},
    {"stat", reinterpret_cast<Elf64_Addr>(&stat)},
    {"stat64", reinterpret_cast<Elf64_Addr>(&stat64)},
    {"statfs", reinterpret_cast<Elf64_Addr>(&statfs)},
    {"statfs", reinterpret_cast<Elf64_Addr>(&statfs)},
    {"statfs64", reinterpret_cast<Elf64_Addr>(&statfs64)},
    {"statvfs", reinterpret_cast<Elf64_Addr>(&statvfs)},
    {"statvfs64", reinterpret_cast<Elf64_Addr>(&statvfs64)},
    {"statx", reinterpret_cast<Elf64_Addr>(&statx)},
    {"stderr", reinterpret_cast<Elf64_Addr>(&stderr)},
    {"stdin", reinterpret_cast<Elf64_Addr>(&stdin)},
    {"stdout", reinterpret_cast<Elf64_Addr>(&stdout)},
    {"stpcpy", reinterpret_cast<Elf64_Addr>(&stpcpy)},
    {"stpncpy", reinterpret_cast<Elf64_Addr>(&stpncpy)},
    {"strcasecmp", reinterpret_cast<Elf64_Addr>(&strcasecmp)},
    {"strcasestr", reinterpret_cast<Elf64_Addr>(&strcasestr_c)},
    {"strcat", reinterpret_cast<Elf64_Addr>(&strcat)},
    {"strchr", reinterpret_cast<Elf64_Addr>(strchr_c)},
    {"strchrnul", reinterpret_cast<Elf64_Addr>(strchrnul_c)},
    {"strcmp", reinterpret_cast<Elf64_Addr>(&strcmp)},
    {"strcoll", reinterpret_cast<Elf64_Addr>(&strcoll)},
    {"strcpy", reinterpret_cast<Elf64_Addr>(&strcpy)},
    {"strcspn", reinterpret_cast<Elf64_Addr>(&strcspn)},
    {"strdup", reinterpret_cast<Elf64_Addr>(&strdup)},
    {"strdup", reinterpret_cast<Elf64_Addr>(&strdup)},
    {"strerror", reinterpret_cast<Elf64_Addr>(&strerror)},
    {"strerror_l", reinterpret_cast<Elf64_Addr>(&strerror_l)},
    {"strerror_r", reinterpret_cast<Elf64_Addr>(&strerror_r)},
    {"strftime", reinterpret_cast<Elf64_Addr>(&strftime)},
    {"strlen", reinterpret_cast<Elf64_Addr>(&strlen)},
    {"strncasecmp", reinterpret_cast<Elf64_Addr>(&strncasecmp)},
    {"strncat", reinterpret_cast<Elf64_Addr>(&strncat)},
    {"strncmp", reinterpret_cast<Elf64_Addr>(&strncmp)},
    {"strncpy", reinterpret_cast<Elf64_Addr>(&strncpy)},
    {"strndup", reinterpret_cast<Elf64_Addr>(&strndup)},
    {"strnlen", reinterpret_cast<Elf64_Addr>(&strnlen)},
    {"strpbrk", reinterpret_cast<Elf64_Addr>(strpbrk_c)},
    {"strptime", reinterpret_cast<Elf64_Addr>(&strptime)},
    {"strrchr", reinterpret_cast<Elf64_Addr>(strrchr_c)},
    {"strsep", reinterpret_cast<Elf64_Addr>(&strsep)},
    {"strsignal", reinterpret_cast<Elf64_Addr>(&strsignal)},
    {"strspn", reinterpret_cast<Elf64_Addr>(&strspn)},
    {"strstr", reinterpret_cast<Elf64_Addr>(strstr_c)},
    {"strtod", reinterpret_cast<Elf64_Addr>(&strtod)},
    {"strtod_l", reinterpret_cast<Elf64_Addr>(&strtod_l)},
    {"strtof", reinterpret_cast<Elf64_Addr>(&strtof)},
    {"strtoimax", reinterpret_cast<Elf64_Addr>(&strtoimax)},
    {"strtok", reinterpret_cast<Elf64_Addr>(&strtok)},
    {"strtok_r", reinterpret_cast<Elf64_Addr>(&strtok_r)},
    {"strtok_r", reinterpret_cast<Elf64_Addr>(&strtok_r)},
    {"strtol", reinterpret_cast<Elf64_Addr>(&strtol)},
    {"strtold", reinterpret_cast<Elf64_Addr>(&strtold)},
    {"strtold_l", reinterpret_cast<Elf64_Addr>(&strtold_l)},
    {"strtoll", reinterpret_cast<Elf64_Addr>(&strtoll)},
    {"strtoll_l", reinterpret_cast<Elf64_Addr>(&strtoll_l)},
    {"strtoul", reinterpret_cast<Elf64_Addr>(&strtoul)},
    {"strtoull", reinterpret_cast<Elf64_Addr>(&strtoull)},
    {"strtoull_l", reinterpret_cast<Elf64_Addr>(&strtoull_l)},
    {"strtoumax", reinterpret_cast<Elf64_Addr>(&strtoumax)},
    {"strverscmp", reinterpret_cast<Elf64_Addr>(&strverscmp)},
    {"strxfrm", reinterpret_cast<Elf64_Addr>(&strxfrm)},
    {"swapcontext", reinterpret_cast<Elf64_Addr>(&swapcontext)},
    {"symlink", reinterpret_cast<Elf64_Addr>(&symlink)},
    {"symlinkat", reinterpret_cast<Elf64_Addr>(&symlinkat)},
    {"sync", reinterpret_cast<Elf64_Addr>(&sync)},
    {"sync_file_range", reinterpret_cast<Elf64_Addr>(&sync_file_range)},
    {"syncfs", reinterpret_cast<Elf64_Addr>(&syncfs)},
    {"syscall", reinterpret_cast<Elf64_Addr>(&syscall)},
    {"sysconf", reinterpret_cast<Elf64_Addr>(&sysconf)},
    {"sysinfo", reinterpret_cast<Elf64_Addr>(&sysinfo)},
    {"system", reinterpret_cast<Elf64_Addr>(&system)},
    {"tcdrain", reinterpret_cast<Elf64_Addr>(&tcdrain)},
    {"tcflow", reinterpret_cast<Elf64_Addr>(&tcflow)},
    {"tcflush", reinterpret_cast<Elf64_Addr>(&tcflush)},
    {"tcflush", reinterpret_cast<Elf64_Addr>(&tcflush)},
    {"tcgetattr", reinterpret_cast<Elf64_Addr>(&tcgetattr)},
    {"tcgetpgrp", reinterpret_cast<Elf64_Addr>(&tcgetpgrp)},
    {"tcsetattr", reinterpret_cast<Elf64_Addr>(&tcsetattr)},
    {"tcsetpgrp", reinterpret_cast<Elf64_Addr>(&tcsetpgrp)},
    {"tdelete", reinterpret_cast<Elf64_Addr>(&tdelete)},
    {"tdestroy", reinterpret_cast<Elf64_Addr>(&tdestroy)},
    {"tempnam", reinterpret_cast<Elf64_Addr>(&tempnam)},
    {"textdomain", reinterpret_cast<Elf64_Addr>(&textdomain)},
    {"tfind", reinterpret_cast<Elf64_Addr>(&tfind)},
    {"time", reinterpret_cast<Elf64_Addr>(&time)},
    {"timegm", reinterpret_cast<Elf64_Addr>(&timegm)},
    {"timer_create", reinterpret_cast<Elf64_Addr>(&timer_create)},
    {"timer_delete", reinterpret_cast<Elf64_Addr>(&timer_delete)},
    {"timer_gettime", reinterpret_cast<Elf64_Addr>(&timer_gettime)},
    {"timer_settime", reinterpret_cast<Elf64_Addr>(&timer_settime)},
    {"timerfd_create", reinterpret_cast<Elf64_Addr>(&timerfd_create)},
    {"timerfd_settime", reinterpret_cast<Elf64_Addr>(&timerfd_settime)},
    {"times", reinterpret_cast<Elf64_Addr>(&times)},
    {"tmpfile", reinterpret_cast<Elf64_Addr>(&tmpfile)},
    {"tmpfile64", reinterpret_cast<Elf64_Addr>(&tmpfile64)},
    {"tolower", reinterpret_cast<Elf64_Addr>(&tolower)},
    {"toupper", reinterpret_cast<Elf64_Addr>(&toupper)},
    {"towlower", reinterpret_cast<Elf64_Addr>(&towlower)},
    {"towupper", reinterpret_cast<Elf64_Addr>(&towupper)},
    {"truncate", reinterpret_cast<Elf64_Addr>(&truncate)},
    {"truncate64", reinterpret_cast<Elf64_Addr>(&truncate64)},
    {"tsearch", reinterpret_cast<Elf64_Addr>(&tsearch)},
    {"ttyname", reinterpret_cast<Elf64_Addr>(&ttyname)},
    {"ttyname_r", reinterpret_cast<Elf64_Addr>(&ttyname_r)},
    {"twalk", reinterpret_cast<Elf64_Addr>(&twalk)},
    {"tzname", reinterpret_cast<Elf64_Addr>(&tzname)},
    {"tzset", reinterpret_cast<Elf64_Addr>(&tzset)},
    {"ulckpwdf", reinterpret_cast<Elf64_Addr>(&ulckpwdf)},
    {"umask", reinterpret_cast<Elf64_Addr>(&umask)},
    {"umount", reinterpret_cast<Elf64_Addr>(&umount)},
    {"umount2", reinterpret_cast<Elf64_Addr>(&umount2)},
    {"uname", reinterpret_cast<Elf64_Addr>(&uname)},
    {"uname", reinterpret_cast<Elf64_Addr>(&uname)},
    {"ungetc", reinterpret_cast<Elf64_Addr>(&ungetc)},
    {"ungetwc", reinterpret_cast<Elf64_Addr>(&ungetwc)},
    {"unlink", reinterpret_cast<Elf64_Addr>(&unlink)},
    {"unlinkat", reinterpret_cast<Elf64_Addr>(&unlinkat)},
    {"unlockpt", reinterpret_cast<Elf64_Addr>(&unlockpt)},
    {"unsetenv", reinterpret_cast<Elf64_Addr>(&unsetenv)},
    {"unshare", reinterpret_cast<Elf64_Addr>(&unshare)},
    {"updwtmpx", reinterpret_cast<Elf64_Addr>(&updwtmpx)},
    {"uselocale", reinterpret_cast<Elf64_Addr>(&uselocale)},
    {"usleep", reinterpret_cast<Elf64_Addr>(&usleep)},
    {"utime", reinterpret_cast<Elf64_Addr>(&utime)},
    {"utimensat", reinterpret_cast<Elf64_Addr>(&utimensat)},
    {"utimes", reinterpret_cast<Elf64_Addr>(&utimes)},
    {"utmpxname", reinterpret_cast<Elf64_Addr>(&utmpxname)},
    {"vasprintf", reinterpret_cast<Elf64_Addr>(&vasprintf)},
    {"versionsort", reinterpret_cast<Elf64_Addr>(&versionsort)},
    {"vfork", reinterpret_cast<Elf64_Addr>(&vfork)},
    {"vfprintf", reinterpret_cast<Elf64_Addr>(&vfprintf)},
    {"vmsplice", reinterpret_cast<Elf64_Addr>(&vmsplice)},
    {"vsnprintf", reinterpret_cast<Elf64_Addr>(&vsnprintf)},
    {"wait", reinterpret_cast<Elf64_Addr>(&wait)},
    {"wait3", reinterpret_cast<Elf64_Addr>(&wait3)},
    {"wait4", reinterpret_cast<Elf64_Addr>(&wait4)},
    {"waitid", reinterpret_cast<Elf64_Addr>(&waitid)},
    {"waitpid", reinterpret_cast<Elf64_Addr>(&waitpid)},
    {"warn", reinterpret_cast<Elf64_Addr>(&warn)},
    {"warnx", reinterpret_cast<Elf64_Addr>(&warnx)},
    {"wcrtomb", reinterpret_cast<Elf64_Addr>(&wcrtomb)},
    {"wcscat", reinterpret_cast<Elf64_Addr>(&wcscat)},
    {"wcschr", reinterpret_cast<Elf64_Addr>(&wcschr_c)},
    {"wcscmp", reinterpret_cast<Elf64_Addr>(&wcscmp)},
    {"wcscoll", reinterpret_cast<Elf64_Addr>(&wcscoll)},
    {"wcscpy", reinterpret_cast<Elf64_Addr>(&wcscpy)},
    {"wcscspn", reinterpret_cast<Elf64_Addr>(&wcscspn)},
    {"wcsdup", reinterpret_cast<Elf64_Addr>(&wcsdup)},
    {"wcsftime", reinterpret_cast<Elf64_Addr>(&wcsftime)},
    {"wcslen", reinterpret_cast<Elf64_Addr>(&wcslen)},
    {"wcsncat", reinterpret_cast<Elf64_Addr>(&wcsncat)},
    {"wcsncmp", reinterpret_cast<Elf64_Addr>(&wcsncmp)},
    {"wcsncpy", reinterpret_cast<Elf64_Addr>(&wcsncpy)},
    {"wcsnlen", reinterpret_cast<Elf64_Addr>(&wcsnlen)},
    {"wcsnrtombs", reinterpret_cast<Elf64_Addr>(&wcsnrtombs)},
    {"wcspbrk", reinterpret_cast<Elf64_Addr>(&wcspbrk_c)},
    {"wcsrchr", reinterpret_cast<Elf64_Addr>(&wcsrchr_c)},
    {"wcsrtombs", reinterpret_cast<Elf64_Addr>(&wcsrtombs)},
    {"wcsstr", reinterpret_cast<Elf64_Addr>(&wcsstr_c)},
    {"wcstok", reinterpret_cast<Elf64_Addr>(&wcstok)},
    {"wcstol", reinterpret_cast<Elf64_Addr>(&wcstol)},
    {"wcstombs", reinterpret_cast<Elf64_Addr>(&wcstombs)},
    {"wcswidth", reinterpret_cast<Elf64_Addr>(&wcswidth)},
    {"wcsxfrm", reinterpret_cast<Elf64_Addr>(&wcsxfrm)},
    {"wctob", reinterpret_cast<Elf64_Addr>(&wctob)},
    {"wctomb", reinterpret_cast<Elf64_Addr>(&wctomb)},
    {"wctype", reinterpret_cast<Elf64_Addr>(&wctype)},
    {"wcwidth", reinterpret_cast<Elf64_Addr>(&wcwidth)},
    {"wmemchr", reinterpret_cast<Elf64_Addr>(&wmemchr_c)},
    {"wmemcmp", reinterpret_cast<Elf64_Addr>(&wmemcmp)},
    {"wmemcpy", reinterpret_cast<Elf64_Addr>(&wmemcpy)},
    {"wmemmove", reinterpret_cast<Elf64_Addr>(&wmemmove)},
    {"wmemset", reinterpret_cast<Elf64_Addr>(&wmemset)},
    {"write", reinterpret_cast<Elf64_Addr>(&write)},
    {"writev", reinterpret_cast<Elf64_Addr>(&writev)},
};
}  // namespace libc_mapping

```

`libc_mapping.h`:

```h
#pragma once

#include <elf.h>
#include <map>
#include <string>

namespace libc_mapping {
extern std::map<std::string, Elf64_Addr> sloader_libc_map;
extern std::map<std::string, const char*> sloader_libc_tls_variables;
}

```

`make-sloader-itself.sh`:

```sh
#! /bin/bash -eux

cd $(git rev-parse --show-toplevel)
SLOADER_PATH=$(realpath ./build/sloader)

if [ ! -f ${SLOADER_PATH} ]
then
    echo "sloader not found at ${SLOADER_PATH}"
    exit 1
fi

rm -rf build2
mkdir -p build2
cd build2
${SLOADER_PATH} cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -S .. -B . -D CMAKE_C_COMPILER_LAUNCHER=${SLOADER_PATH}  -D CMAKE_CXX_COMPILER_LAUNCHER=${SLOADER_PATH} -D CMAKE_C_LINKER_LAUNCHER=${SLOADER_PATH} -D CMAKE_CXX_LINKER_LAUNCHER=${SLOADER_PATH}
${SLOADER_PATH} make VERBOSE=1
${SLOADER_PATH} ctest

```

`misc/build_chibicc.sh`:

```sh
#! /bin/bash -eux

if [[ ! -d chibicc ]]
then
    git clone https://github.com/rui314/chibicc.git
fi

cd chibicc
make -j

```

`misc/build_curl.sh`:

```sh
#! /bin/bash -eux

if [[ ! -d curl ]]
then
    git clone https://github.com/curl/curl.git
fi

cmake -B curl/build -S curl 
cmake --build curl/build -j

```

`misc/build_ninja.sh`:

```sh
#! /bin/bash -eux

if [[ ! -d ninja ]]
then
    git clone https://github.com/ninja-build/ninja.git
fi

cmake -B ninja/build-ninja -S ninja
cmake --build ninja/build-ninja -j

```

`perf_svg.sh`:

```sh
#!/bin/bash -ux
# How to use
# perf_svg.sh ./build/sloader /bin/ls

prefix=perf_svg_$(date +'%Y%m%d%H%M%S')
perf record --freq=max -g --output=${prefix}_perf.data -- $@
if [[ ! -d FlameGraph ]]; then
    git clone https://github.com/brendangregg/FlameGraph
fi
cd FlameGraph
perf script -i ../${prefix}_perf.data | ./stackcollapse-perf.pl > ${prefix}.perf-folded
./flamegraph.pl ${prefix}.perf-folded > ../${prefix}.svg

```

`raw_write/raw_write.h`:

```h
// Copyright (C) 2010 by Shinichiro Hamaji
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// #include <sys/syscall.h>

// TODO(akawashiro):
#define SYS_write 1
#define SYS_exit 60

#if defined(__x86_64__)

#define RAW_NOP4()                        \
    do {                                  \
        __asm__ volatile("nop;\n" : : :); \
        __asm__ volatile("nop;\n" : : :); \
        __asm__ volatile("nop;\n" : : :); \
        __asm__ volatile("nop;\n" : : :); \
    } while (0)

#define RAW_EXIT(status)                                                 \
    do {                                                                 \
        __asm__ volatile("syscall;\n" : : "a"(SYS_exit), "D"(status) :); \
    } while (0)

#define RAW_WRITE(fd, buf, count)                                                     \
    do {                                                                              \
        register unsigned long RAW_rsi##__LINE__ __asm__("rsi") = (unsigned long)buf; \
        __asm__ volatile("syscall;\n"                                                 \
                         : "+r"(RAW_rsi##__LINE__)                                    \
                         : "a"(SYS_write), "D"(fd), "d"(count)                        \
                         : "r8", "r10", "rcx", "r11", "memory", "cc");                \
        /* The input registers may be broken by syscall */                            \
        __asm__ volatile("" ::: "rax", "rdi", "rdx");                                 \
    } while (0)
#elif defined(__i386__)
#define RAW_WRITE(fd, buf, count)                                                                          \
    do {                                                                                                   \
        __asm__ volatile("int $0x80;\n" ::"a"(SYS_write), "b"(fd), "c"(buf), "d"(count) : "memory", "cc"); \
        /* The input registers may be broken by syscall */                                                 \
        __asm__ volatile("" ::: "eax", "ebx", "ecx", "edx");                                               \
    } while (0)
#elif defined(__arm__)
#define RAW_WRITE(fd, buf, count)                \
    do {                                         \
        __asm__ volatile(                        \
            "mov %%r0, %1;\n"                    \
            "mov %%r1, %2;\n"                    \
            "mov %%r2, %3;\n"                    \
            "push {%%r7};\n"                     \
            "mov %%r7, %0;\n"                    \
            "swi 0x0;\n"                         \
            "pop {%%r7};\n" ::"I"(SYS_write),    \
            "r"(fd), "r"(buf), "r"(count)        \
            : "memory", "cc", "r0", "r1", "r2"); \
    } while (0)
#else
#error "RAW_WRITE isn't defined for this architecture"
#endif

#define RAW_PRINT_STR(buf)                     \
    do {                                       \
        const char* RAW_p##__LINE__ = buf;     \
        int i;                                 \
        for (i = 0; RAW_p##__LINE__[i]; i++) { \
        }                                      \
        RAW_WRITE(1, RAW_p##__LINE__, i);      \
    } while (0)

#define RAW_PRINT_BASE_N(num, base)                    \
    do {                                               \
        /* unsigned long long isn't supported */       \
        long long RAW_n##__LINE__ = (long long)num;    \
        int RAW_b##__LINE__ = base;                    \
        int was_minus = 0;                             \
        char buf[21];                                  \
        char* p = buf + 20;                            \
        int l = 0;                                     \
        if (RAW_n##__LINE__ < 0) {                     \
            was_minus = 1;                             \
            RAW_n##__LINE__ = -RAW_n##__LINE__;        \
        }                                              \
        do {                                           \
            int v = RAW_n##__LINE__ % RAW_b##__LINE__; \
            if (v > 9)                                 \
                *p = 'a' + v - 10;                     \
            else                                       \
                *p = '0' + v;                          \
            l++;                                       \
            RAW_n##__LINE__ /= RAW_b##__LINE__;        \
            p--;                                       \
        } while (RAW_n##__LINE__ != 0);                \
        if (was_minus) {                               \
            *p = '-';                                  \
            l++;                                       \
        } else {                                       \
            p++;                                       \
        }                                              \
        RAW_WRITE(1, p, l);                            \
    } while (0)

#define RAW_PRINT_HEX(num) RAW_PRINT_BASE_N(num, 16)
#define RAW_PRINT_INT(num) RAW_PRINT_BASE_N(num, 10)
#define RAW_PRINT_PTR(num)                        \
    do {                                          \
        char buf[3] = "0x";                       \
        RAW_WRITE(1, buf, 2);                     \
        RAW_PRINT_BASE_N((unsigned long)num, 16); \
    } while (0)

#define RAW_PRINT_NL_AFTER_SOMETHING(print) \
    do {                                    \
        print;                              \
        char buf[2] = "\n";                 \
        RAW_WRITE(1, buf, 1);               \
    } while (0)
#define RAW_PUTS_STR(buf) RAW_PRINT_NL_AFTER_SOMETHING(RAW_PRINT_STR(buf))
#define RAW_PUTS_HEX(buf) RAW_PRINT_NL_AFTER_SOMETHING(RAW_PRINT_HEX(buf))
#define RAW_PUTS_INT(buf) RAW_PRINT_NL_AFTER_SOMETHING(RAW_PRINT_INT(buf))
#define RAW_PUTS_PTR(buf) RAW_PRINT_NL_AFTER_SOMETHING(RAW_PRINT_PTR(buf))

/* some more utilities for "printf" debug... */
#if defined(__arm__)
#define RAW_BREAK() __asm__ volatile("bkpt;\n")
#else
#define RAW_BREAK() __asm__ volatile("int3;\n")
#endif
#define RAW_NOP() __asm__ volatile("nop;\n")
/* you can easily find this code by grepping 4242 */
#if defined(__x86_64__)
#define RAW_UNIQ_NOP() __asm__ volatile("nop 0x42424242(%rax);\n")
#elif defined(__i386__)
#define RAW_UNIQ_NOP() __asm__ volatile("nop 0x42424242(%eax);\n")
#elif defined(__arm__)
#define RAW_UNIQ_NOP() __asm__ volatile("nop;\n")
#else
#error "RAW_UNIQ_NOP isn't defined for this architecture"
#endif

#define RAW_DEBUG_MESSAGE()                      \
    do {                                         \
        RAW_PRINT_STR("sloader debug message "); \
        RAW_PRINT_STR(__FILE__);                 \
        RAW_PRINT_STR(":");                      \
        RAW_PRINT_INT(__LINE__);                 \
        RAW_PRINT_STR("\n");                     \
    } while (0)

```

`run-format.sh`:

```sh
#! /bin/bash -eu

cd "$(git rev-parse --show-toplevel)"
git ls-files -- '**/*.h' '**/*.cc' '**/*.c'| xargs -P4 clang-format -i
git ls-files -- '**/CMakeLists.txt' | xargs -P4 cmake-format -i
git diff --exit-code -- .

```

`scripts/build_glibc.sh`:

```sh
#! /bin/bash -eux

cd $(git rev-parse --show-toplevel)/glibc-build
if which bear; then
    LD_LIBRARY_PATH="" bear -- make all -j 20
    LD_LIBRARY_PATH="" bear -- make install -j 20
else
    LD_LIBRARY_PATH="" make all -j $(nproc)
    LD_LIBRARY_PATH="" make install -j $(nproc)
fi

```

`scripts/clone_glibc.sh`:

```sh
#! /bin/bash -eux

cd $(git rev-parse --show-toplevel)

if [[ $# -ne 1 ]]
then
    echo "Usage: $0 <glibc-version>"
    exit 1
fi
GLIBC_VERSION=$1

if [[ ! -d glibc ]]
then
    git clone --depth 1 --no-single-branch https://github.com/akawashiro/glibc.git
    
    pushd glibc
    git remote add upstream https://sourceware.org/git/glibc.git
    git fetch --all
    git checkout ${GLIBC_VERSION}
    popd
fi

mkdir -p glibc-build
mkdir -p glibc-install
cd glibc-build
PREFIX_PATH=$(realpath ../glibc-install)
LD_LIBRARY_PATH="" $(git rev-parse --show-toplevel)/glibc/configure CC="ccache gcc" --prefix=${PREFIX_PATH}

```

`sloader.cc`:

```cc
#include <elf.h>
#include <fcntl.h>
#include <getopt.h>
#include <sys/auxv.h>
#include <sys/mman.h>
#include <unistd.h>

#include <cassert>
#include <cstring>
#include <ctime>
#include <filesystem>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <memory>
#include <string>
#include <vector>

#include "dyn_loader.h"
#include "exec_loader.h"
#include "utils.h"

Elf64_Half GetEType(const std::filesystem::path& filepath) {
    int fd = open(filepath.c_str(), O_RDONLY);
    CHECK(fd >= 0);

    size_t size = lseek(fd, 0, SEEK_END);
    CHECK_GT(size, 8UL + 16UL);

    size_t mapped_size = (size + 0xfff) & ~0xfff;

    char* p = (char*)mmap(NULL, mapped_size, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE, fd, 0);
    LOG(FATAL) << LOG_BITS(mapped_size) << LOG_BITS(size) << LOG_KEY(filepath);
    CHECK(p != MAP_FAILED);

    Elf64_Ehdr* ehdr = reinterpret_cast<Elf64_Ehdr*>(p);
    return ehdr->e_type;
}

int main(int argc, char* const argv[], char** envp) {
    std::string argv0 = argv[1];
    std::filesystem::path fullpath;

    if (argv0[0] == '.' || argv0.find("/") != std::string::npos) {
        fullpath = std::filesystem::path(argv0);
    } else {
        std::vector<std::string> path_dirs = SplitWith(std::string(getenv("PATH")), ":");
        for (const auto& dir : path_dirs) {
            std::filesystem::path p = std::filesystem::path(dir) / argv0;
            if (std::filesystem::exists(p) && std::filesystem::is_regular_file(p)) {
                fullpath = p;
                break;
            }
        }
    }

    LOG(INFO) << LOG_KEY(fullpath);
    CHECK(std::filesystem::exists(fullpath));

    std::vector<std::string> args;
    for (int i = 1; i < argc; i++) {
        args.emplace_back(argv[i]);
    }

    std::vector<std::string> envs;
    for (char** env = envp; *env != 0; env++) {
        envs.emplace_back(*env);
    }

    Elf64_Half etype = GetEType(fullpath);
    if (etype == ET_DYN || etype == ET_EXEC) {
        InitializeDynLoader(fullpath, envs, args);
        GetDynLoader()->Run();
    } else {
        LOG(FATAL) << "Unsupported etype = " << LOG_KEY(etype);
        std::abort();
    }
}

```

`sloader.map`:

```map
/* Script for -z combreloc -z separate-code */
/* Copyright (C) 2014-2020 Free Software Foundation, Inc.
   Copying and distribution of this script, with or without modification,
   are permitted in any medium without royalty provided the copyright
   notice and this notice are preserved.  */
OUTPUT_FORMAT("elf64-x86-64", "elf64-x86-64",
	      "elf64-x86-64")
OUTPUT_ARCH(i386:x86-64)
ENTRY(_start)
SEARCH_DIR("=/usr/local/lib/x86_64-linux-gnu"); SEARCH_DIR("=/lib/x86_64-linux-gnu"); SEARCH_DIR("=/usr/lib/x86_64-linux-gnu"); SEARCH_DIR("=/usr/lib/x86_64-linux-gnu64"); SEARCH_DIR("=/usr/local/lib64"); SEARCH_DIR("=/lib64"); SEARCH_DIR("=/usr/lib64"); SEARCH_DIR("=/usr/local/lib"); SEARCH_DIR("=/lib"); SEARCH_DIR("=/usr/lib"); SEARCH_DIR("=/usr/x86_64-linux-gnu/lib64"); SEARCH_DIR("=/usr/x86_64-linux-gnu/lib");
SECTIONS
{
  PROVIDE (__executable_start = SEGMENT_START("text-segment", 0x100400000)); . = SEGMENT_START("text-segment", 0x100400000) + SIZEOF_HEADERS;
  .interp         : { *(.interp) }
  .note.gnu.build-id  : { *(.note.gnu.build-id) }
  .hash           : { *(.hash) }
  .gnu.hash       : { *(.gnu.hash) }
  .dynsym         : { *(.dynsym) }
  .dynstr         : { *(.dynstr) }
  .gnu.version    : { *(.gnu.version) }
  .gnu.version_d  : { *(.gnu.version_d) }
  .gnu.version_r  : { *(.gnu.version_r) }
  .rela.dyn       :
    {
      *(.rela.init)
      *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*)
      *(.rela.fini)
      *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*)
      *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*)
      *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*)
      *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*)
      *(.rela.ctors)
      *(.rela.dtors)
      *(.rela.got)
      *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*)
      *(.rela.ldata .rela.ldata.* .rela.gnu.linkonce.l.*)
      *(.rela.lbss .rela.lbss.* .rela.gnu.linkonce.lb.*)
      *(.rela.lrodata .rela.lrodata.* .rela.gnu.linkonce.lr.*)
      *(.rela.ifunc)
    }
  .rela.plt       :
    {
      *(.rela.plt)
      PROVIDE_HIDDEN (__rela_iplt_start = .);
      *(.rela.iplt)
      PROVIDE_HIDDEN (__rela_iplt_end = .);
    }
  . = ALIGN(CONSTANT (MAXPAGESIZE));
  .init           :
  {
    KEEP (*(SORT_NONE(.init)))
  }
  .plt            : { *(.plt) *(.iplt) }
.plt.got        : { *(.plt.got) }
.plt.sec        : { *(.plt.sec) }
  .text           :
  {
    *(.text.unlikely .text.*_unlikely .text.unlikely.*)
    *(.text.exit .text.exit.*)
    *(.text.startup .text.startup.*)
    *(.text.hot .text.hot.*)
    *(SORT(.text.sorted.*))
    *(.text .stub .text.* .gnu.linkonce.t.*)
    /* .gnu.warning sections are handled specially by elf.em.  */
    *(.gnu.warning)
  }
  .fini           :
  {
    KEEP (*(SORT_NONE(.fini)))
  }
  PROVIDE (__etext = .);
  PROVIDE (_etext = .);
  PROVIDE (etext = .);
  . = ALIGN(CONSTANT (MAXPAGESIZE));
  /* Adjust the address for the rodata segment.  We want to adjust up to
     the same address within the page on the next page up.  */
  . = SEGMENT_START("rodata-segment", ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)));
  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }
  .rodata1        : { *(.rodata1) }
  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }
  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }
  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }
  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }
  /* These sections are generated by the Sun/Oracle C++ compiler.  */
  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }
  /* Adjust the address for the data segment.  We want to adjust up to
     the same address within the page on the next page up.  */
  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));
  /* Exception handling  */
  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }
  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }
  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }
  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }
  /* Thread Local Storage sections  */
  .tdata	  :
   {
     PROVIDE_HIDDEN (__tdata_start = .);
     *(.tdata .tdata.* .gnu.linkonce.td.*)
   }
  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }
  .preinit_array    :
  {
    PROVIDE_HIDDEN (__preinit_array_start = .);
    KEEP (*(.preinit_array))
    PROVIDE_HIDDEN (__preinit_array_end = .);
  }
  .init_array    :
  {
    PROVIDE_HIDDEN (__init_array_start = .);
    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))
    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))
    PROVIDE_HIDDEN (__init_array_end = .);
  }
  .fini_array    :
  {
    PROVIDE_HIDDEN (__fini_array_start = .);
    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))
    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))
    PROVIDE_HIDDEN (__fini_array_end = .);
  }
  .ctors          :
  {
    /* gcc uses crtbegin.o to find the start of
       the constructors, so we make sure it is
       first.  Because this is a wildcard, it
       doesn't matter if the user does not
       actually link against crtbegin.o; the
       linker won't look for a file to match a
       wildcard.  The wildcard also means that it
       doesn't matter which directory crtbegin.o
       is in.  */
    KEEP (*crtbegin.o(.ctors))
    KEEP (*crtbegin?.o(.ctors))
    /* We don't want to include the .ctor section from
       the crtend.o file until after the sorted ctors.
       The .ctor section from the crtend file contains the
       end of ctors marker and it must be last */
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))
    KEEP (*(SORT(.ctors.*)))
    KEEP (*(.ctors))
  }
  .dtors          :
  {
    KEEP (*crtbegin.o(.dtors))
    KEEP (*crtbegin?.o(.dtors))
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))
    KEEP (*(SORT(.dtors.*)))
    KEEP (*(.dtors))
  }
  .jcr            : { KEEP (*(.jcr)) }
  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }
  .dynamic        : { *(.dynamic) }
  .got            : { *(.got) *(.igot) }
  . = DATA_SEGMENT_RELRO_END (SIZEOF (.got.plt) >= 24 ? 24 : 0, .);
  .got.plt        : { *(.got.plt) *(.igot.plt) }
  .data           :
  {
    *(.data .data.* .gnu.linkonce.d.*)
    SORT(CONSTRUCTORS)
  }
  .data1          : { *(.data1) }
  _edata = .; PROVIDE (edata = .);
  . = .;
  __bss_start = .;
  .bss            :
  {
   *(.dynbss)
   *(.bss .bss.* .gnu.linkonce.b.*)
   *(COMMON)
   /* Align here to ensure that the .bss section occupies space up to
      _end.  Align after .bss to ensure correct alignment even if the
      .bss section disappears because there are no input sections.
      FIXME: Why do we need it? When there is no .bss section, we do not
      pad the .data section.  */
   . = ALIGN(. != 0 ? 64 / 8 : 1);
  }
  .lbss   :
  {
    *(.dynlbss)
    *(.lbss .lbss.* .gnu.linkonce.lb.*)
    *(LARGE_COMMON)
  }
  . = ALIGN(64 / 8);
  . = SEGMENT_START("ldata-segment", .);
  .lrodata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)) :
  {
    *(.lrodata .lrodata.* .gnu.linkonce.lr.*)
  }
  .ldata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)) :
  {
    *(.ldata .ldata.* .gnu.linkonce.l.*)
    . = ALIGN(. != 0 ? 64 / 8 : 1);
  }
  . = ALIGN(64 / 8);
  _end = .; PROVIDE (end = .);
  . = DATA_SEGMENT_END (.);
  /* Stabs debugging sections.  */
  .stab          0 : { *(.stab) }
  .stabstr       0 : { *(.stabstr) }
  .stab.excl     0 : { *(.stab.excl) }
  .stab.exclstr  0 : { *(.stab.exclstr) }
  .stab.index    0 : { *(.stab.index) }
  .stab.indexstr 0 : { *(.stab.indexstr) }
  .comment       0 : { *(.comment) }
  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }
  /* DWARF debug sections.
     Symbols in the DWARF debugging sections are relative to the beginning
     of the section so we begin them at 0.  */
  /* DWARF 1 */
  .debug          0 : { *(.debug) }
  .line           0 : { *(.line) }
  /* GNU DWARF 1 extensions */
  .debug_srcinfo  0 : { *(.debug_srcinfo) }
  .debug_sfnames  0 : { *(.debug_sfnames) }
  /* DWARF 1.1 and DWARF 2 */
  .debug_aranges  0 : { *(.debug_aranges) }
  .debug_pubnames 0 : { *(.debug_pubnames) }
  /* DWARF 2 */
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }
  .debug_abbrev   0 : { *(.debug_abbrev) }
  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }
  .debug_frame    0 : { *(.debug_frame) }
  .debug_str      0 : { *(.debug_str) }
  .debug_loc      0 : { *(.debug_loc) }
  .debug_macinfo  0 : { *(.debug_macinfo) }
  /* SGI/MIPS DWARF 2 extensions */
  .debug_weaknames 0 : { *(.debug_weaknames) }
  .debug_funcnames 0 : { *(.debug_funcnames) }
  .debug_typenames 0 : { *(.debug_typenames) }
  .debug_varnames  0 : { *(.debug_varnames) }
  /* DWARF 3 */
  .debug_pubtypes 0 : { *(.debug_pubtypes) }
  .debug_ranges   0 : { *(.debug_ranges) }
  /* DWARF Extension.  */
  .debug_macro    0 : { *(.debug_macro) }
  .debug_addr     0 : { *(.debug_addr) }
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }
  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }
}

```

`sloader_dl.cc`:

```cc
#include <dlfcn.h>
#include <cerrno>
#include <cstdio>
#include <cstdlib>
#include <optional>

#include <elf.h>
#include <glob.h>

#include "dyn_loader.h"
#include "sloader_dl.h"
#include "utils.h"

void* sloader_dlopen(const char* filename, int flags) {
    // If filename is NULL, then the returned handle is for the main program. Ref
    // dlopen(3).
    if (filename == NULL) {
        return reinterpret_cast<void*>(0xabcdabcdabcdabcd);
    }
    // Skip dynamic loader and libc.so
    {
        std::string filename_str = std::string(filename);
        if (filename_str.find("ld-linux") != std::string::npos || filename_str.find("libc.so") != std::string::npos) {
            LOG(INFO) << "Skip " << filename_str;
            return reinterpret_cast<void*>(0xaaaaaaaabbbbbbbb);
        }
    }

    LOG(INFO) << "sloader_dlopen" << LOG_KEY(filename) << LOG_KEY(flags) << LOG_KEY(getenv("LD_LIBRARY_PATH"));
    GetDynLoader()->LoadDependingLibs(FindLibrary(filename, std::nullopt, std::nullopt));
    GetDynLoader()->Relocate();
    // TODO: Functions depending on handle may fail.
    return reinterpret_cast<void*>(0xdeadbeefdeadbeef);
}

void* sloader_dlsym(void* handle, const char* symbol) {
    LOG(INFO) << "sloader_dlopen" << LOG_KEY(symbol);
    const auto opt = GetDynLoader()->SearchSym(symbol, false);
    CHECK(opt);
    const auto [bin_index, sym_index] = opt.value();
    Elf64_Addr sym_addr = GetDynLoader()->binaries_[bin_index].GetSymbolAddr(sym_index);
    return reinterpret_cast<void*>(sym_addr);
}

void* sloader_dlvsym(void* handle, char* symbol, char* version) {
    printf("sloader_dlvsym: handle=%p symbol=%s version=%s\n", handle, symbol, version);
    exit(10);
    return dlvsym(handle, symbol, version);
}

int sloader_dladdr(void* addr, Dl_info* info) {
    LOG(INFO) << "sloader_dladdr";
    return dladdr(addr, info);
}

```

`sloader_dl.h`:

```h
#include <dlfcn.h>

void* sloader_dlopen(const char* filename, int flags);
void* sloader_dlsym(void* handle, const char* symbol);
void* sloader_dlvsym(void* handle, char* symbol, char* version);
int sloader_dladdr(void *addr, Dl_info *info);

```

`sloader_static.map`:

```map
/* Script for -z combreloc -z separate-code */
/* Copyright (C) 2014-2022 Free Software Foundation, Inc.
   Copying and distribution of this script, with or without modification,
   are permitted in any medium without royalty provided the copyright
   notice and this notice are preserved.  */
OUTPUT_FORMAT("elf64-x86-64", "elf64-x86-64",
	      "elf64-x86-64")
OUTPUT_ARCH(i386:x86-64)
ENTRY(_start)
SEARCH_DIR("=/usr/local/lib/x86_64-linux-gnu"); SEARCH_DIR("=/lib/x86_64-linux-gnu"); SEARCH_DIR("=/usr/lib/x86_64-linux-gnu"); SEARCH_DIR("=/usr/lib/x86_64-linux-gnu64"); SEARCH_DIR("=/usr/local/lib64"); SEARCH_DIR("=/lib64"); SEARCH_DIR("=/usr/lib64"); SEARCH_DIR("=/usr/local/lib"); SEARCH_DIR("=/lib"); SEARCH_DIR("=/usr/lib"); SEARCH_DIR("=/usr/x86_64-linux-gnu/lib64"); SEARCH_DIR("=/usr/x86_64-linux-gnu/lib");
SECTIONS
{
  PROVIDE (__executable_start = SEGMENT_START("text-segment", 0x10000000)); . = SEGMENT_START("text-segment", 0x10000000) + SIZEOF_HEADERS;
  .interp         : { *(.interp) }
  .note.gnu.build-id  : { *(.note.gnu.build-id) }
  .hash           : { *(.hash) }
  .gnu.hash       : { *(.gnu.hash) }
  .dynsym         : { *(.dynsym) }
  .dynstr         : { *(.dynstr) }
  .gnu.version    : { *(.gnu.version) }
  .gnu.version_d  : { *(.gnu.version_d) }
  .gnu.version_r  : { *(.gnu.version_r) }
  .rela.dyn       :
    {
      *(.rela.init)
      *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*)
      *(.rela.fini)
      *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*)
      *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*)
      *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*)
      *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*)
      *(.rela.ctors)
      *(.rela.dtors)
      *(.rela.got)
      *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*)
      *(.rela.ldata .rela.ldata.* .rela.gnu.linkonce.l.*)
      *(.rela.lbss .rela.lbss.* .rela.gnu.linkonce.lb.*)
      *(.rela.lrodata .rela.lrodata.* .rela.gnu.linkonce.lr.*)
      *(.rela.ifunc)
    }
  .rela.plt       :
    {
      *(.rela.plt)
      PROVIDE_HIDDEN (__rela_iplt_start = .);
      *(.rela.iplt)
      PROVIDE_HIDDEN (__rela_iplt_end = .);
    }
  .relr.dyn : { *(.relr.dyn) }
  . = ALIGN(CONSTANT (MAXPAGESIZE));
  .init           :
  {
    KEEP (*(SORT_NONE(.init)))
  }
  .plt            : { *(.plt) *(.iplt) }
.plt.got        : { *(.plt.got) }
.plt.sec        : { *(.plt.sec) }
  .text           :
  {
    *(.text.unlikely .text.*_unlikely .text.unlikely.*)
    *(.text.exit .text.exit.*)
    *(.text.startup .text.startup.*)
    *(.text.hot .text.hot.*)
    *(SORT(.text.sorted.*))
    *(.text .stub .text.* .gnu.linkonce.t.*)
    /* .gnu.warning sections are handled specially by elf.em.  */
    *(.gnu.warning)
  }
  .fini           :
  {
    KEEP (*(SORT_NONE(.fini)))
  }
  PROVIDE (__etext = .);
  PROVIDE (_etext = .);
  PROVIDE (etext = .);
  . = ALIGN(CONSTANT (MAXPAGESIZE));
  /* Adjust the address for the rodata segment.  We want to adjust up to
     the same address within the page on the next page up.  */
  . = SEGMENT_START("rodata-segment", ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)));
  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }
  .rodata1        : { *(.rodata1) }
  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }
  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }
  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }
  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }
  /* These sections are generated by the Sun/Oracle C++ compiler.  */
  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }
  /* Adjust the address for the data segment.  We want to adjust up to
     the same address within the page on the next page up.  */
  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));
  /* Exception handling  */
  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }
  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }
  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }
  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }
  /* Thread Local Storage sections  */
  .tdata	  :
   {
     PROVIDE (__sloader_tdata_start = .);
     . = ALIGN(4096);
     PROVIDE (__tdata_start = .);
     *(.tdata .tdata.* .gnu.linkonce.td.*)
   }
  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }
  .preinit_array    :
  {
    PROVIDE_HIDDEN (__preinit_array_start = .);
    KEEP (*(.preinit_array))
    PROVIDE_HIDDEN (__preinit_array_end = .);
  }
  .init_array    :
  {
    PROVIDE_HIDDEN (__init_array_start = .);
    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))
    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))
    PROVIDE_HIDDEN (__init_array_end = .);
  }
  .fini_array    :
  {
    PROVIDE_HIDDEN (__fini_array_start = .);
    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))
    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))
    PROVIDE_HIDDEN (__fini_array_end = .);
  }
  .ctors          :
  {
    /* gcc uses crtbegin.o to find the start of
       the constructors, so we make sure it is
       first.  Because this is a wildcard, it
       doesn't matter if the user does not
       actually link against crtbegin.o; the
       linker won't look for a file to match a
       wildcard.  The wildcard also means that it
       doesn't matter which directory crtbegin.o
       is in.  */
    KEEP (*crtbegin.o(.ctors))
    KEEP (*crtbegin?.o(.ctors))
    /* We don't want to include the .ctor section from
       the crtend.o file until after the sorted ctors.
       The .ctor section from the crtend file contains the
       end of ctors marker and it must be last */
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))
    KEEP (*(SORT(.ctors.*)))
    KEEP (*(.ctors))
  }
  .dtors          :
  {
    KEEP (*crtbegin.o(.dtors))
    KEEP (*crtbegin?.o(.dtors))
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))
    KEEP (*(SORT(.dtors.*)))
    KEEP (*(.dtors))
  }
  .jcr            : { KEEP (*(.jcr)) }
  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }
  .dynamic        : { *(.dynamic) }
  .got            : { *(.got) *(.igot) }
  . = DATA_SEGMENT_RELRO_END (SIZEOF (.got.plt) >= 24 ? 24 : 0, .);
  .got.plt        : { *(.got.plt) *(.igot.plt) }
  .data           :
  {
    *(.data .data.* .gnu.linkonce.d.*)
    SORT(CONSTRUCTORS)
  }
  .data1          : { *(.data1) }
  _edata = .; PROVIDE (edata = .);
  . = .;
  __bss_start = .;
  .bss            :
  {
   *(.dynbss)
   *(.bss .bss.* .gnu.linkonce.b.*)
   *(COMMON)
   /* Align here to ensure that the .bss section occupies space up to
      _end.  Align after .bss to ensure correct alignment even if the
      .bss section disappears because there are no input sections.
      FIXME: Why do we need it? When there is no .bss section, we do not
      pad the .data section.  */
   . = ALIGN(. != 0 ? 64 / 8 : 1);
  }
  .lbss   :
  {
    *(.dynlbss)
    *(.lbss .lbss.* .gnu.linkonce.lb.*)
    *(LARGE_COMMON)
  }
  . = ALIGN(64 / 8);
  . = SEGMENT_START("ldata-segment", .);
  .lrodata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)) :
  {
    *(.lrodata .lrodata.* .gnu.linkonce.lr.*)
  }
  .ldata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)) :
  {
    *(.ldata .ldata.* .gnu.linkonce.l.*)
    . = ALIGN(. != 0 ? 64 / 8 : 1);
  }
  . = ALIGN(64 / 8);
  _end = .; PROVIDE (end = .);
  . = DATA_SEGMENT_END (.);
  /* Stabs debugging sections.  */
  .stab          0 : { *(.stab) }
  .stabstr       0 : { *(.stabstr) }
  .stab.excl     0 : { *(.stab.excl) }
  .stab.exclstr  0 : { *(.stab.exclstr) }
  .stab.index    0 : { *(.stab.index) }
  .stab.indexstr 0 : { *(.stab.indexstr) }
  .comment       0 : { *(.comment) }
  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }
  /* DWARF debug sections.
     Symbols in the DWARF debugging sections are relative to the beginning
     of the section so we begin them at 0.  */
  /* DWARF 1.  */
  .debug          0 : { *(.debug) }
  .line           0 : { *(.line) }
  /* GNU DWARF 1 extensions.  */
  .debug_srcinfo  0 : { *(.debug_srcinfo) }
  .debug_sfnames  0 : { *(.debug_sfnames) }
  /* DWARF 1.1 and DWARF 2.  */
  .debug_aranges  0 : { *(.debug_aranges) }
  .debug_pubnames 0 : { *(.debug_pubnames) }
  /* DWARF 2.  */
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }
  .debug_abbrev   0 : { *(.debug_abbrev) }
  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }
  .debug_frame    0 : { *(.debug_frame) }
  .debug_str      0 : { *(.debug_str) }
  .debug_loc      0 : { *(.debug_loc) }
  .debug_macinfo  0 : { *(.debug_macinfo) }
  /* SGI/MIPS DWARF 2 extensions.  */
  .debug_weaknames 0 : { *(.debug_weaknames) }
  .debug_funcnames 0 : { *(.debug_funcnames) }
  .debug_typenames 0 : { *(.debug_typenames) }
  .debug_varnames  0 : { *(.debug_varnames) }
  /* DWARF 3.  */
  .debug_pubtypes 0 : { *(.debug_pubtypes) }
  .debug_ranges   0 : { *(.debug_ranges) }
  /* DWARF 5.  */
  .debug_addr     0 : { *(.debug_addr) }
  .debug_line_str 0 : { *(.debug_line_str) }
  .debug_loclists 0 : { *(.debug_loclists) }
  .debug_macro    0 : { *(.debug_macro) }
  .debug_names    0 : { *(.debug_names) }
  .debug_rnglists 0 : { *(.debug_rnglists) }
  .debug_str_offsets 0 : { *(.debug_str_offsets) }
  .debug_sup      0 : { *(.debug_sup) }
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }
  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }
}

```

`tests/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)

add_custom_target(
  hello_asm ALL
  COMMAND nasm -f elf64 ${CMAKE_CURRENT_SOURCE_DIR}/hello.asm -o
          ${CMAKE_CURRENT_BINARY_DIR}/hello.o && ld -s -o hello_asm hello.o
  WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})

add_test(
  NAME hello_asm_test
  COMMAND ./sloader ./tests/hello_asm
  WORKING_DIRECTORY ${CMAKE_BINARY_DIR})

# Hand written testcases
add_subdirectory(print_env_aux)
add_subdirectory(cascades)
add_subdirectory(find_a_depending_so)
add_subdirectory(hello_glibc)
add_subdirectory(hello_static_glibc)
add_subdirectory(global_variable)
add_subdirectory(static_struct)
add_subdirectory(constructor)
add_subdirectory(local_exec)
add_subdirectory(local_dynamic)
add_subdirectory(generic_dynamic)
add_subdirectory(initial_exec)
add_subdirectory(ls)
add_subdirectory(print_args)
add_subdirectory(errno)
add_subdirectory(dlopen)
add_subdirectory(dlopen2)

# GNU Coreutils tests
add_test(
  NAME coreutils_cat
  COMMAND
    python3 ${CMAKE_CURRENT_SOURCE_DIR}/compare_stdout.py
    ${CMAKE_BINARY_DIR}/sloader /bin/cat
    ${CMAKE_CURRENT_SOURCE_DIR}/compare_stdout.py)

add_test(
  NAME coreutils_cksum
  COMMAND
    python3 ${CMAKE_CURRENT_SOURCE_DIR}/compare_stdout.py
    ${CMAKE_BINARY_DIR}/sloader /bin/cksum
    ${CMAKE_CURRENT_SOURCE_DIR}/compare_stdout.py)

add_test(
  NAME coreutils_sha1sum
  COMMAND
    python3 ${CMAKE_CURRENT_SOURCE_DIR}/compare_stdout.py
    ${CMAKE_BINARY_DIR}/sloader /bin/sha1sum
    ${CMAKE_CURRENT_SOURCE_DIR}/compare_stdout.py)

add_test(
  NAME coreutils_md5sum
  COMMAND
    python3 ${CMAKE_CURRENT_SOURCE_DIR}/compare_stdout.py
    ${CMAKE_BINARY_DIR}/sloader /bin/md5sum
    ${CMAKE_CURRENT_SOURCE_DIR}/compare_stdout.py)

add_test(
  NAME coreutils_od
  COMMAND python3 ${CMAKE_CURRENT_SOURCE_DIR}/compare_stdout.py
          ${CMAKE_BINARY_DIR}/sloader /bin/od ${CMAKE_BINARY_DIR}/sloader)

add_test(
  NAME coreutils_head
  COMMAND
    python3 ${CMAKE_CURRENT_SOURCE_DIR}/compare_stdout.py
    ${CMAKE_BINARY_DIR}/sloader /bin/head
    ${CMAKE_CURRENT_SOURCE_DIR}/compare_stdout.py)

add_test(
  NAME coreutils_sort
  COMMAND
    python3 ${CMAKE_CURRENT_SOURCE_DIR}/compare_stdout.py
    ${CMAKE_BINARY_DIR}/sloader /bin/sort
    ${CMAKE_CURRENT_SOURCE_DIR}/compare_stdout.py)

add_test(
  NAME coreutils_uniq
  COMMAND
    python3 ${CMAKE_CURRENT_SOURCE_DIR}/compare_stdout.py
    ${CMAKE_BINARY_DIR}/sloader /bin/uniq
    ${CMAKE_CURRENT_SOURCE_DIR}/compare_stdout.py)

add_test(
  NAME coreutils_wc
  COMMAND
    python3 ${CMAKE_CURRENT_SOURCE_DIR}/compare_stdout.py
    ${CMAKE_BINARY_DIR}/sloader /bin/wc
    ${CMAKE_CURRENT_SOURCE_DIR}/compare_stdout.py)

add_test(NAME coreutils_date
         COMMAND python3 ${CMAKE_CURRENT_SOURCE_DIR}/compare_stdout.py
                 ${CMAKE_BINARY_DIR}/sloader /bin/date)

add_test(NAME coreutils_who
         COMMAND python3 ${CMAKE_CURRENT_SOURCE_DIR}/compare_stdout.py
                 ${CMAKE_BINARY_DIR}/sloader /bin/who)

add_test(
  NAME coreutils_stat
  COMMAND
    python3 ${CMAKE_CURRENT_SOURCE_DIR}/compare_stdout.py
    ${CMAKE_BINARY_DIR}/sloader /bin/stat
    ${CMAKE_CURRENT_SOURCE_DIR}/compare_stdout.py)

add_test(NAME coreutils_hostid
         COMMAND python3 ${CMAKE_CURRENT_SOURCE_DIR}/compare_stdout.py
                 ${CMAKE_BINARY_DIR}/sloader /bin/hostid)

add_test(NAME coreutils_printenv
         COMMAND python3 ${CMAKE_CURRENT_SOURCE_DIR}/compare_stdout.py
                 ${CMAKE_BINARY_DIR}/sloader /bin/printenv)

add_test(NAME coreutils_id
         COMMAND python3 ${CMAKE_CURRENT_SOURCE_DIR}/compare_stdout.py
                 ${CMAKE_BINARY_DIR}/sloader /bin/id)

add_test(NAME coreutils_logname
         COMMAND python3 ${CMAKE_CURRENT_SOURCE_DIR}/compare_stdout.py
                 ${CMAKE_BINARY_DIR}/sloader /bin/logname)

add_test(NAME coreutils_uname
         COMMAND python3 ${CMAKE_CURRENT_SOURCE_DIR}/compare_stdout.py
                 ${CMAKE_BINARY_DIR}/sloader /bin/uname -a)

# GNU Bintuils tests
add_test(
  NAME binutils_objdump
  COMMAND
    python3 ${CMAKE_CURRENT_SOURCE_DIR}/compare_stdout.py
    ${CMAKE_BINARY_DIR}/sloader /bin/objdump -d ${CMAKE_BINARY_DIR}/sloader)

add_test(
  NAME binutils_readelf
  COMMAND
    python3 ${CMAKE_CURRENT_SOURCE_DIR}/compare_stdout.py
    ${CMAKE_BINARY_DIR}/sloader /bin/readelf -a ${CMAKE_BINARY_DIR}/sloader)

# My daily use tools
add_test(NAME test_ps
         COMMAND python3 ${CMAKE_CURRENT_SOURCE_DIR}/compare_stdout.py
                 ${CMAKE_BINARY_DIR}/sloader /usr/bin/ps --help)

add_test(NAME test_top
         COMMAND python3 ${CMAKE_CURRENT_SOURCE_DIR}/compare_stdout.py
                 ${CMAKE_BINARY_DIR}/sloader /usr/bin/top -h)

add_test(NAME test_tmux
         COMMAND python3 ${CMAKE_CURRENT_SOURCE_DIR}/compare_stdout.py
                 ${CMAKE_BINARY_DIR}/sloader tmux --help)

# add_test(NAME test_nvim COMMAND python3
# ${CMAKE_CURRENT_SOURCE_DIR}/compare_stdout.py ${CMAKE_BINARY_DIR}/sloader nvim
# --help)

add_test(NAME test_python3
         COMMAND python3 ${CMAKE_CURRENT_SOURCE_DIR}/compare_stdout.py
                 ${CMAKE_BINARY_DIR}/sloader /usr/bin/python3 --help)

add_test(NAME test_gcc
         COMMAND python3 ${CMAKE_CURRENT_SOURCE_DIR}/compare_stdout.py
                 ${CMAKE_BINARY_DIR}/sloader gcc --help)

add_test(NAME test_make
         COMMAND python3 ${CMAKE_CURRENT_SOURCE_DIR}/compare_stdout.py
                 ${CMAKE_BINARY_DIR}/sloader make --help)

add_test(NAME test_zsh
         COMMAND python3 ${CMAKE_CURRENT_SOURCE_DIR}/compare_stdout.py
                 ${CMAKE_BINARY_DIR}/sloader zsh --help)

add_test(NAME test_rustc
         COMMAND python3 ${CMAKE_CURRENT_SOURCE_DIR}/compare_stdout.py
                 ${CMAKE_BINARY_DIR}/sloader rustc --help)

add_test(
  NAME test_python3_hello
  COMMAND
    python3 ${CMAKE_CURRENT_SOURCE_DIR}/compare_stdout.py
    ${CMAKE_BINARY_DIR}/sloader /usr/bin/python3 ${CMAKE_CURRENT_SOURCE_DIR}/hello.py)

add_test(
  NAME test_python3_ctypes
  COMMAND
    python3 ${CMAKE_CURRENT_SOURCE_DIR}/compare_stdout.py
    ${CMAKE_BINARY_DIR}/sloader /usr/bin/python3 ${CMAKE_CURRENT_SOURCE_DIR}/ctypes.py)

# Installing additional packages is required but not supported yet.
#
# Just `python3` may be a bash script because of pyenv. So, we must use
# `/usr/bin/python3` instead. Then, we must install torch system-wide. But, I
# don't want to install torch system-wide just for testing.
# add_test(
#   NAME test_python3_torch_ones
#   COMMAND
#     python3 ${CMAKE_CURRENT_SOURCE_DIR}/compare_stdout.py
#     ${CMAKE_BINARY_DIR}/sloader /usr/bin/python3
#     ${CMAKE_CURRENT_SOURCE_DIR}/torch_ones.py)

add_test(
  NAME test_bash_plus
  COMMAND
    python3 ${cmake_current_source_dir}/compare_stdout.py
    ${cmake_binary_dir}/sloader bash
    ${cmake_current_source_dir}/one_plus_one.sh)

add_test(NAME test_curl
         COMMAND python3 ${cmake_current_source_dir}/compare_stdout.py
                 ${cmake_binary_dir}/sloader curl -s www.example.com)

set_tests_properties(test_rustc test_top test_bash_plus test_curl
                     PROPERTIES WILL_FAIL TRUE)

if(CUSTOM_LIBC_PATH)
  add_custom_target(
    hello_static_custom_libc ALL
    COMMAND
      gcc -g -c ${CMAKE_CURRENT_SOURCE_DIR}/hello.c -o
      ${CMAKE_CURRENT_BINARY_DIR}/hello_static_custom_libc.o && gcc -o
      hello_static_custom_libc -nostdlib -nostartfiles -static
      ${CUSTOM_LIBC_PATH}/lib/crt1.o ${CUSTOM_LIBC_PATH}/lib/crti.o `gcc
      --print-file-name=crtbegin.o`
      ${CMAKE_CURRENT_BINARY_DIR}/hello_static_custom_libc.o -Wl,--start-group
      ${CUSTOM_LIBC_PATH}/lib/libc.a -lgcc -lgcc_eh -Wl,--end-group `gcc
      --print-file-name=crtend.o` ${CUSTOM_LIBC_PATH}/lib/crtn.o)
  add_test(
    NAME hello_static_custom_libc_test
    COMMAND ${CMAKE_BINARY_DIR}/sloader
            ${CMAKE_CURRENT_BINARY_DIR}/hello_static_custom_libc
    WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})
endif()

```

`tests/cascades/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)

add_library(cascades_hoge SHARED hoge.c)
target_include_directories(cascades_hoge PRIVATE ${CMAKE_SOURCE_DIR})
add_library(cascades_fuga SHARED fuga.c)
target_include_directories(cascades_fuga PRIVATE ${CMAKE_SOURCE_DIR})
target_link_libraries(cascades_fuga cascades_hoge)
add_executable(cascades_main main.c)
target_compile_options(cascades_main PUBLIC -fno-builtin)
target_link_libraries(cascades_main cascades_fuga -nostdlib)

add_test(
  NAME cascades_test
  COMMAND
    python3 ${CMAKE_CURRENT_SOURCE_DIR}/run.py ${CMAKE_BINARY_DIR}/sloader
    ${CMAKE_BINARY_DIR}/tests/cascades/cascades_main)

```

`tests/cascades/fuga.c`:

```c
#include "raw_write.h"

void hoge(int a, int b);

void fuga() {
    RAW_PRINT_STR("Hello World! from fuga\n");
    hoge(40, 2);
    return;
}

```

`tests/cascades/hoge.c`:

```c
#include "raw_write.h"

int hoge(int a, int b) {
    RAW_PRINT_STR("Hello World! from hoge\n");
    return a + b;
}

```

`tests/cascades/main.c`:

```c
void fuga();

int main() {
    fuga();
    return 0;
}

```

`tests/cascades/run.py`:

```py
import subprocess
import sys

comp = subprocess.run(sys.argv[1:], capture_output=True)
print(comp)
print("cmd: ", " ".join(sys.argv[1:]))
stdout = comp.stdout.decode("utf-8")
print("stdout:")
print(stdout)
succeeded = "Hello World! from fuga" in stdout and "Hello World! from hoge" in stdout

if succeeded:
    sys.exit(0)
else:
    sys.exit(1)

```

`tests/compare_stdout.py`:

```py
import subprocess
import sys
import os

comp = subprocess.run(sys.argv[1:], capture_output=True)
print("cmd:", " ".join(sys.argv[1:]))
stdout_sloader = comp.stdout.decode("utf-8")
print(f"{stdout_sloader=}")
stderr_sloader = comp.stderr.decode("utf-8")
print(f"{stderr_sloader=}")

comp = subprocess.run(sys.argv[2:], capture_output=True)
print("cmd:", " ".join(sys.argv[2:]))
stdout_ld = comp.stdout.decode("utf-8")
print(f"{stdout_ld=}")
stderr_ld = comp.stderr.decode("utf-8")
print(f"{stderr_ld=}")

succeeded = (stdout_sloader == stdout_ld)

if succeeded:
    sys.exit(0)
else:
    sys.exit(1)

```

`tests/constructor/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)

add_library(constructor_hoge SHARED hoge.c)
target_include_directories(constructor_hoge PRIVATE ${CMAKE_SOURCE_DIR})
add_executable(constructor_main main.c)
target_compile_options(constructor_main PUBLIC -fno-builtin)
target_link_libraries(constructor_main constructor_hoge -nostdlib)

add_test(
  NAME constructor_test
  COMMAND
    python3 ${CMAKE_CURRENT_SOURCE_DIR}/run.py ${CMAKE_BINARY_DIR}/sloader
    ${CMAKE_BINARY_DIR}/tests/constructor/constructor_main)

```

`tests/constructor/hoge.c`:

```c
#include "raw_write.h"

void before_main() __attribute__((constructor));
void before_main() {
    RAW_PRINT_STR("====== Before main ======\n");
}

unsigned long hoge_var = 0xdeadbeef;

// Ooops!
// We must define buf here as a global variable not as a local variable in
// print_hoge_var. Otherwise, the shared object depends on libc.so. I don't know
// the reason.
char buf[9];

void print_hex(unsigned long var) {
    // Simple itoa
    for (int i = 0; i < 8; i++) {
        char c = (var >> (4 * (7 - i))) & (0xf);
        c += (c < 10) ? '0' : 'a' - 10;
        buf[i] = c;
    }
    buf[8] = 0;

    RAW_PRINT_STR("print_hex: ");
    RAW_PRINT_STR(buf);
    RAW_PRINT_STR("\n");
}

void print_hoge_var() {
    // Simple itoa
    for (int i = 0; i < 8; i++) {
        char c = (hoge_var >> (4 * (7 - i))) & (0xf);
        c += (c < 10) ? '0' : 'a' - 10;
        buf[i] = c;
    }
    buf[8] = 0;

    RAW_PRINT_STR("====== print_hoge_var start ======\n");
    print_hex(hoge_var);
    print_hex((unsigned long)(&hoge_var));
    RAW_PRINT_STR("====== print_hoge_var end ======\n");
}

```

`tests/constructor/main.c`:

```c
extern int hoge_var;

void print_hoge_var();
void print_hex(unsigned long var);

int main() {
    print_hex(hoge_var);
    print_hex(&hoge_var);  // This address must be the same with print_hoge_var.

    print_hoge_var();  // Should be 0xdeadbeef
    hoge_var = 0xabcdef12;
    print_hoge_var();
    hoge_var = 0xaabbccdd;
    print_hoge_var();
    return 0;
}

```

`tests/constructor/run.py`:

```py
import subprocess
import sys

comp = subprocess.run(sys.argv[1:], capture_output=True)
print(comp)
print("cmd:", " ".join(sys.argv[1:]))
stdout = comp.stdout.decode("utf-8")
print("stdout:")
print(stdout)
succeeded = "====== Before main ======" in stdout

if succeeded:
    sys.exit(0)
else:
    sys.exit(1)

```

`tests/dlopen/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)

add_library(dlopen_hoge SHARED hoge.c)
add_executable(dlopen_main main.c)

add_test(
  NAME dlopen_test
  COMMAND
    python3 ${CMAKE_SOURCE_DIR}/tests/compare_stdout.py
    ${CMAKE_BINARY_DIR}/sloader ${CMAKE_BINARY_DIR}/tests/dlopen/dlopen_main
  WORKING_DIRECTORY ${CMAKE_BINARY_DIR}/tests/dlopen)

```

`tests/dlopen/hoge.c`:

```c
#include <stdio.h>

void hoge() {
    printf("hogehoge\n");
}

```

`tests/dlopen/main.c`:

```c
#include <dlfcn.h>
#include <stdio.h>
#include <stdlib.h>

int main() {
    void* handle = dlopen("./libdlopen_hoge.so", RTLD_NOW);
    if (handle == NULL) {
        printf("handle is NULL\n");
        exit(1);
    }
    void (*hoge_func)();
    *(void**)(&hoge_func) = dlsym(handle, "hoge");
    hoge_func();
}

```

`tests/dlopen2/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)

add_library(dlopen2_hoge SHARED hoge.c)
add_executable(dlopen2_main main.c)
target_link_options(dlopen2_main PRIVATE -export-dynamic)

add_test(
  NAME dlopen2_test
  COMMAND python3 ${CMAKE_SOURCE_DIR}/tests/compare_stdout.py
          ${CMAKE_BINARY_DIR}/sloader ${CMAKE_CURRENT_BINARY_DIR}/dlopen2_main
  WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})

```

`tests/dlopen2/hoge.c`:

```c
#include <stdio.h>

void fromMain();

void hoge() {
    printf("hogehoge\n");
    fromMain();
}

```

`tests/dlopen2/main.c`:

```c
#include <dlfcn.h>
#include <stdio.h>
#include <stdlib.h>

void fromMain() {
    printf("From main\n");
}

int main() {
    void* handle = dlopen("./libdlopen2_hoge.so", RTLD_NOW);
    if (handle == NULL) {
        printf("handle is NULL\n");
        exit(1);
    }
    void (*hoge_func)();
    *(void**)(&hoge_func) = dlsym(handle, "hoge");
    hoge_func();
}

```

`tests/errno/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)

add_executable(errno main.c)

add_test(
  NAME errno
  COMMAND python3 ${CMAKE_CURRENT_SOURCE_DIR}/run.py
          ${CMAKE_BINARY_DIR}/sloader ${CMAKE_BINARY_DIR}/tests/errno/errno)

```

`tests/errno/main.c`:

```c
#include <errno.h>
#include <stdio.h>
#include <string.h>

int main() {
    FILE* pf;
    int errnum;
    pf = fopen("unexist.txt", "rb");
    errnum = errno;

    printf("errno: %s\n", strerror(errnum));
    return 0;
}

```

`tests/errno/run.py`:

```py
import subprocess
import sys

comp = subprocess.run(sys.argv[1:], capture_output=True)
print(comp)
print("cmd:", " ".join(sys.argv[1:]))
stdout = comp.stdout.decode("utf-8", errors="ignore")
print("stdout:")
print(stdout)
succeeded = "errno: No such file or directory" in stdout

if succeeded:
    sys.exit(0)
else:
    sys.exit(1)

```

`tests/find_a_depending_so/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)

add_library(hoge SHARED hoge.c)
target_include_directories(hoge PRIVATE ${CMAKE_SOURCE_DIR})
add_executable(find_a_depending_so main.c)
target_compile_options(find_a_depending_so PUBLIC -fno-builtin)
target_link_libraries(find_a_depending_so hoge -nostdlib)

add_test(
  NAME find_a_depending_so_test
  COMMAND
    python3 ${CMAKE_CURRENT_SOURCE_DIR}/run.py ${CMAKE_BINARY_DIR}/sloader
    ${CMAKE_BINARY_DIR}/tests/find_a_depending_so/find_a_depending_so)

```

`tests/find_a_depending_so/hoge.c`:

```c
#include "raw_write.h"

int hoge(int a, int b) {
    RAW_PRINT_STR("Hello World!\n");
    return a + b;
}

```

`tests/find_a_depending_so/main.c`:

```c
int hoge(int a, int b);

int main() {
    return hoge(2, 40);
}

```

`tests/find_a_depending_so/run.py`:

```py
import subprocess
import sys

comp = subprocess.run(sys.argv[1:], capture_output=True)
print(comp)
stdout = comp.stdout.decode("utf-8")
succeeded = "Hello World!" in stdout

if succeeded:
    sys.exit(0)
else:
    sys.exit(1)

```

`tests/generic_dynamic/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)

add_library(generic_dynamic_hoge SHARED hoge.c)
add_executable(generic_dynamic main.c)
target_link_libraries(generic_dynamic generic_dynamic_hoge)

add_test(
  NAME generic_dynamic
  COMMAND
    python3 ${CMAKE_CURRENT_SOURCE_DIR}/run.py ${CMAKE_BINARY_DIR}/sloader
    ${CMAKE_BINARY_DIR}/tests/generic_dynamic/generic_dynamic)

```

`tests/generic_dynamic/hoge.c`:

```c
#include <stdint.h>
#include "raw_write.h"

__thread uint32_t i0 = 0xdeadbeef;

void f() {
    RAW_PRINT_STR("__thread uint32_t i0=");
    RAW_PRINT_HEX(i0);
    RAW_PRINT_STR("\n&i0=");
    RAW_PRINT_HEX(&i0);
    RAW_PRINT_STR("\n");
}

```

`tests/generic_dynamic/main.c`:

```c
void f();

int main() {
    f();
    return 0;
}

```

`tests/generic_dynamic/run.py`:

```py
import subprocess
import sys

comp = subprocess.run(sys.argv[1:], capture_output=True)
print("cmd:", " ".join(sys.argv[1:]))
stdout = comp.stdout.decode("utf-8")
print("stdout:")
print(stdout)
succeeded = "__thread uint32_t i0=deadbeef" in stdout

if succeeded:
    sys.exit(0)
else:
    sys.exit(1)

```

`tests/global_variable/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)

add_library(global_variable_hoge SHARED hoge.c)
target_include_directories(global_variable_hoge PRIVATE ${CMAKE_SOURCE_DIR})
add_executable(global_variable_main main.c)
target_compile_options(global_variable_main PUBLIC -fno-builtin)
target_link_libraries(global_variable_main global_variable_hoge -nostdlib)

add_test(
  NAME global_variable_test
  COMMAND
    python3 ${CMAKE_CURRENT_SOURCE_DIR}/run.py ${CMAKE_BINARY_DIR}/sloader
    ${CMAKE_BINARY_DIR}/tests/global_variable/global_variable_main)

```

`tests/global_variable/hoge.c`:

```c
#include "raw_write.h"

unsigned long hoge_var = 0xdeadbeef;

// Ooops!
// We must define buf here as a global variable not as a local variable in
// print_hoge_var. Otherwise, the shared object depends on libc.so. I don't know
// the reason.
char buf[9];

void print_hex(unsigned long var) {
    // Simple itoa
    for (int i = 0; i < 8; i++) {
        char c = (var >> (4 * (7 - i))) & (0xf);
        c += (c < 10) ? '0' : 'a' - 10;
        buf[i] = c;
    }
    buf[8] = 0;

    RAW_PRINT_STR("print_hex: ");
    RAW_PRINT_STR(buf);
    RAW_PRINT_STR("\n");
}

void print_hoge_var() {
    // Simple itoa
    for (int i = 0; i < 8; i++) {
        char c = (hoge_var >> (4 * (7 - i))) & (0xf);
        c += (c < 10) ? '0' : 'a' - 10;
        buf[i] = c;
    }
    buf[8] = 0;

    RAW_PRINT_STR("====== print_hoge_var start ======\n");
    print_hex(hoge_var);
    print_hex((unsigned long)(&hoge_var));
    RAW_PRINT_STR("====== print_hoge_var end ======\n");
}

```

`tests/global_variable/main.c`:

```c
extern int hoge_var;

void print_hoge_var();
void print_hex(unsigned long var);

int main() {
    print_hex(hoge_var);
    print_hex(&hoge_var);  // This address must be the same with print_hoge_var.

    print_hoge_var();  // Should be 0xdeadbeef
    hoge_var = 0xabcdef12;
    print_hoge_var();
    hoge_var = 0xaabbccdd;
    print_hoge_var();
    return 0;
}

```

`tests/global_variable/run.py`:

```py
import subprocess
import sys

comp = subprocess.run(sys.argv[1:], capture_output=True)
print(comp)
print("cmd:", " ".join(sys.argv[1:]))
stdout = comp.stdout.decode("utf-8", errors="ignore")
print("stdout:")
print(stdout)
succeeded = "deadbeef" in stdout and "abcdef12" in stdout and "aabbccdd" in stdout

if succeeded:
    sys.exit(0)
else:
    sys.exit(1)

```

`tests/hello.asm`:

```asm
;Copyright (c) 1999 Konstantin Boldyshev <konst@linuxassembly.org>
;
;"hello, world" in assembly language for Linux
;
;to build an executable:
;       nasm -f elf hello.asm
;       ld -s -o hello hello.o

section .text
; Export the entry point to the ELF linker or loader.  The conventional
; entry point is "_start". Use "ld -e foo" to override the default.
    global _start

section .data
msg db  'Hello, world!',0xa ;our dear string
len equ $ - msg         ;length of our dear string

section .text

; linker puts the entry point here:
_start:

; Write the string to stdout:

    mov edx,len ;message length
    mov ecx,msg ;message to write
    mov ebx,1   ;file descriptor (stdout)
    mov eax,4   ;system call number (sys_write)
    int 0x80    ;call kernel

; Exit via the kernel:

    mov ebx,0   ;process' exit code
    mov eax,1   ;system call number (sys_exit)
    int 0x80    ;call kernel - this interrupt won't return

```

`tests/hello.c`:

```c
#include <stdio.h>
#include <stdlib.h>

__thread int tls_i = 10;

static void before_main(void) __attribute__((constructor));
static void after_main(void) __attribute__((destructor));

static void before_main(void) {
    puts("before_main");
}

static void after_main(void) {
    puts("after_main");
}

void bye(void) {
    printf("That was all, folks\n");
}

int main() {
    puts("Hello from libc!");
    printf("tls_i = %d\n", tls_i);

    if (atexit(bye) != 0) {
        fprintf(stderr, "cannot set exit function\n");
        exit(EXIT_FAILURE);
    }

    exit(EXIT_SUCCESS);
    return 0;
}

```

`tests/hello.py`:

```py
print("Hello from hello.py")

```

`tests/hello_glibc/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)

add_executable(hello_glibc main.c)

add_test(
  NAME hello_glibc
  COMMAND
    python3 ${CMAKE_CURRENT_SOURCE_DIR}/run.py ${CMAKE_BINARY_DIR}/sloader
    ${CMAKE_BINARY_DIR}/tests/hello_glibc/hello_glibc)

```

`tests/hello_glibc/main.c`:

```c
#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#include "raw_write.h"

int main() {
    RAW_DEBUG_MESSAGE();
    RAW_NOP4();
    write(1, "Hello using write(2)\n", 21);
    RAW_DEBUG_MESSAGE();
    printf("Hello using printf(3)\n");

    const char str[] = "http://www.tutorialspoint.com";
    const char ch = '.';
    char* ret;

    ret = strchr(str, ch);

    printf("String after |%c| is - |%s|\n", ch, ret);

    fwrite("hogeh\n", sizeof(char), 6, stdout);
    return 0;
}

```

`tests/hello_glibc/run.py`:

```py
import subprocess
import sys

comp = subprocess.run(sys.argv[1:], capture_output=True)
print(comp)
print("cmd:", " ".join(sys.argv[1:]))
stdout = comp.stdout.decode("utf-8", errors="ignore")
print("stdout:")
print(stdout)
succeeded = "Hello using write(2)" in stdout and "Hello using printf(3)" in stdout

if succeeded:
    sys.exit(0)
else:
    sys.exit(1)

```

`tests/hello_static_glibc/CMakeLists.txt`:

```txt
add_executable(hello_static_glibc hello.c)
target_link_libraries(hello_static_glibc -static)

add_test(
  NAME hello_static_glibc_test
  COMMAND
    python3 ${CMAKE_CURRENT_SOURCE_DIR}/run.py ${CMAKE_BINARY_DIR}/sloader
    ${CMAKE_BINARY_DIR}/tests/hello_static_glibc/hello_static_glibc)

```

`tests/hello_static_glibc/hello.c`:

```c
#include <stdio.h>
#include <stdlib.h>

__thread int tls_i = 10;

static void before_main(void) __attribute__((constructor));
static void after_main(void) __attribute__((destructor));

static void before_main(void) {
    puts("before_main");
}

static void after_main(void) {
    puts("after_main");
}

void bye(void) {
    printf("That was all, folks\n");
}

int main() {
    puts("Hello from libc!");
    printf("tls_i = %d\n", tls_i);
    fflush(stdout);

    if (atexit(bye) != 0) {
        fprintf(stderr, "cannot set exit function\n");
        exit(EXIT_FAILURE);
    }

    exit(EXIT_SUCCESS);
    return 0;
}

```

`tests/hello_static_glibc/run.py`:

```py
import subprocess
import sys

comp = subprocess.run(sys.argv[1:], capture_output=True)
print("cmd:", " ".join(sys.argv[1:]))
stdout = comp.stdout.decode("utf-8")
print("comp.stdout: ", comp.stdout)
print("stdout:", stdout)
succeeded = "Hello from libc!" in stdout

if succeeded:
    sys.exit(0)
else:
    sys.exit(1)

```

`tests/initial_exec/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)

add_library(initial_exec_hoge SHARED hoge.c)
add_executable(initial_exec main.c)
target_link_libraries(initial_exec initial_exec_hoge)

add_test(
  NAME initial_exec
  COMMAND
    python3 ${CMAKE_CURRENT_SOURCE_DIR}/run.py ${CMAKE_BINARY_DIR}/sloader
    ${CMAKE_BINARY_DIR}/tests/initial_exec/initial_exec)
set_tests_properties(initial_exec PROPERTIES WILL_FAIL TRUE)

```

`tests/initial_exec/hoge.c`:

```c
#include <stdint.h>

__thread uint32_t i0 = 0xaaaaaaaa;
__thread uint32_t i1 = 0xbbbbbbbb;
__thread uint32_t i2 = 0xcccccccc;
__thread uint32_t i3 = 0xdddddddd;
uint32_t j = 0xaabbccdd;

```

`tests/initial_exec/main.c`:

```c
#include <assert.h>
#include <stdint.h>

#include "raw_write.h"

extern __thread uint32_t i0;
extern __thread uint32_t i1;
extern __thread uint32_t i2;
extern __thread uint32_t i3;
extern uint32_t j;

void set_i0() {
    i0 = 0xaabbccdd;
}

int main() {
    RAW_PRINT_STR("__thread uint32_t i0=");
    RAW_PRINT_HEX(i0);
    RAW_PRINT_STR("\n&i0=");
    RAW_PRINT_HEX(&i0);
    RAW_PRINT_STR("\n");

    RAW_PRINT_STR("__thread uint32_t i1=");
    RAW_PRINT_HEX(i1);
    RAW_PRINT_STR("\n&i1=");
    RAW_PRINT_HEX(&i1);
    RAW_PRINT_STR("\n");

    RAW_PRINT_STR("__thread uint32_t i2=");
    RAW_PRINT_HEX(i2);
    RAW_PRINT_STR("\n&i2=");
    RAW_PRINT_HEX(&i2);
    RAW_PRINT_STR("\n");

    RAW_PRINT_STR("__thread uint32_t i3=");
    RAW_PRINT_HEX(i3);
    RAW_PRINT_STR("\n&i3=");
    RAW_PRINT_HEX(&i3);
    RAW_PRINT_STR("\n");

    // RAW_BREAK();
    i0 = 0xeeeeeeee;
    i1 = 0xffffffff;

    RAW_PRINT_STR("__thread uint32_t i0=");
    RAW_PRINT_HEX(i0);
    RAW_PRINT_STR("\n&i0=");
    RAW_PRINT_HEX(&i0);
    RAW_PRINT_STR("\n");

    RAW_PRINT_STR("\nShould be 0xaabbccdd: uint32_t j=");
    RAW_PRINT_HEX(j);
    RAW_PRINT_STR("\n&j=");
    RAW_PRINT_HEX(&j);
    RAW_PRINT_STR("\n");
    return 0;
}

```

`tests/initial_exec/run.py`:

```py
import subprocess
import sys

comp = subprocess.run(sys.argv[1:], capture_output=True)
print("cmd:", " ".join(sys.argv[1:]))
stdout = comp.stdout.decode("utf-8")
print("stdout:")
print(stdout)
succeeded = "__thread uint32_t i0=aaaaaaaa" in stdout and "__thread uint32_t i1=bbbbbbbb" in stdout and "__thread uint32_t i2=cccccccc" in stdout and "__thread uint32_t i3=dddddddd" in stdout and "Should be 0xaabbccdd: uint32_t j=aabbccdd" in stdout and "__thread uint32_t i0=eeeeeeee" in stdout 

if succeeded:
    sys.exit(0)
else:
    sys.exit(1)

```

`tests/local_dynamic/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)

add_library(local_dynamic_hoge SHARED hoge.c)
add_executable(local_dynamic main.c)
target_link_libraries(local_dynamic local_dynamic_hoge)

add_test(
  NAME local_dynamic
  COMMAND
    python3 ${CMAKE_CURRENT_SOURCE_DIR}/run.py ${CMAKE_BINARY_DIR}/sloader
    ${CMAKE_BINARY_DIR}/tests/local_dynamic/local_dynamic)

```

`tests/local_dynamic/hoge.c`:

```c
#include <stdint.h>
#include "raw_write.h"

static __thread uint32_t i0 = 0xdeadbeef;
static __thread uint32_t i1 = 0xeeeeeeee;

void f() {
    RAW_PRINT_STR("__thread uint32_t i0=");
    RAW_PRINT_HEX(i0);
    RAW_PRINT_STR("\n&i0=");
    RAW_PRINT_HEX(&i0);
    RAW_PRINT_STR("\n");

    RAW_PRINT_STR("__thread uint32_t i1=");
    RAW_PRINT_HEX(i1);
    RAW_PRINT_STR("\n&i1=");
    RAW_PRINT_HEX(&i1);
    RAW_PRINT_STR("\n");
}

```

`tests/local_dynamic/main.c`:

```c
void f();

int main() {
    f();
    return 0;
}

```

`tests/local_dynamic/run.py`:

```py
import subprocess
import sys

comp = subprocess.run(sys.argv[1:], capture_output=True)
print("cmd:", " ".join(sys.argv[1:]))
stdout = comp.stdout.decode("utf-8")
print("stdout:")
print(stdout)
succeeded = "__thread uint32_t i0=deadbeef" in stdout

if succeeded:
    sys.exit(0)
else:
    sys.exit(1)

```

`tests/local_exec/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)

add_executable(local_exec main.c)

add_test(
  NAME local_exec
  COMMAND
    python3 ${CMAKE_CURRENT_SOURCE_DIR}/run.py ${CMAKE_BINARY_DIR}/sloader
    ${CMAKE_BINARY_DIR}/tests/local_exec/local_exec)
set_tests_properties(local_exec PROPERTIES WILL_FAIL TRUE)

```

`tests/local_exec/main.c`:

```c
#include <assert.h>
#include <stdint.h>

#include "raw_write.h"

__thread uint32_t i0 = 0xdeadbeef;
__thread uint32_t i1 = 0xabcdabcd;
__thread uint32_t i2 = 0x01234567;
__thread uint32_t i3 = 0x90abcdef;
__thread uint32_t i4;
__thread uint32_t i5;
// uint32_t j = 0xaabbccdd;

void set() {
    i0 = 0xabcdabcd;
}

int main() {
    // RAW_BREAK();
    // i0 = 0xdeadbeef;

    RAW_PRINT_STR("__thread uint32_t i0=");
    RAW_PRINT_HEX(i0);
    RAW_PRINT_STR("\n");
    RAW_PRINT_STR("__thread uint32_t i1=");
    RAW_PRINT_HEX(i1);
    RAW_PRINT_STR("\n");
    RAW_PRINT_STR("__thread uint32_t i2=");
    RAW_PRINT_HEX(i2);
    RAW_PRINT_STR("\n");
    RAW_PRINT_STR("__thread uint32_t i3=");
    RAW_PRINT_HEX(i3);
    RAW_PRINT_STR("\n");
    RAW_PRINT_STR("__thread uint32_t i4=");
    RAW_PRINT_HEX(i4);
    RAW_PRINT_STR("\n");
    RAW_PRINT_STR("__thread uint32_t i5=");
    RAW_PRINT_HEX(i5);
    RAW_PRINT_STR("\n");

    RAW_PRINT_STR("&i0=0x");
    RAW_PRINT_HEX(&i0);
    // RAW_BREAK();
    RAW_PRINT_STR("\n&i1=0x");
    RAW_PRINT_HEX(&i1);
    RAW_PRINT_STR("\n&i2=0x");
    RAW_PRINT_HEX(&i2);
    RAW_PRINT_STR("\n&i3=0x");
    RAW_PRINT_HEX(&i3);
    RAW_PRINT_STR("\n&i4=0x");
    RAW_PRINT_HEX(&i4);
    RAW_PRINT_STR("\n&i5=0x");
    RAW_PRINT_HEX(&i5);

    // RAW_PRINT_STR("\nShould be 0xaabbccdd: uint32_t j=");
    // RAW_PRINT_HEX(j);
    // RAW_PRINT_STR("\n&j=");
    // RAW_PRINT_HEX(&j);
    return 0;
}

```

`tests/local_exec/run.py`:

```py
import subprocess
import sys

comp = subprocess.run(sys.argv[1:], capture_output=True)
print("cmd:", " ".join(sys.argv[1:]))
stdout = comp.stdout.decode("utf-8")
print("stdout:")
print(stdout)
succeeded = "__thread uint32_t i0=deadbeef" in stdout and "__thread uint32_t i1=abcdabcd" in stdout and "__thread uint32_t i2=1234567" in stdout and "__thread uint32_t i3=90abcdef" in stdout and "__thread uint32_t i3=90abcdef" in stdout and "__thread uint32_t i4=0" in stdout and "__thread uint32_t i5=0" in stdout

if succeeded:
    sys.exit(0)
else:
    sys.exit(1)

```

`tests/ls/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)

add_executable(ls ls.c)

add_test(
  NAME ls_test
  COMMAND python3 ${CMAKE_CURRENT_SOURCE_DIR}/run.py ${CMAKE_BINARY_DIR}/sloader
          ${CMAKE_BINARY_DIR}/tests/ls/ls
  WORKING_DIRECTORY ${CMAKE_BINARY_DIR}/tests/ls)

```

`tests/ls/ls.c`:

```c
// Used for basic input/output stream
#include <stdio.h>
// Used for handling directory files
#include <dirent.h>
// For EXIT codes and error handling
#include <errno.h>
#include <stdlib.h>

void _ls(const char* dir, int op_a, int op_l) {
    // Here we will list the directory
    struct dirent* d;
    DIR* dh = opendir(dir);
    if (!dh) {
        if (errno == ENOENT) {
            // If the directory is not found
            perror("Directory doesn't exist");
        } else {
            // If the directory is not readable then throw error and exit
            perror("Unable to read directory");
        }
        exit(EXIT_FAILURE);
    }
    // While the next entry is not readable we will print directory files
    while ((d = readdir(dh)) != NULL) {
        // If hidden files are found we continue
        if (!op_a && d->d_name[0] == '.') continue;
        printf("%s  ", d->d_name);
        if (op_l) printf("\n");
    }
    if (!op_l) printf("\n");
}

int main(int argc, const char* argv[]) {
    if (argc == 1) {
        _ls(".", 0, 0);
    } else if (argc == 2) {
        if (argv[1][0] == '-') {
            // Checking if option is passed
            // Options supporting: a, l
            int op_a = 0, op_l = 0;
            char* p = (char*)(argv[1] + 1);
            while (*p) {
                if (*p == 'a')
                    op_a = 1;
                else if (*p == 'l')
                    op_l = 1;
                else {
                    perror("Option not available");
                    exit(EXIT_FAILURE);
                }
                p++;
            }
            _ls(".", op_a, op_l);
        }
    }
    return 0;
}

```

`tests/ls/run.py`:

```py
import subprocess
import sys

comp = subprocess.run(sys.argv[1:], capture_output=True)
print(comp)
print("cmd:", " ".join(sys.argv[1:]))
stdout = comp.stdout.decode("utf-8", errors="ignore")
print("stdout:")
print(stdout)
succeeded = "ls" in stdout

if succeeded:
    sys.exit(0)
else:
    sys.exit(1)

```

`tests/one_plus_one.sh`:

```sh
echo $((1 + 1))

```

`tests/print_args/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)

add_executable(print_args main.c)

add_test(
  NAME print_args
  COMMAND
    python3 ${CMAKE_CURRENT_SOURCE_DIR}/run.py ${CMAKE_BINARY_DIR}/sloader
    ${CMAKE_BINARY_DIR}/tests/print_args/print_args hoge fuga)

```

`tests/print_args/main.c`:

```c
#include <stdio.h>

int main(int argc, char** argv) {
    int i;
    printf("%d\n", argc);
    for (i = 0; i < argc; i++) {
        printf("%s\n", argv[i]);
    }
    return 0;
}

```

`tests/print_args/run.py`:

```py
import subprocess
import sys

comp = subprocess.run(sys.argv[1:], capture_output=True, bufsize=0)
print(comp)
print("cmd: ", " ".join(sys.argv[1:]))
stdout = comp.stdout.decode("utf-8")
print("stdout:")
print(stdout)
succeeded = "hoge" in stdout and "fuga" in stdout

if succeeded:
    sys.exit(0)
else:
    sys.exit(1)

```

`tests/print_env_aux/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)

add_executable(print_env_aux print_env_aux.c)
target_link_options(print_env_aux PUBLIC -static)

add_test(
  NAME print_env_aux
  COMMAND
    python3 ${CMAKE_CURRENT_SOURCE_DIR}/run.py ${CMAKE_BINARY_DIR}/sloader
    ${CMAKE_BINARY_DIR}/tests/print_env_aux/print_env_aux)

```

`tests/print_env_aux/print_env_aux.c`:

```c
#include <stdio.h>
#include <sys/auxv.h>

int main(int argc, char** argv, char** envp) {
    char* aux_names[] = {
        "AT_NULL",           "AT_IGNORE",
        "AT_EXECFD",         "AT_PHDR",
        "AT_PHENT",          "AT_PHNUM",
        "AT_PAGESZ",         "AT_BASE",
        "AT_FLAGS",          "AT_ENTRY",
        "AT_NOTELF",         "AT_UID",
        "AT_EUID",           "AT_GID",
        "AT_EGID",           "AT_CLKTCK",
        "AT_PLATFORM",       "AT_HWCAP",
        "AT_FPUCW",          "AT_DCACHEBSIZE",
        "AT_ICACHEBSIZE",    "AT_UCACHEBSIZE",
        "AT_IGNOREPPC",      "AT_SECURE",
        "AT_BASE_PLATFORM",  "AT_RANDOM",
        "AT_HWCAP2",         "AT_EXECFN",
        "AT_SYSINFO",        "AT_SYSINFO_EHDR",
        "AT_L1I_CACHESHAPE", "AT_L1D_CACHESHAPE",
        "AT_L2_CACHESHAPE",  "AT_L3_CACHESHAPE",
        "AT_L1I_CACHESIZE",  "AT_L1I_CACHEGEOMETRY",
        "AT_L1D_CACHESIZE",  "AT_L1D_CACHEGEOMETRY",
        "AT_L2_CACHESIZE",   "AT_L2_CACHEGEOMETRY",
        "AT_L3_CACHESIZE",   "AT_L3_CACHEGEOMETRY",
        "AT_MINSIGSTKSZ",
    };
    unsigned long aux_types[] = {AT_NULL,           AT_IGNORE,
                                 AT_EXECFD,         AT_PHDR,
                                 AT_PHENT,          AT_PHNUM,
                                 AT_PAGESZ,         AT_BASE,
                                 AT_FLAGS,          AT_ENTRY,
                                 AT_NOTELF,         AT_UID,
                                 AT_EUID,           AT_GID,
                                 AT_EGID,           AT_CLKTCK,
                                 AT_PLATFORM,       AT_HWCAP,
                                 AT_FPUCW,          AT_DCACHEBSIZE,
                                 AT_ICACHEBSIZE,    AT_UCACHEBSIZE,
                                 AT_IGNOREPPC,      AT_SECURE,
                                 AT_BASE_PLATFORM,  AT_RANDOM,
                                 AT_HWCAP2,         AT_EXECFN,
                                 AT_SYSINFO,        AT_SYSINFO_EHDR,
                                 AT_L1I_CACHESHAPE, AT_L1D_CACHESHAPE,
                                 AT_L2_CACHESHAPE,  AT_L3_CACHESHAPE,
                                 AT_L1I_CACHESIZE,  AT_L1I_CACHEGEOMETRY,
                                 AT_L1D_CACHESIZE,  AT_L1D_CACHEGEOMETRY,
                                 AT_L2_CACHESIZE,   AT_L2_CACHEGEOMETRY,
                                 AT_L3_CACHESIZE,   AT_L3_CACHEGEOMETRY,
                                 AT_MINSIGSTKSZ};
    int n_aux_types = 43;
    for (int i = 0; i < n_aux_types; i++) {
        printf("%s = %lu\n", aux_names[i], getauxval(aux_types[i]));
    }

    for (char** env = envp; *env != 0; env++) {
        char* thisEnv = *env;
        printf("%s\n", thisEnv);
    }
    // TODO: Need this?
    fflush(stdout);
    return 0;
}

```

`tests/print_env_aux/run.py`:

```py
import subprocess
import sys

comp = subprocess.run(sys.argv[1:], capture_output=True, bufsize=0)
print(comp)
print("cmd: ", " ".join(sys.argv[1:]))
stdout = comp.stdout.decode("utf-8")
print("stdout:")
print(stdout)
succeeded = "AT_RANDOM" in stdout and "PATH" in stdout

if succeeded:
    sys.exit(0)
else:
    sys.exit(1)

```

`tests/static_struct/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)

add_library(static_struct_hoge SHARED hoge.c)
target_include_directories(static_struct_hoge PRIVATE ${CMAKE_SOURCE_DIR})
add_executable(static_struct_main main.c)
target_compile_options(static_struct_main PUBLIC -fno-builtin)
target_link_libraries(static_struct_main static_struct_hoge -nostdlib)

add_test(
  NAME static_struct_test
  COMMAND
    python3 ${CMAKE_CURRENT_SOURCE_DIR}/run.py ${CMAKE_BINARY_DIR}/sloader
    ${CMAKE_BINARY_DIR}/tests/static_struct/static_struct_main)

```

`tests/static_struct/hoge.c`:

```c
#include "raw_write.h"

// Ooops!
// We must define buf here as a global variable not as a local variable in
// print_hoge_var. Otherwise, the shared object depends on libc.so. I don't know
// the reason.
char buf[9];

struct Hoge {
    int idx;
    char buf[16];
    void* p;
};

static struct Hoge hoge;

void print_hex(unsigned long var) {
    // Simple itoa
    for (int i = 0; i < 8; i++) {
        char c = (var >> (4 * (7 - i))) & (0xf);
        c += (c < 10) ? '0' : 'a' - 10;
        buf[i] = c;
    }
    buf[8] = 0;

    RAW_PRINT_STR(buf);
    RAW_PRINT_STR("\n");
}

void print_hoge_var() {
    hoge.idx = 0xdeadbeef;
    RAW_PRINT_STR("hoge.idx=0x");
    print_hex(hoge.idx);
    RAW_PRINT_STR("\n");
}

```

`tests/static_struct/main.c`:

```c
void print_hoge_var();

int main() {
    print_hoge_var();
    return 0;
}

```

`tests/static_struct/run.py`:

```py
import subprocess
import sys

comp = subprocess.run(sys.argv[1:], capture_output=True)
print(comp)
print("cmd:", " ".join(sys.argv[1:]))
stdout = comp.stdout.decode("utf-8")
print("stdout:")
print(stdout)
succeeded = "hoge.idx=0xdeadbeef" in stdout

if succeeded:
    sys.exit(0)
else:
    sys.exit(1)

```

`tests/torch_ones.py`:

```py
import torch

print(torch.ones((2,2)))

```

`third_party/glog.cmake`:

```cmake
cmake_minimum_required(VERSION 3.4)
project(glog-download NONE)

include(ExternalProject)
ExternalProject_Add(glog
    GIT_REPOSITORY    https://github.com/google/glog.git
    GIT_TAG           v0.6.0
    SOURCE_DIR        "${CMAKE_CURRENT_BINARY_DIR}/glog"
    BINARY_DIR        ""
    CONFIGURE_COMMAND ""
    BUILD_COMMAND     ""
    INSTALL_COMMAND   ""
    TEST_COMMAND      ""
    CMAKE_ARGS
    -DCMAKE_INSTALL_MESSAGE=LAZY
    -DCMAKE_POSITION_INDEPENDENT_CODE=ON
    )

```

`tls_secure.cc`:

```cc
// This file is to secure memory space just after %fs register.

constexpr int TLS_SPACE_FOR_LOADEE = 4096;
thread_local unsigned char sloader_dummy_to_secure_tls_space[TLS_SPACE_FOR_LOADEE] = {0, 0, 0, 0};
unsigned long sloader_tls_offset = 4096;

void write_sloader_dummy_to_secure_tls_space() {
    sloader_dummy_to_secure_tls_space[0] = 0xaa;
    sloader_dummy_to_secure_tls_space[1] = 0xaa;
    sloader_dummy_to_secure_tls_space[2] = 0xaa;
    sloader_dummy_to_secure_tls_space[3] = 0xaa;
    sloader_dummy_to_secure_tls_space[TLS_SPACE_FOR_LOADEE - 4] = 0xab;
    sloader_dummy_to_secure_tls_space[TLS_SPACE_FOR_LOADEE - 3] = 0xcd;
    sloader_dummy_to_secure_tls_space[TLS_SPACE_FOR_LOADEE - 2] = 0xab;
    sloader_dummy_to_secure_tls_space[TLS_SPACE_FOR_LOADEE - 1] = 0xcd;
}

```

`ubuntu-Dockerfile`:

```
FROM ubuntu:22.04
ENV DEBIAN_FRONTEND=noninteractive
RUN apt-get update && apt-get install -y ninja-build cmake gcc g++ git python3 python3-distutils python3-dev python3-pip nasm clang-format libcap-dev tmux zsh neovim
RUN pip3 install torch==1.13.0+cpu -f https://download.pytorch.org/whl/torch_stable.html
COPY . /sloader
WORKDIR /sloader
# TODO
# RUN ./run-format.sh
RUN rm -rf build
RUN mkdir build
RUN cmake -GNinja -S . -B build
RUN cmake --build build
RUN cd build && ctest --output-on-failure -j $(nproc)
RUN ./make-sloader-itself.sh

```

`ubuntu_usr_bin_commands`:

```
/usr/bin/VGAuthService
/usr/bin/[
/usr/bin/aa-enabled
/usr/bin/aa-exec
/usr/bin/add-apt-repository
/usr/bin/addpart
/usr/bin/apport-bug
/usr/bin/apport-cli
/usr/bin/apport-unpack
/usr/bin/appres
/usr/bin/apt
/usr/bin/apt-cache
/usr/bin/apt-cdrom
/usr/bin/apt-config
/usr/bin/apt-extracttemplates
/usr/bin/apt-ftparchive
/usr/bin/apt-get
/usr/bin/apt-key
/usr/bin/apt-mark
/usr/bin/apt-sortpkgs
/usr/bin/arch
/usr/bin/at
/usr/bin/automat-visualize3
/usr/bin/b2sum
/usr/bin/base32
/usr/bin/base64
/usr/bin/basename
/usr/bin/bash
/usr/bin/bashbug
/usr/bin/batch
/usr/bin/bc
/usr/bin/boltctl
/usr/bin/bootctl
/usr/bin/bsd-from
/usr/bin/bsd-write
/usr/bin/btrfs
/usr/bin/btrfs-convert
/usr/bin/btrfs-find-root
/usr/bin/btrfs-image
/usr/bin/btrfs-map-logical
/usr/bin/btrfs-select-super
/usr/bin/btrfstune
/usr/bin/bunzip2
/usr/bin/busctl
/usr/bin/busybox
/usr/bin/byobu
/usr/bin/byobu-config
/usr/bin/byobu-ctrl-a
/usr/bin/byobu-disable
/usr/bin/byobu-disable-prompt
/usr/bin/byobu-enable
/usr/bin/byobu-enable-prompt
/usr/bin/byobu-export
/usr/bin/byobu-janitor
/usr/bin/byobu-keybindings
/usr/bin/byobu-launch
/usr/bin/byobu-launcher
/usr/bin/byobu-launcher-install
/usr/bin/byobu-launcher-uninstall
/usr/bin/byobu-layout
/usr/bin/byobu-prompt
/usr/bin/byobu-quiet
/usr/bin/byobu-reconnect-sockets
/usr/bin/byobu-select-backend
/usr/bin/byobu-select-profile
/usr/bin/byobu-select-session
/usr/bin/byobu-shell
/usr/bin/byobu-silent
/usr/bin/byobu-status
/usr/bin/byobu-status-detail
/usr/bin/byobu-ugraph
/usr/bin/byobu-ulevel
/usr/bin/bzcat
/usr/bin/bzdiff
/usr/bin/bzexe
/usr/bin/bzgrep
/usr/bin/bzip2
/usr/bin/bzip2recover
/usr/bin/bzmore
/usr/bin/c_rehash
/usr/bin/calendar
/usr/bin/cat
/usr/bin/catchsegv
/usr/bin/catman
/usr/bin/cautious-launcher
/usr/bin/cftp3
/usr/bin/chage
/usr/bin/chardetect3
/usr/bin/chattr
/usr/bin/chcon
/usr/bin/check-language-support
/usr/bin/chfn
/usr/bin/chgrp
/usr/bin/chmod
/usr/bin/choom
/usr/bin/chown
/usr/bin/chrt
/usr/bin/chsh
/usr/bin/chvt
/usr/bin/ckbcomp
/usr/bin/ckeygen3
/usr/bin/cksum
/usr/bin/clear
/usr/bin/clear_console
/usr/bin/cloud-id
/usr/bin/cloud-init
/usr/bin/cloud-init-per
/usr/bin/cmp
/usr/bin/codepage
/usr/bin/col
/usr/bin/col1
/usr/bin/colcrt
/usr/bin/colrm
/usr/bin/column
/usr/bin/comm
/usr/bin/conch3
/usr/bin/corelist
/usr/bin/cp
/usr/bin/cpan
/usr/bin/cpan5.30-x86_64-linux-gnu
/usr/bin/cpio
/usr/bin/crontab
/usr/bin/csplit
/usr/bin/ctail
/usr/bin/curl
/usr/bin/cut
/usr/bin/cvtsudoers
/usr/bin/dash
/usr/bin/date
/usr/bin/dbus-cleanup-sockets
/usr/bin/dbus-daemon
/usr/bin/dbus-launch
/usr/bin/dbus-monitor
/usr/bin/dbus-run-session
/usr/bin/dbus-send
/usr/bin/dbus-update-activation-environment
/usr/bin/dbus-uuidgen
/usr/bin/dd
/usr/bin/deallocvt
/usr/bin/deb-systemd-helper
/usr/bin/deb-systemd-invoke
/usr/bin/debconf
/usr/bin/debconf-apt-progress
/usr/bin/debconf-communicate
/usr/bin/debconf-copydb
/usr/bin/debconf-escape
/usr/bin/debconf-set-selections
/usr/bin/debconf-show
/usr/bin/delpart
/usr/bin/delv
/usr/bin/df
/usr/bin/dfu-tool
/usr/bin/dh_bash-completion
/usr/bin/diff
/usr/bin/diff3
/usr/bin/dig
/usr/bin/dir
/usr/bin/dircolors
/usr/bin/dirmngr
/usr/bin/dirmngr-client
/usr/bin/dirname
/usr/bin/dmesg
/usr/bin/do-release-upgrade
/usr/bin/dpkg
/usr/bin/dpkg-deb
/usr/bin/dpkg-divert
/usr/bin/dpkg-maintscript-helper
/usr/bin/dpkg-query
/usr/bin/dpkg-split
/usr/bin/dpkg-statoverride
/usr/bin/dpkg-trigger
/usr/bin/du
/usr/bin/dumpkeys
/usr/bin/eatmydata
/usr/bin/ec2metadata
/usr/bin/echo
/usr/bin/ed
/usr/bin/editres
/usr/bin/egrep
/usr/bin/eject
/usr/bin/enc2xs
/usr/bin/encguess
/usr/bin/env
/usr/bin/envsubst
/usr/bin/eqn
/usr/bin/expand
/usr/bin/expiry
/usr/bin/expr
/usr/bin/factor
/usr/bin/faillog
/usr/bin/fallocate
/usr/bin/false
/usr/bin/fgconsole
/usr/bin/fgrep
/usr/bin/file
/usr/bin/finalrd
/usr/bin/fincore
/usr/bin/find
/usr/bin/findmnt
/usr/bin/flock
/usr/bin/fmt
/usr/bin/fold
/usr/bin/free
/usr/bin/fuser
/usr/bin/fusermount
/usr/bin/fwupdagent
/usr/bin/fwupdate
/usr/bin/fwupdmgr
/usr/bin/fwupdtool
/usr/bin/fwupdtpmevlog
/usr/bin/gapplication
/usr/bin/gawk
/usr/bin/gdbus
/usr/bin/getconf
/usr/bin/getent
/usr/bin/getkeycodes
/usr/bin/getopt
/usr/bin/gettext
/usr/bin/gettext.sh
/usr/bin/gio
/usr/bin/git
/usr/bin/git-shell
/usr/bin/gpasswd
/usr/bin/gpg
/usr/bin/gpg-agent
/usr/bin/gpg-connect-agent
/usr/bin/gpg-wks-server
/usr/bin/gpg-zip
/usr/bin/gpgcompose
/usr/bin/gpgconf
/usr/bin/gpgparsemail
/usr/bin/gpgsm
/usr/bin/gpgsplit
/usr/bin/gpgtar
/usr/bin/gpgv
/usr/bin/grep
/usr/bin/gresource
/usr/bin/groff
/usr/bin/grog
/usr/bin/grops
/usr/bin/grotty
/usr/bin/groups
/usr/bin/growpart
/usr/bin/gsettings
/usr/bin/gunzip
/usr/bin/gzexe
/usr/bin/gzip
/usr/bin/h2ph
/usr/bin/h2xs
/usr/bin/head
/usr/bin/helpztags
/usr/bin/hexdump
/usr/bin/host
/usr/bin/hostid
/usr/bin/hostname
/usr/bin/hostnamectl
/usr/bin/htop
/usr/bin/hwe-support-status
/usr/bin/iconv
/usr/bin/id
/usr/bin/info
/usr/bin/infocmp
/usr/bin/install
/usr/bin/install-info
/usr/bin/instmodsh
/usr/bin/ionice
/usr/bin/ip
/usr/bin/ipcmk
/usr/bin/ipcrm
/usr/bin/ipcs
/usr/bin/ischroot
/usr/bin/join
/usr/bin/journalctl
/usr/bin/json_pp
/usr/bin/jsonpatch
/usr/bin/jsonpatch-jsondiff
/usr/bin/jsonpointer
/usr/bin/jsonschema
/usr/bin/kbd_mode
/usr/bin/kbdinfo
/usr/bin/kbxutil
/usr/bin/kernel-install
/usr/bin/keyring
/usr/bin/kill
/usr/bin/killall
/usr/bin/kmod
/usr/bin/kmodsign
/usr/bin/landscape-sysinfo
/usr/bin/last
/usr/bin/lastlog
/usr/bin/lcf
/usr/bin/ldd
/usr/bin/less
/usr/bin/lessecho
/usr/bin/lesskey
/usr/bin/lesspipe
/usr/bin/lexgrog
/usr/bin/libnetcfg
/usr/bin/link
/usr/bin/linux-check-removal
/usr/bin/linux-update-symlinks
/usr/bin/linux-version
/usr/bin/listres
/usr/bin/ln
/usr/bin/lnstat
/usr/bin/loadkeys
/usr/bin/loadunimap
/usr/bin/locale
/usr/bin/locale-check
/usr/bin/localectl
/usr/bin/localedef
/usr/bin/logger
/usr/bin/login
/usr/bin/loginctl
/usr/bin/logname
/usr/bin/look
/usr/bin/lorder
/usr/bin/lowntfs-3g
/usr/bin/ls
/usr/bin/lsattr
/usr/bin/lsb_release
/usr/bin/lsblk
/usr/bin/lscpu
/usr/bin/lshw
/usr/bin/lsinitramfs
/usr/bin/lsipc
/usr/bin/lslocks
/usr/bin/lslogins
/usr/bin/lsmem
/usr/bin/lsns
/usr/bin/lsof
/usr/bin/lspci
/usr/bin/lspgpot
/usr/bin/lsusb
/usr/bin/ltrace
/usr/bin/luit
/usr/bin/lz4
/usr/bin/lzmainfo
/usr/bin/mailmail3
/usr/bin/man
/usr/bin/man-recode
/usr/bin/mandb
/usr/bin/manifest
/usr/bin/manpath
/usr/bin/mapscrn
/usr/bin/mawk
/usr/bin/mcookie
/usr/bin/md5sum
/usr/bin/mdig
/usr/bin/mesa-overlay-control.py
/usr/bin/mesg
/usr/bin/migrate-pubring-from-classic-gpg
/usr/bin/miniterm
/usr/bin/mk_modmap
/usr/bin/mkdir
/usr/bin/mkfifo
/usr/bin/mknod
/usr/bin/mksquashfs
/usr/bin/mktemp
/usr/bin/more
/usr/bin/mount
/usr/bin/mountpoint
/usr/bin/mt-gnu
/usr/bin/mtr
/usr/bin/mtr-packet
/usr/bin/mv
/usr/bin/namei
/usr/bin/nano
/usr/bin/nc.openbsd
/usr/bin/ncal
/usr/bin/neqn
/usr/bin/netkit-ftp
/usr/bin/networkctl
/usr/bin/networkd-dispatcher
/usr/bin/newgrp
/usr/bin/ngettext
/usr/bin/nice
/usr/bin/nl
/usr/bin/nohup
/usr/bin/nproc
/usr/bin/nroff
/usr/bin/nsenter
/usr/bin/nslookup
/usr/bin/nstat
/usr/bin/nsupdate
/usr/bin/ntfs-3g
/usr/bin/ntfs-3g.probe
/usr/bin/ntfscat
/usr/bin/ntfscluster
/usr/bin/ntfscmp
/usr/bin/ntfsdecrypt
/usr/bin/ntfsfallocate
/usr/bin/ntfsfix
/usr/bin/ntfsinfo
/usr/bin/ntfsls
/usr/bin/ntfsmove
/usr/bin/ntfsrecover
/usr/bin/ntfssecaudit
/usr/bin/ntfstruncate
/usr/bin/ntfsusermap
/usr/bin/ntfswipe
/usr/bin/numfmt
/usr/bin/od
/usr/bin/oem-getlogs
/usr/bin/openssl
/usr/bin/openvt
/usr/bin/pa-info
/usr/bin/pacat
/usr/bin/pacmd
/usr/bin/pactl
/usr/bin/padsp
/usr/bin/partx
/usr/bin/passwd
/usr/bin/paste
/usr/bin/pastebinit
/usr/bin/pasuspender
/usr/bin/patch
/usr/bin/pathchk
/usr/bin/pax11publish
/usr/bin/pbput
/usr/bin/peekfd
/usr/bin/perl
/usr/bin/perl5.30-x86_64-linux-gnu
/usr/bin/perl5.30.0
/usr/bin/perlbug
/usr/bin/perldoc
/usr/bin/perlivp
/usr/bin/perlthanks
/usr/bin/pgrep
/usr/bin/pic
/usr/bin/piconv
/usr/bin/pinentry-curses
/usr/bin/ping
/usr/bin/pinky
/usr/bin/pkaction
/usr/bin/pkcheck
/usr/bin/pkcon
/usr/bin/pkexec
/usr/bin/pkmon
/usr/bin/pkttyagent
/usr/bin/pl2pm
/usr/bin/pldd
/usr/bin/plymouth
/usr/bin/pmap
/usr/bin/pod2html
/usr/bin/pod2man
/usr/bin/pod2text
/usr/bin/pod2usage
/usr/bin/podchecker
/usr/bin/podselect
/usr/bin/pollinate
/usr/bin/pr
/usr/bin/preconv
/usr/bin/printenv
/usr/bin/printerbanner
/usr/bin/printf
/usr/bin/prlimit
/usr/bin/prove
/usr/bin/prtstat
/usr/bin/ps
/usr/bin/psfxtable
/usr/bin/pslog
/usr/bin/pstree
/usr/bin/ptar
/usr/bin/ptardiff
/usr/bin/ptargrep
/usr/bin/ptx
/usr/bin/purge-old-kernels
/usr/bin/pwd
/usr/bin/pwdx
/usr/bin/py3clean
/usr/bin/py3compile
/usr/bin/pydoc3.8
/usr/bin/pygettext3.8
/usr/bin/pyhtmlizer3
/usr/bin/pyjwt3
/usr/bin/python3.8
/usr/bin/rdma
/usr/bin/readlink
/usr/bin/realpath
/usr/bin/red
/usr/bin/rename.ul
/usr/bin/renice
/usr/bin/rescan-scsi-bus.sh
/usr/bin/resizecons
/usr/bin/resizepart
/usr/bin/resolvectl
/usr/bin/rev
/usr/bin/rgrep
/usr/bin/rm
/usr/bin/rmdir
/usr/bin/routef
/usr/bin/routel
/usr/bin/rsync
/usr/bin/run-mailcap
/usr/bin/run-one
/usr/bin/run-parts
/usr/bin/runcon
/usr/bin/savelog
/usr/bin/sbattach
/usr/bin/sbkeysync
/usr/bin/sbsiglist
/usr/bin/sbsign
/usr/bin/sbvarsign
/usr/bin/sbverify
/usr/bin/scp
/usr/bin/screen
/usr/bin/screendump
/usr/bin/script
/usr/bin/scriptreplay
/usr/bin/scsi_logging_level
/usr/bin/scsi_mandat
/usr/bin/scsi_readcap
/usr/bin/scsi_ready
/usr/bin/scsi_satl
/usr/bin/scsi_start
/usr/bin/scsi_stop
/usr/bin/scsi_temperature
/usr/bin/sdiff
/usr/bin/sed
/usr/bin/select-editor
/usr/bin/sensible-browser
/usr/bin/sensible-editor
/usr/bin/sensible-pager
/usr/bin/seq
/usr/bin/setarch
/usr/bin/setfont
/usr/bin/setkeycodes
/usr/bin/setleds
/usr/bin/setlogcons
/usr/bin/setmetamode
/usr/bin/setpci
/usr/bin/setpriv
/usr/bin/setsid
/usr/bin/setterm
/usr/bin/setupcon
/usr/bin/sftp
/usr/bin/sg_bg_ctl
/usr/bin/sg_compare_and_write
/usr/bin/sg_copy_results
/usr/bin/sg_dd
/usr/bin/sg_decode_sense
/usr/bin/sg_emc_trespass
/usr/bin/sg_format
/usr/bin/sg_get_config
/usr/bin/sg_get_lba_status
/usr/bin/sg_ident
/usr/bin/sg_inq
/usr/bin/sg_logs
/usr/bin/sg_luns
/usr/bin/sg_map
/usr/bin/sg_map26
/usr/bin/sg_modes
/usr/bin/sg_opcodes
/usr/bin/sg_persist
/usr/bin/sg_prevent
/usr/bin/sg_raw
/usr/bin/sg_rbuf
/usr/bin/sg_rdac
/usr/bin/sg_read
/usr/bin/sg_read_attr
/usr/bin/sg_read_block_limits
/usr/bin/sg_read_buffer
/usr/bin/sg_read_long
/usr/bin/sg_readcap
/usr/bin/sg_reassign
/usr/bin/sg_referrals
/usr/bin/sg_rep_zones
/usr/bin/sg_requests
/usr/bin/sg_reset
/usr/bin/sg_reset_wp
/usr/bin/sg_rmsn
/usr/bin/sg_rtpg
/usr/bin/sg_safte
/usr/bin/sg_sanitize
/usr/bin/sg_sat_identify
/usr/bin/sg_sat_phy_event
/usr/bin/sg_sat_read_gplog
/usr/bin/sg_sat_set_features
/usr/bin/sg_scan
/usr/bin/sg_seek
/usr/bin/sg_senddiag
/usr/bin/sg_ses
/usr/bin/sg_ses_microcode
/usr/bin/sg_start
/usr/bin/sg_stpg
/usr/bin/sg_stream_ctl
/usr/bin/sg_sync
/usr/bin/sg_test_rwbuf
/usr/bin/sg_timestamp
/usr/bin/sg_turs
/usr/bin/sg_unmap
/usr/bin/sg_verify
/usr/bin/sg_vpd
/usr/bin/sg_wr_mode
/usr/bin/sg_write_buffer
/usr/bin/sg_write_long
/usr/bin/sg_write_same
/usr/bin/sg_write_verify
/usr/bin/sg_write_x
/usr/bin/sg_xcopy
/usr/bin/sg_zone
/usr/bin/sginfo
/usr/bin/sgm_dd
/usr/bin/sgp_dd
/usr/bin/sha1sum
/usr/bin/sha224sum
/usr/bin/sha256sum
/usr/bin/sha384sum
/usr/bin/sha512sum
/usr/bin/shasum
/usr/bin/showconsolefont
/usr/bin/showkey
/usr/bin/shred
/usr/bin/shuf
/usr/bin/skill
/usr/bin/slabtop
/usr/bin/sleep
/usr/bin/snap
/usr/bin/snapfuse
/usr/bin/soelim
/usr/bin/sort
/usr/bin/splain
/usr/bin/split
/usr/bin/splitfont
/usr/bin/ss
/usr/bin/ssh
/usr/bin/ssh-add
/usr/bin/ssh-agent
/usr/bin/ssh-argv0
/usr/bin/ssh-copy-id
/usr/bin/ssh-import-id
/usr/bin/ssh-import-id-gh
/usr/bin/ssh-import-id-lp
/usr/bin/ssh-keygen
/usr/bin/ssh-keyscan
/usr/bin/stat
/usr/bin/stdbuf
/usr/bin/strace
/usr/bin/strace-log-merge
/usr/bin/stty
/usr/bin/su
/usr/bin/sudo
/usr/bin/sudoreplay
/usr/bin/sum
/usr/bin/symcryptrun
/usr/bin/sync
/usr/bin/systemctl
/usr/bin/systemd-analyze
/usr/bin/systemd-ask-password
/usr/bin/systemd-cat
/usr/bin/systemd-cgls
/usr/bin/systemd-cgtop
/usr/bin/systemd-delta
/usr/bin/systemd-detect-virt
/usr/bin/systemd-escape
/usr/bin/systemd-hwdb
/usr/bin/systemd-id128
/usr/bin/systemd-inhibit
/usr/bin/systemd-machine-id-setup
/usr/bin/systemd-mount
/usr/bin/systemd-notify
/usr/bin/systemd-path
/usr/bin/systemd-run
/usr/bin/systemd-socket-activate
/usr/bin/systemd-stdio-bridge
/usr/bin/systemd-sysusers
/usr/bin/systemd-tmpfiles
/usr/bin/systemd-tty-ask-password-agent
/usr/bin/tabs
/usr/bin/tac
/usr/bin/tail
/usr/bin/tar
/usr/bin/taskset
/usr/bin/tbl
/usr/bin/tee
/usr/bin/telnet.netkit
/usr/bin/tempfile
/usr/bin/test
/usr/bin/tic
/usr/bin/time
/usr/bin/timedatectl
/usr/bin/timeout
/usr/bin/tkconch3
/usr/bin/tload
/usr/bin/tmux
/usr/bin/toe
/usr/bin/top
/usr/bin/touch
/usr/bin/tput
/usr/bin/tr
/usr/bin/tracepath
/usr/bin/traceroute6.iputils
/usr/bin/trial3
/usr/bin/troff
/usr/bin/true
/usr/bin/truncate
/usr/bin/tset
/usr/bin/tsort
/usr/bin/tty
/usr/bin/twist3
/usr/bin/twistd3
/usr/bin/tzselect
/usr/bin/ubuntu-advantage
/usr/bin/ubuntu-security-status
/usr/bin/ucf
/usr/bin/ucfq
/usr/bin/ucfr
/usr/bin/udevadm
/usr/bin/ul
/usr/bin/ulockmgr_server
/usr/bin/umount
/usr/bin/uname
/usr/bin/unattended-upgrade
/usr/bin/uncompress
/usr/bin/unexpand
/usr/bin/unicode_start
/usr/bin/unicode_stop
/usr/bin/uniq
/usr/bin/unlink
/usr/bin/unmkinitramfs
/usr/bin/unshare
/usr/bin/unsquashfs
/usr/bin/update-alternatives
/usr/bin/update-mime-database
/usr/bin/uptime
/usr/bin/usb-devices
/usr/bin/usbhid-dump
/usr/bin/usbreset
/usr/bin/users
/usr/bin/utmpdump
/usr/bin/uuidgen
/usr/bin/uuidparse
/usr/bin/vcs-run
/usr/bin/vdir
/usr/bin/viewres
/usr/bin/vigpg
/usr/bin/vim.basic
/usr/bin/vim.tiny
/usr/bin/vimtutor
/usr/bin/vmhgfs-fuse
/usr/bin/vmstat
/usr/bin/vmtoolsd
/usr/bin/vmware-checkvm
/usr/bin/vmware-hgfsclient
/usr/bin/vmware-namespace-cmd
/usr/bin/vmware-rpctool
/usr/bin/vmware-toolbox-cmd
/usr/bin/vmware-vgauth-cmd
/usr/bin/vmware-vgauth-smoketest
/usr/bin/vmware-vmblock-fuse
/usr/bin/vmware-xferlogs
/usr/bin/volname
/usr/bin/w.procps
/usr/bin/wall
/usr/bin/watch
/usr/bin/watchgnupg
/usr/bin/wc
/usr/bin/wdctl
/usr/bin/wget
/usr/bin/whatis
/usr/bin/whereis
/usr/bin/which
/usr/bin/whiptail
/usr/bin/who
/usr/bin/whoami
/usr/bin/wifi-status
/usr/bin/wslfetch
/usr/bin/wslsys
/usr/bin/wslupath
/usr/bin/wslusc
/usr/bin/wslvar
/usr/bin/wslview
/usr/bin/xargs
/usr/bin/xauth
/usr/bin/xdg-user-dir
/usr/bin/xdg-user-dirs-update
/usr/bin/xdpyinfo
/usr/bin/xdriinfo
/usr/bin/xev
/usr/bin/xfd
/usr/bin/xfontsel
/usr/bin/xkill
/usr/bin/xlsatoms
/usr/bin/xlsclients
/usr/bin/xlsfonts
/usr/bin/xmessage
/usr/bin/xprop
/usr/bin/xsubpp
/usr/bin/xvinfo
/usr/bin/xwininfo
/usr/bin/xxd
/usr/bin/xz
/usr/bin/xzdiff
/usr/bin/xzgrep
/usr/bin/xzless
/usr/bin/xzmore
/usr/bin/yes
/usr/bin/zcat
/usr/bin/zcmp
/usr/bin/zdiff
/usr/bin/zdump
/usr/bin/zegrep
/usr/bin/zfgrep
/usr/bin/zforce
/usr/bin/zgrep
/usr/bin/zipdetails
/usr/bin/zless
/usr/bin/zmore
/usr/bin/znew

```

`utils.cc`:

```cc
#include "utils.h"
#include <string>

std::vector<std::string> SplitWith(std::string str,
                                   const std::string& delimiter) {
    std::vector<std::string> ret;
    size_t pos;
    while ((pos = str.find(delimiter)) != std::string::npos) {
        ret.emplace_back(str.substr(0, pos));
        str.erase(0, pos + delimiter.length());
    }
    return ret;
}

std::string ShowRelocationType(int type) {
    switch (type) {
        case R_X86_64_NONE:
            return "R_X86_64_NONE";
        case R_X86_64_64:
            return "R_X86_64_64";
        case R_X86_64_PC32:
            return "R_X86_64_PC32";
        case R_X86_64_GOT32:
            return "R_X86_64_GOT32";
        case R_X86_64_PLT32:
            return "R_X86_64_PLT32";
        case R_X86_64_COPY:
            return "R_X86_64_COPY";
        case R_X86_64_GLOB_DAT:
            return "R_X86_64_GLOB_DAT";
        case R_X86_64_JUMP_SLOT:
            return "R_X86_64_JUMP_SLOT";
        case R_X86_64_RELATIVE:
            return "R_X86_64_RELATIVE";
        case R_X86_64_GOTPCREL:
            return "R_X86_64_GOTPCREL";
        case R_X86_64_32:
            return "R_X86_64_32";
        case R_X86_64_32S:
            return "R_X86_64_32S";
        case R_X86_64_16:
            return "R_X86_64_16";
        case R_X86_64_PC16:
            return "R_X86_64_PC16";
        case R_X86_64_8:
            return "R_X86_64_8";
        case R_X86_64_PC8:
            return "R_X86_64_PC8";
        case R_X86_64_DTPMOD64:
            return "R_X86_64_DTPMOD64";
        case R_X86_64_DTPOFF64:
            return "R_X86_64_DTPOFF64";
        case R_X86_64_TPOFF64:
            return "R_X86_64_TPOFF64";
        case R_X86_64_TLSGD:
            return "R_X86_64_TLSGD";
        case R_X86_64_TLSLD:
            return "R_X86_64_TLSLD";
        case R_X86_64_DTPOFF32:
            return "R_X86_64_DTPOFF32";
        case R_X86_64_GOTTPOFF:
            return "R_X86_64_GOTTPOFF";
        case R_X86_64_TPOFF32:
            return "R_X86_64_TPOFF32";
        case R_X86_64_PC64:
            return "R_X86_64_PC64";
        case R_X86_64_GOTOFF64:
            return "R_X86_64_GOTOFF64";
        case R_X86_64_GOTPC32:
            return "R_X86_64_GOTPC32";
        case R_X86_64_GOT64:
            return "R_X86_64_GOT64";
        case R_X86_64_GOTPCREL64:
            return "R_X86_64_GOTPCREL64";
        case R_X86_64_GOTPC64:
            return "R_X86_64_GOTPC64";
        case R_X86_64_GOTPLT64:
            return "R_X86_64_GOTPLT64";
        case R_X86_64_PLTOFF64:
            return "R_X86_64_PLTOFF64";
        case R_X86_64_SIZE32:
            return "R_X86_64_SIZE32";
        case R_X86_64_SIZE64:
            return "R_X86_64_SIZE64";
        case R_X86_64_GOTPC32_TLSDESC:
            return "R_X86_64_GOTPC32_TLSDESC";
        case R_X86_64_TLSDESC:
            return "R_X86_64_TLSDESC";
        case R_X86_64_IRELATIVE:
            return "R_X86_64_IRELATIVE";
        case R_X86_64_RELATIVE64:
            return "R_X86_64_RELATIVE64";
        case R_X86_64_GOTPCRELX:
            return "R_X86_64_GOTPCRELX";
        case R_X86_64_REX_GOTPCRELX:
            return "R_X86_64_REX_GOTPCRELX";
        case R_X86_64_NUM:
            return "R_X86_64_NUM";
        default: {
            return HexString(type, 4);
        }
    }
}

std::string ShowRela(const Elf64_Rela& r) {
    std::stringstream ss;
    ss << "Elf_Rela{r_offset=" << HexString(r.r_offset, 8)
       << ", r_info=" << HexString(r.r_info, 8)
       << ", ELF64_R_SYM(r.r_info)=" << HexString(ELF64_R_SYM(r.r_info), 4)
       << ", ELF64_R_TYPE(r.r_info)="
       << ShowRelocationType(ELF64_R_TYPE(r.r_info))
       << ", r_addend=" << HexString(r.r_addend, 8) << "}";
    return ss.str();
}

std::string ShowSTB(unsigned char bind) {
    switch (bind) {
        case STB_LOCAL:
            return "STB_LOCAL";
        case STB_GLOBAL:
            return "STB_GLOBAL";
        case STB_WEAK:
            return "STB_WEAK";
        case STB_NUM:
            return "STB_NUM";
        case STB_GNU_UNIQUE:
            return "STB_GNU_UNIQUE";
        case STB_HIOS:
            return "STB_HIOS";
        case STB_LOPROC:
            return "STB_LOPROC";
        case STB_HIPROC:
            return "STB_HIPROC";
        default: {
            return std::to_string(bind);
        }
    }
}

std::string ShowSTT(unsigned char type) {
    switch (type) {
        case STT_NOTYPE:
            return "STT_NOTYPE";
        case STT_OBJECT:
            return "STT_OBJECT";
        case STT_FUNC:
            return "STT_FUNC";
        case STT_SECTION:
            return "STT_SECTION";
        case STT_FILE:
            return "STT_FILE";
        case STT_COMMON:
            return "STT_COMMON";
        case STT_TLS:
            return "STT_TLS";
        case STT_NUM:
            return "STT_NUM";
        case STT_GNU_IFUNC:
            return "STT_GNU_IFUNC";
        default: {
            LOG(FATAL) << LOG_KEY(type);
            std::abort();
        }
    }
}

std::string ShowSym(const Elf64_Sym& s, const char* strtab) {
    std::stringstream ss;
    std::string name = strtab + s.st_name;
    unsigned char bind = ELF64_ST_BIND(s.st_info);
    unsigned char type = ELF64_ST_TYPE(s.st_info);
    ss << "Elf64_Sym{st_name=" << name
       << ", ELF64_ST_BIND(st_info)=" << ShowSTB(bind)
       << ", ELF64_ST_TYPE(st_info)=" << ShowSTT(type)
       << ", st_other=" << s.st_other << ", st_shndx=" << s.st_shndx
       << ", st_value=" << HexString(s.st_value)
       << ", st_size=" << HexString(s.st_size) << "}";
    return ss.str();
}

```

`utils.h`:

```h
#pragma once

#include <elf.h>

#include <fstream>
#include <iomanip>
#include <iostream>
#include <sstream>
#include <vector>

class nullstream : public std::ostream {
public:
    nullstream() : std::ostream(nullptr) {}
};
inline nullstream null;

#define CHECK(x)                                          \
    if (!(x)) {                                           \
        std::cerr << "CHECK failed: " << #x << std::endl; \
        exit(1);                                          \
    }
#define CHECK_GT(x, y) CHECK((x) > (y))
#define CHECK_LT(x, y) CHECK((x) < (y))
#define CHECK_EQ(x, y) CHECK((x) == (y))
#define CHECK_NE(x, y) CHECK((x) != (y))
#define CHECK_GE(x, y) CHECK((x) >= (y))
#define CHECK_LE(x, y) CHECK((x) <= (y))
/* Replace null with std::cout to enable logging */
#define LOG(loglevel)                                                   \
    null << #loglevel << " " << __FILE__ << ":" << __LINE__ << " " \
              << " "

#define LOG_KEY_VALUE(key, value) " " << key << "=" << value
#define LOG_KEY(key) LOG_KEY_VALUE(#key, key)
#define LOG_64BITS(key) LOG_KEY_VALUE(#key, HexString(key, 16))
#define LOG_32BITS(key) LOG_KEY_VALUE(#key, HexString(key, 8))
#define LOG_16BITS(key) LOG_KEY_VALUE(#key, HexString(key, 4))
#define LOG_8BITS(key) LOG_KEY_VALUE(#key, HexString(key, 2))
#define LOG_BITS(key) LOG_KEY_VALUE(#key, HexString(key))
#define LOG_DWEHPE(type) LOG_KEY_VALUE(#type, ShowDW_EH_PE(type))

template <class T>
std::string HexString(T* num, int length = -1) {
    uint64_t n = reinterpret_cast<uint64_t>(num);
    if (length == -1) {
        length = 16;
    }
    std::stringstream ss;
    ss << "0x" << std::uppercase << std::setfill('0') << std::setw(length) << std::hex << n;
    return ss.str();
}

template <class T>
std::string HexString(const T* num, int length = -1) {
    return HexString(const_cast<T*>(num), length);
}

template <class T>
std::string HexString(T num, int length = -1) {
    if (length == -1) {
        length = sizeof(T) / 2;
    }
    std::stringstream ss;
    ss << "0x" << std::uppercase << std::setfill('0') << std::setw(length) << std::hex << +num;
    return ss.str();
}

std::vector<std::string> SplitWith(std::string str, const std::string& delimiter);

std::string ShowRela(const Elf64_Rela& r);

std::string ShowSym(const Elf64_Sym& s, const char* strtab);

std::string ShowRelocationType(int type);

```