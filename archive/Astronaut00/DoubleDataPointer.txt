Project Path: arc_Astronaut00_DoubleDataPointer_44wzowtb

Source Tree:

```txt
arc_Astronaut00_DoubleDataPointer_44wzowtb
├── DoubleDataPointer.sln
├── Driver
│   ├── cleaning.cpp
│   ├── cleaning.h
│   ├── core.cpp
│   ├── core.h
│   ├── driver.vcxproj
│   ├── driver.vcxproj.filters
│   ├── driver.vcxproj.user
│   ├── main.cpp
│   ├── stdafx.h
│   ├── structs.h
│   ├── util.cpp
│   └── util.h
├── Example
│   ├── Example.vcxproj
│   ├── Example.vcxproj.filters
│   ├── Example.vcxproj.user
│   └── main.cpp
├── README.md
└── Usermode
    ├── memory.cpp
    └── memory.h

```

`DoubleDataPointer.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30907.101
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "driver", "Driver\driver.vcxproj", "{4A9C2A65-D849-44DB-AFB5-207F816B23A2}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Example", "Example\Example.vcxproj", "{136B1D30-4A9A-4635-8D4C-01A050F1D50D}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{4A9C2A65-D849-44DB-AFB5-207F816B23A2}.Debug|ARM.ActiveCfg = Debug|ARM
		{4A9C2A65-D849-44DB-AFB5-207F816B23A2}.Debug|ARM.Build.0 = Debug|ARM
		{4A9C2A65-D849-44DB-AFB5-207F816B23A2}.Debug|ARM.Deploy.0 = Debug|ARM
		{4A9C2A65-D849-44DB-AFB5-207F816B23A2}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{4A9C2A65-D849-44DB-AFB5-207F816B23A2}.Debug|ARM64.Build.0 = Debug|ARM64
		{4A9C2A65-D849-44DB-AFB5-207F816B23A2}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{4A9C2A65-D849-44DB-AFB5-207F816B23A2}.Debug|x64.ActiveCfg = Debug|x64
		{4A9C2A65-D849-44DB-AFB5-207F816B23A2}.Debug|x64.Build.0 = Debug|x64
		{4A9C2A65-D849-44DB-AFB5-207F816B23A2}.Debug|x64.Deploy.0 = Debug|x64
		{4A9C2A65-D849-44DB-AFB5-207F816B23A2}.Debug|x86.ActiveCfg = Debug|Win32
		{4A9C2A65-D849-44DB-AFB5-207F816B23A2}.Debug|x86.Build.0 = Debug|Win32
		{4A9C2A65-D849-44DB-AFB5-207F816B23A2}.Debug|x86.Deploy.0 = Debug|Win32
		{4A9C2A65-D849-44DB-AFB5-207F816B23A2}.Release|ARM.ActiveCfg = Release|ARM
		{4A9C2A65-D849-44DB-AFB5-207F816B23A2}.Release|ARM.Build.0 = Release|ARM
		{4A9C2A65-D849-44DB-AFB5-207F816B23A2}.Release|ARM.Deploy.0 = Release|ARM
		{4A9C2A65-D849-44DB-AFB5-207F816B23A2}.Release|ARM64.ActiveCfg = Release|ARM64
		{4A9C2A65-D849-44DB-AFB5-207F816B23A2}.Release|ARM64.Build.0 = Release|ARM64
		{4A9C2A65-D849-44DB-AFB5-207F816B23A2}.Release|ARM64.Deploy.0 = Release|ARM64
		{4A9C2A65-D849-44DB-AFB5-207F816B23A2}.Release|x64.ActiveCfg = Release|x64
		{4A9C2A65-D849-44DB-AFB5-207F816B23A2}.Release|x64.Build.0 = Release|x64
		{4A9C2A65-D849-44DB-AFB5-207F816B23A2}.Release|x64.Deploy.0 = Release|x64
		{4A9C2A65-D849-44DB-AFB5-207F816B23A2}.Release|x86.ActiveCfg = Release|Win32
		{4A9C2A65-D849-44DB-AFB5-207F816B23A2}.Release|x86.Build.0 = Release|Win32
		{4A9C2A65-D849-44DB-AFB5-207F816B23A2}.Release|x86.Deploy.0 = Release|Win32
		{136B1D30-4A9A-4635-8D4C-01A050F1D50D}.Debug|ARM.ActiveCfg = Debug|Win32
		{136B1D30-4A9A-4635-8D4C-01A050F1D50D}.Debug|ARM64.ActiveCfg = Debug|Win32
		{136B1D30-4A9A-4635-8D4C-01A050F1D50D}.Debug|x64.ActiveCfg = Debug|x64
		{136B1D30-4A9A-4635-8D4C-01A050F1D50D}.Debug|x64.Build.0 = Debug|x64
		{136B1D30-4A9A-4635-8D4C-01A050F1D50D}.Debug|x86.ActiveCfg = Debug|Win32
		{136B1D30-4A9A-4635-8D4C-01A050F1D50D}.Debug|x86.Build.0 = Debug|Win32
		{136B1D30-4A9A-4635-8D4C-01A050F1D50D}.Release|ARM.ActiveCfg = Release|Win32
		{136B1D30-4A9A-4635-8D4C-01A050F1D50D}.Release|ARM64.ActiveCfg = Release|Win32
		{136B1D30-4A9A-4635-8D4C-01A050F1D50D}.Release|x64.ActiveCfg = Release|x64
		{136B1D30-4A9A-4635-8D4C-01A050F1D50D}.Release|x64.Build.0 = Release|x64
		{136B1D30-4A9A-4635-8D4C-01A050F1D50D}.Release|x86.ActiveCfg = Release|Win32
		{136B1D30-4A9A-4635-8D4C-01A050F1D50D}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {0A506531-E5B8-46D7-9AD9-4CCD1D3C1CFB}
	EndGlobalSection
EndGlobal

```

`Driver/cleaning.cpp`:

```cpp
#include "cleaning.h"
#include "util.h"

NTSTATUS NullPageFrameNumbersFromMdl(PMDL mdl)
{
	PPFN_NUMBER mdl_pages = MmGetMdlPfnArray(mdl);
	if (!mdl_pages) { return STATUS_UNSUCCESSFUL; }

	ULONG mdl_page_count = ADDRESS_AND_SIZE_TO_SPAN_PAGES(MmGetMdlVirtualAddress(mdl), MmGetMdlByteCount(mdl));

	ULONG null_pfn = 0x0;
	MM_COPY_ADDRESS source_address = { 0 };
	source_address.VirtualAddress = &null_pfn;

	for (ULONG i = 0; i < mdl_page_count; i++)
	{
		size_t bytes = 0;
		MmCopyMemory(&mdl_pages[i], source_address, sizeof(ULONG), MM_COPY_MEMORY_VIRTUAL, &bytes);
	}
	return STATUS_SUCCESS;
}

NTSTATUS Cleaning::NullPageFrameNumbers(uint64_t start, uint32_t size)
{
	NTSTATUS status = STATUS_UNSUCCESSFUL;
	PMDL mdl = IoAllocateMdl((PVOID)start, (ULONG)size, FALSE, FALSE, NULL);

	if (!mdl)
	{
		printf("[mapper] Failed to allocate Mdl\n");
		return status;
	}

	status = NullPageFrameNumbersFromMdl(mdl);

	IoFreeMdl(mdl);

	return status;
}

PVOID resolve_relative_address(PVOID Instruction, ULONG OffsetOffset, ULONG InstructionSize) //lol paste you got me. IDK the pointers were fucked up somewhere and I'm too lazy to go and manually reread it.
{
	ULONG_PTR Instr = (ULONG_PTR)Instruction;
	LONG RipOffset = *(PLONG)(Instr + OffsetOffset);
	PVOID ResolvedAddr = (PVOID)(Instr + InstructionSize + RipOffset);

	return ResolvedAddr;
}

NTSTATUS FindBigPoolTable(uint64_t* pPoolBigPageTable, uint64_t* pPoolBigPageTableSize)
{
	PVOID ntoskrnl = Core::GetSystemModuleBase("\\SystemRoot\\system32\\ntoskrnl.exe");

	if (!ntoskrnl)
	{
		printf("[mapper] Failed to get ntoskrnl.exe base Address!\n");
		return STATUS_UNSUCCESSFUL;
	}
	printf("[mapper] ntoskrnl.exe -> 0x%p\n", ntoskrnl);

	PVOID ExProtectPoolExCallInstructionsAddress = (PVOID)Util::FindPattern(ntoskrnl, "\xE8\x00\x00\x00\x00\x83\x67\x0C\x00", "x????xxxx");

	PVOID ExProtectPoolExAddress = resolve_relative_address(ExProtectPoolExCallInstructionsAddress, 1, 5);

	if (!ExProtectPoolExAddress)
		return false;

	PVOID PoolBigPageTableInstructionAddress = (PVOID)((ULONG64)ExProtectPoolExAddress + 0x95);
	*pPoolBigPageTable = (UINT64)resolve_relative_address(PoolBigPageTableInstructionAddress, 3, 7);

	PVOID PoolBigPageTableSizeInstructionAddress = (PVOID)((ULONG64)ExProtectPoolExAddress + 0x8E);
	*pPoolBigPageTableSize = (UINT64)resolve_relative_address(PoolBigPageTableSizeInstructionAddress, 3, 7);

	return STATUS_SUCCESS;
}

NTSTATUS Cleaning::CleanFromBigPools(uint64_t start)
{
	uint64_t pPoolBigPageTable = 0;
	uint64_t pPoolBigPageTableSize = 0;

	if (NT_SUCCESS(FindBigPoolTable(&pPoolBigPageTable, &pPoolBigPageTableSize)))
	{
		PPOOL_TRACKER_BIG_PAGES PoolBigPageTable = 0;
		RtlCopyMemory(&PoolBigPageTable, (PVOID)pPoolBigPageTable, 8);
		SIZE_T PoolBigPageTableSize = 0;
		RtlCopyMemory(&PoolBigPageTableSize, (PVOID)pPoolBigPageTableSize, 8);

		for (int i = 0; i < PoolBigPageTableSize; i++)
		{
			if (PoolBigPageTable[i].Va == start || PoolBigPageTable[i].Va == (start + 0x1))
			{
				PoolBigPageTable[i].Va = 0x1;
				PoolBigPageTable[i].NumberOfBytes = 0x0;
				return STATUS_SUCCESS;
			}
		}

		return STATUS_UNSUCCESSFUL;
	}

	return STATUS_UNSUCCESSFUL;
}

```

`Driver/cleaning.h`:

```h
#pragma once
#include "stdafx.h"

namespace Cleaning
{
	NTSTATUS NullPageFrameNumbers(uint64_t start, uint32_t size);
	NTSTATUS CleanFromBigPools(uint64_t start);
}
```

`Driver/core.cpp`:

```cpp
#pragma once
#include "core.h"
#include "structs.h"

namespace Core {

    NTSTATUS GetProcessBaseAddress(int pid, uint64_t* Address)
    {
        PEPROCESS pProcess = NULL;
        if (pid < 1) 
            return STATUS_UNSUCCESSFUL;

        if (!NT_SUCCESS(PsLookupProcessByProcessId((HANDLE)pid, &pProcess)))
            return STATUS_UNSUCCESSFUL;


        *Address = (uint64_t)PsGetProcessSectionBaseAddress(pProcess);

        ObDereferenceObject(pProcess);
        return STATUS_SUCCESS;
    }

    DWORD GetUserDirectoryTableBaseOffset()
    {
        RTL_OSVERSIONINFOW ver = { 0 };
        RtlGetVersion(&ver);

        switch (ver.dwBuildNumber)
        {
        case WINDOWS_1803:
            return 0x0278;
            break;
        case WINDOWS_1809:
            return 0x0278;
            break;
        case WINDOWS_1903:
            return 0x0280;
            break;
        case WINDOWS_1909:
            return 0x0280;
            break;
        case WINDOWS_2004:
            return 0x0388;
            break;
        case WINDOWS_20H2:
            return 0x0388;
            break;
        case WINDOWS_21H1:
            return 0x0388;
            break;
        default:
            return 0x0388;
        }
    }

    //check normal dirbase if 0 then get from UserDirectoryTableBas
    ULONG_PTR GetProcessCr3(PEPROCESS pProcess)
    {
        PUCHAR process = (PUCHAR)pProcess;
        ULONG_PTR process_dirbase = *(PULONG_PTR)(process + 0x28); //dirbase x64, 32bit is 0x18
        if (process_dirbase == 0)
        {
            DWORD UserDirOffset = GetUserDirectoryTableBaseOffset();
            ULONG_PTR process_userdirbase = *(PULONG_PTR)(process + UserDirOffset);
            return process_userdirbase;
        }
        return process_dirbase;
    }
    ULONG_PTR GetKernelDirBase()
    {
        PUCHAR process = (PUCHAR)PsGetCurrentProcess();
        ULONG_PTR cr3 = *(PULONG_PTR)(process + 0x28); //dirbase x64, 32bit is 0x18
        return cr3;
    }
    uint64_t TranslateLinearAddress(uint64_t directoryTableBase, uint64_t virtualAddress);
    NTSTATUS ReadPhysicalAddress(uint64_t TargetAddress, PVOID lpBuffer, SIZE_T Size, SIZE_T* BytesRead);
    NTSTATUS WritePhysicalAddress(uint64_t TargetAddress, PVOID lpBuffer, SIZE_T Size, SIZE_T* BytesWritten);

    NTSTATUS ReadVirtual(uint64_t dirbase, uint64_t address, uint8_t* buffer, SIZE_T size, SIZE_T* read)
    {
        uint64_t paddress = TranslateLinearAddress(dirbase, address);
        return ReadPhysicalAddress(paddress, buffer, size, read);
    }

    NTSTATUS WriteVirtual(uint64_t dirbase, uint64_t address, uint8_t* buffer, SIZE_T size, SIZE_T* written)
    {
        uint64_t paddress = TranslateLinearAddress(dirbase, address);
        return WritePhysicalAddress(paddress, buffer, size, written);
    }

    NTSTATUS ReadPhysicalAddress(uint64_t TargetAddress, PVOID lpBuffer, SIZE_T Size, SIZE_T* BytesRead)
    {
        MM_COPY_ADDRESS AddrToRead = { 0 };
        AddrToRead.PhysicalAddress.QuadPart = TargetAddress;
        return MmCopyMemory(lpBuffer, AddrToRead, Size, MM_COPY_MEMORY_PHYSICAL, BytesRead);
    }

    //MmMapIoSpaceEx limit is page 4096 byte
    NTSTATUS WritePhysicalAddress(uint64_t TargetAddress, PVOID lpBuffer, SIZE_T Size, SIZE_T* BytesWritten)
    {
        if (!TargetAddress)
            return STATUS_UNSUCCESSFUL;

        PHYSICAL_ADDRESS AddrToWrite = { 0 };
        AddrToWrite.QuadPart = TargetAddress;

        PVOID pmapped_mem = MmMapIoSpaceEx(AddrToWrite, Size, PAGE_READWRITE);

        if (!pmapped_mem)
            return STATUS_UNSUCCESSFUL;

        memcpy(pmapped_mem, lpBuffer, Size);

        *BytesWritten = Size;
        MmUnmapIoSpace(pmapped_mem, Size);
        return STATUS_SUCCESS;
    }

#define PAGE_OFFSET_SIZE 12
    static const uint64_t PMASK = (~0xfull << 8) & 0xfffffffffull;

    uint64_t TranslateLinearAddress(uint64_t directoryTableBase, uint64_t virtualAddress) {
        directoryTableBase &= ~0xf;

        uint64_t pageOffset = virtualAddress & ~(~0ul << PAGE_OFFSET_SIZE);
        uint64_t pte = ((virtualAddress >> 12) & (0x1ffll));
        uint64_t pt = ((virtualAddress >> 21) & (0x1ffll));
        uint64_t pd = ((virtualAddress >> 30) & (0x1ffll));
        uint64_t pdp = ((virtualAddress >> 39) & (0x1ffll));

        SIZE_T readsize = 0;
        uint64_t pdpe = 0;
        ReadPhysicalAddress(directoryTableBase + 8 * pdp, &pdpe, sizeof(pdpe), &readsize);
        if (~pdpe & 1)
            return 0;

        uint64_t pde = 0;
        ReadPhysicalAddress((pdpe & PMASK) + 8 * pd, &pde, sizeof(pde), &readsize);
        if (~pde & 1)
            return 0;

        /* 1GB large page, use pde's 12-34 bits */
        if (pde & 0x80)
            return (pde & (~0ull << 42 >> 12)) + (virtualAddress & ~(~0ull << 30));

        uint64_t pteAddr = 0;
        ReadPhysicalAddress((pde & PMASK) + 8 * pt, &pteAddr, sizeof(pteAddr), &readsize);
        if (~pteAddr & 1)
            return 0;

        /* 2MB large page */
        if (pteAddr & 0x80)
            return (pteAddr & PMASK) + (virtualAddress & ~(~0ull << 21));

        virtualAddress = 0;
        ReadPhysicalAddress((pteAddr & PMASK) + 8 * pte, &virtualAddress, sizeof(virtualAddress), &readsize);
        virtualAddress &= PMASK;

        if (!virtualAddress)
            return 0;

        return virtualAddress + pageOffset;
    }


    //
    NTSTATUS ReadProcessMemory(int pid, uint64_t Address, uint64_t AllocatedBuffer, SIZE_T size, SIZE_T* read)
    {
        PEPROCESS pProcess = NULL;
        if (pid == 0) return STATUS_UNSUCCESSFUL;

        NTSTATUS NtRet = PsLookupProcessByProcessId((HANDLE)pid, &pProcess);
        if (NtRet != STATUS_SUCCESS) return NtRet;

        ULONG_PTR process_dirbase = GetProcessCr3(pProcess);
        ObDereferenceObject(pProcess);

        SIZE_T CurOffset = 0;
        SIZE_T TotalSize = size;
        while (TotalSize)
        {

            uint64_t CurPhysAddr = TranslateLinearAddress(process_dirbase, (ULONG64)Address + CurOffset);
            if (!CurPhysAddr) return STATUS_UNSUCCESSFUL;

            ULONG64 ReadSize = min(PAGE_SIZE - (CurPhysAddr & 0xFFF), TotalSize);
            SIZE_T BytesRead = 0;
            NtRet = ReadPhysicalAddress(CurPhysAddr, (PVOID)((ULONG64)AllocatedBuffer + CurOffset), ReadSize, &BytesRead);
            TotalSize -= BytesRead;
            CurOffset += BytesRead;
            if (NtRet != STATUS_SUCCESS) break;
            if (BytesRead == 0) break;
        }

        *read = CurOffset;
        return NtRet;
    }

    NTSTATUS WriteProcessMemory(int pid, uint64_t Address, uint64_t AllocatedBuffer, SIZE_T size, SIZE_T* written)
    {
        PEPROCESS pProcess = NULL;
        if (pid == 0) return STATUS_UNSUCCESSFUL;

        NTSTATUS NtRet = PsLookupProcessByProcessId((HANDLE)pid, &pProcess);
        if (NtRet != STATUS_SUCCESS) return NtRet;

        ULONG_PTR process_dirbase = GetProcessCr3(pProcess);
        ObDereferenceObject(pProcess);

        SIZE_T CurOffset = 0;
        SIZE_T TotalSize = size;
        while (TotalSize)
        {
            uint64_t CurPhysAddr = TranslateLinearAddress(process_dirbase, (ULONG64)Address + CurOffset);
            if (!CurPhysAddr) return STATUS_UNSUCCESSFUL;

            ULONG64 WriteSize = min(PAGE_SIZE - (CurPhysAddr & 0xFFF), TotalSize);
            SIZE_T BytesWritten = 0;
            NtRet = WritePhysicalAddress(CurPhysAddr, (PVOID)((ULONG64)AllocatedBuffer + CurOffset), WriteSize, &BytesWritten);
            TotalSize -= BytesWritten;
            CurOffset += BytesWritten;
            if (NtRet != STATUS_SUCCESS) break;
            if (BytesWritten == 0) break;
        }

        *written = CurOffset;
        return NtRet;
    }

    //NTSTATUS GetModuleBaseAddress(int processId, const char* moduleName, uint64_t* baseAddress)
    //{
    //    printf("Trying to Find: %s\n", moduleName);
    //    if (!moduleName)
    //        return STATUS_UNSUCCESSFUL;


    //    /*PEPROCESS process = NULL;
    //    if (!NT_SUCCESS(PsLookupProcessByProcessId((HANDLE)processId, &process)))
    //        return STATUS_UNSUCCESSFUL;

    //    printf("Found PEPROCESS\n\n", moduleName);

    //    PPEB pPeb = PsGetProcessPeb(process);

    //    if (!pPeb)
    //        return STATUS_UNSUCCESSFUL;

    //    printf("Found PEB\n\n", moduleName);*/

    //    ANSI_STRING ansiString = { 0 };
    //    RtlInitAnsiString(&ansiString, moduleName);

    //    if (ansiString.Length < 3)
    //        return STATUS_UNSUCCESSFUL;

    //    UNICODE_STRING compareString = { 0 };
    //    RtlAnsiStringToUnicodeString(&compareString, &ansiString, TRUE);

    //    if (compareString.Length < 3)
    //        return STATUS_UNSUCCESSFUL;

    //    PEPROCESS pProcess = NULL;
    //    NTSTATUS status = STATUS_UNSUCCESSFUL;
    //    if (NT_SUCCESS(PsLookupProcessByProcessId((HANDLE)processId, &pProcess)))
    //    {
    //        KAPC_STATE state;
    //        KeStackAttachProcess(pProcess, &state);
    //        PPEB pPeb = PsGetProcessPeb(pProcess);

    //        for (PLIST_ENTRY pListEntry = pPeb->Ldr->InMemoryOrderModuleList.Flink; pListEntry != &pPeb->Ldr->InMemoryOrderModuleList; pListEntry = pListEntry->Flink)
    //        {
    //            PLDR_DATA_TABLE_ENTRY pEntry = CONTAINING_RECORD(pListEntry, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);
    //            if (RtlCompareUnicodeString(&pEntry->BaseDllName, &compareString, TRUE) == 0) {
    //                *baseAddress = (uint64_t)pEntry->DllBase;
    //                status = STATUS_SUCCESS;
    //                break;
    //            }
    //        }

    //        KeUnstackDetachProcess(&state);
    //    }
    //    return status;
    //}

    NTSTATUS GetModuleBaseAddress(int processId, const char* moduleName, uint64_t* baseAddress)
    {
        ANSI_STRING ansiString;
        UNICODE_STRING compareString;
        KAPC_STATE state;
        NTSTATUS status = STATUS_UNSUCCESSFUL;
        PEPROCESS process = NULL;
        PPEB pPeb = NULL;

        RtlInitAnsiString(&ansiString, moduleName);
        RtlAnsiStringToUnicodeString(&compareString, &ansiString, TRUE);

        printf("Looking for module %d\n", processId);

        if (!NT_SUCCESS(PsLookupProcessByProcessId((HANDLE)processId, &process)))
            return STATUS_UNSUCCESSFUL;

        printf("Found process %d\n", processId);

        KeStackAttachProcess(process, &state);
        pPeb = PsGetProcessPeb(process);

        if (pPeb)
        {
            PPEB_LDR_DATA pLdr = (PPEB_LDR_DATA)pPeb->Ldr;

            if (pLdr)
            {
                for (PLIST_ENTRY list = (PLIST_ENTRY)pLdr->InMemoryOrderModuleList.Flink; list != &pLdr->InMemoryOrderModuleList; list = (PLIST_ENTRY)list->Flink)
                {
                    PLDR_DATA_TABLE_ENTRY pEntry = CONTAINING_RECORD(list, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);
                    printf("%wZ\n", pEntry->BaseDllName);
                    if (RtlCompareUnicodeString(&pEntry->BaseDllName, &compareString, TRUE) == 0)
                    {
                        *baseAddress = (uint64_t)pEntry->DllBase;
                        status = STATUS_SUCCESS;
                        break;
                    }
                }
            }
        }
        KeUnstackDetachProcess(&state);
        RtlFreeUnicodeString(&compareString);
        return status;
    }

    PVOID GetSystemModuleBase(LPCSTR moduleName) {

        PVOID moduleBase = NULL;
        ULONG info = 0;

        NTSTATUS status = ZwQuerySystemInformation(SystemModuleInformation, 0, info, &info);

        if (!info) {
            return moduleBase;
        }

        PRTL_PROCESS_MODULES modules = (PRTL_PROCESS_MODULES)ExAllocatePoolWithTag(NonPagedPool, info, 0x89109929301);

        status = ZwQuerySystemInformation(SystemModuleInformation, modules, info, &info);

        if (!NT_SUCCESS(status)) {
            return moduleBase;
        }

        PRTL_PROCESS_MODULE_INFORMATION module = modules->Modules;


        if (modules->NumberOfModules > 0) {

            if (!moduleName) {
                moduleBase = modules->Modules[0].ImageBase;
            }
            else {

                for (auto i = 0; i < modules->NumberOfModules; i++) {
                    printf("module[i].FullPathName: %s", module[i].FullPathName);
                    if (!strcmp((CHAR*)module[i].FullPathName, moduleName)) {
                        moduleBase = module[i].ImageBase;
                    }
                }
            }
        }

        if (modules) {
            ExFreePoolWithTag(modules, 0x89109929301);
        }

        return moduleBase;
    }

}
```

`Driver/core.h`:

```h
#pragma once
#include "stdafx.h"

namespace Core {
	PVOID GetSystemModuleBase(LPCSTR moduleName);


	//Sketch
	ULONG_PTR GetKernelDirBase();
	ULONG_PTR GetProcessCr3(PEPROCESS pProcess);
	NTSTATUS ReadVirtual(uint64_t dirbase, uint64_t address, uint8_t* buffer, SIZE_T size, SIZE_T* read);
	NTSTATUS WriteVirtual(uint64_t dirbase, uint64_t address, uint8_t* buffer, SIZE_T size, SIZE_T* written);

	//Safe Guarded Calls
	NTSTATUS GetModuleBaseAddress(int processId, const char* moduleName, uint64_t* baseAddress);
	NTSTATUS GetProcessBaseAddress(int pid, uint64_t* Address);
	NTSTATUS ReadProcessMemory(int pid, uint64_t Address, uint64_t AllocatedBuffer, SIZE_T size, SIZE_T* read);
	NTSTATUS WriteProcessMemory(int pid, uint64_t Address, uint64_t AllocatedBuffer, SIZE_T size, SIZE_T* written);


	ULONG_PTR GetKernelDirBase();
}
```

`Driver/driver.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{4A9C2A65-D849-44DB-AFB5-207F816B23A2}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>driver</RootNamespace>
    <ProjectName>driver</ProjectName>
    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <ALLOW_DATE_TIME>1</ALLOW_DATE_TIME>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <ALLOW_DATE_TIME>1</ALLOW_DATE_TIME>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <ALLOW_DATE_TIME>1</ALLOW_DATE_TIME>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
    <ALLOW_DATE_TIME>1</ALLOW_DATE_TIME>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <ALLOW_DATE_TIME>1</ALLOW_DATE_TIME>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <ALLOW_DATE_TIME>1</ALLOW_DATE_TIME>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <ALLOW_DATE_TIME>1</ALLOW_DATE_TIME>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <ALLOW_DATE_TIME>1</ALLOW_DATE_TIME>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>false</GenerateDebugInformation>
    </Link>
    <Link>
      <ProgramDatabaseFile />
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="cleaning.cpp" />
    <ClCompile Include="core.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="util.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="cleaning.h" />
    <ClInclude Include="core.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="structs.h" />
    <ClInclude Include="util.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Driver/driver.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="core.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="util.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="cleaning.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="core.h">
      <Filter>Driver Files</Filter>
    </ClInclude>
    <ClInclude Include="stdafx.h">
      <Filter>Driver Files</Filter>
    </ClInclude>
    <ClInclude Include="structs.h">
      <Filter>Driver Files</Filter>
    </ClInclude>
    <ClInclude Include="util.h">
      <Filter>Driver Files</Filter>
    </ClInclude>
    <ClInclude Include="cleaning.h">
      <Filter>Driver Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`Driver/driver.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <SignMode>Off</SignMode>
  </PropertyGroup>
</Project>
```

`Driver/main.cpp`:

```cpp
#pragma once
#include "stdafx.h"
#include "cleaning.h"

//these things need thier own file hooks.h and hooks.cpp
PVOID(__fastcall* oApiSetEditionSetProcessWindowStationEntryPointPointer)(PVOID);
PVOID(__fastcall* oApiSetEnsurePointerDeviceHasMonitorPointer)(PVOID);

/* 
  * FOR CHAINING: 
  *	ApiSetEnsurePointerDeviceHasMonitor(PDEVICE_OBJECT a1)
  * sig: \xE8\x00\x00\x00\x00\x85\xC0\x75\x43, x????xxxx (RVA 5)
  *		qword offset: (+0x78) (RVA 7)
  *		qword_1C0258DD0(PDEVICE_OBJECT)
  *
  * FOR USERMODE CALL:
  * __int64 __fastcall NtUserSetProcessWindowStation(struct _DEVICE_OBJECT *a1)
  * 
  * ApiSetEditionSetProcessWindowStationEntryPoint(PDEVICE_OBJECT)
  * sig: \xE8\x00\x00\x00\x00\x48\x98\x48\x83\xC4\x28\xC3\xCC\xCC\xCC\xCC\xCC\xCC\xCC\xCC\x48\x8B\xC4\x48\x89\x58\x08\x48\x89\x70\x10, x????xxxxxxxxxxxxxxxxxxxxxxxxxx
  *		qword offset: (+0x5E) (RVA 7)
  *		qword_1C0258DD0(PDEVICE_OBJECT)
  *
*/


PVOID ApiSetEnsurePointerDeviceHasMonitorHook(PDEVICE_OBJECT DeviceObject) 
{

#pragma region Validation
	{
		if (ExGetPreviousMode() != UserMode) {
			return oApiSetEditionSetProcessWindowStationEntryPointPointer(DeviceObject);
		}

		Communication comm = {};
		size_t read;


		if (!NT_SUCCESS(Core::ReadVirtual(Core::GetKernelDirBase(), (uint64_t)DeviceObject, (uint8_t*)&comm, sizeof(Communication), &read)) || comm.key != COMMUNICATION_KEY) {
			printf("[mapper] Invalid Usermode Call\n");
			return oApiSetEditionSetProcessWindowStationEntryPointPointer(DeviceObject);
		}
	}
#pragma endregion

	auto comm = (Communication*)DeviceObject;

	printf("[mapper] called w reason -> 0x%p\n", comm->key);
	printf("[mapper] called w request -> 0x%p\n", comm->request);

	switch (comm->request) 
	{
		case Request::READPROCESSMEMORY: 
		{
			if (!NT_SUCCESS(Core::ReadProcessMemory(comm->processID,
				comm->address,
				comm->buffer,
				comm->size,
				&comm->read)))
			{
				printf("[mapper] failed a read to -> 0x%llx\n", comm->address);
			}

		} break;
		case Request::WRITEPROCESSMEMORY:
		{

			if (!NT_SUCCESS(Core::WriteProcessMemory(comm->processID,
				comm->address,
				comm->buffer,
				comm->size,
				&comm->written)))
			{
				printf("[mapper] failed a write to -> 0x%llx\n", comm->address);
			};
		} break;
		case Request::GETMODULEBASE:
		{
			printf("comm->processID: %d, comm->moduleName: %s\n", comm->processID, comm->moduleName);
			uint64_t baseAddress = NULL;
			if (NT_SUCCESS(Core::GetModuleBaseAddress(comm->processID, comm->moduleName, &baseAddress)))
				comm->buffer = (uint64_t)baseAddress;
			else
				printf("[mapper] failed to find %s in %d\n", comm->moduleName, comm->processID);
		} break;
		case Request::GETBASE:
		{
			uint64_t baseAddress = NULL;
			if (NT_SUCCESS(Core::GetProcessBaseAddress(comm->processID, &baseAddress)))
				comm->buffer = (uint64_t)baseAddress;
			else
				printf("[mapper] process id: %d base: %p", comm->processID, baseAddress);
		} break;
		//we need a command to restore the original pointers, AND THATS ALL.
	}
	return NULL;
}

void* GetFunctionDataPointer(void* FunctionAddress, uint64_t DataPointerOffset)
{

	return 0;
}

void CleanTraces(EntryParams* params)
{
	uint64_t entryPoint = params->entryPoint;
	uint32_t poolBase = params->poolBase;
	uint32_t size = params->size;

	if (NT_SUCCESS(Cleaning::NullPageFrameNumbers(poolBase, size)))
		printf("[mapper] Nulled Page Frame Number\n");
	else
		printf("[mapper] Failed to Null Page Frame Numbers\n");

	if (NT_SUCCESS(Cleaning::CleanFromBigPools(params->poolBase)))
		printf("[mapper] Cleaned from Bigpools\n");
	else
		printf("[mapper] Failed to clean from Bigpools\n");
}


NTSTATUS DriverEntry(EntryParams* params) //damn this needs serious fixing... it's clunky
{
	if (!params)
		return STATUS_FAILED_DRIVER_ENTRY;

	printf("[mapper] Driver Entry: %xll Image Base: %xll Size: %xll\n", params->entryPoint, params->poolBase, params->size);

#pragma region win32base.sys
	auto win32kbase = Core::GetSystemModuleBase("\\SystemRoot\\System32\\win32kbase.sys");
	{

		if (!win32kbase) 
		{
			printf("[mapper] Failed to get Base Address!\n");
			return STATUS_FAILED_DRIVER_ENTRY;
		}

		printf("[mapper] win32kbase.sys -> 0x%p\n", win32kbase);
	}
#pragma endregion
#pragma region ApiSetEditionSetProcessWindowStationEntryPoint

	auto ApiSetEditionSetProcessWindowStationEntryPointAddress = Util::FindPattern(
		win32kbase, 
		"\xE8\x00\x00\x00\x00\x48\x98\x48\x83\xC4\x28\xC3\xCC\xCC\xCC\xCC\xCC\xCC\xCC\xCC\x48\x8B\xC4\x48\x89\x58\x08\x48\x89\x70\x10", 
		"x????xxxxxxxxxxxxxxxxxxxxxxxxxx");
	{
		if (!ApiSetEditionSetProcessWindowStationEntryPointAddress)
		{
			printf("[mapper] Unable to find ApiSetEditionSetProcessWindowStationEntryPoint signature!\n");
			return STATUS_FAILED_DRIVER_ENTRY;
		}
		ApiSetEditionSetProcessWindowStationEntryPointAddress = RVA(ApiSetEditionSetProcessWindowStationEntryPointAddress, 5);
		printf("[mapper] ApiSetEditionSetProcessWindowStationEntryPoint -> 0x%p\n", ApiSetEditionSetProcessWindowStationEntryPointAddress);
	}

	auto ApiSetEditionSetProcessWindowStationEntryPointDataPointer = RVA(ApiSetEditionSetProcessWindowStationEntryPointAddress + 0x5E, 7);
	{
		if (!ApiSetEditionSetProcessWindowStationEntryPointDataPointer)
		{
			printf("[mapper] Invalid ApiSetEditionSetProcessWindowStationEntryPoint Data Pointer!\n");
			return STATUS_FAILED_DRIVER_ENTRY;
		}
		printf("[mapper] ApiSetEditionSetProcessWindowStationEntryPoint Data Pointer -> 0x%p\n", 
			ApiSetEditionSetProcessWindowStationEntryPointAddress);
	}
#pragma endregion
#pragma region ApiSetEnsurePointerDeviceHasMonitor
	auto ApiSetEnsurePointerDeviceHasMonitorAddress = Util::FindPattern(win32kbase, "\xE8\x00\x00\x00\x00\x85\xC0\x75\x43", "x????xxxx");
	{
		if (!ApiSetEnsurePointerDeviceHasMonitorAddress) 
		{
			printf("[mapper] Unable to find ApiSetEnsurePointerDeviceHasMonitor signature!\n");
			return STATUS_FAILED_DRIVER_ENTRY;
		}
		ApiSetEnsurePointerDeviceHasMonitorAddress = RVA(ApiSetEnsurePointerDeviceHasMonitorAddress, 5);
		printf("[mapper] ApiSetEnsurePointerDeviceHasMonitor -> 0x%p\n", ApiSetEnsurePointerDeviceHasMonitorAddress);
	}

	auto ApiSetEnsurePointerDeviceHasMonitorDataPointer = RVA(ApiSetEnsurePointerDeviceHasMonitorAddress + 0x78, 7);
	{
		if (!ApiSetEnsurePointerDeviceHasMonitorDataPointer) 
		{
			printf("[mapper] Invalid ApiSetEnsurePointerDeviceHasMonitor Data Pointer!\n");
			return STATUS_FAILED_DRIVER_ENTRY;
		}
		printf("[mapper] ApiSetEnsurePointerDeviceHasMonitor Data Pointer -> 0x%p\n", ApiSetEnsurePointerDeviceHasMonitorDataPointer);
	}

#pragma endregion
#pragma region PointerSwapping
	{
		*(PVOID*)&oApiSetEnsurePointerDeviceHasMonitorPointer = InterlockedExchangePointer(
				(volatile PVOID*)ApiSetEnsurePointerDeviceHasMonitorDataPointer,
				ApiSetEnsurePointerDeviceHasMonitorHook);

		printf("[mapper] swapped pointer -> 0x%p to 0x%p\n", 
			ApiSetEnsurePointerDeviceHasMonitorDataPointer, ApiSetEnsurePointerDeviceHasMonitorHook);
	}

	{
		*(PVOID*)&oApiSetEditionSetProcessWindowStationEntryPointPointer = InterlockedExchangePointer(
				(volatile PVOID*)ApiSetEditionSetProcessWindowStationEntryPointDataPointer,
				ApiSetEnsurePointerDeviceHasMonitorAddress);

		printf("[mapper] swapped pointer -> 0x%p to 0x%p\n", 
			ApiSetEditionSetProcessWindowStationEntryPointDataPointer, ApiSetEnsurePointerDeviceHasMonitorAddress);
	}

#pragma endregion


	CleanTraces(params); //This should be NTSTATUS

	return STATUS_SUCCESS;
}

```

`Driver/stdafx.h`:

```h
#pragma once
#include <ntifs.h>
#include <ntddk.h>
#include <windef.h>
#include <ntimage.h>

#include "structs.h"

#define RVA(addr, size)			((PBYTE)(addr + *(DWORD*)(addr + ((size) - 4)) + size))
#define printf(text, ...)		(DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, text, ##__VA_ARGS__))
//#define WINVER_2004				(19041)
#define COMMUNICATION_KEY		(0xDEADBEEF)


typedef signed char        int8_t;
typedef short              int16_t;
typedef int                int32_t;
typedef long long          int64_t;
typedef unsigned char      uint8_t;
typedef unsigned short     uint16_t;
typedef unsigned int       uint32_t;
typedef unsigned long long uint64_t;

enum Request {
	GETBASE = 0,
	GETMODULEBASE = 1,
	READPROCESSMEMORY = 2,
	WRITEPROCESSMEMORY = 3,
	SIGSCAN = 4
};



struct Communication {

	uint64_t key;
	Request request;

	int processID;

	uint64_t address;
	const char* moduleName;

	uint64_t buffer;
	size_t size;

	union
	{
		size_t written;
		size_t read;
	};
};

struct EntryParams
{
	uint64_t poolBase;
	uint32_t entryPoint;
	uint32_t size;
};

extern "C" NTSTATUS ZwQuerySystemInformation(SYSTEM_INFORMATION_CLASS systemInformationClass, PVOID systemInformation, ULONG systemInformationLength, PULONG returnLength);
extern "C" NTKERNELAPI PVOID PsGetProcessSectionBaseAddress(PEPROCESS Process);
extern "C" NTKERNELAPI PPEB NTAPI PsGetProcessPeb(IN PEPROCESS Process);

#include "memory.h"
#include "util.h"
#include "core.h"
```

`Driver/structs.h`:

```h
#pragma once
#include "stdafx.h"

typedef enum _SYSTEM_INFORMATION_CLASS
{
	SystemInformationClassMin = 0,
	SystemBasicInformation = 0,
	SystemProcessorInformation = 1,
	SystemPerformanceInformation = 2,
	SystemTimeOfDayInformation = 3,
	SystemPathInformation = 4,
	SystemNotImplemented1 = 4,
	SystemProcessInformation = 5,
	SystemProcessesAndThreadsInformation = 5,
	SystemCallCountInfoInformation = 6,
	SystemCallCounts = 6,
	SystemDeviceInformation = 7,
	SystemConfigurationInformation = 7,
	SystemProcessorPerformanceInformation = 8,
	SystemProcessorTimes = 8,
	SystemFlagsInformation = 9,
	SystemGlobalFlag = 9,
	SystemCallTimeInformation = 10,
	SystemNotImplemented2 = 10,
	SystemModuleInformation = 11,
	SystemLocksInformation = 12,
	SystemLockInformation = 12,
	SystemStackTraceInformation = 13,
	SystemNotImplemented3 = 13,
	SystemPagedPoolInformation = 14,
	SystemNotImplemented4 = 14,
	SystemNonPagedPoolInformation = 15,
	SystemNotImplemented5 = 15,
	SystemHandleInformation = 16,
	SystemObjectInformation = 17,
	SystemPageFileInformation = 18,
	SystemPagefileInformation = 18,
	SystemVdmInstemulInformation = 19,
	SystemInstructionEmulationCounts = 19,
	SystemVdmBopInformation = 20,
	SystemInvalidInfoClass1 = 20,
	SystemFileCacheInformation = 21,
	SystemCacheInformation = 21,
	SystemPoolTagInformation = 22,
	SystemInterruptInformation = 23,
	SystemProcessorStatistics = 23,
	SystemDpcBehaviourInformation = 24,
	SystemDpcInformation = 24,
	SystemFullMemoryInformation = 25,
	SystemNotImplemented6 = 25,
	SystemLoadImage = 26,
	SystemUnloadImage = 27,
	SystemTimeAdjustmentInformation = 28,
	SystemTimeAdjustment = 28,
	SystemSummaryMemoryInformation = 29,
	SystemNotImplemented7 = 29,
	SystemNextEventIdInformation = 30,
	SystemNotImplemented8 = 30,
	SystemEventIdsInformation = 31,
	SystemNotImplemented9 = 31,
	SystemCrashDumpInformation = 32,
	SystemExceptionInformation = 33,
	SystemCrashDumpStateInformation = 34,
	SystemKernelDebuggerInformation = 35,
	SystemContextSwitchInformation = 36,
	SystemRegistryQuotaInformation = 37,
	SystemLoadAndCallImage = 38,
	SystemPrioritySeparation = 39,
	SystemPlugPlayBusInformation = 40,
	SystemNotImplemented10 = 40,
	SystemDockInformation = 41,
	SystemNotImplemented11 = 41,
	SystemInvalidInfoClass2 = 42,
	SystemProcessorSpeedInformation = 43,
	SystemInvalidInfoClass3 = 43,
	SystemCurrentTimeZoneInformation = 44,
	SystemTimeZoneInformation = 44,
	SystemLookasideInformation = 45,
	SystemSetTimeSlipEvent = 46,
	SystemCreateSession = 47,
	SystemDeleteSession = 48,
	SystemInvalidInfoClass4 = 49,
	SystemRangeStartInformation = 50,
	SystemVerifierInformation = 51,
	SystemAddVerifier = 52,
	SystemSessionProcessesInformation = 53,
	SystemInformationClassMax
} SYSTEM_INFORMATION_CLASS;

typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR  FullPathName[256];

} RTL_PROCESS_MODULE_INFORMATION, * PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES
{
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[1];

} RTL_PROCESS_MODULES, * PRTL_PROCESS_MODULES;

//0x7c8 bytes (sizeof)
struct _PEB
{
    UCHAR InheritedAddressSpace;                                            //0x0
    UCHAR ReadImageFileExecOptions;                                         //0x1
    UCHAR BeingDebugged;                                                    //0x2
    union
    {
        UCHAR BitField;                                                     //0x3
        struct
        {
            UCHAR ImageUsesLargePages : 1;                                    //0x3
            UCHAR IsProtectedProcess : 1;                                     //0x3
            UCHAR IsImageDynamicallyRelocated : 1;                            //0x3
            UCHAR SkipPatchingUser32Forwarders : 1;                           //0x3
            UCHAR IsPackagedProcess : 1;                                      //0x3
            UCHAR IsAppContainer : 1;                                         //0x3
            UCHAR IsProtectedProcessLight : 1;                                //0x3
            UCHAR IsLongPathAwareProcess : 1;                                 //0x3
        };
    };
    UCHAR Padding0[4];                                                      //0x4
    VOID* Mutant;                                                           //0x8
    VOID* ImageBaseAddress;                                                 //0x10
    struct _PEB_LDR_DATA* Ldr;                                              //0x18
    struct _RTL_USER_PROCESS_PARAMETERS* ProcessParameters;                 //0x20
    VOID* SubSystemData;                                                    //0x28
    VOID* ProcessHeap;                                                      //0x30
    struct _RTL_CRITICAL_SECTION* FastPebLock;                              //0x38
    union _SLIST_HEADER* volatile AtlThunkSListPtr;                         //0x40
    VOID* IFEOKey;                                                          //0x48
    union
    {
        ULONG CrossProcessFlags;                                            //0x50
        struct
        {
            ULONG ProcessInJob : 1;                                           //0x50
            ULONG ProcessInitializing : 1;                                    //0x50
            ULONG ProcessUsingVEH : 1;                                        //0x50
            ULONG ProcessUsingVCH : 1;                                        //0x50
            ULONG ProcessUsingFTH : 1;                                        //0x50
            ULONG ProcessPreviouslyThrottled : 1;                             //0x50
            ULONG ProcessCurrentlyThrottled : 1;                              //0x50
            ULONG ProcessImagesHotPatched : 1;                                //0x50
            ULONG ReservedBits0 : 24;                                         //0x50
        };
    };
    UCHAR Padding1[4];                                                      //0x54
    union
    {
        VOID* KernelCallbackTable;                                          //0x58
        VOID* UserSharedInfoPtr;                                            //0x58
    };
    ULONG SystemReserved;                                                   //0x60
    ULONG AtlThunkSListPtr32;                                               //0x64
    VOID* ApiSetMap;                                                        //0x68
    ULONG TlsExpansionCounter;                                              //0x70
    UCHAR Padding2[4];                                                      //0x74
    VOID* TlsBitmap;                                                        //0x78
    ULONG TlsBitmapBits[2];                                                 //0x80
    VOID* ReadOnlySharedMemoryBase;                                         //0x88
    VOID* SharedData;                                                       //0x90
    VOID** ReadOnlyStaticServerData;                                        //0x98
    VOID* AnsiCodePageData;                                                 //0xa0
    VOID* OemCodePageData;                                                  //0xa8
    VOID* UnicodeCaseTableData;                                             //0xb0
    ULONG NumberOfProcessors;                                               //0xb8
    ULONG NtGlobalFlag;                                                     //0xbc
    union _LARGE_INTEGER CriticalSectionTimeout;                            //0xc0
    ULONGLONG HeapSegmentReserve;                                           //0xc8
    ULONGLONG HeapSegmentCommit;                                            //0xd0
    ULONGLONG HeapDeCommitTotalFreeThreshold;                               //0xd8
    ULONGLONG HeapDeCommitFreeBlockThreshold;                               //0xe0
    ULONG NumberOfHeaps;                                                    //0xe8
    ULONG MaximumNumberOfHeaps;                                             //0xec
    VOID** ProcessHeaps;                                                    //0xf0
    VOID* GdiSharedHandleTable;                                             //0xf8
    VOID* ProcessStarterHelper;                                             //0x100
    ULONG GdiDCAttributeList;                                               //0x108
    UCHAR Padding3[4];                                                      //0x10c
    struct _RTL_CRITICAL_SECTION* LoaderLock;                               //0x110
    ULONG OSMajorVersion;                                                   //0x118
    ULONG OSMinorVersion;                                                   //0x11c
    USHORT OSBuildNumber;                                                   //0x120
    USHORT OSCSDVersion;                                                    //0x122
    ULONG OSPlatformId;                                                     //0x124
    ULONG ImageSubsystem;                                                   //0x128
    ULONG ImageSubsystemMajorVersion;                                       //0x12c
    ULONG ImageSubsystemMinorVersion;                                       //0x130
    UCHAR Padding4[4];                                                      //0x134
    ULONGLONG ActiveProcessAffinityMask;                                    //0x138
    ULONG GdiHandleBuffer[60];                                              //0x140
    VOID(*PostProcessInitRoutine)();                                       //0x230
    VOID* TlsExpansionBitmap;                                               //0x238
    ULONG TlsExpansionBitmapBits[32];                                       //0x240
    ULONG SessionId;                                                        //0x2c0
    UCHAR Padding5[4];                                                      //0x2c4
    union _ULARGE_INTEGER AppCompatFlags;                                   //0x2c8
    union _ULARGE_INTEGER AppCompatFlagsUser;                               //0x2d0
    VOID* pShimData;                                                        //0x2d8
    VOID* AppCompatInfo;                                                    //0x2e0
    struct _UNICODE_STRING CSDVersion;                                      //0x2e8
    struct _ACTIVATION_CONTEXT_DATA* ActivationContextData;                 //0x2f8
    struct _ASSEMBLY_STORAGE_MAP* ProcessAssemblyStorageMap;                //0x300
    struct _ACTIVATION_CONTEXT_DATA* SystemDefaultActivationContextData;    //0x308
    struct _ASSEMBLY_STORAGE_MAP* SystemAssemblyStorageMap;                 //0x310
    ULONGLONG MinimumStackCommit;                                           //0x318
    VOID* SparePointers[4];                                                 //0x320
    ULONG SpareUlongs[5];                                                   //0x340
    VOID* WerRegistrationData;                                              //0x358
    VOID* WerShipAssertPtr;                                                 //0x360
    VOID* pUnused;                                                          //0x368
    VOID* pImageHeaderHash;                                                 //0x370
    union
    {
        ULONG TracingFlags;                                                 //0x378
        struct
        {
            ULONG HeapTracingEnabled : 1;                                     //0x378
            ULONG CritSecTracingEnabled : 1;                                  //0x378
            ULONG LibLoaderTracingEnabled : 1;                                //0x378
            ULONG SpareTracingBits : 29;                                      //0x378
        };
    };
    UCHAR Padding6[4];                                                      //0x37c
    ULONGLONG CsrServerReadOnlySharedMemoryBase;                            //0x380
    ULONGLONG TppWorkerpListLock;                                           //0x388
    struct _LIST_ENTRY TppWorkerpList;                                      //0x390
    VOID* WaitOnAddressHashTable[128];                                      //0x3a0
    VOID* TelemetryCoverageHeader;                                          //0x7a0
    ULONG CloudFileFlags;                                                   //0x7a8
    ULONG CloudFileDiagFlags;                                               //0x7ac
    CHAR PlaceholderCompatibilityMode;                                      //0x7b0
    CHAR PlaceholderCompatibilityModeReserved[7];                           //0x7b1
    struct _LEAP_SECOND_DATA* LeapSecondData;                               //0x7b8
    union
    {
        ULONG LeapSecondFlags;                                              //0x7c0
        struct
        {
            ULONG SixtySecondEnabled : 1;                                     //0x7c0
            ULONG Reserved : 31;                                              //0x7c0
        };
    };
    ULONG NtGlobalFlag2;                                                    //0x7c4
};


//0x58 bytes (sizeof)
typedef struct _PEB_LDR_DATA
{
    ULONG Length;                                                           //0x0
    UCHAR Initialized;                                                      //0x4
    VOID* SsHandle;                                                         //0x8
    struct _LIST_ENTRY InLoadOrderModuleList;                               //0x10
    struct _LIST_ENTRY InMemoryOrderModuleList;                             //0x20
    struct _LIST_ENTRY InInitializationOrderModuleList;                     //0x30
    VOID* EntryInProgress;                                                  //0x40
    UCHAR ShutdownInProgress;                                               //0x48
    VOID* ShutdownThreadId;                                                 //0x50
} _PEB_LDR_DATA, * PPEB_LDR_DATA;

//0x120 bytes (sizeof)
typedef struct _LDR_DATA_TABLE_ENTRY
{
    struct _LIST_ENTRY InLoadOrderLinks;                                    //0x0
    struct _LIST_ENTRY InMemoryOrderLinks;                                  //0x10
    struct _LIST_ENTRY InInitializationOrderLinks;                          //0x20
    VOID* DllBase;                                                          //0x30
    VOID* EntryPoint;                                                       //0x38
    ULONG SizeOfImage;                                                      //0x40
    struct _UNICODE_STRING FullDllName;                                     //0x48
    struct _UNICODE_STRING BaseDllName;                                     //0x58
    union
    {
        UCHAR FlagGroup[4];                                                 //0x68
        ULONG Flags;                                                        //0x68
        struct
        {
            ULONG PackagedBinary : 1;                                         //0x68
            ULONG MarkedForRemoval : 1;                                       //0x68
            ULONG ImageDll : 1;                                               //0x68
            ULONG LoadNotificationsSent : 1;                                  //0x68
            ULONG TelemetryEntryProcessed : 1;                                //0x68
            ULONG ProcessStaticImport : 1;                                    //0x68
            ULONG InLegacyLists : 1;                                          //0x68
            ULONG InIndexes : 1;                                              //0x68
            ULONG ShimDll : 1;                                                //0x68
            ULONG InExceptionTable : 1;                                       //0x68
            ULONG ReservedFlags1 : 2;                                         //0x68
            ULONG LoadInProgress : 1;                                         //0x68
            ULONG LoadConfigProcessed : 1;                                    //0x68
            ULONG EntryProcessed : 1;                                         //0x68
            ULONG ProtectDelayLoad : 1;                                       //0x68
            ULONG ReservedFlags3 : 2;                                         //0x68
            ULONG DontCallForThreads : 1;                                     //0x68
            ULONG ProcessAttachCalled : 1;                                    //0x68
            ULONG ProcessAttachFailed : 1;                                    //0x68
            ULONG CorDeferredValidate : 1;                                    //0x68
            ULONG CorImage : 1;                                               //0x68
            ULONG DontRelocate : 1;                                           //0x68
            ULONG CorILOnly : 1;                                              //0x68
            ULONG ChpeImage : 1;                                              //0x68
            ULONG ReservedFlags5 : 2;                                         //0x68
            ULONG Redirected : 1;                                             //0x68
            ULONG ReservedFlags6 : 2;                                         //0x68
            ULONG CompatDatabaseProcessed : 1;                                //0x68
        };
    };
    USHORT ObsoleteLoadCount;                                               //0x6c
    USHORT TlsIndex;                                                        //0x6e
    struct _LIST_ENTRY HashLinks;                                           //0x70
    ULONG TimeDateStamp;                                                    //0x80
    struct _ACTIVATION_CONTEXT* EntryPointActivationContext;                //0x88
    VOID* Lock;                                                             //0x90
    struct _LDR_DDAG_NODE* DdagNode;                                        //0x98
    struct _LIST_ENTRY NodeModuleLink;                                      //0xa0
    struct _LDRP_LOAD_CONTEXT* LoadContext;                                 //0xb0
    VOID* ParentDllBase;                                                    //0xb8
    VOID* SwitchBackContext;                                                //0xc0
    struct _RTL_BALANCED_NODE BaseAddressIndexNode;                         //0xc8
    struct _RTL_BALANCED_NODE MappingInfoIndexNode;                         //0xe0
    ULONGLONG OriginalBase;                                                 //0xf8
    union _LARGE_INTEGER LoadTime;                                          //0x100
    ULONG BaseNameHashValue;                                                //0x108
    enum _LDR_DLL_LOAD_REASON LoadReason;                                   //0x10c
    ULONG ImplicitPathOptions;                                              //0x110
    ULONG ReferenceCount;                                                   //0x114
    ULONG DependentLoadFlags;                                               //0x118
    UCHAR SigningLevel;                                                     //0x11c
} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;


//0x18 bytes (sizeof)
typedef struct _POOL_TRACKER_BIG_PAGES
{
    volatile ULONGLONG Va;                                                  //0x0
    ULONG Key;                                                              //0x8
    ULONG Pattern : 8;                                                        //0xc
    ULONG PoolType : 12;                                                      //0xc
    ULONG SlushSize : 12;                                                     //0xc
    ULONGLONG NumberOfBytes;                                                //0x10
}POOL_TRACKER_BIG_PAGES, * PPOOL_TRACKER_BIG_PAGES;

//0x7c8 bytes (sizeof)
typedef struct _PEB64
{
    UCHAR InheritedAddressSpace;                                            //0x0
    UCHAR ReadImageFileExecOptions;                                         //0x1
    UCHAR BeingDebugged;                                                    //0x2
    union
    {
        UCHAR BitField;                                                     //0x3
        struct
        {
            UCHAR ImageUsesLargePages : 1;                                    //0x3
            UCHAR IsProtectedProcess : 1;                                     //0x3
            UCHAR IsImageDynamicallyRelocated : 1;                            //0x3
            UCHAR SkipPatchingUser32Forwarders : 1;                           //0x3
            UCHAR IsPackagedProcess : 1;                                      //0x3
            UCHAR IsAppContainer : 1;                                         //0x3
            UCHAR IsProtectedProcessLight : 1;                                //0x3
            UCHAR IsLongPathAwareProcess : 1;                                 //0x3
        };
    };
    UCHAR Padding0[4];                                                      //0x4
    ULONGLONG Mutant;                                                       //0x8
    ULONGLONG ImageBaseAddress;                                             //0x10
    ULONGLONG Ldr;                                                          //0x18
    ULONGLONG ProcessParameters;                                            //0x20
    ULONGLONG SubSystemData;                                                //0x28
    ULONGLONG ProcessHeap;                                                  //0x30
    ULONGLONG FastPebLock;                                                  //0x38
    ULONGLONG AtlThunkSListPtr;                                             //0x40
    ULONGLONG IFEOKey;                                                      //0x48
    union
    {
        ULONG CrossProcessFlags;                                            //0x50
        struct
        {
            ULONG ProcessInJob : 1;                                           //0x50
            ULONG ProcessInitializing : 1;                                    //0x50
            ULONG ProcessUsingVEH : 1;                                        //0x50
            ULONG ProcessUsingVCH : 1;                                        //0x50
            ULONG ProcessUsingFTH : 1;                                        //0x50
            ULONG ProcessPreviouslyThrottled : 1;                             //0x50
            ULONG ProcessCurrentlyThrottled : 1;                              //0x50
            ULONG ProcessImagesHotPatched : 1;                                //0x50
            ULONG ReservedBits0 : 24;                                         //0x50
        };
    };
    UCHAR Padding1[4];                                                      //0x54
    union
    {
        ULONGLONG KernelCallbackTable;                                      //0x58
        ULONGLONG UserSharedInfoPtr;                                        //0x58
    };
    ULONG SystemReserved;                                                   //0x60
    ULONG AtlThunkSListPtr32;                                               //0x64
    ULONGLONG ApiSetMap;                                                    //0x68
    ULONG TlsExpansionCounter;                                              //0x70
    UCHAR Padding2[4];                                                      //0x74
    ULONGLONG TlsBitmap;                                                    //0x78
    ULONG TlsBitmapBits[2];                                                 //0x80
    ULONGLONG ReadOnlySharedMemoryBase;                                     //0x88
    ULONGLONG SharedData;                                                   //0x90
    ULONGLONG ReadOnlyStaticServerData;                                     //0x98
    ULONGLONG AnsiCodePageData;                                             //0xa0
    ULONGLONG OemCodePageData;                                              //0xa8
    ULONGLONG UnicodeCaseTableData;                                         //0xb0
    ULONG NumberOfProcessors;                                               //0xb8
    ULONG NtGlobalFlag;                                                     //0xbc
    union _LARGE_INTEGER CriticalSectionTimeout;                            //0xc0
    ULONGLONG HeapSegmentReserve;                                           //0xc8
    ULONGLONG HeapSegmentCommit;                                            //0xd0
    ULONGLONG HeapDeCommitTotalFreeThreshold;                               //0xd8
    ULONGLONG HeapDeCommitFreeBlockThreshold;                               //0xe0
    ULONG NumberOfHeaps;                                                    //0xe8
    ULONG MaximumNumberOfHeaps;                                             //0xec
    ULONGLONG ProcessHeaps;                                                 //0xf0
    ULONGLONG GdiSharedHandleTable;                                         //0xf8
    ULONGLONG ProcessStarterHelper;                                         //0x100
    ULONG GdiDCAttributeList;                                               //0x108
    UCHAR Padding3[4];                                                      //0x10c
    ULONGLONG LoaderLock;                                                   //0x110
    ULONG OSMajorVersion;                                                   //0x118
    ULONG OSMinorVersion;                                                   //0x11c
    USHORT OSBuildNumber;                                                   //0x120
    USHORT OSCSDVersion;                                                    //0x122
    ULONG OSPlatformId;                                                     //0x124
    ULONG ImageSubsystem;                                                   //0x128
    ULONG ImageSubsystemMajorVersion;                                       //0x12c
    ULONG ImageSubsystemMinorVersion;                                       //0x130
    UCHAR Padding4[4];                                                      //0x134
    ULONGLONG ActiveProcessAffinityMask;                                    //0x138
    ULONG GdiHandleBuffer[60];                                              //0x140
    ULONGLONG PostProcessInitRoutine;                                       //0x230
    ULONGLONG TlsExpansionBitmap;                                           //0x238
    ULONG TlsExpansionBitmapBits[32];                                       //0x240
    ULONG SessionId;                                                        //0x2c0
    UCHAR Padding5[4];                                                      //0x2c4
    union _ULARGE_INTEGER AppCompatFlags;                                   //0x2c8
    union _ULARGE_INTEGER AppCompatFlagsUser;                               //0x2d0
    ULONGLONG pShimData;                                                    //0x2d8
    ULONGLONG AppCompatInfo;                                                //0x2e0
    struct _STRING64 CSDVersion;                                            //0x2e8
    ULONGLONG ActivationContextData;                                        //0x2f8
    ULONGLONG ProcessAssemblyStorageMap;                                    //0x300
    ULONGLONG SystemDefaultActivationContextData;                           //0x308
    ULONGLONG SystemAssemblyStorageMap;                                     //0x310
    ULONGLONG MinimumStackCommit;                                           //0x318
    ULONGLONG SparePointers[4];                                             //0x320
    ULONG SpareUlongs[5];                                                   //0x340
    ULONGLONG WerRegistrationData;                                          //0x358
    ULONGLONG WerShipAssertPtr;                                             //0x360
    ULONGLONG pUnused;                                                      //0x368
    ULONGLONG pImageHeaderHash;                                             //0x370
    union
    {
        ULONG TracingFlags;                                                 //0x378
        struct
        {
            ULONG HeapTracingEnabled : 1;                                     //0x378
            ULONG CritSecTracingEnabled : 1;                                  //0x378
            ULONG LibLoaderTracingEnabled : 1;                                //0x378
            ULONG SpareTracingBits : 29;                                      //0x378
        };
    };
    UCHAR Padding6[4];                                                      //0x37c
    ULONGLONG CsrServerReadOnlySharedMemoryBase;                            //0x380
    ULONGLONG TppWorkerpListLock;                                           //0x388
    struct LIST_ENTRY64 TppWorkerpList;                                     //0x390
    ULONGLONG WaitOnAddressHashTable[128];                                  //0x3a0
    ULONGLONG TelemetryCoverageHeader;                                      //0x7a0
    ULONG CloudFileFlags;                                                   //0x7a8
    ULONG CloudFileDiagFlags;                                               //0x7ac
    CHAR PlaceholderCompatibilityMode;                                      //0x7b0
    CHAR PlaceholderCompatibilityModeReserved[7];                           //0x7b1
    ULONGLONG LeapSecondData;                                               //0x7b8
    union
    {
        ULONG LeapSecondFlags;                                              //0x7c0
        struct
        {
            ULONG SixtySecondEnabled : 1;                                     //0x7c0
            ULONG Reserved : 31;                                              //0x7c0
        };
    };
    ULONG NtGlobalFlag2;                                                    //0x7c4
}PEB64, *PPEB64;
```

`Driver/util.cpp`:

```cpp
#pragma once
#include "util.h"


namespace Util {

    PIMAGE_NT_HEADERS getHeader(PVOID module) {
        return (PIMAGE_NT_HEADERS)((PBYTE)module + PIMAGE_DOS_HEADER(module)->e_lfanew);
    }

    PBYTE FindPattern(PVOID module, DWORD size, LPCSTR pattern, LPCSTR mask) {

        auto checkMask = [](PBYTE buffer, LPCSTR pattern, LPCSTR mask) -> BOOL
        {
            for (auto x = buffer; *mask; pattern++, mask++, x++) {
                auto addr = *(BYTE*)(pattern);
                if (addr != *x && *mask != '?')
                    return FALSE;
            }

            return TRUE;
        };

        for (auto x = 0; x < size - strlen(mask); x++) {

            auto addr = (PBYTE)module + x;
            if (checkMask(addr, pattern, mask))
                return addr;
        }

        return NULL;
    }

    PBYTE FindPattern(PVOID base, LPCSTR pattern, LPCSTR mask) {

        auto header = getHeader(base);
        auto section = IMAGE_FIRST_SECTION(header);

        for (auto x = 0; x < header->FileHeader.NumberOfSections; x++, section++) {

            /*
            * Avoids non paged memory,
            * As well as greatly speeds up the process of scanning 30+ sections.
            */
            if (!memcmp(section->Name, ".text", 5) || !memcmp(section->Name, "PAGE", 4)) {
                auto addr = FindPattern((PBYTE)base + section->VirtualAddress, section->Misc.VirtualSize, pattern, mask);
                if (addr) {
                    printf("[mapper] Found in Section -> [ %s ]", section->Name);
                    return addr;
                }
            }
        }

        return NULL;
    }

}

```

`Driver/util.h`:

```h
#pragma once
#include "stdafx.h"


//https://ntdiff.github.io/
#define WINDOWS_1803 17134
#define WINDOWS_1809 17763
#define WINDOWS_1903 18362
#define WINDOWS_1909 18363
#define WINDOWS_2004 19041
#define WINDOWS_20H2 19569
#define WINDOWS_21H1 20180

namespace Util {

	PIMAGE_NT_HEADERS getHeader(PVOID module);
	PBYTE FindPattern(PVOID base, LPCSTR pattern, LPCSTR mask);
}
```

`Example/Example.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{136b1d30-4a9a-4635-8d4c-01a050f1d50d}</ProjectGuid>
    <RootNamespace>Example</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="..\Usermode\memory.cpp" />
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\Usermode\memory.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Example/Example.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Memory">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Project">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\Usermode\memory.cpp">
      <Filter>Memory</Filter>
    </ClCompile>
    <ClCompile Include="main.cpp">
      <Filter>Project</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\Usermode\memory.h">
      <Filter>Memory</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`Example/Example.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`Example/main.cpp`:

```cpp
// Example.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <iostream>
#include <Windows.h>
#include "..\Usermode\memory.h"

Memory* pMem = nullptr;
int main()
{
    LoadLibraryA("user32.dll");

    uint32_t processId = GetCurrentProcessId();
    pMem = new Memory(processId, { "user32.dll" });

    std::cout << "Process Base: " << pMem->base  << std::endl;
    std::cout << "user32.dll Base: " << pMem->moduleBases["user32.dll"] << std::endl;

    int x = 100;
    std::cout << "Rpm: " << pMem->Rpm<int>((uint64_t)&x) << std::endl;

    pMem->Wpm<int>((uint64_t)&x, 15);
    std::cout << "After Wpm: " << x << std::endl;

    return 0;
}
```

`README.md`:

```md
# DoubleDataPointer
Double data pointer communication in to the kernel mode, the driver should be manually mapped into the kernel. Useful for bypassing Anti-Cheat solutions.

This project points a data pointer at another data pointer which is pointed to memory inside of the driver. This allows a user to send commands through a uncommonly used windows API, and execute commands at a kernel permission level.

# Features
- Read Memory
- Write Memory
- Nulls Page Frame numbers of the driver (so it is harder to find the pages with the driver stub)
- Clears Big pools (Usually ExAllocatePool is used to allocate the driver when manually mapping, this takes the driver out of the pig pool tables)
- Physical Memory Read/Write (KeStackAttach can be detected, which is used inside of MmCopyVirtualMemory)
- Uses 2 data pointers so that a surface level check on the first pointer is not outside of a valid module

# Limitations/Detections
- RIP will be outisde of a valid memory region whenever a stack frame is captured from NMI callbacks. This way anticheats can flag you.
- This project creates alertable threads that can be indexed and captured, later anylyzed or checked for abnormalities.
- The data pointer itself can be directly verified to point to a specific region.

This project was created ages ago, it is most definetly detected.

```

`Usermode/memory.cpp`:

```cpp
#pragma once
#include "memory.h"

/*
* __int64 __fastcall NtUserSetProcessWindowStation(struct _DEVICE_OBJECT *a1)
*/
static NTSTATUS(*NtUserCloseWindowStation)(PVOID a1) = nullptr;


Memory::Memory(int32_t pid, std::vector<std::string> moduleNames)
{
	LoadLibraryA("user32.dll");
	Setup("NtUserSetProcessWindowStation");

	processId = pid;

	for (const auto & moduleName : moduleNames)
	{
		uint64_t baseAddress = NULL;
		if (GetModuleBaseAddressFromKernel(processId, moduleName.c_str(), &baseAddress))
			moduleBases.at(moduleName) = baseAddress;
			
	}

	GetProcessBaseAddressFromKernel(pid, &this->base);
}

bool Memory::Rpm(uint64_t address, void* buffer, size_t size)
{
	return ReadMemoryFromKernel(processId, address, buffer, size);
}

bool Memory::Wpm(uint64_t address, void* buffer, size_t size)
{
	return WriteMemoryFromKernel(processId, address, buffer, size);
}



BOOL Memory::Setup(LPCSTR routineName) {
	auto win32u = LoadLibraryA("win32u.dll");
	if (!win32u) {
		return FALSE;
	}

	auto addr = GetProcAddress(win32u, routineName);
	if (!addr) {
		return FALSE;
	}

	*(PVOID*)&NtUserCloseWindowStation = addr;
	return TRUE;
}

bool Memory::GetProcessBaseAddressFromKernel(int processID, uint64_t* baseAddress)
{
	Communication request = {};
	SecureZeroMemory(&request, sizeof(Communication));
	request.request = Request::GETBASE;
	request.key = COMMUNICATION_KEY;
	request.processID = processID;
	request.buffer = 0;
	NtUserCloseWindowStation(&request);

	*baseAddress = request.buffer;
	return (request.buffer != NULL);
}

bool Memory::GetModuleBaseAddressFromKernel(int processID, const char* moduleName, uint64_t* baseAddress)
{
	Communication request = {};
	SecureZeroMemory(&request, sizeof(Communication));
	request.request = Request::GETMODULEBASE;
	request.key = COMMUNICATION_KEY;
	request.processID = processID;
	request.moduleName = moduleName;
	request.buffer = 0;
	NtUserCloseWindowStation(&request);

	*baseAddress = request.buffer;
	return (request.buffer != NULL);
}


bool Memory::ReadMemoryFromKernel(int processId, uint64_t address, void* buffer, size_t size)
{
	size_t read = NULL;
	Communication request = {};
	SecureZeroMemory(&request, sizeof(Communication));

	request.request = Request::READPROCESSMEMORY;
	request.key = COMMUNICATION_KEY;
	request.address = address;
	request.buffer = (uint64_t)buffer;
	request.size = size;
	request.processID = processId;
	request.read = read;

	NtUserCloseWindowStation(&request);
	return (buffer != NULL);
}

bool Memory::WriteMemoryFromKernel(int processId, uint64_t address, void* buffer, size_t size)
{
	size_t written = NULL;
	Communication request = {};
	SecureZeroMemory(&request, sizeof(Communication));

	request.request = Request::WRITEPROCESSMEMORY;
	request.key = COMMUNICATION_KEY;
	request.address = address;
	request.buffer = (uint64_t)buffer;
	request.size = size;
	request.processID = processId;
	request.read = written;

	NtUserCloseWindowStation(&request);
	return (buffer != NULL);
}

```

`Usermode/memory.h`:

```h
#pragma once
#include <Windows.h>
#include <vector>
#include <map>

class Memory
{
public:
	Memory(int32_t pid, std::vector<std::string> ModuleNames = {});

	template<typename T>
	T Rpm(uint64_t address);
	bool Rpm(uint64_t address, void* buffer, size_t size);

	template<typename T>
	void Wpm(uint64_t address, T value);
	bool Wpm(uint64_t address, void* buffer, size_t size);



	std::map<std::string, uint64_t> moduleBases;

	uint64_t base = 0;
private:
	/*
	* Communication
	*/
#define COMMUNICATION_KEY 0xDEADBEEF
	int32_t processId = 0;

	enum Request {
		GETBASE = 0,
		GETMODULEBASE = 1,
		READPROCESSMEMORY = 2,
		WRITEPROCESSMEMORY = 3,
		SIGSCAN = 4
	};
	struct Communication {

		uint64_t key;
		Request request;

		int processID;

		uint64_t address;
		const char* moduleName;

		uint64_t buffer;
		size_t size;

		union
		{
			size_t written;
			size_t read;
		};
	};

	BOOL Setup(LPCSTR routineName);
	bool GetProcessBaseAddressFromKernel(int processID, uint64_t* baseAddress);
	bool GetModuleBaseAddressFromKernel(int processID, const char* moduleName, uint64_t* baseAddress);
	bool ReadMemoryFromKernel(int processId, uint64_t address, void* buffer, size_t size);
	bool WriteMemoryFromKernel(int processId, uint64_t address, void* buffer, size_t size);
}; extern Memory* pMem;

template<typename T>
inline T Memory::Rpm(uint64_t address)
{
	T buffer;
	Rpm(address, &buffer, sizeof(T));
	return buffer;
}

template<typename T>
inline void Memory::Wpm(uint64_t address, T value)
{
	Wpm(address, &value, sizeof(T));
}

```